{
  "filePath" : "/home/maryam/clearblue/files/android-source-35/android/view/ViewRootImpl.java",
  "packageName" : "android.view",
  "className" : "ViewRootImpl",
  "comment" : "\n * The top of a view hierarchy, implementing the needed protocol between View\n * and the WindowManager.  This is for the most part an internal implementation\n * detail of {@link WindowManagerGlobal}.\n *\n * {@hide}\n ",
  "links" : [ "android.view.WindowManagerGlobal" ],
  "variables" : [ {
    "name" : "TAG",
    "type" : "String",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "DBG",
    "type" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "LOCAL_LOGV",
    "type" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "DEBUG_DRAW",
    "type" : "boolean",
    "comment" : " @noinspection PointlessBooleanExpression",
    "links" : [ ]
  }, {
    "name" : "DEBUG_LAYOUT",
    "type" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "DEBUG_DIALOG",
    "type" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "DEBUG_INPUT_RESIZE",
    "type" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "DEBUG_ORIENTATION",
    "type" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "DEBUG_TRACKBALL",
    "type" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "DEBUG_IMF",
    "type" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "DEBUG_CONFIGURATION",
    "type" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "DEBUG_FPS",
    "type" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "DEBUG_INPUT_STAGES",
    "type" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "DEBUG_KEEP_SCREEN_ON",
    "type" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "DEBUG_CONTENT_CAPTURE",
    "type" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "DEBUG_SCROLL_CAPTURE",
    "type" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "DEBUG_TOUCH_NAVIGATION",
    "type" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "DEBUG_BLAST",
    "type" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "DEBUG_SENSITIVE_CONTENT",
    "type" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "LOGTAG_INPUT_FOCUS",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "LOGTAG_VIEWROOT_DRAW_EVENT",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "MT_RENDERER_AVAILABLE",
    "type" : "boolean",
    "comment" : "\n     * Set to false if we do not want to use the multi threaded renderer even though\n     * threaded renderer (aka hardware renderering) is used. Note that by disabling\n     * this, WindowCallbacks will not fire.\n     ",
    "links" : [ ]
  }, {
    "name" : "ENABLE_INPUT_LATENCY_TRACKING",
    "type" : "boolean",
    "comment" : "\n     * Whether or not to report end-to-end input latency. Can be disabled temporarily as a\n     * risk mitigation against potential jank caused by acquiring a weak reference\n     * per frame.\n     ",
    "links" : [ ]
  }, {
    "name" : "USE_ASYNC_PERFORM_HAPTIC_FEEDBACK",
    "type" : "boolean",
    "comment" : "\n     * Controls whether to use the new oneway performHapticFeedback call. This returns\n     * true in a few more conditions, but doesn't affect which haptics happen. Notably, it\n     * makes the call to performHapticFeedback non-blocking, which reduces potential UI jank.\n     * This is intended as a temporary flag, ultimately becoming permanently 'true'.\n     ",
    "links" : [ ]
  }, {
    "name" : "CLIENT_TRANSIENT",
    "type" : "boolean",
    "comment" : "\n     * Whether the client (system UI) is handling the transient gesture and the corresponding\n     * animation.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "CLIENT_IMMERSIVE_CONFIRMATION",
    "type" : "boolean",
    "comment" : "\n     * Whether the client (system UI) is handling the immersive confirmation window. If\n     * {@link CLIENT_TRANSIENT} is set to true, the immersive confirmation window will always be the\n     * client instance and this flag will be ignored. Otherwise, the immersive confirmation window\n     * can be switched freely by this flag.\n     * @hide\n     ",
    "links" : [ "CLIENT_TRANSIENT" ]
  }, {
    "name" : "PROPERTY_PROFILE_RENDERING",
    "type" : "String",
    "comment" : "\n     * Set this system property to true to force the view hierarchy to render\n     * at 60 Hz. This can be used to measure the potential framerate.\n     ",
    "links" : [ ]
  }, {
    "name" : "MAX_TRACKBALL_DELAY",
    "type" : "int",
    "comment" : "\n     * Maximum time we allow the user to roll the trackball enough to generate\n     * a key event, before resetting the counters.\n     ",
    "links" : [ ]
  }, {
    "name" : "CONTENT_CAPTURE_ENABLED_NOT_CHECKED",
    "type" : "int",
    "comment" : "\n     * Initial value for {@link #mContentCaptureEnabled}.\n     ",
    "links" : [ "#mContentCaptureEnabled" ]
  }, {
    "name" : "CONTENT_CAPTURE_ENABLED_TRUE",
    "type" : "int",
    "comment" : "\n     * Value for {@link #mContentCaptureEnabled} when it was checked and set to {@code true}.\n     ",
    "links" : [ "#mContentCaptureEnabled" ]
  }, {
    "name" : "CONTENT_CAPTURE_ENABLED_FALSE",
    "type" : "int",
    "comment" : "\n     * Value for {@link #mContentCaptureEnabled} when it was checked and set to {@code false}.\n     ",
    "links" : [ "#mContentCaptureEnabled" ]
  }, {
    "name" : "SCROLL_CAPTURE_REQUEST_TIMEOUT_MILLIS",
    "type" : "int",
    "comment" : "\n     * Maximum time to wait for {@link View#dispatchScrollCaptureSearch} to complete.\n     ",
    "links" : [ "android.view.View#dispatchScrollCaptureSearch" ]
  }, {
    "name" : "UNSET_SYNC_ID",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "INFREQUENT_UPDATE_INTERVAL_MILLIS",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "INFREQUENT_UPDATE_COUNTS",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "INTERMITTENT_STATE_NOT_INTERMITTENT",
    "type" : "int",
    "comment" : "\n     * The {@link #intermittentUpdateState()} value when the ViewRootImpl isn't intermittent.\n     ",
    "links" : [ "#intermittentUpdateState()" ]
  }, {
    "name" : "INTERMITTENT_STATE_IN_TRANSITION",
    "type" : "int",
    "comment" : "\n     * The {@link #intermittentUpdateState()} value when the ViewRootImpl is transitioning either\n     * to or from intermittent to not intermittent. This indicates that the frame rate shouldn't\n     * change.\n     ",
    "links" : [ "#intermittentUpdateState()" ]
  }, {
    "name" : "INTERMITTENT_STATE_INTERMITTENT",
    "type" : "int",
    "comment" : "\n     * The {@link #intermittentUpdateState()} value when the ViewRootImpl is intermittent.\n     ",
    "links" : [ "#intermittentUpdateState()" ]
  }, {
    "name" : "KEEP_CLEAR_AREA_REPORT_RATE_MILLIS",
    "type" : "int",
    "comment" : "\n     * Minimum time to wait before reporting changes to keep clear areas.\n     ",
    "links" : [ ]
  }, {
    "name" : "NANOS_PER_SEC",
    "type" : "long",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "sRunQueues",
    "type" : "ThreadLocal<HandlerActionQueue>",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "sFirstDrawHandlers",
    "type" : "ArrayList<Runnable>",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "sFirstDrawComplete",
    "type" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mTransformHintListeners",
    "type" : "ArrayList<OnBufferTransformHintChangedListener>",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mPreviousTransformHint",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mOnBackInvokedDispatcher",
    "type" : "WindowOnBackInvokedDispatcher",
    "comment" : "\n     * The top level {@link OnBackInvokedDispatcher}.\n     ",
    "links" : [ "android.window.OnBackInvokedDispatcher" ]
  }, {
    "name" : "mCompatOnBackInvokedCallback",
    "type" : "CompatOnBackInvokedCallback",
    "comment" : "\n     * Compatibility {@link OnBackInvokedCallback} that dispatches KEYCODE_BACK events\n     * to view root for apps using legacy back behavior.\n     ",
    "links" : [ "android.window.CompatOnBackInvokedCallback" ]
  }, {
    "name" : "mForceInvertObserver",
    "type" : "ContentObserver",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "INVALID_VALUE",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mForceInvertEnabled",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "sConfigCallbacks",
    "type" : "ArrayList<ConfigChangedCallback>",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mActivityConfigCallback",
    "type" : "ActivityConfigCallback",
    "comment" : "\n     * Callback used to notify corresponding activity about camera compat control changes, override\n     * configuration change and make sure that all resources are set correctly before updating the\n     * ViewRootImpl's internal state.\n     ",
    "links" : [ ]
  }, {
    "name" : "mForceNextConfigUpdate",
    "type" : "boolean",
    "comment" : "\n     * Used when configuration change first updates the config of corresponding activity.\n     * In that case we receive a call back from {@link ActivityThread} and this flag is used to\n     * preserve the initial value.\n     *\n     * @see #performConfigurationChange\n     ",
    "links" : [ "android.app.ActivityThread" ]
  }, {
    "name" : "mFastScrollSoundEffectsEnabled",
    "type" : "boolean",
    "comment" : " lazily-initialized in getAudioManager() ",
    "links" : [ ]
  }, {
    "name" : "sCompatibilityDone",
    "type" : "boolean",
    "comment" : "\n     * Signals that compatibility booleans have been initialized according to\n     * target SDK versions.\n     ",
    "links" : [ ]
  }, {
    "name" : "sAlwaysAssignFocus",
    "type" : "boolean",
    "comment" : "\n     * Always assign focus if a focusable View is available.\n     ",
    "links" : [ ]
  }, {
    "name" : "mWindowCallbacks",
    "type" : "ArrayList<WindowCallbacks>",
    "comment" : "\n     * This list must only be modified by the main thread.\n     ",
    "links" : [ ]
  }, {
    "name" : "mContext",
    "type" : "Context",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mWindowSession",
    "type" : "IWindowSession",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mDisplay",
    "type" : "Display",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mBasePackageName",
    "type" : "String",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mExtraDisplayListenerLogging",
    "type" : "boolean",
    "comment" : " If we would like to keep a particular eye on the corresponding package.",
    "links" : [ ]
  }, {
    "name" : "mTmpLocation",
    "type" : "int[]",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mTmpValue",
    "type" : "TypedValue",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mThread",
    "type" : "Thread",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mLocation",
    "type" : "WindowLeaked",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mWindowAttributes",
    "type" : "WindowManager.LayoutParams",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mWindow",
    "type" : "W",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mLeashToken",
    "type" : "IBinder",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mTargetSdkVersion",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mView",
    "type" : "View",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mAccessibilityFocusedHost",
    "type" : "View",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mAccessibilityFocusedVirtualView",
    "type" : "AccessibilityNodeInfo",
    "comment" : " mAccessibilityFocusedVirtualView is up-to-date while other fields may be stale.",
    "links" : [ ]
  }, {
    "name" : "mPointerCapture",
    "type" : "boolean",
    "comment" : " True if the window currently has pointer capture enabled.",
    "links" : [ ]
  }, {
    "name" : "mViewVisibility",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mAppVisible",
    "type" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mForceDecorViewVisibility",
    "type" : "boolean",
    "comment" : " stopped and that's when the app will stop drawing further frames.",
    "links" : [ ]
  }, {
    "name" : "mAppVisibilityChanged",
    "type" : "boolean",
    "comment" : " make sure that we always call relayout for the corresponding window.",
    "links" : [ ]
  }, {
    "name" : "mOrigWindowType",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mStopped",
    "type" : "boolean",
    "comment" : " so the window should no longer be active.",
    "links" : [ ]
  }, {
    "name" : "mIsAmbientMode",
    "type" : "boolean",
    "comment" : " which means it won't receive input events.",
    "links" : [ ]
  }, {
    "name" : "mPausedForTransition",
    "type" : "boolean",
    "comment" : " Set to true to stop input during an Activity Transition.",
    "links" : [ ]
  }, {
    "name" : "mSurfaceHolderCallback",
    "type" : "SurfaceHolder.Callback2",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mSurfaceHolder",
    "type" : "BaseSurfaceHolder",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mIsCreating",
    "type" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mDrawingAllowed",
    "type" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mTransparentRegion",
    "type" : "Region",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mPreviousTransparentRegion",
    "type" : "Region",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mTouchableRegion",
    "type" : "Region",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mPreviousTouchableRegion",
    "type" : "Region",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mMeasuredWidth",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mMeasuredHeight",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mViewMeasureDeferred",
    "type" : "boolean",
    "comment" : " If this is true, we must measure the views before laying out them.",
    "links" : [ ]
  }, {
    "name" : "mWidth",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mHeight",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mDirty",
    "type" : "Rect",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mIsAnimating",
    "type" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mUseMTRenderer",
    "type" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mPendingDragResizing",
    "type" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mDragResizing",
    "type" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mInvalidateRootRequested",
    "type" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mCanvasOffsetX",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mCanvasOffsetY",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mTranslator",
    "type" : "CompatibilityInfo.Translator",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mAttachInfo",
    "type" : "View.AttachInfo",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mCompatibleVisibilityInfo",
    "type" : "SystemUiVisibilityInfo",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mDispatchedSystemUiVisibility",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mDispatchedSystemBarAppearance",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mInputQueueCallback",
    "type" : "InputQueue.Callback",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mInputQueue",
    "type" : "InputQueue",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mFallbackEventHandler",
    "type" : "FallbackEventHandler",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mChoreographer",
    "type" : "Choreographer",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mViewFrameInfo",
    "type" : "ViewFrameInfo",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mInputEventAssigner",
    "type" : "InputEventAssigner",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mDisplayDecorationCached",
    "type" : "boolean",
    "comment" : " Whether to draw this surface as DISPLAY_DECORATION.",
    "links" : [ ]
  }, {
    "name" : "mIsStylusPointerIconEnabled",
    "type" : "boolean",
    "comment" : " Is the stylus pointer icon enabled",
    "links" : [ ]
  }, {
    "name" : "mInfrequentUpdateCount",
    "type" : "int",
    "comment" : " VRR check for number of infrequent updates",
    "links" : [ ]
  }, {
    "name" : "mLastUpdateTimeMillis",
    "type" : "long",
    "comment" : " VRR time of last update",
    "links" : [ ]
  }, {
    "name" : "mMinusOneFrameIntervalMillis",
    "type" : "int",
    "comment" : " VRR interval since the previous",
    "links" : [ ]
  }, {
    "name" : "mMinusTwoFrameIntervalMillis",
    "type" : "int",
    "comment" : " VRR interval between the previous and the frame before",
    "links" : [ ]
  }, {
    "name" : "mSurfaceSize",
    "type" : "Point",
    "comment" : " for BLAST adapter surface setup",
    "links" : [ ]
  }, {
    "name" : "mLastSurfaceSize",
    "type" : "Point",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mVisRect",
    "type" : "Rect",
    "comment" : " used to retrieve visible rect of focused view.",
    "links" : [ ]
  }, {
    "name" : "mTempRect",
    "type" : "Rect",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mWindowLayout",
    "type" : "WindowLayout",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mWindowFocusChanged",
    "type" : "boolean",
    "comment" : " the window manager and input events coming through the input system.",
    "links" : [ ]
  }, {
    "name" : "mUpcomingWindowFocus",
    "type" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mUpcomingInTouchMode",
    "type" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mProcessingBackKey",
    "type" : "boolean",
    "comment" : " While set, allow this VRI to handle back key without drop it.",
    "links" : [ ]
  }, {
    "name" : "mWindowlessBackKeyCallback",
    "type" : "Predicate<KeyEvent>",
    "comment" : "\n     * Compatibility {@link OnBackInvokedCallback} for windowless window, to forward the back\n     * key event host app.\n     ",
    "links" : [ "android.window.CompatOnBackInvokedCallback" ]
  }, {
    "name" : "mTraversalScheduled",
    "type" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mTraversalBarrier",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mWillDrawSoon",
    "type" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mIsInTraversal",
    "type" : "boolean",
    "comment" : " Set to true while in performTraversals for detecting when die(true) is called from internal\n     * callbacks such as onMeasure, onPreDraw, onDraw and deferring doDie() until later. ",
    "links" : [ ]
  }, {
    "name" : "mApplyInsetsRequested",
    "type" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mLayoutRequested",
    "type" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mFirst",
    "type" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mContentCaptureEnabled",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mPerformContentCapture",
    "type" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mReportNextDraw",
    "type" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mLastReportNextDrawReason",
    "type" : "String",
    "comment" : " Set only while mReportNextDraw=true, indicating the last reason that was triggered ",
    "links" : [ ]
  }, {
    "name" : "mLastPerformDrawSkippedReason",
    "type" : "String",
    "comment" : " The reaason the last call to performDraw() returned false ",
    "links" : [ ]
  }, {
    "name" : "mLastPerformTraversalsSkipDrawReason",
    "type" : "String",
    "comment" : " The reason the last call to performTraversals() returned without drawing ",
    "links" : [ ]
  }, {
    "name" : "mWmsRequestSyncGroupState",
    "type" : "int",
    "comment" : " The state of the WMS requested sync, if one is in progress. Can be one of the states\n     * below. ",
    "links" : [ ]
  }, {
    "name" : "WMS_SYNC_NONE",
    "type" : "int",
    "comment" : " The possible states of the WMS requested sync, see createSyncIfNeeded()",
    "links" : [ ]
  }, {
    "name" : "WMS_SYNC_PENDING",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "WMS_SYNC_RETURNED",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "WMS_SYNC_MERGED",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mSyncBuffer",
    "type" : "boolean",
    "comment" : "\n     * Set whether the requested SurfaceSyncGroup should sync the buffer. When set to true, VRI will\n     * create a sync transaction with BBQ and send the resulting buffer back to the\n     * SurfaceSyncGroup. If false, VRI will not try to sync a buffer in BBQ, but still report when a\n     * draw occurred.\n     ",
    "links" : [ ]
  }, {
    "name" : "mCheckIfCanDraw",
    "type" : "boolean",
    "comment" : "\n     * Flag to determine whether the client needs to check with WMS if it can draw. WMS will notify\n     * the client that it can't draw if we're still in the middle of a sync set that includes this\n     * window. Once the sync is complete, the window can resume drawing. This is to ensure we don't\n     * deadlock the client by trying to request draws when there may not be any buffers available.\n     ",
    "links" : [ ]
  }, {
    "name" : "mWasLastDrawCanceled",
    "type" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mLastTraversalWasVisible",
    "type" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mLastDrawScreenOff",
    "type" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mDrewOnceForSync",
    "type" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mSyncSeqId",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mLastSyncSeqId",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mUpdateSurfaceNeeded",
    "type" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mFullRedrawNeeded",
    "type" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mNewSurfaceNeeded",
    "type" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mForceNextWindowRelayout",
    "type" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mWindowDrawCountDown",
    "type" : "CountDownLatch",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mHasPendingTransactions",
    "type" : "boolean",
    "comment" : "\n     * Value to indicate whether someone has called {@link #applyTransactionOnDraw}before the\n     * traversal. This is used to determine whether a RT frame callback needs to be registered to\n     * merge the transaction with the next frame. The value is cleared after the VRI has run a\n     * traversal pass.\n     ",
    "links" : [ "#applyTransactionOnDraw" ]
  }, {
    "name" : "mPendingTransaction",
    "type" : "Transaction",
    "comment" : "\n     * The combined transactions passed in from {@link #applyTransactionOnDraw}\n     ",
    "links" : [ "#applyTransactionOnDraw" ]
  }, {
    "name" : "mIsDrawing",
    "type" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mLastSystemUiVisibility",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mClientWindowLayoutFlags",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "MAX_QUEUED_INPUT_EVENT_POOL_SIZE",
    "type" : "int",
    "comment" : " Pool of queued input events.",
    "links" : [ ]
  }, {
    "name" : "mQueuedInputEventPool",
    "type" : "QueuedInputEvent",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mQueuedInputEventPoolSize",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mPendingInputEventHead",
    "type" : "QueuedInputEvent",
    "comment" : " Input event queue.\n     * Pending input events are input events waiting to be delivered to the input stages\n     * and handled by the application.\n     ",
    "links" : [ ]
  }, {
    "name" : "mPendingInputEventTail",
    "type" : "QueuedInputEvent",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mPendingInputEventCount",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mProcessInputEventsScheduled",
    "type" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mUnbufferedInputDispatch",
    "type" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mUnbufferedInputSource",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mPendingInputEventQueueLengthCounterName",
    "type" : "String",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mFirstInputStage",
    "type" : "InputStage",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mFirstPostImeInputStage",
    "type" : "InputStage",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mSyntheticInputStage",
    "type" : "InputStage",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mUnhandledKeyManager",
    "type" : "UnhandledKeyManager",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mWindowAttributesChanged",
    "type" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mSurface",
    "type" : "Surface",
    "comment" : " Surface can never be reassigned or cleared (use Surface.clear()).",
    "links" : [ ]
  }, {
    "name" : "mSurfaceControl",
    "type" : "SurfaceControl",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mBlastBufferQueue",
    "type" : "BLASTBufferQueue",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mHdrRenderState",
    "type" : "HdrRenderState",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mBoundsLayer",
    "type" : "SurfaceControl",
    "comment" : "\n     * Child container layer of {@code mSurface} with the same bounds as its parent, and cropped to\n     * the surface insets. This surface is created only if a client requests it via\n     * {@link #updateAndGetBoundsLayer(Transaction)}. By parenting to this bounds surface, child\n     * surfaces can ensure they do not draw into the surface inset region set by the parent window.\n     ",
    "links" : [ "#updateAndGetBoundsLayer(Transaction)" ]
  }, {
    "name" : "mSurfaceSession",
    "type" : "SurfaceSession",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mTransaction",
    "type" : "Transaction",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mFrameRateTransaction",
    "type" : "Transaction",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mAdded",
    "type" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mAddedTouchMode",
    "type" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mTmpFrames",
    "type" : "ClientWindowFrames",
    "comment" : "\n     * It usually keeps the latest layout result from {@link IWindow#resized} or\n     * {@link IWindowSession#relayout}.\n     ",
    "links" : [ "#relayout", "#resized" ]
  }, {
    "name" : "mWinFrame",
    "type" : "Rect",
    "comment" : " frame given by window manager.",
    "links" : [ ]
  }, {
    "name" : "mLastLayoutFrame",
    "type" : "Rect",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mOverrideInsetsFrame",
    "type" : "Rect",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mPendingBackDropFrame",
    "type" : "Rect",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mPendingAlwaysConsumeSystemBars",
    "type" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mRelayoutSeq",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mWinFrameInScreen",
    "type" : "Rect",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mTempInsets",
    "type" : "InsetsState",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mTempControls",
    "type" : "InsetsSourceControl.Array",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mTempWinConfig",
    "type" : "WindowConfiguration",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mInvCompatScale",
    "type" : "float",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mLastGivenInsets",
    "type" : "ViewTreeObserver.InternalInsetsInfo",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mLastWindowInsets",
    "type" : "WindowInsets",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mTypesHiddenByFlags",
    "type" : "int",
    "comment" : " Insets types hidden by legacy window flags or system UI flags.",
    "links" : [ ]
  }, {
    "name" : "mLastConfigurationFromResources",
    "type" : "Configuration",
    "comment" : " Last applied configuration obtained from resources. ",
    "links" : [ ]
  }, {
    "name" : "mLastReportedMergedConfiguration",
    "type" : "MergedConfiguration",
    "comment" : " Last configuration reported from WM or via {@link #MSG_UPDATE_CONFIGURATION}. ",
    "links" : [ "#MSG_UPDATE_CONFIGURATION" ]
  }, {
    "name" : "mPendingMergedConfiguration",
    "type" : "MergedConfiguration",
    "comment" : " Configurations waiting to be applied. ",
    "links" : [ ]
  }, {
    "name" : "mPendingActivityWindowInfo",
    "type" : "ActivityWindowInfo",
    "comment" : " Non-{@code null} if {@link #mActivityConfigCallback} is not {@code null}. ",
    "links" : [ "#mActivityConfigCallback" ]
  }, {
    "name" : "mLastReportedActivityWindowInfo",
    "type" : "ActivityWindowInfo",
    "comment" : " Non-{@code null} if {@link #mActivityConfigCallback} is not {@code null}. ",
    "links" : [ "#mActivityConfigCallback" ]
  }, {
    "name" : "mScrollMayChange",
    "type" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mSoftInputMode",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mLastScrolledFocus",
    "type" : "WeakReference<View>",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mScrollY",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mCurScrollY",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mScroller",
    "type" : "Scroller",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mResizeInterpolator",
    "type" : "Interpolator",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mPendingTransitions",
    "type" : "ArrayList<LayoutTransition>",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mViewConfiguration",
    "type" : "ViewConfiguration",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mDragDescription",
    "type" : "ClipDescription",
    "comment" : " Drag/drop ",
    "links" : [ ]
  }, {
    "name" : "mCurrentDragView",
    "type" : "View",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mStartedDragViewForA11y",
    "type" : "View",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mLocalDragState",
    "type" : "Object",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mDragPoint",
    "type" : "PointF",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mLastTouchPoint",
    "type" : "PointF",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mLastTouchSource",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mLastTouchDeviceId",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mLastTouchPointerId",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mLastClickToolType",
    "type" : "int",
    "comment" : " Tracks last {@link MotionEvent#getToolType(int)} with {@link MotionEvent#ACTION_UP}. *",
    "links" : [ "android.view.MotionEvent#ACTION_UP", "android.view.MotionEvent#getToolType(int)" ]
  }, {
    "name" : "mProfileRendering",
    "type" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mRenderProfiler",
    "type" : "Choreographer.FrameCallback",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mRenderProfilingEnabled",
    "type" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mFpsStartTime",
    "type" : "long",
    "comment" : " Variables to track frames per second, enabled via DEBUG_FPS flag",
    "links" : [ ]
  }, {
    "name" : "mFpsPrevTime",
    "type" : "long",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mFpsNumFrames",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mInsetsAnimationRunning",
    "type" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mPreviousFrameDrawnTime",
    "type" : "long",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mLargestChildPercentage",
    "type" : "float",
    "comment" : " The largest view size percentage to the display size. Used on trace to collect metric.",
    "links" : [ ]
  }, {
    "name" : "mFrameRateCategoryChangeReason",
    "type" : "int",
    "comment" : " The reason the category was changed.",
    "links" : [ ]
  }, {
    "name" : "mFrameRateCategoryView",
    "type" : "String",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mPointerIconType",
    "type" : "Integer",
    "comment" : " TODO(b/293587049): Remove pointer icon tracking by type when refactor is complete.",
    "links" : [ ]
  }, {
    "name" : "mCustomPointerIcon",
    "type" : "PointerIcon",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mResolvedPointerIcon",
    "type" : "PointerIcon",
    "comment" : "\n     * The resolved pointer icon requested by this window.\n     * A null value indicates the resolved pointer icon has not yet been calculated.\n     ",
    "links" : [ ]
  }, {
    "name" : "mAudioManager",
    "type" : "AudioManager",
    "comment" : "\n     * see {@link #playSoundEffect(int)}\n     ",
    "links" : [ "#playSoundEffect(int)" ]
  }, {
    "name" : "mAccessibilityManager",
    "type" : "AccessibilityManager",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mAccessibilityInteractionController",
    "type" : "AccessibilityInteractionController",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mRoundDisplayAccessibilityHighlightPaint",
    "type" : "Paint",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mAccessibilityInteractionConnectionManager",
    "type" : "AccessibilityInteractionConnectionManager",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mHighContrastTextManager",
    "type" : "HighContrastTextManager",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mSendWindowContentChangedAccessibilityEvent",
    "type" : "SendWindowContentChangedAccessibilityEvent",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mTempHashSet",
    "type" : "HashSet<View>",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mDensity",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mNoncompatDensity",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mInLayout",
    "type" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mLayoutRequesters",
    "type" : "ArrayList<View>",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mHandlingLayoutInLayoutRequest",
    "type" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mViewLayoutDirectionInitial",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mRemoved",
    "type" : "boolean",
    "comment" : " Set to true once doDie() has been called. ",
    "links" : [ ]
  }, {
    "name" : "mNeedsRendererSetup",
    "type" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mInputCompatProcessor",
    "type" : "InputEventCompatProcessor",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mInputEventConsistencyVerifier",
    "type" : "InputEventConsistencyVerifier",
    "comment" : "\n     * Consistency verifier for debugging purposes.\n     ",
    "links" : [ ]
  }, {
    "name" : "mInsetsController",
    "type" : "InsetsController",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mImeBackAnimationController",
    "type" : "ImeBackAnimationController",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mImeFocusController",
    "type" : "ImeFocusController",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mIsSurfaceOpaque",
    "type" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mBlurRegionAggregator",
    "type" : "BackgroundBlurDrawable.Aggregator",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mGestureExclusionTracker",
    "type" : "ViewRootRectTracker",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mKeepClearRectsTracker",
    "type" : "ViewRootRectTracker",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mUnrestrictedKeepClearRectsTracker",
    "type" : "ViewRootRectTracker",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mHasPendingKeepClearAreaChange",
    "type" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mKeepClearAccessibilityFocusRect",
    "type" : "Rect",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mAccessibilityEmbeddedConnection",
    "type" : "IAccessibilityEmbeddedConnection",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mSensitiveContentProtectionService",
    "type" : "ISensitiveContentProtectionManager",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mHandwritingInitiator",
    "type" : "HandwritingInitiator",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mWmsRequestSyncGroup",
    "type" : "SurfaceSyncGroup",
    "comment" : "\n     * A SurfaceSyncGroup that is created when WMS requested to sync the buffer\n     ",
    "links" : [ ]
  }, {
    "name" : "mActiveSurfaceSyncGroup",
    "type" : "SurfaceSyncGroup",
    "comment" : "\n     * The SurfaceSyncGroup that represents the active VRI SurfaceSyncGroup. This is non null if\n     * anyone requested the SurfaceSyncGroup for this VRI to ensure that anyone trying to sync with\n     * this VRI are collected together. The SurfaceSyncGroup is cleared when the VRI draws since\n     * that is the stop point where all changes are have been applied. A new SurfaceSyncGroup is\n     * created after that point when something wants to sync VRI again.\n     ",
    "links" : [ ]
  }, {
    "name" : "mPreviousSyncSafeguardLock",
    "type" : "Object",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mPreviousSyncSafeguard",
    "type" : "SurfaceSyncGroup",
    "comment" : "\n     * Wraps the TransactionCommitted callback for the previous SSG so it can be added to the next\n     * SSG if started before previous has completed.\n     ",
    "links" : [ ]
  }, {
    "name" : "sSyncProgressLock",
    "type" : "Object",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "sNumSyncsInProgress",
    "type" : "int",
    "comment" : " animations until all are done.",
    "links" : [ ]
  }, {
    "name" : "mNumPausedForSync",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mRootScrollCaptureCallbacks",
    "type" : "HashSet<ScrollCaptureCallback>",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mScrollCaptureRequestTimeout",
    "type" : "long",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mSurfaceSequenceId",
    "type" : "int",
    "comment" : "\n     * Increment this value when the surface has been replaced.\n     ",
    "links" : [ ]
  }, {
    "name" : "mRelayoutRequested",
    "type" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mViewBoundsSandboxingEnabled",
    "type" : "boolean",
    "comment" : "\n     * Whether sandboxing of {@link android.view.View#getBoundsOnScreen},\n     * {@link android.view.View#getLocationOnScreen(int[])},\n     * {@link android.view.View#getWindowDisplayFrame} and\n     * {@link android.view.View#getWindowVisibleDisplayFrame}\n     * within Activity bounds is enabled for the current application.\n     ",
    "links" : [ "android.view.View#getLocationOnScreen(int", "android.view.View#getBoundsOnScreen", "android.view.View#getWindowVisibleDisplayFrame", "android.view.View#getWindowDisplayFrame" ]
  }, {
    "name" : "mAccessibilityWindowAttributes",
    "type" : "AccessibilityWindowAttributes",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mPreferredFrameRateCategory",
    "type" : "int",
    "comment" : " could be updated on a frame-by-frame basis.",
    "links" : [ ]
  }, {
    "name" : "mLastPreferredFrameRateCategory",
    "type" : "int",
    "comment" : " could be used to lower frame rate after touch boost",
    "links" : [ ]
  }, {
    "name" : "mPreferredFrameRate",
    "type" : "float",
    "comment" : " touch boosting, view velocity handling, and TextureView.",
    "links" : [ ]
  }, {
    "name" : "mLastPreferredFrameRate",
    "type" : "float",
    "comment" : " track the difference between the current preferred frame rate and the previous value.",
    "links" : [ ]
  }, {
    "name" : "mIsFrameRateBoosting",
    "type" : "boolean",
    "comment" : " Used to check if it is in the frame rate boosting period.",
    "links" : [ ]
  }, {
    "name" : "mIsTouchBoosting",
    "type" : "boolean",
    "comment" : " Used to check if it is in touch boosting period.",
    "links" : [ ]
  }, {
    "name" : "mDrawnThisFrame",
    "type" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mIsFrameRateConflicted",
    "type" : "boolean",
    "comment" : " We consider there is a conflict.",
    "links" : [ ]
  }, {
    "name" : "mFrameRateCompatibility",
    "type" : "int",
    "comment" : " Used to set frame rate compatibility.",
    "links" : [ ]
  }, {
    "name" : "FRAME_RATE_TOUCH_BOOST_TIME",
    "type" : "int",
    "comment" : " time for touch boost period.",
    "links" : [ ]
  }, {
    "name" : "FRAME_RATE_SETTING_REEVALUATE_TIME",
    "type" : "int",
    "comment" : " the time when frame rate was set previously.",
    "links" : [ ]
  }, {
    "name" : "FRAME_RATE_CATEGORY_COUNT",
    "type" : "int",
    "comment" : "\n     * The variables below are used to update frame rate category\n     ",
    "links" : [ ]
  }, {
    "name" : "mFrameRateCategoryHighCount",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mFrameRateCategoryHighHintCount",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mFrameRateCategoryNormalCount",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mFrameRateCategoryLowCount",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mRelayoutBundle",
    "type" : "Bundle",
    "comment" : "\n     * A temporary object used so relayoutWindow can return the latest SyncSeqId\n     * system. The SyncSeqId system was designed to work without synchronous relayout\n     * window, and actually synchronous relayout window presents a problem.  We could have\n     * a sequence like this:\n     *    1. We send MSG_RESIZED to the client with a new syncSeqId to begin a new sync\n     *    2. Due to scheduling the client executes performTraversals before calling MSG_RESIZED\n     *    3. Coincidentally for some random reason it also calls relayout\n     *    4. It observes the new state from relayout, and so the next frame will contain the state\n     * However it hasn't received the seqId yet, and so under the designed operation of\n     * seqId flowing through MSG_RESIZED, the next frame wouldn't be synced. Since it\n     * contains our target sync state, we need to sync it! This problem won't come up once\n     * we get rid of synchronous relayout, until then, we use this bundle to channel the\n     * integer back over relayout.\n     ",
    "links" : [ ]
  }, {
    "name" : "mRelayoutResult",
    "type" : "WindowRelayoutResult",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "sAnrReported",
    "type" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "sTransactionHangCallback",
    "type" : "BLASTBufferQueue.TransactionHangCallback",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mChildBoundingInsets",
    "type" : "Rect",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mChildBoundingInsetsChanged",
    "type" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mTag",
    "type" : "String",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mFpsTraceName",
    "type" : "String",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mLargestViewTraceName",
    "type" : "String",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "sToolkitSetFrameRateReadOnlyFlagValue",
    "type" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "sToolkitFrameRateFunctionEnablingReadOnlyFlagValue",
    "type" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "sToolkitMetricsForFrameRateDecisionFlagValue",
    "type" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "sToolkitFrameRateTypingReadOnlyFlagValue",
    "type" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "sToolkitFrameRateViewEnablingReadOnlyFlagValue",
    "type" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "sToolkitFrameRateVelocityMappingReadOnlyFlagValue",
    "type" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "sToolkitEnableInvalidateCheckThreadFlagValue",
    "type" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mPointerIconEvent",
    "type" : "MotionEvent",
    "comment" : " The latest input event from the gesture that was used to resolve the pointer icon.",
    "links" : [ ]
  }, {
    "name" : "mProfile",
    "type" : "boolean",
    "comment" : " FIXME for perf testing only",
    "links" : [ ]
  }, {
    "name" : "mDisplayListener",
    "type" : "DisplayListener",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mSurfaceChangedCallbacks",
    "type" : "ArrayList<SurfaceChangedCallback>",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mHardwareXOffset",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mHardwareYOffset",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "MSG_INVALIDATE",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "MSG_INVALIDATE_RECT",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "MSG_DIE",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "MSG_RESIZED",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "MSG_RESIZED_REPORT",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "MSG_WINDOW_FOCUS_CHANGED",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "MSG_DISPATCH_INPUT_EVENT",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "MSG_DISPATCH_APP_VISIBILITY",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "MSG_DISPATCH_GET_NEW_SURFACE",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "MSG_DISPATCH_KEY_FROM_IME",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "MSG_DISPATCH_KEY_FROM_AUTOFILL",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "MSG_CHECK_FOCUS",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "MSG_CLOSE_SYSTEM_DIALOGS",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "MSG_DISPATCH_DRAG_EVENT",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "MSG_DISPATCH_DRAG_LOCATION_EVENT",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "MSG_DISPATCH_SYSTEM_UI_VISIBILITY",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "MSG_UPDATE_CONFIGURATION",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "MSG_PROCESS_INPUT_EVENTS",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "MSG_CLEAR_ACCESSIBILITY_FOCUS_HOST",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "MSG_INVALIDATE_WORLD",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "MSG_WINDOW_MOVED",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "MSG_SYNTHESIZE_INPUT_EVENT",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "MSG_DISPATCH_WINDOW_SHOWN",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "MSG_REQUEST_KEYBOARD_SHORTCUTS",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "MSG_UPDATE_POINTER_ICON",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "MSG_POINTER_CAPTURE_CHANGED",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "MSG_INSETS_CONTROL_CHANGED",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "MSG_SYSTEM_GESTURE_EXCLUSION_CHANGED",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "MSG_SHOW_INSETS",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "MSG_HIDE_INSETS",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "MSG_REQUEST_SCROLL_CAPTURE",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "MSG_WINDOW_TOUCH_MODE_CHANGED",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "MSG_KEEP_CLEAR_RECTS_CHANGED",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "MSG_REPORT_KEEP_CLEAR_RECTS",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "MSG_PAUSED_FOR_SYNC_TIMEOUT",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "MSG_DECOR_VIEW_GESTURE_INTERCEPTION",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "MSG_TOUCH_BOOST_TIMEOUT",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "MSG_CHECK_INVALIDATION_IDLE",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "MSG_REFRESH_POINTER_ICON",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "MSG_FRAME_RATE_SETTING",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mHandler",
    "type" : "ViewRootHandler",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mExecutor",
    "type" : "Executor",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mTraversalRunnable",
    "type" : "TraversalRunnable",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mInputEventReceiver",
    "type" : "WindowInputEventReceiver",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mHardwareRendererObserver",
    "type" : "HardwareRendererObserver",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mConsumedBatchedInputRunnable",
    "type" : "ConsumeBatchedInputRunnable",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mConsumeBatchedInputScheduled",
    "type" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mConsumeBatchedInputImmediatelyRunnable",
    "type" : "ConsumeBatchedInputImmediatelyRunnable",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mConsumeBatchedInputImmediatelyScheduled",
    "type" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mInvalidateOnAnimationRunnable",
    "type" : "InvalidateOnAnimationRunnable",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mSimpleExecutor",
    "type" : "Executor",
    "comment" : "",
    "links" : [ ]
  } ],
  "methods" : [ {
    "name" : "protected FrameInfo getUpdatedFrameInfo()",
    "returnType" : "FrameInfo",
    "comment" : "\n     * Update the Choreographer's FrameInfo object with the timing information for the current\n     * ViewRootImpl instance. Erase the data in the current ViewFrameInfo to prepare for the next\n     * frame.\n     * @return the updated FrameInfo object\n     ",
    "links" : [ ]
  }, {
    "name" : "public ImeFocusController getImeFocusController()",
    "returnType" : "ImeFocusController",
    "comment" : "\n     * @return {@link ImeFocusController} for this instance.\n     ",
    "links" : [ "android.view.ImeFocusController" ]
  }, {
    "name" : "public HandwritingInitiator getHandwritingInitiator()",
    "returnType" : "HandwritingInitiator",
    "comment" : "\n     * Used by InputMethodManager.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public static void addFirstDrawHandler(Runnable callback)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public static void addConfigCallback(ConfigChangedCallback callback)",
    "returnType" : "void",
    "comment" : " Add static config callback to be notified about global config changes. ",
    "links" : [ ]
  }, {
    "name" : "public static void removeConfigCallback(ConfigChangedCallback callback)",
    "returnType" : "void",
    "comment" : " Remove a static config callback. ",
    "links" : [ ]
  }, {
    "name" : "public void setActivityConfigCallback(@Nullable ActivityConfigCallback callback)",
    "returnType" : "void",
    "comment" : "\n     * Add activity config callback to be notified about override config changes and camera\n     * compat control state updates.\n     ",
    "links" : [ ]
  }, {
    "name" : "public void setOnContentApplyWindowInsetsListener(OnContentApplyWindowInsetsListener listener)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public void addWindowCallbacks(WindowCallbacks callback)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public void removeWindowCallbacks(WindowCallbacks callback)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public void reportDrawFinish()",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public void profile()",
    "returnType" : "void",
    "comment" : "\n     * Call this to profile the next traversal call.\n     * FIXME for perf testing only. Remove eventually\n     ",
    "links" : [ ]
  }, {
    "name" : "private boolean isInTouchMode()",
    "returnType" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public void notifyChildRebuilt()",
    "returnType" : "void",
    "comment" : "\n     * Notifies us that our child has been rebuilt, following\n     * a window preservation operation. In these cases we\n     * keep the same DecorView, but the activity controlling it\n     * is a different instance, and we need to update our\n     * callbacks.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "private Configuration getConfiguration()",
    "returnType" : "Configuration",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private WindowConfiguration getCompatWindowConfiguration()",
    "returnType" : "WindowConfiguration",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public void setView(View view, WindowManager.LayoutParams attrs, View panelParentView)",
    "returnType" : "void",
    "comment" : "\n     * We have one child\n     ",
    "links" : [ ]
  }, {
    "name" : "public void setView(View view, WindowManager.LayoutParams attrs, View panelParentView, int userId)",
    "returnType" : "void",
    "comment" : "\n     * We have one child\n     ",
    "links" : [ ]
  }, {
    "name" : "private void setAccessibilityWindowAttributesIfNeeded()",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private boolean isForceInvertEnabled()",
    "returnType" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private void reloadForceInvertEnabled()",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private void registerListeners()",
    "returnType" : "void",
    "comment" : "\n     * Register any kind of listeners if setView was success.\n     ",
    "links" : [ ]
  }, {
    "name" : "private void unregisterListeners()",
    "returnType" : "void",
    "comment" : "\n     * Unregister all listeners while detachedFromWindow.\n     ",
    "links" : [ ]
  }, {
    "name" : "private void setTag()",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public int getWindowFlags()",
    "returnType" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public int getDisplayId()",
    "returnType" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public CharSequence getTitle()",
    "returnType" : "CharSequence",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public int getWidth()",
    "returnType" : "int",
    "comment" : "\n     * @return the width of the root view. Note that this will return {@code -1} until the first\n     *         layout traversal, when the width is set.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public int getHeight()",
    "returnType" : "int",
    "comment" : "\n     * @return the height of the root view. Note that this will return {@code -1} until the first\n     *         layout traversal, when the height is set.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : " void destroyHardwareResources()",
    "returnType" : "void",
    "comment" : "\n     * Destroys hardware rendering resources for this ViewRootImpl\n     *\n     * May be called on any thread\n     ",
    "links" : [ ]
  }, {
    "name" : "public void detachFunctor(long functor)",
    "returnType" : "void",
    "comment" : "\n     * Does nothing; Here only because of @UnsupportedAppUsage\n     ",
    "links" : [ ]
  }, {
    "name" : "public static void invokeFunctor(long functor, boolean waitForCompletion)",
    "returnType" : "void",
    "comment" : "\n     * Does nothing; Here only because of @UnsupportedAppUsage\n     ",
    "links" : [ ]
  }, {
    "name" : "public void registerAnimatingRenderNode(RenderNode animator)",
    "returnType" : "void",
    "comment" : "\n     * @param animator animator to register with the hardware renderer\n     ",
    "links" : [ ]
  }, {
    "name" : "public void registerVectorDrawableAnimator(NativeVectorDrawableAnimator animator)",
    "returnType" : "void",
    "comment" : "\n     * @param animator animator to register with the hardware renderer\n     ",
    "links" : [ ]
  }, {
    "name" : "public void registerRtFrameCallback(@NonNull FrameDrawingCallback callback)",
    "returnType" : "void",
    "comment" : "\n     * Registers a callback to be executed when the next frame is being drawn on RenderThread. This\n     * callback will be executed on a RenderThread worker thread, and only used for the next frame\n     * and thus it will only fire once.\n     *\n     * @param callback The callback to register.\n     ",
    "links" : [ ]
  }, {
    "name" : "private void enableHardwareAcceleration(WindowManager.LayoutParams attrs)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private int getNightMode()",
    "returnType" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public int determineForceDarkType()",
    "returnType" : "int",
    "comment" : " Returns true if force dark should be enabled according to various settings ",
    "links" : [ ]
  }, {
    "name" : "private void updateForceDarkMode()",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public View getView()",
    "returnType" : "View",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : " final WindowLeaked getLocation()",
    "returnType" : "WindowLeaked",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public void setLayoutParams(WindowManager.LayoutParams attrs, boolean newView)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private int adjustLayoutInDisplayCutoutMode(WindowManager.LayoutParams attrs)",
    "returnType" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : " void handleAppVisibility(boolean visible)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : " void handleGetNewSurface()",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private void handleResized(ClientWindowFrames frames, boolean reportDraw, MergedConfiguration mergedConfiguration, InsetsState insetsState, boolean forceLayout, boolean alwaysConsumeSystemBars, int displayId, int syncSeqId, boolean dragResizing, @Nullable ActivityWindowInfo activityWindowInfo)",
    "returnType" : "void",
    "comment" : " Handles messages {@link #MSG_RESIZED} and {@link #MSG_RESIZED_REPORT}. ",
    "links" : [ "#MSG_RESIZED", "#MSG_RESIZED_REPORT" ]
  }, {
    "name" : "public void onMovedToDisplay(int displayId, Configuration config)",
    "returnType" : "void",
    "comment" : "\n     * Notify about move to a different display.\n     * @param displayId The id of the display where this view root is moved to.\n     * @param config Configuration of the resources on new display after move.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "private void updateInternalDisplay(int displayId, Resources resources)",
    "returnType" : "void",
    "comment" : "\n     * Updates {@link #mDisplay} to the display object corresponding to {@param displayId}.\n     * Uses DEFAULT_DISPLAY if there isn't a display object in the system corresponding\n     * to {@param displayId}.\n     ",
    "links" : [ "#mDisplay" ]
  }, {
    "name" : " void pokeDrawLockIfNeeded()",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public void requestFitSystemWindows()",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : " void notifyInsetsChanged()",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public void notifyInsetsAnimationRunningStateChanged(boolean running)",
    "returnType" : "void",
    "comment" : "\n     * Notify the when the running state of a insets animation changed.\n     ",
    "links" : [ ]
  }, {
    "name" : "public void requestLayout()",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public boolean isLayoutRequested()",
    "returnType" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public void onDescendantInvalidated(@NonNull View child, @NonNull View descendant)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : " void invalidate()",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : " void invalidateWorld(View view)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public void invalidateChild(View child, Rect dirty)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public ViewParent invalidateChildInParent(int[] location, Rect dirty)",
    "returnType" : "ViewParent",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private void invalidateRectOnScreen(Rect dirty)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public void setIsAmbientMode(boolean ambient)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : " void setWindowStopped(boolean stopped)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public void addSurfaceChangedCallback(SurfaceChangedCallback c)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public void removeSurfaceChangedCallback(SurfaceChangedCallback c)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private void notifySurfaceCreated(Transaction t)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private void notifySurfaceReplaced(Transaction t)",
    "returnType" : "void",
    "comment" : "\n     * Notify listeners when the ViewRootImpl surface has been replaced. This callback will not be\n     * called if a new surface is created, only if the valid surface has been replaced with another\n     * valid surface.\n     ",
    "links" : [ ]
  }, {
    "name" : "private void notifySurfaceDestroyed()",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private void notifyDrawStarted(boolean isWmSync)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public SurfaceControl updateAndGetBoundsLayer(Transaction t)",
    "returnType" : "SurfaceControl",
    "comment" : "\n     * @return child layer with the same bounds as its parent {@code mSurface} and cropped to the\n     * surface insets. If the layer does not exist, it is created.\n     *\n     * <p>Parenting to this layer will ensure that its children are cropped by the view's surface\n     * insets.\n     ",
    "links" : [ ]
  }, {
    "name" : " void updateBlastSurfaceIfNeeded()",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private void setBoundsLayerCrop(Transaction t)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private boolean updateBoundsLayer(SurfaceControl.Transaction t)",
    "returnType" : "boolean",
    "comment" : "\n     * Called after window layout to update the bounds surface. If the surface insets have changed\n     * or the surface has resized, update the bounds surface.\n     ",
    "links" : [ ]
  }, {
    "name" : "private void prepareSurfaces()",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private void destroySurface()",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public void setPausedForTransition(boolean paused)",
    "returnType" : "void",
    "comment" : "\n     * Block the input events during an Activity Transition. The KEYCODE_BACK event is allowed\n     * through to allow quick reversal of the Activity Transition.\n     *\n     * @param paused true to pause, false to resume.\n     ",
    "links" : [ ]
  }, {
    "name" : "public ViewParent getParent()",
    "returnType" : "ViewParent",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public boolean getChildVisibleRect(View child, Rect r, android.graphics.Point offset)",
    "returnType" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public boolean getChildLocalHitRegion(@NonNull View child, @NonNull Region region, @NonNull Matrix matrix, boolean isHover)",
    "returnType" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public void bringChildToFront(View child)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : " int getHostVisibility()",
    "returnType" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public void requestTransitionStart(LayoutTransition transition)",
    "returnType" : "void",
    "comment" : "\n     * Add LayoutTransition to the list of transitions to be started in the next traversal.\n     * This list will be cleared after the transitions on the list are start()'ed. These\n     * transitionsa re added by LayoutTransition itself when it sets up animations. The setup\n     * happens during the layout phase of traversal, which we want to complete before any of the\n     * animations are started (because those animations may side-effect properties that layout\n     * depends upon, like the bounding rectangles of the affected views). So we add the transition\n     * to the list and it is started just prior to starting the drawing phase of traversal.\n     *\n     * @param transition The LayoutTransition to be started on the next traversal.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : " void notifyRendererOfFramePending()",
    "returnType" : "void",
    "comment" : "\n     * Notifies the HardwareRenderer that a new frame will be coming soon.\n     * Currently only {@link ThreadedRenderer} cares about this, and uses\n     * this knowledge to adjust the scheduling of off-thread animations\n     ",
    "links" : [ "android.view.ThreadedRenderer" ]
  }, {
    "name" : "public void notifyRendererOfExpensiveFrame()",
    "returnType" : "void",
    "comment" : "\n     * Notifies the HardwareRenderer of an expensive upcoming frame, to\n     * allow better handling of power and scheduling requirements.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : " void scheduleTraversals()",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : " void unscheduleTraversals()",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : " void doTraversal()",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private void applyKeepScreenOnFlag(WindowManager.LayoutParams params)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private boolean collectViewAttributes()",
    "returnType" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private int getImpliedSystemUiVisibility(WindowManager.LayoutParams params)",
    "returnType" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : " void updateCompatSysUiVisibility(@InsetsType int visibleTypes, @InsetsType int requestedVisibleTypes, @InsetsType int controllableTypes)",
    "returnType" : "void",
    "comment" : "\n     * Update the compatible system UI visibility for dispatching it to the legacy app.\n     ",
    "links" : [ ]
  }, {
    "name" : "private void updateCompatSystemUiVisibilityInfo(int systemUiFlag, @InsetsType int insetsType, @InsetsType int visibleTypes, @InsetsType int controllableTypes)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private void clearLowProfileModeIfNeeded(@InsetsType int showTypes, boolean fromIme)",
    "returnType" : "void",
    "comment" : "\n     * If the system is forcing showing any system bar, the legacy low profile flag should be\n     * cleared for compatibility.\n     *\n     * @param showTypes {@link InsetsType types} shown by the system.\n     * @param fromIme {@code true} if the invocation is from IME.\n     ",
    "links" : [ "android.view.WindowInsets.Type.InsetsType" ]
  }, {
    "name" : "private void dispatchDispatchSystemUiVisibilityChanged()",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private void handleDispatchSystemUiVisibilityChanged()",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public static void adjustLayoutParamsForCompatibility(WindowManager.LayoutParams inOutParams, @Appearance int appearanceControlled, boolean behaviorControlled)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private void controlInsetsForCompatibility(WindowManager.LayoutParams params)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private boolean measureHierarchy(final View host, final WindowManager.LayoutParams lp, final Resources res, final int desiredWindowWidth, final int desiredWindowHeight, boolean forRootSizeOnly)",
    "returnType" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private boolean setMeasuredRootSizeFromSpec(int widthMeasureSpec, int heightMeasureSpec)",
    "returnType" : "boolean",
    "comment" : "\n     * Sets the measured root size for requesting the window frame.\n     *\n     * @param widthMeasureSpec contains the size and the mode of the width.\n     * @param heightMeasureSpec contains the size and the mode of the height.\n     * @return {@code true} if we actually set the measured size; {@code false} otherwise.\n     ",
    "links" : [ ]
  }, {
    "name" : " void transformMatrixToGlobal(Matrix m)",
    "returnType" : "void",
    "comment" : "\n     * Modifies the input matrix such that it maps view-local coordinates to\n     * on-screen coordinates.\n     *\n     * @param m input matrix to modify\n     ",
    "links" : [ ]
  }, {
    "name" : " void transformMatrixToLocal(Matrix m)",
    "returnType" : "void",
    "comment" : "\n     * Modifies the input matrix such that it maps on-screen coordinates to\n     * view-local coordinates.\n     *\n     * @param m input matrix to modify\n     ",
    "links" : [ ]
  }, {
    "name" : " WindowInsets getWindowInsets(boolean forceConstruct)",
    "returnType" : "WindowInsets",
    "comment" : " package ",
    "links" : [ ]
  }, {
    "name" : "public void dispatchApplyInsets(View host)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private boolean shouldDispatchCutout()",
    "returnType" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public InsetsController getInsetsController()",
    "returnType" : "InsetsController",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private static boolean shouldUseDisplaySize(final WindowManager.LayoutParams lp)",
    "returnType" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private static boolean shouldOptimizeMeasure(final WindowManager.LayoutParams lp)",
    "returnType" : "boolean",
    "comment" : "\n     * @return {@code true} if we should reduce unnecessary measure for the window.\n     * TODO(b/260382739): Apply this to all windows.\n     ",
    "links" : [ ]
  }, {
    "name" : "private Rect getWindowBoundsInsetSystemBars()",
    "returnType" : "Rect",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : " int dipToPx(int dip)",
    "returnType" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private void performTraversals()",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private void createSyncIfNeeded()",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private void applySensitiveContentAppProtection(boolean enableProtection)",
    "returnType" : "void",
    "comment" : "\n     * Helper used to notify the service to block projection when a sensitive\n     * view (the view displays sensitive content) is attached to the window.\n     * The window manager service is also notified to unblock projection when\n     * no attached view (to the window) displays sensitive content.\n     *\n     * <ol>\n     *   <li>It should only notify service to block projection when first sensitive view is\n     *   attached to the window.\n     *   <li>It should only notify service to unblock projection when all sensitive view are\n     *   removed from the window.\n     * </ol>\n     *\n     * @param enableProtection if true, the protection is enabled for this window.\n     *                         if false, the protection is removed for this window.\n     ",
    "links" : [ ]
  }, {
    "name" : " void addSensitiveContentAppProtection()",
    "returnType" : "void",
    "comment" : "\n     * Add sensitive content protection, when there are one or more visible sensitive views.\n     ",
    "links" : [ ]
  }, {
    "name" : " void removeSensitiveContentAppProtection()",
    "returnType" : "void",
    "comment" : "\n     * Remove sensitive content protection, when there is no visible sensitive view.\n     ",
    "links" : [ ]
  }, {
    "name" : "private void notifyContentCaptureEvents()",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private void notifyHolderSurfaceDestroyed()",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private void maybeHandleWindowMove(Rect frame)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private void handleWindowFocusChanged()",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public void dispatchCompatFakeFocus()",
    "returnType" : "void",
    "comment" : " TODO(b/263094829): Investigate dispatching this for onPause as well",
    "links" : [ ]
  }, {
    "name" : "private void dispatchFocusEvent(boolean hasWindowFocus, boolean fakeFocus)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private void handleWindowTouchModeChanged()",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private void maybeFireAccessibilityWindowStateChangedEvent()",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private void fireAccessibilityFocusEventIfHasFocusedNode()",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private AccessibilityNodeInfo findFocusedVirtualNode(AccessibilityNodeProvider provider)",
    "returnType" : "AccessibilityNodeInfo",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private void handleOutOfResourcesException(Surface.OutOfResourcesException e)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private void performMeasure(int childWidthMeasureSpec, int childHeightMeasureSpec)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : " boolean isInLayout()",
    "returnType" : "boolean",
    "comment" : "\n     * Called by {@link android.view.View#isInLayout()} to determine whether the view hierarchy\n     * is currently undergoing a layout pass.\n     *\n     * @return whether the view hierarchy is currently undergoing a layout pass\n     ",
    "links" : [ "android.view.View#isInLayout()" ]
  }, {
    "name" : " boolean requestLayoutDuringLayout(final View view)",
    "returnType" : "boolean",
    "comment" : "\n     * Called by {@link android.view.View#requestLayout()} if the view hierarchy is currently\n     * undergoing a layout pass. requestLayout() should not generally be called during layout,\n     * unless the container hierarchy knows what it is doing (i.e., it is fine as long as\n     * all children in that container hierarchy are measured and laid out at the end of the layout\n     * pass for that container). If requestLayout() is called anyway, we handle it correctly\n     * by registering all requesters during a frame as it proceeds. At the end of the frame,\n     * we check all of those views to see if any still have pending layout requests, which\n     * indicates that they were not correctly handled by their container hierarchy. If that is\n     * the case, we clear all such flags in the tree, to remove the buggy flag state that leads\n     * to blank containers, and force a second request/measure/layout pass in this frame. If\n     * more requestLayout() calls are received during that second layout pass, we post those\n     * requests to the next frame to avoid possible infinite loops.\n     *\n     * <p>The return value from this method indicates whether the request should proceed\n     * (if it is a request during the first layout pass) or should be skipped and posted to the\n     * next frame (if it is a request during the second layout pass).</p>\n     *\n     * @param view the view that requested the layout.\n     *\n     * @return true if request should proceed, false otherwise.\n     ",
    "links" : [ "android.view.View#requestLayout()" ]
  }, {
    "name" : "private void performLayout(WindowManager.LayoutParams lp, int desiredWindowWidth, int desiredWindowHeight)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private ArrayList<View> getValidLayoutRequesters(ArrayList<View> layoutRequesters, boolean secondLayoutRequests)",
    "returnType" : "ArrayList<View>",
    "comment" : "\n     * This method is called during layout when there have been calls to requestLayout() during\n     * layout. It walks through the list of views that requested layout to determine which ones\n     * still need it, based on visibility in the hierarchy and whether they have already been\n     * handled (as is usually the case with ListView children).\n     *\n     * @param layoutRequesters The list of views that requested layout during layout\n     * @param secondLayoutRequests Whether the requests were issued during the second layout pass.\n     * If so, the FORCE_LAYOUT flag was not set on requesters.\n     * @return A list of the actual views that still need to be laid out.\n     ",
    "links" : [ ]
  }, {
    "name" : "public void requestTransparentRegion(View child)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private static int getRootMeasureSpec(int windowSize, int measurement, int privateFlags)",
    "returnType" : "int",
    "comment" : "\n     * Figures out the measure spec for the root view in a window based on it's\n     * layout params.\n     *\n     * @param windowSize The available width or height of the window.\n     * @param measurement The layout width or height requested in the layout params.\n     * @param privateFlags The private flags in the layout params of the window.\n     * @return The measure spec to use to measure the root view.\n     ",
    "links" : [ ]
  }, {
    "name" : "public void onPreDraw(RecordingCanvas canvas)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public void onPostDraw(RecordingCanvas canvas)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : " void outputDisplayList(View view)",
    "returnType" : "void",
    "comment" : "\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "private void profileRendering(boolean enabled)",
    "returnType" : "void",
    "comment" : "\n     * @see #PROPERTY_PROFILE_RENDERING\n     ",
    "links" : [ ]
  }, {
    "name" : "private void trackFPS()",
    "returnType" : "void",
    "comment" : "\n     * Called from draw() when DEBUG_FPS is enabled\n     ",
    "links" : [ ]
  }, {
    "name" : "private void collectFrameRateDecisionMetrics()",
    "returnType" : "void",
    "comment" : "\n     * Called from draw() to collect metrics for frame rate decision.\n     ",
    "links" : [ ]
  }, {
    "name" : "private void reportDrawFinished(@Nullable Transaction t, int seqId)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public boolean isHardwareEnabled()",
    "returnType" : "boolean",
    "comment" : "\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean isInWMSRequestedSync()",
    "returnType" : "boolean",
    "comment" : "\n     * This VRI is currently in the middle of a sync request that was initiated by WMS.\n     ",
    "links" : [ ]
  }, {
    "name" : "private void addFrameCommitCallbackIfNeeded()",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private void registerCallbackForPendingTransactions()",
    "returnType" : "void",
    "comment" : "\n     * These callbacks check if the draw failed for any reason and apply\n     * those transactions directly so they don't get stuck forever.\n     ",
    "links" : [ ]
  }, {
    "name" : "private boolean performDraw(@Nullable SurfaceSyncGroup surfaceSyncGroup)",
    "returnType" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private void handleSyncRequestWhenNoAsyncDraw(SurfaceSyncGroup surfaceSyncGroup, boolean hasPendingTransaction, @Nullable Transaction pendingTransaction, String logReason)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private boolean isContentCaptureEnabled()",
    "returnType" : "boolean",
    "comment" : "\n     * Checks (and caches) if content capture is enabled for this context.\n     ",
    "links" : [ ]
  }, {
    "name" : "private boolean isContentCaptureReallyEnabled()",
    "returnType" : "boolean",
    "comment" : "\n     * Checks (without caching) if content capture is enabled for this context.\n     ",
    "links" : [ ]
  }, {
    "name" : "private void performContentCaptureInitialReport()",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private void handleContentCaptureFlush()",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private boolean draw(boolean fullRedrawNeeded, @Nullable SurfaceSyncGroup activeSyncGroup, boolean syncBuffer)",
    "returnType" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private boolean drawSoftware(Surface surface, AttachInfo attachInfo, int xoff, int yoff, boolean scalingRequired, Rect dirty, Rect surfaceInsets)",
    "returnType" : "boolean",
    "comment" : "\n     * @return true if drawing was successful, false if an error occurred\n     ",
    "links" : [ ]
  }, {
    "name" : "private void drawAccessibilityFocusedDrawableIfNeeded(Canvas canvas)",
    "returnType" : "void",
    "comment" : "\n     * We want to draw a highlight around the current accessibility focused.\n     * Since adding a style for all possible view is not a viable option we\n     * have this specialized drawing method.\n     *\n     * Note: We are doing this here to be able to draw the highlight for\n     *       virtual views in addition to real ones.\n     *\n     * Note: A round accessibility focus border is drawn on rounded watch\n     *\n     * Note: Need to set bounds of accessibility focused drawable before drawing on rounded watch,\n     * so that when accessibility focus moved, root will be invalidated at\n     * {@link #draw(boolean, SurfaceSyncGroup, boolean)} and accessibility focus border will be\n     * updated.\n     *\n     * @param canvas The canvas on which to draw.\n     ",
    "links" : [ "#draw(boolean" ]
  }, {
    "name" : "private int getRoundDisplayRadius()",
    "returnType" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private Paint getRoundDisplayAccessibilityHighlightPaint()",
    "returnType" : "Paint",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private void drawAccessibilityFocusedBorderOnRoundDisplay(Canvas canvas, Rect bounds, int roundDisplayRadius, Paint accessibilityFocusHighlightPaint)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private boolean getAccessibilityFocusedRect(Rect bounds)",
    "returnType" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private Drawable getAccessibilityFocusedDrawable()",
    "returnType" : "Drawable",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : " void updateSystemGestureExclusionRectsForView(View view)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : " void systemGestureExclusionChanged()",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public void updateDecorViewGestureInterception(boolean intercepted)",
    "returnType" : "void",
    "comment" : "\n     * Called from DecorView when gesture interception state has changed.\n     *\n     * @param intercepted If DecorView is intercepting touch events\n     ",
    "links" : [ ]
  }, {
    "name" : " void decorViewInterceptionChanged(boolean intercepted)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public void setRootSystemGestureExclusionRects(@NonNull List<Rect> rects)",
    "returnType" : "void",
    "comment" : "\n     * Set the root-level system gesture exclusion rects. These are added to those provided by\n     * the root's view hierarchy.\n     ",
    "links" : [ ]
  }, {
    "name" : "public List<Rect> getRootSystemGestureExclusionRects()",
    "returnType" : "List<Rect>",
    "comment" : "\n     * Returns the root-level system gesture exclusion rects. These do not include those provided by\n     * the root's view hierarchy.\n     ",
    "links" : [ ]
  }, {
    "name" : " void updateKeepClearRectsForView(View view)",
    "returnType" : "void",
    "comment" : "\n     * Called from View when the position listener is triggered\n     ",
    "links" : [ ]
  }, {
    "name" : "private void updateKeepClearForAccessibilityFocusRect()",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : " void keepClearRectsChanged(boolean accessibilityFocusRectChanged)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : " void reportKeepClearAreasChanged()",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public void requestInvalidateRootRenderNode()",
    "returnType" : "void",
    "comment" : "\n     * Requests that the root render node is invalidated next time we perform a draw, such that\n     * {@link WindowCallbacks#onPostDraw} gets called.\n     ",
    "links" : [ "android.view.WindowCallbacks#onPostDraw" ]
  }, {
    "name" : " boolean scrollToRectOrFocus(Rect rectangle, boolean immediate)",
    "returnType" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public void setScrollY(int scrollY)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public int getScrollY()",
    "returnType" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public View getAccessibilityFocusedHost()",
    "returnType" : "View",
    "comment" : "\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public AccessibilityNodeInfo getAccessibilityFocusedVirtualView()",
    "returnType" : "AccessibilityNodeInfo",
    "comment" : "\n     * Get accessibility-focused virtual view. The bounds and sourceNodeId of the returned node is\n     * up-to-date while other fields may be stale.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : " void setAccessibilityFocus(View view, AccessibilityNodeInfo node)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : " boolean hasPointerCapture()",
    "returnType" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : " void requestPointerCapture(boolean enabled)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private void handlePointerCaptureChanged(boolean hasCapture)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private void updateColorModeIfNeeded(@ActivityInfo.ColorMode int colorMode, float desiredRatio)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public void requestChildFocus(View child, View focused)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public void clearChildFocus(View child)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public ViewParent getParentForAccessibility()",
    "returnType" : "ViewParent",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public void focusableViewAvailable(View v)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public void recomputeViewAttributes(View child)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : " void dispatchDetachedFromWindow()",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private void performConfigurationChange(@NonNull MergedConfiguration mergedConfiguration, boolean force, int newDisplayId, @Nullable ActivityWindowInfo activityWindowInfo)",
    "returnType" : "void",
    "comment" : "\n     * Notifies all callbacks that configuration and/or display has changed and updates internal\n     * state.\n     * @param mergedConfiguration New global and override config in {@link MergedConfiguration}\n     *                            container.\n     * @param force Flag indicating if we should force apply the config.\n     * @param newDisplayId Id of new display if moved, {@link Display#INVALID_DISPLAY} if not\n     *                     changed.\n     * @param activityWindowInfo New activity window info. {@code null} if it is non-app window, or\n     *                           this is not a Configuration change to the activity window (global).\n     ",
    "links" : [ "com.android.window.flags.Flags.enableBufferTransformHintFromDisplay#INVALID_DISPLAY", "android.util.MergedConfiguration" ]
  }, {
    "name" : "public void updateConfiguration(int newDisplayId)",
    "returnType" : "void",
    "comment" : "\n     * Update display and views if last applied merged configuration changed.\n     * @param newDisplayId Id of new display if moved, {@link Display#INVALID_DISPLAY} otherwise.\n     ",
    "links" : [ "com.android.window.flags.Flags.enableBufferTransformHintFromDisplay#INVALID_DISPLAY" ]
  }, {
    "name" : "private void updateLastConfigurationFromResources(Configuration resConfig)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public static boolean isViewDescendantOf(View child, View parent)",
    "returnType" : "boolean",
    "comment" : "\n     * Return true if child is an ancestor of parent, (or equal to the parent).\n     ",
    "links" : [ ]
  }, {
    "name" : "private static void forceLayout(View view)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : " boolean ensureTouchMode(boolean inTouchMode)",
    "returnType" : "boolean",
    "comment" : "\n     * Something in the current window tells us we need to change the touch mode.  For\n     * example, we are not in touch mode, and the user touches the screen.\n     *\n     * If the touch mode has changed, tell the window manager, and handle it locally.\n     *\n     * @param inTouchMode Whether we want to be in touch mode.\n     * @return True if the touch mode changed and focus changed was changed as a result\n     ",
    "links" : [ ]
  }, {
    "name" : "private boolean ensureTouchModeLocally(boolean inTouchMode)",
    "returnType" : "boolean",
    "comment" : "\n     * Ensure that the touch mode for this window is set, and if it is changing,\n     * take the appropriate action.\n     * @param inTouchMode Whether we want to be in touch mode.\n     * @return True if the touch mode changed and focus changed was changed as a result\n     ",
    "links" : [ ]
  }, {
    "name" : "private boolean enterTouchMode()",
    "returnType" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private static ViewGroup findAncestorToTakeFocusInTouchMode(View focused)",
    "returnType" : "ViewGroup",
    "comment" : "\n     * Find an ancestor of focused that wants focus after its descendants and is\n     * focusable in touch mode.\n     * @param focused The currently focused view.\n     * @return An appropriate view, or null if no such view exists.\n     ",
    "links" : [ ]
  }, {
    "name" : "private boolean leaveTouchMode()",
    "returnType" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public boolean isHandlingPointerEvent()",
    "returnType" : "boolean",
    "comment" : "\n     * Returns whether this view is currently handling a pointer event.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "private void resetPointerIcon(MotionEvent event)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public void refreshPointerIcon()",
    "returnType" : "void",
    "comment" : "\n     * If there is pointer that is showing a PointerIcon in this window, refresh the icon for that\n     * pointer. This will resolve the PointerIcon through the view hierarchy.\n     ",
    "links" : [ ]
  }, {
    "name" : "private boolean updatePointerIcon(MotionEvent event)",
    "returnType" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private void maybeUpdateTooltip(MotionEvent event)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private View getFocusedViewOrNull()",
    "returnType" : "View",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private static boolean isNavigationKey(KeyEvent keyEvent)",
    "returnType" : "boolean",
    "comment" : "\n     * Returns true if the key is used for keyboard navigation.\n     * @param keyEvent The key event.\n     * @return True if the key is used for keyboard navigation.\n     ",
    "links" : [ ]
  }, {
    "name" : "private static boolean isTypingKey(KeyEvent keyEvent)",
    "returnType" : "boolean",
    "comment" : "\n     * Returns true if the key is used for typing.\n     * @param keyEvent The key event.\n     * @return True if the key is used for typing.\n     ",
    "links" : [ ]
  }, {
    "name" : "private boolean checkForLeavingTouchModeAndConsume(KeyEvent event)",
    "returnType" : "boolean",
    "comment" : "\n     * See if the key event means we should leave touch mode (and leave touch mode if so).\n     * @param event The key event.\n     * @return Whether this key event should be consumed (meaning the act of\n     *   leaving touch mode alone is considered the event).\n     ",
    "links" : [ ]
  }, {
    "name" : " void setLocalDragState(Object obj)",
    "returnType" : "void",
    "comment" : " drag/drop ",
    "links" : [ ]
  }, {
    "name" : "private void handleDragEvent(DragEvent event)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public void onWindowTitleChanged()",
    "returnType" : "void",
    "comment" : "\n     * Notify that the window title changed\n     ",
    "links" : [ ]
  }, {
    "name" : "public void handleDispatchWindowShown()",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public void handleRequestKeyboardShortcuts(IResultReceiver receiver, int deviceId)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public void getLastTouchPoint(Point outLocation)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public int getLastTouchSource()",
    "returnType" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public int getLastTouchDeviceId()",
    "returnType" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public int getLastTouchPointerId()",
    "returnType" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public int getLastClickToolType()",
    "returnType" : "int",
    "comment" : "\n     * Used by InputMethodManager.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public void setDragFocus(View newDragTarget, DragEvent event)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : " void setDragStartedViewForAccessibility(View view)",
    "returnType" : "void",
    "comment" : " Sets the view that started drag and drop for the purpose of sending AccessibilityEvents ",
    "links" : [ ]
  }, {
    "name" : "private AudioManager getAudioManager()",
    "returnType" : "AudioManager",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private AutofillManager getAutofillManager()",
    "returnType" : "AutofillManager",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private boolean isAutofillUiShowing()",
    "returnType" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public AccessibilityInteractionController getAccessibilityInteractionController()",
    "returnType" : "AccessibilityInteractionController",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private int relayoutWindow(WindowManager.LayoutParams params, int viewVisibility, boolean insetsPending) throws RemoteException",
    "returnType" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private void updateOpacity(WindowManager.LayoutParams params, boolean dragResizing, boolean forceUpdate)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private void setFrame(Rect frame, boolean withinRelayout)",
    "returnType" : "void",
    "comment" : "\n     * Set the mWinFrame of this window.\n     * @param frame the new frame of this window.\n     * @param withinRelayout {@code true} if this setting is within the relayout, or is the initial\n     *                       setting. That will make sure in the relayout process, we always compare\n     *                       the window frame with the last processed window frame.\n     ",
    "links" : [ ]
  }, {
    "name" : " void setOverrideInsetsFrame(Rect frame)",
    "returnType" : "void",
    "comment" : "\n     * In the normal course of operations we compute insets relative to\n     * the frame returned from relayout window. In the case of\n     * SurfaceControlViewHost, this frame is in local coordinates\n     * instead of global coordinates. We support this override\n     * frame so we can allow SurfaceControlViewHost to set a frame\n     * to be used to calculate insets, without disturbing the main\n     * mFrame.\n     ",
    "links" : [ ]
  }, {
    "name" : " void getDisplayFrame(Rect outFrame)",
    "returnType" : "void",
    "comment" : "\n     * Gets the current display size in which the window is being laid out, accounting for screen\n     * decorations around it.\n     ",
    "links" : [ ]
  }, {
    "name" : " void getWindowVisibleDisplayFrame(Rect outFrame)",
    "returnType" : "void",
    "comment" : "\n     * Gets the current display size in which the window is being laid out, accounting for screen\n     * decorations around it.\n     ",
    "links" : [ ]
  }, {
    "name" : " void applyViewBoundsSandboxingIfNeeded(final Rect inOutRect)",
    "returnType" : "void",
    "comment" : "\n     * Offset outRect to make it sandboxed within Window's bounds.\n     *\n     * <p>This is used by {@link android.view.View#getBoundsOnScreen},\n     * {@link android.view.ViewRootImpl#getDisplayFrame} and\n     * {@link android.view.ViewRootImpl#getWindowVisibleDisplayFrame}, which are invoked by\n     * {@link android.view.View#getWindowDisplayFrame} and\n     * {@link android.view.View#getWindowVisibleDisplayFrame}, as well as\n     * {@link android.view.ViewDebug#captureLayers} for debugging.\n     ",
    "links" : [ "android.view.View#getBoundsOnScreen", "android.view.ViewRootImpl#getWindowVisibleDisplayFrame", "android.view.View#getWindowVisibleDisplayFrame", "android.view.ViewRootImpl#getDisplayFrame", "android.view.ViewDebug#captureLayers", "android.view.View#getWindowDisplayFrame" ]
  }, {
    "name" : "public void applyViewLocationSandboxingIfNeeded(@Size(2) int[] outLocation)",
    "returnType" : "void",
    "comment" : "\n     * Offset outLocation to make it sandboxed within Window's bounds.\n     *\n     * <p>This is used by {@link android.view.View#getLocationOnScreen(int[])}\n     ",
    "links" : [ "android.view.View#getLocationOnScreen(int" ]
  }, {
    "name" : "private boolean getViewBoundsSandboxingEnabled()",
    "returnType" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public void playSoundEffect(@SoundEffectConstants.SoundEffect int effectId)",
    "returnType" : "void",
    "comment" : "\n     * {@inheritDoc}\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean performHapticFeedback(int effectId, boolean always, boolean fromIme)",
    "returnType" : "boolean",
    "comment" : "\n     * {@inheritDoc}\n     ",
    "links" : [ ]
  }, {
    "name" : "public View focusSearch(View focused, int direction)",
    "returnType" : "View",
    "comment" : "\n     * {@inheritDoc}\n     ",
    "links" : [ ]
  }, {
    "name" : "public View keyboardNavigationClusterSearch(View currentCluster, @FocusDirection int direction)",
    "returnType" : "View",
    "comment" : "\n     * {@inheritDoc}\n     ",
    "links" : [ ]
  }, {
    "name" : "public void debug()",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public void dumpDebug(ProtoOutputStream proto, long fieldId)",
    "returnType" : "void",
    "comment" : "\n     * Export the state of {@link ViewRootImpl} and other relevant classes into a protocol buffer\n     * output stream.\n     *\n     * @param proto Stream to write the state to\n     * @param fieldId FieldId of ViewRootImpl as defined in the parent message\n     ",
    "links" : [ "android.view.ViewRootImpl" ]
  }, {
    "name" : "public void dump(String prefix, PrintWriter writer)",
    "returnType" : "void",
    "comment" : "\n     * Dump information about this ViewRootImpl\n     * @param prefix the prefix that will be prepended to each line of the produced output\n     * @param writer the writer that will receive the resulting text\n     ",
    "links" : [ ]
  }, {
    "name" : "private void dumpViewHierarchy(String prefix, PrintWriter writer, View view)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : " GfxInfo getGfxInfo()",
    "returnType" : "GfxInfo",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private static void computeRenderNodeUsage(RenderNode node, GfxInfo info)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private static void appendGfxInfo(View view, GfxInfo info)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : " boolean die(boolean immediate)",
    "returnType" : "boolean",
    "comment" : "\n     * @param immediate True, do now if not in traversal. False, put on queue and do later.\n     * @return True, request has been queued. False, request has been completed.\n     ",
    "links" : [ ]
  }, {
    "name" : " void doDie()",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public void requestUpdateConfiguration(Configuration config)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public void loadSystemProperties()",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private void destroyHardwareRenderer()",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private void dispatchResized(ClientWindowFrames frames, boolean reportDraw, MergedConfiguration mergedConfiguration, InsetsState insetsState, boolean forceLayout, boolean alwaysConsumeSystemBars, int displayId, int syncSeqId, boolean dragResizing, @Nullable ActivityWindowInfo activityWindowInfo)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private void dispatchInsetsControlChanged(InsetsState insetsState, InsetsSourceControl[] activeControls)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private void showInsets(@InsetsType int types, boolean fromIme, @Nullable ImeTracker.Token statsToken)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private void hideInsets(@InsetsType int types, boolean fromIme, @Nullable ImeTracker.Token statsToken)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public void dispatchMoved(int newX, int newY)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private QueuedInputEvent obtainQueuedInputEvent(InputEvent event, InputEventReceiver receiver, int flags)",
    "returnType" : "QueuedInputEvent",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private void recycleQueuedInputEvent(QueuedInputEvent q)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public void enqueueInputEvent(InputEvent event)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : " void enqueueInputEvent(InputEvent event, InputEventReceiver receiver, int flags, boolean processImmediately)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private void scheduleProcessInputEvents()",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : " void doProcessInputEvents()",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private void deliverInputEvent(QueuedInputEvent q)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private void finishInputEvent(QueuedInputEvent q)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private void logHandledSystemKey(KeyEvent event, boolean handled)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : " static boolean isTerminalInputEvent(InputEvent event)",
    "returnType" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : " void scheduleConsumeBatchedInput()",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : " void unscheduleConsumeBatchedInput()",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : " void scheduleConsumeBatchedInputImmediately()",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : " boolean doConsumeBatchedInput(long frameTimeNanos)",
    "returnType" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public void dispatchInvalidateDelayed(View view, long delayMilliseconds)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public void dispatchInvalidateRectDelayed(AttachInfo.InvalidateInfo info, long delayMilliseconds)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public void dispatchInvalidateOnAnimation(View view)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public void dispatchInvalidateRectOnAnimation(AttachInfo.InvalidateInfo info)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public void cancelInvalidate(View view)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public void dispatchInputEvent(InputEvent event)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public void dispatchInputEvent(InputEvent event, InputEventReceiver receiver)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public void synthesizeInputEvent(InputEvent event)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public void dispatchKeyFromIme(KeyEvent event)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public void dispatchKeyFromAutofill(KeyEvent event)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public void dispatchUnhandledInputEvent(InputEvent event)",
    "returnType" : "void",
    "comment" : "\n     * Reinject unhandled {@link InputEvent}s in order to synthesize fallbacks events.\n     *\n     * Note that it is the responsibility of the caller of this API to recycle the InputEvent it\n     * passes in.\n     ",
    "links" : [ "android.view.InputEvent" ]
  }, {
    "name" : "public void dispatchAppVisibility(boolean visible)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public void dispatchGetNewSurface()",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public void windowFocusChanged(boolean hasFocus)",
    "returnType" : "void",
    "comment" : "\n     * Notifies this {@link ViewRootImpl} object that window focus has changed.\n     ",
    "links" : [ "android.view.ViewRootImpl" ]
  }, {
    "name" : "public void touchModeChanged(boolean inTouchMode)",
    "returnType" : "void",
    "comment" : "\n     * Notifies this {@link ViewRootImpl} object that touch mode state has changed.\n     ",
    "links" : [ "android.view.ViewRootImpl" ]
  }, {
    "name" : "public void dispatchWindowShown()",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public void dispatchCloseSystemDialogs(String reason)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public void dispatchDragEvent(DragEvent event)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public void dispatchCheckFocus()",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public void dispatchRequestKeyboardShortcuts(IResultReceiver receiver, int deviceId)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private void dispatchPointerCaptureChanged(boolean on)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private void postSendWindowContentChangedCallback(View source, int changeType)",
    "returnType" : "void",
    "comment" : "\n     * Post a callback to send a\n     * {@link AccessibilityEvent#TYPE_WINDOW_CONTENT_CHANGED} event.\n     * This event is send at most once every\n     * {@link ViewConfiguration#getSendRecurringAccessibilityEventsInterval()}.\n     ",
    "links" : [ "android.view.accessibility.AccessibilityEvent#TYPE_WINDOW_CONTENT_CHANGED", "android.view.ViewConfiguration#getSendRecurringAccessibilityEventsInterval()" ]
  }, {
    "name" : "private void removeSendWindowContentChangedCallback()",
    "returnType" : "void",
    "comment" : "\n     * Remove a posted callback to send a\n     * {@link AccessibilityEvent#TYPE_WINDOW_CONTENT_CHANGED} event.\n     ",
    "links" : [ "android.view.accessibility.AccessibilityEvent#TYPE_WINDOW_CONTENT_CHANGED" ]
  }, {
    "name" : "public int getDirectAccessibilityConnectionId()",
    "returnType" : "int",
    "comment" : "\n     * Return the connection ID for the {@link AccessibilityInteractionController} of this instance.\n     * @see AccessibilityNodeInfo#setQueryFromAppProcessEnabled\n     ",
    "links" : [ "android.view.AccessibilityInteractionController" ]
  }, {
    "name" : "public boolean showContextMenuForChild(View originalView)",
    "returnType" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public boolean showContextMenuForChild(View originalView, float x, float y)",
    "returnType" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public ActionMode startActionModeForChild(View originalView, ActionMode.Callback callback)",
    "returnType" : "ActionMode",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public ActionMode startActionModeForChild(View originalView, ActionMode.Callback callback, int type)",
    "returnType" : "ActionMode",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public void createContextMenu(ContextMenu menu)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public void childDrawableStateChanged(View child)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public boolean requestSendAccessibilityEvent(View child, AccessibilityEvent event)",
    "returnType" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private View getSourceForAccessibilityEvent(AccessibilityEvent event)",
    "returnType" : "View",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private boolean isAccessibilityFocusDirty()",
    "returnType" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private void handleWindowContentChangedEvent(AccessibilityEvent event)",
    "returnType" : "void",
    "comment" : "\n     * Updates the focused virtual view, when necessary, in response to a\n     * content changed event.\n     * <p>\n     * This is necessary to get updated bounds after a position change.\n     *\n     * @param event an accessibility event of type\n     *              {@link AccessibilityEvent#TYPE_WINDOW_CONTENT_CHANGED}\n     ",
    "links" : [ "android.view.accessibility.AccessibilityEvent#TYPE_WINDOW_CONTENT_CHANGED" ]
  }, {
    "name" : "public void notifySubtreeAccessibilityStateChanged(View child, View source, int changeType)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public boolean canResolveLayoutDirection()",
    "returnType" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public boolean isLayoutDirectionResolved()",
    "returnType" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public int getLayoutDirection()",
    "returnType" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public boolean canResolveTextDirection()",
    "returnType" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public boolean isTextDirectionResolved()",
    "returnType" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public int getTextDirection()",
    "returnType" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public boolean canResolveTextAlignment()",
    "returnType" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public boolean isTextAlignmentResolved()",
    "returnType" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public int getTextAlignment()",
    "returnType" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private View getCommonPredecessor(View first, View second)",
    "returnType" : "View",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : " void checkThread()",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public void requestDisallowInterceptTouchEvent(boolean disallowIntercept)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public boolean requestChildRectangleOnScreen(View child, Rect rectangle, boolean immediate)",
    "returnType" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public void childHasTransientStateChanged(View child, boolean hasTransientState)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public boolean onStartNestedScroll(View child, View target, int nestedScrollAxes)",
    "returnType" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public void onStopNestedScroll(View target)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public void onNestedScrollAccepted(View child, View target, int nestedScrollAxes)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public void onNestedScroll(View target, int dxConsumed, int dyConsumed, int dxUnconsumed, int dyUnconsumed)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public void onNestedPreScroll(View target, int dx, int dy, int[] consumed)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public boolean onNestedFling(View target, float velocityX, float velocityY, boolean consumed)",
    "returnType" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public boolean onNestedPreFling(View target, float velocityX, float velocityY)",
    "returnType" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public boolean onNestedPrePerformAccessibilityAction(View target, int action, Bundle args)",
    "returnType" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public boolean probablyHasInput()",
    "returnType" : "boolean",
    "comment" : "\n     * Checks the input event receiver for input availability.\n     * May return false negatives.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public void addScrollCaptureCallback(ScrollCaptureCallback callback)",
    "returnType" : "void",
    "comment" : "\n     * Adds a scroll capture callback to this window.\n     *\n     * @param callback the callback to add\n     ",
    "links" : [ ]
  }, {
    "name" : "public void removeScrollCaptureCallback(ScrollCaptureCallback callback)",
    "returnType" : "void",
    "comment" : "\n     * Removes a scroll capture callback from this window.\n     *\n     * @param callback the callback to remove\n     ",
    "links" : [ ]
  }, {
    "name" : "public void dispatchScrollCaptureRequest(@NonNull IScrollCaptureResponseListener listener)",
    "returnType" : "void",
    "comment" : "\n     * Dispatches a scroll capture request to the view hierarchy on the ui thread.\n     *\n     * @param listener for the response\n     ",
    "links" : [ ]
  }, {
    "name" : " void processingBackKey(boolean processing)",
    "returnType" : "void",
    "comment" : " Make this VRI able to process back key without drop it.",
    "links" : [ ]
  }, {
    "name" : "private void collectRootScrollCaptureTargets(ScrollCaptureSearchResults results)",
    "returnType" : "void",
    "comment" : "\n     * Collect and include any ScrollCaptureCallback instances registered with the window.\n     *\n     * @see #addScrollCaptureCallback(ScrollCaptureCallback)\n     * @param results an object to collect the results of the search\n     ",
    "links" : [ ]
  }, {
    "name" : "public void setScrollCaptureRequestTimeout(int timeMillis)",
    "returnType" : "void",
    "comment" : "\n     * Update the timeout for scroll capture requests. Only affects this view root.\n     * The default value is {@link #SCROLL_CAPTURE_REQUEST_TIMEOUT_MILLIS}.\n     *\n     * @param timeMillis the new timeout in milliseconds\n     ",
    "links" : [ "#SCROLL_CAPTURE_REQUEST_TIMEOUT_MILLIS" ]
  }, {
    "name" : "public long getScrollCaptureRequestTimeout()",
    "returnType" : "long",
    "comment" : "\n     * Get the current timeout for scroll capture requests.\n     *\n     * @return the timeout in milliseconds\n     ",
    "links" : [ ]
  }, {
    "name" : "public void handleScrollCaptureRequest(@NonNull IScrollCaptureResponseListener listener)",
    "returnType" : "void",
    "comment" : "\n     * Handles an inbound request for scroll capture from the system. A search will be\n     * dispatched through the view tree to locate scrolling content.\n     * <p>\n     * A call to\n     * {@link IScrollCaptureResponseListener#onScrollCaptureResponse} will follow.\n     *\n     * @param listener to receive responses\n     * @see ScrollCaptureSearchResults\n     ",
    "links" : [ "#onScrollCaptureResponse" ]
  }, {
    "name" : "private void dispatchScrollCaptureSearchResponse(@NonNull IScrollCaptureResponseListener listener, @NonNull ScrollCaptureSearchResults results)",
    "returnType" : "void",
    "comment" : " Called by {@link #handleScrollCaptureRequest} when a result is returned ",
    "links" : [ "#handleScrollCaptureRequest" ]
  }, {
    "name" : "private void reportNextDraw(String reason)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public void setReportNextDraw(boolean syncBuffer, String reason)",
    "returnType" : "void",
    "comment" : "\n     * Force the window to report its next draw.\n     * <p>\n     * This method is only supposed to be used to speed up the interaction from SystemUI and window\n     * manager when waiting for the first frame to be drawn when turning on the screen. DO NOT USE\n     * unless you fully understand this interaction.\n     *\n     * @param syncBuffer If true, the transaction that contains the buffer from the draw should be\n     *                   sent to system to be synced. If false, VRI will not try to sync the buffer,\n     *                   but only report back that a buffer was drawn.\n     * @param reason A debug string indicating the reason for reporting the next draw\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : " void changeCanvasOpacity(boolean opaque)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public boolean dispatchUnhandledKeyEvent(KeyEvent event)",
    "returnType" : "boolean",
    "comment" : "\n     * Dispatches a KeyEvent to all registered key fallback handlers.\n     *\n     * @param event\n     * @return {@code true} if the event was handled, {@code false} otherwise.\n     ",
    "links" : [ ]
  }, {
    "name" : " static HandlerActionQueue getRunQueue()",
    "returnType" : "HandlerActionQueue",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private void startDragResizing(Rect initialBounds, boolean fullscreen, Rect systemInsets, Rect stableInsets)",
    "returnType" : "void",
    "comment" : "\n     * Start a drag resizing which will inform all listeners that a window resize is taking place.\n     ",
    "links" : [ ]
  }, {
    "name" : "private void endDragResizing()",
    "returnType" : "void",
    "comment" : "\n     * End a drag resize which will inform all listeners that a window resize has ended.\n     ",
    "links" : [ ]
  }, {
    "name" : "private boolean updateContentDrawBounds()",
    "returnType" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private void requestDrawWindow()",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public SurfaceControl getSurfaceControl()",
    "returnType" : "SurfaceControl",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public IBinder getInputToken()",
    "returnType" : "IBinder",
    "comment" : "\n     * @return Returns a token used to identify the windows input channel.\n     ",
    "links" : [ ]
  }, {
    "name" : "public InputTransferToken getInputTransferToken()",
    "returnType" : "InputTransferToken",
    "comment" : "\n     * {@inheritDoc}\n     ",
    "links" : [ ]
  }, {
    "name" : "public IBinder getWindowToken()",
    "returnType" : "IBinder",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public IAccessibilityEmbeddedConnection getAccessibilityEmbeddedConnection()",
    "returnType" : "IAccessibilityEmbeddedConnection",
    "comment" : "\n     * Gets an accessibility embedded connection interface for this ViewRootImpl.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public void setDisplayDecoration(boolean displayDecoration)",
    "returnType" : "void",
    "comment" : "\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "private void updateDisplayDecoration()",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public void dispatchBlurRegions(float[][] regionCopy, long frameNumber)",
    "returnType" : "void",
    "comment" : "\n     * Sends a list of blur regions to SurfaceFlinger, tagged with a frame.\n     *\n     * @param regionCopy List of regions\n     * @param frameNumber Frame where it should be applied (or current when using BLAST)\n     ",
    "links" : [ ]
  }, {
    "name" : "public BackgroundBlurDrawable createBackgroundBlurDrawable()",
    "returnType" : "BackgroundBlurDrawable",
    "comment" : "\n     * Creates a background blur drawable for the backing {@link Surface}.\n     ",
    "links" : [ "android.view.flags.Flags.addSchandleToVriSurface" ]
  }, {
    "name" : "public void onDescendantUnbufferedRequested()",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : " int getSurfaceSequenceId()",
    "returnType" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public void mergeWithNextTransaction(Transaction t, long frameNumber)",
    "returnType" : "void",
    "comment" : "\n     * Merges the transaction passed in with the next transaction in BLASTBufferQueue. This ensures\n     * you can add transactions to the upcoming frame.\n     ",
    "links" : [ ]
  }, {
    "name" : "public SurfaceControl.Transaction buildReparentTransaction(@NonNull SurfaceControl child)",
    "returnType" : "SurfaceControl.Transaction",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public boolean applyTransactionOnDraw(@NonNull SurfaceControl.Transaction t)",
    "returnType" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public int getBufferTransformHint()",
    "returnType" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public void addOnBufferTransformHintChangedListener(OnBufferTransformHintChangedListener listener)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public void removeOnBufferTransformHintChangedListener(OnBufferTransformHintChangedListener listener)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private void dispatchTransformHintChanged(@SurfaceControl.BufferTransform int hint)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public void requestCompatCameraControl(boolean showControl, boolean transformationApplied, ICompatCameraControlCallback callback)",
    "returnType" : "void",
    "comment" : "\n     * Shows or hides a Camera app compat toggle for stretched issues with the requested state\n     * for the corresponding activity.\n     *\n     * @param showControl Whether the control should be shown or hidden.\n     * @param transformationApplied Whether the treatment is already applied.\n     * @param callback The callback executed when the user clicks on a control.\n    ",
    "links" : [ ]
  }, {
    "name" : " boolean wasRelayoutRequested()",
    "returnType" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : " void forceWmRelayout()",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public WindowOnBackInvokedDispatcher getOnBackInvokedDispatcher()",
    "returnType" : "WindowOnBackInvokedDispatcher",
    "comment" : "\n     * Returns the {@link OnBackInvokedDispatcher} on the decor view if one exists, or the\n     * fallback {@link OnBackInvokedDispatcher} instance.\n     ",
    "links" : [ "android.window.OnBackInvokedDispatcher" ]
  }, {
    "name" : "public OnBackInvokedDispatcher findOnBackInvokedDispatcherForChild(@NonNull View child, @NonNull View requester)",
    "returnType" : "OnBackInvokedDispatcher",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private void registerBackCallbackOnWindow()",
    "returnType" : "void",
    "comment" : "\n     * When this ViewRootImpl is added to the window manager, transfers the first\n     * {@link OnBackInvokedCallback} to be called to the server.\n     ",
    "links" : [ "android.window.CompatOnBackInvokedCallback" ]
  }, {
    "name" : "private void sendBackKeyEvent(int action)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private void registerCompatOnBackInvokedCallback()",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public void setTouchableRegion(Region r)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : " IWindowSession getWindowSession()",
    "returnType" : "IWindowSession",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private void registerCallbacksForSync(boolean syncBuffer, final SurfaceSyncGroup surfaceSyncGroup)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private void safeguardOverlappingSyncs(SurfaceSyncGroup activeSurfaceSyncGroup)",
    "returnType" : "void",
    "comment" : "\n     * This code will ensure that if multiple SurfaceSyncGroups are created for the same\n     * ViewRootImpl the SurfaceSyncGroups will maintain an order. The scenario that could occur\n     * is the following:\n     * <p>\n     * 1. SSG1 is created that includes the target VRI. There could be other VRIs in SSG1\n     * 2. The target VRI draws its frame and marks its own active SSG as ready, but SSG1 is still\n     *    waiting on other things in the SSG\n     * 3. Another SSG2 is created for the target VRI. The second frame renders and marks its own\n     *    second SSG as complete. SSG2 has nothing else to wait on, so it will apply at this point,\n     *    even though SSG1 has not finished.\n     * 4. Frame2 will get to SF first and Frame1 will later get to SF when SSG1 completes.\n     * <p>\n     * The code below ensures the SSGs that contains the VRI maintain an order. We create a new SSG\n     * that's a safeguard SSG. Its only job is to prevent the next active SSG from completing.\n     * The current active SSG for VRI will add a transaction committed callback and when that's\n     * invoked, it will mark the safeguard SSG as ready. If a new request to create a SSG comes\n     * in and the safeguard SSG is not null, it's added as part of the new active SSG. A new\n     * safeguard SSG is created to correspond to the new active SSG. This creates a chain to\n     * ensure the latter SSG always waits for the former SSG's transaction to get to SF.\n     ",
    "links" : [ ]
  }, {
    "name" : "public SurfaceSyncGroup getOrCreateSurfaceSyncGroup()",
    "returnType" : "SurfaceSyncGroup",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private void updateSyncInProgressCount(SurfaceSyncGroup syncGroup)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : " void addToSync(SurfaceSyncGroup syncable)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public void setChildBoundingInsets(@NonNull Rect insets)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private void logAndTrace(String msg)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private void setCategoryFromCategoryCounts()",
    "returnType" : "void",
    "comment" : "\n     * Sets the mPreferredFrameRateCategory from the high, high_hint, normal, and low counts.\n     ",
    "links" : [ ]
  }, {
    "name" : "private void setPreferredFrameRateCategory(int preferredFrameRateCategory)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private static String categoryToString(int frameRateCategory)",
    "returnType" : "String",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private static String reasonToString(int reason)",
    "returnType" : "String",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private void setPreferredFrameRate(float preferredFrameRate)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private boolean shouldSetFrameRateCategory()",
    "returnType" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private boolean shouldSetFrameRate()",
    "returnType" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private boolean shouldTouchBoost(int motionEventAction, int windowType)",
    "returnType" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public void votePreferredFrameRateCategory(int frameRateCategory, int reason, View view)",
    "returnType" : "void",
    "comment" : "\n     * Allow Views to vote for the preferred frame rate category\n     *\n     * @param frameRateCategory the preferred frame rate category of a View\n     ",
    "links" : [ ]
  }, {
    "name" : " int intermittentUpdateState()",
    "returnType" : "int",
    "comment" : "\n     * Returns {@link #INTERMITTENT_STATE_INTERMITTENT} when the ViewRootImpl has only been\n     * updated intermittently, {@link #INTERMITTENT_STATE_NOT_INTERMITTENT} when it is\n     * not updated intermittently, and {@link #INTERMITTENT_STATE_IN_TRANSITION} when it\n     * is transitioning between {@link #INTERMITTENT_STATE_NOT_INTERMITTENT} and\n     * {@link #INTERMITTENT_STATE_INTERMITTENT}.\n     ",
    "links" : [ "#INTERMITTENT_STATE_NOT_INTERMITTENT", "#INTERMITTENT_STATE_IN_TRANSITION", "#INTERMITTENT_STATE_INTERMITTENT" ]
  }, {
    "name" : "public boolean shouldCheckFrameRateCategory()",
    "returnType" : "boolean",
    "comment" : "\n     * Returns whether a View should vote for frame rate category. When the category is HIGH\n     * already, there's no need to calculate the category on the View and vote.\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean shouldCheckFrameRate(boolean isDirect)",
    "returnType" : "boolean",
    "comment" : "\n     * Returns whether a View should vote for frame rate. When the maximum frame rate has already\n     * been voted for, there's no point in calculating and voting for the frame rate. When\n     * isDirect is false, then it will return false when the velocity-calculated frame rate\n     * can be avoided.\n     * @param isDirect true when the frame rate has been set directly on the View or false if\n     *                 the calculation is based only on velocity.\n     ",
    "links" : [ ]
  }, {
    "name" : "public void votePreferredFrameRate(float frameRate, int frameRateCompatibility)",
    "returnType" : "void",
    "comment" : "\n     * Allow Views to vote for the preferred frame rate and compatibility.\n     * When determining the preferred frame rate value,\n     * we follow this logic: If no preferred frame rate has been set yet,\n     * we assign the value of frameRate as the preferred frame rate.\n     * IF there are multiple frame rates are voted:\n     * 1. There is a frame rate is a multiple of all other frame rates.\n     * We choose this frmae rate to be the one to be set.\n     * 2. There is no frame rate can be a multiple of others\n     * We set category to HIGH if the maximum frame rate is greater than 60.\n     * Otherwise, we set category to NORMAL.\n     *\n     * Use FRAME_RATE_COMPATIBILITY_GTE for velocity and FRAME_RATE_COMPATIBILITY_FIXED_SOURCE\n     * for TextureView video play and user requested frame rate.\n     *\n     * @param frameRate the preferred frame rate of a View\n     * @param frameRateCompatibility the preferred frame rate compatibility of a View\n     ",
    "links" : [ ]
  }, {
    "name" : "public int getPreferredFrameRateCategory()",
    "returnType" : "int",
    "comment" : "\n     * Get the value of mPreferredFrameRateCategory\n     ",
    "links" : [ ]
  }, {
    "name" : "public int getLastPreferredFrameRateCategory()",
    "returnType" : "int",
    "comment" : "\n     * Get the value of mLastPreferredFrameRateCategory\n     ",
    "links" : [ ]
  }, {
    "name" : "public float getPreferredFrameRate()",
    "returnType" : "float",
    "comment" : "\n     * Get the value of mPreferredFrameRate\n     ",
    "links" : [ ]
  }, {
    "name" : "public float getLastPreferredFrameRate()",
    "returnType" : "float",
    "comment" : "\n     * Get the value of mLastPreferredFrameRate\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean getIsTouchBoosting()",
    "returnType" : "boolean",
    "comment" : "\n     * Returns whether touch boost is currently enabled.\n     ",
    "links" : [ ]
  }, {
    "name" : "public int getFrameRateCompatibility()",
    "returnType" : "int",
    "comment" : "\n     * Get the value of mFrameRateCompatibility\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean getIsFrameRateBoosting()",
    "returnType" : "boolean",
    "comment" : "\n     * Get the value of mIsFrameRateBoosting\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean getFrameRateBoostOnTouchEnabled()",
    "returnType" : "boolean",
    "comment" : "\n     * Get the value of mFrameRateBoostOnTouchEnabled\n     * Can be used to checked if touch boost is enabled. The default value is true.\n     ",
    "links" : [ ]
  }, {
    "name" : "private void boostFrameRate(int boostTimeOut)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : " void setBackKeyCallbackForWindowlessWindow(@NonNull Predicate<KeyEvent> callback)",
    "returnType" : "void",
    "comment" : "\n     * Set the default back key callback for windowless window, to forward the back key event\n     * to host app.\n     * MUST NOT call this method for normal window.\n     ",
    "links" : [ ]
  }, {
    "name" : " void recordViewPercentage(float percentage)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public boolean isFrameRatePowerSavingsBalanced()",
    "returnType" : "boolean",
    "comment" : "\n     * Get the value of mIsFrameRatePowerSavingsBalanced\n     * Can be used to checked if toolkit dVRR feature is enabled. The default value is true.\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean isFrameRateConflicted()",
    "returnType" : "boolean",
    "comment" : "\n     * Get the value of mIsFrameRateConflicted\n     * Can be used to checked if there is a conflict of frame rate votes.\n     ",
    "links" : [ ]
  }, {
    "name" : "private boolean shouldEnableDvrr()",
    "returnType" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private void removeVrrMessages()",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private void updateInfrequentCount()",
    "returnType" : "void",
    "comment" : "\n     * This function is mainly used for migrating infrequent layer logic\n     * from SurfaceFlinger to Toolkit.\n     * The infrequent layer logic includes:\n     * - NORMAL for infrequent update: FT2-FT1 > 100 && FT3-FT2 > 100.\n     * - HIGH/NORMAL based on size for frequent update: (FT3-FT2) + (FT2 - FT1) < 100.\n     * - otherwise, use the previous category value.\n     ",
    "links" : [ ]
  } ],
  "methodNames" : [ "protected FrameInfo getUpdatedFrameInfo()", "public ImeFocusController getImeFocusController()", "public HandwritingInitiator getHandwritingInitiator()", "public static void addFirstDrawHandler(Runnable callback)", "public static void addConfigCallback(ConfigChangedCallback callback)", "public static void removeConfigCallback(ConfigChangedCallback callback)", "public void setActivityConfigCallback(@Nullable ActivityConfigCallback callback)", "public void setOnContentApplyWindowInsetsListener(OnContentApplyWindowInsetsListener listener)", "public void addWindowCallbacks(WindowCallbacks callback)", "public void removeWindowCallbacks(WindowCallbacks callback)", "public void reportDrawFinish()", "public void profile()", "private boolean isInTouchMode()", "public void notifyChildRebuilt()", "private Configuration getConfiguration()", "private WindowConfiguration getCompatWindowConfiguration()", "public void setView(View view, WindowManager.LayoutParams attrs, View panelParentView)", "public void setView(View view, WindowManager.LayoutParams attrs, View panelParentView, int userId)", "private void setAccessibilityWindowAttributesIfNeeded()", "private boolean isForceInvertEnabled()", "private void reloadForceInvertEnabled()", "private void registerListeners()", "private void unregisterListeners()", "private void setTag()", "public int getWindowFlags()", "public int getDisplayId()", "public CharSequence getTitle()", "public int getWidth()", "public int getHeight()", " void destroyHardwareResources()", "public void detachFunctor(long functor)", "public static void invokeFunctor(long functor, boolean waitForCompletion)", "public void registerAnimatingRenderNode(RenderNode animator)", "public void registerVectorDrawableAnimator(NativeVectorDrawableAnimator animator)", "public void registerRtFrameCallback(@NonNull FrameDrawingCallback callback)", "private void enableHardwareAcceleration(WindowManager.LayoutParams attrs)", "private int getNightMode()", "public int determineForceDarkType()", "private void updateForceDarkMode()", "public View getView()", " final WindowLeaked getLocation()", "public void setLayoutParams(WindowManager.LayoutParams attrs, boolean newView)", "private int adjustLayoutInDisplayCutoutMode(WindowManager.LayoutParams attrs)", " void handleAppVisibility(boolean visible)", " void handleGetNewSurface()", "private void handleResized(ClientWindowFrames frames, boolean reportDraw, MergedConfiguration mergedConfiguration, InsetsState insetsState, boolean forceLayout, boolean alwaysConsumeSystemBars, int displayId, int syncSeqId, boolean dragResizing, @Nullable ActivityWindowInfo activityWindowInfo)", "public void onMovedToDisplay(int displayId, Configuration config)", "private void updateInternalDisplay(int displayId, Resources resources)", " void pokeDrawLockIfNeeded()", "public void requestFitSystemWindows()", " void notifyInsetsChanged()", "public void notifyInsetsAnimationRunningStateChanged(boolean running)", "public void requestLayout()", "public boolean isLayoutRequested()", "public void onDescendantInvalidated(@NonNull View child, @NonNull View descendant)", " void invalidate()", " void invalidateWorld(View view)", "public void invalidateChild(View child, Rect dirty)", "public ViewParent invalidateChildInParent(int[] location, Rect dirty)", "private void invalidateRectOnScreen(Rect dirty)", "public void setIsAmbientMode(boolean ambient)", " void setWindowStopped(boolean stopped)", "public void addSurfaceChangedCallback(SurfaceChangedCallback c)", "public void removeSurfaceChangedCallback(SurfaceChangedCallback c)", "private void notifySurfaceCreated(Transaction t)", "private void notifySurfaceReplaced(Transaction t)", "private void notifySurfaceDestroyed()", "private void notifyDrawStarted(boolean isWmSync)", "public SurfaceControl updateAndGetBoundsLayer(Transaction t)", " void updateBlastSurfaceIfNeeded()", "private void setBoundsLayerCrop(Transaction t)", "private boolean updateBoundsLayer(SurfaceControl.Transaction t)", "private void prepareSurfaces()", "private void destroySurface()", "public void setPausedForTransition(boolean paused)", "public ViewParent getParent()", "public boolean getChildVisibleRect(View child, Rect r, android.graphics.Point offset)", "public boolean getChildLocalHitRegion(@NonNull View child, @NonNull Region region, @NonNull Matrix matrix, boolean isHover)", "public void bringChildToFront(View child)", " int getHostVisibility()", "public void requestTransitionStart(LayoutTransition transition)", " void notifyRendererOfFramePending()", "public void notifyRendererOfExpensiveFrame()", " void scheduleTraversals()", " void unscheduleTraversals()", " void doTraversal()", "private void applyKeepScreenOnFlag(WindowManager.LayoutParams params)", "private boolean collectViewAttributes()", "private int getImpliedSystemUiVisibility(WindowManager.LayoutParams params)", " void updateCompatSysUiVisibility(@InsetsType int visibleTypes, @InsetsType int requestedVisibleTypes, @InsetsType int controllableTypes)", "private void updateCompatSystemUiVisibilityInfo(int systemUiFlag, @InsetsType int insetsType, @InsetsType int visibleTypes, @InsetsType int controllableTypes)", "private void clearLowProfileModeIfNeeded(@InsetsType int showTypes, boolean fromIme)", "private void dispatchDispatchSystemUiVisibilityChanged()", "private void handleDispatchSystemUiVisibilityChanged()", "public static void adjustLayoutParamsForCompatibility(WindowManager.LayoutParams inOutParams, @Appearance int appearanceControlled, boolean behaviorControlled)", "private void controlInsetsForCompatibility(WindowManager.LayoutParams params)", "private boolean measureHierarchy(final View host, final WindowManager.LayoutParams lp, final Resources res, final int desiredWindowWidth, final int desiredWindowHeight, boolean forRootSizeOnly)", "private boolean setMeasuredRootSizeFromSpec(int widthMeasureSpec, int heightMeasureSpec)", " void transformMatrixToGlobal(Matrix m)", " void transformMatrixToLocal(Matrix m)", " WindowInsets getWindowInsets(boolean forceConstruct)", "public void dispatchApplyInsets(View host)", "private boolean shouldDispatchCutout()", "public InsetsController getInsetsController()", "private static boolean shouldUseDisplaySize(final WindowManager.LayoutParams lp)", "private static boolean shouldOptimizeMeasure(final WindowManager.LayoutParams lp)", "private Rect getWindowBoundsInsetSystemBars()", " int dipToPx(int dip)", "private void performTraversals()", "private void createSyncIfNeeded()", "private void applySensitiveContentAppProtection(boolean enableProtection)", " void addSensitiveContentAppProtection()", " void removeSensitiveContentAppProtection()", "private void notifyContentCaptureEvents()", "private void notifyHolderSurfaceDestroyed()", "private void maybeHandleWindowMove(Rect frame)", "private void handleWindowFocusChanged()", "public void dispatchCompatFakeFocus()", "private void dispatchFocusEvent(boolean hasWindowFocus, boolean fakeFocus)", "private void handleWindowTouchModeChanged()", "private void maybeFireAccessibilityWindowStateChangedEvent()", "private void fireAccessibilityFocusEventIfHasFocusedNode()", "private AccessibilityNodeInfo findFocusedVirtualNode(AccessibilityNodeProvider provider)", "private void handleOutOfResourcesException(Surface.OutOfResourcesException e)", "private void performMeasure(int childWidthMeasureSpec, int childHeightMeasureSpec)", " boolean isInLayout()", " boolean requestLayoutDuringLayout(final View view)", "private void performLayout(WindowManager.LayoutParams lp, int desiredWindowWidth, int desiredWindowHeight)", "private ArrayList<View> getValidLayoutRequesters(ArrayList<View> layoutRequesters, boolean secondLayoutRequests)", "public void requestTransparentRegion(View child)", "private static int getRootMeasureSpec(int windowSize, int measurement, int privateFlags)", "public void onPreDraw(RecordingCanvas canvas)", "public void onPostDraw(RecordingCanvas canvas)", " void outputDisplayList(View view)", "private void profileRendering(boolean enabled)", "private void trackFPS()", "private void collectFrameRateDecisionMetrics()", "private void reportDrawFinished(@Nullable Transaction t, int seqId)", "public boolean isHardwareEnabled()", "public boolean isInWMSRequestedSync()", "private void addFrameCommitCallbackIfNeeded()", "private void registerCallbackForPendingTransactions()", "private boolean performDraw(@Nullable SurfaceSyncGroup surfaceSyncGroup)", "private void handleSyncRequestWhenNoAsyncDraw(SurfaceSyncGroup surfaceSyncGroup, boolean hasPendingTransaction, @Nullable Transaction pendingTransaction, String logReason)", "private boolean isContentCaptureEnabled()", "private boolean isContentCaptureReallyEnabled()", "private void performContentCaptureInitialReport()", "private void handleContentCaptureFlush()", "private boolean draw(boolean fullRedrawNeeded, @Nullable SurfaceSyncGroup activeSyncGroup, boolean syncBuffer)", "private boolean drawSoftware(Surface surface, AttachInfo attachInfo, int xoff, int yoff, boolean scalingRequired, Rect dirty, Rect surfaceInsets)", "private void drawAccessibilityFocusedDrawableIfNeeded(Canvas canvas)", "private int getRoundDisplayRadius()", "private Paint getRoundDisplayAccessibilityHighlightPaint()", "private void drawAccessibilityFocusedBorderOnRoundDisplay(Canvas canvas, Rect bounds, int roundDisplayRadius, Paint accessibilityFocusHighlightPaint)", "private boolean getAccessibilityFocusedRect(Rect bounds)", "private Drawable getAccessibilityFocusedDrawable()", " void updateSystemGestureExclusionRectsForView(View view)", " void systemGestureExclusionChanged()", "public void updateDecorViewGestureInterception(boolean intercepted)", " void decorViewInterceptionChanged(boolean intercepted)", "public void setRootSystemGestureExclusionRects(@NonNull List<Rect> rects)", "public List<Rect> getRootSystemGestureExclusionRects()", " void updateKeepClearRectsForView(View view)", "private void updateKeepClearForAccessibilityFocusRect()", " void keepClearRectsChanged(boolean accessibilityFocusRectChanged)", " void reportKeepClearAreasChanged()", "public void requestInvalidateRootRenderNode()", " boolean scrollToRectOrFocus(Rect rectangle, boolean immediate)", "public void setScrollY(int scrollY)", "public int getScrollY()", "public View getAccessibilityFocusedHost()", "public AccessibilityNodeInfo getAccessibilityFocusedVirtualView()", " void setAccessibilityFocus(View view, AccessibilityNodeInfo node)", " boolean hasPointerCapture()", " void requestPointerCapture(boolean enabled)", "private void handlePointerCaptureChanged(boolean hasCapture)", "private void updateColorModeIfNeeded(@ActivityInfo.ColorMode int colorMode, float desiredRatio)", "public void requestChildFocus(View child, View focused)", "public void clearChildFocus(View child)", "public ViewParent getParentForAccessibility()", "public void focusableViewAvailable(View v)", "public void recomputeViewAttributes(View child)", " void dispatchDetachedFromWindow()", "private void performConfigurationChange(@NonNull MergedConfiguration mergedConfiguration, boolean force, int newDisplayId, @Nullable ActivityWindowInfo activityWindowInfo)", "public void updateConfiguration(int newDisplayId)", "private void updateLastConfigurationFromResources(Configuration resConfig)", "public static boolean isViewDescendantOf(View child, View parent)", "private static void forceLayout(View view)", " boolean ensureTouchMode(boolean inTouchMode)", "private boolean ensureTouchModeLocally(boolean inTouchMode)", "private boolean enterTouchMode()", "private static ViewGroup findAncestorToTakeFocusInTouchMode(View focused)", "private boolean leaveTouchMode()", "public boolean isHandlingPointerEvent()", "private void resetPointerIcon(MotionEvent event)", "public void refreshPointerIcon()", "private boolean updatePointerIcon(MotionEvent event)", "private void maybeUpdateTooltip(MotionEvent event)", "private View getFocusedViewOrNull()", "private static boolean isNavigationKey(KeyEvent keyEvent)", "private static boolean isTypingKey(KeyEvent keyEvent)", "private boolean checkForLeavingTouchModeAndConsume(KeyEvent event)", " void setLocalDragState(Object obj)", "private void handleDragEvent(DragEvent event)", "public void onWindowTitleChanged()", "public void handleDispatchWindowShown()", "public void handleRequestKeyboardShortcuts(IResultReceiver receiver, int deviceId)", "public void getLastTouchPoint(Point outLocation)", "public int getLastTouchSource()", "public int getLastTouchDeviceId()", "public int getLastTouchPointerId()", "public int getLastClickToolType()", "public void setDragFocus(View newDragTarget, DragEvent event)", " void setDragStartedViewForAccessibility(View view)", "private AudioManager getAudioManager()", "private AutofillManager getAutofillManager()", "private boolean isAutofillUiShowing()", "public AccessibilityInteractionController getAccessibilityInteractionController()", "private int relayoutWindow(WindowManager.LayoutParams params, int viewVisibility, boolean insetsPending) throws RemoteException", "private void updateOpacity(WindowManager.LayoutParams params, boolean dragResizing, boolean forceUpdate)", "private void setFrame(Rect frame, boolean withinRelayout)", " void setOverrideInsetsFrame(Rect frame)", " void getDisplayFrame(Rect outFrame)", " void getWindowVisibleDisplayFrame(Rect outFrame)", " void applyViewBoundsSandboxingIfNeeded(final Rect inOutRect)", "public void applyViewLocationSandboxingIfNeeded(@Size(2) int[] outLocation)", "private boolean getViewBoundsSandboxingEnabled()", "public void playSoundEffect(@SoundEffectConstants.SoundEffect int effectId)", "public boolean performHapticFeedback(int effectId, boolean always, boolean fromIme)", "public View focusSearch(View focused, int direction)", "public View keyboardNavigationClusterSearch(View currentCluster, @FocusDirection int direction)", "public void debug()", "public void dumpDebug(ProtoOutputStream proto, long fieldId)", "public void dump(String prefix, PrintWriter writer)", "private void dumpViewHierarchy(String prefix, PrintWriter writer, View view)", " GfxInfo getGfxInfo()", "private static void computeRenderNodeUsage(RenderNode node, GfxInfo info)", "private static void appendGfxInfo(View view, GfxInfo info)", " boolean die(boolean immediate)", " void doDie()", "public void requestUpdateConfiguration(Configuration config)", "public void loadSystemProperties()", "private void destroyHardwareRenderer()", "private void dispatchResized(ClientWindowFrames frames, boolean reportDraw, MergedConfiguration mergedConfiguration, InsetsState insetsState, boolean forceLayout, boolean alwaysConsumeSystemBars, int displayId, int syncSeqId, boolean dragResizing, @Nullable ActivityWindowInfo activityWindowInfo)", "private void dispatchInsetsControlChanged(InsetsState insetsState, InsetsSourceControl[] activeControls)", "private void showInsets(@InsetsType int types, boolean fromIme, @Nullable ImeTracker.Token statsToken)", "private void hideInsets(@InsetsType int types, boolean fromIme, @Nullable ImeTracker.Token statsToken)", "public void dispatchMoved(int newX, int newY)", "private QueuedInputEvent obtainQueuedInputEvent(InputEvent event, InputEventReceiver receiver, int flags)", "private void recycleQueuedInputEvent(QueuedInputEvent q)", "public void enqueueInputEvent(InputEvent event)", " void enqueueInputEvent(InputEvent event, InputEventReceiver receiver, int flags, boolean processImmediately)", "private void scheduleProcessInputEvents()", " void doProcessInputEvents()", "private void deliverInputEvent(QueuedInputEvent q)", "private void finishInputEvent(QueuedInputEvent q)", "private void logHandledSystemKey(KeyEvent event, boolean handled)", " static boolean isTerminalInputEvent(InputEvent event)", " void scheduleConsumeBatchedInput()", " void unscheduleConsumeBatchedInput()", " void scheduleConsumeBatchedInputImmediately()", " boolean doConsumeBatchedInput(long frameTimeNanos)", "public void dispatchInvalidateDelayed(View view, long delayMilliseconds)", "public void dispatchInvalidateRectDelayed(AttachInfo.InvalidateInfo info, long delayMilliseconds)", "public void dispatchInvalidateOnAnimation(View view)", "public void dispatchInvalidateRectOnAnimation(AttachInfo.InvalidateInfo info)", "public void cancelInvalidate(View view)", "public void dispatchInputEvent(InputEvent event)", "public void dispatchInputEvent(InputEvent event, InputEventReceiver receiver)", "public void synthesizeInputEvent(InputEvent event)", "public void dispatchKeyFromIme(KeyEvent event)", "public void dispatchKeyFromAutofill(KeyEvent event)", "public void dispatchUnhandledInputEvent(InputEvent event)", "public void dispatchAppVisibility(boolean visible)", "public void dispatchGetNewSurface()", "public void windowFocusChanged(boolean hasFocus)", "public void touchModeChanged(boolean inTouchMode)", "public void dispatchWindowShown()", "public void dispatchCloseSystemDialogs(String reason)", "public void dispatchDragEvent(DragEvent event)", "public void dispatchCheckFocus()", "public void dispatchRequestKeyboardShortcuts(IResultReceiver receiver, int deviceId)", "private void dispatchPointerCaptureChanged(boolean on)", "private void postSendWindowContentChangedCallback(View source, int changeType)", "private void removeSendWindowContentChangedCallback()", "public int getDirectAccessibilityConnectionId()", "public boolean showContextMenuForChild(View originalView)", "public boolean showContextMenuForChild(View originalView, float x, float y)", "public ActionMode startActionModeForChild(View originalView, ActionMode.Callback callback)", "public ActionMode startActionModeForChild(View originalView, ActionMode.Callback callback, int type)", "public void createContextMenu(ContextMenu menu)", "public void childDrawableStateChanged(View child)", "public boolean requestSendAccessibilityEvent(View child, AccessibilityEvent event)", "private View getSourceForAccessibilityEvent(AccessibilityEvent event)", "private boolean isAccessibilityFocusDirty()", "private void handleWindowContentChangedEvent(AccessibilityEvent event)", "public void notifySubtreeAccessibilityStateChanged(View child, View source, int changeType)", "public boolean canResolveLayoutDirection()", "public boolean isLayoutDirectionResolved()", "public int getLayoutDirection()", "public boolean canResolveTextDirection()", "public boolean isTextDirectionResolved()", "public int getTextDirection()", "public boolean canResolveTextAlignment()", "public boolean isTextAlignmentResolved()", "public int getTextAlignment()", "private View getCommonPredecessor(View first, View second)", " void checkThread()", "public void requestDisallowInterceptTouchEvent(boolean disallowIntercept)", "public boolean requestChildRectangleOnScreen(View child, Rect rectangle, boolean immediate)", "public void childHasTransientStateChanged(View child, boolean hasTransientState)", "public boolean onStartNestedScroll(View child, View target, int nestedScrollAxes)", "public void onStopNestedScroll(View target)", "public void onNestedScrollAccepted(View child, View target, int nestedScrollAxes)", "public void onNestedScroll(View target, int dxConsumed, int dyConsumed, int dxUnconsumed, int dyUnconsumed)", "public void onNestedPreScroll(View target, int dx, int dy, int[] consumed)", "public boolean onNestedFling(View target, float velocityX, float velocityY, boolean consumed)", "public boolean onNestedPreFling(View target, float velocityX, float velocityY)", "public boolean onNestedPrePerformAccessibilityAction(View target, int action, Bundle args)", "public boolean probablyHasInput()", "public void addScrollCaptureCallback(ScrollCaptureCallback callback)", "public void removeScrollCaptureCallback(ScrollCaptureCallback callback)", "public void dispatchScrollCaptureRequest(@NonNull IScrollCaptureResponseListener listener)", " void processingBackKey(boolean processing)", "private void collectRootScrollCaptureTargets(ScrollCaptureSearchResults results)", "public void setScrollCaptureRequestTimeout(int timeMillis)", "public long getScrollCaptureRequestTimeout()", "public void handleScrollCaptureRequest(@NonNull IScrollCaptureResponseListener listener)", "private void dispatchScrollCaptureSearchResponse(@NonNull IScrollCaptureResponseListener listener, @NonNull ScrollCaptureSearchResults results)", "private void reportNextDraw(String reason)", "public void setReportNextDraw(boolean syncBuffer, String reason)", " void changeCanvasOpacity(boolean opaque)", "public boolean dispatchUnhandledKeyEvent(KeyEvent event)", " static HandlerActionQueue getRunQueue()", "private void startDragResizing(Rect initialBounds, boolean fullscreen, Rect systemInsets, Rect stableInsets)", "private void endDragResizing()", "private boolean updateContentDrawBounds()", "private void requestDrawWindow()", "public SurfaceControl getSurfaceControl()", "public IBinder getInputToken()", "public InputTransferToken getInputTransferToken()", "public IBinder getWindowToken()", "public IAccessibilityEmbeddedConnection getAccessibilityEmbeddedConnection()", "public void setDisplayDecoration(boolean displayDecoration)", "private void updateDisplayDecoration()", "public void dispatchBlurRegions(float[][] regionCopy, long frameNumber)", "public BackgroundBlurDrawable createBackgroundBlurDrawable()", "public void onDescendantUnbufferedRequested()", " int getSurfaceSequenceId()", "public void mergeWithNextTransaction(Transaction t, long frameNumber)", "public SurfaceControl.Transaction buildReparentTransaction(@NonNull SurfaceControl child)", "public boolean applyTransactionOnDraw(@NonNull SurfaceControl.Transaction t)", "public int getBufferTransformHint()", "public void addOnBufferTransformHintChangedListener(OnBufferTransformHintChangedListener listener)", "public void removeOnBufferTransformHintChangedListener(OnBufferTransformHintChangedListener listener)", "private void dispatchTransformHintChanged(@SurfaceControl.BufferTransform int hint)", "public void requestCompatCameraControl(boolean showControl, boolean transformationApplied, ICompatCameraControlCallback callback)", " boolean wasRelayoutRequested()", " void forceWmRelayout()", "public WindowOnBackInvokedDispatcher getOnBackInvokedDispatcher()", "public OnBackInvokedDispatcher findOnBackInvokedDispatcherForChild(@NonNull View child, @NonNull View requester)", "private void registerBackCallbackOnWindow()", "private void sendBackKeyEvent(int action)", "private void registerCompatOnBackInvokedCallback()", "public void setTouchableRegion(Region r)", " IWindowSession getWindowSession()", "private void registerCallbacksForSync(boolean syncBuffer, final SurfaceSyncGroup surfaceSyncGroup)", "private void safeguardOverlappingSyncs(SurfaceSyncGroup activeSurfaceSyncGroup)", "public SurfaceSyncGroup getOrCreateSurfaceSyncGroup()", "private void updateSyncInProgressCount(SurfaceSyncGroup syncGroup)", " void addToSync(SurfaceSyncGroup syncable)", "public void setChildBoundingInsets(@NonNull Rect insets)", "private void logAndTrace(String msg)", "private void setCategoryFromCategoryCounts()", "private void setPreferredFrameRateCategory(int preferredFrameRateCategory)", "private static String categoryToString(int frameRateCategory)", "private static String reasonToString(int reason)", "private void setPreferredFrameRate(float preferredFrameRate)", "private boolean shouldSetFrameRateCategory()", "private boolean shouldSetFrameRate()", "private boolean shouldTouchBoost(int motionEventAction, int windowType)", "public void votePreferredFrameRateCategory(int frameRateCategory, int reason, View view)", " int intermittentUpdateState()", "public boolean shouldCheckFrameRateCategory()", "public boolean shouldCheckFrameRate(boolean isDirect)", "public void votePreferredFrameRate(float frameRate, int frameRateCompatibility)", "public int getPreferredFrameRateCategory()", "public int getLastPreferredFrameRateCategory()", "public float getPreferredFrameRate()", "public float getLastPreferredFrameRate()", "public boolean getIsTouchBoosting()", "public int getFrameRateCompatibility()", "public boolean getIsFrameRateBoosting()", "public boolean getFrameRateBoostOnTouchEnabled()", "private void boostFrameRate(int boostTimeOut)", " void setBackKeyCallbackForWindowlessWindow(@NonNull Predicate<KeyEvent> callback)", " void recordViewPercentage(float percentage)", "public boolean isFrameRatePowerSavingsBalanced()", "public boolean isFrameRateConflicted()", "private boolean shouldEnableDvrr()", "private void removeVrrMessages()", "private void updateInfrequentCount()" ],
  "variableNames" : [ "TAG", "DBG", "LOCAL_LOGV", "DEBUG_DRAW", "DEBUG_LAYOUT", "DEBUG_DIALOG", "DEBUG_INPUT_RESIZE", "DEBUG_ORIENTATION", "DEBUG_TRACKBALL", "DEBUG_IMF", "DEBUG_CONFIGURATION", "DEBUG_FPS", "DEBUG_INPUT_STAGES", "DEBUG_KEEP_SCREEN_ON", "DEBUG_CONTENT_CAPTURE", "DEBUG_SCROLL_CAPTURE", "DEBUG_TOUCH_NAVIGATION", "DEBUG_BLAST", "DEBUG_SENSITIVE_CONTENT", "LOGTAG_INPUT_FOCUS", "LOGTAG_VIEWROOT_DRAW_EVENT", "MT_RENDERER_AVAILABLE", "ENABLE_INPUT_LATENCY_TRACKING", "USE_ASYNC_PERFORM_HAPTIC_FEEDBACK", "CLIENT_TRANSIENT", "CLIENT_IMMERSIVE_CONFIRMATION", "PROPERTY_PROFILE_RENDERING", "MAX_TRACKBALL_DELAY", "CONTENT_CAPTURE_ENABLED_NOT_CHECKED", "CONTENT_CAPTURE_ENABLED_TRUE", "CONTENT_CAPTURE_ENABLED_FALSE", "SCROLL_CAPTURE_REQUEST_TIMEOUT_MILLIS", "UNSET_SYNC_ID", "INFREQUENT_UPDATE_INTERVAL_MILLIS", "INFREQUENT_UPDATE_COUNTS", "INTERMITTENT_STATE_NOT_INTERMITTENT", "INTERMITTENT_STATE_IN_TRANSITION", "INTERMITTENT_STATE_INTERMITTENT", "KEEP_CLEAR_AREA_REPORT_RATE_MILLIS", "NANOS_PER_SEC", "sRunQueues", "sFirstDrawHandlers", "sFirstDrawComplete", "mTransformHintListeners", "mPreviousTransformHint", "mOnBackInvokedDispatcher", "mCompatOnBackInvokedCallback", "mForceInvertObserver", "INVALID_VALUE", "mForceInvertEnabled", "sConfigCallbacks", "mActivityConfigCallback", "mForceNextConfigUpdate", "mFastScrollSoundEffectsEnabled", "sCompatibilityDone", "sAlwaysAssignFocus", "mWindowCallbacks", "mContext", "mWindowSession", "mDisplay", "mBasePackageName", "mExtraDisplayListenerLogging", "mTmpLocation", "mTmpValue", "mThread", "mLocation", "mWindowAttributes", "mWindow", "mLeashToken", "mTargetSdkVersion", "mView", "mAccessibilityFocusedHost", "mAccessibilityFocusedVirtualView", "mPointerCapture", "mViewVisibility", "mAppVisible", "mForceDecorViewVisibility", "mAppVisibilityChanged", "mOrigWindowType", "mStopped", "mIsAmbientMode", "mPausedForTransition", "mSurfaceHolderCallback", "mSurfaceHolder", "mIsCreating", "mDrawingAllowed", "mTransparentRegion", "mPreviousTransparentRegion", "mTouchableRegion", "mPreviousTouchableRegion", "mMeasuredWidth", "mMeasuredHeight", "mViewMeasureDeferred", "mWidth", "mHeight", "mDirty", "mIsAnimating", "mUseMTRenderer", "mPendingDragResizing", "mDragResizing", "mInvalidateRootRequested", "mCanvasOffsetX", "mCanvasOffsetY", "mTranslator", "mAttachInfo", "mCompatibleVisibilityInfo", "mDispatchedSystemUiVisibility", "mDispatchedSystemBarAppearance", "mInputQueueCallback", "mInputQueue", "mFallbackEventHandler", "mChoreographer", "mViewFrameInfo", "mInputEventAssigner", "mDisplayDecorationCached", "mIsStylusPointerIconEnabled", "mInfrequentUpdateCount", "mLastUpdateTimeMillis", "mMinusOneFrameIntervalMillis", "mMinusTwoFrameIntervalMillis", "mSurfaceSize", "mLastSurfaceSize", "mVisRect", "mTempRect", "mWindowLayout", "mWindowFocusChanged", "mUpcomingWindowFocus", "mUpcomingInTouchMode", "mProcessingBackKey", "mWindowlessBackKeyCallback", "mTraversalScheduled", "mTraversalBarrier", "mWillDrawSoon", "mIsInTraversal", "mApplyInsetsRequested", "mLayoutRequested", "mFirst", "mContentCaptureEnabled", "mPerformContentCapture", "mReportNextDraw", "mLastReportNextDrawReason", "mLastPerformDrawSkippedReason", "mLastPerformTraversalsSkipDrawReason", "mWmsRequestSyncGroupState", "WMS_SYNC_NONE", "WMS_SYNC_PENDING", "WMS_SYNC_RETURNED", "WMS_SYNC_MERGED", "mSyncBuffer", "mCheckIfCanDraw", "mWasLastDrawCanceled", "mLastTraversalWasVisible", "mLastDrawScreenOff", "mDrewOnceForSync", "mSyncSeqId", "mLastSyncSeqId", "mUpdateSurfaceNeeded", "mFullRedrawNeeded", "mNewSurfaceNeeded", "mForceNextWindowRelayout", "mWindowDrawCountDown", "mHasPendingTransactions", "mPendingTransaction", "mIsDrawing", "mLastSystemUiVisibility", "mClientWindowLayoutFlags", "MAX_QUEUED_INPUT_EVENT_POOL_SIZE", "mQueuedInputEventPool", "mQueuedInputEventPoolSize", "mPendingInputEventHead", "mPendingInputEventTail", "mPendingInputEventCount", "mProcessInputEventsScheduled", "mUnbufferedInputDispatch", "mUnbufferedInputSource", "mPendingInputEventQueueLengthCounterName", "mFirstInputStage", "mFirstPostImeInputStage", "mSyntheticInputStage", "mUnhandledKeyManager", "mWindowAttributesChanged", "mSurface", "mSurfaceControl", "mBlastBufferQueue", "mHdrRenderState", "mBoundsLayer", "mSurfaceSession", "mTransaction", "mFrameRateTransaction", "mAdded", "mAddedTouchMode", "mTmpFrames", "mWinFrame", "mLastLayoutFrame", "mOverrideInsetsFrame", "mPendingBackDropFrame", "mPendingAlwaysConsumeSystemBars", "mRelayoutSeq", "mWinFrameInScreen", "mTempInsets", "mTempControls", "mTempWinConfig", "mInvCompatScale", "mLastGivenInsets", "mLastWindowInsets", "mTypesHiddenByFlags", "mLastConfigurationFromResources", "mLastReportedMergedConfiguration", "mPendingMergedConfiguration", "mPendingActivityWindowInfo", "mLastReportedActivityWindowInfo", "mScrollMayChange", "mSoftInputMode", "mLastScrolledFocus", "mScrollY", "mCurScrollY", "mScroller", "mResizeInterpolator", "mPendingTransitions", "mViewConfiguration", "mDragDescription", "mCurrentDragView", "mStartedDragViewForA11y", "mLocalDragState", "mDragPoint", "mLastTouchPoint", "mLastTouchSource", "mLastTouchDeviceId", "mLastTouchPointerId", "mLastClickToolType", "mProfileRendering", "mRenderProfiler", "mRenderProfilingEnabled", "mFpsStartTime", "mFpsPrevTime", "mFpsNumFrames", "mInsetsAnimationRunning", "mPreviousFrameDrawnTime", "mLargestChildPercentage", "mFrameRateCategoryChangeReason", "mFrameRateCategoryView", "mPointerIconType", "mCustomPointerIcon", "mResolvedPointerIcon", "mAudioManager", "mAccessibilityManager", "mAccessibilityInteractionController", "mRoundDisplayAccessibilityHighlightPaint", "mAccessibilityInteractionConnectionManager", "mHighContrastTextManager", "mSendWindowContentChangedAccessibilityEvent", "mTempHashSet", "mDensity", "mNoncompatDensity", "mInLayout", "mLayoutRequesters", "mHandlingLayoutInLayoutRequest", "mViewLayoutDirectionInitial", "mRemoved", "mNeedsRendererSetup", "mInputCompatProcessor", "mInputEventConsistencyVerifier", "mInsetsController", "mImeBackAnimationController", "mImeFocusController", "mIsSurfaceOpaque", "mBlurRegionAggregator", "mGestureExclusionTracker", "mKeepClearRectsTracker", "mUnrestrictedKeepClearRectsTracker", "mHasPendingKeepClearAreaChange", "mKeepClearAccessibilityFocusRect", "mAccessibilityEmbeddedConnection", "mSensitiveContentProtectionService", "mHandwritingInitiator", "mWmsRequestSyncGroup", "mActiveSurfaceSyncGroup", "mPreviousSyncSafeguardLock", "mPreviousSyncSafeguard", "sSyncProgressLock", "sNumSyncsInProgress", "mNumPausedForSync", "mRootScrollCaptureCallbacks", "mScrollCaptureRequestTimeout", "mSurfaceSequenceId", "mRelayoutRequested", "mViewBoundsSandboxingEnabled", "mAccessibilityWindowAttributes", "mPreferredFrameRateCategory", "mLastPreferredFrameRateCategory", "mPreferredFrameRate", "mLastPreferredFrameRate", "mIsFrameRateBoosting", "mIsTouchBoosting", "mDrawnThisFrame", "mIsFrameRateConflicted", "mFrameRateCompatibility", "FRAME_RATE_TOUCH_BOOST_TIME", "FRAME_RATE_SETTING_REEVALUATE_TIME", "FRAME_RATE_CATEGORY_COUNT", "mFrameRateCategoryHighCount", "mFrameRateCategoryHighHintCount", "mFrameRateCategoryNormalCount", "mFrameRateCategoryLowCount", "mRelayoutBundle", "mRelayoutResult", "sAnrReported", "sTransactionHangCallback", "mChildBoundingInsets", "mChildBoundingInsetsChanged", "mTag", "mFpsTraceName", "mLargestViewTraceName", "sToolkitSetFrameRateReadOnlyFlagValue", "sToolkitFrameRateFunctionEnablingReadOnlyFlagValue", "sToolkitMetricsForFrameRateDecisionFlagValue", "sToolkitFrameRateTypingReadOnlyFlagValue", "sToolkitFrameRateViewEnablingReadOnlyFlagValue", "sToolkitFrameRateVelocityMappingReadOnlyFlagValue", "sToolkitEnableInvalidateCheckThreadFlagValue", "mPointerIconEvent", "mProfile", "mDisplayListener", "mSurfaceChangedCallbacks", "mHardwareXOffset", "mHardwareYOffset", "MSG_INVALIDATE", "MSG_INVALIDATE_RECT", "MSG_DIE", "MSG_RESIZED", "MSG_RESIZED_REPORT", "MSG_WINDOW_FOCUS_CHANGED", "MSG_DISPATCH_INPUT_EVENT", "MSG_DISPATCH_APP_VISIBILITY", "MSG_DISPATCH_GET_NEW_SURFACE", "MSG_DISPATCH_KEY_FROM_IME", "MSG_DISPATCH_KEY_FROM_AUTOFILL", "MSG_CHECK_FOCUS", "MSG_CLOSE_SYSTEM_DIALOGS", "MSG_DISPATCH_DRAG_EVENT", "MSG_DISPATCH_DRAG_LOCATION_EVENT", "MSG_DISPATCH_SYSTEM_UI_VISIBILITY", "MSG_UPDATE_CONFIGURATION", "MSG_PROCESS_INPUT_EVENTS", "MSG_CLEAR_ACCESSIBILITY_FOCUS_HOST", "MSG_INVALIDATE_WORLD", "MSG_WINDOW_MOVED", "MSG_SYNTHESIZE_INPUT_EVENT", "MSG_DISPATCH_WINDOW_SHOWN", "MSG_REQUEST_KEYBOARD_SHORTCUTS", "MSG_UPDATE_POINTER_ICON", "MSG_POINTER_CAPTURE_CHANGED", "MSG_INSETS_CONTROL_CHANGED", "MSG_SYSTEM_GESTURE_EXCLUSION_CHANGED", "MSG_SHOW_INSETS", "MSG_HIDE_INSETS", "MSG_REQUEST_SCROLL_CAPTURE", "MSG_WINDOW_TOUCH_MODE_CHANGED", "MSG_KEEP_CLEAR_RECTS_CHANGED", "MSG_REPORT_KEEP_CLEAR_RECTS", "MSG_PAUSED_FOR_SYNC_TIMEOUT", "MSG_DECOR_VIEW_GESTURE_INTERCEPTION", "MSG_TOUCH_BOOST_TIMEOUT", "MSG_CHECK_INVALIDATION_IDLE", "MSG_REFRESH_POINTER_ICON", "MSG_FRAME_RATE_SETTING", "mHandler", "mExecutor", "mTraversalRunnable", "mInputEventReceiver", "mHardwareRendererObserver", "mConsumedBatchedInputRunnable", "mConsumeBatchedInputScheduled", "mConsumeBatchedInputImmediatelyRunnable", "mConsumeBatchedInputImmediatelyScheduled", "mInvalidateOnAnimationRunnable", "mSimpleExecutor" ]
}