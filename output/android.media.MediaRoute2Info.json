{
  "filePath" : "/home/maryam/clearblue/files/android-source-35/android/media/MediaRoute2Info.java",
  "packageName" : "android.media",
  "className" : "MediaRoute2Info",
  "comment" : "\n * Describes the properties of a route.\n ",
  "links" : [ ],
  "variables" : [ {
    "name" : "CREATOR",
    "type" : "Creator<MediaRoute2Info>",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "ROUTE_ID_DEVICE",
    "type" : "String",
    "comment" : "\n     * The {@link #getOriginalId() original id} of the route that represents the built-in media\n     * route.\n     *\n     * <p>A route with this id will only be visible to apps with permission to do system routing,\n     * which means having {@link android.Manifest.permission#BLUETOOTH_CONNECT} and {@link\n     * android.Manifest.permission#BLUETOOTH_SCAN}, or {@link\n     * android.Manifest.permission#MODIFY_AUDIO_ROUTING}.\n     *\n     * @hide\n     ",
    "links" : [ "android.Manifest.permission#MODIFY_AUDIO_ROUTING", "android.Manifest.permission#BLUETOOTH_CONNECT", "android.Manifest.permission#BLUETOOTH_SCAN", "#getOriginalId()" ]
  }, {
    "name" : "ROUTE_ID_DEFAULT",
    "type" : "String",
    "comment" : "\n     * The {@link #getOriginalId() original id} of the route that represents the default system\n     * media route.\n     *\n     * <p>A route with this id will be visible to apps with no permission over system routing. See\n     * {@link #ROUTE_ID_DEVICE} for details.\n     *\n     * @hide\n     ",
    "links" : [ "#getOriginalId()", "#ROUTE_ID_DEVICE" ]
  }, {
    "name" : "CONNECTION_STATE_DISCONNECTED",
    "type" : "int",
    "comment" : "\n     * The default connection state indicating the route is disconnected.\n     *\n     * @see #getConnectionState\n     ",
    "links" : [ ]
  }, {
    "name" : "CONNECTION_STATE_CONNECTING",
    "type" : "int",
    "comment" : "\n     * A connection state indicating the route is in the process of connecting and is not yet\n     * ready for use.\n     *\n     * @see #getConnectionState\n     ",
    "links" : [ ]
  }, {
    "name" : "CONNECTION_STATE_CONNECTED",
    "type" : "int",
    "comment" : "\n     * A connection state indicating the route is connected.\n     *\n     * @see #getConnectionState\n     ",
    "links" : [ ]
  }, {
    "name" : "PLAYBACK_VOLUME_FIXED",
    "type" : "int",
    "comment" : "\n     * Playback information indicating the playback volume is fixed, i&#46;e&#46; it cannot be\n     * controlled from this object. An example of fixed playback volume is a remote player,\n     * playing over HDMI where the user prefers to control the volume on the HDMI sink, rather\n     * than attenuate at the source.\n     *\n     * @see #getVolumeHandling()\n     ",
    "links" : [ ]
  }, {
    "name" : "PLAYBACK_VOLUME_VARIABLE",
    "type" : "int",
    "comment" : "\n     * Playback information indicating the playback volume is variable and can be controlled\n     * from this object.\n     *\n     * @see #getVolumeHandling()\n     ",
    "links" : [ ]
  }, {
    "name" : "TYPE_UNKNOWN",
    "type" : "int",
    "comment" : "\n     * Indicates the route's type is unknown or undefined.\n     *\n     * @see #getType\n     ",
    "links" : [ ]
  }, {
    "name" : "TYPE_BUILTIN_SPEAKER",
    "type" : "int",
    "comment" : "\n     * Indicates the route is the speaker system (i.e. a mono speaker or stereo speakers) built into\n     * the device.\n     *\n     * @see #getType\n     ",
    "links" : [ ]
  }, {
    "name" : "TYPE_WIRED_HEADSET",
    "type" : "int",
    "comment" : "\n     * Indicates the route is a headset, which is the combination of a headphones and a microphone.\n     *\n     * @see #getType\n     ",
    "links" : [ ]
  }, {
    "name" : "TYPE_WIRED_HEADPHONES",
    "type" : "int",
    "comment" : "\n     * Indicates the route is a pair of wired headphones.\n     *\n     * @see #getType\n     ",
    "links" : [ ]
  }, {
    "name" : "TYPE_BLUETOOTH_A2DP",
    "type" : "int",
    "comment" : "\n     * Indicates the route is a bluetooth device, such as a bluetooth speaker or headphones.\n     *\n     * @see #getType\n     ",
    "links" : [ ]
  }, {
    "name" : "TYPE_HDMI",
    "type" : "int",
    "comment" : "\n     * Indicates the route is an HDMI connection.\n     *\n     * @see #getType\n     ",
    "links" : [ ]
  }, {
    "name" : "TYPE_HDMI_ARC",
    "type" : "int",
    "comment" : "\n     * Indicates the route is an Audio Return Channel of an HDMI connection.\n     *\n     * @see #getType\n     ",
    "links" : [ ]
  }, {
    "name" : "TYPE_HDMI_EARC",
    "type" : "int",
    "comment" : "\n     * Indicates the route is an Enhanced Audio Return Channel of an HDMI connection.\n     *\n     * @see #getType\n     ",
    "links" : [ ]
  }, {
    "name" : "TYPE_USB_DEVICE",
    "type" : "int",
    "comment" : "\n     * Indicates the route is a USB audio device.\n     *\n     * @see #getType\n     ",
    "links" : [ ]
  }, {
    "name" : "TYPE_USB_ACCESSORY",
    "type" : "int",
    "comment" : "\n     * Indicates the route is a USB audio device in accessory mode.\n     *\n     * @see #getType\n     ",
    "links" : [ ]
  }, {
    "name" : "TYPE_DOCK",
    "type" : "int",
    "comment" : "\n     * Indicates the route is the audio device associated with a dock.\n     *\n     * @see #getType\n     ",
    "links" : [ ]
  }, {
    "name" : "TYPE_USB_HEADSET",
    "type" : "int",
    "comment" : "\n     * Indicates the route is a USB audio headset.\n     *\n     * @see #getType\n     ",
    "links" : [ ]
  }, {
    "name" : "TYPE_HEARING_AID",
    "type" : "int",
    "comment" : "\n     * Indicates the route is a hearing aid.\n     *\n     * @see #getType\n     ",
    "links" : [ ]
  }, {
    "name" : "TYPE_BLE_HEADSET",
    "type" : "int",
    "comment" : "\n     * Indicates the route is a Bluetooth Low Energy (BLE) HEADSET.\n     *\n     * @see #getType\n     ",
    "links" : [ ]
  }, {
    "name" : "TYPE_REMOTE_TV",
    "type" : "int",
    "comment" : "\n     * Indicates the route is a remote TV.\n     *\n     * <p>A remote device uses a routing protocol managed by the application, as opposed to the\n     * routing being done by the system.\n     *\n     * @see #getType\n     ",
    "links" : [ ]
  }, {
    "name" : "TYPE_REMOTE_SPEAKER",
    "type" : "int",
    "comment" : "\n     * Indicates the route is a remote speaker.\n     *\n     * <p>A remote device uses a routing protocol managed by the application, as opposed to the\n     * routing being done by the system.\n     *\n     * @see #getType\n     ",
    "links" : [ ]
  }, {
    "name" : "TYPE_REMOTE_AUDIO_VIDEO_RECEIVER",
    "type" : "int",
    "comment" : "\n     * Indicates the route is a remote Audio/Video Receiver (AVR).\n     *\n     * <p>A remote device uses a routing protocol managed by the application, as opposed to the\n     * routing being done by the system.\n     *\n     * @see #getType\n     ",
    "links" : [ ]
  }, {
    "name" : "TYPE_REMOTE_TABLET",
    "type" : "int",
    "comment" : "\n     * Indicates the route is a remote tablet.\n     *\n     * <p>A remote device uses a routing protocol managed by the application, as opposed to the\n     * routing being done by the system.\n     *\n     * @see #getType\n     ",
    "links" : [ ]
  }, {
    "name" : "TYPE_REMOTE_TABLET_DOCKED",
    "type" : "int",
    "comment" : "\n     * Indicates the route is a remote docked tablet.\n     *\n     * <p>A remote device uses a routing protocol managed by the application, as opposed to the\n     * routing being done by the system.\n     *\n     * @see #getType\n     ",
    "links" : [ ]
  }, {
    "name" : "TYPE_REMOTE_COMPUTER",
    "type" : "int",
    "comment" : "\n     * Indicates the route is a remote computer.\n     *\n     * <p>A remote device uses a routing protocol managed by the application, as opposed to the\n     * routing being done by the system.\n     *\n     * @see #getType\n     ",
    "links" : [ ]
  }, {
    "name" : "TYPE_REMOTE_GAME_CONSOLE",
    "type" : "int",
    "comment" : "\n     * Indicates the route is a remote gaming console.\n     *\n     * <p>A remote device uses a routing protocol managed by the application, as opposed to the\n     * routing being done by the system.\n     *\n     * @see #getType\n     ",
    "links" : [ ]
  }, {
    "name" : "TYPE_REMOTE_CAR",
    "type" : "int",
    "comment" : "\n     * Indicates the route is a remote car.\n     *\n     * <p>A remote device uses a routing protocol managed by the application, as opposed to the\n     * routing being done by the system.\n     *\n     * @see #getType\n     ",
    "links" : [ ]
  }, {
    "name" : "TYPE_REMOTE_SMARTWATCH",
    "type" : "int",
    "comment" : "\n     * Indicates the route is a remote smartwatch.\n     *\n     * <p>A remote device uses a routing protocol managed by the application, as opposed to the\n     * routing being done by the system.\n     *\n     * @see #getType\n     ",
    "links" : [ ]
  }, {
    "name" : "TYPE_REMOTE_SMARTPHONE",
    "type" : "int",
    "comment" : "\n     * Indicates the route is a remote smartphone.\n     *\n     * <p>A remote device uses a routing protocol managed by the application, as opposed to the\n     * routing being done by the system.\n     *\n     * @see #getType\n     ",
    "links" : [ ]
  }, {
    "name" : "TYPE_GROUP",
    "type" : "int",
    "comment" : "\n     * Indicates the route is a group of devices.\n     *\n     * @see #getType\n     ",
    "links" : [ ]
  }, {
    "name" : "FEATURE_LIVE_AUDIO",
    "type" : "String",
    "comment" : "\n     * Route feature: Live audio.\n     * <p>\n     * A route that supports live audio routing will allow the media audio stream\n     * to be sent to supported destinations.  This can include internal speakers or\n     * audio jacks on the device itself, A2DP devices, and more.\n     * </p><p>\n     * When a live audio route is selected, audio routing is transparent to the application.\n     * All audio played on the media stream will be routed to the selected destination.\n     * </p><p>\n     * Refer to the class documentation for details about live audio routes.\n     * </p>\n     ",
    "links" : [ ]
  }, {
    "name" : "FEATURE_LIVE_VIDEO",
    "type" : "String",
    "comment" : "\n     * Route feature: Live video.\n     * <p>\n     * A route that supports live video routing will allow a mirrored version\n     * of the device's primary display or a customized\n     * {@link android.app.Presentation Presentation} to be sent to supported\n     * destinations.\n     * </p><p>\n     * When a live video route is selected, audio and video routing is transparent\n     * to the application.  By default, audio and video is routed to the selected\n     * destination.  For certain live video routes, the application may also use a\n     * {@link android.app.Presentation Presentation} to replace the mirrored view\n     * on the external display with different content.\n     * </p><p>\n     * Refer to the class documentation for details about live video routes.\n     * </p>\n     *\n     * @see android.app.Presentation\n     ",
    "links" : [ "android.app.Presentation" ]
  }, {
    "name" : "FEATURE_LOCAL_PLAYBACK",
    "type" : "String",
    "comment" : "\n     * Route feature: Local playback.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "FEATURE_REMOTE_PLAYBACK",
    "type" : "String",
    "comment" : "\n     * Route feature: Remote playback.\n     * <p>\n     * A route that supports remote playback routing will allow an application to send\n     * requests to play content remotely to supported destinations.\n     * A route may only support {@link #FEATURE_REMOTE_AUDIO_PLAYBACK audio playback} or\n     * {@link #FEATURE_REMOTE_VIDEO_PLAYBACK video playback}.\n     * </p><p>\n     * Remote playback routes destinations operate independently of the local device.\n     * When a remote playback route is selected, the application can control the content\n     * playing on the destination using {@link MediaRouter2.RoutingController#getControlHints()}.\n     * The application may also receive status updates from the route regarding remote playback.\n     * </p><p>\n     * Refer to the class documentation for details about remote playback routes.\n     * </p>\n     * @see #FEATURE_REMOTE_AUDIO_PLAYBACK\n     * @see #FEATURE_REMOTE_VIDEO_PLAYBACK\n     ",
    "links" : [ "#FEATURE_REMOTE_VIDEO_PLAYBACK", "#FEATURE_REMOTE_AUDIO_PLAYBACK", "MediaRouter2.RoutingController#getControlHints()" ]
  }, {
    "name" : "FEATURE_REMOTE_AUDIO_PLAYBACK",
    "type" : "String",
    "comment" : "\n     * Route feature: Remote audio playback.\n     * <p>\n     * A route that supports remote audio playback routing will allow an application to send\n     * requests to play audio content remotely to supported destinations.\n     *\n     * @see #FEATURE_REMOTE_PLAYBACK\n     * @see #FEATURE_REMOTE_VIDEO_PLAYBACK\n     ",
    "links" : [ ]
  }, {
    "name" : "FEATURE_REMOTE_VIDEO_PLAYBACK",
    "type" : "String",
    "comment" : "\n     * Route feature: Remote video playback.\n     * <p>\n     * A route that supports remote video playback routing will allow an application to send\n     * requests to play video content remotely to supported destinations.\n     *\n     * @see #FEATURE_REMOTE_PLAYBACK\n     * @see #FEATURE_REMOTE_AUDIO_PLAYBACK\n     ",
    "links" : [ ]
  }, {
    "name" : "FEATURE_REMOTE_GROUP_PLAYBACK",
    "type" : "String",
    "comment" : "\n     * Route feature: Remote group playback.\n     * <p>\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "SUITABILITY_STATUS_SUITABLE_FOR_DEFAULT_TRANSFER",
    "type" : "int",
    "comment" : " Indicates the route is always suitable for media playback. ",
    "links" : [ ]
  }, {
    "name" : "SUITABILITY_STATUS_SUITABLE_FOR_MANUAL_TRANSFER",
    "type" : "int",
    "comment" : "\n     * Indicates that the route is suitable for media playback only after explicit user selection.\n     ",
    "links" : [ ]
  }, {
    "name" : "SUITABILITY_STATUS_NOT_SUITABLE_FOR_TRANSFER",
    "type" : "int",
    "comment" : " Indicates that the route is never suitable for media playback. ",
    "links" : [ ]
  }, {
    "name" : "mId",
    "type" : "String",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mName",
    "type" : "CharSequence",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mFeatures",
    "type" : "List<String>",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mType",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mIsSystem",
    "type" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mIconUri",
    "type" : "Uri",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mDescription",
    "type" : "CharSequence",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mConnectionState",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mClientPackageName",
    "type" : "String",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mPackageName",
    "type" : "String",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mVolumeHandling",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mVolumeMax",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mVolume",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mAddress",
    "type" : "String",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mDeduplicationIds",
    "type" : "Set<String>",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mExtras",
    "type" : "Bundle",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mProviderId",
    "type" : "String",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mIsVisibilityRestricted",
    "type" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mAllowedPackages",
    "type" : "Set<String>",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mSuitabilityStatus",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  } ],
  "methods" : [ {
    "name" : "public String getId()",
    "returnType" : "String",
    "comment" : "\n     * Gets the id of the route. The routes which are given by {@link MediaRouter2} will have\n     * unique IDs.\n     * <p>\n     * In order to ensure uniqueness in {@link MediaRouter2} side, the value of this method\n     * can be different from what was set in {@link MediaRoute2ProviderService}.\n     *\n     * @see Builder#Builder(String, CharSequence)\n     ",
    "links" : [ "android.media.MediaRoute2ProviderService", "android.media.MediaRouter2" ]
  }, {
    "name" : "public CharSequence getName()",
    "returnType" : "CharSequence",
    "comment" : "\n     * Gets the user-visible name of the route.\n     ",
    "links" : [ ]
  }, {
    "name" : "public List<String> getFeatures()",
    "returnType" : "List<String>",
    "comment" : "\n     * Gets the supported features of the route.\n     ",
    "links" : [ ]
  }, {
    "name" : "public int getType()",
    "returnType" : "int",
    "comment" : "\n     * Returns the type of this route.\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean isSystemRoute()",
    "returnType" : "boolean",
    "comment" : "\n     * Returns whether the route is a system route or not.\n     * <p>\n     * System routes are media routes directly controlled by the system\n     * such as phone speaker, wired headset, and Bluetooth devices.\n     * </p>\n     ",
    "links" : [ ]
  }, {
    "name" : "public Uri getIconUri()",
    "returnType" : "Uri",
    "comment" : "\n     * Gets the URI of the icon representing this route.\n     * <p>\n     * This icon will be used in picker UIs if available.\n     *\n     * @return The URI of the icon representing this route, or null if none.\n     ",
    "links" : [ ]
  }, {
    "name" : "public CharSequence getDescription()",
    "returnType" : "CharSequence",
    "comment" : "\n     * Gets the user-visible description of the route.\n     ",
    "links" : [ ]
  }, {
    "name" : "public int getConnectionState()",
    "returnType" : "int",
    "comment" : "\n     * Gets the connection state of the route.\n     *\n     * @return The connection state of this route: {@link #CONNECTION_STATE_DISCONNECTED},\n     * {@link #CONNECTION_STATE_CONNECTING}, or {@link #CONNECTION_STATE_CONNECTED}.\n     ",
    "links" : [ "#CONNECTION_STATE_CONNECTED", "#CONNECTION_STATE_DISCONNECTED", "#CONNECTION_STATE_CONNECTING" ]
  }, {
    "name" : "public String getClientPackageName()",
    "returnType" : "String",
    "comment" : "\n     * Gets the package name of the app using the route.\n     * Returns null if no apps are using this route.\n     ",
    "links" : [ ]
  }, {
    "name" : "public String getPackageName()",
    "returnType" : "String",
    "comment" : "\n     * Gets the package name of the provider that published the route.\n     * <p>\n     * It is set by the system service.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public int getVolumeHandling()",
    "returnType" : "int",
    "comment" : "\n     * Gets information about how volume is handled on the route.\n     *\n     * @return {@link #PLAYBACK_VOLUME_FIXED} or {@link #PLAYBACK_VOLUME_VARIABLE}\n     ",
    "links" : [ "#PLAYBACK_VOLUME_VARIABLE", "#PLAYBACK_VOLUME_FIXED" ]
  }, {
    "name" : "public int getVolumeMax()",
    "returnType" : "int",
    "comment" : "\n     * Gets the maximum volume of the route.\n     ",
    "links" : [ ]
  }, {
    "name" : "public int getVolume()",
    "returnType" : "int",
    "comment" : "\n     * Gets the current volume of the route. This may be invalid if the route is not selected.\n     ",
    "links" : [ ]
  }, {
    "name" : "public String getAddress()",
    "returnType" : "String",
    "comment" : "\n     * Gets the hardware address of the route if available.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public Set<String> getDeduplicationIds()",
    "returnType" : "Set<String>",
    "comment" : "\n     * Gets the deduplication IDs associated to the route.\n     *\n     * <p>Two routes with a matching deduplication ID originate from the same receiver device.\n     ",
    "links" : [ ]
  }, {
    "name" : "public Bundle getExtras()",
    "returnType" : "Bundle",
    "comment" : "\n     * Gets an optional bundle with extra data.\n     ",
    "links" : [ ]
  }, {
    "name" : "public String getOriginalId()",
    "returnType" : "String",
    "comment" : "\n     * Gets the original id set by {@link Builder#Builder(String, CharSequence)}.\n     * @hide\n     ",
    "links" : [ "#Builder(String" ]
  }, {
    "name" : "public String getProviderId()",
    "returnType" : "String",
    "comment" : "\n     * Gets the provider id of the route. It is assigned automatically by\n     * {@link com.android.server.media.MediaRouterService}.\n     *\n     * @return provider id of the route or null if it's not set.\n     * @hide\n     ",
    "links" : [ "com.android.server.media.MediaRouterService" ]
  }, {
    "name" : "public boolean hasAnyFeatures(@NonNull Collection<String> features)",
    "returnType" : "boolean",
    "comment" : "\n     * Returns if the route has at least one of the specified route features.\n     *\n     * @param features the list of route features to consider\n     * @return {@code true} if the route has at least one feature in the list\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean hasAllFeatures(@NonNull Collection<String> features)",
    "returnType" : "boolean",
    "comment" : "\n     * Returns if the route has all the specified route features.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean isValid()",
    "returnType" : "boolean",
    "comment" : "\n     * Returns true if the route info has all of the required field.\n     * A route is valid if and only if it is obtained from\n     * {@link com.android.server.media.MediaRouterService}.\n     * @hide\n     ",
    "links" : [ "com.android.server.media.MediaRouterService" ]
  }, {
    "name" : "public boolean isVisibleTo(String packageName)",
    "returnType" : "boolean",
    "comment" : "\n     * Returns whether this route is visible to the package with the given name.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public int getSuitabilityStatus()",
    "returnType" : "int",
    "comment" : " Returns the route suitability status. ",
    "links" : [ ]
  }, {
    "name" : "public void dump(@NonNull PrintWriter pw, @NonNull String prefix)",
    "returnType" : "void",
    "comment" : "\n     * Dumps the current state of the object to the given {@code pw} as a human-readable string.\n     *\n     * <p> Used in the context of dumpsys. </p>\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "private void dumpVolume(@NonNull PrintWriter pw, @NonNull String prefix)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public boolean equals(Object obj)",
    "returnType" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public int hashCode()",
    "returnType" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public String toString()",
    "returnType" : "String",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public int describeContents()",
    "returnType" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public void writeToParcel(@NonNull Parcel dest, int flags)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private static String getDeviceTypeString(@Type int deviceType)",
    "returnType" : "String",
    "comment" : "",
    "links" : [ ]
  } ],
  "methodNames" : [ "public String getId()", "public CharSequence getName()", "public List<String> getFeatures()", "public int getType()", "public boolean isSystemRoute()", "public Uri getIconUri()", "public CharSequence getDescription()", "public int getConnectionState()", "public String getClientPackageName()", "public String getPackageName()", "public int getVolumeHandling()", "public int getVolumeMax()", "public int getVolume()", "public String getAddress()", "public Set<String> getDeduplicationIds()", "public Bundle getExtras()", "public String getOriginalId()", "public String getProviderId()", "public boolean hasAnyFeatures(@NonNull Collection<String> features)", "public boolean hasAllFeatures(@NonNull Collection<String> features)", "public boolean isValid()", "public boolean isVisibleTo(String packageName)", "public int getSuitabilityStatus()", "public void dump(@NonNull PrintWriter pw, @NonNull String prefix)", "private void dumpVolume(@NonNull PrintWriter pw, @NonNull String prefix)", "public boolean equals(Object obj)", "public int hashCode()", "public String toString()", "public int describeContents()", "public void writeToParcel(@NonNull Parcel dest, int flags)", "private static String getDeviceTypeString(@Type int deviceType)" ],
  "variableNames" : [ "CREATOR", "ROUTE_ID_DEVICE", "ROUTE_ID_DEFAULT", "CONNECTION_STATE_DISCONNECTED", "CONNECTION_STATE_CONNECTING", "CONNECTION_STATE_CONNECTED", "PLAYBACK_VOLUME_FIXED", "PLAYBACK_VOLUME_VARIABLE", "TYPE_UNKNOWN", "TYPE_BUILTIN_SPEAKER", "TYPE_WIRED_HEADSET", "TYPE_WIRED_HEADPHONES", "TYPE_BLUETOOTH_A2DP", "TYPE_HDMI", "TYPE_HDMI_ARC", "TYPE_HDMI_EARC", "TYPE_USB_DEVICE", "TYPE_USB_ACCESSORY", "TYPE_DOCK", "TYPE_USB_HEADSET", "TYPE_HEARING_AID", "TYPE_BLE_HEADSET", "TYPE_REMOTE_TV", "TYPE_REMOTE_SPEAKER", "TYPE_REMOTE_AUDIO_VIDEO_RECEIVER", "TYPE_REMOTE_TABLET", "TYPE_REMOTE_TABLET_DOCKED", "TYPE_REMOTE_COMPUTER", "TYPE_REMOTE_GAME_CONSOLE", "TYPE_REMOTE_CAR", "TYPE_REMOTE_SMARTWATCH", "TYPE_REMOTE_SMARTPHONE", "TYPE_GROUP", "FEATURE_LIVE_AUDIO", "FEATURE_LIVE_VIDEO", "FEATURE_LOCAL_PLAYBACK", "FEATURE_REMOTE_PLAYBACK", "FEATURE_REMOTE_AUDIO_PLAYBACK", "FEATURE_REMOTE_VIDEO_PLAYBACK", "FEATURE_REMOTE_GROUP_PLAYBACK", "SUITABILITY_STATUS_SUITABLE_FOR_DEFAULT_TRANSFER", "SUITABILITY_STATUS_SUITABLE_FOR_MANUAL_TRANSFER", "SUITABILITY_STATUS_NOT_SUITABLE_FOR_TRANSFER", "mId", "mName", "mFeatures", "mType", "mIsSystem", "mIconUri", "mDescription", "mConnectionState", "mClientPackageName", "mPackageName", "mVolumeHandling", "mVolumeMax", "mVolume", "mAddress", "mDeduplicationIds", "mExtras", "mProviderId", "mIsVisibilityRestricted", "mAllowedPackages", "mSuitabilityStatus" ]
}