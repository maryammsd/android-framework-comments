{
  "filePath" : "/home/maryam/clearblue/files/android-source-35/android/content/ContentResolver.java",
  "packageName" : "android.content",
  "className" : "ContentResolver",
  "comment" : "\n * This class provides applications access to the content model.\n *\n * <div class=\"special reference\">\n * <h3>Developer Guides</h3>\n * <p>For more information about using a ContentResolver with content providers, read the\n * <a href=\"{@docRoot}guide/topics/providers/content-providers.html\">Content Providers</a>\n * developer guide.</p>\n * </div>\n ",
  "links" : [ ],
  "variables" : [ {
    "name" : "DEPRECATE_DATA_COLUMNS",
    "type" : "boolean",
    "comment" : "\n     * Enables logic that supports deprecation of {@code _data} columns,\n     * typically by replacing values with fake paths that the OS then offers to\n     * redirect to {@link #openFileDescriptor(Uri, String)}, which developers\n     * should be using directly.\n     *\n     * @hide\n     ",
    "links" : [ "#openFileDescriptor(Uri" ]
  }, {
    "name" : "DEPRECATE_DATA_PREFIX",
    "type" : "String",
    "comment" : "\n     * Special filesystem path prefix which indicates that a path should be\n     * treated as a {@code content://} {@link Uri} when\n     * {@link #DEPRECATE_DATA_COLUMNS} is enabled.\n     * <p>\n     * The remainder of the path after this prefix is a\n     * {@link Uri#getSchemeSpecificPart()} value, which includes authority, path\n     * segments, and query parameters.\n     *\n     * @hide\n     ",
    "links" : [ "android.net.Uri#getSchemeSpecificPart()", "android.net.Uri", "#DEPRECATE_DATA_COLUMNS" ]
  }, {
    "name" : "SYNC_EXTRAS_ACCOUNT",
    "type" : "String",
    "comment" : "\n     * @deprecated instead use\n     * {@link #requestSync(android.accounts.Account, String, android.os.Bundle)}\n     ",
    "links" : [ "#requestSync(android.accounts.Account" ]
  }, {
    "name" : "SYNC_EXTRAS_EXPEDITED",
    "type" : "String",
    "comment" : "\n     * If this extra is set to true, the sync request will be scheduled at the front of the\n     * sync request queue, but it is still subject to JobScheduler quota and throttling due to\n     * App Standby buckets.\n     *\n     * <p>This is different from {@link #SYNC_EXTRAS_SCHEDULE_AS_EXPEDITED_JOB}.\n     ",
    "links" : [ "#SYNC_EXTRAS_SCHEDULE_AS_EXPEDITED_JOB" ]
  }, {
    "name" : "SYNC_EXTRAS_REQUIRE_CHARGING",
    "type" : "String",
    "comment" : "\n     * If this extra is set to true, the sync request will be scheduled\n     * only when the device is plugged in. This is equivalent to calling\n     * setRequiresCharging(true) on {@link SyncRequest}.\n     ",
    "links" : [ "android.content.SyncRequest" ]
  }, {
    "name" : "SYNC_EXTRAS_SCHEDULE_AS_EXPEDITED_JOB",
    "type" : "String",
    "comment" : "\n     * Run this sync operation as an \"expedited job\"\n     * (see {@link android.app.job.JobInfo.Builder#setExpedited(boolean)}).\n     * Normally (if this flag isn't specified), sync operations are executed as regular\n     * {@link android.app.job.JobService} jobs.\n     *\n     * <p> Because Expedited Jobs have various restrictions compared to regular jobs, this flag\n     * cannot be combined with certain other flags, otherwise an\n     * <code>IllegalArgumentException</code> will be thrown. Notably, because Expedited Jobs do not\n     * support various constraints, the following restriction apply:\n     * <ul>\n     *  <li>Can't be used with {@link #SYNC_EXTRAS_REQUIRE_CHARGING}\n     *  <li>Can't be used with {@link #SYNC_EXTRAS_EXPEDITED}\n     *  <li>Can't be used on periodic syncs.\n     *  <li>When an expedited-job-sync fails and a retry is scheduled, the retried sync will be\n     *  scheduled as a regular job unless {@link #SYNC_EXTRAS_IGNORE_BACKOFF} is set.\n     * </ul>\n     *\n     * <p>This is different from {@link #SYNC_EXTRAS_EXPEDITED}.\n     ",
    "links" : [ "android.app.job.JobService", "android.app.job.JobInfo.Builder#setExpedited(boolean)", "#SYNC_EXTRAS_EXPEDITED", "#SYNC_EXTRAS_IGNORE_BACKOFF", "#SYNC_EXTRAS_REQUIRE_CHARGING" ]
  }, {
    "name" : "SYNC_EXTRAS_FORCE",
    "type" : "String",
    "comment" : "\n     * @deprecated instead use\n     * {@link #SYNC_EXTRAS_MANUAL}\n     ",
    "links" : [ "#SYNC_EXTRAS_MANUAL" ]
  }, {
    "name" : "SYNC_EXTRAS_IGNORE_SETTINGS",
    "type" : "String",
    "comment" : "\n     * If this extra is set to true then the sync settings (like getSyncAutomatically())\n     * are ignored by the sync scheduler.\n     ",
    "links" : [ ]
  }, {
    "name" : "SYNC_EXTRAS_IGNORE_BACKOFF",
    "type" : "String",
    "comment" : "\n     * If this extra is set to true then any backoffs for the initial attempt (e.g. due to retries)\n     * are ignored by the sync scheduler. If this request fails and gets rescheduled then the\n     * retries will still honor the backoff.\n     ",
    "links" : [ ]
  }, {
    "name" : "SYNC_EXTRAS_DO_NOT_RETRY",
    "type" : "String",
    "comment" : "\n     * If this extra is set to true then the request will not be retried if it fails.\n     ",
    "links" : [ ]
  }, {
    "name" : "SYNC_EXTRAS_MANUAL",
    "type" : "String",
    "comment" : "\n     * Setting this extra is the equivalent of setting both {@link #SYNC_EXTRAS_IGNORE_SETTINGS}\n     * and {@link #SYNC_EXTRAS_IGNORE_BACKOFF}\n     ",
    "links" : [ "#SYNC_EXTRAS_IGNORE_BACKOFF", "#SYNC_EXTRAS_IGNORE_SETTINGS" ]
  }, {
    "name" : "SYNC_EXTRAS_UPLOAD",
    "type" : "String",
    "comment" : "\n     * Indicates that this sync is intended to only upload local changes to the server.\n     * For example, this will be set to true if the sync is initiated by a call to\n     * {@link ContentResolver#notifyChange(android.net.Uri, android.database.ContentObserver, boolean)}\n     ",
    "links" : [ "android.content.ContentResolver#notifyChange(android.net.Uri" ]
  }, {
    "name" : "SYNC_EXTRAS_OVERRIDE_TOO_MANY_DELETIONS",
    "type" : "String",
    "comment" : "\n     * Indicates that the sync adapter should proceed with the delete operations,\n     * even if it determines that there are too many.\n     * See {@link SyncResult#tooManyDeletions}\n     ",
    "links" : [ "android.content.SyncResult#tooManyDeletions" ]
  }, {
    "name" : "SYNC_EXTRAS_DISCARD_LOCAL_DELETIONS",
    "type" : "String",
    "comment" : "\n     * Indicates that the sync adapter should not proceed with the delete operations,\n     * if it determines that there are too many.\n     * See {@link SyncResult#tooManyDeletions}\n     ",
    "links" : [ "android.content.SyncResult#tooManyDeletions" ]
  }, {
    "name" : "SYNC_EXTRAS_EXPECTED_UPLOAD",
    "type" : "String",
    "comment" : " {@hide} User-specified flag for expected upload size. ",
    "links" : [ ]
  }, {
    "name" : "SYNC_EXTRAS_EXPECTED_DOWNLOAD",
    "type" : "String",
    "comment" : " {@hide} User-specified flag for expected download size. ",
    "links" : [ ]
  }, {
    "name" : "SYNC_EXTRAS_PRIORITY",
    "type" : "String",
    "comment" : " {@hide} Priority of this sync with respect to other syncs scheduled for this application. ",
    "links" : [ ]
  }, {
    "name" : "SYNC_EXTRAS_DISALLOW_METERED",
    "type" : "String",
    "comment" : " {@hide} Flag to allow sync to occur on metered network. ",
    "links" : [ ]
  }, {
    "name" : "SYNC_VIRTUAL_EXTRAS_EXEMPTION_FLAG",
    "type" : "String",
    "comment" : "\n     * {@hide} Integer extra containing a SyncExemption flag.\n     *\n     * Only the system and the shell user can set it.\n     *\n     * This extra is \"virtual\". Once passed to the system server, it'll be removed from the bundle.\n     ",
    "links" : [ ]
  }, {
    "name" : "SYNC_EXTRAS_INITIALIZE",
    "type" : "String",
    "comment" : "\n     * Set by the SyncManager to request that the SyncAdapter initialize itself for\n     * the given account/authority pair. One required initialization step is to\n     * ensure that {@link #setIsSyncable(android.accounts.Account, String, int)} has been\n     * called with a >= 0 value. When this flag is set the SyncAdapter does not need to\n     * do a full sync, though it is allowed to do so.\n     ",
    "links" : [ "#setIsSyncable(android.accounts.Account" ]
  }, {
    "name" : "ACTION_SYNC_CONN_STATUS_CHANGED",
    "type" : "Intent",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "SCHEME_CONTENT",
    "type" : "String",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "SCHEME_ANDROID_RESOURCE",
    "type" : "String",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "SCHEME_FILE",
    "type" : "String",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "EXTRA_SIZE",
    "type" : "String",
    "comment" : "\n     * An extra {@link Point} describing the optimal size for a requested image\n     * resource, in pixels. If a provider has multiple sizes of the image, it\n     * should return the image closest to this size.\n     *\n     * @see #openTypedAssetFileDescriptor(Uri, String, Bundle)\n     * @see #openTypedAssetFileDescriptor(Uri, String, Bundle,\n     *      CancellationSignal)\n     ",
    "links" : [ "android.graphics.Point" ]
  }, {
    "name" : "EXTRA_REFRESH_SUPPORTED",
    "type" : "String",
    "comment" : "\n     * An extra boolean describing whether a particular provider supports refresh\n     * or not. If a provider supports refresh, it should include this key in its\n     * returned Cursor as part of its query call.\n     *\n     ",
    "links" : [ ]
  }, {
    "name" : "QUERY_ARG_SQL_SELECTION",
    "type" : "String",
    "comment" : "\n     * Key for an SQL style selection string that may be present in the query Bundle argument\n     * passed to {@link ContentProvider#query(Uri, String[], Bundle, CancellationSignal)}\n     * when called by a legacy client.\n     *\n     * <p>Clients should never include user supplied values directly in the selection string,\n     * as this presents an avenue for SQL injection attacks. In lieu of this, a client\n     * should use standard placeholder notation to represent values in a selection string,\n     * then supply a corresponding value in {@value #QUERY_ARG_SQL_SELECTION_ARGS}.\n     *\n     * <p><b>Apps targeting {@link android.os.Build.VERSION_CODES#O} or higher are strongly\n     * encourage to use structured query arguments in lieu of opaque SQL query clauses.</b>\n     *\n     * @see #QUERY_ARG_SORT_COLUMNS\n     * @see #QUERY_ARG_SORT_DIRECTION\n     * @see #QUERY_ARG_SORT_COLLATION\n     * @see #QUERY_ARG_SORT_LOCALE\n     ",
    "links" : [ "android.os.Build.VERSION_CODES#O", "android.content.ContentProvider#query(Uri" ]
  }, {
    "name" : "QUERY_ARG_SQL_SELECTION_ARGS",
    "type" : "String",
    "comment" : "\n     * Key for SQL selection string arguments list.\n     *\n     * <p>Clients should never include user supplied values directly in the selection string,\n     * as this presents an avenue for SQL injection attacks. In lieu of this, a client\n     * should use standard placeholder notation to represent values in a selection string,\n     * then supply a corresponding value in {@value #QUERY_ARG_SQL_SELECTION_ARGS}.\n     *\n     * <p><b>Apps targeting {@link android.os.Build.VERSION_CODES#O} or higher are strongly\n     * encourage to use structured query arguments in lieu of opaque SQL query clauses.</b>\n     *\n     * @see #QUERY_ARG_SORT_COLUMNS\n     * @see #QUERY_ARG_SORT_DIRECTION\n     * @see #QUERY_ARG_SORT_COLLATION\n     * @see #QUERY_ARG_SORT_LOCALE\n     ",
    "links" : [ "android.os.Build.VERSION_CODES#O" ]
  }, {
    "name" : "QUERY_ARG_SQL_SORT_ORDER",
    "type" : "String",
    "comment" : "\n     * Key for an SQL style sort string that may be present in the query Bundle argument\n     * passed to {@link ContentProvider#query(Uri, String[], Bundle, CancellationSignal)}\n     * when called by a legacy client.\n     *\n     * <p><b>Apps targeting {@link android.os.Build.VERSION_CODES#O} or higher are strongly\n     * encourage to use structured query arguments in lieu of opaque SQL query clauses.</b>\n     *\n     * @see #QUERY_ARG_SORT_COLUMNS\n     * @see #QUERY_ARG_SORT_DIRECTION\n     * @see #QUERY_ARG_SORT_COLLATION\n     * @see #QUERY_ARG_SORT_LOCALE\n     ",
    "links" : [ "android.os.Build.VERSION_CODES#O", "android.content.ContentProvider#query(Uri" ]
  }, {
    "name" : "QUERY_ARG_SQL_GROUP_BY",
    "type" : "String",
    "comment" : "\n     * Key for an SQL style {@code GROUP BY} string that may be present in the\n     * query Bundle argument passed to\n     * {@link ContentProvider#query(Uri, String[], Bundle, CancellationSignal)}.\n     *\n     * <p><b>Apps targeting {@link android.os.Build.VERSION_CODES#O} or higher are strongly\n     * encourage to use structured query arguments in lieu of opaque SQL query clauses.</b>\n     *\n     * @see #QUERY_ARG_GROUP_COLUMNS\n     ",
    "links" : [ "android.os.Build.VERSION_CODES#O", "android.content.ContentProvider#query(Uri" ]
  }, {
    "name" : "QUERY_ARG_SQL_HAVING",
    "type" : "String",
    "comment" : "\n     * Key for an SQL style {@code HAVING} string that may be present in the\n     * query Bundle argument passed to\n     * {@link ContentProvider#query(Uri, String[], Bundle, CancellationSignal)}.\n     *\n     * <p><b>Apps targeting {@link android.os.Build.VERSION_CODES#O} or higher are strongly\n     * encourage to use structured query arguments in lieu of opaque SQL query clauses.</b>\n     ",
    "links" : [ "android.os.Build.VERSION_CODES#O", "android.content.ContentProvider#query(Uri" ]
  }, {
    "name" : "QUERY_ARG_SQL_LIMIT",
    "type" : "String",
    "comment" : "\n     * Key for an SQL style {@code LIMIT} string that may be present in the\n     * query Bundle argument passed to\n     * {@link ContentProvider#query(Uri, String[], Bundle, CancellationSignal)}.\n     *\n     * <p><b>Apps targeting {@link android.os.Build.VERSION_CODES#O} or higher are strongly\n     * encourage to use structured query arguments in lieu of opaque SQL query clauses.</b>\n     *\n     * @see #QUERY_ARG_LIMIT\n     * @see #QUERY_ARG_OFFSET\n     ",
    "links" : [ "android.os.Build.VERSION_CODES#O", "android.content.ContentProvider#query(Uri" ]
  }, {
    "name" : "QUERY_ARG_SORT_COLUMNS",
    "type" : "String",
    "comment" : "\n     * Specifies the list of columns (stored as a {@code String[]}) against\n     * which to sort results. When first column values are identical, records\n     * are then sorted based on second column values, and so on.\n     * <p>\n     * Columns present in this list must also be included in the projection\n     * supplied to\n     * {@link ContentResolver#query(Uri, String[], Bundle, CancellationSignal)}.\n     * <p>\n     * Apps targeting {@link android.os.Build.VERSION_CODES#O} or higher:\n     * <li>{@link ContentProvider} implementations: When preparing data in\n     * {@link ContentProvider#query(Uri, String[], Bundle, CancellationSignal)},\n     * if sort columns is reflected in the returned Cursor, it is strongly\n     * recommended that {@link #QUERY_ARG_SORT_COLUMNS} then be included in the\n     * array of honored arguments reflected in {@link Cursor} extras\n     * {@link Bundle} under {@link #EXTRA_HONORED_ARGS}.\n     * <li>When querying a provider, where no QUERY_ARG_SQL* otherwise exists in\n     * the arguments {@link Bundle}, the Content framework will attempt to\n     * synthesize a QUERY_ARG_SQL* argument using the corresponding\n     * QUERY_ARG_SORT* values.\n     ",
    "links" : [ "android.os.Build.VERSION_CODES#O", "android.content.ContentProvider#query(Uri", "android.content.ContentResolver#query(Uri", "android.os.Bundle", "#QUERY_ARG_SORT_COLUMNS", "#EXTRA_HONORED_ARGS", "android.content.ContentProvider", "android.database.Cursor" ]
  }, {
    "name" : "QUERY_ARG_SORT_DIRECTION",
    "type" : "String",
    "comment" : "\n     * Specifies desired sort order. When unspecified a provider may provide a default\n     * sort direction, or choose to return unsorted results.\n     *\n     * <p>Apps targeting {@link android.os.Build.VERSION_CODES#O} or higher:\n     *\n     * <li>{@link ContentProvider} implementations: When preparing data in\n     * {@link ContentProvider#query(Uri, String[], Bundle, CancellationSignal)}, if sort direction\n     * is reflected in the returned Cursor, it is  strongly recommended that\n     * {@link #QUERY_ARG_SORT_DIRECTION} then be included in the array of honored arguments\n     * reflected in {@link Cursor} extras {@link Bundle} under {@link #EXTRA_HONORED_ARGS}.\n     *\n     * <li>When querying a provider, where no QUERY_ARG_SQL* otherwise exists in the\n     * arguments {@link Bundle}, the Content framework will attempt to synthesize\n     * a QUERY_ARG_SQL* argument using the corresponding QUERY_ARG_SORT* values.\n     *\n     * @see #QUERY_SORT_DIRECTION_ASCENDING\n     * @see #QUERY_SORT_DIRECTION_DESCENDING\n     ",
    "links" : [ "android.os.Build.VERSION_CODES#O", "android.content.ContentProvider#query(Uri", "android.os.Bundle", "#EXTRA_HONORED_ARGS", "android.content.ContentProvider", "#QUERY_ARG_SORT_DIRECTION", "android.database.Cursor" ]
  }, {
    "name" : "QUERY_ARG_SORT_COLLATION",
    "type" : "String",
    "comment" : "\n     * Allows client to specify a hint to the provider declaring which collation\n     * to use when sorting values.\n     * <p>\n     * Providers may support custom collators. When specifying a custom collator\n     * the value is determined by the Provider.\n     * <p>\n     * {@link ContentProvider} implementations: When preparing data in\n     * {@link ContentProvider#query(Uri, String[], Bundle, CancellationSignal)},\n     * if sort collation is reflected in the returned Cursor, it is strongly\n     * recommended that {@link #QUERY_ARG_SORT_COLLATION} then be included in\n     * the array of honored arguments reflected in {@link Cursor} extras\n     * {@link Bundle} under {@link #EXTRA_HONORED_ARGS}.\n     * <p>\n     * When querying a provider, where no QUERY_ARG_SQL* otherwise exists in the\n     * arguments {@link Bundle}, the Content framework will attempt to\n     * synthesize a QUERY_ARG_SQL* argument using the corresponding\n     * QUERY_ARG_SORT* values.\n     *\n     * @see java.text.Collator#PRIMARY\n     * @see java.text.Collator#SECONDARY\n     * @see java.text.Collator#TERTIARY\n     * @see java.text.Collator#IDENTICAL\n     ",
    "links" : [ "android.content.ContentProvider#query(Uri", "android.os.Bundle", "#QUERY_ARG_SORT_COLLATION", "#EXTRA_HONORED_ARGS", "android.content.ContentProvider", "android.database.Cursor" ]
  }, {
    "name" : "QUERY_ARG_SORT_LOCALE",
    "type" : "String",
    "comment" : "\n     * Allows client to specify a hint to the provider declaring which locale to\n     * use when sorting values.\n     * <p>\n     * The value is defined as a RFC 3066 locale ID followed by an optional\n     * keyword list, which is the locale format used to configure ICU through\n     * classes like {@link android.icu.util.ULocale}. This supports requesting\n     * advanced sorting options, such as {@code de@collation=phonebook},\n     * {@code zh@collation=pinyin}, etc.\n     * <p>\n     * {@link ContentProvider} implementations: When preparing data in\n     * {@link ContentProvider#query(Uri, String[], Bundle, CancellationSignal)},\n     * if sort locale is reflected in the returned Cursor, it is strongly\n     * recommended that {@link #QUERY_ARG_SORT_LOCALE} then be included in the\n     * array of honored arguments reflected in {@link Cursor} extras\n     * {@link Bundle} under {@link #EXTRA_HONORED_ARGS}.\n     *\n     * @see java.util.Locale#Locale(String)\n     * @see android.icu.util.ULocale#ULocale(String)\n     ",
    "links" : [ "android.content.ContentProvider#query(Uri", "#QUERY_ARG_SORT_LOCALE", "android.os.Bundle", "#EXTRA_HONORED_ARGS", "android.content.ContentProvider", "android.icu.util.ULocale", "android.database.Cursor" ]
  }, {
    "name" : "QUERY_ARG_GROUP_COLUMNS",
    "type" : "String",
    "comment" : "\n     * Specifies the list of columns (stored as a {@code String[]}) against\n     * which to group results. When column values are identical, multiple\n     * records are collapsed together into a single record.\n     * <p>\n     * Columns present in this list must also be included in the projection\n     * supplied to\n     * {@link ContentResolver#query(Uri, String[], Bundle, CancellationSignal)}.\n     * <p>\n     * Apps targeting {@link android.os.Build.VERSION_CODES#R} or higher:\n     * <li>{@link ContentProvider} implementations: When preparing data in\n     * {@link ContentProvider#query(Uri, String[], Bundle, CancellationSignal)},\n     * if group columns is reflected in the returned Cursor, it is strongly\n     * recommended that {@link #QUERY_ARG_SORT_COLUMNS} then be included in the\n     * array of honored arguments reflected in {@link Cursor} extras\n     * {@link Bundle} under {@link #EXTRA_HONORED_ARGS}.\n     * <li>When querying a provider, where no QUERY_ARG_SQL* otherwise exists in\n     * the arguments {@link Bundle}, the Content framework will attempt to\n     * synthesize an QUERY_ARG_SQL* argument using the corresponding\n     * QUERY_ARG_SORT* values.\n     ",
    "links" : [ "android.os.Build.VERSION_CODES#R", "android.content.ContentProvider#query(Uri", "android.content.ContentResolver#query(Uri", "android.os.Bundle", "#QUERY_ARG_SORT_COLUMNS", "#EXTRA_HONORED_ARGS", "android.content.ContentProvider", "android.database.Cursor" ]
  }, {
    "name" : "EXTRA_HONORED_ARGS",
    "type" : "String",
    "comment" : "\n     * Allows provider to report back to client which query keys are honored in a Cursor.\n     *\n     * <p>Key identifying a {@code String[]} containing all QUERY_ARG_SORT* arguments\n     * honored by the provider. Include this in {@link Cursor} extras {@link Bundle}\n     * when any QUERY_ARG_SORT* value was honored during the preparation of the\n     * results {@link Cursor}.\n     *\n     * <p>If present, ALL honored arguments are enumerated in this extra’s payload.\n     *\n     * @see #QUERY_ARG_SORT_COLUMNS\n     * @see #QUERY_ARG_SORT_DIRECTION\n     * @see #QUERY_ARG_SORT_COLLATION\n     * @see #QUERY_ARG_SORT_LOCALE\n     * @see #QUERY_ARG_GROUP_COLUMNS\n     ",
    "links" : [ "android.os.Bundle", "android.database.Cursor" ]
  }, {
    "name" : "QUERY_SORT_DIRECTION_ASCENDING",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "QUERY_SORT_DIRECTION_DESCENDING",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "QUERY_ARG_OFFSET",
    "type" : "String",
    "comment" : "\n     * Specifies the offset row index within a Cursor.\n     ",
    "links" : [ ]
  }, {
    "name" : "QUERY_ARG_LIMIT",
    "type" : "String",
    "comment" : "\n     * Specifies the max number of rows to include in a Cursor.\n     ",
    "links" : [ ]
  }, {
    "name" : "EXTRA_TOTAL_COUNT",
    "type" : "String",
    "comment" : "\n     * Added to {@link Cursor} extras {@link Bundle} to indicate total row count of\n     * recordset when paging is supported. Providers must include this when\n     * implementing paging support.\n     *\n     * <p>A provider may return -1 that row count of the recordset is unknown.\n     *\n     * <p>Providers having returned -1 in a previous query are recommended to\n     * send content change notification once (if) full recordset size becomes\n     * known.\n     ",
    "links" : [ "android.os.Bundle", "android.database.Cursor" ]
  }, {
    "name" : "CURSOR_ITEM_BASE_TYPE",
    "type" : "String",
    "comment" : "\n     * This is the Android platform's base MIME type for a content: URI\n     * containing a Cursor of a single item.  Applications should use this\n     * as the base type along with their own sub-type of their content: URIs\n     * that represent a particular item.  For example, hypothetical IMAP email\n     * client may have a URI\n     * <code>content://com.company.provider.imap/inbox/1</code> for a particular\n     * message in the inbox, whose MIME type would be reported as\n     * <code>CURSOR_ITEM_BASE_TYPE + \"/vnd.company.imap-msg\"</code>\n     *\n     * <p>Compare with {@link #CURSOR_DIR_BASE_TYPE}.\n     ",
    "links" : [ "#CURSOR_DIR_BASE_TYPE" ]
  }, {
    "name" : "CURSOR_DIR_BASE_TYPE",
    "type" : "String",
    "comment" : "\n     * This is the Android platform's base MIME type for a content: URI\n     * containing a Cursor of zero or more items.  Applications should use this\n     * as the base type along with their own sub-type of their content: URIs\n     * that represent a directory of items.  For example, hypothetical IMAP email\n     * client may have a URI\n     * <code>content://com.company.provider.imap/inbox</code> for all of the\n     * messages in its inbox, whose MIME type would be reported as\n     * <code>CURSOR_DIR_BASE_TYPE + \"/vnd.company.imap-msg\"</code>\n     *\n     * <p>Note how the base MIME type varies between this and\n     * {@link #CURSOR_ITEM_BASE_TYPE} depending on whether there is\n     * one single item or multiple items in the data set, while the sub-type\n     * remains the same because in either case the data structure contained\n     * in the cursor is the same.\n     ",
    "links" : [ "#CURSOR_ITEM_BASE_TYPE" ]
  }, {
    "name" : "ANY_CURSOR_ITEM_TYPE",
    "type" : "String",
    "comment" : "\n     * This is the Android platform's generic MIME type to match any MIME\n     * type of the form \"{@link #CURSOR_ITEM_BASE_TYPE}/{@code SUB_TYPE}\".\n     * {@code SUB_TYPE} is the sub-type of the application-dependent\n     * content, e.g., \"audio\", \"video\", \"playlist\".\n     ",
    "links" : [ "#CURSOR_ITEM_BASE_TYPE" ]
  }, {
    "name" : "MIME_TYPE_DEFAULT",
    "type" : "String",
    "comment" : " {@hide} ",
    "links" : [ ]
  }, {
    "name" : "SYNC_ERROR_SYNC_ALREADY_IN_PROGRESS",
    "type" : "int",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "SYNC_ERROR_AUTHENTICATION",
    "type" : "int",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "SYNC_ERROR_IO",
    "type" : "int",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "SYNC_ERROR_PARSE",
    "type" : "int",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "SYNC_ERROR_CONFLICT",
    "type" : "int",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "SYNC_ERROR_TOO_MANY_DELETIONS",
    "type" : "int",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "SYNC_ERROR_TOO_MANY_RETRIES",
    "type" : "int",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "SYNC_ERROR_INTERNAL",
    "type" : "int",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "SYNC_ERROR_NAMES",
    "type" : "String[]",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "SYNC_OBSERVER_TYPE_SETTINGS",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "SYNC_OBSERVER_TYPE_PENDING",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "SYNC_OBSERVER_TYPE_ACTIVE",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "SYNC_OBSERVER_TYPE_STATUS",
    "type" : "int",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "SYNC_OBSERVER_TYPE_ALL",
    "type" : "int",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "NOTIFY_SYNC_TO_NETWORK",
    "type" : "int",
    "comment" : "\n     * Flag for {@link #notifyChange(Uri, ContentObserver, int)}: attempt to sync the change\n     * to the network.\n     ",
    "links" : [ "#notifyChange(Uri" ]
  }, {
    "name" : "NOTIFY_SKIP_NOTIFY_FOR_DESCENDANTS",
    "type" : "int",
    "comment" : "\n     * Flag for {@link #notifyChange(Uri, ContentObserver, int)}: if set, this notification\n     * will be skipped if it is being delivered to the root URI of a ContentObserver that is\n     * using \"notify for descendants.\"  The purpose of this is to allow the provide to send\n     * a general notification of \"something under X\" changed that observers of that specific\n     * URI can receive, while also sending a specific URI under X.  It would use this flag\n     * when sending the former, so that observers of \"X and descendants\" only see the latter.\n     ",
    "links" : [ "#notifyChange(Uri" ]
  }, {
    "name" : "NOTIFY_INSERT",
    "type" : "int",
    "comment" : "\n     * Flag for {@link #notifyChange(Uri, ContentObserver, int)}: typically set\n     * by a {@link ContentProvider} to indicate that this notification is the\n     * result of an {@link ContentProvider#insert} call.\n     * <p>\n     * Sending these detailed flags are optional, but providers are strongly\n     * recommended to send them.\n     ",
    "links" : [ "#notifyChange(Uri", "android.content.ContentProvider#insert", "android.content.ContentProvider" ]
  }, {
    "name" : "NOTIFY_UPDATE",
    "type" : "int",
    "comment" : "\n     * Flag for {@link #notifyChange(Uri, ContentObserver, int)}: typically set\n     * by a {@link ContentProvider} to indicate that this notification is the\n     * result of an {@link ContentProvider#update} call.\n     * <p>\n     * Sending these detailed flags are optional, but providers are strongly\n     * recommended to send them.\n     ",
    "links" : [ "#notifyChange(Uri", "android.content.ContentProvider#update", "android.content.ContentProvider" ]
  }, {
    "name" : "NOTIFY_DELETE",
    "type" : "int",
    "comment" : "\n     * Flag for {@link #notifyChange(Uri, ContentObserver, int)}: typically set\n     * by a {@link ContentProvider} to indicate that this notification is the\n     * result of a {@link ContentProvider#delete} call.\n     * <p>\n     * Sending these detailed flags are optional, but providers are strongly\n     * recommended to send them.\n     ",
    "links" : [ "#notifyChange(Uri", "android.content.ContentProvider#delete", "android.content.ContentProvider" ]
  }, {
    "name" : "NOTIFY_NO_DELAY",
    "type" : "int",
    "comment" : "\n     * Flag for {@link #notifyChange(Uri, ContentObserver, int)}: typically set\n     * by a {@link ContentProvider} to indicate that this notification should\n     * not be subject to any delays when dispatching to apps running in the\n     * background.\n     * <p>\n     * Using this flag may negatively impact system health and performance, and\n     * should be used sparingly.\n     *\n     * @hide\n     ",
    "links" : [ "#notifyChange(Uri", "android.content.ContentProvider" ]
  }, {
    "name" : "SYNC_EXEMPTION_NONE",
    "type" : "int",
    "comment" : "\n     * No exception, throttled by app standby normally.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "SYNC_EXEMPTION_PROMOTE_BUCKET",
    "type" : "int",
    "comment" : "\n     * Exemption given to a sync request made by a foreground app (including\n     * PROCESS_STATE_IMPORTANT_FOREGROUND).\n     *\n     * At the schedule time, we promote the sync adapter app for a higher bucket:\n     * - If the device is not dozing (so the sync will start right away)\n     *   promote to ACTIVE for 1 hour.\n     * - If the device is dozing (so the sync *won't* start right away),\n     * promote to WORKING_SET for 4 hours, so it'll get a higher chance to be started once the\n     * device comes out of doze.\n     * - When the sync actually starts, we promote the sync adapter app to ACTIVE for 10 minutes,\n     * so it can schedule and start more syncs without getting throttled, even when the first\n     * operation was canceled and now we're retrying.\n     *\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "SYNC_EXEMPTION_PROMOTE_BUCKET_WITH_TEMP",
    "type" : "int",
    "comment" : "\n     * In addition to {@link #SYNC_EXEMPTION_PROMOTE_BUCKET}, we put the sync adapter app in the\n     * temp allowlist for 10 minutes, so that even RARE apps can run syncs right away.\n     * @hide\n     ",
    "links" : [ "#SYNC_EXEMPTION_PROMOTE_BUCKET" ]
  }, {
    "name" : "ENABLE_CONTENT_SAMPLE",
    "type" : "boolean",
    "comment" : " sampled accordingly.",
    "links" : [ ]
  }, {
    "name" : "SLOW_THRESHOLD_MILLIS",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mRandom",
    "type" : "Random",
    "comment" : " guarded by itself",
    "links" : [ ]
  }, {
    "name" : "REMOTE_CALLBACK_RESULT",
    "type" : "String",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "REMOTE_CALLBACK_ERROR",
    "type" : "String",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "CONTENT_PROVIDER_PUBLISH_TIMEOUT_MILLIS",
    "type" : "int",
    "comment" : "\n     * How long we wait for an attached process to publish its content providers\n     * before we decide it must be hung.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "CONTENT_PROVIDER_READY_TIMEOUT_MILLIS",
    "type" : "int",
    "comment" : "\n     * How long we wait for an provider to be published. Should be longer than\n     * {@link #CONTENT_PROVIDER_PUBLISH_TIMEOUT_MILLIS}.\n     * @hide\n     ",
    "links" : [ "#CONTENT_PROVIDER_PUBLISH_TIMEOUT_MILLIS" ]
  }, {
    "name" : "CONTENT_PROVIDER_TIMEOUT_MILLIS",
    "type" : "int",
    "comment" : " Timeout given a ContentProvider that has already been started and connected to.",
    "links" : [ ]
  }, {
    "name" : "REMOTE_CONTENT_PROVIDER_TIMEOUT_MILLIS",
    "type" : "int",
    "comment" : " needs to be started for that.",
    "links" : [ ]
  }, {
    "name" : "CONTENT_SERVICE_NAME",
    "type" : "String",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "sContentService",
    "type" : "IContentService",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mContext",
    "type" : "Context",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mPackageName",
    "type" : "String",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mTargetSdkVersion",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mWrapped",
    "type" : "ContentInterface",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "TAG",
    "type" : "String",
    "comment" : "",
    "links" : [ ]
  } ],
  "methods" : [ {
    "name" : "public static String syncErrorToString(int error)",
    "returnType" : "String",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "public static int syncErrorStringToInt(String error)",
    "returnType" : "int",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "public static ContentResolver wrap(@NonNull ContentInterface wrapped)",
    "returnType" : "ContentResolver",
    "comment" : " {@hide} ",
    "links" : [ ]
  }, {
    "name" : "public static ContentResolver wrap(@NonNull ContentProvider wrapped)",
    "returnType" : "ContentResolver",
    "comment" : "\n     * Create a {@link ContentResolver} instance that redirects all its methods\n     * to the given {@link ContentProvider}.\n     ",
    "links" : [ "android.content.ContentResolver", "android.content.ContentProvider" ]
  }, {
    "name" : "public static ContentResolver wrap(@NonNull ContentProviderClient wrapped)",
    "returnType" : "ContentResolver",
    "comment" : "\n     * Create a {@link ContentResolver} instance that redirects all its methods\n     * to the given {@link ContentProviderClient}.\n     ",
    "links" : [ "android.content.ContentResolver", "android.content.ContentProviderClient" ]
  }, {
    "name" : "protected abstract IContentProvider acquireProvider(Context c, String name)",
    "returnType" : "IContentProvider",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "protected IContentProvider acquireExistingProvider(Context c, String name)",
    "returnType" : "IContentProvider",
    "comment" : "\n     * Providing a default implementation of this, to avoid having to change a\n     * lot of other things, but implementations of ContentResolver should\n     * implement it.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public abstract boolean releaseProvider(IContentProvider icp)",
    "returnType" : "boolean",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "protected abstract IContentProvider acquireUnstableProvider(Context c, String name)",
    "returnType" : "IContentProvider",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "public abstract boolean releaseUnstableProvider(IContentProvider icp)",
    "returnType" : "boolean",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "public abstract void unstableProviderDied(IContentProvider icp)",
    "returnType" : "void",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "public void appNotRespondingViaProvider(IContentProvider icp)",
    "returnType" : "void",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "public final String getType(@NonNull Uri url)",
    "returnType" : "String",
    "comment" : "\n     * Return the MIME type of the given content URL.\n     *\n     * @param url A Uri identifying content (either a list or specific type),\n     * using the content:// scheme.\n     * @return A MIME type for the content, or null if the URL is invalid or the type is unknown\n     ",
    "links" : [ ]
  }, {
    "name" : "public String[] getStreamTypes(@NonNull Uri url, @NonNull String mimeTypeFilter)",
    "returnType" : "String[]",
    "comment" : "\n     * Query for the possible MIME types for the representations the given\n     * content URL can be returned when opened as as stream with\n     * {@link #openTypedAssetFileDescriptor}.  Note that the types here are\n     * not necessarily a superset of the type returned by {@link #getType} --\n     * many content providers cannot return a raw stream for the structured\n     * data that they contain.\n     *\n     * @param url A Uri identifying content (either a list or specific type),\n     * using the content:// scheme.\n     * @param mimeTypeFilter The desired MIME type.  This may be a pattern,\n     * such as *&#47;*, to query for all available MIME types that match the\n     * pattern.\n     * @return Returns an array of MIME type strings for all available\n     * data streams that match the given mimeTypeFilter.  If there are none,\n     * null is returned.\n     ",
    "links" : [ "#getType", "#openTypedAssetFileDescriptor" ]
  }, {
    "name" : "public final Cursor query(@RequiresPermission.Read @NonNull Uri uri, @Nullable String[] projection, @Nullable String selection, @Nullable String[] selectionArgs, @Nullable String sortOrder)",
    "returnType" : "Cursor",
    "comment" : "\n     * Query the given URI, returning a {@link Cursor} over the result set.\n     * <p>\n     * For best performance, the caller should follow these guidelines:\n     * <ul>\n     * <li>Provide an explicit projection, to prevent\n     * reading data from storage that aren't going to be used.</li>\n     * <li>Use question mark parameter markers such as 'phone=?' instead of\n     * explicit values in the {@code selection} parameter, so that queries\n     * that differ only by those values will be recognized as the same\n     * for caching purposes.</li>\n     * </ul>\n     * </p>\n     *\n     * @param uri The URI, using the content:// scheme, for the content to\n     *         retrieve.\n     * @param projection A list of which columns to return. Passing null will\n     *         return all columns, which is inefficient.\n     * @param selection A filter declaring which rows to return, formatted as an\n     *         SQL WHERE clause (excluding the WHERE itself). Passing null will\n     *         return all rows for the given URI.\n     * @param selectionArgs You may include ?s in selection, which will be\n     *         replaced by the values from selectionArgs, in the order that they\n     *         appear in the selection. The values will be bound as Strings.\n     * @param sortOrder How to order the rows, formatted as an SQL ORDER BY\n     *         clause (excluding the ORDER BY itself). Passing null will use the\n     *         default sort order, which may be unordered.\n     * @return A Cursor object, which is positioned before the first entry. May return\n     *         <code>null</code> if the underlying content provider returns <code>null</code>,\n     *         or if it crashes.\n     * @see Cursor\n     ",
    "links" : [ "android.database.Cursor" ]
  }, {
    "name" : "public final Cursor query(@RequiresPermission.Read @NonNull Uri uri, @Nullable String[] projection, @Nullable String selection, @Nullable String[] selectionArgs, @Nullable String sortOrder, @Nullable CancellationSignal cancellationSignal)",
    "returnType" : "Cursor",
    "comment" : "\n     * Query the given URI, returning a {@link Cursor} over the result set\n     * with optional support for cancellation.\n     * <p>\n     * For best performance, the caller should follow these guidelines:\n     * <ul>\n     * <li>Provide an explicit projection, to prevent\n     * reading data from storage that aren't going to be used.</li>\n     * <li>Use question mark parameter markers such as 'phone=?' instead of\n     * explicit values in the {@code selection} parameter, so that queries\n     * that differ only by those values will be recognized as the same\n     * for caching purposes.</li>\n     * </ul>\n     * </p>\n     *\n     * @param uri The URI, using the content:// scheme, for the content to\n     *         retrieve.\n     * @param projection A list of which columns to return. Passing null will\n     *         return all columns, which is inefficient.\n     * @param selection A filter declaring which rows to return, formatted as an\n     *         SQL WHERE clause (excluding the WHERE itself). Passing null will\n     *         return all rows for the given URI.\n     * @param selectionArgs You may include ?s in selection, which will be\n     *         replaced by the values from selectionArgs, in the order that they\n     *         appear in the selection. The values will be bound as Strings.\n     * @param sortOrder How to order the rows, formatted as an SQL ORDER BY\n     *         clause (excluding the ORDER BY itself). Passing null will use the\n     *         default sort order, which may be unordered.\n     * @param cancellationSignal A signal to cancel the operation in progress, or null if none.\n     * If the operation is canceled, then {@link OperationCanceledException} will be thrown\n     * when the query is executed.\n     * @return A Cursor object, which is positioned before the first entry. May return\n     *         <code>null</code> if the underlying content provider returns <code>null</code>,\n     *         or if it crashes.\n     * @see Cursor\n     ",
    "links" : [ "android.os.OperationCanceledException", "android.database.Cursor" ]
  }, {
    "name" : "public final Cursor query(@RequiresPermission.Read @NonNull final Uri uri, @Nullable String[] projection, @Nullable Bundle queryArgs, @Nullable CancellationSignal cancellationSignal)",
    "returnType" : "Cursor",
    "comment" : "\n     * Query the given URI, returning a {@link Cursor} over the result set\n     * with support for cancellation.\n     *\n     * <p>For best performance, the caller should follow these guidelines:\n     *\n     * <li>Provide an explicit projection, to prevent reading data from storage\n     * that aren't going to be used.\n     *\n     * Provider must identify which QUERY_ARG_SORT* arguments were honored during\n     * the preparation of the result set by including the respective argument keys\n     * in the {@link Cursor} extras {@link Bundle}. See {@link #EXTRA_HONORED_ARGS}\n     * for details.\n     *\n     * @see #QUERY_ARG_SORT_COLUMNS\n     * @see #QUERY_ARG_SORT_DIRECTION\n     * @see #QUERY_ARG_SORT_COLLATION\n     *\n     * @param uri The URI, using the content:// scheme, for the content to\n     *         retrieve.\n     * @param projection A list of which columns to return. Passing null will\n     *         return all columns, which is inefficient.\n     * @param queryArgs A Bundle containing additional information necessary for\n     *            the operation. Arguments may include SQL style arguments, such\n     *            as {@link ContentResolver#QUERY_ARG_SQL_LIMIT}, but note that\n     *            the documentation for each individual provider will indicate\n     *            which arguments they support.\n     * @param cancellationSignal A signal to cancel the operation in progress, or null if none.\n     * If the operation is canceled, then {@link OperationCanceledException} will be thrown\n     * when the query is executed.\n     * @return A Cursor object, which is positioned before the first entry. May return\n     *         <code>null</code> if the underlying content provider returns <code>null</code>,\n     *         or if it crashes.\n     * @see Cursor\n     ",
    "links" : [ "android.os.Bundle", "android.os.OperationCanceledException", "#EXTRA_HONORED_ARGS", "android.content.ContentResolver#QUERY_ARG_SQL_LIMIT", "android.database.Cursor" ]
  }, {
    "name" : "public final Uri canonicalizeOrElse(@NonNull Uri uri)",
    "returnType" : "Uri",
    "comment" : " {@hide} ",
    "links" : [ ]
  }, {
    "name" : "public final Uri canonicalize(@NonNull Uri url)",
    "returnType" : "Uri",
    "comment" : "\n     * Transform the given <var>url</var> to a canonical representation of\n     * its referenced resource, which can be used across devices, persisted,\n     * backed up and restored, etc.  The returned Uri is still a fully capable\n     * Uri for use with its content provider, allowing you to do all of the\n     * same content provider operations as with the original Uri --\n     * {@link #query}, {@link #openInputStream(android.net.Uri)}, etc.  The\n     * only difference in behavior between the original and new Uris is that\n     * the content provider may need to do some additional work at each call\n     * using it to resolve it to the correct resource, especially if the\n     * canonical Uri has been moved to a different environment.\n     *\n     * <p>If you are moving a canonical Uri between environments, you should\n     * perform another call to {@link #canonicalize} with that original Uri to\n     * re-canonicalize it for the current environment.  Alternatively, you may\n     * want to use {@link #uncanonicalize} to transform it to a non-canonical\n     * Uri that works only in the current environment but potentially more\n     * efficiently than the canonical representation.</p>\n     *\n     * @param url The {@link Uri} that is to be transformed to a canonical\n     * representation.  Like all resolver calls, the input can be either\n     * a non-canonical or canonical Uri.\n     *\n     * @return Returns the official canonical representation of <var>url</var>,\n     * or null if the content provider does not support a canonical representation\n     * of the given Uri.  Many providers may not support canonicalization of some\n     * or all of their Uris.\n     *\n     * @see #uncanonicalize\n     ",
    "links" : [ "#openInputStream(android.net.Uri)", "android.net.Uri", "#canonicalize", "#uncanonicalize", "#query" ]
  }, {
    "name" : "public final Uri uncanonicalize(@NonNull Uri url)",
    "returnType" : "Uri",
    "comment" : "\n     * Given a canonical Uri previously generated by {@link #canonicalize}, convert\n     * it to its local non-canonical form.  This can be useful in some cases where\n     * you know that you will only be using the Uri in the current environment and\n     * want to avoid any possible overhead when using it with the content\n     * provider or want to verify that the referenced data exists at all in the\n     * new environment.\n     *\n     * @param url The canonical {@link Uri} that is to be convered back to its\n     * non-canonical form.\n     *\n     * @return Returns the non-canonical representation of <var>url</var>.  This will\n     * return null if data identified by the canonical Uri can not be found in\n     * the current environment; callers must always check for null and deal with\n     * that by appropriately falling back to an alternative.\n     *\n     * @see #canonicalize\n     ",
    "links" : [ "android.net.Uri", "#canonicalize" ]
  }, {
    "name" : "public final boolean refresh(@NonNull Uri url, @Nullable Bundle extras, @Nullable CancellationSignal cancellationSignal)",
    "returnType" : "boolean",
    "comment" : "\n     * This allows clients to request an explicit refresh of content identified\n     * by {@code uri}.\n     * <p>\n     * Client code should only invoke this method when there is a strong\n     * indication (such as a user initiated pull to refresh gesture) that the\n     * content is stale.\n     * <p>\n     *\n     * @param url The Uri identifying the data to refresh.\n     * @param extras Additional options from the client. The definitions of\n     *            these are specific to the content provider being called.\n     * @param cancellationSignal A signal to cancel the operation in progress,\n     *            or {@code null} if none. For example, if you called refresh on\n     *            a particular uri, you should call\n     *            {@link CancellationSignal#throwIfCanceled()} to check whether\n     *            the client has canceled the refresh request.\n     * @return true if the provider actually tried refreshing.\n     ",
    "links" : [ "android.os.CancellationSignal#throwIfCanceled()" ]
  }, {
    "name" : "public int checkUriPermission(@NonNull Uri uri, int uid, @Intent.AccessUriMode int modeFlags)",
    "returnType" : "int",
    "comment" : "\n     * Perform a detailed internal check on a {@link Uri} to determine if a UID\n     * is able to access it with specific mode flags.\n     * <p>\n     * This method is typically used when the provider implements more dynamic\n     * access controls that cannot be expressed with {@code <path-permission>}\n     * style static rules.\n     * <p>\n     * Because validation of these dynamic access controls has significant\n     * system health impact, this feature is only available to providers that\n     * are built into the system.\n     *\n     * @param uri the {@link Uri} to perform an access check on.\n     * @param uid the UID to check the permission for.\n     * @param modeFlags the access flags to use for the access check, such as\n     *            {@link Intent#FLAG_GRANT_READ_URI_PERMISSION}.\n     * @return {@link PackageManager#PERMISSION_GRANTED} if access is allowed,\n     *         otherwise {@link PackageManager#PERMISSION_DENIED}.\n     * @hide\n     ",
    "links" : [ "android.content.pm.PackageManager#PERMISSION_DENIED", "android.content.pm.PackageManager#PERMISSION_GRANTED", "android.net.Uri", "android.content.Intent#FLAG_GRANT_READ_URI_PERMISSION" ]
  }, {
    "name" : "public final InputStream openInputStream(@NonNull Uri uri) throws FileNotFoundException",
    "returnType" : "InputStream",
    "comment" : "\n     * Open a stream on to the content associated with a content URI.  If there\n     * is no data associated with the URI, FileNotFoundException is thrown.\n     *\n     * <h5>Accepts the following URI schemes:</h5>\n     * <ul>\n     * <li>content ({@link #SCHEME_CONTENT})</li>\n     * <li>android.resource ({@link #SCHEME_ANDROID_RESOURCE})</li>\n     * <li>file ({@link #SCHEME_FILE})</li>\n     * </ul>\n     *\n     * <p>See {@link #openAssetFileDescriptor(Uri, String)} for more information\n     * on these schemes.\n     *\n     * @param uri The desired URI.\n     * @return InputStream or {@code null} if the provider recently crashed.\n     * @throws FileNotFoundException if the provided URI could not be opened.\n     * @see #openAssetFileDescriptor(Uri, String)\n     ",
    "links" : [ "#SCHEME_FILE", "#SCHEME_ANDROID_RESOURCE", "#openAssetFileDescriptor(Uri", "#SCHEME_CONTENT" ]
  }, {
    "name" : "public final OutputStream openOutputStream(@NonNull Uri uri) throws FileNotFoundException",
    "returnType" : "OutputStream",
    "comment" : "\n     * Synonym for {@link #openOutputStream(Uri, String)\n     * openOutputStream(uri, \"w\")}. Please note the implementation of \"w\" is up to each\n     * Provider implementation and it may or may not truncate.\n     *\n     * @param uri The desired URI.\n     * @return an OutputStream or {@code null} if the provider recently crashed.\n     * @throws FileNotFoundException if the provided URI could not be opened.\n     ",
    "links" : [ "#openOutputStream(Uri" ]
  }, {
    "name" : "public final OutputStream openOutputStream(@NonNull Uri uri, @NonNull String mode) throws FileNotFoundException",
    "returnType" : "OutputStream",
    "comment" : "\n     * Open a stream on to the content associated with a content URI.  If there\n     * is no data associated with the URI, FileNotFoundException is thrown.\n     *\n     * <h5>Accepts the following URI schemes:</h5>\n     * <ul>\n     * <li>content ({@link #SCHEME_CONTENT})</li>\n     * <li>file ({@link #SCHEME_FILE})</li>\n     * </ul>\n     *\n     * <p>See {@link #openAssetFileDescriptor(Uri, String)} for more information\n     * on these schemes.\n     *\n     * @param uri The desired URI.\n     * @param mode The string representation of the file mode. Can be \"r\", \"w\", \"wt\", \"wa\", \"rw\"\n     *             or \"rwt\". Please note the exact implementation of these may differ for each\n     *             Provider implementation - for example, \"w\" may or may not truncate.\n     * @return an OutputStream or {@code null} if the provider recently crashed.\n     * @throws FileNotFoundException if the provided URI could not be opened.\n     * @see #openAssetFileDescriptor(Uri, String)\n     ",
    "links" : [ "#SCHEME_FILE", "#openAssetFileDescriptor(Uri", "#SCHEME_CONTENT" ]
  }, {
    "name" : "public final ParcelFileDescriptor openFile(@NonNull Uri uri, @NonNull String mode, @Nullable CancellationSignal signal) throws FileNotFoundException",
    "returnType" : "ParcelFileDescriptor",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public final ParcelFileDescriptor openFileDescriptor(@NonNull Uri uri, @NonNull String mode) throws FileNotFoundException",
    "returnType" : "ParcelFileDescriptor",
    "comment" : "\n     * Open a raw file descriptor to access data under a URI.  This\n     * is like {@link #openAssetFileDescriptor(Uri, String)}, but uses the\n     * underlying {@link ContentProvider#openFile}\n     * ContentProvider.openFile()} method, so will <em>not</em> work with\n     * providers that return sub-sections of files.  If at all possible,\n     * you should use {@link #openAssetFileDescriptor(Uri, String)}.  You\n     * will receive a FileNotFoundException exception if the provider returns a\n     * sub-section of a file.\n     *\n     * <h5>Accepts the following URI schemes:</h5>\n     * <ul>\n     * <li>content ({@link #SCHEME_CONTENT})</li>\n     * <li>file ({@link #SCHEME_FILE})</li>\n     * </ul>\n     *\n     * <p>See {@link #openAssetFileDescriptor(Uri, String)} for more information\n     * on these schemes.\n     * <p>\n     * If opening with the exclusive \"r\" or \"w\" modes, the returned\n     * ParcelFileDescriptor could be a pipe or socket pair to enable streaming\n     * of data. Opening with the \"rw\" mode implies a file on disk that supports\n     * seeking. If possible, always use an exclusive mode to give the underlying\n     * {@link ContentProvider} the most flexibility.\n     * <p>\n     * If you are writing a file, and need to communicate an error to the\n     * provider, use {@link ParcelFileDescriptor#closeWithError(String)}.\n     *\n     * @param uri The desired URI to open.\n     * @param mode The string representation of the file mode. Can be \"r\", \"w\", \"wt\", \"wa\", \"rw\"\n     *             or \"rwt\". Please note the exact implementation of these may differ for each\n     *             Provider implementation - for example, \"w\" may or may not truncate.\n     * @return Returns a new ParcelFileDescriptor pointing to the file or {@code null} if the\n     * provider recently crashed. You own this descriptor and are responsible for closing it\n     * when done.\n     * @throws FileNotFoundException Throws FileNotFoundException if no\n     * file exists under the URI or the mode is invalid.\n     * @see #openAssetFileDescriptor(Uri, String)\n     ",
    "links" : [ "#SCHEME_FILE", "android.content.ContentProvider#openFile", "#openAssetFileDescriptor(Uri", "#SCHEME_CONTENT", "android.os.ParcelFileDescriptor#closeWithError(String)", "android.content.ContentProvider" ]
  }, {
    "name" : "public final ParcelFileDescriptor openFileDescriptor(@NonNull Uri uri, @NonNull String mode, @Nullable CancellationSignal cancellationSignal) throws FileNotFoundException",
    "returnType" : "ParcelFileDescriptor",
    "comment" : "\n     * Open a raw file descriptor to access data under a URI.  This\n     * is like {@link #openAssetFileDescriptor(Uri, String)}, but uses the\n     * underlying {@link ContentProvider#openFile}\n     * ContentProvider.openFile()} method, so will <em>not</em> work with\n     * providers that return sub-sections of files.  If at all possible,\n     * you should use {@link #openAssetFileDescriptor(Uri, String)}.  You\n     * will receive a FileNotFoundException exception if the provider returns a\n     * sub-section of a file.\n     *\n     * <h5>Accepts the following URI schemes:</h5>\n     * <ul>\n     * <li>content ({@link #SCHEME_CONTENT})</li>\n     * <li>file ({@link #SCHEME_FILE})</li>\n     * </ul>\n     *\n     * <p>See {@link #openAssetFileDescriptor(Uri, String)} for more information\n     * on these schemes.\n     * <p>\n     * If opening with the exclusive \"r\" or \"w\" modes, the returned\n     * ParcelFileDescriptor could be a pipe or socket pair to enable streaming\n     * of data. Opening with the \"rw\" mode implies a file on disk that supports\n     * seeking. If possible, always use an exclusive mode to give the underlying\n     * {@link ContentProvider} the most flexibility.\n     * <p>\n     * If you are writing a file, and need to communicate an error to the\n     * provider, use {@link ParcelFileDescriptor#closeWithError(String)}.\n     *\n     * @param uri The desired URI to open.\n     * @param mode The string representation of the file mode. Can be \"r\", \"w\", \"wt\", \"wa\", \"rw\"\n     *             or \"rwt\". Please note the exact implementation of these may differ for each\n     *             Provider implementation - for example, \"w\" may or may not truncate.\n     * @param cancellationSignal A signal to cancel the operation in progress,\n     *         or null if none. If the operation is canceled, then\n     *         {@link OperationCanceledException} will be thrown.\n     * @return Returns a new ParcelFileDescriptor pointing to the file or {@code null} if the\n     * provider recently crashed. You own this descriptor and are responsible for closing it\n     * when done.\n     * @throws FileNotFoundException Throws FileNotFoundException if no\n     * file exists under the URI or the mode is invalid.\n     * @see #openAssetFileDescriptor(Uri, String)\n     ",
    "links" : [ "#SCHEME_FILE", "android.os.OperationCanceledException", "android.content.ContentProvider#openFile", "#openAssetFileDescriptor(Uri", "#SCHEME_CONTENT", "android.os.ParcelFileDescriptor#closeWithError(String)", "android.content.ContentProvider" ]
  }, {
    "name" : "public final AssetFileDescriptor openAssetFile(@NonNull Uri uri, @NonNull String mode, @Nullable CancellationSignal signal) throws FileNotFoundException",
    "returnType" : "AssetFileDescriptor",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public final AssetFileDescriptor openAssetFileDescriptor(@NonNull Uri uri, @NonNull String mode) throws FileNotFoundException",
    "returnType" : "AssetFileDescriptor",
    "comment" : "\n     * Open a raw file descriptor to access data under a URI.  This\n     * interacts with the underlying {@link ContentProvider#openAssetFile}\n     * method of the provider associated with the given URI, to retrieve any file stored there.\n     *\n     * <h5>Accepts the following URI schemes:</h5>\n     * <ul>\n     * <li>content ({@link #SCHEME_CONTENT})</li>\n     * <li>android.resource ({@link #SCHEME_ANDROID_RESOURCE})</li>\n     * <li>file ({@link #SCHEME_FILE})</li>\n     * </ul>\n     * <h5>The android.resource ({@link #SCHEME_ANDROID_RESOURCE}) Scheme</h5>\n     * <p>\n     * A Uri object can be used to reference a resource in an APK file.  The\n     * Uri should be one of the following formats:\n     * <ul>\n     * <li><code>android.resource://package_name/id_number</code><br/>\n     * <code>package_name</code> is your package name as listed in your AndroidManifest.xml.\n     * For example <code>com.example.myapp</code><br/>\n     * <code>id_number</code> is the int form of the ID.<br/>\n     * The easiest way to construct this form is\n     * <pre>Uri uri = Uri.parse(\"android.resource://com.example.myapp/\" + R.raw.my_resource\");</pre>\n     * </li>\n     * <li><code>android.resource://package_name/type/name</code><br/>\n     * <code>package_name</code> is your package name as listed in your AndroidManifest.xml.\n     * For example <code>com.example.myapp</code><br/>\n     * <code>type</code> is the string form of the resource type.  For example, <code>raw</code>\n     * or <code>drawable</code>.\n     * <code>name</code> is the string form of the resource name.  That is, whatever the file\n     * name was in your res directory, without the type extension.\n     * The easiest way to construct this form is\n     * <pre>Uri uri = Uri.parse(\"android.resource://com.example.myapp/raw/my_resource\");</pre>\n     * </li>\n     * </ul>\n     *\n     * <p>Note that if this function is called for read-only input (mode is \"r\")\n     * on a content: URI, it will instead call {@link #openTypedAssetFileDescriptor}\n     * for you with a MIME type of \"*&#47;*\".  This allows such callers to benefit\n     * from any built-in data conversion that a provider implements.\n     *\n     * @param uri The desired URI to open.\n     * @param mode The string representation of the file mode. Can be \"r\", \"w\", \"wt\", \"wa\", \"rw\"\n     *             or \"rwt\". Please note the exact implementation of these may differ for each\n     *             Provider implementation - for example, \"w\" may or may not truncate.\n     * @return Returns a new ParcelFileDescriptor pointing to the file or {@code null} if the\n     * provider recently crashed. You own this descriptor and are responsible for closing it\n     * when done.\n     * @throws FileNotFoundException Throws FileNotFoundException of no\n     * file exists under the URI or the mode is invalid.\n     ",
    "links" : [ "#SCHEME_FILE", "android.content.ContentProvider#openAssetFile", "#SCHEME_ANDROID_RESOURCE", "#SCHEME_CONTENT", "#openTypedAssetFileDescriptor" ]
  }, {
    "name" : "public final AssetFileDescriptor openAssetFileDescriptor(@NonNull Uri uri, @NonNull String mode, @Nullable CancellationSignal cancellationSignal) throws FileNotFoundException",
    "returnType" : "AssetFileDescriptor",
    "comment" : "\n     * Open a raw file descriptor to access data under a URI.  This\n     * interacts with the underlying {@link ContentProvider#openAssetFile}\n     * method of the provider associated with the given URI, to retrieve any file stored there.\n     *\n     * <h5>Accepts the following URI schemes:</h5>\n     * <ul>\n     * <li>content ({@link #SCHEME_CONTENT})</li>\n     * <li>android.resource ({@link #SCHEME_ANDROID_RESOURCE})</li>\n     * <li>file ({@link #SCHEME_FILE})</li>\n     * </ul>\n     * <h5>The android.resource ({@link #SCHEME_ANDROID_RESOURCE}) Scheme</h5>\n     * <p>\n     * A Uri object can be used to reference a resource in an APK file.  The\n     * Uri should be one of the following formats:\n     * <ul>\n     * <li><code>android.resource://package_name/id_number</code><br/>\n     * <code>package_name</code> is your package name as listed in your AndroidManifest.xml.\n     * For example <code>com.example.myapp</code><br/>\n     * <code>id_number</code> is the int form of the ID.<br/>\n     * The easiest way to construct this form is\n     * <pre>Uri uri = Uri.parse(\"android.resource://com.example.myapp/\" + R.raw.my_resource\");</pre>\n     * </li>\n     * <li><code>android.resource://package_name/type/name</code><br/>\n     * <code>package_name</code> is your package name as listed in your AndroidManifest.xml.\n     * For example <code>com.example.myapp</code><br/>\n     * <code>type</code> is the string form of the resource type.  For example, <code>raw</code>\n     * or <code>drawable</code>.\n     * <code>name</code> is the string form of the resource name.  That is, whatever the file\n     * name was in your res directory, without the type extension.\n     * The easiest way to construct this form is\n     * <pre>Uri uri = Uri.parse(\"android.resource://com.example.myapp/raw/my_resource\");</pre>\n     * </li>\n     * </ul>\n     *\n     * <p>Note that if this function is called for read-only input (mode is \"r\")\n     * on a content: URI, it will instead call {@link #openTypedAssetFileDescriptor}\n     * for you with a MIME type of \"*&#47;*\".  This allows such callers to benefit\n     * from any built-in data conversion that a provider implements.\n     *\n     * @param uri The desired URI to open.\n     * @param mode The string representation of the file mode. Can be \"r\", \"w\", \"wt\", \"wa\", \"rw\"\n     *             or \"rwt\". Please note \"w\" is write only and \"wt\" is write and truncate.\n     *             See{@link ParcelFileDescriptor#parseMode} for more details.\n     * @param cancellationSignal A signal to cancel the operation in progress, or null if\n     *            none. If the operation is canceled, then\n     *            {@link OperationCanceledException} will be thrown.\n     * @return Returns a new ParcelFileDescriptor pointing to the file or {@code null} if the\n     * provider recently crashed. You own this descriptor and are responsible for closing it\n     * when done.\n     * @throws FileNotFoundException Throws FileNotFoundException of no\n     * file exists under the URI or the mode is invalid.\n     ",
    "links" : [ "#SCHEME_FILE", "android.os.ParcelFileDescriptor#parseMode", "android.content.ContentProvider#openAssetFile", "android.os.OperationCanceledException", "#SCHEME_ANDROID_RESOURCE", "#SCHEME_CONTENT", "#openTypedAssetFileDescriptor" ]
  }, {
    "name" : "public final AssetFileDescriptor openTypedAssetFile(@NonNull Uri uri, @NonNull String mimeTypeFilter, @Nullable Bundle opts, @Nullable CancellationSignal signal) throws FileNotFoundException",
    "returnType" : "AssetFileDescriptor",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public final AssetFileDescriptor openTypedAssetFileDescriptor(@NonNull Uri uri, @NonNull String mimeType, @Nullable Bundle opts) throws FileNotFoundException",
    "returnType" : "AssetFileDescriptor",
    "comment" : "\n     * Open a raw file descriptor to access (potentially type transformed)\n     * data from a \"content:\" URI.  This interacts with the underlying\n     * {@link ContentProvider#openTypedAssetFile} method of the provider\n     * associated with the given URI, to retrieve retrieve any appropriate\n     * data stream for the data stored there.\n     *\n     * <p>Unlike {@link #openAssetFileDescriptor}, this function only works\n     * with \"content:\" URIs, because content providers are the only facility\n     * with an associated MIME type to ensure that the returned data stream\n     * is of the desired type.\n     *\n     * <p>All text/* streams are encoded in UTF-8.\n     *\n     * @param uri The desired URI to open.\n     * @param mimeType The desired MIME type of the returned data.  This can\n     * be a pattern such as *&#47;*, which will allow the content provider to\n     * select a type, though there is no way for you to determine what type\n     * it is returning.\n     * @param opts Additional provider-dependent options.\n     * @return Returns a new ParcelFileDescriptor from which you can read the\n     * data stream from the provider or {@code null} if the provider recently crashed.\n     * Note that this may be a pipe, meaning you can't seek in it.  The only seek you\n     * should do is if the AssetFileDescriptor contains an offset, to move to that offset before\n     * reading.  You own this descriptor and are responsible for closing it when done.\n     * @throws FileNotFoundException Throws FileNotFoundException of no\n     * data of the desired type exists under the URI.\n     ",
    "links" : [ "android.content.ContentProvider#openTypedAssetFile", "#openAssetFileDescriptor" ]
  }, {
    "name" : "public final AssetFileDescriptor openTypedAssetFileDescriptor(@NonNull Uri uri, @NonNull String mimeType, @Nullable Bundle opts, @Nullable CancellationSignal cancellationSignal) throws FileNotFoundException",
    "returnType" : "AssetFileDescriptor",
    "comment" : "\n     * Open a raw file descriptor to access (potentially type transformed)\n     * data from a \"content:\" URI.  This interacts with the underlying\n     * {@link ContentProvider#openTypedAssetFile} method of the provider\n     * associated with the given URI, to retrieve any appropriate\n     * data stream for the data stored there.\n     *\n     * <p>Unlike {@link #openAssetFileDescriptor}, this function only works\n     * with \"content:\" URIs, because content providers are the only facility\n     * with an associated MIME type to ensure that the returned data stream\n     * is of the desired type.\n     *\n     * <p>All text/* streams are encoded in UTF-8.\n     *\n     * @param uri The desired URI to open.\n     * @param mimeType The desired MIME type of the returned data.  This can\n     * be a pattern such as *&#47;*, which will allow the content provider to\n     * select a type, though there is no way for you to determine what type\n     * it is returning.\n     * @param opts Additional provider-dependent options.\n     * @param cancellationSignal A signal to cancel the operation in progress,\n     *         or null if none. If the operation is canceled, then\n     *         {@link OperationCanceledException} will be thrown.\n     * @return Returns a new ParcelFileDescriptor from which you can read the\n     * data stream from the provider or {@code null} if the provider recently crashed.\n     * Note that this may be a pipe, meaning you can't seek in it.  The only seek you\n     * should do is if the AssetFileDescriptor contains an offset, to move to that offset before\n     * reading.  You own this descriptor and are responsible for closing it when done.\n     * @throws FileNotFoundException Throws FileNotFoundException of no\n     * data of the desired type exists under the URI.\n     ",
    "links" : [ "android.os.OperationCanceledException", "android.content.ContentProvider#openTypedAssetFile", "#openAssetFileDescriptor" ]
  }, {
    "name" : "public OpenResourceIdResult getResourceId(Uri uri) throws FileNotFoundException",
    "returnType" : "OpenResourceIdResult",
    "comment" : "\n     * Resolves an android.resource URI to a {@link Resources} and a resource id.\n     *\n     * @hide\n     ",
    "links" : [ "android.content.res.Resources" ]
  }, {
    "name" : "public final Uri insert(@RequiresPermission.Write @NonNull Uri url, @Nullable ContentValues values)",
    "returnType" : "Uri",
    "comment" : "\n     * Inserts a row into a table at the given URL.\n     *\n     * If the content provider supports transactions the insertion will be atomic.\n     *\n     * @param url The URL of the table to insert into.\n     * @param values The initial values for the newly inserted row. The key is the column name for\n     *               the field. Passing an empty ContentValues will create an empty row.\n     * @return the URL of the newly created row. May return <code>null</code> if the underlying\n     *         content provider returns <code>null</code>, or if it crashes.\n     ",
    "links" : [ ]
  }, {
    "name" : "public final Uri insert(@RequiresPermission.Write @NonNull Uri url, @Nullable ContentValues values, @Nullable Bundle extras)",
    "returnType" : "Uri",
    "comment" : "\n     * Inserts a row into a table at the given URL.\n     *\n     * If the content provider supports transactions the insertion will be atomic.\n     *\n     * @param url The URL of the table to insert into.\n     * @param values The initial values for the newly inserted row. The key is the column name for\n     *               the field. Passing an empty ContentValues will create an empty row.\n     * @param extras A Bundle containing additional information necessary for\n     *            the operation. Arguments may include SQL style arguments, such\n     *            as {@link ContentResolver#QUERY_ARG_SQL_LIMIT}, but note that\n     *            the documentation for each individual provider will indicate\n     *            which arguments they support.\n     * @return the URL of the newly created row. May return <code>null</code> if the underlying\n     *         content provider returns <code>null</code>, or if it crashes.\n     * @throws IllegalArgumentException if the provider doesn't support one of\n     *             the requested Bundle arguments.\n     ",
    "links" : [ "android.content.ContentResolver#QUERY_ARG_SQL_LIMIT" ]
  }, {
    "name" : "public ContentProviderResult[] applyBatch(@NonNull String authority, @NonNull ArrayList<ContentProviderOperation> operations) throws RemoteException, OperationApplicationException",
    "returnType" : "ContentProviderResult[]",
    "comment" : "\n     * Applies each of the {@link ContentProviderOperation} objects and returns an array\n     * of their results. Passes through OperationApplicationException, which may be thrown\n     * by the call to {@link ContentProviderOperation#apply}.\n     * If all the applications succeed then a {@link ContentProviderResult} array with the\n     * same number of elements as the operations will be returned. It is implementation-specific\n     * how many, if any, operations will have been successfully applied if a call to\n     * apply results in a {@link OperationApplicationException}.\n     * @param authority the authority of the ContentProvider to which this batch should be applied\n     * @param operations the operations to apply\n     * @return the results of the applications\n     * @throws OperationApplicationException thrown if an application fails.\n     * See {@link ContentProviderOperation#apply} for more information.\n     * @throws RemoteException thrown if a RemoteException is encountered while attempting\n     *   to communicate with a remote provider.\n     ",
    "links" : [ "android.content.ContentProviderOperation", "android.content.ContentProviderResult", "android.content.ContentProviderOperation#apply", "android.content.OperationApplicationException" ]
  }, {
    "name" : "public final int bulkInsert(@RequiresPermission.Write @NonNull Uri url, @NonNull ContentValues[] values)",
    "returnType" : "int",
    "comment" : "\n     * Inserts multiple rows into a table at the given URL.\n     *\n     * This function make no guarantees about the atomicity of the insertions.\n     *\n     * @param url The URL of the table to insert into.\n     * @param values The initial values for the newly inserted rows. The key is the column name for\n     *               the field. Passing null will create an empty row.\n     * @return the number of newly created rows.\n     ",
    "links" : [ ]
  }, {
    "name" : "public final int delete(@RequiresPermission.Write @NonNull Uri url, @Nullable String where, @Nullable String[] selectionArgs)",
    "returnType" : "int",
    "comment" : "\n     * Deletes row(s) specified by a content URI.\n     *\n     * If the content provider supports transactions, the deletion will be atomic.\n     *\n     * @param url The URL of the row to delete.\n     * @param where A filter to apply to rows before deleting, formatted as an SQL WHERE clause\n                    (excluding the WHERE itself).\n     * @return The number of rows deleted.\n     ",
    "links" : [ ]
  }, {
    "name" : "public final int delete(@RequiresPermission.Write @NonNull Uri url, @Nullable Bundle extras)",
    "returnType" : "int",
    "comment" : "\n     * Deletes row(s) specified by a content URI.\n     *\n     * If the content provider supports transactions, the deletion will be atomic.\n     *\n     * @param url The URL of the row to delete.\n     * @param extras A Bundle containing additional information necessary for\n     *            the operation. Arguments may include SQL style arguments, such\n     *            as {@link ContentResolver#QUERY_ARG_SQL_LIMIT}, but note that\n     *            the documentation for each individual provider will indicate\n     *            which arguments they support.\n     * @return The number of rows deleted.\n     * @throws IllegalArgumentException if the provider doesn't support one of\n     *             the requested Bundle arguments.\n     ",
    "links" : [ "android.content.ContentResolver#QUERY_ARG_SQL_LIMIT" ]
  }, {
    "name" : "public final int update(@RequiresPermission.Write @NonNull Uri uri, @Nullable ContentValues values, @Nullable String where, @Nullable String[] selectionArgs)",
    "returnType" : "int",
    "comment" : "\n     * Update row(s) in a content URI.\n     *\n     * If the content provider supports transactions the update will be atomic.\n     *\n     * @param uri The URI to modify.\n     * @param values The new field values. The key is the column name for the field.\n                     A null value will remove an existing field value.\n     * @param where A filter to apply to rows before updating, formatted as an SQL WHERE clause\n                    (excluding the WHERE itself).\n     * @return the number of rows updated.\n     * @throws NullPointerException if uri or values are null\n     ",
    "links" : [ ]
  }, {
    "name" : "public final int update(@RequiresPermission.Write @NonNull Uri uri, @Nullable ContentValues values, @Nullable Bundle extras)",
    "returnType" : "int",
    "comment" : "\n     * Update row(s) in a content URI.\n     *\n     * If the content provider supports transactions the update will be atomic.\n     *\n     * @param uri The URI to modify.\n     * @param values The new field values. The key is the column name for the field.\n                     A null value will remove an existing field value.\n     * @param extras A Bundle containing additional information necessary for\n     *            the operation. Arguments may include SQL style arguments, such\n     *            as {@link ContentResolver#QUERY_ARG_SQL_LIMIT}, but note that\n     *            the documentation for each individual provider will indicate\n     *            which arguments they support.\n     * @return the number of rows updated.\n     * @throws NullPointerException if uri or values are null\n     * @throws IllegalArgumentException if the provider doesn't support one of\n     *             the requested Bundle arguments.\n     ",
    "links" : [ "android.content.ContentResolver#QUERY_ARG_SQL_LIMIT" ]
  }, {
    "name" : "public final Bundle call(@NonNull Uri uri, @NonNull String method, @Nullable String arg, @Nullable Bundle extras)",
    "returnType" : "Bundle",
    "comment" : "\n     * Call a provider-defined method.  This can be used to implement\n     * read or write interfaces which are cheaper than using a Cursor and/or\n     * do not fit into the traditional table model.\n     *\n     * @param method provider-defined method name to call.  Opaque to\n     *   framework, but must be non-null.\n     * @param arg provider-defined String argument.  May be null.\n     * @param extras provider-defined Bundle argument.  May be null.\n     * @return a result Bundle, possibly null.  Will be null if the ContentProvider\n     *   does not implement call.\n     * @throws NullPointerException if uri or method is null\n     * @throws IllegalArgumentException if uri is not known\n     ",
    "links" : [ ]
  }, {
    "name" : "public final Bundle call(@NonNull String authority, @NonNull String method, @Nullable String arg, @Nullable Bundle extras)",
    "returnType" : "Bundle",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public final IContentProvider acquireProvider(Uri uri)",
    "returnType" : "IContentProvider",
    "comment" : "\n     * Returns the content provider for the given content URI.\n     *\n     * @param uri The URI to a content provider\n     * @return The ContentProvider for the given URI, or null if no content provider is found.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public final IContentProvider acquireExistingProvider(Uri uri)",
    "returnType" : "IContentProvider",
    "comment" : "\n     * Returns the content provider for the given content URI if the process\n     * already has a reference on it.\n     *\n     * @param uri The URI to a content provider\n     * @return The ContentProvider for the given URI, or null if no content provider is found.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public final IContentProvider acquireProvider(String name)",
    "returnType" : "IContentProvider",
    "comment" : "\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public final IContentProvider acquireUnstableProvider(Uri uri)",
    "returnType" : "IContentProvider",
    "comment" : "\n     * Returns the content provider for the given content URI.\n     *\n     * @param uri The URI to a content provider\n     * @return The ContentProvider for the given URI, or null if no content provider is found.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public final IContentProvider acquireUnstableProvider(String name)",
    "returnType" : "IContentProvider",
    "comment" : "\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public final ContentProviderClient acquireContentProviderClient(@NonNull Uri uri)",
    "returnType" : "ContentProviderClient",
    "comment" : "\n     * Returns a {@link ContentProviderClient} that is associated with the {@link ContentProvider}\n     * that services the content at uri, starting the provider if necessary. Returns\n     * null if there is no provider associated wih the uri. The caller must indicate that they are\n     * done with the provider by calling {@link ContentProviderClient#release} which will allow\n     * the system to release the provider if it determines that there is no other reason for\n     * keeping it active.\n     * @param uri specifies which provider should be acquired\n     * @return a {@link ContentProviderClient} that is associated with the {@link ContentProvider}\n     * that services the content at uri or null if there isn't one.\n     ",
    "links" : [ "android.content.ContentProviderClient#release", "android.content.ContentProviderClient", "android.content.ContentProvider" ]
  }, {
    "name" : "public final ContentProviderClient acquireContentProviderClient(@NonNull String name)",
    "returnType" : "ContentProviderClient",
    "comment" : "\n     * Returns a {@link ContentProviderClient} that is associated with the {@link ContentProvider}\n     * with the authority of name, starting the provider if necessary. Returns\n     * null if there is no provider associated wih the uri. The caller must indicate that they are\n     * done with the provider by calling {@link ContentProviderClient#release} which will allow\n     * the system to release the provider if it determines that there is no other reason for\n     * keeping it active.\n     * @param name specifies which provider should be acquired\n     * @return a {@link ContentProviderClient} that is associated with the {@link ContentProvider}\n     * with the authority of name or null if there isn't one.\n     ",
    "links" : [ "android.content.ContentProviderClient#release", "android.content.ContentProviderClient", "android.content.ContentProvider" ]
  }, {
    "name" : "public final ContentProviderClient acquireUnstableContentProviderClient(@NonNull Uri uri)",
    "returnType" : "ContentProviderClient",
    "comment" : "\n     * Like {@link #acquireContentProviderClient(Uri)}, but for use when you do\n     * not trust the stability of the target content provider.  This turns off\n     * the mechanism in the platform clean up processes that are dependent on\n     * a content provider if that content provider's process goes away.  Normally\n     * you can safely assume that once you have acquired a provider, you can freely\n     * use it as needed and it won't disappear, even if your process is in the\n     * background.  If using this method, you need to take care to deal with any\n     * failures when communicating with the provider, and be sure to close it\n     * so that it can be re-opened later.  In particular, catching a\n     * {@link android.os.DeadObjectException} from the calls there will let you\n     * know that the content provider has gone away; at that point the current\n     * ContentProviderClient object is invalid, and you should release it.  You\n     * can acquire a new one if you would like to try to restart the provider\n     * and perform new operations on it.\n     ",
    "links" : [ "#acquireContentProviderClient(Uri)", "android.os.DeadObjectException" ]
  }, {
    "name" : "public final ContentProviderClient acquireUnstableContentProviderClient(@NonNull String name)",
    "returnType" : "ContentProviderClient",
    "comment" : "\n     * Like {@link #acquireContentProviderClient(String)}, but for use when you do\n     * not trust the stability of the target content provider.  This turns off\n     * the mechanism in the platform clean up processes that are dependent on\n     * a content provider if that content provider's process goes away.  Normally\n     * you can safely assume that once you have acquired a provider, you can freely\n     * use it as needed and it won't disappear, even if your process is in the\n     * background.  If using this method, you need to take care to deal with any\n     * failures when communicating with the provider, and be sure to close it\n     * so that it can be re-opened later.  In particular, catching a\n     * {@link android.os.DeadObjectException} from the calls there will let you\n     * know that the content provider has gone away; at that point the current\n     * ContentProviderClient object is invalid, and you should release it.  You\n     * can acquire a new one if you would like to try to restart the provider\n     * and perform new operations on it.\n     ",
    "links" : [ "#acquireContentProviderClient(String)", "android.os.DeadObjectException" ]
  }, {
    "name" : "public final void registerContentObserver(@NonNull Uri uri, boolean notifyForDescendants, @NonNull ContentObserver observer)",
    "returnType" : "void",
    "comment" : "\n     * Register an observer class that gets callbacks when data identified by a\n     * given content URI changes.\n     * <p>\n     * Starting in {@link android.os.Build.VERSION_CODES#O}, all content\n     * notifications must be backed by a valid {@link ContentProvider}.\n     *\n     * @param uri The URI to watch for changes. This can be a specific row URI,\n     *            or a base URI for a whole class of content.\n     * @param notifyForDescendants When false, the observer will be notified\n     *            whenever a change occurs to the exact URI specified by\n     *            <code>uri</code> or to one of the URI's ancestors in the path\n     *            hierarchy. When true, the observer will also be notified\n     *            whenever a change occurs to the URI's descendants in the path\n     *            hierarchy.\n     * @param observer The object that receives callbacks when changes occur.\n     * @see #unregisterContentObserver\n     ",
    "links" : [ "android.os.Build.VERSION_CODES#O", "android.content.ContentProvider" ]
  }, {
    "name" : "public final void registerContentObserverAsUser(@NonNull Uri uri, boolean notifyForDescendants, @NonNull ContentObserver observer, @NonNull UserHandle userHandle)",
    "returnType" : "void",
    "comment" : "\n     * Same as {@link #registerContentObserver(Uri, boolean, ContentObserver)}, but the observer\n     * registered will get content change notifications for the specified user.\n     * {@link ContentObserver#onChange(boolean, Collection, int, UserHandle)} should be\n     * overwritten to get the corresponding {@link UserHandle} for that notification.\n     *\n     * <p> If you don't hold the {@link android.Manifest.permission#INTERACT_ACROSS_USERS_FULL}\n     * permission, you can register the {@link ContentObserver} only for current user.\n     *\n     * @param uri                  The URI to watch for changes. This can be a specific row URI,\n     *                             or a base URI for a whole class of content.\n     * @param notifyForDescendants When false, the observer will be notified\n     *                             whenever a change occurs to the exact URI specified by\n     *                             <code>uri</code> or to one of the URI's ancestors in the path\n     *                             hierarchy. When true, the observer will also be notified\n     *                             whenever a change occurs to the URI's descendants in the path\n     *                             hierarchy.\n     * @param observer             The object that receives callbacks when changes occur.\n     * @param userHandle           The UserHandle of the user the content change notifications are\n     *                             for.\n     * @hide\n     * @see #unregisterContentObserver\n     ",
    "links" : [ "android.database.ContentObserver#onChange(boolean", "android.Manifest.permission#INTERACT_ACROSS_USERS_FULL", "#registerContentObserver(Uri", "android.os.UserHandle", "android.database.ContentObserver" ]
  }, {
    "name" : "public final void registerContentObserver(Uri uri, boolean notifyForDescendents, ContentObserver observer, @UserIdInt int userHandle)",
    "returnType" : "void",
    "comment" : " @hide - designated user version ",
    "links" : [ ]
  }, {
    "name" : "public final void unregisterContentObserver(@NonNull ContentObserver observer)",
    "returnType" : "void",
    "comment" : "\n     * Unregisters a change observer.\n     *\n     * @param observer The previously registered observer that is no longer needed.\n     * @see #registerContentObserver\n     ",
    "links" : [ ]
  }, {
    "name" : "public void notifyChange(@NonNull Uri uri, @Nullable ContentObserver observer)",
    "returnType" : "void",
    "comment" : "\n     * Notify registered observers that a row was updated and attempt to sync\n     * changes to the network.\n     * <p>\n     * To observe events sent through this call, use\n     * {@link #registerContentObserver(Uri, boolean, ContentObserver)}.\n     * <p>\n     * Starting in {@link android.os.Build.VERSION_CODES#O}, all content\n     * notifications must be backed by a valid {@link ContentProvider}.\n     *\n     * @param uri The uri of the content that was changed.\n     * @param observer The observer that originated the change, may be\n     *            <code>null</null>. The observer that originated the change\n     *            will only receive the notification if it has requested to\n     *            receive self-change notifications by implementing\n     *            {@link ContentObserver#deliverSelfNotifications()} to return\n     *            true.\n     ",
    "links" : [ "android.os.Build.VERSION_CODES#O", "#registerContentObserver(Uri", "android.database.ContentObserver#deliverSelfNotifications()", "android.content.ContentProvider" ]
  }, {
    "name" : "public void notifyChange(@NonNull Uri uri, @Nullable ContentObserver observer, boolean syncToNetwork)",
    "returnType" : "void",
    "comment" : "\n     * Notify registered observers that a row was updated.\n     * <p>\n     * To observe events sent through this call, use\n     * {@link #registerContentObserver(Uri, boolean, ContentObserver)}.\n     * <p>\n     * If syncToNetwork is true, this will attempt to schedule a local sync\n     * using the sync adapter that's registered for the authority of the\n     * provided uri. No account will be passed to the sync adapter, so all\n     * matching accounts will be synchronized.\n     * <p>\n     * Starting in {@link android.os.Build.VERSION_CODES#O}, all content\n     * notifications must be backed by a valid {@link ContentProvider}.\n     *\n     * @param uri The uri of the content that was changed.\n     * @param observer The observer that originated the change, may be\n     *            <code>null</null>. The observer that originated the change\n     *            will only receive the notification if it has requested to\n     *            receive self-change notifications by implementing\n     *            {@link ContentObserver#deliverSelfNotifications()} to return\n     *            true.\n     * @param syncToNetwork If true, same as {@link #NOTIFY_SYNC_TO_NETWORK}.\n     * @see #requestSync(android.accounts.Account, String, android.os.Bundle)\n     * @deprecated callers should consider migrating to\n     *             {@link #notifyChange(Uri, ContentObserver, int)}, as it\n     *             offers support for many more options than just\n     *             {@link #NOTIFY_SYNC_TO_NETWORK}.\n     ",
    "links" : [ "android.os.Build.VERSION_CODES#O", "#NOTIFY_SYNC_TO_NETWORK", "#notifyChange(Uri", "#registerContentObserver(Uri", "android.database.ContentObserver#deliverSelfNotifications()", "android.content.ContentProvider" ]
  }, {
    "name" : "public void notifyChange(@NonNull Uri uri, @Nullable ContentObserver observer, @NotifyFlags int flags)",
    "returnType" : "void",
    "comment" : "\n     * Notify registered observers that a row was updated.\n     * <p>\n     * To observe events sent through this call, use\n     * {@link #registerContentObserver(Uri, boolean, ContentObserver)}.\n     * <p>\n     * If {@link #NOTIFY_SYNC_TO_NETWORK} is set, this will attempt to schedule\n     * a local sync using the sync adapter that's registered for the authority\n     * of the provided uri. No account will be passed to the sync adapter, so\n     * all matching accounts will be synchronized.\n     * <p>\n     * Starting in {@link android.os.Build.VERSION_CODES#O}, all content\n     * notifications must be backed by a valid {@link ContentProvider}.\n     *\n     * @param uri The uri of the content that was changed.\n     * @param observer The observer that originated the change, may be\n     *            <code>null</null>. The observer that originated the change\n     *            will only receive the notification if it has requested to\n     *            receive self-change notifications by implementing\n     *            {@link ContentObserver#deliverSelfNotifications()} to return\n     *            true.\n     * @param flags Additional flags: {@link #NOTIFY_SYNC_TO_NETWORK}.\n     * @see #requestSync(android.accounts.Account, String, android.os.Bundle)\n     ",
    "links" : [ "android.os.Build.VERSION_CODES#O", "#NOTIFY_SYNC_TO_NETWORK", "#registerContentObserver(Uri", "android.database.ContentObserver#deliverSelfNotifications()", "android.content.ContentProvider" ]
  }, {
    "name" : "public void notifyChange(@NonNull Iterable<Uri> uris, @Nullable ContentObserver observer, @NotifyFlags int flags)",
    "returnType" : "void",
    "comment" : " @removed ",
    "links" : [ ]
  }, {
    "name" : "public void notifyChange(@NonNull Collection<Uri> uris, @Nullable ContentObserver observer, @NotifyFlags int flags)",
    "returnType" : "void",
    "comment" : "\n     * Notify registered observers that several rows have been updated.\n     * <p>\n     * To observe events sent through this call, use\n     * {@link #registerContentObserver(Uri, boolean, ContentObserver)}.\n     * <p>\n     * If {@link #NOTIFY_SYNC_TO_NETWORK} is set, this will attempt to schedule\n     * a local sync using the sync adapter that's registered for the authority\n     * of the provided uri. No account will be passed to the sync adapter, so\n     * all matching accounts will be synchronized.\n     * <p>\n     * Starting in {@link android.os.Build.VERSION_CODES#O}, all content\n     * notifications must be backed by a valid {@link ContentProvider}.\n     *\n     * @param uris The uris of the content that was changed.\n     * @param observer The observer that originated the change, may be\n     *            <code>null</null>. The observer that originated the change\n     *            will only receive the notification if it has requested to\n     *            receive self-change notifications by implementing\n     *            {@link ContentObserver#deliverSelfNotifications()} to return\n     *            true.\n     * @param flags Flags such as {@link #NOTIFY_SYNC_TO_NETWORK} or\n     *            {@link #NOTIFY_SKIP_NOTIFY_FOR_DESCENDANTS}.\n     ",
    "links" : [ "android.os.Build.VERSION_CODES#O", "#NOTIFY_SYNC_TO_NETWORK", "#registerContentObserver(Uri", "#NOTIFY_SKIP_NOTIFY_FOR_DESCENDANTS", "android.database.ContentObserver#deliverSelfNotifications()", "android.content.ContentProvider" ]
  }, {
    "name" : "public void notifyChange(@NonNull Uri uri, ContentObserver observer, boolean syncToNetwork, @UserIdInt int userHandle)",
    "returnType" : "void",
    "comment" : "\n     * Notify registered observers within the designated user(s) that a row was updated.\n     *\n     * @deprecated callers should consider migrating to\n     *             {@link #notifyChange(Uri, ContentObserver, int)}, as it\n     *             offers support for many more options than just\n     *             {@link #NOTIFY_SYNC_TO_NETWORK}.\n     * @hide\n     ",
    "links" : [ "#notifyChange(Uri", "#NOTIFY_SYNC_TO_NETWORK" ]
  }, {
    "name" : "public void notifyChange(@NonNull Uri uri, ContentObserver observer, @NotifyFlags int flags, @UserIdInt int userHandle)",
    "returnType" : "void",
    "comment" : " {@hide} ",
    "links" : [ ]
  }, {
    "name" : "public void notifyChange(@NonNull Uri[] uris, ContentObserver observer, @NotifyFlags int flags, @UserIdInt int userHandle)",
    "returnType" : "void",
    "comment" : "\n     * Notify registered observers within the designated user(s) that a row was updated.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public void takePersistableUriPermission(@NonNull Uri uri, @Intent.AccessUriMode int modeFlags)",
    "returnType" : "void",
    "comment" : "\n     * Take a persistable URI permission grant that has been offered. Once\n     * taken, the permission grant will be remembered across device reboots.\n     * Only URI permissions granted with\n     * {@link Intent#FLAG_GRANT_PERSISTABLE_URI_PERMISSION} can be persisted. If\n     * the grant has already been persisted, taking it again will touch\n     * {@link UriPermission#getPersistedTime()}.\n     *\n     * @see #getPersistedUriPermissions()\n     ",
    "links" : [ "android.content.UriPermission#getPersistedTime()", "android.content.Intent#FLAG_GRANT_PERSISTABLE_URI_PERMISSION" ]
  }, {
    "name" : "public void takePersistableUriPermission(@NonNull String toPackage, @NonNull Uri uri, @Intent.AccessUriMode int modeFlags)",
    "returnType" : "void",
    "comment" : "\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public void releasePersistableUriPermission(@NonNull Uri uri, @Intent.AccessUriMode int modeFlags)",
    "returnType" : "void",
    "comment" : "\n     * Relinquish a persisted URI permission grant. The URI must have been\n     * previously made persistent with\n     * {@link #takePersistableUriPermission(Uri, int)}. Any non-persistent\n     * grants to the calling package will remain intact.\n     *\n     * @see #getPersistedUriPermissions()\n     ",
    "links" : [ "#takePersistableUriPermission(Uri" ]
  }, {
    "name" : "public List<UriPermission> getPersistedUriPermissions()",
    "returnType" : "List<UriPermission>",
    "comment" : "\n     * Return list of all URI permission grants that have been persisted by the\n     * calling app. That is, the returned permissions have been granted\n     * <em>to</em> the calling app. Only persistable grants taken with\n     * {@link #takePersistableUriPermission(Uri, int)} are returned.\n     * <p>Note: Some of the returned URIs may not be usable until after the user is unlocked.\n     *\n     * @see #takePersistableUriPermission(Uri, int)\n     * @see #releasePersistableUriPermission(Uri, int)\n     ",
    "links" : [ "#takePersistableUriPermission(Uri" ]
  }, {
    "name" : "public List<UriPermission> getOutgoingPersistedUriPermissions()",
    "returnType" : "List<UriPermission>",
    "comment" : "\n     * Return list of all persisted URI permission grants that are hosted by the\n     * calling app. That is, the returned permissions have been granted\n     * <em>from</em> the calling app. Only grants taken with\n     * {@link #takePersistableUriPermission(Uri, int)} are returned.\n     * <p>Note: Some of the returned URIs may not be usable until after the user is unlocked.\n     ",
    "links" : [ "#takePersistableUriPermission(Uri" ]
  }, {
    "name" : "public List<UriPermission> getOutgoingUriPermissions()",
    "returnType" : "List<UriPermission>",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "public void startSync(Uri uri, Bundle extras)",
    "returnType" : "void",
    "comment" : "\n     * Start an asynchronous sync operation. If you want to monitor the progress\n     * of the sync you may register a SyncObserver. Only values of the following\n     * types may be used in the extras bundle:\n     * <ul>\n     * <li>Integer</li>\n     * <li>Long</li>\n     * <li>Boolean</li>\n     * <li>Float</li>\n     * <li>Double</li>\n     * <li>String</li>\n     * <li>Account</li>\n     * <li>null</li>\n     * </ul>\n     *\n     * @param uri the uri of the provider to sync or null to sync all providers.\n     * @param extras any extras to pass to the SyncAdapter.\n     * @deprecated instead use\n     * {@link #requestSync(android.accounts.Account, String, android.os.Bundle)}\n     ",
    "links" : [ "#requestSync(android.accounts.Account" ]
  }, {
    "name" : "public static void requestSync(Account account, String authority, Bundle extras)",
    "returnType" : "void",
    "comment" : "\n     * Start an asynchronous sync operation. If you want to monitor the progress\n     * of the sync you may register a SyncObserver. Only values of the following\n     * types may be used in the extras bundle:\n     * <ul>\n     * <li>Integer</li>\n     * <li>Long</li>\n     * <li>Boolean</li>\n     * <li>Float</li>\n     * <li>Double</li>\n     * <li>String</li>\n     * <li>Account</li>\n     * <li>null</li>\n     * </ul>\n     *\n     * @param account which account should be synced\n     * @param authority which authority should be synced\n     * @param extras any extras to pass to the SyncAdapter.\n     ",
    "links" : [ ]
  }, {
    "name" : "public static void requestSyncAsUser(Account account, String authority, @UserIdInt int userId, Bundle extras)",
    "returnType" : "void",
    "comment" : "\n     * @see #requestSync(Account, String, Bundle)\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public static void requestSync(SyncRequest request)",
    "returnType" : "void",
    "comment" : "\n     * Register a sync with the SyncManager. These requests are built using the\n     * {@link SyncRequest.Builder}.\n     ",
    "links" : [ "SyncRequest.Builder" ]
  }, {
    "name" : "public static void validateSyncExtrasBundle(Bundle extras)",
    "returnType" : "void",
    "comment" : "\n     * Check that only values of the following types are in the Bundle:\n     * <ul>\n     * <li>Integer</li>\n     * <li>Long</li>\n     * <li>Boolean</li>\n     * <li>Float</li>\n     * <li>Double</li>\n     * <li>String</li>\n     * <li>Account</li>\n     * <li>null</li>\n     * </ul>\n     * @param extras the Bundle to check\n     ",
    "links" : [ ]
  }, {
    "name" : "public void cancelSync(Uri uri)",
    "returnType" : "void",
    "comment" : "\n     * Cancel any active or pending syncs that match the Uri. If the uri is null then\n     * all syncs will be canceled.\n     *\n     * @param uri the uri of the provider to sync or null to sync all providers.\n     * @deprecated instead use {@link #cancelSync(android.accounts.Account, String)}\n     ",
    "links" : [ "#cancelSync(android.accounts.Account" ]
  }, {
    "name" : "public static void cancelSync(Account account, String authority)",
    "returnType" : "void",
    "comment" : "\n     * Cancel any active or pending syncs that match account and authority. The account and\n     * authority can each independently be set to null, which means that syncs with any account\n     * or authority, respectively, will match.\n     *\n     * @param account filters the syncs that match by this account\n     * @param authority filters the syncs that match by this authority\n     ",
    "links" : [ ]
  }, {
    "name" : "public static void cancelSyncAsUser(Account account, String authority, @UserIdInt int userId)",
    "returnType" : "void",
    "comment" : "\n     * @see #cancelSync(Account, String)\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public static SyncAdapterType[] getSyncAdapterTypes()",
    "returnType" : "SyncAdapterType[]",
    "comment" : "\n     * Get information about the SyncAdapters that are known to the system.\n     * @return an array of SyncAdapters that have registered with the system\n     ",
    "links" : [ ]
  }, {
    "name" : "public static SyncAdapterType[] getSyncAdapterTypesAsUser(@UserIdInt int userId)",
    "returnType" : "SyncAdapterType[]",
    "comment" : "\n     * @see #getSyncAdapterTypes()\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public static String[] getSyncAdapterPackagesForAuthorityAsUser(String authority, @UserIdInt int userId)",
    "returnType" : "String[]",
    "comment" : "\n     * @hide\n     * Returns the package names of syncadapters that match a given user and authority.\n     ",
    "links" : [ ]
  }, {
    "name" : "public static String getSyncAdapterPackageAsUser(@NonNull String accountType, @NonNull String authority, @UserIdInt int userId)",
    "returnType" : "String",
    "comment" : "\n     * Returns the package name of the syncadapter that matches a given account type, authority\n     * and user.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public static boolean getSyncAutomatically(Account account, String authority)",
    "returnType" : "boolean",
    "comment" : "\n     * Check if the provider should be synced when a network tickle is received\n     * <p>This method requires the caller to hold the permission\n     * {@link android.Manifest.permission#READ_SYNC_SETTINGS}.\n     *\n     * @param account the account whose setting we are querying\n     * @param authority the provider whose setting we are querying\n     * @return true if the provider should be synced when a network tickle is received\n     ",
    "links" : [ "android.Manifest.permission#READ_SYNC_SETTINGS" ]
  }, {
    "name" : "public static boolean getSyncAutomaticallyAsUser(Account account, String authority, @UserIdInt int userId)",
    "returnType" : "boolean",
    "comment" : "\n     * @see #getSyncAutomatically(Account, String)\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public static void setSyncAutomatically(Account account, String authority, boolean sync)",
    "returnType" : "void",
    "comment" : "\n     * Set whether or not the provider is synced when it receives a network tickle.\n     * <p>This method requires the caller to hold the permission\n     * {@link android.Manifest.permission#WRITE_SYNC_SETTINGS}.\n     *\n     * @param account the account whose setting we are querying\n     * @param authority the provider whose behavior is being controlled\n     * @param sync true if the provider should be synced when tickles are received for it\n     ",
    "links" : [ "android.Manifest.permission#WRITE_SYNC_SETTINGS" ]
  }, {
    "name" : "public static void setSyncAutomaticallyAsUser(Account account, String authority, boolean sync, @UserIdInt int userId)",
    "returnType" : "void",
    "comment" : "\n     * @see #setSyncAutomatically(Account, String, boolean)\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public static boolean hasInvalidScheduleAsEjExtras(Bundle extras)",
    "returnType" : "boolean",
    "comment" : "\n     * {@hide}\n     * Helper function to throw an <code>IllegalArgumentException</code> if any illegal\n     * extras were set for a sync scheduled as an expedited job.\n     *\n     * @param extras bundle to validate.\n     ",
    "links" : [ ]
  }, {
    "name" : "public static void addPeriodicSync(Account account, String authority, Bundle extras, long pollFrequency)",
    "returnType" : "void",
    "comment" : "\n     * Specifies that a sync should be requested with the specified the account, authority,\n     * and extras at the given frequency. If there is already another periodic sync scheduled\n     * with the account, authority and extras then a new periodic sync won't be added, instead\n     * the frequency of the previous one will be updated.\n     * <p>\n     * These periodic syncs honor the \"syncAutomatically\" and \"masterSyncAutomatically\" settings.\n     * Although these sync are scheduled at the specified frequency, it may take longer for it to\n     * actually be started if other syncs are ahead of it in the sync operation queue. This means\n     * that the actual start time may drift.\n     * <p>\n     * Periodic syncs are not allowed to have any of {@link #SYNC_EXTRAS_DO_NOT_RETRY},\n     * {@link #SYNC_EXTRAS_IGNORE_BACKOFF}, {@link #SYNC_EXTRAS_IGNORE_SETTINGS},\n     * {@link #SYNC_EXTRAS_INITIALIZE}, {@link #SYNC_EXTRAS_FORCE},\n     * {@link #SYNC_EXTRAS_EXPEDITED}, {@link #SYNC_EXTRAS_MANUAL},\n     * {@link #SYNC_EXTRAS_SCHEDULE_AS_EXPEDITED_JOB} set to true.\n     * If any are supplied then an {@link IllegalArgumentException} will be thrown.\n     *\n     * <p>This method requires the caller to hold the permission\n     * {@link android.Manifest.permission#WRITE_SYNC_SETTINGS}.\n     * <p>The bundle for a periodic sync can be queried by applications with the correct\n     * permissions using\n     * {@link ContentResolver#getPeriodicSyncs(Account account, String provider)}, so no\n     * sensitive data should be transferred here.\n     *\n     * @param account the account to specify in the sync\n     * @param authority the provider to specify in the sync request\n     * @param extras extra parameters to go along with the sync request\n     * @param pollFrequency how frequently the sync should be performed, in seconds.\n     * On Android API level 24 and above, a minimum interval of 15 minutes is enforced.\n     * On previous versions, the minimum interval is 1 hour.\n     * @throws IllegalArgumentException if an illegal extra was set or if any of the parameters\n     * are null.\n     ",
    "links" : [ "#SYNC_EXTRAS_SCHEDULE_AS_EXPEDITED_JOB", "#SYNC_EXTRAS_FORCE", "android.Manifest.permission#WRITE_SYNC_SETTINGS", "#SYNC_EXTRAS_MANUAL", "#SYNC_EXTRAS_EXPEDITED", "android.content.ContentResolver#getPeriodicSyncs(Account", "#SYNC_EXTRAS_INITIALIZE", "#SYNC_EXTRAS_IGNORE_BACKOFF", "IllegalArgumentException", "#SYNC_EXTRAS_DO_NOT_RETRY", "#SYNC_EXTRAS_IGNORE_SETTINGS" ]
  }, {
    "name" : "public static boolean invalidPeriodicExtras(Bundle extras)",
    "returnType" : "boolean",
    "comment" : "\n     * {@hide}\n     * Helper function to throw an <code>IllegalArgumentException</code> if any illegal\n     * extras were set for a periodic sync.\n     *\n     * @param extras bundle to validate.\n     ",
    "links" : [ ]
  }, {
    "name" : "public static void removePeriodicSync(Account account, String authority, Bundle extras)",
    "returnType" : "void",
    "comment" : "\n     * Remove a periodic sync. Has no affect if account, authority and extras don't match\n     * an existing periodic sync.\n     * <p>This method requires the caller to hold the permission\n     * {@link android.Manifest.permission#WRITE_SYNC_SETTINGS}.\n     *\n     * @param account the account of the periodic sync to remove\n     * @param authority the provider of the periodic sync to remove\n     * @param extras the extras of the periodic sync to remove\n     ",
    "links" : [ "android.Manifest.permission#WRITE_SYNC_SETTINGS" ]
  }, {
    "name" : "public static void cancelSync(SyncRequest request)",
    "returnType" : "void",
    "comment" : "\n     * Remove the specified sync. This will cancel any pending or active syncs. If the request is\n     * for a periodic sync, this call will remove any future occurrences.\n     * <p>\n     *     If a periodic sync is specified, the caller must hold the permission\n     *     {@link android.Manifest.permission#WRITE_SYNC_SETTINGS}.\n     *</p>\n     * It is possible to cancel a sync using a SyncRequest object that is not the same object\n     * with which you requested the sync. Do so by building a SyncRequest with the same\n     * adapter, frequency, <b>and</b> extras bundle.\n     *\n     * @param request SyncRequest object containing information about sync to cancel.\n     ",
    "links" : [ "android.Manifest.permission#WRITE_SYNC_SETTINGS" ]
  }, {
    "name" : "public static List<PeriodicSync> getPeriodicSyncs(Account account, String authority)",
    "returnType" : "List<PeriodicSync>",
    "comment" : "\n     * Get the list of information about the periodic syncs for the given account and authority.\n     * <p>This method requires the caller to hold the permission\n     * {@link android.Manifest.permission#READ_SYNC_SETTINGS}.\n     *\n     * @param account the account whose periodic syncs we are querying\n     * @param authority the provider whose periodic syncs we are querying\n     * @return a list of PeriodicSync objects. This list may be empty but will never be null.\n     ",
    "links" : [ "android.Manifest.permission#READ_SYNC_SETTINGS" ]
  }, {
    "name" : "public static int getIsSyncable(Account account, String authority)",
    "returnType" : "int",
    "comment" : "\n     * Check if this account/provider is syncable.\n     * <p>This method requires the caller to hold the permission\n     * {@link android.Manifest.permission#READ_SYNC_SETTINGS}.\n     * @return >0 if it is syncable, 0 if not, and <0 if the state isn't known yet.\n     ",
    "links" : [ "android.Manifest.permission#READ_SYNC_SETTINGS" ]
  }, {
    "name" : "public static int getIsSyncableAsUser(Account account, String authority, @UserIdInt int userId)",
    "returnType" : "int",
    "comment" : "\n     * @see #getIsSyncable(Account, String)\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public static void setIsSyncable(Account account, String authority, int syncable)",
    "returnType" : "void",
    "comment" : "\n     * Set whether this account/provider is syncable.\n     * <p>This method requires the caller to hold the permission\n     * {@link android.Manifest.permission#WRITE_SYNC_SETTINGS}.\n     * @param syncable >0 denotes syncable, 0 means not syncable, <0 means unknown\n     ",
    "links" : [ "android.Manifest.permission#WRITE_SYNC_SETTINGS" ]
  }, {
    "name" : "public static void setIsSyncableAsUser(Account account, String authority, int syncable, int userId)",
    "returnType" : "void",
    "comment" : "\n     * @see #setIsSyncable(Account, String, int)\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public static boolean getMasterSyncAutomatically()",
    "returnType" : "boolean",
    "comment" : "\n     * Gets the global auto-sync setting that applies to all the providers and accounts.\n     * If this is false then the per-provider auto-sync setting is ignored.\n     * <p>This method requires the caller to hold the permission\n     * {@link android.Manifest.permission#READ_SYNC_SETTINGS}.\n     *\n     * @return the global auto-sync setting that applies to all the providers and accounts\n     ",
    "links" : [ "android.Manifest.permission#READ_SYNC_SETTINGS" ]
  }, {
    "name" : "public static boolean getMasterSyncAutomaticallyAsUser(@UserIdInt int userId)",
    "returnType" : "boolean",
    "comment" : "\n     * @see #getMasterSyncAutomatically()\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public static void setMasterSyncAutomatically(boolean sync)",
    "returnType" : "void",
    "comment" : "\n     * Sets the global auto-sync setting that applies to all the providers and accounts.\n     * If this is false then the per-provider auto-sync setting is ignored.\n     * <p>This method requires the caller to hold the permission\n     * {@link android.Manifest.permission#WRITE_SYNC_SETTINGS}.\n     *\n     * @param sync the global auto-sync setting that applies to all the providers and accounts\n     ",
    "links" : [ "android.Manifest.permission#WRITE_SYNC_SETTINGS" ]
  }, {
    "name" : "public static void setMasterSyncAutomaticallyAsUser(boolean sync, @UserIdInt int userId)",
    "returnType" : "void",
    "comment" : "\n     * @see #setMasterSyncAutomatically(boolean)\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public static boolean isSyncActive(Account account, String authority)",
    "returnType" : "boolean",
    "comment" : "\n     * Returns true if there is currently a sync operation for the given account or authority\n     * actively being processed.\n     * <p>This method requires the caller to hold the permission\n     * {@link android.Manifest.permission#READ_SYNC_STATS}.\n     * @param account the account whose setting we are querying\n     * @param authority the provider whose behavior is being queried\n     * @return true if a sync is active for the given account or authority.\n     ",
    "links" : [ "android.Manifest.permission#READ_SYNC_STATS" ]
  }, {
    "name" : "public static SyncInfo getCurrentSync()",
    "returnType" : "SyncInfo",
    "comment" : "\n     * If a sync is active returns the information about it, otherwise returns null.\n     * <p>\n     * This method requires the caller to hold the permission\n     * {@link android.Manifest.permission#READ_SYNC_STATS}.\n     * <p>\n     * @return the SyncInfo for the currently active sync or null if one is not active.\n     * @deprecated\n     * Since multiple concurrent syncs are now supported you should use\n     * {@link #getCurrentSyncs()} to get the accurate list of current syncs.\n     * This method returns the first item from the list of current syncs\n     * or null if there are none.\n     ",
    "links" : [ "android.Manifest.permission#READ_SYNC_STATS", "#getCurrentSyncs()" ]
  }, {
    "name" : "public static List<SyncInfo> getCurrentSyncs()",
    "returnType" : "List<SyncInfo>",
    "comment" : "\n     * Returns a list with information about all the active syncs. This list will be empty\n     * if there are no active syncs.\n     * <p>\n     * This method requires the caller to hold the permission\n     * {@link android.Manifest.permission#READ_SYNC_STATS}.\n     * <p>\n     * @return a List of SyncInfo objects for the currently active syncs.\n     ",
    "links" : [ "android.Manifest.permission#READ_SYNC_STATS" ]
  }, {
    "name" : "public static List<SyncInfo> getCurrentSyncsAsUser(@UserIdInt int userId)",
    "returnType" : "List<SyncInfo>",
    "comment" : "\n     * @see #getCurrentSyncs()\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public static SyncStatusInfo getSyncStatus(Account account, String authority)",
    "returnType" : "SyncStatusInfo",
    "comment" : "\n     * Returns the status that matches the authority.\n     * @param account the account whose setting we are querying\n     * @param authority the provider whose behavior is being queried\n     * @return the SyncStatusInfo for the authority, or null if none exists\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public static SyncStatusInfo getSyncStatusAsUser(Account account, String authority, @UserIdInt int userId)",
    "returnType" : "SyncStatusInfo",
    "comment" : "\n     * @see #getSyncStatus(Account, String)\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public static boolean isSyncPending(Account account, String authority)",
    "returnType" : "boolean",
    "comment" : "\n     * Return true if the pending status is true of any matching authorities.\n     * <p>This method requires the caller to hold the permission\n     * {@link android.Manifest.permission#READ_SYNC_STATS}.\n     * @param account the account whose setting we are querying\n     * @param authority the provider whose behavior is being queried\n     * @return true if there is a pending sync with the matching account and authority\n     ",
    "links" : [ "android.Manifest.permission#READ_SYNC_STATS" ]
  }, {
    "name" : "public static boolean isSyncPendingAsUser(Account account, String authority, @UserIdInt int userId)",
    "returnType" : "boolean",
    "comment" : "\n     * @see #requestSync(Account, String, Bundle)\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public static Object addStatusChangeListener(int mask, final SyncStatusObserver callback)",
    "returnType" : "Object",
    "comment" : "\n     * Request notifications when the different aspects of the SyncManager change. The\n     * different items that can be requested are:\n     * <ul>\n     * <li> {@link #SYNC_OBSERVER_TYPE_PENDING}\n     * <li> {@link #SYNC_OBSERVER_TYPE_ACTIVE}\n     * <li> {@link #SYNC_OBSERVER_TYPE_SETTINGS}\n     * </ul>\n     * The caller can set one or more of the status types in the mask for any\n     * given listener registration.\n     * @param mask the status change types that will cause the callback to be invoked\n     * @param callback observer to be invoked when the status changes\n     * @return a handle that can be used to remove the listener at a later time\n     ",
    "links" : [ "#SYNC_OBSERVER_TYPE_ACTIVE", "#SYNC_OBSERVER_TYPE_PENDING", "#SYNC_OBSERVER_TYPE_SETTINGS" ]
  }, {
    "name" : "public static void removeStatusChangeListener(Object handle)",
    "returnType" : "void",
    "comment" : "\n     * Remove a previously registered status change listener.\n     * @param handle the handle that was returned by {@link #addStatusChangeListener}\n     ",
    "links" : [ "#addStatusChangeListener" ]
  }, {
    "name" : "public void putCache(@NonNull Uri key, @Nullable Bundle value)",
    "returnType" : "void",
    "comment" : "\n     * Store the given {@link Bundle} as a long-lived cached object within the\n     * system. This can be useful to avoid expensive re-parsing when apps are\n     * restarted multiple times on low-RAM devices.\n     * <p>\n     * The {@link Bundle} is automatically invalidated when a\n     * {@link #notifyChange(Uri, ContentObserver)} event applies to the key.\n     *\n     * @hide\n     ",
    "links" : [ "#notifyChange(Uri", "android.os.Bundle" ]
  }, {
    "name" : "public Bundle getCache(@NonNull Uri key)",
    "returnType" : "Bundle",
    "comment" : "\n     * Retrieve the last {@link Bundle} stored as a long-lived cached object\n     * within the system.\n     *\n     * @return {@code null} if no cached object has been stored, or if the\n     *         stored object has been invalidated due to a\n     *         {@link #notifyChange(Uri, ContentObserver)} event.\n     * @hide\n     ",
    "links" : [ "#notifyChange(Uri", "android.os.Bundle" ]
  }, {
    "name" : "public int getTargetSdkVersion()",
    "returnType" : "int",
    "comment" : " {@hide} ",
    "links" : [ ]
  }, {
    "name" : "private int samplePercentForDuration(long durationMillis)",
    "returnType" : "int",
    "comment" : "\n     * Returns sampling percentage for a given duration.\n     *\n     * Always returns at least 1%.\n     ",
    "links" : [ ]
  }, {
    "name" : "private void maybeLogQueryToEventLog(long durationMillis, Uri uri, String[] projection, @Nullable Bundle queryArgs)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private void maybeLogUpdateToEventLog(long durationMillis, Uri uri, String operation, String selection)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public static IContentService getContentService()",
    "returnType" : "IContentService",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "public String getPackageName()",
    "returnType" : "String",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "public String getAttributionTag()",
    "returnType" : "String",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "public AttributionSource getAttributionSource()",
    "returnType" : "AttributionSource",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "public int resolveUserId(Uri uri)",
    "returnType" : "int",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "public int getUserId()",
    "returnType" : "int",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "public Drawable getTypeDrawable(String mimeType)",
    "returnType" : "Drawable",
    "comment" : " {@hide} ",
    "links" : [ ]
  }, {
    "name" : "public final MimeTypeInfo getTypeInfo(@NonNull String mimeType)",
    "returnType" : "MimeTypeInfo",
    "comment" : "\n     * Return a detailed description of the given MIME type, including an icon\n     * and label that describe the type.\n     *\n     * @param mimeType Valid, concrete MIME type.\n     ",
    "links" : [ ]
  }, {
    "name" : "public static Bundle createSqlQueryBundle(@Nullable String selection, @Nullable String[] selectionArgs)",
    "returnType" : "Bundle",
    "comment" : "\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public static Bundle createSqlQueryBundle(@Nullable String selection, @Nullable String[] selectionArgs, @Nullable String sortOrder)",
    "returnType" : "Bundle",
    "comment" : "\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public static Bundle includeSqlSelectionArgs(@NonNull Bundle queryArgs, @Nullable String selection, @Nullable String[] selectionArgs)",
    "returnType" : "Bundle",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "public static String createSqlSortClause(Bundle queryArgs)",
    "returnType" : "String",
    "comment" : "\n     * Returns structured sort args formatted as an SQL sort clause.\n     *\n     * NOTE: Collator clauses are suitable for use with non text fields. We might\n     * choose to omit any collation clause since we don't know the underlying\n     * type of data to be collated. Imperical testing shows that sqlite3 doesn't\n     * appear to care much about the presence of collate clauses in queries\n     * when ordering by numeric fields. For this reason we include collate\n     * clause unilaterally when {@link #QUERY_ARG_SORT_COLLATION} is present\n     * in query args bundle.\n     *\n     * TODO: Would be nice to explicitly validate that colums referenced in\n     * {@link #QUERY_ARG_SORT_COLUMNS} are present in the associated projection.\n     *\n     * @hide\n     ",
    "links" : [ "#QUERY_ARG_SORT_COLLATION", "#QUERY_ARG_SORT_COLUMNS" ]
  }, {
    "name" : "public Bitmap loadThumbnail(@NonNull Uri uri, @NonNull Size size, @Nullable CancellationSignal signal) throws IOException",
    "returnType" : "Bitmap",
    "comment" : "\n     * Convenience method that efficiently loads a visual thumbnail for the\n     * given {@link Uri}. Internally calls\n     * {@link ContentProvider#openTypedAssetFile} on the remote provider, but\n     * also defensively resizes any returned content to match the requested\n     * target size.\n     *\n     * @param uri The item that should be visualized as a thumbnail.\n     * @param size The target area on the screen where this thumbnail will be\n     *            shown. This is passed to the provider as {@link #EXTRA_SIZE}\n     *            to help it avoid downloading or generating heavy resources.\n     * @param signal A signal to cancel the operation in progress.\n     * @return Valid {@link Bitmap} which is a visual thumbnail.\n     * @throws IOException If any trouble was encountered while generating or\n     *             loading the thumbnail, or if\n     *             {@link CancellationSignal#cancel()} was invoked.\n     ",
    "links" : [ "android.graphics.Bitmap", "#EXTRA_SIZE", "android.net.Uri", "android.content.ContentProvider#openTypedAssetFile", "android.os.CancellationSignal#cancel()" ]
  }, {
    "name" : "public static Bitmap loadThumbnail(@NonNull ContentInterface content, @NonNull Uri uri, @NonNull Size size, @Nullable CancellationSignal signal, int allocator) throws IOException",
    "returnType" : "Bitmap",
    "comment" : " {@hide} ",
    "links" : [ ]
  }, {
    "name" : "public static void onDbCorruption(String tag, String message, Throwable stacktrace)",
    "returnType" : "void",
    "comment" : " {@hide} ",
    "links" : [ ]
  }, {
    "name" : "public static Uri decodeFromFile(@NonNull File file)",
    "returnType" : "Uri",
    "comment" : "\n     * Decode a path generated by {@link #encodeToFile(Uri)} back into\n     * the original {@link Uri}.\n     * <p>\n     * This is used to offer a way to intercept filesystem calls in\n     * {@link ContentProvider} unaware code and redirect them to a\n     * {@link ContentProvider} when they attempt to use {@code _DATA} columns\n     * that are otherwise deprecated.\n     *\n     * @hide\n     ",
    "links" : [ "android.net.Uri", "#encodeToFile(Uri)", "android.content.ContentProvider" ]
  }, {
    "name" : "public static File encodeToFile(@NonNull Uri uri)",
    "returnType" : "File",
    "comment" : "\n     * Encode a {@link Uri} into an opaque filesystem path which can then be\n     * resurrected by {@link #decodeFromFile(File)}.\n     * <p>\n     * This is used to offer a way to intercept filesystem calls in\n     * {@link ContentProvider} unaware code and redirect them to a\n     * {@link ContentProvider} when they attempt to use {@code _DATA} columns\n     * that are otherwise deprecated.\n     *\n     * @hide\n     ",
    "links" : [ "android.net.Uri", "#decodeFromFile(File)", "android.content.ContentProvider" ]
  }, {
    "name" : "public static Uri translateDeprecatedDataPath(@NonNull String path)",
    "returnType" : "Uri",
    "comment" : " {@hide} ",
    "links" : [ ]
  }, {
    "name" : "public static String translateDeprecatedDataPath(@NonNull Uri uri)",
    "returnType" : "String",
    "comment" : " {@hide} ",
    "links" : [ ]
  } ],
  "methodNames" : [ "public static String syncErrorToString(int error)", "public static int syncErrorStringToInt(String error)", "public static ContentResolver wrap(@NonNull ContentInterface wrapped)", "public static ContentResolver wrap(@NonNull ContentProvider wrapped)", "public static ContentResolver wrap(@NonNull ContentProviderClient wrapped)", "protected abstract IContentProvider acquireProvider(Context c, String name)", "protected IContentProvider acquireExistingProvider(Context c, String name)", "public abstract boolean releaseProvider(IContentProvider icp)", "protected abstract IContentProvider acquireUnstableProvider(Context c, String name)", "public abstract boolean releaseUnstableProvider(IContentProvider icp)", "public abstract void unstableProviderDied(IContentProvider icp)", "public void appNotRespondingViaProvider(IContentProvider icp)", "public final String getType(@NonNull Uri url)", "public String[] getStreamTypes(@NonNull Uri url, @NonNull String mimeTypeFilter)", "public final Cursor query(@RequiresPermission.Read @NonNull Uri uri, @Nullable String[] projection, @Nullable String selection, @Nullable String[] selectionArgs, @Nullable String sortOrder)", "public final Cursor query(@RequiresPermission.Read @NonNull Uri uri, @Nullable String[] projection, @Nullable String selection, @Nullable String[] selectionArgs, @Nullable String sortOrder, @Nullable CancellationSignal cancellationSignal)", "public final Cursor query(@RequiresPermission.Read @NonNull final Uri uri, @Nullable String[] projection, @Nullable Bundle queryArgs, @Nullable CancellationSignal cancellationSignal)", "public final Uri canonicalizeOrElse(@NonNull Uri uri)", "public final Uri canonicalize(@NonNull Uri url)", "public final Uri uncanonicalize(@NonNull Uri url)", "public final boolean refresh(@NonNull Uri url, @Nullable Bundle extras, @Nullable CancellationSignal cancellationSignal)", "public int checkUriPermission(@NonNull Uri uri, int uid, @Intent.AccessUriMode int modeFlags)", "public final InputStream openInputStream(@NonNull Uri uri) throws FileNotFoundException", "public final OutputStream openOutputStream(@NonNull Uri uri) throws FileNotFoundException", "public final OutputStream openOutputStream(@NonNull Uri uri, @NonNull String mode) throws FileNotFoundException", "public final ParcelFileDescriptor openFile(@NonNull Uri uri, @NonNull String mode, @Nullable CancellationSignal signal) throws FileNotFoundException", "public final ParcelFileDescriptor openFileDescriptor(@NonNull Uri uri, @NonNull String mode) throws FileNotFoundException", "public final ParcelFileDescriptor openFileDescriptor(@NonNull Uri uri, @NonNull String mode, @Nullable CancellationSignal cancellationSignal) throws FileNotFoundException", "public final AssetFileDescriptor openAssetFile(@NonNull Uri uri, @NonNull String mode, @Nullable CancellationSignal signal) throws FileNotFoundException", "public final AssetFileDescriptor openAssetFileDescriptor(@NonNull Uri uri, @NonNull String mode) throws FileNotFoundException", "public final AssetFileDescriptor openAssetFileDescriptor(@NonNull Uri uri, @NonNull String mode, @Nullable CancellationSignal cancellationSignal) throws FileNotFoundException", "public final AssetFileDescriptor openTypedAssetFile(@NonNull Uri uri, @NonNull String mimeTypeFilter, @Nullable Bundle opts, @Nullable CancellationSignal signal) throws FileNotFoundException", "public final AssetFileDescriptor openTypedAssetFileDescriptor(@NonNull Uri uri, @NonNull String mimeType, @Nullable Bundle opts) throws FileNotFoundException", "public final AssetFileDescriptor openTypedAssetFileDescriptor(@NonNull Uri uri, @NonNull String mimeType, @Nullable Bundle opts, @Nullable CancellationSignal cancellationSignal) throws FileNotFoundException", "public OpenResourceIdResult getResourceId(Uri uri) throws FileNotFoundException", "public final Uri insert(@RequiresPermission.Write @NonNull Uri url, @Nullable ContentValues values)", "public final Uri insert(@RequiresPermission.Write @NonNull Uri url, @Nullable ContentValues values, @Nullable Bundle extras)", "public ContentProviderResult[] applyBatch(@NonNull String authority, @NonNull ArrayList<ContentProviderOperation> operations) throws RemoteException, OperationApplicationException", "public final int bulkInsert(@RequiresPermission.Write @NonNull Uri url, @NonNull ContentValues[] values)", "public final int delete(@RequiresPermission.Write @NonNull Uri url, @Nullable String where, @Nullable String[] selectionArgs)", "public final int delete(@RequiresPermission.Write @NonNull Uri url, @Nullable Bundle extras)", "public final int update(@RequiresPermission.Write @NonNull Uri uri, @Nullable ContentValues values, @Nullable String where, @Nullable String[] selectionArgs)", "public final int update(@RequiresPermission.Write @NonNull Uri uri, @Nullable ContentValues values, @Nullable Bundle extras)", "public final Bundle call(@NonNull Uri uri, @NonNull String method, @Nullable String arg, @Nullable Bundle extras)", "public final Bundle call(@NonNull String authority, @NonNull String method, @Nullable String arg, @Nullable Bundle extras)", "public final IContentProvider acquireProvider(Uri uri)", "public final IContentProvider acquireExistingProvider(Uri uri)", "public final IContentProvider acquireProvider(String name)", "public final IContentProvider acquireUnstableProvider(Uri uri)", "public final IContentProvider acquireUnstableProvider(String name)", "public final ContentProviderClient acquireContentProviderClient(@NonNull Uri uri)", "public final ContentProviderClient acquireContentProviderClient(@NonNull String name)", "public final ContentProviderClient acquireUnstableContentProviderClient(@NonNull Uri uri)", "public final ContentProviderClient acquireUnstableContentProviderClient(@NonNull String name)", "public final void registerContentObserver(@NonNull Uri uri, boolean notifyForDescendants, @NonNull ContentObserver observer)", "public final void registerContentObserverAsUser(@NonNull Uri uri, boolean notifyForDescendants, @NonNull ContentObserver observer, @NonNull UserHandle userHandle)", "public final void registerContentObserver(Uri uri, boolean notifyForDescendents, ContentObserver observer, @UserIdInt int userHandle)", "public final void unregisterContentObserver(@NonNull ContentObserver observer)", "public void notifyChange(@NonNull Uri uri, @Nullable ContentObserver observer)", "public void notifyChange(@NonNull Uri uri, @Nullable ContentObserver observer, boolean syncToNetwork)", "public void notifyChange(@NonNull Uri uri, @Nullable ContentObserver observer, @NotifyFlags int flags)", "public void notifyChange(@NonNull Iterable<Uri> uris, @Nullable ContentObserver observer, @NotifyFlags int flags)", "public void notifyChange(@NonNull Collection<Uri> uris, @Nullable ContentObserver observer, @NotifyFlags int flags)", "public void notifyChange(@NonNull Uri uri, ContentObserver observer, boolean syncToNetwork, @UserIdInt int userHandle)", "public void notifyChange(@NonNull Uri uri, ContentObserver observer, @NotifyFlags int flags, @UserIdInt int userHandle)", "public void notifyChange(@NonNull Uri[] uris, ContentObserver observer, @NotifyFlags int flags, @UserIdInt int userHandle)", "public void takePersistableUriPermission(@NonNull Uri uri, @Intent.AccessUriMode int modeFlags)", "public void takePersistableUriPermission(@NonNull String toPackage, @NonNull Uri uri, @Intent.AccessUriMode int modeFlags)", "public void releasePersistableUriPermission(@NonNull Uri uri, @Intent.AccessUriMode int modeFlags)", "public List<UriPermission> getPersistedUriPermissions()", "public List<UriPermission> getOutgoingPersistedUriPermissions()", "public List<UriPermission> getOutgoingUriPermissions()", "public void startSync(Uri uri, Bundle extras)", "public static void requestSync(Account account, String authority, Bundle extras)", "public static void requestSyncAsUser(Account account, String authority, @UserIdInt int userId, Bundle extras)", "public static void requestSync(SyncRequest request)", "public static void validateSyncExtrasBundle(Bundle extras)", "public void cancelSync(Uri uri)", "public static void cancelSync(Account account, String authority)", "public static void cancelSyncAsUser(Account account, String authority, @UserIdInt int userId)", "public static SyncAdapterType[] getSyncAdapterTypes()", "public static SyncAdapterType[] getSyncAdapterTypesAsUser(@UserIdInt int userId)", "public static String[] getSyncAdapterPackagesForAuthorityAsUser(String authority, @UserIdInt int userId)", "public static String getSyncAdapterPackageAsUser(@NonNull String accountType, @NonNull String authority, @UserIdInt int userId)", "public static boolean getSyncAutomatically(Account account, String authority)", "public static boolean getSyncAutomaticallyAsUser(Account account, String authority, @UserIdInt int userId)", "public static void setSyncAutomatically(Account account, String authority, boolean sync)", "public static void setSyncAutomaticallyAsUser(Account account, String authority, boolean sync, @UserIdInt int userId)", "public static boolean hasInvalidScheduleAsEjExtras(Bundle extras)", "public static void addPeriodicSync(Account account, String authority, Bundle extras, long pollFrequency)", "public static boolean invalidPeriodicExtras(Bundle extras)", "public static void removePeriodicSync(Account account, String authority, Bundle extras)", "public static void cancelSync(SyncRequest request)", "public static List<PeriodicSync> getPeriodicSyncs(Account account, String authority)", "public static int getIsSyncable(Account account, String authority)", "public static int getIsSyncableAsUser(Account account, String authority, @UserIdInt int userId)", "public static void setIsSyncable(Account account, String authority, int syncable)", "public static void setIsSyncableAsUser(Account account, String authority, int syncable, int userId)", "public static boolean getMasterSyncAutomatically()", "public static boolean getMasterSyncAutomaticallyAsUser(@UserIdInt int userId)", "public static void setMasterSyncAutomatically(boolean sync)", "public static void setMasterSyncAutomaticallyAsUser(boolean sync, @UserIdInt int userId)", "public static boolean isSyncActive(Account account, String authority)", "public static SyncInfo getCurrentSync()", "public static List<SyncInfo> getCurrentSyncs()", "public static List<SyncInfo> getCurrentSyncsAsUser(@UserIdInt int userId)", "public static SyncStatusInfo getSyncStatus(Account account, String authority)", "public static SyncStatusInfo getSyncStatusAsUser(Account account, String authority, @UserIdInt int userId)", "public static boolean isSyncPending(Account account, String authority)", "public static boolean isSyncPendingAsUser(Account account, String authority, @UserIdInt int userId)", "public static Object addStatusChangeListener(int mask, final SyncStatusObserver callback)", "public static void removeStatusChangeListener(Object handle)", "public void putCache(@NonNull Uri key, @Nullable Bundle value)", "public Bundle getCache(@NonNull Uri key)", "public int getTargetSdkVersion()", "private int samplePercentForDuration(long durationMillis)", "private void maybeLogQueryToEventLog(long durationMillis, Uri uri, String[] projection, @Nullable Bundle queryArgs)", "private void maybeLogUpdateToEventLog(long durationMillis, Uri uri, String operation, String selection)", "public static IContentService getContentService()", "public String getPackageName()", "public String getAttributionTag()", "public AttributionSource getAttributionSource()", "public int resolveUserId(Uri uri)", "public int getUserId()", "public Drawable getTypeDrawable(String mimeType)", "public final MimeTypeInfo getTypeInfo(@NonNull String mimeType)", "public static Bundle createSqlQueryBundle(@Nullable String selection, @Nullable String[] selectionArgs)", "public static Bundle createSqlQueryBundle(@Nullable String selection, @Nullable String[] selectionArgs, @Nullable String sortOrder)", "public static Bundle includeSqlSelectionArgs(@NonNull Bundle queryArgs, @Nullable String selection, @Nullable String[] selectionArgs)", "public static String createSqlSortClause(Bundle queryArgs)", "public Bitmap loadThumbnail(@NonNull Uri uri, @NonNull Size size, @Nullable CancellationSignal signal) throws IOException", "public static Bitmap loadThumbnail(@NonNull ContentInterface content, @NonNull Uri uri, @NonNull Size size, @Nullable CancellationSignal signal, int allocator) throws IOException", "public static void onDbCorruption(String tag, String message, Throwable stacktrace)", "public static Uri decodeFromFile(@NonNull File file)", "public static File encodeToFile(@NonNull Uri uri)", "public static Uri translateDeprecatedDataPath(@NonNull String path)", "public static String translateDeprecatedDataPath(@NonNull Uri uri)" ],
  "variableNames" : [ "DEPRECATE_DATA_COLUMNS", "DEPRECATE_DATA_PREFIX", "SYNC_EXTRAS_ACCOUNT", "SYNC_EXTRAS_EXPEDITED", "SYNC_EXTRAS_REQUIRE_CHARGING", "SYNC_EXTRAS_SCHEDULE_AS_EXPEDITED_JOB", "SYNC_EXTRAS_FORCE", "SYNC_EXTRAS_IGNORE_SETTINGS", "SYNC_EXTRAS_IGNORE_BACKOFF", "SYNC_EXTRAS_DO_NOT_RETRY", "SYNC_EXTRAS_MANUAL", "SYNC_EXTRAS_UPLOAD", "SYNC_EXTRAS_OVERRIDE_TOO_MANY_DELETIONS", "SYNC_EXTRAS_DISCARD_LOCAL_DELETIONS", "SYNC_EXTRAS_EXPECTED_UPLOAD", "SYNC_EXTRAS_EXPECTED_DOWNLOAD", "SYNC_EXTRAS_PRIORITY", "SYNC_EXTRAS_DISALLOW_METERED", "SYNC_VIRTUAL_EXTRAS_EXEMPTION_FLAG", "SYNC_EXTRAS_INITIALIZE", "ACTION_SYNC_CONN_STATUS_CHANGED", "SCHEME_CONTENT", "SCHEME_ANDROID_RESOURCE", "SCHEME_FILE", "EXTRA_SIZE", "EXTRA_REFRESH_SUPPORTED", "QUERY_ARG_SQL_SELECTION", "QUERY_ARG_SQL_SELECTION_ARGS", "QUERY_ARG_SQL_SORT_ORDER", "QUERY_ARG_SQL_GROUP_BY", "QUERY_ARG_SQL_HAVING", "QUERY_ARG_SQL_LIMIT", "QUERY_ARG_SORT_COLUMNS", "QUERY_ARG_SORT_DIRECTION", "QUERY_ARG_SORT_COLLATION", "QUERY_ARG_SORT_LOCALE", "QUERY_ARG_GROUP_COLUMNS", "EXTRA_HONORED_ARGS", "QUERY_SORT_DIRECTION_ASCENDING", "QUERY_SORT_DIRECTION_DESCENDING", "QUERY_ARG_OFFSET", "QUERY_ARG_LIMIT", "EXTRA_TOTAL_COUNT", "CURSOR_ITEM_BASE_TYPE", "CURSOR_DIR_BASE_TYPE", "ANY_CURSOR_ITEM_TYPE", "MIME_TYPE_DEFAULT", "SYNC_ERROR_SYNC_ALREADY_IN_PROGRESS", "SYNC_ERROR_AUTHENTICATION", "SYNC_ERROR_IO", "SYNC_ERROR_PARSE", "SYNC_ERROR_CONFLICT", "SYNC_ERROR_TOO_MANY_DELETIONS", "SYNC_ERROR_TOO_MANY_RETRIES", "SYNC_ERROR_INTERNAL", "SYNC_ERROR_NAMES", "SYNC_OBSERVER_TYPE_SETTINGS", "SYNC_OBSERVER_TYPE_PENDING", "SYNC_OBSERVER_TYPE_ACTIVE", "SYNC_OBSERVER_TYPE_STATUS", "SYNC_OBSERVER_TYPE_ALL", "NOTIFY_SYNC_TO_NETWORK", "NOTIFY_SKIP_NOTIFY_FOR_DESCENDANTS", "NOTIFY_INSERT", "NOTIFY_UPDATE", "NOTIFY_DELETE", "NOTIFY_NO_DELAY", "SYNC_EXEMPTION_NONE", "SYNC_EXEMPTION_PROMOTE_BUCKET", "SYNC_EXEMPTION_PROMOTE_BUCKET_WITH_TEMP", "ENABLE_CONTENT_SAMPLE", "SLOW_THRESHOLD_MILLIS", "mRandom", "REMOTE_CALLBACK_RESULT", "REMOTE_CALLBACK_ERROR", "CONTENT_PROVIDER_PUBLISH_TIMEOUT_MILLIS", "CONTENT_PROVIDER_READY_TIMEOUT_MILLIS", "CONTENT_PROVIDER_TIMEOUT_MILLIS", "REMOTE_CONTENT_PROVIDER_TIMEOUT_MILLIS", "CONTENT_SERVICE_NAME", "sContentService", "mContext", "mPackageName", "mTargetSdkVersion", "mWrapped", "TAG" ]
}