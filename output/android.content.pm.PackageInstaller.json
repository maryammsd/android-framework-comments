{
  "filePath" : "/home/maryam/clearblue/files/android-source-30/android/content/pm/PackageInstaller.java",
  "packageName" : "android.content.pm",
  "className" : "PackageInstaller",
  "comment" : "\n * Offers the ability to install, upgrade, and remove applications on the\n * device. This includes support for apps packaged either as a single\n * \"monolithic\" APK, or apps packaged as multiple \"split\" APKs.\n * <p>\n * An app is delivered for installation through a\n * {@link PackageInstaller.Session}, which any app can create. Once the session\n * is created, the installer can stream one or more APKs into place until it\n * decides to either commit or destroy the session. Committing may require user\n * intervention to complete the installation, unless the caller falls into one of the\n * following categories, in which case the installation will complete automatically.\n * <ul>\n * <li>the device owner\n * <li>the affiliated profile owner\n * </ul>\n * <p>\n * Sessions can install brand new apps, upgrade existing apps, or add new splits\n * into an existing app.\n * <p>\n * Apps packaged as multiple split APKs always consist of a single \"base\" APK\n * (with a {@code null} split name) and zero or more \"split\" APKs (with unique\n * split names). Any subset of these APKs can be installed together, as long as\n * the following constraints are met:\n * <ul>\n * <li>All APKs must have the exact same package name, version code, and signing\n * certificates.\n * <li>All APKs must have unique split names.\n * <li>All installations must contain a single base APK.\n * </ul>\n * <p>\n * The ApiDemos project contains examples of using this API:\n * <code>ApiDemos/src/com/example/android/apis/content/InstallApk*.java</code>.\n ",
  "variables" : [ {
    "name" : "TAG",
    "type" : "String",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "ENABLE_REVOCABLE_FD",
    "type" : "boolean",
    "comment" : " {@hide} ",
    "links" : [ ]
  }, {
    "name" : "ACTION_SESSION_DETAILS",
    "type" : "String",
    "comment" : "\n     * Activity Action: Show details about a particular install session. This\n     * may surface actions such as pause, resume, or cancel.\n     * <p>\n     * This should always be scoped to the installer package that owns the\n     * session. Clients should use {@link SessionInfo#createDetailsIntent()} to\n     * build this intent correctly.\n     * <p>\n     * In some cases, a matching Activity may not exist, so ensure you safeguard\n     * against this.\n     * <p>\n     * The session to show details for is defined in {@link #EXTRA_SESSION_ID}.\n     ",
    "links" : [ "#EXTRA_SESSION_ID", "#createDetailsIntent()" ]
  }, {
    "name" : "ACTION_SESSION_COMMITTED",
    "type" : "String",
    "comment" : "\n     * Broadcast Action: Explicit broadcast sent to the last known default launcher when a session\n     * for a new install is committed. For managed profile, this is sent to the default launcher\n     * of the primary profile.\n     * <p>\n     * The associated session is defined in {@link #EXTRA_SESSION} and the user for which this\n     * session was created in {@link Intent#EXTRA_USER}.\n     ",
    "links" : [ "#EXTRA_SESSION", "android.content.Intent#EXTRA_USER" ]
  }, {
    "name" : "ACTION_SESSION_UPDATED",
    "type" : "String",
    "comment" : "\n     * Broadcast Action: Send information about a staged install session when its state is updated.\n     * <p>\n     * The associated session information is defined in {@link #EXTRA_SESSION}.\n     ",
    "links" : [ "#EXTRA_SESSION" ]
  }, {
    "name" : "ACTION_CONFIRM_INSTALL",
    "type" : "String",
    "comment" : " {@hide} ",
    "links" : [ ]
  }, {
    "name" : "EXTRA_SESSION_ID",
    "type" : "String",
    "comment" : "\n     * An integer session ID that an operation is working with.\n     *\n     * @see Intent#getIntExtra(String, int)\n     ",
    "links" : [ ]
  }, {
    "name" : "EXTRA_SESSION",
    "type" : "String",
    "comment" : "\n     * {@link SessionInfo} that an operation is working with.\n     *\n     * @see Intent#getParcelableExtra(String)\n     ",
    "links" : [ "SessionInfo" ]
  }, {
    "name" : "EXTRA_PACKAGE_NAME",
    "type" : "String",
    "comment" : "\n     * Package name that an operation is working with.\n     *\n     * @see Intent#getStringExtra(String)\n     ",
    "links" : [ ]
  }, {
    "name" : "EXTRA_STATUS",
    "type" : "String",
    "comment" : "\n     * Current status of an operation. Will be one of\n     * {@link #STATUS_PENDING_USER_ACTION}, {@link #STATUS_SUCCESS},\n     * {@link #STATUS_FAILURE}, {@link #STATUS_FAILURE_ABORTED},\n     * {@link #STATUS_FAILURE_BLOCKED}, {@link #STATUS_FAILURE_CONFLICT},\n     * {@link #STATUS_FAILURE_INCOMPATIBLE}, {@link #STATUS_FAILURE_INVALID}, or\n     * {@link #STATUS_FAILURE_STORAGE}.\n     * <p>\n     * More information about a status may be available through additional\n     * extras; see the individual status documentation for details.\n     *\n     * @see Intent#getIntExtra(String, int)\n     ",
    "links" : [ "#STATUS_FAILURE_INCOMPATIBLE", "#STATUS_PENDING_USER_ACTION", "#STATUS_FAILURE_BLOCKED", "#STATUS_FAILURE_CONFLICT", "#STATUS_FAILURE", "#STATUS_SUCCESS", "#STATUS_FAILURE_STORAGE", "#STATUS_FAILURE_INVALID", "#STATUS_FAILURE_ABORTED" ]
  }, {
    "name" : "EXTRA_STATUS_MESSAGE",
    "type" : "String",
    "comment" : "\n     * Detailed string representation of the status, including raw details that\n     * are useful for debugging.\n     *\n     * @see Intent#getStringExtra(String)\n     ",
    "links" : [ ]
  }, {
    "name" : "EXTRA_OTHER_PACKAGE_NAME",
    "type" : "String",
    "comment" : "\n     * Another package name relevant to a status. This is typically the package\n     * responsible for causing an operation failure.\n     *\n     * @see Intent#getStringExtra(String)\n     ",
    "links" : [ ]
  }, {
    "name" : "EXTRA_STORAGE_PATH",
    "type" : "String",
    "comment" : "\n     * Storage path relevant to a status.\n     *\n     * @see Intent#getStringExtra(String)\n     ",
    "links" : [ ]
  }, {
    "name" : "EXTRA_PACKAGE_NAMES",
    "type" : "String",
    "comment" : " {@hide} ",
    "links" : [ ]
  }, {
    "name" : "EXTRA_LEGACY_STATUS",
    "type" : "String",
    "comment" : " {@hide} ",
    "links" : [ ]
  }, {
    "name" : "EXTRA_LEGACY_BUNDLE",
    "type" : "String",
    "comment" : " {@hide} ",
    "links" : [ ]
  }, {
    "name" : "EXTRA_CALLBACK",
    "type" : "String",
    "comment" : " {@hide} ",
    "links" : [ ]
  }, {
    "name" : "EXTRA_DATA_LOADER_TYPE",
    "type" : "String",
    "comment" : "\n     * Type of DataLoader for this session. Will be one of\n     * {@link #DATA_LOADER_TYPE_NONE}, {@link #DATA_LOADER_TYPE_STREAMING},\n     * {@link #DATA_LOADER_TYPE_INCREMENTAL}.\n     * <p>\n     * See the individual types documentation for details.\n     *\n     * @see Intent#getIntExtra(String, int)\n     * {@hide}\n     ",
    "links" : [ "#DATA_LOADER_TYPE_STREAMING", "#DATA_LOADER_TYPE_INCREMENTAL", "#DATA_LOADER_TYPE_NONE" ]
  }, {
    "name" : "STATUS_PENDING_STREAMING",
    "type" : "int",
    "comment" : "\n     * Streaming installation pending.\n     * Caller should make sure DataLoader is able to prepare image and reinitiate the operation.\n     *\n     * @see #EXTRA_SESSION_ID\n     * {@hide}\n     ",
    "links" : [ ]
  }, {
    "name" : "STATUS_PENDING_USER_ACTION",
    "type" : "int",
    "comment" : "\n     * User action is currently required to proceed. You can launch the intent\n     * activity described by {@link Intent#EXTRA_INTENT} to involve the user and\n     * continue.\n     * <p>\n     * You may choose to immediately launch the intent if the user is actively\n     * using your app. Otherwise, you should use a notification to guide the\n     * user back into your app before launching.\n     *\n     * @see Intent#getParcelableExtra(String)\n     ",
    "links" : [ "android.content.Intent#EXTRA_INTENT" ]
  }, {
    "name" : "STATUS_SUCCESS",
    "type" : "int",
    "comment" : "\n     * The operation succeeded.\n     ",
    "links" : [ ]
  }, {
    "name" : "STATUS_FAILURE",
    "type" : "int",
    "comment" : "\n     * The operation failed in a generic way. The system will always try to\n     * provide a more specific failure reason, but in some rare cases this may\n     * be delivered.\n     *\n     * @see #EXTRA_STATUS_MESSAGE\n     ",
    "links" : [ ]
  }, {
    "name" : "STATUS_FAILURE_BLOCKED",
    "type" : "int",
    "comment" : "\n     * The operation failed because it was blocked. For example, a device policy\n     * may be blocking the operation, a package verifier may have blocked the\n     * operation, or the app may be required for core system operation.\n     * <p>\n     * The result may also contain {@link #EXTRA_OTHER_PACKAGE_NAME} with the\n     * specific package blocking the install.\n     *\n     * @see #EXTRA_STATUS_MESSAGE\n     * @see #EXTRA_OTHER_PACKAGE_NAME\n     ",
    "links" : [ "#EXTRA_OTHER_PACKAGE_NAME" ]
  }, {
    "name" : "STATUS_FAILURE_ABORTED",
    "type" : "int",
    "comment" : "\n     * The operation failed because it was actively aborted. For example, the\n     * user actively declined requested permissions, or the session was\n     * abandoned.\n     *\n     * @see #EXTRA_STATUS_MESSAGE\n     ",
    "links" : [ ]
  }, {
    "name" : "STATUS_FAILURE_INVALID",
    "type" : "int",
    "comment" : "\n     * The operation failed because one or more of the APKs was invalid. For\n     * example, they might be malformed, corrupt, incorrectly signed,\n     * mismatched, etc.\n     *\n     * @see #EXTRA_STATUS_MESSAGE\n     ",
    "links" : [ ]
  }, {
    "name" : "STATUS_FAILURE_CONFLICT",
    "type" : "int",
    "comment" : "\n     * The operation failed because it conflicts (or is inconsistent with) with\n     * another package already installed on the device. For example, an existing\n     * permission, incompatible certificates, etc. The user may be able to\n     * uninstall another app to fix the issue.\n     * <p>\n     * The result may also contain {@link #EXTRA_OTHER_PACKAGE_NAME} with the\n     * specific package identified as the cause of the conflict.\n     *\n     * @see #EXTRA_STATUS_MESSAGE\n     * @see #EXTRA_OTHER_PACKAGE_NAME\n     ",
    "links" : [ "#EXTRA_OTHER_PACKAGE_NAME" ]
  }, {
    "name" : "STATUS_FAILURE_STORAGE",
    "type" : "int",
    "comment" : "\n     * The operation failed because of storage issues. For example, the device\n     * may be running low on space, or external media may be unavailable. The\n     * user may be able to help free space or insert different external media.\n     * <p>\n     * The result may also contain {@link #EXTRA_STORAGE_PATH} with the path to\n     * the storage device that caused the failure.\n     *\n     * @see #EXTRA_STATUS_MESSAGE\n     * @see #EXTRA_STORAGE_PATH\n     ",
    "links" : [ "#EXTRA_STORAGE_PATH" ]
  }, {
    "name" : "STATUS_FAILURE_INCOMPATIBLE",
    "type" : "int",
    "comment" : "\n     * The operation failed because it is fundamentally incompatible with this\n     * device. For example, the app may require a hardware feature that doesn't\n     * exist, it may be missing native code for the ABIs supported by the\n     * device, or it requires a newer SDK version, etc.\n     *\n     * @see #EXTRA_STATUS_MESSAGE\n     ",
    "links" : [ ]
  }, {
    "name" : "DATA_LOADER_TYPE_NONE",
    "type" : "int",
    "comment" : "\n     * Default value, non-streaming installation session.\n     *\n     * @see #EXTRA_DATA_LOADER_TYPE\n     * {@hide}\n     ",
    "links" : [ ]
  }, {
    "name" : "DATA_LOADER_TYPE_STREAMING",
    "type" : "int",
    "comment" : "\n     * Streaming installation using data loader.\n     *\n     * @see #EXTRA_DATA_LOADER_TYPE\n     * {@hide}\n     ",
    "links" : [ ]
  }, {
    "name" : "DATA_LOADER_TYPE_INCREMENTAL",
    "type" : "int",
    "comment" : "\n     * Streaming installation using Incremental FileSystem.\n     *\n     * @see #EXTRA_DATA_LOADER_TYPE\n     * {@hide}\n     ",
    "links" : [ ]
  }, {
    "name" : "LOCATION_DATA_APP",
    "type" : "int",
    "comment" : "\n     * Target location for the file in installation session is /data/app/<packageName>-<id>.\n     * This is the intended location for APKs.\n     * Requires permission to install packages.\n     * {@hide}\n     ",
    "links" : [ ]
  }, {
    "name" : "LOCATION_MEDIA_OBB",
    "type" : "int",
    "comment" : "\n     * Target location for the file in installation session is\n     * /data/media/<userid>/Android/obb/<packageName>. This is the intended location for OBBs.\n     * {@hide}\n     ",
    "links" : [ ]
  }, {
    "name" : "LOCATION_MEDIA_DATA",
    "type" : "int",
    "comment" : "\n     * Target location for the file in installation session is\n     * /data/media/<userid>/Android/data/<packageName>.\n     * This is the intended location for application data.\n     * Can only be used by an app itself running under specific user.\n     * {@hide}\n     ",
    "links" : [ ]
  }, {
    "name" : "mInstaller",
    "type" : "IPackageInstaller",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mUserId",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mInstallerPackageName",
    "type" : "String",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mDelegates",
    "type" : "ArrayList<SessionCallbackDelegate>",
    "comment" : "",
    "links" : [ ]
  } ],
  "methods" : [ {
    "name" : "public int createSession(@NonNull SessionParams params) throws IOException",
    "returnType" : "int",
    "comment" : "\n     * Create a new session using the given parameters, returning a unique ID\n     * that represents the session. Once created, the session can be opened\n     * multiple times across multiple device boots.\n     * <p>\n     * The system may automatically destroy sessions that have not been\n     * finalized (either committed or abandoned) within a reasonable period of\n     * time, typically on the order of a day.\n     *\n     * @throws IOException if parameters were unsatisfiable, such as lack of\n     *             disk space or unavailable media.\n     * @throws SecurityException when installation services are unavailable,\n     *             such as when called from a restricted user.\n     * @throws IllegalArgumentException when {@link SessionParams} is invalid.\n     * @return positive, non-zero unique ID that represents the created session.\n     *         This ID remains consistent across device reboots until the\n     *         session is finalized. IDs are not reused during a given boot.\n     ",
    "links" : [ "SessionParams" ]
  }, {
    "name" : "public Session openSession(int sessionId) throws IOException",
    "returnType" : "Session",
    "comment" : "\n     * Open an existing session to actively perform work. To succeed, the caller\n     * must be the owner of the install session.\n     *\n     * @throws IOException if parameters were unsatisfiable, such as lack of\n     *             disk space or unavailable media.\n     * @throws SecurityException when the caller does not own the session, or\n     *             the session is invalid.\n     ",
    "links" : [ ]
  }, {
    "name" : "public void updateSessionAppIcon(int sessionId, @Nullable Bitmap appIcon)",
    "returnType" : "void",
    "comment" : "\n     * Update the icon representing the app being installed in a specific\n     * session. This should be roughly\n     * {@link ActivityManager#getLauncherLargeIconSize()} in both dimensions.\n     *\n     * @throws SecurityException when the caller does not own the session, or\n     *             the session is invalid.\n     ",
    "links" : [ "android.app.ActivityManager#getLauncherLargeIconSize()" ]
  }, {
    "name" : "public void updateSessionAppLabel(int sessionId, @Nullable CharSequence appLabel)",
    "returnType" : "void",
    "comment" : "\n     * Update the label representing the app being installed in a specific\n     * session.\n     *\n     * @throws SecurityException when the caller does not own the session, or\n     *             the session is invalid.\n     ",
    "links" : [ ]
  }, {
    "name" : "public void abandonSession(int sessionId)",
    "returnType" : "void",
    "comment" : "\n     * Completely abandon the given session, destroying all staged data and\n     * rendering it invalid. Abandoned sessions will be reported to\n     * {@link SessionCallback} listeners as failures. This is equivalent to\n     * opening the session and calling {@link Session#abandon()}.\n     *\n     * @throws SecurityException when the caller does not own the session, or\n     *             the session is invalid.\n     ",
    "links" : [ "#abandon()", "SessionCallback" ]
  }, {
    "name" : "public SessionInfo getSessionInfo(int sessionId)",
    "returnType" : "SessionInfo",
    "comment" : "\n     * Return details for a specific session. No special permissions are\n     * required to retrieve these details.\n     *\n     * @return details for the requested session, or {@code null} if the session\n     *         does not exist.\n     ",
    "links" : [ ]
  }, {
    "name" : "public List<SessionInfo> getAllSessions()",
    "returnType" : "List<SessionInfo>",
    "comment" : "\n     * Return list of all known install sessions, regardless of the installer.\n     ",
    "links" : [ ]
  }, {
    "name" : "public List<SessionInfo> getMySessions()",
    "returnType" : "List<SessionInfo>",
    "comment" : "\n     * Return list of all known install sessions owned by the calling app.\n     ",
    "links" : [ ]
  }, {
    "name" : "public List<SessionInfo> getStagedSessions()",
    "returnType" : "List<SessionInfo>",
    "comment" : "\n     * Return list of all staged install sessions.\n     ",
    "links" : [ ]
  }, {
    "name" : "public SessionInfo getActiveStagedSession()",
    "returnType" : "SessionInfo",
    "comment" : "\n     * Returns first active staged session, or {@code null} if there is none.\n     *\n     * <p>For more information on what sessions are considered active see\n     * {@link SessionInfo#isStagedSessionActive()}.\n     *\n     * @deprecated Use {@link #getActiveStagedSessions} as there can be more than one active staged\n     * session\n     ",
    "links" : [ "#isStagedSessionActive()", "#getActiveStagedSessions" ]
  }, {
    "name" : "public List<SessionInfo> getActiveStagedSessions()",
    "returnType" : "List<SessionInfo>",
    "comment" : "\n     * Returns list of active staged sessions. Returns empty list if there is none.\n     *\n     * <p>For more information on what sessions are considered active see\n     *      * {@link SessionInfo#isStagedSessionActive()}.\n     ",
    "links" : [ "#isStagedSessionActive()" ]
  }, {
    "name" : "public void uninstall(@NonNull String packageName, @NonNull IntentSender statusReceiver)",
    "returnType" : "void",
    "comment" : "\n     * Uninstall the given package, removing it completely from the device. This\n     * method is available to:\n     * <ul>\n     * <li>the current \"installer of record\" for the package\n     * <li>the device owner\n     * <li>the affiliated profile owner\n     * </ul>\n     *\n     * @param packageName The package to uninstall.\n     * @param statusReceiver Where to deliver the result.\n     *\n     * @see android.app.admin.DevicePolicyManager\n     ",
    "links" : [ ]
  }, {
    "name" : "public void uninstall(@NonNull String packageName, @DeleteFlags int flags, @NonNull IntentSender statusReceiver)",
    "returnType" : "void",
    "comment" : "\n     * Uninstall the given package, removing it completely from the device. This\n     * method is only available to the current \"installer of record\" for the\n     * package.\n     *\n     * @param packageName The package to uninstall.\n     * @param flags Flags for uninstall.\n     * @param statusReceiver Where to deliver the result.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public void uninstall(@NonNull VersionedPackage versionedPackage, @NonNull IntentSender statusReceiver)",
    "returnType" : "void",
    "comment" : "\n     * Uninstall the given package with a specific version code, removing it\n     * completely from the device. If the version code of the package\n     * does not match the one passed in the versioned package argument this\n     * method is a no-op. Use {@link PackageManager#VERSION_CODE_HIGHEST} to\n     * uninstall the latest version of the package.\n     * <p>\n     * This method is available to:\n     * <ul>\n     * <li>the current \"installer of record\" for the package\n     * <li>the device owner\n     * <li>the affiliated profile owner\n     * </ul>\n     *\n     * @param versionedPackage The versioned package to uninstall.\n     * @param statusReceiver Where to deliver the result.\n     *\n     * @see android.app.admin.DevicePolicyManager\n     ",
    "links" : [ "android.content.pm.PackageManager#VERSION_CODE_HIGHEST" ]
  }, {
    "name" : "public void uninstall(@NonNull VersionedPackage versionedPackage, @DeleteFlags int flags, @NonNull IntentSender statusReceiver)",
    "returnType" : "void",
    "comment" : "\n     * Uninstall the given package with a specific version code, removing it\n     * completely from the device. This method is only available to the current\n     * \"installer of record\" for the package. If the version code of the package\n     * does not match the one passed in the versioned package argument this\n     * method is a no-op. Use {@link PackageManager#VERSION_CODE_HIGHEST} to\n     * uninstall the latest version of the package.\n     *\n     * @param versionedPackage The versioned package to uninstall.\n     * @param flags Flags for uninstall.\n     * @param statusReceiver Where to deliver the result.\n     *\n     * @hide\n     ",
    "links" : [ "android.content.pm.PackageManager#VERSION_CODE_HIGHEST" ]
  }, {
    "name" : "public void installExistingPackage(@NonNull String packageName, @InstallReason int installReason, @Nullable IntentSender statusReceiver)",
    "returnType" : "void",
    "comment" : "\n     * Install the given package, which already exists on the device, for the user for which this\n     * installer was created.\n     *\n     * <p>This will\n     * {@link PackageInstaller.SessionParams#setWhitelistedRestrictedPermissions(Set) whitelist\n     * all restricted permissions}.\n     *\n     * @param packageName The package to install.\n     * @param installReason Reason for install.\n     * @param statusReceiver Where to deliver the result.\n     ",
    "links" : [ "PackageInstaller.SessionParams#setWhitelistedRestrictedPermissions(Set)" ]
  }, {
    "name" : "public void uninstallExistingPackage(@NonNull String packageName, @Nullable IntentSender statusReceiver)",
    "returnType" : "void",
    "comment" : "\n     * Uninstall the given package for the user for which this installer was created if the package\n     * will still exist for other users on the device.\n     *\n     * @param packageName The package to install.\n     * @param statusReceiver Where to deliver the result.\n     *\n     * {@hide}\n     ",
    "links" : [ ]
  }, {
    "name" : "public void setPermissionsResult(int sessionId, boolean accepted)",
    "returnType" : "void",
    "comment" : " {@hide} ",
    "links" : [ ]
  }, {
    "name" : "public void addSessionCallback(@NonNull SessionCallback callback)",
    "returnType" : "void",
    "comment" : " {@hide} ",
    "links" : [ ]
  }, {
    "name" : "public void registerSessionCallback(@NonNull SessionCallback callback)",
    "returnType" : "void",
    "comment" : "\n     * Register to watch for session lifecycle events. No special permissions\n     * are required to watch for these events.\n     ",
    "links" : [ ]
  }, {
    "name" : "public void addSessionCallback(@NonNull SessionCallback callback, @NonNull Handler handler)",
    "returnType" : "void",
    "comment" : " {@hide} ",
    "links" : [ ]
  }, {
    "name" : "public void registerSessionCallback(@NonNull SessionCallback callback, @NonNull Handler handler)",
    "returnType" : "void",
    "comment" : "\n     * Register to watch for session lifecycle events. No special permissions\n     * are required to watch for these events.\n     *\n     * @param handler to dispatch callback events through, otherwise uses\n     *            calling thread.\n     ",
    "links" : [ ]
  }, {
    "name" : "public void removeSessionCallback(@NonNull SessionCallback callback)",
    "returnType" : "void",
    "comment" : " {@hide} ",
    "links" : [ ]
  }, {
    "name" : "public void unregisterSessionCallback(@NonNull SessionCallback callback)",
    "returnType" : "void",
    "comment" : "\n     * Unregister a previously registered callback.\n     ",
    "links" : [ ]
  } ],
  "variableNames" : [ "TAG", "ENABLE_REVOCABLE_FD", "ACTION_SESSION_DETAILS", "ACTION_SESSION_COMMITTED", "ACTION_SESSION_UPDATED", "ACTION_CONFIRM_INSTALL", "EXTRA_SESSION_ID", "EXTRA_SESSION", "EXTRA_PACKAGE_NAME", "EXTRA_STATUS", "EXTRA_STATUS_MESSAGE", "EXTRA_OTHER_PACKAGE_NAME", "EXTRA_STORAGE_PATH", "EXTRA_PACKAGE_NAMES", "EXTRA_LEGACY_STATUS", "EXTRA_LEGACY_BUNDLE", "EXTRA_CALLBACK", "EXTRA_DATA_LOADER_TYPE", "STATUS_PENDING_STREAMING", "STATUS_PENDING_USER_ACTION", "STATUS_SUCCESS", "STATUS_FAILURE", "STATUS_FAILURE_BLOCKED", "STATUS_FAILURE_ABORTED", "STATUS_FAILURE_INVALID", "STATUS_FAILURE_CONFLICT", "STATUS_FAILURE_STORAGE", "STATUS_FAILURE_INCOMPATIBLE", "DATA_LOADER_TYPE_NONE", "DATA_LOADER_TYPE_STREAMING", "DATA_LOADER_TYPE_INCREMENTAL", "LOCATION_DATA_APP", "LOCATION_MEDIA_OBB", "LOCATION_MEDIA_DATA", "mInstaller", "mUserId", "mInstallerPackageName", "mDelegates" ],
  "methodNames" : [ "public int createSession(@NonNull SessionParams params) throws IOException", "public Session openSession(int sessionId) throws IOException", "public void updateSessionAppIcon(int sessionId, @Nullable Bitmap appIcon)", "public void updateSessionAppLabel(int sessionId, @Nullable CharSequence appLabel)", "public void abandonSession(int sessionId)", "public SessionInfo getSessionInfo(int sessionId)", "public List<SessionInfo> getAllSessions()", "public List<SessionInfo> getMySessions()", "public List<SessionInfo> getStagedSessions()", "public SessionInfo getActiveStagedSession()", "public List<SessionInfo> getActiveStagedSessions()", "public void uninstall(@NonNull String packageName, @NonNull IntentSender statusReceiver)", "public void uninstall(@NonNull String packageName, @DeleteFlags int flags, @NonNull IntentSender statusReceiver)", "public void uninstall(@NonNull VersionedPackage versionedPackage, @NonNull IntentSender statusReceiver)", "public void uninstall(@NonNull VersionedPackage versionedPackage, @DeleteFlags int flags, @NonNull IntentSender statusReceiver)", "public void installExistingPackage(@NonNull String packageName, @InstallReason int installReason, @Nullable IntentSender statusReceiver)", "public void uninstallExistingPackage(@NonNull String packageName, @Nullable IntentSender statusReceiver)", "public void setPermissionsResult(int sessionId, boolean accepted)", "public void addSessionCallback(@NonNull SessionCallback callback)", "public void registerSessionCallback(@NonNull SessionCallback callback)", "public void addSessionCallback(@NonNull SessionCallback callback, @NonNull Handler handler)", "public void registerSessionCallback(@NonNull SessionCallback callback, @NonNull Handler handler)", "public void removeSessionCallback(@NonNull SessionCallback callback)", "public void unregisterSessionCallback(@NonNull SessionCallback callback)" ]
}