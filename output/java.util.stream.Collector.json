{
  "filePath" : "/home/maryam/clearblue/files/android-source-35/java/util/stream/Collector.java",
  "packageName" : "java.util.stream",
  "className" : "Collector",
  "comment" : "\n * A <a href=\"package-summary.html#Reduction\">mutable reduction operation</a> that\n * accumulates input elements into a mutable result container, optionally transforming\n * the accumulated result into a final representation after all input elements\n * have been processed.  Reduction operations can be performed either sequentially\n * or in parallel.\n *\n * <p>Examples of mutable reduction operations include:\n * accumulating elements into a {@code Collection}; concatenating\n * strings using a {@code StringBuilder}; computing summary information about\n * elements such as sum, min, max, or average; computing \"pivot table\" summaries\n * such as \"maximum valued transaction by seller\", etc.  The class {@link Collectors}\n * provides implementations of many common mutable reductions.\n *\n * <p>A {@code Collector} is specified by four functions that work together to\n * accumulate entries into a mutable result container, and optionally perform\n * a final transform on the result.  They are: <ul>\n *     <li>creation of a new result container ({@link #supplier()})</li>\n *     <li>incorporating a new data element into a result container ({@link #accumulator()})</li>\n *     <li>combining two result containers into one ({@link #combiner()})</li>\n *     <li>performing an optional final transform on the container ({@link #finisher()})</li>\n * </ul>\n *\n * <p>Collectors also have a set of characteristics, such as\n * {@link Characteristics#CONCURRENT}, that provide hints that can be used by a\n * reduction implementation to provide better performance.\n *\n * <p>A sequential implementation of a reduction using a collector would\n * create a single result container using the supplier function, and invoke the\n * accumulator function once for each input element.  A parallel implementation\n * would partition the input, create a result container for each partition,\n * accumulate the contents of each partition into a subresult for that partition,\n * and then use the combiner function to merge the subresults into a combined\n * result.\n *\n * <p>To ensure that sequential and parallel executions produce equivalent\n * results, the collector functions must satisfy an <em>identity</em> and an\n * <a href=\"package-summary.html#Associativity\">associativity</a> constraints.\n *\n * <p>The identity constraint says that for any partially accumulated result,\n * combining it with an empty result container must produce an equivalent\n * result.  That is, for a partially accumulated result {@code a} that is the\n * result of any series of accumulator and combiner invocations, {@code a} must\n * be equivalent to {@code combiner.apply(a, supplier.get())}.\n *\n * <p>The associativity constraint says that splitting the computation must\n * produce an equivalent result.  That is, for any input elements {@code t1}\n * and {@code t2}, the results {@code r1} and {@code r2} in the computation\n * below must be equivalent:\n * <pre>{@code\n *     A a1 = supplier.get();\n *     accumulator.accept(a1, t1);\n *     accumulator.accept(a1, t2);\n *     R r1 = finisher.apply(a1);  // result without splitting\n *\n *     A a2 = supplier.get();\n *     accumulator.accept(a2, t1);\n *     A a3 = supplier.get();\n *     accumulator.accept(a3, t2);\n *     R r2 = finisher.apply(combiner.apply(a2, a3));  // result with splitting\n * } </pre>\n *\n * <p>For collectors that do not have the {@code UNORDERED} characteristic,\n * two accumulated results {@code a1} and {@code a2} are equivalent if\n * {@code finisher.apply(a1).equals(finisher.apply(a2))}.  For unordered\n * collectors, equivalence is relaxed to allow for non-equality related to\n * differences in order.  (For example, an unordered collector that accumulated\n * elements to a {@code List} would consider two lists equivalent if they\n * contained the same elements, ignoring order.)\n *\n * <p>Libraries that implement reduction based on {@code Collector}, such as\n * {@link Stream#collect(Collector)}, must adhere to the following constraints:\n * <ul>\n *     <li>The first argument passed to the accumulator function, both\n *     arguments passed to the combiner function, and the argument passed to the\n *     finisher function must be the result of a previous invocation of the\n *     result supplier, accumulator, or combiner functions.</li>\n *     <li>The implementation should not do anything with the result of any of\n *     the result supplier, accumulator, or combiner functions other than to\n *     pass them again to the accumulator, combiner, or finisher functions,\n *     or return them to the caller of the reduction operation.</li>\n *     <li>If a result is passed to the combiner or finisher\n *     function, and the same object is not returned from that function, it is\n *     never used again.</li>\n *     <li>Once a result is passed to the combiner or finisher function, it\n *     is never passed to the accumulator function again.</li>\n *     <li>For non-concurrent collectors, any result returned from the result\n *     supplier, accumulator, or combiner functions must be serially\n *     thread-confined.  This enables collection to occur in parallel without\n *     the {@code Collector} needing to implement any additional synchronization.\n *     The reduction implementation must manage that the input is properly\n *     partitioned, that partitions are processed in isolation, and combining\n *     happens only after accumulation is complete.</li>\n *     <li>For concurrent collectors, an implementation is free to (but not\n *     required to) implement reduction concurrently.  A concurrent reduction\n *     is one where the accumulator function is called concurrently from\n *     multiple threads, using the same concurrently-modifiable result container,\n *     rather than keeping the result isolated during accumulation.\n *     A concurrent reduction should only be applied if the collector has the\n *     {@link Characteristics#UNORDERED} characteristics or if the\n *     originating data is unordered.</li>\n * </ul>\n *\n * <p>In addition to the predefined implementations in {@link Collectors}, the\n * static factory methods {@link #of(Supplier, BiConsumer, BinaryOperator, Characteristics...)}\n * can be used to construct collectors.  For example, you could create a collector\n * that accumulates widgets into a {@code TreeSet} with:\n *\n * <pre>{@code\n *     Collector<Widget, ?, TreeSet<Widget>> intoSet =\n *         Collector.of(TreeSet::new, TreeSet::add,\n *                      (left, right) -> { left.addAll(right); return left; });\n * }</pre>\n *\n * (This behavior is also implemented by the predefined collector\n * {@link Collectors#toCollection(Supplier)}).\n *\n * @apiNote\n * Performing a reduction operation with a {@code Collector} should produce a\n * result equivalent to:\n * <pre>{@code\n *     A container = collector.supplier().get();\n *     for (T t : data)\n *         collector.accumulator().accept(container, t);\n *     return collector.finisher().apply(container);\n * }</pre>\n *\n * <p>However, the library is free to partition the input, perform the reduction\n * on the partitions, and then use the combiner function to combine the partial\n * results to achieve a parallel reduction.  (Depending on the specific reduction\n * operation, this may perform better or worse, depending on the relative cost\n * of the accumulator and combiner functions.)\n *\n * <p>Collectors are designed to be <em>composed</em>; many of the methods\n * in {@link Collectors} are functions that take a collector and produce\n * a new collector.  For example, given the following collector that computes\n * the sum of the salaries of a stream of employees:\n *\n * <pre>{@code\n *     Collector<Employee, ?, Integer> summingSalaries\n *         = Collectors.summingInt(Employee::getSalary))\n * }</pre>\n *\n * If we wanted to create a collector to tabulate the sum of salaries by\n * department, we could reuse the \"sum of salaries\" logic using\n * {@link Collectors#groupingBy(Function, Collector)}:\n *\n * <pre>{@code\n *     Collector<Employee, ?, Map<Department, Integer>> summingSalariesByDept\n *         = Collectors.groupingBy(Employee::getDepartment, summingSalaries);\n * }</pre>\n *\n * @see Stream#collect(Collector)\n * @see Collectors\n *\n * @param <T> the type of input elements to the reduction operation\n * @param <A> the mutable accumulation type of the reduction operation (often\n *            hidden as an implementation detail)\n * @param <R> the result type of the reduction operation\n * @since 1.8\n ",
  "links" : [ "#accumulator()", "#combiner()", "#CONCURRENT", "#UNORDERED", "#of(Supplier", "#supplier()", "java.util.stream.Collectors#toCollection(Supplier)", "java.util.stream.Stream#collect(Collector)", "#finisher()", "java.util.stream.Collectors", "java.util.stream.Collectors#groupingBy(Function" ],
  "variables" : [ ],
  "methods" : [ {
    "name" : " Supplier<A> supplier()",
    "returnType" : "Supplier<A>",
    "comment" : "\n     * A function that creates and returns a new mutable result container.\n     *\n     * @return a function which returns a new, mutable result container\n     ",
    "links" : [ ]
  }, {
    "name" : " BiConsumer<A, T> accumulator()",
    "returnType" : "BiConsumer<A, T>",
    "comment" : "\n     * A function that folds a value into a mutable result container.\n     *\n     * @return a function which folds a value into a mutable result container\n     ",
    "links" : [ ]
  }, {
    "name" : " BinaryOperator<A> combiner()",
    "returnType" : "BinaryOperator<A>",
    "comment" : "\n     * A function that accepts two partial results and merges them.  The\n     * combiner function may fold state from one argument into the other and\n     * return that, or may return a new result container.\n     *\n     * @return a function which combines two partial results into a combined\n     * result\n     ",
    "links" : [ ]
  }, {
    "name" : " Function<A, R> finisher()",
    "returnType" : "Function<A, R>",
    "comment" : "\n     * Perform the final transformation from the intermediate accumulation type\n     * {@code A} to the final result type {@code R}.\n     *\n     * <p>If the characteristic {@code IDENTITY_FINISH} is\n     * set, this function may be presumed to be an identity transform with an\n     * unchecked cast from {@code A} to {@code R}.\n     *\n     * @return a function which transforms the intermediate result to the final\n     * result\n     ",
    "links" : [ ]
  }, {
    "name" : " Set<Characteristics> characteristics()",
    "returnType" : "Set<Characteristics>",
    "comment" : "\n     * Returns a {@code Set} of {@code Collector.Characteristics} indicating\n     * the characteristics of this Collector.  This set should be immutable.\n     *\n     * @return an immutable set of collector characteristics\n     ",
    "links" : [ ]
  }, {
    "name" : "public static Collector<T, R, R> of(Supplier<R> supplier, BiConsumer<R, T> accumulator, BinaryOperator<R> combiner, Characteristics... characteristics)",
    "returnType" : "Collector<T, R, R>",
    "comment" : "\n     * Returns a new {@code Collector} described by the given {@code supplier},\n     * {@code accumulator}, and {@code combiner} functions.  The resulting\n     * {@code Collector} has the {@code Collector.Characteristics.IDENTITY_FINISH}\n     * characteristic.\n     *\n     * @param supplier The supplier function for the new collector\n     * @param accumulator The accumulator function for the new collector\n     * @param combiner The combiner function for the new collector\n     * @param characteristics The collector characteristics for the new\n     *                        collector\n     * @param <T> The type of input elements for the new collector\n     * @param <R> The type of intermediate accumulation result, and final result,\n     *           for the new collector\n     * @throws NullPointerException if any argument is null\n     * @return the new {@code Collector}\n     ",
    "links" : [ ]
  }, {
    "name" : "public static Collector<T, A, R> of(Supplier<A> supplier, BiConsumer<A, T> accumulator, BinaryOperator<A> combiner, Function<A, R> finisher, Characteristics... characteristics)",
    "returnType" : "Collector<T, A, R>",
    "comment" : "\n     * Returns a new {@code Collector} described by the given {@code supplier},\n     * {@code accumulator}, {@code combiner}, and {@code finisher} functions.\n     *\n     * @param supplier The supplier function for the new collector\n     * @param accumulator The accumulator function for the new collector\n     * @param combiner The combiner function for the new collector\n     * @param finisher The finisher function for the new collector\n     * @param characteristics The collector characteristics for the new\n     *                        collector\n     * @param <T> The type of input elements for the new collector\n     * @param <A> The intermediate accumulation type of the new collector\n     * @param <R> The final result type of the new collector\n     * @throws NullPointerException if any argument is null\n     * @return the new {@code Collector}\n     ",
    "links" : [ ]
  } ],
  "methodNames" : [ " Supplier<A> supplier()", " BiConsumer<A, T> accumulator()", " BinaryOperator<A> combiner()", " Function<A, R> finisher()", " Set<Characteristics> characteristics()", "public static Collector<T, R, R> of(Supplier<R> supplier, BiConsumer<R, T> accumulator, BinaryOperator<R> combiner, Characteristics... characteristics)", "public static Collector<T, A, R> of(Supplier<A> supplier, BiConsumer<A, T> accumulator, BinaryOperator<A> combiner, Function<A, R> finisher, Characteristics... characteristics)" ],
  "variableNames" : [ ]
}