{
  "filePath" : "/home/maryam/clearblue/files/android-source-35/java/nio/channels/ScatteringByteChannel.java",
  "packageName" : "java.nio.channels",
  "className" : "ScatteringByteChannel",
  "comment" : "",
  "links" : [ ],
  "variables" : [ ],
  "methods" : [ {
    "name" : "public long read(ByteBuffer[] dsts, int offset, int length) throws IOException",
    "returnType" : "long",
    "comment" : "\n     * Reads a sequence of bytes from this channel into a subsequence of the\n     * given buffers.\n     *\n     * <p> An invocation of this method attempts to read up to <i>r</i> bytes\n     * from this channel, where <i>r</i> is the total number of bytes remaining\n     * the specified subsequence of the given buffer array, that is,\n     *\n     * <blockquote><pre>\n     * dsts[offset].remaining()\n     *     + dsts[offset+1].remaining()\n     *     + ... + dsts[offset+length-1].remaining()</pre></blockquote>\n     *\n     * at the moment that this method is invoked.\n     *\n     * <p> Suppose that a byte sequence of length <i>n</i> is read, where\n     * {@code 0}&nbsp;{@code <=}&nbsp;<i>n</i>&nbsp;{@code <=}&nbsp;<i>r</i>.\n     * Up to the first {@code dsts[offset].remaining()} bytes of this sequence\n     * are transferred into buffer {@code dsts[offset]}, up to the next\n     * {@code dsts[offset+1].remaining()} bytes are transferred into buffer\n     * {@code dsts[offset+1]}, and so forth, until the entire byte sequence\n     * is transferred into the given buffers.  As many bytes as possible are\n     * transferred into each buffer, hence the final position of each updated\n     * buffer, except the last updated buffer, is guaranteed to be equal to\n     * that buffer's limit.\n     *\n     * <p> This method may be invoked at any time.  If another thread has\n     * already initiated a read operation upon this channel, however, then an\n     * invocation of this method will block until the first operation is\n     * complete. </p>\n     *\n     * @param  dsts\n     *         The buffers into which bytes are to be transferred\n     *\n     * @param  offset\n     *         The offset within the buffer array of the first buffer into\n     *         which bytes are to be transferred; must be non-negative and no\n     *         larger than {@code dsts.length}\n     *\n     * @param  length\n     *         The maximum number of buffers to be accessed; must be\n     *         non-negative and no larger than\n     *         {@code dsts.length}&nbsp;-&nbsp;{@code offset}\n     *\n     * @return The number of bytes read, possibly zero,\n     *         or {@code -1} if the channel has reached end-of-stream\n     *\n     * @throws  IndexOutOfBoundsException\n     *          If the preconditions on the {@code offset} and {@code length}\n     *          parameters do not hold\n     *\n     * @throws  NonReadableChannelException\n     *          If this channel was not opened for reading\n     *\n     * @throws  ClosedChannelException\n     *          If this channel is closed\n     *\n     * @throws  AsynchronousCloseException\n     *          If another thread closes this channel\n     *          while the read operation is in progress\n     *\n     * @throws  ClosedByInterruptException\n     *          If another thread interrupts the current thread\n     *          while the read operation is in progress, thereby\n     *          closing the channel and setting the current thread's\n     *          interrupt status\n     *\n     * @throws  IOException\n     *          If some other I/O error occurs\n     ",
    "links" : [ ]
  }, {
    "name" : "public long read(ByteBuffer[] dsts) throws IOException",
    "returnType" : "long",
    "comment" : "\n     * Reads a sequence of bytes from this channel into the given buffers.\n     *\n     * <p> An invocation of this method of the form {@code c.read(dsts)}\n     * behaves in exactly the same manner as the invocation\n     *\n     * <blockquote><pre>\n     * c.read(dsts, 0, dsts.length);</pre></blockquote>\n     *\n     * @param  dsts\n     *         The buffers into which bytes are to be transferred\n     *\n     * @return The number of bytes read, possibly zero,\n     *         or {@code -1} if the channel has reached end-of-stream\n     *\n     * @throws  NonReadableChannelException\n     *          If this channel was not opened for reading\n     *\n     * @throws  ClosedChannelException\n     *          If this channel is closed\n     *\n     * @throws  AsynchronousCloseException\n     *          If another thread closes this channel\n     *          while the read operation is in progress\n     *\n     * @throws  ClosedByInterruptException\n     *          If another thread interrupts the current thread\n     *          while the read operation is in progress, thereby\n     *          closing the channel and setting the current thread's\n     *          interrupt status\n     *\n     * @throws  IOException\n     *          If some other I/O error occurs\n     ",
    "links" : [ ]
  } ],
  "methodNames" : [ "public long read(ByteBuffer[] dsts, int offset, int length) throws IOException", "public long read(ByteBuffer[] dsts) throws IOException" ],
  "variableNames" : [ ]
}