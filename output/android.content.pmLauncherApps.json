{
  "filePath" : "/home/maryam/clearblue/files/android-source-30/android/content/pm/LauncherApps.java",
  "packageName" : "android.content.pm",
  "className" : "LauncherApps",
  "comment" : "\n * Class for retrieving a list of launchable activities for the current user and any associated\n * managed profiles that are visible to the current user, which can be retrieved with\n * {@link #getProfiles}. This is mainly for use by launchers.\n *\n * Apps can be queried for each user profile.\n * Since the PackageManager will not deliver package broadcasts for other profiles, you can register\n * for package changes here.\n * <p>\n * To watch for managed profiles being added or removed, register for the following broadcasts:\n * {@link Intent#ACTION_MANAGED_PROFILE_ADDED} and {@link Intent#ACTION_MANAGED_PROFILE_REMOVED}.\n * <p>\n * Note as of Android O, apps on a managed profile are no longer allowed to access apps on the\n * main profile.  Apps can only access profiles returned by {@link #getProfiles()}.\n ",
  "variables" : [ {
    "name" : "TAG",
    "type" : "String",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "DEBUG",
    "type" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "ACTION_CONFIRM_PIN_SHORTCUT",
    "type" : "String",
    "comment" : "\n     * Activity Action: For the default launcher to show the confirmation dialog to create\n     * a pinned shortcut.\n     *\n     * <p>See the {@link ShortcutManager} javadoc for details.\n     *\n     * <p>\n     * Use {@link #getPinItemRequest(Intent)} to get a {@link PinItemRequest} object,\n     * and call {@link PinItemRequest#accept(Bundle)}\n     * if the user accepts.  If the user doesn't accept, no further action is required.\n     *\n     * @see #EXTRA_PIN_ITEM_REQUEST\n     ",
    "links" : [ "ShortcutManager", "#getPinItemRequest", "PinItemRequest", "PinItemRequest#accept" ]
  }, {
    "name" : "ACTION_CONFIRM_PIN_APPWIDGET",
    "type" : "String",
    "comment" : "\n     * Activity Action: For the default launcher to show the confirmation dialog to create\n     * a pinned app widget.\n     *\n     * <p>See the {@link android.appwidget.AppWidgetManager#requestPinAppWidget} javadoc for\n     * details.\n     *\n     * <p>\n     * Use {@link #getPinItemRequest(Intent)} to get a {@link PinItemRequest} object,\n     * and call {@link PinItemRequest#accept(Bundle)}\n     * if the user accepts.  If the user doesn't accept, no further action is required.\n     *\n     * @see #EXTRA_PIN_ITEM_REQUEST\n     ",
    "links" : [ "android.appwidget.AppWidgetManager#requestPinAppWidget", "#getPinItemRequest", "PinItemRequest", "PinItemRequest#accept" ]
  }, {
    "name" : "EXTRA_PIN_ITEM_REQUEST",
    "type" : "String",
    "comment" : "\n     * An extra for {@link #ACTION_CONFIRM_PIN_SHORTCUT} &amp; {@link #ACTION_CONFIRM_PIN_APPWIDGET}\n     * containing a {@link PinItemRequest} of appropriate type asked to pin.\n     *\n     * <p>A helper function {@link #getPinItemRequest(Intent)} can be used\n     * instead of using this constant directly.\n     *\n     * @see #ACTION_CONFIRM_PIN_SHORTCUT\n     * @see #ACTION_CONFIRM_PIN_APPWIDGET\n     ",
    "links" : [ "#ACTION_CONFIRM_PIN_SHORTCUT", "#ACTION_CONFIRM_PIN_APPWIDGET", "PinItemRequest", "#getPinItemRequest" ]
  }, {
    "name" : "FLAG_CACHE_NOTIFICATION_SHORTCUTS",
    "type" : "int",
    "comment" : "\n     * Cache shortcuts which are used in notifications.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "FLAG_CACHE_BUBBLE_SHORTCUTS",
    "type" : "int",
    "comment" : "\n     * Cache shortcuts which are used in bubbles.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "mContext",
    "type" : "Context",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mService",
    "type" : "ILauncherApps",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mPm",
    "type" : "PackageManager",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mUserManager",
    "type" : "UserManager",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mCallbacks",
    "type" : "List<CallbackMessageHandler>",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mDelegates",
    "type" : "List<SessionCallbackDelegate>",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mShortcutChangeCallbacks",
    "type" : "Map<ShortcutChangeCallback, Pair<Executor, IShortcutChangeCallback>>",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mAppsChangedListener",
    "type" : "IOnAppsChangedListener.Stub",
    "comment" : "",
    "links" : [ ]
  } ],
  "methods" : [ {
    "name" : "private void logErrorForInvalidProfileAccess(@NonNull UserHandle target)",
    "returnType" : "void",
    "comment" : "\n     * Show an error log on logcat, when the calling user is a managed profile, the target\n     * user is different from the calling user, and it is not called from a package that has the\n     * {@link permission.INTERACT_ACROSS_USERS_FULL} permission, in order to help\n     * developers to detect it.\n     ",
    "links" : [ "permission.INTERACT_ACROSS_USERS_FULL" ]
  }, {
    "name" : "public List<UserHandle> getProfiles()",
    "returnType" : "List<UserHandle>",
    "comment" : "\n     * Return a list of profiles that the caller can access via the {@link LauncherApps} APIs.\n     *\n     * <p>If the caller is running on a managed profile, it'll return only the current profile.\n     * Otherwise it'll return the same list as {@link UserManager#getUserProfiles()} would.\n     ",
    "links" : [ "LauncherApps", "UserManager#getUserProfiles" ]
  }, {
    "name" : "public List<LauncherActivityInfo> getActivityList(String packageName, UserHandle user)",
    "returnType" : "List<LauncherActivityInfo>",
    "comment" : "\n     * Retrieves a list of activities that specify {@link Intent#ACTION_MAIN} and\n     * {@link Intent#CATEGORY_LAUNCHER}, across all apps, for a specified user. If an app doesn't\n     * have any activities that specify <code>ACTION_MAIN</code> or <code>CATEGORY_LAUNCHER</code>,\n     * the system adds a synthesized activity to the list. This synthesized activity represents the\n     * app's details page within system settings.\n     *\n     * <p class=\"note\"><b>Note: </b>It's possible for system apps, such as app stores, to prevent\n     * the system from adding synthesized activities to the returned list.</p>\n     *\n     * <p>As of <a href=\"/reference/android/os/Build.VERSION_CODES.html#Q\">Android Q</a>, at least\n     * one of the app's activities or synthesized activities appears in the returned list unless the\n     * app satisfies at least one of the following conditions:</p>\n     * <ul>\n     * <li>The app is a system app.</li>\n     * <li>The app doesn't request any <a href=\"/guide/topics/permissions/overview\">permissions</a>.\n     * </li>\n     * <li>The app doesn't have a <em>launcher activity</em> that is enabled by default. A launcher\n     * activity has an intent containing the <code>ACTION_MAIN</code> action and the\n     * <code>CATEGORY_LAUNCHER</code> category.</li>\n     * </ul>\n     *\n     * <p>Additionally, the system hides synthesized activities for some or all apps in the\n     * following enterprise-related cases:</p>\n     * <ul>\n     * <li>If the device is a\n     * <a href=\"https://developers.google.com/android/work/overview#company-owned-devices-for-knowledge-workers\">fully\n     * managed device</a>, no synthesized activities for any app appear in the returned list.</li>\n     * <li>If the current user has a\n     * <a href=\"https://developers.google.com/android/work/overview#employee-owned-devices-byod\">work\n     * profile</a>, no synthesized activities for the user's work apps appear in the returned\n     * list.</li>\n     * </ul>\n     *\n     * @param packageName The specific package to query. If null, it checks all installed packages\n     *            in the profile.\n     * @param user The UserHandle of the profile.\n     * @return List of launchable activities. Can be an empty list but will not be null.\n     ",
    "links" : [ "Intent#ACTION_MAIN", "Intent#CATEGORY_LAUNCHER" ]
  }, {
    "name" : "public LauncherActivityInfo resolveActivity(Intent intent, UserHandle user)",
    "returnType" : "LauncherActivityInfo",
    "comment" : "\n     * Returns the activity info for a given intent and user handle, if it resolves. Otherwise it\n     * returns null.\n     *\n     * @param intent The intent to find a match for.\n     * @param user The profile to look in for a match.\n     * @return An activity info object if there is a match.\n     ",
    "links" : [ ]
  }, {
    "name" : "public void startMainActivity(ComponentName component, UserHandle user, Rect sourceBounds, Bundle opts)",
    "returnType" : "void",
    "comment" : "\n     * Starts a Main activity in the specified profile.\n     *\n     * @param component The ComponentName of the activity to launch\n     * @param user The UserHandle of the profile\n     * @param sourceBounds The Rect containing the source bounds of the clicked icon\n     * @param opts Options to pass to startActivity\n     ",
    "links" : [ ]
  }, {
    "name" : "public void startPackageInstallerSessionDetailsActivity(@NonNull SessionInfo sessionInfo, @Nullable Rect sourceBounds, @Nullable Bundle opts)",
    "returnType" : "void",
    "comment" : "\n     * Starts an activity to show the details of the specified session.\n     *\n     * @param sessionInfo The SessionInfo of the session\n     * @param sourceBounds The Rect containing the source bounds of the clicked icon\n     * @param opts Options to pass to startActivity\n     ",
    "links" : [ ]
  }, {
    "name" : "public void startAppDetailsActivity(ComponentName component, UserHandle user, Rect sourceBounds, Bundle opts)",
    "returnType" : "void",
    "comment" : "\n     * Starts the settings activity to show the application details for a\n     * package in the specified profile.\n     *\n     * @param component The ComponentName of the package to launch settings for.\n     * @param user The UserHandle of the profile\n     * @param sourceBounds The Rect containing the source bounds of the clicked icon\n     * @param opts Options to pass to startActivity\n     ",
    "links" : [ ]
  }, {
    "name" : "public List<LauncherActivityInfo> getShortcutConfigActivityList(@Nullable String packageName, @NonNull UserHandle user)",
    "returnType" : "List<LauncherActivityInfo>",
    "comment" : "\n     * Retrieves a list of config activities for creating {@link ShortcutInfo}.\n     *\n     * @param packageName The specific package to query. If null, it checks all installed packages\n     *            in the profile.\n     * @param user The UserHandle of the profile.\n     * @return List of config activities. Can be an empty list but will not be null.\n     *\n     * @see Intent#ACTION_CREATE_SHORTCUT\n     * @see #getShortcutConfigActivityIntent(LauncherActivityInfo)\n     ",
    "links" : [ "ShortcutInfo" ]
  }, {
    "name" : "private List<LauncherActivityInfo> convertToActivityList(@Nullable ParceledListSlice<ResolveInfo> activities, UserHandle user)",
    "returnType" : "List<LauncherActivityInfo>",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public IntentSender getShortcutConfigActivityIntent(@NonNull LauncherActivityInfo info)",
    "returnType" : "IntentSender",
    "comment" : "\n     * Returns an intent sender which can be used to start the configure activity for creating\n     * custom shortcuts. Use this method if the provider is in another profile as you are not\n     * allowed to start an activity in another profile.\n     *\n     * <p>The caller should receive {@link PinItemRequest} in onActivityResult on\n     * {@link android.app.Activity#RESULT_OK}.\n     *\n     * <p>Callers must be allowed to access the shortcut information, as defined in {@link\n     * #hasShortcutHostPermission()}.\n     *\n     * @param info a configuration activity returned by {@link #getShortcutConfigActivityList}\n     *\n     * @throws IllegalStateException when the user is locked or not running.\n     * @throws SecurityException if {@link #hasShortcutHostPermission()} is false.\n     *\n     * @see #getPinItemRequest(Intent)\n     * @see Intent#ACTION_CREATE_SHORTCUT\n     * @see android.app.Activity#startIntentSenderForResult\n     ",
    "links" : [ "PinItemRequest", "android.app.Activity#RESULT_OK", "#getShortcutConfigActivityList", "#hasShortcutHostPermission" ]
  }, {
    "name" : "public boolean isPackageEnabled(String packageName, UserHandle user)",
    "returnType" : "boolean",
    "comment" : "\n     * Checks if the package is installed and enabled for a profile.\n     *\n     * @param packageName The package to check.\n     * @param user The UserHandle of the profile.\n     *\n     * @return true if the package exists and is enabled.\n     ",
    "links" : [ ]
  }, {
    "name" : "public Bundle getSuspendedPackageLauncherExtras(String packageName, UserHandle user)",
    "returnType" : "Bundle",
    "comment" : "\n     * Gets the launcher extras supplied to the system when the given package was suspended via\n     * {@code PackageManager#setPackagesSuspended(String[], boolean, PersistableBundle,\n     * PersistableBundle, String)}.\n     *\n     * <p>The contents of this {@link Bundle} are supposed to be a contract between the suspending\n     * app and the launcher.\n     *\n     * <p>Note: This just returns whatever extras were provided to the system, <em>which might\n     * even be {@code null}.</em>\n     *\n     * @param packageName The package for which to fetch the launcher extras.\n     * @param user The {@link UserHandle} of the profile.\n     * @return A {@link Bundle} of launcher extras. Or {@code null} if the package is not currently\n     *         suspended.\n     *\n     * @see Callback#onPackagesSuspended(String[], UserHandle, Bundle)\n     * @see PackageManager#isPackageSuspended()\n     ",
    "links" : [ "Bundle", "UserHandle", "Bundle" ]
  }, {
    "name" : "public boolean shouldHideFromSuggestions(@NonNull String packageName, @NonNull UserHandle user)",
    "returnType" : "boolean",
    "comment" : "\n     * Returns whether a package should be hidden from suggestions to the user. Currently, this\n     * could be done because the package was marked as distracting to the user via\n     * {@code PackageManager.setDistractingPackageRestrictions(String[], int)}.\n     *\n     * @param packageName The package for which to check.\n     * @param user the {@link UserHandle} of the profile.\n     * @return\n     ",
    "links" : [ "UserHandle" ]
  }, {
    "name" : "public ApplicationInfo getApplicationInfo(@NonNull String packageName, @ApplicationInfoFlags int flags, @NonNull UserHandle user) throws PackageManager.NameNotFoundException",
    "returnType" : "ApplicationInfo",
    "comment" : "\n     * Returns {@link ApplicationInfo} about an application installed for a specific user profile.\n     *\n     * @param packageName The package name of the application\n     * @param flags Additional option flags {@link PackageManager#getApplicationInfo}\n     * @param user The UserHandle of the profile.\n     *\n     * @return {@link ApplicationInfo} containing information about the package. Returns\n     *         {@code null} if the package isn't installed for the given profile, or the profile\n     *         isn't enabled.\n     ",
    "links" : [ "ApplicationInfo", "PackageManager#getApplicationInfo", "ApplicationInfo" ]
  }, {
    "name" : "public LauncherApps.AppUsageLimit getAppUsageLimit(@NonNull String packageName, @NonNull UserHandle user)",
    "returnType" : "LauncherApps.AppUsageLimit",
    "comment" : "\n     * Returns an object describing the app usage limit for the given package.\n     * If there are multiple limits that apply to the package, the one with the smallest\n     * time remaining will be returned.\n     *\n     * @param packageName name of the package whose app usage limit will be returned\n     * @param user the user of the package\n     *\n     * @return an {@link AppUsageLimit} object describing the app time limit containing\n     * the given package with the smallest time remaining, or {@code null} if none exist.\n     * @throws SecurityException when the caller is not the recents app.\n     * @hide\n     ",
    "links" : [ "AppUsageLimit" ]
  }, {
    "name" : "public boolean isActivityEnabled(ComponentName component, UserHandle user)",
    "returnType" : "boolean",
    "comment" : "\n     * Checks if the activity exists and it enabled for a profile.\n     *\n     * <p>The activity may still not be exported, in which case {@link #startMainActivity} will\n     * throw a {@link SecurityException} unless the caller has the same UID as the target app's.\n     *\n     * @param component The activity to check.\n     * @param user The UserHandle of the profile.\n     *\n     * @return true if the activity exists and is enabled.\n     ",
    "links" : [ "#startMainActivity", "SecurityException" ]
  }, {
    "name" : "public boolean hasShortcutHostPermission()",
    "returnType" : "boolean",
    "comment" : "\n     * Returns whether the caller can access the shortcut information.  Access is currently\n     * available to:\n     *\n     * <ul>\n     *     <li>The current launcher (or default launcher if there is no set current launcher).</li>\n     *     <li>The currently active voice interaction service.</li>\n     * </ul>\n     *\n     * <p>Note when this method returns {@code false}, it may be a temporary situation because\n     * the user is trying a new launcher application.  The user may decide to change the default\n     * launcher back to the calling application again, so even if a launcher application loses\n     * this permission, it does <b>not</b> have to purge pinned shortcut information.\n     * If the calling launcher application contains pinned shortcuts, they will still work,\n     * even though the caller no longer has the shortcut host permission.\n     *\n     * @throws IllegalStateException when the user is locked.\n     *\n     * @see ShortcutManager\n     ",
    "links" : [ ]
  }, {
    "name" : "private List<ShortcutInfo> maybeUpdateDisabledMessage(List<ShortcutInfo> shortcuts)",
    "returnType" : "List<ShortcutInfo>",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public List<ShortcutInfo> getShortcuts(@NonNull ShortcutQuery query, @NonNull UserHandle user)",
    "returnType" : "List<ShortcutInfo>",
    "comment" : "\n     * Returns {@link ShortcutInfo}s that match {@code query}.\n     *\n     * <p>Callers must be allowed to access the shortcut information, as defined in {@link\n     * #hasShortcutHostPermission()}.\n     *\n     * @param query result includes shortcuts matching this query.\n     * @param user The UserHandle of the profile.\n     *\n     * @return the IDs of {@link ShortcutInfo}s that match the query.\n     * @throws IllegalStateException when the user is locked, or when the {@code user} user\n     * is locked or not running.\n     *\n     * @see ShortcutManager\n     ",
    "links" : [ "ShortcutInfo", "ShortcutInfo" ]
  }, {
    "name" : "public List<ShortcutInfo> getShortcutInfo(@NonNull String packageName, @NonNull List<String> ids, @NonNull UserHandle user)",
    "returnType" : "List<ShortcutInfo>",
    "comment" : "\n     * @hide // No longer used.  Use getShortcuts() instead.  Kept for unit tests.\n     ",
    "links" : [ ]
  }, {
    "name" : "public void pinShortcuts(@NonNull String packageName, @NonNull List<String> shortcutIds, @NonNull UserHandle user)",
    "returnType" : "void",
    "comment" : "\n     * Pin shortcuts on a package.\n     *\n     * <p>This API is <b>NOT</b> cumulative; this will replace all pinned shortcuts for the package.\n     * However, different launchers may have different set of pinned shortcuts.\n     *\n     * <p>The calling launcher application must be allowed to access the shortcut information,\n     * as defined in {@link #hasShortcutHostPermission()}.\n     *\n     * @param packageName The target package name.\n     * @param shortcutIds The IDs of the shortcut to be pinned.\n     * @param user The UserHandle of the profile.\n     * @throws IllegalStateException when the user is locked, or when the {@code user} user\n     * is locked or not running.\n     *\n     * @see ShortcutManager\n     ",
    "links" : [ "#hasShortcutHostPermission" ]
  }, {
    "name" : "public void cacheShortcuts(@NonNull String packageName, @NonNull List<String> shortcutIds, @NonNull UserHandle user, @ShortcutCacheFlags int cacheFlags)",
    "returnType" : "void",
    "comment" : "\n     * Mark shortcuts as cached for a package.\n     *\n     * <p>Only dynamic long lived shortcuts can be cached. None dynamic or non long lived shortcuts\n     * in the list will be ignored.\n     *\n     * <p>Unlike pinned shortcuts, where different callers can have different sets of pinned\n     * shortcuts, cached state is per shortcut only, and even if multiple callers cache the same\n     * shortcut, it can be uncached by any valid caller.\n     *\n     * @param packageName The target package name.\n     * @param shortcutIds The IDs of the shortcut to be cached.\n     * @param user The UserHandle of the profile.\n     * @param cacheFlags One of the values in:\n     * <ul>\n     *     <li>{@link #FLAG_CACHE_NOTIFICATION_SHORTCUTS}\n     *     <li>{@link #FLAG_CACHE_BUBBLE_SHORTCUTS}\n     * </ul>\n     * @throws IllegalStateException when the user is locked, or when the {@code user} user\n     * is locked or not running.\n     *\n     * @see ShortcutManager\n     *\n     * @hide\n     ",
    "links" : [ "#FLAG_CACHE_NOTIFICATION_SHORTCUTS", "#FLAG_CACHE_BUBBLE_SHORTCUTS" ]
  }, {
    "name" : "public void uncacheShortcuts(@NonNull String packageName, @NonNull List<String> shortcutIds, @NonNull UserHandle user, @ShortcutCacheFlags int cacheFlags)",
    "returnType" : "void",
    "comment" : "\n     * Remove cached flag from shortcuts for a package.\n     *\n     * @param packageName The target package name.\n     * @param shortcutIds The IDs of the shortcut to be uncached.\n     * @param user The UserHandle of the profile.\n     * @param cacheFlags One of the values in:\n     * <ul>\n     *     <li>{@link #FLAG_CACHE_NOTIFICATION_SHORTCUTS}\n     *     <li>{@link #FLAG_CACHE_BUBBLE_SHORTCUTS}\n     * </ul>\n     * @throws IllegalStateException when the user is locked, or when the {@code user} user\n     * is locked or not running.\n     *\n     * @see ShortcutManager\n     *\n     * @hide\n     ",
    "links" : [ "#FLAG_CACHE_NOTIFICATION_SHORTCUTS", "#FLAG_CACHE_BUBBLE_SHORTCUTS" ]
  }, {
    "name" : "public int getShortcutIconResId(@NonNull ShortcutInfo shortcut)",
    "returnType" : "int",
    "comment" : "\n     * @hide kept for testing.\n     ",
    "links" : [ ]
  }, {
    "name" : "public int getShortcutIconResId(@NonNull String packageName, @NonNull String shortcutId, @NonNull UserHandle user)",
    "returnType" : "int",
    "comment" : "\n     * @hide kept for testing.\n     ",
    "links" : [ ]
  }, {
    "name" : "public ParcelFileDescriptor getShortcutIconFd(@NonNull ShortcutInfo shortcut)",
    "returnType" : "ParcelFileDescriptor",
    "comment" : "\n     * @hide internal/unit tests only\n     ",
    "links" : [ ]
  }, {
    "name" : "public ParcelFileDescriptor getShortcutIconFd(@NonNull String packageName, @NonNull String shortcutId, @NonNull UserHandle user)",
    "returnType" : "ParcelFileDescriptor",
    "comment" : "\n     * @hide internal/unit tests only\n     ",
    "links" : [ ]
  }, {
    "name" : "private ParcelFileDescriptor getShortcutIconFd(@NonNull String packageName, @NonNull String shortcutId, int userId)",
    "returnType" : "ParcelFileDescriptor",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public ParcelFileDescriptor getUriShortcutIconFd(@NonNull ShortcutInfo shortcut)",
    "returnType" : "ParcelFileDescriptor",
    "comment" : "\n     * @hide internal/unit tests only\n     ",
    "links" : [ ]
  }, {
    "name" : "private ParcelFileDescriptor getUriShortcutIconFd(@NonNull String packageName, @NonNull String shortcutId, int userId)",
    "returnType" : "ParcelFileDescriptor",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private String getShortcutIconUri(@NonNull String packageName, @NonNull String shortcutId, int userId)",
    "returnType" : "String",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public Drawable getShortcutIconDrawable(@NonNull ShortcutInfo shortcut, int density)",
    "returnType" : "Drawable",
    "comment" : "\n     * Returns the icon for this shortcut, without any badging for the profile.\n     *\n     * <p>The calling launcher application must be allowed to access the shortcut information,\n     * as defined in {@link #hasShortcutHostPermission()}.\n     *\n     * @param density The preferred density of the icon, zero for default density. Use\n     * density DPI values from {@link DisplayMetrics}.\n     *\n     * @return The drawable associated with the shortcut.\n     * @throws IllegalStateException when the user is locked, or when the {@code user} user\n     * is locked or not running.\n     *\n     * @see ShortcutManager\n     * @see #getShortcutBadgedIconDrawable(ShortcutInfo, int)\n     * @see DisplayMetrics\n     ",
    "links" : [ "#hasShortcutHostPermission", "DisplayMetrics" ]
  }, {
    "name" : "private Drawable loadDrawableFromFileDescriptor(ParcelFileDescriptor pfd, boolean adaptive)",
    "returnType" : "Drawable",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public Icon getShortcutIcon(@NonNull ShortcutInfo shortcut)",
    "returnType" : "Icon",
    "comment" : "\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "private Drawable loadDrawableResourceFromPackage(String packageName, int resId, UserHandle user, int density)",
    "returnType" : "Drawable",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public Drawable getShortcutBadgedIconDrawable(ShortcutInfo shortcut, int density)",
    "returnType" : "Drawable",
    "comment" : "\n     * Returns the shortcut icon with badging appropriate for the profile.\n     *\n     * <p>The calling launcher application must be allowed to access the shortcut information,\n     * as defined in {@link #hasShortcutHostPermission()}.\n     *\n     * @param density Optional density for the icon, or 0 to use the default density. Use\n     * @return A badged icon for the shortcut.\n     * @throws IllegalStateException when the user is locked, or when the {@code user} user\n     * is locked or not running.\n     *\n     * @see ShortcutManager\n     * @see #getShortcutIconDrawable(ShortcutInfo, int)\n     * @see DisplayMetrics\n     ",
    "links" : [ "#hasShortcutHostPermission" ]
  }, {
    "name" : "public void startShortcut(@NonNull String packageName, @NonNull String shortcutId, @Nullable Rect sourceBounds, @Nullable Bundle startActivityOptions, @NonNull UserHandle user)",
    "returnType" : "void",
    "comment" : "\n     * Starts a shortcut.\n     *\n     * <p>The calling launcher application must be allowed to access the shortcut information,\n     * as defined in {@link #hasShortcutHostPermission()}.\n     *\n     * @param packageName The target shortcut package name.\n     * @param shortcutId The target shortcut ID.\n     * @param sourceBounds The Rect containing the source bounds of the clicked icon.\n     * @param startActivityOptions Options to pass to startActivity.\n     * @param user The UserHandle of the profile.\n     * @throws IllegalStateException when the user is locked, or when the {@code user} user\n     * is locked or not running.\n     *\n     * @throws android.content.ActivityNotFoundException failed to start shortcut. (e.g.\n     * the shortcut no longer exists, is disabled, the intent receiver activity doesn't exist, etc)\n     ",
    "links" : [ "#hasShortcutHostPermission" ]
  }, {
    "name" : "public void startShortcut(@NonNull ShortcutInfo shortcut, @Nullable Rect sourceBounds, @Nullable Bundle startActivityOptions)",
    "returnType" : "void",
    "comment" : "\n     * Launches a shortcut.\n     *\n     * <p>The calling launcher application must be allowed to access the shortcut information,\n     * as defined in {@link #hasShortcutHostPermission()}.\n     *\n     * @param shortcut The target shortcut.\n     * @param sourceBounds The Rect containing the source bounds of the clicked icon.\n     * @param startActivityOptions Options to pass to startActivity.\n     * @throws IllegalStateException when the user is locked, or when the {@code user} user\n     * is locked or not running.\n     *\n     * @throws android.content.ActivityNotFoundException failed to start shortcut. (e.g.\n     * the shortcut no longer exists, is disabled, the intent receiver activity doesn't exist, etc)\n     ",
    "links" : [ "#hasShortcutHostPermission" ]
  }, {
    "name" : "private void startShortcut(@NonNull String packageName, @NonNull String shortcutId, @Nullable Rect sourceBounds, @Nullable Bundle startActivityOptions, int userId)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public void registerCallback(Callback callback)",
    "returnType" : "void",
    "comment" : "\n     * Registers a callback for changes to packages in this user and managed profiles.\n     *\n     * @param callback The callback to register.\n     ",
    "links" : [ ]
  }, {
    "name" : "public void registerCallback(Callback callback, Handler handler)",
    "returnType" : "void",
    "comment" : "\n     * Registers a callback for changes to packages in this user and managed profiles.\n     *\n     * @param callback The callback to register.\n     * @param handler that should be used to post callbacks on, may be null.\n     ",
    "links" : [ ]
  }, {
    "name" : "public void unregisterCallback(Callback callback)",
    "returnType" : "void",
    "comment" : "\n     * Unregisters a callback that was previously registered.\n     *\n     * @param callback The callback to unregister.\n     * @see #registerCallback(Callback)\n     ",
    "links" : [ ]
  }, {
    "name" : "private int findCallbackLocked(Callback callback)",
    "returnType" : "int",
    "comment" : " @return position in mCallbacks for callback or -1 if not present. ",
    "links" : [ ]
  }, {
    "name" : "private void removeCallbackLocked(Callback callback)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private void addCallbackLocked(Callback callback, Handler handler)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public void registerPackageInstallerSessionCallback(@NonNull @CallbackExecutor Executor executor, @NonNull SessionCallback callback)",
    "returnType" : "void",
    "comment" : "\n     * Register a callback to watch for session lifecycle events in this user and managed profiles.\n     * @param callback The callback to register.\n     * @param executor {@link Executor} to handle the callbacks, cannot be null.\n     *\n     * @see PackageInstaller#registerSessionCallback(SessionCallback)\n     ",
    "links" : [ "Executor" ]
  }, {
    "name" : "public void unregisterPackageInstallerSessionCallback(@NonNull SessionCallback callback)",
    "returnType" : "void",
    "comment" : "\n     * Unregisters a callback that was previously registered.\n     *\n     * @param callback The callback to unregister.\n     * @see #registerPackageInstallerSessionCallback(Executor, SessionCallback)\n     ",
    "links" : [ ]
  }, {
    "name" : "public List<SessionInfo> getAllPackageInstallerSessions()",
    "returnType" : "List<SessionInfo>",
    "comment" : "\n     * Return list of all known install sessions in this user and managed profiles, regardless\n     * of the installer.\n     *\n     * @see PackageInstaller#getAllSessions()\n     ",
    "links" : [ ]
  }, {
    "name" : "public void registerShortcutChangeCallback(@NonNull ShortcutChangeCallback callback, @NonNull ShortcutQuery query, @NonNull @CallbackExecutor Executor executor)",
    "returnType" : "void",
    "comment" : "\n     * Register a callback to watch for shortcut change events in this user and managed profiles.\n     *\n     * @param callback The callback to register.\n     * @param query {@link ShortcutQuery} to match and filter the shortcut events. Only matching\n     * shortcuts will be returned by the callback.\n     * @param executor {@link Executor} to handle the callbacks. To dispatch callbacks to the main\n     * thread of your application, you can use {@link android.content.Context#getMainExecutor()}.\n     *\n     * @hide\n     ",
    "links" : [ "ShortcutQuery", "Executor", "android.content.Context#getMainExecutor" ]
  }, {
    "name" : "public void unregisterShortcutChangeCallback(@NonNull ShortcutChangeCallback callback)",
    "returnType" : "void",
    "comment" : "\n     * Unregisters a callback that was previously registered.\n     * @see #registerShortcutChangeCallback(ShortcutChangeCallback, ShortcutQuery, Executor)\n     *\n     * @param callback Callback to be unregistered.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public PinItemRequest getPinItemRequest(Intent intent)",
    "returnType" : "PinItemRequest",
    "comment" : "\n     * A helper method to extract a {@link PinItemRequest} set to\n     * the {@link #EXTRA_PIN_ITEM_REQUEST} extra.\n     ",
    "links" : [ "PinItemRequest", "#EXTRA_PIN_ITEM_REQUEST" ]
  } ],
  "variableNames" : [ "TAG", "DEBUG", "ACTION_CONFIRM_PIN_SHORTCUT", "ACTION_CONFIRM_PIN_APPWIDGET", "EXTRA_PIN_ITEM_REQUEST", "FLAG_CACHE_NOTIFICATION_SHORTCUTS", "FLAG_CACHE_BUBBLE_SHORTCUTS", "mContext", "mService", "mPm", "mUserManager", "mCallbacks", "mDelegates", "mShortcutChangeCallbacks", "mAppsChangedListener" ],
  "methodNames" : [ "private void logErrorForInvalidProfileAccess(@NonNull UserHandle target)", "public List<UserHandle> getProfiles()", "public List<LauncherActivityInfo> getActivityList(String packageName, UserHandle user)", "public LauncherActivityInfo resolveActivity(Intent intent, UserHandle user)", "public void startMainActivity(ComponentName component, UserHandle user, Rect sourceBounds, Bundle opts)", "public void startPackageInstallerSessionDetailsActivity(@NonNull SessionInfo sessionInfo, @Nullable Rect sourceBounds, @Nullable Bundle opts)", "public void startAppDetailsActivity(ComponentName component, UserHandle user, Rect sourceBounds, Bundle opts)", "public List<LauncherActivityInfo> getShortcutConfigActivityList(@Nullable String packageName, @NonNull UserHandle user)", "private List<LauncherActivityInfo> convertToActivityList(@Nullable ParceledListSlice<ResolveInfo> activities, UserHandle user)", "public IntentSender getShortcutConfigActivityIntent(@NonNull LauncherActivityInfo info)", "public boolean isPackageEnabled(String packageName, UserHandle user)", "public Bundle getSuspendedPackageLauncherExtras(String packageName, UserHandle user)", "public boolean shouldHideFromSuggestions(@NonNull String packageName, @NonNull UserHandle user)", "public ApplicationInfo getApplicationInfo(@NonNull String packageName, @ApplicationInfoFlags int flags, @NonNull UserHandle user) throws PackageManager.NameNotFoundException", "public LauncherApps.AppUsageLimit getAppUsageLimit(@NonNull String packageName, @NonNull UserHandle user)", "public boolean isActivityEnabled(ComponentName component, UserHandle user)", "public boolean hasShortcutHostPermission()", "private List<ShortcutInfo> maybeUpdateDisabledMessage(List<ShortcutInfo> shortcuts)", "public List<ShortcutInfo> getShortcuts(@NonNull ShortcutQuery query, @NonNull UserHandle user)", "public List<ShortcutInfo> getShortcutInfo(@NonNull String packageName, @NonNull List<String> ids, @NonNull UserHandle user)", "public void pinShortcuts(@NonNull String packageName, @NonNull List<String> shortcutIds, @NonNull UserHandle user)", "public void cacheShortcuts(@NonNull String packageName, @NonNull List<String> shortcutIds, @NonNull UserHandle user, @ShortcutCacheFlags int cacheFlags)", "public void uncacheShortcuts(@NonNull String packageName, @NonNull List<String> shortcutIds, @NonNull UserHandle user, @ShortcutCacheFlags int cacheFlags)", "public int getShortcutIconResId(@NonNull ShortcutInfo shortcut)", "public int getShortcutIconResId(@NonNull String packageName, @NonNull String shortcutId, @NonNull UserHandle user)", "public ParcelFileDescriptor getShortcutIconFd(@NonNull ShortcutInfo shortcut)", "public ParcelFileDescriptor getShortcutIconFd(@NonNull String packageName, @NonNull String shortcutId, @NonNull UserHandle user)", "private ParcelFileDescriptor getShortcutIconFd(@NonNull String packageName, @NonNull String shortcutId, int userId)", "public ParcelFileDescriptor getUriShortcutIconFd(@NonNull ShortcutInfo shortcut)", "private ParcelFileDescriptor getUriShortcutIconFd(@NonNull String packageName, @NonNull String shortcutId, int userId)", "private String getShortcutIconUri(@NonNull String packageName, @NonNull String shortcutId, int userId)", "public Drawable getShortcutIconDrawable(@NonNull ShortcutInfo shortcut, int density)", "private Drawable loadDrawableFromFileDescriptor(ParcelFileDescriptor pfd, boolean adaptive)", "public Icon getShortcutIcon(@NonNull ShortcutInfo shortcut)", "private Drawable loadDrawableResourceFromPackage(String packageName, int resId, UserHandle user, int density)", "public Drawable getShortcutBadgedIconDrawable(ShortcutInfo shortcut, int density)", "public void startShortcut(@NonNull String packageName, @NonNull String shortcutId, @Nullable Rect sourceBounds, @Nullable Bundle startActivityOptions, @NonNull UserHandle user)", "public void startShortcut(@NonNull ShortcutInfo shortcut, @Nullable Rect sourceBounds, @Nullable Bundle startActivityOptions)", "private void startShortcut(@NonNull String packageName, @NonNull String shortcutId, @Nullable Rect sourceBounds, @Nullable Bundle startActivityOptions, int userId)", "public void registerCallback(Callback callback)", "public void registerCallback(Callback callback, Handler handler)", "public void unregisterCallback(Callback callback)", "private int findCallbackLocked(Callback callback)", "private void removeCallbackLocked(Callback callback)", "private void addCallbackLocked(Callback callback, Handler handler)", "public void registerPackageInstallerSessionCallback(@NonNull @CallbackExecutor Executor executor, @NonNull SessionCallback callback)", "public void unregisterPackageInstallerSessionCallback(@NonNull SessionCallback callback)", "public List<SessionInfo> getAllPackageInstallerSessions()", "public void registerShortcutChangeCallback(@NonNull ShortcutChangeCallback callback, @NonNull ShortcutQuery query, @NonNull @CallbackExecutor Executor executor)", "public void unregisterShortcutChangeCallback(@NonNull ShortcutChangeCallback callback)", "public PinItemRequest getPinItemRequest(Intent intent)" ]
}