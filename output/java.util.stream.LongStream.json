{
  "filePath" : "/home/maryam/clearblue/files/android-source-35/java/util/stream/LongStream.java",
  "packageName" : "java.util.stream",
  "className" : "LongStream",
  "comment" : "\n * A sequence of primitive long-valued elements supporting sequential and parallel\n * aggregate operations.  This is the {@code long} primitive specialization of\n * {@link Stream}.\n *\n * <p>The following example illustrates an aggregate operation using\n * {@link Stream} and {@link LongStream}, computing the sum of the weights of the\n * red widgets:\n *\n * <pre>{@code\n *     long sum = widgets.stream()\n *                       .filter(w -> w.getColor() == RED)\n *                       .mapToLong(w -> w.getWeight())\n *                       .sum();\n * }</pre>\n *\n * See the class documentation for {@link Stream} and the package documentation\n * for <a href=\"package-summary.html\">java.util.stream</a> for additional\n * specification of streams, stream operations, stream pipelines, and\n * parallelism.\n *\n * @since 1.8\n * @see Stream\n * @see <a href=\"package-summary.html\">java.util.stream</a>\n ",
  "links" : [ "java.util.stream.Stream", "java.util.stream.LongStream" ],
  "variables" : [ ],
  "methods" : [ {
    "name" : " LongStream filter(LongPredicate predicate)",
    "returnType" : "LongStream",
    "comment" : "\n     * Returns a stream consisting of the elements of this stream that match\n     * the given predicate.\n     *\n     * <p>This is an <a href=\"package-summary.html#StreamOps\">intermediate\n     * operation</a>.\n     *\n     * @param predicate a <a href=\"package-summary.html#NonInterference\">non-interfering</a>,\n     *                  <a href=\"package-summary.html#Statelessness\">stateless</a>\n     *                  predicate to apply to each element to determine if it\n     *                  should be included\n     * @return the new stream\n     ",
    "links" : [ ]
  }, {
    "name" : " LongStream map(LongUnaryOperator mapper)",
    "returnType" : "LongStream",
    "comment" : "\n     * Returns a stream consisting of the results of applying the given\n     * function to the elements of this stream.\n     *\n     * <p>This is an <a href=\"package-summary.html#StreamOps\">intermediate\n     * operation</a>.\n     *\n     * @param mapper a <a href=\"package-summary.html#NonInterference\">non-interfering</a>,\n     *               <a href=\"package-summary.html#Statelessness\">stateless</a>\n     *               function to apply to each element\n     * @return the new stream\n     ",
    "links" : [ ]
  }, {
    "name" : " Stream<U> mapToObj(LongFunction<? extends U> mapper)",
    "returnType" : "Stream<U>",
    "comment" : "\n     * Returns an object-valued {@code Stream} consisting of the results of\n     * applying the given function to the elements of this stream.\n     *\n     * <p>This is an <a href=\"package-summary.html#StreamOps\">\n     *     intermediate operation</a>.\n     *\n     * @param <U> the element type of the new stream\n     * @param mapper a <a href=\"package-summary.html#NonInterference\">non-interfering</a>,\n     *               <a href=\"package-summary.html#Statelessness\">stateless</a>\n     *               function to apply to each element\n     * @return the new stream\n     ",
    "links" : [ ]
  }, {
    "name" : " IntStream mapToInt(LongToIntFunction mapper)",
    "returnType" : "IntStream",
    "comment" : "\n     * Returns an {@code IntStream} consisting of the results of applying the\n     * given function to the elements of this stream.\n     *\n     * <p>This is an <a href=\"package-summary.html#StreamOps\">intermediate\n     * operation</a>.\n     *\n     * @param mapper a <a href=\"package-summary.html#NonInterference\">non-interfering</a>,\n     *               <a href=\"package-summary.html#Statelessness\">stateless</a>\n     *               function to apply to each element\n     * @return the new stream\n     ",
    "links" : [ ]
  }, {
    "name" : " DoubleStream mapToDouble(LongToDoubleFunction mapper)",
    "returnType" : "DoubleStream",
    "comment" : "\n     * Returns a {@code DoubleStream} consisting of the results of applying the\n     * given function to the elements of this stream.\n     *\n     * <p>This is an <a href=\"package-summary.html#StreamOps\">intermediate\n     * operation</a>.\n     *\n     * @param mapper a <a href=\"package-summary.html#NonInterference\">non-interfering</a>,\n     *               <a href=\"package-summary.html#Statelessness\">stateless</a>\n     *               function to apply to each element\n     * @return the new stream\n     ",
    "links" : [ ]
  }, {
    "name" : " LongStream flatMap(LongFunction<? extends LongStream> mapper)",
    "returnType" : "LongStream",
    "comment" : "\n     * Returns a stream consisting of the results of replacing each element of\n     * this stream with the contents of a mapped stream produced by applying\n     * the provided mapping function to each element.  Each mapped stream is\n     * {@link java.util.stream.BaseStream#close() closed} after its contents\n     * have been placed into this stream.  (If a mapped stream is {@code null}\n     * an empty stream is used, instead.)\n     *\n     * <p>This is an <a href=\"package-summary.html#StreamOps\">intermediate\n     * operation</a>.\n     *\n     * @param mapper a <a href=\"package-summary.html#NonInterference\">non-interfering</a>,\n     *               <a href=\"package-summary.html#Statelessness\">stateless</a>\n     *               function to apply to each element which produces a\n     *               {@code LongStream} of new values\n     * @return the new stream\n     * @see Stream#flatMap(Function)\n     ",
    "links" : [ "java.util.stream.BaseStream#close()" ]
  }, {
    "name" : " LongStream mapMulti(LongMapMultiConsumer mapper)",
    "returnType" : "LongStream",
    "comment" : "\n     * Returns a stream consisting of the results of replacing each element of\n     * this stream with multiple elements, specifically zero or more elements.\n     * Replacement is performed by applying the provided mapping function to each\n     * element in conjunction with a {@linkplain LongConsumer consumer} argument\n     * that accepts replacement elements. The mapping function calls the consumer\n     * zero or more times to provide the replacement elements.\n     *\n     * <p>This is an <a href=\"package-summary.html#StreamOps\">intermediate\n     * operation</a>.\n     *\n     * <p>If the {@linkplain LongConsumer consumer} argument is used outside the scope of\n     * its application to the mapping function, the results are undefined.\n     *\n     * @implSpec\n     * The default implementation invokes {@link #flatMap flatMap} on this stream,\n     * passing a function that behaves as follows. First, it calls the mapper function\n     * with a {@code LongConsumer} that accumulates replacement elements into a newly created\n     * internal buffer. When the mapper function returns, it creates a {@code LongStream} from the\n     * internal buffer. Finally, it returns this stream to {@code flatMap}.\n     *\n     * @param mapper a <a href=\"package-summary.html#NonInterference\">non-interfering</a>,\n     *               <a href=\"package-summary.html#Statelessness\">stateless</a>\n     *               function that generates replacement elements\n     * @return the new stream\n     * @see Stream#mapMulti Stream.mapMulti\n     * @since 16\n     ",
    "links" : [ "#flatMap" ]
  }, {
    "name" : " LongStream distinct()",
    "returnType" : "LongStream",
    "comment" : "\n     * Returns a stream consisting of the distinct elements of this stream.\n     *\n     * <p>This is a <a href=\"package-summary.html#StreamOps\">stateful\n     * intermediate operation</a>.\n     *\n     * @return the new stream\n     ",
    "links" : [ ]
  }, {
    "name" : " LongStream sorted()",
    "returnType" : "LongStream",
    "comment" : "\n     * Returns a stream consisting of the elements of this stream in sorted\n     * order.\n     *\n     * <p>This is a <a href=\"package-summary.html#StreamOps\">stateful\n     * intermediate operation</a>.\n     *\n     * @return the new stream\n     ",
    "links" : [ ]
  }, {
    "name" : " LongStream peek(LongConsumer action)",
    "returnType" : "LongStream",
    "comment" : "\n     * Returns a stream consisting of the elements of this stream, additionally\n     * performing the provided action on each element as elements are consumed\n     * from the resulting stream.\n     *\n     * <p>This is an <a href=\"package-summary.html#StreamOps\">intermediate\n     * operation</a>.\n     *\n     * <p>For parallel stream pipelines, the action may be called at\n     * whatever time and in whatever thread the element is made available by the\n     * upstream operation.  If the action modifies shared state,\n     * it is responsible for providing the required synchronization.\n     *\n     * @apiNote This method exists mainly to support debugging, where you want\n     * to see the elements as they flow past a certain point in a pipeline:\n     * <pre>{@code\n     *     LongStream.of(1, 2, 3, 4)\n     *         .filter(e -> e > 2)\n     *         .peek(e -> System.out.println(\"Filtered value: \" + e))\n     *         .map(e -> e * e)\n     *         .peek(e -> System.out.println(\"Mapped value: \" + e))\n     *         .sum();\n     * }</pre>\n     *\n     * <p>In cases where the stream implementation is able to optimize away the\n     * production of some or all the elements (such as with short-circuiting\n     * operations like {@code findFirst}, or in the example described in\n     * {@link #count}), the action will not be invoked for those elements.\n     *\n     * @param action a <a href=\"package-summary.html#NonInterference\">\n     *               non-interfering</a> action to perform on the elements as\n     *               they are consumed from the stream\n     * @return the new stream\n     ",
    "links" : [ "#count" ]
  }, {
    "name" : " LongStream limit(long maxSize)",
    "returnType" : "LongStream",
    "comment" : "\n     * Returns a stream consisting of the elements of this stream, truncated\n     * to be no longer than {@code maxSize} in length.\n     *\n     * <p>This is a <a href=\"package-summary.html#StreamOps\">short-circuiting\n     * stateful intermediate operation</a>.\n     *\n     * @apiNote\n     * While {@code limit()} is generally a cheap operation on sequential\n     * stream pipelines, it can be quite expensive on ordered parallel pipelines,\n     * especially for large values of {@code maxSize}, since {@code limit(n)}\n     * is constrained to return not just any <em>n</em> elements, but the\n     * <em>first n</em> elements in the encounter order.  Using an unordered\n     * stream source (such as {@link #generate(LongSupplier)}) or removing the\n     * ordering constraint with {@link #unordered()} may result in significant\n     * speedups of {@code limit()} in parallel pipelines, if the semantics of\n     * your situation permit.  If consistency with encounter order is required,\n     * and you are experiencing poor performance or memory utilization with\n     * {@code limit()} in parallel pipelines, switching to sequential execution\n     * with {@link #sequential()} may improve performance.\n     *\n     * @param maxSize the number of elements the stream should be limited to\n     * @return the new stream\n     * @throws IllegalArgumentException if {@code maxSize} is negative\n     ",
    "links" : [ "#generate(LongSupplier)", "#unordered()", "#sequential()" ]
  }, {
    "name" : " LongStream skip(long n)",
    "returnType" : "LongStream",
    "comment" : "\n     * Returns a stream consisting of the remaining elements of this stream\n     * after discarding the first {@code n} elements of the stream.\n     * If this stream contains fewer than {@code n} elements then an\n     * empty stream will be returned.\n     *\n     * <p>This is a <a href=\"package-summary.html#StreamOps\">stateful\n     * intermediate operation</a>.\n     *\n     * @apiNote\n     * While {@code skip()} is generally a cheap operation on sequential\n     * stream pipelines, it can be quite expensive on ordered parallel pipelines,\n     * especially for large values of {@code n}, since {@code skip(n)}\n     * is constrained to skip not just any <em>n</em> elements, but the\n     * <em>first n</em> elements in the encounter order.  Using an unordered\n     * stream source (such as {@link #generate(LongSupplier)}) or removing the\n     * ordering constraint with {@link #unordered()} may result in significant\n     * speedups of {@code skip()} in parallel pipelines, if the semantics of\n     * your situation permit.  If consistency with encounter order is required,\n     * and you are experiencing poor performance or memory utilization with\n     * {@code skip()} in parallel pipelines, switching to sequential execution\n     * with {@link #sequential()} may improve performance.\n     *\n     * @param n the number of leading elements to skip\n     * @return the new stream\n     * @throws IllegalArgumentException if {@code n} is negative\n     ",
    "links" : [ "#generate(LongSupplier)", "#unordered()", "#sequential()" ]
  }, {
    "name" : " LongStream takeWhile(LongPredicate predicate)",
    "returnType" : "LongStream",
    "comment" : "\n     * Returns, if this stream is ordered, a stream consisting of the longest\n     * prefix of elements taken from this stream that match the given predicate.\n     * Otherwise returns, if this stream is unordered, a stream consisting of a\n     * subset of elements taken from this stream that match the given predicate.\n     *\n     * <p>If this stream is ordered then the longest prefix is a contiguous\n     * sequence of elements of this stream that match the given predicate.  The\n     * first element of the sequence is the first element of this stream, and\n     * the element immediately following the last element of the sequence does\n     * not match the given predicate.\n     *\n     * <p>If this stream is unordered, and some (but not all) elements of this\n     * stream match the given predicate, then the behavior of this operation is\n     * nondeterministic; it is free to take any subset of matching elements\n     * (which includes the empty set).\n     *\n     * <p>Independent of whether this stream is ordered or unordered if all\n     * elements of this stream match the given predicate then this operation\n     * takes all elements (the result is the same as the input), or if no\n     * elements of the stream match the given predicate then no elements are\n     * taken (the result is an empty stream).\n     *\n     * <p>This is a <a href=\"package-summary.html#StreamOps\">short-circuiting\n     * stateful intermediate operation</a>.\n     *\n     * @implSpec\n     * The default implementation obtains the {@link #spliterator() spliterator}\n     * of this stream, wraps that spliterator so as to support the semantics\n     * of this operation on traversal, and returns a new stream associated with\n     * the wrapped spliterator.  The returned stream preserves the execution\n     * characteristics of this stream (namely parallel or sequential execution\n     * as per {@link #isParallel()}) but the wrapped spliterator may choose to\n     * not support splitting.  When the returned stream is closed, the close\n     * handlers for both the returned and this stream are invoked.\n     *\n     * @apiNote\n     * While {@code takeWhile()} is generally a cheap operation on sequential\n     * stream pipelines, it can be quite expensive on ordered parallel\n     * pipelines, since the operation is constrained to return not just any\n     * valid prefix, but the longest prefix of elements in the encounter order.\n     * Using an unordered stream source (such as\n     * {@link #generate(LongSupplier)}) or removing the ordering constraint with\n     * {@link #unordered()} may result in significant speedups of\n     * {@code takeWhile()} in parallel pipelines, if the semantics of your\n     * situation permit.  If consistency with encounter order is required, and\n     * you are experiencing poor performance or memory utilization with\n     * {@code takeWhile()} in parallel pipelines, switching to sequential\n     * execution with {@link #sequential()} may improve performance.\n     *\n     * @param predicate a <a href=\"package-summary.html#NonInterference\">non-interfering</a>,\n     *                  <a href=\"package-summary.html#Statelessness\">stateless</a>\n     *                  predicate to apply to elements to determine the longest\n     *                  prefix of elements.\n     * @return the new stream\n     * @since 9\n     ",
    "links" : [ "#spliterator()", "#isParallel()", "#generate(LongSupplier)", "#unordered()", "#sequential()" ]
  }, {
    "name" : " LongStream dropWhile(LongPredicate predicate)",
    "returnType" : "LongStream",
    "comment" : "\n     * Returns, if this stream is ordered, a stream consisting of the remaining\n     * elements of this stream after dropping the longest prefix of elements\n     * that match the given predicate.  Otherwise returns, if this stream is\n     * unordered, a stream consisting of the remaining elements of this stream\n     * after dropping a subset of elements that match the given predicate.\n     *\n     * <p>If this stream is ordered then the longest prefix is a contiguous\n     * sequence of elements of this stream that match the given predicate.  The\n     * first element of the sequence is the first element of this stream, and\n     * the element immediately following the last element of the sequence does\n     * not match the given predicate.\n     *\n     * <p>If this stream is unordered, and some (but not all) elements of this\n     * stream match the given predicate, then the behavior of this operation is\n     * nondeterministic; it is free to drop any subset of matching elements\n     * (which includes the empty set).\n     *\n     * <p>Independent of whether this stream is ordered or unordered if all\n     * elements of this stream match the given predicate then this operation\n     * drops all elements (the result is an empty stream), or if no elements of\n     * the stream match the given predicate then no elements are dropped (the\n     * result is the same as the input).\n     *\n     * <p>This is a <a href=\"package-summary.html#StreamOps\">stateful\n     * intermediate operation</a>.\n     *\n     * @implSpec\n     * The default implementation obtains the {@link #spliterator() spliterator}\n     * of this stream, wraps that spliterator so as to support the semantics\n     * of this operation on traversal, and returns a new stream associated with\n     * the wrapped spliterator.  The returned stream preserves the execution\n     * characteristics of this stream (namely parallel or sequential execution\n     * as per {@link #isParallel()}) but the wrapped spliterator may choose to\n     * not support splitting.  When the returned stream is closed, the close\n     * handlers for both the returned and this stream are invoked.\n     *\n     * @apiNote\n     * While {@code dropWhile()} is generally a cheap operation on sequential\n     * stream pipelines, it can be quite expensive on ordered parallel\n     * pipelines, since the operation is constrained to return not just any\n     * valid prefix, but the longest prefix of elements in the encounter order.\n     * Using an unordered stream source (such as\n     * {@link #generate(LongSupplier)}) or removing the ordering constraint with\n     * {@link #unordered()} may result in significant speedups of\n     * {@code dropWhile()} in parallel pipelines, if the semantics of your\n     * situation permit.  If consistency with encounter order is required, and\n     * you are experiencing poor performance or memory utilization with\n     * {@code dropWhile()} in parallel pipelines, switching to sequential\n     * execution with {@link #sequential()} may improve performance.\n     *\n     * @param predicate a <a href=\"package-summary.html#NonInterference\">non-interfering</a>,\n     *                  <a href=\"package-summary.html#Statelessness\">stateless</a>\n     *                  predicate to apply to elements to determine the longest\n     *                  prefix of elements.\n     * @return the new stream\n     * @since 9\n     ",
    "links" : [ "#spliterator()", "#isParallel()", "#generate(LongSupplier)", "#unordered()", "#sequential()" ]
  }, {
    "name" : " void forEach(LongConsumer action)",
    "returnType" : "void",
    "comment" : "\n     * Performs an action for each element of this stream.\n     *\n     * <p>This is a <a href=\"package-summary.html#StreamOps\">terminal\n     * operation</a>.\n     *\n     * <p>For parallel stream pipelines, this operation does <em>not</em>\n     * guarantee to respect the encounter order of the stream, as doing so\n     * would sacrifice the benefit of parallelism.  For any given element, the\n     * action may be performed at whatever time and in whatever thread the\n     * library chooses.  If the action accesses shared state, it is\n     * responsible for providing the required synchronization.\n     *\n     * @param action a <a href=\"package-summary.html#NonInterference\">\n     *               non-interfering</a> action to perform on the elements\n     ",
    "links" : [ ]
  }, {
    "name" : " void forEachOrdered(LongConsumer action)",
    "returnType" : "void",
    "comment" : "\n     * Performs an action for each element of this stream, guaranteeing that\n     * each element is processed in encounter order for streams that have a\n     * defined encounter order.\n     *\n     * <p>This is a <a href=\"package-summary.html#StreamOps\">terminal\n     * operation</a>.\n     *\n     * @param action a <a href=\"package-summary.html#NonInterference\">\n     *               non-interfering</a> action to perform on the elements\n     * @see #forEach(LongConsumer)\n     ",
    "links" : [ ]
  }, {
    "name" : " long[] toArray()",
    "returnType" : "long[]",
    "comment" : "\n     * Returns an array containing the elements of this stream.\n     *\n     * <p>This is a <a href=\"package-summary.html#StreamOps\">terminal\n     * operation</a>.\n     *\n     * @return an array containing the elements of this stream\n     ",
    "links" : [ ]
  }, {
    "name" : " long reduce(long identity, LongBinaryOperator op)",
    "returnType" : "long",
    "comment" : "\n     * Performs a <a href=\"package-summary.html#Reduction\">reduction</a> on the\n     * elements of this stream, using the provided identity value and an\n     * <a href=\"package-summary.html#Associativity\">associative</a>\n     * accumulation function, and returns the reduced value.  This is equivalent\n     * to:\n     * <pre>{@code\n     *     long result = identity;\n     *     for (long element : this stream)\n     *         result = accumulator.applyAsLong(result, element)\n     *     return result;\n     * }</pre>\n     *\n     * but is not constrained to execute sequentially.\n     *\n     * <p>The {@code identity} value must be an identity for the accumulator\n     * function. This means that for all {@code x},\n     * {@code accumulator.apply(identity, x)} is equal to {@code x}.\n     * The {@code accumulator} function must be an\n     * <a href=\"package-summary.html#Associativity\">associative</a> function.\n     *\n     * <p>This is a <a href=\"package-summary.html#StreamOps\">terminal\n     * operation</a>.\n     *\n     * @apiNote Sum, min, max, and average are all special cases of reduction.\n     * Summing a stream of numbers can be expressed as:\n     *\n     * <pre>{@code\n     *     long sum = integers.reduce(0, (a, b) -> a+b);\n     * }</pre>\n     *\n     * or more compactly:\n     *\n     * <pre>{@code\n     *     long sum = integers.reduce(0, Long::sum);\n     * }</pre>\n     *\n     * <p>While this may seem a more roundabout way to perform an aggregation\n     * compared to simply mutating a running total in a loop, reduction\n     * operations parallelize more gracefully, without needing additional\n     * synchronization and with greatly reduced risk of data races.\n     *\n     * @param identity the identity value for the accumulating function\n     * @param op an <a href=\"package-summary.html#Associativity\">associative</a>,\n     *           <a href=\"package-summary.html#NonInterference\">non-interfering</a>,\n     *           <a href=\"package-summary.html#Statelessness\">stateless</a>\n     *           function for combining two values\n     * @return the result of the reduction\n     * @see #sum()\n     * @see #min()\n     * @see #max()\n     * @see #average()\n     ",
    "links" : [ ]
  }, {
    "name" : " OptionalLong reduce(LongBinaryOperator op)",
    "returnType" : "OptionalLong",
    "comment" : "\n     * Performs a <a href=\"package-summary.html#Reduction\">reduction</a> on the\n     * elements of this stream, using an\n     * <a href=\"package-summary.html#Associativity\">associative</a> accumulation\n     * function, and returns an {@code OptionalLong} describing the reduced value,\n     * if any. This is equivalent to:\n     * <pre>{@code\n     *     boolean foundAny = false;\n     *     long result = null;\n     *     for (long element : this stream) {\n     *         if (!foundAny) {\n     *             foundAny = true;\n     *             result = element;\n     *         }\n     *         else\n     *             result = accumulator.applyAsLong(result, element);\n     *     }\n     *     return foundAny ? OptionalLong.of(result) : OptionalLong.empty();\n     * }</pre>\n     *\n     * but is not constrained to execute sequentially.\n     *\n     * <p>The {@code accumulator} function must be an\n     * <a href=\"package-summary.html#Associativity\">associative</a> function.\n     *\n     * <p>This is a <a href=\"package-summary.html#StreamOps\">terminal\n     * operation</a>.\n     *\n     * @param op an <a href=\"package-summary.html#Associativity\">associative</a>,\n     *           <a href=\"package-summary.html#NonInterference\">non-interfering</a>,\n     *           <a href=\"package-summary.html#Statelessness\">stateless</a>\n     *           function for combining two values\n     * @return the result of the reduction\n     * @see #reduce(long, LongBinaryOperator)\n     ",
    "links" : [ ]
  }, {
    "name" : " R collect(Supplier<R> supplier, ObjLongConsumer<R> accumulator, BiConsumer<R, R> combiner)",
    "returnType" : "R",
    "comment" : "\n     * Performs a <a href=\"package-summary.html#MutableReduction\">mutable\n     * reduction</a> operation on the elements of this stream.  A mutable\n     * reduction is one in which the reduced value is a mutable result container,\n     * such as an {@code ArrayList}, and elements are incorporated by updating\n     * the state of the result rather than by replacing the result.  This\n     * produces a result equivalent to:\n     * <pre>{@code\n     *     R result = supplier.get();\n     *     for (long element : this stream)\n     *         accumulator.accept(result, element);\n     *     return result;\n     * }</pre>\n     *\n     * <p>Like {@link #reduce(long, LongBinaryOperator)}, {@code collect} operations\n     * can be parallelized without requiring additional synchronization.\n     *\n     * <p>This is a <a href=\"package-summary.html#StreamOps\">terminal\n     * operation</a>.\n     *\n     * @param <R> the type of the mutable result container\n     * @param supplier a function that creates a new mutable result container.\n     *                 For a parallel execution, this function may be called\n     *                 multiple times and must return a fresh value each time.\n     * @param accumulator an <a href=\"package-summary.html#Associativity\">associative</a>,\n     *                    <a href=\"package-summary.html#NonInterference\">non-interfering</a>,\n     *                    <a href=\"package-summary.html#Statelessness\">stateless</a>\n     *                    function that must fold an element into a result\n     *                    container.\n     * @param combiner an <a href=\"package-summary.html#Associativity\">associative</a>,\n     *                    <a href=\"package-summary.html#NonInterference\">non-interfering</a>,\n     *                    <a href=\"package-summary.html#Statelessness\">stateless</a>\n     *                    function that accepts two partial result containers\n     *                    and merges them, which must be compatible with the\n     *                    accumulator function.  The combiner function must fold\n     *                    the elements from the second result container into the\n     *                    first result container.\n     * @return the result of the reduction\n     * @see Stream#collect(Supplier, BiConsumer, BiConsumer)\n     ",
    "links" : [ "#reduce(long" ]
  }, {
    "name" : " long sum()",
    "returnType" : "long",
    "comment" : "\n     * Returns the sum of elements in this stream.  This is a special case\n     * of a <a href=\"package-summary.html#Reduction\">reduction</a>\n     * and is equivalent to:\n     * <pre>{@code\n     *     return reduce(0, Long::sum);\n     * }</pre>\n     *\n     * <p>This is a <a href=\"package-summary.html#StreamOps\">terminal\n     * operation</a>.\n     *\n     * @return the sum of elements in this stream\n     ",
    "links" : [ ]
  }, {
    "name" : " OptionalLong min()",
    "returnType" : "OptionalLong",
    "comment" : "\n     * Returns an {@code OptionalLong} describing the minimum element of this\n     * stream, or an empty optional if this stream is empty.  This is a special\n     * case of a <a href=\"package-summary.html#Reduction\">reduction</a>\n     * and is equivalent to:\n     * <pre>{@code\n     *     return reduce(Long::min);\n     * }</pre>\n     *\n     * <p>This is a <a href=\"package-summary.html#StreamOps\">terminal operation</a>.\n     *\n     * @return an {@code OptionalLong} containing the minimum element of this\n     * stream, or an empty {@code OptionalLong} if the stream is empty\n     ",
    "links" : [ ]
  }, {
    "name" : " OptionalLong max()",
    "returnType" : "OptionalLong",
    "comment" : "\n     * Returns an {@code OptionalLong} describing the maximum element of this\n     * stream, or an empty optional if this stream is empty.  This is a special\n     * case of a <a href=\"package-summary.html#Reduction\">reduction</a>\n     * and is equivalent to:\n     * <pre>{@code\n     *     return reduce(Long::max);\n     * }</pre>\n     *\n     * <p>This is a <a href=\"package-summary.html#StreamOps\">terminal\n     * operation</a>.\n     *\n     * @return an {@code OptionalLong} containing the maximum element of this\n     * stream, or an empty {@code OptionalLong} if the stream is empty\n     ",
    "links" : [ ]
  }, {
    "name" : " long count()",
    "returnType" : "long",
    "comment" : "\n     * Returns the count of elements in this stream.  This is a special case of\n     * a <a href=\"package-summary.html#Reduction\">reduction</a> and is\n     * equivalent to:\n     * <pre>{@code\n     *     return map(e -> 1L).sum();\n     * }</pre>\n     *\n     * <p>This is a <a href=\"package-summary.html#StreamOps\">terminal operation</a>.\n     *\n     * @apiNote\n     * An implementation may choose to not execute the stream pipeline (either\n     * sequentially or in parallel) if it is capable of computing the count\n     * directly from the stream source.  In such cases no source elements will\n     * be traversed and no intermediate operations will be evaluated.\n     * Behavioral parameters with side-effects, which are strongly discouraged\n     * except for harmless cases such as debugging, may be affected.  For\n     * example, consider the following stream:\n     * <pre>{@code\n     *     LongStream s = LongStream.of(1, 2, 3, 4);\n     *     long count = s.peek(System.out::println).count();\n     * }</pre>\n     * The number of elements covered by the stream source is known and the\n     * intermediate operation, {@code peek}, does not inject into or remove\n     * elements from the stream (as may be the case for {@code flatMap} or\n     * {@code filter} operations).  Thus the count is 4 and there is no need to\n     * execute the pipeline and, as a side-effect, print out the elements.\n     *\n     * @return the count of elements in this stream\n     ",
    "links" : [ ]
  }, {
    "name" : " OptionalDouble average()",
    "returnType" : "OptionalDouble",
    "comment" : "\n     * Returns an {@code OptionalDouble} describing the arithmetic mean of elements of\n     * this stream, or an empty optional if this stream is empty.  This is a\n     * special case of a\n     * <a href=\"package-summary.html#Reduction\">reduction</a>.\n     *\n     * <p>This is a <a href=\"package-summary.html#StreamOps\">terminal\n     * operation</a>.\n     *\n     * @return an {@code OptionalDouble} containing the average element of this\n     * stream, or an empty optional if the stream is empty\n     ",
    "links" : [ ]
  }, {
    "name" : " LongSummaryStatistics summaryStatistics()",
    "returnType" : "LongSummaryStatistics",
    "comment" : "\n     * Returns a {@code LongSummaryStatistics} describing various summary data\n     * about the elements of this stream.  This is a special case of a\n     * <a href=\"package-summary.html#Reduction\">reduction</a>.\n     *\n     * <p>This is a <a href=\"package-summary.html#StreamOps\">terminal\n     * operation</a>.\n     *\n     * @return a {@code LongSummaryStatistics} describing various summary data\n     * about the elements of this stream\n     ",
    "links" : [ ]
  }, {
    "name" : " boolean anyMatch(LongPredicate predicate)",
    "returnType" : "boolean",
    "comment" : "\n     * Returns whether any elements of this stream match the provided\n     * predicate.  May not evaluate the predicate on all elements if not\n     * necessary for determining the result.  If the stream is empty then\n     * {@code false} is returned and the predicate is not evaluated.\n     *\n     * <p>This is a <a href=\"package-summary.html#StreamOps\">short-circuiting\n     * terminal operation</a>.\n     *\n     * @apiNote\n     * This method evaluates the <em>existential quantification</em> of the\n     * predicate over the elements of the stream (for some x P(x)).\n     *\n     * @param predicate a <a href=\"package-summary.html#NonInterference\">non-interfering</a>,\n     *                  <a href=\"package-summary.html#Statelessness\">stateless</a>\n     *                  predicate to apply to elements of this stream\n     * @return {@code true} if any elements of the stream match the provided\n     * predicate, otherwise {@code false}\n     ",
    "links" : [ ]
  }, {
    "name" : " boolean allMatch(LongPredicate predicate)",
    "returnType" : "boolean",
    "comment" : "\n     * Returns whether all elements of this stream match the provided predicate.\n     * May not evaluate the predicate on all elements if not necessary for\n     * determining the result.  If the stream is empty then {@code true} is\n     * returned and the predicate is not evaluated.\n     *\n     * <p>This is a <a href=\"package-summary.html#StreamOps\">short-circuiting\n     * terminal operation</a>.\n     *\n     * @apiNote\n     * This method evaluates the <em>universal quantification</em> of the\n     * predicate over the elements of the stream (for all x P(x)).  If the\n     * stream is empty, the quantification is said to be <em>vacuously\n     * satisfied</em> and is always {@code true} (regardless of P(x)).\n     *\n     * @param predicate a <a href=\"package-summary.html#NonInterference\">non-interfering</a>,\n     *                  <a href=\"package-summary.html#Statelessness\">stateless</a>\n     *                  predicate to apply to elements of this stream\n     * @return {@code true} if either all elements of the stream match the\n     * provided predicate or the stream is empty, otherwise {@code false}\n     ",
    "links" : [ ]
  }, {
    "name" : " boolean noneMatch(LongPredicate predicate)",
    "returnType" : "boolean",
    "comment" : "\n     * Returns whether no elements of this stream match the provided predicate.\n     * May not evaluate the predicate on all elements if not necessary for\n     * determining the result.  If the stream is empty then {@code true} is\n     * returned and the predicate is not evaluated.\n     *\n     * <p>This is a <a href=\"package-summary.html#StreamOps\">short-circuiting\n     * terminal operation</a>.\n     *\n     * @apiNote\n     * This method evaluates the <em>universal quantification</em> of the\n     * negated predicate over the elements of the stream (for all x ~P(x)).  If\n     * the stream is empty, the quantification is said to be vacuously satisfied\n     * and is always {@code true}, regardless of P(x).\n     *\n     * @param predicate a <a href=\"package-summary.html#NonInterference\">non-interfering</a>,\n     *                  <a href=\"package-summary.html#Statelessness\">stateless</a>\n     *                  predicate to apply to elements of this stream\n     * @return {@code true} if either no elements of the stream match the\n     * provided predicate or the stream is empty, otherwise {@code false}\n     ",
    "links" : [ ]
  }, {
    "name" : " OptionalLong findFirst()",
    "returnType" : "OptionalLong",
    "comment" : "\n     * Returns an {@link OptionalLong} describing the first element of this\n     * stream, or an empty {@code OptionalLong} if the stream is empty.  If the\n     * stream has no encounter order, then any element may be returned.\n     *\n     * <p>This is a <a href=\"package-summary.html#StreamOps\">short-circuiting\n     * terminal operation</a>.\n     *\n     * @return an {@code OptionalLong} describing the first element of this\n     * stream, or an empty {@code OptionalLong} if the stream is empty\n     ",
    "links" : [ "java.util.OptionalLong" ]
  }, {
    "name" : " OptionalLong findAny()",
    "returnType" : "OptionalLong",
    "comment" : "\n     * Returns an {@link OptionalLong} describing some element of the stream, or\n     * an empty {@code OptionalLong} if the stream is empty.\n     *\n     * <p>This is a <a href=\"package-summary.html#StreamOps\">short-circuiting\n     * terminal operation</a>.\n     *\n     * <p>The behavior of this operation is explicitly nondeterministic; it is\n     * free to select any element in the stream.  This is to allow for maximal\n     * performance in parallel operations; the cost is that multiple invocations\n     * on the same source may not return the same result.  (If a stable result\n     * is desired, use {@link #findFirst()} instead.)\n     *\n     * @return an {@code OptionalLong} describing some element of this stream,\n     * or an empty {@code OptionalLong} if the stream is empty\n     * @see #findFirst()\n     ",
    "links" : [ "java.util.OptionalLong", "#findFirst()" ]
  }, {
    "name" : " DoubleStream asDoubleStream()",
    "returnType" : "DoubleStream",
    "comment" : "\n     * Returns a {@code DoubleStream} consisting of the elements of this stream,\n     * converted to {@code double}.\n     *\n     * <p>This is an <a href=\"package-summary.html#StreamOps\">intermediate\n     * operation</a>.\n     *\n     * @return a {@code DoubleStream} consisting of the elements of this stream,\n     * converted to {@code double}\n     ",
    "links" : [ ]
  }, {
    "name" : " Stream<Long> boxed()",
    "returnType" : "Stream<Long>",
    "comment" : "\n     * Returns a {@code Stream} consisting of the elements of this stream,\n     * each boxed to a {@code Long}.\n     *\n     * <p>This is an <a href=\"package-summary.html#StreamOps\">intermediate\n     * operation</a>.\n     *\n     * @return a {@code Stream} consistent of the elements of this stream,\n     * each boxed to {@code Long}\n     ",
    "links" : [ ]
  }, {
    "name" : " LongStream sequential()",
    "returnType" : "LongStream",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : " LongStream parallel()",
    "returnType" : "LongStream",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : " PrimitiveIterator.OfLong iterator()",
    "returnType" : "PrimitiveIterator.OfLong",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : " Spliterator.OfLong spliterator()",
    "returnType" : "Spliterator.OfLong",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public static Builder builder()",
    "returnType" : "Builder",
    "comment" : "\n     * Returns a builder for a {@code LongStream}.\n     *\n     * @return a stream builder\n     ",
    "links" : [ ]
  }, {
    "name" : "public static LongStream empty()",
    "returnType" : "LongStream",
    "comment" : "\n     * Returns an empty sequential {@code LongStream}.\n     *\n     * @return an empty sequential stream\n     ",
    "links" : [ ]
  }, {
    "name" : "public static LongStream of(long t)",
    "returnType" : "LongStream",
    "comment" : "\n     * Returns a sequential {@code LongStream} containing a single element.\n     *\n     * @param t the single element\n     * @return a singleton sequential stream\n     ",
    "links" : [ ]
  }, {
    "name" : "public static LongStream of(long... values)",
    "returnType" : "LongStream",
    "comment" : "\n     * Returns a sequential ordered stream whose elements are the specified values.\n     *\n     * @param values the elements of the new stream\n     * @return the new stream\n     ",
    "links" : [ ]
  }, {
    "name" : "public static LongStream iterate(final long seed, final LongUnaryOperator f)",
    "returnType" : "LongStream",
    "comment" : "\n     * Returns an infinite sequential ordered {@code LongStream} produced by iterative\n     * application of a function {@code f} to an initial element {@code seed},\n     * producing a {@code Stream} consisting of {@code seed}, {@code f(seed)},\n     * {@code f(f(seed))}, etc.\n     *\n     * <p>The first element (position {@code 0}) in the {@code LongStream} will\n     * be the provided {@code seed}.  For {@code n > 0}, the element at position\n     * {@code n}, will be the result of applying the function {@code f} to the\n     * element at position {@code n - 1}.\n     *\n     * <p>The action of applying {@code f} for one element\n     * <a href=\"../concurrent/package-summary.html#MemoryVisibility\"><i>happens-before</i></a>\n     * the action of applying {@code f} for subsequent elements.  For any given\n     * element the action may be performed in whatever thread the library\n     * chooses.\n     *\n     * @param seed the initial element\n     * @param f a function to be applied to the previous element to produce\n     *          a new element\n     * @return a new sequential {@code LongStream}\n     ",
    "links" : [ ]
  }, {
    "name" : "public static LongStream iterate(long seed, LongPredicate hasNext, LongUnaryOperator next)",
    "returnType" : "LongStream",
    "comment" : "\n     * Returns a sequential ordered {@code LongStream} produced by iterative\n     * application of the given {@code next} function to an initial element,\n     * conditioned on satisfying the given {@code hasNext} predicate.  The\n     * stream terminates as soon as the {@code hasNext} predicate returns false.\n     *\n     * <p>{@code LongStream.iterate} should produce the same sequence of elements as\n     * produced by the corresponding for-loop:\n     * <pre>{@code\n     *     for (long index=seed; hasNext.test(index); index = next.applyAsLong(index)) {\n     *         ...\n     *     }\n     * }</pre>\n     *\n     * <p>The resulting sequence may be empty if the {@code hasNext} predicate\n     * does not hold on the seed value.  Otherwise the first element will be the\n     * supplied {@code seed} value, the next element (if present) will be the\n     * result of applying the {@code next} function to the {@code seed} value,\n     * and so on iteratively until the {@code hasNext} predicate indicates that\n     * the stream should terminate.\n     *\n     * <p>The action of applying the {@code hasNext} predicate to an element\n     * <a href=\"../concurrent/package-summary.html#MemoryVisibility\"><i>happens-before</i></a>\n     * the action of applying the {@code next} function to that element.  The\n     * action of applying the {@code next} function for one element\n     * <i>happens-before</i> the action of applying the {@code hasNext}\n     * predicate for subsequent elements.  For any given element an action may\n     * be performed in whatever thread the library chooses.\n     *\n     * @param seed the initial element\n     * @param hasNext a predicate to apply to elements to determine when the\n     *                stream must terminate.\n     * @param next a function to be applied to the previous element to produce\n     *             a new element\n     * @return a new sequential {@code LongStream}\n     * @since 9\n     ",
    "links" : [ ]
  }, {
    "name" : "public static LongStream generate(LongSupplier s)",
    "returnType" : "LongStream",
    "comment" : "\n     * Returns an infinite sequential unordered stream where each element is\n     * generated by the provided {@code LongSupplier}.  This is suitable for\n     * generating constant streams, streams of random elements, etc.\n     *\n     * @param s the {@code LongSupplier} for generated elements\n     * @return a new infinite sequential unordered {@code LongStream}\n     ",
    "links" : [ ]
  }, {
    "name" : "public static LongStream range(long startInclusive, final long endExclusive)",
    "returnType" : "LongStream",
    "comment" : "\n     * Returns a sequential ordered {@code LongStream} from {@code startInclusive}\n     * (inclusive) to {@code endExclusive} (exclusive) by an incremental step of\n     * {@code 1}.\n     *\n     * @apiNote\n     * <p>An equivalent sequence of increasing values can be produced\n     * sequentially using a {@code for} loop as follows:\n     * <pre>{@code\n     *     for (long i = startInclusive; i < endExclusive ; i++) { ... }\n     * }</pre>\n     *\n     * @param startInclusive the (inclusive) initial value\n     * @param endExclusive the exclusive upper bound\n     * @return a sequential {@code LongStream} for the range of {@code long}\n     *         elements\n     ",
    "links" : [ ]
  }, {
    "name" : "public static LongStream rangeClosed(long startInclusive, final long endInclusive)",
    "returnType" : "LongStream",
    "comment" : "\n     * Returns a sequential ordered {@code LongStream} from {@code startInclusive}\n     * (inclusive) to {@code endInclusive} (inclusive) by an incremental step of\n     * {@code 1}.\n     *\n     * @apiNote\n     * <p>An equivalent sequence of increasing values can be produced\n     * sequentially using a {@code for} loop as follows:\n     * <pre>{@code\n     *     for (long i = startInclusive; i <= endInclusive ; i++) { ... }\n     * }</pre>\n     *\n     * @param startInclusive the (inclusive) initial value\n     * @param endInclusive the inclusive upper bound\n     * @return a sequential {@code LongStream} for the range of {@code long}\n     *         elements\n     ",
    "links" : [ ]
  }, {
    "name" : "public static LongStream concat(LongStream a, LongStream b)",
    "returnType" : "LongStream",
    "comment" : "\n     * Creates a lazily concatenated stream whose elements are all the\n     * elements of the first stream followed by all the elements of the\n     * second stream.  The resulting stream is ordered if both\n     * of the input streams are ordered, and parallel if either of the input\n     * streams is parallel.  When the resulting stream is closed, the close\n     * handlers for both input streams are invoked.\n     *\n     * <p>This method operates on the two input streams and binds each stream\n     * to its source.  As a result subsequent modifications to an input stream\n     * source may not be reflected in the concatenated stream result.\n     *\n     * @implNote\n     * Use caution when constructing streams from repeated concatenation.\n     * Accessing an element of a deeply concatenated stream can result in deep\n     * call chains, or even {@code StackOverflowError}.\n     *\n     * @apiNote\n     * To preserve optimization opportunities this method binds each stream to\n     * its source and accepts only two streams as parameters.  For example, the\n     * exact size of the concatenated stream source can be computed if the exact\n     * size of each input stream source is known.\n     * To concatenate more streams without binding, or without nested calls to\n     * this method, try creating a stream of streams and flat-mapping with the\n     * identity function, for example:\n     * <pre>{@code\n     *     LongStream concat = Stream.of(s1, s2, s3, s4).flatMapToLong(s -> s);\n     * }</pre>\n     *\n     * @param a the first stream\n     * @param b the second stream\n     * @return the concatenation of the two input streams\n     ",
    "links" : [ ]
  } ],
  "methodNames" : [ " LongStream filter(LongPredicate predicate)", " LongStream map(LongUnaryOperator mapper)", " Stream<U> mapToObj(LongFunction<? extends U> mapper)", " IntStream mapToInt(LongToIntFunction mapper)", " DoubleStream mapToDouble(LongToDoubleFunction mapper)", " LongStream flatMap(LongFunction<? extends LongStream> mapper)", " LongStream mapMulti(LongMapMultiConsumer mapper)", " LongStream distinct()", " LongStream sorted()", " LongStream peek(LongConsumer action)", " LongStream limit(long maxSize)", " LongStream skip(long n)", " LongStream takeWhile(LongPredicate predicate)", " LongStream dropWhile(LongPredicate predicate)", " void forEach(LongConsumer action)", " void forEachOrdered(LongConsumer action)", " long[] toArray()", " long reduce(long identity, LongBinaryOperator op)", " OptionalLong reduce(LongBinaryOperator op)", " R collect(Supplier<R> supplier, ObjLongConsumer<R> accumulator, BiConsumer<R, R> combiner)", " long sum()", " OptionalLong min()", " OptionalLong max()", " long count()", " OptionalDouble average()", " LongSummaryStatistics summaryStatistics()", " boolean anyMatch(LongPredicate predicate)", " boolean allMatch(LongPredicate predicate)", " boolean noneMatch(LongPredicate predicate)", " OptionalLong findFirst()", " OptionalLong findAny()", " DoubleStream asDoubleStream()", " Stream<Long> boxed()", " LongStream sequential()", " LongStream parallel()", " PrimitiveIterator.OfLong iterator()", " Spliterator.OfLong spliterator()", "public static Builder builder()", "public static LongStream empty()", "public static LongStream of(long t)", "public static LongStream of(long... values)", "public static LongStream iterate(final long seed, final LongUnaryOperator f)", "public static LongStream iterate(long seed, LongPredicate hasNext, LongUnaryOperator next)", "public static LongStream generate(LongSupplier s)", "public static LongStream range(long startInclusive, final long endExclusive)", "public static LongStream rangeClosed(long startInclusive, final long endInclusive)", "public static LongStream concat(LongStream a, LongStream b)" ],
  "variableNames" : [ ]
}