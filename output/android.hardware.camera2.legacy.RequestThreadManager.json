{
  "filePath" : "/home/maryam/clearblue/files/android-source-30/android/hardware/camera2/legacy/RequestThreadManager.java",
  "packageName" : "android.hardware.camera2.legacy",
  "className" : "RequestThreadManager",
  "comment" : "\n * This class executes requests to the {@link Camera}.\n *\n * <p>\n * The main components of this class are:\n * - A message queue of requests to the {@link Camera}.\n * - A thread that consumes requests to the {@link Camera} and executes them.\n * - A {@link GLThreadManager} that draws to the configured output {@link Surface}s.\n * - An {@link CameraDeviceState} state machine that manages the callbacks for various operations.\n * </p>\n ",
  "variables" : [ {
    "name" : "TAG",
    "type" : "String",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mCameraId",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mRequestThread",
    "type" : "RequestHandlerThread",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "DEBUG",
    "type" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "VERBOSE",
    "type" : "boolean",
    "comment" : " For slightly more spammy messages that will get repeated every frame",
    "links" : [ ]
  }, {
    "name" : "mCamera",
    "type" : "Camera",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mCharacteristics",
    "type" : "CameraCharacteristics",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mDeviceState",
    "type" : "CameraDeviceState",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mCaptureCollector",
    "type" : "CaptureCollector",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mFocusStateMapper",
    "type" : "LegacyFocusStateMapper",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mFaceDetectMapper",
    "type" : "LegacyFaceDetectMapper",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "MSG_CONFIGURE_OUTPUTS",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "MSG_SUBMIT_CAPTURE_REQUEST",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "MSG_CLEANUP",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "MAX_IN_FLIGHT_REQUESTS",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "PREVIEW_FRAME_TIMEOUT",
    "type" : "int",
    "comment" : " ms",
    "links" : [ ]
  }, {
    "name" : "JPEG_FRAME_TIMEOUT",
    "type" : "int",
    "comment" : " ms (same as CTS for API2)",
    "links" : [ ]
  }, {
    "name" : "REQUEST_COMPLETE_TIMEOUT",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "ASPECT_RATIO_TOLERANCE",
    "type" : "float",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mPreviewRunning",
    "type" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mPreviewOutputs",
    "type" : "List<Surface>",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mCallbackOutputs",
    "type" : "List<Surface>",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mGLThreadManager",
    "type" : "GLThreadManager",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mPreviewTexture",
    "type" : "SurfaceTexture",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mParams",
    "type" : "Camera.Parameters",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mJpegSurfaceIds",
    "type" : "List<Long>",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mIntermediateBufferSize",
    "type" : "Size",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mRequestQueue",
    "type" : "RequestQueue",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mLastRequest",
    "type" : "LegacyRequest",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mDummyTexture",
    "type" : "SurfaceTexture",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mDummySurface",
    "type" : "Surface",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mIdleLock",
    "type" : "Object",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mPrevCounter",
    "type" : "FpsCounter",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mRequestCounter",
    "type" : "FpsCounter",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mQuit",
    "type" : "AtomicBoolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "USE_BLOB_FORMAT_OVERRIDE",
    "type" : "boolean",
    "comment" : " limitations for (b/17379185).",
    "links" : [ ]
  }, {
    "name" : "mErrorCallback",
    "type" : "Camera.ErrorCallback",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mReceivedJpeg",
    "type" : "ConditionVariable",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mJpegCallback",
    "type" : "Camera.PictureCallback",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mJpegShutterCallback",
    "type" : "Camera.ShutterCallback",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mPreviewCallback",
    "type" : "SurfaceTexture.OnFrameAvailableListener",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mRequestHandlerCb",
    "type" : "Handler.Callback",
    "comment" : "",
    "links" : [ ]
  } ],
  "methods" : [ {
    "name" : "private void createDummySurface()",
    "returnType" : "void",
    "comment" : "\n     * Fake preview for jpeg captures when there is no active preview\n     ",
    "links" : [ ]
  }, {
    "name" : "private void stopPreview()",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private void startPreview()",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private void doJpegCapturePrepare(RequestHolder request) throws IOException",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private void doJpegCapture(RequestHolder request)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private void doPreviewCapture(RequestHolder request) throws IOException",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private void disconnectCallbackSurfaces()",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private void configureOutputs(Collection<Pair<Surface, Size>> outputs)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private void resetJpegSurfaceFormats(Collection<Surface> surfaces)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private Size calculatePictureSize(List<Surface> callbackOutputs, List<Size> callbackSizes, Camera.Parameters params)",
    "returnType" : "Size",
    "comment" : "\n     * Find a JPEG size (that is supported by the legacy camera device) which is equal to or larger\n     * than all of the configured {@code JPEG} outputs (by both width and height).\n     *\n     * <p>If multiple supported JPEG sizes are larger, select the smallest of them which\n     * still satisfies the above constraint.</p>\n     *\n     * <p>As a result, the returned size is guaranteed to be usable without needing\n     * to upscale any of the outputs. If only one {@code JPEG} surface is used,\n     * then no scaling/cropping is necessary between the taken picture and\n     * the {@code JPEG} output surface.</p>\n     *\n     * @param callbackOutputs a non-{@code null} list of {@code Surface}s with any image formats\n     * @param params api1 parameters (used for reading only)\n     *\n     * @return a size large enough to fit all of the configured {@code JPEG} outputs, or\n     *          {@code null} if the {@code callbackOutputs} did not have any {@code JPEG}\n     *          surfaces.\n     ",
    "links" : [ ]
  }, {
    "name" : "private static boolean checkAspectRatiosMatch(Size a, Size b)",
    "returnType" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private int[] getPhotoPreviewFpsRange(List<int[]> frameRates)",
    "returnType" : "int[]",
    "comment" : " Calculate the highest FPS range supported",
    "links" : [ ]
  }, {
    "name" : "public void start()",
    "returnType" : "void",
    "comment" : "\n     * Start the request thread.\n     ",
    "links" : [ ]
  }, {
    "name" : "public long flush()",
    "returnType" : "long",
    "comment" : "\n     * Flush any pending requests.\n     *\n     * @return the last frame number.\n     ",
    "links" : [ ]
  }, {
    "name" : "public void quit()",
    "returnType" : "void",
    "comment" : "\n     * Quit the request thread, and clean up everything.\n     ",
    "links" : [ ]
  }, {
    "name" : "public SubmitInfo submitCaptureRequests(CaptureRequest[] requests, boolean repeating)",
    "returnType" : "SubmitInfo",
    "comment" : "\n     * Submit the given burst of requests to be captured.\n     *\n     * <p>If the burst is repeating, replace the current repeating burst.</p>\n     *\n     * @param requests the burst of requests to add to the queue.\n     * @param repeating true if the burst is repeating.\n     * @return the submission info, including the new request id, and the last frame number, which\n     *   contains either the frame number of the last frame that will be returned for this request,\n     *   or the frame number of the last frame that will be returned for the current repeating\n     *   request if this burst is set to be repeating.\n     ",
    "links" : [ ]
  }, {
    "name" : "public long cancelRepeating(int requestId)",
    "returnType" : "long",
    "comment" : "\n     * Cancel a repeating request.\n     *\n     * @param requestId the id of the repeating request to cancel.\n     * @return the last frame to be returned from the HAL for the given repeating request, or\n     *          {@code INVALID_FRAME} if none exists.\n     ",
    "links" : [ ]
  }, {
    "name" : "public void configure(Collection<Pair<Surface, Size>> outputs)",
    "returnType" : "void",
    "comment" : "\n     * Configure with the current list of output Surfaces.\n     *\n     * <p>\n     * This operation blocks until the configuration is complete.\n     * </p>\n     *\n     * <p>Using a {@code null} or empty {@code outputs} list is the equivalent of unconfiguring.</p>\n     *\n     * @param outputs a {@link java.util.Collection} of outputs to configure.\n     ",
    "links" : [ "java.util.Collection" ]
  }, {
    "name" : "public void setAudioRestriction(int mode)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public int getAudioRestriction()",
    "returnType" : "int",
    "comment" : "",
    "links" : [ ]
  } ],
  "variableNames" : [ "TAG", "mCameraId", "mRequestThread", "DEBUG", "VERBOSE", "mCamera", "mCharacteristics", "mDeviceState", "mCaptureCollector", "mFocusStateMapper", "mFaceDetectMapper", "MSG_CONFIGURE_OUTPUTS", "MSG_SUBMIT_CAPTURE_REQUEST", "MSG_CLEANUP", "MAX_IN_FLIGHT_REQUESTS", "PREVIEW_FRAME_TIMEOUT", "JPEG_FRAME_TIMEOUT", "REQUEST_COMPLETE_TIMEOUT", "ASPECT_RATIO_TOLERANCE", "mPreviewRunning", "mPreviewOutputs", "mCallbackOutputs", "mGLThreadManager", "mPreviewTexture", "mParams", "mJpegSurfaceIds", "mIntermediateBufferSize", "mRequestQueue", "mLastRequest", "mDummyTexture", "mDummySurface", "mIdleLock", "mPrevCounter", "mRequestCounter", "mQuit", "USE_BLOB_FORMAT_OVERRIDE", "mErrorCallback", "mReceivedJpeg", "mJpegCallback", "mJpegShutterCallback", "mPreviewCallback", "mRequestHandlerCb" ],
  "methodNames" : [ "private void createDummySurface()", "private void stopPreview()", "private void startPreview()", "private void doJpegCapturePrepare(RequestHolder request) throws IOException", "private void doJpegCapture(RequestHolder request)", "private void doPreviewCapture(RequestHolder request) throws IOException", "private void disconnectCallbackSurfaces()", "private void configureOutputs(Collection<Pair<Surface, Size>> outputs)", "private void resetJpegSurfaceFormats(Collection<Surface> surfaces)", "private Size calculatePictureSize(List<Surface> callbackOutputs, List<Size> callbackSizes, Camera.Parameters params)", "private static boolean checkAspectRatiosMatch(Size a, Size b)", "private int[] getPhotoPreviewFpsRange(List<int[]> frameRates)", "public void start()", "public long flush()", "public void quit()", "public SubmitInfo submitCaptureRequests(CaptureRequest[] requests, boolean repeating)", "public long cancelRepeating(int requestId)", "public void configure(Collection<Pair<Surface, Size>> outputs)", "public void setAudioRestriction(int mode)", "public int getAudioRestriction()" ]
}