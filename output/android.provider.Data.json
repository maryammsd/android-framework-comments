{
  "filePath" : "/home/maryam/clearblue/files/android-source-30/android/provider/ContactsContract.java",
  "packageName" : "android.provider",
  "className" : "Data",
  "comment" : "\n     * <p>\n     * Constants for the data table, which contains data points tied to a raw\n     * contact.  Each row of the data table is typically used to store a single\n     * piece of contact\n     * information (such as a phone number) and its\n     * associated metadata (such as whether it is a work or home number).\n     * </p>\n     * <h3>Data kinds</h3>\n     * <p>\n     * Data is a generic table that can hold any kind of contact data.\n     * The kind of data stored in a given row is specified by the row's\n     * {@link #MIMETYPE} value, which determines the meaning of the\n     * generic columns {@link #DATA1} through\n     * {@link #DATA15}.\n     * For example, if the data kind is\n     * {@link CommonDataKinds.Phone Phone.CONTENT_ITEM_TYPE}, then the column\n     * {@link #DATA1} stores the\n     * phone number, but if the data kind is\n     * {@link CommonDataKinds.Email Email.CONTENT_ITEM_TYPE}, then {@link #DATA1}\n     * stores the email address.\n     * Sync adapters and applications can introduce their own data kinds.\n     * </p>\n     * <p>\n     * ContactsContract defines a small number of pre-defined data kinds, e.g.\n     * {@link CommonDataKinds.Phone}, {@link CommonDataKinds.Email} etc. As a\n     * convenience, these classes define data kind specific aliases for DATA1 etc.\n     * For example, {@link CommonDataKinds.Phone Phone.NUMBER} is the same as\n     * {@link ContactsContract.Data Data.DATA1}.\n     * </p>\n     * <p>\n     * {@link #DATA1} is an indexed column and should be used for the data element that is\n     * expected to be most frequently used in query selections. For example, in the\n     * case of a row representing email addresses {@link #DATA1} should probably\n     * be used for the email address itself, while {@link #DATA2} etc can be\n     * used for auxiliary information like type of email address.\n     * <p>\n     * <p>\n     * By convention, {@link #DATA15} is used for storing BLOBs (binary data).\n     * </p>\n     * <p>\n     * The sync adapter for a given account type must correctly handle every data type\n     * used in the corresponding raw contacts.  Otherwise it could result in lost or\n     * corrupted data.\n     * </p>\n     * <p>\n     * Similarly, you should refrain from introducing new kinds of data for an other\n     * party's account types. For example, if you add a data row for\n     * \"favorite song\" to a raw contact owned by a Google account, it will not\n     * get synced to the server, because the Google sync adapter does not know\n     * how to handle this data kind. Thus new data kinds are typically\n     * introduced along with new account types, i.e. new sync adapters.\n     * </p>\n     * <h3>Batch operations</h3>\n     * <p>\n     * Data rows can be inserted/updated/deleted using the traditional\n     * {@link ContentResolver#insert}, {@link ContentResolver#update} and\n     * {@link ContentResolver#delete} methods, however the newer mechanism based\n     * on a batch of {@link ContentProviderOperation} will prove to be a better\n     * choice in almost all cases. All operations in a batch are executed in a\n     * single transaction, which ensures that the phone-side and server-side\n     * state of a raw contact are always consistent. Also, the batch-based\n     * approach is far more efficient: not only are the database operations\n     * faster when executed in a single transaction, but also sending a batch of\n     * commands to the content provider saves a lot of time on context switching\n     * between your process and the process in which the content provider runs.\n     * </p>\n     * <p>\n     * The flip side of using batched operations is that a large batch may lock\n     * up the database for a long time preventing other applications from\n     * accessing data and potentially causing ANRs (\"Application Not Responding\"\n     * dialogs.)\n     * </p>\n     * <p>\n     * To avoid such lockups of the database, make sure to insert \"yield points\"\n     * in the batch. A yield point indicates to the content provider that before\n     * executing the next operation it can commit the changes that have already\n     * been made, yield to other requests, open another transaction and continue\n     * processing operations. A yield point will not automatically commit the\n     * transaction, but only if there is another request waiting on the\n     * database. Normally a sync adapter should insert a yield point at the\n     * beginning of each raw contact operation sequence in the batch. See\n     * {@link ContentProviderOperation.Builder#withYieldAllowed(boolean)}.\n     * </p>\n     * <h3>Operations</h3>\n     * <dl>\n     * <dt><b>Insert</b></dt>\n     * <dd>\n     * <p>\n     * An individual data row can be inserted using the traditional\n     * {@link ContentResolver#insert(Uri, ContentValues)} method. Multiple rows\n     * should always be inserted as a batch.\n     * </p>\n     * <p>\n     * An example of a traditional insert:\n     * <pre>\n     * ContentValues values = new ContentValues();\n     * values.put(Data.RAW_CONTACT_ID, rawContactId);\n     * values.put(Data.MIMETYPE, Phone.CONTENT_ITEM_TYPE);\n     * values.put(Phone.NUMBER, \"1-800-GOOG-411\");\n     * values.put(Phone.TYPE, Phone.TYPE_CUSTOM);\n     * values.put(Phone.LABEL, \"free directory assistance\");\n     * Uri dataUri = getContentResolver().insert(Data.CONTENT_URI, values);\n     * </pre>\n     * <p>\n     * The same done using ContentProviderOperations:\n     * <pre>\n     * ArrayList&lt;ContentProviderOperation&gt; ops =\n     *          new ArrayList&lt;ContentProviderOperation&gt;();\n     *\n     * ops.add(ContentProviderOperation.newInsert(Data.CONTENT_URI)\n     *          .withValue(Data.RAW_CONTACT_ID, rawContactId)\n     *          .withValue(Data.MIMETYPE, Phone.CONTENT_ITEM_TYPE)\n     *          .withValue(Phone.NUMBER, \"1-800-GOOG-411\")\n     *          .withValue(Phone.TYPE, Phone.TYPE_CUSTOM)\n     *          .withValue(Phone.LABEL, \"free directory assistance\")\n     *          .build());\n     * getContentResolver().applyBatch(ContactsContract.AUTHORITY, ops);\n     * </pre>\n     * </p>\n     * <dt><b>Update</b></dt>\n     * <dd>\n     * <p>\n     * Just as with insert, update can be done incrementally or as a batch,\n     * the batch mode being the preferred method:\n     * <pre>\n     * ArrayList&lt;ContentProviderOperation&gt; ops =\n     *          new ArrayList&lt;ContentProviderOperation&gt;();\n     *\n     * ops.add(ContentProviderOperation.newUpdate(Data.CONTENT_URI)\n     *          .withSelection(Data._ID + \"=?\", new String[]{String.valueOf(dataId)})\n     *          .withValue(Email.DATA, \"somebody@android.com\")\n     *          .build());\n     * getContentResolver().applyBatch(ContactsContract.AUTHORITY, ops);\n     * </pre>\n     * </p>\n     * </dd>\n     * <dt><b>Delete</b></dt>\n     * <dd>\n     * <p>\n     * Just as with insert and update, deletion can be done either using the\n     * {@link ContentResolver#delete} method or using a ContentProviderOperation:\n     * <pre>\n     * ArrayList&lt;ContentProviderOperation&gt; ops =\n     *          new ArrayList&lt;ContentProviderOperation&gt;();\n     *\n     * ops.add(ContentProviderOperation.newDelete(Data.CONTENT_URI)\n     *          .withSelection(Data._ID + \"=?\", new String[]{String.valueOf(dataId)})\n     *          .build());\n     * getContentResolver().applyBatch(ContactsContract.AUTHORITY, ops);\n     * </pre>\n     * </p>\n     * </dd>\n     * <dt><b>Query</b></dt>\n     * <dd>\n     * <p>\n     * <dl>\n     * <dt>Finding all Data of a given type for a given contact</dt>\n     * <dd>\n     * <pre>\n     * Cursor c = getContentResolver().query(Data.CONTENT_URI,\n     *          new String[] {Data._ID, Phone.NUMBER, Phone.TYPE, Phone.LABEL},\n     *          Data.CONTACT_ID + &quot;=?&quot; + \" AND \"\n     *                  + Data.MIMETYPE + \"='\" + Phone.CONTENT_ITEM_TYPE + \"'\",\n     *          new String[] {String.valueOf(contactId)}, null);\n     * </pre>\n     * </p>\n     * <p>\n     * </dd>\n     * <dt>Finding all Data of a given type for a given raw contact</dt>\n     * <dd>\n     * <pre>\n     * Cursor c = getContentResolver().query(Data.CONTENT_URI,\n     *          new String[] {Data._ID, Phone.NUMBER, Phone.TYPE, Phone.LABEL},\n     *          Data.RAW_CONTACT_ID + &quot;=?&quot; + \" AND \"\n     *                  + Data.MIMETYPE + \"='\" + Phone.CONTENT_ITEM_TYPE + \"'\",\n     *          new String[] {String.valueOf(rawContactId)}, null);\n     * </pre>\n     * </dd>\n     * <dt>Finding all Data for a given raw contact</dt>\n     * <dd>\n     * Most sync adapters will want to read all data rows for a raw contact\n     * along with the raw contact itself.  For that you should use the\n     * {@link RawContactsEntity}. See also {@link RawContacts}.\n     * </dd>\n     * </dl>\n     * </p>\n     * </dd>\n     * </dl>\n     * <h2>Columns</h2>\n     * <p>\n     * Many columns are available via a {@link Data#CONTENT_URI} query.  For best performance you\n     * should explicitly specify a projection to only those columns that you need.\n     * </p>\n     * <table class=\"jd-sumtable\">\n     * <tr>\n     * <th colspan='4'>Data</th>\n     * </tr>\n     * <tr>\n     * <td style=\"width: 7em;\">long</td>\n     * <td style=\"width: 20em;\">{@link #_ID}</td>\n     * <td style=\"width: 5em;\">read-only</td>\n     * <td>Row ID. Sync adapter should try to preserve row IDs during updates. In other words,\n     * it would be a bad idea to delete and reinsert a data row. A sync adapter should\n     * always do an update instead.</td>\n     * </tr>\n     * <tr>\n     * <td>String</td>\n     * <td>{@link #MIMETYPE}</td>\n     * <td>read/write-once</td>\n     * <td>\n     * <p>The MIME type of the item represented by this row. Examples of common\n     * MIME types are:\n     * <ul>\n     * <li>{@link CommonDataKinds.StructuredName StructuredName.CONTENT_ITEM_TYPE}</li>\n     * <li>{@link CommonDataKinds.Phone Phone.CONTENT_ITEM_TYPE}</li>\n     * <li>{@link CommonDataKinds.Email Email.CONTENT_ITEM_TYPE}</li>\n     * <li>{@link CommonDataKinds.Photo Photo.CONTENT_ITEM_TYPE}</li>\n     * <li>{@link CommonDataKinds.Organization Organization.CONTENT_ITEM_TYPE}</li>\n     * <li>{@link CommonDataKinds.Im Im.CONTENT_ITEM_TYPE}</li>\n     * <li>{@link CommonDataKinds.Nickname Nickname.CONTENT_ITEM_TYPE}</li>\n     * <li>{@link CommonDataKinds.Note Note.CONTENT_ITEM_TYPE}</li>\n     * <li>{@link CommonDataKinds.StructuredPostal StructuredPostal.CONTENT_ITEM_TYPE}</li>\n     * <li>{@link CommonDataKinds.GroupMembership GroupMembership.CONTENT_ITEM_TYPE}</li>\n     * <li>{@link CommonDataKinds.Website Website.CONTENT_ITEM_TYPE}</li>\n     * <li>{@link CommonDataKinds.Event Event.CONTENT_ITEM_TYPE}</li>\n     * <li>{@link CommonDataKinds.Relation Relation.CONTENT_ITEM_TYPE}</li>\n     * <li>{@link CommonDataKinds.SipAddress SipAddress.CONTENT_ITEM_TYPE}</li>\n     * </ul>\n     * </p>\n     * </td>\n     * </tr>\n     * <tr>\n     * <td>long</td>\n     * <td>{@link #RAW_CONTACT_ID}</td>\n     * <td>read/write-once</td>\n     * <td>The id of the row in the {@link RawContacts} table that this data belongs to.</td>\n     * </tr>\n     * <tr>\n     * <td>int</td>\n     * <td>{@link #IS_PRIMARY}</td>\n     * <td>read/write</td>\n     * <td>Whether this is the primary entry of its kind for the raw contact it belongs to.\n     * \"1\" if true, \"0\" if false.\n     * </td>\n     * </tr>\n     * <tr>\n     * <td>int</td>\n     * <td>{@link #IS_SUPER_PRIMARY}</td>\n     * <td>read/write</td>\n     * <td>Whether this is the primary entry of its kind for the aggregate\n     * contact it belongs to. Any data record that is \"super primary\" must\n     * also be \"primary\".  For example, the super-primary entry may be\n     * interpreted as the default contact value of its kind (for example,\n     * the default phone number to use for the contact).</td>\n     * </tr>\n     * <tr>\n     * <td>int</td>\n     * <td>{@link #DATA_VERSION}</td>\n     * <td>read-only</td>\n     * <td>The version of this data record. Whenever the data row changes\n     * the version goes up. This value is monotonically increasing.</td>\n     * </tr>\n     * <tr>\n     * <td>Any type</td>\n     * <td>\n     * {@link #DATA1}<br>\n     * {@link #DATA2}<br>\n     * {@link #DATA3}<br>\n     * {@link #DATA4}<br>\n     * {@link #DATA5}<br>\n     * {@link #DATA6}<br>\n     * {@link #DATA7}<br>\n     * {@link #DATA8}<br>\n     * {@link #DATA9}<br>\n     * {@link #DATA10}<br>\n     * {@link #DATA11}<br>\n     * {@link #DATA12}<br>\n     * {@link #DATA13}<br>\n     * {@link #DATA14}<br>\n     * {@link #DATA15}\n     * </td>\n     * <td>read/write</td>\n     * <td>\n     * <p>\n     * Generic data columns.  The meaning of each column is determined by the\n     * {@link #MIMETYPE}.  By convention, {@link #DATA15} is used for storing\n     * BLOBs (binary data).\n     * </p>\n     * <p>\n     * Data columns whose meaning is not explicitly defined for a given MIMETYPE\n     * should not be used.  There is no guarantee that any sync adapter will\n     * preserve them.  Sync adapters themselves should not use such columns either,\n     * but should instead use {@link #SYNC1}-{@link #SYNC4}.\n     * </p>\n     * </td>\n     * </tr>\n     * <tr>\n     * <td>Any type</td>\n     * <td>\n     * {@link #SYNC1}<br>\n     * {@link #SYNC2}<br>\n     * {@link #SYNC3}<br>\n     * {@link #SYNC4}\n     * </td>\n     * <td>read/write</td>\n     * <td>Generic columns for use by sync adapters. For example, a Photo row\n     * may store the image URL in SYNC1, a status (not loaded, loading, loaded, error)\n     * in SYNC2, server-side version number in SYNC3 and error code in SYNC4.</td>\n     * </tr>\n     * </table>\n     *\n     * <p>\n     * Some columns from the most recent associated status update are also available\n     * through an implicit join.\n     * </p>\n     * <table class=\"jd-sumtable\">\n     * <tr>\n     * <th colspan='4'>Join with {@link StatusUpdates}</th>\n     * </tr>\n     * <tr>\n     * <td style=\"width: 7em;\">int</td>\n     * <td style=\"width: 20em;\">{@link #PRESENCE}</td>\n     * <td style=\"width: 5em;\">read-only</td>\n     * <td>IM presence status linked to this data row. Compare with\n     * {@link #CONTACT_PRESENCE}, which contains the contact's presence across\n     * all IM rows. See {@link StatusUpdates} for individual status definitions.\n     * The provider may choose not to store this value\n     * in persistent storage. The expectation is that presence status will be\n     * updated on a regular basis.\n     * </td>\n     * </tr>\n     * <tr>\n     * <td>String</td>\n     * <td>{@link #STATUS}</td>\n     * <td>read-only</td>\n     * <td>Latest status update linked with this data row.</td>\n     * </tr>\n     * <tr>\n     * <td>long</td>\n     * <td>{@link #STATUS_TIMESTAMP}</td>\n     * <td>read-only</td>\n     * <td>The absolute time in milliseconds when the latest status was\n     * inserted/updated for this data row.</td>\n     * </tr>\n     * <tr>\n     * <td>String</td>\n     * <td>{@link #STATUS_RES_PACKAGE}</td>\n     * <td>read-only</td>\n     * <td>The package containing resources for this status: label and icon.</td>\n     * </tr>\n     * <tr>\n     * <td>long</td>\n     * <td>{@link #STATUS_LABEL}</td>\n     * <td>read-only</td>\n     * <td>The resource ID of the label describing the source of status update linked\n     * to this data row. This resource is scoped by the {@link #STATUS_RES_PACKAGE}.</td>\n     * </tr>\n     * <tr>\n     * <td>long</td>\n     * <td>{@link #STATUS_ICON}</td>\n     * <td>read-only</td>\n     * <td>The resource ID of the icon for the source of the status update linked\n     * to this data row. This resource is scoped by the {@link #STATUS_RES_PACKAGE}.</td>\n     * </tr>\n     * </table>\n     *\n     * <p>\n     * Some columns from the associated raw contact are also available through an\n     * implicit join.  The other columns are excluded as uninteresting in this\n     * context.\n     * </p>\n     *\n     * <table class=\"jd-sumtable\">\n     * <tr>\n     * <th colspan='4'>Join with {@link ContactsContract.RawContacts}</th>\n     * </tr>\n     * <tr>\n     * <td style=\"width: 7em;\">long</td>\n     * <td style=\"width: 20em;\">{@link #CONTACT_ID}</td>\n     * <td style=\"width: 5em;\">read-only</td>\n     * <td>The id of the row in the {@link Contacts} table that this data belongs\n     * to.</td>\n     * </tr>\n     * <tr>\n     * <td>int</td>\n     * <td>{@link #AGGREGATION_MODE}</td>\n     * <td>read-only</td>\n     * <td>See {@link RawContacts}.</td>\n     * </tr>\n     * <tr>\n     * <td>int</td>\n     * <td>{@link #DELETED}</td>\n     * <td>read-only</td>\n     * <td>See {@link RawContacts}.</td>\n     * </tr>\n     * </table>\n     *\n     * <p>\n     * The ID column for the associated aggregated contact table\n     * {@link ContactsContract.Contacts} is available\n     * via the implicit join to the {@link RawContacts} table, see above.\n     * The remaining columns from this table are also\n     * available, through an implicit join.  This\n     * facilitates lookup by\n     * the value of a single data element, such as the email address.\n     * </p>\n     *\n     * <table class=\"jd-sumtable\">\n     * <tr>\n     * <th colspan='4'>Join with {@link ContactsContract.Contacts}</th>\n     * </tr>\n     * <tr>\n     * <td style=\"width: 7em;\">String</td>\n     * <td style=\"width: 20em;\">{@link #LOOKUP_KEY}</td>\n     * <td style=\"width: 5em;\">read-only</td>\n     * <td>See {@link ContactsContract.Contacts}</td>\n     * </tr>\n     * <tr>\n     * <td>String</td>\n     * <td>{@link #DISPLAY_NAME}</td>\n     * <td>read-only</td>\n     * <td>See {@link ContactsContract.Contacts}</td>\n     * </tr>\n     * <tr>\n     * <td>long</td>\n     * <td>{@link #PHOTO_ID}</td>\n     * <td>read-only</td>\n     * <td>See {@link ContactsContract.Contacts}.</td>\n     * </tr>\n     * <tr>\n     * <td>int</td>\n     * <td>{@link #IN_VISIBLE_GROUP}</td>\n     * <td>read-only</td>\n     * <td>See {@link ContactsContract.Contacts}.</td>\n     * </tr>\n     * <tr>\n     * <td>int</td>\n     * <td>{@link #HAS_PHONE_NUMBER}</td>\n     * <td>read-only</td>\n     * <td>See {@link ContactsContract.Contacts}.</td>\n     * </tr>\n     * <tr>\n     * <td>int</td>\n     * <td>{@link #STARRED}</td>\n     * <td>read-only</td>\n     * <td>See {@link ContactsContract.Contacts}.</td>\n     * </tr>\n     * <tr>\n     * <td>String</td>\n     * <td>{@link #CUSTOM_RINGTONE}</td>\n     * <td>read-only</td>\n     * <td>See {@link ContactsContract.Contacts}.</td>\n     * </tr>\n     * <tr>\n     * <td>int</td>\n     * <td>{@link #SEND_TO_VOICEMAIL}</td>\n     * <td>read-only</td>\n     * <td>See {@link ContactsContract.Contacts}.</td>\n     * </tr>\n     * <tr>\n     * <td>int</td>\n     * <td>{@link #CONTACT_PRESENCE}</td>\n     * <td>read-only</td>\n     * <td>See {@link ContactsContract.Contacts}.</td>\n     * </tr>\n     * <tr>\n     * <td>String</td>\n     * <td>{@link #CONTACT_STATUS}</td>\n     * <td>read-only</td>\n     * <td>See {@link ContactsContract.Contacts}.</td>\n     * </tr>\n     * <tr>\n     * <td>long</td>\n     * <td>{@link #CONTACT_STATUS_TIMESTAMP}</td>\n     * <td>read-only</td>\n     * <td>See {@link ContactsContract.Contacts}.</td>\n     * </tr>\n     * <tr>\n     * <td>String</td>\n     * <td>{@link #CONTACT_STATUS_RES_PACKAGE}</td>\n     * <td>read-only</td>\n     * <td>See {@link ContactsContract.Contacts}.</td>\n     * </tr>\n     * <tr>\n     * <td>long</td>\n     * <td>{@link #CONTACT_STATUS_LABEL}</td>\n     * <td>read-only</td>\n     * <td>See {@link ContactsContract.Contacts}.</td>\n     * </tr>\n     * <tr>\n     * <td>long</td>\n     * <td>{@link #CONTACT_STATUS_ICON}</td>\n     * <td>read-only</td>\n     * <td>See {@link ContactsContract.Contacts}.</td>\n     * </tr>\n     * </table>\n     ",
  "variables" : [ {
    "name" : "CONTENT_URI",
    "type" : "Uri",
    "comment" : "\n         * The content:// style URI for this table, which requests a directory\n         * of data rows matching the selection criteria.\n         ",
    "links" : [ ]
  }, {
    "name" : "ENTERPRISE_CONTENT_URI",
    "type" : "Uri",
    "comment" : "\n        * The content:// style URI for this table in managed profile, which requests a directory\n        * of data rows matching the selection criteria.\n        *\n        * @hide\n        ",
    "links" : [ ]
  }, {
    "name" : "VISIBLE_CONTACTS_ONLY",
    "type" : "String",
    "comment" : "\n         * A boolean parameter for {@link Data#CONTENT_URI}.\n         * This specifies whether or not the returned data items should be filtered to show\n         * data items belonging to visible contacts only.\n         ",
    "links" : [ "#CONTENT_URI" ]
  }, {
    "name" : "CONTENT_TYPE",
    "type" : "String",
    "comment" : "\n         * The MIME type of the results from {@link #CONTENT_URI}.\n         ",
    "links" : [ "#CONTENT_URI" ]
  } ],
  "methods" : [ {
    "name" : "public static Uri getContactLookupUri(ContentResolver resolver, Uri dataUri)",
    "returnType" : "Uri",
    "comment" : "\n         * <p>\n         * Build a {@link android.provider.ContactsContract.Contacts#CONTENT_LOOKUP_URI}\n         * style {@link Uri} for the parent {@link android.provider.ContactsContract.Contacts}\n         * entry of the given {@link ContactsContract.Data} entry.\n         * </p>\n         * <p>\n         * Returns the Uri for the contact in the first entry returned by\n         * {@link ContentResolver#query(Uri, String[], String, String[], String)}\n         * for the provided {@code dataUri}.  If the query returns null or empty\n         * results, silently returns null.\n         * </p>\n         ",
    "links" : [ "android.provider.ContactsContract.Contacts", "android.provider.ContactsContract.Contacts#CONTENT_LOOKUP_URI", "android.content.ContentResolver#query(Uri", "ContactsContract.Data", "android.net.Uri" ]
  } ],
  "variableNames" : [ "CONTENT_URI", "ENTERPRISE_CONTENT_URI", "VISIBLE_CONTACTS_ONLY", "CONTENT_TYPE" ],
  "methodNames" : [ "public static Uri getContactLookupUri(ContentResolver resolver, Uri dataUri)" ]
}