{
  "filePath" : "/home/maryam/clearblue/files/android-source-35/android/media/MediaFormat.java",
  "packageName" : "android.media",
  "className" : "MediaFormat",
  "comment" : "\n * Encapsulates the information describing the format of media data, be it audio or video, as\n * well as optional feature metadata.\n * <p>\n * The format of the media data is specified as key/value pairs. Keys are strings. Values can\n * be integer, long, float, String or ByteBuffer.\n * <p>\n * The feature metadata is specificed as string/boolean pairs.\n * <p>\n * Keys common to all audio/video formats, <b>all keys not marked optional are mandatory</b>:\n *\n * <table>\n * <tr><th>Name</th><th>Value Type</th><th>Description</th></tr>\n * <tr><td>{@link #KEY_MIME}</td><td>String</td><td>The type of the format.</td></tr>\n * <tr><td>{@link #KEY_CODECS_STRING}</td><td>String</td><td>optional, the RFC 6381 codecs string of the MediaFormat</td></tr>\n * <tr><td>{@link #KEY_MAX_INPUT_SIZE}</td><td>Integer</td><td>optional, maximum size of a buffer of input data</td></tr>\n * <tr><td>{@link #KEY_PIXEL_ASPECT_RATIO_WIDTH}</td><td>Integer</td><td>optional, the pixel aspect ratio width</td></tr>\n * <tr><td>{@link #KEY_PIXEL_ASPECT_RATIO_HEIGHT}</td><td>Integer</td><td>optional, the pixel aspect ratio height</td></tr>\n * <tr><td>{@link #KEY_BIT_RATE}</td><td>Integer</td><td><b>encoder-only</b>, desired bitrate in bits/second</td></tr>\n * <tr><td>{@link #KEY_DURATION}</td><td>long</td><td>the duration of the content (in microseconds)</td></tr>\n * </table>\n *\n * Video formats have the following keys:\n * <table>\n * <tr><th>Name</th><th>Value Type</th><th>Description</th></tr>\n * <tr><td>{@link #KEY_WIDTH}</td><td>Integer</td><td></td></tr>\n * <tr><td>{@link #KEY_HEIGHT}</td><td>Integer</td><td></td></tr>\n * <tr><td>{@link #KEY_COLOR_FORMAT}</td><td>Integer</td><td>set by the user\n *         for encoders, readable in the output format of decoders</b></td></tr>\n * <tr><td>{@link #KEY_FRAME_RATE}</td><td>Integer or Float</td><td>required for <b>encoders</b>,\n *         optional for <b>decoders</b></td></tr>\n * <tr><td>{@link #KEY_CAPTURE_RATE}</td><td>Integer</td><td></td></tr>\n * <tr><td>{@link #KEY_I_FRAME_INTERVAL}</td><td>Integer (or Float)</td><td><b>encoder-only</b>,\n *         time-interval between key frames.\n *         Float support added in {@link android.os.Build.VERSION_CODES#N_MR1}</td></tr>\n * <tr><td>{@link #KEY_INTRA_REFRESH_PERIOD}</td><td>Integer</td><td><b>encoder-only</b>, optional</td></tr>\n * <tr><td>{@link #KEY_LATENCY}</td><td>Integer</td><td><b>encoder-only</b>, optional</td></tr>\n * <tr><td>{@link #KEY_MAX_WIDTH}</td><td>Integer</td><td><b>decoder-only</b>, optional, max-resolution width</td></tr>\n * <tr><td>{@link #KEY_MAX_HEIGHT}</td><td>Integer</td><td><b>decoder-only</b>, optional, max-resolution height</td></tr>\n * <tr><td>{@link #KEY_REPEAT_PREVIOUS_FRAME_AFTER}</td><td>Long</td><td><b>encoder in surface-mode\n *         only</b>, optional</td></tr>\n * <tr><td>{@link #KEY_PUSH_BLANK_BUFFERS_ON_STOP}</td><td>Integer(1)</td><td><b>decoder rendering\n *         to a surface only</b>, optional</td></tr>\n * <tr><td>{@link #KEY_TEMPORAL_LAYERING}</td><td>String</td><td><b>encoder only</b>, optional,\n *         temporal-layering schema</td></tr>\n * </table>\n * Specify both {@link #KEY_MAX_WIDTH} and {@link #KEY_MAX_HEIGHT} to enable\n * adaptive playback (seamless resolution change) for a video decoder that\n * supports it ({@link MediaCodecInfo.CodecCapabilities#FEATURE_AdaptivePlayback}).\n * The values are used as hints for the codec: they are the maximum expected\n * resolution to prepare for.  Depending on codec support, preparing for larger\n * maximum resolution may require more memory even if that resolution is never\n * reached.  These fields have no effect for codecs that do not support adaptive\n * playback.<br /><br />\n *\n * Audio formats have the following keys:\n * <table>\n * <tr><th>Name</th><th>Value Type</th><th>Description</th></tr>\n * <tr><td>{@link #KEY_CHANNEL_COUNT}</td><td>Integer</td><td></td></tr>\n * <tr><td>{@link #KEY_SAMPLE_RATE}</td><td>Integer</td><td></td></tr>\n * <tr><td>{@link #KEY_PCM_ENCODING}</td><td>Integer</td><td>optional</td></tr>\n * <tr><td>{@link #KEY_IS_ADTS}</td><td>Integer</td><td>optional, if <em>decoding</em> AAC audio content, setting this key to 1 indicates that each audio frame is prefixed by the ADTS header.</td></tr>\n * <tr><td>{@link #KEY_AAC_PROFILE}</td><td>Integer</td><td><b>encoder-only</b>, optional, if content is AAC audio, specifies the desired profile.</td></tr>\n * <tr><td>{@link #KEY_AAC_SBR_MODE}</td><td>Integer</td><td><b>encoder-only</b>, optional, if content is AAC audio, specifies the desired SBR mode.</td></tr>\n * <tr><td>{@link #KEY_AAC_DRC_TARGET_REFERENCE_LEVEL}</td><td>Integer</td><td><b>decoder-only</b>, optional, if content is AAC audio, specifies the target reference level.</td></tr>\n * <tr><td>{@link #KEY_AAC_ENCODED_TARGET_LEVEL}</td><td>Integer</td><td><b>decoder-only</b>, optional, if content is AAC audio, specifies the target reference level used at encoder.</td></tr>\n * <tr><td>{@link #KEY_AAC_DRC_BOOST_FACTOR}</td><td>Integer</td><td><b>decoder-only</b>, optional, if content is AAC audio, specifies the DRC boost factor.</td></tr>\n * <tr><td>{@link #KEY_AAC_DRC_ATTENUATION_FACTOR}</td><td>Integer</td><td><b>decoder-only</b>, optional, if content is AAC audio, specifies the DRC attenuation factor.</td></tr>\n * <tr><td>{@link #KEY_AAC_DRC_HEAVY_COMPRESSION}</td><td>Integer</td><td><b>decoder-only</b>, optional, if content is AAC audio, specifies whether to use heavy compression.</td></tr>\n * <tr><td>{@link #KEY_AAC_MAX_OUTPUT_CHANNEL_COUNT}</td><td>Integer</td><td><b>decoder-only</b>, optional, if content is AAC audio, specifies the maximum number of channels the decoder outputs.</td></tr>\n * <tr><td>{@link #KEY_AAC_DRC_EFFECT_TYPE}</td><td>Integer</td><td><b>decoder-only</b>, optional, if content is AAC audio, specifies the MPEG-D DRC effect type to use.</td></tr>\n * <tr><td>{@link #KEY_AAC_DRC_OUTPUT_LOUDNESS}</td><td>Integer</td><td><b>decoder-only</b>, optional, if content is AAC audio, returns the DRC output loudness.</td></tr>\n * <tr><td>{@link #KEY_AAC_DRC_ALBUM_MODE}</td><td>Integer</td><td><b>decoder-only</b>, optional, if content is AAC audio, specifies the whether MPEG-D DRC Album Mode is active or not.</td></tr>\n * <tr><td>{@link #KEY_CHANNEL_MASK}</td><td>Integer</td><td>optional, a mask of audio channel assignments</td></tr>\n * <tr><td>{@link #KEY_ENCODER_DELAY}</td><td>Integer</td><td>optional, the number of frames to trim from the start of the decoded audio stream.</td></tr>\n * <tr><td>{@link #KEY_ENCODER_PADDING}</td><td>Integer</td><td>optional, the number of frames to trim from the end of the decoded audio stream.</td></tr>\n * <tr><td>{@link #KEY_FLAC_COMPRESSION_LEVEL}</td><td>Integer</td><td><b>encoder-only</b>, optional, if content is FLAC audio, specifies the desired compression level.</td></tr>\n * <tr><td>{@link #KEY_MPEGH_PROFILE_LEVEL_INDICATION}</td><td>Integer</td>\n *     <td><b>decoder-only</b>, optional, if content is MPEG-H audio,\n *         specifies the profile and level of the stream.</td></tr>\n * <tr><td>{@link #KEY_MPEGH_COMPATIBLE_SETS}</td><td>ByteBuffer</td>\n *     <td><b>decoder-only</b>, optional, if content is MPEG-H audio,\n *         specifies the compatible sets (profile and level) of the stream.</td></tr>\n * <tr><td>{@link #KEY_MPEGH_REFERENCE_CHANNEL_LAYOUT}</td>\n *     <td>Integer</td><td><b>decoder-only</b>, optional, if content is MPEG-H audio,\n *         specifies the preferred reference channel layout of the stream.</td></tr>\n * <tr><td>{@link #KEY_MAX_BUFFER_BATCH_OUTPUT_SIZE}</td><td>Integer</td><td>optional, used with\n *         large audio frame support, specifies max size of output buffer in bytes.</td></tr>\n * <tr><td>{@link #KEY_BUFFER_BATCH_THRESHOLD_OUTPUT_SIZE}</td><td>Integer</td><td>optional,\n *         used with large audio frame support, specifies threshold output size in bytes.</td></tr>\n * </table>\n *\n * Subtitle formats have the following keys:\n * <table>\n * <tr><td>{@link #KEY_MIME}</td><td>String</td><td>The type of the format.</td></tr>\n * <tr><td>{@link #KEY_LANGUAGE}</td><td>String</td><td>The language of the content.</td></tr>\n * <tr><td>{@link #KEY_CAPTION_SERVICE_NUMBER}</td><td>int</td><td>optional, the closed-caption service or channel number.</td></tr>\n * </table>\n *\n * Image formats have the following keys:\n * <table>\n * <tr><td>{@link #KEY_MIME}</td><td>String</td><td>The type of the format.</td></tr>\n * <tr><td>{@link #KEY_WIDTH}</td><td>Integer</td><td></td></tr>\n * <tr><td>{@link #KEY_HEIGHT}</td><td>Integer</td><td></td></tr>\n * <tr><td>{@link #KEY_COLOR_FORMAT}</td><td>Integer</td><td>set by the user\n *         for encoders, readable in the output format of decoders</b></td></tr>\n * <tr><td>{@link #KEY_TILE_WIDTH}</td><td>Integer</td><td>required if the image has grid</td></tr>\n * <tr><td>{@link #KEY_TILE_HEIGHT}</td><td>Integer</td><td>required if the image has grid</td></tr>\n * <tr><td>{@link #KEY_GRID_ROWS}</td><td>Integer</td><td>required if the image has grid</td></tr>\n * <tr><td>{@link #KEY_GRID_COLUMNS}</td><td>Integer</td><td>required if the image has grid</td></tr>\n * </table>\n ",
  "links" : [ "#KEY_FRAME_RATE", "#KEY_MAX_INPUT_SIZE", "#KEY_LANGUAGE", "#KEY_TEMPORAL_LAYERING", "#KEY_PCM_ENCODING", "#KEY_GRID_COLUMNS", "#KEY_ENCODER_PADDING", "#KEY_MAX_BUFFER_BATCH_OUTPUT_SIZE", "#KEY_I_FRAME_INTERVAL", "#KEY_PIXEL_ASPECT_RATIO_WIDTH", "#KEY_MPEGH_PROFILE_LEVEL_INDICATION", "#KEY_CAPTURE_RATE", "#KEY_MPEGH_REFERENCE_CHANNEL_LAYOUT", "#KEY_AAC_DRC_HEAVY_COMPRESSION", "android.os.Build.VERSION_CODES#N_MR1", "#KEY_BUFFER_BATCH_THRESHOLD_OUTPUT_SIZE", "#KEY_AAC_MAX_OUTPUT_CHANNEL_COUNT", "#KEY_AAC_DRC_OUTPUT_LOUDNESS", "#KEY_LATENCY", "#KEY_AAC_DRC_EFFECT_TYPE", "#KEY_HEIGHT", "#KEY_ENCODER_DELAY", "#KEY_CODECS_STRING", "#KEY_CHANNEL_MASK", "#KEY_WIDTH", "#KEY_MPEGH_COMPATIBLE_SETS", "#KEY_PIXEL_ASPECT_RATIO_HEIGHT", "#KEY_REPEAT_PREVIOUS_FRAME_AFTER", "#KEY_COLOR_FORMAT", "#KEY_DURATION", "#KEY_IS_ADTS", "#KEY_MIME", "MediaCodecInfo.CodecCapabilities#FEATURE_AdaptivePlayback", "#KEY_TILE_WIDTH", "#KEY_FLAC_COMPRESSION_LEVEL", "#KEY_MAX_WIDTH", "#KEY_MAX_HEIGHT", "#KEY_SAMPLE_RATE", "#KEY_BIT_RATE", "#KEY_TILE_HEIGHT", "#KEY_INTRA_REFRESH_PERIOD", "#KEY_CAPTION_SERVICE_NUMBER", "#KEY_GRID_ROWS", "#KEY_AAC_DRC_TARGET_REFERENCE_LEVEL", "#KEY_AAC_PROFILE", "#KEY_AAC_DRC_BOOST_FACTOR", "#KEY_CHANNEL_COUNT", "#KEY_PUSH_BLANK_BUFFERS_ON_STOP", "#KEY_AAC_ENCODED_TARGET_LEVEL", "#KEY_AAC_DRC_ALBUM_MODE", "#KEY_AAC_SBR_MODE", "#KEY_AAC_DRC_ATTENUATION_FACTOR" ],
  "variables" : [ {
    "name" : "MIMETYPE_VIDEO_VP8",
    "type" : "String",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "MIMETYPE_VIDEO_VP9",
    "type" : "String",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "MIMETYPE_VIDEO_AV1",
    "type" : "String",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "MIMETYPE_VIDEO_AVC",
    "type" : "String",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "MIMETYPE_VIDEO_HEVC",
    "type" : "String",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "MIMETYPE_VIDEO_MPEG4",
    "type" : "String",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "MIMETYPE_VIDEO_H263",
    "type" : "String",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "MIMETYPE_VIDEO_MPEG2",
    "type" : "String",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "MIMETYPE_VIDEO_RAW",
    "type" : "String",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "MIMETYPE_VIDEO_DOLBY_VISION",
    "type" : "String",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "MIMETYPE_VIDEO_SCRAMBLED",
    "type" : "String",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "MIMETYPE_AUDIO_AMR_NB",
    "type" : "String",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "MIMETYPE_AUDIO_AMR_WB",
    "type" : "String",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "MIMETYPE_AUDIO_MPEG",
    "type" : "String",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "MIMETYPE_AUDIO_AAC",
    "type" : "String",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "MIMETYPE_AUDIO_QCELP",
    "type" : "String",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "MIMETYPE_AUDIO_VORBIS",
    "type" : "String",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "MIMETYPE_AUDIO_OPUS",
    "type" : "String",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "MIMETYPE_AUDIO_G711_ALAW",
    "type" : "String",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "MIMETYPE_AUDIO_G711_MLAW",
    "type" : "String",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "MIMETYPE_AUDIO_RAW",
    "type" : "String",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "MIMETYPE_AUDIO_FLAC",
    "type" : "String",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "MIMETYPE_AUDIO_MSGSM",
    "type" : "String",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "MIMETYPE_AUDIO_AC3",
    "type" : "String",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "MIMETYPE_AUDIO_EAC3",
    "type" : "String",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "MIMETYPE_AUDIO_EAC3_JOC",
    "type" : "String",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "MIMETYPE_AUDIO_AC4",
    "type" : "String",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "MIMETYPE_AUDIO_SCRAMBLED",
    "type" : "String",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "MIMETYPE_AUDIO_MPEGH_MHA1",
    "type" : "String",
    "comment" : " MIME type for MPEG-H Audio single stream ",
    "links" : [ ]
  }, {
    "name" : "MIMETYPE_AUDIO_MPEGH_MHM1",
    "type" : "String",
    "comment" : " MIME type for MPEG-H Audio single stream, encapsulated in MHAS ",
    "links" : [ ]
  }, {
    "name" : "MIMETYPE_AUDIO_DTS",
    "type" : "String",
    "comment" : " MIME type for DTS Digital Surround (up to 5.1 channels) audio stream, aka DTS-CA. ",
    "links" : [ ]
  }, {
    "name" : "MIMETYPE_AUDIO_DTS_HD",
    "type" : "String",
    "comment" : "\n     * MIME type for DTS HD (up to 7.1 channels) audio stream.\n     * With codec profile DTS_HDProfileHRA represents DTS HD High Resolution Audio.\n     * With codec profile DTS_HDProfileMA represents DTS HD Master Audio.\n     * With codec profile DTS_HDProfileLBR represents DTS Express.\n     ",
    "links" : [ ]
  }, {
    "name" : "MIMETYPE_AUDIO_DTS_UHD",
    "type" : "String",
    "comment" : "\n     * MIME type for DTS UHD (object-based) audio stream, aka DTS:X.\n     * With codec profile DTS_UHDProfileP1 represents DTS-UHD P1.\n     * With codec profile DTS_UHDProfileP2 represents DTS-UHD P2.\n     ",
    "links" : [ ]
  }, {
    "name" : "MIMETYPE_AUDIO_DRA",
    "type" : "String",
    "comment" : " MIME type for Dynamic Resolution Adaptation (DRA) audio stream. ",
    "links" : [ ]
  }, {
    "name" : "MIMETYPE_AUDIO_DOLBY_MAT",
    "type" : "String",
    "comment" : " MIME type for Dolby Metadata-enhanced Audio Transmission (MAT) audio stream. ",
    "links" : [ ]
  }, {
    "name" : "MIMETYPE_AUDIO_DOLBY_TRUEHD",
    "type" : "String",
    "comment" : " MIME type for Dolby TrueHD audio format, based on Meridian Lossless Packing (MLP). ",
    "links" : [ ]
  }, {
    "name" : "MIMETYPE_AUDIO_AAC_LC",
    "type" : "String",
    "comment" : "\n     * MIME type for AAC Low Complexity (LC) audio stream. Uses the scheme defined by\n     * RFC 6381 with OTI of MPEG-4 (40) and AOT of AAC LC (2) from ISO/IEC 14496-3.\n     ",
    "links" : [ ]
  }, {
    "name" : "MIMETYPE_AUDIO_AAC_HE_V1",
    "type" : "String",
    "comment" : "\n     * MIME type for HE-AAC v1 (LC + SBR) audio stream. Uses the scheme defined by\n     * RFC 6381 with OTI of MPEG-4 (40) and AOT of AAC SBR (5) from ISO/IEC 14496-3.\n     ",
    "links" : [ ]
  }, {
    "name" : "MIMETYPE_AUDIO_AAC_HE_V2",
    "type" : "String",
    "comment" : "\n     * MIME type for HE-AAC v2 (LC + SBR + PS) audio stream. Uses the scheme defined by\n     * RFC 6381 with OTI of MPEG-4 (40) and AOT of PS (29) from ISO/IEC 14496-3.\n     ",
    "links" : [ ]
  }, {
    "name" : "MIMETYPE_AUDIO_AAC_ELD",
    "type" : "String",
    "comment" : "\n     * MIME type for AAC Enhanced Low Delay (ELD) audio stream. Uses the scheme defined by\n     * RFC 6381 with OTI of MPEG-4 (40) and AOT of ELD (39) from ISO/IEC 14496-3.\n     ",
    "links" : [ ]
  }, {
    "name" : "MIMETYPE_AUDIO_AAC_XHE",
    "type" : "String",
    "comment" : "\n     * MIME type for AAC XHE audio stream. Uses the scheme defined by\n     * RFC 6381 with OTI of MPEG-4 (40) and AOT of USAC (42) from ISO/IEC 14496-3.\n     ",
    "links" : [ ]
  }, {
    "name" : "MIMETYPE_AUDIO_MPEGH_BL_L3",
    "type" : "String",
    "comment" : "\n     * MIME type for MPEG-H Baseline (BL) Profile L3 audio stream. Uses the scheme defined by\n     * RFC 6381 with mpegh3daProfileLevelIndication for main profile/L3 (0x3) from ISO/IEC 23008-3.\n     ",
    "links" : [ ]
  }, {
    "name" : "MIMETYPE_AUDIO_MPEGH_BL_L4",
    "type" : "String",
    "comment" : "\n     * MIME type for MPEG-H Baseline (BL) Profile L4 audio stream. Uses the scheme defined by\n     * RFC 6381 with mpegh3daProfileLevelIndication for main profile/L4 (0x4) from ISO/IEC 23008-3.\n     ",
    "links" : [ ]
  }, {
    "name" : "MIMETYPE_AUDIO_MPEGH_LC_L3",
    "type" : "String",
    "comment" : "\n     * MIME type for MPEG-H Low Complexity (LC) L3 audio stream. Uses the scheme defined by\n     * RFC 6381 with mpegh3daProfileLevelIndication for LC profile/L3 (0xD) from ISO/IEC 23008-3.\n     ",
    "links" : [ ]
  }, {
    "name" : "MIMETYPE_AUDIO_MPEGH_LC_L4",
    "type" : "String",
    "comment" : "\n     * MIME type for MPEG-H Low Complexity (LC) L4 audio stream. Uses the scheme defined by\n     * RFC 6381 with mpegh3daProfileLevelIndication for LC profile/L4 (0xE) from ISO/IEC 23008-3.\n     ",
    "links" : [ ]
  }, {
    "name" : "MIMETYPE_AUDIO_IEC61937",
    "type" : "String",
    "comment" : "\n     * MIME type for the IEC61937 audio stream encapsulation. This type isn't defined by IANA.\n     ",
    "links" : [ ]
  }, {
    "name" : "MIMETYPE_IMAGE_ANDROID_HEIC",
    "type" : "String",
    "comment" : "\n     * MIME type for HEIF still image data encoded in HEVC.\n     *\n     * To decode such an image, {@link MediaCodec} decoder for\n     * {@link #MIMETYPE_VIDEO_HEVC} shall be used. The client needs to form\n     * the correct {@link #MediaFormat} based on additional information in\n     * the track format (shown in the next paragraph), and send it to\n     * {@link MediaCodec#configure}.\n     *\n     * The track's MediaFormat will come with {@link #KEY_WIDTH} and\n     * {@link #KEY_HEIGHT} keys, which describes the width and height\n     * of the image. If the image doesn't contain grid (i.e. none of\n     * {@link #KEY_TILE_WIDTH}, {@link #KEY_TILE_HEIGHT},\n     * {@link #KEY_GRID_ROWS}, {@link #KEY_GRID_COLUMNS} are present), the\n     * track will contain a single sample of coded data for the entire image,\n     * and the image width and height should be used to set up the decoder.\n     *\n     * If the image does come with grid, each sample from the track will\n     * contain one tile in the grid, of which the size is described by\n     * {@link #KEY_TILE_WIDTH} and {@link #KEY_TILE_HEIGHT}. This size\n     * (instead of {@link #KEY_WIDTH} and {@link #KEY_HEIGHT}) should be\n     * used to set up the decoder. The track contains {@link #KEY_GRID_ROWS}\n     * by {@link #KEY_GRID_COLUMNS} samples in row-major, top-row first,\n     * left-to-right order. The output image should be reconstructed by\n     * first tiling the decoding results of the tiles in the correct order,\n     * then trimming (before rotation is applied) on the bottom and right\n     * side, if the tiled area is larger than the image width and height.\n     ",
    "links" : [ "android.media.MediaCodec", "#KEY_HEIGHT", "#KEY_TILE_HEIGHT", "#KEY_WIDTH", "#KEY_GRID_COLUMNS", "#KEY_GRID_ROWS", "#MIMETYPE_VIDEO_HEVC", "android.media.MediaCodec#configure", "#MediaFormat", "#KEY_TILE_WIDTH" ]
  }, {
    "name" : "MIMETYPE_IMAGE_AVIF",
    "type" : "String",
    "comment" : "\n     * MIME type for AVIF still image data encoded in AV1.\n     *\n     * To decode such an image, {@link MediaCodec} decoder for\n     * {@link #MIMETYPE_VIDEO_AV1} shall be used. The client needs to form\n     * the correct {@link #MediaFormat} based on additional information in\n     * the track format (shown in the next paragraph), and send it to\n     * {@link MediaCodec#configure}.\n     *\n     * The track's MediaFormat will come with {@link #KEY_WIDTH} and\n     * {@link #KEY_HEIGHT} keys, which describes the width and height\n     * of the image. If the image doesn't contain grid (i.e. none of\n     * {@link #KEY_TILE_WIDTH}, {@link #KEY_TILE_HEIGHT},\n     * {@link #KEY_GRID_ROWS}, {@link #KEY_GRID_COLUMNS} are present), the\n     * track will contain a single sample of coded data for the entire image,\n     * and the image width and height should be used to set up the decoder.\n     *\n     * If the image does come with grid, each sample from the track will\n     * contain one tile in the grid, of which the size is described by\n     * {@link #KEY_TILE_WIDTH} and {@link #KEY_TILE_HEIGHT}. This size\n     * (instead of {@link #KEY_WIDTH} and {@link #KEY_HEIGHT}) should be\n     * used to set up the decoder. The track contains {@link #KEY_GRID_ROWS}\n     * by {@link #KEY_GRID_COLUMNS} samples in row-major, top-row first,\n     * left-to-right order. The output image should be reconstructed by\n     * first tiling the decoding results of the tiles in the correct order,\n     * then trimming (before rotation is applied) on the bottom and right\n     * side, if the tiled area is larger than the image width and height.\n     ",
    "links" : [ "#MIMETYPE_VIDEO_AV1", "android.media.MediaCodec", "#KEY_HEIGHT", "#KEY_TILE_HEIGHT", "#KEY_WIDTH", "#KEY_GRID_COLUMNS", "#KEY_GRID_ROWS", "android.media.MediaCodec#configure", "#MediaFormat", "#KEY_TILE_WIDTH" ]
  }, {
    "name" : "MIMETYPE_TEXT_VTT",
    "type" : "String",
    "comment" : "\n     * MIME type for WebVTT subtitle data.\n     ",
    "links" : [ ]
  }, {
    "name" : "MIMETYPE_TEXT_SUBRIP",
    "type" : "String",
    "comment" : "\n     * MIME type for SubRip (SRT) container.\n     ",
    "links" : [ ]
  }, {
    "name" : "MIMETYPE_TEXT_CEA_608",
    "type" : "String",
    "comment" : "\n     * MIME type for CEA-608 closed caption data.\n     ",
    "links" : [ ]
  }, {
    "name" : "MIMETYPE_TEXT_CEA_708",
    "type" : "String",
    "comment" : "\n     * MIME type for CEA-708 closed caption data.\n     ",
    "links" : [ ]
  }, {
    "name" : "mMap",
    "type" : "Map<String, Object>",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "LOG_SESSION_ID",
    "type" : "String",
    "comment" : "\n     * A key describing the log session ID for MediaCodec. The log session ID is a random 32-byte\n     * hexadecimal string that is used to associate metrics from multiple media codec instances\n     * to the same playback or recording session. The value is created as\n     * {@link android.media.metrics.LogSessionId LogSessionId}. Sessions are created in\n     * {@link android.media.metrics.MediaMetricsManager MediaMetricsManager}.\n     * The associated value is a string.\n     ",
    "links" : [ "android.media.metrics.LogSessionId", "android.media.metrics.MediaMetricsManager" ]
  }, {
    "name" : "KEY_MIME",
    "type" : "String",
    "comment" : "\n     * A key describing the mime type of the MediaFormat.\n     * The associated value is a string.\n     ",
    "links" : [ ]
  }, {
    "name" : "KEY_CODECS_STRING",
    "type" : "String",
    "comment" : "\n     * A key describing the codecs string of the MediaFormat. See RFC 6381 section 3.2 for the\n     * syntax of the value. The value does not hold {@link MediaCodec}-exposed codec names.\n     * The associated value is a string.\n     *\n     * @see MediaParser.TrackData#mediaFormat\n     ",
    "links" : [ "android.media.MediaCodec" ]
  }, {
    "name" : "KEY_LOW_LATENCY",
    "type" : "String",
    "comment" : "\n     * An optional key describing the low latency decoding mode. This is an optional parameter\n     * that applies only to decoders. If enabled, the decoder doesn't hold input and output\n     * data more than required by the codec standards.\n     * The associated value is an integer (0 or 1): 1 when low-latency decoding is enabled,\n     * 0 otherwise. The default value is 0.\n     ",
    "links" : [ ]
  }, {
    "name" : "KEY_LANGUAGE",
    "type" : "String",
    "comment" : "\n     * A key describing the language of the content, using either ISO 639-1\n     * or 639-2/T codes.  The associated value is a string.\n     ",
    "links" : [ ]
  }, {
    "name" : "KEY_CAPTION_SERVICE_NUMBER",
    "type" : "String",
    "comment" : "\n     * A key describing the closed caption service number. For CEA-608 caption tracks, holds the\n     * channel number. For CEA-708, holds the service number.\n     * The associated value is an int.\n     ",
    "links" : [ ]
  }, {
    "name" : "KEY_SAMPLE_RATE",
    "type" : "String",
    "comment" : "\n     * A key describing the sample rate of an audio format.\n     * The associated value is an integer\n     ",
    "links" : [ ]
  }, {
    "name" : "KEY_CHANNEL_COUNT",
    "type" : "String",
    "comment" : "\n     * A key describing the number of channels in an audio format.\n     * The associated value is an integer\n     ",
    "links" : [ ]
  }, {
    "name" : "KEY_WIDTH",
    "type" : "String",
    "comment" : "\n     * A key describing the width of the content in a video format.\n     * The associated value is an integer\n     ",
    "links" : [ ]
  }, {
    "name" : "KEY_HEIGHT",
    "type" : "String",
    "comment" : "\n     * A key describing the height of the content in a video format.\n     * The associated value is an integer\n     ",
    "links" : [ ]
  }, {
    "name" : "KEY_CROP_BOTTOM",
    "type" : "String",
    "comment" : "\n     * A key describing the bottom-coordinate (y) of the crop rectangle.\n     * This is the bottom-most row included in the crop frame,\n     * where row indices start at 0.\n     * Additional information on the crop rectangle semantics can be found at\n     * {@link android.media.MediaCodec}.\n     ",
    "links" : [ "android.media.MediaCodec" ]
  }, {
    "name" : "KEY_CROP_LEFT",
    "type" : "String",
    "comment" : "\n     * A key describing the left-coordinate (x) of the crop rectangle.\n     * This is the left-most column included in the crop frame,\n     * where column indices start at 0.\n     * Additional information on the crop rectangle semantics can be found at\n     * {@link android.media.MediaCodec}.\n     ",
    "links" : [ "android.media.MediaCodec" ]
  }, {
    "name" : "KEY_CROP_RIGHT",
    "type" : "String",
    "comment" : "\n     * A key describing the right-coordinate (x) of the crop rectangle.\n     * This is the right-most column included in the crop frame,\n     * where column indices start at 0.\n     * Additional information on the crop rectangle semantics can be found at\n     * {@link android.media.MediaCodec}.\n     ",
    "links" : [ "android.media.MediaCodec" ]
  }, {
    "name" : "KEY_CROP_TOP",
    "type" : "String",
    "comment" : "\n     * A key describing the top-coordinate (y) of the crop rectangle.\n     * This is the top-most row included in the crop frame,\n     * where row indices start at 0.\n     * Additional information on the crop rectangle semantics can be found at\n     * {@link android.media.MediaCodec}.\n     ",
    "links" : [ "android.media.MediaCodec" ]
  }, {
    "name" : "KEY_MAX_WIDTH",
    "type" : "String",
    "comment" : "\n     * A key describing the maximum expected width of the content in a video\n     * decoder format, in case there are resolution changes in the video content.\n     * The associated value is an integer\n     ",
    "links" : [ ]
  }, {
    "name" : "KEY_MAX_HEIGHT",
    "type" : "String",
    "comment" : "\n     * A key describing the maximum expected height of the content in a video\n     * decoder format, in case there are resolution changes in the video content.\n     * The associated value is an integer\n     ",
    "links" : [ ]
  }, {
    "name" : "KEY_MAX_INPUT_SIZE",
    "type" : "String",
    "comment" : " A key describing the maximum size in bytes of a buffer of data\n     * described by this MediaFormat.\n     * The associated value is an integer\n     ",
    "links" : [ ]
  }, {
    "name" : "KEY_BUFFER_BATCH_MAX_OUTPUT_SIZE",
    "type" : "String",
    "comment" : "\n     * A key describing the maximum output buffer size in bytes when using\n     * large buffer mode containing multiple access units.\n     *\n     * When not-set - codec functions with one access-unit per frame.\n     * When set less than the size of two access-units - will make codec\n     * operate in single access-unit per output frame.\n     * When set to a value too big - The component or the framework will\n     * override this value to a reasonable max size not exceeding typical\n     * 10 seconds of data (device dependent) when set to a value larger than\n     * that. The value final value used will be returned in the output format.\n     *\n     * The associated value is an integer\n     *\n     * @see FEATURE_MultipleFrames\n     ",
    "links" : [ ]
  }, {
    "name" : "KEY_BUFFER_BATCH_THRESHOLD_OUTPUT_SIZE",
    "type" : "String",
    "comment" : "\n     * A key describing the threshold output size in bytes when using large buffer\n     * mode containing multiple access units.\n     *\n     * This is an optional parameter.\n     *\n     * If not set - the component can set this to a reasonable value.\n     * If set larger than max size, the components will\n     * clip this setting to maximum buffer batching output size.\n     *\n     * The component will return a partial output buffer if the output buffer reaches or\n     * surpass this limit.\n     *\n     * Threshold size should be always less or equal to KEY_MAX_BUFFER_BATCH_OUTPUT_SIZE.\n     * The final setting of this value as determined by the component will be returned\n     * in the output format\n     *\n     * The associated value is an integer\n     *\n     * @see FEATURE_MultipleFrames\n     ",
    "links" : [ ]
  }, {
    "name" : "KEY_PIXEL_ASPECT_RATIO_WIDTH",
    "type" : "String",
    "comment" : "\n     * A key describing the pixel aspect ratio width.\n     * The associated value is an integer\n     ",
    "links" : [ ]
  }, {
    "name" : "KEY_PIXEL_ASPECT_RATIO_HEIGHT",
    "type" : "String",
    "comment" : "\n     * A key describing the pixel aspect ratio height.\n     * The associated value is an integer\n     ",
    "links" : [ ]
  }, {
    "name" : "KEY_BIT_RATE",
    "type" : "String",
    "comment" : "\n     * A key describing the average bitrate in bits/sec.\n     * The associated value is an integer\n     ",
    "links" : [ ]
  }, {
    "name" : "KEY_HARDWARE_AV_SYNC_ID",
    "type" : "String",
    "comment" : "\n     * A key describing the hardware AV sync id.\n     * The associated value is an integer\n     *\n     * See android.media.tv.tuner.Tuner#getAvSyncHwId.\n     ",
    "links" : [ ]
  }, {
    "name" : "KEY_MAX_BIT_RATE",
    "type" : "String",
    "comment" : "\n     * A key describing the max bitrate in bits/sec.\n     * This is usually over a one-second sliding window (e.g. over any window of one second).\n     * The associated value is an integer\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "KEY_COLOR_FORMAT",
    "type" : "String",
    "comment" : "\n     * A key describing the color format of the content in a video format.\n     * Constants are declared in {@link android.media.MediaCodecInfo.CodecCapabilities}.\n     ",
    "links" : [ "android.media.MediaCodecInfo.CodecCapabilities" ]
  }, {
    "name" : "KEY_FRAME_RATE",
    "type" : "String",
    "comment" : "\n     * A key describing the frame rate of a video format in frames/sec.\n     * <p>\n     * The associated value is normally an integer when the value is used by the platform,\n     * but video codecs also accept float configuration values.\n     * Specifically, {@link MediaExtractor#getTrackFormat MediaExtractor} provides an integer\n     * value corresponding to the frame rate information of the track if specified and non-zero.\n     * Otherwise, this key is not present. {@link MediaCodec#configure MediaCodec} accepts both\n     * float and integer values.\n     * <p>\n     * This represents the desired operating frame rate if the\n     * {@link #KEY_OPERATING_RATE} is not present and {@link #KEY_PRIORITY} is {@code 0}\n     * (realtime). Otherwise, this is just informational.\n     * <p>\n     * For video encoders this value corresponds to the intended frame rate (the rate at which\n     * the application intends to send frames to the encoder, as calculated by the buffer\n     * timestamps, and not from the actual real-time rate that the frames are sent to\n     * the encoder). Encoders use this hint for rate control, specifically for the initial\n     * frames, as encoders are expected to support variable frame rate (for rate control) based\n     * on the actual {@link MediaCodec.BufferInfo#presentationTimeUs buffer timestamps} of\n     * subsequent frames.\n     * <p>\n     * This key is not used in the {@code MediaCodec}\n     * {@link MediaCodec#getInputFormat input}/{@link MediaCodec#getOutputFormat output} formats,\n     * nor by {@link MediaMuxer#addTrack MediaMuxer}.\n     ",
    "links" : [ "android.media.MediaExtractor#getTrackFormat", "#KEY_PRIORITY", "android.media.MediaCodec#getOutputFormat", "MediaCodec.BufferInfo#presentationTimeUs", "android.media.MediaCodec#getInputFormat", "#KEY_OPERATING_RATE", "android.media.MediaCodec#configure", "android.media.MediaMuxer#addTrack" ]
  }, {
    "name" : "KEY_TILE_WIDTH",
    "type" : "String",
    "comment" : "\n     * A key describing the width (in pixels) of each tile of the content in a\n     * {@link #MIMETYPE_IMAGE_ANDROID_HEIC} / {@link #MIMETYPE_IMAGE_AVIF} track.\n     * The associated value is an integer.\n     *\n     * Refer to {@link #MIMETYPE_IMAGE_ANDROID_HEIC} / {@link #MIMETYPE_IMAGE_AVIF} on decoding\n     * instructions of such tracks.\n     *\n     * @see #KEY_TILE_HEIGHT\n     * @see #KEY_GRID_ROWS\n     * @see #KEY_GRID_COLUMNS\n     ",
    "links" : [ "#MIMETYPE_IMAGE_ANDROID_HEIC", "#MIMETYPE_IMAGE_AVIF" ]
  }, {
    "name" : "KEY_TILE_HEIGHT",
    "type" : "String",
    "comment" : "\n     * A key describing the height (in pixels) of each tile of the content in a\n     * {@link #MIMETYPE_IMAGE_ANDROID_HEIC} / {@link #MIMETYPE_IMAGE_AVIF} track.\n     * The associated value is an integer.\n     *\n     * Refer to {@link #MIMETYPE_IMAGE_ANDROID_HEIC} / {@link #MIMETYPE_IMAGE_AVIF} on decoding\n     * instructions of such tracks.\n     *\n     * @see #KEY_TILE_WIDTH\n     * @see #KEY_GRID_ROWS\n     * @see #KEY_GRID_COLUMNS\n     ",
    "links" : [ "#MIMETYPE_IMAGE_ANDROID_HEIC", "#MIMETYPE_IMAGE_AVIF" ]
  }, {
    "name" : "KEY_GRID_ROWS",
    "type" : "String",
    "comment" : "\n     * A key describing the number of grid rows in the content in a\n     * {@link #MIMETYPE_IMAGE_ANDROID_HEIC} / {@link #MIMETYPE_IMAGE_AVIF} track.\n     * The associated value is an integer.\n     *\n     * Refer to {@link #MIMETYPE_IMAGE_ANDROID_HEIC} / {@link #MIMETYPE_IMAGE_AVIF} on decoding\n     * instructions of such tracks.\n     *\n     * @see #KEY_TILE_WIDTH\n     * @see #KEY_TILE_HEIGHT\n     * @see #KEY_GRID_COLUMNS\n     ",
    "links" : [ "#MIMETYPE_IMAGE_ANDROID_HEIC", "#MIMETYPE_IMAGE_AVIF" ]
  }, {
    "name" : "KEY_GRID_COLUMNS",
    "type" : "String",
    "comment" : "\n     * A key describing the number of grid columns in the content in a\n     * {@link #MIMETYPE_IMAGE_ANDROID_HEIC} / {@link #MIMETYPE_IMAGE_AVIF} track.\n     * The associated value is an integer.\n     *\n     * Refer to {@link #MIMETYPE_IMAGE_ANDROID_HEIC} / {@link #MIMETYPE_IMAGE_AVIF} on decoding\n     * instructions of such tracks.\n     *\n     * @see #KEY_TILE_WIDTH\n     * @see #KEY_TILE_HEIGHT\n     * @see #KEY_GRID_ROWS\n     ",
    "links" : [ "#MIMETYPE_IMAGE_ANDROID_HEIC", "#MIMETYPE_IMAGE_AVIF" ]
  }, {
    "name" : "KEY_PCM_ENCODING",
    "type" : "String",
    "comment" : "\n     * A key describing the raw audio sample encoding/format.\n     *\n     * <p>The associated value is an integer, using one of the\n     * {@link AudioFormat}.ENCODING_PCM_ values.</p>\n     *\n     * <p>This is an optional key for audio decoders and encoders specifying the\n     * desired raw audio sample format during {@link MediaCodec#configure\n     * MediaCodec.configure(&hellip;)} call. Use {@link MediaCodec#getInputFormat\n     * MediaCodec.getInput}/{@link MediaCodec#getOutputFormat OutputFormat(&hellip;)}\n     * to confirm the actual format. For the PCM decoder this key specifies both\n     * input and output sample encodings.</p>\n     *\n     * <p>This key is also used by {@link MediaExtractor} to specify the sample\n     * format of audio data, if it is specified.</p>\n     *\n     * <p>If this key is missing, the raw audio sample format is signed 16-bit short.</p>\n     ",
    "links" : [ "android.media.MediaCodec#getOutputFormat", "android.media.MediaCodec#configureMediaCodec.configure(", "android.media.AudioFormat", "android.media.MediaCodec#getInputFormatMediaCodec.getInput", "android.media.MediaExtractor" ]
  }, {
    "name" : "KEY_CAPTURE_RATE",
    "type" : "String",
    "comment" : "\n     * A key describing the capture rate of a video format in frames/sec.\n     * <p>\n     * When capture rate is different than the frame rate, it means that the\n     * video is acquired at a different rate than the playback, which produces\n     * slow motion or timelapse effect during playback. Application can use the\n     * value of this key to tell the relative speed ratio between capture and\n     * playback rates when the video was recorded.\n     * </p>\n     * <p>\n     * The associated value is an integer or a float.\n     * </p>\n     ",
    "links" : [ ]
  }, {
    "name" : "KEY_SLOW_MOTION_MARKERS",
    "type" : "String",
    "comment" : "\n     * A key for retrieving the slow-motion marker information associated with a video track.\n     * <p>\n     * The associated value is a ByteBuffer in {@link ByteOrder#BIG_ENDIAN}\n     * (networking order) of the following format:\n     * </p>\n     * <pre class=\"prettyprint\">\n     *     float(32) playbackRate;\n     *     unsigned int(32) numMarkers;\n     *     for (i = 0;i < numMarkers; i++) {\n     *         int(64) timestampUs;\n     *         float(32) speedRatio;\n     *     }</pre>\n     * The meaning of each field is as follows:\n     * <table border=\"1\" width=\"90%\" align=\"center\" cellpadding=\"5\">\n     *     <tbody>\n     *     <tr>\n     *         <td>playbackRate</td>\n     *         <td>The frame rate at which the playback should happen (or the flattened\n     *             clip should be).</td>\n     *     </tr>\n     *     <tr>\n     *         <td>numMarkers</td>\n     *         <td>The number of slow-motion markers that follows.</td>\n     *     </tr>\n     *     <tr>\n     *         <td>timestampUs</td>\n     *         <td>The starting point of a new segment.</td>\n     *     </tr>\n     *     <tr>\n     *         <td>speedRatio</td>\n     *         <td>The playback speed for that segment. The playback speed is a floating\n     *             point number, indicating how fast the time progresses relative to that\n     *             written in the container. (Eg. 4.0 means time goes 4x as fast, which\n     *             makes 30fps become 120fps.)</td>\n     *     </tr>\n     * </table>\n     * <p>\n     * The following constraints apply to the timestampUs of the markers:\n     * </p>\n     * <li>The timestampUs shall be monotonically increasing.</li>\n     * <li>The timestampUs shall fall within the time span of the video track.</li>\n     * <li>The first timestampUs should match that of the first video sample.</li>\n     ",
    "links" : [ "java.nio.ByteOrder#BIG_ENDIAN" ]
  }, {
    "name" : "KEY_I_FRAME_INTERVAL",
    "type" : "String",
    "comment" : "\n     * A key describing the frequency of key frames expressed in seconds between key frames.\n     * <p>\n     * This key is used by video encoders.\n     * A negative value means no key frames are requested after the first frame.\n     * A zero value means a stream containing all key frames is requested.\n     * <p class=note>\n     * Most video encoders will convert this value of the number of non-key-frames between\n     * key-frames, using the {@linkplain #KEY_FRAME_RATE frame rate} information; therefore,\n     * if the actual frame rate differs (e.g. input frames are dropped or the frame rate\n     * changes), the <strong>time interval</strong> between key frames will not be the\n     * configured value.\n     * <p>\n     * The associated value is an integer (or float since\n     * {@link android.os.Build.VERSION_CODES#N_MR1}).\n     ",
    "links" : [ "android.os.Build.VERSION_CODES#N_MR1" ]
  }, {
    "name" : "KEY_INTRA_REFRESH_PERIOD",
    "type" : "String",
    "comment" : "\n    * An optional key describing the period of intra refresh in frames. This is an\n    * optional parameter that applies only to video encoders. If encoder supports it\n    * ({@link MediaCodecInfo.CodecCapabilities#FEATURE_IntraRefresh}), the whole\n    * frame is completely refreshed after the specified period. Also for each frame,\n    * a fix subset of macroblocks must be intra coded which leads to more constant bitrate\n    * than inserting a key frame. This key is recommended for video streaming applications\n    * as it provides low-delay and good error-resilience. This key is ignored if the\n    * video encoder does not support the intra refresh feature. Use the output format to\n    * verify that this feature was enabled.\n    * The associated value is an integer.\n    ",
    "links" : [ "MediaCodecInfo.CodecCapabilities#FEATURE_IntraRefresh" ]
  }, {
    "name" : "KEY_PREPEND_HEADER_TO_SYNC_FRAMES",
    "type" : "String",
    "comment" : "\n     * An optional key describing whether encoders prepend headers to sync frames (e.g.\n     * SPS and PPS to IDR frames for H.264). This is an optional parameter that applies only\n     * to video encoders. A video encoder may not support this feature; the component will fail\n     * to configure in that case. For other components, this key is ignored.\n     *\n     * The value is an integer, with 1 indicating to prepend headers to every sync frames,\n     * or 0 otherwise. The default value is 0.\n     ",
    "links" : [ ]
  }, {
    "name" : "KEY_TEMPORAL_LAYERING",
    "type" : "String",
    "comment" : "\n     * A key describing the temporal layering schema.  This is an optional parameter\n     * that applies only to video encoders.  Use {@link MediaCodec#getOutputFormat}\n     * after {@link MediaCodec#configure configure} to query if the encoder supports\n     * the desired schema. Supported values are {@code webrtc.vp8.N-layer},\n     * {@code android.generic.N}, {@code android.generic.N+M} and {@code none}, where\n     * {@code N} denotes the total number of non-bidirectional layers (which must be at least 1)\n     * and {@code M} denotes the total number of bidirectional layers (which must be non-negative).\n     * <p class=note>{@code android.generic.*} schemas have been added in {@link\n     * android.os.Build.VERSION_CODES#N_MR1}.\n     * <p>\n     * The encoder may support fewer temporal layers, in which case the output format\n     * will contain the configured schema. If the encoder does not support temporal\n     * layering, the output format will not have an entry with this key.\n     * The associated value is a string.\n     ",
    "links" : [ "android.media.MediaCodec#getOutputFormat", "android.media.MediaCodec#configure", "android.os.Build.VERSION_CODES#N_MR1" ]
  }, {
    "name" : "KEY_STRIDE",
    "type" : "String",
    "comment" : "\n     * A key describing the stride of the video bytebuffer layout.\n     * Stride (or row increment) is the difference between the index of a pixel\n     * and that of the pixel directly underneath. For YUV 420 formats, the\n     * stride corresponds to the Y plane; the stride of the U and V planes can\n     * be calculated based on the color format, though it is generally undefined\n     * and depends on the device and release.\n     * The associated value is an integer, representing number of bytes.\n     ",
    "links" : [ ]
  }, {
    "name" : "KEY_SLICE_HEIGHT",
    "type" : "String",
    "comment" : "\n     * A key describing the plane height of a multi-planar (YUV) video bytebuffer layout.\n     * Slice height (or plane height/vertical stride) is the number of rows that must be skipped\n     * to get from the top of the Y plane to the top of the U plane in the bytebuffer. In essence\n     * the offset of the U plane is sliceHeight * stride. The height of the U/V planes\n     * can be calculated based on the color format, though it is generally undefined\n     * and depends on the device and release.\n     * The associated value is an integer, representing number of rows.\n     ",
    "links" : [ ]
  }, {
    "name" : "KEY_REPEAT_PREVIOUS_FRAME_AFTER",
    "type" : "String",
    "comment" : "\n     * Applies only when configuring a video encoder in \"surface-input\" mode.\n     * The associated value is a long and gives the time in microseconds\n     * after which the frame previously submitted to the encoder will be\n     * repeated (once) if no new frame became available since.\n     ",
    "links" : [ ]
  }, {
    "name" : "KEY_MAX_FPS_TO_ENCODER",
    "type" : "String",
    "comment" : "\n     * Instruct the video encoder in \"surface-input\" mode to drop excessive\n     * frames from the source, so that the input frame rate to the encoder\n     * does not exceed the specified fps.\n     *\n     * The associated value is a float, representing the max frame rate to\n     * feed the encoder at.\n     *\n     ",
    "links" : [ ]
  }, {
    "name" : "KEY_MAX_PTS_GAP_TO_ENCODER",
    "type" : "String",
    "comment" : "\n     * Instruct the video encoder in \"surface-input\" mode to limit the gap of\n     * timestamp between any two adjacent frames fed to the encoder to the\n     * specified amount (in micro-second).\n     *\n     * The associated value is a long int. When positive, it represents the max\n     * timestamp gap between two adjacent frames fed to the encoder. When negative,\n     * the absolute value represents a fixed timestamp gap between any two adjacent\n     * frames fed to the encoder. Note that this will also apply even when the\n     * original timestamp goes backward in time. Under normal conditions, such frames\n     * would be dropped and not sent to the encoder.\n     *\n     * The output timestamp will be restored to the original timestamp and will\n     * not be affected.\n     *\n     * This is used in some special scenarios where input frames arrive sparingly\n     * but it's undesirable to allocate more bits to any single frame, or when it's\n     * important to ensure all frames are captured (rather than captured in the\n     * correct order).\n     *\n     ",
    "links" : [ ]
  }, {
    "name" : "KEY_CREATE_INPUT_SURFACE_SUSPENDED",
    "type" : "String",
    "comment" : "\n     * If specified when configuring a video encoder that's in \"surface-input\"\n     * mode, it will instruct the encoder to put the surface source in suspended\n     * state when it's connected. No video frames will be accepted until a resume\n     * operation (see {@link MediaCodec#PARAMETER_KEY_SUSPEND}), optionally with\n     * timestamp specified via {@link MediaCodec#PARAMETER_KEY_SUSPEND_TIME}, is\n     * received.\n     *\n     * The value is an integer, with 1 indicating to create with the surface\n     * source suspended, or 0 otherwise. The default value is 0.\n     *\n     * If this key is not set or set to 0, the surface source will accept buffers\n     * as soon as it's connected to the encoder (although they may not be encoded\n     * immediately). This key can be used when the client wants to prepare the\n     * encoder session in advance, but do not want to accept buffers immediately.\n     ",
    "links" : [ "android.media.MediaCodec#PARAMETER_KEY_SUSPEND", "android.media.MediaCodec#PARAMETER_KEY_SUSPEND_TIME" ]
  }, {
    "name" : "KEY_PUSH_BLANK_BUFFERS_ON_STOP",
    "type" : "String",
    "comment" : "\n     * If specified when configuring a video decoder rendering to a surface,\n     * causes the decoder to output \"blank\", i.e. black frames to the surface\n     * when stopped to clear out any previously displayed contents.\n     * The associated value is an integer of value 1.\n     ",
    "links" : [ ]
  }, {
    "name" : "KEY_DURATION",
    "type" : "String",
    "comment" : "\n     * A key describing the duration (in microseconds) of the content.\n     * The associated value is a long.\n     ",
    "links" : [ ]
  }, {
    "name" : "KEY_IS_ADTS",
    "type" : "String",
    "comment" : "\n     * A key mapping to a value of 1 if the content is AAC audio and\n     * audio frames are prefixed with an ADTS header.\n     * The associated value is an integer (0 or 1).\n     * This key is only supported when _decoding_ content, it cannot\n     * be used to configure an encoder to emit ADTS output.\n     ",
    "links" : [ ]
  }, {
    "name" : "KEY_CHANNEL_MASK",
    "type" : "String",
    "comment" : "\n     * A key describing the channel composition of audio content. This mask\n     * is composed of bits drawn from channel mask definitions in {@link android.media.AudioFormat}.\n     * The associated value is an integer.\n     ",
    "links" : [ "android.media.AudioFormat" ]
  }, {
    "name" : "KEY_MAX_OUTPUT_CHANNEL_COUNT",
    "type" : "String",
    "comment" : "\n     * A key describing the maximum number of channels that can be output by an audio decoder.\n     * By default, the decoder will output the same number of channels as present in the encoded\n     * stream, if supported. Set this value to limit the number of output channels, and use\n     * the downmix information in the stream, if available.\n     * <p>Values larger than the number of channels in the content to decode behave like the number\n     * of channels in the content (if applicable), for instance passing 99 for a 5.1 audio stream\n     * behaves like passing 6.\n     * <p>This key is only used during decoding.\n     ",
    "links" : [ ]
  }, {
    "name" : "KEY_ENCODER_DELAY",
    "type" : "String",
    "comment" : "\n     * A key describing the number of frames to trim from the start of the decoded audio stream.\n     * The associated value is an integer.\n     ",
    "links" : [ ]
  }, {
    "name" : "KEY_ENCODER_PADDING",
    "type" : "String",
    "comment" : "\n     * A key describing the number of frames to trim from the end of the decoded audio stream.\n     * The associated value is an integer.\n     ",
    "links" : [ ]
  }, {
    "name" : "KEY_AAC_PROFILE",
    "type" : "String",
    "comment" : "\n     * A key describing the AAC profile to be used (AAC audio formats only).\n     * Constants are declared in {@link android.media.MediaCodecInfo.CodecProfileLevel}.\n     ",
    "links" : [ "android.media.MediaCodecInfo.CodecProfileLevel" ]
  }, {
    "name" : "KEY_AAC_SBR_MODE",
    "type" : "String",
    "comment" : "\n     * A key describing the AAC SBR mode to be used (AAC audio formats only).\n     * The associated value is an integer and can be set to following values:\n     * <ul>\n     * <li>0 - no SBR should be applied</li>\n     * <li>1 - single rate SBR</li>\n     * <li>2 - double rate SBR</li>\n     * </ul>\n     * Note: If this key is not defined the default SRB mode for the desired AAC profile will\n     * be used.\n     * <p>This key is only used during encoding.\n     ",
    "links" : [ ]
  }, {
    "name" : "KEY_AAC_MAX_OUTPUT_CHANNEL_COUNT",
    "type" : "String",
    "comment" : "\n     * A key describing the maximum number of channels that can be output by the AAC decoder.\n     * By default, the decoder will output the same number of channels as present in the encoded\n     * stream, if supported. Set this value to limit the number of output channels, and use\n     * the downmix information in the stream, if available.\n     * <p>Values larger than the number of channels in the content to decode behave just\n     * like the actual channel count of the content (e.g. passing 99 for the decoding of 5.1 content\n     * will behave like using 6).\n     * <p>This key is only used during decoding.\n     * @deprecated Use the non-AAC-specific key {@link #KEY_MAX_OUTPUT_CHANNEL_COUNT} instead\n     ",
    "links" : [ "#KEY_MAX_OUTPUT_CHANNEL_COUNT" ]
  }, {
    "name" : "KEY_AAC_DRC_TARGET_REFERENCE_LEVEL",
    "type" : "String",
    "comment" : "\n     * A key describing the Target Reference Level (Target Loudness).\n     * <p>For normalizing loudness across program items, a gain is applied to the audio output so\n     * that the output loudness matches the Target Reference Level. The gain is derived as the\n     * difference between the Target Reference Level and the Program Reference Level (Program\n     * Loudness). The latter can be given in the bitstream and indicates the actual loudness value\n     * of the program item.</p>\n     * <p>The Target Reference Level controls loudness normalization for both MPEG-4 DRC and\n     * MPEG-D DRC.\n     * <p>The value is given as an integer value between\n     * 40 and 127, and is calculated as -4 * Target Reference Level in LKFS.\n     * Therefore, it represents the range of -10 to -31.75 LKFS.\n     * <p>For MPEG-4 DRC, a value of -1 switches off loudness normalization and DRC processing.</p>\n     * <p>For MPEG-D DRC, a value of -1 switches off loudness normalization only. For DRC processing\n     * options of MPEG-D DRC, see {@link #KEY_AAC_DRC_EFFECT_TYPE}</p>\n     * <p>The default value on mobile devices is 64 (-16 LKFS).\n     * <p>This key is only used during decoding.\n     ",
    "links" : [ "#KEY_AAC_DRC_EFFECT_TYPE" ]
  }, {
    "name" : "KEY_AAC_DRC_EFFECT_TYPE",
    "type" : "String",
    "comment" : "\n     * A key describing for selecting the DRC effect type for MPEG-D DRC.\n     * The supported values are defined in ISO/IEC 23003-4:2015 and are described as follows:\n     * <table>\n     * <tr><th>Value</th><th>Effect</th></tr>\n     * <tr><th>-1</th><th>Off</th></tr>\n     * <tr><th>0</th><th>None</th></tr>\n     * <tr><th>1</th><th>Late night</th></tr>\n     * <tr><th>2</th><th>Noisy environment</th></tr>\n     * <tr><th>3</th><th>Limited playback range</th></tr>\n     * <tr><th>4</th><th>Low playback level</th></tr>\n     * <tr><th>5</th><th>Dialog enhancement</th></tr>\n     * <tr><th>6</th><th>General compression</th></tr>\n     * </table>\n     * <p>The value -1 (Off) disables DRC processing, while loudness normalization may still be\n     * active and dependent on {@link #KEY_AAC_DRC_TARGET_REFERENCE_LEVEL}.<br>\n     * The value 0 (None) automatically enables DRC processing if necessary to prevent signal\n     * clipping<br>\n     * The value 6 (General compression) can be used for enabling MPEG-D DRC without particular\n     * DRC effect type request.<br>\n     * The default DRC effect type is 3 (\"Limited playback range\") on mobile devices.\n     * <p>This key is only used during decoding.\n     ",
    "links" : [ "#KEY_AAC_DRC_TARGET_REFERENCE_LEVEL" ]
  }, {
    "name" : "KEY_AAC_ENCODED_TARGET_LEVEL",
    "type" : "String",
    "comment" : "\n     * A key describing the target reference level that was assumed at the encoder for\n     * calculation of attenuation gains for clipping prevention.\n     * <p>If it is known, this information can be provided as an integer value between\n     * 0 and 127, which is calculated as -4 * Encoded Target Level in LKFS.\n     * If the Encoded Target Level is unknown, the value can be set to -1.\n     * <p>The default value is -1 (unknown).\n     * <p>The value is ignored when heavy compression (see {@link #KEY_AAC_DRC_HEAVY_COMPRESSION})\n     * or MPEG-D DRC is used.\n     * <p>This key is only used during decoding.\n     ",
    "links" : [ "#KEY_AAC_DRC_HEAVY_COMPRESSION" ]
  }, {
    "name" : "KEY_AAC_DRC_BOOST_FACTOR",
    "type" : "String",
    "comment" : "\n     * A key describing the boost factor allowing to adapt the dynamics of the output to the\n     * actual listening requirements. This relies on DRC gain sequences that can be transmitted in\n     * the encoded bitstream to be able to reduce the dynamics of the output signal upon request.\n     * This factor enables the user to select how much of the gains are applied.\n     * <p>Positive gains (boost) and negative gains (attenuation, see\n     * {@link #KEY_AAC_DRC_ATTENUATION_FACTOR}) can be controlled separately for a better match\n     * to different use-cases.\n     * <p>Typically, attenuation gains are sent for loud signal segments, and boost gains are sent\n     * for soft signal segments. If the output is listened to in a noisy environment, for example,\n     * the boost factor is used to enable the positive gains, i.e. to amplify soft signal segments\n     * beyond the noise floor. But for listening late at night, the attenuation\n     * factor is used to enable the negative gains, to prevent loud signal from surprising\n     * the listener. In applications which generally need a low dynamic range, both the boost factor\n     * and the attenuation factor are used in order to enable all DRC gains.\n     * <p>In order to prevent clipping, it is also recommended to apply the attenuation gains\n     * in case of a downmix and/or loudness normalization to high target reference levels.\n     * <p>Both the boost and the attenuation factor parameters are given as integer values\n     * between 0 and 127, representing the range of the factor of 0 (i.e. don't apply)\n     * to 1 (i.e. fully apply boost/attenuation gains respectively).\n     * <p>The default value is 127 (fully apply boost DRC gains).\n     * <p>This key is only used during decoding.\n     ",
    "links" : [ "#KEY_AAC_DRC_ATTENUATION_FACTOR" ]
  }, {
    "name" : "KEY_AAC_DRC_ATTENUATION_FACTOR",
    "type" : "String",
    "comment" : "\n     * A key describing the attenuation factor allowing to adapt the dynamics of the output to the\n     * actual listening requirements.\n     * See {@link #KEY_AAC_DRC_BOOST_FACTOR} for a description of the role of this attenuation\n     * factor and the value range.\n     * <p>The default value is 127 (fully apply attenuation DRC gains).\n     * <p>This key is only used during decoding.\n     ",
    "links" : [ "#KEY_AAC_DRC_BOOST_FACTOR" ]
  }, {
    "name" : "KEY_AAC_DRC_HEAVY_COMPRESSION",
    "type" : "String",
    "comment" : "\n     * A key describing the selection of the heavy compression profile for MPEG-4 DRC.\n     * <p>Two separate DRC gain sequences can be transmitted in one bitstream: light compression\n     * and heavy compression. When selecting the application of the heavy compression, one of\n     * the sequences is selected:\n     * <ul>\n     * <li>0 enables light compression,</li>\n     * <li>1 enables heavy compression instead.\n     * </ul>\n     * Note that heavy compression doesn't offer the features of scaling of DRC gains\n     * (see {@link #KEY_AAC_DRC_BOOST_FACTOR} and {@link #KEY_AAC_DRC_ATTENUATION_FACTOR} for the\n     * boost and attenuation factors), and frequency-selective (multiband) DRC.\n     * Light compression usually contains clipping prevention for stereo downmixing while heavy\n     * compression, if additionally provided in the bitstream, is usually stronger, and contains\n     * clipping prevention for stereo and mono downmixing.\n     * <p>The default is 1 (heavy compression).\n     * <p>This key is only used during decoding.\n     ",
    "links" : [ "#KEY_AAC_DRC_BOOST_FACTOR", "#KEY_AAC_DRC_ATTENUATION_FACTOR" ]
  }, {
    "name" : "KEY_AAC_DRC_OUTPUT_LOUDNESS",
    "type" : "String",
    "comment" : "\n     * A key to retrieve the output loudness of a decoded bitstream.\n     * <p>If loudness normalization is active, the value corresponds to the Target Reference Level\n     * (see {@link #KEY_AAC_DRC_TARGET_REFERENCE_LEVEL}).<br>\n     * If loudness normalization is not active, the value corresponds to the loudness metadata\n     * given in the bitstream.\n     * <p>The value is retrieved with getInteger() and is given as an integer value between 0 and\n     * 231. It is calculated as -4 * Output Loudness in LKFS. Therefore, it represents the range of\n     * 0 to -57.75 LKFS.\n     * <p>A value of -1 indicates that no loudness metadata is present in the bitstream.\n     * <p>Loudness metadata can originate from MPEG-4 DRC or MPEG-D DRC.\n     * <p>This key is only used during decoding.\n     ",
    "links" : [ "#KEY_AAC_DRC_TARGET_REFERENCE_LEVEL" ]
  }, {
    "name" : "KEY_AAC_DRC_ALBUM_MODE",
    "type" : "String",
    "comment" : "\n     * A key describing the album mode for MPEG-D DRC as defined in ISO/IEC 23003-4.\n     * <p>The associated value is an integer and can be set to following values:\n     * <table>\n     * <tr><th>Value</th><th>Album Mode</th></tr>\n     * <tr><th>0</th><th>disabled</th></tr>\n     * <tr><th>1</th><th>enabled</th></tr>\n     * </table>\n     * <p>Disabled album mode leads to application of gain sequences for fading in and out, if\n     * provided in the bitstream. Enabled album mode makes use of dedicated album loudness\n     * information, if provided in the bitstream.\n     * <p>The default value is 0 (album mode disabled).\n     * <p>This key is only used during decoding.\n     ",
    "links" : [ ]
  }, {
    "name" : "KEY_FLAC_COMPRESSION_LEVEL",
    "type" : "String",
    "comment" : "\n     * A key describing the FLAC compression level to be used (FLAC audio format only).\n     * The associated value is an integer ranging from 0 (fastest, least compression)\n     * to 8 (slowest, most compression).\n     ",
    "links" : [ ]
  }, {
    "name" : "KEY_MPEGH_PROFILE_LEVEL_INDICATION",
    "type" : "String",
    "comment" : "\n     * A key describing the MPEG-H stream profile-level indication.\n     *\n     * See ISO_IEC_23008-3;2019 MHADecoderConfigurationRecord mpegh3daProfileLevelIndication.\n     ",
    "links" : [ ]
  }, {
    "name" : "KEY_MPEGH_COMPATIBLE_SETS",
    "type" : "String",
    "comment" : "\n     * A key describing the MPEG-H stream compatible sets.\n     *\n     * See FDAmd_2 of ISO_IEC_23008-3;2019 MHAProfileAndLevelCompatibilitySetBox.\n     ",
    "links" : [ ]
  }, {
    "name" : "KEY_MPEGH_REFERENCE_CHANNEL_LAYOUT",
    "type" : "String",
    "comment" : "\n     * A key describing the MPEG-H stream reference channel layout.\n     *\n     * See ISO_IEC_23008-3;2019 MHADecoderConfigurationRecord referenceChannelLayout\n     * and ISO_IEC_230018 ChannelConfiguration value.\n     ",
    "links" : [ ]
  }, {
    "name" : "KEY_COMPLEXITY",
    "type" : "String",
    "comment" : "\n     * A key describing the encoding complexity.\n     * The associated value is an integer.  These values are device and codec specific,\n     * but lower values generally result in faster and/or less power-hungry encoding.\n     *\n     * @see MediaCodecInfo.EncoderCapabilities#getComplexityRange()\n     ",
    "links" : [ ]
  }, {
    "name" : "KEY_QUALITY",
    "type" : "String",
    "comment" : "\n     * A key describing the desired encoding quality.\n     * The associated value is an integer.  This key is only supported for encoders\n     * that are configured in constant-quality mode.  These values are device and\n     * codec specific, but lower values generally result in more efficient\n     * (smaller-sized) encoding.\n     *\n     * @see MediaCodecInfo.EncoderCapabilities#getQualityRange()\n     ",
    "links" : [ ]
  }, {
    "name" : "KEY_PRIORITY",
    "type" : "String",
    "comment" : "\n     * A key describing the desired codec priority.\n     * <p>\n     * The associated value is an integer. Higher value means lower priority.\n     * <p>\n     * Currently, only two levels are supported:<br>\n     * 0: realtime priority - meaning that the codec shall support the given\n     *    performance configuration (e.g. framerate) at realtime. This should\n     *    only be used by media playback, capture, and possibly by realtime\n     *    communication scenarios if best effort performance is not suitable.<br>\n     * 1: non-realtime priority (best effort).\n     * <p>\n     * This is a hint used at codec configuration and resource planning - to understand\n     * the realtime requirements of the application; however, due to the nature of\n     * media components, performance is not guaranteed.\n     *\n     ",
    "links" : [ ]
  }, {
    "name" : "KEY_OPERATING_RATE",
    "type" : "String",
    "comment" : "\n     * A key describing the desired operating frame rate for video or sample rate for audio\n     * that the codec will need to operate at.\n     * <p>\n     * The associated value is an integer or a float representing frames-per-second or\n     * samples-per-second\n     * <p>\n     * This is used for cases like high-speed/slow-motion video capture, where the video encoder\n     * format contains the target playback rate (e.g. 30fps), but the component must be able to\n     * handle the high operating capture rate (e.g. 240fps).\n     * <p>\n     * This rate will be used by codec for resource planning and setting the operating points.\n     *\n     ",
    "links" : [ ]
  }, {
    "name" : "KEY_PROFILE",
    "type" : "String",
    "comment" : "\n     * A key describing the desired profile to be used by an encoder.\n     * <p>\n     * The associated value is an integer.\n     * Constants are declared in {@link MediaCodecInfo.CodecProfileLevel}.\n     * This key is used as a hint, and is only supported for codecs\n     * that specify a profile. When configuring profile, encoder configuration\n     * may fail if other parameters are not compatible with the desired\n     * profile or if the desired profile is not supported, but it may also\n     * fail silently (where the encoder ends up using a different, compatible profile.)\n     * <p>\n     * It is recommended that the profile is set for all encoders. For more information, see\n     * the <i>Encoder Profiles</i> section of the {@link MediaCodec} API reference.\n     * <p class=\"note\">\n     * <strong>Note:</strong> Codecs are free to use all the available\n     * coding tools at the specified profile, but may ultimately choose to not do so.\n     * <p class=\"note\">\n     * <strong>Note:</strong> When configuring video encoders, profile (if set) must be\n     * set together with {@link #KEY_LEVEL level}.\n     *\n     * @see MediaCodecInfo.CodecCapabilities#profileLevels\n     ",
    "links" : [ "MediaCodecInfo.CodecProfileLevel", "android.media.MediaCodec", "#KEY_LEVEL" ]
  }, {
    "name" : "KEY_LEVEL",
    "type" : "String",
    "comment" : "\n     * A key describing the desired profile to be used by an encoder.\n     * <p>\n     * The associated value is an integer.\n     * Constants are declared in {@link MediaCodecInfo.CodecProfileLevel}.\n     * This key is used as a further hint when specifying a desired profile,\n     * and is only supported for codecs that specify a level.\n     * <p>\n     * This key is ignored if the {@link #KEY_PROFILE profile} is not specified.\n     * Otherwise, the value should be a level compatible with the configured encoding\n     * parameters.\n     * <p class=\"note\">\n     * <strong>Note:</strong> This key cannot be used to constrain the encoder's\n     * output to a maximum encoding level. Encoders are free to target a different\n     * level if the configured encoding parameters dictate it. Nevertheless,\n     * encoders shall use (and encode) a level sufficient to decode the generated\n     * bitstream, though they may exceed the (Video) Buffering Verifier limits for\n     * that encoded level.\n     *\n     * @see MediaCodecInfo.CodecCapabilities#profileLevels\n     ",
    "links" : [ "MediaCodecInfo.CodecProfileLevel", "#KEY_PROFILE" ]
  }, {
    "name" : "KEY_LATENCY",
    "type" : "String",
    "comment" : "\n    * An optional key describing the desired encoder latency in frames. This is an optional\n    * parameter that applies only to video encoders. If encoder supports it, it should ouput\n    * at least one output frame after being queued the specified number of frames. This key\n    * is ignored if the video encoder does not support the latency feature. Use the output\n    * format to verify that this feature was enabled and the actual value used by the encoder.\n    * <p>\n    * If the key is not specified, the default latency will be implenmentation specific.\n    * The associated value is an integer.\n    ",
    "links" : [ ]
  }, {
    "name" : "KEY_OUTPUT_REORDER_DEPTH",
    "type" : "String",
    "comment" : "\n     * An optional key describing the maximum number of non-display-order coded frames.\n     * This is an optional parameter that applies only to video encoders. Application should\n     * check the value for this key in the output format to see if codec will produce\n     * non-display-order coded frames. If encoder supports it, the output frames' order will be\n     * different from the display order and each frame's display order could be retrived from\n     * {@link MediaCodec.BufferInfo#presentationTimeUs}. Before API level 27, application may\n     * receive non-display-order coded frames even though the application did not request it.\n     * Note: Application should not rearrange the frames to display order before feeding them\n     * to {@link MediaMuxer#writeSampleData}.\n     * <p>\n     * The default value is 0.\n     ",
    "links" : [ "android.media.MediaMuxer#writeSampleData", "MediaCodec.BufferInfo#presentationTimeUs" ]
  }, {
    "name" : "KEY_ROTATION",
    "type" : "String",
    "comment" : "\n     * A key describing the desired clockwise rotation on an output surface.\n     * This key is only used when the codec is configured using an output surface.\n     * The associated value is an integer, representing degrees. Supported values\n     * are 0, 90, 180 or 270. This is an optional field; if not specified, rotation\n     * defaults to 0.\n     *\n     * @see MediaCodecInfo.CodecCapabilities#profileLevels\n     ",
    "links" : [ ]
  }, {
    "name" : "KEY_BITRATE_MODE",
    "type" : "String",
    "comment" : "\n     * A key describing the desired bitrate mode to be used by an encoder.\n     * Constants are declared in {@link MediaCodecInfo.EncoderCapabilities}.\n     *\n     * @see MediaCodecInfo.EncoderCapabilities#isBitrateModeSupported(int)\n     ",
    "links" : [ "MediaCodecInfo.EncoderCapabilities" ]
  }, {
    "name" : "KEY_VIDEO_QP_MAX",
    "type" : "String",
    "comment" : "\n     * A key describing the maximum Quantization Parameter allowed for encoding video.\n     * This key applies to all three video picture types (I, P, and B).\n     * The value is used directly for picture type I; a per-mime formula is used\n     * to calculate the value for the remaining picture types.\n     *\n     * This calculation can be avoided by directly specifying values for each picture type\n     * using the type-specific keys {@link #KEY_VIDEO_QP_I_MAX}, {@link #KEY_VIDEO_QP_P_MAX},\n     * and {@link #KEY_VIDEO_QP_B_MAX}.\n     *\n     * The associated value is an integer.\n     ",
    "links" : [ "#KEY_VIDEO_QP_I_MAX", "#KEY_VIDEO_QP_P_MAX", "#KEY_VIDEO_QP_B_MAX" ]
  }, {
    "name" : "KEY_VIDEO_QP_MIN",
    "type" : "String",
    "comment" : "\n     * A key describing the minimum Quantization Parameter allowed for encoding video.\n     * This key applies to all three video frame types (I, P, and B).\n     * The value is used directly for picture type I; a per-mime formula is used\n     * to calculate the value for the remaining picture types.\n     *\n     * This calculation can be avoided by directly specifying values for each picture type\n     * using the type-specific keys {@link #KEY_VIDEO_QP_I_MIN}, {@link #KEY_VIDEO_QP_P_MIN},\n     * and {@link #KEY_VIDEO_QP_B_MIN}.\n     *\n     * The associated value is an integer.\n     ",
    "links" : [ "#KEY_VIDEO_QP_I_MIN", "#KEY_VIDEO_QP_P_MIN", "#KEY_VIDEO_QP_B_MIN" ]
  }, {
    "name" : "KEY_VIDEO_QP_I_MAX",
    "type" : "String",
    "comment" : "\n     * A key describing the maximum Quantization Parameter allowed for encoding video.\n     * This value applies to video I-frames.\n     *\n     * The associated value is an integer.\n     ",
    "links" : [ ]
  }, {
    "name" : "KEY_VIDEO_QP_I_MIN",
    "type" : "String",
    "comment" : "\n     * A key describing the minimum Quantization Parameter allowed for encoding video.\n     * This value applies to video I-frames.\n     *\n     * The associated value is an integer.\n     ",
    "links" : [ ]
  }, {
    "name" : "KEY_VIDEO_QP_P_MAX",
    "type" : "String",
    "comment" : "\n     * A key describing the maximum Quantization Parameter allowed for encoding video.\n     * This value applies to video P-frames.\n     *\n     * The associated value is an integer.\n     ",
    "links" : [ ]
  }, {
    "name" : "KEY_VIDEO_QP_P_MIN",
    "type" : "String",
    "comment" : "\n     * A key describing the minimum Quantization Parameter allowed for encoding video.\n     * This value applies to video P-frames.\n     *\n     * The associated value is an integer.\n     ",
    "links" : [ ]
  }, {
    "name" : "KEY_VIDEO_QP_B_MAX",
    "type" : "String",
    "comment" : "\n     * A key describing the maximum Quantization Parameter allowed for encoding video.\n     * This value applies to video B-frames.\n     *\n     * The associated value is an integer.\n     ",
    "links" : [ ]
  }, {
    "name" : "KEY_VIDEO_QP_B_MIN",
    "type" : "String",
    "comment" : "\n     * A key describing the minimum Quantization Parameter allowed for encoding video.\n     * This value applies to video B-frames.\n     *\n     * The associated value is an integer.\n     ",
    "links" : [ ]
  }, {
    "name" : "KEY_VIDEO_ENCODING_STATISTICS_LEVEL",
    "type" : "String",
    "comment" : "\n     * A key describing the level of encoding statistics information emitted from video encoder.\n     *\n     * The associated value is an integer.\n     ",
    "links" : [ ]
  }, {
    "name" : "VIDEO_ENCODING_STATISTICS_LEVEL_NONE",
    "type" : "int",
    "comment" : "\n     * Encoding Statistics Level None.\n     * Encoder generates no information about Encoding statistics.\n     ",
    "links" : [ ]
  }, {
    "name" : "VIDEO_ENCODING_STATISTICS_LEVEL_1",
    "type" : "int",
    "comment" : "\n     * Encoding Statistics Level 1.\n     * Encoder generates {@link MediaFormat#KEY_PICTURE_TYPE} and\n     * {@link MediaFormat#KEY_VIDEO_QP_AVERAGE} for each frame.\n     ",
    "links" : [ "android.media.MediaFormat#KEY_VIDEO_QP_AVERAGE", "android.media.MediaFormat#KEY_PICTURE_TYPE" ]
  }, {
    "name" : "KEY_VIDEO_QP_AVERAGE",
    "type" : "String",
    "comment" : "\n     * A key describing the per-frame average block QP (Quantization Parameter).\n     * This is a part of a video 'Encoding Statistics' export feature.\n     * This value is emitted from video encoder for a video frame.\n     * The average value is rounded to the nearest integer value.\n     *\n     * The associated value is an integer.\n     ",
    "links" : [ ]
  }, {
    "name" : "KEY_PICTURE_TYPE",
    "type" : "String",
    "comment" : "\n     * A key describing the picture type of the encoded frame.\n     * This is a part of a video 'Encoding Statistics' export feature.\n     * This value is emitted from video encoder for a video frame.\n     *\n     * The associated value is an integer.\n     ",
    "links" : [ ]
  }, {
    "name" : "PICTURE_TYPE_UNKNOWN",
    "type" : "int",
    "comment" : " Picture Type is unknown. ",
    "links" : [ ]
  }, {
    "name" : "PICTURE_TYPE_I",
    "type" : "int",
    "comment" : " Picture Type is I Frame. ",
    "links" : [ ]
  }, {
    "name" : "PICTURE_TYPE_P",
    "type" : "int",
    "comment" : " Picture Type is P Frame. ",
    "links" : [ ]
  }, {
    "name" : "PICTURE_TYPE_B",
    "type" : "int",
    "comment" : " Picture Type is B Frame. ",
    "links" : [ ]
  }, {
    "name" : "KEY_AUDIO_SESSION_ID",
    "type" : "String",
    "comment" : "\n     * A key describing the audio session ID of the AudioTrack associated\n     * to a tunneled video codec.\n     * The associated value is an integer.\n     *\n     * @see MediaCodecInfo.CodecCapabilities#FEATURE_TunneledPlayback\n     ",
    "links" : [ ]
  }, {
    "name" : "KEY_AUDIO_HW_SYNC",
    "type" : "String",
    "comment" : "\n     * A key describing the audio hardware sync ID of the AudioTrack associated\n     * to a tunneled video codec. The associated value is an integer.\n     *\n     * @hide\n     *\n     * @see MediaCodecInfo.CodecCapabilities#FEATURE_TunneledPlayback\n     * @see AudioManager#getAudioHwSyncForSession\n     ",
    "links" : [ ]
  }, {
    "name" : "KEY_IS_AUTOSELECT",
    "type" : "String",
    "comment" : "\n     * A key for boolean AUTOSELECT behavior for the track. Tracks with AUTOSELECT=true\n     * are considered when automatically selecting a track without specific user\n     * choice, based on the current locale.\n     * This is currently only used for subtitle tracks, when the user selected\n     * 'Default' for the captioning locale.\n     * The associated value is an integer, where non-0 means TRUE.  This is an optional\n     * field; if not specified, AUTOSELECT defaults to TRUE.\n     ",
    "links" : [ ]
  }, {
    "name" : "KEY_IS_DEFAULT",
    "type" : "String",
    "comment" : "\n     * A key for boolean DEFAULT behavior for the track. The track with DEFAULT=true is\n     * selected in the absence of a specific user choice.\n     * This is currently used in two scenarios:\n     * 1) for subtitle tracks, when the user selected 'Default' for the captioning locale.\n     * 2) for a {@link #MIMETYPE_IMAGE_ANDROID_HEIC} / {@link #MIMETYPE_IMAGE_AVIF} track,\n     * indicating the image is the primary item in the file.\n     *\n     * The associated value is an integer, where non-0 means TRUE.  This is an optional\n     * field; if not specified, DEFAULT is considered to be FALSE.\n     ",
    "links" : [ "#MIMETYPE_IMAGE_ANDROID_HEIC", "#MIMETYPE_IMAGE_AVIF" ]
  }, {
    "name" : "KEY_IS_FORCED_SUBTITLE",
    "type" : "String",
    "comment" : "\n     * A key for the FORCED field for subtitle tracks. True if it is a\n     * forced subtitle track.  Forced subtitle tracks are essential for the\n     * content and are shown even when the user turns off Captions.  They\n     * are used for example to translate foreign/alien dialogs or signs.\n     * The associated value is an integer, where non-0 means TRUE.  This is an\n     * optional field; if not specified, FORCED defaults to FALSE.\n     ",
    "links" : [ ]
  }, {
    "name" : "KEY_HAPTIC_CHANNEL_COUNT",
    "type" : "String",
    "comment" : "\n     * A key describing the number of haptic channels in an audio format.\n     * The associated value is an integer.\n     ",
    "links" : [ ]
  }, {
    "name" : "KEY_IS_TIMED_TEXT",
    "type" : "String",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "KEY_COLOR_STANDARD",
    "type" : "String",
    "comment" : "\n     * An optional key describing the color primaries, white point and\n     * luminance factors for video content.\n     *\n     * The associated value is an integer: 0 if unspecified, or one of the\n     * COLOR_STANDARD_ values.\n     ",
    "links" : [ ]
  }, {
    "name" : "COLOR_STANDARD_BT709",
    "type" : "int",
    "comment" : " BT.709 color chromacity coordinates with KR = 0.2126, KB = 0.0722. ",
    "links" : [ ]
  }, {
    "name" : "COLOR_STANDARD_BT601_PAL",
    "type" : "int",
    "comment" : " BT.601 625 color chromacity coordinates with KR = 0.299, KB = 0.114. ",
    "links" : [ ]
  }, {
    "name" : "COLOR_STANDARD_BT601_NTSC",
    "type" : "int",
    "comment" : " BT.601 525 color chromacity coordinates with KR = 0.299, KB = 0.114. ",
    "links" : [ ]
  }, {
    "name" : "COLOR_STANDARD_BT2020",
    "type" : "int",
    "comment" : " BT.2020 color chromacity coordinates with KR = 0.2627, KB = 0.0593. ",
    "links" : [ ]
  }, {
    "name" : "KEY_COLOR_TRANSFER",
    "type" : "String",
    "comment" : "\n     * An optional key describing the opto-electronic transfer function used\n     * for the video content.\n     *\n     * The associated value is an integer: 0 if unspecified, or one of the\n     * COLOR_TRANSFER_ values.\n     ",
    "links" : [ ]
  }, {
    "name" : "COLOR_TRANSFER_LINEAR",
    "type" : "int",
    "comment" : " Linear transfer characteristic curve. ",
    "links" : [ ]
  }, {
    "name" : "COLOR_TRANSFER_SDR_VIDEO",
    "type" : "int",
    "comment" : " SMPTE 170M transfer characteristic curve used by BT.601/BT.709/BT.2020. This is the curve\n     *  used by most non-HDR video content. ",
    "links" : [ ]
  }, {
    "name" : "COLOR_TRANSFER_ST2084",
    "type" : "int",
    "comment" : " SMPTE ST 2084 transfer function. This is used by some HDR video content. ",
    "links" : [ ]
  }, {
    "name" : "COLOR_TRANSFER_HLG",
    "type" : "int",
    "comment" : " ARIB STD-B67 hybrid-log-gamma transfer function. This is used by some HDR video content. ",
    "links" : [ ]
  }, {
    "name" : "KEY_COLOR_RANGE",
    "type" : "String",
    "comment" : "\n     * An optional key describing the range of the component values of the video content.\n     *\n     * The associated value is an integer: 0 if unspecified, or one of the\n     * COLOR_RANGE_ values.\n     ",
    "links" : [ ]
  }, {
    "name" : "COLOR_RANGE_LIMITED",
    "type" : "int",
    "comment" : " Limited range. Y component values range from 16 to 235 for 8-bit content.\n     *  Cr, Cy values range from 16 to 240 for 8-bit content.\n     *  This is the default for video content. ",
    "links" : [ ]
  }, {
    "name" : "COLOR_RANGE_FULL",
    "type" : "int",
    "comment" : " Full range. Y, Cr and Cb component values range from 0 to 255 for 8-bit content. ",
    "links" : [ ]
  }, {
    "name" : "KEY_HDR_STATIC_INFO",
    "type" : "String",
    "comment" : "\n     * An optional key describing the static metadata of HDR (high-dynamic-range) video content.\n     *\n     * The associated value is a ByteBuffer. This buffer contains the raw contents of the\n     * Static Metadata Descriptor (including the descriptor ID) of an HDMI Dynamic Range and\n     * Mastering InfoFrame as defined by CTA-861.3. This key must be provided to video decoders\n     * for HDR video content unless this information is contained in the bitstream and the video\n     * decoder supports an HDR-capable profile. This key must be provided to video encoders for\n     * HDR video content.\n     ",
    "links" : [ ]
  }, {
    "name" : "KEY_HDR10_PLUS_INFO",
    "type" : "String",
    "comment" : "\n     * An optional key describing the HDR10+ metadata of the video content.\n     *\n     * The associated value is a ByteBuffer containing HDR10+ metadata conforming to the\n     * user_data_registered_itu_t_t35() syntax of SEI message for ST 2094-40. This key will\n     * be present on:\n     *<p>\n     * - The formats of output buffers of a decoder configured for HDR10+ profiles (such as\n     *   {@link MediaCodecInfo.CodecProfileLevel#VP9Profile2HDR10Plus}, {@link\n     *   MediaCodecInfo.CodecProfileLevel#VP9Profile3HDR10Plus} or {@link\n     *   MediaCodecInfo.CodecProfileLevel#HEVCProfileMain10HDR10Plus}), or\n     *<p>\n     * - The formats of output buffers of an encoder configured for an HDR10+ profiles that\n     *   uses out-of-band metadata (such as {@link\n     *   MediaCodecInfo.CodecProfileLevel#VP9Profile2HDR10Plus} or {@link\n     *   MediaCodecInfo.CodecProfileLevel#VP9Profile3HDR10Plus}).\n     *\n     * @see MediaCodec#PARAMETER_KEY_HDR10_PLUS_INFO\n     ",
    "links" : [ "MediaCodecInfo.CodecProfileLevel#VP9Profile2HDR10Plus", "MediaCodecInfo.CodecProfileLevel#HEVCProfileMain10HDR10Plus", "MediaCodecInfo.CodecProfileLevel#VP9Profile3HDR10Plus" ]
  }, {
    "name" : "KEY_COLOR_TRANSFER_REQUEST",
    "type" : "String",
    "comment" : "\n     * An optional key describing the opto-electronic transfer function\n     * requested for the output video content.\n     *\n     * The associated value is an integer: 0 if unspecified, or one of the\n     * COLOR_TRANSFER_ values. When unspecified the component will not touch the\n     * video content; otherwise the component will tone-map the raw video frame\n     * to match the requested transfer function.\n     *\n     * After configure, component's input format will contain this key to note\n     * whether the request is supported or not. If the value in the input format\n     * is the same as the requested value, the request is supported. The value\n     * is set to 0 if unsupported.\n     ",
    "links" : [ ]
  }, {
    "name" : "KEY_TRACK_ID",
    "type" : "String",
    "comment" : "\n     * A key describing a unique ID for the content of a media track.\n     *\n     * <p>This key is used by {@link MediaExtractor}. Some extractors provide multiple encodings\n     * of the same track (e.g. float audio tracks for FLAC and WAV may be expressed as two\n     * tracks via MediaExtractor: a normal PCM track for backward compatibility, and a float PCM\n     * track for added fidelity. Similarly, Dolby Vision extractor may provide a baseline SDR\n     * version of a DV track.) This key can be used to identify which MediaExtractor tracks refer\n     * to the same underlying content.\n     * </p>\n     *\n     * The associated value is an integer.\n     ",
    "links" : [ "android.media.MediaExtractor" ]
  }, {
    "name" : "KEY_CA_SYSTEM_ID",
    "type" : "String",
    "comment" : "\n     * A key describing the system id of the conditional access system used to scramble\n     * a media track.\n     * <p>\n     * This key is set by {@link MediaExtractor} if the track is scrambled with a conditional\n     * access system, regardless of the presence of a valid {@link MediaCas} object.\n     * <p>\n     * The associated value is an integer.\n     * @hide\n     ",
    "links" : [ "android.media.MediaCas", "android.media.MediaExtractor" ]
  }, {
    "name" : "KEY_CA_SESSION_ID",
    "type" : "String",
    "comment" : "\n     * A key describing the {@link MediaCas.Session} object associated with a media track.\n     * <p>\n     * This key is set by {@link MediaExtractor} if the track is scrambled with a conditional\n     * access system, after it receives a valid {@link MediaCas} object.\n     * <p>\n     * The associated value is a ByteBuffer.\n     * @hide\n     ",
    "links" : [ "MediaCas.Session", "android.media.MediaCas", "android.media.MediaExtractor" ]
  }, {
    "name" : "KEY_CA_PRIVATE_DATA",
    "type" : "String",
    "comment" : "\n     * A key describing the private data in the CA_descriptor associated with a media track.\n     * <p>\n     * This key is set by {@link MediaExtractor} if the track is scrambled with a conditional\n     * access system, before it receives a valid {@link MediaCas} object.\n     * <p>\n     * The associated value is a ByteBuffer.\n     * @hide\n     ",
    "links" : [ "android.media.MediaCas", "android.media.MediaExtractor" ]
  }, {
    "name" : "KEY_MAX_B_FRAMES",
    "type" : "String",
    "comment" : "\n     * A key describing the maximum number of B frames between I or P frames,\n     * to be used by a video encoder.\n     * The associated value is an integer. The default value is 0, which means\n     * that no B frames are allowed. Note that non-zero value does not guarantee\n     * B frames; it's up to the encoder to decide.\n     ",
    "links" : [ ]
  }, {
    "name" : "KEY_ALLOW_FRAME_DROP",
    "type" : "String",
    "comment" : "\n     * A key for applications to opt out of allowing\n     * a Surface to discard undisplayed/unconsumed frames\n     * as means to catch up after falling behind.\n     * This value is an integer.\n     * The value 0 indicates the surface is not allowed to drop frames.\n     * The value 1 indicates the surface is allowed to drop frames.\n     *\n     * {@link MediaCodec} describes the semantics.\n     ",
    "links" : [ "android.media.MediaCodec" ]
  }, {
    "name" : "KEY_IMPORTANCE",
    "type" : "String",
    "comment" : "\n     * A key describing the desired codec importance for the application.\n     * <p>\n     * The associated value is a positive integer including zero.\n     * Higher value means lesser importance.\n     * <p>\n     * The resource manager may use the codec importance, along with other factors\n     * when reclaiming codecs from an application.\n     * The specifics of reclaim policy is device dependent, but specifying the codec importance,\n     * will allow the resource manager to prioritize reclaiming less important codecs\n     * (assigned higher values) from the (reclaim) requesting application first.\n     * So, the codec importance is only relevant within the context of that application.\n     * <p>\n     * The codec importance can be set:\n     * <ul>\n     * <li>through {@link MediaCodec#configure}. </li>\n     * <li>through {@link MediaCodec#setParameters} if the codec has been configured already,\n     * which allows the users to change the codec importance multiple times.\n     * </ul>\n     * Any change/update in codec importance is guaranteed upon the completion of the function call\n     * that sets the codec importance. So, in case of concurrent codec operations,\n     * make sure to wait for the change in codec importance, before using another codec.\n     * Note that unless specified, by default the codecs will have highest importance (of value 0).\n     *\n     ",
    "links" : [ "android.media.MediaCodec#setParameters", "android.media.MediaCodec#configure" ]
  }, {
    "name" : "FLAG_SECURITY_MODEL_SANDBOXED",
    "type" : "int",
    "comment" : "\n     * Flag for {@link MediaCodecInfo#SECURITY_MODEL_SANDBOXED}.\n     ",
    "links" : [ "android.media.MediaCodecInfo#SECURITY_MODEL_SANDBOXED" ]
  }, {
    "name" : "FLAG_SECURITY_MODEL_MEMORY_SAFE",
    "type" : "int",
    "comment" : "\n     * Flag for {@link MediaCodecInfo#SECURITY_MODEL_MEMORY_SAFE}.\n     ",
    "links" : [ "android.media.MediaCodecInfo#SECURITY_MODEL_MEMORY_SAFE" ]
  }, {
    "name" : "FLAG_SECURITY_MODEL_TRUSTED_CONTENT_ONLY",
    "type" : "int",
    "comment" : "\n     * Flag for {@link MediaCodecInfo#SECURITY_MODEL_TRUSTED_CONTENT_ONLY}.\n     ",
    "links" : [ "android.media.MediaCodecInfo#SECURITY_MODEL_TRUSTED_CONTENT_ONLY" ]
  }, {
    "name" : "KEY_SECURITY_MODEL",
    "type" : "String",
    "comment" : "\n     * A key describing the requested security model as flags.\n     * <p>\n     * The associated value is a flag of the following values:\n     * {@link FLAG_SECURITY_MODEL_SANDBOXED},\n     * {@link FLAG_SECURITY_MODEL_MEMORY_SAFE},\n     * {@link FLAG_SECURITY_MODEL_TRUSTED_CONTENT_ONLY}. The default value is\n     * {@link FLAG_SECURITY_MODEL_SANDBOXED}.\n     * <p>\n     * When passed to {@link MediaCodecList#findDecoderForFormat} or\n     * {@link MediaCodecList#findEncoderForFormat}, MediaCodecList filters\n     * the security model of the codecs according to this flag value.\n     * <p>\n     * When passed to {@link MediaCodec#configure}, MediaCodec verifies\n     * the security model matches the flag value passed, and throws\n     * {@link java.lang.IllegalArgumentException} if the model does not match.\n     * <p>\n     * @see MediaCodecInfo#getSecurityModel\n     * @see MediaCodecList#findDecoderForFormat\n     * @see MediaCodecList#findEncoderForFormat\n     ",
    "links" : [ "FLAG_SECURITY_MODEL_TRUSTED_CONTENT_ONLY", "FLAG_SECURITY_MODEL_MEMORY_SAFE", "android.media.MediaCodec#configure", "android.media.MediaCodecList#findEncoderForFormat", "android.media.MediaCodecList#findDecoderForFormat", "java.lang.IllegalArgumentException", "FLAG_SECURITY_MODEL_SANDBOXED" ]
  }, {
    "name" : "TYPE_NULL",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "TYPE_INTEGER",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "TYPE_LONG",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "TYPE_FLOAT",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "TYPE_STRING",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "TYPE_BYTE_BUFFER",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "KEY_FEATURE_",
    "type" : "String",
    "comment" : "\n     * A key prefix used together with a {@link MediaCodecInfo.CodecCapabilities}\n     * feature name describing a required or optional feature for a codec capabilities\n     * query.\n     * The associated value is an integer, where non-0 value means the feature is\n     * requested to be present, while 0 value means the feature is requested to be not\n     * present.\n     * @see MediaCodecList#findDecoderForFormat\n     * @see MediaCodecList#findEncoderForFormat\n     * @see MediaCodecInfo.CodecCapabilities#isFormatSupported\n     *\n     * @hide\n     ",
    "links" : [ "MediaCodecInfo.CodecCapabilities" ]
  } ],
  "methods" : [ {
    "name" : " Map<String, Object> getMap()",
    "returnType" : "Map<String, Object>",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public final boolean containsKey(@NonNull String name)",
    "returnType" : "boolean",
    "comment" : "\n     * Returns true iff a key of the given name exists in the format.\n     ",
    "links" : [ ]
  }, {
    "name" : "public final boolean containsFeature(@NonNull String name)",
    "returnType" : "boolean",
    "comment" : "\n     * Returns true iff a feature of the given name exists in the format.\n     ",
    "links" : [ ]
  }, {
    "name" : "public final int getValueTypeForKey(@NonNull String name)",
    "returnType" : "int",
    "comment" : "\n     * Returns the value type for a key. If the key does not exist, it returns TYPE_NULL.\n     ",
    "links" : [ ]
  }, {
    "name" : "public final Number getNumber(@NonNull String name)",
    "returnType" : "Number",
    "comment" : "\n     * Returns the value of a numeric key. This is provided as a convenience method for keys\n     * that may take multiple numeric types, such as {@link #KEY_FRAME_RATE}, or {@link\n     * #KEY_I_FRAME_INTERVAL}.\n     *\n     * @return null if the key does not exist or the stored value for the key is null\n     * @throws ClassCastException if the stored value for the key is ByteBuffer or String\n     ",
    "links" : [ "#KEY_FRAME_RATE", "#KEY_I_FRAME_INTERVAL" ]
  }, {
    "name" : "public final Number getNumber(@NonNull String name, @NonNull Number defaultValue)",
    "returnType" : "Number",
    "comment" : "\n     * Returns the value of a numeric key, or the default value if the key is missing.\n     *\n     * @return defaultValue if the key does not exist or the stored value for the key is null\n     * @throws ClassCastException if the stored value for the key is ByteBuffer or String\n     ",
    "links" : [ ]
  }, {
    "name" : "public final int getInteger(@NonNull String name)",
    "returnType" : "int",
    "comment" : "\n     * Returns the value of an integer key.\n     *\n     * @throws NullPointerException if the key does not exist or the stored value for the key is\n     *         null\n     * @throws ClassCastException if the stored value for the key is long, float, ByteBuffer or\n     *         String\n     ",
    "links" : [ ]
  }, {
    "name" : "public final int getInteger(@NonNull String name, int defaultValue)",
    "returnType" : "int",
    "comment" : "\n     * Returns the value of an integer key, or the default value if the key is missing.\n     *\n     * @return defaultValue if the key does not exist or the stored value for the key is null\n     * @throws ClassCastException if the stored value for the key is long, float, ByteBuffer or\n     *         String\n     ",
    "links" : [ ]
  }, {
    "name" : "public final long getLong(@NonNull String name)",
    "returnType" : "long",
    "comment" : "\n     * Returns the value of a long key.\n     *\n     * @throws NullPointerException if the key does not exist or the stored value for the key is\n     *         null\n     * @throws ClassCastException if the stored value for the key is int, float, ByteBuffer or\n     *         String\n     ",
    "links" : [ ]
  }, {
    "name" : "public final long getLong(@NonNull String name, long defaultValue)",
    "returnType" : "long",
    "comment" : "\n     * Returns the value of a long key, or the default value if the key is missing.\n     *\n     * @return defaultValue if the key does not exist or the stored value for the key is null\n     * @throws ClassCastException if the stored value for the key is int, float, ByteBuffer or\n     *         String\n     ",
    "links" : [ ]
  }, {
    "name" : "public final float getFloat(@NonNull String name)",
    "returnType" : "float",
    "comment" : "\n     * Returns the value of a float key.\n     *\n     * @throws NullPointerException if the key does not exist or the stored value for the key is\n     *         null\n     * @throws ClassCastException if the stored value for the key is int, long, ByteBuffer or\n     *         String\n     ",
    "links" : [ ]
  }, {
    "name" : "public final float getFloat(@NonNull String name, float defaultValue)",
    "returnType" : "float",
    "comment" : "\n     * Returns the value of a float key, or the default value if the key is missing.\n     *\n     * @return defaultValue if the key does not exist or the stored value for the key is null\n     * @throws ClassCastException if the stored value for the key is int, long, ByteBuffer or\n     *         String\n     ",
    "links" : [ ]
  }, {
    "name" : "public final String getString(@NonNull String name)",
    "returnType" : "String",
    "comment" : "\n     * Returns the value of a string key.\n     *\n     * @return null if the key does not exist or the stored value for the key is null\n     * @throws ClassCastException if the stored value for the key is int, long, float or ByteBuffer\n     ",
    "links" : [ ]
  }, {
    "name" : "public final String getString(@NonNull String name, @NonNull String defaultValue)",
    "returnType" : "String",
    "comment" : "\n     * Returns the value of a string key, or the default value if the key is missing.\n     *\n     * @return defaultValue if the key does not exist or the stored value for the key is null\n     * @throws ClassCastException if the stored value for the key is int, long, float or ByteBuffer\n     ",
    "links" : [ ]
  }, {
    "name" : "public final ByteBuffer getByteBuffer(@NonNull String name)",
    "returnType" : "ByteBuffer",
    "comment" : "\n     * Returns the value of a ByteBuffer key.\n     *\n     * @return null if the key does not exist or the stored value for the key is null\n     * @throws ClassCastException if the stored value for the key is int, long, float or String\n     ",
    "links" : [ ]
  }, {
    "name" : "public final ByteBuffer getByteBuffer(@NonNull String name, @NonNull ByteBuffer defaultValue)",
    "returnType" : "ByteBuffer",
    "comment" : "\n     * Returns the value of a ByteBuffer key, or the default value if the key is missing.\n     *\n     * @return defaultValue if the key does not exist or the stored value for the key is null\n     * @throws ClassCastException if the stored value for the key is int, long, float or String\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean getFeatureEnabled(@NonNull String feature)",
    "returnType" : "boolean",
    "comment" : "\n     * Returns whether a feature is to be enabled ({@code true}) or disabled\n     * ({@code false}).\n     *\n     * @param feature the name of a {@link MediaCodecInfo.CodecCapabilities} feature.\n     *\n     * @throws IllegalArgumentException if the feature was neither set to be enabled\n     *         nor to be disabled.\n     ",
    "links" : [ "MediaCodecInfo.CodecCapabilities" ]
  }, {
    "name" : "public final void setInteger(@NonNull String name, int value)",
    "returnType" : "void",
    "comment" : "\n     * Sets the value of an integer key.\n     ",
    "links" : [ ]
  }, {
    "name" : "public final void setLong(@NonNull String name, long value)",
    "returnType" : "void",
    "comment" : "\n     * Sets the value of a long key.\n     ",
    "links" : [ ]
  }, {
    "name" : "public final void setFloat(@NonNull String name, float value)",
    "returnType" : "void",
    "comment" : "\n     * Sets the value of a float key.\n     ",
    "links" : [ ]
  }, {
    "name" : "public final void setString(@NonNull String name, @Nullable String value)",
    "returnType" : "void",
    "comment" : "\n     * Sets the value of a string key.\n     * <p>\n     * If value is {@code null}, it sets a null value that behaves similarly to a missing key.\n     * This could be used prior to API level {@link android os.Build.VERSION_CODES#Q} to effectively\n     * remove a key.\n     ",
    "links" : [ "android" ]
  }, {
    "name" : "public final void setByteBuffer(@NonNull String name, @Nullable ByteBuffer bytes)",
    "returnType" : "void",
    "comment" : "\n     * Sets the value of a ByteBuffer key.\n     * <p>\n     * If value is {@code null}, it sets a null value that behaves similarly to a missing key.\n     * This could be used prior to API level {@link android os.Build.VERSION_CODES#Q} to effectively\n     * remove a key.\n     ",
    "links" : [ "android" ]
  }, {
    "name" : "public final void removeKey(@NonNull String name)",
    "returnType" : "void",
    "comment" : "\n     * Removes a value of a given key if present. Has no effect if the key is not present.\n     ",
    "links" : [ ]
  }, {
    "name" : "public final void removeFeature(@NonNull String name)",
    "returnType" : "void",
    "comment" : "\n     * Removes a given feature setting if present. Has no effect if the feature setting is not\n     * present.\n     ",
    "links" : [ ]
  }, {
    "name" : "public final java.util.Set<String> getKeys()",
    "returnType" : "java.util.Set<String>",
    "comment" : "\n     * Returns a {@link java.util.Set Set} view of the keys contained in this MediaFormat.\n     *\n     * The set is backed by the MediaFormat object, so changes to the format are reflected in the\n     * set, and vice-versa. If the format is modified while an iteration over the set is in progress\n     * (except through the iterator's own remove operation), the results of the iteration are\n     * undefined. The set supports element removal, which removes the corresponding mapping from the\n     * format, via the Iterator.remove, Set.remove, removeAll, retainAll, and clear operations.\n     * It does not support the add or addAll operations.\n     ",
    "links" : [ "java.util.Set" ]
  }, {
    "name" : "public final java.util.Set<String> getFeatures()",
    "returnType" : "java.util.Set<String>",
    "comment" : "\n     * Returns a {@link java.util.Set Set} view of the features contained in this MediaFormat.\n     *\n     * The set is backed by the MediaFormat object, so changes to the format are reflected in the\n     * set, and vice-versa. If the format is modified while an iteration over the set is in progress\n     * (except through the iterator's own remove operation), the results of the iteration are\n     * undefined. The set supports element removal, which removes the corresponding mapping from the\n     * format, via the Iterator.remove, Set.remove, removeAll, retainAll, and clear operations.\n     * It does not support the add or addAll operations.\n     ",
    "links" : [ "java.util.Set" ]
  }, {
    "name" : "public void setFeatureEnabled(@NonNull String feature, boolean enabled)",
    "returnType" : "void",
    "comment" : "\n     * Sets whether a feature is to be enabled ({@code true}) or disabled\n     * ({@code false}).\n     *\n     * If {@code enabled} is {@code true}, the feature is requested to be present.\n     * Otherwise, the feature is requested to be not present.\n     *\n     * @param feature the name of a {@link MediaCodecInfo.CodecCapabilities} feature.\n     *\n     * @see MediaCodecList#findDecoderForFormat\n     * @see MediaCodecList#findEncoderForFormat\n     * @see MediaCodecInfo.CodecCapabilities#isFormatSupported\n     ",
    "links" : [ "MediaCodecInfo.CodecCapabilities" ]
  }, {
    "name" : "public static final MediaFormat createAudioFormat(@NonNull String mime, int sampleRate, int channelCount)",
    "returnType" : "MediaFormat",
    "comment" : "\n     * Creates a minimal audio format.\n     * @param mime The mime type of the content.\n     * @param sampleRate The sampling rate of the content.\n     * @param channelCount The number of audio channels in the content.\n     ",
    "links" : [ ]
  }, {
    "name" : "public static final MediaFormat createSubtitleFormat(@NonNull String mime, String language)",
    "returnType" : "MediaFormat",
    "comment" : "\n     * Creates a minimal subtitle format.\n     * @param mime The mime type of the content.\n     * @param language The language of the content, using either ISO 639-1 or 639-2/T\n     *        codes.  Specify null or \"und\" if language information is only included\n     *        in the content.  (This will also work if there are multiple language\n     *        tracks in the content.)\n     ",
    "links" : [ ]
  }, {
    "name" : "public static final MediaFormat createVideoFormat(@NonNull String mime, int width, int height)",
    "returnType" : "MediaFormat",
    "comment" : "\n     * Creates a minimal video format.\n     * @param mime The mime type of the content.\n     * @param width The width of the content (in pixels)\n     * @param height The height of the content (in pixels)\n     ",
    "links" : [ ]
  }, {
    "name" : "public String toString()",
    "returnType" : "String",
    "comment" : "",
    "links" : [ ]
  } ],
  "methodNames" : [ " Map<String, Object> getMap()", "public final boolean containsKey(@NonNull String name)", "public final boolean containsFeature(@NonNull String name)", "public final int getValueTypeForKey(@NonNull String name)", "public final Number getNumber(@NonNull String name)", "public final Number getNumber(@NonNull String name, @NonNull Number defaultValue)", "public final int getInteger(@NonNull String name)", "public final int getInteger(@NonNull String name, int defaultValue)", "public final long getLong(@NonNull String name)", "public final long getLong(@NonNull String name, long defaultValue)", "public final float getFloat(@NonNull String name)", "public final float getFloat(@NonNull String name, float defaultValue)", "public final String getString(@NonNull String name)", "public final String getString(@NonNull String name, @NonNull String defaultValue)", "public final ByteBuffer getByteBuffer(@NonNull String name)", "public final ByteBuffer getByteBuffer(@NonNull String name, @NonNull ByteBuffer defaultValue)", "public boolean getFeatureEnabled(@NonNull String feature)", "public final void setInteger(@NonNull String name, int value)", "public final void setLong(@NonNull String name, long value)", "public final void setFloat(@NonNull String name, float value)", "public final void setString(@NonNull String name, @Nullable String value)", "public final void setByteBuffer(@NonNull String name, @Nullable ByteBuffer bytes)", "public final void removeKey(@NonNull String name)", "public final void removeFeature(@NonNull String name)", "public final java.util.Set<String> getKeys()", "public final java.util.Set<String> getFeatures()", "public void setFeatureEnabled(@NonNull String feature, boolean enabled)", "public static final MediaFormat createAudioFormat(@NonNull String mime, int sampleRate, int channelCount)", "public static final MediaFormat createSubtitleFormat(@NonNull String mime, String language)", "public static final MediaFormat createVideoFormat(@NonNull String mime, int width, int height)", "public String toString()" ],
  "variableNames" : [ "MIMETYPE_VIDEO_VP8", "MIMETYPE_VIDEO_VP9", "MIMETYPE_VIDEO_AV1", "MIMETYPE_VIDEO_AVC", "MIMETYPE_VIDEO_HEVC", "MIMETYPE_VIDEO_MPEG4", "MIMETYPE_VIDEO_H263", "MIMETYPE_VIDEO_MPEG2", "MIMETYPE_VIDEO_RAW", "MIMETYPE_VIDEO_DOLBY_VISION", "MIMETYPE_VIDEO_SCRAMBLED", "MIMETYPE_AUDIO_AMR_NB", "MIMETYPE_AUDIO_AMR_WB", "MIMETYPE_AUDIO_MPEG", "MIMETYPE_AUDIO_AAC", "MIMETYPE_AUDIO_QCELP", "MIMETYPE_AUDIO_VORBIS", "MIMETYPE_AUDIO_OPUS", "MIMETYPE_AUDIO_G711_ALAW", "MIMETYPE_AUDIO_G711_MLAW", "MIMETYPE_AUDIO_RAW", "MIMETYPE_AUDIO_FLAC", "MIMETYPE_AUDIO_MSGSM", "MIMETYPE_AUDIO_AC3", "MIMETYPE_AUDIO_EAC3", "MIMETYPE_AUDIO_EAC3_JOC", "MIMETYPE_AUDIO_AC4", "MIMETYPE_AUDIO_SCRAMBLED", "MIMETYPE_AUDIO_MPEGH_MHA1", "MIMETYPE_AUDIO_MPEGH_MHM1", "MIMETYPE_AUDIO_DTS", "MIMETYPE_AUDIO_DTS_HD", "MIMETYPE_AUDIO_DTS_UHD", "MIMETYPE_AUDIO_DRA", "MIMETYPE_AUDIO_DOLBY_MAT", "MIMETYPE_AUDIO_DOLBY_TRUEHD", "MIMETYPE_AUDIO_AAC_LC", "MIMETYPE_AUDIO_AAC_HE_V1", "MIMETYPE_AUDIO_AAC_HE_V2", "MIMETYPE_AUDIO_AAC_ELD", "MIMETYPE_AUDIO_AAC_XHE", "MIMETYPE_AUDIO_MPEGH_BL_L3", "MIMETYPE_AUDIO_MPEGH_BL_L4", "MIMETYPE_AUDIO_MPEGH_LC_L3", "MIMETYPE_AUDIO_MPEGH_LC_L4", "MIMETYPE_AUDIO_IEC61937", "MIMETYPE_IMAGE_ANDROID_HEIC", "MIMETYPE_IMAGE_AVIF", "MIMETYPE_TEXT_VTT", "MIMETYPE_TEXT_SUBRIP", "MIMETYPE_TEXT_CEA_608", "MIMETYPE_TEXT_CEA_708", "mMap", "LOG_SESSION_ID", "KEY_MIME", "KEY_CODECS_STRING", "KEY_LOW_LATENCY", "KEY_LANGUAGE", "KEY_CAPTION_SERVICE_NUMBER", "KEY_SAMPLE_RATE", "KEY_CHANNEL_COUNT", "KEY_WIDTH", "KEY_HEIGHT", "KEY_CROP_BOTTOM", "KEY_CROP_LEFT", "KEY_CROP_RIGHT", "KEY_CROP_TOP", "KEY_MAX_WIDTH", "KEY_MAX_HEIGHT", "KEY_MAX_INPUT_SIZE", "KEY_BUFFER_BATCH_MAX_OUTPUT_SIZE", "KEY_BUFFER_BATCH_THRESHOLD_OUTPUT_SIZE", "KEY_PIXEL_ASPECT_RATIO_WIDTH", "KEY_PIXEL_ASPECT_RATIO_HEIGHT", "KEY_BIT_RATE", "KEY_HARDWARE_AV_SYNC_ID", "KEY_MAX_BIT_RATE", "KEY_COLOR_FORMAT", "KEY_FRAME_RATE", "KEY_TILE_WIDTH", "KEY_TILE_HEIGHT", "KEY_GRID_ROWS", "KEY_GRID_COLUMNS", "KEY_PCM_ENCODING", "KEY_CAPTURE_RATE", "KEY_SLOW_MOTION_MARKERS", "KEY_I_FRAME_INTERVAL", "KEY_INTRA_REFRESH_PERIOD", "KEY_PREPEND_HEADER_TO_SYNC_FRAMES", "KEY_TEMPORAL_LAYERING", "KEY_STRIDE", "KEY_SLICE_HEIGHT", "KEY_REPEAT_PREVIOUS_FRAME_AFTER", "KEY_MAX_FPS_TO_ENCODER", "KEY_MAX_PTS_GAP_TO_ENCODER", "KEY_CREATE_INPUT_SURFACE_SUSPENDED", "KEY_PUSH_BLANK_BUFFERS_ON_STOP", "KEY_DURATION", "KEY_IS_ADTS", "KEY_CHANNEL_MASK", "KEY_MAX_OUTPUT_CHANNEL_COUNT", "KEY_ENCODER_DELAY", "KEY_ENCODER_PADDING", "KEY_AAC_PROFILE", "KEY_AAC_SBR_MODE", "KEY_AAC_MAX_OUTPUT_CHANNEL_COUNT", "KEY_AAC_DRC_TARGET_REFERENCE_LEVEL", "KEY_AAC_DRC_EFFECT_TYPE", "KEY_AAC_ENCODED_TARGET_LEVEL", "KEY_AAC_DRC_BOOST_FACTOR", "KEY_AAC_DRC_ATTENUATION_FACTOR", "KEY_AAC_DRC_HEAVY_COMPRESSION", "KEY_AAC_DRC_OUTPUT_LOUDNESS", "KEY_AAC_DRC_ALBUM_MODE", "KEY_FLAC_COMPRESSION_LEVEL", "KEY_MPEGH_PROFILE_LEVEL_INDICATION", "KEY_MPEGH_COMPATIBLE_SETS", "KEY_MPEGH_REFERENCE_CHANNEL_LAYOUT", "KEY_COMPLEXITY", "KEY_QUALITY", "KEY_PRIORITY", "KEY_OPERATING_RATE", "KEY_PROFILE", "KEY_LEVEL", "KEY_LATENCY", "KEY_OUTPUT_REORDER_DEPTH", "KEY_ROTATION", "KEY_BITRATE_MODE", "KEY_VIDEO_QP_MAX", "KEY_VIDEO_QP_MIN", "KEY_VIDEO_QP_I_MAX", "KEY_VIDEO_QP_I_MIN", "KEY_VIDEO_QP_P_MAX", "KEY_VIDEO_QP_P_MIN", "KEY_VIDEO_QP_B_MAX", "KEY_VIDEO_QP_B_MIN", "KEY_VIDEO_ENCODING_STATISTICS_LEVEL", "VIDEO_ENCODING_STATISTICS_LEVEL_NONE", "VIDEO_ENCODING_STATISTICS_LEVEL_1", "KEY_VIDEO_QP_AVERAGE", "KEY_PICTURE_TYPE", "PICTURE_TYPE_UNKNOWN", "PICTURE_TYPE_I", "PICTURE_TYPE_P", "PICTURE_TYPE_B", "KEY_AUDIO_SESSION_ID", "KEY_AUDIO_HW_SYNC", "KEY_IS_AUTOSELECT", "KEY_IS_DEFAULT", "KEY_IS_FORCED_SUBTITLE", "KEY_HAPTIC_CHANNEL_COUNT", "KEY_IS_TIMED_TEXT", "KEY_COLOR_STANDARD", "COLOR_STANDARD_BT709", "COLOR_STANDARD_BT601_PAL", "COLOR_STANDARD_BT601_NTSC", "COLOR_STANDARD_BT2020", "KEY_COLOR_TRANSFER", "COLOR_TRANSFER_LINEAR", "COLOR_TRANSFER_SDR_VIDEO", "COLOR_TRANSFER_ST2084", "COLOR_TRANSFER_HLG", "KEY_COLOR_RANGE", "COLOR_RANGE_LIMITED", "COLOR_RANGE_FULL", "KEY_HDR_STATIC_INFO", "KEY_HDR10_PLUS_INFO", "KEY_COLOR_TRANSFER_REQUEST", "KEY_TRACK_ID", "KEY_CA_SYSTEM_ID", "KEY_CA_SESSION_ID", "KEY_CA_PRIVATE_DATA", "KEY_MAX_B_FRAMES", "KEY_ALLOW_FRAME_DROP", "KEY_IMPORTANCE", "FLAG_SECURITY_MODEL_SANDBOXED", "FLAG_SECURITY_MODEL_MEMORY_SAFE", "FLAG_SECURITY_MODEL_TRUSTED_CONTENT_ONLY", "KEY_SECURITY_MODEL", "TYPE_NULL", "TYPE_INTEGER", "TYPE_LONG", "TYPE_FLOAT", "TYPE_STRING", "TYPE_BYTE_BUFFER", "KEY_FEATURE_" ]
}