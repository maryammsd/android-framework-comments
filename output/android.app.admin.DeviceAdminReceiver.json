{
  "filePath" : "/home/maryam/clearblue/files/android-source-35/android/app/admin/DeviceAdminReceiver.java",
  "packageName" : "android.app.admin",
  "className" : "DeviceAdminReceiver",
  "comment" : "\n * Base class for implementing a device administration component.  This\n * class provides a convenience for interpreting the raw intent actions\n * that are sent by the system.\n *\n * <p>The callback methods, like the base\n * {@link BroadcastReceiver#onReceive(Context, Intent) BroadcastReceiver.onReceive()}\n * method, happen on the main thread of the process.  Thus long running\n * operations must be done on another thread.  Note that because a receiver\n * is done once returning from its receive function, such long-running operations\n * should probably be done in a {@link Service}.\n *\n * <p>When publishing your DeviceAdmin subclass as a receiver, it must\n * handle {@link #ACTION_DEVICE_ADMIN_ENABLED} and require the\n * {@link android.Manifest.permission#BIND_DEVICE_ADMIN} permission.  A typical\n * manifest entry would look like:</p>\n *\n * {@sample development/samples/ApiDemos/AndroidManifest.xml device_admin_declaration}\n *\n * <p>The meta-data referenced here provides addition information specific\n * to the device administrator, as parsed by the {@link DeviceAdminInfo} class.\n * A typical file would be:</p>\n *\n * {@sample development/samples/ApiDemos/res/xml/device_admin_sample.xml meta_data}\n *\n * <div class=\"special reference\">\n * <h3>Developer Guides</h3>\n * <p>For more information about device administration, read the\n * <a href=\"{@docRoot}guide/topics/admin/device-admin.html\">Device Administration</a>\n * developer guide.</p>\n * </div>\n ",
  "links" : [ "android.content.BroadcastReceiver#onReceive(Context", "android.Manifest.permission#BIND_DEVICE_ADMIN", "android.app.Service", "android.app.admin.DeviceAdminInfo", "#ACTION_DEVICE_ADMIN_ENABLED" ],
  "variables" : [ {
    "name" : "TAG",
    "type" : "String",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "LOCAL_LOGV",
    "type" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "ACTION_DEVICE_ADMIN_ENABLED",
    "type" : "String",
    "comment" : "\n     * This is the primary action that a device administrator must implement to be\n     * allowed to manage a device.  This will be set to the receiver\n     * when the user enables it for administration.  You will generally\n     * handle this in {@link DeviceAdminReceiver#onEnabled(Context, Intent)}.  To be\n     * supported, the receiver must also require the\n     * {@link android.Manifest.permission#BIND_DEVICE_ADMIN} permission so\n     * that other applications can not abuse it.\n     ",
    "links" : [ "android.Manifest.permission#BIND_DEVICE_ADMIN", "android.app.admin.DeviceAdminReceiver#onEnabled(Context" ]
  }, {
    "name" : "ACTION_DEVICE_ADMIN_DISABLE_REQUESTED",
    "type" : "String",
    "comment" : "\n     * Action sent to a device administrator when the user has requested to\n     * disable it, but before this has actually been done.  This gives you\n     * a chance to supply a message to the user about the impact of\n     * disabling your admin, by setting the extra field\n     * {@link #EXTRA_DISABLE_WARNING} in the result Intent.  If not set,\n     * no warning will be displayed.  If set, the given text will be shown\n     * to the user before they disable your admin.\n     ",
    "links" : [ "#EXTRA_DISABLE_WARNING" ]
  }, {
    "name" : "EXTRA_DISABLE_WARNING",
    "type" : "String",
    "comment" : "\n     * A CharSequence that can be shown to the user informing them of the\n     * impact of disabling your admin.\n     *\n     * @see #ACTION_DEVICE_ADMIN_DISABLE_REQUESTED\n     ",
    "links" : [ ]
  }, {
    "name" : "ACTION_DEVICE_ADMIN_DISABLED",
    "type" : "String",
    "comment" : "\n     * Action sent to a device administrator when the user has disabled\n     * it.  Upon return, the application no longer has access to the\n     * protected device policy manager APIs.  You will generally\n     * handle this in {@link DeviceAdminReceiver#onDisabled(Context, Intent)}.  Note\n     * that this action will be\n     * sent the receiver regardless of whether it is explicitly listed in\n     * its intent filter.\n     ",
    "links" : [ "android.app.admin.DeviceAdminReceiver#onDisabled(Context" ]
  }, {
    "name" : "ACTION_PASSWORD_CHANGED",
    "type" : "String",
    "comment" : "\n     * Action sent to a device administrator when the user has changed the password of their device\n     * or profile challenge.  You can at this point check the characteristics\n     * of the new password with {@link DevicePolicyManager#isActivePasswordSufficient()\n     * DevicePolicyManager.isActivePasswordSufficient()}.\n     * You will generally\n     * handle this in {@link DeviceAdminReceiver#onPasswordChanged(Context, Intent, UserHandle)}.\n     *\n     * <p>The calling device admin must have requested\n     * {@link DeviceAdminInfo#USES_POLICY_LIMIT_PASSWORD} to receive\n     * this broadcast.\n     ",
    "links" : [ "android.app.admin.DeviceAdminInfo#USES_POLICY_LIMIT_PASSWORD", "android.app.admin.DeviceAdminReceiver#onPasswordChanged(Context", "android.app.admin.DevicePolicyManager#isActivePasswordSufficient()" ]
  }, {
    "name" : "ACTION_PASSWORD_FAILED",
    "type" : "String",
    "comment" : "\n     * Action sent to a device administrator when the user has entered an incorrect device\n     * or profile challenge password.  You can at this point check the\n     * number of failed password attempts there have been with\n     * {@link DevicePolicyManager#getCurrentFailedPasswordAttempts\n     * DevicePolicyManager.getCurrentFailedPasswordAttempts()}.  You will generally\n     * handle this in {@link DeviceAdminReceiver#onPasswordFailed(Context, Intent, UserHandle)}.\n     *\n     * <p>The calling device admin must have requested\n     * {@link DeviceAdminInfo#USES_POLICY_WATCH_LOGIN} to receive\n     * this broadcast.\n     ",
    "links" : [ "android.app.admin.DevicePolicyManager#getCurrentFailedPasswordAttemptsDevicePolicyManager.getCurrentFailedPasswordAttempts()", "android.app.admin.DeviceAdminReceiver#onPasswordFailed(Context", "android.app.admin.DeviceAdminInfo#USES_POLICY_WATCH_LOGIN" ]
  }, {
    "name" : "ACTION_PASSWORD_SUCCEEDED",
    "type" : "String",
    "comment" : "\n     * Action sent to a device administrator when the user has successfully entered their device\n     * or profile challenge password, after failing one or more times.  You will generally\n     * handle this in {@link DeviceAdminReceiver#onPasswordSucceeded(Context, Intent, UserHandle)}.\n     *\n     * <p>The calling device admin must have requested\n     * {@link DeviceAdminInfo#USES_POLICY_WATCH_LOGIN} to receive\n     * this broadcast.\n     ",
    "links" : [ "android.app.admin.DeviceAdminInfo#USES_POLICY_WATCH_LOGIN", "android.app.admin.DeviceAdminReceiver#onPasswordSucceeded(Context" ]
  }, {
    "name" : "ACTION_PASSWORD_EXPIRING",
    "type" : "String",
    "comment" : "\n     * Action periodically sent to a device administrator when the device or profile challenge\n     * password is expiring.  You will generally\n     * handle this in {@link DeviceAdminReceiver#onPasswordExpiring(Context, Intent, UserHandle)}.\n     *\n     * <p>The calling device admin must have requested\n     * {@link DeviceAdminInfo#USES_POLICY_EXPIRE_PASSWORD} to receive\n     * this broadcast.\n     ",
    "links" : [ "android.app.admin.DeviceAdminReceiver#onPasswordExpiring(Context", "android.app.admin.DeviceAdminInfo#USES_POLICY_EXPIRE_PASSWORD" ]
  }, {
    "name" : "ACTION_LOCK_TASK_ENTERING",
    "type" : "String",
    "comment" : "\n     * Action sent to a device administrator to notify that the device is entering\n     * lock task mode.  The extra {@link #EXTRA_LOCK_TASK_PACKAGE}\n     * will describe the package using lock task mode.\n     *\n     * <p>The calling device admin must be the device owner or profile\n     * owner to receive this broadcast.\n     *\n     * @see DevicePolicyManager#isLockTaskPermitted(String)\n     ",
    "links" : [ "#EXTRA_LOCK_TASK_PACKAGE" ]
  }, {
    "name" : "ACTION_LOCK_TASK_EXITING",
    "type" : "String",
    "comment" : "\n     * Action sent to a device administrator to notify that the device is exiting\n     * lock task mode.\n     *\n     * <p>The calling device admin must be the device owner or profile\n     * owner to receive this broadcast.\n     *\n     * @see DevicePolicyManager#isLockTaskPermitted(String)\n     ",
    "links" : [ ]
  }, {
    "name" : "EXTRA_LOCK_TASK_PACKAGE",
    "type" : "String",
    "comment" : "\n     * A string containing the name of the package entering lock task mode.\n     *\n     * @see #ACTION_LOCK_TASK_ENTERING\n     ",
    "links" : [ ]
  }, {
    "name" : "ACTION_PROFILE_PROVISIONING_COMPLETE",
    "type" : "String",
    "comment" : "\n     * Broadcast Action: This broadcast is sent to indicate that provisioning of a managed profile\n     * or managed device has completed successfully.\n     *\n     * <p>The broadcast is limited to the profile that will be managed by the application that\n     * requested provisioning. In the device owner case the profile is the primary user.\n     * The broadcast will also be limited to the {@link DeviceAdminReceiver} component\n     * specified in the original intent or NFC bump that started the provisioning process\n     * (see {@link DevicePolicyManager#ACTION_PROVISION_MANAGED_PROFILE\n     * DevicePolicyManager.ACTION_PROVISION_MANAGED_PROFILE}).\n     *\n     * <p>A device admin application which listens to this intent can find out if the device was\n     * provisioned for the device owner or profile owner case by calling respectively\n     * {@link android.app.admin.DevicePolicyManager#isDeviceOwnerApp} and\n     * {@link android.app.admin.DevicePolicyManager#isProfileOwnerApp}. You will generally handle\n     * this in {@link DeviceAdminReceiver#onProfileProvisioningComplete}.\n     *\n     * <p>The intent for this action may include the following extras:\n     * <ul>\n     *     <li>{@link DevicePolicyManager#EXTRA_PROVISIONING_ADMIN_EXTRAS_BUNDLE}\n     *\n     * @see DevicePolicyManager#ACTION_PROVISIONING_SUCCESSFUL\n     ",
    "links" : [ "android.app.admin.DeviceAdminReceiver#onProfileProvisioningComplete", "android.app.admin.DeviceAdminReceiver", "android.app.admin.DevicePolicyManager#isDeviceOwnerApp", "android.app.admin.DevicePolicyManager#ACTION_PROVISION_MANAGED_PROFILEDevicePolicyManager.ACTION_PROVISION_MANAGED_PROFILE", "android.app.admin.DevicePolicyManager#isProfileOwnerApp", "android.app.admin.DevicePolicyManager#EXTRA_PROVISIONING_ADMIN_EXTRAS_BUNDLE" ]
  }, {
    "name" : "ACTION_BUGREPORT_SHARING_DECLINED",
    "type" : "String",
    "comment" : "\n     * Action sent to a device administrator to notify that the device user\n     * has declined sharing a bugreport.\n     *\n     * <p>The calling device admin must be the device owner to receive this broadcast.\n     * @see DevicePolicyManager#requestBugreport\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "ACTION_BUGREPORT_FAILED",
    "type" : "String",
    "comment" : "\n     * Action sent to a device administrator to notify that the collection of a bugreport\n     * has failed.\n     *\n     * <p>The calling device admin must be the device owner to receive this broadcast.\n     * @see DevicePolicyManager#requestBugreport\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "ACTION_BUGREPORT_SHARE",
    "type" : "String",
    "comment" : "\n     * Action sent to a device administrator to share the bugreport.\n     *\n     * <p>The calling device admin must be the device owner to receive this broadcast.\n     * @see DevicePolicyManager#requestBugreport\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "ACTION_SECURITY_LOGS_AVAILABLE",
    "type" : "String",
    "comment" : "\n     * Broadcast action: notify that a new batch of security logs is ready to be collected.\n     ",
    "links" : [ ]
  }, {
    "name" : "ACTION_NETWORK_LOGS_AVAILABLE",
    "type" : "String",
    "comment" : "\n     * Broadcast action: notify that a new batch of network logs is ready to be collected.\n     * @see DeviceAdminReceiver#onNetworkLogsAvailable\n     * @see DelegatedAdminReceiver#onNetworkLogsAvailable\n     ",
    "links" : [ ]
  }, {
    "name" : "EXTRA_NETWORK_LOGS_TOKEN",
    "type" : "String",
    "comment" : "\n     * A {@code long} containing a token of the current batch of network logs, that has to be used\n     * to retrieve the batch of logs by the device owner.\n     *\n     * @see #ACTION_NETWORK_LOGS_AVAILABLE\n     * @see DevicePolicyManager#retrieveNetworkLogs\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "EXTRA_NETWORK_LOGS_COUNT",
    "type" : "String",
    "comment" : "\n     * An {@code int} count representing a total count of network logs inside the current batch of\n     * network logs.\n     *\n     * @see #ACTION_NETWORK_LOGS_AVAILABLE\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "ACTION_USER_ADDED",
    "type" : "String",
    "comment" : "\n     * Broadcast action: notify the device owner that a user or profile has been added.\n     * Carries an extra {@link Intent#EXTRA_USER} that has the {@link UserHandle} of\n     * the new user.\n     * @hide\n     ",
    "links" : [ "android.os.UserHandle", "android.content.Intent#EXTRA_USER" ]
  }, {
    "name" : "ACTION_USER_REMOVED",
    "type" : "String",
    "comment" : "\n     * Broadcast action: notify the device owner that a user or profile has been removed.\n     * Carries an extra {@link Intent#EXTRA_USER} that has the {@link UserHandle} of\n     * the user.\n     * @hide\n     ",
    "links" : [ "android.os.UserHandle", "android.content.Intent#EXTRA_USER" ]
  }, {
    "name" : "ACTION_USER_STARTED",
    "type" : "String",
    "comment" : "\n     * Broadcast action: notify the device owner that a user or profile has been started.\n     * Carries an extra {@link Intent#EXTRA_USER} that has the {@link UserHandle} of\n     * the user.\n     * @hide\n     ",
    "links" : [ "android.os.UserHandle", "android.content.Intent#EXTRA_USER" ]
  }, {
    "name" : "ACTION_USER_STOPPED",
    "type" : "String",
    "comment" : "\n     * Broadcast action: notify the device owner that a user or profile has been stopped.\n     * Carries an extra {@link Intent#EXTRA_USER} that has the {@link UserHandle} of\n     * the user.\n     * @hide\n     ",
    "links" : [ "android.os.UserHandle", "android.content.Intent#EXTRA_USER" ]
  }, {
    "name" : "ACTION_USER_SWITCHED",
    "type" : "String",
    "comment" : "\n     * Broadcast action: notify the device owner that a user or profile has been switched to.\n     * Carries an extra {@link Intent#EXTRA_USER} that has the {@link UserHandle} of\n     * the user.\n     * @hide\n     ",
    "links" : [ "android.os.UserHandle", "android.content.Intent#EXTRA_USER" ]
  }, {
    "name" : "EXTRA_BUGREPORT_HASH",
    "type" : "String",
    "comment" : "\n     * A string containing the SHA-256 hash of the bugreport file.\n     *\n     * @see #ACTION_BUGREPORT_SHARE\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "EXTRA_BUGREPORT_FAILURE_REASON",
    "type" : "String",
    "comment" : "\n     * An {@code int} failure code representing the reason of the bugreport failure. One of\n     * {@link #BUGREPORT_FAILURE_FAILED_COMPLETING}\n     * or {@link #BUGREPORT_FAILURE_FILE_NO_LONGER_AVAILABLE}\n     *\n     * @see #ACTION_BUGREPORT_FAILED\n     * @hide\n     ",
    "links" : [ "#BUGREPORT_FAILURE_FAILED_COMPLETING", "#BUGREPORT_FAILURE_FILE_NO_LONGER_AVAILABLE" ]
  }, {
    "name" : "BUGREPORT_FAILURE_FAILED_COMPLETING",
    "type" : "int",
    "comment" : "\n     * Bugreport completion process failed.\n     *\n     * <p>If this error code is received, the requesting of bugreport can be retried.\n     * @see DevicePolicyManager#requestBugreport\n     ",
    "links" : [ ]
  }, {
    "name" : "BUGREPORT_FAILURE_FILE_NO_LONGER_AVAILABLE",
    "type" : "int",
    "comment" : "\n     * Bugreport has been created, but is no longer available for collection.\n     *\n     * <p>This error likely occurs because the user of the device hasn't consented to share\n     * the bugreport for a long period after its creation.\n     *\n     * <p>If this error code is received, the requesting of bugreport can be retried.\n     * @see DevicePolicyManager#requestBugreport\n     ",
    "links" : [ ]
  }, {
    "name" : "ACTION_CHOOSE_PRIVATE_KEY_ALIAS",
    "type" : "String",
    "comment" : "\n     * Broadcast action: notify that some app is attempting to choose a KeyChain key.\n     * @see DeviceAdminReceiver#onChoosePrivateKeyAlias\n     * @see DelegatedAdminReceiver#onChoosePrivateKeyAlias\n     ",
    "links" : [ ]
  }, {
    "name" : "EXTRA_CHOOSE_PRIVATE_KEY_SENDER_UID",
    "type" : "String",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "EXTRA_CHOOSE_PRIVATE_KEY_URI",
    "type" : "String",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "EXTRA_CHOOSE_PRIVATE_KEY_ALIAS",
    "type" : "String",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "EXTRA_CHOOSE_PRIVATE_KEY_RESPONSE",
    "type" : "String",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "ACTION_NOTIFY_PENDING_SYSTEM_UPDATE",
    "type" : "String",
    "comment" : "\n     * Broadcast action: notify device owner that there is a pending system update.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "EXTRA_SYSTEM_UPDATE_RECEIVED_TIME",
    "type" : "String",
    "comment" : "\n     * A long type extra for {@link #onSystemUpdatePending} recording the system time as given by\n     * {@link System#currentTimeMillis()} when the current pending system update is first available.\n     * @hide\n     ",
    "links" : [ "#currentTimeMillis()", "#onSystemUpdatePending" ]
  }, {
    "name" : "DEVICE_ADMIN_META_DATA",
    "type" : "String",
    "comment" : "  TO DO: describe syntax.",
    "links" : [ ]
  }, {
    "name" : "ACTION_TRANSFER_OWNERSHIP_COMPLETE",
    "type" : "String",
    "comment" : "\n     * Broadcast action: notify the newly transferred administrator that the transfer\n     * from the original administrator was successful.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "ACTION_AFFILIATED_PROFILE_TRANSFER_OWNERSHIP_COMPLETE",
    "type" : "String",
    "comment" : "\n     * Broadcast action: notify the device owner that the ownership of one of its affiliated\n     * profiles is transferred.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "EXTRA_TRANSFER_OWNERSHIP_ADMIN_EXTRAS_BUNDLE",
    "type" : "String",
    "comment" : "\n     * A {@link android.os.Parcelable} extra of type {@link android.os.PersistableBundle} that\n     * allows a mobile device management application to pass data to the management application\n     * instance after owner transfer.\n     *\n     * <p>If the transfer is successful, the new owner receives the data in\n     * {@link DeviceAdminReceiver#onTransferOwnershipComplete(Context, PersistableBundle)}.\n     * The bundle is not changed during the ownership transfer.\n     *\n     * @see DevicePolicyManager#transferOwnership(ComponentName, ComponentName, PersistableBundle)\n     ",
    "links" : [ "android.app.admin.DeviceAdminReceiver#onTransferOwnershipComplete(Context", "android.os.Parcelable", "android.os.PersistableBundle" ]
  }, {
    "name" : "ACTION_OPERATION_SAFETY_STATE_CHANGED",
    "type" : "String",
    "comment" : "\n     * Broadcast action: notify the admin that the state of operations that can be unsafe because\n     * of a given reason (specified by the {@link #EXTRA_OPERATION_SAFETY_REASON} {@code int} extra)\n     * has changed (the new value is specified by the {@link #EXTRA_OPERATION_SAFETY_STATE}\n     * {@code boolean} extra).\n     *\n     * @hide\n     ",
    "links" : [ "#EXTRA_OPERATION_SAFETY_REASON", "#EXTRA_OPERATION_SAFETY_STATE" ]
  }, {
    "name" : "ACTION_COMPLIANCE_ACKNOWLEDGEMENT_REQUIRED",
    "type" : "String",
    "comment" : "\n     * Broadcast action: notify the profile owner on an organization-owned device that it needs to\n     * acknowledge device compliance.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "EXTRA_OPERATION_SAFETY_REASON",
    "type" : "String",
    "comment" : "\n     * An {@code int} extra specifying an {@link OperationSafetyReason}.\n     *\n     * @hide\n     ",
    "links" : [ "android.app.admin.DevicePolicyManager.OperationSafetyReason" ]
  }, {
    "name" : "EXTRA_OPERATION_SAFETY_STATE",
    "type" : "String",
    "comment" : "\n     * An {@code boolean} extra specifying whether an operation will fail due to a\n     * {@link OperationSafetyReason}. {@code true} means operations that rely on that reason are\n     * safe, while {@code false} means they're unsafe.\n     *\n     * @hide\n     ",
    "links" : [ "android.app.admin.DevicePolicyManager.OperationSafetyReason" ]
  }, {
    "name" : "mManager",
    "type" : "DevicePolicyManager",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mWho",
    "type" : "ComponentName",
    "comment" : "",
    "links" : [ ]
  } ],
  "methods" : [ {
    "name" : "public DevicePolicyManager getManager(@NonNull Context context)",
    "returnType" : "DevicePolicyManager",
    "comment" : "\n     * Retrieve the DevicePolicyManager interface for this administrator to work\n     * with the system.\n     ",
    "links" : [ ]
  }, {
    "name" : "public ComponentName getWho(@NonNull Context context)",
    "returnType" : "ComponentName",
    "comment" : "\n     * Retrieve the ComponentName describing who this device administrator is, for\n     * use in {@link DevicePolicyManager} APIs that require the administrator to\n     * identify itself.\n     ",
    "links" : [ "android.app.admin.DevicePolicyManager" ]
  }, {
    "name" : "public void onEnabled(@NonNull Context context, @NonNull Intent intent)",
    "returnType" : "void",
    "comment" : "\n     * Called after the administrator is first enabled, as a result of\n     * receiving {@link #ACTION_DEVICE_ADMIN_ENABLED}.  At this point you\n     * can use {@link DevicePolicyManager} to set your desired policies.\n     *\n     * <p> If the admin is activated by a device owner, then the intent\n     * may contain private extras that are relevant to user setup.\n     * {@see DevicePolicyManager#createAndManageUser(ComponentName, String, ComponentName,\n     *      PersistableBundle, int)}\n     *\n     * @param context The running context as per {@link #onReceive}.\n     * @param intent The received intent as per {@link #onReceive}.\n     ",
    "links" : [ "#onReceive", "android.app.admin.DevicePolicyManager", "#ACTION_DEVICE_ADMIN_ENABLED" ]
  }, {
    "name" : "public CharSequence onDisableRequested(@NonNull Context context, @NonNull Intent intent)",
    "returnType" : "CharSequence",
    "comment" : "\n     * Called when the user has asked to disable the administrator, as a result of\n     * receiving {@link #ACTION_DEVICE_ADMIN_DISABLE_REQUESTED}, giving you\n     * a chance to present a warning message to them.  The message is returned\n     * as the result; if null is returned (the default implementation), no\n     * message will be displayed.\n     * @param context The running context as per {@link #onReceive}.\n     * @param intent The received intent as per {@link #onReceive}.\n     * @return Return the warning message to display to the user before\n     * being disabled; if null is returned, no message is displayed.\n     ",
    "links" : [ "#onReceive", "#ACTION_DEVICE_ADMIN_DISABLE_REQUESTED" ]
  }, {
    "name" : "public void onDisabled(@NonNull Context context, @NonNull Intent intent)",
    "returnType" : "void",
    "comment" : "\n     * Called prior to the administrator being disabled, as a result of\n     * receiving {@link #ACTION_DEVICE_ADMIN_DISABLED}.  Upon return, you\n     * can no longer use the protected parts of the {@link DevicePolicyManager}\n     * API.\n     * @param context The running context as per {@link #onReceive}.\n     * @param intent The received intent as per {@link #onReceive}.\n     ",
    "links" : [ "#onReceive", "android.app.admin.DevicePolicyManager", "#ACTION_DEVICE_ADMIN_DISABLED" ]
  }, {
    "name" : "public void onPasswordChanged(@NonNull Context context, @NonNull Intent intent)",
    "returnType" : "void",
    "comment" : "\n     * Called after the user has changed their device or profile challenge password, as a result of\n     * receiving {@link #ACTION_PASSWORD_CHANGED}.  At this point you\n     * can use {@link DevicePolicyManager#getPasswordQuality(android.content.ComponentName)}\n     * to retrieve the active password characteristics.\n     * @param context The running context as per {@link #onReceive}.\n     * @param intent The received intent as per {@link #onReceive}.\n     *\n     * @deprecated From {@link android.os.Build.VERSION_CODES#O}, use\n     *             {@link #onPasswordChanged(Context, Intent, UserHandle)} instead.\n     ",
    "links" : [ "android.os.Build.VERSION_CODES#O", "#onReceive", "#ACTION_PASSWORD_CHANGED", "#onPasswordChanged(Context", "android.app.admin.DevicePolicyManager#getPasswordQuality(android.content.ComponentName)" ]
  }, {
    "name" : "public void onPasswordChanged(@NonNull Context context, @NonNull Intent intent, @NonNull UserHandle user)",
    "returnType" : "void",
    "comment" : "\n     * Called after the user has changed their device or profile challenge password, as a result of\n     * receiving {@link #ACTION_PASSWORD_CHANGED}.  At this point you\n     * can use {@link DevicePolicyManager#getPasswordQuality(android.content.ComponentName)}\n     * to retrieve the active password characteristics.\n     * @param context The running context as per {@link #onReceive}.\n     * @param intent The received intent as per {@link #onReceive}.\n     * @param user The user or profile for whom the password changed. To see whether this\n     *        user is the current profile or a parent user, check for equality with\n     *        {@link Process#myUserHandle}.\n     ",
    "links" : [ "#onReceive", "android.os.Process#myUserHandle", "#ACTION_PASSWORD_CHANGED", "android.app.admin.DevicePolicyManager#getPasswordQuality(android.content.ComponentName)" ]
  }, {
    "name" : "public void onPasswordFailed(@NonNull Context context, @NonNull Intent intent)",
    "returnType" : "void",
    "comment" : "\n     * Called after the user has failed at entering their device or profile challenge password,\n     * as a result of receiving {@link #ACTION_PASSWORD_FAILED}.  At this point you can use\n     * {@link DevicePolicyManager#getCurrentFailedPasswordAttempts()} to retrieve the number of\n     * failed password attempts.\n     * @param context The running context as per {@link #onReceive}.\n     * @param intent The received intent as per {@link #onReceive}.\n     *\n     * @deprecated From {@link android.os.Build.VERSION_CODES#O}, use\n     *             {@link #onPasswordFailed(Context, Intent, UserHandle)} instead.\n     ",
    "links" : [ "android.app.admin.DevicePolicyManager#getCurrentFailedPasswordAttempts()", "android.os.Build.VERSION_CODES#O", "#ACTION_PASSWORD_FAILED", "#onReceive", "#onPasswordFailed(Context" ]
  }, {
    "name" : "public void onPasswordFailed(@NonNull Context context, @NonNull Intent intent, @NonNull UserHandle user)",
    "returnType" : "void",
    "comment" : "\n     * Called after the user has failed at entering their device or profile challenge password,\n     * as a result of receiving {@link #ACTION_PASSWORD_FAILED}.  At this point you can use\n     * {@link DevicePolicyManager#getCurrentFailedPasswordAttempts()} to retrieve the number of\n     * failed password attempts.\n     * @param context The running context as per {@link #onReceive}.\n     * @param intent The received intent as per {@link #onReceive}.\n     * @param user The user or profile for whom the password check failed. To see whether this\n     *        user is the current profile or a parent user, check for equality with\n     *        {@link Process#myUserHandle}.\n     ",
    "links" : [ "android.app.admin.DevicePolicyManager#getCurrentFailedPasswordAttempts()", "#ACTION_PASSWORD_FAILED", "#onReceive", "android.os.Process#myUserHandle" ]
  }, {
    "name" : "public void onPasswordSucceeded(@NonNull Context context, @NonNull Intent intent)",
    "returnType" : "void",
    "comment" : "\n     * Called after the user has succeeded at entering their device or profile challenge password,\n     * as a result of receiving {@link #ACTION_PASSWORD_SUCCEEDED}.  This will\n     * only be received the first time they succeed after having previously\n     * failed.\n     * @param context The running context as per {@link #onReceive}.\n     * @param intent The received intent as per {@link #onReceive}.\n     *\n     * @deprecated From {@link android.os.Build.VERSION_CODES#O}, use\n     *             {@link #onPasswordSucceeded(Context, Intent, UserHandle)} instead.\n     ",
    "links" : [ "android.os.Build.VERSION_CODES#O", "#onReceive", "#ACTION_PASSWORD_SUCCEEDED", "#onPasswordSucceeded(Context" ]
  }, {
    "name" : "public void onPasswordSucceeded(@NonNull Context context, @NonNull Intent intent, @NonNull UserHandle user)",
    "returnType" : "void",
    "comment" : "\n     * Called after the user has succeeded at entering their device or profile challenge password,\n     * as a result of receiving {@link #ACTION_PASSWORD_SUCCEEDED}.  This will\n     * only be received the first time they succeed after having previously\n     * failed.\n     * @param context The running context as per {@link #onReceive}.\n     * @param intent The received intent as per {@link #onReceive}.\n     * @param user The user of profile for whom the password check succeeded.  To see whether this\n     *        user is the current profile or a parent user, check for equality with\n     *        {@link Process#myUserHandle}.\n     ",
    "links" : [ "#onReceive", "android.os.Process#myUserHandle", "#ACTION_PASSWORD_SUCCEEDED" ]
  }, {
    "name" : "public void onPasswordExpiring(@NonNull Context context, @NonNull Intent intent)",
    "returnType" : "void",
    "comment" : "\n     * Called periodically when the device or profile challenge password is about to expire\n     * or has expired.  It will typically be called at these times: on device boot, once per day\n     * before the password expires, and at the time when the password expires.\n     *\n     * <p>If the password is not updated by the user, this method will continue to be called\n     * once per day until the password is changed or the device admin disables password expiration.\n     *\n     * <p>The admin will typically post a notification requesting the user to change their password\n     * in response to this call. The actual password expiration time can be obtained by calling\n     * {@link DevicePolicyManager#getPasswordExpiration(ComponentName) }\n     *\n     * <p>The admin should be sure to take down any notifications it posted in response to this call\n     * when it receives {@link DeviceAdminReceiver#onPasswordChanged(Context, Intent) }.\n     *\n     * @param context The running context as per {@link #onReceive}.\n     * @param intent The received intent as per {@link #onReceive}.\n     *\n     * @deprecated From {@link android.os.Build.VERSION_CODES#O}, use\n     *             {@link #onPasswordExpiring(Context, Intent, UserHandle)} instead.\n     ",
    "links" : [ "android.os.Build.VERSION_CODES#O", "android.app.admin.DevicePolicyManager#getPasswordExpiration(ComponentName)", "#onReceive", "android.app.admin.DeviceAdminReceiver#onPasswordChanged(Context", "#onPasswordExpiring(Context" ]
  }, {
    "name" : "public void onPasswordExpiring(@NonNull Context context, @NonNull Intent intent, @NonNull UserHandle user)",
    "returnType" : "void",
    "comment" : "\n     * Called periodically when the device or profile challenge password is about to expire\n     * or has expired.  It will typically be called at these times: on device boot, once per day\n     * before the password expires, and at the time when the password expires.\n     *\n     * <p>If the password is not updated by the user, this method will continue to be called\n     * once per day until the password is changed or the device admin disables password expiration.\n     *\n     * <p>The admin will typically post a notification requesting the user to change their password\n     * in response to this call. The actual password expiration time can be obtained by calling\n     * {@link DevicePolicyManager#getPasswordExpiration(ComponentName) }\n     *\n     * <p>The admin should be sure to take down any notifications it posted in response to this call\n     * when it receives {@link DeviceAdminReceiver#onPasswordChanged(Context, Intent, UserHandle) }.\n     *\n     * @param context The running context as per {@link #onReceive}.\n     * @param intent The received intent as per {@link #onReceive}.\n     * @param user The user or profile for whom the password is expiring. To see whether this\n     *        user is the current profile or a parent user, check for equality with\n     *        {@link Process#myUserHandle}.\n     ",
    "links" : [ "android.app.admin.DevicePolicyManager#getPasswordExpiration(ComponentName)", "#onReceive", "android.os.Process#myUserHandle", "android.app.admin.DeviceAdminReceiver#onPasswordChanged(Context" ]
  }, {
    "name" : "public void onProfileProvisioningComplete(@NonNull Context context, @NonNull Intent intent)",
    "returnType" : "void",
    "comment" : "\n     * Called when provisioning of a managed profile or managed device has completed successfully.\n     *\n     * <p> As a prerequisite for the execution of this callback the {@link DeviceAdminReceiver} has\n     * to declare an intent filter for {@link #ACTION_PROFILE_PROVISIONING_COMPLETE}.\n     * Its component must also be specified in the {@link DevicePolicyManager#EXTRA_DEVICE_ADMIN}\n     * of the {@link DevicePolicyManager#ACTION_PROVISION_MANAGED_PROFILE} intent that started the\n     * managed provisioning.\n     *\n     * <p>When provisioning of a managed profile is complete, the managed profile is hidden until\n     * the profile owner calls {@link DevicePolicyManager#setProfileEnabled(ComponentName admin)}.\n     * Typically a profile owner will enable the profile when it has finished any additional setup\n     * such as adding an account by using the {@link AccountManager} and calling APIs to bring the\n     * profile into the desired state.\n     *\n     * <p> Note that provisioning completes without waiting for any server interactions, so the\n     * profile owner needs to wait for data to be available if required (e.g. Android device IDs or\n     * other data that is set as a result of server interactions).\n     *\n     * <p>From version {@link android.os.Build.VERSION_CODES#O}, when managed provisioning has\n     * completed, along with this callback the activity intent\n     * {@link DevicePolicyManager#ACTION_PROVISIONING_SUCCESSFUL} will also be sent to the same\n     * application.\n     *\n     * <p>The {@code Intent} may include any of the extras specified for\n     * {@link #ACTION_PROFILE_PROVISIONING_COMPLETE}.\n     *\n     * @param context The running context as per {@link #onReceive}.\n     * @param intent The received intent as per {@link #onReceive}.\n     ",
    "links" : [ "android.accounts.AccountManager", "#ACTION_PROFILE_PROVISIONING_COMPLETE", "android.os.Build.VERSION_CODES#O", "android.app.admin.DevicePolicyManager#ACTION_PROVISION_MANAGED_PROFILE", "#onReceive", "android.app.admin.DeviceAdminReceiver", "android.app.admin.DevicePolicyManager#EXTRA_DEVICE_ADMIN", "android.app.admin.DevicePolicyManager#ACTION_PROVISIONING_SUCCESSFUL", "android.app.admin.DevicePolicyManager#setProfileEnabled(ComponentName" ]
  }, {
    "name" : "public void onReadyForUserInitialization(@NonNull Context context, @NonNull Intent intent)",
    "returnType" : "void",
    "comment" : "\n     * Called during provisioning of a managed device to allow the device initializer to perform\n     * user setup steps.\n     *\n     * @param context The running context as per {@link #onReceive}.\n     * @param intent The received intent as per {@link #onReceive}.\n     * @deprecated Do not use\n     ",
    "links" : [ "#onReceive" ]
  }, {
    "name" : "public void onLockTaskModeEntering(@NonNull Context context, @NonNull Intent intent, @NonNull String pkg)",
    "returnType" : "void",
    "comment" : "\n     * Called when a device is entering lock task mode.\n     *\n     * @param context The running context as per {@link #onReceive}.\n     * @param intent The received intent as per {@link #onReceive}.\n     * @param pkg The authorized package using lock task mode.\n     ",
    "links" : [ "#onReceive" ]
  }, {
    "name" : "public void onLockTaskModeExiting(@NonNull Context context, @NonNull Intent intent)",
    "returnType" : "void",
    "comment" : "\n     * Called when a device is exiting lock task mode.\n     *\n     * @param context The running context as per {@link #onReceive}.\n     * @param intent The received intent as per {@link #onReceive}.\n     ",
    "links" : [ "#onReceive" ]
  }, {
    "name" : "public String onChoosePrivateKeyAlias(@NonNull Context context, @NonNull Intent intent, int uid, @Nullable Uri uri, @Nullable String alias)",
    "returnType" : "String",
    "comment" : "\n     * Allows this receiver to select the alias for a private key and certificate pair for\n     * authentication. If this method returns null, the default {@link android.app.Activity} will be\n     * shown that lets the user pick a private key and certificate pair.\n     * If this method returns {@link KeyChain#KEY_ALIAS_SELECTION_DENIED},\n     * the default {@link android.app.Activity} will not be shown and the user will not be allowed\n     * to pick anything. And the app, that called {@link KeyChain#choosePrivateKeyAlias}, will\n     * receive {@code null} back.\n     *\n     * @param context The running context as per {@link #onReceive}.\n     * @param intent The received intent as per {@link #onReceive}.\n     * @param uid The uid of the app asking for the private key and certificate pair.\n     * @param uri The URI to authenticate, may be null.\n     * @param alias The alias preselected by the client, or null.\n     * @return The private key alias to return and grant access to.\n     * @see KeyChain#choosePrivateKeyAlias\n     ",
    "links" : [ "#onReceive", "android.security.KeyChain#KEY_ALIAS_SELECTION_DENIED", "android.security.KeyChain#choosePrivateKeyAlias", "android.app.Activity" ]
  }, {
    "name" : "public void onSystemUpdatePending(@NonNull Context context, @NonNull Intent intent, long receivedTime)",
    "returnType" : "void",
    "comment" : "\n     * Called when the information about a pending system update is available.\n     *\n     * <p>Allows the receiver to be notified when information about a pending system update is\n     * available from the system update service. The same pending system update can trigger multiple\n     * calls to this method, so it is necessary to examine the incoming parameters for details about\n     * the update.\n     *\n     * <p>This callback is only applicable to device owners and profile owners.\n     *\n     * <p>To get further information about a pending system update (for example, whether or not the\n     * update is a security patch), the device owner or profile owner can call\n     * {@link DevicePolicyManager#getPendingSystemUpdate}.\n     *\n     * @param context The running context as per {@link #onReceive}.\n     * @param intent The received intent as per {@link #onReceive}.\n     * @param receivedTime The time as given by {@link System#currentTimeMillis()} indicating when\n     *        the current pending update was first available. -1 if no pending update is available.\n     * @see DevicePolicyManager#getPendingSystemUpdate\n     ",
    "links" : [ "#currentTimeMillis()", "#onReceive", "android.app.admin.DevicePolicyManager#getPendingSystemUpdate" ]
  }, {
    "name" : "public void onBugreportSharingDeclined(@NonNull Context context, @NonNull Intent intent)",
    "returnType" : "void",
    "comment" : "\n     * Called when sharing a bugreport has been cancelled by the user of the device.\n     *\n     * <p>This callback is only applicable to device owners.\n     *\n     * @param context The running context as per {@link #onReceive}.\n     * @param intent The received intent as per {@link #onReceive}.\n     * @see DevicePolicyManager#requestBugreport\n     ",
    "links" : [ "#onReceive" ]
  }, {
    "name" : "public void onBugreportShared(@NonNull Context context, @NonNull Intent intent, @NonNull String bugreportHash)",
    "returnType" : "void",
    "comment" : "\n     * Called when the bugreport has been shared with the device administrator app.\n     *\n     * <p>This callback is only applicable to device owners.\n     *\n     * @param context The running context as per {@link #onReceive}.\n     * @param intent The received intent as per {@link #onReceive}. Contains the URI of\n     * the bugreport file (with MIME type \"application/vnd.android.bugreport\"), that can be accessed\n     * by calling {@link Intent#getData()}\n     * @param bugreportHash SHA-256 hash of the bugreport file.\n     * @see DevicePolicyManager#requestBugreport\n     ",
    "links" : [ "#onReceive", "android.content.Intent#getData()" ]
  }, {
    "name" : "public void onBugreportFailed(@NonNull Context context, @NonNull Intent intent, @BugreportFailureCode int failureCode)",
    "returnType" : "void",
    "comment" : "\n     * Called when the bugreport collection flow has failed.\n     *\n     * <p>This callback is only applicable to device owners.\n     *\n     * @param context The running context as per {@link #onReceive}.\n     * @param intent The received intent as per {@link #onReceive}.\n     * @param failureCode int containing failure code. One of\n     * {@link #BUGREPORT_FAILURE_FAILED_COMPLETING}\n     * or {@link #BUGREPORT_FAILURE_FILE_NO_LONGER_AVAILABLE}\n     * @see DevicePolicyManager#requestBugreport\n     ",
    "links" : [ "#BUGREPORT_FAILURE_FAILED_COMPLETING", "#onReceive", "#BUGREPORT_FAILURE_FILE_NO_LONGER_AVAILABLE" ]
  }, {
    "name" : "public void onSecurityLogsAvailable(@NonNull Context context, @NonNull Intent intent)",
    "returnType" : "void",
    "comment" : "\n     * Called when a new batch of security logs can be retrieved.\n     *\n     * <p>If a secondary user or profile is created, this callback won't be received until all users\n     * become affiliated again (even if security logging is enabled).\n     * See {@link DevicePolicyManager#setAffiliationIds}\n     *\n     * <p>This callback will be re-triggered if the logs are not retrieved.\n     *\n     * <p>This callback is only applicable to device owners and profile owners of\n     * organization-owned managed profiles.\n     *\n     * <p>\n     * This callback is triggered by a foreground broadcast and the app should ensure that any\n     * long-running work is not executed synchronously inside the callback.\n     *\n     * @param context The running context as per {@link #onReceive}.\n     * @param intent The received intent as per {@link #onReceive}.\n     * @see DevicePolicyManager#retrieveSecurityLogs(ComponentName)\n     ",
    "links" : [ "#onReceive", "android.app.admin.DevicePolicyManager#setAffiliationIds" ]
  }, {
    "name" : "public void onNetworkLogsAvailable(@NonNull Context context, @NonNull Intent intent, long batchToken, @IntRange(from = 1) int networkLogsCount)",
    "returnType" : "void",
    "comment" : "\n     * Called each time a new batch of network logs can be retrieved. This callback method will only\n     * ever be called when network logging is enabled. The logs can only be retrieved while network\n     * logging is enabled.\n     *\n     * <p>If a secondary user or profile is created, this callback won't be received until all users\n     * become affiliated again (even if network logging is enabled). It will also no longer be\n     * possible to retrieve the network logs batch with the most recent {@code batchToken} provided\n     * by this callback. See {@link DevicePolicyManager#setAffiliationIds}.\n     *\n     * <p>This callback is only applicable to device owners and profile owners.\n     *\n     * <p>\n     * This callback is triggered by a foreground broadcast and the app should ensure that any\n     * long-running work is not executed synchronously inside the callback.\n     *\n     * @param context The running context as per {@link #onReceive}.\n     * @param intent The received intent as per {@link #onReceive}.\n     * @param batchToken The token representing the current batch of network logs.\n     * @param networkLogsCount The total count of events in the current batch of network logs.\n     * @see DevicePolicyManager#retrieveNetworkLogs\n     ",
    "links" : [ "#onReceive", "android.app.admin.DevicePolicyManager#setAffiliationIds" ]
  }, {
    "name" : "public void onUserAdded(@NonNull Context context, @NonNull Intent intent, @NonNull UserHandle addedUser)",
    "returnType" : "void",
    "comment" : "\n     * Called when a user or profile is created.\n     *\n     * <p>This callback is only applicable to device owners.\n     *\n     * @param context The running context as per {@link #onReceive}.\n     * @param intent The received intent as per {@link #onReceive}.\n     * @param addedUser The {@link UserHandle} of the user that has just been added.\n     ",
    "links" : [ "#onReceive", "android.os.UserHandle" ]
  }, {
    "name" : "public void onUserRemoved(@NonNull Context context, @NonNull Intent intent, @NonNull UserHandle removedUser)",
    "returnType" : "void",
    "comment" : "\n     * Called when a user or profile is removed.\n     *\n     * <p>This callback is only applicable to device owners.\n     *\n     * @param context The running context as per {@link #onReceive}.\n     * @param intent The received intent as per {@link #onReceive}.\n     * @param removedUser The {@link UserHandle} of the user that has just been removed.\n     ",
    "links" : [ "#onReceive", "android.os.UserHandle" ]
  }, {
    "name" : "public void onUserStarted(@NonNull Context context, @NonNull Intent intent, @NonNull UserHandle startedUser)",
    "returnType" : "void",
    "comment" : "\n     * Called when a user or profile is started.\n     *\n     * <p>This callback is only applicable to device owners.\n     *\n     * @param context The running context as per {@link #onReceive}.\n     * @param intent The received intent as per {@link #onReceive}.\n     * @param startedUser The {@link UserHandle} of the user that has just been started.\n     ",
    "links" : [ "#onReceive", "android.os.UserHandle" ]
  }, {
    "name" : "public void onUserStopped(@NonNull Context context, @NonNull Intent intent, @NonNull UserHandle stoppedUser)",
    "returnType" : "void",
    "comment" : "\n     * Called when a user or profile is stopped.\n     *\n     * <p>This callback is only applicable to device owners.\n     *\n     * @param context The running context as per {@link #onReceive}.\n     * @param intent The received intent as per {@link #onReceive}.\n     * @param stoppedUser The {@link UserHandle} of the user that has just been stopped.\n     ",
    "links" : [ "#onReceive", "android.os.UserHandle" ]
  }, {
    "name" : "public void onUserSwitched(@NonNull Context context, @NonNull Intent intent, @NonNull UserHandle switchedUser)",
    "returnType" : "void",
    "comment" : "\n     * Called when a user or profile is switched to.\n     *\n     * <p>This callback is only applicable to device owners.\n     *\n     * @param context The running context as per {@link #onReceive}.\n     * @param intent The received intent as per {@link #onReceive}.\n     * @param switchedUser The {@link UserHandle} of the user that has just been switched to.\n     ",
    "links" : [ "#onReceive", "android.os.UserHandle" ]
  }, {
    "name" : "public void onTransferOwnershipComplete(@NonNull Context context, @Nullable PersistableBundle bundle)",
    "returnType" : "void",
    "comment" : "\n     * Called on the newly assigned owner (either device owner or profile owner) when the ownership\n     * transfer has completed successfully.\n     *\n     * <p> The {@code bundle} parameter allows the original owner to pass data\n     * to the new one.\n     *\n     * @param context the running context as per {@link #onReceive}\n     * @param bundle the data to be passed to the new owner\n     ",
    "links" : [ "#onReceive" ]
  }, {
    "name" : "public void onTransferAffiliatedProfileOwnershipComplete(@NonNull Context context, @NonNull UserHandle user)",
    "returnType" : "void",
    "comment" : "\n     * Called on the device owner when the ownership of one of its affiliated profiles is\n     * transferred.\n     *\n     * <p>This can be used when transferring both device and profile ownership when using\n     * work profile on a fully managed device. The process would look like this:\n     * <ol>\n     * <li>Transfer profile ownership</li>\n     * <li>The device owner gets notified with this callback</li>\n     * <li>Transfer device ownership</li>\n     * <li>Both profile and device ownerships have been transferred</li>\n     * </ol>\n     *\n     * @param context the running context as per {@link #onReceive}\n     * @param user the {@link UserHandle} of the affiliated user\n     * @see DevicePolicyManager#transferOwnership(ComponentName, ComponentName, PersistableBundle)\n     ",
    "links" : [ "#onReceive", "android.os.UserHandle" ]
  }, {
    "name" : "public void onOperationSafetyStateChanged(@NonNull Context context, @OperationSafetyReason int reason, boolean isSafe)",
    "returnType" : "void",
    "comment" : "\n     * Called to notify the state of operations that can be unsafe to execute has changed.\n     *\n     * <p><b>Note:/b> notice that the operation safety state might change between the time this\n     * callback is received and the operation's method on {@link DevicePolicyManager} is called, so\n     * calls to the latter could still throw a {@link UnsafeStateException} even when this method\n     * is called with {@code isSafe} as {@code true}\n     *\n     * @param context the running context as per {@link #onReceive}\n     * @param reason the reason an operation could be unsafe.\n     * @param isSafe whether the operation is safe to be executed.\n     ",
    "links" : [ "#onReceive", "android.app.admin.UnsafeStateException", "android.app.admin.DevicePolicyManager" ]
  }, {
    "name" : "private void onOperationSafetyStateChanged(Context context, Intent intent)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public void onComplianceAcknowledgementRequired(@NonNull Context context, @NonNull Intent intent)",
    "returnType" : "void",
    "comment" : "\n     * Called to notify a profile owner of an organization-owned device that it needs to acknowledge\n     * device compliance to allow the user to turn the profile off if needed according to the\n     * maximum profile time off policy.\n     *\n     * Default implementation acknowledges compliance immediately. DPC may prefer to override this\n     * implementation to delay acknowledgement until a successful policy sync. Until compliance is\n     * acknowledged the user is still free to turn the profile off, but the timer won't be reset,\n     * so personal apps will be suspended sooner. This callback is delivered using a foreground\n     * broadcast and should be handled quickly.\n     *\n     * @param context the running context as per {@link #onReceive}\n     * @param intent The received intent as per {@link #onReceive}.\n     *\n     * @see DevicePolicyManager#acknowledgeDeviceCompliant()\n     * @see DevicePolicyManager#isComplianceAcknowledgementRequired()\n     * @see DevicePolicyManager#setManagedProfileMaximumTimeOff(ComponentName, long)\n     ",
    "links" : [ "#onReceive" ]
  }, {
    "name" : "private boolean hasRequiredExtra(Intent intent, String extra)",
    "returnType" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public void onReceive(@NonNull Context context, @NonNull Intent intent)",
    "returnType" : "void",
    "comment" : "\n     * Intercept standard device administrator broadcasts.  Implementations\n     * should not override this method; it is better to implement the\n     * convenience callbacks for each action.\n     ",
    "links" : [ ]
  } ],
  "methodNames" : [ "public DevicePolicyManager getManager(@NonNull Context context)", "public ComponentName getWho(@NonNull Context context)", "public void onEnabled(@NonNull Context context, @NonNull Intent intent)", "public CharSequence onDisableRequested(@NonNull Context context, @NonNull Intent intent)", "public void onDisabled(@NonNull Context context, @NonNull Intent intent)", "public void onPasswordChanged(@NonNull Context context, @NonNull Intent intent)", "public void onPasswordChanged(@NonNull Context context, @NonNull Intent intent, @NonNull UserHandle user)", "public void onPasswordFailed(@NonNull Context context, @NonNull Intent intent)", "public void onPasswordFailed(@NonNull Context context, @NonNull Intent intent, @NonNull UserHandle user)", "public void onPasswordSucceeded(@NonNull Context context, @NonNull Intent intent)", "public void onPasswordSucceeded(@NonNull Context context, @NonNull Intent intent, @NonNull UserHandle user)", "public void onPasswordExpiring(@NonNull Context context, @NonNull Intent intent)", "public void onPasswordExpiring(@NonNull Context context, @NonNull Intent intent, @NonNull UserHandle user)", "public void onProfileProvisioningComplete(@NonNull Context context, @NonNull Intent intent)", "public void onReadyForUserInitialization(@NonNull Context context, @NonNull Intent intent)", "public void onLockTaskModeEntering(@NonNull Context context, @NonNull Intent intent, @NonNull String pkg)", "public void onLockTaskModeExiting(@NonNull Context context, @NonNull Intent intent)", "public String onChoosePrivateKeyAlias(@NonNull Context context, @NonNull Intent intent, int uid, @Nullable Uri uri, @Nullable String alias)", "public void onSystemUpdatePending(@NonNull Context context, @NonNull Intent intent, long receivedTime)", "public void onBugreportSharingDeclined(@NonNull Context context, @NonNull Intent intent)", "public void onBugreportShared(@NonNull Context context, @NonNull Intent intent, @NonNull String bugreportHash)", "public void onBugreportFailed(@NonNull Context context, @NonNull Intent intent, @BugreportFailureCode int failureCode)", "public void onSecurityLogsAvailable(@NonNull Context context, @NonNull Intent intent)", "public void onNetworkLogsAvailable(@NonNull Context context, @NonNull Intent intent, long batchToken, @IntRange(from = 1) int networkLogsCount)", "public void onUserAdded(@NonNull Context context, @NonNull Intent intent, @NonNull UserHandle addedUser)", "public void onUserRemoved(@NonNull Context context, @NonNull Intent intent, @NonNull UserHandle removedUser)", "public void onUserStarted(@NonNull Context context, @NonNull Intent intent, @NonNull UserHandle startedUser)", "public void onUserStopped(@NonNull Context context, @NonNull Intent intent, @NonNull UserHandle stoppedUser)", "public void onUserSwitched(@NonNull Context context, @NonNull Intent intent, @NonNull UserHandle switchedUser)", "public void onTransferOwnershipComplete(@NonNull Context context, @Nullable PersistableBundle bundle)", "public void onTransferAffiliatedProfileOwnershipComplete(@NonNull Context context, @NonNull UserHandle user)", "public void onOperationSafetyStateChanged(@NonNull Context context, @OperationSafetyReason int reason, boolean isSafe)", "private void onOperationSafetyStateChanged(Context context, Intent intent)", "public void onComplianceAcknowledgementRequired(@NonNull Context context, @NonNull Intent intent)", "private boolean hasRequiredExtra(Intent intent, String extra)", "public void onReceive(@NonNull Context context, @NonNull Intent intent)" ],
  "variableNames" : [ "TAG", "LOCAL_LOGV", "ACTION_DEVICE_ADMIN_ENABLED", "ACTION_DEVICE_ADMIN_DISABLE_REQUESTED", "EXTRA_DISABLE_WARNING", "ACTION_DEVICE_ADMIN_DISABLED", "ACTION_PASSWORD_CHANGED", "ACTION_PASSWORD_FAILED", "ACTION_PASSWORD_SUCCEEDED", "ACTION_PASSWORD_EXPIRING", "ACTION_LOCK_TASK_ENTERING", "ACTION_LOCK_TASK_EXITING", "EXTRA_LOCK_TASK_PACKAGE", "ACTION_PROFILE_PROVISIONING_COMPLETE", "ACTION_BUGREPORT_SHARING_DECLINED", "ACTION_BUGREPORT_FAILED", "ACTION_BUGREPORT_SHARE", "ACTION_SECURITY_LOGS_AVAILABLE", "ACTION_NETWORK_LOGS_AVAILABLE", "EXTRA_NETWORK_LOGS_TOKEN", "EXTRA_NETWORK_LOGS_COUNT", "ACTION_USER_ADDED", "ACTION_USER_REMOVED", "ACTION_USER_STARTED", "ACTION_USER_STOPPED", "ACTION_USER_SWITCHED", "EXTRA_BUGREPORT_HASH", "EXTRA_BUGREPORT_FAILURE_REASON", "BUGREPORT_FAILURE_FAILED_COMPLETING", "BUGREPORT_FAILURE_FILE_NO_LONGER_AVAILABLE", "ACTION_CHOOSE_PRIVATE_KEY_ALIAS", "EXTRA_CHOOSE_PRIVATE_KEY_SENDER_UID", "EXTRA_CHOOSE_PRIVATE_KEY_URI", "EXTRA_CHOOSE_PRIVATE_KEY_ALIAS", "EXTRA_CHOOSE_PRIVATE_KEY_RESPONSE", "ACTION_NOTIFY_PENDING_SYSTEM_UPDATE", "EXTRA_SYSTEM_UPDATE_RECEIVED_TIME", "DEVICE_ADMIN_META_DATA", "ACTION_TRANSFER_OWNERSHIP_COMPLETE", "ACTION_AFFILIATED_PROFILE_TRANSFER_OWNERSHIP_COMPLETE", "EXTRA_TRANSFER_OWNERSHIP_ADMIN_EXTRAS_BUNDLE", "ACTION_OPERATION_SAFETY_STATE_CHANGED", "ACTION_COMPLIANCE_ACKNOWLEDGEMENT_REQUIRED", "EXTRA_OPERATION_SAFETY_REASON", "EXTRA_OPERATION_SAFETY_STATE", "mManager", "mWho" ]
}