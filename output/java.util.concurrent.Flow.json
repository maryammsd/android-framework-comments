{
  "filePath" : "/home/maryam/clearblue/files/android-source-35/java/util/concurrent/Flow.java",
  "packageName" : "java.util.concurrent",
  "className" : "Flow",
  "comment" : "\n * Interrelated interfaces and static methods for establishing\n * flow-controlled components in which {@link Publisher Publishers}\n * produce items consumed by one or more {@link Subscriber\n * Subscribers}, each managed by a {@link Subscription\n * Subscription}.\n *\n * <p>These interfaces correspond to the <a\n * href=\"http://www.reactive-streams.org/\"> reactive-streams</a>\n * specification.  They apply in both concurrent and distributed\n * asynchronous settings: All (seven) methods are defined in {@code\n * void} \"one-way\" message style. Communication relies on a simple form\n * of flow control (method {@link Subscription#request}) that can be\n * used to avoid resource management problems that may otherwise occur\n * in \"push\" based systems.\n *\n * <p><b>Examples.</b> A {@link Publisher} usually defines its own\n * {@link Subscription} implementation; constructing one in method\n * {@code subscribe} and issuing it to the calling {@link\n * Subscriber}. It publishes items to the subscriber asynchronously,\n * normally using an {@link Executor}.  For example, here is a very\n * simple publisher that only issues (when requested) a single {@code\n * TRUE} item to a single subscriber.  Because the subscriber receives\n * only a single item, this class does not use buffering and ordering\n * control required in most implementations.\n *\n * <pre> {@code\n * class OneShotPublisher implements Publisher<Boolean> {\n *   private final ExecutorService executor = ForkJoinPool.commonPool(); // daemon-based\n *   private boolean subscribed; // true after first subscribe\n *   public synchronized void subscribe(Subscriber<? super Boolean> subscriber) {\n *     if (subscribed)\n *       subscriber.onError(new IllegalStateException()); // only one allowed\n *     else {\n *       subscribed = true;\n *       subscriber.onSubscribe(new OneShotSubscription(subscriber, executor));\n *     }\n *   }\n *   static class OneShotSubscription implements Subscription {\n *     private final Subscriber<? super Boolean> subscriber;\n *     private final ExecutorService executor;\n *     private Future<?> future; // to allow cancellation\n *     private boolean completed;\n *     OneShotSubscription(Subscriber<? super Boolean> subscriber,\n *                         ExecutorService executor) {\n *       this.subscriber = subscriber;\n *       this.executor = executor;\n *     }\n *     public synchronized void request(long n) {\n *       if (!completed) {\n *         completed = true;\n *         if (n <= 0) {\n *           IllegalArgumentException ex = new IllegalArgumentException();\n *           executor.execute(() -> subscriber.onError(ex));\n *         } else {\n *           future = executor.submit(() -> {\n *             subscriber.onNext(Boolean.TRUE);\n *             subscriber.onComplete();\n *           });\n *         }\n *       }\n *     }\n *     public synchronized void cancel() {\n *       completed = true;\n *       if (future != null) future.cancel(false);\n *     }\n *   }\n * }}</pre>\n *\n * <p>A {@link Subscriber} arranges that items be requested and\n * processed.  Items (invocations of {@link Subscriber#onNext}) are\n * not issued unless requested, but multiple items may be requested.\n * Many Subscriber implementations can arrange this in the style of\n * the following example, where a buffer size of 1 single-steps, and\n * larger sizes usually allow for more efficient overlapped processing\n * with less communication; for example with a value of 64, this keeps\n * total outstanding requests between 32 and 64.\n * Because Subscriber method invocations for a given {@link\n * Subscription} are strictly ordered, there is no need for these\n * methods to use locks or volatiles unless a Subscriber maintains\n * multiple Subscriptions (in which case it is better to instead\n * define multiple Subscribers, each with its own Subscription).\n *\n * <pre> {@code\n * class SampleSubscriber<T> implements Subscriber<T> {\n *   final Consumer<? super T> consumer;\n *   Subscription subscription;\n *   final long bufferSize;\n *   long count;\n *   SampleSubscriber(long bufferSize, Consumer<? super T> consumer) {\n *     this.bufferSize = bufferSize;\n *     this.consumer = consumer;\n *   }\n *   public void onSubscribe(Subscription subscription) {\n *     long initialRequestSize = bufferSize;\n *     count = bufferSize - bufferSize / 2; // re-request when half consumed\n *     (this.subscription = subscription).request(initialRequestSize);\n *   }\n *   public void onNext(T item) {\n *     if (--count <= 0)\n *       subscription.request(count = bufferSize - bufferSize / 2);\n *     consumer.accept(item);\n *   }\n *   public void onError(Throwable ex) { ex.printStackTrace(); }\n *   public void onComplete() {}\n * }}</pre>\n *\n * <p>The default value of {@link #defaultBufferSize} may provide a\n * useful starting point for choosing request sizes and capacities in\n * Flow components based on expected rates, resources, and usages.\n * Or, when flow control is never needed, a subscriber may initially\n * request an effectively unbounded number of items, as in:\n *\n * <pre> {@code\n * class UnboundedSubscriber<T> implements Subscriber<T> {\n *   public void onSubscribe(Subscription subscription) {\n *     subscription.request(Long.MAX_VALUE); // effectively unbounded\n *   }\n *   public void onNext(T item) { use(item); }\n *   public void onError(Throwable ex) { ex.printStackTrace(); }\n *   public void onComplete() {}\n *   void use(T item) { ... }\n * }}</pre>\n *\n * @author Doug Lea\n * @since 9\n ",
  "links" : [ "#onNext", "SubscriberSubscribers", "#request", "Subscriber", "java.util.concurrent.Executor", "SubscriptionSubscription", "Publisher", "#defaultBufferSize", "Subscription" ],
  "variables" : [ {
    "name" : "DEFAULT_BUFFER_SIZE",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  } ],
  "methods" : [ {
    "name" : "public static int defaultBufferSize()",
    "returnType" : "int",
    "comment" : "\n     * Returns a default value for Publisher or Subscriber buffering,\n     * that may be used in the absence of other constraints.\n     *\n     * @implNote\n     * The current value returned is 256.\n     *\n     * @return the buffer size value\n     ",
    "links" : [ ]
  } ],
  "methodNames" : [ "public static int defaultBufferSize()" ],
  "variableNames" : [ "DEFAULT_BUFFER_SIZE" ]
}