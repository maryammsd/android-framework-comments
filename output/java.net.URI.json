{
  "filePath" : "/home/maryam/clearblue/files/android-source-35/java/net/URI.java",
  "packageName" : "java.net",
  "className" : "URI",
  "comment" : "",
  "links" : [ ],
  "variables" : [ {
    "name" : "serialVersionUID",
    "type" : "long",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "scheme",
    "type" : "String",
    "comment" : " null ==> relative URI",
    "links" : [ ]
  }, {
    "name" : "fragment",
    "type" : "String",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "authority",
    "type" : "String",
    "comment" : " Registry or server",
    "links" : [ ]
  }, {
    "name" : "userInfo",
    "type" : "String",
    "comment" : " Server-based authority: [<userInfo>@]<host>[:<port>]",
    "links" : [ ]
  }, {
    "name" : "host",
    "type" : "String",
    "comment" : " null ==> registry-based",
    "links" : [ ]
  }, {
    "name" : "port",
    "type" : "int",
    "comment" : " -1 ==> undefined",
    "links" : [ ]
  }, {
    "name" : "path",
    "type" : "String",
    "comment" : " null ==> opaque",
    "links" : [ ]
  }, {
    "name" : "query",
    "type" : "String",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "schemeSpecificPart",
    "type" : "String",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "hash",
    "type" : "int",
    "comment" : " Zero ==> undefined",
    "links" : [ ]
  }, {
    "name" : "decodedUserInfo",
    "type" : "String",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "decodedAuthority",
    "type" : "String",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "decodedPath",
    "type" : "String",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "decodedQuery",
    "type" : "String",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "decodedFragment",
    "type" : "String",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "decodedSchemeSpecificPart",
    "type" : "String",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "string",
    "type" : "String",
    "comment" : " The only serializable field",
    "links" : [ ]
  }, {
    "name" : "L_DIGIT",
    "type" : "long",
    "comment" : "            \"8\" | \"9\"",
    "links" : [ ]
  }, {
    "name" : "H_DIGIT",
    "type" : "long",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "L_UPALPHA",
    "type" : "long",
    "comment" : "            \"S\" | \"T\" | \"U\" | \"V\" | \"W\" | \"X\" | \"Y\" | \"Z\"",
    "links" : [ ]
  }, {
    "name" : "H_UPALPHA",
    "type" : "long",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "L_LOWALPHA",
    "type" : "long",
    "comment" : "            \"s\" | \"t\" | \"u\" | \"v\" | \"w\" | \"x\" | \"y\" | \"z\"",
    "links" : [ ]
  }, {
    "name" : "H_LOWALPHA",
    "type" : "long",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "L_ALPHA",
    "type" : "long",
    "comment" : " alpha         = lowalpha | upalpha",
    "links" : [ ]
  }, {
    "name" : "H_ALPHA",
    "type" : "long",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "L_ALPHANUM",
    "type" : "long",
    "comment" : " alphanum      = alpha | digit",
    "links" : [ ]
  }, {
    "name" : "H_ALPHANUM",
    "type" : "long",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "L_HEX",
    "type" : "long",
    "comment" : "                         \"a\" | \"b\" | \"c\" | \"d\" | \"e\" | \"f\"",
    "links" : [ ]
  }, {
    "name" : "H_HEX",
    "type" : "long",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "L_MARK",
    "type" : "long",
    "comment" : "                 \"(\" | \")\"",
    "links" : [ ]
  }, {
    "name" : "H_MARK",
    "type" : "long",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "L_UNRESERVED",
    "type" : "long",
    "comment" : " unreserved    = alphanum | mark",
    "links" : [ ]
  }, {
    "name" : "H_UNRESERVED",
    "type" : "long",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "L_RESERVED",
    "type" : "long",
    "comment" : " Added per RFC2732: \"[\", \"]\"",
    "links" : [ ]
  }, {
    "name" : "H_RESERVED",
    "type" : "long",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "L_ESCAPED",
    "type" : "long",
    "comment" : " characters are allowed; this is handled by the scanEscape method below.",
    "links" : [ ]
  }, {
    "name" : "H_ESCAPED",
    "type" : "long",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "L_URIC",
    "type" : "long",
    "comment" : " uric          = reserved | unreserved | escaped",
    "links" : [ ]
  }, {
    "name" : "H_URIC",
    "type" : "long",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "L_PCHAR",
    "type" : "long",
    "comment" : "                 \":\" | \"@\" | \"&\" | \"=\" | \"+\" | \"$\" | \",\"",
    "links" : [ ]
  }, {
    "name" : "H_PCHAR",
    "type" : "long",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "L_PATH",
    "type" : "long",
    "comment" : " All valid path characters",
    "links" : [ ]
  }, {
    "name" : "H_PATH",
    "type" : "long",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "L_DASH",
    "type" : "long",
    "comment" : " Dash, for use in domainlabel and toplabel",
    "links" : [ ]
  }, {
    "name" : "H_DASH",
    "type" : "long",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "L_UNDERSCORE",
    "type" : "long",
    "comment" : " UNDERSCORE, for use in domainlabel and toplabel",
    "links" : [ ]
  }, {
    "name" : "H_UNDERSCORE",
    "type" : "long",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "L_DOT",
    "type" : "long",
    "comment" : " Dot, for use in hostnames",
    "links" : [ ]
  }, {
    "name" : "H_DOT",
    "type" : "long",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "L_USERINFO",
    "type" : "long",
    "comment" : "                    \";\" | \":\" | \"&\" | \"=\" | \"+\" | \"$\" | \",\" )",
    "links" : [ ]
  }, {
    "name" : "H_USERINFO",
    "type" : "long",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "L_REG_NAME",
    "type" : "long",
    "comment" : "                     \";\" | \":\" | \"@\" | \"&\" | \"=\" | \"+\" )",
    "links" : [ ]
  }, {
    "name" : "H_REG_NAME",
    "type" : "long",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "L_SERVER",
    "type" : "long",
    "comment" : " All valid characters for server-based authorities",
    "links" : [ ]
  }, {
    "name" : "H_SERVER",
    "type" : "long",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "L_SERVER_PERCENT",
    "type" : "long",
    "comment" : " In this case, a % does not signify an escape sequence",
    "links" : [ ]
  }, {
    "name" : "H_SERVER_PERCENT",
    "type" : "long",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "L_LEFT_BRACKET",
    "type" : "long",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "H_LEFT_BRACKET",
    "type" : "long",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "L_SCHEME",
    "type" : "long",
    "comment" : " scheme        = alpha *( alpha | digit | \"+\" | \"-\" | \".\" )",
    "links" : [ ]
  }, {
    "name" : "H_SCHEME",
    "type" : "long",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "L_URIC_NO_SLASH",
    "type" : "long",
    "comment" : "                 \"&\" | \"=\" | \"+\" | \"$\" | \",\"",
    "links" : [ ]
  }, {
    "name" : "H_URIC_NO_SLASH",
    "type" : "long",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "L_SCOPE_ID",
    "type" : "long",
    "comment" : " scope_id = alpha | digit | \"_\" | \".\"",
    "links" : [ ]
  }, {
    "name" : "H_SCOPE_ID",
    "type" : "long",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "hexDigits",
    "type" : "char[]",
    "comment" : "",
    "links" : [ ]
  } ],
  "methods" : [ {
    "name" : "public static URI create(String str)",
    "returnType" : "URI",
    "comment" : "\n     * Creates a URI by parsing the given string.\n     *\n     * <p> This convenience factory method works as if by invoking the {@link\n     * #URI(String)} constructor; any {@link URISyntaxException} thrown by the\n     * constructor is caught and wrapped in a new {@link\n     * IllegalArgumentException} object, which is then thrown.\n     *\n     * <p> This method is provided for use in situations where it is known that\n     * the given string is a legal URI, for example for URI constants declared\n     * within in a program, and so it would be considered a programming error\n     * for the string not to parse as such.  The constructors, which throw\n     * {@link URISyntaxException} directly, should be used situations where a\n     * URI is being constructed from user input or from some other source that\n     * may be prone to errors.  </p>\n     *\n     * @param  str   The string to be parsed into a URI\n     * @return The new URI\n     *\n     * @throws  NullPointerException\n     *          If {@code str} is {@code null}\n     *\n     * @throws  IllegalArgumentException\n     *          If the given string violates RFC&nbsp;2396\n     ",
    "links" : [ "java.net.URISyntaxException", "#URI(String)", "IllegalArgumentException" ]
  }, {
    "name" : "public URI parseServerAuthority() throws URISyntaxException",
    "returnType" : "URI",
    "comment" : "\n     * Attempts to parse this URI's authority component, if defined, into\n     * user-information, host, and port components.\n     *\n     * <p> If this URI's authority component has already been recognized as\n     * being server-based then it will already have been parsed into\n     * user-information, host, and port components.  In this case, or if this\n     * URI has no authority component, this method simply returns this URI.\n     *\n     * <p> Otherwise this method attempts once more to parse the authority\n     * component into user-information, host, and port components, and throws\n     * an exception describing why the authority component could not be parsed\n     * in that way.\n     *\n     * <p> This method is provided because the generic URI syntax specified in\n     * <a href=\"http://www.ietf.org/rfc/rfc2396.txt\">RFC&nbsp;2396</a>\n     * cannot always distinguish a malformed server-based authority from a\n     * legitimate registry-based authority.  It must therefore treat some\n     * instances of the former as instances of the latter.  The authority\n     * component in the URI string {@code \"//foo:bar\"}, for example, is not a\n     * legal server-based authority but it is legal as a registry-based\n     * authority.\n     *\n     * <p> In many common situations, for example when working URIs that are\n     * known to be either URNs or URLs, the hierarchical URIs being used will\n     * always be server-based.  They therefore must either be parsed as such or\n     * treated as an error.  In these cases a statement such as\n     *\n     * <blockquote>\n     * {@code URI }<i>u</i>{@code  = new URI(str).parseServerAuthority();}\n     * </blockquote>\n     *\n     * <p> can be used to ensure that <i>u</i> always refers to a URI that, if\n     * it has an authority component, has a server-based authority with proper\n     * user-information, host, and port components.  Invoking this method also\n     * ensures that if the authority could not be parsed in that way then an\n     * appropriate diagnostic message can be issued based upon the exception\n     * that is thrown. </p>\n     *\n     * @return  A URI whose authority field has been parsed\n     *          as a server-based authority\n     *\n     * @throws  URISyntaxException\n     *          If the authority component of this URI is defined\n     *          but cannot be parsed as a server-based authority\n     *          according to RFC&nbsp;2396\n     ",
    "links" : [ ]
  }, {
    "name" : "public URI normalize()",
    "returnType" : "URI",
    "comment" : "\n     * Normalizes this URI's path.\n     *\n     * <p> If this URI is opaque, or if its path is already in normal form,\n     * then this URI is returned.  Otherwise a new URI is constructed that is\n     * identical to this URI except that its path is computed by normalizing\n     * this URI's path in a manner consistent with <a\n     * href=\"http://www.ietf.org/rfc/rfc2396.txt\">RFC&nbsp;2396</a>,\n     * section&nbsp;5.2, step&nbsp;6, sub-steps&nbsp;c through&nbsp;f; that is:\n     * </p>\n     *\n     * <ol>\n     *\n     *   <li><p> All {@code \".\"} segments are removed. </p></li>\n     *\n     *   <li><p> If a {@code \"..\"} segment is preceded by a non-{@code \"..\"}\n     *   segment then both of these segments are removed.  This step is\n     *   repeated until it is no longer applicable. </p></li>\n     *\n     *   <li><p> If the path is relative, and if its first segment contains a\n     *   colon character ({@code ':'}), then a {@code \".\"} segment is\n     *   prepended.  This prevents a relative URI with a path such as\n     *   {@code \"a:b/c/d\"} from later being re-parsed as an opaque URI with a\n     *   scheme of {@code \"a\"} and a scheme-specific part of {@code \"b/c/d\"}.\n     *   <b><i>(Deviation from RFC&nbsp;2396)</i></b> </p></li>\n     *\n     * </ol>\n     *\n     * <p> A normalized path will begin with one or more {@code \"..\"} segments\n     * if there were insufficient non-{@code \"..\"} segments preceding them to\n     * allow their removal.  A normalized path will begin with a {@code \".\"}\n     * segment if one was inserted by step 3 above.  Otherwise, a normalized\n     * path will not contain any {@code \".\"} or {@code \"..\"} segments. </p>\n     *\n     * @return  A URI equivalent to this URI,\n     *          but whose path is in normal form\n     ",
    "links" : [ ]
  }, {
    "name" : "public URI resolve(URI uri)",
    "returnType" : "URI",
    "comment" : "\n     * Resolves the given URI against this URI.\n     *\n     * <p> If the given URI is already absolute, or if this URI is opaque, then\n     * the given URI is returned.\n     *\n     * <p><a name=\"resolve-frag\"></a> If the given URI's fragment component is\n     * defined, its path component is empty, and its scheme, authority, and\n     * query components are undefined, then a URI with the given fragment but\n     * with all other components equal to those of this URI is returned.  This\n     * allows a URI representing a standalone fragment reference, such as\n     * {@code \"#foo\"}, to be usefully resolved against a base URI.\n     *\n     * <p> Otherwise this method constructs a new hierarchical URI in a manner\n     * consistent with <a\n     * href=\"http://www.ietf.org/rfc/rfc2396.txt\">RFC&nbsp;2396</a>,\n     * section&nbsp;5.2; that is: </p>\n     *\n     * <ol>\n     *\n     *   <li><p> A new URI is constructed with this URI's scheme and the given\n     *   URI's query and fragment components. </p></li>\n     *\n     *   <li><p> If the given URI has an authority component then the new URI's\n     *   authority and path are taken from the given URI. </p></li>\n     *\n     *   <li><p> Otherwise the new URI's authority component is copied from\n     *   this URI, and its path is computed as follows: </p>\n     *\n     *   <ol>\n     *\n     *     <li><p> If the given URI's path is absolute then the new URI's path\n     *     is taken from the given URI. </p></li>\n     *\n     *     <li><p> Otherwise the given URI's path is relative, and so the new\n     *     URI's path is computed by resolving the path of the given URI\n     *     against the path of this URI.  This is done by concatenating all but\n     *     the last segment of this URI's path, if any, with the given URI's\n     *     path and then normalizing the result as if by invoking the {@link\n     *     #normalize() normalize} method. </p></li>\n     *\n     *   </ol></li>\n     *\n     * </ol>\n     *\n     * <p> The result of this method is absolute if, and only if, either this\n     * URI is absolute or the given URI is absolute.  </p>\n     *\n     * @param  uri  The URI to be resolved against this URI\n     * @return The resulting URI\n     *\n     * @throws  NullPointerException\n     *          If {@code uri} is {@code null}\n     ",
    "links" : [ "#normalize()" ]
  }, {
    "name" : "public URI resolve(String str)",
    "returnType" : "URI",
    "comment" : "\n     * Constructs a new URI by parsing the given string and then resolving it\n     * against this URI.\n     *\n     * <p> This convenience method works as if invoking it were equivalent to\n     * evaluating the expression {@link #resolve(java.net.URI)\n     * resolve}{@code (URI.}{@link #create(String) create}{@code (str))}. </p>\n     *\n     * @param  str   The string to be parsed into a URI\n     * @return The resulting URI\n     *\n     * @throws  NullPointerException\n     *          If {@code str} is {@code null}\n     *\n     * @throws  IllegalArgumentException\n     *          If the given string violates RFC&nbsp;2396\n     ",
    "links" : [ "#resolve(java.net.URI)", "#create(String)" ]
  }, {
    "name" : "public URI relativize(URI uri)",
    "returnType" : "URI",
    "comment" : "\n     * Relativizes the given URI against this URI.\n     *\n     * <p> The relativization of the given URI against this URI is computed as\n     * follows: </p>\n     *\n     * <ol>\n     *\n     *   <li><p> If either this URI or the given URI are opaque, or if the\n     *   scheme and authority components of the two URIs are not identical, or\n     *   if the path of this URI is not a prefix of the path of the given URI,\n     *   then the given URI is returned. </p></li>\n     *\n     *   <li><p> Otherwise a new relative hierarchical URI is constructed with\n     *   query and fragment components taken from the given URI and with a path\n     *   component computed by removing this URI's path from the beginning of\n     *   the given URI's path. </p></li>\n     *\n     * </ol>\n     *\n     * @param  uri  The URI to be relativized against this URI\n     * @return The resulting URI\n     *\n     * @throws  NullPointerException\n     *          If {@code uri} is {@code null}\n     ",
    "links" : [ ]
  }, {
    "name" : "public URL toURL() throws MalformedURLException",
    "returnType" : "URL",
    "comment" : "\n     * Constructs a URL from this URI.\n     *\n     * <p> This convenience method works as if invoking it were equivalent to\n     * evaluating the expression {@code new URL(this.toString())} after\n     * first checking that this URI is absolute. </p>\n     *\n     * @return  A URL constructed from this URI\n     *\n     * @throws  IllegalArgumentException\n     *          If this URL is not absolute\n     *\n     * @throws  MalformedURLException\n     *          If a protocol handler for the URL could not be found,\n     *          or if some other error occurred while constructing the URL\n     ",
    "links" : [ ]
  }, {
    "name" : "public String getScheme()",
    "returnType" : "String",
    "comment" : "\n     * Returns the scheme component of this URI.\n     *\n     * <p> The scheme component of a URI, if defined, only contains characters\n     * in the <i>alphanum</i> category and in the string {@code \"-.+\"}.  A\n     * scheme always starts with an <i>alpha</i> character. <p>\n     *\n     * The scheme component of a URI cannot contain escaped octets, hence this\n     * method does not perform any decoding.\n     *\n     * @return  The scheme component of this URI,\n     *          or {@code null} if the scheme is undefined\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean isAbsolute()",
    "returnType" : "boolean",
    "comment" : "\n     * Tells whether or not this URI is absolute.\n     *\n     * <p> A URI is absolute if, and only if, it has a scheme component. </p>\n     *\n     * @return  {@code true} if, and only if, this URI is absolute\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean isOpaque()",
    "returnType" : "boolean",
    "comment" : "\n     * Tells whether or not this URI is opaque.\n     *\n     * <p> A URI is opaque if, and only if, it is absolute and its\n     * scheme-specific part does not begin with a slash character ('/').\n     * An opaque URI has a scheme, a scheme-specific part, and possibly\n     * a fragment; all other components are undefined. </p>\n     *\n     * @return  {@code true} if, and only if, this URI is opaque\n     ",
    "links" : [ ]
  }, {
    "name" : "public String getRawSchemeSpecificPart()",
    "returnType" : "String",
    "comment" : "\n     * Returns the raw scheme-specific part of this URI.  The scheme-specific\n     * part is never undefined, though it may be empty.\n     *\n     * <p> The scheme-specific part of a URI only contains legal URI\n     * characters. </p>\n     *\n     * @return  The raw scheme-specific part of this URI\n     *          (never {@code null})\n     ",
    "links" : [ ]
  }, {
    "name" : "public String getSchemeSpecificPart()",
    "returnType" : "String",
    "comment" : "\n     * Returns the decoded scheme-specific part of this URI.\n     *\n     * <p> The string returned by this method is equal to that returned by the\n     * {@link #getRawSchemeSpecificPart() getRawSchemeSpecificPart} method\n     * except that all sequences of escaped octets are <a\n     * href=\"#decode\">decoded</a>.  </p>\n     *\n     * @return  The decoded scheme-specific part of this URI\n     *          (never {@code null})\n     ",
    "links" : [ "#getRawSchemeSpecificPart()" ]
  }, {
    "name" : "public String getRawAuthority()",
    "returnType" : "String",
    "comment" : "\n     * Returns the raw authority component of this URI.\n     *\n     * <p> The authority component of a URI, if defined, only contains the\n     * commercial-at character ({@code '@'}) and characters in the\n     * <i>unreserved</i>, <i>punct</i>, <i>escaped</i>, and <i>other</i>\n     * categories.  If the authority is server-based then it is further\n     * constrained to have valid user-information, host, and port\n     * components. </p>\n     *\n     * @return  The raw authority component of this URI,\n     *          or {@code null} if the authority is undefined\n     ",
    "links" : [ ]
  }, {
    "name" : "public String getAuthority()",
    "returnType" : "String",
    "comment" : "\n     * Returns the decoded authority component of this URI.\n     *\n     * <p> The string returned by this method is equal to that returned by the\n     * {@link #getRawAuthority() getRawAuthority} method except that all\n     * sequences of escaped octets are <a href=\"#decode\">decoded</a>.  </p>\n     *\n     * @return  The decoded authority component of this URI,\n     *          or {@code null} if the authority is undefined\n     ",
    "links" : [ "#getRawAuthority()" ]
  }, {
    "name" : "public String getRawUserInfo()",
    "returnType" : "String",
    "comment" : "\n     * Returns the raw user-information component of this URI.\n     *\n     * <p> The user-information component of a URI, if defined, only contains\n     * characters in the <i>unreserved</i>, <i>punct</i>, <i>escaped</i>, and\n     * <i>other</i> categories. </p>\n     *\n     * @return  The raw user-information component of this URI,\n     *          or {@code null} if the user information is undefined\n     ",
    "links" : [ ]
  }, {
    "name" : "public String getUserInfo()",
    "returnType" : "String",
    "comment" : "\n     * Returns the decoded user-information component of this URI.\n     *\n     * <p> The string returned by this method is equal to that returned by the\n     * {@link #getRawUserInfo() getRawUserInfo} method except that all\n     * sequences of escaped octets are <a href=\"#decode\">decoded</a>.  </p>\n     *\n     * @return  The decoded user-information component of this URI,\n     *          or {@code null} if the user information is undefined\n     ",
    "links" : [ "#getRawUserInfo()" ]
  }, {
    "name" : "public String getHost()",
    "returnType" : "String",
    "comment" : "\n     * Returns the host component of this URI.\n     *\n     * <p> The host component of a URI, if defined, will have one of the\n     * following forms: </p>\n     *\n     * <ul>\n     *\n     *   <li><p> A domain name consisting of one or more <i>labels</i>\n     *   separated by period characters ({@code '.'}), optionally followed by\n     *   a period character.  Each label consists of <i>alphanum</i> characters\n     *   as well as hyphen characters ({@code '-'}), though hyphens never\n     *   occur as the first or last characters in a label. The rightmost\n     *   label of a domain name consisting of two or more labels, begins\n     *   with an <i>alpha</i> character. </li>\n     *\n     *   <li><p> A dotted-quad IPv4 address of the form\n     *   <i>digit</i>{@code +.}<i>digit</i>{@code +.}<i>digit</i>{@code +.}<i>digit</i>{@code +},\n     *   where no <i>digit</i> sequence is longer than three characters and no\n     *   sequence has a value larger than 255. </p></li>\n     *\n     *   <li><p> An IPv6 address enclosed in square brackets ({@code '['} and\n     *   {@code ']'}) and consisting of hexadecimal digits, colon characters\n     *   ({@code ':'}), and possibly an embedded IPv4 address.  The full\n     *   syntax of IPv6 addresses is specified in <a\n     *   href=\"http://www.ietf.org/rfc/rfc2373.txt\"><i>RFC&nbsp;2373: IPv6\n     *   Addressing Architecture</i></a>.  </p></li>\n     *\n     * </ul>\n     *\n     * The host component of a URI cannot contain escaped octets, hence this\n     * method does not perform any decoding.\n     *\n     * @return  The host component of this URI,\n     *          or {@code null} if the host is undefined\n     ",
    "links" : [ ]
  }, {
    "name" : "public int getPort()",
    "returnType" : "int",
    "comment" : "\n     * Returns the port number of this URI.\n     *\n     * <p> The port component of a URI, if defined, is a non-negative\n     * integer. </p>\n     *\n     * @return  The port component of this URI,\n     *          or {@code -1} if the port is undefined\n     ",
    "links" : [ ]
  }, {
    "name" : "public String getRawPath()",
    "returnType" : "String",
    "comment" : "\n     * Returns the raw path component of this URI.\n     *\n     * <p> The path component of a URI, if defined, only contains the slash\n     * character ({@code '/'}), the commercial-at character ({@code '@'}),\n     * and characters in the <i>unreserved</i>, <i>punct</i>, <i>escaped</i>,\n     * and <i>other</i> categories. </p>\n     *\n     * @return  The path component of this URI,\n     *          or {@code null} if the path is undefined\n     ",
    "links" : [ ]
  }, {
    "name" : "public String getPath()",
    "returnType" : "String",
    "comment" : "\n     * Returns the decoded path component of this URI.\n     *\n     * <p> The string returned by this method is equal to that returned by the\n     * {@link #getRawPath() getRawPath} method except that all sequences of\n     * escaped octets are <a href=\"#decode\">decoded</a>.  </p>\n     *\n     * @return  The decoded path component of this URI,\n     *          or {@code null} if the path is undefined\n     ",
    "links" : [ "#getRawPath()" ]
  }, {
    "name" : "public String getRawQuery()",
    "returnType" : "String",
    "comment" : "\n     * Returns the raw query component of this URI.\n     *\n     * <p> The query component of a URI, if defined, only contains legal URI\n     * characters. </p>\n     *\n     * @return  The raw query component of this URI,\n     *          or {@code null} if the query is undefined\n     ",
    "links" : [ ]
  }, {
    "name" : "public String getQuery()",
    "returnType" : "String",
    "comment" : "\n     * Returns the decoded query component of this URI.\n     *\n     * <p> The string returned by this method is equal to that returned by the\n     * {@link #getRawQuery() getRawQuery} method except that all sequences of\n     * escaped octets are <a href=\"#decode\">decoded</a>.  </p>\n     *\n     * @return  The decoded query component of this URI,\n     *          or {@code null} if the query is undefined\n     ",
    "links" : [ "#getRawQuery()" ]
  }, {
    "name" : "public String getRawFragment()",
    "returnType" : "String",
    "comment" : "\n     * Returns the raw fragment component of this URI.\n     *\n     * <p> The fragment component of a URI, if defined, only contains legal URI\n     * characters. </p>\n     *\n     * @return  The raw fragment component of this URI,\n     *          or {@code null} if the fragment is undefined\n     ",
    "links" : [ ]
  }, {
    "name" : "public String getFragment()",
    "returnType" : "String",
    "comment" : "\n     * Returns the decoded fragment component of this URI.\n     *\n     * <p> The string returned by this method is equal to that returned by the\n     * {@link #getRawFragment() getRawFragment} method except that all\n     * sequences of escaped octets are <a href=\"#decode\">decoded</a>.  </p>\n     *\n     * @return  The decoded fragment component of this URI,\n     *          or {@code null} if the fragment is undefined\n     ",
    "links" : [ "#getRawFragment()" ]
  }, {
    "name" : "public boolean equals(Object ob)",
    "returnType" : "boolean",
    "comment" : "\n     * Tests this URI for equality with another object.\n     *\n     * <p> If the given object is not a URI then this method immediately\n     * returns {@code false}.\n     *\n     * <p> For two URIs to be considered equal requires that either both are\n     * opaque or both are hierarchical.  Their schemes must either both be\n     * undefined or else be equal without regard to case. Their fragments\n     * must either both be undefined or else be equal.\n     *\n     * <p> For two opaque URIs to be considered equal, their scheme-specific\n     * parts must be equal.\n     *\n     * <p> For two hierarchical URIs to be considered equal, their paths must\n     * be equal and their queries must either both be undefined or else be\n     * equal.  Their authorities must either both be undefined, or both be\n     * registry-based, or both be server-based.  If their authorities are\n     * defined and are registry-based, then they must be equal.  If their\n     * authorities are defined and are server-based, then their hosts must be\n     * equal without regard to case, their port numbers must be equal, and\n     * their user-information components must be equal.\n     *\n     * <p> When testing the user-information, path, query, fragment, authority,\n     * or scheme-specific parts of two URIs for equality, the raw forms rather\n     * than the encoded forms of these components are compared and the\n     * hexadecimal digits of escaped octets are compared without regard to\n     * case.\n     *\n     * <p> This method satisfies the general contract of the {@link\n     * java.lang.Object#equals(Object) Object.equals} method. </p>\n     *\n     * @param   ob   The object to which this object is to be compared\n     *\n     * @return  {@code true} if, and only if, the given object is a URI that\n     *          is identical to this URI\n     ",
    "links" : [ "java.lang.Object#equals(Object)" ]
  }, {
    "name" : "public int hashCode()",
    "returnType" : "int",
    "comment" : "\n     * Returns a hash-code value for this URI.  The hash code is based upon all\n     * of the URI's components, and satisfies the general contract of the\n     * {@link java.lang.Object#hashCode() Object.hashCode} method.\n     *\n     * @return  A hash-code value for this URI\n     ",
    "links" : [ "java.lang.Object#hashCode()" ]
  }, {
    "name" : "public int compareTo(URI that)",
    "returnType" : "int",
    "comment" : "\n     * Compares this URI to another object, which must be a URI.\n     *\n     * <p> When comparing corresponding components of two URIs, if one\n     * component is undefined but the other is defined then the first is\n     * considered to be less than the second.  Unless otherwise noted, string\n     * components are ordered according to their natural, case-sensitive\n     * ordering as defined by the {@link java.lang.String#compareTo(Object)\n     * String.compareTo} method.  String components that are subject to\n     * encoding are compared by comparing their raw forms rather than their\n     * encoded forms.\n     *\n     * <p> The ordering of URIs is defined as follows: </p>\n     *\n     * <ul>\n     *\n     *   <li><p> Two URIs with different schemes are ordered according the\n     *   ordering of their schemes, without regard to case. </p></li>\n     *\n     *   <li><p> A hierarchical URI is considered to be less than an opaque URI\n     *   with an identical scheme. </p></li>\n     *\n     *   <li><p> Two opaque URIs with identical schemes are ordered according\n     *   to the ordering of their scheme-specific parts. </p></li>\n     *\n     *   <li><p> Two opaque URIs with identical schemes and scheme-specific\n     *   parts are ordered according to the ordering of their\n     *   fragments. </p></li>\n     *\n     *   <li><p> Two hierarchical URIs with identical schemes are ordered\n     *   according to the ordering of their authority components: </p>\n     *\n     *   <ul>\n     *\n     *     <li><p> If both authority components are server-based then the URIs\n     *     are ordered according to their user-information components; if these\n     *     components are identical then the URIs are ordered according to the\n     *     ordering of their hosts, without regard to case; if the hosts are\n     *     identical then the URIs are ordered according to the ordering of\n     *     their ports. </p></li>\n     *\n     *     <li><p> If one or both authority components are registry-based then\n     *     the URIs are ordered according to the ordering of their authority\n     *     components. </p></li>\n     *\n     *   </ul></li>\n     *\n     *   <li><p> Finally, two hierarchical URIs with identical schemes and\n     *   authority components are ordered according to the ordering of their\n     *   paths; if their paths are identical then they are ordered according to\n     *   the ordering of their queries; if the queries are identical then they\n     *   are ordered according to the order of their fragments. </p></li>\n     *\n     * </ul>\n     *\n     * <p> This method satisfies the general contract of the {@link\n     * java.lang.Comparable#compareTo(Object) Comparable.compareTo}\n     * method. </p>\n     *\n     * @param   that\n     *          The object to which this URI is to be compared\n     *\n     * @return  A negative integer, zero, or a positive integer as this URI is\n     *          less than, equal to, or greater than the given URI\n     *\n     * @throws  ClassCastException\n     *          If the given object is not a URI\n     ",
    "links" : [ "java.lang.String#compareTo(Object)", "java.lang.Comparable#compareTo(Object)" ]
  }, {
    "name" : "public String toString()",
    "returnType" : "String",
    "comment" : "\n     * Returns the content of this URI as a string.\n     *\n     * <p> If this URI was created by invoking one of the constructors in this\n     * class then a string equivalent to the original input string, or to the\n     * string computed from the originally-given components, as appropriate, is\n     * returned.  Otherwise this URI was created by normalization, resolution,\n     * or relativization, and so a string is constructed from this URI's\n     * components according to the rules specified in <a\n     * href=\"http://www.ietf.org/rfc/rfc2396.txt\">RFC&nbsp;2396</a>,\n     * section&nbsp;5.2, step&nbsp;7. </p>\n     *\n     * @return  The string form of this URI\n     ",
    "links" : [ ]
  }, {
    "name" : "public String toASCIIString()",
    "returnType" : "String",
    "comment" : "\n     * Returns the content of this URI as a US-ASCII string.\n     *\n     * <p> If this URI does not contain any characters in the <i>other</i>\n     * category then an invocation of this method will return the same value as\n     * an invocation of the {@link #toString() toString} method.  Otherwise\n     * this method works as if by invoking that method and then <a\n     * href=\"#encode\">encoding</a> the result.  </p>\n     *\n     * @return  The string form of this URI, encoded as needed\n     *          so that it only contains characters in the US-ASCII\n     *          charset\n     ",
    "links" : [ "#toString()" ]
  }, {
    "name" : "private void writeObject(ObjectOutputStream os) throws IOException",
    "returnType" : "void",
    "comment" : "\n     * Saves the content of this URI to the given serial stream.\n     *\n     * <p> The only serializable field of a URI instance is its {@code string}\n     * field.  That field is given a value, if it does not have one already,\n     * and then the {@link java.io.ObjectOutputStream#defaultWriteObject()}\n     * method of the given object-output stream is invoked. </p>\n     *\n     * @param  os  The object-output stream to which this object\n     *             is to be written\n     ",
    "links" : [ "java.io.ObjectOutputStream#defaultWriteObject()" ]
  }, {
    "name" : "private void readObject(ObjectInputStream is) throws ClassNotFoundException, IOException",
    "returnType" : "void",
    "comment" : "\n     * Reconstitutes a URI from the given serial stream.\n     *\n     * <p> The {@link java.io.ObjectInputStream#defaultReadObject()} method is\n     * invoked to read the value of the {@code string} field.  The result is\n     * then parsed in the usual way.\n     *\n     * @param  is  The object-input stream from which this object\n     *             is being read\n     ",
    "links" : [ "java.io.ObjectInputStream#defaultReadObject()" ]
  }, {
    "name" : "private static int toLower(char c)",
    "returnType" : "int",
    "comment" : " US-ASCII only",
    "links" : [ ]
  }, {
    "name" : "private static int toUpper(char c)",
    "returnType" : "int",
    "comment" : " US-ASCII only",
    "links" : [ ]
  }, {
    "name" : "private static boolean equal(String s, String t)",
    "returnType" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private static boolean equalIgnoringCase(String s, String t)",
    "returnType" : "boolean",
    "comment" : " US-ASCII only",
    "links" : [ ]
  }, {
    "name" : "private static int hash(int hash, String s)",
    "returnType" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private static int normalizedHash(int hash, String s)",
    "returnType" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private static int hashIgnoringCase(int hash, String s)",
    "returnType" : "int",
    "comment" : " US-ASCII only",
    "links" : [ ]
  }, {
    "name" : "private static int compare(String s, String t)",
    "returnType" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private static int compareIgnoringCase(String s, String t)",
    "returnType" : "int",
    "comment" : " US-ASCII only",
    "links" : [ ]
  }, {
    "name" : "private static void checkPath(String s, String scheme, String path) throws URISyntaxException",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private void appendAuthority(StringBuffer sb, String authority, String userInfo, String host, int port)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private void appendSchemeSpecificPart(StringBuffer sb, String opaquePart, String authority, String userInfo, String host, int port, String path, String query)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private void appendFragment(StringBuffer sb, String fragment)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private String toString(String scheme, String opaquePart, String authority, String userInfo, String host, int port, String path, String query, String fragment)",
    "returnType" : "String",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private void defineSchemeSpecificPart()",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private void defineString()",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private static String resolvePath(String base, String child, boolean absolute)",
    "returnType" : "String",
    "comment" : " RFC2396 5.2 (6)",
    "links" : [ ]
  }, {
    "name" : "private static URI resolve(URI base, URI child)",
    "returnType" : "URI",
    "comment" : " RFC2396 5.2",
    "links" : [ ]
  }, {
    "name" : "private static URI normalize(URI u)",
    "returnType" : "URI",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private static URI relativize(URI base, URI child)",
    "returnType" : "URI",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private static int needsNormalization(String path)",
    "returnType" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private static void split(char[] path, int[] segs)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private static int join(char[] path, int[] segs)",
    "returnType" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private static void removeDots(char[] path, int[] segs, boolean removeLeading)",
    "returnType" : "void",
    "comment" : " private static void removeDots(char[] path, int[] segs) {",
    "links" : [ ]
  }, {
    "name" : "private static void maybeAddLeadingDot(char[] path, int[] segs)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private static String normalize(String ps)",
    "returnType" : "String",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private static String normalize(String ps, boolean removeLeading)",
    "returnType" : "String",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private static long lowMask(String chars)",
    "returnType" : "long",
    "comment" : " Compute the low-order mask for the characters in the given string",
    "links" : [ ]
  }, {
    "name" : "private static long highMask(String chars)",
    "returnType" : "long",
    "comment" : " Compute the high-order mask for the characters in the given string",
    "links" : [ ]
  }, {
    "name" : "private static long lowMask(char first, char last)",
    "returnType" : "long",
    "comment" : " between first and last, inclusive",
    "links" : [ ]
  }, {
    "name" : "private static long highMask(char first, char last)",
    "returnType" : "long",
    "comment" : " between first and last, inclusive",
    "links" : [ ]
  }, {
    "name" : "private static boolean match(char c, long lowMask, long highMask)",
    "returnType" : "boolean",
    "comment" : " Tell whether the given character is permitted by the given mask pair",
    "links" : [ ]
  }, {
    "name" : "private static void appendEscape(StringBuffer sb, byte b)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private static void appendEncoded(StringBuffer sb, char c)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private static String quote(String s, long lowMask, long highMask)",
    "returnType" : "String",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private static String encode(String s)",
    "returnType" : "String",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private static int decode(char c)",
    "returnType" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private static byte decode(char c1, char c2)",
    "returnType" : "byte",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private static String decode(String s)",
    "returnType" : "String",
    "comment" : "",
    "links" : [ ]
  } ],
  "methodNames" : [ "public static URI create(String str)", "public URI parseServerAuthority() throws URISyntaxException", "public URI normalize()", "public URI resolve(URI uri)", "public URI resolve(String str)", "public URI relativize(URI uri)", "public URL toURL() throws MalformedURLException", "public String getScheme()", "public boolean isAbsolute()", "public boolean isOpaque()", "public String getRawSchemeSpecificPart()", "public String getSchemeSpecificPart()", "public String getRawAuthority()", "public String getAuthority()", "public String getRawUserInfo()", "public String getUserInfo()", "public String getHost()", "public int getPort()", "public String getRawPath()", "public String getPath()", "public String getRawQuery()", "public String getQuery()", "public String getRawFragment()", "public String getFragment()", "public boolean equals(Object ob)", "public int hashCode()", "public int compareTo(URI that)", "public String toString()", "public String toASCIIString()", "private void writeObject(ObjectOutputStream os) throws IOException", "private void readObject(ObjectInputStream is) throws ClassNotFoundException, IOException", "private static int toLower(char c)", "private static int toUpper(char c)", "private static boolean equal(String s, String t)", "private static boolean equalIgnoringCase(String s, String t)", "private static int hash(int hash, String s)", "private static int normalizedHash(int hash, String s)", "private static int hashIgnoringCase(int hash, String s)", "private static int compare(String s, String t)", "private static int compareIgnoringCase(String s, String t)", "private static void checkPath(String s, String scheme, String path) throws URISyntaxException", "private void appendAuthority(StringBuffer sb, String authority, String userInfo, String host, int port)", "private void appendSchemeSpecificPart(StringBuffer sb, String opaquePart, String authority, String userInfo, String host, int port, String path, String query)", "private void appendFragment(StringBuffer sb, String fragment)", "private String toString(String scheme, String opaquePart, String authority, String userInfo, String host, int port, String path, String query, String fragment)", "private void defineSchemeSpecificPart()", "private void defineString()", "private static String resolvePath(String base, String child, boolean absolute)", "private static URI resolve(URI base, URI child)", "private static URI normalize(URI u)", "private static URI relativize(URI base, URI child)", "private static int needsNormalization(String path)", "private static void split(char[] path, int[] segs)", "private static int join(char[] path, int[] segs)", "private static void removeDots(char[] path, int[] segs, boolean removeLeading)", "private static void maybeAddLeadingDot(char[] path, int[] segs)", "private static String normalize(String ps)", "private static String normalize(String ps, boolean removeLeading)", "private static long lowMask(String chars)", "private static long highMask(String chars)", "private static long lowMask(char first, char last)", "private static long highMask(char first, char last)", "private static boolean match(char c, long lowMask, long highMask)", "private static void appendEscape(StringBuffer sb, byte b)", "private static void appendEncoded(StringBuffer sb, char c)", "private static String quote(String s, long lowMask, long highMask)", "private static String encode(String s)", "private static int decode(char c)", "private static byte decode(char c1, char c2)", "private static String decode(String s)" ],
  "variableNames" : [ "serialVersionUID", "scheme", "fragment", "authority", "userInfo", "host", "port", "path", "query", "schemeSpecificPart", "hash", "decodedUserInfo", "decodedAuthority", "decodedPath", "decodedQuery", "decodedFragment", "decodedSchemeSpecificPart", "string", "L_DIGIT", "H_DIGIT", "L_UPALPHA", "H_UPALPHA", "L_LOWALPHA", "H_LOWALPHA", "L_ALPHA", "H_ALPHA", "L_ALPHANUM", "H_ALPHANUM", "L_HEX", "H_HEX", "L_MARK", "H_MARK", "L_UNRESERVED", "H_UNRESERVED", "L_RESERVED", "H_RESERVED", "L_ESCAPED", "H_ESCAPED", "L_URIC", "H_URIC", "L_PCHAR", "H_PCHAR", "L_PATH", "H_PATH", "L_DASH", "H_DASH", "L_UNDERSCORE", "H_UNDERSCORE", "L_DOT", "H_DOT", "L_USERINFO", "H_USERINFO", "L_REG_NAME", "H_REG_NAME", "L_SERVER", "H_SERVER", "L_SERVER_PERCENT", "H_SERVER_PERCENT", "L_LEFT_BRACKET", "H_LEFT_BRACKET", "L_SCHEME", "H_SCHEME", "L_URIC_NO_SLASH", "H_URIC_NO_SLASH", "L_SCOPE_ID", "H_SCOPE_ID", "hexDigits" ]
}