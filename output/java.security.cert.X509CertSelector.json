{
  "filePath" : "/home/maryam/clearblue/files/android-source-35/java/security/cert/X509CertSelector.java",
  "packageName" : "java.security.cert",
  "className" : "X509CertSelector",
  "comment" : "\n * A {@code CertSelector} that selects {@code X509Certificates} that\n * match all specified criteria. This class is particularly useful when\n * selecting certificates from a {@code CertStore} to build a\n * PKIX-compliant certification path.\n * <p>\n * When first constructed, an {@code X509CertSelector} has no criteria\n * enabled and each of the {@code get} methods return a default value\n * ({@code null}, or {@code -1} for the {@link #getBasicConstraints\n * getBasicConstraints} method). Therefore, the {@link #match match}\n * method would return {@code true} for any {@code X509Certificate}.\n * Typically, several criteria are enabled (by calling\n * {@link #setIssuer setIssuer} or\n * {@link #setKeyUsage setKeyUsage}, for instance) and then the\n * {@code X509CertSelector} is passed to\n * {@link CertStore#getCertificates CertStore.getCertificates} or some similar\n * method.\n * <p>\n * Several criteria can be enabled (by calling {@link #setIssuer setIssuer}\n * and {@link #setSerialNumber setSerialNumber},\n * for example) such that the {@code match} method\n * usually uniquely matches a single {@code X509Certificate}. We say\n * usually, since it is possible for two issuing CAs to have the same\n * distinguished name and each issue a certificate with the same serial\n * number. Other unique combinations include the issuer, subject,\n * subjectKeyIdentifier and/or the subjectPublicKey criteria.\n * <p>\n * Please refer to <a href=\"http://tools.ietf.org/html/rfc5280\">RFC 5280:\n * Internet X.509 Public Key Infrastructure Certificate and CRL Profile</a> for\n * definitions of the X.509 certificate extensions mentioned below.\n * <p>\n * <b>Concurrent Access</b>\n * <p>\n * Unless otherwise specified, the methods defined in this class are not\n * thread-safe. Multiple threads that need to access a single\n * object concurrently should synchronize amongst themselves and\n * provide the necessary locking. Multiple threads each manipulating\n * separate objects need not synchronize.\n *\n * @see CertSelector\n * @see X509Certificate\n *\n * @since       1.4\n * @author      Steve Hanna\n ",
  "links" : [ "#match", "#setIssuer", "#setSerialNumber", "#setKeyUsage", "java.security.cert.CertStore#getCertificates", "#getBasicConstraintsgetBasicConstraints" ],
  "variables" : [ {
    "name" : "debug",
    "type" : "Debug",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "ANY_EXTENDED_KEY_USAGE",
    "type" : "ObjectIdentifier",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "serialNumber",
    "type" : "BigInteger",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "issuer",
    "type" : "X500Principal",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "subject",
    "type" : "X500Principal",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "subjectKeyID",
    "type" : "byte[]",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "authorityKeyID",
    "type" : "byte[]",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "certificateValid",
    "type" : "Date",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "privateKeyValid",
    "type" : "Date",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "subjectPublicKeyAlgID",
    "type" : "ObjectIdentifier",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "subjectPublicKey",
    "type" : "PublicKey",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "subjectPublicKeyBytes",
    "type" : "byte[]",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "keyUsage",
    "type" : "boolean[]",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "keyPurposeSet",
    "type" : "Set<String>",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "keyPurposeOIDSet",
    "type" : "Set<ObjectIdentifier>",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "subjectAlternativeNames",
    "type" : "Set<List<?>>",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "subjectAlternativeGeneralNames",
    "type" : "Set<GeneralNameInterface>",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "policy",
    "type" : "CertificatePolicySet",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "policySet",
    "type" : "Set<String>",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "pathToNames",
    "type" : "Set<List<?>>",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "pathToGeneralNames",
    "type" : "Set<GeneralNameInterface>",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "nc",
    "type" : "NameConstraintsExtension",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "ncBytes",
    "type" : "byte[]",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "basicConstraints",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "x509Cert",
    "type" : "X509Certificate",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "matchAllSubjectAltNames",
    "type" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "FALSE",
    "type" : "Boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "PRIVATE_KEY_USAGE_ID",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "SUBJECT_ALT_NAME_ID",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "NAME_CONSTRAINTS_ID",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "CERT_POLICIES_ID",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "EXTENDED_KEY_USAGE_ID",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "NUM_OF_EXTENSIONS",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "EXTENSION_OIDS",
    "type" : "String[]",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "NAME_ANY",
    "type" : "int",
    "comment" : " Constants representing the GeneralName types ",
    "links" : [ ]
  }, {
    "name" : "NAME_RFC822",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "NAME_DNS",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "NAME_X400",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "NAME_DIRECTORY",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "NAME_EDI",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "NAME_URI",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "NAME_IP",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "NAME_OID",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  } ],
  "methods" : [ {
    "name" : "public void setCertificate(X509Certificate cert)",
    "returnType" : "void",
    "comment" : "\n     * Sets the certificateEquals criterion. The specified\n     * {@code X509Certificate} must be equal to the\n     * {@code X509Certificate} passed to the {@code match} method.\n     * If {@code null}, then this check is not applied.\n     *\n     * <p>This method is particularly useful when it is necessary to\n     * match a single certificate. Although other criteria can be specified\n     * in conjunction with the certificateEquals criterion, it is usually not\n     * practical or necessary.\n     *\n     * @param cert the {@code X509Certificate} to match (or\n     * {@code null})\n     * @see #getCertificate\n     ",
    "links" : [ ]
  }, {
    "name" : "public void setSerialNumber(BigInteger serial)",
    "returnType" : "void",
    "comment" : "\n     * Sets the serialNumber criterion. The specified serial number\n     * must match the certificate serial number in the\n     * {@code X509Certificate}. If {@code null}, any certificate\n     * serial number will do.\n     *\n     * @param serial the certificate serial number to match\n     *        (or {@code null})\n     * @see #getSerialNumber\n     ",
    "links" : [ ]
  }, {
    "name" : "public void setIssuer(X500Principal issuer)",
    "returnType" : "void",
    "comment" : "\n     * Sets the issuer criterion. The specified distinguished name\n     * must match the issuer distinguished name in the\n     * {@code X509Certificate}. If {@code null}, any issuer\n     * distinguished name will do.\n     *\n     * @param issuer a distinguished name as X500Principal\n     *                 (or {@code null})\n     * @since 1.5\n     ",
    "links" : [ ]
  }, {
    "name" : "public void setIssuer(String issuerDN) throws IOException",
    "returnType" : "void",
    "comment" : "\n     * <strong>Denigrated</strong>, use {@linkplain #setIssuer(X500Principal)}\n     * or {@linkplain #setIssuer(byte[])} instead. This method should not be\n     * relied on as it can fail to match some certificates because of a loss of\n     * encoding information in the\n     * <a href=\"http://www.ietf.org/rfc/rfc2253.txt\">RFC 2253</a> String form\n     * of some distinguished names.\n     * <p>\n     * Sets the issuer criterion. The specified distinguished name\n     * must match the issuer distinguished name in the\n     * {@code X509Certificate}. If {@code null}, any issuer\n     * distinguished name will do.\n     * <p>\n     * If {@code issuerDN} is not {@code null}, it should contain a\n     * distinguished name, in RFC 2253 format.\n     *\n     * @param issuerDN a distinguished name in RFC 2253 format\n     *                 (or {@code null})\n     * @throws IOException if a parsing error occurs (incorrect form for DN)\n     ",
    "links" : [ ]
  }, {
    "name" : "public void setIssuer(byte[] issuerDN) throws IOException",
    "returnType" : "void",
    "comment" : "\n     * Sets the issuer criterion. The specified distinguished name\n     * must match the issuer distinguished name in the\n     * {@code X509Certificate}. If {@code null} is specified,\n     * the issuer criterion is disabled and any issuer distinguished name will\n     * do.\n     * <p>\n     * If {@code issuerDN} is not {@code null}, it should contain a\n     * single DER encoded distinguished name, as defined in X.501. The ASN.1\n     * notation for this structure is as follows.\n     * <pre>{@code\n     * Name ::= CHOICE {\n     *   RDNSequence }\n     *\n     * RDNSequence ::= SEQUENCE OF RelativeDistinguishedName\n     *\n     * RelativeDistinguishedName ::=\n     *   SET SIZE (1 .. MAX) OF AttributeTypeAndValue\n     *\n     * AttributeTypeAndValue ::= SEQUENCE {\n     *   type     AttributeType,\n     *   value    AttributeValue }\n     *\n     * AttributeType ::= OBJECT IDENTIFIER\n     *\n     * AttributeValue ::= ANY DEFINED BY AttributeType\n     * ....\n     * DirectoryString ::= CHOICE {\n     *       teletexString           TeletexString (SIZE (1..MAX)),\n     *       printableString         PrintableString (SIZE (1..MAX)),\n     *       universalString         UniversalString (SIZE (1..MAX)),\n     *       utf8String              UTF8String (SIZE (1.. MAX)),\n     *       bmpString               BMPString (SIZE (1..MAX)) }\n     * }</pre>\n     * <p>\n     * Note that the byte array specified here is cloned to protect against\n     * subsequent modifications.\n     *\n     * @param issuerDN a byte array containing the distinguished name\n     *                 in ASN.1 DER encoded form (or {@code null})\n     * @throws IOException if an encoding error occurs (incorrect form for DN)\n     ",
    "links" : [ ]
  }, {
    "name" : "public void setSubject(X500Principal subject)",
    "returnType" : "void",
    "comment" : "\n     * Sets the subject criterion. The specified distinguished name\n     * must match the subject distinguished name in the\n     * {@code X509Certificate}. If {@code null}, any subject\n     * distinguished name will do.\n     *\n     * @param subject a distinguished name as X500Principal\n     *                  (or {@code null})\n     * @since 1.5\n     ",
    "links" : [ ]
  }, {
    "name" : "public void setSubject(String subjectDN) throws IOException",
    "returnType" : "void",
    "comment" : "\n     * <strong>Denigrated</strong>, use {@linkplain #setSubject(X500Principal)}\n     * or {@linkplain #setSubject(byte[])} instead. This method should not be\n     * relied on as it can fail to match some certificates because of a loss of\n     * encoding information in the RFC 2253 String form of some distinguished\n     * names.\n     * <p>\n     * Sets the subject criterion. The specified distinguished name\n     * must match the subject distinguished name in the\n     * {@code X509Certificate}. If {@code null}, any subject\n     * distinguished name will do.\n     * <p>\n     * If {@code subjectDN} is not {@code null}, it should contain a\n     * distinguished name, in RFC 2253 format.\n     *\n     * @param subjectDN a distinguished name in RFC 2253 format\n     *                  (or {@code null})\n     * @throws IOException if a parsing error occurs (incorrect form for DN)\n     ",
    "links" : [ ]
  }, {
    "name" : "public void setSubject(byte[] subjectDN) throws IOException",
    "returnType" : "void",
    "comment" : "\n     * Sets the subject criterion. The specified distinguished name\n     * must match the subject distinguished name in the\n     * {@code X509Certificate}. If {@code null}, any subject\n     * distinguished name will do.\n     * <p>\n     * If {@code subjectDN} is not {@code null}, it should contain a\n     * single DER encoded distinguished name, as defined in X.501. For the ASN.1\n     * notation for this structure, see\n     * {@link #setIssuer(byte [] issuerDN) setIssuer(byte [] issuerDN)}.\n     *\n     * @param subjectDN a byte array containing the distinguished name in\n     *                  ASN.1 DER format (or {@code null})\n     * @throws IOException if an encoding error occurs (incorrect form for DN)\n     ",
    "links" : [ "#setIssuer(byte" ]
  }, {
    "name" : "public void setSubjectKeyIdentifier(byte[] subjectKeyID)",
    "returnType" : "void",
    "comment" : "\n     * Sets the subjectKeyIdentifier criterion. The\n     * {@code X509Certificate} must contain a SubjectKeyIdentifier\n     * extension for which the contents of the extension\n     * matches the specified criterion value.\n     * If the criterion value is {@code null}, no\n     * subjectKeyIdentifier check will be done.\n     * <p>\n     * If {@code subjectKeyID} is not {@code null}, it\n     * should contain a single DER encoded value corresponding to the contents\n     * of the extension value (not including the object identifier,\n     * criticality setting, and encapsulating OCTET STRING)\n     * for a SubjectKeyIdentifier extension.\n     * The ASN.1 notation for this structure follows.\n     *\n     * <pre>{@code\n     * SubjectKeyIdentifier ::= KeyIdentifier\n     *\n     * KeyIdentifier ::= OCTET STRING\n     * }</pre>\n     * <p>\n     * Since the format of subject key identifiers is not mandated by\n     * any standard, subject key identifiers are not parsed by the\n     * {@code X509CertSelector}. Instead, the values are compared using\n     * a byte-by-byte comparison.\n     * <p>\n     * Note that the byte array supplied here is cloned to protect against\n     * subsequent modifications.\n     *\n     * @param subjectKeyID the subject key identifier (or {@code null})\n     * @see #getSubjectKeyIdentifier\n     ",
    "links" : [ ]
  }, {
    "name" : "public void setAuthorityKeyIdentifier(byte[] authorityKeyID)",
    "returnType" : "void",
    "comment" : "\n     * Sets the authorityKeyIdentifier criterion. The\n     * {@code X509Certificate} must contain an\n     * AuthorityKeyIdentifier extension for which the contents of the\n     * extension value matches the specified criterion value.\n     * If the criterion value is {@code null}, no\n     * authorityKeyIdentifier check will be done.\n     * <p>\n     * If {@code authorityKeyID} is not {@code null}, it\n     * should contain a single DER encoded value corresponding to the contents\n     * of the extension value (not including the object identifier,\n     * criticality setting, and encapsulating OCTET STRING)\n     * for an AuthorityKeyIdentifier extension.\n     * The ASN.1 notation for this structure follows.\n     *\n     * <pre>{@code\n     * AuthorityKeyIdentifier ::= SEQUENCE {\n     *    keyIdentifier             [0] KeyIdentifier           OPTIONAL,\n     *    authorityCertIssuer       [1] GeneralNames            OPTIONAL,\n     *    authorityCertSerialNumber [2] CertificateSerialNumber OPTIONAL  }\n     *\n     * KeyIdentifier ::= OCTET STRING\n     * }</pre>\n     * <p>\n     * Authority key identifiers are not parsed by the\n     * {@code X509CertSelector}.  Instead, the values are\n     * compared using a byte-by-byte comparison.\n     * <p>\n     * When the {@code keyIdentifier} field of\n     * {@code AuthorityKeyIdentifier} is populated, the value is\n     * usually taken from the {@code SubjectKeyIdentifier} extension\n     * in the issuer's certificate.  Note, however, that the result of\n     * {@code X509Certificate.getExtensionValue(<SubjectKeyIdentifier Object\n     * Identifier>)} on the issuer's certificate may NOT be used\n     * directly as the input to {@code setAuthorityKeyIdentifier}.\n     * This is because the SubjectKeyIdentifier contains\n     * only a KeyIdentifier OCTET STRING, and not a SEQUENCE of\n     * KeyIdentifier, GeneralNames, and CertificateSerialNumber.\n     * In order to use the extension value of the issuer certificate's\n     * {@code SubjectKeyIdentifier}\n     * extension, it will be necessary to extract the value of the embedded\n     * {@code KeyIdentifier} OCTET STRING, then DER encode this OCTET\n     * STRING inside a SEQUENCE.\n     * For more details on SubjectKeyIdentifier, see\n     * {@link #setSubjectKeyIdentifier(byte[] subjectKeyID)}.\n     * <p>\n     * Note also that the byte array supplied here is cloned to protect against\n     * subsequent modifications.\n     *\n     * @param authorityKeyID the authority key identifier\n     *        (or {@code null})\n     * @see #getAuthorityKeyIdentifier\n     ",
    "links" : [ "#setSubjectKeyIdentifier(byte" ]
  }, {
    "name" : "public void setCertificateValid(Date certValid)",
    "returnType" : "void",
    "comment" : "\n     * Sets the certificateValid criterion. The specified date must fall\n     * within the certificate validity period for the\n     * {@code X509Certificate}. If {@code null}, no certificateValid\n     * check will be done.\n     * <p>\n     * Note that the {@code Date} supplied here is cloned to protect\n     * against subsequent modifications.\n     *\n     * @param certValid the {@code Date} to check (or {@code null})\n     * @see #getCertificateValid\n     ",
    "links" : [ ]
  }, {
    "name" : "public void setPrivateKeyValid(Date privateKeyValid)",
    "returnType" : "void",
    "comment" : "\n     * Sets the privateKeyValid criterion. The specified date must fall\n     * within the private key validity period for the\n     * {@code X509Certificate}. If {@code null}, no privateKeyValid\n     * check will be done.\n     * <p>\n     * Note that the {@code Date} supplied here is cloned to protect\n     * against subsequent modifications.\n     *\n     * @param privateKeyValid the {@code Date} to check (or\n     *                        {@code null})\n     * @see #getPrivateKeyValid\n     ",
    "links" : [ ]
  }, {
    "name" : "public void setSubjectPublicKeyAlgID(String oid) throws IOException",
    "returnType" : "void",
    "comment" : "\n     * Sets the subjectPublicKeyAlgID criterion. The\n     * {@code X509Certificate} must contain a subject public key\n     * with the specified algorithm. If {@code null}, no\n     * subjectPublicKeyAlgID check will be done.\n     *\n     * @param oid The object identifier (OID) of the algorithm to check\n     *            for (or {@code null}). An OID is represented by a\n     *            set of nonnegative integers separated by periods.\n     * @throws IOException if the OID is invalid, such as\n     * the first component being not 0, 1 or 2 or the second component\n     * being greater than 39.\n     *\n     * @see #getSubjectPublicKeyAlgID\n     ",
    "links" : [ ]
  }, {
    "name" : "public void setSubjectPublicKey(PublicKey key)",
    "returnType" : "void",
    "comment" : "\n     * Sets the subjectPublicKey criterion. The\n     * {@code X509Certificate} must contain the specified subject public\n     * key. If {@code null}, no subjectPublicKey check will be done.\n     *\n     * @param key the subject public key to check for (or {@code null})\n     * @see #getSubjectPublicKey\n     ",
    "links" : [ ]
  }, {
    "name" : "public void setSubjectPublicKey(byte[] key) throws IOException",
    "returnType" : "void",
    "comment" : "\n     * Sets the subjectPublicKey criterion. The {@code X509Certificate}\n     * must contain the specified subject public key. If {@code null},\n     * no subjectPublicKey check will be done.\n     * <p>\n     * Because this method allows the public key to be specified as a byte\n     * array, it may be used for unknown key types.\n     * <p>\n     * If {@code key} is not {@code null}, it should contain a\n     * single DER encoded SubjectPublicKeyInfo structure, as defined in X.509.\n     * The ASN.1 notation for this structure is as follows.\n     * <pre>{@code\n     * SubjectPublicKeyInfo  ::=  SEQUENCE  {\n     *   algorithm            AlgorithmIdentifier,\n     *   subjectPublicKey     BIT STRING  }\n     *\n     * AlgorithmIdentifier  ::=  SEQUENCE  {\n     *   algorithm               OBJECT IDENTIFIER,\n     *   parameters              ANY DEFINED BY algorithm OPTIONAL  }\n     *                              -- contains a value of the type\n     *                              -- registered for use with the\n     *                              -- algorithm object identifier value\n     * }</pre>\n     * <p>\n     * Note that the byte array supplied here is cloned to protect against\n     * subsequent modifications.\n     *\n     * @param key a byte array containing the subject public key in ASN.1 DER\n     *            form (or {@code null})\n     * @throws IOException if an encoding error occurs (incorrect form for\n     * subject public key)\n     * @see #getSubjectPublicKey\n     ",
    "links" : [ ]
  }, {
    "name" : "public void setKeyUsage(boolean[] keyUsage)",
    "returnType" : "void",
    "comment" : "\n     * Sets the keyUsage criterion. The {@code X509Certificate}\n     * must allow the specified keyUsage values. If {@code null}, no\n     * keyUsage check will be done. Note that an {@code X509Certificate}\n     * that has no keyUsage extension implicitly allows all keyUsage values.\n     * <p>\n     * Note that the boolean array supplied here is cloned to protect against\n     * subsequent modifications.\n     *\n     * @param keyUsage a boolean array in the same format as the boolean\n     *                 array returned by\n     * {@link X509Certificate#getKeyUsage() X509Certificate.getKeyUsage()}.\n     *                 Or {@code null}.\n     * @see #getKeyUsage\n     ",
    "links" : [ "java.security.cert.X509Certificate#getKeyUsage()" ]
  }, {
    "name" : "public void setExtendedKeyUsage(Set<String> keyPurposeSet) throws IOException",
    "returnType" : "void",
    "comment" : "\n     * Sets the extendedKeyUsage criterion. The {@code X509Certificate}\n     * must allow the specified key purposes in its extended key usage\n     * extension. If {@code keyPurposeSet} is empty or {@code null},\n     * no extendedKeyUsage check will be done. Note that an\n     * {@code X509Certificate} that has no extendedKeyUsage extension\n     * implicitly allows all key purposes.\n     * <p>\n     * Note that the {@code Set} is cloned to protect against\n     * subsequent modifications.\n     *\n     * @param keyPurposeSet a {@code Set} of key purpose OIDs in string\n     * format (or {@code null}). Each OID is represented by a set of\n     * nonnegative integers separated by periods.\n     * @throws IOException if the OID is invalid, such as\n     * the first component being not 0, 1 or 2 or the second component\n     * being greater than 39.\n     * @see #getExtendedKeyUsage\n     ",
    "links" : [ ]
  }, {
    "name" : "public void setMatchAllSubjectAltNames(boolean matchAllNames)",
    "returnType" : "void",
    "comment" : "\n     * Enables/disables matching all of the subjectAlternativeNames\n     * specified in the {@link #setSubjectAlternativeNames\n     * setSubjectAlternativeNames} or {@link #addSubjectAlternativeName\n     * addSubjectAlternativeName} methods. If enabled,\n     * the {@code X509Certificate} must contain all of the\n     * specified subject alternative names. If disabled, the\n     * {@code X509Certificate} must contain at least one of the\n     * specified subject alternative names.\n     *\n     * <p>The matchAllNames flag is {@code true} by default.\n     *\n     * @param matchAllNames if {@code true}, the flag is enabled;\n     * if {@code false}, the flag is disabled.\n     * @see #getMatchAllSubjectAltNames\n     ",
    "links" : [ "#addSubjectAlternativeNameaddSubjectAlternativeName", "#setSubjectAlternativeNamessetSubjectAlternativeNames" ]
  }, {
    "name" : "public void setSubjectAlternativeNames(Collection<List<?>> names) throws IOException",
    "returnType" : "void",
    "comment" : "\n     * Sets the subjectAlternativeNames criterion. The\n     * {@code X509Certificate} must contain all or at least one of the\n     * specified subjectAlternativeNames, depending on the value of\n     * the matchAllNames flag (see {@link #setMatchAllSubjectAltNames\n     * setMatchAllSubjectAltNames}).\n     * <p>\n     * This method allows the caller to specify, with a single method call,\n     * the complete set of subject alternative names for the\n     * subjectAlternativeNames criterion. The specified value replaces\n     * the previous value for the subjectAlternativeNames criterion.\n     * <p>\n     * The {@code names} parameter (if not {@code null}) is a\n     * {@code Collection} with one\n     * entry for each name to be included in the subject alternative name\n     * criterion. Each entry is a {@code List} whose first entry is an\n     * {@code Integer} (the name type, 0-8) and whose second\n     * entry is a {@code String} or a byte array (the name, in\n     * string or ASN.1 DER encoded form, respectively).\n     * There can be multiple names of the same type. If {@code null}\n     * is supplied as the value for this argument, no\n     * subjectAlternativeNames check will be performed.\n     * <p>\n     * Each subject alternative name in the {@code Collection}\n     * may be specified either as a {@code String} or as an ASN.1 encoded\n     * byte array. For more details about the formats used, see\n     * {@link #addSubjectAlternativeName(int type, String name)\n     * addSubjectAlternativeName(int type, String name)} and\n     * {@link #addSubjectAlternativeName(int type, byte [] name)\n     * addSubjectAlternativeName(int type, byte [] name)}.\n     * <p>\n     * <strong>Note:</strong> for distinguished names, specify the byte\n     * array form instead of the String form. See the note in\n     * {@link #addSubjectAlternativeName(int, String)} for more information.\n     * <p>\n     * Note that the {@code names} parameter can contain duplicate\n     * names (same name and name type), but they may be removed from the\n     * {@code Collection} of names returned by the\n     * {@link #getSubjectAlternativeNames getSubjectAlternativeNames} method.\n     * <p>\n     * Note that a deep copy is performed on the {@code Collection} to\n     * protect against subsequent modifications.\n     *\n     * @param names a {@code Collection} of names (or {@code null})\n     * @throws IOException if a parsing error occurs\n     * @see #getSubjectAlternativeNames\n     ",
    "links" : [ "#getSubjectAlternativeNames", "#addSubjectAlternativeName(int", "#setMatchAllSubjectAltNamessetMatchAllSubjectAltNames" ]
  }, {
    "name" : "public void addSubjectAlternativeName(int type, String name) throws IOException",
    "returnType" : "void",
    "comment" : "\n     * Adds a name to the subjectAlternativeNames criterion. The\n     * {@code X509Certificate} must contain all or at least one\n     * of the specified subjectAlternativeNames, depending on the value of\n     * the matchAllNames flag (see {@link #setMatchAllSubjectAltNames\n     * setMatchAllSubjectAltNames}).\n     * <p>\n     * This method allows the caller to add a name to the set of subject\n     * alternative names.\n     * The specified name is added to any previous value for the\n     * subjectAlternativeNames criterion. If the specified name is a\n     * duplicate, it may be ignored.\n     * <p>\n     * The name is provided in string format.\n     * <a href=\"http://www.ietf.org/rfc/rfc822.txt\">RFC 822</a>, DNS, and URI\n     * names use the well-established string formats for those types (subject to\n     * the restrictions included in RFC 5280). IPv4 address names are\n     * supplied using dotted quad notation. OID address names are represented\n     * as a series of nonnegative integers separated by periods. And\n     * directory names (distinguished names) are supplied in RFC 2253 format.\n     * No standard string format is defined for otherNames, X.400 names,\n     * EDI party names, IPv6 address names, or any other type of names. They\n     * should be specified using the\n     * {@link #addSubjectAlternativeName(int type, byte [] name)\n     * addSubjectAlternativeName(int type, byte [] name)}\n     * method.\n     * <p>\n     * <strong>Note:</strong> for distinguished names, use\n     * {@linkplain #addSubjectAlternativeName(int, byte[])} instead.\n     * This method should not be relied on as it can fail to match some\n     * certificates because of a loss of encoding information in the RFC 2253\n     * String form of some distinguished names.\n     *\n     * @param type the name type (0-8, as specified in\n     *             RFC 5280, section 4.2.1.6)\n     * @param name the name in string form (not {@code null})\n     * @throws IOException if a parsing error occurs\n     ",
    "links" : [ "#addSubjectAlternativeName(int", "#setMatchAllSubjectAltNamessetMatchAllSubjectAltNames" ]
  }, {
    "name" : "public void addSubjectAlternativeName(int type, byte[] name) throws IOException",
    "returnType" : "void",
    "comment" : "\n     * Adds a name to the subjectAlternativeNames criterion. The\n     * {@code X509Certificate} must contain all or at least one\n     * of the specified subjectAlternativeNames, depending on the value of\n     * the matchAllNames flag (see {@link #setMatchAllSubjectAltNames\n     * setMatchAllSubjectAltNames}).\n     * <p>\n     * This method allows the caller to add a name to the set of subject\n     * alternative names.\n     * The specified name is added to any previous value for the\n     * subjectAlternativeNames criterion. If the specified name is a\n     * duplicate, it may be ignored.\n     * <p>\n     * The name is provided as a byte array. This byte array should contain\n     * the DER encoded name, as it would appear in the GeneralName structure\n     * defined in RFC 5280 and X.509. The encoded byte array should only contain\n     * the encoded value of the name, and should not include the tag associated\n     * with the name in the GeneralName structure. The ASN.1 definition of this\n     * structure appears below.\n     * <pre>{@code\n     *  GeneralName ::= CHOICE {\n     *       otherName                       [0]     OtherName,\n     *       rfc822Name                      [1]     IA5String,\n     *       dNSName                         [2]     IA5String,\n     *       x400Address                     [3]     ORAddress,\n     *       directoryName                   [4]     Name,\n     *       ediPartyName                    [5]     EDIPartyName,\n     *       uniformResourceIdentifier       [6]     IA5String,\n     *       iPAddress                       [7]     OCTET STRING,\n     *       registeredID                    [8]     OBJECT IDENTIFIER}\n     * }</pre>\n     * <p>\n     * Note that the byte array supplied here is cloned to protect against\n     * subsequent modifications.\n     *\n     * @param type the name type (0-8, as listed above)\n     * @param name a byte array containing the name in ASN.1 DER encoded form\n     * @throws IOException if a parsing error occurs\n     ",
    "links" : [ "#setMatchAllSubjectAltNamessetMatchAllSubjectAltNames" ]
  }, {
    "name" : "private void addSubjectAlternativeNameInternal(int type, Object name) throws IOException",
    "returnType" : "void",
    "comment" : "\n     * A private method that adds a name (String or byte array) to the\n     * subjectAlternativeNames criterion. The {@code X509Certificate}\n     * must contain the specified subjectAlternativeName.\n     *\n     * @param type the name type (0-8, as specified in\n     *             RFC 5280, section 4.2.1.6)\n     * @param name the name in string or byte array form\n     * @throws IOException if a parsing error occurs\n     ",
    "links" : [ ]
  }, {
    "name" : "private static Set<GeneralNameInterface> parseNames(Collection<List<?>> names) throws IOException",
    "returnType" : "Set<GeneralNameInterface>",
    "comment" : "\n     * Parse an argument of the form passed to setSubjectAlternativeNames,\n     * returning a {@code Collection} of\n     * {@code GeneralNameInterface}s.\n     * Throw an IllegalArgumentException or a ClassCastException\n     * if the argument is malformed.\n     *\n     * @param names a Collection with one entry per name.\n     *              Each entry is a {@code List} whose first entry\n     *              is an Integer (the name type, 0-8) and whose second\n     *              entry is a String or a byte array (the name, in\n     *              string or ASN.1 DER encoded form, respectively).\n     *              There can be multiple names of the same type. Null is\n     *              not an acceptable value.\n     * @return a Set of {@code GeneralNameInterface}s\n     * @throws IOException if a parsing error occurs\n     ",
    "links" : [ ]
  }, {
    "name" : " static boolean equalNames(Collection<?> object1, Collection<?> object2)",
    "returnType" : "boolean",
    "comment" : "\n     * Compare for equality two objects of the form passed to\n     * setSubjectAlternativeNames (or X509CRLSelector.setIssuerNames).\n     * Throw an {@code IllegalArgumentException} or a\n     * {@code ClassCastException} if one of the objects is malformed.\n     *\n     * @param object1 a Collection containing the first object to compare\n     * @param object2 a Collection containing the second object to compare\n     * @return true if the objects are equal, false otherwise\n     ",
    "links" : [ ]
  }, {
    "name" : " static GeneralNameInterface makeGeneralNameInterface(int type, Object name) throws IOException",
    "returnType" : "GeneralNameInterface",
    "comment" : "\n     * Make a {@code GeneralNameInterface} out of a name type (0-8) and an\n     * Object that may be a byte array holding the ASN.1 DER encoded\n     * name or a String form of the name.  Except for X.509\n     * Distinguished Names, the String form of the name must not be the\n     * result from calling toString on an existing GeneralNameInterface\n     * implementing class.  The output of toString is not compatible\n     * with the String constructors for names other than Distinguished\n     * Names.\n     *\n     * @param type name type (0-8)\n     * @param name name as ASN.1 Der-encoded byte array or String\n     * @return a GeneralNameInterface name\n     * @throws IOException if a parsing error occurs\n     ",
    "links" : [ ]
  }, {
    "name" : "public void setNameConstraints(byte[] bytes) throws IOException",
    "returnType" : "void",
    "comment" : "\n     * Sets the name constraints criterion. The {@code X509Certificate}\n     * must have subject and subject alternative names that\n     * meet the specified name constraints.\n     * <p>\n     * The name constraints are specified as a byte array. This byte array\n     * should contain the DER encoded form of the name constraints, as they\n     * would appear in the NameConstraints structure defined in RFC 5280\n     * and X.509. The ASN.1 definition of this structure appears below.\n     *\n     * <pre>{@code\n     *  NameConstraints ::= SEQUENCE {\n     *       permittedSubtrees       [0]     GeneralSubtrees OPTIONAL,\n     *       excludedSubtrees        [1]     GeneralSubtrees OPTIONAL }\n     *\n     *  GeneralSubtrees ::= SEQUENCE SIZE (1..MAX) OF GeneralSubtree\n     *\n     *  GeneralSubtree ::= SEQUENCE {\n     *       base                    GeneralName,\n     *       minimum         [0]     BaseDistance DEFAULT 0,\n     *       maximum         [1]     BaseDistance OPTIONAL }\n     *\n     *  BaseDistance ::= INTEGER (0..MAX)\n     *\n     *  GeneralName ::= CHOICE {\n     *       otherName                       [0]     OtherName,\n     *       rfc822Name                      [1]     IA5String,\n     *       dNSName                         [2]     IA5String,\n     *       x400Address                     [3]     ORAddress,\n     *       directoryName                   [4]     Name,\n     *       ediPartyName                    [5]     EDIPartyName,\n     *       uniformResourceIdentifier       [6]     IA5String,\n     *       iPAddress                       [7]     OCTET STRING,\n     *       registeredID                    [8]     OBJECT IDENTIFIER}\n     * }</pre>\n     * <p>\n     * Note that the byte array supplied here is cloned to protect against\n     * subsequent modifications.\n     *\n     * @param bytes a byte array containing the ASN.1 DER encoding of\n     *              a NameConstraints extension to be used for checking\n     *              name constraints. Only the value of the extension is\n     *              included, not the OID or criticality flag. Can be\n     *              {@code null},\n     *              in which case no name constraints check will be performed.\n     * @throws IOException if a parsing error occurs\n     * @see #getNameConstraints\n     ",
    "links" : [ ]
  }, {
    "name" : "public void setBasicConstraints(int minMaxPathLen)",
    "returnType" : "void",
    "comment" : "\n     * Sets the basic constraints constraint. If the value is greater than or\n     * equal to zero, {@code X509Certificates} must include a\n     * basicConstraints extension with\n     * a pathLen of at least this value. If the value is -2, only end-entity\n     * certificates are accepted. If the value is -1, no check is done.\n     * <p>\n     * This constraint is useful when building a certification path forward\n     * (from the target toward the trust anchor. If a partial path has been\n     * built, any candidate certificate must have a maxPathLen value greater\n     * than or equal to the number of certificates in the partial path.\n     *\n     * @param minMaxPathLen the value for the basic constraints constraint\n     * @throws IllegalArgumentException if the value is less than -2\n     * @see #getBasicConstraints\n     ",
    "links" : [ ]
  }, {
    "name" : "public void setPolicy(Set<String> certPolicySet) throws IOException",
    "returnType" : "void",
    "comment" : "\n     * Sets the policy constraint. The {@code X509Certificate} must\n     * include at least one of the specified policies in its certificate\n     * policies extension. If {@code certPolicySet} is empty, then the\n     * {@code X509Certificate} must include at least some specified policy\n     * in its certificate policies extension. If {@code certPolicySet} is\n     * {@code null}, no policy check will be performed.\n     * <p>\n     * Note that the {@code Set} is cloned to protect against\n     * subsequent modifications.\n     *\n     * @param certPolicySet a {@code Set} of certificate policy OIDs in\n     *                      string format (or {@code null}). Each OID is\n     *                      represented by a set of nonnegative integers\n     *                    separated by periods.\n     * @throws IOException if a parsing error occurs on the OID such as\n     * the first component is not 0, 1 or 2 or the second component is\n     * greater than 39.\n     * @see #getPolicy\n     ",
    "links" : [ ]
  }, {
    "name" : "public void setPathToNames(Collection<List<?>> names) throws IOException",
    "returnType" : "void",
    "comment" : "\n     * Sets the pathToNames criterion. The {@code X509Certificate} must\n     * not include name constraints that would prohibit building a\n     * path to the specified names.\n     * <p>\n     * This method allows the caller to specify, with a single method call,\n     * the complete set of names which the {@code X509Certificates}'s\n     * name constraints must permit. The specified value replaces\n     * the previous value for the pathToNames criterion.\n     * <p>\n     * This constraint is useful when building a certification path forward\n     * (from the target toward the trust anchor. If a partial path has been\n     * built, any candidate certificate must not include name constraints that\n     * would prohibit building a path to any of the names in the partial path.\n     * <p>\n     * The {@code names} parameter (if not {@code null}) is a\n     * {@code Collection} with one\n     * entry for each name to be included in the pathToNames\n     * criterion. Each entry is a {@code List} whose first entry is an\n     * {@code Integer} (the name type, 0-8) and whose second\n     * entry is a {@code String} or a byte array (the name, in\n     * string or ASN.1 DER encoded form, respectively).\n     * There can be multiple names of the same type. If {@code null}\n     * is supplied as the value for this argument, no\n     * pathToNames check will be performed.\n     * <p>\n     * Each name in the {@code Collection}\n     * may be specified either as a {@code String} or as an ASN.1 encoded\n     * byte array. For more details about the formats used, see\n     * {@link #addPathToName(int type, String name)\n     * addPathToName(int type, String name)} and\n     * {@link #addPathToName(int type, byte [] name)\n     * addPathToName(int type, byte [] name)}.\n     * <p>\n     * <strong>Note:</strong> for distinguished names, specify the byte\n     * array form instead of the String form. See the note in\n     * {@link #addPathToName(int, String)} for more information.\n     * <p>\n     * Note that the {@code names} parameter can contain duplicate\n     * names (same name and name type), but they may be removed from the\n     * {@code Collection} of names returned by the\n     * {@link #getPathToNames getPathToNames} method.\n     * <p>\n     * Note that a deep copy is performed on the {@code Collection} to\n     * protect against subsequent modifications.\n     *\n     * @param names a {@code Collection} with one entry per name\n     *              (or {@code null})\n     * @throws IOException if a parsing error occurs\n     * @see #getPathToNames\n     ",
    "links" : [ "#getPathToNames", "#addPathToName(int" ]
  }, {
    "name" : " void setPathToNamesInternal(Set<GeneralNameInterface> names)",
    "returnType" : "void",
    "comment" : " called from CertPathHelper",
    "links" : [ ]
  }, {
    "name" : "public void addPathToName(int type, String name) throws IOException",
    "returnType" : "void",
    "comment" : "\n     * Adds a name to the pathToNames criterion. The {@code X509Certificate}\n     * must not include name constraints that would prohibit building a\n     * path to the specified name.\n     * <p>\n     * This method allows the caller to add a name to the set of names which\n     * the {@code X509Certificates}'s name constraints must permit.\n     * The specified name is added to any previous value for the\n     * pathToNames criterion.  If the name is a duplicate, it may be ignored.\n     * <p>\n     * The name is provided in string format. RFC 822, DNS, and URI names\n     * use the well-established string formats for those types (subject to\n     * the restrictions included in RFC 5280). IPv4 address names are\n     * supplied using dotted quad notation. OID address names are represented\n     * as a series of nonnegative integers separated by periods. And\n     * directory names (distinguished names) are supplied in RFC 2253 format.\n     * No standard string format is defined for otherNames, X.400 names,\n     * EDI party names, IPv6 address names, or any other type of names. They\n     * should be specified using the\n     * {@link #addPathToName(int type, byte [] name)\n     * addPathToName(int type, byte [] name)} method.\n     * <p>\n     * <strong>Note:</strong> for distinguished names, use\n     * {@linkplain #addPathToName(int, byte[])} instead.\n     * This method should not be relied on as it can fail to match some\n     * certificates because of a loss of encoding information in the RFC 2253\n     * String form of some distinguished names.\n     *\n     * @param type the name type (0-8, as specified in\n     *             RFC 5280, section 4.2.1.6)\n     * @param name the name in string form\n     * @throws IOException if a parsing error occurs\n     ",
    "links" : [ "#addPathToName(int" ]
  }, {
    "name" : "public void addPathToName(int type, byte[] name) throws IOException",
    "returnType" : "void",
    "comment" : "\n     * Adds a name to the pathToNames criterion. The {@code X509Certificate}\n     * must not include name constraints that would prohibit building a\n     * path to the specified name.\n     * <p>\n     * This method allows the caller to add a name to the set of names which\n     * the {@code X509Certificates}'s name constraints must permit.\n     * The specified name is added to any previous value for the\n     * pathToNames criterion. If the name is a duplicate, it may be ignored.\n     * <p>\n     * The name is provided as a byte array. This byte array should contain\n     * the DER encoded name, as it would appear in the GeneralName structure\n     * defined in RFC 5280 and X.509. The ASN.1 definition of this structure\n     * appears in the documentation for\n     * {@link #addSubjectAlternativeName(int type, byte [] name)\n     * addSubjectAlternativeName(int type, byte [] name)}.\n     * <p>\n     * Note that the byte array supplied here is cloned to protect against\n     * subsequent modifications.\n     *\n     * @param type the name type (0-8, as specified in\n     *             RFC 5280, section 4.2.1.6)\n     * @param name a byte array containing the name in ASN.1 DER encoded form\n     * @throws IOException if a parsing error occurs\n     ",
    "links" : [ "#addSubjectAlternativeName(int" ]
  }, {
    "name" : "private void addPathToNameInternal(int type, Object name) throws IOException",
    "returnType" : "void",
    "comment" : "\n     * A private method that adds a name (String or byte array) to the\n     * pathToNames criterion. The {@code X509Certificate} must contain\n     * the specified pathToName.\n     *\n     * @param type the name type (0-8, as specified in\n     *             RFC 5280, section 4.2.1.6)\n     * @param name the name in string or byte array form\n     * @throws IOException if an encoding error occurs (incorrect form for DN)\n     ",
    "links" : [ ]
  }, {
    "name" : "public X509Certificate getCertificate()",
    "returnType" : "X509Certificate",
    "comment" : "\n     * Returns the certificateEquals criterion. The specified\n     * {@code X509Certificate} must be equal to the\n     * {@code X509Certificate} passed to the {@code match} method.\n     * If {@code null}, this check is not applied.\n     *\n     * @return the {@code X509Certificate} to match (or {@code null})\n     * @see #setCertificate\n     ",
    "links" : [ ]
  }, {
    "name" : "public BigInteger getSerialNumber()",
    "returnType" : "BigInteger",
    "comment" : "\n     * Returns the serialNumber criterion. The specified serial number\n     * must match the certificate serial number in the\n     * {@code X509Certificate}. If {@code null}, any certificate\n     * serial number will do.\n     *\n     * @return the certificate serial number to match\n     *                (or {@code null})\n     * @see #setSerialNumber\n     ",
    "links" : [ ]
  }, {
    "name" : "public X500Principal getIssuer()",
    "returnType" : "X500Principal",
    "comment" : "\n     * Returns the issuer criterion as an {@code X500Principal}. This\n     * distinguished name must match the issuer distinguished name in the\n     * {@code X509Certificate}. If {@code null}, the issuer criterion\n     * is disabled and any issuer distinguished name will do.\n     *\n     * @return the required issuer distinguished name as X500Principal\n     *         (or {@code null})\n     * @since 1.5\n     ",
    "links" : [ ]
  }, {
    "name" : "public String getIssuerAsString()",
    "returnType" : "String",
    "comment" : "\n     * <strong>Denigrated</strong>, use {@linkplain #getIssuer()} or\n     * {@linkplain #getIssuerAsBytes()} instead. This method should not be\n     * relied on as it can fail to match some certificates because of a loss of\n     * encoding information in the RFC 2253 String form of some distinguished\n     * names.\n     * <p>\n     * Returns the issuer criterion as a {@code String}. This\n     * distinguished name must match the issuer distinguished name in the\n     * {@code X509Certificate}. If {@code null}, the issuer criterion\n     * is disabled and any issuer distinguished name will do.\n     * <p>\n     * If the value returned is not {@code null}, it is a\n     * distinguished name, in RFC 2253 format.\n     *\n     * @return the required issuer distinguished name in RFC 2253 format\n     *         (or {@code null})\n     ",
    "links" : [ ]
  }, {
    "name" : "public byte[] getIssuerAsBytes() throws IOException",
    "returnType" : "byte[]",
    "comment" : "\n     * Returns the issuer criterion as a byte array. This distinguished name\n     * must match the issuer distinguished name in the\n     * {@code X509Certificate}. If {@code null}, the issuer criterion\n     * is disabled and any issuer distinguished name will do.\n     * <p>\n     * If the value returned is not {@code null}, it is a byte\n     * array containing a single DER encoded distinguished name, as defined in\n     * X.501. The ASN.1 notation for this structure is supplied in the\n     * documentation for\n     * {@link #setIssuer(byte [] issuerDN) setIssuer(byte [] issuerDN)}.\n     * <p>\n     * Note that the byte array returned is cloned to protect against\n     * subsequent modifications.\n     *\n     * @return a byte array containing the required issuer distinguished name\n     *         in ASN.1 DER format (or {@code null})\n     * @throws IOException if an encoding error occurs\n     ",
    "links" : [ "#setIssuer(byte" ]
  }, {
    "name" : "public X500Principal getSubject()",
    "returnType" : "X500Principal",
    "comment" : "\n     * Returns the subject criterion as an {@code X500Principal}. This\n     * distinguished name must match the subject distinguished name in the\n     * {@code X509Certificate}. If {@code null}, the subject criterion\n     * is disabled and any subject distinguished name will do.\n     *\n     * @return the required subject distinguished name as X500Principal\n     *         (or {@code null})\n     * @since 1.5\n     ",
    "links" : [ ]
  }, {
    "name" : "public String getSubjectAsString()",
    "returnType" : "String",
    "comment" : "\n     * <strong>Denigrated</strong>, use {@linkplain #getSubject()} or\n     * {@linkplain #getSubjectAsBytes()} instead. This method should not be\n     * relied on as it can fail to match some certificates because of a loss of\n     * encoding information in the RFC 2253 String form of some distinguished\n     * names.\n     * <p>\n     * Returns the subject criterion as a {@code String}. This\n     * distinguished name must match the subject distinguished name in the\n     * {@code X509Certificate}. If {@code null}, the subject criterion\n     * is disabled and any subject distinguished name will do.\n     * <p>\n     * If the value returned is not {@code null}, it is a\n     * distinguished name, in RFC 2253 format.\n     *\n     * @return the required subject distinguished name in RFC 2253 format\n     *         (or {@code null})\n     ",
    "links" : [ ]
  }, {
    "name" : "public byte[] getSubjectAsBytes() throws IOException",
    "returnType" : "byte[]",
    "comment" : "\n     * Returns the subject criterion as a byte array. This distinguished name\n     * must match the subject distinguished name in the\n     * {@code X509Certificate}. If {@code null}, the subject criterion\n     * is disabled and any subject distinguished name will do.\n     * <p>\n     * If the value returned is not {@code null}, it is a byte\n     * array containing a single DER encoded distinguished name, as defined in\n     * X.501. The ASN.1 notation for this structure is supplied in the\n     * documentation for\n     * {@link #setSubject(byte [] subjectDN) setSubject(byte [] subjectDN)}.\n     * <p>\n     * Note that the byte array returned is cloned to protect against\n     * subsequent modifications.\n     *\n     * @return a byte array containing the required subject distinguished name\n     *         in ASN.1 DER format (or {@code null})\n     * @throws IOException if an encoding error occurs\n     ",
    "links" : [ "#setSubject(byte" ]
  }, {
    "name" : "public byte[] getSubjectKeyIdentifier()",
    "returnType" : "byte[]",
    "comment" : "\n     * Returns the subjectKeyIdentifier criterion. The\n     * {@code X509Certificate} must contain a SubjectKeyIdentifier\n     * extension with the specified value. If {@code null}, no\n     * subjectKeyIdentifier check will be done.\n     * <p>\n     * Note that the byte array returned is cloned to protect against\n     * subsequent modifications.\n     *\n     * @return the key identifier (or {@code null})\n     * @see #setSubjectKeyIdentifier\n     ",
    "links" : [ ]
  }, {
    "name" : "public byte[] getAuthorityKeyIdentifier()",
    "returnType" : "byte[]",
    "comment" : "\n     * Returns the authorityKeyIdentifier criterion. The\n     * {@code X509Certificate} must contain a AuthorityKeyIdentifier\n     * extension with the specified value. If {@code null}, no\n     * authorityKeyIdentifier check will be done.\n     * <p>\n     * Note that the byte array returned is cloned to protect against\n     * subsequent modifications.\n     *\n     * @return the key identifier (or {@code null})\n     * @see #setAuthorityKeyIdentifier\n     ",
    "links" : [ ]
  }, {
    "name" : "public Date getCertificateValid()",
    "returnType" : "Date",
    "comment" : "\n     * Returns the certificateValid criterion. The specified date must fall\n     * within the certificate validity period for the\n     * {@code X509Certificate}. If {@code null}, no certificateValid\n     * check will be done.\n     * <p>\n     * Note that the {@code Date} returned is cloned to protect against\n     * subsequent modifications.\n     *\n     * @return the {@code Date} to check (or {@code null})\n     * @see #setCertificateValid\n     ",
    "links" : [ ]
  }, {
    "name" : "public Date getPrivateKeyValid()",
    "returnType" : "Date",
    "comment" : "\n     * Returns the privateKeyValid criterion. The specified date must fall\n     * within the private key validity period for the\n     * {@code X509Certificate}. If {@code null}, no privateKeyValid\n     * check will be done.\n     * <p>\n     * Note that the {@code Date} returned is cloned to protect against\n     * subsequent modifications.\n     *\n     * @return the {@code Date} to check (or {@code null})\n     * @see #setPrivateKeyValid\n     ",
    "links" : [ ]
  }, {
    "name" : "public String getSubjectPublicKeyAlgID()",
    "returnType" : "String",
    "comment" : "\n     * Returns the subjectPublicKeyAlgID criterion. The\n     * {@code X509Certificate} must contain a subject public key\n     * with the specified algorithm. If {@code null}, no\n     * subjectPublicKeyAlgID check will be done.\n     *\n     * @return the object identifier (OID) of the signature algorithm to check\n     *         for (or {@code null}). An OID is represented by a set of\n     *         nonnegative integers separated by periods.\n     * @see #setSubjectPublicKeyAlgID\n     ",
    "links" : [ ]
  }, {
    "name" : "public PublicKey getSubjectPublicKey()",
    "returnType" : "PublicKey",
    "comment" : "\n     * Returns the subjectPublicKey criterion. The\n     * {@code X509Certificate} must contain the specified subject\n     * public key. If {@code null}, no subjectPublicKey check will be done.\n     *\n     * @return the subject public key to check for (or {@code null})\n     * @see #setSubjectPublicKey\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean[] getKeyUsage()",
    "returnType" : "boolean[]",
    "comment" : "\n     * Returns the keyUsage criterion. The {@code X509Certificate}\n     * must allow the specified keyUsage values. If null, no keyUsage\n     * check will be done.\n     * <p>\n     * Note that the boolean array returned is cloned to protect against\n     * subsequent modifications.\n     *\n     * @return a boolean array in the same format as the boolean\n     *                 array returned by\n     * {@link X509Certificate#getKeyUsage() X509Certificate.getKeyUsage()}.\n     *                 Or {@code null}.\n     * @see #setKeyUsage\n     ",
    "links" : [ "java.security.cert.X509Certificate#getKeyUsage()" ]
  }, {
    "name" : "public Set<String> getExtendedKeyUsage()",
    "returnType" : "Set<String>",
    "comment" : "\n     * Returns the extendedKeyUsage criterion. The {@code X509Certificate}\n     * must allow the specified key purposes in its extended key usage\n     * extension. If the {@code keyPurposeSet} returned is empty or\n     * {@code null}, no extendedKeyUsage check will be done. Note that an\n     * {@code X509Certificate} that has no extendedKeyUsage extension\n     * implicitly allows all key purposes.\n     *\n     * @return an immutable {@code Set} of key purpose OIDs in string\n     * format (or {@code null})\n     * @see #setExtendedKeyUsage\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean getMatchAllSubjectAltNames()",
    "returnType" : "boolean",
    "comment" : "\n     * Indicates if the {@code X509Certificate} must contain all\n     * or at least one of the subjectAlternativeNames\n     * specified in the {@link #setSubjectAlternativeNames\n     * setSubjectAlternativeNames} or {@link #addSubjectAlternativeName\n     * addSubjectAlternativeName} methods. If {@code true},\n     * the {@code X509Certificate} must contain all of the\n     * specified subject alternative names. If {@code false}, the\n     * {@code X509Certificate} must contain at least one of the\n     * specified subject alternative names.\n     *\n     * @return {@code true} if the flag is enabled;\n     * {@code false} if the flag is disabled. The flag is\n     * {@code true} by default.\n     * @see #setMatchAllSubjectAltNames\n     ",
    "links" : [ "#addSubjectAlternativeNameaddSubjectAlternativeName", "#setSubjectAlternativeNamessetSubjectAlternativeNames" ]
  }, {
    "name" : "public Collection<List<?>> getSubjectAlternativeNames()",
    "returnType" : "Collection<List<?>>",
    "comment" : "\n     * Returns a copy of the subjectAlternativeNames criterion.\n     * The {@code X509Certificate} must contain all or at least one\n     * of the specified subjectAlternativeNames, depending on the value\n     * of the matchAllNames flag (see {@link #getMatchAllSubjectAltNames\n     * getMatchAllSubjectAltNames}). If the value returned is\n     * {@code null}, no subjectAlternativeNames check will be performed.\n     * <p>\n     * If the value returned is not {@code null}, it is a\n     * {@code Collection} with\n     * one entry for each name to be included in the subject alternative name\n     * criterion. Each entry is a {@code List} whose first entry is an\n     * {@code Integer} (the name type, 0-8) and whose second\n     * entry is a {@code String} or a byte array (the name, in\n     * string or ASN.1 DER encoded form, respectively).\n     * There can be multiple names of the same type.  Note that the\n     * {@code Collection} returned may contain duplicate names (same name\n     * and name type).\n     * <p>\n     * Each subject alternative name in the {@code Collection}\n     * may be specified either as a {@code String} or as an ASN.1 encoded\n     * byte array. For more details about the formats used, see\n     * {@link #addSubjectAlternativeName(int type, String name)\n     * addSubjectAlternativeName(int type, String name)} and\n     * {@link #addSubjectAlternativeName(int type, byte [] name)\n     * addSubjectAlternativeName(int type, byte [] name)}.\n     * <p>\n     * Note that a deep copy is performed on the {@code Collection} to\n     * protect against subsequent modifications.\n     *\n     * @return a {@code Collection} of names (or {@code null})\n     * @see #setSubjectAlternativeNames\n     ",
    "links" : [ "#getMatchAllSubjectAltNamesgetMatchAllSubjectAltNames", "#addSubjectAlternativeName(int" ]
  }, {
    "name" : "private static Set<List<?>> cloneNames(Collection<List<?>> names)",
    "returnType" : "Set<List<?>>",
    "comment" : "\n     * Clone an object of the form passed to\n     * setSubjectAlternativeNames and setPathToNames.\n     * Throw a {@code RuntimeException} if the argument is malformed.\n     * <p>\n     * This method wraps cloneAndCheckNames, changing any\n     * {@code IOException} into a {@code RuntimeException}. This\n     * method should be used when the object being\n     * cloned has already been checked, so there should never be any exceptions.\n     *\n     * @param names a {@code Collection} with one entry per name.\n     *              Each entry is a {@code List} whose first entry\n     *              is an Integer (the name type, 0-8) and whose second\n     *              entry is a String or a byte array (the name, in\n     *              string or ASN.1 DER encoded form, respectively).\n     *              There can be multiple names of the same type. Null\n     *              is not an acceptable value.\n     * @return a deep copy of the specified {@code Collection}\n     * @throws RuntimeException if a parsing error occurs\n     ",
    "links" : [ ]
  }, {
    "name" : "private static Set<List<?>> cloneAndCheckNames(Collection<List<?>> names) throws IOException",
    "returnType" : "Set<List<?>>",
    "comment" : "\n     * Clone and check an argument of the form passed to\n     * setSubjectAlternativeNames and setPathToNames.\n     * Throw an {@code IOException} if the argument is malformed.\n     *\n     * @param names a {@code Collection} with one entry per name.\n     *              Each entry is a {@code List} whose first entry\n     *              is an Integer (the name type, 0-8) and whose second\n     *              entry is a String or a byte array (the name, in\n     *              string or ASN.1 DER encoded form, respectively).\n     *              There can be multiple names of the same type.\n     *              {@code null} is not an acceptable value.\n     * @return a deep copy of the specified {@code Collection}\n     * @throws IOException if a parsing error occurs\n     ",
    "links" : [ ]
  }, {
    "name" : "public byte[] getNameConstraints()",
    "returnType" : "byte[]",
    "comment" : "\n     * Returns the name constraints criterion. The {@code X509Certificate}\n     * must have subject and subject alternative names that\n     * meet the specified name constraints.\n     * <p>\n     * The name constraints are returned as a byte array. This byte array\n     * contains the DER encoded form of the name constraints, as they\n     * would appear in the NameConstraints structure defined in RFC 5280\n     * and X.509. The ASN.1 notation for this structure is supplied in the\n     * documentation for\n     * {@link #setNameConstraints(byte [] bytes) setNameConstraints(byte [] bytes)}.\n     * <p>\n     * Note that the byte array returned is cloned to protect against\n     * subsequent modifications.\n     *\n     * @return a byte array containing the ASN.1 DER encoding of\n     *         a NameConstraints extension used for checking name constraints.\n     *         {@code null} if no name constraints check will be performed.\n     * @see #setNameConstraints\n     ",
    "links" : [ "#setNameConstraints(byte" ]
  }, {
    "name" : "public int getBasicConstraints()",
    "returnType" : "int",
    "comment" : "\n     * Returns the basic constraints constraint. If the value is greater than\n     * or equal to zero, the {@code X509Certificates} must include a\n     * basicConstraints extension with a pathLen of at least this value.\n     * If the value is -2, only end-entity certificates are accepted. If\n     * the value is -1, no basicConstraints check is done.\n     *\n     * @return the value for the basic constraints constraint\n     * @see #setBasicConstraints\n     ",
    "links" : [ ]
  }, {
    "name" : "public Set<String> getPolicy()",
    "returnType" : "Set<String>",
    "comment" : "\n     * Returns the policy criterion. The {@code X509Certificate} must\n     * include at least one of the specified policies in its certificate policies\n     * extension. If the {@code Set} returned is empty, then the\n     * {@code X509Certificate} must include at least some specified policy\n     * in its certificate policies extension. If the {@code Set} returned is\n     * {@code null}, no policy check will be performed.\n     *\n     * @return an immutable {@code Set} of certificate policy OIDs in\n     *         string format (or {@code null})\n     * @see #setPolicy\n     ",
    "links" : [ ]
  }, {
    "name" : "public Collection<List<?>> getPathToNames()",
    "returnType" : "Collection<List<?>>",
    "comment" : "\n     * Returns a copy of the pathToNames criterion. The\n     * {@code X509Certificate} must not include name constraints that would\n     * prohibit building a path to the specified names. If the value\n     * returned is {@code null}, no pathToNames check will be performed.\n     * <p>\n     * If the value returned is not {@code null}, it is a\n     * {@code Collection} with one\n     * entry for each name to be included in the pathToNames\n     * criterion. Each entry is a {@code List} whose first entry is an\n     * {@code Integer} (the name type, 0-8) and whose second\n     * entry is a {@code String} or a byte array (the name, in\n     * string or ASN.1 DER encoded form, respectively).\n     * There can be multiple names of the same type. Note that the\n     * {@code Collection} returned may contain duplicate names (same\n     * name and name type).\n     * <p>\n     * Each name in the {@code Collection}\n     * may be specified either as a {@code String} or as an ASN.1 encoded\n     * byte array. For more details about the formats used, see\n     * {@link #addPathToName(int type, String name)\n     * addPathToName(int type, String name)} and\n     * {@link #addPathToName(int type, byte [] name)\n     * addPathToName(int type, byte [] name)}.\n     * <p>\n     * Note that a deep copy is performed on the {@code Collection} to\n     * protect against subsequent modifications.\n     *\n     * @return a {@code Collection} of names (or {@code null})\n     * @see #setPathToNames\n     ",
    "links" : [ "#addPathToName(int" ]
  }, {
    "name" : "public String toString()",
    "returnType" : "String",
    "comment" : "\n     * Return a printable representation of the {@code CertSelector}.\n     *\n     * @return a {@code String} describing the contents of the\n     *         {@code CertSelector}\n     ",
    "links" : [ ]
  }, {
    "name" : "private static String keyUsageToString(boolean[] k)",
    "returnType" : "String",
    "comment" : "\n     * Returns a printable representation of the KeyUsage.\n     ",
    "links" : [ ]
  }, {
    "name" : "private static Extension getExtensionObject(X509Certificate cert, int extId) throws IOException",
    "returnType" : "Extension",
    "comment" : "\n     * Returns an Extension object given any X509Certificate and extension oid.\n     * Throw an {@code IOException} if the extension byte value is\n     * malformed.\n     *\n     * @param cert a {@code X509Certificate}\n     * @param extId an {@code integer} which specifies the extension index.\n     * Currently, the supported extensions are as follows:\n     * index 0 - PrivateKeyUsageExtension\n     * index 1 - SubjectAlternativeNameExtension\n     * index 2 - NameConstraintsExtension\n     * index 3 - CertificatePoliciesExtension\n     * index 4 - ExtendedKeyUsageExtension\n     * @return an {@code Extension} object whose real type is as specified\n     * by the extension oid.\n     * @throws IOException if cannot construct the {@code Extension}\n     * object with the extension encoding retrieved from the passed in\n     * {@code X509Certificate}.\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean match(Certificate cert)",
    "returnType" : "boolean",
    "comment" : "\n     * Decides whether a {@code Certificate} should be selected.\n     *\n     * @param cert the {@code Certificate} to be checked\n     * @return {@code true} if the {@code Certificate} should be\n     *         selected, {@code false} otherwise\n     ",
    "links" : [ ]
  }, {
    "name" : "private boolean matchSubjectKeyID(X509Certificate xcert)",
    "returnType" : "boolean",
    "comment" : " match on subject key identifier extension value ",
    "links" : [ ]
  }, {
    "name" : "private boolean matchAuthorityKeyID(X509Certificate xcert)",
    "returnType" : "boolean",
    "comment" : " match on authority key identifier extension value ",
    "links" : [ ]
  }, {
    "name" : "private boolean matchPrivateKeyValid(X509Certificate xcert)",
    "returnType" : "boolean",
    "comment" : " match on private key usage range ",
    "links" : [ ]
  }, {
    "name" : "private boolean matchSubjectPublicKeyAlgID(X509Certificate xcert)",
    "returnType" : "boolean",
    "comment" : " match on subject public key algorithm OID ",
    "links" : [ ]
  }, {
    "name" : "private boolean matchKeyUsage(X509Certificate xcert)",
    "returnType" : "boolean",
    "comment" : " match on key usage extension value ",
    "links" : [ ]
  }, {
    "name" : "private boolean matchExtendedKeyUsage(X509Certificate xcert)",
    "returnType" : "boolean",
    "comment" : " match on extended key usage purpose OIDs ",
    "links" : [ ]
  }, {
    "name" : "private boolean matchSubjectAlternativeNames(X509Certificate xcert)",
    "returnType" : "boolean",
    "comment" : " match on subject alternative name extension names ",
    "links" : [ ]
  }, {
    "name" : "private boolean matchNameConstraints(X509Certificate xcert)",
    "returnType" : "boolean",
    "comment" : " match on name constraints ",
    "links" : [ ]
  }, {
    "name" : "private boolean matchPolicy(X509Certificate xcert)",
    "returnType" : "boolean",
    "comment" : " match on policy OIDs ",
    "links" : [ ]
  }, {
    "name" : "private boolean matchPathToNames(X509Certificate xcert)",
    "returnType" : "boolean",
    "comment" : " match on pathToNames ",
    "links" : [ ]
  }, {
    "name" : "private boolean matchExcluded(GeneralSubtrees excluded)",
    "returnType" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private boolean matchPermitted(GeneralSubtrees permitted)",
    "returnType" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private boolean matchBasicConstraints(X509Certificate xcert)",
    "returnType" : "boolean",
    "comment" : " match on basic constraints ",
    "links" : [ ]
  }, {
    "name" : "private static Set<T> cloneSet(Set<T> set)",
    "returnType" : "Set<T>",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public Object clone()",
    "returnType" : "Object",
    "comment" : "\n     * Returns a copy of this object.\n     *\n     * @return the copy\n     ",
    "links" : [ ]
  } ],
  "methodNames" : [ "public void setCertificate(X509Certificate cert)", "public void setSerialNumber(BigInteger serial)", "public void setIssuer(X500Principal issuer)", "public void setIssuer(String issuerDN) throws IOException", "public void setIssuer(byte[] issuerDN) throws IOException", "public void setSubject(X500Principal subject)", "public void setSubject(String subjectDN) throws IOException", "public void setSubject(byte[] subjectDN) throws IOException", "public void setSubjectKeyIdentifier(byte[] subjectKeyID)", "public void setAuthorityKeyIdentifier(byte[] authorityKeyID)", "public void setCertificateValid(Date certValid)", "public void setPrivateKeyValid(Date privateKeyValid)", "public void setSubjectPublicKeyAlgID(String oid) throws IOException", "public void setSubjectPublicKey(PublicKey key)", "public void setSubjectPublicKey(byte[] key) throws IOException", "public void setKeyUsage(boolean[] keyUsage)", "public void setExtendedKeyUsage(Set<String> keyPurposeSet) throws IOException", "public void setMatchAllSubjectAltNames(boolean matchAllNames)", "public void setSubjectAlternativeNames(Collection<List<?>> names) throws IOException", "public void addSubjectAlternativeName(int type, String name) throws IOException", "public void addSubjectAlternativeName(int type, byte[] name) throws IOException", "private void addSubjectAlternativeNameInternal(int type, Object name) throws IOException", "private static Set<GeneralNameInterface> parseNames(Collection<List<?>> names) throws IOException", " static boolean equalNames(Collection<?> object1, Collection<?> object2)", " static GeneralNameInterface makeGeneralNameInterface(int type, Object name) throws IOException", "public void setNameConstraints(byte[] bytes) throws IOException", "public void setBasicConstraints(int minMaxPathLen)", "public void setPolicy(Set<String> certPolicySet) throws IOException", "public void setPathToNames(Collection<List<?>> names) throws IOException", " void setPathToNamesInternal(Set<GeneralNameInterface> names)", "public void addPathToName(int type, String name) throws IOException", "public void addPathToName(int type, byte[] name) throws IOException", "private void addPathToNameInternal(int type, Object name) throws IOException", "public X509Certificate getCertificate()", "public BigInteger getSerialNumber()", "public X500Principal getIssuer()", "public String getIssuerAsString()", "public byte[] getIssuerAsBytes() throws IOException", "public X500Principal getSubject()", "public String getSubjectAsString()", "public byte[] getSubjectAsBytes() throws IOException", "public byte[] getSubjectKeyIdentifier()", "public byte[] getAuthorityKeyIdentifier()", "public Date getCertificateValid()", "public Date getPrivateKeyValid()", "public String getSubjectPublicKeyAlgID()", "public PublicKey getSubjectPublicKey()", "public boolean[] getKeyUsage()", "public Set<String> getExtendedKeyUsage()", "public boolean getMatchAllSubjectAltNames()", "public Collection<List<?>> getSubjectAlternativeNames()", "private static Set<List<?>> cloneNames(Collection<List<?>> names)", "private static Set<List<?>> cloneAndCheckNames(Collection<List<?>> names) throws IOException", "public byte[] getNameConstraints()", "public int getBasicConstraints()", "public Set<String> getPolicy()", "public Collection<List<?>> getPathToNames()", "public String toString()", "private static String keyUsageToString(boolean[] k)", "private static Extension getExtensionObject(X509Certificate cert, int extId) throws IOException", "public boolean match(Certificate cert)", "private boolean matchSubjectKeyID(X509Certificate xcert)", "private boolean matchAuthorityKeyID(X509Certificate xcert)", "private boolean matchPrivateKeyValid(X509Certificate xcert)", "private boolean matchSubjectPublicKeyAlgID(X509Certificate xcert)", "private boolean matchKeyUsage(X509Certificate xcert)", "private boolean matchExtendedKeyUsage(X509Certificate xcert)", "private boolean matchSubjectAlternativeNames(X509Certificate xcert)", "private boolean matchNameConstraints(X509Certificate xcert)", "private boolean matchPolicy(X509Certificate xcert)", "private boolean matchPathToNames(X509Certificate xcert)", "private boolean matchExcluded(GeneralSubtrees excluded)", "private boolean matchPermitted(GeneralSubtrees permitted)", "private boolean matchBasicConstraints(X509Certificate xcert)", "private static Set<T> cloneSet(Set<T> set)", "public Object clone()" ],
  "variableNames" : [ "debug", "ANY_EXTENDED_KEY_USAGE", "serialNumber", "issuer", "subject", "subjectKeyID", "authorityKeyID", "certificateValid", "privateKeyValid", "subjectPublicKeyAlgID", "subjectPublicKey", "subjectPublicKeyBytes", "keyUsage", "keyPurposeSet", "keyPurposeOIDSet", "subjectAlternativeNames", "subjectAlternativeGeneralNames", "policy", "policySet", "pathToNames", "pathToGeneralNames", "nc", "ncBytes", "basicConstraints", "x509Cert", "matchAllSubjectAltNames", "FALSE", "PRIVATE_KEY_USAGE_ID", "SUBJECT_ALT_NAME_ID", "NAME_CONSTRAINTS_ID", "CERT_POLICIES_ID", "EXTENDED_KEY_USAGE_ID", "NUM_OF_EXTENSIONS", "EXTENSION_OIDS", "NAME_ANY", "NAME_RFC822", "NAME_DNS", "NAME_X400", "NAME_DIRECTORY", "NAME_EDI", "NAME_URI", "NAME_IP", "NAME_OID" ]
}