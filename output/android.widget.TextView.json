{
  "filePath" : "/home/maryam/clearblue/files/android-source-35/android/widget/TextView.java",
  "packageName" : "android.widget",
  "className" : "TextView",
  "comment" : "\n * A user interface element that displays text to the user.\n * To provide user-editable text, see {@link EditText}.\n * <p>\n * The following code sample shows a typical use, with an XML layout\n * and code to modify the contents of the text view:\n * </p>\n\n * <pre>\n * &lt;LinearLayout\n       xmlns:android=\"http://schemas.android.com/apk/res/android\"\n       android:layout_width=\"match_parent\"\n       android:layout_height=\"match_parent\"&gt;\n *    &lt;TextView\n *        android:id=\"@+id/text_view_id\"\n *        android:layout_height=\"wrap_content\"\n *        android:layout_width=\"wrap_content\"\n *        android:text=\"@string/hello\" /&gt;\n * &lt;/LinearLayout&gt;\n * </pre>\n * <p>\n * This code sample demonstrates how to modify the contents of the text view\n * defined in the previous XML layout:\n * </p>\n * <pre>\n * public class MainActivity extends Activity {\n *\n *    protected void onCreate(Bundle savedInstanceState) {\n *         super.onCreate(savedInstanceState);\n *         setContentView(R.layout.activity_main);\n *         final TextView helloTextView = (TextView) findViewById(R.id.text_view_id);\n *         helloTextView.setText(R.string.user_greeting);\n *     }\n * }\n * </pre>\n * <p>\n * To customize the appearance of TextView, see <a href=\"https://developer.android.com/guide/topics/ui/themes.html\">Styles and Themes</a>.\n * </p>\n * <p>\n * <b>XML attributes</b>\n * <p>\n * See {@link android.R.styleable#TextView TextView Attributes},\n * {@link android.R.styleable#View View Attributes}\n *\n * @attr ref android.R.styleable#TextView_text\n * @attr ref android.R.styleable#TextView_bufferType\n * @attr ref android.R.styleable#TextView_hint\n * @attr ref android.R.styleable#TextView_textColor\n * @attr ref android.R.styleable#TextView_textColorHighlight\n * @attr ref android.R.styleable#TextView_textColorHint\n * @attr ref android.R.styleable#TextView_textAppearance\n * @attr ref android.R.styleable#TextView_textColorLink\n * @attr ref android.R.styleable#TextView_textFontWeight\n * @attr ref android.R.styleable#TextView_textSize\n * @attr ref android.R.styleable#TextView_textScaleX\n * @attr ref android.R.styleable#TextView_fontFamily\n * @attr ref android.R.styleable#TextView_typeface\n * @attr ref android.R.styleable#TextView_textStyle\n * @attr ref android.R.styleable#TextView_cursorVisible\n * @attr ref android.R.styleable#TextView_maxLines\n * @attr ref android.R.styleable#TextView_maxHeight\n * @attr ref android.R.styleable#TextView_lines\n * @attr ref android.R.styleable#TextView_height\n * @attr ref android.R.styleable#TextView_minLines\n * @attr ref android.R.styleable#TextView_minHeight\n * @attr ref android.R.styleable#TextView_maxEms\n * @attr ref android.R.styleable#TextView_maxWidth\n * @attr ref android.R.styleable#TextView_ems\n * @attr ref android.R.styleable#TextView_width\n * @attr ref android.R.styleable#TextView_minEms\n * @attr ref android.R.styleable#TextView_minWidth\n * @attr ref android.R.styleable#TextView_gravity\n * @attr ref android.R.styleable#TextView_scrollHorizontally\n * @attr ref android.R.styleable#TextView_password\n * @attr ref android.R.styleable#TextView_singleLine\n * @attr ref android.R.styleable#TextView_selectAllOnFocus\n * @attr ref android.R.styleable#TextView_includeFontPadding\n * @attr ref android.R.styleable#TextView_maxLength\n * @attr ref android.R.styleable#TextView_shadowColor\n * @attr ref android.R.styleable#TextView_shadowDx\n * @attr ref android.R.styleable#TextView_shadowDy\n * @attr ref android.R.styleable#TextView_shadowRadius\n * @attr ref android.R.styleable#TextView_autoLink\n * @attr ref android.R.styleable#TextView_linksClickable\n * @attr ref android.R.styleable#TextView_numeric\n * @attr ref android.R.styleable#TextView_digits\n * @attr ref android.R.styleable#TextView_phoneNumber\n * @attr ref android.R.styleable#TextView_inputMethod\n * @attr ref android.R.styleable#TextView_capitalize\n * @attr ref android.R.styleable#TextView_autoText\n * @attr ref android.R.styleable#TextView_editable\n * @attr ref android.R.styleable#TextView_freezesText\n * @attr ref android.R.styleable#TextView_ellipsize\n * @attr ref android.R.styleable#TextView_drawableTop\n * @attr ref android.R.styleable#TextView_drawableBottom\n * @attr ref android.R.styleable#TextView_drawableRight\n * @attr ref android.R.styleable#TextView_drawableLeft\n * @attr ref android.R.styleable#TextView_drawableStart\n * @attr ref android.R.styleable#TextView_drawableEnd\n * @attr ref android.R.styleable#TextView_drawablePadding\n * @attr ref android.R.styleable#TextView_drawableTint\n * @attr ref android.R.styleable#TextView_drawableTintMode\n * @attr ref android.R.styleable#TextView_lineSpacingExtra\n * @attr ref android.R.styleable#TextView_lineSpacingMultiplier\n * @attr ref android.R.styleable#TextView_justificationMode\n * @attr ref android.R.styleable#TextView_marqueeRepeatLimit\n * @attr ref android.R.styleable#TextView_inputType\n * @attr ref android.R.styleable#TextView_imeOptions\n * @attr ref android.R.styleable#TextView_privateImeOptions\n * @attr ref android.R.styleable#TextView_imeActionLabel\n * @attr ref android.R.styleable#TextView_imeActionId\n * @attr ref android.R.styleable#TextView_editorExtras\n * @attr ref android.R.styleable#TextView_elegantTextHeight\n * @attr ref android.R.styleable#TextView_fallbackLineSpacing\n * @attr ref android.R.styleable#TextView_letterSpacing\n * @attr ref android.R.styleable#TextView_fontFeatureSettings\n * @attr ref android.R.styleable#TextView_fontVariationSettings\n * @attr ref android.R.styleable#TextView_breakStrategy\n * @attr ref android.R.styleable#TextView_hyphenationFrequency\n * @attr ref android.R.styleable#TextView_lineBreakStyle\n * @attr ref android.R.styleable#TextView_lineBreakWordStyle\n * @attr ref android.R.styleable#TextView_autoSizeTextType\n * @attr ref android.R.styleable#TextView_autoSizeMinTextSize\n * @attr ref android.R.styleable#TextView_autoSizeMaxTextSize\n * @attr ref android.R.styleable#TextView_autoSizeStepGranularity\n * @attr ref android.R.styleable#TextView_autoSizePresetSizes\n * @attr ref android.R.styleable#TextView_textCursorDrawable\n * @attr ref android.R.styleable#TextView_textSelectHandle\n * @attr ref android.R.styleable#TextView_textSelectHandleLeft\n * @attr ref android.R.styleable#TextView_textSelectHandleRight\n * @attr ref android.R.styleable#TextView_allowUndo\n * @attr ref android.R.styleable#TextView_enabled\n ",
  "links" : [ "android.R.styleable#TextView", "android.R.styleable#View", "android.widget.EditText" ],
  "variables" : [ {
    "name" : "LOG_TAG",
    "type" : "String",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "DEBUG_EXTRACT",
    "type" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "DEBUG_CURSOR",
    "type" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "TEMP_POSITION",
    "type" : "float[]",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "DEFAULT_TYPEFACE",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "SANS",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "SERIF",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "MONOSPACE",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "ELLIPSIZE_NOT_SET",
    "type" : "int",
    "comment" : " Enum for the \"ellipsize\" XML parameter.",
    "links" : [ ]
  }, {
    "name" : "ELLIPSIZE_NONE",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "ELLIPSIZE_START",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "ELLIPSIZE_MIDDLE",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "ELLIPSIZE_END",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "ELLIPSIZE_MARQUEE",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "SIGNED",
    "type" : "int",
    "comment" : " TODO: How can we get this from the XML instead of hardcoding it here?",
    "links" : [ ]
  }, {
    "name" : "DECIMAL",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "MARQUEE_FADE_NORMAL",
    "type" : "int",
    "comment" : "\n     * Draw marquee text with fading edges as usual\n     ",
    "links" : [ ]
  }, {
    "name" : "MARQUEE_FADE_SWITCH_SHOW_ELLIPSIS",
    "type" : "int",
    "comment" : "\n     * Draw marquee text as ellipsize end while inactive instead of with the fade.\n     * (Useful for devices where the fade can be expensive if overdone)\n     ",
    "links" : [ ]
  }, {
    "name" : "MARQUEE_FADE_SWITCH_SHOW_FADE",
    "type" : "int",
    "comment" : "\n     * Draw marquee text with fading edges because it is currently active/animating.\n     ",
    "links" : [ ]
  }, {
    "name" : "LINES",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "EMS",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "PIXELS",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "MAX_LENGTH_FOR_SINGLE_LINE_EDIT_TEXT",
    "type" : "int",
    "comment" : " Maximum text length for single line input.",
    "links" : [ ]
  }, {
    "name" : "mSingleLineLengthFilter",
    "type" : "InputFilter.LengthFilter",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "TEMP_RECTF",
    "type" : "RectF",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "VERY_WIDE",
    "type" : "int",
    "comment" : " XXX should be much larger",
    "links" : [ ]
  }, {
    "name" : "ANIMATED_SCROLL_GAP",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "NO_FILTERS",
    "type" : "InputFilter[]",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "EMPTY_SPANNED",
    "type" : "Spanned",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "CHANGE_WATCHER_PRIORITY",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "OFFSET_MAPPING_SPAN_PRIORITY",
    "type" : "int",
    "comment" : "\n     * The span priority of the {@link OffsetMapping} that is set on the text. It must be\n     * higher than the {@link DynamicLayout}'s {@link TextWatcher}, so that the transformed text is\n     * updated before {@link DynamicLayout#reflow(CharSequence, int, int, int)} being triggered\n     * by {@link TextWatcher#onTextChanged(CharSequence, int, int, int)}.\n     ",
    "links" : [ "android.text.DynamicLayout#reflow(CharSequence", "android.text.DynamicLayout", "android.text.method.OffsetMapping", "android.text.TextWatcher#onTextChanged(CharSequence", "android.text.TextWatcher" ]
  }, {
    "name" : "MULTILINE_STATE_SET",
    "type" : "int[]",
    "comment" : " New state used to change background based on whether this TextView is multiline.",
    "links" : [ ]
  }, {
    "name" : "ACCESSIBILITY_ACTION_SHARE",
    "type" : "int",
    "comment" : " Accessibility action to share selected text.",
    "links" : [ ]
  }, {
    "name" : "ACCESSIBILITY_ACTION_PROCESS_TEXT_START_ID",
    "type" : "int",
    "comment" : " Accessibility action start id for \"process text\" actions.",
    "links" : [ ]
  }, {
    "name" : "ACCESSIBILITY_ACTION_SMART_START_ID",
    "type" : "int",
    "comment" : " Accessibility action start id for \"smart\" actions. @hide ",
    "links" : [ ]
  }, {
    "name" : "PROCESS_TEXT_REQUEST_CODE",
    "type" : "int",
    "comment" : "\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "KEY_EVENT_NOT_HANDLED",
    "type" : "int",
    "comment" : "\n     *  Return code of {@link #doKeyDown}.\n     ",
    "links" : [ "#doKeyDown" ]
  }, {
    "name" : "KEY_EVENT_HANDLED",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "KEY_DOWN_HANDLED_BY_KEY_LISTENER",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "KEY_DOWN_HANDLED_BY_MOVEMENT_METHOD",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "FLOATING_TOOLBAR_SELECT_ALL_REFRESH_DELAY",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "DEFAULT_LINE_BREAK_STYLE",
    "type" : "int",
    "comment" : " The default value of the line break style.",
    "links" : [ ]
  }, {
    "name" : "DEFAULT_LINE_BREAK_WORD_STYLE",
    "type" : "int",
    "comment" : " The default value of the line break word style.",
    "links" : [ ]
  }, {
    "name" : "BORINGLAYOUT_FALLBACK_LINESPACING",
    "type" : "long",
    "comment" : "\n     * This change ID enables the fallback text line spacing (line height) for BoringLayout.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "STATICLAYOUT_FALLBACK_LINESPACING",
    "type" : "long",
    "comment" : "\n     * This change ID enables the fallback text line spacing (line height) for StaticLayout.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "USE_BOUNDS_FOR_WIDTH",
    "type" : "long",
    "comment" : "\n     * This change ID enables the bounding box based layout.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "sLastCutCopyOrTextChangedTime",
    "type" : "long",
    "comment" : " System wide time for last cut, copy or text changed action.",
    "links" : [ ]
  }, {
    "name" : "mTextColor",
    "type" : "ColorStateList",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mHintTextColor",
    "type" : "ColorStateList",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mLinkTextColor",
    "type" : "ColorStateList",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mCurTextColor",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mCurHintTextColor",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mFreezesText",
    "type" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mEditableFactory",
    "type" : "Editable.Factory",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mSpannableFactory",
    "type" : "Spannable.Factory",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mShadowRadius",
    "type" : "float",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mShadowDx",
    "type" : "float",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mShadowDy",
    "type" : "float",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mShadowColor",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mLastOrientation",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mPreDrawRegistered",
    "type" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mPreDrawListenerDetached",
    "type" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mTextClassifier",
    "type" : "TextClassifier",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mTextClassificationSession",
    "type" : "TextClassifier",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mTextClassificationContext",
    "type" : "TextClassificationContext",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mPreventDefaultMovement",
    "type" : "boolean",
    "comment" : " changing.",
    "links" : [ ]
  }, {
    "name" : "mEllipsize",
    "type" : "TextUtils.TruncateAt",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mImeIsConsumingInput",
    "type" : "boolean",
    "comment" : " A flag to indicate the cursor was hidden by IME.",
    "links" : [ ]
  }, {
    "name" : "mCursorVisibleFromAttr",
    "type" : "boolean",
    "comment" : " {@code true} is the default value.",
    "links" : [ ]
  }, {
    "name" : "mDrawables",
    "type" : "Drawables",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mCharWrapper",
    "type" : "CharWrapper",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mMarquee",
    "type" : "Marquee",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mRestartMarquee",
    "type" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mMarqueeRepeatLimit",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mLastLayoutDirection",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mMarqueeFadeMode",
    "type" : "int",
    "comment" : "\n     * On some devices the fading edges add a performance penalty if used\n     * extensively in the same layout. This mode indicates how the marquee\n     * is currently being shown, if applicable. (mEllipsize will == MARQUEE)\n     ",
    "links" : [ ]
  }, {
    "name" : "mSavedMarqueeModeLayout",
    "type" : "Layout",
    "comment" : "\n     * When mMarqueeFadeMode is not MARQUEE_FADE_NORMAL, this stores\n     * the layout that should be used when the mode switches.\n     ",
    "links" : [ ]
  }, {
    "name" : "mText",
    "type" : "CharSequence",
    "comment" : " Do not update following mText/mSpannable/mPrecomputed except for setTextInternal()",
    "links" : [ ]
  }, {
    "name" : "mSpannable",
    "type" : "Spannable",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mPrecomputed",
    "type" : "PrecomputedText",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mTransformed",
    "type" : "CharSequence",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mBufferType",
    "type" : "BufferType",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mHint",
    "type" : "CharSequence",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mHintLayout",
    "type" : "Layout",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mHideHint",
    "type" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mMovement",
    "type" : "MovementMethod",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mTransformation",
    "type" : "TransformationMethod",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mAllowTransformationLengthChange",
    "type" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mChangeWatcher",
    "type" : "ChangeWatcher",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mListeners",
    "type" : "ArrayList<TextWatcher>",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mTextPaint",
    "type" : "TextPaint",
    "comment" : " display attributes",
    "links" : [ ]
  }, {
    "name" : "mUserSetTextScaleX",
    "type" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mLayout",
    "type" : "Layout",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mLocalesChanged",
    "type" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mTextSizeUnit",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mLineBreakStyle",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mLineBreakWordStyle",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mFontWeightAdjustment",
    "type" : "int",
    "comment" : " more bold.",
    "links" : [ ]
  }, {
    "name" : "mOriginalTypeface",
    "type" : "Typeface",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mListenerChanged",
    "type" : "boolean",
    "comment" : " True if setKeyListener() has been explicitly called",
    "links" : [ ]
  }, {
    "name" : "mUseInternationalizedInput",
    "type" : "boolean",
    "comment" : " True if internationalized input should be used for numbers and date and time.",
    "links" : [ ]
  }, {
    "name" : "FALLBACK_LINE_SPACING_NONE",
    "type" : "int",
    "comment" : " Fallback fonts that end up getting used should be allowed to affect line spacing.",
    "links" : [ ]
  }, {
    "name" : "FALLBACK_LINE_SPACING_STATIC_LAYOUT_ONLY",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "FALLBACK_LINE_SPACING_ALL",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mUseFallbackLineSpacing",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mUseTextPaddingForUiTranslation",
    "type" : "boolean",
    "comment" : " True if the view text can be padded for compat reasons, when the view is translated.",
    "links" : [ ]
  }, {
    "name" : "mUseBoundsForWidth",
    "type" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mShiftDrawingOffsetForStartOverhang",
    "type" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mMinimumFontMetrics",
    "type" : "Paint.FontMetrics",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mLocalePreferredFontMetrics",
    "type" : "Paint.FontMetrics",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mUseLocalePreferredLineHeightForMinimum",
    "type" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mGravity",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mHorizontallyScrolling",
    "type" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mAutoLinkMask",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mLinksClickable",
    "type" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mSpacingMult",
    "type" : "float",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mSpacingAdd",
    "type" : "float",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mLineHeightComplexDimen",
    "type" : "int",
    "comment" : "\n     * Remembers what line height was set to originally, before we broke it down into raw pixels.\n     *\n     * <p>This is stored as a complex dimension with both value and unit packed into one field!\n     * {@see TypedValue}\n     ",
    "links" : [ ]
  }, {
    "name" : "mBreakStrategy",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mHyphenationFrequency",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mJustificationMode",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mMaximum",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mMaxMode",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mMinimum",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mMinMode",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mOldMaximum",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mOldMaxMode",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mMaxWidth",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mMaxWidthMode",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mMinWidth",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mMinWidthMode",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mSingleLine",
    "type" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mDesiredHeightAtMeasure",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mIncludePad",
    "type" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mDeferScroll",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mTempRect",
    "type" : "Rect",
    "comment" : " tmp primitives, so we don't alloc them on each draw",
    "links" : [ ]
  }, {
    "name" : "mLastScroll",
    "type" : "long",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mScroller",
    "type" : "Scroller",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mTempTextPaint",
    "type" : "TextPaint",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mTempCursor",
    "type" : "Object",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mBoring",
    "type" : "BoringLayout.Metrics",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mHintBoring",
    "type" : "BoringLayout.Metrics",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mSavedLayout",
    "type" : "BoringLayout",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mSavedHintLayout",
    "type" : "BoringLayout",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mTextDir",
    "type" : "TextDirectionHeuristic",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mFilters",
    "type" : "InputFilter[]",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mTextOperationUser",
    "type" : "UserHandle",
    "comment" : "\n     * {@link UserHandle} that represents the logical owner of the text. {@code null} when it is\n     * the same as {@link Process#myUserHandle()}.\n     *\n     * <p>Most of applications should not worry about this. Some privileged apps that host UI for\n     * other apps may need to set this so that the system can use right user's resources and\n     * services such as input methods and spell checkers.</p>\n     *\n     * @see #setTextOperationUser(UserHandle)\n     ",
    "links" : [ "android.os.Process#myUserHandle()", "android.os.UserHandle" ]
  }, {
    "name" : "mCurrentSpellCheckerLocaleCache",
    "type" : "Locale",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mHighlightColor",
    "type" : "int",
    "comment" : " a link is pressed). These highlight-related fields do not go in mEditor.",
    "links" : [ ]
  }, {
    "name" : "mHighlightPath",
    "type" : "Path",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mHighlightPaint",
    "type" : "Paint",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mHighlightPathBogus",
    "type" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mHighlightPaths",
    "type" : "List<Path>",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mHighlightPaints",
    "type" : "List<Paint>",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mHighlights",
    "type" : "Highlights",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mSearchResultHighlights",
    "type" : "int[]",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mSearchResultHighlightPaint",
    "type" : "Paint",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mFocusedSearchResultHighlightPaint",
    "type" : "Paint",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mFocusedSearchResultHighlightColor",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mSearchResultHighlightColor",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mFocusedSearchResultIndex",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mGesturePreviewHighlightStart",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mGesturePreviewHighlightEnd",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mGesturePreviewHighlightPaint",
    "type" : "Paint",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mPathRecyclePool",
    "type" : "List<Path>",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mHighlightPathsBogus",
    "type" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mCursorDrawableRes",
    "type" : "int",
    "comment" : " they are defined by the TextView's style and are theme-dependent.",
    "links" : [ ]
  }, {
    "name" : "mCursorDrawable",
    "type" : "Drawable",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mTextSelectHandleLeftRes",
    "type" : "int",
    "comment" : " by removing it, but we would break apps targeting <= P that use it by reflection.",
    "links" : [ ]
  }, {
    "name" : "mTextSelectHandleLeft",
    "type" : "Drawable",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mTextSelectHandleRightRes",
    "type" : "int",
    "comment" : " by removing it, but we would break apps targeting <= P that use it by reflection.",
    "links" : [ ]
  }, {
    "name" : "mTextSelectHandleRight",
    "type" : "Drawable",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mTextSelectHandleRes",
    "type" : "int",
    "comment" : " by removing it, but we would break apps targeting <= P that use it by reflection.",
    "links" : [ ]
  }, {
    "name" : "mTextSelectHandle",
    "type" : "Drawable",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mTextEditSuggestionItemLayout",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mTextEditSuggestionContainerLayout",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mTextEditSuggestionHighlightStyle",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "NO_POINTER_ID",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mPrimePointerId",
    "type" : "int",
    "comment" : "\n     * The prime (the 1st finger) pointer id which is used as a lock to prevent multi touch among\n     * TextView and the handle views which are rendered on popup windows.\n     ",
    "links" : [ ]
  }, {
    "name" : "mIsPrimePointerFromHandleView",
    "type" : "boolean",
    "comment" : "\n     * Whether the prime pointer is from the event delivered to selection handle or insertion\n     * handle.\n     ",
    "links" : [ ]
  }, {
    "name" : "mEditor",
    "type" : "Editor",
    "comment" : "\n     * {@link EditText} specific data, created on demand when one of the Editor fields is used.\n     * See {@link #createEditorIfNeeded()}.\n     ",
    "links" : [ "#createEditorIfNeeded()", "android.widget.EditText" ]
  }, {
    "name" : "DEVICE_PROVISIONED_UNKNOWN",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "DEVICE_PROVISIONED_NO",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "DEVICE_PROVISIONED_YES",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mDeviceProvisionedState",
    "type" : "int",
    "comment" : "\n     * Some special options such as sharing selected text should only be shown if the device\n     * is provisioned. Only check the provisioned state once for a given view instance.\n     ",
    "links" : [ ]
  }, {
    "name" : "mLastInputSource",
    "type" : "int",
    "comment" : "\n     * The last input source on this TextView.\n     *\n     * Use the SOURCE_TOUCHSCREEN as the default value for backward compatibility. There could be a\n     * non UI event originated ActionMode initiation, e.g. API call, a11y events, etc.\n     ",
    "links" : [ ]
  }, {
    "name" : "AUTO_SIZE_TEXT_TYPE_NONE",
    "type" : "int",
    "comment" : "\n     * The TextView does not auto-size text (default).\n     ",
    "links" : [ ]
  }, {
    "name" : "AUTO_SIZE_TEXT_TYPE_UNIFORM",
    "type" : "int",
    "comment" : "\n     * The TextView scales text size both horizontally and vertically to fit within the\n     * container.\n     ",
    "links" : [ ]
  }, {
    "name" : "DEFAULT_AUTO_SIZE_MIN_TEXT_SIZE_IN_SP",
    "type" : "int",
    "comment" : " Default minimum size for auto-sizing text in scaled pixels.",
    "links" : [ ]
  }, {
    "name" : "DEFAULT_AUTO_SIZE_MAX_TEXT_SIZE_IN_SP",
    "type" : "int",
    "comment" : " Default maximum size for auto-sizing text in scaled pixels.",
    "links" : [ ]
  }, {
    "name" : "DEFAULT_AUTO_SIZE_GRANULARITY_IN_PX",
    "type" : "int",
    "comment" : " Default value for the step size in pixels.",
    "links" : [ ]
  }, {
    "name" : "UNSET_AUTO_SIZE_UNIFORM_CONFIGURATION_VALUE",
    "type" : "float",
    "comment" : " Use this to specify that any of the auto-size configuration int values have not been set.",
    "links" : [ ]
  }, {
    "name" : "mAutoSizeTextType",
    "type" : "int",
    "comment" : " Auto-size text type.",
    "links" : [ ]
  }, {
    "name" : "mNeedsAutoSizeText",
    "type" : "boolean",
    "comment" : " Specify if auto-size text is needed.",
    "links" : [ ]
  }, {
    "name" : "mAutoSizeStepGranularityInPx",
    "type" : "float",
    "comment" : " Step size for auto-sizing in pixels.",
    "links" : [ ]
  }, {
    "name" : "mAutoSizeMinTextSizeInPx",
    "type" : "float",
    "comment" : " Minimum text size for auto-sizing in pixels.",
    "links" : [ ]
  }, {
    "name" : "mAutoSizeMaxTextSizeInPx",
    "type" : "float",
    "comment" : " Maximum text size for auto-sizing in pixels.",
    "links" : [ ]
  }, {
    "name" : "mAutoSizeTextSizesInPx",
    "type" : "int[]",
    "comment" : " when auto-sizing text.",
    "links" : [ ]
  }, {
    "name" : "mHasPresetAutoSizeValues",
    "type" : "boolean",
    "comment" : " mAutoSizeStepGranularityInPx.",
    "links" : [ ]
  }, {
    "name" : "mTextSetFromXmlOrResourceId",
    "type" : "boolean",
    "comment" : " sanitize autofill requests.",
    "links" : [ ]
  }, {
    "name" : "mTextId",
    "type" : "int",
    "comment" : " Resource id used to set the text.",
    "links" : [ ]
  }, {
    "name" : "mHintId",
    "type" : "int",
    "comment" : " Resource id used to set the hint.",
    "links" : [ ]
  }, {
    "name" : "mWhitespacePattern",
    "type" : "Pattern",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "sAppearanceValues",
    "type" : "SparseIntArray",
    "comment" : " Maps styleable attributes that exist both in TextView style and TextAppearance.",
    "links" : [ ]
  }, {
    "name" : "FOCUSED_SEARCH_RESULT_INDEX_NONE",
    "type" : "int",
    "comment" : "\n     * A special index used for {@link #setFocusedSearchResultIndex(int)} and\n     * {@link #getFocusedSearchResultIndex()} inidicating there is no focused search result.\n     ",
    "links" : [ "#getFocusedSearchResultIndex()", "#setFocusedSearchResultIndex(int)" ]
  }, {
    "name" : "UNKNOWN_BORING",
    "type" : "BoringLayout.Metrics",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "ID_SELECT_ALL",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "ID_UNDO",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "ID_REDO",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "ID_CUT",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "ID_COPY",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "ID_PASTE",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "ID_SHARE",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "ID_PASTE_AS_PLAIN_TEXT",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "ID_REPLACE",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "ID_ASSIST",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "ID_AUTOFILL",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  } ],
  "methods" : [ {
    "name" : "public static void preloadFontCache()",
    "returnType" : "void",
    "comment" : "\n     * Kick-start the font cache for the zygote process (to pay the cost of\n     * initializing freetype for our default font only once).\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "private void setTextInternal(@Nullable CharSequence text)",
    "returnType" : "void",
    "comment" : " Update mText and mPrecomputed",
    "links" : [ ]
  }, {
    "name" : "public void setAutoSizeTextTypeWithDefaults(@AutoSizeTextType int autoSizeTextType)",
    "returnType" : "void",
    "comment" : "\n     * Specify whether this widget should automatically scale the text to try to perfectly fit\n     * within the layout bounds by using the default auto-size configuration.\n     *\n     * @param autoSizeTextType the type of auto-size. Must be one of\n     *        {@link TextView#AUTO_SIZE_TEXT_TYPE_NONE} or\n     *        {@link TextView#AUTO_SIZE_TEXT_TYPE_UNIFORM}\n     *\n     * @throws IllegalArgumentException if <code>autoSizeTextType</code> is none of the types above.\n     *\n     * @attr ref android.R.styleable#TextView_autoSizeTextType\n     *\n     * @see #getAutoSizeTextType()\n     ",
    "links" : [ "android.widget.TextView#AUTO_SIZE_TEXT_TYPE_UNIFORM", "android.widget.TextView#AUTO_SIZE_TEXT_TYPE_NONE" ]
  }, {
    "name" : "public void setAutoSizeTextTypeUniformWithConfiguration(int autoSizeMinTextSize, int autoSizeMaxTextSize, int autoSizeStepGranularity, int unit)",
    "returnType" : "void",
    "comment" : "\n     * Specify whether this widget should automatically scale the text to try to perfectly fit\n     * within the layout bounds. If all the configuration params are valid the type of auto-size is\n     * set to {@link #AUTO_SIZE_TEXT_TYPE_UNIFORM}.\n     *\n     * @param autoSizeMinTextSize the minimum text size available for auto-size\n     * @param autoSizeMaxTextSize the maximum text size available for auto-size\n     * @param autoSizeStepGranularity the auto-size step granularity. It is used in conjunction with\n     *                                the minimum and maximum text size in order to build the set of\n     *                                text sizes the system uses to choose from when auto-sizing\n     * @param unit the desired dimension unit for all sizes above. See {@link TypedValue} for the\n     *             possible dimension units\n     *\n     * @throws IllegalArgumentException if any of the configuration params are invalid.\n     *\n     * @attr ref android.R.styleable#TextView_autoSizeTextType\n     * @attr ref android.R.styleable#TextView_autoSizeMinTextSize\n     * @attr ref android.R.styleable#TextView_autoSizeMaxTextSize\n     * @attr ref android.R.styleable#TextView_autoSizeStepGranularity\n     *\n     * @see #setAutoSizeTextTypeWithDefaults(int)\n     * @see #setAutoSizeTextTypeUniformWithPresetSizes(int[], int)\n     * @see #getAutoSizeMinTextSize()\n     * @see #getAutoSizeMaxTextSize()\n     * @see #getAutoSizeStepGranularity()\n     * @see #getAutoSizeTextAvailableSizes()\n     ",
    "links" : [ "android.util.TypedValue", "#AUTO_SIZE_TEXT_TYPE_UNIFORM" ]
  }, {
    "name" : "public void setAutoSizeTextTypeUniformWithPresetSizes(@NonNull int[] presetSizes, int unit)",
    "returnType" : "void",
    "comment" : "\n     * Specify whether this widget should automatically scale the text to try to perfectly fit\n     * within the layout bounds. If at least one value from the <code>presetSizes</code> is valid\n     * then the type of auto-size is set to {@link #AUTO_SIZE_TEXT_TYPE_UNIFORM}.\n     *\n     * @param presetSizes an {@code int} array of sizes in pixels\n     * @param unit the desired dimension unit for the preset sizes above. See {@link TypedValue} for\n     *             the possible dimension units\n     *\n     * @throws IllegalArgumentException if all of the <code>presetSizes</code> are invalid.\n     *\n     * @attr ref android.R.styleable#TextView_autoSizeTextType\n     * @attr ref android.R.styleable#TextView_autoSizePresetSizes\n     *\n     * @see #setAutoSizeTextTypeWithDefaults(int)\n     * @see #setAutoSizeTextTypeUniformWithConfiguration(int, int, int, int)\n     * @see #getAutoSizeMinTextSize()\n     * @see #getAutoSizeMaxTextSize()\n     * @see #getAutoSizeTextAvailableSizes()\n     ",
    "links" : [ "android.util.TypedValue", "#AUTO_SIZE_TEXT_TYPE_UNIFORM" ]
  }, {
    "name" : "public int getAutoSizeTextType()",
    "returnType" : "int",
    "comment" : "\n     * Returns the type of auto-size set for this widget.\n     *\n     * @return an {@code int} corresponding to one of the auto-size types:\n     *         {@link TextView#AUTO_SIZE_TEXT_TYPE_NONE} or\n     *         {@link TextView#AUTO_SIZE_TEXT_TYPE_UNIFORM}\n     *\n     * @attr ref android.R.styleable#TextView_autoSizeTextType\n     *\n     * @see #setAutoSizeTextTypeWithDefaults(int)\n     * @see #setAutoSizeTextTypeUniformWithConfiguration(int, int, int, int)\n     * @see #setAutoSizeTextTypeUniformWithPresetSizes(int[], int)\n     ",
    "links" : [ "android.widget.TextView#AUTO_SIZE_TEXT_TYPE_UNIFORM", "android.widget.TextView#AUTO_SIZE_TEXT_TYPE_NONE" ]
  }, {
    "name" : "public int getAutoSizeStepGranularity()",
    "returnType" : "int",
    "comment" : "\n     * @return the current auto-size step granularity in pixels.\n     *\n     * @attr ref android.R.styleable#TextView_autoSizeStepGranularity\n     *\n     * @see #setAutoSizeTextTypeUniformWithConfiguration(int, int, int, int)\n     ",
    "links" : [ ]
  }, {
    "name" : "public int getAutoSizeMinTextSize()",
    "returnType" : "int",
    "comment" : "\n     * @return the current auto-size minimum text size in pixels (the default is 12sp). Note that\n     *         if auto-size has not been configured this function returns {@code -1}.\n     *\n     * @attr ref android.R.styleable#TextView_autoSizeMinTextSize\n     *\n     * @see #setAutoSizeTextTypeUniformWithConfiguration(int, int, int, int)\n     * @see #setAutoSizeTextTypeUniformWithPresetSizes(int[], int)\n     ",
    "links" : [ ]
  }, {
    "name" : "public int getAutoSizeMaxTextSize()",
    "returnType" : "int",
    "comment" : "\n     * @return the current auto-size maximum text size in pixels (the default is 112sp). Note that\n     *         if auto-size has not been configured this function returns {@code -1}.\n     *\n     * @attr ref android.R.styleable#TextView_autoSizeMaxTextSize\n     *\n     * @see #setAutoSizeTextTypeUniformWithConfiguration(int, int, int, int)\n     * @see #setAutoSizeTextTypeUniformWithPresetSizes(int[], int)\n     ",
    "links" : [ ]
  }, {
    "name" : "public int[] getAutoSizeTextAvailableSizes()",
    "returnType" : "int[]",
    "comment" : "\n     * @return the current auto-size {@code int} sizes array (in pixels).\n     *\n     * @see #setAutoSizeTextTypeUniformWithConfiguration(int, int, int, int)\n     * @see #setAutoSizeTextTypeUniformWithPresetSizes(int[], int)\n     ",
    "links" : [ ]
  }, {
    "name" : "private void setupAutoSizeUniformPresetSizes(TypedArray textSizes)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private boolean setupAutoSizeUniformPresetSizesConfiguration()",
    "returnType" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private void validateAndSetAutoSizeTextTypeUniformConfiguration(float autoSizeMinTextSizeInPx, float autoSizeMaxTextSizeInPx, float autoSizeStepGranularityInPx)",
    "returnType" : "void",
    "comment" : "\n     * If all params are valid then save the auto-size configuration.\n     *\n     * @throws IllegalArgumentException if any of the params are invalid\n     ",
    "links" : [ ]
  }, {
    "name" : "private void clearAutoSizeConfiguration()",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private int[] cleanupAutoSizePresetSizes(int[] presetValues)",
    "returnType" : "int[]",
    "comment" : " Returns distinct sorted positive values.",
    "links" : [ ]
  }, {
    "name" : "private boolean setupAutoSizeText()",
    "returnType" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private int[] parseDimensionArray(TypedArray dimens)",
    "returnType" : "int[]",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public void onActivityResult(int requestCode, int resultCode, @Nullable Intent data)",
    "returnType" : "void",
    "comment" : "\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "private void setTypefaceFromAttrs(@Nullable Typeface typeface, @Nullable String familyName, @XMLTypefaceAttr int typefaceIndex, @Typeface.Style int style, @IntRange(from = FontStyle.FONT_WEIGHT_UNSPECIFIED, to = FontStyle.FONT_WEIGHT_MAX) int weight)",
    "returnType" : "void",
    "comment" : "\n     * Sets the Typeface taking into account the given attributes.\n     *\n     * @param typeface a typeface\n     * @param familyName family name string, e.g. \"serif\"\n     * @param typefaceIndex an index of the typeface enum, e.g. SANS, SERIF.\n     * @param style a typeface style\n     * @param weight a weight value for the Typeface or {@code FontStyle.FONT_WEIGHT_UNSPECIFIED}\n     *               if not specified.\n     ",
    "links" : [ ]
  }, {
    "name" : "private void resolveStyleAndSetTypeface(@NonNull Typeface typeface, @Typeface.Style int style, @IntRange(from = FontStyle.FONT_WEIGHT_UNSPECIFIED, to = FontStyle.FONT_WEIGHT_MAX) int weight)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private void setRelativeDrawablesIfNeeded(Drawable start, Drawable end)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public void setEnabled(boolean enabled)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public void setTypeface(@Nullable Typeface tf, @Typeface.Style int style)",
    "returnType" : "void",
    "comment" : "\n     * Sets the typeface and style in which the text should be displayed,\n     * and turns on the fake bold and italic bits in the Paint if the\n     * Typeface that you provided does not have all the bits in the\n     * style that you specified.\n     *\n     * @attr ref android.R.styleable#TextView_typeface\n     * @attr ref android.R.styleable#TextView_textStyle\n     ",
    "links" : [ ]
  }, {
    "name" : "protected boolean getDefaultEditable()",
    "returnType" : "boolean",
    "comment" : "\n     * Subclasses override this to specify that they have a KeyListener\n     * by default even if not specifically called for in the XML options.\n     ",
    "links" : [ ]
  }, {
    "name" : "protected MovementMethod getDefaultMovementMethod()",
    "returnType" : "MovementMethod",
    "comment" : "\n     * Subclasses override this to specify a default movement method.\n     ",
    "links" : [ ]
  }, {
    "name" : "public CharSequence getText()",
    "returnType" : "CharSequence",
    "comment" : "\n     * Return the text that TextView is displaying. If {@link #setText(CharSequence)} was called\n     * with an argument of {@link android.widget.TextView.BufferType#SPANNABLE BufferType.SPANNABLE}\n     * or {@link android.widget.TextView.BufferType#EDITABLE BufferType.EDITABLE}, you can cast\n     * the return value from this method to Spannable or Editable, respectively.\n     *\n     * <p>The content of the return value should not be modified. If you want a modifiable one, you\n     * should make your own copy first.</p>\n     *\n     * @return The text displayed by the text view.\n     * @attr ref android.R.styleable#TextView_text\n     ",
    "links" : [ "android.widget.TextView.BufferType#EDITABLE", "#setText(CharSequence)", "android.widget.TextView.BufferType#SPANNABLE" ]
  }, {
    "name" : "public int length()",
    "returnType" : "int",
    "comment" : "\n     * Returns the length, in characters, of the text managed by this TextView\n     * @return The length of the text managed by the TextView in characters.\n     ",
    "links" : [ ]
  }, {
    "name" : "public Editable getEditableText()",
    "returnType" : "Editable",
    "comment" : "\n     * Return the text that TextView is displaying as an Editable object. If the text is not\n     * editable, null is returned.\n     *\n     * @see #getText\n     ",
    "links" : [ ]
  }, {
    "name" : "public CharSequence getTransformed()",
    "returnType" : "CharSequence",
    "comment" : "\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public int getLineHeight()",
    "returnType" : "int",
    "comment" : "\n     * Gets the vertical distance between lines of text, in pixels.\n     * Note that markup within the text can cause individual lines\n     * to be taller or shorter than this height, and the layout may\n     * contain additional first-or last-line padding.\n     * @return The height of one standard line in pixels.\n     ",
    "links" : [ ]
  }, {
    "name" : "public final Layout getLayout()",
    "returnType" : "Layout",
    "comment" : "\n     * Gets the {@link android.text.Layout} that is currently being used to display the text.\n     * This value can be null if the text or width has recently changed.\n     * @return The Layout that is currently being used to display the text.\n     ",
    "links" : [ "android.text.Layout" ]
  }, {
    "name" : " final Layout getHintLayout()",
    "returnType" : "Layout",
    "comment" : "\n     * @return the {@link android.text.Layout} that is currently being used to\n     * display the hint text. This can be null.\n     ",
    "links" : [ "android.text.Layout" ]
  }, {
    "name" : "public final UndoManager getUndoManager()",
    "returnType" : "UndoManager",
    "comment" : "\n     * Retrieve the {@link android.content.UndoManager} that is currently associated\n     * with this TextView.  By default there is no associated UndoManager, so null\n     * is returned.  One can be associated with the TextView through\n     * {@link #setUndoManager(android.content.UndoManager, String)}\n     *\n     * @hide\n     ",
    "links" : [ "android.content.UndoManager", "#setUndoManager(android.content.UndoManager" ]
  }, {
    "name" : "public final Editor getEditorForTesting()",
    "returnType" : "Editor",
    "comment" : "\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public final void setUndoManager(UndoManager undoManager, String tag)",
    "returnType" : "void",
    "comment" : "\n     * Associate an {@link android.content.UndoManager} with this TextView.  Once\n     * done, all edit operations on the TextView will result in appropriate\n     * {@link android.content.UndoOperation} objects pushed on the given UndoManager's\n     * stack.\n     *\n     * @param undoManager The {@link android.content.UndoManager} to associate with\n     * this TextView, or null to clear any existing association.\n     * @param tag String tag identifying this particular TextView owner in the\n     * UndoManager.  This is used to keep the correct association with the\n     * {@link android.content.UndoOwner} of any operations inside of the UndoManager.\n     *\n     * @hide\n     ",
    "links" : [ "android.content.UndoOwner", "android.content.UndoManager", "android.content.UndoOperation" ]
  }, {
    "name" : "public final KeyListener getKeyListener()",
    "returnType" : "KeyListener",
    "comment" : "\n     * Gets the current {@link KeyListener} for the TextView.\n     * This will frequently be null for non-EditText TextViews.\n     * @return the current key listener for this TextView.\n     *\n     * @attr ref android.R.styleable#TextView_numeric\n     * @attr ref android.R.styleable#TextView_digits\n     * @attr ref android.R.styleable#TextView_phoneNumber\n     * @attr ref android.R.styleable#TextView_inputMethod\n     * @attr ref android.R.styleable#TextView_capitalize\n     * @attr ref android.R.styleable#TextView_autoText\n     ",
    "links" : [ "android.text.method.DateKeyListener" ]
  }, {
    "name" : "public void setKeyListener(KeyListener input)",
    "returnType" : "void",
    "comment" : "\n     * Sets the key listener to be used with this TextView.  This can be null\n     * to disallow user input.  Note that this method has significant and\n     * subtle interactions with soft keyboards and other input method:\n     * see {@link KeyListener#getInputType() KeyListener.getInputType()}\n     * for important details.  Calling this method will replace the current\n     * content type of the text view with the content type returned by the\n     * key listener.\n     * <p>\n     * Be warned that if you want a TextView with a key listener or movement\n     * method not to be focusable, or if you want a TextView without a\n     * key listener or movement method to be focusable, you must call\n     * {@link #setFocusable} again after calling this to get the focusability\n     * back the way you want it.\n     *\n     * @attr ref android.R.styleable#TextView_numeric\n     * @attr ref android.R.styleable#TextView_digits\n     * @attr ref android.R.styleable#TextView_phoneNumber\n     * @attr ref android.R.styleable#TextView_inputMethod\n     * @attr ref android.R.styleable#TextView_capitalize\n     * @attr ref android.R.styleable#TextView_autoText\n     ",
    "links" : [ "#setFocusable", "android.text.method.DateKeyListener#getInputType()" ]
  }, {
    "name" : "private void setInputTypeFromEditor()",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private void setKeyListenerOnly(KeyListener input)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public final MovementMethod getMovementMethod()",
    "returnType" : "MovementMethod",
    "comment" : "\n     * Gets the {@link android.text.method.MovementMethod} being used for this TextView,\n     * which provides positioning, scrolling, and text selection functionality.\n     * This will frequently be null for non-EditText TextViews.\n     * @return the movement method being used for this TextView.\n     * @see android.text.method.MovementMethod\n     ",
    "links" : [ "android.text.method.MovementMethod" ]
  }, {
    "name" : "public final void setMovementMethod(MovementMethod movement)",
    "returnType" : "void",
    "comment" : "\n     * Sets the {@link android.text.method.MovementMethod} for handling arrow key movement\n     * for this TextView. This can be null to disallow using the arrow keys to move the\n     * cursor or scroll the view.\n     * <p>\n     * Be warned that if you want a TextView with a key listener or movement\n     * method not to be focusable, or if you want a TextView without a\n     * key listener or movement method to be focusable, you must call\n     * {@link #setFocusable} again after calling this to get the focusability\n     * back the way you want it.\n     ",
    "links" : [ "#setFocusable", "android.text.method.MovementMethod" ]
  }, {
    "name" : "private void fixFocusableAndClickableSettings()",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public final TransformationMethod getTransformationMethod()",
    "returnType" : "TransformationMethod",
    "comment" : "\n     * Gets the current {@link android.text.method.TransformationMethod} for the TextView.\n     * This is frequently null, except for single-line and password fields.\n     * @return the current transformation method for this TextView.\n     *\n     * @attr ref android.R.styleable#TextView_password\n     * @attr ref android.R.styleable#TextView_singleLine\n     ",
    "links" : [ "android.text.method.TransformationMethod" ]
  }, {
    "name" : "public final void setTransformationMethod(TransformationMethod method)",
    "returnType" : "void",
    "comment" : "\n     * Sets the transformation that is applied to the text that this\n     * TextView is displaying.\n     *\n     * @attr ref android.R.styleable#TextView_password\n     * @attr ref android.R.styleable#TextView_singleLine\n     ",
    "links" : [ ]
  }, {
    "name" : " void setTransformationMethodInternal(@Nullable TransformationMethod method, boolean updateText)",
    "returnType" : "void",
    "comment" : "\n     * Set the transformation that is applied to the text that this TextView is displaying,\n     * optionally call the setText.\n     * @param method the new transformation method to be set.\n     * @param updateText whether the call {@link #setText} which will update the TextView to display\n     *                   the new content. This method is helpful when updating\n     *                   {@link TransformationMethod} inside {@link #setText}. It should only be\n     *                   false if text will be updated immediately after this call, otherwise the\n     *                   TextView will enter an inconsistent state.\n     ",
    "links" : [ "android.text.method.AllCapsTransformationMethod", "#setText" ]
  }, {
    "name" : "public int getCompoundPaddingTop()",
    "returnType" : "int",
    "comment" : "\n     * Returns the top padding of the view, plus space for the top\n     * Drawable if any.\n     ",
    "links" : [ ]
  }, {
    "name" : "public int getCompoundPaddingBottom()",
    "returnType" : "int",
    "comment" : "\n     * Returns the bottom padding of the view, plus space for the bottom\n     * Drawable if any.\n     ",
    "links" : [ ]
  }, {
    "name" : "public int getCompoundPaddingLeft()",
    "returnType" : "int",
    "comment" : "\n     * Returns the left padding of the view, plus space for the left\n     * Drawable if any.\n     ",
    "links" : [ ]
  }, {
    "name" : "public int getCompoundPaddingRight()",
    "returnType" : "int",
    "comment" : "\n     * Returns the right padding of the view, plus space for the right\n     * Drawable if any.\n     ",
    "links" : [ ]
  }, {
    "name" : "public int getCompoundPaddingStart()",
    "returnType" : "int",
    "comment" : "\n     * Returns the start padding of the view, plus space for the start\n     * Drawable if any.\n     ",
    "links" : [ ]
  }, {
    "name" : "public int getCompoundPaddingEnd()",
    "returnType" : "int",
    "comment" : "\n     * Returns the end padding of the view, plus space for the end\n     * Drawable if any.\n     ",
    "links" : [ ]
  }, {
    "name" : "public int getExtendedPaddingTop()",
    "returnType" : "int",
    "comment" : "\n     * Returns the extended top padding of the view, including both the\n     * top Drawable if any and any extra space to keep more than maxLines\n     * of text from showing.  It is only valid to call this after measuring.\n     ",
    "links" : [ ]
  }, {
    "name" : "public int getExtendedPaddingBottom()",
    "returnType" : "int",
    "comment" : "\n     * Returns the extended bottom padding of the view, including both the\n     * bottom Drawable if any and any extra space to keep more than maxLines\n     * of text from showing.  It is only valid to call this after measuring.\n     ",
    "links" : [ ]
  }, {
    "name" : "public int getTotalPaddingLeft()",
    "returnType" : "int",
    "comment" : "\n     * Returns the total left padding of the view, including the left\n     * Drawable if any.\n     ",
    "links" : [ ]
  }, {
    "name" : "public int getTotalPaddingRight()",
    "returnType" : "int",
    "comment" : "\n     * Returns the total right padding of the view, including the right\n     * Drawable if any.\n     ",
    "links" : [ ]
  }, {
    "name" : "public int getTotalPaddingStart()",
    "returnType" : "int",
    "comment" : "\n     * Returns the total start padding of the view, including the start\n     * Drawable if any.\n     ",
    "links" : [ ]
  }, {
    "name" : "public int getTotalPaddingEnd()",
    "returnType" : "int",
    "comment" : "\n     * Returns the total end padding of the view, including the end\n     * Drawable if any.\n     ",
    "links" : [ ]
  }, {
    "name" : "public int getTotalPaddingTop()",
    "returnType" : "int",
    "comment" : "\n     * Returns the total top padding of the view, including the top\n     * Drawable if any, the extra space to keep more than maxLines\n     * from showing, and the vertical offset for gravity, if any.\n     ",
    "links" : [ ]
  }, {
    "name" : "public int getTotalPaddingBottom()",
    "returnType" : "int",
    "comment" : "\n     * Returns the total bottom padding of the view, including the bottom\n     * Drawable if any, the extra space to keep more than maxLines\n     * from showing, and the vertical offset for gravity, if any.\n     ",
    "links" : [ ]
  }, {
    "name" : "public void setCompoundDrawables(@Nullable Drawable left, @Nullable Drawable top, @Nullable Drawable right, @Nullable Drawable bottom)",
    "returnType" : "void",
    "comment" : "\n     * Sets the Drawables (if any) to appear to the left of, above, to the\n     * right of, and below the text. Use {@code null} if you do not want a\n     * Drawable there. The Drawables must already have had\n     * {@link Drawable#setBounds} called.\n     * <p>\n     * Calling this method will overwrite any Drawables previously set using\n     * {@link #setCompoundDrawablesRelative} or related methods.\n     *\n     * @attr ref android.R.styleable#TextView_drawableLeft\n     * @attr ref android.R.styleable#TextView_drawableTop\n     * @attr ref android.R.styleable#TextView_drawableRight\n     * @attr ref android.R.styleable#TextView_drawableBottom\n     ",
    "links" : [ "android.graphics.drawable.Drawable#setBounds", "#setCompoundDrawablesRelative" ]
  }, {
    "name" : "public void setCompoundDrawablesWithIntrinsicBounds(@DrawableRes int left, @DrawableRes int top, @DrawableRes int right, @DrawableRes int bottom)",
    "returnType" : "void",
    "comment" : "\n     * Sets the Drawables (if any) to appear to the left of, above, to the\n     * right of, and below the text. Use 0 if you do not want a Drawable there.\n     * The Drawables' bounds will be set to their intrinsic bounds.\n     * <p>\n     * Calling this method will overwrite any Drawables previously set using\n     * {@link #setCompoundDrawablesRelative} or related methods.\n     *\n     * @param left Resource identifier of the left Drawable.\n     * @param top Resource identifier of the top Drawable.\n     * @param right Resource identifier of the right Drawable.\n     * @param bottom Resource identifier of the bottom Drawable.\n     *\n     * @attr ref android.R.styleable#TextView_drawableLeft\n     * @attr ref android.R.styleable#TextView_drawableTop\n     * @attr ref android.R.styleable#TextView_drawableRight\n     * @attr ref android.R.styleable#TextView_drawableBottom\n     ",
    "links" : [ "#setCompoundDrawablesRelative" ]
  }, {
    "name" : "public void setCompoundDrawablesWithIntrinsicBounds(@Nullable Drawable left, @Nullable Drawable top, @Nullable Drawable right, @Nullable Drawable bottom)",
    "returnType" : "void",
    "comment" : "\n     * Sets the Drawables (if any) to appear to the left of, above, to the\n     * right of, and below the text. Use {@code null} if you do not want a\n     * Drawable there. The Drawables' bounds will be set to their intrinsic\n     * bounds.\n     * <p>\n     * Calling this method will overwrite any Drawables previously set using\n     * {@link #setCompoundDrawablesRelative} or related methods.\n     *\n     * @attr ref android.R.styleable#TextView_drawableLeft\n     * @attr ref android.R.styleable#TextView_drawableTop\n     * @attr ref android.R.styleable#TextView_drawableRight\n     * @attr ref android.R.styleable#TextView_drawableBottom\n     ",
    "links" : [ "#setCompoundDrawablesRelative" ]
  }, {
    "name" : "public void setCompoundDrawablesRelative(@Nullable Drawable start, @Nullable Drawable top, @Nullable Drawable end, @Nullable Drawable bottom)",
    "returnType" : "void",
    "comment" : "\n     * Sets the Drawables (if any) to appear to the start of, above, to the end\n     * of, and below the text. Use {@code null} if you do not want a Drawable\n     * there. The Drawables must already have had {@link Drawable#setBounds}\n     * called.\n     * <p>\n     * Calling this method will overwrite any Drawables previously set using\n     * {@link #setCompoundDrawables} or related methods.\n     *\n     * @attr ref android.R.styleable#TextView_drawableStart\n     * @attr ref android.R.styleable#TextView_drawableTop\n     * @attr ref android.R.styleable#TextView_drawableEnd\n     * @attr ref android.R.styleable#TextView_drawableBottom\n     ",
    "links" : [ "android.graphics.drawable.Drawable#setBounds", "#setCompoundDrawables" ]
  }, {
    "name" : "public void setCompoundDrawablesRelativeWithIntrinsicBounds(@DrawableRes int start, @DrawableRes int top, @DrawableRes int end, @DrawableRes int bottom)",
    "returnType" : "void",
    "comment" : "\n     * Sets the Drawables (if any) to appear to the start of, above, to the end\n     * of, and below the text. Use 0 if you do not want a Drawable there. The\n     * Drawables' bounds will be set to their intrinsic bounds.\n     * <p>\n     * Calling this method will overwrite any Drawables previously set using\n     * {@link #setCompoundDrawables} or related methods.\n     *\n     * @param start Resource identifier of the start Drawable.\n     * @param top Resource identifier of the top Drawable.\n     * @param end Resource identifier of the end Drawable.\n     * @param bottom Resource identifier of the bottom Drawable.\n     *\n     * @attr ref android.R.styleable#TextView_drawableStart\n     * @attr ref android.R.styleable#TextView_drawableTop\n     * @attr ref android.R.styleable#TextView_drawableEnd\n     * @attr ref android.R.styleable#TextView_drawableBottom\n     ",
    "links" : [ "#setCompoundDrawables" ]
  }, {
    "name" : "public void setCompoundDrawablesRelativeWithIntrinsicBounds(@Nullable Drawable start, @Nullable Drawable top, @Nullable Drawable end, @Nullable Drawable bottom)",
    "returnType" : "void",
    "comment" : "\n     * Sets the Drawables (if any) to appear to the start of, above, to the end\n     * of, and below the text. Use {@code null} if you do not want a Drawable\n     * there. The Drawables' bounds will be set to their intrinsic bounds.\n     * <p>\n     * Calling this method will overwrite any Drawables previously set using\n     * {@link #setCompoundDrawables} or related methods.\n     *\n     * @attr ref android.R.styleable#TextView_drawableStart\n     * @attr ref android.R.styleable#TextView_drawableTop\n     * @attr ref android.R.styleable#TextView_drawableEnd\n     * @attr ref android.R.styleable#TextView_drawableBottom\n     ",
    "links" : [ "#setCompoundDrawables" ]
  }, {
    "name" : "public Drawable[] getCompoundDrawables()",
    "returnType" : "Drawable[]",
    "comment" : "\n     * Returns drawables for the left, top, right, and bottom borders.\n     *\n     * @attr ref android.R.styleable#TextView_drawableLeft\n     * @attr ref android.R.styleable#TextView_drawableTop\n     * @attr ref android.R.styleable#TextView_drawableRight\n     * @attr ref android.R.styleable#TextView_drawableBottom\n     ",
    "links" : [ ]
  }, {
    "name" : "public Drawable[] getCompoundDrawablesRelative()",
    "returnType" : "Drawable[]",
    "comment" : "\n     * Returns drawables for the start, top, end, and bottom borders.\n     *\n     * @attr ref android.R.styleable#TextView_drawableStart\n     * @attr ref android.R.styleable#TextView_drawableTop\n     * @attr ref android.R.styleable#TextView_drawableEnd\n     * @attr ref android.R.styleable#TextView_drawableBottom\n     ",
    "links" : [ ]
  }, {
    "name" : "public void setCompoundDrawablePadding(int pad)",
    "returnType" : "void",
    "comment" : "\n     * Sets the size of the padding between the compound drawables and\n     * the text.\n     *\n     * @attr ref android.R.styleable#TextView_drawablePadding\n     ",
    "links" : [ ]
  }, {
    "name" : "public int getCompoundDrawablePadding()",
    "returnType" : "int",
    "comment" : "\n     * Returns the padding between the compound drawables and the text.\n     *\n     * @attr ref android.R.styleable#TextView_drawablePadding\n     ",
    "links" : [ ]
  }, {
    "name" : "public void setCompoundDrawableTintList(@Nullable ColorStateList tint)",
    "returnType" : "void",
    "comment" : "\n     * Applies a tint to the compound drawables. Does not modify the\n     * current tint mode, which is {@link BlendMode#SRC_IN} by default.\n     * <p>\n     * Subsequent calls to\n     * {@link #setCompoundDrawables(Drawable, Drawable, Drawable, Drawable)}\n     * and related methods will automatically mutate the drawables and apply\n     * the specified tint and tint mode using\n     * {@link Drawable#setTintList(ColorStateList)}.\n     *\n     * @param tint the tint to apply, may be {@code null} to clear tint\n     *\n     * @attr ref android.R.styleable#TextView_drawableTint\n     * @see #getCompoundDrawableTintList()\n     * @see Drawable#setTintList(ColorStateList)\n     ",
    "links" : [ "#setCompoundDrawables(Drawable", "android.graphics.drawable.Drawable#setTintList(ColorStateList)", "android.graphics.BlendMode#SRC_IN" ]
  }, {
    "name" : "public ColorStateList getCompoundDrawableTintList()",
    "returnType" : "ColorStateList",
    "comment" : "\n     * @return the tint applied to the compound drawables\n     * @attr ref android.R.styleable#TextView_drawableTint\n     * @see #setCompoundDrawableTintList(ColorStateList)\n     ",
    "links" : [ ]
  }, {
    "name" : "public void setCompoundDrawableTintMode(@Nullable PorterDuff.Mode tintMode)",
    "returnType" : "void",
    "comment" : "\n     * Specifies the blending mode used to apply the tint specified by\n     * {@link #setCompoundDrawableTintList(ColorStateList)} to the compound\n     * drawables. The default mode is {@link PorterDuff.Mode#SRC_IN}.\n     *\n     * @param tintMode the blending mode used to apply the tint, may be\n     *                 {@code null} to clear tint\n     * @attr ref android.R.styleable#TextView_drawableTintMode\n     * @see #setCompoundDrawableTintList(ColorStateList)\n     * @see Drawable#setTintMode(PorterDuff.Mode)\n     ",
    "links" : [ "#setCompoundDrawableTintList(ColorStateList)", "PorterDuff.Mode#SRC_IN" ]
  }, {
    "name" : "public void setCompoundDrawableTintBlendMode(@Nullable BlendMode blendMode)",
    "returnType" : "void",
    "comment" : "\n     * Specifies the blending mode used to apply the tint specified by\n     * {@link #setCompoundDrawableTintList(ColorStateList)} to the compound\n     * drawables. The default mode is {@link PorterDuff.Mode#SRC_IN}.\n     *\n     * @param blendMode the blending mode used to apply the tint, may be\n     *                 {@code null} to clear tint\n     * @attr ref android.R.styleable#TextView_drawableTintMode\n     * @see #setCompoundDrawableTintList(ColorStateList)\n     * @see Drawable#setTintBlendMode(BlendMode)\n     ",
    "links" : [ "#setCompoundDrawableTintList(ColorStateList)", "PorterDuff.Mode#SRC_IN" ]
  }, {
    "name" : "public PorterDuff.Mode getCompoundDrawableTintMode()",
    "returnType" : "PorterDuff.Mode",
    "comment" : "\n     * Returns the blending mode used to apply the tint to the compound\n     * drawables, if specified.\n     *\n     * @return the blending mode used to apply the tint to the compound\n     *         drawables\n     * @attr ref android.R.styleable#TextView_drawableTintMode\n     * @see #setCompoundDrawableTintMode(PorterDuff.Mode)\n     *\n     ",
    "links" : [ ]
  }, {
    "name" : "public BlendMode getCompoundDrawableTintBlendMode()",
    "returnType" : "BlendMode",
    "comment" : "\n     * Returns the blending mode used to apply the tint to the compound\n     * drawables, if specified.\n     *\n     * @return the blending mode used to apply the tint to the compound\n     *         drawables\n     * @attr ref android.R.styleable#TextView_drawableTintMode\n     * @see #setCompoundDrawableTintBlendMode(BlendMode)\n     ",
    "links" : [ ]
  }, {
    "name" : "private void applyCompoundDrawableTint()",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public void setPadding(int left, int top, int right, int bottom)",
    "returnType" : "void",
    "comment" : "\n     * @inheritDoc\n     *\n     * @see #setFirstBaselineToTopHeight(int)\n     * @see #setLastBaselineToBottomHeight(int)\n     ",
    "links" : [ ]
  }, {
    "name" : "public void setPaddingRelative(int start, int top, int end, int bottom)",
    "returnType" : "void",
    "comment" : "\n     * @inheritDoc\n     *\n     * @see #setFirstBaselineToTopHeight(int)\n     * @see #setLastBaselineToBottomHeight(int)\n     ",
    "links" : [ ]
  }, {
    "name" : "public void setFirstBaselineToTopHeight(@Px @IntRange(from = 0) int firstBaselineToTopHeight)",
    "returnType" : "void",
    "comment" : "\n     * Updates the top padding of the TextView so that {@code firstBaselineToTopHeight} is\n     * the distance between the top of the TextView and first line's baseline.\n     * <p>\n     * <img src=\"{@docRoot}reference/android/images/text/widget/first_last_baseline.png\" />\n     * <figcaption>First and last baseline metrics for a TextView.</figcaption>\n     *\n     * <strong>Note</strong> that if {@code FontMetrics.top} or {@code FontMetrics.ascent} was\n     * already greater than {@code firstBaselineToTopHeight}, the top padding is not updated.\n     * Moreover since this function sets the top padding, if the height of the TextView is less than\n     * the sum of top padding, line height and bottom padding, top of the line will be pushed\n     * down and bottom will be clipped.\n     *\n     * @param firstBaselineToTopHeight distance between first baseline to top of the container\n     *      in pixels\n     *\n     * @see #getFirstBaselineToTopHeight()\n     * @see #setLastBaselineToBottomHeight(int)\n     * @see #setPadding(int, int, int, int)\n     * @see #setPaddingRelative(int, int, int, int)\n     *\n     * @attr ref android.R.styleable#TextView_firstBaselineToTopHeight\n     ",
    "links" : [ ]
  }, {
    "name" : "public void setLastBaselineToBottomHeight(@Px @IntRange(from = 0) int lastBaselineToBottomHeight)",
    "returnType" : "void",
    "comment" : "\n     * Updates the bottom padding of the TextView so that {@code lastBaselineToBottomHeight} is\n     * the distance between the bottom of the TextView and the last line's baseline.\n     * <p>\n     * <img src=\"{@docRoot}reference/android/images/text/widget/first_last_baseline.png\" />\n     * <figcaption>First and last baseline metrics for a TextView.</figcaption>\n     *\n     * <strong>Note</strong> that if {@code FontMetrics.bottom} or {@code FontMetrics.descent} was\n     * already greater than {@code lastBaselineToBottomHeight}, the bottom padding is not updated.\n     * Moreover since this function sets the bottom padding, if the height of the TextView is less\n     * than the sum of top padding, line height and bottom padding, bottom of the text will be\n     * clipped.\n     *\n     * @param lastBaselineToBottomHeight distance between last baseline to bottom of the container\n     *      in pixels\n     *\n     * @see #getLastBaselineToBottomHeight()\n     * @see #setFirstBaselineToTopHeight(int)\n     * @see #setPadding(int, int, int, int)\n     * @see #setPaddingRelative(int, int, int, int)\n     *\n     * @attr ref android.R.styleable#TextView_lastBaselineToBottomHeight\n     ",
    "links" : [ ]
  }, {
    "name" : "public int getFirstBaselineToTopHeight()",
    "returnType" : "int",
    "comment" : "\n     * Returns the distance between the first text baseline and the top of this TextView.\n     *\n     * @see #setFirstBaselineToTopHeight(int)\n     * @attr ref android.R.styleable#TextView_firstBaselineToTopHeight\n     ",
    "links" : [ ]
  }, {
    "name" : "public int getLastBaselineToBottomHeight()",
    "returnType" : "int",
    "comment" : "\n     * Returns the distance between the last text baseline and the bottom of this TextView.\n     *\n     * @see #setLastBaselineToBottomHeight(int)\n     * @attr ref android.R.styleable#TextView_lastBaselineToBottomHeight\n     ",
    "links" : [ ]
  }, {
    "name" : "public final int getAutoLinkMask()",
    "returnType" : "int",
    "comment" : "\n     * Gets the autolink mask of the text.\n     *\n     * See {@link Linkify#ALL} and peers for possible values.\n     *\n     * @attr ref android.R.styleable#TextView_autoLink\n     ",
    "links" : [ "android.text.util.Linkify#ALL" ]
  }, {
    "name" : "public void setTextSelectHandle(@NonNull Drawable textSelectHandle)",
    "returnType" : "void",
    "comment" : "\n     * Sets the Drawable corresponding to the selection handle used for\n     * positioning the cursor within text. The Drawable defaults to the value\n     * of the textSelectHandle attribute.\n     * Note that any change applied to the handle Drawable will not be visible\n     * until the handle is hidden and then drawn again.\n     *\n     * @see #setTextSelectHandle(int)\n     * @attr ref android.R.styleable#TextView_textSelectHandle\n     ",
    "links" : [ ]
  }, {
    "name" : "public void setTextSelectHandle(@DrawableRes int textSelectHandle)",
    "returnType" : "void",
    "comment" : "\n     * Sets the Drawable corresponding to the selection handle used for\n     * positioning the cursor within text. The Drawable defaults to the value\n     * of the textSelectHandle attribute.\n     * Note that any change applied to the handle Drawable will not be visible\n     * until the handle is hidden and then drawn again.\n     *\n     * @see #setTextSelectHandle(Drawable)\n     * @attr ref android.R.styleable#TextView_textSelectHandle\n     ",
    "links" : [ ]
  }, {
    "name" : "public Drawable getTextSelectHandle()",
    "returnType" : "Drawable",
    "comment" : "\n     * Returns the Drawable corresponding to the selection handle used\n     * for positioning the cursor within text.\n     * Note that any change applied to the handle Drawable will not be visible\n     * until the handle is hidden and then drawn again.\n     *\n     * @return the text select handle drawable\n     *\n     * @see #setTextSelectHandle(Drawable)\n     * @see #setTextSelectHandle(int)\n     * @attr ref android.R.styleable#TextView_textSelectHandle\n     ",
    "links" : [ ]
  }, {
    "name" : "public void setTextSelectHandleLeft(@NonNull Drawable textSelectHandleLeft)",
    "returnType" : "void",
    "comment" : "\n     * Sets the Drawable corresponding to the left handle used\n     * for selecting text. The Drawable defaults to the value of the\n     * textSelectHandleLeft attribute.\n     * Note that any change applied to the handle Drawable will not be visible\n     * until the handle is hidden and then drawn again.\n     *\n     * @see #setTextSelectHandleLeft(int)\n     * @attr ref android.R.styleable#TextView_textSelectHandleLeft\n     ",
    "links" : [ ]
  }, {
    "name" : "public void setTextSelectHandleLeft(@DrawableRes int textSelectHandleLeft)",
    "returnType" : "void",
    "comment" : "\n     * Sets the Drawable corresponding to the left handle used\n     * for selecting text. The Drawable defaults to the value of the\n     * textSelectHandleLeft attribute.\n     * Note that any change applied to the handle Drawable will not be visible\n     * until the handle is hidden and then drawn again.\n     *\n     * @see #setTextSelectHandleLeft(Drawable)\n     * @attr ref android.R.styleable#TextView_textSelectHandleLeft\n     ",
    "links" : [ ]
  }, {
    "name" : "public Drawable getTextSelectHandleLeft()",
    "returnType" : "Drawable",
    "comment" : "\n     * Returns the Drawable corresponding to the left handle used\n     * for selecting text.\n     * Note that any change applied to the handle Drawable will not be visible\n     * until the handle is hidden and then drawn again.\n     *\n     * @return the left text selection handle drawable\n     *\n     * @see #setTextSelectHandleLeft(Drawable)\n     * @see #setTextSelectHandleLeft(int)\n     * @attr ref android.R.styleable#TextView_textSelectHandleLeft\n     ",
    "links" : [ ]
  }, {
    "name" : "public void setTextSelectHandleRight(@NonNull Drawable textSelectHandleRight)",
    "returnType" : "void",
    "comment" : "\n     * Sets the Drawable corresponding to the right handle used\n     * for selecting text. The Drawable defaults to the value of the\n     * textSelectHandleRight attribute.\n     * Note that any change applied to the handle Drawable will not be visible\n     * until the handle is hidden and then drawn again.\n     *\n     * @see #setTextSelectHandleRight(int)\n     * @attr ref android.R.styleable#TextView_textSelectHandleRight\n     ",
    "links" : [ ]
  }, {
    "name" : "public void setTextSelectHandleRight(@DrawableRes int textSelectHandleRight)",
    "returnType" : "void",
    "comment" : "\n     * Sets the Drawable corresponding to the right handle used\n     * for selecting text. The Drawable defaults to the value of the\n     * textSelectHandleRight attribute.\n     * Note that any change applied to the handle Drawable will not be visible\n     * until the handle is hidden and then drawn again.\n     *\n     * @see #setTextSelectHandleRight(Drawable)\n     * @attr ref android.R.styleable#TextView_textSelectHandleRight\n     ",
    "links" : [ ]
  }, {
    "name" : "public Drawable getTextSelectHandleRight()",
    "returnType" : "Drawable",
    "comment" : "\n     * Returns the Drawable corresponding to the right handle used\n     * for selecting text.\n     * Note that any change applied to the handle Drawable will not be visible\n     * until the handle is hidden and then drawn again.\n     *\n     * @return the right text selection handle drawable\n     *\n     * @see #setTextSelectHandleRight(Drawable)\n     * @see #setTextSelectHandleRight(int)\n     * @attr ref android.R.styleable#TextView_textSelectHandleRight\n     ",
    "links" : [ ]
  }, {
    "name" : "public void setTextCursorDrawable(@Nullable Drawable textCursorDrawable)",
    "returnType" : "void",
    "comment" : "\n     * Sets the Drawable corresponding to the text cursor. The Drawable defaults to the\n     * value of the textCursorDrawable attribute.\n     * Note that any change applied to the cursor Drawable will not be visible\n     * until the cursor is hidden and then drawn again.\n     *\n     * @see #setTextCursorDrawable(int)\n     * @attr ref android.R.styleable#TextView_textCursorDrawable\n     ",
    "links" : [ ]
  }, {
    "name" : "public void setTextCursorDrawable(@DrawableRes int textCursorDrawable)",
    "returnType" : "void",
    "comment" : "\n     * Sets the Drawable corresponding to the text cursor. The Drawable defaults to the\n     * value of the textCursorDrawable attribute.\n     * Note that any change applied to the cursor Drawable will not be visible\n     * until the cursor is hidden and then drawn again.\n     *\n     * @see #setTextCursorDrawable(Drawable)\n     * @attr ref android.R.styleable#TextView_textCursorDrawable\n     ",
    "links" : [ ]
  }, {
    "name" : "public Drawable getTextCursorDrawable()",
    "returnType" : "Drawable",
    "comment" : "\n     * Returns the Drawable corresponding to the text cursor.\n     * Note that any change applied to the cursor Drawable will not be visible\n     * until the cursor is hidden and then drawn again.\n     *\n     * @return the text cursor drawable\n     *\n     * @see #setTextCursorDrawable(Drawable)\n     * @see #setTextCursorDrawable(int)\n     * @attr ref android.R.styleable#TextView_textCursorDrawable\n     ",
    "links" : [ ]
  }, {
    "name" : "public void setTextAppearance(@StyleRes int resId)",
    "returnType" : "void",
    "comment" : "\n     * Sets the text appearance from the specified style resource.\n     * <p>\n     * Use a framework-defined {@code TextAppearance} style like\n     * {@link android.R.style#TextAppearance_Material_Body1 @android:style/TextAppearance.Material.Body1}\n     * or see {@link android.R.styleable#TextAppearance TextAppearance} for the\n     * set of attributes that can be used in a custom style.\n     *\n     * @param resId the resource identifier of the style to apply\n     * @attr ref android.R.styleable#TextView_textAppearance\n     ",
    "links" : [ "android.R.style#TextAppearance_Material_Body1", "android.R.styleable#TextAppearance" ]
  }, {
    "name" : "public void setTextAppearance(Context context, @StyleRes int resId)",
    "returnType" : "void",
    "comment" : "\n     * Sets the text color, size, style, hint color, and highlight color\n     * from the specified TextAppearance resource.\n     *\n     * @deprecated Use {@link #setTextAppearance(int)} instead.\n     ",
    "links" : [ "#setTextAppearance(int)" ]
  }, {
    "name" : "private void readTextAppearance(Context context, TypedArray appearance, TextAppearanceAttributes attributes, boolean styleArray)",
    "returnType" : "void",
    "comment" : "\n     * Read the Text Appearance attributes from a given TypedArray and set its values to the given\n     * set. If the TypedArray contains a value that was already set in the given attributes, that\n     * will be overridden.\n     *\n     * @param context The Context to be used\n     * @param appearance The TypedArray to read properties from\n     * @param attributes the TextAppearanceAttributes to fill in\n     * @param styleArray Whether the given TypedArray is a style or a TextAppearance. This defines\n     *                   what attribute indexes will be used to read the properties.\n     ",
    "links" : [ ]
  }, {
    "name" : "private void applyTextAppearance(TextAppearanceAttributes attributes)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private void updateLineBreakConfigFromTextAppearance(boolean isLineBreakStyleSpecified, boolean isLineBreakWordStyleSpecified, @LineBreakConfig.LineBreakStyle int lineBreakStyle, @LineBreakConfig.LineBreakWordStyle int lineBreakWordStyle)",
    "returnType" : "void",
    "comment" : "\n     * Updates the LineBreakConfig from the TextAppearance.\n     *\n     * This method updates the given line configuration from the TextAppearance. This method will\n     * request new layout if line break config has been changed.\n     *\n     * @param isLineBreakStyleSpecified true if the line break style is specified.\n     * @param isLineBreakWordStyleSpecified true if the line break word style is specified.\n     * @param lineBreakStyle the value of the line break style in the TextAppearance.\n     * @param lineBreakWordStyle the value of the line break word style in the TextAppearance.\n     ",
    "links" : [ ]
  }, {
    "name" : "public Locale getTextLocale()",
    "returnType" : "Locale",
    "comment" : "\n     * Get the default primary {@link Locale} of the text in this TextView. This will always be\n     * the first member of {@link #getTextLocales()}.\n     * @return the default primary {@link Locale} of the text in this TextView.\n     ",
    "links" : [ "java.util.Locale", "#getTextLocales()" ]
  }, {
    "name" : "public LocaleList getTextLocales()",
    "returnType" : "LocaleList",
    "comment" : "\n     * Get the default {@link LocaleList} of the text in this TextView.\n     * @return the default {@link LocaleList} of the text in this TextView.\n     ",
    "links" : [ "android.os.LocaleList" ]
  }, {
    "name" : "private void changeListenerLocaleTo(@Nullable Locale locale)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public void setTextLocale(@NonNull Locale locale)",
    "returnType" : "void",
    "comment" : "\n     * Set the default {@link Locale} of the text in this TextView to a one-member\n     * {@link LocaleList} containing just the given Locale.\n     *\n     * @param locale the {@link Locale} for drawing text, must not be null.\n     *\n     * @see #setTextLocales\n     ",
    "links" : [ "java.util.Locale", "android.os.LocaleList" ]
  }, {
    "name" : "public void setTextLocales(@NonNull @Size(min = 1) LocaleList locales)",
    "returnType" : "void",
    "comment" : "\n     * Set the default {@link LocaleList} of the text in this TextView to the given value.\n     *\n     * This value is used to choose appropriate typefaces for ambiguous characters (typically used\n     * for CJK locales to disambiguate Hanzi/Kanji/Hanja characters). It also affects\n     * other aspects of text display, including line breaking.\n     *\n     * @param locales the {@link LocaleList} for drawing text, must not be null or empty.\n     *\n     * @see Paint#setTextLocales\n     ",
    "links" : [ "android.os.LocaleList" ]
  }, {
    "name" : "protected void onConfigurationChanged(Configuration newConfig)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public float getTextSize()",
    "returnType" : "float",
    "comment" : "\n     * @return the size (in pixels) of the default text size in this TextView.\n     ",
    "links" : [ ]
  }, {
    "name" : "public float getScaledTextSize()",
    "returnType" : "float",
    "comment" : "\n     * @return the size (in scaled pixels) of the default text size in this TextView.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public int getTypefaceStyle()",
    "returnType" : "int",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "public void setTextSize(float size)",
    "returnType" : "void",
    "comment" : "\n     * Set the default text size to the given value, interpreted as \"scaled\n     * pixel\" units.  This size is adjusted based on the current density and\n     * user font size preference.\n     *\n     * <p>Note: if this TextView has the auto-size feature enabled, then this function is no-op.\n     *\n     * @param size The scaled pixel size.\n     *\n     * @attr ref android.R.styleable#TextView_textSize\n     ",
    "links" : [ ]
  }, {
    "name" : "public void setTextSize(int unit, float size)",
    "returnType" : "void",
    "comment" : "\n     * Set the default text size to a given unit and value. See {@link\n     * TypedValue} for the possible dimension units.\n     *\n     * <p>Note: if this TextView has the auto-size feature enabled, then this function is no-op.\n     *\n     * @param unit The desired dimension unit.\n     * @param size The desired size in the given units.\n     *\n     * @attr ref android.R.styleable#TextView_textSize\n     ",
    "links" : [ "android.util.TypedValue" ]
  }, {
    "name" : "private DisplayMetrics getDisplayMetricsOrSystem()",
    "returnType" : "DisplayMetrics",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private void setTextSizeInternal(int unit, float size, boolean shouldRequestLayout)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private void setRawTextSize(float size, boolean shouldRequestLayout)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public int getTextSizeUnit()",
    "returnType" : "int",
    "comment" : "\n     * Gets the text size unit defined by the developer. It may be specified in resources or be\n     * passed as the unit argument of {@link #setTextSize(int, float)} at runtime.\n     *\n     * @return the dimension type of the text size unit originally defined.\n     * @see TypedValue#TYPE_DIMENSION\n     ",
    "links" : [ "#setTextSize(int" ]
  }, {
    "name" : "public float getTextScaleX()",
    "returnType" : "float",
    "comment" : "\n     * Gets the extent by which text should be stretched horizontally.\n     * This will usually be 1.0.\n     * @return The horizontal scale factor.\n     ",
    "links" : [ ]
  }, {
    "name" : "public void setTextScaleX(float size)",
    "returnType" : "void",
    "comment" : "\n     * Sets the horizontal scale factor for text. The default value\n     * is 1.0. Values greater than 1.0 stretch the text wider.\n     * Values less than 1.0 make the text narrower. By default, this value is 1.0.\n     * @param size The horizontal scale factor.\n     * @attr ref android.R.styleable#TextView_textScaleX\n     ",
    "links" : [ ]
  }, {
    "name" : "public void setTypeface(@Nullable Typeface tf)",
    "returnType" : "void",
    "comment" : "\n     * Sets the typeface and style in which the text should be displayed.\n     * Note that not all Typeface families actually have bold and italic\n     * variants, so you may need to use\n     * {@link #setTypeface(Typeface, int)} to get the appearance\n     * that you actually want.\n     *\n     * @see #getTypeface()\n     *\n     * @attr ref android.R.styleable#TextView_fontFamily\n     * @attr ref android.R.styleable#TextView_typeface\n     * @attr ref android.R.styleable#TextView_textStyle\n     ",
    "links" : [ "#setTypeface(Typeface" ]
  }, {
    "name" : "public Typeface getTypeface()",
    "returnType" : "Typeface",
    "comment" : "\n     * Gets the current {@link Typeface} that is used to style the text.\n     * @return The current Typeface.\n     *\n     * @see #setTypeface(Typeface)\n     *\n     * @attr ref android.R.styleable#TextView_fontFamily\n     * @attr ref android.R.styleable#TextView_typeface\n     * @attr ref android.R.styleable#TextView_textStyle\n     ",
    "links" : [ "android.graphics.Typeface" ]
  }, {
    "name" : "public void setElegantTextHeight(boolean elegant)",
    "returnType" : "void",
    "comment" : "\n     * Set the TextView's elegant height metrics flag. This setting selects font\n     * variants that have not been compacted to fit Latin-based vertical\n     * metrics, and also increases top and bottom bounds to provide more space.\n     *\n     * @param elegant set the paint's elegant metrics flag.\n     *\n     * @see #isElegantTextHeight()\n     * @see Paint#isElegantTextHeight()\n     *\n     * @attr ref android.R.styleable#TextView_elegantTextHeight\n     ",
    "links" : [ ]
  }, {
    "name" : "public void setFallbackLineSpacing(boolean enabled)",
    "returnType" : "void",
    "comment" : "\n     * Set whether to respect the ascent and descent of the fallback fonts that are used in\n     * displaying the text (which is needed to avoid text from consecutive lines running into\n     * each other). If set, fallback fonts that end up getting used can increase the ascent\n     * and descent of the lines that they are used on.\n     * <p/>\n     * It is required to be true if text could be in languages like Burmese or Tibetan where text\n     * is typically much taller or deeper than Latin text.\n     *\n     * @param enabled whether to expand linespacing based on fallback fonts, {@code true} by default\n     *\n     * @see StaticLayout.Builder#setUseLineSpacingFromFallbacks(boolean)\n     *\n     * @attr ref android.R.styleable#TextView_fallbackLineSpacing\n     ",
    "links" : [ ]
  }, {
    "name" : "public void setUseBoundsForWidth(boolean useBoundsForWidth)",
    "returnType" : "void",
    "comment" : "\n     * Set true for using width of bounding box as a source of automatic line breaking and drawing.\n     *\n     * If this value is false, the TextView determines the View width, drawing offset and automatic\n     * line breaking based on total advances as text widths. By setting true, use glyph bound's as a\n     * source of text width.\n     *\n     * If the font used for this TextView has glyphs that has negative bearing X or glyph xMax is\n     * greater than advance, the glyph clipping can be happened because the drawing area may be\n     * bigger than advance. By setting this to true, the TextView will reserve more spaces for\n     * drawing are, so clipping can be prevented.\n     *\n     * This value is true by default if the target API version is 35 or later.\n     *\n     * @param useBoundsForWidth true for using bounding box for width. false for using advances for\n     *                          width.\n     * @see #getUseBoundsForWidth()\n     * @see #setShiftDrawingOffsetForStartOverhang(boolean)\n     * @see #getShiftDrawingOffsetForStartOverhang()\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean getUseBoundsForWidth()",
    "returnType" : "boolean",
    "comment" : "\n     * Returns true if using bounding box as a width, false for using advance as a width.\n     *\n     * @see #setUseBoundsForWidth(boolean)\n     * @see #setShiftDrawingOffsetForStartOverhang(boolean)\n     * @see #getShiftDrawingOffsetForStartOverhang()\n     * @return True if using bounding box for width, false if using advance for width.\n     ",
    "links" : [ ]
  }, {
    "name" : "public void setShiftDrawingOffsetForStartOverhang(boolean shiftDrawingOffsetForStartOverhang)",
    "returnType" : "void",
    "comment" : "\n     * Set true for shifting the drawing x offset for showing overhang at the start position.\n     *\n     * This flag is ignored if the {@link #getUseBoundsForWidth()} is false.\n     *\n     * If this value is false, the TextView draws text from the zero even if there is a glyph stroke\n     * in a region where the x coordinate is negative. TextView clips the stroke in the region where\n     * the X coordinate is negative unless the parents has {@link ViewGroup#getClipChildren()} to\n     * true. This is useful for aligning multiple TextViews vertically.\n     *\n     * If this value is true, the TextView draws text with shifting the x coordinate of the drawing\n     * bounding box. This prevents the clipping even if the parents doesn't have\n     * {@link ViewGroup#getClipChildren()} to true.\n     *\n     * This value is false by default.\n     *\n     * @param shiftDrawingOffsetForStartOverhang true for shifting the drawing offset for showing\n     *                                           the stroke that is in the region whre the x\n     *                                           coorinate is negative.\n     * @see #setUseBoundsForWidth(boolean)\n     * @see #getUseBoundsForWidth()\n     ",
    "links" : [ "#getUseBoundsForWidth()", "android.view.ViewGroup#getClipChildren()" ]
  }, {
    "name" : "public boolean getShiftDrawingOffsetForStartOverhang()",
    "returnType" : "boolean",
    "comment" : "\n     * Returns true if shifting the drawing x offset for start overhang.\n     *\n     * @see #setShiftDrawingOffsetForStartOverhang(boolean)\n     * @see #setUseBoundsForWidth(boolean)\n     * @see #getUseBoundsForWidth()\n     * @return True if shifting the drawing x offset for start overhang.\n     ",
    "links" : [ ]
  }, {
    "name" : "public void setMinimumFontMetrics(@Nullable Paint.FontMetrics minimumFontMetrics)",
    "returnType" : "void",
    "comment" : "\n     * Set the minimum font metrics used for line spacing.\n     *\n     * <p>\n     * {@code null} is the default value. If {@code null} is set or left as default, the font\n     * metrics obtained by {@link Paint#getFontMetricsForLocale(Paint.FontMetrics)} is used.\n     *\n     * <p>\n     * The minimum meaning here is the minimum value of line spacing: maximum value of\n     * {@link Paint#ascent()}, minimum value of {@link Paint#descent()}.\n     *\n     * <p>\n     * By setting this value, each line will have minimum line spacing regardless of the text\n     * rendered. For example, usually Japanese script has larger vertical metrics than Latin script.\n     * By setting the metrics obtained by {@link Paint#getFontMetricsForLocale(Paint.FontMetrics)}\n     * for Japanese or leave it {@code null} if the TextView's locale or system locale is Japanese,\n     * the line spacing for Japanese is reserved if the TextView contains English text. If the\n     * vertical metrics of the text is larger than Japanese, for example Burmese, the bigger font\n     * metrics is used.\n     *\n     * @param minimumFontMetrics A minimum font metrics. Passing {@code null} for using the value\n     *                           obtained by\n     *                           {@link Paint#getFontMetricsForLocale(Paint.FontMetrics)}\n     * @see #getMinimumFontMetrics()\n     * @see Layout#getMinimumFontMetrics()\n     * @see Layout.Builder#setMinimumFontMetrics(Paint.FontMetrics)\n     * @see StaticLayout.Builder#setMinimumFontMetrics(Paint.FontMetrics)\n     * @see DynamicLayout.Builder#setMinimumFontMetrics(Paint.FontMetrics)\n     ",
    "links" : [ "android.graphics.Paint#descent()", "android.graphics.Paint#getFontMetricsForLocale(Paint.FontMetrics)", "android.graphics.Paint#ascent()" ]
  }, {
    "name" : "public Paint.FontMetrics getMinimumFontMetrics()",
    "returnType" : "Paint.FontMetrics",
    "comment" : "\n     * Get the minimum font metrics used for line spacing.\n     *\n     * @see #setMinimumFontMetrics(Paint.FontMetrics)\n     * @see Layout#getMinimumFontMetrics()\n     * @see Layout.Builder#setMinimumFontMetrics(Paint.FontMetrics)\n     * @see StaticLayout.Builder#setMinimumFontMetrics(Paint.FontMetrics)\n     * @see DynamicLayout.Builder#setMinimumFontMetrics(Paint.FontMetrics)\n     *\n     * @return a minimum font metrics. {@code null} for using the value obtained by\n     *         {@link Paint#getFontMetricsForLocale(Paint.FontMetrics)}\n     ",
    "links" : [ "android.graphics.Paint#getFontMetricsForLocale(Paint.FontMetrics)" ]
  }, {
    "name" : "public boolean isLocalePreferredLineHeightForMinimumUsed()",
    "returnType" : "boolean",
    "comment" : "\n     * Returns true if the locale preferred line height is used for the minimum line height.\n     *\n     * @return true if using locale preferred line height for the minimum line height. Otherwise\n     *         false.\n     *\n     * @see #setLocalePreferredLineHeightForMinimumUsed(boolean)\n     * @see #setMinimumFontMetrics(Paint.FontMetrics)\n     * @see #getMinimumFontMetrics()\n     ",
    "links" : [ ]
  }, {
    "name" : "public void setLocalePreferredLineHeightForMinimumUsed(boolean flag)",
    "returnType" : "void",
    "comment" : "\n     * Set true if the locale preferred line height is used for the minimum line height.\n     *\n     * By setting this flag to true is equivalenet to call\n     * {@link #setMinimumFontMetrics(Paint.FontMetrics)} with the one obtained by\n     * {@link Paint#getFontMetricsForLocale(Paint.FontMetrics)}.\n     *\n     * If custom minimum line height was specified by\n     * {@link #setMinimumFontMetrics(Paint.FontMetrics)}, this flag will be ignored.\n     *\n     * @param flag true for using locale preferred line height for the minimum line height.\n     * @see #isLocalePreferredLineHeightForMinimumUsed()\n     * @see #setMinimumFontMetrics(Paint.FontMetrics)\n     * @see #getMinimumFontMetrics()\n     ",
    "links" : [ "android.graphics.Paint#getFontMetricsForLocale(Paint.FontMetrics)", "#setMinimumFontMetrics(Paint.FontMetrics)" ]
  }, {
    "name" : "public boolean isFallbackLineSpacing()",
    "returnType" : "boolean",
    "comment" : "\n     * @return whether fallback line spacing is enabled, {@code true} by default\n     *\n     * @see #setFallbackLineSpacing(boolean)\n     *\n     * @attr ref android.R.styleable#TextView_fallbackLineSpacing\n     ",
    "links" : [ ]
  }, {
    "name" : "private boolean isFallbackLineSpacingForBoringLayout()",
    "returnType" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : " boolean isFallbackLineSpacingForStaticLayout()",
    "returnType" : "boolean",
    "comment" : " package ",
    "links" : [ ]
  }, {
    "name" : "public boolean isElegantTextHeight()",
    "returnType" : "boolean",
    "comment" : "\n     * Get the value of the TextView's elegant height metrics flag. This setting selects font\n     * variants that have not been compacted to fit Latin-based vertical\n     * metrics, and also increases top and bottom bounds to provide more space.\n     * @return {@code true} if the elegant height metrics flag is set.\n     *\n     * @see #setElegantTextHeight(boolean)\n     * @see Paint#setElegantTextHeight(boolean)\n     ",
    "links" : [ ]
  }, {
    "name" : "public float getLetterSpacing()",
    "returnType" : "float",
    "comment" : "\n     * Gets the text letter-space value, which determines the spacing between characters.\n     * The value returned is in ems. Normally, this value is 0.0.\n     * @return The text letter-space value in ems.\n     *\n     * @see #setLetterSpacing(float)\n     * @see Paint#setLetterSpacing\n     ",
    "links" : [ ]
  }, {
    "name" : "public void setLetterSpacing(float letterSpacing)",
    "returnType" : "void",
    "comment" : "\n     * Sets text letter-spacing in em units.  Typical values\n     * for slight expansion will be around 0.05.  Negative values tighten text.\n     *\n     * @see #getLetterSpacing()\n     * @see Paint#getLetterSpacing\n     *\n     * @param letterSpacing A text letter-space value in ems.\n     * @attr ref android.R.styleable#TextView_letterSpacing\n     ",
    "links" : [ ]
  }, {
    "name" : "public String getFontFeatureSettings()",
    "returnType" : "String",
    "comment" : "\n     * Returns the font feature settings. The format is the same as the CSS\n     * font-feature-settings attribute:\n     * <a href=\"https://www.w3.org/TR/css-fonts-3/#font-feature-settings-prop\">\n     *     https://www.w3.org/TR/css-fonts-3/#font-feature-settings-prop</a>\n     *\n     * @return the currently set font feature settings.  Default is null.\n     *\n     * @see #setFontFeatureSettings(String)\n     * @see Paint#setFontFeatureSettings(String) Paint.setFontFeatureSettings(String)\n     ",
    "links" : [ ]
  }, {
    "name" : "public String getFontVariationSettings()",
    "returnType" : "String",
    "comment" : "\n     * Returns the font variation settings.\n     *\n     * @return the currently set font variation settings.  Returns null if no variation is\n     * specified.\n     *\n     * @see #setFontVariationSettings(String)\n     * @see Paint#setFontVariationSettings(String) Paint.setFontVariationSettings(String)\n     ",
    "links" : [ ]
  }, {
    "name" : "public void setBreakStrategy(@Layout.BreakStrategy int breakStrategy)",
    "returnType" : "void",
    "comment" : "\n     * Sets the break strategy for breaking paragraphs into lines. The default value for\n     * TextView is {@link Layout#BREAK_STRATEGY_HIGH_QUALITY}, and the default value for\n     * EditText is {@link Layout#BREAK_STRATEGY_SIMPLE}, the latter to avoid the\n     * text \"dancing\" when being edited.\n     * <p>\n     * Enabling hyphenation with either using {@link Layout#HYPHENATION_FREQUENCY_NORMAL} or\n     * {@link Layout#HYPHENATION_FREQUENCY_FULL} while line breaking is set to one of\n     * {@link Layout#BREAK_STRATEGY_BALANCED}, {@link Layout#BREAK_STRATEGY_HIGH_QUALITY}\n     * improves the structure of text layout however has performance impact and requires more time\n     * to do the text layout.</p>\n     * <p>\n     * Compared with {@link #setLineBreakStyle(int)}, line break style with different strictness is\n     * evaluated in the ICU to identify the potential breakpoints. In\n     * {@link #setBreakStrategy(int)}, line break strategy handles the post processing of ICU's line\n     * break result. It aims to evaluate ICU's breakpoints and break the lines based on the\n     * constraint.\n     * </p>\n     *\n     * @attr ref android.R.styleable#TextView_breakStrategy\n     * @see #getBreakStrategy()\n     * @see #setHyphenationFrequency(int)\n     ",
    "links" : [ "android.text.BoringLayout#BREAK_STRATEGY_HIGH_QUALITY", "android.text.BoringLayout#HYPHENATION_FREQUENCY_NORMAL", "#setLineBreakStyle(int)", "android.text.BoringLayout#BREAK_STRATEGY_SIMPLE", "android.text.BoringLayout#HYPHENATION_FREQUENCY_FULL", "android.text.BoringLayout#BREAK_STRATEGY_BALANCED", "#setBreakStrategy(int)" ]
  }, {
    "name" : "public int getBreakStrategy()",
    "returnType" : "int",
    "comment" : "\n     * Gets the current strategy for breaking paragraphs into lines.\n     * @return the current strategy for breaking paragraphs into lines.\n     *\n     * @attr ref android.R.styleable#TextView_breakStrategy\n     * @see #setBreakStrategy(int)\n     ",
    "links" : [ ]
  }, {
    "name" : "public void setHyphenationFrequency(@Layout.HyphenationFrequency int hyphenationFrequency)",
    "returnType" : "void",
    "comment" : "\n     * Sets the frequency of automatic hyphenation to use when determining word breaks.\n     * The default value for both TextView and {@link EditText} is\n     * {@link Layout#HYPHENATION_FREQUENCY_NONE}. Note that the default hyphenation frequency value\n     * is set from the theme.\n     * <p/>\n     * Enabling hyphenation with either using {@link Layout#HYPHENATION_FREQUENCY_NORMAL} or\n     * {@link Layout#HYPHENATION_FREQUENCY_FULL} while line breaking is set to one of\n     * {@link Layout#BREAK_STRATEGY_BALANCED}, {@link Layout#BREAK_STRATEGY_HIGH_QUALITY}\n     * improves the structure of text layout however has performance impact and requires more time\n     * to do the text layout.\n     * <p/>\n     * Note: Before Android Q, in the theme hyphenation frequency is set to\n     * {@link Layout#HYPHENATION_FREQUENCY_NORMAL}. The default value is changed into\n     * {@link Layout#HYPHENATION_FREQUENCY_NONE} on Q.\n     *\n     * @param hyphenationFrequency the hyphenation frequency to use, one of\n     *                             {@link Layout#HYPHENATION_FREQUENCY_NONE},\n     *                             {@link Layout#HYPHENATION_FREQUENCY_NORMAL},\n     *                             {@link Layout#HYPHENATION_FREQUENCY_FULL}\n     * @attr ref android.R.styleable#TextView_hyphenationFrequency\n     * @see #getHyphenationFrequency()\n     * @see #getBreakStrategy()\n     ",
    "links" : [ "android.text.BoringLayout#BREAK_STRATEGY_HIGH_QUALITY", "android.text.BoringLayout#HYPHENATION_FREQUENCY_NORMAL", "android.text.BoringLayout#HYPHENATION_FREQUENCY_NONE", "android.text.BoringLayout#HYPHENATION_FREQUENCY_FULL", "android.text.BoringLayout#BREAK_STRATEGY_BALANCED", "android.widget.EditText" ]
  }, {
    "name" : "public int getHyphenationFrequency()",
    "returnType" : "int",
    "comment" : "\n     * Gets the current frequency of automatic hyphenation to be used when determining word breaks.\n     * @return the current frequency of automatic hyphenation to be used when determining word\n     * breaks.\n     *\n     * @attr ref android.R.styleable#TextView_hyphenationFrequency\n     * @see #setHyphenationFrequency(int)\n     ",
    "links" : [ ]
  }, {
    "name" : "public void setLineBreakStyle(@LineBreakConfig.LineBreakStyle int lineBreakStyle)",
    "returnType" : "void",
    "comment" : "\n     * Sets the line-break style for text wrapping.\n     *\n     * <p>Line-break style specifies the line-break strategies that can be used\n     * for text wrapping. The line-break style affects rule-based line breaking\n     * by specifying the strictness of line-breaking rules.\n     *\n     * <p>The following are types of line-break styles:\n     * <ul>\n     *   <li>{@link LineBreakConfig#LINE_BREAK_STYLE_LOOSE}\n     *   <li>{@link LineBreakConfig#LINE_BREAK_STYLE_NORMAL}\n     *   <li>{@link LineBreakConfig#LINE_BREAK_STYLE_STRICT}\n     * </ul>\n     *\n     * <p>The default line-break style is\n     * {@link LineBreakConfig#LINE_BREAK_STYLE_NONE}, which specifies that no\n     * line-breaking rules are used.\n     *\n     * <p>See the\n     * <a href=\"https://www.w3.org/TR/css-text-3/#line-break-property\" class=\"external\">\n     * line-break property</a> for more information.\n     *\n     * @param lineBreakStyle The line-break style for the text.\n     ",
    "links" : [ "android.graphics.text.LineBreakConfig#LINE_BREAK_STYLE_NORMAL", "android.graphics.text.LineBreakConfig#LINE_BREAK_STYLE_STRICT", "android.graphics.text.LineBreakConfig#LINE_BREAK_STYLE_NONE", "android.graphics.text.LineBreakConfig#LINE_BREAK_STYLE_LOOSE" ]
  }, {
    "name" : "public void setLineBreakWordStyle(@LineBreakConfig.LineBreakWordStyle int lineBreakWordStyle)",
    "returnType" : "void",
    "comment" : "\n     * Sets the line-break word style for text wrapping.\n     *\n     * <p>The line-break word style affects dictionary-based line breaking by\n     * providing phrase-based line-breaking opportunities. Use\n     * {@link LineBreakConfig#LINE_BREAK_WORD_STYLE_PHRASE} to specify\n     * phrase-based line breaking.\n     *\n     * <p>The default line-break word style is\n     * {@link LineBreakConfig#LINE_BREAK_WORD_STYLE_NONE}, which specifies that\n     * no line-breaking word style is used.\n     *\n     * <p>See the\n     * <a href=\"https://www.w3.org/TR/css-text-3/#word-break-property\" class=\"external\">\n     * word-break property</a> for more information.\n     *\n     * @param lineBreakWordStyle The line-break word style for the text.\n     ",
    "links" : [ "android.graphics.text.LineBreakConfig#LINE_BREAK_WORD_STYLE_PHRASE", "android.graphics.text.LineBreakConfig#LINE_BREAK_WORD_STYLE_NONE" ]
  }, {
    "name" : "public int getLineBreakStyle()",
    "returnType" : "int",
    "comment" : "\n     * Gets the current line-break style for text wrapping.\n     *\n     * @return The line-break style to be used for text wrapping.\n     ",
    "links" : [ ]
  }, {
    "name" : "public int getLineBreakWordStyle()",
    "returnType" : "int",
    "comment" : "\n     * Gets the current line-break word style for text wrapping.\n     *\n     * @return The line-break word style to be used for text wrapping.\n     ",
    "links" : [ ]
  }, {
    "name" : "public PrecomputedText.Params getTextMetricsParams()",
    "returnType" : "PrecomputedText.Params",
    "comment" : "\n     * Gets the parameters for text layout precomputation, for use with {@link PrecomputedText}.\n     *\n     * @return a current {@link PrecomputedText.Params}\n     * @see PrecomputedText\n     ",
    "links" : [ "PrecomputedText.Params", "android.text.PrecomputedText" ]
  }, {
    "name" : "public void setTextMetricsParams(@NonNull PrecomputedText.Params params)",
    "returnType" : "void",
    "comment" : "\n     * Apply the text layout parameter.\n     *\n     * Update the TextView parameters to be compatible with {@link PrecomputedText.Params}.\n     * @see PrecomputedText\n     ",
    "links" : [ "PrecomputedText.Params" ]
  }, {
    "name" : "public void setJustificationMode(@Layout.JustificationMode int justificationMode)",
    "returnType" : "void",
    "comment" : "\n     * Set justification mode. The default value is {@link Layout#JUSTIFICATION_MODE_NONE}. If the\n     * last line is too short for justification, the last line will be displayed with the\n     * alignment set by {@link android.view.View#setTextAlignment}.\n     *\n     * @see #getJustificationMode()\n     ",
    "links" : [ "android.text.BoringLayout#JUSTIFICATION_MODE_NONE", "android.view.View#setTextAlignment" ]
  }, {
    "name" : "public int getJustificationMode()",
    "returnType" : "int",
    "comment" : "\n     * @return true if currently paragraph justification mode.\n     *\n     * @see #setJustificationMode(int)\n     ",
    "links" : [ ]
  }, {
    "name" : "public void setFontFeatureSettings(@Nullable String fontFeatureSettings)",
    "returnType" : "void",
    "comment" : "\n     * Sets font feature settings. The format is the same as the CSS\n     * font-feature-settings attribute:\n     * <a href=\"https://www.w3.org/TR/css-fonts-3/#font-feature-settings-prop\">\n     *     https://www.w3.org/TR/css-fonts-3/#font-feature-settings-prop</a>\n     *\n     * @param fontFeatureSettings font feature settings represented as CSS compatible string\n     *\n     * @see #getFontFeatureSettings()\n     * @see Paint#getFontFeatureSettings() Paint.getFontFeatureSettings()\n     *\n     * @attr ref android.R.styleable#TextView_fontFeatureSettings\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean setFontVariationSettings(@Nullable String fontVariationSettings)",
    "returnType" : "boolean",
    "comment" : "\n     * Sets TrueType or OpenType font variation settings. The settings string is constructed from\n     * multiple pairs of axis tag and style values. The axis tag must contain four ASCII characters\n     * and must be wrapped with single quotes (U+0027) or double quotes (U+0022). Axis strings that\n     * are longer or shorter than four characters, or contain characters outside of U+0020..U+007E\n     * are invalid. If a specified axis name is not defined in the font, the settings will be\n     * ignored.\n     *\n     * <p>\n     * Examples,\n     * <ul>\n     * <li>Set font width to 150.\n     * <pre>\n     * <code>\n     *   TextView textView = (TextView) findViewById(R.id.textView);\n     *   textView.setFontVariationSettings(\"'wdth' 150\");\n     * </code>\n     * </pre>\n     * </li>\n     *\n     * <li>Set the font slant to 20 degrees and ask for italic style.\n     * <pre>\n     * <code>\n     *   TextView textView = (TextView) findViewById(R.id.textView);\n     *   textView.setFontVariationSettings(\"'slnt' 20, 'ital' 1\");\n     * </code>\n     * </pre>\n     * </p>\n     * </li>\n     * </ul>\n     *\n     * @param fontVariationSettings font variation settings. You can pass null or empty string as\n     *                              no variation settings.\n     * @return true if the given settings is effective to at least one font file underlying this\n     *         TextView. This function also returns true for empty settings string. Otherwise\n     *         returns false.\n     *\n     * @throws IllegalArgumentException If given string is not a valid font variation settings\n     *                                  format.\n     *\n     * @see #getFontVariationSettings()\n     * @see FontVariationAxis\n     *\n     * @attr ref android.R.styleable#TextView_fontVariationSettings\n     ",
    "links" : [ ]
  }, {
    "name" : "public void setTextColor(@ColorInt int color)",
    "returnType" : "void",
    "comment" : "\n     * Sets the text color for all the states (normal, selected,\n     * focused) to be this color.\n     *\n     * @param color A color value in the form 0xAARRGGBB.\n     * Do not pass a resource ID. To get a color value from a resource ID, call\n     * {@link androidx.core.content.ContextCompat#getColor(Context, int) getColor}.\n     *\n     * @see #setTextColor(ColorStateList)\n     * @see #getTextColors()\n     *\n     * @attr ref android.R.styleable#TextView_textColor\n     ",
    "links" : [ "androidx.core.content.ContextCompat#getColor(Context" ]
  }, {
    "name" : "public void setTextColor(ColorStateList colors)",
    "returnType" : "void",
    "comment" : "\n     * Sets the text color.\n     *\n     * @see #setTextColor(int)\n     * @see #getTextColors()\n     * @see #setHintTextColor(ColorStateList)\n     * @see #setLinkTextColor(ColorStateList)\n     *\n     * @attr ref android.R.styleable#TextView_textColor\n     ",
    "links" : [ ]
  }, {
    "name" : "public final ColorStateList getTextColors()",
    "returnType" : "ColorStateList",
    "comment" : "\n     * Gets the text colors for the different states (normal, selected, focused) of the TextView.\n     *\n     * @see #setTextColor(ColorStateList)\n     * @see #setTextColor(int)\n     *\n     * @attr ref android.R.styleable#TextView_textColor\n     ",
    "links" : [ ]
  }, {
    "name" : "public final int getCurrentTextColor()",
    "returnType" : "int",
    "comment" : "\n     * Return the current color selected for normal text.\n     *\n     * @return Returns the current text color.\n     ",
    "links" : [ ]
  }, {
    "name" : "public void setHighlightColor(@ColorInt int color)",
    "returnType" : "void",
    "comment" : "\n     * Sets the color used to display the selection highlight.\n     *\n     * @attr ref android.R.styleable#TextView_textColorHighlight\n     ",
    "links" : [ ]
  }, {
    "name" : "public int getHighlightColor()",
    "returnType" : "int",
    "comment" : "\n     * @return the color used to display the selection highlight\n     *\n     * @see #setHighlightColor(int)\n     *\n     * @attr ref android.R.styleable#TextView_textColorHighlight\n     ",
    "links" : [ ]
  }, {
    "name" : "public final void setShowSoftInputOnFocus(boolean show)",
    "returnType" : "void",
    "comment" : "\n     * Sets whether the soft input method will be made visible when this\n     * TextView gets focused. The default is true.\n     ",
    "links" : [ ]
  }, {
    "name" : "public final boolean getShowSoftInputOnFocus()",
    "returnType" : "boolean",
    "comment" : "\n     * Returns whether the soft input method will be made visible when this\n     * TextView gets focused. The default is true.\n     ",
    "links" : [ ]
  }, {
    "name" : "public void setShadowLayer(float radius, float dx, float dy, int color)",
    "returnType" : "void",
    "comment" : "\n     * Gives the text a shadow of the specified blur radius and color, the specified\n     * distance from its drawn position.\n     * <p>\n     * The text shadow produced does not interact with the properties on view\n     * that are responsible for real time shadows,\n     * {@link View#getElevation() elevation} and\n     * {@link View#getTranslationZ() translationZ}.\n     *\n     * @see Paint#setShadowLayer(float, float, float, int)\n     *\n     * @attr ref android.R.styleable#TextView_shadowColor\n     * @attr ref android.R.styleable#TextView_shadowDx\n     * @attr ref android.R.styleable#TextView_shadowDy\n     * @attr ref android.R.styleable#TextView_shadowRadius\n     ",
    "links" : [ "android.view.View#getTranslationZ()", "android.view.View#getElevation()" ]
  }, {
    "name" : "public float getShadowRadius()",
    "returnType" : "float",
    "comment" : "\n     * Gets the radius of the shadow layer.\n     *\n     * @return the radius of the shadow layer. If 0, the shadow layer is not visible\n     *\n     * @see #setShadowLayer(float, float, float, int)\n     *\n     * @attr ref android.R.styleable#TextView_shadowRadius\n     ",
    "links" : [ ]
  }, {
    "name" : "public float getShadowDx()",
    "returnType" : "float",
    "comment" : "\n     * @return the horizontal offset of the shadow layer\n     *\n     * @see #setShadowLayer(float, float, float, int)\n     *\n     * @attr ref android.R.styleable#TextView_shadowDx\n     ",
    "links" : [ ]
  }, {
    "name" : "public float getShadowDy()",
    "returnType" : "float",
    "comment" : "\n     * Gets the vertical offset of the shadow layer.\n     * @return The vertical offset of the shadow layer.\n     *\n     * @see #setShadowLayer(float, float, float, int)\n     *\n     * @attr ref android.R.styleable#TextView_shadowDy\n     ",
    "links" : [ ]
  }, {
    "name" : "public int getShadowColor()",
    "returnType" : "int",
    "comment" : "\n     * Gets the color of the shadow layer.\n     * @return the color of the shadow layer\n     *\n     * @see #setShadowLayer(float, float, float, int)\n     *\n     * @attr ref android.R.styleable#TextView_shadowColor\n     ",
    "links" : [ ]
  }, {
    "name" : "public TextPaint getPaint()",
    "returnType" : "TextPaint",
    "comment" : "\n     * Gets the {@link TextPaint} used for the text.\n     * Use this only to consult the Paint's properties and not to change them.\n     * @return The base paint used for the text.\n     ",
    "links" : [ "android.text.TextPaint" ]
  }, {
    "name" : "public final void setAutoLinkMask(int mask)",
    "returnType" : "void",
    "comment" : "\n     * Sets the autolink mask of the text.  See {@link\n     * android.text.util.Linkify#ALL Linkify.ALL} and peers for\n     * possible values.\n     *\n     * <p class=\"note\"><b>Note:</b>\n     * {@link android.text.util.Linkify#MAP_ADDRESSES Linkify.MAP_ADDRESSES}\n     * is deprecated and should be avoided; see its documentation.\n     *\n     * @attr ref android.R.styleable#TextView_autoLink\n     ",
    "links" : [ "android.text.util.Linkify#ALL", "android.text.util.Linkify#MAP_ADDRESSES" ]
  }, {
    "name" : "public final void setLinksClickable(boolean whether)",
    "returnType" : "void",
    "comment" : "\n     * Sets whether the movement method will automatically be set to\n     * {@link LinkMovementMethod} if {@link #setAutoLinkMask} has been\n     * set to nonzero and links are detected in {@link #setText}.\n     * The default is true.\n     *\n     * @attr ref android.R.styleable#TextView_linksClickable\n     ",
    "links" : [ "#setText", "android.text.method.LinkMovementMethod", "#setAutoLinkMask" ]
  }, {
    "name" : "public final boolean getLinksClickable()",
    "returnType" : "boolean",
    "comment" : "\n     * Returns whether the movement method will automatically be set to\n     * {@link LinkMovementMethod} if {@link #setAutoLinkMask} has been\n     * set to nonzero and links are detected in {@link #setText}.\n     * The default is true.\n     *\n     * @attr ref android.R.styleable#TextView_linksClickable\n     ",
    "links" : [ "#setText", "android.text.method.LinkMovementMethod", "#setAutoLinkMask" ]
  }, {
    "name" : "public URLSpan[] getUrls()",
    "returnType" : "URLSpan[]",
    "comment" : "\n     * Returns the list of {@link android.text.style.URLSpan URLSpans} attached to the text\n     * (by {@link Linkify} or otherwise) if any.  You can call\n     * {@link URLSpan#getURL} on them to find where they link to\n     * or use {@link Spanned#getSpanStart} and {@link Spanned#getSpanEnd}\n     * to find the region of the text they are attached to.\n     ",
    "links" : [ "android.text.style.URLSpan", "android.text.Spanned#getSpanStart", "android.text.Spanned#getSpanEnd", "android.text.util.Linkify", "android.text.style.URLSpan#getURL" ]
  }, {
    "name" : "public final void setHintTextColor(@ColorInt int color)",
    "returnType" : "void",
    "comment" : "\n     * Sets the color of the hint text for all the states (disabled, focussed, selected...) of this\n     * TextView.\n     *\n     * @see #setHintTextColor(ColorStateList)\n     * @see #getHintTextColors()\n     * @see #setTextColor(int)\n     *\n     * @attr ref android.R.styleable#TextView_textColorHint\n     ",
    "links" : [ ]
  }, {
    "name" : "public final void setHintTextColor(ColorStateList colors)",
    "returnType" : "void",
    "comment" : "\n     * Sets the color of the hint text.\n     *\n     * @see #getHintTextColors()\n     * @see #setHintTextColor(int)\n     * @see #setTextColor(ColorStateList)\n     * @see #setLinkTextColor(ColorStateList)\n     *\n     * @attr ref android.R.styleable#TextView_textColorHint\n     ",
    "links" : [ ]
  }, {
    "name" : "public final ColorStateList getHintTextColors()",
    "returnType" : "ColorStateList",
    "comment" : "\n     * @return the color of the hint text, for the different states of this TextView.\n     *\n     * @see #setHintTextColor(ColorStateList)\n     * @see #setHintTextColor(int)\n     * @see #setTextColor(ColorStateList)\n     * @see #setLinkTextColor(ColorStateList)\n     *\n     * @attr ref android.R.styleable#TextView_textColorHint\n     ",
    "links" : [ ]
  }, {
    "name" : "public final int getCurrentHintTextColor()",
    "returnType" : "int",
    "comment" : "\n     * <p>Return the current color selected to paint the hint text.</p>\n     *\n     * @return Returns the current hint text color.\n     ",
    "links" : [ ]
  }, {
    "name" : "public final void setLinkTextColor(@ColorInt int color)",
    "returnType" : "void",
    "comment" : "\n     * Sets the color of links in the text.\n     *\n     * @see #setLinkTextColor(ColorStateList)\n     * @see #getLinkTextColors()\n     *\n     * @attr ref android.R.styleable#TextView_textColorLink\n     ",
    "links" : [ ]
  }, {
    "name" : "public final void setLinkTextColor(ColorStateList colors)",
    "returnType" : "void",
    "comment" : "\n     * Sets the color of links in the text.\n     *\n     * @see #setLinkTextColor(int)\n     * @see #getLinkTextColors()\n     * @see #setTextColor(ColorStateList)\n     * @see #setHintTextColor(ColorStateList)\n     *\n     * @attr ref android.R.styleable#TextView_textColorLink\n     ",
    "links" : [ ]
  }, {
    "name" : "public final ColorStateList getLinkTextColors()",
    "returnType" : "ColorStateList",
    "comment" : "\n     * @return the list of colors used to paint the links in the text, for the different states of\n     * this TextView\n     *\n     * @see #setLinkTextColor(ColorStateList)\n     * @see #setLinkTextColor(int)\n     *\n     * @attr ref android.R.styleable#TextView_textColorLink\n     ",
    "links" : [ ]
  }, {
    "name" : "public void setGravity(int gravity)",
    "returnType" : "void",
    "comment" : "\n     * Sets the horizontal alignment of the text and the\n     * vertical gravity that will be used when there is extra space\n     * in the TextView beyond what is required for the text itself.\n     *\n     * @see android.view.Gravity\n     * @attr ref android.R.styleable#TextView_gravity\n     ",
    "links" : [ ]
  }, {
    "name" : "public int getGravity()",
    "returnType" : "int",
    "comment" : "\n     * Returns the horizontal and vertical alignment of this TextView.\n     *\n     * @see android.view.Gravity\n     * @attr ref android.R.styleable#TextView_gravity\n     ",
    "links" : [ ]
  }, {
    "name" : "public int getPaintFlags()",
    "returnType" : "int",
    "comment" : "\n     * Gets the flags on the Paint being used to display the text.\n     * @return The flags on the Paint being used to display the text.\n     * @see Paint#getFlags\n     ",
    "links" : [ ]
  }, {
    "name" : "public void setPaintFlags(int flags)",
    "returnType" : "void",
    "comment" : "\n     * Sets flags on the Paint being used to display the text and\n     * reflows the text if they are different from the old flags.\n     * @see Paint#setFlags\n     ",
    "links" : [ ]
  }, {
    "name" : "public void setHorizontallyScrolling(boolean whether)",
    "returnType" : "void",
    "comment" : "\n     * Sets whether the text should be allowed to be wider than the\n     * View is.  If false, it will be wrapped to the width of the View.\n     *\n     * @attr ref android.R.styleable#TextView_scrollHorizontally\n     ",
    "links" : [ ]
  }, {
    "name" : "public final boolean isHorizontallyScrollable()",
    "returnType" : "boolean",
    "comment" : "\n     * Returns whether the text is allowed to be wider than the View.\n     * If false, the text will be wrapped to the width of the View.\n     *\n     * @attr ref android.R.styleable#TextView_scrollHorizontally\n     * @see #setHorizontallyScrolling(boolean)\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean getHorizontallyScrolling()",
    "returnType" : "boolean",
    "comment" : "\n     * Returns whether the text is allowed to be wider than the View.\n     * If false, the text will be wrapped to the width of the View.\n     *\n     * @attr ref android.R.styleable#TextView_scrollHorizontally\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public void setMinLines(int minLines)",
    "returnType" : "void",
    "comment" : "\n     * Sets the height of the TextView to be at least {@code minLines} tall.\n     * <p>\n     * This value is used for height calculation if LayoutParams does not force TextView to have an\n     * exact height. Setting this value overrides other previous minimum height configurations such\n     * as {@link #setMinHeight(int)} or {@link #setHeight(int)}. {@link #setSingleLine()} will set\n     * this value to 1.\n     *\n     * @param minLines the minimum height of TextView in terms of number of lines\n     *\n     * @see #getMinLines()\n     * @see #setLines(int)\n     *\n     * @attr ref android.R.styleable#TextView_minLines\n     ",
    "links" : [ "#setSingleLine()", "#setHeight(int)", "#setMinHeight(int)" ]
  }, {
    "name" : "public int getMinLines()",
    "returnType" : "int",
    "comment" : "\n     * Returns the minimum height of TextView in terms of number of lines or -1 if the minimum\n     * height was set using {@link #setMinHeight(int)} or {@link #setHeight(int)}.\n     *\n     * @return the minimum height of TextView in terms of number of lines or -1 if the minimum\n     *         height is not defined in lines\n     *\n     * @see #setMinLines(int)\n     * @see #setLines(int)\n     *\n     * @attr ref android.R.styleable#TextView_minLines\n     ",
    "links" : [ "#setHeight(int)", "#setMinHeight(int)" ]
  }, {
    "name" : "public void setMinHeight(int minPixels)",
    "returnType" : "void",
    "comment" : "\n     * Sets the height of the TextView to be at least {@code minPixels} tall.\n     * <p>\n     * This value is used for height calculation if LayoutParams does not force TextView to have an\n     * exact height. Setting this value overrides previous minimum height configurations such as\n     * {@link #setMinLines(int)} or {@link #setLines(int)}.\n     * <p>\n     * The value given here is different than {@link #setMinimumHeight(int)}. Between\n     * {@code minHeight} and the value set in {@link #setMinimumHeight(int)}, the greater one is\n     * used to decide the final height.\n     *\n     * @param minPixels the minimum height of TextView in terms of pixels\n     *\n     * @see #getMinHeight()\n     * @see #setHeight(int)\n     *\n     * @attr ref android.R.styleable#TextView_minHeight\n     ",
    "links" : [ "#setMinimumHeight(int)", "#setMinLines(int)", "#setLines(int)" ]
  }, {
    "name" : "public int getMinHeight()",
    "returnType" : "int",
    "comment" : "\n     * Returns the minimum height of TextView in terms of pixels or -1 if the minimum height was\n     * set using {@link #setMinLines(int)} or {@link #setLines(int)}.\n     *\n     * @return the minimum height of TextView in terms of pixels or -1 if the minimum height is not\n     *         defined in pixels\n     *\n     * @see #setMinHeight(int)\n     * @see #setHeight(int)\n     *\n     * @attr ref android.R.styleable#TextView_minHeight\n     ",
    "links" : [ "#setMinLines(int)", "#setLines(int)" ]
  }, {
    "name" : "public void setMaxLines(int maxLines)",
    "returnType" : "void",
    "comment" : "\n     * Sets the height of the TextView to be at most {@code maxLines} tall.\n     * <p>\n     * This value is used for height calculation if LayoutParams does not force TextView to have an\n     * exact height. Setting this value overrides previous maximum height configurations such as\n     * {@link #setMaxHeight(int)} or {@link #setLines(int)}.\n     *\n     * @param maxLines the maximum height of TextView in terms of number of lines\n     *\n     * @see #getMaxLines()\n     * @see #setLines(int)\n     *\n     * @attr ref android.R.styleable#TextView_maxLines\n     ",
    "links" : [ "#setMaxHeight(int)", "#setLines(int)" ]
  }, {
    "name" : "public int getMaxLines()",
    "returnType" : "int",
    "comment" : "\n     * Returns the maximum height of TextView in terms of number of lines or -1 if the\n     * maximum height was set using {@link #setMaxHeight(int)} or {@link #setHeight(int)}.\n     *\n     * @return the maximum height of TextView in terms of number of lines. -1 if the maximum height\n     *         is not defined in lines.\n     *\n     * @see #setMaxLines(int)\n     * @see #setLines(int)\n     *\n     * @attr ref android.R.styleable#TextView_maxLines\n     ",
    "links" : [ "#setMaxHeight(int)", "#setHeight(int)" ]
  }, {
    "name" : "public void setMaxHeight(int maxPixels)",
    "returnType" : "void",
    "comment" : "\n     * Sets the height of the TextView to be at most {@code maxPixels} tall.\n     * <p>\n     * This value is used for height calculation if LayoutParams does not force TextView to have an\n     * exact height. Setting this value overrides previous maximum height configurations such as\n     * {@link #setMaxLines(int)} or {@link #setLines(int)}.\n     *\n     * @param maxPixels the maximum height of TextView in terms of pixels\n     *\n     * @see #getMaxHeight()\n     * @see #setHeight(int)\n     *\n     * @attr ref android.R.styleable#TextView_maxHeight\n     ",
    "links" : [ "#setMaxLines(int)", "#setLines(int)" ]
  }, {
    "name" : "public int getMaxHeight()",
    "returnType" : "int",
    "comment" : "\n     * Returns the maximum height of TextView in terms of pixels or -1 if the maximum height was\n     * set using {@link #setMaxLines(int)} or {@link #setLines(int)}.\n     *\n     * @return the maximum height of TextView in terms of pixels or -1 if the maximum height\n     *         is not defined in pixels\n     *\n     * @see #setMaxHeight(int)\n     * @see #setHeight(int)\n     *\n     * @attr ref android.R.styleable#TextView_maxHeight\n     ",
    "links" : [ "#setMaxLines(int)", "#setLines(int)" ]
  }, {
    "name" : "public void setLines(int lines)",
    "returnType" : "void",
    "comment" : "\n     * Sets the height of the TextView to be exactly {@code lines} tall.\n     * <p>\n     * This value is used for height calculation if LayoutParams does not force TextView to have an\n     * exact height. Setting this value overrides previous minimum/maximum height configurations\n     * such as {@link #setMinLines(int)} or {@link #setMaxLines(int)}. {@link #setSingleLine()} will\n     * set this value to 1.\n     *\n     * @param lines the exact height of the TextView in terms of lines\n     *\n     * @see #setHeight(int)\n     *\n     * @attr ref android.R.styleable#TextView_lines\n     ",
    "links" : [ "#setSingleLine()", "#setMinLines(int)", "#setMaxLines(int)" ]
  }, {
    "name" : "public void setHeight(int pixels)",
    "returnType" : "void",
    "comment" : "\n     * Sets the height of the TextView to be exactly <code>pixels</code> tall.\n     * <p>\n     * This value is used for height calculation if LayoutParams does not force TextView to have an\n     * exact height. Setting this value overrides previous minimum/maximum height configurations\n     * such as {@link #setMinHeight(int)} or {@link #setMaxHeight(int)}.\n     *\n     * @param pixels the exact height of the TextView in terms of pixels\n     *\n     * @see #setLines(int)\n     *\n     * @attr ref android.R.styleable#TextView_height\n     ",
    "links" : [ "#setMaxHeight(int)", "#setMinHeight(int)" ]
  }, {
    "name" : "public void setMinEms(int minEms)",
    "returnType" : "void",
    "comment" : "\n     * Sets the width of the TextView to be at least {@code minEms} wide.\n     * <p>\n     * This value is used for width calculation if LayoutParams does not force TextView to have an\n     * exact width. Setting this value overrides previous minimum width configurations such as\n     * {@link #setMinWidth(int)} or {@link #setWidth(int)}.\n     *\n     * @param minEms the minimum width of TextView in terms of ems\n     *\n     * @see #getMinEms()\n     * @see #setEms(int)\n     *\n     * @attr ref android.R.styleable#TextView_minEms\n     ",
    "links" : [ "#setMinWidth(int)", "#setWidth(int)" ]
  }, {
    "name" : "public int getMinEms()",
    "returnType" : "int",
    "comment" : "\n     * Returns the minimum width of TextView in terms of ems or -1 if the minimum width was set\n     * using {@link #setMinWidth(int)} or {@link #setWidth(int)}.\n     *\n     * @return the minimum width of TextView in terms of ems. -1 if the minimum width is not\n     *         defined in ems\n     *\n     * @see #setMinEms(int)\n     * @see #setEms(int)\n     *\n     * @attr ref android.R.styleable#TextView_minEms\n     ",
    "links" : [ "#setMinWidth(int)", "#setWidth(int)" ]
  }, {
    "name" : "public void setMinWidth(int minPixels)",
    "returnType" : "void",
    "comment" : "\n     * Sets the width of the TextView to be at least {@code minPixels} wide.\n     * <p>\n     * This value is used for width calculation if LayoutParams does not force TextView to have an\n     * exact width. Setting this value overrides previous minimum width configurations such as\n     * {@link #setMinEms(int)} or {@link #setEms(int)}.\n     * <p>\n     * The value given here is different than {@link #setMinimumWidth(int)}. Between\n     * {@code minWidth} and the value set in {@link #setMinimumWidth(int)}, the greater one is used\n     * to decide the final width.\n     *\n     * @param minPixels the minimum width of TextView in terms of pixels\n     *\n     * @see #getMinWidth()\n     * @see #setWidth(int)\n     *\n     * @attr ref android.R.styleable#TextView_minWidth\n     ",
    "links" : [ "#setMinEms(int)", "#setEms(int)", "#setMinimumWidth(int)" ]
  }, {
    "name" : "public int getMinWidth()",
    "returnType" : "int",
    "comment" : "\n     * Returns the minimum width of TextView in terms of pixels or -1 if the minimum width was set\n     * using {@link #setMinEms(int)} or {@link #setEms(int)}.\n     *\n     * @return the minimum width of TextView in terms of pixels or -1 if the minimum width is not\n     *         defined in pixels\n     *\n     * @see #setMinWidth(int)\n     * @see #setWidth(int)\n     *\n     * @attr ref android.R.styleable#TextView_minWidth\n     ",
    "links" : [ "#setMinEms(int)", "#setEms(int)" ]
  }, {
    "name" : "public void setMaxEms(int maxEms)",
    "returnType" : "void",
    "comment" : "\n     * Sets the width of the TextView to be at most {@code maxEms} wide.\n     * <p>\n     * This value is used for width calculation if LayoutParams does not force TextView to have an\n     * exact width. Setting this value overrides previous maximum width configurations such as\n     * {@link #setMaxWidth(int)} or {@link #setWidth(int)}.\n     *\n     * @param maxEms the maximum width of TextView in terms of ems\n     *\n     * @see #getMaxEms()\n     * @see #setEms(int)\n     *\n     * @attr ref android.R.styleable#TextView_maxEms\n     ",
    "links" : [ "#setMaxWidth(int)", "#setWidth(int)" ]
  }, {
    "name" : "public int getMaxEms()",
    "returnType" : "int",
    "comment" : "\n     * Returns the maximum width of TextView in terms of ems or -1 if the maximum width was set\n     * using {@link #setMaxWidth(int)} or {@link #setWidth(int)}.\n     *\n     * @return the maximum width of TextView in terms of ems or -1 if the maximum width is not\n     *         defined in ems\n     *\n     * @see #setMaxEms(int)\n     * @see #setEms(int)\n     *\n     * @attr ref android.R.styleable#TextView_maxEms\n     ",
    "links" : [ "#setMaxWidth(int)", "#setWidth(int)" ]
  }, {
    "name" : "public void setMaxWidth(int maxPixels)",
    "returnType" : "void",
    "comment" : "\n     * Sets the width of the TextView to be at most {@code maxPixels} wide.\n     * <p>\n     * This value is used for width calculation if LayoutParams does not force TextView to have an\n     * exact width. Setting this value overrides previous maximum width configurations such as\n     * {@link #setMaxEms(int)} or {@link #setEms(int)}.\n     *\n     * @param maxPixels the maximum width of TextView in terms of pixels\n     *\n     * @see #getMaxWidth()\n     * @see #setWidth(int)\n     *\n     * @attr ref android.R.styleable#TextView_maxWidth\n     ",
    "links" : [ "#setMaxEms(int)", "#setEms(int)" ]
  }, {
    "name" : "public int getMaxWidth()",
    "returnType" : "int",
    "comment" : "\n     * Returns the maximum width of TextView in terms of pixels or -1 if the maximum width was set\n     * using {@link #setMaxEms(int)} or {@link #setEms(int)}.\n     *\n     * @return the maximum width of TextView in terms of pixels. -1 if the maximum width is not\n     *         defined in pixels\n     *\n     * @see #setMaxWidth(int)\n     * @see #setWidth(int)\n     *\n     * @attr ref android.R.styleable#TextView_maxWidth\n     ",
    "links" : [ "#setMaxEms(int)", "#setEms(int)" ]
  }, {
    "name" : "public void setEms(int ems)",
    "returnType" : "void",
    "comment" : "\n     * Sets the width of the TextView to be exactly {@code ems} wide.\n     *\n     * This value is used for width calculation if LayoutParams does not force TextView to have an\n     * exact width. Setting this value overrides previous minimum/maximum configurations such as\n     * {@link #setMinEms(int)} or {@link #setMaxEms(int)}.\n     *\n     * @param ems the exact width of the TextView in terms of ems\n     *\n     * @see #setWidth(int)\n     *\n     * @attr ref android.R.styleable#TextView_ems\n     ",
    "links" : [ "#setMaxEms(int)", "#setMinEms(int)" ]
  }, {
    "name" : "public void setWidth(int pixels)",
    "returnType" : "void",
    "comment" : "\n     * Sets the width of the TextView to be exactly {@code pixels} wide.\n     * <p>\n     * This value is used for width calculation if LayoutParams does not force TextView to have an\n     * exact width. Setting this value overrides previous minimum/maximum width configurations\n     * such as {@link #setMinWidth(int)} or {@link #setMaxWidth(int)}.\n     *\n     * @param pixels the exact width of the TextView in terms of pixels\n     *\n     * @see #setEms(int)\n     *\n     * @attr ref android.R.styleable#TextView_width\n     ",
    "links" : [ "#setMinWidth(int)", "#setMaxWidth(int)" ]
  }, {
    "name" : "public void setLineSpacing(float add, float mult)",
    "returnType" : "void",
    "comment" : "\n     * Sets line spacing for this TextView.  Each line other than the last line will have its height\n     * multiplied by {@code mult} and have {@code add} added to it.\n     *\n     * @param add The value in pixels that should be added to each line other than the last line.\n     *            This will be applied after the multiplier\n     * @param mult The value by which each line height other than the last line will be multiplied\n     *             by\n     *\n     * @attr ref android.R.styleable#TextView_lineSpacingExtra\n     * @attr ref android.R.styleable#TextView_lineSpacingMultiplier\n     ",
    "links" : [ ]
  }, {
    "name" : "public float getLineSpacingMultiplier()",
    "returnType" : "float",
    "comment" : "\n     * Gets the line spacing multiplier\n     *\n     * @return the value by which each line's height is multiplied to get its actual height.\n     *\n     * @see #setLineSpacing(float, float)\n     * @see #getLineSpacingExtra()\n     *\n     * @attr ref android.R.styleable#TextView_lineSpacingMultiplier\n     ",
    "links" : [ ]
  }, {
    "name" : "public float getLineSpacingExtra()",
    "returnType" : "float",
    "comment" : "\n     * Gets the line spacing extra space\n     *\n     * @return the extra space that is added to the height of each lines of this TextView.\n     *\n     * @see #setLineSpacing(float, float)\n     * @see #getLineSpacingMultiplier()\n     *\n     * @attr ref android.R.styleable#TextView_lineSpacingExtra\n     ",
    "links" : [ ]
  }, {
    "name" : "public void setLineHeight(@Px @IntRange(from = 0) int lineHeight)",
    "returnType" : "void",
    "comment" : "\n     * Sets an explicit line height for this TextView. This is equivalent to the vertical distance\n     * between subsequent baselines in the TextView.\n     *\n     * @param lineHeight the line height in pixels\n     *\n     * @see #setLineSpacing(float, float)\n     * @see #getLineSpacingExtra()\n     *\n     * @attr ref android.R.styleable#TextView_lineHeight\n     ",
    "links" : [ ]
  }, {
    "name" : "private void setLineHeightPx(@Px @FloatRange(from = 0) float lineHeight)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public void setLineHeight(@TypedValue.ComplexDimensionUnit int unit, @FloatRange(from = 0) float lineHeight)",
    "returnType" : "void",
    "comment" : "\n     * Sets an explicit line height to a given unit and value for this TextView. This is equivalent\n     * to the vertical distance between subsequent baselines in the TextView. See {@link\n     * TypedValue} for the possible dimension units.\n     *\n     * @param unit The desired dimension unit. SP units are strongly recommended so that line height\n     *             stays proportional to the text size when fonts are scaled up for accessibility.\n     * @param lineHeight The desired line height in the given units.\n     *\n     * @see #setLineSpacing(float, float)\n     * @see #getLineSpacingExtra()\n     *\n     * @attr ref android.R.styleable#TextView_lineHeight\n     ",
    "links" : [ "android.util.TypedValue" ]
  }, {
    "name" : "private void maybeRecalculateLineHeight()",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public void setHighlights(@Nullable Highlights highlights)",
    "returnType" : "void",
    "comment" : "\n     * Set Highlights\n     *\n     * @param highlights A highlight object. Call with null for reset.\n     *\n     * @see #getHighlights()\n     * @see Highlights\n     ",
    "links" : [ ]
  }, {
    "name" : "public Highlights getHighlights()",
    "returnType" : "Highlights",
    "comment" : "\n     * Returns highlights\n     *\n     * @return a highlight to be drawn. null if no highlight was set.\n     *\n     * @see #setHighlights(Highlights)\n     * @see Highlights\n     *\n     ",
    "links" : [ ]
  }, {
    "name" : "public void setSearchResultHighlights(@Nullable int... ranges)",
    "returnType" : "void",
    "comment" : "\n     * Sets the search result ranges with flatten range representation.\n     *\n     * Ranges are represented of flattened inclusive start and exclusive end integers array. The\n     * inclusive start offset of the {@code i}-th range is stored in {@code 2 * i}-th of the array.\n     * The exclusive end offset of the {@code i}-th range is stored in {@code 2* i + 1}-th of the\n     * array. For example, the two ranges: (1, 2) and (3, 4) are flattened into single int array\n     * [1, 2, 3, 4].\n     *\n     * TextView will render the search result with the highlights with specified color in the theme.\n     * If there is a focused search result, it is rendered with focused color. By calling this\n     * method, the focused search index will be cleared.\n     *\n     * @attr ref android.R.styleable#TextView_searchResultHighlightColor\n     * @attr ref android.R.styleable#TextAppearance_searchResultHighlightColor\n     * @attr ref android.R.styleable#TextView_focusedSearchResultHighlightColor\n     * @attr ref android.R.styleable#TextAppearance_focusedSearchResultHighlightColor\n     *\n     * @see #getSearchResultHighlights()\n     * @see #setFocusedSearchResultIndex(int)\n     * @see #getFocusedSearchResultIndex()\n     * @see #setSearchResultHighlightColor(int)\n     * @see #getSearchResultHighlightColor()\n     * @see #setFocusedSearchResultHighlightColor(int)\n     * @see #getFocusedSearchResultHighlightColor()\n     *\n     * @param ranges the flatten ranges of the search result. null for clear.\n     ",
    "links" : [ ]
  }, {
    "name" : "public int[] getSearchResultHighlights()",
    "returnType" : "int[]",
    "comment" : "\n     * Gets the current search result ranges.\n     *\n     * @see #setSearchResultHighlights(int[])\n     * @see #setFocusedSearchResultIndex(int)\n     * @see #getFocusedSearchResultIndex()\n     * @see #setSearchResultHighlightColor(int)\n     * @see #getSearchResultHighlightColor()\n     * @see #setFocusedSearchResultHighlightColor(int)\n     * @see #getFocusedSearchResultHighlightColor()\n     *\n     * @return a flatten search result ranges. null if not available.\n     ",
    "links" : [ ]
  }, {
    "name" : "public void setFocusedSearchResultIndex(int index)",
    "returnType" : "void",
    "comment" : "\n     * Sets the focused search result index.\n     *\n     * The focused search result is drawn in a focused color.\n     * Calling {@link #FOCUSED_SEARCH_RESULT_INDEX_NONE} for clearing focused search result.\n     *\n     * This method must be called after setting search result ranges by\n     * {@link #setSearchResultHighlights(int[])}.\n     *\n     * @attr ref android.R.styleable#TextView_searchResultHighlightColor\n     * @attr ref android.R.styleable#TextAppearance_searchResultHighlightColor\n     * @attr ref android.R.styleable#TextView_focusedSearchResultHighlightColor\n     * @attr ref android.R.styleable#TextAppearance_focusedSearchResultHighlightColor\n     *\n     * @see #setSearchResultHighlights(int[])\n     * @see #getSearchResultHighlights()\n     * @see #setFocusedSearchResultIndex(int)\n     * @see #getFocusedSearchResultIndex()\n     * @see #setSearchResultHighlightColor(int)\n     * @see #getSearchResultHighlightColor()\n     * @see #setFocusedSearchResultHighlightColor(int)\n     * @see #getFocusedSearchResultHighlightColor()\n     *\n     * @param index a focused search index or {@link #FOCUSED_SEARCH_RESULT_INDEX_NONE}\n     ",
    "links" : [ "#setSearchResultHighlights(int", "#FOCUSED_SEARCH_RESULT_INDEX_NONE" ]
  }, {
    "name" : "public int getFocusedSearchResultIndex()",
    "returnType" : "int",
    "comment" : "\n     * Gets the focused search result index.\n     *\n     * @attr ref android.R.styleable#TextView_searchResultHighlightColor\n     * @attr ref android.R.styleable#TextAppearance_searchResultHighlightColor\n     * @attr ref android.R.styleable#TextView_focusedSearchResultHighlightColor\n     * @attr ref android.R.styleable#TextAppearance_focusedSearchResultHighlightColor\n     *\n     * @see #setSearchResultHighlights(int[])\n     * @see #getSearchResultHighlights()\n     * @see #setFocusedSearchResultIndex(int)\n     * @see #getFocusedSearchResultIndex()\n     * @see #setSearchResultHighlightColor(int)\n     * @see #getSearchResultHighlightColor()\n     * @see #setFocusedSearchResultHighlightColor(int)\n     * @see #getFocusedSearchResultHighlightColor()\n\n     * @return a focused search index or {@link #FOCUSED_SEARCH_RESULT_INDEX_NONE}\n     ",
    "links" : [ "#FOCUSED_SEARCH_RESULT_INDEX_NONE" ]
  }, {
    "name" : "public void setSearchResultHighlightColor(@ColorInt int color)",
    "returnType" : "void",
    "comment" : "\n     * Sets the search result highlight color.\n     *\n     * @attr ref android.R.styleable#TextView_searchResultHighlightColor\n     * @attr ref android.R.styleable#TextAppearance_searchResultHighlightColor\n     * @attr ref android.R.styleable#TextView_focusedSearchResultHighlightColor\n     * @attr ref android.R.styleable#TextAppearance_focusedSearchResultHighlightColor\n     *\n     * @see #setSearchResultHighlights(int[])\n     * @see #getSearchResultHighlights()\n     * @see #setFocusedSearchResultIndex(int)\n     * @see #getFocusedSearchResultIndex()\n     * @see #setSearchResultHighlightColor(int)\n     * @see #getSearchResultHighlightColor()\n     * @see #setFocusedSearchResultHighlightColor(int)\n     * @see #getFocusedSearchResultHighlightColor()\n\n     * @param color a search result highlight color.\n     ",
    "links" : [ ]
  }, {
    "name" : "public int getSearchResultHighlightColor()",
    "returnType" : "int",
    "comment" : "\n     * Gets the search result highlight color.\n     *\n     * @attr ref android.R.styleable#TextView_searchResultHighlightColor\n     * @attr ref android.R.styleable#TextAppearance_searchResultHighlightColor\n     * @attr ref android.R.styleable#TextView_focusedSearchResultHighlightColor\n     * @attr ref android.R.styleable#TextAppearance_focusedSearchResultHighlightColor\n     *\n     * @see #setSearchResultHighlights(int[])\n     * @see #getSearchResultHighlights()\n     * @see #setFocusedSearchResultIndex(int)\n     * @see #getFocusedSearchResultIndex()\n     * @see #setSearchResultHighlightColor(int)\n     * @see #getSearchResultHighlightColor()\n     * @see #setFocusedSearchResultHighlightColor(int)\n     * @see #getFocusedSearchResultHighlightColor()\n\n     * @return a search result highlight color.\n     ",
    "links" : [ ]
  }, {
    "name" : "public void setFocusedSearchResultHighlightColor(@ColorInt int color)",
    "returnType" : "void",
    "comment" : "\n     * Sets focused search result highlight color.\n     *\n     * @attr ref android.R.styleable#TextView_searchResultHighlightColor\n     * @attr ref android.R.styleable#TextAppearance_searchResultHighlightColor\n     * @attr ref android.R.styleable#TextView_focusedSearchResultHighlightColor\n     * @attr ref android.R.styleable#TextAppearance_focusedSearchResultHighlightColor\n     *\n     * @see #setSearchResultHighlights(int[])\n     * @see #getSearchResultHighlights()\n     * @see #setFocusedSearchResultIndex(int)\n     * @see #getFocusedSearchResultIndex()\n     * @see #setSearchResultHighlightColor(int)\n     * @see #getSearchResultHighlightColor()\n     * @see #setFocusedSearchResultHighlightColor(int)\n     * @see #getFocusedSearchResultHighlightColor()\n\n     * @param color a focused search result highlight color.\n     ",
    "links" : [ ]
  }, {
    "name" : "public int getFocusedSearchResultHighlightColor()",
    "returnType" : "int",
    "comment" : "\n     * Gets focused search result highlight color.\n     *\n     * @attr ref android.R.styleable#TextView_searchResultHighlightColor\n     * @attr ref android.R.styleable#TextAppearance_searchResultHighlightColor\n     * @attr ref android.R.styleable#TextView_focusedSearchResultHighlightColor\n     * @attr ref android.R.styleable#TextAppearance_focusedSearchResultHighlightColor\n     *\n     * @see #setSearchResultHighlights(int[])\n     * @see #getSearchResultHighlights()\n     * @see #setFocusedSearchResultIndex(int)\n     * @see #getFocusedSearchResultIndex()\n     * @see #setSearchResultHighlightColor(int)\n     * @see #getSearchResultHighlightColor()\n     * @see #setFocusedSearchResultHighlightColor(int)\n     * @see #getFocusedSearchResultHighlightColor()\n\n     * @return a focused search result highlight color.\n     ",
    "links" : [ ]
  }, {
    "name" : "private void setSelectGesturePreviewHighlight(int start, int end)",
    "returnType" : "void",
    "comment" : "\n     * Highlights the text range (from inclusive start offset to exclusive end offset) to show what\n     * will be selected by the ongoing select handwriting gesture. While the gesture preview\n     * highlight is shown, the selection or cursor is hidden. If the text or selection is changed,\n     * the gesture preview highlight will be cleared.\n     ",
    "links" : [ ]
  }, {
    "name" : "private void setDeleteGesturePreviewHighlight(int start, int end)",
    "returnType" : "void",
    "comment" : "\n     * Highlights the text range (from inclusive start offset to exclusive end offset) to show what\n     * will be deleted by the ongoing delete handwriting gesture. While the gesture preview\n     * highlight is shown, the selection or cursor is hidden. If the text or selection is changed,\n     * the gesture preview highlight will be cleared.\n     ",
    "links" : [ ]
  }, {
    "name" : "private void setGesturePreviewHighlight(int start, int end, int color)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private void clearGesturePreviewHighlight()",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : " boolean hasGesturePreviewHighlight()",
    "returnType" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public final void append(CharSequence text)",
    "returnType" : "void",
    "comment" : "\n     * Convenience method to append the specified text to the TextView's\n     * display buffer, upgrading it to {@link android.widget.TextView.BufferType#EDITABLE}\n     * if it was not already editable.\n     *\n     * @param text text to be appended to the already displayed text\n     ",
    "links" : [ "android.widget.TextView.BufferType#EDITABLE" ]
  }, {
    "name" : "public void append(CharSequence text, int start, int end)",
    "returnType" : "void",
    "comment" : "\n     * Convenience method to append the specified text slice to the TextView's\n     * display buffer, upgrading it to {@link android.widget.TextView.BufferType#EDITABLE}\n     * if it was not already editable.\n     *\n     * @param text text to be appended to the already displayed text\n     * @param start the index of the first character in the {@code text}\n     * @param end the index of the character following the last character in the {@code text}\n     *\n     * @see Appendable#append(CharSequence, int, int)\n     ",
    "links" : [ "android.widget.TextView.BufferType#EDITABLE" ]
  }, {
    "name" : "private void updateTextColors()",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "protected void drawableStateChanged()",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public void drawableHotspotChanged(float x, float y)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public Parcelable onSaveInstanceState()",
    "returnType" : "Parcelable",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : " void removeMisspelledSpans(Spannable spannable)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public void onRestoreInstanceState(Parcelable state)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public void setFreezesText(boolean freezesText)",
    "returnType" : "void",
    "comment" : "\n     * Control whether this text view saves its entire text contents when\n     * freezing to an icicle, in addition to dynamic state such as cursor\n     * position.  By default this is false, not saving the text.  Set to true\n     * if the text in the text view is not being saved somewhere else in\n     * persistent storage (such as in a content provider) so that if the\n     * view is later thawed the user will not lose their data. For\n     * {@link android.widget.EditText} it is always enabled, regardless of\n     * the value of the attribute.\n     *\n     * @param freezesText Controls whether a frozen icicle should include the\n     * entire text data: true to include it, false to not.\n     *\n     * @attr ref android.R.styleable#TextView_freezesText\n     ",
    "links" : [ "android.widget.EditText" ]
  }, {
    "name" : "public boolean getFreezesText()",
    "returnType" : "boolean",
    "comment" : "\n     * Return whether this text view is including its entire text contents\n     * in frozen icicles. For {@link android.widget.EditText} it always returns true.\n     *\n     * @return Returns true if text is included, false if it isn't.\n     *\n     * @see #setFreezesText\n     ",
    "links" : [ "android.widget.EditText" ]
  }, {
    "name" : "public final void setEditableFactory(Editable.Factory factory)",
    "returnType" : "void",
    "comment" : "\n     * Sets the Factory used to create new {@link Editable Editables}.\n     *\n     * @param factory {@link android.text.Editable.Factory Editable.Factory} to be used\n     *\n     * @see android.text.Editable.Factory\n     * @see android.widget.TextView.BufferType#EDITABLE\n     ",
    "links" : [ "android.text.Editable.Factory", "android.text.Editable" ]
  }, {
    "name" : "public final void setSpannableFactory(Spannable.Factory factory)",
    "returnType" : "void",
    "comment" : "\n     * Sets the Factory used to create new {@link Spannable Spannables}.\n     *\n     * @param factory {@link android.text.Spannable.Factory Spannable.Factory} to be used\n     *\n     * @see android.text.Spannable.Factory\n     * @see android.widget.TextView.BufferType#SPANNABLE\n     ",
    "links" : [ "android.text.Spannable.Factory", "android.text.Spannable" ]
  }, {
    "name" : "public final void setText(CharSequence text)",
    "returnType" : "void",
    "comment" : "\n     * Sets the text to be displayed. TextView <em>does not</em> accept\n     * HTML-like formatting, which you can do with text strings in XML resource files.\n     * To style your strings, attach android.text.style.* objects to a\n     * {@link android.text.SpannableString}, or see the\n     * <a href=\"{@docRoot}guide/topics/resources/available-resources.html#stringresources\">\n     * Available Resource Types</a> documentation for an example of setting\n     * formatted text in the XML resource file.\n     * <p/>\n     * When required, TextView will use {@link android.text.Spannable.Factory} to create final or\n     * intermediate {@link Spannable Spannables}. Likewise it will use\n     * {@link android.text.Editable.Factory} to create final or intermediate\n     * {@link Editable Editables}.\n     *\n     * If the passed text is a {@link PrecomputedText} but the parameters used to create the\n     * PrecomputedText mismatches with this TextView, IllegalArgumentException is thrown. To ensure\n     * the parameters match, you can call {@link TextView#setTextMetricsParams} before calling this.\n     *\n     * @param text text to be displayed\n     *\n     * @attr ref android.R.styleable#TextView_text\n     * @throws IllegalArgumentException if the passed text is a {@link PrecomputedText} but the\n     *                                  parameters used to create the PrecomputedText mismatches\n     *                                  with this TextView.\n     ",
    "links" : [ "android.text.Spannable.Factory", "android.text.SpannableString", "android.text.Spannable", "android.text.Editable.Factory", "android.text.PrecomputedText", "android.text.Editable", "android.widget.TextView#setTextMetricsParams" ]
  }, {
    "name" : "public Runnable setTextAsync(@Nullable CharSequence text)",
    "returnType" : "Runnable",
    "comment" : "\n     * RemotableViewMethod's asyncImpl of {@link #setText(CharSequence)}.\n     * This should be called on a background thread, and returns a Runnable which is then must be\n     * called on the main thread to complete the operation and set text.\n     * @param text text to be displayed\n     * @return Runnable that sets text; must be called on the main thread by the caller of this\n     * method to complete the operation\n     * @hide\n     ",
    "links" : [ "#setText(CharSequence)" ]
  }, {
    "name" : "public final void setTextKeepState(CharSequence text)",
    "returnType" : "void",
    "comment" : "\n     * Sets the text to be displayed but retains the cursor position. Same as\n     * {@link #setText(CharSequence)} except that the cursor position (if any) is retained in the\n     * new text.\n     * <p/>\n     * When required, TextView will use {@link android.text.Spannable.Factory} to create final or\n     * intermediate {@link Spannable Spannables}. Likewise it will use\n     * {@link android.text.Editable.Factory} to create final or intermediate\n     * {@link Editable Editables}.\n     *\n     * @param text text to be displayed\n     *\n     * @see #setText(CharSequence)\n     ",
    "links" : [ "#setText(CharSequence)", "android.text.Spannable.Factory", "android.text.Spannable", "android.text.Editable.Factory", "android.text.Editable" ]
  }, {
    "name" : "public void setText(CharSequence text, BufferType type)",
    "returnType" : "void",
    "comment" : "\n     * Sets the text to be displayed and the {@link android.widget.TextView.BufferType}.\n     * <p/>\n     * When required, TextView will use {@link android.text.Spannable.Factory} to create final or\n     * intermediate {@link Spannable Spannables}. Likewise it will use\n     * {@link android.text.Editable.Factory} to create final or intermediate\n     * {@link Editable Editables}.\n     *\n     * Subclasses overriding this method should ensure that the following post condition holds,\n     * in order to guarantee the safety of the view's measurement and layout operations:\n     * regardless of the input, after calling #setText both {@code mText} and {@code mTransformed}\n     * will be different from {@code null}.\n     *\n     * @param text text to be displayed\n     * @param type a {@link android.widget.TextView.BufferType} which defines whether the text is\n     *              stored as a static text, styleable/spannable text, or editable text\n     *\n     * @see #setText(CharSequence)\n     * @see android.widget.TextView.BufferType\n     * @see #setSpannableFactory(Spannable.Factory)\n     * @see #setEditableFactory(Editable.Factory)\n     *\n     * @attr ref android.R.styleable#TextView_text\n     * @attr ref android.R.styleable#TextView_bufferType\n     ",
    "links" : [ "android.text.Spannable.Factory", "android.text.Spannable", "android.text.Editable.Factory", "android.widget.TextView.BufferType", "android.text.Editable" ]
  }, {
    "name" : "private void setText(CharSequence text, BufferType type, boolean notifyBefore, int oldlen)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public final void setText(@NonNull char[] text, int start, int len)",
    "returnType" : "void",
    "comment" : "\n     * Sets the TextView to display the specified slice of the specified\n     * char array. You must promise that you will not change the contents\n     * of the array except for right before another call to setText(),\n     * since the TextView has no way to know that the text\n     * has changed and that it needs to invalidate and re-layout.\n     *\n     * @throws NullPointerException if text is null\n     * @throws IndexOutOfBoundsException if start or start+len are not in 0 to text.length\n     *\n     * @param text char array to be displayed\n     * @param start start index in the char array\n     * @param len length of char count after {@code start}\n     ",
    "links" : [ ]
  }, {
    "name" : "public final void setTextKeepState(CharSequence text, BufferType type)",
    "returnType" : "void",
    "comment" : "\n     * Sets the text to be displayed and the {@link android.widget.TextView.BufferType} but retains\n     * the cursor position. Same as\n     * {@link #setText(CharSequence, android.widget.TextView.BufferType)} except that the cursor\n     * position (if any) is retained in the new text.\n     * <p/>\n     * When required, TextView will use {@link android.text.Spannable.Factory} to create final or\n     * intermediate {@link Spannable Spannables}. Likewise it will use\n     * {@link android.text.Editable.Factory} to create final or intermediate\n     * {@link Editable Editables}.\n     *\n     * @param text text to be displayed\n     * @param type a {@link android.widget.TextView.BufferType} which defines whether the text is\n     *              stored as a static text, styleable/spannable text, or editable text\n     *\n     * @see #setText(CharSequence, android.widget.TextView.BufferType)\n     ",
    "links" : [ "android.text.Spannable.Factory", "android.text.Spannable", "android.text.Editable.Factory", "#setText(CharSequence", "android.widget.TextView.BufferType", "android.text.Editable" ]
  }, {
    "name" : "public final void setText(@StringRes int resid)",
    "returnType" : "void",
    "comment" : "\n     * Sets the text to be displayed using a string resource identifier.\n     *\n     * @param resid the resource identifier of the string resource to be displayed\n     *\n     * @see #setText(CharSequence)\n     *\n     * @attr ref android.R.styleable#TextView_text\n     ",
    "links" : [ ]
  }, {
    "name" : "public final void setText(@StringRes int resid, BufferType type)",
    "returnType" : "void",
    "comment" : "\n     * Sets the text to be displayed using a string resource identifier and the\n     * {@link android.widget.TextView.BufferType}.\n     * <p/>\n     * When required, TextView will use {@link android.text.Spannable.Factory} to create final or\n     * intermediate {@link Spannable Spannables}. Likewise it will use\n     * {@link android.text.Editable.Factory} to create final or intermediate\n     * {@link Editable Editables}.\n     *\n     * @param resid the resource identifier of the string resource to be displayed\n     * @param type a {@link android.widget.TextView.BufferType} which defines whether the text is\n     *              stored as a static text, styleable/spannable text, or editable text\n     *\n     * @see #setText(int)\n     * @see #setText(CharSequence)\n     * @see android.widget.TextView.BufferType\n     * @see #setSpannableFactory(Spannable.Factory)\n     * @see #setEditableFactory(Editable.Factory)\n     *\n     * @attr ref android.R.styleable#TextView_text\n     * @attr ref android.R.styleable#TextView_bufferType\n     ",
    "links" : [ "android.text.Spannable.Factory", "android.text.Spannable", "android.text.Editable.Factory", "android.widget.TextView.BufferType", "android.text.Editable" ]
  }, {
    "name" : "public final void setHint(CharSequence hint)",
    "returnType" : "void",
    "comment" : "\n     * Sets the text to be displayed when the text of the TextView is empty.\n     * Null means to use the normal empty text. The hint does not currently\n     * participate in determining the size of the view.\n     *\n     * @attr ref android.R.styleable#TextView_hint\n     ",
    "links" : [ ]
  }, {
    "name" : "private void setHintInternal(CharSequence hint)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public final void setHint(@StringRes int resid)",
    "returnType" : "void",
    "comment" : "\n     * Sets the text to be displayed when the text of the TextView is empty,\n     * from a resource.\n     *\n     * @attr ref android.R.styleable#TextView_hint\n     ",
    "links" : [ ]
  }, {
    "name" : "public CharSequence getHint()",
    "returnType" : "CharSequence",
    "comment" : "\n     * Returns the hint that is displayed when the text of the TextView\n     * is empty.\n     *\n     * @attr ref android.R.styleable#TextView_hint\n     ",
    "links" : [ ]
  }, {
    "name" : "public void hideHint()",
    "returnType" : "void",
    "comment" : "\n     * Temporarily hides the hint text until the text is modified, or the hint text is modified, or\n     * the view gains or loses focus.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean isSingleLine()",
    "returnType" : "boolean",
    "comment" : "\n     * Returns if the text is constrained to a single horizontally scrolling line ignoring new\n     * line characters instead of letting it wrap onto multiple lines.\n     *\n     * @attr ref android.R.styleable#TextView_singleLine\n     ",
    "links" : [ ]
  }, {
    "name" : "private static boolean isMultilineInputType(int type)",
    "returnType" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : " CharSequence removeSuggestionSpans(CharSequence text)",
    "returnType" : "CharSequence",
    "comment" : "\n     * Removes the suggestion spans.\n     ",
    "links" : [ ]
  }, {
    "name" : "public void setInputType(int type)",
    "returnType" : "void",
    "comment" : "\n     * Set the type of the content with a constant as defined for {@link EditorInfo#inputType}. This\n     * will take care of changing the key listener, by calling {@link #setKeyListener(KeyListener)},\n     * to match the given content type.  If the given content type is {@link EditorInfo#TYPE_NULL}\n     * then a soft keyboard will not be displayed for this text view.\n     *\n     * Note that the maximum number of displayed lines (see {@link #setMaxLines(int)}) will be\n     * modified if you change the {@link EditorInfo#TYPE_TEXT_FLAG_MULTI_LINE} flag of the input\n     * type.\n     *\n     * @see #getInputType()\n     * @see #setRawInputType(int)\n     * @see android.text.InputType\n     * @attr ref android.R.styleable#TextView_inputType\n     ",
    "links" : [ "android.view.inputmethod.EditorInfo#TYPE_NULL", "#setKeyListener(KeyListener)", "android.view.inputmethod.EditorInfo#TYPE_TEXT_FLAG_MULTI_LINE", "android.view.inputmethod.EditorInfo#inputType", "#setMaxLines(int)" ]
  }, {
    "name" : " boolean hasPasswordTransformationMethod()",
    "returnType" : "boolean",
    "comment" : "\n     * It would be better to rely on the input type for everything. A password inputType should have\n     * a password transformation. We should hence use isPasswordInputType instead of this method.\n     *\n     * We should:\n     * - Call setInputType in setKeyListener instead of changing the input type directly (which\n     * would install the correct transformation).\n     * - Refuse the installation of a non-password transformation in setTransformation if the input\n     * type is password.\n     *\n     * However, this is like this for legacy reasons and we cannot break existing apps. This method\n     * is useful since it matches what the user can see (obfuscated text or not).\n     *\n     * @return true if the current transformation method is of the password type.\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean isAnyPasswordInputType()",
    "returnType" : "boolean",
    "comment" : "\n     * Returns true if the current inputType is any type of password.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : " static boolean isPasswordInputType(int inputType)",
    "returnType" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private static boolean isVisiblePasswordInputType(int inputType)",
    "returnType" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public void setRawInputType(int type)",
    "returnType" : "void",
    "comment" : "\n     * Directly change the content type integer of the text view, without\n     * modifying any other state.\n     * @see #setInputType(int)\n     * @see android.text.InputType\n     * @attr ref android.R.styleable#TextView_inputType\n     ",
    "links" : [ ]
  }, {
    "name" : "public String[] getAutofillHints()",
    "returnType" : "String[]",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private Locale getCustomLocaleForKeyListenerOrNull()",
    "returnType" : "Locale",
    "comment" : "\n     * @return {@code null} if the key listener should use pre-O (locale-independent). Otherwise\n     *         a {@code Locale} object that can be used to customize key various listeners.\n     * @see DateKeyListener#getInstance(Locale)\n     * @see DateTimeKeyListener#getInstance(Locale)\n     * @see DigitsKeyListener#getInstance(Locale)\n     * @see TimeKeyListener#getInstance(Locale)\n     ",
    "links" : [ ]
  }, {
    "name" : "private void setInputType(int type, boolean direct)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public int getInputType()",
    "returnType" : "int",
    "comment" : "\n     * Get the type of the editable content.\n     *\n     * @see #setInputType(int)\n     * @see android.text.InputType\n     ",
    "links" : [ ]
  }, {
    "name" : "public void setImeOptions(int imeOptions)",
    "returnType" : "void",
    "comment" : "\n     * Change the editor type integer associated with the text view, which\n     * is reported to an Input Method Editor (IME) with {@link EditorInfo#imeOptions}\n     * when it has focus.\n     * @see #getImeOptions\n     * @see android.view.inputmethod.EditorInfo\n     * @attr ref android.R.styleable#TextView_imeOptions\n     ",
    "links" : [ "android.view.inputmethod.EditorInfo#imeOptions" ]
  }, {
    "name" : "public int getImeOptions()",
    "returnType" : "int",
    "comment" : "\n     * Get the type of the Input Method Editor (IME).\n     * @return the type of the IME\n     * @see #setImeOptions(int)\n     * @see EditorInfo\n     ",
    "links" : [ ]
  }, {
    "name" : "public void setImeActionLabel(CharSequence label, int actionId)",
    "returnType" : "void",
    "comment" : "\n     * Change the custom IME action associated with the text view, which\n     * will be reported to an IME with {@link EditorInfo#actionLabel}\n     * and {@link EditorInfo#actionId} when it has focus.\n     * @see #getImeActionLabel\n     * @see #getImeActionId\n     * @see android.view.inputmethod.EditorInfo\n     * @attr ref android.R.styleable#TextView_imeActionLabel\n     * @attr ref android.R.styleable#TextView_imeActionId\n     ",
    "links" : [ "android.view.inputmethod.EditorInfo#actionId", "android.view.inputmethod.EditorInfo#actionLabel" ]
  }, {
    "name" : "public CharSequence getImeActionLabel()",
    "returnType" : "CharSequence",
    "comment" : "\n     * Get the IME action label previous set with {@link #setImeActionLabel}.\n     *\n     * @see #setImeActionLabel\n     * @see android.view.inputmethod.EditorInfo\n     ",
    "links" : [ "#setImeActionLabel" ]
  }, {
    "name" : "public int getImeActionId()",
    "returnType" : "int",
    "comment" : "\n     * Get the IME action ID previous set with {@link #setImeActionLabel}.\n     *\n     * @see #setImeActionLabel\n     * @see android.view.inputmethod.EditorInfo\n     ",
    "links" : [ "#setImeActionLabel" ]
  }, {
    "name" : "public void setOnEditorActionListener(OnEditorActionListener l)",
    "returnType" : "void",
    "comment" : "\n     * Set a special listener to be called when an action is performed\n     * on the text view.  This will be called when the enter key is pressed,\n     * or when an action supplied to the IME is selected by the user.  Setting\n     * this means that the normal hard key event will not insert a newline\n     * into the text view, even if it is multi-line; holding down the ALT\n     * modifier will, however, allow the user to insert a newline character.\n     ",
    "links" : [ ]
  }, {
    "name" : "public void onEditorAction(int actionCode)",
    "returnType" : "void",
    "comment" : "\n     * Called when an attached input method calls\n     * {@link InputConnection#performEditorAction(int)\n     * InputConnection.performEditorAction()}\n     * for this text view.  The default implementation will call your action\n     * listener supplied to {@link #setOnEditorActionListener}, or perform\n     * a standard operation for {@link EditorInfo#IME_ACTION_NEXT\n     * EditorInfo.IME_ACTION_NEXT}, {@link EditorInfo#IME_ACTION_PREVIOUS\n     * EditorInfo.IME_ACTION_PREVIOUS}, or {@link EditorInfo#IME_ACTION_DONE\n     * EditorInfo.IME_ACTION_DONE}.\n     *\n     * <p>For backwards compatibility, if no IME options have been set and the\n     * text view would not normally advance focus on enter, then\n     * the NEXT and DONE actions received here will be turned into an enter\n     * key down/up pair to go through the normal key handling.\n     *\n     * @param actionCode The code of the action being performed.\n     *\n     * @see #setOnEditorActionListener\n     ",
    "links" : [ "android.view.inputmethod.EditorInfo#IME_ACTION_PREVIOUSEditorInfo.IME_ACTION_PREVIOUS", "android.view.inputmethod.BaseInputConnection#performEditorAction(int)", "#setOnEditorActionListener", "android.view.inputmethod.EditorInfo#IME_ACTION_DONEEditorInfo.IME_ACTION_DONE", "android.view.inputmethod.EditorInfo#IME_ACTION_NEXTEditorInfo.IME_ACTION_NEXT" ]
  }, {
    "name" : "public void setPrivateImeOptions(String type)",
    "returnType" : "void",
    "comment" : "\n     * Set the private content type of the text, which is the\n     * {@link EditorInfo#privateImeOptions EditorInfo.privateImeOptions}\n     * field that will be filled in when creating an input connection.\n     *\n     * @see #getPrivateImeOptions()\n     * @see EditorInfo#privateImeOptions\n     * @attr ref android.R.styleable#TextView_privateImeOptions\n     ",
    "links" : [ "android.view.inputmethod.EditorInfo#privateImeOptions" ]
  }, {
    "name" : "public String getPrivateImeOptions()",
    "returnType" : "String",
    "comment" : "\n     * Get the private type of the content.\n     *\n     * @see #setPrivateImeOptions(String)\n     * @see EditorInfo#privateImeOptions\n     ",
    "links" : [ ]
  }, {
    "name" : "public void setInputExtras(@XmlRes int xmlResId) throws XmlPullParserException, IOException",
    "returnType" : "void",
    "comment" : "\n     * Set the extra input data of the text, which is the\n     * {@link EditorInfo#extras TextBoxAttribute.extras}\n     * Bundle that will be filled in when creating an input connection.  The\n     * given integer is the resource identifier of an XML resource holding an\n     * {@link android.R.styleable#InputExtras &lt;input-extras&gt;} XML tree.\n     *\n     * @see #getInputExtras(boolean)\n     * @see EditorInfo#extras\n     * @attr ref android.R.styleable#TextView_editorExtras\n     ",
    "links" : [ "android.R.styleable#InputExtras", "android.view.inputmethod.EditorInfo#extras" ]
  }, {
    "name" : "public Bundle getInputExtras(boolean create)",
    "returnType" : "Bundle",
    "comment" : "\n     * Retrieve the input extras currently associated with the text view, which\n     * can be viewed as well as modified.\n     *\n     * @param create If true, the extras will be created if they don't already\n     * exist.  Otherwise, null will be returned if none have been created.\n     * @see #setInputExtras(int)\n     * @see EditorInfo#extras\n     * @attr ref android.R.styleable#TextView_editorExtras\n     ",
    "links" : [ ]
  }, {
    "name" : "public void setImeHintLocales(@Nullable LocaleList hintLocales)",
    "returnType" : "void",
    "comment" : "\n     * Change \"hint\" locales associated with the text view, which will be reported to an IME with\n     * {@link EditorInfo#hintLocales} when it has focus.\n     *\n     * Starting with Android O, this also causes internationalized listeners to be created (or\n     * change locale) based on the first locale in the input locale list.\n     *\n     * <p><strong>Note:</strong> If you want new \"hint\" to take effect immediately you need to\n     * call {@link InputMethodManager#restartInput(View)}.</p>\n     * @param hintLocales List of the languages that the user is supposed to switch to no matter\n     * what input method subtype is currently used. Set {@code null} to clear the current \"hint\".\n     * @see #getImeHintLocales()\n     * @see android.view.inputmethod.EditorInfo#hintLocales\n     ",
    "links" : [ "android.view.inputmethod.InputMethodManager#restartInput(View)", "android.view.inputmethod.EditorInfo#hintLocales" ]
  }, {
    "name" : "public LocaleList getImeHintLocales()",
    "returnType" : "LocaleList",
    "comment" : "\n     * @return The current languages list \"hint\". {@code null} when no \"hint\" is available.\n     * @see #setImeHintLocales(LocaleList)\n     * @see android.view.inputmethod.EditorInfo#hintLocales\n     ",
    "links" : [ ]
  }, {
    "name" : "public CharSequence getError()",
    "returnType" : "CharSequence",
    "comment" : "\n     * Returns the error message that was set to be displayed with\n     * {@link #setError}, or <code>null</code> if no error was set\n     * or if it the error was cleared by the widget after user input.\n     ",
    "links" : [ "#setError" ]
  }, {
    "name" : "public void setError(CharSequence error)",
    "returnType" : "void",
    "comment" : "\n     * Sets the right-hand compound drawable of the TextView to the \"error\"\n     * icon and sets an error message that will be displayed in a popup when\n     * the TextView has focus.  The icon and error message will be reset to\n     * null when any key events cause changes to the TextView's text.  If the\n     * <code>error</code> is <code>null</code>, the error message and icon\n     * will be cleared.\n     ",
    "links" : [ ]
  }, {
    "name" : "public void setError(CharSequence error, Drawable icon)",
    "returnType" : "void",
    "comment" : "\n     * Sets the right-hand compound drawable of the TextView to the specified\n     * icon and sets an error message that will be displayed in a popup when\n     * the TextView has focus.  The icon and error message will be reset to\n     * null when any key events cause changes to the TextView's text.  The\n     * drawable must already have had {@link Drawable#setBounds} set on it.\n     * If the <code>error</code> is <code>null</code>, the error message will\n     * be cleared (and you should provide a <code>null</code> icon as well).\n     ",
    "links" : [ "android.graphics.drawable.Drawable#setBounds" ]
  }, {
    "name" : "protected boolean setFrame(int l, int t, int r, int b)",
    "returnType" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private void restartMarqueeIfNeeded()",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public void setFilters(InputFilter[] filters)",
    "returnType" : "void",
    "comment" : "\n     * Sets the list of input filters that will be used if the buffer is\n     * Editable. Has no effect otherwise.\n     *\n     * @attr ref android.R.styleable#TextView_maxLength\n     ",
    "links" : [ ]
  }, {
    "name" : "private void setFilters(Editable e, InputFilter[] filters)",
    "returnType" : "void",
    "comment" : "\n     * Sets the list of input filters on the specified Editable,\n     * and includes mInput in the list if it is an InputFilter.\n     ",
    "links" : [ ]
  }, {
    "name" : "public InputFilter[] getFilters()",
    "returnType" : "InputFilter[]",
    "comment" : "\n     * Returns the current list of input filters.\n     *\n     * @attr ref android.R.styleable#TextView_maxLength\n     ",
    "links" : [ ]
  }, {
    "name" : "private int getBoxHeight(Layout l)",
    "returnType" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : " int getVerticalOffset(boolean forceNormal)",
    "returnType" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private int getBottomVerticalOffset(boolean forceNormal)",
    "returnType" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : " void invalidateCursorPath()",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : " void invalidateCursor()",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private void invalidateCursor(int a, int b, int c)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : " void invalidateRegion(int start, int end, boolean invalidateCursor)",
    "returnType" : "void",
    "comment" : "\n     * Invalidates the region of text enclosed between the start and end text offsets.\n     ",
    "links" : [ ]
  }, {
    "name" : "private void registerForPreDraw()",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private void unregisterForPreDraw()",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public boolean onPreDraw()",
    "returnType" : "boolean",
    "comment" : "\n     * {@inheritDoc}\n     ",
    "links" : [ ]
  }, {
    "name" : "protected void onAttachedToWindow()",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "protected void onDetachedFromWindowInternal()",
    "returnType" : "void",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "public void onScreenStateChanged(int screenState)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "protected boolean isPaddingOffsetRequired()",
    "returnType" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "protected int getLeftPaddingOffset()",
    "returnType" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "protected int getTopPaddingOffset()",
    "returnType" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "protected int getBottomPaddingOffset()",
    "returnType" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "protected int getRightPaddingOffset()",
    "returnType" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "protected boolean verifyDrawable(@NonNull Drawable who)",
    "returnType" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public void jumpDrawablesToCurrentState()",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public void invalidateDrawable(@NonNull Drawable drawable)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public boolean hasOverlappingRendering()",
    "returnType" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public boolean isTextSelectable()",
    "returnType" : "boolean",
    "comment" : "\n     *\n     * Returns the state of the {@code textIsSelectable} flag (See\n     * {@link #setTextIsSelectable setTextIsSelectable()}). Although you have to set this flag\n     * to allow users to select and copy text in a non-editable TextView, the content of an\n     * {@link EditText} can always be selected, independently of the value of this flag.\n     * <p>\n     *\n     * @return True if the text displayed in this TextView can be selected by the user.\n     *\n     * @attr ref android.R.styleable#TextView_textIsSelectable\n     ",
    "links" : [ "#setTextIsSelectable", "android.widget.EditText" ]
  }, {
    "name" : "public void setTextIsSelectable(boolean selectable)",
    "returnType" : "void",
    "comment" : "\n     * Sets whether the content of this view is selectable by the user. The default is\n     * {@code false}, meaning that the content is not selectable.\n     * <p>\n     * When you use a TextView to display a useful piece of information to the user (such as a\n     * contact's address), make it selectable, so that the user can select and copy its\n     * content. You can also use set the XML attribute\n     * {@link android.R.styleable#TextView_textIsSelectable} to \"true\".\n     * <p>\n     * When you call this method to set the value of {@code textIsSelectable}, it sets\n     * the flags {@code focusable}, {@code focusableInTouchMode}, {@code clickable},\n     * and {@code longClickable} to the same value. These flags correspond to the attributes\n     * {@link android.R.styleable#View_focusable android:focusable},\n     * {@link android.R.styleable#View_focusableInTouchMode android:focusableInTouchMode},\n     * {@link android.R.styleable#View_clickable android:clickable}, and\n     * {@link android.R.styleable#View_longClickable android:longClickable}. To restore any of these\n     * flags to a state you had set previously, call one or more of the following methods:\n     * {@link #setFocusable(boolean) setFocusable()},\n     * {@link #setFocusableInTouchMode(boolean) setFocusableInTouchMode()},\n     * {@link #setClickable(boolean) setClickable()} or\n     * {@link #setLongClickable(boolean) setLongClickable()}.\n     *\n     * @param selectable Whether the content of this TextView should be selectable.\n     ",
    "links" : [ "#setClickable(boolean)", "android.R.styleable#View_clickable", "android.R.styleable#View_focusableInTouchMode", "android.R.styleable#View_longClickable", "#setLongClickable(boolean)", "android.R.styleable#View_focusable", "android.R.styleable#TextView_textIsSelectable", "#setFocusableInTouchMode(boolean)", "#setFocusable(boolean)" ]
  }, {
    "name" : "protected int[] onCreateDrawableState(int extraSpace)",
    "returnType" : "int[]",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private void maybeUpdateHighlightPaths()",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private void addSearchHighlightPaths()",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private Path getUpdatedHighlightPath()",
    "returnType" : "Path",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public int getHorizontalOffsetForDrawables()",
    "returnType" : "int",
    "comment" : "\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "protected void onDraw(Canvas canvas)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public void getFocusedRect(Rect r)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public int getLineCount()",
    "returnType" : "int",
    "comment" : "\n     * Return the number of lines of text, or 0 if the internal Layout has not\n     * been built.\n     ",
    "links" : [ ]
  }, {
    "name" : "public int getLineBounds(int line, Rect bounds)",
    "returnType" : "int",
    "comment" : "\n     * Return the baseline for the specified line (0...getLineCount() - 1)\n     * If bounds is not null, return the top, left, right, bottom extents\n     * of the specified line in it. If the internal Layout has not been built,\n     * return 0 and set bounds to (0, 0, 0, 0)\n     * @param line which line to examine (0..getLineCount() - 1)\n     * @param bounds Optional. If not null, it returns the extent of the line\n     * @return the Y-coordinate of the baseline\n     ",
    "links" : [ ]
  }, {
    "name" : "public int getBaseline()",
    "returnType" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : " int getBaselineOffset()",
    "returnType" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "protected int getFadeTop(boolean offsetRequired)",
    "returnType" : "int",
    "comment" : "\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "protected int getFadeHeight(boolean offsetRequired)",
    "returnType" : "int",
    "comment" : "\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public PointerIcon onResolvePointerIcon(MotionEvent event, int pointerIndex)",
    "returnType" : "PointerIcon",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public boolean onKeyPreIme(int keyCode, KeyEvent event)",
    "returnType" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public boolean handleBackInTextActionModeIfNeeded(KeyEvent event)",
    "returnType" : "boolean",
    "comment" : "\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean onKeyDown(int keyCode, KeyEvent event)",
    "returnType" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public boolean onKeyMultiple(int keyCode, int repeatCount, KeyEvent event)",
    "returnType" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private boolean shouldAdvanceFocusOnEnter()",
    "returnType" : "boolean",
    "comment" : "\n     * Returns true if pressing ENTER in this field advances focus instead\n     * of inserting the character.  This is true mostly in single-line fields,\n     * but also in mail addresses and subjects which will display on multiple\n     * lines but where it doesn't make sense to insert newlines.\n     ",
    "links" : [ ]
  }, {
    "name" : "private boolean isDirectionalNavigationKey(int keyCode)",
    "returnType" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private int doKeyDown(int keyCode, KeyEvent event, KeyEvent otherEvent)",
    "returnType" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public void resetErrorChangedFlag()",
    "returnType" : "void",
    "comment" : "\n     * Resets the mErrorWasChanged flag, so that future calls to {@link #setError(CharSequence)}\n     * can be recorded.\n     * @hide\n     ",
    "links" : [ "#setError(CharSequence)" ]
  }, {
    "name" : "public void hideErrorIfUnchanged()",
    "returnType" : "void",
    "comment" : "\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean onKeyUp(int keyCode, KeyEvent event)",
    "returnType" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private int getActionIdForEnterEvent()",
    "returnType" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public boolean onCheckIsTextEditor()",
    "returnType" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private boolean hasEditorInFocusSearchDirection(@FocusRealDirection int direction)",
    "returnType" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public InputConnection onCreateInputConnection(EditorInfo outAttrs)",
    "returnType" : "InputConnection",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public void onRequestCursorUpdatesInternal(@InputConnection.CursorUpdateMode int cursorUpdateMode, @InputConnection.CursorUpdateFilter int cursorUpdateFilter)",
    "returnType" : "void",
    "comment" : "\n     * Called back by the system to handle {@link InputConnection#requestCursorUpdates(int, int)}.\n     *\n     * @param cursorUpdateMode modes defined in {@link InputConnection.CursorUpdateMode}.\n     * @param cursorUpdateFilter modes defined in {@link InputConnection.CursorUpdateFilter}.\n     *\n     * @hide\n     ",
    "links" : [ "InputConnection.CursorUpdateMode", "android.view.inputmethod.BaseInputConnection#requestCursorUpdates(int", "InputConnection.CursorUpdateFilter" ]
  }, {
    "name" : "public boolean extractText(ExtractedTextRequest request, ExtractedText outText)",
    "returnType" : "boolean",
    "comment" : "\n     * If this TextView contains editable content, extract a portion of it\n     * based on the information in <var>request</var> in to <var>outText</var>.\n     * @return Returns true if the text was successfully extracted, else false.\n     ",
    "links" : [ ]
  }, {
    "name" : " static void removeParcelableSpans(Spannable spannable, int start, int end)",
    "returnType" : "void",
    "comment" : "\n     * This is used to remove all style-impacting spans from text before new\n     * extracted text is being replaced into it, so that we don't have any\n     * lingering spans applied during the replace.\n     ",
    "links" : [ ]
  }, {
    "name" : "public void setExtractedText(ExtractedText text)",
    "returnType" : "void",
    "comment" : "\n     * Apply to this text view the given extracted text, as previously\n     * returned by {@link #extractText(ExtractedTextRequest, ExtractedText)}.\n     ",
    "links" : [ "#extractText(ExtractedTextRequest" ]
  }, {
    "name" : "public void setExtracting(ExtractedTextRequest req)",
    "returnType" : "void",
    "comment" : "\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public void onCommitCompletion(CompletionInfo text)",
    "returnType" : "void",
    "comment" : "\n     * Called by the framework in response to a text completion from\n     * the current input method, provided by it calling\n     * {@link InputConnection#commitCompletion\n     * InputConnection.commitCompletion()}.  The default implementation does\n     * nothing; text views that are supporting auto-completion should override\n     * this to do their desired behavior.\n     *\n     * @param text The auto complete text the user has selected.\n     ",
    "links" : [ "android.view.inputmethod.BaseInputConnection#commitCompletionInputConnection.commitCompletion()" ]
  }, {
    "name" : "public void onCommitCorrection(CorrectionInfo info)",
    "returnType" : "void",
    "comment" : "\n     * Called by the framework in response to a text auto-correction (such as fixing a typo using a\n     * dictionary) from the current input method, provided by it calling\n     * {@link InputConnection#commitCorrection(CorrectionInfo) InputConnection.commitCorrection()}.\n     * The default implementation flashes the background of the corrected word to provide\n     * feedback to the user.\n     *\n     * @param info The auto correct info about the text that was corrected.\n     ",
    "links" : [ "android.view.inputmethod.BaseInputConnection#commitCorrection(CorrectionInfo)" ]
  }, {
    "name" : "public void beginBatchEdit()",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public void endBatchEdit()",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public void onBeginBatchEdit()",
    "returnType" : "void",
    "comment" : "\n     * Called by the framework in response to a request to begin a batch\n     * of edit operations through a call to link {@link #beginBatchEdit()}.\n     ",
    "links" : [ "#beginBatchEdit()" ]
  }, {
    "name" : "public void onEndBatchEdit()",
    "returnType" : "void",
    "comment" : "\n     * Called by the framework in response to a request to end a batch\n     * of edit operations through a call to link {@link #endBatchEdit}.\n     ",
    "links" : [ "#endBatchEdit" ]
  }, {
    "name" : "public void onPerformSpellCheck()",
    "returnType" : "void",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "public boolean onPrivateIMECommand(String action, Bundle data)",
    "returnType" : "boolean",
    "comment" : "\n     * Called by the framework in response to a private command from the\n     * current method, provided by it calling\n     * {@link InputConnection#performPrivateCommand\n     * InputConnection.performPrivateCommand()}.\n     *\n     * @param action The action name of the command.\n     * @param data Any additional data for the command.  This may be null.\n     * @return Return true if you handled the command, else false.\n     ",
    "links" : [ "android.view.inputmethod.BaseInputConnection#performPrivateCommandInputConnection.performPrivateCommand()" ]
  }, {
    "name" : "public boolean isOffsetMappingAvailable()",
    "returnType" : "boolean",
    "comment" : "\n     * Return whether the text is transformed and has {@link OffsetMapping}.\n     * @hide\n     ",
    "links" : [ "android.text.method.OffsetMapping" ]
  }, {
    "name" : "public boolean previewHandwritingGesture(@NonNull PreviewableHandwritingGesture gesture, @Nullable CancellationSignal cancellationSignal)",
    "returnType" : "boolean",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "public int performHandwritingSelectGesture(@NonNull SelectGesture gesture)",
    "returnType" : "int",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "private int performHandwritingSelectGesture(@NonNull SelectGesture gesture, boolean isPreview)",
    "returnType" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private int performHandwritingSelectGesture(int[] range, boolean isPreview)",
    "returnType" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public int performHandwritingSelectRangeGesture(@NonNull SelectRangeGesture gesture)",
    "returnType" : "int",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "private int performHandwritingSelectRangeGesture(@NonNull SelectRangeGesture gesture, boolean isPreview)",
    "returnType" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public int performHandwritingDeleteGesture(@NonNull DeleteGesture gesture)",
    "returnType" : "int",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "private int performHandwritingDeleteGesture(@NonNull DeleteGesture gesture, boolean isPreview)",
    "returnType" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private int performHandwritingDeleteGesture(int[] range, int granularity, boolean isPreview)",
    "returnType" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public int performHandwritingDeleteRangeGesture(@NonNull DeleteRangeGesture gesture)",
    "returnType" : "int",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "private int performHandwritingDeleteRangeGesture(@NonNull DeleteRangeGesture gesture, boolean isPreview)",
    "returnType" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private int[] adjustHandwritingDeleteGestureRange(int[] range)",
    "returnType" : "int[]",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public int performHandwritingInsertGesture(@NonNull InsertGesture gesture)",
    "returnType" : "int",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "public int performHandwritingRemoveSpaceGesture(@NonNull RemoveSpaceGesture gesture)",
    "returnType" : "int",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "public int performHandwritingJoinOrSplitGesture(@NonNull JoinOrSplitGesture gesture)",
    "returnType" : "int",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "public int performHandwritingInsertModeGesture(@NonNull InsertModeGesture gesture)",
    "returnType" : "int",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "private int handleGestureFailure(HandwritingGesture gesture)",
    "returnType" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private int handleGestureFailure(HandwritingGesture gesture, boolean isPreview)",
    "returnType" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private int getLineForHandwritingGesture(PointF point)",
    "returnType" : "int",
    "comment" : "\n     * Returns the closest line such that the point is either inside the line bounds or within\n     * {@link ViewConfiguration#getScaledHandwritingGestureLineMargin} of the line bounds. Returns\n     * -1 if the point is not within the margin of any line bounds.\n     ",
    "links" : [ "android.view.ViewConfiguration#getScaledHandwritingGestureLineMargin" ]
  }, {
    "name" : "private int[] getRangeForRect(@NonNull RectF area, int granularity)",
    "returnType" : "int[]",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private int tryInsertTextForHandwritingGesture(int offset, String textToInsert, HandwritingGesture gesture)",
    "returnType" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private Pattern getWhitespacePattern()",
    "returnType" : "Pattern",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public void nullLayouts()",
    "returnType" : "void",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "private void assumeLayout()",
    "returnType" : "void",
    "comment" : "\n     * Make a new Layout based on the already-measured size of the view,\n     * on the assumption that it was measured correctly at some point.\n     ",
    "links" : [ ]
  }, {
    "name" : "private Layout.Alignment getLayoutAlignment()",
    "returnType" : "Layout.Alignment",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private Paint.FontMetrics getResolvedMinimumFontMetrics()",
    "returnType" : "Paint.FontMetrics",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public void makeNewLayout(int wantWidth, int hintWidth, BoringLayout.Metrics boring, BoringLayout.Metrics hintBoring, int ellipsisWidth, boolean bringIntoView)",
    "returnType" : "void",
    "comment" : "\n     * The width passed in is now the desired layout width,\n     * not the full view width with padding.\n     * {@hide}\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean useDynamicLayout()",
    "returnType" : "boolean",
    "comment" : "\n     * Returns true if DynamicLayout is required\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "protected Layout makeSingleLayout(int wantWidth, BoringLayout.Metrics boring, int ellipsisWidth, Layout.Alignment alignment, boolean shouldEllipsize, TruncateAt effectiveEllipsize, boolean useSaved)",
    "returnType" : "Layout",
    "comment" : "\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "private boolean compressText(float width)",
    "returnType" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private static int desired(Layout layout, boolean useBoundsForWidth)",
    "returnType" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public void setIncludeFontPadding(boolean includepad)",
    "returnType" : "void",
    "comment" : "\n     * Set whether the TextView includes extra top and bottom padding to make\n     * room for accents that go above the normal ascent and descent.\n     * The default is true.\n     *\n     * @see #getIncludeFontPadding()\n     *\n     * @attr ref android.R.styleable#TextView_includeFontPadding\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean getIncludeFontPadding()",
    "returnType" : "boolean",
    "comment" : "\n     * Gets whether the TextView includes extra top and bottom padding to make\n     * room for accents that go above the normal ascent and descent.\n     *\n     * @see #setIncludeFontPadding(boolean)\n     *\n     * @attr ref android.R.styleable#TextView_includeFontPadding\n     ",
    "links" : [ ]
  }, {
    "name" : "protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private void autoSizeText()",
    "returnType" : "void",
    "comment" : "\n     * Automatically computes and sets the text size.\n     ",
    "links" : [ ]
  }, {
    "name" : "private int findLargestTextSizeWhichFits(RectF availableSpace)",
    "returnType" : "int",
    "comment" : "\n     * Performs a binary search to find the largest text size that will still fit within the size\n     * available to this view.\n     ",
    "links" : [ ]
  }, {
    "name" : "private boolean suggestedSizeFitsInSpace(int suggestedSizeInPx, RectF availableSpace)",
    "returnType" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private int getDesiredHeight()",
    "returnType" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private int getDesiredHeight(Layout layout, boolean cap)",
    "returnType" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private void checkForResize()",
    "returnType" : "void",
    "comment" : "\n     * Check whether a change to the existing text layout requires a\n     * new view layout.\n     ",
    "links" : [ ]
  }, {
    "name" : "private void checkForRelayout()",
    "returnType" : "void",
    "comment" : "\n     * Check whether entirely new text requires a new view layout\n     * or merely a new text layout.\n     ",
    "links" : [ ]
  }, {
    "name" : "protected void onLayout(boolean changed, int left, int top, int right, int bottom)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private boolean isShowingHint()",
    "returnType" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private boolean bringTextIntoView()",
    "returnType" : "boolean",
    "comment" : "\n     * Returns true if anything changed.\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean bringPointIntoView(int offset)",
    "returnType" : "boolean",
    "comment" : "\n     * Move the point, specified by the offset, into the view if it is needed.\n     * This has to be called after layout. Returns true if anything changed.\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean bringPointIntoView(@IntRange(from = 0) int offset, boolean requestRectWithoutFocus)",
    "returnType" : "boolean",
    "comment" : "\n     * Move the insertion position of the given offset into visible area of the View.\n     *\n     * If the View is focused or {@code requestRectWithoutFocus} is set to true, this API may call\n     * {@link View#requestRectangleOnScreen(Rect)} to bring the point to the visible area if\n     * necessary.\n     *\n     * @param offset an offset of the character.\n     * @param requestRectWithoutFocus True for calling {@link View#requestRectangleOnScreen(Rect)}\n     *                                in the unfocused state. False for calling it only the View has\n     *                                the focus.\n     * @return true if anything changed, otherwise false.\n     *\n     * @see #bringPointIntoView(int)\n     ",
    "links" : [ "android.view.View#requestRectangleOnScreen(Rect)" ]
  }, {
    "name" : "public boolean moveCursorToVisibleOffset()",
    "returnType" : "boolean",
    "comment" : "\n     * Move the cursor, if needed, so that it is at an offset that is visible\n     * to the user.  This will not move the cursor if it represents more than\n     * one character (a selection range).  This will only work if the\n     * TextView contains spannable text; otherwise it will do nothing.\n     *\n     * @return True if the cursor was actually moved, false otherwise.\n     ",
    "links" : [ ]
  }, {
    "name" : "public void computeScroll()",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private void getInterestingRect(Rect r, int line)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private void convertFromViewportToContentCoordinates(Rect r)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private PointF convertFromScreenToContentCoordinates(PointF point)",
    "returnType" : "PointF",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private RectF convertFromScreenToContentCoordinates(RectF rect)",
    "returnType" : "RectF",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : " int viewportToContentHorizontalOffset()",
    "returnType" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : " int viewportToContentVerticalOffset()",
    "returnType" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public void debug(int depth)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public int getSelectionStart()",
    "returnType" : "int",
    "comment" : "\n     * Convenience for {@link Selection#getSelectionStart}.\n     ",
    "links" : [ "android.text.Selection#getSelectionStart" ]
  }, {
    "name" : "public int getSelectionEnd()",
    "returnType" : "int",
    "comment" : "\n     * Convenience for {@link Selection#getSelectionEnd}.\n     ",
    "links" : [ "android.text.Selection#getSelectionEnd" ]
  }, {
    "name" : "public void getSelection(int start, int end, final Layout.SelectionRectangleConsumer consumer)",
    "returnType" : "void",
    "comment" : "\n     * Calculates the rectangles which should be highlighted to indicate a selection between start\n     * and end and feeds them into the given {@link Layout.SelectionRectangleConsumer}.\n     *\n     * @param start    the starting index of the selection\n     * @param end      the ending index of the selection\n     * @param consumer the {@link Layout.SelectionRectangleConsumer} which will receive the\n     *                 generated rectangles. It will be called every time a rectangle is generated.\n     * @hide\n     ",
    "links" : [ "Layout.SelectionRectangleConsumer" ]
  }, {
    "name" : " int getSelectionStartTransformed()",
    "returnType" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : " int getSelectionEndTransformed()",
    "returnType" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public boolean hasSelection()",
    "returnType" : "boolean",
    "comment" : "\n     * Return true iff there is a selection of nonzero length inside this text view.\n     ",
    "links" : [ ]
  }, {
    "name" : " String getSelectedText()",
    "returnType" : "String",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public void setSingleLine()",
    "returnType" : "void",
    "comment" : "\n     * Sets the properties of this field (lines, horizontally scrolling,\n     * transformation method) to be for a single-line input.\n     *\n     * @attr ref android.R.styleable#TextView_singleLine\n     ",
    "links" : [ ]
  }, {
    "name" : "public void setAllCaps(boolean allCaps)",
    "returnType" : "void",
    "comment" : "\n     * Sets the properties of this field to transform input to ALL CAPS\n     * display. This may use a \"small caps\" formatting if available.\n     * This setting will be ignored if this field is editable or selectable.\n     *\n     * This call replaces the current transformation method. Disabling this\n     * will not necessarily restore the previous behavior from before this\n     * was enabled.\n     *\n     * @see #setTransformationMethod(TransformationMethod)\n     * @attr ref android.R.styleable#TextView_textAllCaps\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean isAllCaps()",
    "returnType" : "boolean",
    "comment" : "\n     *\n     * Checks whether the transformation method applied to this TextView is set to ALL CAPS.\n     * @return Whether the current transformation method is for ALL CAPS.\n     *\n     * @see #setAllCaps(boolean)\n     * @see #setTransformationMethod(TransformationMethod)\n     ",
    "links" : [ ]
  }, {
    "name" : "public void setSingleLine(boolean singleLine)",
    "returnType" : "void",
    "comment" : "\n     * If true, sets the properties of this field (number of lines, horizontally scrolling,\n     * transformation method) to be for a single-line input; if false, restores these to the default\n     * conditions.\n     *\n     * Note that the default conditions are not necessarily those that were in effect prior this\n     * method, and you may want to reset these properties to your custom values.\n     *\n     * Note that due to performance reasons, by setting single line for the EditText, the maximum\n     * text length is set to 5000 if no other character limitation are applied.\n     *\n     * @attr ref android.R.styleable#TextView_singleLine\n     ",
    "links" : [ ]
  }, {
    "name" : "private void setInputTypeSingleLine(boolean singleLine)",
    "returnType" : "void",
    "comment" : "\n     * Adds or remove the EditorInfo.TYPE_TEXT_FLAG_MULTI_LINE on the mInputType.\n     * @param singleLine\n     ",
    "links" : [ ]
  }, {
    "name" : "private void applySingleLine(boolean singleLine, boolean applyTransformation, boolean changeMaxLines, boolean changeMaxLength)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public void setEllipsize(TextUtils.TruncateAt where)",
    "returnType" : "void",
    "comment" : "\n     * Causes words in the text that are longer than the view's width\n     * to be ellipsized instead of broken in the middle.  You may also\n     * want to {@link #setSingleLine} or {@link #setHorizontallyScrolling}\n     * to constrain the text to a single line.  Use <code>null</code>\n     * to turn off ellipsizing.\n     *\n     * If {@link #setMaxLines} has been used to set two or more lines,\n     * only {@link android.text.TextUtils.TruncateAt#END} and\n     * {@link android.text.TextUtils.TruncateAt#MARQUEE} are supported\n     * (other ellipsizing types will not do anything).\n     *\n     * @attr ref android.R.styleable#TextView_ellipsize\n     ",
    "links" : [ "#setSingleLine", "#setMaxLines", "android.text.TextUtils.TruncateAt#END", "android.text.TextUtils.TruncateAt#MARQUEE", "#setHorizontallyScrolling" ]
  }, {
    "name" : "public void setMarqueeRepeatLimit(int marqueeLimit)",
    "returnType" : "void",
    "comment" : "\n     * Sets how many times to repeat the marquee animation. Only applied if the\n     * TextView has marquee enabled. Set to -1 to repeat indefinitely.\n     *\n     * @see #getMarqueeRepeatLimit()\n     *\n     * @attr ref android.R.styleable#TextView_marqueeRepeatLimit\n     ",
    "links" : [ ]
  }, {
    "name" : "public int getMarqueeRepeatLimit()",
    "returnType" : "int",
    "comment" : "\n     * Gets the number of times the marquee animation is repeated. Only meaningful if the\n     * TextView has marquee enabled.\n     *\n     * @return the number of times the marquee animation is repeated. -1 if the animation\n     * repeats indefinitely\n     *\n     * @see #setMarqueeRepeatLimit(int)\n     *\n     * @attr ref android.R.styleable#TextView_marqueeRepeatLimit\n     ",
    "links" : [ ]
  }, {
    "name" : "public TextUtils.TruncateAt getEllipsize()",
    "returnType" : "TextUtils.TruncateAt",
    "comment" : "\n     * Returns where, if anywhere, words that are longer than the view\n     * is wide should be ellipsized.\n     ",
    "links" : [ ]
  }, {
    "name" : "public void setSelectAllOnFocus(boolean selectAllOnFocus)",
    "returnType" : "void",
    "comment" : "\n     * Set the TextView so that when it takes focus, all the text is\n     * selected.\n     *\n     * @attr ref android.R.styleable#TextView_selectAllOnFocus\n     ",
    "links" : [ ]
  }, {
    "name" : "public void setCursorVisible(boolean visible)",
    "returnType" : "void",
    "comment" : "\n     * Set whether the cursor is visible. The default is true. Note that this property only\n     * makes sense for editable TextView. If IME is consuming the input, the cursor will always be\n     * invisible, visibility will be updated as the last state when IME does not consume\n     * the input anymore.\n     *\n     * @see #isCursorVisible()\n     *\n     * @attr ref android.R.styleable#TextView_cursorVisible\n     ",
    "links" : [ ]
  }, {
    "name" : "public void setImeConsumesInput(boolean imeConsumesInput)",
    "returnType" : "void",
    "comment" : "\n     * Sets the IME is consuming the input and make the cursor invisible if {@code imeConsumesInput}\n     * is {@code true}. Otherwise, make the cursor visible.\n     *\n     * @param imeConsumesInput {@code true} if IME is consuming the input\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "private void updateCursorVisibleInternal()",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public boolean isCursorVisible()",
    "returnType" : "boolean",
    "comment" : "\n     * @return whether or not the cursor is visible (assuming this TextView is editable). This\n     * method may return {@code false} when the IME is consuming the input even if the\n     * {@code mEditor.mCursorVisible} attribute is {@code true} or {@code #setCursorVisible(true)}\n     * is called.\n     *\n     * @see #setCursorVisible(boolean)\n     *\n     * @attr ref android.R.styleable#TextView_cursorVisible\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean isCursorVisibleFromAttr()",
    "returnType" : "boolean",
    "comment" : "\n     * @return whether cursor is visible without regard to {@code mImeIsConsumingInput}.\n     * {@code true} is the default value.\n     *\n     * @see #setCursorVisible(boolean)\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "private boolean canMarquee()",
    "returnType" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "protected void startMarquee()",
    "returnType" : "void",
    "comment" : "\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "protected void stopMarquee()",
    "returnType" : "void",
    "comment" : "\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "private void startStopMarquee(boolean start)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "protected void onTextChanged(CharSequence text, int start, int lengthBefore, int lengthAfter)",
    "returnType" : "void",
    "comment" : "\n     * This method is called when the text is changed, in case any subclasses\n     * would like to know.\n     *\n     * Within <code>text</code>, the <code>lengthAfter</code> characters\n     * beginning at <code>start</code> have just replaced old text that had\n     * length <code>lengthBefore</code>. It is an error to attempt to make\n     * changes to <code>text</code> from this callback.\n     *\n     * @param text The text the TextView is displaying\n     * @param start The offset of the start of the range of the text that was\n     * modified\n     * @param lengthBefore The length of the former text that has been replaced\n     * @param lengthAfter The length of the replacement modified text\n     ",
    "links" : [ ]
  }, {
    "name" : "protected void onSelectionChanged(int selStart, int selEnd)",
    "returnType" : "void",
    "comment" : "\n     * This method is called when the selection has changed, in case any\n     * subclasses would like to know.\n     * </p>\n     * <p class=\"note\"><strong>Note:</strong> Always call the super implementation, which informs\n     * the accessibility subsystem about the selection change.\n     * </p>\n     *\n     * @param selStart The new selection start location.\n     * @param selEnd The new selection end location.\n     ",
    "links" : [ ]
  }, {
    "name" : "public void addTextChangedListener(TextWatcher watcher)",
    "returnType" : "void",
    "comment" : "\n     * Adds a TextWatcher to the list of those whose methods are called\n     * whenever this TextView's text changes.\n     * <p>\n     * In 1.0, the {@link TextWatcher#afterTextChanged} method was erroneously\n     * not called after {@link #setText} calls.  Now, doing {@link #setText}\n     * if there are any text changed listeners forces the buffer type to\n     * Editable if it would not otherwise be and does call this method.\n     ",
    "links" : [ "#setText", "android.text.TextWatcher#afterTextChanged" ]
  }, {
    "name" : "public void removeTextChangedListener(TextWatcher watcher)",
    "returnType" : "void",
    "comment" : "\n     * Removes the specified TextWatcher from the list of those whose\n     * methods are called\n     * whenever this TextView's text changes.\n     ",
    "links" : [ ]
  }, {
    "name" : "private void sendBeforeTextChanged(CharSequence text, int start, int before, int after)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private void removeIntersectingNonAdjacentSpans(int start, int end, Class<T> type)",
    "returnType" : "void",
    "comment" : " Removes all spans that are inside or actually overlap the start..end range",
    "links" : [ ]
  }, {
    "name" : " void removeAdjacentSuggestionSpans(final int pos)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : " void sendOnTextChanged(CharSequence text, int start, int before, int after)",
    "returnType" : "void",
    "comment" : "\n     * Not private so it can be called from an inner class without going\n     * through a thunk.\n     ",
    "links" : [ ]
  }, {
    "name" : " void sendAfterTextChanged(Editable text)",
    "returnType" : "void",
    "comment" : "\n     * Not private so it can be called from an inner class without going\n     * through a thunk.\n     ",
    "links" : [ ]
  }, {
    "name" : "private void notifyListeningManagersAfterTextChanged()",
    "returnType" : "void",
    "comment" : "\n     * Notify managers (such as {@link AutofillManager} and {@link ContentCaptureManager}) that are\n     * interested on text changes.\n     ",
    "links" : [ "android.view.contentcapture.ContentCaptureManager", "android.view.autofill.AutofillManager" ]
  }, {
    "name" : "public void notifyContentCaptureTextChanged()",
    "returnType" : "void",
    "comment" : "\n     * Notifies the ContentCapture service that the text of the view has changed (only if\n     * ContentCapture has been notified of this view's existence already).\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "private boolean isAutofillable()",
    "returnType" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : " void updateAfterEdit()",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : " void handleTextChanged(CharSequence buffer, int start, int before, int after)",
    "returnType" : "void",
    "comment" : "\n     * Not private so it can be called from an inner class without going\n     * through a thunk.\n     ",
    "links" : [ ]
  }, {
    "name" : " void spanChange(Spanned buf, Object what, int oldStart, int newStart, int oldEnd, int newEnd)",
    "returnType" : "void",
    "comment" : "\n     * Not private so it can be called from an inner class without going\n     * through a thunk.\n     ",
    "links" : [ ]
  }, {
    "name" : "protected void onFocusChanged(boolean focused, int direction, Rect previouslyFocusedRect)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public void onWindowFocusChanged(boolean hasWindowFocus)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "protected void onVisibilityChanged(View changedView, int visibility)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public void onVisibilityAggregated(boolean isVisible)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public void clearComposingText()",
    "returnType" : "void",
    "comment" : "\n     * Use {@link BaseInputConnection#removeComposingSpans\n     * BaseInputConnection.removeComposingSpans()} to remove any IME composing\n     * state from this text view.\n     ",
    "links" : [ "android.view.inputmethod.BaseInputConnection#removeComposingSpansBaseInputConnection.removeComposingSpans()" ]
  }, {
    "name" : "public void setSelected(boolean selected)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : " boolean isFromPrimePointer(MotionEvent event, boolean fromHandleView)",
    "returnType" : "boolean",
    "comment" : "\n     * Called from onTouchEvent() to prevent the touches by secondary fingers.\n     * Dragging on handles can revise cursor/selection, so can dragging on the text view.\n     * This method is a lock to avoid processing multiple fingers on both text view and handles.\n     * Note: multiple fingers on handles (e.g. 2 fingers on the 2 selection handles) should work.\n     *\n     * @param event The motion event that is being handled and carries the pointer info.\n     * @param fromHandleView true if the event is delivered to selection handle or insertion\n     * handle; false if this event is delivered to TextView.\n     * @return Returns true to indicate that onTouchEvent() can continue processing the motion\n     * event, otherwise false.\n     *  - Always returns true for the first finger.\n     *  - For secondary fingers, if the first or current finger is from TextView, returns false.\n     *    This is to make touch mutually exclusive between the TextView and the handles, but\n     *    not among the handles.\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean onTouchEvent(MotionEvent event)",
    "returnType" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private boolean shouldStartHandwritingForEndOfLineTap(MotionEvent actionUpEvent)",
    "returnType" : "boolean",
    "comment" : "\n     * If handwriting is supported, the TextView is already focused and not empty, and the cursor is\n     * at the end of a line, a stylus tap after the end of the line will trigger handwriting.\n     ",
    "links" : [ ]
  }, {
    "name" : "public final boolean showUIForTouchScreen()",
    "returnType" : "boolean",
    "comment" : "\n     * Returns true when need to show UIs, e.g. floating toolbar, etc, for finger based interaction.\n     *\n     * @return true if UIs need to show for finger interaciton. false if UIs are not necessary.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "private boolean showAutofillDialog()",
    "returnType" : "boolean",
    "comment" : "\n     * The fill dialog UI is a more conspicuous and efficient interface than dropdown UI.\n     * If autofill suggestions are available when the user clicks on a field that supports filling\n     * the dialog UI, Autofill will pop up a fill dialog. The dialog will take up a larger area\n     * to display the datasets, so it is easy for users to pay attention to the datasets and\n     * selecting a dataset. The autofill dialog is shown as the bottom sheet, the better\n     * experience is not to show the IME if there is a fill dialog.\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean onGenericMotionEvent(MotionEvent event)",
    "returnType" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "protected void onCreateContextMenu(ContextMenu menu)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public boolean showContextMenu()",
    "returnType" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public boolean showContextMenu(float x, float y)",
    "returnType" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : " boolean isTextEditable()",
    "returnType" : "boolean",
    "comment" : "\n     * @return True iff this TextView contains a text that can be edited, or if this is\n     * a selectable TextView.\n     ",
    "links" : [ ]
  }, {
    "name" : " boolean isTextAutofillable()",
    "returnType" : "boolean",
    "comment" : "\n     * @return true if this TextView could be filled by an Autofill service. Note that disabled\n     * fields can still be filled.\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean didTouchFocusSelect()",
    "returnType" : "boolean",
    "comment" : "\n     * Returns true, only while processing a touch gesture, if the initial\n     * touch down event caused focus to move to the text view and as a result\n     * its selection changed.  Only valid while processing the touch gesture\n     * of interest, in an editable text view.\n     ",
    "links" : [ ]
  }, {
    "name" : "public void cancelLongPress()",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public boolean onTrackballEvent(MotionEvent event)",
    "returnType" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public void setScroller(Scroller s)",
    "returnType" : "void",
    "comment" : "\n     * Sets the Scroller used for producing a scrolling animation\n     *\n     * @param s A Scroller instance\n     ",
    "links" : [ ]
  }, {
    "name" : "protected float getLeftFadingEdgeStrength()",
    "returnType" : "float",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "protected float getRightFadingEdgeStrength()",
    "returnType" : "float",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private float getHorizontalFadingEdgeStrength(float position1, float position2)",
    "returnType" : "float",
    "comment" : "\n     * Calculates the fading edge strength as the ratio of the distance between two\n     * horizontal positions to {@link View#getHorizontalFadingEdgeLength()}. Uses the absolute\n     * value for the distance calculation.\n     *\n     * @param position1 A horizontal position.\n     * @param position2 A horizontal position.\n     * @return Fading edge strength between [0.0f, 1.0f].\n     ",
    "links" : [ "android.view.View#getHorizontalFadingEdgeLength()" ]
  }, {
    "name" : "private boolean isMarqueeFadeEnabled()",
    "returnType" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "protected int computeHorizontalScrollRange()",
    "returnType" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "protected int computeVerticalScrollRange()",
    "returnType" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "protected int computeVerticalScrollExtent()",
    "returnType" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public void findViewsWithText(ArrayList<View> outViews, CharSequence searched, int flags)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public static ColorStateList getTextColors(Context context, TypedArray attrs)",
    "returnType" : "ColorStateList",
    "comment" : "\n     * Returns the TextView_textColor attribute from the TypedArray, if set, or\n     * the TextAppearance_textColor from the TextView_textAppearance attribute,\n     * if TextView_textColor was not set directly.\n     *\n     * @removed\n     ",
    "links" : [ ]
  }, {
    "name" : "public static int getTextColor(Context context, TypedArray attrs, int def)",
    "returnType" : "int",
    "comment" : "\n     * Returns the default color from the TextView_textColor attribute from the\n     * AttributeSet, if set, or the default color from the\n     * TextAppearance_textColor from the TextView_textAppearance attribute, if\n     * TextView_textColor was not set directly.\n     *\n     * @removed\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean onKeyShortcut(int keyCode, KeyEvent event)",
    "returnType" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : " boolean canSelectText()",
    "returnType" : "boolean",
    "comment" : "\n     * Unlike {@link #textCanBeSelected()}, this method is based on the <i>current</i> state of the\n     * TextView. {@link #textCanBeSelected()} has to be true (this is one of the conditions to have\n     * a selection controller (see {@link Editor#prepareCursorControllers()}), but this is not\n     * sufficient.\n     ",
    "links" : [ "#textCanBeSelected()", "android.widget.Editor#prepareCursorControllers()" ]
  }, {
    "name" : " boolean textCanBeSelected()",
    "returnType" : "boolean",
    "comment" : "\n     * Test based on the <i>intrinsic</i> charateristics of the TextView.\n     * The text must be spannable and the movement method must allow for arbitary selection.\n     *\n     * See also {@link #canSelectText()}.\n     ",
    "links" : [ "#canSelectText()" ]
  }, {
    "name" : "private Locale getTextServicesLocale(boolean allowNullLocale)",
    "returnType" : "Locale",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public final void setTextOperationUser(@Nullable UserHandle user)",
    "returnType" : "void",
    "comment" : "\n     * Associate {@link UserHandle} who is considered to be the logical owner of the text shown in\n     * this {@link TextView}.\n     *\n     * <p>Most of applications should not worry about this.  Some privileged apps that host UI for\n     * other apps may need to set this so that the system can user right user's resources and\n     * services such as input methods and spell checkers.</p>\n     *\n     * @param user {@link UserHandle} who is considered to be the owner of the text shown in this\n     *        {@link TextView}. {@code null} to reset {@link #mTextOperationUser}.\n     * @hide\n     ",
    "links" : [ "android.widget.TextView", "android.os.UserHandle", "#mTextOperationUser" ]
  }, {
    "name" : "public boolean isAutoHandwritingEnabled()",
    "returnType" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public boolean shouldTrackHandwritingArea()",
    "returnType" : "boolean",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "public boolean isStylusHandwritingAvailable()",
    "returnType" : "boolean",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : " final TextServicesManager getTextServicesManagerForUser()",
    "returnType" : "TextServicesManager",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : " final ClipboardManager getClipboardManagerForUser()",
    "returnType" : "ClipboardManager",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : " final TextClassificationManager getTextClassificationManagerForUser()",
    "returnType" : "TextClassificationManager",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : " final T getServiceManagerForUser(String packageName, Class<T> managerClazz)",
    "returnType" : "T",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : " void startActivityAsTextOperationUserIfNecessary(@NonNull Intent intent)",
    "returnType" : "void",
    "comment" : "\n     * Starts {@link Activity} as a text-operation user if it is specified with\n     * {@link #setTextOperationUser(UserHandle)}.\n     *\n     * <p>Otherwise, just starts {@link Activity} with {@link Context#startActivity(Intent)}.</p>\n     *\n     * @param intent The description of the activity to start.\n     ",
    "links" : [ "android.app.Activity", "#setTextOperationUser(UserHandle)", "android.content.Context#startActivity(Intent)" ]
  }, {
    "name" : "public Locale getTextServicesLocale()",
    "returnType" : "Locale",
    "comment" : " by catching intent of keyboard switch event",
    "links" : [ ]
  }, {
    "name" : "public boolean isInExtractedMode()",
    "returnType" : "boolean",
    "comment" : "\n     * @return {@code true} if this TextView is specialized for showing and interacting with the\n     * extracted text in a full-screen input method.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "private boolean isAutoSizeEnabled()",
    "returnType" : "boolean",
    "comment" : "\n     * @return {@code true} if this widget supports auto-sizing text and has been configured to\n     * auto-size.\n     ",
    "links" : [ ]
  }, {
    "name" : "protected boolean supportsAutoSizeText()",
    "returnType" : "boolean",
    "comment" : "\n     * @return {@code true} if this TextView supports auto-sizing text to fit within its container.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public Locale getSpellCheckerLocale()",
    "returnType" : "Locale",
    "comment" : "\n     * This is a temporary method. Future versions may support multi-locale text.\n     * Caveat: This method may not return the latest spell checker locale, but this should be\n     * acceptable and it's more important to make this method asynchronous.\n     *\n     * @return The locale that should be used for a spell checker in this TextView,\n     * based on the current spell checker settings, the current IME's locale, or the system default\n     * locale.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "private void updateTextServicesLocaleAsync()",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private void updateTextServicesLocaleLocked()",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : " void onLocaleChanged()",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public WordIterator getWordIterator()",
    "returnType" : "WordIterator",
    "comment" : "\n     * This method is used by the ArrowKeyMovementMethod to jump from one word to the other.\n     * Made available to achieve a consistent behavior.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public void onPopulateAccessibilityEventInternal(AccessibilityEvent event)",
    "returnType" : "void",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "public CharSequence getAccessibilityClassName()",
    "returnType" : "CharSequence",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "protected void onProvideStructure(@NonNull ViewStructure structure, @ViewStructureType int viewFor, int flags)",
    "returnType" : "void",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : " boolean canRequestAutofill()",
    "returnType" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private void requestAutofill()",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public void autofill(AutofillValue value)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public int getAutofillType()",
    "returnType" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public AutofillValue getAutofillValue()",
    "returnType" : "AutofillValue",
    "comment" : "\n     * Gets the {@link TextView}'s current text for AutoFill. The value is trimmed to 100K\n     * {@code char}s if longer.\n     *\n     * @return current text, {@code null} if the text is not editable\n     *\n     * @see View#getAutofillValue()\n     ",
    "links" : [ "android.widget.TextView" ]
  }, {
    "name" : "public void onInitializeAccessibilityEventInternal(AccessibilityEvent event)",
    "returnType" : "void",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "public void onInitializeAccessibilityNodeInfoInternal(AccessibilityNodeInfo info)",
    "returnType" : "void",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "public void addExtraDataToAccessibilityNodeInfo(AccessibilityNodeInfo info, String extraDataKey, Bundle arguments)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private boolean getViewVisibleRect(Rect rect)",
    "returnType" : "boolean",
    "comment" : "\n     * Helper method to set {@code rect} to this TextView's non-clipped area in its own coordinates.\n     * This method obtains the view's visible rectangle whereas the method\n     * {@link #getContentVisibleRect} returns the text layout's visible rectangle.\n     *\n     * @return true if at least part of the text content is visible; false if the text content is\n     * completely clipped or translated out of the visible area.\n     ",
    "links" : [ "#getContentVisibleRect" ]
  }, {
    "name" : "private boolean getContentVisibleRect(Rect rect)",
    "returnType" : "boolean",
    "comment" : "\n     * Helper method to set {@code rect} to the text content's non-clipped area in the view's\n     * coordinates.\n     *\n     * @return true if at least part of the text content is visible; false if the text content is\n     * completely clipped or translated out of the visible area.\n     ",
    "links" : [ ]
  }, {
    "name" : "public void populateCharacterBounds(CursorAnchorInfo.Builder builder, int startIndex, int endIndex, float viewportToContentHorizontalOffset, float viewportToContentVerticalOffset)",
    "returnType" : "void",
    "comment" : "\n     * Populate requested character bounds in a {@link CursorAnchorInfo.Builder}\n     *\n     * @param builder The builder to populate\n     * @param startIndex The starting character index to populate\n     * @param endIndex The ending character index to populate\n     * @param viewportToContentHorizontalOffset The horizontal offset from the viewport to the\n     * content\n     * @param viewportToContentVerticalOffset The vertical offset from the viewport to the content\n     * @hide\n     ",
    "links" : [ "CursorAnchorInfo.Builder" ]
  }, {
    "name" : "private float[] getCharacterBounds(int start, int end, float layoutLeft, float layoutTop)",
    "returnType" : "float[]",
    "comment" : "\n     * Return the bounds of the characters in the given range, in TextView's coordinates.\n     *\n     * @param start the start index of the interested text range, inclusive.\n     * @param end the end index of the interested text range, exclusive.\n     * @param layoutLeft the left of the given {@code layout} in the editor view's coordinates.\n     * @param layoutTop  the top of the given {@code layout} in the editor view's coordinates.\n     * @return the character bounds stored in a flattened array, in the editor view's coordinates.\n     ",
    "links" : [ ]
  }, {
    "name" : "public CursorAnchorInfo getCursorAnchorInfo(@InputConnection.CursorUpdateFilter int filter, @NonNull CursorAnchorInfo.Builder cursorAnchorInfoBuilder, @NonNull Matrix viewToScreenMatrix)",
    "returnType" : "CursorAnchorInfo",
    "comment" : "\n     * Compute {@link CursorAnchorInfo} from this {@link TextView}.\n     *\n     * @param filter the {@link CursorAnchorInfo} update filter which specified the needed\n     *               information from IME.\n     * @param cursorAnchorInfoBuilder a cached {@link CursorAnchorInfo.Builder} object used to build\n     *                                the result {@link CursorAnchorInfo}.\n     * @param viewToScreenMatrix a cached {@link Matrix} object used to compute the view to screen\n     *                           matrix.\n     * @return the result {@link CursorAnchorInfo} to be passed to IME.\n     * @hide\n     ",
    "links" : [ "android.widget.TextView", "android.view.inputmethod.CursorAnchorInfo", "android.graphics.Matrix", "CursorAnchorInfo.Builder" ]
  }, {
    "name" : "public TextBoundsInfo getTextBoundsInfo(@NonNull RectF bounds)",
    "returnType" : "TextBoundsInfo",
    "comment" : "\n     * Creates the {@link TextBoundsInfo} for the text lines that intersects with the {@code rectF}.\n     * @hide\n     ",
    "links" : [ "android.view.inputmethod.TextBoundsInfo" ]
  }, {
    "name" : "public boolean isPositionVisible(final float positionX, final float positionY)",
    "returnType" : "boolean",
    "comment" : "\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean performAccessibilityActionInternal(int action, Bundle arguments)",
    "returnType" : "boolean",
    "comment" : "\n     * Performs an accessibility action after it has been offered to the\n     * delegate.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "private boolean performAccessibilityActionClick(Bundle arguments)",
    "returnType" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private void requestFocusOnNonEditableSelectableText()",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private boolean hasSpannableText()",
    "returnType" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public void sendAccessibilityEventInternal(int eventType)",
    "returnType" : "void",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "public void sendAccessibilityEventUnchecked(AccessibilityEvent event)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private CharSequence getTextForAccessibility()",
    "returnType" : "CharSequence",
    "comment" : "\n     * Returns the text that should be exposed to accessibility services.\n     * <p>\n     * This approximates what is displayed visually.\n     *\n     * @return the text that should be exposed to accessibility services, may\n     *         be {@code null} if no text is set\n     ",
    "links" : [ ]
  }, {
    "name" : " boolean isVisibleToAccessibility()",
    "returnType" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : " void sendAccessibilityEventTypeViewTextChanged(CharSequence beforeText, int fromIndex, int removedCount, int addedCount)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : " void sendAccessibilityEventTypeViewTextChanged(CharSequence beforeText, int fromIndex, int toIndex)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private InputMethodManager getInputMethodManager()",
    "returnType" : "InputMethodManager",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public boolean isInputMethodTarget()",
    "returnType" : "boolean",
    "comment" : "\n     * Returns whether this text view is a current input method target.  The\n     * default implementation just checks with {@link InputMethodManager}.\n     * @return True if the TextView is a current input method target; false otherwise.\n     ",
    "links" : [ "android.view.inputmethod.InputMethodManager" ]
  }, {
    "name" : "public boolean onTextContextMenuItem(int id)",
    "returnType" : "boolean",
    "comment" : "\n     * Called when a context menu option for the text view is selected.  Currently\n     * this will be one of {@link android.R.id#selectAll}, {@link android.R.id#cut},\n     * {@link android.R.id#copy}, {@link android.R.id#paste},\n     * {@link android.R.id#pasteAsPlainText} (starting at API level23) or\n     * {@link android.R.id#shareText}.\n     *\n     * @return true if the context menu item action was performed.\n     ",
    "links" : [ "android.R.id#paste", "android.R.id#cut", "android.R.id#selectAll", "android.R.id#pasteAsPlainText", "android.R.id#shareText", "android.R.id#copy" ]
  }, {
    "name" : " CharSequence getTransformedText(int start, int end)",
    "returnType" : "CharSequence",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public boolean performLongClick()",
    "returnType" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "protected void onScrollChanged(int horiz, int vert, int oldHoriz, int oldVert)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public boolean isSuggestionsEnabled()",
    "returnType" : "boolean",
    "comment" : "\n     * Return whether or not suggestions are enabled on this TextView. The suggestions are generated\n     * by the IME or by the spell checker as the user types. This is done by adding\n     * {@link SuggestionSpan}s to the text.\n     *\n     * When suggestions are enabled (default), this list of suggestions will be displayed when the\n     * user asks for them on these parts of the text. This value depends on the inputType of this\n     * TextView.\n     *\n     * The class of the input type must be {@link InputType#TYPE_CLASS_TEXT}.\n     *\n     * In addition, the type variation must be one of\n     * {@link InputType#TYPE_TEXT_VARIATION_NORMAL},\n     * {@link InputType#TYPE_TEXT_VARIATION_EMAIL_SUBJECT},\n     * {@link InputType#TYPE_TEXT_VARIATION_LONG_MESSAGE},\n     * {@link InputType#TYPE_TEXT_VARIATION_SHORT_MESSAGE} or\n     * {@link InputType#TYPE_TEXT_VARIATION_WEB_EDIT_TEXT}.\n     *\n     * And finally, the {@link InputType#TYPE_TEXT_FLAG_NO_SUGGESTIONS} flag must <i>not</i> be set.\n     *\n     * @return true if the suggestions popup window is enabled, based on the inputType.\n     ",
    "links" : [ "android.text.InputType#TYPE_TEXT_VARIATION_SHORT_MESSAGE", "android.text.style.SuggestionSpan", "android.text.InputType#TYPE_TEXT_FLAG_NO_SUGGESTIONS", "android.text.InputType#TYPE_TEXT_VARIATION_EMAIL_SUBJECT", "android.text.InputType#TYPE_TEXT_VARIATION_LONG_MESSAGE", "android.text.InputType#TYPE_CLASS_TEXT", "android.text.InputType#TYPE_TEXT_VARIATION_WEB_EDIT_TEXT", "android.text.InputType#TYPE_TEXT_VARIATION_NORMAL" ]
  }, {
    "name" : "public void setCustomSelectionActionModeCallback(ActionMode.Callback actionModeCallback)",
    "returnType" : "void",
    "comment" : "\n     * If provided, this ActionMode.Callback will be used to create the ActionMode when text\n     * selection is initiated in this View.\n     *\n     * <p>The standard implementation populates the menu with a subset of Select All, Cut, Copy,\n     * Paste, Replace and Share actions, depending on what this View supports.\n     *\n     * <p>A custom implementation can add new entries in the default menu in its\n     * {@link android.view.ActionMode.Callback#onPrepareActionMode(ActionMode, android.view.Menu)}\n     * method. The default actions can also be removed from the menu using\n     * {@link android.view.Menu#removeItem(int)} and passing {@link android.R.id#selectAll},\n     * {@link android.R.id#cut}, {@link android.R.id#copy}, {@link android.R.id#paste},\n     * {@link android.R.id#pasteAsPlainText} (starting at API level23),\n     * {@link android.R.id#replaceText} or {@link android.R.id#shareText} ids as parameters.\n     *\n     * <p>Returning false from\n     * {@link android.view.ActionMode.Callback#onCreateActionMode(ActionMode, android.view.Menu)}\n     * will prevent the action mode from being started.\n     *\n     * <p>Action click events should be handled by the custom implementation of\n     * {@link android.view.ActionMode.Callback#onActionItemClicked(ActionMode,\n     * android.view.MenuItem)}.\n     *\n     * <p>Note that text selection mode is not started when a TextView receives focus and the\n     * {@link android.R.attr#selectAllOnFocus} flag has been set. The content is highlighted in\n     * that case, to allow for quick replacement.\n     ",
    "links" : [ "android.R.id#paste", "android.R.id#cut", "android.R.attr#selectAllOnFocus", "android.R.id#selectAll", "android.R.id#pasteAsPlainText", "android.R.id#shareText", "android.view.ActionMode.Callback#onCreateActionMode(ActionMode", "android.view.ActionMode.Callback#onPrepareActionMode(ActionMode", "android.R.id#copy", "android.view.ActionMode.Callback#onActionItemClicked(ActionMode", "android.view.Menu#removeItem(int)", "android.R.id#replaceText" ]
  }, {
    "name" : "public ActionMode.Callback getCustomSelectionActionModeCallback()",
    "returnType" : "ActionMode.Callback",
    "comment" : "\n     * Retrieves the value set in {@link #setCustomSelectionActionModeCallback}. Default is null.\n     *\n     * @return The current custom selection callback.\n     ",
    "links" : [ "#setCustomSelectionActionModeCallback" ]
  }, {
    "name" : "public void setCustomInsertionActionModeCallback(ActionMode.Callback actionModeCallback)",
    "returnType" : "void",
    "comment" : "\n     * If provided, this ActionMode.Callback will be used to create the ActionMode when text\n     * insertion is initiated in this View.\n     * The standard implementation populates the menu with a subset of Select All,\n     * Paste and Replace actions, depending on what this View supports.\n     *\n     * <p>A custom implementation can add new entries in the default menu in its\n     * {@link android.view.ActionMode.Callback#onPrepareActionMode(android.view.ActionMode,\n     * android.view.Menu)} method. The default actions can also be removed from the menu using\n     * {@link android.view.Menu#removeItem(int)} and passing {@link android.R.id#selectAll},\n     * {@link android.R.id#paste}, {@link android.R.id#pasteAsPlainText} (starting at API\n     * level23) or {@link android.R.id#replaceText} ids as parameters.</p>\n     *\n     * <p>Returning false from\n     * {@link android.view.ActionMode.Callback#onCreateActionMode(android.view.ActionMode,\n     * android.view.Menu)} will prevent the action mode from being started.</p>\n     *\n     * <p>Action click events should be handled by the custom implementation of\n     * {@link android.view.ActionMode.Callback#onActionItemClicked(android.view.ActionMode,\n     * android.view.MenuItem)}.</p>\n     *\n     * <p>Note that text insertion mode is not started when a TextView receives focus and the\n     * {@link android.R.attr#selectAllOnFocus} flag has been set.</p>\n     ",
    "links" : [ "android.view.ActionMode.Callback#onCreateActionMode(android.view.ActionMode", "android.R.id#paste", "android.R.attr#selectAllOnFocus", "android.R.id#selectAll", "android.R.id#pasteAsPlainText", "android.view.ActionMode.Callback#onPrepareActionMode(android.view.ActionMode", "android.view.ActionMode.Callback#onActionItemClicked(android.view.ActionMode", "android.view.Menu#removeItem(int)", "android.R.id#replaceText" ]
  }, {
    "name" : "public ActionMode.Callback getCustomInsertionActionModeCallback()",
    "returnType" : "ActionMode.Callback",
    "comment" : "\n     * Retrieves the value set in {@link #setCustomInsertionActionModeCallback}. Default is null.\n     *\n     * @return The current custom insertion callback.\n     ",
    "links" : [ "#setCustomInsertionActionModeCallback" ]
  }, {
    "name" : "public void setTextClassifier(@Nullable TextClassifier textClassifier)",
    "returnType" : "void",
    "comment" : "\n     * Sets the {@link TextClassifier} for this TextView.\n     ",
    "links" : [ "android.view.textclassifier.TextClassifier" ]
  }, {
    "name" : "public TextClassifier getTextClassifier()",
    "returnType" : "TextClassifier",
    "comment" : "\n     * Returns the {@link TextClassifier} used by this TextView.\n     * If no TextClassifier has been set, this TextView uses the default set by the\n     * {@link TextClassificationManager}.\n     ",
    "links" : [ "android.view.textclassifier.TextClassifier", "android.view.textclassifier.TextClassificationManager" ]
  }, {
    "name" : " TextClassifier getTextClassificationSession()",
    "returnType" : "TextClassifier",
    "comment" : "\n     * Returns a session-aware text classifier.\n     * This method creates one if none already exists or the current one is destroyed.\n     ",
    "links" : [ ]
  }, {
    "name" : " TextClassificationContext getTextClassificationContext()",
    "returnType" : "TextClassificationContext",
    "comment" : "\n     * Returns the {@link TextClassificationContext} for the current TextClassifier session.\n     * @see #getTextClassificationSession()\n     ",
    "links" : [ "android.view.textclassifier.TextClassificationContext" ]
  }, {
    "name" : " boolean usesNoOpTextClassifier()",
    "returnType" : "boolean",
    "comment" : "\n     * Returns true if this TextView uses a no-op TextClassifier.\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean requestActionMode(@NonNull TextLinks.TextLinkSpan clickedSpan)",
    "returnType" : "boolean",
    "comment" : "\n     * Starts an ActionMode for the specified TextLinkSpan.\n     *\n     * @return Whether or not we're attempting to start the action mode.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean handleClick(@NonNull TextLinks.TextLinkSpan clickedSpan)",
    "returnType" : "boolean",
    "comment" : "\n     * Handles a click on the specified TextLinkSpan.\n     *\n     * @return Whether or not the click is being handled.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "protected void stopTextActionMode()",
    "returnType" : "void",
    "comment" : "\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public void hideFloatingToolbar(int durationMs)",
    "returnType" : "void",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : " boolean canUndo()",
    "returnType" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : " boolean canRedo()",
    "returnType" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : " boolean canCut()",
    "returnType" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : " boolean canCopy()",
    "returnType" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : " boolean canReplace()",
    "returnType" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : " boolean canShare()",
    "returnType" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : " boolean isDeviceProvisioned()",
    "returnType" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : " boolean canPaste()",
    "returnType" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : " boolean canPasteAsPlainText()",
    "returnType" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : " boolean canProcessText()",
    "returnType" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : " boolean canSelectAllText()",
    "returnType" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : " boolean selectAllText()",
    "returnType" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private void paste(boolean withFormatting)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private void shareSelectedText()",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private boolean setPrimaryClip(ClipData clip)",
    "returnType" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public int getOffsetForPosition(float x, float y)",
    "returnType" : "int",
    "comment" : "\n     * Get the character offset closest to the specified absolute position. A typical use case is to\n     * pass the result of {@link MotionEvent#getX()} and {@link MotionEvent#getY()} to this method.\n     *\n     * @param x The horizontal absolute position of a point on screen\n     * @param y The vertical absolute position of a point on screen\n     * @return the character offset for the character whose position is closest to the specified\n     *  position. Returns -1 if there is no layout.\n     ",
    "links" : [ "android.view.MotionEvent#getY()", "android.view.MotionEvent#getX()" ]
  }, {
    "name" : " float convertToLocalHorizontalCoordinate(float x)",
    "returnType" : "float",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public int getLineAtCoordinate(float y)",
    "returnType" : "int",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : " int getLineAtCoordinateUnclamped(float y)",
    "returnType" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : " int getOffsetAtCoordinate(int line, float x)",
    "returnType" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public int transformedToOriginal(int offset, @OffsetMapping.MapStrategy int strategy)",
    "returnType" : "int",
    "comment" : "\n     * Convenient method to convert an offset on the transformed text to the original text.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public int originalToTransformed(int offset, @OffsetMapping.MapStrategy int strategy)",
    "returnType" : "int",
    "comment" : "\n     * Convenient method to convert an offset on the original text to the transformed text.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean onDragEvent(DragEvent event)",
    "returnType" : "boolean",
    "comment" : "\n     * Handles drag events sent by the system following a call to\n     * {@link android.view.View#startDragAndDrop(ClipData,DragShadowBuilder,Object,int)\n     * startDragAndDrop()}.\n     *\n     * <p>If this text view is not editable, delegates to the default {@link View#onDragEvent}\n     * implementation.\n     *\n     * <p>If this text view is editable, accepts all drag actions (returns true for an\n     * {@link android.view.DragEvent#ACTION_DRAG_STARTED ACTION_DRAG_STARTED} event and all\n     * subsequent drag events). While the drag is in progress, updates the cursor position\n     * to follow the touch location. Once a drop event is received, handles content insertion\n     * via {@link #performReceiveContent}.\n     *\n     * @param event The {@link android.view.DragEvent} sent by the system.\n     * The {@link android.view.DragEvent#getAction()} method returns an action type constant\n     * defined in DragEvent, indicating the type of drag event represented by this object.\n     * @return Returns true if this text view is editable and delegates to super otherwise.\n     * See {@link View#onDragEvent}.\n     ",
    "links" : [ "#performReceiveContent", "android.view.DragEvent", "android.view.View#onDragEvent", "android.view.DragEvent#ACTION_DRAG_STARTED", "android.view.DragEvent#getAction()", "android.view.View#startDragAndDrop(ClipData" ]
  }, {
    "name" : " boolean isInBatchEditMode()",
    "returnType" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public void onRtlPropertiesChanged(int layoutDirection)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public TextDirectionHeuristic getTextDirectionHeuristic()",
    "returnType" : "TextDirectionHeuristic",
    "comment" : "\n     * Returns resolved {@link TextDirectionHeuristic} that will be used for text layout.\n     * The {@link TextDirectionHeuristic} that is used by TextView is only available after\n     * {@link #getTextDirection()} and {@link #getLayoutDirection()} is resolved. Therefore the\n     * return value may not be the same as the one TextView uses if the View's layout direction is\n     * not resolved or detached from parent root view.\n     ",
    "links" : [ "#getLayoutDirection()", "#getTextDirection()", "android.text.TextDirectionHeuristic" ]
  }, {
    "name" : "public void onResolveDrawables(int layoutDirection)",
    "returnType" : "void",
    "comment" : "\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "private void prepareDrawableForDisplay(@Nullable Drawable dr)",
    "returnType" : "void",
    "comment" : "\n     * Prepares a drawable for display by propagating layout direction and\n     * drawable state.\n     *\n     * @param dr the drawable to prepare\n     ",
    "links" : [ ]
  }, {
    "name" : "protected void resetResolvedDrawables()",
    "returnType" : "void",
    "comment" : "\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "protected void viewClicked(InputMethodManager imm)",
    "returnType" : "void",
    "comment" : "\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "protected void deleteText_internal(int start, int end)",
    "returnType" : "void",
    "comment" : "\n     * Deletes the range of text [start, end[.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "protected void replaceText_internal(int start, int end, CharSequence text)",
    "returnType" : "void",
    "comment" : "\n     * Replaces the range of text [start, end[ by replacement text\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "protected void setSpan_internal(Object span, int start, int end, int flags)",
    "returnType" : "void",
    "comment" : "\n     * Sets a span on the specified range of text\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "protected void setCursorPosition_internal(int start, int end)",
    "returnType" : "void",
    "comment" : "\n     * Moves the cursor to the specified offset position in text\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "private void createEditorIfNeeded()",
    "returnType" : "void",
    "comment" : "\n     * An Editor should be created as soon as any of the editable-specific fields (grouped\n     * inside the Editor object) is assigned to a non-default value.\n     * This method will create the Editor if needed.\n     *\n     * A standard TextView (as well as buttons, checkboxes...) should not qualify and hence will\n     * have a null Editor, unlike an EditText. Inconsistent in-between states will have an\n     * Editor for backward compatibility, as soon as one of these fields is assigned.\n     *\n     * Also note that for performance reasons, the mEditor is created when needed, but not\n     * reset when no more edit-specific fields are needed.\n     ",
    "links" : [ ]
  }, {
    "name" : "public CharSequence getIterableTextForAccessibility()",
    "returnType" : "CharSequence",
    "comment" : "\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "private void ensureIterableTextForAccessibilitySelectable()",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public TextSegmentIterator getIteratorForGranularity(int granularity)",
    "returnType" : "TextSegmentIterator",
    "comment" : "\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public int getAccessibilitySelectionStart()",
    "returnType" : "int",
    "comment" : "\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean isAccessibilitySelectionExtendable()",
    "returnType" : "boolean",
    "comment" : "\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public void prepareForExtendedAccessibilitySelection()",
    "returnType" : "void",
    "comment" : "\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public int getAccessibilitySelectionEnd()",
    "returnType" : "int",
    "comment" : "\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public void setAccessibilitySelection(int start, int end)",
    "returnType" : "void",
    "comment" : "\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "protected void encodeProperties(@NonNull ViewHierarchyEncoder stream)",
    "returnType" : "void",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "public void onInputConnectionOpenedInternal(@NonNull InputConnection ic, @NonNull EditorInfo editorInfo, @Nullable Handler handler)",
    "returnType" : "void",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "public void onInputConnectionClosedInternal()",
    "returnType" : "void",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "public ContentInfo onReceiveContent(@NonNull ContentInfo payload)",
    "returnType" : "ContentInfo",
    "comment" : "\n     * Default {@link TextView} implementation for receiving content. Apps wishing to provide\n     * custom behavior should configure a listener via {@link #setOnReceiveContentListener}.\n     *\n     * <p>For non-editable TextViews the default behavior is a no-op (returns the passed-in\n     * content without acting on it).\n     *\n     * <p>For editable TextViews the default behavior is to insert text into the view, coercing\n     * non-text content to text as needed. The MIME types \"text/plain\" and \"text/html\" have\n     * well-defined behavior for this, while other MIME types have reasonable fallback behavior\n     * (see {@link ClipData.Item#coerceToStyledText}).\n     *\n     * @param payload The content to insert and related metadata.\n     *\n     * @return The portion of the passed-in content that was not handled (may be all, some, or none\n     * of the passed-in content).\n     ",
    "links" : [ "ClipData.Item#coerceToStyledText", "android.widget.TextView", "#setOnReceiveContentListener" ]
  }, {
    "name" : "private static void logCursor(String location, @Nullable String msgFormat, Object... msgArgs)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public void onCreateViewTranslationRequest(@NonNull int[] supportedFormats, @NonNull Consumer<ViewTranslationRequest> requestsCollector)",
    "returnType" : "void",
    "comment" : "\n     * Collects a {@link ViewTranslationRequest} which represents the content to be translated in\n     * the view.\n     *\n     * <p>NOTE: When overriding the method, it should not collect a request to translate this\n     * TextView if it is displaying a password.\n     *\n     * @param supportedFormats the supported translation format. The value could be {@link\n     *                         android.view.translation.TranslationSpec#DATA_FORMAT_TEXT}.\n     * @param requestsCollector {@link Consumer} to receiver the {@link ViewTranslationRequest}\n     *                                         which contains the information to be translated.\n     ",
    "links" : [ "java.util.function.Consumer", "android.view.translation.TranslationSpec#DATA_FORMAT_TEXT", "android.view.translation.ViewTranslationRequest" ]
  } ],
  "methodNames" : [ "public static void preloadFontCache()", "private void setTextInternal(@Nullable CharSequence text)", "public void setAutoSizeTextTypeWithDefaults(@AutoSizeTextType int autoSizeTextType)", "public void setAutoSizeTextTypeUniformWithConfiguration(int autoSizeMinTextSize, int autoSizeMaxTextSize, int autoSizeStepGranularity, int unit)", "public void setAutoSizeTextTypeUniformWithPresetSizes(@NonNull int[] presetSizes, int unit)", "public int getAutoSizeTextType()", "public int getAutoSizeStepGranularity()", "public int getAutoSizeMinTextSize()", "public int getAutoSizeMaxTextSize()", "public int[] getAutoSizeTextAvailableSizes()", "private void setupAutoSizeUniformPresetSizes(TypedArray textSizes)", "private boolean setupAutoSizeUniformPresetSizesConfiguration()", "private void validateAndSetAutoSizeTextTypeUniformConfiguration(float autoSizeMinTextSizeInPx, float autoSizeMaxTextSizeInPx, float autoSizeStepGranularityInPx)", "private void clearAutoSizeConfiguration()", "private int[] cleanupAutoSizePresetSizes(int[] presetValues)", "private boolean setupAutoSizeText()", "private int[] parseDimensionArray(TypedArray dimens)", "public void onActivityResult(int requestCode, int resultCode, @Nullable Intent data)", "private void setTypefaceFromAttrs(@Nullable Typeface typeface, @Nullable String familyName, @XMLTypefaceAttr int typefaceIndex, @Typeface.Style int style, @IntRange(from = FontStyle.FONT_WEIGHT_UNSPECIFIED, to = FontStyle.FONT_WEIGHT_MAX) int weight)", "private void resolveStyleAndSetTypeface(@NonNull Typeface typeface, @Typeface.Style int style, @IntRange(from = FontStyle.FONT_WEIGHT_UNSPECIFIED, to = FontStyle.FONT_WEIGHT_MAX) int weight)", "private void setRelativeDrawablesIfNeeded(Drawable start, Drawable end)", "public void setEnabled(boolean enabled)", "public void setTypeface(@Nullable Typeface tf, @Typeface.Style int style)", "protected boolean getDefaultEditable()", "protected MovementMethod getDefaultMovementMethod()", "public CharSequence getText()", "public int length()", "public Editable getEditableText()", "public CharSequence getTransformed()", "public int getLineHeight()", "public final Layout getLayout()", " final Layout getHintLayout()", "public final UndoManager getUndoManager()", "public final Editor getEditorForTesting()", "public final void setUndoManager(UndoManager undoManager, String tag)", "public final KeyListener getKeyListener()", "public void setKeyListener(KeyListener input)", "private void setInputTypeFromEditor()", "private void setKeyListenerOnly(KeyListener input)", "public final MovementMethod getMovementMethod()", "public final void setMovementMethod(MovementMethod movement)", "private void fixFocusableAndClickableSettings()", "public final TransformationMethod getTransformationMethod()", "public final void setTransformationMethod(TransformationMethod method)", " void setTransformationMethodInternal(@Nullable TransformationMethod method, boolean updateText)", "public int getCompoundPaddingTop()", "public int getCompoundPaddingBottom()", "public int getCompoundPaddingLeft()", "public int getCompoundPaddingRight()", "public int getCompoundPaddingStart()", "public int getCompoundPaddingEnd()", "public int getExtendedPaddingTop()", "public int getExtendedPaddingBottom()", "public int getTotalPaddingLeft()", "public int getTotalPaddingRight()", "public int getTotalPaddingStart()", "public int getTotalPaddingEnd()", "public int getTotalPaddingTop()", "public int getTotalPaddingBottom()", "public void setCompoundDrawables(@Nullable Drawable left, @Nullable Drawable top, @Nullable Drawable right, @Nullable Drawable bottom)", "public void setCompoundDrawablesWithIntrinsicBounds(@DrawableRes int left, @DrawableRes int top, @DrawableRes int right, @DrawableRes int bottom)", "public void setCompoundDrawablesWithIntrinsicBounds(@Nullable Drawable left, @Nullable Drawable top, @Nullable Drawable right, @Nullable Drawable bottom)", "public void setCompoundDrawablesRelative(@Nullable Drawable start, @Nullable Drawable top, @Nullable Drawable end, @Nullable Drawable bottom)", "public void setCompoundDrawablesRelativeWithIntrinsicBounds(@DrawableRes int start, @DrawableRes int top, @DrawableRes int end, @DrawableRes int bottom)", "public void setCompoundDrawablesRelativeWithIntrinsicBounds(@Nullable Drawable start, @Nullable Drawable top, @Nullable Drawable end, @Nullable Drawable bottom)", "public Drawable[] getCompoundDrawables()", "public Drawable[] getCompoundDrawablesRelative()", "public void setCompoundDrawablePadding(int pad)", "public int getCompoundDrawablePadding()", "public void setCompoundDrawableTintList(@Nullable ColorStateList tint)", "public ColorStateList getCompoundDrawableTintList()", "public void setCompoundDrawableTintMode(@Nullable PorterDuff.Mode tintMode)", "public void setCompoundDrawableTintBlendMode(@Nullable BlendMode blendMode)", "public PorterDuff.Mode getCompoundDrawableTintMode()", "public BlendMode getCompoundDrawableTintBlendMode()", "private void applyCompoundDrawableTint()", "public void setPadding(int left, int top, int right, int bottom)", "public void setPaddingRelative(int start, int top, int end, int bottom)", "public void setFirstBaselineToTopHeight(@Px @IntRange(from = 0) int firstBaselineToTopHeight)", "public void setLastBaselineToBottomHeight(@Px @IntRange(from = 0) int lastBaselineToBottomHeight)", "public int getFirstBaselineToTopHeight()", "public int getLastBaselineToBottomHeight()", "public final int getAutoLinkMask()", "public void setTextSelectHandle(@NonNull Drawable textSelectHandle)", "public void setTextSelectHandle(@DrawableRes int textSelectHandle)", "public Drawable getTextSelectHandle()", "public void setTextSelectHandleLeft(@NonNull Drawable textSelectHandleLeft)", "public void setTextSelectHandleLeft(@DrawableRes int textSelectHandleLeft)", "public Drawable getTextSelectHandleLeft()", "public void setTextSelectHandleRight(@NonNull Drawable textSelectHandleRight)", "public void setTextSelectHandleRight(@DrawableRes int textSelectHandleRight)", "public Drawable getTextSelectHandleRight()", "public void setTextCursorDrawable(@Nullable Drawable textCursorDrawable)", "public void setTextCursorDrawable(@DrawableRes int textCursorDrawable)", "public Drawable getTextCursorDrawable()", "public void setTextAppearance(@StyleRes int resId)", "public void setTextAppearance(Context context, @StyleRes int resId)", "private void readTextAppearance(Context context, TypedArray appearance, TextAppearanceAttributes attributes, boolean styleArray)", "private void applyTextAppearance(TextAppearanceAttributes attributes)", "private void updateLineBreakConfigFromTextAppearance(boolean isLineBreakStyleSpecified, boolean isLineBreakWordStyleSpecified, @LineBreakConfig.LineBreakStyle int lineBreakStyle, @LineBreakConfig.LineBreakWordStyle int lineBreakWordStyle)", "public Locale getTextLocale()", "public LocaleList getTextLocales()", "private void changeListenerLocaleTo(@Nullable Locale locale)", "public void setTextLocale(@NonNull Locale locale)", "public void setTextLocales(@NonNull @Size(min = 1) LocaleList locales)", "protected void onConfigurationChanged(Configuration newConfig)", "public float getTextSize()", "public float getScaledTextSize()", "public int getTypefaceStyle()", "public void setTextSize(float size)", "public void setTextSize(int unit, float size)", "private DisplayMetrics getDisplayMetricsOrSystem()", "private void setTextSizeInternal(int unit, float size, boolean shouldRequestLayout)", "private void setRawTextSize(float size, boolean shouldRequestLayout)", "public int getTextSizeUnit()", "public float getTextScaleX()", "public void setTextScaleX(float size)", "public void setTypeface(@Nullable Typeface tf)", "public Typeface getTypeface()", "public void setElegantTextHeight(boolean elegant)", "public void setFallbackLineSpacing(boolean enabled)", "public void setUseBoundsForWidth(boolean useBoundsForWidth)", "public boolean getUseBoundsForWidth()", "public void setShiftDrawingOffsetForStartOverhang(boolean shiftDrawingOffsetForStartOverhang)", "public boolean getShiftDrawingOffsetForStartOverhang()", "public void setMinimumFontMetrics(@Nullable Paint.FontMetrics minimumFontMetrics)", "public Paint.FontMetrics getMinimumFontMetrics()", "public boolean isLocalePreferredLineHeightForMinimumUsed()", "public void setLocalePreferredLineHeightForMinimumUsed(boolean flag)", "public boolean isFallbackLineSpacing()", "private boolean isFallbackLineSpacingForBoringLayout()", " boolean isFallbackLineSpacingForStaticLayout()", "public boolean isElegantTextHeight()", "public float getLetterSpacing()", "public void setLetterSpacing(float letterSpacing)", "public String getFontFeatureSettings()", "public String getFontVariationSettings()", "public void setBreakStrategy(@Layout.BreakStrategy int breakStrategy)", "public int getBreakStrategy()", "public void setHyphenationFrequency(@Layout.HyphenationFrequency int hyphenationFrequency)", "public int getHyphenationFrequency()", "public void setLineBreakStyle(@LineBreakConfig.LineBreakStyle int lineBreakStyle)", "public void setLineBreakWordStyle(@LineBreakConfig.LineBreakWordStyle int lineBreakWordStyle)", "public int getLineBreakStyle()", "public int getLineBreakWordStyle()", "public PrecomputedText.Params getTextMetricsParams()", "public void setTextMetricsParams(@NonNull PrecomputedText.Params params)", "public void setJustificationMode(@Layout.JustificationMode int justificationMode)", "public int getJustificationMode()", "public void setFontFeatureSettings(@Nullable String fontFeatureSettings)", "public boolean setFontVariationSettings(@Nullable String fontVariationSettings)", "public void setTextColor(@ColorInt int color)", "public void setTextColor(ColorStateList colors)", "public final ColorStateList getTextColors()", "public final int getCurrentTextColor()", "public void setHighlightColor(@ColorInt int color)", "public int getHighlightColor()", "public final void setShowSoftInputOnFocus(boolean show)", "public final boolean getShowSoftInputOnFocus()", "public void setShadowLayer(float radius, float dx, float dy, int color)", "public float getShadowRadius()", "public float getShadowDx()", "public float getShadowDy()", "public int getShadowColor()", "public TextPaint getPaint()", "public final void setAutoLinkMask(int mask)", "public final void setLinksClickable(boolean whether)", "public final boolean getLinksClickable()", "public URLSpan[] getUrls()", "public final void setHintTextColor(@ColorInt int color)", "public final void setHintTextColor(ColorStateList colors)", "public final ColorStateList getHintTextColors()", "public final int getCurrentHintTextColor()", "public final void setLinkTextColor(@ColorInt int color)", "public final void setLinkTextColor(ColorStateList colors)", "public final ColorStateList getLinkTextColors()", "public void setGravity(int gravity)", "public int getGravity()", "public int getPaintFlags()", "public void setPaintFlags(int flags)", "public void setHorizontallyScrolling(boolean whether)", "public final boolean isHorizontallyScrollable()", "public boolean getHorizontallyScrolling()", "public void setMinLines(int minLines)", "public int getMinLines()", "public void setMinHeight(int minPixels)", "public int getMinHeight()", "public void setMaxLines(int maxLines)", "public int getMaxLines()", "public void setMaxHeight(int maxPixels)", "public int getMaxHeight()", "public void setLines(int lines)", "public void setHeight(int pixels)", "public void setMinEms(int minEms)", "public int getMinEms()", "public void setMinWidth(int minPixels)", "public int getMinWidth()", "public void setMaxEms(int maxEms)", "public int getMaxEms()", "public void setMaxWidth(int maxPixels)", "public int getMaxWidth()", "public void setEms(int ems)", "public void setWidth(int pixels)", "public void setLineSpacing(float add, float mult)", "public float getLineSpacingMultiplier()", "public float getLineSpacingExtra()", "public void setLineHeight(@Px @IntRange(from = 0) int lineHeight)", "private void setLineHeightPx(@Px @FloatRange(from = 0) float lineHeight)", "public void setLineHeight(@TypedValue.ComplexDimensionUnit int unit, @FloatRange(from = 0) float lineHeight)", "private void maybeRecalculateLineHeight()", "public void setHighlights(@Nullable Highlights highlights)", "public Highlights getHighlights()", "public void setSearchResultHighlights(@Nullable int... ranges)", "public int[] getSearchResultHighlights()", "public void setFocusedSearchResultIndex(int index)", "public int getFocusedSearchResultIndex()", "public void setSearchResultHighlightColor(@ColorInt int color)", "public int getSearchResultHighlightColor()", "public void setFocusedSearchResultHighlightColor(@ColorInt int color)", "public int getFocusedSearchResultHighlightColor()", "private void setSelectGesturePreviewHighlight(int start, int end)", "private void setDeleteGesturePreviewHighlight(int start, int end)", "private void setGesturePreviewHighlight(int start, int end, int color)", "private void clearGesturePreviewHighlight()", " boolean hasGesturePreviewHighlight()", "public final void append(CharSequence text)", "public void append(CharSequence text, int start, int end)", "private void updateTextColors()", "protected void drawableStateChanged()", "public void drawableHotspotChanged(float x, float y)", "public Parcelable onSaveInstanceState()", " void removeMisspelledSpans(Spannable spannable)", "public void onRestoreInstanceState(Parcelable state)", "public void setFreezesText(boolean freezesText)", "public boolean getFreezesText()", "public final void setEditableFactory(Editable.Factory factory)", "public final void setSpannableFactory(Spannable.Factory factory)", "public final void setText(CharSequence text)", "public Runnable setTextAsync(@Nullable CharSequence text)", "public final void setTextKeepState(CharSequence text)", "public void setText(CharSequence text, BufferType type)", "private void setText(CharSequence text, BufferType type, boolean notifyBefore, int oldlen)", "public final void setText(@NonNull char[] text, int start, int len)", "public final void setTextKeepState(CharSequence text, BufferType type)", "public final void setText(@StringRes int resid)", "public final void setText(@StringRes int resid, BufferType type)", "public final void setHint(CharSequence hint)", "private void setHintInternal(CharSequence hint)", "public final void setHint(@StringRes int resid)", "public CharSequence getHint()", "public void hideHint()", "public boolean isSingleLine()", "private static boolean isMultilineInputType(int type)", " CharSequence removeSuggestionSpans(CharSequence text)", "public void setInputType(int type)", " boolean hasPasswordTransformationMethod()", "public boolean isAnyPasswordInputType()", " static boolean isPasswordInputType(int inputType)", "private static boolean isVisiblePasswordInputType(int inputType)", "public void setRawInputType(int type)", "public String[] getAutofillHints()", "private Locale getCustomLocaleForKeyListenerOrNull()", "private void setInputType(int type, boolean direct)", "public int getInputType()", "public void setImeOptions(int imeOptions)", "public int getImeOptions()", "public void setImeActionLabel(CharSequence label, int actionId)", "public CharSequence getImeActionLabel()", "public int getImeActionId()", "public void setOnEditorActionListener(OnEditorActionListener l)", "public void onEditorAction(int actionCode)", "public void setPrivateImeOptions(String type)", "public String getPrivateImeOptions()", "public void setInputExtras(@XmlRes int xmlResId) throws XmlPullParserException, IOException", "public Bundle getInputExtras(boolean create)", "public void setImeHintLocales(@Nullable LocaleList hintLocales)", "public LocaleList getImeHintLocales()", "public CharSequence getError()", "public void setError(CharSequence error)", "public void setError(CharSequence error, Drawable icon)", "protected boolean setFrame(int l, int t, int r, int b)", "private void restartMarqueeIfNeeded()", "public void setFilters(InputFilter[] filters)", "private void setFilters(Editable e, InputFilter[] filters)", "public InputFilter[] getFilters()", "private int getBoxHeight(Layout l)", " int getVerticalOffset(boolean forceNormal)", "private int getBottomVerticalOffset(boolean forceNormal)", " void invalidateCursorPath()", " void invalidateCursor()", "private void invalidateCursor(int a, int b, int c)", " void invalidateRegion(int start, int end, boolean invalidateCursor)", "private void registerForPreDraw()", "private void unregisterForPreDraw()", "public boolean onPreDraw()", "protected void onAttachedToWindow()", "protected void onDetachedFromWindowInternal()", "public void onScreenStateChanged(int screenState)", "protected boolean isPaddingOffsetRequired()", "protected int getLeftPaddingOffset()", "protected int getTopPaddingOffset()", "protected int getBottomPaddingOffset()", "protected int getRightPaddingOffset()", "protected boolean verifyDrawable(@NonNull Drawable who)", "public void jumpDrawablesToCurrentState()", "public void invalidateDrawable(@NonNull Drawable drawable)", "public boolean hasOverlappingRendering()", "public boolean isTextSelectable()", "public void setTextIsSelectable(boolean selectable)", "protected int[] onCreateDrawableState(int extraSpace)", "private void maybeUpdateHighlightPaths()", "private void addSearchHighlightPaths()", "private Path getUpdatedHighlightPath()", "public int getHorizontalOffsetForDrawables()", "protected void onDraw(Canvas canvas)", "public void getFocusedRect(Rect r)", "public int getLineCount()", "public int getLineBounds(int line, Rect bounds)", "public int getBaseline()", " int getBaselineOffset()", "protected int getFadeTop(boolean offsetRequired)", "protected int getFadeHeight(boolean offsetRequired)", "public PointerIcon onResolvePointerIcon(MotionEvent event, int pointerIndex)", "public boolean onKeyPreIme(int keyCode, KeyEvent event)", "public boolean handleBackInTextActionModeIfNeeded(KeyEvent event)", "public boolean onKeyDown(int keyCode, KeyEvent event)", "public boolean onKeyMultiple(int keyCode, int repeatCount, KeyEvent event)", "private boolean shouldAdvanceFocusOnEnter()", "private boolean isDirectionalNavigationKey(int keyCode)", "private int doKeyDown(int keyCode, KeyEvent event, KeyEvent otherEvent)", "public void resetErrorChangedFlag()", "public void hideErrorIfUnchanged()", "public boolean onKeyUp(int keyCode, KeyEvent event)", "private int getActionIdForEnterEvent()", "public boolean onCheckIsTextEditor()", "private boolean hasEditorInFocusSearchDirection(@FocusRealDirection int direction)", "public InputConnection onCreateInputConnection(EditorInfo outAttrs)", "public void onRequestCursorUpdatesInternal(@InputConnection.CursorUpdateMode int cursorUpdateMode, @InputConnection.CursorUpdateFilter int cursorUpdateFilter)", "public boolean extractText(ExtractedTextRequest request, ExtractedText outText)", " static void removeParcelableSpans(Spannable spannable, int start, int end)", "public void setExtractedText(ExtractedText text)", "public void setExtracting(ExtractedTextRequest req)", "public void onCommitCompletion(CompletionInfo text)", "public void onCommitCorrection(CorrectionInfo info)", "public void beginBatchEdit()", "public void endBatchEdit()", "public void onBeginBatchEdit()", "public void onEndBatchEdit()", "public void onPerformSpellCheck()", "public boolean onPrivateIMECommand(String action, Bundle data)", "public boolean isOffsetMappingAvailable()", "public boolean previewHandwritingGesture(@NonNull PreviewableHandwritingGesture gesture, @Nullable CancellationSignal cancellationSignal)", "public int performHandwritingSelectGesture(@NonNull SelectGesture gesture)", "private int performHandwritingSelectGesture(@NonNull SelectGesture gesture, boolean isPreview)", "private int performHandwritingSelectGesture(int[] range, boolean isPreview)", "public int performHandwritingSelectRangeGesture(@NonNull SelectRangeGesture gesture)", "private int performHandwritingSelectRangeGesture(@NonNull SelectRangeGesture gesture, boolean isPreview)", "public int performHandwritingDeleteGesture(@NonNull DeleteGesture gesture)", "private int performHandwritingDeleteGesture(@NonNull DeleteGesture gesture, boolean isPreview)", "private int performHandwritingDeleteGesture(int[] range, int granularity, boolean isPreview)", "public int performHandwritingDeleteRangeGesture(@NonNull DeleteRangeGesture gesture)", "private int performHandwritingDeleteRangeGesture(@NonNull DeleteRangeGesture gesture, boolean isPreview)", "private int[] adjustHandwritingDeleteGestureRange(int[] range)", "public int performHandwritingInsertGesture(@NonNull InsertGesture gesture)", "public int performHandwritingRemoveSpaceGesture(@NonNull RemoveSpaceGesture gesture)", "public int performHandwritingJoinOrSplitGesture(@NonNull JoinOrSplitGesture gesture)", "public int performHandwritingInsertModeGesture(@NonNull InsertModeGesture gesture)", "private int handleGestureFailure(HandwritingGesture gesture)", "private int handleGestureFailure(HandwritingGesture gesture, boolean isPreview)", "private int getLineForHandwritingGesture(PointF point)", "private int[] getRangeForRect(@NonNull RectF area, int granularity)", "private int tryInsertTextForHandwritingGesture(int offset, String textToInsert, HandwritingGesture gesture)", "private Pattern getWhitespacePattern()", "public void nullLayouts()", "private void assumeLayout()", "private Layout.Alignment getLayoutAlignment()", "private Paint.FontMetrics getResolvedMinimumFontMetrics()", "public void makeNewLayout(int wantWidth, int hintWidth, BoringLayout.Metrics boring, BoringLayout.Metrics hintBoring, int ellipsisWidth, boolean bringIntoView)", "public boolean useDynamicLayout()", "protected Layout makeSingleLayout(int wantWidth, BoringLayout.Metrics boring, int ellipsisWidth, Layout.Alignment alignment, boolean shouldEllipsize, TruncateAt effectiveEllipsize, boolean useSaved)", "private boolean compressText(float width)", "private static int desired(Layout layout, boolean useBoundsForWidth)", "public void setIncludeFontPadding(boolean includepad)", "public boolean getIncludeFontPadding()", "protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec)", "private void autoSizeText()", "private int findLargestTextSizeWhichFits(RectF availableSpace)", "private boolean suggestedSizeFitsInSpace(int suggestedSizeInPx, RectF availableSpace)", "private int getDesiredHeight()", "private int getDesiredHeight(Layout layout, boolean cap)", "private void checkForResize()", "private void checkForRelayout()", "protected void onLayout(boolean changed, int left, int top, int right, int bottom)", "private boolean isShowingHint()", "private boolean bringTextIntoView()", "public boolean bringPointIntoView(int offset)", "public boolean bringPointIntoView(@IntRange(from = 0) int offset, boolean requestRectWithoutFocus)", "public boolean moveCursorToVisibleOffset()", "public void computeScroll()", "private void getInterestingRect(Rect r, int line)", "private void convertFromViewportToContentCoordinates(Rect r)", "private PointF convertFromScreenToContentCoordinates(PointF point)", "private RectF convertFromScreenToContentCoordinates(RectF rect)", " int viewportToContentHorizontalOffset()", " int viewportToContentVerticalOffset()", "public void debug(int depth)", "public int getSelectionStart()", "public int getSelectionEnd()", "public void getSelection(int start, int end, final Layout.SelectionRectangleConsumer consumer)", " int getSelectionStartTransformed()", " int getSelectionEndTransformed()", "public boolean hasSelection()", " String getSelectedText()", "public void setSingleLine()", "public void setAllCaps(boolean allCaps)", "public boolean isAllCaps()", "public void setSingleLine(boolean singleLine)", "private void setInputTypeSingleLine(boolean singleLine)", "private void applySingleLine(boolean singleLine, boolean applyTransformation, boolean changeMaxLines, boolean changeMaxLength)", "public void setEllipsize(TextUtils.TruncateAt where)", "public void setMarqueeRepeatLimit(int marqueeLimit)", "public int getMarqueeRepeatLimit()", "public TextUtils.TruncateAt getEllipsize()", "public void setSelectAllOnFocus(boolean selectAllOnFocus)", "public void setCursorVisible(boolean visible)", "public void setImeConsumesInput(boolean imeConsumesInput)", "private void updateCursorVisibleInternal()", "public boolean isCursorVisible()", "public boolean isCursorVisibleFromAttr()", "private boolean canMarquee()", "protected void startMarquee()", "protected void stopMarquee()", "private void startStopMarquee(boolean start)", "protected void onTextChanged(CharSequence text, int start, int lengthBefore, int lengthAfter)", "protected void onSelectionChanged(int selStart, int selEnd)", "public void addTextChangedListener(TextWatcher watcher)", "public void removeTextChangedListener(TextWatcher watcher)", "private void sendBeforeTextChanged(CharSequence text, int start, int before, int after)", "private void removeIntersectingNonAdjacentSpans(int start, int end, Class<T> type)", " void removeAdjacentSuggestionSpans(final int pos)", " void sendOnTextChanged(CharSequence text, int start, int before, int after)", " void sendAfterTextChanged(Editable text)", "private void notifyListeningManagersAfterTextChanged()", "public void notifyContentCaptureTextChanged()", "private boolean isAutofillable()", " void updateAfterEdit()", " void handleTextChanged(CharSequence buffer, int start, int before, int after)", " void spanChange(Spanned buf, Object what, int oldStart, int newStart, int oldEnd, int newEnd)", "protected void onFocusChanged(boolean focused, int direction, Rect previouslyFocusedRect)", "public void onWindowFocusChanged(boolean hasWindowFocus)", "protected void onVisibilityChanged(View changedView, int visibility)", "public void onVisibilityAggregated(boolean isVisible)", "public void clearComposingText()", "public void setSelected(boolean selected)", " boolean isFromPrimePointer(MotionEvent event, boolean fromHandleView)", "public boolean onTouchEvent(MotionEvent event)", "private boolean shouldStartHandwritingForEndOfLineTap(MotionEvent actionUpEvent)", "public final boolean showUIForTouchScreen()", "private boolean showAutofillDialog()", "public boolean onGenericMotionEvent(MotionEvent event)", "protected void onCreateContextMenu(ContextMenu menu)", "public boolean showContextMenu()", "public boolean showContextMenu(float x, float y)", " boolean isTextEditable()", " boolean isTextAutofillable()", "public boolean didTouchFocusSelect()", "public void cancelLongPress()", "public boolean onTrackballEvent(MotionEvent event)", "public void setScroller(Scroller s)", "protected float getLeftFadingEdgeStrength()", "protected float getRightFadingEdgeStrength()", "private float getHorizontalFadingEdgeStrength(float position1, float position2)", "private boolean isMarqueeFadeEnabled()", "protected int computeHorizontalScrollRange()", "protected int computeVerticalScrollRange()", "protected int computeVerticalScrollExtent()", "public void findViewsWithText(ArrayList<View> outViews, CharSequence searched, int flags)", "public static ColorStateList getTextColors(Context context, TypedArray attrs)", "public static int getTextColor(Context context, TypedArray attrs, int def)", "public boolean onKeyShortcut(int keyCode, KeyEvent event)", " boolean canSelectText()", " boolean textCanBeSelected()", "private Locale getTextServicesLocale(boolean allowNullLocale)", "public final void setTextOperationUser(@Nullable UserHandle user)", "public boolean isAutoHandwritingEnabled()", "public boolean shouldTrackHandwritingArea()", "public boolean isStylusHandwritingAvailable()", " final TextServicesManager getTextServicesManagerForUser()", " final ClipboardManager getClipboardManagerForUser()", " final TextClassificationManager getTextClassificationManagerForUser()", " final T getServiceManagerForUser(String packageName, Class<T> managerClazz)", " void startActivityAsTextOperationUserIfNecessary(@NonNull Intent intent)", "public Locale getTextServicesLocale()", "public boolean isInExtractedMode()", "private boolean isAutoSizeEnabled()", "protected boolean supportsAutoSizeText()", "public Locale getSpellCheckerLocale()", "private void updateTextServicesLocaleAsync()", "private void updateTextServicesLocaleLocked()", " void onLocaleChanged()", "public WordIterator getWordIterator()", "public void onPopulateAccessibilityEventInternal(AccessibilityEvent event)", "public CharSequence getAccessibilityClassName()", "protected void onProvideStructure(@NonNull ViewStructure structure, @ViewStructureType int viewFor, int flags)", " boolean canRequestAutofill()", "private void requestAutofill()", "public void autofill(AutofillValue value)", "public int getAutofillType()", "public AutofillValue getAutofillValue()", "public void onInitializeAccessibilityEventInternal(AccessibilityEvent event)", "public void onInitializeAccessibilityNodeInfoInternal(AccessibilityNodeInfo info)", "public void addExtraDataToAccessibilityNodeInfo(AccessibilityNodeInfo info, String extraDataKey, Bundle arguments)", "private boolean getViewVisibleRect(Rect rect)", "private boolean getContentVisibleRect(Rect rect)", "public void populateCharacterBounds(CursorAnchorInfo.Builder builder, int startIndex, int endIndex, float viewportToContentHorizontalOffset, float viewportToContentVerticalOffset)", "private float[] getCharacterBounds(int start, int end, float layoutLeft, float layoutTop)", "public CursorAnchorInfo getCursorAnchorInfo(@InputConnection.CursorUpdateFilter int filter, @NonNull CursorAnchorInfo.Builder cursorAnchorInfoBuilder, @NonNull Matrix viewToScreenMatrix)", "public TextBoundsInfo getTextBoundsInfo(@NonNull RectF bounds)", "public boolean isPositionVisible(final float positionX, final float positionY)", "public boolean performAccessibilityActionInternal(int action, Bundle arguments)", "private boolean performAccessibilityActionClick(Bundle arguments)", "private void requestFocusOnNonEditableSelectableText()", "private boolean hasSpannableText()", "public void sendAccessibilityEventInternal(int eventType)", "public void sendAccessibilityEventUnchecked(AccessibilityEvent event)", "private CharSequence getTextForAccessibility()", " boolean isVisibleToAccessibility()", " void sendAccessibilityEventTypeViewTextChanged(CharSequence beforeText, int fromIndex, int removedCount, int addedCount)", " void sendAccessibilityEventTypeViewTextChanged(CharSequence beforeText, int fromIndex, int toIndex)", "private InputMethodManager getInputMethodManager()", "public boolean isInputMethodTarget()", "public boolean onTextContextMenuItem(int id)", " CharSequence getTransformedText(int start, int end)", "public boolean performLongClick()", "protected void onScrollChanged(int horiz, int vert, int oldHoriz, int oldVert)", "public boolean isSuggestionsEnabled()", "public void setCustomSelectionActionModeCallback(ActionMode.Callback actionModeCallback)", "public ActionMode.Callback getCustomSelectionActionModeCallback()", "public void setCustomInsertionActionModeCallback(ActionMode.Callback actionModeCallback)", "public ActionMode.Callback getCustomInsertionActionModeCallback()", "public void setTextClassifier(@Nullable TextClassifier textClassifier)", "public TextClassifier getTextClassifier()", " TextClassifier getTextClassificationSession()", " TextClassificationContext getTextClassificationContext()", " boolean usesNoOpTextClassifier()", "public boolean requestActionMode(@NonNull TextLinks.TextLinkSpan clickedSpan)", "public boolean handleClick(@NonNull TextLinks.TextLinkSpan clickedSpan)", "protected void stopTextActionMode()", "public void hideFloatingToolbar(int durationMs)", " boolean canUndo()", " boolean canRedo()", " boolean canCut()", " boolean canCopy()", " boolean canReplace()", " boolean canShare()", " boolean isDeviceProvisioned()", " boolean canPaste()", " boolean canPasteAsPlainText()", " boolean canProcessText()", " boolean canSelectAllText()", " boolean selectAllText()", "private void paste(boolean withFormatting)", "private void shareSelectedText()", "private boolean setPrimaryClip(ClipData clip)", "public int getOffsetForPosition(float x, float y)", " float convertToLocalHorizontalCoordinate(float x)", "public int getLineAtCoordinate(float y)", " int getLineAtCoordinateUnclamped(float y)", " int getOffsetAtCoordinate(int line, float x)", "public int transformedToOriginal(int offset, @OffsetMapping.MapStrategy int strategy)", "public int originalToTransformed(int offset, @OffsetMapping.MapStrategy int strategy)", "public boolean onDragEvent(DragEvent event)", " boolean isInBatchEditMode()", "public void onRtlPropertiesChanged(int layoutDirection)", "public TextDirectionHeuristic getTextDirectionHeuristic()", "public void onResolveDrawables(int layoutDirection)", "private void prepareDrawableForDisplay(@Nullable Drawable dr)", "protected void resetResolvedDrawables()", "protected void viewClicked(InputMethodManager imm)", "protected void deleteText_internal(int start, int end)", "protected void replaceText_internal(int start, int end, CharSequence text)", "protected void setSpan_internal(Object span, int start, int end, int flags)", "protected void setCursorPosition_internal(int start, int end)", "private void createEditorIfNeeded()", "public CharSequence getIterableTextForAccessibility()", "private void ensureIterableTextForAccessibilitySelectable()", "public TextSegmentIterator getIteratorForGranularity(int granularity)", "public int getAccessibilitySelectionStart()", "public boolean isAccessibilitySelectionExtendable()", "public void prepareForExtendedAccessibilitySelection()", "public int getAccessibilitySelectionEnd()", "public void setAccessibilitySelection(int start, int end)", "protected void encodeProperties(@NonNull ViewHierarchyEncoder stream)", "public void onInputConnectionOpenedInternal(@NonNull InputConnection ic, @NonNull EditorInfo editorInfo, @Nullable Handler handler)", "public void onInputConnectionClosedInternal()", "public ContentInfo onReceiveContent(@NonNull ContentInfo payload)", "private static void logCursor(String location, @Nullable String msgFormat, Object... msgArgs)", "public void onCreateViewTranslationRequest(@NonNull int[] supportedFormats, @NonNull Consumer<ViewTranslationRequest> requestsCollector)" ],
  "variableNames" : [ "LOG_TAG", "DEBUG_EXTRACT", "DEBUG_CURSOR", "TEMP_POSITION", "DEFAULT_TYPEFACE", "SANS", "SERIF", "MONOSPACE", "ELLIPSIZE_NOT_SET", "ELLIPSIZE_NONE", "ELLIPSIZE_START", "ELLIPSIZE_MIDDLE", "ELLIPSIZE_END", "ELLIPSIZE_MARQUEE", "SIGNED", "DECIMAL", "MARQUEE_FADE_NORMAL", "MARQUEE_FADE_SWITCH_SHOW_ELLIPSIS", "MARQUEE_FADE_SWITCH_SHOW_FADE", "LINES", "EMS", "PIXELS", "MAX_LENGTH_FOR_SINGLE_LINE_EDIT_TEXT", "mSingleLineLengthFilter", "TEMP_RECTF", "VERY_WIDE", "ANIMATED_SCROLL_GAP", "NO_FILTERS", "EMPTY_SPANNED", "CHANGE_WATCHER_PRIORITY", "OFFSET_MAPPING_SPAN_PRIORITY", "MULTILINE_STATE_SET", "ACCESSIBILITY_ACTION_SHARE", "ACCESSIBILITY_ACTION_PROCESS_TEXT_START_ID", "ACCESSIBILITY_ACTION_SMART_START_ID", "PROCESS_TEXT_REQUEST_CODE", "KEY_EVENT_NOT_HANDLED", "KEY_EVENT_HANDLED", "KEY_DOWN_HANDLED_BY_KEY_LISTENER", "KEY_DOWN_HANDLED_BY_MOVEMENT_METHOD", "FLOATING_TOOLBAR_SELECT_ALL_REFRESH_DELAY", "DEFAULT_LINE_BREAK_STYLE", "DEFAULT_LINE_BREAK_WORD_STYLE", "BORINGLAYOUT_FALLBACK_LINESPACING", "STATICLAYOUT_FALLBACK_LINESPACING", "USE_BOUNDS_FOR_WIDTH", "sLastCutCopyOrTextChangedTime", "mTextColor", "mHintTextColor", "mLinkTextColor", "mCurTextColor", "mCurHintTextColor", "mFreezesText", "mEditableFactory", "mSpannableFactory", "mShadowRadius", "mShadowDx", "mShadowDy", "mShadowColor", "mLastOrientation", "mPreDrawRegistered", "mPreDrawListenerDetached", "mTextClassifier", "mTextClassificationSession", "mTextClassificationContext", "mPreventDefaultMovement", "mEllipsize", "mImeIsConsumingInput", "mCursorVisibleFromAttr", "mDrawables", "mCharWrapper", "mMarquee", "mRestartMarquee", "mMarqueeRepeatLimit", "mLastLayoutDirection", "mMarqueeFadeMode", "mSavedMarqueeModeLayout", "mText", "mSpannable", "mPrecomputed", "mTransformed", "mBufferType", "mHint", "mHintLayout", "mHideHint", "mMovement", "mTransformation", "mAllowTransformationLengthChange", "mChangeWatcher", "mListeners", "mTextPaint", "mUserSetTextScaleX", "mLayout", "mLocalesChanged", "mTextSizeUnit", "mLineBreakStyle", "mLineBreakWordStyle", "mFontWeightAdjustment", "mOriginalTypeface", "mListenerChanged", "mUseInternationalizedInput", "FALLBACK_LINE_SPACING_NONE", "FALLBACK_LINE_SPACING_STATIC_LAYOUT_ONLY", "FALLBACK_LINE_SPACING_ALL", "mUseFallbackLineSpacing", "mUseTextPaddingForUiTranslation", "mUseBoundsForWidth", "mShiftDrawingOffsetForStartOverhang", "mMinimumFontMetrics", "mLocalePreferredFontMetrics", "mUseLocalePreferredLineHeightForMinimum", "mGravity", "mHorizontallyScrolling", "mAutoLinkMask", "mLinksClickable", "mSpacingMult", "mSpacingAdd", "mLineHeightComplexDimen", "mBreakStrategy", "mHyphenationFrequency", "mJustificationMode", "mMaximum", "mMaxMode", "mMinimum", "mMinMode", "mOldMaximum", "mOldMaxMode", "mMaxWidth", "mMaxWidthMode", "mMinWidth", "mMinWidthMode", "mSingleLine", "mDesiredHeightAtMeasure", "mIncludePad", "mDeferScroll", "mTempRect", "mLastScroll", "mScroller", "mTempTextPaint", "mTempCursor", "mBoring", "mHintBoring", "mSavedLayout", "mSavedHintLayout", "mTextDir", "mFilters", "mTextOperationUser", "mCurrentSpellCheckerLocaleCache", "mHighlightColor", "mHighlightPath", "mHighlightPaint", "mHighlightPathBogus", "mHighlightPaths", "mHighlightPaints", "mHighlights", "mSearchResultHighlights", "mSearchResultHighlightPaint", "mFocusedSearchResultHighlightPaint", "mFocusedSearchResultHighlightColor", "mSearchResultHighlightColor", "mFocusedSearchResultIndex", "mGesturePreviewHighlightStart", "mGesturePreviewHighlightEnd", "mGesturePreviewHighlightPaint", "mPathRecyclePool", "mHighlightPathsBogus", "mCursorDrawableRes", "mCursorDrawable", "mTextSelectHandleLeftRes", "mTextSelectHandleLeft", "mTextSelectHandleRightRes", "mTextSelectHandleRight", "mTextSelectHandleRes", "mTextSelectHandle", "mTextEditSuggestionItemLayout", "mTextEditSuggestionContainerLayout", "mTextEditSuggestionHighlightStyle", "NO_POINTER_ID", "mPrimePointerId", "mIsPrimePointerFromHandleView", "mEditor", "DEVICE_PROVISIONED_UNKNOWN", "DEVICE_PROVISIONED_NO", "DEVICE_PROVISIONED_YES", "mDeviceProvisionedState", "mLastInputSource", "AUTO_SIZE_TEXT_TYPE_NONE", "AUTO_SIZE_TEXT_TYPE_UNIFORM", "DEFAULT_AUTO_SIZE_MIN_TEXT_SIZE_IN_SP", "DEFAULT_AUTO_SIZE_MAX_TEXT_SIZE_IN_SP", "DEFAULT_AUTO_SIZE_GRANULARITY_IN_PX", "UNSET_AUTO_SIZE_UNIFORM_CONFIGURATION_VALUE", "mAutoSizeTextType", "mNeedsAutoSizeText", "mAutoSizeStepGranularityInPx", "mAutoSizeMinTextSizeInPx", "mAutoSizeMaxTextSizeInPx", "mAutoSizeTextSizesInPx", "mHasPresetAutoSizeValues", "mTextSetFromXmlOrResourceId", "mTextId", "mHintId", "mWhitespacePattern", "sAppearanceValues", "FOCUSED_SEARCH_RESULT_INDEX_NONE", "UNKNOWN_BORING", "ID_SELECT_ALL", "ID_UNDO", "ID_REDO", "ID_CUT", "ID_COPY", "ID_PASTE", "ID_SHARE", "ID_PASTE_AS_PLAIN_TEXT", "ID_REPLACE", "ID_ASSIST", "ID_AUTOFILL" ]
}