{
  "filePath" : "/home/maryam/clearblue/files/android-source-35/java/nio/file/Path.java",
  "packageName" : "java.nio.file",
  "className" : "Path",
  "comment" : "",
  "links" : [ ],
  "variables" : [ ],
  "methods" : [ {
    "name" : "public static Path of(String first, String... more)",
    "returnType" : "Path",
    "comment" : "\n     * Returns a {@code Path} by converting a path string, or a sequence of\n     * strings that when joined form a path string. If {@code more} does not\n     * specify any elements then the value of the {@code first} parameter is\n     * the path string to convert. If {@code more} specifies one or more\n     * elements then each non-empty string, including {@code first}, is\n     * considered to be a sequence of name elements and is joined to form a\n     * path string. The details as to how the Strings are joined is provider\n     * specific but typically they will be joined using the\n     * {@link FileSystem#getSeparator name-separator} as the separator.\n     * For example, if the name separator is \"{@code /}\" and\n     * {@code getPath(\"/foo\",\"bar\",\"gus\")} is invoked, then the path string\n     * {@code \"/foo/bar/gus\"} is converted to a {@code Path}. A {@code Path}\n     * representing an empty path is returned if {@code first} is the empty\n     * string and {@code more} does not contain any non-empty strings.\n     *\n     * <p> The {@code Path} is obtained by invoking the {@link FileSystem#getPath\n     * getPath} method of the {@link FileSystems#getDefault default} {@link\n     * FileSystem}.\n     *\n     * <p> Note that while this method is very convenient, using it will imply\n     * an assumed reference to the default {@code FileSystem} and limit the\n     * utility of the calling code. Hence it should not be used in library code\n     * intended for flexible reuse. A more flexible alternative is to use an\n     * existing {@code Path} instance as an anchor, such as:\n     * <pre>{@code\n     *     Path dir = ...\n     *     Path path = dir.resolve(\"file\");\n     * }</pre>\n     *\n     * @param   first\n     *          the path string or initial part of the path string\n     * @param   more\n     *          additional strings to be joined to form the path string\n     *\n     * @return  the resulting {@code Path}\n     *\n     * @throws  InvalidPathException\n     *          if the path string cannot be converted to a {@code Path}\n     *\n     * @see FileSystem#getPath\n     *\n     * @since 11\n     ",
    "links" : [ "java.nio.file.FileSystems#getDefault", "java.nio.file.FileSystem#getPathgetPath", "java.nio.file.FileSystem#getSeparator", "java.nio.file.FileSystem" ]
  }, {
    "name" : "public static Path of(URI uri)",
    "returnType" : "Path",
    "comment" : "\n     * Returns a {@code Path} by converting a URI.\n     *\n     * <p> This method iterates over the {@link FileSystemProvider#installedProviders()\n     * installed} providers to locate the provider that is identified by the\n     * URI {@link URI#getScheme scheme} of the given URI. URI schemes are\n     * compared without regard to case. If the provider is found then its {@link\n     * FileSystemProvider#getPath getPath} method is invoked to convert the\n     * URI.\n     *\n     * <p> In the case of the default provider, identified by the URI scheme\n     * \"file\", the given URI has a non-empty path component, and undefined query\n     * and fragment components. Whether the authority component may be present\n     * is platform specific. The returned {@code Path} is associated with the\n     * {@link FileSystems#getDefault default} file system.\n     *\n     * <p> The default provider provides a similar <em>round-trip</em> guarantee\n     * to the {@link java.io.File} class. For a given {@code Path} <i>p</i> it\n     * is guaranteed that\n     * <blockquote>{@code\n     * Path.of(}<i>p</i>{@code .}{@link Path#toUri() toUri}{@code ()).equals(}\n     * <i>p</i>{@code .}{@link Path#toAbsolutePath() toAbsolutePath}{@code ())}\n     * </blockquote>\n     * so long as the original {@code Path}, the {@code URI}, and the new {@code\n     * Path} are all created in (possibly different invocations of) the same\n     * Java virtual machine. Whether other providers make any guarantees is\n     * provider specific and therefore unspecified.\n     *\n     * @param   uri\n     *          the URI to convert\n     *\n     * @return  the resulting {@code Path}\n     *\n     * @throws  IllegalArgumentException\n     *          if preconditions on the {@code uri} parameter do not hold. The\n     *          format of the URI is provider specific.\n     * @throws  FileSystemNotFoundException\n     *          The file system, identified by the URI, does not exist and\n     *          cannot be created automatically, or the provider identified by\n     *          the URI's scheme component is not installed\n     * @throws  SecurityException\n     *          if a security manager is installed and it denies an unspecified\n     *          permission to access the file system\n     *\n     * @since 11\n     ",
    "links" : [ "java.nio.file.FileSystems#getDefault", "java.nio.file.spi.FileSystemProvider#installedProviders()", "java.net.URI#getScheme", "java.nio.file.Path#toAbsolutePath()", "java.nio.file.spi.FileSystemProvider#getPath", "java.nio.file.Path#toUri()", "java.io.File" ]
  }, {
    "name" : " FileSystem getFileSystem()",
    "returnType" : "FileSystem",
    "comment" : "\n     * Returns the file system that created this object.\n     *\n     * @return  the file system that created this object\n     ",
    "links" : [ ]
  }, {
    "name" : " boolean isAbsolute()",
    "returnType" : "boolean",
    "comment" : "\n     * Tells whether or not this path is absolute.\n     *\n     * <p> An absolute path is complete in that it doesn't need to be combined\n     * with other path information in order to locate a file.\n     *\n     * @return  {@code true} if, and only if, this path is absolute\n     ",
    "links" : [ ]
  }, {
    "name" : " Path getRoot()",
    "returnType" : "Path",
    "comment" : "\n     * Returns the root component of this path as a {@code Path} object,\n     * or {@code null} if this path does not have a root component.\n     *\n     * @return  a path representing the root component of this path,\n     *          or {@code null}\n     ",
    "links" : [ ]
  }, {
    "name" : " Path getFileName()",
    "returnType" : "Path",
    "comment" : "\n     * Returns the name of the file or directory denoted by this path as a\n     * {@code Path} object. The file name is the <em>farthest</em> element from\n     * the root in the directory hierarchy.\n     *\n     * @return  a path representing the name of the file or directory, or\n     *          {@code null} if this path has zero elements\n     ",
    "links" : [ ]
  }, {
    "name" : " Path getParent()",
    "returnType" : "Path",
    "comment" : "\n     * Returns the <em>parent path</em>, or {@code null} if this path does not\n     * have a parent.\n     *\n     * <p> The parent of this path object consists of this path's root\n     * component, if any, and each element in the path except for the\n     * <em>farthest</em> from the root in the directory hierarchy. This method\n     * does not access the file system; the path or its parent may not exist.\n     * Furthermore, this method does not eliminate special names such as \".\"\n     * and \"..\" that may be used in some implementations. On UNIX for example,\n     * the parent of \"{@code /a/b/c}\" is \"{@code /a/b}\", and the parent of\n     * {@code \"x/y/.}\" is \"{@code x/y}\". This method may be used with the {@link\n     * #normalize normalize} method, to eliminate redundant names, for cases where\n     * <em>shell-like</em> navigation is required.\n     *\n     * <p> If this path has one or more elements, and no root component, then\n     * this method is equivalent to evaluating the expression:\n     * <blockquote><pre>\n     * subpath(0,&nbsp;getNameCount()-1);\n     * </pre></blockquote>\n     *\n     * @return  a path representing the path's parent\n     ",
    "links" : [ "#normalize" ]
  }, {
    "name" : " int getNameCount()",
    "returnType" : "int",
    "comment" : "\n     * Returns the number of name elements in the path.\n     *\n     * @return  the number of elements in the path, or {@code 0} if this path\n     *          only represents a root component\n     ",
    "links" : [ ]
  }, {
    "name" : " Path getName(int index)",
    "returnType" : "Path",
    "comment" : "\n     * Returns a name element of this path as a {@code Path} object.\n     *\n     * <p> The {@code index} parameter is the index of the name element to return.\n     * The element that is <em>closest</em> to the root in the directory hierarchy\n     * has index {@code 0}. The element that is <em>farthest</em> from the root\n     * has index {@link #getNameCount count}{@code -1}.\n     *\n     * @param   index\n     *          the index of the element\n     *\n     * @return  the name element\n     *\n     * @throws  IllegalArgumentException\n     *          if {@code index} is negative, {@code index} is greater than or\n     *          equal to the number of elements, or this path has zero name\n     *          elements\n     ",
    "links" : [ "#getNameCount" ]
  }, {
    "name" : " Path subpath(int beginIndex, int endIndex)",
    "returnType" : "Path",
    "comment" : "\n     * Returns a relative {@code Path} that is a subsequence of the name\n     * elements of this path.\n     *\n     * <p> The {@code beginIndex} and {@code endIndex} parameters specify the\n     * subsequence of name elements. The name that is <em>closest</em> to the root\n     * in the directory hierarchy has index {@code 0}. The name that is\n     * <em>farthest</em> from the root has index {@link #getNameCount\n     * count}{@code -1}. The returned {@code Path} object has the name elements\n     * that begin at {@code beginIndex} and extend to the element at index {@code\n     * endIndex-1}.\n     *\n     * @param   beginIndex\n     *          the index of the first element, inclusive\n     * @param   endIndex\n     *          the index of the last element, exclusive\n     *\n     * @return  a new {@code Path} object that is a subsequence of the name\n     *          elements in this {@code Path}\n     *\n     * @throws  IllegalArgumentException\n     *          if {@code beginIndex} is negative, or greater than or equal to\n     *          the number of elements. If {@code endIndex} is less than or\n     *          equal to {@code beginIndex}, or larger than the number of elements.\n     ",
    "links" : [ "#getNameCountcount" ]
  }, {
    "name" : " boolean startsWith(Path other)",
    "returnType" : "boolean",
    "comment" : "\n     * Tests if this path starts with the given path.\n     *\n     * <p> This path <em>starts</em> with the given path if this path's root\n     * component <em>starts</em> with the root component of the given path,\n     * and this path starts with the same name elements as the given path.\n     * If the given path has more name elements than this path then {@code false}\n     * is returned.\n     *\n     * <p> Whether or not the root component of this path starts with the root\n     * component of the given path is file system specific. If this path does\n     * not have a root component and the given path has a root component then\n     * this path does not start with the given path.\n     *\n     * <p> If the given path is associated with a different {@code FileSystem}\n     * to this path then {@code false} is returned.\n     *\n     * @param   other\n     *          the given path\n     *\n     * @return  {@code true} if this path starts with the given path; otherwise\n     *          {@code false}\n     ",
    "links" : [ ]
  }, {
    "name" : " boolean startsWith(String other)",
    "returnType" : "boolean",
    "comment" : "\n     * Tests if this path starts with a {@code Path}, constructed by converting\n     * the given path string, in exactly the manner specified by the {@link\n     * #startsWith(Path) startsWith(Path)} method. On UNIX for example, the path\n     * \"{@code foo/bar}\" starts with \"{@code foo}\" and \"{@code foo/bar}\". It\n     * does not start with \"{@code f}\" or \"{@code fo}\".\n     *\n     * @param   other\n     *          the given path string\n     *\n     * @return  {@code true} if this path starts with the given path; otherwise\n     *          {@code false}\n     *\n     * @throws  InvalidPathException\n     *          If the path string cannot be converted to a Path.\n     ",
    "links" : [ "#startsWith(Path)" ]
  }, {
    "name" : " boolean endsWith(Path other)",
    "returnType" : "boolean",
    "comment" : "\n     * Tests if this path ends with the given path.\n     *\n     * <p> If the given path has <em>N</em> elements, and no root component,\n     * and this path has <em>N</em> or more elements, then this path ends with\n     * the given path if the last <em>N</em> elements of each path, starting at\n     * the element farthest from the root, are equal.\n     *\n     * <p> If the given path has a root component then this path ends with the\n     * given path if the root component of this path <em>ends with</em> the root\n     * component of the given path, and the corresponding elements of both paths\n     * are equal. Whether or not the root component of this path ends with the\n     * root component of the given path is file system specific. If this path\n     * does not have a root component and the given path has a root component\n     * then this path does not end with the given path.\n     *\n     * <p> If the given path is associated with a different {@code FileSystem}\n     * to this path then {@code false} is returned.\n     *\n     * @param   other\n     *          the given path\n     *\n     * @return  {@code true} if this path ends with the given path; otherwise\n     *          {@code false}\n     ",
    "links" : [ ]
  }, {
    "name" : " boolean endsWith(String other)",
    "returnType" : "boolean",
    "comment" : "\n     * Tests if this path ends with a {@code Path}, constructed by converting\n     * the given path string, in exactly the manner specified by the {@link\n     * #endsWith(Path) endsWith(Path)} method. On UNIX for example, the path\n     * \"{@code foo/bar}\" ends with \"{@code foo/bar}\" and \"{@code bar}\". It does\n     * not end with \"{@code r}\" or \"{@code /bar}\". Note that trailing separators\n     * are not taken into account, and so invoking this method on the {@code\n     * Path}\"{@code foo/bar}\" with the {@code String} \"{@code bar/}\" returns\n     * {@code true}.\n     *\n     * @param   other\n     *          the given path string\n     *\n     * @return  {@code true} if this path ends with the given path; otherwise\n     *          {@code false}\n     *\n     * @throws  InvalidPathException\n     *          If the path string cannot be converted to a Path.\n     ",
    "links" : [ "#endsWith(Path)" ]
  }, {
    "name" : " Path normalize()",
    "returnType" : "Path",
    "comment" : "\n     * Returns a path that is this path with redundant name elements eliminated.\n     *\n     * <p> The precise definition of this method is implementation dependent but\n     * in general it derives from this path, a path that does not contain\n     * <em>redundant</em> name elements. In many file systems, the \"{@code .}\"\n     * and \"{@code ..}\" are special names used to indicate the current directory\n     * and parent directory. In such file systems all occurrences of \"{@code .}\"\n     * are considered redundant. If a \"{@code ..}\" is preceded by a\n     * non-\"{@code ..}\" name then both names are considered redundant (the\n     * process to identify such names is repeated until it is no longer\n     * applicable).\n     *\n     * <p> This method does not access the file system; the path may not locate\n     * a file that exists. Eliminating \"{@code ..}\" and a preceding name from a\n     * path may result in the path that locates a different file than the original\n     * path. This can arise when the preceding name is a symbolic link.\n     *\n     * @return  the resulting path or this path if it does not contain\n     *          redundant name elements; an empty path is returned if this path\n     *          does have a root component and all name elements are redundant\n     *\n     * @see #getParent\n     * @see #toRealPath\n     ",
    "links" : [ ]
  }, {
    "name" : " Path resolve(Path other)",
    "returnType" : "Path",
    "comment" : "\n     * Resolve the given path against this path.\n     *\n     * <p> If the {@code other} parameter is an {@link #isAbsolute() absolute}\n     * path then this method trivially returns {@code other}. If {@code other}\n     * is an <i>empty path</i> then this method trivially returns this path.\n     * Otherwise this method considers this path to be a directory and resolves\n     * the given path against this path. In the simplest case, the given path\n     * does not have a {@link #getRoot root} component, in which case this method\n     * <em>joins</em> the given path to this path and returns a resulting path\n     * that {@link #endsWith ends} with the given path. Where the given path has\n     * a root component then resolution is highly implementation dependent and\n     * therefore unspecified.\n     *\n     * @param   other\n     *          the path to resolve against this path\n     *\n     * @return  the resulting path\n     *\n     * @see #relativize\n     ",
    "links" : [ "#endsWith", "#getRoot", "#isAbsolute()" ]
  }, {
    "name" : " Path resolve(String other)",
    "returnType" : "Path",
    "comment" : "\n     * Converts a given path string to a {@code Path} and resolves it against\n     * this {@code Path} in exactly the manner specified by the {@link\n     * #resolve(Path) resolve} method. For example, suppose that the name\n     * separator is \"{@code /}\" and a path represents \"{@code foo/bar}\", then\n     * invoking this method with the path string \"{@code gus}\" will result in\n     * the {@code Path} \"{@code foo/bar/gus}\".\n     *\n     * @param   other\n     *          the path string to resolve against this path\n     *\n     * @return  the resulting path\n     *\n     * @throws  InvalidPathException\n     *          if the path string cannot be converted to a Path.\n     *\n     * @see FileSystem#getPath\n     ",
    "links" : [ "#resolve(Path)" ]
  }, {
    "name" : " Path resolveSibling(Path other)",
    "returnType" : "Path",
    "comment" : "\n     * Resolves the given path against this path's {@link #getParent parent}\n     * path. This is useful where a file name needs to be <i>replaced</i> with\n     * another file name. For example, suppose that the name separator is\n     * \"{@code /}\" and a path represents \"{@code dir1/dir2/foo}\", then invoking\n     * this method with the {@code Path} \"{@code bar}\" will result in the {@code\n     * Path} \"{@code dir1/dir2/bar}\". If this path does not have a parent path,\n     * or {@code other} is {@link #isAbsolute() absolute}, then this method\n     * returns {@code other}. If {@code other} is an empty path then this method\n     * returns this path's parent, or where this path doesn't have a parent, the\n     * empty path.\n     *\n     * @param   other\n     *          the path to resolve against this path's parent\n     *\n     * @return  the resulting path\n     *\n     * @see #resolve(Path)\n     ",
    "links" : [ "#getParent", "#isAbsolute()" ]
  }, {
    "name" : " Path resolveSibling(String other)",
    "returnType" : "Path",
    "comment" : "\n     * Converts a given path string to a {@code Path} and resolves it against\n     * this path's {@link #getParent parent} path in exactly the manner\n     * specified by the {@link #resolveSibling(Path) resolveSibling} method.\n     *\n     * @param   other\n     *          the path string to resolve against this path's parent\n     *\n     * @return  the resulting path\n     *\n     * @throws  InvalidPathException\n     *          if the path string cannot be converted to a Path.\n     *\n     * @see FileSystem#getPath\n     ",
    "links" : [ "#getParent", "#resolveSibling(Path)" ]
  }, {
    "name" : " Path relativize(Path other)",
    "returnType" : "Path",
    "comment" : "\n     * Constructs a relative path between this path and a given path.\n     *\n     * <p> Relativization is the inverse of {@link #resolve(Path) resolution}.\n     * This method attempts to construct a {@link #isAbsolute relative} path\n     * that when {@link #resolve(Path) resolved} against this path, yields a\n     * path that locates the same file as the given path. For example, on UNIX,\n     * if this path is {@code \"/a/b\"} and the given path is {@code \"/a/b/c/d\"}\n     * then the resulting relative path would be {@code \"c/d\"}. Where this\n     * path and the given path do not have a {@link #getRoot root} component,\n     * then a relative path can be constructed. A relative path cannot be\n     * constructed if only one of the paths have a root component. Where both\n     * paths have a root component then it is implementation dependent if a\n     * relative path can be constructed. If this path and the given path are\n     * {@link #equals equal} then an <i>empty path</i> is returned.\n     *\n     * <p> For any two {@link #normalize normalized} paths <i>p</i> and\n     * <i>q</i>, where <i>q</i> does not have a root component,\n     * <blockquote>\n     *   <i>p</i><tt>.relativize(</tt><i>p</i><tt>.resolve(</tt><i>q</i><tt>)).equals(</tt><i>q</i><tt>)</tt>\n     * </blockquote>\n     *\n     * <p> When symbolic links are supported, then whether the resulting path,\n     * when resolved against this path, yields a path that can be used to locate\n     * the {@link Files#isSameFile same} file as {@code other} is implementation\n     * dependent. For example, if this path is  {@code \"/a/b\"} and the given\n     * path is {@code \"/a/x\"} then the resulting relative path may be {@code\n     * \"../x\"}. If {@code \"b\"} is a symbolic link then is implementation\n     * dependent if {@code \"a/b/../x\"} would locate the same file as {@code \"/a/x\"}.\n     *\n     * @param   other\n     *          the path to relativize against this path\n     *\n     * @return  the resulting relative path, or an empty path if both paths are\n     *          equal\n     *\n     * @throws  IllegalArgumentException\n     *          if {@code other} is not a {@code Path} that can be relativized\n     *          against this path\n     ",
    "links" : [ "#equals", "#isAbsolute", "#getRoot", "java.nio.file.Files#isSameFile", "#resolve(Path)", "#normalize" ]
  }, {
    "name" : " URI toUri()",
    "returnType" : "URI",
    "comment" : "\n     * Returns a URI to represent this path.\n     *\n     * <p> This method constructs an absolute {@link URI} with a {@link\n     * URI#getScheme() scheme} equal to the URI scheme that identifies the\n     * provider. The exact form of the scheme specific part is highly provider\n     * dependent.\n     *\n     * <p> In the case of the default provider, the URI is hierarchical with\n     * a {@link URI#getPath() path} component that is absolute. The query and\n     * fragment components are undefined. Whether the authority component is\n     * defined or not is implementation dependent. There is no guarantee that\n     * the {@code URI} may be used to construct a {@link java.io.File java.io.File}.\n     * In particular, if this path represents a Universal Naming Convention (UNC)\n     * path, then the UNC server name may be encoded in the authority component\n     * of the resulting URI. In the case of the default provider, and the file\n     * exists, and it can be determined that the file is a directory, then the\n     * resulting {@code URI} will end with a slash.\n     *\n     * <p> The default provider provides a similar <em>round-trip</em> guarantee\n     * to the {@link java.io.File} class. For a given {@code Path} <i>p</i> it\n     * is guaranteed that\n     * <blockquote><tt>\n     * {@link Paths#get(URI) Paths.get}(</tt><i>p</i><tt>.toUri()).equals(</tt><i>p</i>\n     * <tt>.{@link #toAbsolutePath() toAbsolutePath}())</tt>\n     * </blockquote>\n     * so long as the original {@code Path}, the {@code URI}, and the new {@code\n     * Path} are all created in (possibly different invocations of) the same\n     * Java virtual machine. Whether other providers make any guarantees is\n     * provider specific and therefore unspecified.\n     *\n     * <p> When a file system is constructed to access the contents of a file\n     * as a file system then it is highly implementation specific if the returned\n     * URI represents the given path in the file system or it represents a\n     * <em>compound</em> URI that encodes the URI of the enclosing file system.\n     * A format for compound URIs is not defined in this release; such a scheme\n     * may be added in a future release.\n     *\n     * @return  the URI representing this path\n     *\n     * @throws  java.io.IOError\n     *          if an I/O error occurs obtaining the absolute path, or where a\n     *          file system is constructed to access the contents of a file as\n     *          a file system, and the URI of the enclosing file system cannot be\n     *          obtained\n     *\n     * @throws  SecurityException\n     *          In the case of the default provider, and a security manager\n     *          is installed, the {@link #toAbsolutePath toAbsolutePath} method\n     *          throws a security exception.\n     ",
    "links" : [ "java.nio.file.Paths#get(URI)", "#toAbsolutePath", "java.net.URI#getPath()", "java.net.URI#getScheme()", "java.net.URI", "java.io.File", "#toAbsolutePath()" ]
  }, {
    "name" : " Path toAbsolutePath()",
    "returnType" : "Path",
    "comment" : "\n     * Returns a {@code Path} object representing the absolute path of this\n     * path.\n     *\n     * <p> If this path is already {@link Path#isAbsolute absolute} then this\n     * method simply returns this path. Otherwise, this method resolves the path\n     * in an implementation dependent manner, typically by resolving the path\n     * against a file system default directory. Depending on the implementation,\n     * this method may throw an I/O error if the file system is not accessible.\n     *\n     * @return  a {@code Path} object representing the absolute path\n     *\n     * @throws  java.io.IOError\n     *          if an I/O error occurs\n     * @throws  SecurityException\n     *          In the case of the default provider, a security manager\n     *          is installed, and this path is not absolute, then the security\n     *          manager's {@link SecurityManager#checkPropertyAccess(String)\n     *          checkPropertyAccess} method is invoked to check access to the\n     *          system property {@code user.dir}\n     ",
    "links" : [ "#checkPropertyAccess(String)", "java.nio.file.Path#isAbsolute" ]
  }, {
    "name" : " Path toRealPath(LinkOption... options) throws IOException",
    "returnType" : "Path",
    "comment" : "\n     * Returns the <em>real</em> path of an existing file.\n     *\n     * <p> The precise definition of this method is implementation dependent but\n     * in general it derives from this path, an {@link #isAbsolute absolute}\n     * path that locates the {@link Files#isSameFile same} file as this path, but\n     * with name elements that represent the actual name of the directories\n     * and the file. For example, where filename comparisons on a file system\n     * are case insensitive then the name elements represent the names in their\n     * actual case. Additionally, the resulting path has redundant name\n     * elements removed.\n     *\n     * <p> If this path is relative then its absolute path is first obtained,\n     * as if by invoking the {@link #toAbsolutePath toAbsolutePath} method.\n     *\n     * <p> The {@code options} array may be used to indicate how symbolic links\n     * are handled. By default, symbolic links are resolved to their final\n     * target. If the option {@link LinkOption#NOFOLLOW_LINKS NOFOLLOW_LINKS} is\n     * present then this method does not resolve symbolic links.\n     *\n     * Some implementations allow special names such as \"{@code ..}\" to refer to\n     * the parent directory. When deriving the <em>real path</em>, and a\n     * \"{@code ..}\" (or equivalent) is preceded by a non-\"{@code ..}\" name then\n     * an implementation will typically cause both names to be removed. When\n     * not resolving symbolic links and the preceding name is a symbolic link\n     * then the names are only removed if it guaranteed that the resulting path\n     * will locate the same file as this path.\n     *\n     * @param   options\n     *          options indicating how symbolic links are handled\n     *\n     * @return  an absolute path represent the <em>real</em> path of the file\n     *          located by this object\n     *\n     * @throws  IOException\n     *          if the file does not exist or an I/O error occurs\n     * @throws  SecurityException\n     *          In the case of the default provider, and a security manager\n     *          is installed, its {@link SecurityManager#checkRead(String) checkRead}\n     *          method is invoked to check read access to the file, and where\n     *          this path is not absolute, its {@link SecurityManager#checkPropertyAccess(String)\n     *          checkPropertyAccess} method is invoked to check access to the\n     *          system property {@code user.dir}\n     ",
    "links" : [ "#checkPropertyAccess(String)", "#toAbsolutePath", "#checkRead(String)", "#isAbsolute", "java.nio.file.LinkOption#NOFOLLOW_LINKS", "java.nio.file.Files#isSameFile" ]
  }, {
    "name" : " File toFile()",
    "returnType" : "File",
    "comment" : "\n     * Returns a {@link File} object representing this path. Where this {@code\n     * Path} is associated with the default provider, then this method is\n     * equivalent to returning a {@code File} object constructed with the\n     * {@code String} representation of this path.\n     *\n     * <p> If this path was created by invoking the {@code File} {@link\n     * File#toPath toPath} method then there is no guarantee that the {@code\n     * File} object returned by this method is {@link #equals equal} to the\n     * original {@code File}.\n     *\n     * @return  a {@code File} object representing this path\n     *\n     * @throws  UnsupportedOperationException\n     *          if this {@code Path} is not associated with the default provider\n     ",
    "links" : [ "#equals", "java.io.File#toPath", "java.io.File" ]
  }, {
    "name" : " WatchKey register(WatchService watcher, WatchEvent.Kind<?>[] events, WatchEvent.Modifier... modifiers) throws IOException",
    "returnType" : "WatchKey",
    "comment" : "\n     * Registers the file located by this path with a watch service.\n     *\n     * <p> In this release, this path locates a directory that exists. The\n     * directory is registered with the watch service so that entries in the\n     * directory can be watched. The {@code events} parameter is the events to\n     * register and may contain the following events:\n     * <ul>\n     *   <li>{@link StandardWatchEventKinds#ENTRY_CREATE ENTRY_CREATE} -\n     *       entry created or moved into the directory</li>\n     *   <li>{@link StandardWatchEventKinds#ENTRY_DELETE ENTRY_DELETE} -\n     *        entry deleted or moved out of the directory</li>\n     *   <li>{@link StandardWatchEventKinds#ENTRY_MODIFY ENTRY_MODIFY} -\n     *        entry in directory was modified</li>\n     * </ul>\n     *\n     * <p> The {@link WatchEvent#context context} for these events is the\n     * relative path between the directory located by this path, and the path\n     * that locates the directory entry that is created, deleted, or modified.\n     *\n     * <p> The set of events may include additional implementation specific\n     * event that are not defined by the enum {@link StandardWatchEventKinds}\n     *\n     * <p> The {@code modifiers} parameter specifies <em>modifiers</em> that\n     * qualify how the directory is registered. This release does not define any\n     * <em>standard</em> modifiers. It may contain implementation specific\n     * modifiers.\n     *\n     * <p> Where a file is registered with a watch service by means of a symbolic\n     * link then it is implementation specific if the watch continues to depend\n     * on the existence of the symbolic link after it is registered.\n     *\n     * @param   watcher\n     *          the watch service to which this object is to be registered\n     * @param   events\n     *          the events for which this object should be registered\n     * @param   modifiers\n     *          the modifiers, if any, that modify how the object is registered\n     *\n     * @return  a key representing the registration of this object with the\n     *          given watch service\n     *\n     * @throws  UnsupportedOperationException\n     *          if unsupported events or modifiers are specified\n     * @throws  IllegalArgumentException\n     *          if an invalid combination of events or modifiers is specified\n     * @throws  ClosedWatchServiceException\n     *          if the watch service is closed\n     * @throws  NotDirectoryException\n     *          if the file is registered to watch the entries in a directory\n     *          and the file is not a directory  <i>(optional specific exception)</i>\n     * @throws  IOException\n     *          if an I/O error occurs\n     * @throws  SecurityException\n     *          In the case of the default provider, and a security manager is\n     *          installed, the {@link SecurityManager#checkRead(String) checkRead}\n     *          method is invoked to check read access to the file.\n     ",
    "links" : [ "java.nio.file.StandardWatchEventKinds#ENTRY_CREATE", "java.nio.file.WatchEvent#context", "java.nio.file.StandardWatchEventKinds#ENTRY_DELETE", "java.nio.file.StandardWatchEventKinds", "#checkRead(String)", "java.nio.file.StandardWatchEventKinds#ENTRY_MODIFY" ]
  }, {
    "name" : " WatchKey register(WatchService watcher, WatchEvent.Kind<?>... events) throws IOException",
    "returnType" : "WatchKey",
    "comment" : "\n     * Registers the file located by this path with a watch service.\n     *\n     * <p> An invocation of this method behaves in exactly the same way as the\n     * invocation\n     * <pre>\n     *     watchable.{@link #register(WatchService,WatchEvent.Kind[],WatchEvent.Modifier[]) register}(watcher, events, new WatchEvent.Modifier[0]);\n     * </pre>\n     *\n     * <p> <b>Usage Example:</b>\n     * Suppose we wish to register a directory for entry create, delete, and modify\n     * events:\n     * <pre>\n     *     Path dir = ...\n     *     WatchService watcher = ...\n     *\n     *     WatchKey key = dir.register(watcher, ENTRY_CREATE, ENTRY_DELETE, ENTRY_MODIFY);\n     * </pre>\n     * @param   watcher\n     *          The watch service to which this object is to be registered\n     * @param   events\n     *          The events for which this object should be registered\n     *\n     * @return  A key representing the registration of this object with the\n     *          given watch service\n     *\n     * @throws  UnsupportedOperationException\n     *          If unsupported events are specified\n     * @throws  IllegalArgumentException\n     *          If an invalid combination of events is specified\n     * @throws  ClosedWatchServiceException\n     *          If the watch service is closed\n     * @throws  NotDirectoryException\n     *          If the file is registered to watch the entries in a directory\n     *          and the file is not a directory  <i>(optional specific exception)</i>\n     * @throws  IOException\n     *          If an I/O error occurs\n     * @throws  SecurityException\n     *          In the case of the default provider, and a security manager is\n     *          installed, the {@link SecurityManager#checkRead(String) checkRead}\n     *          method is invoked to check read access to the file.\n     ",
    "links" : [ "#checkRead(String)", "#register(WatchService" ]
  }, {
    "name" : " Iterator<Path> iterator()",
    "returnType" : "Iterator<Path>",
    "comment" : "\n     * Returns an iterator over the name elements of this path.\n     *\n     * <p> The first element returned by the iterator represents the name\n     * element that is closest to the root in the directory hierarchy, the\n     * second element is the next closest, and so on. The last element returned\n     * is the name of the file or directory denoted by this path. The {@link\n     * #getRoot root} component, if present, is not returned by the iterator.\n     *\n     * @return  an iterator over the name elements of this path.\n     ",
    "links" : [ "#getRoot" ]
  }, {
    "name" : " int compareTo(Path other)",
    "returnType" : "int",
    "comment" : "\n     * Compares two abstract paths lexicographically. The ordering defined by\n     * this method is provider specific, and in the case of the default\n     * provider, platform specific. This method does not access the file system\n     * and neither file is required to exist.\n     *\n     * <p> This method may not be used to compare paths that are associated\n     * with different file system providers.\n     *\n     * @param   other  the path compared to this path.\n     *\n     * @return  zero if the argument is {@link #equals equal} to this path, a\n     *          value less than zero if this path is lexicographically less than\n     *          the argument, or a value greater than zero if this path is\n     *          lexicographically greater than the argument\n     *\n     * @throws  ClassCastException\n     *          if the paths are associated with different providers\n     ",
    "links" : [ "#equals" ]
  }, {
    "name" : " boolean equals(Object other)",
    "returnType" : "boolean",
    "comment" : "\n     * Tests this path for equality with the given object.\n     *\n     * <p> If the given object is not a Path, or is a Path associated with a\n     * different {@code FileSystem}, then this method returns {@code false}.\n     *\n     * <p> Whether or not two path are equal depends on the file system\n     * implementation. In some cases the paths are compared without regard\n     * to case, and others are case sensitive. This method does not access the\n     * file system and the file is not required to exist. Where required, the\n     * {@link Files#isSameFile isSameFile} method may be used to check if two\n     * paths locate the same file.\n     *\n     * <p> This method satisfies the general contract of the {@link\n     * java.lang.Object#equals(Object) Object.equals} method. </p>\n     *\n     * @param   other\n     *          the object to which this object is to be compared\n     *\n     * @return  {@code true} if, and only if, the given object is a {@code Path}\n     *          that is identical to this {@code Path}\n     ",
    "links" : [ "java.lang.Object#equals(Object)", "java.nio.file.Files#isSameFile" ]
  }, {
    "name" : " int hashCode()",
    "returnType" : "int",
    "comment" : "\n     * Computes a hash code for this path.\n     *\n     * <p> The hash code is based upon the components of the path, and\n     * satisfies the general contract of the {@link Object#hashCode\n     * Object.hashCode} method.\n     *\n     * @return  the hash-code value for this path\n     ",
    "links" : [ "#hashCodeObject.hashCode" ]
  }, {
    "name" : " String toString()",
    "returnType" : "String",
    "comment" : "\n     * Returns the string representation of this path.\n     *\n     * <p> If this path was created by converting a path string using the\n     * {@link FileSystem#getPath getPath} method then the path string returned\n     * by this method may differ from the original String used to create the path.\n     *\n     * <p> The returned path string uses the default name {@link\n     * FileSystem#getSeparator separator} to separate names in the path.\n     *\n     * @return  the string representation of this path\n     ",
    "links" : [ "java.nio.file.FileSystem#getPath", "java.nio.file.FileSystem#getSeparator" ]
  } ],
  "methodNames" : [ "public static Path of(String first, String... more)", "public static Path of(URI uri)", " FileSystem getFileSystem()", " boolean isAbsolute()", " Path getRoot()", " Path getFileName()", " Path getParent()", " int getNameCount()", " Path getName(int index)", " Path subpath(int beginIndex, int endIndex)", " boolean startsWith(Path other)", " boolean startsWith(String other)", " boolean endsWith(Path other)", " boolean endsWith(String other)", " Path normalize()", " Path resolve(Path other)", " Path resolve(String other)", " Path resolveSibling(Path other)", " Path resolveSibling(String other)", " Path relativize(Path other)", " URI toUri()", " Path toAbsolutePath()", " Path toRealPath(LinkOption... options) throws IOException", " File toFile()", " WatchKey register(WatchService watcher, WatchEvent.Kind<?>[] events, WatchEvent.Modifier... modifiers) throws IOException", " WatchKey register(WatchService watcher, WatchEvent.Kind<?>... events) throws IOException", " Iterator<Path> iterator()", " int compareTo(Path other)", " boolean equals(Object other)", " int hashCode()", " String toString()" ],
  "variableNames" : [ ]
}