{
  "filePath" : "/home/maryam/clearblue/files/android-source-35/android/location/LocationManager.java",
  "packageName" : "android.location",
  "className" : "LocationManager",
  "comment" : "\n * This class provides access to the system location services. These services allow applications to\n * obtain periodic updates of the device's geographical location, or to be notified when the device\n * enters the proximity of a given geographical location.\n *\n * <p class=\"note\">Unless otherwise noted, all Location API methods require the\n * {@link android.Manifest.permission#ACCESS_COARSE_LOCATION} or\n * {@link android.Manifest.permission#ACCESS_FINE_LOCATION} permissions. If your application only\n * has the coarse permission then providers will still return location results, but the exact\n * location will be obfuscated to a coarse level of accuracy.\n ",
  "links" : [ "android.Manifest.permission#ACCESS_COARSE_LOCATION", "android.Manifest.permission#ACCESS_FINE_LOCATION" ],
  "variables" : [ {
    "name" : "BLOCK_IMMUTABLE_PENDING_INTENTS",
    "type" : "long",
    "comment" : "\n     * For apps targeting Android S and above, immutable PendingIntents passed into location APIs\n     * will generate an IllegalArgumentException.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "BLOCK_PENDING_INTENT_SYSTEM_API_USAGE",
    "type" : "long",
    "comment" : "\n     * For apps targeting Android S and above, LocationRequest system APIs may not be used with\n     * PendingIntent location requests.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "DELIVER_HISTORICAL_LOCATIONS",
    "type" : "long",
    "comment" : "\n     * For apps targeting Android S and above, location clients may receive historical locations\n     * (from before the present time) under some circumstances.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "GET_PROVIDER_SECURITY_EXCEPTIONS",
    "type" : "long",
    "comment" : "\n     * For apps targeting Android R and above, {@link #getProvider(String)} will no longer throw any\n     * security exceptions.\n     *\n     * @hide\n     ",
    "links" : [ "#getProvider(String)" ]
  }, {
    "name" : "BLOCK_UNTARGETED_PENDING_INTENTS",
    "type" : "long",
    "comment" : "\n     * For apps targeting Android K and above, supplied {@link PendingIntent}s must be targeted to a\n     * specific package.\n     *\n     * @hide\n     ",
    "links" : [ "android.app.PendingIntent" ]
  }, {
    "name" : "BLOCK_INCOMPLETE_LOCATIONS",
    "type" : "long",
    "comment" : "\n     * For apps targeting Android K and above, incomplete locations may not be passed to\n     * {@link #setTestProviderLocation}.\n     *\n     * @hide\n     ",
    "links" : [ "#setTestProviderLocation" ]
  }, {
    "name" : "BLOCK_GPS_STATUS_USAGE",
    "type" : "long",
    "comment" : "\n     * For apps targeting Android S and above, all {@link GpsStatus} API usage must be replaced with\n     * {@link GnssStatus} APIs.\n     *\n     * @hide\n     ",
    "links" : [ "android.location.GpsStatus", "android.location.GnssStatus" ]
  }, {
    "name" : "NETWORK_PROVIDER",
    "type" : "String",
    "comment" : "\n     * Standard name of the network location provider.\n     *\n     * <p>If present, this provider determines location based on nearby of cell tower and WiFi\n     * access points. Operation of this provider may require a data connection.\n     ",
    "links" : [ ]
  }, {
    "name" : "GPS_PROVIDER",
    "type" : "String",
    "comment" : "\n     * Standard name of the GNSS location provider.\n     *\n     * <p>If present, this provider determines location using GNSS satellites. The responsiveness\n     * and accuracy of location fixes may depend on GNSS signal conditions.\n     *\n     * <p>Locations returned from this provider are with respect to the primary GNSS antenna\n     * position within the device. {@link #getGnssAntennaInfos()} may be used to determine the GNSS\n     * antenna position with respect to the Android Coordinate System, and convert between them if\n     * necessary. This is generally only necessary for high accuracy applications.\n     *\n     * <p>The extras Bundle for locations derived by this location provider may contain the\n     * following key/value pairs:\n     * <ul>\n     * <li> satellites - the number of satellites used to derive the fix\n     * </ul>\n     ",
    "links" : [ "#getGnssAntennaInfos()" ]
  }, {
    "name" : "GPS_HARDWARE_PROVIDER",
    "type" : "String",
    "comment" : "\n     * Standard name of the GNSS hardware location provider.\n     *\n     * <p>This provider is similar to {@link LocationManager#GPS_PROVIDER}, but it directly uses the\n     * HAL GNSS implementation and doesn't go through any provider overrides that may exist. This\n     * provider will only be available when the GPS_PROVIDER is overridden with a proxy using {@link\n     * android.location.provider.LocationProviderBase#ACTION_GNSS_PROVIDER}, and is intended only\n     * for use internally by the location provider system.\n     *\n     * @hide\n     ",
    "links" : [ "android.location.LocationManager#GPS_PROVIDER", "android.location.provider.LocationProviderBase#ACTION_GNSS_PROVIDER" ]
  }, {
    "name" : "PASSIVE_PROVIDER",
    "type" : "String",
    "comment" : "\n     * A special location provider for receiving locations without actively initiating a location\n     * fix. This location provider is always present.\n     *\n     * <p>This provider can be used to passively receive location updates when other applications or\n     * services request them without actually requesting the locations yourself. This provider will\n     * only return locations generated by other providers.\n     ",
    "links" : [ ]
  }, {
    "name" : "FUSED_PROVIDER",
    "type" : "String",
    "comment" : "\n     * Standard name of the fused location provider.\n     *\n     * <p>If present, this provider may combine inputs from several other location providers to\n     * provide the best possible location fix. It is implicitly used for all requestLocationUpdates\n     * APIs that involve a {@link Criteria}.\n     ",
    "links" : [ "android.location.LocationRequest.createFromDeprecatedCriteria" ]
  }, {
    "name" : "KEY_PROXIMITY_ENTERING",
    "type" : "String",
    "comment" : "\n     * Key used for the Bundle extra holding a boolean indicating whether\n     * a proximity alert is entering (true) or exiting (false)..\n     ",
    "links" : [ ]
  }, {
    "name" : "KEY_STATUS_CHANGED",
    "type" : "String",
    "comment" : "\n     * This key is no longer in use.\n     *\n     * <p>Key used for a Bundle extra holding an Integer status value when a status change is\n     * broadcast using a PendingIntent.\n     *\n     * @deprecated Status changes are deprecated and no longer broadcast from Android Q onwards.\n     ",
    "links" : [ ]
  }, {
    "name" : "KEY_PROVIDER_ENABLED",
    "type" : "String",
    "comment" : "\n     * Key used for an extra holding a boolean enabled/disabled status value when a provider\n     * enabled/disabled event is broadcast using a PendingIntent.\n     *\n     * @see #requestLocationUpdates(String, LocationRequest, PendingIntent)\n     ",
    "links" : [ ]
  }, {
    "name" : "KEY_LOCATION_CHANGED",
    "type" : "String",
    "comment" : "\n     * Key used for an extra holding a {@link Location} value when a location change is sent using\n     * a PendingIntent. If the location change includes a list of batched locations via\n     * {@link #KEY_LOCATIONS} then this key will still be present, and will hold the last location\n     * in the batch. Use {@link Intent#getParcelableExtra(String)} to retrieve the location.\n     *\n     * @see #requestLocationUpdates(String, LocationRequest, PendingIntent)\n     ",
    "links" : [ "android.app.PendingIntent#getParcelableExtra(String)", "android.location.Location", "#KEY_LOCATIONS" ]
  }, {
    "name" : "KEY_LOCATIONS",
    "type" : "String",
    "comment" : "\n     * Key used for an extra holding a array of {@link Location}s when a location change is sent\n     * using a PendingIntent. This key will only be present if the location change includes\n     * multiple (ie, batched) locations, otherwise only {@link #KEY_LOCATION_CHANGED} will be\n     * present. Use {@link Intent#getParcelableArrayExtra(String)} to retrieve the locations.\n     *\n     * <p>The array of locations will never be empty, and will ordered from earliest location to\n     * latest location, the same as with {@link LocationListener#onLocationChanged(List)}.\n     *\n     * @see #requestLocationUpdates(String, LocationRequest, PendingIntent)\n     ",
    "links" : [ "android.location.LocationListener#onLocationChanged(List)", "android.app.PendingIntent#getParcelableArrayExtra(String)", "android.location.Location", "#KEY_LOCATION_CHANGED" ]
  }, {
    "name" : "KEY_FLUSH_COMPLETE",
    "type" : "String",
    "comment" : "\n     * Key used for an extra holding an integer request code when location flush completion is sent\n     * using a PendingIntent.\n     *\n     * @see #requestFlush(String, PendingIntent, int)\n     ",
    "links" : [ ]
  }, {
    "name" : "PROVIDERS_CHANGED_ACTION",
    "type" : "String",
    "comment" : "\n     * Broadcast intent action when the set of enabled location providers changes. To check the\n     * status of a provider, use {@link #isProviderEnabled(String)}. From Android Q and above, will\n     * include a string intent extra, {@link #EXTRA_PROVIDER_NAME}, with the name of the provider\n     * whose state has changed. From Android R and above, will include a boolean intent extra,\n     * {@link #EXTRA_PROVIDER_ENABLED}, with the enabled state of the provider.\n     *\n     * @see #EXTRA_PROVIDER_NAME\n     * @see #EXTRA_PROVIDER_ENABLED\n     * @see #isProviderEnabled(String)\n     ",
    "links" : [ "#EXTRA_PROVIDER_ENABLED", "#EXTRA_PROVIDER_NAME", "#isProviderEnabled(String)" ]
  }, {
    "name" : "EXTRA_PROVIDER_NAME",
    "type" : "String",
    "comment" : "\n     * Intent extra included with {@link #PROVIDERS_CHANGED_ACTION} broadcasts, containing the name\n     * of the location provider that has changed.\n     *\n     * @see #PROVIDERS_CHANGED_ACTION\n     * @see #EXTRA_PROVIDER_ENABLED\n     ",
    "links" : [ "#PROVIDERS_CHANGED_ACTION" ]
  }, {
    "name" : "EXTRA_PROVIDER_ENABLED",
    "type" : "String",
    "comment" : "\n     * Intent extra included with {@link #PROVIDERS_CHANGED_ACTION} broadcasts, containing the\n     * boolean enabled state of the location provider that has changed.\n     *\n     * @see #PROVIDERS_CHANGED_ACTION\n     * @see #EXTRA_PROVIDER_NAME\n     ",
    "links" : [ "#PROVIDERS_CHANGED_ACTION" ]
  }, {
    "name" : "MODE_CHANGED_ACTION",
    "type" : "String",
    "comment" : "\n     * Broadcast intent action when the device location enabled state changes. From Android R and\n     * above, will include a boolean intent extra, {@link #EXTRA_LOCATION_ENABLED}, with the enabled\n     * state of location.\n     *\n     * @see #EXTRA_LOCATION_ENABLED\n     * @see #isLocationEnabled()\n     ",
    "links" : [ "#EXTRA_LOCATION_ENABLED" ]
  }, {
    "name" : "EXTRA_LOCATION_ENABLED",
    "type" : "String",
    "comment" : "\n     * Intent extra included with {@link #MODE_CHANGED_ACTION} broadcasts, containing the boolean\n     * enabled state of location.\n     *\n     * @see #MODE_CHANGED_ACTION\n     ",
    "links" : [ "#MODE_CHANGED_ACTION" ]
  }, {
    "name" : "ACTION_ADAS_GNSS_ENABLED_CHANGED",
    "type" : "String",
    "comment" : "\n     * Broadcast intent action when the ADAS (Advanced Driving Assistance Systems) GNSS location\n     * enabled state changes. Includes a boolean intent extra, {@link #EXTRA_ADAS_GNSS_ENABLED},\n     * with the enabled state of ADAS GNSS location. This broadcast only has meaning on automotive\n     * devices.\n     *\n     * @see #EXTRA_ADAS_GNSS_ENABLED\n     * @see #isAdasGnssLocationEnabled()\n     *\n     * @hide\n     ",
    "links" : [ "#EXTRA_ADAS_GNSS_ENABLED" ]
  }, {
    "name" : "EXTRA_ADAS_GNSS_ENABLED",
    "type" : "String",
    "comment" : "\n     * Intent extra included with {@link #ACTION_ADAS_GNSS_ENABLED_CHANGED} broadcasts, containing\n     * the boolean enabled state of ADAS GNSS location.\n     *\n     * @see #ACTION_ADAS_GNSS_ENABLED_CHANGED\n     *\n     * @hide\n     ",
    "links" : [ "#ACTION_ADAS_GNSS_ENABLED_CHANGED" ]
  }, {
    "name" : "HIGH_POWER_REQUEST_CHANGE_ACTION",
    "type" : "String",
    "comment" : "\n     * Broadcast intent action indicating that a high power location requests\n     * has either started or stopped being active.  The current state of\n     * active location requests should be read from AppOpsManager using\n     * {@code OP_MONITOR_HIGH_POWER_LOCATION}.\n     *\n     * @hide\n     * @deprecated This action is unnecessary from Android S forward.\n     ",
    "links" : [ ]
  }, {
    "name" : "ACTION_GNSS_CAPABILITIES_CHANGED",
    "type" : "String",
    "comment" : "\n     * Broadcast intent action when GNSS capabilities change. This is most common at boot time as\n     * GNSS capabilities are queried from the chipset. Includes an intent extra,\n     * {@link #EXTRA_GNSS_CAPABILITIES}, with the new {@link GnssCapabilities}.\n     *\n     * @see #EXTRA_GNSS_CAPABILITIES\n     * @see #getGnssCapabilities()\n     ",
    "links" : [ "#EXTRA_GNSS_CAPABILITIES", "android.location.GnssCapabilities" ]
  }, {
    "name" : "EXTRA_GNSS_CAPABILITIES",
    "type" : "String",
    "comment" : "\n     * Intent extra included with {@link #ACTION_GNSS_CAPABILITIES_CHANGED} broadcasts, containing\n     * the new {@link GnssCapabilities}.\n     *\n     * @see #ACTION_GNSS_CAPABILITIES_CHANGED\n     ",
    "links" : [ "android.location.GnssCapabilities", "#ACTION_GNSS_CAPABILITIES_CHANGED" ]
  }, {
    "name" : "SETTINGS_FOOTER_DISPLAYED_ACTION",
    "type" : "String",
    "comment" : "\n     * Broadcast intent action for Settings app to inject a footer at the bottom of location\n     * settings. This is for use only by apps that are included in the system image.\n     *\n     * <p>To inject a footer to location settings, you must declare a broadcast receiver for\n     * this action in the manifest:\n     * <pre>\n     *     &lt;receiver android:name=\"com.example.android.footer.MyFooterInjector\"&gt;\n     *         &lt;intent-filter&gt;\n     *             &lt;action android:name=\"com.android.settings.location.INJECT_FOOTER\" /&gt;\n     *         &lt;/intent-filter&gt;\n     *         &lt;meta-data\n     *             android:name=\"com.android.settings.location.FOOTER_STRING\"\n     *             android:resource=\"@string/my_injected_footer_string\" /&gt;\n     *     &lt;/receiver&gt;\n     * </pre>\n     *\n     * <p>This broadcast receiver will never actually be invoked. See also\n     * {#METADATA_SETTINGS_FOOTER_STRING}.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "METADATA_SETTINGS_FOOTER_STRING",
    "type" : "String",
    "comment" : "\n     * Metadata name for {@link LocationManager#SETTINGS_FOOTER_DISPLAYED_ACTION} broadcast\n     * receivers to specify a string resource id as location settings footer text. This is for use\n     * only by apps that are included in the system image.\n     *\n     * <p>See {@link #SETTINGS_FOOTER_DISPLAYED_ACTION} for more detail on how to use.\n     *\n     * @hide\n     ",
    "links" : [ "#SETTINGS_FOOTER_DISPLAYED_ACTION", "android.location.LocationManager#SETTINGS_FOOTER_DISPLAYED_ACTION" ]
  }, {
    "name" : "METADATA_SETTINGS_FOOTER_HTML",
    "type" : "String",
    "comment" : "\n     * Metadata name for {@link LocationManager#SETTINGS_FOOTER_DISPLAYED_ACTION} broadcast\n     * receivers to specify a string resource id as location settings footer HTML snippet. This is\n     * for use only by apps that are included in the system image. If HTML snippet is provided,\n     * plain text footer text specified with {@link #METADATA_SETTINGS_FOOTER_STRING} will be\n     * ignored.\n     *\n     * <p>See {@link #SETTINGS_FOOTER_DISPLAYED_ACTION} for more detail on how to use.\n     *\n     * @hide\n     ",
    "links" : [ "#METADATA_SETTINGS_FOOTER_STRING", "#SETTINGS_FOOTER_DISPLAYED_ACTION", "android.location.LocationManager#SETTINGS_FOOTER_DISPLAYED_ACTION" ]
  }, {
    "name" : "MAX_SINGLE_LOCATION_TIMEOUT_MS",
    "type" : "long",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "CACHE_KEY_LOCATION_ENABLED_PROPERTY",
    "type" : "String",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "sLocationEnabledCache",
    "type" : "LocationEnabledCache",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "sLocationListeners",
    "type" : "WeakHashMap<LocationListener, WeakReference<LocationListenerTransport>>",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mContext",
    "type" : "Context",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mService",
    "type" : "ILocationManager",
    "comment" : "",
    "links" : [ ]
  } ],
  "methods" : [ {
    "name" : " static ILocationManager getService() throws RemoteException",
    "returnType" : "ILocationManager",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public String[] getBackgroundThrottlingWhitelist()",
    "returnType" : "String[]",
    "comment" : "\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public String[] getIgnoreSettingsWhitelist()",
    "returnType" : "String[]",
    "comment" : "\n     * @deprecated Do not use.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public PackageTagsList getIgnoreSettingsAllowlist()",
    "returnType" : "PackageTagsList",
    "comment" : "\n     * For testing purposes only.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public PackageTagsList getAdasAllowlist()",
    "returnType" : "PackageTagsList",
    "comment" : "\n     * Returns ADAS packages and their associated attribution tags.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public String getExtraLocationControllerPackage()",
    "returnType" : "String",
    "comment" : "\n     * Returns the extra location controller package on the device.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public void setExtraLocationControllerPackage(@Nullable String packageName)",
    "returnType" : "void",
    "comment" : "\n     * Set the extra location controller package for location services on the device.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public void setExtraLocationControllerPackageEnabled(boolean enabled)",
    "returnType" : "void",
    "comment" : "\n     * Set whether the extra location controller package is currently enabled on the device.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean isExtraLocationControllerPackageEnabled()",
    "returnType" : "boolean",
    "comment" : "\n     * Returns whether extra location controller package is currently enabled on the device.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public void setLocationControllerExtraPackage(String packageName)",
    "returnType" : "void",
    "comment" : "\n     * Set the extra location controller package for location services on the device.\n     *\n     * @removed\n     * @deprecated Use {@link #setExtraLocationControllerPackage} instead.\n     * @hide\n     ",
    "links" : [ "#setExtraLocationControllerPackage" ]
  }, {
    "name" : "public void setLocationControllerExtraPackageEnabled(boolean enabled)",
    "returnType" : "void",
    "comment" : "\n     * Set whether the extra location controller package is currently enabled on the device.\n     *\n     * @removed\n     * @deprecated Use {@link #setExtraLocationControllerPackageEnabled} instead.\n     * @hide\n     ",
    "links" : [ "#setExtraLocationControllerPackageEnabled" ]
  }, {
    "name" : "public boolean isLocationEnabled()",
    "returnType" : "boolean",
    "comment" : "\n     * Returns the current enabled/disabled state of location. To listen for changes, see\n     * {@link #MODE_CHANGED_ACTION}.\n     *\n     * @return true if location is enabled and false if location is disabled.\n     ",
    "links" : [ "#MODE_CHANGED_ACTION" ]
  }, {
    "name" : "public boolean isLocationEnabledForUser(@NonNull UserHandle userHandle)",
    "returnType" : "boolean",
    "comment" : "\n     * Returns the current enabled/disabled state of location for the given user.\n     *\n     * @param userHandle the user to query\n     * @return true if location is enabled and false if location is disabled.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public void setLocationEnabledForUser(boolean enabled, @NonNull UserHandle userHandle)",
    "returnType" : "void",
    "comment" : "\n     * Enables or disables location for the given user.\n     *\n     * @param enabled true to enable location and false to disable location.\n     * @param userHandle the user to set\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean isAdasGnssLocationEnabled()",
    "returnType" : "boolean",
    "comment" : "\n     * Returns the current enabled/disabled state of ADAS (Advanced Driving Assistance Systems)\n     * GNSS location access for the given user. This controls safety critical automotive access to\n     * GNSS location. This only has meaning on automotive devices.\n     *\n     * @return true if ADAS location is enabled and false if ADAS location is disabled.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public void setAdasGnssLocationEnabled(boolean enabled)",
    "returnType" : "void",
    "comment" : "\n     * Enables or disables ADAS (Advanced Driving Assistance Systems) GNSS location access for the\n     * given user. This only has meaning on automotive devices.\n     *\n     * @param enabled true to enable ADAS location and false to disable ADAS location.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean isProviderEnabled(@NonNull String provider)",
    "returnType" : "boolean",
    "comment" : "\n     * Returns the current enabled/disabled status of the given provider. To listen for changes, see\n     * {@link #PROVIDERS_CHANGED_ACTION}.\n     *\n     * Before API version {@link android.os.Build.VERSION_CODES#LOLLIPOP}, this method would throw\n     * {@link SecurityException} if the location permissions were not sufficient to use the\n     * specified provider.\n     *\n     * @param provider a provider listed by {@link #getAllProviders()}\n     * @return true if the provider exists and is enabled\n     *\n     * @throws IllegalArgumentException if provider is null\n     ",
    "links" : [ "android.os.Build.VERSION_CODES#LOLLIPOP", "#getAllProviders()", "SecurityException", "#PROVIDERS_CHANGED_ACTION" ]
  }, {
    "name" : "public boolean isProviderEnabledForUser(@NonNull String provider, @NonNull UserHandle userHandle)",
    "returnType" : "boolean",
    "comment" : "\n     * Returns the current enabled/disabled status of the given provider and user. Callers should\n     * prefer {@link #isLocationEnabledForUser(UserHandle)} unless they depend on provider-specific\n     * APIs.\n     *\n     * Before API version {@link android.os.Build.VERSION_CODES#LOLLIPOP}, this method would throw\n     * {@link SecurityException} if the location permissions were not sufficient to use the\n     * specified provider.\n     *\n     * @param provider a provider listed by {@link #getAllProviders()}\n     * @param userHandle the user to query\n     * @return true if the provider exists and is enabled\n     *\n     * @throws IllegalArgumentException if provider is null\n     * @hide\n     ",
    "links" : [ "android.os.Build.VERSION_CODES#LOLLIPOP", "#getAllProviders()", "SecurityException", "#isLocationEnabledForUser(UserHandle)" ]
  }, {
    "name" : "public boolean setProviderEnabledForUser(@NonNull String provider, boolean enabled, @NonNull UserHandle userHandle)",
    "returnType" : "boolean",
    "comment" : "\n     * Method for enabling or disabling a single location provider. This method is deprecated and\n     * functions as a best effort. It should not be relied on in any meaningful sense as providers\n     * may no longer be enabled or disabled by clients.\n     *\n     * @param provider a provider listed by {@link #getAllProviders()}\n     * @param enabled whether to enable or disable the provider\n     * @param userHandle the user to set\n     * @return true if the value was set, false otherwise\n     *\n     * @throws IllegalArgumentException if provider is null\n     * @deprecated Do not manipulate providers individually, use\n     * {@link #setLocationEnabledForUser(boolean, UserHandle)} instead.\n     * @hide\n     ",
    "links" : [ "#getAllProviders()", "#setLocationEnabledForUser(boolean" ]
  }, {
    "name" : "public void setAutomotiveGnssSuspended(boolean suspended)",
    "returnType" : "void",
    "comment" : "\n     * Set whether GNSS requests are suspended on the automotive device.\n     *\n     * For devices where GNSS prevents the system from going into a low power state, GNSS should\n     * be suspended right before going into the lower power state and resumed right after the device\n     * wakes up.\n     *\n     * This method disables GNSS and should only be used for power management use cases such as\n     * suspend-to-RAM or suspend-to-disk.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean isAutomotiveGnssSuspended()",
    "returnType" : "boolean",
    "comment" : "\n     * Return whether GNSS requests are suspended on the automotive device.\n     *\n     * @return true if GNSS requests are suspended and false if they aren't.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public Location getLastLocation()",
    "returnType" : "Location",
    "comment" : "\n     * Gets the last known location from the fused provider, or null if there is no last known\n     * location. The returned location may be quite old in some circumstances, so the age of the\n     * location should always be checked.\n     *\n     * @return the last known location, or null if not available\n     *\n     * @throws SecurityException if no suitable location permission is present\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public Location getLastKnownLocation(@NonNull String provider)",
    "returnType" : "Location",
    "comment" : "\n     * Gets the last known location from the given provider, or null if there is no last known\n     * location. The returned location may be quite old in some circumstances, so the age of the\n     * location should always be checked.\n     *\n     * <p>This will never activate sensors to compute a new location, and will only ever return a\n     * cached location.\n     *\n     * <p>See also {@link #getCurrentLocation(String, CancellationSignal, Executor, Consumer)} which\n     * will always attempt to return a current location, but will potentially use additional power\n     * in the course of the attempt as compared to this method.\n     *\n     * @param provider a provider listed by {@link #getAllProviders()}\n     *\n     * @return the last known location for the given provider, or null if not available\n     *\n     * @throws SecurityException if no suitable permission is present\n     * @throws IllegalArgumentException if provider is null or doesn't exist\n     ",
    "links" : [ "#getAllProviders()", "#getCurrentLocation(String" ]
  }, {
    "name" : "public Location getLastKnownLocation(@NonNull String provider, @NonNull LastLocationRequest lastLocationRequest)",
    "returnType" : "Location",
    "comment" : "\n     * Gets the last known location from the given provider, or null if there is no last known\n     * location.\n     *\n     * <p>See {@link LastLocationRequest} documentation for an explanation of various request\n     * parameters and how they can affect the returned location.\n     *\n     * <p>See {@link #getLastKnownLocation(String)} for more detail on how this method works.\n     *\n     * @param provider            a provider listed by {@link #getAllProviders()}\n     * @param lastLocationRequest the last location request containing location parameters\n     *\n     * @return the last known location for the given provider, or null if not available\n     *\n     * @throws SecurityException if no suitable permission is present\n     * @throws IllegalArgumentException if provider is null or doesn't exist\n     * @throws IllegalArgumentException if lastLocationRequest is null\n     *\n     * @hide\n     ",
    "links" : [ "android.location.LastLocationRequest", "#getAllProviders()", "#getLastKnownLocation(String)" ]
  }, {
    "name" : "public void getCurrentLocation(@NonNull String provider, @Nullable CancellationSignal cancellationSignal, @NonNull @CallbackExecutor Executor executor, @NonNull Consumer<Location> consumer)",
    "returnType" : "void",
    "comment" : "\n     * Asynchronously returns a single current location fix from the given provider.\n     *\n     * <p>See\n     * {@link #getCurrentLocation(String, LocationRequest, CancellationSignal, Executor, Consumer)}\n     * for more information.\n     *\n     * @param provider           a provider listed by {@link #getAllProviders()}\n     * @param cancellationSignal an optional signal that allows for cancelling this call\n     * @param executor           the callback will take place on this {@link Executor}\n     * @param consumer           the callback invoked with either a {@link Location} or null\n     *\n     * @throws IllegalArgumentException if provider is null or doesn't exist\n     * @throws IllegalArgumentException if executor is null\n     * @throws IllegalArgumentException if consumer is null\n     * @throws SecurityException        if no suitable permission is present\n     ",
    "links" : [ "#getAllProviders()", "android.annotation.CallbackExecutor", "android.location.Location", "#getCurrentLocation(String" ]
  }, {
    "name" : "public void getCurrentLocation(@NonNull LocationRequest locationRequest, @Nullable CancellationSignal cancellationSignal, @NonNull @CallbackExecutor Executor executor, @NonNull Consumer<Location> consumer)",
    "returnType" : "void",
    "comment" : "\n     * Asynchronously returns a single current location fix from the given provider based on the\n     * given {@link LocationRequest}.\n     *\n     * <p>See\n     * {@link #getCurrentLocation(String, LocationRequest, CancellationSignal, Executor, Consumer)}\n     * for more information.\n     *\n     * @param locationRequest    the location request containing location parameters\n     * @param cancellationSignal an optional signal that allows for cancelling this call\n     * @param executor           the callback will take place on this {@link Executor}\n     * @param consumer           the callback invoked with either a {@link Location} or null\n     *\n     * @throws IllegalArgumentException if provider is null or doesn't exist\n     * @throws IllegalArgumentException if executor is null\n     * @throws IllegalArgumentException if consumer is null\n     * @throws SecurityException        if no suitable permission is present\n     * @hide\n     * @deprecated Use\n     * {@link #getCurrentLocation(String, LocationRequest, CancellationSignal, Executor, Consumer)}\n     * instead.\n     ",
    "links" : [ "android.location.LocationRequest", "android.annotation.CallbackExecutor", "android.location.Location", "#getCurrentLocation(String" ]
  }, {
    "name" : "public void getCurrentLocation(@NonNull String provider, @NonNull LocationRequest locationRequest, @Nullable CancellationSignal cancellationSignal, @NonNull @CallbackExecutor Executor executor, @NonNull Consumer<Location> consumer)",
    "returnType" : "void",
    "comment" : "\n     * Asynchronously returns a single current location fix from the given provider based on the\n     * given {@link LocationRequest}. This may activate sensors in order to compute a new location,\n     * unlike {@link #getLastKnownLocation(String)}, which will only return a cached fix if\n     * available. The given callback will be invoked once and only once, either with a valid\n     * location or with a null location if the provider was unable to generate a valid location.\n     *\n     * <p>A client may supply an optional {@link CancellationSignal}. If this is used to cancel the\n     * operation, no callback should be expected after the cancellation.\n     *\n     * <p>This method may return locations from the very recent past (on the order of several\n     * seconds), but will never return older locations (for example, several minutes old or older).\n     * Clients may rely upon the guarantee that if this method returns a location, it will represent\n     * the best estimation of the location of the device in the present moment.\n     *\n     * <p>Clients calling this method from the background may notice that the method fails to\n     * determine a valid location fix more often than while in the foreground. Background\n     * applications may be throttled in their location accesses to some degree.\n     *\n     * The given location request may be used to provide hints on how a fresh location is computed\n     * if necessary. In particular {@link LocationRequest#getDurationMillis()} can be used to\n     * provide maximum duration allowed before failing. The system will always cap the maximum\n     * amount of time a request for current location may run to some reasonable value (less than a\n     * minute for example) before the request is failed.\n     *\n     * @param provider           a provider listed by {@link #getAllProviders()}\n     * @param locationRequest    the location request containing location parameters\n     * @param cancellationSignal an optional signal that allows for cancelling this call\n     * @param executor           the callback will take place on this {@link Executor}\n     * @param consumer           the callback invoked with either a {@link Location} or null\n     *\n     * @throws IllegalArgumentException if provider is null or doesn't exist\n     * @throws IllegalArgumentException if executor is null\n     * @throws IllegalArgumentException if consumer is null\n     * @throws SecurityException        if no suitable permission is present\n     ",
    "links" : [ "#getAllProviders()", "#getLastKnownLocation(String)", "android.os.CancellationSignal", "android.location.LocationRequest", "android.annotation.CallbackExecutor", "android.location.Location", "android.location.LocationRequest#getDurationMillis()" ]
  }, {
    "name" : "public void requestSingleUpdate(@NonNull String provider, @NonNull LocationListener listener, @Nullable Looper looper)",
    "returnType" : "void",
    "comment" : "\n     * Register for a single location update using the named provider and a callback.\n     *\n     * <p>See {@link #requestLocationUpdates(String, long, float, LocationListener, Looper)} for\n     * more detail on how to use this method.\n     *\n     * @param provider a provider listed by {@link #getAllProviders()}\n     * @param listener the listener to receive location updates\n     * @param looper   the looper handling listener callbacks, or null to use the looper of the\n     *                 calling thread\n     *\n     * @throws IllegalArgumentException if provider is null or doesn't exist\n     * @throws IllegalArgumentException if listener is null\n     * @throws SecurityException        if no suitable permission is present\n     * @deprecated Use {@link #getCurrentLocation(String, CancellationSignal, Executor, Consumer)}\n     * instead as it does not carry a risk of extreme battery drain.\n     ",
    "links" : [ "#getAllProviders()", "#requestLocationUpdates(String", "#getCurrentLocation(String" ]
  }, {
    "name" : "public void requestSingleUpdate(@NonNull Criteria criteria, @NonNull LocationListener listener, @Nullable Looper looper)",
    "returnType" : "void",
    "comment" : "\n     * Register for a single location update using a Criteria and a callback.\n     *\n     * <p>Note: Since Android KitKat, Criteria requests will always result in using the\n     * {@link #FUSED_PROVIDER}.\n     *\n     * <p>See {@link #requestLocationUpdates(long, float, Criteria, PendingIntent)} for more detail\n     * on how to use this method.\n     *\n     * @param criteria contains parameters to choose the appropriate provider for location updates\n     * @param listener the listener to receive location updates\n     * @param looper   the looper handling listener callbacks, or null to use the looper of the\n     *                 calling thread\n     *\n     * @throws IllegalArgumentException if criteria is null\n     * @throws IllegalArgumentException if listener is null\n     * @throws SecurityException        if no suitable permission is present\n     * @deprecated Use {@link #getCurrentLocation(String, CancellationSignal, Executor, Consumer)}\n     * instead as it does not carry a risk of extreme battery drain.\n     ",
    "links" : [ "#FUSED_PROVIDER", "#requestLocationUpdates(long", "#getCurrentLocation(String" ]
  }, {
    "name" : "public void requestSingleUpdate(@NonNull String provider, @NonNull PendingIntent pendingIntent)",
    "returnType" : "void",
    "comment" : "\n     * Register for a single location update using a named provider and pending intent.\n     *\n     * <p>See {@link #requestLocationUpdates(long, float, Criteria, PendingIntent)} for more detail\n     * on how to use this method.\n     *\n     * @param provider      a provider listed by {@link #getAllProviders()}\n     * @param pendingIntent the pending intent to send location updates\n     *\n     * @throws IllegalArgumentException if provider is null or doesn't exist\n     * @throws IllegalArgumentException if intent is null\n     * @throws SecurityException        if no suitable permission is present\n     * @deprecated Use {@link #getCurrentLocation(String, CancellationSignal, Executor, Consumer)}\n     * instead as it does not carry a risk of extreme battery drain.\n     ",
    "links" : [ "#getAllProviders()", "#requestLocationUpdates(long", "#getCurrentLocation(String" ]
  }, {
    "name" : "public void requestSingleUpdate(@NonNull Criteria criteria, @NonNull PendingIntent pendingIntent)",
    "returnType" : "void",
    "comment" : "\n     * Register for a single location update using a Criteria and pending intent.\n     *\n     * <p>Note: Since Android KitKat, Criteria requests will always result in using the\n     * {@link #FUSED_PROVIDER}.\n     *\n     * <p>See {@link #requestLocationUpdates(long, float, Criteria, PendingIntent)} for more detail\n     * on how to use this method.\n     *\n     * @param criteria      contains parameters to choose the appropriate provider for location\n     *                      updates\n     * @param pendingIntent the pending intent to send location updates\n     *\n     * @throws IllegalArgumentException if provider is null or doesn't exist\n     * @throws IllegalArgumentException if intent is null\n     * @throws SecurityException        if no suitable permission is present\n     * @deprecated Use {@link #getCurrentLocation(String, CancellationSignal, Executor, Consumer)}\n     * instead as it does not carry a risk of extreme battery drain.\n     ",
    "links" : [ "#FUSED_PROVIDER", "#requestLocationUpdates(long", "#getCurrentLocation(String" ]
  }, {
    "name" : "public void requestLocationUpdates(@NonNull String provider, long minTimeMs, float minDistanceM, @NonNull LocationListener listener)",
    "returnType" : "void",
    "comment" : "\n     * Register for location updates from the given provider with the given arguments, and a\n     * callback on the {@link Looper} of the calling thread.\n     *\n     * <p>See {@link #requestLocationUpdates(String, LocationRequest, Executor, LocationListener)}\n     * for more detail on how this method works.\n     *\n     * <p class=\"note\"> Prior to Jellybean, the minTime parameter was only a hint, and some location\n     * provider implementations ignored it. For Jellybean and onwards however, it is mandatory for\n     * Android compatible devices to observe both the minTime and minDistance parameters.\n     *\n     * @param provider     a provider listed by {@link #getAllProviders()}\n     * @param minTimeMs    minimum time interval between location updates in milliseconds\n     * @param minDistanceM minimum distance between location updates in meters\n     * @param listener     the listener to receive location updates\n     *\n     * @throws IllegalArgumentException if provider is null or doesn't exist\n     * @throws IllegalArgumentException if listener is null\n     * @throws RuntimeException if the calling thread has no Looper\n     * @throws SecurityException if no suitable permission is present\n     ",
    "links" : [ "#getAllProviders()", "android.os.Looper", "#requestLocationUpdates(String" ]
  }, {
    "name" : "public void requestLocationUpdates(@NonNull String provider, long minTimeMs, float minDistanceM, @NonNull LocationListener listener, @Nullable Looper looper)",
    "returnType" : "void",
    "comment" : "\n     * Register for location updates from the given provider with the given arguments, and a\n     * callback on the specified {@link Looper}.\n     *\n     * <p>See {@link #requestLocationUpdates(String, LocationRequest, Executor, LocationListener)}\n     * for more detail on how this method works.\n     *\n     * <p class=\"note\">Prior to Jellybean, the minTime parameter was only a hint, and some location\n     * provider implementations ignored it. For Jellybean and onwards however, it is mandatory for\n     * Android compatible devices to observe both the minTime and minDistance parameters.\n     *\n     * @param provider     a provider listed by {@link #getAllProviders()}\n     * @param minTimeMs    minimum time interval between location updates in milliseconds\n     * @param minDistanceM minimum distance between location updates in meters\n     * @param listener     the listener to receive location updates\n     * @param looper       the looper handling listener callbacks, or null to use the looper of the\n     *                     calling thread\n     *\n     * @throws IllegalArgumentException if provider is null or doesn't exist\n     * @throws IllegalArgumentException if listener is null\n     * @throws SecurityException if no suitable permission is present\n     ",
    "links" : [ "#getAllProviders()", "android.os.Looper", "#requestLocationUpdates(String" ]
  }, {
    "name" : "public void requestLocationUpdates(@NonNull String provider, long minTimeMs, float minDistanceM, @NonNull @CallbackExecutor Executor executor, @NonNull LocationListener listener)",
    "returnType" : "void",
    "comment" : "\n     * Register for location updates using the named provider, and a callback on\n     * the specified {@link Executor}.\n     *\n     * <p>See {@link #requestLocationUpdates(String, LocationRequest, Executor, LocationListener)}\n     * for more detail on how this method works.\n     *\n     * <p class=\"note\">Prior to Jellybean, the minTime parameter was only a hint, and some location\n     * provider implementations ignored it. For Jellybean and onwards however, it is mandatory for\n     * Android compatible devices to observe both the minTime and minDistance parameters.\n     *\n     * @param provider     a provider listed by {@link #getAllProviders()}\n     * @param minTimeMs    minimum time interval between location updates in milliseconds\n     * @param minDistanceM minimum distance between location updates in meters\n     * @param executor     the executor handling listener callbacks\n     * @param listener     the listener to receive location updates\n     *\n     * @throws IllegalArgumentException if provider is null or doesn't exist\n     * @throws IllegalArgumentException if executor is null\n     * @throws IllegalArgumentException if listener is null\n     * @throws SecurityException if no suitable permission is present\n     ",
    "links" : [ "#getAllProviders()", "#requestLocationUpdates(String", "android.annotation.CallbackExecutor" ]
  }, {
    "name" : "public void requestLocationUpdates(long minTimeMs, float minDistanceM, @NonNull Criteria criteria, @NonNull LocationListener listener, @Nullable Looper looper)",
    "returnType" : "void",
    "comment" : "\n     * Register for location updates using a provider selected through the given Criteria, and a\n     * callback on the specified {@link Looper}.\n     *\n     * <p>Note: Since Android KitKat, Criteria requests will always result in using the\n     * {@link #FUSED_PROVIDER}.\n     *\n     * <p>See {@link #requestLocationUpdates(String, LocationRequest, Executor, LocationListener)}\n     * for more detail on how this method works.\n     *\n     * @param minTimeMs minimum time interval between location updates in milliseconds\n     * @param minDistanceM minimum distance between location updates in meters\n     * @param criteria contains parameters to choose the appropriate provider for location updates\n     * @param listener the listener to receive location updates\n     *\n     * @throws IllegalArgumentException if criteria is null\n     * @throws IllegalArgumentException if listener is null\n     * @throws SecurityException if no suitable permission is present\n     *\n     * @deprecated Use\n     * {@link #requestLocationUpdates(String, long, float, LocationListener, Looper)} instead to\n     * explicitly select a provider.\n     ",
    "links" : [ "#FUSED_PROVIDER", "android.os.Looper", "#requestLocationUpdates(String" ]
  }, {
    "name" : "public void requestLocationUpdates(long minTimeMs, float minDistanceM, @NonNull Criteria criteria, @NonNull @CallbackExecutor Executor executor, @NonNull LocationListener listener)",
    "returnType" : "void",
    "comment" : "\n     * Register for location updates using a provider selected through the given Criteria, and a\n     * callback on the specified {@link Executor}.\n     *\n     * <p>Note: Since Android KitKat, Criteria requests will always result in using the\n     * {@link #FUSED_PROVIDER}.\n     *\n     * <p>See {@link #requestLocationUpdates(String, LocationRequest, Executor, LocationListener)}\n     * for more detail on how this method works.\n     *\n     * @param minTimeMs minimum time interval between location updates in milliseconds\n     * @param minDistanceM minimum distance between location updates in meters\n     * @param criteria contains parameters to choose the appropriate provider for location updates\n     * @param executor the executor handling listener callbacks\n     * @param listener the listener to receive location updates\n     *\n     * @throws IllegalArgumentException if criteria is null\n     * @throws IllegalArgumentException if executor is null\n     * @throws IllegalArgumentException if listener is null\n     * @throws SecurityException        if no suitable permission is present\n     *\n     * @deprecated Use\n     * {@link #requestLocationUpdates(String, long, float, Executor, LocationListener)} instead to\n     * explicitly select a provider.\n     ",
    "links" : [ "#FUSED_PROVIDER", "#requestLocationUpdates(String", "android.annotation.CallbackExecutor" ]
  }, {
    "name" : "public void requestLocationUpdates(@NonNull String provider, long minTimeMs, float minDistanceM, @NonNull PendingIntent pendingIntent)",
    "returnType" : "void",
    "comment" : "\n     * Register for location updates using the named provider, and callbacks delivered via the\n     * provided {@link PendingIntent}.\n     *\n     * <p>See {@link #requestLocationUpdates(String, LocationRequest, PendingIntent)} for more\n     * detail on how this method works.\n     *\n     * @param provider      a provider listed by {@link #getAllProviders()}\n     * @param minTimeMs     minimum time interval between location updates in milliseconds\n     * @param minDistanceM  minimum distance between location updates in meters\n     * @param pendingIntent the pending intent to send location updates\n     *\n     * @throws IllegalArgumentException if provider is null or doesn't exist\n     * @throws IllegalArgumentException if pendingIntent is null\n     * @throws SecurityException if no suitable permission is present\n     ",
    "links" : [ "#getAllProviders()", "#requestLocationUpdates(String", "android.app.PendingIntent" ]
  }, {
    "name" : "public void requestLocationUpdates(long minTimeMs, float minDistanceM, @NonNull Criteria criteria, @NonNull PendingIntent pendingIntent)",
    "returnType" : "void",
    "comment" : "\n     * Register for location updates using a provider selected through the given Criteria, and\n     * callbacks delivered via the provided {@link PendingIntent}.\n     *\n     * <p>Note: Since Android KitKat, Criteria requests will always result in using the\n     * {@link #FUSED_PROVIDER}.\n     *\n     * <p>See {@link #requestLocationUpdates(String, long, float, PendingIntent)} for more detail on\n     * how this method works.\n     *\n     * @param minTimeMs minimum time interval between location updates in milliseconds\n     * @param minDistanceM minimum distance between location updates in meters\n     * @param criteria contains parameters to choose the appropriate provider for location updates\n     * @param pendingIntent the pending intent to send location updates\n     *\n     * @throws IllegalArgumentException if provider is null or doesn't exist\n     * @throws IllegalArgumentException if pendingIntent is null\n     * @throws SecurityException if no suitable permission is present\n     *\n     * @deprecated Use {@link #requestLocationUpdates(String, long, float, PendingIntent)} instead\n     * to explicitly select a provider.\n     ",
    "links" : [ "#FUSED_PROVIDER", "#requestLocationUpdates(String", "android.app.PendingIntent" ]
  }, {
    "name" : "public void requestLocationUpdates(@Nullable LocationRequest locationRequest, @NonNull LocationListener listener, @Nullable Looper looper)",
    "returnType" : "void",
    "comment" : "\n     * Register for location updates using a {@link LocationRequest}, and a callback on the\n     * specified {@link Looper}.\n     *\n     * <p>The system will automatically select and enable the best provider based on the given\n     * {@link LocationRequest}. The LocationRequest can be null, in which case the system will\n     * choose default low power parameters for location updates, but this is heavily discouraged,\n     * and an explicit LocationRequest should always be provided.\n     *\n     * <p>See {@link #requestLocationUpdates(String, LocationRequest, Executor, LocationListener)}\n     * for more detail on how this method works.\n     *\n     * @param locationRequest the location request containing location parameters\n     * @param listener the listener to receive location updates\n     * @param looper the looper handling listener callbacks, or null to use the looper of the\n     *               calling thread\n     *\n     * @throws IllegalArgumentException if listener is null\n     * @throws SecurityException if no suitable permission is present\n     *\n     * @hide\n     * @deprecated Use\n     * {@link #requestLocationUpdates(String, LocationRequest, Executor, LocationListener)} instead.\n     ",
    "links" : [ "android.os.Looper", "android.location.LocationRequest", "#requestLocationUpdates(String" ]
  }, {
    "name" : "public void requestLocationUpdates(@Nullable LocationRequest locationRequest, @NonNull @CallbackExecutor Executor executor, @NonNull LocationListener listener)",
    "returnType" : "void",
    "comment" : "\n     * Register for location updates using a {@link LocationRequest}, and a callback on the\n     * specified {@link Executor}.\n     *\n     * <p>See {@link #requestLocationUpdates(String, LocationRequest, Executor, LocationListener)}\n     * for more detail on how this method works.\n     *\n     * @param locationRequest the location request containing location parameters\n     * @param executor the executor handling listener callbacks\n     * @param listener the listener to receive location updates\n     *\n     * @throws IllegalArgumentException if executor is null\n     * @throws IllegalArgumentException if listener is null\n     * @throws SecurityException if no suitable permission is present\n     *\n     * @hide\n     * @deprecated Use\n     * {@link #requestLocationUpdates(String, LocationRequest, Executor, LocationListener)} instead.\n     ",
    "links" : [ "android.location.LocationRequest", "#requestLocationUpdates(String", "android.annotation.CallbackExecutor" ]
  }, {
    "name" : "public void requestLocationUpdates(@Nullable LocationRequest locationRequest, @NonNull PendingIntent pendingIntent)",
    "returnType" : "void",
    "comment" : "\n     * Register for location updates using a {@link LocationRequest}, and callbacks delivered via\n     * the provided {@link PendingIntent}.\n     *\n     * <p>See {@link #requestLocationUpdates(String, LocationRequest, PendingIntent)} for more\n     * detail on how this method works.\n     *\n     * @param locationRequest the location request containing location parameters\n     * @param pendingIntent the pending intent to send location updates\n     *\n     * @throws IllegalArgumentException if pendingIntent is null\n     * @throws SecurityException if no suitable permission is present\n     *\n     * @hide\n     * @deprecated Use {@link #requestLocationUpdates(String, LocationRequest, PendingIntent)}\n     * instead.\n     ",
    "links" : [ "android.location.LocationRequest", "#requestLocationUpdates(String", "android.app.PendingIntent" ]
  }, {
    "name" : "public void requestLocationUpdates(@NonNull String provider, @NonNull LocationRequest locationRequest, @NonNull @CallbackExecutor Executor executor, @NonNull LocationListener listener)",
    "returnType" : "void",
    "comment" : "\n     * Register for location updates from the specified provider, using a {@link LocationRequest},\n     * and a callback on the specified {@link Executor}.\n     *\n     * <p>Only one request can be registered for each unique listener/provider pair, so any\n     * subsequent requests with the same provider and listener will overwrite all associated\n     * arguments. The same listener may be used across multiple providers with different requests\n     * for each provider.\n     *\n     * <p>It may take some time to receive the first location update depending on the conditions the\n     * device finds itself in. In order to take advantage of cached locations, application may\n     * consider using {@link #getLastKnownLocation(String)} or {@link #getCurrentLocation(String,\n     * LocationRequest, CancellationSignal, Executor, Consumer)} instead.\n     *\n     * <p>See {@link LocationRequest} documentation for an explanation of various request parameters\n     * and how they can affect the received locations.\n     *\n     * <p>If your application wants to passively observe location updates from all providers, then\n     * use the {@link #PASSIVE_PROVIDER}. This provider does not turn on or modify active location\n     * providers, so you do not need to be as careful about minimum time and minimum distance\n     * parameters. However, if your application performs heavy work on a location update (such as\n     * network activity) then you should set an explicit fastest interval on your location request\n     * in case another application enables a location provider with extremely fast updates.\n     *\n     * <p>In case the provider you have selected is disabled, location updates will cease, and a\n     * provider availability update will be sent. As soon as the provider is enabled again, another\n     * provider availability update will be sent and location updates will resume.\n     *\n     * <p>Locations returned from {@link #GPS_PROVIDER} are with respect to the primary GNSS antenna\n     * position within the device. {@link #getGnssAntennaInfos()} may be used to determine the GNSS\n     * antenna position with respect to the Android Coordinate System, and convert between them if\n     * necessary. This is generally only necessary for high accuracy applications.\n     *\n     * <p>When location callbacks are invoked, the system will hold a wakelock on your\n     * application's behalf for some period of time, but not indefinitely. If your application\n     * requires a long running wakelock within the location callback, you should acquire it\n     * yourself.\n     *\n     * <p>Spamming location requests is a drain on system resources, and the system has preventative\n     * measures in place to ensure that this behavior will never result in more locations than could\n     * be achieved with a single location request with an equivalent interval that is left in place\n     * the whole time. As part of this amelioration, applications that target Android S and above\n     * may receive cached or historical locations through their listener. These locations will never\n     * be older than the interval of the location request.\n     *\n     * <p>To unregister for location updates, use {@link #removeUpdates(LocationListener)}.\n     *\n     * @param provider a provider listed by {@link #getAllProviders()}\n     * @param locationRequest the location request containing location parameters\n     * @param executor the executor handling listener callbacks\n     * @param listener the listener to receive location updates\n     *\n     * @throws IllegalArgumentException if provider is null or doesn't exist\n     * @throws IllegalArgumentException if locationRequest is null\n     * @throws IllegalArgumentException if listener is null\n     * @throws SecurityException if no suitable permission is present\n     ",
    "links" : [ "#PASSIVE_PROVIDER", "#getAllProviders()", "#getLastKnownLocation(String)", "android.location.LocationRequest", "#getGnssAntennaInfos()", "android.annotation.CallbackExecutor", "#GPS_PROVIDER", "#removeUpdates(LocationListener)", "#getCurrentLocation(String" ]
  }, {
    "name" : "public void requestLocationUpdates(@NonNull String provider, @NonNull LocationRequest locationRequest, @NonNull PendingIntent pendingIntent)",
    "returnType" : "void",
    "comment" : "\n     * Register for location updates from the specified provider, using a {@link LocationRequest},\n     * and callbacks delivered via the provided {@link PendingIntent}.\n     *\n     * <p>The delivered pending intents will contain extras with the callback information. The keys\n     * used for the extras are {@link #KEY_LOCATION_CHANGED} and {@link #KEY_PROVIDER_ENABLED}. See\n     * the documentation for each respective extra key for information on the values.\n     *\n     * <p>To unregister for location updates, use {@link #removeUpdates(PendingIntent)}.\n     *\n     * @param provider a provider listed by {@link #getAllProviders()}\n     * @param locationRequest the location request containing location parameters\n     * @param pendingIntent the pending intent to send location updates\n     *\n     * @throws IllegalArgumentException if provider is null or doesn't exist\n     * @throws IllegalArgumentException if locationRequest is null\n     * @throws IllegalArgumentException if pendingIntent is null\n     * @throws SecurityException if no suitable permission is present\n     ",
    "links" : [ "#getAllProviders()", "android.location.LocationRequest", "#KEY_PROVIDER_ENABLED", "#removeUpdates(PendingIntent)", "android.app.PendingIntent", "#KEY_LOCATION_CHANGED" ]
  }, {
    "name" : "public boolean injectLocation(@NonNull Location location)",
    "returnType" : "boolean",
    "comment" : "\n     * Set the last known location with a new location.\n     *\n     * <p>A privileged client can inject a {@link Location} if it has a better estimate of what\n     * the recent location is.  This is especially useful when the device boots up and the GPS\n     * chipset is in the process of getting the first fix.  If the client has cached the location,\n     * it can inject the {@link Location}, so if an app requests for a {@link Location} from {@link\n     * #getLastKnownLocation(String)}, the location information is still useful before getting\n     * the first fix.\n     *\n     * @param location newly available {@link Location} object\n     * @return true if the location was injected, false otherwise\n     *\n     * @throws IllegalArgumentException if location is null\n     * @throws SecurityException if permissions are not present\n     *\n     * @hide\n     ",
    "links" : [ "#getLastKnownLocation(String)", "android.location.Location" ]
  }, {
    "name" : "public void requestFlush(@NonNull String provider, @NonNull LocationListener listener, @SuppressLint(\"ListenerLast\") int requestCode)",
    "returnType" : "void",
    "comment" : "\n     * Requests that the given provider flush any batched locations to listeners. The given listener\n     * (registered with the provider) will have {@link LocationListener#onFlushComplete(int)}\n     * invoked with the given result code after any locations that were flushed have been delivered.\n     * If {@link #removeUpdates(LocationListener)} is invoked before the flush callback is executed,\n     * then the flush callback will never be executed.\n     *\n     * @param provider    a provider listed by {@link #getAllProviders()}\n     * @param listener    a listener registered under the provider\n     * @param requestCode an arbitrary integer passed through to\n     *                    {@link LocationListener#onFlushComplete(int)}\n     *\n     * @throws IllegalArgumentException if provider is null or doesn't exist\n     * @throws IllegalArgumentException if listener is null or is not registered under the provider\n     ",
    "links" : [ "#getAllProviders()", "android.location.LocationListener#onFlushComplete(int)", "#removeUpdates(LocationListener)" ]
  }, {
    "name" : "public void requestFlush(@NonNull String provider, @NonNull PendingIntent pendingIntent, int requestCode)",
    "returnType" : "void",
    "comment" : "\n     * Requests that the given provider flush any batched locations to listeners. The given\n     * PendingIntent (registered with the provider) will be sent with {@link #KEY_FLUSH_COMPLETE}\n     * present in the extra keys, and {@code requestCode} as the corresponding value.\n     *\n     * @param provider      a provider listed by {@link #getAllProviders()}\n     * @param pendingIntent a pendingIntent registered under the provider\n     * @param requestCode   an arbitrary integer that will be passed back as the extra value for\n     *                      {@link #KEY_FLUSH_COMPLETE}\n     *\n     * @throws IllegalArgumentException if provider is null or doesn't exist\n     * @throws IllegalArgumentException if pending intent is null or is not registered under the\n     *                                  provider\n     ",
    "links" : [ "#getAllProviders()", "#KEY_FLUSH_COMPLETE" ]
  }, {
    "name" : "public void removeUpdates(@NonNull LocationListener listener)",
    "returnType" : "void",
    "comment" : "\n     * Removes all location updates for the specified {@link LocationListener}. The given listener\n     * is guaranteed not to receive any invocations that <b>happens-after</b> this method is\n     * invoked.\n     *\n     * <p>If the given listener has any batched requests, this method will not flush any incomplete\n     * location batches before stopping location updates. If you wish to flush any pending locations\n     * before stopping, you must first call {@link #requestFlush(String, LocationListener, int)} and\n     * then call this method once the flush is complete. If this method is invoked before the flush\n     * is complete, you may not receive the flushed locations.\n     *\n     * @param listener listener that no longer needs location updates\n     *\n     * @throws IllegalArgumentException if listener is null\n     ",
    "links" : [ "android.location.LocationListener", "#requestFlush(String" ]
  }, {
    "name" : "public void removeUpdates(@NonNull PendingIntent pendingIntent)",
    "returnType" : "void",
    "comment" : "\n     * Removes location updates for the specified {@link PendingIntent}. Following this call, the\n     * PendingIntent will no longer receive location updates.\n     *\n     * <p>See {@link #removeUpdates(LocationListener)} for more detail on how this method works.\n     *\n     * @param pendingIntent pending intent that no longer needs location updates\n     *\n     * @throws IllegalArgumentException if pendingIntent is null\n     ",
    "links" : [ "android.app.PendingIntent", "#removeUpdates(LocationListener)" ]
  }, {
    "name" : "public boolean hasProvider(@NonNull String provider)",
    "returnType" : "boolean",
    "comment" : "\n     * Returns true if the given location provider exists on this device, irrespective of whether\n     * it is currently enabled or not.\n     *\n     * @param provider a potential location provider\n     * @return true if the location provider exists, false otherwise\n     *\n     * @throws IllegalArgumentException if provider is null\n     ",
    "links" : [ ]
  }, {
    "name" : "public List<String> getAllProviders()",
    "returnType" : "List<String>",
    "comment" : "\n     * Returns a list of the names of all available location providers. All providers are returned,\n     * including those that are currently disabled.\n     *\n     * @return list of provider names\n     ",
    "links" : [ ]
  }, {
    "name" : "public List<String> getProviders(boolean enabledOnly)",
    "returnType" : "List<String>",
    "comment" : "\n     * Returns a list of the names of available location providers. If {@code enabledOnly} is false,\n     * this is functionally the same as {@link #getAllProviders()}.\n     *\n     * @param enabledOnly if true then only enabled providers are included\n     * @return list of provider names\n     ",
    "links" : [ "#getAllProviders()" ]
  }, {
    "name" : "public List<String> getProviders(@NonNull Criteria criteria, boolean enabledOnly)",
    "returnType" : "List<String>",
    "comment" : "\n     * Returns a list of the names of available location providers that satisfy the given criteria.\n     *\n     * @param criteria the criteria that providers must match\n     * @param enabledOnly if true then only enabled providers are included\n     * @return list of provider names\n     *\n     * @throws IllegalArgumentException if criteria is null\n     *\n     * @deprecated Criteria based APIs are deprecated, prefer to select a provider explicitly.\n     ",
    "links" : [ ]
  }, {
    "name" : "public String getBestProvider(@NonNull Criteria criteria, boolean enabledOnly)",
    "returnType" : "String",
    "comment" : "\n     * Returns the name of the provider that best meets the given criteria. Only providers that are\n     * permitted to be accessed by the caller will be returned. If several providers meet the\n     * criteria, the one with the best accuracy is returned. If no provider meets the criteria, the\n     * criteria are loosened in the following order:\n     *\n     * <ul>\n     * <li> power requirement\n     * <li> accuracy\n     * <li> bearing\n     * <li> speed\n     * <li> altitude\n     * </ul>\n     *\n     * <p> Note that the requirement on monetary cost is not removed in this process.\n     *\n     * @param criteria the criteria that need to be matched\n     * @param enabledOnly if true then only enabled providers are included\n     * @return name of the provider that best matches the criteria, or null if none match\n     *\n     * @throws IllegalArgumentException if criteria is null\n     *\n     * @deprecated Criteria based APIs are deprecated, prefer to select a provider explicitly.\n     ",
    "links" : [ ]
  }, {
    "name" : "public LocationProvider getProvider(@NonNull String provider)",
    "returnType" : "LocationProvider",
    "comment" : "\n     * Returns the information about the location provider with the given name, or null if no\n     * provider exists by that name.\n     *\n     * @param provider a provider listed by {@link #getAllProviders()}\n     * @return location provider information, or null if provider does not exist\n     *\n     * @throws IllegalArgumentException if provider is null\n     *\n     * @deprecated This method has no way to indicate that a provider's properties are unknown, and\n     * so may return incorrect results on rare occasions. Use {@link #getProviderProperties(String)}\n     * instead.\n     ",
    "links" : [ "#getAllProviders()", "#getProviderProperties(String)" ]
  }, {
    "name" : "public ProviderProperties getProviderProperties(@NonNull String provider)",
    "returnType" : "ProviderProperties",
    "comment" : "\n     * Returns the properties of the given provider, or null if the properties are currently\n     * unknown. Provider properties may change over time, although this is discouraged, and should\n     * be rare. The most common transition is when provider properties go from being unknown to\n     * known, which is most common near boot time.\n     *\n     * @param provider a provider listed by {@link #getAllProviders()}\n     * @return location provider properties, or null if properties are currently unknown\n     *\n     * @throws IllegalArgumentException if provider is null or does not exist\n     ",
    "links" : [ "#getAllProviders()" ]
  }, {
    "name" : "public boolean isProviderPackage(@NonNull String packageName)",
    "returnType" : "boolean",
    "comment" : "\n     * Returns true if the given package name matches a location provider package, and false\n     * otherwise.\n     *\n     * @hide\n     * @deprecated Prefer {@link #isProviderPackage(String, String, String)} instead.\n     ",
    "links" : [ "#isProviderPackage(String" ]
  }, {
    "name" : "public boolean isProviderPackage(@Nullable String provider, @NonNull String packageName)",
    "returnType" : "boolean",
    "comment" : "\n     * Returns true if the given provider corresponds to the given package name. If the given\n     * provider is null, this will return true if any provider corresponds to the given package\n     * name.\n     *\n     * @param provider a provider listed by {@link #getAllProviders()} or null\n     * @param packageName the package name to test if it is a provider\n     * @return true if the given arguments correspond to a provider\n     *\n     * @deprecated Use {@link #isProviderPackage(String, String, String)} instead.\n     *\n     * @hide\n     * @removed\n     ",
    "links" : [ "#getAllProviders()", "#isProviderPackage(String" ]
  }, {
    "name" : "public boolean isProviderPackage(@Nullable String provider, @NonNull String packageName, @Nullable String attributionTag)",
    "returnType" : "boolean",
    "comment" : "\n     * Returns true if the given provider corresponds to the given package name. If the given\n     * provider is null, this will return true if any provider corresponds to the given package\n     * name and/or attribution tag. If attribution tag is non-null, the provider identity must match\n     * both the given package name and attribution tag.\n     *\n     * @param provider a provider listed by {@link #getAllProviders()} or null\n     * @param packageName the package name to test if it is a provider\n     * @param attributionTag an optional attribution tag within the given package\n     * @return true if the given arguments correspond to a provider\n     * @hide\n     ",
    "links" : [ "#getAllProviders()" ]
  }, {
    "name" : "public List<String> getProviderPackages(@NonNull String provider)",
    "returnType" : "List<String>",
    "comment" : "\n     * Returns a list of packages associated with the given provider,\n     * and an empty list if no package is associated with the provider.\n     *\n     * @hide\n     * @deprecated Prefer {@link #isProviderPackage(String, String, String)} instead.\n     ",
    "links" : [ "#isProviderPackage(String" ]
  }, {
    "name" : "public boolean sendExtraCommand(@NonNull String provider, @NonNull String command, @Nullable Bundle extras)",
    "returnType" : "boolean",
    "comment" : "\n     * Sends additional commands to a location provider. Can be used to support provider specific\n     * extensions to the Location Manager API.\n     *\n     * @param provider a provider listed by {@link #getAllProviders()}\n     * @param command  name of the command to send to the provider\n     * @param extras   optional arguments for the command, or null\n     * @return true always, the return value may be ignored\n     ",
    "links" : [ "#getAllProviders()" ]
  }, {
    "name" : "public void addTestProvider(@NonNull String provider, boolean requiresNetwork, boolean requiresSatellite, boolean requiresCell, boolean hasMonetaryCost, boolean supportsAltitude, boolean supportsSpeed, boolean supportsBearing, @ProviderProperties.PowerUsage int powerUsage, @ProviderProperties.Accuracy int accuracy)",
    "returnType" : "void",
    "comment" : "\n     * Creates a test location provider and adds it to the set of active providers. This provider\n     * will replace any provider with the same name that exists prior to this call.\n     *\n     * @param provider the provider name\n     *\n     * @throws IllegalArgumentException if provider is null\n     * @throws SecurityException if {@link android.app.AppOpsManager#OPSTR_MOCK_LOCATION\n     * mock location app op} is not set to {@link android.app.AppOpsManager#MODE_ALLOWED\n     * allowed} for your app.\n     ",
    "links" : [ "android.app.AppOpsManager#OPSTR_MOCK_LOCATIONmock", "android.app.AppOpsManager#MODE_ALLOWEDallowed" ]
  }, {
    "name" : "public void addTestProvider(@NonNull String provider, @NonNull ProviderProperties properties)",
    "returnType" : "void",
    "comment" : "\n     * Creates a test location provider and adds it to the set of active providers. This provider\n     * will replace any provider with the same name that exists prior to this call.\n     *\n     * @param provider the provider name\n     *\n     * @throws IllegalArgumentException if provider is null\n     * @throws IllegalArgumentException if properties is null\n     * @throws SecurityException if {@link android.app.AppOpsManager#OPSTR_MOCK_LOCATION\n     * mock location app op} is not set to {@link android.app.AppOpsManager#MODE_ALLOWED\n     * allowed} for your app.\n     ",
    "links" : [ "android.app.AppOpsManager#OPSTR_MOCK_LOCATIONmock", "android.app.AppOpsManager#MODE_ALLOWEDallowed" ]
  }, {
    "name" : "public void addTestProvider(@NonNull String provider, @NonNull ProviderProperties properties, @NonNull Set<String> extraAttributionTags)",
    "returnType" : "void",
    "comment" : "\n     * Creates a test location provider and adds it to the set of active providers. This provider\n     * will replace any provider with the same name that exists prior to this call.\n     *\n     * @param provider the provider name\n     * @param properties the provider properties\n     * @param extraAttributionTags additional attribution tags associated with this provider\n     *\n     * @throws IllegalArgumentException if provider is null\n     * @throws IllegalArgumentException if properties is null\n     * @throws SecurityException if {@link android.app.AppOpsManager#OPSTR_MOCK_LOCATION\n     * mock location app op} is not set to {@link android.app.AppOpsManager#MODE_ALLOWED\n     * allowed} for your app.\n     ",
    "links" : [ "android.app.AppOpsManager#OPSTR_MOCK_LOCATIONmock", "android.app.AppOpsManager#MODE_ALLOWEDallowed" ]
  }, {
    "name" : "public void removeTestProvider(@NonNull String provider)",
    "returnType" : "void",
    "comment" : "\n     * Removes the test location provider with the given name or does nothing if no such test\n     * location provider exists.\n     *\n     * @param provider the provider name\n     *\n     * @throws IllegalArgumentException if provider is null\n     * @throws SecurityException if {@link android.app.AppOpsManager#OPSTR_MOCK_LOCATION\n     * mock location app op} is not set to {@link android.app.AppOpsManager#MODE_ALLOWED\n     * allowed} for your app.\n     ",
    "links" : [ "android.app.AppOpsManager#OPSTR_MOCK_LOCATIONmock", "android.app.AppOpsManager#MODE_ALLOWEDallowed" ]
  }, {
    "name" : "public void setTestProviderLocation(@NonNull String provider, @NonNull Location location)",
    "returnType" : "void",
    "comment" : "\n     * Sets a new location for the given test provider. This location will be identiable as a mock\n     * location to all clients via {@link Location#isMock()}.\n     *\n     * <p>The location object must have a minimum number of fields set to be considered valid, as\n     * per documentation on {@link Location} class.\n     *\n     * @param provider the provider name\n     * @param location the mock location\n     *\n     * @throws SecurityException if {@link android.app.AppOpsManager#OPSTR_MOCK_LOCATION\n     * mock location app op} is not set to {@link android.app.AppOpsManager#MODE_ALLOWED\n     * allowed} for your app.\n     * @throws IllegalArgumentException if the provider is null or not a test provider\n     * @throws IllegalArgumentException if the location is null or incomplete\n     ",
    "links" : [ "android.app.AppOpsManager#OPSTR_MOCK_LOCATIONmock", "android.app.AppOpsManager#MODE_ALLOWEDallowed", "android.location.Location", "android.location.Location#isMock()" ]
  }, {
    "name" : "public void clearTestProviderLocation(@NonNull String provider)",
    "returnType" : "void",
    "comment" : "\n     * Does nothing.\n     *\n     * @deprecated This method has always been a no-op, and may be removed in the future.\n     ",
    "links" : [ ]
  }, {
    "name" : "public void setTestProviderEnabled(@NonNull String provider, boolean enabled)",
    "returnType" : "void",
    "comment" : "\n     * Sets the given test provider to be enabled or disabled.\n     *\n     * @param provider the provider name\n     * @param enabled the mock enabled value\n     *\n     * @throws SecurityException if {@link android.app.AppOpsManager#OPSTR_MOCK_LOCATION\n     * mock location app op} is not set to {@link android.app.AppOpsManager#MODE_ALLOWED\n     * allowed} for your app.\n     * @throws IllegalArgumentException if provider is null or not a test provider\n     ",
    "links" : [ "android.app.AppOpsManager#OPSTR_MOCK_LOCATIONmock", "android.app.AppOpsManager#MODE_ALLOWEDallowed" ]
  }, {
    "name" : "public void clearTestProviderEnabled(@NonNull String provider)",
    "returnType" : "void",
    "comment" : "\n     * Equivalent to calling {@link #setTestProviderEnabled(String, boolean)} to disable a test\n     * provider.\n     *\n     * @deprecated Use {@link #setTestProviderEnabled(String, boolean)} instead.\n     ",
    "links" : [ "#setTestProviderEnabled(String" ]
  }, {
    "name" : "public void setTestProviderStatus(@NonNull String provider, int status, @Nullable Bundle extras, long updateTime)",
    "returnType" : "void",
    "comment" : "\n     * This method has no effect as provider status has been deprecated and is no longer supported.\n     *\n     * @deprecated This method has no effect.\n     ",
    "links" : [ ]
  }, {
    "name" : "public void clearTestProviderStatus(@NonNull String provider)",
    "returnType" : "void",
    "comment" : "\n     * This method has no effect as provider status has been deprecated and is no longer supported.\n     *\n     * @deprecated This method has no effect.\n     ",
    "links" : [ ]
  }, {
    "name" : "public void addProximityAlert(double latitude, double longitude, float radius, long expiration, @NonNull PendingIntent pendingIntent)",
    "returnType" : "void",
    "comment" : "\n     * Sets a proximity alert for the location given by the position (latitude, longitude) and the\n     * given radius.\n     *\n     * <p>When the device detects that it has entered or exited the area surrounding the location,\n     * the given PendingIntent will be fired.\n     *\n     * <p>The fired intent will have a boolean extra added with key {@link #KEY_PROXIMITY_ENTERING}.\n     * If the value is true, the device is entering the proximity region; if false, it is exiting.\n     *\n     * <p>Due to the approximate nature of position estimation, if the device passes through the\n     * given area briefly, it is possible that no Intent will be fired. Similarly, an intent could\n     * be fired if the device passes very close to the given area but does not actually enter it.\n     *\n     * <p>Before API version 17, this method could be used with\n     * {@link android.Manifest.permission#ACCESS_FINE_LOCATION} or\n     * {@link android.Manifest.permission#ACCESS_COARSE_LOCATION}. From API version 17 and onwards,\n     * this method requires {@link android.Manifest.permission#ACCESS_FINE_LOCATION} permission.\n     *\n     * @param latitude      the latitude of the central point of the alert region\n     * @param longitude     the longitude of the central point of the alert region\n     * @param radius        the radius of the central point of the alert region in meters\n     * @param expiration    expiration realtime for this proximity alert in milliseconds, or -1 to\n     *                      indicate no expiration\n     * @param pendingIntent a {@link PendingIntent} that will sent when entry to or exit from the\n     *                      alert region is detected\n     * @throws SecurityException if {@link android.Manifest.permission#ACCESS_FINE_LOCATION}\n     *                           permission is not present\n     ",
    "links" : [ "android.Manifest.permission#ACCESS_COARSE_LOCATION", "android.Manifest.permission#ACCESS_FINE_LOCATION", "#KEY_PROXIMITY_ENTERING", "android.app.PendingIntent" ]
  }, {
    "name" : "public void removeProximityAlert(@NonNull PendingIntent intent)",
    "returnType" : "void",
    "comment" : "\n     * Removes the proximity alert with the given PendingIntent.\n     *\n     * <p>Before API version 17, this method could be used with\n     * {@link android.Manifest.permission#ACCESS_FINE_LOCATION} or\n     * {@link android.Manifest.permission#ACCESS_COARSE_LOCATION}.\n     * From API version 17 and onwards, this method requires\n     * {@link android.Manifest.permission#ACCESS_FINE_LOCATION} permission.\n     *\n     * @param intent the PendingIntent that no longer needs to be notified of\n     * proximity alerts\n     *\n     * @throws IllegalArgumentException if intent is null\n     * @throws SecurityException if {@link android.Manifest.permission#ACCESS_FINE_LOCATION}\n     * permission is not present\n     ",
    "links" : [ "android.Manifest.permission#ACCESS_COARSE_LOCATION", "android.Manifest.permission#ACCESS_FINE_LOCATION" ]
  }, {
    "name" : "public GnssCapabilities getGnssCapabilities()",
    "returnType" : "GnssCapabilities",
    "comment" : "\n     * Returns the supported capabilities of the GNSS chipset.\n     ",
    "links" : [ ]
  }, {
    "name" : "public int getGnssYearOfHardware()",
    "returnType" : "int",
    "comment" : "\n     * Returns the model year of the GNSS hardware and software build, or 0 if the model year\n     * is before 2016.\n     ",
    "links" : [ ]
  }, {
    "name" : "public String getGnssHardwareModelName()",
    "returnType" : "String",
    "comment" : "\n     * Returns the model name (including vendor and hardware/software version) of the GNSS hardware\n     * driver, or null if this information is not available.\n     *\n     * <p>No device-specific serial number or ID is returned from this API.\n     ",
    "links" : [ ]
  }, {
    "name" : "public List<GnssAntennaInfo> getGnssAntennaInfos()",
    "returnType" : "List<GnssAntennaInfo>",
    "comment" : "\n     * Returns the current list of GNSS antenna infos, or null if unknown or unsupported.\n     *\n     * @see #getGnssCapabilities()\n     ",
    "links" : [ ]
  }, {
    "name" : "public GpsStatus getGpsStatus(@Nullable GpsStatus status)",
    "returnType" : "GpsStatus",
    "comment" : "\n     * Retrieves information about the current status of the GPS engine. This should only be called\n     * from within the {@link GpsStatus.Listener#onGpsStatusChanged} callback to ensure that the\n     * data is copied atomically.\n     *\n     * The caller may either pass in an existing {@link GpsStatus} object to be overwritten, or pass\n     * null to create a new {@link GpsStatus} object.\n     *\n     * @param status object containing GPS status details, or null.\n     * @return status object containing updated GPS status.\n     *\n     * @deprecated GpsStatus APIs are deprecated, use {@link GnssStatus} APIs instead. No longer\n     * supported in apps targeting S and above.\n     ",
    "links" : [ "android.location.GpsStatus", "GpsStatus.Listener#onGpsStatusChanged", "android.location.GnssStatus" ]
  }, {
    "name" : "public boolean addGpsStatusListener(GpsStatus.Listener listener)",
    "returnType" : "boolean",
    "comment" : "\n     * Adds a GPS status listener.\n     *\n     * @param listener GPS status listener object to register\n     * @return true if the listener was successfully added\n     * @throws SecurityException if the ACCESS_FINE_LOCATION permission is not present\n     *\n     * @deprecated Use {@link #registerGnssStatusCallback(GnssStatus.Callback, Handler)} or {@link\n     * #registerGnssStatusCallback(Executor, GnssStatus.Callback)} instead.\n     ",
    "links" : [ "#registerGnssStatusCallback(GnssStatus.Callback", "#registerGnssStatusCallback(Executor" ]
  }, {
    "name" : "public void removeGpsStatusListener(GpsStatus.Listener listener)",
    "returnType" : "void",
    "comment" : "\n     * Removes a GPS status listener.\n     *\n     * @param listener GPS status listener object to remove\n     *\n     * @deprecated use {@link #unregisterGnssStatusCallback(GnssStatus.Callback)} instead. No longer\n     * supported in apps targeting S and above.\n     ",
    "links" : [ "#unregisterGnssStatusCallback(GnssStatus.Callback)" ]
  }, {
    "name" : "public boolean registerGnssStatusCallback(@NonNull GnssStatus.Callback callback)",
    "returnType" : "boolean",
    "comment" : "\n     * Registers a GNSS status callback. This method must be called from a {@link Looper} thread,\n     * and callbacks will occur on that looper.\n     *\n     * <p>See {@link #registerGnssStatusCallback(Executor, GnssStatus.Callback)} for more detail on\n     * how this method works.\n     *\n     * @param callback the callback to register\n     * @return {@code true} always\n     *\n     * @throws SecurityException if the ACCESS_FINE_LOCATION permission is not present\n     *\n     * @deprecated Use {@link #registerGnssStatusCallback(GnssStatus.Callback, Handler)} or {@link\n     * #registerGnssStatusCallback(Executor, GnssStatus.Callback)} instead.\n     ",
    "links" : [ "#registerGnssStatusCallback(GnssStatus.Callback", "android.os.Looper", "#registerGnssStatusCallback(Executor" ]
  }, {
    "name" : "public boolean registerGnssStatusCallback(@NonNull GnssStatus.Callback callback, @Nullable Handler handler)",
    "returnType" : "boolean",
    "comment" : "\n     * Registers a GNSS status callback.\n     *\n     * <p>See {@link #registerGnssStatusCallback(Executor, GnssStatus.Callback)} for more detail on\n     * how this method works.\n     *\n     * @param callback the callback to register\n     * @param handler  the handler the callback runs on\n     * @return {@code true} always\n     *\n     * @throws IllegalArgumentException if callback is null\n     * @throws SecurityException if the ACCESS_FINE_LOCATION permission is not present\n     ",
    "links" : [ "#registerGnssStatusCallback(Executor" ]
  }, {
    "name" : "public boolean registerGnssStatusCallback(@NonNull @CallbackExecutor Executor executor, @NonNull GnssStatus.Callback callback)",
    "returnType" : "boolean",
    "comment" : "\n     * Registers a GNSS status callback. GNSS status information will only be received while the\n     * {@link #GPS_PROVIDER} is enabled, and while the client app is in the foreground.\n     *\n     * @param executor the executor that the callback runs on\n     * @param callback the callback to register\n     * @return {@code true} always\n     *\n     * @throws IllegalArgumentException if executor is null\n     * @throws IllegalArgumentException if callback is null\n     * @throws SecurityException if the ACCESS_FINE_LOCATION permission is not present\n     ",
    "links" : [ "#GPS_PROVIDER" ]
  }, {
    "name" : "public void unregisterGnssStatusCallback(@NonNull GnssStatus.Callback callback)",
    "returnType" : "void",
    "comment" : "\n     * Removes a GNSS status callback.\n     *\n     * @param callback GNSS status callback object to remove\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean addNmeaListener(@NonNull GpsStatus.NmeaListener listener)",
    "returnType" : "boolean",
    "comment" : "\n     * No-op method to keep backward-compatibility.\n     *\n     * @deprecated Use {@link #addNmeaListener(OnNmeaMessageListener, Handler)} or {@link\n     * #addNmeaListener(Executor, OnNmeaMessageListener)} instead.\n     ",
    "links" : [ "#addNmeaListener(Executor", "#addNmeaListener(OnNmeaMessageListener" ]
  }, {
    "name" : "public void removeNmeaListener(@NonNull GpsStatus.NmeaListener listener)",
    "returnType" : "void",
    "comment" : "\n     * No-op method to keep backward-compatibility.\n     *\n     * @deprecated Use {@link #removeNmeaListener(OnNmeaMessageListener)} instead.\n     ",
    "links" : [ "#removeNmeaListener(OnNmeaMessageListener)" ]
  }, {
    "name" : "public boolean addNmeaListener(@NonNull OnNmeaMessageListener listener)",
    "returnType" : "boolean",
    "comment" : "\n     * Adds an NMEA listener.\n     *\n     * <p>See {@link #addNmeaListener(Executor, OnNmeaMessageListener)} for more detail on how this\n     * method works.\n     *\n     * @param listener the listener to register\n     * @return {@code true} always\n     *\n     * @throws SecurityException if the ACCESS_FINE_LOCATION permission is not present\n     * @deprecated Use {@link #addNmeaListener(OnNmeaMessageListener, Handler)} or {@link\n     * #addNmeaListener(Executor, OnNmeaMessageListener)} instead.\n     ",
    "links" : [ "#addNmeaListener(Executor", "#addNmeaListener(OnNmeaMessageListener" ]
  }, {
    "name" : "public boolean addNmeaListener(@NonNull OnNmeaMessageListener listener, @Nullable Handler handler)",
    "returnType" : "boolean",
    "comment" : "\n     * Adds an NMEA listener.\n     *\n     * <p>See {@link #addNmeaListener(Executor, OnNmeaMessageListener)} for more detail on how this\n     * method works.\n     *\n     * @param listener the listener to register\n     * @param handler  the handler that the listener runs on\n     * @return {@code true} always\n     *\n     * @throws IllegalArgumentException if listener is null\n     * @throws SecurityException if the ACCESS_FINE_LOCATION permission is not present\n     ",
    "links" : [ "#addNmeaListener(Executor" ]
  }, {
    "name" : "public boolean addNmeaListener(@NonNull @CallbackExecutor Executor executor, @NonNull OnNmeaMessageListener listener)",
    "returnType" : "boolean",
    "comment" : "\n     * Adds an NMEA listener. GNSS NMEA information will only be received while the\n     * {@link #GPS_PROVIDER} is enabled, and while the client app is in the foreground.\n     *\n     * @param listener the listener to register\n     * @param executor the executor that the listener runs on\n     * @return {@code true} always\n     *\n     * @throws IllegalArgumentException if executor is null\n     * @throws IllegalArgumentException if listener is null\n     * @throws SecurityException if the ACCESS_FINE_LOCATION permission is not present\n     ",
    "links" : [ "#GPS_PROVIDER" ]
  }, {
    "name" : "public void removeNmeaListener(@NonNull OnNmeaMessageListener listener)",
    "returnType" : "void",
    "comment" : "\n     * Removes an NMEA listener.\n     *\n     * @param listener a {@link OnNmeaMessageListener} object to remove\n     ",
    "links" : [ "android.location.OnNmeaMessageListener" ]
  }, {
    "name" : "public boolean addGpsMeasurementListener(GpsMeasurementsEvent.Listener listener)",
    "returnType" : "boolean",
    "comment" : "\n     * No-op method to keep backward-compatibility.\n     *\n     * @hide\n     * @deprecated Use {@link #registerGnssMeasurementsCallback} instead.\n     * @removed\n     ",
    "links" : [ "#registerGnssMeasurementsCallback" ]
  }, {
    "name" : "public void removeGpsMeasurementListener(GpsMeasurementsEvent.Listener listener)",
    "returnType" : "void",
    "comment" : "\n     * No-op method to keep backward-compatibility.\n     *\n     * @hide\n     * @deprecated Use {@link #unregisterGnssMeasurementsCallback} instead.\n     * @removed\n     ",
    "links" : [ "#unregisterGnssMeasurementsCallback" ]
  }, {
    "name" : "public boolean registerGnssMeasurementsCallback(@NonNull GnssMeasurementsEvent.Callback callback)",
    "returnType" : "boolean",
    "comment" : "\n     * Registers a GNSS measurements callback which will run on a binder thread.\n     *\n     * <p>See {@link #registerGnssMeasurementsCallback(Executor, GnssMeasurementsEvent.Callback)\n     * for more detail on how this method works.\n     *\n     * @param callback a {@link GnssMeasurementsEvent.Callback} object to register\n     * @return {@code true} always\n     *\n     * @deprecated Use {@link\n     * #registerGnssMeasurementsCallback(GnssMeasurementsEvent.Callback, Handler)} or {@link\n     * #registerGnssMeasurementsCallback(Executor, GnssMeasurementsEvent.Callback)} instead.\n     ",
    "links" : [ "GnssMeasurementsEvent.Callback", "#registerGnssMeasurementsCallback(Executor", "#registerGnssMeasurementsCallback(GnssMeasurementsEvent.Callback" ]
  }, {
    "name" : "public boolean registerGnssMeasurementsCallback(@NonNull GnssMeasurementsEvent.Callback callback, @Nullable Handler handler)",
    "returnType" : "boolean",
    "comment" : "\n     * Registers a GNSS measurements callback.\n     *\n     * <p>See {@link #registerGnssMeasurementsCallback(Executor, GnssMeasurementsEvent.Callback)\n     * for more detail on how this method works.\n     *\n     * @param callback a {@link GnssMeasurementsEvent.Callback} object to register\n     * @param handler  the handler that the callback runs on\n     * @return {@code true} always\n     *\n     * @throws IllegalArgumentException if callback is null\n     * @throws SecurityException if the ACCESS_FINE_LOCATION permission is not present\n     ",
    "links" : [ "GnssMeasurementsEvent.Callback", "#registerGnssMeasurementsCallback(Executor" ]
  }, {
    "name" : "public boolean registerGnssMeasurementsCallback(@NonNull @CallbackExecutor Executor executor, @NonNull GnssMeasurementsEvent.Callback callback)",
    "returnType" : "boolean",
    "comment" : "\n     * Registers a GNSS measurements callback. GNSS measurements information will only be received\n     * while the {@link #GPS_PROVIDER} is enabled, and while the client app is in the foreground.\n     *\n     * <p>Not all GNSS chipsets support measurements updates, see {@link #getGnssCapabilities()}.\n     *\n     * <p class=\"caution\">On Android R devices that have not yet upgraded to Android R QPR1, using\n     * this API will cause unavoidable crashes in the client application when GNSS measurements\n     * are received. If a client needs to receive GNSS measurements on Android R devices that have\n     * not been upgraded to QPR1, clients are instead encouraged to use\n     * <a href=\"https://developer.android.com/reference/androidx/core/location/LocationManagerCompat#registerGnssMeasurementsCallback(android.location.LocationManager,java.util.concurrent.Executor,android.location.GnssMeasurementsEvent.Callback)\">LocationManagerCompat.registerGnssMeasurementsCallback()</a>\n     * from the compat libraries instead to avoid this crash.\n     *\n     * @param executor the executor that the callback runs on\n     * @param callback the callback to register\n     * @return {@code true} always\n     *\n     * @throws IllegalArgumentException if executor is null\n     * @throws IllegalArgumentException if callback is null\n     * @throws SecurityException if the ACCESS_FINE_LOCATION permission is not present\n     ",
    "links" : [ "#getGnssCapabilities()", "#GPS_PROVIDER" ]
  }, {
    "name" : "public boolean registerGnssMeasurementsCallback(@NonNull GnssRequest request, @NonNull @CallbackExecutor Executor executor, @NonNull GnssMeasurementsEvent.Callback callback)",
    "returnType" : "boolean",
    "comment" : "\n     * Registers a GNSS Measurement callback.\n     *\n     * @param request  the gnss measurement request containgin measurement parameters\n     * @param executor the executor that the callback runs on\n     * @param callback the callack to register\n     * @return {@code true} always\n     *\n     * @throws IllegalArgumentException if request is null\n     * @throws IllegalArgumentException if executor is null\n     * @throws IllegalArgumentException if callback is null\n     * @throws SecurityException        if the ACCESS_FINE_LOCATION permission is not present\n     * @hide\n     * @deprecated Use {@link #registerGnssMeasurementsCallback(GnssMeasurementRequest, Executor,\n     * GnssMeasurementsEvent.Callback)} instead.\n     ",
    "links" : [ "#registerGnssMeasurementsCallback(GnssMeasurementRequest" ]
  }, {
    "name" : "public boolean registerGnssMeasurementsCallback(@NonNull GnssMeasurementRequest request, @NonNull @CallbackExecutor Executor executor, @NonNull GnssMeasurementsEvent.Callback callback)",
    "returnType" : "boolean",
    "comment" : "\n     * Registers a GNSS measurement callback.\n     *\n     * @param request  extra parameters to pass to GNSS measurement provider. For example, if {@link\n     *                 GnssMeasurementRequest#isFullTracking()} is true, GNSS chipset switches off\n     *                 duty cycling.\n     * @param executor the executor that the callback runs on\n     * @param callback a {@link GnssMeasurementsEvent.Callback} object to register.\n     * @return {@code true} always if the callback was added successfully, {@code false} otherwise.\n     * @throws IllegalArgumentException if request is null\n     * @throws IllegalArgumentException if executor is null\n     * @throws IllegalArgumentException if callback is null\n     * @throws SecurityException        if the ACCESS_FINE_LOCATION permission is not present\n     ",
    "links" : [ "android.location.GnssMeasurementRequest#isFullTracking()", "GnssMeasurementsEvent.Callback" ]
  }, {
    "name" : "public void injectGnssMeasurementCorrections(@NonNull GnssMeasurementCorrections measurementCorrections)",
    "returnType" : "void",
    "comment" : "\n     * Injects GNSS measurement corrections into the GNSS chipset.\n     *\n     * @param measurementCorrections measurement corrections to be injected into the chipset\n     *\n     * @throws IllegalArgumentException if measurementCorrections is null\n     * @throws SecurityException if the ACCESS_FINE_LOCATION permission is not present\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public void unregisterGnssMeasurementsCallback(@NonNull GnssMeasurementsEvent.Callback callback)",
    "returnType" : "void",
    "comment" : "\n     * Unregisters a GPS Measurement callback.\n     *\n     * @param callback a {@link GnssMeasurementsEvent.Callback} object to remove.\n     ",
    "links" : [ "GnssMeasurementsEvent.Callback" ]
  }, {
    "name" : "public boolean registerAntennaInfoListener(@NonNull @CallbackExecutor Executor executor, @NonNull GnssAntennaInfo.Listener listener)",
    "returnType" : "boolean",
    "comment" : "\n     * Registers a GNSS antenna info listener that will receive all changes to antenna info. Use\n     * {@link #getGnssAntennaInfos()} to get current antenna info.\n     *\n     * <p>Not all GNSS chipsets support antenna info updates, see {@link #getGnssCapabilities()}. If\n     * unsupported, the listener will never be invoked.\n     *\n     * <p>Prior to Android S, this requires the {@link Manifest.permission#ACCESS_FINE_LOCATION}\n     * permission.\n     *\n     * @param executor the executor that the listener runs on\n     * @param listener the listener to register\n     * @return {@code true} always\n     *\n     * @throws IllegalArgumentException if executor is null\n     * @throws IllegalArgumentException if listener is null\n     ",
    "links" : [ "#getGnssCapabilities()", "#getGnssAntennaInfos()", "Manifest.permission#ACCESS_FINE_LOCATION" ]
  }, {
    "name" : "public void unregisterAntennaInfoListener(@NonNull GnssAntennaInfo.Listener listener)",
    "returnType" : "void",
    "comment" : "\n     * Unregisters a GNSS antenna info listener.\n     *\n     * @param listener a {@link GnssAntennaInfo.Listener} object to remove\n     ",
    "links" : [ "GnssAntennaInfo.Listener" ]
  }, {
    "name" : "public boolean addGpsNavigationMessageListener(GpsNavigationMessageEvent.Listener listener)",
    "returnType" : "boolean",
    "comment" : "\n     * No-op method to keep backward-compatibility.\n     *\n     * @hide\n     * @deprecated Use {@link #registerGnssNavigationMessageCallback} instead.\n     * @removed\n     ",
    "links" : [ "#registerGnssNavigationMessageCallback" ]
  }, {
    "name" : "public void removeGpsNavigationMessageListener(GpsNavigationMessageEvent.Listener listener)",
    "returnType" : "void",
    "comment" : "\n     * No-op method to keep backward-compatibility.\n     *\n     * @hide\n     * @deprecated Use {@link #unregisterGnssNavigationMessageCallback} instead.\n     * @removed\n     ",
    "links" : [ "#unregisterGnssNavigationMessageCallback" ]
  }, {
    "name" : "public boolean registerGnssNavigationMessageCallback(@NonNull GnssNavigationMessage.Callback callback)",
    "returnType" : "boolean",
    "comment" : "\n     * Registers a GNSS navigation message callback which will run on a binder thread.\n     *\n     * <p>See\n     * {@link #registerGnssNavigationMessageCallback(Executor, GnssNavigationMessage.Callback)} for\n     * more detail on how this method works.\n     *\n     * @param callback the callback to register\n     * @return {@code true} always\n     *\n     * @deprecated Use {@link\n     * #registerGnssNavigationMessageCallback(GnssNavigationMessage.Callback, Handler)} or {@link\n     * #registerGnssNavigationMessageCallback(Executor, GnssNavigationMessage.Callback)} instead.\n     ",
    "links" : [ "#registerGnssNavigationMessageCallback(Executor", "#registerGnssNavigationMessageCallback(GnssNavigationMessage.Callback" ]
  }, {
    "name" : "public boolean registerGnssNavigationMessageCallback(@NonNull GnssNavigationMessage.Callback callback, @Nullable Handler handler)",
    "returnType" : "boolean",
    "comment" : "\n     * Registers a GNSS navigation message callback.\n     *\n     * <p>See\n     * {@link #registerGnssNavigationMessageCallback(Executor, GnssNavigationMessage.Callback)} for\n     * more detail on how this method works.\n     *\n     * @param callback the callback to register\n     * @param handler  the handler that the callback runs on\n     * @return {@code true} always\n     *\n     * @throws IllegalArgumentException if callback is null\n     * @throws SecurityException if the ACCESS_FINE_LOCATION permission is not present\n     ",
    "links" : [ "#registerGnssNavigationMessageCallback(Executor" ]
  }, {
    "name" : "public boolean registerGnssNavigationMessageCallback(@NonNull @CallbackExecutor Executor executor, @NonNull GnssNavigationMessage.Callback callback)",
    "returnType" : "boolean",
    "comment" : "\n     * Registers a GNSS navigation message callback. GNSS navigation messages will only be received\n     * while the {@link #GPS_PROVIDER} is enabled, and while the client app is in the foreground.\n     *\n     * <p>Not all GNSS chipsets support navigation message updates, see\n     * {@link #getGnssCapabilities()}.\n     *\n     * @param executor the executor that the callback runs on\n     * @param callback the callback to register\n     * @return {@code true} always\n     *\n     * @throws IllegalArgumentException if executor is null\n     * @throws IllegalArgumentException if callback is null\n     * @throws SecurityException if the ACCESS_FINE_LOCATION permission is not present\n     ",
    "links" : [ "#getGnssCapabilities()", "#GPS_PROVIDER" ]
  }, {
    "name" : "public void unregisterGnssNavigationMessageCallback(@NonNull GnssNavigationMessage.Callback callback)",
    "returnType" : "void",
    "comment" : "\n     * Unregisters a GNSS Navigation Message callback.\n     *\n     * @param callback a {@link GnssNavigationMessage.Callback} object to remove.\n     ",
    "links" : [ "GnssNavigationMessage.Callback" ]
  }, {
    "name" : "public void addProviderRequestChangedListener(@NonNull @CallbackExecutor Executor executor, @NonNull ChangedListener listener)",
    "returnType" : "void",
    "comment" : "\n     * Adds a {@link ProviderRequest.ChangedListener} for listening to all providers'\n     * {@link ProviderRequest} changed events.\n     *\n     * @param executor the executor that the callback runs on\n     * @param listener the listener to register\n     * @hide\n     ",
    "links" : [ "android.location.provider.ProviderRequest", "ProviderRequest.ChangedListener" ]
  }, {
    "name" : "public void removeProviderRequestChangedListener(@NonNull ProviderRequest.ChangedListener listener)",
    "returnType" : "void",
    "comment" : "\n     * Removes a {@link ProviderRequest.ChangedListener} that has been added.\n     *\n     * @param listener the listener to remove.\n     * @hide\n     ",
    "links" : [ "ProviderRequest.ChangedListener" ]
  }, {
    "name" : "public int getGnssBatchSize()",
    "returnType" : "int",
    "comment" : "\n     * Returns the batch size (in number of Location objects) that are supported by the batching\n     * interface.\n     *\n     * Prior to Android S this call requires the {@link Manifest.permission#LOCATION_HARDWARE}\n     * permission.\n     *\n     * @return Maximum number of location objects that can be returned\n     * @deprecated Do not use\n     * @hide\n     ",
    "links" : [ "Manifest.permission#LOCATION_HARDWARE" ]
  }, {
    "name" : "public boolean registerGnssBatchedLocationCallback(long periodNanos, boolean wakeOnFifoFull, @NonNull BatchedLocationCallback callback, @Nullable Handler handler)",
    "returnType" : "boolean",
    "comment" : "\n     * Start hardware-batching of GNSS locations. This API is primarily used when the AP is\n     * asleep and the device can batch GNSS locations in the hardware.\n     *\n     * Note this is designed (as was the fused location interface before it) for a single user\n     * SystemApi - requests are not consolidated.  Care should be taken when the System switches\n     * users that may have different batching requests, to stop hardware batching for one user, and\n     * restart it for the next.\n     *\n     * @param periodNanos Time interval, in nanoseconds, that the GNSS locations are requested\n     *                    within the batch\n     * @param wakeOnFifoFull ignored\n     * @param callback The listener on which to return the batched locations\n     * @param handler The handler on which to process the callback\n     *\n     * @return True always\n     * @deprecated Use {@link LocationRequest.Builder#setMaxUpdateDelayMillis(long)} instead.\n     * @hide\n     ",
    "links" : [ "LocationRequest.Builder#setMaxUpdateDelayMillis(long)" ]
  }, {
    "name" : "public void flushGnssBatch()",
    "returnType" : "void",
    "comment" : "\n     * Flush the batched GNSS locations. All GNSS locations currently ready in the batch are\n     * returned via the callback sent in startGnssBatch(), and the buffer containing the batched\n     * locations is cleared.\n     *\n     * @hide\n     * @deprecated Use {@link #requestFlush(String, LocationListener, int)} or\n     *             {@link #requestFlush(String, PendingIntent, int)} instead.\n     ",
    "links" : [ "#requestFlush(String" ]
  }, {
    "name" : "public boolean unregisterGnssBatchedLocationCallback(@NonNull BatchedLocationCallback callback)",
    "returnType" : "boolean",
    "comment" : "\n     * Stop batching locations. This API is primarily used when the AP is asleep and the device can\n     * batch locations in the hardware.\n     *\n     * @param callback ignored\n     *\n     * @return True always\n     * @deprecated Use {@link LocationRequest.Builder#setMaxUpdateDelayMillis(long)} instead.\n     * @hide\n     ",
    "links" : [ "LocationRequest.Builder#setMaxUpdateDelayMillis(long)" ]
  }, {
    "name" : "public static void invalidateLocalLocationEnabledCaches()",
    "returnType" : "void",
    "comment" : "\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public static void disableLocalLocationEnabledCaches()",
    "returnType" : "void",
    "comment" : "\n     * @hide\n     ",
    "links" : [ ]
  } ],
  "methodNames" : [ " static ILocationManager getService() throws RemoteException", "public String[] getBackgroundThrottlingWhitelist()", "public String[] getIgnoreSettingsWhitelist()", "public PackageTagsList getIgnoreSettingsAllowlist()", "public PackageTagsList getAdasAllowlist()", "public String getExtraLocationControllerPackage()", "public void setExtraLocationControllerPackage(@Nullable String packageName)", "public void setExtraLocationControllerPackageEnabled(boolean enabled)", "public boolean isExtraLocationControllerPackageEnabled()", "public void setLocationControllerExtraPackage(String packageName)", "public void setLocationControllerExtraPackageEnabled(boolean enabled)", "public boolean isLocationEnabled()", "public boolean isLocationEnabledForUser(@NonNull UserHandle userHandle)", "public void setLocationEnabledForUser(boolean enabled, @NonNull UserHandle userHandle)", "public boolean isAdasGnssLocationEnabled()", "public void setAdasGnssLocationEnabled(boolean enabled)", "public boolean isProviderEnabled(@NonNull String provider)", "public boolean isProviderEnabledForUser(@NonNull String provider, @NonNull UserHandle userHandle)", "public boolean setProviderEnabledForUser(@NonNull String provider, boolean enabled, @NonNull UserHandle userHandle)", "public void setAutomotiveGnssSuspended(boolean suspended)", "public boolean isAutomotiveGnssSuspended()", "public Location getLastLocation()", "public Location getLastKnownLocation(@NonNull String provider)", "public Location getLastKnownLocation(@NonNull String provider, @NonNull LastLocationRequest lastLocationRequest)", "public void getCurrentLocation(@NonNull String provider, @Nullable CancellationSignal cancellationSignal, @NonNull @CallbackExecutor Executor executor, @NonNull Consumer<Location> consumer)", "public void getCurrentLocation(@NonNull LocationRequest locationRequest, @Nullable CancellationSignal cancellationSignal, @NonNull @CallbackExecutor Executor executor, @NonNull Consumer<Location> consumer)", "public void getCurrentLocation(@NonNull String provider, @NonNull LocationRequest locationRequest, @Nullable CancellationSignal cancellationSignal, @NonNull @CallbackExecutor Executor executor, @NonNull Consumer<Location> consumer)", "public void requestSingleUpdate(@NonNull String provider, @NonNull LocationListener listener, @Nullable Looper looper)", "public void requestSingleUpdate(@NonNull Criteria criteria, @NonNull LocationListener listener, @Nullable Looper looper)", "public void requestSingleUpdate(@NonNull String provider, @NonNull PendingIntent pendingIntent)", "public void requestSingleUpdate(@NonNull Criteria criteria, @NonNull PendingIntent pendingIntent)", "public void requestLocationUpdates(@NonNull String provider, long minTimeMs, float minDistanceM, @NonNull LocationListener listener)", "public void requestLocationUpdates(@NonNull String provider, long minTimeMs, float minDistanceM, @NonNull LocationListener listener, @Nullable Looper looper)", "public void requestLocationUpdates(@NonNull String provider, long minTimeMs, float minDistanceM, @NonNull @CallbackExecutor Executor executor, @NonNull LocationListener listener)", "public void requestLocationUpdates(long minTimeMs, float minDistanceM, @NonNull Criteria criteria, @NonNull LocationListener listener, @Nullable Looper looper)", "public void requestLocationUpdates(long minTimeMs, float minDistanceM, @NonNull Criteria criteria, @NonNull @CallbackExecutor Executor executor, @NonNull LocationListener listener)", "public void requestLocationUpdates(@NonNull String provider, long minTimeMs, float minDistanceM, @NonNull PendingIntent pendingIntent)", "public void requestLocationUpdates(long minTimeMs, float minDistanceM, @NonNull Criteria criteria, @NonNull PendingIntent pendingIntent)", "public void requestLocationUpdates(@Nullable LocationRequest locationRequest, @NonNull LocationListener listener, @Nullable Looper looper)", "public void requestLocationUpdates(@Nullable LocationRequest locationRequest, @NonNull @CallbackExecutor Executor executor, @NonNull LocationListener listener)", "public void requestLocationUpdates(@Nullable LocationRequest locationRequest, @NonNull PendingIntent pendingIntent)", "public void requestLocationUpdates(@NonNull String provider, @NonNull LocationRequest locationRequest, @NonNull @CallbackExecutor Executor executor, @NonNull LocationListener listener)", "public void requestLocationUpdates(@NonNull String provider, @NonNull LocationRequest locationRequest, @NonNull PendingIntent pendingIntent)", "public boolean injectLocation(@NonNull Location location)", "public void requestFlush(@NonNull String provider, @NonNull LocationListener listener, @SuppressLint(\"ListenerLast\") int requestCode)", "public void requestFlush(@NonNull String provider, @NonNull PendingIntent pendingIntent, int requestCode)", "public void removeUpdates(@NonNull LocationListener listener)", "public void removeUpdates(@NonNull PendingIntent pendingIntent)", "public boolean hasProvider(@NonNull String provider)", "public List<String> getAllProviders()", "public List<String> getProviders(boolean enabledOnly)", "public List<String> getProviders(@NonNull Criteria criteria, boolean enabledOnly)", "public String getBestProvider(@NonNull Criteria criteria, boolean enabledOnly)", "public LocationProvider getProvider(@NonNull String provider)", "public ProviderProperties getProviderProperties(@NonNull String provider)", "public boolean isProviderPackage(@NonNull String packageName)", "public boolean isProviderPackage(@Nullable String provider, @NonNull String packageName)", "public boolean isProviderPackage(@Nullable String provider, @NonNull String packageName, @Nullable String attributionTag)", "public List<String> getProviderPackages(@NonNull String provider)", "public boolean sendExtraCommand(@NonNull String provider, @NonNull String command, @Nullable Bundle extras)", "public void addTestProvider(@NonNull String provider, boolean requiresNetwork, boolean requiresSatellite, boolean requiresCell, boolean hasMonetaryCost, boolean supportsAltitude, boolean supportsSpeed, boolean supportsBearing, @ProviderProperties.PowerUsage int powerUsage, @ProviderProperties.Accuracy int accuracy)", "public void addTestProvider(@NonNull String provider, @NonNull ProviderProperties properties)", "public void addTestProvider(@NonNull String provider, @NonNull ProviderProperties properties, @NonNull Set<String> extraAttributionTags)", "public void removeTestProvider(@NonNull String provider)", "public void setTestProviderLocation(@NonNull String provider, @NonNull Location location)", "public void clearTestProviderLocation(@NonNull String provider)", "public void setTestProviderEnabled(@NonNull String provider, boolean enabled)", "public void clearTestProviderEnabled(@NonNull String provider)", "public void setTestProviderStatus(@NonNull String provider, int status, @Nullable Bundle extras, long updateTime)", "public void clearTestProviderStatus(@NonNull String provider)", "public void addProximityAlert(double latitude, double longitude, float radius, long expiration, @NonNull PendingIntent pendingIntent)", "public void removeProximityAlert(@NonNull PendingIntent intent)", "public GnssCapabilities getGnssCapabilities()", "public int getGnssYearOfHardware()", "public String getGnssHardwareModelName()", "public List<GnssAntennaInfo> getGnssAntennaInfos()", "public GpsStatus getGpsStatus(@Nullable GpsStatus status)", "public boolean addGpsStatusListener(GpsStatus.Listener listener)", "public void removeGpsStatusListener(GpsStatus.Listener listener)", "public boolean registerGnssStatusCallback(@NonNull GnssStatus.Callback callback)", "public boolean registerGnssStatusCallback(@NonNull GnssStatus.Callback callback, @Nullable Handler handler)", "public boolean registerGnssStatusCallback(@NonNull @CallbackExecutor Executor executor, @NonNull GnssStatus.Callback callback)", "public void unregisterGnssStatusCallback(@NonNull GnssStatus.Callback callback)", "public boolean addNmeaListener(@NonNull GpsStatus.NmeaListener listener)", "public void removeNmeaListener(@NonNull GpsStatus.NmeaListener listener)", "public boolean addNmeaListener(@NonNull OnNmeaMessageListener listener)", "public boolean addNmeaListener(@NonNull OnNmeaMessageListener listener, @Nullable Handler handler)", "public boolean addNmeaListener(@NonNull @CallbackExecutor Executor executor, @NonNull OnNmeaMessageListener listener)", "public void removeNmeaListener(@NonNull OnNmeaMessageListener listener)", "public boolean addGpsMeasurementListener(GpsMeasurementsEvent.Listener listener)", "public void removeGpsMeasurementListener(GpsMeasurementsEvent.Listener listener)", "public boolean registerGnssMeasurementsCallback(@NonNull GnssMeasurementsEvent.Callback callback)", "public boolean registerGnssMeasurementsCallback(@NonNull GnssMeasurementsEvent.Callback callback, @Nullable Handler handler)", "public boolean registerGnssMeasurementsCallback(@NonNull @CallbackExecutor Executor executor, @NonNull GnssMeasurementsEvent.Callback callback)", "public boolean registerGnssMeasurementsCallback(@NonNull GnssRequest request, @NonNull @CallbackExecutor Executor executor, @NonNull GnssMeasurementsEvent.Callback callback)", "public boolean registerGnssMeasurementsCallback(@NonNull GnssMeasurementRequest request, @NonNull @CallbackExecutor Executor executor, @NonNull GnssMeasurementsEvent.Callback callback)", "public void injectGnssMeasurementCorrections(@NonNull GnssMeasurementCorrections measurementCorrections)", "public void unregisterGnssMeasurementsCallback(@NonNull GnssMeasurementsEvent.Callback callback)", "public boolean registerAntennaInfoListener(@NonNull @CallbackExecutor Executor executor, @NonNull GnssAntennaInfo.Listener listener)", "public void unregisterAntennaInfoListener(@NonNull GnssAntennaInfo.Listener listener)", "public boolean addGpsNavigationMessageListener(GpsNavigationMessageEvent.Listener listener)", "public void removeGpsNavigationMessageListener(GpsNavigationMessageEvent.Listener listener)", "public boolean registerGnssNavigationMessageCallback(@NonNull GnssNavigationMessage.Callback callback)", "public boolean registerGnssNavigationMessageCallback(@NonNull GnssNavigationMessage.Callback callback, @Nullable Handler handler)", "public boolean registerGnssNavigationMessageCallback(@NonNull @CallbackExecutor Executor executor, @NonNull GnssNavigationMessage.Callback callback)", "public void unregisterGnssNavigationMessageCallback(@NonNull GnssNavigationMessage.Callback callback)", "public void addProviderRequestChangedListener(@NonNull @CallbackExecutor Executor executor, @NonNull ChangedListener listener)", "public void removeProviderRequestChangedListener(@NonNull ProviderRequest.ChangedListener listener)", "public int getGnssBatchSize()", "public boolean registerGnssBatchedLocationCallback(long periodNanos, boolean wakeOnFifoFull, @NonNull BatchedLocationCallback callback, @Nullable Handler handler)", "public void flushGnssBatch()", "public boolean unregisterGnssBatchedLocationCallback(@NonNull BatchedLocationCallback callback)", "public static void invalidateLocalLocationEnabledCaches()", "public static void disableLocalLocationEnabledCaches()" ],
  "variableNames" : [ "BLOCK_IMMUTABLE_PENDING_INTENTS", "BLOCK_PENDING_INTENT_SYSTEM_API_USAGE", "DELIVER_HISTORICAL_LOCATIONS", "GET_PROVIDER_SECURITY_EXCEPTIONS", "BLOCK_UNTARGETED_PENDING_INTENTS", "BLOCK_INCOMPLETE_LOCATIONS", "BLOCK_GPS_STATUS_USAGE", "NETWORK_PROVIDER", "GPS_PROVIDER", "GPS_HARDWARE_PROVIDER", "PASSIVE_PROVIDER", "FUSED_PROVIDER", "KEY_PROXIMITY_ENTERING", "KEY_STATUS_CHANGED", "KEY_PROVIDER_ENABLED", "KEY_LOCATION_CHANGED", "KEY_LOCATIONS", "KEY_FLUSH_COMPLETE", "PROVIDERS_CHANGED_ACTION", "EXTRA_PROVIDER_NAME", "EXTRA_PROVIDER_ENABLED", "MODE_CHANGED_ACTION", "EXTRA_LOCATION_ENABLED", "ACTION_ADAS_GNSS_ENABLED_CHANGED", "EXTRA_ADAS_GNSS_ENABLED", "HIGH_POWER_REQUEST_CHANGE_ACTION", "ACTION_GNSS_CAPABILITIES_CHANGED", "EXTRA_GNSS_CAPABILITIES", "SETTINGS_FOOTER_DISPLAYED_ACTION", "METADATA_SETTINGS_FOOTER_STRING", "METADATA_SETTINGS_FOOTER_HTML", "MAX_SINGLE_LOCATION_TIMEOUT_MS", "CACHE_KEY_LOCATION_ENABLED_PROPERTY", "sLocationEnabledCache", "sLocationListeners", "mContext", "mService" ]
}