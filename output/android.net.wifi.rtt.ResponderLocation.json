{
  "filePath" : "/home/maryam/clearblue/files/android-source-30/android/net/wifi/rtt/ResponderLocation.java",
  "packageName" : "android.net.wifi.rtt",
  "className" : "ResponderLocation",
  "comment" : "\n * ResponderLocation is both a Location Configuration Information (LCI) decoder and a Location Civic\n * Report (LCR) decoder for information received from a Wi-Fi Access Point (AP) during Wi-Fi RTT\n * ranging process.\n *\n * <p>This is based on the IEEE P802.11-REVmc/D8.0 spec section 9.4.2.22, under Measurement Report\n * Element. Subelement location data-fields parsed from separate input LCI and LCR Information\n * Elements are unified in this class.</p>\n *\n * <p>Note: The information provided by this class is broadcast by a responder (usually an Access\n * Point), and passed on as-is. There is no guarantee this information is accurate or correct, and\n * as a result developers should carefully consider how this information should be used and provide\n * corresponding advice to users.</p>\n ",
  "variables" : [ {
    "name" : "BYTE_MASK",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "LSB_IN_BYTE",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "MSB_IN_BYTE",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "MIN_BUFFER_SIZE",
    "type" : "int",
    "comment" : " length of LEAD_LCI_ELEMENT_BYTES",
    "links" : [ ]
  }, {
    "name" : "MAX_BUFFER_SIZE",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "MEASUREMENT_TOKEN_AUTONOMOUS",
    "type" : "byte",
    "comment" : " Information Element (IE) fields",
    "links" : [ ]
  }, {
    "name" : "MEASUREMENT_REPORT_MODE",
    "type" : "byte",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "MEASUREMENT_TYPE_LCI",
    "type" : "byte",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "MEASUREMENT_TYPE_LCR",
    "type" : "byte",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "SUBELEMENT_LCI",
    "type" : "byte",
    "comment" : " LCI Subelement IDs",
    "links" : [ ]
  }, {
    "name" : "SUBELEMENT_Z",
    "type" : "byte",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "SUBELEMENT_USAGE",
    "type" : "byte",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "SUBELEMENT_BSSID_LIST",
    "type" : "byte",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "SUBELEMENT_LCI_LENGTH",
    "type" : "int",
    "comment" : " LCI Subelement Lengths",
    "links" : [ ]
  }, {
    "name" : "SUBELEMENT_Z_LENGTH",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "SUBELEMENT_USAGE_LENGTH1",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "SUBELEMENT_USAGE_LENGTH3",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "SUBELEMENT_BSSID_LIST_MIN_BUFFER_LENGTH",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "LEAD_LCI_ELEMENT_BYTES",
    "type" : "byte[]",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "SUBELEMENT_LCI_BIT_FIELD_LENGTHS",
    "type" : "int[]",
    "comment" : " The LCI subelement bit-field lengths are described in Figure 9-214 of the REVmc spec and\n    represented here as a an array of integers ",
    "links" : [ ]
  }, {
    "name" : "LATLNG_FRACTION_BITS",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "LATLNG_UNCERTAINTY_BASE",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "ALTITUDE_FRACTION_BITS",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "ALTITUDE_UNCERTAINTY_BASE",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "LAT_ABS_LIMIT",
    "type" : "double",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "LNG_ABS_LIMIT",
    "type" : "double",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "UNCERTAINTY_UNDEFINED",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "SUBELEMENT_LCI_LAT_UNCERTAINTY_INDEX",
    "type" : "int",
    "comment" : " Subelement LCI fields indices",
    "links" : [ ]
  }, {
    "name" : "SUBELEMENT_LCI_LAT_INDEX",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "SUBELEMENT_LCI_LNG_UNCERTAINTY_INDEX",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "SUBELEMENT_LCI_LNG_INDEX",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "SUBELEMENT_LCI_ALT_TYPE_INDEX",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "SUBELEMENT_LCI_ALT_UNCERTAINTY_INDEX",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "SUBELEMENT_LCI_ALT_INDEX",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "SUBELEMENT_LCI_DATUM_INDEX",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "SUBELEMENT_LCI_REGLOC_AGREEMENT_INDEX",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "SUBELEMENT_LCI_REGLOC_DSE_INDEX",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "SUBELEMENT_LCI_DEPENDENT_STA_INDEX",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "SUBELEMENT_LCI_VERSION_INDEX",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "ALTITUDE_UNDEFINED",
    "type" : "int",
    "comment" : "\n     * Altitude is not defined for the Responder.\n     * The altitude and altitude uncertainty should not be used: see section 2.4 of IETF RFC 6225.\n     ",
    "links" : [ ]
  }, {
    "name" : "ALTITUDE_METERS",
    "type" : "int",
    "comment" : " Responder Altitude is measured in meters.  ",
    "links" : [ ]
  }, {
    "name" : "ALTITUDE_FLOORS",
    "type" : "int",
    "comment" : " Responder Altitude is measured in floors. ",
    "links" : [ ]
  }, {
    "name" : "DATUM_UNDEFINED",
    "type" : "int",
    "comment" : " Datum is not defined. ",
    "links" : [ ]
  }, {
    "name" : "DATUM_WGS84",
    "type" : "int",
    "comment" : " Datum used is WGS84. ",
    "links" : [ ]
  }, {
    "name" : "DATUM_NAD83_NAV88",
    "type" : "int",
    "comment" : " Datum used is NAD83 NAV88. ",
    "links" : [ ]
  }, {
    "name" : "DATUM_NAD83_MLLW",
    "type" : "int",
    "comment" : " Datum used is NAD83 MLLW. ",
    "links" : [ ]
  }, {
    "name" : "LCI_VERSION_1",
    "type" : "int",
    "comment" : " Version of the LCI protocol is 1.0, the only defined protocol at this time. ",
    "links" : [ ]
  }, {
    "name" : "LOCATION_PROVIDER",
    "type" : "String",
    "comment" : " Provider/Source of the location ",
    "links" : [ ]
  }, {
    "name" : "SUBELEMENT_Z_BIT_FIELD_LENGTHS",
    "type" : "int[]",
    "comment" : " LCI Subelement Z constants",
    "links" : [ ]
  }, {
    "name" : "Z_FLOOR_NUMBER_FRACTION_BITS",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "Z_FLOOR_HEIGHT_FRACTION_BITS",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "Z_MAX_HEIGHT_UNCERTAINTY_FACTOR",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "SUBELEMENT_Z_LAT_EXPECTED_TO_MOVE_INDEX",
    "type" : "int",
    "comment" : " LCI Subelement Z fields indices",
    "links" : [ ]
  }, {
    "name" : "SUBELEMENT_Z_FLOOR_NUMBER_INDEX",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "SUBELEMENT_Z_HEIGHT_ABOVE_FLOOR_INDEX",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "SUBELEMENT_Z_HEIGHT_ABOVE_FLOOR_UNCERTAINTY_INDEX",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "SUBELEMENT_USAGE_MASK_RETRANSMIT",
    "type" : "int",
    "comment" : " LCI Subelement Usage Rules constants",
    "links" : [ ]
  }, {
    "name" : "SUBELEMENT_USAGE_MASK_RETENTION_EXPIRES",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "SUBELEMENT_USAGE_MASK_STA_LOCATION_POLICY",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "SUBELEMENT_USAGE_PARAMS_INDEX",
    "type" : "int",
    "comment" : " 8 bits",
    "links" : [ ]
  }, {
    "name" : "SUBELEMENT_BSSID_MAX_INDICATOR_INDEX",
    "type" : "int",
    "comment" : " LCI Subelement BSSID List",
    "links" : [ ]
  }, {
    "name" : "SUBELEMENT_BSSID_LIST_INDEX",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "BYTES_IN_A_BSSID",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "LOCATION_FIXED",
    "type" : "int",
    "comment" : " Location of responder is fixed (does not move) ",
    "links" : [ ]
  }, {
    "name" : "LOCATION_VARIABLE",
    "type" : "int",
    "comment" : " Location of the responder is variable, and may move ",
    "links" : [ ]
  }, {
    "name" : "LOCATION_MOVEMENT_UNKNOWN",
    "type" : "int",
    "comment" : " Location of the responder is not known to be either fixed or variable. ",
    "links" : [ ]
  }, {
    "name" : "LOCATION_RESERVED",
    "type" : "int",
    "comment" : " Location of the responder status is a reserved value ",
    "links" : [ ]
  }, {
    "name" : "SUBELEMENT_LOCATION_CIVIC",
    "type" : "byte",
    "comment" : " LCR Subelement IDs",
    "links" : [ ]
  }, {
    "name" : "SUBELEMENT_MAP_IMAGE",
    "type" : "byte",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "SUBELEMENT_LOCATION_CIVIC_MIN_LENGTH",
    "type" : "int",
    "comment" : " LCR Subelement Lengths",
    "links" : [ ]
  }, {
    "name" : "SUBELEMENT_LOCATION_CIVIC_MAX_LENGTH",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "SUBELEMENT_MAP_IMAGE_URL_MAX_LENGTH",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "LEAD_LCR_ELEMENT_BYTES",
    "type" : "byte[]",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "CIVIC_COUNTRY_CODE_INDEX",
    "type" : "int",
    "comment" : " LCR Location Civic Subelement",
    "links" : [ ]
  }, {
    "name" : "CIVIC_TLV_LIST_INDEX",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "SUBELEMENT_IMAGE_MAP_TYPE_INDEX",
    "type" : "int",
    "comment" : " LCR Map Image Subelement field indexes.",
    "links" : [ ]
  }, {
    "name" : "MAP_TYPE_URL_DEFINED",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "SUPPORTED_IMAGE_FILE_EXTENSIONS",
    "type" : "String[]",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mIsValid",
    "type" : "boolean",
    "comment" : " General LCI and LCR state",
    "links" : [ ]
  }, {
    "name" : "mIsLciValid",
    "type" : "boolean",
    "comment" : "\n      These members are not final because we are not sure if the corresponding subelement will be\n      present until after the parsing process. However, the default value should be set as listed.\n    ",
    "links" : [ ]
  }, {
    "name" : "mIsZValid",
    "type" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mIsUsageValid",
    "type" : "boolean",
    "comment" : " By default this is assumed true",
    "links" : [ ]
  }, {
    "name" : "mIsBssidListValid",
    "type" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mIsLocationCivicValid",
    "type" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mIsMapImageValid",
    "type" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mLatitudeUncertainty",
    "type" : "double",
    "comment" : " LCI Subelement LCI state",
    "links" : [ ]
  }, {
    "name" : "mLatitude",
    "type" : "double",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mLongitudeUncertainty",
    "type" : "double",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mLongitude",
    "type" : "double",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mAltitudeType",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mAltitudeUncertainty",
    "type" : "double",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mAltitude",
    "type" : "double",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mDatum",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mLciRegisteredLocationAgreement",
    "type" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mLciRegisteredLocationDse",
    "type" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mLciDependentStation",
    "type" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mLciVersion",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mExpectedToMove",
    "type" : "int",
    "comment" : " LCI Subelement Z state",
    "links" : [ ]
  }, {
    "name" : "mFloorNumber",
    "type" : "double",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mHeightAboveFloorMeters",
    "type" : "double",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mHeightAboveFloorUncertaintyMeters",
    "type" : "double",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mUsageRetransmit",
    "type" : "boolean",
    "comment" : " LCI Subelement Usage Rights state",
    "links" : [ ]
  }, {
    "name" : "mUsageRetentionExpires",
    "type" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mUsageExtraInfoOnAssociation",
    "type" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mBssidList",
    "type" : "ArrayList<MacAddress>",
    "comment" : " LCI Subelement BSSID List state",
    "links" : [ ]
  }, {
    "name" : "mCivicLocationCountryCode",
    "type" : "String",
    "comment" : " LCR Subelement Location Civic state",
    "links" : [ ]
  }, {
    "name" : "mCivicLocationString",
    "type" : "String",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mCivicLocation",
    "type" : "CivicLocation",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mMapImageType",
    "type" : "int",
    "comment" : " LCR Subelement Map Image state",
    "links" : [ ]
  }, {
    "name" : "mMapImageUri",
    "type" : "Uri",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "CREATOR",
    "type" : "Creator<ResponderLocation>",
    "comment" : "",
    "links" : [ ]
  } ],
  "methods" : [ {
    "name" : "public int describeContents()",
    "returnType" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public void writeToParcel(Parcel parcel, int flags)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private boolean parseInformationElementBuffer(int ieType, byte[] buffer, byte[] expectedLeadBytes)",
    "returnType" : "boolean",
    "comment" : "\n     * Test if the Information Element (IE) is in the correct format, and then parse its Subelements\n     * based on their type, and setting state in this object when present.\n     *\n     * @return a boolean indicating the success of the parsing function\n     ",
    "links" : [ ]
  }, {
    "name" : "private boolean parseSubelementLci(byte[] buffer)",
    "returnType" : "boolean",
    "comment" : "\n     * Parse the LCI Sub-Element in the LCI Information Element (IE).\n     *\n     * @param buffer a buffer containing the subelement\n     * @return boolean true indicates success\n     ",
    "links" : [ ]
  }, {
    "name" : "private double decodeLciLatLng(long[] fields, int[] bitFieldSizes, int offset, double limit)",
    "returnType" : "double",
    "comment" : "\n     * Decode the floating point value of an encoded lat or lng in the LCI subelement field.\n     *\n     * @param fields        the array of field data represented as longs\n     * @param bitFieldSizes the lengths of each field\n     * @param offset        the offset of the field being decoded\n     * @param limit the maximum absolute value (note: different for lat vs lng)\n     * @return the floating point value of the lat or lng\n     ",
    "links" : [ ]
  }, {
    "name" : "private double decodeLciLatLngUncertainty(long encodedValue)",
    "returnType" : "double",
    "comment" : "\n     * Coverts an encoded Lat/Lng uncertainty into a number of degrees.\n     *\n     * @param encodedValue the encoded uncertainty\n     * @return the value in degrees\n     ",
    "links" : [ ]
  }, {
    "name" : "private double decodeLciAltUncertainty(long encodedValue)",
    "returnType" : "double",
    "comment" : "\n     * Converts an encoded Alt uncertainty into a number of degrees.\n     *\n     * @param encodedValue the encoded uncertainty\n     * @return the value in degrees\n     ",
    "links" : [ ]
  }, {
    "name" : "private boolean parseSubelementZ(byte[] buffer)",
    "returnType" : "boolean",
    "comment" : "\n     * Parse the Z subelement of the LCI IE.\n     *\n     * @param buffer a buffer containing the subelement\n     * @return boolean true indicates success\n     ",
    "links" : [ ]
  }, {
    "name" : "private double decodeZUnsignedToSignedValue(long[] fieldValues, int[] fieldLengths, int index, int fraction)",
    "returnType" : "double",
    "comment" : "\n     * Decode a two's complement encoded value, to a signed double based on the field length.\n     *\n     * @param fieldValues the array of field values reprented as longs\n     * @param fieldLengths the array of field lengths\n     * @param index the index of the field being decoded\n     * @param fraction the number of fractional bits in the value\n     * @return the signed value represented as a double\n     ",
    "links" : [ ]
  }, {
    "name" : "private boolean parseSubelementUsage(byte[] buffer)",
    "returnType" : "boolean",
    "comment" : "\n     * Parse Subelement Usage Rights\n     ",
    "links" : [ ]
  }, {
    "name" : "private boolean parseSubelementBssidList(byte[] buffer)",
    "returnType" : "boolean",
    "comment" : "\n     * Parse the BSSID List Subelement of the LCI IE.\n     *\n     * @param buffer a buffer containing the subelement\n     * @return boolean true indicates success\n     ",
    "links" : [ ]
  }, {
    "name" : "private boolean parseSubelementLocationCivic(byte[] buffer)",
    "returnType" : "boolean",
    "comment" : "\n     * Parse the Location Civic subelement in the LCR IE.\n     *\n     * @param buffer a buffer containing the subelement\n     * @return boolean true indicates success\n     ",
    "links" : [ ]
  }, {
    "name" : "private boolean parseSubelementMapImage(byte[] buffer)",
    "returnType" : "boolean",
    "comment" : "\n     * Parse the Map Image subelement in the LCR IE.\n     *\n     * @param buffer a buffer containing the subelement\n     * @return boolean true indicates success\n     ",
    "links" : [ ]
  }, {
    "name" : "private String imageTypeToMime(int imageTypeCode, String imageUrl)",
    "returnType" : "String",
    "comment" : "\n     * Convert an image type code to a Mime type\n     *\n     * @param imageTypeCode encoded as an integer\n     * @return the mime type of the image file\n     ",
    "links" : [ ]
  }, {
    "name" : "private long[] getFieldData(byte[] buffer, int[] bitFieldSizes)",
    "returnType" : "long[]",
    "comment" : "\n     * Converts a byte array containing fields of variable size, into an array of longs where the\n     * field boundaries are defined in a constant int array passed as an argument.\n     *\n     * @param buffer        the byte array containing all the fields\n     * @param bitFieldSizes the int array defining the size of each field\n     ",
    "links" : [ ]
  }, {
    "name" : "private int getBitAtBitOffsetInByteArray(byte[] buffer, int bufferBitOffset)",
    "returnType" : "int",
    "comment" : "\n     * Retrieves state of a bit at the bit-offset in a byte array, where the offset represents the\n     * bytes in contiguous data with each value in big endian order.\n     *\n     * @param buffer          the data buffer of bytes containing all the fields\n     * @param bufferBitOffset the bit offset into the entire buffer\n     * @return a zero or one value, representing the state of that bit.\n     ",
    "links" : [ ]
  }, {
    "name" : "private void swapEndianByteByByte(byte[] buffer)",
    "returnType" : "void",
    "comment" : "\n     * Reverses the order of the bits in each byte of a byte array.\n     *\n     * @param buffer the array containing each byte that will be reversed\n     ",
    "links" : [ ]
  }, {
    "name" : "private void setLciSubelementDefaults()",
    "returnType" : "void",
    "comment" : "\n     * Sets the LCI subelement fields to the default undefined values.\n     ",
    "links" : [ ]
  }, {
    "name" : "private void setZaxisSubelementDefaults()",
    "returnType" : "void",
    "comment" : "\n     * Sets the Z subelement fields to the default values when undefined.\n     ",
    "links" : [ ]
  }, {
    "name" : "private void setUsageSubelementDefaults()",
    "returnType" : "void",
    "comment" : "\n     * Sets the Usage Policy subelement fields to the default undefined values.\n     ",
    "links" : [ ]
  }, {
    "name" : "private void setBssidListSubelementDefaults()",
    "returnType" : "void",
    "comment" : "\n     * Sets the BSSID List subelement fields to the default values when undefined.\n     ",
    "links" : [ ]
  }, {
    "name" : "public void setCivicLocationSubelementDefaults()",
    "returnType" : "void",
    "comment" : "\n     * Sets the LCR Civic Location subelement field to the default undefined value.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "private void setMapImageSubelementDefaults()",
    "returnType" : "void",
    "comment" : "\n     * Sets the LCR Map Image subelement field to the default values when undefined.\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean equals(Object obj)",
    "returnType" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public int hashCode()",
    "returnType" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public boolean isValid()",
    "returnType" : "boolean",
    "comment" : "\n     * @return true if the ResponderLocation object is valid and contains useful information\n     * relevant to the location of the Responder. If this is ever false, this object will not be\n     * available to developers, and have a null value.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean isLciSubelementValid()",
    "returnType" : "boolean",
    "comment" : "\n     * @return true if the LCI subelement (containing Latitude, Longitude and Altitude) is valid.\n     *\n     * <p> This method tells us if the responder has provided its Location Configuration\n     * Information (LCI) directly, and is useful when an external database of responder locations\n     * is not available</p>\n     *\n     * <p>If isLciSubelementValid() returns true, all the LCI values provided by the corresponding\n     * getter methods will have been set as described by the responder, or else if false, they\n     * should not be used and will throw an IllegalStateException.</p>\n     ",
    "links" : [ ]
  }, {
    "name" : "public double getLatitudeUncertainty()",
    "returnType" : "double",
    "comment" : "\n     * @return the latitude uncertainty in degrees.\n     * <p>\n     * Only valid if {@link #isLciSubelementValid()} returns true, or will throw an exception.\n     * </p>\n     * <p> An unknown uncertainty is indicated by 0.</p>\n     ",
    "links" : [ "#isLciSubelementValid()" ]
  }, {
    "name" : "public double getLatitude()",
    "returnType" : "double",
    "comment" : "\n     * @return the latitude in degrees\n     * <p>\n     * Only valid if {@link #isLciSubelementValid()} returns true, or will throw an exception.\n     ",
    "links" : [ "#isLciSubelementValid()" ]
  }, {
    "name" : "public double getLongitudeUncertainty()",
    "returnType" : "double",
    "comment" : "\n     * @return the Longitude uncertainty in degrees.\n     * <p>\n     * Only valid if {@link #isLciSubelementValid()} returns true, or will throw an exception.\n     * </p>\n     * <p> An unknown uncertainty is indicated by 0.</p>\n     ",
    "links" : [ "#isLciSubelementValid()" ]
  }, {
    "name" : "public double getLongitude()",
    "returnType" : "double",
    "comment" : "\n     * @return the Longitude in degrees..\n     * <p>\n     * Only valid if {@link #isLciSubelementValid()} returns true, or will throw an exception.\n     ",
    "links" : [ "#isLciSubelementValid()" ]
  }, {
    "name" : "public int getAltitudeType()",
    "returnType" : "int",
    "comment" : "\n     * @return the Altitude type.\n     * <p>\n     * Only valid if {@link #isLciSubelementValid()} returns true, or will throw an exception.\n     ",
    "links" : [ "#isLciSubelementValid()" ]
  }, {
    "name" : "public double getAltitudeUncertainty()",
    "returnType" : "double",
    "comment" : "\n     * @return the Altitude uncertainty in meters.\n     * <p>\n     * Only valid if {@link #isLciSubelementValid()} returns true, or will throw an exception.\n     * </p>\n     * <p>An unknown uncertainty is indicated by 0.</p>\n     ",
    "links" : [ "#isLciSubelementValid()" ]
  }, {
    "name" : "public double getAltitude()",
    "returnType" : "double",
    "comment" : "\n     * @return the Altitude in units defined by the altitude type.\n     * <p>\n     * Only valid if {@link #isLciSubelementValid()} returns true, or will throw an exception.\n     ",
    "links" : [ "#isLciSubelementValid()" ]
  }, {
    "name" : "public int getDatum()",
    "returnType" : "int",
    "comment" : "\n     * @return the Datum used for the LCI positioning information.\n     * <p>\n     * Only valid if {@link #isLciSubelementValid()} returns true, or will throw an exception.\n     ",
    "links" : [ "#isLciSubelementValid()" ]
  }, {
    "name" : "public boolean getRegisteredLocationAgreementIndication()",
    "returnType" : "boolean",
    "comment" : "\n     * @return true if the station is operating within a national policy area or an international\n     * agreement area near a national border, otherwise false\n     * (see 802.11REVmc Section 11.12.3 - Registered STA Operation).\n     * <p>\n     * Only valid if {@link #isLciSubelementValid()} returns true, or will throw an exception.\n     ",
    "links" : [ "#isLciSubelementValid()" ]
  }, {
    "name" : "public boolean getRegisteredLocationDseIndication()",
    "returnType" : "boolean",
    "comment" : "\n     * @return true indicating this is an enabling station, enabling the operation of nearby STAs\n     * with Dynamic Station Enablement (DSE), otherwise false.\n     * (see 802.11REVmc Section 11.12.3 - Registered STA Operation).\n     * <p>\n     * Only valid if {@link #isLciSubelementValid()} returns true, or will throw an exception.\n     *\n     * @hide\n     ",
    "links" : [ "#isLciSubelementValid()" ]
  }, {
    "name" : "public boolean getDependentStationIndication()",
    "returnType" : "boolean",
    "comment" : "\n     * @return true indicating this is a dependent station that is operating with the enablement of\n     * an enabling station whose LCI is being reported, otherwise false.\n     * (see 802.11REVmc Section 11.12.3 - Registered STA Operation).\n     * <p>\n     * Only valid if {@link #isLciSubelementValid()} returns true, or will throw an exception.\n     *\n     * @hide\n     ",
    "links" : [ "#isLciSubelementValid()" ]
  }, {
    "name" : "public int getLciVersion()",
    "returnType" : "int",
    "comment" : "\n     * @return a value greater or equal to 1, indicating the current version number\n     * of the LCI protocol.\n     * <p>\n     * Only valid if {@link #isLciSubelementValid()} returns true, or will throw an exception.\n     ",
    "links" : [ "#isLciSubelementValid()" ]
  }, {
    "name" : "public Location toLocation()",
    "returnType" : "Location",
    "comment" : "\n     * @return the LCI location represented as a {@link Location} object (best effort).\n     * <p>\n     * Only valid if {@link #isLciSubelementValid()} returns true, or will throw an exception.\n     ",
    "links" : [ "android.location.Location", "#isLciSubelementValid()" ]
  }, {
    "name" : "public boolean isZaxisSubelementValid()",
    "returnType" : "boolean",
    "comment" : "\n     * @return if the Z subelement (containing mobility, Floor, Height above floor) is valid.\n     ",
    "links" : [ ]
  }, {
    "name" : "public int getExpectedToMove()",
    "returnType" : "int",
    "comment" : "\n     * @return an integer representing the mobility of the responder.\n     * <p>\n     * Only valid if {@link #isZaxisSubelementValid()} returns true, or will throw an exception.\n     ",
    "links" : [ "#isZaxisSubelementValid()" ]
  }, {
    "name" : "public double getFloorNumber()",
    "returnType" : "double",
    "comment" : "\n     * @return the Z sub element Floor Number.\n     * <p>\n     * Only valid if {@link #isZaxisSubelementValid()} returns true, or will throw an exception.\n     * </p>\n     * <p>Note: this number can be positive or negative, with value increments of +/- 1/16 of a\n     * floor.</p>.\n     ",
    "links" : [ "#isZaxisSubelementValid()" ]
  }, {
    "name" : "public double getHeightAboveFloorMeters()",
    "returnType" : "double",
    "comment" : "\n     * @return the Z subelement Height above the floor in meters.\n     * <p>\n     * Only valid if {@link #isZaxisSubelementValid()} returns true, or will throw an exception.\n     * </p>\n     * <p>This value can be positive or negative. </p>\n     ",
    "links" : [ "#isZaxisSubelementValid()" ]
  }, {
    "name" : "public double getHeightAboveFloorUncertaintyMeters()",
    "returnType" : "double",
    "comment" : "\n     * @return the Z subelement Height above the floor uncertainty in meters.\n     * <p>\n     * Only valid if {@link #isZaxisSubelementValid()} returns true, or will throw an exception.\n     * </p>\n     * <p>An unknown uncertainty is indicated by 0.</p>\n     ",
    "links" : [ "#isZaxisSubelementValid()" ]
  }, {
    "name" : "public boolean getRetransmitPolicyIndication()",
    "returnType" : "boolean",
    "comment" : "\n     * @return true if the location information received from the responder can be\n     * retransmitted to another device, physically separate from the one that received it.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean getRetentionExpiresIndication()",
    "returnType" : "boolean",
    "comment" : "\n     * @return true if location-data received should expire (and be deleted)\n     * by the time provided in the getRelativeExpirationTimeHours() method.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean getExtraInfoOnAssociationIndication()",
    "returnType" : "boolean",
    "comment" : "\n     * @return true if there is extra location info available on association.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public List<MacAddress> getColocatedBssids()",
    "returnType" : "List<MacAddress>",
    "comment" : "\n     * @return the Immutable list of colocated BSSIDs at the responder.\n     *\n     * <p> Will return an empty list when there are no bssids listed.\n     ",
    "links" : [ ]
  }, {
    "name" : "public Address toCivicLocationAddress()",
    "returnType" : "Address",
    "comment" : "\n     * @return the civic location represented as an {@link Address} object (best effort).\n     *\n     * <p> Will return a {@code null} when there is no Civic Location defined.\n     ",
    "links" : [ "android.location.Address" ]
  }, {
    "name" : "public SparseArray<String> toCivicLocationSparseArray()",
    "returnType" : "SparseArray<String>",
    "comment" : "\n     * @return the civic location represented as a {@link SparseArray}\n     * <p>\n     * Valid keys to access the SparseArray can be found in {@code CivicLocationKeys}.\n     * </p>\n     * <p> Will return a {@code null} when there is no Civic Location defined.\n     *\n     ",
    "links" : [ "android.util.SparseArray" ]
  }, {
    "name" : "public String getCivicLocationCountryCode()",
    "returnType" : "String",
    "comment" : "\n     * @return the civic location two upper-case ASCII character country code defined in ISO 3166.\n     *\n     * <p> Will return a {@code null} when there is no country code defined.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public String getCivicLocationElementValue(@CivicLocationKeysType int key)",
    "returnType" : "String",
    "comment" : "\n     * @return the value of the Civic Location String associated with a key.\n     *\n     * <p> Will return a {@code null} when there is no value associated with the key provided.\n     *\n     * @param key used to find a corresponding value in the Civic Location Tuple list\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public String getMapImageMimeType()",
    "returnType" : "String",
    "comment" : "\n     * @return the Map Image file Mime type, referred to by getMapImageUrl().\n     ",
    "links" : [ ]
  }, {
    "name" : "public Uri getMapImageUri()",
    "returnType" : "Uri",
    "comment" : "\n     * @return a URI referencing a map-file showing the local floor plan.\n     *\n     * <p> Will return a {@code null} when there is no URI defined.\n     ",
    "links" : [ ]
  } ],
  "variableNames" : [ "BYTE_MASK", "LSB_IN_BYTE", "MSB_IN_BYTE", "MIN_BUFFER_SIZE", "MAX_BUFFER_SIZE", "MEASUREMENT_TOKEN_AUTONOMOUS", "MEASUREMENT_REPORT_MODE", "MEASUREMENT_TYPE_LCI", "MEASUREMENT_TYPE_LCR", "SUBELEMENT_LCI", "SUBELEMENT_Z", "SUBELEMENT_USAGE", "SUBELEMENT_BSSID_LIST", "SUBELEMENT_LCI_LENGTH", "SUBELEMENT_Z_LENGTH", "SUBELEMENT_USAGE_LENGTH1", "SUBELEMENT_USAGE_LENGTH3", "SUBELEMENT_BSSID_LIST_MIN_BUFFER_LENGTH", "LEAD_LCI_ELEMENT_BYTES", "SUBELEMENT_LCI_BIT_FIELD_LENGTHS", "LATLNG_FRACTION_BITS", "LATLNG_UNCERTAINTY_BASE", "ALTITUDE_FRACTION_BITS", "ALTITUDE_UNCERTAINTY_BASE", "LAT_ABS_LIMIT", "LNG_ABS_LIMIT", "UNCERTAINTY_UNDEFINED", "SUBELEMENT_LCI_LAT_UNCERTAINTY_INDEX", "SUBELEMENT_LCI_LAT_INDEX", "SUBELEMENT_LCI_LNG_UNCERTAINTY_INDEX", "SUBELEMENT_LCI_LNG_INDEX", "SUBELEMENT_LCI_ALT_TYPE_INDEX", "SUBELEMENT_LCI_ALT_UNCERTAINTY_INDEX", "SUBELEMENT_LCI_ALT_INDEX", "SUBELEMENT_LCI_DATUM_INDEX", "SUBELEMENT_LCI_REGLOC_AGREEMENT_INDEX", "SUBELEMENT_LCI_REGLOC_DSE_INDEX", "SUBELEMENT_LCI_DEPENDENT_STA_INDEX", "SUBELEMENT_LCI_VERSION_INDEX", "ALTITUDE_UNDEFINED", "ALTITUDE_METERS", "ALTITUDE_FLOORS", "DATUM_UNDEFINED", "DATUM_WGS84", "DATUM_NAD83_NAV88", "DATUM_NAD83_MLLW", "LCI_VERSION_1", "LOCATION_PROVIDER", "SUBELEMENT_Z_BIT_FIELD_LENGTHS", "Z_FLOOR_NUMBER_FRACTION_BITS", "Z_FLOOR_HEIGHT_FRACTION_BITS", "Z_MAX_HEIGHT_UNCERTAINTY_FACTOR", "SUBELEMENT_Z_LAT_EXPECTED_TO_MOVE_INDEX", "SUBELEMENT_Z_FLOOR_NUMBER_INDEX", "SUBELEMENT_Z_HEIGHT_ABOVE_FLOOR_INDEX", "SUBELEMENT_Z_HEIGHT_ABOVE_FLOOR_UNCERTAINTY_INDEX", "SUBELEMENT_USAGE_MASK_RETRANSMIT", "SUBELEMENT_USAGE_MASK_RETENTION_EXPIRES", "SUBELEMENT_USAGE_MASK_STA_LOCATION_POLICY", "SUBELEMENT_USAGE_PARAMS_INDEX", "SUBELEMENT_BSSID_MAX_INDICATOR_INDEX", "SUBELEMENT_BSSID_LIST_INDEX", "BYTES_IN_A_BSSID", "LOCATION_FIXED", "LOCATION_VARIABLE", "LOCATION_MOVEMENT_UNKNOWN", "LOCATION_RESERVED", "SUBELEMENT_LOCATION_CIVIC", "SUBELEMENT_MAP_IMAGE", "SUBELEMENT_LOCATION_CIVIC_MIN_LENGTH", "SUBELEMENT_LOCATION_CIVIC_MAX_LENGTH", "SUBELEMENT_MAP_IMAGE_URL_MAX_LENGTH", "LEAD_LCR_ELEMENT_BYTES", "CIVIC_COUNTRY_CODE_INDEX", "CIVIC_TLV_LIST_INDEX", "SUBELEMENT_IMAGE_MAP_TYPE_INDEX", "MAP_TYPE_URL_DEFINED", "SUPPORTED_IMAGE_FILE_EXTENSIONS", "mIsValid", "mIsLciValid", "mIsZValid", "mIsUsageValid", "mIsBssidListValid", "mIsLocationCivicValid", "mIsMapImageValid", "mLatitudeUncertainty", "mLatitude", "mLongitudeUncertainty", "mLongitude", "mAltitudeType", "mAltitudeUncertainty", "mAltitude", "mDatum", "mLciRegisteredLocationAgreement", "mLciRegisteredLocationDse", "mLciDependentStation", "mLciVersion", "mExpectedToMove", "mFloorNumber", "mHeightAboveFloorMeters", "mHeightAboveFloorUncertaintyMeters", "mUsageRetransmit", "mUsageRetentionExpires", "mUsageExtraInfoOnAssociation", "mBssidList", "mCivicLocationCountryCode", "mCivicLocationString", "mCivicLocation", "mMapImageType", "mMapImageUri", "CREATOR" ],
  "methodNames" : [ "public int describeContents()", "public void writeToParcel(Parcel parcel, int flags)", "private boolean parseInformationElementBuffer(int ieType, byte[] buffer, byte[] expectedLeadBytes)", "private boolean parseSubelementLci(byte[] buffer)", "private double decodeLciLatLng(long[] fields, int[] bitFieldSizes, int offset, double limit)", "private double decodeLciLatLngUncertainty(long encodedValue)", "private double decodeLciAltUncertainty(long encodedValue)", "private boolean parseSubelementZ(byte[] buffer)", "private double decodeZUnsignedToSignedValue(long[] fieldValues, int[] fieldLengths, int index, int fraction)", "private boolean parseSubelementUsage(byte[] buffer)", "private boolean parseSubelementBssidList(byte[] buffer)", "private boolean parseSubelementLocationCivic(byte[] buffer)", "private boolean parseSubelementMapImage(byte[] buffer)", "private String imageTypeToMime(int imageTypeCode, String imageUrl)", "private long[] getFieldData(byte[] buffer, int[] bitFieldSizes)", "private int getBitAtBitOffsetInByteArray(byte[] buffer, int bufferBitOffset)", "private void swapEndianByteByByte(byte[] buffer)", "private void setLciSubelementDefaults()", "private void setZaxisSubelementDefaults()", "private void setUsageSubelementDefaults()", "private void setBssidListSubelementDefaults()", "public void setCivicLocationSubelementDefaults()", "private void setMapImageSubelementDefaults()", "public boolean equals(Object obj)", "public int hashCode()", "public boolean isValid()", "public boolean isLciSubelementValid()", "public double getLatitudeUncertainty()", "public double getLatitude()", "public double getLongitudeUncertainty()", "public double getLongitude()", "public int getAltitudeType()", "public double getAltitudeUncertainty()", "public double getAltitude()", "public int getDatum()", "public boolean getRegisteredLocationAgreementIndication()", "public boolean getRegisteredLocationDseIndication()", "public boolean getDependentStationIndication()", "public int getLciVersion()", "public Location toLocation()", "public boolean isZaxisSubelementValid()", "public int getExpectedToMove()", "public double getFloorNumber()", "public double getHeightAboveFloorMeters()", "public double getHeightAboveFloorUncertaintyMeters()", "public boolean getRetransmitPolicyIndication()", "public boolean getRetentionExpiresIndication()", "public boolean getExtraInfoOnAssociationIndication()", "public List<MacAddress> getColocatedBssids()", "public Address toCivicLocationAddress()", "public SparseArray<String> toCivicLocationSparseArray()", "public String getCivicLocationCountryCode()", "public String getCivicLocationElementValue(@CivicLocationKeysType int key)", "public String getMapImageMimeType()", "public Uri getMapImageUri()" ]
}