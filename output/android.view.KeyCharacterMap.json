{
  "filePath" : "/home/maryam/clearblue/files/android-source-35/android/view/KeyCharacterMap.java",
  "packageName" : "android.view",
  "className" : "KeyCharacterMap",
  "comment" : "\n * Describes the keys provided by a keyboard device and their associated labels.\n ",
  "links" : [ ],
  "variables" : [ {
    "name" : "BUILT_IN_KEYBOARD",
    "type" : "int",
    "comment" : "\n     * The id of the device's primary built in keyboard is always 0.\n     *\n     * @deprecated This constant should no longer be used because there is no\n     * guarantee that a device has a built-in keyboard that can be used for\n     * typing text.  There might not be a built-in keyboard, the built-in keyboard\n     * might be a {@link #NUMERIC} or {@link #SPECIAL_FUNCTION} keyboard, or there\n     * might be multiple keyboards installed including external keyboards.\n     * When interpreting key presses received from the framework, applications should\n     * use the device id specified in the {@link KeyEvent} received.\n     * When synthesizing key presses for delivery elsewhere or when translating key presses\n     * from unknown keyboards, applications should use the special {@link #VIRTUAL_KEYBOARD}\n     * device id.\n     ",
    "links" : [ "#NUMERIC", "android.view.KeyEvent", "#SPECIAL_FUNCTION", "#VIRTUAL_KEYBOARD" ]
  }, {
    "name" : "VIRTUAL_KEYBOARD",
    "type" : "int",
    "comment" : "\n     * The id of a generic virtual keyboard with a full layout that can be used to\n     * synthesize key events.  Typically used with {@link #getEvents}.\n     ",
    "links" : [ "#getEvents" ]
  }, {
    "name" : "NUMERIC",
    "type" : "int",
    "comment" : "\n     * A numeric (12-key) keyboard.\n     * <p>\n     * A numeric keyboard supports text entry using a multi-tap approach.\n     * It may be necessary to tap a key multiple times to generate the desired letter\n     * or symbol.\n     * </p><p>\n     * This type of keyboard is generally designed for thumb typing.\n     * </p>\n     ",
    "links" : [ ]
  }, {
    "name" : "PREDICTIVE",
    "type" : "int",
    "comment" : "\n     * A keyboard with all the letters, but with more than one letter per key.\n     * <p>\n     * This type of keyboard is generally designed for thumb typing.\n     * </p>\n     ",
    "links" : [ ]
  }, {
    "name" : "ALPHA",
    "type" : "int",
    "comment" : "\n     * A keyboard with all the letters, and maybe some numbers.\n     * <p>\n     * An alphabetic keyboard supports text entry directly but may have a condensed\n     * layout with a small form factor.  In contrast to a {@link #FULL full keyboard}, some\n     * symbols may only be accessible using special on-screen character pickers.\n     * In addition, to improve typing speed and accuracy, the framework provides\n     * special affordances for alphabetic keyboards such as auto-capitalization\n     * and toggled / locked shift and alt keys.\n     * </p><p>\n     * This type of keyboard is generally designed for thumb typing.\n     * </p>\n     ",
    "links" : [ "#FULL" ]
  }, {
    "name" : "FULL",
    "type" : "int",
    "comment" : "\n     * A full PC-style keyboard.\n     * <p>\n     * A full keyboard behaves like a PC keyboard.  All symbols are accessed directly\n     * by pressing keys on the keyboard without on-screen support or affordances such\n     * as auto-capitalization.\n     * </p><p>\n     * This type of keyboard is generally designed for full two hand typing.\n     * </p>\n     ",
    "links" : [ ]
  }, {
    "name" : "SPECIAL_FUNCTION",
    "type" : "int",
    "comment" : "\n     * A keyboard that is only used to control special functions rather than for typing.\n     * <p>\n     * A special function keyboard consists only of non-printing keys such as\n     * HOME and POWER that are not actually used for typing.\n     * </p>\n     ",
    "links" : [ ]
  }, {
    "name" : "HEX_INPUT",
    "type" : "char",
    "comment" : "\n     * This private-use character is used to trigger Unicode character\n     * input by hex digits.\n     ",
    "links" : [ ]
  }, {
    "name" : "PICKER_DIALOG_INPUT",
    "type" : "char",
    "comment" : "\n     * This private-use character is used to bring up a character picker for\n     * miscellaneous symbols.\n     ",
    "links" : [ ]
  }, {
    "name" : "MODIFIER_BEHAVIOR_CHORDED",
    "type" : "int",
    "comment" : "\n     * Modifier keys may be chorded with character keys.\n     *\n     * @see #getModifierBehavior()\n     ",
    "links" : [ ]
  }, {
    "name" : "MODIFIER_BEHAVIOR_CHORDED_OR_TOGGLED",
    "type" : "int",
    "comment" : "\n     * Modifier keys may be chorded with character keys or they may toggle\n     * into latched or locked states when pressed independently.\n     *\n     * @see #getModifierBehavior()\n     ",
    "links" : [ ]
  }, {
    "name" : "COMBINING_ACCENT",
    "type" : "int",
    "comment" : "\n     * This bit will be set in the return value of {@link #get(int, int)} if the\n     * key is a \"dead key.\"\n     ",
    "links" : [ "#get(int" ]
  }, {
    "name" : "COMBINING_ACCENT_MASK",
    "type" : "int",
    "comment" : "\n     * Mask the return value from {@link #get(int, int)} with this value to get\n     * a printable representation of the accent character of a \"dead key.\"\n     ",
    "links" : [ "#get(int" ]
  }, {
    "name" : "ACCENT_ACUTE",
    "type" : "int",
    "comment" : " Characters used to display placeholders for dead keys. ",
    "links" : [ ]
  }, {
    "name" : "ACCENT_BREVE",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "ACCENT_CARON",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "ACCENT_CEDILLA",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "ACCENT_CIRCUMFLEX",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "ACCENT_COMMA_ABOVE",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "ACCENT_COMMA_ABOVE_RIGHT",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "ACCENT_DOT_ABOVE",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "ACCENT_DOT_BELOW",
    "type" : "int",
    "comment" : " approximate",
    "links" : [ ]
  }, {
    "name" : "ACCENT_DOUBLE_ACUTE",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "ACCENT_GRAVE",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "ACCENT_HOOK_ABOVE",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "ACCENT_HORN",
    "type" : "int",
    "comment" : " approximate",
    "links" : [ ]
  }, {
    "name" : "ACCENT_MACRON",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "ACCENT_MACRON_BELOW",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "ACCENT_OGONEK",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "ACCENT_REVERSED_COMMA_ABOVE",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "ACCENT_RING_ABOVE",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "ACCENT_STROKE",
    "type" : "int",
    "comment" : " approximate",
    "links" : [ ]
  }, {
    "name" : "ACCENT_TILDE",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "ACCENT_TURNED_COMMA_ABOVE",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "ACCENT_UMLAUT",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "ACCENT_VERTICAL_LINE_ABOVE",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "ACCENT_VERTICAL_LINE_BELOW",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "ACCENT_APOSTROPHE",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "ACCENT_QUOTATION_MARK",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "ACCENT_GRAVE_LEGACY",
    "type" : "int",
    "comment" : " Legacy dead key display characters used in previous versions of the API.\n     * We still support these characters by mapping them to their non-legacy version. ",
    "links" : [ ]
  }, {
    "name" : "ACCENT_CIRCUMFLEX_LEGACY",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "ACCENT_TILDE_LEGACY",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "CHAR_SPACE",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "sCombiningToAccent",
    "type" : "SparseIntArray",
    "comment" : "\n     * Maps Unicode combining diacritical to display-form dead key.\n     ",
    "links" : [ ]
  }, {
    "name" : "sAccentToCombining",
    "type" : "SparseIntArray",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "sDeadKeyCache",
    "type" : "SparseIntArray",
    "comment" : "\n     * Maps combinations of (display-form) combining key and second character\n     * to combined output character.\n     * These mappings are derived from the Unicode NFC tables as needed.\n     ",
    "links" : [ ]
  }, {
    "name" : "sDeadKeyBuilder",
    "type" : "StringBuilder",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "CREATOR",
    "type" : "Parcelable.Creator<KeyCharacterMap>",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mPtr",
    "type" : "long",
    "comment" : "",
    "links" : [ ]
  } ],
  "methods" : [ {
    "name" : "private static void addCombining(int combining, int accent)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private static void addDeadKey(int accent, int c, int result)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private static native long nativeReadFromParcel(Parcel in)",
    "returnType" : "long",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private static native void nativeWriteToParcel(long ptr, Parcel out)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private static native void nativeDispose(long ptr)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private static native char nativeGetCharacter(long ptr, int keyCode, int metaState)",
    "returnType" : "char",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private static native boolean nativeGetFallbackAction(long ptr, int keyCode, int metaState, FallbackAction outFallbackAction)",
    "returnType" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private static native char nativeGetNumber(long ptr, int keyCode)",
    "returnType" : "char",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private static native char nativeGetMatch(long ptr, int keyCode, char[] chars, int metaState)",
    "returnType" : "char",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private static native char nativeGetDisplayLabel(long ptr, int keyCode)",
    "returnType" : "char",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private static native int nativeGetKeyboardType(long ptr)",
    "returnType" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private static native KeyEvent[] nativeGetEvents(long ptr, char[] chars)",
    "returnType" : "KeyEvent[]",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private static native KeyCharacterMap nativeObtainEmptyKeyCharacterMap(int deviceId)",
    "returnType" : "KeyCharacterMap",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private static native boolean nativeEquals(long ptr1, long ptr2)",
    "returnType" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private static native void nativeApplyOverlay(long ptr, String layoutDescriptor, String overlay)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private static native int nativeGetMappedKey(long ptr, int scanCode)",
    "returnType" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "protected void finalize() throws Throwable",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public static KeyCharacterMap obtainEmptyMap(int deviceId)",
    "returnType" : "KeyCharacterMap",
    "comment" : "\n     * Obtain empty key character map\n     * @param deviceId The input device ID\n     * @return The KeyCharacterMap object\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public static KeyCharacterMap load(int deviceId)",
    "returnType" : "KeyCharacterMap",
    "comment" : "\n     * Loads the key character maps for the keyboard with the specified device id.\n     *\n     * @param deviceId The device id of the keyboard.\n     * @return The associated key character map.\n     * @throws {@link UnavailableException} if the key character map\n     * could not be loaded because it was malformed or the default key character map\n     * is missing from the system.\n     ",
    "links" : [ "UnavailableException" ]
  }, {
    "name" : "public static KeyCharacterMap load(@NonNull String layoutDescriptor, @NonNull String overlay)",
    "returnType" : "KeyCharacterMap",
    "comment" : "\n     * Loads the key character map with applied KCM overlay.\n     *\n     * @param layoutDescriptor descriptor of the applied overlay KCM\n     * @param overlay          string describing the overlay KCM\n     * @return The resultant key character map.\n     * @throws {@link UnavailableException} if the key character map\n     *                could not be loaded because it was malformed or the default key character map\n     *                is missing from the system.\n     * @hide\n     ",
    "links" : [ "UnavailableException" ]
  }, {
    "name" : "private void applyOverlay(@NonNull String layoutDescriptor, @NonNull String overlay)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public int getMappedKeyOrDefault(int scanCode, int defaultKeyCode)",
    "returnType" : "int",
    "comment" : "\n     * Gets the mapped key for the provided scan code. Returns the provided default if no mapping\n     * found in the KeyCharacterMap.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public int get(int keyCode, int metaState)",
    "returnType" : "int",
    "comment" : "\n     * Gets the Unicode character generated by the specified key and meta\n     * key state combination.\n     * <p>\n     * Returns the Unicode character that the specified key would produce\n     * when the specified meta bits (see {@link MetaKeyKeyListener})\n     * were active.\n     * </p><p>\n     * Returns 0 if the key is not one that is used to type Unicode\n     * characters.\n     * </p><p>\n     * If the return value has bit {@link #COMBINING_ACCENT} set, the\n     * key is a \"dead key\" that should be combined with another to\n     * actually produce a character -- see {@link #getDeadChar} --\n     * after masking with {@link #COMBINING_ACCENT_MASK}.\n     * </p>\n     *\n     * @param keyCode The key code.\n     * @param metaState The meta key modifier state.\n     * @return The associated character or combining accent, or 0 if none.\n     ",
    "links" : [ "#COMBINING_ACCENT", "#getDeadChar", "android.text.method.MetaKeyKeyListener", "#COMBINING_ACCENT_MASK" ]
  }, {
    "name" : "public FallbackAction getFallbackAction(int keyCode, int metaState)",
    "returnType" : "FallbackAction",
    "comment" : "\n     * Gets the fallback action to perform if the application does not\n     * handle the specified key.\n     * <p>\n     * When an application does not handle a particular key, the system may\n     * translate the key to an alternate fallback key (specified in the\n     * fallback action) and dispatch it to the application.\n     * The event containing the fallback key is flagged\n     * with {@link KeyEvent#FLAG_FALLBACK}.\n     * </p>\n     *\n     * @param keyCode The key code.\n     * @param metaState The meta key modifier state.\n     * @return The fallback action, or null if none.  Remember to recycle the fallback action.\n     *\n     * @hide\n     ",
    "links" : [ "android.view.KeyEvent#FLAG_FALLBACK" ]
  }, {
    "name" : "public char getNumber(int keyCode)",
    "returnType" : "char",
    "comment" : "\n     * Gets the number or symbol associated with the key.\n     * <p>\n     * The character value is returned, not the numeric value.\n     * If the key is not a number, but is a symbol, the symbol is retuned.\n     * </p><p>\n     * This method is intended to to support dial pads and other numeric or\n     * symbolic entry on keyboards where certain keys serve dual function\n     * as alphabetic and symbolic keys.  This method returns the number\n     * or symbol associated with the key independent of whether the user\n     * has pressed the required modifier.\n     * </p><p>\n     * For example, on one particular keyboard the keys on the top QWERTY row generate\n     * numbers when ALT is pressed such that ALT-Q maps to '1'.  So for that keyboard\n     * when {@link #getNumber} is called with {@link KeyEvent#KEYCODE_Q} it returns '1'\n     * so that the user can type numbers without pressing ALT when it makes sense.\n     * </p>\n     *\n     * @param keyCode The key code.\n     * @return The associated numeric or symbolic character, or 0 if none.\n     ",
    "links" : [ "android.view.KeyEvent#KEYCODE_Q", "#getNumber" ]
  }, {
    "name" : "public char getMatch(int keyCode, char[] chars)",
    "returnType" : "char",
    "comment" : "\n     * Gets the first character in the character array that can be generated\n     * by the specified key code.\n     * <p>\n     * This is a convenience function that returns the same value as\n     * {@link #getMatch(int,char[],int) getMatch(keyCode, chars, 0)}.\n     * </p>\n     *\n     * @param keyCode The keycode.\n     * @param chars The array of matching characters to consider.\n     * @return The matching associated character, or 0 if none.\n     * @throws {@link IllegalArgumentException} if the passed array of characters is null.\n     ",
    "links" : [ "#getMatch(int", "IllegalArgumentException" ]
  }, {
    "name" : "public char getMatch(int keyCode, char[] chars, int metaState)",
    "returnType" : "char",
    "comment" : "\n     * Gets the first character in the character array that can be generated\n     * by the specified key code.  If there are multiple choices, prefers\n     * the one that would be generated with the specified meta key modifier state.\n     *\n     * @param keyCode The key code.\n     * @param chars The array of matching characters to consider.\n     * @param metaState The preferred meta key modifier state.\n     * @return The matching associated character, or 0 if none.\n     * @throws {@link IllegalArgumentException} if the passed array of characters is null.\n     ",
    "links" : [ "IllegalArgumentException" ]
  }, {
    "name" : "public char getDisplayLabel(int keyCode)",
    "returnType" : "char",
    "comment" : "\n     * Gets the primary character for this key.\n     * In other words, the label that is physically printed on it.\n     *\n     * @param keyCode The key code.\n     * @return The display label character, or 0 if none (eg. for non-printing keys).\n     ",
    "links" : [ ]
  }, {
    "name" : "public static int getDeadChar(int accent, int c)",
    "returnType" : "int",
    "comment" : "\n     * Get the character that is produced by combining the dead key producing accent\n     * with the key producing character c.\n     * For example, getDeadChar('`', 'e') returns &egrave;.\n     * getDeadChar('^', ' ') returns '^' and getDeadChar('^', '^') returns '^'.\n     *\n     * @param accent The accent character.  eg. '`'\n     * @param c The basic character.\n     * @return The combined character, or 0 if the characters cannot be combined.\n     ",
    "links" : [ ]
  }, {
    "name" : "public static int getCombiningChar(int accent)",
    "returnType" : "int",
    "comment" : "\n     * Get the combining character that corresponds with the provided accent.\n     *\n     * @param accent The accent character.  eg. '`'\n     * @return The combining character\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean getKeyData(int keyCode, KeyData results)",
    "returnType" : "boolean",
    "comment" : "\n     * Get the character conversion data for a given key code.\n     *\n     * @param keyCode The keyCode to query.\n     * @param results A {@link KeyData} instance that will be filled with the results.\n     * @return True if the key was mapped.  If the key was not mapped, results is not modified.\n     *\n     * @deprecated instead use {@link KeyCharacterMap#getDisplayLabel(int)},\n     * {@link KeyCharacterMap#getNumber(int)} or {@link KeyCharacterMap#get(int, int)}.\n     ",
    "links" : [ "android.view.KeyCharacterMap#get(int", "android.view.KeyCharacterMap#getNumber(int)", "android.view.KeyCharacterMap#getDisplayLabel(int)", "KeyData" ]
  }, {
    "name" : "public KeyEvent[] getEvents(char[] chars)",
    "returnType" : "KeyEvent[]",
    "comment" : "\n     * Get an array of KeyEvent objects that if put into the input stream\n     * could plausibly generate the provided sequence of characters.  It is\n     * not guaranteed that the sequence is the only way to generate these\n     * events or that it is optimal.\n     * <p>\n     * This function is primarily offered for instrumentation and testing purposes.\n     * It may fail to map characters to key codes.  In particular, the key character\n     * map for the {@link #BUILT_IN_KEYBOARD built-in keyboard} device id may be empty.\n     * Consider using the key character map associated with the\n     * {@link #VIRTUAL_KEYBOARD virtual keyboard} device id instead.\n     * </p><p>\n     * For robust text entry, do not use this function.  Instead construct a\n     * {@link KeyEvent} with action code {@link KeyEvent#ACTION_MULTIPLE} that contains\n     * the desired string using {@link KeyEvent#KeyEvent(long, String, int, int)}.\n     * </p>\n     *\n     * @param chars The sequence of characters to generate.\n     * @return An array of {@link KeyEvent} objects, or null if the given char array\n     *         can not be generated using the current key character map.\n     * @throws {@link IllegalArgumentException} if the passed array of characters is null.\n     ",
    "links" : [ "android.view.KeyEvent#ACTION_MULTIPLE", "android.view.KeyEvent", "#BUILT_IN_KEYBOARD", "#VIRTUAL_KEYBOARD", "android.view.KeyEvent#KeyEvent(long", "IllegalArgumentException" ]
  }, {
    "name" : "public boolean isPrintingKey(int keyCode)",
    "returnType" : "boolean",
    "comment" : "\n     * Returns true if the specified key produces a glyph.\n     *\n     * @param keyCode The key code.\n     * @return True if the key is a printing key.\n     ",
    "links" : [ ]
  }, {
    "name" : "public int getKeyboardType()",
    "returnType" : "int",
    "comment" : "\n     * Gets the keyboard type.\n     * Returns {@link #NUMERIC}, {@link #PREDICTIVE}, {@link #ALPHA}, {@link #FULL}\n     * or {@link #SPECIAL_FUNCTION}.\n     * <p>\n     * Different keyboard types have different semantics.  Refer to the documentation\n     * associated with the keyboard type constants for details.\n     * </p>\n     *\n     * @return The keyboard type.\n     ",
    "links" : [ "#NUMERIC", "#PREDICTIVE", "#SPECIAL_FUNCTION", "#ALPHA", "#FULL" ]
  }, {
    "name" : "public int getModifierBehavior()",
    "returnType" : "int",
    "comment" : "\n     * Gets a constant that describes the behavior of this keyboard's modifier keys\n     * such as {@link KeyEvent#KEYCODE_SHIFT_LEFT}.\n     * <p>\n     * Currently there are two behaviors that may be combined:\n     * </p>\n     * <ul>\n     * <li>Chorded behavior: When the modifier key is pressed together with one or more\n     * character keys, the keyboard inserts the modified keys and\n     * then resets the modifier state when the modifier key is released.</li>\n     * <li>Toggled behavior: When the modifier key is pressed and released on its own\n     * it first toggles into a latched state.  When latched, the modifier will apply\n     * to next character key that is pressed and will then reset itself to the initial state.\n     * If the modifier is already latched and the modifier key is pressed and release on\n     * its own again, then it toggles into a locked state.  When locked, the modifier will\n     * apply to all subsequent character keys that are pressed until unlocked by pressing\n     * the modifier key on its own one more time to reset it to the initial state.\n     * Toggled behavior is useful for small profile keyboards designed for thumb typing.\n     * </ul>\n     * <p>\n     * This function currently returns {@link #MODIFIER_BEHAVIOR_CHORDED} when the\n     * {@link #getKeyboardType() keyboard type} is {@link #FULL} or {@link #SPECIAL_FUNCTION} and\n     * {@link #MODIFIER_BEHAVIOR_CHORDED_OR_TOGGLED} otherwise.\n     * In the future, the function may also take into account global keyboard\n     * accessibility settings, other user preferences, or new device capabilities.\n     * </p>\n     *\n     * @return The modifier behavior for this keyboard.\n     *\n     * @see #MODIFIER_BEHAVIOR_CHORDED\n     * @see #MODIFIER_BEHAVIOR_CHORDED_OR_TOGGLED\n     ",
    "links" : [ "android.view.KeyEvent#KEYCODE_SHIFT_LEFT", "#getKeyboardType()", "#SPECIAL_FUNCTION", "#MODIFIER_BEHAVIOR_CHORDED_OR_TOGGLED", "#FULL", "#MODIFIER_BEHAVIOR_CHORDED" ]
  }, {
    "name" : "public static boolean deviceHasKey(int keyCode)",
    "returnType" : "boolean",
    "comment" : "\n     * Queries the framework about whether any physical keys exist on any currently attached input\n     * devices that are capable of producing the given key code.\n     *\n     * @param keyCode The key code to query.\n     * @return True if at least one attached keyboard supports the specified key code.\n     ",
    "links" : [ ]
  }, {
    "name" : "public static boolean[] deviceHasKeys(int[] keyCodes)",
    "returnType" : "boolean[]",
    "comment" : "\n     * Queries the framework about whether any physical keys exist on any currently attached input\n     * devices that are capable of producing the given array of key codes.\n     *\n     * @param keyCodes The array of key codes to query.\n     * @return A new array of the same size as the key codes array whose elements\n     * are set to true if at least one attached keyboard supports the corresponding key code\n     * at the same index in the key codes array.\n     ",
    "links" : [ ]
  }, {
    "name" : "public void writeToParcel(Parcel out, int flags)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public int describeContents()",
    "returnType" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public boolean equals(Object obj)",
    "returnType" : "boolean",
    "comment" : "",
    "links" : [ ]
  } ],
  "methodNames" : [ "private static void addCombining(int combining, int accent)", "private static void addDeadKey(int accent, int c, int result)", "private static native long nativeReadFromParcel(Parcel in)", "private static native void nativeWriteToParcel(long ptr, Parcel out)", "private static native void nativeDispose(long ptr)", "private static native char nativeGetCharacter(long ptr, int keyCode, int metaState)", "private static native boolean nativeGetFallbackAction(long ptr, int keyCode, int metaState, FallbackAction outFallbackAction)", "private static native char nativeGetNumber(long ptr, int keyCode)", "private static native char nativeGetMatch(long ptr, int keyCode, char[] chars, int metaState)", "private static native char nativeGetDisplayLabel(long ptr, int keyCode)", "private static native int nativeGetKeyboardType(long ptr)", "private static native KeyEvent[] nativeGetEvents(long ptr, char[] chars)", "private static native KeyCharacterMap nativeObtainEmptyKeyCharacterMap(int deviceId)", "private static native boolean nativeEquals(long ptr1, long ptr2)", "private static native void nativeApplyOverlay(long ptr, String layoutDescriptor, String overlay)", "private static native int nativeGetMappedKey(long ptr, int scanCode)", "protected void finalize() throws Throwable", "public static KeyCharacterMap obtainEmptyMap(int deviceId)", "public static KeyCharacterMap load(int deviceId)", "public static KeyCharacterMap load(@NonNull String layoutDescriptor, @NonNull String overlay)", "private void applyOverlay(@NonNull String layoutDescriptor, @NonNull String overlay)", "public int getMappedKeyOrDefault(int scanCode, int defaultKeyCode)", "public int get(int keyCode, int metaState)", "public FallbackAction getFallbackAction(int keyCode, int metaState)", "public char getNumber(int keyCode)", "public char getMatch(int keyCode, char[] chars)", "public char getMatch(int keyCode, char[] chars, int metaState)", "public char getDisplayLabel(int keyCode)", "public static int getDeadChar(int accent, int c)", "public static int getCombiningChar(int accent)", "public boolean getKeyData(int keyCode, KeyData results)", "public KeyEvent[] getEvents(char[] chars)", "public boolean isPrintingKey(int keyCode)", "public int getKeyboardType()", "public int getModifierBehavior()", "public static boolean deviceHasKey(int keyCode)", "public static boolean[] deviceHasKeys(int[] keyCodes)", "public void writeToParcel(Parcel out, int flags)", "public int describeContents()", "public boolean equals(Object obj)" ],
  "variableNames" : [ "BUILT_IN_KEYBOARD", "VIRTUAL_KEYBOARD", "NUMERIC", "PREDICTIVE", "ALPHA", "FULL", "SPECIAL_FUNCTION", "HEX_INPUT", "PICKER_DIALOG_INPUT", "MODIFIER_BEHAVIOR_CHORDED", "MODIFIER_BEHAVIOR_CHORDED_OR_TOGGLED", "COMBINING_ACCENT", "COMBINING_ACCENT_MASK", "ACCENT_ACUTE", "ACCENT_BREVE", "ACCENT_CARON", "ACCENT_CEDILLA", "ACCENT_CIRCUMFLEX", "ACCENT_COMMA_ABOVE", "ACCENT_COMMA_ABOVE_RIGHT", "ACCENT_DOT_ABOVE", "ACCENT_DOT_BELOW", "ACCENT_DOUBLE_ACUTE", "ACCENT_GRAVE", "ACCENT_HOOK_ABOVE", "ACCENT_HORN", "ACCENT_MACRON", "ACCENT_MACRON_BELOW", "ACCENT_OGONEK", "ACCENT_REVERSED_COMMA_ABOVE", "ACCENT_RING_ABOVE", "ACCENT_STROKE", "ACCENT_TILDE", "ACCENT_TURNED_COMMA_ABOVE", "ACCENT_UMLAUT", "ACCENT_VERTICAL_LINE_ABOVE", "ACCENT_VERTICAL_LINE_BELOW", "ACCENT_APOSTROPHE", "ACCENT_QUOTATION_MARK", "ACCENT_GRAVE_LEGACY", "ACCENT_CIRCUMFLEX_LEGACY", "ACCENT_TILDE_LEGACY", "CHAR_SPACE", "sCombiningToAccent", "sAccentToCombining", "sDeadKeyCache", "sDeadKeyBuilder", "CREATOR", "mPtr" ]
}