{
  "filePath" : "/home/maryam/clearblue/files/android-source-35/android/view/ViewGroup.java",
  "packageName" : "android.view",
  "className" : "ViewGroup",
  "comment" : "\n * <p>\n * A <code>ViewGroup</code> is a special view that can contain other views\n * (called children.) The view group is the base class for layouts and views\n * containers. This class also defines the\n * {@link android.view.ViewGroup.LayoutParams} class which serves as the base\n * class for layouts parameters.\n * </p>\n *\n * <p>\n * Also see {@link LayoutParams} for layout attributes.\n * </p>\n *\n * <div class=\"special reference\">\n * <h3>Developer Guides</h3>\n * <p>For more information about creating user interface layouts, read the\n * <a href=\"{@docRoot}guide/topics/ui/declaring-layout.html\">XML Layouts</a> developer\n * guide.</p></div>\n *\n * <p>Here is a complete implementation of a custom ViewGroup that implements\n * a simple {@link android.widget.FrameLayout} along with the ability to stack\n * children in left and right gutters.</p>\n *\n * {@sample development/samples/ApiDemos/src/com/example/android/apis/view/CustomLayout.java\n *      Complete}\n *\n * <p>If you are implementing XML layout attributes as shown in the example, this is the\n * corresponding definition for them that would go in <code>res/values/attrs.xml</code>:</p>\n *\n * {@sample development/samples/ApiDemos/res/values/attrs.xml CustomLayout}\n *\n * <p>Finally the layout manager can be used in an XML layout like so:</p>\n *\n * {@sample development/samples/ApiDemos/res/layout/custom_layout.xml Complete}\n *\n * @attr ref android.R.styleable#ViewGroup_clipChildren\n * @attr ref android.R.styleable#ViewGroup_clipToPadding\n * @attr ref android.R.styleable#ViewGroup_layoutAnimation\n * @attr ref android.R.styleable#ViewGroup_animationCache\n * @attr ref android.R.styleable#ViewGroup_persistentDrawingCache\n * @attr ref android.R.styleable#ViewGroup_alwaysDrawnWithCache\n * @attr ref android.R.styleable#ViewGroup_addStatesFromChildren\n * @attr ref android.R.styleable#ViewGroup_descendantFocusability\n * @attr ref android.R.styleable#ViewGroup_animateLayoutChanges\n * @attr ref android.R.styleable#ViewGroup_splitMotionEvents\n * @attr ref android.R.styleable#ViewGroup_layoutMode\n ",
  "links" : [ "android.view.ViewGroup.LayoutParams", "LayoutParams", "android.widget.FrameLayout" ],
  "variables" : [ {
    "name" : "TAG",
    "type" : "String",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "DBG",
    "type" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mDisappearingChildren",
    "type" : "ArrayList<View>",
    "comment" : "\n     * Views which have been hidden or removed which need to be animated on\n     * their way out.\n     * This field should be made private, so it is hidden from the SDK.\n     * {@hide}\n     ",
    "links" : [ ]
  }, {
    "name" : "mOnHierarchyChangeListener",
    "type" : "OnHierarchyChangeListener",
    "comment" : "\n     * Listener used to propagate events indicating when children are added\n     * and/or removed from a view group.\n     * This field should be made private, so it is hidden from the SDK.\n     * {@hide}\n     ",
    "links" : [ ]
  }, {
    "name" : "mFocused",
    "type" : "View",
    "comment" : " The view contained within this ViewGroup that has or contains focus.",
    "links" : [ ]
  }, {
    "name" : "mDefaultFocus",
    "type" : "View",
    "comment" : " that is or contains a default-focus view.",
    "links" : [ ]
  }, {
    "name" : "mFocusedInCluster",
    "type" : "View",
    "comment" : " The last child of this ViewGroup which held focus within the current cluster",
    "links" : [ ]
  }, {
    "name" : "mChildTransformation",
    "type" : "Transformation",
    "comment" : "\n     * A Transformation used when drawing children, to\n     * apply on the child being drawn.\n     ",
    "links" : [ ]
  }, {
    "name" : "mInvalidateRegion",
    "type" : "RectF",
    "comment" : "\n     * Used to track the current invalidation region.\n     ",
    "links" : [ ]
  }, {
    "name" : "mInvalidationTransformation",
    "type" : "Transformation",
    "comment" : "\n     * A Transformation used to calculate a correct\n     * invalidation area when the application is autoscaled.\n     ",
    "links" : [ ]
  }, {
    "name" : "mCurrentDragChild",
    "type" : "View",
    "comment" : " Used only to generate ENTER/EXIT events for pre-Nougat aps.",
    "links" : [ ]
  }, {
    "name" : "mCurrentDragStartEvent",
    "type" : "DragEvent",
    "comment" : " Metadata about the ongoing drag",
    "links" : [ ]
  }, {
    "name" : "mIsInterestedInDrag",
    "type" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mChildrenInterestedInDrag",
    "type" : "HashSet<View>",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mLocalPoint",
    "type" : "PointF",
    "comment" : " Used during drag dispatch",
    "links" : [ ]
  }, {
    "name" : "mTempPosition",
    "type" : "float[]",
    "comment" : " Lazily-created holder for point computations.",
    "links" : [ ]
  }, {
    "name" : "mTempPoint",
    "type" : "Point",
    "comment" : " Lazily-created holder for point computations.",
    "links" : [ ]
  }, {
    "name" : "mTempRect",
    "type" : "Rect",
    "comment" : " Lazily created Rect for dispatch to children",
    "links" : [ ]
  }, {
    "name" : "mTempLocation",
    "type" : "int[]",
    "comment" : " Lazily created int[2] for dispatch to children",
    "links" : [ ]
  }, {
    "name" : "mLayoutAnimationController",
    "type" : "LayoutAnimationController",
    "comment" : " Layout animation",
    "links" : [ ]
  }, {
    "name" : "mAnimationListener",
    "type" : "Animation.AnimationListener",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mFirstTouchTarget",
    "type" : "TouchTarget",
    "comment" : " First touch target in the linked list of touch targets.",
    "links" : [ ]
  }, {
    "name" : "mLastTouchDownTime",
    "type" : "long",
    "comment" : " For debugging only.  You can see these in hierarchyviewer.",
    "links" : [ ]
  }, {
    "name" : "mLastTouchDownIndex",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mLastTouchDownX",
    "type" : "float",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mLastTouchDownY",
    "type" : "float",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mFirstHoverTarget",
    "type" : "HoverTarget",
    "comment" : " their bounds and the view group does not intercept hover.",
    "links" : [ ]
  }, {
    "name" : "mHoveredSelf",
    "type" : "boolean",
    "comment" : " It might not have actually handled the hover event.",
    "links" : [ ]
  }, {
    "name" : "mTooltipHoverTarget",
    "type" : "View",
    "comment" : " The child capable of showing a tooltip and currently under the pointer.",
    "links" : [ ]
  }, {
    "name" : "mTooltipHoveredSelf",
    "type" : "boolean",
    "comment" : " over the view group but not one of its child views.",
    "links" : [ ]
  }, {
    "name" : "mGroupFlags",
    "type" : "int",
    "comment" : "\n     * Internal flags.\n     *\n     * This field should be made private, so it is hidden from the SDK.\n     * {@hide}\n     ",
    "links" : [ ]
  }, {
    "name" : "mLayoutMode",
    "type" : "int",
    "comment" : "\n     * Either {@link #LAYOUT_MODE_CLIP_BOUNDS} or {@link #LAYOUT_MODE_OPTICAL_BOUNDS}.\n     ",
    "links" : [ "#LAYOUT_MODE_OPTICAL_BOUNDS", "#LAYOUT_MODE_CLIP_BOUNDS" ]
  }, {
    "name" : "FLAG_CLIP_CHILDREN",
    "type" : "int",
    "comment" : " Set by default",
    "links" : [ ]
  }, {
    "name" : "FLAG_CLIP_TO_PADDING",
    "type" : "int",
    "comment" : " Set by default",
    "links" : [ ]
  }, {
    "name" : "FLAG_INVALIDATE_REQUIRED",
    "type" : "int",
    "comment" : " a child needs to be invalidated and FLAG_OPTIMIZE_INVALIDATE is set",
    "links" : [ ]
  }, {
    "name" : "FLAG_RUN_ANIMATION",
    "type" : "int",
    "comment" : " When set, dispatchDraw() will run the layout animation and unset the flag",
    "links" : [ ]
  }, {
    "name" : "FLAG_ANIMATION_DONE",
    "type" : "int",
    "comment" : " Set by default",
    "links" : [ ]
  }, {
    "name" : "FLAG_PADDING_NOT_NULL",
    "type" : "int",
    "comment" : " to clip it, even if FLAG_CLIP_TO_PADDING is set",
    "links" : [ ]
  }, {
    "name" : "FLAG_ANIMATION_CACHE",
    "type" : "int",
    "comment" : " @deprecated - functionality removed ",
    "links" : [ ]
  }, {
    "name" : "FLAG_OPTIMIZE_INVALIDATE",
    "type" : "int",
    "comment" : " characteristics",
    "links" : [ ]
  }, {
    "name" : "FLAG_CLEAR_TRANSFORMATION",
    "type" : "int",
    "comment" : " When set, the next call to drawChild() will clear mChildTransformation's matrix",
    "links" : [ ]
  }, {
    "name" : "FLAG_NOTIFY_ANIMATION_LISTENER",
    "type" : "int",
    "comment" : " This flag is set when the layout animation is over (after FLAG_ANIMATION_DONE is set)",
    "links" : [ ]
  }, {
    "name" : "FLAG_USE_CHILD_DRAWING_ORDER",
    "type" : "int",
    "comment" : "\n     * When set, the drawing method will call {@link #getChildDrawingOrder(int, int)}\n     * to get the index of the child to draw for that iteration.\n     *\n     * @hide\n     ",
    "links" : [ "#getChildDrawingOrder(int" ]
  }, {
    "name" : "FLAG_SUPPORT_STATIC_TRANSFORMATIONS",
    "type" : "int",
    "comment" : "\n     * When set, this ViewGroup supports static transformations on children; this causes\n     * {@link #getChildStaticTransformation(View, android.view.animation.Transformation)} to be\n     * invoked when a child is drawn.\n     *\n     * Any subclass overriding\n     * {@link #getChildStaticTransformation(View, android.view.animation.Transformation)} should\n     * set this flags in {@link #mGroupFlags}.\n     *\n     * {@hide}\n     ",
    "links" : [ "#mGroupFlags", "#getChildStaticTransformation(View" ]
  }, {
    "name" : "FLAG_ADD_STATES_FROM_CHILDREN",
    "type" : "int",
    "comment" : "\n     * When set, this ViewGroup's drawable states also include those\n     * of its children.\n     ",
    "links" : [ ]
  }, {
    "name" : "FLAG_ALWAYS_DRAWN_WITH_CACHE",
    "type" : "int",
    "comment" : " @deprecated functionality removed ",
    "links" : [ ]
  }, {
    "name" : "FLAG_CHILDREN_DRAWN_WITH_CACHE",
    "type" : "int",
    "comment" : " @deprecated functionality removed ",
    "links" : [ ]
  }, {
    "name" : "FLAG_NOTIFY_CHILDREN_ON_DRAWABLE_STATE_CHANGE",
    "type" : "int",
    "comment" : "\n     * When set, this group will go through its list of children to notify them of\n     * any drawable state change.\n     ",
    "links" : [ ]
  }, {
    "name" : "FLAG_MASK_FOCUSABILITY",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "FOCUS_BEFORE_DESCENDANTS",
    "type" : "int",
    "comment" : "\n     * This view will get focus before any of its descendants.\n     ",
    "links" : [ ]
  }, {
    "name" : "FOCUS_AFTER_DESCENDANTS",
    "type" : "int",
    "comment" : "\n     * This view will get focus only if none of its descendants want it.\n     ",
    "links" : [ ]
  }, {
    "name" : "FOCUS_BLOCK_DESCENDANTS",
    "type" : "int",
    "comment" : "\n     * This view will block any of its descendants from getting focus, even\n     * if they are focusable.\n     ",
    "links" : [ ]
  }, {
    "name" : "DESCENDANT_FOCUSABILITY_FLAGS",
    "type" : "int[]",
    "comment" : "\n     * Used to map between enum in attrubutes and flag values.\n     ",
    "links" : [ ]
  }, {
    "name" : "FLAG_DISALLOW_INTERCEPT",
    "type" : "int",
    "comment" : "\n     * When set, this ViewGroup should not intercept touch events.\n     * {@hide}\n     ",
    "links" : [ ]
  }, {
    "name" : "FLAG_SPLIT_MOTION_EVENTS",
    "type" : "int",
    "comment" : "\n     * When set, this ViewGroup will split MotionEvents to multiple child Views when appropriate.\n     ",
    "links" : [ ]
  }, {
    "name" : "FLAG_PREVENT_DISPATCH_ATTACHED_TO_WINDOW",
    "type" : "int",
    "comment" : "\n     * When set, this ViewGroup will not dispatch onAttachedToWindow calls\n     * to children when adding new views. This is used to prevent multiple\n     * onAttached calls when a ViewGroup adds children in its own onAttached method.\n     ",
    "links" : [ ]
  }, {
    "name" : "FLAG_LAYOUT_MODE_WAS_EXPLICITLY_SET",
    "type" : "int",
    "comment" : "\n     * When true, indicates that a layoutMode has been explicitly set, either with\n     * an explicit call to {@link #setLayoutMode(int)} in code or from an XML resource.\n     * This distinguishes the situation in which a layout mode was inherited from\n     * one of the ViewGroup's ancestors and cached locally.\n     ",
    "links" : [ "#setLayoutMode(int)" ]
  }, {
    "name" : "FLAG_IS_TRANSITION_GROUP",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "FLAG_IS_TRANSITION_GROUP_SET",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "FLAG_TOUCHSCREEN_BLOCKS_FOCUS",
    "type" : "int",
    "comment" : "\n     * When set, focus will not be permitted to enter this group if a touchscreen is present.\n     ",
    "links" : [ ]
  }, {
    "name" : "FLAG_START_ACTION_MODE_FOR_CHILD_IS_TYPED",
    "type" : "int",
    "comment" : "\n     * When true, indicates that a call to startActionModeForChild was made with the type parameter\n     * and should not be ignored. This helps in backwards compatibility with the existing method\n     * without a type.\n     *\n     * @see #startActionModeForChild(View, android.view.ActionMode.Callback)\n     * @see #startActionModeForChild(View, android.view.ActionMode.Callback, int)\n     ",
    "links" : [ ]
  }, {
    "name" : "FLAG_START_ACTION_MODE_FOR_CHILD_IS_NOT_TYPED",
    "type" : "int",
    "comment" : "\n     * When true, indicates that a call to startActionModeForChild was made without the type\n     * parameter. This helps in backwards compatibility with the existing method\n     * without a type.\n     *\n     * @see #startActionModeForChild(View, android.view.ActionMode.Callback)\n     * @see #startActionModeForChild(View, android.view.ActionMode.Callback, int)\n     ",
    "links" : [ ]
  }, {
    "name" : "FLAG_SHOW_CONTEXT_MENU_WITH_COORDS",
    "type" : "int",
    "comment" : "\n     * When set, indicates that a call to showContextMenuForChild was made with explicit\n     * coordinates within the initiating child view.\n     ",
    "links" : [ ]
  }, {
    "name" : "mPersistentDrawingCache",
    "type" : "int",
    "comment" : "\n     * Indicates which types of drawing caches are to be kept in memory.\n     * This field should be made private, so it is hidden from the SDK.\n     * {@hide}\n     ",
    "links" : [ ]
  }, {
    "name" : "PERSISTENT_NO_CACHE",
    "type" : "int",
    "comment" : "\n     * Used to indicate that no drawing cache should be kept in memory.\n     *\n     * @deprecated The view drawing cache was largely made obsolete with the introduction of\n     * hardware-accelerated rendering in API 11. With hardware-acceleration, intermediate cache\n     * layers are largely unnecessary and can easily result in a net loss in performance due to the\n     * cost of creating and updating the layer. In the rare cases where caching layers are useful,\n     * such as for alpha animations, {@link #setLayerType(int, Paint)} handles this with hardware\n     * rendering. For software-rendered snapshots of a small part of the View hierarchy or\n     * individual Views it is recommended to create a {@link Canvas} from either a {@link Bitmap} or\n     * {@link android.graphics.Picture} and call {@link #draw(Canvas)} on the View. However these\n     * software-rendered usages are discouraged and have compatibility issues with hardware-only\n     * rendering features such as {@link android.graphics.Bitmap.Config#HARDWARE Config.HARDWARE}\n     * bitmaps, real-time shadows, and outline clipping. For screenshots of the UI for feedback\n     * reports or unit testing the {@link PixelCopy} API is recommended.\n     ",
    "links" : [ "android.graphics.Bitmap.Config#HARDWARE", "#setLayerType(int", "android.graphics.Picture", "#draw(Canvas)", "android.graphics.Bitmap", "android.view.PixelCopy", "android.graphics.Canvas" ]
  }, {
    "name" : "PERSISTENT_ANIMATION_CACHE",
    "type" : "int",
    "comment" : "\n     * Used to indicate that the animation drawing cache should be kept in memory.\n     *\n     * @deprecated The view drawing cache was largely made obsolete with the introduction of\n     * hardware-accelerated rendering in API 11. With hardware-acceleration, intermediate cache\n     * layers are largely unnecessary and can easily result in a net loss in performance due to the\n     * cost of creating and updating the layer. In the rare cases where caching layers are useful,\n     * such as for alpha animations, {@link #setLayerType(int, Paint)} handles this with hardware\n     * rendering. For software-rendered snapshots of a small part of the View hierarchy or\n     * individual Views it is recommended to create a {@link Canvas} from either a {@link Bitmap} or\n     * {@link android.graphics.Picture} and call {@link #draw(Canvas)} on the View. However these\n     * software-rendered usages are discouraged and have compatibility issues with hardware-only\n     * rendering features such as {@link android.graphics.Bitmap.Config#HARDWARE Config.HARDWARE}\n     * bitmaps, real-time shadows, and outline clipping. For screenshots of the UI for feedback\n     * reports or unit testing the {@link PixelCopy} API is recommended.\n     ",
    "links" : [ "android.graphics.Bitmap.Config#HARDWARE", "#setLayerType(int", "android.graphics.Picture", "#draw(Canvas)", "android.graphics.Bitmap", "android.view.PixelCopy", "android.graphics.Canvas" ]
  }, {
    "name" : "PERSISTENT_SCROLLING_CACHE",
    "type" : "int",
    "comment" : "\n     * Used to indicate that the scrolling drawing cache should be kept in memory.\n     *\n     * @deprecated The view drawing cache was largely made obsolete with the introduction of\n     * hardware-accelerated rendering in API 11. With hardware-acceleration, intermediate cache\n     * layers are largely unnecessary and can easily result in a net loss in performance due to the\n     * cost of creating and updating the layer. In the rare cases where caching layers are useful,\n     * such as for alpha animations, {@link #setLayerType(int, Paint)} handles this with hardware\n     * rendering. For software-rendered snapshots of a small part of the View hierarchy or\n     * individual Views it is recommended to create a {@link Canvas} from either a {@link Bitmap} or\n     * {@link android.graphics.Picture} and call {@link #draw(Canvas)} on the View. However these\n     * software-rendered usages are discouraged and have compatibility issues with hardware-only\n     * rendering features such as {@link android.graphics.Bitmap.Config#HARDWARE Config.HARDWARE}\n     * bitmaps, real-time shadows, and outline clipping. For screenshots of the UI for feedback\n     * reports or unit testing the {@link PixelCopy} API is recommended.\n     ",
    "links" : [ "android.graphics.Bitmap.Config#HARDWARE", "#setLayerType(int", "android.graphics.Picture", "#draw(Canvas)", "android.graphics.Bitmap", "android.view.PixelCopy", "android.graphics.Canvas" ]
  }, {
    "name" : "PERSISTENT_ALL_CACHES",
    "type" : "int",
    "comment" : "\n     * Used to indicate that all drawing caches should be kept in memory.\n     *\n     * @deprecated The view drawing cache was largely made obsolete with the introduction of\n     * hardware-accelerated rendering in API 11. With hardware-acceleration, intermediate cache\n     * layers are largely unnecessary and can easily result in a net loss in performance due to the\n     * cost of creating and updating the layer. In the rare cases where caching layers are useful,\n     * such as for alpha animations, {@link #setLayerType(int, Paint)} handles this with hardware\n     * rendering. For software-rendered snapshots of a small part of the View hierarchy or\n     * individual Views it is recommended to create a {@link Canvas} from either a {@link Bitmap} or\n     * {@link android.graphics.Picture} and call {@link #draw(Canvas)} on the View. However these\n     * software-rendered usages are discouraged and have compatibility issues with hardware-only\n     * rendering features such as {@link android.graphics.Bitmap.Config#HARDWARE Config.HARDWARE}\n     * bitmaps, real-time shadows, and outline clipping. For screenshots of the UI for feedback\n     * reports or unit testing the {@link PixelCopy} API is recommended.\n     ",
    "links" : [ "android.graphics.Bitmap.Config#HARDWARE", "#setLayerType(int", "android.graphics.Picture", "#draw(Canvas)", "android.graphics.Bitmap", "android.view.PixelCopy", "android.graphics.Canvas" ]
  }, {
    "name" : "LAYOUT_MODE_UNDEFINED",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "LAYOUT_MODE_CLIP_BOUNDS",
    "type" : "int",
    "comment" : "\n     * This constant is a {@link #setLayoutMode(int) layoutMode}.\n     * Clip bounds are the raw values of {@link #getLeft() left}, {@link #getTop() top},\n     * {@link #getRight() right} and {@link #getBottom() bottom}.\n     ",
    "links" : [ "#setLayoutMode(int)", "#getLeft()", "#getRight()", "#getTop()", "#getBottom()" ]
  }, {
    "name" : "LAYOUT_MODE_OPTICAL_BOUNDS",
    "type" : "int",
    "comment" : "\n     * This constant is a {@link #setLayoutMode(int) layoutMode}.\n     * Optical bounds describe where a widget appears to be. They sit inside the clip\n     * bounds which need to cover a larger area to allow other effects,\n     * such as shadows and glows, to be drawn.\n     ",
    "links" : [ "#setLayoutMode(int)" ]
  }, {
    "name" : "LAYOUT_MODE_DEFAULT",
    "type" : "int",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "CLIP_TO_PADDING_MASK",
    "type" : "int",
    "comment" : "\n     * We clip to padding when FLAG_CLIP_TO_PADDING and FLAG_PADDING_NOT_NULL\n     * are set at the same time.\n     ",
    "links" : [ ]
  }, {
    "name" : "CHILD_LEFT_INDEX",
    "type" : "int",
    "comment" : " Index of the child's left position in the mLocation array",
    "links" : [ ]
  }, {
    "name" : "CHILD_TOP_INDEX",
    "type" : "int",
    "comment" : " Index of the child's top position in the mLocation array",
    "links" : [ ]
  }, {
    "name" : "mChildren",
    "type" : "View[]",
    "comment" : " Child views of this ViewGroup",
    "links" : [ ]
  }, {
    "name" : "mChildrenCount",
    "type" : "int",
    "comment" : " considered as children",
    "links" : [ ]
  }, {
    "name" : "mSuppressLayout",
    "type" : "boolean",
    "comment" : " suppressLayout()",
    "links" : [ ]
  }, {
    "name" : "mLayoutCalledWhileSuppressed",
    "type" : "boolean",
    "comment" : " layout is later re-enabled.",
    "links" : [ ]
  }, {
    "name" : "ARRAY_INITIAL_CAPACITY",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "ARRAY_CAPACITY_INCREMENT",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "sDebugLines",
    "type" : "float[]",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mCachePaint",
    "type" : "Paint",
    "comment" : " Used to draw cached views",
    "links" : [ ]
  }, {
    "name" : "mTransition",
    "type" : "LayoutTransition",
    "comment" : " Used to animate add/remove changes in layout",
    "links" : [ ]
  }, {
    "name" : "mTransitioningViews",
    "type" : "ArrayList<View>",
    "comment" : " being animated.",
    "links" : [ ]
  }, {
    "name" : "mVisibilityChangingChildren",
    "type" : "ArrayList<View>",
    "comment" : " views during a transition when they otherwise would have become gone/invisible",
    "links" : [ ]
  }, {
    "name" : "mPreSortedChildren",
    "type" : "ArrayList<View>",
    "comment" : " input/software draw dispatch for correctly Z ordering.",
    "links" : [ ]
  }, {
    "name" : "mChildCountWithTransientState",
    "type" : "int",
    "comment" : " Indicates how many of this container's child subtrees contain transient state",
    "links" : [ ]
  }, {
    "name" : "mNestedScrollAxes",
    "type" : "int",
    "comment" : "\n     * Currently registered axes for nested scrolling. Flag set consisting of\n     * {@link #SCROLL_AXIS_HORIZONTAL} {@link #SCROLL_AXIS_VERTICAL} or {@link #SCROLL_AXIS_NONE}\n     * for null.\n     ",
    "links" : [ "#SCROLL_AXIS_VERTICAL", "#SCROLL_AXIS_HORIZONTAL", "#SCROLL_AXIS_NONE" ]
  }, {
    "name" : "mTransientIndices",
    "type" : "IntArray",
    "comment" : " Used to manage the list of transient views, added by addTransientView()",
    "links" : [ ]
  }, {
    "name" : "mTransientViews",
    "type" : "List<View>",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mChildUnhandledKeyListeners",
    "type" : "int",
    "comment" : "\n     * Keeps track of how many child views have UnhandledKeyEventListeners. This should only be\n     * updated on the UI thread so shouldn't require explicit synchronization.\n     ",
    "links" : [ ]
  }, {
    "name" : "mInsetsAnimationDispatchMode",
    "type" : "int",
    "comment" : "\n     * Current dispatch mode of animation events\n     *\n     * @see WindowInsetsAnimation.Callback#getDispatchMode()\n     ",
    "links" : [ ]
  }, {
    "name" : "SENTINEL_ACTION_MODE",
    "type" : "ActionMode",
    "comment" : "\n     * Empty ActionMode used as a sentinel in recursive entries to startActionModeForChild.\n     *\n     * @see #startActionModeForChild(View, android.view.ActionMode.Callback)\n     * @see #startActionModeForChild(View, android.view.ActionMode.Callback, int)\n     ",
    "links" : [ ]
  }, {
    "name" : "mLayoutTransitionListener",
    "type" : "LayoutTransition.TransitionListener",
    "comment" : "",
    "links" : [ ]
  } ],
  "methods" : [ {
    "name" : "private void initViewGroup()",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private void initFromAttributes(Context context, AttributeSet attrs, int defStyleAttr, int defStyleRes)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public int getDescendantFocusability()",
    "returnType" : "int",
    "comment" : "\n     * Gets the descendant focusability of this view group.  The descendant\n     * focusability defines the relationship between this view group and its\n     * descendants when looking for a view to take focus in\n     * {@link #requestFocus(int, android.graphics.Rect)}.\n     *\n     * @return one of {@link #FOCUS_BEFORE_DESCENDANTS}, {@link #FOCUS_AFTER_DESCENDANTS},\n     *   {@link #FOCUS_BLOCK_DESCENDANTS}.\n     ",
    "links" : [ "#requestFocus(int", "#FOCUS_BLOCK_DESCENDANTS", "#FOCUS_AFTER_DESCENDANTS", "#FOCUS_BEFORE_DESCENDANTS" ]
  }, {
    "name" : "public void setDescendantFocusability(int focusability)",
    "returnType" : "void",
    "comment" : "\n     * Set the descendant focusability of this view group. This defines the relationship\n     * between this view group and its descendants when looking for a view to\n     * take focus in {@link #requestFocus(int, android.graphics.Rect)}.\n     *\n     * @param focusability one of {@link #FOCUS_BEFORE_DESCENDANTS}, {@link #FOCUS_AFTER_DESCENDANTS},\n     *   {@link #FOCUS_BLOCK_DESCENDANTS}.\n     ",
    "links" : [ "#requestFocus(int", "#FOCUS_BLOCK_DESCENDANTS", "#FOCUS_AFTER_DESCENDANTS", "#FOCUS_BEFORE_DESCENDANTS" ]
  }, {
    "name" : " void handleFocusGainInternal(int direction, Rect previouslyFocusedRect)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public void requestChildFocus(View child, View focused)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : " void setDefaultFocus(View child)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : " void clearDefaultFocus(View child)",
    "returnType" : "void",
    "comment" : "\n     * Clears the default-focus chain from {@param child} up to the first parent which has another\n     * default-focusable branch below it or until there is no default-focus chain.\n     *\n     * @param child\n     ",
    "links" : [ ]
  }, {
    "name" : " boolean hasDefaultFocus()",
    "returnType" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : " void clearFocusedInCluster(View child)",
    "returnType" : "void",
    "comment" : "\n     * Removes {@code child} (and associated focusedInCluster chain) from the cluster containing\n     * it.\n     * <br>\n     * This is intended to be run on {@code child}'s immediate parent. This is necessary because\n     * the chain is sometimes cleared after {@code child} has been detached.\n     ",
    "links" : [ ]
  }, {
    "name" : " void clearFocusedInCluster()",
    "returnType" : "void",
    "comment" : "\n     * Removes the focusedInCluster chain from this up to the cluster containing it.\n     ",
    "links" : [ ]
  }, {
    "name" : "public void focusableViewAvailable(View v)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public boolean showContextMenuForChild(View originalView)",
    "returnType" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public final boolean isShowingContextMenuWithCoords()",
    "returnType" : "boolean",
    "comment" : "\n     * @hide used internally for compatibility with existing app code only\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean showContextMenuForChild(View originalView, float x, float y)",
    "returnType" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public ActionMode startActionModeForChild(View originalView, ActionMode.Callback callback)",
    "returnType" : "ActionMode",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public ActionMode startActionModeForChild(View originalView, ActionMode.Callback callback, int type)",
    "returnType" : "ActionMode",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public boolean dispatchActivityResult(String who, int requestCode, int resultCode, Intent data)",
    "returnType" : "boolean",
    "comment" : "\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public View focusSearch(View focused, int direction)",
    "returnType" : "View",
    "comment" : "\n     * Find the nearest view in the specified direction that wants to take\n     * focus.\n     *\n     * @param focused The view that currently has focus\n     * @param direction One of FOCUS_UP, FOCUS_DOWN, FOCUS_LEFT, and\n     *        FOCUS_RIGHT, or 0 for not applicable.\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean requestChildRectangleOnScreen(View child, Rect rectangle, boolean immediate)",
    "returnType" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public boolean requestSendAccessibilityEvent(View child, AccessibilityEvent event)",
    "returnType" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public boolean onRequestSendAccessibilityEvent(View child, AccessibilityEvent event)",
    "returnType" : "boolean",
    "comment" : "\n     * Called when a child has requested sending an {@link AccessibilityEvent} and\n     * gives an opportunity to its parent to augment the event.\n     * <p>\n     * If an {@link android.view.View.AccessibilityDelegate} has been specified via calling\n     * {@link android.view.View#setAccessibilityDelegate(android.view.View.AccessibilityDelegate)} its\n     * {@link android.view.View.AccessibilityDelegate#onRequestSendAccessibilityEvent(ViewGroup, View, AccessibilityEvent)}\n     * is responsible for handling this call.\n     * </p>\n     *\n     * @param child The child which requests sending the event.\n     * @param event The event to be sent.\n     * @return True if the event should be sent.\n     *\n     * @see #requestSendAccessibilityEvent(View, AccessibilityEvent)\n     ",
    "links" : [ "android.view.View.AccessibilityDelegate", "android.view.View.AccessibilityDelegate#onRequestSendAccessibilityEvent(ViewGroup", "android.view.accessibility.AccessibilityEvent", "android.view.View#setAccessibilityDelegate(android.view.View.AccessibilityDelegate)" ]
  }, {
    "name" : "public boolean onRequestSendAccessibilityEventInternal(View child, AccessibilityEvent event)",
    "returnType" : "boolean",
    "comment" : "\n     * @see #onRequestSendAccessibilityEvent(View, AccessibilityEvent)\n     *\n     * Note: Called from the default {@link View.AccessibilityDelegate}.\n     *\n     * @hide\n     ",
    "links" : [ "View.AccessibilityDelegate" ]
  }, {
    "name" : "public void childHasTransientStateChanged(View child, boolean childHasTransientState)",
    "returnType" : "void",
    "comment" : "\n     * Called when a child view has changed whether or not it is tracking transient state.\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean hasTransientState()",
    "returnType" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public boolean dispatchUnhandledMove(View focused, int direction)",
    "returnType" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public void clearChildFocus(View child)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public void clearFocus()",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : " void unFocus(View focused)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public View getFocusedChild()",
    "returnType" : "View",
    "comment" : "\n     * Returns the focused child of this view, if any. The child may have focus\n     * or contain focus.\n     *\n     * @return the focused child or null.\n     ",
    "links" : [ ]
  }, {
    "name" : " View getDeepestFocusedChild()",
    "returnType" : "View",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public boolean hasFocus()",
    "returnType" : "boolean",
    "comment" : "\n     * Returns true if this view has or contains focus\n     *\n     * @return true if this view has or contains focus\n     ",
    "links" : [ ]
  }, {
    "name" : "public View findFocus()",
    "returnType" : "View",
    "comment" : "\n     * (non-Javadoc)\n     *\n     * @see android.view.View#findFocus()\n     ",
    "links" : [ ]
  }, {
    "name" : " boolean hasFocusable(boolean allowAutoFocus, boolean dispatchExplicit)",
    "returnType" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : " boolean hasFocusableChild(boolean dispatchExplicit)",
    "returnType" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public void addFocusables(ArrayList<View> views, int direction, int focusableMode)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public void addKeyboardNavigationClusters(Collection<View> views, int direction)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public void setTouchscreenBlocksFocus(boolean touchscreenBlocksFocus)",
    "returnType" : "void",
    "comment" : "\n     * Set whether this ViewGroup should ignore focus requests for itself and its children.\n     * If this option is enabled and the ViewGroup or a descendant currently has focus, focus\n     * will proceed forward.\n     *\n     * @param touchscreenBlocksFocus true to enable blocking focus in the presence of a touchscreen\n     ",
    "links" : [ ]
  }, {
    "name" : "private void setTouchscreenBlocksFocusNoRefocus(boolean touchscreenBlocksFocus)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public boolean getTouchscreenBlocksFocus()",
    "returnType" : "boolean",
    "comment" : "\n     * Check whether this ViewGroup should ignore focus requests for itself and its children.\n     ",
    "links" : [ ]
  }, {
    "name" : " boolean shouldBlockFocusForTouchscreen()",
    "returnType" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public void findViewsWithText(ArrayList<View> outViews, CharSequence text, int flags)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public View findViewByAccessibilityIdTraversal(int accessibilityId)",
    "returnType" : "View",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "public View findViewByAutofillIdTraversal(int autofillId)",
    "returnType" : "View",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "public void dispatchWindowFocusChanged(boolean hasFocus)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public void addTouchables(ArrayList<View> views)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public void makeOptionalFitsSystemWindows()",
    "returnType" : "void",
    "comment" : "\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public void makeFrameworkOptionalFitsSystemWindows()",
    "returnType" : "void",
    "comment" : "\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public void dispatchDisplayHint(int hint)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "protected void onChildVisibilityChanged(View child, int oldVisibility, int newVisibility)",
    "returnType" : "void",
    "comment" : "\n     * Called when a view's visibility has changed. Notify the parent to take any appropriate\n     * action.\n     *\n     * @param child The view whose visibility has changed\n     * @param oldVisibility The previous visibility value (GONE, INVISIBLE, or VISIBLE).\n     * @param newVisibility The new visibility value (GONE, INVISIBLE, or VISIBLE).\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "protected void dispatchVisibilityChanged(View changedView, int visibility)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public void dispatchWindowVisibilityChanged(int visibility)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : " boolean dispatchVisibilityAggregated(boolean isVisible)",
    "returnType" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public void dispatchConfigurationChanged(Configuration newConfig)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public void recomputeViewAttributes(View child)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : " void dispatchCollectViewAttributes(AttachInfo attachInfo, int visibility)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public void bringChildToFront(View child)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private PointF getLocalPoint()",
    "returnType" : "PointF",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : " boolean dispatchDragEnterExitInPreN(DragEvent event)",
    "returnType" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public boolean dispatchDragEvent(DragEvent event)",
    "returnType" : "boolean",
    "comment" : " TODO: Write real docs",
    "links" : [ ]
  }, {
    "name" : " View findFrontmostDroppableChildAt(float x, float y, PointF outLocalPoint)",
    "returnType" : "View",
    "comment" : " the position within its own local coordinate system.",
    "links" : [ ]
  }, {
    "name" : " boolean notifyChildOfDragStart(View child)",
    "returnType" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public void dispatchWindowSystemUiVisiblityChanged(int visible)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public void dispatchSystemUiVisibilityChanged(int visible)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : " boolean updateLocalSystemUiVisibility(int localValue, int localChanges)",
    "returnType" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public boolean dispatchKeyEventPreIme(KeyEvent event)",
    "returnType" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public boolean dispatchKeyEvent(KeyEvent event)",
    "returnType" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public boolean dispatchKeyShortcutEvent(KeyEvent event)",
    "returnType" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public boolean dispatchTrackballEvent(MotionEvent event)",
    "returnType" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public boolean dispatchCapturedPointerEvent(MotionEvent event)",
    "returnType" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public void dispatchPointerCaptureChanged(boolean hasCapture)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public PointerIcon onResolvePointerIcon(MotionEvent event, int pointerIndex)",
    "returnType" : "PointerIcon",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private PointerIcon dispatchResolvePointerIcon(MotionEvent event, int pointerIndex, View child)",
    "returnType" : "PointerIcon",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private int getAndVerifyPreorderedIndex(int childrenCount, int i, boolean customOrder)",
    "returnType" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "protected boolean dispatchHoverEvent(MotionEvent event)",
    "returnType" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private void exitHoverTargets()",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private void cancelHoverTarget(View view)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : " boolean dispatchTooltipHoverEvent(MotionEvent event)",
    "returnType" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private boolean dispatchTooltipHoverEvent(MotionEvent event, View child)",
    "returnType" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private void exitTooltipHoverTargets()",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "protected boolean hasHoveredChild()",
    "returnType" : "boolean",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "protected boolean pointInHoveredChild(MotionEvent event)",
    "returnType" : "boolean",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "public void addChildrenForAccessibility(ArrayList<View> outChildren)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public boolean onInterceptHoverEvent(MotionEvent event)",
    "returnType" : "boolean",
    "comment" : "\n     * Implement this method to intercept hover events before they are handled\n     * by child views.\n     * <p>\n     * This method is called before dispatching a hover event to a child of\n     * the view group or to the view group's own {@link #onHoverEvent} to allow\n     * the view group a chance to intercept the hover event.\n     * This method can also be used to watch all pointer motions that occur within\n     * the bounds of the view group even when the pointer is hovering over\n     * a child of the view group rather than over the view group itself.\n     * </p><p>\n     * The view group can prevent its children from receiving hover events by\n     * implementing this method and returning <code>true</code> to indicate\n     * that it would like to intercept hover events.  The view group must\n     * continuously return <code>true</code> from {@link #onInterceptHoverEvent}\n     * for as long as it wishes to continue intercepting hover events from\n     * its children.\n     * </p><p>\n     * Interception preserves the invariant that at most one view can be\n     * hovered at a time by transferring hover focus from the currently hovered\n     * child to the view group or vice-versa as needed.\n     * </p><p>\n     * If this method returns <code>true</code> and a child is already hovered, then the\n     * child view will first receive a hover exit event and then the view group\n     * itself will receive a hover enter event in {@link #onHoverEvent}.\n     * Likewise, if this method had previously returned <code>true</code> to intercept hover\n     * events and instead returns <code>false</code> while the pointer is hovering\n     * within the bounds of one of a child, then the view group will first receive a\n     * hover exit event in {@link #onHoverEvent} and then the hovered child will\n     * receive a hover enter event.\n     * </p><p>\n     * The default implementation handles mouse hover on the scroll bars.\n     * </p>\n     *\n     * @param event The motion event that describes the hover.\n     * @return True if the view group would like to intercept the hover event\n     * and prevent its children from receiving it.\n     ",
    "links" : [ "#onHoverEvent", "#onInterceptHoverEvent" ]
  }, {
    "name" : "private static MotionEvent obtainMotionEventNoHistoryOrSelf(MotionEvent event)",
    "returnType" : "MotionEvent",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "protected boolean dispatchGenericPointerEvent(MotionEvent event)",
    "returnType" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "protected boolean dispatchGenericFocusedEvent(MotionEvent event)",
    "returnType" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private boolean dispatchTransformedGenericPointerEvent(MotionEvent event, View child)",
    "returnType" : "boolean",
    "comment" : "\n     * Dispatches a generic pointer event to a child, taking into account\n     * transformations that apply to the child.\n     *\n     * @param event The event to send.\n     * @param child The view to send the event to.\n     * @return {@code true} if the child handled the event.\n     ",
    "links" : [ ]
  }, {
    "name" : "private MotionEvent getTransformedMotionEvent(MotionEvent event, View child)",
    "returnType" : "MotionEvent",
    "comment" : "\n     * Returns a MotionEvent that's been transformed into the child's local coordinates.\n     *\n     * It's the responsibility of the caller to recycle it once they're finished with it.\n     * @param event The event to transform.\n     * @param child The view whose coordinate space is to be used.\n     * @return A copy of the given MotionEvent, transformed into the given View's coordinate\n     *         space.\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean dispatchTouchEvent(MotionEvent ev)",
    "returnType" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public ArrayList<View> buildTouchDispatchChildList()",
    "returnType" : "ArrayList<View>",
    "comment" : "\n     * Provide custom ordering of views in which the touch will be dispatched.\n     *\n     * This is called within a tight loop, so you are not allowed to allocate objects, including\n     * the return array. Instead, you should return a pre-allocated list that will be cleared\n     * after the dispatch is finished.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "private View findChildWithAccessibilityFocus()",
    "returnType" : "View",
    "comment" : "\n     * Finds the child which has accessibility focus.\n     *\n     * @return The child that has focus.\n     ",
    "links" : [ ]
  }, {
    "name" : "private void resetTouchState()",
    "returnType" : "void",
    "comment" : "\n     * Resets all touch state in preparation for a new cycle.\n     ",
    "links" : [ ]
  }, {
    "name" : "private static boolean resetCancelNextUpFlag(@NonNull View view)",
    "returnType" : "boolean",
    "comment" : "\n     * Resets the cancel next up flag.\n     * Returns true if the flag was previously set.\n     ",
    "links" : [ ]
  }, {
    "name" : "private void clearTouchTargets()",
    "returnType" : "void",
    "comment" : "\n     * Clears all touch targets.\n     ",
    "links" : [ ]
  }, {
    "name" : "private void cancelAndClearTouchTargets(MotionEvent event)",
    "returnType" : "void",
    "comment" : "\n     * Cancels and clears all touch targets.\n     ",
    "links" : [ ]
  }, {
    "name" : "private TouchTarget getTouchTarget(@NonNull View child)",
    "returnType" : "TouchTarget",
    "comment" : "\n     * Gets the touch target for specified child view.\n     * Returns null if not found.\n     ",
    "links" : [ ]
  }, {
    "name" : "private TouchTarget addTouchTarget(@NonNull View child, int pointerIdBits)",
    "returnType" : "TouchTarget",
    "comment" : "\n     * Adds a touch target for specified child to the beginning of the list.\n     * Assumes the target child is not already present.\n     ",
    "links" : [ ]
  }, {
    "name" : "private void removePointersFromTouchTargets(int pointerIdBits)",
    "returnType" : "void",
    "comment" : "\n     * Removes the pointer ids from consideration.\n     ",
    "links" : [ ]
  }, {
    "name" : "private void cancelTouchTarget(View view)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private Rect getTempRect()",
    "returnType" : "Rect",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private float[] getTempLocationF()",
    "returnType" : "float[]",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private Point getTempPoint()",
    "returnType" : "Point",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "protected boolean isTransformedTouchPointInView(float x, float y, View child, PointF outLocalPoint)",
    "returnType" : "boolean",
    "comment" : "\n     * Returns true if a child view contains the specified point when transformed\n     * into its coordinate space.\n     * Child must not be null.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public void transformPointToViewLocal(float[] point, View child)",
    "returnType" : "void",
    "comment" : "\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "private boolean dispatchTransformedTouchEvent(MotionEvent event, boolean cancel, View child, int desiredPointerIdBits)",
    "returnType" : "boolean",
    "comment" : "\n     * Transforms a motion event into the coordinate space of a particular child view,\n     * filters out irrelevant pointer ids, and overrides its action if necessary.\n     * If child is null, assumes the MotionEvent will be sent to this ViewGroup instead.\n     ",
    "links" : [ ]
  }, {
    "name" : "public void setMotionEventSplittingEnabled(boolean split)",
    "returnType" : "void",
    "comment" : "\n     * Enable or disable the splitting of MotionEvents to multiple children during touch event\n     * dispatch. This behavior is enabled by default for applications that target an\n     * SDK version of {@link Build.VERSION_CODES#HONEYCOMB} or newer.\n     *\n     * <p>When this option is enabled MotionEvents may be split and dispatched to different child\n     * views depending on where each pointer initially went down. This allows for user interactions\n     * such as scrolling two panes of content independently, chording of buttons, and performing\n     * independent gestures on different pieces of content.\n     *\n     * @param split <code>true</code> to allow MotionEvents to be split and dispatched to multiple\n     *              child views. <code>false</code> to only allow one child view to be the target of\n     *              any MotionEvent received by this ViewGroup.\n     * @attr ref android.R.styleable#ViewGroup_splitMotionEvents\n     ",
    "links" : [ "Build.VERSION_CODES#HONEYCOMB" ]
  }, {
    "name" : "public boolean isMotionEventSplittingEnabled()",
    "returnType" : "boolean",
    "comment" : "\n     * Returns true if MotionEvents dispatched to this ViewGroup can be split to multiple children.\n     * @return true if MotionEvents dispatched to this ViewGroup can be split to multiple children.\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean isTransitionGroup()",
    "returnType" : "boolean",
    "comment" : "\n     * Returns true if this ViewGroup should be considered as a single entity for removal\n     * when executing an Activity transition. If this is false, child elements will move\n     * individually during the transition.\n     *\n     * @return True if the ViewGroup should be acted on together during an Activity transition.\n     * The default value is true when there is a non-null background or if\n     * {@link #getTransitionName()} is not null or if a\n     * non-null {@link android.view.ViewOutlineProvider} other than\n     * {@link android.view.ViewOutlineProvider#BACKGROUND} was given to\n     * {@link #setOutlineProvider(ViewOutlineProvider)} and false otherwise.\n     ",
    "links" : [ "#getTransitionName()", "android.view.ViewOutlineProvider", "#setOutlineProvider(ViewOutlineProvider)", "android.view.ViewOutlineProvider#BACKGROUND" ]
  }, {
    "name" : "public void setTransitionGroup(boolean isTransitionGroup)",
    "returnType" : "void",
    "comment" : "\n     * Changes whether or not this ViewGroup should be treated as a single entity during\n     * Activity Transitions.\n     * @param isTransitionGroup Whether or not the ViewGroup should be treated as a unit\n     *                          in Activity transitions. If false, the ViewGroup won't transition,\n     *                          only its children. If true, the entire ViewGroup will transition\n     *                          together.\n     * @see android.app.ActivityOptions#makeSceneTransitionAnimation(android.app.Activity,\n     * android.util.Pair[])\n     ",
    "links" : [ ]
  }, {
    "name" : "public void requestDisallowInterceptTouchEvent(boolean disallowIntercept)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public boolean onInterceptTouchEvent(MotionEvent ev)",
    "returnType" : "boolean",
    "comment" : "\n     * Implement this method to intercept all touch screen motion events.  This\n     * allows you to watch events as they are dispatched to your children, and\n     * take ownership of the current gesture at any point.\n     *\n     * <p>Using this function takes some care, as it has a fairly complicated\n     * interaction with {@link View#onTouchEvent(MotionEvent)\n     * View.onTouchEvent(MotionEvent)}, and using it requires implementing\n     * that method as well as this one in the correct way.  Events will be\n     * received in the following order:\n     *\n     * <ol>\n     * <li> You will receive the down event here.\n     * <li> The down event will be handled either by a child of this view\n     * group, or given to your own onTouchEvent() method to handle; this means\n     * you should implement onTouchEvent() to return true, so you will\n     * continue to see the rest of the gesture (instead of looking for\n     * a parent view to handle it).  Also, by returning true from\n     * onTouchEvent(), you will not receive any following\n     * events in onInterceptTouchEvent() and all touch processing must\n     * happen in onTouchEvent() like normal.\n     * <li> For as long as you return false from this function, each following\n     * event (up to and including the final up) will be delivered first here\n     * and then to the target's onTouchEvent().\n     * <li> If you return true from here, you will not receive any\n     * following events: the target view will receive the same event but\n     * with the action {@link MotionEvent#ACTION_CANCEL}, and all further\n     * events will be delivered to your onTouchEvent() method and no longer\n     * appear here.\n     * </ol>\n     *\n     * @param ev The motion event being dispatched down the hierarchy.\n     * @return Return true to steal motion events from the children and have\n     * them dispatched to this ViewGroup through onTouchEvent().\n     * The current target will receive an ACTION_CANCEL event, and no further\n     * messages will be delivered here.\n     ",
    "links" : [ "android.webkit.WebView#onTouchEvent(MotionEvent)", "android.view.MotionEvent#ACTION_CANCEL" ]
  }, {
    "name" : "public boolean requestFocus(int direction, Rect previouslyFocusedRect)",
    "returnType" : "boolean",
    "comment" : "\n     * {@inheritDoc}\n     *\n     * Looks for a view to give focus to respecting the setting specified by\n     * {@link #getDescendantFocusability()}.\n     *\n     * Uses {@link #onRequestFocusInDescendants(int, android.graphics.Rect)} to\n     * find focus within the children of this group when appropriate.\n     *\n     * @see #FOCUS_BEFORE_DESCENDANTS\n     * @see #FOCUS_AFTER_DESCENDANTS\n     * @see #FOCUS_BLOCK_DESCENDANTS\n     * @see #onRequestFocusInDescendants(int, android.graphics.Rect)\n     ",
    "links" : [ "#getDescendantFocusability()", "#onRequestFocusInDescendants(int" ]
  }, {
    "name" : "protected boolean onRequestFocusInDescendants(int direction, Rect previouslyFocusedRect)",
    "returnType" : "boolean",
    "comment" : "\n     * Look for a descendant to call {@link View#requestFocus} on.\n     * Called by {@link ViewGroup#requestFocus(int, android.graphics.Rect)}\n     * when it wants to request focus within its children.  Override this to\n     * customize how your {@link ViewGroup} requests focus within its children.\n     * @param direction One of FOCUS_UP, FOCUS_DOWN, FOCUS_LEFT, and FOCUS_RIGHT\n     * @param previouslyFocusedRect The rectangle (in this View's coordinate system)\n     *        to give a finer grained hint about where focus is coming from.  May be null\n     *        if there is no hint.\n     * @return Whether focus was taken.\n     ",
    "links" : [ "android.webkit.WebView#requestFocus", "android.view.ViewGroup#requestFocus(int", "android.view.ViewGroup" ]
  }, {
    "name" : "public boolean restoreDefaultFocus()",
    "returnType" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public boolean restoreFocusInCluster(@FocusRealDirection int direction)",
    "returnType" : "boolean",
    "comment" : "\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "private boolean restoreFocusInClusterInternal(@FocusRealDirection int direction)",
    "returnType" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public boolean restoreFocusNotInCluster()",
    "returnType" : "boolean",
    "comment" : "\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public void dispatchStartTemporaryDetach()",
    "returnType" : "void",
    "comment" : "\n     * {@inheritDoc}\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public void dispatchFinishTemporaryDetach()",
    "returnType" : "void",
    "comment" : "\n     * {@inheritDoc}\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : " void dispatchAttachedToWindow(AttachInfo info, int visibility)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : " void dispatchScreenStateChanged(int screenState)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : " void dispatchMovedToDisplay(Display display, Configuration config)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public boolean dispatchPopulateAccessibilityEventInternal(AccessibilityEvent event)",
    "returnType" : "boolean",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "public void dispatchProvideStructure(ViewStructure structure)",
    "returnType" : "void",
    "comment" : "\n     * Dispatch creation of {@link ViewStructure} down the hierarchy.  This implementation\n     * adds in all child views of the view group, in addition to calling the default View\n     * implementation.\n     ",
    "links" : [ "android.view.ViewStructure" ]
  }, {
    "name" : "public void dispatchProvideAutofillStructure(ViewStructure structure, @AutofillFlags int flags)",
    "returnType" : "void",
    "comment" : "\n     * {@inheritDoc}\n     *\n     * <p>This implementation adds in all child views of the view group, in addition to calling the\n     * default {@link View} implementation.\n     ",
    "links" : [ "android.webkit.WebView" ]
  }, {
    "name" : "public void dispatchProvideContentCaptureStructure()",
    "returnType" : "void",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "private ChildListForAutoFillOrContentCapture getChildrenForAutofill(@AutofillFlags int flags)",
    "returnType" : "ChildListForAutoFillOrContentCapture",
    "comment" : "\n     * Gets the children for autofill. Children for autofill are the first\n     * level descendants that are important for autofill. The returned\n     * child list object is pooled and the caller must recycle it once done.\n     * @hide ",
    "links" : [ ]
  }, {
    "name" : "private AutofillManager getAutofillManager()",
    "returnType" : "AutofillManager",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private boolean shouldIncludeAllChildrenViewWithAutofillTypeNotNone(AutofillManager afm)",
    "returnType" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private boolean shouldIncludeAllChildrenViews(AutofillManager afm)",
    "returnType" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private boolean shouldAlwaysIncludeWebview(AutofillManager afm)",
    "returnType" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private boolean shouldIncludeInvisibleView(AutofillManager afm)",
    "returnType" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private void populateChildrenForAutofill(ArrayList<View> list, @AutofillFlags int flags)",
    "returnType" : "void",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "private ChildListForAutoFillOrContentCapture getChildrenForContentCapture()",
    "returnType" : "ChildListForAutoFillOrContentCapture",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private void populateChildrenForContentCapture(ArrayList<View> list)",
    "returnType" : "void",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "private static View getAndVerifyPreorderedView(ArrayList<View> preorderedList, View[] children, int childIndex)",
    "returnType" : "View",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public void resetSubtreeAutofillIds()",
    "returnType" : "void",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "public void onInitializeAccessibilityNodeInfoInternal(AccessibilityNodeInfo info)",
    "returnType" : "void",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "public void addExtraDataToAccessibilityNodeInfo(@NonNull AccessibilityNodeInfo info, @NonNull String extraDataKey, @Nullable Bundle arguments)",
    "returnType" : "void",
    "comment" : "\n     * {@inheritDoc}\n     *\n     * @param info The info to which to add the extra data. Never {@code null}.\n     * @param extraDataKey A key specifying the type of extra data to add to the info. The\n     *                     extra data should be added to the {@link Bundle} returned by\n     *                     the info's {@link AccessibilityNodeInfo#getExtras} method. Never\n     *                     {@code null}.\n     * @param arguments A {@link Bundle} holding any arguments relevant for this request. May be\n     *                  {@code null} if the service provided no arguments.\n     *\n     ",
    "links" : [ "android.os.Bundle", "android.view.accessibility.AccessibilityNodeInfo#getExtras" ]
  }, {
    "name" : "public CharSequence getAccessibilityClassName()",
    "returnType" : "CharSequence",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public void notifySubtreeAccessibilityStateChanged(View child, View source, int changeType)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public void notifySubtreeAccessibilityStateChangedIfNeeded()",
    "returnType" : "void",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : " void resetSubtreeAccessibilityStateChanged()",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : " int getNumChildrenForAccessibility()",
    "returnType" : "int",
    "comment" : "\n     * Counts the number of children of this View that will be sent to an accessibility service.\n     *\n     * @return The number of children an {@code AccessibilityNodeInfo} rooted at this View\n     * would have.\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean onNestedPrePerformAccessibilityAction(View target, int action, Bundle args)",
    "returnType" : "boolean",
    "comment" : "\n     * {@inheritDoc}\n     *\n     * <p>Subclasses should always call <code>super.onNestedPrePerformAccessibilityAction</code></p>\n     *\n     * @param target The target view dispatching this action\n     * @param action Action being performed; see\n     *               {@link android.view.accessibility.AccessibilityNodeInfo}\n     * @param args Optional action arguments\n     * @return false by default. Subclasses should return true if they handle the event.\n     ",
    "links" : [ "android.view.accessibility.AccessibilityNodeInfo" ]
  }, {
    "name" : " void calculateAccessibilityDataSensitive()",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : " void dispatchDetachedFromWindow()",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "protected void internalSetPadding(int left, int top, int right, int bottom)",
    "returnType" : "void",
    "comment" : "\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "protected void dispatchSaveInstanceState(SparseArray<Parcelable> container)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "protected void dispatchFreezeSelfOnly(SparseArray<Parcelable> container)",
    "returnType" : "void",
    "comment" : "\n     * Perform dispatching of a {@link #saveHierarchyState(android.util.SparseArray)}  freeze()}\n     * to only this view, not to its children.  For use when overriding\n     * {@link #dispatchSaveInstanceState(android.util.SparseArray)}  dispatchFreeze()} to allow\n     * subclasses to freeze their own state but not the state of their children.\n     *\n     * @param container the container\n     ",
    "links" : [ "#saveHierarchyState(android.util.SparseArray)", "#dispatchSaveInstanceState(android.util.SparseArray)" ]
  }, {
    "name" : "protected void dispatchRestoreInstanceState(SparseArray<Parcelable> container)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "protected void dispatchThawSelfOnly(SparseArray<Parcelable> container)",
    "returnType" : "void",
    "comment" : "\n     * Perform dispatching of a {@link #restoreHierarchyState(android.util.SparseArray)}\n     * to only this view, not to its children.  For use when overriding\n     * {@link #dispatchRestoreInstanceState(android.util.SparseArray)} to allow\n     * subclasses to thaw their own state but not the state of their children.\n     *\n     * @param container the container\n     ",
    "links" : [ "#dispatchRestoreInstanceState(android.util.SparseArray)", "#restoreHierarchyState(android.util.SparseArray)" ]
  }, {
    "name" : "protected void setChildrenDrawingCacheEnabled(boolean enabled)",
    "returnType" : "void",
    "comment" : "\n     * Enables or disables the drawing cache for each child of this view group.\n     *\n     * @param enabled true to enable the cache, false to dispose of it\n     *\n     * @deprecated The view drawing cache was largely made obsolete with the introduction of\n     * hardware-accelerated rendering in API 11. With hardware-acceleration, intermediate cache\n     * layers are largely unnecessary and can easily result in a net loss in performance due to the\n     * cost of creating and updating the layer. In the rare cases where caching layers are useful,\n     * such as for alpha animations, {@link #setLayerType(int, Paint)} handles this with hardware\n     * rendering. For software-rendered snapshots of a small part of the View hierarchy or\n     * individual Views it is recommended to create a {@link Canvas} from either a {@link Bitmap} or\n     * {@link android.graphics.Picture} and call {@link #draw(Canvas)} on the View. However these\n     * software-rendered usages are discouraged and have compatibility issues with hardware-only\n     * rendering features such as {@link android.graphics.Bitmap.Config#HARDWARE Config.HARDWARE}\n     * bitmaps, real-time shadows, and outline clipping. For screenshots of the UI for feedback\n     * reports or unit testing the {@link PixelCopy} API is recommended.\n     ",
    "links" : [ "android.graphics.Bitmap.Config#HARDWARE", "#setLayerType(int", "android.graphics.Picture", "#draw(Canvas)", "android.graphics.Bitmap", "android.view.PixelCopy", "android.graphics.Canvas" ]
  }, {
    "name" : "public Bitmap createSnapshot(ViewDebug.CanvasProvider canvasProvider, boolean skipChildren)",
    "returnType" : "Bitmap",
    "comment" : "\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : " boolean isLayoutModeOptical()",
    "returnType" : "boolean",
    "comment" : " Return true if this ViewGroup is laying out using optical bounds. ",
    "links" : [ ]
  }, {
    "name" : " Insets computeOpticalInsets()",
    "returnType" : "Insets",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private static void fillRect(Canvas canvas, Paint paint, int x1, int y1, int x2, int y2)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private static int sign(int x)",
    "returnType" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private static void drawCorner(Canvas c, Paint paint, int x1, int y1, int dx, int dy, int lw)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private static void drawRectCorners(Canvas canvas, int x1, int y1, int x2, int y2, Paint paint, int lineLength, int lineWidth)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private static void fillDifference(Canvas canvas, int x2, int y2, int x3, int y3, int dx1, int dy1, int dx2, int dy2, Paint paint)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "protected void onDebugDrawMargins(@NonNull Canvas canvas, Paint paint)",
    "returnType" : "void",
    "comment" : "\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "protected void onDebugDraw(@NonNull Canvas canvas)",
    "returnType" : "void",
    "comment" : "\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "protected void dispatchDraw(@NonNull Canvas canvas)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public ViewGroupOverlay getOverlay()",
    "returnType" : "ViewGroupOverlay",
    "comment" : "\n     * Returns the ViewGroupOverlay for this view group, creating it if it does\n     * not yet exist. In addition to {@link ViewOverlay}'s support for drawables,\n     * {@link ViewGroupOverlay} allows views to be added to the overlay. These\n     * views, like overlay drawables, are visual-only; they do not receive input\n     * events and should not be used as anything other than a temporary\n     * representation of a view in a parent container, such as might be used\n     * by an animation effect.\n     *\n     * <p>Note: Overlays do not currently work correctly with {@link\n     * SurfaceView} or {@link TextureView}; contents in overlays for these\n     * types of views may not display correctly.</p>\n     *\n     * @return The ViewGroupOverlay object for this view.\n     * @see ViewGroupOverlay\n     ",
    "links" : [ "android.view.SurfaceView", "android.view.ViewGroupOverlay", "android.view.TextureView", "android.view.ViewOverlay" ]
  }, {
    "name" : "protected int getChildDrawingOrder(int childCount, int drawingPosition)",
    "returnType" : "int",
    "comment" : "\n     * Converts drawing order position to container position. Override this\n     * if you want to change the drawing order of children. By default, it\n     * returns drawingPosition.\n     * <p>\n     * NOTE: In order for this method to be called, you must enable child ordering\n     * first by calling {@link #setChildrenDrawingOrderEnabled(boolean)}.\n     *\n     * @param drawingPosition the drawing order position.\n     * @return the container position of a child for this drawing order position.\n     *\n     * @see #setChildrenDrawingOrderEnabled(boolean)\n     * @see #isChildrenDrawingOrderEnabled()\n     ",
    "links" : [ "#setChildrenDrawingOrderEnabled(boolean)" ]
  }, {
    "name" : "public final int getChildDrawingOrder(int drawingPosition)",
    "returnType" : "int",
    "comment" : "\n     * Converts drawing order position to container position.\n     * <p>\n     * Children are not necessarily drawn in the order in which they appear in the container.\n     * ViewGroups can enable a custom ordering via {@link #setChildrenDrawingOrderEnabled(boolean)}.\n     * This method returns the container position of a child that appears in the given position\n     * in the current drawing order.\n     *\n     * @param drawingPosition the drawing order position.\n     * @return the container position of a child for this drawing order position.\n     *\n     * @see #getChildDrawingOrder(int, int)\n     ",
    "links" : [ "#setChildrenDrawingOrderEnabled(boolean)" ]
  }, {
    "name" : "private boolean hasChildWithZ()",
    "returnType" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : " ArrayList<View> buildOrderedChildList()",
    "returnType" : "ArrayList<View>",
    "comment" : "\n     * Populates (and returns) mPreSortedChildren with a pre-ordered list of the View's children,\n     * sorted first by Z, then by child drawing order (if applicable). This list must be cleared\n     * after use to avoid leaking child Views.\n     *\n     * Uses a stable, insertion sort which is commonly O(n) for ViewGroups with very few elevated\n     * children.\n     ",
    "links" : [ ]
  }, {
    "name" : "private void notifyAnimationListener()",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "protected void dispatchGetDisplayList()",
    "returnType" : "void",
    "comment" : "\n     * This method is used to cause children of this ViewGroup to restore or recreate their\n     * display lists. It is called by getDisplayList() when the parent ViewGroup does not need\n     * to recreate its own display list, which would happen if it went through the normal\n     * draw/dispatchDraw mechanisms.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "private void recreateChildDisplayList(View child)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "protected boolean drawChild(@NonNull Canvas canvas, View child, long drawingTime)",
    "returnType" : "boolean",
    "comment" : "\n     * Draw one child of this View Group. This method is responsible for getting\n     * the canvas in the right state. This includes clipping, translating so\n     * that the child's scrolled origin is at 0, 0, and applying any animation\n     * transformations.\n     *\n     * @param canvas The canvas on which to draw the child\n     * @param child Who to draw\n     * @param drawingTime The time at which draw is occurring\n     * @return True if an invalidate() was issued\n     ",
    "links" : [ ]
  }, {
    "name" : " void getScrollIndicatorBounds(@NonNull Rect out)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public boolean getClipChildren()",
    "returnType" : "boolean",
    "comment" : "\n     * Returns whether this group's children are clipped to their bounds before drawing.\n     * The default value is true.\n     * @see #setClipChildren(boolean)\n     *\n     * @return True if the group's children will be clipped to their bounds,\n     * false otherwise.\n     ",
    "links" : [ ]
  }, {
    "name" : "public void setClipChildren(boolean clipChildren)",
    "returnType" : "void",
    "comment" : "\n     * By default, children are clipped to their bounds before drawing. This\n     * allows view groups to override this behavior for animations, etc.\n     *\n     * @param clipChildren true to clip children to their bounds,\n     *        false otherwise\n     * @attr ref android.R.styleable#ViewGroup_clipChildren\n     ",
    "links" : [ ]
  }, {
    "name" : "public void setClipToPadding(boolean clipToPadding)",
    "returnType" : "void",
    "comment" : "\n     * Sets whether this ViewGroup will clip its children to its padding and resize (but not\n     * clip) any EdgeEffect to the padded region, if padding is present.\n     * <p>\n     * By default, children are clipped to the padding of their parent\n     * ViewGroup. This clipping behavior is only enabled if padding is non-zero.\n     *\n     * @param clipToPadding true to clip children to the padding of the group, and resize (but\n     *        not clip) any EdgeEffect to the padded region. False otherwise.\n     * @attr ref android.R.styleable#ViewGroup_clipToPadding\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean getClipToPadding()",
    "returnType" : "boolean",
    "comment" : "\n     * Returns whether this ViewGroup will clip its children to its padding, and resize (but\n     * not clip) any EdgeEffect to the padded region, if padding is present.\n     * <p>\n     * By default, children are clipped to the padding of their parent\n     * Viewgroup. This clipping behavior is only enabled if padding is non-zero.\n     *\n     * @return true if this ViewGroup clips children to its padding and resizes (but doesn't\n     *         clip) any EdgeEffect to the padded region, false otherwise.\n     *\n     * @attr ref android.R.styleable#ViewGroup_clipToPadding\n     ",
    "links" : [ ]
  }, {
    "name" : "public void dispatchSetSelected(boolean selected)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public void dispatchSetActivated(boolean activated)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "protected void dispatchSetPressed(boolean pressed)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public void dispatchDrawableHotspotChanged(float x, float y)",
    "returnType" : "void",
    "comment" : "\n     * Dispatches drawable hotspot changes to child views that meet at least\n     * one of the following criteria:\n     * <ul>\n     *     <li>Returns {@code false} from both {@link View#isClickable()} and\n     *     {@link View#isLongClickable()}</li>\n     *     <li>Requests duplication of parent state via\n     *     {@link View#setDuplicateParentStateEnabled(boolean)}</li>\n     * </ul>\n     *\n     * @param x hotspot x coordinate\n     * @param y hotspot y coordinate\n     * @see #drawableHotspotChanged(float, float)\n     ",
    "links" : [ "android.webkit.WebView#setDuplicateParentStateEnabled(boolean)", "android.webkit.WebView#isLongClickable()", "android.webkit.WebView#isClickable()" ]
  }, {
    "name" : " void dispatchCancelPendingInputEvents()",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "protected void setStaticTransformationsEnabled(boolean enabled)",
    "returnType" : "void",
    "comment" : "\n     * When this property is set to true, this ViewGroup supports static transformations on\n     * children; this causes\n     * {@link #getChildStaticTransformation(View, android.view.animation.Transformation)} to be\n     * invoked when a child is drawn.\n     *\n     * Any subclass overriding\n     * {@link #getChildStaticTransformation(View, android.view.animation.Transformation)} should\n     * set this property to true.\n     *\n     * @param enabled True to enable static transformations on children, false otherwise.\n     *\n     * @see #getChildStaticTransformation(View, android.view.animation.Transformation)\n     ",
    "links" : [ "#getChildStaticTransformation(View" ]
  }, {
    "name" : "protected boolean getChildStaticTransformation(View child, Transformation t)",
    "returnType" : "boolean",
    "comment" : "\n     * Sets  <code>t</code> to be the static transformation of the child, if set, returning a\n     * boolean to indicate whether a static transform was set. The default implementation\n     * simply returns <code>false</code>; subclasses may override this method for different\n     * behavior. {@link #setStaticTransformationsEnabled(boolean)} must be set to true\n     * for this method to be called.\n     *\n     * @param child The child view whose static transform is being requested\n     * @param t The Transformation which will hold the result\n     * @return true if the transformation was set, false otherwise\n     * @see #setStaticTransformationsEnabled(boolean)\n     ",
    "links" : [ "#setStaticTransformationsEnabled(boolean)" ]
  }, {
    "name" : " Transformation getChildTransformation()",
    "returnType" : "Transformation",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "protected T findViewTraversal(@IdRes int id)",
    "returnType" : "T",
    "comment" : "\n     * {@hide}\n     ",
    "links" : [ ]
  }, {
    "name" : "protected T findViewWithTagTraversal(Object tag)",
    "returnType" : "T",
    "comment" : "\n     * {@hide}\n     ",
    "links" : [ ]
  }, {
    "name" : "protected T findViewByPredicateTraversal(Predicate<View> predicate, View childToSkip)",
    "returnType" : "T",
    "comment" : "\n     * {@hide}\n     ",
    "links" : [ ]
  }, {
    "name" : "public void addTransientView(View view, int index)",
    "returnType" : "void",
    "comment" : "\n     * This method adds a view to this container at the specified index purely for the\n     * purposes of allowing that view to draw even though it is not a normal child of\n     * the container. That is, the view does not participate in layout, focus, accessibility,\n     * input, or other normal view operations; it is purely an item to be drawn during the normal\n     * rendering operation of this container. The index that it is added at is the order\n     * in which it will be drawn, with respect to the other views in the container.\n     * For example, a transient view added at index 0 will be drawn before all other views\n     * in the container because it will be drawn first (including before any real view\n     * at index 0). There can be more than one transient view at any particular index;\n     * these views will be drawn in the order in which they were added to the list of\n     * transient views. The index of transient views can also be greater than the number\n     * of normal views in the container; that just means that they will be drawn after all\n     * other views are drawn.\n     *\n     * <p>Note that since transient views do not participate in layout, they must be sized\n     * manually or, more typically, they should just use the size that they had before they\n     * were removed from their container.</p>\n     *\n     * <p>Transient views are useful for handling animations of views that have been removed\n     * from the container, but which should be animated out after the removal. Adding these\n     * views as transient views allows them to participate in drawing without side-effecting\n     * the layout of the container.</p>\n     *\n     * <p>Transient views must always be explicitly {@link #removeTransientView(View) removed}\n     * from the container when they are no longer needed. For example, a transient view\n     * which is added in order to fade it out in its old location should be removed\n     * once the animation is complete.</p>\n     *\n     * @param view The view to be added. The view must not have a parent.\n     * @param index The index at which this view should be drawn, must be >= 0.\n     * This value is relative to the {@link #getChildAt(int) index} values in the normal\n     * child list of this container, where any transient view at a particular index will\n     * be drawn before any normal child at that same index.\n     *\n     * @hide\n     ",
    "links" : [ "#removeTransientView(View)", "#getChildAt(int)" ]
  }, {
    "name" : "public void removeTransientView(View view)",
    "returnType" : "void",
    "comment" : "\n     * Removes a view from the list of transient views in this container. If there is no\n     * such transient view, this method does nothing.\n     *\n     * @param view The transient view to be removed\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public int getTransientViewCount()",
    "returnType" : "int",
    "comment" : "\n     * Returns the number of transient views in this container. Specific transient\n     * views and the index at which they were added can be retrieved via\n     * {@link #getTransientView(int)} and {@link #getTransientViewIndex(int)}.\n     *\n     * @see #addTransientView(View, int)\n     * @return The number of transient views in this container\n     *\n     * @hide\n     ",
    "links" : [ "#getTransientView(int)", "#getTransientViewIndex(int)" ]
  }, {
    "name" : "public int getTransientViewIndex(int position)",
    "returnType" : "int",
    "comment" : "\n     * Given a valid position within the list of transient views, returns the index of\n     * the transient view at that position.\n     *\n     * @param position The position of the index being queried. Must be at least 0\n     * and less than the value returned by {@link #getTransientViewCount()}.\n     * @return The index of the transient view stored in the given position if the\n     * position is valid, otherwise -1\n     *\n     * @hide\n     ",
    "links" : [ "#getTransientViewCount()" ]
  }, {
    "name" : "public View getTransientView(int position)",
    "returnType" : "View",
    "comment" : "\n     * Given a valid position within the list of transient views, returns the\n     * transient view at that position.\n     *\n     * @param position The position of the view being queried. Must be at least 0\n     * and less than the value returned by {@link #getTransientViewCount()}.\n     * @return The transient view stored in the given position if the\n     * position is valid, otherwise null\n     *\n     * @hide\n     ",
    "links" : [ "#getTransientViewCount()" ]
  }, {
    "name" : "public void addView(View child)",
    "returnType" : "void",
    "comment" : "\n     * <p>Adds a child view. If no layout parameters are already set on the child, the\n     * default parameters for this ViewGroup are set on the child.</p>\n     *\n     * <p><strong>Note:</strong> do not invoke this method from\n     * {@link #draw(android.graphics.Canvas)}, {@link #onDraw(android.graphics.Canvas)},\n     * {@link #dispatchDraw(android.graphics.Canvas)} or any related method.</p>\n     *\n     * @param child the child view to add\n     *\n     * @see #generateDefaultLayoutParams()\n     ",
    "links" : [ "#dispatchDraw(android.graphics.Canvas)", "#draw(android.graphics.Canvas)", "#onDraw(android.graphics.Canvas)" ]
  }, {
    "name" : "public void addView(View child, int index)",
    "returnType" : "void",
    "comment" : "\n     * Adds a child view. If no layout parameters are already set on the child, the\n     * default parameters for this ViewGroup are set on the child.\n     *\n     * <p><strong>Note:</strong> do not invoke this method from\n     * {@link #draw(android.graphics.Canvas)}, {@link #onDraw(android.graphics.Canvas)},\n     * {@link #dispatchDraw(android.graphics.Canvas)} or any related method.</p>\n     *\n     * @param child the child view to add\n     * @param index the position at which to add the child\n     *\n     * @see #generateDefaultLayoutParams()\n     ",
    "links" : [ "#dispatchDraw(android.graphics.Canvas)", "#draw(android.graphics.Canvas)", "#onDraw(android.graphics.Canvas)" ]
  }, {
    "name" : "public void addView(View child, int width, int height)",
    "returnType" : "void",
    "comment" : "\n     * Adds a child view with this ViewGroup's default layout parameters and the\n     * specified width and height.\n     *\n     * <p><strong>Note:</strong> do not invoke this method from\n     * {@link #draw(android.graphics.Canvas)}, {@link #onDraw(android.graphics.Canvas)},\n     * {@link #dispatchDraw(android.graphics.Canvas)} or any related method.</p>\n     *\n     * @param child the child view to add\n     ",
    "links" : [ "#dispatchDraw(android.graphics.Canvas)", "#draw(android.graphics.Canvas)", "#onDraw(android.graphics.Canvas)" ]
  }, {
    "name" : "public void addView(View child, LayoutParams params)",
    "returnType" : "void",
    "comment" : "\n     * Adds a child view with the specified layout parameters.\n     *\n     * <p><strong>Note:</strong> do not invoke this method from\n     * {@link #draw(android.graphics.Canvas)}, {@link #onDraw(android.graphics.Canvas)},\n     * {@link #dispatchDraw(android.graphics.Canvas)} or any related method.</p>\n     *\n     * @param child the child view to add\n     * @param params the layout parameters to set on the child\n     ",
    "links" : [ "#dispatchDraw(android.graphics.Canvas)", "#draw(android.graphics.Canvas)", "#onDraw(android.graphics.Canvas)" ]
  }, {
    "name" : "public void addView(View child, int index, LayoutParams params)",
    "returnType" : "void",
    "comment" : "\n     * Adds a child view with the specified layout parameters.\n     *\n     * <p><strong>Note:</strong> do not invoke this method from\n     * {@link #draw(android.graphics.Canvas)}, {@link #onDraw(android.graphics.Canvas)},\n     * {@link #dispatchDraw(android.graphics.Canvas)} or any related method.</p>\n     *\n     * @param child the child view to add\n     * @param index the position at which to add the child or -1 to add last\n     * @param params the layout parameters to set on the child\n     ",
    "links" : [ "#dispatchDraw(android.graphics.Canvas)", "#draw(android.graphics.Canvas)", "#onDraw(android.graphics.Canvas)" ]
  }, {
    "name" : "public void updateViewLayout(View view, ViewGroup.LayoutParams params)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "protected boolean checkLayoutParams(ViewGroup.LayoutParams p)",
    "returnType" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public void setOnHierarchyChangeListener(OnHierarchyChangeListener listener)",
    "returnType" : "void",
    "comment" : "\n     * Register a callback to be invoked when a child is added to or removed\n     * from this view.\n     *\n     * @param listener the callback to invoke on hierarchy change\n     ",
    "links" : [ ]
  }, {
    "name" : " void dispatchViewAdded(View child)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public void onViewAdded(View child)",
    "returnType" : "void",
    "comment" : "\n     * Called when a new child is added to this ViewGroup. Overrides should always\n     * call super.onViewAdded.\n     *\n     * @param child the added child view\n     ",
    "links" : [ ]
  }, {
    "name" : " void dispatchViewRemoved(View child)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public void onViewRemoved(View child)",
    "returnType" : "void",
    "comment" : "\n     * Called when a child view is removed from this ViewGroup. Overrides should always\n     * call super.onViewRemoved.\n     *\n     * @param child the removed child view\n     ",
    "links" : [ ]
  }, {
    "name" : "private void clearCachedLayoutMode()",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "protected void onAttachedToWindow()",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "protected void onDetachedFromWindow()",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "protected void destroyHardwareResources()",
    "returnType" : "void",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "protected boolean addViewInLayout(View child, int index, LayoutParams params)",
    "returnType" : "boolean",
    "comment" : "\n     * Adds a view during layout. This is useful if in your onLayout() method,\n     * you need to add more views (as does the list view for example).\n     *\n     * If index is negative, it means put it at the end of the list.\n     *\n     * @param child the view to add to the group\n     * @param index the index at which the child must be added or -1 to add last\n     * @param params the layout parameters to associate with the child\n     * @return true if the child was added, false otherwise\n     ",
    "links" : [ ]
  }, {
    "name" : "protected boolean addViewInLayout(View child, int index, LayoutParams params, boolean preventRequestLayout)",
    "returnType" : "boolean",
    "comment" : "\n     * Adds a view during layout. This is useful if in your onLayout() method,\n     * you need to add more views (as does the list view for example).\n     *\n     * If index is negative, it means put it at the end of the list.\n     *\n     * @param child the view to add to the group\n     * @param index the index at which the child must be added or -1 to add last\n     * @param params the layout parameters to associate with the child\n     * @param preventRequestLayout if true, calling this method will not trigger a\n     *        layout request on child\n     * @return true if the child was added, false otherwise\n     ",
    "links" : [ ]
  }, {
    "name" : "protected void cleanupLayoutState(View child)",
    "returnType" : "void",
    "comment" : "\n     * Prevents the specified child to be laid out during the next layout pass.\n     *\n     * @param child the child on which to perform the cleanup\n     ",
    "links" : [ ]
  }, {
    "name" : "private void addViewInner(View child, int index, LayoutParams params, boolean preventRequestLayout)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private void touchAccessibilityNodeProviderIfNeeded(View child)",
    "returnType" : "void",
    "comment" : "\n     * We may need to touch the provider to bring up the a11y layer. In a11y mode\n     * clients inspect the screen or the user touches it which triggers bringing up\n     * of the a11y infrastructure while in autofill mode we want the infra up and\n     * running from the beginning since we watch for a11y events to drive autofill.\n     ",
    "links" : [ ]
  }, {
    "name" : "private void addInArray(View child, int index)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private void removeFromArray(int index)",
    "returnType" : "void",
    "comment" : " This method also sets the child's mParent to null",
    "links" : [ ]
  }, {
    "name" : "private void removeFromArray(int start, int count)",
    "returnType" : "void",
    "comment" : " This method also sets the children's mParent to null",
    "links" : [ ]
  }, {
    "name" : "private void bindLayoutAnimation(View child)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "protected void attachLayoutAnimationParameters(View child, LayoutParams params, int index, int count)",
    "returnType" : "void",
    "comment" : "\n     * Subclasses should override this method to set layout animation\n     * parameters on the supplied child.\n     *\n     * @param child the child to associate with animation parameters\n     * @param params the child's layout parameters which hold the animation\n     *        parameters\n     * @param index the index of the child in the view group\n     * @param count the number of children in the view group\n     ",
    "links" : [ ]
  }, {
    "name" : "public void removeView(View view)",
    "returnType" : "void",
    "comment" : "\n     * {@inheritDoc}\n     *\n     * <p><strong>Note:</strong> do not invoke this method from\n     * {@link #draw(android.graphics.Canvas)}, {@link #onDraw(android.graphics.Canvas)},\n     * {@link #dispatchDraw(android.graphics.Canvas)} or any related method.</p>\n     ",
    "links" : [ "#dispatchDraw(android.graphics.Canvas)", "#draw(android.graphics.Canvas)", "#onDraw(android.graphics.Canvas)" ]
  }, {
    "name" : "public void removeViewInLayout(View view)",
    "returnType" : "void",
    "comment" : "\n     * Removes a view during layout. This is useful if in your onLayout() method,\n     * you need to remove more views.\n     *\n     * <p><strong>Note:</strong> do not invoke this method from\n     * {@link #draw(android.graphics.Canvas)}, {@link #onDraw(android.graphics.Canvas)},\n     * {@link #dispatchDraw(android.graphics.Canvas)} or any related method.</p>\n     *\n     * @param view the view to remove from the group\n     ",
    "links" : [ "#dispatchDraw(android.graphics.Canvas)", "#draw(android.graphics.Canvas)", "#onDraw(android.graphics.Canvas)" ]
  }, {
    "name" : "public void removeViewsInLayout(int start, int count)",
    "returnType" : "void",
    "comment" : "\n     * Removes a range of views during layout. This is useful if in your onLayout() method,\n     * you need to remove more views.\n     *\n     * <p><strong>Note:</strong> do not invoke this method from\n     * {@link #draw(android.graphics.Canvas)}, {@link #onDraw(android.graphics.Canvas)},\n     * {@link #dispatchDraw(android.graphics.Canvas)} or any related method.</p>\n     *\n     * @param start the index of the first view to remove from the group\n     * @param count the number of views to remove from the group\n     ",
    "links" : [ "#dispatchDraw(android.graphics.Canvas)", "#draw(android.graphics.Canvas)", "#onDraw(android.graphics.Canvas)" ]
  }, {
    "name" : "public void removeViewAt(int index)",
    "returnType" : "void",
    "comment" : "\n     * Removes the view at the specified position in the group.\n     *\n     * <p><strong>Note:</strong> do not invoke this method from\n     * {@link #draw(android.graphics.Canvas)}, {@link #onDraw(android.graphics.Canvas)},\n     * {@link #dispatchDraw(android.graphics.Canvas)} or any related method.</p>\n     *\n     * @param index the position in the group of the view to remove\n     ",
    "links" : [ "#dispatchDraw(android.graphics.Canvas)", "#draw(android.graphics.Canvas)", "#onDraw(android.graphics.Canvas)" ]
  }, {
    "name" : "public void removeViews(int start, int count)",
    "returnType" : "void",
    "comment" : "\n     * Removes the specified range of views from the group.\n     *\n     * <p><strong>Note:</strong> do not invoke this method from\n     * {@link #draw(android.graphics.Canvas)}, {@link #onDraw(android.graphics.Canvas)},\n     * {@link #dispatchDraw(android.graphics.Canvas)} or any related method.</p>\n     *\n     * @param start the first position in the group of the range of views to remove\n     * @param count the number of views to remove\n     ",
    "links" : [ "#dispatchDraw(android.graphics.Canvas)", "#draw(android.graphics.Canvas)", "#onDraw(android.graphics.Canvas)" ]
  }, {
    "name" : "private boolean removeViewInternal(View view)",
    "returnType" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private void removeViewInternal(int index, View view)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public void setLayoutTransition(LayoutTransition transition)",
    "returnType" : "void",
    "comment" : "\n     * Sets the LayoutTransition object for this ViewGroup. If the LayoutTransition object is\n     * not null, changes in layout which occur because of children being added to or removed from\n     * the ViewGroup will be animated according to the animations defined in that LayoutTransition\n     * object. By default, the transition object is null (so layout changes are not animated).\n     *\n     * <p>Replacing a non-null transition will cause that previous transition to be\n     * canceled, if it is currently running, to restore this container to\n     * its correct post-transition state.</p>\n     *\n     * @param transition The LayoutTransition object that will animated changes in layout. A value\n     * of <code>null</code> means no transition will run on layout changes.\n     * @attr ref android.R.styleable#ViewGroup_animateLayoutChanges\n     ",
    "links" : [ ]
  }, {
    "name" : "public LayoutTransition getLayoutTransition()",
    "returnType" : "LayoutTransition",
    "comment" : "\n     * Gets the LayoutTransition object for this ViewGroup. If the LayoutTransition object is\n     * not null, changes in layout which occur because of children being added to or removed from\n     * the ViewGroup will be animated according to the animations defined in that LayoutTransition\n     * object. By default, the transition object is null (so layout changes are not animated).\n     *\n     * @return LayoutTranstion The LayoutTransition object that will animated changes in layout.\n     * A value of <code>null</code> means no transition will run on layout changes.\n     ",
    "links" : [ ]
  }, {
    "name" : "private void removeViewsInternal(int start, int count)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public void removeAllViews()",
    "returnType" : "void",
    "comment" : "\n     * Call this method to remove all child views from the\n     * ViewGroup.\n     *\n     * <p><strong>Note:</strong> do not invoke this method from\n     * {@link #draw(android.graphics.Canvas)}, {@link #onDraw(android.graphics.Canvas)},\n     * {@link #dispatchDraw(android.graphics.Canvas)} or any related method.</p>\n     ",
    "links" : [ "#dispatchDraw(android.graphics.Canvas)", "#draw(android.graphics.Canvas)", "#onDraw(android.graphics.Canvas)" ]
  }, {
    "name" : "public void removeAllViewsInLayout()",
    "returnType" : "void",
    "comment" : "\n     * Called by a ViewGroup subclass to remove child views from itself,\n     * when it must first know its size on screen before it can calculate how many\n     * child views it will render. An example is a Gallery or a ListView, which\n     * may \"have\" 50 children, but actually only render the number of children\n     * that can currently fit inside the object on screen. Do not call\n     * this method unless you are extending ViewGroup and understand the\n     * view measuring and layout pipeline.\n     *\n     * <p><strong>Note:</strong> do not invoke this method from\n     * {@link #draw(android.graphics.Canvas)}, {@link #onDraw(android.graphics.Canvas)},\n     * {@link #dispatchDraw(android.graphics.Canvas)} or any related method.</p>\n     ",
    "links" : [ "#dispatchDraw(android.graphics.Canvas)", "#draw(android.graphics.Canvas)", "#onDraw(android.graphics.Canvas)" ]
  }, {
    "name" : "protected void removeDetachedView(View child, boolean animate)",
    "returnType" : "void",
    "comment" : "\n     * Finishes the removal of a detached view. This method will dispatch the detached from\n     * window event and notify the hierarchy change listener.\n     * <p>\n     * This method is intended to be lightweight and makes no assumptions about whether the\n     * parent or child should be redrawn. Proper use of this method will include also making\n     * any appropriate {@link #requestLayout()} or {@link #invalidate()} calls.\n     * For example, callers can {@link #post(Runnable) post} a {@link Runnable}\n     * which performs a {@link #requestLayout()} on the next frame, after all detach/remove\n     * calls are finished, causing layout to be run prior to redrawing the view hierarchy.\n     *\n     * @param child the child to be definitely removed from the view hierarchy\n     * @param animate if true and the view has an animation, the view is placed in the\n     *                disappearing views list, otherwise, it is detached from the window\n     *\n     * @see #attachViewToParent(View, int, android.view.ViewGroup.LayoutParams)\n     * @see #detachAllViewsFromParent()\n     * @see #detachViewFromParent(View)\n     * @see #detachViewFromParent(int)\n     ",
    "links" : [ "Runnable", "#post(Runnable)", "#requestLayout()", "#invalidate()" ]
  }, {
    "name" : "protected void attachViewToParent(View child, int index, LayoutParams params)",
    "returnType" : "void",
    "comment" : "\n     * Attaches a view to this view group. Attaching a view assigns this group as the parent,\n     * sets the layout parameters and puts the view in the list of children so that\n     * it can be retrieved by calling {@link #getChildAt(int)}.\n     * <p>\n     * This method is intended to be lightweight and makes no assumptions about whether the\n     * parent or child should be redrawn. Proper use of this method will include also making\n     * any appropriate {@link #requestLayout()} or {@link #invalidate()} calls.\n     * For example, callers can {@link #post(Runnable) post} a {@link Runnable}\n     * which performs a {@link #requestLayout()} on the next frame, after all detach/attach\n     * calls are finished, causing layout to be run prior to redrawing the view hierarchy.\n     * <p>\n     * This method should be called only for views which were detached from their parent.\n     *\n     * @param child the child to attach\n     * @param index the index at which the child should be attached\n     * @param params the layout parameters of the child\n     *\n     * @see #removeDetachedView(View, boolean)\n     * @see #detachAllViewsFromParent()\n     * @see #detachViewFromParent(View)\n     * @see #detachViewFromParent(int)\n     ",
    "links" : [ "Runnable", "#getChildAt(int)", "#post(Runnable)", "#requestLayout()", "#invalidate()" ]
  }, {
    "name" : "protected void detachViewFromParent(View child)",
    "returnType" : "void",
    "comment" : "\n     * Detaches a view from its parent. Detaching a view should be followed\n     * either by a call to\n     * {@link #attachViewToParent(View, int, android.view.ViewGroup.LayoutParams)}\n     * or a call to {@link #removeDetachedView(View, boolean)}. Detachment should only be\n     * temporary; reattachment or removal should happen within the same drawing cycle as\n     * detachment. When a view is detached, its parent is null and cannot be retrieved by a\n     * call to {@link #getChildAt(int)}.\n     *\n     * @param child the child to detach\n     *\n     * @see #detachViewFromParent(int)\n     * @see #detachViewsFromParent(int, int)\n     * @see #detachAllViewsFromParent()\n     * @see #attachViewToParent(View, int, android.view.ViewGroup.LayoutParams)\n     * @see #removeDetachedView(View, boolean)\n     ",
    "links" : [ "#attachViewToParent(View", "#getChildAt(int)", "#removeDetachedView(View" ]
  }, {
    "name" : "protected void detachViewFromParent(int index)",
    "returnType" : "void",
    "comment" : "\n     * Detaches a view from its parent. Detaching a view should be followed\n     * either by a call to\n     * {@link #attachViewToParent(View, int, android.view.ViewGroup.LayoutParams)}\n     * or a call to {@link #removeDetachedView(View, boolean)}. Detachment should only be\n     * temporary; reattachment or removal should happen within the same drawing cycle as\n     * detachment. When a view is detached, its parent is null and cannot be retrieved by a\n     * call to {@link #getChildAt(int)}.\n     *\n     * @param index the index of the child to detach\n     *\n     * @see #detachViewFromParent(View)\n     * @see #detachAllViewsFromParent()\n     * @see #detachViewsFromParent(int, int)\n     * @see #attachViewToParent(View, int, android.view.ViewGroup.LayoutParams)\n     * @see #removeDetachedView(View, boolean)\n     ",
    "links" : [ "#attachViewToParent(View", "#getChildAt(int)", "#removeDetachedView(View" ]
  }, {
    "name" : "protected void detachViewsFromParent(int start, int count)",
    "returnType" : "void",
    "comment" : "\n     * Detaches a range of views from their parents. Detaching a view should be followed\n     * either by a call to\n     * {@link #attachViewToParent(View, int, android.view.ViewGroup.LayoutParams)}\n     * or a call to {@link #removeDetachedView(View, boolean)}. Detachment should only be\n     * temporary; reattachment or removal should happen within the same drawing cycle as\n     * detachment. When a view is detached, its parent is null and cannot be retrieved by a\n     * call to {@link #getChildAt(int)}.\n     *\n     * @param start the first index of the childrend range to detach\n     * @param count the number of children to detach\n     *\n     * @see #detachViewFromParent(View)\n     * @see #detachViewFromParent(int)\n     * @see #detachAllViewsFromParent()\n     * @see #attachViewToParent(View, int, android.view.ViewGroup.LayoutParams)\n     * @see #removeDetachedView(View, boolean)\n     ",
    "links" : [ "#attachViewToParent(View", "#getChildAt(int)", "#removeDetachedView(View" ]
  }, {
    "name" : "protected void detachAllViewsFromParent()",
    "returnType" : "void",
    "comment" : "\n     * Detaches all views from the parent. Detaching a view should be followed\n     * either by a call to\n     * {@link #attachViewToParent(View, int, android.view.ViewGroup.LayoutParams)}\n     * or a call to {@link #removeDetachedView(View, boolean)}. Detachment should only be\n     * temporary; reattachment or removal should happen within the same drawing cycle as\n     * detachment. When a view is detached, its parent is null and cannot be retrieved by a\n     * call to {@link #getChildAt(int)}.\n     *\n     * @see #detachViewFromParent(View)\n     * @see #detachViewFromParent(int)\n     * @see #detachViewsFromParent(int, int)\n     * @see #attachViewToParent(View, int, android.view.ViewGroup.LayoutParams)\n     * @see #removeDetachedView(View, boolean)\n     ",
    "links" : [ "#attachViewToParent(View", "#getChildAt(int)", "#removeDetachedView(View" ]
  }, {
    "name" : "public void onDescendantInvalidated(@NonNull View child, @NonNull View target)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public final void invalidateChild(View child, final Rect dirty)",
    "returnType" : "void",
    "comment" : "\n     * Don't call or override this method. It is used for the implementation of\n     * the view hierarchy.\n     *\n     * @deprecated Use {@link #onDescendantInvalidated(View, View)} instead to observe updates to\n     * draw state in descendants.\n     ",
    "links" : [ "#onDescendantInvalidated(View" ]
  }, {
    "name" : "public ViewParent invalidateChildInParent(final int[] location, final Rect dirty)",
    "returnType" : "ViewParent",
    "comment" : "\n     * Don't call or override this method. It is used for the implementation of\n     * the view hierarchy.\n     *\n     * This implementation returns null if this ViewGroup does not have a parent,\n     * if this ViewGroup is already fully invalidated or if the dirty rectangle\n     * does not intersect with this ViewGroup's bounds.\n     *\n     * @deprecated Use {@link #onDescendantInvalidated(View, View)} instead to observe updates to\n     * draw state in descendants.\n     ",
    "links" : [ "#onDescendantInvalidated(View" ]
  }, {
    "name" : "public final void offsetDescendantRectToMyCoords(View descendant, Rect rect)",
    "returnType" : "void",
    "comment" : "\n     * Offset a rectangle that is in a descendant's coordinate\n     * space into our coordinate space.\n     * @param descendant A descendant of this view\n     * @param rect A rectangle defined in descendant's coordinate space.\n     ",
    "links" : [ ]
  }, {
    "name" : "public final void offsetRectIntoDescendantCoords(View descendant, Rect rect)",
    "returnType" : "void",
    "comment" : "\n     * Offset a rectangle that is in our coordinate space into an ancestor's\n     * coordinate space.\n     * @param descendant A descendant of this view\n     * @param rect A rectangle defined in descendant's coordinate space.\n     ",
    "links" : [ ]
  }, {
    "name" : " void offsetRectBetweenParentAndChild(View descendant, Rect rect, boolean offsetFromChildToParent, boolean clipToBounds)",
    "returnType" : "void",
    "comment" : "\n     * Helper method that offsets a rect either from parent to descendant or\n     * descendant to parent.\n     ",
    "links" : [ ]
  }, {
    "name" : "public void offsetChildrenTopAndBottom(int offset)",
    "returnType" : "void",
    "comment" : "\n     * Offset the vertical location of all children of this view by the specified number of pixels.\n     *\n     * @param offset the number of pixels to offset\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean getChildVisibleRect(View child, Rect r, android.graphics.Point offset)",
    "returnType" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public boolean getChildVisibleRect(View child, Rect r, android.graphics.Point offset, boolean forceParentCheck)",
    "returnType" : "boolean",
    "comment" : "\n     * @param forceParentCheck true to guarantee that this call will propagate to all ancestors,\n     *      false otherwise\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public final void layout(int l, int t, int r, int b)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "protected abstract void onLayout(boolean changed, int l, int t, int r, int b)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "protected boolean canAnimate()",
    "returnType" : "boolean",
    "comment" : "\n     * Indicates whether the view group has the ability to animate its children\n     * after the first layout.\n     *\n     * @return true if the children can be animated, false otherwise\n     ",
    "links" : [ ]
  }, {
    "name" : "public void startLayoutAnimation()",
    "returnType" : "void",
    "comment" : "\n     * Runs the layout animation. Calling this method triggers a relayout of\n     * this view group.\n     ",
    "links" : [ ]
  }, {
    "name" : "public void scheduleLayoutAnimation()",
    "returnType" : "void",
    "comment" : "\n     * Schedules the layout animation to be played after the next layout pass\n     * of this view group. This can be used to restart the layout animation\n     * when the content of the view group changes or when the activity is\n     * paused and resumed.\n     ",
    "links" : [ ]
  }, {
    "name" : "public void setLayoutAnimation(LayoutAnimationController controller)",
    "returnType" : "void",
    "comment" : "\n     * Sets the layout animation controller used to animate the group's\n     * children after the first layout.\n     *\n     * @param controller the animation controller\n     ",
    "links" : [ ]
  }, {
    "name" : "public LayoutAnimationController getLayoutAnimation()",
    "returnType" : "LayoutAnimationController",
    "comment" : "\n     * Returns the layout animation controller used to animate the group's\n     * children.\n     *\n     * @return the current animation controller\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean isAnimationCacheEnabled()",
    "returnType" : "boolean",
    "comment" : "\n     * Indicates whether the children's drawing cache is used during a layout\n     * animation. By default, the drawing cache is enabled but this will prevent\n     * nested layout animations from working. To nest animations, you must disable\n     * the cache.\n     *\n     * @return true if the animation cache is enabled, false otherwise\n     *\n     * @see #setAnimationCacheEnabled(boolean)\n     * @see View#setDrawingCacheEnabled(boolean)\n     *\n     * @deprecated As of {@link android.os.Build.VERSION_CODES#M}, this property is ignored.\n     * Caching behavior of children may be controlled through {@link View#setLayerType(int, Paint)}.\n     ",
    "links" : [ "android.webkit.WebView#setLayerType(int", "android.os.Build.VERSION_CODES#M" ]
  }, {
    "name" : "public void setAnimationCacheEnabled(boolean enabled)",
    "returnType" : "void",
    "comment" : "\n     * Enables or disables the children's drawing cache during a layout animation.\n     * By default, the drawing cache is enabled but this will prevent nested\n     * layout animations from working. To nest animations, you must disable the\n     * cache.\n     *\n     * @param enabled true to enable the animation cache, false otherwise\n     *\n     * @see #isAnimationCacheEnabled()\n     * @see View#setDrawingCacheEnabled(boolean)\n     *\n     * @deprecated As of {@link android.os.Build.VERSION_CODES#M}, this property is ignored.\n     * Caching behavior of children may be controlled through {@link View#setLayerType(int, Paint)}.\n     ",
    "links" : [ "android.webkit.WebView#setLayerType(int", "android.os.Build.VERSION_CODES#M" ]
  }, {
    "name" : "public boolean isAlwaysDrawnWithCacheEnabled()",
    "returnType" : "boolean",
    "comment" : "\n     * Indicates whether this ViewGroup will always try to draw its children using their\n     * drawing cache. By default this property is enabled.\n     *\n     * @return true if the animation cache is enabled, false otherwise\n     *\n     * @see #setAlwaysDrawnWithCacheEnabled(boolean)\n     * @see #setChildrenDrawnWithCacheEnabled(boolean)\n     * @see View#setDrawingCacheEnabled(boolean)\n     *\n     * @deprecated As of {@link android.os.Build.VERSION_CODES#M}, this property is ignored.\n     * Child views may no longer have their caching behavior disabled by parents.\n     ",
    "links" : [ "android.os.Build.VERSION_CODES#M" ]
  }, {
    "name" : "public void setAlwaysDrawnWithCacheEnabled(boolean always)",
    "returnType" : "void",
    "comment" : "\n     * Indicates whether this ViewGroup will always try to draw its children using their\n     * drawing cache. This property can be set to true when the cache rendering is\n     * slightly different from the children's normal rendering. Renderings can be different,\n     * for instance, when the cache's quality is set to low.\n     *\n     * When this property is disabled, the ViewGroup will use the drawing cache of its\n     * children only when asked to. It's usually the task of subclasses to tell ViewGroup\n     * when to start using the drawing cache and when to stop using it.\n     *\n     * @param always true to always draw with the drawing cache, false otherwise\n     *\n     * @see #isAlwaysDrawnWithCacheEnabled()\n     * @see #setChildrenDrawnWithCacheEnabled(boolean)\n     * @see View#setDrawingCacheEnabled(boolean)\n     * @see View#setDrawingCacheQuality(int)\n     *\n     * @deprecated As of {@link android.os.Build.VERSION_CODES#M}, this property is ignored.\n     * Child views may no longer have their caching behavior disabled by parents.\n     ",
    "links" : [ "android.os.Build.VERSION_CODES#M" ]
  }, {
    "name" : "protected boolean isChildrenDrawnWithCacheEnabled()",
    "returnType" : "boolean",
    "comment" : "\n     * Indicates whether the ViewGroup is currently drawing its children using\n     * their drawing cache.\n     *\n     * @return true if children should be drawn with their cache, false otherwise\n     *\n     * @see #setAlwaysDrawnWithCacheEnabled(boolean)\n     * @see #setChildrenDrawnWithCacheEnabled(boolean)\n     *\n     * @deprecated As of {@link android.os.Build.VERSION_CODES#M}, this property is ignored.\n     * Child views may no longer be forced to cache their rendering state by their parents.\n     * Use {@link View#setLayerType(int, Paint)} on individual Views instead.\n     ",
    "links" : [ "android.webkit.WebView#setLayerType(int", "android.os.Build.VERSION_CODES#M" ]
  }, {
    "name" : "protected void setChildrenDrawnWithCacheEnabled(boolean enabled)",
    "returnType" : "void",
    "comment" : "\n     * Tells the ViewGroup to draw its children using their drawing cache. This property\n     * is ignored when {@link #isAlwaysDrawnWithCacheEnabled()} is true. A child's drawing cache\n     * will be used only if it has been enabled.\n     *\n     * Subclasses should call this method to start and stop using the drawing cache when\n     * they perform performance sensitive operations, like scrolling or animating.\n     *\n     * @param enabled true if children should be drawn with their cache, false otherwise\n     *\n     * @see #setAlwaysDrawnWithCacheEnabled(boolean)\n     * @see #isChildrenDrawnWithCacheEnabled()\n     *\n     * @deprecated As of {@link android.os.Build.VERSION_CODES#M}, this property is ignored.\n     * Child views may no longer be forced to cache their rendering state by their parents.\n     * Use {@link View#setLayerType(int, Paint)} on individual Views instead.\n     ",
    "links" : [ "android.webkit.WebView#setLayerType(int", "#isAlwaysDrawnWithCacheEnabled()", "android.os.Build.VERSION_CODES#M" ]
  }, {
    "name" : "protected boolean isChildrenDrawingOrderEnabled()",
    "returnType" : "boolean",
    "comment" : "\n     * Indicates whether the ViewGroup is drawing its children in the order defined by\n     * {@link #getChildDrawingOrder(int, int)}.\n     *\n     * @return true if children drawing order is defined by {@link #getChildDrawingOrder(int, int)},\n     *         false otherwise\n     *\n     * @see #setChildrenDrawingOrderEnabled(boolean)\n     * @see #getChildDrawingOrder(int, int)\n     ",
    "links" : [ "#getChildDrawingOrder(int" ]
  }, {
    "name" : "protected void setChildrenDrawingOrderEnabled(boolean enabled)",
    "returnType" : "void",
    "comment" : "\n     * Tells the ViewGroup whether to draw its children in the order defined by the method\n     * {@link #getChildDrawingOrder(int, int)}.\n     * <p>\n     * Note that {@link View#getZ() Z} reordering, done by {@link #dispatchDraw(Canvas)},\n     * will override custom child ordering done via this method.\n     *\n     * @param enabled true if the order of the children when drawing is determined by\n     *        {@link #getChildDrawingOrder(int, int)}, false otherwise\n     *\n     * @see #isChildrenDrawingOrderEnabled()\n     * @see #getChildDrawingOrder(int, int)\n     ",
    "links" : [ "android.webkit.WebView#getZ()", "#dispatchDraw(Canvas)", "#getChildDrawingOrder(int" ]
  }, {
    "name" : "private boolean hasBooleanFlag(int flag)",
    "returnType" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private void setBooleanFlag(int flag, boolean value)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public int getPersistentDrawingCache()",
    "returnType" : "int",
    "comment" : "\n     * Returns an integer indicating what types of drawing caches are kept in memory.\n     *\n     * @see #setPersistentDrawingCache(int)\n     * @see #setAnimationCacheEnabled(boolean)\n     *\n     * @return one or a combination of {@link #PERSISTENT_NO_CACHE},\n     *         {@link #PERSISTENT_ANIMATION_CACHE}, {@link #PERSISTENT_SCROLLING_CACHE}\n     *         and {@link #PERSISTENT_ALL_CACHES}\n     *\n     * @deprecated The view drawing cache was largely made obsolete with the introduction of\n     * hardware-accelerated rendering in API 11. With hardware-acceleration, intermediate cache\n     * layers are largely unnecessary and can easily result in a net loss in performance due to the\n     * cost of creating and updating the layer. In the rare cases where caching layers are useful,\n     * such as for alpha animations, {@link #setLayerType(int, Paint)} handles this with hardware\n     * rendering. For software-rendered snapshots of a small part of the View hierarchy or\n     * individual Views it is recommended to create a {@link Canvas} from either a {@link Bitmap} or\n     * {@link android.graphics.Picture} and call {@link #draw(Canvas)} on the View. However these\n     * software-rendered usages are discouraged and have compatibility issues with hardware-only\n     * rendering features such as {@link android.graphics.Bitmap.Config#HARDWARE Config.HARDWARE}\n     * bitmaps, real-time shadows, and outline clipping. For screenshots of the UI for feedback\n     * reports or unit testing the {@link PixelCopy} API is recommended.\n     ",
    "links" : [ "android.graphics.Bitmap.Config#HARDWARE", "#setLayerType(int", "#PERSISTENT_ALL_CACHES", "android.graphics.Picture", "#draw(Canvas)", "android.graphics.Bitmap", "#PERSISTENT_NO_CACHE", "android.view.PixelCopy", "#PERSISTENT_ANIMATION_CACHE", "#PERSISTENT_SCROLLING_CACHE", "android.graphics.Canvas" ]
  }, {
    "name" : "public void setPersistentDrawingCache(int drawingCacheToKeep)",
    "returnType" : "void",
    "comment" : "\n     * Indicates what types of drawing caches should be kept in memory after\n     * they have been created.\n     *\n     * @see #getPersistentDrawingCache()\n     * @see #setAnimationCacheEnabled(boolean)\n     *\n     * @param drawingCacheToKeep one or a combination of {@link #PERSISTENT_NO_CACHE},\n     *        {@link #PERSISTENT_ANIMATION_CACHE}, {@link #PERSISTENT_SCROLLING_CACHE}\n     *        and {@link #PERSISTENT_ALL_CACHES}\n     *\n     * @deprecated The view drawing cache was largely made obsolete with the introduction of\n     * hardware-accelerated rendering in API 11. With hardware-acceleration, intermediate cache\n     * layers are largely unnecessary and can easily result in a net loss in performance due to the\n     * cost of creating and updating the layer. In the rare cases where caching layers are useful,\n     * such as for alpha animations, {@link #setLayerType(int, Paint)} handles this with hardware\n     * rendering. For software-rendered snapshots of a small part of the View hierarchy or\n     * individual Views it is recommended to create a {@link Canvas} from either a {@link Bitmap} or\n     * {@link android.graphics.Picture} and call {@link #draw(Canvas)} on the View. However these\n     * software-rendered usages are discouraged and have compatibility issues with hardware-only\n     * rendering features such as {@link android.graphics.Bitmap.Config#HARDWARE Config.HARDWARE}\n     * bitmaps, real-time shadows, and outline clipping. For screenshots of the UI for feedback\n     * reports or unit testing the {@link PixelCopy} API is recommended.\n     ",
    "links" : [ "android.graphics.Bitmap.Config#HARDWARE", "#setLayerType(int", "#PERSISTENT_ALL_CACHES", "android.graphics.Picture", "#draw(Canvas)", "android.graphics.Bitmap", "#PERSISTENT_NO_CACHE", "android.view.PixelCopy", "#PERSISTENT_ANIMATION_CACHE", "#PERSISTENT_SCROLLING_CACHE", "android.graphics.Canvas" ]
  }, {
    "name" : "private void setLayoutMode(int layoutMode, boolean explicitly)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : " void invalidateInheritedLayoutMode(int layoutModeOfRoot)",
    "returnType" : "void",
    "comment" : "\n     * Recursively traverse the view hierarchy, resetting the layoutMode of any\n     * descendants that had inherited a different layoutMode from a previous parent.\n     * Recursion terminates when a descendant's mode is:\n     * <ul>\n     *     <li>Undefined</li>\n     *     <li>The same as the root node's</li>\n     *     <li>A mode that had been explicitly set</li>\n     * <ul/>\n     * The first two clauses are optimizations.\n     * @param layoutModeOfRoot\n     ",
    "links" : [ ]
  }, {
    "name" : "public int getLayoutMode()",
    "returnType" : "int",
    "comment" : "\n     * Returns the basis of alignment during layout operations on this ViewGroup:\n     * either {@link #LAYOUT_MODE_CLIP_BOUNDS} or {@link #LAYOUT_MODE_OPTICAL_BOUNDS}.\n     * <p>\n     * If no layoutMode was explicitly set, either programmatically or in an XML resource,\n     * the method returns the layoutMode of the view's parent ViewGroup if such a parent exists,\n     * otherwise the method returns a default value of {@link #LAYOUT_MODE_CLIP_BOUNDS}.\n     *\n     * @return the layout mode to use during layout operations\n     *\n     * @see #setLayoutMode(int)\n     ",
    "links" : [ "#LAYOUT_MODE_OPTICAL_BOUNDS", "#LAYOUT_MODE_CLIP_BOUNDS" ]
  }, {
    "name" : "public void setLayoutMode(int layoutMode)",
    "returnType" : "void",
    "comment" : "\n     * Sets the basis of alignment during the layout of this ViewGroup.\n     * Valid values are either {@link #LAYOUT_MODE_CLIP_BOUNDS} or\n     * {@link #LAYOUT_MODE_OPTICAL_BOUNDS}.\n     *\n     * @param layoutMode the layout mode to use during layout operations\n     *\n     * @see #getLayoutMode()\n     * @attr ref android.R.styleable#ViewGroup_layoutMode\n     ",
    "links" : [ "#LAYOUT_MODE_OPTICAL_BOUNDS", "#LAYOUT_MODE_CLIP_BOUNDS" ]
  }, {
    "name" : "public LayoutParams generateLayoutParams(AttributeSet attrs)",
    "returnType" : "LayoutParams",
    "comment" : "\n     * Returns a new set of layout parameters based on the supplied attributes set.\n     *\n     * @param attrs the attributes to build the layout parameters from\n     *\n     * @return an instance of {@link android.view.ViewGroup.LayoutParams} or one\n     *         of its descendants\n     ",
    "links" : [ "android.view.ViewGroup.LayoutParams" ]
  }, {
    "name" : "protected LayoutParams generateLayoutParams(ViewGroup.LayoutParams p)",
    "returnType" : "LayoutParams",
    "comment" : "\n     * Returns a safe set of layout parameters based on the supplied layout params.\n     * When a ViewGroup is passed a View whose layout params do not pass the test of\n     * {@link #checkLayoutParams(android.view.ViewGroup.LayoutParams)}, this method\n     * is invoked. This method should return a new set of layout params suitable for\n     * this ViewGroup, possibly by copying the appropriate attributes from the\n     * specified set of layout params.\n     *\n     * @param p The layout parameters to convert into a suitable set of layout parameters\n     *          for this ViewGroup.\n     *\n     * @return an instance of {@link android.view.ViewGroup.LayoutParams} or one\n     *         of its descendants\n     ",
    "links" : [ "#checkLayoutParams(android.view.ViewGroup.LayoutParams)", "android.view.ViewGroup.LayoutParams" ]
  }, {
    "name" : "protected LayoutParams generateDefaultLayoutParams()",
    "returnType" : "LayoutParams",
    "comment" : "\n     * Returns a set of default layout parameters. These parameters are requested\n     * when the View passed to {@link #addView(View)} has no layout parameters\n     * already set. If null is returned, an exception is thrown from addView.\n     *\n     * @return a set of default layout parameters or null\n     ",
    "links" : [ "#addView(View)" ]
  }, {
    "name" : "protected void debug(int depth)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public int indexOfChild(View child)",
    "returnType" : "int",
    "comment" : "\n     * Returns the position in the group of the specified child view.\n     *\n     * @param child the view for which to get the position\n     * @return a positive integer representing the position of the view in the\n     *         group, or -1 if the view does not exist in the group\n     ",
    "links" : [ ]
  }, {
    "name" : "public int getChildCount()",
    "returnType" : "int",
    "comment" : "\n     * Returns the number of children in the group.\n     *\n     * @return a positive integer representing the number of children in\n     *         the group\n     ",
    "links" : [ ]
  }, {
    "name" : "public View getChildAt(int index)",
    "returnType" : "View",
    "comment" : "\n     * Returns the view at the specified position in the group.\n     *\n     * @param index the position at which to get the view from\n     * @return the view at the specified position or null if the position\n     *         does not exist within the group\n     ",
    "links" : [ ]
  }, {
    "name" : "protected void measureChildren(int widthMeasureSpec, int heightMeasureSpec)",
    "returnType" : "void",
    "comment" : "\n     * Ask all of the children of this view to measure themselves, taking into\n     * account both the MeasureSpec requirements for this view and its padding.\n     * We skip children that are in the GONE state The heavy lifting is done in\n     * getChildMeasureSpec.\n     *\n     * @param widthMeasureSpec The width requirements for this view\n     * @param heightMeasureSpec The height requirements for this view\n     ",
    "links" : [ ]
  }, {
    "name" : "protected void measureChild(View child, int parentWidthMeasureSpec, int parentHeightMeasureSpec)",
    "returnType" : "void",
    "comment" : "\n     * Ask one of the children of this view to measure itself, taking into\n     * account both the MeasureSpec requirements for this view and its padding.\n     * The heavy lifting is done in getChildMeasureSpec.\n     *\n     * @param child The child to measure\n     * @param parentWidthMeasureSpec The width requirements for this view\n     * @param parentHeightMeasureSpec The height requirements for this view\n     ",
    "links" : [ ]
  }, {
    "name" : "protected void measureChildWithMargins(View child, int parentWidthMeasureSpec, int widthUsed, int parentHeightMeasureSpec, int heightUsed)",
    "returnType" : "void",
    "comment" : "\n     * Ask one of the children of this view to measure itself, taking into\n     * account both the MeasureSpec requirements for this view and its padding\n     * and margins. The child must have MarginLayoutParams The heavy lifting is\n     * done in getChildMeasureSpec.\n     *\n     * @param child The child to measure\n     * @param parentWidthMeasureSpec The width requirements for this view\n     * @param widthUsed Extra space that has been used up by the parent\n     *        horizontally (possibly by other children of the parent)\n     * @param parentHeightMeasureSpec The height requirements for this view\n     * @param heightUsed Extra space that has been used up by the parent\n     *        vertically (possibly by other children of the parent)\n     ",
    "links" : [ ]
  }, {
    "name" : "public static int getChildMeasureSpec(int spec, int padding, int childDimension)",
    "returnType" : "int",
    "comment" : "\n     * Does the hard part of measureChildren: figuring out the MeasureSpec to\n     * pass to a particular child. This method figures out the right MeasureSpec\n     * for one dimension (height or width) of one child view.\n     *\n     * The goal is to combine information from our MeasureSpec with the\n     * LayoutParams of the child to get the best possible results. For example,\n     * if the this view knows its size (because its MeasureSpec has a mode of\n     * EXACTLY), and the child has indicated in its LayoutParams that it wants\n     * to be the same size as the parent, the parent should ask the child to\n     * layout given an exact size.\n     *\n     * @param spec The requirements for this view\n     * @param padding The padding of this view for the current dimension and\n     *        margins, if applicable\n     * @param childDimension How big the child wants to be in the current\n     *        dimension\n     * @return a MeasureSpec integer for the child\n     ",
    "links" : [ ]
  }, {
    "name" : "public void clearDisappearingChildren()",
    "returnType" : "void",
    "comment" : "\n     * Removes any pending animations for views that have been removed. Call\n     * this if you don't want animations for exiting views to stack up.\n     ",
    "links" : [ ]
  }, {
    "name" : "private void addDisappearingView(View v)",
    "returnType" : "void",
    "comment" : "\n     * Add a view which is removed from mChildren but still needs animation\n     *\n     * @param v View to add\n     ",
    "links" : [ ]
  }, {
    "name" : " void finishAnimatingView(final View view, Animation animation)",
    "returnType" : "void",
    "comment" : "\n     * Cleanup a view when its animation is done. This may mean removing it from\n     * the list of disappearing views.\n     *\n     * @param view The view whose animation has finished\n     * @param animation The animation, cannot be null\n     ",
    "links" : [ ]
  }, {
    "name" : " boolean isViewTransitioning(View view)",
    "returnType" : "boolean",
    "comment" : "\n     * Utility function called by View during invalidation to determine whether a view that\n     * is invisible or gone should still be invalidated because it is being transitioned (and\n     * therefore still needs to be drawn).\n     ",
    "links" : [ ]
  }, {
    "name" : "public void startViewTransition(View view)",
    "returnType" : "void",
    "comment" : "\n     * This method tells the ViewGroup that the given View object, which should have this\n     * ViewGroup as its parent,\n     * should be kept around  (re-displayed when the ViewGroup draws its children) even if it\n     * is removed from its parent. This allows animations, such as those used by\n     * {@link android.app.Fragment} and {@link android.animation.LayoutTransition} to animate\n     * the removal of views. A call to this method should always be accompanied by a later call\n     * to {@link #endViewTransition(View)}, such as after an animation on the View has finished,\n     * so that the View finally gets removed.\n     *\n     * @param view The View object to be kept visible even if it gets removed from its parent.\n     ",
    "links" : [ "android.app.Fragment", "android.animation.LayoutTransition", "#endViewTransition(View)" ]
  }, {
    "name" : "public void endViewTransition(View view)",
    "returnType" : "void",
    "comment" : "\n     * This method should always be called following an earlier call to\n     * {@link #startViewTransition(View)}. The given View is finally removed from its parent\n     * and will no longer be displayed. Note that this method does not perform the functionality\n     * of removing a view from its parent; it just discontinues the display of a View that\n     * has previously been removed.\n     *\n     * @return view The View object that has been removed but is being kept around in the visible\n     * hierarchy by an earlier call to {@link #startViewTransition(View)}.\n     ",
    "links" : [ "#startViewTransition(View)" ]
  }, {
    "name" : "public void suppressLayout(boolean suppress)",
    "returnType" : "void",
    "comment" : "\n     * Tells this ViewGroup to suppress all layout() calls until layout\n     * suppression is disabled with a later call to suppressLayout(false).\n     * When layout suppression is disabled, a requestLayout() call is sent\n     * if layout() was attempted while layout was being suppressed.\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean isLayoutSuppressed()",
    "returnType" : "boolean",
    "comment" : "\n     * Returns whether layout calls on this container are currently being\n     * suppressed, due to an earlier call to {@link #suppressLayout(boolean)}.\n     *\n     * @return true if layout calls are currently suppressed, false otherwise.\n     ",
    "links" : [ "#suppressLayout(boolean)" ]
  }, {
    "name" : "public boolean gatherTransparentRegion(Region region)",
    "returnType" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public void requestTransparentRegion(View child)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public void subtractObscuredTouchableRegion(Region touchableRegion, View view)",
    "returnType" : "void",
    "comment" : "\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean getChildLocalHitRegion(@NonNull View child, @NonNull Region region, @NonNull Matrix matrix, boolean isHover)",
    "returnType" : "boolean",
    "comment" : "\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "private boolean isOnTop(View view, View otherView, ArrayList<View> preorderedList)",
    "returnType" : "boolean",
    "comment" : "\n     * Return true if the given {@code view} is drawn on top of the {@code otherView}.\n     * Both the {@code view} and {@code otherView} must be children of this ViewGroup.\n     * Otherwise, the returned value is meaningless.\n     ",
    "links" : [ ]
  }, {
    "name" : "private static void applyOpToRegionByBounds(Region region, View view, Region.Op op)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public WindowInsets dispatchApplyWindowInsets(WindowInsets insets)",
    "returnType" : "WindowInsets",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private WindowInsets brokenDispatchApplyWindowInsets(WindowInsets insets)",
    "returnType" : "WindowInsets",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private WindowInsets newDispatchApplyWindowInsets(WindowInsets insets)",
    "returnType" : "WindowInsets",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public void setWindowInsetsAnimationCallback(@Nullable WindowInsetsAnimation.Callback callback)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public boolean hasWindowInsetsAnimationCallback()",
    "returnType" : "boolean",
    "comment" : "\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public void dispatchWindowInsetsAnimationPrepare(@NonNull WindowInsetsAnimation animation)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public Bounds dispatchWindowInsetsAnimationStart(@NonNull WindowInsetsAnimation animation, @NonNull Bounds bounds)",
    "returnType" : "Bounds",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public WindowInsets dispatchWindowInsetsAnimationProgress(@NonNull WindowInsets insets, @NonNull List<WindowInsetsAnimation> runningAnimations)",
    "returnType" : "WindowInsets",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public void dispatchWindowInsetsAnimationEnd(@NonNull WindowInsetsAnimation animation)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public void dispatchScrollCaptureSearch(@NonNull Rect localVisibleRect, @NonNull Point windowOffset, @NonNull Consumer<ScrollCaptureTarget> targets)",
    "returnType" : "void",
    "comment" : "\n     * Handle the scroll capture search request by checking this view if applicable, then to each\n     * child view.\n     *\n     * @param localVisibleRect the visible area of this ViewGroup in local coordinates, according to\n     *                         the parent\n     * @param windowOffset     the offset of this view within the window\n     * @param targets          accepts potential scroll capture targets; {@link Consumer#accept\n     *                         results.accept} may be called zero or more times on the calling\n     *                         thread before onScrollCaptureSearch returns\n     ",
    "links" : [ "java.util.function.Consumer#acceptresults.accept" ]
  }, {
    "name" : "public Animation.AnimationListener getLayoutAnimationListener()",
    "returnType" : "Animation.AnimationListener",
    "comment" : "\n     * Returns the animation listener to which layout animation events are\n     * sent.\n     *\n     * @return an {@link android.view.animation.Animation.AnimationListener}\n     ",
    "links" : [ "android.view.animation.Animation.AnimationListener" ]
  }, {
    "name" : "protected void drawableStateChanged()",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public void jumpDrawablesToCurrentState()",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "protected int[] onCreateDrawableState(int extraSpace)",
    "returnType" : "int[]",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public void setAddStatesFromChildren(boolean addsStates)",
    "returnType" : "void",
    "comment" : "\n     * Sets whether this ViewGroup's drawable states also include\n     * its children's drawable states.  This is used, for example, to\n     * make a group appear to be focused when its child EditText or button\n     * is focused.\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean addStatesFromChildren()",
    "returnType" : "boolean",
    "comment" : "\n     * Returns whether this ViewGroup's drawable states also include\n     * its children's drawable states.  This is used, for example, to\n     * make a group appear to be focused when its child EditText or button\n     * is focused.\n     ",
    "links" : [ ]
  }, {
    "name" : "public void childDrawableStateChanged(View child)",
    "returnType" : "void",
    "comment" : "\n     * If {@link #addStatesFromChildren} is true, refreshes this group's\n     * drawable state (to include the states from its children).\n     ",
    "links" : [ "#addStatesFromChildren" ]
  }, {
    "name" : "public void setLayoutAnimationListener(Animation.AnimationListener animationListener)",
    "returnType" : "void",
    "comment" : "\n     * Specifies the animation listener to which layout animation events must\n     * be sent. Only\n     * {@link android.view.animation.Animation.AnimationListener#onAnimationStart(Animation)}\n     * and\n     * {@link android.view.animation.Animation.AnimationListener#onAnimationEnd(Animation)}\n     * are invoked.\n     *\n     * @param animationListener the layout animation listener\n     ",
    "links" : [ "android.view.animation.Animation.AnimationListener#onAnimationEnd(Animation)", "android.view.animation.Animation.AnimationListener#onAnimationStart(Animation)" ]
  }, {
    "name" : "public void requestTransitionStart(LayoutTransition transition)",
    "returnType" : "void",
    "comment" : "\n     * This method is called by LayoutTransition when there are 'changing' animations that need\n     * to start after the layout/setup phase. The request is forwarded to the ViewAncestor, who\n     * starts all pending transitions prior to the drawing phase in the current traversal.\n     *\n     * @param transition The LayoutTransition to be started on the next traversal.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean resolveRtlPropertiesIfNeeded()",
    "returnType" : "boolean",
    "comment" : "\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean resolveLayoutDirection()",
    "returnType" : "boolean",
    "comment" : "\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean resolveTextDirection()",
    "returnType" : "boolean",
    "comment" : "\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean resolveTextAlignment()",
    "returnType" : "boolean",
    "comment" : "\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public void resolvePadding()",
    "returnType" : "void",
    "comment" : "\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "protected void resolveDrawables()",
    "returnType" : "void",
    "comment" : "\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public void resolveLayoutParams()",
    "returnType" : "void",
    "comment" : "\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public void resetResolvedLayoutDirection()",
    "returnType" : "void",
    "comment" : "\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public void resetResolvedTextDirection()",
    "returnType" : "void",
    "comment" : "\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public void resetResolvedTextAlignment()",
    "returnType" : "void",
    "comment" : "\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public void resetResolvedPadding()",
    "returnType" : "void",
    "comment" : "\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "protected void resetResolvedDrawables()",
    "returnType" : "void",
    "comment" : "\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean shouldDelayChildPressedState()",
    "returnType" : "boolean",
    "comment" : "\n     * Return true if the pressed state should be delayed for children or descendants of this\n     * ViewGroup. Generally, this should be done for containers that can scroll, such as a List.\n     * This prevents the pressed state from appearing when the user is actually trying to scroll\n     * the content.\n     *\n     * The default implementation returns true for compatibility reasons. Subclasses that do\n     * not scroll should generally override this method and return false.\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean onStartNestedScroll(View child, View target, int nestedScrollAxes)",
    "returnType" : "boolean",
    "comment" : "\n     * @inheritDoc\n     ",
    "links" : [ ]
  }, {
    "name" : "public void onNestedScrollAccepted(View child, View target, int axes)",
    "returnType" : "void",
    "comment" : "\n     * @inheritDoc\n     ",
    "links" : [ ]
  }, {
    "name" : "public void onStopNestedScroll(View child)",
    "returnType" : "void",
    "comment" : "\n     * @inheritDoc\n     *\n     * <p>The default implementation of onStopNestedScroll calls\n     * {@link #stopNestedScroll()} to halt any recursive nested scrolling in progress.</p>\n     ",
    "links" : [ "#stopNestedScroll()" ]
  }, {
    "name" : "public void onNestedScroll(View target, int dxConsumed, int dyConsumed, int dxUnconsumed, int dyUnconsumed)",
    "returnType" : "void",
    "comment" : "\n     * @inheritDoc\n     ",
    "links" : [ ]
  }, {
    "name" : "public void onNestedPreScroll(View target, int dx, int dy, int[] consumed)",
    "returnType" : "void",
    "comment" : "\n     * @inheritDoc\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean onNestedFling(View target, float velocityX, float velocityY, boolean consumed)",
    "returnType" : "boolean",
    "comment" : "\n     * @inheritDoc\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean onNestedPreFling(View target, float velocityX, float velocityY)",
    "returnType" : "boolean",
    "comment" : "\n     * @inheritDoc\n     ",
    "links" : [ ]
  }, {
    "name" : "public int getNestedScrollAxes()",
    "returnType" : "int",
    "comment" : "\n     * Return the current axes of nested scrolling for this ViewGroup.\n     *\n     * <p>A ViewGroup returning something other than {@link #SCROLL_AXIS_NONE} is currently\n     * acting as a nested scrolling parent for one or more descendant views in the hierarchy.</p>\n     *\n     * @return Flags indicating the current axes of nested scrolling\n     * @see #SCROLL_AXIS_HORIZONTAL\n     * @see #SCROLL_AXIS_VERTICAL\n     * @see #SCROLL_AXIS_NONE\n     ",
    "links" : [ "#SCROLL_AXIS_NONE" ]
  }, {
    "name" : "protected void onSetLayoutParams(View child, LayoutParams layoutParams)",
    "returnType" : "void",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "public void captureTransitioningViews(List<View> transitioningViews)",
    "returnType" : "void",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "public void findNamedViews(Map<String, View> namedElements)",
    "returnType" : "void",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : " boolean hasUnhandledKeyListener()",
    "returnType" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : " void incrementChildUnhandledKeyListeners()",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : " void decrementChildUnhandledKeyListeners()",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : " View dispatchUnhandledKeyEvent(KeyEvent evt)",
    "returnType" : "View",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private static void drawRect(@NonNull Canvas canvas, Paint paint, int x1, int y1, int x2, int y2)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "protected void encodeProperties(@NonNull ViewHierarchyEncoder encoder)",
    "returnType" : "void",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "public final void onDescendantUnbufferedRequested()",
    "returnType" : "void",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "public void dispatchCreateViewTranslationRequest(@NonNull Map<AutofillId, long[]> viewIds, @NonNull @DataFormat int[] supportedFormats, @Nullable TranslationCapability capability, @NonNull List<ViewTranslationRequest> requests)",
    "returnType" : "void",
    "comment" : "\n     * {@inheritDoc}\n     *\n     * The implementation calls {@link #dispatchCreateViewTranslationRequest} for all the child\n     * views.\n     ",
    "links" : [ "#dispatchCreateViewTranslationRequest" ]
  }, {
    "name" : "public OnBackInvokedDispatcher findOnBackInvokedDispatcherForChild(@NonNull View child, @NonNull View requester)",
    "returnType" : "OnBackInvokedDispatcher",
    "comment" : "\n     * Walk up the View hierarchy to find the nearest {@link OnBackInvokedDispatcher}.\n     *\n     * @return The {@link OnBackInvokedDispatcher} from this or the nearest\n     * ancestor, or null if the view is both not attached and have no ancestor providing an\n     * {@link OnBackInvokedDispatcher}.\n     *\n     * @param child The direct child of this view for which to find a dispatcher.\n     * @param requester The requester that will use the dispatcher. Can be the same as child.\n     ",
    "links" : [ "android.window.OnBackInvokedDispatcher" ]
  } ],
  "methodNames" : [ "private void initViewGroup()", "private void initFromAttributes(Context context, AttributeSet attrs, int defStyleAttr, int defStyleRes)", "public int getDescendantFocusability()", "public void setDescendantFocusability(int focusability)", " void handleFocusGainInternal(int direction, Rect previouslyFocusedRect)", "public void requestChildFocus(View child, View focused)", " void setDefaultFocus(View child)", " void clearDefaultFocus(View child)", " boolean hasDefaultFocus()", " void clearFocusedInCluster(View child)", " void clearFocusedInCluster()", "public void focusableViewAvailable(View v)", "public boolean showContextMenuForChild(View originalView)", "public final boolean isShowingContextMenuWithCoords()", "public boolean showContextMenuForChild(View originalView, float x, float y)", "public ActionMode startActionModeForChild(View originalView, ActionMode.Callback callback)", "public ActionMode startActionModeForChild(View originalView, ActionMode.Callback callback, int type)", "public boolean dispatchActivityResult(String who, int requestCode, int resultCode, Intent data)", "public View focusSearch(View focused, int direction)", "public boolean requestChildRectangleOnScreen(View child, Rect rectangle, boolean immediate)", "public boolean requestSendAccessibilityEvent(View child, AccessibilityEvent event)", "public boolean onRequestSendAccessibilityEvent(View child, AccessibilityEvent event)", "public boolean onRequestSendAccessibilityEventInternal(View child, AccessibilityEvent event)", "public void childHasTransientStateChanged(View child, boolean childHasTransientState)", "public boolean hasTransientState()", "public boolean dispatchUnhandledMove(View focused, int direction)", "public void clearChildFocus(View child)", "public void clearFocus()", " void unFocus(View focused)", "public View getFocusedChild()", " View getDeepestFocusedChild()", "public boolean hasFocus()", "public View findFocus()", " boolean hasFocusable(boolean allowAutoFocus, boolean dispatchExplicit)", " boolean hasFocusableChild(boolean dispatchExplicit)", "public void addFocusables(ArrayList<View> views, int direction, int focusableMode)", "public void addKeyboardNavigationClusters(Collection<View> views, int direction)", "public void setTouchscreenBlocksFocus(boolean touchscreenBlocksFocus)", "private void setTouchscreenBlocksFocusNoRefocus(boolean touchscreenBlocksFocus)", "public boolean getTouchscreenBlocksFocus()", " boolean shouldBlockFocusForTouchscreen()", "public void findViewsWithText(ArrayList<View> outViews, CharSequence text, int flags)", "public View findViewByAccessibilityIdTraversal(int accessibilityId)", "public View findViewByAutofillIdTraversal(int autofillId)", "public void dispatchWindowFocusChanged(boolean hasFocus)", "public void addTouchables(ArrayList<View> views)", "public void makeOptionalFitsSystemWindows()", "public void makeFrameworkOptionalFitsSystemWindows()", "public void dispatchDisplayHint(int hint)", "protected void onChildVisibilityChanged(View child, int oldVisibility, int newVisibility)", "protected void dispatchVisibilityChanged(View changedView, int visibility)", "public void dispatchWindowVisibilityChanged(int visibility)", " boolean dispatchVisibilityAggregated(boolean isVisible)", "public void dispatchConfigurationChanged(Configuration newConfig)", "public void recomputeViewAttributes(View child)", " void dispatchCollectViewAttributes(AttachInfo attachInfo, int visibility)", "public void bringChildToFront(View child)", "private PointF getLocalPoint()", " boolean dispatchDragEnterExitInPreN(DragEvent event)", "public boolean dispatchDragEvent(DragEvent event)", " View findFrontmostDroppableChildAt(float x, float y, PointF outLocalPoint)", " boolean notifyChildOfDragStart(View child)", "public void dispatchWindowSystemUiVisiblityChanged(int visible)", "public void dispatchSystemUiVisibilityChanged(int visible)", " boolean updateLocalSystemUiVisibility(int localValue, int localChanges)", "public boolean dispatchKeyEventPreIme(KeyEvent event)", "public boolean dispatchKeyEvent(KeyEvent event)", "public boolean dispatchKeyShortcutEvent(KeyEvent event)", "public boolean dispatchTrackballEvent(MotionEvent event)", "public boolean dispatchCapturedPointerEvent(MotionEvent event)", "public void dispatchPointerCaptureChanged(boolean hasCapture)", "public PointerIcon onResolvePointerIcon(MotionEvent event, int pointerIndex)", "private PointerIcon dispatchResolvePointerIcon(MotionEvent event, int pointerIndex, View child)", "private int getAndVerifyPreorderedIndex(int childrenCount, int i, boolean customOrder)", "protected boolean dispatchHoverEvent(MotionEvent event)", "private void exitHoverTargets()", "private void cancelHoverTarget(View view)", " boolean dispatchTooltipHoverEvent(MotionEvent event)", "private boolean dispatchTooltipHoverEvent(MotionEvent event, View child)", "private void exitTooltipHoverTargets()", "protected boolean hasHoveredChild()", "protected boolean pointInHoveredChild(MotionEvent event)", "public void addChildrenForAccessibility(ArrayList<View> outChildren)", "public boolean onInterceptHoverEvent(MotionEvent event)", "private static MotionEvent obtainMotionEventNoHistoryOrSelf(MotionEvent event)", "protected boolean dispatchGenericPointerEvent(MotionEvent event)", "protected boolean dispatchGenericFocusedEvent(MotionEvent event)", "private boolean dispatchTransformedGenericPointerEvent(MotionEvent event, View child)", "private MotionEvent getTransformedMotionEvent(MotionEvent event, View child)", "public boolean dispatchTouchEvent(MotionEvent ev)", "public ArrayList<View> buildTouchDispatchChildList()", "private View findChildWithAccessibilityFocus()", "private void resetTouchState()", "private static boolean resetCancelNextUpFlag(@NonNull View view)", "private void clearTouchTargets()", "private void cancelAndClearTouchTargets(MotionEvent event)", "private TouchTarget getTouchTarget(@NonNull View child)", "private TouchTarget addTouchTarget(@NonNull View child, int pointerIdBits)", "private void removePointersFromTouchTargets(int pointerIdBits)", "private void cancelTouchTarget(View view)", "private Rect getTempRect()", "private float[] getTempLocationF()", "private Point getTempPoint()", "protected boolean isTransformedTouchPointInView(float x, float y, View child, PointF outLocalPoint)", "public void transformPointToViewLocal(float[] point, View child)", "private boolean dispatchTransformedTouchEvent(MotionEvent event, boolean cancel, View child, int desiredPointerIdBits)", "public void setMotionEventSplittingEnabled(boolean split)", "public boolean isMotionEventSplittingEnabled()", "public boolean isTransitionGroup()", "public void setTransitionGroup(boolean isTransitionGroup)", "public void requestDisallowInterceptTouchEvent(boolean disallowIntercept)", "public boolean onInterceptTouchEvent(MotionEvent ev)", "public boolean requestFocus(int direction, Rect previouslyFocusedRect)", "protected boolean onRequestFocusInDescendants(int direction, Rect previouslyFocusedRect)", "public boolean restoreDefaultFocus()", "public boolean restoreFocusInCluster(@FocusRealDirection int direction)", "private boolean restoreFocusInClusterInternal(@FocusRealDirection int direction)", "public boolean restoreFocusNotInCluster()", "public void dispatchStartTemporaryDetach()", "public void dispatchFinishTemporaryDetach()", " void dispatchAttachedToWindow(AttachInfo info, int visibility)", " void dispatchScreenStateChanged(int screenState)", " void dispatchMovedToDisplay(Display display, Configuration config)", "public boolean dispatchPopulateAccessibilityEventInternal(AccessibilityEvent event)", "public void dispatchProvideStructure(ViewStructure structure)", "public void dispatchProvideAutofillStructure(ViewStructure structure, @AutofillFlags int flags)", "public void dispatchProvideContentCaptureStructure()", "private ChildListForAutoFillOrContentCapture getChildrenForAutofill(@AutofillFlags int flags)", "private AutofillManager getAutofillManager()", "private boolean shouldIncludeAllChildrenViewWithAutofillTypeNotNone(AutofillManager afm)", "private boolean shouldIncludeAllChildrenViews(AutofillManager afm)", "private boolean shouldAlwaysIncludeWebview(AutofillManager afm)", "private boolean shouldIncludeInvisibleView(AutofillManager afm)", "private void populateChildrenForAutofill(ArrayList<View> list, @AutofillFlags int flags)", "private ChildListForAutoFillOrContentCapture getChildrenForContentCapture()", "private void populateChildrenForContentCapture(ArrayList<View> list)", "private static View getAndVerifyPreorderedView(ArrayList<View> preorderedList, View[] children, int childIndex)", "public void resetSubtreeAutofillIds()", "public void onInitializeAccessibilityNodeInfoInternal(AccessibilityNodeInfo info)", "public void addExtraDataToAccessibilityNodeInfo(@NonNull AccessibilityNodeInfo info, @NonNull String extraDataKey, @Nullable Bundle arguments)", "public CharSequence getAccessibilityClassName()", "public void notifySubtreeAccessibilityStateChanged(View child, View source, int changeType)", "public void notifySubtreeAccessibilityStateChangedIfNeeded()", " void resetSubtreeAccessibilityStateChanged()", " int getNumChildrenForAccessibility()", "public boolean onNestedPrePerformAccessibilityAction(View target, int action, Bundle args)", " void calculateAccessibilityDataSensitive()", " void dispatchDetachedFromWindow()", "protected void internalSetPadding(int left, int top, int right, int bottom)", "protected void dispatchSaveInstanceState(SparseArray<Parcelable> container)", "protected void dispatchFreezeSelfOnly(SparseArray<Parcelable> container)", "protected void dispatchRestoreInstanceState(SparseArray<Parcelable> container)", "protected void dispatchThawSelfOnly(SparseArray<Parcelable> container)", "protected void setChildrenDrawingCacheEnabled(boolean enabled)", "public Bitmap createSnapshot(ViewDebug.CanvasProvider canvasProvider, boolean skipChildren)", " boolean isLayoutModeOptical()", " Insets computeOpticalInsets()", "private static void fillRect(Canvas canvas, Paint paint, int x1, int y1, int x2, int y2)", "private static int sign(int x)", "private static void drawCorner(Canvas c, Paint paint, int x1, int y1, int dx, int dy, int lw)", "private static void drawRectCorners(Canvas canvas, int x1, int y1, int x2, int y2, Paint paint, int lineLength, int lineWidth)", "private static void fillDifference(Canvas canvas, int x2, int y2, int x3, int y3, int dx1, int dy1, int dx2, int dy2, Paint paint)", "protected void onDebugDrawMargins(@NonNull Canvas canvas, Paint paint)", "protected void onDebugDraw(@NonNull Canvas canvas)", "protected void dispatchDraw(@NonNull Canvas canvas)", "public ViewGroupOverlay getOverlay()", "protected int getChildDrawingOrder(int childCount, int drawingPosition)", "public final int getChildDrawingOrder(int drawingPosition)", "private boolean hasChildWithZ()", " ArrayList<View> buildOrderedChildList()", "private void notifyAnimationListener()", "protected void dispatchGetDisplayList()", "private void recreateChildDisplayList(View child)", "protected boolean drawChild(@NonNull Canvas canvas, View child, long drawingTime)", " void getScrollIndicatorBounds(@NonNull Rect out)", "public boolean getClipChildren()", "public void setClipChildren(boolean clipChildren)", "public void setClipToPadding(boolean clipToPadding)", "public boolean getClipToPadding()", "public void dispatchSetSelected(boolean selected)", "public void dispatchSetActivated(boolean activated)", "protected void dispatchSetPressed(boolean pressed)", "public void dispatchDrawableHotspotChanged(float x, float y)", " void dispatchCancelPendingInputEvents()", "protected void setStaticTransformationsEnabled(boolean enabled)", "protected boolean getChildStaticTransformation(View child, Transformation t)", " Transformation getChildTransformation()", "protected T findViewTraversal(@IdRes int id)", "protected T findViewWithTagTraversal(Object tag)", "protected T findViewByPredicateTraversal(Predicate<View> predicate, View childToSkip)", "public void addTransientView(View view, int index)", "public void removeTransientView(View view)", "public int getTransientViewCount()", "public int getTransientViewIndex(int position)", "public View getTransientView(int position)", "public void addView(View child)", "public void addView(View child, int index)", "public void addView(View child, int width, int height)", "public void addView(View child, LayoutParams params)", "public void addView(View child, int index, LayoutParams params)", "public void updateViewLayout(View view, ViewGroup.LayoutParams params)", "protected boolean checkLayoutParams(ViewGroup.LayoutParams p)", "public void setOnHierarchyChangeListener(OnHierarchyChangeListener listener)", " void dispatchViewAdded(View child)", "public void onViewAdded(View child)", " void dispatchViewRemoved(View child)", "public void onViewRemoved(View child)", "private void clearCachedLayoutMode()", "protected void onAttachedToWindow()", "protected void onDetachedFromWindow()", "protected void destroyHardwareResources()", "protected boolean addViewInLayout(View child, int index, LayoutParams params)", "protected boolean addViewInLayout(View child, int index, LayoutParams params, boolean preventRequestLayout)", "protected void cleanupLayoutState(View child)", "private void addViewInner(View child, int index, LayoutParams params, boolean preventRequestLayout)", "private void touchAccessibilityNodeProviderIfNeeded(View child)", "private void addInArray(View child, int index)", "private void removeFromArray(int index)", "private void removeFromArray(int start, int count)", "private void bindLayoutAnimation(View child)", "protected void attachLayoutAnimationParameters(View child, LayoutParams params, int index, int count)", "public void removeView(View view)", "public void removeViewInLayout(View view)", "public void removeViewsInLayout(int start, int count)", "public void removeViewAt(int index)", "public void removeViews(int start, int count)", "private boolean removeViewInternal(View view)", "private void removeViewInternal(int index, View view)", "public void setLayoutTransition(LayoutTransition transition)", "public LayoutTransition getLayoutTransition()", "private void removeViewsInternal(int start, int count)", "public void removeAllViews()", "public void removeAllViewsInLayout()", "protected void removeDetachedView(View child, boolean animate)", "protected void attachViewToParent(View child, int index, LayoutParams params)", "protected void detachViewFromParent(View child)", "protected void detachViewFromParent(int index)", "protected void detachViewsFromParent(int start, int count)", "protected void detachAllViewsFromParent()", "public void onDescendantInvalidated(@NonNull View child, @NonNull View target)", "public final void invalidateChild(View child, final Rect dirty)", "public ViewParent invalidateChildInParent(final int[] location, final Rect dirty)", "public final void offsetDescendantRectToMyCoords(View descendant, Rect rect)", "public final void offsetRectIntoDescendantCoords(View descendant, Rect rect)", " void offsetRectBetweenParentAndChild(View descendant, Rect rect, boolean offsetFromChildToParent, boolean clipToBounds)", "public void offsetChildrenTopAndBottom(int offset)", "public boolean getChildVisibleRect(View child, Rect r, android.graphics.Point offset)", "public boolean getChildVisibleRect(View child, Rect r, android.graphics.Point offset, boolean forceParentCheck)", "public final void layout(int l, int t, int r, int b)", "protected abstract void onLayout(boolean changed, int l, int t, int r, int b)", "protected boolean canAnimate()", "public void startLayoutAnimation()", "public void scheduleLayoutAnimation()", "public void setLayoutAnimation(LayoutAnimationController controller)", "public LayoutAnimationController getLayoutAnimation()", "public boolean isAnimationCacheEnabled()", "public void setAnimationCacheEnabled(boolean enabled)", "public boolean isAlwaysDrawnWithCacheEnabled()", "public void setAlwaysDrawnWithCacheEnabled(boolean always)", "protected boolean isChildrenDrawnWithCacheEnabled()", "protected void setChildrenDrawnWithCacheEnabled(boolean enabled)", "protected boolean isChildrenDrawingOrderEnabled()", "protected void setChildrenDrawingOrderEnabled(boolean enabled)", "private boolean hasBooleanFlag(int flag)", "private void setBooleanFlag(int flag, boolean value)", "public int getPersistentDrawingCache()", "public void setPersistentDrawingCache(int drawingCacheToKeep)", "private void setLayoutMode(int layoutMode, boolean explicitly)", " void invalidateInheritedLayoutMode(int layoutModeOfRoot)", "public int getLayoutMode()", "public void setLayoutMode(int layoutMode)", "public LayoutParams generateLayoutParams(AttributeSet attrs)", "protected LayoutParams generateLayoutParams(ViewGroup.LayoutParams p)", "protected LayoutParams generateDefaultLayoutParams()", "protected void debug(int depth)", "public int indexOfChild(View child)", "public int getChildCount()", "public View getChildAt(int index)", "protected void measureChildren(int widthMeasureSpec, int heightMeasureSpec)", "protected void measureChild(View child, int parentWidthMeasureSpec, int parentHeightMeasureSpec)", "protected void measureChildWithMargins(View child, int parentWidthMeasureSpec, int widthUsed, int parentHeightMeasureSpec, int heightUsed)", "public static int getChildMeasureSpec(int spec, int padding, int childDimension)", "public void clearDisappearingChildren()", "private void addDisappearingView(View v)", " void finishAnimatingView(final View view, Animation animation)", " boolean isViewTransitioning(View view)", "public void startViewTransition(View view)", "public void endViewTransition(View view)", "public void suppressLayout(boolean suppress)", "public boolean isLayoutSuppressed()", "public boolean gatherTransparentRegion(Region region)", "public void requestTransparentRegion(View child)", "public void subtractObscuredTouchableRegion(Region touchableRegion, View view)", "public boolean getChildLocalHitRegion(@NonNull View child, @NonNull Region region, @NonNull Matrix matrix, boolean isHover)", "private boolean isOnTop(View view, View otherView, ArrayList<View> preorderedList)", "private static void applyOpToRegionByBounds(Region region, View view, Region.Op op)", "public WindowInsets dispatchApplyWindowInsets(WindowInsets insets)", "private WindowInsets brokenDispatchApplyWindowInsets(WindowInsets insets)", "private WindowInsets newDispatchApplyWindowInsets(WindowInsets insets)", "public void setWindowInsetsAnimationCallback(@Nullable WindowInsetsAnimation.Callback callback)", "public boolean hasWindowInsetsAnimationCallback()", "public void dispatchWindowInsetsAnimationPrepare(@NonNull WindowInsetsAnimation animation)", "public Bounds dispatchWindowInsetsAnimationStart(@NonNull WindowInsetsAnimation animation, @NonNull Bounds bounds)", "public WindowInsets dispatchWindowInsetsAnimationProgress(@NonNull WindowInsets insets, @NonNull List<WindowInsetsAnimation> runningAnimations)", "public void dispatchWindowInsetsAnimationEnd(@NonNull WindowInsetsAnimation animation)", "public void dispatchScrollCaptureSearch(@NonNull Rect localVisibleRect, @NonNull Point windowOffset, @NonNull Consumer<ScrollCaptureTarget> targets)", "public Animation.AnimationListener getLayoutAnimationListener()", "protected void drawableStateChanged()", "public void jumpDrawablesToCurrentState()", "protected int[] onCreateDrawableState(int extraSpace)", "public void setAddStatesFromChildren(boolean addsStates)", "public boolean addStatesFromChildren()", "public void childDrawableStateChanged(View child)", "public void setLayoutAnimationListener(Animation.AnimationListener animationListener)", "public void requestTransitionStart(LayoutTransition transition)", "public boolean resolveRtlPropertiesIfNeeded()", "public boolean resolveLayoutDirection()", "public boolean resolveTextDirection()", "public boolean resolveTextAlignment()", "public void resolvePadding()", "protected void resolveDrawables()", "public void resolveLayoutParams()", "public void resetResolvedLayoutDirection()", "public void resetResolvedTextDirection()", "public void resetResolvedTextAlignment()", "public void resetResolvedPadding()", "protected void resetResolvedDrawables()", "public boolean shouldDelayChildPressedState()", "public boolean onStartNestedScroll(View child, View target, int nestedScrollAxes)", "public void onNestedScrollAccepted(View child, View target, int axes)", "public void onStopNestedScroll(View child)", "public void onNestedScroll(View target, int dxConsumed, int dyConsumed, int dxUnconsumed, int dyUnconsumed)", "public void onNestedPreScroll(View target, int dx, int dy, int[] consumed)", "public boolean onNestedFling(View target, float velocityX, float velocityY, boolean consumed)", "public boolean onNestedPreFling(View target, float velocityX, float velocityY)", "public int getNestedScrollAxes()", "protected void onSetLayoutParams(View child, LayoutParams layoutParams)", "public void captureTransitioningViews(List<View> transitioningViews)", "public void findNamedViews(Map<String, View> namedElements)", " boolean hasUnhandledKeyListener()", " void incrementChildUnhandledKeyListeners()", " void decrementChildUnhandledKeyListeners()", " View dispatchUnhandledKeyEvent(KeyEvent evt)", "private static void drawRect(@NonNull Canvas canvas, Paint paint, int x1, int y1, int x2, int y2)", "protected void encodeProperties(@NonNull ViewHierarchyEncoder encoder)", "public final void onDescendantUnbufferedRequested()", "public void dispatchCreateViewTranslationRequest(@NonNull Map<AutofillId, long[]> viewIds, @NonNull @DataFormat int[] supportedFormats, @Nullable TranslationCapability capability, @NonNull List<ViewTranslationRequest> requests)", "public OnBackInvokedDispatcher findOnBackInvokedDispatcherForChild(@NonNull View child, @NonNull View requester)" ],
  "variableNames" : [ "TAG", "DBG", "mDisappearingChildren", "mOnHierarchyChangeListener", "mFocused", "mDefaultFocus", "mFocusedInCluster", "mChildTransformation", "mInvalidateRegion", "mInvalidationTransformation", "mCurrentDragChild", "mCurrentDragStartEvent", "mIsInterestedInDrag", "mChildrenInterestedInDrag", "mLocalPoint", "mTempPosition", "mTempPoint", "mTempRect", "mTempLocation", "mLayoutAnimationController", "mAnimationListener", "mFirstTouchTarget", "mLastTouchDownTime", "mLastTouchDownIndex", "mLastTouchDownX", "mLastTouchDownY", "mFirstHoverTarget", "mHoveredSelf", "mTooltipHoverTarget", "mTooltipHoveredSelf", "mGroupFlags", "mLayoutMode", "FLAG_CLIP_CHILDREN", "FLAG_CLIP_TO_PADDING", "FLAG_INVALIDATE_REQUIRED", "FLAG_RUN_ANIMATION", "FLAG_ANIMATION_DONE", "FLAG_PADDING_NOT_NULL", "FLAG_ANIMATION_CACHE", "FLAG_OPTIMIZE_INVALIDATE", "FLAG_CLEAR_TRANSFORMATION", "FLAG_NOTIFY_ANIMATION_LISTENER", "FLAG_USE_CHILD_DRAWING_ORDER", "FLAG_SUPPORT_STATIC_TRANSFORMATIONS", "FLAG_ADD_STATES_FROM_CHILDREN", "FLAG_ALWAYS_DRAWN_WITH_CACHE", "FLAG_CHILDREN_DRAWN_WITH_CACHE", "FLAG_NOTIFY_CHILDREN_ON_DRAWABLE_STATE_CHANGE", "FLAG_MASK_FOCUSABILITY", "FOCUS_BEFORE_DESCENDANTS", "FOCUS_AFTER_DESCENDANTS", "FOCUS_BLOCK_DESCENDANTS", "DESCENDANT_FOCUSABILITY_FLAGS", "FLAG_DISALLOW_INTERCEPT", "FLAG_SPLIT_MOTION_EVENTS", "FLAG_PREVENT_DISPATCH_ATTACHED_TO_WINDOW", "FLAG_LAYOUT_MODE_WAS_EXPLICITLY_SET", "FLAG_IS_TRANSITION_GROUP", "FLAG_IS_TRANSITION_GROUP_SET", "FLAG_TOUCHSCREEN_BLOCKS_FOCUS", "FLAG_START_ACTION_MODE_FOR_CHILD_IS_TYPED", "FLAG_START_ACTION_MODE_FOR_CHILD_IS_NOT_TYPED", "FLAG_SHOW_CONTEXT_MENU_WITH_COORDS", "mPersistentDrawingCache", "PERSISTENT_NO_CACHE", "PERSISTENT_ANIMATION_CACHE", "PERSISTENT_SCROLLING_CACHE", "PERSISTENT_ALL_CACHES", "LAYOUT_MODE_UNDEFINED", "LAYOUT_MODE_CLIP_BOUNDS", "LAYOUT_MODE_OPTICAL_BOUNDS", "LAYOUT_MODE_DEFAULT", "CLIP_TO_PADDING_MASK", "CHILD_LEFT_INDEX", "CHILD_TOP_INDEX", "mChildren", "mChildrenCount", "mSuppressLayout", "mLayoutCalledWhileSuppressed", "ARRAY_INITIAL_CAPACITY", "ARRAY_CAPACITY_INCREMENT", "sDebugLines", "mCachePaint", "mTransition", "mTransitioningViews", "mVisibilityChangingChildren", "mPreSortedChildren", "mChildCountWithTransientState", "mNestedScrollAxes", "mTransientIndices", "mTransientViews", "mChildUnhandledKeyListeners", "mInsetsAnimationDispatchMode", "SENTINEL_ACTION_MODE", "mLayoutTransitionListener" ]
}