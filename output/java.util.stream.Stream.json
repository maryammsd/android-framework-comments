{
  "filePath" : "/home/maryam/clearblue/files/android-source-35/java/util/stream/Stream.java",
  "packageName" : "java.util.stream",
  "className" : "Stream",
  "comment" : "\n * A sequence of elements supporting sequential and parallel aggregate\n * operations.  The following example illustrates an aggregate operation using\n * {@link Stream} and {@link IntStream}:\n *\n * <pre>{@code\n *     int sum = widgets.stream()\n *                      .filter(w -> w.getColor() == RED)\n *                      .mapToInt(w -> w.getWeight())\n *                      .sum();\n * }</pre>\n *\n * In this example, {@code widgets} is a {@code Collection<Widget>}.  We create\n * a stream of {@code Widget} objects via {@link Collection#stream Collection.stream()},\n * filter it to produce a stream containing only the red widgets, and then\n * transform it into a stream of {@code int} values representing the weight of\n * each red widget. Then this stream is summed to produce a total weight.\n *\n * <p>In addition to {@code Stream}, which is a stream of object references,\n * there are primitive specializations for {@link IntStream}, {@link LongStream},\n * and {@link DoubleStream}, all of which are referred to as \"streams\" and\n * conform to the characteristics and restrictions described here.\n *\n * <p>To perform a computation, stream\n * <a href=\"package-summary.html#StreamOps\">operations</a> are composed into a\n * <em>stream pipeline</em>.  A stream pipeline consists of a source (which\n * might be an array, a collection, a generator function, an I/O channel,\n * etc), zero or more <em>intermediate operations</em> (which transform a\n * stream into another stream, such as {@link Stream#filter(Predicate)}), and a\n * <em>terminal operation</em> (which produces a result or side-effect, such\n * as {@link Stream#count()} or {@link Stream#forEach(Consumer)}).\n * Streams are lazy; computation on the source data is only performed when the\n * terminal operation is initiated, and source elements are consumed only\n * as needed.\n *\n * <p>A stream implementation is permitted significant latitude in optimizing\n * the computation of the result.  For example, a stream implementation is free\n * to elide operations (or entire stages) from a stream pipeline -- and\n * therefore elide invocation of behavioral parameters -- if it can prove that\n * it would not affect the result of the computation.  This means that\n * side-effects of behavioral parameters may not always be executed and should\n * not be relied upon, unless otherwise specified (such as by the terminal\n * operations {@code forEach} and {@code forEachOrdered}). (For a specific\n * example of such an optimization, see the API note documented on the\n * {@link #count} operation.  For more detail, see the\n * <a href=\"package-summary.html#SideEffects\">side-effects</a> section of the\n * stream package documentation.)\n *\n * <p>Collections and streams, while bearing some superficial similarities,\n * have different goals.  Collections are primarily concerned with the efficient\n * management of, and access to, their elements.  By contrast, streams do not\n * provide a means to directly access or manipulate their elements, and are\n * instead concerned with declaratively describing their source and the\n * computational operations which will be performed in aggregate on that source.\n * However, if the provided stream operations do not offer the desired\n * functionality, the {@link #iterator()} and {@link #spliterator()} operations\n * can be used to perform a controlled traversal.\n *\n * <p>A stream pipeline, like the \"widgets\" example above, can be viewed as\n * a <em>query</em> on the stream source.  Unless the source was explicitly\n * designed for concurrent modification (such as a {@link ConcurrentHashMap}),\n * unpredictable or erroneous behavior may result from modifying the stream\n * source while it is being queried.\n *\n * <p>Most stream operations accept parameters that describe user-specified\n * behavior, such as the lambda expression {@code w -> w.getWeight()} passed to\n * {@code mapToInt} in the example above.  To preserve correct behavior,\n * these <em>behavioral parameters</em>:\n * <ul>\n * <li>must be <a href=\"package-summary.html#NonInterference\">non-interfering</a>\n * (they do not modify the stream source); and</li>\n * <li>in most cases must be <a href=\"package-summary.html#Statelessness\">stateless</a>\n * (their result should not depend on any state that might change during execution\n * of the stream pipeline).</li>\n * </ul>\n *\n * <p>Such parameters are always instances of a\n * <a href=\"../function/package-summary.html\">functional interface</a> such\n * as {@link java.util.function.Function}, and are often lambda expressions or\n * method references.  Unless otherwise specified these parameters must be\n * <em>non-null</em>.\n *\n * <p>A stream should be operated on (invoking an intermediate or terminal stream\n * operation) only once.  This rules out, for example, \"forked\" streams, where\n * the same source feeds two or more pipelines, or multiple traversals of the\n * same stream.  A stream implementation may throw {@link IllegalStateException}\n * if it detects that the stream is being reused. However, since some stream\n * operations may return their receiver rather than a new stream object, it may\n * not be possible to detect reuse in all cases.\n *\n * <p>Streams have a {@link #close()} method and implement {@link AutoCloseable}.\n * Operating on a stream after it has been closed will throw {@link IllegalStateException}.\n * Most stream instances do not actually need to be closed after use, as they\n * are backed by collections, arrays, or generating functions, which require no\n * special resource management. Generally, only streams whose source is an IO channel,\n * such as those returned by {@link Files#lines(Path)}, will require closing. If a\n * stream does require closing, it must be opened as a resource within a try-with-resources\n * statement or similar control structure to ensure that it is closed promptly after its\n * operations have completed.\n *\n * <p>Stream pipelines may execute either sequentially or in\n * <a href=\"package-summary.html#Parallelism\">parallel</a>.  This\n * execution mode is a property of the stream.  Streams are created\n * with an initial choice of sequential or parallel execution.  (For example,\n * {@link Collection#stream() Collection.stream()} creates a sequential stream,\n * and {@link Collection#parallelStream() Collection.parallelStream()} creates\n * a parallel one.)  This choice of execution mode may be modified by the\n * {@link #sequential()} or {@link #parallel()} methods, and may be queried with\n * the {@link #isParallel()} method.\n *\n * @param <T> the type of the stream elements\n * @since 1.8\n * @see IntStream\n * @see LongStream\n * @see DoubleStream\n * @see <a href=\"package-summary.html\">java.util.stream</a>\n ",
  "links" : [ "java.util.stream.IntStream", "IllegalStateException", "java.util.stream.LongStream", "#spliterator()", "java.nio.file.Files#lines(Path)", "#isParallel()", "AutoCloseable", "java.util.concurrent.ConcurrentHashMap", "#parallel()", "#stream", "#count", "#sequential()", "java.util.function.Function", "java.util.stream.DoubleStream", "java.util.stream.Stream#count()", "#iterator()", "java.util.stream.Stream", "java.util.stream.Stream#filter(Predicate)", "#close()", "java.util.stream.Stream#forEach(Consumer)", "#parallelStream()", "#stream()" ],
  "variables" : [ ],
  "methods" : [ {
    "name" : " Stream<T> filter(Predicate<? super T> predicate)",
    "returnType" : "Stream<T>",
    "comment" : "\n     * Returns a stream consisting of the elements of this stream that match\n     * the given predicate.\n     *\n     * <p>This is an <a href=\"package-summary.html#StreamOps\">intermediate\n     * operation</a>.\n     *\n     * @param predicate a <a href=\"package-summary.html#NonInterference\">non-interfering</a>,\n     *                  <a href=\"package-summary.html#Statelessness\">stateless</a>\n     *                  predicate to apply to each element to determine if it\n     *                  should be included\n     * @return the new stream\n     ",
    "links" : [ ]
  }, {
    "name" : " Stream<R> map(Function<? super T, ? extends R> mapper)",
    "returnType" : "Stream<R>",
    "comment" : "\n     * Returns a stream consisting of the results of applying the given\n     * function to the elements of this stream.\n     *\n     * <p>This is an <a href=\"package-summary.html#StreamOps\">intermediate\n     * operation</a>.\n     *\n     * @param <R> The element type of the new stream\n     * @param mapper a <a href=\"package-summary.html#NonInterference\">non-interfering</a>,\n     *               <a href=\"package-summary.html#Statelessness\">stateless</a>\n     *               function to apply to each element\n     * @return the new stream\n     ",
    "links" : [ ]
  }, {
    "name" : " IntStream mapToInt(ToIntFunction<? super T> mapper)",
    "returnType" : "IntStream",
    "comment" : "\n     * Returns an {@code IntStream} consisting of the results of applying the\n     * given function to the elements of this stream.\n     *\n     * <p>This is an <a href=\"package-summary.html#StreamOps\">\n     *     intermediate operation</a>.\n     *\n     * @param mapper a <a href=\"package-summary.html#NonInterference\">non-interfering</a>,\n     *               <a href=\"package-summary.html#Statelessness\">stateless</a>\n     *               function to apply to each element\n     * @return the new stream\n     ",
    "links" : [ ]
  }, {
    "name" : " LongStream mapToLong(ToLongFunction<? super T> mapper)",
    "returnType" : "LongStream",
    "comment" : "\n     * Returns a {@code LongStream} consisting of the results of applying the\n     * given function to the elements of this stream.\n     *\n     * <p>This is an <a href=\"package-summary.html#StreamOps\">intermediate\n     * operation</a>.\n     *\n     * @param mapper a <a href=\"package-summary.html#NonInterference\">non-interfering</a>,\n     *               <a href=\"package-summary.html#Statelessness\">stateless</a>\n     *               function to apply to each element\n     * @return the new stream\n     ",
    "links" : [ ]
  }, {
    "name" : " DoubleStream mapToDouble(ToDoubleFunction<? super T> mapper)",
    "returnType" : "DoubleStream",
    "comment" : "\n     * Returns a {@code DoubleStream} consisting of the results of applying the\n     * given function to the elements of this stream.\n     *\n     * <p>This is an <a href=\"package-summary.html#StreamOps\">intermediate\n     * operation</a>.\n     *\n     * @param mapper a <a href=\"package-summary.html#NonInterference\">non-interfering</a>,\n     *               <a href=\"package-summary.html#Statelessness\">stateless</a>\n     *               function to apply to each element\n     * @return the new stream\n     ",
    "links" : [ ]
  }, {
    "name" : " Stream<R> flatMap(Function<? super T, ? extends Stream<? extends R>> mapper)",
    "returnType" : "Stream<R>",
    "comment" : "\n     * Returns a stream consisting of the results of replacing each element of\n     * this stream with the contents of a mapped stream produced by applying\n     * the provided mapping function to each element.  Each mapped stream is\n     * {@link java.util.stream.BaseStream#close() closed} after its contents\n     * have been placed into this stream.  (If a mapped stream is {@code null}\n     * an empty stream is used, instead.)\n     *\n     * <p>This is an <a href=\"package-summary.html#StreamOps\">intermediate\n     * operation</a>.\n     *\n     * @apiNote\n     * The {@code flatMap()} operation has the effect of applying a one-to-many\n     * transformation to the elements of the stream, and then flattening the\n     * resulting elements into a new stream.\n     *\n     * <p><b>Examples.</b>\n     *\n     * <p>If {@code orders} is a stream of purchase orders, and each purchase\n     * order contains a collection of line items, then the following produces a\n     * stream containing all the line items in all the orders:\n     * <pre>{@code\n     *     orders.flatMap(order -> order.getLineItems().stream())...\n     * }</pre>\n     *\n     * <p>If {@code path} is the path to a file, then the following produces a\n     * stream of the {@code words} contained in that file:\n     * <pre>{@code\n     *     Stream<String> lines = Files.lines(path, StandardCharsets.UTF_8);\n     *     Stream<String> words = lines.flatMap(line -> Stream.of(line.split(\" +\")));\n     * }</pre>\n     * The {@code mapper} function passed to {@code flatMap} splits a line,\n     * using a simple regular expression, into an array of words, and then\n     * creates a stream of words from that array.\n     *\n     * @param <R> The element type of the new stream\n     * @param mapper a <a href=\"package-summary.html#NonInterference\">non-interfering</a>,\n     *               <a href=\"package-summary.html#Statelessness\">stateless</a>\n     *               function to apply to each element which produces a stream\n     *               of new values\n     * @return the new stream\n     * @see #mapMulti\n     ",
    "links" : [ "java.util.stream.BaseStream#close()" ]
  }, {
    "name" : " IntStream flatMapToInt(Function<? super T, ? extends IntStream> mapper)",
    "returnType" : "IntStream",
    "comment" : "\n     * Returns an {@code IntStream} consisting of the results of replacing each\n     * element of this stream with the contents of a mapped stream produced by\n     * applying the provided mapping function to each element.  Each mapped\n     * stream is {@link java.util.stream.BaseStream#close() closed} after its\n     * contents have been placed into this stream.  (If a mapped stream is\n     * {@code null} an empty stream is used, instead.)\n     *\n     * <p>This is an <a href=\"package-summary.html#StreamOps\">intermediate\n     * operation</a>.\n     *\n     * @param mapper a <a href=\"package-summary.html#NonInterference\">non-interfering</a>,\n     *               <a href=\"package-summary.html#Statelessness\">stateless</a>\n     *               function to apply to each element which produces a stream\n     *               of new values\n     * @return the new stream\n     * @see #flatMap(Function)\n     ",
    "links" : [ "java.util.stream.BaseStream#close()" ]
  }, {
    "name" : " LongStream flatMapToLong(Function<? super T, ? extends LongStream> mapper)",
    "returnType" : "LongStream",
    "comment" : "\n     * Returns an {@code LongStream} consisting of the results of replacing each\n     * element of this stream with the contents of a mapped stream produced by\n     * applying the provided mapping function to each element.  Each mapped\n     * stream is {@link java.util.stream.BaseStream#close() closed} after its\n     * contents have been placed into this stream.  (If a mapped stream is\n     * {@code null} an empty stream is used, instead.)\n     *\n     * <p>This is an <a href=\"package-summary.html#StreamOps\">intermediate\n     * operation</a>.\n     *\n     * @param mapper a <a href=\"package-summary.html#NonInterference\">non-interfering</a>,\n     *               <a href=\"package-summary.html#Statelessness\">stateless</a>\n     *               function to apply to each element which produces a stream\n     *               of new values\n     * @return the new stream\n     * @see #flatMap(Function)\n     ",
    "links" : [ "java.util.stream.BaseStream#close()" ]
  }, {
    "name" : " DoubleStream flatMapToDouble(Function<? super T, ? extends DoubleStream> mapper)",
    "returnType" : "DoubleStream",
    "comment" : "\n     * Returns an {@code DoubleStream} consisting of the results of replacing\n     * each element of this stream with the contents of a mapped stream produced\n     * by applying the provided mapping function to each element.  Each mapped\n     * stream is {@link java.util.stream.BaseStream#close() closed} after its\n     * contents have placed been into this stream.  (If a mapped stream is\n     * {@code null} an empty stream is used, instead.)\n     *\n     * <p>This is an <a href=\"package-summary.html#StreamOps\">intermediate\n     * operation</a>.\n     *\n     * @param mapper a <a href=\"package-summary.html#NonInterference\">non-interfering</a>,\n     *               <a href=\"package-summary.html#Statelessness\">stateless</a>\n     *               function to apply to each element which produces a stream\n     *               of new values\n     * @return the new stream\n     * @see #flatMap(Function)\n     ",
    "links" : [ "java.util.stream.BaseStream#close()" ]
  }, {
    "name" : " Stream<R> mapMulti(BiConsumer<? super T, ? super Consumer<R>> mapper)",
    "returnType" : "Stream<R>",
    "comment" : "\n     * Returns a stream consisting of the results of replacing each element of\n     * this stream with multiple elements, specifically zero or more elements.\n     * Replacement is performed by applying the provided mapping function to each\n     * element in conjunction with a {@linkplain Consumer consumer} argument\n     * that accepts replacement elements. The mapping function calls the consumer\n     * zero or more times to provide the replacement elements.\n     *\n     * <p>This is an <a href=\"package-summary.html#StreamOps\">intermediate\n     * operation</a>.\n     *\n     * <p>If the {@linkplain Consumer consumer} argument is used outside the scope of\n     * its application to the mapping function, the results are undefined.\n     *\n     * @implSpec\n     * The default implementation invokes {@link #flatMap flatMap} on this stream,\n     * passing a function that behaves as follows. First, it calls the mapper function\n     * with a {@code Consumer} that accumulates replacement elements into a newly created\n     * internal buffer. When the mapper function returns, it creates a stream from the\n     * internal buffer. Finally, it returns this stream to {@code flatMap}.\n     *\n     * @apiNote\n     * This method is similar to {@link #flatMap flatMap} in that it applies a one-to-many\n     * transformation to the elements of the stream and flattens the result elements\n     * into a new stream. This method is preferable to {@code flatMap} in the following\n     * circumstances:\n     * <ul>\n     * <li>When replacing each stream element with a small (possibly zero) number of\n     * elements. Using this method avoids the overhead of creating a new Stream instance\n     * for every group of result elements, as required by {@code flatMap}.</li>\n     * <li>When it is easier to use an imperative approach for generating result\n     * elements than it is to return them in the form of a Stream.</li>\n     * </ul>\n     *\n     * <p>If a lambda expression is provided as the mapper function argument, additional type\n     * information may be necessary for proper inference of the element type {@code <R>} of\n     * the returned stream. This can be provided in the form of explicit type declarations for\n     * the lambda parameters or as an explicit type argument to the {@code mapMulti} call.\n     *\n     * <p><b>Examples</b>\n     *\n     * <p>Given a stream of {@code Number} objects, the following\n     * produces a list containing only the {@code Integer} objects:\n     * <pre>{@code\n     *     Stream<Number> numbers = ... ;\n     *     List<Integer> integers = numbers.<Integer>mapMulti((number, consumer) -> {\n     *             if (number instanceof Integer i)\n     *                 consumer.accept(i);\n     *         })\n     *         .collect(Collectors.toList());\n     * }</pre>\n     *\n     * <p>If we have an {@code Iterable<Object>} and need to recursively expand its elements\n     * that are themselves of type {@code Iterable}, we can use {@code mapMulti} as follows:\n     * <pre>{@code\n     * class C {\n     *     static void expandIterable(Object e, Consumer<Object> c) {\n     *         if (e instanceof Iterable<?> elements) {\n     *             for (Object ie : elements) {\n     *                 expandIterable(ie, c);\n     *             }\n     *         } else if (e != null) {\n     *             c.accept(e);\n     *         }\n     *     }\n     *\n     *     public static void main(String[] args) {\n     *         var nestedList = List.of(1, List.of(2, List.of(3, 4)), 5);\n     *         Stream<Object> expandedStream = nestedList.stream().mapMulti(C::expandIterable);\n     *     }\n     * }\n     * }</pre>\n     *\n     * @param <R> The element type of the new stream\n     * @param mapper a <a href=\"package-summary.html#NonInterference\">non-interfering</a>,\n     *               <a href=\"package-summary.html#Statelessness\">stateless</a>\n     *               function that generates replacement elements\n     * @return the new stream\n     * @see #flatMap flatMap\n     * @since 16\n     ",
    "links" : [ "#flatMap" ]
  }, {
    "name" : " IntStream mapMultiToInt(BiConsumer<? super T, ? super IntConsumer> mapper)",
    "returnType" : "IntStream",
    "comment" : "\n     * Returns an {@code IntStream} consisting of the results of replacing each\n     * element of this stream with multiple elements, specifically zero or more\n     * elements.\n     * Replacement is performed by applying the provided mapping function to each\n     * element in conjunction with a {@linkplain IntConsumer consumer} argument\n     * that accepts replacement elements. The mapping function calls the consumer\n     * zero or more times to provide the replacement elements.\n     *\n     * <p>This is an <a href=\"package-summary.html#StreamOps\">intermediate\n     * operation</a>.\n     *\n     * <p>If the {@linkplain IntConsumer consumer} argument is used outside the scope of\n     * its application to the mapping function, the results are undefined.\n     *\n     * @implSpec\n     * The default implementation invokes {@link #flatMapToInt flatMapToInt} on this stream,\n     * passing a function that behaves as follows. First, it calls the mapper function\n     * with an {@code IntConsumer} that accumulates replacement elements into a newly created\n     * internal buffer. When the mapper function returns, it creates an {@code IntStream} from\n     * the internal buffer. Finally, it returns this stream to {@code flatMapToInt}.\n     *\n     * @param mapper a <a href=\"package-summary.html#NonInterference\">non-interfering</a>,\n     *               <a href=\"package-summary.html#Statelessness\">stateless</a>\n     *               function that generates replacement elements\n     * @return the new stream\n     * @see #mapMulti mapMulti\n     * @since 16\n     ",
    "links" : [ "#flatMapToInt" ]
  }, {
    "name" : " LongStream mapMultiToLong(BiConsumer<? super T, ? super LongConsumer> mapper)",
    "returnType" : "LongStream",
    "comment" : "\n     * Returns a {@code LongStream} consisting of the results of replacing each\n     * element of this stream with multiple elements, specifically zero or more\n     * elements.\n     * Replacement is performed by applying the provided mapping function to each\n     * element in conjunction with a {@linkplain LongConsumer consumer} argument\n     * that accepts replacement elements. The mapping function calls the consumer\n     * zero or more times to provide the replacement elements.\n     *\n     * <p>This is an <a href=\"package-summary.html#StreamOps\">intermediate\n     * operation</a>.\n     *\n     * <p>If the {@linkplain LongConsumer consumer} argument is used outside the scope of\n     * its application to the mapping function, the results are undefined.\n     *\n     * @implSpec\n     * The default implementation invokes {@link #flatMapToLong flatMapToLong} on this stream,\n     * passing a function that behaves as follows. First, it calls the mapper function\n     * with a {@code LongConsumer} that accumulates replacement elements into a newly created\n     * internal buffer. When the mapper function returns, it creates a {@code LongStream} from\n     * the internal buffer. Finally, it returns this stream to {@code flatMapToLong}.\n     *\n     * @param mapper a <a href=\"package-summary.html#NonInterference\">non-interfering</a>,\n     *               <a href=\"package-summary.html#Statelessness\">stateless</a>\n     *               function that generates replacement elements\n     * @return the new stream\n     * @see #mapMulti mapMulti\n     * @since 16\n     ",
    "links" : [ "#flatMapToLong" ]
  }, {
    "name" : " DoubleStream mapMultiToDouble(BiConsumer<? super T, ? super DoubleConsumer> mapper)",
    "returnType" : "DoubleStream",
    "comment" : "\n     * Returns a {@code DoubleStream} consisting of the results of replacing each\n     * element of this stream with multiple elements, specifically zero or more\n     * elements.\n     * Replacement is performed by applying the provided mapping function to each\n     * element in conjunction with a {@linkplain DoubleConsumer consumer} argument\n     * that accepts replacement elements. The mapping function calls the consumer\n     * zero or more times to provide the replacement elements.\n     *\n     * <p>This is an <a href=\"package-summary.html#StreamOps\">intermediate\n     * operation</a>.\n     *\n     * <p>If the {@linkplain DoubleConsumer consumer} argument is used outside the scope of\n     * its application to the mapping function, the results are undefined.\n     *\n     * @implSpec\n     * The default implementation invokes {@link #flatMapToDouble flatMapToDouble} on this stream,\n     * passing a function that behaves as follows. First, it calls the mapper function\n     * with an {@code DoubleConsumer} that accumulates replacement elements into a newly created\n     * internal buffer. When the mapper function returns, it creates a {@code DoubleStream} from\n     * the internal buffer. Finally, it returns this stream to {@code flatMapToDouble}.\n     *\n     * @param mapper a <a href=\"package-summary.html#NonInterference\">non-interfering</a>,\n     *               <a href=\"package-summary.html#Statelessness\">stateless</a>\n     *               function that generates replacement elements\n     * @return the new stream\n     * @see #mapMulti mapMulti\n     * @since 16\n     ",
    "links" : [ "#flatMapToDouble" ]
  }, {
    "name" : " Stream<T> distinct()",
    "returnType" : "Stream<T>",
    "comment" : "\n     * Returns a stream consisting of the distinct elements (according to\n     * {@link Object#equals(Object)}) of this stream.\n     *\n     * <p>For ordered streams, the selection of distinct elements is stable\n     * (for duplicated elements, the element appearing first in the encounter\n     * order is preserved.)  For unordered streams, no stability guarantees\n     * are made.\n     *\n     * <p>This is a <a href=\"package-summary.html#StreamOps\">stateful\n     * intermediate operation</a>.\n     *\n     * @apiNote\n     * Preserving stability for {@code distinct()} in parallel pipelines is\n     * relatively expensive (requires that the operation act as a full barrier,\n     * with substantial buffering overhead), and stability is often not needed.\n     * Using an unordered stream source (such as {@link #generate(Supplier)})\n     * or removing the ordering constraint with {@link #unordered()} may result\n     * in significantly more efficient execution for {@code distinct()} in parallel\n     * pipelines, if the semantics of your situation permit.  If consistency\n     * with encounter order is required, and you are experiencing poor performance\n     * or memory utilization with {@code distinct()} in parallel pipelines,\n     * switching to sequential execution with {@link #sequential()} may improve\n     * performance.\n     *\n     * @return the new stream\n     ",
    "links" : [ "#equals(Object)", "#generate(Supplier)", "#unordered()", "#sequential()" ]
  }, {
    "name" : " Stream<T> sorted()",
    "returnType" : "Stream<T>",
    "comment" : "\n     * Returns a stream consisting of the elements of this stream, sorted\n     * according to natural order.  If the elements of this stream are not\n     * {@code Comparable}, a {@code java.lang.ClassCastException} may be thrown\n     * when the terminal operation is executed.\n     *\n     * <p>For ordered streams, the sort is stable.  For unordered streams, no\n     * stability guarantees are made.\n     *\n     * <p>This is a <a href=\"package-summary.html#StreamOps\">stateful\n     * intermediate operation</a>.\n     *\n     * @return the new stream\n     ",
    "links" : [ ]
  }, {
    "name" : " Stream<T> sorted(Comparator<? super T> comparator)",
    "returnType" : "Stream<T>",
    "comment" : "\n     * Returns a stream consisting of the elements of this stream, sorted\n     * according to the provided {@code Comparator}.\n     *\n     * <p>For ordered streams, the sort is stable.  For unordered streams, no\n     * stability guarantees are made.\n     *\n     * <p>This is a <a href=\"package-summary.html#StreamOps\">stateful\n     * intermediate operation</a>.\n     *\n     * @param comparator a <a href=\"package-summary.html#NonInterference\">non-interfering</a>,\n     *                   <a href=\"package-summary.html#Statelessness\">stateless</a>\n     *                   {@code Comparator} to be used to compare stream elements\n     * @return the new stream\n     ",
    "links" : [ ]
  }, {
    "name" : " Stream<T> peek(Consumer<? super T> action)",
    "returnType" : "Stream<T>",
    "comment" : "\n     * Returns a stream consisting of the elements of this stream, additionally\n     * performing the provided action on each element as elements are consumed\n     * from the resulting stream.\n     *\n     * <p>This is an <a href=\"package-summary.html#StreamOps\">intermediate\n     * operation</a>.\n     *\n     * <p>For parallel stream pipelines, the action may be called at\n     * whatever time and in whatever thread the element is made available by the\n     * upstream operation.  If the action modifies shared state,\n     * it is responsible for providing the required synchronization.\n     *\n     * @apiNote This method exists mainly to support debugging, where you want\n     * to see the elements as they flow past a certain point in a pipeline:\n     * <pre>{@code\n     *     Stream.of(\"one\", \"two\", \"three\", \"four\")\n     *         .filter(e -> e.length() > 3)\n     *         .peek(e -> System.out.println(\"Filtered value: \" + e))\n     *         .map(String::toUpperCase)\n     *         .peek(e -> System.out.println(\"Mapped value: \" + e))\n     *         .collect(Collectors.toList());\n     * }</pre>\n     *\n     * <p>In cases where the stream implementation is able to optimize away the\n     * production of some or all the elements (such as with short-circuiting\n     * operations like {@code findFirst}, or in the example described in\n     * {@link #count}), the action will not be invoked for those elements.\n     *\n     * @param action a <a href=\"package-summary.html#NonInterference\">\n     *                 non-interfering</a> action to perform on the elements as\n     *                 they are consumed from the stream\n     * @return the new stream\n     ",
    "links" : [ "#count" ]
  }, {
    "name" : " Stream<T> limit(long maxSize)",
    "returnType" : "Stream<T>",
    "comment" : "\n     * Returns a stream consisting of the elements of this stream, truncated\n     * to be no longer than {@code maxSize} in length.\n     *\n     * <p>This is a <a href=\"package-summary.html#StreamOps\">short-circuiting\n     * stateful intermediate operation</a>.\n     *\n     * @apiNote\n     * While {@code limit()} is generally a cheap operation on sequential\n     * stream pipelines, it can be quite expensive on ordered parallel pipelines,\n     * especially for large values of {@code maxSize}, since {@code limit(n)}\n     * is constrained to return not just any <em>n</em> elements, but the\n     * <em>first n</em> elements in the encounter order.  Using an unordered\n     * stream source (such as {@link #generate(Supplier)}) or removing the\n     * ordering constraint with {@link #unordered()} may result in significant\n     * speedups of {@code limit()} in parallel pipelines, if the semantics of\n     * your situation permit.  If consistency with encounter order is required,\n     * and you are experiencing poor performance or memory utilization with\n     * {@code limit()} in parallel pipelines, switching to sequential execution\n     * with {@link #sequential()} may improve performance.\n     *\n     * @param maxSize the number of elements the stream should be limited to\n     * @return the new stream\n     * @throws IllegalArgumentException if {@code maxSize} is negative\n     ",
    "links" : [ "#generate(Supplier)", "#unordered()", "#sequential()" ]
  }, {
    "name" : " Stream<T> skip(long n)",
    "returnType" : "Stream<T>",
    "comment" : "\n     * Returns a stream consisting of the remaining elements of this stream\n     * after discarding the first {@code n} elements of the stream.\n     * If this stream contains fewer than {@code n} elements then an\n     * empty stream will be returned.\n     *\n     * <p>This is a <a href=\"package-summary.html#StreamOps\">stateful\n     * intermediate operation</a>.\n     *\n     * @apiNote\n     * While {@code skip()} is generally a cheap operation on sequential\n     * stream pipelines, it can be quite expensive on ordered parallel pipelines,\n     * especially for large values of {@code n}, since {@code skip(n)}\n     * is constrained to skip not just any <em>n</em> elements, but the\n     * <em>first n</em> elements in the encounter order.  Using an unordered\n     * stream source (such as {@link #generate(Supplier)}) or removing the\n     * ordering constraint with {@link #unordered()} may result in significant\n     * speedups of {@code skip()} in parallel pipelines, if the semantics of\n     * your situation permit.  If consistency with encounter order is required,\n     * and you are experiencing poor performance or memory utilization with\n     * {@code skip()} in parallel pipelines, switching to sequential execution\n     * with {@link #sequential()} may improve performance.\n     *\n     * @param n the number of leading elements to skip\n     * @return the new stream\n     * @throws IllegalArgumentException if {@code n} is negative\n     ",
    "links" : [ "#generate(Supplier)", "#unordered()", "#sequential()" ]
  }, {
    "name" : " Stream<T> takeWhile(Predicate<? super T> predicate)",
    "returnType" : "Stream<T>",
    "comment" : "\n     * Returns, if this stream is ordered, a stream consisting of the longest\n     * prefix of elements taken from this stream that match the given predicate.\n     * Otherwise returns, if this stream is unordered, a stream consisting of a\n     * subset of elements taken from this stream that match the given predicate.\n     *\n     * <p>If this stream is ordered then the longest prefix is a contiguous\n     * sequence of elements of this stream that match the given predicate.  The\n     * first element of the sequence is the first element of this stream, and\n     * the element immediately following the last element of the sequence does\n     * not match the given predicate.\n     *\n     * <p>If this stream is unordered, and some (but not all) elements of this\n     * stream match the given predicate, then the behavior of this operation is\n     * nondeterministic; it is free to take any subset of matching elements\n     * (which includes the empty set).\n     *\n     * <p>Independent of whether this stream is ordered or unordered if all\n     * elements of this stream match the given predicate then this operation\n     * takes all elements (the result is the same as the input), or if no\n     * elements of the stream match the given predicate then no elements are\n     * taken (the result is an empty stream).\n     *\n     * <p>This is a <a href=\"package-summary.html#StreamOps\">short-circuiting\n     * stateful intermediate operation</a>.\n     *\n     * @implSpec\n     * The default implementation obtains the {@link #spliterator() spliterator}\n     * of this stream, wraps that spliterator so as to support the semantics\n     * of this operation on traversal, and returns a new stream associated with\n     * the wrapped spliterator.  The returned stream preserves the execution\n     * characteristics of this stream (namely parallel or sequential execution\n     * as per {@link #isParallel()}) but the wrapped spliterator may choose to\n     * not support splitting.  When the returned stream is closed, the close\n     * handlers for both the returned and this stream are invoked.\n     *\n     * @apiNote\n     * While {@code takeWhile()} is generally a cheap operation on sequential\n     * stream pipelines, it can be quite expensive on ordered parallel\n     * pipelines, since the operation is constrained to return not just any\n     * valid prefix, but the longest prefix of elements in the encounter order.\n     * Using an unordered stream source (such as {@link #generate(Supplier)}) or\n     * removing the ordering constraint with {@link #unordered()} may result in\n     * significant speedups of {@code takeWhile()} in parallel pipelines, if the\n     * semantics of your situation permit.  If consistency with encounter order\n     * is required, and you are experiencing poor performance or memory\n     * utilization with {@code takeWhile()} in parallel pipelines, switching to\n     * sequential execution with {@link #sequential()} may improve performance.\n     *\n     * @param predicate a <a href=\"package-summary.html#NonInterference\">non-interfering</a>,\n     *                  <a href=\"package-summary.html#Statelessness\">stateless</a>\n     *                  predicate to apply to elements to determine the longest\n     *                  prefix of elements.\n     * @return the new stream\n     * @since 9\n     ",
    "links" : [ "#spliterator()", "#isParallel()", "#generate(Supplier)", "#unordered()", "#sequential()" ]
  }, {
    "name" : " Stream<T> dropWhile(Predicate<? super T> predicate)",
    "returnType" : "Stream<T>",
    "comment" : "\n     * Returns, if this stream is ordered, a stream consisting of the remaining\n     * elements of this stream after dropping the longest prefix of elements\n     * that match the given predicate.  Otherwise returns, if this stream is\n     * unordered, a stream consisting of the remaining elements of this stream\n     * after dropping a subset of elements that match the given predicate.\n     *\n     * <p>If this stream is ordered then the longest prefix is a contiguous\n     * sequence of elements of this stream that match the given predicate.  The\n     * first element of the sequence is the first element of this stream, and\n     * the element immediately following the last element of the sequence does\n     * not match the given predicate.\n     *\n     * <p>If this stream is unordered, and some (but not all) elements of this\n     * stream match the given predicate, then the behavior of this operation is\n     * nondeterministic; it is free to drop any subset of matching elements\n     * (which includes the empty set).\n     *\n     * <p>Independent of whether this stream is ordered or unordered if all\n     * elements of this stream match the given predicate then this operation\n     * drops all elements (the result is an empty stream), or if no elements of\n     * the stream match the given predicate then no elements are dropped (the\n     * result is the same as the input).\n     *\n     * <p>This is a <a href=\"package-summary.html#StreamOps\">stateful\n     * intermediate operation</a>.\n     *\n     * @implSpec\n     * The default implementation obtains the {@link #spliterator() spliterator}\n     * of this stream, wraps that spliterator so as to support the semantics\n     * of this operation on traversal, and returns a new stream associated with\n     * the wrapped spliterator.  The returned stream preserves the execution\n     * characteristics of this stream (namely parallel or sequential execution\n     * as per {@link #isParallel()}) but the wrapped spliterator may choose to\n     * not support splitting.  When the returned stream is closed, the close\n     * handlers for both the returned and this stream are invoked.\n     *\n     * @apiNote\n     * While {@code dropWhile()} is generally a cheap operation on sequential\n     * stream pipelines, it can be quite expensive on ordered parallel\n     * pipelines, since the operation is constrained to return not just any\n     * valid prefix, but the longest prefix of elements in the encounter order.\n     * Using an unordered stream source (such as {@link #generate(Supplier)}) or\n     * removing the ordering constraint with {@link #unordered()} may result in\n     * significant speedups of {@code dropWhile()} in parallel pipelines, if the\n     * semantics of your situation permit.  If consistency with encounter order\n     * is required, and you are experiencing poor performance or memory\n     * utilization with {@code dropWhile()} in parallel pipelines, switching to\n     * sequential execution with {@link #sequential()} may improve performance.\n     *\n     * @param predicate a <a href=\"package-summary.html#NonInterference\">non-interfering</a>,\n     *                  <a href=\"package-summary.html#Statelessness\">stateless</a>\n     *                  predicate to apply to elements to determine the longest\n     *                  prefix of elements.\n     * @return the new stream\n     * @since 9\n     ",
    "links" : [ "#spliterator()", "#isParallel()", "#generate(Supplier)", "#unordered()", "#sequential()" ]
  }, {
    "name" : " void forEach(Consumer<? super T> action)",
    "returnType" : "void",
    "comment" : "\n     * Performs an action for each element of this stream.\n     *\n     * <p>This is a <a href=\"package-summary.html#StreamOps\">terminal\n     * operation</a>.\n     *\n     * <p>The behavior of this operation is explicitly nondeterministic.\n     * For parallel stream pipelines, this operation does <em>not</em>\n     * guarantee to respect the encounter order of the stream, as doing so\n     * would sacrifice the benefit of parallelism.  For any given element, the\n     * action may be performed at whatever time and in whatever thread the\n     * library chooses.  If the action accesses shared state, it is\n     * responsible for providing the required synchronization.\n     *\n     * @param action a <a href=\"package-summary.html#NonInterference\">\n     *               non-interfering</a> action to perform on the elements\n     ",
    "links" : [ ]
  }, {
    "name" : " void forEachOrdered(Consumer<? super T> action)",
    "returnType" : "void",
    "comment" : "\n     * Performs an action for each element of this stream, in the encounter\n     * order of the stream if the stream has a defined encounter order.\n     *\n     * <p>This is a <a href=\"package-summary.html#StreamOps\">terminal\n     * operation</a>.\n     *\n     * <p>This operation processes the elements one at a time, in encounter\n     * order if one exists.  Performing the action for one element\n     * <a href=\"../concurrent/package-summary.html#MemoryVisibility\"><i>happens-before</i></a>\n     * performing the action for subsequent elements, but for any given element,\n     * the action may be performed in whatever thread the library chooses.\n     *\n     * @param action a <a href=\"package-summary.html#NonInterference\">\n     *               non-interfering</a> action to perform on the elements\n     * @see #forEach(Consumer)\n     ",
    "links" : [ ]
  }, {
    "name" : " Object[] toArray()",
    "returnType" : "Object[]",
    "comment" : "\n     * Returns an array containing the elements of this stream.\n     *\n     * <p>This is a <a href=\"package-summary.html#StreamOps\">terminal\n     * operation</a>.\n     *\n     * @return an array, whose {@linkplain Class#getComponentType runtime component\n     * type} is {@code Object}, containing the elements of this stream\n     ",
    "links" : [ ]
  }, {
    "name" : " A[] toArray(IntFunction<A[]> generator)",
    "returnType" : "A[]",
    "comment" : "\n     * Returns an array containing the elements of this stream, using the\n     * provided {@code generator} function to allocate the returned array, as\n     * well as any additional arrays that might be required for a partitioned\n     * execution or for resizing.\n     *\n     * <p>This is a <a href=\"package-summary.html#StreamOps\">terminal\n     * operation</a>.\n     *\n     * @apiNote\n     * The generator function takes an integer, which is the size of the\n     * desired array, and produces an array of the desired size.  This can be\n     * concisely expressed with an array constructor reference:\n     * <pre>{@code\n     *     Person[] men = people.stream()\n     *                          .filter(p -> p.getGender() == MALE)\n     *                          .toArray(Person[]::new);\n     * }</pre>\n     *\n     * @param <A> the component type of the resulting array\n     * @param generator a function which produces a new array of the desired\n     *                  type and the provided length\n     * @return an array containing the elements in this stream\n     * @throws ArrayStoreException if the runtime type of any element of this\n     *         stream is not assignable to the {@linkplain Class#getComponentType\n     *         runtime component type} of the generated array\n     ",
    "links" : [ ]
  }, {
    "name" : " T reduce(T identity, BinaryOperator<T> accumulator)",
    "returnType" : "T",
    "comment" : "\n     * Performs a <a href=\"package-summary.html#Reduction\">reduction</a> on the\n     * elements of this stream, using the provided identity value and an\n     * <a href=\"package-summary.html#Associativity\">associative</a>\n     * accumulation function, and returns the reduced value.  This is equivalent\n     * to:\n     * <pre>{@code\n     *     T result = identity;\n     *     for (T element : this stream)\n     *         result = accumulator.apply(result, element)\n     *     return result;\n     * }</pre>\n     *\n     * but is not constrained to execute sequentially.\n     *\n     * <p>The {@code identity} value must be an identity for the accumulator\n     * function. This means that for all {@code t},\n     * {@code accumulator.apply(identity, t)} is equal to {@code t}.\n     * The {@code accumulator} function must be an\n     * <a href=\"package-summary.html#Associativity\">associative</a> function.\n     *\n     * <p>This is a <a href=\"package-summary.html#StreamOps\">terminal\n     * operation</a>.\n     *\n     * @apiNote Sum, min, max, average, and string concatenation are all special\n     * cases of reduction. Summing a stream of numbers can be expressed as:\n     *\n     * <pre>{@code\n     *     Integer sum = integers.reduce(0, (a, b) -> a+b);\n     * }</pre>\n     *\n     * or:\n     *\n     * <pre>{@code\n     *     Integer sum = integers.reduce(0, Integer::sum);\n     * }</pre>\n     *\n     * <p>While this may seem a more roundabout way to perform an aggregation\n     * compared to simply mutating a running total in a loop, reduction\n     * operations parallelize more gracefully, without needing additional\n     * synchronization and with greatly reduced risk of data races.\n     *\n     * @param identity the identity value for the accumulating function\n     * @param accumulator an <a href=\"package-summary.html#Associativity\">associative</a>,\n     *                    <a href=\"package-summary.html#NonInterference\">non-interfering</a>,\n     *                    <a href=\"package-summary.html#Statelessness\">stateless</a>\n     *                    function for combining two values\n     * @return the result of the reduction\n     ",
    "links" : [ ]
  }, {
    "name" : " Optional<T> reduce(BinaryOperator<T> accumulator)",
    "returnType" : "Optional<T>",
    "comment" : "\n     * Performs a <a href=\"package-summary.html#Reduction\">reduction</a> on the\n     * elements of this stream, using an\n     * <a href=\"package-summary.html#Associativity\">associative</a> accumulation\n     * function, and returns an {@code Optional} describing the reduced value,\n     * if any. This is equivalent to:\n     * <pre>{@code\n     *     boolean foundAny = false;\n     *     T result = null;\n     *     for (T element : this stream) {\n     *         if (!foundAny) {\n     *             foundAny = true;\n     *             result = element;\n     *         }\n     *         else\n     *             result = accumulator.apply(result, element);\n     *     }\n     *     return foundAny ? Optional.of(result) : Optional.empty();\n     * }</pre>\n     *\n     * but is not constrained to execute sequentially.\n     *\n     * <p>The {@code accumulator} function must be an\n     * <a href=\"package-summary.html#Associativity\">associative</a> function.\n     *\n     * <p>This is a <a href=\"package-summary.html#StreamOps\">terminal\n     * operation</a>.\n     *\n     * @param accumulator an <a href=\"package-summary.html#Associativity\">associative</a>,\n     *                    <a href=\"package-summary.html#NonInterference\">non-interfering</a>,\n     *                    <a href=\"package-summary.html#Statelessness\">stateless</a>\n     *                    function for combining two values\n     * @return an {@link Optional} describing the result of the reduction\n     * @throws NullPointerException if the result of the reduction is null\n     * @see #reduce(Object, BinaryOperator)\n     * @see #min(Comparator)\n     * @see #max(Comparator)\n     ",
    "links" : [ "Optional" ]
  }, {
    "name" : " U reduce(U identity, BiFunction<U, ? super T, U> accumulator, BinaryOperator<U> combiner)",
    "returnType" : "U",
    "comment" : "\n     * Performs a <a href=\"package-summary.html#Reduction\">reduction</a> on the\n     * elements of this stream, using the provided identity, accumulation and\n     * combining functions.  This is equivalent to:\n     * <pre>{@code\n     *     U result = identity;\n     *     for (T element : this stream)\n     *         result = accumulator.apply(result, element)\n     *     return result;\n     * }</pre>\n     *\n     * but is not constrained to execute sequentially.\n     *\n     * <p>The {@code identity} value must be an identity for the combiner\n     * function.  This means that for all {@code u}, {@code combiner(identity, u)}\n     * is equal to {@code u}.  Additionally, the {@code combiner} function\n     * must be compatible with the {@code accumulator} function; for all\n     * {@code u} and {@code t}, the following must hold:\n     * <pre>{@code\n     *     combiner.apply(u, accumulator.apply(identity, t)) == accumulator.apply(u, t)\n     * }</pre>\n     *\n     * <p>This is a <a href=\"package-summary.html#StreamOps\">terminal\n     * operation</a>.\n     *\n     * @apiNote Many reductions using this form can be represented more simply\n     * by an explicit combination of {@code map} and {@code reduce} operations.\n     * The {@code accumulator} function acts as a fused mapper and accumulator,\n     * which can sometimes be more efficient than separate mapping and reduction,\n     * such as when knowing the previously reduced value allows you to avoid\n     * some computation.\n     *\n     * @param <U> The type of the result\n     * @param identity the identity value for the combiner function\n     * @param accumulator an <a href=\"package-summary.html#Associativity\">associative</a>,\n     *                    <a href=\"package-summary.html#NonInterference\">non-interfering</a>,\n     *                    <a href=\"package-summary.html#Statelessness\">stateless</a>\n     *                    function for incorporating an additional element into a result\n     * @param combiner an <a href=\"package-summary.html#Associativity\">associative</a>,\n     *                    <a href=\"package-summary.html#NonInterference\">non-interfering</a>,\n     *                    <a href=\"package-summary.html#Statelessness\">stateless</a>\n     *                    function for combining two values, which must be\n     *                    compatible with the accumulator function\n     * @return the result of the reduction\n     * @see #reduce(BinaryOperator)\n     * @see #reduce(Object, BinaryOperator)\n     ",
    "links" : [ ]
  }, {
    "name" : " R collect(Supplier<R> supplier, BiConsumer<R, ? super T> accumulator, BiConsumer<R, R> combiner)",
    "returnType" : "R",
    "comment" : "\n     * Performs a <a href=\"package-summary.html#MutableReduction\">mutable\n     * reduction</a> operation on the elements of this stream.  A mutable\n     * reduction is one in which the reduced value is a mutable result container,\n     * such as an {@code ArrayList}, and elements are incorporated by updating\n     * the state of the result rather than by replacing the result.  This\n     * produces a result equivalent to:\n     * <pre>{@code\n     *     R result = supplier.get();\n     *     for (T element : this stream)\n     *         accumulator.accept(result, element);\n     *     return result;\n     * }</pre>\n     *\n     * <p>Like {@link #reduce(Object, BinaryOperator)}, {@code collect} operations\n     * can be parallelized without requiring additional synchronization.\n     *\n     * <p>This is a <a href=\"package-summary.html#StreamOps\">terminal\n     * operation</a>.\n     *\n     * @apiNote There are many existing classes in the JDK whose signatures are\n     * well-suited for use with method references as arguments to {@code collect()}.\n     * For example, the following will accumulate strings into an {@code ArrayList}:\n     * <pre>{@code\n     *     List<String> asList = stringStream.collect(ArrayList::new, ArrayList::add,\n     *                                                ArrayList::addAll);\n     * }</pre>\n     *\n     * <p>The following will take a stream of strings and concatenates them into a\n     * single string:\n     * <pre>{@code\n     *     String concat = stringStream.collect(StringBuilder::new, StringBuilder::append,\n     *                                          StringBuilder::append)\n     *                                 .toString();\n     * }</pre>\n     *\n     * @param <R> the type of the mutable result container\n     * @param supplier a function that creates a new mutable result container.\n     *                 For a parallel execution, this function may be called\n     *                 multiple times and must return a fresh value each time.\n     * @param accumulator an <a href=\"package-summary.html#Associativity\">associative</a>,\n     *                    <a href=\"package-summary.html#NonInterference\">non-interfering</a>,\n     *                    <a href=\"package-summary.html#Statelessness\">stateless</a>\n     *                    function that must fold an element into a result\n     *                    container.\n     * @param combiner an <a href=\"package-summary.html#Associativity\">associative</a>,\n     *                    <a href=\"package-summary.html#NonInterference\">non-interfering</a>,\n     *                    <a href=\"package-summary.html#Statelessness\">stateless</a>\n     *                    function that accepts two partial result containers\n     *                    and merges them, which must be compatible with the\n     *                    accumulator function.  The combiner function must fold\n     *                    the elements from the second result container into the\n     *                    first result container.\n     * @return the result of the reduction\n     ",
    "links" : [ "#reduce(Object" ]
  }, {
    "name" : " R collect(Collector<? super T, A, R> collector)",
    "returnType" : "R",
    "comment" : "\n     * Performs a <a href=\"package-summary.html#MutableReduction\">mutable\n     * reduction</a> operation on the elements of this stream using a\n     * {@code Collector}.  A {@code Collector}\n     * encapsulates the functions used as arguments to\n     * {@link #collect(Supplier, BiConsumer, BiConsumer)}, allowing for reuse of\n     * collection strategies and composition of collect operations such as\n     * multiple-level grouping or partitioning.\n     *\n     * <p>If the stream is parallel, and the {@code Collector}\n     * is {@link Collector.Characteristics#CONCURRENT concurrent}, and\n     * either the stream is unordered or the collector is\n     * {@link Collector.Characteristics#UNORDERED unordered},\n     * then a concurrent reduction will be performed (see {@link Collector} for\n     * details on concurrent reduction.)\n     *\n     * <p>This is a <a href=\"package-summary.html#StreamOps\">terminal\n     * operation</a>.\n     *\n     * <p>When executed in parallel, multiple intermediate results may be\n     * instantiated, populated, and merged so as to maintain isolation of\n     * mutable data structures.  Therefore, even when executed in parallel\n     * with non-thread-safe data structures (such as {@code ArrayList}), no\n     * additional synchronization is needed for a parallel reduction.\n     *\n     * @apiNote\n     * The following will accumulate strings into a List:\n     * <pre>{@code\n     *     List<String> asList = stringStream.collect(Collectors.toList());\n     * }</pre>\n     *\n     * <p>The following will classify {@code Person} objects by city:\n     * <pre>{@code\n     *     Map<String, List<Person>> peopleByCity\n     *         = personStream.collect(Collectors.groupingBy(Person::getCity));\n     * }</pre>\n     *\n     * <p>The following will classify {@code Person} objects by state and city,\n     * cascading two {@code Collector}s together:\n     * <pre>{@code\n     *     Map<String, Map<String, List<Person>>> peopleByStateAndCity\n     *         = personStream.collect(Collectors.groupingBy(Person::getState,\n     *                                                      Collectors.groupingBy(Person::getCity)));\n     * }</pre>\n     *\n     * @param <R> the type of the result\n     * @param <A> the intermediate accumulation type of the {@code Collector}\n     * @param collector the {@code Collector} describing the reduction\n     * @return the result of the reduction\n     * @see #collect(Supplier, BiConsumer, BiConsumer)\n     * @see Collectors\n     ",
    "links" : [ "Collector.Characteristics#UNORDERED", "Collector.Characteristics#CONCURRENT", "java.util.stream.Collector", "#collect(Supplier" ]
  }, {
    "name" : " List<T> toList()",
    "returnType" : "List<T>",
    "comment" : "\n     * Accumulates the elements of this stream into a {@code List}. The elements in\n     * the list will be in this stream's encounter order, if one exists. The returned List\n     * is unmodifiable; calls to any mutator method will always cause\n     * {@code UnsupportedOperationException} to be thrown. There are no\n     * guarantees on the implementation type or serializability of the returned List.\n     *\n     * <p>The returned instance may be <a href=\"{@docRoot}/java.base/java/lang/doc-files/ValueBased.html\">value-based</a>.\n     * Callers should make no assumptions about the identity of the returned instances.\n     * Identity-sensitive operations on these instances (reference equality ({@code ==}),\n     * identity hash code, and synchronization) are unreliable and should be avoided.\n     *\n     * <p>This is a <a href=\"package-summary.html#StreamOps\">terminal operation</a>.\n     *\n     * @apiNote If more control over the returned object is required, use\n     * {@link Collectors#toCollection(Supplier)}.\n     *\n     * @implSpec The implementation in this interface returns a List produced as if by the following:\n     * <pre>{@code\n     * Collections.unmodifiableList(new ArrayList<>(Arrays.asList(this.toArray())))\n     * }</pre>\n     *\n     * @implNote Most instances of Stream will override this method and provide an implementation\n     * that is highly optimized compared to the implementation in this interface.\n     *\n     * @return a List containing the stream elements\n     *\n     * @since 16\n     ",
    "links" : [ "java.util.stream.Collectors#toCollection(Supplier)" ]
  }, {
    "name" : " Optional<T> min(Comparator<? super T> comparator)",
    "returnType" : "Optional<T>",
    "comment" : "\n     * Returns the minimum element of this stream according to the provided\n     * {@code Comparator}.  This is a special case of a\n     * <a href=\"package-summary.html#Reduction\">reduction</a>.\n     *\n     * <p>This is a <a href=\"package-summary.html#StreamOps\">terminal operation</a>.\n     *\n     * @param comparator a <a href=\"package-summary.html#NonInterference\">non-interfering</a>,\n     *                   <a href=\"package-summary.html#Statelessness\">stateless</a>\n     *                   {@code Comparator} to compare elements of this stream\n     * @return an {@code Optional} describing the minimum element of this stream,\n     * or an empty {@code Optional} if the stream is empty\n     * @throws NullPointerException if the minimum element is null\n     ",
    "links" : [ ]
  }, {
    "name" : " Optional<T> max(Comparator<? super T> comparator)",
    "returnType" : "Optional<T>",
    "comment" : "\n     * Returns the maximum element of this stream according to the provided\n     * {@code Comparator}.  This is a special case of a\n     * <a href=\"package-summary.html#Reduction\">reduction</a>.\n     *\n     * <p>This is a <a href=\"package-summary.html#StreamOps\">terminal\n     * operation</a>.\n     *\n     * @param comparator a <a href=\"package-summary.html#NonInterference\">non-interfering</a>,\n     *                   <a href=\"package-summary.html#Statelessness\">stateless</a>\n     *                   {@code Comparator} to compare elements of this stream\n     * @return an {@code Optional} describing the maximum element of this stream,\n     * or an empty {@code Optional} if the stream is empty\n     * @throws NullPointerException if the maximum element is null\n     ",
    "links" : [ ]
  }, {
    "name" : " long count()",
    "returnType" : "long",
    "comment" : "\n     * Returns the count of elements in this stream.  This is a special case of\n     * a <a href=\"package-summary.html#Reduction\">reduction</a> and is\n     * equivalent to:\n     * <pre>{@code\n     *     return mapToLong(e -> 1L).sum();\n     * }</pre>\n     *\n     * <p>This is a <a href=\"package-summary.html#StreamOps\">terminal operation</a>.\n     *\n     * @apiNote\n     * An implementation may choose to not execute the stream pipeline (either\n     * sequentially or in parallel) if it is capable of computing the count\n     * directly from the stream source.  In such cases no source elements will\n     * be traversed and no intermediate operations will be evaluated.\n     * Behavioral parameters with side-effects, which are strongly discouraged\n     * except for harmless cases such as debugging, may be affected.  For\n     * example, consider the following stream:\n     * <pre>{@code\n     *     List<String> l = Arrays.asList(\"A\", \"B\", \"C\", \"D\");\n     *     long count = l.stream().peek(System.out::println).count();\n     * }</pre>\n     * The number of elements covered by the stream source, a {@code List}, is\n     * known and the intermediate operation, {@code peek}, does not inject into\n     * or remove elements from the stream (as may be the case for\n     * {@code flatMap} or {@code filter} operations).  Thus the count is the\n     * size of the {@code List} and there is no need to execute the pipeline\n     * and, as a side-effect, print out the list elements.\n     *\n     * @return the count of elements in this stream\n     ",
    "links" : [ ]
  }, {
    "name" : " boolean anyMatch(Predicate<? super T> predicate)",
    "returnType" : "boolean",
    "comment" : "\n     * Returns whether any elements of this stream match the provided\n     * predicate.  May not evaluate the predicate on all elements if not\n     * necessary for determining the result.  If the stream is empty then\n     * {@code false} is returned and the predicate is not evaluated.\n     *\n     * <p>This is a <a href=\"package-summary.html#StreamOps\">short-circuiting\n     * terminal operation</a>.\n     *\n     * @apiNote\n     * This method evaluates the <em>existential quantification</em> of the\n     * predicate over the elements of the stream (for some x P(x)).\n     *\n     * @param predicate a <a href=\"package-summary.html#NonInterference\">non-interfering</a>,\n     *                  <a href=\"package-summary.html#Statelessness\">stateless</a>\n     *                  predicate to apply to elements of this stream\n     * @return {@code true} if any elements of the stream match the provided\n     * predicate, otherwise {@code false}\n     ",
    "links" : [ ]
  }, {
    "name" : " boolean allMatch(Predicate<? super T> predicate)",
    "returnType" : "boolean",
    "comment" : "\n     * Returns whether all elements of this stream match the provided predicate.\n     * May not evaluate the predicate on all elements if not necessary for\n     * determining the result.  If the stream is empty then {@code true} is\n     * returned and the predicate is not evaluated.\n     *\n     * <p>This is a <a href=\"package-summary.html#StreamOps\">short-circuiting\n     * terminal operation</a>.\n     *\n     * @apiNote\n     * This method evaluates the <em>universal quantification</em> of the\n     * predicate over the elements of the stream (for all x P(x)).  If the\n     * stream is empty, the quantification is said to be <em>vacuously\n     * satisfied</em> and is always {@code true} (regardless of P(x)).\n     *\n     * @param predicate a <a href=\"package-summary.html#NonInterference\">non-interfering</a>,\n     *                  <a href=\"package-summary.html#Statelessness\">stateless</a>\n     *                  predicate to apply to elements of this stream\n     * @return {@code true} if either all elements of the stream match the\n     * provided predicate or the stream is empty, otherwise {@code false}\n     ",
    "links" : [ ]
  }, {
    "name" : " boolean noneMatch(Predicate<? super T> predicate)",
    "returnType" : "boolean",
    "comment" : "\n     * Returns whether no elements of this stream match the provided predicate.\n     * May not evaluate the predicate on all elements if not necessary for\n     * determining the result.  If the stream is empty then {@code true} is\n     * returned and the predicate is not evaluated.\n     *\n     * <p>This is a <a href=\"package-summary.html#StreamOps\">short-circuiting\n     * terminal operation</a>.\n     *\n     * @apiNote\n     * This method evaluates the <em>universal quantification</em> of the\n     * negated predicate over the elements of the stream (for all x ~P(x)).  If\n     * the stream is empty, the quantification is said to be vacuously satisfied\n     * and is always {@code true}, regardless of P(x).\n     *\n     * @param predicate a <a href=\"package-summary.html#NonInterference\">non-interfering</a>,\n     *                  <a href=\"package-summary.html#Statelessness\">stateless</a>\n     *                  predicate to apply to elements of this stream\n     * @return {@code true} if either no elements of the stream match the\n     * provided predicate or the stream is empty, otherwise {@code false}\n     ",
    "links" : [ ]
  }, {
    "name" : " Optional<T> findFirst()",
    "returnType" : "Optional<T>",
    "comment" : "\n     * Returns an {@link Optional} describing the first element of this stream,\n     * or an empty {@code Optional} if the stream is empty.  If the stream has\n     * no encounter order, then any element may be returned.\n     *\n     * <p>This is a <a href=\"package-summary.html#StreamOps\">short-circuiting\n     * terminal operation</a>.\n     *\n     * @return an {@code Optional} describing the first element of this stream,\n     * or an empty {@code Optional} if the stream is empty\n     * @throws NullPointerException if the element selected is null\n     ",
    "links" : [ "Optional" ]
  }, {
    "name" : " Optional<T> findAny()",
    "returnType" : "Optional<T>",
    "comment" : "\n     * Returns an {@link Optional} describing some element of the stream, or an\n     * empty {@code Optional} if the stream is empty.\n     *\n     * <p>This is a <a href=\"package-summary.html#StreamOps\">short-circuiting\n     * terminal operation</a>.\n     *\n     * <p>The behavior of this operation is explicitly nondeterministic; it is\n     * free to select any element in the stream.  This is to allow for maximal\n     * performance in parallel operations; the cost is that multiple invocations\n     * on the same source may not return the same result.  (If a stable result\n     * is desired, use {@link #findFirst()} instead.)\n     *\n     * @return an {@code Optional} describing some element of this stream, or an\n     * empty {@code Optional} if the stream is empty\n     * @throws NullPointerException if the element selected is null\n     * @see #findFirst()\n     ",
    "links" : [ "Optional", "#findFirst()" ]
  }, {
    "name" : "public static Builder<T> builder()",
    "returnType" : "Builder<T>",
    "comment" : "\n     * Returns a builder for a {@code Stream}.\n     *\n     * @param <T> type of elements\n     * @return a stream builder\n     ",
    "links" : [ ]
  }, {
    "name" : "public static Stream<T> empty()",
    "returnType" : "Stream<T>",
    "comment" : "\n     * Returns an empty sequential {@code Stream}.\n     *\n     * @param <T> the type of stream elements\n     * @return an empty sequential stream\n     ",
    "links" : [ ]
  }, {
    "name" : "public static Stream<T> of(T t)",
    "returnType" : "Stream<T>",
    "comment" : "\n     * Returns a sequential {@code Stream} containing a single element.\n     *\n     * @param t the single element\n     * @param <T> the type of stream elements\n     * @return a singleton sequential stream\n     ",
    "links" : [ ]
  }, {
    "name" : "public static Stream<T> ofNullable(T t)",
    "returnType" : "Stream<T>",
    "comment" : "\n     * Returns a sequential {@code Stream} containing a single element, if\n     * non-null, otherwise returns an empty {@code Stream}.\n     *\n     * @param t the single element\n     * @param <T> the type of stream elements\n     * @return a stream with a single element if the specified element\n     *         is non-null, otherwise an empty stream\n     * @since 9\n     ",
    "links" : [ ]
  }, {
    "name" : "public static Stream<T> of(T... values)",
    "returnType" : "Stream<T>",
    "comment" : "\n     * Returns a sequential ordered stream whose elements are the specified values.\n     *\n     * @param <T> the type of stream elements\n     * @param values the elements of the new stream\n     * @return the new stream\n     ",
    "links" : [ ]
  }, {
    "name" : "public static Stream<T> iterate(final T seed, final UnaryOperator<T> f)",
    "returnType" : "Stream<T>",
    "comment" : "\n     * Returns an infinite sequential ordered {@code Stream} produced by iterative\n     * application of a function {@code f} to an initial element {@code seed},\n     * producing a {@code Stream} consisting of {@code seed}, {@code f(seed)},\n     * {@code f(f(seed))}, etc.\n     *\n     * <p>The first element (position {@code 0}) in the {@code Stream} will be\n     * the provided {@code seed}.  For {@code n > 0}, the element at position\n     * {@code n}, will be the result of applying the function {@code f} to the\n     * element at position {@code n - 1}.\n     *\n     * <p>The action of applying {@code f} for one element\n     * <a href=\"../concurrent/package-summary.html#MemoryVisibility\"><i>happens-before</i></a>\n     * the action of applying {@code f} for subsequent elements.  For any given\n     * element the action may be performed in whatever thread the library\n     * chooses.\n     *\n     * @param <T> the type of stream elements\n     * @param seed the initial element\n     * @param f a function to be applied to the previous element to produce\n     *          a new element\n     * @return a new sequential {@code Stream}\n     ",
    "links" : [ ]
  }, {
    "name" : "public static Stream<T> iterate(T seed, Predicate<? super T> hasNext, UnaryOperator<T> next)",
    "returnType" : "Stream<T>",
    "comment" : "\n     * Returns a sequential ordered {@code Stream} produced by iterative\n     * application of the given {@code next} function to an initial element,\n     * conditioned on satisfying the given {@code hasNext} predicate.  The\n     * stream terminates as soon as the {@code hasNext} predicate returns false.\n     *\n     * <p>{@code Stream.iterate} should produce the same sequence of elements as\n     * produced by the corresponding for-loop:\n     * <pre>{@code\n     *     for (T index=seed; hasNext.test(index); index = next.apply(index)) {\n     *         ...\n     *     }\n     * }</pre>\n     *\n     * <p>The resulting sequence may be empty if the {@code hasNext} predicate\n     * does not hold on the seed value.  Otherwise the first element will be the\n     * supplied {@code seed} value, the next element (if present) will be the\n     * result of applying the {@code next} function to the {@code seed} value,\n     * and so on iteratively until the {@code hasNext} predicate indicates that\n     * the stream should terminate.\n     *\n     * <p>The action of applying the {@code hasNext} predicate to an element\n     * <a href=\"../concurrent/package-summary.html#MemoryVisibility\"><i>happens-before</i></a>\n     * the action of applying the {@code next} function to that element.  The\n     * action of applying the {@code next} function for one element\n     * <i>happens-before</i> the action of applying the {@code hasNext}\n     * predicate for subsequent elements.  For any given element an action may\n     * be performed in whatever thread the library chooses.\n     *\n     * @param <T> the type of stream elements\n     * @param seed the initial element\n     * @param hasNext a predicate to apply to elements to determine when the\n     *                stream must terminate.\n     * @param next a function to be applied to the previous element to produce\n     *             a new element\n     * @return a new sequential {@code Stream}\n     * @since 9\n     ",
    "links" : [ ]
  }, {
    "name" : "public static Stream<T> generate(Supplier<? extends T> s)",
    "returnType" : "Stream<T>",
    "comment" : "\n     * Returns an infinite sequential unordered stream where each element is\n     * generated by the provided {@code Supplier}.  This is suitable for\n     * generating constant streams, streams of random elements, etc.\n     *\n     * @param <T> the type of stream elements\n     * @param s the {@code Supplier} of generated elements\n     * @return a new infinite sequential unordered {@code Stream}\n     ",
    "links" : [ ]
  }, {
    "name" : "public static Stream<T> concat(Stream<? extends T> a, Stream<? extends T> b)",
    "returnType" : "Stream<T>",
    "comment" : "\n     * Creates a lazily concatenated stream whose elements are all the\n     * elements of the first stream followed by all the elements of the\n     * second stream.  The resulting stream is ordered if both\n     * of the input streams are ordered, and parallel if either of the input\n     * streams is parallel.  When the resulting stream is closed, the close\n     * handlers for both input streams are invoked.\n     *\n     * <p>This method operates on the two input streams and binds each stream\n     * to its source.  As a result subsequent modifications to an input stream\n     * source may not be reflected in the concatenated stream result.\n     *\n     * @implNote\n     * Use caution when constructing streams from repeated concatenation.\n     * Accessing an element of a deeply concatenated stream can result in deep\n     * call chains, or even {@code StackOverflowError}.\n     *\n     * <p>Subsequent changes to the sequential/parallel execution mode of the\n     * returned stream are not guaranteed to be propagated to the input streams.\n     *\n     * @apiNote\n     * To preserve optimization opportunities this method binds each stream to\n     * its source and accepts only two streams as parameters.  For example, the\n     * exact size of the concatenated stream source can be computed if the exact\n     * size of each input stream source is known.\n     * To concatenate more streams without binding, or without nested calls to\n     * this method, try creating a stream of streams and flat-mapping with the\n     * identity function, for example:\n     * <pre>{@code\n     *     Stream<T> concat = Stream.of(s1, s2, s3, s4).flatMap(s -> s);\n     * }</pre>\n     *\n     * @param <T> The type of stream elements\n     * @param a the first stream\n     * @param b the second stream\n     * @return the concatenation of the two input streams\n     ",
    "links" : [ ]
  } ],
  "methodNames" : [ " Stream<T> filter(Predicate<? super T> predicate)", " Stream<R> map(Function<? super T, ? extends R> mapper)", " IntStream mapToInt(ToIntFunction<? super T> mapper)", " LongStream mapToLong(ToLongFunction<? super T> mapper)", " DoubleStream mapToDouble(ToDoubleFunction<? super T> mapper)", " Stream<R> flatMap(Function<? super T, ? extends Stream<? extends R>> mapper)", " IntStream flatMapToInt(Function<? super T, ? extends IntStream> mapper)", " LongStream flatMapToLong(Function<? super T, ? extends LongStream> mapper)", " DoubleStream flatMapToDouble(Function<? super T, ? extends DoubleStream> mapper)", " Stream<R> mapMulti(BiConsumer<? super T, ? super Consumer<R>> mapper)", " IntStream mapMultiToInt(BiConsumer<? super T, ? super IntConsumer> mapper)", " LongStream mapMultiToLong(BiConsumer<? super T, ? super LongConsumer> mapper)", " DoubleStream mapMultiToDouble(BiConsumer<? super T, ? super DoubleConsumer> mapper)", " Stream<T> distinct()", " Stream<T> sorted()", " Stream<T> sorted(Comparator<? super T> comparator)", " Stream<T> peek(Consumer<? super T> action)", " Stream<T> limit(long maxSize)", " Stream<T> skip(long n)", " Stream<T> takeWhile(Predicate<? super T> predicate)", " Stream<T> dropWhile(Predicate<? super T> predicate)", " void forEach(Consumer<? super T> action)", " void forEachOrdered(Consumer<? super T> action)", " Object[] toArray()", " A[] toArray(IntFunction<A[]> generator)", " T reduce(T identity, BinaryOperator<T> accumulator)", " Optional<T> reduce(BinaryOperator<T> accumulator)", " U reduce(U identity, BiFunction<U, ? super T, U> accumulator, BinaryOperator<U> combiner)", " R collect(Supplier<R> supplier, BiConsumer<R, ? super T> accumulator, BiConsumer<R, R> combiner)", " R collect(Collector<? super T, A, R> collector)", " List<T> toList()", " Optional<T> min(Comparator<? super T> comparator)", " Optional<T> max(Comparator<? super T> comparator)", " long count()", " boolean anyMatch(Predicate<? super T> predicate)", " boolean allMatch(Predicate<? super T> predicate)", " boolean noneMatch(Predicate<? super T> predicate)", " Optional<T> findFirst()", " Optional<T> findAny()", "public static Builder<T> builder()", "public static Stream<T> empty()", "public static Stream<T> of(T t)", "public static Stream<T> ofNullable(T t)", "public static Stream<T> of(T... values)", "public static Stream<T> iterate(final T seed, final UnaryOperator<T> f)", "public static Stream<T> iterate(T seed, Predicate<? super T> hasNext, UnaryOperator<T> next)", "public static Stream<T> generate(Supplier<? extends T> s)", "public static Stream<T> concat(Stream<? extends T> a, Stream<? extends T> b)" ],
  "variableNames" : [ ]
}