{
  "filePath" : "/home/maryam/clearblue/files/android-source-30/android/content/IntentFilter.java",
  "packageName" : "android.content",
  "className" : "IntentFilter",
  "comment" : "\n * Structured description of Intent values to be matched.  An IntentFilter can\n * match against actions, categories, and data (either via its type, scheme,\n * and/or path) in an Intent.  It also includes a \"priority\" value which is\n * used to order multiple matching filters.\n *\n * <p>IntentFilter objects are often created in XML as part of a package's\n * {@link android.R.styleable#AndroidManifest AndroidManifest.xml} file,\n * using {@link android.R.styleable#AndroidManifestIntentFilter intent-filter}\n * tags.\n *\n * <p>There are three Intent characteristics you can filter on: the\n * <em>action</em>, <em>data</em>, and <em>categories</em>.  For each of these\n * characteristics you can provide\n * multiple possible matching values (via {@link #addAction},\n * {@link #addDataType}, {@link #addDataScheme}, {@link #addDataSchemeSpecificPart},\n * {@link #addDataAuthority}, {@link #addDataPath}, and {@link #addCategory}, respectively).\n * For actions, if no data characteristics are specified, then the filter will\n * only match intents that contain no data.\n *\n * <p>The data characteristic is\n * itself divided into three attributes: type, scheme, authority, and path.\n * Any that are\n * specified must match the contents of the Intent.  If you specify a scheme\n * but no type, only Intent that does not have a type (such as mailto:) will\n * match; a content: URI will never match because they always have a MIME type\n * that is supplied by their content provider.  Specifying a type with no scheme\n * has somewhat special meaning: it will match either an Intent with no URI\n * field, or an Intent with a content: or file: URI.  If you specify neither,\n * then only an Intent with no data or type will match.  To specify an authority,\n * you must also specify one or more schemes that it is associated with.\n * To specify a path, you also must specify both one or more authorities and\n * one or more schemes it is associated with.\n *\n * <div class=\"special reference\">\n * <h3>Developer Guides</h3>\n * <p>For information about how to create and resolve intents, read the\n * <a href=\"{@docRoot}guide/topics/intents/intents-filters.html\">Intents and Intent Filters</a>\n * developer guide.</p>\n * </div>\n *\n * <h3>Filter Rules</h3>\n * <p>A match is based on the following rules.  Note that\n * for an IntentFilter to match an Intent, three conditions must hold:\n * the <strong>action</strong> and <strong>category</strong> must match, and\n * the data (both the <strong>data type</strong> and\n * <strong>data scheme+authority+path</strong> if specified) must match\n * (see {@link #match(ContentResolver, Intent, boolean, String)} for more details\n * on how the data fields match).\n *\n * <p><strong>Action</strong> matches if any of the given values match the\n * Intent action; if the filter specifies no actions, then it will only match\n * Intents that do not contain an action.\n *\n * <p><strong>Data Type</strong> matches if any of the given values match the\n * Intent type.  The Intent\n * type is determined by calling {@link Intent#resolveType}.  A wildcard can be\n * used for the MIME sub-type, in both the Intent and IntentFilter, so that the\n * type \"audio/*\" will match \"audio/mpeg\", \"audio/aiff\", \"audio/*\", etc.\n * <em>Note that MIME type matching here is <b>case sensitive</b>, unlike\n * formal RFC MIME types!</em>  You should thus always use lower case letters\n * for your MIME types.\n *\n * <p><strong>Data Scheme</strong> matches if any of the given values match the\n * Intent data's scheme.\n * The Intent scheme is determined by calling {@link Intent#getData}\n * and {@link android.net.Uri#getScheme} on that URI.\n * <em>Note that scheme matching here is <b>case sensitive</b>, unlike\n * formal RFC schemes!</em>  You should thus always use lower case letters\n * for your schemes.\n *\n * <p><strong>Data Scheme Specific Part</strong> matches if any of the given values match\n * the Intent's data scheme specific part <em>and</em> one of the data schemes in the filter\n * has matched the Intent, <em>or</em> no scheme specific parts were supplied in the filter.\n * The Intent scheme specific part is determined by calling\n * {@link Intent#getData} and {@link android.net.Uri#getSchemeSpecificPart} on that URI.\n * <em>Note that scheme specific part matching is <b>case sensitive</b>.</em>\n *\n * <p><strong>Data Authority</strong> matches if any of the given values match\n * the Intent's data authority <em>and</em> one of the data schemes in the filter\n * has matched the Intent, <em>or</em> no authorities were supplied in the filter.\n * The Intent authority is determined by calling\n * {@link Intent#getData} and {@link android.net.Uri#getAuthority} on that URI.\n * <em>Note that authority matching here is <b>case sensitive</b>, unlike\n * formal RFC host names!</em>  You should thus always use lower case letters\n * for your authority.\n *\n * <p><strong>Data Path</strong> matches if any of the given values match the\n * Intent's data path <em>and</em> both a scheme and authority in the filter\n * has matched against the Intent, <em>or</em> no paths were supplied in the\n * filter.  The Intent authority is determined by calling\n * {@link Intent#getData} and {@link android.net.Uri#getPath} on that URI.\n *\n * <p><strong>Categories</strong> match if <em>all</em> of the categories in\n * the Intent match categories given in the filter.  Extra categories in the\n * filter that are not in the Intent will not cause the match to fail.  Note\n * that unlike the action, an IntentFilter with no categories\n * will only match an Intent that does not have any categories.\n ",
  "variables" : [ {
    "name" : "AGLOB_STR",
    "type" : "String",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "SGLOB_STR",
    "type" : "String",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "PREFIX_STR",
    "type" : "String",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "LITERAL_STR",
    "type" : "String",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "PATH_STR",
    "type" : "String",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "PORT_STR",
    "type" : "String",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "HOST_STR",
    "type" : "String",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "AUTH_STR",
    "type" : "String",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "SSP_STR",
    "type" : "String",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "SCHEME_STR",
    "type" : "String",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "STATIC_TYPE_STR",
    "type" : "String",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "TYPE_STR",
    "type" : "String",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "GROUP_STR",
    "type" : "String",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "CAT_STR",
    "type" : "String",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "NAME_STR",
    "type" : "String",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "ACTION_STR",
    "type" : "String",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "AUTO_VERIFY_STR",
    "type" : "String",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "SYSTEM_HIGH_PRIORITY",
    "type" : "int",
    "comment" : "\n     * The filter {@link #setPriority} value at which system high-priority\n     * receivers are placed; that is, receivers that should execute before\n     * application code. Applications should never use filters with this or\n     * higher priorities.\n     *\n     * @see #setPriority\n     ",
    "links" : [ "#setPriority" ]
  }, {
    "name" : "SYSTEM_LOW_PRIORITY",
    "type" : "int",
    "comment" : "\n     * The filter {@link #setPriority} value at which system low-priority\n     * receivers are placed; that is, receivers that should execute after\n     * application code. Applications should never use filters with this or\n     * lower priorities.\n     *\n     * @see #setPriority\n     ",
    "links" : [ "#setPriority" ]
  }, {
    "name" : "MATCH_CATEGORY_MASK",
    "type" : "int",
    "comment" : "\n     * The part of a match constant that describes the category of match\n     * that occurred.  May be either {@link #MATCH_CATEGORY_EMPTY},\n     * {@link #MATCH_CATEGORY_SCHEME}, {@link #MATCH_CATEGORY_SCHEME_SPECIFIC_PART},\n     * {@link #MATCH_CATEGORY_HOST}, {@link #MATCH_CATEGORY_PORT},\n     * {@link #MATCH_CATEGORY_PATH}, or {@link #MATCH_CATEGORY_TYPE}.  Higher\n     * values indicate a better match.\n     ",
    "links" : [ "#MATCH_CATEGORY_EMPTY", "#MATCH_CATEGORY_SCHEME", "#MATCH_CATEGORY_SCHEME_SPECIFIC_PART", "#MATCH_CATEGORY_HOST", "#MATCH_CATEGORY_PORT", "#MATCH_CATEGORY_PATH", "#MATCH_CATEGORY_TYPE" ]
  }, {
    "name" : "MATCH_ADJUSTMENT_MASK",
    "type" : "int",
    "comment" : "\n     * The part of a match constant that applies a quality adjustment to the\n     * basic category of match.  The value {@link #MATCH_ADJUSTMENT_NORMAL}\n     * is no adjustment; higher numbers than that improve the quality, while\n     * lower numbers reduce it.\n     ",
    "links" : [ "#MATCH_ADJUSTMENT_NORMAL" ]
  }, {
    "name" : "MATCH_ADJUSTMENT_NORMAL",
    "type" : "int",
    "comment" : "\n     * Quality adjustment applied to the category of match that signifies\n     * the default, base value; higher numbers improve the quality while\n     * lower numbers reduce it.\n     ",
    "links" : [ ]
  }, {
    "name" : "MATCH_CATEGORY_EMPTY",
    "type" : "int",
    "comment" : "\n     * The filter matched an intent that had no data specified.\n     ",
    "links" : [ ]
  }, {
    "name" : "MATCH_CATEGORY_SCHEME",
    "type" : "int",
    "comment" : "\n     * The filter matched an intent with the same data URI scheme.\n     ",
    "links" : [ ]
  }, {
    "name" : "MATCH_CATEGORY_HOST",
    "type" : "int",
    "comment" : "\n     * The filter matched an intent with the same data URI scheme and\n     * authority host.\n     ",
    "links" : [ ]
  }, {
    "name" : "MATCH_CATEGORY_PORT",
    "type" : "int",
    "comment" : "\n     * The filter matched an intent with the same data URI scheme and\n     * authority host and port.\n     ",
    "links" : [ ]
  }, {
    "name" : "MATCH_CATEGORY_PATH",
    "type" : "int",
    "comment" : "\n     * The filter matched an intent with the same data URI scheme,\n     * authority, and path.\n     ",
    "links" : [ ]
  }, {
    "name" : "MATCH_CATEGORY_SCHEME_SPECIFIC_PART",
    "type" : "int",
    "comment" : "\n     * The filter matched an intent with the same data URI scheme and\n     * scheme specific part.\n     ",
    "links" : [ ]
  }, {
    "name" : "MATCH_CATEGORY_TYPE",
    "type" : "int",
    "comment" : "\n     * The filter matched an intent with the same data MIME type.\n     ",
    "links" : [ ]
  }, {
    "name" : "NO_MATCH_TYPE",
    "type" : "int",
    "comment" : "\n     * The filter didn't match due to different MIME types.\n     ",
    "links" : [ ]
  }, {
    "name" : "NO_MATCH_DATA",
    "type" : "int",
    "comment" : "\n     * The filter didn't match due to different data URIs.\n     ",
    "links" : [ ]
  }, {
    "name" : "NO_MATCH_ACTION",
    "type" : "int",
    "comment" : "\n     * The filter didn't match due to different actions.\n     ",
    "links" : [ ]
  }, {
    "name" : "NO_MATCH_CATEGORY",
    "type" : "int",
    "comment" : "\n     * The filter didn't match because it required one or more categories\n     * that were not in the Intent.\n     ",
    "links" : [ ]
  }, {
    "name" : "SCHEME_HTTP",
    "type" : "String",
    "comment" : "\n     * HTTP scheme.\n     *\n     * @see #addDataScheme(String)\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "SCHEME_HTTPS",
    "type" : "String",
    "comment" : "\n     * HTTPS scheme.\n     *\n     * @see #addDataScheme(String)\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "WILDCARD",
    "type" : "String",
    "comment" : "\n     * The value to indicate a wildcard for incoming match arguments.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "WILDCARD_PATH",
    "type" : "String",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "mPriority",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mOrder",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mActions",
    "type" : "ArrayList<String>",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mCategories",
    "type" : "ArrayList<String>",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mDataSchemes",
    "type" : "ArrayList<String>",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mDataSchemeSpecificParts",
    "type" : "ArrayList<PatternMatcher>",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mDataAuthorities",
    "type" : "ArrayList<AuthorityEntry>",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mDataPaths",
    "type" : "ArrayList<PatternMatcher>",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mStaticDataTypes",
    "type" : "ArrayList<String>",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mDataTypes",
    "type" : "ArrayList<String>",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mMimeGroups",
    "type" : "ArrayList<String>",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mHasStaticPartialTypes",
    "type" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mHasDynamicPartialTypes",
    "type" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "STATE_VERIFY_AUTO",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "STATE_NEED_VERIFY",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "STATE_NEED_VERIFY_CHECKED",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "STATE_VERIFIED",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mVerifyState",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "VISIBILITY_NONE",
    "type" : "int",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "VISIBILITY_EXPLICIT",
    "type" : "int",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "VISIBILITY_IMPLICIT",
    "type" : "int",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "mInstantAppVisibility",
    "type" : "int",
    "comment" : " Whether or not the intent filter is visible to instant apps. ",
    "links" : [ ]
  }, {
    "name" : "CREATOR",
    "type" : "Parcelable.Creator<IntentFilter>",
    "comment" : "",
    "links" : [ ]
  } ],
  "methods" : [ {
    "name" : "private static int findStringInSet(String[] set, String string, int[] lengths, int lenPos)",
    "returnType" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private static String[] addStringToSet(String[] set, String string, int[] lengths, int lenPos)",
    "returnType" : "String[]",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private static String[] removeStringFromSet(String[] set, String string, int[] lengths, int lenPos)",
    "returnType" : "String[]",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public static IntentFilter create(String action, String dataType)",
    "returnType" : "IntentFilter",
    "comment" : "\n     * Create a new IntentFilter instance with a specified action and MIME\n     * type, where you know the MIME type is correctly formatted.  This catches\n     * the {@link MalformedMimeTypeException} exception that the constructor\n     * can call and turns it into a runtime exception.\n     *\n     * @param action The action to match, such as Intent.ACTION_VIEW.\n     * @param dataType The type to match, such as \"vnd.android.cursor.dir/person\".\n     *\n     * @return A new IntentFilter for the given action and type.\n     *\n     * @see #IntentFilter(String, String)\n     ",
    "links" : [ "MalformedMimeTypeException" ]
  }, {
    "name" : "public final void setPriority(int priority)",
    "returnType" : "void",
    "comment" : "\n     * Modify priority of this filter.  This only affects receiver filters.\n     * The priority of activity filters are set in XML and cannot be changed\n     * programmatically. The default priority is 0. Positive values will be\n     * before the default, lower values will be after it. Applications should\n     * use a value that is larger than {@link #SYSTEM_LOW_PRIORITY} and\n     * smaller than {@link #SYSTEM_HIGH_PRIORITY} .\n     *\n     * @param priority The new priority value.\n     *\n     * @see #getPriority\n     * @see #SYSTEM_LOW_PRIORITY\n     * @see #SYSTEM_HIGH_PRIORITY\n     ",
    "links" : [ "#SYSTEM_LOW_PRIORITY", "#SYSTEM_HIGH_PRIORITY" ]
  }, {
    "name" : "public final int getPriority()",
    "returnType" : "int",
    "comment" : "\n     * Return the priority of this filter.\n     *\n     * @return The priority of the filter.\n     *\n     * @see #setPriority\n     ",
    "links" : [ ]
  }, {
    "name" : "public final void setOrder(int order)",
    "returnType" : "void",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "public final int getOrder()",
    "returnType" : "int",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "public final void setAutoVerify(boolean autoVerify)",
    "returnType" : "void",
    "comment" : "\n     * Set whether this filter will needs to be automatically verified against its data URIs or not.\n     * The default is false.\n     *\n     * The verification would need to happen only and only if the Intent action is\n     * {@link android.content.Intent#ACTION_VIEW} and the Intent category is\n     * {@link android.content.Intent#CATEGORY_BROWSABLE} and the Intent data scheme\n     * is \"http\" or \"https\".\n     *\n     * True means that the filter will need to use its data URIs to be verified.\n     *\n     * @param autoVerify The new autoVerify value.\n     *\n     * @see #getAutoVerify()\n     * @see #addAction(String)\n     * @see #getAction(int)\n     * @see #addCategory(String)\n     * @see #getCategory(int)\n     * @see #addDataScheme(String)\n     * @see #getDataScheme(int)\n     *\n     * @hide\n     ",
    "links" : [ "android.content.Intent#ACTION_VIEW", "android.content.Intent#CATEGORY_BROWSABLE" ]
  }, {
    "name" : "public final boolean getAutoVerify()",
    "returnType" : "boolean",
    "comment" : "\n     * Return if this filter will needs to be automatically verified again its data URIs or not.\n     *\n     * @return True if the filter will needs to be automatically verified. False otherwise.\n     *\n     * @see #setAutoVerify(boolean)\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public final boolean handleAllWebDataURI()",
    "returnType" : "boolean",
    "comment" : "\n     * Return if this filter handle all HTTP or HTTPS data URI or not.  This is the\n     * core check for whether a given activity qualifies as a \"browser\".\n     *\n     * @return True if the filter handle all HTTP or HTTPS data URI. False otherwise.\n     *\n     * This will check if:\n     *\n     * - either the Intent category is {@link android.content.Intent#CATEGORY_APP_BROWSER}\n     * - either the Intent action is {@link android.content.Intent#ACTION_VIEW} and\n     * the Intent category is {@link android.content.Intent#CATEGORY_BROWSABLE} and the Intent\n     * data scheme is \"http\" or \"https\" and that there is no specific host defined.\n     *\n     * @hide\n     ",
    "links" : [ "android.content.Intent#CATEGORY_APP_BROWSER", "android.content.Intent#ACTION_VIEW", "android.content.Intent#CATEGORY_BROWSABLE" ]
  }, {
    "name" : "public final boolean handlesWebUris(boolean onlyWebSchemes)",
    "returnType" : "boolean",
    "comment" : "\n     * Return if this filter handles HTTP or HTTPS data URIs.\n     *\n     * @return True if the filter handles ACTION_VIEW/CATEGORY_BROWSABLE,\n     * has at least one HTTP or HTTPS data URI pattern defined, and optionally\n     * does not define any non-http/https data URI patterns.\n     *\n     * This will check if if the Intent action is {@link android.content.Intent#ACTION_VIEW} and\n     * the Intent category is {@link android.content.Intent#CATEGORY_BROWSABLE} and the Intent\n     * data scheme is \"http\" or \"https\".\n     *\n     * @param onlyWebSchemes When true, requires that the intent filter declare\n     *     that it handles *only* http: or https: schemes.  This is a requirement for\n     *     the intent filter's domain linkage being verifiable.\n     * @hide\n     ",
    "links" : [ "android.content.Intent#ACTION_VIEW", "android.content.Intent#CATEGORY_BROWSABLE" ]
  }, {
    "name" : "public final boolean needsVerification()",
    "returnType" : "boolean",
    "comment" : "\n     * Return if this filter needs to be automatically verified again its data URIs or not.\n     *\n     * @return True if the filter needs to be automatically verified. False otherwise.\n     *\n     * This will check if if the Intent action is {@link android.content.Intent#ACTION_VIEW} and\n     * the Intent category is {@link android.content.Intent#CATEGORY_BROWSABLE} and the Intent\n     * data scheme is \"http\" or \"https\".\n     *\n     * @see #setAutoVerify(boolean)\n     *\n     * @hide\n     ",
    "links" : [ "android.content.Intent#ACTION_VIEW", "android.content.Intent#CATEGORY_BROWSABLE" ]
  }, {
    "name" : "public final boolean isVerified()",
    "returnType" : "boolean",
    "comment" : "\n     * Return if this filter has been verified\n     *\n     * @return true if the filter has been verified or if autoVerify is false.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public void setVerified(boolean verified)",
    "returnType" : "void",
    "comment" : "\n     * Set if this filter has been verified\n     *\n     * @param verified true if this filter has been verified. False otherwise.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public void setVisibilityToInstantApp(@InstantAppVisibility int visibility)",
    "returnType" : "void",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "public int getVisibilityToInstantApp()",
    "returnType" : "int",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "public boolean isVisibleToInstantApp()",
    "returnType" : "boolean",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "public boolean isExplicitlyVisibleToInstantApp()",
    "returnType" : "boolean",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "public boolean isImplicitlyVisibleToInstantApp()",
    "returnType" : "boolean",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "public final void addAction(String action)",
    "returnType" : "void",
    "comment" : "\n     * Add a new Intent action to match against.  If any actions are included\n     * in the filter, then an Intent's action must be one of those values for\n     * it to match.  If no actions are included, the Intent action is ignored.\n     *\n     * @param action Name of the action to match, such as Intent.ACTION_VIEW.\n     ",
    "links" : [ ]
  }, {
    "name" : "public final int countActions()",
    "returnType" : "int",
    "comment" : "\n     * Return the number of actions in the filter.\n     ",
    "links" : [ ]
  }, {
    "name" : "public final String getAction(int index)",
    "returnType" : "String",
    "comment" : "\n     * Return an action in the filter.\n     ",
    "links" : [ ]
  }, {
    "name" : "public final boolean hasAction(String action)",
    "returnType" : "boolean",
    "comment" : "\n     * Is the given action included in the filter?  Note that if the filter\n     * does not include any actions, false will <em>always</em> be returned.\n     *\n     * @param action The action to look for.\n     *\n     * @return True if the action is explicitly mentioned in the filter.\n     ",
    "links" : [ ]
  }, {
    "name" : "public final boolean matchAction(String action)",
    "returnType" : "boolean",
    "comment" : "\n     * Match this filter against an Intent's action.  If the filter does not\n     * specify any actions, the match will always fail.\n     *\n     * @param action The desired action to look for.\n     *\n     * @return True if the action is listed in the filter.\n     ",
    "links" : [ ]
  }, {
    "name" : "private boolean matchAction(String action, boolean wildcardSupported, @Nullable Collection<String> ignoreActions)",
    "returnType" : "boolean",
    "comment" : "\n     * Variant of {@link #matchAction(String)} that allows a wildcard for the provided action.\n     * @param wildcardSupported if true, will allow action to use wildcards\n     * @param ignoreActions if not null, the set of actions to should not be considered valid while\n     *                      calculating the match\n     ",
    "links" : [ "#matchAction" ]
  }, {
    "name" : "public final Iterator<String> actionsIterator()",
    "returnType" : "Iterator<String>",
    "comment" : "\n     * Return an iterator over the filter's actions.  If there are no actions,\n     * returns null.\n     ",
    "links" : [ ]
  }, {
    "name" : "public final void addDataType(String type) throws MalformedMimeTypeException",
    "returnType" : "void",
    "comment" : "\n     * Add a new Intent data type to match against.  If any types are\n     * included in the filter, then an Intent's data must be <em>either</em>\n     * one of these types <em>or</em> a matching scheme.  If no data types\n     * are included, then an Intent will only match if it specifies no data.\n     *\n     * <p><em>Note: MIME type matching in the Android framework is\n     * case-sensitive, unlike formal RFC MIME types.  As a result,\n     * you should always write your MIME types with lower case letters,\n     * and any MIME types you receive from outside of Android should be\n     * converted to lower case before supplying them here.</em></p>\n     *\n     * <p>Throws {@link MalformedMimeTypeException} if the given MIME type is\n     * not syntactically correct.\n     *\n     * @param type Name of the data type to match, such as \"vnd.android.cursor.dir/person\".\n     *\n     * @see #matchData\n     ",
    "links" : [ "MalformedMimeTypeException" ]
  }, {
    "name" : "public final void addDynamicDataType(String type) throws MalformedMimeTypeException",
    "returnType" : "void",
    "comment" : "\n     * Add a new Intent data type <em>from MIME group</em> to match against.  If any types are\n     * included in the filter, then an Intent's data must be <em>either</em>\n     * one of these types <em>or</em> a matching scheme.  If no data types\n     * are included, then an Intent will only match if it specifies no data.\n     *\n     * <p><em>Note: MIME type matching in the Android framework is\n     * case-sensitive, unlike formal RFC MIME types.  As a result,\n     * you should always write your MIME types with lower case letters,\n     * and any MIME types you receive from outside of Android should be\n     * converted to lower case before supplying them here.</em></p>\n     *\n     * <p>Throws {@link MalformedMimeTypeException} if the given MIME type is\n     * not syntactically correct.\n     *\n     * @param type Name of the data type to match, such as \"vnd.android.cursor.dir/person\".\n     *\n     * @see #clearDynamicDataTypes()\n     * @hide\n     ",
    "links" : [ "MalformedMimeTypeException" ]
  }, {
    "name" : "private void processMimeType(String type, BiConsumer<String, Boolean> action) throws MalformedMimeTypeException",
    "returnType" : "void",
    "comment" : "\n     * Process mime type - convert to representation used internally and check if type is partial,\n     * and then call provided action\n     ",
    "links" : [ ]
  }, {
    "name" : "public final void clearDynamicDataTypes()",
    "returnType" : "void",
    "comment" : "\n     * Remove all previously added Intent data types from IntentFilter.\n     *\n     * @see #addDynamicDataType(String)\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public int countStaticDataTypes()",
    "returnType" : "int",
    "comment" : "\n     * Return the number of static data types in the filter.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public final boolean hasDataType(String type)",
    "returnType" : "boolean",
    "comment" : "\n     * Is the given data type included in the filter?  Note that if the filter\n     * does not include any type, false will <em>always</em> be returned.\n     *\n     * @param type The data type to look for.\n     *\n     * @return True if the type is explicitly mentioned in the filter.\n     ",
    "links" : [ ]
  }, {
    "name" : "public final boolean hasExactDataType(String type)",
    "returnType" : "boolean",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "public final boolean hasExactDynamicDataType(String type)",
    "returnType" : "boolean",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "public final boolean hasExactStaticDataType(String type)",
    "returnType" : "boolean",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "public final int countDataTypes()",
    "returnType" : "int",
    "comment" : "\n     * Return the number of data types in the filter.\n     ",
    "links" : [ ]
  }, {
    "name" : "public final String getDataType(int index)",
    "returnType" : "String",
    "comment" : "\n     * Return a data type in the filter.\n     ",
    "links" : [ ]
  }, {
    "name" : "public final Iterator<String> typesIterator()",
    "returnType" : "Iterator<String>",
    "comment" : "\n     * Return an iterator over the filter's data types.\n     ",
    "links" : [ ]
  }, {
    "name" : "public final List<String> dataTypes()",
    "returnType" : "List<String>",
    "comment" : "\n     * Return copy of filter's data types.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public final void addMimeGroup(String name)",
    "returnType" : "void",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "public final boolean hasMimeGroup(String name)",
    "returnType" : "boolean",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "public final String getMimeGroup(int index)",
    "returnType" : "String",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "public final int countMimeGroups()",
    "returnType" : "int",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "public final Iterator<String> mimeGroupsIterator()",
    "returnType" : "Iterator<String>",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "public final void addDataScheme(String scheme)",
    "returnType" : "void",
    "comment" : "\n     * Add a new Intent data scheme to match against.  If any schemes are\n     * included in the filter, then an Intent's data must be <em>either</em>\n     * one of these schemes <em>or</em> a matching data type.  If no schemes\n     * are included, then an Intent will match only if it includes no data.\n     *\n     * <p><em>Note: scheme matching in the Android framework is\n     * case-sensitive, unlike formal RFC schemes.  As a result,\n     * you should always write your schemes with lower case letters,\n     * and any schemes you receive from outside of Android should be\n     * converted to lower case before supplying them here.</em></p>\n     *\n     * @param scheme Name of the scheme to match, such as \"http\".\n     *\n     * @see #matchData\n     ",
    "links" : [ ]
  }, {
    "name" : "public final int countDataSchemes()",
    "returnType" : "int",
    "comment" : "\n     * Return the number of data schemes in the filter.\n     ",
    "links" : [ ]
  }, {
    "name" : "public final String getDataScheme(int index)",
    "returnType" : "String",
    "comment" : "\n     * Return a data scheme in the filter.\n     ",
    "links" : [ ]
  }, {
    "name" : "public final boolean hasDataScheme(String scheme)",
    "returnType" : "boolean",
    "comment" : "\n     * Is the given data scheme included in the filter?  Note that if the\n     * filter does not include any scheme, false will <em>always</em> be\n     * returned.\n     *\n     * @param scheme The data scheme to look for.\n     *\n     * @return True if the scheme is explicitly mentioned in the filter.\n     ",
    "links" : [ ]
  }, {
    "name" : "public final Iterator<String> schemesIterator()",
    "returnType" : "Iterator<String>",
    "comment" : "\n     * Return an iterator over the filter's data schemes.\n     ",
    "links" : [ ]
  }, {
    "name" : "public final void addDataSchemeSpecificPart(String ssp, int type)",
    "returnType" : "void",
    "comment" : "\n     * Add a new Intent data \"scheme specific part\" to match against.  The filter must\n     * include one or more schemes (via {@link #addDataScheme}) for the\n     * scheme specific part to be considered.  If any scheme specific parts are\n     * included in the filter, then an Intent's data must match one of\n     * them.  If no scheme specific parts are included, then only the scheme must match.\n     *\n     * <p>The \"scheme specific part\" that this matches against is the string returned\n     * by {@link android.net.Uri#getSchemeSpecificPart() Uri.getSchemeSpecificPart}.\n     * For Uris that contain a path, this kind of matching is not generally of interest,\n     * since {@link #addDataAuthority(String, String)} and\n     * {@link #addDataPath(String, int)} can provide a better mechanism for matching\n     * them.  However, for Uris that do not contain a path, the authority and path\n     * are empty, so this is the only way to match against the non-scheme part.</p>\n     *\n     * @param ssp Either a raw string that must exactly match the scheme specific part\n     * path, or a simple pattern, depending on <var>type</var>.\n     * @param type Determines how <var>ssp</var> will be compared to\n     * determine a match: either {@link PatternMatcher#PATTERN_LITERAL},\n     * {@link PatternMatcher#PATTERN_PREFIX}, or\n     * {@link PatternMatcher#PATTERN_SIMPLE_GLOB}.\n     *\n     * @see #matchData\n     * @see #addDataScheme\n     ",
    "links" : [ "#addDataScheme", "android.net.Uri#getSchemeSpecificPart", "#addDataAuthority", "#addDataPath", "PatternMatcher#PATTERN_LITERAL", "PatternMatcher#PATTERN_PREFIX", "PatternMatcher#PATTERN_SIMPLE_GLOB" ]
  }, {
    "name" : "public final void addDataSchemeSpecificPart(PatternMatcher ssp)",
    "returnType" : "void",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "public final int countDataSchemeSpecificParts()",
    "returnType" : "int",
    "comment" : "\n     * Return the number of data scheme specific parts in the filter.\n     ",
    "links" : [ ]
  }, {
    "name" : "public final PatternMatcher getDataSchemeSpecificPart(int index)",
    "returnType" : "PatternMatcher",
    "comment" : "\n     * Return a data scheme specific part in the filter.\n     ",
    "links" : [ ]
  }, {
    "name" : "public final boolean hasDataSchemeSpecificPart(String data)",
    "returnType" : "boolean",
    "comment" : "\n     * Is the given data scheme specific part included in the filter?  Note that if the\n     * filter does not include any scheme specific parts, false will <em>always</em> be\n     * returned.\n     *\n     * @param data The scheme specific part that is being looked for.\n     *\n     * @return Returns true if the data string matches a scheme specific part listed in the\n     *         filter.\n     ",
    "links" : [ ]
  }, {
    "name" : "private boolean hasDataSchemeSpecificPart(String data, boolean supportWildcards)",
    "returnType" : "boolean",
    "comment" : "\n     * Variant of {@link #hasDataSchemeSpecificPart(String)} that supports wildcards on the provided\n     * ssp.\n     * @param supportWildcards if true, will allow parameters to use wildcards\n     ",
    "links" : [ "#hasDataSchemeSpecificPart" ]
  }, {
    "name" : "public final boolean hasDataSchemeSpecificPart(PatternMatcher ssp)",
    "returnType" : "boolean",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "public final Iterator<PatternMatcher> schemeSpecificPartsIterator()",
    "returnType" : "Iterator<PatternMatcher>",
    "comment" : "\n     * Return an iterator over the filter's data scheme specific parts.\n     ",
    "links" : [ ]
  }, {
    "name" : "public final void addDataAuthority(String host, String port)",
    "returnType" : "void",
    "comment" : "\n     * Add a new Intent data authority to match against.  The filter must\n     * include one or more schemes (via {@link #addDataScheme}) for the\n     * authority to be considered.  If any authorities are\n     * included in the filter, then an Intent's data must match one of\n     * them.  If no authorities are included, then only the scheme must match.\n     *\n     * <p><em>Note: host name in the Android framework is\n     * case-sensitive, unlike formal RFC host names.  As a result,\n     * you should always write your host names with lower case letters,\n     * and any host names you receive from outside of Android should be\n     * converted to lower case before supplying them here.</em></p>\n     *\n     * @param host The host part of the authority to match.  May start with a\n     *             single '*' to wildcard the front of the host name.\n     * @param port Optional port part of the authority to match.  If null, any\n     *             port is allowed.\n     *\n     * @see #matchData\n     * @see #addDataScheme\n     ",
    "links" : [ "#addDataScheme" ]
  }, {
    "name" : "public final void addDataAuthority(AuthorityEntry ent)",
    "returnType" : "void",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "public final int countDataAuthorities()",
    "returnType" : "int",
    "comment" : "\n     * Return the number of data authorities in the filter.\n     ",
    "links" : [ ]
  }, {
    "name" : "public final AuthorityEntry getDataAuthority(int index)",
    "returnType" : "AuthorityEntry",
    "comment" : "\n     * Return a data authority in the filter.\n     ",
    "links" : [ ]
  }, {
    "name" : "public final boolean hasDataAuthority(Uri data)",
    "returnType" : "boolean",
    "comment" : "\n     * Is the given data authority included in the filter?  Note that if the\n     * filter does not include any authorities, false will <em>always</em> be\n     * returned.\n     *\n     * @param data The data whose authority is being looked for.\n     *\n     * @return Returns true if the data string matches an authority listed in the\n     *         filter.\n     ",
    "links" : [ ]
  }, {
    "name" : "public final boolean hasDataAuthority(AuthorityEntry auth)",
    "returnType" : "boolean",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "public final Iterator<AuthorityEntry> authoritiesIterator()",
    "returnType" : "Iterator<AuthorityEntry>",
    "comment" : "\n     * Return an iterator over the filter's data authorities.\n     ",
    "links" : [ ]
  }, {
    "name" : "public final void addDataPath(String path, int type)",
    "returnType" : "void",
    "comment" : "\n     * Add a new Intent data path to match against.  The filter must\n     * include one or more schemes (via {@link #addDataScheme}) <em>and</em>\n     * one or more authorities (via {@link #addDataAuthority}) for the\n     * path to be considered.  If any paths are\n     * included in the filter, then an Intent's data must match one of\n     * them.  If no paths are included, then only the scheme/authority must\n     * match.\n     *\n     * <p>The path given here can either be a literal that must directly\n     * match or match against a prefix, or it can be a simple globbing pattern.\n     * If the latter, you can use '*' anywhere in the pattern to match zero\n     * or more instances of the previous character, '.' as a wildcard to match\n     * any character, and '\\' to escape the next character.\n     *\n     * @param path Either a raw string that must exactly match the file\n     * path, or a simple pattern, depending on <var>type</var>.\n     * @param type Determines how <var>path</var> will be compared to\n     * determine a match: either {@link PatternMatcher#PATTERN_LITERAL},\n     * {@link PatternMatcher#PATTERN_PREFIX}, or\n     * {@link PatternMatcher#PATTERN_SIMPLE_GLOB}.\n     *\n     * @see #matchData\n     * @see #addDataScheme\n     * @see #addDataAuthority\n     ",
    "links" : [ "#addDataScheme", "#addDataAuthority", "PatternMatcher#PATTERN_LITERAL", "PatternMatcher#PATTERN_PREFIX", "PatternMatcher#PATTERN_SIMPLE_GLOB" ]
  }, {
    "name" : "public final void addDataPath(PatternMatcher path)",
    "returnType" : "void",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "public final int countDataPaths()",
    "returnType" : "int",
    "comment" : "\n     * Return the number of data paths in the filter.\n     ",
    "links" : [ ]
  }, {
    "name" : "public final PatternMatcher getDataPath(int index)",
    "returnType" : "PatternMatcher",
    "comment" : "\n     * Return a data path in the filter.\n     ",
    "links" : [ ]
  }, {
    "name" : "public final boolean hasDataPath(String data)",
    "returnType" : "boolean",
    "comment" : "\n     * Is the given data path included in the filter?  Note that if the\n     * filter does not include any paths, false will <em>always</em> be\n     * returned.\n     *\n     * @param data The data path to look for.  This is without the scheme\n     *             prefix.\n     *\n     * @return True if the data string matches a path listed in the\n     *         filter.\n     ",
    "links" : [ ]
  }, {
    "name" : "private boolean hasDataPath(String data, boolean wildcardSupported)",
    "returnType" : "boolean",
    "comment" : "\n     * Variant of {@link #hasDataPath(String)} that supports wildcards on the provided scheme, host,\n     * and path.\n     * @param wildcardSupported if true, will allow parameters to use wildcards\n     ",
    "links" : [ "#hasDataPath" ]
  }, {
    "name" : "public final boolean hasDataPath(PatternMatcher path)",
    "returnType" : "boolean",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "public final Iterator<PatternMatcher> pathsIterator()",
    "returnType" : "Iterator<PatternMatcher>",
    "comment" : "\n     * Return an iterator over the filter's data paths.\n     ",
    "links" : [ ]
  }, {
    "name" : "public final int matchDataAuthority(Uri data)",
    "returnType" : "int",
    "comment" : "\n     * Match this intent filter against the given Intent data.  This ignores\n     * the data scheme -- unlike {@link #matchData}, the authority will match\n     * regardless of whether there is a matching scheme.\n     *\n     * @param data The data whose authority is being looked for.\n     *\n     * @return Returns either {@link #MATCH_CATEGORY_HOST},\n     * {@link #MATCH_CATEGORY_PORT}, {@link #NO_MATCH_DATA}.\n     ",
    "links" : [ "#matchData", "#MATCH_CATEGORY_HOST", "#MATCH_CATEGORY_PORT", "#NO_MATCH_DATA" ]
  }, {
    "name" : "public final int matchDataAuthority(Uri data, boolean wildcardSupported)",
    "returnType" : "int",
    "comment" : "\n     * Variant of {@link #matchDataAuthority(Uri)} that allows wildcard matching of the provided\n     * authority.\n     *\n     * @param wildcardSupported if true, will allow parameters to use wildcards\n     * @hide\n     ",
    "links" : [ "#matchDataAuthority" ]
  }, {
    "name" : "public final int matchData(String type, String scheme, Uri data)",
    "returnType" : "int",
    "comment" : "\n     * Match this filter against an Intent's data (type, scheme and path). If\n     * the filter does not specify any types and does not specify any\n     * schemes/paths, the match will only succeed if the intent does not\n     * also specify a type or data.  If the filter does not specify any schemes,\n     * it will implicitly match intents with no scheme, or the schemes \"content:\"\n     * or \"file:\" (basically performing a MIME-type only match).  If the filter\n     * does not specify any MIME types, the Intent also must not specify a MIME\n     * type.\n     *\n     * <p>Be aware that to match against an authority, you must also specify a base\n     * scheme the authority is in.  To match against a data path, both a scheme\n     * and authority must be specified.  If the filter does not specify any\n     * types or schemes that it matches against, it is considered to be empty\n     * (any authority or data path given is ignored, as if it were empty as\n     * well).\n     *\n     * <p><em>Note: MIME type, Uri scheme, and host name matching in the\n     * Android framework is case-sensitive, unlike the formal RFC definitions.\n     * As a result, you should always write these elements with lower case letters,\n     * and normalize any MIME types or Uris you receive from\n     * outside of Android to ensure these elements are lower case before\n     * supplying them here.</em></p>\n     *\n     * @param type The desired data type to look for, as returned by\n     *             Intent.resolveType().\n     * @param scheme The desired data scheme to look for, as returned by\n     *               Intent.getScheme().\n     * @param data The full data string to match against, as supplied in\n     *             Intent.data.\n     *\n     * @return Returns either a valid match constant (a combination of\n     * {@link #MATCH_CATEGORY_MASK} and {@link #MATCH_ADJUSTMENT_MASK}),\n     * or one of the error codes {@link #NO_MATCH_TYPE} if the type didn't match\n     * or {@link #NO_MATCH_DATA} if the scheme/path didn't match.\n     *\n     * @see #match\n     ",
    "links" : [ "#MATCH_CATEGORY_MASK", "#MATCH_ADJUSTMENT_MASK", "#NO_MATCH_TYPE", "#NO_MATCH_DATA" ]
  }, {
    "name" : "private int matchData(String type, String scheme, Uri data, boolean wildcardSupported)",
    "returnType" : "int",
    "comment" : "\n     * Variant of {@link #matchData(String, String, Uri)} that allows wildcard matching\n     * of the provided type, scheme, host and path parameters.\n     * @param wildcardSupported if true, will allow parameters to use wildcards\n     ",
    "links" : [ "#matchData" ]
  }, {
    "name" : "public final void addCategory(String category)",
    "returnType" : "void",
    "comment" : "\n     * Add a new Intent category to match against.  The semantics of\n     * categories is the opposite of actions -- an Intent includes the\n     * categories that it requires, all of which must be included in the\n     * filter in order to match.  In other words, adding a category to the\n     * filter has no impact on matching unless that category is specified in\n     * the intent.\n     *\n     * @param category Name of category to match, such as Intent.CATEGORY_EMBED.\n     ",
    "links" : [ ]
  }, {
    "name" : "public final int countCategories()",
    "returnType" : "int",
    "comment" : "\n     * Return the number of categories in the filter.\n     ",
    "links" : [ ]
  }, {
    "name" : "public final String getCategory(int index)",
    "returnType" : "String",
    "comment" : "\n     * Return a category in the filter.\n     ",
    "links" : [ ]
  }, {
    "name" : "public final boolean hasCategory(String category)",
    "returnType" : "boolean",
    "comment" : "\n     * Is the given category included in the filter?\n     *\n     * @param category The category that the filter supports.\n     *\n     * @return True if the category is explicitly mentioned in the filter.\n     ",
    "links" : [ ]
  }, {
    "name" : "public final Iterator<String> categoriesIterator()",
    "returnType" : "Iterator<String>",
    "comment" : "\n     * Return an iterator over the filter's categories.\n     *\n     * @return Iterator if this filter has categories or {@code null} if none.\n     ",
    "links" : [ ]
  }, {
    "name" : "public final String matchCategories(Set<String> categories)",
    "returnType" : "String",
    "comment" : "\n     * Match this filter against an Intent's categories.  Each category in\n     * the Intent must be specified by the filter; if any are not in the\n     * filter, the match fails.\n     *\n     * @param categories The categories included in the intent, as returned by\n     *                   Intent.getCategories().\n     *\n     * @return If all categories match (success), null; else the name of the\n     *         first category that didn't match.\n     ",
    "links" : [ ]
  }, {
    "name" : "public final int match(ContentResolver resolver, Intent intent, boolean resolve, String logTag)",
    "returnType" : "int",
    "comment" : "\n     * Test whether this filter matches the given <var>intent</var>.\n     *\n     * @param intent The Intent to compare against.\n     * @param resolve If true, the intent's type will be resolved by calling\n     *                Intent.resolveType(); otherwise a simple match against\n     *                Intent.type will be performed.\n     * @param logTag Tag to use in debugging messages.\n     *\n     * @return Returns either a valid match constant (a combination of\n     * {@link #MATCH_CATEGORY_MASK} and {@link #MATCH_ADJUSTMENT_MASK}),\n     * or one of the error codes {@link #NO_MATCH_TYPE} if the type didn't match,\n     * {@link #NO_MATCH_DATA} if the scheme/path didn't match,\n     * {@link #NO_MATCH_ACTION} if the action didn't match, or\n     * {@link #NO_MATCH_CATEGORY} if one or more categories didn't match.\n     *\n     * @see #match(String, String, String, android.net.Uri , Set, String)\n     ",
    "links" : [ "#MATCH_CATEGORY_MASK", "#MATCH_ADJUSTMENT_MASK", "#NO_MATCH_TYPE", "#NO_MATCH_DATA", "#NO_MATCH_ACTION", "#NO_MATCH_CATEGORY" ]
  }, {
    "name" : "public final int match(String action, String type, String scheme, Uri data, Set<String> categories, String logTag)",
    "returnType" : "int",
    "comment" : "\n     * Test whether this filter matches the given intent data.  A match is\n     * only successful if the actions and categories in the Intent match\n     * against the filter, as described in {@link IntentFilter}; in that case,\n     * the match result returned will be as per {@link #matchData}.\n     *\n     * @param action The intent action to match against (Intent.getAction).\n     * @param type The intent type to match against (Intent.resolveType()).\n     * @param scheme The data scheme to match against (Intent.getScheme()).\n     * @param data The data URI to match against (Intent.getData()).\n     * @param categories The categories to match against\n     *                   (Intent.getCategories()).\n     * @param logTag Tag to use in debugging messages.\n     *\n     * @return Returns either a valid match constant (a combination of\n     * {@link #MATCH_CATEGORY_MASK} and {@link #MATCH_ADJUSTMENT_MASK}),\n     * or one of the error codes {@link #NO_MATCH_TYPE} if the type didn't match,\n     * {@link #NO_MATCH_DATA} if the scheme/path didn't match,\n     * {@link #NO_MATCH_ACTION} if the action didn't match, or\n     * {@link #NO_MATCH_CATEGORY} if one or more categories didn't match.\n     *\n     * @see #matchData\n     * @see Intent#getAction\n     * @see Intent#resolveType\n     * @see Intent#getScheme\n     * @see Intent#getData\n     * @see Intent#getCategories\n     ",
    "links" : [ "IntentFilter", "#matchData", "#MATCH_CATEGORY_MASK", "#MATCH_ADJUSTMENT_MASK", "#NO_MATCH_TYPE", "#NO_MATCH_DATA", "#NO_MATCH_ACTION", "#NO_MATCH_CATEGORY" ]
  }, {
    "name" : "public final int match(String action, String type, String scheme, Uri data, Set<String> categories, String logTag, boolean supportWildcards, @Nullable Collection<String> ignoreActions)",
    "returnType" : "int",
    "comment" : "\n     * Variant of {@link #match(ContentResolver, Intent, boolean, String)} that supports wildcards\n     * in the action, type, scheme, host and path.\n     * @param supportWildcards if true, will allow supported parameters to use wildcards to match\n     *                         this filter\n     * @param ignoreActions a collection of actions that, if not null should be ignored and not used\n     *                      if provided as the matching action or the set of actions defined by this\n     *                      filter\n     * @hide\n     ",
    "links" : [ "#match" ]
  }, {
    "name" : "public void writeToXml(XmlSerializer serializer) throws IOException",
    "returnType" : "void",
    "comment" : "\n     * Write the contents of the IntentFilter as an XML stream.\n     ",
    "links" : [ ]
  }, {
    "name" : "private void writeDataTypesToXml(XmlSerializer serializer) throws IOException",
    "returnType" : "void",
    "comment" : "\n     * Write data types (both static and dynamic) to XML.\n     * In implementation we rely on two facts:\n     * - {@link #mStaticDataTypes} is subsequence of {@link #mDataTypes}\n     * - both {@link #mStaticDataTypes} and {@link #mDataTypes} does not contain duplicates\n     ",
    "links" : [ "#mStaticDataTypes", "#mDataTypes", "#mStaticDataTypes", "#mDataTypes" ]
  }, {
    "name" : "private void writeDataTypeToXml(XmlSerializer serializer, String type, String tag) throws IOException",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public void readFromXml(XmlPullParser parser) throws XmlPullParserException, IOException",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public void dumpDebug(ProtoOutputStream proto, long fieldId)",
    "returnType" : "void",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "public void dump(Printer du, String prefix)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public final int describeContents()",
    "returnType" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public final void writeToParcel(Parcel dest, int flags)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public boolean debugCheck()",
    "returnType" : "boolean",
    "comment" : "\n     * For debugging -- perform a check on the filter, return true if it passed\n     * or false if it failed.\n     *\n     * {@hide}\n     ",
    "links" : [ ]
  }, {
    "name" : "private boolean hasPartialTypes()",
    "returnType" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private final boolean findMimeType(String type)",
    "returnType" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public ArrayList<String> getHostsList()",
    "returnType" : "ArrayList<String>",
    "comment" : "\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public String[] getHosts()",
    "returnType" : "String[]",
    "comment" : "\n     * @hide\n     ",
    "links" : [ ]
  } ],
  "variableNames" : [ "AGLOB_STR", "SGLOB_STR", "PREFIX_STR", "LITERAL_STR", "PATH_STR", "PORT_STR", "HOST_STR", "AUTH_STR", "SSP_STR", "SCHEME_STR", "STATIC_TYPE_STR", "TYPE_STR", "GROUP_STR", "CAT_STR", "NAME_STR", "ACTION_STR", "AUTO_VERIFY_STR", "SYSTEM_HIGH_PRIORITY", "SYSTEM_LOW_PRIORITY", "MATCH_CATEGORY_MASK", "MATCH_ADJUSTMENT_MASK", "MATCH_ADJUSTMENT_NORMAL", "MATCH_CATEGORY_EMPTY", "MATCH_CATEGORY_SCHEME", "MATCH_CATEGORY_HOST", "MATCH_CATEGORY_PORT", "MATCH_CATEGORY_PATH", "MATCH_CATEGORY_SCHEME_SPECIFIC_PART", "MATCH_CATEGORY_TYPE", "NO_MATCH_TYPE", "NO_MATCH_DATA", "NO_MATCH_ACTION", "NO_MATCH_CATEGORY", "SCHEME_HTTP", "SCHEME_HTTPS", "WILDCARD", "WILDCARD_PATH", "mPriority", "mOrder", "mActions", "mCategories", "mDataSchemes", "mDataSchemeSpecificParts", "mDataAuthorities", "mDataPaths", "mStaticDataTypes", "mDataTypes", "mMimeGroups", "mHasStaticPartialTypes", "mHasDynamicPartialTypes", "STATE_VERIFY_AUTO", "STATE_NEED_VERIFY", "STATE_NEED_VERIFY_CHECKED", "STATE_VERIFIED", "mVerifyState", "VISIBILITY_NONE", "VISIBILITY_EXPLICIT", "VISIBILITY_IMPLICIT", "mInstantAppVisibility", "CREATOR" ],
  "methodNames" : [ "private static int findStringInSet(String[] set, String string, int[] lengths, int lenPos)", "private static String[] addStringToSet(String[] set, String string, int[] lengths, int lenPos)", "private static String[] removeStringFromSet(String[] set, String string, int[] lengths, int lenPos)", "public static IntentFilter create(String action, String dataType)", "public final void setPriority(int priority)", "public final int getPriority()", "public final void setOrder(int order)", "public final int getOrder()", "public final void setAutoVerify(boolean autoVerify)", "public final boolean getAutoVerify()", "public final boolean handleAllWebDataURI()", "public final boolean handlesWebUris(boolean onlyWebSchemes)", "public final boolean needsVerification()", "public final boolean isVerified()", "public void setVerified(boolean verified)", "public void setVisibilityToInstantApp(@InstantAppVisibility int visibility)", "public int getVisibilityToInstantApp()", "public boolean isVisibleToInstantApp()", "public boolean isExplicitlyVisibleToInstantApp()", "public boolean isImplicitlyVisibleToInstantApp()", "public final void addAction(String action)", "public final int countActions()", "public final String getAction(int index)", "public final boolean hasAction(String action)", "public final boolean matchAction(String action)", "private boolean matchAction(String action, boolean wildcardSupported, @Nullable Collection<String> ignoreActions)", "public final Iterator<String> actionsIterator()", "public final void addDataType(String type) throws MalformedMimeTypeException", "public final void addDynamicDataType(String type) throws MalformedMimeTypeException", "private void processMimeType(String type, BiConsumer<String, Boolean> action) throws MalformedMimeTypeException", "public final void clearDynamicDataTypes()", "public int countStaticDataTypes()", "public final boolean hasDataType(String type)", "public final boolean hasExactDataType(String type)", "public final boolean hasExactDynamicDataType(String type)", "public final boolean hasExactStaticDataType(String type)", "public final int countDataTypes()", "public final String getDataType(int index)", "public final Iterator<String> typesIterator()", "public final List<String> dataTypes()", "public final void addMimeGroup(String name)", "public final boolean hasMimeGroup(String name)", "public final String getMimeGroup(int index)", "public final int countMimeGroups()", "public final Iterator<String> mimeGroupsIterator()", "public final void addDataScheme(String scheme)", "public final int countDataSchemes()", "public final String getDataScheme(int index)", "public final boolean hasDataScheme(String scheme)", "public final Iterator<String> schemesIterator()", "public final void addDataSchemeSpecificPart(String ssp, int type)", "public final void addDataSchemeSpecificPart(PatternMatcher ssp)", "public final int countDataSchemeSpecificParts()", "public final PatternMatcher getDataSchemeSpecificPart(int index)", "public final boolean hasDataSchemeSpecificPart(String data)", "private boolean hasDataSchemeSpecificPart(String data, boolean supportWildcards)", "public final boolean hasDataSchemeSpecificPart(PatternMatcher ssp)", "public final Iterator<PatternMatcher> schemeSpecificPartsIterator()", "public final void addDataAuthority(String host, String port)", "public final void addDataAuthority(AuthorityEntry ent)", "public final int countDataAuthorities()", "public final AuthorityEntry getDataAuthority(int index)", "public final boolean hasDataAuthority(Uri data)", "public final boolean hasDataAuthority(AuthorityEntry auth)", "public final Iterator<AuthorityEntry> authoritiesIterator()", "public final void addDataPath(String path, int type)", "public final void addDataPath(PatternMatcher path)", "public final int countDataPaths()", "public final PatternMatcher getDataPath(int index)", "public final boolean hasDataPath(String data)", "private boolean hasDataPath(String data, boolean wildcardSupported)", "public final boolean hasDataPath(PatternMatcher path)", "public final Iterator<PatternMatcher> pathsIterator()", "public final int matchDataAuthority(Uri data)", "public final int matchDataAuthority(Uri data, boolean wildcardSupported)", "public final int matchData(String type, String scheme, Uri data)", "private int matchData(String type, String scheme, Uri data, boolean wildcardSupported)", "public final void addCategory(String category)", "public final int countCategories()", "public final String getCategory(int index)", "public final boolean hasCategory(String category)", "public final Iterator<String> categoriesIterator()", "public final String matchCategories(Set<String> categories)", "public final int match(ContentResolver resolver, Intent intent, boolean resolve, String logTag)", "public final int match(String action, String type, String scheme, Uri data, Set<String> categories, String logTag)", "public final int match(String action, String type, String scheme, Uri data, Set<String> categories, String logTag, boolean supportWildcards, @Nullable Collection<String> ignoreActions)", "public void writeToXml(XmlSerializer serializer) throws IOException", "private void writeDataTypesToXml(XmlSerializer serializer) throws IOException", "private void writeDataTypeToXml(XmlSerializer serializer, String type, String tag) throws IOException", "public void readFromXml(XmlPullParser parser) throws XmlPullParserException, IOException", "public void dumpDebug(ProtoOutputStream proto, long fieldId)", "public void dump(Printer du, String prefix)", "public final int describeContents()", "public final void writeToParcel(Parcel dest, int flags)", "public boolean debugCheck()", "private boolean hasPartialTypes()", "private final boolean findMimeType(String type)", "public ArrayList<String> getHostsList()", "public String[] getHosts()" ]
}