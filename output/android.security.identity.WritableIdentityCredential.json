{
  "filePath" : "/home/maryam/clearblue/files/android-source-35/android/security/identity/WritableIdentityCredential.java",
  "packageName" : "android.security.identity",
  "className" : "WritableIdentityCredential",
  "comment" : "\n * Class used to personalize a new identity credential.\n *\n * <p>Credentials cannot be updated or modified after creation; any changes require deletion and\n * re-creation.\n *\n * Use {@link IdentityCredentialStore#createCredential(String, String)} to create a new credential.\n ",
  "links" : [ "android.security.identity.IdentityCredentialStore#createCredential(String" ],
  "variables" : [ ],
  "methods" : [ {
    "name" : "public abstract Collection<X509Certificate> getCredentialKeyCertificateChain(@NonNull byte[] challenge)",
    "returnType" : "Collection<X509Certificate>",
    "comment" : "\n     * Generates and returns an X.509 certificate chain for the CredentialKey which identifies this\n     * credential to the issuing authority. The certificate contains an\n     * <a href=\"https://source.android.com/security/keystore/attestation\">Android Keystore</a>\n     * attestation extension which describes the key and the security hardware in which it lives.\n     *\n     * <p>Additionally, the attestation extension will contain the tag Tag::IDENTITY_CREDENTIAL_KEY\n     * which indicates it is an Identity Credential key (which can only sign/MAC very specific\n     * messages) and not an Android Keystore key (which can be used to sign/MAC anything).\n     *\n     * <p>The issuer <b>MUST</b> carefully examine this certificate chain including (but not\n     * limited to) checking that the root certificate is well-known, the tag\n     * Tag::IDENTITY_CREDENTIAL_KEY present, the passed in challenge is present, the tag\n     * Tag::ATTESTATION_APPLICATION_ID is set to the expected Android application, the device\n     * has verified boot enabled, each certificate in the chain is signed by its successor,\n     * none of the certificates have been revoked, and so on.\n     *\n     * <p>It is not strictly necessary to use this method to provision a credential if the issuing\n     * authority doesn't care about the nature of the security hardware. If called, however, this\n     * method must be called before {@link #personalize(PersonalizationData)}.\n     *\n     * @param challenge is a non-empty byte array whose contents should be unique, fresh and\n     *                  provided by the issuing authority. The value provided is embedded in the\n     *                  attestation extension and enables the issuing authority to verify that the\n     *                  attestation certificate is fresh. Implementations are required to support\n     *                  challenges at least 32 bytes of length.\n     * @return the X.509 certificate for this credential's CredentialKey.\n     ",
    "links" : [ "#personalize(PersonalizationData)" ]
  }, {
    "name" : "public abstract byte[] personalize(@NonNull PersonalizationData personalizationData)",
    "returnType" : "byte[]",
    "comment" : "\n     * Stores all of the data in the credential, with the specified access control profiles.\n     *\n     * <p>This method returns a COSE_Sign1 data structure signed by the CredentialKey with payload\n     * set to {@code ProofOfProvisioning} as defined below.\n     *\n     * <pre>\n     *     ProofOfProvisioning = [\n     *          \"ProofOfProvisioning\",        ; tstr\n     *          tstr,                         ; DocType\n     *          [ * AccessControlProfile ],\n     *          ProvisionedData,\n     *          bool                          ; true if this is a test credential, should\n     *                                        ; always be false.\n     *      ]\n     *\n     *      AccessControlProfile = {\n     *          \"id\": uint,\n     *          ? \"readerCertificate\" : bstr,\n     *          ? (\n     *               \"userAuthenticationRequired\" : bool,\n     *               \"timeoutMillis\" : uint,\n     *          )\n     *      }\n     *\n     *      ProvisionedData = {\n     *          * Namespace =&gt; [ + Entry ]\n     *      },\n     *\n     *      Namespace = tstr\n     *\n     *      Entry = {\n     *          \"name\" : tstr,\n     *          \"value\" : any,\n     *          \"accessControlProfiles\" : [ * uint ],\n     *      }\n     * </pre>\n     *\n     * <p>This data structure provides a guarantee to the issuer about the data which may be\n     * returned in the CBOR returned by\n     * {@link ResultData#getAuthenticatedData()} during a credential\n     * presentation.\n     *\n     * @param personalizationData   The data to provision, including access control profiles\n     *                              and data elements and their values, grouped into namespaces.\n     * @return A COSE_Sign1 data structure, see above.\n     ",
    "links" : [ "android.security.identity.ResultData#getAuthenticatedData()" ]
  } ],
  "methodNames" : [ "public abstract Collection<X509Certificate> getCredentialKeyCertificateChain(@NonNull byte[] challenge)", "public abstract byte[] personalize(@NonNull PersonalizationData personalizationData)" ],
  "variableNames" : [ ]
}