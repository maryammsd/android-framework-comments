{
  "filePath" : "/home/maryam/clearblue/files/android-source-35/android/net/wifi/WifiEnterpriseConfig.java",
  "packageName" : "android.net.wifi",
  "className" : "WifiEnterpriseConfig",
  "comment" : "\n * Enterprise configuration details for Wi-Fi. Stores details about the EAP method\n * and any associated credentials.\n ",
  "links" : [ ],
  "variables" : [ {
    "name" : "WAPI_AS_CERTIFICATE",
    "type" : "String",
    "comment" : " Key prefix for WAPI AS certificates. ",
    "links" : [ ]
  }, {
    "name" : "WAPI_USER_CERTIFICATE",
    "type" : "String",
    "comment" : " Key prefix for WAPI user certificates. ",
    "links" : [ ]
  }, {
    "name" : "EXTRA_WAPI_AS_CERTIFICATE_NAME",
    "type" : "String",
    "comment" : "\n     * Intent extra: name for WAPI AS certificates\n     ",
    "links" : [ ]
  }, {
    "name" : "EXTRA_WAPI_AS_CERTIFICATE_DATA",
    "type" : "String",
    "comment" : "\n     * Intent extra: data for WAPI AS certificates\n     ",
    "links" : [ ]
  }, {
    "name" : "EXTRA_WAPI_USER_CERTIFICATE_NAME",
    "type" : "String",
    "comment" : "\n     * Intent extra: name for WAPI USER certificates\n     ",
    "links" : [ ]
  }, {
    "name" : "EXTRA_WAPI_USER_CERTIFICATE_DATA",
    "type" : "String",
    "comment" : "\n     * Intent extra: data for WAPI USER certificates\n     ",
    "links" : [ ]
  }, {
    "name" : "EMPTY_VALUE",
    "type" : "String",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "EAP_KEY",
    "type" : "String",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "PHASE2_KEY",
    "type" : "String",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "IDENTITY_KEY",
    "type" : "String",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "ANON_IDENTITY_KEY",
    "type" : "String",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "PASSWORD_KEY",
    "type" : "String",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "SUBJECT_MATCH_KEY",
    "type" : "String",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "ALTSUBJECT_MATCH_KEY",
    "type" : "String",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "DOM_SUFFIX_MATCH_KEY",
    "type" : "String",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "OPP_KEY_CACHING",
    "type" : "String",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "EAP_ERP",
    "type" : "String",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "OCSP",
    "type" : "String",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "DECORATED_IDENTITY_PREFIX_KEY",
    "type" : "String",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "ENGINE_ID_KEYSTORE",
    "type" : "String",
    "comment" : "\n     * String representing the keystore OpenSSL ENGINE's ID.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "KEYSTORE_URI",
    "type" : "String",
    "comment" : "\n     * String representing the keystore URI used for wpa_supplicant.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "KEYSTORES_URI",
    "type" : "String",
    "comment" : "\n     * String representing the keystore URI used for wpa_supplicant,\n     * Unlike #KEYSTORE_URI, this supports a list of space-delimited aliases\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "CERT_HASH_PREFIX",
    "type" : "String",
    "comment" : "\n     * String representing a SHA-256 certificate hash used for wpa_supplicant.\n     ",
    "links" : [ ]
  }, {
    "name" : "ENGINE_ENABLE",
    "type" : "String",
    "comment" : "\n     * String to set the engine value to when it should be enabled.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "ENGINE_DISABLE",
    "type" : "String",
    "comment" : "\n     * String to set the engine value to when it should be disabled.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "CA_CERTIFICATE",
    "type" : "String",
    "comment" : "\n     * Key prefix for CA certificates.\n     * Note: copied from {@link android.security.Credentials#CA_CERTIFICATE} since it is @hide.\n     ",
    "links" : [ "android.security.Credentials#CA_CERTIFICATE" ]
  }, {
    "name" : "USER_CERTIFICATE",
    "type" : "String",
    "comment" : "\n     * Key prefix for user certificates.\n     * Note: copied from {@link android.security.Credentials#USER_CERTIFICATE} since it is @hide.\n     ",
    "links" : [ "android.security.Credentials#USER_CERTIFICATE" ]
  }, {
    "name" : "USER_PRIVATE_KEY",
    "type" : "String",
    "comment" : "\n     * Key prefix for user private and secret keys.\n     * Note: copied from {@link android.security.Credentials#USER_PRIVATE_KEY} since it is @hide.\n     ",
    "links" : [ "android.security.Credentials#USER_PRIVATE_KEY" ]
  }, {
    "name" : "CA_CERT_PREFIX",
    "type" : "String",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "CLIENT_CERT_PREFIX",
    "type" : "String",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "CLIENT_CERT_KEY",
    "type" : "String",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "CA_CERT_KEY",
    "type" : "String",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "CA_PATH_KEY",
    "type" : "String",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "ENGINE_KEY",
    "type" : "String",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "ENGINE_ID_KEY",
    "type" : "String",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "PRIVATE_KEY_ID_KEY",
    "type" : "String",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "REALM_KEY",
    "type" : "String",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "PLMN_KEY",
    "type" : "String",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "CA_CERT_ALIAS_DELIMITER",
    "type" : "String",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "WAPI_CERT_SUITE_KEY",
    "type" : "String",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "OCSP_NONE",
    "type" : "int",
    "comment" : "\n     * Do not use OCSP stapling (TLS certificate status extension)\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "OCSP_REQUEST_CERT_STATUS",
    "type" : "int",
    "comment" : "\n     * Try to use OCSP stapling, but not require response\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "OCSP_REQUIRE_CERT_STATUS",
    "type" : "int",
    "comment" : "\n     * Require valid OCSP stapling response\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "OCSP_REQUIRE_ALL_NON_TRUSTED_CERTS_STATUS",
    "type" : "int",
    "comment" : "\n     * Require valid OCSP stapling response for all not-trusted certificates in the server\n     * certificate chain.\n     * @apiNote This option is not supported by most SSL libraries and should not be used.\n     * Specifying this option will most likely cause connection failures.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "mOcsp",
    "type" : "int",
    "comment" : "\n     * Whether to use/require OCSP (Online Certificate Status Protocol) to check server certificate.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "SUPPLICANT_CONFIG_KEYS",
    "type" : "String[]",
    "comment" : " Fields to copy verbatim from wpa_supplicant.",
    "links" : [ ]
  }, {
    "name" : "CERTIFICATE_MAX_LENGTH",
    "type" : "int",
    "comment" : "\n     * Maximum length of a certificate.\n     ",
    "links" : [ ]
  }, {
    "name" : "KEYCHAIN_ALIAS_MAX_LENGTH",
    "type" : "int",
    "comment" : "\n     * Maximum length of the {@link #mKeyChainAlias} field.\n     ",
    "links" : [ "#mKeyChainAlias" ]
  }, {
    "name" : "CLIENT_CERTIFICATE_CHAIN_MAX_ELEMENTS",
    "type" : "int",
    "comment" : "\n     * Maximum number of elements in a client certificate chain.\n     ",
    "links" : [ ]
  }, {
    "name" : "CA_CERTIFICATES_MAX_ELEMENTS",
    "type" : "int",
    "comment" : "\n     * Maximum number of elements in a list of CA certificates.\n     ",
    "links" : [ ]
  }, {
    "name" : "SUPPORTED_FIELDS",
    "type" : "Map<String, Integer>",
    "comment" : "\n     * Fields that are supported in {@link #mFields}.\n     * Each entry includes the supported field's key and its maximum allowed length.\n     ",
    "links" : [ "#mFields" ]
  }, {
    "name" : "UNQUOTED_KEYS",
    "type" : "List<String>",
    "comment" : "\n     * Fields that have unquoted values in {@link #mFields}.\n     ",
    "links" : [ "#mFields" ]
  }, {
    "name" : "TLS_V1_0",
    "type" : "int",
    "comment" : " Constant definition for TLS v1.0 which is used in {@link #setMinimumTlsVersion(int)} ",
    "links" : [ "#setMinimumTlsVersion(int)" ]
  }, {
    "name" : "TLS_V1_1",
    "type" : "int",
    "comment" : " Constant definition for TLS v1.1 which is used in {@link #setMinimumTlsVersion(int)} ",
    "links" : [ "#setMinimumTlsVersion(int)" ]
  }, {
    "name" : "TLS_V1_2",
    "type" : "int",
    "comment" : " Constant definition for TLS v1.2 which is used in {@link #setMinimumTlsVersion(int)} ",
    "links" : [ "#setMinimumTlsVersion(int)" ]
  }, {
    "name" : "TLS_V1_3",
    "type" : "int",
    "comment" : " Constant definition for TLS v1.3 which is used in {@link #setMinimumTlsVersion(int)} ",
    "links" : [ "#setMinimumTlsVersion(int)" ]
  }, {
    "name" : "TLS_VERSION_MIN",
    "type" : "int",
    "comment" : "\n     * The minimum valid value for a TLS version.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "TLS_VERSION_MAX",
    "type" : "int",
    "comment" : "\n     * The maximum valid value for a TLS version.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "TOFU_STATE_NOT_ENABLED",
    "type" : "int",
    "comment" : "\n     * TOFU is not enabled for this configuration.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "TOFU_STATE_ENABLED_PRE_CONNECTION",
    "type" : "int",
    "comment" : "\n     * TOFU is enabled pre-connection.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "TOFU_STATE_CONFIGURE_ROOT_CA",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "TOFU_STATE_CERT_PINNING",
    "type" : "int",
    "comment" : "\n     * Certificate pinning was used post-TOFU connection.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "TOFU_DIALOG_STATE_UNSPECIFIED",
    "type" : "int",
    "comment" : "\n     * TOFU dialog has not been displayed to the user, or state is unknown.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "TOFU_DIALOG_STATE_REJECTED",
    "type" : "int",
    "comment" : "\n     * TOFU dialog was rejected by the user.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "TOFU_DIALOG_STATE_ACCEPTED",
    "type" : "int",
    "comment" : "\n     * TOFU dialog was accepted by the user.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "mFields",
    "type" : "HashMap<String, String>",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mCaCerts",
    "type" : "X509Certificate[]",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mClientPrivateKey",
    "type" : "PrivateKey",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mClientCertificateChain",
    "type" : "X509Certificate[]",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mEapMethod",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mPhase2Method",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mIsAppInstalledDeviceKeyAndCert",
    "type" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mIsAppInstalledCaCert",
    "type" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mKeyChainAlias",
    "type" : "String",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mIsTrustOnFirstUseEnabled",
    "type" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mUserApproveNoCaCert",
    "type" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mMinimumTlsVersion",
    "type" : "int",
    "comment" : " Default is 1.0, i.e. accept any TLS version.",
    "links" : [ ]
  }, {
    "name" : "mTofuDialogState",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mTofuConnectionState",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mSelectedRcoi",
    "type" : "long",
    "comment" : " subscription.",
    "links" : [ ]
  }, {
    "name" : "mIsStrictConservativePeerMode",
    "type" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "TAG",
    "type" : "String",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "CREATOR",
    "type" : "Creator<WifiEnterpriseConfig>",
    "comment" : "",
    "links" : [ ]
  } ],
  "methods" : [ {
    "name" : "private static boolean isKeySupported(String key)",
    "returnType" : "boolean",
    "comment" : "\n     * Check whether a key is supported by {@link #mFields}.\n     * @return true if the key is supported, false otherwise.\n     ",
    "links" : [ "#mFields" ]
  }, {
    "name" : "private static boolean isFieldLengthValid(String key, String value)",
    "returnType" : "boolean",
    "comment" : "\n     * Check whether a value from {@link #mFields} has a valid length.\n     * @return true if the length is valid, false otherwise.\n     ",
    "links" : [ "#mFields" ]
  }, {
    "name" : "private static boolean isFieldLengthValid(String value, int maxLength)",
    "returnType" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private static boolean isFieldValid(String key, String value)",
    "returnType" : "boolean",
    "comment" : "\n     * Check whether a key/value pair from {@link #mFields} is valid.\n     * @return true if the key/value pair is valid, false otherwise.\n     ",
    "links" : [ "#mFields" ]
  }, {
    "name" : "private Bundle fieldMapToBundle()",
    "returnType" : "Bundle",
    "comment" : "\n     * Convert the {@link #mFields} map to a Bundle for parceling.\n     * Unsupported keys will not be included in the Bundle.\n     ",
    "links" : [ "#mFields" ]
  }, {
    "name" : "private static HashMap<String, String> bundleToFieldMap(Bundle bundle)",
    "returnType" : "HashMap<String, String>",
    "comment" : "\n     * Convert an unparceled Bundle to the {@link #mFields} map.\n     * Unsupported keys will not be included in the map.\n     ",
    "links" : [ "#mFields" ]
  }, {
    "name" : "private void copyFrom(WifiEnterpriseConfig source, boolean ignoreMaskedPassword, String mask)",
    "returnType" : "void",
    "comment" : "\n     * Copy over the contents of the source WifiEnterpriseConfig object over to this object.\n     *\n     * @param source Source WifiEnterpriseConfig object.\n     * @param ignoreMaskedPassword Set to true to ignore masked password field, false otherwise.\n     * @param mask if |ignoreMaskedPassword| is set, check if the incoming password field is set\n     *             to this value.\n     ",
    "links" : [ ]
  }, {
    "name" : "public void copyFromExternal(WifiEnterpriseConfig externalConfig, String mask)",
    "returnType" : "void",
    "comment" : "\n     * Copy fields from the provided external WifiEnterpriseConfig.\n     * This is needed to handle the WifiEnterpriseConfig objects which were sent by apps with the\n     * password field masked.\n     *\n     * @param externalConfig External WifiEnterpriseConfig object.\n     * @param mask String mask to compare against.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public int describeContents()",
    "returnType" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public void writeToParcel(Parcel dest, int flags)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public boolean saveToSupplicant(SupplicantSaver saver)",
    "returnType" : "boolean",
    "comment" : "\n     * Internal use only; supply field values to wpa_supplicant config.  The configuration\n     * process aborts on the first failed call on {@code saver}.\n     * @param saver proxy for setting configuration in wpa_supplciant\n     * @return whether the save succeeded on all attempts\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public void loadFromSupplicant(SupplicantLoader loader)",
    "returnType" : "void",
    "comment" : "\n     * Internal use only; retrieve configuration from wpa_supplicant config.\n     * @param loader proxy for retrieving configuration keys from wpa_supplicant\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public void setEapMethod(int eapMethod)",
    "returnType" : "void",
    "comment" : "\n     * Set the EAP authentication method.\n     * @param  eapMethod is one of {@link Eap}, except for {@link Eap#NONE}\n     * @throws IllegalArgumentException on an invalid eap method\n     ",
    "links" : [ "Eap", "#NONE" ]
  }, {
    "name" : "public int getEapMethod()",
    "returnType" : "int",
    "comment" : "\n     * Get the eap method.\n     * @return eap method configured\n     ",
    "links" : [ ]
  }, {
    "name" : "public void setPhase2Method(int phase2Method)",
    "returnType" : "void",
    "comment" : "\n     * Set Phase 2 authentication method. Sets the inner authentication method to be used in\n     * phase 2 after setting up a secure channel\n     * @param phase2Method is the inner authentication method and can be one of {@link Phase2}\n     * @throws IllegalArgumentException on an invalid phase2 method\n     ",
    "links" : [ "Phase2" ]
  }, {
    "name" : "public int getPhase2Method()",
    "returnType" : "int",
    "comment" : "\n     * Get the phase 2 authentication method.\n     * @return a phase 2 method defined at {@link Phase2}\n     * ",
    "links" : [ "Phase2" ]
  }, {
    "name" : "public void setIdentity(String identity)",
    "returnType" : "void",
    "comment" : "\n     * Set the identity\n     * @param identity\n     ",
    "links" : [ ]
  }, {
    "name" : "public String getIdentity()",
    "returnType" : "String",
    "comment" : "\n     * Get the identity\n     * @return the identity\n     ",
    "links" : [ ]
  }, {
    "name" : "public void setAnonymousIdentity(String anonymousIdentity)",
    "returnType" : "void",
    "comment" : "\n     * Set anonymous identity. This is used as the unencrypted identity with\n     * certain EAP types\n     * @param anonymousIdentity the anonymous identity\n     ",
    "links" : [ ]
  }, {
    "name" : "public String getAnonymousIdentity()",
    "returnType" : "String",
    "comment" : "\n     * Get the anonymous identity\n     * @return anonymous identity\n     ",
    "links" : [ ]
  }, {
    "name" : "public void setPassword(String password)",
    "returnType" : "void",
    "comment" : "\n     * Set the password.\n     * @param password the password\n     ",
    "links" : [ ]
  }, {
    "name" : "public String getPassword()",
    "returnType" : "String",
    "comment" : "\n     * Get the password.\n     *\n     * Returns locally set password value. For networks fetched from\n     * framework, returns \"*\".\n     ",
    "links" : [ ]
  }, {
    "name" : "public static String encodeCaCertificateAlias(String alias)",
    "returnType" : "String",
    "comment" : "\n     * Encode a CA certificate alias so it does not contain illegal character.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public static String decodeCaCertificateAlias(String alias)",
    "returnType" : "String",
    "comment" : "\n     * Decode a previously-encoded CA certificate alias.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public void setServerCertificateHash(String certHash)",
    "returnType" : "void",
    "comment" : "\n     * Set a server certificate hash instead of a CA certificate for a TOFU connection\n     *\n     * @param certHash Server certificate hash to match against in subsequent connections\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public void setCaCertificateAlias(String alias)",
    "returnType" : "void",
    "comment" : "\n     * Set CA certificate alias.\n     *\n     * <p> See the {@link android.security.KeyChain} for details on installing or choosing\n     * a certificate\n     * </p>\n     * @param alias identifies the certificate\n     * @hide\n     ",
    "links" : [ "android.security.KeyChain" ]
  }, {
    "name" : "public void setCaCertificateAliases(@Nullable String[] aliases)",
    "returnType" : "void",
    "comment" : "\n     * Set CA certificate aliases. When creating installing the corresponding certificate to\n     * the keystore, please use alias encoded by {@link #encodeCaCertificateAlias(String)}.\n     *\n     * <p> See the {@link android.security.KeyChain} for details on installing or choosing\n     * a certificate.\n     * </p>\n     * @param aliases identifies the certificate. Can be null to indicate the absence of a\n     *                certificate.\n     * @hide\n     ",
    "links" : [ "android.security.KeyChain", "#encodeCaCertificateAlias(String)" ]
  }, {
    "name" : "public boolean hasCaCertificate()",
    "returnType" : "boolean",
    "comment" : "\n     * Indicates whether or not this enterprise config has a CA certificate configured.\n     ",
    "links" : [ ]
  }, {
    "name" : "public String getCaCertificateAlias()",
    "returnType" : "String",
    "comment" : "\n     * Get CA certificate alias\n     * @return alias to the CA certificate\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public String[] getCaCertificateAliases()",
    "returnType" : "String[]",
    "comment" : "\n     * Get CA certificate aliases.\n     * @return alias to the CA certificate, or null if unset.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public void setCaCertificate(@Nullable X509Certificate cert)",
    "returnType" : "void",
    "comment" : "\n     * Specify a X.509 certificate that identifies the server.\n     *\n     * <p>A default name is automatically assigned to the certificate and used\n     * with this configuration. The framework takes care of installing the\n     * certificate when the config is saved and removing the certificate when\n     * the config is removed.\n     *\n     * Note: If no certificate is set for an Enterprise configuration, either by not calling this\n     * API (or the {@link #setCaCertificates(X509Certificate[])}, or by calling it with null, then\n     * the server certificate validation is skipped - which means that the connection is not secure.\n     *\n     * @param cert X.509 CA certificate\n     * @throws IllegalArgumentException if not a CA certificate\n     ",
    "links" : [ "#setCaCertificates(X509Certificate" ]
  }, {
    "name" : "public void setCaCertificateForTrustOnFirstUse(@Nullable X509Certificate cert)",
    "returnType" : "void",
    "comment" : "\n     * Specify a X.509 certificate that identifies the server.\n     *\n     * This hidden API allows setting self-signed certificate for Trust on First Use.\n     *\n     * @param cert X.509 CA certificate\n     * @throws IllegalArgumentException if Trust on First Use is not enabled.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public X509Certificate getCaCertificate()",
    "returnType" : "X509Certificate",
    "comment" : "\n     * Get CA certificate. If multiple CA certificates are configured previously,\n     * return the first one.\n     * @return X.509 CA certificate\n     ",
    "links" : [ ]
  }, {
    "name" : "public void setCaCertificates(@Nullable X509Certificate[] certs)",
    "returnType" : "void",
    "comment" : "\n     * Specify a list of X.509 certificates that identifies the server. The validation\n     * passes if the CA of server certificate matches one of the given certificates.\n\n     * <p>Default names are automatically assigned to the certificates and used\n     * with this configuration. The framework takes care of installing the\n     * certificates when the config is saved and removing the certificates when\n     * the config is removed.\n     *\n     * Note: If no certificates are set for an Enterprise configuration, either by not calling this\n     * API (or the {@link #setCaCertificate(X509Certificate)}, or by calling it with null, then the\n     * server certificate validation is skipped - which means that the\n     * connection is not secure.\n     *\n     * @param certs X.509 CA certificates\n     * @throws IllegalArgumentException if any of the provided certificates is\n     *     not a CA certificate, or if too many CA certificates are provided\n     ",
    "links" : [ "#setCaCertificate(X509Certificate)" ]
  }, {
    "name" : "public X509Certificate[] getCaCertificates()",
    "returnType" : "X509Certificate[]",
    "comment" : "\n     * Get CA certificates.\n     ",
    "links" : [ ]
  }, {
    "name" : "public void resetCaCertificate()",
    "returnType" : "void",
    "comment" : "\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public void setCaPath(@NonNull String path)",
    "returnType" : "void",
    "comment" : "\n     * Set the ca_path directive on wpa_supplicant.\n     *\n     * From wpa_supplicant documentation:\n     *\n     * Directory path for CA certificate files (PEM). This path may contain\n     * multiple CA certificates in OpenSSL format. Common use for this is to\n     * point to system trusted CA list which is often installed into directory\n     * like /etc/ssl/certs. If configured, these certificates are added to the\n     * list of trusted CAs. ca_cert may also be included in that case, but it is\n     * not required.\n     *\n     * Note: If no certificate path is set for an Enterprise configuration, either by not calling\n     * this API, or by calling it with null, and no certificate is set by\n     * {@link #setCaCertificate(X509Certificate)} or {@link #setCaCertificates(X509Certificate[])},\n     * then the server certificate validation is skipped - which means that the connection is not\n     * secure.\n     *\n     * @param path The path for CA certificate files, or empty string to clear.\n     * @hide\n     ",
    "links" : [ "#setCaCertificate(X509Certificate)", "#setCaCertificates(X509Certificate" ]
  }, {
    "name" : "public String getCaPath()",
    "returnType" : "String",
    "comment" : "\n     * Get the ca_path directive from wpa_supplicant.\n     * @return The path for CA certificate files, or an empty string if unset.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public void setClientCertificateAlias(@NonNull String alias)",
    "returnType" : "void",
    "comment" : "\n     * Set Client certificate alias.\n     *\n     * <p> See the {@link android.security.KeyChain} for details on installing or choosing\n     * a certificate\n     * </p>\n     * @param alias identifies the certificate, or empty string to clear.\n     * @hide\n     ",
    "links" : [ "android.security.KeyChain" ]
  }, {
    "name" : "public String getClientCertificateAlias()",
    "returnType" : "String",
    "comment" : "\n     * Get client certificate alias.\n     * @return alias to the client certificate, or an empty string if unset.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public void setClientKeyEntry(PrivateKey privateKey, X509Certificate clientCertificate)",
    "returnType" : "void",
    "comment" : "\n     * Specify a private key and client certificate for client authorization.\n     *\n     * <p>A default name is automatically assigned to the key entry and used\n     * with this configuration.  The framework takes care of installing the\n     * key entry when the config is saved and removing the key entry when\n     * the config is removed.\n\n     * @param privateKey a PrivateKey instance for the end certificate.\n     * @param clientCertificate an X509Certificate representing the end certificate.\n     * @throws IllegalArgumentException for an invalid key or certificate.\n     ",
    "links" : [ ]
  }, {
    "name" : "public void setClientKeyEntryWithCertificateChain(PrivateKey privateKey, X509Certificate[] clientCertificateChain)",
    "returnType" : "void",
    "comment" : "\n     * Specify a private key and client certificate chain for client authorization.\n     *\n     * <p>A default name is automatically assigned to the key entry and used\n     * with this configuration.  The framework takes care of installing the\n     * key entry when the config is saved and removing the key entry when\n     * the config is removed.\n     *\n     * @param privateKey a PrivateKey instance for the end certificate.\n     * @param clientCertificateChain an array of X509Certificate instances which starts with\n     *         end certificate and continues with additional CA certificates necessary to\n     *         link the end certificate with some root certificate known by the authenticator.\n     * @throws IllegalArgumentException for an invalid key or certificate.\n     ",
    "links" : [ ]
  }, {
    "name" : "public void setClientKeyPairAlias(@NonNull String alias)",
    "returnType" : "void",
    "comment" : "\n     * Specify a key pair via KeyChain alias for client authentication.\n     *\n     * The alias should refer to a key pair in KeyChain that is allowed for WiFi authentication.\n     *\n     * @param alias key pair alias\n     * @see android.app.admin.DevicePolicyManager#grantKeyPairToWifiAuth(String)\n     ",
    "links" : [ ]
  }, {
    "name" : "public String getClientKeyPairAlias()",
    "returnType" : "String",
    "comment" : "\n     * Get KeyChain alias to use for client authentication.\n     ",
    "links" : [ ]
  }, {
    "name" : "public String getClientKeyPairAliasInternal()",
    "returnType" : "String",
    "comment" : "\n     * Get KeyChain alias to use for client authentication without SDK check.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public X509Certificate getClientCertificate()",
    "returnType" : "X509Certificate",
    "comment" : "\n     * Get client certificate\n     *\n     * @return X.509 client certificate\n     ",
    "links" : [ ]
  }, {
    "name" : "public X509Certificate[] getClientCertificateChain()",
    "returnType" : "X509Certificate[]",
    "comment" : "\n     * Get the complete client certificate chain in the same order as it was last supplied.\n     *\n     * <p>If the chain was last supplied by a call to\n     * {@link #setClientKeyEntry(java.security.PrivateKey, java.security.cert.X509Certificate)}\n     * with a non-null * certificate instance, a single-element array containing the certificate\n     * will be * returned. If {@link #setClientKeyEntryWithCertificateChain(\n     * java.security.PrivateKey, java.security.cert.X509Certificate[])} was last called with a\n     * non-empty array, this array will be returned in the same order as it was supplied.\n     * Otherwise, {@code null} will be returned.\n     *\n     * @return X.509 client certificates\n     ",
    "links" : [ "#setClientKeyEntry(java.security.PrivateKey", "#setClientKeyEntryWithCertificateChain(" ]
  }, {
    "name" : "public void resetClientKeyEntry()",
    "returnType" : "void",
    "comment" : "\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public PrivateKey getClientPrivateKey()",
    "returnType" : "PrivateKey",
    "comment" : "\n     * Get the client private key as supplied in {@link #setClientKeyEntryWithCertificateChain}, or\n     * null if unset.\n     ",
    "links" : [ "#setClientKeyEntryWithCertificateChain" ]
  }, {
    "name" : "public void setSubjectMatch(String subjectMatch)",
    "returnType" : "void",
    "comment" : "\n     * Set subject match (deprecated). This is the substring to be matched against the subject of\n     * the authentication server certificate.\n     * @param subjectMatch substring to be matched\n     * @deprecated in favor of altSubjectMatch\n     ",
    "links" : [ ]
  }, {
    "name" : "public String getSubjectMatch()",
    "returnType" : "String",
    "comment" : "\n     * Get subject match (deprecated)\n     * @return the subject match string\n     * @deprecated in favor of altSubjectMatch\n     ",
    "links" : [ ]
  }, {
    "name" : "public void setAltSubjectMatch(String altSubjectMatch)",
    "returnType" : "void",
    "comment" : "\n     * Set alternate subject match. This is the substring to be matched against the\n     * alternate subject of the authentication server certificate.\n     *\n     * Note: If no alternate subject is set for an Enterprise configuration, either by not calling\n     * this API, or by calling it with null, or not setting domain suffix match using the\n     * {@link #setDomainSuffixMatch(String)}, then the server certificate validation is incomplete -\n     * which means that the connection is not secure.\n     *\n     * @param altSubjectMatch substring to be matched, for example\n     *                     DNS:server.example.com;EMAIL:server@example.com\n     ",
    "links" : [ "#setDomainSuffixMatch(String)" ]
  }, {
    "name" : "public String getAltSubjectMatch()",
    "returnType" : "String",
    "comment" : "\n     * Get alternate subject match\n     * @return the alternate subject match string\n     ",
    "links" : [ ]
  }, {
    "name" : "public void setDomainSuffixMatch(String domain)",
    "returnType" : "void",
    "comment" : "\n     * Set the domain_suffix_match directive on wpa_supplicant. This is the parameter to use\n     * for Hotspot 2.0 defined matching of AAA server certs per WFA HS2.0 spec, section 7.3.3.2,\n     * second paragraph.\n     *\n     * <p>From wpa_supplicant documentation:\n     * <p>Constraint for server domain name. If set, this FQDN is used as a suffix match requirement\n     * for the AAAserver certificate in SubjectAltName dNSName element(s). If a matching dNSName is\n     * found, this constraint is met.\n     * <p>Suffix match here means that the host/domain name is compared one label at a time starting\n     * from the top-level domain and all the labels in domain_suffix_match shall be included in the\n     * certificate. The certificate may include additional sub-level labels in addition to the\n     * required labels.\n     * <p>More than one match string can be provided by using semicolons to separate the strings\n     * (e.g., example.org;example.com). When multiple strings are specified, a match with any one of\n     * the values is considered a sufficient match for the certificate, i.e., the conditions are\n     * ORed ogether.\n     * <p>For example, domain_suffix_match=example.com would match test.example.com but would not\n     * match test-example.com.\n     *\n     * Note: If no domain suffix is set for an Enterprise configuration, either by not calling this\n     * API, or by calling it with null, or not setting alternate subject match using the\n     * {@link #setAltSubjectMatch(String)}, then the server certificate\n     * validation is incomplete - which means that the connection is not secure.\n     *\n     * @param domain The domain value\n     ",
    "links" : [ "#setAltSubjectMatch(String)" ]
  }, {
    "name" : "public String getDomainSuffixMatch()",
    "returnType" : "String",
    "comment" : "\n     * Get the domain_suffix_match value. See setDomSuffixMatch.\n     * @return The domain value.\n     ",
    "links" : [ ]
  }, {
    "name" : "public void setRealm(String realm)",
    "returnType" : "void",
    "comment" : "\n     * Set realm for Passpoint credential; realm identifies a set of networks where your\n     * Passpoint credential can be used\n     * @param realm the realm\n     ",
    "links" : [ ]
  }, {
    "name" : "public String getRealm()",
    "returnType" : "String",
    "comment" : "\n     * Get realm for Passpoint credential; see {@link #setRealm(String)} for more information\n     * @return the realm\n     ",
    "links" : [ "#setRealm(String)" ]
  }, {
    "name" : "public void setSelectedRcoi(long selectedRcoi)",
    "returnType" : "void",
    "comment" : "\n     * Set selected RCOI for Passpoint: Indicates which RCOI was selected on a particular network\n     * @param selectedRcoi the selected RCOI on a particular network\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public long getSelectedRcoi()",
    "returnType" : "long",
    "comment" : "\n     * Get the selected RCOI matched for a Passpoint connection\n     * @return the selected RCOI\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public void setStrictConservativePeerMode(boolean enable)",
    "returnType" : "void",
    "comment" : "\n     * Enable or disable the conservative peer mode, this is only meaningful for\n     * EAP-SIM/AKA/AKA'\n     * @param enable true if the conservative peer mode is enabled.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean getStrictConservativePeerMode()",
    "returnType" : "boolean",
    "comment" : "\n     * Check if the conservative peer mode is enabled or not, this is only meaningful for\n     * EAP-SIM/AKA/AKA'\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public void setPlmn(String plmn)",
    "returnType" : "void",
    "comment" : "\n     * Set plmn (Public Land Mobile Network) of the provider of Passpoint credential\n     * @param plmn the plmn value derived from mcc (mobile country code) & mnc (mobile network code)\n     ",
    "links" : [ ]
  }, {
    "name" : "public String getPlmn()",
    "returnType" : "String",
    "comment" : "\n     * Get plmn (Public Land Mobile Network) for Passpoint credential; see {@link #setPlmn\n     * (String)} for more information\n     * @return the plmn\n     ",
    "links" : [ "#setPlmn(String)" ]
  }, {
    "name" : "public String getKeyId(WifiEnterpriseConfig current)",
    "returnType" : "String",
    "comment" : " See {@link WifiConfiguration#getKeyIdForCredentials} @hide ",
    "links" : [ "android.net.wifi.WifiConfiguration#getKeyIdForCredentials" ]
  }, {
    "name" : "private String removeDoubleQuotes(String string)",
    "returnType" : "String",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private String convertToQuotedString(String string)",
    "returnType" : "String",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private int getStringIndex(String[] arr, String toBeFound, int defaultIndex)",
    "returnType" : "int",
    "comment" : "\n     * Returns the index at which the toBeFound string is found in the array.\n     * @param arr array of strings\n     * @param toBeFound string to be found\n     * @param defaultIndex default index to be returned when string is not found\n     * @return the index into array\n     ",
    "links" : [ ]
  }, {
    "name" : "private String getFieldValue(String key, String prefix)",
    "returnType" : "String",
    "comment" : "\n     * Returns the field value for the key with prefix removed.\n     * @param key into the hash\n     * @param prefix is the prefix that the value may have\n     * @return value\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public String getFieldValue(String key)",
    "returnType" : "String",
    "comment" : "\n     * Returns the field value for the key.\n     * @param key into the hash\n     * @return value\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "private void setFieldValue(String key, String value, String prefix)",
    "returnType" : "void",
    "comment" : "\n     * Set a value with an optional prefix at key\n     * @param key into the hash\n     * @param value to be set\n     * @param prefix an optional value to be prefixed to actual value\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public void setFieldValue(String key, String value)",
    "returnType" : "void",
    "comment" : "\n     * Set a value at key\n     * @param key into the hash\n     * @param value to be set\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public String toString()",
    "returnType" : "String",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private boolean isEapMethodValid()",
    "returnType" : "boolean",
    "comment" : "\n     * Returns whether the EAP method data is valid, i.e., whether mEapMethod and mPhase2Method\n     * are valid indices into {@code Eap.strings[]} and {@code Phase2.strings[]} respectively.\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean isAppInstalledDeviceKeyAndCert()",
    "returnType" : "boolean",
    "comment" : "\n     * Check if certificate was installed by an app, or manually (not by an app). If true,\n     * certificate and keys will be removed from key storage when this network is removed. If not,\n     * then certificates and keys remain persistent until the user manually removes them.\n     *\n     * @return true if certificate was installed by an app, false if certificate was installed\n     * manually by the user.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public void initIsAppInstalledDeviceKeyAndCert(boolean isAppInstalledDeviceKeyAndCert)",
    "returnType" : "void",
    "comment" : "\n     * Initialize the value of the app installed device key and cert flag.\n     *\n     * @param isAppInstalledDeviceKeyAndCert true or false\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean isAppInstalledCaCert()",
    "returnType" : "boolean",
    "comment" : "\n     * Check if CA certificate was installed by an app, or manually (not by an app). If true,\n     * CA certificate will be removed from key storage when this network is removed. If not,\n     * then certificates and keys remain persistent until the user manually removes them.\n     *\n     * @return true if CA certificate was installed by an app, false if CA certificate was installed\n     * manually by the user.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public void initIsAppInstalledCaCert(boolean isAppInstalledCaCert)",
    "returnType" : "void",
    "comment" : "\n     * Initialize the value of the app installed root CA cert flag.\n     *\n     * @param isAppInstalledCaCert true or false\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public void setOcsp(@Ocsp int ocsp)",
    "returnType" : "void",
    "comment" : "\n     * Set the OCSP type.\n     * @param ocsp is one of {@link ##OCSP_NONE}, {@link #OCSP_REQUEST_CERT_STATUS},\n     *                   {@link #OCSP_REQUIRE_CERT_STATUS} or\n     *                   {@link #OCSP_REQUIRE_ALL_NON_TRUSTED_CERTS_STATUS}\n     * @throws IllegalArgumentException if the OCSP type is invalid\n     * @hide\n     ",
    "links" : [ "#OCSP_REQUIRE_CERT_STATUS", "#OCSP_REQUEST_CERT_STATUS", "#OCSP_REQUIRE_ALL_NON_TRUSTED_CERTS_STATUS" ]
  }, {
    "name" : "public int getOcsp()",
    "returnType" : "int",
    "comment" : "\n     * Get the OCSP type.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean isAuthenticationSimBased()",
    "returnType" : "boolean",
    "comment" : "\n     * Utility method to determine whether the configuration's authentication method is SIM-based.\n     *\n     * @return true if the credential information requires SIM card for current authentication\n     * method, otherwise it returns false.\n     ",
    "links" : [ ]
  }, {
    "name" : "public void setWapiCertSuite(@NonNull String wapiCertSuite)",
    "returnType" : "void",
    "comment" : "\n     * Set the WAPI certificate suite name on wpa_supplicant.\n     *\n     * If this field is not specified, WAPI-CERT uses ASU ID from WAI packet\n     * as the certificate suite name automatically.\n     *\n     * @param wapiCertSuite The name for WAPI certificate suite, or empty string to clear.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public String getWapiCertSuite()",
    "returnType" : "String",
    "comment" : "\n     * Get the WAPI certificate suite name\n     * @return the certificate suite name\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean isEapMethodServerCertUsed()",
    "returnType" : "boolean",
    "comment" : "\n     * Determines whether an Enterprise configuration's EAP method requires a Root CA certification\n     * to validate the authentication server i.e. PEAP, TLS, UNAUTH_TLS, or TTLS.\n     * @return True if configuration requires a CA certification, false otherwise.\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean isServerCertValidationEnabled()",
    "returnType" : "boolean",
    "comment" : "\n     * Determines whether an Enterprise configuration enables server certificate validation.\n     * <p>\n     * The caller can determine, along with {@link #isEapMethodServerCertUsed()}, if an\n     * Enterprise configuration enables server certificate validation, which is a mandatory\n     * requirement for networks that use TLS based EAP methods. A configuration that does not\n     * enable server certificate validation will be ignored and will not be considered for\n     * network selection. A network suggestion with such a configuration will cause an\n     * IllegalArgumentException to be thrown when suggested.\n     * Server validation is achieved by the following:\n     * - Either certificate or CA path is configured.\n     * - Either alternative subject match or domain suffix match is set.\n     * @return True for server certificate validation is enabled, false otherwise.\n     * @throws IllegalStateException on configuration which doesn't use server certificate.\n     * @see #isEapMethodServerCertUsed()\n     ",
    "links" : [ "#isEapMethodServerCertUsed()" ]
  }, {
    "name" : "public boolean isMandatoryParameterSetForServerCertValidation()",
    "returnType" : "boolean",
    "comment" : "\n     * Helper method to check if mandatory parameter for server cert validation is set.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public static boolean isSuiteBCipherCert(@Nullable X509Certificate x509Certificate)",
    "returnType" : "boolean",
    "comment" : "\n     * Check if a given certificate Get the Suite-B cipher from the certificate\n     *\n     * @param x509Certificate Certificate to process\n     * @return true if the certificate OID matches the Suite-B requirements for RSA or ECDSA\n     * certificates, or false otherwise.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public void setDecoratedIdentityPrefix(@Nullable String decoratedIdentityPrefix)",
    "returnType" : "void",
    "comment" : "\n     * Set a prefix for a decorated identity as per RFC 7542.\n     * This prefix must contain a list of realms (could be a list of 1) delimited by a '!'\n     * character. e.g. homerealm.example.org! or proxyrealm.example.net!homerealm.example.org!\n     * A prefix of \"homerealm.example.org!\" will generate a decorated identity that\n     * looks like: homerealm.example.org!user@otherrealm.example.net\n     * Calling with a null parameter will clear the decorated prefix.\n     * Note: Caller must verify that the device supports this feature by calling\n     * {@link WifiManager#isDecoratedIdentitySupported()}\n     *\n     * @param decoratedIdentityPrefix The prefix to add to the outer/anonymous identity\n     ",
    "links" : [ "android.net.wifi.WifiManager#isDecoratedIdentitySupported()" ]
  }, {
    "name" : "public String getDecoratedIdentityPrefix()",
    "returnType" : "String",
    "comment" : "\n     * Get the decorated identity prefix.\n     *\n     * @return The decorated identity prefix\n     ",
    "links" : [ ]
  }, {
    "name" : "public void enableTrustOnFirstUse(boolean enable)",
    "returnType" : "void",
    "comment" : "\n     * Enable Trust On First Use.\n     *\n     * Trust On First Use (TOFU) simplifies manual or partial configurations\n     * of TLS-based EAP networks. TOFU operates by installing the Root CA cert\n     * which is received from the server during an initial connection to a new network.\n     * Such installation is gated by user approval.\n     * Use only when it is not possible to configure the Root CA cert for the server.\n     * <br>\n     * Note: If a Root CA cert is already configured, this option is ignored,\n     * e.g. if {@link #setCaCertificate(X509Certificate)}, or\n     * {@link #setCaCertificates(X509Certificate[])} is called.\n     *\n     * @param enable true to enable; false otherwise (the default if the method is not called).\n     ",
    "links" : [ "#setCaCertificate(X509Certificate)", "#setCaCertificates(X509Certificate" ]
  }, {
    "name" : "public boolean isTrustOnFirstUseEnabled()",
    "returnType" : "boolean",
    "comment" : "\n     * Indicates whether or not Trust On First Use (TOFU) is enabled.\n     *\n     * @return Trust On First Use is enabled or not.\n     ",
    "links" : [ ]
  }, {
    "name" : "public void setTofuConnectionState(@TofuConnectionState int state)",
    "returnType" : "void",
    "comment" : "\n     * Set the TOFU connection state.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public int getTofuConnectionState()",
    "returnType" : "int",
    "comment" : "\n     * Get the TOFU connection state.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public void setTofuDialogApproved(boolean approved)",
    "returnType" : "void",
    "comment" : "\n     * Indicate whether the user accepted the TOFU dialog.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public void setTofuDialogState(@TofuDialogState int state)",
    "returnType" : "void",
    "comment" : "\n     * Set the TOFU dialog state.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public int getTofuDialogState()",
    "returnType" : "int",
    "comment" : "\n     * Get the TOFU dialog state.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public void setUserApproveNoCaCert(boolean approved)",
    "returnType" : "void",
    "comment" : "\n     * For devices with no TOFU support, indicate that the user approved that a\n     * legacy TLS-based EAP configuration from a previous release can be used\n     * without a Root CA certificate.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean isUserApproveNoCaCert()",
    "returnType" : "boolean",
    "comment" : "\n     * For devices with no TOFU support, indicates if the user approved that a\n     * legacy TLS-based EAP configuration from a previous release can be used\n     * without a Root CA certificate.\n     *\n     * @return indicate whether a user approves this no CA cert config.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public void setMinimumTlsVersion(@TlsVersion int tlsVersion) throws IllegalArgumentException",
    "returnType" : "void",
    "comment" : "\n     * Set the minimum TLS version for TLS-based EAP methods.\n     *\n     * {@link WifiManager#isTlsMinimumVersionSupported()} indicates whether or not a minimum\n     * TLS version can be set. If not supported, the minimum TLS version is always TLS v1.0.\n     * <p>\n     * {@link WifiManager#isTlsV13Supported()} indicates whether or not TLS v1.3 is supported.\n     * If requested minimum is not supported, it will default to the maximum supported version.\n     *\n     * @param tlsVersion the TLS version\n     * @throws IllegalArgumentException if the TLS version is invalid.\n     ",
    "links" : [ "android.net.wifi.WifiManager#isTlsMinimumVersionSupported()", "android.net.wifi.WifiManager#isTlsV13Supported()" ]
  }, {
    "name" : "public int getMinimumTlsVersion()",
    "returnType" : "int",
    "comment" : "\n     * Get the minimum TLS version for TLS-based EAP methods.\n     *\n     * @return the TLS version\n     ",
    "links" : [ ]
  } ],
  "methodNames" : [ "private static boolean isKeySupported(String key)", "private static boolean isFieldLengthValid(String key, String value)", "private static boolean isFieldLengthValid(String value, int maxLength)", "private static boolean isFieldValid(String key, String value)", "private Bundle fieldMapToBundle()", "private static HashMap<String, String> bundleToFieldMap(Bundle bundle)", "private void copyFrom(WifiEnterpriseConfig source, boolean ignoreMaskedPassword, String mask)", "public void copyFromExternal(WifiEnterpriseConfig externalConfig, String mask)", "public int describeContents()", "public void writeToParcel(Parcel dest, int flags)", "public boolean saveToSupplicant(SupplicantSaver saver)", "public void loadFromSupplicant(SupplicantLoader loader)", "public void setEapMethod(int eapMethod)", "public int getEapMethod()", "public void setPhase2Method(int phase2Method)", "public int getPhase2Method()", "public void setIdentity(String identity)", "public String getIdentity()", "public void setAnonymousIdentity(String anonymousIdentity)", "public String getAnonymousIdentity()", "public void setPassword(String password)", "public String getPassword()", "public static String encodeCaCertificateAlias(String alias)", "public static String decodeCaCertificateAlias(String alias)", "public void setServerCertificateHash(String certHash)", "public void setCaCertificateAlias(String alias)", "public void setCaCertificateAliases(@Nullable String[] aliases)", "public boolean hasCaCertificate()", "public String getCaCertificateAlias()", "public String[] getCaCertificateAliases()", "public void setCaCertificate(@Nullable X509Certificate cert)", "public void setCaCertificateForTrustOnFirstUse(@Nullable X509Certificate cert)", "public X509Certificate getCaCertificate()", "public void setCaCertificates(@Nullable X509Certificate[] certs)", "public X509Certificate[] getCaCertificates()", "public void resetCaCertificate()", "public void setCaPath(@NonNull String path)", "public String getCaPath()", "public void setClientCertificateAlias(@NonNull String alias)", "public String getClientCertificateAlias()", "public void setClientKeyEntry(PrivateKey privateKey, X509Certificate clientCertificate)", "public void setClientKeyEntryWithCertificateChain(PrivateKey privateKey, X509Certificate[] clientCertificateChain)", "public void setClientKeyPairAlias(@NonNull String alias)", "public String getClientKeyPairAlias()", "public String getClientKeyPairAliasInternal()", "public X509Certificate getClientCertificate()", "public X509Certificate[] getClientCertificateChain()", "public void resetClientKeyEntry()", "public PrivateKey getClientPrivateKey()", "public void setSubjectMatch(String subjectMatch)", "public String getSubjectMatch()", "public void setAltSubjectMatch(String altSubjectMatch)", "public String getAltSubjectMatch()", "public void setDomainSuffixMatch(String domain)", "public String getDomainSuffixMatch()", "public void setRealm(String realm)", "public String getRealm()", "public void setSelectedRcoi(long selectedRcoi)", "public long getSelectedRcoi()", "public void setStrictConservativePeerMode(boolean enable)", "public boolean getStrictConservativePeerMode()", "public void setPlmn(String plmn)", "public String getPlmn()", "public String getKeyId(WifiEnterpriseConfig current)", "private String removeDoubleQuotes(String string)", "private String convertToQuotedString(String string)", "private int getStringIndex(String[] arr, String toBeFound, int defaultIndex)", "private String getFieldValue(String key, String prefix)", "public String getFieldValue(String key)", "private void setFieldValue(String key, String value, String prefix)", "public void setFieldValue(String key, String value)", "public String toString()", "private boolean isEapMethodValid()", "public boolean isAppInstalledDeviceKeyAndCert()", "public void initIsAppInstalledDeviceKeyAndCert(boolean isAppInstalledDeviceKeyAndCert)", "public boolean isAppInstalledCaCert()", "public void initIsAppInstalledCaCert(boolean isAppInstalledCaCert)", "public void setOcsp(@Ocsp int ocsp)", "public int getOcsp()", "public boolean isAuthenticationSimBased()", "public void setWapiCertSuite(@NonNull String wapiCertSuite)", "public String getWapiCertSuite()", "public boolean isEapMethodServerCertUsed()", "public boolean isServerCertValidationEnabled()", "public boolean isMandatoryParameterSetForServerCertValidation()", "public static boolean isSuiteBCipherCert(@Nullable X509Certificate x509Certificate)", "public void setDecoratedIdentityPrefix(@Nullable String decoratedIdentityPrefix)", "public String getDecoratedIdentityPrefix()", "public void enableTrustOnFirstUse(boolean enable)", "public boolean isTrustOnFirstUseEnabled()", "public void setTofuConnectionState(@TofuConnectionState int state)", "public int getTofuConnectionState()", "public void setTofuDialogApproved(boolean approved)", "public void setTofuDialogState(@TofuDialogState int state)", "public int getTofuDialogState()", "public void setUserApproveNoCaCert(boolean approved)", "public boolean isUserApproveNoCaCert()", "public void setMinimumTlsVersion(@TlsVersion int tlsVersion) throws IllegalArgumentException", "public int getMinimumTlsVersion()" ],
  "variableNames" : [ "WAPI_AS_CERTIFICATE", "WAPI_USER_CERTIFICATE", "EXTRA_WAPI_AS_CERTIFICATE_NAME", "EXTRA_WAPI_AS_CERTIFICATE_DATA", "EXTRA_WAPI_USER_CERTIFICATE_NAME", "EXTRA_WAPI_USER_CERTIFICATE_DATA", "EMPTY_VALUE", "EAP_KEY", "PHASE2_KEY", "IDENTITY_KEY", "ANON_IDENTITY_KEY", "PASSWORD_KEY", "SUBJECT_MATCH_KEY", "ALTSUBJECT_MATCH_KEY", "DOM_SUFFIX_MATCH_KEY", "OPP_KEY_CACHING", "EAP_ERP", "OCSP", "DECORATED_IDENTITY_PREFIX_KEY", "ENGINE_ID_KEYSTORE", "KEYSTORE_URI", "KEYSTORES_URI", "CERT_HASH_PREFIX", "ENGINE_ENABLE", "ENGINE_DISABLE", "CA_CERTIFICATE", "USER_CERTIFICATE", "USER_PRIVATE_KEY", "CA_CERT_PREFIX", "CLIENT_CERT_PREFIX", "CLIENT_CERT_KEY", "CA_CERT_KEY", "CA_PATH_KEY", "ENGINE_KEY", "ENGINE_ID_KEY", "PRIVATE_KEY_ID_KEY", "REALM_KEY", "PLMN_KEY", "CA_CERT_ALIAS_DELIMITER", "WAPI_CERT_SUITE_KEY", "OCSP_NONE", "OCSP_REQUEST_CERT_STATUS", "OCSP_REQUIRE_CERT_STATUS", "OCSP_REQUIRE_ALL_NON_TRUSTED_CERTS_STATUS", "mOcsp", "SUPPLICANT_CONFIG_KEYS", "CERTIFICATE_MAX_LENGTH", "KEYCHAIN_ALIAS_MAX_LENGTH", "CLIENT_CERTIFICATE_CHAIN_MAX_ELEMENTS", "CA_CERTIFICATES_MAX_ELEMENTS", "SUPPORTED_FIELDS", "UNQUOTED_KEYS", "TLS_V1_0", "TLS_V1_1", "TLS_V1_2", "TLS_V1_3", "TLS_VERSION_MIN", "TLS_VERSION_MAX", "TOFU_STATE_NOT_ENABLED", "TOFU_STATE_ENABLED_PRE_CONNECTION", "TOFU_STATE_CONFIGURE_ROOT_CA", "TOFU_STATE_CERT_PINNING", "TOFU_DIALOG_STATE_UNSPECIFIED", "TOFU_DIALOG_STATE_REJECTED", "TOFU_DIALOG_STATE_ACCEPTED", "mFields", "mCaCerts", "mClientPrivateKey", "mClientCertificateChain", "mEapMethod", "mPhase2Method", "mIsAppInstalledDeviceKeyAndCert", "mIsAppInstalledCaCert", "mKeyChainAlias", "mIsTrustOnFirstUseEnabled", "mUserApproveNoCaCert", "mMinimumTlsVersion", "mTofuDialogState", "mTofuConnectionState", "mSelectedRcoi", "mIsStrictConservativePeerMode", "TAG", "CREATOR" ]
}