{
  "filePath" : "/home/maryam/clearblue/files/android-source-35/java/net/Socket.java",
  "packageName" : "java.net",
  "className" : "Socket",
  "comment" : "\n * This class implements client sockets (also called just\n * \"sockets\"). A socket is an endpoint for communication\n * between two machines.\n * <p>\n * The actual work of the socket is performed by an instance of the\n * {@code SocketImpl} class. An application, by changing\n * the socket factory that creates the socket implementation,\n * can configure itself to create sockets appropriate to the local\n * firewall.\n *\n * @author  unascribed\n * @see     java.net.Socket#setSocketImplFactory(java.net.SocketImplFactory)\n * @see     java.net.SocketImpl\n * @see     java.nio.channels.SocketChannel\n * @since   1.0\n ",
  "links" : [ ],
  "variables" : [ {
    "name" : "created",
    "type" : "boolean",
    "comment" : "\n     * Various states of this socket.\n     ",
    "links" : [ ]
  }, {
    "name" : "bound",
    "type" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "connected",
    "type" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "closed",
    "type" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "closeLock",
    "type" : "Object",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "shutIn",
    "type" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "shutOut",
    "type" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "impl",
    "type" : "SocketImpl",
    "comment" : "\n     * The implementation of this Socket.\n     ",
    "links" : [ ]
  }, {
    "name" : "oldImpl",
    "type" : "boolean",
    "comment" : "\n     * Are we using an older SocketImpl?\n     ",
    "links" : [ ]
  }, {
    "name" : "factory",
    "type" : "SocketImplFactory",
    "comment" : "\n     * The factory for all client sockets.\n     ",
    "links" : [ ]
  }, {
    "name" : "options",
    "type" : "Set<SocketOption<?>>",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "optionsSet",
    "type" : "boolean",
    "comment" : "",
    "links" : [ ]
  } ],
  "methods" : [ {
    "name" : "private static Void checkPermission(SocketImpl impl)",
    "returnType" : "Void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private static InetAddress[] nonNullAddress(InetAddress address)",
    "returnType" : "InetAddress[]",
    "comment" : " BEGIN Android-changed: App compat. Socket ctor should try all addresses. http://b/30007735",
    "links" : [ ]
  }, {
    "name" : " void createImpl(boolean stream) throws SocketException",
    "returnType" : "void",
    "comment" : "\n     * Creates the socket implementation.\n     *\n     * @param stream a {@code boolean} value : {@code true} for a TCP socket,\n     *               {@code false} for UDP.\n     * @throws IOException if creation fails\n     * @since 1.4\n     ",
    "links" : [ ]
  }, {
    "name" : "private void checkOldImpl()",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : " void setImpl()",
    "returnType" : "void",
    "comment" : "\n     * Sets impl to the system-default type of SocketImpl.\n     * @since 1.4\n     ",
    "links" : [ ]
  }, {
    "name" : " SocketImpl getImpl() throws SocketException",
    "returnType" : "SocketImpl",
    "comment" : "\n     * Get the {@code SocketImpl} attached to this socket, creating\n     * it if necessary.\n     *\n     * @return  the {@code SocketImpl} attached to that ServerSocket.\n     * @throws SocketException if creation fails\n     * @since 1.4\n     ",
    "links" : [ ]
  }, {
    "name" : "public void connect(SocketAddress endpoint) throws IOException",
    "returnType" : "void",
    "comment" : "\n     * Connects this socket to the server.\n     *\n     * @param   endpoint the {@code SocketAddress}\n     * @throws  IOException if an error occurs during the connection\n     * @throws  java.nio.channels.IllegalBlockingModeException\n     *          if this socket has an associated channel,\n     *          and the channel is in non-blocking mode\n     * @throws  IllegalArgumentException if endpoint is null or is a\n     *          SocketAddress subclass not supported by this socket\n     * @since 1.4\n     * @spec JSR-51\n     ",
    "links" : [ ]
  }, {
    "name" : "public void connect(SocketAddress endpoint, int timeout) throws IOException",
    "returnType" : "void",
    "comment" : "\n     * Connects this socket to the server with a specified timeout value.\n     * A timeout of zero is interpreted as an infinite timeout. The connection\n     * will then block until established or an error occurs.\n     *\n     * @param   endpoint the {@code SocketAddress}\n     * @param   timeout  the timeout value to be used in milliseconds.\n     * @throws  IOException if an error occurs during the connection\n     * @throws  SocketTimeoutException if timeout expires before connecting\n     * @throws  java.nio.channels.IllegalBlockingModeException\n     *          if this socket has an associated channel,\n     *          and the channel is in non-blocking mode\n     * @throws  IllegalArgumentException if endpoint is null or is a\n     *          SocketAddress subclass not supported by this socket\n     * @since 1.4\n     * @spec JSR-51\n     ",
    "links" : [ ]
  }, {
    "name" : "public void bind(SocketAddress bindpoint) throws IOException",
    "returnType" : "void",
    "comment" : "\n     * Binds the socket to a local address.\n     * <P>\n     * If the address is {@code null}, then the system will pick up\n     * an ephemeral port and a valid local address to bind the socket.\n     *\n     * @param   bindpoint the {@code SocketAddress} to bind to\n     * @throws  IOException if the bind operation fails, or if the socket\n     *                     is already bound.\n     * @throws  IllegalArgumentException if bindpoint is a\n     *          SocketAddress subclass not supported by this socket\n     * @throws  SecurityException  if a security manager exists and its\n     *          {@code checkListen} method doesn't allow the bind\n     *          to the local port.\n     *\n     * @since   1.4\n     * @see #isBound\n     ",
    "links" : [ ]
  }, {
    "name" : "private void checkAddress(InetAddress addr, String op)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : " final void postAccept()",
    "returnType" : "void",
    "comment" : "\n     * set the flags after an accept() call.\n     ",
    "links" : [ ]
  }, {
    "name" : " void setCreated()",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : " void setBound()",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : " void setConnected()",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public InetAddress getInetAddress()",
    "returnType" : "InetAddress",
    "comment" : "\n     * Returns the address to which the socket is connected.\n     * <p>\n     * If the socket was connected prior to being {@link #close closed},\n     * then this method will continue to return the connected address\n     * after the socket is closed.\n     *\n     * @return  the remote IP address to which this socket is connected,\n     *          or {@code null} if the socket is not connected.\n     ",
    "links" : [ "#close" ]
  }, {
    "name" : "public InetAddress getLocalAddress()",
    "returnType" : "InetAddress",
    "comment" : "\n     * Gets the local address to which the socket is bound.\n     * <p>\n     * If there is a security manager set, its {@code checkConnect} method is\n     * called with the local address and {@code -1} as its arguments to see\n     * if the operation is allowed. If the operation is not allowed,\n     * the {@link InetAddress#getLoopbackAddress loopback} address is returned.\n     *\n     * @return the local address to which the socket is bound,\n     *         the loopback address if denied by the security manager, or\n     *         the wildcard address if the socket is closed or not bound yet.\n     * @since   1.1\n     *\n     * @see SecurityManager#checkConnect\n     ",
    "links" : [ "java.net.InetAddress#getLoopbackAddress" ]
  }, {
    "name" : "public int getPort()",
    "returnType" : "int",
    "comment" : "\n     * Returns the remote port number to which this socket is connected.\n     * <p>\n     * If the socket was connected prior to being {@link #close closed},\n     * then this method will continue to return the connected port number\n     * after the socket is closed.\n     *\n     * @return  the remote port number to which this socket is connected, or\n     *          0 if the socket is not connected yet.\n     ",
    "links" : [ "#close" ]
  }, {
    "name" : "public int getLocalPort()",
    "returnType" : "int",
    "comment" : "\n     * Returns the local port number to which this socket is bound.\n     * <p>\n     * If the socket was bound prior to being {@link #close closed},\n     * then this method will continue to return the local port number\n     * after the socket is closed.\n     *\n     * @return  the local port number to which this socket is bound or -1\n     *          if the socket is not bound yet.\n     ",
    "links" : [ "#close" ]
  }, {
    "name" : "public SocketAddress getRemoteSocketAddress()",
    "returnType" : "SocketAddress",
    "comment" : "\n     * Returns the address of the endpoint this socket is connected to, or\n     * {@code null} if it is unconnected.\n     * <p>\n     * If the socket was connected prior to being {@link #close closed},\n     * then this method will continue to return the connected address\n     * after the socket is closed.\n     *\n\n     * @return a {@code SocketAddress} representing the remote endpoint of this\n     *         socket, or {@code null} if it is not connected yet.\n     * @see #getInetAddress()\n     * @see #getPort()\n     * @see #connect(SocketAddress, int)\n     * @see #connect(SocketAddress)\n     * @since 1.4\n     ",
    "links" : [ "#close" ]
  }, {
    "name" : "public SocketAddress getLocalSocketAddress()",
    "returnType" : "SocketAddress",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public SocketChannel getChannel()",
    "returnType" : "SocketChannel",
    "comment" : "\n     * Returns the unique {@link java.nio.channels.SocketChannel SocketChannel}\n     * object associated with this socket, if any.\n     *\n     * <p> A socket will have a channel if, and only if, the channel itself was\n     * created via the {@link java.nio.channels.SocketChannel#open\n     * SocketChannel.open} or {@link\n     * java.nio.channels.ServerSocketChannel#accept ServerSocketChannel.accept}\n     * methods.\n     *\n     * @return  the socket channel associated with this socket,\n     *          or {@code null} if this socket was not created\n     *          for a channel\n     *\n     * @since 1.4\n     * @spec JSR-51\n     ",
    "links" : [ "java.nio.channels.SocketChannel#openSocketChannel.open", "java.nio.channels.SocketChannel", "java.nio.channels.ServerSocketChannel#accept" ]
  }, {
    "name" : "public InputStream getInputStream() throws IOException",
    "returnType" : "InputStream",
    "comment" : "\n     * Returns an input stream for this socket.\n     *\n     * <p> If this socket has an associated channel then the resulting input\n     * stream delegates all of its operations to the channel.  If the channel\n     * is in non-blocking mode then the input stream's {@code read} operations\n     * will throw an {@link java.nio.channels.IllegalBlockingModeException}.\n     *\n     * <p>Under abnormal conditions the underlying connection may be\n     * broken by the remote host or the network software (for example\n     * a connection reset in the case of TCP connections). When a\n     * broken connection is detected by the network software the\n     * following applies to the returned input stream :-\n     *\n     * <ul>\n     *\n     *   <li><p>The network software may discard bytes that are buffered\n     *   by the socket. Bytes that aren't discarded by the network\n     *   software can be read using {@link java.io.InputStream#read read}.\n     *\n     *   <li><p>If there are no bytes buffered on the socket, or all\n     *   buffered bytes have been consumed by\n     *   {@link java.io.InputStream#read read}, then all subsequent\n     *   calls to {@link java.io.InputStream#read read} will throw an\n     *   {@link java.io.IOException IOException}.\n     *\n     *   <li><p>If there are no bytes buffered on the socket, and the\n     *   socket has not been closed using {@link #close close}, then\n     *   {@link java.io.InputStream#available available} will\n     *   return {@code 0}.\n     *\n     * </ul>\n     *\n     * <p> Closing the returned {@link java.io.InputStream InputStream}\n     * will close the associated socket.\n     *\n     * @return     an input stream for reading bytes from this socket.\n     * @exception  IOException  if an I/O error occurs when creating the\n     *             input stream, the socket is closed, the socket is\n     *             not connected, or the socket input has been shutdown\n     *             using {@link #shutdownInput()}\n     *\n     * @revised 1.4\n     * @spec JSR-51\n     ",
    "links" : [ "java.nio.channels.IllegalBlockingModeException", "java.io.InputStream#read", "java.io.IOException", "#close", "#shutdownInput()", "java.io.InputStream#available", "java.io.InputStream" ]
  }, {
    "name" : "public OutputStream getOutputStream() throws IOException",
    "returnType" : "OutputStream",
    "comment" : "\n     * Returns an output stream for this socket.\n     *\n     * <p> If this socket has an associated channel then the resulting output\n     * stream delegates all of its operations to the channel.  If the channel\n     * is in non-blocking mode then the output stream's {@code write}\n     * operations will throw an {@link\n     * java.nio.channels.IllegalBlockingModeException}.\n     *\n     * <p> Closing the returned {@link java.io.OutputStream OutputStream}\n     * will close the associated socket.\n     *\n     * @return     an output stream for writing bytes to this socket.\n     * @exception  IOException  if an I/O error occurs when creating the\n     *               output stream or if the socket is not connected.\n     * @revised 1.4\n     * @spec JSR-51\n     ",
    "links" : [ "java.io.OutputStream", "java.nio.channels.IllegalBlockingModeException" ]
  }, {
    "name" : "public void setTcpNoDelay(boolean on) throws SocketException",
    "returnType" : "void",
    "comment" : "\n     * Enable/disable {@link SocketOptions#TCP_NODELAY TCP_NODELAY}\n     * (disable/enable Nagle's algorithm).\n     *\n     * @param on {@code true} to enable TCP_NODELAY,\n     * {@code false} to disable.\n     *\n     * @exception SocketException if there is an error\n     * in the underlying protocol, such as a TCP error.\n     *\n     * @since   1.1\n     *\n     * @see #getTcpNoDelay()\n     ",
    "links" : [ "java.net.SocketOptions#TCP_NODELAY" ]
  }, {
    "name" : "public boolean getTcpNoDelay() throws SocketException",
    "returnType" : "boolean",
    "comment" : "\n     * Tests if {@link SocketOptions#TCP_NODELAY TCP_NODELAY} is enabled.\n     *\n     * @return a {@code boolean} indicating whether or not\n     *         {@link SocketOptions#TCP_NODELAY TCP_NODELAY} is enabled.\n     * @exception SocketException if there is an error\n     * in the underlying protocol, such as a TCP error.\n     * @since   1.1\n     * @see #setTcpNoDelay(boolean)\n     ",
    "links" : [ "java.net.SocketOptions#TCP_NODELAY" ]
  }, {
    "name" : "public void setSoLinger(boolean on, int linger) throws SocketException",
    "returnType" : "void",
    "comment" : "\n     * Enable/disable {@link SocketOptions#SO_LINGER SO_LINGER} with the\n     * specified linger time in seconds. The maximum timeout value is platform\n     * specific.\n     *\n     * The setting only affects socket close.\n     *\n     * @param on     whether or not to linger on.\n     * @param linger how long to linger for, if on is true.\n     * @exception SocketException if there is an error\n     * in the underlying protocol, such as a TCP error.\n     * @exception IllegalArgumentException if the linger value is negative.\n     * @since 1.1\n     * @see #getSoLinger()\n     ",
    "links" : [ "java.net.SocketOptions#SO_LINGER" ]
  }, {
    "name" : "public int getSoLinger() throws SocketException",
    "returnType" : "int",
    "comment" : "\n     * Returns setting for {@link SocketOptions#SO_LINGER SO_LINGER}.\n     * -1 returns implies that the\n     * option is disabled.\n     *\n     * The setting only affects socket close.\n     *\n     * @return the setting for {@link SocketOptions#SO_LINGER SO_LINGER}.\n     * @exception SocketException if there is an error\n     * in the underlying protocol, such as a TCP error.\n     * @since   1.1\n     * @see #setSoLinger(boolean, int)\n     ",
    "links" : [ "java.net.SocketOptions#SO_LINGER" ]
  }, {
    "name" : "public void sendUrgentData(int data) throws IOException",
    "returnType" : "void",
    "comment" : "\n     * Send one byte of urgent data on the socket. The byte to be sent is the lowest eight\n     * bits of the data parameter. The urgent byte is\n     * sent after any preceding writes to the socket OutputStream\n     * and before any future writes to the OutputStream.\n     * @param data The byte of data to send\n     * @exception IOException if there is an error\n     *  sending the data.\n     * @since 1.4\n     ",
    "links" : [ ]
  }, {
    "name" : "public void setOOBInline(boolean on) throws SocketException",
    "returnType" : "void",
    "comment" : "\n     * Enable/disable {@link SocketOptions#SO_OOBINLINE SO_OOBINLINE}\n     * (receipt of TCP urgent data)\n     *\n     * By default, this option is disabled and TCP urgent data received on a\n     * socket is silently discarded. If the user wishes to receive urgent data, then\n     * this option must be enabled. When enabled, urgent data is received\n     * inline with normal data.\n     * <p>\n     * Note, only limited support is provided for handling incoming urgent\n     * data. In particular, no notification of incoming urgent data is provided\n     * and there is no capability to distinguish between normal data and urgent\n     * data unless provided by a higher level protocol.\n     *\n     * @param on {@code true} to enable\n     *           {@link SocketOptions#SO_OOBINLINE SO_OOBINLINE},\n     *           {@code false} to disable.\n     *\n     * @exception SocketException if there is an error\n     * in the underlying protocol, such as a TCP error.\n     *\n     * @since   1.4\n     *\n     * @see #getOOBInline()\n     ",
    "links" : [ "java.net.SocketOptions#SO_OOBINLINE" ]
  }, {
    "name" : "public boolean getOOBInline() throws SocketException",
    "returnType" : "boolean",
    "comment" : "\n     * Tests if {@link SocketOptions#SO_OOBINLINE SO_OOBINLINE} is enabled.\n     *\n     * @return a {@code boolean} indicating whether or not\n     *         {@link SocketOptions#SO_OOBINLINE SO_OOBINLINE}is enabled.\n     *\n     * @exception SocketException if there is an error\n     * in the underlying protocol, such as a TCP error.\n     * @since   1.4\n     * @see #setOOBInline(boolean)\n     ",
    "links" : [ "java.net.SocketOptions#SO_OOBINLINE" ]
  }, {
    "name" : "public synchronized void setSoTimeout(int timeout) throws SocketException",
    "returnType" : "void",
    "comment" : "\n     *  Enable/disable {@link SocketOptions#SO_TIMEOUT SO_TIMEOUT}\n     *  with the specified timeout, in milliseconds. With this option set\n     *  to a non-zero timeout, a read() call on the InputStream associated with\n     *  this Socket will block for only this amount of time.  If the timeout\n     *  expires, a <B>java.net.SocketTimeoutException</B> is raised, though the\n     *  Socket is still valid. The option <B>must</B> be enabled\n     *  prior to entering the blocking operation to have effect. The\n     *  timeout must be {@code > 0}.\n     *  A timeout of zero is interpreted as an infinite timeout.\n     *\n     * @param timeout the specified timeout, in milliseconds.\n     * @exception SocketException if there is an error\n     * in the underlying protocol, such as a TCP error.\n     * @since   1.1\n     * @see #getSoTimeout()\n     ",
    "links" : [ "java.net.SocketOptions#SO_TIMEOUT" ]
  }, {
    "name" : "public synchronized int getSoTimeout() throws SocketException",
    "returnType" : "int",
    "comment" : "\n     * Returns setting for {@link SocketOptions#SO_TIMEOUT SO_TIMEOUT}.\n     * 0 returns implies that the option is disabled (i.e., timeout of infinity).\n     *\n     * @return the setting for {@link SocketOptions#SO_TIMEOUT SO_TIMEOUT}\n     * @exception SocketException if there is an error\n     * in the underlying protocol, such as a TCP error.\n     *\n     * @since   1.1\n     * @see #setSoTimeout(int)\n     ",
    "links" : [ "java.net.SocketOptions#SO_TIMEOUT" ]
  }, {
    "name" : "public synchronized void setSendBufferSize(int size) throws SocketException",
    "returnType" : "void",
    "comment" : "\n     * Sets the {@link SocketOptions#SO_SNDBUF SO_SNDBUF} option to the\n     * specified value for this {@code Socket}.\n     * The {@link SocketOptions#SO_SNDBUF SO_SNDBUF} option is used by the\n     * platform's networking code as a hint for the size to set the underlying\n     * network I/O buffers.\n     *\n     * <p>Because {@link SocketOptions#SO_SNDBUF SO_SNDBUF} is a hint,\n     * applications that want to verify what size the buffers were set to\n     * should call {@link #getSendBufferSize()}.\n     *\n     * @exception SocketException if there is an error\n     * in the underlying protocol, such as a TCP error.\n     *\n     * @param size the size to which to set the send buffer\n     * size. This value must be greater than 0.\n     *\n     * @exception IllegalArgumentException if the\n     * value is 0 or is negative.\n     *\n     * @see #getSendBufferSize()\n     * @since 1.2\n     ",
    "links" : [ "java.net.SocketOptions#SO_SNDBUF", "#getSendBufferSize()" ]
  }, {
    "name" : "public synchronized int getSendBufferSize() throws SocketException",
    "returnType" : "int",
    "comment" : "\n     * Get value of the {@link SocketOptions#SO_SNDBUF SO_SNDBUF} option\n     * for this {@code Socket}, that is the buffer size used by the platform\n     * for output on this {@code Socket}.\n     * @return the value of the {@link SocketOptions#SO_SNDBUF SO_SNDBUF}\n     *         option for this {@code Socket}.\n     *\n     * @exception SocketException if there is an error\n     * in the underlying protocol, such as a TCP error.\n     *\n     * @see #setSendBufferSize(int)\n     * @since 1.2\n     ",
    "links" : [ "java.net.SocketOptions#SO_SNDBUF" ]
  }, {
    "name" : "public synchronized void setReceiveBufferSize(int size) throws SocketException",
    "returnType" : "void",
    "comment" : "\n     * Sets the {@link SocketOptions#SO_RCVBUF SO_RCVBUF} option to the\n     * specified value for this {@code Socket}. The\n     * {@link SocketOptions#SO_RCVBUF SO_RCVBUF} option is\n     * used by the platform's networking code as a hint for the size to set\n     * the underlying network I/O buffers.\n     *\n     * <p>Increasing the receive buffer size can increase the performance of\n     * network I/O for high-volume connection, while decreasing it can\n     * help reduce the backlog of incoming data.\n     *\n     * <p>Because {@link SocketOptions#SO_RCVBUF SO_RCVBUF} is a hint,\n     * applications that want to verify what size the buffers were set to\n     * should call {@link #getReceiveBufferSize()}.\n     *\n     * <p>The value of {@link SocketOptions#SO_RCVBUF SO_RCVBUF} is also used\n     * to set the TCP receive window that is advertized to the remote peer.\n     * Generally, the window size can be modified at any time when a socket is\n     * connected. However, if a receive window larger than 64K is required then\n     * this must be requested <B>before</B> the socket is connected to the\n     * remote peer. There are two cases to be aware of:\n     * <ol>\n     * <li>For sockets accepted from a ServerSocket, this must be done by calling\n     * {@link ServerSocket#setReceiveBufferSize(int)} before the ServerSocket\n     * is bound to a local address.</li>\n     * <li>For client sockets, setReceiveBufferSize() must be called before\n     * connecting the socket to its remote peer.</li></ol>\n     * @param size the size to which to set the receive buffer\n     * size. This value must be greater than 0.\n     *\n     * @exception IllegalArgumentException if the value is 0 or is\n     * negative.\n     *\n     * @exception SocketException if there is an error\n     * in the underlying protocol, such as a TCP error.\n     *\n     * @see #getReceiveBufferSize()\n     * @see ServerSocket#setReceiveBufferSize(int)\n     * @since 1.2\n     ",
    "links" : [ "#getReceiveBufferSize()", "java.net.SocketOptions#SO_RCVBUF", "java.net.ServerSocket#setReceiveBufferSize(int)" ]
  }, {
    "name" : "public synchronized int getReceiveBufferSize() throws SocketException",
    "returnType" : "int",
    "comment" : "\n     * Gets the value of the {@link SocketOptions#SO_RCVBUF SO_RCVBUF} option\n     * for this {@code Socket}, that is the buffer size used by the platform\n     * for input on this {@code Socket}.\n     *\n     * @return the value of the {@link SocketOptions#SO_RCVBUF SO_RCVBUF}\n     *         option for this {@code Socket}.\n     * @exception SocketException if there is an error\n     * in the underlying protocol, such as a TCP error.\n     * @see #setReceiveBufferSize(int)\n     * @since 1.2\n     ",
    "links" : [ "java.net.SocketOptions#SO_RCVBUF" ]
  }, {
    "name" : "public void setKeepAlive(boolean on) throws SocketException",
    "returnType" : "void",
    "comment" : "\n     * Enable/disable {@link SocketOptions#SO_KEEPALIVE SO_KEEPALIVE}.\n     *\n     * @param on  whether or not to have socket keep alive turned on.\n     * @exception SocketException if there is an error\n     * in the underlying protocol, such as a TCP error.\n     * @since 1.3\n     * @see #getKeepAlive()\n     ",
    "links" : [ "java.net.SocketOptions#SO_KEEPALIVE" ]
  }, {
    "name" : "public boolean getKeepAlive() throws SocketException",
    "returnType" : "boolean",
    "comment" : "\n     * Tests if {@link SocketOptions#SO_KEEPALIVE SO_KEEPALIVE} is enabled.\n     *\n     * @return a {@code boolean} indicating whether or not\n     *         {@link SocketOptions#SO_KEEPALIVE SO_KEEPALIVE} is enabled.\n     * @exception SocketException if there is an error\n     * in the underlying protocol, such as a TCP error.\n     * @since   1.3\n     * @see #setKeepAlive(boolean)\n     ",
    "links" : [ "java.net.SocketOptions#SO_KEEPALIVE" ]
  }, {
    "name" : "public void setTrafficClass(int tc) throws SocketException",
    "returnType" : "void",
    "comment" : "\n     * Sets traffic class or type-of-service octet in the IP\n     * header for packets sent from this Socket.\n     * As the underlying network implementation may ignore this\n     * value applications should consider it a hint.\n     *\n     * <P> The tc <B>must</B> be in the range {@code 0 <= tc <=\n     * 255} or an IllegalArgumentException will be thrown.\n     * <p>Notes:\n     * <p>For Internet Protocol v4 the value consists of an\n     * {@code integer}, the least significant 8 bits of which\n     * represent the value of the TOS octet in IP packets sent by\n     * the socket.\n     * RFC 1349 defines the TOS values as follows:\n     *\n     * <UL>\n     * <LI><CODE>IPTOS_LOWCOST (0x02)</CODE></LI>\n     * <LI><CODE>IPTOS_RELIABILITY (0x04)</CODE></LI>\n     * <LI><CODE>IPTOS_THROUGHPUT (0x08)</CODE></LI>\n     * <LI><CODE>IPTOS_LOWDELAY (0x10)</CODE></LI>\n     * </UL>\n     * The last low order bit is always ignored as this\n     * corresponds to the MBZ (must be zero) bit.\n     * <p>\n     * Setting bits in the precedence field may result in a\n     * SocketException indicating that the operation is not\n     * permitted.\n     * <p>\n     * As RFC 1122 section 4.2.4.2 indicates, a compliant TCP\n     * implementation should, but is not required to, let application\n     * change the TOS field during the lifetime of a connection.\n     * So whether the type-of-service field can be changed after the\n     * TCP connection has been established depends on the implementation\n     * in the underlying platform. Applications should not assume that\n     * they can change the TOS field after the connection.\n     * <p>\n     * For Internet Protocol v6 {@code tc} is the value that\n     * would be placed into the sin6_flowinfo field of the IP header.\n     *\n     * @param tc        an {@code int} value for the bitset.\n     * @throws SocketException if there is an error setting the\n     * traffic class or type-of-service\n     * @since 1.4\n     * @see #getTrafficClass\n     * @see SocketOptions#IP_TOS\n     ",
    "links" : [ ]
  }, {
    "name" : "public int getTrafficClass() throws SocketException",
    "returnType" : "int",
    "comment" : "\n     * Gets traffic class or type-of-service in the IP header\n     * for packets sent from this Socket\n     * <p>\n     * As the underlying network implementation may ignore the\n     * traffic class or type-of-service set using {@link #setTrafficClass(int)}\n     * this method may return a different value than was previously\n     * set using the {@link #setTrafficClass(int)} method on this Socket.\n     *\n     * @return the traffic class or type-of-service already set\n     * @throws SocketException if there is an error obtaining the\n     * traffic class or type-of-service value.\n     * @since 1.4\n     * @see #setTrafficClass(int)\n     * @see SocketOptions#IP_TOS\n     ",
    "links" : [ "#setTrafficClass(int)" ]
  }, {
    "name" : "public void setReuseAddress(boolean on) throws SocketException",
    "returnType" : "void",
    "comment" : "\n     * Enable/disable the {@link SocketOptions#SO_REUSEADDR SO_REUSEADDR}\n     * socket option.\n     * <p>\n     * When a TCP connection is closed the connection may remain\n     * in a timeout state for a period of time after the connection\n     * is closed (typically known as the {@code TIME_WAIT} state\n     * or {@code 2MSL} wait state).\n     * For applications using a well known socket address or port\n     * it may not be possible to bind a socket to the required\n     * {@code SocketAddress} if there is a connection in the\n     * timeout state involving the socket address or port.\n     * <p>\n     * Enabling {@link SocketOptions#SO_REUSEADDR SO_REUSEADDR}\n     * prior to binding the socket using {@link #bind(SocketAddress)} allows\n     * the socket to be bound even though a previous connection is in a timeout\n     * state.\n     * <p>\n     * When a {@code Socket} is created the initial setting\n     * of {@link SocketOptions#SO_REUSEADDR SO_REUSEADDR} is disabled.\n     * <p>\n     * The behaviour when {@link SocketOptions#SO_REUSEADDR SO_REUSEADDR} is\n     * enabled or disabled after a socket is bound (See {@link #isBound()})\n     * is not defined.\n     *\n     * @param on  whether to enable or disable the socket option\n     * @exception SocketException if an error occurs enabling or\n     *            disabling the {@link SocketOptions#SO_REUSEADDR SO_REUSEADDR}\n     *            socket option, or the socket is closed.\n     * @since 1.4\n     * @see #getReuseAddress()\n     * @see #bind(SocketAddress)\n     * @see #isClosed()\n     * @see #isBound()\n     ",
    "links" : [ "#bind(SocketAddress)", "java.net.SocketOptions#SO_REUSEADDR", "#isBound()" ]
  }, {
    "name" : "public boolean getReuseAddress() throws SocketException",
    "returnType" : "boolean",
    "comment" : "\n     * Tests if {@link SocketOptions#SO_REUSEADDR SO_REUSEADDR} is enabled.\n     *\n     * @return a {@code boolean} indicating whether or not\n     *         {@link SocketOptions#SO_REUSEADDR SO_REUSEADDR} is enabled.\n     * @exception SocketException if there is an error\n     * in the underlying protocol, such as a TCP error.\n     * @since   1.4\n     * @see #setReuseAddress(boolean)\n     ",
    "links" : [ "java.net.SocketOptions#SO_REUSEADDR" ]
  }, {
    "name" : "public synchronized void close() throws IOException",
    "returnType" : "void",
    "comment" : "\n     * Closes this socket.\n     * <p>\n     * Any thread currently blocked in an I/O operation upon this socket\n     * will throw a {@link SocketException}.\n     * <p>\n     * Once a socket has been closed, it is not available for further networking\n     * use (i.e. can't be reconnected or rebound). A new socket needs to be\n     * created.\n     *\n     * <p> Closing this socket will also close the socket's\n     * {@link java.io.InputStream InputStream} and\n     * {@link java.io.OutputStream OutputStream}.\n     *\n     * <p> If this socket has an associated channel then the channel is closed\n     * as well.\n     *\n     * @exception  IOException  if an I/O error occurs when closing this socket.\n     * @revised 1.4\n     * @spec JSR-51\n     * @see #isClosed\n     ",
    "links" : [ "java.io.OutputStream", "java.net.SocketException", "java.io.InputStream" ]
  }, {
    "name" : "public void shutdownInput() throws IOException",
    "returnType" : "void",
    "comment" : "\n     * Places the input stream for this socket at \"end of stream\".\n     * Any data sent to the input stream side of the socket is acknowledged\n     * and then silently discarded.\n     * <p>\n     * If you read from a socket input stream after invoking this method on the\n     * socket, the stream's {@code available} method will return 0, and its\n     * {@code read} methods will return {@code -1} (end of stream).\n     *\n     * @exception IOException if an I/O error occurs when shutting down this\n     * socket.\n     *\n     * @since 1.3\n     * @see java.net.Socket#shutdownOutput()\n     * @see java.net.Socket#close()\n     * @see java.net.Socket#setSoLinger(boolean, int)\n     * @see #isInputShutdown\n     ",
    "links" : [ ]
  }, {
    "name" : "public void shutdownOutput() throws IOException",
    "returnType" : "void",
    "comment" : "\n     * Disables the output stream for this socket.\n     * For a TCP socket, any previously written data will be sent\n     * followed by TCP's normal connection termination sequence.\n     *\n     * If you write to a socket output stream after invoking\n     * shutdownOutput() on the socket, the stream will throw\n     * an IOException.\n     *\n     * @exception IOException if an I/O error occurs when shutting down this\n     * socket.\n     *\n     * @since 1.3\n     * @see java.net.Socket#shutdownInput()\n     * @see java.net.Socket#close()\n     * @see java.net.Socket#setSoLinger(boolean, int)\n     * @see #isOutputShutdown\n     ",
    "links" : [ ]
  }, {
    "name" : "public String toString()",
    "returnType" : "String",
    "comment" : "\n     * Converts this socket to a {@code String}.\n     *\n     * @return  a string representation of this socket.\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean isConnected()",
    "returnType" : "boolean",
    "comment" : "\n     * Returns the connection state of the socket.\n     * <p>\n     * Note: Closing a socket doesn't clear its connection state, which means\n     * this method will return {@code true} for a closed socket\n     * (see {@link #isClosed()}) if it was successfuly connected prior\n     * to being closed.\n     *\n     * @return true if the socket was successfuly connected to a server\n     * @since 1.4\n     ",
    "links" : [ "#isClosed()" ]
  }, {
    "name" : "public boolean isBound()",
    "returnType" : "boolean",
    "comment" : "\n     * Returns the binding state of the socket.\n     * <p>\n     * Note: Closing a socket doesn't clear its binding state, which means\n     * this method will return {@code true} for a closed socket\n     * (see {@link #isClosed()}) if it was successfuly bound prior\n     * to being closed.\n     *\n     * @return true if the socket was successfuly bound to an address\n     * @since 1.4\n     * @see #bind\n     ",
    "links" : [ "#isClosed()" ]
  }, {
    "name" : "public boolean isClosed()",
    "returnType" : "boolean",
    "comment" : "\n     * Returns the closed state of the socket.\n     *\n     * @return true if the socket has been closed\n     * @since 1.4\n     * @see #close\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean isInputShutdown()",
    "returnType" : "boolean",
    "comment" : "\n     * Returns whether the read-half of the socket connection is closed.\n     *\n     * @return true if the input of the socket has been shutdown\n     * @since 1.4\n     * @see #shutdownInput\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean isOutputShutdown()",
    "returnType" : "boolean",
    "comment" : "\n     * Returns whether the write-half of the socket connection is closed.\n     *\n     * @return true if the output of the socket has been shutdown\n     * @since 1.4\n     * @see #shutdownOutput\n     ",
    "links" : [ ]
  }, {
    "name" : "public static synchronized void setSocketImplFactory(SocketImplFactory fac) throws IOException",
    "returnType" : "void",
    "comment" : "\n     * Sets the client socket implementation factory for the\n     * application. The factory can be specified only once.\n     * <p>\n     * When an application creates a new client socket, the socket\n     * implementation factory's {@code createSocketImpl} method is\n     * called to create the actual socket implementation.\n     * <p>\n     * Passing {@code null} to the method is a no-op unless the factory\n     * was already set.\n     * <p>If there is a security manager, this method first calls\n     * the security manager's {@code checkSetFactory} method\n     * to ensure the operation is allowed.\n     * This could result in a SecurityException.\n     *\n     * @param      fac   the desired factory.\n     * @exception  IOException  if an I/O error occurs when setting the\n     *               socket factory.\n     * @exception  SocketException  if the factory is already defined.\n     * @exception  SecurityException  if a security manager exists and its\n     *             {@code checkSetFactory} method doesn't allow the operation.\n     * @see        java.net.SocketImplFactory#createSocketImpl()\n     * @see        SecurityManager#checkSetFactory\n     ",
    "links" : [ ]
  }, {
    "name" : "public void setPerformancePreferences(int connectionTime, int latency, int bandwidth)",
    "returnType" : "void",
    "comment" : "\n     * Sets performance preferences for this socket.\n     *\n     * <p> Sockets use the TCP/IP protocol by default.  Some implementations\n     * may offer alternative protocols which have different performance\n     * characteristics than TCP/IP.  This method allows the application to\n     * express its own preferences as to how these tradeoffs should be made\n     * when the implementation chooses from the available protocols.\n     *\n     * <p> Performance preferences are described by three integers\n     * whose values indicate the relative importance of short connection time,\n     * low latency, and high bandwidth.  The absolute values of the integers\n     * are irrelevant; in order to choose a protocol the values are simply\n     * compared, with larger values indicating stronger preferences. Negative\n     * values represent a lower priority than positive values. If the\n     * application prefers short connection time over both low latency and high\n     * bandwidth, for example, then it could invoke this method with the values\n     * {@code (1, 0, 0)}.  If the application prefers high bandwidth above low\n     * latency, and low latency above short connection time, then it could\n     * invoke this method with the values {@code (0, 1, 2)}.\n     *\n     * <p> Invoking this method after this socket has been connected\n     * will have no effect.\n     *\n     * @param  connectionTime\n     *         An {@code int} expressing the relative importance of a short\n     *         connection time\n     *\n     * @param  latency\n     *         An {@code int} expressing the relative importance of low\n     *         latency\n     *\n     * @param  bandwidth\n     *         An {@code int} expressing the relative importance of high\n     *         bandwidth\n     *\n     * @since 1.5\n     ",
    "links" : [ ]
  }, {
    "name" : "public Socket setOption(SocketOption<T> name, T value) throws IOException",
    "returnType" : "Socket",
    "comment" : "\n     * Sets the value of a socket option.\n     *\n     * @param <T> The type of the socket option value\n     * @param name The socket option\n     * @param value The value of the socket option. A value of {@code null}\n     *              may be valid for some options.\n     * @return this Socket\n     *\n     * @throws UnsupportedOperationException if the socket does not support\n     *         the option.\n     *\n     * @throws IllegalArgumentException if the value is not valid for\n     *         the option.\n     *\n     * @throws IOException if an I/O error occurs, or if the socket is closed.\n     *\n     * @throws NullPointerException if name is {@code null}\n     *\n     * @throws SecurityException if a security manager is set and if the socket\n     *         option requires a security permission and if the caller does\n     *         not have the required permission.\n     *         {@link java.net.StandardSocketOptions StandardSocketOptions}\n     *         do not require any security permission.\n     *\n     * @since 9\n     ",
    "links" : [ "java.net.StandardSocketOptions" ]
  }, {
    "name" : "public T getOption(SocketOption<T> name) throws IOException",
    "returnType" : "T",
    "comment" : "\n     * Returns the value of a socket option.\n     *\n     * @param <T> The type of the socket option value\n     * @param name The socket option\n     *\n     * @return The value of the socket option.\n     *\n     * @throws UnsupportedOperationException if the socket does not support\n     *         the option.\n     *\n     * @throws IOException if an I/O error occurs, or if the socket is closed.\n     *\n     * @throws NullPointerException if name is {@code null}\n     *\n     * @throws SecurityException if a security manager is set and if the socket\n     *         option requires a security permission and if the caller does\n     *         not have the required permission.\n     *         {@link java.net.StandardSocketOptions StandardSocketOptions}\n     *         do not require any security permission.\n     *\n     * @since 9\n     ",
    "links" : [ "java.net.StandardSocketOptions" ]
  }, {
    "name" : "public Set<SocketOption<?>> supportedOptions()",
    "returnType" : "Set<SocketOption<?>>",
    "comment" : "\n     * Returns a set of the socket options supported by this socket.\n     *\n     * This method will continue to return the set of options even after\n     * the socket has been closed.\n     *\n     * @return A set of the socket options supported by this socket. This set\n     *         may be empty if the socket's SocketImpl cannot be created.\n     *\n     * @since 9\n     ",
    "links" : [ ]
  }, {
    "name" : "public FileDescriptor getFileDescriptor$()",
    "returnType" : "FileDescriptor",
    "comment" : "\n     * Gets socket's underlying {@link FileDescriptor}.\n     *\n     * @hide internal use only\n     *\n     * @return socket's underlying {@link FileDescriptor}.\n     ",
    "links" : [ "java.io.FileDescriptor" ]
  } ],
  "methodNames" : [ "private static Void checkPermission(SocketImpl impl)", "private static InetAddress[] nonNullAddress(InetAddress address)", " void createImpl(boolean stream) throws SocketException", "private void checkOldImpl()", " void setImpl()", " SocketImpl getImpl() throws SocketException", "public void connect(SocketAddress endpoint) throws IOException", "public void connect(SocketAddress endpoint, int timeout) throws IOException", "public void bind(SocketAddress bindpoint) throws IOException", "private void checkAddress(InetAddress addr, String op)", " final void postAccept()", " void setCreated()", " void setBound()", " void setConnected()", "public InetAddress getInetAddress()", "public InetAddress getLocalAddress()", "public int getPort()", "public int getLocalPort()", "public SocketAddress getRemoteSocketAddress()", "public SocketAddress getLocalSocketAddress()", "public SocketChannel getChannel()", "public InputStream getInputStream() throws IOException", "public OutputStream getOutputStream() throws IOException", "public void setTcpNoDelay(boolean on) throws SocketException", "public boolean getTcpNoDelay() throws SocketException", "public void setSoLinger(boolean on, int linger) throws SocketException", "public int getSoLinger() throws SocketException", "public void sendUrgentData(int data) throws IOException", "public void setOOBInline(boolean on) throws SocketException", "public boolean getOOBInline() throws SocketException", "public synchronized void setSoTimeout(int timeout) throws SocketException", "public synchronized int getSoTimeout() throws SocketException", "public synchronized void setSendBufferSize(int size) throws SocketException", "public synchronized int getSendBufferSize() throws SocketException", "public synchronized void setReceiveBufferSize(int size) throws SocketException", "public synchronized int getReceiveBufferSize() throws SocketException", "public void setKeepAlive(boolean on) throws SocketException", "public boolean getKeepAlive() throws SocketException", "public void setTrafficClass(int tc) throws SocketException", "public int getTrafficClass() throws SocketException", "public void setReuseAddress(boolean on) throws SocketException", "public boolean getReuseAddress() throws SocketException", "public synchronized void close() throws IOException", "public void shutdownInput() throws IOException", "public void shutdownOutput() throws IOException", "public String toString()", "public boolean isConnected()", "public boolean isBound()", "public boolean isClosed()", "public boolean isInputShutdown()", "public boolean isOutputShutdown()", "public static synchronized void setSocketImplFactory(SocketImplFactory fac) throws IOException", "public void setPerformancePreferences(int connectionTime, int latency, int bandwidth)", "public Socket setOption(SocketOption<T> name, T value) throws IOException", "public T getOption(SocketOption<T> name) throws IOException", "public Set<SocketOption<?>> supportedOptions()", "public FileDescriptor getFileDescriptor$()" ],
  "variableNames" : [ "created", "bound", "connected", "closed", "closeLock", "shutIn", "shutOut", "impl", "oldImpl", "factory", "options", "optionsSet" ]
}