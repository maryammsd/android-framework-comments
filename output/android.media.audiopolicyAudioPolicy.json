{
  "filePath" : "/home/maryam/clearblue/files/android-source-30/android/media/audiopolicy/AudioPolicy.java",
  "packageName" : "android.media.audiopolicy",
  "className" : "AudioPolicy",
  "comment" : "\n * @hide\n * AudioPolicy provides access to the management of audio routing and audio focus.\n ",
  "variables" : [ {
    "name" : "TAG",
    "type" : "String",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "DEBUG",
    "type" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mLock",
    "type" : "Object",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "POLICY_STATUS_UNREGISTERED",
    "type" : "int",
    "comment" : "\n     * The status of an audio policy that is valid but cannot be used because it is not registered.\n     ",
    "links" : [ ]
  }, {
    "name" : "POLICY_STATUS_REGISTERED",
    "type" : "int",
    "comment" : "\n     * The status of an audio policy that is valid, successfully registered and thus active.\n     ",
    "links" : [ ]
  }, {
    "name" : "mStatus",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mRegistrationId",
    "type" : "String",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mStatusListener",
    "type" : "AudioPolicyStatusListener",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mIsFocusPolicy",
    "type" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mIsTestFocusPolicy",
    "type" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mInjectors",
    "type" : "ArrayList<WeakReference<AudioTrack>>",
    "comment" : "\n     * The list of AudioTrack instances created to inject audio into the associated mixes\n     * Lazy initialization in {@link #createAudioTrackSource(AudioMix)}\n     ",
    "links" : [ "#createAudioTrackSource" ]
  }, {
    "name" : "mCaptors",
    "type" : "ArrayList<WeakReference<AudioRecord>>",
    "comment" : "\n     * The list AudioRecord instances created to capture audio from the associated mixes\n     * Lazy initialization in {@link #createAudioRecordSink(AudioMix)}\n     ",
    "links" : [ "#createAudioRecordSink" ]
  }, {
    "name" : "FOCUS_POLICY_DUCKING_IN_APP",
    "type" : "int",
    "comment" : "\n     * The behavior of a policy with regards to audio focus where it relies on the application\n     * to do the ducking, the is the legacy and default behavior.\n     ",
    "links" : [ ]
  }, {
    "name" : "FOCUS_POLICY_DUCKING_DEFAULT",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "FOCUS_POLICY_DUCKING_IN_POLICY",
    "type" : "int",
    "comment" : "\n     * The behavior of a policy with regards to audio focus where it handles ducking instead\n     * of the application losing focus and being signaled it can duck (as communicated by\n     * {@link android.media.AudioManager#AUDIOFOCUS_LOSS_TRANSIENT_CAN_DUCK}).\n     * <br>Can only be used after having set a listener with\n     * {@link AudioPolicy#setAudioPolicyFocusListener(AudioPolicyFocusListener)}.\n     ",
    "links" : [ "android.media.AudioManager#AUDIOFOCUS_LOSS_TRANSIENT_CAN_DUCK", "AudioPolicy#setAudioPolicyFocusListener" ]
  }, {
    "name" : "mFocusListener",
    "type" : "AudioPolicyFocusListener",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mVolCb",
    "type" : "AudioPolicyVolumeCallback",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mContext",
    "type" : "Context",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mConfig",
    "type" : "AudioPolicyConfig",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mProjection",
    "type" : "MediaProjection",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mPolicyCb",
    "type" : "IAudioPolicyCallback",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mEventHandler",
    "type" : "EventHandler",
    "comment" : " Event handling",
    "links" : [ ]
  }, {
    "name" : "MSG_POLICY_STATUS_CHANGE",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "MSG_FOCUS_GRANT",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "MSG_FOCUS_LOSS",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "MSG_MIX_STATE_UPDATE",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "MSG_FOCUS_REQUEST",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "MSG_FOCUS_ABANDON",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "MSG_VOL_ADJUST",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "sService",
    "type" : "IAudioService",
    "comment" : "",
    "links" : [ ]
  } ],
  "methods" : [ {
    "name" : "public AudioPolicyConfig getConfig()",
    "returnType" : "AudioPolicyConfig",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "public boolean hasFocusListener()",
    "returnType" : "boolean",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "public boolean isFocusPolicy()",
    "returnType" : "boolean",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "public boolean isTestFocusPolicy()",
    "returnType" : "boolean",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "public boolean isVolumeController()",
    "returnType" : "boolean",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "public MediaProjection getMediaProjection()",
    "returnType" : "MediaProjection",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "public int attachMixes(@NonNull List<AudioMix> mixes)",
    "returnType" : "int",
    "comment" : "\n     * Update the current configuration of the set of audio mixes by adding new ones, while\n     * keeping the policy registered.\n     * This method can only be called on a registered policy.\n     * @param mixes the list of {@link AudioMix} to add\n     * @return {@link AudioManager#SUCCESS} if the change was successful, {@link AudioManager#ERROR}\n     *    otherwise.\n     ",
    "links" : [ "AudioMix", "AudioManager#SUCCESS", "AudioManager#ERROR" ]
  }, {
    "name" : "public int detachMixes(@NonNull List<AudioMix> mixes)",
    "returnType" : "int",
    "comment" : "\n     * Update the current configuration of the set of audio mixes by removing some, while\n     * keeping the policy registered.\n     * This method can only be called on a registered policy.\n     * @param mixes the list of {@link AudioMix} to remove\n     * @return {@link AudioManager#SUCCESS} if the change was successful, {@link AudioManager#ERROR}\n     *    otherwise.\n     ",
    "links" : [ "AudioMix", "AudioManager#SUCCESS", "AudioManager#ERROR" ]
  }, {
    "name" : "public boolean setUidDeviceAffinity(int uid, @NonNull List<AudioDeviceInfo> devices)",
    "returnType" : "boolean",
    "comment" : "\n     * @hide\n     * Configures the audio framework so that all audio streams originating from the given UID\n     * can only come from a set of audio devices.\n     * For this routing to be operational, a number of {@link AudioMix} instances must have been\n     * previously registered on this policy, and routed to a super-set of the given audio devices\n     * with {@link AudioMix.Builder#setDevice(android.media.AudioDeviceInfo)}. Note that having\n     * multiple devices in the list doesn't imply the signals will be duplicated on the different\n     * audio devices, final routing will depend on the {@link AudioAttributes} of the sounds being\n     * played.\n     * @param uid UID of the application to affect.\n     * @param devices list of devices to which the audio stream of the application may be routed.\n     * @return true if the change was successful, false otherwise.\n     ",
    "links" : [ "AudioMix", "AudioMix.Builder#setDevice", "AudioAttributes" ]
  }, {
    "name" : "public boolean removeUidDeviceAffinity(int uid)",
    "returnType" : "boolean",
    "comment" : "\n     * @hide\n     * Removes audio device affinity previously set by\n     * {@link #setUidDeviceAffinity(int, java.util.List)}.\n     * @param uid UID of the application affected.\n     * @return true if the change was successful, false otherwise.\n     ",
    "links" : [ "#setUidDeviceAffinity" ]
  }, {
    "name" : "public boolean removeUserIdDeviceAffinity(@UserIdInt int userId)",
    "returnType" : "boolean",
    "comment" : "\n     * @hide\n     * Removes audio device affinity previously set by\n     * {@link #setUserIdDeviceAffinity(int, java.util.List)}.\n     * @param userId userId of the application affected, as obtained via\n     * {@link UserHandle#getIdentifier}. Not to be confused with application uid.\n     * @return true if the change was successful, false otherwise.\n     ",
    "links" : [ "#setUserIdDeviceAffinity", "UserHandle#getIdentifier" ]
  }, {
    "name" : "public boolean setUserIdDeviceAffinity(@UserIdInt int userId, @NonNull List<AudioDeviceInfo> devices)",
    "returnType" : "boolean",
    "comment" : "\n     * @hide\n     * Configures the audio framework so that all audio streams originating from the given user\n     * can only come from a set of audio devices.\n     * For this routing to be operational, a number of {@link AudioMix} instances must have been\n     * previously registered on this policy, and routed to a super-set of the given audio devices\n     * with {@link AudioMix.Builder#setDevice(android.media.AudioDeviceInfo)}. Note that having\n     * multiple devices in the list doesn't imply the signals will be duplicated on the different\n     * audio devices, final routing will depend on the {@link AudioAttributes} of the sounds being\n     * played.\n     * @param userId userId of the application affected, as obtained via\n     * {@link UserHandle#getIdentifier}. Not to be confused with application uid.\n     * @param devices list of devices to which the audio stream of the application may be routed.\n     * @return true if the change was successful, false otherwise.\n     ",
    "links" : [ "AudioMix", "AudioMix.Builder#setDevice", "AudioAttributes", "UserHandle#getIdentifier" ]
  }, {
    "name" : "public void setRegistration(String regId)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private boolean policyReadyToUse()",
    "returnType" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private boolean isLoopbackRenderPolicy()",
    "returnType" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private int checkCallingOrSelfPermission(String permission)",
    "returnType" : "int",
    "comment" : "\n     * Returns {@link PackageManager#PERMISSION_GRANTED} if the caller has the given permission.\n     ",
    "links" : [ "PackageManager#PERMISSION_GRANTED" ]
  }, {
    "name" : "private void checkMixReadyToUse(AudioMix mix, boolean forTrack) throws IllegalArgumentException",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public int getFocusDuckingBehavior()",
    "returnType" : "int",
    "comment" : "\n     * Returns the current behavior for audio focus-related ducking.\n     * @return {@link #FOCUS_POLICY_DUCKING_IN_APP} or {@link #FOCUS_POLICY_DUCKING_IN_POLICY}\n     ",
    "links" : [ "#FOCUS_POLICY_DUCKING_IN_APP", "#FOCUS_POLICY_DUCKING_IN_POLICY" ]
  }, {
    "name" : "public int setFocusDuckingBehavior(int behavior) throws IllegalArgumentException, IllegalStateException",
    "returnType" : "int",
    "comment" : "\n     * Sets the behavior for audio focus-related ducking.\n     * There must be a focus listener if this policy is to handle ducking.\n     * @param behavior {@link #FOCUS_POLICY_DUCKING_IN_APP} or\n     *     {@link #FOCUS_POLICY_DUCKING_IN_POLICY}\n     * @return {@link AudioManager#SUCCESS} or {@link AudioManager#ERROR} (for instance if there\n     *     is already an audio policy that handles ducking).\n     * @throws IllegalArgumentException\n     * @throws IllegalStateException\n     ",
    "links" : [ "#FOCUS_POLICY_DUCKING_IN_APP", "#FOCUS_POLICY_DUCKING_IN_POLICY", "AudioManager#SUCCESS", "AudioManager#ERROR" ]
  }, {
    "name" : "public AudioRecord createAudioRecordSink(AudioMix mix) throws IllegalArgumentException",
    "returnType" : "AudioRecord",
    "comment" : "\n     * Create an {@link AudioRecord} instance that is associated with the given {@link AudioMix}.\n     * Audio buffers recorded through the created instance will contain the mix of the audio\n     * streams that fed the given mixer.\n     * @param mix a non-null {@link AudioMix} instance whose routing flags was defined with\n     *     {@link AudioMix#ROUTE_FLAG_LOOP_BACK}, previously added to this policy.\n     * @return a new {@link AudioRecord} instance whose data format is the one defined in the\n     *     {@link AudioMix}, or null if this policy was not successfully registered\n     *     with {@link AudioManager#registerAudioPolicy(AudioPolicy)}.\n     * @throws IllegalArgumentException\n     ",
    "links" : [ "AudioRecord", "AudioMix", "AudioMix", "AudioMix#ROUTE_FLAG_LOOP_BACK", "AudioRecord", "AudioMix", "AudioManager#registerAudioPolicy" ]
  }, {
    "name" : "public AudioTrack createAudioTrackSource(AudioMix mix) throws IllegalArgumentException",
    "returnType" : "AudioTrack",
    "comment" : "\n     * Create an {@link AudioTrack} instance that is associated with the given {@link AudioMix}.\n     * Audio buffers played through the created instance will be sent to the given mix\n     * to be recorded through the recording APIs.\n     * @param mix a non-null {@link AudioMix} instance whose routing flags was defined with\n     *     {@link AudioMix#ROUTE_FLAG_LOOP_BACK}, previously added to this policy.\n     * @return a new {@link AudioTrack} instance whose data format is the one defined in the\n     *     {@link AudioMix}, or null if this policy was not successfully registered\n     *     with {@link AudioManager#registerAudioPolicy(AudioPolicy)}.\n     * @throws IllegalArgumentException\n     ",
    "links" : [ "AudioTrack", "AudioMix", "AudioMix", "AudioMix#ROUTE_FLAG_LOOP_BACK", "AudioTrack", "AudioMix", "AudioManager#registerAudioPolicy" ]
  }, {
    "name" : "public void invalidateCaptorsAndInjectors()",
    "returnType" : "void",
    "comment" : "\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public int getStatus()",
    "returnType" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private void onPolicyStatusChange()",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public IAudioPolicyCallback cb()",
    "returnType" : "IAudioPolicyCallback",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "private static String addressForTag(AudioMix mix)",
    "returnType" : "String",
    "comment" : " Utils",
    "links" : [ ]
  }, {
    "name" : "private void sendMsg(int msg)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private void sendMsg(int msg, Object obj, int i)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private static IAudioService getService()",
    "returnType" : "IAudioService",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public String toLogFriendlyString()",
    "returnType" : "String",
    "comment" : "",
    "links" : [ ]
  } ],
  "variableNames" : [ "TAG", "DEBUG", "mLock", "POLICY_STATUS_UNREGISTERED", "POLICY_STATUS_REGISTERED", "mStatus", "mRegistrationId", "mStatusListener", "mIsFocusPolicy", "mIsTestFocusPolicy", "mInjectors", "mCaptors", "FOCUS_POLICY_DUCKING_IN_APP", "FOCUS_POLICY_DUCKING_DEFAULT", "FOCUS_POLICY_DUCKING_IN_POLICY", "mFocusListener", "mVolCb", "mContext", "mConfig", "mProjection", "mPolicyCb", "mEventHandler", "MSG_POLICY_STATUS_CHANGE", "MSG_FOCUS_GRANT", "MSG_FOCUS_LOSS", "MSG_MIX_STATE_UPDATE", "MSG_FOCUS_REQUEST", "MSG_FOCUS_ABANDON", "MSG_VOL_ADJUST", "sService" ],
  "methodNames" : [ "public AudioPolicyConfig getConfig()", "public boolean hasFocusListener()", "public boolean isFocusPolicy()", "public boolean isTestFocusPolicy()", "public boolean isVolumeController()", "public MediaProjection getMediaProjection()", "public int attachMixes(@NonNull List<AudioMix> mixes)", "public int detachMixes(@NonNull List<AudioMix> mixes)", "public boolean setUidDeviceAffinity(int uid, @NonNull List<AudioDeviceInfo> devices)", "public boolean removeUidDeviceAffinity(int uid)", "public boolean removeUserIdDeviceAffinity(@UserIdInt int userId)", "public boolean setUserIdDeviceAffinity(@UserIdInt int userId, @NonNull List<AudioDeviceInfo> devices)", "public void setRegistration(String regId)", "private boolean policyReadyToUse()", "private boolean isLoopbackRenderPolicy()", "private int checkCallingOrSelfPermission(String permission)", "private void checkMixReadyToUse(AudioMix mix, boolean forTrack) throws IllegalArgumentException", "public int getFocusDuckingBehavior()", "public int setFocusDuckingBehavior(int behavior) throws IllegalArgumentException, IllegalStateException", "public AudioRecord createAudioRecordSink(AudioMix mix) throws IllegalArgumentException", "public AudioTrack createAudioTrackSource(AudioMix mix) throws IllegalArgumentException", "public void invalidateCaptorsAndInjectors()", "public int getStatus()", "private void onPolicyStatusChange()", "public IAudioPolicyCallback cb()", "private static String addressForTag(AudioMix mix)", "private void sendMsg(int msg)", "private void sendMsg(int msg, Object obj, int i)", "private static IAudioService getService()", "public String toLogFriendlyString()" ]
}