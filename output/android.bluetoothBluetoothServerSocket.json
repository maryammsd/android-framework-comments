{
  "filePath" : "/home/maryam/clearblue/files/android-source-30/android/bluetooth/BluetoothServerSocket.java",
  "packageName" : "android.bluetooth",
  "className" : "BluetoothServerSocket",
  "comment" : "\n * A listening Bluetooth socket.\n *\n * <p>The interface for Bluetooth Sockets is similar to that of TCP sockets:\n * {@link java.net.Socket} and {@link java.net.ServerSocket}. On the server\n * side, use a {@link BluetoothServerSocket} to create a listening server\n * socket. When a connection is accepted by the {@link BluetoothServerSocket},\n * it will return a new {@link BluetoothSocket} to manage the connection.\n * On the client side, use a single {@link BluetoothSocket} to both initiate\n * an outgoing connection and to manage the connection.\n *\n * <p>For Bluetooth BR/EDR, the most common type of socket is RFCOMM, which is the type supported by\n * the Android APIs. RFCOMM is a connection-oriented, streaming transport over Bluetooth BR/EDR. It\n * is also known as the Serial Port Profile (SPP). To create a listening\n * {@link BluetoothServerSocket} that's ready for incoming Bluetooth BR/EDR connections, use {@link\n * BluetoothAdapter#listenUsingRfcommWithServiceRecord\n * BluetoothAdapter.listenUsingRfcommWithServiceRecord()}.\n *\n * <p>For Bluetooth LE, the socket uses LE Connection-oriented Channel (CoC). LE CoC is a\n * connection-oriented, streaming transport over Bluetooth LE and has a credit-based flow control.\n * Correspondingly, use {@link BluetoothAdapter#listenUsingL2capChannel\n * BluetoothAdapter.listenUsingL2capChannel()} to create a listening {@link BluetoothServerSocket}\n * that's ready for incoming Bluetooth LE CoC connections. For LE CoC, you can use {@link #getPsm()}\n * to get the protocol/service multiplexer (PSM) value that the peer needs to use to connect to your\n * socket.\n *\n * <p> After the listening {@link BluetoothServerSocket} is created, call {@link #accept()} to\n * listen for incoming connection requests. This call will block until a connection is established,\n * at which point, it will return a {@link BluetoothSocket} to manage the connection. Once the\n * {@link BluetoothSocket} is acquired, it's a good idea to call {@link #close()} on the {@link\n * BluetoothServerSocket} when it's no longer needed for accepting\n * connections. Closing the {@link BluetoothServerSocket} will <em>not</em> close the returned\n * {@link BluetoothSocket}.\n *\n * <p>{@link BluetoothServerSocket} is thread\n * safe. In particular, {@link #close} will always immediately abort ongoing\n * operations and close the server socket.\n *\n * <p class=\"note\"><strong>Note:</strong>\n * Requires the {@link android.Manifest.permission#BLUETOOTH} permission.\n *\n * <div class=\"special reference\">\n * <h3>Developer Guides</h3>\n * <p>For more information about using Bluetooth, read the\n * <a href=\"{@docRoot}guide/topics/connectivity/bluetooth.html\">Bluetooth</a> developer guide.</p>\n * </div>\n *\n * {@see BluetoothSocket}\n ",
  "variables" : [ {
    "name" : "TAG",
    "type" : "String",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "DBG",
    "type" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mSocket",
    "type" : "BluetoothSocket",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mHandler",
    "type" : "Handler",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mMessage",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mChannel",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  } ],
  "methods" : [ {
    "name" : "public BluetoothSocket accept() throws IOException",
    "returnType" : "BluetoothSocket",
    "comment" : "\n     * Block until a connection is established.\n     * <p>Returns a connected {@link BluetoothSocket} on successful connection.\n     * <p>Once this call returns, it can be called again to accept subsequent\n     * incoming connections.\n     * <p>{@link #close} can be used to abort this call from another thread.\n     *\n     * @return a connected {@link BluetoothSocket}\n     * @throws IOException on error, for example this call was aborted, or timeout\n     ",
    "links" : [ "BluetoothSocket", "#close", "BluetoothSocket" ]
  }, {
    "name" : "public BluetoothSocket accept(int timeout) throws IOException",
    "returnType" : "BluetoothSocket",
    "comment" : "\n     * Block until a connection is established, with timeout.\n     * <p>Returns a connected {@link BluetoothSocket} on successful connection.\n     * <p>Once this call returns, it can be called again to accept subsequent\n     * incoming connections.\n     * <p>{@link #close} can be used to abort this call from another thread.\n     *\n     * @return a connected {@link BluetoothSocket}\n     * @throws IOException on error, for example this call was aborted, or timeout\n     ",
    "links" : [ "BluetoothSocket", "#close", "BluetoothSocket" ]
  }, {
    "name" : "public void close() throws IOException",
    "returnType" : "void",
    "comment" : "\n     * Immediately close this socket, and release all associated resources.\n     * <p>Causes blocked calls on this socket in other threads to immediately\n     * throw an IOException.\n     * <p>Closing the {@link BluetoothServerSocket} will <em>not</em>\n     * close any {@link BluetoothSocket} received from {@link #accept()}.\n     ",
    "links" : [ "BluetoothServerSocket", "BluetoothSocket", "#accept" ]
  }, {
    "name" : " synchronized void setCloseHandler(Handler handler, int message)",
    "returnType" : "void",
    "comment" : "package",
    "links" : [ ]
  }, {
    "name" : " void setServiceName(String serviceName)",
    "returnType" : "void",
    "comment" : "package",
    "links" : [ ]
  }, {
    "name" : "public int getChannel()",
    "returnType" : "int",
    "comment" : "\n     * Returns the channel on which this socket is bound.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public int getPsm()",
    "returnType" : "int",
    "comment" : "\n     * Returns the assigned dynamic protocol/service multiplexer (PSM) value for the listening L2CAP\n     * Connection-oriented Channel (CoC) server socket. This server socket must be returned by the\n     * {@link BluetoothAdapter#listenUsingL2capChannel()} or {@link\n     * BluetoothAdapter#listenUsingInsecureL2capChannel()}. The returned value is undefined if this\n     * method is called on non-L2CAP server sockets.\n     *\n     * @return the assigned PSM or LE_PSM value depending on transport\n     ",
    "links" : [ "BluetoothAdapter#listenUsingL2capChannel" ]
  }, {
    "name" : " void setChannel(int newChannel)",
    "returnType" : "void",
    "comment" : "package",
    "links" : [ ]
  }, {
    "name" : "public String toString()",
    "returnType" : "String",
    "comment" : "",
    "links" : [ ]
  } ],
  "variableNames" : [ "TAG", "DBG", "mSocket", "mHandler", "mMessage", "mChannel" ],
  "methodNames" : [ "public BluetoothSocket accept() throws IOException", "public BluetoothSocket accept(int timeout) throws IOException", "public void close() throws IOException", " synchronized void setCloseHandler(Handler handler, int message)", " void setServiceName(String serviceName)", "public int getChannel()", "public int getPsm()", " void setChannel(int newChannel)", "public String toString()" ]
}