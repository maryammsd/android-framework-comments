{
  "filePath" : "/home/maryam/clearblue/files/android-source-35/android/crypto/hpke/HpkeSpi.java",
  "packageName" : "android.crypto.hpke",
  "className" : "HpkeSpi",
  "comment" : "\n * Service Provider Interface for HPKE client API classes to communicate with implementations\n * of HPKE as described in RFC 9180.\n * <p>\n * There are no standard Java Cryptography Architecture names or interface classes for HPKE,\n * but instances of this class can be obtained by calling\n * {@code Provider.getService(\"ConscryptHpke\", String SuiteName)} where {@code suiteName}\n * is the name of the HPKE suite, e.g.\n * {@code \"DHKEM_X25519_HKDF_SHA256/HKDF_SHA256/AES_128_GCM\"}.\n ",
  "links" : [ ],
  "variables" : [ ],
  "methods" : [ {
    "name" : " void engineInitSender(@NonNull PublicKey recipientKey, @Nullable byte[] info, @Nullable PrivateKey senderKey, @Nullable byte[] psk, @Nullable byte[] psk_id) throws InvalidKeyException",
    "returnType" : "void",
    "comment" : "\n     * Initialises an HPKE SPI in one of the sender modes described in RFC 9180.\n     * <p>\n     * If {@code psk} and {@code psk_id} are supplied then Pre-Shared Key Authentication\n     * will be used.\n     * <p>\n     * If {@code senderKey} is supplied then Asymmetric Key Authentication will be used.\n     * <p>\n     * If neither is supplied then \"base\" mode (no sender authentication) will be used.\n     * <p>\n     * Note that only base mode is currently supported on Android.\n     * <p>\n     * Public and private keys must be supplied in a format that can be used by the\n     * implementation.  An instance of the {@code \"XDH\"} {@link java.security.KeyFactory} can\n     * be used to translate {@code KeySpecs} or keys from another {@link java.security.Provider}\n     *\n     * @param recipientKey public key of the recipient\n     * @param info application-supplied information, may be null or empty\n     * @param senderKey private key of the sender, for symmetric auth modes only, else null\n     * @param psk pre-shared key, for PSK auth modes only, else null\n     * @param psk_id pre-shared key ID, for PSK auth modes only, else null\n     * @throws InvalidKeyException if recipientKey is null or an unsupported key format\n     * @throws UnsupportedOperationException if mode is not a supported HPKE mode\n     * @throws IllegalStateException if this SPI has already been initialised\n     ",
    "links" : [ "java.security.KeyFactory", "java.security.Provider" ]
  }, {
    "name" : " void engineInitSenderWithSeed(@NonNull PublicKey recipientKey, @Nullable byte[] info, @Nullable PrivateKey senderKey, @Nullable byte[] psk, @Nullable byte[] psk_id, @NonNull byte[] sKe) throws InvalidKeyException",
    "returnType" : "void",
    "comment" : "\n     * Initialises an HPKE SPI in one of the sender modes described in RFC 9180 with\n     * a predefined random seed to allow testing against known test vectors.\n     * <p>\n     * This mode provides absolutely no security and should only be used for testing\n     * purposes.\n     * <p>\n     * If {@code psk} and {@code psk_id} are supplied then Pre-Shared Key Authentication\n     * will be used.\n     * <p>\n     * If {@code senderKey} is supplied then Asymmetric Key Authentication will be used.\n     * <p>\n     * If neither is supplied then \"base\" mode (no sender authentication) will be used.\n     * <p>\n     * Note that only base mode is currently supported on Android.\n     * <p>\n     * Public and private keys must be supplied in a format that can be used by the\n     * implementation.  An instance of the {@code \"XDH\"} {@link java.security.KeyFactory} can\n     * be used to translate {@code KeySpecs} or keys from another {@link java.security.Provider}\n     *\n     *\n     * @param recipientKey public key of the recipient\n     * @param info application-supplied information, may be null or empty\n     * @param senderKey private key of the sender, for symmetric auth modes only, else null\n     * @param psk pre-shared key, for PSK auth modes only, else null\n     * @param psk_id pre-shared key ID, for PSK auth modes only, else null\n     * @param sKe Predetermined random seed, should only be usesd  for validation against\n     *            known test vectors\n     * @throws InvalidKeyException if recipientKey is null or an unsupported key format or senderKey\n     *            is an unsupported key format\n     * @throws UnsupportedOperationException if mode is not a supported HPKE mode\n     * @throws IllegalStateException if this SPI has already been initialised\n     ",
    "links" : [ "java.security.KeyFactory", "java.security.Provider" ]
  }, {
    "name" : " void engineInitRecipient(@NonNull byte[] encapsulated, @NonNull PrivateKey recipientKey, @Nullable byte[] info, @Nullable PublicKey senderKey, @Nullable byte[] psk, @Nullable byte[] psk_id) throws InvalidKeyException",
    "returnType" : "void",
    "comment" : "\n     * Initialises an HPKE SPI in one of the sender modes described in RFC 9180.\n     * <p>\n     * If {@code psk} and {@code psk_id} are supplied then Pre-Shared Key Authentication\n     * will be used.\n     * <p>\n     * If {@code senderKey} is supplied then Asymmetric Key Authentication will be used.\n     * <p>\n     * If neither is supplied then \"base\" mode (no sender authentication) will be used.\n     * <p>\n     * Note that only base mode is currently supported on Android.\n     * <p>\n     * Public and private keys must be supplied in a format that can be used by the\n     * implementation.  An instance of the {@code \"XDH\"} {@link java.security.KeyFactory} can\n     * be used to translate {@code KeySpecs} or keys from another {@link java.security.Provider}\n     *\n     * @param encapsulated encapsulated ephemeral key from a sender\n     * @param recipientKey private key of the recipient\n     * @param info application-supplied information, may be null or empty\n     * @param senderKey public key of sender, for asymmetric auth modes only, else null\n     * @param psk pre-shared key, for PSK auth modes only, else null\n     * @param psk_id pre-shared key ID, for PSK auth modes only, else null\n     * @throws InvalidKeyException if recipientKey is null or an unsupported key format or senderKey\n     *         is an unsupported key format\n     * @throws UnsupportedOperationException if mode is not a supported HPKE mode\n     * @throws IllegalStateException if this SPI has already been initialised\n     ",
    "links" : [ "java.security.KeyFactory", "java.security.Provider" ]
  }, {
    "name" : " byte[] engineSeal(@NonNull byte[] plaintext, @Nullable byte[] aad)",
    "returnType" : "byte[]",
    "comment" : "\n     * Seals a message, using the internal key schedule maintained by an HPKE sender SPI.\n     *\n     * @param plaintext the plaintext\n     * @param aad optional associated data, may be null or empty\n     * @return the ciphertext\n     * @throws NullPointerException if the plaintext is null\n     * @throws IllegalStateException if this SPI has not been initialised or if it was initialised\n     *         as a recipient\n     ",
    "links" : [ ]
  }, {
    "name" : " byte[] engineOpen(@NonNull byte[] ciphertext, @Nullable byte[] aad) throws GeneralSecurityException",
    "returnType" : "byte[]",
    "comment" : "\n     * Opens a message, using the internal key schedule maintained by an HPKE recipient SPI.\n     *\n     * @param ciphertext the ciphertext\n     * @param aad optional associated data, may be null or empty\n     * @return the plaintext\n     * @throws IllegalStateException if this SPI has not been initialised or if it was initialised\n     *         as a sender\n     * @throws GeneralSecurityException on decryption failures\n     ",
    "links" : [ ]
  }, {
    "name" : " byte[] engineExport(int length, @Nullable byte[] context)",
    "returnType" : "byte[]",
    "comment" : "\n     * Exports secret key material from this SPI as described in RFC 9180.\n     *\n     * @param length  expected output length\n     * @param context optional context string, may be null or empty\n     * @return exported value\n     * @throws IllegalArgumentException if the length is not valid for the KDF in use\n     * @throws IllegalStateException if this SPI has not been initialised\n     *\n     ",
    "links" : [ ]
  }, {
    "name" : " byte[] getEncapsulated()",
    "returnType" : "byte[]",
    "comment" : "\n     * Returns the encapsulated key material for an HPKE sender.\n     *\n     * @return the key material\n     * @throws IllegalStateException if this SPI has not been initialised or if it was initialised\n     *         as a recipient\n     ",
    "links" : [ ]
  } ],
  "methodNames" : [ " void engineInitSender(@NonNull PublicKey recipientKey, @Nullable byte[] info, @Nullable PrivateKey senderKey, @Nullable byte[] psk, @Nullable byte[] psk_id) throws InvalidKeyException", " void engineInitSenderWithSeed(@NonNull PublicKey recipientKey, @Nullable byte[] info, @Nullable PrivateKey senderKey, @Nullable byte[] psk, @Nullable byte[] psk_id, @NonNull byte[] sKe) throws InvalidKeyException", " void engineInitRecipient(@NonNull byte[] encapsulated, @NonNull PrivateKey recipientKey, @Nullable byte[] info, @Nullable PublicKey senderKey, @Nullable byte[] psk, @Nullable byte[] psk_id) throws InvalidKeyException", " byte[] engineSeal(@NonNull byte[] plaintext, @Nullable byte[] aad)", " byte[] engineOpen(@NonNull byte[] ciphertext, @Nullable byte[] aad) throws GeneralSecurityException", " byte[] engineExport(int length, @Nullable byte[] context)", " byte[] getEncapsulated()" ],
  "variableNames" : [ ]
}