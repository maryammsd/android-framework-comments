{
  "filePath" : "/home/maryam/clearblue/files/android-source-30/android/media/MediaPlayer.java",
  "packageName" : "android.media",
  "className" : "MediaPlayer",
  "comment" : "\n * MediaPlayer class can be used to control playback\n * of audio/video files and streams. An example on how to use the methods in\n * this class can be found in {@link android.widget.VideoView}.\n *\n * <p>MediaPlayer is not thread-safe. Creation of and all access to player instances\n * should be on the same thread. If registering <a href=\"#Callbacks\">callbacks</a>,\n * the thread must have a Looper.\n *\n * <p>Topics covered here are:\n * <ol>\n * <li><a href=\"#StateDiagram\">State Diagram</a>\n * <li><a href=\"#Valid_and_Invalid_States\">Valid and Invalid States</a>\n * <li><a href=\"#Permissions\">Permissions</a>\n * <li><a href=\"#Callbacks\">Register informational and error callbacks</a>\n * </ol>\n *\n * <div class=\"special reference\">\n * <h3>Developer Guides</h3>\n * <p>For more information about how to use MediaPlayer, read the\n * <a href=\"{@docRoot}guide/topics/media/mediaplayer.html\">Media Playback</a> developer guide.</p>\n * </div>\n *\n * <a name=\"StateDiagram\"></a>\n * <h3>State Diagram</h3>\n *\n * <p>Playback control of audio/video files and streams is managed as a state\n * machine. The following diagram shows the life cycle and the states of a\n * MediaPlayer object driven by the supported playback control operations.\n * The ovals represent the states a MediaPlayer object may reside\n * in. The arcs represent the playback control operations that drive the object\n * state transition. There are two types of arcs. The arcs with a single arrow\n * head represent synchronous method calls, while those with\n * a double arrow head represent asynchronous method calls.</p>\n *\n * <p><img src=\"../../../images/mediaplayer_state_diagram.gif\"\n *         alt=\"MediaPlayer State diagram\"\n *         border=\"0\" /></p>\n *\n * <p>From this state diagram, one can see that a MediaPlayer object has the\n *    following states:</p>\n * <ul>\n *     <li>When a MediaPlayer object is just created using <code>new</code> or\n *         after {@link #reset()} is called, it is in the <em>Idle</em> state; and after\n *         {@link #release()} is called, it is in the <em>End</em> state. Between these\n *         two states is the life cycle of the MediaPlayer object.\n *         <ul>\n *         <li>There is a subtle but important difference between a newly constructed\n *         MediaPlayer object and the MediaPlayer object after {@link #reset()}\n *         is called. It is a programming error to invoke methods such\n *         as {@link #getCurrentPosition()},\n *         {@link #getDuration()}, {@link #getVideoHeight()},\n *         {@link #getVideoWidth()}, {@link #setAudioAttributes(AudioAttributes)},\n *         {@link #setLooping(boolean)},\n *         {@link #setVolume(float, float)}, {@link #pause()}, {@link #start()},\n *         {@link #stop()}, {@link #seekTo(long, int)}, {@link #prepare()} or\n *         {@link #prepareAsync()} in the <em>Idle</em> state for both cases. If any of these\n *         methods is called right after a MediaPlayer object is constructed,\n *         the user supplied callback method OnErrorListener.onError() won't be\n *         called by the internal player engine and the object state remains\n *         unchanged; but if these methods are called right after {@link #reset()},\n *         the user supplied callback method OnErrorListener.onError() will be\n *         invoked by the internal player engine and the object will be\n *         transfered to the <em>Error</em> state. </li>\n *         <li>It is also recommended that once\n *         a MediaPlayer object is no longer being used, call {@link #release()} immediately\n *         so that resources used by the internal player engine associated with the\n *         MediaPlayer object can be released immediately. Resource may include\n *         singleton resources such as hardware acceleration components and\n *         failure to call {@link #release()} may cause subsequent instances of\n *         MediaPlayer objects to fallback to software implementations or fail\n *         altogether. Once the MediaPlayer\n *         object is in the <em>End</em> state, it can no longer be used and\n *         there is no way to bring it back to any other state. </li>\n *         <li>Furthermore,\n *         the MediaPlayer objects created using <code>new</code> is in the\n *         <em>Idle</em> state, while those created with one\n *         of the overloaded convenient <code>create</code> methods are <em>NOT</em>\n *         in the <em>Idle</em> state. In fact, the objects are in the <em>Prepared</em>\n *         state if the creation using <code>create</code> method is successful.\n *         </li>\n *         </ul>\n *         </li>\n *     <li>In general, some playback control operation may fail due to various\n *         reasons, such as unsupported audio/video format, poorly interleaved\n *         audio/video, resolution too high, streaming timeout, and the like.\n *         Thus, error reporting and recovery is an important concern under\n *         these circumstances. Sometimes, due to programming errors, invoking a playback\n *         control operation in an invalid state may also occur. Under all these\n *         error conditions, the internal player engine invokes a user supplied\n *         OnErrorListener.onError() method if an OnErrorListener has been\n *         registered beforehand via\n *         {@link #setOnErrorListener(android.media.MediaPlayer.OnErrorListener)}.\n *         <ul>\n *         <li>It is important to note that once an error occurs, the\n *         MediaPlayer object enters the <em>Error</em> state (except as noted\n *         above), even if an error listener has not been registered by the application.</li>\n *         <li>In order to reuse a MediaPlayer object that is in the <em>\n *         Error</em> state and recover from the error,\n *         {@link #reset()} can be called to restore the object to its <em>Idle</em>\n *         state.</li>\n *         <li>It is good programming practice to have your application\n *         register a OnErrorListener to look out for error notifications from\n *         the internal player engine.</li>\n *         <li>IllegalStateException is\n *         thrown to prevent programming errors such as calling {@link #prepare()},\n *         {@link #prepareAsync()}, or one of the overloaded <code>setDataSource\n *         </code> methods in an invalid state. </li>\n *         </ul>\n *         </li>\n *     <li>Calling\n *         {@link #setDataSource(FileDescriptor)}, or\n *         {@link #setDataSource(String)}, or\n *         {@link #setDataSource(Context, Uri)}, or\n *         {@link #setDataSource(FileDescriptor, long, long)}, or\n *         {@link #setDataSource(MediaDataSource)} transfers a\n *         MediaPlayer object in the <em>Idle</em> state to the\n *         <em>Initialized</em> state.\n *         <ul>\n *         <li>An IllegalStateException is thrown if\n *         setDataSource() is called in any other state.</li>\n *         <li>It is good programming\n *         practice to always look out for <code>IllegalArgumentException</code>\n *         and <code>IOException</code> that may be thrown from the overloaded\n *         <code>setDataSource</code> methods.</li>\n *         </ul>\n *         </li>\n *     <li>A MediaPlayer object must first enter the <em>Prepared</em> state\n *         before playback can be started.\n *         <ul>\n *         <li>There are two ways (synchronous vs.\n *         asynchronous) that the <em>Prepared</em> state can be reached:\n *         either a call to {@link #prepare()} (synchronous) which\n *         transfers the object to the <em>Prepared</em> state once the method call\n *         returns, or a call to {@link #prepareAsync()} (asynchronous) which\n *         first transfers the object to the <em>Preparing</em> state after the\n *         call returns (which occurs almost right away) while the internal\n *         player engine continues working on the rest of preparation work\n *         until the preparation work completes. When the preparation completes or when {@link #prepare()} call returns,\n *         the internal player engine then calls a user supplied callback method,\n *         onPrepared() of the OnPreparedListener interface, if an\n *         OnPreparedListener is registered beforehand via {@link\n *         #setOnPreparedListener(android.media.MediaPlayer.OnPreparedListener)}.</li>\n *         <li>It is important to note that\n *         the <em>Preparing</em> state is a transient state, and the behavior\n *         of calling any method with side effect while a MediaPlayer object is\n *         in the <em>Preparing</em> state is undefined.</li>\n *         <li>An IllegalStateException is\n *         thrown if {@link #prepare()} or {@link #prepareAsync()} is called in\n *         any other state.</li>\n *         <li>While in the <em>Prepared</em> state, properties\n *         such as audio/sound volume, screenOnWhilePlaying, looping can be\n *         adjusted by invoking the corresponding set methods.</li>\n *         </ul>\n *         </li>\n *     <li>To start the playback, {@link #start()} must be called. After\n *         {@link #start()} returns successfully, the MediaPlayer object is in the\n *         <em>Started</em> state. {@link #isPlaying()} can be called to test\n *         whether the MediaPlayer object is in the <em>Started</em> state.\n *         <ul>\n *         <li>While in the <em>Started</em> state, the internal player engine calls\n *         a user supplied OnBufferingUpdateListener.onBufferingUpdate() callback\n *         method if a OnBufferingUpdateListener has been registered beforehand\n *         via {@link #setOnBufferingUpdateListener(OnBufferingUpdateListener)}.\n *         This callback allows applications to keep track of the buffering status\n *         while streaming audio/video.</li>\n *         <li>Calling {@link #start()} has no effect\n *         on a MediaPlayer object that is already in the <em>Started</em> state.</li>\n *         </ul>\n *         </li>\n *     <li>Playback can be paused and stopped, and the current playback position\n *         can be adjusted. Playback can be paused via {@link #pause()}. When the call to\n *         {@link #pause()} returns, the MediaPlayer object enters the\n *         <em>Paused</em> state. Note that the transition from the <em>Started</em>\n *         state to the <em>Paused</em> state and vice versa happens\n *         asynchronously in the player engine. It may take some time before\n *         the state is updated in calls to {@link #isPlaying()}, and it can be\n *         a number of seconds in the case of streamed content.\n *         <ul>\n *         <li>Calling {@link #start()} to resume playback for a paused\n *         MediaPlayer object, and the resumed playback\n *         position is the same as where it was paused. When the call to\n *         {@link #start()} returns, the paused MediaPlayer object goes back to\n *         the <em>Started</em> state.</li>\n *         <li>Calling {@link #pause()} has no effect on\n *         a MediaPlayer object that is already in the <em>Paused</em> state.</li>\n *         </ul>\n *         </li>\n *     <li>Calling  {@link #stop()} stops playback and causes a\n *         MediaPlayer in the <em>Started</em>, <em>Paused</em>, <em>Prepared\n *         </em> or <em>PlaybackCompleted</em> state to enter the\n *         <em>Stopped</em> state.\n *         <ul>\n *         <li>Once in the <em>Stopped</em> state, playback cannot be started\n *         until {@link #prepare()} or {@link #prepareAsync()} are called to set\n *         the MediaPlayer object to the <em>Prepared</em> state again.</li>\n *         <li>Calling {@link #stop()} has no effect on a MediaPlayer\n *         object that is already in the <em>Stopped</em> state.</li>\n *         </ul>\n *         </li>\n *     <li>The playback position can be adjusted with a call to\n *         {@link #seekTo(long, int)}.\n *         <ul>\n *         <li>Although the asynchronuous {@link #seekTo(long, int)}\n *         call returns right away, the actual seek operation may take a while to\n *         finish, especially for audio/video being streamed. When the actual\n *         seek operation completes, the internal player engine calls a user\n *         supplied OnSeekComplete.onSeekComplete() if an OnSeekCompleteListener\n *         has been registered beforehand via\n *         {@link #setOnSeekCompleteListener(OnSeekCompleteListener)}.</li>\n *         <li>Please\n *         note that {@link #seekTo(long, int)} can also be called in the other states,\n *         such as <em>Prepared</em>, <em>Paused</em> and <em>PlaybackCompleted\n *         </em> state. When {@link #seekTo(long, int)} is called in those states,\n *         one video frame will be displayed if the stream has video and the requested\n *         position is valid.\n *         </li>\n *         <li>Furthermore, the actual current playback position\n *         can be retrieved with a call to {@link #getCurrentPosition()}, which\n *         is helpful for applications such as a Music player that need to keep\n *         track of the playback progress.</li>\n *         </ul>\n *         </li>\n *     <li>When the playback reaches the end of stream, the playback completes.\n *         <ul>\n *         <li>If the looping mode was being set to <var>true</var> with\n *         {@link #setLooping(boolean)}, the MediaPlayer object shall remain in\n *         the <em>Started</em> state.</li>\n *         <li>If the looping mode was set to <var>false\n *         </var>, the player engine calls a user supplied callback method,\n *         OnCompletion.onCompletion(), if a OnCompletionListener is registered\n *         beforehand via {@link #setOnCompletionListener(OnCompletionListener)}.\n *         The invoke of the callback signals that the object is now in the <em>\n *         PlaybackCompleted</em> state.</li>\n *         <li>While in the <em>PlaybackCompleted</em>\n *         state, calling {@link #start()} can restart the playback from the\n *         beginning of the audio/video source.</li>\n * </ul>\n *\n *\n * <a name=\"Valid_and_Invalid_States\"></a>\n * <h3>Valid and invalid states</h3>\n *\n * <table border=\"0\" cellspacing=\"0\" cellpadding=\"0\">\n * <tr><td>Method Name </p></td>\n *     <td>Valid States </p></td>\n *     <td>Invalid States </p></td>\n *     <td>Comments </p></td></tr>\n * <tr><td>attachAuxEffect </p></td>\n *     <td>{Initialized, Prepared, Started, Paused, Stopped, PlaybackCompleted} </p></td>\n *     <td>{Idle, Error} </p></td>\n *     <td>This method must be called after setDataSource.\n *     Calling it does not change the object state. </p></td></tr>\n * <tr><td>getAudioSessionId </p></td>\n *     <td>any </p></td>\n *     <td>{} </p></td>\n *     <td>This method can be called in any state and calling it does not change\n *         the object state. </p></td></tr>\n * <tr><td>getCurrentPosition </p></td>\n *     <td>{Idle, Initialized, Prepared, Started, Paused, Stopped,\n *         PlaybackCompleted} </p></td>\n *     <td>{Error}</p></td>\n *     <td>Successful invoke of this method in a valid state does not change the\n *         state. Calling this method in an invalid state transfers the object\n *         to the <em>Error</em> state. </p></td></tr>\n * <tr><td>getDuration </p></td>\n *     <td>{Prepared, Started, Paused, Stopped, PlaybackCompleted} </p></td>\n *     <td>{Idle, Initialized, Error} </p></td>\n *     <td>Successful invoke of this method in a valid state does not change the\n *         state. Calling this method in an invalid state transfers the object\n *         to the <em>Error</em> state. </p></td></tr>\n * <tr><td>getVideoHeight </p></td>\n *     <td>{Idle, Initialized, Prepared, Started, Paused, Stopped,\n *         PlaybackCompleted}</p></td>\n *     <td>{Error}</p></td>\n *     <td>Successful invoke of this method in a valid state does not change the\n *         state. Calling this method in an invalid state transfers the object\n *         to the <em>Error</em> state.  </p></td></tr>\n * <tr><td>getVideoWidth </p></td>\n *     <td>{Idle, Initialized, Prepared, Started, Paused, Stopped,\n *         PlaybackCompleted}</p></td>\n *     <td>{Error}</p></td>\n *     <td>Successful invoke of this method in a valid state does not change\n *         the state. Calling this method in an invalid state transfers the\n *         object to the <em>Error</em> state. </p></td></tr>\n * <tr><td>isPlaying </p></td>\n *     <td>{Idle, Initialized, Prepared, Started, Paused, Stopped,\n *          PlaybackCompleted}</p></td>\n *     <td>{Error}</p></td>\n *     <td>Successful invoke of this method in a valid state does not change\n *         the state. Calling this method in an invalid state transfers the\n *         object to the <em>Error</em> state. </p></td></tr>\n * <tr><td>pause </p></td>\n *     <td>{Started, Paused, PlaybackCompleted}</p></td>\n *     <td>{Idle, Initialized, Prepared, Stopped, Error}</p></td>\n *     <td>Successful invoke of this method in a valid state transfers the\n *         object to the <em>Paused</em> state. Calling this method in an\n *         invalid state transfers the object to the <em>Error</em> state.</p></td></tr>\n * <tr><td>prepare </p></td>\n *     <td>{Initialized, Stopped} </p></td>\n *     <td>{Idle, Prepared, Started, Paused, PlaybackCompleted, Error} </p></td>\n *     <td>Successful invoke of this method in a valid state transfers the\n *         object to the <em>Prepared</em> state. Calling this method in an\n *         invalid state throws an IllegalStateException.</p></td></tr>\n * <tr><td>prepareAsync </p></td>\n *     <td>{Initialized, Stopped} </p></td>\n *     <td>{Idle, Prepared, Started, Paused, PlaybackCompleted, Error} </p></td>\n *     <td>Successful invoke of this method in a valid state transfers the\n *         object to the <em>Preparing</em> state. Calling this method in an\n *         invalid state throws an IllegalStateException.</p></td></tr>\n * <tr><td>release </p></td>\n *     <td>any </p></td>\n *     <td>{} </p></td>\n *     <td>After {@link #release()}, the object is no longer available. </p></td></tr>\n * <tr><td>reset </p></td>\n *     <td>{Idle, Initialized, Prepared, Started, Paused, Stopped,\n *         PlaybackCompleted, Error}</p></td>\n *     <td>{}</p></td>\n *     <td>After {@link #reset()}, the object is like being just created.</p></td></tr>\n * <tr><td>seekTo </p></td>\n *     <td>{Prepared, Started, Paused, PlaybackCompleted} </p></td>\n *     <td>{Idle, Initialized, Stopped, Error}</p></td>\n *     <td>Successful invoke of this method in a valid state does not change\n *         the state. Calling this method in an invalid state transfers the\n *         object to the <em>Error</em> state. </p></td></tr>\n * <tr><td>setAudioAttributes </p></td>\n *     <td>{Idle, Initialized, Stopped, Prepared, Started, Paused,\n *          PlaybackCompleted}</p></td>\n *     <td>{Error}</p></td>\n *     <td>Successful invoke of this method does not change the state. In order for the\n *         target audio attributes type to become effective, this method must be called before\n *         prepare() or prepareAsync().</p></td></tr>\n * <tr><td>setAudioSessionId </p></td>\n *     <td>{Idle} </p></td>\n *     <td>{Initialized, Prepared, Started, Paused, Stopped, PlaybackCompleted,\n *          Error} </p></td>\n *     <td>This method must be called in idle state as the audio session ID must be known before\n *         calling setDataSource. Calling it does not change the object state. </p></td></tr>\n * <tr><td>setAudioStreamType (deprecated)</p></td>\n *     <td>{Idle, Initialized, Stopped, Prepared, Started, Paused,\n *          PlaybackCompleted}</p></td>\n *     <td>{Error}</p></td>\n *     <td>Successful invoke of this method does not change the state. In order for the\n *         target audio stream type to become effective, this method must be called before\n *         prepare() or prepareAsync().</p></td></tr>\n * <tr><td>setAuxEffectSendLevel </p></td>\n *     <td>any</p></td>\n *     <td>{} </p></td>\n *     <td>Calling this method does not change the object state. </p></td></tr>\n * <tr><td>setDataSource </p></td>\n *     <td>{Idle} </p></td>\n *     <td>{Initialized, Prepared, Started, Paused, Stopped, PlaybackCompleted,\n *          Error} </p></td>\n *     <td>Successful invoke of this method in a valid state transfers the\n *         object to the <em>Initialized</em> state. Calling this method in an\n *         invalid state throws an IllegalStateException.</p></td></tr>\n * <tr><td>setDisplay </p></td>\n *     <td>any </p></td>\n *     <td>{} </p></td>\n *     <td>This method can be called in any state and calling it does not change\n *         the object state. </p></td></tr>\n * <tr><td>setSurface </p></td>\n *     <td>any </p></td>\n *     <td>{} </p></td>\n *     <td>This method can be called in any state and calling it does not change\n *         the object state. </p></td></tr>\n * <tr><td>setVideoScalingMode </p></td>\n *     <td>{Initialized, Prepared, Started, Paused, Stopped, PlaybackCompleted} </p></td>\n *     <td>{Idle, Error}</p></td>\n *     <td>Successful invoke of this method does not change the state.</p></td></tr>\n * <tr><td>setLooping </p></td>\n *     <td>{Idle, Initialized, Stopped, Prepared, Started, Paused,\n *         PlaybackCompleted}</p></td>\n *     <td>{Error}</p></td>\n *     <td>Successful invoke of this method in a valid state does not change\n *         the state. Calling this method in an\n *         invalid state transfers the object to the <em>Error</em> state.</p></td></tr>\n * <tr><td>isLooping </p></td>\n *     <td>any </p></td>\n *     <td>{} </p></td>\n *     <td>This method can be called in any state and calling it does not change\n *         the object state. </p></td></tr>\n * <tr><td>setOnBufferingUpdateListener </p></td>\n *     <td>any </p></td>\n *     <td>{} </p></td>\n *     <td>This method can be called in any state and calling it does not change\n *         the object state. </p></td></tr>\n * <tr><td>setOnCompletionListener </p></td>\n *     <td>any </p></td>\n *     <td>{} </p></td>\n *     <td>This method can be called in any state and calling it does not change\n *         the object state. </p></td></tr>\n * <tr><td>setOnErrorListener </p></td>\n *     <td>any </p></td>\n *     <td>{} </p></td>\n *     <td>This method can be called in any state and calling it does not change\n *         the object state. </p></td></tr>\n * <tr><td>setOnPreparedListener </p></td>\n *     <td>any </p></td>\n *     <td>{} </p></td>\n *     <td>This method can be called in any state and calling it does not change\n *         the object state. </p></td></tr>\n * <tr><td>setOnSeekCompleteListener </p></td>\n *     <td>any </p></td>\n *     <td>{} </p></td>\n *     <td>This method can be called in any state and calling it does not change\n *         the object state. </p></td></tr>\n * <tr><td>setPlaybackParams</p></td>\n *     <td>{Initialized, Prepared, Started, Paused, PlaybackCompleted, Error}</p></td>\n *     <td>{Idle, Stopped} </p></td>\n *     <td>This method will change state in some cases, depending on when it's called.\n *         </p></td></tr>\n * <tr><td>setScreenOnWhilePlaying</></td>\n *     <td>any </p></td>\n *     <td>{} </p></td>\n *     <td>This method can be called in any state and calling it does not change\n *         the object state.  </p></td></tr>\n * <tr><td>setVolume </p></td>\n *     <td>{Idle, Initialized, Stopped, Prepared, Started, Paused,\n *          PlaybackCompleted}</p></td>\n *     <td>{Error}</p></td>\n *     <td>Successful invoke of this method does not change the state.\n * <tr><td>setWakeMode </p></td>\n *     <td>any </p></td>\n *     <td>{} </p></td>\n *     <td>This method can be called in any state and calling it does not change\n *         the object state.</p></td></tr>\n * <tr><td>start </p></td>\n *     <td>{Prepared, Started, Paused, PlaybackCompleted}</p></td>\n *     <td>{Idle, Initialized, Stopped, Error}</p></td>\n *     <td>Successful invoke of this method in a valid state transfers the\n *         object to the <em>Started</em> state. Calling this method in an\n *         invalid state transfers the object to the <em>Error</em> state.</p></td></tr>\n * <tr><td>stop </p></td>\n *     <td>{Prepared, Started, Stopped, Paused, PlaybackCompleted}</p></td>\n *     <td>{Idle, Initialized, Error}</p></td>\n *     <td>Successful invoke of this method in a valid state transfers the\n *         object to the <em>Stopped</em> state. Calling this method in an\n *         invalid state transfers the object to the <em>Error</em> state.</p></td></tr>\n * <tr><td>getTrackInfo </p></td>\n *     <td>{Prepared, Started, Stopped, Paused, PlaybackCompleted}</p></td>\n *     <td>{Idle, Initialized, Error}</p></td>\n *     <td>Successful invoke of this method does not change the state.</p></td></tr>\n * <tr><td>addTimedTextSource </p></td>\n *     <td>{Prepared, Started, Stopped, Paused, PlaybackCompleted}</p></td>\n *     <td>{Idle, Initialized, Error}</p></td>\n *     <td>Successful invoke of this method does not change the state.</p></td></tr>\n * <tr><td>selectTrack </p></td>\n *     <td>{Prepared, Started, Stopped, Paused, PlaybackCompleted}</p></td>\n *     <td>{Idle, Initialized, Error}</p></td>\n *     <td>Successful invoke of this method does not change the state.</p></td></tr>\n * <tr><td>deselectTrack </p></td>\n *     <td>{Prepared, Started, Stopped, Paused, PlaybackCompleted}</p></td>\n *     <td>{Idle, Initialized, Error}</p></td>\n *     <td>Successful invoke of this method does not change the state.</p></td></tr>\n *\n * </table>\n *\n * <a name=\"Permissions\"></a>\n * <h3>Permissions</h3>\n * <p>One may need to declare a corresponding WAKE_LOCK permission {@link\n * android.R.styleable#AndroidManifestUsesPermission &lt;uses-permission&gt;}\n * element.\n *\n * <p>This class requires the {@link android.Manifest.permission#INTERNET} permission\n * when used with network-based content.\n *\n * <a name=\"Callbacks\"></a>\n * <h3>Callbacks</h3>\n * <p>Applications may want to register for informational and error\n * events in order to be informed of some internal state update and\n * possible runtime errors during playback or streaming. Registration for\n * these events is done by properly setting the appropriate listeners (via calls\n * to\n * {@link #setOnPreparedListener(OnPreparedListener) setOnPreparedListener},\n * {@link #setOnVideoSizeChangedListener(OnVideoSizeChangedListener) setOnVideoSizeChangedListener},\n * {@link #setOnSeekCompleteListener(OnSeekCompleteListener) setOnSeekCompleteListener},\n * {@link #setOnCompletionListener(OnCompletionListener) setOnCompletionListener},\n * {@link #setOnBufferingUpdateListener(OnBufferingUpdateListener) setOnBufferingUpdateListener},\n * {@link #setOnInfoListener(OnInfoListener) setOnInfoListener},\n * {@link #setOnErrorListener(OnErrorListener) setOnErrorListener}, etc).\n * In order to receive the respective callback\n * associated with these listeners, applications are required to create\n * MediaPlayer objects on a thread with its own Looper running (main UI\n * thread by default has a Looper running).\n *\n ",
  "variables" : [ {
    "name" : "METADATA_UPDATE_ONLY",
    "type" : "boolean",
    "comment" : "\n       Constant to retrieve only the new metadata since the last\n       call.\n       // FIXME: unhide.\n       // FIXME: add link to getMetadata(boolean, boolean)\n       {@hide}\n     ",
    "links" : [ ]
  }, {
    "name" : "METADATA_ALL",
    "type" : "boolean",
    "comment" : "\n       Constant to retrieve all the metadata.\n       // FIXME: unhide.\n       // FIXME: add link to getMetadata(boolean, boolean)\n       {@hide}\n     ",
    "links" : [ ]
  }, {
    "name" : "APPLY_METADATA_FILTER",
    "type" : "boolean",
    "comment" : "\n       Constant to enable the metadata filter during retrieval.\n       // FIXME: unhide.\n       // FIXME: add link to getMetadata(boolean, boolean)\n       {@hide}\n     ",
    "links" : [ ]
  }, {
    "name" : "BYPASS_METADATA_FILTER",
    "type" : "boolean",
    "comment" : "\n       Constant to disable the metadata filter during retrieval.\n       // FIXME: unhide.\n       // FIXME: add link to getMetadata(boolean, boolean)\n       {@hide}\n     ",
    "links" : [ ]
  }, {
    "name" : "TAG",
    "type" : "String",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "IMEDIA_PLAYER",
    "type" : "String",
    "comment" : " macro invocation in IMediaPlayer.cpp",
    "links" : [ ]
  }, {
    "name" : "mNativeContext",
    "type" : "long",
    "comment" : " accessed by native methods",
    "links" : [ ]
  }, {
    "name" : "mNativeSurfaceTexture",
    "type" : "long",
    "comment" : " accessed by native methods",
    "links" : [ ]
  }, {
    "name" : "mListenerContext",
    "type" : "int",
    "comment" : " accessed by native methods",
    "links" : [ ]
  }, {
    "name" : "mSurfaceHolder",
    "type" : "SurfaceHolder",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mEventHandler",
    "type" : "EventHandler",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mWakeLock",
    "type" : "PowerManager.WakeLock",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mScreenOnWhilePlaying",
    "type" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mStayAwake",
    "type" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mStreamType",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mDrmUUID",
    "type" : "UUID",
    "comment" : " Modular DRM",
    "links" : [ ]
  }, {
    "name" : "mDrmLock",
    "type" : "Object",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mDrmInfo",
    "type" : "DrmInfo",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mDrmObj",
    "type" : "MediaDrm",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mDrmSessionId",
    "type" : "byte[]",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mDrmInfoResolved",
    "type" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mActiveDrmScheme",
    "type" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mDrmConfigAllowed",
    "type" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mDrmProvisioningInProgress",
    "type" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mPrepareDrmInProgress",
    "type" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mDrmProvisioningThread",
    "type" : "ProvisioningThread",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "INVOKE_ID_GET_TRACK_INFO",
    "type" : "int",
    "comment" : " Do not change these values (starting with INVOKE_ID) without updating\n     * their counterparts in include/media/mediaplayer.h!\n     ",
    "links" : [ ]
  }, {
    "name" : "INVOKE_ID_ADD_EXTERNAL_SOURCE",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "INVOKE_ID_ADD_EXTERNAL_SOURCE_FD",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "INVOKE_ID_SELECT_TRACK",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "INVOKE_ID_DESELECT_TRACK",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "INVOKE_ID_SET_VIDEO_SCALE_MODE",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "INVOKE_ID_GET_SELECTED_TRACK",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "VIDEO_SCALING_MODE_SCALE_TO_FIT",
    "type" : "int",
    "comment" : "\n     * Specifies a video scaling mode. The content is stretched to the\n     * surface rendering area. When the surface has the same aspect ratio\n     * as the content, the aspect ratio of the content is maintained;\n     * otherwise, the aspect ratio of the content is not maintained when video\n     * is being rendered. Unlike {@link #VIDEO_SCALING_MODE_SCALE_TO_FIT_WITH_CROPPING},\n     * there is no content cropping with this video scaling mode.\n     ",
    "links" : [ "#VIDEO_SCALING_MODE_SCALE_TO_FIT_WITH_CROPPING" ]
  }, {
    "name" : "VIDEO_SCALING_MODE_SCALE_TO_FIT_WITH_CROPPING",
    "type" : "int",
    "comment" : "\n     * Specifies a video scaling mode. The content is scaled, maintaining\n     * its aspect ratio. The whole surface area is always used. When the\n     * aspect ratio of the content is the same as the surface, no content\n     * is cropped; otherwise, content is cropped to fit the surface.\n     ",
    "links" : [ ]
  }, {
    "name" : "mPreferredDevice",
    "type" : "AudioDeviceInfo",
    "comment" : "--------------------",
    "links" : [ ]
  }, {
    "name" : "mRoutingChangeListeners",
    "type" : "ArrayMap<AudioRouting.OnRoutingChangedListener, NativeRoutingEventHandlerDelegate>",
    "comment" : "\n     * The list of AudioRouting.OnRoutingChangedListener interfaces added (with\n     * {@link #addOnRoutingChangedListener(android.media.AudioRouting.OnRoutingChangedListener, Handler)}\n     * by an app to receive (re)routing notifications.\n     ",
    "links" : [ "#addOnRoutingChangedListener" ]
  }, {
    "name" : "PLAYBACK_RATE_AUDIO_MODE_RESAMPLE",
    "type" : "int",
    "comment" : "\n     * Change playback speed of audio by resampling the audio.\n     * <p>\n     * Specifies resampling as audio mode for variable rate playback, i.e.,\n     * resample the waveform based on the requested playback rate to get\n     * a new waveform, and play back the new waveform at the original sampling\n     * frequency.\n     * When rate is larger than 1.0, pitch becomes higher.\n     * When rate is smaller than 1.0, pitch becomes lower.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "PLAYBACK_RATE_AUDIO_MODE_STRETCH",
    "type" : "int",
    "comment" : "\n     * Change playback speed of audio without changing its pitch.\n     * <p>\n     * Specifies time stretching as audio mode for variable rate playback.\n     * Time stretching changes the duration of the audio samples without\n     * affecting its pitch.\n     * <p>\n     * This mode is only supported for a limited range of playback speed factors,\n     * e.g. between 1/2x and 2x.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "PLAYBACK_RATE_AUDIO_MODE_DEFAULT",
    "type" : "int",
    "comment" : "\n     * Change playback speed of audio without changing its pitch, and\n     * possibly mute audio if time stretching is not supported for the playback\n     * speed.\n     * <p>\n     * Try to keep audio pitch when changing the playback rate, but allow the\n     * system to determine how to change audio playback if the rate is out\n     * of range.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "SEEK_PREVIOUS_SYNC",
    "type" : "int",
    "comment" : "\n     * This mode is used with {@link #seekTo(long, int)} to move media position to\n     * a sync (or key) frame associated with a data source that is located\n     * right before or at the given time.\n     *\n     * @see #seekTo(long, int)\n     ",
    "links" : [ "#seekTo" ]
  }, {
    "name" : "SEEK_NEXT_SYNC",
    "type" : "int",
    "comment" : "\n     * This mode is used with {@link #seekTo(long, int)} to move media position to\n     * a sync (or key) frame associated with a data source that is located\n     * right after or at the given time.\n     *\n     * @see #seekTo(long, int)\n     ",
    "links" : [ "#seekTo" ]
  }, {
    "name" : "SEEK_CLOSEST_SYNC",
    "type" : "int",
    "comment" : "\n     * This mode is used with {@link #seekTo(long, int)} to move media position to\n     * a sync (or key) frame associated with a data source that is located\n     * closest to (in time) or at the given time.\n     *\n     * @see #seekTo(long, int)\n     ",
    "links" : [ "#seekTo" ]
  }, {
    "name" : "SEEK_CLOSEST",
    "type" : "int",
    "comment" : "\n     * This mode is used with {@link #seekTo(long, int)} to move media position to\n     * a frame (not necessarily a key frame) associated with a data source that\n     * is located closest to or at the given time.\n     *\n     * @see #seekTo(long, int)\n     ",
    "links" : [ "#seekTo" ]
  }, {
    "name" : "KEY_PARAMETER_AUDIO_ATTRIBUTES",
    "type" : "int",
    "comment" : " Keep KEY_PARAMETER_* in sync with include/media/mediaplayer.h",
    "links" : [ ]
  }, {
    "name" : "mIndexTrackPairs",
    "type" : "Vector<Pair<Integer, SubtitleTrack>>",
    "comment" : "               an inband subtitle track or any out-of-band track (subtitle or timedtext).",
    "links" : [ ]
  }, {
    "name" : "mInbandTrackIndices",
    "type" : "BitSet",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "MEDIA_MIMETYPE_TEXT_SUBRIP",
    "type" : "String",
    "comment" : "\n     * MIME type for SubRip (SRT) container. Used in addTimedTextSource APIs.\n     * @deprecated use {@link MediaFormat#MIMETYPE_TEXT_SUBRIP}\n     ",
    "links" : [ "MediaFormat#MIMETYPE_TEXT_SUBRIP" ]
  }, {
    "name" : "MEDIA_MIMETYPE_TEXT_VTT",
    "type" : "String",
    "comment" : "\n     * MIME type for WebVTT subtitle data.\n     * @hide\n     * @deprecated\n     ",
    "links" : [ ]
  }, {
    "name" : "MEDIA_MIMETYPE_TEXT_CEA_608",
    "type" : "String",
    "comment" : "\n     * MIME type for CEA-608 closed caption data.\n     * @hide\n     * @deprecated\n     ",
    "links" : [ ]
  }, {
    "name" : "MEDIA_MIMETYPE_TEXT_CEA_708",
    "type" : "String",
    "comment" : "\n     * MIME type for CEA-708 closed caption data.\n     * @hide\n     * @deprecated\n     ",
    "links" : [ ]
  }, {
    "name" : "mSubtitleController",
    "type" : "SubtitleController",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mSelectedSubtitleTrackIndex",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mOpenSubtitleSources",
    "type" : "Vector<InputStream>",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mIntSubtitleDataListener",
    "type" : "OnSubtitleDataListener",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "MEDIA_NOP",
    "type" : "int",
    "comment" : " interface test message",
    "links" : [ ]
  }, {
    "name" : "MEDIA_PREPARED",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "MEDIA_PLAYBACK_COMPLETE",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "MEDIA_BUFFERING_UPDATE",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "MEDIA_SEEK_COMPLETE",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "MEDIA_SET_VIDEO_SIZE",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "MEDIA_STARTED",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "MEDIA_PAUSED",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "MEDIA_STOPPED",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "MEDIA_SKIPPED",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "MEDIA_NOTIFY_TIME",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "MEDIA_TIMED_TEXT",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "MEDIA_ERROR",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "MEDIA_INFO",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "MEDIA_SUBTITLE_DATA",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "MEDIA_META_DATA",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "MEDIA_DRM_INFO",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "MEDIA_TIME_DISCONTINUITY",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "MEDIA_AUDIO_ROUTING_CHANGED",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mTimeProvider",
    "type" : "TimeProvider",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mTimeProviderLock",
    "type" : "Object",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mOnPreparedListener",
    "type" : "OnPreparedListener",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mOnCompletionListener",
    "type" : "OnCompletionListener",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mOnCompletionInternalListener",
    "type" : "OnCompletionListener",
    "comment" : "\n     * @hide\n     * Internal completion listener to update PlayerBase of the play state. Always \"registered\".\n     ",
    "links" : [ ]
  }, {
    "name" : "mOnBufferingUpdateListener",
    "type" : "OnBufferingUpdateListener",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mOnSeekCompleteListener",
    "type" : "OnSeekCompleteListener",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mOnVideoSizeChangedListener",
    "type" : "OnVideoSizeChangedListener",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mOnTimedTextListener",
    "type" : "OnTimedTextListener",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mSubtitleDataListenerDisabled",
    "type" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mExtSubtitleDataListener",
    "type" : "OnSubtitleDataListener",
    "comment" : " External OnSubtitleDataListener, the one set by {@link #setOnSubtitleDataListener}. ",
    "links" : [ "#setOnSubtitleDataListener" ]
  }, {
    "name" : "mExtSubtitleDataHandler",
    "type" : "Handler",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mOnMediaTimeDiscontinuityListener",
    "type" : "OnMediaTimeDiscontinuityListener",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mOnMediaTimeDiscontinuityHandler",
    "type" : "Handler",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mOnTimedMetaDataAvailableListener",
    "type" : "OnTimedMetaDataAvailableListener",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "MEDIA_ERROR_UNKNOWN",
    "type" : "int",
    "comment" : " Unspecified media player error.\n     * @see android.media.MediaPlayer.OnErrorListener\n     ",
    "links" : [ ]
  }, {
    "name" : "MEDIA_ERROR_SERVER_DIED",
    "type" : "int",
    "comment" : " Media server died. In this case, the application must release the\n     * MediaPlayer object and instantiate a new one.\n     * @see android.media.MediaPlayer.OnErrorListener\n     ",
    "links" : [ ]
  }, {
    "name" : "MEDIA_ERROR_NOT_VALID_FOR_PROGRESSIVE_PLAYBACK",
    "type" : "int",
    "comment" : " The video is streamed and its container is not valid for progressive\n     * playback i.e the video's index (e.g moov atom) is not at the start of the\n     * file.\n     * @see android.media.MediaPlayer.OnErrorListener\n     ",
    "links" : [ ]
  }, {
    "name" : "MEDIA_ERROR_IO",
    "type" : "int",
    "comment" : " File or network related operation errors. ",
    "links" : [ ]
  }, {
    "name" : "MEDIA_ERROR_MALFORMED",
    "type" : "int",
    "comment" : " Bitstream is not conforming to the related coding standard or file spec. ",
    "links" : [ ]
  }, {
    "name" : "MEDIA_ERROR_UNSUPPORTED",
    "type" : "int",
    "comment" : " Bitstream is conforming to the related coding standard or file spec, but\n     * the media framework does not support the feature. ",
    "links" : [ ]
  }, {
    "name" : "MEDIA_ERROR_TIMED_OUT",
    "type" : "int",
    "comment" : " Some operation takes too long to complete, usually more than 3-5 seconds. ",
    "links" : [ ]
  }, {
    "name" : "MEDIA_ERROR_SYSTEM",
    "type" : "int",
    "comment" : " Unspecified low-level system error. This value originated from UNKNOWN_ERROR in\n     * system/core/include/utils/Errors.h\n     * @see android.media.MediaPlayer.OnErrorListener\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "mOnErrorListener",
    "type" : "OnErrorListener",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "MEDIA_INFO_UNKNOWN",
    "type" : "int",
    "comment" : " Unspecified media player info.\n     * @see android.media.MediaPlayer.OnInfoListener\n     ",
    "links" : [ ]
  }, {
    "name" : "MEDIA_INFO_STARTED_AS_NEXT",
    "type" : "int",
    "comment" : " The player was started because it was used as the next player for another\n     * player, which just completed playback.\n     * @see android.media.MediaPlayer#setNextMediaPlayer(MediaPlayer)\n     * @see android.media.MediaPlayer.OnInfoListener\n     ",
    "links" : [ ]
  }, {
    "name" : "MEDIA_INFO_VIDEO_RENDERING_START",
    "type" : "int",
    "comment" : " The player just pushed the very first video frame for rendering.\n     * @see android.media.MediaPlayer.OnInfoListener\n     ",
    "links" : [ ]
  }, {
    "name" : "MEDIA_INFO_VIDEO_TRACK_LAGGING",
    "type" : "int",
    "comment" : " The video is too complex for the decoder: it can't decode frames fast\n     *  enough. Possibly only the audio plays fine at this stage.\n     * @see android.media.MediaPlayer.OnInfoListener\n     ",
    "links" : [ ]
  }, {
    "name" : "MEDIA_INFO_BUFFERING_START",
    "type" : "int",
    "comment" : " MediaPlayer is temporarily pausing playback internally in order to\n     * buffer more data.\n     * @see android.media.MediaPlayer.OnInfoListener\n     ",
    "links" : [ ]
  }, {
    "name" : "MEDIA_INFO_BUFFERING_END",
    "type" : "int",
    "comment" : " MediaPlayer is resuming playback after filling buffers.\n     * @see android.media.MediaPlayer.OnInfoListener\n     ",
    "links" : [ ]
  }, {
    "name" : "MEDIA_INFO_NETWORK_BANDWIDTH",
    "type" : "int",
    "comment" : " Estimated network bandwidth information (kbps) is available; currently this event fires\n     * simultaneously as {@link #MEDIA_INFO_BUFFERING_START} and {@link #MEDIA_INFO_BUFFERING_END}\n     * when playing network files.\n     * @see android.media.MediaPlayer.OnInfoListener\n     * @hide\n     ",
    "links" : [ "#MEDIA_INFO_BUFFERING_START", "#MEDIA_INFO_BUFFERING_END" ]
  }, {
    "name" : "MEDIA_INFO_BAD_INTERLEAVING",
    "type" : "int",
    "comment" : " Bad interleaving means that a media has been improperly interleaved or\n     * not interleaved at all, e.g has all the video samples first then all the\n     * audio ones. Video is playing but a lot of disk seeks may be happening.\n     * @see android.media.MediaPlayer.OnInfoListener\n     ",
    "links" : [ ]
  }, {
    "name" : "MEDIA_INFO_NOT_SEEKABLE",
    "type" : "int",
    "comment" : " The media cannot be seeked (e.g live stream)\n     * @see android.media.MediaPlayer.OnInfoListener\n     ",
    "links" : [ ]
  }, {
    "name" : "MEDIA_INFO_METADATA_UPDATE",
    "type" : "int",
    "comment" : " A new set of metadata is available.\n     * @see android.media.MediaPlayer.OnInfoListener\n     ",
    "links" : [ ]
  }, {
    "name" : "MEDIA_INFO_EXTERNAL_METADATA_UPDATE",
    "type" : "int",
    "comment" : " A new set of external-only metadata is available.  Used by\n     *  JAVA framework to avoid triggering track scanning.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "MEDIA_INFO_AUDIO_NOT_PLAYING",
    "type" : "int",
    "comment" : " Informs that audio is not playing. Note that playback of the video\n     * is not interrupted.\n     * @see android.media.MediaPlayer.OnInfoListener\n     ",
    "links" : [ ]
  }, {
    "name" : "MEDIA_INFO_VIDEO_NOT_PLAYING",
    "type" : "int",
    "comment" : " Informs that video is not playing. Note that playback of the audio\n     * is not interrupted.\n     * @see android.media.MediaPlayer.OnInfoListener\n     ",
    "links" : [ ]
  }, {
    "name" : "MEDIA_INFO_TIMED_TEXT_ERROR",
    "type" : "int",
    "comment" : " Failed to handle timed text track properly.\n     * @see android.media.MediaPlayer.OnInfoListener\n     *\n     * {@hide}\n     ",
    "links" : [ ]
  }, {
    "name" : "MEDIA_INFO_UNSUPPORTED_SUBTITLE",
    "type" : "int",
    "comment" : " Subtitle track was not supported by the media framework.\n     * @see android.media.MediaPlayer.OnInfoListener\n     ",
    "links" : [ ]
  }, {
    "name" : "MEDIA_INFO_SUBTITLE_TIMED_OUT",
    "type" : "int",
    "comment" : " Reading the subtitle track takes too long.\n     * @see android.media.MediaPlayer.OnInfoListener\n     ",
    "links" : [ ]
  }, {
    "name" : "mOnInfoListener",
    "type" : "OnInfoListener",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mOnDrmConfigHelper",
    "type" : "OnDrmConfigHelper",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mOnDrmInfoHandlerDelegate",
    "type" : "OnDrmInfoHandlerDelegate",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "PREPARE_DRM_STATUS_SUCCESS",
    "type" : "int",
    "comment" : "\n     * The status codes for {@link OnDrmPreparedListener#onDrmPrepared} listener.\n     * <p>\n     *\n     * DRM preparation has succeeded.\n     ",
    "links" : [ "OnDrmPreparedListener#onDrmPrepared" ]
  }, {
    "name" : "PREPARE_DRM_STATUS_PROVISIONING_NETWORK_ERROR",
    "type" : "int",
    "comment" : "\n     * The device required DRM provisioning but couldn't reach the provisioning server.\n     ",
    "links" : [ ]
  }, {
    "name" : "PREPARE_DRM_STATUS_PROVISIONING_SERVER_ERROR",
    "type" : "int",
    "comment" : "\n     * The device required DRM provisioning but the provisioning server denied the request.\n     ",
    "links" : [ ]
  }, {
    "name" : "PREPARE_DRM_STATUS_PREPARATION_ERROR",
    "type" : "int",
    "comment" : "\n     * The DRM preparation has failed .\n     ",
    "links" : [ ]
  }, {
    "name" : "mOnDrmPreparedHandlerDelegate",
    "type" : "OnDrmPreparedHandlerDelegate",
    "comment" : "",
    "links" : [ ]
  } ],
  "methods" : [ {
    "name" : "private native void _setVideoSurface(Surface surface)",
    "returnType" : "void",
    "comment" : "\n     * Update the MediaPlayer SurfaceTexture.\n     * Call after setting a new display surface.\n     ",
    "links" : [ ]
  }, {
    "name" : "public Parcel newRequest()",
    "returnType" : "Parcel",
    "comment" : "\n     * Create a request parcel which can be routed to the native media\n     * player using {@link #invoke(Parcel, Parcel)}. The Parcel\n     * returned has the proper InterfaceToken set. The caller should\n     * not overwrite that token, i.e it can only append data to the\n     * Parcel.\n     *\n     * @return A parcel suitable to hold a request for the native\n     * player.\n     * {@hide}\n     ",
    "links" : [ "#invoke" ]
  }, {
    "name" : "public void invoke(Parcel request, Parcel reply)",
    "returnType" : "void",
    "comment" : "\n     * Invoke a generic method on the native player using opaque\n     * parcels for the request and reply. Both payloads' format is a\n     * convention between the java caller and the native player.\n     * Must be called after setDataSource to make sure a native player\n     * exists. On failure, a RuntimeException is thrown.\n     *\n     * @param request Parcel with the data for the extension. The\n     * caller must use {@link #newRequest()} to get one.\n     *\n     * @param reply Output parcel with the data returned by the\n     * native player.\n     * {@hide}\n     ",
    "links" : [ "#newRequest" ]
  }, {
    "name" : "public void setDisplay(SurfaceHolder sh)",
    "returnType" : "void",
    "comment" : "\n     * Sets the {@link SurfaceHolder} to use for displaying the video\n     * portion of the media.\n     *\n     * Either a surface holder or surface must be set if a display or video sink\n     * is needed.  Not calling this method or {@link #setSurface(Surface)}\n     * when playing back a video will result in only the audio track being played.\n     * A null surface holder or surface will result in only the audio track being\n     * played.\n     *\n     * @param sh the SurfaceHolder to use for video display\n     * @throws IllegalStateException if the internal player engine has not been\n     * initialized or has been released.\n     ",
    "links" : [ "SurfaceHolder", "#setSurface" ]
  }, {
    "name" : "public void setSurface(Surface surface)",
    "returnType" : "void",
    "comment" : "\n     * Sets the {@link Surface} to be used as the sink for the video portion of\n     * the media. This is similar to {@link #setDisplay(SurfaceHolder)}, but\n     * does not support {@link #setScreenOnWhilePlaying(boolean)}.  Setting a\n     * Surface will un-set any Surface or SurfaceHolder that was previously set.\n     * A null surface will result in only the audio track being played.\n     *\n     * If the Surface sends frames to a {@link SurfaceTexture}, the timestamps\n     * returned from {@link SurfaceTexture#getTimestamp()} will have an\n     * unspecified zero point.  These timestamps cannot be directly compared\n     * between different media sources, different instances of the same media\n     * source, or multiple runs of the same program.  The timestamp is normally\n     * monotonically increasing and is unaffected by time-of-day adjustments,\n     * but it is reset when the position is set.\n     *\n     * @param surface The {@link Surface} to be used for the video portion of\n     * the media.\n     * @throws IllegalStateException if the internal player engine has not been\n     * initialized or has been released.\n     ",
    "links" : [ "Surface", "#setDisplay", "#setScreenOnWhilePlaying", "SurfaceTexture", "SurfaceTexture#getTimestamp", "Surface" ]
  }, {
    "name" : "public void setVideoScalingMode(int mode)",
    "returnType" : "void",
    "comment" : "\n     * Sets video scaling mode. To make the target video scaling mode\n     * effective during playback, this method must be called after\n     * data source is set. If not called, the default video\n     * scaling mode is {@link #VIDEO_SCALING_MODE_SCALE_TO_FIT}.\n     *\n     * <p> The supported video scaling modes are:\n     * <ul>\n     * <li> {@link #VIDEO_SCALING_MODE_SCALE_TO_FIT}\n     * <li> {@link #VIDEO_SCALING_MODE_SCALE_TO_FIT_WITH_CROPPING}\n     * </ul>\n     *\n     * @param mode target video scaling mode. Must be one of the supported\n     * video scaling modes; otherwise, IllegalArgumentException will be thrown.\n     *\n     * @see MediaPlayer#VIDEO_SCALING_MODE_SCALE_TO_FIT\n     * @see MediaPlayer#VIDEO_SCALING_MODE_SCALE_TO_FIT_WITH_CROPPING\n     ",
    "links" : [ "#VIDEO_SCALING_MODE_SCALE_TO_FIT", "#VIDEO_SCALING_MODE_SCALE_TO_FIT", "#VIDEO_SCALING_MODE_SCALE_TO_FIT_WITH_CROPPING" ]
  }, {
    "name" : "public static MediaPlayer create(Context context, Uri uri)",
    "returnType" : "MediaPlayer",
    "comment" : "\n     * Convenience method to create a MediaPlayer for a given Uri.\n     * On success, {@link #prepare()} will already have been called and must not be called again.\n     * <p>When done with the MediaPlayer, you should call  {@link #release()},\n     * to free the resources. If not released, too many MediaPlayer instances will\n     * result in an exception.</p>\n     * <p>Note that since {@link #prepare()} is called automatically in this method,\n     * you cannot change the audio\n     * session ID (see {@link #setAudioSessionId(int)}) or audio attributes\n     * (see {@link #setAudioAttributes(AudioAttributes)} of the new MediaPlayer.</p>\n     *\n     * @param context the Context to use\n     * @param uri the Uri from which to get the datasource\n     * @return a MediaPlayer object, or null if creation failed\n     ",
    "links" : [ "#prepare", "#release", "#prepare", "#setAudioSessionId", "#setAudioAttributes" ]
  }, {
    "name" : "public static MediaPlayer create(Context context, Uri uri, SurfaceHolder holder)",
    "returnType" : "MediaPlayer",
    "comment" : "\n     * Convenience method to create a MediaPlayer for a given Uri.\n     * On success, {@link #prepare()} will already have been called and must not be called again.\n     * <p>When done with the MediaPlayer, you should call  {@link #release()},\n     * to free the resources. If not released, too many MediaPlayer instances will\n     * result in an exception.</p>\n     * <p>Note that since {@link #prepare()} is called automatically in this method,\n     * you cannot change the audio\n     * session ID (see {@link #setAudioSessionId(int)}) or audio attributes\n     * (see {@link #setAudioAttributes(AudioAttributes)} of the new MediaPlayer.</p>\n     *\n     * @param context the Context to use\n     * @param uri the Uri from which to get the datasource\n     * @param holder the SurfaceHolder to use for displaying the video\n     * @return a MediaPlayer object, or null if creation failed\n     ",
    "links" : [ "#prepare", "#release", "#prepare", "#setAudioSessionId", "#setAudioAttributes" ]
  }, {
    "name" : "public static MediaPlayer create(Context context, Uri uri, SurfaceHolder holder, AudioAttributes audioAttributes, int audioSessionId)",
    "returnType" : "MediaPlayer",
    "comment" : "\n     * Same factory method as {@link #create(Context, Uri, SurfaceHolder)} but that lets you specify\n     * the audio attributes and session ID to be used by the new MediaPlayer instance.\n     * @param context the Context to use\n     * @param uri the Uri from which to get the datasource\n     * @param holder the SurfaceHolder to use for displaying the video, may be null.\n     * @param audioAttributes the {@link AudioAttributes} to be used by the media player.\n     * @param audioSessionId the audio session ID to be used by the media player,\n     *     see {@link AudioManager#generateAudioSessionId()} to obtain a new session.\n     * @return a MediaPlayer object, or null if creation failed\n     ",
    "links" : [ "#create", "AudioAttributes", "AudioManager#generateAudioSessionId" ]
  }, {
    "name" : "public static MediaPlayer create(Context context, int resid)",
    "returnType" : "MediaPlayer",
    "comment" : "\n     * Convenience method to create a MediaPlayer for a given resource id.\n     * On success, {@link #prepare()} will already have been called and must not be called again.\n     * <p>When done with the MediaPlayer, you should call  {@link #release()},\n     * to free the resources. If not released, too many MediaPlayer instances will\n     * result in an exception.</p>\n     * <p>Note that since {@link #prepare()} is called automatically in this method,\n     * you cannot change the audio\n     * session ID (see {@link #setAudioSessionId(int)}) or audio attributes\n     * (see {@link #setAudioAttributes(AudioAttributes)} of the new MediaPlayer.</p>\n     *\n     * @param context the Context to use\n     * @param resid the raw resource id (<var>R.raw.&lt;something></var>) for\n     *              the resource to use as the datasource\n     * @return a MediaPlayer object, or null if creation failed\n     ",
    "links" : [ "#prepare", "#release", "#prepare", "#setAudioSessionId", "#setAudioAttributes" ]
  }, {
    "name" : "public static MediaPlayer create(Context context, int resid, AudioAttributes audioAttributes, int audioSessionId)",
    "returnType" : "MediaPlayer",
    "comment" : "\n     * Same factory method as {@link #create(Context, int)} but that lets you specify the audio\n     * attributes and session ID to be used by the new MediaPlayer instance.\n     * @param context the Context to use\n     * @param resid the raw resource id (<var>R.raw.&lt;something></var>) for\n     *              the resource to use as the datasource\n     * @param audioAttributes the {@link AudioAttributes} to be used by the media player.\n     * @param audioSessionId the audio session ID to be used by the media player,\n     *     see {@link AudioManager#generateAudioSessionId()} to obtain a new session.\n     * @return a MediaPlayer object, or null if creation failed\n     ",
    "links" : [ "#create", "AudioAttributes", "AudioManager#generateAudioSessionId" ]
  }, {
    "name" : "public void setDataSource(@NonNull Context context, @NonNull Uri uri) throws IOException, IllegalArgumentException, SecurityException, IllegalStateException",
    "returnType" : "void",
    "comment" : "\n     * Sets the data source as a content Uri.\n     *\n     * @param context the Context to use when resolving the Uri\n     * @param uri the Content URI of the data you want to play\n     * @throws IllegalStateException if it is called in an invalid state\n     ",
    "links" : [ ]
  }, {
    "name" : "public void setDataSource(@NonNull Context context, @NonNull Uri uri, @Nullable Map<String, String> headers, @Nullable List<HttpCookie> cookies) throws IOException",
    "returnType" : "void",
    "comment" : "\n     * Sets the data source as a content Uri.\n     *\n     * To provide cookies for the subsequent HTTP requests, you can install your own default cookie\n     * handler and use other variants of setDataSource APIs instead. Alternatively, you can use\n     * this API to pass the cookies as a list of HttpCookie. If the app has not installed\n     * a CookieHandler already, this API creates a CookieManager and populates its CookieStore with\n     * the provided cookies. If the app has installed its own handler already, this API requires the\n     * handler to be of CookieManager type such that the API can update the manager’s CookieStore.\n     *\n     * <p><strong>Note</strong> that the cross domain redirection is allowed by default,\n     * but that can be changed with key/value pairs through the headers parameter with\n     * \"android-allow-cross-domain-redirect\" as the key and \"0\" or \"1\" as the value to\n     * disallow or allow cross domain redirection.\n     *\n     * @param context the Context to use when resolving the Uri\n     * @param uri the Content URI of the data you want to play\n     * @param headers the headers to be sent together with the request for the data\n     *                The headers must not include cookies. Instead, use the cookies param.\n     * @param cookies the cookies to be sent together with the request\n     * @throws IllegalArgumentException if cookies are provided and the installed handler is not\n     *                                  a CookieManager\n     * @throws IllegalStateException    if it is called in an invalid state\n     * @throws NullPointerException     if context or uri is null\n     * @throws IOException              if uri has a file scheme and an I/O error occurs\n     ",
    "links" : [ ]
  }, {
    "name" : "public void setDataSource(@NonNull Context context, @NonNull Uri uri, @Nullable Map<String, String> headers) throws IOException, IllegalArgumentException, SecurityException, IllegalStateException",
    "returnType" : "void",
    "comment" : "\n     * Sets the data source as a content Uri.\n     *\n     * <p><strong>Note</strong> that the cross domain redirection is allowed by default,\n     * but that can be changed with key/value pairs through the headers parameter with\n     * \"android-allow-cross-domain-redirect\" as the key and \"0\" or \"1\" as the value to\n     * disallow or allow cross domain redirection.\n     *\n     * @param context the Context to use when resolving the Uri\n     * @param uri the Content URI of the data you want to play\n     * @param headers the headers to be sent together with the request for the data\n     * @throws IllegalStateException if it is called in an invalid state\n     ",
    "links" : [ ]
  }, {
    "name" : "private boolean attemptDataSource(ContentResolver resolver, Uri uri)",
    "returnType" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public void setDataSource(String path) throws IOException, IllegalArgumentException, SecurityException, IllegalStateException",
    "returnType" : "void",
    "comment" : "\n     * Sets the data source (file-path or http/rtsp URL) to use.\n     *\n     * <p>When <code>path</code> refers to a local file, the file may actually be opened by a\n     * process other than the calling application.  This implies that the pathname\n     * should be an absolute path (as any other process runs with unspecified current working\n     * directory), and that the pathname should reference a world-readable file.\n     * As an alternative, the application could first open the file for reading,\n     * and then use the file descriptor form {@link #setDataSource(FileDescriptor)}.\n     *\n     * @param path the path of the file, or the http/rtsp URL of the stream you want to play\n     * @throws IllegalStateException if it is called in an invalid state\n     ",
    "links" : [ "#setDataSource" ]
  }, {
    "name" : "public void setDataSource(String path, Map<String, String> headers) throws IOException, IllegalArgumentException, SecurityException, IllegalStateException",
    "returnType" : "void",
    "comment" : "\n     * Sets the data source (file-path or http/rtsp URL) to use.\n     *\n     * @param path the path of the file, or the http/rtsp URL of the stream you want to play\n     * @param headers the headers associated with the http request for the stream you want to play\n     * @throws IllegalStateException if it is called in an invalid state\n     * @hide pending API council\n     ",
    "links" : [ ]
  }, {
    "name" : "private void setDataSource(String path, Map<String, String> headers, List<HttpCookie> cookies) throws IOException, IllegalArgumentException, SecurityException, IllegalStateException",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private void setDataSource(String path, String[] keys, String[] values, List<HttpCookie> cookies) throws IOException, IllegalArgumentException, SecurityException, IllegalStateException",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private native void nativeSetDataSource(IBinder httpServiceBinder, String path, String[] keys, String[] values) throws IOException, IllegalArgumentException, SecurityException, IllegalStateException",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public void setDataSource(@NonNull AssetFileDescriptor afd) throws IOException, IllegalArgumentException, IllegalStateException",
    "returnType" : "void",
    "comment" : "\n     * Sets the data source (AssetFileDescriptor) to use. It is the caller's\n     * responsibility to close the file descriptor. It is safe to do so as soon\n     * as this call returns.\n     *\n     * @param afd the AssetFileDescriptor for the file you want to play\n     * @throws IllegalStateException if it is called in an invalid state\n     * @throws IllegalArgumentException if afd is not a valid AssetFileDescriptor\n     * @throws IOException if afd can not be read\n     ",
    "links" : [ ]
  }, {
    "name" : "public void setDataSource(FileDescriptor fd) throws IOException, IllegalArgumentException, IllegalStateException",
    "returnType" : "void",
    "comment" : "\n     * Sets the data source (FileDescriptor) to use. It is the caller's responsibility\n     * to close the file descriptor. It is safe to do so as soon as this call returns.\n     *\n     * @param fd the FileDescriptor for the file you want to play\n     * @throws IllegalStateException if it is called in an invalid state\n     * @throws IllegalArgumentException if fd is not a valid FileDescriptor\n     * @throws IOException if fd can not be read\n     ",
    "links" : [ ]
  }, {
    "name" : "public void setDataSource(FileDescriptor fd, long offset, long length) throws IOException, IllegalArgumentException, IllegalStateException",
    "returnType" : "void",
    "comment" : "\n     * Sets the data source (FileDescriptor) to use.  The FileDescriptor must be\n     * seekable (N.B. a LocalSocket is not seekable). It is the caller's responsibility\n     * to close the file descriptor. It is safe to do so as soon as this call returns.\n     *\n     * @param fd the FileDescriptor for the file you want to play\n     * @param offset the offset into the file where the data to be played starts, in bytes\n     * @param length the length in bytes of the data to be played\n     * @throws IllegalStateException if it is called in an invalid state\n     * @throws IllegalArgumentException if fd is not a valid FileDescriptor\n     * @throws IOException if fd can not be read\n     ",
    "links" : [ ]
  }, {
    "name" : "private native void _setDataSource(FileDescriptor fd, long offset, long length) throws IOException, IllegalArgumentException, IllegalStateException",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public void setDataSource(MediaDataSource dataSource) throws IllegalArgumentException, IllegalStateException",
    "returnType" : "void",
    "comment" : "\n     * Sets the data source (MediaDataSource) to use.\n     *\n     * @param dataSource the MediaDataSource for the media you want to play\n     * @throws IllegalStateException if it is called in an invalid state\n     * @throws IllegalArgumentException if dataSource is not a valid MediaDataSource\n     ",
    "links" : [ ]
  }, {
    "name" : "private native void _setDataSource(MediaDataSource dataSource) throws IllegalArgumentException, IllegalStateException",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public void prepare() throws IOException, IllegalStateException",
    "returnType" : "void",
    "comment" : "\n     * Prepares the player for playback, synchronously.\n     *\n     * After setting the datasource and the display surface, you need to either\n     * call prepare() or prepareAsync(). For files, it is OK to call prepare(),\n     * which blocks until MediaPlayer is ready for playback.\n     *\n     * @throws IllegalStateException if it is called in an invalid state\n     ",
    "links" : [ ]
  }, {
    "name" : "private native void _prepare() throws IOException, IllegalStateException",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public native void prepareAsync() throws IllegalStateException",
    "returnType" : "void",
    "comment" : "\n     * Prepares the player for playback, asynchronously.\n     *\n     * After setting the datasource and the display surface, you need to either\n     * call prepare() or prepareAsync(). For streams, you should call prepareAsync(),\n     * which returns immediately, rather than blocking until enough data has been\n     * buffered.\n     *\n     * @throws IllegalStateException if it is called in an invalid state\n     ",
    "links" : [ ]
  }, {
    "name" : "public void start() throws IllegalStateException",
    "returnType" : "void",
    "comment" : "\n     * Starts or resumes playback. If playback had previously been paused,\n     * playback will continue from where it was paused. If playback had\n     * been stopped, or never started before, playback will start at the\n     * beginning.\n     *\n     * @throws IllegalStateException if it is called in an invalid state\n     ",
    "links" : [ ]
  }, {
    "name" : "private void startImpl()",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private native void _start() throws IllegalStateException",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private int getAudioStreamType()",
    "returnType" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private native int _getAudioStreamType() throws IllegalStateException",
    "returnType" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public void stop() throws IllegalStateException",
    "returnType" : "void",
    "comment" : "\n     * Stops playback after playback has been started or paused.\n     *\n     * @throws IllegalStateException if the internal player engine has not been\n     * initialized.\n     ",
    "links" : [ ]
  }, {
    "name" : "private native void _stop() throws IllegalStateException",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public void pause() throws IllegalStateException",
    "returnType" : "void",
    "comment" : "\n     * Pauses playback. Call start() to resume.\n     *\n     * @throws IllegalStateException if the internal player engine has not been\n     * initialized.\n     ",
    "links" : [ ]
  }, {
    "name" : "private native void _pause() throws IllegalStateException",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : " void playerStart()",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : " void playerPause()",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : " void playerStop()",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : " int playerApplyVolumeShaper(@NonNull VolumeShaper.Configuration configuration, @NonNull VolumeShaper.Operation operation)",
    "returnType" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : " VolumeShaper.State playerGetVolumeShaperState(int id)",
    "returnType" : "VolumeShaper.State",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public VolumeShaper createVolumeShaper(@NonNull VolumeShaper.Configuration configuration)",
    "returnType" : "VolumeShaper",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private native int native_applyVolumeShaper(@NonNull VolumeShaper.Configuration configuration, @NonNull VolumeShaper.Operation operation)",
    "returnType" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private native VolumeShaper.State native_getVolumeShaperState(int id)",
    "returnType" : "VolumeShaper.State",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public boolean setPreferredDevice(AudioDeviceInfo deviceInfo)",
    "returnType" : "boolean",
    "comment" : "\n     * Specifies an audio device (via an {@link AudioDeviceInfo} object) to route\n     * the output from this MediaPlayer.\n     * @param deviceInfo The {@link AudioDeviceInfo} specifying the audio sink or source.\n     *  If deviceInfo is null, default routing is restored.\n     * @return true if succesful, false if the specified {@link AudioDeviceInfo} is non-null and\n     * does not correspond to a valid audio device.\n     ",
    "links" : [ "AudioDeviceInfo", "AudioDeviceInfo", "AudioDeviceInfo" ]
  }, {
    "name" : "public AudioDeviceInfo getPreferredDevice()",
    "returnType" : "AudioDeviceInfo",
    "comment" : "\n     * Returns the selected output specified by {@link #setPreferredDevice}. Note that this\n     * is not guaranteed to correspond to the actual device being used for playback.\n     ",
    "links" : [ "#setPreferredDevice" ]
  }, {
    "name" : "public AudioDeviceInfo getRoutedDevice()",
    "returnType" : "AudioDeviceInfo",
    "comment" : "\n     * Returns an {@link AudioDeviceInfo} identifying the current routing of this MediaPlayer\n     * Note: The query is only valid if the MediaPlayer is currently playing.\n     * If the player is not playing, the returned device can be null or correspond to previously\n     * selected device when the player was last active.\n     ",
    "links" : [ "AudioDeviceInfo" ]
  }, {
    "name" : "private void enableNativeRoutingCallbacksLocked(boolean enabled)",
    "returnType" : "void",
    "comment" : "\n     * Call BEFORE adding a routing callback handler or AFTER removing a routing callback handler.\n     ",
    "links" : [ ]
  }, {
    "name" : "public void addOnRoutingChangedListener(AudioRouting.OnRoutingChangedListener listener, Handler handler)",
    "returnType" : "void",
    "comment" : "\n     * Adds an {@link AudioRouting.OnRoutingChangedListener} to receive notifications of routing\n     * changes on this MediaPlayer.\n     * @param listener The {@link AudioRouting.OnRoutingChangedListener} interface to receive\n     * notifications of rerouting events.\n     * @param handler  Specifies the {@link Handler} object for the thread on which to execute\n     * the callback. If <code>null</code>, the handler on the main looper will be used.\n     ",
    "links" : [ "AudioRouting.OnRoutingChangedListener", "AudioRouting.OnRoutingChangedListener", "Handler" ]
  }, {
    "name" : "public void removeOnRoutingChangedListener(AudioRouting.OnRoutingChangedListener listener)",
    "returnType" : "void",
    "comment" : "\n     * Removes an {@link AudioRouting.OnRoutingChangedListener} which has been previously added\n     * to receive rerouting notifications.\n     * @param listener The previously added {@link AudioRouting.OnRoutingChangedListener} interface\n     * to remove.\n     ",
    "links" : [ "AudioRouting.OnRoutingChangedListener", "AudioRouting.OnRoutingChangedListener" ]
  }, {
    "name" : "private final native boolean native_setOutputDevice(int deviceId)",
    "returnType" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private final native int native_getRoutedDeviceId()",
    "returnType" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private final native void native_enableDeviceCallback(boolean enabled)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public void setWakeMode(Context context, int mode)",
    "returnType" : "void",
    "comment" : "\n     * Set the low-level power management behavior for this MediaPlayer.  This\n     * can be used when the MediaPlayer is not playing through a SurfaceHolder\n     * set with {@link #setDisplay(SurfaceHolder)} and thus can use the\n     * high-level {@link #setScreenOnWhilePlaying(boolean)} feature.\n     *\n     * <p>This function has the MediaPlayer access the low-level power manager\n     * service to control the device's power usage while playing is occurring.\n     * The parameter is a combination of {@link android.os.PowerManager} wake flags.\n     * Use of this method requires {@link android.Manifest.permission#WAKE_LOCK}\n     * permission.\n     * By default, no attempt is made to keep the device awake during playback.\n     *\n     * @param context the Context to use\n     * @param mode    the power/wake mode to set\n     * @see android.os.PowerManager\n     ",
    "links" : [ "#setDisplay", "#setScreenOnWhilePlaying", "android.os.PowerManager", "android.Manifest.permission#WAKE_LOCK" ]
  }, {
    "name" : "public void setScreenOnWhilePlaying(boolean screenOn)",
    "returnType" : "void",
    "comment" : "\n     * Control whether we should use the attached SurfaceHolder to keep the\n     * screen on while video playback is occurring.  This is the preferred\n     * method over {@link #setWakeMode} where possible, since it doesn't\n     * require that the application have permission for low-level wake lock\n     * access.\n     *\n     * @param screenOn Supply true to keep the screen on, false to allow it\n     * to turn off.\n     ",
    "links" : [ "#setWakeMode" ]
  }, {
    "name" : "private void stayAwake(boolean awake)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private void updateSurfaceScreenOn()",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public native int getVideoWidth()",
    "returnType" : "int",
    "comment" : "\n     * Returns the width of the video.\n     *\n     * @return the width of the video, or 0 if there is no video,\n     * no display surface was set, or the width has not been determined\n     * yet. The OnVideoSizeChangedListener can be registered via\n     * {@link #setOnVideoSizeChangedListener(OnVideoSizeChangedListener)}\n     * to provide a notification when the width is available.\n     ",
    "links" : [ "#setOnVideoSizeChangedListener" ]
  }, {
    "name" : "public native int getVideoHeight()",
    "returnType" : "int",
    "comment" : "\n     * Returns the height of the video.\n     *\n     * @return the height of the video, or 0 if there is no video,\n     * no display surface was set, or the height has not been determined\n     * yet. The OnVideoSizeChangedListener can be registered via\n     * {@link #setOnVideoSizeChangedListener(OnVideoSizeChangedListener)}\n     * to provide a notification when the height is available.\n     ",
    "links" : [ "#setOnVideoSizeChangedListener" ]
  }, {
    "name" : "public PersistableBundle getMetrics()",
    "returnType" : "PersistableBundle",
    "comment" : "\n     * Return Metrics data about the current player.\n     *\n     * @return a {@link PersistableBundle} containing the set of attributes and values\n     * available for the media being handled by this instance of MediaPlayer\n     * The attributes are descibed in {@link MetricsConstants}.\n     *\n     *  Additional vendor-specific fields may also be present in\n     *  the return value.\n     ",
    "links" : [ "PersistableBundle", "MetricsConstants" ]
  }, {
    "name" : "private native PersistableBundle native_getMetrics()",
    "returnType" : "PersistableBundle",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public native boolean isPlaying()",
    "returnType" : "boolean",
    "comment" : "\n     * Checks whether the MediaPlayer is playing.\n     *\n     * @return true if currently playing, false otherwise\n     * @throws IllegalStateException if the internal player engine has not been\n     * initialized or has been released.\n     ",
    "links" : [ ]
  }, {
    "name" : "public PlaybackParams easyPlaybackParams(float rate, @PlaybackRateAudioMode int audioMode)",
    "returnType" : "PlaybackParams",
    "comment" : "\n     * Sets playback rate and audio mode.\n     *\n     * @param rate the ratio between desired playback rate and normal one.\n     * @param audioMode audio playback mode. Must be one of the supported\n     * audio modes.\n     *\n     * @throws IllegalStateException if the internal player engine has not been\n     * initialized.\n     * @throws IllegalArgumentException if audioMode is not supported.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public native void setPlaybackParams(@NonNull PlaybackParams params)",
    "returnType" : "void",
    "comment" : "\n     * Sets playback rate using {@link PlaybackParams}. The object sets its internal\n     * PlaybackParams to the input, except that the object remembers previous speed\n     * when input speed is zero. This allows the object to resume at previous speed\n     * when start() is called. Calling it before the object is prepared does not change\n     * the object state. After the object is prepared, calling it with zero speed is\n     * equivalent to calling pause(). After the object is prepared, calling it with\n     * non-zero speed is equivalent to calling start().\n     *\n     * @param params the playback params.\n     *\n     * @throws IllegalStateException if the internal player engine has not been\n     * initialized or has been released.\n     * @throws IllegalArgumentException if params is not supported.\n     ",
    "links" : [ "PlaybackParams" ]
  }, {
    "name" : "public native PlaybackParams getPlaybackParams()",
    "returnType" : "PlaybackParams",
    "comment" : "\n     * Gets the playback params, containing the current playback rate.\n     *\n     * @return the playback params.\n     * @throws IllegalStateException if the internal player engine has not been\n     * initialized.\n     ",
    "links" : [ ]
  }, {
    "name" : "public native void setSyncParams(@NonNull SyncParams params)",
    "returnType" : "void",
    "comment" : "\n     * Sets A/V sync mode.\n     *\n     * @param params the A/V sync params to apply\n     *\n     * @throws IllegalStateException if the internal player engine has not been\n     * initialized.\n     * @throws IllegalArgumentException if params are not supported.\n     ",
    "links" : [ ]
  }, {
    "name" : "public native SyncParams getSyncParams()",
    "returnType" : "SyncParams",
    "comment" : "\n     * Gets the A/V sync mode.\n     *\n     * @return the A/V sync params\n     *\n     * @throws IllegalStateException if the internal player engine has not been\n     * initialized.\n     ",
    "links" : [ ]
  }, {
    "name" : "private final native void _seekTo(long msec, int mode)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public void seekTo(long msec, @SeekMode int mode)",
    "returnType" : "void",
    "comment" : "\n     * Moves the media to specified time position by considering the given mode.\n     * <p>\n     * When seekTo is finished, the user will be notified via OnSeekComplete supplied by the user.\n     * There is at most one active seekTo processed at any time. If there is a to-be-completed\n     * seekTo, new seekTo requests will be queued in such a way that only the last request\n     * is kept. When current seekTo is completed, the queued request will be processed if\n     * that request is different from just-finished seekTo operation, i.e., the requested\n     * position or mode is different.\n     *\n     * @param msec the offset in milliseconds from the start to seek to.\n     * When seeking to the given time position, there is no guarantee that the data source\n     * has a frame located at the position. When this happens, a frame nearby will be rendered.\n     * If msec is negative, time position zero will be used.\n     * If msec is larger than duration, duration will be used.\n     * @param mode the mode indicating where exactly to seek to.\n     * Use {@link #SEEK_PREVIOUS_SYNC} if one wants to seek to a sync frame\n     * that has a timestamp earlier than or the same as msec. Use\n     * {@link #SEEK_NEXT_SYNC} if one wants to seek to a sync frame\n     * that has a timestamp later than or the same as msec. Use\n     * {@link #SEEK_CLOSEST_SYNC} if one wants to seek to a sync frame\n     * that has a timestamp closest to or the same as msec. Use\n     * {@link #SEEK_CLOSEST} if one wants to seek to a frame that may\n     * or may not be a sync frame but is closest to or the same as msec.\n     * {@link #SEEK_CLOSEST} often has larger performance overhead compared\n     * to the other options if there is no sync frame located at msec.\n     * @throws IllegalStateException if the internal player engine has not been\n     * initialized\n     * @throws IllegalArgumentException if the mode is invalid.\n     ",
    "links" : [ "#SEEK_PREVIOUS_SYNC", "#SEEK_NEXT_SYNC", "#SEEK_CLOSEST_SYNC", "#SEEK_CLOSEST", "#SEEK_CLOSEST" ]
  }, {
    "name" : "public void seekTo(int msec) throws IllegalStateException",
    "returnType" : "void",
    "comment" : "\n     * Seeks to specified time position.\n     * Same as {@link #seekTo(long, int)} with {@code mode = SEEK_PREVIOUS_SYNC}.\n     *\n     * @param msec the offset in milliseconds from the start to seek to\n     * @throws IllegalStateException if the internal player engine has not been\n     * initialized\n     ",
    "links" : [ "#seekTo" ]
  }, {
    "name" : "public MediaTimestamp getTimestamp()",
    "returnType" : "MediaTimestamp",
    "comment" : "\n     * Get current playback position as a {@link MediaTimestamp}.\n     * <p>\n     * The MediaTimestamp represents how the media time correlates to the system time in\n     * a linear fashion using an anchor and a clock rate. During regular playback, the media\n     * time moves fairly constantly (though the anchor frame may be rebased to a current\n     * system time, the linear correlation stays steady). Therefore, this method does not\n     * need to be called often.\n     * <p>\n     * To help users get current playback position, this method always anchors the timestamp\n     * to the current {@link System#nanoTime system time}, so\n     * {@link MediaTimestamp#getAnchorMediaTimeUs} can be used as current playback position.\n     *\n     * @return a MediaTimestamp object if a timestamp is available, or {@code null} if no timestamp\n     *         is available, e.g. because the media player has not been initialized.\n     *\n     * @see MediaTimestamp\n     ",
    "links" : [ "MediaTimestamp", "System#nanoTime", "MediaTimestamp#getAnchorMediaTimeUs" ]
  }, {
    "name" : "public native int getCurrentPosition()",
    "returnType" : "int",
    "comment" : "\n     * Gets the current playback position.\n     *\n     * @return the current position in milliseconds\n     ",
    "links" : [ ]
  }, {
    "name" : "public native int getDuration()",
    "returnType" : "int",
    "comment" : "\n     * Gets the duration of the file.\n     *\n     * @return the duration in milliseconds, if no duration is available\n     *         (for example, if streaming live content), -1 is returned.\n     ",
    "links" : [ ]
  }, {
    "name" : "public Metadata getMetadata(final boolean update_only, final boolean apply_filter)",
    "returnType" : "Metadata",
    "comment" : "\n     * Gets the media metadata.\n     *\n     * @param update_only controls whether the full set of available\n     * metadata is returned or just the set that changed since the\n     * last call. See {@see #METADATA_UPDATE_ONLY} and {@see\n     * #METADATA_ALL}.\n     *\n     * @param apply_filter if true only metadata that matches the\n     * filter is returned. See {@see #APPLY_METADATA_FILTER} and {@see\n     * #BYPASS_METADATA_FILTER}.\n     *\n     * @return The metadata, possibly empty. null if an error occured.\n     // FIXME: unhide.\n     * {@hide}\n     ",
    "links" : [ ]
  }, {
    "name" : "public int setMetadataFilter(Set<Integer> allow, Set<Integer> block)",
    "returnType" : "int",
    "comment" : "\n     * Set a filter for the metadata update notification and update\n     * retrieval. The caller provides 2 set of metadata keys, allowed\n     * and blocked. The blocked set always takes precedence over the\n     * allowed one.\n     * Metadata.MATCH_ALL and Metadata.MATCH_NONE are 2 sets available as\n     * shorthands to allow/block all or no metadata.\n     *\n     * By default, there is no filter set.\n     *\n     * @param allow Is the set of metadata the client is interested\n     *              in receiving new notifications for.\n     * @param block Is the set of metadata the client is not interested\n     *              in receiving new notifications for.\n     * @return The call status code.\n     *\n     // FIXME: unhide.\n     * {@hide}\n     ",
    "links" : [ ]
  }, {
    "name" : "public native void setNextMediaPlayer(MediaPlayer next)",
    "returnType" : "void",
    "comment" : "\n     * Set the MediaPlayer to start when this MediaPlayer finishes playback\n     * (i.e. reaches the end of the stream).\n     * The media framework will attempt to transition from this player to\n     * the next as seamlessly as possible. The next player can be set at\n     * any time before completion, but shall be after setDataSource has been\n     * called successfully. The next player must be prepared by the\n     * app, and the application should not call start() on it.\n     * The next MediaPlayer must be different from 'this'. An exception\n     * will be thrown if next == this.\n     * The application may call setNextMediaPlayer(null) to indicate no\n     * next player should be started at the end of playback.\n     * If the current player is looping, it will keep looping and the next\n     * player will not be started.\n     *\n     * @param next the player to start after this one completes playback.\n     *\n     ",
    "links" : [ ]
  }, {
    "name" : "public void release()",
    "returnType" : "void",
    "comment" : "\n     * Releases resources associated with this MediaPlayer object.\n     * It is considered good practice to call this method when you're\n     * done using the MediaPlayer. In particular, whenever an Activity\n     * of an application is paused (its onPause() method is called),\n     * or stopped (its onStop() method is called), this method should be\n     * invoked to release the MediaPlayer object, unless the application\n     * has a special need to keep the object around. In addition to\n     * unnecessary resources (such as memory and instances of codecs)\n     * being held, failure to call this method immediately if a\n     * MediaPlayer object is no longer needed may also lead to\n     * continuous battery consumption for mobile devices, and playback\n     * failure for other applications if no multiple instances of the\n     * same codec are supported on a device. Even if multiple instances\n     * of the same codec are supported, some performance degradation\n     * may be expected when unnecessary multiple instances are used\n     * at the same time.\n     ",
    "links" : [ ]
  }, {
    "name" : "private native void _release()",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public void reset()",
    "returnType" : "void",
    "comment" : "\n     * Resets the MediaPlayer to its uninitialized state. After calling\n     * this method, you will have to initialize it again by setting the\n     * data source and calling prepare().\n     ",
    "links" : [ ]
  }, {
    "name" : "private native void _reset()",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public void notifyAt(long mediaTimeUs)",
    "returnType" : "void",
    "comment" : "\n     * Set up a timer for {@link #TimeProvider}. {@link #TimeProvider} will be\n     * notified when the presentation time reaches (becomes greater than or equal to)\n     * the value specified.\n     *\n     * @param mediaTimeUs presentation time to get timed event callback at\n     * @hide\n     ",
    "links" : [ "#TimeProvider", "#TimeProvider" ]
  }, {
    "name" : "private native void _notifyAt(long mediaTimeUs)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public void setAudioStreamType(int streamtype)",
    "returnType" : "void",
    "comment" : "\n     * Sets the audio stream type for this MediaPlayer. See {@link AudioManager}\n     * for a list of stream types. Must call this method before prepare() or\n     * prepareAsync() in order for the target stream type to become effective\n     * thereafter.\n     *\n     * @param streamtype the audio stream type\n     * @deprecated use {@link #setAudioAttributes(AudioAttributes)}\n     * @see android.media.AudioManager\n     ",
    "links" : [ "AudioManager", "#setAudioAttributes" ]
  }, {
    "name" : "private native void _setAudioStreamType(int streamtype)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private native boolean setParameter(int key, Parcel value)",
    "returnType" : "boolean",
    "comment" : "\n     * Sets the parameter indicated by key.\n     * @param key key indicates the parameter to be set.\n     * @param value value of the parameter to be set.\n     * @return true if the parameter is set successfully, false otherwise\n     * {@hide}\n     ",
    "links" : [ ]
  }, {
    "name" : "public void setAudioAttributes(AudioAttributes attributes) throws IllegalArgumentException",
    "returnType" : "void",
    "comment" : "\n     * Sets the audio attributes for this MediaPlayer.\n     * See {@link AudioAttributes} for how to build and configure an instance of this class.\n     * You must call this method before {@link #prepare()} or {@link #prepareAsync()} in order\n     * for the audio attributes to become effective thereafter.\n     * @param attributes a non-null set of audio attributes\n     ",
    "links" : [ "AudioAttributes", "#prepare", "#prepareAsync" ]
  }, {
    "name" : "public native void setLooping(boolean looping)",
    "returnType" : "void",
    "comment" : "\n     * Sets the player to be looping or non-looping.\n     *\n     * @param looping whether to loop or not\n     ",
    "links" : [ ]
  }, {
    "name" : "public native boolean isLooping()",
    "returnType" : "boolean",
    "comment" : "\n     * Checks whether the MediaPlayer is looping or non-looping.\n     *\n     * @return true if the MediaPlayer is currently looping, false otherwise\n     ",
    "links" : [ ]
  }, {
    "name" : "public void setVolume(float leftVolume, float rightVolume)",
    "returnType" : "void",
    "comment" : "\n     * FIXME: Merge this into javadoc comment above when setVolume(float) is not @hide.\n     * The single parameter form below is preferred if the channel volumes don't need\n     * to be set independently.\n     ",
    "links" : [ ]
  }, {
    "name" : " void playerSetVolume(boolean muting, float leftVolume, float rightVolume)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private native void _setVolume(float leftVolume, float rightVolume)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public void setVolume(float volume)",
    "returnType" : "void",
    "comment" : "\n     * Similar, excepts sets volume of all channels to same value.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public native void setAudioSessionId(int sessionId) throws IllegalArgumentException, IllegalStateException",
    "returnType" : "void",
    "comment" : "\n     * Sets the audio session ID.\n     *\n     * @param sessionId the audio session ID.\n     * The audio session ID is a system wide unique identifier for the audio stream played by\n     * this MediaPlayer instance.\n     * The primary use of the audio session ID  is to associate audio effects to a particular\n     * instance of MediaPlayer: if an audio session ID is provided when creating an audio effect,\n     * this effect will be applied only to the audio content of media players within the same\n     * audio session and not to the output mix.\n     * When created, a MediaPlayer instance automatically generates its own audio session ID.\n     * However, it is possible to force this player to be part of an already existing audio session\n     * by calling this method.\n     * This method must be called before one of the overloaded <code> setDataSource </code> methods.\n     * @throws IllegalStateException if it is called in an invalid state\n     ",
    "links" : [ ]
  }, {
    "name" : "public native int getAudioSessionId()",
    "returnType" : "int",
    "comment" : "\n     * Returns the audio session ID.\n     *\n     * @return the audio session ID. {@see #setAudioSessionId(int)}\n     * Note that the audio session ID is 0 only if a problem occured when the MediaPlayer was contructed.\n     ",
    "links" : [ ]
  }, {
    "name" : "public native void attachAuxEffect(int effectId)",
    "returnType" : "void",
    "comment" : "\n     * Attaches an auxiliary effect to the player. A typical auxiliary effect is a reverberation\n     * effect which can be applied on any sound source that directs a certain amount of its\n     * energy to this effect. This amount is defined by setAuxEffectSendLevel().\n     * See {@link #setAuxEffectSendLevel(float)}.\n     * <p>After creating an auxiliary effect (e.g.\n     * {@link android.media.audiofx.EnvironmentalReverb}), retrieve its ID with\n     * {@link android.media.audiofx.AudioEffect#getId()} and use it when calling this method\n     * to attach the player to the effect.\n     * <p>To detach the effect from the player, call this method with a null effect id.\n     * <p>This method must be called after one of the overloaded <code> setDataSource </code>\n     * methods.\n     * @param effectId system wide unique id of the effect to attach\n     ",
    "links" : [ "#setAuxEffectSendLevel", "android.media.audiofx.EnvironmentalReverb", "android.media.audiofx.AudioEffect#getId" ]
  }, {
    "name" : "public void setAuxEffectSendLevel(float level)",
    "returnType" : "void",
    "comment" : "\n     * Sets the send level of the player to the attached auxiliary effect.\n     * See {@link #attachAuxEffect(int)}. The level value range is 0 to 1.0.\n     * <p>By default the send level is 0, so even if an effect is attached to the player\n     * this method must be called for the effect to be applied.\n     * <p>Note that the passed level value is a raw scalar. UI controls should be scaled\n     * logarithmically: the gain applied by audio framework ranges from -72dB to 0dB,\n     * so an appropriate conversion from linear UI input x to level is:\n     * x == 0 -> level = 0\n     * 0 < x <= R -> level = 10^(72*(x-R)/20/R)\n     * @param level send level scalar\n     ",
    "links" : [ "#attachAuxEffect" ]
  }, {
    "name" : " int playerSetAuxEffectSendLevel(boolean muting, float level)",
    "returnType" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private native void _setAuxEffectSendLevel(float level)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private final native int native_invoke(Parcel request, Parcel reply)",
    "returnType" : "int",
    "comment" : "\n     * @param request Parcel destinated to the media player. The\n     *                Interface token must be set to the IMediaPlayer\n     *                one to be routed correctly through the system.\n     * @param reply[out] Parcel that will contain the reply.\n     * @return The status code.\n     ",
    "links" : [ ]
  }, {
    "name" : "private final native boolean native_getMetadata(boolean update_only, boolean apply_filter, Parcel reply)",
    "returnType" : "boolean",
    "comment" : "\n     * @param update_only If true fetch only the set of metadata that have\n     *                    changed since the last invocation of getMetadata.\n     *                    The set is built using the unfiltered\n     *                    notifications the native player sent to the\n     *                    MediaPlayerService during that period of\n     *                    time. If false, all the metadatas are considered.\n     * @param apply_filter  If true, once the metadata set has been built based on\n     *                     the value update_only, the current filter is applied.\n     * @param reply[out] On return contains the serialized\n     *                   metadata. Valid only if the call was successful.\n     * @return The status code.\n     ",
    "links" : [ ]
  }, {
    "name" : "private final native int native_setMetadataFilter(Parcel request)",
    "returnType" : "int",
    "comment" : "\n     * @param request Parcel with the 2 serialized lists of allowed\n     *                metadata types followed by the one to be\n     *                dropped. Each list starts with an integer\n     *                indicating the number of metadata type elements.\n     * @return The status code.\n     ",
    "links" : [ ]
  }, {
    "name" : "private static final native void native_init()",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private final native void native_setup(Object mediaplayer_this)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private final native void native_finalize()",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public TrackInfo[] getTrackInfo() throws IllegalStateException",
    "returnType" : "TrackInfo[]",
    "comment" : "\n     * Returns an array of track information.\n     *\n     * @return Array of track info. The total number of tracks is the array length.\n     * Must be called again if an external timed text source has been added after any of the\n     * addTimedTextSource methods are called.\n     * @throws IllegalStateException if it is called in an invalid state.\n     ",
    "links" : [ ]
  }, {
    "name" : "private TrackInfo[] getInbandTrackInfo() throws IllegalStateException",
    "returnType" : "TrackInfo[]",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private static boolean availableMimeTypeForExternalSource(String mimeType)",
    "returnType" : "boolean",
    "comment" : "\n     * A helper function to check if the mime type is supported by media framework.\n     ",
    "links" : [ ]
  }, {
    "name" : "public void setSubtitleAnchor(SubtitleController controller, SubtitleController.Anchor anchor)",
    "returnType" : "void",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "private synchronized void setSubtitleAnchor()",
    "returnType" : "void",
    "comment" : "\n     * The private version of setSubtitleAnchor is used internally to set mSubtitleController if\n     * necessary when clients don't provide their own SubtitleControllers using the public version\n     * {@link #setSubtitleAnchor(SubtitleController, Anchor)} (e.g. {@link VideoView} provides one).\n     ",
    "links" : [ "#setSubtitleAnchor", "VideoView" ]
  }, {
    "name" : "public void onSubtitleTrackSelected(SubtitleTrack track)",
    "returnType" : "void",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "public void addSubtitleSource(InputStream is, MediaFormat format) throws IllegalStateException",
    "returnType" : "void",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "private void scanInternalSubtitleTracks()",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private void populateInbandTracks()",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public void addTimedTextSource(String path, String mimeType) throws IOException, IllegalArgumentException, IllegalStateException",
    "returnType" : "void",
    "comment" : "\n     * Adds an external timed text source file.\n     *\n     * Currently supported format is SubRip with the file extension .srt, case insensitive.\n     * Note that a single external timed text source may contain multiple tracks in it.\n     * One can find the total number of available tracks using {@link #getTrackInfo()} to see what\n     * additional tracks become available after this method call.\n     *\n     * @param path The file path of external timed text source file.\n     * @param mimeType The mime type of the file. Must be one of the mime types listed above.\n     * @throws IOException if the file cannot be accessed or is corrupted.\n     * @throws IllegalArgumentException if the mimeType is not supported.\n     * @throws IllegalStateException if called in an invalid state.\n     ",
    "links" : [ "#getTrackInfo" ]
  }, {
    "name" : "public void addTimedTextSource(Context context, Uri uri, String mimeType) throws IOException, IllegalArgumentException, IllegalStateException",
    "returnType" : "void",
    "comment" : "\n     * Adds an external timed text source file (Uri).\n     *\n     * Currently supported format is SubRip with the file extension .srt, case insensitive.\n     * Note that a single external timed text source may contain multiple tracks in it.\n     * One can find the total number of available tracks using {@link #getTrackInfo()} to see what\n     * additional tracks become available after this method call.\n     *\n     * @param context the Context to use when resolving the Uri\n     * @param uri the Content URI of the data you want to play\n     * @param mimeType The mime type of the file. Must be one of the mime types listed above.\n     * @throws IOException if the file cannot be accessed or is corrupted.\n     * @throws IllegalArgumentException if the mimeType is not supported.\n     * @throws IllegalStateException if called in an invalid state.\n     ",
    "links" : [ "#getTrackInfo" ]
  }, {
    "name" : "public void addTimedTextSource(FileDescriptor fd, String mimeType) throws IllegalArgumentException, IllegalStateException",
    "returnType" : "void",
    "comment" : "\n     * Adds an external timed text source file (FileDescriptor).\n     *\n     * It is the caller's responsibility to close the file descriptor.\n     * It is safe to do so as soon as this call returns.\n     *\n     * Currently supported format is SubRip. Note that a single external timed text source may\n     * contain multiple tracks in it. One can find the total number of available tracks\n     * using {@link #getTrackInfo()} to see what additional tracks become available\n     * after this method call.\n     *\n     * @param fd the FileDescriptor for the file you want to play\n     * @param mimeType The mime type of the file. Must be one of the mime types listed above.\n     * @throws IllegalArgumentException if the mimeType is not supported.\n     * @throws IllegalStateException if called in an invalid state.\n     ",
    "links" : [ "#getTrackInfo" ]
  }, {
    "name" : "public void addTimedTextSource(FileDescriptor fd, long offset, long length, String mime) throws IllegalArgumentException, IllegalStateException",
    "returnType" : "void",
    "comment" : "\n     * Adds an external timed text file (FileDescriptor).\n     *\n     * It is the caller's responsibility to close the file descriptor.\n     * It is safe to do so as soon as this call returns.\n     *\n     * Currently supported format is SubRip. Note that a single external timed text source may\n     * contain multiple tracks in it. One can find the total number of available tracks\n     * using {@link #getTrackInfo()} to see what additional tracks become available\n     * after this method call.\n     *\n     * @param fd the FileDescriptor for the file you want to play\n     * @param offset the offset into the file where the data to be played starts, in bytes\n     * @param length the length in bytes of the data to be played\n     * @param mime The mime type of the file. Must be one of the mime types listed above.\n     * @throws IllegalArgumentException if the mimeType is not supported.\n     * @throws IllegalStateException if called in an invalid state.\n     ",
    "links" : [ "#getTrackInfo" ]
  }, {
    "name" : "public int getSelectedTrack(int trackType) throws IllegalStateException",
    "returnType" : "int",
    "comment" : "\n     * Returns the index of the audio, video, or subtitle track currently selected for playback,\n     * The return value is an index into the array returned by {@link #getTrackInfo()}, and can\n     * be used in calls to {@link #selectTrack(int)} or {@link #deselectTrack(int)}.\n     *\n     * @param trackType should be one of {@link TrackInfo#MEDIA_TRACK_TYPE_VIDEO},\n     * {@link TrackInfo#MEDIA_TRACK_TYPE_AUDIO}, or\n     * {@link TrackInfo#MEDIA_TRACK_TYPE_SUBTITLE}\n     * @return index of the audio, video, or subtitle track currently selected for playback;\n     * a negative integer is returned when there is no selected track for {@code trackType} or\n     * when {@code trackType} is not one of audio, video, or subtitle.\n     * @throws IllegalStateException if called after {@link #release()}\n     *\n     * @see #getTrackInfo()\n     * @see #selectTrack(int)\n     * @see #deselectTrack(int)\n     ",
    "links" : [ "#getTrackInfo", "#selectTrack", "#deselectTrack", "TrackInfo#MEDIA_TRACK_TYPE_VIDEO", "TrackInfo#MEDIA_TRACK_TYPE_AUDIO", "TrackInfo#MEDIA_TRACK_TYPE_SUBTITLE", "#release" ]
  }, {
    "name" : "public void selectTrack(int index) throws IllegalStateException",
    "returnType" : "void",
    "comment" : "\n     * Selects a track.\n     * <p>\n     * If a MediaPlayer is in invalid state, it throws an IllegalStateException exception.\n     * If a MediaPlayer is in <em>Started</em> state, the selected track is presented immediately.\n     * If a MediaPlayer is not in Started state, it just marks the track to be played.\n     * </p>\n     * <p>\n     * In any valid state, if it is called multiple times on the same type of track (ie. Video,\n     * Audio, Timed Text), the most recent one will be chosen.\n     * </p>\n     * <p>\n     * The first audio and video tracks are selected by default if available, even though\n     * this method is not called. However, no timed text track will be selected until\n     * this function is called.\n     * </p>\n     * <p>\n     * Currently, only timed text, subtitle or audio tracks can be selected via this method.\n     * In addition, the support for selecting an audio track at runtime is pretty limited\n     * in that an audio track can only be selected in the <em>Prepared</em> state.\n     * </p>\n     * @param index the index of the track to be selected. The valid range of the index\n     * is 0..total number of track - 1. The total number of tracks as well as the type of\n     * each individual track can be found by calling {@link #getTrackInfo()} method.\n     * @throws IllegalStateException if called in an invalid state.\n     *\n     * @see android.media.MediaPlayer#getTrackInfo\n     ",
    "links" : [ "#getTrackInfo" ]
  }, {
    "name" : "public void deselectTrack(int index) throws IllegalStateException",
    "returnType" : "void",
    "comment" : "\n     * Deselect a track.\n     * <p>\n     * Currently, the track must be a timed text track and no audio or video tracks can be\n     * deselected. If the timed text track identified by index has not been\n     * selected before, it throws an exception.\n     * </p>\n     * @param index the index of the track to be deselected. The valid range of the index\n     * is 0..total number of tracks - 1. The total number of tracks as well as the type of\n     * each individual track can be found by calling {@link #getTrackInfo()} method.\n     * @throws IllegalStateException if called in an invalid state.\n     *\n     * @see android.media.MediaPlayer#getTrackInfo\n     ",
    "links" : [ "#getTrackInfo" ]
  }, {
    "name" : "private void selectOrDeselectTrack(int index, boolean select) throws IllegalStateException",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private void selectOrDeselectInbandTrack(int index, boolean select) throws IllegalStateException",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public static native int native_pullBatteryData(Parcel reply)",
    "returnType" : "int",
    "comment" : "\n     * @param reply Parcel with audio/video duration info for battery\n                    tracking usage\n     * @return The status code.\n     * {@hide}\n     ",
    "links" : [ ]
  }, {
    "name" : "public void setRetransmitEndpoint(InetSocketAddress endpoint) throws IllegalStateException, IllegalArgumentException",
    "returnType" : "void",
    "comment" : "\n     * Sets the target UDP re-transmit endpoint for the low level player.\n     * Generally, the address portion of the endpoint is an IP multicast\n     * address, although a unicast address would be equally valid.  When a valid\n     * retransmit endpoint has been set, the media player will not decode and\n     * render the media presentation locally.  Instead, the player will attempt\n     * to re-multiplex its media data using the Android@Home RTP profile and\n     * re-transmit to the target endpoint.  Receiver devices (which may be\n     * either the same as the transmitting device or different devices) may\n     * instantiate, prepare, and start a receiver player using a setDataSource\n     * URL of the form...\n     *\n     * aahRX://&lt;multicastIP&gt;:&lt;port&gt;\n     *\n     * to receive, decode and render the re-transmitted content.\n     *\n     * setRetransmitEndpoint may only be called before setDataSource has been\n     * called; while the player is in the Idle state.\n     *\n     * @param endpoint the address and UDP port of the re-transmission target or\n     * null if no re-transmission is to be performed.\n     * @throws IllegalStateException if it is called in an invalid state\n     * @throws IllegalArgumentException if the retransmit endpoint is supplied,\n     * but invalid.\n     *\n     * {@hide} pending API council\n     ",
    "links" : [ ]
  }, {
    "name" : "private final native int native_setRetransmitEndpoint(String addrString, int port)",
    "returnType" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "protected void finalize()",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public MediaTimeProvider getMediaTimeProvider()",
    "returnType" : "MediaTimeProvider",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "private static void postEventFromNative(Object mediaplayer_ref, int what, int arg1, int arg2, Object obj)",
    "returnType" : "void",
    "comment" : "\n     * Called from native code when an interesting event happens.  This method\n     * just uses the EventHandler system to post the event back to the main app thread.\n     * We use a weak reference to the original MediaPlayer object so that the native\n     * code is safe from the object disappearing from underneath it.  (This is\n     * the cookie passed to native_setup().)\n     ",
    "links" : [ ]
  }, {
    "name" : "public void setOnPreparedListener(OnPreparedListener listener)",
    "returnType" : "void",
    "comment" : "\n     * Register a callback to be invoked when the media source is ready\n     * for playback.\n     *\n     * @param listener the callback that will be run\n     ",
    "links" : [ ]
  }, {
    "name" : "public void setOnCompletionListener(OnCompletionListener listener)",
    "returnType" : "void",
    "comment" : "\n     * Register a callback to be invoked when the end of a media source\n     * has been reached during playback.\n     *\n     * @param listener the callback that will be run\n     ",
    "links" : [ ]
  }, {
    "name" : "public void setOnBufferingUpdateListener(OnBufferingUpdateListener listener)",
    "returnType" : "void",
    "comment" : "\n     * Register a callback to be invoked when the status of a network\n     * stream's buffer has changed.\n     *\n     * @param listener the callback that will be run.\n     ",
    "links" : [ ]
  }, {
    "name" : "public void setOnSeekCompleteListener(OnSeekCompleteListener listener)",
    "returnType" : "void",
    "comment" : "\n     * Register a callback to be invoked when a seek operation has been\n     * completed.\n     *\n     * @param listener the callback that will be run\n     ",
    "links" : [ ]
  }, {
    "name" : "public void setOnVideoSizeChangedListener(OnVideoSizeChangedListener listener)",
    "returnType" : "void",
    "comment" : "\n     * Register a callback to be invoked when the video size is\n     * known or updated.\n     *\n     * @param listener the callback that will be run\n     ",
    "links" : [ ]
  }, {
    "name" : "public void setOnTimedTextListener(OnTimedTextListener listener)",
    "returnType" : "void",
    "comment" : "\n     * Register a callback to be invoked when a timed text is available\n     * for display.\n     *\n     * @param listener the callback that will be run\n     ",
    "links" : [ ]
  }, {
    "name" : "public void setOnSubtitleDataListener(@NonNull OnSubtitleDataListener listener, @NonNull Handler handler)",
    "returnType" : "void",
    "comment" : "\n     * Sets the listener to be invoked when a subtitle track has new data available.\n     * The subtitle data comes from a subtitle track previously selected with\n     * {@link #selectTrack(int)}. Use {@link #getTrackInfo()} to determine which tracks are\n     * subtitles (of type {@link TrackInfo#MEDIA_TRACK_TYPE_SUBTITLE}), Subtitle track encodings\n     * can be determined by {@link TrackInfo#getFormat()}).<br>\n     * See {@link SubtitleData} for an example of querying subtitle encoding.\n     * @param listener the listener called when new data is available\n     * @param handler the {@link Handler} that receives the listener events\n     ",
    "links" : [ "#selectTrack", "#getTrackInfo", "TrackInfo#MEDIA_TRACK_TYPE_SUBTITLE", "TrackInfo#getFormat", "SubtitleData", "Handler" ]
  }, {
    "name" : "public void setOnSubtitleDataListener(@NonNull OnSubtitleDataListener listener)",
    "returnType" : "void",
    "comment" : "\n     * Sets the listener to be invoked when a subtitle track has new data available.\n     * The subtitle data comes from a subtitle track previously selected with\n     * {@link #selectTrack(int)}. Use {@link #getTrackInfo()} to determine which tracks are\n     * subtitles (of type {@link TrackInfo#MEDIA_TRACK_TYPE_SUBTITLE}), Subtitle track encodings\n     * can be determined by {@link TrackInfo#getFormat()}).<br>\n     * See {@link SubtitleData} for an example of querying subtitle encoding.<br>\n     * The listener will be called on the same thread as the one in which the MediaPlayer was\n     * created.\n     * @param listener the listener called when new data is available\n     ",
    "links" : [ "#selectTrack", "#getTrackInfo", "TrackInfo#MEDIA_TRACK_TYPE_SUBTITLE", "TrackInfo#getFormat", "SubtitleData" ]
  }, {
    "name" : "public void clearOnSubtitleDataListener()",
    "returnType" : "void",
    "comment" : "\n     * Clears the listener previously set with\n     * {@link #setOnSubtitleDataListener(OnSubtitleDataListener)} or\n     * {@link #setOnSubtitleDataListener(OnSubtitleDataListener, Handler)}.\n     ",
    "links" : [ "#setOnSubtitleDataListener", "#setOnSubtitleDataListener" ]
  }, {
    "name" : "private void setOnSubtitleDataListenerInt(@Nullable OnSubtitleDataListener listener, @Nullable Handler handler)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public void setOnMediaTimeDiscontinuityListener(@NonNull OnMediaTimeDiscontinuityListener listener, @NonNull Handler handler)",
    "returnType" : "void",
    "comment" : "\n     * Sets the listener to be invoked when a media time discontinuity is encountered.\n     * @param listener the listener called after a discontinuity\n     * @param handler the {@link Handler} that receives the listener events\n     ",
    "links" : [ "Handler" ]
  }, {
    "name" : "public void setOnMediaTimeDiscontinuityListener(@NonNull OnMediaTimeDiscontinuityListener listener)",
    "returnType" : "void",
    "comment" : "\n     * Sets the listener to be invoked when a media time discontinuity is encountered.\n     * The listener will be called on the same thread as the one in which the MediaPlayer was\n     * created.\n     * @param listener the listener called after a discontinuity\n     ",
    "links" : [ ]
  }, {
    "name" : "public void clearOnMediaTimeDiscontinuityListener()",
    "returnType" : "void",
    "comment" : "\n     * Clears the listener previously set with\n     * {@link #setOnMediaTimeDiscontinuityListener(OnMediaTimeDiscontinuityListener)}\n     * or {@link #setOnMediaTimeDiscontinuityListener(OnMediaTimeDiscontinuityListener, Handler)}\n     ",
    "links" : [ "#setOnMediaTimeDiscontinuityListener", "#setOnMediaTimeDiscontinuityListener" ]
  }, {
    "name" : "private void setOnMediaTimeDiscontinuityListenerInt(@Nullable OnMediaTimeDiscontinuityListener listener, @Nullable Handler handler)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public void setOnTimedMetaDataAvailableListener(OnTimedMetaDataAvailableListener listener)",
    "returnType" : "void",
    "comment" : "\n     * Register a callback to be invoked when a selected track has timed metadata available.\n     * <p>\n     * Currently only HTTP live streaming data URI's embedded with timed ID3 tags generates\n     * {@link TimedMetaData}.\n     *\n     * @see MediaPlayer#selectTrack(int)\n     * @see MediaPlayer.OnTimedMetaDataAvailableListener\n     * @see TimedMetaData\n     *\n     * @param listener the callback that will be run\n     ",
    "links" : [ "TimedMetaData" ]
  }, {
    "name" : "public void setOnErrorListener(OnErrorListener listener)",
    "returnType" : "void",
    "comment" : "\n     * Register a callback to be invoked when an error has happened\n     * during an asynchronous operation.\n     *\n     * @param listener the callback that will be run\n     ",
    "links" : [ ]
  }, {
    "name" : "public void setOnInfoListener(OnInfoListener listener)",
    "returnType" : "void",
    "comment" : "\n     * Register a callback to be invoked when an info/warning is available.\n     *\n     * @param listener the callback that will be run\n     ",
    "links" : [ ]
  }, {
    "name" : "public void setOnDrmConfigHelper(OnDrmConfigHelper listener)",
    "returnType" : "void",
    "comment" : "\n     * Register a callback to be invoked for configuration of the DRM object before\n     * the session is created.\n     * The callback will be invoked synchronously during the execution\n     * of {@link #prepareDrm(UUID uuid)}.\n     *\n     * @param listener the callback that will be run\n     ",
    "links" : [ "#prepareDrm" ]
  }, {
    "name" : "public void setOnDrmInfoListener(OnDrmInfoListener listener)",
    "returnType" : "void",
    "comment" : "\n     * Register a callback to be invoked when the DRM info is\n     * known.\n     *\n     * @param listener the callback that will be run\n     ",
    "links" : [ ]
  }, {
    "name" : "public void setOnDrmInfoListener(OnDrmInfoListener listener, Handler handler)",
    "returnType" : "void",
    "comment" : "\n     * Register a callback to be invoked when the DRM info is\n     * known.\n     *\n     * @param listener the callback that will be run\n     ",
    "links" : [ ]
  }, {
    "name" : "public void setOnDrmPreparedListener(OnDrmPreparedListener listener)",
    "returnType" : "void",
    "comment" : "\n     * Register a callback to be invoked when the DRM object is prepared.\n     *\n     * @param listener the callback that will be run\n     ",
    "links" : [ ]
  }, {
    "name" : "public void setOnDrmPreparedListener(OnDrmPreparedListener listener, Handler handler)",
    "returnType" : "void",
    "comment" : "\n     * Register a callback to be invoked when the DRM object is prepared.\n     *\n     * @param listener the callback that will be run\n     * @param handler the Handler that will receive the callback\n     ",
    "links" : [ ]
  }, {
    "name" : "public DrmInfo getDrmInfo()",
    "returnType" : "DrmInfo",
    "comment" : "\n     * Retrieves the DRM Info associated with the current source\n     *\n     * @throws IllegalStateException if called before prepare()\n     ",
    "links" : [ ]
  }, {
    "name" : "public void prepareDrm(@NonNull UUID uuid) throws UnsupportedSchemeException, ResourceBusyException, ProvisioningNetworkErrorException, ProvisioningServerErrorException",
    "returnType" : "void",
    "comment" : "\n     * Prepares the DRM for the current source\n     * <p>\n     * If {@code OnDrmConfigHelper} is registered, it will be called during\n     * preparation to allow configuration of the DRM properties before opening the\n     * DRM session. Note that the callback is called synchronously in the thread that called\n     * {@code prepareDrm}. It should be used only for a series of {@code getDrmPropertyString}\n     * and {@code setDrmPropertyString} calls and refrain from any lengthy operation.\n     * <p>\n     * If the device has not been provisioned before, this call also provisions the device\n     * which involves accessing the provisioning server and can take a variable time to\n     * complete depending on the network connectivity.\n     * If {@code OnDrmPreparedListener} is registered, prepareDrm() runs in non-blocking\n     * mode by launching the provisioning in the background and returning. The listener\n     * will be called when provisioning and preparation has finished. If a\n     * {@code OnDrmPreparedListener} is not registered, prepareDrm() waits till provisioning\n     * and preparation has finished, i.e., runs in blocking mode.\n     * <p>\n     * If {@code OnDrmPreparedListener} is registered, it is called to indicate the DRM\n     * session being ready. The application should not make any assumption about its call\n     * sequence (e.g., before or after prepareDrm returns), or the thread context that will\n     * execute the listener (unless the listener is registered with a handler thread).\n     * <p>\n     *\n     * @param uuid The UUID of the crypto scheme. If not known beforehand, it can be retrieved\n     * from the source through {@code getDrmInfo} or registering a {@code onDrmInfoListener}.\n     *\n     * @throws IllegalStateException              if called before prepare(), or the DRM was\n     *                                            prepared already\n     * @throws UnsupportedSchemeException         if the crypto scheme is not supported\n     * @throws ResourceBusyException              if required DRM resources are in use\n     * @throws ProvisioningNetworkErrorException  if provisioning is required but failed due to a\n     *                                            network error\n     * @throws ProvisioningServerErrorException   if provisioning is required but failed due to\n     *                                            the request denied by the provisioning server\n     ",
    "links" : [ ]
  }, {
    "name" : "private native void _releaseDrm()",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public void releaseDrm() throws NoDrmSchemeException",
    "returnType" : "void",
    "comment" : "\n     * Releases the DRM session\n     * <p>\n     * The player has to have an active DRM session and be in stopped, or prepared\n     * state before this call is made.\n     * A {@code reset()} call will release the DRM session implicitly.\n     *\n     * @throws NoDrmSchemeException if there is no active DRM session to release\n     ",
    "links" : [ ]
  }, {
    "name" : "public MediaDrm.KeyRequest getKeyRequest(@Nullable byte[] keySetId, @Nullable byte[] initData, @Nullable String mimeType, @MediaDrm.KeyType int keyType, @Nullable Map<String, String> optionalParameters) throws NoDrmSchemeException",
    "returnType" : "MediaDrm.KeyRequest",
    "comment" : "\n     * A key request/response exchange occurs between the app and a license server\n     * to obtain or release keys used to decrypt encrypted content.\n     * <p>\n     * getKeyRequest() is used to obtain an opaque key request byte array that is\n     * delivered to the license server.  The opaque key request byte array is returned\n     * in KeyRequest.data.  The recommended URL to deliver the key request to is\n     * returned in KeyRequest.defaultUrl.\n     * <p>\n     * After the app has received the key request response from the server,\n     * it should deliver to the response to the DRM engine plugin using the method\n     * {@link #provideKeyResponse}.\n     *\n     * @param keySetId is the key-set identifier of the offline keys being released when keyType is\n     * {@link MediaDrm#KEY_TYPE_RELEASE}. It should be set to null for other key requests, when\n     * keyType is {@link MediaDrm#KEY_TYPE_STREAMING} or {@link MediaDrm#KEY_TYPE_OFFLINE}.\n     *\n     * @param initData is the container-specific initialization data when the keyType is\n     * {@link MediaDrm#KEY_TYPE_STREAMING} or {@link MediaDrm#KEY_TYPE_OFFLINE}. Its meaning is\n     * interpreted based on the mime type provided in the mimeType parameter.  It could\n     * contain, for example, the content ID, key ID or other data obtained from the content\n     * metadata that is required in generating the key request.\n     * When the keyType is {@link MediaDrm#KEY_TYPE_RELEASE}, it should be set to null.\n     *\n     * @param mimeType identifies the mime type of the content\n     *\n     * @param keyType specifies the type of the request. The request may be to acquire\n     * keys for streaming, {@link MediaDrm#KEY_TYPE_STREAMING}, or for offline content\n     * {@link MediaDrm#KEY_TYPE_OFFLINE}, or to release previously acquired\n     * keys ({@link MediaDrm#KEY_TYPE_RELEASE}), which are identified by a keySetId.\n     *\n     * @param optionalParameters are included in the key request message to\n     * allow a client application to provide additional message parameters to the server.\n     * This may be {@code null} if no additional parameters are to be sent.\n     *\n     * @throws NoDrmSchemeException if there is no active DRM session\n     ",
    "links" : [ "#provideKeyResponse", "MediaDrm#KEY_TYPE_RELEASE", "MediaDrm#KEY_TYPE_STREAMING", "MediaDrm#KEY_TYPE_OFFLINE", "MediaDrm#KEY_TYPE_STREAMING", "MediaDrm#KEY_TYPE_OFFLINE", "MediaDrm#KEY_TYPE_RELEASE", "MediaDrm#KEY_TYPE_STREAMING", "MediaDrm#KEY_TYPE_OFFLINE", "MediaDrm#KEY_TYPE_RELEASE" ]
  }, {
    "name" : "public byte[] provideKeyResponse(@Nullable byte[] keySetId, @NonNull byte[] response) throws NoDrmSchemeException, DeniedByServerException",
    "returnType" : "byte[]",
    "comment" : "\n     * A key response is received from the license server by the app, then it is\n     * provided to the DRM engine plugin using provideKeyResponse. When the\n     * response is for an offline key request, a key-set identifier is returned that\n     * can be used to later restore the keys to a new session with the method\n     * {@ link # restoreKeys}.\n     * When the response is for a streaming or release request, null is returned.\n     *\n     * @param keySetId When the response is for a release request, keySetId identifies\n     * the saved key associated with the release request (i.e., the same keySetId\n     * passed to the earlier {@ link # getKeyRequest} call. It MUST be null when the\n     * response is for either streaming or offline key requests.\n     *\n     * @param response the byte array response from the server\n     *\n     * @throws NoDrmSchemeException if there is no active DRM session\n     * @throws DeniedByServerException if the response indicates that the\n     * server rejected the request\n     ",
    "links" : [ ]
  }, {
    "name" : "public void restoreKeys(@NonNull byte[] keySetId) throws NoDrmSchemeException",
    "returnType" : "void",
    "comment" : "\n     * Restore persisted offline keys into a new session.  keySetId identifies the\n     * keys to load, obtained from a prior call to {@link #provideKeyResponse}.\n     *\n     * @param keySetId identifies the saved key set to restore\n     ",
    "links" : [ "#provideKeyResponse" ]
  }, {
    "name" : "public String getDrmPropertyString(@NonNull @MediaDrm.StringProperty String propertyName) throws NoDrmSchemeException",
    "returnType" : "String",
    "comment" : "\n     * Read a DRM engine plugin String property value, given the property name string.\n     * <p>\n     * @param propertyName the property name\n     *\n     * Standard fields names are:\n     * {@link MediaDrm#PROPERTY_VENDOR}, {@link MediaDrm#PROPERTY_VERSION},\n     * {@link MediaDrm#PROPERTY_DESCRIPTION}, {@link MediaDrm#PROPERTY_ALGORITHMS}\n     ",
    "links" : [ "MediaDrm#PROPERTY_VENDOR", "MediaDrm#PROPERTY_VERSION", "MediaDrm#PROPERTY_DESCRIPTION", "MediaDrm#PROPERTY_ALGORITHMS" ]
  }, {
    "name" : "public void setDrmPropertyString(@NonNull @MediaDrm.StringProperty String propertyName, @NonNull String value) throws NoDrmSchemeException",
    "returnType" : "void",
    "comment" : "\n     * Set a DRM engine plugin String property value.\n     * <p>\n     * @param propertyName the property name\n     * @param value the property value\n     *\n     * Standard fields names are:\n     * {@link MediaDrm#PROPERTY_VENDOR}, {@link MediaDrm#PROPERTY_VERSION},\n     * {@link MediaDrm#PROPERTY_DESCRIPTION}, {@link MediaDrm#PROPERTY_ALGORITHMS}\n     ",
    "links" : [ "MediaDrm#PROPERTY_VENDOR", "MediaDrm#PROPERTY_VERSION", "MediaDrm#PROPERTY_DESCRIPTION", "MediaDrm#PROPERTY_ALGORITHMS" ]
  }, {
    "name" : "private native void _prepareDrm(@NonNull byte[] uuid, @NonNull byte[] drmSessionId)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private void prepareDrm_createDrmStep(@NonNull UUID uuid) throws UnsupportedSchemeException",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private void prepareDrm_openSessionStep(@NonNull UUID uuid) throws NotProvisionedException, ResourceBusyException",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private int HandleProvisioninig(UUID uuid)",
    "returnType" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private boolean resumePrepareDrm(UUID uuid)",
    "returnType" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private void resetDrmState()",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private void cleanDrmObj()",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private static final byte[] getByteArrayFromUUID(@NonNull UUID uuid)",
    "returnType" : "byte[]",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private boolean isVideoScalingModeSupported(int mode)",
    "returnType" : "boolean",
    "comment" : "\n     * Test whether a given video scaling mode is supported.\n     ",
    "links" : [ ]
  } ],
  "variableNames" : [ "METADATA_UPDATE_ONLY", "METADATA_ALL", "APPLY_METADATA_FILTER", "BYPASS_METADATA_FILTER", "TAG", "IMEDIA_PLAYER", "mNativeContext", "mNativeSurfaceTexture", "mListenerContext", "mSurfaceHolder", "mEventHandler", "mWakeLock", "mScreenOnWhilePlaying", "mStayAwake", "mStreamType", "mDrmUUID", "mDrmLock", "mDrmInfo", "mDrmObj", "mDrmSessionId", "mDrmInfoResolved", "mActiveDrmScheme", "mDrmConfigAllowed", "mDrmProvisioningInProgress", "mPrepareDrmInProgress", "mDrmProvisioningThread", "INVOKE_ID_GET_TRACK_INFO", "INVOKE_ID_ADD_EXTERNAL_SOURCE", "INVOKE_ID_ADD_EXTERNAL_SOURCE_FD", "INVOKE_ID_SELECT_TRACK", "INVOKE_ID_DESELECT_TRACK", "INVOKE_ID_SET_VIDEO_SCALE_MODE", "INVOKE_ID_GET_SELECTED_TRACK", "VIDEO_SCALING_MODE_SCALE_TO_FIT", "VIDEO_SCALING_MODE_SCALE_TO_FIT_WITH_CROPPING", "mPreferredDevice", "mRoutingChangeListeners", "PLAYBACK_RATE_AUDIO_MODE_RESAMPLE", "PLAYBACK_RATE_AUDIO_MODE_STRETCH", "PLAYBACK_RATE_AUDIO_MODE_DEFAULT", "SEEK_PREVIOUS_SYNC", "SEEK_NEXT_SYNC", "SEEK_CLOSEST_SYNC", "SEEK_CLOSEST", "KEY_PARAMETER_AUDIO_ATTRIBUTES", "mIndexTrackPairs", "mInbandTrackIndices", "MEDIA_MIMETYPE_TEXT_SUBRIP", "MEDIA_MIMETYPE_TEXT_VTT", "MEDIA_MIMETYPE_TEXT_CEA_608", "MEDIA_MIMETYPE_TEXT_CEA_708", "mSubtitleController", "mSelectedSubtitleTrackIndex", "mOpenSubtitleSources", "mIntSubtitleDataListener", "MEDIA_NOP", "MEDIA_PREPARED", "MEDIA_PLAYBACK_COMPLETE", "MEDIA_BUFFERING_UPDATE", "MEDIA_SEEK_COMPLETE", "MEDIA_SET_VIDEO_SIZE", "MEDIA_STARTED", "MEDIA_PAUSED", "MEDIA_STOPPED", "MEDIA_SKIPPED", "MEDIA_NOTIFY_TIME", "MEDIA_TIMED_TEXT", "MEDIA_ERROR", "MEDIA_INFO", "MEDIA_SUBTITLE_DATA", "MEDIA_META_DATA", "MEDIA_DRM_INFO", "MEDIA_TIME_DISCONTINUITY", "MEDIA_AUDIO_ROUTING_CHANGED", "mTimeProvider", "mTimeProviderLock", "mOnPreparedListener", "mOnCompletionListener", "mOnCompletionInternalListener", "mOnBufferingUpdateListener", "mOnSeekCompleteListener", "mOnVideoSizeChangedListener", "mOnTimedTextListener", "mSubtitleDataListenerDisabled", "mExtSubtitleDataListener", "mExtSubtitleDataHandler", "mOnMediaTimeDiscontinuityListener", "mOnMediaTimeDiscontinuityHandler", "mOnTimedMetaDataAvailableListener", "MEDIA_ERROR_UNKNOWN", "MEDIA_ERROR_SERVER_DIED", "MEDIA_ERROR_NOT_VALID_FOR_PROGRESSIVE_PLAYBACK", "MEDIA_ERROR_IO", "MEDIA_ERROR_MALFORMED", "MEDIA_ERROR_UNSUPPORTED", "MEDIA_ERROR_TIMED_OUT", "MEDIA_ERROR_SYSTEM", "mOnErrorListener", "MEDIA_INFO_UNKNOWN", "MEDIA_INFO_STARTED_AS_NEXT", "MEDIA_INFO_VIDEO_RENDERING_START", "MEDIA_INFO_VIDEO_TRACK_LAGGING", "MEDIA_INFO_BUFFERING_START", "MEDIA_INFO_BUFFERING_END", "MEDIA_INFO_NETWORK_BANDWIDTH", "MEDIA_INFO_BAD_INTERLEAVING", "MEDIA_INFO_NOT_SEEKABLE", "MEDIA_INFO_METADATA_UPDATE", "MEDIA_INFO_EXTERNAL_METADATA_UPDATE", "MEDIA_INFO_AUDIO_NOT_PLAYING", "MEDIA_INFO_VIDEO_NOT_PLAYING", "MEDIA_INFO_TIMED_TEXT_ERROR", "MEDIA_INFO_UNSUPPORTED_SUBTITLE", "MEDIA_INFO_SUBTITLE_TIMED_OUT", "mOnInfoListener", "mOnDrmConfigHelper", "mOnDrmInfoHandlerDelegate", "PREPARE_DRM_STATUS_SUCCESS", "PREPARE_DRM_STATUS_PROVISIONING_NETWORK_ERROR", "PREPARE_DRM_STATUS_PROVISIONING_SERVER_ERROR", "PREPARE_DRM_STATUS_PREPARATION_ERROR", "mOnDrmPreparedHandlerDelegate" ],
  "methodNames" : [ "private native void _setVideoSurface(Surface surface)", "public Parcel newRequest()", "public void invoke(Parcel request, Parcel reply)", "public void setDisplay(SurfaceHolder sh)", "public void setSurface(Surface surface)", "public void setVideoScalingMode(int mode)", "public static MediaPlayer create(Context context, Uri uri)", "public static MediaPlayer create(Context context, Uri uri, SurfaceHolder holder)", "public static MediaPlayer create(Context context, Uri uri, SurfaceHolder holder, AudioAttributes audioAttributes, int audioSessionId)", "public static MediaPlayer create(Context context, int resid)", "public static MediaPlayer create(Context context, int resid, AudioAttributes audioAttributes, int audioSessionId)", "public void setDataSource(@NonNull Context context, @NonNull Uri uri) throws IOException, IllegalArgumentException, SecurityException, IllegalStateException", "public void setDataSource(@NonNull Context context, @NonNull Uri uri, @Nullable Map<String, String> headers, @Nullable List<HttpCookie> cookies) throws IOException", "public void setDataSource(@NonNull Context context, @NonNull Uri uri, @Nullable Map<String, String> headers) throws IOException, IllegalArgumentException, SecurityException, IllegalStateException", "private boolean attemptDataSource(ContentResolver resolver, Uri uri)", "public void setDataSource(String path) throws IOException, IllegalArgumentException, SecurityException, IllegalStateException", "public void setDataSource(String path, Map<String, String> headers) throws IOException, IllegalArgumentException, SecurityException, IllegalStateException", "private void setDataSource(String path, Map<String, String> headers, List<HttpCookie> cookies) throws IOException, IllegalArgumentException, SecurityException, IllegalStateException", "private void setDataSource(String path, String[] keys, String[] values, List<HttpCookie> cookies) throws IOException, IllegalArgumentException, SecurityException, IllegalStateException", "private native void nativeSetDataSource(IBinder httpServiceBinder, String path, String[] keys, String[] values) throws IOException, IllegalArgumentException, SecurityException, IllegalStateException", "public void setDataSource(@NonNull AssetFileDescriptor afd) throws IOException, IllegalArgumentException, IllegalStateException", "public void setDataSource(FileDescriptor fd) throws IOException, IllegalArgumentException, IllegalStateException", "public void setDataSource(FileDescriptor fd, long offset, long length) throws IOException, IllegalArgumentException, IllegalStateException", "private native void _setDataSource(FileDescriptor fd, long offset, long length) throws IOException, IllegalArgumentException, IllegalStateException", "public void setDataSource(MediaDataSource dataSource) throws IllegalArgumentException, IllegalStateException", "private native void _setDataSource(MediaDataSource dataSource) throws IllegalArgumentException, IllegalStateException", "public void prepare() throws IOException, IllegalStateException", "private native void _prepare() throws IOException, IllegalStateException", "public native void prepareAsync() throws IllegalStateException", "public void start() throws IllegalStateException", "private void startImpl()", "private native void _start() throws IllegalStateException", "private int getAudioStreamType()", "private native int _getAudioStreamType() throws IllegalStateException", "public void stop() throws IllegalStateException", "private native void _stop() throws IllegalStateException", "public void pause() throws IllegalStateException", "private native void _pause() throws IllegalStateException", " void playerStart()", " void playerPause()", " void playerStop()", " int playerApplyVolumeShaper(@NonNull VolumeShaper.Configuration configuration, @NonNull VolumeShaper.Operation operation)", " VolumeShaper.State playerGetVolumeShaperState(int id)", "public VolumeShaper createVolumeShaper(@NonNull VolumeShaper.Configuration configuration)", "private native int native_applyVolumeShaper(@NonNull VolumeShaper.Configuration configuration, @NonNull VolumeShaper.Operation operation)", "private native VolumeShaper.State native_getVolumeShaperState(int id)", "public boolean setPreferredDevice(AudioDeviceInfo deviceInfo)", "public AudioDeviceInfo getPreferredDevice()", "public AudioDeviceInfo getRoutedDevice()", "private void enableNativeRoutingCallbacksLocked(boolean enabled)", "public void addOnRoutingChangedListener(AudioRouting.OnRoutingChangedListener listener, Handler handler)", "public void removeOnRoutingChangedListener(AudioRouting.OnRoutingChangedListener listener)", "private final native boolean native_setOutputDevice(int deviceId)", "private final native int native_getRoutedDeviceId()", "private final native void native_enableDeviceCallback(boolean enabled)", "public void setWakeMode(Context context, int mode)", "public void setScreenOnWhilePlaying(boolean screenOn)", "private void stayAwake(boolean awake)", "private void updateSurfaceScreenOn()", "public native int getVideoWidth()", "public native int getVideoHeight()", "public PersistableBundle getMetrics()", "private native PersistableBundle native_getMetrics()", "public native boolean isPlaying()", "public PlaybackParams easyPlaybackParams(float rate, @PlaybackRateAudioMode int audioMode)", "public native void setPlaybackParams(@NonNull PlaybackParams params)", "public native PlaybackParams getPlaybackParams()", "public native void setSyncParams(@NonNull SyncParams params)", "public native SyncParams getSyncParams()", "private final native void _seekTo(long msec, int mode)", "public void seekTo(long msec, @SeekMode int mode)", "public void seekTo(int msec) throws IllegalStateException", "public MediaTimestamp getTimestamp()", "public native int getCurrentPosition()", "public native int getDuration()", "public Metadata getMetadata(final boolean update_only, final boolean apply_filter)", "public int setMetadataFilter(Set<Integer> allow, Set<Integer> block)", "public native void setNextMediaPlayer(MediaPlayer next)", "public void release()", "private native void _release()", "public void reset()", "private native void _reset()", "public void notifyAt(long mediaTimeUs)", "private native void _notifyAt(long mediaTimeUs)", "public void setAudioStreamType(int streamtype)", "private native void _setAudioStreamType(int streamtype)", "private native boolean setParameter(int key, Parcel value)", "public void setAudioAttributes(AudioAttributes attributes) throws IllegalArgumentException", "public native void setLooping(boolean looping)", "public native boolean isLooping()", "public void setVolume(float leftVolume, float rightVolume)", " void playerSetVolume(boolean muting, float leftVolume, float rightVolume)", "private native void _setVolume(float leftVolume, float rightVolume)", "public void setVolume(float volume)", "public native void setAudioSessionId(int sessionId) throws IllegalArgumentException, IllegalStateException", "public native int getAudioSessionId()", "public native void attachAuxEffect(int effectId)", "public void setAuxEffectSendLevel(float level)", " int playerSetAuxEffectSendLevel(boolean muting, float level)", "private native void _setAuxEffectSendLevel(float level)", "private final native int native_invoke(Parcel request, Parcel reply)", "private final native boolean native_getMetadata(boolean update_only, boolean apply_filter, Parcel reply)", "private final native int native_setMetadataFilter(Parcel request)", "private static final native void native_init()", "private final native void native_setup(Object mediaplayer_this)", "private final native void native_finalize()", "public TrackInfo[] getTrackInfo() throws IllegalStateException", "private TrackInfo[] getInbandTrackInfo() throws IllegalStateException", "private static boolean availableMimeTypeForExternalSource(String mimeType)", "public void setSubtitleAnchor(SubtitleController controller, SubtitleController.Anchor anchor)", "private synchronized void setSubtitleAnchor()", "public void onSubtitleTrackSelected(SubtitleTrack track)", "public void addSubtitleSource(InputStream is, MediaFormat format) throws IllegalStateException", "private void scanInternalSubtitleTracks()", "private void populateInbandTracks()", "public void addTimedTextSource(String path, String mimeType) throws IOException, IllegalArgumentException, IllegalStateException", "public void addTimedTextSource(Context context, Uri uri, String mimeType) throws IOException, IllegalArgumentException, IllegalStateException", "public void addTimedTextSource(FileDescriptor fd, String mimeType) throws IllegalArgumentException, IllegalStateException", "public void addTimedTextSource(FileDescriptor fd, long offset, long length, String mime) throws IllegalArgumentException, IllegalStateException", "public int getSelectedTrack(int trackType) throws IllegalStateException", "public void selectTrack(int index) throws IllegalStateException", "public void deselectTrack(int index) throws IllegalStateException", "private void selectOrDeselectTrack(int index, boolean select) throws IllegalStateException", "private void selectOrDeselectInbandTrack(int index, boolean select) throws IllegalStateException", "public static native int native_pullBatteryData(Parcel reply)", "public void setRetransmitEndpoint(InetSocketAddress endpoint) throws IllegalStateException, IllegalArgumentException", "private final native int native_setRetransmitEndpoint(String addrString, int port)", "protected void finalize()", "public MediaTimeProvider getMediaTimeProvider()", "private static void postEventFromNative(Object mediaplayer_ref, int what, int arg1, int arg2, Object obj)", "public void setOnPreparedListener(OnPreparedListener listener)", "public void setOnCompletionListener(OnCompletionListener listener)", "public void setOnBufferingUpdateListener(OnBufferingUpdateListener listener)", "public void setOnSeekCompleteListener(OnSeekCompleteListener listener)", "public void setOnVideoSizeChangedListener(OnVideoSizeChangedListener listener)", "public void setOnTimedTextListener(OnTimedTextListener listener)", "public void setOnSubtitleDataListener(@NonNull OnSubtitleDataListener listener, @NonNull Handler handler)", "public void setOnSubtitleDataListener(@NonNull OnSubtitleDataListener listener)", "public void clearOnSubtitleDataListener()", "private void setOnSubtitleDataListenerInt(@Nullable OnSubtitleDataListener listener, @Nullable Handler handler)", "public void setOnMediaTimeDiscontinuityListener(@NonNull OnMediaTimeDiscontinuityListener listener, @NonNull Handler handler)", "public void setOnMediaTimeDiscontinuityListener(@NonNull OnMediaTimeDiscontinuityListener listener)", "public void clearOnMediaTimeDiscontinuityListener()", "private void setOnMediaTimeDiscontinuityListenerInt(@Nullable OnMediaTimeDiscontinuityListener listener, @Nullable Handler handler)", "public void setOnTimedMetaDataAvailableListener(OnTimedMetaDataAvailableListener listener)", "public void setOnErrorListener(OnErrorListener listener)", "public void setOnInfoListener(OnInfoListener listener)", "public void setOnDrmConfigHelper(OnDrmConfigHelper listener)", "public void setOnDrmInfoListener(OnDrmInfoListener listener)", "public void setOnDrmInfoListener(OnDrmInfoListener listener, Handler handler)", "public void setOnDrmPreparedListener(OnDrmPreparedListener listener)", "public void setOnDrmPreparedListener(OnDrmPreparedListener listener, Handler handler)", "public DrmInfo getDrmInfo()", "public void prepareDrm(@NonNull UUID uuid) throws UnsupportedSchemeException, ResourceBusyException, ProvisioningNetworkErrorException, ProvisioningServerErrorException", "private native void _releaseDrm()", "public void releaseDrm() throws NoDrmSchemeException", "public MediaDrm.KeyRequest getKeyRequest(@Nullable byte[] keySetId, @Nullable byte[] initData, @Nullable String mimeType, @MediaDrm.KeyType int keyType, @Nullable Map<String, String> optionalParameters) throws NoDrmSchemeException", "public byte[] provideKeyResponse(@Nullable byte[] keySetId, @NonNull byte[] response) throws NoDrmSchemeException, DeniedByServerException", "public void restoreKeys(@NonNull byte[] keySetId) throws NoDrmSchemeException", "public String getDrmPropertyString(@NonNull @MediaDrm.StringProperty String propertyName) throws NoDrmSchemeException", "public void setDrmPropertyString(@NonNull @MediaDrm.StringProperty String propertyName, @NonNull String value) throws NoDrmSchemeException", "private native void _prepareDrm(@NonNull byte[] uuid, @NonNull byte[] drmSessionId)", "private void prepareDrm_createDrmStep(@NonNull UUID uuid) throws UnsupportedSchemeException", "private void prepareDrm_openSessionStep(@NonNull UUID uuid) throws NotProvisionedException, ResourceBusyException", "private int HandleProvisioninig(UUID uuid)", "private boolean resumePrepareDrm(UUID uuid)", "private void resetDrmState()", "private void cleanDrmObj()", "private static final byte[] getByteArrayFromUUID(@NonNull UUID uuid)", "private boolean isVideoScalingModeSupported(int mode)" ]
}