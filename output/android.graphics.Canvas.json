{
  "filePath" : "/home/maryam/clearblue/files/android-source-30/android/graphics/Canvas.java",
  "packageName" : "android.graphics",
  "className" : "Canvas",
  "comment" : "\n * The Canvas class holds the \"draw\" calls. To draw something, you need\n * 4 basic components: A Bitmap to hold the pixels, a Canvas to host\n * the draw calls (writing into the bitmap), a drawing primitive (e.g. Rect,\n * Path, text, Bitmap), and a paint (to describe the colors and styles for the\n * drawing).\n *\n * <div class=\"special reference\">\n * <h3>Developer Guides</h3>\n * <p>For more information about how to use Canvas, read the\n * <a href=\"{@docRoot}guide/topics/graphics/2d-graphics.html\">\n * Canvas and Drawables</a> developer guide.</p></div>\n ",
  "variables" : [ {
    "name" : "sCompatiblityVersion",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "sCompatibilityRestore",
    "type" : "boolean",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "sCompatibilitySetBitmap",
    "type" : "boolean",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "mBitmap",
    "type" : "Bitmap",
    "comment" : " may be null",
    "links" : [ ]
  }, {
    "name" : "mDrawFilter",
    "type" : "DrawFilter",
    "comment" : " optional field set by the caller",
    "links" : [ ]
  }, {
    "name" : "MAXMIMUM_BITMAP_SIZE",
    "type" : "int",
    "comment" : " (see SkCanvas.cpp, SkDraw.cpp)",
    "links" : [ ]
  }, {
    "name" : "mFinalizer",
    "type" : "Runnable",
    "comment" : " This field is used to finalize the native Canvas properly",
    "links" : [ ]
  }, {
    "name" : "MATRIX_SAVE_FLAG",
    "type" : "int",
    "comment" : "\n     * Restore the current matrix when restore() is called.\n     * @removed\n     * @deprecated Use the flagless version of {@link #save()}, {@link #saveLayer(RectF, Paint)} or\n     *             {@link #saveLayerAlpha(RectF, int)}. For saveLayer() calls the matrix\n     *             was always restored for {@link #isHardwareAccelerated() Hardware accelerated}\n     *             canvases and as of API level {@value Build.VERSION_CODES#O} that is the default\n     *             behavior for all canvas types.\n     ",
    "links" : [ "#saveLayer(RectF", "#save()", "#isHardwareAccelerated()", "#saveLayerAlpha(RectF" ]
  }, {
    "name" : "CLIP_SAVE_FLAG",
    "type" : "int",
    "comment" : "\n     * Restore the current clip when restore() is called.\n     *\n     * @removed\n     * @deprecated Use the flagless version of {@link #save()}, {@link #saveLayer(RectF, Paint)} or\n     *             {@link #saveLayerAlpha(RectF, int)}. For saveLayer() calls the clip\n     *             was always restored for {@link #isHardwareAccelerated() Hardware accelerated}\n     *             canvases and as of API level {@value Build.VERSION_CODES#O} that is the default\n     *             behavior for all canvas types.\n     ",
    "links" : [ "#saveLayer(RectF", "#save()", "#isHardwareAccelerated()", "#saveLayerAlpha(RectF" ]
  }, {
    "name" : "HAS_ALPHA_LAYER_SAVE_FLAG",
    "type" : "int",
    "comment" : "\n     * The layer requires a per-pixel alpha channel.\n     *\n     * @removed\n     * @deprecated This flag is ignored. Use the flagless version of {@link #saveLayer(RectF, Paint)}\n     *             {@link #saveLayerAlpha(RectF, int)}.\n     ",
    "links" : [ "#saveLayer(RectF", "#saveLayerAlpha(RectF" ]
  }, {
    "name" : "FULL_COLOR_LAYER_SAVE_FLAG",
    "type" : "int",
    "comment" : "\n     * The layer requires full 8-bit precision for each color channel.\n     *\n     * @removed\n     * @deprecated This flag is ignored. Use the flagless version of {@link #saveLayer(RectF, Paint)}\n     *             {@link #saveLayerAlpha(RectF, int)}.\n     ",
    "links" : [ "#saveLayer(RectF", "#saveLayerAlpha(RectF" ]
  }, {
    "name" : "CLIP_TO_LAYER_SAVE_FLAG",
    "type" : "int",
    "comment" : "\n     * Clip drawing to the bounds of the offscreen layer, omit at your own peril.\n     * <p class=\"note\"><strong>Note:</strong> it is strongly recommended to not\n     * omit this flag for any call to <code>saveLayer()</code> and\n     * <code>saveLayerAlpha()</code> variants. Not passing this flag generally\n     * triggers extremely poor performance with hardware accelerated rendering.\n     *\n     * @removed\n     * @deprecated This flag results in poor performance and the same effect can be achieved with\n     *             a single layer or multiple draw commands with different clips.\n     *\n     ",
    "links" : [ ]
  }, {
    "name" : "ALL_SAVE_FLAG",
    "type" : "int",
    "comment" : "\n     * Restore everything when restore() is called (standard save flags).\n     * <p class=\"note\"><strong>Note:</strong> for performance reasons, it is\n     * strongly recommended to pass this - the complete set of flags - to any\n     * call to <code>saveLayer()</code> and <code>saveLayerAlpha()</code>\n     * variants.\n     *\n     * <p class=\"note\"><strong>Note:</strong> all methods that accept this flag\n     * have flagless versions that are equivalent to passing this flag.\n     ",
    "links" : [ ]
  } ],
  "methods" : [ {
    "name" : "public long getNativeCanvasWrapper()",
    "returnType" : "long",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "public boolean isRecordingFor(Object o)",
    "returnType" : "boolean",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "protected GL getGL()",
    "returnType" : "GL",
    "comment" : "\n     * Returns null.\n     *\n     * @deprecated This method is not supported and should not be invoked.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean isHardwareAccelerated()",
    "returnType" : "boolean",
    "comment" : "\n     * Indicates whether this Canvas uses hardware acceleration.\n     *\n     * Note that this method does not define what type of hardware acceleration\n     * may or may not be used.\n     *\n     * @return True if drawing operations are hardware accelerated,\n     *         false otherwise.\n     ",
    "links" : [ ]
  }, {
    "name" : "public void setBitmap(@Nullable Bitmap bitmap)",
    "returnType" : "void",
    "comment" : "\n     * Specify a bitmap for the canvas to draw into. All canvas state such as\n     * layers, filters, and the save/restore stack are reset. Additionally,\n     * the canvas' target density is updated to match that of the bitmap.\n     *\n     * Prior to API level {@value Build.VERSION_CODES#O} the current matrix and\n     * clip stack were preserved.\n     *\n     * @param bitmap Specifies a mutable bitmap for the canvas to draw into.\n     * @see #setDensity(int)\n     * @see #getDensity()\n     ",
    "links" : [ ]
  }, {
    "name" : "public void insertReorderBarrier()",
    "returnType" : "void",
    "comment" : "\n     * @deprecated use {@link #enableZ()} instead\n     * @hide ",
    "links" : [ "#enableZ()" ]
  }, {
    "name" : "public void insertInorderBarrier()",
    "returnType" : "void",
    "comment" : "\n     * @deprecated use {@link #disableZ()} instead\n     * @hide ",
    "links" : [ "#disableZ()" ]
  }, {
    "name" : "public void enableZ()",
    "returnType" : "void",
    "comment" : "\n     * <p>Enables Z support which defaults to disabled. This allows for RenderNodes drawn with\n     * {@link #drawRenderNode(RenderNode)} to be re-arranged based off of their\n     * {@link RenderNode#getElevation()} and {@link RenderNode#getTranslationZ()}\n     * values. It also enables rendering of shadows for RenderNodes with an elevation or\n     * translationZ.</p>\n     *\n     * <p>Any draw reordering will not be moved before this call. A typical usage of this might\n     * look something like:\n     *\n     * <pre class=\"prettyprint\">\n     *     void draw(Canvas canvas) {\n     *         // Draw any background content\n     *         canvas.drawColor(backgroundColor);\n     *\n     *         // Begin drawing that may be reordered based off of Z\n     *         canvas.enableZ();\n     *         for (RenderNode child : children) {\n     *             canvas.drawRenderNode(child);\n     *         }\n     *         // End drawing that may be reordered based off of Z\n     *         canvas.disableZ();\n     *\n     *         // Draw any overlays\n     *         canvas.drawText(\"I'm on top of everything!\", 0, 0, paint);\n     *     }\n     * </pre>\n     * </p>\n     *\n     * Note: This is not impacted by any {@link #save()} or {@link #restore()} calls as it is not\n     * considered to be part of the current matrix or clip.\n     *\n     * See {@link #disableZ()}\n     ",
    "links" : [ "#drawRenderNode(RenderNode)", "#disableZ()", "#save()", "android.graphics.RenderNode#getElevation()", "#restore()", "android.graphics.RenderNode#getTranslationZ()" ]
  }, {
    "name" : "public void disableZ()",
    "returnType" : "void",
    "comment" : "\n     * Disables Z support, preventing any RenderNodes drawn after this point from being\n     * visually reordered or having shadows rendered.\n     *\n     * Note: This is not impacted by any {@link #save()} or {@link #restore()} calls as it is not\n     * considered to be part of the current matrix or clip.\n     *\n     * See {@link #enableZ()}\n     ",
    "links" : [ "#enableZ()", "#save()", "#restore()" ]
  }, {
    "name" : "public boolean isOpaque()",
    "returnType" : "boolean",
    "comment" : "\n     * Return true if the device that the current layer draws into is opaque\n     * (i.e. does not support per-pixel alpha).\n     *\n     * @return true if the device that the current layer draws into is opaque\n     ",
    "links" : [ ]
  }, {
    "name" : "public int getWidth()",
    "returnType" : "int",
    "comment" : "\n     * Returns the width of the current drawing layer\n     *\n     * @return the width of the current drawing layer\n     ",
    "links" : [ ]
  }, {
    "name" : "public int getHeight()",
    "returnType" : "int",
    "comment" : "\n     * Returns the height of the current drawing layer\n     *\n     * @return the height of the current drawing layer\n     ",
    "links" : [ ]
  }, {
    "name" : "public int getDensity()",
    "returnType" : "int",
    "comment" : "\n     * <p>Returns the target density of the canvas.  The default density is\n     * derived from the density of its backing bitmap, or\n     * {@link Bitmap#DENSITY_NONE} if there is not one.</p>\n     *\n     * @return Returns the current target density of the canvas, which is used\n     * to determine the scaling factor when drawing a bitmap into it.\n     *\n     * @see #setDensity(int)\n     * @see Bitmap#getDensity()\n     ",
    "links" : [ "android.graphics.Bitmap#DENSITY_NONE" ]
  }, {
    "name" : "public void setDensity(int density)",
    "returnType" : "void",
    "comment" : "\n     * <p>Specifies the density for this Canvas' backing bitmap.  This modifies\n     * the target density of the canvas itself, as well as the density of its\n     * backing bitmap via {@link Bitmap#setDensity(int) Bitmap.setDensity(int)}.\n     *\n     * @param density The new target density of the canvas, which is used\n     * to determine the scaling factor when drawing a bitmap into it.  Use\n     * {@link Bitmap#DENSITY_NONE} to disable bitmap scaling.\n     *\n     * @see #getDensity()\n     * @see Bitmap#setDensity(int)\n     ",
    "links" : [ "android.graphics.Bitmap#DENSITY_NONE", "android.graphics.Bitmap#setDensity(int)" ]
  }, {
    "name" : "public void setScreenDensity(int density)",
    "returnType" : "void",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "public int getMaximumBitmapWidth()",
    "returnType" : "int",
    "comment" : "\n     * Returns the maximum allowed width for bitmaps drawn with this canvas.\n     * Attempting to draw with a bitmap wider than this value will result\n     * in an error.\n     *\n     * @see #getMaximumBitmapHeight()\n     ",
    "links" : [ ]
  }, {
    "name" : "public int getMaximumBitmapHeight()",
    "returnType" : "int",
    "comment" : "\n     * Returns the maximum allowed height for bitmaps drawn with this canvas.\n     * Attempting to draw with a bitmap taller than this value will result\n     * in an error.\n     *\n     * @see #getMaximumBitmapWidth()\n     ",
    "links" : [ ]
  }, {
    "name" : "private static void checkValidSaveFlags(int saveFlags)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public int save()",
    "returnType" : "int",
    "comment" : "\n     * Saves the current matrix and clip onto a private stack.\n     * <p>\n     * Subsequent calls to translate,scale,rotate,skew,concat or clipRect,\n     * clipPath will all operate as usual, but when the balancing call to\n     * restore() is made, those calls will be forgotten, and the settings that\n     * existed before the save() will be reinstated.\n     *\n     * @return The value to pass to restoreToCount() to balance this save()\n     ",
    "links" : [ ]
  }, {
    "name" : "public int save(@Saveflags int saveFlags)",
    "returnType" : "int",
    "comment" : "\n     * Based on saveFlags, can save the current matrix and clip onto a private\n     * stack.\n     * <p class=\"note\"><strong>Note:</strong> if possible, use the\n     * parameter-less save(). It is simpler and faster than individually\n     * disabling the saving of matrix or clip with this method.\n     * <p>\n     * Subsequent calls to translate,scale,rotate,skew,concat or clipRect,\n     * clipPath will all operate as usual, but when the balancing call to\n     * restore() is made, those calls will be forgotten, and the settings that\n     * existed before the save() will be reinstated.\n     *\n     * @removed\n     * @deprecated Use {@link #save()} instead.\n     * @param saveFlags flag bits that specify which parts of the Canvas state\n     *                  to save/restore\n     * @return The value to pass to restoreToCount() to balance this save()\n     ",
    "links" : [ "#save()" ]
  }, {
    "name" : "public int saveLayer(@Nullable RectF bounds, @Nullable Paint paint, @Saveflags int saveFlags)",
    "returnType" : "int",
    "comment" : "\n     * This behaves the same as save(), but in addition it allocates and\n     * redirects drawing to an offscreen bitmap.\n     * <p class=\"note\"><strong>Note:</strong> this method is very expensive,\n     * incurring more than double rendering cost for contained content. Avoid\n     * using this method, especially if the bounds provided are large. It is\n     * recommended to use a {@link android.view.View#LAYER_TYPE_HARDWARE hardware layer} on a View\n     * to apply an xfermode, color filter, or alpha, as it will perform much\n     * better than this method.\n     * <p>\n     * All drawing calls are directed to a newly allocated offscreen bitmap.\n     * Only when the balancing call to restore() is made, is that offscreen\n     * buffer drawn back to the current target of the Canvas (either the\n     * screen, it's target Bitmap, or the previous layer).\n     * <p>\n     * Attributes of the Paint - {@link Paint#getAlpha() alpha},\n     * {@link Paint#getXfermode() Xfermode}, and\n     * {@link Paint#getColorFilter() ColorFilter} are applied when the\n     * offscreen bitmap is drawn back when restore() is called.\n     *\n     * As of API Level API level {@value Build.VERSION_CODES#P} the only valid\n     * {@code saveFlags} is {@link #ALL_SAVE_FLAG}.  All other flags are ignored.\n     *\n     * @deprecated Use {@link #saveLayer(RectF, Paint)} instead.\n     * @param bounds May be null. The maximum size the offscreen bitmap\n     *               needs to be (in local coordinates)\n     * @param paint  This is copied, and is applied to the offscreen when\n     *               restore() is called.\n     * @param saveFlags see _SAVE_FLAG constants, generally {@link #ALL_SAVE_FLAG} is recommended\n     *               for performance reasons.\n     * @return       value to pass to restoreToCount() to balance this save()\n     ",
    "links" : [ "android.graphics.Paint#getColorFilter()", "#saveLayer(RectF", "android.view.View#LAYER_TYPE_HARDWARE", "#ALL_SAVE_FLAG", "android.graphics.Paint#getAlpha()", "android.graphics.Paint#getXfermode()" ]
  }, {
    "name" : "public int saveLayer(@Nullable RectF bounds, @Nullable Paint paint)",
    "returnType" : "int",
    "comment" : "\n     * This behaves the same as save(), but in addition it allocates and\n     * redirects drawing to an offscreen rendering target.\n     * <p class=\"note\"><strong>Note:</strong> this method is very expensive,\n     * incurring more than double rendering cost for contained content. Avoid\n     * using this method when possible and instead use a\n     * {@link android.view.View#LAYER_TYPE_HARDWARE hardware layer} on a View\n     * to apply an xfermode, color filter, or alpha, as it will perform much\n     * better than this method.\n     * <p>\n     * All drawing calls are directed to a newly allocated offscreen rendering target.\n     * Only when the balancing call to restore() is made, is that offscreen\n     * buffer drawn back to the current target of the Canvas (which can potentially be a previous\n     * layer if these calls are nested).\n     * <p>\n     * Attributes of the Paint - {@link Paint#getAlpha() alpha},\n     * {@link Paint#getXfermode() Xfermode}, and\n     * {@link Paint#getColorFilter() ColorFilter} are applied when the\n     * offscreen rendering target is drawn back when restore() is called.\n     *\n     * @param bounds May be null. The maximum size the offscreen render target\n     *               needs to be (in local coordinates)\n     * @param paint  This is copied, and is applied to the offscreen when\n     *               restore() is called.\n     * @return       value to pass to restoreToCount() to balance this save()\n     ",
    "links" : [ "android.graphics.Paint#getColorFilter()", "android.view.View#LAYER_TYPE_HARDWARE", "android.graphics.Paint#getAlpha()", "android.graphics.Paint#getXfermode()" ]
  }, {
    "name" : "public int saveUnclippedLayer(int left, int top, int right, int bottom)",
    "returnType" : "int",
    "comment" : "\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public void restoreUnclippedLayer(int saveCount, Paint paint)",
    "returnType" : "void",
    "comment" : "\n     * @hide\n     * @param saveCount The save level to restore to.\n     * @param paint     This is copied and is applied to the area within the unclipped layer's\n     *                  bounds (i.e. equivalent to a drawPaint()) before restore() is called.\n     ",
    "links" : [ ]
  }, {
    "name" : "public int saveLayer(float left, float top, float right, float bottom, @Nullable Paint paint, @Saveflags int saveFlags)",
    "returnType" : "int",
    "comment" : "\n     * Helper version of saveLayer() that takes 4 values rather than a RectF.\n     *\n     * As of API Level API level {@value Build.VERSION_CODES#P} the only valid\n     * {@code saveFlags} is {@link #ALL_SAVE_FLAG}.  All other flags are ignored.\n     *\n     * @deprecated Use {@link #saveLayer(float, float, float, float, Paint)} instead.\n     ",
    "links" : [ "#saveLayer(float", "#ALL_SAVE_FLAG" ]
  }, {
    "name" : "public int saveLayer(float left, float top, float right, float bottom, @Nullable Paint paint)",
    "returnType" : "int",
    "comment" : "\n     * Convenience for {@link #saveLayer(RectF, Paint)} that takes the four float coordinates of the\n     * bounds rectangle.\n     ",
    "links" : [ "#saveLayer(RectF" ]
  }, {
    "name" : "public int saveLayerAlpha(@Nullable RectF bounds, int alpha, @Saveflags int saveFlags)",
    "returnType" : "int",
    "comment" : "\n     * This behaves the same as save(), but in addition it allocates and\n     * redirects drawing to an offscreen bitmap.\n     * <p class=\"note\"><strong>Note:</strong> this method is very expensive,\n     * incurring more than double rendering cost for contained content. Avoid\n     * using this method, especially if the bounds provided are large. It is\n     * recommended to use a {@link android.view.View#LAYER_TYPE_HARDWARE hardware layer} on a View\n     * to apply an xfermode, color filter, or alpha, as it will perform much\n     * better than this method.\n     * <p>\n     * All drawing calls are directed to a newly allocated offscreen bitmap.\n     * Only when the balancing call to restore() is made, is that offscreen\n     * buffer drawn back to the current target of the Canvas (either the\n     * screen, it's target Bitmap, or the previous layer).\n     * <p>\n     * The {@code alpha} parameter is applied when the offscreen bitmap is\n     * drawn back when restore() is called.\n     *\n     * As of API Level API level {@value Build.VERSION_CODES#P} the only valid\n     * {@code saveFlags} is {@link #ALL_SAVE_FLAG}.  All other flags are ignored.\n     *\n     * @deprecated Use {@link #saveLayerAlpha(RectF, int)} instead.\n     * @param bounds    The maximum size the offscreen bitmap needs to be\n     *                  (in local coordinates)\n     * @param alpha     The alpha to apply to the offscreen when it is\n                        drawn during restore()\n     * @param saveFlags see _SAVE_FLAG constants, generally {@link #ALL_SAVE_FLAG} is recommended\n     *                  for performance reasons.\n     * @return          value to pass to restoreToCount() to balance this call\n     ",
    "links" : [ "android.view.View#LAYER_TYPE_HARDWARE", "#ALL_SAVE_FLAG", "#saveLayerAlpha(RectF" ]
  }, {
    "name" : "public int saveLayerAlpha(@Nullable RectF bounds, int alpha)",
    "returnType" : "int",
    "comment" : "\n     * Convenience for {@link #saveLayer(RectF, Paint)} but instead of taking a entire Paint object\n     * it takes only the {@code alpha} parameter.\n     *\n     * @param bounds    The maximum size the offscreen bitmap needs to be\n     *                  (in local coordinates)\n     * @param alpha     The alpha to apply to the offscreen when it is\n                        drawn during restore()\n     ",
    "links" : [ "#saveLayer(RectF" ]
  }, {
    "name" : "public int saveLayerAlpha(float left, float top, float right, float bottom, int alpha, @Saveflags int saveFlags)",
    "returnType" : "int",
    "comment" : "\n     * Helper for saveLayerAlpha() that takes 4 values instead of a RectF.\n     *\n     * As of API Level API level {@value Build.VERSION_CODES#P} the only valid\n     * {@code saveFlags} is {@link #ALL_SAVE_FLAG}.  All other flags are ignored.\n     *\n     * @deprecated Use {@link #saveLayerAlpha(float, float, float, float, int)} instead.\n     ",
    "links" : [ "#ALL_SAVE_FLAG", "#saveLayerAlpha(float" ]
  }, {
    "name" : "public int saveLayerAlpha(float left, float top, float right, float bottom, int alpha)",
    "returnType" : "int",
    "comment" : "\n     * Convenience for {@link #saveLayerAlpha(RectF, int)} that takes the four float coordinates of\n     * the bounds rectangle.\n     ",
    "links" : [ "#saveLayerAlpha(RectF" ]
  }, {
    "name" : "public void restore()",
    "returnType" : "void",
    "comment" : "\n     * This call balances a previous call to save(), and is used to remove all\n     * modifications to the matrix/clip state since the last save call. It is\n     * an error to call restore() more times than save() was called.\n     ",
    "links" : [ ]
  }, {
    "name" : "public int getSaveCount()",
    "returnType" : "int",
    "comment" : "\n     * Returns the number of matrix/clip states on the Canvas' private stack.\n     * This will equal # save() calls - # restore() calls.\n     ",
    "links" : [ ]
  }, {
    "name" : "public void restoreToCount(int saveCount)",
    "returnType" : "void",
    "comment" : "\n     * Efficient way to pop any calls to save() that happened after the save\n     * count reached saveCount. It is an error for saveCount to be less than 1.\n     *\n     * Example:\n     *    int count = canvas.save();\n     *    ... // more calls potentially to save()\n     *    canvas.restoreToCount(count);\n     *    // now the canvas is back in the same state it was before the initial\n     *    // call to save().\n     *\n     * @param saveCount The save level to restore to.\n     ",
    "links" : [ ]
  }, {
    "name" : "public void translate(float dx, float dy)",
    "returnType" : "void",
    "comment" : "\n     * Preconcat the current matrix with the specified translation\n     *\n     * @param dx The distance to translate in X\n     * @param dy The distance to translate in Y\n    ",
    "links" : [ ]
  }, {
    "name" : "public void scale(float sx, float sy)",
    "returnType" : "void",
    "comment" : "\n     * Preconcat the current matrix with the specified scale.\n     *\n     * @param sx The amount to scale in X\n     * @param sy The amount to scale in Y\n     ",
    "links" : [ ]
  }, {
    "name" : "public final void scale(float sx, float sy, float px, float py)",
    "returnType" : "void",
    "comment" : "\n     * Preconcat the current matrix with the specified scale.\n     *\n     * @param sx The amount to scale in X\n     * @param sy The amount to scale in Y\n     * @param px The x-coord for the pivot point (unchanged by the scale)\n     * @param py The y-coord for the pivot point (unchanged by the scale)\n     ",
    "links" : [ ]
  }, {
    "name" : "public void rotate(float degrees)",
    "returnType" : "void",
    "comment" : "\n     * Preconcat the current matrix with the specified rotation.\n     *\n     * @param degrees The amount to rotate, in degrees\n     ",
    "links" : [ ]
  }, {
    "name" : "public final void rotate(float degrees, float px, float py)",
    "returnType" : "void",
    "comment" : "\n     * Preconcat the current matrix with the specified rotation.\n     *\n     * @param degrees The amount to rotate, in degrees\n     * @param px The x-coord for the pivot point (unchanged by the rotation)\n     * @param py The y-coord for the pivot point (unchanged by the rotation)\n     ",
    "links" : [ ]
  }, {
    "name" : "public void skew(float sx, float sy)",
    "returnType" : "void",
    "comment" : "\n     * Preconcat the current matrix with the specified skew.\n     *\n     * @param sx The amount to skew in X\n     * @param sy The amount to skew in Y\n     ",
    "links" : [ ]
  }, {
    "name" : "public void concat(@Nullable Matrix matrix)",
    "returnType" : "void",
    "comment" : "\n     * Preconcat the current matrix with the specified matrix. If the specified\n     * matrix is null, this method does nothing.\n     *\n     * @param matrix The matrix to preconcatenate with the current matrix\n     ",
    "links" : [ ]
  }, {
    "name" : "public void setMatrix(@Nullable Matrix matrix)",
    "returnType" : "void",
    "comment" : "\n     * Completely replace the current matrix with the specified matrix. If the\n     * matrix parameter is null, then the current matrix is reset to identity.\n     *\n     * <strong>Note:</strong> it is recommended to use {@link #concat(Matrix)},\n     * {@link #scale(float, float)}, {@link #translate(float, float)} and\n     * {@link #rotate(float)} instead of this method.\n     *\n     * @param matrix The matrix to replace the current matrix with. If it is\n     *               null, set the current matrix to identity.\n     *\n     * @see #concat(Matrix)\n     ",
    "links" : [ "#concat(Matrix)", "#scale(float", "#rotate(float)", "#translate(float" ]
  }, {
    "name" : "public void getMatrix(@NonNull Matrix ctm)",
    "returnType" : "void",
    "comment" : "\n     * Return, in ctm, the current transformation matrix. This does not alter\n     * the matrix in the canvas, but just returns a copy of it.\n     *\n     * @deprecated {@link #isHardwareAccelerated() Hardware accelerated} canvases may have any\n     * matrix when passed to a View or Drawable, as it is implementation defined where in the\n     * hierarchy such canvases are created. It is recommended in such cases to either draw contents\n     * irrespective of the current matrix, or to track relevant transform state outside of the\n     * canvas.\n     ",
    "links" : [ "#isHardwareAccelerated()" ]
  }, {
    "name" : "public final Matrix getMatrix()",
    "returnType" : "Matrix",
    "comment" : "\n     * Return a new matrix with a copy of the canvas' current transformation\n     * matrix.\n     *\n     * @deprecated {@link #isHardwareAccelerated() Hardware accelerated} canvases may have any\n     * matrix when passed to a View or Drawable, as it is implementation defined where in the\n     * hierarchy such canvases are created. It is recommended in such cases to either draw contents\n     * irrespective of the current matrix, or to track relevant transform state outside of the\n     * canvas.\n     ",
    "links" : [ "#isHardwareAccelerated()" ]
  }, {
    "name" : "private static void checkValidClipOp(@NonNull Region.Op op)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public boolean clipRect(@NonNull RectF rect, @NonNull Region.Op op)",
    "returnType" : "boolean",
    "comment" : "\n     * Modify the current clip with the specified rectangle.\n     *\n     * @param rect The rect to intersect with the current clip\n     * @param op How the clip is modified\n     * @return true if the resulting clip is non-empty\n     *\n     * @deprecated Region.Op values other than {@link Region.Op#INTERSECT} and\n     * {@link Region.Op#DIFFERENCE} have the ability to expand the clip. The canvas clipping APIs\n     * are intended to only expand the clip as a result of a restore operation. This enables a view\n     * parent to clip a canvas to clearly define the maximal drawing area of its children. The\n     * recommended alternative calls are {@link #clipRect(RectF)} and {@link #clipOutRect(RectF)};\n     *\n     * As of API Level API level {@value Build.VERSION_CODES#P} only {@link Region.Op#INTERSECT} and\n     * {@link Region.Op#DIFFERENCE} are valid Region.Op parameters.\n     ",
    "links" : [ "Region.Op#INTERSECT", "#clipOutRect(RectF)", "#clipRect(RectF)", "Region.Op#DIFFERENCE" ]
  }, {
    "name" : "public boolean clipRect(@NonNull Rect rect, @NonNull Region.Op op)",
    "returnType" : "boolean",
    "comment" : "\n     * Modify the current clip with the specified rectangle, which is\n     * expressed in local coordinates.\n     *\n     * @param rect The rectangle to intersect with the current clip.\n     * @param op How the clip is modified\n     * @return true if the resulting clip is non-empty\n     *\n     * @deprecated Region.Op values other than {@link Region.Op#INTERSECT} and\n     * {@link Region.Op#DIFFERENCE} have the ability to expand the clip. The canvas clipping APIs\n     * are intended to only expand the clip as a result of a restore operation. This enables a view\n     * parent to clip a canvas to clearly define the maximal drawing area of its children. The\n     * recommended alternative calls are {@link #clipRect(Rect)} and {@link #clipOutRect(Rect)};\n     *\n     * As of API Level API level {@value Build.VERSION_CODES#P} only {@link Region.Op#INTERSECT} and\n     * {@link Region.Op#DIFFERENCE} are valid Region.Op parameters.\n     ",
    "links" : [ "Region.Op#INTERSECT", "#clipOutRect(Rect)", "#clipRect(Rect)", "Region.Op#DIFFERENCE" ]
  }, {
    "name" : "public boolean clipRectUnion(@NonNull Rect rect)",
    "returnType" : "boolean",
    "comment" : "\n     * DON'T USE THIS METHOD.  It exists only to support a particular legacy behavior in\n     * the view system and will be removed as soon as that code is refactored to no longer\n     * depend on this behavior.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean clipRect(@NonNull RectF rect)",
    "returnType" : "boolean",
    "comment" : "\n     * Intersect the current clip with the specified rectangle, which is\n     * expressed in local coordinates.\n     *\n     * @param rect The rectangle to intersect with the current clip.\n     * @return true if the resulting clip is non-empty\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean clipOutRect(@NonNull RectF rect)",
    "returnType" : "boolean",
    "comment" : "\n     * Set the clip to the difference of the current clip and the specified rectangle, which is\n     * expressed in local coordinates.\n     *\n     * @param rect The rectangle to perform a difference op with the current clip.\n     * @return true if the resulting clip is non-empty\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean clipRect(@NonNull Rect rect)",
    "returnType" : "boolean",
    "comment" : "\n     * Intersect the current clip with the specified rectangle, which is\n     * expressed in local coordinates.\n     *\n     * @param rect The rectangle to intersect with the current clip.\n     * @return true if the resulting clip is non-empty\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean clipOutRect(@NonNull Rect rect)",
    "returnType" : "boolean",
    "comment" : "\n     * Set the clip to the difference of the current clip and the specified rectangle, which is\n     * expressed in local coordinates.\n     *\n     * @param rect The rectangle to perform a difference op with the current clip.\n     * @return true if the resulting clip is non-empty\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean clipRect(float left, float top, float right, float bottom, @NonNull Region.Op op)",
    "returnType" : "boolean",
    "comment" : "\n     * Modify the current clip with the specified rectangle, which is\n     * expressed in local coordinates.\n     *\n     * @param left   The left side of the rectangle to intersect with the\n     *               current clip\n     * @param top    The top of the rectangle to intersect with the current\n     *               clip\n     * @param right  The right side of the rectangle to intersect with the\n     *               current clip\n     * @param bottom The bottom of the rectangle to intersect with the current\n     *               clip\n     * @param op     How the clip is modified\n     * @return       true if the resulting clip is non-empty\n     *\n     * @deprecated Region.Op values other than {@link Region.Op#INTERSECT} and\n     * {@link Region.Op#DIFFERENCE} have the ability to expand the clip. The canvas clipping APIs\n     * are intended to only expand the clip as a result of a restore operation. This enables a view\n     * parent to clip a canvas to clearly define the maximal drawing area of its children. The\n     * recommended alternative calls are {@link #clipRect(float,float,float,float)} and\n     * {@link #clipOutRect(float,float,float,float)};\n     *\n     * As of API Level API level {@value Build.VERSION_CODES#P} only {@link Region.Op#INTERSECT} and\n     * {@link Region.Op#DIFFERENCE} are valid Region.Op parameters.\n     ",
    "links" : [ "Region.Op#INTERSECT", "#clipOutRect(float", "Region.Op#DIFFERENCE", "#clipRect(float" ]
  }, {
    "name" : "public boolean clipRect(float left, float top, float right, float bottom)",
    "returnType" : "boolean",
    "comment" : "\n     * Intersect the current clip with the specified rectangle, which is\n     * expressed in local coordinates.\n     *\n     * @param left   The left side of the rectangle to intersect with the\n     *               current clip\n     * @param top    The top of the rectangle to intersect with the current clip\n     * @param right  The right side of the rectangle to intersect with the\n     *               current clip\n     * @param bottom The bottom of the rectangle to intersect with the current\n     *               clip\n     * @return       true if the resulting clip is non-empty\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean clipOutRect(float left, float top, float right, float bottom)",
    "returnType" : "boolean",
    "comment" : "\n     * Set the clip to the difference of the current clip and the specified rectangle, which is\n     * expressed in local coordinates.\n     *\n     * @param left   The left side of the rectangle used in the difference operation\n     * @param top    The top of the rectangle used in the difference operation\n     * @param right  The right side of the rectangle used in the difference operation\n     * @param bottom The bottom of the rectangle used in the difference operation\n     * @return       true if the resulting clip is non-empty\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean clipRect(int left, int top, int right, int bottom)",
    "returnType" : "boolean",
    "comment" : "\n     * Intersect the current clip with the specified rectangle, which is\n     * expressed in local coordinates.\n     *\n     * @param left   The left side of the rectangle to intersect with the\n     *               current clip\n     * @param top    The top of the rectangle to intersect with the current clip\n     * @param right  The right side of the rectangle to intersect with the\n     *               current clip\n     * @param bottom The bottom of the rectangle to intersect with the current\n     *               clip\n     * @return       true if the resulting clip is non-empty\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean clipOutRect(int left, int top, int right, int bottom)",
    "returnType" : "boolean",
    "comment" : "\n     * Set the clip to the difference of the current clip and the specified rectangle, which is\n     * expressed in local coordinates.\n     *\n     * @param left   The left side of the rectangle used in the difference operation\n     * @param top    The top of the rectangle used in the difference operation\n     * @param right  The right side of the rectangle used in the difference operation\n     * @param bottom The bottom of the rectangle used in the difference operation\n     * @return       true if the resulting clip is non-empty\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean clipPath(@NonNull Path path, @NonNull Region.Op op)",
    "returnType" : "boolean",
    "comment" : "\n        * Modify the current clip with the specified path.\n     *\n     * @param path The path to operate on the current clip\n     * @param op   How the clip is modified\n     * @return     true if the resulting is non-empty\n     *\n     * @deprecated Region.Op values other than {@link Region.Op#INTERSECT} and\n     * {@link Region.Op#DIFFERENCE} have the ability to expand the clip. The canvas clipping APIs\n     * are intended to only expand the clip as a result of a restore operation. This enables a view\n     * parent to clip a canvas to clearly define the maximal drawing area of its children. The\n     * recommended alternative calls are {@link #clipPath(Path)} and\n     * {@link #clipOutPath(Path)};\n     *\n     * As of API Level API level {@value Build.VERSION_CODES#P} only {@link Region.Op#INTERSECT} and\n     * {@link Region.Op#DIFFERENCE} are valid Region.Op parameters.\n     ",
    "links" : [ "#clipOutPath(Path)", "Region.Op#INTERSECT", "#clipPath(Path)", "Region.Op#DIFFERENCE" ]
  }, {
    "name" : "public boolean clipPath(@NonNull Path path)",
    "returnType" : "boolean",
    "comment" : "\n     * Intersect the current clip with the specified path.\n     *\n     * @param path The path to intersect with the current clip\n     * @return     true if the resulting clip is non-empty\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean clipOutPath(@NonNull Path path)",
    "returnType" : "boolean",
    "comment" : "\n     * Set the clip to the difference of the current clip and the specified path.\n     *\n     * @param path The path used in the difference operation\n     * @return     true if the resulting clip is non-empty\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean clipRegion(@NonNull Region region, @NonNull Region.Op op)",
    "returnType" : "boolean",
    "comment" : "\n     * Modify the current clip with the specified region. Note that unlike\n     * clipRect() and clipPath() which transform their arguments by the\n     * current matrix, clipRegion() assumes its argument is already in the\n     * coordinate system of the current layer's bitmap, and so not\n     * transformation is performed.\n     *\n     * @param region The region to operate on the current clip, based on op\n     * @param op How the clip is modified\n     * @return true if the resulting is non-empty\n     *\n     * @removed\n     * @deprecated Unlike all other clip calls this API does not respect the\n     *             current matrix. Use {@link #clipRect(Rect)} as an alternative.\n     ",
    "links" : [ "#clipRect(Rect)" ]
  }, {
    "name" : "public boolean clipRegion(@NonNull Region region)",
    "returnType" : "boolean",
    "comment" : "\n     * Intersect the current clip with the specified region. Note that unlike\n     * clipRect() and clipPath() which transform their arguments by the\n     * current matrix, clipRegion() assumes its argument is already in the\n     * coordinate system of the current layer's bitmap, and so not\n     * transformation is performed.\n     *\n     * @param region The region to operate on the current clip, based on op\n     * @return true if the resulting is non-empty\n     *\n     * @removed\n     * @deprecated Unlike all other clip calls this API does not respect the\n     *             current matrix. Use {@link #clipRect(Rect)} as an alternative.\n     ",
    "links" : [ "#clipRect(Rect)" ]
  }, {
    "name" : "public DrawFilter getDrawFilter()",
    "returnType" : "DrawFilter",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public void setDrawFilter(@Nullable DrawFilter filter)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public boolean quickReject(@NonNull RectF rect, @NonNull EdgeType type)",
    "returnType" : "boolean",
    "comment" : "\n     * Return true if the specified rectangle, after being transformed by the\n     * current matrix, would lie completely outside of the current clip. Call\n     * this to check if an area you intend to draw into is clipped out (and\n     * therefore you can skip making the draw calls).\n     *\n     * @param rect  the rect to compare with the current clip\n     * @param type  {@link Canvas.EdgeType#AA} if the path should be considered antialiased,\n     *              since that means it may affect a larger area (more pixels) than\n     *              non-antialiased ({@link Canvas.EdgeType#BW}).\n     * @return      true if the rect (transformed by the canvas' matrix)\n     *              does not intersect with the canvas' clip\n     * @deprecated The EdgeType is ignored. Use {@link #quickReject(RectF)} instead.\n     ",
    "links" : [ "Canvas.EdgeType#BW", "#quickReject(RectF)", "Canvas.EdgeType#AA" ]
  }, {
    "name" : "public boolean quickReject(@NonNull RectF rect)",
    "returnType" : "boolean",
    "comment" : "\n     * Return true if the specified rectangle, after being transformed by the\n     * current matrix, would lie completely outside of the current clip. Call\n     * this to check if an area you intend to draw into is clipped out (and\n     * therefore you can skip making the draw calls).\n     *\n     * @param rect  the rect to compare with the current clip\n     * @return      true if the rect (transformed by the canvas' matrix)\n     *              does not intersect with the canvas' clip\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean quickReject(@NonNull Path path, @NonNull EdgeType type)",
    "returnType" : "boolean",
    "comment" : "\n     * Return true if the specified path, after being transformed by the\n     * current matrix, would lie completely outside of the current clip. Call\n     * this to check if an area you intend to draw into is clipped out (and\n     * therefore you can skip making the draw calls). Note: for speed it may\n     * return false even if the path itself might not intersect the clip\n     * (i.e. the bounds of the path intersects, but the path does not).\n     *\n     * @param path        The path to compare with the current clip\n     * @param type        {@link Canvas.EdgeType#AA} if the path should be considered antialiased,\n     *                    since that means it may affect a larger area (more pixels) than\n     *                    non-antialiased ({@link Canvas.EdgeType#BW}).\n     * @return            true if the path (transformed by the canvas' matrix)\n     *                    does not intersect with the canvas' clip\n     * @deprecated The EdgeType is ignored. Use {@link #quickReject(Path)} instead.\n     ",
    "links" : [ "#quickReject(Path)", "Canvas.EdgeType#BW", "Canvas.EdgeType#AA" ]
  }, {
    "name" : "public boolean quickReject(@NonNull Path path)",
    "returnType" : "boolean",
    "comment" : "\n     * Return true if the specified path, after being transformed by the\n     * current matrix, would lie completely outside of the current clip. Call\n     * this to check if an area you intend to draw into is clipped out (and\n     * therefore you can skip making the draw calls). Note: for speed it may\n     * return false even if the path itself might not intersect the clip\n     * (i.e. the bounds of the path intersects, but the path does not).\n     *\n     * @param path        The path to compare with the current clip\n     * @return            true if the path (transformed by the canvas' matrix)\n     *                    does not intersect with the canvas' clip\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean quickReject(float left, float top, float right, float bottom, @NonNull EdgeType type)",
    "returnType" : "boolean",
    "comment" : "\n     * Return true if the specified rectangle, after being transformed by the\n     * current matrix, would lie completely outside of the current clip. Call\n     * this to check if an area you intend to draw into is clipped out (and\n     * therefore you can skip making the draw calls).\n     *\n     * @param left        The left side of the rectangle to compare with the\n     *                    current clip\n     * @param top         The top of the rectangle to compare with the current\n     *                    clip\n     * @param right       The right side of the rectangle to compare with the\n     *                    current clip\n     * @param bottom      The bottom of the rectangle to compare with the\n     *                    current clip\n     * @param type        {@link Canvas.EdgeType#AA} if the path should be considered antialiased,\n     *                    since that means it may affect a larger area (more pixels) than\n     *                    non-antialiased ({@link Canvas.EdgeType#BW}).\n     * @return            true if the rect (transformed by the canvas' matrix)\n     *                    does not intersect with the canvas' clip\n     * @deprecated The EdgeType is ignored. Use {@link #quickReject(float, float, float, float)}\n     *             instead.\n     ",
    "links" : [ "Canvas.EdgeType#BW", "Canvas.EdgeType#AA", "#quickReject(float" ]
  }, {
    "name" : "public boolean quickReject(float left, float top, float right, float bottom)",
    "returnType" : "boolean",
    "comment" : "\n     * Return true if the specified rectangle, after being transformed by the\n     * current matrix, would lie completely outside of the current clip. Call\n     * this to check if an area you intend to draw into is clipped out (and\n     * therefore you can skip making the draw calls).\n     *\n     * @param left        The left side of the rectangle to compare with the\n     *                    current clip\n     * @param top         The top of the rectangle to compare with the current\n     *                    clip\n     * @param right       The right side of the rectangle to compare with the\n     *                    current clip\n     * @param bottom      The bottom of the rectangle to compare with the\n     *                    current clip\n     * @return            true if the rect (transformed by the canvas' matrix)\n     *                    does not intersect with the canvas' clip\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean getClipBounds(@Nullable Rect bounds)",
    "returnType" : "boolean",
    "comment" : "\n     * Return the bounds of the current clip (in local coordinates) in the\n     * bounds parameter, and return true if it is non-empty. This can be useful\n     * in a way similar to quickReject, in that it tells you that drawing\n     * outside of these bounds will be clipped out.\n     *\n     * @param bounds Return the clip bounds here. If it is null, ignore it but\n     *               still return true if the current clip is non-empty.\n     * @return true if the current clip is non-empty.\n     ",
    "links" : [ ]
  }, {
    "name" : "public final Rect getClipBounds()",
    "returnType" : "Rect",
    "comment" : "\n     * Retrieve the bounds of the current clip (in local coordinates).\n     *\n     * @return the clip bounds, or [0, 0, 0, 0] if the clip is empty.\n     ",
    "links" : [ ]
  }, {
    "name" : "public void drawPicture(@NonNull Picture picture)",
    "returnType" : "void",
    "comment" : "\n     * Save the canvas state, draw the picture, and restore the canvas state.\n     * This differs from picture.draw(canvas), which does not perform any\n     * save/restore.\n     *\n     * <p>\n     * <strong>Note:</strong> This forces the picture to internally call\n     * {@link Picture#endRecording} in order to prepare for playback.\n     *\n     * @param picture  The picture to be drawn\n     ",
    "links" : [ "android.graphics.Picture#endRecording" ]
  }, {
    "name" : "public void drawPicture(@NonNull Picture picture, @NonNull RectF dst)",
    "returnType" : "void",
    "comment" : "\n     * Draw the picture, stretched to fit into the dst rectangle.\n     ",
    "links" : [ ]
  }, {
    "name" : "public void drawPicture(@NonNull Picture picture, @NonNull Rect dst)",
    "returnType" : "void",
    "comment" : "\n     * Draw the picture, stretched to fit into the dst rectangle.\n     ",
    "links" : [ ]
  }, {
    "name" : "public void release()",
    "returnType" : "void",
    "comment" : "\n     * Releases the resources associated with this canvas.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public static void freeCaches()",
    "returnType" : "void",
    "comment" : "\n     * Free up as much memory as possible from private caches (e.g. fonts, images)\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public static void freeTextLayoutCaches()",
    "returnType" : "void",
    "comment" : "\n     * Free up text layout caches\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public static void setCompatibilityVersion(int apiLevel)",
    "returnType" : "void",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "private static native void nFreeCaches()",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private static native void nFreeTextLayoutCaches()",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private static native long nGetNativeFinalizer()",
    "returnType" : "long",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private static native void nSetCompatibilityVersion(int apiLevel)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private static native long nInitRaster(long bitmapHandle)",
    "returnType" : "long",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private static native void nSetBitmap(long canvasHandle, long bitmapHandle)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private static native boolean nGetClipBounds(long nativeCanvas, Rect bounds)",
    "returnType" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private static native boolean nIsOpaque(long canvasHandle)",
    "returnType" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private static native int nGetWidth(long canvasHandle)",
    "returnType" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private static native int nGetHeight(long canvasHandle)",
    "returnType" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private static native int nSave(long canvasHandle, int saveFlags)",
    "returnType" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private static native int nSaveLayer(long nativeCanvas, float l, float t, float r, float b, long nativePaint, int layerFlags)",
    "returnType" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private static native int nSaveLayerAlpha(long nativeCanvas, float l, float t, float r, float b, int alpha, int layerFlags)",
    "returnType" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private static native int nSaveUnclippedLayer(long nativeCanvas, int l, int t, int r, int b)",
    "returnType" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private static native void nRestoreUnclippedLayer(long nativeCanvas, int saveCount, long nativePaint)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private static native boolean nRestore(long canvasHandle)",
    "returnType" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private static native void nRestoreToCount(long canvasHandle, int saveCount)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private static native int nGetSaveCount(long canvasHandle)",
    "returnType" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private static native void nTranslate(long canvasHandle, float dx, float dy)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private static native void nScale(long canvasHandle, float sx, float sy)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private static native void nRotate(long canvasHandle, float degrees)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private static native void nSkew(long canvasHandle, float sx, float sy)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private static native void nConcat(long nativeCanvas, long nativeMatrix)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private static native void nSetMatrix(long nativeCanvas, long nativeMatrix)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private static native boolean nClipRect(long nativeCanvas, float left, float top, float right, float bottom, int regionOp)",
    "returnType" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private static native boolean nClipPath(long nativeCanvas, long nativePath, int regionOp)",
    "returnType" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private static native void nSetDrawFilter(long nativeCanvas, long nativeFilter)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private static native void nGetMatrix(long nativeCanvas, long nativeMatrix)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private static native boolean nQuickReject(long nativeCanvas, long nativePath)",
    "returnType" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private static native boolean nQuickReject(long nativeCanvas, float left, float top, float right, float bottom)",
    "returnType" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public void drawArc(@NonNull RectF oval, float startAngle, float sweepAngle, boolean useCenter, @NonNull Paint paint)",
    "returnType" : "void",
    "comment" : "\n     * <p>\n     * Draw the specified arc, which will be scaled to fit inside the specified oval.\n     * </p>\n     * <p>\n     * If the start angle is negative or >= 360, the start angle is treated as start angle modulo\n     * 360.\n     * </p>\n     * <p>\n     * If the sweep angle is >= 360, then the oval is drawn completely. Note that this differs\n     * slightly from SkPath::arcTo, which treats the sweep angle modulo 360. If the sweep angle is\n     * negative, the sweep angle is treated as sweep angle modulo 360\n     * </p>\n     * <p>\n     * The arc is drawn clockwise. An angle of 0 degrees correspond to the geometric angle of 0\n     * degrees (3 o'clock on a watch.)\n     * </p>\n     *\n     * @param oval The bounds of oval used to define the shape and size of the arc\n     * @param startAngle Starting angle (in degrees) where the arc begins\n     * @param sweepAngle Sweep angle (in degrees) measured clockwise\n     * @param useCenter If true, include the center of the oval in the arc, and close it if it is\n     *            being stroked. This will draw a wedge\n     * @param paint The paint used to draw the arc\n     ",
    "links" : [ ]
  }, {
    "name" : "public void drawArc(float left, float top, float right, float bottom, float startAngle, float sweepAngle, boolean useCenter, @NonNull Paint paint)",
    "returnType" : "void",
    "comment" : "\n     * <p>\n     * Draw the specified arc, which will be scaled to fit inside the specified oval.\n     * </p>\n     * <p>\n     * If the start angle is negative or >= 360, the start angle is treated as start angle modulo\n     * 360.\n     * </p>\n     * <p>\n     * If the sweep angle is >= 360, then the oval is drawn completely. Note that this differs\n     * slightly from SkPath::arcTo, which treats the sweep angle modulo 360. If the sweep angle is\n     * negative, the sweep angle is treated as sweep angle modulo 360\n     * </p>\n     * <p>\n     * The arc is drawn clockwise. An angle of 0 degrees correspond to the geometric angle of 0\n     * degrees (3 o'clock on a watch.)\n     * </p>\n     *\n     * @param startAngle Starting angle (in degrees) where the arc begins\n     * @param sweepAngle Sweep angle (in degrees) measured clockwise\n     * @param useCenter If true, include the center of the oval in the arc, and close it if it is\n     *            being stroked. This will draw a wedge\n     * @param paint The paint used to draw the arc\n     ",
    "links" : [ ]
  }, {
    "name" : "public void drawARGB(int a, int r, int g, int b)",
    "returnType" : "void",
    "comment" : "\n     * Fill the entire canvas' bitmap (restricted to the current clip) with the specified ARGB\n     * color, using srcover porterduff mode.\n     *\n     * @param a alpha component (0..255) of the color to draw onto the canvas\n     * @param r red component (0..255) of the color to draw onto the canvas\n     * @param g green component (0..255) of the color to draw onto the canvas\n     * @param b blue component (0..255) of the color to draw onto the canvas\n     ",
    "links" : [ ]
  }, {
    "name" : "public void drawBitmap(@NonNull Bitmap bitmap, float left, float top, @Nullable Paint paint)",
    "returnType" : "void",
    "comment" : "\n     * Draw the specified bitmap, with its top/left corner at (x,y), using the specified paint,\n     * transformed by the current matrix.\n     * <p>\n     * Note: if the paint contains a maskfilter that generates a mask which extends beyond the\n     * bitmap's original width/height (e.g. BlurMaskFilter), then the bitmap will be drawn as if it\n     * were in a Shader with CLAMP mode. Thus the color outside of the original width/height will be\n     * the edge color replicated.\n     * <p>\n     * If the bitmap and canvas have different densities, this function will take care of\n     * automatically scaling the bitmap to draw at the same density as the canvas.\n     *\n     * @param bitmap The bitmap to be drawn\n     * @param left The position of the left side of the bitmap being drawn\n     * @param top The position of the top side of the bitmap being drawn\n     * @param paint The paint used to draw the bitmap (may be null)\n     ",
    "links" : [ ]
  }, {
    "name" : "public void drawBitmap(@NonNull Bitmap bitmap, @Nullable Rect src, @NonNull RectF dst, @Nullable Paint paint)",
    "returnType" : "void",
    "comment" : "\n     * Draw the specified bitmap, scaling/translating automatically to fill the destination\n     * rectangle. If the source rectangle is not null, it specifies the subset of the bitmap to\n     * draw.\n     * <p>\n     * Note: if the paint contains a maskfilter that generates a mask which extends beyond the\n     * bitmap's original width/height (e.g. BlurMaskFilter), then the bitmap will be drawn as if it\n     * were in a Shader with CLAMP mode. Thus the color outside of the original width/height will be\n     * the edge color replicated.\n     * <p>\n     * This function <em>ignores the density associated with the bitmap</em>. This is because the\n     * source and destination rectangle coordinate spaces are in their respective densities, so must\n     * already have the appropriate scaling factor applied.\n     *\n     * @param bitmap The bitmap to be drawn\n     * @param src May be null. The subset of the bitmap to be drawn\n     * @param dst The rectangle that the bitmap will be scaled/translated to fit into\n     * @param paint May be null. The paint used to draw the bitmap\n     ",
    "links" : [ ]
  }, {
    "name" : "public void drawBitmap(@NonNull Bitmap bitmap, @Nullable Rect src, @NonNull Rect dst, @Nullable Paint paint)",
    "returnType" : "void",
    "comment" : "\n     * Draw the specified bitmap, scaling/translating automatically to fill the destination\n     * rectangle. If the source rectangle is not null, it specifies the subset of the bitmap to\n     * draw.\n     * <p>\n     * Note: if the paint contains a maskfilter that generates a mask which extends beyond the\n     * bitmap's original width/height (e.g. BlurMaskFilter), then the bitmap will be drawn as if it\n     * were in a Shader with CLAMP mode. Thus the color outside of the original width/height will be\n     * the edge color replicated.\n     * <p>\n     * This function <em>ignores the density associated with the bitmap</em>. This is because the\n     * source and destination rectangle coordinate spaces are in their respective densities, so must\n     * already have the appropriate scaling factor applied.\n     *\n     * @param bitmap The bitmap to be drawn\n     * @param src May be null. The subset of the bitmap to be drawn\n     * @param dst The rectangle that the bitmap will be scaled/translated to fit into\n     * @param paint May be null. The paint used to draw the bitmap\n     ",
    "links" : [ ]
  }, {
    "name" : "public void drawBitmap(@NonNull int[] colors, int offset, int stride, float x, float y, int width, int height, boolean hasAlpha, @Nullable Paint paint)",
    "returnType" : "void",
    "comment" : "\n     * Treat the specified array of colors as a bitmap, and draw it. This gives the same result as\n     * first creating a bitmap from the array, and then drawing it, but this method avoids\n     * explicitly creating a bitmap object which can be more efficient if the colors are changing\n     * often.\n     *\n     * @param colors Array of colors representing the pixels of the bitmap\n     * @param offset Offset into the array of colors for the first pixel\n     * @param stride The number of colors in the array between rows (must be >= width or <= -width).\n     * @param x The X coordinate for where to draw the bitmap\n     * @param y The Y coordinate for where to draw the bitmap\n     * @param width The width of the bitmap\n     * @param height The height of the bitmap\n     * @param hasAlpha True if the alpha channel of the colors contains valid values. If false, the\n     *            alpha byte is ignored (assumed to be 0xFF for every pixel).\n     * @param paint May be null. The paint used to draw the bitmap\n     * @deprecated Usage with a {@link #isHardwareAccelerated() hardware accelerated} canvas\n     *             requires an internal copy of color buffer contents every time this method is\n     *             called. Using a Bitmap avoids this copy, and allows the application to more\n     *             explicitly control the lifetime and copies of pixel data.\n     ",
    "links" : [ "#isHardwareAccelerated()" ]
  }, {
    "name" : "public void drawBitmap(@NonNull int[] colors, int offset, int stride, int x, int y, int width, int height, boolean hasAlpha, @Nullable Paint paint)",
    "returnType" : "void",
    "comment" : "\n     * Legacy version of drawBitmap(int[] colors, ...) that took ints for x,y\n     *\n     * @deprecated Usage with a {@link #isHardwareAccelerated() hardware accelerated} canvas\n     *             requires an internal copy of color buffer contents every time this method is\n     *             called. Using a Bitmap avoids this copy, and allows the application to more\n     *             explicitly control the lifetime and copies of pixel data.\n     ",
    "links" : [ "#isHardwareAccelerated()" ]
  }, {
    "name" : "public void drawBitmap(@NonNull Bitmap bitmap, @NonNull Matrix matrix, @Nullable Paint paint)",
    "returnType" : "void",
    "comment" : "\n     * Draw the bitmap using the specified matrix.\n     *\n     * @param bitmap The bitmap to draw\n     * @param matrix The matrix used to transform the bitmap when it is drawn\n     * @param paint May be null. The paint used to draw the bitmap\n     ",
    "links" : [ ]
  }, {
    "name" : "public void drawBitmapMesh(@NonNull Bitmap bitmap, int meshWidth, int meshHeight, @NonNull float[] verts, int vertOffset, @Nullable int[] colors, int colorOffset, @Nullable Paint paint)",
    "returnType" : "void",
    "comment" : "\n     * Draw the bitmap through the mesh, where mesh vertices are evenly distributed across the\n     * bitmap. There are meshWidth+1 vertices across, and meshHeight+1 vertices down. The verts\n     * array is accessed in row-major order, so that the first meshWidth+1 vertices are distributed\n     * across the top of the bitmap from left to right. A more general version of this method is\n     * drawVertices().\n     *\n     * Prior to API level {@value Build.VERSION_CODES#P} vertOffset and colorOffset were ignored,\n     * effectively treating them as zeros. In API level {@value Build.VERSION_CODES#P} and above\n     * these parameters will be respected.\n     *\n     * @param bitmap The bitmap to draw using the mesh\n     * @param meshWidth The number of columns in the mesh. Nothing is drawn if this is 0\n     * @param meshHeight The number of rows in the mesh. Nothing is drawn if this is 0\n     * @param verts Array of x,y pairs, specifying where the mesh should be drawn. There must be at\n     *            least (meshWidth+1) * (meshHeight+1) * 2 + vertOffset values in the array\n     * @param vertOffset Number of verts elements to skip before drawing\n     * @param colors May be null. Specifies a color at each vertex, which is interpolated across the\n     *            cell, and whose values are multiplied by the corresponding bitmap colors. If not\n     *            null, there must be at least (meshWidth+1) * (meshHeight+1) + colorOffset values\n     *            in the array.\n     * @param colorOffset Number of color elements to skip before drawing\n     * @param paint May be null. The paint used to draw the bitmap\n     ",
    "links" : [ ]
  }, {
    "name" : "public void drawCircle(float cx, float cy, float radius, @NonNull Paint paint)",
    "returnType" : "void",
    "comment" : "\n     * Draw the specified circle using the specified paint. If radius is <= 0, then nothing will be\n     * drawn. The circle will be filled or framed based on the Style in the paint.\n     *\n     * @param cx The x-coordinate of the center of the circle to be drawn\n     * @param cy The y-coordinate of the center of the circle to be drawn\n     * @param radius The radius of the circle to be drawn\n     * @param paint The paint used to draw the circle\n     ",
    "links" : [ ]
  }, {
    "name" : "public void drawColor(@ColorInt int color)",
    "returnType" : "void",
    "comment" : "\n     * Fill the entire canvas' bitmap (restricted to the current clip) with the specified color,\n     * using srcover porterduff mode.\n     *\n     * @param color the color to draw onto the canvas\n     ",
    "links" : [ ]
  }, {
    "name" : "public void drawColor(@ColorLong long color)",
    "returnType" : "void",
    "comment" : "\n     * Fill the entire canvas' bitmap (restricted to the current clip) with the specified color,\n     * using srcover porterduff mode.\n     *\n     * @param color the {@code ColorLong} to draw onto the canvas. See the {@link Color}\n     *              class for details about {@code ColorLong}s.\n     * @throws IllegalArgumentException if the color space encoded in the {@code ColorLong}\n     *                                  is invalid or unknown.\n     ",
    "links" : [ "android.graphics.Color" ]
  }, {
    "name" : "public void drawColor(@ColorInt int color, @NonNull PorterDuff.Mode mode)",
    "returnType" : "void",
    "comment" : "\n     * Fill the entire canvas' bitmap (restricted to the current clip) with the specified color and\n     * porter-duff xfermode.\n     *\n     * @param color the color to draw onto the canvas\n     * @param mode the porter-duff mode to apply to the color\n     ",
    "links" : [ ]
  }, {
    "name" : "public void drawColor(@ColorInt int color, @NonNull BlendMode mode)",
    "returnType" : "void",
    "comment" : "\n     * Fill the entire canvas' bitmap (restricted to the current clip) with the specified color and\n     * blendmode.\n     *\n     * @param color the color to draw onto the canvas\n     * @param mode the blendmode to apply to the color\n     ",
    "links" : [ ]
  }, {
    "name" : "public void drawColor(@ColorLong long color, @NonNull BlendMode mode)",
    "returnType" : "void",
    "comment" : "\n     * Fill the entire canvas' bitmap (restricted to the current clip) with the specified color and\n     * blendmode.\n     *\n     * @param color the {@code ColorLong} to draw onto the canvas. See the {@link Color}\n     *              class for details about {@code ColorLong}s.\n     * @param mode the blendmode to apply to the color\n     * @throws IllegalArgumentException if the color space encoded in the {@code ColorLong}\n     *                                  is invalid or unknown.\n     ",
    "links" : [ "android.graphics.Color" ]
  }, {
    "name" : "public void drawLine(float startX, float startY, float stopX, float stopY, @NonNull Paint paint)",
    "returnType" : "void",
    "comment" : "\n     * Draw a line segment with the specified start and stop x,y coordinates, using the specified\n     * paint.\n     * <p>\n     * Note that since a line is always \"framed\", the Style is ignored in the paint.\n     * </p>\n     * <p>\n     * Degenerate lines (length is 0) will not be drawn.\n     * </p>\n     *\n     * @param startX The x-coordinate of the start point of the line\n     * @param startY The y-coordinate of the start point of the line\n     * @param paint The paint used to draw the line\n     ",
    "links" : [ ]
  }, {
    "name" : "public void drawLines(@Size(multiple = 4) @NonNull float[] pts, int offset, int count, @NonNull Paint paint)",
    "returnType" : "void",
    "comment" : "\n     * Draw a series of lines. Each line is taken from 4 consecutive values in the pts array. Thus\n     * to draw 1 line, the array must contain at least 4 values. This is logically the same as\n     * drawing the array as follows: drawLine(pts[0], pts[1], pts[2], pts[3]) followed by\n     * drawLine(pts[4], pts[5], pts[6], pts[7]) and so on.\n     *\n     * @param pts Array of points to draw [x0 y0 x1 y1 x2 y2 ...]\n     * @param offset Number of values in the array to skip before drawing.\n     * @param count The number of values in the array to process, after skipping \"offset\" of them.\n     *            Since each line uses 4 values, the number of \"lines\" that are drawn is really\n     *            (count >> 2).\n     * @param paint The paint used to draw the points\n     ",
    "links" : [ ]
  }, {
    "name" : "public void drawLines(@Size(multiple = 4) @NonNull float[] pts, @NonNull Paint paint)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public void drawOval(@NonNull RectF oval, @NonNull Paint paint)",
    "returnType" : "void",
    "comment" : "\n     * Draw the specified oval using the specified paint. The oval will be filled or framed based on\n     * the Style in the paint.\n     *\n     * @param oval The rectangle bounds of the oval to be drawn\n     ",
    "links" : [ ]
  }, {
    "name" : "public void drawOval(float left, float top, float right, float bottom, @NonNull Paint paint)",
    "returnType" : "void",
    "comment" : "\n     * Draw the specified oval using the specified paint. The oval will be filled or framed based on\n     * the Style in the paint.\n     ",
    "links" : [ ]
  }, {
    "name" : "public void drawPaint(@NonNull Paint paint)",
    "returnType" : "void",
    "comment" : "\n     * Fill the entire canvas' bitmap (restricted to the current clip) with the specified paint.\n     * This is equivalent (but faster) to drawing an infinitely large rectangle with the specified\n     * paint.\n     *\n     * @param paint The paint used to draw onto the canvas\n     ",
    "links" : [ ]
  }, {
    "name" : "public void drawPatch(@NonNull NinePatch patch, @NonNull Rect dst, @Nullable Paint paint)",
    "returnType" : "void",
    "comment" : "\n     * Draws the specified bitmap as an N-patch (most often, a 9-patches.)\n     *\n     * @param patch The ninepatch object to render\n     * @param dst The destination rectangle.\n     * @param paint The paint to draw the bitmap with. may be null\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public void drawPatch(@NonNull NinePatch patch, @NonNull RectF dst, @Nullable Paint paint)",
    "returnType" : "void",
    "comment" : "\n     * Draws the specified bitmap as an N-patch (most often, a 9-patches.)\n     *\n     * @param patch The ninepatch object to render\n     * @param dst The destination rectangle.\n     * @param paint The paint to draw the bitmap with. may be null\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public void drawPath(@NonNull Path path, @NonNull Paint paint)",
    "returnType" : "void",
    "comment" : "\n     * Draw the specified path using the specified paint. The path will be filled or framed based on\n     * the Style in the paint.\n     *\n     * @param path The path to be drawn\n     * @param paint The paint used to draw the path\n     ",
    "links" : [ ]
  }, {
    "name" : "public void drawPoint(float x, float y, @NonNull Paint paint)",
    "returnType" : "void",
    "comment" : "\n     * Helper for drawPoints() for drawing a single point.\n     ",
    "links" : [ ]
  }, {
    "name" : "public void drawPoints(@Size(multiple = 2) float[] pts, int offset, int count, @NonNull Paint paint)",
    "returnType" : "void",
    "comment" : "\n     * Draw a series of points. Each point is centered at the coordinate specified by pts[], and its\n     * diameter is specified by the paint's stroke width (as transformed by the canvas' CTM), with\n     * special treatment for a stroke width of 0, which always draws exactly 1 pixel (or at most 4\n     * if antialiasing is enabled). The shape of the point is controlled by the paint's Cap type.\n     * The shape is a square, unless the cap type is Round, in which case the shape is a circle.\n     *\n     * @param pts Array of points to draw [x0 y0 x1 y1 x2 y2 ...]\n     * @param offset Number of values to skip before starting to draw.\n     * @param count The number of values to process, after skipping offset of them. Since one point\n     *            uses two values, the number of \"points\" that are drawn is really (count >> 1).\n     * @param paint The paint used to draw the points\n     ",
    "links" : [ ]
  }, {
    "name" : "public void drawPoints(@Size(multiple = 2) @NonNull float[] pts, @NonNull Paint paint)",
    "returnType" : "void",
    "comment" : "\n     * Helper for drawPoints() that assumes you want to draw the entire array\n     ",
    "links" : [ ]
  }, {
    "name" : "public void drawPosText(@NonNull char[] text, int index, int count, @NonNull @Size(multiple = 2) float[] pos, @NonNull Paint paint)",
    "returnType" : "void",
    "comment" : "\n     * Draw the text in the array, with each character's origin specified by the pos array.\n     *\n     * @param text The text to be drawn\n     * @param index The index of the first character to draw\n     * @param count The number of characters to draw, starting from index.\n     * @param pos Array of [x,y] positions, used to position each character\n     * @param paint The paint used for the text (e.g. color, size, style)\n     * @deprecated This method does not support glyph composition and decomposition and should\n     *             therefore not be used to render complex scripts. It also doesn't handle\n     *             supplementary characters (eg emoji).\n     ",
    "links" : [ ]
  }, {
    "name" : "public void drawPosText(@NonNull String text, @NonNull @Size(multiple = 2) float[] pos, @NonNull Paint paint)",
    "returnType" : "void",
    "comment" : "\n     * Draw the text in the array, with each character's origin specified by the pos array.\n     *\n     * @param text The text to be drawn\n     * @param pos Array of [x,y] positions, used to position each character\n     * @param paint The paint used for the text (e.g. color, size, style)\n     * @deprecated This method does not support glyph composition and decomposition and should\n     *             therefore not be used to render complex scripts. It also doesn't handle\n     *             supplementary characters (eg emoji).\n     ",
    "links" : [ ]
  }, {
    "name" : "public void drawRect(@NonNull RectF rect, @NonNull Paint paint)",
    "returnType" : "void",
    "comment" : "\n     * Draw the specified Rect using the specified paint. The rectangle will be filled or framed\n     * based on the Style in the paint.\n     *\n     * @param rect The rect to be drawn\n     * @param paint The paint used to draw the rect\n     ",
    "links" : [ ]
  }, {
    "name" : "public void drawRect(@NonNull Rect r, @NonNull Paint paint)",
    "returnType" : "void",
    "comment" : "\n     * Draw the specified Rect using the specified Paint. The rectangle will be filled or framed\n     * based on the Style in the paint.\n     *\n     * @param r The rectangle to be drawn.\n     * @param paint The paint used to draw the rectangle\n     ",
    "links" : [ ]
  }, {
    "name" : "public void drawRect(float left, float top, float right, float bottom, @NonNull Paint paint)",
    "returnType" : "void",
    "comment" : "\n     * Draw the specified Rect using the specified paint. The rectangle will be filled or framed\n     * based on the Style in the paint.\n     *\n     * @param left The left side of the rectangle to be drawn\n     * @param top The top side of the rectangle to be drawn\n     * @param right The right side of the rectangle to be drawn\n     * @param bottom The bottom side of the rectangle to be drawn\n     * @param paint The paint used to draw the rect\n     ",
    "links" : [ ]
  }, {
    "name" : "public void drawRGB(int r, int g, int b)",
    "returnType" : "void",
    "comment" : "\n     * Fill the entire canvas' bitmap (restricted to the current clip) with the specified RGB color,\n     * using srcover porterduff mode.\n     *\n     * @param r red component (0..255) of the color to draw onto the canvas\n     * @param g green component (0..255) of the color to draw onto the canvas\n     * @param b blue component (0..255) of the color to draw onto the canvas\n     ",
    "links" : [ ]
  }, {
    "name" : "public void drawRoundRect(@NonNull RectF rect, float rx, float ry, @NonNull Paint paint)",
    "returnType" : "void",
    "comment" : "\n     * Draw the specified round-rect using the specified paint. The roundrect will be filled or\n     * framed based on the Style in the paint.\n     *\n     * @param rect The rectangular bounds of the roundRect to be drawn\n     * @param rx The x-radius of the oval used to round the corners\n     * @param ry The y-radius of the oval used to round the corners\n     * @param paint The paint used to draw the roundRect\n     ",
    "links" : [ ]
  }, {
    "name" : "public void drawRoundRect(float left, float top, float right, float bottom, float rx, float ry, @NonNull Paint paint)",
    "returnType" : "void",
    "comment" : "\n     * Draw the specified round-rect using the specified paint. The roundrect will be filled or\n     * framed based on the Style in the paint.\n     *\n     * @param rx The x-radius of the oval used to round the corners\n     * @param ry The y-radius of the oval used to round the corners\n     * @param paint The paint used to draw the roundRect\n     ",
    "links" : [ ]
  }, {
    "name" : "public void drawDoubleRoundRect(@NonNull RectF outer, float outerRx, float outerRy, @NonNull RectF inner, float innerRx, float innerRy, @NonNull Paint paint)",
    "returnType" : "void",
    "comment" : "\n     * Draws a double rounded rectangle using the specified paint. The resultant round rect\n     * will be filled in the area defined between the outer and inner rectangular bounds if\n     * the {@link Paint} configured with {@link Paint.Style#FILL}.\n     * Otherwise if {@link Paint.Style#STROKE} is used, then 2 rounded rect strokes will\n     * be drawn at the outer and inner rounded rectangles\n     *\n     * @param outer The outer rectangular bounds of the roundRect to be drawn\n     * @param outerRx The x-radius of the oval used to round the corners on the outer rectangle\n     * @param outerRy The y-radius of the oval used to round the corners on the outer rectangle\n     * @param inner The inner rectangular bounds of the roundRect to be drawn\n     * @param innerRx The x-radius of the oval used to round the corners on the inner rectangle\n     * @param innerRy The y-radius of the oval used to round the corners on the outer rectangle\n     * @param paint The paint used to draw the double roundRect\n     ",
    "links" : [ "Paint.Style#STROKE", "Paint.Style#FILL", "android.graphics.Paint" ]
  }, {
    "name" : "public void drawDoubleRoundRect(@NonNull RectF outer, @NonNull float[] outerRadii, @NonNull RectF inner, @NonNull float[] innerRadii, @NonNull Paint paint)",
    "returnType" : "void",
    "comment" : "\n     * Draws a double rounded rectangle using the specified paint. The resultant round rect\n     * will be filled in the area defined between the outer and inner rectangular bounds if\n     * the {@link Paint} configured with {@link Paint.Style#FILL}.\n     * Otherwise if {@link Paint.Style#STROKE} is used, then 2 rounded rect strokes will\n     * be drawn at the outer and inner rounded rectangles\n     *\n     * @param outer The outer rectangular bounds of the roundRect to be drawn\n     * @param outerRadii Array of 8 float representing the x, y corner radii for top left,\n     *                   top right, bottom right, bottom left corners respectively on the outer\n     *                   rounded rectangle\n     *\n     * @param inner The inner rectangular bounds of the roundRect to be drawn\n     * @param innerRadii Array of 8 float representing the x, y corner radii for top left,\n     *                   top right, bottom right, bottom left corners respectively on the\n     *                   outer rounded rectangle\n     * @param paint The paint used to draw the double roundRect\n     ",
    "links" : [ "Paint.Style#STROKE", "Paint.Style#FILL", "android.graphics.Paint" ]
  }, {
    "name" : "public void drawText(@NonNull char[] text, int index, int count, float x, float y, @NonNull Paint paint)",
    "returnType" : "void",
    "comment" : "\n     * Draw the text, with origin at (x,y), using the specified paint. The origin is interpreted\n     * based on the Align setting in the paint.\n     *\n     * @param text The text to be drawn\n     * @param x The x-coordinate of the origin of the text being drawn\n     * @param y The y-coordinate of the baseline of the text being drawn\n     * @param paint The paint used for the text (e.g. color, size, style)\n     ",
    "links" : [ ]
  }, {
    "name" : "public void drawText(@NonNull String text, float x, float y, @NonNull Paint paint)",
    "returnType" : "void",
    "comment" : "\n     * Draw the text, with origin at (x,y), using the specified paint. The origin is interpreted\n     * based on the Align setting in the paint.\n     *\n     * @param text The text to be drawn\n     * @param x The x-coordinate of the origin of the text being drawn\n     * @param y The y-coordinate of the baseline of the text being drawn\n     * @param paint The paint used for the text (e.g. color, size, style)\n     ",
    "links" : [ ]
  }, {
    "name" : "public void drawText(@NonNull String text, int start, int end, float x, float y, @NonNull Paint paint)",
    "returnType" : "void",
    "comment" : "\n     * Draw the text, with origin at (x,y), using the specified paint. The origin is interpreted\n     * based on the Align setting in the paint.\n     *\n     * @param text The text to be drawn\n     * @param start The index of the first character in text to draw\n     * @param end (end - 1) is the index of the last character in text to draw\n     * @param x The x-coordinate of the origin of the text being drawn\n     * @param y The y-coordinate of the baseline of the text being drawn\n     * @param paint The paint used for the text (e.g. color, size, style)\n     ",
    "links" : [ ]
  }, {
    "name" : "public void drawText(@NonNull CharSequence text, int start, int end, float x, float y, @NonNull Paint paint)",
    "returnType" : "void",
    "comment" : "\n     * Draw the specified range of text, specified by start/end, with its origin at (x,y), in the\n     * specified Paint. The origin is interpreted based on the Align setting in the Paint.\n     *\n     * @param text The text to be drawn\n     * @param start The index of the first character in text to draw\n     * @param end (end - 1) is the index of the last character in text to draw\n     * @param x The x-coordinate of origin for where to draw the text\n     * @param y The y-coordinate of origin for where to draw the text\n     * @param paint The paint used for the text (e.g. color, size, style)\n     ",
    "links" : [ ]
  }, {
    "name" : "public void drawTextOnPath(@NonNull char[] text, int index, int count, @NonNull Path path, float hOffset, float vOffset, @NonNull Paint paint)",
    "returnType" : "void",
    "comment" : "\n     * Draw the text, with origin at (x,y), using the specified paint, along the specified path. The\n     * paint's Align setting determines where along the path to start the text.\n     *\n     * @param text The text to be drawn\n     * @param index The starting index within the text to be drawn\n     * @param count Starting from index, the number of characters to draw\n     * @param path The path the text should follow for its baseline\n     * @param hOffset The distance along the path to add to the text's starting position\n     * @param vOffset The distance above(-) or below(+) the path to position the text\n     * @param paint The paint used for the text (e.g. color, size, style)\n     ",
    "links" : [ ]
  }, {
    "name" : "public void drawTextOnPath(@NonNull String text, @NonNull Path path, float hOffset, float vOffset, @NonNull Paint paint)",
    "returnType" : "void",
    "comment" : "\n     * Draw the text, with origin at (x,y), using the specified paint, along the specified path. The\n     * paint's Align setting determines where along the path to start the text.\n     *\n     * @param text The text to be drawn\n     * @param path The path the text should follow for its baseline\n     * @param hOffset The distance along the path to add to the text's starting position\n     * @param vOffset The distance above(-) or below(+) the path to position the text\n     * @param paint The paint used for the text (e.g. color, size, style)\n     ",
    "links" : [ ]
  }, {
    "name" : "public void drawTextRun(@NonNull char[] text, int index, int count, int contextIndex, int contextCount, float x, float y, boolean isRtl, @NonNull Paint paint)",
    "returnType" : "void",
    "comment" : "\n     * Draw a run of text, all in a single direction, with optional context for complex text\n     * shaping.\n     * <p>\n     * See {@link #drawTextRun(CharSequence, int, int, int, int, float, float, boolean, Paint)} for\n     * more details. This method uses a character array rather than CharSequence to represent the\n     * string. Also, to be consistent with the pattern established in {@link #drawText}, in this\n     * method {@code count} and {@code contextCount} are used rather than offsets of the end\n     * position; {@code count = end - start, contextCount = contextEnd -\n     * contextStart}.\n     *\n     * @param text the text to render\n     * @param index the start of the text to render\n     * @param count the count of chars to render\n     * @param contextIndex the start of the context for shaping. Must be no greater than index.\n     * @param contextCount the number of characters in the context for shaping. contexIndex +\n     *            contextCount must be no less than index + count.\n     * @param x the x position at which to draw the text\n     * @param y the y position at which to draw the text\n     * @param isRtl whether the run is in RTL direction\n     * @param paint the paint\n     ",
    "links" : [ "#drawText", "#drawTextRun(CharSequence" ]
  }, {
    "name" : "public void drawTextRun(@NonNull CharSequence text, int start, int end, int contextStart, int contextEnd, float x, float y, boolean isRtl, @NonNull Paint paint)",
    "returnType" : "void",
    "comment" : "\n     * Draw a run of text, all in a single direction, with optional context for complex text\n     * shaping.\n     * <p>\n     * The run of text includes the characters from {@code start} to {@code end} in the text. In\n     * addition, the range {@code contextStart} to {@code contextEnd} is used as context for the\n     * purpose of complex text shaping, such as Arabic text potentially shaped differently based on\n     * the text next to it.\n     * <p>\n     * All text outside the range {@code contextStart..contextEnd} is ignored. The text between\n     * {@code start} and {@code end} will be laid out and drawn. The context range is useful for\n     * contextual shaping, e.g. Kerning, Arabic contextural form.\n     * <p>\n     * The direction of the run is explicitly specified by {@code isRtl}. Thus, this method is\n     * suitable only for runs of a single direction. Alignment of the text is as determined by the\n     * Paint's TextAlign value. Further, {@code 0 <= contextStart <= start <= end <= contextEnd\n     * <= text.length} must hold on entry.\n     * <p>\n     * Also see {@link android.graphics.Paint#getRunAdvance} for a corresponding method to measure\n     * the text; the advance width of the text drawn matches the value obtained from that method.\n     *\n     * @param text the text to render\n     * @param start the start of the text to render. Data before this position can be used for\n     *            shaping context.\n     * @param end the end of the text to render. Data at or after this position can be used for\n     *            shaping context.\n     * @param contextStart the index of the start of the shaping context\n     * @param contextEnd the index of the end of the shaping context\n     * @param x the x position at which to draw the text\n     * @param y the y position at which to draw the text\n     * @param isRtl whether the run is in RTL direction\n     * @param paint the paint\n     * @see #drawTextRun(char[], int, int, int, int, float, float, boolean, Paint)\n     ",
    "links" : [ "android.graphics.Paint#getRunAdvance" ]
  }, {
    "name" : "public void drawTextRun(@NonNull MeasuredText text, int start, int end, int contextStart, int contextEnd, float x, float y, boolean isRtl, @NonNull Paint paint)",
    "returnType" : "void",
    "comment" : "\n     * Draw a run of text, all in a single direction, with optional context for complex text\n     * shaping.\n     * <p>\n     * See {@link #drawTextRun(CharSequence, int, int, int, int, float, float, boolean, Paint)} for\n     * more details. This method uses a {@link MeasuredText} rather than CharSequence to represent\n     * the string.\n     *\n     * @param text the text to render\n     * @param start the start of the text to render. Data before this position can be used for\n     *            shaping context.\n     * @param end the end of the text to render. Data at or after this position can be used for\n     *            shaping context.\n     * @param contextStart the index of the start of the shaping context\n     * @param contextEnd the index of the end of the shaping context\n     * @param x the x position at which to draw the text\n     * @param y the y position at which to draw the text\n     * @param isRtl whether the run is in RTL direction\n     * @param paint the paint\n     ",
    "links" : [ "android.graphics.text.MeasuredText", "#drawTextRun(CharSequence" ]
  }, {
    "name" : "public void drawVertices(@NonNull VertexMode mode, int vertexCount, @NonNull float[] verts, int vertOffset, @Nullable float[] texs, int texOffset, @Nullable int[] colors, int colorOffset, @Nullable short[] indices, int indexOffset, int indexCount, @NonNull Paint paint)",
    "returnType" : "void",
    "comment" : "\n     * Draw the array of vertices, interpreted as triangles (based on mode). The verts array is\n     * required, and specifies the x,y pairs for each vertex. If texs is non-null, then it is used\n     * to specify the coordinate in shader coordinates to use at each vertex (the paint must have a\n     * shader in this case). If there is no texs array, but there is a color array, then each color\n     * is interpolated across its corresponding triangle in a gradient. If both texs and colors\n     * arrays are present, then they behave as before, but the resulting color at each pixels is the\n     * result of multiplying the colors from the shader and the color-gradient together. The indices\n     * array is optional, but if it is present, then it is used to specify the index of each\n     * triangle, rather than just walking through the arrays in order.\n     *\n     * @param mode How to interpret the array of vertices\n     * @param vertexCount The number of values in the vertices array (and corresponding texs and\n     *            colors arrays if non-null). Each logical vertex is two values (x, y), vertexCount\n     *            must be a multiple of 2.\n     * @param verts Array of vertices for the mesh\n     * @param vertOffset Number of values in the verts to skip before drawing.\n     * @param texs May be null. If not null, specifies the coordinates to sample into the current\n     *            shader (e.g. bitmap tile or gradient)\n     * @param texOffset Number of values in texs to skip before drawing.\n     * @param colors May be null. If not null, specifies a color for each vertex, to be interpolated\n     *            across the triangle.\n     * @param colorOffset Number of values in colors to skip before drawing.\n     * @param indices If not null, array of indices to reference into the vertex (texs, colors)\n     *            array.\n     * @param indexCount number of entries in the indices array (if not null).\n     * @param paint Specifies the shader to use if the texs array is non-null.\n     ",
    "links" : [ ]
  }, {
    "name" : "public void drawRenderNode(@NonNull RenderNode renderNode)",
    "returnType" : "void",
    "comment" : "\n     * Draws the given RenderNode. This is only supported in hardware rendering, which can be\n     * verified by asserting that {@link #isHardwareAccelerated()} is true. If\n     * {@link #isHardwareAccelerated()} is false then this throws an exception.\n     *\n     * See {@link RenderNode} for more information on what a RenderNode is and how to use it.\n     *\n     * @param renderNode The RenderNode to draw, must be non-null.\n     ",
    "links" : [ "#isHardwareAccelerated()", "android.graphics.RenderNode" ]
  } ],
  "variableNames" : [ "sCompatiblityVersion", "sCompatibilityRestore", "sCompatibilitySetBitmap", "mBitmap", "mDrawFilter", "MAXMIMUM_BITMAP_SIZE", "mFinalizer", "MATRIX_SAVE_FLAG", "CLIP_SAVE_FLAG", "HAS_ALPHA_LAYER_SAVE_FLAG", "FULL_COLOR_LAYER_SAVE_FLAG", "CLIP_TO_LAYER_SAVE_FLAG", "ALL_SAVE_FLAG" ],
  "methodNames" : [ "public long getNativeCanvasWrapper()", "public boolean isRecordingFor(Object o)", "protected GL getGL()", "public boolean isHardwareAccelerated()", "public void setBitmap(@Nullable Bitmap bitmap)", "public void insertReorderBarrier()", "public void insertInorderBarrier()", "public void enableZ()", "public void disableZ()", "public boolean isOpaque()", "public int getWidth()", "public int getHeight()", "public int getDensity()", "public void setDensity(int density)", "public void setScreenDensity(int density)", "public int getMaximumBitmapWidth()", "public int getMaximumBitmapHeight()", "private static void checkValidSaveFlags(int saveFlags)", "public int save()", "public int save(@Saveflags int saveFlags)", "public int saveLayer(@Nullable RectF bounds, @Nullable Paint paint, @Saveflags int saveFlags)", "public int saveLayer(@Nullable RectF bounds, @Nullable Paint paint)", "public int saveUnclippedLayer(int left, int top, int right, int bottom)", "public void restoreUnclippedLayer(int saveCount, Paint paint)", "public int saveLayer(float left, float top, float right, float bottom, @Nullable Paint paint, @Saveflags int saveFlags)", "public int saveLayer(float left, float top, float right, float bottom, @Nullable Paint paint)", "public int saveLayerAlpha(@Nullable RectF bounds, int alpha, @Saveflags int saveFlags)", "public int saveLayerAlpha(@Nullable RectF bounds, int alpha)", "public int saveLayerAlpha(float left, float top, float right, float bottom, int alpha, @Saveflags int saveFlags)", "public int saveLayerAlpha(float left, float top, float right, float bottom, int alpha)", "public void restore()", "public int getSaveCount()", "public void restoreToCount(int saveCount)", "public void translate(float dx, float dy)", "public void scale(float sx, float sy)", "public final void scale(float sx, float sy, float px, float py)", "public void rotate(float degrees)", "public final void rotate(float degrees, float px, float py)", "public void skew(float sx, float sy)", "public void concat(@Nullable Matrix matrix)", "public void setMatrix(@Nullable Matrix matrix)", "public void getMatrix(@NonNull Matrix ctm)", "public final Matrix getMatrix()", "private static void checkValidClipOp(@NonNull Region.Op op)", "public boolean clipRect(@NonNull RectF rect, @NonNull Region.Op op)", "public boolean clipRect(@NonNull Rect rect, @NonNull Region.Op op)", "public boolean clipRectUnion(@NonNull Rect rect)", "public boolean clipRect(@NonNull RectF rect)", "public boolean clipOutRect(@NonNull RectF rect)", "public boolean clipRect(@NonNull Rect rect)", "public boolean clipOutRect(@NonNull Rect rect)", "public boolean clipRect(float left, float top, float right, float bottom, @NonNull Region.Op op)", "public boolean clipRect(float left, float top, float right, float bottom)", "public boolean clipOutRect(float left, float top, float right, float bottom)", "public boolean clipRect(int left, int top, int right, int bottom)", "public boolean clipOutRect(int left, int top, int right, int bottom)", "public boolean clipPath(@NonNull Path path, @NonNull Region.Op op)", "public boolean clipPath(@NonNull Path path)", "public boolean clipOutPath(@NonNull Path path)", "public boolean clipRegion(@NonNull Region region, @NonNull Region.Op op)", "public boolean clipRegion(@NonNull Region region)", "public DrawFilter getDrawFilter()", "public void setDrawFilter(@Nullable DrawFilter filter)", "public boolean quickReject(@NonNull RectF rect, @NonNull EdgeType type)", "public boolean quickReject(@NonNull RectF rect)", "public boolean quickReject(@NonNull Path path, @NonNull EdgeType type)", "public boolean quickReject(@NonNull Path path)", "public boolean quickReject(float left, float top, float right, float bottom, @NonNull EdgeType type)", "public boolean quickReject(float left, float top, float right, float bottom)", "public boolean getClipBounds(@Nullable Rect bounds)", "public final Rect getClipBounds()", "public void drawPicture(@NonNull Picture picture)", "public void drawPicture(@NonNull Picture picture, @NonNull RectF dst)", "public void drawPicture(@NonNull Picture picture, @NonNull Rect dst)", "public void release()", "public static void freeCaches()", "public static void freeTextLayoutCaches()", "public static void setCompatibilityVersion(int apiLevel)", "private static native void nFreeCaches()", "private static native void nFreeTextLayoutCaches()", "private static native long nGetNativeFinalizer()", "private static native void nSetCompatibilityVersion(int apiLevel)", "private static native long nInitRaster(long bitmapHandle)", "private static native void nSetBitmap(long canvasHandle, long bitmapHandle)", "private static native boolean nGetClipBounds(long nativeCanvas, Rect bounds)", "private static native boolean nIsOpaque(long canvasHandle)", "private static native int nGetWidth(long canvasHandle)", "private static native int nGetHeight(long canvasHandle)", "private static native int nSave(long canvasHandle, int saveFlags)", "private static native int nSaveLayer(long nativeCanvas, float l, float t, float r, float b, long nativePaint, int layerFlags)", "private static native int nSaveLayerAlpha(long nativeCanvas, float l, float t, float r, float b, int alpha, int layerFlags)", "private static native int nSaveUnclippedLayer(long nativeCanvas, int l, int t, int r, int b)", "private static native void nRestoreUnclippedLayer(long nativeCanvas, int saveCount, long nativePaint)", "private static native boolean nRestore(long canvasHandle)", "private static native void nRestoreToCount(long canvasHandle, int saveCount)", "private static native int nGetSaveCount(long canvasHandle)", "private static native void nTranslate(long canvasHandle, float dx, float dy)", "private static native void nScale(long canvasHandle, float sx, float sy)", "private static native void nRotate(long canvasHandle, float degrees)", "private static native void nSkew(long canvasHandle, float sx, float sy)", "private static native void nConcat(long nativeCanvas, long nativeMatrix)", "private static native void nSetMatrix(long nativeCanvas, long nativeMatrix)", "private static native boolean nClipRect(long nativeCanvas, float left, float top, float right, float bottom, int regionOp)", "private static native boolean nClipPath(long nativeCanvas, long nativePath, int regionOp)", "private static native void nSetDrawFilter(long nativeCanvas, long nativeFilter)", "private static native void nGetMatrix(long nativeCanvas, long nativeMatrix)", "private static native boolean nQuickReject(long nativeCanvas, long nativePath)", "private static native boolean nQuickReject(long nativeCanvas, float left, float top, float right, float bottom)", "public void drawArc(@NonNull RectF oval, float startAngle, float sweepAngle, boolean useCenter, @NonNull Paint paint)", "public void drawArc(float left, float top, float right, float bottom, float startAngle, float sweepAngle, boolean useCenter, @NonNull Paint paint)", "public void drawARGB(int a, int r, int g, int b)", "public void drawBitmap(@NonNull Bitmap bitmap, float left, float top, @Nullable Paint paint)", "public void drawBitmap(@NonNull Bitmap bitmap, @Nullable Rect src, @NonNull RectF dst, @Nullable Paint paint)", "public void drawBitmap(@NonNull Bitmap bitmap, @Nullable Rect src, @NonNull Rect dst, @Nullable Paint paint)", "public void drawBitmap(@NonNull int[] colors, int offset, int stride, float x, float y, int width, int height, boolean hasAlpha, @Nullable Paint paint)", "public void drawBitmap(@NonNull int[] colors, int offset, int stride, int x, int y, int width, int height, boolean hasAlpha, @Nullable Paint paint)", "public void drawBitmap(@NonNull Bitmap bitmap, @NonNull Matrix matrix, @Nullable Paint paint)", "public void drawBitmapMesh(@NonNull Bitmap bitmap, int meshWidth, int meshHeight, @NonNull float[] verts, int vertOffset, @Nullable int[] colors, int colorOffset, @Nullable Paint paint)", "public void drawCircle(float cx, float cy, float radius, @NonNull Paint paint)", "public void drawColor(@ColorInt int color)", "public void drawColor(@ColorLong long color)", "public void drawColor(@ColorInt int color, @NonNull PorterDuff.Mode mode)", "public void drawColor(@ColorInt int color, @NonNull BlendMode mode)", "public void drawColor(@ColorLong long color, @NonNull BlendMode mode)", "public void drawLine(float startX, float startY, float stopX, float stopY, @NonNull Paint paint)", "public void drawLines(@Size(multiple = 4) @NonNull float[] pts, int offset, int count, @NonNull Paint paint)", "public void drawLines(@Size(multiple = 4) @NonNull float[] pts, @NonNull Paint paint)", "public void drawOval(@NonNull RectF oval, @NonNull Paint paint)", "public void drawOval(float left, float top, float right, float bottom, @NonNull Paint paint)", "public void drawPaint(@NonNull Paint paint)", "public void drawPatch(@NonNull NinePatch patch, @NonNull Rect dst, @Nullable Paint paint)", "public void drawPatch(@NonNull NinePatch patch, @NonNull RectF dst, @Nullable Paint paint)", "public void drawPath(@NonNull Path path, @NonNull Paint paint)", "public void drawPoint(float x, float y, @NonNull Paint paint)", "public void drawPoints(@Size(multiple = 2) float[] pts, int offset, int count, @NonNull Paint paint)", "public void drawPoints(@Size(multiple = 2) @NonNull float[] pts, @NonNull Paint paint)", "public void drawPosText(@NonNull char[] text, int index, int count, @NonNull @Size(multiple = 2) float[] pos, @NonNull Paint paint)", "public void drawPosText(@NonNull String text, @NonNull @Size(multiple = 2) float[] pos, @NonNull Paint paint)", "public void drawRect(@NonNull RectF rect, @NonNull Paint paint)", "public void drawRect(@NonNull Rect r, @NonNull Paint paint)", "public void drawRect(float left, float top, float right, float bottom, @NonNull Paint paint)", "public void drawRGB(int r, int g, int b)", "public void drawRoundRect(@NonNull RectF rect, float rx, float ry, @NonNull Paint paint)", "public void drawRoundRect(float left, float top, float right, float bottom, float rx, float ry, @NonNull Paint paint)", "public void drawDoubleRoundRect(@NonNull RectF outer, float outerRx, float outerRy, @NonNull RectF inner, float innerRx, float innerRy, @NonNull Paint paint)", "public void drawDoubleRoundRect(@NonNull RectF outer, @NonNull float[] outerRadii, @NonNull RectF inner, @NonNull float[] innerRadii, @NonNull Paint paint)", "public void drawText(@NonNull char[] text, int index, int count, float x, float y, @NonNull Paint paint)", "public void drawText(@NonNull String text, float x, float y, @NonNull Paint paint)", "public void drawText(@NonNull String text, int start, int end, float x, float y, @NonNull Paint paint)", "public void drawText(@NonNull CharSequence text, int start, int end, float x, float y, @NonNull Paint paint)", "public void drawTextOnPath(@NonNull char[] text, int index, int count, @NonNull Path path, float hOffset, float vOffset, @NonNull Paint paint)", "public void drawTextOnPath(@NonNull String text, @NonNull Path path, float hOffset, float vOffset, @NonNull Paint paint)", "public void drawTextRun(@NonNull char[] text, int index, int count, int contextIndex, int contextCount, float x, float y, boolean isRtl, @NonNull Paint paint)", "public void drawTextRun(@NonNull CharSequence text, int start, int end, int contextStart, int contextEnd, float x, float y, boolean isRtl, @NonNull Paint paint)", "public void drawTextRun(@NonNull MeasuredText text, int start, int end, int contextStart, int contextEnd, float x, float y, boolean isRtl, @NonNull Paint paint)", "public void drawVertices(@NonNull VertexMode mode, int vertexCount, @NonNull float[] verts, int vertOffset, @Nullable float[] texs, int texOffset, @Nullable int[] colors, int colorOffset, @Nullable short[] indices, int indexOffset, int indexCount, @NonNull Paint paint)", "public void drawRenderNode(@NonNull RenderNode renderNode)" ]
}