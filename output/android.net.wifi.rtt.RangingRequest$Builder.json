{
  "filePath" : "/home/maryam/clearblue/files/android-source-35/android/net/wifi/rtt/RangingRequest.java",
  "packageName" : "android.net.wifi.rtt",
  "className" : "Builder",
  "comment" : "\n     * Builder class used to construct {@link RangingRequest} objects.\n     ",
  "links" : [ "android.net.wifi.rtt.RangingRequest" ],
  "variables" : [ {
    "name" : "mRttPeers",
    "type" : "List<ResponderConfig>",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mRttBurstSize",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mVendorData",
    "type" : "List<OuiKeyedData>",
    "comment" : "",
    "links" : [ ]
  } ],
  "methods" : [ {
    "name" : "public Builder setRttBurstSize(int rttBurstSize)",
    "returnType" : "Builder",
    "comment" : "\n         * Set the RTT Burst size for the ranging request.\n         * <p>\n         * If not set, the default RTT burst size given by\n         * {@link #getDefaultRttBurstSize()} is used to determine the default value.\n         * If set, the value must be in the range {@link #getMinRttBurstSize()} and\n         * {@link #getMaxRttBurstSize()} inclusively, or a\n         * {@link java.lang.IllegalArgumentException} will be thrown.\n         *\n         * Note: RTT burst size is applicable to IEEE 802.11mc, and for one special case it is\n         * also applicable to IEEE 802.11az to generate multiple NTB ranging requests per\n         * measurement. It is applicable for IEEE 802.11az based ranging requests when MIMO is\n         * not available, with the transmit and receive spatial streams between the initiator and\n         * responder station is equal to 1. See\n         * {@link RangingResult#get80211azNumberOfRxSpatialStreams()} and\n         * {@link RangingResult#get80211azNumberOfTxSpatialStreams()}.\n         *\n         * @param rttBurstSize The number of FTM packets used to estimate a range.\n         * @return The builder to facilitate chaining\n         * {@code builder.setXXX(..).setXXX(..)}.\n         ",
    "links" : [ "android.net.wifi.rtt.RangingResult#get80211azNumberOfRxSpatialStreams()", "#getMaxRttBurstSize()", "#getDefaultRttBurstSize()", "android.net.wifi.rtt.RangingResult#get80211azNumberOfTxSpatialStreams()", "java.lang.IllegalArgumentException", "#getMinRttBurstSize()" ]
  }, {
    "name" : "public Builder addAccessPoint(@NonNull ScanResult apInfo)",
    "returnType" : "Builder",
    "comment" : "\n         * Add the device specified by the {@link ScanResult} to the list of devices with\n         * which to measure range. The total number of peers added to a request cannot exceed the\n         * limit specified by {@link #getMaxPeers()}.\n         * <p>\n         * Two-sided Ranging will be performed if the local device and the AP support IEEE 802.11az\n         * (non-trigger based ranging) or IEEE 802.11mc. AP capability is determined by the method\n         * {@link ScanResult#is80211azNtbResponder()} or {@link ScanResult#is80211mcResponder()}.\n         *\n         * If both 11az and 11mc are supported by the local device and the AP, 11az non-trigger\n         * based ranging will be performed.\n         *\n         * If two-sided ranging is not supported, one-sided RTT will be performed with no\n         * correction for the AP packet turnaround time.\n         *\n         * @param apInfo Information about an Access Point (AP) obtained in a Scan Result.\n         * @return The builder to facilitate chaining\n         *         {@code builder.setXXX(..).setXXX(..)}.\n         ",
    "links" : [ "android.net.wifi.ScanResult", "android.net.wifi.ScanResult#is80211mcResponder()", "#getMaxPeers()", "android.net.wifi.ScanResult#is80211azNtbResponder()" ]
  }, {
    "name" : "public Builder addAccessPoints(@NonNull List<ScanResult> apInfos)",
    "returnType" : "Builder",
    "comment" : "\n         * Add the devices specified by the {@link ScanResult}s to the list of devices with\n         * which to measure range. The total number of peers added to a request cannot exceed the\n         * limit specified by {@link #getMaxPeers()}.\n         * <p>\n         * Two-sided Ranging will be performed if the local device and the AP support IEEE 802.11az\n         * (non-trigger based ranging) or IEEE 802.11mc. AP capability is determined by the method\n         * {@link ScanResult#is80211azNtbResponder()} or {@link ScanResult#is80211mcResponder()}.\n         *\n         * If both 11az and 11mc are supported by the local device and the AP, 11az non-trigger\n         * based ranging will be performed.\n         *\n         * If two-sided ranging is not supported, one-sided RTT will be performed with no\n         * correction for the AP packet turnaround time.\n         *\n         * @param apInfos Information about Access Points (APs) obtained in a Scan Result.\n         * @return The builder to facilitate chaining\n         *         {@code builder.setXXX(..).setXXX(..)}.\n         ",
    "links" : [ "android.net.wifi.ScanResult", "android.net.wifi.ScanResult#is80211mcResponder()", "#getMaxPeers()", "android.net.wifi.ScanResult#is80211azNtbResponder()" ]
  }, {
    "name" : "public Builder addResponder(@NonNull ResponderConfig responder)",
    "returnType" : "Builder",
    "comment" : "\n         * Add the Responder device specified by the {@link ResponderConfig} to the list of devices\n         * with which to measure range. The total number of peers added to the request cannot exceed\n         * the limit specified by {@link #getMaxPeers()}.\n         * <p>\n         * Two-sided Ranging will be performed if the local device and the AP support IEEE 802.11az\n         * (non-trigger based ranging) or IEEE 802.11mc. AP capability is determined by the method\n         * {@link ScanResult#is80211azNtbResponder()} or {@link ScanResult#is80211mcResponder()}.\n         *\n         * If both 11az and 11mc are supported by the local device and the AP, 11az non-trigger\n         * based ranging will be performed.\n         *\n         * If two-sided ranging is not supported, one-sided RTT will be performed with no\n         * correction for the AP packet turnaround time.\n         *\n         * @param responder Information on the RTT Responder.\n         * @return The builder, to facilitate chaining {@code builder.setXXX(..).setXXX(..)}.\n         ",
    "links" : [ "android.net.wifi.rtt.ResponderConfig", "android.net.wifi.ScanResult#is80211mcResponder()", "#getMaxPeers()", "android.net.wifi.ScanResult#is80211azNtbResponder()" ]
  }, {
    "name" : "public Builder addResponders(@NonNull List<ResponderConfig> responders)",
    "returnType" : "Builder",
    "comment" : "\n         * Add the devices specified by the {@link ResponderConfig}s to the list of devices with\n         * which to measure range. The total number of peers added to a request cannot exceed the\n         * limit specified by {@link #getMaxPeers()}.\n         * <p>\n         * Two-sided Ranging will be performed if the local device and the AP support IEEE 802.11az\n         * (non-trigger based ranging) or IEEE 802.11mc. AP capability is determined by the method\n         * {@link ScanResult#is80211azNtbResponder()} or {@link ScanResult#is80211mcResponder()}.\n         *\n         * If both 11az and 11mc are supported by the local device and the AP, 11az non-trigger\n         * based ranging will be performed.\n         *\n         * If two-sided ranging is not supported, one-sided RTT will be performed with no\n         * correction for the AP packet turnaround time.\n         *\n         * @param responders Information representing the set of access points to be ranged\n         * @return The builder to facilitate chaining\n         *         {@code builder.setXXX(..).setXXX(..)}.\n         ",
    "links" : [ "android.net.wifi.rtt.ResponderConfig", "android.net.wifi.ScanResult#is80211mcResponder()", "#getMaxPeers()", "android.net.wifi.ScanResult#is80211azNtbResponder()" ]
  }, {
    "name" : "public Builder addNon80211mcCapableAccessPoint(@NonNull ScanResult apInfo)",
    "returnType" : "Builder",
    "comment" : "\n         * Add the non-802.11mc and non-802.11az capable device specified by the {@link ScanResult}\n         * to the list of devices with which to measure range. The total number of peers added to a\n         * request cannot exceed the limit specified by {@link #getMaxPeers()}.\n         * <p>\n         * Accurate ranging cannot be supported if the Access Point does not support IEEE 802.11mc\n         * and IEEE 802.11az, and instead an alternate protocol called one-sided RTT will be used\n         * with lower accuracy. Use {@link ScanResult#is80211mcResponder()} to verify the Access\n         * Point(s) are not 802.11mc capable. Use {@link ScanResult#is80211azNtbResponder()} ()} to\n         * verify the Access Point)s) are not 802.11az capable.\n         * <p>\n         * One-sided RTT does not subtract the RTT turnaround time at the Access Point, which can\n         * add hundreds of meters to the estimate. With experimentation, it is possible to use this\n         * information to make a statistical estimate of the range by taking multiple measurements\n         * to several Access Points and normalizing the result. For some applications this can be\n         * used to improve range estimates based on Receive Signal Strength Indication (RSSI), but\n         * will not be as accurate as IEEE 802.11mc (two-sided RTT).\n         * <p>\n         * Note: one-sided RTT should only be used if you are very familiar with statistical\n         * estimation techniques.\n         *\n         * @param apInfo Information about an Access Point (AP) obtained in a Scan Result\n         * @return The builder to facilitate chaining\n         *         {@code builder.setXXX(..).setXXX(..)}.\n         ",
    "links" : [ "android.net.wifi.ScanResult", "android.net.wifi.ScanResult#is80211mcResponder()", "#getMaxPeers()", "android.net.wifi.ScanResult#is80211azNtbResponder()" ]
  }, {
    "name" : "public Builder addNon80211mcCapableAccessPoints(@NonNull List<ScanResult> apInfos)",
    "returnType" : "Builder",
    "comment" : "\n         * Add the non-802.11mc and non-802.11az capable devices specified by the {@link ScanResult}\n         * to the list of devices with which to measure range. The total number of peers added to a\n         * request cannot exceed the limit specified by {@link #getMaxPeers()}.\n         * <p>\n         * Accurate ranging cannot be supported if the Access Point does not support IEEE 802.11mc\n         * and IEEE 802.11az, and instead an alternate protocol called one-sided RTT will be used\n         * with lower accuracy. Use {@link ScanResult#is80211mcResponder()} to verify the Access\n         * Point(s) are not 802.11mc capable. Use {@link ScanResult#is80211azNtbResponder()} ()} to\n         * verify the Access Point(s) are not 802.11az capable.\n         * <p>\n         * One-sided RTT does not subtract the RTT turnaround time at the Access Point, which can\n         * add hundreds of meters to the estimate. With experimentation, it is possible to use this\n         * information to make a statistical estimate of the range by taking multiple measurements\n         * to several Access Points and normalizing the result. For some applications this can be\n         * used to improve range estimates based on Receive Signal Strength Indication (RSSI), but\n         * will not be as accurate as IEEE 802.11mc (two-sided RTT).\n         * <p>\n         * Note: one-sided RTT should only be used if you are very familiar with statistical\n         * estimation techniques.\n         *\n         * @param apInfos Information about Access Points (APs) obtained in a Scan Result.\n         * @return The builder to facilitate chaining\n         *         {@code builder.setXXX(..).setXXX(..)}.\n         ",
    "links" : [ "android.net.wifi.ScanResult", "android.net.wifi.ScanResult#is80211mcResponder()", "#getMaxPeers()", "android.net.wifi.ScanResult#is80211azNtbResponder()" ]
  }, {
    "name" : "public Builder addWifiAwarePeer(@NonNull MacAddress peerMacAddress)",
    "returnType" : "Builder",
    "comment" : "\n         * Add the device specified by the {@code peerMacAddress} to the list of devices with\n         * which to measure range.\n         * <p>\n         * The MAC address may be obtained out-of-band from a peer Wi-Fi Aware device. A Wi-Fi\n         * Aware device may obtain its MAC address using the {@link IdentityChangedListener}\n         * provided to\n         * {@link WifiAwareManager#attach(AttachCallback, IdentityChangedListener, Handler)}.\n         * <p>\n         * Note: in order to use this API the device must support Wi-Fi Aware\n         * {@link android.net.wifi.aware}. The peer device which is being ranged to must be\n         * configured to publish a service (with any name) with:\n         * <li>Type {@link android.net.wifi.aware.PublishConfig#PUBLISH_TYPE_UNSOLICITED}.\n         * <li>Ranging enabled\n         * {@link android.net.wifi.aware.PublishConfig.Builder#setRangingEnabled(boolean)}.\n         *\n         * @param peerMacAddress The MAC address of the Wi-Fi Aware peer.\n         * @return The builder, to facilitate chaining {@code builder.setXXX(..).setXXX(..)}.\n         ",
    "links" : [ "android.net.wifi.aware.PublishConfig#PUBLISH_TYPE_UNSOLICITED", "android.net.wifi.aware.IdentityChangedListener", "android.net.wifi.aware", "android.net.wifi.aware.WifiAwareManager#attach(AttachCallback", "android.net.wifi.aware.PublishConfig.Builder#setRangingEnabled(boolean)" ]
  }, {
    "name" : "public Builder addWifiAwarePeer(@NonNull PeerHandle peerHandle)",
    "returnType" : "Builder",
    "comment" : "\n         * Add a device specified by a {@link PeerHandle} to the list of devices with which to\n         * measure range.\n         * <p>\n         * The {@link PeerHandle} may be obtained as part of the Wi-Fi Aware discovery process. E.g.\n         * using {@link DiscoverySessionCallback#onServiceDiscovered(PeerHandle, byte[], List)}.\n         * <p>\n         * Note: in order to use this API the device must support Wi-Fi Aware\n         * {@link android.net.wifi.aware}. The requesting device can be either publisher or\n         * subscriber in a discovery session. For both requesting device and peer device ranging\n         * must be enabled on the discovery session:\n         * <li>{@link android.net.wifi.aware.PublishConfig.Builder#setRangingEnabled(boolean)} for\n         * publisher.</li>\n         * <li>Either {@link android.net.wifi.aware.SubscribeConfig.Builder#setMinDistanceMm(int)}\n         * or {@link android.net.wifi.aware.SubscribeConfig.Builder#setMaxDistanceMm(int)} must be\n         * set to enable ranging on subscriber </li>\n         *\n         * @param peerHandle The peer handler of the peer Wi-Fi Aware device.\n         * @return The builder, to facilitate chaining {@code builder.setXXX(..).setXXX(..)}.\n         ",
    "links" : [ "android.net.wifi.aware.DiscoverySessionCallback#onServiceDiscovered(PeerHandle", "android.net.wifi.aware.SubscribeConfig.Builder#setMinDistanceMm(int)", "android.net.wifi.aware.SubscribeConfig.Builder#setMaxDistanceMm(int)", "android.net.wifi.aware", "android.net.wifi.aware.PeerHandle", "android.net.wifi.aware.PublishConfig.Builder#setRangingEnabled(boolean)" ]
  }, {
    "name" : "public Builder setVendorData(@NonNull List<OuiKeyedData> vendorData)",
    "returnType" : "Builder",
    "comment" : "\n         * Set additional vendor-provided configuration data.\n         *\n         * @param vendorData List of {@link OuiKeyedData} containing the vendor-provided\n         *     configuration data. Note that multiple elements with the same OUI are allowed.\n         * @return Builder for chaining.\n         * @hide\n         ",
    "links" : [ "android.net.wifi.OuiKeyedData" ]
  }, {
    "name" : "public RangingRequest build()",
    "returnType" : "RangingRequest",
    "comment" : "\n         * Build {@link RangingRequest} given the current configurations made on the\n         * builder.\n         ",
    "links" : [ "android.net.wifi.rtt.RangingRequest" ]
  } ],
  "methodNames" : [ "public Builder setRttBurstSize(int rttBurstSize)", "public Builder addAccessPoint(@NonNull ScanResult apInfo)", "public Builder addAccessPoints(@NonNull List<ScanResult> apInfos)", "public Builder addResponder(@NonNull ResponderConfig responder)", "public Builder addResponders(@NonNull List<ResponderConfig> responders)", "public Builder addNon80211mcCapableAccessPoint(@NonNull ScanResult apInfo)", "public Builder addNon80211mcCapableAccessPoints(@NonNull List<ScanResult> apInfos)", "public Builder addWifiAwarePeer(@NonNull MacAddress peerMacAddress)", "public Builder addWifiAwarePeer(@NonNull PeerHandle peerHandle)", "public Builder setVendorData(@NonNull List<OuiKeyedData> vendorData)", "public RangingRequest build()" ],
  "variableNames" : [ "mRttPeers", "mRttBurstSize", "mVendorData" ]
}