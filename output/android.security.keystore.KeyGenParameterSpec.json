{
  "filePath" : "/home/maryam/clearblue/files/android-source-35/android/security/keystore/KeyGenParameterSpec.java",
  "packageName" : "android.security.keystore",
  "className" : "KeyGenParameterSpec",
  "comment" : "\n * {@link AlgorithmParameterSpec} for initializing a {@link KeyPairGenerator} or a\n * {@link KeyGenerator} of the <a href=\"{@docRoot}training/articles/keystore.html\">Android Keystore\n * system</a>. The spec determines authorized uses of the key, such as whether user authentication\n * is required for using the key, what operations are authorized (e.g., signing, but not\n * decryption), with what parameters (e.g., only with a particular padding scheme or digest), and\n * the key's validity start and end dates. Key use authorizations expressed in the spec apply\n * only to secret keys and private keys -- public keys can be used for any supported operations.\n *\n * <p>To generate an asymmetric key pair or a symmetric key, create an instance of this class using\n * the {@link Builder}, initialize a {@code KeyPairGenerator} or a {@code KeyGenerator} of the\n * desired key type (e.g., {@code EC} or {@code AES} -- see\n * {@link KeyProperties}.{@code KEY_ALGORITHM} constants) from the {@code AndroidKeyStore} provider\n * with the {@code KeyGenParameterSpec} instance, and then generate a key or key pair using\n * {@link KeyGenerator#generateKey()} or {@link KeyPairGenerator#generateKeyPair()}.\n *\n * <p>The generated key pair or key will be returned by the generator and also stored in the Android\n * Keystore under the alias specified in this spec. To obtain the secret or private key from the\n * Android Keystore use {@link java.security.KeyStore#getKey(String, char[]) KeyStore.getKey(String, null)}\n * or {@link java.security.KeyStore#getEntry(String, java.security.KeyStore.ProtectionParameter) KeyStore.getEntry(String, null)}.\n * To obtain the public key from the Android Keystore use\n * {@link java.security.KeyStore#getCertificate(String)} and then\n * {@link Certificate#getPublicKey()}.\n *\n * <p>To help obtain algorithm-specific public parameters of key pairs stored in the Android\n * Keystore, generated private keys implement {@link java.security.interfaces.ECKey} or\n * {@link java.security.interfaces.RSAKey} interfaces whereas public keys implement\n * {@link java.security.interfaces.ECPublicKey} or {@link java.security.interfaces.RSAPublicKey}\n * interfaces.\n *\n * <p>For asymmetric key pairs, a X.509 certificate will be also generated and stored in the Android\n * Keystore. This is because the {@link java.security.KeyStore} abstraction does not support storing\n * key pairs without a certificate. The subject, serial number, and validity dates of the\n * certificate can be customized in this spec. The certificate may be replaced at a later time by a\n * certificate signed by a Certificate Authority (CA).\n *\n * <p>NOTE: If attestation is not requested using {@link Builder#setAttestationChallenge(byte[])},\n * generated certificate may be self-signed. If a private key is not authorized to sign the\n * certificate, then the certificate will be created with an invalid signature which will not\n * verify. Such a certificate is still useful because it provides access to the public key. To\n * generate a valid signature for the certificate the key needs to be authorized for all of the\n * following:\n * <ul>\n * <li>{@link KeyProperties#PURPOSE_SIGN},</li>\n * <li>operation without requiring the user to be authenticated (see\n * {@link Builder#setUserAuthenticationRequired(boolean)}),</li>\n * <li>signing/origination at this moment in time (see {@link Builder#setKeyValidityStart(Date)}\n * and {@link Builder#setKeyValidityForOriginationEnd(Date)}),</li>\n * <li>suitable digest,</li>\n * <li>(RSA keys only) padding scheme {@link KeyProperties#SIGNATURE_PADDING_RSA_PKCS1}.</li>\n * </ul>\n *\n * <p>NOTE: The key material of the generated symmetric and private keys is not accessible. The key\n * material of the public keys is accessible.\n *\n * <p>Instances of this class are immutable.\n *\n * <p><h3>Known issues</h3>\n * A known bug in Android 6.0 (API Level 23) causes user authentication-related authorizations to be\n * enforced even for public keys. To work around this issue extract the public key material to use\n * outside of Android Keystore. For example:\n * <pre> {@code\n * PublicKey unrestrictedPublicKey =\n *         KeyFactory.getInstance(publicKey.getAlgorithm()).generatePublic(\n *                 new X509EncodedKeySpec(publicKey.getEncoded()));\n * }</pre>\n *\n * <p><h3>Example: NIST P-256 EC key pair for signing/verification using ECDSA</h3>\n * This example illustrates how to generate a NIST P-256 (aka secp256r1 aka prime256v1) EC key pair\n * in the Android KeyStore system under alias {@code key1} where the private key is authorized to be\n * used only for signing using SHA-256, SHA-384, or SHA-512 digest and only if the user has been\n * authenticated within the last five minutes. The use of the public key is unrestricted (See Known\n * Issues).\n * <pre> {@code\n * KeyPairGenerator keyPairGenerator = KeyPairGenerator.getInstance(\n *         KeyProperties.KEY_ALGORITHM_EC, \"AndroidKeyStore\");\n * keyPairGenerator.initialize(\n *         new KeyGenParameterSpec.Builder(\n *                 \"key1\",\n *                 KeyProperties.PURPOSE_SIGN)\n *                 .setAlgorithmParameterSpec(new ECGenParameterSpec(\"secp256r1\"))\n *                 .setDigests(KeyProperties.DIGEST_SHA256,\n *                         KeyProperties.DIGEST_SHA384,\n *                         KeyProperties.DIGEST_SHA512)\n *                 // Only permit the private key to be used if the user authenticated\n *                 // within the last five minutes.\n *                 .setUserAuthenticationRequired(true)\n *                 .setUserAuthenticationValidityDurationSeconds(5 * 60)\n *                 .build());\n * KeyPair keyPair = keyPairGenerator.generateKeyPair();\n * Signature signature = Signature.getInstance(\"SHA256withECDSA\");\n * signature.initSign(keyPair.getPrivate());\n * ...\n *\n * // The key pair can also be obtained from the Android Keystore any time as follows:\n * KeyStore keyStore = KeyStore.getInstance(\"AndroidKeyStore\");\n * keyStore.load(null);\n * PrivateKey privateKey = (PrivateKey) keyStore.getKey(\"key1\", null);\n * PublicKey publicKey = keyStore.getCertificate(\"key1\").getPublicKey();\n * }</pre>\n *\n * <p><h3>Example: RSA key pair for signing/verification using RSA-PSS</h3>\n * This example illustrates how to generate an RSA key pair in the Android KeyStore system under\n * alias {@code key1} authorized to be used only for signing using the RSA-PSS signature padding\n * scheme with SHA-256 or SHA-512 digests. The use of the public key is unrestricted.\n * <pre> {@code\n * KeyPairGenerator keyPairGenerator = KeyPairGenerator.getInstance(\n *         KeyProperties.KEY_ALGORITHM_RSA, \"AndroidKeyStore\");\n * keyPairGenerator.initialize(\n *         new KeyGenParameterSpec.Builder(\n *                 \"key1\",\n *                 KeyProperties.PURPOSE_SIGN)\n *                 .setDigests(KeyProperties.DIGEST_SHA256, KeyProperties.DIGEST_SHA512)\n *                 .setSignaturePaddings(KeyProperties.SIGNATURE_PADDING_RSA_PSS)\n *                 .build());\n * KeyPair keyPair = keyPairGenerator.generateKeyPair();\n * Signature signature = Signature.getInstance(\"SHA256withRSA/PSS\");\n * signature.initSign(keyPair.getPrivate());\n * ...\n *\n * // The key pair can also be obtained from the Android Keystore any time as follows:\n * KeyStore keyStore = KeyStore.getInstance(\"AndroidKeyStore\");\n * keyStore.load(null);\n * PrivateKey privateKey = (PrivateKey) keyStore.getKey(\"key1\", null);\n * PublicKey publicKey = keyStore.getCertificate(\"key1\").getPublicKey();\n * }</pre>\n *\n * <p><h3>Example: RSA key pair for encryption/decryption using RSA OAEP</h3>\n * This example illustrates how to generate an RSA key pair in the Android KeyStore system under\n * alias {@code key1} where the private key is authorized to be used only for decryption using RSA\n * OAEP encryption padding scheme with SHA-256 or SHA-512 digests. The use of the public key is\n * unrestricted.\n * <pre> {@code\n * KeyPairGenerator keyPairGenerator = KeyPairGenerator.getInstance(\n *         KeyProperties.KEY_ALGORITHM_RSA, \"AndroidKeyStore\");\n * keyPairGenerator.initialize(\n *         new KeyGenParameterSpec.Builder(\n *                 \"key1\",\n *                 KeyProperties.PURPOSE_DECRYPT)\n *                 .setDigests(KeyProperties.DIGEST_SHA256, KeyProperties.DIGEST_SHA512)\n *                 .setEncryptionPaddings(KeyProperties.ENCRYPTION_PADDING_RSA_OAEP)\n *                 .build());\n * KeyPair keyPair = keyPairGenerator.generateKeyPair();\n * Cipher cipher = Cipher.getInstance(\"RSA/ECB/OAEPWithSHA-256AndMGF1Padding\");\n * cipher.init(Cipher.DECRYPT_MODE, keyPair.getPrivate());\n * ...\n *\n * // The key pair can also be obtained from the Android Keystore any time as follows:\n * KeyStore keyStore = KeyStore.getInstance(\"AndroidKeyStore\");\n * keyStore.load(null);\n * PrivateKey privateKey = (PrivateKey) keyStore.getKey(\"key1\", null);\n * PublicKey publicKey = keyStore.getCertificate(\"key1\").getPublicKey();\n * }</pre>\n *\n * <p><h3>Example: AES key for encryption/decryption in GCM mode</h3>\n * The following example illustrates how to generate an AES key in the Android KeyStore system under\n * alias {@code key2} authorized to be used only for encryption/decryption in GCM mode with no\n * padding.\n * <pre> {@code\n * KeyGenerator keyGenerator = KeyGenerator.getInstance(\n *         KeyProperties.KEY_ALGORITHM_AES, \"AndroidKeyStore\");\n * keyGenerator.init(\n *         new KeyGenParameterSpec.Builder(\"key2\",\n *                 KeyProperties.PURPOSE_ENCRYPT | KeyProperties.PURPOSE_DECRYPT)\n *                 .setBlockModes(KeyProperties.BLOCK_MODE_GCM)\n *                 .setEncryptionPaddings(KeyProperties.ENCRYPTION_PADDING_NONE)\n *                 .build());\n * SecretKey key = keyGenerator.generateKey();\n *\n * Cipher cipher = Cipher.getInstance(\"AES/GCM/NoPadding\");\n * cipher.init(Cipher.ENCRYPT_MODE, key);\n * ...\n *\n * // The key can also be obtained from the Android Keystore any time as follows:\n * KeyStore keyStore = KeyStore.getInstance(\"AndroidKeyStore\");\n * keyStore.load(null);\n * key = (SecretKey) keyStore.getKey(\"key2\", null);\n * }</pre>\n *\n * <p><h3>Example: HMAC key for generating a MAC using SHA-256</h3>\n * This example illustrates how to generate an HMAC key in the Android KeyStore system under alias\n * {@code key2} authorized to be used only for generating an HMAC using SHA-256.\n * <pre> {@code\n * KeyGenerator keyGenerator = KeyGenerator.getInstance(\n *         KeyProperties.KEY_ALGORITHM_HMAC_SHA256, \"AndroidKeyStore\");\n * keyGenerator.init(\n *         new KeyGenParameterSpec.Builder(\"key2\", KeyProperties.PURPOSE_SIGN).build());\n * SecretKey key = keyGenerator.generateKey();\n * Mac mac = Mac.getInstance(\"HmacSHA256\");\n * mac.init(key);\n * ...\n *\n * // The key can also be obtained from the Android Keystore any time as follows:\n * KeyStore keyStore = KeyStore.getInstance(\"AndroidKeyStore\");\n * keyStore.load(null);\n * key = (SecretKey) keyStore.getKey(\"key2\", null);\n * }</pre>\n *\n * <p><h3 id=\"example:ecdh\">Example: EC key for ECDH key agreement</h3>\n * This example illustrates how to generate an elliptic curve key pair, used to establish a shared\n * secret with another party using ECDH key agreement.\n * <pre> {@code\n * KeyPairGenerator keyPairGenerator = KeyPairGenerator.getInstance(\n *         KeyProperties.KEY_ALGORITHM_EC, \"AndroidKeyStore\");\n * keyPairGenerator.initialize(\n *         new KeyGenParameterSpec.Builder(\n *             \"eckeypair\",\n *             KeyProperties.PURPOSE_AGREE_KEY)\n *             .setAlgorithmParameterSpec(new ECGenParameterSpec(\"secp256r1\"))\n *             .build());\n * KeyPair myKeyPair = keyPairGenerator.generateKeyPair();\n *\n * // Exchange public keys with server. A new ephemeral key MUST be used for every message.\n * PublicKey serverEphemeralPublicKey; // Ephemeral key received from server.\n *\n * // Create a shared secret based on our private key and the other party's public key.\n * KeyAgreement keyAgreement = KeyAgreement.getInstance(\"ECDH\", \"AndroidKeyStore\");\n * keyAgreement.init(myKeyPair.getPrivate());\n * keyAgreement.doPhase(serverEphemeralPublicKey, true);\n * byte[] sharedSecret = keyAgreement.generateSecret();\n *\n * // sharedSecret cannot safely be used as a key yet. We must run it through a key derivation\n * // function with some other data: \"salt\" and \"info\". Salt is an optional random value,\n * // omitted in this example. It's good practice to include both public keys and any other\n * // key negotiation data in info. Here we use the public keys and a label that indicates\n * // messages encrypted with this key are coming from the server.\n * byte[] salt = {};\n * ByteArrayOutputStream info = new ByteArrayOutputStream();\n * info.write(\"ECDH secp256r1 AES-256-GCM-SIV\\0\".getBytes(StandardCharsets.UTF_8));\n * info.write(myKeyPair.getPublic().getEncoded());\n * info.write(serverEphemeralPublicKey.getEncoded());\n *\n * // This example uses the Tink library and the HKDF key derivation function.\n * AesGcmSiv key = new AesGcmSiv(Hkdf.computeHkdf(\n *         \"HMACSHA256\", sharedSecret, salt, info.toByteArray(), 32));\n * byte[] associatedData = {};\n * return key.decrypt(ciphertext, associatedData);\n * }</pre>\n ",
  "links" : [ "java.security.KeyPairGenerator", "java.security.KeyStore#getEntry(String", "java.security.KeyStore#getCertificate(String)", "java.security.KeyStore#getKey(String", "java.security.interfaces.RSAKey", "java.security.interfaces.ECKey", "Builder", "#setKeyValidityStart(Date)", "java.security.KeyStore", "javax.crypto.KeyGenerator#generateKey()", "javax.crypto.KeyGenerator", "#setUserAuthenticationRequired(boolean)", "#setAttestationChallenge(byte", "java.security.interfaces.RSAPublicKey", "android.security.keystore.KeyProperties#PURPOSE_SIGN", "android.security.keystore.KeyProperties", "#setKeyValidityForOriginationEnd(Date)", "java.security.KeyPairGenerator#generateKeyPair()", "java.security.spec.AlgorithmParameterSpec", "java.security.interfaces.ECPublicKey", "java.security.cert.Certificate#getPublicKey()", "android.security.keystore.KeyProperties#SIGNATURE_PADDING_RSA_PKCS1" ],
  "variables" : [ {
    "name" : "DEFAULT_ATTESTATION_CERT_SUBJECT",
    "type" : "X500Principal",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "DEFAULT_SELF_SIGNED_CERT_SUBJECT",
    "type" : "X500Principal",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "DEFAULT_CERT_SERIAL_NUMBER",
    "type" : "BigInteger",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "DEFAULT_CERT_NOT_BEFORE",
    "type" : "Date",
    "comment" : " Jan 1 1970",
    "links" : [ ]
  }, {
    "name" : "DEFAULT_CERT_NOT_AFTER",
    "type" : "Date",
    "comment" : " Jan 1 2048",
    "links" : [ ]
  }, {
    "name" : "mKeystoreAlias",
    "type" : "String",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mNamespace",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mKeySize",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mSpec",
    "type" : "AlgorithmParameterSpec",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mCertificateSubject",
    "type" : "X500Principal",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mCertificateSerialNumber",
    "type" : "BigInteger",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mCertificateNotBefore",
    "type" : "Date",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mCertificateNotAfter",
    "type" : "Date",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mKeyValidityStart",
    "type" : "Date",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mKeyValidityForOriginationEnd",
    "type" : "Date",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mKeyValidityForConsumptionEnd",
    "type" : "Date",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mPurposes",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mDigests",
    "type" : "String[]",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mMgf1Digests",
    "type" : "Set<String>",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mEncryptionPaddings",
    "type" : "String[]",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mSignaturePaddings",
    "type" : "String[]",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mBlockModes",
    "type" : "String[]",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mRandomizedEncryptionRequired",
    "type" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mUserAuthenticationRequired",
    "type" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mUserAuthenticationValidityDurationSeconds",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mUserAuthenticationType",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mUserPresenceRequired",
    "type" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mAttestationChallenge",
    "type" : "byte[]",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mDevicePropertiesAttestationIncluded",
    "type" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mAttestationIds",
    "type" : "int[]",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mUniqueIdIncluded",
    "type" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mUserAuthenticationValidWhileOnBody",
    "type" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mInvalidatedByBiometricEnrollment",
    "type" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mIsStrongBoxBacked",
    "type" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mUserConfirmationRequired",
    "type" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mUnlockedDeviceRequired",
    "type" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mCriticalToDeviceEncryption",
    "type" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mMaxUsageCount",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mAttestKeyAlias",
    "type" : "String",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mBoundToSecureUserId",
    "type" : "long",
    "comment" : "",
    "links" : [ ]
  } ],
  "methods" : [ {
    "name" : "public String getKeystoreAlias()",
    "returnType" : "String",
    "comment" : "\n     * Returns the alias that will be used in the {@code java.security.KeyStore}\n     * in conjunction with the {@code AndroidKeyStore}.\n     ",
    "links" : [ ]
  }, {
    "name" : "public int getUid()",
    "returnType" : "int",
    "comment" : "\n     * Returns the UID which will own the key. {@code -1} is an alias for the UID of the current\n     * process.\n     *\n     * @deprecated See deprecation message on {@link KeyGenParameterSpec.Builder#setUid(int)}.\n     *             Known namespaces will be translated to their legacy UIDs. Unknown\n     *             Namespaces will yield {@link IllegalStateException}.\n     *\n     * @hide\n     ",
    "links" : [ "IllegalStateException", "KeyGenParameterSpec.Builder#setUid(int)" ]
  }, {
    "name" : "public int getNamespace()",
    "returnType" : "int",
    "comment" : "\n     * Returns the target namespace for the key.\n     * See {@link KeyGenParameterSpec.Builder#setNamespace(int)}.\n     *\n     * @return The numeric namespace as configured in the keystore2_key_contexts files of Android's\n     *         SEPolicy.\n     *         See <a href=\"https://source.android.com/security/keystore#access-control\">\n     *             Keystore 2.0 access control</a>\n     * @hide\n     ",
    "links" : [ "KeyGenParameterSpec.Builder#setNamespace(int)" ]
  }, {
    "name" : "public int getKeySize()",
    "returnType" : "int",
    "comment" : "\n     * Returns the requested key size. If {@code -1}, the size should be looked up from\n     * {@link #getAlgorithmParameterSpec()}, if provided, otherwise an algorithm-specific default\n     * size should be used.\n     ",
    "links" : [ "#getAlgorithmParameterSpec()" ]
  }, {
    "name" : "public AlgorithmParameterSpec getAlgorithmParameterSpec()",
    "returnType" : "AlgorithmParameterSpec",
    "comment" : "\n     * Returns the key algorithm-specific {@link AlgorithmParameterSpec} that will be used for\n     * creation of the key or {@code null} if algorithm-specific defaults should be used.\n     ",
    "links" : [ "java.security.spec.AlgorithmParameterSpec" ]
  }, {
    "name" : "public X500Principal getCertificateSubject()",
    "returnType" : "X500Principal",
    "comment" : "\n     * Returns the subject distinguished name to be used on the X.509 certificate that will be put\n     * in the {@link java.security.KeyStore}.\n     ",
    "links" : [ "java.security.KeyStore" ]
  }, {
    "name" : "public BigInteger getCertificateSerialNumber()",
    "returnType" : "BigInteger",
    "comment" : "\n     * Returns the serial number to be used on the X.509 certificate that will be put in the\n     * {@link java.security.KeyStore}.\n     ",
    "links" : [ "java.security.KeyStore" ]
  }, {
    "name" : "public Date getCertificateNotBefore()",
    "returnType" : "Date",
    "comment" : "\n     * Returns the start date to be used on the X.509 certificate that will be put in the\n     * {@link java.security.KeyStore}.\n     ",
    "links" : [ "java.security.KeyStore" ]
  }, {
    "name" : "public Date getCertificateNotAfter()",
    "returnType" : "Date",
    "comment" : "\n     * Returns the end date to be used on the X.509 certificate that will be put in the\n     * {@link java.security.KeyStore}.\n     ",
    "links" : [ "java.security.KeyStore" ]
  }, {
    "name" : "public Date getKeyValidityStart()",
    "returnType" : "Date",
    "comment" : "\n     * Returns the time instant before which the key is not yet valid or {@code null} if not\n     * restricted.\n     ",
    "links" : [ ]
  }, {
    "name" : "public Date getKeyValidityForConsumptionEnd()",
    "returnType" : "Date",
    "comment" : "\n     * Returns the time instant after which the key is no longer valid for decryption and\n     * verification or {@code null} if not restricted.\n     ",
    "links" : [ ]
  }, {
    "name" : "public Date getKeyValidityForOriginationEnd()",
    "returnType" : "Date",
    "comment" : "\n     * Returns the time instant after which the key is no longer valid for encryption and signing\n     * or {@code null} if not restricted.\n     ",
    "links" : [ ]
  }, {
    "name" : "public int getPurposes()",
    "returnType" : "int",
    "comment" : "\n     * Returns the set of purposes (e.g., encrypt, decrypt, sign) for which the key can be used.\n     * Attempts to use the key for any other purpose will be rejected.\n     *\n     * <p>See {@link KeyProperties}.{@code PURPOSE} flags.\n     ",
    "links" : [ "android.security.keystore.KeyProperties" ]
  }, {
    "name" : "public String[] getDigests()",
    "returnType" : "String[]",
    "comment" : "\n     * Returns the set of digest algorithms (e.g., {@code SHA-256}, {@code SHA-384} with which the\n     * key can be used.\n     *\n     * <p>See {@link KeyProperties}.{@code DIGEST} constants.\n     *\n     * @throws IllegalStateException if this set has not been specified.\n     *\n     * @see #isDigestsSpecified()\n     ",
    "links" : [ "android.security.keystore.KeyProperties" ]
  }, {
    "name" : "public boolean isDigestsSpecified()",
    "returnType" : "boolean",
    "comment" : "\n     * Returns {@code true} if the set of digest algorithms with which the key can be used has been\n     * specified.\n     *\n     * @see #getDigests()\n     ",
    "links" : [ ]
  }, {
    "name" : "public Set<String> getMgf1Digests()",
    "returnType" : "Set<String>",
    "comment" : "\n     * Returns the set of digests that can be used by the MGF1 mask generation function\n     * (e.g., {@code SHA-256}, {@code SHA-384}) with the key. Useful with the {@code RSA-OAEP}\n     * scheme.\n     * If not explicitly specified during key generation, the default {@code SHA-1} digest is\n     * used and may be specified when using the key.\n     *\n     * <p>See {@link KeyProperties}.{@code DIGEST} constants.\n     *\n     * @throws IllegalStateException if this set has not been specified.\n     *\n     * @see #isMgf1DigestsSpecified()\n     ",
    "links" : [ "android.security.keystore.KeyProperties" ]
  }, {
    "name" : "public boolean isMgf1DigestsSpecified()",
    "returnType" : "boolean",
    "comment" : "\n     * Returns {@code true} if the set of digests for the MGF1 mask generation function,\n     * with which the key can be used, has been specified. Useful with the {@code RSA-OAEP} scheme.\n     *\n     * @see #getMgf1Digests()\n     ",
    "links" : [ ]
  }, {
    "name" : "public String[] getEncryptionPaddings()",
    "returnType" : "String[]",
    "comment" : "\n     * Returns the set of padding schemes (e.g., {@code PKCS7Padding}, {@code OEAPPadding},\n     * {@code PKCS1Padding}, {@code NoPadding}) with which the key can be used when\n     * encrypting/decrypting. Attempts to use the key with any other padding scheme will be\n     * rejected.\n     *\n     * <p>See {@link KeyProperties}.{@code ENCRYPTION_PADDING} constants.\n     ",
    "links" : [ "android.security.keystore.KeyProperties" ]
  }, {
    "name" : "public String[] getSignaturePaddings()",
    "returnType" : "String[]",
    "comment" : "\n     * Gets the set of padding schemes (e.g., {@code PSS}, {@code PKCS#1}) with which the key\n     * can be used when signing/verifying. Attempts to use the key with any other padding scheme\n     * will be rejected.\n     *\n     * <p>See {@link KeyProperties}.{@code SIGNATURE_PADDING} constants.\n     ",
    "links" : [ "android.security.keystore.KeyProperties" ]
  }, {
    "name" : "public String[] getBlockModes()",
    "returnType" : "String[]",
    "comment" : "\n     * Gets the set of block modes (e.g., {@code GCM}, {@code CBC}) with which the key can be used\n     * when encrypting/decrypting. Attempts to use the key with any other block modes will be\n     * rejected.\n     *\n     * <p>See {@link KeyProperties}.{@code BLOCK_MODE} constants.\n     ",
    "links" : [ "android.security.keystore.KeyProperties" ]
  }, {
    "name" : "public boolean isRandomizedEncryptionRequired()",
    "returnType" : "boolean",
    "comment" : "\n     * Returns {@code true} if encryption using this key must be sufficiently randomized to produce\n     * different ciphertexts for the same plaintext every time. The formal cryptographic property\n     * being required is <em>indistinguishability under chosen-plaintext attack ({@code\n     * IND-CPA})</em>. This property is important because it mitigates several classes of\n     * weaknesses due to which ciphertext may leak information about plaintext.  For example, if a\n     * given plaintext always produces the same ciphertext, an attacker may see the repeated\n     * ciphertexts and be able to deduce something about the plaintext.\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean isUserAuthenticationRequired()",
    "returnType" : "boolean",
    "comment" : "\n     * Returns {@code true} if the key is authorized to be used only if the user has been\n     * authenticated.\n     *\n     * <p>This authorization applies only to secret key and private key operations. Public key\n     * operations are not restricted.\n     *\n     * @see #getUserAuthenticationValidityDurationSeconds()\n     * @see Builder#setUserAuthenticationRequired(boolean)\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean isUserConfirmationRequired()",
    "returnType" : "boolean",
    "comment" : "\n     * Returns {@code true} if the key is authorized to be used only for messages confirmed by the\n     * user.\n     *\n     * Confirmation is separate from user authentication (see\n     * {@link Builder#setUserAuthenticationRequired(boolean)}). Keys can be created that require\n     * confirmation but not user authentication, or user authentication but not confirmation, or\n     * both. Confirmation verifies that some user with physical possession of the device has\n     * approved a displayed message. User authentication verifies that the correct user is present\n     * and has authenticated.\n     *\n     * <p>This authorization applies only to secret key and private key operations. Public key\n     * operations are not restricted.\n     *\n     * @see Builder#setUserConfirmationRequired(boolean)\n     ",
    "links" : [ "#setUserAuthenticationRequired(boolean)" ]
  }, {
    "name" : "public int getUserAuthenticationValidityDurationSeconds()",
    "returnType" : "int",
    "comment" : "\n     * Gets the duration of time (seconds) for which this key is authorized to be used after the\n     * user is successfully authenticated. This has effect only if user authentication is required\n     * (see {@link #isUserAuthenticationRequired()}).\n     *\n     * <p>This authorization applies only to secret key and private key operations. Public key\n     * operations are not restricted.\n     *\n     * @return duration in seconds or {@code -1} if authentication is required for every use of the\n     *         key.\n     *\n     * @see #isUserAuthenticationRequired()\n     * @see Builder#setUserAuthenticationValidityDurationSeconds(int)\n     ",
    "links" : [ "#isUserAuthenticationRequired()" ]
  }, {
    "name" : "public int getUserAuthenticationType()",
    "returnType" : "int",
    "comment" : "\n     * Gets the modes of authentication that can authorize use of this key. This has effect only if\n     * user authentication is required (see {@link #isUserAuthenticationRequired()}).\n     *\n     * <p>This authorization applies only to secret key and private key operations. Public key\n     * operations are not restricted.\n     *\n     * @return integer representing the bitwse OR of all acceptable authentication types for the\n     *         key.\n     *\n     * @see #isUserAuthenticationRequired()\n     * @see Builder#setUserAuthenticationParameters(int, int)\n     ",
    "links" : [ "#isUserAuthenticationRequired()" ]
  }, {
    "name" : "public boolean isUserPresenceRequired()",
    "returnType" : "boolean",
    "comment" : "\n     * Returns {@code true} if the key is authorized to be used only if a test of user presence has\n     * been performed between the {@code Signature.initSign()} and {@code Signature.sign()} calls.\n     * It requires that the KeyStore implementation have a direct way to validate the user presence\n     * for example a KeyStore hardware backed strongbox can use a button press that is observable\n     * in hardware. A test for user presence is tangential to authentication. The test can be part\n     * of an authentication step as long as this step can be validated by the hardware protecting\n     * the key and cannot be spoofed. For example, a physical button press can be used as a test of\n     * user presence if the other pins connected to the button are not able to simulate a button\n     * press. There must be no way for the primary processor to fake a button press, or that\n     * button must not be used as a test of user presence.\n     ",
    "links" : [ ]
  }, {
    "name" : "public byte[] getAttestationChallenge()",
    "returnType" : "byte[]",
    "comment" : "\n     * Returns the attestation challenge value that will be placed in attestation certificate for\n     * this key pair.\n     *\n     * <p>If this method returns non-{@code null}, the public key certificate for this key pair will\n     * contain an extension that describes the details of the key's configuration and\n     * authorizations, including the content of the attestation challenge value. If the key is in\n     * secure hardware, and if the secure hardware supports attestation, the certificate will be\n     * signed by a chain of certificates rooted at a trustworthy CA key. Otherwise the chain will\n     * be rooted at an untrusted certificate.\n     *\n     * <p>If this method returns {@code null}, and the spec is used to generate an asymmetric (RSA\n     * or EC) key pair, the public key will have a self-signed certificate if it has purpose {@link\n     * KeyProperties#PURPOSE_SIGN}. If does not have purpose {@link KeyProperties#PURPOSE_SIGN}, it\n     * will have a fake certificate.\n     *\n     * <p>Symmetric keys, such as AES and HMAC keys, do not have public key certificates. If a\n     * KeyGenParameterSpec with getAttestationChallenge returning non-null is used to generate a\n     * symmetric (AES or HMAC) key, {@link javax.crypto.KeyGenerator#generateKey()} will throw\n     * {@link java.security.InvalidAlgorithmParameterException}.\n     *\n     * @see Builder#setAttestationChallenge(byte[])\n     ",
    "links" : [ "android.security.keystore.KeyProperties#PURPOSE_SIGN", "javax.crypto.KeyGenerator#generateKey()", "java.security.InvalidAlgorithmParameterException" ]
  }, {
    "name" : "public boolean isDevicePropertiesAttestationIncluded()",
    "returnType" : "boolean",
    "comment" : "\n     * Returns {@code true} if attestation for the base device properties ({@link Build#BRAND},\n     * {@link Build#DEVICE}, {@link Build#MANUFACTURER}, {@link Build#MODEL}, {@link Build#PRODUCT})\n     * was requested to be added in the attestation certificate for the generated key.\n     *\n     * {@link javax.crypto.KeyGenerator#generateKey()} will throw\n     * {@link java.security.ProviderException} if device properties attestation fails or is not\n     * supported.\n     *\n     * @see Builder#setDevicePropertiesAttestationIncluded(boolean)\n     ",
    "links" : [ "android.os.Build#DEVICE", "android.os.Build#MANUFACTURER", "android.os.Build#PRODUCT", "java.security.ProviderException", "android.os.Build#BRAND", "android.os.Build#MODEL", "javax.crypto.KeyGenerator#generateKey()" ]
  }, {
    "name" : "public int[] getAttestationIds()",
    "returnType" : "int[]",
    "comment" : "\n     * @hide\n     * Allows the caller to specify device IDs to be attested to in the certificate for the\n     * generated key pair. These values are the enums specified in\n     * {@link android.security.keystore.AttestationUtils}\n     *\n     * @see android.security.keystore.AttestationUtils#ID_TYPE_SERIAL\n     * @see android.security.keystore.AttestationUtils#ID_TYPE_IMEI\n     * @see android.security.keystore.AttestationUtils#ID_TYPE_MEID\n     * @see android.security.keystore.AttestationUtils#USE_INDIVIDUAL_ATTESTATION\n     *\n     * @return integer array representing the requested device IDs to attest.\n     ",
    "links" : [ "android.security.keystore.AttestationUtils" ]
  }, {
    "name" : "public boolean isUniqueIdIncluded()",
    "returnType" : "boolean",
    "comment" : "\n     * @hide This is a system-only API\n     *\n     * Returns {@code true} if the attestation certificate will contain a unique ID field.\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean isUserAuthenticationValidWhileOnBody()",
    "returnType" : "boolean",
    "comment" : "\n     * Returns {@code true} if the key will remain authorized only until the device is removed from\n     * the user's body, up to the validity duration.  This option has no effect on keys that don't\n     * have an authentication validity duration, and has no effect if the device lacks an on-body\n     * sensor.\n     *\n     * <p>Authorization applies only to secret key and private key operations. Public key operations\n     * are not restricted.\n     *\n     * @see #isUserAuthenticationRequired()\n     * @see #getUserAuthenticationValidityDurationSeconds()\n     * @see Builder#setUserAuthenticationValidWhileOnBody(boolean)\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean isInvalidatedByBiometricEnrollment()",
    "returnType" : "boolean",
    "comment" : "\n     * Returns {@code true} if the key is irreversibly invalidated when a new biometric is\n     * enrolled or all enrolled biometrics are removed. This has effect only for keys that\n     * require biometric user authentication for every use.\n     *\n     * @see #isUserAuthenticationRequired()\n     * @see #getUserAuthenticationValidityDurationSeconds()\n     * @see Builder#setInvalidatedByBiometricEnrollment(boolean)\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean isStrongBoxBacked()",
    "returnType" : "boolean",
    "comment" : "\n     * Returns {@code true} if the key is protected by a Strongbox security chip.\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean isUnlockedDeviceRequired()",
    "returnType" : "boolean",
    "comment" : "\n     * Returns {@code true} if the key is authorized to be used only while the device is unlocked.\n     *\n     * @see Builder#setUnlockedDeviceRequired(boolean)\n     ",
    "links" : [ ]
  }, {
    "name" : "public long getBoundToSpecificSecureUserId()",
    "returnType" : "long",
    "comment" : "\n     * Return the secure user id that this key should be bound to.\n     *\n     * Normally an authentication-bound key is tied to the secure user id of the current user\n     * (either the root SID from GateKeeper for auth-bound keys with a timeout, or the authenticator\n     * id of the current biometric set for keys requiring explicit biometric authorization).\n     * If this parameter is set (this method returning non-zero value), the key should be tied to\n     * the specified secure user id, overriding the logic above.\n     *\n     * This is only applicable when {@link #isUserAuthenticationRequired} is {@code true}\n     *\n     * @hide\n     ",
    "links" : [ "#isUserAuthenticationRequired" ]
  }, {
    "name" : "public boolean isCriticalToDeviceEncryption()",
    "returnType" : "boolean",
    "comment" : "\n     * Returns whether this key is critical to the device encryption flow.\n     *\n     * @see Builder#setCriticalToDeviceEncryption(boolean)\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public int getMaxUsageCount()",
    "returnType" : "int",
    "comment" : "\n     * Returns the maximum number of times the limited use key is allowed to be used or\n     * {@link KeyProperties#UNRESTRICTED_USAGE_COUNT} if there’s no restriction on the number of\n     * times the key can be used.\n     *\n     * @see Builder#setMaxUsageCount(int)\n     ",
    "links" : [ "android.security.keystore.KeyProperties#UNRESTRICTED_USAGE_COUNT" ]
  }, {
    "name" : "public String getAttestKeyAlias()",
    "returnType" : "String",
    "comment" : "\n     * Returns the alias of the attestation key that will be used to sign the attestation\n     * certificate of the generated key.  Note that an attestation certificate will only be\n     * generated if an attestation challenge is set.\n     *\n     * @see Builder#setAttestKeyAlias(String)\n     ",
    "links" : [ ]
  } ],
  "methodNames" : [ "public String getKeystoreAlias()", "public int getUid()", "public int getNamespace()", "public int getKeySize()", "public AlgorithmParameterSpec getAlgorithmParameterSpec()", "public X500Principal getCertificateSubject()", "public BigInteger getCertificateSerialNumber()", "public Date getCertificateNotBefore()", "public Date getCertificateNotAfter()", "public Date getKeyValidityStart()", "public Date getKeyValidityForConsumptionEnd()", "public Date getKeyValidityForOriginationEnd()", "public int getPurposes()", "public String[] getDigests()", "public boolean isDigestsSpecified()", "public Set<String> getMgf1Digests()", "public boolean isMgf1DigestsSpecified()", "public String[] getEncryptionPaddings()", "public String[] getSignaturePaddings()", "public String[] getBlockModes()", "public boolean isRandomizedEncryptionRequired()", "public boolean isUserAuthenticationRequired()", "public boolean isUserConfirmationRequired()", "public int getUserAuthenticationValidityDurationSeconds()", "public int getUserAuthenticationType()", "public boolean isUserPresenceRequired()", "public byte[] getAttestationChallenge()", "public boolean isDevicePropertiesAttestationIncluded()", "public int[] getAttestationIds()", "public boolean isUniqueIdIncluded()", "public boolean isUserAuthenticationValidWhileOnBody()", "public boolean isInvalidatedByBiometricEnrollment()", "public boolean isStrongBoxBacked()", "public boolean isUnlockedDeviceRequired()", "public long getBoundToSpecificSecureUserId()", "public boolean isCriticalToDeviceEncryption()", "public int getMaxUsageCount()", "public String getAttestKeyAlias()" ],
  "variableNames" : [ "DEFAULT_ATTESTATION_CERT_SUBJECT", "DEFAULT_SELF_SIGNED_CERT_SUBJECT", "DEFAULT_CERT_SERIAL_NUMBER", "DEFAULT_CERT_NOT_BEFORE", "DEFAULT_CERT_NOT_AFTER", "mKeystoreAlias", "mNamespace", "mKeySize", "mSpec", "mCertificateSubject", "mCertificateSerialNumber", "mCertificateNotBefore", "mCertificateNotAfter", "mKeyValidityStart", "mKeyValidityForOriginationEnd", "mKeyValidityForConsumptionEnd", "mPurposes", "mDigests", "mMgf1Digests", "mEncryptionPaddings", "mSignaturePaddings", "mBlockModes", "mRandomizedEncryptionRequired", "mUserAuthenticationRequired", "mUserAuthenticationValidityDurationSeconds", "mUserAuthenticationType", "mUserPresenceRequired", "mAttestationChallenge", "mDevicePropertiesAttestationIncluded", "mAttestationIds", "mUniqueIdIncluded", "mUserAuthenticationValidWhileOnBody", "mInvalidatedByBiometricEnrollment", "mIsStrongBoxBacked", "mUserConfirmationRequired", "mUnlockedDeviceRequired", "mCriticalToDeviceEncryption", "mMaxUsageCount", "mAttestKeyAlias", "mBoundToSecureUserId" ]
}