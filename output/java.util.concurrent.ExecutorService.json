{
  "filePath" : "/home/maryam/clearblue/files/android-source-35/java/util/concurrent/ExecutorService.java",
  "packageName" : "java.util.concurrent",
  "className" : "ExecutorService",
  "comment" : "\n * An {@link Executor} that provides methods to manage termination and\n * methods that can produce a {@link Future} for tracking progress of\n * one or more asynchronous tasks.\n *\n * <p>An {@code ExecutorService} can be shut down, which will cause\n * it to reject new tasks.  Two different methods are provided for\n * shutting down an {@code ExecutorService}. The {@link #shutdown}\n * method will allow previously submitted tasks to execute before\n * terminating, while the {@link #shutdownNow} method prevents waiting\n * tasks from starting and attempts to stop currently executing tasks.\n * Upon termination, an executor has no tasks actively executing, no\n * tasks awaiting execution, and no new tasks can be submitted.  An\n * unused {@code ExecutorService} should be shut down to allow\n * reclamation of its resources.\n *\n * <p>Method {@code submit} extends base method {@link\n * Executor#execute(Runnable)} by creating and returning a {@link Future}\n * that can be used to cancel execution and/or wait for completion.\n * Methods {@code invokeAny} and {@code invokeAll} perform the most\n * commonly useful forms of bulk execution, executing a collection of\n * tasks and then waiting for at least one, or all, to\n * complete. (Class {@link ExecutorCompletionService} can be used to\n * write customized variants of these methods.)\n *\n * <p>The {@link Executors} class provides factory methods for the\n * executor services provided in this package.\n *\n * <h2>Usage Examples</h2>\n *\n * Here is a sketch of a network service in which threads in a thread\n * pool service incoming requests. It uses the preconfigured {@link\n * Executors#newFixedThreadPool} factory method:\n *\n * <pre> {@code\n * class NetworkService implements Runnable {\n *   private final ServerSocket serverSocket;\n *   private final ExecutorService pool;\n *\n *   public NetworkService(int port, int poolSize)\n *       throws IOException {\n *     serverSocket = new ServerSocket(port);\n *     pool = Executors.newFixedThreadPool(poolSize);\n *   }\n *\n *   public void run() { // run the service\n *     try {\n *       for (;;) {\n *         pool.execute(new Handler(serverSocket.accept()));\n *       }\n *     } catch (IOException ex) {\n *       pool.shutdown();\n *     }\n *   }\n * }\n *\n * class Handler implements Runnable {\n *   private final Socket socket;\n *   Handler(Socket socket) { this.socket = socket; }\n *   public void run() {\n *     // read and service request on socket\n *   }\n * }}</pre>\n *\n * The following method shuts down an {@code ExecutorService} in two phases,\n * first by calling {@code shutdown} to reject incoming tasks, and then\n * calling {@code shutdownNow}, if necessary, to cancel any lingering tasks:\n *\n * <pre> {@code\n * void shutdownAndAwaitTermination(ExecutorService pool) {\n *   pool.shutdown(); // Disable new tasks from being submitted\n *   try {\n *     // Wait a while for existing tasks to terminate\n *     if (!pool.awaitTermination(60, TimeUnit.SECONDS)) {\n *       pool.shutdownNow(); // Cancel currently executing tasks\n *       // Wait a while for tasks to respond to being cancelled\n *       if (!pool.awaitTermination(60, TimeUnit.SECONDS))\n *           System.err.println(\"Pool did not terminate\");\n *     }\n *   } catch (InterruptedException ex) {\n *     // (Re-)Cancel if current thread also interrupted\n *     pool.shutdownNow();\n *     // Preserve interrupt status\n *     Thread.currentThread().interrupt();\n *   }\n * }}</pre>\n *\n * <p>Memory consistency effects: Actions in a thread prior to the\n * submission of a {@code Runnable} or {@code Callable} task to an\n * {@code ExecutorService}\n * <a href=\"package-summary.html#MemoryVisibility\"><i>happen-before</i></a>\n * any actions taken by that task, which in turn <i>happen-before</i> the\n * result is retrieved via {@code Future.get()}.\n *\n * @since 1.5\n * @author Doug Lea\n ",
  "links" : [ "java.util.concurrent.Future", "java.util.concurrent.Executor", "#shutdownNow", "#shutdown", "java.util.concurrent.Executors#newFixedThreadPool", "java.util.concurrent.Executor#execute(Runnable)", "java.util.concurrent.ExecutorCompletionService", "java.util.concurrent.Executors" ],
  "variables" : [ ],
  "methods" : [ {
    "name" : " void shutdown()",
    "returnType" : "void",
    "comment" : "\n     * Initiates an orderly shutdown in which previously submitted\n     * tasks are executed, but no new tasks will be accepted.\n     * Invocation has no additional effect if already shut down.\n     *\n     * <p>This method does not wait for previously submitted tasks to\n     * complete execution.  Use {@link #awaitTermination awaitTermination}\n     * to do that.\n     ",
    "links" : [ "#awaitTermination" ]
  }, {
    "name" : " List<Runnable> shutdownNow()",
    "returnType" : "List<Runnable>",
    "comment" : "\n     * Attempts to stop all actively executing tasks, halts the\n     * processing of waiting tasks, and returns a list of the tasks\n     * that were awaiting execution.\n     *\n     * <p>This method does not wait for actively executing tasks to\n     * terminate.  Use {@link #awaitTermination awaitTermination} to\n     * do that.\n     *\n     * <p>There are no guarantees beyond best-effort attempts to stop\n     * processing actively executing tasks.  For example, typical\n     * implementations will cancel via {@link Thread#interrupt}, so any\n     * task that fails to respond to interrupts may never terminate.\n     *\n     * @return list of tasks that never commenced execution\n     ",
    "links" : [ "#awaitTermination", "#interrupt" ]
  }, {
    "name" : " boolean isShutdown()",
    "returnType" : "boolean",
    "comment" : "\n     * Returns {@code true} if this executor has been shut down.\n     *\n     * @return {@code true} if this executor has been shut down\n     ",
    "links" : [ ]
  }, {
    "name" : " boolean isTerminated()",
    "returnType" : "boolean",
    "comment" : "\n     * Returns {@code true} if all tasks have completed following shut down.\n     * Note that {@code isTerminated} is never {@code true} unless\n     * either {@code shutdown} or {@code shutdownNow} was called first.\n     *\n     * @return {@code true} if all tasks have completed following shut down\n     ",
    "links" : [ ]
  }, {
    "name" : " boolean awaitTermination(long timeout, TimeUnit unit) throws InterruptedException",
    "returnType" : "boolean",
    "comment" : "\n     * Blocks until all tasks have completed execution after a shutdown\n     * request, or the timeout occurs, or the current thread is\n     * interrupted, whichever happens first.\n     *\n     * @param timeout the maximum time to wait\n     * @param unit the time unit of the timeout argument\n     * @return {@code true} if this executor terminated and\n     *         {@code false} if the timeout elapsed before termination\n     * @throws InterruptedException if interrupted while waiting\n     ",
    "links" : [ ]
  }, {
    "name" : " Future<T> submit(Callable<T> task)",
    "returnType" : "Future<T>",
    "comment" : "\n     * Submits a value-returning task for execution and returns a\n     * Future representing the pending results of the task. The\n     * Future's {@code get} method will return the task's result upon\n     * successful completion.\n     *\n     * <p>\n     * If you would like to immediately block waiting\n     * for a task, you can use constructions of the form\n     * {@code result = exec.submit(aCallable).get();}\n     *\n     * <p>Note: The {@link Executors} class includes a set of methods\n     * that can convert some other common closure-like objects,\n     * for example, {@link java.security.PrivilegedAction} to\n     * {@link Callable} form so they can be submitted.\n     *\n     * @param task the task to submit\n     * @param <T> the type of the task's result\n     * @return a Future representing pending completion of the task\n     * @throws RejectedExecutionException if the task cannot be\n     *         scheduled for execution\n     * @throws NullPointerException if the task is null\n     ",
    "links" : [ "java.util.concurrent.Callable", "java.security.PrivilegedAction", "java.util.concurrent.Executors" ]
  }, {
    "name" : " Future<T> submit(Runnable task, T result)",
    "returnType" : "Future<T>",
    "comment" : "\n     * Submits a Runnable task for execution and returns a Future\n     * representing that task. The Future's {@code get} method will\n     * return the given result upon successful completion.\n     *\n     * @param task the task to submit\n     * @param result the result to return\n     * @param <T> the type of the result\n     * @return a Future representing pending completion of the task\n     * @throws RejectedExecutionException if the task cannot be\n     *         scheduled for execution\n     * @throws NullPointerException if the task is null\n     ",
    "links" : [ ]
  }, {
    "name" : " Future<?> submit(Runnable task)",
    "returnType" : "Future<?>",
    "comment" : "\n     * Submits a Runnable task for execution and returns a Future\n     * representing that task. The Future's {@code get} method will\n     * return {@code null} upon <em>successful</em> completion.\n     *\n     * @param task the task to submit\n     * @return a Future representing pending completion of the task\n     * @throws RejectedExecutionException if the task cannot be\n     *         scheduled for execution\n     * @throws NullPointerException if the task is null\n     ",
    "links" : [ ]
  }, {
    "name" : " List<Future<T>> invokeAll(Collection<? extends Callable<T>> tasks) throws InterruptedException",
    "returnType" : "List<Future<T>>",
    "comment" : "\n     * Executes the given tasks, returning a list of Futures holding\n     * their status and results when all complete.\n     * {@link Future#isDone} is {@code true} for each\n     * element of the returned list.\n     * Note that a <em>completed</em> task could have\n     * terminated either normally or by throwing an exception.\n     * The results of this method are undefined if the given\n     * collection is modified while this operation is in progress.\n     *\n     * @param tasks the collection of tasks\n     * @param <T> the type of the values returned from the tasks\n     * @return a list of Futures representing the tasks, in the same\n     *         sequential order as produced by the iterator for the\n     *         given task list, each of which has completed\n     * @throws InterruptedException if interrupted while waiting, in\n     *         which case unfinished tasks are cancelled\n     * @throws NullPointerException if tasks or any of its elements are {@code null}\n     * @throws RejectedExecutionException if any task cannot be\n     *         scheduled for execution\n     ",
    "links" : [ "java.util.concurrent.Future#isDone" ]
  }, {
    "name" : " List<Future<T>> invokeAll(Collection<? extends Callable<T>> tasks, long timeout, TimeUnit unit) throws InterruptedException",
    "returnType" : "List<Future<T>>",
    "comment" : "\n     * Executes the given tasks, returning a list of Futures holding\n     * their status and results\n     * when all complete or the timeout expires, whichever happens first.\n     * {@link Future#isDone} is {@code true} for each\n     * element of the returned list.\n     * Upon return, tasks that have not completed are cancelled.\n     * Note that a <em>completed</em> task could have\n     * terminated either normally or by throwing an exception.\n     * The results of this method are undefined if the given\n     * collection is modified while this operation is in progress.\n     *\n     * @param tasks the collection of tasks\n     * @param timeout the maximum time to wait\n     * @param unit the time unit of the timeout argument\n     * @param <T> the type of the values returned from the tasks\n     * @return a list of Futures representing the tasks, in the same\n     *         sequential order as produced by the iterator for the\n     *         given task list. If the operation did not time out,\n     *         each task will have completed. If it did time out, some\n     *         of these tasks will not have completed.\n     * @throws InterruptedException if interrupted while waiting, in\n     *         which case unfinished tasks are cancelled\n     * @throws NullPointerException if tasks, any of its elements, or\n     *         unit are {@code null}\n     * @throws RejectedExecutionException if any task cannot be scheduled\n     *         for execution\n     ",
    "links" : [ "java.util.concurrent.Future#isDone" ]
  }, {
    "name" : " T invokeAny(Collection<? extends Callable<T>> tasks) throws InterruptedException, ExecutionException",
    "returnType" : "T",
    "comment" : "\n     * Executes the given tasks, returning the result\n     * of one that has completed successfully (i.e., without throwing\n     * an exception), if any do. Upon normal or exceptional return,\n     * tasks that have not completed are cancelled.\n     * The results of this method are undefined if the given\n     * collection is modified while this operation is in progress.\n     *\n     * @param tasks the collection of tasks\n     * @param <T> the type of the values returned from the tasks\n     * @return the result returned by one of the tasks\n     * @throws InterruptedException if interrupted while waiting\n     * @throws NullPointerException if tasks or any element task\n     *         subject to execution is {@code null}\n     * @throws IllegalArgumentException if tasks is empty\n     * @throws ExecutionException if no task successfully completes\n     * @throws RejectedExecutionException if tasks cannot be scheduled\n     *         for execution\n     ",
    "links" : [ ]
  }, {
    "name" : " T invokeAny(Collection<? extends Callable<T>> tasks, long timeout, TimeUnit unit) throws InterruptedException, ExecutionException, TimeoutException",
    "returnType" : "T",
    "comment" : "\n     * Executes the given tasks, returning the result\n     * of one that has completed successfully (i.e., without throwing\n     * an exception), if any do before the given timeout elapses.\n     * Upon normal or exceptional return, tasks that have not\n     * completed are cancelled.\n     * The results of this method are undefined if the given\n     * collection is modified while this operation is in progress.\n     *\n     * @param tasks the collection of tasks\n     * @param timeout the maximum time to wait\n     * @param unit the time unit of the timeout argument\n     * @param <T> the type of the values returned from the tasks\n     * @return the result returned by one of the tasks\n     * @throws InterruptedException if interrupted while waiting\n     * @throws NullPointerException if tasks, or unit, or any element\n     *         task subject to execution is {@code null}\n     * @throws TimeoutException if the given timeout elapses before\n     *         any task successfully completes\n     * @throws ExecutionException if no task successfully completes\n     * @throws RejectedExecutionException if tasks cannot be scheduled\n     *         for execution\n     ",
    "links" : [ ]
  } ],
  "methodNames" : [ " void shutdown()", " List<Runnable> shutdownNow()", " boolean isShutdown()", " boolean isTerminated()", " boolean awaitTermination(long timeout, TimeUnit unit) throws InterruptedException", " Future<T> submit(Callable<T> task)", " Future<T> submit(Runnable task, T result)", " Future<?> submit(Runnable task)", " List<Future<T>> invokeAll(Collection<? extends Callable<T>> tasks) throws InterruptedException", " List<Future<T>> invokeAll(Collection<? extends Callable<T>> tasks, long timeout, TimeUnit unit) throws InterruptedException", " T invokeAny(Collection<? extends Callable<T>> tasks) throws InterruptedException, ExecutionException", " T invokeAny(Collection<? extends Callable<T>> tasks, long timeout, TimeUnit unit) throws InterruptedException, ExecutionException, TimeoutException" ],
  "variableNames" : [ ]
}