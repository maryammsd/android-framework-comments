{
  "filePath" : "/home/maryam/clearblue/files/android-source-35/android/text/Layout.java",
  "packageName" : "android.text",
  "className" : "Layout",
  "comment" : "\n * A base class that manages text layout in visual elements on\n * the screen.\n * <p>For text that will be edited, use a {@link DynamicLayout},\n * which will be updated as the text changes.\n * For text that will not change, use a {@link StaticLayout}.\n ",
  "links" : [ "android.text.StaticLayout", "android.text.DynamicLayout" ],
  "variables" : [ {
    "name" : "HIGH_CONTRAST_TEXT_BORDER_WIDTH_MIN_PX",
    "type" : "float",
    "comment" : " These should match the constants in framework/base/libs/hwui/hwui/DrawTextFunctor.h",
    "links" : [ ]
  }, {
    "name" : "HIGH_CONTRAST_TEXT_BORDER_WIDTH_FACTOR",
    "type" : "float",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "BREAK_STRATEGY_SIMPLE",
    "type" : "int",
    "comment" : "\n     * Value for break strategy indicating simple line breaking. Automatic hyphens are not added\n     * (though soft hyphens are respected), and modifying text generally doesn't affect the layout\n     * before it (which yields a more consistent user experience when editing), but layout may not\n     * be the highest quality.\n     ",
    "links" : [ ]
  }, {
    "name" : "BREAK_STRATEGY_HIGH_QUALITY",
    "type" : "int",
    "comment" : "\n     * Value for break strategy indicating high quality line breaking, including automatic\n     * hyphenation and doing whole-paragraph optimization of line breaks.\n     ",
    "links" : [ ]
  }, {
    "name" : "BREAK_STRATEGY_BALANCED",
    "type" : "int",
    "comment" : "\n     * Value for break strategy indicating balanced line breaking. The breaks are chosen to\n     * make all lines as close to the same length as possible, including automatic hyphenation.\n     ",
    "links" : [ ]
  }, {
    "name" : "HYPHENATION_FREQUENCY_NONE",
    "type" : "int",
    "comment" : "\n     * Value for hyphenation frequency indicating no automatic hyphenation. Useful\n     * for backward compatibility, and for cases where the automatic hyphenation algorithm results\n     * in incorrect hyphenation. Mid-word breaks may still happen when a word is wider than the\n     * layout and there is otherwise no valid break. Soft hyphens are ignored and will not be used\n     * as suggestions for potential line breaks.\n     ",
    "links" : [ ]
  }, {
    "name" : "HYPHENATION_FREQUENCY_NORMAL",
    "type" : "int",
    "comment" : "\n     * Value for hyphenation frequency indicating a light amount of automatic hyphenation, which\n     * is a conservative default. Useful for informal cases, such as short sentences or chat\n     * messages.\n     ",
    "links" : [ ]
  }, {
    "name" : "HYPHENATION_FREQUENCY_FULL",
    "type" : "int",
    "comment" : "\n     * Value for hyphenation frequency indicating the full amount of automatic hyphenation, typical\n     * in typography. Useful for running text and where it's important to put the maximum amount of\n     * text in a screen with limited space.\n     ",
    "links" : [ ]
  }, {
    "name" : "HYPHENATION_FREQUENCY_NORMAL_FAST",
    "type" : "int",
    "comment" : "\n     * Value for hyphenation frequency indicating a light amount of automatic hyphenation with\n     * using faster algorithm.\n     *\n     * This option is useful for informal cases, such as short sentences or chat messages. To make\n     * text rendering faster with hyphenation, this algorithm ignores some hyphen character related\n     * typographic features, e.g. kerning.\n     ",
    "links" : [ ]
  }, {
    "name" : "HYPHENATION_FREQUENCY_FULL_FAST",
    "type" : "int",
    "comment" : "\n     * Value for hyphenation frequency indicating the full amount of automatic hyphenation with\n     * using faster algorithm.\n     *\n     * This option is useful for running text and where it's important to put the maximum amount of\n     * text in a screen with limited space. To make text rendering faster with hyphenation, this\n     * algorithm ignores some hyphen character related typographic features, e.g. kerning.\n     ",
    "links" : [ ]
  }, {
    "name" : "NO_PARA_SPANS",
    "type" : "ParagraphStyle[]",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "JUSTIFICATION_MODE_NONE",
    "type" : "int",
    "comment" : "\n     * Value for justification mode indicating no justification.\n     ",
    "links" : [ ]
  }, {
    "name" : "JUSTIFICATION_MODE_INTER_WORD",
    "type" : "int",
    "comment" : "\n     * Value for justification mode indicating the text is justified by stretching word spacing.\n     ",
    "links" : [ ]
  }, {
    "name" : "JUSTIFICATION_MODE_INTER_CHARACTER",
    "type" : "int",
    "comment" : "\n     * Value for justification mode indicating the text is justified by stretching letter spacing.\n     ",
    "links" : [ ]
  }, {
    "name" : "DEFAULT_LINESPACING_MULTIPLIER",
    "type" : "float",
    "comment" : "\n     * Line spacing multiplier for default line spacing.\n     ",
    "links" : [ ]
  }, {
    "name" : "DEFAULT_LINESPACING_ADDITION",
    "type" : "float",
    "comment" : "\n     * Line spacing addition for default line spacing.\n     ",
    "links" : [ ]
  }, {
    "name" : "INCLUSION_STRATEGY_ANY_OVERLAP",
    "type" : "TextInclusionStrategy",
    "comment" : "\n     * Strategy which considers a text segment to be inside a rectangle area if the segment bounds\n     * intersect the rectangle.\n     ",
    "links" : [ ]
  }, {
    "name" : "INCLUSION_STRATEGY_CONTAINS_CENTER",
    "type" : "TextInclusionStrategy",
    "comment" : "\n     * Strategy which considers a text segment to be inside a rectangle area if the center of the\n     * segment bounds is inside the rectangle.\n     ",
    "links" : [ ]
  }, {
    "name" : "INCLUSION_STRATEGY_CONTAINS_ALL",
    "type" : "TextInclusionStrategy",
    "comment" : "\n     * Strategy which considers a text segment to be inside a rectangle area if the segment bounds\n     * are completely contained within the rectangle.\n     ",
    "links" : [ ]
  }, {
    "name" : "mText",
    "type" : "CharSequence",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mPaint",
    "type" : "TextPaint",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mWorkPaint",
    "type" : "TextPaint",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mWorkPlainPaint",
    "type" : "Paint",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mWidth",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mAlignment",
    "type" : "Alignment",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mSpacingMult",
    "type" : "float",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mSpacingAdd",
    "type" : "float",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "sTempRect",
    "type" : "Rect",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mSpannedText",
    "type" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mTextDir",
    "type" : "TextDirectionHeuristic",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mLineBackgroundSpans",
    "type" : "SpanSet<LineBackgroundSpan>",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mIncludePad",
    "type" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mFallbackLineSpacing",
    "type" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mEllipsizedWidth",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mEllipsize",
    "type" : "TextUtils.TruncateAt",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mMaxLines",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mBreakStrategy",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mHyphenationFrequency",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mLeftIndents",
    "type" : "int[]",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mRightIndents",
    "type" : "int[]",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mJustificationMode",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mLineBreakConfig",
    "type" : "LineBreakConfig",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mUseBoundsForWidth",
    "type" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mShiftDrawingOffsetForStartOverhang",
    "type" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mMinimumFontMetrics",
    "type" : "Paint.FontMetrics",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mLineInfo",
    "type" : "TextLine.LineInfo",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "DIR_LEFT_TO_RIGHT",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "DIR_RIGHT_TO_LEFT",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "DIR_REQUEST_LTR",
    "type" : "int",
    "comment" : " package ",
    "links" : [ ]
  }, {
    "name" : "DIR_REQUEST_RTL",
    "type" : "int",
    "comment" : " package ",
    "links" : [ ]
  }, {
    "name" : "DIR_REQUEST_DEFAULT_LTR",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "DIR_REQUEST_DEFAULT_RTL",
    "type" : "int",
    "comment" : " package ",
    "links" : [ ]
  }, {
    "name" : "RUN_LENGTH_MASK",
    "type" : "int",
    "comment" : " package ",
    "links" : [ ]
  }, {
    "name" : "RUN_LEVEL_SHIFT",
    "type" : "int",
    "comment" : " package ",
    "links" : [ ]
  }, {
    "name" : "RUN_LEVEL_MASK",
    "type" : "int",
    "comment" : " package ",
    "links" : [ ]
  }, {
    "name" : "RUN_RTL_FLAG",
    "type" : "int",
    "comment" : " package ",
    "links" : [ ]
  }, {
    "name" : "TAB_INCREMENT",
    "type" : "float",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "DIRS_ALL_LEFT_TO_RIGHT",
    "type" : "Directions",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "DIRS_ALL_RIGHT_TO_LEFT",
    "type" : "Directions",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "TEXT_SELECTION_LAYOUT_RIGHT_TO_LEFT",
    "type" : "int",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "TEXT_SELECTION_LAYOUT_LEFT_TO_RIGHT",
    "type" : "int",
    "comment" : " @hide ",
    "links" : [ ]
  } ],
  "methods" : [ {
    "name" : "public static float getDesiredWidth(CharSequence source, TextPaint paint)",
    "returnType" : "float",
    "comment" : "\n     * Return how wide a layout must be in order to display the specified text with one line per\n     * paragraph.\n     *\n     * <p>As of O, Uses\n     * {@link TextDirectionHeuristics#FIRSTSTRONG_LTR} as the default text direction heuristics. In\n     * the earlier versions uses {@link TextDirectionHeuristics#LTR} as the default.</p>\n     ",
    "links" : [ "android.text.TextDirectionHeuristics#FIRSTSTRONG_LTR", "android.text.TextDirectionHeuristics#LTR" ]
  }, {
    "name" : "public static float getDesiredWidth(CharSequence source, int start, int end, TextPaint paint)",
    "returnType" : "float",
    "comment" : "\n     * Return how wide a layout must be in order to display the specified text slice with one\n     * line per paragraph.\n     *\n     * <p>As of O, Uses\n     * {@link TextDirectionHeuristics#FIRSTSTRONG_LTR} as the default text direction heuristics. In\n     * the earlier versions uses {@link TextDirectionHeuristics#LTR} as the default.</p>\n     ",
    "links" : [ "android.text.TextDirectionHeuristics#FIRSTSTRONG_LTR", "android.text.TextDirectionHeuristics#LTR" ]
  }, {
    "name" : "public static float getDesiredWidth(CharSequence source, int start, int end, TextPaint paint, TextDirectionHeuristic textDir)",
    "returnType" : "float",
    "comment" : "\n     * Return how wide a layout must be in order to display the\n     * specified text slice with one line per paragraph.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public static float getDesiredWidthWithLimit(CharSequence source, int start, int end, TextPaint paint, TextDirectionHeuristic textDir, float upperLimit, boolean useBoundsForWidth)",
    "returnType" : "float",
    "comment" : "\n     * Return how wide a layout must be in order to display the\n     * specified text slice with one line per paragraph.\n     *\n     * If the measured width exceeds given limit, returns limit value instead.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : " void replaceWith(CharSequence text, TextPaint paint, int width, Alignment align, float spacingmult, float spacingadd)",
    "returnType" : "void",
    "comment" : " package ",
    "links" : [ ]
  }, {
    "name" : "public void draw(Canvas c)",
    "returnType" : "void",
    "comment" : "\n     * Draw this Layout on the specified Canvas.\n     *\n     * This API draws background first, then draws text on top of it.\n     *\n     * @see #draw(Canvas, List, List, Path, Paint, int)\n     ",
    "links" : [ ]
  }, {
    "name" : "public void draw(Canvas canvas, Path selectionHighlight, Paint selectionHighlightPaint, int cursorOffsetVertical)",
    "returnType" : "void",
    "comment" : "\n     * Draw this Layout on the specified canvas, with the highlight path drawn\n     * between the background and the text.\n     *\n     * @param canvas the canvas\n     * @param selectionHighlight the path of the selection highlight or cursor; can be null\n     * @param selectionHighlightPaint the paint for the selection highlight\n     * @param cursorOffsetVertical the amount to temporarily translate the\n     *        canvas while rendering the highlight\n     *\n     * @see #draw(Canvas, List, List, Path, Paint, int)\n     ",
    "links" : [ ]
  }, {
    "name" : "public void draw(@NonNull Canvas canvas, @Nullable List<Path> highlightPaths, @Nullable List<Paint> highlightPaints, @Nullable Path selectionPath, @Nullable Paint selectionPaint, int cursorOffsetVertical)",
    "returnType" : "void",
    "comment" : "\n     * Draw this layout on the specified canvas.\n     *\n     * This API draws background first, then draws highlight paths on top of it, then draws\n     * selection or cursor, then finally draws text on top of it.\n     *\n     * @see #drawBackground(Canvas)\n     * @see #drawText(Canvas)\n     *\n     * @param canvas the canvas\n     * @param highlightPaths the path of the highlights. The highlightPaths and highlightPaints must\n     *                      have the same length and aligned in the same order. For example, the\n     *                      paint of the n-th of the highlightPaths should be stored at the n-th of\n     *                      highlightPaints.\n     * @param highlightPaints the paints for the highlights. The highlightPaths and highlightPaints\n     *                        must have the same length and aligned in the same order. For example,\n     *                        the paint of the n-th of the highlightPaths should be stored at the\n     *                        n-th of highlightPaints.\n     * @param selectionPath the selection or cursor path\n     * @param selectionPaint the paint for the selection or cursor.\n     * @param cursorOffsetVertical the amount to temporarily translate the canvas while rendering\n     *                            the highlight\n     ",
    "links" : [ ]
  }, {
    "name" : "private static boolean shouldDrawHighlightsOnTop(Canvas canvas)",
    "returnType" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private static Paint setToHighlightPaint(Paint p, BlendMode blendMode, Paint outPaint)",
    "returnType" : "Paint",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public void drawText(@NonNull Canvas canvas)",
    "returnType" : "void",
    "comment" : "\n     * Draw text part of this layout.\n     *\n     * Different from {@link #draw(Canvas, List, List, Path, Paint, int)} API, this API only draws\n     * text part, not drawing highlights, selections, or backgrounds.\n     *\n     * @see #draw(Canvas, List, List, Path, Paint, int)\n     * @see #drawBackground(Canvas)\n     *\n     * @param canvas the canvas\n     ",
    "links" : [ "#draw(Canvas" ]
  }, {
    "name" : "public void drawBackground(@NonNull Canvas canvas)",
    "returnType" : "void",
    "comment" : "\n     * Draw background of this layout.\n     *\n     * Different from {@link #draw(Canvas, List, List, Path, Paint, int)} API, this API only draws\n     * background, not drawing text, highlights or selections. The background here is drawn by\n     * {@link LineBackgroundSpan} attached to the text.\n     *\n     * @see #draw(Canvas, List, List, Path, Paint, int)\n     * @see #drawText(Canvas)\n     *\n     * @param canvas the canvas\n     ",
    "links" : [ "#draw(Canvas", "android.text.style.LineBackgroundSpan" ]
  }, {
    "name" : "public void drawWithoutText(@NonNull Canvas canvas, @Nullable List<Path> highlightPaths, @Nullable List<Paint> highlightPaints, @Nullable Path selectionPath, @Nullable Paint selectionPaint, int cursorOffsetVertical, int firstLine, int lastLine)",
    "returnType" : "void",
    "comment" : "\n     * @hide public for Editor.java\n     ",
    "links" : [ ]
  }, {
    "name" : "public void drawHighlights(@NonNull Canvas canvas, @Nullable List<Path> highlightPaths, @Nullable List<Paint> highlightPaints, @Nullable Path selectionPath, @Nullable Paint selectionPaint, int cursorOffsetVertical, int firstLine, int lastLine)",
    "returnType" : "void",
    "comment" : "\n     * @hide public for Editor.java\n     ",
    "links" : [ ]
  }, {
    "name" : "private BlendMode determineHighContrastHighlightBlendMode(Canvas canvas)",
    "returnType" : "BlendMode",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private boolean isHighContrastTextDark()",
    "returnType" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private boolean isJustificationRequired(int lineNum)",
    "returnType" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private float getJustifyWidth(int lineNum)",
    "returnType" : "float",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public void drawText(Canvas canvas, int firstLine, int lastLine)",
    "returnType" : "void",
    "comment" : "\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public void drawBackground(@NonNull Canvas canvas, int firstLine, int lastLine)",
    "returnType" : "void",
    "comment" : "\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "private void drawHighContrastBackground(@NonNull Canvas canvas, int firstLine, int lastLine)",
    "returnType" : "void",
    "comment" : "\n     * Draws a solid rectangle behind the text, the same color as the high contrast stroke border,\n     * to make it even easier to read.\n     *\n     * <p>We draw it here instead of in DrawTextFunctor so that multiple spans don't draw\n     * backgrounds over each other's text.\n     ",
    "links" : [ ]
  }, {
    "name" : "public long getLineRangeForDraw(Canvas canvas)",
    "returnType" : "long",
    "comment" : "\n     * @param canvas\n     * @return The range of lines that need to be drawn, possibly empty.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "private int getLineStartPos(int line, int left, int right)",
    "returnType" : "int",
    "comment" : "\n     * Return the start position of the line, given the left and right bounds of the margins.\n     *\n     * @param line the line index\n     * @param left the left bounds (0, or leading margin if ltr para)\n     * @param right the right bounds (width, minus leading margin if rtl para)\n     * @return the start position of the line (to right of line if rtl para)\n     ",
    "links" : [ ]
  }, {
    "name" : "public final void increaseWidthTo(int wid)",
    "returnType" : "void",
    "comment" : "\n     * Increase the width of this layout to the specified width.\n     * Be careful to use this only when you know it is appropriate&mdash;\n     * it does not cause the text to reflow to use the full new width.\n     ",
    "links" : [ ]
  }, {
    "name" : "public int getHeight()",
    "returnType" : "int",
    "comment" : "\n     * Return the total height of this layout.\n     ",
    "links" : [ ]
  }, {
    "name" : "public int getHeight(boolean cap)",
    "returnType" : "int",
    "comment" : "\n     * Return the total height of this layout.\n     *\n     * @param cap if true and max lines is set, returns the height of the layout at the max lines.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public abstract int getLineCount()",
    "returnType" : "int",
    "comment" : "\n     * Return the number of lines of text in this layout.\n     ",
    "links" : [ ]
  }, {
    "name" : "public RectF computeDrawingBoundingBox()",
    "returnType" : "RectF",
    "comment" : "\n     * Get an actual bounding box that draws text content.\n     *\n     * Note that the {@link RectF#top} and {@link RectF#bottom} may be different from the\n     * {@link Layout#getLineTop(int)} of the first line and {@link Layout#getLineBottom(int)} of\n     * the last line. The line top and line bottom are calculated based on yMin/yMax or\n     * ascent/descent value of font file. On the other hand, the drawing bounding boxes are\n     * calculated based on actual glyphs used there.\n     *\n     * @return bounding rectangle\n     ",
    "links" : [ "android.text.Layout#getLineTop(int)", "android.graphics.RectF#bottom", "android.graphics.RectF#top", "android.text.Layout#getLineBottom(int)" ]
  }, {
    "name" : "public int getLineBounds(int line, Rect bounds)",
    "returnType" : "int",
    "comment" : "\n     * Return the baseline for the specified line (0&hellip;getLineCount() - 1)\n     * If bounds is not null, return the top, left, right, bottom extents\n     * of the specified line in it.\n     * @param line which line to examine (0..getLineCount() - 1)\n     * @param bounds Optional. If not null, it returns the extent of the line\n     * @return the Y-coordinate of the baseline\n     ",
    "links" : [ ]
  }, {
    "name" : "public abstract int getLineTop(int line)",
    "returnType" : "int",
    "comment" : "\n     * Return the vertical position of the top of the specified line\n     * (0&hellip;getLineCount()).\n     * If the specified line is equal to the line count, returns the\n     * bottom of the last line.\n     ",
    "links" : [ ]
  }, {
    "name" : "public abstract int getLineDescent(int line)",
    "returnType" : "int",
    "comment" : "\n     * Return the descent of the specified line(0&hellip;getLineCount() - 1).\n     ",
    "links" : [ ]
  }, {
    "name" : "public abstract int getLineStart(int line)",
    "returnType" : "int",
    "comment" : "\n     * Return the text offset of the beginning of the specified line (\n     * 0&hellip;getLineCount()). If the specified line is equal to the line\n     * count, returns the length of the text.\n     ",
    "links" : [ ]
  }, {
    "name" : "public abstract int getParagraphDirection(int line)",
    "returnType" : "int",
    "comment" : "\n     * Returns the primary directionality of the paragraph containing the\n     * specified line, either 1 for left-to-right lines, or -1 for right-to-left\n     * lines (see {@link #DIR_LEFT_TO_RIGHT}, {@link #DIR_RIGHT_TO_LEFT}).\n     ",
    "links" : [ "#DIR_RIGHT_TO_LEFT", "#DIR_LEFT_TO_RIGHT" ]
  }, {
    "name" : "public abstract boolean getLineContainsTab(int line)",
    "returnType" : "boolean",
    "comment" : "\n     * Returns whether the specified line contains one or more\n     * characters that need to be handled specially, like tabs.\n     ",
    "links" : [ ]
  }, {
    "name" : "public abstract Directions getLineDirections(int line)",
    "returnType" : "Directions",
    "comment" : "\n     * Returns the directional run information for the specified line.\n     * The array alternates counts of characters in left-to-right\n     * and right-to-left segments of the line.\n     *\n     * <p>NOTE: this is inadequate to support bidirectional text, and will change.\n     ",
    "links" : [ ]
  }, {
    "name" : "public abstract int getTopPadding()",
    "returnType" : "int",
    "comment" : "\n     * Returns the (negative) number of extra pixels of ascent padding in the\n     * top line of the Layout.\n     ",
    "links" : [ ]
  }, {
    "name" : "public abstract int getBottomPadding()",
    "returnType" : "int",
    "comment" : "\n     * Returns the number of extra pixels of descent padding in the\n     * bottom line of the Layout.\n     ",
    "links" : [ ]
  }, {
    "name" : "public int getStartHyphenEdit(int line)",
    "returnType" : "int",
    "comment" : "\n     * Returns the start hyphen edit for a line.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public int getEndHyphenEdit(int line)",
    "returnType" : "int",
    "comment" : "\n     * Returns the end hyphen edit for a line.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public int getIndentAdjust(int line, Alignment alignment)",
    "returnType" : "int",
    "comment" : "\n     * Returns the left indent for a line.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean isLevelBoundary(int offset)",
    "returnType" : "boolean",
    "comment" : "\n     * Returns true if the character at offset and the preceding character\n     * are at different run levels (and thus there's a split caret).\n     * @param offset the offset\n     * @return true if at a level boundary\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean isRtlCharAt(int offset)",
    "returnType" : "boolean",
    "comment" : "\n     * Returns true if the character at offset is right to left (RTL).\n     * @param offset the offset\n     * @return true if the character is RTL, false if it is LTR\n     ",
    "links" : [ ]
  }, {
    "name" : "public long getRunRange(int offset)",
    "returnType" : "long",
    "comment" : "\n     * Returns the range of the run that the character at offset belongs to.\n     * @param offset the offset\n     * @return The range of the run\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean primaryIsTrailingPrevious(int offset)",
    "returnType" : "boolean",
    "comment" : "\n     * Checks if the trailing BiDi level should be used for an offset\n     *\n     * This method is useful when the offset is at the BiDi level transition point and determine\n     * which run need to be used. For example, let's think about following input: (L* denotes\n     * Left-to-Right characters, R* denotes Right-to-Left characters.)\n     * Input (Logical Order): L1 L2 L3 R1 R2 R3 L4 L5 L6\n     * Input (Display Order): L1 L2 L3 R3 R2 R1 L4 L5 L6\n     *\n     * Then, think about selecting the range (3, 6). The offset=3 and offset=6 are ambiguous here\n     * since they are at the BiDi transition point.  In Android, the offset is considered to be\n     * associated with the trailing run if the BiDi level of the trailing run is higher than of the\n     * previous run.  In this case, the BiDi level of the input text is as follows:\n     *\n     * Input (Logical Order): L1 L2 L3 R1 R2 R3 L4 L5 L6\n     *              BiDi Run: [ Run 0 ][ Run 1 ][ Run 2 ]\n     *            BiDi Level:  0  0  0  1  1  1  0  0  0\n     *\n     * Thus, offset = 3 is part of Run 1 and this method returns true for offset = 3, since the BiDi\n     * level of Run 1 is higher than the level of Run 0.  Similarly, the offset = 6 is a part of Run\n     * 1 and this method returns false for the offset = 6 since the BiDi level of Run 1 is higher\n     * than the level of Run 2.\n     *\n     * @returns true if offset is at the BiDi level transition point and trailing BiDi level is\n     *          higher than previous BiDi level. See above for the detail.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean[] primaryIsTrailingPreviousAllLineOffsets(int line)",
    "returnType" : "boolean[]",
    "comment" : "\n     * Computes in linear time the results of calling\n     * #primaryIsTrailingPrevious for all offsets on a line.\n     * @param line The line giving the offsets we compute the information for\n     * @return The array of results, indexed from 0, where 0 corresponds to the line start offset\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public float getPrimaryHorizontal(int offset)",
    "returnType" : "float",
    "comment" : "\n     * Get the primary horizontal position for the specified text offset.\n     * This is the location where a new character would be inserted in\n     * the paragraph's primary direction.\n     ",
    "links" : [ ]
  }, {
    "name" : "public float getPrimaryHorizontal(int offset, boolean clamped)",
    "returnType" : "float",
    "comment" : "\n     * Get the primary horizontal position for the specified text offset, but\n     * optionally clamp it so that it doesn't exceed the width of the layout.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public float getSecondaryHorizontal(int offset)",
    "returnType" : "float",
    "comment" : "\n     * Get the secondary horizontal position for the specified text offset.\n     * This is the location where a new character would be inserted in\n     * the direction other than the paragraph's primary direction.\n     ",
    "links" : [ ]
  }, {
    "name" : "public float getSecondaryHorizontal(int offset, boolean clamped)",
    "returnType" : "float",
    "comment" : "\n     * Get the secondary horizontal position for the specified text offset, but\n     * optionally clamp it so that it doesn't exceed the width of the layout.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "private float getHorizontal(int offset, boolean primary)",
    "returnType" : "float",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private float getHorizontal(int offset, boolean trailing, boolean clamped)",
    "returnType" : "float",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private float getHorizontal(int offset, boolean trailing, int line, boolean clamped)",
    "returnType" : "float",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private float[] getLineHorizontals(int line, boolean clamped, boolean primary)",
    "returnType" : "float[]",
    "comment" : "\n     * Computes in linear time the results of calling #getHorizontal for all offsets on a line.\n     *\n     * @param line The line giving the offsets we compute information for\n     * @param clamped Whether to clamp the results to the width of the layout\n     * @param primary Whether the results should be the primary or the secondary horizontal\n     * @return The array of results, indexed from 0, where 0 corresponds to the line start offset\n     ",
    "links" : [ ]
  }, {
    "name" : "private void fillHorizontalBoundsForLine(int line, float[] horizontalBounds)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public void fillCharacterBounds(@IntRange(from = 0) int start, @IntRange(from = 0) int end, @NonNull float[] bounds, @IntRange(from = 0) int boundsStart)",
    "returnType" : "void",
    "comment" : "\n     * Return the characters' bounds in the given range. The {@code bounds} array will be filled\n     * starting from {@code boundsStart} (inclusive). The coordinates are in local text layout.\n     *\n     * @param start the start index to compute the character bounds, inclusive.\n     * @param end the end index to compute the character bounds, exclusive.\n     * @param bounds the array to fill in the character bounds. The array is divided into segments\n     *               of four where each index in that segment represents left, top, right and\n     *               bottom of the character.\n     * @param boundsStart the inclusive start index in the array to start filling in the values\n     *                    from.\n     *\n     * @throws IndexOutOfBoundsException if the range defined by {@code start} and {@code end}\n     * exceeds the range of the text, or {@code bounds} doesn't have enough space to store the\n     * result.\n     * @throws IllegalArgumentException if {@code bounds} is null.\n     ",
    "links" : [ ]
  }, {
    "name" : "private void forEachCharacterBounds(@IntRange(from = 0) int start, @IntRange(from = 0) int end, @IntRange(from = 0) int startLine, @IntRange(from = 0) int endLine, CharacterBoundsListener listener)",
    "returnType" : "void",
    "comment" : "\n     * Return the characters' bounds in the given range. The coordinates are in local text layout.\n     *\n     * @param start the start index to compute the character bounds, inclusive.\n     * @param end the end index to compute the character bounds, exclusive.\n     * @param startLine index of the line that contains {@code start}\n     * @param endLine index of the line that contains {@code end}\n     * @param listener called for each character with its bounds\n     *\n     ",
    "links" : [ ]
  }, {
    "name" : "public float getLineLeft(int line)",
    "returnType" : "float",
    "comment" : "\n     * Get the leftmost position that should be exposed for horizontal\n     * scrolling on the specified line.\n     ",
    "links" : [ ]
  }, {
    "name" : "public float getLineRight(int line)",
    "returnType" : "float",
    "comment" : "\n     * Get the rightmost position that should be exposed for horizontal\n     * scrolling on the specified line.\n     ",
    "links" : [ ]
  }, {
    "name" : "public float getLineMax(int line)",
    "returnType" : "float",
    "comment" : "\n     * Gets the unsigned horizontal extent of the specified line, including\n     * leading margin indent, but excluding trailing whitespace.\n     ",
    "links" : [ ]
  }, {
    "name" : "public float getLineWidth(int line)",
    "returnType" : "float",
    "comment" : "\n     * Gets the unsigned horizontal extent of the specified line, including\n     * leading margin indent and trailing whitespace.\n     ",
    "links" : [ ]
  }, {
    "name" : "private float getLineExtent(int line, boolean full)",
    "returnType" : "float",
    "comment" : "\n     * Like {@link #getLineExtent(int,TabStops,boolean)} but determines the\n     * tab stops instead of using the ones passed in.\n     * @param line the index of the line\n     * @param full whether to include trailing whitespace\n     * @return the extent of the line\n     ",
    "links" : [ "#getLineExtent(int" ]
  }, {
    "name" : "public int getLineLetterSpacingUnitCount(@IntRange(from = 0) int line, boolean includeTrailingWhitespace)",
    "returnType" : "int",
    "comment" : "\n     * Returns the number of letter spacing unit in the line.\n     *\n     * <p>\n     * This API returns a number of letters that is a target of letter spacing. The letter spacing\n     * won't be added to the middle of the characters that are needed to be treated as a single,\n     * e.g., ligatured or conjunct form. Note that this value is different from the number of]\n     * grapheme clusters that is calculated by {@link BreakIterator#getCharacterInstance(Locale)}.\n     * For example, if the \"fi\" is ligatured, the ligatured form is treated as single uni and letter\n     * spacing is not added, but it has two separate grapheme cluster.\n     *\n     * <p>\n     * This value is used for calculating the letter spacing amount for the justification because\n     * the letter spacing is applied between clusters. For example, if extra {@code W} pixels needed\n     * to be filled by letter spacing, the amount of letter spacing to be applied is\n     * {@code W}/(letter spacing unit count - 1) px.\n     *\n     * @param line the index of the line\n     * @param includeTrailingWhitespace whether to include trailing whitespace\n     * @return the number of cluster count in the line.\n     ",
    "links" : [ "java.text.BreakIterator#getCharacterInstance(Locale)" ]
  }, {
    "name" : "private float getLineExtent(int line, TabStops tabStops, boolean full)",
    "returnType" : "float",
    "comment" : "\n     * Returns the signed horizontal extent of the specified line, excluding\n     * leading margin.  If full is false, excludes trailing whitespace.\n     * @param line the index of the line\n     * @param tabStops the tab stops, can be null if we know they're not used.\n     * @param full whether to include trailing whitespace\n     * @return the extent of the text on this line\n     ",
    "links" : [ ]
  }, {
    "name" : "public int getLineForVertical(int vertical)",
    "returnType" : "int",
    "comment" : " FIXME: It may be faster to do a linear search for layouts without many lines.",
    "links" : [ ]
  }, {
    "name" : "public int getLineForOffset(int offset)",
    "returnType" : "int",
    "comment" : "\n     * Get the line number on which the specified text offset appears.\n     * If you ask for a position before 0, you get 0; if you ask for a position\n     * beyond the end of the text, you get the last line.\n     ",
    "links" : [ ]
  }, {
    "name" : "public int getOffsetForHorizontal(int line, float horiz)",
    "returnType" : "int",
    "comment" : "\n     * Get the character offset on the specified line whose position is\n     * closest to the specified horizontal position.\n     ",
    "links" : [ ]
  }, {
    "name" : "public int getOffsetForHorizontal(int line, float horiz, boolean primary)",
    "returnType" : "int",
    "comment" : "\n     * Get the character offset on the specified line whose position is\n     * closest to the specified horizontal position.\n     *\n     * @param line the line used to find the closest offset\n     * @param horiz the horizontal position used to find the closest offset\n     * @param primary whether to use the primary position or secondary position to find the offset\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public int[] getRangeForRect(@NonNull RectF area, @NonNull SegmentFinder segmentFinder, @NonNull TextInclusionStrategy inclusionStrategy)",
    "returnType" : "int[]",
    "comment" : "\n     * Finds the range of text which is inside the specified rectangle area. The start of the range\n     * is the start of the first text segment inside the area, and the end of the range is the end\n     * of the last text segment inside the area.\n     *\n     * <p>A text segment is considered to be inside the area according to the provided {@link\n     * TextInclusionStrategy}. If a text segment spans multiple lines or multiple directional runs\n     * (e.g. a hyphenated word), the text segment is divided into pieces at the line and run breaks,\n     * then the text segment is considered to be inside the area if any of its pieces are inside the\n     * area.\n     *\n     * <p>The returned range may also include text segments which are not inside the specified area,\n     * if those text segments are in between text segments which are inside the area. For example,\n     * the returned range may be \"segment1 segment2 segment3\" if \"segment1\" and \"segment3\" are\n     * inside the area and \"segment2\" is not.\n     *\n     * @param area area for which the text range will be found\n     * @param segmentFinder SegmentFinder for determining the ranges of text to be considered as a\n     *     text segment\n     * @param inclusionStrategy strategy for determining whether a text segment is inside the\n     *     specified area\n     * @return int array of size 2 containing the start (inclusive) and end (exclusive) character\n     *     offsets of the text range, or null if there are no text segments inside the area\n     ",
    "links" : [ "TextInclusionStrategy" ]
  }, {
    "name" : "private int getStartOrEndOffsetForAreaWithinLine(@IntRange(from = 0) int line, @NonNull RectF area, @NonNull SegmentFinder segmentFinder, @NonNull TextInclusionStrategy inclusionStrategy, boolean getStart)",
    "returnType" : "int",
    "comment" : "\n     * Finds the start character offset of the first text segment within a line inside the specified\n     * rectangle area, or the end character offset of the last text segment inside the area.\n     *\n     * @param line index of the line to search\n     * @param area area inside which text segments will be found\n     * @param segmentFinder SegmentFinder for determining the ranges of text to be considered as a\n     *     text segment\n     * @param inclusionStrategy strategy for determining whether a text segment is inside the\n     *     specified area\n     * @param getStart true to find the start of the first text segment inside the area, false to\n     *     find the end of the last text segment\n     * @return the start character offset of the first text segment inside the area, or the end\n     *     character offset of the last text segment inside the area.\n     ",
    "links" : [ ]
  }, {
    "name" : "private static int getStartOffsetForAreaWithinRun(@NonNull RectF area, int lineTop, int lineBottom, @IntRange(from = 0) int lineStartOffset, @IntRange(from = 0) int lineStartPos, @NonNull float[] horizontalBounds, @IntRange(from = 0) int runStartOffset, @IntRange(from = 0) int runEndOffset, float runLeft, float runRight, boolean isRtl, @NonNull SegmentFinder segmentFinder, @NonNull TextInclusionStrategy inclusionStrategy)",
    "returnType" : "int",
    "comment" : "\n     * Finds the start character offset of the first text segment within a directional run inside\n     * the specified rectangle area.\n     *\n     * @param area area inside which text segments will be found\n     * @param lineTop top of the line containing this run\n     * @param lineBottom bottom (not including line spacing) of the line containing this run\n     * @param lineStartOffset start character offset of the line containing this run\n     * @param lineStartPos start position of the line containing this run\n     * @param horizontalBounds array containing the signed horizontal bounds of the characters in\n     *     the line. The left and right bounds of the character at offset i are stored at index (2 *\n     *     i) and index (2 * i + 1). Bounds are relative to {@code lineStartPos}.\n     * @param runStartOffset start offset of the run relative to {@code lineStartOffset}\n     * @param runEndOffset end offset of the run relative to {@code lineStartOffset}\n     * @param runLeft left bound of the run\n     * @param runRight right bound of the run\n     * @param isRtl whether the run is right-to-left\n     * @param segmentFinder SegmentFinder for determining the ranges of text to be considered as a\n     *     text segment\n     * @param inclusionStrategy strategy for determining whether a text segment is inside the\n     *     specified area\n     * @return the start character offset of the first text segment inside the area\n     ",
    "links" : [ ]
  }, {
    "name" : "private static int getEndOffsetForAreaWithinRun(@NonNull RectF area, int lineTop, int lineBottom, @IntRange(from = 0) int lineStartOffset, @IntRange(from = 0) int lineStartPos, @NonNull float[] horizontalBounds, @IntRange(from = 0) int runStartOffset, @IntRange(from = 0) int runEndOffset, float runLeft, float runRight, boolean isRtl, @NonNull SegmentFinder segmentFinder, @NonNull TextInclusionStrategy inclusionStrategy)",
    "returnType" : "int",
    "comment" : "\n     * Finds the end character offset of the last text segment within a directional run inside the\n     * specified rectangle area.\n     *\n     * @param area area inside which text segments will be found\n     * @param lineTop top of the line containing this run\n     * @param lineBottom bottom (not including line spacing) of the line containing this run\n     * @param lineStartOffset start character offset of the line containing this run\n     * @param lineStartPos start position of the line containing this run\n     * @param horizontalBounds array containing the signed horizontal bounds of the characters in\n     *     the line. The left and right bounds of the character at offset i are stored at index (2 *\n     *     i) and index (2 * i + 1). Bounds are relative to {@code lineStartPos}.\n     * @param runStartOffset start offset of the run relative to {@code lineStartOffset}\n     * @param runEndOffset end offset of the run relative to {@code lineStartOffset}\n     * @param runLeft left bound of the run\n     * @param runRight right bound of the run\n     * @param isRtl whether the run is right-to-left\n     * @param segmentFinder SegmentFinder for determining the ranges of text to be considered as a\n     *     text segment\n     * @param inclusionStrategy strategy for determining whether a text segment is inside the\n     *     specified area\n     * @return the end character offset of the last text segment inside the area\n     ",
    "links" : [ ]
  }, {
    "name" : "public final int getLineEnd(int line)",
    "returnType" : "int",
    "comment" : "\n     * Return the text offset after the last character on the specified line.\n     ",
    "links" : [ ]
  }, {
    "name" : "public int getLineVisibleEnd(int line)",
    "returnType" : "int",
    "comment" : "\n     * Return the text offset after the last visible character (so whitespace\n     * is not counted) on the specified line.\n     ",
    "links" : [ ]
  }, {
    "name" : "private int getLineVisibleEnd(int line, int start, int end, boolean trailingSpaceAtLastLineIsVisible)",
    "returnType" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public final int getLineBottom(int line)",
    "returnType" : "int",
    "comment" : "\n     * Return the vertical position of the bottom of the specified line.\n     ",
    "links" : [ ]
  }, {
    "name" : "public int getLineBottom(int line, boolean includeLineSpacing)",
    "returnType" : "int",
    "comment" : "\n     * Return the vertical position of the bottom of the specified line.\n     *\n     * @param line index of the line\n     * @param includeLineSpacing whether to include the line spacing\n     ",
    "links" : [ ]
  }, {
    "name" : "public final int getLineBaseline(int line)",
    "returnType" : "int",
    "comment" : "\n     * Return the vertical position of the baseline of the specified line.\n     ",
    "links" : [ ]
  }, {
    "name" : "public final int getLineAscent(int line)",
    "returnType" : "int",
    "comment" : "\n     * Get the ascent of the text on the specified line.\n     * The return value is negative to match the Paint.ascent() convention.\n     ",
    "links" : [ ]
  }, {
    "name" : "public int getLineExtra(@IntRange(from = 0) int line)",
    "returnType" : "int",
    "comment" : "\n     * Return the extra space added as a result of line spacing attributes\n     * {@link #getSpacingAdd()} and {@link #getSpacingMultiplier()}. Default value is {@code zero}.\n     *\n     * @param line the index of the line, the value should be equal or greater than {@code zero}\n     * @hide\n     ",
    "links" : [ "#getSpacingMultiplier()", "#getSpacingAdd()" ]
  }, {
    "name" : "public int getOffsetToLeftOf(int offset)",
    "returnType" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public int getOffsetToRightOf(int offset)",
    "returnType" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private int getOffsetToLeftRightOf(int caret, boolean toLeft)",
    "returnType" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private int getOffsetAtStartOf(int offset)",
    "returnType" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public boolean shouldClampCursor(int line)",
    "returnType" : "boolean",
    "comment" : "\n     * Determine whether we should clamp cursor position. Currently it's\n     * only robust for left-aligned displays.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public void getCursorPath(final int point, final Path dest, final CharSequence editingBuffer)",
    "returnType" : "void",
    "comment" : "\n     * Fills in the specified Path with a representation of a cursor\n     * at the specified offset.  This will often be a vertical line\n     * but can be multiple discontinuous lines in text with multiple\n     * directionalities.\n     ",
    "links" : [ ]
  }, {
    "name" : "private void addSelection(int line, int start, int end, int top, int bottom, SelectionRectangleConsumer consumer)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public void getSelectionPath(int start, int end, Path dest)",
    "returnType" : "void",
    "comment" : "\n     * Fills in the specified Path with a representation of a highlight\n     * between the specified offsets.  This will often be a rectangle\n     * or a potentially discontinuous set of rectangles.  If the start\n     * and end are the same, the returned path is empty.\n     ",
    "links" : [ ]
  }, {
    "name" : "public final void getSelection(int start, int end, final SelectionRectangleConsumer consumer)",
    "returnType" : "void",
    "comment" : "\n     * Calculates the rectangles which should be highlighted to indicate a selection between start\n     * and end and feeds them into the given {@link SelectionRectangleConsumer}.\n     *\n     * @param start    the starting index of the selection\n     * @param end      the ending index of the selection\n     * @param consumer the {@link SelectionRectangleConsumer} which will receive the generated\n     *                 rectangles. It will be called every time a rectangle is generated.\n     * @hide\n     * @see #getSelectionPath(int, int, Path)\n     ",
    "links" : [ "SelectionRectangleConsumer" ]
  }, {
    "name" : "public final Alignment getParagraphAlignment(int line)",
    "returnType" : "Alignment",
    "comment" : "\n     * Get the alignment of the specified paragraph, taking into account\n     * markup attached to it.\n     ",
    "links" : [ ]
  }, {
    "name" : "public final int getParagraphLeft(int line)",
    "returnType" : "int",
    "comment" : "\n     * Get the left edge of the specified paragraph, inset by left margins.\n     ",
    "links" : [ ]
  }, {
    "name" : "public final int getParagraphRight(int line)",
    "returnType" : "int",
    "comment" : "\n     * Get the right edge of the specified paragraph, inset by right margins.\n     ",
    "links" : [ ]
  }, {
    "name" : "private int getParagraphLeadingMargin(int line)",
    "returnType" : "int",
    "comment" : "\n     * Returns the effective leading margin (unsigned) for this line,\n     * taking into account LeadingMarginSpan and LeadingMarginSpan2.\n     * @param line the line index\n     * @return the leading margin of this line\n     ",
    "links" : [ ]
  }, {
    "name" : "private static float measurePara(TextPaint paint, CharSequence text, int start, int end, TextDirectionHeuristic textDir, boolean useBoundsForWidth)",
    "returnType" : "float",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : " static float nextTab(CharSequence text, int start, int end, float h, Object[] tabs)",
    "returnType" : "float",
    "comment" : " package ",
    "links" : [ ]
  }, {
    "name" : "protected final boolean isSpanned()",
    "returnType" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : " static T[] getParagraphSpans(Spanned text, int start, int end, Class<T> type)",
    "returnType" : "T[]",
    "comment" : " package ",
    "links" : [ ]
  }, {
    "name" : "private void ellipsize(int start, int end, int line, char[] dest, int destoff, TextUtils.TruncateAt method)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public abstract int getEllipsisStart(int line)",
    "returnType" : "int",
    "comment" : "\n     * Return the offset of the first character to be ellipsized away,\n     * relative to the start of the line.  (So 0 if the beginning of the\n     * line is ellipsized, not getLineStart().)\n     ",
    "links" : [ ]
  }, {
    "name" : "public abstract int getEllipsisCount(int line)",
    "returnType" : "int",
    "comment" : "\n     * Returns the number of characters to be ellipsized away, or 0 if\n     * no ellipsis is to take place.\n     ",
    "links" : [ ]
  }, {
    "name" : "public final CharSequence getText()",
    "returnType" : "CharSequence",
    "comment" : "\n     * Return the text used for creating this layout.\n     *\n     * @return the text used for creating this layout.\n     ",
    "links" : [ ]
  }, {
    "name" : "public final TextPaint getPaint()",
    "returnType" : "TextPaint",
    "comment" : "\n     * Return the paint used for creating this layout.\n     *\n     * Do not modify the returned paint object. This paint object will still be used for\n     * drawing/measuring text.\n     *\n     * @return the paint used for creating this layout.\n     ",
    "links" : [ ]
  }, {
    "name" : "public final int getWidth()",
    "returnType" : "int",
    "comment" : "\n     * Return the width used for creating this layout in pixels.\n     *\n     * @return the width used for creating this layout in pixels.\n     ",
    "links" : [ ]
  }, {
    "name" : "public final Alignment getAlignment()",
    "returnType" : "Alignment",
    "comment" : "\n     * Returns the alignment used for creating this layout in pixels.\n     *\n     * @return the alignment used for creating this layout.\n     * @see StaticLayout.Builder#setAlignment(Alignment)\n     ",
    "links" : [ ]
  }, {
    "name" : "public final TextDirectionHeuristic getTextDirectionHeuristic()",
    "returnType" : "TextDirectionHeuristic",
    "comment" : "\n     * Returns the text direction heuristic used for creating this layout.\n     *\n     * @return the text direction heuristic used for creating this layout\n     * @see Layout.Builder#setTextDirectionHeuristic(TextDirectionHeuristic)\n     * @see StaticLayout.Builder#setTextDirection(TextDirectionHeuristic)\n     ",
    "links" : [ ]
  }, {
    "name" : "public final float getSpacingMultiplier()",
    "returnType" : "float",
    "comment" : "\n     * Returns the multiplier applied to the line height.\n     *\n     * @return the line height multiplier.\n     * @see StaticLayout.Builder#setLineSpacing(float, float)\n     ",
    "links" : [ ]
  }, {
    "name" : "public final float getLineSpacingMultiplier()",
    "returnType" : "float",
    "comment" : "\n     * Returns the multiplier applied to the line height.\n     *\n     * @return the line height multiplier.\n     * @see Layout.Builder#setLineSpacingMultiplier(float)\n     * @see StaticLayout.Builder#setLineSpacing(float, float)\n     * @see Layout#getSpacingMultiplier()\n     ",
    "links" : [ ]
  }, {
    "name" : "public final float getSpacingAdd()",
    "returnType" : "float",
    "comment" : "\n     * Returns the amount added to the line height.\n     *\n     * @return the line height additional amount.\n     * @see StaticLayout.Builder#setLineSpacing(float, float)\n     ",
    "links" : [ ]
  }, {
    "name" : "public final float getLineSpacingAmount()",
    "returnType" : "float",
    "comment" : "\n     * Returns the amount added to the line height.\n     *\n     * @return the line height additional amount.\n     * @see Layout.Builder#setLineSpacingAmount(float)\n     * @see StaticLayout.Builder#setLineSpacing(float, float)\n     * @see Layout#getSpacingAdd()\n     ",
    "links" : [ ]
  }, {
    "name" : "public final boolean isFontPaddingIncluded()",
    "returnType" : "boolean",
    "comment" : "\n     * Returns true if this layout is created with increased line height.\n     *\n     * @return true if the layout is created with increased line height.\n     * @see Layout.Builder#setFontPaddingIncluded(boolean)\n     * @see StaticLayout.Builder#setIncludePad(boolean)\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean isFallbackLineSpacingEnabled()",
    "returnType" : "boolean",
    "comment" : " not being final because of already published API.",
    "links" : [ ]
  }, {
    "name" : "public int getEllipsizedWidth()",
    "returnType" : "int",
    "comment" : "\n     * Return the width to which this layout is ellipsized.\n     *\n     * If no ellipsize is applied, the same amount of {@link #getWidth} is returned.\n     *\n     * @return the amount of ellipsized width in pixels.\n     * @see StaticLayout.Builder#setEllipsizedWidth(int)\n     * @see StaticLayout.Builder#setEllipsize(TextUtils.TruncateAt)\n     ",
    "links" : [ "#getWidth" ]
  }, {
    "name" : "public final TextUtils.TruncateAt getEllipsize()",
    "returnType" : "TextUtils.TruncateAt",
    "comment" : "\n     * Return the ellipsize option used for creating this layout.\n     *\n     * May return null if no ellipsize option was selected.\n     *\n     * @return The ellipsize option used for creating this layout, or null if no ellipsize option\n     * was selected.\n     * @see Layout.Builder#setEllipsize(TextUtils.TruncateAt)\n     * @see StaticLayout.Builder#setEllipsize(TextUtils.TruncateAt)\n     * @see Layout.Builder#setEllipsizedWidth(int)\n     * @see StaticLayout.Builder#setEllipsizedWidth(int)\n     * @see Layout#getEllipsizedWidth()\n     ",
    "links" : [ ]
  }, {
    "name" : "public final int getMaxLines()",
    "returnType" : "int",
    "comment" : "\n     * Return the maximum lines allowed used for creating this layout.\n     *\n     * Note that this is not an actual line count of this layout. Use {@link #getLineCount()} for\n     * getting the actual line count of this layout.\n     *\n     * @return the maximum lines allowed used for creating this layout.\n     * @see Layout.Builder#setMaxLines(int)\n     * @see StaticLayout.Builder#setMaxLines(int)\n     ",
    "links" : [ "#getLineCount()" ]
  }, {
    "name" : "public final int getBreakStrategy()",
    "returnType" : "int",
    "comment" : "\n     * Return the break strategy used for creating this layout.\n     *\n     * @return the break strategy used for creating this layout.\n     * @see Layout.Builder#setBreakStrategy(int)\n     * @see StaticLayout.Builder#setBreakStrategy(int)\n     ",
    "links" : [ ]
  }, {
    "name" : "public final int getHyphenationFrequency()",
    "returnType" : "int",
    "comment" : "\n     * Return the hyphenation frequency used for creating this layout.\n     *\n     * @return the hyphenation frequency used for creating this layout.\n     * @see Layout.Builder#setHyphenationFrequency(int)\n     * @see StaticLayout.Builder#setHyphenationFrequency(int)\n     ",
    "links" : [ ]
  }, {
    "name" : "public final int[] getLeftIndents()",
    "returnType" : "int[]",
    "comment" : "\n     * Return a copy of the left indents used for this layout.\n     *\n     * May return null if no left indentation is applied.\n     *\n     * @return the array of left indents in pixels.\n     * @see Layout.Builder#setLeftIndents(int[])\n     * @see Layout.Builder#setRightIndents(int[])\n     * @see StaticLayout.Builder#setIndents(int[], int[])\n     ",
    "links" : [ ]
  }, {
    "name" : "public final int[] getRightIndents()",
    "returnType" : "int[]",
    "comment" : "\n     * Return a copy of the right indents used for this layout.\n     *\n     * May return null if no right indentation is applied.\n     *\n     * @return the array of right indents in pixels.\n     * @see Layout.Builder#setLeftIndents(int[])\n     * @see Layout.Builder#setRightIndents(int[])\n     * @see StaticLayout.Builder#setIndents(int[], int[])\n     ",
    "links" : [ ]
  }, {
    "name" : "public final int getJustificationMode()",
    "returnType" : "int",
    "comment" : "\n     * Return the justification mode used for creating this layout.\n     *\n     * @return the justification mode used for creating this layout.\n     * @see Layout.Builder#setJustificationMode(int)\n     * @see StaticLayout.Builder#setJustificationMode(int)\n     ",
    "links" : [ ]
  }, {
    "name" : "public LineBreakConfig getLineBreakConfig()",
    "returnType" : "LineBreakConfig",
    "comment" : " not being final because of subclass has already published API.",
    "links" : [ ]
  }, {
    "name" : "public boolean getUseBoundsForWidth()",
    "returnType" : "boolean",
    "comment" : "\n     * Returns true if using bounding box as a width, false for using advance as a width.\n     *\n     * @return True if using bounding box for width, false if using advance for width.\n     * @see android.widget.TextView#setUseBoundsForWidth(boolean)\n     * @see android.widget.TextView#getUseBoundsForWidth()\n     * @see StaticLayout.Builder#setUseBoundsForWidth(boolean)\n     * @see DynamicLayout.Builder#setUseBoundsForWidth(boolean)\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean getShiftDrawingOffsetForStartOverhang()",
    "returnType" : "boolean",
    "comment" : "\n     * Returns true if shifting drawing offset for start overhang.\n     *\n     * @return True if shifting drawing offset for start overhang.\n     * @see android.widget.TextView#setShiftDrawingOffsetForStartOverhang(boolean)\n     * @see TextView#getShiftDrawingOffsetForStartOverhang()\n     * @see StaticLayout.Builder#setShiftDrawingOffsetForStartOverhang(boolean)\n     * @see DynamicLayout.Builder#setShiftDrawingOffsetForStartOverhang(boolean)\n     ",
    "links" : [ ]
  }, {
    "name" : "public Paint.FontMetrics getMinimumFontMetrics()",
    "returnType" : "Paint.FontMetrics",
    "comment" : "\n     * Get the minimum font metrics used for line spacing.\n     *\n     * @see android.widget.TextView#setMinimumFontMetrics(Paint.FontMetrics)\n     * @see android.widget.TextView#getMinimumFontMetrics()\n     * @see Layout.Builder#setMinimumFontMetrics(Paint.FontMetrics)\n     * @see StaticLayout.Builder#setMinimumFontMetrics(Paint.FontMetrics)\n     * @see DynamicLayout.Builder#setMinimumFontMetrics(Paint.FontMetrics)\n     *\n     * @return a minimum font metrics. {@code null} for using the value obtained by\n     *         {@link Paint#getFontMetricsForLocale(Paint.FontMetrics)}\n     ",
    "links" : [ "android.graphics.Paint#getFontMetricsForLocale(Paint.FontMetrics)" ]
  } ],
  "methodNames" : [ "public static float getDesiredWidth(CharSequence source, TextPaint paint)", "public static float getDesiredWidth(CharSequence source, int start, int end, TextPaint paint)", "public static float getDesiredWidth(CharSequence source, int start, int end, TextPaint paint, TextDirectionHeuristic textDir)", "public static float getDesiredWidthWithLimit(CharSequence source, int start, int end, TextPaint paint, TextDirectionHeuristic textDir, float upperLimit, boolean useBoundsForWidth)", " void replaceWith(CharSequence text, TextPaint paint, int width, Alignment align, float spacingmult, float spacingadd)", "public void draw(Canvas c)", "public void draw(Canvas canvas, Path selectionHighlight, Paint selectionHighlightPaint, int cursorOffsetVertical)", "public void draw(@NonNull Canvas canvas, @Nullable List<Path> highlightPaths, @Nullable List<Paint> highlightPaints, @Nullable Path selectionPath, @Nullable Paint selectionPaint, int cursorOffsetVertical)", "private static boolean shouldDrawHighlightsOnTop(Canvas canvas)", "private static Paint setToHighlightPaint(Paint p, BlendMode blendMode, Paint outPaint)", "public void drawText(@NonNull Canvas canvas)", "public void drawBackground(@NonNull Canvas canvas)", "public void drawWithoutText(@NonNull Canvas canvas, @Nullable List<Path> highlightPaths, @Nullable List<Paint> highlightPaints, @Nullable Path selectionPath, @Nullable Paint selectionPaint, int cursorOffsetVertical, int firstLine, int lastLine)", "public void drawHighlights(@NonNull Canvas canvas, @Nullable List<Path> highlightPaths, @Nullable List<Paint> highlightPaints, @Nullable Path selectionPath, @Nullable Paint selectionPaint, int cursorOffsetVertical, int firstLine, int lastLine)", "private BlendMode determineHighContrastHighlightBlendMode(Canvas canvas)", "private boolean isHighContrastTextDark()", "private boolean isJustificationRequired(int lineNum)", "private float getJustifyWidth(int lineNum)", "public void drawText(Canvas canvas, int firstLine, int lastLine)", "public void drawBackground(@NonNull Canvas canvas, int firstLine, int lastLine)", "private void drawHighContrastBackground(@NonNull Canvas canvas, int firstLine, int lastLine)", "public long getLineRangeForDraw(Canvas canvas)", "private int getLineStartPos(int line, int left, int right)", "public final void increaseWidthTo(int wid)", "public int getHeight()", "public int getHeight(boolean cap)", "public abstract int getLineCount()", "public RectF computeDrawingBoundingBox()", "public int getLineBounds(int line, Rect bounds)", "public abstract int getLineTop(int line)", "public abstract int getLineDescent(int line)", "public abstract int getLineStart(int line)", "public abstract int getParagraphDirection(int line)", "public abstract boolean getLineContainsTab(int line)", "public abstract Directions getLineDirections(int line)", "public abstract int getTopPadding()", "public abstract int getBottomPadding()", "public int getStartHyphenEdit(int line)", "public int getEndHyphenEdit(int line)", "public int getIndentAdjust(int line, Alignment alignment)", "public boolean isLevelBoundary(int offset)", "public boolean isRtlCharAt(int offset)", "public long getRunRange(int offset)", "public boolean primaryIsTrailingPrevious(int offset)", "public boolean[] primaryIsTrailingPreviousAllLineOffsets(int line)", "public float getPrimaryHorizontal(int offset)", "public float getPrimaryHorizontal(int offset, boolean clamped)", "public float getSecondaryHorizontal(int offset)", "public float getSecondaryHorizontal(int offset, boolean clamped)", "private float getHorizontal(int offset, boolean primary)", "private float getHorizontal(int offset, boolean trailing, boolean clamped)", "private float getHorizontal(int offset, boolean trailing, int line, boolean clamped)", "private float[] getLineHorizontals(int line, boolean clamped, boolean primary)", "private void fillHorizontalBoundsForLine(int line, float[] horizontalBounds)", "public void fillCharacterBounds(@IntRange(from = 0) int start, @IntRange(from = 0) int end, @NonNull float[] bounds, @IntRange(from = 0) int boundsStart)", "private void forEachCharacterBounds(@IntRange(from = 0) int start, @IntRange(from = 0) int end, @IntRange(from = 0) int startLine, @IntRange(from = 0) int endLine, CharacterBoundsListener listener)", "public float getLineLeft(int line)", "public float getLineRight(int line)", "public float getLineMax(int line)", "public float getLineWidth(int line)", "private float getLineExtent(int line, boolean full)", "public int getLineLetterSpacingUnitCount(@IntRange(from = 0) int line, boolean includeTrailingWhitespace)", "private float getLineExtent(int line, TabStops tabStops, boolean full)", "public int getLineForVertical(int vertical)", "public int getLineForOffset(int offset)", "public int getOffsetForHorizontal(int line, float horiz)", "public int getOffsetForHorizontal(int line, float horiz, boolean primary)", "public int[] getRangeForRect(@NonNull RectF area, @NonNull SegmentFinder segmentFinder, @NonNull TextInclusionStrategy inclusionStrategy)", "private int getStartOrEndOffsetForAreaWithinLine(@IntRange(from = 0) int line, @NonNull RectF area, @NonNull SegmentFinder segmentFinder, @NonNull TextInclusionStrategy inclusionStrategy, boolean getStart)", "private static int getStartOffsetForAreaWithinRun(@NonNull RectF area, int lineTop, int lineBottom, @IntRange(from = 0) int lineStartOffset, @IntRange(from = 0) int lineStartPos, @NonNull float[] horizontalBounds, @IntRange(from = 0) int runStartOffset, @IntRange(from = 0) int runEndOffset, float runLeft, float runRight, boolean isRtl, @NonNull SegmentFinder segmentFinder, @NonNull TextInclusionStrategy inclusionStrategy)", "private static int getEndOffsetForAreaWithinRun(@NonNull RectF area, int lineTop, int lineBottom, @IntRange(from = 0) int lineStartOffset, @IntRange(from = 0) int lineStartPos, @NonNull float[] horizontalBounds, @IntRange(from = 0) int runStartOffset, @IntRange(from = 0) int runEndOffset, float runLeft, float runRight, boolean isRtl, @NonNull SegmentFinder segmentFinder, @NonNull TextInclusionStrategy inclusionStrategy)", "public final int getLineEnd(int line)", "public int getLineVisibleEnd(int line)", "private int getLineVisibleEnd(int line, int start, int end, boolean trailingSpaceAtLastLineIsVisible)", "public final int getLineBottom(int line)", "public int getLineBottom(int line, boolean includeLineSpacing)", "public final int getLineBaseline(int line)", "public final int getLineAscent(int line)", "public int getLineExtra(@IntRange(from = 0) int line)", "public int getOffsetToLeftOf(int offset)", "public int getOffsetToRightOf(int offset)", "private int getOffsetToLeftRightOf(int caret, boolean toLeft)", "private int getOffsetAtStartOf(int offset)", "public boolean shouldClampCursor(int line)", "public void getCursorPath(final int point, final Path dest, final CharSequence editingBuffer)", "private void addSelection(int line, int start, int end, int top, int bottom, SelectionRectangleConsumer consumer)", "public void getSelectionPath(int start, int end, Path dest)", "public final void getSelection(int start, int end, final SelectionRectangleConsumer consumer)", "public final Alignment getParagraphAlignment(int line)", "public final int getParagraphLeft(int line)", "public final int getParagraphRight(int line)", "private int getParagraphLeadingMargin(int line)", "private static float measurePara(TextPaint paint, CharSequence text, int start, int end, TextDirectionHeuristic textDir, boolean useBoundsForWidth)", " static float nextTab(CharSequence text, int start, int end, float h, Object[] tabs)", "protected final boolean isSpanned()", " static T[] getParagraphSpans(Spanned text, int start, int end, Class<T> type)", "private void ellipsize(int start, int end, int line, char[] dest, int destoff, TextUtils.TruncateAt method)", "public abstract int getEllipsisStart(int line)", "public abstract int getEllipsisCount(int line)", "public final CharSequence getText()", "public final TextPaint getPaint()", "public final int getWidth()", "public final Alignment getAlignment()", "public final TextDirectionHeuristic getTextDirectionHeuristic()", "public final float getSpacingMultiplier()", "public final float getLineSpacingMultiplier()", "public final float getSpacingAdd()", "public final float getLineSpacingAmount()", "public final boolean isFontPaddingIncluded()", "public boolean isFallbackLineSpacingEnabled()", "public int getEllipsizedWidth()", "public final TextUtils.TruncateAt getEllipsize()", "public final int getMaxLines()", "public final int getBreakStrategy()", "public final int getHyphenationFrequency()", "public final int[] getLeftIndents()", "public final int[] getRightIndents()", "public final int getJustificationMode()", "public LineBreakConfig getLineBreakConfig()", "public boolean getUseBoundsForWidth()", "public boolean getShiftDrawingOffsetForStartOverhang()", "public Paint.FontMetrics getMinimumFontMetrics()" ],
  "variableNames" : [ "HIGH_CONTRAST_TEXT_BORDER_WIDTH_MIN_PX", "HIGH_CONTRAST_TEXT_BORDER_WIDTH_FACTOR", "BREAK_STRATEGY_SIMPLE", "BREAK_STRATEGY_HIGH_QUALITY", "BREAK_STRATEGY_BALANCED", "HYPHENATION_FREQUENCY_NONE", "HYPHENATION_FREQUENCY_NORMAL", "HYPHENATION_FREQUENCY_FULL", "HYPHENATION_FREQUENCY_NORMAL_FAST", "HYPHENATION_FREQUENCY_FULL_FAST", "NO_PARA_SPANS", "JUSTIFICATION_MODE_NONE", "JUSTIFICATION_MODE_INTER_WORD", "JUSTIFICATION_MODE_INTER_CHARACTER", "DEFAULT_LINESPACING_MULTIPLIER", "DEFAULT_LINESPACING_ADDITION", "INCLUSION_STRATEGY_ANY_OVERLAP", "INCLUSION_STRATEGY_CONTAINS_CENTER", "INCLUSION_STRATEGY_CONTAINS_ALL", "mText", "mPaint", "mWorkPaint", "mWorkPlainPaint", "mWidth", "mAlignment", "mSpacingMult", "mSpacingAdd", "sTempRect", "mSpannedText", "mTextDir", "mLineBackgroundSpans", "mIncludePad", "mFallbackLineSpacing", "mEllipsizedWidth", "mEllipsize", "mMaxLines", "mBreakStrategy", "mHyphenationFrequency", "mLeftIndents", "mRightIndents", "mJustificationMode", "mLineBreakConfig", "mUseBoundsForWidth", "mShiftDrawingOffsetForStartOverhang", "mMinimumFontMetrics", "mLineInfo", "DIR_LEFT_TO_RIGHT", "DIR_RIGHT_TO_LEFT", "DIR_REQUEST_LTR", "DIR_REQUEST_RTL", "DIR_REQUEST_DEFAULT_LTR", "DIR_REQUEST_DEFAULT_RTL", "RUN_LENGTH_MASK", "RUN_LEVEL_SHIFT", "RUN_LEVEL_MASK", "RUN_RTL_FLAG", "TAB_INCREMENT", "DIRS_ALL_LEFT_TO_RIGHT", "DIRS_ALL_RIGHT_TO_LEFT", "TEXT_SELECTION_LAYOUT_RIGHT_TO_LEFT", "TEXT_SELECTION_LAYOUT_LEFT_TO_RIGHT" ]
}