{
  "filePath" : "/home/maryam/clearblue/files/android-source-30/android/hardware/camera2/CaptureRequest.java",
  "packageName" : "android.hardware.camera2",
  "className" : "CaptureRequest",
  "comment" : "\n * <p>An immutable package of settings and outputs needed to capture a single\n * image from the camera device.</p>\n *\n * <p>Contains the configuration for the capture hardware (sensor, lens, flash),\n * the processing pipeline, the control algorithms, and the output buffers. Also\n * contains the list of target Surfaces to send image data to for this\n * capture.</p>\n *\n * <p>CaptureRequests can be created by using a {@link Builder} instance,\n * obtained by calling {@link CameraDevice#createCaptureRequest}</p>\n *\n * <p>CaptureRequests are given to {@link CameraCaptureSession#capture} or\n * {@link CameraCaptureSession#setRepeatingRequest} to capture images from a camera.</p>\n *\n * <p>Each request can specify a different subset of target Surfaces for the\n * camera to send the captured data to. All the surfaces used in a request must\n * be part of the surface list given to the last call to\n * {@link CameraDevice#createCaptureSession}, when the request is submitted to the\n * session.</p>\n *\n * <p>For example, a request meant for repeating preview might only include the\n * Surface for the preview SurfaceView or SurfaceTexture, while a\n * high-resolution still capture would also include a Surface from a ImageReader\n * configured for high-resolution JPEG images.</p>\n *\n * <p>A reprocess capture request allows a previously-captured image from the camera device to be\n * sent back to the device for further processing. It can be created with\n * {@link CameraDevice#createReprocessCaptureRequest}, and used with a reprocessable capture session\n * created with {@link CameraDevice#createReprocessableCaptureSession}.</p>\n *\n * @see CameraCaptureSession#capture\n * @see CameraCaptureSession#setRepeatingRequest\n * @see CameraCaptureSession#captureBurst\n * @see CameraCaptureSession#setRepeatingBurst\n * @see CameraDevice#createCaptureRequest\n * @see CameraDevice#createReprocessCaptureRequest\n ",
  "variables" : [ {
    "name" : "TAG",
    "type" : "String",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mSurfaceSet",
    "type" : "ArraySet<Surface>",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mSurfacesLock",
    "type" : "Object",
    "comment" : " to reset the capture request back to its original state.",
    "links" : [ ]
  }, {
    "name" : "mSurfaceConverted",
    "type" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mStreamIdxArray",
    "type" : "int[]",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mSurfaceIdxArray",
    "type" : "int[]",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mEmptySurfaceSet",
    "type" : "ArraySet<Surface>",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mLogicalCameraId",
    "type" : "String",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mLogicalCameraSettings",
    "type" : "CameraMetadataNative",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mPhysicalCameraSettings",
    "type" : "HashMap<String, CameraMetadataNative>",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mIsReprocess",
    "type" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "REQUEST_TYPE_REGULAR",
    "type" : "int",
    "comment" : "\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "REQUEST_TYPE_REPROCESS",
    "type" : "int",
    "comment" : "\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "REQUEST_TYPE_ZSL_STILL",
    "type" : "int",
    "comment" : "\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "REQUEST_TYPE_COUNT",
    "type" : "int",
    "comment" : "\n     * Note: To add another request type, the FrameNumberTracker in CameraDeviceImpl must be\n     * adjusted accordingly.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "mRequestType",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mIsPartOfCHSRequestList",
    "type" : "boolean",
    "comment" : " {@link android.hardware.camera2.CameraConstrainedHighSpeedCaptureSession#createHighSpeedRequestList}",
    "links" : [ "android.hardware.camera2.CameraConstrainedHighSpeedCaptureSession#createHighSpeedRequestList" ]
  }, {
    "name" : "mReprocessableSessionId",
    "type" : "int",
    "comment" : " Valid only for reprocess requests (mIsReprocess == true).",
    "links" : [ ]
  }, {
    "name" : "mUserTag",
    "type" : "Object",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "CREATOR",
    "type" : "Parcelable.Creator<CaptureRequest>",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "COLOR_CORRECTION_MODE",
    "type" : "Key<Integer>",
    "comment" : "\n     * <p>The mode control selects how the image data is converted from the\n     * sensor's native color into linear sRGB color.</p>\n     * <p>When auto-white balance (AWB) is enabled with {@link CaptureRequest#CONTROL_AWB_MODE android.control.awbMode}, this\n     * control is overridden by the AWB routine. When AWB is disabled, the\n     * application controls how the color mapping is performed.</p>\n     * <p>We define the expected processing pipeline below. For consistency\n     * across devices, this is always the case with TRANSFORM_MATRIX.</p>\n     * <p>When either FAST or HIGH_QUALITY is used, the camera device may\n     * do additional processing but {@link CaptureRequest#COLOR_CORRECTION_GAINS android.colorCorrection.gains} and\n     * {@link CaptureRequest#COLOR_CORRECTION_TRANSFORM android.colorCorrection.transform} will still be provided by the\n     * camera device (in the results) and be roughly correct.</p>\n     * <p>Switching to TRANSFORM_MATRIX and using the data provided from\n     * FAST or HIGH_QUALITY will yield a picture with the same white point\n     * as what was produced by the camera device in the earlier frame.</p>\n     * <p>The expected processing pipeline is as follows:</p>\n     * <p><img alt=\"White balance processing pipeline\" src=\"/reference/images/camera2/metadata/android.colorCorrection.mode/processing_pipeline.png\" /></p>\n     * <p>The white balance is encoded by two values, a 4-channel white-balance\n     * gain vector (applied in the Bayer domain), and a 3x3 color transform\n     * matrix (applied after demosaic).</p>\n     * <p>The 4-channel white-balance gains are defined as:</p>\n     * <pre><code>{@link CaptureRequest#COLOR_CORRECTION_GAINS android.colorCorrection.gains} = [ R G_even G_odd B ]\n     * </code></pre>\n     * <p>where <code>G_even</code> is the gain for green pixels on even rows of the\n     * output, and <code>G_odd</code> is the gain for green pixels on the odd rows.\n     * These may be identical for a given camera device implementation; if\n     * the camera device does not support a separate gain for even/odd green\n     * channels, it will use the <code>G_even</code> value, and write <code>G_odd</code> equal to\n     * <code>G_even</code> in the output result metadata.</p>\n     * <p>The matrices for color transforms are defined as a 9-entry vector:</p>\n     * <pre><code>{@link CaptureRequest#COLOR_CORRECTION_TRANSFORM android.colorCorrection.transform} = [ I0 I1 I2 I3 I4 I5 I6 I7 I8 ]\n     * </code></pre>\n     * <p>which define a transform from input sensor colors, <code>P_in = [ r g b ]</code>,\n     * to output linear sRGB, <code>P_out = [ r' g' b' ]</code>,</p>\n     * <p>with colors as follows:</p>\n     * <pre><code>r' = I0r + I1g + I2b\n     * g' = I3r + I4g + I5b\n     * b' = I6r + I7g + I8b\n     * </code></pre>\n     * <p>Both the input and output value ranges must match. Overflow/underflow\n     * values are clipped to fit within the range.</p>\n     * <p><b>Possible values:</b>\n     * <ul>\n     *   <li>{@link #COLOR_CORRECTION_MODE_TRANSFORM_MATRIX TRANSFORM_MATRIX}</li>\n     *   <li>{@link #COLOR_CORRECTION_MODE_FAST FAST}</li>\n     *   <li>{@link #COLOR_CORRECTION_MODE_HIGH_QUALITY HIGH_QUALITY}</li>\n     * </ul></p>\n     * <p><b>Optional</b> - The value for this key may be {@code null} on some devices.</p>\n     * <p><b>Full capability</b> -\n     * Present on all camera devices that report being {@link CameraCharacteristics#INFO_SUPPORTED_HARDWARE_LEVEL_FULL HARDWARE_LEVEL_FULL} devices in the\n     * {@link CameraCharacteristics#INFO_SUPPORTED_HARDWARE_LEVEL android.info.supportedHardwareLevel} key</p>\n     *\n     * @see CaptureRequest#COLOR_CORRECTION_GAINS\n     * @see CaptureRequest#COLOR_CORRECTION_TRANSFORM\n     * @see CaptureRequest#CONTROL_AWB_MODE\n     * @see CameraCharacteristics#INFO_SUPPORTED_HARDWARE_LEVEL\n     * @see #COLOR_CORRECTION_MODE_TRANSFORM_MATRIX\n     * @see #COLOR_CORRECTION_MODE_FAST\n     * @see #COLOR_CORRECTION_MODE_HIGH_QUALITY\n     ",
    "links" : [ "CaptureRequest#CONTROL_AWB_MODE", "CaptureRequest#COLOR_CORRECTION_GAINS", "CaptureRequest#COLOR_CORRECTION_TRANSFORM", "CaptureRequest#COLOR_CORRECTION_GAINS", "CaptureRequest#COLOR_CORRECTION_TRANSFORM", "#COLOR_CORRECTION_MODE_TRANSFORM_MATRIX", "#COLOR_CORRECTION_MODE_FAST", "#COLOR_CORRECTION_MODE_HIGH_QUALITY", "CameraCharacteristics#INFO_SUPPORTED_HARDWARE_LEVEL_FULL", "CameraCharacteristics#INFO_SUPPORTED_HARDWARE_LEVEL" ]
  }, {
    "name" : "COLOR_CORRECTION_TRANSFORM",
    "type" : "Key<android.hardware.camera2.params.ColorSpaceTransform>",
    "comment" : "\n     * <p>A color transform matrix to use to transform\n     * from sensor RGB color space to output linear sRGB color space.</p>\n     * <p>This matrix is either set by the camera device when the request\n     * {@link CaptureRequest#COLOR_CORRECTION_MODE android.colorCorrection.mode} is not TRANSFORM_MATRIX, or\n     * directly by the application in the request when the\n     * {@link CaptureRequest#COLOR_CORRECTION_MODE android.colorCorrection.mode} is TRANSFORM_MATRIX.</p>\n     * <p>In the latter case, the camera device may round the matrix to account\n     * for precision issues; the final rounded matrix should be reported back\n     * in this matrix result metadata. The transform should keep the magnitude\n     * of the output color values within <code>[0, 1.0]</code> (assuming input color\n     * values is within the normalized range <code>[0, 1.0]</code>), or clipping may occur.</p>\n     * <p>The valid range of each matrix element varies on different devices, but\n     * values within [-1.5, 3.0] are guaranteed not to be clipped.</p>\n     * <p><b>Units</b>: Unitless scale factors</p>\n     * <p><b>Optional</b> - The value for this key may be {@code null} on some devices.</p>\n     * <p><b>Full capability</b> -\n     * Present on all camera devices that report being {@link CameraCharacteristics#INFO_SUPPORTED_HARDWARE_LEVEL_FULL HARDWARE_LEVEL_FULL} devices in the\n     * {@link CameraCharacteristics#INFO_SUPPORTED_HARDWARE_LEVEL android.info.supportedHardwareLevel} key</p>\n     *\n     * @see CaptureRequest#COLOR_CORRECTION_MODE\n     * @see CameraCharacteristics#INFO_SUPPORTED_HARDWARE_LEVEL\n     ",
    "links" : [ "CaptureRequest#COLOR_CORRECTION_MODE", "CaptureRequest#COLOR_CORRECTION_MODE", "CameraCharacteristics#INFO_SUPPORTED_HARDWARE_LEVEL_FULL", "CameraCharacteristics#INFO_SUPPORTED_HARDWARE_LEVEL" ]
  }, {
    "name" : "COLOR_CORRECTION_GAINS",
    "type" : "Key<android.hardware.camera2.params.RggbChannelVector>",
    "comment" : "\n     * <p>Gains applying to Bayer raw color channels for\n     * white-balance.</p>\n     * <p>These per-channel gains are either set by the camera device\n     * when the request {@link CaptureRequest#COLOR_CORRECTION_MODE android.colorCorrection.mode} is not\n     * TRANSFORM_MATRIX, or directly by the application in the\n     * request when the {@link CaptureRequest#COLOR_CORRECTION_MODE android.colorCorrection.mode} is\n     * TRANSFORM_MATRIX.</p>\n     * <p>The gains in the result metadata are the gains actually\n     * applied by the camera device to the current frame.</p>\n     * <p>The valid range of gains varies on different devices, but gains\n     * between [1.0, 3.0] are guaranteed not to be clipped. Even if a given\n     * device allows gains below 1.0, this is usually not recommended because\n     * this can create color artifacts.</p>\n     * <p><b>Units</b>: Unitless gain factors</p>\n     * <p><b>Optional</b> - The value for this key may be {@code null} on some devices.</p>\n     * <p><b>Full capability</b> -\n     * Present on all camera devices that report being {@link CameraCharacteristics#INFO_SUPPORTED_HARDWARE_LEVEL_FULL HARDWARE_LEVEL_FULL} devices in the\n     * {@link CameraCharacteristics#INFO_SUPPORTED_HARDWARE_LEVEL android.info.supportedHardwareLevel} key</p>\n     *\n     * @see CaptureRequest#COLOR_CORRECTION_MODE\n     * @see CameraCharacteristics#INFO_SUPPORTED_HARDWARE_LEVEL\n     ",
    "links" : [ "CaptureRequest#COLOR_CORRECTION_MODE", "CaptureRequest#COLOR_CORRECTION_MODE", "CameraCharacteristics#INFO_SUPPORTED_HARDWARE_LEVEL_FULL", "CameraCharacteristics#INFO_SUPPORTED_HARDWARE_LEVEL" ]
  }, {
    "name" : "COLOR_CORRECTION_ABERRATION_MODE",
    "type" : "Key<Integer>",
    "comment" : "\n     * <p>Mode of operation for the chromatic aberration correction algorithm.</p>\n     * <p>Chromatic (color) aberration is caused by the fact that different wavelengths of light\n     * can not focus on the same point after exiting from the lens. This metadata defines\n     * the high level control of chromatic aberration correction algorithm, which aims to\n     * minimize the chromatic artifacts that may occur along the object boundaries in an\n     * image.</p>\n     * <p>FAST/HIGH_QUALITY both mean that camera device determined aberration\n     * correction will be applied. HIGH_QUALITY mode indicates that the camera device will\n     * use the highest-quality aberration correction algorithms, even if it slows down\n     * capture rate. FAST means the camera device will not slow down capture rate when\n     * applying aberration correction.</p>\n     * <p>LEGACY devices will always be in FAST mode.</p>\n     * <p><b>Possible values:</b>\n     * <ul>\n     *   <li>{@link #COLOR_CORRECTION_ABERRATION_MODE_OFF OFF}</li>\n     *   <li>{@link #COLOR_CORRECTION_ABERRATION_MODE_FAST FAST}</li>\n     *   <li>{@link #COLOR_CORRECTION_ABERRATION_MODE_HIGH_QUALITY HIGH_QUALITY}</li>\n     * </ul></p>\n     * <p><b>Available values for this device:</b><br>\n     * {@link CameraCharacteristics#COLOR_CORRECTION_AVAILABLE_ABERRATION_MODES android.colorCorrection.availableAberrationModes}</p>\n     * <p>This key is available on all devices.</p>\n     *\n     * @see CameraCharacteristics#COLOR_CORRECTION_AVAILABLE_ABERRATION_MODES\n     * @see #COLOR_CORRECTION_ABERRATION_MODE_OFF\n     * @see #COLOR_CORRECTION_ABERRATION_MODE_FAST\n     * @see #COLOR_CORRECTION_ABERRATION_MODE_HIGH_QUALITY\n     ",
    "links" : [ "#COLOR_CORRECTION_ABERRATION_MODE_OFF", "#COLOR_CORRECTION_ABERRATION_MODE_FAST", "#COLOR_CORRECTION_ABERRATION_MODE_HIGH_QUALITY", "CameraCharacteristics#COLOR_CORRECTION_AVAILABLE_ABERRATION_MODES" ]
  }, {
    "name" : "CONTROL_AE_ANTIBANDING_MODE",
    "type" : "Key<Integer>",
    "comment" : "\n     * <p>The desired setting for the camera device's auto-exposure\n     * algorithm's antibanding compensation.</p>\n     * <p>Some kinds of lighting fixtures, such as some fluorescent\n     * lights, flicker at the rate of the power supply frequency\n     * (60Hz or 50Hz, depending on country). While this is\n     * typically not noticeable to a person, it can be visible to\n     * a camera device. If a camera sets its exposure time to the\n     * wrong value, the flicker may become visible in the\n     * viewfinder as flicker or in a final captured image, as a\n     * set of variable-brightness bands across the image.</p>\n     * <p>Therefore, the auto-exposure routines of camera devices\n     * include antibanding routines that ensure that the chosen\n     * exposure value will not cause such banding. The choice of\n     * exposure time depends on the rate of flicker, which the\n     * camera device can detect automatically, or the expected\n     * rate can be selected by the application using this\n     * control.</p>\n     * <p>A given camera device may not support all of the possible\n     * options for the antibanding mode. The\n     * {@link CameraCharacteristics#CONTROL_AE_AVAILABLE_ANTIBANDING_MODES android.control.aeAvailableAntibandingModes} key contains\n     * the available modes for a given camera device.</p>\n     * <p>AUTO mode is the default if it is available on given\n     * camera device. When AUTO mode is not available, the\n     * default will be either 50HZ or 60HZ, and both 50HZ\n     * and 60HZ will be available.</p>\n     * <p>If manual exposure control is enabled (by setting\n     * {@link CaptureRequest#CONTROL_AE_MODE android.control.aeMode} or {@link CaptureRequest#CONTROL_MODE android.control.mode} to OFF),\n     * then this setting has no effect, and the application must\n     * ensure it selects exposure times that do not cause banding\n     * issues. The {@link CaptureResult#STATISTICS_SCENE_FLICKER android.statistics.sceneFlicker} key can assist\n     * the application in this.</p>\n     * <p><b>Possible values:</b>\n     * <ul>\n     *   <li>{@link #CONTROL_AE_ANTIBANDING_MODE_OFF OFF}</li>\n     *   <li>{@link #CONTROL_AE_ANTIBANDING_MODE_50HZ 50HZ}</li>\n     *   <li>{@link #CONTROL_AE_ANTIBANDING_MODE_60HZ 60HZ}</li>\n     *   <li>{@link #CONTROL_AE_ANTIBANDING_MODE_AUTO AUTO}</li>\n     * </ul></p>\n     * <p><b>Available values for this device:</b><br></p>\n     * <p>{@link CameraCharacteristics#CONTROL_AE_AVAILABLE_ANTIBANDING_MODES android.control.aeAvailableAntibandingModes}</p>\n     * <p>This key is available on all devices.</p>\n     *\n     * @see CameraCharacteristics#CONTROL_AE_AVAILABLE_ANTIBANDING_MODES\n     * @see CaptureRequest#CONTROL_AE_MODE\n     * @see CaptureRequest#CONTROL_MODE\n     * @see CaptureResult#STATISTICS_SCENE_FLICKER\n     * @see #CONTROL_AE_ANTIBANDING_MODE_OFF\n     * @see #CONTROL_AE_ANTIBANDING_MODE_50HZ\n     * @see #CONTROL_AE_ANTIBANDING_MODE_60HZ\n     * @see #CONTROL_AE_ANTIBANDING_MODE_AUTO\n     ",
    "links" : [ "CameraCharacteristics#CONTROL_AE_AVAILABLE_ANTIBANDING_MODES", "CaptureRequest#CONTROL_AE_MODE", "CaptureRequest#CONTROL_MODE", "CaptureResult#STATISTICS_SCENE_FLICKER", "#CONTROL_AE_ANTIBANDING_MODE_OFF", "#CONTROL_AE_ANTIBANDING_MODE_50HZ", "#CONTROL_AE_ANTIBANDING_MODE_60HZ", "#CONTROL_AE_ANTIBANDING_MODE_AUTO", "CameraCharacteristics#CONTROL_AE_AVAILABLE_ANTIBANDING_MODES" ]
  }, {
    "name" : "CONTROL_AE_EXPOSURE_COMPENSATION",
    "type" : "Key<Integer>",
    "comment" : "\n     * <p>Adjustment to auto-exposure (AE) target image\n     * brightness.</p>\n     * <p>The adjustment is measured as a count of steps, with the\n     * step size defined by {@link CameraCharacteristics#CONTROL_AE_COMPENSATION_STEP android.control.aeCompensationStep} and the\n     * allowed range by {@link CameraCharacteristics#CONTROL_AE_COMPENSATION_RANGE android.control.aeCompensationRange}.</p>\n     * <p>For example, if the exposure value (EV) step is 0.333, '6'\n     * will mean an exposure compensation of +2 EV; -3 will mean an\n     * exposure compensation of -1 EV. One EV represents a doubling\n     * of image brightness. Note that this control will only be\n     * effective if {@link CaptureRequest#CONTROL_AE_MODE android.control.aeMode} <code>!=</code> OFF. This control\n     * will take effect even when {@link CaptureRequest#CONTROL_AE_LOCK android.control.aeLock} <code>== true</code>.</p>\n     * <p>In the event of exposure compensation value being changed, camera device\n     * may take several frames to reach the newly requested exposure target.\n     * During that time, {@link CaptureResult#CONTROL_AE_STATE android.control.aeState} field will be in the SEARCHING\n     * state. Once the new exposure target is reached, {@link CaptureResult#CONTROL_AE_STATE android.control.aeState} will\n     * change from SEARCHING to either CONVERGED, LOCKED (if AE lock is enabled), or\n     * FLASH_REQUIRED (if the scene is too dark for still capture).</p>\n     * <p><b>Units</b>: Compensation steps</p>\n     * <p><b>Range of valid values:</b><br>\n     * {@link CameraCharacteristics#CONTROL_AE_COMPENSATION_RANGE android.control.aeCompensationRange}</p>\n     * <p>This key is available on all devices.</p>\n     *\n     * @see CameraCharacteristics#CONTROL_AE_COMPENSATION_RANGE\n     * @see CameraCharacteristics#CONTROL_AE_COMPENSATION_STEP\n     * @see CaptureRequest#CONTROL_AE_LOCK\n     * @see CaptureRequest#CONTROL_AE_MODE\n     * @see CaptureResult#CONTROL_AE_STATE\n     ",
    "links" : [ "CameraCharacteristics#CONTROL_AE_COMPENSATION_STEP", "CameraCharacteristics#CONTROL_AE_COMPENSATION_RANGE", "CaptureRequest#CONTROL_AE_MODE", "CaptureRequest#CONTROL_AE_LOCK", "CaptureResult#CONTROL_AE_STATE", "CaptureResult#CONTROL_AE_STATE", "CameraCharacteristics#CONTROL_AE_COMPENSATION_RANGE" ]
  }, {
    "name" : "CONTROL_AE_LOCK",
    "type" : "Key<Boolean>",
    "comment" : "\n     * <p>Whether auto-exposure (AE) is currently locked to its latest\n     * calculated values.</p>\n     * <p>When set to <code>true</code> (ON), the AE algorithm is locked to its latest parameters,\n     * and will not change exposure settings until the lock is set to <code>false</code> (OFF).</p>\n     * <p>Note that even when AE is locked, the flash may be fired if\n     * the {@link CaptureRequest#CONTROL_AE_MODE android.control.aeMode} is ON_AUTO_FLASH /\n     * ON_ALWAYS_FLASH / ON_AUTO_FLASH_REDEYE.</p>\n     * <p>When {@link CaptureRequest#CONTROL_AE_EXPOSURE_COMPENSATION android.control.aeExposureCompensation} is changed, even if the AE lock\n     * is ON, the camera device will still adjust its exposure value.</p>\n     * <p>If AE precapture is triggered (see {@link CaptureRequest#CONTROL_AE_PRECAPTURE_TRIGGER android.control.aePrecaptureTrigger})\n     * when AE is already locked, the camera device will not change the exposure time\n     * ({@link CaptureRequest#SENSOR_EXPOSURE_TIME android.sensor.exposureTime}) and sensitivity ({@link CaptureRequest#SENSOR_SENSITIVITY android.sensor.sensitivity})\n     * parameters. The flash may be fired if the {@link CaptureRequest#CONTROL_AE_MODE android.control.aeMode}\n     * is ON_AUTO_FLASH/ON_AUTO_FLASH_REDEYE and the scene is too dark. If the\n     * {@link CaptureRequest#CONTROL_AE_MODE android.control.aeMode} is ON_ALWAYS_FLASH, the scene may become overexposed.\n     * Similarly, AE precapture trigger CANCEL has no effect when AE is already locked.</p>\n     * <p>When an AE precapture sequence is triggered, AE unlock will not be able to unlock\n     * the AE if AE is locked by the camera device internally during precapture metering\n     * sequence In other words, submitting requests with AE unlock has no effect for an\n     * ongoing precapture metering sequence. Otherwise, the precapture metering sequence\n     * will never succeed in a sequence of preview requests where AE lock is always set\n     * to <code>false</code>.</p>\n     * <p>Since the camera device has a pipeline of in-flight requests, the settings that\n     * get locked do not necessarily correspond to the settings that were present in the\n     * latest capture result received from the camera device, since additional captures\n     * and AE updates may have occurred even before the result was sent out. If an\n     * application is switching between automatic and manual control and wishes to eliminate\n     * any flicker during the switch, the following procedure is recommended:</p>\n     * <ol>\n     * <li>Starting in auto-AE mode:</li>\n     * <li>Lock AE</li>\n     * <li>Wait for the first result to be output that has the AE locked</li>\n     * <li>Copy exposure settings from that result into a request, set the request to manual AE</li>\n     * <li>Submit the capture request, proceed to run manual AE as desired.</li>\n     * </ol>\n     * <p>See {@link CaptureResult#CONTROL_AE_STATE android.control.aeState} for AE lock related state transition details.</p>\n     * <p>This key is available on all devices.</p>\n     *\n     * @see CaptureRequest#CONTROL_AE_EXPOSURE_COMPENSATION\n     * @see CaptureRequest#CONTROL_AE_MODE\n     * @see CaptureRequest#CONTROL_AE_PRECAPTURE_TRIGGER\n     * @see CaptureResult#CONTROL_AE_STATE\n     * @see CaptureRequest#SENSOR_EXPOSURE_TIME\n     * @see CaptureRequest#SENSOR_SENSITIVITY\n     ",
    "links" : [ "CaptureRequest#CONTROL_AE_MODE", "CaptureRequest#CONTROL_AE_EXPOSURE_COMPENSATION", "CaptureRequest#CONTROL_AE_PRECAPTURE_TRIGGER", "CaptureRequest#SENSOR_EXPOSURE_TIME", "CaptureRequest#SENSOR_SENSITIVITY", "CaptureRequest#CONTROL_AE_MODE", "CaptureRequest#CONTROL_AE_MODE", "CaptureResult#CONTROL_AE_STATE" ]
  }, {
    "name" : "CONTROL_AE_MODE",
    "type" : "Key<Integer>",
    "comment" : "\n     * <p>The desired mode for the camera device's\n     * auto-exposure routine.</p>\n     * <p>This control is only effective if {@link CaptureRequest#CONTROL_MODE android.control.mode} is\n     * AUTO.</p>\n     * <p>When set to any of the ON modes, the camera device's\n     * auto-exposure routine is enabled, overriding the\n     * application's selected exposure time, sensor sensitivity,\n     * and frame duration ({@link CaptureRequest#SENSOR_EXPOSURE_TIME android.sensor.exposureTime},\n     * {@link CaptureRequest#SENSOR_SENSITIVITY android.sensor.sensitivity}, and\n     * {@link CaptureRequest#SENSOR_FRAME_DURATION android.sensor.frameDuration}). If one of the FLASH modes\n     * is selected, the camera device's flash unit controls are\n     * also overridden.</p>\n     * <p>The FLASH modes are only available if the camera device\n     * has a flash unit ({@link CameraCharacteristics#FLASH_INFO_AVAILABLE android.flash.info.available} is <code>true</code>).</p>\n     * <p>If flash TORCH mode is desired, this field must be set to\n     * ON or OFF, and {@link CaptureRequest#FLASH_MODE android.flash.mode} set to TORCH.</p>\n     * <p>When set to any of the ON modes, the values chosen by the\n     * camera device auto-exposure routine for the overridden\n     * fields for a given capture will be available in its\n     * CaptureResult.</p>\n     * <p><b>Possible values:</b>\n     * <ul>\n     *   <li>{@link #CONTROL_AE_MODE_OFF OFF}</li>\n     *   <li>{@link #CONTROL_AE_MODE_ON ON}</li>\n     *   <li>{@link #CONTROL_AE_MODE_ON_AUTO_FLASH ON_AUTO_FLASH}</li>\n     *   <li>{@link #CONTROL_AE_MODE_ON_ALWAYS_FLASH ON_ALWAYS_FLASH}</li>\n     *   <li>{@link #CONTROL_AE_MODE_ON_AUTO_FLASH_REDEYE ON_AUTO_FLASH_REDEYE}</li>\n     *   <li>{@link #CONTROL_AE_MODE_ON_EXTERNAL_FLASH ON_EXTERNAL_FLASH}</li>\n     * </ul></p>\n     * <p><b>Available values for this device:</b><br>\n     * {@link CameraCharacteristics#CONTROL_AE_AVAILABLE_MODES android.control.aeAvailableModes}</p>\n     * <p>This key is available on all devices.</p>\n     *\n     * @see CameraCharacteristics#CONTROL_AE_AVAILABLE_MODES\n     * @see CaptureRequest#CONTROL_MODE\n     * @see CameraCharacteristics#FLASH_INFO_AVAILABLE\n     * @see CaptureRequest#FLASH_MODE\n     * @see CaptureRequest#SENSOR_EXPOSURE_TIME\n     * @see CaptureRequest#SENSOR_FRAME_DURATION\n     * @see CaptureRequest#SENSOR_SENSITIVITY\n     * @see #CONTROL_AE_MODE_OFF\n     * @see #CONTROL_AE_MODE_ON\n     * @see #CONTROL_AE_MODE_ON_AUTO_FLASH\n     * @see #CONTROL_AE_MODE_ON_ALWAYS_FLASH\n     * @see #CONTROL_AE_MODE_ON_AUTO_FLASH_REDEYE\n     * @see #CONTROL_AE_MODE_ON_EXTERNAL_FLASH\n     ",
    "links" : [ "CaptureRequest#CONTROL_MODE", "CaptureRequest#SENSOR_EXPOSURE_TIME", "CaptureRequest#SENSOR_SENSITIVITY", "CaptureRequest#SENSOR_FRAME_DURATION", "CameraCharacteristics#FLASH_INFO_AVAILABLE", "CaptureRequest#FLASH_MODE", "#CONTROL_AE_MODE_OFF", "#CONTROL_AE_MODE_ON", "#CONTROL_AE_MODE_ON_AUTO_FLASH", "#CONTROL_AE_MODE_ON_ALWAYS_FLASH", "#CONTROL_AE_MODE_ON_AUTO_FLASH_REDEYE", "#CONTROL_AE_MODE_ON_EXTERNAL_FLASH", "CameraCharacteristics#CONTROL_AE_AVAILABLE_MODES" ]
  }, {
    "name" : "CONTROL_AE_REGIONS",
    "type" : "Key<android.hardware.camera2.params.MeteringRectangle[]>",
    "comment" : "\n     * <p>List of metering areas to use for auto-exposure adjustment.</p>\n     * <p>Not available if {@link CameraCharacteristics#CONTROL_MAX_REGIONS_AE android.control.maxRegionsAe} is 0.\n     * Otherwise will always be present.</p>\n     * <p>The maximum number of regions supported by the device is determined by the value\n     * of {@link CameraCharacteristics#CONTROL_MAX_REGIONS_AE android.control.maxRegionsAe}.</p>\n     * <p>For devices not supporting {@link CaptureRequest#DISTORTION_CORRECTION_MODE android.distortionCorrection.mode} control, the coordinate\n     * system always follows that of {@link CameraCharacteristics#SENSOR_INFO_ACTIVE_ARRAY_SIZE android.sensor.info.activeArraySize}, with (0,0) being\n     * the top-left pixel in the active pixel array, and\n     * ({@link CameraCharacteristics#SENSOR_INFO_ACTIVE_ARRAY_SIZE android.sensor.info.activeArraySize}.width - 1,\n     * {@link CameraCharacteristics#SENSOR_INFO_ACTIVE_ARRAY_SIZE android.sensor.info.activeArraySize}.height - 1) being the bottom-right pixel in the\n     * active pixel array.</p>\n     * <p>For devices supporting {@link CaptureRequest#DISTORTION_CORRECTION_MODE android.distortionCorrection.mode} control, the coordinate\n     * system depends on the mode being set.\n     * When the distortion correction mode is OFF, the coordinate system follows\n     * {@link CameraCharacteristics#SENSOR_INFO_PRE_CORRECTION_ACTIVE_ARRAY_SIZE android.sensor.info.preCorrectionActiveArraySize}, with\n     * <code>(0, 0)</code> being the top-left pixel of the pre-correction active array, and\n     * ({@link CameraCharacteristics#SENSOR_INFO_PRE_CORRECTION_ACTIVE_ARRAY_SIZE android.sensor.info.preCorrectionActiveArraySize}.width - 1,\n     * {@link CameraCharacteristics#SENSOR_INFO_PRE_CORRECTION_ACTIVE_ARRAY_SIZE android.sensor.info.preCorrectionActiveArraySize}.height - 1) being the bottom-right\n     * pixel in the pre-correction active pixel array.\n     * When the distortion correction mode is not OFF, the coordinate system follows\n     * {@link CameraCharacteristics#SENSOR_INFO_ACTIVE_ARRAY_SIZE android.sensor.info.activeArraySize}, with\n     * <code>(0, 0)</code> being the top-left pixel of the active array, and\n     * ({@link CameraCharacteristics#SENSOR_INFO_ACTIVE_ARRAY_SIZE android.sensor.info.activeArraySize}.width - 1,\n     * {@link CameraCharacteristics#SENSOR_INFO_ACTIVE_ARRAY_SIZE android.sensor.info.activeArraySize}.height - 1) being the bottom-right pixel in the\n     * active pixel array.</p>\n     * <p>The weight must be within <code>[0, 1000]</code>, and represents a weight\n     * for every pixel in the area. This means that a large metering area\n     * with the same weight as a smaller area will have more effect in\n     * the metering result. Metering areas can partially overlap and the\n     * camera device will add the weights in the overlap region.</p>\n     * <p>The weights are relative to weights of other exposure metering regions, so if only one\n     * region is used, all non-zero weights will have the same effect. A region with 0\n     * weight is ignored.</p>\n     * <p>If all regions have 0 weight, then no specific metering area needs to be used by the\n     * camera device.</p>\n     * <p>If the metering region is outside the used {@link CaptureRequest#SCALER_CROP_REGION android.scaler.cropRegion} returned in\n     * capture result metadata, the camera device will ignore the sections outside the crop\n     * region and output only the intersection rectangle as the metering region in the result\n     * metadata.  If the region is entirely outside the crop region, it will be ignored and\n     * not reported in the result metadata.</p>\n     * <p>Starting from API level 30, the coordinate system of activeArraySize or\n     * preCorrectionActiveArraySize is used to represent post-zoomRatio field of view, not\n     * pre-zoom field of view. This means that the same aeRegions values at different\n     * {@link CaptureRequest#CONTROL_ZOOM_RATIO android.control.zoomRatio} represent different parts of the scene. The aeRegions\n     * coordinates are relative to the activeArray/preCorrectionActiveArray representing the\n     * zoomed field of view. If {@link CaptureRequest#CONTROL_ZOOM_RATIO android.control.zoomRatio} is set to 1.0 (default), the same\n     * aeRegions at different {@link CaptureRequest#SCALER_CROP_REGION android.scaler.cropRegion} still represent the same parts of the\n     * scene as they do before. See {@link CaptureRequest#CONTROL_ZOOM_RATIO android.control.zoomRatio} for details. Whether to use\n     * activeArraySize or preCorrectionActiveArraySize still depends on distortion correction\n     * mode.</p>\n     * <p><b>Units</b>: Pixel coordinates within {@link CameraCharacteristics#SENSOR_INFO_ACTIVE_ARRAY_SIZE android.sensor.info.activeArraySize} or\n     * {@link CameraCharacteristics#SENSOR_INFO_PRE_CORRECTION_ACTIVE_ARRAY_SIZE android.sensor.info.preCorrectionActiveArraySize} depending on\n     * distortion correction capability and mode</p>\n     * <p><b>Range of valid values:</b><br>\n     * Coordinates must be between <code>[(0,0), (width, height))</code> of\n     * {@link CameraCharacteristics#SENSOR_INFO_ACTIVE_ARRAY_SIZE android.sensor.info.activeArraySize} or {@link CameraCharacteristics#SENSOR_INFO_PRE_CORRECTION_ACTIVE_ARRAY_SIZE android.sensor.info.preCorrectionActiveArraySize}\n     * depending on distortion correction capability and mode</p>\n     * <p><b>Optional</b> - The value for this key may be {@code null} on some devices.</p>\n     *\n     * @see CameraCharacteristics#CONTROL_MAX_REGIONS_AE\n     * @see CaptureRequest#CONTROL_ZOOM_RATIO\n     * @see CaptureRequest#DISTORTION_CORRECTION_MODE\n     * @see CaptureRequest#SCALER_CROP_REGION\n     * @see CameraCharacteristics#SENSOR_INFO_ACTIVE_ARRAY_SIZE\n     * @see CameraCharacteristics#SENSOR_INFO_PRE_CORRECTION_ACTIVE_ARRAY_SIZE\n     ",
    "links" : [ "CameraCharacteristics#CONTROL_MAX_REGIONS_AE", "CameraCharacteristics#CONTROL_MAX_REGIONS_AE", "CaptureRequest#DISTORTION_CORRECTION_MODE", "CameraCharacteristics#SENSOR_INFO_ACTIVE_ARRAY_SIZE", "CameraCharacteristics#SENSOR_INFO_ACTIVE_ARRAY_SIZE", "CameraCharacteristics#SENSOR_INFO_ACTIVE_ARRAY_SIZE", "CaptureRequest#DISTORTION_CORRECTION_MODE", "CameraCharacteristics#SENSOR_INFO_PRE_CORRECTION_ACTIVE_ARRAY_SIZE", "CameraCharacteristics#SENSOR_INFO_PRE_CORRECTION_ACTIVE_ARRAY_SIZE", "CameraCharacteristics#SENSOR_INFO_PRE_CORRECTION_ACTIVE_ARRAY_SIZE", "CameraCharacteristics#SENSOR_INFO_ACTIVE_ARRAY_SIZE", "CameraCharacteristics#SENSOR_INFO_ACTIVE_ARRAY_SIZE", "CameraCharacteristics#SENSOR_INFO_ACTIVE_ARRAY_SIZE", "CaptureRequest#SCALER_CROP_REGION", "CaptureRequest#CONTROL_ZOOM_RATIO", "CaptureRequest#CONTROL_ZOOM_RATIO", "CaptureRequest#SCALER_CROP_REGION", "CaptureRequest#CONTROL_ZOOM_RATIO", "CameraCharacteristics#SENSOR_INFO_ACTIVE_ARRAY_SIZE", "CameraCharacteristics#SENSOR_INFO_PRE_CORRECTION_ACTIVE_ARRAY_SIZE", "CameraCharacteristics#SENSOR_INFO_ACTIVE_ARRAY_SIZE", "CameraCharacteristics#SENSOR_INFO_PRE_CORRECTION_ACTIVE_ARRAY_SIZE" ]
  }, {
    "name" : "CONTROL_AE_TARGET_FPS_RANGE",
    "type" : "Key<android.util.Range<Integer>>",
    "comment" : "\n     * <p>Range over which the auto-exposure routine can\n     * adjust the capture frame rate to maintain good\n     * exposure.</p>\n     * <p>Only constrains auto-exposure (AE) algorithm, not\n     * manual control of {@link CaptureRequest#SENSOR_EXPOSURE_TIME android.sensor.exposureTime} and\n     * {@link CaptureRequest#SENSOR_FRAME_DURATION android.sensor.frameDuration}.</p>\n     * <p><b>Units</b>: Frames per second (FPS)</p>\n     * <p><b>Range of valid values:</b><br>\n     * Any of the entries in {@link CameraCharacteristics#CONTROL_AE_AVAILABLE_TARGET_FPS_RANGES android.control.aeAvailableTargetFpsRanges}</p>\n     * <p>This key is available on all devices.</p>\n     *\n     * @see CameraCharacteristics#CONTROL_AE_AVAILABLE_TARGET_FPS_RANGES\n     * @see CaptureRequest#SENSOR_EXPOSURE_TIME\n     * @see CaptureRequest#SENSOR_FRAME_DURATION\n     ",
    "links" : [ "CaptureRequest#SENSOR_EXPOSURE_TIME", "CaptureRequest#SENSOR_FRAME_DURATION", "CameraCharacteristics#CONTROL_AE_AVAILABLE_TARGET_FPS_RANGES" ]
  }, {
    "name" : "CONTROL_AE_PRECAPTURE_TRIGGER",
    "type" : "Key<Integer>",
    "comment" : "\n     * <p>Whether the camera device will trigger a precapture\n     * metering sequence when it processes this request.</p>\n     * <p>This entry is normally set to IDLE, or is not\n     * included at all in the request settings. When included and\n     * set to START, the camera device will trigger the auto-exposure (AE)\n     * precapture metering sequence.</p>\n     * <p>When set to CANCEL, the camera device will cancel any active\n     * precapture metering trigger, and return to its initial AE state.\n     * If a precapture metering sequence is already completed, and the camera\n     * device has implicitly locked the AE for subsequent still capture, the\n     * CANCEL trigger will unlock the AE and return to its initial AE state.</p>\n     * <p>The precapture sequence should be triggered before starting a\n     * high-quality still capture for final metering decisions to\n     * be made, and for firing pre-capture flash pulses to estimate\n     * scene brightness and required final capture flash power, when\n     * the flash is enabled.</p>\n     * <p>Normally, this entry should be set to START for only a\n     * single request, and the application should wait until the\n     * sequence completes before starting a new one.</p>\n     * <p>When a precapture metering sequence is finished, the camera device\n     * may lock the auto-exposure routine internally to be able to accurately expose the\n     * subsequent still capture image (<code>{@link CaptureRequest#CONTROL_CAPTURE_INTENT android.control.captureIntent} == STILL_CAPTURE</code>).\n     * For this case, the AE may not resume normal scan if no subsequent still capture is\n     * submitted. To ensure that the AE routine restarts normal scan, the application should\n     * submit a request with <code>{@link CaptureRequest#CONTROL_AE_LOCK android.control.aeLock} == true</code>, followed by a request\n     * with <code>{@link CaptureRequest#CONTROL_AE_LOCK android.control.aeLock} == false</code>, if the application decides not to submit a\n     * still capture request after the precapture sequence completes. Alternatively, for\n     * API level 23 or newer devices, the CANCEL can be used to unlock the camera device\n     * internally locked AE if the application doesn't submit a still capture request after\n     * the AE precapture trigger. Note that, the CANCEL was added in API level 23, and must not\n     * be used in devices that have earlier API levels.</p>\n     * <p>The exact effect of auto-exposure (AE) precapture trigger\n     * depends on the current AE mode and state; see\n     * {@link CaptureResult#CONTROL_AE_STATE android.control.aeState} for AE precapture state transition\n     * details.</p>\n     * <p>On LEGACY-level devices, the precapture trigger is not supported;\n     * capturing a high-resolution JPEG image will automatically trigger a\n     * precapture sequence before the high-resolution capture, including\n     * potentially firing a pre-capture flash.</p>\n     * <p>Using the precapture trigger and the auto-focus trigger {@link CaptureRequest#CONTROL_AF_TRIGGER android.control.afTrigger}\n     * simultaneously is allowed. However, since these triggers often require cooperation between\n     * the auto-focus and auto-exposure routines (for example, the may need to be enabled for a\n     * focus sweep), the camera device may delay acting on a later trigger until the previous\n     * trigger has been fully handled. This may lead to longer intervals between the trigger and\n     * changes to {@link CaptureResult#CONTROL_AE_STATE android.control.aeState} indicating the start of the precapture sequence, for\n     * example.</p>\n     * <p>If both the precapture and the auto-focus trigger are activated on the same request, then\n     * the camera device will complete them in the optimal order for that device.</p>\n     * <p><b>Possible values:</b>\n     * <ul>\n     *   <li>{@link #CONTROL_AE_PRECAPTURE_TRIGGER_IDLE IDLE}</li>\n     *   <li>{@link #CONTROL_AE_PRECAPTURE_TRIGGER_START START}</li>\n     *   <li>{@link #CONTROL_AE_PRECAPTURE_TRIGGER_CANCEL CANCEL}</li>\n     * </ul></p>\n     * <p><b>Optional</b> - The value for this key may be {@code null} on some devices.</p>\n     * <p><b>Limited capability</b> -\n     * Present on all camera devices that report being at least {@link CameraCharacteristics#INFO_SUPPORTED_HARDWARE_LEVEL_LIMITED HARDWARE_LEVEL_LIMITED} devices in the\n     * {@link CameraCharacteristics#INFO_SUPPORTED_HARDWARE_LEVEL android.info.supportedHardwareLevel} key</p>\n     *\n     * @see CaptureRequest#CONTROL_AE_LOCK\n     * @see CaptureResult#CONTROL_AE_STATE\n     * @see CaptureRequest#CONTROL_AF_TRIGGER\n     * @see CaptureRequest#CONTROL_CAPTURE_INTENT\n     * @see CameraCharacteristics#INFO_SUPPORTED_HARDWARE_LEVEL\n     * @see #CONTROL_AE_PRECAPTURE_TRIGGER_IDLE\n     * @see #CONTROL_AE_PRECAPTURE_TRIGGER_START\n     * @see #CONTROL_AE_PRECAPTURE_TRIGGER_CANCEL\n     ",
    "links" : [ "CaptureRequest#CONTROL_CAPTURE_INTENT", "CaptureRequest#CONTROL_AE_LOCK", "CaptureRequest#CONTROL_AE_LOCK", "CaptureResult#CONTROL_AE_STATE", "CaptureRequest#CONTROL_AF_TRIGGER", "CaptureResult#CONTROL_AE_STATE", "#CONTROL_AE_PRECAPTURE_TRIGGER_IDLE", "#CONTROL_AE_PRECAPTURE_TRIGGER_START", "#CONTROL_AE_PRECAPTURE_TRIGGER_CANCEL", "CameraCharacteristics#INFO_SUPPORTED_HARDWARE_LEVEL_LIMITED", "CameraCharacteristics#INFO_SUPPORTED_HARDWARE_LEVEL" ]
  }, {
    "name" : "CONTROL_AF_MODE",
    "type" : "Key<Integer>",
    "comment" : "\n     * <p>Whether auto-focus (AF) is currently enabled, and what\n     * mode it is set to.</p>\n     * <p>Only effective if {@link CaptureRequest#CONTROL_MODE android.control.mode} = AUTO and the lens is not fixed focus\n     * (i.e. <code>{@link CameraCharacteristics#LENS_INFO_MINIMUM_FOCUS_DISTANCE android.lens.info.minimumFocusDistance} &gt; 0</code>). Also note that\n     * when {@link CaptureRequest#CONTROL_AE_MODE android.control.aeMode} is OFF, the behavior of AF is device\n     * dependent. It is recommended to lock AF by using {@link CaptureRequest#CONTROL_AF_TRIGGER android.control.afTrigger} before\n     * setting {@link CaptureRequest#CONTROL_AE_MODE android.control.aeMode} to OFF, or set AF mode to OFF when AE is OFF.</p>\n     * <p>If the lens is controlled by the camera device auto-focus algorithm,\n     * the camera device will report the current AF status in {@link CaptureResult#CONTROL_AF_STATE android.control.afState}\n     * in result metadata.</p>\n     * <p><b>Possible values:</b>\n     * <ul>\n     *   <li>{@link #CONTROL_AF_MODE_OFF OFF}</li>\n     *   <li>{@link #CONTROL_AF_MODE_AUTO AUTO}</li>\n     *   <li>{@link #CONTROL_AF_MODE_MACRO MACRO}</li>\n     *   <li>{@link #CONTROL_AF_MODE_CONTINUOUS_VIDEO CONTINUOUS_VIDEO}</li>\n     *   <li>{@link #CONTROL_AF_MODE_CONTINUOUS_PICTURE CONTINUOUS_PICTURE}</li>\n     *   <li>{@link #CONTROL_AF_MODE_EDOF EDOF}</li>\n     * </ul></p>\n     * <p><b>Available values for this device:</b><br>\n     * {@link CameraCharacteristics#CONTROL_AF_AVAILABLE_MODES android.control.afAvailableModes}</p>\n     * <p>This key is available on all devices.</p>\n     *\n     * @see CaptureRequest#CONTROL_AE_MODE\n     * @see CameraCharacteristics#CONTROL_AF_AVAILABLE_MODES\n     * @see CaptureResult#CONTROL_AF_STATE\n     * @see CaptureRequest#CONTROL_AF_TRIGGER\n     * @see CaptureRequest#CONTROL_MODE\n     * @see CameraCharacteristics#LENS_INFO_MINIMUM_FOCUS_DISTANCE\n     * @see #CONTROL_AF_MODE_OFF\n     * @see #CONTROL_AF_MODE_AUTO\n     * @see #CONTROL_AF_MODE_MACRO\n     * @see #CONTROL_AF_MODE_CONTINUOUS_VIDEO\n     * @see #CONTROL_AF_MODE_CONTINUOUS_PICTURE\n     * @see #CONTROL_AF_MODE_EDOF\n     ",
    "links" : [ "CaptureRequest#CONTROL_MODE", "CameraCharacteristics#LENS_INFO_MINIMUM_FOCUS_DISTANCE", "CaptureRequest#CONTROL_AE_MODE", "CaptureRequest#CONTROL_AF_TRIGGER", "CaptureRequest#CONTROL_AE_MODE", "CaptureResult#CONTROL_AF_STATE", "#CONTROL_AF_MODE_OFF", "#CONTROL_AF_MODE_AUTO", "#CONTROL_AF_MODE_MACRO", "#CONTROL_AF_MODE_CONTINUOUS_VIDEO", "#CONTROL_AF_MODE_CONTINUOUS_PICTURE", "#CONTROL_AF_MODE_EDOF", "CameraCharacteristics#CONTROL_AF_AVAILABLE_MODES" ]
  }, {
    "name" : "CONTROL_AF_REGIONS",
    "type" : "Key<android.hardware.camera2.params.MeteringRectangle[]>",
    "comment" : "\n     * <p>List of metering areas to use for auto-focus.</p>\n     * <p>Not available if {@link CameraCharacteristics#CONTROL_MAX_REGIONS_AF android.control.maxRegionsAf} is 0.\n     * Otherwise will always be present.</p>\n     * <p>The maximum number of focus areas supported by the device is determined by the value\n     * of {@link CameraCharacteristics#CONTROL_MAX_REGIONS_AF android.control.maxRegionsAf}.</p>\n     * <p>For devices not supporting {@link CaptureRequest#DISTORTION_CORRECTION_MODE android.distortionCorrection.mode} control, the coordinate\n     * system always follows that of {@link CameraCharacteristics#SENSOR_INFO_ACTIVE_ARRAY_SIZE android.sensor.info.activeArraySize}, with (0,0) being\n     * the top-left pixel in the active pixel array, and\n     * ({@link CameraCharacteristics#SENSOR_INFO_ACTIVE_ARRAY_SIZE android.sensor.info.activeArraySize}.width - 1,\n     * {@link CameraCharacteristics#SENSOR_INFO_ACTIVE_ARRAY_SIZE android.sensor.info.activeArraySize}.height - 1) being the bottom-right pixel in the\n     * active pixel array.</p>\n     * <p>For devices supporting {@link CaptureRequest#DISTORTION_CORRECTION_MODE android.distortionCorrection.mode} control, the coordinate\n     * system depends on the mode being set.\n     * When the distortion correction mode is OFF, the coordinate system follows\n     * {@link CameraCharacteristics#SENSOR_INFO_PRE_CORRECTION_ACTIVE_ARRAY_SIZE android.sensor.info.preCorrectionActiveArraySize}, with\n     * <code>(0, 0)</code> being the top-left pixel of the pre-correction active array, and\n     * ({@link CameraCharacteristics#SENSOR_INFO_PRE_CORRECTION_ACTIVE_ARRAY_SIZE android.sensor.info.preCorrectionActiveArraySize}.width - 1,\n     * {@link CameraCharacteristics#SENSOR_INFO_PRE_CORRECTION_ACTIVE_ARRAY_SIZE android.sensor.info.preCorrectionActiveArraySize}.height - 1) being the bottom-right\n     * pixel in the pre-correction active pixel array.\n     * When the distortion correction mode is not OFF, the coordinate system follows\n     * {@link CameraCharacteristics#SENSOR_INFO_ACTIVE_ARRAY_SIZE android.sensor.info.activeArraySize}, with\n     * <code>(0, 0)</code> being the top-left pixel of the active array, and\n     * ({@link CameraCharacteristics#SENSOR_INFO_ACTIVE_ARRAY_SIZE android.sensor.info.activeArraySize}.width - 1,\n     * {@link CameraCharacteristics#SENSOR_INFO_ACTIVE_ARRAY_SIZE android.sensor.info.activeArraySize}.height - 1) being the bottom-right pixel in the\n     * active pixel array.</p>\n     * <p>The weight must be within <code>[0, 1000]</code>, and represents a weight\n     * for every pixel in the area. This means that a large metering area\n     * with the same weight as a smaller area will have more effect in\n     * the metering result. Metering areas can partially overlap and the\n     * camera device will add the weights in the overlap region.</p>\n     * <p>The weights are relative to weights of other metering regions, so if only one region\n     * is used, all non-zero weights will have the same effect. A region with 0 weight is\n     * ignored.</p>\n     * <p>If all regions have 0 weight, then no specific metering area needs to be used by the\n     * camera device. The capture result will either be a zero weight region as well, or\n     * the region selected by the camera device as the focus area of interest.</p>\n     * <p>If the metering region is outside the used {@link CaptureRequest#SCALER_CROP_REGION android.scaler.cropRegion} returned in\n     * capture result metadata, the camera device will ignore the sections outside the crop\n     * region and output only the intersection rectangle as the metering region in the result\n     * metadata. If the region is entirely outside the crop region, it will be ignored and\n     * not reported in the result metadata.</p>\n     * <p>Starting from API level 30, the coordinate system of activeArraySize or\n     * preCorrectionActiveArraySize is used to represent post-zoomRatio field of view, not\n     * pre-zoom field of view. This means that the same afRegions values at different\n     * {@link CaptureRequest#CONTROL_ZOOM_RATIO android.control.zoomRatio} represent different parts of the scene. The afRegions\n     * coordinates are relative to the activeArray/preCorrectionActiveArray representing the\n     * zoomed field of view. If {@link CaptureRequest#CONTROL_ZOOM_RATIO android.control.zoomRatio} is set to 1.0 (default), the same\n     * afRegions at different {@link CaptureRequest#SCALER_CROP_REGION android.scaler.cropRegion} still represent the same parts of the\n     * scene as they do before. See {@link CaptureRequest#CONTROL_ZOOM_RATIO android.control.zoomRatio} for details. Whether to use\n     * activeArraySize or preCorrectionActiveArraySize still depends on distortion correction\n     * mode.</p>\n     * <p><b>Units</b>: Pixel coordinates within {@link CameraCharacteristics#SENSOR_INFO_ACTIVE_ARRAY_SIZE android.sensor.info.activeArraySize} or\n     * {@link CameraCharacteristics#SENSOR_INFO_PRE_CORRECTION_ACTIVE_ARRAY_SIZE android.sensor.info.preCorrectionActiveArraySize} depending on\n     * distortion correction capability and mode</p>\n     * <p><b>Range of valid values:</b><br>\n     * Coordinates must be between <code>[(0,0), (width, height))</code> of\n     * {@link CameraCharacteristics#SENSOR_INFO_ACTIVE_ARRAY_SIZE android.sensor.info.activeArraySize} or {@link CameraCharacteristics#SENSOR_INFO_PRE_CORRECTION_ACTIVE_ARRAY_SIZE android.sensor.info.preCorrectionActiveArraySize}\n     * depending on distortion correction capability and mode</p>\n     * <p><b>Optional</b> - The value for this key may be {@code null} on some devices.</p>\n     *\n     * @see CameraCharacteristics#CONTROL_MAX_REGIONS_AF\n     * @see CaptureRequest#CONTROL_ZOOM_RATIO\n     * @see CaptureRequest#DISTORTION_CORRECTION_MODE\n     * @see CaptureRequest#SCALER_CROP_REGION\n     * @see CameraCharacteristics#SENSOR_INFO_ACTIVE_ARRAY_SIZE\n     * @see CameraCharacteristics#SENSOR_INFO_PRE_CORRECTION_ACTIVE_ARRAY_SIZE\n     ",
    "links" : [ "CameraCharacteristics#CONTROL_MAX_REGIONS_AF", "CameraCharacteristics#CONTROL_MAX_REGIONS_AF", "CaptureRequest#DISTORTION_CORRECTION_MODE", "CameraCharacteristics#SENSOR_INFO_ACTIVE_ARRAY_SIZE", "CameraCharacteristics#SENSOR_INFO_ACTIVE_ARRAY_SIZE", "CameraCharacteristics#SENSOR_INFO_ACTIVE_ARRAY_SIZE", "CaptureRequest#DISTORTION_CORRECTION_MODE", "CameraCharacteristics#SENSOR_INFO_PRE_CORRECTION_ACTIVE_ARRAY_SIZE", "CameraCharacteristics#SENSOR_INFO_PRE_CORRECTION_ACTIVE_ARRAY_SIZE", "CameraCharacteristics#SENSOR_INFO_PRE_CORRECTION_ACTIVE_ARRAY_SIZE", "CameraCharacteristics#SENSOR_INFO_ACTIVE_ARRAY_SIZE", "CameraCharacteristics#SENSOR_INFO_ACTIVE_ARRAY_SIZE", "CameraCharacteristics#SENSOR_INFO_ACTIVE_ARRAY_SIZE", "CaptureRequest#SCALER_CROP_REGION", "CaptureRequest#CONTROL_ZOOM_RATIO", "CaptureRequest#CONTROL_ZOOM_RATIO", "CaptureRequest#SCALER_CROP_REGION", "CaptureRequest#CONTROL_ZOOM_RATIO", "CameraCharacteristics#SENSOR_INFO_ACTIVE_ARRAY_SIZE", "CameraCharacteristics#SENSOR_INFO_PRE_CORRECTION_ACTIVE_ARRAY_SIZE", "CameraCharacteristics#SENSOR_INFO_ACTIVE_ARRAY_SIZE", "CameraCharacteristics#SENSOR_INFO_PRE_CORRECTION_ACTIVE_ARRAY_SIZE" ]
  }, {
    "name" : "CONTROL_AF_TRIGGER",
    "type" : "Key<Integer>",
    "comment" : "\n     * <p>Whether the camera device will trigger autofocus for this request.</p>\n     * <p>This entry is normally set to IDLE, or is not\n     * included at all in the request settings.</p>\n     * <p>When included and set to START, the camera device will trigger the\n     * autofocus algorithm. If autofocus is disabled, this trigger has no effect.</p>\n     * <p>When set to CANCEL, the camera device will cancel any active trigger,\n     * and return to its initial AF state.</p>\n     * <p>Generally, applications should set this entry to START or CANCEL for only a\n     * single capture, and then return it to IDLE (or not set at all). Specifying\n     * START for multiple captures in a row means restarting the AF operation over\n     * and over again.</p>\n     * <p>See {@link CaptureResult#CONTROL_AF_STATE android.control.afState} for what the trigger means for each AF mode.</p>\n     * <p>Using the autofocus trigger and the precapture trigger {@link CaptureRequest#CONTROL_AE_PRECAPTURE_TRIGGER android.control.aePrecaptureTrigger}\n     * simultaneously is allowed. However, since these triggers often require cooperation between\n     * the auto-focus and auto-exposure routines (for example, the may need to be enabled for a\n     * focus sweep), the camera device may delay acting on a later trigger until the previous\n     * trigger has been fully handled. This may lead to longer intervals between the trigger and\n     * changes to {@link CaptureResult#CONTROL_AF_STATE android.control.afState}, for example.</p>\n     * <p><b>Possible values:</b>\n     * <ul>\n     *   <li>{@link #CONTROL_AF_TRIGGER_IDLE IDLE}</li>\n     *   <li>{@link #CONTROL_AF_TRIGGER_START START}</li>\n     *   <li>{@link #CONTROL_AF_TRIGGER_CANCEL CANCEL}</li>\n     * </ul></p>\n     * <p>This key is available on all devices.</p>\n     *\n     * @see CaptureRequest#CONTROL_AE_PRECAPTURE_TRIGGER\n     * @see CaptureResult#CONTROL_AF_STATE\n     * @see #CONTROL_AF_TRIGGER_IDLE\n     * @see #CONTROL_AF_TRIGGER_START\n     * @see #CONTROL_AF_TRIGGER_CANCEL\n     ",
    "links" : [ "CaptureResult#CONTROL_AF_STATE", "CaptureRequest#CONTROL_AE_PRECAPTURE_TRIGGER", "CaptureResult#CONTROL_AF_STATE", "#CONTROL_AF_TRIGGER_IDLE", "#CONTROL_AF_TRIGGER_START", "#CONTROL_AF_TRIGGER_CANCEL" ]
  }, {
    "name" : "CONTROL_AWB_LOCK",
    "type" : "Key<Boolean>",
    "comment" : "\n     * <p>Whether auto-white balance (AWB) is currently locked to its\n     * latest calculated values.</p>\n     * <p>When set to <code>true</code> (ON), the AWB algorithm is locked to its latest parameters,\n     * and will not change color balance settings until the lock is set to <code>false</code> (OFF).</p>\n     * <p>Since the camera device has a pipeline of in-flight requests, the settings that\n     * get locked do not necessarily correspond to the settings that were present in the\n     * latest capture result received from the camera device, since additional captures\n     * and AWB updates may have occurred even before the result was sent out. If an\n     * application is switching between automatic and manual control and wishes to eliminate\n     * any flicker during the switch, the following procedure is recommended:</p>\n     * <ol>\n     * <li>Starting in auto-AWB mode:</li>\n     * <li>Lock AWB</li>\n     * <li>Wait for the first result to be output that has the AWB locked</li>\n     * <li>Copy AWB settings from that result into a request, set the request to manual AWB</li>\n     * <li>Submit the capture request, proceed to run manual AWB as desired.</li>\n     * </ol>\n     * <p>Note that AWB lock is only meaningful when\n     * {@link CaptureRequest#CONTROL_AWB_MODE android.control.awbMode} is in the AUTO mode; in other modes,\n     * AWB is already fixed to a specific setting.</p>\n     * <p>Some LEGACY devices may not support ON; the value is then overridden to OFF.</p>\n     * <p>This key is available on all devices.</p>\n     *\n     * @see CaptureRequest#CONTROL_AWB_MODE\n     ",
    "links" : [ "CaptureRequest#CONTROL_AWB_MODE" ]
  }, {
    "name" : "CONTROL_AWB_MODE",
    "type" : "Key<Integer>",
    "comment" : "\n     * <p>Whether auto-white balance (AWB) is currently setting the color\n     * transform fields, and what its illumination target\n     * is.</p>\n     * <p>This control is only effective if {@link CaptureRequest#CONTROL_MODE android.control.mode} is AUTO.</p>\n     * <p>When set to the ON mode, the camera device's auto-white balance\n     * routine is enabled, overriding the application's selected\n     * {@link CaptureRequest#COLOR_CORRECTION_TRANSFORM android.colorCorrection.transform}, {@link CaptureRequest#COLOR_CORRECTION_GAINS android.colorCorrection.gains} and\n     * {@link CaptureRequest#COLOR_CORRECTION_MODE android.colorCorrection.mode}. Note that when {@link CaptureRequest#CONTROL_AE_MODE android.control.aeMode}\n     * is OFF, the behavior of AWB is device dependent. It is recommened to\n     * also set AWB mode to OFF or lock AWB by using {@link CaptureRequest#CONTROL_AWB_LOCK android.control.awbLock} before\n     * setting AE mode to OFF.</p>\n     * <p>When set to the OFF mode, the camera device's auto-white balance\n     * routine is disabled. The application manually controls the white\n     * balance by {@link CaptureRequest#COLOR_CORRECTION_TRANSFORM android.colorCorrection.transform}, {@link CaptureRequest#COLOR_CORRECTION_GAINS android.colorCorrection.gains}\n     * and {@link CaptureRequest#COLOR_CORRECTION_MODE android.colorCorrection.mode}.</p>\n     * <p>When set to any other modes, the camera device's auto-white\n     * balance routine is disabled. The camera device uses each\n     * particular illumination target for white balance\n     * adjustment. The application's values for\n     * {@link CaptureRequest#COLOR_CORRECTION_TRANSFORM android.colorCorrection.transform},\n     * {@link CaptureRequest#COLOR_CORRECTION_GAINS android.colorCorrection.gains} and\n     * {@link CaptureRequest#COLOR_CORRECTION_MODE android.colorCorrection.mode} are ignored.</p>\n     * <p><b>Possible values:</b>\n     * <ul>\n     *   <li>{@link #CONTROL_AWB_MODE_OFF OFF}</li>\n     *   <li>{@link #CONTROL_AWB_MODE_AUTO AUTO}</li>\n     *   <li>{@link #CONTROL_AWB_MODE_INCANDESCENT INCANDESCENT}</li>\n     *   <li>{@link #CONTROL_AWB_MODE_FLUORESCENT FLUORESCENT}</li>\n     *   <li>{@link #CONTROL_AWB_MODE_WARM_FLUORESCENT WARM_FLUORESCENT}</li>\n     *   <li>{@link #CONTROL_AWB_MODE_DAYLIGHT DAYLIGHT}</li>\n     *   <li>{@link #CONTROL_AWB_MODE_CLOUDY_DAYLIGHT CLOUDY_DAYLIGHT}</li>\n     *   <li>{@link #CONTROL_AWB_MODE_TWILIGHT TWILIGHT}</li>\n     *   <li>{@link #CONTROL_AWB_MODE_SHADE SHADE}</li>\n     * </ul></p>\n     * <p><b>Available values for this device:</b><br>\n     * {@link CameraCharacteristics#CONTROL_AWB_AVAILABLE_MODES android.control.awbAvailableModes}</p>\n     * <p>This key is available on all devices.</p>\n     *\n     * @see CaptureRequest#COLOR_CORRECTION_GAINS\n     * @see CaptureRequest#COLOR_CORRECTION_MODE\n     * @see CaptureRequest#COLOR_CORRECTION_TRANSFORM\n     * @see CaptureRequest#CONTROL_AE_MODE\n     * @see CameraCharacteristics#CONTROL_AWB_AVAILABLE_MODES\n     * @see CaptureRequest#CONTROL_AWB_LOCK\n     * @see CaptureRequest#CONTROL_MODE\n     * @see #CONTROL_AWB_MODE_OFF\n     * @see #CONTROL_AWB_MODE_AUTO\n     * @see #CONTROL_AWB_MODE_INCANDESCENT\n     * @see #CONTROL_AWB_MODE_FLUORESCENT\n     * @see #CONTROL_AWB_MODE_WARM_FLUORESCENT\n     * @see #CONTROL_AWB_MODE_DAYLIGHT\n     * @see #CONTROL_AWB_MODE_CLOUDY_DAYLIGHT\n     * @see #CONTROL_AWB_MODE_TWILIGHT\n     * @see #CONTROL_AWB_MODE_SHADE\n     ",
    "links" : [ "CaptureRequest#CONTROL_MODE", "CaptureRequest#COLOR_CORRECTION_TRANSFORM", "CaptureRequest#COLOR_CORRECTION_GAINS", "CaptureRequest#COLOR_CORRECTION_MODE", "CaptureRequest#CONTROL_AE_MODE", "CaptureRequest#CONTROL_AWB_LOCK", "CaptureRequest#COLOR_CORRECTION_TRANSFORM", "CaptureRequest#COLOR_CORRECTION_GAINS", "CaptureRequest#COLOR_CORRECTION_MODE", "CaptureRequest#COLOR_CORRECTION_TRANSFORM", "CaptureRequest#COLOR_CORRECTION_GAINS", "CaptureRequest#COLOR_CORRECTION_MODE", "#CONTROL_AWB_MODE_OFF", "#CONTROL_AWB_MODE_AUTO", "#CONTROL_AWB_MODE_INCANDESCENT", "#CONTROL_AWB_MODE_FLUORESCENT", "#CONTROL_AWB_MODE_WARM_FLUORESCENT", "#CONTROL_AWB_MODE_DAYLIGHT", "#CONTROL_AWB_MODE_CLOUDY_DAYLIGHT", "#CONTROL_AWB_MODE_TWILIGHT", "#CONTROL_AWB_MODE_SHADE", "CameraCharacteristics#CONTROL_AWB_AVAILABLE_MODES" ]
  }, {
    "name" : "CONTROL_AWB_REGIONS",
    "type" : "Key<android.hardware.camera2.params.MeteringRectangle[]>",
    "comment" : "\n     * <p>List of metering areas to use for auto-white-balance illuminant\n     * estimation.</p>\n     * <p>Not available if {@link CameraCharacteristics#CONTROL_MAX_REGIONS_AWB android.control.maxRegionsAwb} is 0.\n     * Otherwise will always be present.</p>\n     * <p>The maximum number of regions supported by the device is determined by the value\n     * of {@link CameraCharacteristics#CONTROL_MAX_REGIONS_AWB android.control.maxRegionsAwb}.</p>\n     * <p>For devices not supporting {@link CaptureRequest#DISTORTION_CORRECTION_MODE android.distortionCorrection.mode} control, the coordinate\n     * system always follows that of {@link CameraCharacteristics#SENSOR_INFO_ACTIVE_ARRAY_SIZE android.sensor.info.activeArraySize}, with (0,0) being\n     * the top-left pixel in the active pixel array, and\n     * ({@link CameraCharacteristics#SENSOR_INFO_ACTIVE_ARRAY_SIZE android.sensor.info.activeArraySize}.width - 1,\n     * {@link CameraCharacteristics#SENSOR_INFO_ACTIVE_ARRAY_SIZE android.sensor.info.activeArraySize}.height - 1) being the bottom-right pixel in the\n     * active pixel array.</p>\n     * <p>For devices supporting {@link CaptureRequest#DISTORTION_CORRECTION_MODE android.distortionCorrection.mode} control, the coordinate\n     * system depends on the mode being set.\n     * When the distortion correction mode is OFF, the coordinate system follows\n     * {@link CameraCharacteristics#SENSOR_INFO_PRE_CORRECTION_ACTIVE_ARRAY_SIZE android.sensor.info.preCorrectionActiveArraySize}, with\n     * <code>(0, 0)</code> being the top-left pixel of the pre-correction active array, and\n     * ({@link CameraCharacteristics#SENSOR_INFO_PRE_CORRECTION_ACTIVE_ARRAY_SIZE android.sensor.info.preCorrectionActiveArraySize}.width - 1,\n     * {@link CameraCharacteristics#SENSOR_INFO_PRE_CORRECTION_ACTIVE_ARRAY_SIZE android.sensor.info.preCorrectionActiveArraySize}.height - 1) being the bottom-right\n     * pixel in the pre-correction active pixel array.\n     * When the distortion correction mode is not OFF, the coordinate system follows\n     * {@link CameraCharacteristics#SENSOR_INFO_ACTIVE_ARRAY_SIZE android.sensor.info.activeArraySize}, with\n     * <code>(0, 0)</code> being the top-left pixel of the active array, and\n     * ({@link CameraCharacteristics#SENSOR_INFO_ACTIVE_ARRAY_SIZE android.sensor.info.activeArraySize}.width - 1,\n     * {@link CameraCharacteristics#SENSOR_INFO_ACTIVE_ARRAY_SIZE android.sensor.info.activeArraySize}.height - 1) being the bottom-right pixel in the\n     * active pixel array.</p>\n     * <p>The weight must range from 0 to 1000, and represents a weight\n     * for every pixel in the area. This means that a large metering area\n     * with the same weight as a smaller area will have more effect in\n     * the metering result. Metering areas can partially overlap and the\n     * camera device will add the weights in the overlap region.</p>\n     * <p>The weights are relative to weights of other white balance metering regions, so if\n     * only one region is used, all non-zero weights will have the same effect. A region with\n     * 0 weight is ignored.</p>\n     * <p>If all regions have 0 weight, then no specific metering area needs to be used by the\n     * camera device.</p>\n     * <p>If the metering region is outside the used {@link CaptureRequest#SCALER_CROP_REGION android.scaler.cropRegion} returned in\n     * capture result metadata, the camera device will ignore the sections outside the crop\n     * region and output only the intersection rectangle as the metering region in the result\n     * metadata.  If the region is entirely outside the crop region, it will be ignored and\n     * not reported in the result metadata.</p>\n     * <p>Starting from API level 30, the coordinate system of activeArraySize or\n     * preCorrectionActiveArraySize is used to represent post-zoomRatio field of view, not\n     * pre-zoom field of view. This means that the same awbRegions values at different\n     * {@link CaptureRequest#CONTROL_ZOOM_RATIO android.control.zoomRatio} represent different parts of the scene. The awbRegions\n     * coordinates are relative to the activeArray/preCorrectionActiveArray representing the\n     * zoomed field of view. If {@link CaptureRequest#CONTROL_ZOOM_RATIO android.control.zoomRatio} is set to 1.0 (default), the same\n     * awbRegions at different {@link CaptureRequest#SCALER_CROP_REGION android.scaler.cropRegion} still represent the same parts of\n     * the scene as they do before. See {@link CaptureRequest#CONTROL_ZOOM_RATIO android.control.zoomRatio} for details. Whether to use\n     * activeArraySize or preCorrectionActiveArraySize still depends on distortion correction\n     * mode.</p>\n     * <p><b>Units</b>: Pixel coordinates within {@link CameraCharacteristics#SENSOR_INFO_ACTIVE_ARRAY_SIZE android.sensor.info.activeArraySize} or\n     * {@link CameraCharacteristics#SENSOR_INFO_PRE_CORRECTION_ACTIVE_ARRAY_SIZE android.sensor.info.preCorrectionActiveArraySize} depending on\n     * distortion correction capability and mode</p>\n     * <p><b>Range of valid values:</b><br>\n     * Coordinates must be between <code>[(0,0), (width, height))</code> of\n     * {@link CameraCharacteristics#SENSOR_INFO_ACTIVE_ARRAY_SIZE android.sensor.info.activeArraySize} or {@link CameraCharacteristics#SENSOR_INFO_PRE_CORRECTION_ACTIVE_ARRAY_SIZE android.sensor.info.preCorrectionActiveArraySize}\n     * depending on distortion correction capability and mode</p>\n     * <p><b>Optional</b> - The value for this key may be {@code null} on some devices.</p>\n     *\n     * @see CameraCharacteristics#CONTROL_MAX_REGIONS_AWB\n     * @see CaptureRequest#CONTROL_ZOOM_RATIO\n     * @see CaptureRequest#DISTORTION_CORRECTION_MODE\n     * @see CaptureRequest#SCALER_CROP_REGION\n     * @see CameraCharacteristics#SENSOR_INFO_ACTIVE_ARRAY_SIZE\n     * @see CameraCharacteristics#SENSOR_INFO_PRE_CORRECTION_ACTIVE_ARRAY_SIZE\n     ",
    "links" : [ "CameraCharacteristics#CONTROL_MAX_REGIONS_AWB", "CameraCharacteristics#CONTROL_MAX_REGIONS_AWB", "CaptureRequest#DISTORTION_CORRECTION_MODE", "CameraCharacteristics#SENSOR_INFO_ACTIVE_ARRAY_SIZE", "CameraCharacteristics#SENSOR_INFO_ACTIVE_ARRAY_SIZE", "CameraCharacteristics#SENSOR_INFO_ACTIVE_ARRAY_SIZE", "CaptureRequest#DISTORTION_CORRECTION_MODE", "CameraCharacteristics#SENSOR_INFO_PRE_CORRECTION_ACTIVE_ARRAY_SIZE", "CameraCharacteristics#SENSOR_INFO_PRE_CORRECTION_ACTIVE_ARRAY_SIZE", "CameraCharacteristics#SENSOR_INFO_PRE_CORRECTION_ACTIVE_ARRAY_SIZE", "CameraCharacteristics#SENSOR_INFO_ACTIVE_ARRAY_SIZE", "CameraCharacteristics#SENSOR_INFO_ACTIVE_ARRAY_SIZE", "CameraCharacteristics#SENSOR_INFO_ACTIVE_ARRAY_SIZE", "CaptureRequest#SCALER_CROP_REGION", "CaptureRequest#CONTROL_ZOOM_RATIO", "CaptureRequest#CONTROL_ZOOM_RATIO", "CaptureRequest#SCALER_CROP_REGION", "CaptureRequest#CONTROL_ZOOM_RATIO", "CameraCharacteristics#SENSOR_INFO_ACTIVE_ARRAY_SIZE", "CameraCharacteristics#SENSOR_INFO_PRE_CORRECTION_ACTIVE_ARRAY_SIZE", "CameraCharacteristics#SENSOR_INFO_ACTIVE_ARRAY_SIZE", "CameraCharacteristics#SENSOR_INFO_PRE_CORRECTION_ACTIVE_ARRAY_SIZE" ]
  }, {
    "name" : "CONTROL_CAPTURE_INTENT",
    "type" : "Key<Integer>",
    "comment" : "\n     * <p>Information to the camera device 3A (auto-exposure,\n     * auto-focus, auto-white balance) routines about the purpose\n     * of this capture, to help the camera device to decide optimal 3A\n     * strategy.</p>\n     * <p>This control (except for MANUAL) is only effective if\n     * <code>{@link CaptureRequest#CONTROL_MODE android.control.mode} != OFF</code> and any 3A routine is active.</p>\n     * <p>All intents are supported by all devices, except that:\n     *   * ZERO_SHUTTER_LAG will be supported if {@link CameraCharacteristics#REQUEST_AVAILABLE_CAPABILITIES android.request.availableCapabilities} contains\n     * PRIVATE_REPROCESSING or YUV_REPROCESSING.\n     *   * MANUAL will be supported if {@link CameraCharacteristics#REQUEST_AVAILABLE_CAPABILITIES android.request.availableCapabilities} contains\n     * MANUAL_SENSOR.\n     *   * MOTION_TRACKING will be supported if {@link CameraCharacteristics#REQUEST_AVAILABLE_CAPABILITIES android.request.availableCapabilities} contains\n     * MOTION_TRACKING.</p>\n     * <p><b>Possible values:</b>\n     * <ul>\n     *   <li>{@link #CONTROL_CAPTURE_INTENT_CUSTOM CUSTOM}</li>\n     *   <li>{@link #CONTROL_CAPTURE_INTENT_PREVIEW PREVIEW}</li>\n     *   <li>{@link #CONTROL_CAPTURE_INTENT_STILL_CAPTURE STILL_CAPTURE}</li>\n     *   <li>{@link #CONTROL_CAPTURE_INTENT_VIDEO_RECORD VIDEO_RECORD}</li>\n     *   <li>{@link #CONTROL_CAPTURE_INTENT_VIDEO_SNAPSHOT VIDEO_SNAPSHOT}</li>\n     *   <li>{@link #CONTROL_CAPTURE_INTENT_ZERO_SHUTTER_LAG ZERO_SHUTTER_LAG}</li>\n     *   <li>{@link #CONTROL_CAPTURE_INTENT_MANUAL MANUAL}</li>\n     *   <li>{@link #CONTROL_CAPTURE_INTENT_MOTION_TRACKING MOTION_TRACKING}</li>\n     * </ul></p>\n     * <p>This key is available on all devices.</p>\n     *\n     * @see CaptureRequest#CONTROL_MODE\n     * @see CameraCharacteristics#REQUEST_AVAILABLE_CAPABILITIES\n     * @see #CONTROL_CAPTURE_INTENT_CUSTOM\n     * @see #CONTROL_CAPTURE_INTENT_PREVIEW\n     * @see #CONTROL_CAPTURE_INTENT_STILL_CAPTURE\n     * @see #CONTROL_CAPTURE_INTENT_VIDEO_RECORD\n     * @see #CONTROL_CAPTURE_INTENT_VIDEO_SNAPSHOT\n     * @see #CONTROL_CAPTURE_INTENT_ZERO_SHUTTER_LAG\n     * @see #CONTROL_CAPTURE_INTENT_MANUAL\n     * @see #CONTROL_CAPTURE_INTENT_MOTION_TRACKING\n     ",
    "links" : [ "CaptureRequest#CONTROL_MODE", "CameraCharacteristics#REQUEST_AVAILABLE_CAPABILITIES", "CameraCharacteristics#REQUEST_AVAILABLE_CAPABILITIES", "CameraCharacteristics#REQUEST_AVAILABLE_CAPABILITIES", "#CONTROL_CAPTURE_INTENT_CUSTOM", "#CONTROL_CAPTURE_INTENT_PREVIEW", "#CONTROL_CAPTURE_INTENT_STILL_CAPTURE", "#CONTROL_CAPTURE_INTENT_VIDEO_RECORD", "#CONTROL_CAPTURE_INTENT_VIDEO_SNAPSHOT", "#CONTROL_CAPTURE_INTENT_ZERO_SHUTTER_LAG", "#CONTROL_CAPTURE_INTENT_MANUAL", "#CONTROL_CAPTURE_INTENT_MOTION_TRACKING" ]
  }, {
    "name" : "CONTROL_EFFECT_MODE",
    "type" : "Key<Integer>",
    "comment" : "\n     * <p>A special color effect to apply.</p>\n     * <p>When this mode is set, a color effect will be applied\n     * to images produced by the camera device. The interpretation\n     * and implementation of these color effects is left to the\n     * implementor of the camera device, and should not be\n     * depended on to be consistent (or present) across all\n     * devices.</p>\n     * <p><b>Possible values:</b>\n     * <ul>\n     *   <li>{@link #CONTROL_EFFECT_MODE_OFF OFF}</li>\n     *   <li>{@link #CONTROL_EFFECT_MODE_MONO MONO}</li>\n     *   <li>{@link #CONTROL_EFFECT_MODE_NEGATIVE NEGATIVE}</li>\n     *   <li>{@link #CONTROL_EFFECT_MODE_SOLARIZE SOLARIZE}</li>\n     *   <li>{@link #CONTROL_EFFECT_MODE_SEPIA SEPIA}</li>\n     *   <li>{@link #CONTROL_EFFECT_MODE_POSTERIZE POSTERIZE}</li>\n     *   <li>{@link #CONTROL_EFFECT_MODE_WHITEBOARD WHITEBOARD}</li>\n     *   <li>{@link #CONTROL_EFFECT_MODE_BLACKBOARD BLACKBOARD}</li>\n     *   <li>{@link #CONTROL_EFFECT_MODE_AQUA AQUA}</li>\n     * </ul></p>\n     * <p><b>Available values for this device:</b><br>\n     * {@link CameraCharacteristics#CONTROL_AVAILABLE_EFFECTS android.control.availableEffects}</p>\n     * <p>This key is available on all devices.</p>\n     *\n     * @see CameraCharacteristics#CONTROL_AVAILABLE_EFFECTS\n     * @see #CONTROL_EFFECT_MODE_OFF\n     * @see #CONTROL_EFFECT_MODE_MONO\n     * @see #CONTROL_EFFECT_MODE_NEGATIVE\n     * @see #CONTROL_EFFECT_MODE_SOLARIZE\n     * @see #CONTROL_EFFECT_MODE_SEPIA\n     * @see #CONTROL_EFFECT_MODE_POSTERIZE\n     * @see #CONTROL_EFFECT_MODE_WHITEBOARD\n     * @see #CONTROL_EFFECT_MODE_BLACKBOARD\n     * @see #CONTROL_EFFECT_MODE_AQUA\n     ",
    "links" : [ "#CONTROL_EFFECT_MODE_OFF", "#CONTROL_EFFECT_MODE_MONO", "#CONTROL_EFFECT_MODE_NEGATIVE", "#CONTROL_EFFECT_MODE_SOLARIZE", "#CONTROL_EFFECT_MODE_SEPIA", "#CONTROL_EFFECT_MODE_POSTERIZE", "#CONTROL_EFFECT_MODE_WHITEBOARD", "#CONTROL_EFFECT_MODE_BLACKBOARD", "#CONTROL_EFFECT_MODE_AQUA", "CameraCharacteristics#CONTROL_AVAILABLE_EFFECTS" ]
  }, {
    "name" : "CONTROL_MODE",
    "type" : "Key<Integer>",
    "comment" : "\n     * <p>Overall mode of 3A (auto-exposure, auto-white-balance, auto-focus) control\n     * routines.</p>\n     * <p>This is a top-level 3A control switch. When set to OFF, all 3A control\n     * by the camera device is disabled. The application must set the fields for\n     * capture parameters itself.</p>\n     * <p>When set to AUTO, the individual algorithm controls in\n     * android.control.* are in effect, such as {@link CaptureRequest#CONTROL_AF_MODE android.control.afMode}.</p>\n     * <p>When set to USE_SCENE_MODE or USE_EXTENDED_SCENE_MODE, the individual controls in\n     * android.control.* are mostly disabled, and the camera device\n     * implements one of the scene mode or extended scene mode settings (such as ACTION,\n     * SUNSET, PARTY, or BOKEH) as it wishes. The camera device scene mode\n     * 3A settings are provided by {@link android.hardware.camera2.CaptureResult capture results}.</p>\n     * <p>When set to OFF_KEEP_STATE, it is similar to OFF mode, the only difference\n     * is that this frame will not be used by camera device background 3A statistics\n     * update, as if this frame is never captured. This mode can be used in the scenario\n     * where the application doesn't want a 3A manual control capture to affect\n     * the subsequent auto 3A capture results.</p>\n     * <p><b>Possible values:</b>\n     * <ul>\n     *   <li>{@link #CONTROL_MODE_OFF OFF}</li>\n     *   <li>{@link #CONTROL_MODE_AUTO AUTO}</li>\n     *   <li>{@link #CONTROL_MODE_USE_SCENE_MODE USE_SCENE_MODE}</li>\n     *   <li>{@link #CONTROL_MODE_OFF_KEEP_STATE OFF_KEEP_STATE}</li>\n     *   <li>{@link #CONTROL_MODE_USE_EXTENDED_SCENE_MODE USE_EXTENDED_SCENE_MODE}</li>\n     * </ul></p>\n     * <p><b>Available values for this device:</b><br>\n     * {@link CameraCharacteristics#CONTROL_AVAILABLE_MODES android.control.availableModes}</p>\n     * <p>This key is available on all devices.</p>\n     *\n     * @see CaptureRequest#CONTROL_AF_MODE\n     * @see CameraCharacteristics#CONTROL_AVAILABLE_MODES\n     * @see #CONTROL_MODE_OFF\n     * @see #CONTROL_MODE_AUTO\n     * @see #CONTROL_MODE_USE_SCENE_MODE\n     * @see #CONTROL_MODE_OFF_KEEP_STATE\n     * @see #CONTROL_MODE_USE_EXTENDED_SCENE_MODE\n     ",
    "links" : [ "CaptureRequest#CONTROL_AF_MODE", "android.hardware.camera2.CaptureResult", "#CONTROL_MODE_OFF", "#CONTROL_MODE_AUTO", "#CONTROL_MODE_USE_SCENE_MODE", "#CONTROL_MODE_OFF_KEEP_STATE", "#CONTROL_MODE_USE_EXTENDED_SCENE_MODE", "CameraCharacteristics#CONTROL_AVAILABLE_MODES" ]
  }, {
    "name" : "CONTROL_SCENE_MODE",
    "type" : "Key<Integer>",
    "comment" : "\n     * <p>Control for which scene mode is currently active.</p>\n     * <p>Scene modes are custom camera modes optimized for a certain set of conditions and\n     * capture settings.</p>\n     * <p>This is the mode that that is active when\n     * <code>{@link CaptureRequest#CONTROL_MODE android.control.mode} == USE_SCENE_MODE</code>. Aside from FACE_PRIORITY, these modes will\n     * disable {@link CaptureRequest#CONTROL_AE_MODE android.control.aeMode}, {@link CaptureRequest#CONTROL_AWB_MODE android.control.awbMode}, and {@link CaptureRequest#CONTROL_AF_MODE android.control.afMode}\n     * while in use.</p>\n     * <p>The interpretation and implementation of these scene modes is left\n     * to the implementor of the camera device. Their behavior will not be\n     * consistent across all devices, and any given device may only implement\n     * a subset of these modes.</p>\n     * <p><b>Possible values:</b>\n     * <ul>\n     *   <li>{@link #CONTROL_SCENE_MODE_DISABLED DISABLED}</li>\n     *   <li>{@link #CONTROL_SCENE_MODE_FACE_PRIORITY FACE_PRIORITY}</li>\n     *   <li>{@link #CONTROL_SCENE_MODE_ACTION ACTION}</li>\n     *   <li>{@link #CONTROL_SCENE_MODE_PORTRAIT PORTRAIT}</li>\n     *   <li>{@link #CONTROL_SCENE_MODE_LANDSCAPE LANDSCAPE}</li>\n     *   <li>{@link #CONTROL_SCENE_MODE_NIGHT NIGHT}</li>\n     *   <li>{@link #CONTROL_SCENE_MODE_NIGHT_PORTRAIT NIGHT_PORTRAIT}</li>\n     *   <li>{@link #CONTROL_SCENE_MODE_THEATRE THEATRE}</li>\n     *   <li>{@link #CONTROL_SCENE_MODE_BEACH BEACH}</li>\n     *   <li>{@link #CONTROL_SCENE_MODE_SNOW SNOW}</li>\n     *   <li>{@link #CONTROL_SCENE_MODE_SUNSET SUNSET}</li>\n     *   <li>{@link #CONTROL_SCENE_MODE_STEADYPHOTO STEADYPHOTO}</li>\n     *   <li>{@link #CONTROL_SCENE_MODE_FIREWORKS FIREWORKS}</li>\n     *   <li>{@link #CONTROL_SCENE_MODE_SPORTS SPORTS}</li>\n     *   <li>{@link #CONTROL_SCENE_MODE_PARTY PARTY}</li>\n     *   <li>{@link #CONTROL_SCENE_MODE_CANDLELIGHT CANDLELIGHT}</li>\n     *   <li>{@link #CONTROL_SCENE_MODE_BARCODE BARCODE}</li>\n     *   <li>{@link #CONTROL_SCENE_MODE_HIGH_SPEED_VIDEO HIGH_SPEED_VIDEO}</li>\n     *   <li>{@link #CONTROL_SCENE_MODE_HDR HDR}</li>\n     * </ul></p>\n     * <p><b>Available values for this device:</b><br>\n     * {@link CameraCharacteristics#CONTROL_AVAILABLE_SCENE_MODES android.control.availableSceneModes}</p>\n     * <p>This key is available on all devices.</p>\n     *\n     * @see CaptureRequest#CONTROL_AE_MODE\n     * @see CaptureRequest#CONTROL_AF_MODE\n     * @see CameraCharacteristics#CONTROL_AVAILABLE_SCENE_MODES\n     * @see CaptureRequest#CONTROL_AWB_MODE\n     * @see CaptureRequest#CONTROL_MODE\n     * @see #CONTROL_SCENE_MODE_DISABLED\n     * @see #CONTROL_SCENE_MODE_FACE_PRIORITY\n     * @see #CONTROL_SCENE_MODE_ACTION\n     * @see #CONTROL_SCENE_MODE_PORTRAIT\n     * @see #CONTROL_SCENE_MODE_LANDSCAPE\n     * @see #CONTROL_SCENE_MODE_NIGHT\n     * @see #CONTROL_SCENE_MODE_NIGHT_PORTRAIT\n     * @see #CONTROL_SCENE_MODE_THEATRE\n     * @see #CONTROL_SCENE_MODE_BEACH\n     * @see #CONTROL_SCENE_MODE_SNOW\n     * @see #CONTROL_SCENE_MODE_SUNSET\n     * @see #CONTROL_SCENE_MODE_STEADYPHOTO\n     * @see #CONTROL_SCENE_MODE_FIREWORKS\n     * @see #CONTROL_SCENE_MODE_SPORTS\n     * @see #CONTROL_SCENE_MODE_PARTY\n     * @see #CONTROL_SCENE_MODE_CANDLELIGHT\n     * @see #CONTROL_SCENE_MODE_BARCODE\n     * @see #CONTROL_SCENE_MODE_HIGH_SPEED_VIDEO\n     * @see #CONTROL_SCENE_MODE_HDR\n     ",
    "links" : [ "CaptureRequest#CONTROL_MODE", "CaptureRequest#CONTROL_AE_MODE", "CaptureRequest#CONTROL_AWB_MODE", "CaptureRequest#CONTROL_AF_MODE", "#CONTROL_SCENE_MODE_DISABLED", "#CONTROL_SCENE_MODE_FACE_PRIORITY", "#CONTROL_SCENE_MODE_ACTION", "#CONTROL_SCENE_MODE_PORTRAIT", "#CONTROL_SCENE_MODE_LANDSCAPE", "#CONTROL_SCENE_MODE_NIGHT", "#CONTROL_SCENE_MODE_NIGHT_PORTRAIT", "#CONTROL_SCENE_MODE_THEATRE", "#CONTROL_SCENE_MODE_BEACH", "#CONTROL_SCENE_MODE_SNOW", "#CONTROL_SCENE_MODE_SUNSET", "#CONTROL_SCENE_MODE_STEADYPHOTO", "#CONTROL_SCENE_MODE_FIREWORKS", "#CONTROL_SCENE_MODE_SPORTS", "#CONTROL_SCENE_MODE_PARTY", "#CONTROL_SCENE_MODE_CANDLELIGHT", "#CONTROL_SCENE_MODE_BARCODE", "#CONTROL_SCENE_MODE_HIGH_SPEED_VIDEO", "#CONTROL_SCENE_MODE_HDR", "CameraCharacteristics#CONTROL_AVAILABLE_SCENE_MODES" ]
  }, {
    "name" : "CONTROL_VIDEO_STABILIZATION_MODE",
    "type" : "Key<Integer>",
    "comment" : "\n     * <p>Whether video stabilization is\n     * active.</p>\n     * <p>Video stabilization automatically warps images from\n     * the camera in order to stabilize motion between consecutive frames.</p>\n     * <p>If enabled, video stabilization can modify the\n     * {@link CaptureRequest#SCALER_CROP_REGION android.scaler.cropRegion} to keep the video stream stabilized.</p>\n     * <p>Switching between different video stabilization modes may take several\n     * frames to initialize, the camera device will report the current mode\n     * in capture result metadata. For example, When \"ON\" mode is requested,\n     * the video stabilization modes in the first several capture results may\n     * still be \"OFF\", and it will become \"ON\" when the initialization is\n     * done.</p>\n     * <p>In addition, not all recording sizes or frame rates may be supported for\n     * stabilization by a device that reports stabilization support. It is guaranteed\n     * that an output targeting a MediaRecorder or MediaCodec will be stabilized if\n     * the recording resolution is less than or equal to 1920 x 1080 (width less than\n     * or equal to 1920, height less than or equal to 1080), and the recording\n     * frame rate is less than or equal to 30fps.  At other sizes, the CaptureResult\n     * {@link CaptureRequest#CONTROL_VIDEO_STABILIZATION_MODE android.control.videoStabilizationMode} field will return\n     * OFF if the recording output is not stabilized, or if there are no output\n     * Surface types that can be stabilized.</p>\n     * <p>If a camera device supports both this mode and OIS\n     * ({@link CaptureRequest#LENS_OPTICAL_STABILIZATION_MODE android.lens.opticalStabilizationMode}), turning both modes on may\n     * produce undesirable interaction, so it is recommended not to enable\n     * both at the same time.</p>\n     * <p><b>Possible values:</b>\n     * <ul>\n     *   <li>{@link #CONTROL_VIDEO_STABILIZATION_MODE_OFF OFF}</li>\n     *   <li>{@link #CONTROL_VIDEO_STABILIZATION_MODE_ON ON}</li>\n     * </ul></p>\n     * <p>This key is available on all devices.</p>\n     *\n     * @see CaptureRequest#CONTROL_VIDEO_STABILIZATION_MODE\n     * @see CaptureRequest#LENS_OPTICAL_STABILIZATION_MODE\n     * @see CaptureRequest#SCALER_CROP_REGION\n     * @see #CONTROL_VIDEO_STABILIZATION_MODE_OFF\n     * @see #CONTROL_VIDEO_STABILIZATION_MODE_ON\n     ",
    "links" : [ "CaptureRequest#SCALER_CROP_REGION", "CaptureRequest#CONTROL_VIDEO_STABILIZATION_MODE", "CaptureRequest#LENS_OPTICAL_STABILIZATION_MODE", "#CONTROL_VIDEO_STABILIZATION_MODE_OFF", "#CONTROL_VIDEO_STABILIZATION_MODE_ON" ]
  }, {
    "name" : "CONTROL_POST_RAW_SENSITIVITY_BOOST",
    "type" : "Key<Integer>",
    "comment" : "\n     * <p>The amount of additional sensitivity boost applied to output images\n     * after RAW sensor data is captured.</p>\n     * <p>Some camera devices support additional digital sensitivity boosting in the\n     * camera processing pipeline after sensor RAW image is captured.\n     * Such a boost will be applied to YUV/JPEG format output images but will not\n     * have effect on RAW output formats like RAW_SENSOR, RAW10, RAW12 or RAW_OPAQUE.</p>\n     * <p>This key will be <code>null</code> for devices that do not support any RAW format\n     * outputs. For devices that do support RAW format outputs, this key will always\n     * present, and if a device does not support post RAW sensitivity boost, it will\n     * list <code>100</code> in this key.</p>\n     * <p>If the camera device cannot apply the exact boost requested, it will reduce the\n     * boost to the nearest supported value.\n     * The final boost value used will be available in the output capture result.</p>\n     * <p>For devices that support post RAW sensitivity boost, the YUV/JPEG output images\n     * of such device will have the total sensitivity of\n     * <code>{@link CaptureRequest#SENSOR_SENSITIVITY android.sensor.sensitivity} * {@link CaptureRequest#CONTROL_POST_RAW_SENSITIVITY_BOOST android.control.postRawSensitivityBoost} / 100</code>\n     * The sensitivity of RAW format images will always be <code>{@link CaptureRequest#SENSOR_SENSITIVITY android.sensor.sensitivity}</code></p>\n     * <p>This control is only effective if {@link CaptureRequest#CONTROL_AE_MODE android.control.aeMode} or {@link CaptureRequest#CONTROL_MODE android.control.mode} is set to\n     * OFF; otherwise the auto-exposure algorithm will override this value.</p>\n     * <p><b>Units</b>: ISO arithmetic units, the same as {@link CaptureRequest#SENSOR_SENSITIVITY android.sensor.sensitivity}</p>\n     * <p><b>Range of valid values:</b><br>\n     * {@link CameraCharacteristics#CONTROL_POST_RAW_SENSITIVITY_BOOST_RANGE android.control.postRawSensitivityBoostRange}</p>\n     * <p><b>Optional</b> - The value for this key may be {@code null} on some devices.</p>\n     *\n     * @see CaptureRequest#CONTROL_AE_MODE\n     * @see CaptureRequest#CONTROL_MODE\n     * @see CaptureRequest#CONTROL_POST_RAW_SENSITIVITY_BOOST\n     * @see CameraCharacteristics#CONTROL_POST_RAW_SENSITIVITY_BOOST_RANGE\n     * @see CaptureRequest#SENSOR_SENSITIVITY\n     ",
    "links" : [ "CaptureRequest#SENSOR_SENSITIVITY", "CaptureRequest#CONTROL_POST_RAW_SENSITIVITY_BOOST", "CaptureRequest#SENSOR_SENSITIVITY", "CaptureRequest#CONTROL_AE_MODE", "CaptureRequest#CONTROL_MODE", "CaptureRequest#SENSOR_SENSITIVITY", "CameraCharacteristics#CONTROL_POST_RAW_SENSITIVITY_BOOST_RANGE" ]
  }, {
    "name" : "CONTROL_ENABLE_ZSL",
    "type" : "Key<Boolean>",
    "comment" : "\n     * <p>Allow camera device to enable zero-shutter-lag mode for requests with\n     * {@link CaptureRequest#CONTROL_CAPTURE_INTENT android.control.captureIntent} == STILL_CAPTURE.</p>\n     * <p>If enableZsl is <code>true</code>, the camera device may enable zero-shutter-lag mode for requests with\n     * STILL_CAPTURE capture intent. The camera device may use images captured in the past to\n     * produce output images for a zero-shutter-lag request. The result metadata including the\n     * {@link CaptureResult#SENSOR_TIMESTAMP android.sensor.timestamp} reflects the source frames used to produce output images.\n     * Therefore, the contents of the output images and the result metadata may be out of order\n     * compared to previous regular requests. enableZsl does not affect requests with other\n     * capture intents.</p>\n     * <p>For example, when requests are submitted in the following order:\n     *   Request A: enableZsl is ON, {@link CaptureRequest#CONTROL_CAPTURE_INTENT android.control.captureIntent} is PREVIEW\n     *   Request B: enableZsl is ON, {@link CaptureRequest#CONTROL_CAPTURE_INTENT android.control.captureIntent} is STILL_CAPTURE</p>\n     * <p>The output images for request B may have contents captured before the output images for\n     * request A, and the result metadata for request B may be older than the result metadata for\n     * request A.</p>\n     * <p>Note that when enableZsl is <code>true</code>, it is not guaranteed to get output images captured in\n     * the past for requests with STILL_CAPTURE capture intent.</p>\n     * <p>For applications targeting SDK versions O and newer, the value of enableZsl in\n     * TEMPLATE_STILL_CAPTURE template may be <code>true</code>. The value in other templates is always\n     * <code>false</code> if present.</p>\n     * <p>For applications targeting SDK versions older than O, the value of enableZsl in all\n     * capture templates is always <code>false</code> if present.</p>\n     * <p>For application-operated ZSL, use CAMERA3_TEMPLATE_ZERO_SHUTTER_LAG template.</p>\n     * <p><b>Optional</b> - The value for this key may be {@code null} on some devices.</p>\n     *\n     * @see CaptureRequest#CONTROL_CAPTURE_INTENT\n     * @see CaptureResult#SENSOR_TIMESTAMP\n     ",
    "links" : [ "CaptureRequest#CONTROL_CAPTURE_INTENT", "CaptureResult#SENSOR_TIMESTAMP", "CaptureRequest#CONTROL_CAPTURE_INTENT", "CaptureRequest#CONTROL_CAPTURE_INTENT" ]
  }, {
    "name" : "CONTROL_EXTENDED_SCENE_MODE",
    "type" : "Key<Integer>",
    "comment" : "\n     * <p>Whether extended scene mode is enabled for a particular capture request.</p>\n     * <p>With bokeh mode, the camera device may blur out the parts of scene that are not in\n     * focus, creating a bokeh (or shallow depth of field) effect for people or objects.</p>\n     * <p>When set to BOKEH_STILL_CAPTURE mode with STILL_CAPTURE capture intent, due to the extra\n     * processing needed for high quality bokeh effect, the stall may be longer than when\n     * capture intent is not STILL_CAPTURE.</p>\n     * <p>When set to BOKEH_STILL_CAPTURE mode with PREVIEW capture intent,</p>\n     * <ul>\n     * <li>If the camera device has BURST_CAPTURE capability, the frame rate requirement of\n     * BURST_CAPTURE must still be met.</li>\n     * <li>All streams not larger than the maximum streaming dimension for BOKEH_STILL_CAPTURE mode\n     * (queried via {@link android.hardware.camera2.CameraCharacteristics#CONTROL_AVAILABLE_EXTENDED_SCENE_MODE_CAPABILITIES })\n     * will have preview bokeh effect applied.</li>\n     * </ul>\n     * <p>When set to BOKEH_CONTINUOUS mode, configured streams dimension should not exceed this mode's\n     * maximum streaming dimension in order to have bokeh effect applied. Bokeh effect may not\n     * be available for streams larger than the maximum streaming dimension.</p>\n     * <p>Switching between different extended scene modes may involve reconfiguration of the camera\n     * pipeline, resulting in long latency. The application should check this key against the\n     * available session keys queried via\n     * {@link android.hardware.camera2.CameraCharacteristics#getAvailableSessionKeys }.</p>\n     * <p>For a logical multi-camera, bokeh may be implemented by stereo vision from sub-cameras\n     * with different field of view. As a result, when bokeh mode is enabled, the camera device\n     * may override {@link CaptureRequest#SCALER_CROP_REGION android.scaler.cropRegion} or {@link CaptureRequest#CONTROL_ZOOM_RATIO android.control.zoomRatio}, and the field of\n     * view may be smaller than when bokeh mode is off.</p>\n     * <p><b>Possible values:</b>\n     * <ul>\n     *   <li>{@link #CONTROL_EXTENDED_SCENE_MODE_DISABLED DISABLED}</li>\n     *   <li>{@link #CONTROL_EXTENDED_SCENE_MODE_BOKEH_STILL_CAPTURE BOKEH_STILL_CAPTURE}</li>\n     *   <li>{@link #CONTROL_EXTENDED_SCENE_MODE_BOKEH_CONTINUOUS BOKEH_CONTINUOUS}</li>\n     * </ul></p>\n     * <p><b>Optional</b> - The value for this key may be {@code null} on some devices.</p>\n     *\n     * @see CaptureRequest#CONTROL_ZOOM_RATIO\n     * @see CaptureRequest#SCALER_CROP_REGION\n     * @see #CONTROL_EXTENDED_SCENE_MODE_DISABLED\n     * @see #CONTROL_EXTENDED_SCENE_MODE_BOKEH_STILL_CAPTURE\n     * @see #CONTROL_EXTENDED_SCENE_MODE_BOKEH_CONTINUOUS\n     ",
    "links" : [ "android.hardware.camera2.CameraCharacteristics#CONTROL_AVAILABLE_EXTENDED_SCENE_MODE_CAPABILITIES", "android.hardware.camera2.CameraCharacteristics#getAvailableSessionKeys", "CaptureRequest#SCALER_CROP_REGION", "CaptureRequest#CONTROL_ZOOM_RATIO", "#CONTROL_EXTENDED_SCENE_MODE_DISABLED", "#CONTROL_EXTENDED_SCENE_MODE_BOKEH_STILL_CAPTURE", "#CONTROL_EXTENDED_SCENE_MODE_BOKEH_CONTINUOUS" ]
  }, {
    "name" : "CONTROL_ZOOM_RATIO",
    "type" : "Key<Float>",
    "comment" : "\n     * <p>The desired zoom ratio</p>\n     * <p>Instead of using {@link CaptureRequest#SCALER_CROP_REGION android.scaler.cropRegion} with dual purposes of crop and zoom, the\n     * application can now choose to use this tag to specify the desired zoom level. The\n     * {@link CaptureRequest#SCALER_CROP_REGION android.scaler.cropRegion} can still be used to specify the horizontal or vertical\n     * crop to achieve aspect ratios different than the native camera sensor.</p>\n     * <p>By using this control, the application gains a simpler way to control zoom, which can\n     * be a combination of optical and digital zoom. For example, a multi-camera system may\n     * contain more than one lens with different focal lengths, and the user can use optical\n     * zoom by switching between lenses. Using zoomRatio has benefits in the scenarios below:</p>\n     * <ul>\n     * <li>Zooming in from a wide-angle lens to a telephoto lens: A floating-point ratio provides\n     *   better precision compared to an integer value of {@link CaptureRequest#SCALER_CROP_REGION android.scaler.cropRegion}.</li>\n     * <li>Zooming out from a wide lens to an ultrawide lens: zoomRatio supports zoom-out whereas\n     *   {@link CaptureRequest#SCALER_CROP_REGION android.scaler.cropRegion} doesn't.</li>\n     * </ul>\n     * <p>To illustrate, here are several scenarios of different zoom ratios, crop regions,\n     * and output streams, for a hypothetical camera device with an active array of size\n     * <code>(2000,1500)</code>.</p>\n     * <ul>\n     * <li>Camera Configuration:<ul>\n     * <li>Active array size: <code>2000x1500</code> (3 MP, 4:3 aspect ratio)</li>\n     * <li>Output stream #1: <code>640x480</code> (VGA, 4:3 aspect ratio)</li>\n     * <li>Output stream #2: <code>1280x720</code> (720p, 16:9 aspect ratio)</li>\n     * </ul>\n     * </li>\n     * <li>Case #1: 4:3 crop region with 2.0x zoom ratio<ul>\n     * <li>Zoomed field of view: 1/4 of original field of view</li>\n     * <li>Crop region: <code>Rect(0, 0, 2000, 1500) // (left, top, right, bottom)</code> (post zoom)</li>\n     * </ul>\n     * </li>\n     * <li><img alt=\"4:3 aspect ratio crop diagram\" src=\"/reference/images/camera2/metadata/android.control.zoomRatio/zoom-ratio-2-crop-43.png\" /><ul>\n     * <li><code>640x480</code> stream source area: <code>(0, 0, 2000, 1500)</code> (equal to crop region)</li>\n     * <li><code>1280x720</code> stream source area: <code>(0, 187, 2000, 1312)</code> (letterboxed)</li>\n     * </ul>\n     * </li>\n     * <li>Case #2: 16:9 crop region with 2.0x zoom.<ul>\n     * <li>Zoomed field of view: 1/4 of original field of view</li>\n     * <li>Crop region: <code>Rect(0, 187, 2000, 1312)</code></li>\n     * <li><img alt=\"16:9 aspect ratio crop diagram\" src=\"/reference/images/camera2/metadata/android.control.zoomRatio/zoom-ratio-2-crop-169.png\" /></li>\n     * <li><code>640x480</code> stream source area: <code>(250, 187, 1750, 1312)</code> (pillarboxed)</li>\n     * <li><code>1280x720</code> stream source area: <code>(0, 187, 2000, 1312)</code> (equal to crop region)</li>\n     * </ul>\n     * </li>\n     * <li>Case #3: 1:1 crop region with 0.5x zoom out to ultrawide lens.<ul>\n     * <li>Zoomed field of view: 4x of original field of view (switched from wide lens to ultrawide lens)</li>\n     * <li>Crop region: <code>Rect(250, 0, 1750, 1500)</code></li>\n     * <li><img alt=\"1:1 aspect ratio crop diagram\" src=\"/reference/images/camera2/metadata/android.control.zoomRatio/zoom-ratio-0.5-crop-11.png\" /></li>\n     * <li><code>640x480</code> stream source area: <code>(250, 187, 1750, 1312)</code> (letterboxed)</li>\n     * <li><code>1280x720</code> stream source area: <code>(250, 328, 1750, 1172)</code> (letterboxed)</li>\n     * </ul>\n     * </li>\n     * </ul>\n     * <p>As seen from the graphs above, the coordinate system of cropRegion now changes to the\n     * effective after-zoom field-of-view, and is represented by the rectangle of (0, 0,\n     * activeArrayWith, activeArrayHeight). The same applies to AE/AWB/AF regions, and faces.\n     * This coordinate system change isn't applicable to RAW capture and its related\n     * metadata such as intrinsicCalibration and lensShadingMap.</p>\n     * <p>Using the same hypothetical example above, and assuming output stream #1 (640x480) is\n     * the viewfinder stream, the application can achieve 2.0x zoom in one of two ways:</p>\n     * <ul>\n     * <li>zoomRatio = 2.0, scaler.cropRegion = (0, 0, 2000, 1500)</li>\n     * <li>zoomRatio = 1.0 (default), scaler.cropRegion = (500, 375, 1500, 1125)</li>\n     * </ul>\n     * <p>If the application intends to set aeRegions to be top-left quarter of the viewfinder\n     * field-of-view, the {@link CaptureRequest#CONTROL_AE_REGIONS android.control.aeRegions} should be set to (0, 0, 1000, 750) with\n     * zoomRatio set to 2.0. Alternatively, the application can set aeRegions to the equivalent\n     * region of (500, 375, 1000, 750) for zoomRatio of 1.0. If the application doesn't\n     * explicitly set {@link CaptureRequest#CONTROL_ZOOM_RATIO android.control.zoomRatio}, its value defaults to 1.0.</p>\n     * <p>One limitation of controlling zoom using zoomRatio is that the {@link CaptureRequest#SCALER_CROP_REGION android.scaler.cropRegion}\n     * must only be used for letterboxing or pillarboxing of the sensor active array, and no\n     * FREEFORM cropping can be used with {@link CaptureRequest#CONTROL_ZOOM_RATIO android.control.zoomRatio} other than 1.0.</p>\n     * <p><b>Range of valid values:</b><br>\n     * {@link CameraCharacteristics#CONTROL_ZOOM_RATIO_RANGE android.control.zoomRatioRange}</p>\n     * <p><b>Optional</b> - The value for this key may be {@code null} on some devices.</p>\n     * <p><b>Limited capability</b> -\n     * Present on all camera devices that report being at least {@link CameraCharacteristics#INFO_SUPPORTED_HARDWARE_LEVEL_LIMITED HARDWARE_LEVEL_LIMITED} devices in the\n     * {@link CameraCharacteristics#INFO_SUPPORTED_HARDWARE_LEVEL android.info.supportedHardwareLevel} key</p>\n     *\n     * @see CaptureRequest#CONTROL_AE_REGIONS\n     * @see CaptureRequest#CONTROL_ZOOM_RATIO\n     * @see CameraCharacteristics#CONTROL_ZOOM_RATIO_RANGE\n     * @see CameraCharacteristics#INFO_SUPPORTED_HARDWARE_LEVEL\n     * @see CaptureRequest#SCALER_CROP_REGION\n     ",
    "links" : [ "CaptureRequest#SCALER_CROP_REGION", "CaptureRequest#SCALER_CROP_REGION", "CaptureRequest#SCALER_CROP_REGION", "CaptureRequest#SCALER_CROP_REGION", "CaptureRequest#CONTROL_AE_REGIONS", "CaptureRequest#CONTROL_ZOOM_RATIO", "CaptureRequest#SCALER_CROP_REGION", "CaptureRequest#CONTROL_ZOOM_RATIO", "CameraCharacteristics#CONTROL_ZOOM_RATIO_RANGE", "CameraCharacteristics#INFO_SUPPORTED_HARDWARE_LEVEL_LIMITED", "CameraCharacteristics#INFO_SUPPORTED_HARDWARE_LEVEL" ]
  }, {
    "name" : "EDGE_MODE",
    "type" : "Key<Integer>",
    "comment" : "\n     * <p>Operation mode for edge\n     * enhancement.</p>\n     * <p>Edge enhancement improves sharpness and details in the captured image. OFF means\n     * no enhancement will be applied by the camera device.</p>\n     * <p>FAST/HIGH_QUALITY both mean camera device determined enhancement\n     * will be applied. HIGH_QUALITY mode indicates that the\n     * camera device will use the highest-quality enhancement algorithms,\n     * even if it slows down capture rate. FAST means the camera device will\n     * not slow down capture rate when applying edge enhancement. FAST may be the same as OFF if\n     * edge enhancement will slow down capture rate. Every output stream will have a similar\n     * amount of enhancement applied.</p>\n     * <p>ZERO_SHUTTER_LAG is meant to be used by applications that maintain a continuous circular\n     * buffer of high-resolution images during preview and reprocess image(s) from that buffer\n     * into a final capture when triggered by the user. In this mode, the camera device applies\n     * edge enhancement to low-resolution streams (below maximum recording resolution) to\n     * maximize preview quality, but does not apply edge enhancement to high-resolution streams,\n     * since those will be reprocessed later if necessary.</p>\n     * <p>For YUV_REPROCESSING, these FAST/HIGH_QUALITY modes both mean that the camera\n     * device will apply FAST/HIGH_QUALITY YUV-domain edge enhancement, respectively.\n     * The camera device may adjust its internal edge enhancement parameters for best\n     * image quality based on the {@link CaptureRequest#REPROCESS_EFFECTIVE_EXPOSURE_FACTOR android.reprocess.effectiveExposureFactor}, if it is set.</p>\n     * <p><b>Possible values:</b>\n     * <ul>\n     *   <li>{@link #EDGE_MODE_OFF OFF}</li>\n     *   <li>{@link #EDGE_MODE_FAST FAST}</li>\n     *   <li>{@link #EDGE_MODE_HIGH_QUALITY HIGH_QUALITY}</li>\n     *   <li>{@link #EDGE_MODE_ZERO_SHUTTER_LAG ZERO_SHUTTER_LAG}</li>\n     * </ul></p>\n     * <p><b>Available values for this device:</b><br>\n     * {@link CameraCharacteristics#EDGE_AVAILABLE_EDGE_MODES android.edge.availableEdgeModes}</p>\n     * <p><b>Optional</b> - The value for this key may be {@code null} on some devices.</p>\n     * <p><b>Full capability</b> -\n     * Present on all camera devices that report being {@link CameraCharacteristics#INFO_SUPPORTED_HARDWARE_LEVEL_FULL HARDWARE_LEVEL_FULL} devices in the\n     * {@link CameraCharacteristics#INFO_SUPPORTED_HARDWARE_LEVEL android.info.supportedHardwareLevel} key</p>\n     *\n     * @see CameraCharacteristics#EDGE_AVAILABLE_EDGE_MODES\n     * @see CameraCharacteristics#INFO_SUPPORTED_HARDWARE_LEVEL\n     * @see CaptureRequest#REPROCESS_EFFECTIVE_EXPOSURE_FACTOR\n     * @see #EDGE_MODE_OFF\n     * @see #EDGE_MODE_FAST\n     * @see #EDGE_MODE_HIGH_QUALITY\n     * @see #EDGE_MODE_ZERO_SHUTTER_LAG\n     ",
    "links" : [ "CaptureRequest#REPROCESS_EFFECTIVE_EXPOSURE_FACTOR", "#EDGE_MODE_OFF", "#EDGE_MODE_FAST", "#EDGE_MODE_HIGH_QUALITY", "#EDGE_MODE_ZERO_SHUTTER_LAG", "CameraCharacteristics#EDGE_AVAILABLE_EDGE_MODES", "CameraCharacteristics#INFO_SUPPORTED_HARDWARE_LEVEL_FULL", "CameraCharacteristics#INFO_SUPPORTED_HARDWARE_LEVEL" ]
  }, {
    "name" : "FLASH_MODE",
    "type" : "Key<Integer>",
    "comment" : "\n     * <p>The desired mode for for the camera device's flash control.</p>\n     * <p>This control is only effective when flash unit is available\n     * (<code>{@link CameraCharacteristics#FLASH_INFO_AVAILABLE android.flash.info.available} == true</code>).</p>\n     * <p>When this control is used, the {@link CaptureRequest#CONTROL_AE_MODE android.control.aeMode} must be set to ON or OFF.\n     * Otherwise, the camera device auto-exposure related flash control (ON_AUTO_FLASH,\n     * ON_ALWAYS_FLASH, or ON_AUTO_FLASH_REDEYE) will override this control.</p>\n     * <p>When set to OFF, the camera device will not fire flash for this capture.</p>\n     * <p>When set to SINGLE, the camera device will fire flash regardless of the camera\n     * device's auto-exposure routine's result. When used in still capture case, this\n     * control should be used along with auto-exposure (AE) precapture metering sequence\n     * ({@link CaptureRequest#CONTROL_AE_PRECAPTURE_TRIGGER android.control.aePrecaptureTrigger}), otherwise, the image may be incorrectly exposed.</p>\n     * <p>When set to TORCH, the flash will be on continuously. This mode can be used\n     * for use cases such as preview, auto-focus assist, still capture, or video recording.</p>\n     * <p>The flash status will be reported by {@link CaptureResult#FLASH_STATE android.flash.state} in the capture result metadata.</p>\n     * <p><b>Possible values:</b>\n     * <ul>\n     *   <li>{@link #FLASH_MODE_OFF OFF}</li>\n     *   <li>{@link #FLASH_MODE_SINGLE SINGLE}</li>\n     *   <li>{@link #FLASH_MODE_TORCH TORCH}</li>\n     * </ul></p>\n     * <p>This key is available on all devices.</p>\n     *\n     * @see CaptureRequest#CONTROL_AE_MODE\n     * @see CaptureRequest#CONTROL_AE_PRECAPTURE_TRIGGER\n     * @see CameraCharacteristics#FLASH_INFO_AVAILABLE\n     * @see CaptureResult#FLASH_STATE\n     * @see #FLASH_MODE_OFF\n     * @see #FLASH_MODE_SINGLE\n     * @see #FLASH_MODE_TORCH\n     ",
    "links" : [ "CameraCharacteristics#FLASH_INFO_AVAILABLE", "CaptureRequest#CONTROL_AE_MODE", "CaptureRequest#CONTROL_AE_PRECAPTURE_TRIGGER", "CaptureResult#FLASH_STATE", "#FLASH_MODE_OFF", "#FLASH_MODE_SINGLE", "#FLASH_MODE_TORCH" ]
  }, {
    "name" : "HOT_PIXEL_MODE",
    "type" : "Key<Integer>",
    "comment" : "\n     * <p>Operational mode for hot pixel correction.</p>\n     * <p>Hotpixel correction interpolates out, or otherwise removes, pixels\n     * that do not accurately measure the incoming light (i.e. pixels that\n     * are stuck at an arbitrary value or are oversensitive).</p>\n     * <p><b>Possible values:</b>\n     * <ul>\n     *   <li>{@link #HOT_PIXEL_MODE_OFF OFF}</li>\n     *   <li>{@link #HOT_PIXEL_MODE_FAST FAST}</li>\n     *   <li>{@link #HOT_PIXEL_MODE_HIGH_QUALITY HIGH_QUALITY}</li>\n     * </ul></p>\n     * <p><b>Available values for this device:</b><br>\n     * {@link CameraCharacteristics#HOT_PIXEL_AVAILABLE_HOT_PIXEL_MODES android.hotPixel.availableHotPixelModes}</p>\n     * <p><b>Optional</b> - The value for this key may be {@code null} on some devices.</p>\n     *\n     * @see CameraCharacteristics#HOT_PIXEL_AVAILABLE_HOT_PIXEL_MODES\n     * @see #HOT_PIXEL_MODE_OFF\n     * @see #HOT_PIXEL_MODE_FAST\n     * @see #HOT_PIXEL_MODE_HIGH_QUALITY\n     ",
    "links" : [ "#HOT_PIXEL_MODE_OFF", "#HOT_PIXEL_MODE_FAST", "#HOT_PIXEL_MODE_HIGH_QUALITY", "CameraCharacteristics#HOT_PIXEL_AVAILABLE_HOT_PIXEL_MODES" ]
  }, {
    "name" : "JPEG_GPS_LOCATION",
    "type" : "Key<android.location.Location>",
    "comment" : "\n     * <p>A location object to use when generating image GPS metadata.</p>\n     * <p>Setting a location object in a request will include the GPS coordinates of the location\n     * into any JPEG images captured based on the request. These coordinates can then be\n     * viewed by anyone who receives the JPEG image.</p>\n     * <p>This tag is also used for HEIC image capture.</p>\n     * <p>This key is available on all devices.</p>\n     ",
    "links" : [ ]
  }, {
    "name" : "JPEG_GPS_COORDINATES",
    "type" : "Key<double[]>",
    "comment" : "\n     * <p>GPS coordinates to include in output JPEG\n     * EXIF.</p>\n     * <p>This tag is also used for HEIC image capture.</p>\n     * <p><b>Range of valid values:</b><br>\n     * (-180 - 180], [-90,90], [-inf, inf]</p>\n     * <p>This key is available on all devices.</p>\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "JPEG_GPS_PROCESSING_METHOD",
    "type" : "Key<String>",
    "comment" : "\n     * <p>32 characters describing GPS algorithm to\n     * include in EXIF.</p>\n     * <p>This tag is also used for HEIC image capture.</p>\n     * <p>This key is available on all devices.</p>\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "JPEG_GPS_TIMESTAMP",
    "type" : "Key<Long>",
    "comment" : "\n     * <p>Time GPS fix was made to include in\n     * EXIF.</p>\n     * <p>This tag is also used for HEIC image capture.</p>\n     * <p><b>Units</b>: UTC in seconds since January 1, 1970</p>\n     * <p>This key is available on all devices.</p>\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "JPEG_ORIENTATION",
    "type" : "Key<Integer>",
    "comment" : "\n     * <p>The orientation for a JPEG image.</p>\n     * <p>The clockwise rotation angle in degrees, relative to the orientation\n     * to the camera, that the JPEG picture needs to be rotated by, to be viewed\n     * upright.</p>\n     * <p>Camera devices may either encode this value into the JPEG EXIF header, or\n     * rotate the image data to match this orientation. When the image data is rotated,\n     * the thumbnail data will also be rotated.</p>\n     * <p>Note that this orientation is relative to the orientation of the camera sensor, given\n     * by {@link CameraCharacteristics#SENSOR_ORIENTATION android.sensor.orientation}.</p>\n     * <p>To translate from the device orientation given by the Android sensor APIs for camera\n     * sensors which are not EXTERNAL, the following sample code may be used:</p>\n     * <pre><code>private int getJpegOrientation(CameraCharacteristics c, int deviceOrientation) {\n     *     if (deviceOrientation == android.view.OrientationEventListener.ORIENTATION_UNKNOWN) return 0;\n     *     int sensorOrientation = c.get(CameraCharacteristics.SENSOR_ORIENTATION);\n     *\n     *     // Round device orientation to a multiple of 90\n     *     deviceOrientation = (deviceOrientation + 45) / 90 * 90;\n     *\n     *     // Reverse device orientation for front-facing cameras\n     *     boolean facingFront = c.get(CameraCharacteristics.LENS_FACING) == CameraCharacteristics.LENS_FACING_FRONT;\n     *     if (facingFront) deviceOrientation = -deviceOrientation;\n     *\n     *     // Calculate desired JPEG orientation relative to camera orientation to make\n     *     // the image upright relative to the device orientation\n     *     int jpegOrientation = (sensorOrientation + deviceOrientation + 360) % 360;\n     *\n     *     return jpegOrientation;\n     * }\n     * </code></pre>\n     * <p>For EXTERNAL cameras the sensor orientation will always be set to 0 and the facing will\n     * also be set to EXTERNAL. The above code is not relevant in such case.</p>\n     * <p>This tag is also used to describe the orientation of the HEIC image capture, in which\n     * case the rotation is reflected by\n     * {@link android.media.ExifInterface#TAG_ORIENTATION EXIF orientation flag}, and not by\n     * rotating the image data itself.</p>\n     * <p><b>Units</b>: Degrees in multiples of 90</p>\n     * <p><b>Range of valid values:</b><br>\n     * 0, 90, 180, 270</p>\n     * <p>This key is available on all devices.</p>\n     *\n     * @see CameraCharacteristics#SENSOR_ORIENTATION\n     ",
    "links" : [ "CameraCharacteristics#SENSOR_ORIENTATION", "android.media.ExifInterface#TAG_ORIENTATION" ]
  }, {
    "name" : "JPEG_QUALITY",
    "type" : "Key<Byte>",
    "comment" : "\n     * <p>Compression quality of the final JPEG\n     * image.</p>\n     * <p>85-95 is typical usage range. This tag is also used to describe the quality\n     * of the HEIC image capture.</p>\n     * <p><b>Range of valid values:</b><br>\n     * 1-100; larger is higher quality</p>\n     * <p>This key is available on all devices.</p>\n     ",
    "links" : [ ]
  }, {
    "name" : "JPEG_THUMBNAIL_QUALITY",
    "type" : "Key<Byte>",
    "comment" : "\n     * <p>Compression quality of JPEG\n     * thumbnail.</p>\n     * <p>This tag is also used to describe the quality of the HEIC image capture.</p>\n     * <p><b>Range of valid values:</b><br>\n     * 1-100; larger is higher quality</p>\n     * <p>This key is available on all devices.</p>\n     ",
    "links" : [ ]
  }, {
    "name" : "JPEG_THUMBNAIL_SIZE",
    "type" : "Key<android.util.Size>",
    "comment" : "\n     * <p>Resolution of embedded JPEG thumbnail.</p>\n     * <p>When set to (0, 0) value, the JPEG EXIF will not contain thumbnail,\n     * but the captured JPEG will still be a valid image.</p>\n     * <p>For best results, when issuing a request for a JPEG image, the thumbnail size selected\n     * should have the same aspect ratio as the main JPEG output.</p>\n     * <p>If the thumbnail image aspect ratio differs from the JPEG primary image aspect\n     * ratio, the camera device creates the thumbnail by cropping it from the primary image.\n     * For example, if the primary image has 4:3 aspect ratio, the thumbnail image has\n     * 16:9 aspect ratio, the primary image will be cropped vertically (letterbox) to\n     * generate the thumbnail image. The thumbnail image will always have a smaller Field\n     * Of View (FOV) than the primary image when aspect ratios differ.</p>\n     * <p>When an {@link CaptureRequest#JPEG_ORIENTATION android.jpeg.orientation} of non-zero degree is requested,\n     * the camera device will handle thumbnail rotation in one of the following ways:</p>\n     * <ul>\n     * <li>Set the {@link android.media.ExifInterface#TAG_ORIENTATION EXIF orientation flag}\n     *   and keep jpeg and thumbnail image data unrotated.</li>\n     * <li>Rotate the jpeg and thumbnail image data and not set\n     *   {@link android.media.ExifInterface#TAG_ORIENTATION EXIF orientation flag}. In this\n     *   case, LIMITED or FULL hardware level devices will report rotated thumnail size in\n     *   capture result, so the width and height will be interchanged if 90 or 270 degree\n     *   orientation is requested. LEGACY device will always report unrotated thumbnail\n     *   size.</li>\n     * </ul>\n     * <p>The tag is also used as thumbnail size for HEIC image format capture, in which case the\n     * the thumbnail rotation is reflected by\n     * {@link android.media.ExifInterface#TAG_ORIENTATION EXIF orientation flag}, and not by\n     * rotating the thumbnail data itself.</p>\n     * <p><b>Range of valid values:</b><br>\n     * {@link CameraCharacteristics#JPEG_AVAILABLE_THUMBNAIL_SIZES android.jpeg.availableThumbnailSizes}</p>\n     * <p>This key is available on all devices.</p>\n     *\n     * @see CameraCharacteristics#JPEG_AVAILABLE_THUMBNAIL_SIZES\n     * @see CaptureRequest#JPEG_ORIENTATION\n     ",
    "links" : [ "CaptureRequest#JPEG_ORIENTATION", "android.media.ExifInterface#TAG_ORIENTATION", "android.media.ExifInterface#TAG_ORIENTATION", "android.media.ExifInterface#TAG_ORIENTATION", "CameraCharacteristics#JPEG_AVAILABLE_THUMBNAIL_SIZES" ]
  }, {
    "name" : "LENS_APERTURE",
    "type" : "Key<Float>",
    "comment" : "\n     * <p>The desired lens aperture size, as a ratio of lens focal length to the\n     * effective aperture diameter.</p>\n     * <p>Setting this value is only supported on the camera devices that have a variable\n     * aperture lens.</p>\n     * <p>When this is supported and {@link CaptureRequest#CONTROL_AE_MODE android.control.aeMode} is OFF,\n     * this can be set along with {@link CaptureRequest#SENSOR_EXPOSURE_TIME android.sensor.exposureTime},\n     * {@link CaptureRequest#SENSOR_SENSITIVITY android.sensor.sensitivity}, and {@link CaptureRequest#SENSOR_FRAME_DURATION android.sensor.frameDuration}\n     * to achieve manual exposure control.</p>\n     * <p>The requested aperture value may take several frames to reach the\n     * requested value; the camera device will report the current (intermediate)\n     * aperture size in capture result metadata while the aperture is changing.\n     * While the aperture is still changing, {@link CaptureResult#LENS_STATE android.lens.state} will be set to MOVING.</p>\n     * <p>When this is supported and {@link CaptureRequest#CONTROL_AE_MODE android.control.aeMode} is one of\n     * the ON modes, this will be overridden by the camera device\n     * auto-exposure algorithm, the overridden values are then provided\n     * back to the user in the corresponding result.</p>\n     * <p><b>Units</b>: The f-number (f/N)</p>\n     * <p><b>Range of valid values:</b><br>\n     * {@link CameraCharacteristics#LENS_INFO_AVAILABLE_APERTURES android.lens.info.availableApertures}</p>\n     * <p><b>Optional</b> - The value for this key may be {@code null} on some devices.</p>\n     * <p><b>Full capability</b> -\n     * Present on all camera devices that report being {@link CameraCharacteristics#INFO_SUPPORTED_HARDWARE_LEVEL_FULL HARDWARE_LEVEL_FULL} devices in the\n     * {@link CameraCharacteristics#INFO_SUPPORTED_HARDWARE_LEVEL android.info.supportedHardwareLevel} key</p>\n     *\n     * @see CaptureRequest#CONTROL_AE_MODE\n     * @see CameraCharacteristics#INFO_SUPPORTED_HARDWARE_LEVEL\n     * @see CameraCharacteristics#LENS_INFO_AVAILABLE_APERTURES\n     * @see CaptureResult#LENS_STATE\n     * @see CaptureRequest#SENSOR_EXPOSURE_TIME\n     * @see CaptureRequest#SENSOR_FRAME_DURATION\n     * @see CaptureRequest#SENSOR_SENSITIVITY\n     ",
    "links" : [ "CaptureRequest#CONTROL_AE_MODE", "CaptureRequest#SENSOR_EXPOSURE_TIME", "CaptureRequest#SENSOR_SENSITIVITY", "CaptureRequest#SENSOR_FRAME_DURATION", "CaptureResult#LENS_STATE", "CaptureRequest#CONTROL_AE_MODE", "CameraCharacteristics#LENS_INFO_AVAILABLE_APERTURES", "CameraCharacteristics#INFO_SUPPORTED_HARDWARE_LEVEL_FULL", "CameraCharacteristics#INFO_SUPPORTED_HARDWARE_LEVEL" ]
  }, {
    "name" : "LENS_FILTER_DENSITY",
    "type" : "Key<Float>",
    "comment" : "\n     * <p>The desired setting for the lens neutral density filter(s).</p>\n     * <p>This control will not be supported on most camera devices.</p>\n     * <p>Lens filters are typically used to lower the amount of light the\n     * sensor is exposed to (measured in steps of EV). As used here, an EV\n     * step is the standard logarithmic representation, which are\n     * non-negative, and inversely proportional to the amount of light\n     * hitting the sensor.  For example, setting this to 0 would result\n     * in no reduction of the incoming light, and setting this to 2 would\n     * mean that the filter is set to reduce incoming light by two stops\n     * (allowing 1/4 of the prior amount of light to the sensor).</p>\n     * <p>It may take several frames before the lens filter density changes\n     * to the requested value. While the filter density is still changing,\n     * {@link CaptureResult#LENS_STATE android.lens.state} will be set to MOVING.</p>\n     * <p><b>Units</b>: Exposure Value (EV)</p>\n     * <p><b>Range of valid values:</b><br>\n     * {@link CameraCharacteristics#LENS_INFO_AVAILABLE_FILTER_DENSITIES android.lens.info.availableFilterDensities}</p>\n     * <p><b>Optional</b> - The value for this key may be {@code null} on some devices.</p>\n     * <p><b>Full capability</b> -\n     * Present on all camera devices that report being {@link CameraCharacteristics#INFO_SUPPORTED_HARDWARE_LEVEL_FULL HARDWARE_LEVEL_FULL} devices in the\n     * {@link CameraCharacteristics#INFO_SUPPORTED_HARDWARE_LEVEL android.info.supportedHardwareLevel} key</p>\n     *\n     * @see CameraCharacteristics#INFO_SUPPORTED_HARDWARE_LEVEL\n     * @see CameraCharacteristics#LENS_INFO_AVAILABLE_FILTER_DENSITIES\n     * @see CaptureResult#LENS_STATE\n     ",
    "links" : [ "CaptureResult#LENS_STATE", "CameraCharacteristics#LENS_INFO_AVAILABLE_FILTER_DENSITIES", "CameraCharacteristics#INFO_SUPPORTED_HARDWARE_LEVEL_FULL", "CameraCharacteristics#INFO_SUPPORTED_HARDWARE_LEVEL" ]
  }, {
    "name" : "LENS_FOCAL_LENGTH",
    "type" : "Key<Float>",
    "comment" : "\n     * <p>The desired lens focal length; used for optical zoom.</p>\n     * <p>This setting controls the physical focal length of the camera\n     * device's lens. Changing the focal length changes the field of\n     * view of the camera device, and is usually used for optical zoom.</p>\n     * <p>Like {@link CaptureRequest#LENS_FOCUS_DISTANCE android.lens.focusDistance} and {@link CaptureRequest#LENS_APERTURE android.lens.aperture}, this\n     * setting won't be applied instantaneously, and it may take several\n     * frames before the lens can change to the requested focal length.\n     * While the focal length is still changing, {@link CaptureResult#LENS_STATE android.lens.state} will\n     * be set to MOVING.</p>\n     * <p>Optical zoom via this control will not be supported on most devices. Starting from API\n     * level 30, the camera device may combine optical and digital zoom through the\n     * {@link CaptureRequest#CONTROL_ZOOM_RATIO android.control.zoomRatio} control.</p>\n     * <p><b>Units</b>: Millimeters</p>\n     * <p><b>Range of valid values:</b><br>\n     * {@link CameraCharacteristics#LENS_INFO_AVAILABLE_FOCAL_LENGTHS android.lens.info.availableFocalLengths}</p>\n     * <p>This key is available on all devices.</p>\n     *\n     * @see CaptureRequest#CONTROL_ZOOM_RATIO\n     * @see CaptureRequest#LENS_APERTURE\n     * @see CaptureRequest#LENS_FOCUS_DISTANCE\n     * @see CameraCharacteristics#LENS_INFO_AVAILABLE_FOCAL_LENGTHS\n     * @see CaptureResult#LENS_STATE\n     ",
    "links" : [ "CaptureRequest#LENS_FOCUS_DISTANCE", "CaptureRequest#LENS_APERTURE", "CaptureResult#LENS_STATE", "CaptureRequest#CONTROL_ZOOM_RATIO", "CameraCharacteristics#LENS_INFO_AVAILABLE_FOCAL_LENGTHS" ]
  }, {
    "name" : "LENS_FOCUS_DISTANCE",
    "type" : "Key<Float>",
    "comment" : "\n     * <p>Desired distance to plane of sharpest focus,\n     * measured from frontmost surface of the lens.</p>\n     * <p>This control can be used for setting manual focus, on devices that support\n     * the MANUAL_SENSOR capability and have a variable-focus lens (see\n     * {@link CameraCharacteristics#LENS_INFO_MINIMUM_FOCUS_DISTANCE android.lens.info.minimumFocusDistance}).</p>\n     * <p>A value of <code>0.0f</code> means infinity focus. The value set will be clamped to\n     * <code>[0.0f, {@link CameraCharacteristics#LENS_INFO_MINIMUM_FOCUS_DISTANCE android.lens.info.minimumFocusDistance}]</code>.</p>\n     * <p>Like {@link CaptureRequest#LENS_FOCAL_LENGTH android.lens.focalLength}, this setting won't be applied\n     * instantaneously, and it may take several frames before the lens\n     * can move to the requested focus distance. While the lens is still moving,\n     * {@link CaptureResult#LENS_STATE android.lens.state} will be set to MOVING.</p>\n     * <p>LEGACY devices support at most setting this to <code>0.0f</code>\n     * for infinity focus.</p>\n     * <p><b>Units</b>: See {@link CameraCharacteristics#LENS_INFO_FOCUS_DISTANCE_CALIBRATION android.lens.info.focusDistanceCalibration} for details</p>\n     * <p><b>Range of valid values:</b><br>\n     * &gt;= 0</p>\n     * <p><b>Optional</b> - The value for this key may be {@code null} on some devices.</p>\n     * <p><b>Full capability</b> -\n     * Present on all camera devices that report being {@link CameraCharacteristics#INFO_SUPPORTED_HARDWARE_LEVEL_FULL HARDWARE_LEVEL_FULL} devices in the\n     * {@link CameraCharacteristics#INFO_SUPPORTED_HARDWARE_LEVEL android.info.supportedHardwareLevel} key</p>\n     *\n     * @see CameraCharacteristics#INFO_SUPPORTED_HARDWARE_LEVEL\n     * @see CaptureRequest#LENS_FOCAL_LENGTH\n     * @see CameraCharacteristics#LENS_INFO_FOCUS_DISTANCE_CALIBRATION\n     * @see CameraCharacteristics#LENS_INFO_MINIMUM_FOCUS_DISTANCE\n     * @see CaptureResult#LENS_STATE\n     ",
    "links" : [ "CameraCharacteristics#LENS_INFO_MINIMUM_FOCUS_DISTANCE", "CameraCharacteristics#LENS_INFO_MINIMUM_FOCUS_DISTANCE", "CaptureRequest#LENS_FOCAL_LENGTH", "CaptureResult#LENS_STATE", "CameraCharacteristics#LENS_INFO_FOCUS_DISTANCE_CALIBRATION", "CameraCharacteristics#INFO_SUPPORTED_HARDWARE_LEVEL_FULL", "CameraCharacteristics#INFO_SUPPORTED_HARDWARE_LEVEL" ]
  }, {
    "name" : "LENS_OPTICAL_STABILIZATION_MODE",
    "type" : "Key<Integer>",
    "comment" : "\n     * <p>Sets whether the camera device uses optical image stabilization (OIS)\n     * when capturing images.</p>\n     * <p>OIS is used to compensate for motion blur due to small\n     * movements of the camera during capture. Unlike digital image\n     * stabilization ({@link CaptureRequest#CONTROL_VIDEO_STABILIZATION_MODE android.control.videoStabilizationMode}), OIS\n     * makes use of mechanical elements to stabilize the camera\n     * sensor, and thus allows for longer exposure times before\n     * camera shake becomes apparent.</p>\n     * <p>Switching between different optical stabilization modes may take several\n     * frames to initialize, the camera device will report the current mode in\n     * capture result metadata. For example, When \"ON\" mode is requested, the\n     * optical stabilization modes in the first several capture results may still\n     * be \"OFF\", and it will become \"ON\" when the initialization is done.</p>\n     * <p>If a camera device supports both OIS and digital image stabilization\n     * ({@link CaptureRequest#CONTROL_VIDEO_STABILIZATION_MODE android.control.videoStabilizationMode}), turning both modes on may produce undesirable\n     * interaction, so it is recommended not to enable both at the same time.</p>\n     * <p>Not all devices will support OIS; see\n     * {@link CameraCharacteristics#LENS_INFO_AVAILABLE_OPTICAL_STABILIZATION android.lens.info.availableOpticalStabilization} for\n     * available controls.</p>\n     * <p><b>Possible values:</b>\n     * <ul>\n     *   <li>{@link #LENS_OPTICAL_STABILIZATION_MODE_OFF OFF}</li>\n     *   <li>{@link #LENS_OPTICAL_STABILIZATION_MODE_ON ON}</li>\n     * </ul></p>\n     * <p><b>Available values for this device:</b><br>\n     * {@link CameraCharacteristics#LENS_INFO_AVAILABLE_OPTICAL_STABILIZATION android.lens.info.availableOpticalStabilization}</p>\n     * <p><b>Optional</b> - The value for this key may be {@code null} on some devices.</p>\n     * <p><b>Limited capability</b> -\n     * Present on all camera devices that report being at least {@link CameraCharacteristics#INFO_SUPPORTED_HARDWARE_LEVEL_LIMITED HARDWARE_LEVEL_LIMITED} devices in the\n     * {@link CameraCharacteristics#INFO_SUPPORTED_HARDWARE_LEVEL android.info.supportedHardwareLevel} key</p>\n     *\n     * @see CaptureRequest#CONTROL_VIDEO_STABILIZATION_MODE\n     * @see CameraCharacteristics#INFO_SUPPORTED_HARDWARE_LEVEL\n     * @see CameraCharacteristics#LENS_INFO_AVAILABLE_OPTICAL_STABILIZATION\n     * @see #LENS_OPTICAL_STABILIZATION_MODE_OFF\n     * @see #LENS_OPTICAL_STABILIZATION_MODE_ON\n     ",
    "links" : [ "CaptureRequest#CONTROL_VIDEO_STABILIZATION_MODE", "CaptureRequest#CONTROL_VIDEO_STABILIZATION_MODE", "CameraCharacteristics#LENS_INFO_AVAILABLE_OPTICAL_STABILIZATION", "#LENS_OPTICAL_STABILIZATION_MODE_OFF", "#LENS_OPTICAL_STABILIZATION_MODE_ON", "CameraCharacteristics#LENS_INFO_AVAILABLE_OPTICAL_STABILIZATION", "CameraCharacteristics#INFO_SUPPORTED_HARDWARE_LEVEL_LIMITED", "CameraCharacteristics#INFO_SUPPORTED_HARDWARE_LEVEL" ]
  }, {
    "name" : "NOISE_REDUCTION_MODE",
    "type" : "Key<Integer>",
    "comment" : "\n     * <p>Mode of operation for the noise reduction algorithm.</p>\n     * <p>The noise reduction algorithm attempts to improve image quality by removing\n     * excessive noise added by the capture process, especially in dark conditions.</p>\n     * <p>OFF means no noise reduction will be applied by the camera device, for both raw and\n     * YUV domain.</p>\n     * <p>MINIMAL means that only sensor raw domain basic noise reduction is enabled ,to remove\n     * demosaicing or other processing artifacts. For YUV_REPROCESSING, MINIMAL is same as OFF.\n     * This mode is optional, may not be support by all devices. The application should check\n     * {@link CameraCharacteristics#NOISE_REDUCTION_AVAILABLE_NOISE_REDUCTION_MODES android.noiseReduction.availableNoiseReductionModes} before using it.</p>\n     * <p>FAST/HIGH_QUALITY both mean camera device determined noise filtering\n     * will be applied. HIGH_QUALITY mode indicates that the camera device\n     * will use the highest-quality noise filtering algorithms,\n     * even if it slows down capture rate. FAST means the camera device will not\n     * slow down capture rate when applying noise filtering. FAST may be the same as MINIMAL if\n     * MINIMAL is listed, or the same as OFF if any noise filtering will slow down capture rate.\n     * Every output stream will have a similar amount of enhancement applied.</p>\n     * <p>ZERO_SHUTTER_LAG is meant to be used by applications that maintain a continuous circular\n     * buffer of high-resolution images during preview and reprocess image(s) from that buffer\n     * into a final capture when triggered by the user. In this mode, the camera device applies\n     * noise reduction to low-resolution streams (below maximum recording resolution) to maximize\n     * preview quality, but does not apply noise reduction to high-resolution streams, since\n     * those will be reprocessed later if necessary.</p>\n     * <p>For YUV_REPROCESSING, these FAST/HIGH_QUALITY modes both mean that the camera device\n     * will apply FAST/HIGH_QUALITY YUV domain noise reduction, respectively. The camera device\n     * may adjust the noise reduction parameters for best image quality based on the\n     * {@link CaptureRequest#REPROCESS_EFFECTIVE_EXPOSURE_FACTOR android.reprocess.effectiveExposureFactor} if it is set.</p>\n     * <p><b>Possible values:</b>\n     * <ul>\n     *   <li>{@link #NOISE_REDUCTION_MODE_OFF OFF}</li>\n     *   <li>{@link #NOISE_REDUCTION_MODE_FAST FAST}</li>\n     *   <li>{@link #NOISE_REDUCTION_MODE_HIGH_QUALITY HIGH_QUALITY}</li>\n     *   <li>{@link #NOISE_REDUCTION_MODE_MINIMAL MINIMAL}</li>\n     *   <li>{@link #NOISE_REDUCTION_MODE_ZERO_SHUTTER_LAG ZERO_SHUTTER_LAG}</li>\n     * </ul></p>\n     * <p><b>Available values for this device:</b><br>\n     * {@link CameraCharacteristics#NOISE_REDUCTION_AVAILABLE_NOISE_REDUCTION_MODES android.noiseReduction.availableNoiseReductionModes}</p>\n     * <p><b>Optional</b> - The value for this key may be {@code null} on some devices.</p>\n     * <p><b>Full capability</b> -\n     * Present on all camera devices that report being {@link CameraCharacteristics#INFO_SUPPORTED_HARDWARE_LEVEL_FULL HARDWARE_LEVEL_FULL} devices in the\n     * {@link CameraCharacteristics#INFO_SUPPORTED_HARDWARE_LEVEL android.info.supportedHardwareLevel} key</p>\n     *\n     * @see CameraCharacteristics#INFO_SUPPORTED_HARDWARE_LEVEL\n     * @see CameraCharacteristics#NOISE_REDUCTION_AVAILABLE_NOISE_REDUCTION_MODES\n     * @see CaptureRequest#REPROCESS_EFFECTIVE_EXPOSURE_FACTOR\n     * @see #NOISE_REDUCTION_MODE_OFF\n     * @see #NOISE_REDUCTION_MODE_FAST\n     * @see #NOISE_REDUCTION_MODE_HIGH_QUALITY\n     * @see #NOISE_REDUCTION_MODE_MINIMAL\n     * @see #NOISE_REDUCTION_MODE_ZERO_SHUTTER_LAG\n     ",
    "links" : [ "CameraCharacteristics#NOISE_REDUCTION_AVAILABLE_NOISE_REDUCTION_MODES", "CaptureRequest#REPROCESS_EFFECTIVE_EXPOSURE_FACTOR", "#NOISE_REDUCTION_MODE_OFF", "#NOISE_REDUCTION_MODE_FAST", "#NOISE_REDUCTION_MODE_HIGH_QUALITY", "#NOISE_REDUCTION_MODE_MINIMAL", "#NOISE_REDUCTION_MODE_ZERO_SHUTTER_LAG", "CameraCharacteristics#NOISE_REDUCTION_AVAILABLE_NOISE_REDUCTION_MODES", "CameraCharacteristics#INFO_SUPPORTED_HARDWARE_LEVEL_FULL", "CameraCharacteristics#INFO_SUPPORTED_HARDWARE_LEVEL" ]
  }, {
    "name" : "REQUEST_ID",
    "type" : "Key<Integer>",
    "comment" : "\n     * <p>An application-specified ID for the current\n     * request. Must be maintained unchanged in output\n     * frame</p>\n     * <p><b>Units</b>: arbitrary integer assigned by application</p>\n     * <p><b>Range of valid values:</b><br>\n     * Any int</p>\n     * <p><b>Optional</b> - The value for this key may be {@code null} on some devices.</p>\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "SCALER_CROP_REGION",
    "type" : "Key<android.graphics.Rect>",
    "comment" : "\n     * <p>The desired region of the sensor to read out for this capture.</p>\n     * <p>This control can be used to implement digital zoom.</p>\n     * <p>For devices not supporting {@link CaptureRequest#DISTORTION_CORRECTION_MODE android.distortionCorrection.mode} control, the coordinate\n     * system always follows that of {@link CameraCharacteristics#SENSOR_INFO_ACTIVE_ARRAY_SIZE android.sensor.info.activeArraySize}, with <code>(0, 0)</code> being\n     * the top-left pixel of the active array.</p>\n     * <p>For devices supporting {@link CaptureRequest#DISTORTION_CORRECTION_MODE android.distortionCorrection.mode} control, the coordinate system\n     * depends on the mode being set.  When the distortion correction mode is OFF, the\n     * coordinate system follows {@link CameraCharacteristics#SENSOR_INFO_PRE_CORRECTION_ACTIVE_ARRAY_SIZE android.sensor.info.preCorrectionActiveArraySize}, with <code>(0,\n     * 0)</code> being the top-left pixel of the pre-correction active array.  When the distortion\n     * correction mode is not OFF, the coordinate system follows\n     * {@link CameraCharacteristics#SENSOR_INFO_ACTIVE_ARRAY_SIZE android.sensor.info.activeArraySize}, with <code>(0, 0)</code> being the top-left pixel of the\n     * active array.</p>\n     * <p>Output streams use this rectangle to produce their output, cropping to a smaller region\n     * if necessary to maintain the stream's aspect ratio, then scaling the sensor input to\n     * match the output's configured resolution.</p>\n     * <p>The crop region is applied after the RAW to other color space (e.g. YUV)\n     * conversion. Since raw streams (e.g. RAW16) don't have the conversion stage, they are not\n     * croppable. The crop region will be ignored by raw streams.</p>\n     * <p>For non-raw streams, any additional per-stream cropping will be done to maximize the\n     * final pixel area of the stream.</p>\n     * <p>For example, if the crop region is set to a 4:3 aspect ratio, then 4:3 streams will use\n     * the exact crop region. 16:9 streams will further crop vertically (letterbox).</p>\n     * <p>Conversely, if the crop region is set to a 16:9, then 4:3 outputs will crop horizontally\n     * (pillarbox), and 16:9 streams will match exactly. These additional crops will be\n     * centered within the crop region.</p>\n     * <p>To illustrate, here are several scenarios of different crop regions and output streams,\n     * for a hypothetical camera device with an active array of size <code>(2000,1500)</code>.  Note that\n     * several of these examples use non-centered crop regions for ease of illustration; such\n     * regions are only supported on devices with FREEFORM capability\n     * ({@link CameraCharacteristics#SCALER_CROPPING_TYPE android.scaler.croppingType} <code>== FREEFORM</code>), but this does not affect the way the crop\n     * rules work otherwise.</p>\n     * <ul>\n     * <li>Camera Configuration:<ul>\n     * <li>Active array size: <code>2000x1500</code> (3 MP, 4:3 aspect ratio)</li>\n     * <li>Output stream #1: <code>640x480</code> (VGA, 4:3 aspect ratio)</li>\n     * <li>Output stream #2: <code>1280x720</code> (720p, 16:9 aspect ratio)</li>\n     * </ul>\n     * </li>\n     * <li>Case #1: 4:3 crop region with 2x digital zoom<ul>\n     * <li>Crop region: <code>Rect(500, 375, 1500, 1125) // (left, top, right, bottom)</code></li>\n     * <li><img alt=\"4:3 aspect ratio crop diagram\" src=\"/reference/images/camera2/metadata/android.scaler.cropRegion/crop-region-43-ratio.png\" /></li>\n     * <li><code>640x480</code> stream source area: <code>(500, 375, 1500, 1125)</code> (equal to crop region)</li>\n     * <li><code>1280x720</code> stream source area: <code>(500, 469, 1500, 1031)</code> (letterboxed)</li>\n     * </ul>\n     * </li>\n     * <li>Case #2: 16:9 crop region with ~1.5x digital zoom.<ul>\n     * <li>Crop region: <code>Rect(500, 375, 1833, 1125)</code></li>\n     * <li><img alt=\"16:9 aspect ratio crop diagram\" src=\"/reference/images/camera2/metadata/android.scaler.cropRegion/crop-region-169-ratio.png\" /></li>\n     * <li><code>640x480</code> stream source area: <code>(666, 375, 1666, 1125)</code> (pillarboxed)</li>\n     * <li><code>1280x720</code> stream source area: <code>(500, 375, 1833, 1125)</code> (equal to crop region)</li>\n     * </ul>\n     * </li>\n     * <li>Case #3: 1:1 crop region with ~2.6x digital zoom.<ul>\n     * <li>Crop region: <code>Rect(500, 375, 1250, 1125)</code></li>\n     * <li><img alt=\"1:1 aspect ratio crop diagram\" src=\"/reference/images/camera2/metadata/android.scaler.cropRegion/crop-region-11-ratio.png\" /></li>\n     * <li><code>640x480</code> stream source area: <code>(500, 469, 1250, 1031)</code> (letterboxed)</li>\n     * <li><code>1280x720</code> stream source area: <code>(500, 543, 1250, 957)</code> (letterboxed)</li>\n     * </ul>\n     * </li>\n     * <li>Case #4: Replace <code>640x480</code> stream with <code>1024x1024</code> stream, with 4:3 crop region:<ul>\n     * <li>Crop region: <code>Rect(500, 375, 1500, 1125)</code></li>\n     * <li><img alt=\"Square output, 4:3 aspect ratio crop diagram\" src=\"/reference/images/camera2/metadata/android.scaler.cropRegion/crop-region-43-square-ratio.png\" /></li>\n     * <li><code>1024x1024</code> stream source area: <code>(625, 375, 1375, 1125)</code> (pillarboxed)</li>\n     * <li><code>1280x720</code> stream source area: <code>(500, 469, 1500, 1031)</code> (letterboxed)</li>\n     * <li>Note that in this case, neither of the two outputs is a subset of the other, with\n     *   each containing image data the other doesn't have.</li>\n     * </ul>\n     * </li>\n     * </ul>\n     * <p>If the coordinate system is {@link CameraCharacteristics#SENSOR_INFO_ACTIVE_ARRAY_SIZE android.sensor.info.activeArraySize}, the width and height\n     * of the crop region cannot be set to be smaller than\n     * <code>floor( activeArraySize.width / {@link CameraCharacteristics#SCALER_AVAILABLE_MAX_DIGITAL_ZOOM android.scaler.availableMaxDigitalZoom} )</code> and\n     * <code>floor( activeArraySize.height / {@link CameraCharacteristics#SCALER_AVAILABLE_MAX_DIGITAL_ZOOM android.scaler.availableMaxDigitalZoom} )</code>, respectively.</p>\n     * <p>If the coordinate system is {@link CameraCharacteristics#SENSOR_INFO_PRE_CORRECTION_ACTIVE_ARRAY_SIZE android.sensor.info.preCorrectionActiveArraySize}, the width\n     * and height of the crop region cannot be set to be smaller than\n     * <code>floor( preCorrectionActiveArraySize.width / {@link CameraCharacteristics#SCALER_AVAILABLE_MAX_DIGITAL_ZOOM android.scaler.availableMaxDigitalZoom} )</code>\n     * and\n     * <code>floor( preCorrectionActiveArraySize.height / {@link CameraCharacteristics#SCALER_AVAILABLE_MAX_DIGITAL_ZOOM android.scaler.availableMaxDigitalZoom} )</code>,\n     * respectively.</p>\n     * <p>The camera device may adjust the crop region to account for rounding and other hardware\n     * requirements; the final crop region used will be included in the output capture result.</p>\n     * <p>Starting from API level 30, it's strongly recommended to use {@link CaptureRequest#CONTROL_ZOOM_RATIO android.control.zoomRatio}\n     * to take advantage of better support for zoom with logical multi-camera. The benefits\n     * include better precision with optical-digital zoom combination, and ability to do\n     * zoom-out from 1.0x. When using {@link CaptureRequest#CONTROL_ZOOM_RATIO android.control.zoomRatio} for zoom, the crop region in\n     * the capture request must be either letterboxing or pillarboxing (but not both). The\n     * coordinate system is post-zoom, meaning that the activeArraySize or\n     * preCorrectionActiveArraySize covers the camera device's field of view \"after\" zoom.  See\n     * {@link CaptureRequest#CONTROL_ZOOM_RATIO android.control.zoomRatio} for details.</p>\n     * <p><b>Units</b>: Pixel coordinates relative to\n     * {@link CameraCharacteristics#SENSOR_INFO_ACTIVE_ARRAY_SIZE android.sensor.info.activeArraySize} or\n     * {@link CameraCharacteristics#SENSOR_INFO_PRE_CORRECTION_ACTIVE_ARRAY_SIZE android.sensor.info.preCorrectionActiveArraySize} depending on distortion correction\n     * capability and mode</p>\n     * <p>This key is available on all devices.</p>\n     *\n     * @see CaptureRequest#CONTROL_ZOOM_RATIO\n     * @see CaptureRequest#DISTORTION_CORRECTION_MODE\n     * @see CameraCharacteristics#SCALER_AVAILABLE_MAX_DIGITAL_ZOOM\n     * @see CameraCharacteristics#SCALER_CROPPING_TYPE\n     * @see CameraCharacteristics#SENSOR_INFO_ACTIVE_ARRAY_SIZE\n     * @see CameraCharacteristics#SENSOR_INFO_PRE_CORRECTION_ACTIVE_ARRAY_SIZE\n     ",
    "links" : [ "CaptureRequest#DISTORTION_CORRECTION_MODE", "CameraCharacteristics#SENSOR_INFO_ACTIVE_ARRAY_SIZE", "CaptureRequest#DISTORTION_CORRECTION_MODE", "CameraCharacteristics#SENSOR_INFO_PRE_CORRECTION_ACTIVE_ARRAY_SIZE", "CameraCharacteristics#SENSOR_INFO_ACTIVE_ARRAY_SIZE", "CameraCharacteristics#SCALER_CROPPING_TYPE", "CameraCharacteristics#SENSOR_INFO_ACTIVE_ARRAY_SIZE", "CameraCharacteristics#SCALER_AVAILABLE_MAX_DIGITAL_ZOOM", "CameraCharacteristics#SCALER_AVAILABLE_MAX_DIGITAL_ZOOM", "CameraCharacteristics#SENSOR_INFO_PRE_CORRECTION_ACTIVE_ARRAY_SIZE", "CameraCharacteristics#SCALER_AVAILABLE_MAX_DIGITAL_ZOOM", "CameraCharacteristics#SCALER_AVAILABLE_MAX_DIGITAL_ZOOM", "CaptureRequest#CONTROL_ZOOM_RATIO", "CaptureRequest#CONTROL_ZOOM_RATIO", "CaptureRequest#CONTROL_ZOOM_RATIO", "CameraCharacteristics#SENSOR_INFO_ACTIVE_ARRAY_SIZE", "CameraCharacteristics#SENSOR_INFO_PRE_CORRECTION_ACTIVE_ARRAY_SIZE" ]
  }, {
    "name" : "SCALER_ROTATE_AND_CROP",
    "type" : "Key<Integer>",
    "comment" : "\n     * <p>Whether a rotation-and-crop operation is applied to processed\n     * outputs from the camera.</p>\n     * <p>This control is primarily intended to help camera applications with no support for\n     * multi-window modes to work correctly on devices where multi-window scenarios are\n     * unavoidable, such as foldables or other devices with variable display geometry or more\n     * free-form window placement (such as laptops, which often place portrait-orientation apps\n     * in landscape with pillarboxing).</p>\n     * <p>If supported, the default value is <code>ROTATE_AND_CROP_AUTO</code>, which allows the camera API\n     * to enable backwards-compatibility support for applications that do not support resizing\n     * / multi-window modes, when the device is in fact in a multi-window mode (such as inset\n     * portrait on laptops, or on a foldable device in some fold states).  In addition,\n     * <code>ROTATE_AND_CROP_NONE</code> and <code>ROTATE_AND_CROP_90</code> will always be available if this control\n     * is supported by the device.  If not supported, devices API level 30 or higher will always\n     * list only <code>ROTATE_AND_CROP_NONE</code>.</p>\n     * <p>When <code>CROP_AUTO</code> is in use, and the camera API activates backward-compatibility mode,\n     * several metadata fields will also be parsed differently to ensure that coordinates are\n     * correctly handled for features like drawing face detection boxes or passing in\n     * tap-to-focus coordinates.  The camera API will convert positions in the active array\n     * coordinate system to/from the cropped-and-rotated coordinate system to make the\n     * operation transparent for applications.  The following controls are affected:</p>\n     * <ul>\n     * <li>{@link CaptureRequest#CONTROL_AE_REGIONS android.control.aeRegions}</li>\n     * <li>{@link CaptureRequest#CONTROL_AF_REGIONS android.control.afRegions}</li>\n     * <li>{@link CaptureRequest#CONTROL_AWB_REGIONS android.control.awbRegions}</li>\n     * <li>{@link CaptureResult#STATISTICS_FACES android.statistics.faces}</li>\n     * </ul>\n     * <p>Capture results will contain the actual value selected by the API;\n     * <code>ROTATE_AND_CROP_AUTO</code> will never be seen in a capture result.</p>\n     * <p>Applications can also select their preferred cropping mode, either to opt out of the\n     * backwards-compatibility treatment, or to use the cropping feature themselves as needed.\n     * In this case, no coordinate translation will be done automatically, and all controls\n     * will continue to use the normal active array coordinates.</p>\n     * <p>Cropping and rotating is done after the application of digital zoom (via either\n     * {@link CaptureRequest#SCALER_CROP_REGION android.scaler.cropRegion} or {@link CaptureRequest#CONTROL_ZOOM_RATIO android.control.zoomRatio}), but before each individual\n     * output is further cropped and scaled. It only affects processed outputs such as\n     * YUV, PRIVATE, and JPEG.  It has no effect on RAW outputs.</p>\n     * <p>When <code>CROP_90</code> or <code>CROP_270</code> are selected, there is a significant loss to the field of\n     * view. For example, with a 4:3 aspect ratio output of 1600x1200, <code>CROP_90</code> will still\n     * produce 1600x1200 output, but these buffers are cropped from a vertical 3:4 slice at the\n     * center of the 4:3 area, then rotated to be 4:3, and then upscaled to 1600x1200.  Only\n     * 56.25% of the original FOV is still visible.  In general, for an aspect ratio of <code>w:h</code>,\n     * the crop and rotate operation leaves <code>(h/w)^2</code> of the field of view visible. For 16:9,\n     * this is ~31.6%.</p>\n     * <p>As a visual example, the figure below shows the effect of <code>ROTATE_AND_CROP_90</code> on the\n     * outputs for the following parameters:</p>\n     * <ul>\n     * <li>Sensor active array: <code>2000x1500</code></li>\n     * <li>Crop region: top-left: <code>(500, 375)</code>, size: <code>(1000, 750)</code> (4:3 aspect ratio)</li>\n     * <li>Output streams: YUV <code>640x480</code> and YUV <code>1280x720</code></li>\n     * <li><code>ROTATE_AND_CROP_90</code></li>\n     * </ul>\n     * <p><img alt=\"Effect of ROTATE_AND_CROP_90\" src=\"/reference/images/camera2/metadata/android.scaler.rotateAndCrop/crop-region-rotate-90-43-ratio.png\" /></p>\n     * <p>With these settings, the regions of the active array covered by the output streams are:</p>\n     * <ul>\n     * <li>640x480 stream crop: top-left: <code>(219, 375)</code>, size: <code>(562, 750)</code></li>\n     * <li>1280x720 stream crop: top-left: <code>(289, 375)</code>, size: <code>(422, 750)</code></li>\n     * </ul>\n     * <p>Since the buffers are rotated, the buffers as seen by the application are:</p>\n     * <ul>\n     * <li>640x480 stream: top-left: <code>(781, 375)</code> on active array, size: <code>(640, 480)</code>, downscaled 1.17x from sensor pixels</li>\n     * <li>1280x720 stream: top-left: <code>(711, 375)</code> on active array, size: <code>(1280, 720)</code>, upscaled 1.71x from sensor pixels</li>\n     * </ul>\n     * <p><b>Possible values:</b>\n     * <ul>\n     *   <li>{@link #SCALER_ROTATE_AND_CROP_NONE NONE}</li>\n     *   <li>{@link #SCALER_ROTATE_AND_CROP_90 90}</li>\n     *   <li>{@link #SCALER_ROTATE_AND_CROP_180 180}</li>\n     *   <li>{@link #SCALER_ROTATE_AND_CROP_270 270}</li>\n     *   <li>{@link #SCALER_ROTATE_AND_CROP_AUTO AUTO}</li>\n     * </ul></p>\n     * <p><b>Available values for this device:</b><br>\n     * android.scaler.availableRotateAndCropModes</p>\n     * <p><b>Optional</b> - The value for this key may be {@code null} on some devices.</p>\n     *\n     * @see CaptureRequest#CONTROL_AE_REGIONS\n     * @see CaptureRequest#CONTROL_AF_REGIONS\n     * @see CaptureRequest#CONTROL_AWB_REGIONS\n     * @see CaptureRequest#CONTROL_ZOOM_RATIO\n     * @see CaptureRequest#SCALER_CROP_REGION\n     * @see CaptureResult#STATISTICS_FACES\n     * @see #SCALER_ROTATE_AND_CROP_NONE\n     * @see #SCALER_ROTATE_AND_CROP_90\n     * @see #SCALER_ROTATE_AND_CROP_180\n     * @see #SCALER_ROTATE_AND_CROP_270\n     * @see #SCALER_ROTATE_AND_CROP_AUTO\n     * @hide\n     ",
    "links" : [ "CaptureRequest#CONTROL_AE_REGIONS", "CaptureRequest#CONTROL_AF_REGIONS", "CaptureRequest#CONTROL_AWB_REGIONS", "CaptureResult#STATISTICS_FACES", "CaptureRequest#SCALER_CROP_REGION", "CaptureRequest#CONTROL_ZOOM_RATIO", "#SCALER_ROTATE_AND_CROP_NONE", "#SCALER_ROTATE_AND_CROP_90", "#SCALER_ROTATE_AND_CROP_180", "#SCALER_ROTATE_AND_CROP_270", "#SCALER_ROTATE_AND_CROP_AUTO" ]
  }, {
    "name" : "SENSOR_EXPOSURE_TIME",
    "type" : "Key<Long>",
    "comment" : "\n     * <p>Duration each pixel is exposed to\n     * light.</p>\n     * <p>If the sensor can't expose this exact duration, it will shorten the\n     * duration exposed to the nearest possible value (rather than expose longer).\n     * The final exposure time used will be available in the output capture result.</p>\n     * <p>This control is only effective if {@link CaptureRequest#CONTROL_AE_MODE android.control.aeMode} or {@link CaptureRequest#CONTROL_MODE android.control.mode} is set to\n     * OFF; otherwise the auto-exposure algorithm will override this value.</p>\n     * <p><b>Units</b>: Nanoseconds</p>\n     * <p><b>Range of valid values:</b><br>\n     * {@link CameraCharacteristics#SENSOR_INFO_EXPOSURE_TIME_RANGE android.sensor.info.exposureTimeRange}</p>\n     * <p><b>Optional</b> - The value for this key may be {@code null} on some devices.</p>\n     * <p><b>Full capability</b> -\n     * Present on all camera devices that report being {@link CameraCharacteristics#INFO_SUPPORTED_HARDWARE_LEVEL_FULL HARDWARE_LEVEL_FULL} devices in the\n     * {@link CameraCharacteristics#INFO_SUPPORTED_HARDWARE_LEVEL android.info.supportedHardwareLevel} key</p>\n     *\n     * @see CaptureRequest#CONTROL_AE_MODE\n     * @see CaptureRequest#CONTROL_MODE\n     * @see CameraCharacteristics#INFO_SUPPORTED_HARDWARE_LEVEL\n     * @see CameraCharacteristics#SENSOR_INFO_EXPOSURE_TIME_RANGE\n     ",
    "links" : [ "CaptureRequest#CONTROL_AE_MODE", "CaptureRequest#CONTROL_MODE", "CameraCharacteristics#SENSOR_INFO_EXPOSURE_TIME_RANGE", "CameraCharacteristics#INFO_SUPPORTED_HARDWARE_LEVEL_FULL", "CameraCharacteristics#INFO_SUPPORTED_HARDWARE_LEVEL" ]
  }, {
    "name" : "SENSOR_FRAME_DURATION",
    "type" : "Key<Long>",
    "comment" : "\n     * <p>Duration from start of frame exposure to\n     * start of next frame exposure.</p>\n     * <p>The maximum frame rate that can be supported by a camera subsystem is\n     * a function of many factors:</p>\n     * <ul>\n     * <li>Requested resolutions of output image streams</li>\n     * <li>Availability of binning / skipping modes on the imager</li>\n     * <li>The bandwidth of the imager interface</li>\n     * <li>The bandwidth of the various ISP processing blocks</li>\n     * </ul>\n     * <p>Since these factors can vary greatly between different ISPs and\n     * sensors, the camera abstraction tries to represent the bandwidth\n     * restrictions with as simple a model as possible.</p>\n     * <p>The model presented has the following characteristics:</p>\n     * <ul>\n     * <li>The image sensor is always configured to output the smallest\n     * resolution possible given the application's requested output stream\n     * sizes.  The smallest resolution is defined as being at least as large\n     * as the largest requested output stream size; the camera pipeline must\n     * never digitally upsample sensor data when the crop region covers the\n     * whole sensor. In general, this means that if only small output stream\n     * resolutions are configured, the sensor can provide a higher frame\n     * rate.</li>\n     * <li>Since any request may use any or all the currently configured\n     * output streams, the sensor and ISP must be configured to support\n     * scaling a single capture to all the streams at the same time.  This\n     * means the camera pipeline must be ready to produce the largest\n     * requested output size without any delay.  Therefore, the overall\n     * frame rate of a given configured stream set is governed only by the\n     * largest requested stream resolution.</li>\n     * <li>Using more than one output stream in a request does not affect the\n     * frame duration.</li>\n     * <li>Certain format-streams may need to do additional background processing\n     * before data is consumed/produced by that stream. These processors\n     * can run concurrently to the rest of the camera pipeline, but\n     * cannot process more than 1 capture at a time.</li>\n     * </ul>\n     * <p>The necessary information for the application, given the model above, is provided via\n     * {@link android.hardware.camera2.params.StreamConfigurationMap#getOutputMinFrameDuration }.\n     * These are used to determine the maximum frame rate / minimum frame duration that is\n     * possible for a given stream configuration.</p>\n     * <p>Specifically, the application can use the following rules to\n     * determine the minimum frame duration it can request from the camera\n     * device:</p>\n     * <ol>\n     * <li>Let the set of currently configured input/output streams be called <code>S</code>.</li>\n     * <li>Find the minimum frame durations for each stream in <code>S</code>, by looking it up in {@link android.hardware.camera2.params.StreamConfigurationMap#getOutputMinFrameDuration }\n     * (with its respective size/format). Let this set of frame durations be called <code>F</code>.</li>\n     * <li>For any given request <code>R</code>, the minimum frame duration allowed for <code>R</code> is the maximum\n     * out of all values in <code>F</code>. Let the streams used in <code>R</code> be called <code>S_r</code>.</li>\n     * </ol>\n     * <p>If none of the streams in <code>S_r</code> have a stall time (listed in {@link android.hardware.camera2.params.StreamConfigurationMap#getOutputStallDuration }\n     * using its respective size/format), then the frame duration in <code>F</code> determines the steady\n     * state frame rate that the application will get if it uses <code>R</code> as a repeating request. Let\n     * this special kind of request be called <code>Rsimple</code>.</p>\n     * <p>A repeating request <code>Rsimple</code> can be <em>occasionally</em> interleaved by a single capture of a\n     * new request <code>Rstall</code> (which has at least one in-use stream with a non-0 stall time) and if\n     * <code>Rstall</code> has the same minimum frame duration this will not cause a frame rate loss if all\n     * buffers from the previous <code>Rstall</code> have already been delivered.</p>\n     * <p>For more details about stalling, see {@link android.hardware.camera2.params.StreamConfigurationMap#getOutputStallDuration }.</p>\n     * <p>This control is only effective if {@link CaptureRequest#CONTROL_AE_MODE android.control.aeMode} or {@link CaptureRequest#CONTROL_MODE android.control.mode} is set to\n     * OFF; otherwise the auto-exposure algorithm will override this value.</p>\n     * <p><b>Units</b>: Nanoseconds</p>\n     * <p><b>Range of valid values:</b><br>\n     * See {@link CameraCharacteristics#SENSOR_INFO_MAX_FRAME_DURATION android.sensor.info.maxFrameDuration}, {@link android.hardware.camera2.params.StreamConfigurationMap }.\n     * The duration is capped to <code>max(duration, exposureTime + overhead)</code>.</p>\n     * <p><b>Optional</b> - The value for this key may be {@code null} on some devices.</p>\n     * <p><b>Full capability</b> -\n     * Present on all camera devices that report being {@link CameraCharacteristics#INFO_SUPPORTED_HARDWARE_LEVEL_FULL HARDWARE_LEVEL_FULL} devices in the\n     * {@link CameraCharacteristics#INFO_SUPPORTED_HARDWARE_LEVEL android.info.supportedHardwareLevel} key</p>\n     *\n     * @see CaptureRequest#CONTROL_AE_MODE\n     * @see CaptureRequest#CONTROL_MODE\n     * @see CameraCharacteristics#INFO_SUPPORTED_HARDWARE_LEVEL\n     * @see CameraCharacteristics#SENSOR_INFO_MAX_FRAME_DURATION\n     ",
    "links" : [ "android.hardware.camera2.params.StreamConfigurationMap#getOutputMinFrameDuration", "android.hardware.camera2.params.StreamConfigurationMap#getOutputMinFrameDuration", "android.hardware.camera2.params.StreamConfigurationMap#getOutputStallDuration", "android.hardware.camera2.params.StreamConfigurationMap#getOutputStallDuration", "CaptureRequest#CONTROL_AE_MODE", "CaptureRequest#CONTROL_MODE", "CameraCharacteristics#SENSOR_INFO_MAX_FRAME_DURATION", "android.hardware.camera2.params.StreamConfigurationMap", "CameraCharacteristics#INFO_SUPPORTED_HARDWARE_LEVEL_FULL", "CameraCharacteristics#INFO_SUPPORTED_HARDWARE_LEVEL" ]
  }, {
    "name" : "SENSOR_SENSITIVITY",
    "type" : "Key<Integer>",
    "comment" : "\n     * <p>The amount of gain applied to sensor data\n     * before processing.</p>\n     * <p>The sensitivity is the standard ISO sensitivity value,\n     * as defined in ISO 12232:2006.</p>\n     * <p>The sensitivity must be within {@link CameraCharacteristics#SENSOR_INFO_SENSITIVITY_RANGE android.sensor.info.sensitivityRange}, and\n     * if if it less than {@link CameraCharacteristics#SENSOR_MAX_ANALOG_SENSITIVITY android.sensor.maxAnalogSensitivity}, the camera device\n     * is guaranteed to use only analog amplification for applying the gain.</p>\n     * <p>If the camera device cannot apply the exact sensitivity\n     * requested, it will reduce the gain to the nearest supported\n     * value. The final sensitivity used will be available in the\n     * output capture result.</p>\n     * <p>This control is only effective if {@link CaptureRequest#CONTROL_AE_MODE android.control.aeMode} or {@link CaptureRequest#CONTROL_MODE android.control.mode} is set to\n     * OFF; otherwise the auto-exposure algorithm will override this value.</p>\n     * <p>Note that for devices supporting postRawSensitivityBoost, the total sensitivity applied\n     * to the final processed image is the combination of {@link CaptureRequest#SENSOR_SENSITIVITY android.sensor.sensitivity} and\n     * {@link CaptureRequest#CONTROL_POST_RAW_SENSITIVITY_BOOST android.control.postRawSensitivityBoost}. In case the application uses the sensor\n     * sensitivity from last capture result of an auto request for a manual request, in order\n     * to achieve the same brightness in the output image, the application should also\n     * set postRawSensitivityBoost.</p>\n     * <p><b>Units</b>: ISO arithmetic units</p>\n     * <p><b>Range of valid values:</b><br>\n     * {@link CameraCharacteristics#SENSOR_INFO_SENSITIVITY_RANGE android.sensor.info.sensitivityRange}</p>\n     * <p><b>Optional</b> - The value for this key may be {@code null} on some devices.</p>\n     * <p><b>Full capability</b> -\n     * Present on all camera devices that report being {@link CameraCharacteristics#INFO_SUPPORTED_HARDWARE_LEVEL_FULL HARDWARE_LEVEL_FULL} devices in the\n     * {@link CameraCharacteristics#INFO_SUPPORTED_HARDWARE_LEVEL android.info.supportedHardwareLevel} key</p>\n     *\n     * @see CaptureRequest#CONTROL_AE_MODE\n     * @see CaptureRequest#CONTROL_MODE\n     * @see CaptureRequest#CONTROL_POST_RAW_SENSITIVITY_BOOST\n     * @see CameraCharacteristics#INFO_SUPPORTED_HARDWARE_LEVEL\n     * @see CameraCharacteristics#SENSOR_INFO_SENSITIVITY_RANGE\n     * @see CameraCharacteristics#SENSOR_MAX_ANALOG_SENSITIVITY\n     * @see CaptureRequest#SENSOR_SENSITIVITY\n     ",
    "links" : [ "CameraCharacteristics#SENSOR_INFO_SENSITIVITY_RANGE", "CameraCharacteristics#SENSOR_MAX_ANALOG_SENSITIVITY", "CaptureRequest#CONTROL_AE_MODE", "CaptureRequest#CONTROL_MODE", "CaptureRequest#SENSOR_SENSITIVITY", "CaptureRequest#CONTROL_POST_RAW_SENSITIVITY_BOOST", "CameraCharacteristics#SENSOR_INFO_SENSITIVITY_RANGE", "CameraCharacteristics#INFO_SUPPORTED_HARDWARE_LEVEL_FULL", "CameraCharacteristics#INFO_SUPPORTED_HARDWARE_LEVEL" ]
  }, {
    "name" : "SENSOR_TEST_PATTERN_DATA",
    "type" : "Key<int[]>",
    "comment" : "\n     * <p>A pixel <code>[R, G_even, G_odd, B]</code> that supplies the test pattern\n     * when {@link CaptureRequest#SENSOR_TEST_PATTERN_MODE android.sensor.testPatternMode} is SOLID_COLOR.</p>\n     * <p>Each color channel is treated as an unsigned 32-bit integer.\n     * The camera device then uses the most significant X bits\n     * that correspond to how many bits are in its Bayer raw sensor\n     * output.</p>\n     * <p>For example, a sensor with RAW10 Bayer output would use the\n     * 10 most significant bits from each color channel.</p>\n     * <p><b>Optional</b> - The value for this key may be {@code null} on some devices.</p>\n     *\n     * @see CaptureRequest#SENSOR_TEST_PATTERN_MODE\n     ",
    "links" : [ "CaptureRequest#SENSOR_TEST_PATTERN_MODE" ]
  }, {
    "name" : "SENSOR_TEST_PATTERN_MODE",
    "type" : "Key<Integer>",
    "comment" : "\n     * <p>When enabled, the sensor sends a test pattern instead of\n     * doing a real exposure from the camera.</p>\n     * <p>When a test pattern is enabled, all manual sensor controls specified\n     * by android.sensor.* will be ignored. All other controls should\n     * work as normal.</p>\n     * <p>For example, if manual flash is enabled, flash firing should still\n     * occur (and that the test pattern remain unmodified, since the flash\n     * would not actually affect it).</p>\n     * <p>Defaults to OFF.</p>\n     * <p><b>Possible values:</b>\n     * <ul>\n     *   <li>{@link #SENSOR_TEST_PATTERN_MODE_OFF OFF}</li>\n     *   <li>{@link #SENSOR_TEST_PATTERN_MODE_SOLID_COLOR SOLID_COLOR}</li>\n     *   <li>{@link #SENSOR_TEST_PATTERN_MODE_COLOR_BARS COLOR_BARS}</li>\n     *   <li>{@link #SENSOR_TEST_PATTERN_MODE_COLOR_BARS_FADE_TO_GRAY COLOR_BARS_FADE_TO_GRAY}</li>\n     *   <li>{@link #SENSOR_TEST_PATTERN_MODE_PN9 PN9}</li>\n     *   <li>{@link #SENSOR_TEST_PATTERN_MODE_CUSTOM1 CUSTOM1}</li>\n     * </ul></p>\n     * <p><b>Available values for this device:</b><br>\n     * {@link CameraCharacteristics#SENSOR_AVAILABLE_TEST_PATTERN_MODES android.sensor.availableTestPatternModes}</p>\n     * <p><b>Optional</b> - The value for this key may be {@code null} on some devices.</p>\n     *\n     * @see CameraCharacteristics#SENSOR_AVAILABLE_TEST_PATTERN_MODES\n     * @see #SENSOR_TEST_PATTERN_MODE_OFF\n     * @see #SENSOR_TEST_PATTERN_MODE_SOLID_COLOR\n     * @see #SENSOR_TEST_PATTERN_MODE_COLOR_BARS\n     * @see #SENSOR_TEST_PATTERN_MODE_COLOR_BARS_FADE_TO_GRAY\n     * @see #SENSOR_TEST_PATTERN_MODE_PN9\n     * @see #SENSOR_TEST_PATTERN_MODE_CUSTOM1\n     ",
    "links" : [ "#SENSOR_TEST_PATTERN_MODE_OFF", "#SENSOR_TEST_PATTERN_MODE_SOLID_COLOR", "#SENSOR_TEST_PATTERN_MODE_COLOR_BARS", "#SENSOR_TEST_PATTERN_MODE_COLOR_BARS_FADE_TO_GRAY", "#SENSOR_TEST_PATTERN_MODE_PN9", "#SENSOR_TEST_PATTERN_MODE_CUSTOM1", "CameraCharacteristics#SENSOR_AVAILABLE_TEST_PATTERN_MODES" ]
  }, {
    "name" : "SHADING_MODE",
    "type" : "Key<Integer>",
    "comment" : "\n     * <p>Quality of lens shading correction applied\n     * to the image data.</p>\n     * <p>When set to OFF mode, no lens shading correction will be applied by the\n     * camera device, and an identity lens shading map data will be provided\n     * if <code>{@link CaptureRequest#STATISTICS_LENS_SHADING_MAP_MODE android.statistics.lensShadingMapMode} == ON</code>. For example, for lens\n     * shading map with size of <code>[ 4, 3 ]</code>,\n     * the output {@link CaptureResult#STATISTICS_LENS_SHADING_CORRECTION_MAP android.statistics.lensShadingCorrectionMap} for this case will be an identity\n     * map shown below:</p>\n     * <pre><code>[ 1.0, 1.0, 1.0, 1.0,  1.0, 1.0, 1.0, 1.0,\n     *  1.0, 1.0, 1.0, 1.0,  1.0, 1.0, 1.0, 1.0,\n     *  1.0, 1.0, 1.0, 1.0,  1.0, 1.0, 1.0, 1.0,\n     *  1.0, 1.0, 1.0, 1.0,  1.0, 1.0, 1.0, 1.0,\n     *  1.0, 1.0, 1.0, 1.0,  1.0, 1.0, 1.0, 1.0,\n     *  1.0, 1.0, 1.0, 1.0,  1.0, 1.0, 1.0, 1.0 ]\n     * </code></pre>\n     * <p>When set to other modes, lens shading correction will be applied by the camera\n     * device. Applications can request lens shading map data by setting\n     * {@link CaptureRequest#STATISTICS_LENS_SHADING_MAP_MODE android.statistics.lensShadingMapMode} to ON, and then the camera device will provide lens\n     * shading map data in {@link CaptureResult#STATISTICS_LENS_SHADING_CORRECTION_MAP android.statistics.lensShadingCorrectionMap}; the returned shading map\n     * data will be the one applied by the camera device for this capture request.</p>\n     * <p>The shading map data may depend on the auto-exposure (AE) and AWB statistics, therefore\n     * the reliability of the map data may be affected by the AE and AWB algorithms. When AE and\n     * AWB are in AUTO modes({@link CaptureRequest#CONTROL_AE_MODE android.control.aeMode} <code>!=</code> OFF and {@link CaptureRequest#CONTROL_AWB_MODE android.control.awbMode} <code>!=</code>\n     * OFF), to get best results, it is recommended that the applications wait for the AE and AWB\n     * to be converged before using the returned shading map data.</p>\n     * <p><b>Possible values:</b>\n     * <ul>\n     *   <li>{@link #SHADING_MODE_OFF OFF}</li>\n     *   <li>{@link #SHADING_MODE_FAST FAST}</li>\n     *   <li>{@link #SHADING_MODE_HIGH_QUALITY HIGH_QUALITY}</li>\n     * </ul></p>\n     * <p><b>Available values for this device:</b><br>\n     * {@link CameraCharacteristics#SHADING_AVAILABLE_MODES android.shading.availableModes}</p>\n     * <p><b>Optional</b> - The value for this key may be {@code null} on some devices.</p>\n     * <p><b>Full capability</b> -\n     * Present on all camera devices that report being {@link CameraCharacteristics#INFO_SUPPORTED_HARDWARE_LEVEL_FULL HARDWARE_LEVEL_FULL} devices in the\n     * {@link CameraCharacteristics#INFO_SUPPORTED_HARDWARE_LEVEL android.info.supportedHardwareLevel} key</p>\n     *\n     * @see CaptureRequest#CONTROL_AE_MODE\n     * @see CaptureRequest#CONTROL_AWB_MODE\n     * @see CameraCharacteristics#INFO_SUPPORTED_HARDWARE_LEVEL\n     * @see CameraCharacteristics#SHADING_AVAILABLE_MODES\n     * @see CaptureResult#STATISTICS_LENS_SHADING_CORRECTION_MAP\n     * @see CaptureRequest#STATISTICS_LENS_SHADING_MAP_MODE\n     * @see #SHADING_MODE_OFF\n     * @see #SHADING_MODE_FAST\n     * @see #SHADING_MODE_HIGH_QUALITY\n     ",
    "links" : [ "CaptureRequest#STATISTICS_LENS_SHADING_MAP_MODE", "CaptureResult#STATISTICS_LENS_SHADING_CORRECTION_MAP", "CaptureRequest#STATISTICS_LENS_SHADING_MAP_MODE", "CaptureResult#STATISTICS_LENS_SHADING_CORRECTION_MAP", "CaptureRequest#CONTROL_AE_MODE", "CaptureRequest#CONTROL_AWB_MODE", "#SHADING_MODE_OFF", "#SHADING_MODE_FAST", "#SHADING_MODE_HIGH_QUALITY", "CameraCharacteristics#SHADING_AVAILABLE_MODES", "CameraCharacteristics#INFO_SUPPORTED_HARDWARE_LEVEL_FULL", "CameraCharacteristics#INFO_SUPPORTED_HARDWARE_LEVEL" ]
  }, {
    "name" : "STATISTICS_FACE_DETECT_MODE",
    "type" : "Key<Integer>",
    "comment" : "\n     * <p>Operating mode for the face detector\n     * unit.</p>\n     * <p>Whether face detection is enabled, and whether it\n     * should output just the basic fields or the full set of\n     * fields.</p>\n     * <p><b>Possible values:</b>\n     * <ul>\n     *   <li>{@link #STATISTICS_FACE_DETECT_MODE_OFF OFF}</li>\n     *   <li>{@link #STATISTICS_FACE_DETECT_MODE_SIMPLE SIMPLE}</li>\n     *   <li>{@link #STATISTICS_FACE_DETECT_MODE_FULL FULL}</li>\n     * </ul></p>\n     * <p><b>Available values for this device:</b><br>\n     * {@link CameraCharacteristics#STATISTICS_INFO_AVAILABLE_FACE_DETECT_MODES android.statistics.info.availableFaceDetectModes}</p>\n     * <p>This key is available on all devices.</p>\n     *\n     * @see CameraCharacteristics#STATISTICS_INFO_AVAILABLE_FACE_DETECT_MODES\n     * @see #STATISTICS_FACE_DETECT_MODE_OFF\n     * @see #STATISTICS_FACE_DETECT_MODE_SIMPLE\n     * @see #STATISTICS_FACE_DETECT_MODE_FULL\n     ",
    "links" : [ "#STATISTICS_FACE_DETECT_MODE_OFF", "#STATISTICS_FACE_DETECT_MODE_SIMPLE", "#STATISTICS_FACE_DETECT_MODE_FULL", "CameraCharacteristics#STATISTICS_INFO_AVAILABLE_FACE_DETECT_MODES" ]
  }, {
    "name" : "STATISTICS_HOT_PIXEL_MAP_MODE",
    "type" : "Key<Boolean>",
    "comment" : "\n     * <p>Operating mode for hot pixel map generation.</p>\n     * <p>If set to <code>true</code>, a hot pixel map is returned in {@link CaptureResult#STATISTICS_HOT_PIXEL_MAP android.statistics.hotPixelMap}.\n     * If set to <code>false</code>, no hot pixel map will be returned.</p>\n     * <p><b>Range of valid values:</b><br>\n     * {@link CameraCharacteristics#STATISTICS_INFO_AVAILABLE_HOT_PIXEL_MAP_MODES android.statistics.info.availableHotPixelMapModes}</p>\n     * <p><b>Optional</b> - The value for this key may be {@code null} on some devices.</p>\n     *\n     * @see CaptureResult#STATISTICS_HOT_PIXEL_MAP\n     * @see CameraCharacteristics#STATISTICS_INFO_AVAILABLE_HOT_PIXEL_MAP_MODES\n     ",
    "links" : [ "CaptureResult#STATISTICS_HOT_PIXEL_MAP", "CameraCharacteristics#STATISTICS_INFO_AVAILABLE_HOT_PIXEL_MAP_MODES" ]
  }, {
    "name" : "STATISTICS_LENS_SHADING_MAP_MODE",
    "type" : "Key<Integer>",
    "comment" : "\n     * <p>Whether the camera device will output the lens\n     * shading map in output result metadata.</p>\n     * <p>When set to ON,\n     * android.statistics.lensShadingMap will be provided in\n     * the output result metadata.</p>\n     * <p>ON is always supported on devices with the RAW capability.</p>\n     * <p><b>Possible values:</b>\n     * <ul>\n     *   <li>{@link #STATISTICS_LENS_SHADING_MAP_MODE_OFF OFF}</li>\n     *   <li>{@link #STATISTICS_LENS_SHADING_MAP_MODE_ON ON}</li>\n     * </ul></p>\n     * <p><b>Available values for this device:</b><br>\n     * {@link CameraCharacteristics#STATISTICS_INFO_AVAILABLE_LENS_SHADING_MAP_MODES android.statistics.info.availableLensShadingMapModes}</p>\n     * <p><b>Optional</b> - The value for this key may be {@code null} on some devices.</p>\n     * <p><b>Full capability</b> -\n     * Present on all camera devices that report being {@link CameraCharacteristics#INFO_SUPPORTED_HARDWARE_LEVEL_FULL HARDWARE_LEVEL_FULL} devices in the\n     * {@link CameraCharacteristics#INFO_SUPPORTED_HARDWARE_LEVEL android.info.supportedHardwareLevel} key</p>\n     *\n     * @see CameraCharacteristics#INFO_SUPPORTED_HARDWARE_LEVEL\n     * @see CameraCharacteristics#STATISTICS_INFO_AVAILABLE_LENS_SHADING_MAP_MODES\n     * @see #STATISTICS_LENS_SHADING_MAP_MODE_OFF\n     * @see #STATISTICS_LENS_SHADING_MAP_MODE_ON\n     ",
    "links" : [ "#STATISTICS_LENS_SHADING_MAP_MODE_OFF", "#STATISTICS_LENS_SHADING_MAP_MODE_ON", "CameraCharacteristics#STATISTICS_INFO_AVAILABLE_LENS_SHADING_MAP_MODES", "CameraCharacteristics#INFO_SUPPORTED_HARDWARE_LEVEL_FULL", "CameraCharacteristics#INFO_SUPPORTED_HARDWARE_LEVEL" ]
  }, {
    "name" : "STATISTICS_OIS_DATA_MODE",
    "type" : "Key<Integer>",
    "comment" : "\n     * <p>A control for selecting whether optical stabilization (OIS) position\n     * information is included in output result metadata.</p>\n     * <p>Since optical image stabilization generally involves motion much faster than the duration\n     * of individualq image exposure, multiple OIS samples can be included for a single capture\n     * result. For example, if the OIS reporting operates at 200 Hz, a typical camera operating\n     * at 30fps may have 6-7 OIS samples per capture result. This information can be combined\n     * with the rolling shutter skew to account for lens motion during image exposure in\n     * post-processing algorithms.</p>\n     * <p><b>Possible values:</b>\n     * <ul>\n     *   <li>{@link #STATISTICS_OIS_DATA_MODE_OFF OFF}</li>\n     *   <li>{@link #STATISTICS_OIS_DATA_MODE_ON ON}</li>\n     * </ul></p>\n     * <p><b>Available values for this device:</b><br>\n     * {@link CameraCharacteristics#STATISTICS_INFO_AVAILABLE_OIS_DATA_MODES android.statistics.info.availableOisDataModes}</p>\n     * <p><b>Optional</b> - The value for this key may be {@code null} on some devices.</p>\n     *\n     * @see CameraCharacteristics#STATISTICS_INFO_AVAILABLE_OIS_DATA_MODES\n     * @see #STATISTICS_OIS_DATA_MODE_OFF\n     * @see #STATISTICS_OIS_DATA_MODE_ON\n     ",
    "links" : [ "#STATISTICS_OIS_DATA_MODE_OFF", "#STATISTICS_OIS_DATA_MODE_ON", "CameraCharacteristics#STATISTICS_INFO_AVAILABLE_OIS_DATA_MODES" ]
  }, {
    "name" : "TONEMAP_CURVE_BLUE",
    "type" : "Key<float[]>",
    "comment" : "\n     * <p>Tonemapping / contrast / gamma curve for the blue\n     * channel, to use when {@link CaptureRequest#TONEMAP_MODE android.tonemap.mode} is\n     * CONTRAST_CURVE.</p>\n     * <p>See android.tonemap.curveRed for more details.</p>\n     * <p><b>Optional</b> - The value for this key may be {@code null} on some devices.</p>\n     * <p><b>Full capability</b> -\n     * Present on all camera devices that report being {@link CameraCharacteristics#INFO_SUPPORTED_HARDWARE_LEVEL_FULL HARDWARE_LEVEL_FULL} devices in the\n     * {@link CameraCharacteristics#INFO_SUPPORTED_HARDWARE_LEVEL android.info.supportedHardwareLevel} key</p>\n     *\n     * @see CameraCharacteristics#INFO_SUPPORTED_HARDWARE_LEVEL\n     * @see CaptureRequest#TONEMAP_MODE\n     * @hide\n     ",
    "links" : [ "CaptureRequest#TONEMAP_MODE", "CameraCharacteristics#INFO_SUPPORTED_HARDWARE_LEVEL_FULL", "CameraCharacteristics#INFO_SUPPORTED_HARDWARE_LEVEL" ]
  }, {
    "name" : "TONEMAP_CURVE_GREEN",
    "type" : "Key<float[]>",
    "comment" : "\n     * <p>Tonemapping / contrast / gamma curve for the green\n     * channel, to use when {@link CaptureRequest#TONEMAP_MODE android.tonemap.mode} is\n     * CONTRAST_CURVE.</p>\n     * <p>See android.tonemap.curveRed for more details.</p>\n     * <p><b>Optional</b> - The value for this key may be {@code null} on some devices.</p>\n     * <p><b>Full capability</b> -\n     * Present on all camera devices that report being {@link CameraCharacteristics#INFO_SUPPORTED_HARDWARE_LEVEL_FULL HARDWARE_LEVEL_FULL} devices in the\n     * {@link CameraCharacteristics#INFO_SUPPORTED_HARDWARE_LEVEL android.info.supportedHardwareLevel} key</p>\n     *\n     * @see CameraCharacteristics#INFO_SUPPORTED_HARDWARE_LEVEL\n     * @see CaptureRequest#TONEMAP_MODE\n     * @hide\n     ",
    "links" : [ "CaptureRequest#TONEMAP_MODE", "CameraCharacteristics#INFO_SUPPORTED_HARDWARE_LEVEL_FULL", "CameraCharacteristics#INFO_SUPPORTED_HARDWARE_LEVEL" ]
  }, {
    "name" : "TONEMAP_CURVE_RED",
    "type" : "Key<float[]>",
    "comment" : "\n     * <p>Tonemapping / contrast / gamma curve for the red\n     * channel, to use when {@link CaptureRequest#TONEMAP_MODE android.tonemap.mode} is\n     * CONTRAST_CURVE.</p>\n     * <p>Each channel's curve is defined by an array of control points:</p>\n     * <pre><code>android.tonemap.curveRed =\n     *   [ P0in, P0out, P1in, P1out, P2in, P2out, P3in, P3out, ..., PNin, PNout ]\n     * 2 &lt;= N &lt;= {@link CameraCharacteristics#TONEMAP_MAX_CURVE_POINTS android.tonemap.maxCurvePoints}</code></pre>\n     * <p>These are sorted in order of increasing <code>Pin</code>; it is\n     * required that input values 0.0 and 1.0 are included in the list to\n     * define a complete mapping. For input values between control points,\n     * the camera device must linearly interpolate between the control\n     * points.</p>\n     * <p>Each curve can have an independent number of points, and the number\n     * of points can be less than max (that is, the request doesn't have to\n     * always provide a curve with number of points equivalent to\n     * {@link CameraCharacteristics#TONEMAP_MAX_CURVE_POINTS android.tonemap.maxCurvePoints}).</p>\n     * <p>For devices with MONOCHROME capability, all three channels must have the same set of\n     * control points.</p>\n     * <p>A few examples, and their corresponding graphical mappings; these\n     * only specify the red channel and the precision is limited to 4\n     * digits, for conciseness.</p>\n     * <p>Linear mapping:</p>\n     * <pre><code>android.tonemap.curveRed = [ 0, 0, 1.0, 1.0 ]\n     * </code></pre>\n     * <p><img alt=\"Linear mapping curve\" src=\"/reference/images/camera2/metadata/android.tonemap.curveRed/linear_tonemap.png\" /></p>\n     * <p>Invert mapping:</p>\n     * <pre><code>android.tonemap.curveRed = [ 0, 1.0, 1.0, 0 ]\n     * </code></pre>\n     * <p><img alt=\"Inverting mapping curve\" src=\"/reference/images/camera2/metadata/android.tonemap.curveRed/inverse_tonemap.png\" /></p>\n     * <p>Gamma 1/2.2 mapping, with 16 control points:</p>\n     * <pre><code>android.tonemap.curveRed = [\n     *   0.0000, 0.0000, 0.0667, 0.2920, 0.1333, 0.4002, 0.2000, 0.4812,\n     *   0.2667, 0.5484, 0.3333, 0.6069, 0.4000, 0.6594, 0.4667, 0.7072,\n     *   0.5333, 0.7515, 0.6000, 0.7928, 0.6667, 0.8317, 0.7333, 0.8685,\n     *   0.8000, 0.9035, 0.8667, 0.9370, 0.9333, 0.9691, 1.0000, 1.0000 ]\n     * </code></pre>\n     * <p><img alt=\"Gamma = 1/2.2 tonemapping curve\" src=\"/reference/images/camera2/metadata/android.tonemap.curveRed/gamma_tonemap.png\" /></p>\n     * <p>Standard sRGB gamma mapping, per IEC 61966-2-1:1999, with 16 control points:</p>\n     * <pre><code>android.tonemap.curveRed = [\n     *   0.0000, 0.0000, 0.0667, 0.2864, 0.1333, 0.4007, 0.2000, 0.4845,\n     *   0.2667, 0.5532, 0.3333, 0.6125, 0.4000, 0.6652, 0.4667, 0.7130,\n     *   0.5333, 0.7569, 0.6000, 0.7977, 0.6667, 0.8360, 0.7333, 0.8721,\n     *   0.8000, 0.9063, 0.8667, 0.9389, 0.9333, 0.9701, 1.0000, 1.0000 ]\n     * </code></pre>\n     * <p><img alt=\"sRGB tonemapping curve\" src=\"/reference/images/camera2/metadata/android.tonemap.curveRed/srgb_tonemap.png\" /></p>\n     * <p><b>Range of valid values:</b><br>\n     * 0-1 on both input and output coordinates, normalized\n     * as a floating-point value such that 0 == black and 1 == white.</p>\n     * <p><b>Optional</b> - The value for this key may be {@code null} on some devices.</p>\n     * <p><b>Full capability</b> -\n     * Present on all camera devices that report being {@link CameraCharacteristics#INFO_SUPPORTED_HARDWARE_LEVEL_FULL HARDWARE_LEVEL_FULL} devices in the\n     * {@link CameraCharacteristics#INFO_SUPPORTED_HARDWARE_LEVEL android.info.supportedHardwareLevel} key</p>\n     *\n     * @see CameraCharacteristics#INFO_SUPPORTED_HARDWARE_LEVEL\n     * @see CameraCharacteristics#TONEMAP_MAX_CURVE_POINTS\n     * @see CaptureRequest#TONEMAP_MODE\n     * @hide\n     ",
    "links" : [ "CaptureRequest#TONEMAP_MODE", "CameraCharacteristics#TONEMAP_MAX_CURVE_POINTS", "CameraCharacteristics#TONEMAP_MAX_CURVE_POINTS", "CameraCharacteristics#INFO_SUPPORTED_HARDWARE_LEVEL_FULL", "CameraCharacteristics#INFO_SUPPORTED_HARDWARE_LEVEL" ]
  }, {
    "name" : "TONEMAP_CURVE",
    "type" : "Key<android.hardware.camera2.params.TonemapCurve>",
    "comment" : "\n     * <p>Tonemapping / contrast / gamma curve to use when {@link CaptureRequest#TONEMAP_MODE android.tonemap.mode}\n     * is CONTRAST_CURVE.</p>\n     * <p>The tonemapCurve consist of three curves for each of red, green, and blue\n     * channels respectively. The following example uses the red channel as an\n     * example. The same logic applies to green and blue channel.\n     * Each channel's curve is defined by an array of control points:</p>\n     * <pre><code>curveRed =\n     *   [ P0(in, out), P1(in, out), P2(in, out), P3(in, out), ..., PN(in, out) ]\n     * 2 &lt;= N &lt;= {@link CameraCharacteristics#TONEMAP_MAX_CURVE_POINTS android.tonemap.maxCurvePoints}</code></pre>\n     * <p>These are sorted in order of increasing <code>Pin</code>; it is always\n     * guaranteed that input values 0.0 and 1.0 are included in the list to\n     * define a complete mapping. For input values between control points,\n     * the camera device must linearly interpolate between the control\n     * points.</p>\n     * <p>Each curve can have an independent number of points, and the number\n     * of points can be less than max (that is, the request doesn't have to\n     * always provide a curve with number of points equivalent to\n     * {@link CameraCharacteristics#TONEMAP_MAX_CURVE_POINTS android.tonemap.maxCurvePoints}).</p>\n     * <p>For devices with MONOCHROME capability, all three channels must have the same set of\n     * control points.</p>\n     * <p>A few examples, and their corresponding graphical mappings; these\n     * only specify the red channel and the precision is limited to 4\n     * digits, for conciseness.</p>\n     * <p>Linear mapping:</p>\n     * <pre><code>curveRed = [ (0, 0), (1.0, 1.0) ]\n     * </code></pre>\n     * <p><img alt=\"Linear mapping curve\" src=\"/reference/images/camera2/metadata/android.tonemap.curveRed/linear_tonemap.png\" /></p>\n     * <p>Invert mapping:</p>\n     * <pre><code>curveRed = [ (0, 1.0), (1.0, 0) ]\n     * </code></pre>\n     * <p><img alt=\"Inverting mapping curve\" src=\"/reference/images/camera2/metadata/android.tonemap.curveRed/inverse_tonemap.png\" /></p>\n     * <p>Gamma 1/2.2 mapping, with 16 control points:</p>\n     * <pre><code>curveRed = [\n     *   (0.0000, 0.0000), (0.0667, 0.2920), (0.1333, 0.4002), (0.2000, 0.4812),\n     *   (0.2667, 0.5484), (0.3333, 0.6069), (0.4000, 0.6594), (0.4667, 0.7072),\n     *   (0.5333, 0.7515), (0.6000, 0.7928), (0.6667, 0.8317), (0.7333, 0.8685),\n     *   (0.8000, 0.9035), (0.8667, 0.9370), (0.9333, 0.9691), (1.0000, 1.0000) ]\n     * </code></pre>\n     * <p><img alt=\"Gamma = 1/2.2 tonemapping curve\" src=\"/reference/images/camera2/metadata/android.tonemap.curveRed/gamma_tonemap.png\" /></p>\n     * <p>Standard sRGB gamma mapping, per IEC 61966-2-1:1999, with 16 control points:</p>\n     * <pre><code>curveRed = [\n     *   (0.0000, 0.0000), (0.0667, 0.2864), (0.1333, 0.4007), (0.2000, 0.4845),\n     *   (0.2667, 0.5532), (0.3333, 0.6125), (0.4000, 0.6652), (0.4667, 0.7130),\n     *   (0.5333, 0.7569), (0.6000, 0.7977), (0.6667, 0.8360), (0.7333, 0.8721),\n     *   (0.8000, 0.9063), (0.8667, 0.9389), (0.9333, 0.9701), (1.0000, 1.0000) ]\n     * </code></pre>\n     * <p><img alt=\"sRGB tonemapping curve\" src=\"/reference/images/camera2/metadata/android.tonemap.curveRed/srgb_tonemap.png\" /></p>\n     * <p><b>Optional</b> - The value for this key may be {@code null} on some devices.</p>\n     * <p><b>Full capability</b> -\n     * Present on all camera devices that report being {@link CameraCharacteristics#INFO_SUPPORTED_HARDWARE_LEVEL_FULL HARDWARE_LEVEL_FULL} devices in the\n     * {@link CameraCharacteristics#INFO_SUPPORTED_HARDWARE_LEVEL android.info.supportedHardwareLevel} key</p>\n     *\n     * @see CameraCharacteristics#INFO_SUPPORTED_HARDWARE_LEVEL\n     * @see CameraCharacteristics#TONEMAP_MAX_CURVE_POINTS\n     * @see CaptureRequest#TONEMAP_MODE\n     ",
    "links" : [ "CaptureRequest#TONEMAP_MODE", "CameraCharacteristics#TONEMAP_MAX_CURVE_POINTS", "CameraCharacteristics#TONEMAP_MAX_CURVE_POINTS", "CameraCharacteristics#INFO_SUPPORTED_HARDWARE_LEVEL_FULL", "CameraCharacteristics#INFO_SUPPORTED_HARDWARE_LEVEL" ]
  }, {
    "name" : "TONEMAP_MODE",
    "type" : "Key<Integer>",
    "comment" : "\n     * <p>High-level global contrast/gamma/tonemapping control.</p>\n     * <p>When switching to an application-defined contrast curve by setting\n     * {@link CaptureRequest#TONEMAP_MODE android.tonemap.mode} to CONTRAST_CURVE, the curve is defined\n     * per-channel with a set of <code>(in, out)</code> points that specify the\n     * mapping from input high-bit-depth pixel value to the output\n     * low-bit-depth value.  Since the actual pixel ranges of both input\n     * and output may change depending on the camera pipeline, the values\n     * are specified by normalized floating-point numbers.</p>\n     * <p>More-complex color mapping operations such as 3D color look-up\n     * tables, selective chroma enhancement, or other non-linear color\n     * transforms will be disabled when {@link CaptureRequest#TONEMAP_MODE android.tonemap.mode} is\n     * CONTRAST_CURVE.</p>\n     * <p>When using either FAST or HIGH_QUALITY, the camera device will\n     * emit its own tonemap curve in {@link CaptureRequest#TONEMAP_CURVE android.tonemap.curve}.\n     * These values are always available, and as close as possible to the\n     * actually used nonlinear/nonglobal transforms.</p>\n     * <p>If a request is sent with CONTRAST_CURVE with the camera device's\n     * provided curve in FAST or HIGH_QUALITY, the image's tonemap will be\n     * roughly the same.</p>\n     * <p><b>Possible values:</b>\n     * <ul>\n     *   <li>{@link #TONEMAP_MODE_CONTRAST_CURVE CONTRAST_CURVE}</li>\n     *   <li>{@link #TONEMAP_MODE_FAST FAST}</li>\n     *   <li>{@link #TONEMAP_MODE_HIGH_QUALITY HIGH_QUALITY}</li>\n     *   <li>{@link #TONEMAP_MODE_GAMMA_VALUE GAMMA_VALUE}</li>\n     *   <li>{@link #TONEMAP_MODE_PRESET_CURVE PRESET_CURVE}</li>\n     * </ul></p>\n     * <p><b>Available values for this device:</b><br>\n     * {@link CameraCharacteristics#TONEMAP_AVAILABLE_TONE_MAP_MODES android.tonemap.availableToneMapModes}</p>\n     * <p><b>Optional</b> - The value for this key may be {@code null} on some devices.</p>\n     * <p><b>Full capability</b> -\n     * Present on all camera devices that report being {@link CameraCharacteristics#INFO_SUPPORTED_HARDWARE_LEVEL_FULL HARDWARE_LEVEL_FULL} devices in the\n     * {@link CameraCharacteristics#INFO_SUPPORTED_HARDWARE_LEVEL android.info.supportedHardwareLevel} key</p>\n     *\n     * @see CameraCharacteristics#INFO_SUPPORTED_HARDWARE_LEVEL\n     * @see CameraCharacteristics#TONEMAP_AVAILABLE_TONE_MAP_MODES\n     * @see CaptureRequest#TONEMAP_CURVE\n     * @see CaptureRequest#TONEMAP_MODE\n     * @see #TONEMAP_MODE_CONTRAST_CURVE\n     * @see #TONEMAP_MODE_FAST\n     * @see #TONEMAP_MODE_HIGH_QUALITY\n     * @see #TONEMAP_MODE_GAMMA_VALUE\n     * @see #TONEMAP_MODE_PRESET_CURVE\n     ",
    "links" : [ "CaptureRequest#TONEMAP_MODE", "CaptureRequest#TONEMAP_MODE", "CaptureRequest#TONEMAP_CURVE", "#TONEMAP_MODE_CONTRAST_CURVE", "#TONEMAP_MODE_FAST", "#TONEMAP_MODE_HIGH_QUALITY", "#TONEMAP_MODE_GAMMA_VALUE", "#TONEMAP_MODE_PRESET_CURVE", "CameraCharacteristics#TONEMAP_AVAILABLE_TONE_MAP_MODES", "CameraCharacteristics#INFO_SUPPORTED_HARDWARE_LEVEL_FULL", "CameraCharacteristics#INFO_SUPPORTED_HARDWARE_LEVEL" ]
  }, {
    "name" : "TONEMAP_GAMMA",
    "type" : "Key<Float>",
    "comment" : "\n     * <p>Tonemapping curve to use when {@link CaptureRequest#TONEMAP_MODE android.tonemap.mode} is\n     * GAMMA_VALUE</p>\n     * <p>The tonemap curve will be defined the following formula:\n     * * OUT = pow(IN, 1.0 / gamma)\n     * where IN and OUT is the input pixel value scaled to range [0.0, 1.0],\n     * pow is the power function and gamma is the gamma value specified by this\n     * key.</p>\n     * <p>The same curve will be applied to all color channels. The camera device\n     * may clip the input gamma value to its supported range. The actual applied\n     * value will be returned in capture result.</p>\n     * <p>The valid range of gamma value varies on different devices, but values\n     * within [1.0, 5.0] are guaranteed not to be clipped.</p>\n     * <p><b>Optional</b> - The value for this key may be {@code null} on some devices.</p>\n     *\n     * @see CaptureRequest#TONEMAP_MODE\n     ",
    "links" : [ "CaptureRequest#TONEMAP_MODE" ]
  }, {
    "name" : "TONEMAP_PRESET_CURVE",
    "type" : "Key<Integer>",
    "comment" : "\n     * <p>Tonemapping curve to use when {@link CaptureRequest#TONEMAP_MODE android.tonemap.mode} is\n     * PRESET_CURVE</p>\n     * <p>The tonemap curve will be defined by specified standard.</p>\n     * <p>sRGB (approximated by 16 control points):</p>\n     * <p><img alt=\"sRGB tonemapping curve\" src=\"/reference/images/camera2/metadata/android.tonemap.curveRed/srgb_tonemap.png\" /></p>\n     * <p>Rec. 709 (approximated by 16 control points):</p>\n     * <p><img alt=\"Rec. 709 tonemapping curve\" src=\"/reference/images/camera2/metadata/android.tonemap.curveRed/rec709_tonemap.png\" /></p>\n     * <p>Note that above figures show a 16 control points approximation of preset\n     * curves. Camera devices may apply a different approximation to the curve.</p>\n     * <p><b>Possible values:</b>\n     * <ul>\n     *   <li>{@link #TONEMAP_PRESET_CURVE_SRGB SRGB}</li>\n     *   <li>{@link #TONEMAP_PRESET_CURVE_REC709 REC709}</li>\n     * </ul></p>\n     * <p><b>Optional</b> - The value for this key may be {@code null} on some devices.</p>\n     *\n     * @see CaptureRequest#TONEMAP_MODE\n     * @see #TONEMAP_PRESET_CURVE_SRGB\n     * @see #TONEMAP_PRESET_CURVE_REC709\n     ",
    "links" : [ "CaptureRequest#TONEMAP_MODE", "#TONEMAP_PRESET_CURVE_SRGB", "#TONEMAP_PRESET_CURVE_REC709" ]
  }, {
    "name" : "LED_TRANSMIT",
    "type" : "Key<Boolean>",
    "comment" : "\n     * <p>This LED is nominally used to indicate to the user\n     * that the camera is powered on and may be streaming images back to the\n     * Application Processor. In certain rare circumstances, the OS may\n     * disable this when video is processed locally and not transmitted to\n     * any untrusted applications.</p>\n     * <p>In particular, the LED <em>must</em> always be on when the data could be\n     * transmitted off the device. The LED <em>should</em> always be on whenever\n     * data is stored locally on the device.</p>\n     * <p>The LED <em>may</em> be off if a trusted application is using the data that\n     * doesn't violate the above rules.</p>\n     * <p><b>Optional</b> - The value for this key may be {@code null} on some devices.</p>\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "BLACK_LEVEL_LOCK",
    "type" : "Key<Boolean>",
    "comment" : "\n     * <p>Whether black-level compensation is locked\n     * to its current values, or is free to vary.</p>\n     * <p>When set to <code>true</code> (ON), the values used for black-level\n     * compensation will not change until the lock is set to\n     * <code>false</code> (OFF).</p>\n     * <p>Since changes to certain capture parameters (such as\n     * exposure time) may require resetting of black level\n     * compensation, the camera device must report whether setting\n     * the black level lock was successful in the output result\n     * metadata.</p>\n     * <p>For example, if a sequence of requests is as follows:</p>\n     * <ul>\n     * <li>Request 1: Exposure = 10ms, Black level lock = OFF</li>\n     * <li>Request 2: Exposure = 10ms, Black level lock = ON</li>\n     * <li>Request 3: Exposure = 10ms, Black level lock = ON</li>\n     * <li>Request 4: Exposure = 20ms, Black level lock = ON</li>\n     * <li>Request 5: Exposure = 20ms, Black level lock = ON</li>\n     * <li>Request 6: Exposure = 20ms, Black level lock = ON</li>\n     * </ul>\n     * <p>And the exposure change in Request 4 requires the camera\n     * device to reset the black level offsets, then the output\n     * result metadata is expected to be:</p>\n     * <ul>\n     * <li>Result 1: Exposure = 10ms, Black level lock = OFF</li>\n     * <li>Result 2: Exposure = 10ms, Black level lock = ON</li>\n     * <li>Result 3: Exposure = 10ms, Black level lock = ON</li>\n     * <li>Result 4: Exposure = 20ms, Black level lock = OFF</li>\n     * <li>Result 5: Exposure = 20ms, Black level lock = ON</li>\n     * <li>Result 6: Exposure = 20ms, Black level lock = ON</li>\n     * </ul>\n     * <p>This indicates to the application that on frame 4, black\n     * levels were reset due to exposure value changes, and pixel\n     * values may not be consistent across captures.</p>\n     * <p>The camera device will maintain the lock to the extent\n     * possible, only overriding the lock to OFF when changes to\n     * other request parameters require a black level recalculation\n     * or reset.</p>\n     * <p><b>Optional</b> - The value for this key may be {@code null} on some devices.</p>\n     * <p><b>Full capability</b> -\n     * Present on all camera devices that report being {@link CameraCharacteristics#INFO_SUPPORTED_HARDWARE_LEVEL_FULL HARDWARE_LEVEL_FULL} devices in the\n     * {@link CameraCharacteristics#INFO_SUPPORTED_HARDWARE_LEVEL android.info.supportedHardwareLevel} key</p>\n     *\n     * @see CameraCharacteristics#INFO_SUPPORTED_HARDWARE_LEVEL\n     ",
    "links" : [ "CameraCharacteristics#INFO_SUPPORTED_HARDWARE_LEVEL_FULL", "CameraCharacteristics#INFO_SUPPORTED_HARDWARE_LEVEL" ]
  }, {
    "name" : "REPROCESS_EFFECTIVE_EXPOSURE_FACTOR",
    "type" : "Key<Float>",
    "comment" : "\n     * <p>The amount of exposure time increase factor applied to the original output\n     * frame by the application processing before sending for reprocessing.</p>\n     * <p>This is optional, and will be supported if the camera device supports YUV_REPROCESSING\n     * capability ({@link CameraCharacteristics#REQUEST_AVAILABLE_CAPABILITIES android.request.availableCapabilities} contains YUV_REPROCESSING).</p>\n     * <p>For some YUV reprocessing use cases, the application may choose to filter the original\n     * output frames to effectively reduce the noise to the same level as a frame that was\n     * captured with longer exposure time. To be more specific, assuming the original captured\n     * images were captured with a sensitivity of S and an exposure time of T, the model in\n     * the camera device is that the amount of noise in the image would be approximately what\n     * would be expected if the original capture parameters had been a sensitivity of\n     * S/effectiveExposureFactor and an exposure time of T*effectiveExposureFactor, rather\n     * than S and T respectively. If the captured images were processed by the application\n     * before being sent for reprocessing, then the application may have used image processing\n     * algorithms and/or multi-frame image fusion to reduce the noise in the\n     * application-processed images (input images). By using the effectiveExposureFactor\n     * control, the application can communicate to the camera device the actual noise level\n     * improvement in the application-processed image. With this information, the camera\n     * device can select appropriate noise reduction and edge enhancement parameters to avoid\n     * excessive noise reduction ({@link CaptureRequest#NOISE_REDUCTION_MODE android.noiseReduction.mode}) and insufficient edge\n     * enhancement ({@link CaptureRequest#EDGE_MODE android.edge.mode}) being applied to the reprocessed frames.</p>\n     * <p>For example, for multi-frame image fusion use case, the application may fuse\n     * multiple output frames together to a final frame for reprocessing. When N image are\n     * fused into 1 image for reprocessing, the exposure time increase factor could be up to\n     * square root of N (based on a simple photon shot noise model). The camera device will\n     * adjust the reprocessing noise reduction and edge enhancement parameters accordingly to\n     * produce the best quality images.</p>\n     * <p>This is relative factor, 1.0 indicates the application hasn't processed the input\n     * buffer in a way that affects its effective exposure time.</p>\n     * <p>This control is only effective for YUV reprocessing capture request. For noise\n     * reduction reprocessing, it is only effective when <code>{@link CaptureRequest#NOISE_REDUCTION_MODE android.noiseReduction.mode} != OFF</code>.\n     * Similarly, for edge enhancement reprocessing, it is only effective when\n     * <code>{@link CaptureRequest#EDGE_MODE android.edge.mode} != OFF</code>.</p>\n     * <p><b>Units</b>: Relative exposure time increase factor.</p>\n     * <p><b>Range of valid values:</b><br>\n     * &gt;= 1.0</p>\n     * <p><b>Optional</b> - The value for this key may be {@code null} on some devices.</p>\n     * <p><b>Limited capability</b> -\n     * Present on all camera devices that report being at least {@link CameraCharacteristics#INFO_SUPPORTED_HARDWARE_LEVEL_LIMITED HARDWARE_LEVEL_LIMITED} devices in the\n     * {@link CameraCharacteristics#INFO_SUPPORTED_HARDWARE_LEVEL android.info.supportedHardwareLevel} key</p>\n     *\n     * @see CaptureRequest#EDGE_MODE\n     * @see CameraCharacteristics#INFO_SUPPORTED_HARDWARE_LEVEL\n     * @see CaptureRequest#NOISE_REDUCTION_MODE\n     * @see CameraCharacteristics#REQUEST_AVAILABLE_CAPABILITIES\n     ",
    "links" : [ "CameraCharacteristics#REQUEST_AVAILABLE_CAPABILITIES", "CaptureRequest#NOISE_REDUCTION_MODE", "CaptureRequest#EDGE_MODE", "CaptureRequest#NOISE_REDUCTION_MODE", "CaptureRequest#EDGE_MODE", "CameraCharacteristics#INFO_SUPPORTED_HARDWARE_LEVEL_LIMITED", "CameraCharacteristics#INFO_SUPPORTED_HARDWARE_LEVEL" ]
  }, {
    "name" : "DISTORTION_CORRECTION_MODE",
    "type" : "Key<Integer>",
    "comment" : "\n     * <p>Mode of operation for the lens distortion correction block.</p>\n     * <p>The lens distortion correction block attempts to improve image quality by fixing\n     * radial, tangential, or other geometric aberrations in the camera device's optics.  If\n     * available, the {@link CameraCharacteristics#LENS_DISTORTION android.lens.distortion} field documents the lens's distortion parameters.</p>\n     * <p>OFF means no distortion correction is done.</p>\n     * <p>FAST/HIGH_QUALITY both mean camera device determined distortion correction will be\n     * applied. HIGH_QUALITY mode indicates that the camera device will use the highest-quality\n     * correction algorithms, even if it slows down capture rate. FAST means the camera device\n     * will not slow down capture rate when applying correction. FAST may be the same as OFF if\n     * any correction at all would slow down capture rate.  Every output stream will have a\n     * similar amount of enhancement applied.</p>\n     * <p>The correction only applies to processed outputs such as YUV, Y8, JPEG, or DEPTH16; it is\n     * not applied to any RAW output.</p>\n     * <p>This control will be on by default on devices that support this control. Applications\n     * disabling distortion correction need to pay extra attention with the coordinate system of\n     * metering regions, crop region, and face rectangles. When distortion correction is OFF,\n     * metadata coordinates follow the coordinate system of\n     * {@link CameraCharacteristics#SENSOR_INFO_PRE_CORRECTION_ACTIVE_ARRAY_SIZE android.sensor.info.preCorrectionActiveArraySize}. When distortion is not OFF, metadata\n     * coordinates follow the coordinate system of {@link CameraCharacteristics#SENSOR_INFO_ACTIVE_ARRAY_SIZE android.sensor.info.activeArraySize}.  The\n     * camera device will map these metadata fields to match the corrected image produced by the\n     * camera device, for both capture requests and results.  However, this mapping is not very\n     * precise, since rectangles do not generally map to rectangles when corrected.  Only linear\n     * scaling between the active array and precorrection active array coordinates is\n     * performed. Applications that require precise correction of metadata need to undo that\n     * linear scaling, and apply a more complete correction that takes into the account the app's\n     * own requirements.</p>\n     * <p>The full list of metadata that is affected in this way by distortion correction is:</p>\n     * <ul>\n     * <li>{@link CaptureRequest#CONTROL_AF_REGIONS android.control.afRegions}</li>\n     * <li>{@link CaptureRequest#CONTROL_AE_REGIONS android.control.aeRegions}</li>\n     * <li>{@link CaptureRequest#CONTROL_AWB_REGIONS android.control.awbRegions}</li>\n     * <li>{@link CaptureRequest#SCALER_CROP_REGION android.scaler.cropRegion}</li>\n     * <li>{@link CaptureResult#STATISTICS_FACES android.statistics.faces}</li>\n     * </ul>\n     * <p><b>Possible values:</b>\n     * <ul>\n     *   <li>{@link #DISTORTION_CORRECTION_MODE_OFF OFF}</li>\n     *   <li>{@link #DISTORTION_CORRECTION_MODE_FAST FAST}</li>\n     *   <li>{@link #DISTORTION_CORRECTION_MODE_HIGH_QUALITY HIGH_QUALITY}</li>\n     * </ul></p>\n     * <p><b>Available values for this device:</b><br>\n     * {@link CameraCharacteristics#DISTORTION_CORRECTION_AVAILABLE_MODES android.distortionCorrection.availableModes}</p>\n     * <p><b>Optional</b> - The value for this key may be {@code null} on some devices.</p>\n     *\n     * @see CaptureRequest#CONTROL_AE_REGIONS\n     * @see CaptureRequest#CONTROL_AF_REGIONS\n     * @see CaptureRequest#CONTROL_AWB_REGIONS\n     * @see CameraCharacteristics#DISTORTION_CORRECTION_AVAILABLE_MODES\n     * @see CameraCharacteristics#LENS_DISTORTION\n     * @see CaptureRequest#SCALER_CROP_REGION\n     * @see CameraCharacteristics#SENSOR_INFO_ACTIVE_ARRAY_SIZE\n     * @see CameraCharacteristics#SENSOR_INFO_PRE_CORRECTION_ACTIVE_ARRAY_SIZE\n     * @see CaptureResult#STATISTICS_FACES\n     * @see #DISTORTION_CORRECTION_MODE_OFF\n     * @see #DISTORTION_CORRECTION_MODE_FAST\n     * @see #DISTORTION_CORRECTION_MODE_HIGH_QUALITY\n     ",
    "links" : [ "CameraCharacteristics#LENS_DISTORTION", "CameraCharacteristics#SENSOR_INFO_PRE_CORRECTION_ACTIVE_ARRAY_SIZE", "CameraCharacteristics#SENSOR_INFO_ACTIVE_ARRAY_SIZE", "CaptureRequest#CONTROL_AF_REGIONS", "CaptureRequest#CONTROL_AE_REGIONS", "CaptureRequest#CONTROL_AWB_REGIONS", "CaptureRequest#SCALER_CROP_REGION", "CaptureResult#STATISTICS_FACES", "#DISTORTION_CORRECTION_MODE_OFF", "#DISTORTION_CORRECTION_MODE_FAST", "#DISTORTION_CORRECTION_MODE_HIGH_QUALITY", "CameraCharacteristics#DISTORTION_CORRECTION_AVAILABLE_MODES" ]
  } ],
  "methods" : [ {
    "name" : "public int getRequestType()",
    "returnType" : "int",
    "comment" : "\n     * Get the type of the capture request\n     *\n     * Return one of REGULAR, ZSL_STILL, or REPROCESS.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public T get(Key<T> key)",
    "returnType" : "T",
    "comment" : "\n     * Get a capture request field value.\n     *\n     * <p>The field definitions can be found in {@link CaptureRequest}.</p>\n     *\n     * <p>Querying the value for the same key more than once will return a value\n     * which is equal to the previous queried value.</p>\n     *\n     * @throws IllegalArgumentException if the key was not valid\n     *\n     * @param key The result field to read.\n     * @return The value of that key, or {@code null} if the field is not set.\n     ",
    "links" : [ "CaptureRequest" ]
  }, {
    "name" : "protected T getProtected(Key<?> key)",
    "returnType" : "T",
    "comment" : "\n     * {@inheritDoc}\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "protected Class<Key<?>> getKeyClass()",
    "returnType" : "Class<Key<?>>",
    "comment" : "\n     * {@inheritDoc}\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public List<Key<?>> getKeys()",
    "returnType" : "List<Key<?>>",
    "comment" : "\n     * {@inheritDoc}\n     ",
    "links" : [ ]
  }, {
    "name" : "public Object getTag()",
    "returnType" : "Object",
    "comment" : "\n     * Retrieve the tag for this request, if any.\n     *\n     * <p>This tag is not used for anything by the camera device, but can be\n     * used by an application to easily identify a CaptureRequest when it is\n     * returned by\n     * {@link CameraCaptureSession.CaptureCallback#onCaptureCompleted CaptureCallback.onCaptureCompleted}\n     * </p>\n     *\n     * @return the last tag Object set on this request, or {@code null} if\n     *     no tag has been set.\n     * @see Builder#setTag\n     ",
    "links" : [ "CameraCaptureSession.CaptureCallback#onCaptureCompleted" ]
  }, {
    "name" : "public boolean isReprocess()",
    "returnType" : "boolean",
    "comment" : "\n     * Determine if this is a reprocess capture request.\n     *\n     * <p>A reprocess capture request produces output images from an input buffer from the\n     * {@link CameraCaptureSession}'s input {@link Surface}. A reprocess capture request can be\n     * created by {@link CameraDevice#createReprocessCaptureRequest}.</p>\n     *\n     * @return {@code true} if this is a reprocess capture request. {@code false} if this is not a\n     * reprocess capture request.\n     *\n     * @see CameraDevice#createReprocessCaptureRequest\n     ",
    "links" : [ "CameraCaptureSession", "Surface", "CameraDevice#createReprocessCaptureRequest" ]
  }, {
    "name" : "public boolean isPartOfCRequestList()",
    "returnType" : "boolean",
    "comment" : "\n     * <p>Determine if this request is part of a constrained high speed request list that was\n     * created by\n     * {@link android.hardware.camera2.CameraConstrainedHighSpeedCaptureSession#createHighSpeedRequestList}.\n     * A constrained high speed request list contains some constrained high speed capture requests\n     * with certain interleaved pattern that is suitable for high speed preview/video streaming. An\n     * active constrained high speed capture session only accepts constrained high speed request\n     * lists.  This method can be used to do the correctness check when a constrained high speed\n     * capture session receives a request list via {@link CameraCaptureSession#setRepeatingBurst} or\n     * {@link CameraCaptureSession#captureBurst}.  </p>\n     *\n     *\n     * @return {@code true} if this request is part of a constrained high speed request list,\n     * {@code false} otherwise.\n     *\n     * @hide\n     ",
    "links" : [ "android.hardware.camera2.CameraConstrainedHighSpeedCaptureSession#createHighSpeedRequestList", "CameraCaptureSession#setRepeatingBurst", "CameraCaptureSession#captureBurst" ]
  }, {
    "name" : "public CameraMetadataNative getNativeCopy()",
    "returnType" : "CameraMetadataNative",
    "comment" : "\n     * Returns a copy of the underlying {@link CameraMetadataNative}.\n     * @hide\n     ",
    "links" : [ "CameraMetadataNative" ]
  }, {
    "name" : "public int getReprocessableSessionId()",
    "returnType" : "int",
    "comment" : "\n     * Get the reprocessable session ID this reprocess capture request is associated with.\n     *\n     * @return the reprocessable session ID this reprocess capture request is associated with\n     *\n     * @throws IllegalStateException if this capture request is not a reprocess capture request.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean equals(Object other)",
    "returnType" : "boolean",
    "comment" : "\n     * Determine whether this CaptureRequest is equal to another CaptureRequest.\n     *\n     * <p>A request is considered equal to another is if it's set of key/values is equal, it's\n     * list of output surfaces is equal, the user tag is equal, and the return values of\n     * isReprocess() are equal.</p>\n     *\n     * @param other Another instance of CaptureRequest.\n     *\n     * @return True if the requests are the same, false otherwise.\n     ",
    "links" : [ ]
  }, {
    "name" : "private boolean equals(CaptureRequest other)",
    "returnType" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public int hashCode()",
    "returnType" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private void readFromParcel(Parcel in)",
    "returnType" : "void",
    "comment" : "\n     * Expand this object from a Parcel.\n     * Hidden since this breaks the immutability of CaptureRequest, but is\n     * needed to receive CaptureRequests with aidl.\n     *\n     * @param in The parcel from which the object should be read\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public int describeContents()",
    "returnType" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public void writeToParcel(Parcel dest, int flags)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public boolean containsTarget(Surface surface)",
    "returnType" : "boolean",
    "comment" : "\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public Collection<Surface> getTargets()",
    "returnType" : "Collection<Surface>",
    "comment" : "\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public String getLogicalCameraId()",
    "returnType" : "String",
    "comment" : "\n     * Retrieves the logical camera id.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public void convertSurfaceToStreamId(final SparseArray<OutputConfiguration> configuredOutputs)",
    "returnType" : "void",
    "comment" : "\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public void recoverStreamIdToSurface()",
    "returnType" : "void",
    "comment" : "\n     * @hide\n     ",
    "links" : [ ]
  } ],
  "variableNames" : [ "TAG", "mSurfaceSet", "mSurfacesLock", "mSurfaceConverted", "mStreamIdxArray", "mSurfaceIdxArray", "mEmptySurfaceSet", "mLogicalCameraId", "mLogicalCameraSettings", "mPhysicalCameraSettings", "mIsReprocess", "REQUEST_TYPE_REGULAR", "REQUEST_TYPE_REPROCESS", "REQUEST_TYPE_ZSL_STILL", "REQUEST_TYPE_COUNT", "mRequestType", "mIsPartOfCHSRequestList", "mReprocessableSessionId", "mUserTag", "CREATOR", "COLOR_CORRECTION_MODE", "COLOR_CORRECTION_TRANSFORM", "COLOR_CORRECTION_GAINS", "COLOR_CORRECTION_ABERRATION_MODE", "CONTROL_AE_ANTIBANDING_MODE", "CONTROL_AE_EXPOSURE_COMPENSATION", "CONTROL_AE_LOCK", "CONTROL_AE_MODE", "CONTROL_AE_REGIONS", "CONTROL_AE_TARGET_FPS_RANGE", "CONTROL_AE_PRECAPTURE_TRIGGER", "CONTROL_AF_MODE", "CONTROL_AF_REGIONS", "CONTROL_AF_TRIGGER", "CONTROL_AWB_LOCK", "CONTROL_AWB_MODE", "CONTROL_AWB_REGIONS", "CONTROL_CAPTURE_INTENT", "CONTROL_EFFECT_MODE", "CONTROL_MODE", "CONTROL_SCENE_MODE", "CONTROL_VIDEO_STABILIZATION_MODE", "CONTROL_POST_RAW_SENSITIVITY_BOOST", "CONTROL_ENABLE_ZSL", "CONTROL_EXTENDED_SCENE_MODE", "CONTROL_ZOOM_RATIO", "EDGE_MODE", "FLASH_MODE", "HOT_PIXEL_MODE", "JPEG_GPS_LOCATION", "JPEG_GPS_COORDINATES", "JPEG_GPS_PROCESSING_METHOD", "JPEG_GPS_TIMESTAMP", "JPEG_ORIENTATION", "JPEG_QUALITY", "JPEG_THUMBNAIL_QUALITY", "JPEG_THUMBNAIL_SIZE", "LENS_APERTURE", "LENS_FILTER_DENSITY", "LENS_FOCAL_LENGTH", "LENS_FOCUS_DISTANCE", "LENS_OPTICAL_STABILIZATION_MODE", "NOISE_REDUCTION_MODE", "REQUEST_ID", "SCALER_CROP_REGION", "SCALER_ROTATE_AND_CROP", "SENSOR_EXPOSURE_TIME", "SENSOR_FRAME_DURATION", "SENSOR_SENSITIVITY", "SENSOR_TEST_PATTERN_DATA", "SENSOR_TEST_PATTERN_MODE", "SHADING_MODE", "STATISTICS_FACE_DETECT_MODE", "STATISTICS_HOT_PIXEL_MAP_MODE", "STATISTICS_LENS_SHADING_MAP_MODE", "STATISTICS_OIS_DATA_MODE", "TONEMAP_CURVE_BLUE", "TONEMAP_CURVE_GREEN", "TONEMAP_CURVE_RED", "TONEMAP_CURVE", "TONEMAP_MODE", "TONEMAP_GAMMA", "TONEMAP_PRESET_CURVE", "LED_TRANSMIT", "BLACK_LEVEL_LOCK", "REPROCESS_EFFECTIVE_EXPOSURE_FACTOR", "DISTORTION_CORRECTION_MODE" ],
  "methodNames" : [ "public int getRequestType()", "public T get(Key<T> key)", "protected T getProtected(Key<?> key)", "protected Class<Key<?>> getKeyClass()", "public List<Key<?>> getKeys()", "public Object getTag()", "public boolean isReprocess()", "public boolean isPartOfCRequestList()", "public CameraMetadataNative getNativeCopy()", "public int getReprocessableSessionId()", "public boolean equals(Object other)", "private boolean equals(CaptureRequest other)", "public int hashCode()", "private void readFromParcel(Parcel in)", "public int describeContents()", "public void writeToParcel(Parcel dest, int flags)", "public boolean containsTarget(Surface surface)", "public Collection<Surface> getTargets()", "public String getLogicalCameraId()", "public void convertSurfaceToStreamId(final SparseArray<OutputConfiguration> configuredOutputs)", "public void recoverStreamIdToSurface()" ]
}