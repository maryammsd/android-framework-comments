{
  "filePath" : "/home/maryam/clearblue/files/android-source-35/android/content/Context.java",
  "packageName" : "android.content",
  "className" : "Context",
  "comment" : "\n * Interface to global information about an application environment.  This is\n * an abstract class whose implementation is provided by\n * the Android system.  It\n * allows access to application-specific resources and classes, as well as\n * up-calls for application-level operations such as launching activities,\n * broadcasting and receiving intents, etc.\n ",
  "links" : [ ],
  "variables" : [ {
    "name" : "OVERRIDABLE_COMPONENT_CALLBACKS",
    "type" : "long",
    "comment" : "\n     * After {@link Build.VERSION_CODES#TIRAMISU},\n     * {@link #registerComponentCallbacks(ComponentCallbacks)} will add a {@link ComponentCallbacks}\n     * to {@link Activity} or {@link ContextWrapper#getBaseContext()} instead of always adding to\n     * {@link #getApplicationContext()}.\n     *\n     * @hide\n     ",
    "links" : [ "#registerComponentCallbacks(ComponentCallbacks)", "Build.VERSION_CODES#TIRAMISU", "android.content.ComponentCallbacks", "#getApplicationContext()", "android.content.ContextWrapper#getBaseContext()", "android.app.Activity" ]
  }, {
    "name" : "DEVICE_ID_DEFAULT",
    "type" : "int",
    "comment" : "\n     * The default device ID, which is the ID of the primary (non-virtual) device.\n     ",
    "links" : [ ]
  }, {
    "name" : "DEVICE_ID_INVALID",
    "type" : "int",
    "comment" : "\n     * Invalid device ID.\n     ",
    "links" : [ ]
  }, {
    "name" : "MODE_PRIVATE",
    "type" : "int",
    "comment" : "\n     * File creation mode: the default mode, where the created file can only\n     * be accessed by the calling application (or all applications sharing the\n     * same user ID).\n     ",
    "links" : [ ]
  }, {
    "name" : "MODE_WORLD_READABLE",
    "type" : "int",
    "comment" : "\n     * File creation mode: allow all other applications to have read access to\n     * the created file.\n     * <p>\n     * Starting from {@link android.os.Build.VERSION_CODES#N}, attempting to use this\n     * mode throws a {@link SecurityException}.\n     *\n     * @deprecated Creating world-readable files is very dangerous, and likely\n     *             to cause security holes in applications. It is strongly\n     *             discouraged; instead, applications should use more formal\n     *             mechanism for interactions such as {@link ContentProvider},\n     *             {@link BroadcastReceiver}, and {@link android.app.Service}.\n     *             There are no guarantees that this access mode will remain on\n     *             a file, such as when it goes through a backup and restore.\n     * @see androidx.core.content.FileProvider\n     * @see Intent#FLAG_GRANT_WRITE_URI_PERMISSION\n     ",
    "links" : [ "android.app.Service", "SecurityException", "android.content.ContentProvider", "android.content.BroadcastReceiver", "android.os.Build.VERSION_CODES#N" ]
  }, {
    "name" : "MODE_WORLD_WRITEABLE",
    "type" : "int",
    "comment" : "\n     * File creation mode: allow all other applications to have write access to\n     * the created file.\n     * <p>\n     * Starting from {@link android.os.Build.VERSION_CODES#N}, attempting to use this\n     * mode will throw a {@link SecurityException}.\n     *\n     * @deprecated Creating world-writable files is very dangerous, and likely\n     *             to cause security holes in applications. It is strongly\n     *             discouraged; instead, applications should use more formal\n     *             mechanism for interactions such as {@link ContentProvider},\n     *             {@link BroadcastReceiver}, and {@link android.app.Service}.\n     *             There are no guarantees that this access mode will remain on\n     *             a file, such as when it goes through a backup and restore.\n     * @see androidx.core.content.FileProvider\n     * @see Intent#FLAG_GRANT_WRITE_URI_PERMISSION\n     ",
    "links" : [ "android.app.Service", "SecurityException", "android.content.ContentProvider", "android.content.BroadcastReceiver", "android.os.Build.VERSION_CODES#N" ]
  }, {
    "name" : "MODE_APPEND",
    "type" : "int",
    "comment" : "\n     * File creation mode: for use with {@link #openFileOutput}, if the file\n     * already exists then write data to the end of the existing file\n     * instead of erasing it.\n     * @see #openFileOutput\n     ",
    "links" : [ "#openFileOutput" ]
  }, {
    "name" : "MODE_MULTI_PROCESS",
    "type" : "int",
    "comment" : "\n     * SharedPreference loading flag: when set, the file on disk will\n     * be checked for modification even if the shared preferences\n     * instance is already loaded in this process.  This behavior is\n     * sometimes desired in cases where the application has multiple\n     * processes, all writing to the same SharedPreferences file.\n     * Generally there are better forms of communication between\n     * processes, though.\n     *\n     * <p>This was the legacy (but undocumented) behavior in and\n     * before Gingerbread (Android 2.3) and this flag is implied when\n     * targeting such releases.  For applications targeting SDK\n     * versions <em>greater than</em> Android 2.3, this flag must be\n     * explicitly set if desired.\n     *\n     * @see #getSharedPreferences\n     *\n     * @deprecated MODE_MULTI_PROCESS does not work reliably in\n     * some versions of Android, and furthermore does not provide any\n     * mechanism for reconciling concurrent modifications across\n     * processes.  Applications should not attempt to use it.  Instead,\n     * they should use an explicit cross-process data management\n     * approach such as {@link android.content.ContentProvider ContentProvider}.\n     ",
    "links" : [ "android.content.ContentProvider" ]
  }, {
    "name" : "MODE_ENABLE_WRITE_AHEAD_LOGGING",
    "type" : "int",
    "comment" : "\n     * Database open flag: when set, the database is opened with write-ahead\n     * logging enabled by default.\n     *\n     * @see #openOrCreateDatabase(String, int, CursorFactory)\n     * @see #openOrCreateDatabase(String, int, CursorFactory, DatabaseErrorHandler)\n     * @see SQLiteDatabase#enableWriteAheadLogging\n     ",
    "links" : [ ]
  }, {
    "name" : "MODE_NO_LOCALIZED_COLLATORS",
    "type" : "int",
    "comment" : "\n     * Database open flag: when set, the database is opened without support for\n     * localized collators.\n     *\n     * @see #openOrCreateDatabase(String, int, CursorFactory)\n     * @see #openOrCreateDatabase(String, int, CursorFactory, DatabaseErrorHandler)\n     * @see SQLiteDatabase#NO_LOCALIZED_COLLATORS\n     ",
    "links" : [ ]
  }, {
    "name" : "BIND_AUTO_CREATE",
    "type" : "int",
    "comment" : "\n     * Flag for {@link #bindService}: automatically create the service as long\n     * as the binding exists.  Note that while this will create the service,\n     * its {@link android.app.Service#onStartCommand}\n     * method will still only be called due to an\n     * explicit call to {@link #startService}.  Even without that, though,\n     * this still provides you with access to the service object while the\n     * service is created.\n     *\n     * <p>Note that prior to {@link android.os.Build.VERSION_CODES#ICE_CREAM_SANDWICH},\n     * not supplying this flag would also impact how important the system\n     * consider's the target service's process to be.  When set, the only way\n     * for it to be raised was by binding from a service in which case it will\n     * only be important when that activity is in the foreground.  Now to\n     * achieve this behavior you must explicitly supply the new flag\n     * {@link #BIND_ADJUST_WITH_ACTIVITY}.  For compatibility, old applications\n     * that don't specify {@link #BIND_AUTO_CREATE} will automatically have\n     * the flags {@link #BIND_WAIVE_PRIORITY} and\n     * {@link #BIND_ADJUST_WITH_ACTIVITY} set for them in order to achieve\n     * the same result.\n     ",
    "links" : [ "android.app.Service#onStartCommand", "android.os.Build.VERSION_CODES#ICE_CREAM_SANDWICH", "#BIND_WAIVE_PRIORITY", "#bindService", "#BIND_ADJUST_WITH_ACTIVITY", "#startService", "#BIND_AUTO_CREATE" ]
  }, {
    "name" : "BIND_DEBUG_UNBIND",
    "type" : "int",
    "comment" : "\n     * Flag for {@link #bindService}: include debugging help for mismatched\n     * calls to unbind.  When this flag is set, the callstack of the following\n     * {@link #unbindService} call is retained, to be printed if a later\n     * incorrect unbind call is made.  Note that doing this requires retaining\n     * information about the binding that was made for the lifetime of the app,\n     * resulting in a leak -- this should only be used for debugging.\n     ",
    "links" : [ "#unbindService", "#bindService" ]
  }, {
    "name" : "BIND_NOT_FOREGROUND",
    "type" : "int",
    "comment" : "\n     * Flag for {@link #bindService}: don't allow this binding to raise\n     * the target service's process to the foreground scheduling priority.\n     * It will still be raised to at least the same memory priority\n     * as the client (so that its process will not be killable in any\n     * situation where the client is not killable), but for CPU scheduling\n     * purposes it may be left in the background.  This only has an impact\n     * in the situation where the binding client is a foreground process\n     * and the target service is in a background process.\n     ",
    "links" : [ "#bindService" ]
  }, {
    "name" : "BIND_ABOVE_CLIENT",
    "type" : "int",
    "comment" : "\n     * Flag for {@link #bindService}: indicates that the client application\n     * binding to this service considers the service to be more important than\n     * the app itself.  When set, the platform will try to have the out of\n     * memory killer kill the app before it kills the service it is bound to, though\n     * this is not guaranteed to be the case.\n     ",
    "links" : [ "#bindService" ]
  }, {
    "name" : "BIND_ALLOW_OOM_MANAGEMENT",
    "type" : "int",
    "comment" : "\n     * Flag for {@link #bindService}: allow the process hosting the bound\n     * service to go through its normal memory management.  It will be\n     * treated more like a running service, allowing the system to\n     * (temporarily) expunge the process if low on memory or for some other\n     * whim it may have, and being more aggressive about making it a candidate\n     * to be killed (and restarted) if running for a long time.\n     ",
    "links" : [ "#bindService" ]
  }, {
    "name" : "BIND_WAIVE_PRIORITY",
    "type" : "int",
    "comment" : "\n     * Flag for {@link #bindService}: don't impact the scheduling or\n     * memory management priority of the target service's hosting process.\n     * Allows the service's process to be managed on the background LRU list\n     * just like a regular application process in the background.\n     ",
    "links" : [ "#bindService" ]
  }, {
    "name" : "BIND_IMPORTANT",
    "type" : "int",
    "comment" : "\n     * Flag for {@link #bindService}: this service is very important to\n     * the client, so should be brought to the foreground process level\n     * when the client is.  Normally a process can only be raised to the\n     * visibility level by a client, even if that client is in the foreground.\n     ",
    "links" : [ "#bindService" ]
  }, {
    "name" : "BIND_ADJUST_WITH_ACTIVITY",
    "type" : "int",
    "comment" : "\n     * Flag for {@link #bindService}: If binding from an activity, allow the\n     * target service's process importance to be raised based on whether the\n     * activity is visible to the user, regardless whether another flag is\n     * used to reduce the amount that the client process's overall importance\n     * is used to impact it.\n     ",
    "links" : [ "#bindService" ]
  }, {
    "name" : "BIND_NOT_PERCEPTIBLE",
    "type" : "int",
    "comment" : "\n     * Flag for {@link #bindService}: If binding from an app that is visible or user-perceptible,\n     * lower the target service's importance to below the perceptible level. This allows\n     * the system to (temporarily) expunge the bound process from memory to make room for more\n     * important user-perceptible processes.\n     ",
    "links" : [ "#bindService" ]
  }, {
    "name" : "BIND_ALLOW_ACTIVITY_STARTS",
    "type" : "int",
    "comment" : "\n     * Flag for {@link #bindService}: If binding from an app that is visible, the bound service is\n     * allowed to start an activity from background. This was the default behavior before SDK\n     * version {@link android.os.Build.VERSION_CODES#UPSIDE_DOWN_CAKE}. Since then, the default\n     * behavior changed to disallow the bound service to start a background activity even if the app\n     * bound to it is in foreground, unless this flag is specified when binding.\n     ",
    "links" : [ "android.os.Build.VERSION_CODES#UPSIDE_DOWN_CAKE", "#bindService" ]
  }, {
    "name" : "BIND_INCLUDE_CAPABILITIES",
    "type" : "int",
    "comment" : "\n     * Flag for {@link #bindService}: If binding from an app that has specific capabilities\n     * due to its foreground state such as an activity or foreground service, then this flag will\n     * allow the bound app to get the same capabilities, as long as it has the required permissions\n     * as well.\n     *\n     * If binding from a top app and its target SDK version is at or above\n     * {@link android.os.Build.VERSION_CODES#R}, the app needs to\n     * explicitly use BIND_INCLUDE_CAPABILITIES flag to pass all capabilities to the service so the\n     * other app can have while-in-use access such as location, camera, microphone from background.\n     * If binding from a top app and its target SDK version is below\n     * {@link android.os.Build.VERSION_CODES#R}, BIND_INCLUDE_CAPABILITIES is implicit.\n     ",
    "links" : [ "android.os.Build.VERSION_CODES#R", "#bindService" ]
  }, {
    "name" : "BIND_SHARED_ISOLATED_PROCESS",
    "type" : "int",
    "comment" : "\n     * Flag for {@link #bindIsolatedService}: Bind the service into a shared isolated process.\n     * Specifying this flag allows multiple isolated services to be running in a single shared\n     * isolated process.\n     *\n     * The shared isolated process instance is identified by the <var>instanceName</var>\n     * parameter in {@link #bindIsolatedService(Intent, int, String, Executor, ServiceConnection)}.\n     *\n     * Subsequent calls to {@link #bindIsolatedService} with the same <var>instanceName</var>\n     * will cause the isolated service to be co-located in the same shared isolated process.\n     *\n     * Note that the shared isolated process is scoped to the calling app; once created, only\n     * the calling app can bind additional isolated services into the shared process. However,\n     * the services themselves can come from different APKs and therefore different vendors.\n     *\n     * Only services that set the {@link android.R.attr#allowSharedIsolatedProcess} attribute\n     * to {@code true} are allowed to be bound into a shared isolated process.\n     *\n     ",
    "links" : [ "#bindIsolatedService", "android.R.attr#allowSharedIsolatedProcess", "#bindIsolatedService(Intent" ]
  }, {
    "name" : "BIND_PACKAGE_ISOLATED_PROCESS",
    "type" : "int",
    "comment" : "\n     * Flag for {@link #bindIsolatedService}: Bind the service into a shared isolated process,\n     * but only with other isolated services from the same package that declare the same process\n     * name.\n     *\n     * <p>Specifying this flag allows multiple isolated services defined in the same package to be\n     * running in a single shared isolated process. This shared isolated process must be specified\n     * since this flag will not work with the default application process.\n     *\n     * <p>This flag is different from {@link #BIND_SHARED_ISOLATED_PROCESS} since it only\n     * allows binding services from the same package in the same shared isolated process. This also\n     * means the shared package isolated process is global, and not scoped to each potential\n     * calling app.\n     *\n     * <p>The shared isolated process instance is identified by the \"android:process\" attribute\n     * defined by the service. This flag cannot be used without this attribute set.\n     ",
    "links" : [ "#bindIsolatedService", "#BIND_SHARED_ISOLATED_PROCESS" ]
  }, {
    "name" : "BIND_NOT_APP_COMPONENT_USAGE",
    "type" : "int",
    "comment" : "\n     * Flag for {@link #bindService}: This flag is only intended to be used by the system to\n     * indicate that a service binding is not considered as real package component usage and should\n     * not generate a {@link android.app.usage.UsageEvents.Event#APP_COMPONENT_USED} event in usage\n     * stats.\n     * @hide\n     ",
    "links" : [ "android.app.usage.UsageEvents.Event#APP_COMPONENT_USED", "#bindService" ]
  }, {
    "name" : "BIND_ALMOST_PERCEPTIBLE",
    "type" : "int",
    "comment" : "\n     * Flag for {@link #bindService}: allow the process hosting the target service to be treated\n     * as if it's as important as a perceptible app to the user and avoid the oom killer killing\n     * this process in low memory situations until there aren't any other processes left but the\n     * ones which are user-perceptible.\n     *\n     * @hide\n     ",
    "links" : [ "#bindService" ]
  }, {
    "name" : "BIND_BYPASS_POWER_NETWORK_RESTRICTIONS",
    "type" : "int",
    "comment" : "\n     * Flag for {@link #bindService}: allow the process hosting the target service to gain\n     * {@link ActivityManager#PROCESS_CAPABILITY_POWER_RESTRICTED_NETWORK}, which allows it be able\n     * to access network regardless of any power saving restrictions.\n     *\n     * @hide\n     ",
    "links" : [ "android.app.ActivityManager#PROCESS_CAPABILITY_POWER_RESTRICTED_NETWORK", "#bindService" ]
  }, {
    "name" : "BIND_ALLOW_FOREGROUND_SERVICE_STARTS_FROM_BACKGROUND",
    "type" : "int",
    "comment" : "\n     * Do not use. This flag is no longer needed nor used.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "BIND_SCHEDULE_LIKE_TOP_APP",
    "type" : "int",
    "comment" : "\n     * Flag for {@link #bindService}: This flag is intended to be used only by the system to adjust\n     * the scheduling policy for IMEs (and any other out-of-process user-visible components that\n     * work closely with the top app) so that UI hosted in such services can have the same\n     * scheduling policy (e.g. SCHED_FIFO when it is enabled and TOP_APP_PRIORITY_BOOST otherwise)\n     * as the actual top-app.\n     * @hide\n     ",
    "links" : [ "#bindService" ]
  }, {
    "name" : "BIND_ALLOW_BACKGROUND_ACTIVITY_STARTS",
    "type" : "int",
    "comment" : "\n     * Flag for {@link #bindService}: allow background activity starts from the bound service's\n     * process.\n     * This flag is only respected if the caller is holding\n     * {@link android.Manifest.permission#START_ACTIVITIES_FROM_BACKGROUND}.\n     * @hide\n     ",
    "links" : [ "android.Manifest.permission#START_ACTIVITIES_FROM_BACKGROUND", "#bindService" ]
  }, {
    "name" : "BIND_RESTRICT_ASSOCIATIONS",
    "type" : "int",
    "comment" : "\n     * @hide Flag for {@link #bindService}: the service being bound to represents a\n     * protected system component, so must have association restrictions applied to it.\n     * That is, a system config must have one or more allow-association tags limiting\n     * which packages it can interact with.  If it does not have any such association\n     * restrictions, a default empty set will be created.\n     ",
    "links" : [ "#bindService" ]
  }, {
    "name" : "BIND_ALLOW_INSTANT",
    "type" : "int",
    "comment" : "\n     * @hide Flag for {@link #bindService}: allows binding to a service provided\n     * by an instant app. Note that the caller may not have access to the instant\n     * app providing the service which is a violation of the instant app sandbox.\n     * This flag is intended ONLY for development/testing and should be used with\n     * great care. Only the system is allowed to use this flag.\n     ",
    "links" : [ "#bindService" ]
  }, {
    "name" : "BIND_IMPORTANT_BACKGROUND",
    "type" : "int",
    "comment" : "\n     * @hide Flag for {@link #bindService}: like {@link #BIND_NOT_FOREGROUND}, but puts it\n     * up in to the important background state (instead of transient).\n     ",
    "links" : [ "#bindService", "#BIND_NOT_FOREGROUND" ]
  }, {
    "name" : "BIND_ALLOW_WHITELIST_MANAGEMENT",
    "type" : "int",
    "comment" : "\n     * @hide Flag for {@link #bindService}: allows application hosting service to manage allowlists\n     * such as temporary allowing a {@code PendingIntent} to bypass Power Save mode.\n     ",
    "links" : [ "#bindService" ]
  }, {
    "name" : "BIND_FOREGROUND_SERVICE_WHILE_AWAKE",
    "type" : "int",
    "comment" : "\n     * @hide Flag for {@link #bindService}: Like {@link #BIND_FOREGROUND_SERVICE},\n     * but only applies while the device is awake.\n     ",
    "links" : [ "#BIND_FOREGROUND_SERVICE", "#bindService" ]
  }, {
    "name" : "BIND_FOREGROUND_SERVICE",
    "type" : "int",
    "comment" : "\n     * @hide Flag for {@link #bindService}: For only the case where the binding\n     * is coming from the system, set the process state to BOUND_FOREGROUND_SERVICE\n     * instead of the normal maximum of IMPORTANT_FOREGROUND.  That is, this is\n     * saying that the process shouldn't participate in the normal power reduction\n     * modes (removing network access etc).\n     ",
    "links" : [ "#bindService" ]
  }, {
    "name" : "BIND_TREAT_LIKE_ACTIVITY",
    "type" : "int",
    "comment" : "\n     * @hide Flag for {@link #bindService}: Treat the binding as hosting\n     * an activity, an unbinding as the activity going in the background.\n     * That is, when unbinding, the process when empty will go on the activity\n     * LRU list instead of the regular one, keeping it around more aggressively\n     * than it otherwise would be.  This is intended for use with IMEs to try\n     * to keep IME processes around for faster keyboard switching.\n     ",
    "links" : [ "#bindService" ]
  }, {
    "name" : "BIND_VISIBLE",
    "type" : "int",
    "comment" : "\n     * @hide An idea that is not yet implemented.\n     * Flag for {@link #bindService}: If binding from an activity, consider\n     * this service to be visible like the binding activity is.  That is,\n     * it will be treated as something more important to keep around than\n     * invisible background activities.  This will impact the number of\n     * recent activities the user can switch between without having them\n     * restart.  There is no guarantee this will be respected, as the system\n     * tries to balance such requests from one app vs. the importance of\n     * keeping other apps around.\n     *\n     * @deprecated Repurposed to {@link #BIND_TREAT_LIKE_VISIBLE_FOREGROUND_SERVICE}.\n     ",
    "links" : [ "#BIND_TREAT_LIKE_VISIBLE_FOREGROUND_SERVICE", "#bindService" ]
  }, {
    "name" : "BIND_TREAT_LIKE_VISIBLE_FOREGROUND_SERVICE",
    "type" : "int",
    "comment" : "\n     * @hide Flag for {@link #bindService}: Treat the binding as hosting a foreground service\n     * and also visible to the user. That is, the app hosting the service will get its process state\n     * bumped to the {@link android.app.ActivityManager#PROCESS_STATE_FOREGROUND_SERVICE},\n     * and it's considered as visible to the user, thus less likely to be expunged from memory\n     * on low memory situations. This is intented for use by processes with the process state\n     * better than the {@link android.app.ActivityManager#PROCESS_STATE_TOP}.\n     ",
    "links" : [ "android.app.ActivityManager#PROCESS_STATE_TOP", "#bindService", "android.app.ActivityManager#PROCESS_STATE_FOREGROUND_SERVICE" ]
  }, {
    "name" : "BIND_SHOWING_UI",
    "type" : "int",
    "comment" : "\n     * @hide\n     * Flag for {@link #bindService}: Consider this binding to be causing the target\n     * process to be showing UI, so it will be do a UI_HIDDEN memory trim when it goes\n     * away.\n     ",
    "links" : [ "#bindService" ]
  }, {
    "name" : "BIND_NOT_VISIBLE",
    "type" : "int",
    "comment" : "\n     * Flag for {@link #bindService}: Don't consider the bound service to be\n     * visible, even if the caller is visible.\n     * @hide\n     ",
    "links" : [ "#bindService" ]
  }, {
    "name" : "BIND_EXTERNAL_SERVICE",
    "type" : "int",
    "comment" : "\n     * Flag for {@link #bindService}: The service being bound is an\n     * {@link android.R.attr#isolatedProcess isolated},\n     * {@link android.R.attr#externalService external} service.  This binds the service into the\n     * calling application's package, rather than the package in which the service is declared.\n     * <p>\n     * When using this flag, the code for the service being bound will execute under the calling\n     * application's package name and user ID.  Because the service must be an isolated process,\n     * it will not have direct access to the application's data, though.\n     *\n     * The purpose of this flag is to allow applications to provide services that are attributed\n     * to the app using the service, rather than the application providing the service.\n     * </p>\n     *\n     * <em>This flag is NOT compatible with {@link BindServiceFlags}. If you need to use\n     * {@link BindServiceFlags}, you must use {@link #BIND_EXTERNAL_SERVICE_LONG} instead.</em>\n     ",
    "links" : [ "#BIND_EXTERNAL_SERVICE_LONG", "android.R.attr#externalService", "android.R.attr#isolatedProcess", "#bindService", "BindServiceFlags" ]
  }, {
    "name" : "BIND_EXTERNAL_SERVICE_LONG",
    "type" : "long",
    "comment" : "\n     * Works in the same way as {@link #BIND_EXTERNAL_SERVICE}, but it's defined as a {@code long}\n     * value that is compatible to {@link BindServiceFlags}.\n     ",
    "links" : [ "#BIND_EXTERNAL_SERVICE", "BindServiceFlags" ]
  }, {
    "name" : "BIND_BYPASS_USER_NETWORK_RESTRICTIONS",
    "type" : "long",
    "comment" : "\n     * Flag for {@link #bindService}: allow the process hosting the target service to gain\n     * {@link ActivityManager#PROCESS_CAPABILITY_USER_RESTRICTED_NETWORK}, which allows it be able\n     * to access network regardless of any user restrictions.\n     *\n     * @hide\n     ",
    "links" : [ "android.app.ActivityManager#PROCESS_CAPABILITY_USER_RESTRICTED_NETWORK", "#bindService" ]
  }, {
    "name" : "BIND_MATCH_QUARANTINED_COMPONENTS",
    "type" : "long",
    "comment" : "\n     * Flag for {@link #bindService}.\n     *\n     * @hide\n     ",
    "links" : [ "#bindService" ]
  }, {
    "name" : "BIND_REDUCTION_FLAGS",
    "type" : "int",
    "comment" : "\n     * These bind flags reduce the strength of the binding such that we shouldn't\n     * consider it as pulling the process up to the level of the one that is bound to it.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "RECEIVER_VISIBLE_TO_INSTANT_APPS",
    "type" : "int",
    "comment" : "\n     * Flag for {@link #registerReceiver}: The receiver can receive broadcasts from Instant Apps.\n     ",
    "links" : [ "#registerReceiver" ]
  }, {
    "name" : "RECEIVER_EXPORTED",
    "type" : "int",
    "comment" : "\n     * Flag for {@link #registerReceiver}: The receiver can receive broadcasts from other Apps.\n     * Has the same behavior as marking a statically registered receiver with \"exported=true\"\n     ",
    "links" : [ "#registerReceiver" ]
  }, {
    "name" : "RECEIVER_EXPORTED_UNAUDITED",
    "type" : "int",
    "comment" : "\n     * @deprecated Use {@link #RECEIVER_NOT_EXPORTED} or {@link #RECEIVER_EXPORTED} instead.\n     * @hide\n     ",
    "links" : [ "#RECEIVER_EXPORTED", "#RECEIVER_NOT_EXPORTED" ]
  }, {
    "name" : "RECEIVER_NOT_EXPORTED",
    "type" : "int",
    "comment" : "\n     * Flag for {@link #registerReceiver}: The receiver cannot receive broadcasts from other Apps.\n     * Has the same behavior as marking a statically registered receiver with \"exported=false\"\n     ",
    "links" : [ "#registerReceiver" ]
  }, {
    "name" : "sLastAutofillId",
    "type" : "int",
    "comment" : " Non-activity related autofill ids are unique in the app ",
    "links" : [ ]
  }, {
    "name" : "POWER_SERVICE",
    "type" : "String",
    "comment" : "\n     * Use with {@link #getSystemService(String)} to retrieve a\n     * {@link android.os.PowerManager} for controlling power management,\n     * including \"wake locks,\" which let you keep the device on while\n     * you're running long tasks.\n     ",
    "links" : [ "android.os.PowerManager", "#getSystemService(String)" ]
  }, {
    "name" : "POWER_STATS_SERVICE",
    "type" : "String",
    "comment" : "\n     * Use with {@link #getSystemService(String)} to retrieve a\n     * {@link android.os.PowerStatsService} for accessing power stats\n     * service.\n     *\n     * @see #getSystemService(String)\n     * @hide\n     ",
    "links" : [ "#getSystemService(String)", "android.os.PowerStatsService" ]
  }, {
    "name" : "RECOVERY_SERVICE",
    "type" : "String",
    "comment" : "\n     * Use with {@link #getSystemService(String)} to retrieve a\n     * {@link android.os.RecoverySystem} for accessing the recovery system\n     * service.\n     *\n     * @see #getSystemService(String)\n     * @hide\n     ",
    "links" : [ "#getSystemService(String)", "android.os.RecoverySystem" ]
  }, {
    "name" : "SYSTEM_UPDATE_SERVICE",
    "type" : "String",
    "comment" : "\n     * Use with {@link #getSystemService(String)} to retrieve a\n     * {@link android.os.SystemUpdateManager} for accessing the system update\n     * manager service.\n     *\n     * @see #getSystemService(String)\n     * @hide\n     ",
    "links" : [ "#getSystemService(String)", "android.os.SystemUpdateManager" ]
  }, {
    "name" : "WINDOW_SERVICE",
    "type" : "String",
    "comment" : "\n     * Use with {@link #getSystemService(String)} to retrieve a\n     * {@link android.view.WindowManager} for accessing the system's window\n     * manager.\n     *\n     * @see #getSystemService(String)\n     * @see android.view.WindowManager\n     ",
    "links" : [ "#getSystemService(String)", "android.view.WindowManager" ]
  }, {
    "name" : "LAYOUT_INFLATER_SERVICE",
    "type" : "String",
    "comment" : "\n     * Use with {@link #getSystemService(String)} to retrieve a\n     * {@link android.view.LayoutInflater} for inflating layout resources in this\n     * context.\n     *\n     * @see #getSystemService(String)\n     * @see android.view.LayoutInflater\n     ",
    "links" : [ "#getSystemService(String)", "android.view.LayoutInflater" ]
  }, {
    "name" : "ACCOUNT_SERVICE",
    "type" : "String",
    "comment" : "\n     * Use with {@link #getSystemService(String)} to retrieve a\n     * {@link android.accounts.AccountManager} for receiving intents at a\n     * time of your choosing.\n     *\n     * @see #getSystemService(String)\n     * @see android.accounts.AccountManager\n     ",
    "links" : [ "android.accounts.AccountManager", "#getSystemService(String)" ]
  }, {
    "name" : "ACTIVITY_SERVICE",
    "type" : "String",
    "comment" : "\n     * Use with {@link #getSystemService(String)} to retrieve a\n     * {@link android.app.ActivityManager} for interacting with the global\n     * system state.\n     *\n     * @see #getSystemService(String)\n     * @see android.app.ActivityManager\n     ",
    "links" : [ "android.app.ActivityManager", "#getSystemService(String)" ]
  }, {
    "name" : "ACTIVITY_TASK_SERVICE",
    "type" : "String",
    "comment" : "\n     * Use with {@link #getSystemService(String)} to retrieve a\n     * {@link android.app.ActivityTaskManager} for interacting with the global system state.\n     *\n     * @see #getSystemService(String)\n     * @see android.app.ActivityTaskManager\n     * @hide\n     ",
    "links" : [ "#getSystemService(String)", "android.app.ActivityTaskManager" ]
  }, {
    "name" : "URI_GRANTS_SERVICE",
    "type" : "String",
    "comment" : "\n     * Use with {@link #getSystemService(String)} to retrieve a\n     * {@link android.app.UriGrantsManager} for interacting with the global system state.\n     *\n     * @see #getSystemService(String)\n     * @see android.app.UriGrantsManager\n     * @hide\n     ",
    "links" : [ "#getSystemService(String)", "android.app.UriGrantsManager" ]
  }, {
    "name" : "ALARM_SERVICE",
    "type" : "String",
    "comment" : "\n     * Use with {@link #getSystemService(String)} to retrieve a\n     * {@link android.app.AlarmManager} for receiving intents at a\n     * time of your choosing.\n     *\n     * @see #getSystemService(String)\n     * @see android.app.AlarmManager\n     ",
    "links" : [ "#getSystemService(String)", "android.app.AlarmManager" ]
  }, {
    "name" : "NOTIFICATION_SERVICE",
    "type" : "String",
    "comment" : "\n     * Use with {@link #getSystemService(String)} to retrieve a\n     * {@link android.app.NotificationManager} for informing the user of\n     * background events.\n     *\n     * @see #getSystemService(String)\n     * @see android.app.NotificationManager\n     ",
    "links" : [ "#getSystemService(String)", "android.app.NotificationManager" ]
  }, {
    "name" : "ACCESSIBILITY_SERVICE",
    "type" : "String",
    "comment" : "\n     * Use with {@link #getSystemService(String)} to retrieve a\n     * {@link android.view.accessibility.AccessibilityManager} for giving the user\n     * feedback for UI events through the registered event listeners.\n     *\n     * @see #getSystemService(String)\n     * @see android.view.accessibility.AccessibilityManager\n     ",
    "links" : [ "android.view.accessibility.AccessibilityManager", "#getSystemService(String)" ]
  }, {
    "name" : "CAPTIONING_SERVICE",
    "type" : "String",
    "comment" : "\n     * Use with {@link #getSystemService(String)} to retrieve a\n     * {@link android.view.accessibility.CaptioningManager} for obtaining\n     * captioning properties and listening for changes in captioning\n     * preferences.\n     *\n     * @see #getSystemService(String)\n     * @see android.view.accessibility.CaptioningManager\n     ",
    "links" : [ "#getSystemService(String)", "android.view.accessibility.CaptioningManager" ]
  }, {
    "name" : "KEYGUARD_SERVICE",
    "type" : "String",
    "comment" : "\n     * Use with {@link #getSystemService(String)} to retrieve a\n     * {@link android.app.KeyguardManager} for controlling keyguard.\n     *\n     * @see #getSystemService(String)\n     * @see android.app.KeyguardManager\n     ",
    "links" : [ "android.app.KeyguardManager", "#getSystemService(String)" ]
  }, {
    "name" : "LOCATION_SERVICE",
    "type" : "String",
    "comment" : "\n     * Use with {@link #getSystemService(String)} to retrieve a {@link\n     * android.location.LocationManager} for controlling location\n     * updates.\n     *\n     * @see #getSystemService(String)\n     * @see android.location.LocationManager\n     ",
    "links" : [ "#getSystemService(String)", "android.location.LocationManager" ]
  }, {
    "name" : "COUNTRY_DETECTOR",
    "type" : "String",
    "comment" : "\n     * Use with {@link #getSystemService(String)} to retrieve a\n     * {@link android.location.CountryDetector} for detecting the country that\n     * the user is in.\n     *\n     * @hide\n     ",
    "links" : [ "#getSystemService(String)", "android.location.CountryDetector" ]
  }, {
    "name" : "SEARCH_SERVICE",
    "type" : "String",
    "comment" : "\n     * Use with {@link #getSystemService(String)} to retrieve a {@link\n     * android.app.SearchManager} for handling searches.\n     *\n     * <p>\n     * {@link Configuration#UI_MODE_TYPE_WATCH} does not support\n     * {@link android.app.SearchManager}.\n     *\n     * @see #getSystemService\n     * @see android.app.SearchManager\n     ",
    "links" : [ "#getSystemService(String)", "android.content.res.Configuration#UI_MODE_TYPE_WATCH", "android.app.SearchManager" ]
  }, {
    "name" : "SENSOR_SERVICE",
    "type" : "String",
    "comment" : "\n     * Use with {@link #getSystemService(String)} to retrieve a {@link\n     * android.hardware.SensorManager} for accessing sensors.\n     *\n     * @see #getSystemService(String)\n     * @see android.hardware.SensorManager\n     ",
    "links" : [ "android.hardware.SensorManager", "#getSystemService(String)" ]
  }, {
    "name" : "SENSOR_PRIVACY_SERVICE",
    "type" : "String",
    "comment" : "\n     * Use with {@link #getSystemService(String)} to retrieve a {@link\n     * android.hardware.SensorPrivacyManager} for accessing sensor privacy\n     * functions.\n     *\n     * @see #getSystemService(String)\n     * @see android.hardware.SensorPrivacyManager\n     *\n     * @hide\n     ",
    "links" : [ "#getSystemService(String)", "android.hardware.SensorPrivacyManager" ]
  }, {
    "name" : "STORAGE_SERVICE",
    "type" : "String",
    "comment" : "\n     * Use with {@link #getSystemService(String)} to retrieve a {@link\n     * android.os.storage.StorageManager} for accessing system storage\n     * functions.\n     *\n     * @see #getSystemService(String)\n     * @see android.os.storage.StorageManager\n     ",
    "links" : [ "android.os.storage.StorageManager", "#getSystemService(String)" ]
  }, {
    "name" : "STORAGE_STATS_SERVICE",
    "type" : "String",
    "comment" : "\n     * Use with {@link #getSystemService(String)} to retrieve a {@link\n     * android.app.usage.StorageStatsManager} for accessing system storage\n     * statistics.\n     *\n     * @see #getSystemService(String)\n     * @see android.app.usage.StorageStatsManager\n     ",
    "links" : [ "#getSystemService(String)", "android.app.usage.StorageStatsManager" ]
  }, {
    "name" : "WALLPAPER_SERVICE",
    "type" : "String",
    "comment" : "\n     * Use with {@link #getSystemService(String)} to retrieve a\n     * com.android.server.WallpaperService for accessing wallpapers.\n     *\n     * @see #getSystemService(String)\n     ",
    "links" : [ "#getSystemService(String)" ]
  }, {
    "name" : "VIBRATOR_MANAGER_SERVICE",
    "type" : "String",
    "comment" : "\n     * Use with {@link #getSystemService(String)} to retrieve a {@link android.os.VibratorManager}\n     * for accessing the device vibrators, interacting with individual ones and playing synchronized\n     * effects on multiple vibrators.\n     *\n     * @see #getSystemService(String)\n     * @see android.os.VibratorManager\n     ",
    "links" : [ "#getSystemService(String)", "android.os.VibratorManager" ]
  }, {
    "name" : "VIBRATOR_SERVICE",
    "type" : "String",
    "comment" : "\n     * Use with {@link #getSystemService(String)} to retrieve a {@link android.os.Vibrator} for\n     * interacting with the vibration hardware.\n     *\n     * @deprecated Use {@link android.os.VibratorManager} to retrieve the default system vibrator.\n     * @see #getSystemService(String)\n     * @see android.os.Vibrator\n     ",
    "links" : [ "#getSystemService(String)", "android.os.VibratorManager", "android.os.Vibrator" ]
  }, {
    "name" : "STATUS_BAR_SERVICE",
    "type" : "String",
    "comment" : "\n     * Use with {@link #getSystemService(String)} to retrieve a {@link\n     * android.app.StatusBarManager} for interacting with the status bar and quick settings.\n     *\n     * @see #getSystemService(String)\n     * @see android.app.StatusBarManager\n     *\n     ",
    "links" : [ "#getSystemService(String)", "android.app.StatusBarManager" ]
  }, {
    "name" : "CONNECTIVITY_SERVICE",
    "type" : "String",
    "comment" : "\n     * Use with {@link #getSystemService(String)} to retrieve a {@link\n     * android.net.ConnectivityManager} for handling management of\n     * network connections.\n     *\n     * @see #getSystemService(String)\n     * @see android.net.ConnectivityManager\n     ",
    "links" : [ "android.net.ConnectivityManager", "#getSystemService(String)" ]
  }, {
    "name" : "PAC_PROXY_SERVICE",
    "type" : "String",
    "comment" : "\n     * Use with {@link #getSystemService(String)} to retrieve a {@link\n     * android.net.PacProxyManager} for handling management of\n     * pac proxy information.\n     *\n     * @see #getSystemService(String)\n     * @see android.net.PacProxyManager\n     * @hide\n     ",
    "links" : [ "#getSystemService(String)", "android.net.PacProxyManager" ]
  }, {
    "name" : "VCN_MANAGEMENT_SERVICE",
    "type" : "String",
    "comment" : "\n     * Use with {@link #getSystemService(String)} to retrieve a {@link android.net.vcn.VcnManager}\n     * for managing Virtual Carrier Networks\n     *\n     * @see #getSystemService(String)\n     * @see android.net.vcn.VcnManager\n     * @hide\n     ",
    "links" : [ "#getSystemService(String)", "android.net.vcn.VcnManager" ]
  }, {
    "name" : "NETD_SERVICE",
    "type" : "String",
    "comment" : "\n     * Use with {@link #getSystemService(String)} to retrieve a\n     * {@link android.net.INetd} for communicating with the network stack\n     * @hide\n     * @see #getSystemService(String)\n     * @hide\n     ",
    "links" : [ "android.net.INetd", "#getSystemService(String)" ]
  }, {
    "name" : "NETWORK_STACK_SERVICE",
    "type" : "String",
    "comment" : "\n     * Use with {@link android.os.ServiceManager.getService()} to retrieve a\n     * {@link INetworkStackConnector} IBinder for communicating with the network stack\n     * @hide\n     * @see NetworkStackClient\n     ",
    "links" : [ "android.os.ServiceManager.getService()", "INetworkStackConnector" ]
  }, {
    "name" : "TETHERING_SERVICE",
    "type" : "String",
    "comment" : "\n     * Use with {@link #getSystemService(String)} to retrieve a {@link android.net.TetheringManager}\n     * for managing tethering functions.\n     * @hide\n     * @see android.net.TetheringManager\n     ",
    "links" : [ "#getSystemService(String)", "android.net.TetheringManager" ]
  }, {
    "name" : "THREAD_NETWORK_SERVICE",
    "type" : "String",
    "comment" : "\n     * Use with {@link #getSystemService(String)} to retrieve a\n     * {@link android.net.thread.ThreadNetworkManager}.\n     *\n     * <p>On devices without {@link PackageManager#FEATURE_THREAD_NETWORK} system feature\n     * the {@link #getSystemService(String)} will return {@code null}.\n     *\n     * @see #getSystemService(String)\n     * @see android.net.thread.ThreadNetworkManager\n     * @hide\n     ",
    "links" : [ "#getSystemService(String)", "android.content.pm.PackageManager#FEATURE_THREAD_NETWORK", "android.net.thread.ThreadNetworkManager" ]
  }, {
    "name" : "IPSEC_SERVICE",
    "type" : "String",
    "comment" : "\n     * Use with {@link #getSystemService(String)} to retrieve a\n     * {@link android.net.IpSecManager} for encrypting Sockets or Networks with\n     * IPSec.\n     *\n     * @see #getSystemService(String)\n     ",
    "links" : [ "#getSystemService(String)", "android.net.IpSecManager" ]
  }, {
    "name" : "VPN_MANAGEMENT_SERVICE",
    "type" : "String",
    "comment" : "\n     * Use with {@link #getSystemService(String)} to retrieve a {@link android.net.VpnManager} to\n     * manage profiles for the platform built-in VPN.\n     *\n     * @see #getSystemService(String)\n     ",
    "links" : [ "#getSystemService(String)", "android.net.VpnManager" ]
  }, {
    "name" : "CONNECTIVITY_DIAGNOSTICS_SERVICE",
    "type" : "String",
    "comment" : "\n     * Use with {@link #getSystemService(String)} to retrieve a {@link\n     * android.net.ConnectivityDiagnosticsManager} for performing network connectivity diagnostics\n     * as well as receiving network connectivity information from the system.\n     *\n     * @see #getSystemService(String)\n     * @see android.net.ConnectivityDiagnosticsManager\n     ",
    "links" : [ "#getSystemService(String)", "android.net.ConnectivityDiagnosticsManager" ]
  }, {
    "name" : "TEST_NETWORK_SERVICE",
    "type" : "String",
    "comment" : "\n     * Use with {@link #getSystemService(String)} to retrieve a {@link\n     * android.net.TestNetworkManager} for building TUNs and limited-use Networks\n     *\n     * @see #getSystemService(String)\n     * @hide\n     ",
    "links" : [ "#getSystemService(String)", "android.net.TestNetworkManager" ]
  }, {
    "name" : "UPDATE_LOCK_SERVICE",
    "type" : "String",
    "comment" : "\n     * Use with {@link #getSystemService(String)} to retrieve a {@link\n     * android.os.IUpdateLock} for managing runtime sequences that\n     * must not be interrupted by headless OTA application or similar.\n     *\n     * @hide\n     * @see #getSystemService(String)\n     * @see android.os.UpdateLock\n     ",
    "links" : [ "#getSystemService(String)", "android.os.IUpdateLock" ]
  }, {
    "name" : "NETWORKMANAGEMENT_SERVICE",
    "type" : "String",
    "comment" : "\n     * Constant for the internal network management service, not really a Context service.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "SLICE_SERVICE",
    "type" : "String",
    "comment" : "\n     * Use with {@link #getSystemService(String)} to retrieve a\n     * {@link com.android.server.slice.SliceManagerService} for managing slices.\n     * @hide\n     * @see #getSystemService(String)\n     ",
    "links" : [ "#getSystemService(String)", "com.android.server.slice.SliceManagerService" ]
  }, {
    "name" : "NETWORK_STATS_SERVICE",
    "type" : "String",
    "comment" : "\n     * Use with {@link #getSystemService(String)} to retrieve a {@link\n     * android.app.usage.NetworkStatsManager} for querying network usage stats.\n     *\n     * @see #getSystemService(String)\n     * @see android.app.usage.NetworkStatsManager\n     ",
    "links" : [ "#getSystemService(String)", "android.app.usage.NetworkStatsManager" ]
  }, {
    "name" : "NETWORK_POLICY_SERVICE",
    "type" : "String",
    "comment" : " {@hide} ",
    "links" : [ ]
  }, {
    "name" : "NETWORK_WATCHLIST_SERVICE",
    "type" : "String",
    "comment" : " {@hide} ",
    "links" : [ ]
  }, {
    "name" : "WIFI_SERVICE",
    "type" : "String",
    "comment" : "\n     * Use with {@link #getSystemService(String)} to retrieve a {@link\n     * android.net.wifi.WifiManager} for handling management of\n     * Wi-Fi access.\n     *\n     * @see #getSystemService(String)\n     * @see android.net.wifi.WifiManager\n     ",
    "links" : [ "android.net.wifi.WifiManager", "#getSystemService(String)" ]
  }, {
    "name" : "WIFI_NL80211_SERVICE",
    "type" : "String",
    "comment" : "\n     * Use with {@link #getSystemService(String)} to retrieve a\n     * {@link android.net.wifi.wificond.WifiNl80211Manager} for handling management of the\n     * Wi-Fi nl802.11 daemon (wificond).\n     *\n     * @see #getSystemService(String)\n     * @see android.net.wifi.wificond.WifiNl80211Manager\n     * @hide\n     ",
    "links" : [ "#getSystemService(String)", "android.net.wifi.wificond.WifiNl80211Manager" ]
  }, {
    "name" : "WIFI_P2P_SERVICE",
    "type" : "String",
    "comment" : "\n     * Use with {@link #getSystemService(String)} to retrieve a {@link\n     * android.net.wifi.p2p.WifiP2pManager} for handling management of\n     * Wi-Fi peer-to-peer connections.\n     *\n     * @see #getSystemService(String)\n     * @see android.net.wifi.p2p.WifiP2pManager\n     ",
    "links" : [ "#getSystemService(String)", "android.net.wifi.p2p.WifiP2pManager" ]
  }, {
    "name" : "WIFI_AWARE_SERVICE",
    "type" : "String",
    "comment" : "\n     * Use with {@link #getSystemService(String)} to retrieve a\n     * {@link android.net.wifi.aware.WifiAwareManager} for handling management of\n     * Wi-Fi Aware.\n     *\n     * @see #getSystemService(String)\n     * @see android.net.wifi.aware.WifiAwareManager\n     ",
    "links" : [ "#getSystemService(String)", "android.net.wifi.aware.WifiAwareManager" ]
  }, {
    "name" : "WIFI_SCANNING_SERVICE",
    "type" : "String",
    "comment" : "\n     * Use with {@link #getSystemService(String)} to retrieve a {@link\n     * android.net.wifi.WifiScanner} for scanning the wifi universe\n     *\n     * @see #getSystemService(String)\n     * @see android.net.wifi.WifiScanner\n     * @hide\n     ",
    "links" : [ "#getSystemService(String)", "android.net.wifi.WifiScanner" ]
  }, {
    "name" : "WIFI_RTT_SERVICE",
    "type" : "String",
    "comment" : "\n     * Use with {@link #getSystemService(String)} to retrieve a {@link\n     * android.net.wifi.RttManager} for ranging devices with wifi\n     *\n     * @see #getSystemService(String)\n     * @see android.net.wifi.RttManager\n     * @hide\n     ",
    "links" : [ "#getSystemService(String)", "android.net.wifi.RttManager" ]
  }, {
    "name" : "WIFI_RTT_RANGING_SERVICE",
    "type" : "String",
    "comment" : "\n     * Use with {@link #getSystemService(String)} to retrieve a {@link\n     * android.net.wifi.rtt.WifiRttManager} for ranging devices with wifi.\n     *\n     * @see #getSystemService(String)\n     * @see android.net.wifi.rtt.WifiRttManager\n     ",
    "links" : [ "#getSystemService(String)", "android.net.wifi.rtt.WifiRttManager" ]
  }, {
    "name" : "LOWPAN_SERVICE",
    "type" : "String",
    "comment" : "\n     * Use with {@link #getSystemService(String)} to retrieve a {@link\n     * android.net.lowpan.LowpanManager} for handling management of\n     * LoWPAN access.\n     *\n     * @see #getSystemService(String)\n     * @see android.net.lowpan.LowpanManager\n     *\n     * @hide\n     ",
    "links" : [ "#getSystemService(String)", "android.net.lowpan.LowpanManager" ]
  }, {
    "name" : "ETHERNET_SERVICE",
    "type" : "String",
    "comment" : "\n     * Use with {@link #getSystemService(String)} to retrieve a {@link android.net.EthernetManager}\n     * for handling management of Ethernet access.\n     *\n     * @see #getSystemService(String)\n     * @see android.net.EthernetManager\n     *\n     * @hide\n     ",
    "links" : [ "#getSystemService(String)", "android.net.EthernetManager" ]
  }, {
    "name" : "NSD_SERVICE",
    "type" : "String",
    "comment" : "\n     * Use with {@link #getSystemService(String)} to retrieve a {@link\n     * android.net.nsd.NsdManager} for handling management of network service\n     * discovery\n     *\n     * @see #getSystemService(String)\n     * @see android.net.nsd.NsdManager\n     ",
    "links" : [ "android.net.nsd.NsdManager", "#getSystemService(String)" ]
  }, {
    "name" : "AUDIO_SERVICE",
    "type" : "String",
    "comment" : "\n     * Use with {@link #getSystemService(String)} to retrieve a\n     * {@link android.media.AudioManager} for handling management of volume,\n     * ringer modes and audio routing.\n     *\n     * @see #getSystemService(String)\n     * @see android.media.AudioManager\n     ",
    "links" : [ "#getSystemService(String)", "android.media.AudioManager" ]
  }, {
    "name" : "AUDIO_DEVICE_VOLUME_SERVICE",
    "type" : "String",
    "comment" : "\n     * @hide\n     * Use with {@link #getSystemService(String)} to retrieve a\n     * {@link android.media.AudioDeviceVolumeManager} for handling management of audio device\n     * (e.g. speaker, USB headset) volume.\n     *\n     * @see #getSystemService(String)\n     * @see android.media.AudioDeviceVolumeManager\n     ",
    "links" : [ "#getSystemService(String)", "android.media.AudioDeviceVolumeManager" ]
  }, {
    "name" : "MEDIA_TRANSCODING_SERVICE",
    "type" : "String",
    "comment" : "\n     * Use with {@link #getSystemService(String)} to retrieve a {@link\n     * android.media.MediaTranscodingManager} for transcoding media.\n     *\n     * @hide\n     * @see #getSystemService(String)\n     * @see android.media.MediaTranscodingManager\n     ",
    "links" : [ "#getSystemService(String)", "android.media.MediaTranscodingManager" ]
  }, {
    "name" : "AUTH_SERVICE",
    "type" : "String",
    "comment" : "\n     * AuthService orchestrates biometric and PIN/pattern/password authentication.\n     *\n     * BiometricService was split into two services, AuthService and BiometricService, where\n     * AuthService is the high level service that orchestrates all types of authentication, and\n     * BiometricService is a lower layer responsible only for biometric authentication.\n     *\n     * Ideally we should have renamed BiometricManager to AuthManager, because it logically\n     * corresponds to AuthService. However, because BiometricManager is a public API, we kept\n     * the old name but changed the internal implementation to use AuthService.\n     *\n     * As of now, the AUTH_SERVICE constant is only used to identify the service in\n     * SystemServiceRegistry and SELinux. To obtain the manager for AUTH_SERVICE, one should use\n     * BIOMETRIC_SERVICE with {@link #getSystemService(String)} to retrieve a\n     * {@link android.hardware.biometrics.BiometricManager}\n     *\n     * Map of the two services and their managers:\n     * [Service]            [Manager]\n     * AuthService          BiometricManager\n     * BiometricService     N/A\n     *\n     * @hide\n     ",
    "links" : [ "#getSystemService(String)", "android.hardware.biometrics.BiometricManager" ]
  }, {
    "name" : "FINGERPRINT_SERVICE",
    "type" : "String",
    "comment" : "\n     * Use with {@link #getSystemService(String)} to retrieve a\n     * {@link android.hardware.fingerprint.FingerprintManager} for handling management\n     * of fingerprints.\n     *\n     * @see #getSystemService(String)\n     * @see android.hardware.fingerprint.FingerprintManager\n     ",
    "links" : [ "#getSystemService(String)", "android.hardware.fingerprint.FingerprintManager" ]
  }, {
    "name" : "FACE_SERVICE",
    "type" : "String",
    "comment" : "\n     * Use with {@link #getSystemService(String)} to retrieve a\n     * {@link android.hardware.face.FaceManager} for handling management\n     * of face authentication.\n     *\n     * @hide\n     * @see #getSystemService\n     * @see android.hardware.face.FaceManager\n     ",
    "links" : [ "#getSystemService(String)", "android.hardware.face.FaceManager" ]
  }, {
    "name" : "IRIS_SERVICE",
    "type" : "String",
    "comment" : "\n     * Use with {@link #getSystemService(String)} to retrieve a\n     * {@link android.hardware.iris.IrisManager} for handling management\n     * of iris authentication.\n     *\n     * @hide\n     * @see #getSystemService\n     * @see android.hardware.iris.IrisManager\n     ",
    "links" : [ "#getSystemService(String)", "android.hardware.iris.IrisManager" ]
  }, {
    "name" : "BIOMETRIC_SERVICE",
    "type" : "String",
    "comment" : "\n     * Use with {@link #getSystemService(String)} to retrieve a\n     * {@link android.hardware.biometrics.BiometricManager} for handling\n     * biometric and PIN/pattern/password authentication.\n     *\n     * @see #getSystemService\n     * @see android.hardware.biometrics.BiometricManager\n     ",
    "links" : [ "#getSystemService(String)", "android.hardware.biometrics.BiometricManager" ]
  }, {
    "name" : "MEDIA_COMMUNICATION_SERVICE",
    "type" : "String",
    "comment" : "\n     * Use with {@link #getSystemService(String)} to retrieve a\n     * {@link android.media.MediaCommunicationManager}\n     * for managing {@link android.media.MediaSession2}.\n     *\n     * @see #getSystemService(String)\n     * @see android.media.MediaCommunicationManager\n     ",
    "links" : [ "#getSystemService(String)", "android.media.MediaSession2", "android.media.MediaCommunicationManager" ]
  }, {
    "name" : "MEDIA_ROUTER_SERVICE",
    "type" : "String",
    "comment" : "\n     * Use with {@link #getSystemService} to retrieve a\n     * {@link android.media.MediaRouter} for controlling and managing\n     * routing of media.\n     *\n     * @see #getSystemService(String)\n     * @see android.media.MediaRouter\n     ",
    "links" : [ "android.media.MediaRouter", "#getSystemService" ]
  }, {
    "name" : "MEDIA_SESSION_SERVICE",
    "type" : "String",
    "comment" : "\n     * Use with {@link #getSystemService(String)} to retrieve a\n     * {@link android.media.session.MediaSessionManager} for managing media Sessions.\n     *\n     * @see #getSystemService(String)\n     * @see android.media.session.MediaSessionManager\n     ",
    "links" : [ "#getSystemService(String)", "android.media.session.MediaSessionManager" ]
  }, {
    "name" : "TELEPHONY_SERVICE",
    "type" : "String",
    "comment" : "\n     * Use with {@link #getSystemService(String)} to retrieve a\n     * {@link android.telephony.TelephonyManager} for handling management the\n     * telephony features of the device.\n     *\n     * @see #getSystemService(String)\n     * @see android.telephony.TelephonyManager\n     ",
    "links" : [ "#getSystemService(String)", "android.telephony.TelephonyManager" ]
  }, {
    "name" : "TELEPHONY_SUBSCRIPTION_SERVICE",
    "type" : "String",
    "comment" : "\n     * Use with {@link #getSystemService(String)} to retrieve a\n     * {@link android.telephony.SubscriptionManager} for handling management the\n     * telephony subscriptions of the device.\n     *\n     * @see #getSystemService(String)\n     * @see android.telephony.SubscriptionManager\n     ",
    "links" : [ "#getSystemService(String)", "android.telephony.SubscriptionManager" ]
  }, {
    "name" : "TELECOM_SERVICE",
    "type" : "String",
    "comment" : "\n     * Use with {@link #getSystemService(String)} to retrieve a\n     * {@link android.telecom.TelecomManager} to manage telecom-related features\n     * of the device.\n     *\n     * @see #getSystemService(String)\n     * @see android.telecom.TelecomManager\n     ",
    "links" : [ "#getSystemService(String)", "android.telecom.TelecomManager" ]
  }, {
    "name" : "CARRIER_CONFIG_SERVICE",
    "type" : "String",
    "comment" : "\n     * Use with {@link #getSystemService(String)} to retrieve a\n     * {@link android.telephony.CarrierConfigManager} for reading carrier configuration values.\n     *\n     * @see #getSystemService(String)\n     * @see android.telephony.CarrierConfigManager\n     ",
    "links" : [ "#getSystemService(String)", "android.telephony.CarrierConfigManager" ]
  }, {
    "name" : "EUICC_SERVICE",
    "type" : "String",
    "comment" : "\n     * Use with {@link #getSystemService(String)} to retrieve a\n     * {@link android.telephony.euicc.EuiccManager} to manage the device eUICC (embedded SIM).\n     *\n     * @see #getSystemService(String)\n     * @see android.telephony.euicc.EuiccManager\n     ",
    "links" : [ "#getSystemService(String)", "android.telephony.euicc.EuiccManager" ]
  }, {
    "name" : "EUICC_CARD_SERVICE",
    "type" : "String",
    "comment" : "\n     * Use with {@link #getSystemService(String)} to retrieve a\n     * {@link android.telephony.euicc.EuiccCardManager} to access the device eUICC (embedded SIM).\n     *\n     * @see #getSystemService(String)\n     * @see android.telephony.euicc.EuiccCardManager\n     * @hide\n     ",
    "links" : [ "#getSystemService(String)", "android.telephony.euicc.EuiccCardManager" ]
  }, {
    "name" : "MMS_SERVICE",
    "type" : "String",
    "comment" : "\n     * Use with {@link #getSystemService(String)} to retrieve a\n     * {@link android.telephony.MmsManager} to send/receive MMS messages.\n     *\n     * @see #getSystemService(String)\n     * @see android.telephony.MmsManager\n     * @hide\n     ",
    "links" : [ "#getSystemService(String)", "android.telephony.MmsManager" ]
  }, {
    "name" : "CLIPBOARD_SERVICE",
    "type" : "String",
    "comment" : "\n     * Use with {@link #getSystemService(String)} to retrieve a\n     * {@link android.content.ClipboardManager} for accessing and modifying\n     * the contents of the global clipboard.\n     *\n     * @see #getSystemService(String)\n     * @see android.content.ClipboardManager\n     ",
    "links" : [ "#getSystemService(String)", "android.content.ClipboardManager" ]
  }, {
    "name" : "TEXT_CLASSIFICATION_SERVICE",
    "type" : "String",
    "comment" : "\n     * Use with {@link #getSystemService(String)} to retrieve a\n     * {@link TextClassificationManager} for text classification services.\n     *\n     * @see #getSystemService(String)\n     * @see TextClassificationManager\n     ",
    "links" : [ "#getSystemService(String)", "android.view.textclassifier.TextClassificationManager" ]
  }, {
    "name" : "SELECTION_TOOLBAR_SERVICE",
    "type" : "String",
    "comment" : "\n     * Use with {@link #getSystemService(String)} to retrieve a\n     * {@link android.view.selectiontoolbar.SelectionToolbarManager} for selection toolbar service.\n     *\n     * @see #getSystemService(String)\n     * @hide\n     ",
    "links" : [ "android.view.selectiontoolbar.SelectionToolbarManager", "#getSystemService(String)" ]
  }, {
    "name" : "FONT_SERVICE",
    "type" : "String",
    "comment" : "\n     * Use with {@link #getSystemService(String)} to retrieve a\n     * {@link android.graphics.fonts.FontManager} for font services.\n     *\n     * @see #getSystemService(String)\n     * @see android.graphics.fonts.FontManager\n     * @hide\n     ",
    "links" : [ "#getSystemService(String)", "android.graphics.fonts.FontManager" ]
  }, {
    "name" : "ATTENTION_SERVICE",
    "type" : "String",
    "comment" : "\n     * Use with {@link #getSystemService(String)} to retrieve a\n     * {@link com.android.server.attention.AttentionManagerService} for attention services.\n     *\n     * @see #getSystemService(String)\n     * @see android.server.attention.AttentionManagerService\n     * @hide\n     ",
    "links" : [ "#getSystemService(String)", "com.android.server.attention.AttentionManagerService" ]
  }, {
    "name" : "ROTATION_RESOLVER_SERVICE",
    "type" : "String",
    "comment" : "\n     * Official published name of the (internal) rotation resolver service.\n     *\n     * // TODO(b/178151184): change it back to rotation resolver before S release.\n     *\n     * @see #getSystemService(String)\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "INPUT_METHOD_SERVICE",
    "type" : "String",
    "comment" : "\n     * Use with {@link #getSystemService(String)} to retrieve a\n     * {@link android.view.inputmethod.InputMethodManager} for accessing input\n     * methods.\n     *\n     * @see #getSystemService(String)\n     ",
    "links" : [ "#getSystemService(String)", "android.view.inputmethod.InputMethodManager" ]
  }, {
    "name" : "TEXT_SERVICES_MANAGER_SERVICE",
    "type" : "String",
    "comment" : "\n     * Use with {@link #getSystemService(String)} to retrieve a\n     * {@link android.view.textservice.TextServicesManager} for accessing\n     * text services.\n     *\n     * @see #getSystemService(String)\n     ",
    "links" : [ "android.view.textservice.TextServicesManager", "#getSystemService(String)" ]
  }, {
    "name" : "APPWIDGET_SERVICE",
    "type" : "String",
    "comment" : "\n     * Use with {@link #getSystemService(String)} to retrieve a\n     * {@link android.appwidget.AppWidgetManager} for accessing AppWidgets.\n     *\n     * @see #getSystemService(String)\n     ",
    "links" : [ "#getSystemService(String)", "android.appwidget.AppWidgetManager" ]
  }, {
    "name" : "VOICE_INTERACTION_MANAGER_SERVICE",
    "type" : "String",
    "comment" : "\n     * Official published name of the (internal) voice interaction manager service.\n     *\n     * @hide\n     * @see #getSystemService(String)\n     ",
    "links" : [ ]
  }, {
    "name" : "AUTOFILL_MANAGER_SERVICE",
    "type" : "String",
    "comment" : "\n     * Official published name of the (internal) autofill service.\n     *\n     * @hide\n     * @see #getSystemService(String)\n     ",
    "links" : [ ]
  }, {
    "name" : "TEXT_TO_SPEECH_MANAGER_SERVICE",
    "type" : "String",
    "comment" : "\n     * Official published name of the (internal) text to speech manager service.\n     *\n     * @hide\n     * @see #getSystemService(String)\n     ",
    "links" : [ ]
  }, {
    "name" : "CONTENT_CAPTURE_MANAGER_SERVICE",
    "type" : "String",
    "comment" : "\n     * Official published name of the content capture service.\n     *\n     * @hide\n     * @see #getSystemService(String)\n     ",
    "links" : [ ]
  }, {
    "name" : "TRANSLATION_MANAGER_SERVICE",
    "type" : "String",
    "comment" : "\n     * Official published name of the translation service.\n     *\n     * @hide\n     * @see #getSystemService(String)\n     ",
    "links" : [ ]
  }, {
    "name" : "UI_TRANSLATION_SERVICE",
    "type" : "String",
    "comment" : "\n     * Official published name of the translation service which supports ui translation function.\n     *\n     * @hide\n     * @see #getSystemService(String)\n     ",
    "links" : [ ]
  }, {
    "name" : "CONTENT_SUGGESTIONS_SERVICE",
    "type" : "String",
    "comment" : "\n     * Used for getting content selections and classifications for task snapshots.\n     *\n     * @hide\n     * @see #getSystemService(String)\n     ",
    "links" : [ ]
  }, {
    "name" : "APP_PREDICTION_SERVICE",
    "type" : "String",
    "comment" : "\n     * Official published name of the app prediction service.\n     *\n     * <p><b>NOTE: </b> this service is optional; callers of\n     * {@code Context.getSystemServiceName(APP_PREDICTION_SERVICE)} should check for {@code null}.\n     *\n     * @hide\n     * @see #getSystemService(String)\n     ",
    "links" : [ ]
  }, {
    "name" : "FEATURE_FLAGS_SERVICE",
    "type" : "String",
    "comment" : "\n     * Used for reading system-wide, overridable flags.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "SEARCH_UI_SERVICE",
    "type" : "String",
    "comment" : "\n     * Official published name of the search ui service.\n     *\n     * <p><b>NOTE: </b> this service is optional; callers of\n     * {@code Context.getSystemServiceName(SEARCH_UI_SERVICE)} should check for {@code null}.\n     *\n     * @hide\n     * @see #getSystemService(String)\n     ",
    "links" : [ ]
  }, {
    "name" : "SMARTSPACE_SERVICE",
    "type" : "String",
    "comment" : "\n     * Used for getting the smartspace service.\n     *\n     * <p><b>NOTE: </b> this service is optional; callers of\n     * {@code Context.getSystemServiceName(SMARTSPACE_SERVICE)} should check for {@code null}.\n     *\n     * @hide\n     * @see #getSystemService(String)\n     ",
    "links" : [ ]
  }, {
    "name" : "CONTEXTUAL_SEARCH_SERVICE",
    "type" : "String",
    "comment" : "\n     * Used for getting the contextual search service.\n     *\n     * <p><b>NOTE: </b> this service is optional; callers of\n     * {@code Context.getSystemServiceName(CONTEXTUAL_SEARCH_SERVICE)} must check for {@code null}.\n     *\n     * @hide\n     * @see #getSystemService(String)\n     ",
    "links" : [ ]
  }, {
    "name" : "CLOUDSEARCH_SERVICE",
    "type" : "String",
    "comment" : "\n     * Used for getting the cloudsearch service.\n     *\n     * <p><b>NOTE: </b> this service is optional; callers of\n     * {@code Context.getSystemServiceName(CLOUDSEARCH_SERVICE)} should check for {@code null}.\n     *\n     * @hide\n     * @see #getSystemService(String)\n     ",
    "links" : [ ]
  }, {
    "name" : "SOUND_TRIGGER_SERVICE",
    "type" : "String",
    "comment" : "\n     * Use with {@link #getSystemService(String)} to access the\n     * {@link com.android.server.voiceinteraction.SoundTriggerService}.\n     *\n     * @hide\n     * @see #getSystemService(String)\n     ",
    "links" : [ "#getSystemService(String)", "com.android.server.voiceinteraction.SoundTriggerService" ]
  }, {
    "name" : "SOUND_TRIGGER_MIDDLEWARE_SERVICE",
    "type" : "String",
    "comment" : "\n     * Use with {@link #getSystemService(String)} to access the\n     * {@link com.android.server.soundtrigger_middleware.SoundTriggerMiddlewareService}.\n     *\n     * @hide\n     * @see #getSystemService(String)\n     ",
    "links" : [ "#getSystemService(String)", "com.android.server.soundtrigger_middleware.SoundTriggerMiddlewareService" ]
  }, {
    "name" : "WALLPAPER_EFFECTS_GENERATION_SERVICE",
    "type" : "String",
    "comment" : "\n     * Used for getting the wallpaper effects generation service.\n     *\n     * <p><b>NOTE: </b> this service is optional; callers of\n     * {@code Context.getSystemServiceName(WALLPAPER_EFFECTS_GENERATION_SERVICE)} should check for\n     * {@code null}.\n     *\n     * @hide\n     * @see #getSystemService(String)\n     ",
    "links" : [ ]
  }, {
    "name" : "MUSIC_RECOGNITION_SERVICE",
    "type" : "String",
    "comment" : "\n     * Used to access {@link MusicRecognitionManagerService}.\n     *\n     * @hide\n     * @see #getSystemService(String)\n     ",
    "links" : [ "MusicRecognitionManagerService" ]
  }, {
    "name" : "PERMISSION_SERVICE",
    "type" : "String",
    "comment" : "\n     * Official published name of the (internal) permission service.\n     *\n     * @see #getSystemService(String)\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "LEGACY_PERMISSION_SERVICE",
    "type" : "String",
    "comment" : "@SystemApi(client = SystemApi.Client.MODULE_LIBRARIES)",
    "links" : [ ]
  }, {
    "name" : "PERMISSION_CONTROLLER_SERVICE",
    "type" : "String",
    "comment" : "\n     * Official published name of the (internal) permission controller service.\n     *\n     * @see #getSystemService(String)\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "PERMISSION_CHECKER_SERVICE",
    "type" : "String",
    "comment" : "\n     * Official published name of the (internal) permission checker service.\n     *\n     * @see #getSystemService(String)\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "PERMISSION_ENFORCER_SERVICE",
    "type" : "String",
    "comment" : "\n     * Official published name of the (internal) permission enforcer service.\n     *\n     * @see #getSystemService(String)\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "APP_HIBERNATION_SERVICE",
    "type" : "String",
    "comment" : "\n     * Use with {@link #getSystemService(String) to retrieve an\n     * {@link android.apphibernation.AppHibernationManager}} for\n     * communicating with the hibernation service.\n     * @hide\n     *\n     * @see #getSystemService(String)\n     ",
    "links" : [ "#getSystemService(String)", "android.apphibernation.AppHibernationManager" ]
  }, {
    "name" : "BACKUP_SERVICE",
    "type" : "String",
    "comment" : "\n     * Use with {@link #getSystemService(String)} to retrieve an\n     * {@link android.app.backup.IBackupManager IBackupManager} for communicating\n     * with the backup mechanism.\n     * @hide\n     *\n     * @see #getSystemService(String)\n     ",
    "links" : [ "#getSystemService(String)", "android.app.backup.IBackupManager" ]
  }, {
    "name" : "ROLLBACK_SERVICE",
    "type" : "String",
    "comment" : "\n     * Use with {@link #getSystemService(String)} to retrieve an\n     * {@link android.content.rollback.RollbackManager} for communicating\n     * with the rollback manager\n     *\n     * @see #getSystemService(String)\n     * @hide\n     ",
    "links" : [ "#getSystemService(String)", "android.content.rollback.RollbackManager" ]
  }, {
    "name" : "REBOOT_READINESS_SERVICE",
    "type" : "String",
    "comment" : "\n     * Use with {@link #getSystemService(String)} to retrieve an\n     * {@link android.scheduling.RebootReadinessManager} for communicating\n     * with the reboot readiness detector.\n     *\n     * @see #getSystemService(String)\n     * @hide\n     ",
    "links" : [ "#getSystemService(String)", "android.scheduling.RebootReadinessManager" ]
  }, {
    "name" : "DROPBOX_SERVICE",
    "type" : "String",
    "comment" : "\n     * Use with {@link #getSystemService(String)} to retrieve a\n     * {@link android.os.DropBoxManager} instance for recording\n     * diagnostic logs.\n     * @see #getSystemService(String)\n     ",
    "links" : [ "#getSystemService(String)", "android.os.DropBoxManager" ]
  }, {
    "name" : "BACKGROUND_INSTALL_CONTROL_SERVICE",
    "type" : "String",
    "comment" : "\n     * System service name for BackgroundInstallControlService. This service supervises the MBAs\n     * on device and provides the related metadata of the MBAs.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "BINARY_TRANSPARENCY_SERVICE",
    "type" : "String",
    "comment" : "\n     * System service name for BinaryTransparencyService. This is used to retrieve measurements\n     * pertaining to various pre-installed and system binaries on device for the purposes of\n     * providing transparency to the user.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "DEVICE_IDLE_CONTROLLER",
    "type" : "String",
    "comment" : "\n     * System service name for the DeviceIdleManager.\n     * @see #getSystemService(String)\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "POWER_WHITELIST_MANAGER",
    "type" : "String",
    "comment" : "\n     * System service name for the PowerWhitelistManager.\n     *\n     * @see #getSystemService(String)\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "POWER_EXEMPTION_SERVICE",
    "type" : "String",
    "comment" : "\n     * System service name for the PowerExemptionManager.\n     *\n     * @see #getSystemService(String)\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "DEVICE_POLICY_SERVICE",
    "type" : "String",
    "comment" : "\n     * Use with {@link #getSystemService(String)} to retrieve a\n     * {@link android.app.admin.DevicePolicyManager} for working with global\n     * device policy management.\n     *\n     * @see #getSystemService(String)\n     ",
    "links" : [ "#getSystemService(String)", "android.app.admin.DevicePolicyManager" ]
  }, {
    "name" : "UI_MODE_SERVICE",
    "type" : "String",
    "comment" : "\n     * Use with {@link #getSystemService(String)} to retrieve a\n     * {@link android.app.UiModeManager} for controlling UI modes.\n     *\n     * @see #getSystemService(String)\n     ",
    "links" : [ "android.app.UiModeManager", "#getSystemService(String)" ]
  }, {
    "name" : "DOWNLOAD_SERVICE",
    "type" : "String",
    "comment" : "\n     * Use with {@link #getSystemService(String)} to retrieve a\n     * {@link android.app.DownloadManager} for requesting HTTP downloads.\n     *\n     * @see #getSystemService(String)\n     ",
    "links" : [ "android.app.DownloadManager", "#getSystemService(String)" ]
  }, {
    "name" : "BATTERY_SERVICE",
    "type" : "String",
    "comment" : "\n     * Use with {@link #getSystemService(String)} to retrieve a\n     * {@link android.os.BatteryManager} for managing battery state.\n     *\n     * @see #getSystemService(String)\n     ",
    "links" : [ "#getSystemService(String)", "android.os.BatteryManager" ]
  }, {
    "name" : "NFC_SERVICE",
    "type" : "String",
    "comment" : "\n     * Use with {@link #getSystemService(String)} to retrieve a\n     * {@link android.nfc.NfcManager} for using NFC.\n     *\n     * @see #getSystemService(String)\n     ",
    "links" : [ "#getSystemService(String)", "android.nfc.NfcManager" ]
  }, {
    "name" : "BLUETOOTH_SERVICE",
    "type" : "String",
    "comment" : "\n     * Use with {@link #getSystemService(String)} to retrieve a\n     * {@link android.bluetooth.BluetoothManager} for using Bluetooth.\n     *\n     * @see #getSystemService(String)\n     ",
    "links" : [ "#getSystemService(String)", "android.bluetooth.BluetoothManager" ]
  }, {
    "name" : "SIP_SERVICE",
    "type" : "String",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "USB_SERVICE",
    "type" : "String",
    "comment" : "\n     * Use with {@link #getSystemService(String)} to retrieve a {@link\n     * android.hardware.usb.UsbManager} for access to USB devices (as a USB host)\n     * and for controlling this device's behavior as a USB device.\n     *\n     * @see #getSystemService(String)\n     * @see android.hardware.usb.UsbManager\n     ",
    "links" : [ "#getSystemService(String)", "android.hardware.usb.UsbManager" ]
  }, {
    "name" : "ADB_SERVICE",
    "type" : "String",
    "comment" : "\n     * Use with {@link #getSystemService(String)} to retrieve a {@link\n     * Use with {@link #getSystemService} to retrieve a {@link\n     * android.debug.AdbManager} for access to ADB debug functions.\n     *\n     * @see #getSystemService(String)\n     * @see android.debug.AdbManager\n     *\n     * @hide\n     ",
    "links" : [ "#getSystemService(String)", "android.debug.AdbManager", "Use", "#getSystemService" ]
  }, {
    "name" : "SERIAL_SERVICE",
    "type" : "String",
    "comment" : "\n     * Use with {@link #getSystemService(String)} to retrieve a {@link\n     * android.hardware.SerialManager} for access to serial ports.\n     *\n     * @see #getSystemService(String)\n     * @see android.hardware.SerialManager\n     *\n     * @hide\n     ",
    "links" : [ "#getSystemService(String)", "android.hardware.SerialManager" ]
  }, {
    "name" : "HDMI_CONTROL_SERVICE",
    "type" : "String",
    "comment" : "\n     * Use with {@link #getSystemService(String)} to retrieve a\n     * {@link android.hardware.hdmi.HdmiControlManager} for controlling and managing\n     * HDMI-CEC protocol.\n     *\n     * @see #getSystemService(String)\n     * @see android.hardware.hdmi.HdmiControlManager\n     * @hide\n     ",
    "links" : [ "android.hardware.hdmi.HdmiControlManager", "#getSystemService(String)" ]
  }, {
    "name" : "INPUT_SERVICE",
    "type" : "String",
    "comment" : "\n     * Use with {@link #getSystemService(String)} to retrieve a\n     * {@link android.hardware.input.InputManager} for interacting with input devices.\n     *\n     * @see #getSystemService(String)\n     * @see android.hardware.input.InputManager\n     ",
    "links" : [ "#getSystemService(String)", "android.hardware.input.InputManager" ]
  }, {
    "name" : "DISPLAY_SERVICE",
    "type" : "String",
    "comment" : "\n     * Use with {@link #getSystemService(String)} to retrieve a\n     * {@link android.hardware.display.DisplayManager} for interacting with display devices.\n     *\n     * @see #getSystemService(String)\n     * @see android.hardware.display.DisplayManager\n     ",
    "links" : [ "#getSystemService(String)", "android.hardware.display.DisplayManager" ]
  }, {
    "name" : "COLOR_DISPLAY_SERVICE",
    "type" : "String",
    "comment" : "\n     * Use with {@link #getSystemService(String)} to retrieve a\n     * {@link android.hardware.display.ColorDisplayManager} for controlling color transforms.\n     *\n     * @see #getSystemService(String)\n     * @see android.hardware.display.ColorDisplayManager\n     * @hide\n     ",
    "links" : [ "android.hardware.display.ColorDisplayManager", "#getSystemService(String)" ]
  }, {
    "name" : "USER_SERVICE",
    "type" : "String",
    "comment" : "\n     * Use with {@link #getSystemService(String)} to retrieve a\n     * {@link android.os.UserManager} for managing users on devices that support multiple users.\n     *\n     * @see #getSystemService(String)\n     * @see android.os.UserManager\n     ",
    "links" : [ "android.os.UserManager", "#getSystemService(String)" ]
  }, {
    "name" : "LAUNCHER_APPS_SERVICE",
    "type" : "String",
    "comment" : "\n     * Use with {@link #getSystemService(String)} to retrieve a\n     * {@link android.content.pm.LauncherApps} for querying and monitoring launchable apps across\n     * profiles of a user.\n     *\n     * @see #getSystemService(String)\n     * @see android.content.pm.LauncherApps\n     ",
    "links" : [ "android.content.pm.LauncherApps", "#getSystemService(String)" ]
  }, {
    "name" : "RESTRICTIONS_SERVICE",
    "type" : "String",
    "comment" : "\n     * Use with {@link #getSystemService(String)} to retrieve a\n     * {@link android.content.RestrictionsManager} for retrieving application restrictions\n     * and requesting permissions for restricted operations.\n     * @see #getSystemService(String)\n     * @see android.content.RestrictionsManager\n     ",
    "links" : [ "#getSystemService(String)", "android.content.RestrictionsManager" ]
  }, {
    "name" : "APP_OPS_SERVICE",
    "type" : "String",
    "comment" : "\n     * Use with {@link #getSystemService(String)} to retrieve a\n     * {@link android.app.AppOpsManager} for tracking application operations\n     * on the device.\n     *\n     * @see #getSystemService(String)\n     * @see android.app.AppOpsManager\n     ",
    "links" : [ "#getSystemService(String)", "android.app.AppOpsManager" ]
  }, {
    "name" : "ROLE_SERVICE",
    "type" : "String",
    "comment" : "\n     * Use with {@link #getSystemService(String)} to retrieve a {@link android.app.role.RoleManager}\n     * for managing roles.\n     *\n     * @see #getSystemService(String)\n     * @see android.app.role.RoleManager\n     ",
    "links" : [ "android.app.role.RoleManager", "#getSystemService(String)" ]
  }, {
    "name" : "CAMERA_SERVICE",
    "type" : "String",
    "comment" : "\n     * Use with {@link #getSystemService(String)} to retrieve a\n     * {@link android.hardware.camera2.CameraManager} for interacting with\n     * camera devices.\n     *\n     * @see #getSystemService(String)\n     * @see android.hardware.camera2.CameraManager\n     ",
    "links" : [ "#getSystemService(String)", "android.hardware.camera2.CameraManager" ]
  }, {
    "name" : "PRINT_SERVICE",
    "type" : "String",
    "comment" : "\n     * {@link android.print.PrintManager} for printing and managing\n     * printers and print tasks.\n     *\n     * @see #getSystemService(String)\n     * @see android.print.PrintManager\n     ",
    "links" : [ "android.print.PrintManager" ]
  }, {
    "name" : "COMPANION_DEVICE_SERVICE",
    "type" : "String",
    "comment" : "\n     * Use with {@link #getSystemService(String)} to retrieve a\n     * {@link android.companion.CompanionDeviceManager} for managing companion devices\n     *\n     * @see #getSystemService(String)\n     * @see android.companion.CompanionDeviceManager\n     ",
    "links" : [ "android.companion.CompanionDeviceManager", "#getSystemService(String)" ]
  }, {
    "name" : "VIRTUAL_DEVICE_SERVICE",
    "type" : "String",
    "comment" : "\n     * Use with {@link #getSystemService(String)} to retrieve a\n     * {@link android.companion.virtual.VirtualDeviceManager} for managing virtual devices.\n     *\n     * On devices without {@link PackageManager#FEATURE_COMPANION_DEVICE_SETUP}\n     * system feature the {@link #getSystemService(String)} will return {@code null}.\n     *\n     * @see #getSystemService(String)\n     * @see android.companion.virtual.VirtualDeviceManager\n     ",
    "links" : [ "#getSystemService(String)", "android.content.pm.PackageManager#FEATURE_COMPANION_DEVICE_SETUP", "android.companion.virtual.VirtualDeviceManager" ]
  }, {
    "name" : "CONSUMER_IR_SERVICE",
    "type" : "String",
    "comment" : "\n     * Use with {@link #getSystemService(String)} to retrieve a\n     * {@link android.hardware.ConsumerIrManager} for transmitting infrared\n     * signals from the device.\n     *\n     * @see #getSystemService(String)\n     * @see android.hardware.ConsumerIrManager\n     ",
    "links" : [ "#getSystemService(String)", "android.hardware.ConsumerIrManager" ]
  }, {
    "name" : "TRUST_SERVICE",
    "type" : "String",
    "comment" : "\n     * {@link android.app.trust.TrustManager} for managing trust agents.\n     * @see #getSystemService(String)\n     * @see android.app.trust.TrustManager\n     * @hide\n     ",
    "links" : [ "android.app.trust.TrustManager" ]
  }, {
    "name" : "TV_INTERACTIVE_APP_SERVICE",
    "type" : "String",
    "comment" : "\n     * Use with {@link #getSystemService(String)} to retrieve a\n     * {@link android.media.tv.interactive.TvInteractiveAppManager} for interacting with TV\n     * interactive applications on the device.\n     *\n     * @see #getSystemService(String)\n     * @see android.media.tv.interactive.TvInteractiveAppManager\n     ",
    "links" : [ "#getSystemService(String)", "android.media.tv.interactive.TvInteractiveAppManager" ]
  }, {
    "name" : "TV_INPUT_SERVICE",
    "type" : "String",
    "comment" : "\n     * Use with {@link #getSystemService(String)} to retrieve a\n     * {@link android.media.tv.TvInputManager} for interacting with TV inputs\n     * on the device.\n     *\n     * @see #getSystemService(String)\n     * @see android.media.tv.TvInputManager\n     ",
    "links" : [ "#getSystemService(String)", "android.media.tv.TvInputManager" ]
  }, {
    "name" : "TV_AD_SERVICE",
    "type" : "String",
    "comment" : "\n     * Use with {@link #getSystemService(String)} to retrieve a\n     * {@link android.media.tv.ad.TvAdManager} for interacting with TV client-side advertisement\n     * services on the device.\n     *\n     * @see #getSystemService(String)\n     * @see android.media.tv.ad.TvAdManager\n     ",
    "links" : [ "#getSystemService(String)", "android.media.tv.ad.TvAdManager" ]
  }, {
    "name" : "TV_TUNER_RESOURCE_MGR_SERVICE",
    "type" : "String",
    "comment" : "\n     * Use with {@link #getSystemService(String)} to retrieve a\n     * {@link android.media.tv.TunerResourceManager} for interacting with TV\n     * tuner resources on the device.\n     *\n     * @see #getSystemService(String)\n     * @see android.media.tv.TunerResourceManager\n     * @hide\n     ",
    "links" : [ "android.media.tv.TunerResourceManager", "#getSystemService(String)" ]
  }, {
    "name" : "NETWORK_SCORE_SERVICE",
    "type" : "String",
    "comment" : "\n     * {@link android.net.NetworkScoreManager} for managing network scoring.\n     * @see #getSystemService(String)\n     * @see android.net.NetworkScoreManager\n     * @deprecated see\n     * <a href=\"{@docRoot}guide/topics/connectivity/wifi-suggest\">Wi-Fi Suggestion API</a>\n     * for alternative API to propose WiFi networks.\n     * @hide\n     ",
    "links" : [ "android.net.NetworkScoreManager" ]
  }, {
    "name" : "USAGE_STATS_SERVICE",
    "type" : "String",
    "comment" : "\n     * Use with {@link #getSystemService(String)} to retrieve a {@link\n     * android.app.usage.UsageStatsManager} for querying device usage stats.\n     *\n     * @see #getSystemService(String)\n     * @see android.app.usage.UsageStatsManager\n     ",
    "links" : [ "#getSystemService(String)", "android.app.usage.UsageStatsManager" ]
  }, {
    "name" : "JOB_SCHEDULER_SERVICE",
    "type" : "String",
    "comment" : "\n     * Use with {@link #getSystemService(String)} to retrieve a {@link\n     * android.app.job.JobScheduler} instance for managing occasional\n     * background tasks.\n     * @see #getSystemService(String)\n     * @see android.app.job.JobScheduler\n     ",
    "links" : [ "#getSystemService(String)", "android.app.job.JobScheduler" ]
  }, {
    "name" : "PERSISTENT_DATA_BLOCK_SERVICE",
    "type" : "String",
    "comment" : "\n     * Use with {@link #getSystemService(String)} to retrieve a {@link\n     * android.service.persistentdata.PersistentDataBlockManager} instance\n     * for interacting with a storage device that lives across factory resets.\n     *\n     * @see #getSystemService(String)\n     * @see android.service.persistentdata.PersistentDataBlockManager\n     ",
    "links" : [ "#getSystemService(String)", "android.service.persistentdata.PersistentDataBlockManager" ]
  }, {
    "name" : "OEM_LOCK_SERVICE",
    "type" : "String",
    "comment" : "\n     * Use with {@link #getSystemService(String)} to retrieve a {@link\n     * android.service.oemlock.OemLockManager} instance for managing the OEM lock.\n     *\n     * @see #getSystemService(String)\n     * @see android.service.oemlock.OemLockManager\n     * @hide\n     ",
    "links" : [ "#getSystemService(String)", "android.service.oemlock.OemLockManager" ]
  }, {
    "name" : "MEDIA_PROJECTION_SERVICE",
    "type" : "String",
    "comment" : "\n     * Use with {@link #getSystemService(String)} to retrieve a {@link\n     * android.media.projection.MediaProjectionManager} instance for managing\n     * media projection sessions.\n     * @see #getSystemService(String)\n     * @see android.media.projection.MediaProjectionManager\n     ",
    "links" : [ "#getSystemService(String)", "android.media.projection.MediaProjectionManager" ]
  }, {
    "name" : "MIDI_SERVICE",
    "type" : "String",
    "comment" : "\n     * Use with {@link #getSystemService(String)} to retrieve a\n     * {@link android.media.midi.MidiManager} for accessing the MIDI service.\n     *\n     * @see #getSystemService(String)\n     ",
    "links" : [ "android.media.midi.MidiManager", "#getSystemService(String)" ]
  }, {
    "name" : "RADIO_SERVICE",
    "type" : "String",
    "comment" : "\n     * Use with {@link #getSystemService(String)} to retrieve a\n     * {@link android.hardware.radio.RadioManager} for accessing the broadcast radio service.\n     *\n     * @see #getSystemService(String)\n     * @hide\n     ",
    "links" : [ "#getSystemService(String)", "android.hardware.radio.RadioManager" ]
  }, {
    "name" : "HARDWARE_PROPERTIES_SERVICE",
    "type" : "String",
    "comment" : "\n     * Use with {@link #getSystemService(String)} to retrieve a\n     * {@link android.os.HardwarePropertiesManager} for accessing the hardware properties service.\n     *\n     * @see #getSystemService(String)\n     ",
    "links" : [ "#getSystemService(String)", "android.os.HardwarePropertiesManager" ]
  }, {
    "name" : "THERMAL_SERVICE",
    "type" : "String",
    "comment" : "\n     * Use with {@link #getSystemService(String)} to retrieve a\n     * {@link android.os.ThermalService} for accessing the thermal service.\n     *\n     * @see #getSystemService(String)\n     * @hide\n     ",
    "links" : [ "#getSystemService(String)", "android.os.ThermalService" ]
  }, {
    "name" : "PERFORMANCE_HINT_SERVICE",
    "type" : "String",
    "comment" : "\n     * Use with {@link #getSystemService(String)} to retrieve a\n     * {@link android.os.PerformanceHintManager} for accessing the performance hinting service.\n     *\n     * @see #getSystemService(String)\n     ",
    "links" : [ "#getSystemService(String)", "android.os.PerformanceHintManager" ]
  }, {
    "name" : "SHORTCUT_SERVICE",
    "type" : "String",
    "comment" : "\n     * Use with {@link #getSystemService(String)} to retrieve a\n     * {@link android.content.pm.ShortcutManager} for accessing the launcher shortcut service.\n     *\n     * @see #getSystemService(String)\n     * @see android.content.pm.ShortcutManager\n     ",
    "links" : [ "#getSystemService(String)", "android.content.pm.ShortcutManager" ]
  }, {
    "name" : "CONTEXTHUB_SERVICE",
    "type" : "String",
    "comment" : "\n     * Use with {@link #getSystemService(String)} to retrieve a {@link\n     * android.hardware.location.ContextHubManager} for accessing context hubs.\n     *\n     * @see #getSystemService(String)\n     * @see android.hardware.location.ContextHubManager\n     *\n     * @hide\n     ",
    "links" : [ "#getSystemService(String)", "android.hardware.location.ContextHubManager" ]
  }, {
    "name" : "SYSTEM_HEALTH_SERVICE",
    "type" : "String",
    "comment" : "\n     * Use with {@link #getSystemService(String)} to retrieve a\n     * {@link android.os.health.SystemHealthManager} for accessing system health (battery, power,\n     * memory, etc) metrics.\n     *\n     * @see #getSystemService(String)\n     ",
    "links" : [ "#getSystemService(String)", "android.os.health.SystemHealthManager" ]
  }, {
    "name" : "GATEKEEPER_SERVICE",
    "type" : "String",
    "comment" : "\n     * Gatekeeper Service.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "DEVICE_IDENTIFIERS_SERVICE",
    "type" : "String",
    "comment" : "\n     * Service defining the policy for access to device identifiers.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "INCIDENT_SERVICE",
    "type" : "String",
    "comment" : "\n     * Service to report a system health \"incident\"\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "INCIDENT_COMPANION_SERVICE",
    "type" : "String",
    "comment" : "\n     * Service to assist incidentd and dumpstated in reporting status to the user\n     * and in confirming authorization to take an incident report or bugreport\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "STATS_MANAGER_SERVICE",
    "type" : "String",
    "comment" : "\n     * Service to assist {@link android.app.StatsManager} that lives in system server.\n     * @hide\n     ",
    "links" : [ "android.app.StatsManager" ]
  }, {
    "name" : "STATS_COMPANION_SERVICE",
    "type" : "String",
    "comment" : "\n     * Service to assist statsd in obtaining general stats.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "STATS_BOOTSTRAP_ATOM_SERVICE",
    "type" : "String",
    "comment" : "\n     * Service to assist statsd in logging atoms from bootstrap atoms.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "STATS_MANAGER",
    "type" : "String",
    "comment" : "\n     * Use with {@link #getSystemService(String)} to retrieve an {@link android.app.StatsManager}.\n     * @hide\n     ",
    "links" : [ "#getSystemService(String)", "android.app.StatsManager" ]
  }, {
    "name" : "PLATFORM_COMPAT_SERVICE",
    "type" : "String",
    "comment" : "\n     * Use with {@link android.os.ServiceManager.getService()} to retrieve a\n     * {@link IPlatformCompat} IBinder for communicating with the platform compat service.\n     * @hide\n     ",
    "links" : [ "com.android.internal.compat.IPlatformCompat", "android.os.ServiceManager.getService()" ]
  }, {
    "name" : "PLATFORM_COMPAT_NATIVE_SERVICE",
    "type" : "String",
    "comment" : "\n     * Use with {@link android.os.ServiceManager.getService()} to retrieve a\n     * {@link IPlatformCompatNative} IBinder for native code communicating with the platform compat\n     * service.\n     * @hide\n     ",
    "links" : [ "com.android.internal.compat.IPlatformCompatNative", "android.os.ServiceManager.getService()" ]
  }, {
    "name" : "BUGREPORT_SERVICE",
    "type" : "String",
    "comment" : "\n     * Service to capture a bugreport.\n     * @see #getSystemService(String)\n     * @see android.os.BugreportManager\n     ",
    "links" : [ ]
  }, {
    "name" : "OVERLAY_SERVICE",
    "type" : "String",
    "comment" : "\n     * Use with {@link #getSystemService(String)} to retrieve a {@link\n     * android.content.om.OverlayManager} for managing overlay packages.\n     *\n     * @see #getSystemService(String)\n     * @see android.content.om.OverlayManager\n     ",
    "links" : [ "#getSystemService(String)", "android.content.om.OverlayManager" ]
  }, {
    "name" : "RESOURCES_SERVICE",
    "type" : "String",
    "comment" : "\n     * Use with {@link #getSystemService(String)} to manage resources.\n     *\n     * @see #getSystemService(String)\n     * @see com.android.server.resources.ResourcesManagerService\n     * @hide\n     ",
    "links" : [ "#getSystemService(String)" ]
  }, {
    "name" : "IDMAP_SERVICE",
    "type" : "String",
    "comment" : "\n     * Use with {@link #getSystemService(String)} to retrieve a\n     * {android.os.IIdmap2} for managing idmap files (used by overlay\n     * packages).\n     *\n     * @see #getSystemService(String)\n     * @hide\n     ",
    "links" : [ "#getSystemService(String)" ]
  }, {
    "name" : "VR_SERVICE",
    "type" : "String",
    "comment" : "\n     * Use with {@link #getSystemService(String)} to retrieve a\n     * {@link VrManager} for accessing the VR service.\n     *\n     * @see #getSystemService(String)\n     * @hide\n     ",
    "links" : [ "#getSystemService(String)", "android.app.VrManager" ]
  }, {
    "name" : "CROSS_PROFILE_APPS_SERVICE",
    "type" : "String",
    "comment" : "\n     * Use with {@link #getSystemService(String)} to retrieve a\n     * {@link android.content.pm.CrossProfileApps} for cross profile operations.\n     *\n     * @see #getSystemService(String)\n     ",
    "links" : [ "#getSystemService(String)", "android.content.pm.CrossProfileApps" ]
  }, {
    "name" : "SECURE_ELEMENT_SERVICE",
    "type" : "String",
    "comment" : "\n     * Use with {@link #getSystemService} to retrieve a\n     * {@link android.se.omapi.ISecureElementService}\n     * for accessing the SecureElementService.\n     *\n     * @hide\n     ",
    "links" : [ "android.se.omapi.ISecureElementService", "#getSystemService" ]
  }, {
    "name" : "TIME_DETECTOR_SERVICE",
    "type" : "String",
    "comment" : "\n     * Use with {@link #getSystemService(String)} to retrieve a\n     * {@link android.app.timedetector.TimeDetector}.\n     * @hide\n     *\n     * @see #getSystemService(String)\n     ",
    "links" : [ "#getSystemService(String)", "android.app.timedetector.TimeDetector" ]
  }, {
    "name" : "TIME_ZONE_DETECTOR_SERVICE",
    "type" : "String",
    "comment" : "\n     * Use with {@link #getSystemService(String)} to retrieve a\n     * {@link android.app.timezonedetector.TimeZoneDetector}.\n     * @hide\n     *\n     * @see #getSystemService(String)\n     ",
    "links" : [ "#getSystemService(String)", "android.app.timezonedetector.TimeZoneDetector" ]
  }, {
    "name" : "TIME_MANAGER_SERVICE",
    "type" : "String",
    "comment" : "\n     * Use with {@link #getSystemService(String)} to retrieve a {@link TimeManager}.\n     * @hide\n     *\n     * @see #getSystemService(String)\n     ",
    "links" : [ "#getSystemService(String)", "android.app.time.TimeManager" ]
  }, {
    "name" : "APP_BINDING_SERVICE",
    "type" : "String",
    "comment" : "\n     * Binder service name for {@link AppBindingService}.\n     * @hide\n     ",
    "links" : [ "AppBindingService" ]
  }, {
    "name" : "TELEPHONY_IMS_SERVICE",
    "type" : "String",
    "comment" : "\n     * Use with {@link #getSystemService(String)} to retrieve an\n     * {@link android.telephony.ims.ImsManager}.\n     ",
    "links" : [ "#getSystemService(String)", "android.telephony.ims.ImsManager" ]
  }, {
    "name" : "SYSTEM_CONFIG_SERVICE",
    "type" : "String",
    "comment" : "\n     * Use with {@link #getSystemService(String)} to retrieve an\n     * {@link android.os.SystemConfigManager}.\n     * @hide\n     ",
    "links" : [ "#getSystemService(String)", "android.os.SystemConfigManager" ]
  }, {
    "name" : "TELEPHONY_RCS_MESSAGE_SERVICE",
    "type" : "String",
    "comment" : "\n     * Use with {@link #getSystemService(String)} to retrieve an\n     * {@link android.telephony.ims.RcsMessageManager}.\n     * @hide\n     ",
    "links" : [ "#getSystemService(String)", "android.telephony.ims.RcsMessageManager" ]
  }, {
    "name" : "DYNAMIC_SYSTEM_SERVICE",
    "type" : "String",
    "comment" : "\n     * Use with {@link #getSystemService(String)} to retrieve an\n     * {@link android.os.image.DynamicSystemManager}.\n     * @hide\n     ",
    "links" : [ "android.os.image.DynamicSystemManager", "#getSystemService(String)" ]
  }, {
    "name" : "BLOB_STORE_SERVICE",
    "type" : "String",
    "comment" : "\n     * Use with {@link #getSystemService(String)} to retrieve a {@link\n     * android.app.blob.BlobStoreManager} for contributing and accessing data blobs\n     * from the blob store maintained by the system.\n     *\n     * @see #getSystemService(String)\n     * @see android.app.blob.BlobStoreManager\n     ",
    "links" : [ "android.app.blob.BlobStoreManager", "#getSystemService(String)" ]
  }, {
    "name" : "TELEPHONY_REGISTRY_SERVICE",
    "type" : "String",
    "comment" : "\n     * Use with {@link #getSystemService(String)} to retrieve an\n     * {@link TelephonyRegistryManager}.\n     * @hide\n     ",
    "links" : [ "#getSystemService(String)", "android.telephony.TelephonyRegistryManager" ]
  }, {
    "name" : "BATTERY_STATS_SERVICE",
    "type" : "String",
    "comment" : "\n     * Use with {@link #getSystemService(String)} to retrieve an\n     * {@link android.os.BatteryStatsManager}.\n     * @hide\n     ",
    "links" : [ "#getSystemService(String)", "android.os.BatteryStatsManager" ]
  }, {
    "name" : "APP_SEARCH_SERVICE",
    "type" : "String",
    "comment" : "\n     * Use with {@link #getSystemService(String)} to retrieve an\n     * {@link android.app.appsearch.AppSearchManager} for\n     * indexing and querying app data managed by the system.\n     *\n     * @see #getSystemService(String)\n     ",
    "links" : [ "#getSystemService(String)", "android.app.appsearch.AppSearchManager" ]
  }, {
    "name" : "APP_INTEGRITY_SERVICE",
    "type" : "String",
    "comment" : "\n     * Use with {@link #getSystemService(String)} to retrieve an\n     * {@link android.content.integrity.AppIntegrityManager}.\n     * @hide\n     ",
    "links" : [ "#getSystemService(String)", "android.content.integrity.AppIntegrityManager" ]
  }, {
    "name" : "DATA_LOADER_MANAGER_SERVICE",
    "type" : "String",
    "comment" : "\n     * Use with {@link #getSystemService(String)} to retrieve an\n     * {@link android.content.pm.DataLoaderManager}.\n     * @hide\n     ",
    "links" : [ "#getSystemService(String)", "android.content.pm.DataLoaderManager" ]
  }, {
    "name" : "INCREMENTAL_SERVICE",
    "type" : "String",
    "comment" : "\n     * Use with {@link #getSystemService(String)} to retrieve an\n     * {@link android.os.incremental.IncrementalManager}.\n     * @hide\n     ",
    "links" : [ "#getSystemService(String)", "android.os.incremental.IncrementalManager" ]
  }, {
    "name" : "ATTESTATION_VERIFICATION_SERVICE",
    "type" : "String",
    "comment" : "\n     * Use with {@link #getSystemService(String)} to retrieve an\n     * {@link android.security.attestationverification.AttestationVerificationManager}.\n     * @see #getSystemService(String)\n     * @see android.security.attestationverification.AttestationVerificationManager\n     * @hide\n     ",
    "links" : [ "#getSystemService(String)", "android.security.attestationverification.AttestationVerificationManager" ]
  }, {
    "name" : "FILE_INTEGRITY_SERVICE",
    "type" : "String",
    "comment" : "\n     * Use with {@link #getSystemService(String)} to retrieve an\n     * {@link android.security.FileIntegrityManager}.\n     * @see #getSystemService(String)\n     * @see android.security.FileIntegrityManager\n     ",
    "links" : [ "android.security.FileIntegrityManager", "#getSystemService(String)" ]
  }, {
    "name" : "REMOTE_PROVISIONING_SERVICE",
    "type" : "String",
    "comment" : "\n     * Binder service for remote key provisioning.\n     *\n     * @see android.frameworks.rkp.IRemoteProvisioning\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "LIGHTS_SERVICE",
    "type" : "String",
    "comment" : "\n     * Use with {@link #getSystemService(String)} to retrieve a\n     * {@link android.hardware.lights.LightsManager} for controlling device lights.\n     *\n     * @see #getSystemService(String)\n     * @hide\n     ",
    "links" : [ "#getSystemService(String)", "android.hardware.lights.LightsManager" ]
  }, {
    "name" : "UWB_SERVICE",
    "type" : "String",
    "comment" : "\n     * Use with {@link #getSystemService(String)} to retrieve a\n     * {@link android.uwb.UwbManager}.\n     *\n     * @see #getSystemService(String)\n     * @hide\n     ",
    "links" : [ "#getSystemService(String)", "android.uwb.UwbManager" ]
  }, {
    "name" : "DREAM_SERVICE",
    "type" : "String",
    "comment" : "\n     * Use with {@link #getSystemService(String)} to retrieve a\n     * {@link android.app.DreamManager} for controlling Dream states.\n     *\n     * @see #getSystemService(String)\n\n     * @hide\n     ",
    "links" : [ "#getSystemService(String)", "android.app.DreamManager" ]
  }, {
    "name" : "SMS_SERVICE",
    "type" : "String",
    "comment" : "\n     * Use with {@link #getSystemService(String)} to retrieve a\n     * {@link android.telephony.SmsManager} for accessing Sms functionality.\n     *\n     * @see #getSystemService(String)\n\n     * @hide\n     ",
    "links" : [ "#getSystemService(String)", "android.telephony.SmsManager" ]
  }, {
    "name" : "PEOPLE_SERVICE",
    "type" : "String",
    "comment" : "\n     * Use with {@link #getSystemService(String)} to access a {@link PeopleManager} to interact\n     * with your published conversations.\n     *\n     * @see #getSystemService(String)\n     ",
    "links" : [ "android.app.people.PeopleManager", "#getSystemService(String)" ]
  }, {
    "name" : "DEVICE_STATE_SERVICE",
    "type" : "String",
    "comment" : "\n     * Use with {@link #getSystemService(String)} to access device state service.\n     *\n     * @see #getSystemService(String)\n     * @hide\n     ",
    "links" : [ "#getSystemService(String)" ]
  }, {
    "name" : "MEDIA_METRICS_SERVICE",
    "type" : "String",
    "comment" : "\n     * Use with {@link #getSystemService(String)} to retrieve a\n     * {@link android.media.metrics.MediaMetricsManager} for interacting with media metrics\n     * on the device.\n     *\n     * @see #getSystemService(String)\n     * @see android.media.metrics.MediaMetricsManager\n     ",
    "links" : [ "#getSystemService(String)", "android.media.metrics.MediaMetricsManager" ]
  }, {
    "name" : "SPEECH_RECOGNITION_SERVICE",
    "type" : "String",
    "comment" : "\n     * Use with {@link #getSystemService(String)} to access system speech recognition service.\n     *\n     * @see #getSystemService(String)\n     * @hide\n    ",
    "links" : [ "#getSystemService(String)" ]
  }, {
    "name" : "GAME_SERVICE",
    "type" : "String",
    "comment" : "\n     * Use with {@link #getSystemService(String)} to retrieve a\n     * {@link GameManager}.\n     *\n     * @see #getSystemService(String)\n     ",
    "links" : [ "#getSystemService(String)", "android.app.GameManager" ]
  }, {
    "name" : "DOMAIN_VERIFICATION_SERVICE",
    "type" : "String",
    "comment" : "\n     * Use with {@link #getSystemService(String)} to access\n     * {@link android.content.pm.verify.domain.DomainVerificationManager} to retrieve approval and\n     * user state for declared web domains.\n     *\n     * @see #getSystemService(String)\n     * @see android.content.pm.verify.domain.DomainVerificationManager\n     ",
    "links" : [ "#getSystemService(String)", "android.content.pm.verify.domain.DomainVerificationManager" ]
  }, {
    "name" : "DISPLAY_HASH_SERVICE",
    "type" : "String",
    "comment" : "\n     * Use with {@link #getSystemService(String)} to access\n     * {@link android.view.displayhash.DisplayHashManager} to handle display hashes.\n     *\n     * @see #getSystemService(String)\n     ",
    "links" : [ "#getSystemService(String)", "android.view.displayhash.DisplayHashManager" ]
  }, {
    "name" : "LOCALE_SERVICE",
    "type" : "String",
    "comment" : "\n     * Use with {@link #getSystemService(String)} to retrieve a\n     * {@link android.app.LocaleManager}.\n     *\n     * @see #getSystemService(String)\n     ",
    "links" : [ "#getSystemService(String)", "android.app.LocaleManager" ]
  }, {
    "name" : "SAFETY_CENTER_SERVICE",
    "type" : "String",
    "comment" : "\n     * Use with {@link #getSystemService(String)} to retrieve a {@link\n     * android.safetycenter.SafetyCenterManager} instance for interacting with the safety center.\n     *\n     * @see #getSystemService(String)\n     * @see android.safetycenter.SafetyCenterManager\n     * @hide\n     ",
    "links" : [ "#getSystemService(String)", "android.safetycenter.SafetyCenterManager" ]
  }, {
    "name" : "NEARBY_SERVICE",
    "type" : "String",
    "comment" : "\n     * Use with {@link #getSystemService(String)} to retrieve a\n     * {@link android.nearby.NearbyManager} to discover nearby devices.\n     *\n     * @see #getSystemService(String)\n     * @see android.nearby.NearbyManager\n     * @hide\n     ",
    "links" : [ "#getSystemService(String)", "android.nearby.NearbyManager" ]
  }, {
    "name" : "REMOTE_AUTH_SERVICE",
    "type" : "String",
    "comment" : "\n     * Use with {@link #getSystemService(String)} to retrieve a\n     * {@link android.remoteauth.RemoteAuthManager} to discover,\n     * register and authenticate via remote authenticator  devices.\n     *\n     * @see #getSystemService(String)\n     * @see android.remoteauth.RemoteAuthManager\n     * @hide\n     ",
    "links" : [ "android.remoteauth.RemoteAuthManager", "#getSystemService(String)" ]
  }, {
    "name" : "AMBIENT_CONTEXT_SERVICE",
    "type" : "String",
    "comment" : "\n     * Use with {@link #getSystemService(String)} to retrieve a\n     * {@link android.app.ambientcontext.AmbientContextManager}.\n     *\n     * @see #getSystemService(String)\n     * @see AmbientContextManager\n     * @hide\n     ",
    "links" : [ "#getSystemService(String)", "android.app.ambientcontext.AmbientContextManager" ]
  }, {
    "name" : "WEARABLE_SENSING_SERVICE",
    "type" : "String",
    "comment" : "\n     * Use with {@link #getSystemService(String)} to retrieve a\n     * {@link android.app.wearable.WearableSensingManager}.\n     *\n     * @see #getSystemService(String)\n     * @see WearableSensingManager\n     * @hide\n     ",
    "links" : [ "#getSystemService(String)", "android.app.wearable.WearableSensingManager" ]
  }, {
    "name" : "ON_DEVICE_INTELLIGENCE_SERVICE",
    "type" : "String",
    "comment" : "\n     * Use with {@link #getSystemService(String)} to retrieve a\n     * {@link android.app.ondeviceintelligence.OnDeviceIntelligenceManager}.\n     *\n     * @see #getSystemService(String)\n     * @see OnDeviceIntelligenceManager\n     * @hide\n     ",
    "links" : [ "#getSystemService(String)", "android.app.ondeviceintelligence.OnDeviceIntelligenceManager" ]
  }, {
    "name" : "HEALTHCONNECT_SERVICE",
    "type" : "String",
    "comment" : "\n     * Use with {@link #getSystemService(String)} to retrieve a\n     * {@link android.health.connect.HealthConnectManager}.\n     *\n     * @see #getSystemService(String)\n     * @see android.health.connect.HealthConnectManager\n     ",
    "links" : [ "#getSystemService(String)", "android.health.connect.HealthConnectManager" ]
  }, {
    "name" : "CREDENTIAL_SERVICE",
    "type" : "String",
    "comment" : "\n     * Use with {@link #getSystemService(String)} to retrieve a\n     * {@link android.credentials.CredentialManager} to authenticate a user to your app.\n     *\n     * @see #getSystemService(String)\n     * @see CredentialManager\n     ",
    "links" : [ "#getSystemService(String)", "android.credentials.CredentialManager" ]
  }, {
    "name" : "DEVICE_LOCK_SERVICE",
    "type" : "String",
    "comment" : "\n     * Use with {@link #getSystemService(String)} to retrieve a\n     * {@link android.devicelock.DeviceLockManager}.\n     *\n     * @see #getSystemService(String)\n     ",
    "links" : [ "#getSystemService(String)", "android.devicelock.DeviceLockManager" ]
  }, {
    "name" : "VIRTUALIZATION_SERVICE",
    "type" : "String",
    "comment" : "\n     * Use with {@link #getSystemService(String)} to retrieve a\n     * {@link android.system.virtualmachine.VirtualMachineManager}.\n     *\n     * <p>On devices without {@link PackageManager#FEATURE_VIRTUALIZATION_FRAMEWORK} system feature\n     * the {@link #getSystemService(String)} will return {@code null}.\n     *\n     * @see #getSystemService(String)\n     * @see android.system.virtualmachine.VirtualMachineManager\n     * @hide\n     ",
    "links" : [ "#getSystemService(String)", "android.content.pm.PackageManager#FEATURE_VIRTUALIZATION_FRAMEWORK", "android.system.virtualmachine.VirtualMachineManager" ]
  }, {
    "name" : "GRAMMATICAL_INFLECTION_SERVICE",
    "type" : "String",
    "comment" : "\n     * Use with {@link #getSystemService(String)} to retrieve a\n     * {@link GrammaticalInflectionManager}.\n     *\n     * @see #getSystemService(String)\n     ",
    "links" : [ "#getSystemService(String)", "android.app.GrammaticalInflectionManager" ]
  }, {
    "name" : "SATELLITE_SERVICE",
    "type" : "String",
    "comment" : "\n     * Use with {@link #getSystemService(String)} to retrieve a\n     * {@link android.telephony.satellite.SatelliteManager} for accessing satellite functionality.\n     *\n     * @see #getSystemService(String)\n     * @see android.telephony.satellite.SatelliteManager\n     * @hide\n     ",
    "links" : [ "android.telephony.satellite.SatelliteManager", "#getSystemService(String)" ]
  }, {
    "name" : "SHARED_CONNECTIVITY_SERVICE",
    "type" : "String",
    "comment" : "\n     * Use with {@link #getSystemService(String)} to retrieve a\n     * {@link android.net.wifi.sharedconnectivity.app.SharedConnectivityManager} for accessing\n     * shared connectivity services.\n     *\n     * @see #getSystemService(String)\n     * @see android.net.wifi.sharedconnectivity.app.SharedConnectivityManager\n     * @hide\n     ",
    "links" : [ "#getSystemService(String)", "android.net.wifi.sharedconnectivity.app.SharedConnectivityManager" ]
  }, {
    "name" : "SECURITY_STATE_SERVICE",
    "type" : "String",
    "comment" : "\n     * Use with {@link #getSystemService(String)} to retrieve a\n     * {@link android.os.SecurityStateManager} for accessing the security state manager service.\n     *\n     * @see #getSystemService(String)\n     * @see android.os.SecurityStateManager\n     ",
    "links" : [ "android.os.SecurityStateManager", "#getSystemService(String)" ]
  }, {
    "name" : "ECM_ENHANCED_CONFIRMATION_SERVICE",
    "type" : "String",
    "comment" : "\n     * Use with {@link #getSystemService(String)} to retrieve an\n     * {@link android.app.ecm.EnhancedConfirmationManager}.\n     *\n     * @see #getSystemService(String)\n     * @see android.app.ecm.EnhancedConfirmationManager\n     * @hide\n     ",
    "links" : [ "#getSystemService(String)", "android.app.ecm.EnhancedConfirmationManager" ]
  }, {
    "name" : "SENSITIVE_CONTENT_PROTECTION_SERVICE",
    "type" : "String",
    "comment" : "\n     * Service to protect sensitive content during screen share.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "CONTACT_KEYS_SERVICE",
    "type" : "String",
    "comment" : "\n     * Use with {@link #getSystemService(String)} to retrieve a\n     * {@link E2eeContactKeysManager} to managing contact keys.\n     *\n     * @see #getSystemService(String)\n     * @see E2eeContactKeysManager\n     ",
    "links" : [ "#getSystemService(String)", "android.provider.E2eeContactKeysManager" ]
  }, {
    "name" : "PROFILING_SERVICE",
    "type" : "String",
    "comment" : "\n     * Use with {@link #getSystemService(String)} to retrieve an\n     * {@link android.os.ProfilingManager}.\n     *\n     * @see #getSystemService(String)\n     ",
    "links" : [ "#getSystemService(String)", "android.os.ProfilingManager" ]
  }, {
    "name" : "WEBVIEW_UPDATE_SERVICE",
    "type" : "String",
    "comment" : "\n     * Use with {@link #getSystemService(String)} to retrieve a {@link\n     * android.webkit.WebViewUpdateManager} for accessing the WebView update service.\n     *\n     * @see #getSystemService(String)\n     * @see android.webkit.WebViewUpdateManager\n     * @hide\n     ",
    "links" : [ "android.webkit.WebViewUpdateManager", "#getSystemService(String)" ]
  }, {
    "name" : "BLOCKED_NUMBERS_SERVICE",
    "type" : "String",
    "comment" : "\n     * Use with {@link #getSystemService(String)} to retrieve a\n     * {@link android.provider.BlockedNumbersManager} for accessing the blocked number service.\n     *\n     * @see #getSystemService(String)\n     * @see android.provider.BlockedNumbersManager\n     * @hide\n     ",
    "links" : [ "#getSystemService(String)", "android.provider.BlockedNumbersManager" ]
  }, {
    "name" : "CONTEXT_INCLUDE_CODE",
    "type" : "int",
    "comment" : "\n     * Flag for use with {@link #createPackageContext}: include the application\n     * code with the context.  This means loading code into the caller's\n     * process, so that {@link #getClassLoader()} can be used to instantiate\n     * the application's classes.  Setting this flags imposes security\n     * restrictions on what application context you can access; if the\n     * requested application can not be safely loaded into your process,\n     * java.lang.SecurityException will be thrown.  If this flag is not set,\n     * there will be no restrictions on the packages that can be loaded,\n     * but {@link #getClassLoader} will always return the default system\n     * class loader.\n     ",
    "links" : [ "#getClassLoader()", "#getClassLoader", "#createPackageContext" ]
  }, {
    "name" : "CONTEXT_IGNORE_SECURITY",
    "type" : "int",
    "comment" : "\n     * Flag for use with {@link #createPackageContext}: ignore any security\n     * restrictions on the Context being requested, allowing it to always\n     * be loaded.  For use with {@link #CONTEXT_INCLUDE_CODE} to allow code\n     * to be loaded into a process even when it isn't safe to do so.  Use\n     * with extreme care!\n     ",
    "links" : [ "#CONTEXT_INCLUDE_CODE", "#createPackageContext" ]
  }, {
    "name" : "CONTEXT_RESTRICTED",
    "type" : "int",
    "comment" : "\n     * Flag for use with {@link #createPackageContext}: a restricted context may\n     * disable specific features. For instance, a View associated with a restricted\n     * context would ignore particular XML attributes.\n     ",
    "links" : [ "#createPackageContext" ]
  }, {
    "name" : "CONTEXT_DEVICE_PROTECTED_STORAGE",
    "type" : "int",
    "comment" : "\n     * Flag for use with {@link #createPackageContext}: point all file APIs at\n     * device-protected storage.\n     *\n     * @hide\n     ",
    "links" : [ "#createPackageContext" ]
  }, {
    "name" : "CONTEXT_CREDENTIAL_PROTECTED_STORAGE",
    "type" : "int",
    "comment" : "\n     * Flag for use with {@link #createPackageContext}: point all file APIs at\n     * credential-protected storage.\n     *\n     * @hide\n     ",
    "links" : [ "#createPackageContext" ]
  }, {
    "name" : "CONTEXT_REGISTER_PACKAGE",
    "type" : "int",
    "comment" : "\n     * @hide Used to indicate we should tell the activity manager about the process\n     * loading this code.\n     ",
    "links" : [ ]
  } ],
  "methods" : [ {
    "name" : "public abstract AssetManager getAssets()",
    "returnType" : "AssetManager",
    "comment" : "\n     * Returns an AssetManager instance for the application's package.\n     * <p>\n     * <strong>Note:</strong> Implementations of this method should return\n     * an AssetManager instance that is consistent with the Resources instance\n     * returned by {@link #getResources()}. For example, they should share the\n     * same {@link Configuration} object.\n     *\n     * @return an AssetManager instance for the application's package\n     * @see #getResources()\n     ",
    "links" : [ "android.content.res.Configuration", "#getResources()" ]
  }, {
    "name" : "public abstract Resources getResources()",
    "returnType" : "Resources",
    "comment" : "\n     * Returns a Resources instance for the application's package.\n     * <p>\n     * <strong>Note:</strong> Implementations of this method should return\n     * a Resources instance that is consistent with the AssetManager instance\n     * returned by {@link #getAssets()}. For example, they should share the\n     * same {@link Configuration} object.\n     *\n     * @return a Resources instance for the application's package\n     * @see #getAssets()\n     ",
    "links" : [ "#getAssets()", "android.content.res.Configuration" ]
  }, {
    "name" : "public abstract PackageManager getPackageManager()",
    "returnType" : "PackageManager",
    "comment" : " Return PackageManager instance to find global package information. ",
    "links" : [ ]
  }, {
    "name" : "public abstract ContentResolver getContentResolver()",
    "returnType" : "ContentResolver",
    "comment" : " Return a ContentResolver instance for your application's package. ",
    "links" : [ ]
  }, {
    "name" : "public abstract Looper getMainLooper()",
    "returnType" : "Looper",
    "comment" : "\n     * Return the Looper for the main thread of the current process.  This is\n     * the thread used to dispatch calls to application components (activities,\n     * services, etc).\n     * <p>\n     * By definition, this method returns the same result as would be obtained\n     * by calling {@link Looper#getMainLooper() Looper.getMainLooper()}.\n     * </p>\n     *\n     * @return The main looper.\n     ",
    "links" : [ "android.os.Looper#getMainLooper()" ]
  }, {
    "name" : "public Executor getMainExecutor()",
    "returnType" : "Executor",
    "comment" : "\n     * Return an {@link Executor} that will run enqueued tasks on the main\n     * thread associated with this context. This is the thread used to dispatch\n     * calls to application components (activities, services, etc).\n     ",
    "links" : [ "android.annotation.CallbackExecutor" ]
  }, {
    "name" : "public abstract Context getApplicationContext()",
    "returnType" : "Context",
    "comment" : "\n     * Return the context of the single, global Application object of the\n     * current process.  This generally should only be used if you need a\n     * Context whose lifecycle is separate from the current context, that is\n     * tied to the lifetime of the process rather than the current component.\n     *\n     * <p>Consider for example how this interacts with\n     * {@link #registerReceiver(BroadcastReceiver, IntentFilter)}:\n     * <ul>\n     * <li> <p>If used from an Activity context, the receiver is being registered\n     * within that activity.  This means that you are expected to unregister\n     * before the activity is done being destroyed; in fact if you do not do\n     * so, the framework will clean up your leaked registration as it removes\n     * the activity and log an error.  Thus, if you use the Activity context\n     * to register a receiver that is static (global to the process, not\n     * associated with an Activity instance) then that registration will be\n     * removed on you at whatever point the activity you used is destroyed.\n     * <li> <p>If used from the Context returned here, the receiver is being\n     * registered with the global state associated with your application.  Thus\n     * it will never be unregistered for you.  This is necessary if the receiver\n     * is associated with static data, not a particular component.  However\n     * using the ApplicationContext elsewhere can easily lead to serious leaks\n     * if you forget to unregister, unbind, etc.\n     * </ul>\n     ",
    "links" : [ "#registerReceiver(BroadcastReceiver" ]
  }, {
    "name" : "public int getNextAutofillId()",
    "returnType" : "int",
    "comment" : "\n     * Gets the next autofill ID.\n     *\n     * <p>All IDs will be smaller or the same as {@link View#LAST_APP_AUTOFILL_ID}. All IDs\n     * returned will be unique.\n     *\n     * @return A ID that is unique in the process\n     *\n     * {@hide}\n     ",
    "links" : [ "android.view.View#LAST_APP_AUTOFILL_ID" ]
  }, {
    "name" : "public void registerComponentCallbacks(ComponentCallbacks callback)",
    "returnType" : "void",
    "comment" : "\n     * Add a new {@link ComponentCallbacks} to the base application of the\n     * Context, which will be called at the same times as the ComponentCallbacks\n     * methods of activities and other components are called. Note that you\n     * <em>must</em> be sure to use {@link #unregisterComponentCallbacks} when\n     * appropriate in the future; this will not be removed for you.\n     * <p>\n     * After {@link Build.VERSION_CODES#S}, registering the ComponentCallbacks to Context created\n     * via {@link #createWindowContext(int, Bundle)} or\n     * {@link #createWindowContext(Display, int, Bundle)} will receive\n     * {@link ComponentCallbacks#onConfigurationChanged(Configuration)} from Window Context rather\n     * than its base application. It is helpful if you want to handle UI components that\n     * associated with the Window Context when the Window Context has configuration changes.</p>\n     * <p>\n     * After {@link Build.VERSION_CODES#TIRAMISU}, registering the ComponentCallbacks to\n     * {@link Activity} context will receive\n     * {@link ComponentCallbacks#onConfigurationChanged(Configuration)} from\n     * {@link Activity#onConfigurationChanged(Configuration)} rather than its base application.</p>\n     * <p>\n     * After {@link Build.VERSION_CODES#UPSIDE_DOWN_CAKE}, registering the ComponentCallbacks to\n     * {@link android.inputmethodservice.InputMethodService} will receive\n     * {@link ComponentCallbacks#onConfigurationChanged(Configuration)} from InputmethodService\n     * rather than its base application. It is helpful if you want to handle UI components when the\n     * IME has configuration changes.</p>\n     *\n     * @param callback The interface to call.  This can be either a\n     * {@link ComponentCallbacks} or {@link ComponentCallbacks2} interface.\n     *\n     * @see Context#createWindowContext(int, Bundle)\n     ",
    "links" : [ "android.content.ComponentCallbacks2", "Build.VERSION_CODES#S", "#unregisterComponentCallbacks", "Build.VERSION_CODES#TIRAMISU", "#createWindowContext(int", "android.content.ComponentCallbacks#onConfigurationChanged(Configuration)", "android.content.ComponentCallbacks", "#createWindowContext(Display", "Build.VERSION_CODES#UPSIDE_DOWN_CAKE", "android.inputmethodservice.InputMethodService", "android.app.Activity", "android.app.Activity#onConfigurationChanged(Configuration)" ]
  }, {
    "name" : "public void unregisterComponentCallbacks(ComponentCallbacks callback)",
    "returnType" : "void",
    "comment" : "\n     * Remove a {@link ComponentCallbacks} object that was previously registered\n     * with {@link #registerComponentCallbacks(ComponentCallbacks)}.\n     ",
    "links" : [ "#registerComponentCallbacks(ComponentCallbacks)", "android.content.ComponentCallbacks" ]
  }, {
    "name" : "public final CharSequence getText(@StringRes int resId)",
    "returnType" : "CharSequence",
    "comment" : "\n     * Return a localized, styled CharSequence from the application's package's\n     * default string table.\n     *\n     * @param resId Resource id for the CharSequence text\n     ",
    "links" : [ ]
  }, {
    "name" : "public final String getString(@StringRes int resId)",
    "returnType" : "String",
    "comment" : "\n     * Returns a localized string from the application's package's\n     * default string table.\n     *\n     * @param resId Resource id for the string\n     * @return The string data associated with the resource, stripped of styled\n     *         text information.\n     ",
    "links" : [ ]
  }, {
    "name" : "public final String getString(@StringRes int resId, Object... formatArgs)",
    "returnType" : "String",
    "comment" : "\n     * Returns a localized formatted string from the application's package's\n     * default string table, substituting the format arguments as defined in\n     * {@link java.util.Formatter} and {@link java.lang.String#format}.\n     *\n     * @param resId Resource id for the format string\n     * @param formatArgs The format arguments that will be used for\n     *                   substitution.\n     * @return The string data associated with the resource, formatted and\n     *         stripped of styled text information.\n     ",
    "links" : [ "java.lang.String#format", "java.util.Formatter" ]
  }, {
    "name" : "public final int getColor(@ColorRes int id)",
    "returnType" : "int",
    "comment" : "\n     * Returns a color associated with a particular resource ID and styled for\n     * the current theme.\n     *\n     * @param id The desired resource identifier, as generated by the aapt\n     *           tool. This integer encodes the package, type, and resource\n     *           entry. The value 0 is an invalid identifier.\n     * @return A single color value in the form 0xAARRGGBB.\n     * @throws android.content.res.Resources.NotFoundException if the given ID\n     *         does not exist.\n     ",
    "links" : [ ]
  }, {
    "name" : "public final Drawable getDrawable(@DrawableRes int id)",
    "returnType" : "Drawable",
    "comment" : "\n     * Returns a drawable object associated with a particular resource ID and\n     * styled for the current theme.\n     *\n     * @param id The desired resource identifier, as generated by the aapt\n     *           tool. This integer encodes the package, type, and resource\n     *           entry. The value 0 is an invalid identifier.\n     * @return An object that can be used to draw this resource.\n     * @throws android.content.res.Resources.NotFoundException if the given ID\n     *         does not exist.\n     ",
    "links" : [ ]
  }, {
    "name" : "public final ColorStateList getColorStateList(@ColorRes int id)",
    "returnType" : "ColorStateList",
    "comment" : "\n     * Returns a color state list associated with a particular resource ID and\n     * styled for the current theme.\n     *\n     * @param id The desired resource identifier, as generated by the aapt\n     *           tool. This integer encodes the package, type, and resource\n     *           entry. The value 0 is an invalid identifier.\n     * @return A color state list.\n     * @throws android.content.res.Resources.NotFoundException if the given ID\n     *         does not exist.\n     ",
    "links" : [ ]
  }, {
    "name" : "public abstract void setTheme(@StyleRes int resid)",
    "returnType" : "void",
    "comment" : "\n     * Set the base theme for this context.  Note that this should be called\n     * before any views are instantiated in the Context (for example before\n     * calling {@link android.app.Activity#setContentView} or\n     * {@link android.view.LayoutInflater#inflate}).\n     *\n     * @param resid The style resource describing the theme.\n     ",
    "links" : [ "android.view.LayoutInflater#inflate", "android.app.Activity#setContentView" ]
  }, {
    "name" : "public int getThemeResId()",
    "returnType" : "int",
    "comment" : " @hide Needed for some internal implementation...  not public because\n     * you can't assume this actually means anything. ",
    "links" : [ ]
  }, {
    "name" : "public abstract Resources.Theme getTheme()",
    "returnType" : "Resources.Theme",
    "comment" : "\n     * Return the Theme object associated with this Context.\n     ",
    "links" : [ ]
  }, {
    "name" : "public final TypedArray obtainStyledAttributes(@NonNull @StyleableRes int[] attrs)",
    "returnType" : "TypedArray",
    "comment" : "\n     * Retrieve styled attribute information in this Context's theme.  See\n     * {@link android.content.res.Resources.Theme#obtainStyledAttributes(int[])}\n     * for more information.\n     *\n     * @see android.content.res.Resources.Theme#obtainStyledAttributes(int[])\n     ",
    "links" : [ "android.content.res.Resources.Theme#obtainStyledAttributes(int" ]
  }, {
    "name" : "public final TypedArray obtainStyledAttributes(@StyleRes int resid, @NonNull @StyleableRes int[] attrs) throws Resources.NotFoundException",
    "returnType" : "TypedArray",
    "comment" : "\n     * Retrieve styled attribute information in this Context's theme.  See\n     * {@link android.content.res.Resources.Theme#obtainStyledAttributes(int, int[])}\n     * for more information.\n     *\n     * @see android.content.res.Resources.Theme#obtainStyledAttributes(int, int[])\n     ",
    "links" : [ "android.content.res.Resources.Theme#obtainStyledAttributes(int" ]
  }, {
    "name" : "public final TypedArray obtainStyledAttributes(@Nullable AttributeSet set, @NonNull @StyleableRes int[] attrs)",
    "returnType" : "TypedArray",
    "comment" : "\n     * Retrieve styled attribute information in this Context's theme.  See\n     * {@link android.content.res.Resources.Theme#obtainStyledAttributes(AttributeSet, int[], int, int)}\n     * for more information.\n     *\n     * @see android.content.res.Resources.Theme#obtainStyledAttributes(AttributeSet, int[], int, int)\n     ",
    "links" : [ "android.content.res.Resources.Theme#obtainStyledAttributes(AttributeSet" ]
  }, {
    "name" : "public final TypedArray obtainStyledAttributes(@Nullable AttributeSet set, @NonNull @StyleableRes int[] attrs, @AttrRes int defStyleAttr, @StyleRes int defStyleRes)",
    "returnType" : "TypedArray",
    "comment" : "\n     * Retrieve styled attribute information in this Context's theme.  See\n     * {@link android.content.res.Resources.Theme#obtainStyledAttributes(AttributeSet, int[], int, int)}\n     * for more information.\n     *\n     * @see android.content.res.Resources.Theme#obtainStyledAttributes(AttributeSet, int[], int, int)\n     ",
    "links" : [ "android.content.res.Resources.Theme#obtainStyledAttributes(AttributeSet" ]
  }, {
    "name" : "public abstract ClassLoader getClassLoader()",
    "returnType" : "ClassLoader",
    "comment" : "\n     * Return a class loader you can use to retrieve classes in this package.\n     ",
    "links" : [ ]
  }, {
    "name" : "public abstract String getPackageName()",
    "returnType" : "String",
    "comment" : " Return the name of this application's package. ",
    "links" : [ ]
  }, {
    "name" : "public abstract String getBasePackageName()",
    "returnType" : "String",
    "comment" : "\n     * @hide Return the name of the base context this context is derived from.\n     * This is the same as {@link #getOpPackageName()} except in\n     * cases where system components are loaded into other app processes, in which\n     * case {@link #getOpPackageName()} will be the name of the primary package in\n     * that process (so that app ops uid verification will work with the name).\n     ",
    "links" : [ "#getOpPackageName()" ]
  }, {
    "name" : "public String getOpPackageName()",
    "returnType" : "String",
    "comment" : "\n     * Return the package name that should be used for {@link android.app.AppOpsManager} calls from\n     * this context, so that app ops manager's uid verification will work with the name.\n     * <p>\n     * This is not generally intended for third party application developers.\n     ",
    "links" : [ "android.app.AppOpsManager" ]
  }, {
    "name" : "public String getAttributionTag()",
    "returnType" : "String",
    "comment" : "\n     * <p>Attribution can be used in complex apps to logically separate parts of the app. E.g. a\n     * blogging app might also have a instant messaging app built in. In this case two separate tags\n     * can for used each sub-feature.\n     *\n     * @return the attribution tag this context is for or {@code null} if this is the default.\n     ",
    "links" : [ ]
  }, {
    "name" : "public AttributionSource getAttributionSource()",
    "returnType" : "AttributionSource",
    "comment" : "\n     * @return The identity of this context for permission purposes.\n     *\n     * @see AttributionSource\n     ",
    "links" : [ ]
  }, {
    "name" : "public String getFeatureId()",
    "returnType" : "String",
    "comment" : "\n     * @removed\n     ",
    "links" : [ ]
  }, {
    "name" : "public ContextParams getParams()",
    "returnType" : "ContextParams",
    "comment" : "\n     * Return the set of parameters which this Context was created with, if it\n     * was created via {@link #createContext(ContextParams)}.\n     ",
    "links" : [ "#createContext(ContextParams)" ]
  }, {
    "name" : "public abstract ApplicationInfo getApplicationInfo()",
    "returnType" : "ApplicationInfo",
    "comment" : " Return the full application info for this context's package. ",
    "links" : [ ]
  }, {
    "name" : "public abstract String getPackageResourcePath()",
    "returnType" : "String",
    "comment" : "\n     * Return the full path to this context's primary Android package.\n     * The Android package is a ZIP file which contains the application's\n     * primary resources.\n     *\n     * <p>Note: this is not generally useful for applications, since they should\n     * not be directly accessing the file system.\n     *\n     * @return String Path to the resources.\n     ",
    "links" : [ ]
  }, {
    "name" : "public abstract String getPackageCodePath()",
    "returnType" : "String",
    "comment" : "\n     * Return the full path to this context's primary Android package.\n     * The Android package is a ZIP file which contains application's\n     * primary code and assets.\n     *\n     * <p>Note: this is not generally useful for applications, since they should\n     * not be directly accessing the file system.\n     *\n     * @return String Path to the code and assets.\n     ",
    "links" : [ ]
  }, {
    "name" : "public File getSharedPrefsFile(String name)",
    "returnType" : "File",
    "comment" : "\n     * @hide\n     * @deprecated use {@link #getSharedPreferencesPath(String)}\n     ",
    "links" : [ "#getSharedPreferencesPath(String)" ]
  }, {
    "name" : "public abstract SharedPreferences getSharedPreferences(String name, @PreferencesMode int mode)",
    "returnType" : "SharedPreferences",
    "comment" : "\n     * Retrieve and hold the contents of the preferences file 'name', returning\n     * a SharedPreferences through which you can retrieve and modify its\n     * values.  Only one instance of the SharedPreferences object is returned\n     * to any callers for the same name, meaning they will see each other's\n     * edits as soon as they are made.\n     *\n     * <p>This method is thread-safe.\n     *\n     * <p>If the preferences directory does not already exist, it will be created when this method\n     * is called.\n     *\n     * <p>If a preferences file by this name does not exist, it will be created when you retrieve an\n     * editor ({@link SharedPreferences#edit()}) and then commit changes ({@link\n     * SharedPreferences.Editor#commit()} or {@link SharedPreferences.Editor#apply()}).\n     *\n     * @param name Desired preferences file.\n     * @param mode Operating mode.\n     *\n     * @return The single {@link SharedPreferences} instance that can be used\n     *         to retrieve and modify the preference values.\n     *\n     * @see #MODE_PRIVATE\n     ",
    "links" : [ "SharedPreferences.Editor#commit()", "android.content.SharedPreferences", "android.content.SharedPreferences#edit()", "SharedPreferences.Editor#apply()" ]
  }, {
    "name" : "public abstract SharedPreferences getSharedPreferences(File file, @PreferencesMode int mode)",
    "returnType" : "SharedPreferences",
    "comment" : "\n     * Retrieve and hold the contents of the preferences file, returning\n     * a SharedPreferences through which you can retrieve and modify its\n     * values.  Only one instance of the SharedPreferences object is returned\n     * to any callers for the same name, meaning they will see each other's\n     * edits as soon as they are made.\n     *\n     * @param file Desired preferences file. If a preferences file by this name\n     * does not exist, it will be created when you retrieve an\n     * editor (SharedPreferences.edit()) and then commit changes (Editor.commit()).\n     * @param mode Operating mode.\n     *\n     * @return The single {@link SharedPreferences} instance that can be used\n     *         to retrieve and modify the preference values.\n     *\n     * @see #getSharedPreferencesPath(String)\n     * @see #MODE_PRIVATE\n     * @removed\n     ",
    "links" : [ "android.content.SharedPreferences" ]
  }, {
    "name" : "public abstract boolean moveSharedPreferencesFrom(Context sourceContext, String name)",
    "returnType" : "boolean",
    "comment" : "\n     * Move an existing shared preferences file from the given source storage\n     * context to this context. This is typically used to migrate data between\n     * storage locations after an upgrade, such as moving to device protected\n     * storage.\n     *\n     * @param sourceContext The source context which contains the existing\n     *            shared preferences to move.\n     * @param name The name of the shared preferences file.\n     * @return {@code true} if the move was successful or if the shared\n     *         preferences didn't exist in the source context, otherwise\n     *         {@code false}.\n     * @see #createDeviceProtectedStorageContext()\n     ",
    "links" : [ ]
  }, {
    "name" : "public abstract boolean deleteSharedPreferences(String name)",
    "returnType" : "boolean",
    "comment" : "\n     * Delete an existing shared preferences file.\n     *\n     * @param name The name (unique in the application package) of the shared\n     *            preferences file.\n     * @return {@code true} if the shared preferences file was successfully\n     *         deleted; else {@code false}.\n     * @see #getSharedPreferences(String, int)\n     ",
    "links" : [ ]
  }, {
    "name" : "public abstract void reloadSharedPreferences()",
    "returnType" : "void",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "public abstract FileInputStream openFileInput(String name) throws FileNotFoundException",
    "returnType" : "FileInputStream",
    "comment" : "\n     * Open a private file associated with this Context's application package\n     * for reading.\n     *\n     * @param name The name of the file to open; can not contain path\n     *             separators.\n     *\n     * @return The resulting {@link FileInputStream}.\n     *\n     * @see #openFileOutput\n     * @see #fileList\n     * @see #deleteFile\n     * @see java.io.FileInputStream#FileInputStream(String)\n     ",
    "links" : [ "java.io.FileInputStream" ]
  }, {
    "name" : "public abstract FileOutputStream openFileOutput(String name, @FileMode int mode) throws FileNotFoundException",
    "returnType" : "FileOutputStream",
    "comment" : "\n     * Open a private file associated with this Context's application package\n     * for writing. Creates the file if it doesn't already exist.\n     * <p>\n     * No additional permissions are required for the calling app to read or\n     * write the returned file.\n     *\n     * @param name The name of the file to open; can not contain path\n     *            separators.\n     * @param mode Operating mode.\n     * @return The resulting {@link FileOutputStream}.\n     * @see #MODE_APPEND\n     * @see #MODE_PRIVATE\n     * @see #openFileInput\n     * @see #fileList\n     * @see #deleteFile\n     * @see java.io.FileOutputStream#FileOutputStream(String)\n     ",
    "links" : [ "java.io.FileOutputStream" ]
  }, {
    "name" : "public abstract boolean deleteFile(String name)",
    "returnType" : "boolean",
    "comment" : "\n     * Delete the given private file associated with this Context's\n     * application package.\n     *\n     * @param name The name of the file to delete; can not contain path\n     *             separators.\n     *\n     * @return {@code true} if the file was successfully deleted; else\n     *         {@code false}.\n     *\n     * @see #openFileInput\n     * @see #openFileOutput\n     * @see #fileList\n     * @see java.io.File#delete()\n     ",
    "links" : [ ]
  }, {
    "name" : "public abstract File getFileStreamPath(String name)",
    "returnType" : "File",
    "comment" : "\n     * Returns the absolute path on the filesystem where a file created with\n     * {@link #openFileOutput} is stored.\n     * <p>\n     * The returned path may change over time if the calling app is moved to an\n     * adopted storage device, so only relative paths should be persisted.\n     *\n     * @param name The name of the file for which you would like to get\n     *          its path.\n     *\n     * @return An absolute path to the given file.\n     *\n     * @see #openFileOutput\n     * @see #getFilesDir\n     * @see #getDir\n     ",
    "links" : [ "#openFileOutput" ]
  }, {
    "name" : "public abstract File getSharedPreferencesPath(String name)",
    "returnType" : "File",
    "comment" : "\n     * Returns the absolute path on the filesystem where a file created with\n     * {@link #getSharedPreferences(String, int)} is stored.\n     * <p>\n     * The returned path may change over time if the calling app is moved to an\n     * adopted storage device, so only relative paths should be persisted.\n     *\n     * @param name The name of the shared preferences for which you would like\n     *            to get a path.\n     * @return An absolute path to the given file.\n     * @see #getSharedPreferences(String, int)\n     * @removed\n     ",
    "links" : [ "#getSharedPreferences(String" ]
  }, {
    "name" : "public abstract File getDataDir()",
    "returnType" : "File",
    "comment" : "\n     * Returns the absolute path to the directory on the filesystem where all\n     * private files belonging to this app are stored. Apps should not use this\n     * path directly; they should instead use {@link #getFilesDir()},\n     * {@link #getCacheDir()}, {@link #getDir(String, int)}, or other storage\n     * APIs on this class.\n     * <p>\n     * The returned path may change over time if the calling app is moved to an\n     * adopted storage device, so only relative paths should be persisted.\n     * <p>\n     * No additional permissions are required for the calling app to read or\n     * write files under the returned path.\n     *\n     * @see ApplicationInfo#dataDir\n     ",
    "links" : [ "#getDir(String", "#getCacheDir()", "#getFilesDir()" ]
  }, {
    "name" : "public abstract File getFilesDir()",
    "returnType" : "File",
    "comment" : "\n     * Returns the absolute path to the directory on the filesystem where files\n     * created with {@link #openFileOutput} are stored.\n     * <p>\n     * The returned path may change over time if the calling app is moved to an\n     * adopted storage device, so only relative paths should be persisted.\n     * <p>\n     * No additional permissions are required for the calling app to read or\n     * write files under the returned path.\n     *\n     * @return The path of the directory holding application files.\n     * @see #openFileOutput\n     * @see #getFileStreamPath\n     * @see #getDir\n     ",
    "links" : [ "#openFileOutput" ]
  }, {
    "name" : "public File getCrateDir(@NonNull String crateId)",
    "returnType" : "File",
    "comment" : "\n     * Returns the absolute path to the directory that is related to the crate on the filesystem.\n     * <p>\n     *     The crateId require a validated file name. It can't contain any \"..\", \".\",\n     *     {@link File#separatorChar} etc..\n     * </p>\n     * <p>\n     * The returned path may change over time if the calling app is moved to an\n     * adopted storage device, so only relative paths should be persisted.\n     * </p>\n     * <p>\n     * No additional permissions are required for the calling app to read or\n     * write files under the returned path.\n     *</p>\n     *\n     * @param crateId the relative validated file name under {@link Context#getDataDir()}/crates\n     * @return the crate directory file.\n     * @hide\n     ",
    "links" : [ "android.annotation.DisplayContext#getDataDir()", "java.io.File#separatorChar" ]
  }, {
    "name" : "public abstract File getNoBackupFilesDir()",
    "returnType" : "File",
    "comment" : "\n     * Returns the absolute path to the directory on the filesystem similar to\n     * {@link #getFilesDir()}. The difference is that files placed under this\n     * directory will be excluded from automatic backup to remote storage. See\n     * {@link android.app.backup.BackupAgent BackupAgent} for a full discussion\n     * of the automatic backup mechanism in Android.\n     * <p>\n     * The returned path may change over time if the calling app is moved to an\n     * adopted storage device, so only relative paths should be persisted.\n     * <p>\n     * No additional permissions are required for the calling app to read or\n     * write files under the returned path.\n     *\n     * @return The path of the directory holding application files that will not\n     *         be automatically backed up to remote storage.\n     * @see #openFileOutput\n     * @see #getFileStreamPath\n     * @see #getDir\n     * @see android.app.backup.BackupAgent\n     ",
    "links" : [ "#getFilesDir()", "android.app.backup.BackupAgent" ]
  }, {
    "name" : "public abstract File getExternalFilesDir(@Nullable String type)",
    "returnType" : "File",
    "comment" : "\n     * Returns the absolute path to the directory on the primary shared/external\n     * storage device where the application can place persistent files it owns.\n     * These files are internal to the applications, and not typically visible\n     * to the user as media.\n     * <p>\n     * This is like {@link #getFilesDir()} in that these files will be deleted\n     * when the application is uninstalled, however there are some important\n     * differences:\n     * <ul>\n     * <li>Shared storage may not always be available, since removable media can\n     * be ejected by the user. Media state can be checked using\n     * {@link Environment#getExternalStorageState(File)}.\n     * <li>There is no security enforced with these files. For example, any\n     * application holding\n     * {@link android.Manifest.permission#WRITE_EXTERNAL_STORAGE} can write to\n     * these files.\n     * </ul>\n     * <p>\n     * If a shared storage device is emulated (as determined by\n     * {@link Environment#isExternalStorageEmulated(File)}), its contents are\n     * backed by a private user data partition, which means there is little\n     * benefit to storing data here instead of the private directories returned\n     * by {@link #getFilesDir()}, etc.\n     * <p>\n     * Starting in {@link android.os.Build.VERSION_CODES#KITKAT}, no permissions\n     * are required to read or write to the returned path; it's always\n     * accessible to the calling app. This only applies to paths generated for\n     * package name of the calling application. To access paths belonging to\n     * other packages,\n     * {@link android.Manifest.permission#WRITE_EXTERNAL_STORAGE} and/or\n     * {@link android.Manifest.permission#READ_EXTERNAL_STORAGE} are required.\n     * <p>\n     * On devices with multiple users (as described by {@link UserManager}),\n     * each user has their own isolated shared storage. Applications only have\n     * access to the shared storage for the user they're running as.\n     * <p>\n     * The returned path may change over time if different shared storage media\n     * is inserted, so only relative paths should be persisted.\n     * <p>\n     * Here is an example of typical code to manipulate a file in an\n     * application's shared storage:\n     * </p>\n     * {@sample development/samples/ApiDemos/src/com/example/android/apis/content/ExternalStorage.java\n     * private_file}\n     * <p>\n     * If you supply a non-null <var>type</var> to this function, the returned\n     * file will be a path to a sub-directory of the given type. Though these\n     * files are not automatically scanned by the media scanner, you can\n     * explicitly add them to the media database with\n     * {@link android.media.MediaScannerConnection#scanFile(Context, String[], String[], android.media.MediaScannerConnection.OnScanCompletedListener)\n     * MediaScannerConnection.scanFile}. Note that this is not the same as\n     * {@link android.os.Environment#getExternalStoragePublicDirectory\n     * Environment.getExternalStoragePublicDirectory()}, which provides\n     * directories of media shared by all applications. The directories returned\n     * here are owned by the application, and their contents will be removed\n     * when the application is uninstalled. Unlike\n     * {@link android.os.Environment#getExternalStoragePublicDirectory\n     * Environment.getExternalStoragePublicDirectory()}, the directory returned\n     * here will be automatically created for you.\n     * <p>\n     * Here is an example of typical code to manipulate a picture in an\n     * application's shared storage and add it to the media database:\n     * </p>\n     * {@sample development/samples/ApiDemos/src/com/example/android/apis/content/ExternalStorage.java\n     * private_picture}\n     *\n     * @param type The type of files directory to return. May be {@code null}\n     *            for the root of the files directory or one of the following\n     *            constants for a subdirectory:\n     *            {@link android.os.Environment#DIRECTORY_MUSIC},\n     *            {@link android.os.Environment#DIRECTORY_PODCASTS},\n     *            {@link android.os.Environment#DIRECTORY_RINGTONES},\n     *            {@link android.os.Environment#DIRECTORY_ALARMS},\n     *            {@link android.os.Environment#DIRECTORY_NOTIFICATIONS},\n     *            {@link android.os.Environment#DIRECTORY_PICTURES}, or\n     *            {@link android.os.Environment#DIRECTORY_MOVIES}.\n     * @return the absolute path to application-specific directory. May return\n     *         {@code null} if shared storage is not currently available.\n     * @see #getFilesDir\n     * @see #getExternalFilesDirs(String)\n     * @see Environment#getExternalStorageState(File)\n     * @see Environment#isExternalStorageEmulated(File)\n     * @see Environment#isExternalStorageRemovable(File)\n     ",
    "links" : [ "android.os.UserManager", "#getFilesDir()", "android.os.Environment#DIRECTORY_PICTURES", "android.os.Environment#getExternalStorageState(File)", "android.os.Environment#DIRECTORY_NOTIFICATIONS", "android.os.Build.VERSION_CODES#KITKAT", "android.media.MediaScannerConnection#scanFile(Context", "android.os.Environment#DIRECTORY_MOVIES", "android.os.Environment#DIRECTORY_MUSIC", "android.Manifest.permission#WRITE_EXTERNAL_STORAGE", "android.os.Environment#isExternalStorageEmulated(File)", "android.os.Environment#getExternalStoragePublicDirectoryEnvironment.getExternalStoragePublicDirectory()", "android.Manifest.permission#READ_EXTERNAL_STORAGE", "android.os.Environment#DIRECTORY_RINGTONES", "android.os.Environment#DIRECTORY_PODCASTS", "android.os.Environment#DIRECTORY_ALARMS" ]
  }, {
    "name" : "public abstract File[] getExternalFilesDirs(String type)",
    "returnType" : "File[]",
    "comment" : "\n     * Returns absolute paths to application-specific directories on all\n     * shared/external storage devices where the application can place\n     * persistent files it owns. These files are internal to the application,\n     * and not typically visible to the user as media.\n     * <p>\n     * This is like {@link #getFilesDir()} in that these files will be deleted\n     * when the application is uninstalled, however there are some important\n     * differences:\n     * <ul>\n     * <li>Shared storage may not always be available, since removable media can\n     * be ejected by the user. Media state can be checked using\n     * {@link Environment#getExternalStorageState(File)}.\n     * <li>There is no security enforced with these files. For example, any\n     * application holding\n     * {@link android.Manifest.permission#WRITE_EXTERNAL_STORAGE} can write to\n     * these files.\n     * </ul>\n     * <p>\n     * If a shared storage device is emulated (as determined by\n     * {@link Environment#isExternalStorageEmulated(File)}), its contents are\n     * backed by a private user data partition, which means there is little\n     * benefit to storing data here instead of the private directories returned\n     * by {@link #getFilesDir()}, etc.\n     * <p>\n     * Shared storage devices returned here are considered a stable part of the\n     * device, including physical media slots under a protective cover. The\n     * returned paths do not include transient devices, such as USB flash drives\n     * connected to handheld devices.\n     * <p>\n     * An application may store data on any or all of the returned devices. For\n     * example, an app may choose to store large files on the device with the\n     * most available space, as measured by {@link StatFs}.\n     * <p>\n     * No additional permissions are required for the calling app to read or\n     * write files under the returned path. Write access outside of these paths\n     * on secondary external storage devices is not available.\n     * <p>\n     * The returned path may change over time if different shared storage media\n     * is inserted, so only relative paths should be persisted.\n     *\n     * @param type The type of files directory to return. May be {@code null}\n     *            for the root of the files directory or one of the following\n     *            constants for a subdirectory:\n     *            {@link android.os.Environment#DIRECTORY_MUSIC},\n     *            {@link android.os.Environment#DIRECTORY_PODCASTS},\n     *            {@link android.os.Environment#DIRECTORY_RINGTONES},\n     *            {@link android.os.Environment#DIRECTORY_ALARMS},\n     *            {@link android.os.Environment#DIRECTORY_NOTIFICATIONS},\n     *            {@link android.os.Environment#DIRECTORY_PICTURES}, or\n     *            {@link android.os.Environment#DIRECTORY_MOVIES}.\n     * @return the absolute paths to application-specific directories. Some\n     *         individual paths may be {@code null} if that shared storage is\n     *         not currently available. The first path returned is the same as\n     *         {@link #getExternalFilesDir(String)}.\n     * @see #getExternalFilesDir(String)\n     * @see Environment#getExternalStorageState(File)\n     * @see Environment#isExternalStorageEmulated(File)\n     * @see Environment#isExternalStorageRemovable(File)\n     ",
    "links" : [ "#getFilesDir()", "android.os.Environment#DIRECTORY_PICTURES", "android.os.Environment#getExternalStorageState(File)", "android.os.Environment#DIRECTORY_NOTIFICATIONS", "#getExternalFilesDir(String)", "android.os.Environment#DIRECTORY_MOVIES", "android.os.Environment#DIRECTORY_MUSIC", "android.Manifest.permission#WRITE_EXTERNAL_STORAGE", "android.os.Environment#isExternalStorageEmulated(File)", "android.os.StatFs", "android.os.Environment#DIRECTORY_RINGTONES", "android.os.Environment#DIRECTORY_PODCASTS", "android.os.Environment#DIRECTORY_ALARMS" ]
  }, {
    "name" : "public abstract File getObbDir()",
    "returnType" : "File",
    "comment" : "\n     * Return the primary shared/external storage directory where this\n     * application's OBB files (if there are any) can be found. Note if the\n     * application does not have any OBB files, this directory may not exist.\n     * <p>\n     * This is like {@link #getFilesDir()} in that these files will be deleted\n     * when the application is uninstalled, however there are some important\n     * differences:\n     * <ul>\n     * <li>Shared storage may not always be available, since removable media can\n     * be ejected by the user. Media state can be checked using\n     * {@link Environment#getExternalStorageState(File)}.\n     * <li>There is no security enforced with these files. For example, any\n     * application holding\n     * {@link android.Manifest.permission#WRITE_EXTERNAL_STORAGE} can write to\n     * these files.\n     * </ul>\n     * <p>\n     * Starting in {@link android.os.Build.VERSION_CODES#KITKAT}, no permissions\n     * are required to read or write to the path that this method returns.\n     * However, starting from {@link android.os.Build.VERSION_CODES#M},\n     * to read the OBB expansion files, you must declare the\n     * {@link android.Manifest.permission#READ_EXTERNAL_STORAGE} permission in the app manifest and ask for\n     * permission at runtime as follows:\n     * </p>\n     * <p>\n     * {@code <uses-permission android:name=\"android.permission.READ_EXTERNAL_STORAGE\"\n     * android:maxSdkVersion=\"23\" />}\n     * </p>\n     * <p>\n     * Starting from {@link android.os.Build.VERSION_CODES#N},\n     * {@link android.Manifest.permission#READ_EXTERNAL_STORAGE}\n     * permission is not required, so dont ask for this\n     * permission at runtime. To handle both cases, your app must first try to read the OBB file,\n     * and if it fails, you must request\n     * {@link android.Manifest.permission#READ_EXTERNAL_STORAGE} permission at runtime.\n     * </p>\n     *\n     * <p>\n     * The following code snippet shows how to do this:\n     * </p>\n     *\n     * <pre>\n     * File obb = new File(obb_filename);\n     * boolean open_failed = false;\n     *\n     * try {\n     *     BufferedReader br = new BufferedReader(new FileReader(obb));\n     *     open_failed = false;\n     *     ReadObbFile(br);\n     * } catch (IOException e) {\n     *     open_failed = true;\n     * }\n     *\n     * if (open_failed) {\n     *     // request READ_EXTERNAL_STORAGE permission before reading OBB file\n     *     ReadObbFileWithPermission();\n     * }\n     * </pre>\n     *\n     * On devices with multiple users (as described by {@link UserManager}),\n     * multiple users may share the same OBB storage location. Applications\n     * should ensure that multiple instances running under different users don't\n     * interfere with each other.\n     *\n     * @return the absolute path to application-specific directory. May return\n     *         {@code null} if shared storage is not currently available.\n     * @see #getObbDirs()\n     * @see Environment#getExternalStorageState(File)\n     * @see Environment#isExternalStorageEmulated(File)\n     * @see Environment#isExternalStorageRemovable(File)\n     ",
    "links" : [ "android.os.UserManager", "android.Manifest.permission#WRITE_EXTERNAL_STORAGE", "#getFilesDir()", "android.Manifest.permission#READ_EXTERNAL_STORAGE", "android.os.Environment#getExternalStorageState(File)", "android.os.Build.VERSION_CODES#KITKAT", "android.os.Build.VERSION_CODES#N", "android.os.Build.VERSION_CODES#M" ]
  }, {
    "name" : "public abstract File[] getObbDirs()",
    "returnType" : "File[]",
    "comment" : "\n     * Returns absolute paths to application-specific directories on all\n     * shared/external storage devices where the application's OBB files (if\n     * there are any) can be found. Note if the application does not have any\n     * OBB files, these directories may not exist.\n     * <p>\n     * This is like {@link #getFilesDir()} in that these files will be deleted\n     * when the application is uninstalled, however there are some important\n     * differences:\n     * <ul>\n     * <li>Shared storage may not always be available, since removable media can\n     * be ejected by the user. Media state can be checked using\n     * {@link Environment#getExternalStorageState(File)}.\n     * <li>There is no security enforced with these files. For example, any\n     * application holding\n     * {@link android.Manifest.permission#WRITE_EXTERNAL_STORAGE} can write to\n     * these files.\n     * </ul>\n     * <p>\n     * Shared storage devices returned here are considered a stable part of the\n     * device, including physical media slots under a protective cover. The\n     * returned paths do not include transient devices, such as USB flash drives\n     * connected to handheld devices.\n     * <p>\n     * An application may store data on any or all of the returned devices. For\n     * example, an app may choose to store large files on the device with the\n     * most available space, as measured by {@link StatFs}.\n     * <p>\n     * No additional permissions are required for the calling app to read or\n     * write files under the returned path. Write access outside of these paths\n     * on secondary external storage devices is not available.\n     *\n     * @return the absolute paths to application-specific directories. Some\n     *         individual paths may be {@code null} if that shared storage is\n     *         not currently available. The first path returned is the same as\n     *         {@link #getObbDir()}\n     * @see #getObbDir()\n     * @see Environment#getExternalStorageState(File)\n     * @see Environment#isExternalStorageEmulated(File)\n     * @see Environment#isExternalStorageRemovable(File)\n     ",
    "links" : [ "android.Manifest.permission#WRITE_EXTERNAL_STORAGE", "android.os.StatFs", "#getObbDir()", "#getFilesDir()", "android.os.Environment#getExternalStorageState(File)" ]
  }, {
    "name" : "public abstract File getCacheDir()",
    "returnType" : "File",
    "comment" : "\n     * Returns the absolute path to the application specific cache directory on\n     * the filesystem.\n     * <p>\n     * The system will automatically delete files in this directory as disk\n     * space is needed elsewhere on the device. The system will always delete\n     * older files first, as reported by {@link File#lastModified()}. If\n     * desired, you can exert more control over how files are deleted using\n     * {@link StorageManager#setCacheBehaviorGroup(File, boolean)} and\n     * {@link StorageManager#setCacheBehaviorTombstone(File, boolean)}.\n     * <p>\n     * Apps are strongly encouraged to keep their usage of cache space below the\n     * quota returned by\n     * {@link StorageManager#getCacheQuotaBytes(java.util.UUID)}. If your app\n     * goes above this quota, your cached files will be some of the first to be\n     * deleted when additional disk space is needed. Conversely, if your app\n     * stays under this quota, your cached files will be some of the last to be\n     * deleted when additional disk space is needed.\n     * <p>\n     * Note that your cache quota will change over time depending on how\n     * frequently the user interacts with your app, and depending on how much\n     * system-wide disk space is used.\n     * <p>\n     * The returned path may change over time if the calling app is moved to an\n     * adopted storage device, so only relative paths should be persisted.\n     * <p>\n     * Apps require no extra permissions to read or write to the returned path,\n     * since this path lives in their private storage.\n     *\n     * @return The path of the directory holding application cache files.\n     * @see #openFileOutput\n     * @see #getFileStreamPath\n     * @see #getDir\n     * @see #getExternalCacheDir\n     ",
    "links" : [ "android.os.storage.StorageManager#setCacheBehaviorGroup(File", "java.io.File#lastModified()", "android.os.storage.StorageManager#getCacheQuotaBytes(java.util.UUID)", "android.os.storage.StorageManager#setCacheBehaviorTombstone(File" ]
  }, {
    "name" : "public abstract File getCodeCacheDir()",
    "returnType" : "File",
    "comment" : "\n     * Returns the absolute path to the application specific cache directory on\n     * the filesystem designed for storing cached code.\n     * <p>\n     * The system will delete any files stored in this location both when your\n     * specific application is upgraded, and when the entire platform is\n     * upgraded.\n     * <p>\n     * This location is optimal for storing compiled or optimized code generated\n     * by your application at runtime.\n     * <p>\n     * The returned path may change over time if the calling app is moved to an\n     * adopted storage device, so only relative paths should be persisted.\n     * <p>\n     * Apps require no extra permissions to read or write to the returned path,\n     * since this path lives in their private storage.\n     *\n     * @return The path of the directory holding application code cache files.\n     ",
    "links" : [ ]
  }, {
    "name" : "public abstract File getExternalCacheDir()",
    "returnType" : "File",
    "comment" : "\n     * Returns absolute path to application-specific directory on the primary\n     * shared/external storage device where the application can place cache\n     * files it owns. These files are internal to the application, and not\n     * typically visible to the user as media.\n     * <p>\n     * This is like {@link #getCacheDir()} in that these files will be deleted\n     * when the application is uninstalled, however there are some important\n     * differences:\n     * <ul>\n     * <li>The platform does not always monitor the space available in shared\n     * storage, and thus may not automatically delete these files. Apps should\n     * always manage the maximum space used in this location. Currently the only\n     * time files here will be deleted by the platform is when running on\n     * {@link android.os.Build.VERSION_CODES#JELLY_BEAN_MR1} or later and\n     * {@link Environment#isExternalStorageEmulated(File)} returns true.\n     * <li>Shared storage may not always be available, since removable media can\n     * be ejected by the user. Media state can be checked using\n     * {@link Environment#getExternalStorageState(File)}.\n     * <li>There is no security enforced with these files. For example, any\n     * application holding\n     * {@link android.Manifest.permission#WRITE_EXTERNAL_STORAGE} can write to\n     * these files.\n     * </ul>\n     * <p>\n     * If a shared storage device is emulated (as determined by\n     * {@link Environment#isExternalStorageEmulated(File)}), its contents are\n     * backed by a private user data partition, which means there is little\n     * benefit to storing data here instead of the private directory returned by\n     * {@link #getCacheDir()}.\n     * <p>\n     * Starting in {@link android.os.Build.VERSION_CODES#KITKAT}, no permissions\n     * are required to read or write to the returned path; it's always\n     * accessible to the calling app. This only applies to paths generated for\n     * package name of the calling application. To access paths belonging to\n     * other packages,\n     * {@link android.Manifest.permission#WRITE_EXTERNAL_STORAGE} and/or\n     * {@link android.Manifest.permission#READ_EXTERNAL_STORAGE} are required.\n     * <p>\n     * On devices with multiple users (as described by {@link UserManager}),\n     * each user has their own isolated shared storage. Applications only have\n     * access to the shared storage for the user they're running as.\n     * <p>\n     * The returned path may change over time if different shared storage media\n     * is inserted, so only relative paths should be persisted.\n     *\n     * @return the absolute path to application-specific directory. May return\n     *         {@code null} if shared storage is not currently available.\n     * @see #getCacheDir\n     * @see #getExternalCacheDirs()\n     * @see Environment#getExternalStorageState(File)\n     * @see Environment#isExternalStorageEmulated(File)\n     * @see Environment#isExternalStorageRemovable(File)\n     ",
    "links" : [ "android.os.Build.VERSION_CODES#JELLY_BEAN_MR1", "android.os.UserManager", "android.os.Environment#isExternalStorageEmulated(File)", "android.Manifest.permission#WRITE_EXTERNAL_STORAGE", "#getCacheDir()", "android.Manifest.permission#READ_EXTERNAL_STORAGE", "android.os.Environment#getExternalStorageState(File)", "android.os.Build.VERSION_CODES#KITKAT" ]
  }, {
    "name" : "public abstract File getPreloadsFileCache()",
    "returnType" : "File",
    "comment" : "\n     * Returns absolute path to application-specific directory in the preloaded cache.\n     * <p>Files stored in the cache directory can be deleted when the device runs low on storage.\n     * There is no guarantee when these files will be deleted.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public abstract File[] getExternalCacheDirs()",
    "returnType" : "File[]",
    "comment" : "\n     * Returns absolute paths to application-specific directories on all\n     * shared/external storage devices where the application can place cache\n     * files it owns. These files are internal to the application, and not\n     * typically visible to the user as media.\n     * <p>\n     * This is like {@link #getCacheDir()} in that these files will be deleted\n     * when the application is uninstalled, however there are some important\n     * differences:\n     * <ul>\n     * <li>The platform does not always monitor the space available in shared\n     * storage, and thus may not automatically delete these files. Apps should\n     * always manage the maximum space used in this location. Currently the only\n     * time files here will be deleted by the platform is when running on\n     * {@link android.os.Build.VERSION_CODES#JELLY_BEAN_MR1} or later and\n     * {@link Environment#isExternalStorageEmulated(File)} returns true.\n     * <li>Shared storage may not always be available, since removable media can\n     * be ejected by the user. Media state can be checked using\n     * {@link Environment#getExternalStorageState(File)}.\n     * <li>There is no security enforced with these files. For example, any\n     * application holding\n     * {@link android.Manifest.permission#WRITE_EXTERNAL_STORAGE} can write to\n     * these files.\n     * </ul>\n     * <p>\n     * If a shared storage device is emulated (as determined by\n     * {@link Environment#isExternalStorageEmulated(File)}), its contents are\n     * backed by a private user data partition, which means there is little\n     * benefit to storing data here instead of the private directory returned by\n     * {@link #getCacheDir()}.\n     * <p>\n     * Shared storage devices returned here are considered a stable part of the\n     * device, including physical media slots under a protective cover. The\n     * returned paths do not include transient devices, such as USB flash drives\n     * connected to handheld devices.\n     * <p>\n     * An application may store data on any or all of the returned devices. For\n     * example, an app may choose to store large files on the device with the\n     * most available space, as measured by {@link StatFs}.\n     * <p>\n     * No additional permissions are required for the calling app to read or\n     * write files under the returned path. Write access outside of these paths\n     * on secondary external storage devices is not available.\n     * <p>\n     * The returned paths may change over time if different shared storage media\n     * is inserted, so only relative paths should be persisted.\n     *\n     * @return the absolute paths to application-specific directories. Some\n     *         individual paths may be {@code null} if that shared storage is\n     *         not currently available. The first path returned is the same as\n     *         {@link #getExternalCacheDir()}.\n     * @see #getExternalCacheDir()\n     * @see Environment#getExternalStorageState(File)\n     * @see Environment#isExternalStorageEmulated(File)\n     * @see Environment#isExternalStorageRemovable(File)\n     ",
    "links" : [ "android.os.Build.VERSION_CODES#JELLY_BEAN_MR1", "android.os.Environment#isExternalStorageEmulated(File)", "android.Manifest.permission#WRITE_EXTERNAL_STORAGE", "android.os.StatFs", "#getCacheDir()", "android.os.Environment#getExternalStorageState(File)", "#getExternalCacheDir()" ]
  }, {
    "name" : "public abstract File[] getExternalMediaDirs()",
    "returnType" : "File[]",
    "comment" : "\n     * Returns absolute paths to application-specific directories on all\n     * shared/external storage devices where the application can place media\n     * files. These files are scanned and made available to other apps through\n     * {@link MediaStore}.\n     * <p>\n     * This is like {@link #getExternalFilesDirs} in that these files will be\n     * deleted when the application is uninstalled, however there are some\n     * important differences:\n     * <ul>\n     * <li>Shared storage may not always be available, since removable media can\n     * be ejected by the user. Media state can be checked using\n     * {@link Environment#getExternalStorageState(File)}.\n     * <li>There is no security enforced with these files. For example, any\n     * application holding\n     * {@link android.Manifest.permission#WRITE_EXTERNAL_STORAGE} can write to\n     * these files.\n     * </ul>\n     * <p>\n     * Shared storage devices returned here are considered a stable part of the\n     * device, including physical media slots under a protective cover. The\n     * returned paths do not include transient devices, such as USB flash drives\n     * connected to handheld devices.\n     * <p>\n     * An application may store data on any or all of the returned devices. For\n     * example, an app may choose to store large files on the device with the\n     * most available space, as measured by {@link StatFs}.\n     * <p>\n     * No additional permissions are required for the calling app to read or\n     * write files under the returned path. Write access outside of these paths\n     * on secondary external storage devices is not available.\n     * <p>\n     * The returned paths may change over time if different shared storage media\n     * is inserted, so only relative paths should be persisted.\n     *\n     * @return the absolute paths to application-specific directories. Some\n     *         individual paths may be {@code null} if that shared storage is\n     *         not currently available.\n     * @see Environment#getExternalStorageState(File)\n     * @see Environment#isExternalStorageEmulated(File)\n     * @see Environment#isExternalStorageRemovable(File)\n     * @deprecated These directories still exist and are scanned, but developers\n     *             are encouraged to migrate to inserting content into a\n     *             {@link MediaStore} collection directly, as any app can\n     *             contribute new media to {@link MediaStore} with no\n     *             permissions required, starting in\n     *             {@link android.os.Build.VERSION_CODES#Q}.\n     ",
    "links" : [ "android.Manifest.permission#WRITE_EXTERNAL_STORAGE", "android.os.StatFs", "android.os.Build.VERSION_CODES#Q", "android.provider.MediaStore", "android.os.Environment#getExternalStorageState(File)", "#getExternalFilesDirs" ]
  }, {
    "name" : "public abstract String[] fileList()",
    "returnType" : "String[]",
    "comment" : "\n     * Returns an array of strings naming the private files associated with\n     * this Context's application package.\n     *\n     * @return Array of strings naming the private files.\n     *\n     * @see #openFileInput\n     * @see #openFileOutput\n     * @see #deleteFile\n     ",
    "links" : [ ]
  }, {
    "name" : "public abstract File getDir(String name, @FileMode int mode)",
    "returnType" : "File",
    "comment" : "\n     * Retrieve, creating if needed, a new directory in which the application\n     * can place its own custom data files.  You can use the returned File\n     * object to create and access files in this directory.  Note that files\n     * created through a File object will only be accessible by your own\n     * application; you can only set the mode of the entire directory, not\n     * of individual files.\n     * <p>\n     * The returned path may change over time if the calling app is moved to an\n     * adopted storage device, so only relative paths should be persisted.\n     * <p>\n     * Apps require no extra permissions to read or write to the returned path,\n     * since this path lives in their private storage.\n     *\n     * @param name Name of the directory to retrieve.  This is a directory\n     * that is created as part of your application data.\n     * @param mode Operating mode.\n     *\n     * @return A {@link File} object for the requested directory.  The directory\n     * will have been created if it does not already exist.\n     *\n     * @see #openFileOutput(String, int)\n     ",
    "links" : [ "java.io.File" ]
  }, {
    "name" : "public abstract SQLiteDatabase openOrCreateDatabase(String name, @DatabaseMode int mode, CursorFactory factory)",
    "returnType" : "SQLiteDatabase",
    "comment" : "\n     * Open a new private SQLiteDatabase associated with this Context's\n     * application package. Create the database file if it doesn't exist.\n     *\n     * @param name The name (unique in the application package) of the database.\n     * @param mode Operating mode.\n     * @param factory An optional factory class that is called to instantiate a\n     *            cursor when query is called.\n     * @return The contents of a newly created database with the given name.\n     * @throws android.database.sqlite.SQLiteException if the database file\n     *             could not be opened.\n     * @see #MODE_PRIVATE\n     * @see #MODE_ENABLE_WRITE_AHEAD_LOGGING\n     * @see #MODE_NO_LOCALIZED_COLLATORS\n     * @see #deleteDatabase\n     ",
    "links" : [ ]
  }, {
    "name" : "public abstract SQLiteDatabase openOrCreateDatabase(String name, @DatabaseMode int mode, CursorFactory factory, @Nullable DatabaseErrorHandler errorHandler)",
    "returnType" : "SQLiteDatabase",
    "comment" : "\n     * Open a new private SQLiteDatabase associated with this Context's\n     * application package. Creates the database file if it doesn't exist.\n     * <p>\n     * Accepts input param: a concrete instance of {@link DatabaseErrorHandler}\n     * to be used to handle corruption when sqlite reports database corruption.\n     * </p>\n     *\n     * @param name The name (unique in the application package) of the database.\n     * @param mode Operating mode.\n     * @param factory An optional factory class that is called to instantiate a\n     *            cursor when query is called.\n     * @param errorHandler the {@link DatabaseErrorHandler} to be used when\n     *            sqlite reports database corruption. if null,\n     *            {@link android.database.DefaultDatabaseErrorHandler} is\n     *            assumed.\n     * @return The contents of a newly created database with the given name.\n     * @throws android.database.sqlite.SQLiteException if the database file\n     *             could not be opened.\n     * @see #MODE_PRIVATE\n     * @see #MODE_ENABLE_WRITE_AHEAD_LOGGING\n     * @see #MODE_NO_LOCALIZED_COLLATORS\n     * @see #deleteDatabase\n     ",
    "links" : [ "android.database.DefaultDatabaseErrorHandler", "android.database.DatabaseErrorHandler" ]
  }, {
    "name" : "public abstract boolean moveDatabaseFrom(Context sourceContext, String name)",
    "returnType" : "boolean",
    "comment" : "\n     * Move an existing database file from the given source storage context to\n     * this context. This is typically used to migrate data between storage\n     * locations after an upgrade, such as migrating to device protected\n     * storage.\n     * <p>\n     * The database must be closed before being moved.\n     *\n     * @param sourceContext The source context which contains the existing\n     *            database to move.\n     * @param name The name of the database file.\n     * @return {@code true} if the move was successful or if the database didn't\n     *         exist in the source context, otherwise {@code false}.\n     * @see #createDeviceProtectedStorageContext()\n     ",
    "links" : [ ]
  }, {
    "name" : "public abstract boolean deleteDatabase(String name)",
    "returnType" : "boolean",
    "comment" : "\n     * Delete an existing private SQLiteDatabase associated with this Context's\n     * application package.\n     *\n     * @param name The name (unique in the application package) of the\n     *             database.\n     *\n     * @return {@code true} if the database was successfully deleted; else {@code false}.\n     *\n     * @see #openOrCreateDatabase\n     ",
    "links" : [ ]
  }, {
    "name" : "public abstract File getDatabasePath(String name)",
    "returnType" : "File",
    "comment" : "\n     * Returns the absolute path on the filesystem where a database created with\n     * {@link #openOrCreateDatabase} is stored.\n     * <p>\n     * The returned path may change over time if the calling app is moved to an\n     * adopted storage device, so only relative paths should be persisted.\n     *\n     * @param name The name of the database for which you would like to get\n     *          its path.\n     *\n     * @return An absolute path to the given database.\n     *\n     * @see #openOrCreateDatabase\n     ",
    "links" : [ "#openOrCreateDatabase" ]
  }, {
    "name" : "public abstract String[] databaseList()",
    "returnType" : "String[]",
    "comment" : "\n     * Returns an array of strings naming the private databases associated with\n     * this Context's application package.\n     *\n     * @return Array of strings naming the private databases.\n     *\n     * @see #openOrCreateDatabase\n     * @see #deleteDatabase\n     ",
    "links" : [ ]
  }, {
    "name" : "public abstract Drawable getWallpaper()",
    "returnType" : "Drawable",
    "comment" : "\n     * @deprecated Use {@link android.app.WallpaperManager#getDrawable\n     * WallpaperManager.get()} instead.\n     ",
    "links" : [ "android.app.WallpaperManager#getDrawableWallpaperManager.get()" ]
  }, {
    "name" : "public abstract Drawable peekWallpaper()",
    "returnType" : "Drawable",
    "comment" : "\n     * @deprecated Use {@link android.app.WallpaperManager#peekDrawable\n     * WallpaperManager.peek()} instead.\n     ",
    "links" : [ "android.app.WallpaperManager#peekDrawableWallpaperManager.peek()" ]
  }, {
    "name" : "public abstract int getWallpaperDesiredMinimumWidth()",
    "returnType" : "int",
    "comment" : "\n     * @deprecated Use {@link android.app.WallpaperManager#getDesiredMinimumWidth()\n     * WallpaperManager.getDesiredMinimumWidth()} instead.\n     ",
    "links" : [ "android.app.WallpaperManager#getDesiredMinimumWidth()" ]
  }, {
    "name" : "public abstract int getWallpaperDesiredMinimumHeight()",
    "returnType" : "int",
    "comment" : "\n     * @deprecated Use {@link android.app.WallpaperManager#getDesiredMinimumHeight()\n     * WallpaperManager.getDesiredMinimumHeight()} instead.\n     ",
    "links" : [ "android.app.WallpaperManager#getDesiredMinimumHeight()" ]
  }, {
    "name" : "public abstract void setWallpaper(Bitmap bitmap) throws IOException",
    "returnType" : "void",
    "comment" : "\n     * @deprecated Use {@link android.app.WallpaperManager#setBitmap(Bitmap)\n     * WallpaperManager.set()} instead.\n     * <p>This method requires the caller to hold the permission\n     * {@link android.Manifest.permission#SET_WALLPAPER}.\n     ",
    "links" : [ "android.app.WallpaperManager#setBitmap(Bitmap)", "android.Manifest.permission#SET_WALLPAPER" ]
  }, {
    "name" : "public abstract void setWallpaper(InputStream data) throws IOException",
    "returnType" : "void",
    "comment" : "\n     * @deprecated Use {@link android.app.WallpaperManager#setStream(InputStream)\n     * WallpaperManager.set()} instead.\n     * <p>This method requires the caller to hold the permission\n     * {@link android.Manifest.permission#SET_WALLPAPER}.\n     ",
    "links" : [ "android.app.WallpaperManager#setStream(InputStream)", "android.Manifest.permission#SET_WALLPAPER" ]
  }, {
    "name" : "public abstract void clearWallpaper() throws IOException",
    "returnType" : "void",
    "comment" : "\n     * @deprecated Use {@link android.app.WallpaperManager#clear\n     * WallpaperManager.clear()} instead.\n     * <p>This method requires the caller to hold the permission\n     * {@link android.Manifest.permission#SET_WALLPAPER}.\n     ",
    "links" : [ "android.app.WallpaperManager#clearWallpaperManager.clear()", "android.Manifest.permission#SET_WALLPAPER" ]
  }, {
    "name" : "public abstract void startActivity(@RequiresPermission Intent intent)",
    "returnType" : "void",
    "comment" : "\n     * Same as {@link #startActivity(Intent, Bundle)} with no options\n     * specified.\n     *\n     * @param intent The description of the activity to start.\n     *\n     * @throws ActivityNotFoundException &nbsp;\n     *`\n     * @see #startActivity(Intent, Bundle)\n     * @see PackageManager#resolveActivity\n     ",
    "links" : [ "#startActivity(Intent" ]
  }, {
    "name" : "public void startActivityAsUser(@RequiresPermission @NonNull Intent intent, @NonNull UserHandle user)",
    "returnType" : "void",
    "comment" : "\n     * Version of {@link #startActivity(Intent)} that allows you to specify the\n     * user the activity will be started for.  This is not available to applications\n     * that are not pre-installed on the system image.\n     * @param intent The description of the activity to start.\n     * @param user The UserHandle of the user to start this activity for.\n     * @throws ActivityNotFoundException &nbsp;\n     * @hide\n     ",
    "links" : [ "#startActivity(Intent)" ]
  }, {
    "name" : "public abstract void startActivity(@RequiresPermission Intent intent, @Nullable Bundle options)",
    "returnType" : "void",
    "comment" : "\n     * Launch a new activity.  You will not receive any information about when\n     * the activity exits.\n     *\n     * <p>Note that if this method is being called from outside of an\n     * {@link android.app.Activity} Context, then the Intent must include\n     * the {@link Intent#FLAG_ACTIVITY_NEW_TASK} launch flag.  This is because,\n     * without being started from an existing Activity, there is no existing\n     * task in which to place the new activity and thus it needs to be placed\n     * in its own separate task.\n     *\n     * <p>This method throws {@link ActivityNotFoundException}\n     * if there was no Activity found to run the given Intent.\n     *\n     * @param intent The description of the activity to start.\n     * @param options Additional options for how the Activity should be started.\n     * May be null if there are no options.  See {@link android.app.ActivityOptions}\n     * for how to build the Bundle supplied here; there are no supported definitions\n     * for building it manually.\n     *\n     * @throws ActivityNotFoundException &nbsp;\n     *\n     * @see #startActivity(Intent)\n     * @see PackageManager#resolveActivity\n     ",
    "links" : [ "android.app.ActivityOptions", "android.content.ActivityNotFoundException", "android.content.Intent#FLAG_ACTIVITY_NEW_TASK", "android.app.Activity" ]
  }, {
    "name" : "public void startActivityAsUser(@RequiresPermission @NonNull Intent intent, @Nullable Bundle options, @NonNull UserHandle userId)",
    "returnType" : "void",
    "comment" : "\n     * Version of {@link #startActivity(Intent, Bundle)} that allows you to specify the\n     * user the activity will be started for.  This is not available to applications\n     * that are not pre-installed on the system image.\n     * @param intent The description of the activity to start.\n     * @param options Additional options for how the Activity should be started.\n     * May be null if there are no options.  See {@link android.app.ActivityOptions}\n     * for how to build the Bundle supplied here; there are no supported definitions\n     * for building it manually.\n     * @param userId The UserHandle of the user to start this activity for.\n     * @throws ActivityNotFoundException &nbsp;\n     * @hide\n     ",
    "links" : [ "android.app.ActivityOptions", "#startActivity(Intent" ]
  }, {
    "name" : "public void startActivityForResult(@NonNull String who, Intent intent, int requestCode, @Nullable Bundle options)",
    "returnType" : "void",
    "comment" : "\n     * Version of {@link #startActivity(Intent, Bundle)} that returns a result to the caller. This\n     * is only supported for Views and Fragments.\n     * @param who The identifier for the calling element that will receive the result.\n     * @param intent The intent to start.\n     * @param requestCode The code that will be returned with onActivityResult() identifying this\n     *          request.\n     * @param options Additional options for how the Activity should be started.\n     *          May be null if there are no options.  See {@link android.app.ActivityOptions}\n     *          for how to build the Bundle supplied here; there are no supported definitions\n     *          for building it manually.\n     * @hide\n     ",
    "links" : [ "android.app.ActivityOptions", "#startActivity(Intent" ]
  }, {
    "name" : "public boolean canStartActivityForResult()",
    "returnType" : "boolean",
    "comment" : "\n     * Identifies whether this Context instance will be able to process calls to\n     * {@link #startActivityForResult(String, Intent, int, Bundle)}.\n     * @hide\n     ",
    "links" : [ "#startActivityForResult(String" ]
  }, {
    "name" : "public abstract void startActivities(@RequiresPermission Intent[] intents)",
    "returnType" : "void",
    "comment" : "\n     * Same as {@link #startActivities(Intent[], Bundle)} with no options\n     * specified.\n     *\n     * @param intents An array of Intents to be started.\n     *\n     * @throws ActivityNotFoundException &nbsp;\n     *\n     * @see #startActivities(Intent[], Bundle)\n     * @see PackageManager#resolveActivity\n     ",
    "links" : [ "#startActivities(Intent" ]
  }, {
    "name" : "public abstract void startActivities(@RequiresPermission Intent[] intents, Bundle options)",
    "returnType" : "void",
    "comment" : "\n     * Launch multiple new activities.  This is generally the same as calling\n     * {@link #startActivity(Intent)} for the first Intent in the array,\n     * that activity during its creation calling {@link #startActivity(Intent)}\n     * for the second entry, etc.  Note that unlike that approach, generally\n     * none of the activities except the last in the array will be created\n     * at this point, but rather will be created when the user first visits\n     * them (due to pressing back from the activity on top).\n     *\n     * <p>This method throws {@link ActivityNotFoundException}\n     * if there was no Activity found for <em>any</em> given Intent.  In this\n     * case the state of the activity stack is undefined (some Intents in the\n     * list may be on it, some not), so you probably want to avoid such situations.\n     *\n     * @param intents An array of Intents to be started.\n     * @param options Additional options for how the Activity should be started.\n     * See {@link android.content.Context#startActivity(Intent, Bundle)}\n     * Context.startActivity(Intent, Bundle)} for more details.\n     *\n     * @throws ActivityNotFoundException &nbsp;\n     *\n     * @see #startActivities(Intent[])\n     * @see PackageManager#resolveActivity\n     ",
    "links" : [ "android.content.ActivityNotFoundException", "#startActivity(Intent)", "android.content.Context#startActivity(Intent" ]
  }, {
    "name" : "public int startActivitiesAsUser(Intent[] intents, Bundle options, UserHandle userHandle)",
    "returnType" : "int",
    "comment" : "\n     * @hide\n     * Launch multiple new activities.  This is generally the same as calling\n     * {@link #startActivity(Intent)} for the first Intent in the array,\n     * that activity during its creation calling {@link #startActivity(Intent)}\n     * for the second entry, etc.  Note that unlike that approach, generally\n     * none of the activities except the last in the array will be created\n     * at this point, but rather will be created when the user first visits\n     * them (due to pressing back from the activity on top).\n     *\n     * <p>This method throws {@link ActivityNotFoundException}\n     * if there was no Activity found for <em>any</em> given Intent.  In this\n     * case the state of the activity stack is undefined (some Intents in the\n     * list may be on it, some not), so you probably want to avoid such situations.\n     *\n     * @param intents An array of Intents to be started.\n     * @param options Additional options for how the Activity should be started.\n     * @param userHandle The user for whom to launch the activities\n     * See {@link android.content.Context#startActivity(Intent, Bundle)}\n     * Context.startActivity(Intent, Bundle)} for more details.\n     *\n     * @return The corresponding flag {@link ActivityManager#START_CANCELED},\n     *         {@link ActivityManager#START_SUCCESS} etc. indicating whether the launch was\n     *         successful.\n     *\n     * @throws ActivityNotFoundException &nbsp;\n     *\n     * @see #startActivities(Intent[])\n     * @see PackageManager#resolveActivity\n     ",
    "links" : [ "android.app.ActivityManager#START_SUCCESS", "android.content.ActivityNotFoundException", "#startActivity(Intent)", "android.app.ActivityManager#START_CANCELED", "android.content.Context#startActivity(Intent" ]
  }, {
    "name" : "public abstract void startIntentSender(IntentSender intent, @Nullable Intent fillInIntent, @Intent.MutableFlags int flagsMask, @Intent.MutableFlags int flagsValues, int extraFlags) throws IntentSender.SendIntentException",
    "returnType" : "void",
    "comment" : "\n     * Same as {@link #startIntentSender(IntentSender, Intent, int, int, int, Bundle)}\n     * with no options specified.\n     *\n     * @param intent The IntentSender to launch.\n     * @param fillInIntent If non-null, this will be provided as the\n     * intent parameter to {@link IntentSender#sendIntent}.\n     * @param flagsMask Intent flags in the original IntentSender that you\n     * would like to change.\n     * @param flagsValues Desired values for any bits set in\n     * <var>flagsMask</var>\n     * @param extraFlags Always set to 0.\n     *\n     * @see #startActivity(Intent)\n     * @see #startIntentSender(IntentSender, Intent, int, int, int, Bundle)\n     ",
    "links" : [ "#startIntentSender(IntentSender", "android.content.IntentSender#sendIntent" ]
  }, {
    "name" : "public abstract void startIntentSender(IntentSender intent, @Nullable Intent fillInIntent, @Intent.MutableFlags int flagsMask, @Intent.MutableFlags int flagsValues, int extraFlags, @Nullable Bundle options) throws IntentSender.SendIntentException",
    "returnType" : "void",
    "comment" : "\n     * Like {@link #startActivity(Intent, Bundle)}, but taking a IntentSender\n     * to start.  If the IntentSender is for an activity, that activity will be started\n     * as if you had called the regular {@link #startActivity(Intent)}\n     * here; otherwise, its associated action will be executed (such as\n     * sending a broadcast) as if you had called\n     * {@link IntentSender#sendIntent IntentSender.sendIntent} on it.\n     *\n     * @param intent The IntentSender to launch.\n     * @param fillInIntent If non-null, this will be provided as the\n     * intent parameter to {@link IntentSender#sendIntent}.\n     * @param flagsMask Intent flags in the original IntentSender that you\n     * would like to change.\n     * @param flagsValues Desired values for any bits set in\n     * <var>flagsMask</var>\n     * @param extraFlags Always set to 0.\n     * @param options Additional options for how the Activity should be started.\n     * See {@link android.content.Context#startActivity(Intent, Bundle)}\n     * Context.startActivity(Intent, Bundle)} for more details.  If options\n     * have also been supplied by the IntentSender, options given here will\n     * override any that conflict with those given by the IntentSender.\n     *\n     * @see #startActivity(Intent, Bundle)\n     * @see #startIntentSender(IntentSender, Intent, int, int, int)\n     ",
    "links" : [ "#startActivity(Intent", "android.content.IntentSender#sendIntent", "#startActivity(Intent)", "android.content.Context#startActivity(Intent" ]
  }, {
    "name" : "public abstract void sendBroadcast(@RequiresPermission Intent intent)",
    "returnType" : "void",
    "comment" : "\n     * Broadcast the given intent to all interested BroadcastReceivers.  This\n     * call is asynchronous; it returns immediately, and you will continue\n     * executing while the receivers are run.  No results are propagated from\n     * receivers and receivers can not abort the broadcast. If you want\n     * to allow receivers to propagate results or abort the broadcast, you must\n     * send an ordered broadcast using\n     * {@link #sendOrderedBroadcast(Intent, String)}.\n     *\n     * <p>See {@link BroadcastReceiver} for more information on Intent broadcasts.\n     *\n     * @param intent The Intent to broadcast; all receivers matching this\n     *               Intent will receive the broadcast.\n     *\n     * @see android.content.BroadcastReceiver\n     * @see #registerReceiver\n     * @see #sendBroadcast(Intent, String)\n     * @see #sendOrderedBroadcast(Intent, String)\n     * @see #sendOrderedBroadcast(Intent, String, BroadcastReceiver, Handler, int, String, Bundle)\n     ",
    "links" : [ "#sendOrderedBroadcast(Intent", "android.content.BroadcastReceiver" ]
  }, {
    "name" : "public abstract void sendBroadcast(@RequiresPermission Intent intent, @Nullable String receiverPermission)",
    "returnType" : "void",
    "comment" : "\n     * Broadcast the given intent to all interested BroadcastReceivers, allowing\n     * an optional required permission to be enforced.  This\n     * call is asynchronous; it returns immediately, and you will continue\n     * executing while the receivers are run.  No results are propagated from\n     * receivers and receivers can not abort the broadcast. If you want\n     * to allow receivers to propagate results or abort the broadcast, you must\n     * send an ordered broadcast using\n     * {@link #sendOrderedBroadcast(Intent, String)}.\n     *\n     * <p>See {@link BroadcastReceiver} for more information on Intent broadcasts.\n     *\n     * @param intent The Intent to broadcast; all receivers matching this\n     *               Intent will receive the broadcast.\n     * @param receiverPermission (optional) String naming a permission that\n     *               a receiver must hold in order to receive your broadcast.\n     *               If null, no permission is required.\n     *\n     * @see android.content.BroadcastReceiver\n     * @see #registerReceiver\n     * @see #sendBroadcast(Intent)\n     * @see #sendOrderedBroadcast(Intent, String)\n     * @see #sendOrderedBroadcast(Intent, String, BroadcastReceiver, Handler, int, String, Bundle)\n     ",
    "links" : [ "#sendOrderedBroadcast(Intent", "android.content.BroadcastReceiver" ]
  }, {
    "name" : "public void sendBroadcastMultiplePermissions(@NonNull Intent intent, @NonNull String[] receiverPermissions)",
    "returnType" : "void",
    "comment" : "\n     * Broadcast the given intent to all interested BroadcastReceivers, allowing\n     * an array of required permissions to be enforced.  This call is asynchronous; it returns\n     * immediately, and you will continue executing while the receivers are run.  No results are\n     * propagated from receivers and receivers can not abort the broadcast. If you want to allow\n     * receivers to propagate results or abort the broadcast, you must send an ordered broadcast\n     * using {@link #sendOrderedBroadcast(Intent, String)}.\n     *\n     * <p>See {@link BroadcastReceiver} for more information on Intent broadcasts.\n     *\n     * @param intent The Intent to broadcast; all receivers matching this\n     *               Intent will receive the broadcast.\n     * @param receiverPermissions Array of names of permissions that a receiver must hold\n     *                            in order to receive your broadcast.\n     *                            If empty, no permissions are required.\n     *\n     * @see android.content.BroadcastReceiver\n     * @see #registerReceiver\n     * @see #sendBroadcast(Intent)\n     * @see #sendOrderedBroadcast(Intent, String)\n     * @see #sendOrderedBroadcast(Intent, String, BroadcastReceiver, Handler, int, String, Bundle)\n     * @hide\n     ",
    "links" : [ "#sendOrderedBroadcast(Intent", "android.content.BroadcastReceiver" ]
  }, {
    "name" : "public void sendBroadcastMultiplePermissions(@NonNull Intent intent, @NonNull String[] receiverPermissions, @Nullable String[] excludedPermissions)",
    "returnType" : "void",
    "comment" : "\n     * Like {@link #sendBroadcastMultiplePermissions(Intent, String[])}, but also allows\n     * specification of a list of excluded permissions. This allows sending a broadcast to an\n     * app that has the permissions in `receiverPermissions` but not `excludedPermissions`.\n     * @hide\n     ",
    "links" : [ "#sendBroadcastMultiplePermissions(Intent" ]
  }, {
    "name" : "public void sendBroadcastMultiplePermissions(@NonNull Intent intent, @NonNull String[] receiverPermissions, @Nullable String[] excludedPermissions, @Nullable String[] excludedPackages)",
    "returnType" : "void",
    "comment" : "\n     * Like {@link #sendBroadcastMultiplePermissions(Intent, String[], String[])}, but also allows\n     * specification of a list of excluded packages.\n     *\n     * @hide\n     ",
    "links" : [ "#sendBroadcastMultiplePermissions(Intent" ]
  }, {
    "name" : "public void sendBroadcastMultiplePermissions(@NonNull Intent intent, @NonNull String[] receiverPermissions, @Nullable String[] excludedPermissions, @Nullable String[] excludedPackages, @Nullable BroadcastOptions options)",
    "returnType" : "void",
    "comment" : "\n     * Like {@link #sendBroadcastMultiplePermissions(Intent, String[], String[], String[])}, but\n     * also allows specification of options generated from {@link android.app.BroadcastOptions}.\n     *\n     * @hide\n     ",
    "links" : [ "android.app.BroadcastOptions", "#sendBroadcastMultiplePermissions(Intent" ]
  }, {
    "name" : "public void sendBroadcastMultiplePermissions(@NonNull Intent intent, @NonNull String[] receiverPermissions, @Nullable Bundle options)",
    "returnType" : "void",
    "comment" : "\n     * Version of {@link #sendBroadcastMultiplePermissions(Intent, String[])} that allows you to\n     * specify the {@link android.app.BroadcastOptions}.\n     *\n     * @param intent The Intent to broadcast; all receivers matching this\n     *               Intent will receive the broadcast.\n     * @param receiverPermissions Array of names of permissions that a receiver must hold\n     *                            in order to receive your broadcast.\n     *                            If empty, no permissions are required.\n     * @param options Additional sending options, generated from a\n     *                {@link android.app.BroadcastOptions}.\n     * @see #sendBroadcastMultiplePermissions(Intent, String[])\n     * @see android.app.BroadcastOptions\n     * @hide\n     ",
    "links" : [ "android.app.BroadcastOptions", "#sendBroadcastMultiplePermissions(Intent" ]
  }, {
    "name" : "public void sendBroadcastMultiplePermissions(@NonNull Intent intent, @NonNull String[] receiverPermissions, @Nullable BroadcastOptions options)",
    "returnType" : "void",
    "comment" : "\n     * Version of {@link #sendBroadcastMultiplePermissions(Intent, String[])} that allows you to\n     * specify the {@link android.app.BroadcastOptions}.\n     *\n     * @param intent The Intent to broadcast; all receivers matching this\n     *               Intent will receive the broadcast.\n     * @param receiverPermissions Array of names of permissions that a receiver must hold\n     *                            in order to receive your broadcast.\n     *                            If empty, no permissions are required.\n     * @param options Additional sending options, generated from a\n     *                {@link android.app.BroadcastOptions}.\n     * @see #sendBroadcastMultiplePermissions(Intent, String[])\n     * @see android.app.BroadcastOptions\n     * @hide\n     ",
    "links" : [ "android.app.BroadcastOptions", "#sendBroadcastMultiplePermissions(Intent" ]
  }, {
    "name" : "public void sendBroadcastWithMultiplePermissions(@NonNull Intent intent, @NonNull String[] receiverPermissions)",
    "returnType" : "void",
    "comment" : "\n     * Broadcast the given intent to all interested BroadcastReceivers, allowing\n     * an array of required permissions to be enforced.  This call is asynchronous; it returns\n     * immediately, and you will continue executing while the receivers are run.  No results are\n     * propagated from receivers and receivers can not abort the broadcast. If you want to allow\n     * receivers to propagate results or abort the broadcast, you must send an ordered broadcast\n     * using {@link #sendOrderedBroadcast(Intent, String)}.\n     *\n     * <p>See {@link BroadcastReceiver} for more information on Intent broadcasts.\n     *\n     * @param intent The Intent to broadcast; all receivers matching this\n     *               Intent will receive the broadcast.\n     * @param receiverPermissions Array of names of permissions that a receiver must hold\n     *                            in order to receive your broadcast.\n     *                            If empty, no permissions are required.\n     *\n     * @see android.content.BroadcastReceiver\n     * @see #registerReceiver\n     * @see #sendBroadcast(Intent)\n     * @see #sendOrderedBroadcast(Intent, String)\n     * @see #sendOrderedBroadcast(Intent, String, BroadcastReceiver, Handler, int, String, Bundle)\n     ",
    "links" : [ "#sendOrderedBroadcast(Intent", "android.content.BroadcastReceiver" ]
  }, {
    "name" : "public abstract void sendBroadcastAsUserMultiplePermissions(Intent intent, UserHandle user, String[] receiverPermissions)",
    "returnType" : "void",
    "comment" : "\n     * Broadcast the given intent to all interested BroadcastReceivers, allowing\n     * an array of required permissions to be enforced.  This call is asynchronous; it returns\n     * immediately, and you will continue executing while the receivers are run.  No results are\n     * propagated from receivers and receivers can not abort the broadcast. If you want to allow\n     * receivers to propagate results or abort the broadcast, you must send an ordered broadcast\n     * using {@link #sendOrderedBroadcast(Intent, String)}.\n     *\n     * <p>See {@link BroadcastReceiver} for more information on Intent broadcasts.\n     *\n     * @param intent The Intent to broadcast; all receivers matching this\n     *               Intent will receive the broadcast.\n     * @param user The user to send the broadcast to.\n     * @param receiverPermissions Array of names of permissions that a receiver must hold\n     *                            in order to receive your broadcast.\n     *                            If null or empty, no permissions are required.\n     *\n     * @see android.content.BroadcastReceiver\n     * @see #registerReceiver\n     * @see #sendBroadcast(Intent)\n     * @see #sendOrderedBroadcast(Intent, String)\n     * @see #sendOrderedBroadcast(Intent, String, BroadcastReceiver, Handler, int, String, Bundle)\n     * @hide\n     ",
    "links" : [ "#sendOrderedBroadcast(Intent", "android.content.BroadcastReceiver" ]
  }, {
    "name" : "public void sendBroadcast(@NonNull Intent intent, @Nullable String receiverPermission, @Nullable Bundle options)",
    "returnType" : "void",
    "comment" : "\n     * Broadcast the given intent to all interested BroadcastReceivers, allowing\n     * an optional required permission to be enforced.  This\n     * call is asynchronous; it returns immediately, and you will continue\n     * executing while the receivers are run.  No results are propagated from\n     * receivers and receivers can not abort the broadcast. If you want\n     * to allow receivers to propagate results or abort the broadcast, you must\n     * send an ordered broadcast using\n     * {@link #sendOrderedBroadcast(Intent, String)}.\n     *\n     * <p>See {@link BroadcastReceiver} for more information on Intent broadcasts.\n     *\n     * @param intent The Intent to broadcast; all receivers matching this\n     *               Intent will receive the broadcast.\n     * @param receiverPermission (optional) String naming a permission that\n     *               a receiver must hold in order to receive your broadcast.\n     *               If null, no permission is required.\n     * @param options (optional) Additional sending options, generated from a\n     * {@link android.app.BroadcastOptions}.\n     *\n     * @see android.content.BroadcastReceiver\n     * @see #registerReceiver\n     * @see #sendBroadcast(Intent)\n     * @see #sendOrderedBroadcast(Intent, String)\n     * @see #sendOrderedBroadcast(Intent, String, BroadcastReceiver, Handler, int, String, Bundle)\n     ",
    "links" : [ "#sendOrderedBroadcast(Intent", "android.app.BroadcastOptions", "android.content.BroadcastReceiver" ]
  }, {
    "name" : "public abstract void sendBroadcast(Intent intent, String receiverPermission, int appOp)",
    "returnType" : "void",
    "comment" : "\n     * Like {@link #sendBroadcast(Intent, String)}, but also allows specification\n     * of an associated app op as per {@link android.app.AppOpsManager}.\n     * @hide\n     ",
    "links" : [ "#sendBroadcast(Intent", "android.app.AppOpsManager" ]
  }, {
    "name" : "public abstract void sendOrderedBroadcast(@RequiresPermission Intent intent, @Nullable String receiverPermission)",
    "returnType" : "void",
    "comment" : "\n     * Broadcast the given intent to all interested BroadcastReceivers, delivering\n     * them one at a time to allow more preferred receivers to consume the\n     * broadcast before it is delivered to less preferred receivers.  This\n     * call is asynchronous; it returns immediately, and you will continue\n     * executing while the receivers are run.\n     *\n     * <p>See {@link BroadcastReceiver} for more information on Intent broadcasts.\n     *\n     * @param intent The Intent to broadcast; all receivers matching this\n     *               Intent will receive the broadcast.\n     * @param receiverPermission (optional) String naming a permissions that\n     *               a receiver must hold in order to receive your broadcast.\n     *               If null, no permission is required.\n     *\n     * @see android.content.BroadcastReceiver\n     * @see #registerReceiver\n     * @see #sendBroadcast(Intent)\n     * @see #sendOrderedBroadcast(Intent, String, BroadcastReceiver, Handler, int, String, Bundle)\n     ",
    "links" : [ "android.content.BroadcastReceiver" ]
  }, {
    "name" : "public void sendOrderedBroadcast(@NonNull Intent intent, @Nullable String receiverPermission, @Nullable Bundle options)",
    "returnType" : "void",
    "comment" : "\n     * Broadcast the given intent to all interested BroadcastReceivers, delivering\n     * them one at a time to allow more preferred receivers to consume the\n     * broadcast before it is delivered to less preferred receivers.  This\n     * call is asynchronous; it returns immediately, and you will continue\n     * executing while the receivers are run.\n     *\n     * <p>See {@link BroadcastReceiver} for more information on Intent broadcasts.\n     *\n     * @param intent             The Intent to broadcast; all receivers matching this\n     *                           Intent will receive the broadcast.\n     * @param receiverPermission (optional) String naming a permissions that\n     *                           a receiver must hold in order to receive your broadcast.\n     *                           If null, no permission is required.\n     * @param options            (optional) Additional sending options, generated from a\n     *                           {@link android.app.BroadcastOptions}.\n     * @see android.content.BroadcastReceiver\n     * @see #registerReceiver\n     * @see #sendBroadcast(Intent)\n     * @see #sendOrderedBroadcast(Intent, String, BroadcastReceiver, Handler, int, String, Bundle)\n     ",
    "links" : [ "android.app.BroadcastOptions", "android.content.BroadcastReceiver" ]
  }, {
    "name" : "public abstract void sendOrderedBroadcast(@RequiresPermission @NonNull Intent intent, @Nullable String receiverPermission, @Nullable BroadcastReceiver resultReceiver, @Nullable Handler scheduler, int initialCode, @Nullable String initialData, @Nullable Bundle initialExtras)",
    "returnType" : "void",
    "comment" : "\n     * Version of {@link #sendBroadcast(Intent)} that allows you to\n     * receive data back from the broadcast.  This is accomplished by\n     * supplying your own BroadcastReceiver when calling, which will be\n     * treated as a final receiver at the end of the broadcast -- its\n     * {@link BroadcastReceiver#onReceive} method will be called with\n     * the result values collected from the other receivers.  The broadcast will\n     * be serialized in the same way as calling\n     * {@link #sendOrderedBroadcast(Intent, String)}.\n     *\n     * <p>Like {@link #sendBroadcast(Intent)}, this method is\n     * asynchronous; it will return before\n     * resultReceiver.onReceive() is called.\n     *\n     * <p>See {@link BroadcastReceiver} for more information on Intent broadcasts.\n     *\n     * @param intent The Intent to broadcast; all receivers matching this\n     *               Intent will receive the broadcast.\n     * @param receiverPermission String naming a permissions that\n     *               a receiver must hold in order to receive your broadcast.\n     *               If null, no permission is required.\n     * @param resultReceiver Your own BroadcastReceiver to treat as the final\n     *                       receiver of the broadcast.\n     * @param scheduler A custom Handler with which to schedule the\n     *                  resultReceiver callback; if null it will be\n     *                  scheduled in the Context's main thread.\n     * @param initialCode An initial value for the result code.  Often\n     *                    Activity.RESULT_OK.\n     * @param initialData An initial value for the result data.  Often\n     *                    null.\n     * @param initialExtras An initial value for the result extras.  Often\n     *                      null.\n     *\n     * @see #sendBroadcast(Intent)\n     * @see #sendBroadcast(Intent, String)\n     * @see #sendOrderedBroadcast(Intent, String)\n     * @see android.content.BroadcastReceiver\n     * @see #registerReceiver\n     * @see android.app.Activity#RESULT_OK\n     ",
    "links" : [ "#sendOrderedBroadcast(Intent", "android.content.BroadcastReceiver#onReceive", "#sendBroadcast(Intent)", "android.content.BroadcastReceiver" ]
  }, {
    "name" : "public void sendOrderedBroadcast(@NonNull Intent intent, @Nullable String receiverPermission, @Nullable Bundle options, @Nullable BroadcastReceiver resultReceiver, @Nullable Handler scheduler, int initialCode, @Nullable String initialData, @Nullable Bundle initialExtras)",
    "returnType" : "void",
    "comment" : "\n     * Version of {@link #sendBroadcast(Intent)} that allows you to\n     * receive data back from the broadcast.  This is accomplished by\n     * supplying your own BroadcastReceiver when calling, which will be\n     * treated as a final receiver at the end of the broadcast -- its\n     * {@link BroadcastReceiver#onReceive} method will be called with\n     * the result values collected from the other receivers.  The broadcast will\n     * be serialized in the same way as calling\n     * {@link #sendOrderedBroadcast(Intent, String)}.\n     *\n     * <p>Like {@link #sendBroadcast(Intent)}, this method is\n     * asynchronous; it will return before\n     * resultReceiver.onReceive() is called.\n     *\n     * <p>See {@link BroadcastReceiver} for more information on Intent broadcasts.\n     *\n     *\n     * @param intent The Intent to broadcast; all receivers matching this\n     *               Intent will receive the broadcast.\n     * @param receiverPermission String naming a permissions that\n     *               a receiver must hold in order to receive your broadcast.\n     *               If null, no permission is required.\n     * @param options (optional) Additional sending options, generated from a\n     * {@link android.app.BroadcastOptions}.\n     * @param resultReceiver Your own BroadcastReceiver to treat as the final\n     *                       receiver of the broadcast.\n     * @param scheduler A custom Handler with which to schedule the\n     *                  resultReceiver callback; if null it will be\n     *                  scheduled in the Context's main thread.\n     * @param initialCode An initial value for the result code.  Often\n     *                    Activity.RESULT_OK.\n     * @param initialData An initial value for the result data.  Often\n     *                    null.\n     * @param initialExtras An initial value for the result extras.  Often\n     *                      null.\n     * @see #sendBroadcast(Intent)\n     * @see #sendBroadcast(Intent, String)\n     * @see #sendOrderedBroadcast(Intent, String)\n     * @see android.content.BroadcastReceiver\n     * @see #registerReceiver\n     * @see android.app.Activity#RESULT_OK\n     ",
    "links" : [ "#sendOrderedBroadcast(Intent", "android.content.BroadcastReceiver#onReceive", "#sendBroadcast(Intent)", "android.app.BroadcastOptions", "android.content.BroadcastReceiver" ]
  }, {
    "name" : "public abstract void sendOrderedBroadcast(Intent intent, String receiverPermission, int appOp, BroadcastReceiver resultReceiver, Handler scheduler, int initialCode, String initialData, Bundle initialExtras)",
    "returnType" : "void",
    "comment" : "\n     * Like {@link #sendOrderedBroadcast(Intent, String, BroadcastReceiver, android.os.Handler,\n     * int, String, android.os.Bundle)}, but also allows specification\n     * of an associated app op as per {@link android.app.AppOpsManager}.\n     * @hide\n     ",
    "links" : [ "#sendOrderedBroadcast(Intent", "android.app.AppOpsManager" ]
  }, {
    "name" : "public abstract void sendBroadcastAsUser(@RequiresPermission Intent intent, UserHandle user)",
    "returnType" : "void",
    "comment" : "\n     * Version of {@link #sendBroadcast(Intent)} that allows you to specify the\n     * user the broadcast will be sent to.  This is not available to applications\n     * that are not pre-installed on the system image.\n     * @param intent The intent to broadcast\n     * @param user UserHandle to send the intent to.\n     * @see #sendBroadcast(Intent)\n     ",
    "links" : [ "#sendBroadcast(Intent)" ]
  }, {
    "name" : "public abstract void sendBroadcastAsUser(@RequiresPermission Intent intent, UserHandle user, @Nullable String receiverPermission)",
    "returnType" : "void",
    "comment" : "\n     * Version of {@link #sendBroadcast(Intent, String)} that allows you to specify the\n     * user the broadcast will be sent to.  This is not available to applications\n     * that are not pre-installed on the system image.\n     *\n     * @param intent The Intent to broadcast; all receivers matching this\n     *               Intent will receive the broadcast.\n     * @param user UserHandle to send the intent to.\n     * @param receiverPermission (optional) String naming a permission that\n     *               a receiver must hold in order to receive your broadcast.\n     *               If null, no permission is required.\n     *\n     * @see #sendBroadcast(Intent, String)\n     ",
    "links" : [ "#sendBroadcast(Intent" ]
  }, {
    "name" : "public abstract void sendBroadcastAsUser(@RequiresPermission Intent intent, UserHandle user, @Nullable String receiverPermission, @Nullable Bundle options)",
    "returnType" : "void",
    "comment" : "\n     * Version of {@link #sendBroadcast(Intent, String, Bundle)} that allows you to specify the\n     * user the broadcast will be sent to.  This is not available to applications\n     * that are not pre-installed on the system image.\n     *\n     * @param intent The Intent to broadcast; all receivers matching this\n     *               Intent will receive the broadcast.\n     * @param user UserHandle to send the intent to.\n     * @param receiverPermission (optional) String naming a permission that\n     *               a receiver must hold in order to receive your broadcast.\n     *               If null, no permission is required.\n     * @param options (optional) Additional sending options, generated from a\n     * {@link android.app.BroadcastOptions}.\n     *\n     * @see #sendBroadcast(Intent, String, Bundle)\n     * @hide\n     ",
    "links" : [ "#sendBroadcast(Intent", "android.app.BroadcastOptions" ]
  }, {
    "name" : "public abstract void sendBroadcastAsUser(@RequiresPermission Intent intent, UserHandle user, @Nullable String receiverPermission, int appOp)",
    "returnType" : "void",
    "comment" : "\n     * Version of {@link #sendBroadcast(Intent, String)} that allows you to specify the\n     * user the broadcast will be sent to.  This is not available to applications\n     * that are not pre-installed on the system image.\n     *\n     * @param intent The Intent to broadcast; all receivers matching this\n     *               Intent will receive the broadcast.\n     * @param user UserHandle to send the intent to.\n     * @param receiverPermission (optional) String naming a permission that\n     *               a receiver must hold in order to receive your broadcast.\n     *               If null, no permission is required.\n     * @param appOp The app op associated with the broadcast.\n     *\n     * @see #sendBroadcast(Intent, String)\n     *\n     * @hide\n     ",
    "links" : [ "#sendBroadcast(Intent" ]
  }, {
    "name" : "public abstract void sendOrderedBroadcastAsUser(@RequiresPermission Intent intent, UserHandle user, @Nullable String receiverPermission, BroadcastReceiver resultReceiver, @Nullable Handler scheduler, int initialCode, @Nullable String initialData, @Nullable Bundle initialExtras)",
    "returnType" : "void",
    "comment" : "\n     * Version of\n     * {@link #sendOrderedBroadcast(Intent, String, BroadcastReceiver, Handler, int, String, Bundle)}\n     * that allows you to specify the\n     * user the broadcast will be sent to.  This is not available to applications\n     * that are not pre-installed on the system image.\n     *\n     * <p>See {@link BroadcastReceiver} for more information on Intent broadcasts.\n     *\n     * @param intent The Intent to broadcast; all receivers matching this\n     *               Intent will receive the broadcast.\n     * @param user UserHandle to send the intent to.\n     * @param receiverPermission String naming a permissions that\n     *               a receiver must hold in order to receive your broadcast.\n     *               If null, no permission is required.\n     * @param resultReceiver Your own BroadcastReceiver to treat as the final\n     *                       receiver of the broadcast.\n     * @param scheduler A custom Handler with which to schedule the\n     *                  resultReceiver callback; if null it will be\n     *                  scheduled in the Context's main thread.\n     * @param initialCode An initial value for the result code.  Often\n     *                    Activity.RESULT_OK.\n     * @param initialData An initial value for the result data.  Often\n     *                    null.\n     * @param initialExtras An initial value for the result extras.  Often\n     *                      null.\n     *\n     * @see #sendOrderedBroadcast(Intent, String, BroadcastReceiver, Handler, int, String, Bundle)\n     ",
    "links" : [ "#sendOrderedBroadcast(Intent", "android.content.BroadcastReceiver" ]
  }, {
    "name" : "public abstract void sendOrderedBroadcastAsUser(Intent intent, UserHandle user, @Nullable String receiverPermission, int appOp, BroadcastReceiver resultReceiver, @Nullable Handler scheduler, int initialCode, @Nullable String initialData, @Nullable Bundle initialExtras)",
    "returnType" : "void",
    "comment" : "\n     * Similar to above but takes an appOp as well, to enforce restrictions.\n     * @see #sendOrderedBroadcastAsUser(Intent, UserHandle, String,\n     *       BroadcastReceiver, Handler, int, String, Bundle)\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public abstract void sendOrderedBroadcastAsUser(Intent intent, UserHandle user, @Nullable String receiverPermission, int appOp, @Nullable Bundle options, BroadcastReceiver resultReceiver, @Nullable Handler scheduler, int initialCode, @Nullable String initialData, @Nullable Bundle initialExtras)",
    "returnType" : "void",
    "comment" : "\n     * Similar to above but takes an appOp as well, to enforce restrictions, and an options Bundle.\n     * @see #sendOrderedBroadcastAsUser(Intent, UserHandle, String,\n     *       BroadcastReceiver, Handler, int, String, Bundle)\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public void sendOrderedBroadcast(@NonNull Intent intent, @Nullable String receiverPermission, @Nullable String receiverAppOp, @Nullable BroadcastReceiver resultReceiver, @Nullable Handler scheduler, int initialCode, @Nullable String initialData, @Nullable Bundle initialExtras)",
    "returnType" : "void",
    "comment" : "\n     * Version of\n     * {@link #sendOrderedBroadcast(Intent, String, BroadcastReceiver, Handler, int, String,\n     * Bundle)} that allows you to specify the App Op to enforce restrictions on which receivers\n     * the broadcast will be sent to.\n     *\n     * <p>See {@link BroadcastReceiver} for more information on Intent broadcasts.\n     *\n     * @param intent The Intent to broadcast; all receivers matching this\n     *               Intent will receive the broadcast.\n     * @param receiverPermission String naming a permissions that\n     *               a receiver must hold in order to receive your broadcast.\n     *               If null, no permission is required.\n     * @param receiverAppOp The app op associated with the broadcast. If null, no appOp is\n     *                      required. If both receiverAppOp and receiverPermission are non-null,\n     *                      a receiver must have both of them to\n     *                      receive the broadcast\n     * @param resultReceiver Your own BroadcastReceiver to treat as the final\n     *                       receiver of the broadcast.\n     * @param scheduler A custom Handler with which to schedule the\n     *                  resultReceiver callback; if null it will be\n     *                  scheduled in the Context's main thread.\n     * @param initialCode An initial value for the result code.  Often\n     *                    Activity.RESULT_OK.\n     * @param initialData An initial value for the result data.  Often\n     *                    null.\n     * @param initialExtras An initial value for the result extras.  Often\n     *                      null.\n     *\n     * @see #sendOrderedBroadcast(Intent, String, BroadcastReceiver, Handler, int, String, Bundle)\n     ",
    "links" : [ "#sendOrderedBroadcast(Intent", "android.content.BroadcastReceiver" ]
  }, {
    "name" : "public void sendOrderedBroadcast(@RequiresPermission @NonNull Intent intent, int initialCode, @Nullable String receiverPermission, @Nullable String receiverAppOp, @Nullable BroadcastReceiver resultReceiver, @Nullable Handler scheduler, @Nullable String initialData, @Nullable Bundle initialExtras, @Nullable Bundle options)",
    "returnType" : "void",
    "comment" : "\n     * Version of\n     * {@link #sendOrderedBroadcast(Intent, String, BroadcastReceiver, Handler, int, String,\n     * Bundle)} that allows you to specify the App Op to enforce restrictions on which receivers\n     * the broadcast will be sent to as well as supply an optional sending options\n     *\n     * <p>See {@link BroadcastReceiver} for more information on Intent broadcasts.\n     *\n     * @param intent The Intent to broadcast; all receivers matching this\n     *               Intent will receive the broadcast.\n     * @param receiverPermission String naming a permissions that\n     *               a receiver must hold in order to receive your broadcast.\n     *               If null, no permission is required.\n     * @param receiverAppOp The app op associated with the broadcast. If null, no appOp is\n     *                      required. If both receiverAppOp and receiverPermission are non-null,\n     *                      a receiver must have both of them to\n     *                      receive the broadcast\n     * @param options (optional) Additional sending options, generated from a\n     * {@link android.app.BroadcastOptions}.\n     * @param resultReceiver Your own BroadcastReceiver to treat as the final\n     *                       receiver of the broadcast.\n     * @param scheduler A custom Handler with which to schedule the\n     *                  resultReceiver callback; if null it will be\n     *                  scheduled in the Context's main thread.\n     * @param initialCode An initial value for the result code.  Often\n     *                    Activity.RESULT_OK.\n     * @param initialData An initial value for the result data.  Often\n     *                    null.\n     * @param initialExtras An initial value for the result extras.  Often\n     *                      null.\n     *\n     * @see #sendOrderedBroadcast(Intent, String, BroadcastReceiver, Handler, int, String, Bundle)\n     * @see android.app.BroadcastOptions\n     * @hide\n     ",
    "links" : [ "#sendOrderedBroadcast(Intent", "android.app.BroadcastOptions", "android.content.BroadcastReceiver" ]
  }, {
    "name" : "public abstract void sendStickyBroadcast(@RequiresPermission Intent intent)",
    "returnType" : "void",
    "comment" : "\n     * <p>Perform a {@link #sendBroadcast(Intent)} that is \"sticky,\" meaning the\n     * Intent you are sending stays around after the broadcast is complete,\n     * so that others can quickly retrieve that data through the return\n     * value of {@link #registerReceiver(BroadcastReceiver, IntentFilter)}.  In\n     * all other ways, this behaves the same as\n     * {@link #sendBroadcast(Intent)}.\n     *\n     * @deprecated Sticky broadcasts should not be used.  They provide no security (anyone\n     * can access them), no protection (anyone can modify them), and many other problems.\n     * The recommended pattern is to use a non-sticky broadcast to report that <em>something</em>\n     * has changed, with another mechanism for apps to retrieve the current value whenever\n     * desired.\n     *\n     * @param intent The Intent to broadcast; all receivers matching this\n     * Intent will receive the broadcast, and the Intent will be held to\n     * be re-broadcast to future receivers.\n     *\n     * @see #sendBroadcast(Intent)\n     * @see #sendStickyOrderedBroadcast(Intent, BroadcastReceiver, Handler, int, String, Bundle)\n     ",
    "links" : [ "#sendBroadcast(Intent)", "#registerReceiver(BroadcastReceiver" ]
  }, {
    "name" : "public void sendStickyBroadcast(@RequiresPermission @NonNull Intent intent, @Nullable Bundle options)",
    "returnType" : "void",
    "comment" : "\n     * <p>Perform a {@link #sendBroadcast(Intent)} that is \"sticky,\" meaning the\n     * Intent you are sending stays around after the broadcast is complete,\n     * so that others can quickly retrieve that data through the return\n     * value of {@link #registerReceiver(BroadcastReceiver, IntentFilter)}.  In\n     * all other ways, this behaves the same as\n     * {@link #sendBroadcast(Intent)}.\n     *\n     * @deprecated Sticky broadcasts should not be used.  They provide no security (anyone\n     * can access them), no protection (anyone can modify them), and many other problems.\n     * The recommended pattern is to use a non-sticky broadcast to report that <em>something</em>\n     * has changed, with another mechanism for apps to retrieve the current value whenever\n     * desired.\n     *\n     * @param intent The Intent to broadcast; all receivers matching this\n     * Intent will receive the broadcast, and the Intent will be held to\n     * be re-broadcast to future receivers.\n     * @param options (optional) Additional sending options, generated from a\n     * {@link android.app.BroadcastOptions}.\n     *\n     * @see #sendBroadcast(Intent)\n     * @see #sendStickyOrderedBroadcast(Intent, BroadcastReceiver, Handler, int, String, Bundle)\n     ",
    "links" : [ "#sendBroadcast(Intent)", "android.app.BroadcastOptions", "#registerReceiver(BroadcastReceiver" ]
  }, {
    "name" : "public abstract void sendStickyOrderedBroadcast(@RequiresPermission Intent intent, BroadcastReceiver resultReceiver, @Nullable Handler scheduler, int initialCode, @Nullable String initialData, @Nullable Bundle initialExtras)",
    "returnType" : "void",
    "comment" : "\n     * <p>Version of {@link #sendStickyBroadcast} that allows you to\n     * receive data back from the broadcast.  This is accomplished by\n     * supplying your own BroadcastReceiver when calling, which will be\n     * treated as a final receiver at the end of the broadcast -- its\n     * {@link BroadcastReceiver#onReceive} method will be called with\n     * the result values collected from the other receivers.  The broadcast will\n     * be serialized in the same way as calling\n     * {@link #sendOrderedBroadcast(Intent, String)}.\n     *\n     * <p>Like {@link #sendBroadcast(Intent)}, this method is\n     * asynchronous; it will return before\n     * resultReceiver.onReceive() is called.  Note that the sticky data\n     * stored is only the data you initially supply to the broadcast, not\n     * the result of any changes made by the receivers.\n     *\n     * <p>See {@link BroadcastReceiver} for more information on Intent broadcasts.\n     *\n     * @deprecated Sticky broadcasts should not be used.  They provide no security (anyone\n     * can access them), no protection (anyone can modify them), and many other problems.\n     * The recommended pattern is to use a non-sticky broadcast to report that <em>something</em>\n     * has changed, with another mechanism for apps to retrieve the current value whenever\n     * desired.\n     *\n     * @param intent The Intent to broadcast; all receivers matching this\n     *               Intent will receive the broadcast.\n     * @param resultReceiver Your own BroadcastReceiver to treat as the final\n     *                       receiver of the broadcast.\n     * @param scheduler A custom Handler with which to schedule the\n     *                  resultReceiver callback; if null it will be\n     *                  scheduled in the Context's main thread.\n     * @param initialCode An initial value for the result code.  Often\n     *                    Activity.RESULT_OK.\n     * @param initialData An initial value for the result data.  Often\n     *                    null.\n     * @param initialExtras An initial value for the result extras.  Often\n     *                      null.\n     *\n     * @see #sendBroadcast(Intent)\n     * @see #sendBroadcast(Intent, String)\n     * @see #sendOrderedBroadcast(Intent, String)\n     * @see #sendStickyBroadcast(Intent)\n     * @see android.content.BroadcastReceiver\n     * @see #registerReceiver\n     * @see android.app.Activity#RESULT_OK\n     ",
    "links" : [ "#sendOrderedBroadcast(Intent", "android.content.BroadcastReceiver#onReceive", "#sendBroadcast(Intent)", "#sendStickyBroadcast", "android.content.BroadcastReceiver" ]
  }, {
    "name" : "public abstract void removeStickyBroadcast(@RequiresPermission Intent intent)",
    "returnType" : "void",
    "comment" : "\n     * <p>Remove the data previously sent with {@link #sendStickyBroadcast},\n     * so that it is as if the sticky broadcast had never happened.\n     *\n     * @deprecated Sticky broadcasts should not be used.  They provide no security (anyone\n     * can access them), no protection (anyone can modify them), and many other problems.\n     * The recommended pattern is to use a non-sticky broadcast to report that <em>something</em>\n     * has changed, with another mechanism for apps to retrieve the current value whenever\n     * desired.\n     *\n     * @param intent The Intent that was previously broadcast.\n     *\n     * @see #sendStickyBroadcast\n     ",
    "links" : [ "#sendStickyBroadcast" ]
  }, {
    "name" : "public abstract void sendStickyBroadcastAsUser(@RequiresPermission Intent intent, UserHandle user)",
    "returnType" : "void",
    "comment" : "\n     * <p>Version of {@link #sendStickyBroadcast(Intent)} that allows you to specify the\n     * user the broadcast will be sent to.  This is not available to applications\n     * that are not pre-installed on the system image.\n     *\n     * @deprecated Sticky broadcasts should not be used.  They provide no security (anyone\n     * can access them), no protection (anyone can modify them), and many other problems.\n     * The recommended pattern is to use a non-sticky broadcast to report that <em>something</em>\n     * has changed, with another mechanism for apps to retrieve the current value whenever\n     * desired.\n     *\n     * @param intent The Intent to broadcast; all receivers matching this\n     * Intent will receive the broadcast, and the Intent will be held to\n     * be re-broadcast to future receivers.\n     * @param user UserHandle to send the intent to.\n     *\n     * @see #sendBroadcast(Intent)\n     ",
    "links" : [ "#sendStickyBroadcast(Intent)" ]
  }, {
    "name" : "public abstract void sendStickyBroadcastAsUser(@RequiresPermission Intent intent, UserHandle user, Bundle options)",
    "returnType" : "void",
    "comment" : "\n     * @hide\n     * This is just here for sending CONNECTIVITY_ACTION.\n     ",
    "links" : [ ]
  }, {
    "name" : "public abstract void sendStickyOrderedBroadcastAsUser(@RequiresPermission Intent intent, UserHandle user, BroadcastReceiver resultReceiver, @Nullable Handler scheduler, int initialCode, @Nullable String initialData, @Nullable Bundle initialExtras)",
    "returnType" : "void",
    "comment" : "\n     * <p>Version of\n     * {@link #sendStickyOrderedBroadcast(Intent, BroadcastReceiver, Handler, int, String, Bundle)}\n     * that allows you to specify the\n     * user the broadcast will be sent to.  This is not available to applications\n     * that are not pre-installed on the system image.\n     *\n     * <p>See {@link BroadcastReceiver} for more information on Intent broadcasts.\n     *\n     * @deprecated Sticky broadcasts should not be used.  They provide no security (anyone\n     * can access them), no protection (anyone can modify them), and many other problems.\n     * The recommended pattern is to use a non-sticky broadcast to report that <em>something</em>\n     * has changed, with another mechanism for apps to retrieve the current value whenever\n     * desired.\n     *\n     * @param intent The Intent to broadcast; all receivers matching this\n     *               Intent will receive the broadcast.\n     * @param user UserHandle to send the intent to.\n     * @param resultReceiver Your own BroadcastReceiver to treat as the final\n     *                       receiver of the broadcast.\n     * @param scheduler A custom Handler with which to schedule the\n     *                  resultReceiver callback; if null it will be\n     *                  scheduled in the Context's main thread.\n     * @param initialCode An initial value for the result code.  Often\n     *                    Activity.RESULT_OK.\n     * @param initialData An initial value for the result data.  Often\n     *                    null.\n     * @param initialExtras An initial value for the result extras.  Often\n     *                      null.\n     *\n     * @see #sendStickyOrderedBroadcast(Intent, BroadcastReceiver, Handler, int, String, Bundle)\n     ",
    "links" : [ "#sendStickyOrderedBroadcast(Intent", "android.content.BroadcastReceiver" ]
  }, {
    "name" : "public abstract void removeStickyBroadcastAsUser(@RequiresPermission Intent intent, UserHandle user)",
    "returnType" : "void",
    "comment" : "\n     * <p>Version of {@link #removeStickyBroadcast(Intent)} that allows you to specify the\n     * user the broadcast will be sent to.  This is not available to applications\n     * that are not pre-installed on the system image.\n     *\n     * <p>You must hold the {@link android.Manifest.permission#BROADCAST_STICKY}\n     * permission in order to use this API.  If you do not hold that\n     * permission, {@link SecurityException} will be thrown.\n     *\n     * @deprecated Sticky broadcasts should not be used.  They provide no security (anyone\n     * can access them), no protection (anyone can modify them), and many other problems.\n     * The recommended pattern is to use a non-sticky broadcast to report that <em>something</em>\n     * has changed, with another mechanism for apps to retrieve the current value whenever\n     * desired.\n     *\n     * @param intent The Intent that was previously broadcast.\n     * @param user UserHandle to remove the sticky broadcast from.\n     *\n     * @see #sendStickyBroadcastAsUser\n     ",
    "links" : [ "#removeStickyBroadcast(Intent)", "android.Manifest.permission#BROADCAST_STICKY", "SecurityException" ]
  }, {
    "name" : "public abstract Intent registerReceiver(@Nullable BroadcastReceiver receiver, IntentFilter filter)",
    "returnType" : "Intent",
    "comment" : "\n     * Register a BroadcastReceiver to be run in the main activity thread.  The\n     * <var>receiver</var> will be called with any broadcast Intent that\n     * matches <var>filter</var>, in the main application thread.\n     *\n     * <p>The system may broadcast Intents that are \"sticky\" -- these stay\n     * around after the broadcast has finished, to be sent to any later\n     * registrations. If your IntentFilter matches one of these sticky\n     * Intents, that Intent will be returned by this function\n     * <strong>and</strong> sent to your <var>receiver</var> as if it had just\n     * been broadcast.\n     *\n     * <p>There may be multiple sticky Intents that match <var>filter</var>,\n     * in which case each of these will be sent to <var>receiver</var>.  In\n     * this case, only one of these can be returned directly by the function;\n     * which of these that is returned is arbitrarily decided by the system.\n     *\n     * <p>If you know the Intent your are registering for is sticky, you can\n     * supply null for your <var>receiver</var>.  In this case, no receiver is\n     * registered -- the function simply returns the sticky Intent that\n     * matches <var>filter</var>.  In the case of multiple matches, the same\n     * rules as described above apply.\n     *\n     * <p>See {@link BroadcastReceiver} for more information on Intent broadcasts.\n     *\n     * <p>As of {@link android.os.Build.VERSION_CODES#UPSIDE_DOWN_CAKE}, the system can <a\n     * href=\"{@docRoot}develop/background-work/background-tasks/broadcasts#android-14\">place\n     * context-registered broadcasts in a queue while the app is in the <a\n     * href=\"{@docRoot}guide/components/activities/process-lifecycle\">cached state</a>.\n     * When the app leaves the cached state, such as returning to the\n     * foreground, the system delivers any queued broadcasts. Multiple instances\n     * of certain broadcasts might be merged into one broadcast.\n     *\n     * <p>As of {@link android.os.Build.VERSION_CODES#ICE_CREAM_SANDWICH}, receivers\n     * registered with this method will correctly respect the\n     * {@link Intent#setPackage(String)} specified for an Intent being broadcast.\n     * Prior to that, it would be ignored and delivered to all matching registered\n     * receivers.  Be careful if using this for security.</p>\n     *\n     * <p>For apps targeting {@link android.os.Build.VERSION_CODES#UPSIDE_DOWN_CAKE},\n     * either {@link #RECEIVER_EXPORTED} or {@link #RECEIVER_NOT_EXPORTED} must be\n     * specified if the receiver is not being registered for <a\n     * href=\"{@docRoot}guide/components/broadcasts#system-broadcasts\">system broadcasts</a>\n     * or a {@link SecurityException} will be thrown. See {@link\n     * #registerReceiver(BroadcastReceiver, IntentFilter, int)} to register a receiver with\n     * flags.\n     *\n     * <p class=\"note\">Note: this method <em>cannot be called from a\n     * {@link BroadcastReceiver} component;</em> that is, from a BroadcastReceiver\n     * that is declared in an application's manifest.  It is okay, however, to call\n     * this method from another BroadcastReceiver that has itself been registered\n     * at run time with {@link #registerReceiver}, since the lifetime of such a\n     * registered BroadcastReceiver is tied to the object that registered it.</p>\n     *\n     * @param receiver The BroadcastReceiver to handle the broadcast.\n     * @param filter Selects the Intent broadcasts to be received.\n     *\n     * @return The first sticky intent found that matches <var>filter</var>,\n     *         or null if there are none.\n     *\n     * @see #registerReceiver(BroadcastReceiver, IntentFilter, String, Handler)\n     * @see #sendBroadcast\n     * @see #unregisterReceiver\n     ",
    "links" : [ "#RECEIVER_EXPORTED", "android.os.Build.VERSION_CODES#UPSIDE_DOWN_CAKE", "#RECEIVER_NOT_EXPORTED", "android.os.Build.VERSION_CODES#ICE_CREAM_SANDWICH", "#registerReceiver", "SecurityException", "android.content.Intent#setPackage(String)", "android.content.BroadcastReceiver", "#registerReceiver(BroadcastReceiver" ]
  }, {
    "name" : "public abstract Intent registerReceiver(@Nullable BroadcastReceiver receiver, IntentFilter filter, @RegisterReceiverFlags int flags)",
    "returnType" : "Intent",
    "comment" : "\n     * Register to receive intent broadcasts, with the receiver optionally being\n     * exposed to Instant Apps. See\n     * {@link #registerReceiver(BroadcastReceiver, IntentFilter)} for more\n     * information. By default Instant Apps cannot interact with receivers in other\n     * applications, this allows you to expose a receiver that Instant Apps can\n     * interact with.\n     *\n     * <p>See {@link BroadcastReceiver} for more information on Intent broadcasts.\n     *\n     * <p>As of {@link android.os.Build.VERSION_CODES#UPSIDE_DOWN_CAKE}, the system can <a\n     * href=\"{@docRoot}develop/background-work/background-tasks/broadcasts#android-14\">place\n     * context-registered broadcasts in a queue while the app is in the <a\n     * href=\"{@docRoot}guide/components/activities/process-lifecycle\">cached state</a>.\n     * When the app leaves the cached state, such as returning to the\n     * foreground, the system delivers any queued broadcasts. Multiple instances\n     * of certain broadcasts might be merged into one broadcast.\n     *\n     * <p>As of {@link android.os.Build.VERSION_CODES#ICE_CREAM_SANDWICH}, receivers\n     * registered with this method will correctly respect the\n     * {@link Intent#setPackage(String)} specified for an Intent being broadcast.\n     * Prior to that, it would be ignored and delivered to all matching registered\n     * receivers.  Be careful if using this for security.</p>\n     *\n     * @param receiver The BroadcastReceiver to handle the broadcast.\n     * @param filter Selects the Intent broadcasts to be received.\n     * @param flags Additional options for the receiver. For apps targeting {@link\n     *      android.os.Build.VERSION_CODES#UPSIDE_DOWN_CAKE} either {@link #RECEIVER_EXPORTED} or\n     *      {@link #RECEIVER_NOT_EXPORTED} must be specified if the receiver isn't being registered\n     *      for <a href=\"{@docRoot}guide/components/broadcasts#system-broadcasts\">system\n     *      broadcasts</a> or a {@link SecurityException} will be thrown. If {@link\n     *      #RECEIVER_EXPORTED} is specified, a receiver may additionally specify {@link\n     *      #RECEIVER_VISIBLE_TO_INSTANT_APPS}. For a complete list of system broadcast actions,\n     *      see the BROADCAST_ACTIONS.TXT file in the Android SDK. If both {@link\n     *      #RECEIVER_EXPORTED} and {@link #RECEIVER_NOT_EXPORTED} are specified, an {@link\n     *      IllegalArgumentException} will be thrown.\n     *\n     * @return The first sticky intent found that matches <var>filter</var>,\n     *         or null if there are none.\n     *\n     * @see #registerReceiver(BroadcastReceiver, IntentFilter)\n     * @see #sendBroadcast\n     * @see #unregisterReceiver\n     ",
    "links" : [ "#RECEIVER_EXPORTED", "android.os.Build.VERSION_CODES#UPSIDE_DOWN_CAKE", "#RECEIVER_NOT_EXPORTED", "#RECEIVER_VISIBLE_TO_INSTANT_APPS", "android.os.Build.VERSION_CODES#ICE_CREAM_SANDWICH", "SecurityException", "android.content.Intent#setPackage(String)", "#registerReceiver(BroadcastReceiver", "android.content.BroadcastReceiver", "IllegalArgumentException" ]
  }, {
    "name" : "public abstract Intent registerReceiver(BroadcastReceiver receiver, IntentFilter filter, @Nullable String broadcastPermission, @Nullable Handler scheduler)",
    "returnType" : "Intent",
    "comment" : "\n     * Register to receive intent broadcasts, to run in the context of\n     * <var>scheduler</var>.  See\n     * {@link #registerReceiver(BroadcastReceiver, IntentFilter)} for more\n     * information.  This allows you to enforce permissions on who can\n     * broadcast intents to your receiver, or have the receiver run in\n     * a different thread than the main application thread.\n     *\n     * <p>See {@link BroadcastReceiver} for more information on Intent broadcasts.\n     *\n     * <p>As of {@link android.os.Build.VERSION_CODES#UPSIDE_DOWN_CAKE}, the system can <a\n     * href=\"{@docRoot}develop/background-work/background-tasks/broadcasts#android-14\">place\n     * context-registered broadcasts in a queue while the app is in the <a\n     * href=\"{@docRoot}guide/components/activities/process-lifecycle\">cached state</a>.\n     * When the app leaves the cached state, such as returning to the\n     * foreground, the system delivers any queued broadcasts. Multiple instances\n     * of certain broadcasts might be merged into one broadcast.\n     *\n     * <p>As of {@link android.os.Build.VERSION_CODES#ICE_CREAM_SANDWICH}, receivers\n     * registered with this method will correctly respect the\n     * {@link Intent#setPackage(String)} specified for an Intent being broadcast.\n     * Prior to that, it would be ignored and delivered to all matching registered\n     * receivers.  Be careful if using this for security.</p>\n     *\n     * <p>For apps targeting {@link android.os.Build.VERSION_CODES#UPSIDE_DOWN_CAKE},\n     * either {@link #RECEIVER_EXPORTED} or {@link #RECEIVER_NOT_EXPORTED} must be\n     * specified if the receiver is not being registered for <a\n     * href=\"{@docRoot}guide/components/broadcasts#system-broadcasts\">system broadcasts</a>\n     * or a {@link SecurityException} will be thrown. See {@link\n     * #registerReceiver(BroadcastReceiver, IntentFilter, String, Handler, int)} to register a\n     * receiver with flags.\n     *\n     * @param receiver The BroadcastReceiver to handle the broadcast.\n     * @param filter Selects the Intent broadcasts to be received.\n     * @param broadcastPermission String naming a permissions that a\n     *      broadcaster must hold in order to send an Intent to you.  If null,\n     *      no permission is required.\n     * @param scheduler Handler identifying the thread that will receive\n     *      the Intent.  If null, the main thread of the process will be used.\n     *\n     * @return The first sticky intent found that matches <var>filter</var>,\n     *         or null if there are none.\n     *\n     * @see #registerReceiver(BroadcastReceiver, IntentFilter)\n     * @see #sendBroadcast\n     * @see #unregisterReceiver\n     ",
    "links" : [ "#RECEIVER_EXPORTED", "android.os.Build.VERSION_CODES#UPSIDE_DOWN_CAKE", "#RECEIVER_NOT_EXPORTED", "android.os.Build.VERSION_CODES#ICE_CREAM_SANDWICH", "SecurityException", "android.content.Intent#setPackage(String)", "#registerReceiver(BroadcastReceiver", "android.content.BroadcastReceiver" ]
  }, {
    "name" : "public abstract Intent registerReceiver(BroadcastReceiver receiver, IntentFilter filter, @Nullable String broadcastPermission, @Nullable Handler scheduler, @RegisterReceiverFlags int flags)",
    "returnType" : "Intent",
    "comment" : "\n     * Register to receive intent broadcasts, to run in the context of\n     * <var>scheduler</var>. See\n     * {@link #registerReceiver(BroadcastReceiver, IntentFilter, int)} and\n     * {@link #registerReceiver(BroadcastReceiver, IntentFilter, String, Handler)}\n     * for more information.\n     *\n     * <p>See {@link BroadcastReceiver} for more information on Intent broadcasts.\n     *\n     * <p>As of {@link android.os.Build.VERSION_CODES#UPSIDE_DOWN_CAKE}, the system can <a\n     * href=\"{@docRoot}develop/background-work/background-tasks/broadcasts#android-14\">place\n     * context-registered broadcasts in a queue while the app is in the <a\n     * href=\"{@docRoot}guide/components/activities/process-lifecycle\">cached state</a>.\n     * When the app leaves the cached state, such as returning to the\n     * foreground, the system delivers any queued broadcasts. Multiple instances\n     * of certain broadcasts might be merged into one broadcast.\n     *\n     * <p>As of {@link android.os.Build.VERSION_CODES#ICE_CREAM_SANDWICH}, receivers\n     * registered with this method will correctly respect the\n     * {@link Intent#setPackage(String)} specified for an Intent being broadcast.\n     * Prior to that, it would be ignored and delivered to all matching registered\n     * receivers.  Be careful if using this for security.</p>\n     *\n     * @param receiver The BroadcastReceiver to handle the broadcast.\n     * @param filter Selects the Intent broadcasts to be received.\n     * @param broadcastPermission String naming a permissions that a\n     *      broadcaster must hold in order to send an Intent to you.  If null,\n     *      no permission is required.\n     * @param scheduler Handler identifying the thread that will receive\n     *      the Intent.  If null, the main thread of the process will be used.\n     * @param flags Additional options for the receiver. For apps targeting {@link\n     *      android.os.Build.VERSION_CODES#UPSIDE_DOWN_CAKE} either {@link #RECEIVER_EXPORTED} or\n     *      {@link #RECEIVER_NOT_EXPORTED} must be specified if the receiver isn't being registered\n     *      for <a href=\"{@docRoot}guide/components/broadcasts#system-broadcasts\">system\n     *      broadcasts</a> or a {@link SecurityException} will be thrown. If {@link\n     *      #RECEIVER_EXPORTED} is specified, a receiver may additionally specify {@link\n     *      #RECEIVER_VISIBLE_TO_INSTANT_APPS}. For a complete list of system broadcast actions,\n     *      see the BROADCAST_ACTIONS.TXT file in the Android SDK. If both {@link\n     *      #RECEIVER_EXPORTED} and {@link #RECEIVER_NOT_EXPORTED} are specified, an {@link\n     *      IllegalArgumentException} will be thrown.\n     * @return The first sticky intent found that matches <var>filter</var>,\n     *         or null if there are none.\n     *\n     * @see #registerReceiver(BroadcastReceiver, IntentFilter, int)\n     * @see #registerReceiver(BroadcastReceiver, IntentFilter, String, Handler)\n     * @see #sendBroadcast\n     * @see #unregisterReceiver\n     ",
    "links" : [ "#RECEIVER_EXPORTED", "android.os.Build.VERSION_CODES#UPSIDE_DOWN_CAKE", "#RECEIVER_NOT_EXPORTED", "#RECEIVER_VISIBLE_TO_INSTANT_APPS", "android.os.Build.VERSION_CODES#ICE_CREAM_SANDWICH", "SecurityException", "android.content.Intent#setPackage(String)", "#registerReceiver(BroadcastReceiver", "android.content.BroadcastReceiver", "IllegalArgumentException" ]
  }, {
    "name" : "public Intent registerReceiverForAllUsers(@Nullable BroadcastReceiver receiver, @NonNull IntentFilter filter, @Nullable String broadcastPermission, @Nullable Handler scheduler)",
    "returnType" : "Intent",
    "comment" : "\n     * Same as {@link #registerReceiver(BroadcastReceiver, IntentFilter, String, Handler)}\n     * but this receiver will receive broadcasts that are sent to all users. The receiver can\n     * use {@link BroadcastReceiver#getSendingUser} to determine on which user the broadcast\n     * was sent.\n     *\n     * @param receiver The BroadcastReceiver to handle the broadcast.\n     * @param filter Selects the Intent broadcasts to be received.\n     * @param broadcastPermission String naming a permissions that a\n     *      broadcaster must hold in order to send an Intent to you. If {@code null},\n     *      no permission is required.\n     * @param scheduler Handler identifying the thread that will receive\n     *      the Intent. If {@code null}, the main thread of the process will be used.\n     *\n     * @return The first sticky intent found that matches <var>filter</var>,\n     *         or {@code null} if there are none.\n     *\n     * @see #registerReceiver(BroadcastReceiver, IntentFilter, String, Handler)\n     * @see #sendBroadcast\n     * @see #unregisterReceiver\n     * @hide\n     ",
    "links" : [ "#registerReceiver(BroadcastReceiver", "android.content.BroadcastReceiver#getSendingUser" ]
  }, {
    "name" : "public Intent registerReceiverForAllUsers(@Nullable BroadcastReceiver receiver, @NonNull IntentFilter filter, @Nullable String broadcastPermission, @Nullable Handler scheduler, @RegisterReceiverFlags int flags)",
    "returnType" : "Intent",
    "comment" : "\n     * Same as {@link #registerReceiver(BroadcastReceiver, IntentFilter, String, Handler, int)}\n     * but this receiver will receive broadcasts that are sent to all users. The receiver can\n     * use {@link BroadcastReceiver#getSendingUser} to determine on which user the broadcast\n     * was sent.\n     *\n     * @param receiver The BroadcastReceiver to handle the broadcast.\n     * @param filter Selects the Intent broadcasts to be received.\n     * @param broadcastPermission String naming a permissions that a\n     *      broadcaster must hold in order to send an Intent to you. If {@code null},\n     *      no permission is required.\n     * @param scheduler Handler identifying the thread that will receive\n     *      the Intent. If {@code null}, the main thread of the process will be used.\n     * @param flags Additional options for the receiver. For apps targeting {@link\n     *      android.os.Build.VERSION_CODES#UPSIDE_DOWN_CAKE} either {@link #RECEIVER_EXPORTED} or\n     *      {@link #RECEIVER_NOT_EXPORTED} must be specified if the receiver isn't being registered\n     *      for <a href=\"{@docRoot}guide/components/broadcasts#system-broadcasts\">system\n     *      broadcasts</a> or a {@link SecurityException} will be thrown. If {@link\n     *      #RECEIVER_EXPORTED} is specified, a receiver may additionally specify {@link\n     *      #RECEIVER_VISIBLE_TO_INSTANT_APPS}. For a complete list of system broadcast actions,\n     *      see the BROADCAST_ACTIONS.TXT file in the Android SDK. If both {@link\n     *      #RECEIVER_EXPORTED} and {@link #RECEIVER_NOT_EXPORTED} are specified, an {@link\n     *      IllegalArgumentException} will be thrown.\n     *\n     * @return The first sticky intent found that matches <var>filter</var>,\n     *         or {@code null} if there are none.\n     *\n     * @see #registerReceiver(BroadcastReceiver, IntentFilter, String, Handler, int)\n     * @see #sendBroadcast\n     * @see #unregisterReceiver\n     * @hide\n     ",
    "links" : [ "#RECEIVER_EXPORTED", "android.os.Build.VERSION_CODES#UPSIDE_DOWN_CAKE", "#RECEIVER_NOT_EXPORTED", "#RECEIVER_VISIBLE_TO_INSTANT_APPS", "SecurityException", "#registerReceiver(BroadcastReceiver", "android.content.BroadcastReceiver#getSendingUser", "IllegalArgumentException" ]
  }, {
    "name" : "public abstract Intent registerReceiverAsUser(BroadcastReceiver receiver, UserHandle user, IntentFilter filter, @Nullable String broadcastPermission, @Nullable Handler scheduler)",
    "returnType" : "Intent",
    "comment" : "\n     * @hide\n     * Same as {@link #registerReceiver(BroadcastReceiver, IntentFilter, String, Handler)\n     * but for a specific user.  This receiver will receiver broadcasts that\n     * are sent to the requested user.\n     *\n     * @param receiver The BroadcastReceiver to handle the broadcast.\n     * @param user UserHandle to send the intent to.\n     * @param filter Selects the Intent broadcasts to be received.\n     * @param broadcastPermission String naming a permissions that a\n     *      broadcaster must hold in order to send an Intent to you.  If null,\n     *      no permission is required.\n     * @param scheduler Handler identifying the thread that will receive\n     *      the Intent.  If null, the main thread of the process will be used.\n     *\n     * @return The first sticky intent found that matches <var>filter</var>,\n     *         or null if there are none.\n     *\n     * @see #registerReceiver(BroadcastReceiver, IntentFilter, String, Handler)\n     * @see #sendBroadcast\n     * @see #unregisterReceiver\n     ",
    "links" : [ "#registerReceiver(BroadcastReceiver" ]
  }, {
    "name" : "public abstract Intent registerReceiverAsUser(BroadcastReceiver receiver, UserHandle user, IntentFilter filter, @Nullable String broadcastPermission, @Nullable Handler scheduler, @RegisterReceiverFlags int flags)",
    "returnType" : "Intent",
    "comment" : "\n     * @hide\n     * Same as {@link #registerReceiver(BroadcastReceiver, IntentFilter, String, Handler, int)\n     * but for a specific user.  This receiver will receiver broadcasts that\n     * are sent to the requested user.\n     *\n     * @param receiver The BroadcastReceiver to handle the broadcast.\n     * @param user UserHandle to send the intent to.\n     * @param filter Selects the Intent broadcasts to be received.\n     * @param broadcastPermission String naming a permissions that a\n     *      broadcaster must hold in order to send an Intent to you.  If null,\n     *      no permission is required.\n     * @param scheduler Handler identifying the thread that will receive\n     *      the Intent.  If null, the main thread of the process will be used.\n     * @param flags Additional options for the receiver. For apps targeting {@link\n     *      android.os.Build.VERSION_CODES#UPSIDE_DOWN_CAKE} either {@link #RECEIVER_EXPORTED} or\n     *      {@link #RECEIVER_NOT_EXPORTED} must be specified if the receiver isn't being registered\n     *      for <a href=\"{@docRoot}guide/components/broadcasts#system-broadcasts\">system\n     *      broadcasts</a> or a {@link SecurityException} will be thrown. If {@link\n     *      #RECEIVER_EXPORTED} is specified, a receiver may additionally specify {@link\n     *      #RECEIVER_VISIBLE_TO_INSTANT_APPS}. For a complete list of system broadcast actions,\n     *      see the BROADCAST_ACTIONS.TXT file in the Android SDK. If both {@link\n     *      #RECEIVER_EXPORTED} and {@link #RECEIVER_NOT_EXPORTED} are specified, an {@link\n     *      IllegalArgumentException} will be thrown.\n     *\n     * @return The first sticky intent found that matches <var>filter</var>,\n     *         or null if there are none.\n     *\n     * @see #registerReceiver(BroadcastReceiver, IntentFilter, String, Handler, int)\n     * @see #sendBroadcast\n     * @see #unregisterReceiver\n     ",
    "links" : [ "#RECEIVER_EXPORTED", "android.os.Build.VERSION_CODES#UPSIDE_DOWN_CAKE", "#RECEIVER_NOT_EXPORTED", "#RECEIVER_VISIBLE_TO_INSTANT_APPS", "SecurityException", "#registerReceiver(BroadcastReceiver", "IllegalArgumentException" ]
  }, {
    "name" : "public abstract void unregisterReceiver(BroadcastReceiver receiver)",
    "returnType" : "void",
    "comment" : "\n     * Unregister a previously registered BroadcastReceiver.  <em>All</em>\n     * filters that have been registered for this BroadcastReceiver will be\n     * removed.\n     *\n     * @param receiver The BroadcastReceiver to unregister.\n     *\n     * @throws IllegalArgumentException if the {@code receiver} was not previously registered or\n     *                                  already unregistered.\n     * @see #registerReceiver\n     ",
    "links" : [ ]
  }, {
    "name" : "public abstract ComponentName startService(Intent service)",
    "returnType" : "ComponentName",
    "comment" : "\n     * Request that a given application service be started.  The Intent\n     * should either contain the complete class name of a specific service\n     * implementation to start, or a specific package name to target.  If the\n     * Intent is less specified, it logs a warning about this.  In this case any of the\n     * multiple matching services may be used.  If this service\n     * is not already running, it will be instantiated and started (creating a\n     * process for it if needed); if it is running then it remains running.\n     *\n     * <p>Every call to this method will result in a corresponding call to\n     * the target service's {@link android.app.Service#onStartCommand} method,\n     * with the <var>intent</var> given here.  This provides a convenient way\n     * to submit jobs to a service without having to bind and call on to its\n     * interface.\n     *\n     * <p>Using startService() overrides the default service lifetime that is\n     * managed by {@link #bindService}: it requires the service to remain\n     * running until {@link #stopService} is called, regardless of whether\n     * any clients are connected to it.  Note that calls to startService()\n     * do not nest: no matter how many times you call startService(),\n     * a single call to {@link #stopService} will stop it.\n     *\n     * <p>The system attempts to keep running services around as much as\n     * possible.  The only time they should be stopped is if the current\n     * foreground application is using so many resources that the service needs\n     * to be killed.  If any errors happen in the service's process, it will\n     * automatically be restarted.\n     *\n     * <p>This function will throw {@link SecurityException} if you do not\n     * have permission to start the given service.\n     *\n     * <div class=\"caution\">\n     * <p><strong>Note:</strong> Each call to startService()\n     * results in significant work done by the system to manage service\n     * lifecycle surrounding the processing of the intent, which can take\n     * multiple milliseconds of CPU time. Due to this cost, startService()\n     * should not be used for frequent intent delivery to a service, and only\n     * for scheduling significant work. Use {@link #bindService bound services}\n     * for high frequency calls.\n     * </p>\n     *\n     * Beginning with SDK Version {@link android.os.Build.VERSION_CODES#O},\n     * apps targeting SDK Version {@link android.os.Build.VERSION_CODES#O}\n     * or higher are not allowed to start background services from the background.\n     * See\n     * <a href=\"/about/versions/oreo/background\">\n     * Background Execution Limits</a>\n     * for more details.\n     *\n     * <p><strong>Note:</strong>\n     * Beginning with SDK Version {@link android.os.Build.VERSION_CODES#S},\n     * apps targeting SDK Version {@link android.os.Build.VERSION_CODES#S}\n     * or higher are not allowed to start foreground services from the background.\n     * See\n     * <a href=\"/about/versions/12/behavior-changes-12\">\n     * Behavior changes: Apps targeting Android 12\n     * </a>\n     * for more details.\n     * </div>\n     *\n     * @param service Identifies the service to be started.  The Intent must be\n     *      fully explicit (supplying a component name).  Additional values\n     *      may be included in the Intent extras to supply arguments along with\n     *      this specific start call.\n     *\n     * @return If the service is being started or is already running, the\n     * {@link ComponentName} of the actual service that was started is\n     * returned; else if the service does not exist null is returned.\n     *\n     * @throws SecurityException If the caller does not have permission to access the service\n     * or the service can not be found.\n     * @throws IllegalStateException\n     * Before Android {@link android.os.Build.VERSION_CODES#S},\n     * if the application is in a state where the service\n     * can not be started (such as not in the foreground in a state when services are allowed),\n     * {@link IllegalStateException} was thrown.\n     * @throws android.app.BackgroundServiceStartNotAllowedException\n     * On Android {@link android.os.Build.VERSION_CODES#S} and later,\n     * if the application is in a state where the service\n     * can not be started (such as not in the foreground in a state when services are allowed),\n     * {@link android.app.BackgroundServiceStartNotAllowedException} is thrown.\n     * This exception extends {@link IllegalStateException}, so apps can\n     * use {@code catch (IllegalStateException)} to catch both.\n     *\n     * @see #startForegroundService(Intent)\n     * @see #stopService\n     * @see #bindService\n     ",
    "links" : [ "android.os.Build.VERSION_CODES#O", "IllegalStateException", "android.app.Service#onStartCommand", "android.os.Build.VERSION_CODES#S", "android.content.ComponentName", "#stopService", "#bindService", "SecurityException", "android.app.BackgroundServiceStartNotAllowedException" ]
  }, {
    "name" : "public abstract ComponentName startForegroundService(Intent service)",
    "returnType" : "ComponentName",
    "comment" : "\n     * Similar to {@link #startService(Intent)}, but with an implicit promise that the\n     * Service will call {@link android.app.Service#startForeground(int, android.app.Notification)\n     * startForeground(int, android.app.Notification)} once it begins running.  The service is given\n     * an amount of time comparable to the ANR interval to do this, otherwise the system\n     * will automatically crash the process, in which case an internal exception\n     * {@code ForegroundServiceDidNotStartInTimeException} is logged on logcat on devices\n     * running SDK Version {@link android.os.Build.VERSION_CODES#S} or later. On older Android\n     * versions, an internal exception {@code RemoteServiceException} is logged instead, with\n     * a corresponding message.\n     *\n     * <p>Unlike the ordinary {@link #startService(Intent)}, this method can be used\n     * at any time, regardless of whether the app hosting the service is in a foreground\n     * state.\n     *\n     * <div class=\"caution\">\n     * <p><strong>Note:</strong>\n     * Beginning with SDK Version {@link android.os.Build.VERSION_CODES#S},\n     * apps targeting SDK Version {@link android.os.Build.VERSION_CODES#S}\n     * or higher are not allowed to start foreground services from the background.\n     * See\n     * <a href=\"/about/versions/12/behavior-changes-12\">\n     * Behavior changes: Apps targeting Android 12\n     * </a>\n     * for more details.\n     * </div>\n     *\n     * @param service Identifies the service to be started.  The Intent must be\n     *      fully explicit (supplying a component name).  Additional values\n     *      may be included in the Intent extras to supply arguments along with\n     *      this specific start call.\n     *\n     * @return If the service is being started or is already running, the\n     * {@link ComponentName} of the actual service that was started is\n     * returned; else if the service does not exist null is returned.\n     *\n     * @throws SecurityException If the caller does not have permission to access the service\n     * or the service can not be found.\n     *\n     * @throws android.app.ForegroundServiceStartNotAllowedException\n     * If the caller app's targeting API is\n     * {@link android.os.Build.VERSION_CODES#S} or later, and the foreground service is restricted\n     * from start due to background restriction.\n     *\n     * @see #stopService\n     * @see android.app.Service#startForeground(int, android.app.Notification)\n     ",
    "links" : [ "android.os.Build.VERSION_CODES#S", "android.content.ComponentName", "android.app.Service#startForeground(int", "#startService(Intent)" ]
  }, {
    "name" : "public abstract ComponentName startForegroundServiceAsUser(Intent service, UserHandle user)",
    "returnType" : "ComponentName",
    "comment" : "\n     * @hide like {@link #startForegroundService(Intent)} but for a specific user.\n     ",
    "links" : [ "#startForegroundService(Intent)" ]
  }, {
    "name" : "public abstract boolean stopService(Intent service)",
    "returnType" : "boolean",
    "comment" : "\n     * Request that a given application service be stopped.  If the service is\n     * not running, nothing happens.  Otherwise it is stopped.  Note that calls\n     * to startService() are not counted -- this stops the service no matter\n     * how many times it was started.\n     *\n     * <p>If the service is running as a foreground service when it is\n     * stopped, its associated notification will be removed.  To avoid this,\n     * apps can use {@link android.app.Service#stopForeground(int)\n     * stopForeground(STOP_FOREGROUND_DETACH)} to decouple the notification\n     * from the service's lifecycle before stopping it.</p>\n     *\n     * <p>Note that if a stopped service still has {@link ServiceConnection}\n     * objects bound to it with the {@link #BIND_AUTO_CREATE} set, it will\n     * not be destroyed until all of these bindings are removed.  See\n     * the {@link android.app.Service} documentation for more details on a\n     * service's lifecycle.\n     *\n     * <p>This function will throw {@link SecurityException} if you do not\n     * have permission to stop the given service.\n     *\n     * @param service Description of the service to be stopped.  The Intent must be either\n     *      fully explicit (supplying a component name) or specify a specific package\n     *      name it is targeted to.\n     *\n     * @return If there is a service matching the given Intent that is already\n     * running, then it is stopped and {@code true} is returned; else {@code false} is returned.\n     *\n     * @throws SecurityException If the caller does not have permission to access the service\n     * or the service can not be found.\n     * @throws IllegalStateException If the application is in a state where the service\n     * can not be started (such as not in the foreground in a state when services are allowed).\n     *\n     * @see #startService\n     ",
    "links" : [ "android.app.Service", "android.app.Service#stopForeground(int)", "android.app.IServiceConnection", "SecurityException", "#BIND_AUTO_CREATE" ]
  }, {
    "name" : "public abstract ComponentName startServiceAsUser(Intent service, UserHandle user)",
    "returnType" : "ComponentName",
    "comment" : "\n     * @hide like {@link #startService(Intent)} but for a specific user.\n     ",
    "links" : [ "#startService(Intent)" ]
  }, {
    "name" : "public abstract boolean stopServiceAsUser(Intent service, UserHandle user)",
    "returnType" : "boolean",
    "comment" : "\n     * @hide like {@link #stopService(Intent)} but for a specific user.\n     ",
    "links" : [ "#stopService(Intent)" ]
  }, {
    "name" : "public abstract boolean bindService(@RequiresPermission @NonNull Intent service, @NonNull ServiceConnection conn, int flags)",
    "returnType" : "boolean",
    "comment" : "\n     * Connects to an application service, creating it if needed.  This defines\n     * a dependency between your application and the service.  The given\n     * <var>conn</var> will receive the service object when it is created and be\n     * told if it dies and restarts.  The service will be considered required\n     * by the system only for as long as the calling context exists.  For\n     * example, if this Context is an Activity that is stopped, the service will\n     * not be required to continue running until the Activity is resumed.\n     *\n     * <p>If the service does not support binding, it may return {@code null} from\n     * its {@link android.app.Service#onBind(Intent) onBind()} method.  If it does, then\n     * the ServiceConnection's\n     * {@link ServiceConnection#onNullBinding(ComponentName) onNullBinding()} method\n     * will be invoked instead of\n     * {@link ServiceConnection#onServiceConnected(ComponentName, IBinder) onServiceConnected()}.\n     *\n     * <p class=\"note\"><b>Note:</b> This method <em>cannot</em> be called from a\n     * {@link BroadcastReceiver} component.  A pattern you can use to\n     * communicate from a BroadcastReceiver to a Service is to call\n     * {@link #startService} with the arguments containing the command to be\n     * sent, with the service calling its\n     * {@link android.app.Service#stopSelf(int)} method when done executing\n     * that command.  See the API demo App/Service/Service Start Arguments\n     * Controller for an illustration of this.  It is okay, however, to use\n     * this method from a BroadcastReceiver that has been registered with\n     * {@link #registerReceiver}, since the lifetime of this BroadcastReceiver\n     * is tied to another object (the one that registered it).</p>\n     *\n     * <p>This method only accepts a int type flag, to pass in a long type flag, call\n     * {@link #bindService(Intent, ServiceConnection, BindServiceFlags)} instead.</p>\n     *\n     * @param service Identifies the service to connect to.  The Intent must\n     *      specify an explicit component name.\n     * @param conn Receives information as the service is started and stopped.\n     *      This must be a valid ServiceConnection object; it must not be null.\n     * @param flags Operation options for the binding. Can be:\n     *      <ul>\n     *          <li>0\n     *          <li>{@link #BIND_AUTO_CREATE}\n     *          <li>{@link #BIND_DEBUG_UNBIND}\n     *          <li>{@link #BIND_NOT_FOREGROUND}\n     *          <li>{@link #BIND_ABOVE_CLIENT}\n     *          <li>{@link #BIND_ALLOW_OOM_MANAGEMENT}\n     *          <li>{@link #BIND_WAIVE_PRIORITY}\n     *          <li>{@link #BIND_IMPORTANT}\n     *          <li>{@link #BIND_ADJUST_WITH_ACTIVITY}\n     *          <li>{@link #BIND_NOT_PERCEPTIBLE}\n     *          <li>{@link #BIND_INCLUDE_CAPABILITIES}\n     *      </ul>\n     *\n     * @return {@code true} if the system is in the process of bringing up a\n     *      service that your client has permission to bind to; {@code false}\n     *      if the system couldn't find the service or if your client doesn't\n     *      have permission to bind to it. Regardless of the return value, you\n     *      should later call {@link #unbindService} to release the connection.\n     *\n     * @throws SecurityException If the caller does not have permission to\n     *      access the service or the service cannot be found. Call\n     *      {@link #unbindService} to release the connection when this exception\n     *      is thrown.\n     *\n     * @see #unbindService\n     * @see #startService\n     ",
    "links" : [ "#bindService(Intent", "#BIND_WAIVE_PRIORITY", "#BIND_ADJUST_WITH_ACTIVITY", "#BIND_AUTO_CREATE", "android.content.BroadcastReceiver", "#BIND_DEBUG_UNBIND", "android.app.IServiceConnection#onNullBinding(ComponentName)", "#BIND_INCLUDE_CAPABILITIES", "#unbindService", "#BIND_ABOVE_CLIENT", "#registerReceiver", "android.app.IServiceConnection#onServiceConnected(ComponentName", "#BIND_IMPORTANT", "android.app.Service#stopSelf(int)", "#BIND_NOT_PERCEPTIBLE", "#startService", "android.app.Service#onBind(Intent)", "#BIND_ALLOW_OOM_MANAGEMENT", "#BIND_NOT_FOREGROUND" ]
  }, {
    "name" : "public boolean bindService(@RequiresPermission @NonNull Intent service, @NonNull ServiceConnection conn, @NonNull BindServiceFlags flags)",
    "returnType" : "boolean",
    "comment" : "\n     * See {@link #bindService(Intent, ServiceConnection, int)}\n     * Call {@link BindServiceFlags#of(long)} to obtain a BindServiceFlags object.\n     ",
    "links" : [ "#bindService(Intent", "#of(long)" ]
  }, {
    "name" : "public boolean bindService(@RequiresPermission @NonNull Intent service, @BindServiceFlagsBits int flags, @NonNull @CallbackExecutor Executor executor, @NonNull ServiceConnection conn)",
    "returnType" : "boolean",
    "comment" : "\n     * Same as {@link #bindService(Intent, ServiceConnection, int)\n     * bindService(Intent, ServiceConnection, int)} with executor to control ServiceConnection\n     * callbacks.\n     *\n     * <p>This method only accepts a 32 bits flag, to pass in a 64 bits flag, call\n     * {@link #bindService(Intent, BindServiceFlags, Executor, ServiceConnection)} instead.</p>\n     *\n     * @param executor Callbacks on ServiceConnection will be called on executor. Must use same\n     *      instance for the same instance of ServiceConnection.\n     *\n     * @return The result of the binding as described in\n     *      {@link #bindService(Intent, ServiceConnection, int)\n     *      bindService(Intent, ServiceConnection, int)}.\n     ",
    "links" : [ "#bindService(Intent" ]
  }, {
    "name" : "public boolean bindService(@RequiresPermission @NonNull Intent service, @NonNull BindServiceFlags flags, @NonNull @CallbackExecutor Executor executor, @NonNull ServiceConnection conn)",
    "returnType" : "boolean",
    "comment" : "\n     * See {@link #bindService(Intent, int, Executor, ServiceConnection)}\n     * Call {@link BindServiceFlags#of(long)} to obtain a BindServiceFlags object.\n     ",
    "links" : [ "#bindService(Intent", "#of(long)" ]
  }, {
    "name" : "public boolean bindIsolatedService(@RequiresPermission @NonNull Intent service, int flags, @NonNull String instanceName, @NonNull @CallbackExecutor Executor executor, @NonNull ServiceConnection conn)",
    "returnType" : "boolean",
    "comment" : "\n     * Variation of {@link #bindService} that, in the specific case of isolated\n     * services, allows the caller to generate multiple instances of a service\n     * from a single component declaration.  In other words, you can use this to bind\n     * to a service that has specified {@link android.R.attr#isolatedProcess} and, in\n     * addition to the existing behavior of running in an isolated process, you can\n     * also through the arguments here have the system bring up multiple concurrent\n     * processes hosting their own instances of that service.  The <var>instanceName</var>\n     * you provide here identifies the different instances, and you can use\n     * {@link #updateServiceGroup(ServiceConnection, int, int)} to tell the system how it\n     * should manage each of these instances.\n     *\n     * @param service Identifies the service to connect to.  The Intent must\n     *      specify an explicit component name.\n     * @param flags Operation options for the binding as per {@link #bindService}.\n     * @param instanceName Unique identifier for the service instance.  Each unique\n     *      name here will result in a different service instance being created.  Identifiers\n     *      must only contain ASCII letters, digits, underscores, and periods.\n     * @param executor Callbacks on ServiceConnection will be called on executor.\n     *      Must use same instance for the same instance of ServiceConnection.\n     * @param conn Receives information as the service is started and stopped.\n     *      This must be a valid ServiceConnection object; it must not be null.\n     *\n     * @return Returns success of binding as per {@link #bindService}.\n     *\n     * @throws SecurityException If the caller does not have permission to access the service\n     * @throws IllegalArgumentException If the instanceName is invalid.\n     *\n     * @see #bindService\n     * @see #updateServiceGroup\n     * @see android.R.attr#isolatedProcess\n     ",
    "links" : [ "#updateServiceGroup(ServiceConnection", "android.R.attr#isolatedProcess", "#bindService" ]
  }, {
    "name" : "public boolean bindIsolatedService(@RequiresPermission @NonNull Intent service, @NonNull BindServiceFlags flags, @NonNull String instanceName, @NonNull @CallbackExecutor Executor executor, @NonNull ServiceConnection conn)",
    "returnType" : "boolean",
    "comment" : "\n     * See {@link #bindIsolatedService(Intent, int, String, Executor,ServiceConnection)}\n     * Call {@link BindServiceFlags#of(long)} to obtain a BindServiceFlags object.\n     ",
    "links" : [ "#bindIsolatedService(Intent", "#of(long)" ]
  }, {
    "name" : "public boolean bindServiceAsUser(@NonNull @RequiresPermission Intent service, @NonNull ServiceConnection conn, int flags, @NonNull UserHandle user)",
    "returnType" : "boolean",
    "comment" : "\n     * Binds to a service in the given {@code user} in the same manner as {@link #bindService}.\n     *\n     * <p>Requires that one of the following conditions are met:\n     * <ul>\n     *  <li>caller has {@code android.Manifest.permission.INTERACT_ACROSS_USERS_FULL}</li>\n     *  <li>caller has {@code android.Manifest.permission.INTERACT_ACROSS_USERS} and is the same\n     *      package as the {@code service} (determined by its component's package) and the Android\n     *      version is at least {@link android.os.Build.VERSION_CODES#TIRAMISU}</li>\n     *  <li>caller has {@code android.Manifest.permission.INTERACT_ACROSS_USERS} and is in same\n     *      profile group as the given {@code user}</li>\n     *  <li>caller has {@code android.Manifest.permission.INTERACT_ACROSS_PROFILES} and is in same\n     *      profile group as the given {@code user} and is the same package as the {@code service}\n     *      </li>\n     * </ul>\n     *\n     * @param service Identifies the service to connect to.  The Intent must\n     *      specify an explicit component name.\n     * @param conn Receives information as the service is started and stopped.\n     *      This must be a valid ServiceConnection object; it must not be null.\n     * @param flags Operation options for the binding.  May be 0,\n     *          {@link #BIND_AUTO_CREATE}, {@link #BIND_DEBUG_UNBIND},\n     *          {@link #BIND_NOT_FOREGROUND}, {@link #BIND_ABOVE_CLIENT},\n     *          {@link #BIND_ALLOW_OOM_MANAGEMENT}, {@link #BIND_WAIVE_PRIORITY}.\n     *          {@link #BIND_IMPORTANT}, or\n     *          {@link #BIND_ADJUST_WITH_ACTIVITY}.\n     * @return {@code true} if the system is in the process of bringing up a\n     *         service that your client has permission to bind to; {@code false}\n     *         if the system couldn't find the service. You should call {@link #unbindService}\n     *         to release the connection even if this method returned {@code false}.\n     *\n     * @throws SecurityException if the client does not have the required permission to bind.\n     ",
    "links" : [ "android.os.Build.VERSION_CODES#TIRAMISU", "#unbindService", "#BIND_ABOVE_CLIENT", "#BIND_IMPORTANT", "#BIND_WAIVE_PRIORITY", "#bindService", "#BIND_ADJUST_WITH_ACTIVITY", "#BIND_AUTO_CREATE", "#BIND_ALLOW_OOM_MANAGEMENT", "#BIND_DEBUG_UNBIND", "#BIND_NOT_FOREGROUND" ]
  }, {
    "name" : "public boolean bindServiceAsUser(@NonNull @RequiresPermission Intent service, @NonNull ServiceConnection conn, @NonNull BindServiceFlags flags, @NonNull UserHandle user)",
    "returnType" : "boolean",
    "comment" : "\n     * See {@link #bindServiceAsUser(Intent, ServiceConnection, int, UserHandle)}\n     * Call {@link BindServiceFlags#of(long)} to obtain a BindServiceFlags object.\n     ",
    "links" : [ "#bindServiceAsUser(Intent", "#of(long)" ]
  }, {
    "name" : "public boolean bindServiceAsUser(Intent service, ServiceConnection conn, int flags, Handler handler, UserHandle user)",
    "returnType" : "boolean",
    "comment" : "\n     * Same as {@link #bindServiceAsUser(Intent, ServiceConnection, int, UserHandle)}, but with an\n     * explicit non-null Handler to run the ServiceConnection callbacks on.\n     * @hide\n     ",
    "links" : [ "#bindServiceAsUser(Intent" ]
  }, {
    "name" : "public boolean bindServiceAsUser(@NonNull Intent service, @NonNull ServiceConnection conn, @NonNull BindServiceFlags flags, @NonNull Handler handler, @NonNull UserHandle user)",
    "returnType" : "boolean",
    "comment" : "\n     * See {@link #bindServiceAsUser(Intent, ServiceConnection, int, Handler, UserHandle)}\n     * Call {@link BindServiceFlags#of(long)} to obtain a BindServiceFlags object.\n     * @hide\n     ",
    "links" : [ "#bindServiceAsUser(Intent", "#of(long)" ]
  }, {
    "name" : "public void updateServiceGroup(@NonNull ServiceConnection conn, int group, int importance)",
    "returnType" : "void",
    "comment" : "\n     * For a service previously bound with {@link #bindService} or a related method, change\n     * how the system manages that service's process in relation to other processes.  This\n     * doesn't modify the original bind flags that were passed in when binding, but adjusts\n     * how the process will be managed in some cases based on those flags.  Currently only\n     * works on isolated processes (will be ignored for non-isolated processes).\n     *\n     * <p>Note that this call does not take immediate effect, but will be applied the next\n     * time the impacted process is adjusted for some other reason.  Typically you would\n     * call this before then calling a new {@link #bindIsolatedService} on the service\n     * of interest, with that binding causing the process to be shuffled accordingly.</p>\n     *\n     * @param conn The connection interface previously supplied to bindService().  This\n     *             parameter must not be null.\n     * @param group A group to put this connection's process in.  Upon calling here, this\n     *              will override any previous group that was set for that process.  The group\n     *              tells the system about processes that are logically grouped together, so\n     *              should be managed as one unit of importance (such as when being considered\n     *              a recently used app).  All processes in the same app with the same group\n     *              are considered to be related.  Supplying 0 reverts to the default behavior\n     *              of not grouping.\n     * @param importance Additional importance of the processes within a group.  Upon calling\n     *                   here, this will override any previous importance that was set for that\n     *                   process.  The most important process is 0, and higher values are\n     *                   successively less important.  You can view this as describing how\n     *                   to order the processes in an array, with the processes at the end of\n     *                   the array being the least important.  This value has no meaning besides\n     *                   indicating how processes should be ordered in that array one after the\n     *                   other.  This provides a way to fine-tune the system's process killing,\n     *                   guiding it to kill processes at the end of the array first.\n     *\n     * @see #bindIsolatedService\n     ",
    "links" : [ "#bindIsolatedService", "#bindService" ]
  }, {
    "name" : "public abstract void unbindService(@NonNull ServiceConnection conn)",
    "returnType" : "void",
    "comment" : "\n     * Disconnect from an application service.  You will no longer receive\n     * calls as the service is restarted, and the service is now allowed to\n     * stop at any time.\n     *\n     * @param conn The connection interface previously supplied to\n     *             bindService().  This parameter must not be null.\n     *\n     * @see #bindService\n     ",
    "links" : [ ]
  }, {
    "name" : "public abstract boolean startInstrumentation(@NonNull ComponentName className, @Nullable String profileFile, @Nullable Bundle arguments)",
    "returnType" : "boolean",
    "comment" : "\n     * Start executing an {@link android.app.Instrumentation} class.  The given\n     * Instrumentation component will be run by killing its target application\n     * (if currently running), starting the target process, instantiating the\n     * instrumentation component, and then letting it drive the application.\n     *\n     * <p>This function is not synchronous -- it returns as soon as the\n     * instrumentation has started and while it is running.\n     *\n     * <p>Instrumentation is normally only allowed to run against a package\n     * that is either unsigned or signed with a signature that the\n     * the instrumentation package is also signed with (ensuring the target\n     * trusts the instrumentation).\n     *\n     * @param className Name of the Instrumentation component to be run.\n     * @param profileFile Optional path to write profiling data as the\n     * instrumentation runs, or null for no profiling.\n     * @param arguments Additional optional arguments to pass to the\n     * instrumentation, or null.\n     *\n     * @return {@code true} if the instrumentation was successfully started,\n     * else {@code false} if it could not be found.\n     ",
    "links" : [ "android.app.Instrumentation" ]
  }, {
    "name" : "public abstract Object getSystemService(@ServiceName @NonNull String name)",
    "returnType" : "Object",
    "comment" : "\n     * Return the handle to a system-level service by name. The class of the\n     * returned object varies by the requested name. Currently available names\n     * are:\n     *\n     * <dl>\n     *  <dt> {@link #WINDOW_SERVICE} (\"window\")\n     *  <dd> The top-level window manager in which you can place custom\n     *  windows.  The returned object is a {@link android.view.WindowManager}. Must only be obtained\n     *  from a visual context such as Activity or a Context created with\n     *  {@link #createWindowContext(int, Bundle)}, which are adjusted to the configuration and\n     *  visual bounds of an area on screen.\n     *  <dt> {@link #LAYOUT_INFLATER_SERVICE} (\"layout_inflater\")\n     *  <dd> A {@link android.view.LayoutInflater} for inflating layout resources\n     *  in this context. Must only be obtained from a visual context such as Activity or a Context\n     *  created with {@link #createWindowContext(int, Bundle)}, which are adjusted to the\n     *  configuration and visual bounds of an area on screen.\n     *  <dt> {@link #ACTIVITY_SERVICE} (\"activity\")\n     *  <dd> A {@link android.app.ActivityManager} for interacting with the\n     *  global activity state of the system.\n     *  <dt> {@link #WALLPAPER_SERVICE} (\"wallpaper\")\n     *  <dd> A {@link android.service.wallpaper.WallpaperService} for accessing wallpapers in this\n     *  context. Must only be obtained from a visual context such as Activity or a Context created\n     *  with {@link #createWindowContext(int, Bundle)}, which are adjusted to the configuration and\n     *  visual bounds of an area on screen.\n     *  <dt> {@link #POWER_SERVICE} (\"power\")\n     *  <dd> A {@link android.os.PowerManager} for controlling power\n     *  management.\n     *  <dt> {@link #ALARM_SERVICE} (\"alarm\")\n     *  <dd> A {@link android.app.AlarmManager} for receiving intents at the\n     *  time of your choosing.\n     *  <dt> {@link #NOTIFICATION_SERVICE} (\"notification\")\n     *  <dd> A {@link android.app.NotificationManager} for informing the user\n     *   of background events.\n     *  <dt> {@link #KEYGUARD_SERVICE} (\"keyguard\")\n     *  <dd> A {@link android.app.KeyguardManager} for controlling keyguard.\n     *  <dt> {@link #LOCATION_SERVICE} (\"location\")\n     *  <dd> A {@link android.location.LocationManager} for controlling location\n     *   (e.g., GPS) updates.\n     *  <dt> {@link #SEARCH_SERVICE} (\"search\")\n     *  <dd> A {@link android.app.SearchManager} for handling search.\n     *  <dt> {@link #VIBRATOR_MANAGER_SERVICE} (\"vibrator_manager\")\n     *  <dd> A {@link android.os.VibratorManager} for accessing the device vibrators, interacting\n     *  with individual ones and playing synchronized effects on multiple vibrators.\n     *  <dt> {@link #VIBRATOR_SERVICE} (\"vibrator\")\n     *  <dd> A {@link android.os.Vibrator} for interacting with the vibrator hardware.\n     *  <dt> {@link #CONNECTIVITY_SERVICE} (\"connectivity\")\n     *  <dd> A {@link android.net.ConnectivityManager ConnectivityManager} for\n     *  handling management of network connections.\n     *  <dt> {@link #IPSEC_SERVICE} (\"ipsec\")\n     *  <dd> A {@link android.net.IpSecManager IpSecManager} for managing IPSec on\n     *  sockets and networks.\n     *  <dt> {@link #WIFI_SERVICE} (\"wifi\")\n     *  <dd> A {@link android.net.wifi.WifiManager WifiManager} for management of Wi-Fi\n     *  connectivity.  On releases before Android 7, it should only be obtained from an application\n     *  context, and not from any other derived context to avoid memory leaks within the calling\n     *  process.\n     *  <dt> {@link #WIFI_AWARE_SERVICE} (\"wifiaware\")\n     *  <dd> A {@link android.net.wifi.aware.WifiAwareManager WifiAwareManager} for management of\n     * Wi-Fi Aware discovery and connectivity.\n     *  <dt> {@link #WIFI_P2P_SERVICE} (\"wifip2p\")\n     *  <dd> A {@link android.net.wifi.p2p.WifiP2pManager WifiP2pManager} for management of\n     * Wi-Fi Direct connectivity.\n     * <dt> {@link #INPUT_METHOD_SERVICE} (\"input_method\")\n     * <dd> An {@link android.view.inputmethod.InputMethodManager InputMethodManager}\n     * for management of input methods.\n     * <dt> {@link #UI_MODE_SERVICE} (\"uimode\")\n     * <dd> An {@link android.app.UiModeManager} for controlling UI modes.\n     * <dt> {@link #DOWNLOAD_SERVICE} (\"download\")\n     * <dd> A {@link android.app.DownloadManager} for requesting HTTP downloads\n     * <dt> {@link #BATTERY_SERVICE} (\"batterymanager\")\n     * <dd> A {@link android.os.BatteryManager} for managing battery state\n     * <dt> {@link #JOB_SCHEDULER_SERVICE} (\"taskmanager\")\n     * <dd>  A {@link android.app.job.JobScheduler} for managing scheduled tasks\n     * <dt> {@link #NETWORK_STATS_SERVICE} (\"netstats\")\n     * <dd> A {@link android.app.usage.NetworkStatsManager NetworkStatsManager} for querying network\n     * usage statistics.\n     * <dt> {@link #HARDWARE_PROPERTIES_SERVICE} (\"hardware_properties\")\n     * <dd> A {@link android.os.HardwarePropertiesManager} for accessing hardware properties.\n     * <dt> {@link #DOMAIN_VERIFICATION_SERVICE} (\"domain_verification\")\n     * <dd> A {@link android.content.pm.verify.domain.DomainVerificationManager} for accessing\n     * web domain approval state.\n     * <dt> {@link #DISPLAY_HASH_SERVICE} (\"display_hash\")\n     * <dd> A {@link android.view.displayhash.DisplayHashManager} for management of display hashes.\n     * </dl>\n     *\n     * <p>Note:  System services obtained via this API may be closely associated with\n     * the Context in which they are obtained from.  In general, do not share the\n     * service objects between various different contexts (Activities, Applications,\n     * Services, Providers, etc.)\n     *\n     * <p>Note: Instant apps, for which {@link PackageManager#isInstantApp()} returns true,\n     * don't have access to the following system services: {@link #DEVICE_POLICY_SERVICE},\n     * {@link #FINGERPRINT_SERVICE}, {@link #KEYGUARD_SERVICE}, {@link #SHORTCUT_SERVICE},\n     * {@link #USB_SERVICE}, {@link #WALLPAPER_SERVICE}, {@link #WIFI_P2P_SERVICE},\n     * {@link #WIFI_SERVICE}, {@link #WIFI_AWARE_SERVICE}. For these services this method will\n     * return <code>null</code>.  Generally, if you are running as an instant app you should always\n     * check whether the result of this method is {@code null}.\n     *\n     * <p>Note: When implementing this method, keep in mind that new services can be added on newer\n     * Android releases, so if you're looking for just the explicit names mentioned above, make sure\n     * to return {@code null} when you don't recognize the name &mdash; if you throw a\n     * {@link RuntimeException} exception instead, your app might break on new Android releases.\n     *\n     * @param name The name of the desired service.\n     *\n     * @return The service or {@code null} if the name does not exist.\n     *\n     * @see #WINDOW_SERVICE\n     * @see android.view.WindowManager\n     * @see #LAYOUT_INFLATER_SERVICE\n     * @see android.view.LayoutInflater\n     * @see #ACTIVITY_SERVICE\n     * @see android.app.ActivityManager\n     * @see #POWER_SERVICE\n     * @see android.os.PowerManager\n     * @see #ALARM_SERVICE\n     * @see android.app.AlarmManager\n     * @see #NOTIFICATION_SERVICE\n     * @see android.app.NotificationManager\n     * @see #KEYGUARD_SERVICE\n     * @see android.app.KeyguardManager\n     * @see #LOCATION_SERVICE\n     * @see android.location.LocationManager\n     * @see #SEARCH_SERVICE\n     * @see android.app.SearchManager\n     * @see #SENSOR_SERVICE\n     * @see android.hardware.SensorManager\n     * @see #STORAGE_SERVICE\n     * @see android.os.storage.StorageManager\n     * @see #VIBRATOR_MANAGER_SERVICE\n     * @see android.os.VibratorManager\n     * @see #VIBRATOR_SERVICE\n     * @see android.os.Vibrator\n     * @see #CONNECTIVITY_SERVICE\n     * @see android.net.ConnectivityManager\n     * @see #WIFI_SERVICE\n     * @see android.net.wifi.WifiManager\n     * @see #AUDIO_SERVICE\n     * @see android.media.AudioManager\n     * @see #MEDIA_ROUTER_SERVICE\n     * @see android.media.MediaRouter\n     * @see #TELEPHONY_SERVICE\n     * @see android.telephony.TelephonyManager\n     * @see #TELEPHONY_SUBSCRIPTION_SERVICE\n     * @see android.telephony.SubscriptionManager\n     * @see #CARRIER_CONFIG_SERVICE\n     * @see android.telephony.CarrierConfigManager\n     * @see #EUICC_SERVICE\n     * @see android.telephony.euicc.EuiccManager\n     * @see #INPUT_METHOD_SERVICE\n     * @see android.view.inputmethod.InputMethodManager\n     * @see #UI_MODE_SERVICE\n     * @see android.app.UiModeManager\n     * @see #DOWNLOAD_SERVICE\n     * @see android.app.DownloadManager\n     * @see #BATTERY_SERVICE\n     * @see android.os.BatteryManager\n     * @see #JOB_SCHEDULER_SERVICE\n     * @see android.app.job.JobScheduler\n     * @see #NETWORK_STATS_SERVICE\n     * @see android.app.usage.NetworkStatsManager\n     * @see android.os.HardwarePropertiesManager\n     * @see #HARDWARE_PROPERTIES_SERVICE\n     * @see #DOMAIN_VERIFICATION_SERVICE\n     * @see android.content.pm.verify.domain.DomainVerificationManager\n     * @see #DISPLAY_HASH_SERVICE\n     * @see android.view.displayhash.DisplayHashManager\n     ",
    "links" : [ "android.app.KeyguardManager", "#SHORTCUT_SERVICE", "#VIBRATOR_MANAGER_SERVICE", "android.view.WindowManager", "#WINDOW_SERVICE", "#WIFI_AWARE_SERVICE", "#IPSEC_SERVICE", "android.os.PowerManager", "android.app.UiModeManager", "#DOMAIN_VERIFICATION_SERVICE", "#LOCATION_SERVICE", "android.net.ConnectivityManager", "android.service.wallpaper.WallpaperService", "android.app.NotificationManager", "android.app.usage.NetworkStatsManager", "android.net.IpSecManager", "android.app.job.JobScheduler", "android.net.wifi.aware.WifiAwareManager", "android.content.pm.PackageManager#isInstantApp()", "#DEVICE_POLICY_SERVICE", "#FINGERPRINT_SERVICE", "android.app.DownloadManager", "#ACTIVITY_SERVICE", "#HARDWARE_PROPERTIES_SERVICE", "#createWindowContext(int", "#WIFI_SERVICE", "android.location.LocationManager", "android.app.SearchManager", "#DOWNLOAD_SERVICE", "android.app.ActivityManager", "android.os.HardwarePropertiesManager", "android.os.BatteryManager", "#SEARCH_SERVICE", "#JOB_SCHEDULER_SERVICE", "android.view.inputmethod.InputMethodManager", "RuntimeException", "#INPUT_METHOD_SERVICE", "#NETWORK_STATS_SERVICE", "android.content.pm.verify.domain.DomainVerificationManager", "#DISPLAY_HASH_SERVICE", "#VIBRATOR_SERVICE", "#POWER_SERVICE", "#WIFI_P2P_SERVICE", "android.view.displayhash.DisplayHashManager", "#ALARM_SERVICE", "#LAYOUT_INFLATER_SERVICE", "android.app.AlarmManager", "#CONNECTIVITY_SERVICE", "android.view.LayoutInflater", "#NOTIFICATION_SERVICE", "#BATTERY_SERVICE", "android.net.wifi.WifiManager", "#KEYGUARD_SERVICE", "android.net.wifi.p2p.WifiP2pManager", "android.os.VibratorManager", "#USB_SERVICE", "android.os.Vibrator", "#WALLPAPER_SERVICE", "#UI_MODE_SERVICE" ]
  }, {
    "name" : "public final T getSystemService(@NonNull Class<T> serviceClass)",
    "returnType" : "T",
    "comment" : "\n     * Return the handle to a system-level service by class.\n     * <p>\n     * Currently available classes are:\n     * {@link android.view.WindowManager}, {@link android.view.LayoutInflater},\n     * {@link android.app.ActivityManager}, {@link android.os.PowerManager},\n     * {@link android.app.AlarmManager}, {@link android.app.NotificationManager},\n     * {@link android.app.KeyguardManager}, {@link android.location.LocationManager},\n     * {@link android.app.SearchManager}, {@link android.os.Vibrator},\n     * {@link android.net.ConnectivityManager},\n     * {@link android.net.wifi.WifiManager},\n     * {@link android.media.AudioManager}, {@link android.media.MediaRouter},\n     * {@link android.telephony.TelephonyManager}, {@link android.telephony.SubscriptionManager},\n     * {@link android.view.inputmethod.InputMethodManager},\n     * {@link android.app.UiModeManager}, {@link android.app.DownloadManager},\n     * {@link android.os.BatteryManager}, {@link android.app.job.JobScheduler},\n     * {@link android.app.usage.NetworkStatsManager},\n     * {@link android.content.pm.verify.domain.DomainVerificationManager},\n     * {@link android.view.displayhash.DisplayHashManager}.\n     * </p>\n     *\n     * <p>\n     * Note: System services obtained via this API may be closely associated with\n     * the Context in which they are obtained from.  In general, do not share the\n     * service objects between various different contexts (Activities, Applications,\n     * Services, Providers, etc.)\n     * </p>\n     *\n     * <p>Note: Instant apps, for which {@link PackageManager#isInstantApp()} returns true,\n     * don't have access to the following system services: {@link #DEVICE_POLICY_SERVICE},\n     * {@link #FINGERPRINT_SERVICE}, {@link #KEYGUARD_SERVICE}, {@link #SHORTCUT_SERVICE},\n     * {@link #USB_SERVICE}, {@link #WALLPAPER_SERVICE}, {@link #WIFI_P2P_SERVICE},\n     * {@link #WIFI_SERVICE}, {@link #WIFI_AWARE_SERVICE}. For these services this method will\n     * return {@code null}. Generally, if you are running as an instant app you should always\n     * check whether the result of this method is {@code null}.\n     * </p>\n     *\n     * @param serviceClass The class of the desired service.\n     * @return The service or {@code null} if the class is not a supported system service. Note:\n     * <b>never</b> throw a {@link RuntimeException} if the name is not supported.\n     ",
    "links" : [ "android.app.KeyguardManager", "android.app.ActivityManager", "#SHORTCUT_SERVICE", "android.os.BatteryManager", "android.view.WindowManager", "android.media.AudioManager", "android.view.inputmethod.InputMethodManager", "#WIFI_AWARE_SERVICE", "android.os.PowerManager", "android.app.UiModeManager", "RuntimeException", "android.telephony.SubscriptionManager", "android.content.pm.verify.domain.DomainVerificationManager", "android.telephony.TelephonyManager", "android.net.ConnectivityManager", "#WIFI_P2P_SERVICE", "android.view.displayhash.DisplayHashManager", "android.app.NotificationManager", "android.app.usage.NetworkStatsManager", "android.app.AlarmManager", "android.view.LayoutInflater", "android.app.job.JobScheduler", "android.content.pm.PackageManager#isInstantApp()", "#DEVICE_POLICY_SERVICE", "#FINGERPRINT_SERVICE", "android.app.DownloadManager", "android.net.wifi.WifiManager", "#KEYGUARD_SERVICE", "android.media.MediaRouter", "#WIFI_SERVICE", "#USB_SERVICE", "android.os.Vibrator", "android.location.LocationManager", "android.app.SearchManager", "#WALLPAPER_SERVICE" ]
  }, {
    "name" : "public abstract String getSystemServiceName(@NonNull Class<?> serviceClass)",
    "returnType" : "String",
    "comment" : "\n     * Gets the name of the system-level service that is represented by the specified class.\n     *\n     * @param serviceClass The class of the desired service.\n     * @return The service name or null if the class is not a supported system service.\n     ",
    "links" : [ ]
  }, {
    "name" : "public abstract int checkPermission(@NonNull @PermissionName String permission, int pid, int uid)",
    "returnType" : "int",
    "comment" : "\n     * Determine whether the given permission is allowed for a particular\n     * process and user ID running in the system.\n     *\n     * @param permission The name of the permission being checked.\n     * @param pid The process ID being checked against.  Must be > 0.\n     * @param uid The UID being checked against.  A uid of 0 is the root\n     * user, which will pass every permission check.\n     *\n     * @return {@link PackageManager#PERMISSION_GRANTED} if the given\n     * pid/uid is allowed that permission, or\n     * {@link PackageManager#PERMISSION_DENIED} if it is not.\n     *\n     * @see PackageManager#checkPermission(String, String)\n     * @see #checkCallingPermission\n     ",
    "links" : [ "android.content.pm.PackageManager#PERMISSION_DENIED", "android.content.pm.PackageManager#PERMISSION_GRANTED" ]
  }, {
    "name" : "public abstract int checkPermission(@NonNull String permission, int pid, int uid, IBinder callerToken)",
    "returnType" : "int",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "public abstract int checkCallingPermission(@NonNull @PermissionName String permission)",
    "returnType" : "int",
    "comment" : "\n     * Determine whether the calling process of an IPC you are handling has been\n     * granted a particular permission.  This is basically the same as calling\n     * {@link #checkPermission(String, int, int)} with the pid and uid returned\n     * by {@link android.os.Binder#getCallingPid} and\n     * {@link android.os.Binder#getCallingUid}.  One important difference\n     * is that if you are not currently processing an IPC, this function\n     * will always fail.  This is done to protect against accidentally\n     * leaking permissions; you can use {@link #checkCallingOrSelfPermission}\n     * to avoid this protection.\n     *\n     * @param permission The name of the permission being checked.\n     *\n     * @return {@link PackageManager#PERMISSION_GRANTED} if the calling\n     * pid/uid is allowed that permission, or\n     * {@link PackageManager#PERMISSION_DENIED} if it is not.\n     *\n     * @see PackageManager#checkPermission(String, String)\n     * @see #checkPermission\n     * @see #checkCallingOrSelfPermission\n     ",
    "links" : [ "#checkCallingOrSelfPermission", "#checkPermission(String", "android.content.pm.PackageManager#PERMISSION_DENIED", "android.content.pm.PackageManager#PERMISSION_GRANTED", "android.os.Binder#getCallingPid", "android.os.Binder#getCallingUid" ]
  }, {
    "name" : "public abstract int checkCallingOrSelfPermission(@NonNull @PermissionName String permission)",
    "returnType" : "int",
    "comment" : "\n     * Determine whether the calling process of an IPC <em>or you</em> have been\n     * granted a particular permission.  This is the same as\n     * {@link #checkCallingPermission}, except it grants your own permissions\n     * if you are not currently processing an IPC.  Use with care!\n     *\n     * @param permission The name of the permission being checked.\n     *\n     * @return {@link PackageManager#PERMISSION_GRANTED} if the calling\n     * pid/uid is allowed that permission, or\n     * {@link PackageManager#PERMISSION_DENIED} if it is not.\n     *\n     * @see PackageManager#checkPermission(String, String)\n     * @see #checkPermission\n     * @see #checkCallingPermission\n     ",
    "links" : [ "android.content.pm.PackageManager#PERMISSION_DENIED", "android.content.pm.PackageManager#PERMISSION_GRANTED", "#checkCallingPermission" ]
  }, {
    "name" : "public abstract int checkSelfPermission(@NonNull String permission)",
    "returnType" : "int",
    "comment" : "\n     * Determine whether <em>you</em> have been granted a particular permission.\n     *\n     * @param permission The name of the permission being checked.\n     *\n     * @return {@link PackageManager#PERMISSION_GRANTED} if you have the\n     * permission, or {@link PackageManager#PERMISSION_DENIED} if not.\n     *\n     * @see PackageManager#checkPermission(String, String)\n     * @see #checkCallingPermission(String)\n     ",
    "links" : [ "android.content.pm.PackageManager#PERMISSION_DENIED", "android.content.pm.PackageManager#PERMISSION_GRANTED" ]
  }, {
    "name" : "public abstract void enforcePermission(@NonNull @PermissionName String permission, int pid, int uid, @Nullable String message)",
    "returnType" : "void",
    "comment" : "\n     * If the given permission is not allowed for a particular process\n     * and user ID running in the system, throw a {@link SecurityException}.\n     *\n     * @param permission The name of the permission being checked.\n     * @param pid The process ID being checked against.  Must be &gt; 0.\n     * @param uid The UID being checked against.  A uid of 0 is the root\n     * user, which will pass every permission check.\n     * @param message A message to include in the exception if it is thrown.\n     *\n     * @see #checkPermission(String, int, int)\n     ",
    "links" : [ "SecurityException" ]
  }, {
    "name" : "public abstract void enforceCallingPermission(@NonNull @PermissionName String permission, @Nullable String message)",
    "returnType" : "void",
    "comment" : "\n     * If the calling process of an IPC you are handling has not been\n     * granted a particular permission, throw a {@link\n     * SecurityException}.  This is basically the same as calling\n     * {@link #enforcePermission(String, int, int, String)} with the\n     * pid and uid returned by {@link android.os.Binder#getCallingPid}\n     * and {@link android.os.Binder#getCallingUid}.  One important\n     * difference is that if you are not currently processing an IPC,\n     * this function will always throw the SecurityException.  This is\n     * done to protect against accidentally leaking permissions; you\n     * can use {@link #enforceCallingOrSelfPermission} to avoid this\n     * protection.\n     *\n     * @param permission The name of the permission being checked.\n     * @param message A message to include in the exception if it is thrown.\n     *\n     * @see #checkCallingPermission(String)\n     ",
    "links" : [ "#enforceCallingOrSelfPermission", "android.os.Binder#getCallingPid", "#enforcePermission(String", "SecurityException", "android.os.Binder#getCallingUid" ]
  }, {
    "name" : "public abstract void enforceCallingOrSelfPermission(@NonNull @PermissionName String permission, @Nullable String message)",
    "returnType" : "void",
    "comment" : "\n     * If neither you nor the calling process of an IPC you are\n     * handling has been granted a particular permission, throw a\n     * {@link SecurityException}.  This is the same as {@link\n     * #enforceCallingPermission}, except it grants your own\n     * permissions if you are not currently processing an IPC.  Use\n     * with care!\n     *\n     * @param permission The name of the permission being checked.\n     * @param message A message to include in the exception if it is thrown.\n     *\n     * @see #checkCallingOrSelfPermission(String)\n     ",
    "links" : [ "#enforceCallingPermission", "SecurityException" ]
  }, {
    "name" : "public abstract void grantUriPermission(String toPackage, Uri uri, @Intent.GrantUriMode int modeFlags)",
    "returnType" : "void",
    "comment" : "\n     * Grant permission to access a specific Uri to another package, regardless\n     * of whether that package has general permission to access the Uri's\n     * content provider.  This can be used to grant specific, temporary\n     * permissions, typically in response to user interaction (such as the\n     * user opening an attachment that you would like someone else to\n     * display).\n     *\n     * <p>Normally you should use {@link Intent#FLAG_GRANT_READ_URI_PERMISSION\n     * Intent.FLAG_GRANT_READ_URI_PERMISSION} or\n     * {@link Intent#FLAG_GRANT_WRITE_URI_PERMISSION\n     * Intent.FLAG_GRANT_WRITE_URI_PERMISSION} with the Intent being used to\n     * start an activity instead of this function directly.  If you use this\n     * function directly, you should be sure to call\n     * {@link #revokeUriPermission} when the target should no longer be allowed\n     * to access it.\n     *\n     * <p>To succeed, the content provider owning the Uri must have set the\n     * {@link android.R.styleable#AndroidManifestProvider_grantUriPermissions\n     * grantUriPermissions} attribute in its manifest or included the\n     * {@link android.R.styleable#AndroidManifestGrantUriPermission\n     * &lt;grant-uri-permissions&gt;} tag.\n     *\n     * @param toPackage The package you would like to allow to access the Uri.\n     * @param uri The Uri you would like to grant access to.\n     * @param modeFlags The desired access modes.\n     *\n     * @see #revokeUriPermission\n     ",
    "links" : [ "android.content.Intent#FLAG_GRANT_WRITE_URI_PERMISSIONIntent.FLAG_GRANT_WRITE_URI_PERMISSION", "android.content.Intent#FLAG_GRANT_READ_URI_PERMISSIONIntent.FLAG_GRANT_READ_URI_PERMISSION", "#revokeUriPermission", "android.R.styleable#AndroidManifestProvider_grantUriPermissionsgrantUriPermissions", "android.R.styleable#AndroidManifestGrantUriPermission" ]
  }, {
    "name" : "public abstract void revokeUriPermission(Uri uri, @Intent.AccessUriMode int modeFlags)",
    "returnType" : "void",
    "comment" : "\n     * Remove all permissions to access a particular content provider Uri\n     * that were previously added with {@link #grantUriPermission} or <em>any other</em> mechanism.\n     * The given Uri will match all previously granted Uris that are the same or a\n     * sub-path of the given Uri.  That is, revoking \"content://foo/target\" will\n     * revoke both \"content://foo/target\" and \"content://foo/target/sub\", but not\n     * \"content://foo\".  It will not remove any prefix grants that exist at a\n     * higher level.\n     *\n     * <p>Prior to {@link android.os.Build.VERSION_CODES#LOLLIPOP}, if you did not have\n     * regular permission access to a Uri, but had received access to it through\n     * a specific Uri permission grant, you could not revoke that grant with this\n     * function and a {@link SecurityException} would be thrown.  As of\n     * {@link android.os.Build.VERSION_CODES#LOLLIPOP}, this function will not throw a security\n     * exception, but will remove whatever permission grants to the Uri had been given to the app\n     * (or none).</p>\n     *\n     * <p>Unlike {@link #revokeUriPermission(String, Uri, int)}, this method impacts all permission\n     * grants matching the given Uri, for any package they had been granted to, through any\n     * mechanism this had happened (such as indirectly through the clipboard, activity launch,\n     * service start, etc).  That means this can be potentially dangerous to use, as it can\n     * revoke grants that another app could be strongly expecting to stick around.</p>\n     *\n     * @param uri The Uri you would like to revoke access to.\n     * @param modeFlags The access modes to revoke.\n     *\n     * @see #grantUriPermission\n     ",
    "links" : [ "#grantUriPermission", "android.os.Build.VERSION_CODES#LOLLIPOP", "#revokeUriPermission(String", "SecurityException" ]
  }, {
    "name" : "public abstract void revokeUriPermission(String toPackage, Uri uri, @Intent.AccessUriMode int modeFlags)",
    "returnType" : "void",
    "comment" : "\n     * Remove permissions to access a particular content provider Uri\n     * that were previously added with {@link #grantUriPermission} for a specific target\n     * package.  The given Uri will match all previously granted Uris that are the same or a\n     * sub-path of the given Uri.  That is, revoking \"content://foo/target\" will\n     * revoke both \"content://foo/target\" and \"content://foo/target/sub\", but not\n     * \"content://foo\".  It will not remove any prefix grants that exist at a\n     * higher level.\n     *\n     * <p>Unlike {@link #revokeUriPermission(Uri, int)}, this method will <em>only</em>\n     * revoke permissions that had been explicitly granted through {@link #grantUriPermission}\n     * and only for the package specified.  Any matching grants that have happened through\n     * other mechanisms (clipboard, activity launching, service starting, etc) will not be\n     * removed.</p>\n     *\n     * @param toPackage The package you had previously granted access to.\n     * @param uri The Uri you would like to revoke access to.\n     * @param modeFlags The access modes to revoke.\n     *\n     * @see #grantUriPermission\n     ",
    "links" : [ "#revokeUriPermission(Uri", "#grantUriPermission" ]
  }, {
    "name" : "public abstract int checkUriPermission(Uri uri, int pid, int uid, @Intent.AccessUriMode int modeFlags)",
    "returnType" : "int",
    "comment" : "\n     * Determine whether a particular process and uid has been granted\n     * permission to access a specific URI.  This only checks for permissions\n     * that have been explicitly granted -- if the given process/uid has\n     * more general access to the URI's content provider then this check will\n     * always fail.\n     *\n     * @param uri The uri that is being checked.\n     * @param pid The process ID being checked against.  Must be &gt; 0.\n     * @param uid The UID being checked against.  A uid of 0 is the root\n     * user, which will pass every permission check.\n     * @param modeFlags The access modes to check.\n     *\n     * @return {@link PackageManager#PERMISSION_GRANTED} if the given\n     * pid/uid is allowed to access that uri, or\n     * {@link PackageManager#PERMISSION_DENIED} if it is not.\n     *\n     * @see #checkCallingUriPermission\n     ",
    "links" : [ "android.content.pm.PackageManager#PERMISSION_DENIED", "android.content.pm.PackageManager#PERMISSION_GRANTED" ]
  }, {
    "name" : "public int checkContentUriPermissionFull(@NonNull Uri uri, int pid, int uid, @Intent.AccessUriMode int modeFlags)",
    "returnType" : "int",
    "comment" : "\n     * Determine whether a particular process and uid has been granted\n     * permission to access a specific content URI.\n     *\n     * <p>Unlike {@link #checkUriPermission(Uri, int, int, int)}, this method\n     * checks for general access to the URI's content provider, as well as\n     * explicitly granted permissions.</p>\n     *\n     * <p>Note, this check will throw an {@link IllegalArgumentException}\n     * for non-content URIs.</p>\n     *\n     * @param uri The content uri that is being checked.\n     * @param pid (Optional) The process ID being checked against. If the\n     * pid is unknown, pass -1.\n     * @param uid The UID being checked against.  A uid of 0 is the root\n     * user, which will pass every permission check.\n     * @param modeFlags The access modes to check.\n     *\n     * @return {@link PackageManager#PERMISSION_GRANTED} if the given\n     * pid/uid is allowed to access that uri, or\n     * {@link PackageManager#PERMISSION_DENIED} if it is not.\n     *\n     * @see #checkUriPermission(Uri, int, int, int)\n     ",
    "links" : [ "android.content.pm.PackageManager#PERMISSION_DENIED", "#checkUriPermission(Uri", "android.content.pm.PackageManager#PERMISSION_GRANTED", "IllegalArgumentException" ]
  }, {
    "name" : "public int[] checkUriPermissions(@NonNull List<Uri> uris, int pid, int uid, @Intent.AccessUriMode int modeFlags)",
    "returnType" : "int[]",
    "comment" : "\n     * Determine whether a particular process and uid has been granted\n     * permission to access a list of URIs.  This only checks for permissions\n     * that have been explicitly granted -- if the given process/uid has\n     * more general access to the URI's content provider then this check will\n     * always fail.\n     *\n     * <strong>Note:</strong> On SDK Version {@link android.os.Build.VERSION_CODES#S},\n     * calling this method from a secondary-user's context will incorrectly return\n     * {@link PackageManager#PERMISSION_DENIED} for all {code uris}.\n     *\n     * @param uris The list of URIs that is being checked.\n     * @param pid The process ID being checked against.  Must be &gt; 0.\n     * @param uid The UID being checked against.  A uid of 0 is the root\n     * user, which will pass every permission check.\n     * @param modeFlags The access modes to check for the list of uris\n     *\n     * @return Array of permission grants corresponding to each entry in the list of uris.\n     * {@link PackageManager#PERMISSION_GRANTED} if the given pid/uid is allowed to access that uri,\n     * or {@link PackageManager#PERMISSION_DENIED} if it is not.\n     *\n     * @see #checkCallingUriPermission\n     ",
    "links" : [ "android.content.pm.PackageManager#PERMISSION_DENIED", "android.os.Build.VERSION_CODES#S", "android.content.pm.PackageManager#PERMISSION_GRANTED" ]
  }, {
    "name" : "public abstract int checkUriPermission(Uri uri, int pid, int uid, @Intent.AccessUriMode int modeFlags, IBinder callerToken)",
    "returnType" : "int",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "public abstract int checkCallingUriPermission(Uri uri, @Intent.AccessUriMode int modeFlags)",
    "returnType" : "int",
    "comment" : "\n     * Determine whether the calling process and uid has been\n     * granted permission to access a specific URI.  This is basically\n     * the same as calling {@link #checkUriPermission(Uri, int, int,\n     * int)} with the pid and uid returned by {@link\n     * android.os.Binder#getCallingPid} and {@link\n     * android.os.Binder#getCallingUid}.  One important difference is\n     * that if you are not currently processing an IPC, this function\n     * will always fail.\n     *\n     * @param uri The uri that is being checked.\n     * @param modeFlags The access modes to check.\n     *\n     * @return {@link PackageManager#PERMISSION_GRANTED} if the caller\n     * is allowed to access that uri, or\n     * {@link PackageManager#PERMISSION_DENIED} if it is not.\n     *\n     * @see #checkUriPermission(Uri, int, int, int)\n     ",
    "links" : [ "android.content.pm.PackageManager#PERMISSION_DENIED", "#checkUriPermission(Uri", "android.content.pm.PackageManager#PERMISSION_GRANTED", "android.os.Binder#getCallingPid", "android.os.Binder#getCallingUid" ]
  }, {
    "name" : "public int[] checkCallingUriPermissions(@NonNull List<Uri> uris, @Intent.AccessUriMode int modeFlags)",
    "returnType" : "int[]",
    "comment" : "\n     * Determine whether the calling process and uid has been\n     * granted permission to access a list of URIs.  This is basically\n     * the same as calling {@link #checkUriPermissions(List, int, int, int)}\n     * with the pid and uid returned by {@link\n     * android.os.Binder#getCallingPid} and {@link\n     * android.os.Binder#getCallingUid}.  One important difference is\n     * that if you are not currently processing an IPC, this function\n     * will always fail.\n     *\n     * @param uris The list of URIs that is being checked.\n     * @param modeFlags The access modes to check.\n     *\n     * @return Array of permission grants corresponding to each entry in the list of uris.\n     * {@link PackageManager#PERMISSION_GRANTED} if the given pid/uid is allowed to access that uri,\n     * or {@link PackageManager#PERMISSION_DENIED} if it is not.\n     *\n     * @see #checkUriPermission(Uri, int, int, int)\n     ",
    "links" : [ "android.content.pm.PackageManager#PERMISSION_DENIED", "android.content.pm.PackageManager#PERMISSION_GRANTED", "#checkUriPermissions(List", "android.os.Binder#getCallingPid", "android.os.Binder#getCallingUid" ]
  }, {
    "name" : "public abstract int checkCallingOrSelfUriPermission(Uri uri, @Intent.AccessUriMode int modeFlags)",
    "returnType" : "int",
    "comment" : "\n     * Determine whether the calling process of an IPC <em>or you</em> has been granted\n     * permission to access a specific URI.  This is the same as\n     * {@link #checkCallingUriPermission}, except it grants your own permissions\n     * if you are not currently processing an IPC.  Use with care!\n     *\n     * @param uri The uri that is being checked.\n     * @param modeFlags The access modes to check.\n     *\n     * @return {@link PackageManager#PERMISSION_GRANTED} if the caller\n     * is allowed to access that uri, or\n     * {@link PackageManager#PERMISSION_DENIED} if it is not.\n     *\n     * @see #checkCallingUriPermission\n     ",
    "links" : [ "android.content.pm.PackageManager#PERMISSION_DENIED", "android.content.pm.PackageManager#PERMISSION_GRANTED", "#checkCallingUriPermission" ]
  }, {
    "name" : "public int[] checkCallingOrSelfUriPermissions(@NonNull List<Uri> uris, @Intent.AccessUriMode int modeFlags)",
    "returnType" : "int[]",
    "comment" : "\n     * Determine whether the calling process of an IPC <em>or you</em> has been granted\n     * permission to access a list of URIs.  This is the same as\n     * {@link #checkCallingUriPermission}, except it grants your own permissions\n     * if you are not currently processing an IPC.  Use with care!\n     *\n     * @param uris The list of URIs that is being checked.\n     * @param modeFlags The access modes to check.\n     *\n     * @return Array of permission grants corresponding to each entry in the list of uris.\n     * {@link PackageManager#PERMISSION_GRANTED} if the given pid/uid is allowed to access that uri,\n     * or {@link PackageManager#PERMISSION_DENIED} if it is not.\n     *\n     * @see #checkCallingUriPermission\n     ",
    "links" : [ "android.content.pm.PackageManager#PERMISSION_DENIED", "android.content.pm.PackageManager#PERMISSION_GRANTED", "#checkCallingUriPermission" ]
  }, {
    "name" : "public abstract int checkUriPermission(@Nullable Uri uri, @Nullable String readPermission, @Nullable String writePermission, int pid, int uid, @Intent.AccessUriMode int modeFlags)",
    "returnType" : "int",
    "comment" : "\n     * Check both a Uri and normal permission.  This allows you to perform\n     * both {@link #checkPermission} and {@link #checkUriPermission} in one\n     * call.\n     *\n     * @param uri The Uri whose permission is to be checked, or null to not\n     * do this check.\n     * @param readPermission The permission that provides overall read access,\n     * or null to not do this check.\n     * @param writePermission The permission that provides overall write\n     * access, or null to not do this check.\n     * @param pid The process ID being checked against.  Must be &gt; 0.\n     * @param uid The UID being checked against.  A uid of 0 is the root\n     * user, which will pass every permission check.\n     * @param modeFlags The access modes to check.\n     *\n     * @return {@link PackageManager#PERMISSION_GRANTED} if the caller\n     * is allowed to access that uri or holds one of the given permissions, or\n     * {@link PackageManager#PERMISSION_DENIED} if it is not.\n     ",
    "links" : [ "android.content.pm.PackageManager#PERMISSION_DENIED", "#checkUriPermission", "android.content.pm.PackageManager#PERMISSION_GRANTED", "#checkPermission" ]
  }, {
    "name" : "public abstract void enforceUriPermission(Uri uri, int pid, int uid, @Intent.AccessUriMode int modeFlags, String message)",
    "returnType" : "void",
    "comment" : "\n     * If a particular process and uid has not been granted\n     * permission to access a specific URI, throw {@link\n     * SecurityException}.  This only checks for permissions that have\n     * been explicitly granted -- if the given process/uid has more\n     * general access to the URI's content provider then this check\n     * will always fail.\n     *\n     * @param uri The uri that is being checked.\n     * @param pid The process ID being checked against.  Must be &gt; 0.\n     * @param uid The UID being checked against.  A uid of 0 is the root\n     * user, which will pass every permission check.\n     * @param modeFlags The access modes to enforce.\n     * @param message A message to include in the exception if it is thrown.\n     *\n     * @see #checkUriPermission(Uri, int, int, int)\n     ",
    "links" : [ "SecurityException" ]
  }, {
    "name" : "public abstract void enforceCallingUriPermission(Uri uri, @Intent.AccessUriMode int modeFlags, String message)",
    "returnType" : "void",
    "comment" : "\n     * If the calling process and uid has not been granted\n     * permission to access a specific URI, throw {@link\n     * SecurityException}.  This is basically the same as calling\n     * {@link #enforceUriPermission(Uri, int, int, int, String)} with\n     * the pid and uid returned by {@link\n     * android.os.Binder#getCallingPid} and {@link\n     * android.os.Binder#getCallingUid}.  One important difference is\n     * that if you are not currently processing an IPC, this function\n     * will always throw a SecurityException.\n     *\n     * @param uri The uri that is being checked.\n     * @param modeFlags The access modes to enforce.\n     * @param message A message to include in the exception if it is thrown.\n     *\n     * @see #checkCallingUriPermission(Uri, int)\n     ",
    "links" : [ "android.os.Binder#getCallingPid", "SecurityException", "#enforceUriPermission(Uri", "android.os.Binder#getCallingUid" ]
  }, {
    "name" : "public abstract void enforceCallingOrSelfUriPermission(Uri uri, @Intent.AccessUriMode int modeFlags, String message)",
    "returnType" : "void",
    "comment" : "\n     * If the calling process of an IPC <em>or you</em> has not been\n     * granted permission to access a specific URI, throw {@link\n     * SecurityException}.  This is the same as {@link\n     * #enforceCallingUriPermission}, except it grants your own\n     * permissions if you are not currently processing an IPC.  Use\n     * with care!\n     *\n     * @param uri The uri that is being checked.\n     * @param modeFlags The access modes to enforce.\n     * @param message A message to include in the exception if it is thrown.\n     *\n     * @see #checkCallingOrSelfUriPermission(Uri, int)\n     ",
    "links" : [ "SecurityException", "#enforceCallingUriPermission" ]
  }, {
    "name" : "public abstract void enforceUriPermission(@Nullable Uri uri, @Nullable String readPermission, @Nullable String writePermission, int pid, int uid, @Intent.AccessUriMode int modeFlags, @Nullable String message)",
    "returnType" : "void",
    "comment" : "\n     * Enforce both a Uri and normal permission.  This allows you to perform\n     * both {@link #enforcePermission} and {@link #enforceUriPermission} in one\n     * call.\n     *\n     * @param uri The Uri whose permission is to be checked, or null to not\n     * do this check.\n     * @param readPermission The permission that provides overall read access,\n     * or null to not do this check.\n     * @param writePermission The permission that provides overall write\n     * access, or null to not do this check.\n     * @param pid The process ID being checked against.  Must be &gt; 0.\n     * @param uid The UID being checked against.  A uid of 0 is the root\n     * user, which will pass every permission check.\n     * @param modeFlags The access modes to enforce.\n     * @param message A message to include in the exception if it is thrown.\n     *\n     * @see #checkUriPermission(Uri, String, String, int, int, int)\n     ",
    "links" : [ "#enforcePermission", "#enforceUriPermission" ]
  }, {
    "name" : "public void revokeSelfPermissionOnKill(@NonNull String permName)",
    "returnType" : "void",
    "comment" : "\n     * Triggers the asynchronous revocation of a runtime permission. If the permission is not\n     * currently granted, nothing happens (even if later granted by the user).\n     *\n     * @param permName The name of the permission to be revoked.\n     * @see #revokeSelfPermissionsOnKill(Collection)\n     * @throws IllegalArgumentException if the permission is not a runtime permission\n     ",
    "links" : [ ]
  }, {
    "name" : "public void revokeSelfPermissionsOnKill(@NonNull Collection<String> permissions)",
    "returnType" : "void",
    "comment" : "\n     * Triggers the revocation of one or more permissions for the calling package. A package is only\n     * able to revoke runtime permissions. If a permission is not currently granted, it is ignored\n     * and will not get revoked (even if later granted by the user). Ultimately, you should never\n     * make assumptions about a permission status as users may grant or revoke them at any time.\n     * <p>\n     * Background permissions which have no corresponding foreground permission still granted once\n     * the revocation is effective will also be revoked.\n     * <p>\n     * The revocation happens asynchronously and kills all processes running in the calling UID. It\n     * will be triggered once it is safe to do so. In particular, it will not be triggered as long\n     * as the package remains in the foreground, or has any active manifest components (e.g. when\n     * another app is accessing a content provider in the package).\n     * <p>\n     * If you want to revoke the permissions right away, you could call {@code System.exit()}, but\n     * this could affect other apps that are accessing your app at the moment. For example, apps\n     * accessing a content provider in your app will all crash.\n     * <p>\n     * Note that the settings UI shows a permission group as granted as long as at least one\n     * permission in the group is granted. If you want the user to observe the revocation in the\n     * settings, you should revoke every permission in the target group. To learn the current list\n     * of permissions in a group, you may use\n     * {@link PackageManager#getGroupOfPlatformPermission(String, Executor, Consumer)} and\n     * {@link PackageManager#getPlatformPermissionsForGroup(String, Executor, Consumer)}. This list\n     * of permissions may evolve over time, so it is recommended to check whether it contains any\n     * permission you wish to retain before trying to revoke an entire group.\n     *\n     * @param permissions Collection of permissions to be revoked.\n     * @see PackageManager#getGroupOfPlatformPermission(String, Executor, Consumer)\n     * @see PackageManager#getPlatformPermissionsForGroup(String, Executor, Consumer)\n     * @throws IllegalArgumentException if any of the permissions is not a runtime permission\n     ",
    "links" : [ "android.content.pm.PackageManager#getPlatformPermissionsForGroup(String", "android.content.pm.PackageManager#getGroupOfPlatformPermission(String" ]
  }, {
    "name" : "public abstract Context createPackageContext(String packageName, @CreatePackageOptions int flags) throws PackageManager.NameNotFoundException",
    "returnType" : "Context",
    "comment" : "\n     * Return a new Context object for the given application name.  This\n     * Context is the same as what the named application gets when it is\n     * launched, containing the same resources and class loader.  Each call to\n     * this method returns a new instance of a Context object; Context objects\n     * are not shared, however they share common state (Resources, ClassLoader,\n     * etc) so the Context instance itself is fairly lightweight.\n     *\n     * <p>Throws {@link android.content.pm.PackageManager.NameNotFoundException} if there is no\n     * application with the given package name.\n     *\n     * <p>Throws {@link java.lang.SecurityException} if the Context requested\n     * can not be loaded into the caller's process for security reasons (see\n     * {@link #CONTEXT_INCLUDE_CODE} for more information}.\n     *\n     * @param packageName Name of the application's package.\n     * @param flags Option flags.\n     *\n     * @return A {@link Context} for the application.\n     *\n     * @throws SecurityException &nbsp;\n     * @throws PackageManager.NameNotFoundException if there is no application with\n     * the given package name.\n     ",
    "links" : [ "android.content.pm.PackageManager.NameNotFoundException", "android.annotation.DisplayContext", "#CONTEXT_INCLUDE_CODE", "java.lang.SecurityException" ]
  }, {
    "name" : "public Context createPackageContextAsUser(@NonNull String packageName, @CreatePackageOptions int flags, @NonNull UserHandle user) throws PackageManager.NameNotFoundException",
    "returnType" : "Context",
    "comment" : "\n     * Similar to {@link #createPackageContext(String, int)}, but with a\n     * different {@link UserHandle}. For example, {@link #getContentResolver()}\n     * will open any {@link Uri} as the given user.\n     *\n     * @hide\n     ",
    "links" : [ "android.os.UserHandle", "android.net.Uri", "#createPackageContext(String", "#getContentResolver()" ]
  }, {
    "name" : "public Context createContextAsUser(@NonNull UserHandle user, @CreatePackageOptions int flags)",
    "returnType" : "Context",
    "comment" : "\n     * Similar to {@link #createPackageContext(String, int)}, but for the own package with a\n     * different {@link UserHandle}. For example, {@link #getContentResolver()}\n     * will open any {@link Uri} as the given user.\n     *\n     * @hide\n     ",
    "links" : [ "android.os.UserHandle", "android.net.Uri", "#createPackageContext(String", "#getContentResolver()" ]
  }, {
    "name" : "public abstract Context createApplicationContext(ApplicationInfo application, @CreatePackageOptions int flags) throws PackageManager.NameNotFoundException",
    "returnType" : "Context",
    "comment" : "\n     * Creates a context given an {@link android.content.pm.ApplicationInfo}.\n     *\n     * @hide\n     ",
    "links" : [ "android.content.pm.ApplicationInfo" ]
  }, {
    "name" : "public Context createContextForSdkInSandbox(@NonNull ApplicationInfo sdkInfo, @CreatePackageOptions int flags) throws PackageManager.NameNotFoundException",
    "returnType" : "Context",
    "comment" : "\n     * Creates a context given an {@link android.content.pm.ApplicationInfo}.\n     *\n     * Context created is for an sdk library that is being loaded in sdk sandbox.\n     *\n     * @param sdkInfo information regarding the sdk library being loaded.\n     *\n     * @throws PackageManager.NameNotFoundException if there is no application with\n     * the given package name.\n     * @throws SecurityException if caller is not a SdkSandbox process.\n     *\n     * @hide\n     ",
    "links" : [ "android.content.pm.ApplicationInfo" ]
  }, {
    "name" : "public abstract Context createContextForSplit(String splitName) throws PackageManager.NameNotFoundException",
    "returnType" : "Context",
    "comment" : "\n     * Return a new Context object for the given split name. The new Context has a ClassLoader and\n     * Resources object that can access the split's and all of its dependencies' code/resources.\n     * Each call to this method returns a new instance of a Context object;\n     * Context objects are not shared, however common state (ClassLoader, other Resources for\n     * the same split) may be so the Context itself can be fairly lightweight.\n     *\n     * @param splitName The name of the split to include, as declared in the split's\n     *                  <code>AndroidManifest.xml</code>.\n     * @return A {@link Context} with the given split's code and/or resources loaded.\n     ",
    "links" : [ "android.annotation.DisplayContext" ]
  }, {
    "name" : "public UserHandle getUser()",
    "returnType" : "UserHandle",
    "comment" : "\n     * Get the user associated with this context.\n     *\n     * @return the user associated with this context\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public int getUserId()",
    "returnType" : "int",
    "comment" : "\n     * Get the user associated with this context\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public abstract Context createConfigurationContext(@NonNull Configuration overrideConfiguration)",
    "returnType" : "Context",
    "comment" : "\n     * Return a new Context object for the current Context but whose resources\n     * are adjusted to match the given Configuration.  Each call to this method\n     * returns a new instance of a Context object; Context objects are not\n     * shared, however common state (ClassLoader, other Resources for the\n     * same configuration) may be so the Context itself can be fairly lightweight.\n     *\n     * @param overrideConfiguration A {@link Configuration} specifying what\n     * values to modify in the base Configuration of the original Context's\n     * resources.  If the base configuration changes (such as due to an\n     * orientation change), the resources of this context will also change except\n     * for those that have been explicitly overridden with a value here.\n     *\n     * @return A {@link Context} with the given configuration override.\n     ",
    "links" : [ "android.annotation.DisplayContext", "android.content.res.Configuration" ]
  }, {
    "name" : "public abstract Context createDisplayContext(@NonNull Display display)",
    "returnType" : "Context",
    "comment" : "\n     * Returns a new {@code Context} object from the current context but with resources\n     * adjusted to match the metrics of {@code display}. Each call to this method\n     * returns a new instance of a context object. Context objects are not shared; however,\n     * common state (such as the {@link ClassLoader} and other resources for the same\n     * configuration) can be shared, so the {@code Context} itself is lightweight.\n     *\n     * <p><b>Note:</b>\n     * This {@code Context} is <b>not</b> expected to be updated with new configuration if the\n     * underlying display configuration changes and the cached {@code Resources} it returns\n     * could be stale. It is suggested to use\n     * {@link android.hardware.display.DisplayManager.DisplayListener} to listen for\n     * changes and re-create an instance if necessary. </p>\n     * <p>\n     * This {@code Context} is <b>not</b> a UI context, do not use it to access UI components\n     * or obtain a {@link WindowManager} instance.\n     * </p><p>\n     * To obtain an instance of {@link WindowManager} configured to show windows on the given\n     * display, call {@link #createWindowContext(int, Bundle)} on the returned display context,\n     * then call {@link #getSystemService(String)} or {@link #getSystemService(Class)} on the\n     * returned window context.\n     * </p>\n     * @param display The display to which the current context's resources are adjusted.\n     *\n     * @return A context for the display.\n     ",
    "links" : [ "android.hardware.display.DisplayManager.DisplayListener", "#getSystemService(String)", "#getSystemService(Class)", "#createWindowContext(int", "android.view.WindowManager", "ClassLoader" ]
  }, {
    "name" : "public Context createDeviceContext(int deviceId)",
    "returnType" : "Context",
    "comment" : "\n     * Returns a new {@code Context} object from the current context but with device association\n     * given by the {@code deviceId}. Each call to this method returns a new instance of a context\n     * object. Context objects are not shared; however, common state (such as the\n     * {@link ClassLoader} and other resources for the same configuration) can be shared, so the\n     * {@code Context} itself is lightweight.\n     * <p>\n     * Applications that run on virtual devices may use this method to access the default device\n     * capabilities and functionality (by passing\n     * {@link Context#DEVICE_ID_DEFAULT}. Similarly,\n     * applications running on the default device may access the functionality of virtual devices.\n     * </p>\n     * <p>\n     * Note that the newly created instance will be associated with the same display as the parent\n     * Context, regardless of the device ID passed here.\n     * </p>\n     * @param deviceId The ID of the device to associate with this context.\n     * @return A context associated with the given device ID.\n     *\n     * @see #getDeviceId()\n     * @see VirtualDeviceManager#getVirtualDevices()\n     * @throws IllegalArgumentException if the given device ID is not a valid ID of the default\n     * device or a virtual device.\n     ",
    "links" : [ "android.annotation.DisplayContext#DEVICE_ID_DEFAULT", "ClassLoader" ]
  }, {
    "name" : "public Context createWindowContext(@WindowType int type, @Nullable Bundle options)",
    "returnType" : "Context",
    "comment" : "\n     * Creates a Context for a non-activity window.\n     *\n     * <p>\n     * A window context is a context that can be used to add non-activity windows, such as\n     * {@link android.view.WindowManager.LayoutParams#TYPE_APPLICATION_OVERLAY}. A window context\n     * must be created from a context that has an associated {@link Display}, such as\n     * {@link android.app.Activity Activity} or a context created with\n     * {@link #createDisplayContext(Display)}.\n     *\n     * <p>\n     * The window context is created with the appropriate {@link Configuration} for the area of the\n     * display that the windows created with it can occupy; it must be used when\n     * {@link android.view.LayoutInflater inflating} views, such that they can be inflated with\n     * proper {@link Resources}.\n     *\n     * Below is a sample code to <b>add an application overlay window on the primary display:</b>\n     * <pre class=\"prettyprint\">\n     * ...\n     * final DisplayManager dm = anyContext.getSystemService(DisplayManager.class);\n     * final Display primaryDisplay = dm.getDisplay(DEFAULT_DISPLAY);\n     * final Context windowContext = anyContext.createDisplayContext(primaryDisplay)\n     *         .createWindowContext(TYPE_APPLICATION_OVERLAY, null);\n     * final View overlayView = Inflater.from(windowContext).inflate(someLayoutXml, null);\n     *\n     * // WindowManager.LayoutParams initialization\n     * ...\n     * // The types used in addView and createWindowContext must match.\n     * mParams.type = TYPE_APPLICATION_OVERLAY;\n     * ...\n     *\n     * windowContext.getSystemService(WindowManager.class).addView(overlayView, mParams);\n     * </pre>\n     *\n     * <p>\n     * This context's configuration and resources are adjusted to an area of the display where\n     * the windows with provided type will be added. <b>Note that all windows associated with the\n     * same context will have an affinity and can only be moved together between different displays\n     * or areas on a display.</b> If there is a need to add different window types, or\n     * non-associated windows, separate Contexts should be used.\n     * </p>\n     * <p>\n     * Creating a window context is an expensive operation. Misuse of this API may lead to a huge\n     * performance drop. The best practice is to use the same window context when possible.\n     * An approach is to create one window context with specific window type and display and\n     * use it everywhere it's needed.\n     * </p>\n     * <p>\n     * After {@link Build.VERSION_CODES#S}, window context provides the capability to receive\n     * configuration changes for existing token by overriding the\n     * {@link android.view.WindowManager.LayoutParams#token token} of the\n     * {@link android.view.WindowManager.LayoutParams} passed in\n     * {@link WindowManager#addView(View, LayoutParams)}. This is useful when an application needs\n     * to attach its window to an existing activity for window token sharing use-case.\n     * </p>\n     * <p>\n     * Note that the window context in {@link Build.VERSION_CODES#R} didn't have this\n     * capability. This is a no-op for the window context in {@link Build.VERSION_CODES#R}.\n     * </p>\n     * Below is sample code to <b>attach an existing token to a window context:</b>\n     * <pre class=\"prettyprint\">\n     * final DisplayManager dm = anyContext.getSystemService(DisplayManager.class);\n     * final Display primaryDisplay = dm.getDisplay(DEFAULT_DISPLAY);\n     * final Context windowContext = anyContext.createWindowContext(primaryDisplay,\n     *         TYPE_APPLICATION, null);\n     *\n     * // Get an existing token.\n     * final IBinder existingToken = activity.getWindow().getAttributes().token;\n     *\n     * // The types used in addView() and createWindowContext() must match.\n     * final WindowManager.LayoutParams params = new WindowManager.LayoutParams(TYPE_APPLICATION);\n     * params.token = existingToken;\n     *\n     * // After WindowManager#addView(), the server side will extract the provided token from\n     * // LayoutParams#token (existingToken in the sample code), and switch to propagate\n     * // configuration changes from the node associated with the provided token.\n     * windowContext.getSystemService(WindowManager.class).addView(overlayView, mParams);\n     * </pre>\n     * <p>\n     * After {@link Build.VERSION_CODES#S}, window context provides the capability to listen to its\n     * {@link Configuration} changes by calling\n     * {@link #registerComponentCallbacks(ComponentCallbacks)}, while other kinds of {@link Context}\n     * will register the {@link ComponentCallbacks} to {@link #getApplicationContext() its\n     * Application context}. Note that window context only propagate\n     * {@link ComponentCallbacks#onConfigurationChanged(Configuration)} callback.\n     * {@link ComponentCallbacks#onLowMemory()} or other callbacks in {@link ComponentCallbacks2}\n     * won't be invoked.\n     * </p>\n     * <p>\n     * Note that using {@link android.app.Application} or {@link android.app.Service} context for\n     * UI-related queries may result in layout or continuity issues on devices with variable screen\n     * sizes (e.g. foldables) or in multi-window modes, since these non-UI contexts may not reflect\n     * the {@link Configuration} changes for the visual container.\n     * </p>\n     * @param type Window type in {@link WindowManager.LayoutParams}\n     * @param options A bundle used to pass window-related options\n     * @return A {@link Context} that can be used to create\n     *         non-{@link android.app.Activity activity} windows.\n     *\n     * @see #getSystemService(String)\n     * @see #getSystemService(Class)\n     * @see #WINDOW_SERVICE\n     * @see #LAYOUT_INFLATER_SERVICE\n     * @see #WALLPAPER_SERVICE\n     * @throws UnsupportedOperationException if this {@link Context} does not attach to a display,\n     * such as {@link android.app.Application Application} or {@link android.app.Service Service}.\n     ",
    "links" : [ "android.view.WindowManager.LayoutParams#TYPE_APPLICATION_OVERLAY", "#registerComponentCallbacks(ComponentCallbacks)", "Build.VERSION_CODES#S", "Build.VERSION_CODES#R", "android.view.LayoutInflater", "android.content.ComponentCallbacks#onConfigurationChanged(Configuration)", "android.app.Service", "android.content.ComponentCallbacks", "#getApplicationContext()", "android.view.WindowManager#addView(View", "android.annotation.DisplayContext", "android.content.ComponentCallbacks2", "android.view.WindowManager.LayoutParams", "android.app.Application", "android.content.res.Configuration", "android.view.Display", "WindowManager.LayoutParams", "android.content.ComponentCallbacks#onLowMemory()", "android.app.Activity", "#createDisplayContext(Display)", "android.view.WindowManager.LayoutParams#token", "android.content.res.Resources" ]
  }, {
    "name" : "public Context createWindowContext(@NonNull Display display, @WindowType int type, @SuppressLint(\"NullableCollection\") @Nullable Bundle options)",
    "returnType" : "Context",
    "comment" : "\n     * Creates a {@code Context} for a non-{@link android.app.Activity activity} window on the given\n     * {@link Display}.\n     *\n     * <p>\n     * Similar to {@link #createWindowContext(int, Bundle)}, but the {@code display} is passed in,\n     * instead of implicitly using the {@link #getDisplay() original Context's Display}.\n     * </p>\n     *\n     * @param display The {@link Display} to associate with\n     * @param type Window type in {@link WindowManager.LayoutParams}\n     * @param options A bundle used to pass window-related options.\n     * @return A {@link Context} that can be used to create\n     *         non-{@link android.app.Activity activity} windows.\n     * @throws IllegalArgumentException if the {@link Display} is {@code null}.\n     *\n     * @see #getSystemService(String)\n     * @see #getSystemService(Class)\n     * @see #WINDOW_SERVICE\n     * @see #LAYOUT_INFLATER_SERVICE\n     * @see #WALLPAPER_SERVICE\n     ",
    "links" : [ "android.annotation.DisplayContext", "#createWindowContext(int", "android.view.Display", "#getDisplay()", "WindowManager.LayoutParams", "android.app.Activity" ]
  }, {
    "name" : "public Context createContext(@NonNull ContextParams contextParams)",
    "returnType" : "Context",
    "comment" : "\n     * Creates a context with specific properties and behaviors.\n     *\n     * @param contextParams Parameters for how the new context should behave.\n     * @return A context with the specified behaviors.\n     *\n     * @see ContextParams\n     ",
    "links" : [ ]
  }, {
    "name" : "public Context createAttributionContext(@Nullable String attributionTag)",
    "returnType" : "Context",
    "comment" : "\n     * Return a new Context object for the current Context but attribute to a different tag.\n     * In complex apps attribution tagging can be used to distinguish between separate logical\n     * parts.\n     *\n     * @param attributionTag The tag or {@code null} to create a context for the default.\n     *\n     * @return A {@link Context} that is tagged for the new attribution\n     *\n     * @see #getAttributionTag()\n     ",
    "links" : [ "android.annotation.DisplayContext" ]
  }, {
    "name" : "public Context createFeatureContext(@Nullable String attributionTag)",
    "returnType" : "Context",
    "comment" : "\n     * @removed\n     ",
    "links" : [ ]
  }, {
    "name" : "public abstract Context createDeviceProtectedStorageContext()",
    "returnType" : "Context",
    "comment" : "\n     * Return a new Context object for the current Context but whose storage\n     * APIs are backed by device-protected storage.\n     * <p>\n     * On devices with direct boot, data stored in this location is encrypted\n     * with a key tied to the physical device, and it can be accessed\n     * immediately after the device has booted successfully, both\n     * <em>before and after</em> the user has authenticated with their\n     * credentials (such as a lock pattern or PIN).\n     * <p>\n     * Because device-protected data is available without user authentication,\n     * you should carefully limit the data you store using this Context. For\n     * example, storing sensitive authentication tokens or passwords in the\n     * device-protected area is strongly discouraged.\n     * <p>\n     * If the underlying device does not have the ability to store\n     * device-protected and credential-protected data using different keys, then\n     * both storage areas will become available at the same time. They remain as\n     * two distinct storage locations on disk, and only the window of\n     * availability changes.\n     * <p>\n     * Each call to this method returns a new instance of a Context object;\n     * Context objects are not shared, however common state (ClassLoader, other\n     * Resources for the same configuration) may be so the Context itself can be\n     * fairly lightweight.\n     *\n     * @see #isDeviceProtectedStorage()\n     ",
    "links" : [ ]
  }, {
    "name" : "public abstract Context createCredentialProtectedStorageContext()",
    "returnType" : "Context",
    "comment" : "\n     * Return a new Context object for the current Context but whose storage\n     * APIs are backed by credential-protected storage. This is the default\n     * storage area for apps unless\n     * {@link android.R.attr#defaultToDeviceProtectedStorage} was requested.\n     * <p>\n     * On devices with direct boot, data stored in this location is encrypted\n     * with a key tied to user credentials, which can be accessed\n     * <em>only after</em> the user has entered their credentials (such as a\n     * lock pattern or PIN).\n     * <p>\n     * If the underlying device does not have the ability to store\n     * device-protected and credential-protected data using different keys, then\n     * both storage areas will become available at the same time. They remain as\n     * two distinct storage locations on disk, and only the window of\n     * availability changes.\n     * <p>\n     * Each call to this method returns a new instance of a Context object;\n     * Context objects are not shared, however common state (ClassLoader, other\n     * Resources for the same configuration) may be so the Context itself can be\n     * fairly lightweight.\n     *\n     * @see #isCredentialProtectedStorage()\n     * @hide\n     ",
    "links" : [ "android.R.attr#defaultToDeviceProtectedStorage" ]
  }, {
    "name" : "public Context createTokenContext(@NonNull IBinder token, @NonNull Display display)",
    "returnType" : "Context",
    "comment" : "\n     * Creates a UI context with a {@code token}. The users of this API should handle this context's\n     * configuration changes.\n     *\n     * @param token The token to associate with the {@link Resources}\n     * @param display The display to associate with the token context\n     *\n     * @hide\n     ",
    "links" : [ "android.content.res.Resources" ]
  }, {
    "name" : "public abstract DisplayAdjustments getDisplayAdjustments(int displayId)",
    "returnType" : "DisplayAdjustments",
    "comment" : "\n     * Gets the display adjustments holder for this context.  This information\n     * is provided on a per-application or activity basis and is used to simulate lower density\n     * display metrics for legacy applications and restricted screen sizes.\n     *\n     * @param displayId The display id for which to get compatibility info.\n     * @return The compatibility info holder, or null if not required by the application.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public Display getDisplay()",
    "returnType" : "Display",
    "comment" : "\n     * Get the display this context is associated with. Applications should use this method with\n     * {@link android.app.Activity} or a context associated with a {@link Display} via\n     * {@link #createDisplayContext(Display)} to get a display object associated with a Context, or\n     * {@link android.hardware.display.DisplayManager#getDisplay} to get a display object by id.\n     * @return Returns the {@link Display} object this context is associated with.\n     * @throws UnsupportedOperationException if the method is called on an instance that is not\n     *         associated with any display.\n     ",
    "links" : [ "android.view.Display", "android.app.Activity", "android.hardware.display.DisplayManager#getDisplay", "#createDisplayContext(Display)" ]
  }, {
    "name" : "public Display getDisplayNoVerify()",
    "returnType" : "Display",
    "comment" : "\n     * A version of {@link #getDisplay()} that does not perform a Context misuse check to be used by\n     * legacy APIs.\n     * TODO(b/149790106): Fix usages and remove.\n     * @hide\n     ",
    "links" : [ "#getDisplay()" ]
  }, {
    "name" : "public abstract int getDisplayId()",
    "returnType" : "int",
    "comment" : "\n     * Gets the ID of the display this context is associated with.\n     *\n     * @return display ID associated with this {@link Context}.\n     * @see #getDisplay()\n     * @hide\n     ",
    "links" : [ "android.annotation.DisplayContext" ]
  }, {
    "name" : "public int getAssociatedDisplayId()",
    "returnType" : "int",
    "comment" : "\n     * @return Returns the id of the Display object associated with this Context or\n     * {@link Display#INVALID_DISPLAY} if no Display has been associated.\n     * @see #getDisplay()\n     * @see #getDisplayId()\n     *\n     * @hide\n     ",
    "links" : [ "android.view.Display#INVALID_DISPLAY" ]
  }, {
    "name" : "public abstract void updateDisplay(int displayId)",
    "returnType" : "void",
    "comment" : "\n     * Updates the display association of this Context with the display with the given ID.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public void updateDeviceId(int deviceId)",
    "returnType" : "void",
    "comment" : "\n     * Updates the device ID association of this Context. Since a Context created with\n     * {@link #createDeviceContext} cannot change its device association, this method must\n     * not be called for instances created with {@link #createDeviceContext}.\n     *<p>\n     * Note that updating the deviceId of the Context will not update its associated display.\n     *</p>\n     * @param deviceId The new device ID to assign to this Context.\n     * @throws UnsupportedOperationException if the method is called on an instance that was\n     *         created with {@link Context#createDeviceContext(int)}\n     * @throws IllegalArgumentException if the given device ID is not a valid ID of the default\n     *         device or a virtual device.\n     *\n     * @see #createDeviceContext(int)\n     * @hide\n     ",
    "links" : [ "#createDeviceContext", "android.annotation.DisplayContext#createDeviceContext(int)" ]
  }, {
    "name" : "public int getDeviceId()",
    "returnType" : "int",
    "comment" : "\n     * Gets the device ID this context is associated with. Applications can use this method to\n     * determine whether they are running on a virtual device and identify that device.\n     *\n     * The device ID of the host device is\n     * {@link Context#DEVICE_ID_DEFAULT}\n     *\n     * <p>\n     * If the underlying device ID is changed by the system, for example, when an\n     * {@link Activity} is moved to a different virtual device, applications can register to listen\n     * to changes by calling\n     * {@link Context#registerDeviceIdChangeListener(Executor, IntConsumer)}.\n     * </p>\n     *\n     * <p>\n     * This method will only return a reliable value for this instance if it was created with\n     * {@link Context#createDeviceContext(int)}, or if this instance is a UI or Display Context.\n     * Contexts created with {@link Context#createDeviceContext(int)} will have an explicit\n     * device association, which will never change, even if the underlying device is closed or is\n     * removed. UI Contexts and Display Contexts are\n     * already associated with a display, so if the device association is not explicitly\n     * given, {@link Context#getDeviceId()} will return the ID of the device associated with\n     * the associated display. The system can assign an arbitrary device id value for Contexts not\n     * logically associated with a device.\n     * </p>\n     *\n     * @return the ID of the device this context is associated with.\n     * @see #createDeviceContext(int)\n     * @see #registerDeviceIdChangeListener(Executor, IntConsumer)\n     * @see #isUiContext()\n     ",
    "links" : [ "android.annotation.DisplayContext#DEVICE_ID_DEFAULT", "android.app.Activity", "android.annotation.DisplayContext#createDeviceContext(int)", "android.annotation.DisplayContext#getDeviceId()", "android.annotation.DisplayContext#registerDeviceIdChangeListener(Executor" ]
  }, {
    "name" : "public void registerDeviceIdChangeListener(@NonNull @CallbackExecutor Executor executor, @NonNull IntConsumer listener)",
    "returnType" : "void",
    "comment" : "\n     * Adds a new device ID changed listener to the {@code Context}, which will be called when\n     * the device association is changed by the system.\n     * <p>\n     * The callback can be called when an app is moved to a different device and the {@code Context}\n     * is not explicitly associated with a specific device.\n     * </p>\n     * <p> When an application receives a device id update callback, this Context is guaranteed to\n     * also have an updated display ID(if any) and {@link Configuration}.\n     * <p/>\n     * @param executor The Executor on whose thread to execute the callbacks of the {@code listener}\n     *                 object.\n     * @param listener The listener {@code IntConsumer} to call which will receive the updated\n     *                 device ID.\n     *\n     * @see Context#getDeviceId()\n     * @see Context#createDeviceContext(int)\n     ",
    "links" : [ "android.content.res.Configuration" ]
  }, {
    "name" : "public void unregisterDeviceIdChangeListener(@NonNull IntConsumer listener)",
    "returnType" : "void",
    "comment" : "\n     * Removes a device ID changed listener from the Context. It's a no-op if\n     * the listener is not already registered.\n     *\n     * @param listener The {@code Consumer} to remove.\n     *\n     * @see #getDeviceId()\n     * @see #registerDeviceIdChangeListener(Executor, IntConsumer)\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean isRestricted()",
    "returnType" : "boolean",
    "comment" : "\n     * Indicates whether this Context is restricted.\n     *\n     * @return {@code true} if this Context is restricted, {@code false} otherwise.\n     *\n     * @see #CONTEXT_RESTRICTED\n     ",
    "links" : [ ]
  }, {
    "name" : "public abstract boolean isDeviceProtectedStorage()",
    "returnType" : "boolean",
    "comment" : "\n     * Indicates if the storage APIs of this Context are backed by\n     * device-protected storage.\n     *\n     * @see #createDeviceProtectedStorageContext()\n     ",
    "links" : [ ]
  }, {
    "name" : "public abstract boolean isCredentialProtectedStorage()",
    "returnType" : "boolean",
    "comment" : "\n     * Indicates if the storage APIs of this Context are backed by\n     * credential-protected storage.\n     *\n     * @see #createCredentialProtectedStorageContext()\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public abstract boolean canLoadUnsafeResources()",
    "returnType" : "boolean",
    "comment" : "\n     * Returns true if the context can load unsafe resources, e.g. fonts.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public IBinder getActivityToken()",
    "returnType" : "IBinder",
    "comment" : "\n     * Returns token if the {@link Context} is a {@link android.app.Activity}. Returns\n     * {@code null} otherwise.\n     *\n     * @hide\n     ",
    "links" : [ "android.annotation.DisplayContext", "android.app.Activity" ]
  }, {
    "name" : "public IBinder getWindowContextToken()",
    "returnType" : "IBinder",
    "comment" : "\n     * Returns the {@link IBinder} representing the associated\n     * {@link com.android.server.wm.WindowToken} if the {@link Context} is a\n     * {@link android.app.WindowContext}. Returns {@code null} otherwise.\n     *\n     * @hide\n     ",
    "links" : [ "com.android.server.wm.WindowToken", "android.annotation.DisplayContext", "android.app.WindowContext", "android.os.IBinder" ]
  }, {
    "name" : "public static IBinder getToken(@NonNull Context context)",
    "returnType" : "IBinder",
    "comment" : "\n     * Returns the proper token of a {@link Context}.\n     *\n     * If the {@link Context} is an {@link android.app.Activity}, returns\n     * {@link #getActivityToken()}. If the {@lijnk Context} is a {@link android.app.WindowContext},\n     * returns {@link #getWindowContextToken()}. Returns {@code null}, otherwise.\n     *\n     * @hide\n     ",
    "links" : [ "android.annotation.DisplayContext", "android.app.WindowContext", "#getWindowContextToken()", "#getActivityToken()", "android.app.Activity" ]
  }, {
    "name" : "public IServiceConnection getServiceDispatcher(ServiceConnection conn, Handler handler, long flags)",
    "returnType" : "IServiceConnection",
    "comment" : "\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public IApplicationThread getIApplicationThread()",
    "returnType" : "IApplicationThread",
    "comment" : "\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public IBinder getProcessToken()",
    "returnType" : "IBinder",
    "comment" : "\n     * Used by a mainline module to uniquely identify a specific app process.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public Handler getMainThreadHandler()",
    "returnType" : "Handler",
    "comment" : "\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public AutofillClient getAutofillClient()",
    "returnType" : "AutofillClient",
    "comment" : "\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public void setAutofillClient(@SuppressWarnings(\"unused\") AutofillClient client)",
    "returnType" : "void",
    "comment" : "\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public ContentCaptureClient getContentCaptureClient()",
    "returnType" : "ContentCaptureClient",
    "comment" : "\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public final boolean isAutofillCompatibilityEnabled()",
    "returnType" : "boolean",
    "comment" : "\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public AutofillOptions getAutofillOptions()",
    "returnType" : "AutofillOptions",
    "comment" : "\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public void setAutofillOptions(@SuppressWarnings(\"unused\") @Nullable AutofillOptions options)",
    "returnType" : "void",
    "comment" : "\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public ContentCaptureOptions getContentCaptureOptions()",
    "returnType" : "ContentCaptureOptions",
    "comment" : "\n     * Gets the Content Capture options for this context, or {@code null} if it's not allowlisted.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public void setContentCaptureOptions(@SuppressWarnings(\"unused\") @Nullable ContentCaptureOptions options)",
    "returnType" : "void",
    "comment" : "\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public void assertRuntimeOverlayThemable()",
    "returnType" : "void",
    "comment" : "\n     * Throws an exception if the Context is using system resources,\n     * which are non-runtime-overlay-themable and may show inconsistent UI.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean isUiContext()",
    "returnType" : "boolean",
    "comment" : "\n     * Returns {@code true} if the context is a UI context which can access UI components such as\n     * {@link WindowManager}, {@link android.view.LayoutInflater LayoutInflater} or\n     * {@link android.app.WallpaperManager WallpaperManager}. Accessing UI components from non-UI\n     * contexts throws {@link android.os.strictmode.Violation} if\n     * {@link android.os.StrictMode.VmPolicy.Builder#detectIncorrectContextUse()} is enabled.\n     * <p>\n     * Examples of UI contexts are\n     * an {@link android.app.Activity Activity}, a context created from\n     * {@link #createWindowContext(int, Bundle)} or\n     * {@link android.inputmethodservice.InputMethodService InputMethodService}\n     * </p>\n     * <p>\n     * Note that even if it is allowed programmatically, it is not suggested to override this\n     * method to bypass {@link android.os.strictmode.IncorrectContextUseViolation} verification.\n     * </p>\n     *\n     * @see #getDisplay()\n     * @see #getSystemService(String)\n     * @see android.os.StrictMode.VmPolicy.Builder#detectIncorrectContextUse()\n     ",
    "links" : [ "android.os.StrictMode.VmPolicy.Builder#detectIncorrectContextUse()", "android.os.strictmode.IncorrectContextUseViolation", "android.view.LayoutInflater", "#createWindowContext(int", "android.view.WindowManager", "android.os.strictmode.Violation", "android.inputmethodservice.InputMethodService", "android.app.Activity", "android.app.WallpaperManager" ]
  }, {
    "name" : "public void destroy()",
    "returnType" : "void",
    "comment" : "\n     * Called when a {@link Context} is going to be released.\n     * This method can be overridden to perform the final cleanups, such as release\n     * {@link BroadcastReceiver} registrations.\n     *\n     * @see WindowContext#destroy()\n     *\n     * @hide\n     ",
    "links" : [ "android.annotation.DisplayContext", "android.content.BroadcastReceiver" ]
  }, {
    "name" : "public boolean isConfigurationContext()",
    "returnType" : "boolean",
    "comment" : "\n     * Indicates this {@link Context} has the proper {@link Configuration} to obtain\n     * {@link android.view.LayoutInflater}, {@link android.view.ViewConfiguration} and\n     * {@link android.view.GestureDetector}. Generally, all UI contexts, such as\n     * {@link android.app.Activity} or {@link android.app.WindowContext}, are initialized with base\n     * configuration.\n     * <p>\n     * Note that the context created via {@link Context#createConfigurationContext(Configuration)}\n     * is also regarded as a context that is based on a configuration because the\n     * configuration is explicitly provided via the API.\n     * </p>\n     *\n     * @see #isUiContext()\n     * @see #createConfigurationContext(Configuration)\n     *\n     * @hide\n     ",
    "links" : [ "android.view.ViewConfiguration", "android.annotation.DisplayContext", "android.view.GestureDetector", "android.view.LayoutInflater", "android.app.WindowContext", "android.content.res.Configuration", "android.annotation.DisplayContext#createConfigurationContext(Configuration)", "android.app.Activity" ]
  }, {
    "name" : "public void closeSystemDialogs()",
    "returnType" : "void",
    "comment" : "\n     * Closes temporary system dialogs. Some examples of temporary system dialogs are the\n     * notification window-shade and the recent tasks dialog.\n     *\n     * @hide\n     ",
    "links" : [ ]
  } ],
  "methodNames" : [ "public abstract AssetManager getAssets()", "public abstract Resources getResources()", "public abstract PackageManager getPackageManager()", "public abstract ContentResolver getContentResolver()", "public abstract Looper getMainLooper()", "public Executor getMainExecutor()", "public abstract Context getApplicationContext()", "public int getNextAutofillId()", "public void registerComponentCallbacks(ComponentCallbacks callback)", "public void unregisterComponentCallbacks(ComponentCallbacks callback)", "public final CharSequence getText(@StringRes int resId)", "public final String getString(@StringRes int resId)", "public final String getString(@StringRes int resId, Object... formatArgs)", "public final int getColor(@ColorRes int id)", "public final Drawable getDrawable(@DrawableRes int id)", "public final ColorStateList getColorStateList(@ColorRes int id)", "public abstract void setTheme(@StyleRes int resid)", "public int getThemeResId()", "public abstract Resources.Theme getTheme()", "public final TypedArray obtainStyledAttributes(@NonNull @StyleableRes int[] attrs)", "public final TypedArray obtainStyledAttributes(@StyleRes int resid, @NonNull @StyleableRes int[] attrs) throws Resources.NotFoundException", "public final TypedArray obtainStyledAttributes(@Nullable AttributeSet set, @NonNull @StyleableRes int[] attrs)", "public final TypedArray obtainStyledAttributes(@Nullable AttributeSet set, @NonNull @StyleableRes int[] attrs, @AttrRes int defStyleAttr, @StyleRes int defStyleRes)", "public abstract ClassLoader getClassLoader()", "public abstract String getPackageName()", "public abstract String getBasePackageName()", "public String getOpPackageName()", "public String getAttributionTag()", "public AttributionSource getAttributionSource()", "public String getFeatureId()", "public ContextParams getParams()", "public abstract ApplicationInfo getApplicationInfo()", "public abstract String getPackageResourcePath()", "public abstract String getPackageCodePath()", "public File getSharedPrefsFile(String name)", "public abstract SharedPreferences getSharedPreferences(String name, @PreferencesMode int mode)", "public abstract SharedPreferences getSharedPreferences(File file, @PreferencesMode int mode)", "public abstract boolean moveSharedPreferencesFrom(Context sourceContext, String name)", "public abstract boolean deleteSharedPreferences(String name)", "public abstract void reloadSharedPreferences()", "public abstract FileInputStream openFileInput(String name) throws FileNotFoundException", "public abstract FileOutputStream openFileOutput(String name, @FileMode int mode) throws FileNotFoundException", "public abstract boolean deleteFile(String name)", "public abstract File getFileStreamPath(String name)", "public abstract File getSharedPreferencesPath(String name)", "public abstract File getDataDir()", "public abstract File getFilesDir()", "public File getCrateDir(@NonNull String crateId)", "public abstract File getNoBackupFilesDir()", "public abstract File getExternalFilesDir(@Nullable String type)", "public abstract File[] getExternalFilesDirs(String type)", "public abstract File getObbDir()", "public abstract File[] getObbDirs()", "public abstract File getCacheDir()", "public abstract File getCodeCacheDir()", "public abstract File getExternalCacheDir()", "public abstract File getPreloadsFileCache()", "public abstract File[] getExternalCacheDirs()", "public abstract File[] getExternalMediaDirs()", "public abstract String[] fileList()", "public abstract File getDir(String name, @FileMode int mode)", "public abstract SQLiteDatabase openOrCreateDatabase(String name, @DatabaseMode int mode, CursorFactory factory)", "public abstract SQLiteDatabase openOrCreateDatabase(String name, @DatabaseMode int mode, CursorFactory factory, @Nullable DatabaseErrorHandler errorHandler)", "public abstract boolean moveDatabaseFrom(Context sourceContext, String name)", "public abstract boolean deleteDatabase(String name)", "public abstract File getDatabasePath(String name)", "public abstract String[] databaseList()", "public abstract Drawable getWallpaper()", "public abstract Drawable peekWallpaper()", "public abstract int getWallpaperDesiredMinimumWidth()", "public abstract int getWallpaperDesiredMinimumHeight()", "public abstract void setWallpaper(Bitmap bitmap) throws IOException", "public abstract void setWallpaper(InputStream data) throws IOException", "public abstract void clearWallpaper() throws IOException", "public abstract void startActivity(@RequiresPermission Intent intent)", "public void startActivityAsUser(@RequiresPermission @NonNull Intent intent, @NonNull UserHandle user)", "public abstract void startActivity(@RequiresPermission Intent intent, @Nullable Bundle options)", "public void startActivityAsUser(@RequiresPermission @NonNull Intent intent, @Nullable Bundle options, @NonNull UserHandle userId)", "public void startActivityForResult(@NonNull String who, Intent intent, int requestCode, @Nullable Bundle options)", "public boolean canStartActivityForResult()", "public abstract void startActivities(@RequiresPermission Intent[] intents)", "public abstract void startActivities(@RequiresPermission Intent[] intents, Bundle options)", "public int startActivitiesAsUser(Intent[] intents, Bundle options, UserHandle userHandle)", "public abstract void startIntentSender(IntentSender intent, @Nullable Intent fillInIntent, @Intent.MutableFlags int flagsMask, @Intent.MutableFlags int flagsValues, int extraFlags) throws IntentSender.SendIntentException", "public abstract void startIntentSender(IntentSender intent, @Nullable Intent fillInIntent, @Intent.MutableFlags int flagsMask, @Intent.MutableFlags int flagsValues, int extraFlags, @Nullable Bundle options) throws IntentSender.SendIntentException", "public abstract void sendBroadcast(@RequiresPermission Intent intent)", "public abstract void sendBroadcast(@RequiresPermission Intent intent, @Nullable String receiverPermission)", "public void sendBroadcastMultiplePermissions(@NonNull Intent intent, @NonNull String[] receiverPermissions)", "public void sendBroadcastMultiplePermissions(@NonNull Intent intent, @NonNull String[] receiverPermissions, @Nullable String[] excludedPermissions)", "public void sendBroadcastMultiplePermissions(@NonNull Intent intent, @NonNull String[] receiverPermissions, @Nullable String[] excludedPermissions, @Nullable String[] excludedPackages)", "public void sendBroadcastMultiplePermissions(@NonNull Intent intent, @NonNull String[] receiverPermissions, @Nullable String[] excludedPermissions, @Nullable String[] excludedPackages, @Nullable BroadcastOptions options)", "public void sendBroadcastMultiplePermissions(@NonNull Intent intent, @NonNull String[] receiverPermissions, @Nullable Bundle options)", "public void sendBroadcastMultiplePermissions(@NonNull Intent intent, @NonNull String[] receiverPermissions, @Nullable BroadcastOptions options)", "public void sendBroadcastWithMultiplePermissions(@NonNull Intent intent, @NonNull String[] receiverPermissions)", "public abstract void sendBroadcastAsUserMultiplePermissions(Intent intent, UserHandle user, String[] receiverPermissions)", "public void sendBroadcast(@NonNull Intent intent, @Nullable String receiverPermission, @Nullable Bundle options)", "public abstract void sendBroadcast(Intent intent, String receiverPermission, int appOp)", "public abstract void sendOrderedBroadcast(@RequiresPermission Intent intent, @Nullable String receiverPermission)", "public void sendOrderedBroadcast(@NonNull Intent intent, @Nullable String receiverPermission, @Nullable Bundle options)", "public abstract void sendOrderedBroadcast(@RequiresPermission @NonNull Intent intent, @Nullable String receiverPermission, @Nullable BroadcastReceiver resultReceiver, @Nullable Handler scheduler, int initialCode, @Nullable String initialData, @Nullable Bundle initialExtras)", "public void sendOrderedBroadcast(@NonNull Intent intent, @Nullable String receiverPermission, @Nullable Bundle options, @Nullable BroadcastReceiver resultReceiver, @Nullable Handler scheduler, int initialCode, @Nullable String initialData, @Nullable Bundle initialExtras)", "public abstract void sendOrderedBroadcast(Intent intent, String receiverPermission, int appOp, BroadcastReceiver resultReceiver, Handler scheduler, int initialCode, String initialData, Bundle initialExtras)", "public abstract void sendBroadcastAsUser(@RequiresPermission Intent intent, UserHandle user)", "public abstract void sendBroadcastAsUser(@RequiresPermission Intent intent, UserHandle user, @Nullable String receiverPermission)", "public abstract void sendBroadcastAsUser(@RequiresPermission Intent intent, UserHandle user, @Nullable String receiverPermission, @Nullable Bundle options)", "public abstract void sendBroadcastAsUser(@RequiresPermission Intent intent, UserHandle user, @Nullable String receiverPermission, int appOp)", "public abstract void sendOrderedBroadcastAsUser(@RequiresPermission Intent intent, UserHandle user, @Nullable String receiverPermission, BroadcastReceiver resultReceiver, @Nullable Handler scheduler, int initialCode, @Nullable String initialData, @Nullable Bundle initialExtras)", "public abstract void sendOrderedBroadcastAsUser(Intent intent, UserHandle user, @Nullable String receiverPermission, int appOp, BroadcastReceiver resultReceiver, @Nullable Handler scheduler, int initialCode, @Nullable String initialData, @Nullable Bundle initialExtras)", "public abstract void sendOrderedBroadcastAsUser(Intent intent, UserHandle user, @Nullable String receiverPermission, int appOp, @Nullable Bundle options, BroadcastReceiver resultReceiver, @Nullable Handler scheduler, int initialCode, @Nullable String initialData, @Nullable Bundle initialExtras)", "public void sendOrderedBroadcast(@NonNull Intent intent, @Nullable String receiverPermission, @Nullable String receiverAppOp, @Nullable BroadcastReceiver resultReceiver, @Nullable Handler scheduler, int initialCode, @Nullable String initialData, @Nullable Bundle initialExtras)", "public void sendOrderedBroadcast(@RequiresPermission @NonNull Intent intent, int initialCode, @Nullable String receiverPermission, @Nullable String receiverAppOp, @Nullable BroadcastReceiver resultReceiver, @Nullable Handler scheduler, @Nullable String initialData, @Nullable Bundle initialExtras, @Nullable Bundle options)", "public abstract void sendStickyBroadcast(@RequiresPermission Intent intent)", "public void sendStickyBroadcast(@RequiresPermission @NonNull Intent intent, @Nullable Bundle options)", "public abstract void sendStickyOrderedBroadcast(@RequiresPermission Intent intent, BroadcastReceiver resultReceiver, @Nullable Handler scheduler, int initialCode, @Nullable String initialData, @Nullable Bundle initialExtras)", "public abstract void removeStickyBroadcast(@RequiresPermission Intent intent)", "public abstract void sendStickyBroadcastAsUser(@RequiresPermission Intent intent, UserHandle user)", "public abstract void sendStickyBroadcastAsUser(@RequiresPermission Intent intent, UserHandle user, Bundle options)", "public abstract void sendStickyOrderedBroadcastAsUser(@RequiresPermission Intent intent, UserHandle user, BroadcastReceiver resultReceiver, @Nullable Handler scheduler, int initialCode, @Nullable String initialData, @Nullable Bundle initialExtras)", "public abstract void removeStickyBroadcastAsUser(@RequiresPermission Intent intent, UserHandle user)", "public abstract Intent registerReceiver(@Nullable BroadcastReceiver receiver, IntentFilter filter)", "public abstract Intent registerReceiver(@Nullable BroadcastReceiver receiver, IntentFilter filter, @RegisterReceiverFlags int flags)", "public abstract Intent registerReceiver(BroadcastReceiver receiver, IntentFilter filter, @Nullable String broadcastPermission, @Nullable Handler scheduler)", "public abstract Intent registerReceiver(BroadcastReceiver receiver, IntentFilter filter, @Nullable String broadcastPermission, @Nullable Handler scheduler, @RegisterReceiverFlags int flags)", "public Intent registerReceiverForAllUsers(@Nullable BroadcastReceiver receiver, @NonNull IntentFilter filter, @Nullable String broadcastPermission, @Nullable Handler scheduler)", "public Intent registerReceiverForAllUsers(@Nullable BroadcastReceiver receiver, @NonNull IntentFilter filter, @Nullable String broadcastPermission, @Nullable Handler scheduler, @RegisterReceiverFlags int flags)", "public abstract Intent registerReceiverAsUser(BroadcastReceiver receiver, UserHandle user, IntentFilter filter, @Nullable String broadcastPermission, @Nullable Handler scheduler)", "public abstract Intent registerReceiverAsUser(BroadcastReceiver receiver, UserHandle user, IntentFilter filter, @Nullable String broadcastPermission, @Nullable Handler scheduler, @RegisterReceiverFlags int flags)", "public abstract void unregisterReceiver(BroadcastReceiver receiver)", "public abstract ComponentName startService(Intent service)", "public abstract ComponentName startForegroundService(Intent service)", "public abstract ComponentName startForegroundServiceAsUser(Intent service, UserHandle user)", "public abstract boolean stopService(Intent service)", "public abstract ComponentName startServiceAsUser(Intent service, UserHandle user)", "public abstract boolean stopServiceAsUser(Intent service, UserHandle user)", "public abstract boolean bindService(@RequiresPermission @NonNull Intent service, @NonNull ServiceConnection conn, int flags)", "public boolean bindService(@RequiresPermission @NonNull Intent service, @NonNull ServiceConnection conn, @NonNull BindServiceFlags flags)", "public boolean bindService(@RequiresPermission @NonNull Intent service, @BindServiceFlagsBits int flags, @NonNull @CallbackExecutor Executor executor, @NonNull ServiceConnection conn)", "public boolean bindService(@RequiresPermission @NonNull Intent service, @NonNull BindServiceFlags flags, @NonNull @CallbackExecutor Executor executor, @NonNull ServiceConnection conn)", "public boolean bindIsolatedService(@RequiresPermission @NonNull Intent service, int flags, @NonNull String instanceName, @NonNull @CallbackExecutor Executor executor, @NonNull ServiceConnection conn)", "public boolean bindIsolatedService(@RequiresPermission @NonNull Intent service, @NonNull BindServiceFlags flags, @NonNull String instanceName, @NonNull @CallbackExecutor Executor executor, @NonNull ServiceConnection conn)", "public boolean bindServiceAsUser(@NonNull @RequiresPermission Intent service, @NonNull ServiceConnection conn, int flags, @NonNull UserHandle user)", "public boolean bindServiceAsUser(@NonNull @RequiresPermission Intent service, @NonNull ServiceConnection conn, @NonNull BindServiceFlags flags, @NonNull UserHandle user)", "public boolean bindServiceAsUser(Intent service, ServiceConnection conn, int flags, Handler handler, UserHandle user)", "public boolean bindServiceAsUser(@NonNull Intent service, @NonNull ServiceConnection conn, @NonNull BindServiceFlags flags, @NonNull Handler handler, @NonNull UserHandle user)", "public void updateServiceGroup(@NonNull ServiceConnection conn, int group, int importance)", "public abstract void unbindService(@NonNull ServiceConnection conn)", "public abstract boolean startInstrumentation(@NonNull ComponentName className, @Nullable String profileFile, @Nullable Bundle arguments)", "public abstract Object getSystemService(@ServiceName @NonNull String name)", "public final T getSystemService(@NonNull Class<T> serviceClass)", "public abstract String getSystemServiceName(@NonNull Class<?> serviceClass)", "public abstract int checkPermission(@NonNull @PermissionName String permission, int pid, int uid)", "public abstract int checkPermission(@NonNull String permission, int pid, int uid, IBinder callerToken)", "public abstract int checkCallingPermission(@NonNull @PermissionName String permission)", "public abstract int checkCallingOrSelfPermission(@NonNull @PermissionName String permission)", "public abstract int checkSelfPermission(@NonNull String permission)", "public abstract void enforcePermission(@NonNull @PermissionName String permission, int pid, int uid, @Nullable String message)", "public abstract void enforceCallingPermission(@NonNull @PermissionName String permission, @Nullable String message)", "public abstract void enforceCallingOrSelfPermission(@NonNull @PermissionName String permission, @Nullable String message)", "public abstract void grantUriPermission(String toPackage, Uri uri, @Intent.GrantUriMode int modeFlags)", "public abstract void revokeUriPermission(Uri uri, @Intent.AccessUriMode int modeFlags)", "public abstract void revokeUriPermission(String toPackage, Uri uri, @Intent.AccessUriMode int modeFlags)", "public abstract int checkUriPermission(Uri uri, int pid, int uid, @Intent.AccessUriMode int modeFlags)", "public int checkContentUriPermissionFull(@NonNull Uri uri, int pid, int uid, @Intent.AccessUriMode int modeFlags)", "public int[] checkUriPermissions(@NonNull List<Uri> uris, int pid, int uid, @Intent.AccessUriMode int modeFlags)", "public abstract int checkUriPermission(Uri uri, int pid, int uid, @Intent.AccessUriMode int modeFlags, IBinder callerToken)", "public abstract int checkCallingUriPermission(Uri uri, @Intent.AccessUriMode int modeFlags)", "public int[] checkCallingUriPermissions(@NonNull List<Uri> uris, @Intent.AccessUriMode int modeFlags)", "public abstract int checkCallingOrSelfUriPermission(Uri uri, @Intent.AccessUriMode int modeFlags)", "public int[] checkCallingOrSelfUriPermissions(@NonNull List<Uri> uris, @Intent.AccessUriMode int modeFlags)", "public abstract int checkUriPermission(@Nullable Uri uri, @Nullable String readPermission, @Nullable String writePermission, int pid, int uid, @Intent.AccessUriMode int modeFlags)", "public abstract void enforceUriPermission(Uri uri, int pid, int uid, @Intent.AccessUriMode int modeFlags, String message)", "public abstract void enforceCallingUriPermission(Uri uri, @Intent.AccessUriMode int modeFlags, String message)", "public abstract void enforceCallingOrSelfUriPermission(Uri uri, @Intent.AccessUriMode int modeFlags, String message)", "public abstract void enforceUriPermission(@Nullable Uri uri, @Nullable String readPermission, @Nullable String writePermission, int pid, int uid, @Intent.AccessUriMode int modeFlags, @Nullable String message)", "public void revokeSelfPermissionOnKill(@NonNull String permName)", "public void revokeSelfPermissionsOnKill(@NonNull Collection<String> permissions)", "public abstract Context createPackageContext(String packageName, @CreatePackageOptions int flags) throws PackageManager.NameNotFoundException", "public Context createPackageContextAsUser(@NonNull String packageName, @CreatePackageOptions int flags, @NonNull UserHandle user) throws PackageManager.NameNotFoundException", "public Context createContextAsUser(@NonNull UserHandle user, @CreatePackageOptions int flags)", "public abstract Context createApplicationContext(ApplicationInfo application, @CreatePackageOptions int flags) throws PackageManager.NameNotFoundException", "public Context createContextForSdkInSandbox(@NonNull ApplicationInfo sdkInfo, @CreatePackageOptions int flags) throws PackageManager.NameNotFoundException", "public abstract Context createContextForSplit(String splitName) throws PackageManager.NameNotFoundException", "public UserHandle getUser()", "public int getUserId()", "public abstract Context createConfigurationContext(@NonNull Configuration overrideConfiguration)", "public abstract Context createDisplayContext(@NonNull Display display)", "public Context createDeviceContext(int deviceId)", "public Context createWindowContext(@WindowType int type, @Nullable Bundle options)", "public Context createWindowContext(@NonNull Display display, @WindowType int type, @SuppressLint(\"NullableCollection\") @Nullable Bundle options)", "public Context createContext(@NonNull ContextParams contextParams)", "public Context createAttributionContext(@Nullable String attributionTag)", "public Context createFeatureContext(@Nullable String attributionTag)", "public abstract Context createDeviceProtectedStorageContext()", "public abstract Context createCredentialProtectedStorageContext()", "public Context createTokenContext(@NonNull IBinder token, @NonNull Display display)", "public abstract DisplayAdjustments getDisplayAdjustments(int displayId)", "public Display getDisplay()", "public Display getDisplayNoVerify()", "public abstract int getDisplayId()", "public int getAssociatedDisplayId()", "public abstract void updateDisplay(int displayId)", "public void updateDeviceId(int deviceId)", "public int getDeviceId()", "public void registerDeviceIdChangeListener(@NonNull @CallbackExecutor Executor executor, @NonNull IntConsumer listener)", "public void unregisterDeviceIdChangeListener(@NonNull IntConsumer listener)", "public boolean isRestricted()", "public abstract boolean isDeviceProtectedStorage()", "public abstract boolean isCredentialProtectedStorage()", "public abstract boolean canLoadUnsafeResources()", "public IBinder getActivityToken()", "public IBinder getWindowContextToken()", "public static IBinder getToken(@NonNull Context context)", "public IServiceConnection getServiceDispatcher(ServiceConnection conn, Handler handler, long flags)", "public IApplicationThread getIApplicationThread()", "public IBinder getProcessToken()", "public Handler getMainThreadHandler()", "public AutofillClient getAutofillClient()", "public void setAutofillClient(@SuppressWarnings(\"unused\") AutofillClient client)", "public ContentCaptureClient getContentCaptureClient()", "public final boolean isAutofillCompatibilityEnabled()", "public AutofillOptions getAutofillOptions()", "public void setAutofillOptions(@SuppressWarnings(\"unused\") @Nullable AutofillOptions options)", "public ContentCaptureOptions getContentCaptureOptions()", "public void setContentCaptureOptions(@SuppressWarnings(\"unused\") @Nullable ContentCaptureOptions options)", "public void assertRuntimeOverlayThemable()", "public boolean isUiContext()", "public void destroy()", "public boolean isConfigurationContext()", "public void closeSystemDialogs()" ],
  "variableNames" : [ "OVERRIDABLE_COMPONENT_CALLBACKS", "DEVICE_ID_DEFAULT", "DEVICE_ID_INVALID", "MODE_PRIVATE", "MODE_WORLD_READABLE", "MODE_WORLD_WRITEABLE", "MODE_APPEND", "MODE_MULTI_PROCESS", "MODE_ENABLE_WRITE_AHEAD_LOGGING", "MODE_NO_LOCALIZED_COLLATORS", "BIND_AUTO_CREATE", "BIND_DEBUG_UNBIND", "BIND_NOT_FOREGROUND", "BIND_ABOVE_CLIENT", "BIND_ALLOW_OOM_MANAGEMENT", "BIND_WAIVE_PRIORITY", "BIND_IMPORTANT", "BIND_ADJUST_WITH_ACTIVITY", "BIND_NOT_PERCEPTIBLE", "BIND_ALLOW_ACTIVITY_STARTS", "BIND_INCLUDE_CAPABILITIES", "BIND_SHARED_ISOLATED_PROCESS", "BIND_PACKAGE_ISOLATED_PROCESS", "BIND_NOT_APP_COMPONENT_USAGE", "BIND_ALMOST_PERCEPTIBLE", "BIND_BYPASS_POWER_NETWORK_RESTRICTIONS", "BIND_ALLOW_FOREGROUND_SERVICE_STARTS_FROM_BACKGROUND", "BIND_SCHEDULE_LIKE_TOP_APP", "BIND_ALLOW_BACKGROUND_ACTIVITY_STARTS", "BIND_RESTRICT_ASSOCIATIONS", "BIND_ALLOW_INSTANT", "BIND_IMPORTANT_BACKGROUND", "BIND_ALLOW_WHITELIST_MANAGEMENT", "BIND_FOREGROUND_SERVICE_WHILE_AWAKE", "BIND_FOREGROUND_SERVICE", "BIND_TREAT_LIKE_ACTIVITY", "BIND_VISIBLE", "BIND_TREAT_LIKE_VISIBLE_FOREGROUND_SERVICE", "BIND_SHOWING_UI", "BIND_NOT_VISIBLE", "BIND_EXTERNAL_SERVICE", "BIND_EXTERNAL_SERVICE_LONG", "BIND_BYPASS_USER_NETWORK_RESTRICTIONS", "BIND_MATCH_QUARANTINED_COMPONENTS", "BIND_REDUCTION_FLAGS", "RECEIVER_VISIBLE_TO_INSTANT_APPS", "RECEIVER_EXPORTED", "RECEIVER_EXPORTED_UNAUDITED", "RECEIVER_NOT_EXPORTED", "sLastAutofillId", "POWER_SERVICE", "POWER_STATS_SERVICE", "RECOVERY_SERVICE", "SYSTEM_UPDATE_SERVICE", "WINDOW_SERVICE", "LAYOUT_INFLATER_SERVICE", "ACCOUNT_SERVICE", "ACTIVITY_SERVICE", "ACTIVITY_TASK_SERVICE", "URI_GRANTS_SERVICE", "ALARM_SERVICE", "NOTIFICATION_SERVICE", "ACCESSIBILITY_SERVICE", "CAPTIONING_SERVICE", "KEYGUARD_SERVICE", "LOCATION_SERVICE", "COUNTRY_DETECTOR", "SEARCH_SERVICE", "SENSOR_SERVICE", "SENSOR_PRIVACY_SERVICE", "STORAGE_SERVICE", "STORAGE_STATS_SERVICE", "WALLPAPER_SERVICE", "VIBRATOR_MANAGER_SERVICE", "VIBRATOR_SERVICE", "STATUS_BAR_SERVICE", "CONNECTIVITY_SERVICE", "PAC_PROXY_SERVICE", "VCN_MANAGEMENT_SERVICE", "NETD_SERVICE", "NETWORK_STACK_SERVICE", "TETHERING_SERVICE", "THREAD_NETWORK_SERVICE", "IPSEC_SERVICE", "VPN_MANAGEMENT_SERVICE", "CONNECTIVITY_DIAGNOSTICS_SERVICE", "TEST_NETWORK_SERVICE", "UPDATE_LOCK_SERVICE", "NETWORKMANAGEMENT_SERVICE", "SLICE_SERVICE", "NETWORK_STATS_SERVICE", "NETWORK_POLICY_SERVICE", "NETWORK_WATCHLIST_SERVICE", "WIFI_SERVICE", "WIFI_NL80211_SERVICE", "WIFI_P2P_SERVICE", "WIFI_AWARE_SERVICE", "WIFI_SCANNING_SERVICE", "WIFI_RTT_SERVICE", "WIFI_RTT_RANGING_SERVICE", "LOWPAN_SERVICE", "ETHERNET_SERVICE", "NSD_SERVICE", "AUDIO_SERVICE", "AUDIO_DEVICE_VOLUME_SERVICE", "MEDIA_TRANSCODING_SERVICE", "AUTH_SERVICE", "FINGERPRINT_SERVICE", "FACE_SERVICE", "IRIS_SERVICE", "BIOMETRIC_SERVICE", "MEDIA_COMMUNICATION_SERVICE", "MEDIA_ROUTER_SERVICE", "MEDIA_SESSION_SERVICE", "TELEPHONY_SERVICE", "TELEPHONY_SUBSCRIPTION_SERVICE", "TELECOM_SERVICE", "CARRIER_CONFIG_SERVICE", "EUICC_SERVICE", "EUICC_CARD_SERVICE", "MMS_SERVICE", "CLIPBOARD_SERVICE", "TEXT_CLASSIFICATION_SERVICE", "SELECTION_TOOLBAR_SERVICE", "FONT_SERVICE", "ATTENTION_SERVICE", "ROTATION_RESOLVER_SERVICE", "INPUT_METHOD_SERVICE", "TEXT_SERVICES_MANAGER_SERVICE", "APPWIDGET_SERVICE", "VOICE_INTERACTION_MANAGER_SERVICE", "AUTOFILL_MANAGER_SERVICE", "TEXT_TO_SPEECH_MANAGER_SERVICE", "CONTENT_CAPTURE_MANAGER_SERVICE", "TRANSLATION_MANAGER_SERVICE", "UI_TRANSLATION_SERVICE", "CONTENT_SUGGESTIONS_SERVICE", "APP_PREDICTION_SERVICE", "FEATURE_FLAGS_SERVICE", "SEARCH_UI_SERVICE", "SMARTSPACE_SERVICE", "CONTEXTUAL_SEARCH_SERVICE", "CLOUDSEARCH_SERVICE", "SOUND_TRIGGER_SERVICE", "SOUND_TRIGGER_MIDDLEWARE_SERVICE", "WALLPAPER_EFFECTS_GENERATION_SERVICE", "MUSIC_RECOGNITION_SERVICE", "PERMISSION_SERVICE", "LEGACY_PERMISSION_SERVICE", "PERMISSION_CONTROLLER_SERVICE", "PERMISSION_CHECKER_SERVICE", "PERMISSION_ENFORCER_SERVICE", "APP_HIBERNATION_SERVICE", "BACKUP_SERVICE", "ROLLBACK_SERVICE", "REBOOT_READINESS_SERVICE", "DROPBOX_SERVICE", "BACKGROUND_INSTALL_CONTROL_SERVICE", "BINARY_TRANSPARENCY_SERVICE", "DEVICE_IDLE_CONTROLLER", "POWER_WHITELIST_MANAGER", "POWER_EXEMPTION_SERVICE", "DEVICE_POLICY_SERVICE", "UI_MODE_SERVICE", "DOWNLOAD_SERVICE", "BATTERY_SERVICE", "NFC_SERVICE", "BLUETOOTH_SERVICE", "SIP_SERVICE", "USB_SERVICE", "ADB_SERVICE", "SERIAL_SERVICE", "HDMI_CONTROL_SERVICE", "INPUT_SERVICE", "DISPLAY_SERVICE", "COLOR_DISPLAY_SERVICE", "USER_SERVICE", "LAUNCHER_APPS_SERVICE", "RESTRICTIONS_SERVICE", "APP_OPS_SERVICE", "ROLE_SERVICE", "CAMERA_SERVICE", "PRINT_SERVICE", "COMPANION_DEVICE_SERVICE", "VIRTUAL_DEVICE_SERVICE", "CONSUMER_IR_SERVICE", "TRUST_SERVICE", "TV_INTERACTIVE_APP_SERVICE", "TV_INPUT_SERVICE", "TV_AD_SERVICE", "TV_TUNER_RESOURCE_MGR_SERVICE", "NETWORK_SCORE_SERVICE", "USAGE_STATS_SERVICE", "JOB_SCHEDULER_SERVICE", "PERSISTENT_DATA_BLOCK_SERVICE", "OEM_LOCK_SERVICE", "MEDIA_PROJECTION_SERVICE", "MIDI_SERVICE", "RADIO_SERVICE", "HARDWARE_PROPERTIES_SERVICE", "THERMAL_SERVICE", "PERFORMANCE_HINT_SERVICE", "SHORTCUT_SERVICE", "CONTEXTHUB_SERVICE", "SYSTEM_HEALTH_SERVICE", "GATEKEEPER_SERVICE", "DEVICE_IDENTIFIERS_SERVICE", "INCIDENT_SERVICE", "INCIDENT_COMPANION_SERVICE", "STATS_MANAGER_SERVICE", "STATS_COMPANION_SERVICE", "STATS_BOOTSTRAP_ATOM_SERVICE", "STATS_MANAGER", "PLATFORM_COMPAT_SERVICE", "PLATFORM_COMPAT_NATIVE_SERVICE", "BUGREPORT_SERVICE", "OVERLAY_SERVICE", "RESOURCES_SERVICE", "IDMAP_SERVICE", "VR_SERVICE", "CROSS_PROFILE_APPS_SERVICE", "SECURE_ELEMENT_SERVICE", "TIME_DETECTOR_SERVICE", "TIME_ZONE_DETECTOR_SERVICE", "TIME_MANAGER_SERVICE", "APP_BINDING_SERVICE", "TELEPHONY_IMS_SERVICE", "SYSTEM_CONFIG_SERVICE", "TELEPHONY_RCS_MESSAGE_SERVICE", "DYNAMIC_SYSTEM_SERVICE", "BLOB_STORE_SERVICE", "TELEPHONY_REGISTRY_SERVICE", "BATTERY_STATS_SERVICE", "APP_SEARCH_SERVICE", "APP_INTEGRITY_SERVICE", "DATA_LOADER_MANAGER_SERVICE", "INCREMENTAL_SERVICE", "ATTESTATION_VERIFICATION_SERVICE", "FILE_INTEGRITY_SERVICE", "REMOTE_PROVISIONING_SERVICE", "LIGHTS_SERVICE", "UWB_SERVICE", "DREAM_SERVICE", "SMS_SERVICE", "PEOPLE_SERVICE", "DEVICE_STATE_SERVICE", "MEDIA_METRICS_SERVICE", "SPEECH_RECOGNITION_SERVICE", "GAME_SERVICE", "DOMAIN_VERIFICATION_SERVICE", "DISPLAY_HASH_SERVICE", "LOCALE_SERVICE", "SAFETY_CENTER_SERVICE", "NEARBY_SERVICE", "REMOTE_AUTH_SERVICE", "AMBIENT_CONTEXT_SERVICE", "WEARABLE_SENSING_SERVICE", "ON_DEVICE_INTELLIGENCE_SERVICE", "HEALTHCONNECT_SERVICE", "CREDENTIAL_SERVICE", "DEVICE_LOCK_SERVICE", "VIRTUALIZATION_SERVICE", "GRAMMATICAL_INFLECTION_SERVICE", "SATELLITE_SERVICE", "SHARED_CONNECTIVITY_SERVICE", "SECURITY_STATE_SERVICE", "ECM_ENHANCED_CONFIRMATION_SERVICE", "SENSITIVE_CONTENT_PROTECTION_SERVICE", "CONTACT_KEYS_SERVICE", "PROFILING_SERVICE", "WEBVIEW_UPDATE_SERVICE", "BLOCKED_NUMBERS_SERVICE", "CONTEXT_INCLUDE_CODE", "CONTEXT_IGNORE_SECURITY", "CONTEXT_RESTRICTED", "CONTEXT_DEVICE_PROTECTED_STORAGE", "CONTEXT_CREDENTIAL_PROTECTED_STORAGE", "CONTEXT_REGISTER_PACKAGE" ]
}