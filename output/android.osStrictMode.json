{
  "filePath" : "/home/maryam/clearblue/files/android-source-30/android/os/StrictMode.java",
  "packageName" : "android.os",
  "className" : "StrictMode",
  "comment" : "\n * StrictMode is a developer tool which detects things you might be doing by accident and brings\n * them to your attention so you can fix them.\n *\n * <p>StrictMode is most commonly used to catch accidental disk or network access on the\n * application's main thread, where UI operations are received and animations take place. Keeping\n * disk and network operations off the main thread makes for much smoother, more responsive\n * applications. By keeping your application's main thread responsive, you also prevent <a\n * href=\"{@docRoot}guide/practices/design/responsiveness.html\">ANR dialogs</a> from being shown to\n * users.\n *\n * <p class=\"note\">Note that even though an Android device's disk is often on flash memory, many\n * devices run a filesystem on top of that memory with very limited concurrency. It's often the case\n * that almost all disk accesses are fast, but may in individual cases be dramatically slower when\n * certain I/O is happening in the background from other processes. If possible, it's best to assume\n * that such things are not fast.\n *\n * <p>Example code to enable from early in your {@link android.app.Application}, {@link\n * android.app.Activity}, or other application component's {@link android.app.Application#onCreate}\n * method:\n *\n * <pre>\n * public void onCreate() {\n *     if (DEVELOPER_MODE) {\n *         StrictMode.setThreadPolicy(new {@link ThreadPolicy.Builder StrictMode.ThreadPolicy.Builder}()\n *                 .detectDiskReads()\n *                 .detectDiskWrites()\n *                 .detectNetwork()   // or .detectAll() for all detectable problems\n *                 .penaltyLog()\n *                 .build());\n *         StrictMode.setVmPolicy(new {@link VmPolicy.Builder StrictMode.VmPolicy.Builder}()\n *                 .detectLeakedSqlLiteObjects()\n *                 .detectLeakedClosableObjects()\n *                 .penaltyLog()\n *                 .penaltyDeath()\n *                 .build());\n *     }\n *     super.onCreate();\n * }\n * </pre>\n *\n * <p>You can decide what should happen when a violation is detected. For example, using {@link\n * ThreadPolicy.Builder#penaltyLog} you can watch the output of <code>adb logcat</code> while you\n * use your application to see the violations as they happen.\n *\n * <p>If you find violations that you feel are problematic, there are a variety of tools to help\n * solve them: threads, {@link android.os.Handler}, {@link android.os.AsyncTask}, {@link\n * android.app.IntentService}, etc. But don't feel compelled to fix everything that StrictMode\n * finds. In particular, many cases of disk access are often necessary during the normal activity\n * lifecycle. Use StrictMode to find things you did by accident. Network requests on the UI thread\n * are almost always a problem, though.\n *\n * <p class=\"note\">StrictMode is not a security mechanism and is not guaranteed to find all disk or\n * network accesses. While it does propagate its state across process boundaries when doing {@link\n * android.os.Binder} calls, it's still ultimately a best effort mechanism. Notably, disk or network\n * access from JNI calls won't necessarily trigger it. Future versions of Android may catch more (or\n * fewer) operations, so you should never leave StrictMode enabled in applications distributed on\n * Google Play.\n ",
  "variables" : [ {
    "name" : "TAG",
    "type" : "String",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "LOG_V",
    "type" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "DISABLE_PROPERTY",
    "type" : "String",
    "comment" : "\n     * Boolean system property to disable strict mode checks outright. Set this to 'true' to force\n     * disable; 'false' has no effect on other enable/disable policy.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "VISUAL_PROPERTY",
    "type" : "String",
    "comment" : "\n     * The boolean system property to control screen flashes on violations.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "CLEARTEXT_PROPERTY",
    "type" : "String",
    "comment" : "\n     * Temporary property used to include {@link #DETECT_VM_CLEARTEXT_NETWORK} in {@link\n     * VmPolicy.Builder#detectAll()}. Apps can still always opt-into detection using {@link\n     * VmPolicy.Builder#detectCleartextNetwork()}.\n     ",
    "links" : [ "#DETECT_VM_CLEARTEXT_NETWORK" ]
  }, {
    "name" : "DISABLE",
    "type" : "boolean",
    "comment" : "\n     * Quick feature-flag that can be used to disable the defaults provided by {@link\n     * #initThreadDefaults(ApplicationInfo)} and {@link #initVmDefaults(ApplicationInfo)}.\n     ",
    "links" : [ "#initVmDefaults" ]
  }, {
    "name" : "MIN_VM_INTERVAL_MS",
    "type" : "long",
    "comment" : " Only apply VM penalties for the same violation at this interval.",
    "links" : [ ]
  }, {
    "name" : "MIN_LOG_INTERVAL_MS",
    "type" : "long",
    "comment" : " Only log a duplicate stack trace to the logs every second.",
    "links" : [ ]
  }, {
    "name" : "MIN_DIALOG_INTERVAL_MS",
    "type" : "long",
    "comment" : " Only show an annoying dialog at most every 30 seconds",
    "links" : [ ]
  }, {
    "name" : "MIN_DROPBOX_INTERVAL_MS",
    "type" : "long",
    "comment" : " Only log a dropbox entry at most every 30 seconds",
    "links" : [ ]
  }, {
    "name" : "MAX_SPAN_TAGS",
    "type" : "int",
    "comment" : " How many Span tags (e.g. animations) to report.",
    "links" : [ ]
  }, {
    "name" : "MAX_OFFENSES_PER_LOOP",
    "type" : "int",
    "comment" : " of the Looper.",
    "links" : [ ]
  }, {
    "name" : "DETECT_THREAD_DISK_WRITE",
    "type" : "int",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "DETECT_THREAD_DISK_READ",
    "type" : "int",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "DETECT_THREAD_NETWORK",
    "type" : "int",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "DETECT_THREAD_CUSTOM",
    "type" : "int",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "DETECT_THREAD_RESOURCE_MISMATCH",
    "type" : "int",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "DETECT_THREAD_UNBUFFERED_IO",
    "type" : "int",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "DETECT_THREAD_EXPLICIT_GC",
    "type" : "int",
    "comment" : " @hide  ",
    "links" : [ ]
  }, {
    "name" : "DETECT_THREAD_ALL",
    "type" : "int",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "DETECT_VM_CURSOR_LEAKS",
    "type" : "int",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "DETECT_VM_CLOSABLE_LEAKS",
    "type" : "int",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "DETECT_VM_ACTIVITY_LEAKS",
    "type" : "int",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "DETECT_VM_INSTANCE_LEAKS",
    "type" : "int",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "DETECT_VM_REGISTRATION_LEAKS",
    "type" : "int",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "DETECT_VM_FILE_URI_EXPOSURE",
    "type" : "int",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "DETECT_VM_CLEARTEXT_NETWORK",
    "type" : "int",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "DETECT_VM_CONTENT_URI_WITHOUT_PERMISSION",
    "type" : "int",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "DETECT_VM_UNTAGGED_SOCKET",
    "type" : "int",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "DETECT_VM_NON_SDK_API_USAGE",
    "type" : "int",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "DETECT_VM_IMPLICIT_DIRECT_BOOT",
    "type" : "int",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "DETECT_VM_CREDENTIAL_PROTECTED_WHILE_LOCKED",
    "type" : "int",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "DETECT_VM_INCORRECT_CONTEXT_USE",
    "type" : "int",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "DETECT_VM_ALL",
    "type" : "int",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "PENALTY_GATHER",
    "type" : "int",
    "comment" : "\n     * Non-public penalty mode which overrides all the other penalty bits and signals that we're in\n     * a Binder call and we should ignore the other penalty bits and instead serialize back all our\n     * offending stack traces to the caller to ultimately handle in the originating process.\n     *\n     * <p>This must be kept in sync with the constant in libs/binder/Parcel.cpp\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "PENALTY_LOG",
    "type" : "int",
    "comment" : " {@hide} ",
    "links" : [ ]
  }, {
    "name" : "PENALTY_DIALOG",
    "type" : "int",
    "comment" : " {@hide} ",
    "links" : [ ]
  }, {
    "name" : "PENALTY_DEATH",
    "type" : "int",
    "comment" : " {@hide} ",
    "links" : [ ]
  }, {
    "name" : "PENALTY_FLASH",
    "type" : "int",
    "comment" : " {@hide} ",
    "links" : [ ]
  }, {
    "name" : "PENALTY_DROPBOX",
    "type" : "int",
    "comment" : " {@hide} ",
    "links" : [ ]
  }, {
    "name" : "PENALTY_DEATH_ON_NETWORK",
    "type" : "int",
    "comment" : " {@hide} ",
    "links" : [ ]
  }, {
    "name" : "PENALTY_DEATH_ON_CLEARTEXT_NETWORK",
    "type" : "int",
    "comment" : " {@hide} ",
    "links" : [ ]
  }, {
    "name" : "PENALTY_DEATH_ON_FILE_URI_EXPOSURE",
    "type" : "int",
    "comment" : " {@hide} ",
    "links" : [ ]
  }, {
    "name" : "PENALTY_ALL",
    "type" : "int",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "NETWORK_POLICY_ACCEPT",
    "type" : "int",
    "comment" : " {@hide} ",
    "links" : [ ]
  }, {
    "name" : "NETWORK_POLICY_LOG",
    "type" : "int",
    "comment" : " {@hide} ",
    "links" : [ ]
  }, {
    "name" : "NETWORK_POLICY_REJECT",
    "type" : "int",
    "comment" : " {@hide} ",
    "links" : [ ]
  }, {
    "name" : "EMPTY_CLASS_LIMIT_MAP",
    "type" : "HashMap<Class, Integer>",
    "comment" : " Note: must be before static initialization of sVmPolicy.",
    "links" : [ ]
  }, {
    "name" : "sVmPolicy",
    "type" : "VmPolicy",
    "comment" : " The current VmPolicy in effect. ",
    "links" : [ ]
  }, {
    "name" : "LOGCAT_LOGGER",
    "type" : "ViolationLogger",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "sLogger",
    "type" : "ViolationLogger",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "sThreadViolationListener",
    "type" : "ThreadLocal<OnThreadViolationListener>",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "sThreadViolationExecutor",
    "type" : "ThreadLocal<Executor>",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "sDropboxCallsInFlight",
    "type" : "AtomicInteger",
    "comment" : "\n     * The number of threads trying to do an async dropbox write. Just to limit ourselves out of\n     * paranoia.\n     ",
    "links" : [ ]
  }, {
    "name" : "sNonSdkApiUsageConsumer",
    "type" : "Consumer<String>",
    "comment" : "\n     * Callback supplied to dalvik / libcore to get informed of usages of java API that are not\n     * a part of the public SDK.\n     ",
    "links" : [ ]
  }, {
    "name" : "gatheredViolations",
    "type" : "ThreadLocal<ArrayList<ViolationInfo>>",
    "comment" : "\n     * Log of strict mode violation stack traces that have occurred during a Binder call, to be\n     * serialized back later to the caller via Parcel.writeNoException() (amusingly) where the\n     * caller can choose how to react.\n     ",
    "links" : [ ]
  }, {
    "name" : "violationsBeingTimed",
    "type" : "ThreadLocal<ArrayList<ViolationInfo>>",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "THREAD_HANDLER",
    "type" : "ThreadLocal<Handler>",
    "comment" : " Note: only access this once verifying the thread has a Looper.",
    "links" : [ ]
  }, {
    "name" : "THREAD_ANDROID_POLICY",
    "type" : "ThreadLocal<AndroidBlockGuardPolicy>",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "VM_ANDROID_POLICY",
    "type" : "BlockGuard.VmPolicy",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "sLastInstanceCountCheckMillis",
    "type" : "long",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "sIsIdlerRegistered",
    "type" : "boolean",
    "comment" : " guarded by StrictMode.class",
    "links" : [ ]
  }, {
    "name" : "sProcessIdleHandler",
    "type" : "MessageQueue.IdleHandler",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "sUserKeyUnlocked",
    "type" : "boolean",
    "comment" : " Assume locked until we hear otherwise ",
    "links" : [ ]
  }, {
    "name" : "sLastVmViolationTime",
    "type" : "HashMap<Integer, Long>",
    "comment" : " Map from VM violation fingerprint to uptime millis.",
    "links" : [ ]
  }, {
    "name" : "NO_OP_SPAN",
    "type" : "Span",
    "comment" : " The no-op span that's used in user builds.",
    "links" : [ ]
  }, {
    "name" : "sThisThreadSpanState",
    "type" : "ThreadLocal<ThreadSpanState>",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "sWindowManager",
    "type" : "Singleton<IWindowManager>",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "sExpectedActivityInstanceCount",
    "type" : "HashMap<Class, Integer>",
    "comment" : "",
    "links" : [ ]
  } ],
  "methods" : [ {
    "name" : "public static void setViolationLogger(ViolationLogger listener)",
    "returnType" : "void",
    "comment" : " {@hide} ",
    "links" : [ ]
  }, {
    "name" : "public static void setThreadPolicy(final ThreadPolicy policy)",
    "returnType" : "void",
    "comment" : "\n     * Sets the policy for what actions on the current thread should be detected, as well as the\n     * penalty if such actions occur.\n     *\n     * <p>Internally this sets a thread-local variable which is propagated across cross-process IPC\n     * calls, meaning you can catch violations when a system service or another process accesses the\n     * disk or network on your behalf.\n     *\n     * @param policy the policy to put into place\n     ",
    "links" : [ ]
  }, {
    "name" : "public static void setThreadPolicyMask(@ThreadPolicyMask int threadPolicyMask)",
    "returnType" : "void",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "private static void setBlockGuardPolicy(@ThreadPolicyMask int threadPolicyMask)",
    "returnType" : "void",
    "comment" : " Sets the policy in Dalvik/libcore (BlockGuard)",
    "links" : [ ]
  }, {
    "name" : "private static void setBlockGuardVmPolicy(@VmPolicyMask int vmPolicyMask)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private static void setCloseGuardEnabled(boolean enabled)",
    "returnType" : "void",
    "comment" : " Sets up CloseGuard in Dalvik/libcore",
    "links" : [ ]
  }, {
    "name" : "public static int getThreadPolicyMask()",
    "returnType" : "int",
    "comment" : "\n     * Returns the bitmask of the current thread's policy.\n     *\n     * @return the bitmask of all the DETECT_* and PENALTY_* bits currently enabled\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public static ThreadPolicy getThreadPolicy()",
    "returnType" : "ThreadPolicy",
    "comment" : " Returns the current thread's policy. ",
    "links" : [ ]
  }, {
    "name" : "public static ThreadPolicy allowThreadDiskWrites()",
    "returnType" : "ThreadPolicy",
    "comment" : "\n     * A convenience wrapper that takes the current {@link ThreadPolicy} from {@link\n     * #getThreadPolicy}, modifies it to permit both disk reads &amp; writes, and sets the new\n     * policy with {@link #setThreadPolicy}, returning the old policy so you can restore it at the\n     * end of a block.\n     *\n     * @return the old policy, to be passed to {@link #setThreadPolicy} to restore the policy at the\n     *     end of a block\n     ",
    "links" : [ "ThreadPolicy", "#setThreadPolicy", "#setThreadPolicy" ]
  }, {
    "name" : "public static int allowThreadDiskWritesMask()",
    "returnType" : "int",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "public static ThreadPolicy allowThreadDiskReads()",
    "returnType" : "ThreadPolicy",
    "comment" : "\n     * A convenience wrapper that takes the current {@link ThreadPolicy} from {@link\n     * #getThreadPolicy}, modifies it to permit disk reads, and sets the new policy with {@link\n     * #setThreadPolicy}, returning the old policy so you can restore it at the end of a block.\n     *\n     * @return the old policy, to be passed to setThreadPolicy to restore the policy.\n     ",
    "links" : [ "ThreadPolicy" ]
  }, {
    "name" : "public static int allowThreadDiskReadsMask()",
    "returnType" : "int",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "public static ThreadPolicy allowThreadViolations()",
    "returnType" : "ThreadPolicy",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "public static VmPolicy allowVmViolations()",
    "returnType" : "VmPolicy",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "public static boolean isBundledSystemApp(ApplicationInfo ai)",
    "returnType" : "boolean",
    "comment" : "\n     * Determine if the given app is \"bundled\" as part of the system image. These bundled apps are\n     * developed in lock-step with the OS, and they aren't updated outside of an OTA, so we want to\n     * chase any {@link StrictMode} regressions by enabling detection when running on {@link\n     * Build#IS_USERDEBUG} or {@link Build#IS_ENG} builds.\n     *\n     * <p>Unbundled apps included in the system image are expected to detect and triage their own\n     * {@link StrictMode} issues separate from the OS release process, which is why we don't enable\n     * them here.\n     *\n     * @hide\n     ",
    "links" : [ "StrictMode", "Build#IS_ENG", "StrictMode" ]
  }, {
    "name" : "public static void initThreadDefaults(ApplicationInfo ai)",
    "returnType" : "void",
    "comment" : "\n     * Initialize default {@link ThreadPolicy} for the current thread.\n     *\n     * @hide\n     ",
    "links" : [ "ThreadPolicy" ]
  }, {
    "name" : "public static void initVmDefaults(ApplicationInfo ai)",
    "returnType" : "void",
    "comment" : "\n     * Initialize default {@link VmPolicy} for the current VM.\n     *\n     * @hide\n     ",
    "links" : [ "VmPolicy" ]
  }, {
    "name" : "public static void enableDeathOnFileUriExposure()",
    "returnType" : "void",
    "comment" : "\n     * Used by the framework to make file usage a fatal error.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public static void disableDeathOnFileUriExposure()",
    "returnType" : "void",
    "comment" : "\n     * Used by lame internal apps that haven't done the hard work to get themselves off file:// Uris\n     * yet.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "private static boolean tooManyViolationsThisLoop()",
    "returnType" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private static void dropboxViolationAsync(final int penaltyMask, final ViolationInfo info)",
    "returnType" : "void",
    "comment" : "\n     * In the common case, as set by conditionallyEnableDebugLogging, we're just dropboxing any\n     * violations but not showing a dialog, not loggging, and not killing the process. In these\n     * cases we don't need to do a synchronous call to the ActivityManager. This is used by both\n     * per-thread and vm-wide violations when applicable.\n     ",
    "links" : [ ]
  }, {
    "name" : "private static void handleApplicationStrictModeViolation(int penaltyMask, ViolationInfo info)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : " static boolean hasGatheredViolations()",
    "returnType" : "boolean",
    "comment" : " package ",
    "links" : [ ]
  }, {
    "name" : " static void clearGatheredViolations()",
    "returnType" : "void",
    "comment" : " package ",
    "links" : [ ]
  }, {
    "name" : "public static void conditionallyCheckInstanceCounts()",
    "returnType" : "void",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "public static void setVmPolicy(final VmPolicy policy)",
    "returnType" : "void",
    "comment" : "\n     * Sets the policy for what actions in the VM process (on any thread) should be detected, as\n     * well as the penalty if such actions occur.\n     *\n     * @param policy the policy to put into place\n     ",
    "links" : [ ]
  }, {
    "name" : "public static VmPolicy getVmPolicy()",
    "returnType" : "VmPolicy",
    "comment" : " Gets the current VM policy. ",
    "links" : [ ]
  }, {
    "name" : "public static void enableDefaults()",
    "returnType" : "void",
    "comment" : "\n     * Enable the recommended StrictMode defaults, with violations just being logged.\n     *\n     * <p>This catches disk and network access on the main thread, as well as leaked SQLite cursors\n     * and unclosed resources. This is simply a wrapper around {@link #setVmPolicy} and {@link\n     * #setThreadPolicy}.\n     ",
    "links" : [ "#setVmPolicy" ]
  }, {
    "name" : "public static boolean vmSqliteObjectLeaksEnabled()",
    "returnType" : "boolean",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "public static boolean vmClosableObjectLeaksEnabled()",
    "returnType" : "boolean",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "public static boolean vmRegistrationLeaksEnabled()",
    "returnType" : "boolean",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "public static boolean vmFileUriExposureEnabled()",
    "returnType" : "boolean",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "public static boolean vmCleartextNetworkEnabled()",
    "returnType" : "boolean",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "public static boolean vmContentUriWithoutPermissionEnabled()",
    "returnType" : "boolean",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "public static boolean vmUntaggedSocketEnabled()",
    "returnType" : "boolean",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "public static boolean vmImplicitDirectBootEnabled()",
    "returnType" : "boolean",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "public static boolean vmCredentialProtectedWhileLockedEnabled()",
    "returnType" : "boolean",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "public static boolean vmIncorrectContextUseEnabled()",
    "returnType" : "boolean",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "public static void onSqliteObjectLeaked(String message, Throwable originStack)",
    "returnType" : "void",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "public static void onWebViewMethodCalledOnWrongThread(Throwable originStack)",
    "returnType" : "void",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "public static void onIntentReceiverLeaked(Throwable originStack)",
    "returnType" : "void",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "public static void onServiceConnectionLeaked(Throwable originStack)",
    "returnType" : "void",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "public static void onFileUriExposed(Uri uri, String location)",
    "returnType" : "void",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "public static void onContentUriWithoutPermission(Uri uri, String location)",
    "returnType" : "void",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "public static void onCleartextNetworkDetected(byte[] firstPacket)",
    "returnType" : "void",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "public static void onUntaggedSocket()",
    "returnType" : "void",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "public static void onImplicitDirectBoot()",
    "returnType" : "void",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "public static void onIncorrectContextUsed(String message, Throwable originStack)",
    "returnType" : "void",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "private static boolean isUserKeyUnlocked(int userId)",
    "returnType" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private static void onCredentialProtectedPathAccess(String path, int userId)",
    "returnType" : "void",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "private static void clampViolationTimeMap(@NonNull final Map<Integer, Long> violationTime, final long retainSince)",
    "returnType" : "void",
    "comment" : "\n     * Clamp the given map by removing elements with timestamp older than the given retainSince.\n     ",
    "links" : [ ]
  }, {
    "name" : "public static void onVmPolicyViolation(Violation originStack)",
    "returnType" : "void",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "public static void onVmPolicyViolation(Violation violation, boolean forceDeath)",
    "returnType" : "void",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : " static void writeGatheredViolationsToParcel(Parcel p)",
    "returnType" : "void",
    "comment" : " package ",
    "links" : [ ]
  }, {
    "name" : " static void readAndHandleBinderCallViolations(Parcel p)",
    "returnType" : "void",
    "comment" : " package ",
    "links" : [ ]
  }, {
    "name" : "private static void onBinderStrictModePolicyChange(@ThreadPolicyMask int newPolicy)",
    "returnType" : "void",
    "comment" : "\n     * Called from android_util_Binder.cpp's android_os_Parcel_enforceInterface when an incoming\n     * Binder call requires changing the StrictMode policy mask. The role of this function is to ask\n     * Binder for its current (native) thread-local policy value and synchronize it to libcore's\n     * (Java) thread-local policy value.\n     ",
    "links" : [ ]
  }, {
    "name" : "public static Span enterCriticalSpan(String name)",
    "returnType" : "Span",
    "comment" : "\n     * Enter a named critical span (e.g. an animation)\n     *\n     * <p>The name is an arbitary label (or tag) that will be applied to any strictmode violation\n     * that happens while this span is active. You must call finish() on the span when done.\n     *\n     * <p>This will never return null, but on devices without debugging enabled, this may return a\n     * dummy object on which the finish() method is a no-op.\n     *\n     * <p>TODO: add CloseGuard to this, verifying callers call finish.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public static void noteSlowCall(String name)",
    "returnType" : "void",
    "comment" : "\n     * For code to note that it's slow. This is a no-op unless the current thread's {@link\n     * android.os.StrictMode.ThreadPolicy} has {@link\n     * android.os.StrictMode.ThreadPolicy.Builder#detectCustomSlowCalls} enabled.\n     *\n     * @param name a short string for the exception stack trace that's built if when this fires.\n     ",
    "links" : [ ]
  }, {
    "name" : "public static void noteResourceMismatch(Object tag)",
    "returnType" : "void",
    "comment" : "\n     * For code to note that a resource was obtained using a type other than its defined type. This\n     * is a no-op unless the current thread's {@link android.os.StrictMode.ThreadPolicy} has {@link\n     * android.os.StrictMode.ThreadPolicy.Builder#detectResourceMismatches()} enabled.\n     *\n     * @param tag an object for the exception stack trace that's built if when this fires.\n     * @hide\n     ",
    "links" : [ "android.os.StrictMode.ThreadPolicy" ]
  }, {
    "name" : "public static void noteUnbufferedIO()",
    "returnType" : "void",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "public static void noteDiskRead()",
    "returnType" : "void",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "public static void noteDiskWrite()",
    "returnType" : "void",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "public static Object trackActivity(Object instance)",
    "returnType" : "Object",
    "comment" : "\n     * Returns an object that is used to track instances of activites. The activity should store a\n     * reference to the tracker object in one of its fields.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public static void incrementExpectedActivityCount(Class klass)",
    "returnType" : "void",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "public static void decrementExpectedActivityCount(Class klass)",
    "returnType" : "void",
    "comment" : " @hide ",
    "links" : [ ]
  } ],
  "variableNames" : [ "TAG", "LOG_V", "DISABLE_PROPERTY", "VISUAL_PROPERTY", "CLEARTEXT_PROPERTY", "DISABLE", "MIN_VM_INTERVAL_MS", "MIN_LOG_INTERVAL_MS", "MIN_DIALOG_INTERVAL_MS", "MIN_DROPBOX_INTERVAL_MS", "MAX_SPAN_TAGS", "MAX_OFFENSES_PER_LOOP", "DETECT_THREAD_DISK_WRITE", "DETECT_THREAD_DISK_READ", "DETECT_THREAD_NETWORK", "DETECT_THREAD_CUSTOM", "DETECT_THREAD_RESOURCE_MISMATCH", "DETECT_THREAD_UNBUFFERED_IO", "DETECT_THREAD_EXPLICIT_GC", "DETECT_THREAD_ALL", "DETECT_VM_CURSOR_LEAKS", "DETECT_VM_CLOSABLE_LEAKS", "DETECT_VM_ACTIVITY_LEAKS", "DETECT_VM_INSTANCE_LEAKS", "DETECT_VM_REGISTRATION_LEAKS", "DETECT_VM_FILE_URI_EXPOSURE", "DETECT_VM_CLEARTEXT_NETWORK", "DETECT_VM_CONTENT_URI_WITHOUT_PERMISSION", "DETECT_VM_UNTAGGED_SOCKET", "DETECT_VM_NON_SDK_API_USAGE", "DETECT_VM_IMPLICIT_DIRECT_BOOT", "DETECT_VM_CREDENTIAL_PROTECTED_WHILE_LOCKED", "DETECT_VM_INCORRECT_CONTEXT_USE", "DETECT_VM_ALL", "PENALTY_GATHER", "PENALTY_LOG", "PENALTY_DIALOG", "PENALTY_DEATH", "PENALTY_FLASH", "PENALTY_DROPBOX", "PENALTY_DEATH_ON_NETWORK", "PENALTY_DEATH_ON_CLEARTEXT_NETWORK", "PENALTY_DEATH_ON_FILE_URI_EXPOSURE", "PENALTY_ALL", "NETWORK_POLICY_ACCEPT", "NETWORK_POLICY_LOG", "NETWORK_POLICY_REJECT", "EMPTY_CLASS_LIMIT_MAP", "sVmPolicy", "LOGCAT_LOGGER", "sLogger", "sThreadViolationListener", "sThreadViolationExecutor", "sDropboxCallsInFlight", "sNonSdkApiUsageConsumer", "gatheredViolations", "violationsBeingTimed", "THREAD_HANDLER", "THREAD_ANDROID_POLICY", "VM_ANDROID_POLICY", "sLastInstanceCountCheckMillis", "sIsIdlerRegistered", "sProcessIdleHandler", "sUserKeyUnlocked", "sLastVmViolationTime", "NO_OP_SPAN", "sThisThreadSpanState", "sWindowManager", "sExpectedActivityInstanceCount" ],
  "methodNames" : [ "public static void setViolationLogger(ViolationLogger listener)", "public static void setThreadPolicy(final ThreadPolicy policy)", "public static void setThreadPolicyMask(@ThreadPolicyMask int threadPolicyMask)", "private static void setBlockGuardPolicy(@ThreadPolicyMask int threadPolicyMask)", "private static void setBlockGuardVmPolicy(@VmPolicyMask int vmPolicyMask)", "private static void setCloseGuardEnabled(boolean enabled)", "public static int getThreadPolicyMask()", "public static ThreadPolicy getThreadPolicy()", "public static ThreadPolicy allowThreadDiskWrites()", "public static int allowThreadDiskWritesMask()", "public static ThreadPolicy allowThreadDiskReads()", "public static int allowThreadDiskReadsMask()", "public static ThreadPolicy allowThreadViolations()", "public static VmPolicy allowVmViolations()", "public static boolean isBundledSystemApp(ApplicationInfo ai)", "public static void initThreadDefaults(ApplicationInfo ai)", "public static void initVmDefaults(ApplicationInfo ai)", "public static void enableDeathOnFileUriExposure()", "public static void disableDeathOnFileUriExposure()", "private static boolean tooManyViolationsThisLoop()", "private static void dropboxViolationAsync(final int penaltyMask, final ViolationInfo info)", "private static void handleApplicationStrictModeViolation(int penaltyMask, ViolationInfo info)", " static boolean hasGatheredViolations()", " static void clearGatheredViolations()", "public static void conditionallyCheckInstanceCounts()", "public static void setVmPolicy(final VmPolicy policy)", "public static VmPolicy getVmPolicy()", "public static void enableDefaults()", "public static boolean vmSqliteObjectLeaksEnabled()", "public static boolean vmClosableObjectLeaksEnabled()", "public static boolean vmRegistrationLeaksEnabled()", "public static boolean vmFileUriExposureEnabled()", "public static boolean vmCleartextNetworkEnabled()", "public static boolean vmContentUriWithoutPermissionEnabled()", "public static boolean vmUntaggedSocketEnabled()", "public static boolean vmImplicitDirectBootEnabled()", "public static boolean vmCredentialProtectedWhileLockedEnabled()", "public static boolean vmIncorrectContextUseEnabled()", "public static void onSqliteObjectLeaked(String message, Throwable originStack)", "public static void onWebViewMethodCalledOnWrongThread(Throwable originStack)", "public static void onIntentReceiverLeaked(Throwable originStack)", "public static void onServiceConnectionLeaked(Throwable originStack)", "public static void onFileUriExposed(Uri uri, String location)", "public static void onContentUriWithoutPermission(Uri uri, String location)", "public static void onCleartextNetworkDetected(byte[] firstPacket)", "public static void onUntaggedSocket()", "public static void onImplicitDirectBoot()", "public static void onIncorrectContextUsed(String message, Throwable originStack)", "private static boolean isUserKeyUnlocked(int userId)", "private static void onCredentialProtectedPathAccess(String path, int userId)", "private static void clampViolationTimeMap(@NonNull final Map<Integer, Long> violationTime, final long retainSince)", "public static void onVmPolicyViolation(Violation originStack)", "public static void onVmPolicyViolation(Violation violation, boolean forceDeath)", " static void writeGatheredViolationsToParcel(Parcel p)", " static void readAndHandleBinderCallViolations(Parcel p)", "private static void onBinderStrictModePolicyChange(@ThreadPolicyMask int newPolicy)", "public static Span enterCriticalSpan(String name)", "public static void noteSlowCall(String name)", "public static void noteResourceMismatch(Object tag)", "public static void noteUnbufferedIO()", "public static void noteDiskRead()", "public static void noteDiskWrite()", "public static Object trackActivity(Object instance)", "public static void incrementExpectedActivityCount(Class klass)", "public static void decrementExpectedActivityCount(Class klass)" ]
}