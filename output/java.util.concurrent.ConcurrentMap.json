{
  "filePath" : "/home/maryam/clearblue/files/android-source-35/java/util/concurrent/ConcurrentMap.java",
  "packageName" : "java.util.concurrent",
  "className" : "ConcurrentMap",
  "comment" : "\n * A {@link Map} providing thread safety and atomicity guarantees.\n *\n * <p>To maintain the specified guarantees, default implementations of\n * methods including {@link #putIfAbsent} inherited from {@link Map}\n * must be overridden by implementations of this interface. Similarly,\n * implementations of the collections returned by methods {@link\n * #keySet}, {@link #values}, and {@link #entrySet} must override\n * methods such as {@code removeIf} when necessary to\n * preserve atomicity guarantees.\n *\n * <p>Memory consistency effects: As with other concurrent\n * collections, actions in a thread prior to placing an object into a\n * {@code ConcurrentMap} as a key or value\n * <a href=\"package-summary.html#MemoryVisibility\"><i>happen-before</i></a>\n * actions subsequent to the access or removal of that object from\n * the {@code ConcurrentMap} in another thread.\n *\n * <p>This interface is a member of the\n * <a href=\"{@docRoot}/java.base/java/util/package-summary.html#CollectionsFramework\">\n * Java Collections Framework</a>.\n *\n * @since 1.5\n * @author Doug Lea\n * @param <K> the type of keys maintained by this map\n * @param <V> the type of mapped values\n ",
  "links" : [ "#putIfAbsent", "#entrySet", "java.util.Map", "#values", "#keySet" ],
  "variables" : [ ],
  "methods" : [ {
    "name" : " V getOrDefault(Object key, V defaultValue)",
    "returnType" : "V",
    "comment" : "\n     * {@inheritDoc}\n     *\n     * @implNote This implementation assumes that the ConcurrentMap cannot\n     * contain null values and {@code get()} returning null unambiguously means\n     * the key is absent. Implementations which support null values\n     * <strong>must</strong> override this default implementation.\n     *\n     * @throws ClassCastException {@inheritDoc}\n     * @throws NullPointerException {@inheritDoc}\n     * @since 1.8\n     ",
    "links" : [ ]
  }, {
    "name" : " void forEach(BiConsumer<? super K, ? super V> action)",
    "returnType" : "void",
    "comment" : "\n     * {@inheritDoc}\n     *\n     * @implSpec The default implementation is equivalent to, for this\n     * {@code map}:\n     * <pre> {@code\n     * for (Map.Entry<K,V> entry : map.entrySet()) {\n     *   action.accept(entry.getKey(), entry.getValue());\n     * }}</pre>\n     *\n     * @implNote The default implementation assumes that\n     * {@code IllegalStateException} thrown by {@code getKey()} or\n     * {@code getValue()} indicates that the entry has been removed and cannot\n     * be processed. Operation continues for subsequent entries.\n     *\n     * @throws NullPointerException {@inheritDoc}\n     * @since 1.8\n     ",
    "links" : [ ]
  }, {
    "name" : " V putIfAbsent(K key, V value)",
    "returnType" : "V",
    "comment" : "\n     * If the specified key is not already associated\n     * with a value, associates it with the given value.\n     * This is equivalent to, for this {@code map}:\n     * <pre> {@code\n     * if (!map.containsKey(key))\n     *   return map.put(key, value);\n     * else\n     *   return map.get(key);}</pre>\n     *\n     * except that the action is performed atomically.\n     *\n     * @implNote This implementation intentionally re-abstracts the\n     * inappropriate default provided in {@code Map}.\n     *\n     * @param key key with which the specified value is to be associated\n     * @param value value to be associated with the specified key\n     * @return the previous value associated with the specified key, or\n     *         {@code null} if there was no mapping for the key.\n     *         (A {@code null} return can also indicate that the map\n     *         previously associated {@code null} with the key,\n     *         if the implementation supports null values.)\n     * @throws UnsupportedOperationException if the {@code put} operation\n     *         is not supported by this map\n     * @throws ClassCastException if the class of the specified key or value\n     *         prevents it from being stored in this map\n     * @throws NullPointerException if the specified key or value is null,\n     *         and this map does not permit null keys or values\n     * @throws IllegalArgumentException if some property of the specified key\n     *         or value prevents it from being stored in this map\n     ",
    "links" : [ ]
  }, {
    "name" : " boolean remove(Object key, Object value)",
    "returnType" : "boolean",
    "comment" : "\n     * Removes the entry for a key only if currently mapped to a given value.\n     * This is equivalent to, for this {@code map}:\n     * <pre> {@code\n     * if (map.containsKey(key)\n     *     && Objects.equals(map.get(key), value)) {\n     *   map.remove(key);\n     *   return true;\n     * } else {\n     *   return false;\n     * }}</pre>\n     *\n     * except that the action is performed atomically.\n     *\n     * @implNote This implementation intentionally re-abstracts the\n     * inappropriate default provided in {@code Map}.\n     *\n     * @param key key with which the specified value is associated\n     * @param value value expected to be associated with the specified key\n     * @return {@code true} if the value was removed\n     * @throws UnsupportedOperationException if the {@code remove} operation\n     *         is not supported by this map\n     * @throws ClassCastException if the key or value is of an inappropriate\n     *         type for this map\n     * (<a href=\"{@docRoot}/java.base/java/util/Collection.html#optional-restrictions\">optional</a>)\n     * @throws NullPointerException if the specified key or value is null,\n     *         and this map does not permit null keys or values\n     * (<a href=\"{@docRoot}/java.base/java/util/Collection.html#optional-restrictions\">optional</a>)\n     ",
    "links" : [ ]
  }, {
    "name" : " boolean replace(K key, V oldValue, V newValue)",
    "returnType" : "boolean",
    "comment" : "\n     * Replaces the entry for a key only if currently mapped to a given value.\n     * This is equivalent to, for this {@code map}:\n     * <pre> {@code\n     * if (map.containsKey(key)\n     *     && Objects.equals(map.get(key), oldValue)) {\n     *   map.put(key, newValue);\n     *   return true;\n     * } else {\n     *   return false;\n     * }}</pre>\n     *\n     * except that the action is performed atomically.\n     *\n     * @implNote This implementation intentionally re-abstracts the\n     * inappropriate default provided in {@code Map}.\n     *\n     * @param key key with which the specified value is associated\n     * @param oldValue value expected to be associated with the specified key\n     * @param newValue value to be associated with the specified key\n     * @return {@code true} if the value was replaced\n     * @throws UnsupportedOperationException if the {@code put} operation\n     *         is not supported by this map\n     * @throws ClassCastException if the class of a specified key or value\n     *         prevents it from being stored in this map\n     * @throws NullPointerException if a specified key or value is null,\n     *         and this map does not permit null keys or values\n     * @throws IllegalArgumentException if some property of a specified key\n     *         or value prevents it from being stored in this map\n     ",
    "links" : [ ]
  }, {
    "name" : " V replace(K key, V value)",
    "returnType" : "V",
    "comment" : "\n     * Replaces the entry for a key only if currently mapped to some value.\n     * This is equivalent to, for this {@code map}:\n     * <pre> {@code\n     * if (map.containsKey(key))\n     *   return map.put(key, value);\n     * else\n     *   return null;}</pre>\n     *\n     * except that the action is performed atomically.\n     *\n     * @implNote This implementation intentionally re-abstracts the\n     * inappropriate default provided in {@code Map}.\n     *\n     * @param key key with which the specified value is associated\n     * @param value value to be associated with the specified key\n     * @return the previous value associated with the specified key, or\n     *         {@code null} if there was no mapping for the key.\n     *         (A {@code null} return can also indicate that the map\n     *         previously associated {@code null} with the key,\n     *         if the implementation supports null values.)\n     * @throws UnsupportedOperationException if the {@code put} operation\n     *         is not supported by this map\n     * @throws ClassCastException if the class of the specified key or value\n     *         prevents it from being stored in this map\n     * @throws NullPointerException if the specified key or value is null,\n     *         and this map does not permit null keys or values\n     * @throws IllegalArgumentException if some property of the specified key\n     *         or value prevents it from being stored in this map\n     ",
    "links" : [ ]
  }, {
    "name" : " void replaceAll(BiFunction<? super K, ? super V, ? extends V> function)",
    "returnType" : "void",
    "comment" : "\n     * {@inheritDoc}\n     *\n     * @implSpec\n     * <p>The default implementation is equivalent to, for this {@code map}:\n     * <pre> {@code\n     * for (Map.Entry<K,V> entry : map.entrySet()) {\n     *   K k;\n     *   V v;\n     *   do {\n     *     k = entry.getKey();\n     *     v = entry.getValue();\n     *   } while (!map.replace(k, v, function.apply(k, v)));\n     * }}</pre>\n     *\n     * The default implementation may retry these steps when multiple\n     * threads attempt updates including potentially calling the function\n     * repeatedly for a given key.\n     *\n     * <p>This implementation assumes that the ConcurrentMap cannot contain null\n     * values and {@code get()} returning null unambiguously means the key is\n     * absent. Implementations which support null values <strong>must</strong>\n     * override this default implementation.\n     *\n     * @throws UnsupportedOperationException {@inheritDoc}\n     * @throws NullPointerException {@inheritDoc}\n     * @throws ClassCastException {@inheritDoc}\n     * @throws IllegalArgumentException {@inheritDoc}\n     * @since 1.8\n     ",
    "links" : [ ]
  }, {
    "name" : " V computeIfAbsent(K key, Function<? super K, ? extends V> mappingFunction)",
    "returnType" : "V",
    "comment" : "\n     * {@inheritDoc}\n     *\n     * @implSpec\n     * The default implementation is equivalent to the following steps for this\n     * {@code map}:\n     *\n     * <pre> {@code\n     * V oldValue, newValue;\n     * return ((oldValue = map.get(key)) == null\n     *         && (newValue = mappingFunction.apply(key)) != null\n     *         && (oldValue = map.putIfAbsent(key, newValue)) == null)\n     *   ? newValue\n     *   : oldValue;}</pre>\n     *\n     * <p>This implementation assumes that the ConcurrentMap cannot contain null\n     * values and {@code get()} returning null unambiguously means the key is\n     * absent. Implementations which support null values <strong>must</strong>\n     * override this default implementation.\n     *\n     * @throws UnsupportedOperationException {@inheritDoc}\n     * @throws ClassCastException {@inheritDoc}\n     * @throws NullPointerException {@inheritDoc}\n     * @throws IllegalArgumentException {@inheritDoc}\n     * @since 1.8\n     ",
    "links" : [ ]
  }, {
    "name" : " V computeIfPresent(K key, BiFunction<? super K, ? super V, ? extends V> remappingFunction)",
    "returnType" : "V",
    "comment" : "\n     * {@inheritDoc}\n     *\n     * @implSpec\n     * The default implementation is equivalent to performing the following\n     * steps for this {@code map}:\n     *\n     * <pre> {@code\n     * for (V oldValue; (oldValue = map.get(key)) != null; ) {\n     *   V newValue = remappingFunction.apply(key, oldValue);\n     *   if ((newValue == null)\n     *       ? map.remove(key, oldValue)\n     *       : map.replace(key, oldValue, newValue))\n     *     return newValue;\n     * }\n     * return null;}</pre>\n     * When multiple threads attempt updates, map operations and the\n     * remapping function may be called multiple times.\n     *\n     * <p>This implementation assumes that the ConcurrentMap cannot contain null\n     * values and {@code get()} returning null unambiguously means the key is\n     * absent. Implementations which support null values <strong>must</strong>\n     * override this default implementation.\n     *\n     * @throws UnsupportedOperationException {@inheritDoc}\n     * @throws ClassCastException {@inheritDoc}\n     * @throws NullPointerException {@inheritDoc}\n     * @throws IllegalArgumentException {@inheritDoc}\n     * @since 1.8\n     ",
    "links" : [ ]
  }, {
    "name" : " V compute(K key, BiFunction<? super K, ? super V, ? extends V> remappingFunction)",
    "returnType" : "V",
    "comment" : "\n     * {@inheritDoc}\n     *\n     * @implSpec\n     * The default implementation is equivalent to performing the following\n     * steps for this {@code map}:\n     *\n     * <pre> {@code\n     * for (;;) {\n     *   V oldValue = map.get(key);\n     *   V newValue = remappingFunction.apply(key, oldValue);\n     *   if (newValue != null) {\n     *     if ((oldValue != null)\n     *       ? map.replace(key, oldValue, newValue)\n     *       : map.putIfAbsent(key, newValue) == null)\n     *       return newValue;\n     *   } else if (oldValue == null || map.remove(key, oldValue)) {\n     *     return null;\n     *   }\n     * }}</pre>\n     * When multiple threads attempt updates, map operations and the\n     * remapping function may be called multiple times.\n     *\n     * <p>This implementation assumes that the ConcurrentMap cannot contain null\n     * values and {@code get()} returning null unambiguously means the key is\n     * absent. Implementations which support null values <strong>must</strong>\n     * override this default implementation.\n     *\n     * @throws UnsupportedOperationException {@inheritDoc}\n     * @throws ClassCastException {@inheritDoc}\n     * @throws NullPointerException {@inheritDoc}\n     * @throws IllegalArgumentException {@inheritDoc}\n     * @since 1.8\n     ",
    "links" : [ ]
  }, {
    "name" : " V merge(K key, V value, BiFunction<? super V, ? super V, ? extends V> remappingFunction)",
    "returnType" : "V",
    "comment" : "\n     * {@inheritDoc}\n     *\n     * @implSpec\n     * The default implementation is equivalent to performing the following\n     * steps for this {@code map}:\n     *\n     * <pre> {@code\n     * for (;;) {\n     *   V oldValue = map.get(key);\n     *   if (oldValue != null) {\n     *     V newValue = remappingFunction.apply(oldValue, value);\n     *     if (newValue != null) {\n     *       if (map.replace(key, oldValue, newValue))\n     *         return newValue;\n     *     } else if (map.remove(key, oldValue)) {\n     *       return null;\n     *     }\n     *   } else if (map.putIfAbsent(key, value) == null) {\n     *     return value;\n     *   }\n     * }}</pre>\n     * When multiple threads attempt updates, map operations and the\n     * remapping function may be called multiple times.\n     *\n     * <p>This implementation assumes that the ConcurrentMap cannot contain null\n     * values and {@code get()} returning null unambiguously means the key is\n     * absent. Implementations which support null values <strong>must</strong>\n     * override this default implementation.\n     *\n     * @throws UnsupportedOperationException {@inheritDoc}\n     * @throws ClassCastException {@inheritDoc}\n     * @throws NullPointerException {@inheritDoc}\n     * @throws IllegalArgumentException {@inheritDoc}\n     * @since 1.8\n     ",
    "links" : [ ]
  } ],
  "methodNames" : [ " V getOrDefault(Object key, V defaultValue)", " void forEach(BiConsumer<? super K, ? super V> action)", " V putIfAbsent(K key, V value)", " boolean remove(Object key, Object value)", " boolean replace(K key, V oldValue, V newValue)", " V replace(K key, V value)", " void replaceAll(BiFunction<? super K, ? super V, ? extends V> function)", " V computeIfAbsent(K key, Function<? super K, ? extends V> mappingFunction)", " V computeIfPresent(K key, BiFunction<? super K, ? super V, ? extends V> remappingFunction)", " V compute(K key, BiFunction<? super K, ? super V, ? extends V> remappingFunction)", " V merge(K key, V value, BiFunction<? super V, ? super V, ? extends V> remappingFunction)" ],
  "variableNames" : [ ]
}