{
  "filePath" : "/home/maryam/clearblue/files/android-source-35/java/io/ObjectOutputStream.java",
  "packageName" : "java.io",
  "className" : "ObjectOutputStream",
  "comment" : "\n * An ObjectOutputStream writes primitive data types and graphs of Java objects\n * to an OutputStream.  The objects can be read (reconstituted) using an\n * ObjectInputStream.  Persistent storage of objects can be accomplished by\n * using a file for the stream.  If the stream is a network socket stream, the\n * objects can be reconstituted on another host or in another process.\n *\n * <p>Only objects that support the java.io.Serializable interface can be\n * written to streams.  The class of each serializable object is encoded\n * including the class name and signature of the class, the values of the\n * object's fields and arrays, and the closure of any other objects referenced\n * from the initial objects.\n *\n * <p>The method writeObject is used to write an object to the stream.  Any\n * object, including Strings and arrays, is written with writeObject. Multiple\n * objects or primitives can be written to the stream.  The objects must be\n * read back from the corresponding ObjectInputstream with the same types and\n * in the same order as they were written.\n *\n * <p>Primitive data types can also be written to the stream using the\n * appropriate methods from DataOutput. Strings can also be written using the\n * writeUTF method.\n *\n * <p>The default serialization mechanism for an object writes the class of the\n * object, the class signature, and the values of all non-transient and\n * non-static fields.  References to other objects (except in transient or\n * static fields) cause those objects to be written also. Multiple references\n * to a single object are encoded using a reference sharing mechanism so that\n * graphs of objects can be restored to the same shape as when the original was\n * written.\n *\n * <p>For example to write an object that can be read by the example in\n * ObjectInputStream:\n * <br>\n * <pre>\n *      FileOutputStream fos = new FileOutputStream(\"t.tmp\");\n *      ObjectOutputStream oos = new ObjectOutputStream(fos);\n *\n *      oos.writeInt(12345);\n *      oos.writeObject(\"Today\");\n *      oos.writeObject(new Date());\n *\n *      oos.close();\n * </pre>\n *\n * <p>Classes that require special handling during the serialization and\n * deserialization process must implement special methods with these exact\n * signatures:\n * <br>\n * <pre>\n * private void readObject(java.io.ObjectInputStream stream)\n *     throws IOException, ClassNotFoundException;\n * private void writeObject(java.io.ObjectOutputStream stream)\n *     throws IOException\n * private void readObjectNoData()\n *     throws ObjectStreamException;\n * </pre>\n *\n * <p>The writeObject method is responsible for writing the state of the object\n * for its particular class so that the corresponding readObject method can\n * restore it.  The method does not need to concern itself with the state\n * belonging to the object's superclasses or subclasses.  State is saved by\n * writing the individual fields to the ObjectOutputStream using the\n * writeObject method or by using the methods for primitive data types\n * supported by DataOutput.\n *\n * <p>Serialization does not write out the fields of any object that does not\n * implement the java.io.Serializable interface.  Subclasses of Objects that\n * are not serializable can be serializable. In this case the non-serializable\n * class must have a no-arg constructor to allow its fields to be initialized.\n * In this case it is the responsibility of the subclass to save and restore\n * the state of the non-serializable class. It is frequently the case that the\n * fields of that class are accessible (public, package, or protected) or that\n * there are get and set methods that can be used to restore the state.\n *\n * <p>Serialization of an object can be prevented by implementing writeObject\n * and readObject methods that throw the NotSerializableException.  The\n * exception will be caught by the ObjectOutputStream and abort the\n * serialization process.\n *\n * <p>Implementing the Externalizable interface allows the object to assume\n * complete control over the contents and format of the object's serialized\n * form.  The methods of the Externalizable interface, writeExternal and\n * readExternal, are called to save and restore the objects state.  When\n * implemented by a class they can write and read their own state using all of\n * the methods of ObjectOutput and ObjectInput.  It is the responsibility of\n * the objects to handle any versioning that occurs.\n *\n * <p>Enum constants are serialized differently than ordinary serializable or\n * externalizable objects.  The serialized form of an enum constant consists\n * solely of its name; field values of the constant are not transmitted.  To\n * serialize an enum constant, ObjectOutputStream writes the string returned by\n * the constant's name method.  Like other serializable or externalizable\n * objects, enum constants can function as the targets of back references\n * appearing subsequently in the serialization stream.  The process by which\n * enum constants are serialized cannot be customized; any class-specific\n * writeObject and writeReplace methods defined by enum types are ignored\n * during serialization.  Similarly, any serialPersistentFields or\n * serialVersionUID field declarations are also ignored--all enum types have a\n * fixed serialVersionUID of 0L.\n *\n * <p>Primitive data, excluding serializable fields and externalizable data, is\n * written to the ObjectOutputStream in block-data records. A block data record\n * is composed of a header and data. The block data header consists of a marker\n * and the number of bytes to follow the header.  Consecutive primitive data\n * writes are merged into one block-data record.  The blocking factor used for\n * a block-data record will be 1024 bytes.  Each block-data record will be\n * filled up to 1024 bytes, or be written whenever there is a termination of\n * block-data mode.  Calls to the ObjectOutputStream methods writeObject,\n * defaultWriteObject and writeFields initially terminate any existing\n * block-data record.\n *\n * @author      Mike Warres\n * @author      Roger Riggs\n * @see java.io.DataOutput\n * @see java.io.ObjectInputStream\n * @see java.io.Serializable\n * @see java.io.Externalizable\n * @see <a href=\"../../../platform/serialization/spec/output.html\">Object Serialization Specification, Section 2, Object Output Classes</a>\n * @since       JDK1.1\n ",
  "links" : [ ],
  "variables" : [ {
    "name" : "bout",
    "type" : "BlockDataOutputStream",
    "comment" : " filter stream for handling block data conversion ",
    "links" : [ ]
  }, {
    "name" : "handles",
    "type" : "HandleTable",
    "comment" : " obj -> wire handle map ",
    "links" : [ ]
  }, {
    "name" : "subs",
    "type" : "ReplaceTable",
    "comment" : " obj -> replacement obj map ",
    "links" : [ ]
  }, {
    "name" : "protocol",
    "type" : "int",
    "comment" : " stream protocol version ",
    "links" : [ ]
  }, {
    "name" : "depth",
    "type" : "int",
    "comment" : " recursion depth ",
    "links" : [ ]
  }, {
    "name" : "primVals",
    "type" : "byte[]",
    "comment" : " buffer for writing primitive field values ",
    "links" : [ ]
  }, {
    "name" : "enableOverride",
    "type" : "boolean",
    "comment" : " if true, invoke writeObjectOverride() instead of writeObject() ",
    "links" : [ ]
  }, {
    "name" : "enableReplace",
    "type" : "boolean",
    "comment" : " if true, invoke replaceObject() ",
    "links" : [ ]
  }, {
    "name" : "curContext",
    "type" : "SerialCallbackContext",
    "comment" : "\n     * Context during upcalls to class-defined writeObject methods; holds\n     * object currently being serialized and descriptor for current class.\n     * Null when not during writeObject upcall.\n     ",
    "links" : [ ]
  }, {
    "name" : "curPut",
    "type" : "PutFieldImpl",
    "comment" : " current PutField object ",
    "links" : [ ]
  }, {
    "name" : "debugInfoStack",
    "type" : "DebugTraceInfoStack",
    "comment" : " custom storage for debug trace info ",
    "links" : [ ]
  }, {
    "name" : "extendedDebugInfo",
    "type" : "boolean",
    "comment" : "\n    private static final boolean extendedDebugInfo =\n        java.security.AccessController.doPrivileged(\n            new sun.security.action.GetBooleanAction(\n                \"sun.io.serialization.extendedDebugInfo\")).booleanValue();\n    ",
    "links" : [ ]
  } ],
  "methods" : [ {
    "name" : "public void useProtocolVersion(int version) throws IOException",
    "returnType" : "void",
    "comment" : "\n     * Specify stream protocol version to use when writing the stream.\n     *\n     * <p>This routine provides a hook to enable the current version of\n     * Serialization to write in a format that is backwards compatible to a\n     * previous version of the stream format.\n     *\n     * <p>Every effort will be made to avoid introducing additional\n     * backwards incompatibilities; however, sometimes there is no\n     * other alternative.\n     *\n     * @param   version use ProtocolVersion from java.io.ObjectStreamConstants.\n     * @throws  IllegalStateException if called after any objects\n     *          have been serialized.\n     * @throws  IllegalArgumentException if invalid version is passed in.\n     * @throws  IOException if I/O errors occur\n     * @see java.io.ObjectStreamConstants#PROTOCOL_VERSION_1\n     * @see java.io.ObjectStreamConstants#PROTOCOL_VERSION_2\n     * @since   1.2\n     ",
    "links" : [ ]
  }, {
    "name" : "public final void writeObject(Object obj) throws IOException",
    "returnType" : "void",
    "comment" : "\n     * Write the specified object to the ObjectOutputStream.  The class of the\n     * object, the signature of the class, and the values of the non-transient\n     * and non-static fields of the class and all of its supertypes are\n     * written.  Default serialization for a class can be overridden using the\n     * writeObject and the readObject methods.  Objects referenced by this\n     * object are written transitively so that a complete equivalent graph of\n     * objects can be reconstructed by an ObjectInputStream.\n     *\n     * <p>Exceptions are thrown for problems with the OutputStream and for\n     * classes that should not be serialized.  All exceptions are fatal to the\n     * OutputStream, which is left in an indeterminate state, and it is up to\n     * the caller to ignore or recover the stream state.\n     *\n     * @throws  InvalidClassException Something is wrong with a class used by\n     *          serialization.\n     * @throws  NotSerializableException Some object to be serialized does not\n     *          implement the java.io.Serializable interface.\n     * @throws  IOException Any exception thrown by the underlying\n     *          OutputStream.\n     ",
    "links" : [ ]
  }, {
    "name" : "protected void writeObjectOverride(Object obj) throws IOException",
    "returnType" : "void",
    "comment" : "\n     * Method used by subclasses to override the default writeObject method.\n     * This method is called by trusted subclasses of ObjectInputStream that\n     * constructed ObjectInputStream using the protected no-arg constructor.\n     * The subclass is expected to provide an override method with the modifier\n     * \"final\".\n     *\n     * @param   obj object to be written to the underlying stream\n     * @throws  IOException if there are I/O errors while writing to the\n     *          underlying stream\n     * @see #ObjectOutputStream()\n     * @see #writeObject(Object)\n     * @since 1.2\n     ",
    "links" : [ ]
  }, {
    "name" : "public void writeUnshared(Object obj) throws IOException",
    "returnType" : "void",
    "comment" : "\n     * Writes an \"unshared\" object to the ObjectOutputStream.  This method is\n     * identical to writeObject, except that it always writes the given object\n     * as a new, unique object in the stream (as opposed to a back-reference\n     * pointing to a previously serialized instance).  Specifically:\n     * <ul>\n     *   <li>An object written via writeUnshared is always serialized in the\n     *       same manner as a newly appearing object (an object that has not\n     *       been written to the stream yet), regardless of whether or not the\n     *       object has been written previously.\n     *\n     *   <li>If writeObject is used to write an object that has been previously\n     *       written with writeUnshared, the previous writeUnshared operation\n     *       is treated as if it were a write of a separate object.  In other\n     *       words, ObjectOutputStream will never generate back-references to\n     *       object data written by calls to writeUnshared.\n     * </ul>\n     * While writing an object via writeUnshared does not in itself guarantee a\n     * unique reference to the object when it is deserialized, it allows a\n     * single object to be defined multiple times in a stream, so that multiple\n     * calls to readUnshared by the receiver will not conflict.  Note that the\n     * rules described above only apply to the base-level object written with\n     * writeUnshared, and not to any transitively referenced sub-objects in the\n     * object graph to be serialized.\n     *\n     * <p>ObjectOutputStream subclasses which override this method can only be\n     * constructed in security contexts possessing the\n     * \"enableSubclassImplementation\" SerializablePermission; any attempt to\n     * instantiate such a subclass without this permission will cause a\n     * SecurityException to be thrown.\n     *\n     * @param   obj object to write to stream\n     * @throws  NotSerializableException if an object in the graph to be\n     *          serialized does not implement the Serializable interface\n     * @throws  InvalidClassException if a problem exists with the class of an\n     *          object to be serialized\n     * @throws  IOException if an I/O error occurs during serialization\n     * @since 1.4\n     ",
    "links" : [ ]
  }, {
    "name" : "public void defaultWriteObject() throws IOException",
    "returnType" : "void",
    "comment" : "\n     * Write the non-static and non-transient fields of the current class to\n     * this stream.  This may only be called from the writeObject method of the\n     * class being serialized. It will throw the NotActiveException if it is\n     * called otherwise.\n     *\n     * @throws  IOException if I/O errors occur while writing to the underlying\n     *          <code>OutputStream</code>\n     ",
    "links" : [ ]
  }, {
    "name" : "public ObjectOutputStream.PutField putFields() throws IOException",
    "returnType" : "ObjectOutputStream.PutField",
    "comment" : "\n     * Retrieve the object used to buffer persistent fields to be written to\n     * the stream.  The fields will be written to the stream when writeFields\n     * method is called.\n     *\n     * @return  an instance of the class Putfield that holds the serializable\n     *          fields\n     * @throws  IOException if I/O errors occur\n     * @since 1.2\n     ",
    "links" : [ ]
  }, {
    "name" : "public void writeFields() throws IOException",
    "returnType" : "void",
    "comment" : "\n     * Write the buffered fields to the stream.\n     *\n     * @throws  IOException if I/O errors occur while writing to the underlying\n     *          stream\n     * @throws  NotActiveException Called when a classes writeObject method was\n     *          not called to write the state of the object.\n     * @since 1.2\n     ",
    "links" : [ ]
  }, {
    "name" : "public void reset() throws IOException",
    "returnType" : "void",
    "comment" : "\n     * Reset will disregard the state of any objects already written to the\n     * stream.  The state is reset to be the same as a new ObjectOutputStream.\n     * The current point in the stream is marked as reset so the corresponding\n     * ObjectInputStream will be reset at the same point.  Objects previously\n     * written to the stream will not be referred to as already being in the\n     * stream.  They will be written to the stream again.\n     *\n     * @throws  IOException if reset() is invoked while serializing an object.\n     ",
    "links" : [ ]
  }, {
    "name" : "protected void annotateClass(Class<?> cl) throws IOException",
    "returnType" : "void",
    "comment" : "\n     * Subclasses may implement this method to allow class data to be stored in\n     * the stream. By default this method does nothing.  The corresponding\n     * method in ObjectInputStream is resolveClass.  This method is called\n     * exactly once for each unique class in the stream.  The class name and\n     * signature will have already been written to the stream.  This method may\n     * make free use of the ObjectOutputStream to save any representation of\n     * the class it deems suitable (for example, the bytes of the class file).\n     * The resolveClass method in the corresponding subclass of\n     * ObjectInputStream must read and use any data or objects written by\n     * annotateClass.\n     *\n     * @param   cl the class to annotate custom data for\n     * @throws  IOException Any exception thrown by the underlying\n     *          OutputStream.\n     ",
    "links" : [ ]
  }, {
    "name" : "protected void annotateProxyClass(Class<?> cl) throws IOException",
    "returnType" : "void",
    "comment" : "\n     * Subclasses may implement this method to store custom data in the stream\n     * along with descriptors for dynamic proxy classes.\n     *\n     * <p>This method is called exactly once for each unique proxy class\n     * descriptor in the stream.  The default implementation of this method in\n     * <code>ObjectOutputStream</code> does nothing.\n     *\n     * <p>The corresponding method in <code>ObjectInputStream</code> is\n     * <code>resolveProxyClass</code>.  For a given subclass of\n     * <code>ObjectOutputStream</code> that overrides this method, the\n     * <code>resolveProxyClass</code> method in the corresponding subclass of\n     * <code>ObjectInputStream</code> must read any data or objects written by\n     * <code>annotateProxyClass</code>.\n     *\n     * @param   cl the proxy class to annotate custom data for\n     * @throws  IOException any exception thrown by the underlying\n     *          <code>OutputStream</code>\n     * @see ObjectInputStream#resolveProxyClass(String[])\n     * @since   1.3\n     ",
    "links" : [ ]
  }, {
    "name" : "protected Object replaceObject(Object obj) throws IOException",
    "returnType" : "Object",
    "comment" : "\n     * This method will allow trusted subclasses of ObjectOutputStream to\n     * substitute one object for another during serialization. Replacing\n     * objects is disabled until enableReplaceObject is called. The\n     * enableReplaceObject method checks that the stream requesting to do\n     * replacement can be trusted.  The first occurrence of each object written\n     * into the serialization stream is passed to replaceObject.  Subsequent\n     * references to the object are replaced by the object returned by the\n     * original call to replaceObject.  To ensure that the private state of\n     * objects is not unintentionally exposed, only trusted streams may use\n     * replaceObject.\n     *\n     * <p>The ObjectOutputStream.writeObject method takes a parameter of type\n     * Object (as opposed to type Serializable) to allow for cases where\n     * non-serializable objects are replaced by serializable ones.\n     *\n     * <p>When a subclass is replacing objects it must insure that either a\n     * complementary substitution must be made during deserialization or that\n     * the substituted object is compatible with every field where the\n     * reference will be stored.  Objects whose type is not a subclass of the\n     * type of the field or array element abort the serialization by raising an\n     * exception and the object is not be stored.\n     *\n     * <p>This method is called only once when each object is first\n     * encountered.  All subsequent references to the object will be redirected\n     * to the new object. This method should return the object to be\n     * substituted or the original object.\n     *\n     * <p>Null can be returned as the object to be substituted, but may cause\n     * NullReferenceException in classes that contain references to the\n     * original object since they may be expecting an object instead of\n     * null.\n     *\n     * @param   obj the object to be replaced\n     * @return  the alternate object that replaced the specified one\n     * @throws  IOException Any exception thrown by the underlying\n     *          OutputStream.\n     ",
    "links" : [ ]
  }, {
    "name" : "protected boolean enableReplaceObject(boolean enable) throws SecurityException",
    "returnType" : "boolean",
    "comment" : "\n     * Enable the stream to do replacement of objects in the stream.  When\n     * enabled, the replaceObject method is called for every object being\n     * serialized.\n     *\n     * <p>If <code>enable</code> is true, and there is a security manager\n     * installed, this method first calls the security manager's\n     * <code>checkPermission</code> method with a\n     * <code>SerializablePermission(\"enableSubstitution\")</code> permission to\n     * ensure it's ok to enable the stream to do replacement of objects in the\n     * stream.\n     *\n     * @param   enable boolean parameter to enable replacement of objects\n     * @return  the previous setting before this method was invoked\n     * @throws  SecurityException if a security manager exists and its\n     *          <code>checkPermission</code> method denies enabling the stream\n     *          to do replacement of objects in the stream.\n     * @see SecurityManager#checkPermission\n     * @see java.io.SerializablePermission\n     ",
    "links" : [ ]
  }, {
    "name" : "protected void writeStreamHeader() throws IOException",
    "returnType" : "void",
    "comment" : "\n     * The writeStreamHeader method is provided so subclasses can append or\n     * prepend their own header to the stream.  It writes the magic number and\n     * version to the stream.\n     *\n     * @throws  IOException if I/O errors occur while writing to the underlying\n     *          stream\n     ",
    "links" : [ ]
  }, {
    "name" : "protected void writeClassDescriptor(ObjectStreamClass desc) throws IOException",
    "returnType" : "void",
    "comment" : "\n     * Write the specified class descriptor to the ObjectOutputStream.  Class\n     * descriptors are used to identify the classes of objects written to the\n     * stream.  Subclasses of ObjectOutputStream may override this method to\n     * customize the way in which class descriptors are written to the\n     * serialization stream.  The corresponding method in ObjectInputStream,\n     * <code>readClassDescriptor</code>, should then be overridden to\n     * reconstitute the class descriptor from its custom stream representation.\n     * By default, this method writes class descriptors according to the format\n     * defined in the Object Serialization specification.\n     *\n     * <p>Note that this method will only be called if the ObjectOutputStream\n     * is not using the old serialization stream format (set by calling\n     * ObjectOutputStream's <code>useProtocolVersion</code> method).  If this\n     * serialization stream is using the old format\n     * (<code>PROTOCOL_VERSION_1</code>), the class descriptor will be written\n     * internally in a manner that cannot be overridden or customized.\n     *\n     * @param   desc class descriptor to write to the stream\n     * @throws  IOException If an I/O error has occurred.\n     * @see java.io.ObjectInputStream#readClassDescriptor()\n     * @see #useProtocolVersion(int)\n     * @see java.io.ObjectStreamConstants#PROTOCOL_VERSION_1\n     * @since 1.3\n     ",
    "links" : [ ]
  }, {
    "name" : "public void write(int val) throws IOException",
    "returnType" : "void",
    "comment" : "\n     * Writes a byte. This method will block until the byte is actually\n     * written.\n     *\n     * @param   val the byte to be written to the stream\n     * @throws  IOException If an I/O error has occurred.\n     ",
    "links" : [ ]
  }, {
    "name" : "public void write(byte[] buf) throws IOException",
    "returnType" : "void",
    "comment" : "\n     * Writes an array of bytes. This method will block until the bytes are\n     * actually written.\n     *\n     * @param   buf the data to be written\n     * @throws  IOException If an I/O error has occurred.\n     ",
    "links" : [ ]
  }, {
    "name" : "public void write(byte[] buf, int off, int len) throws IOException",
    "returnType" : "void",
    "comment" : "\n     * Writes a sub array of bytes.\n     *\n     * @param   buf the data to be written\n     * @param   off the start offset in the data\n     * @param   len the number of bytes that are written\n     * @throws  IOException If an I/O error has occurred.\n     ",
    "links" : [ ]
  }, {
    "name" : "public void flush() throws IOException",
    "returnType" : "void",
    "comment" : "\n     * Flushes the stream. This will write any buffered output bytes and flush\n     * through to the underlying stream.\n     *\n     * @throws  IOException If an I/O error has occurred.\n     ",
    "links" : [ ]
  }, {
    "name" : "protected void drain() throws IOException",
    "returnType" : "void",
    "comment" : "\n     * Drain any buffered data in ObjectOutputStream.  Similar to flush but\n     * does not propagate the flush to the underlying stream.\n     *\n     * @throws  IOException if I/O errors occur while writing to the underlying\n     *          stream\n     ",
    "links" : [ ]
  }, {
    "name" : "public void close() throws IOException",
    "returnType" : "void",
    "comment" : "\n     * Closes the stream. This method must be called to release any resources\n     * associated with the stream.\n     *\n     * @throws  IOException If an I/O error has occurred.\n     ",
    "links" : [ ]
  }, {
    "name" : "public void writeBoolean(boolean val) throws IOException",
    "returnType" : "void",
    "comment" : "\n     * Writes a boolean.\n     *\n     * @param   val the boolean to be written\n     * @throws  IOException if I/O errors occur while writing to the underlying\n     *          stream\n     ",
    "links" : [ ]
  }, {
    "name" : "public void writeByte(int val) throws IOException",
    "returnType" : "void",
    "comment" : "\n     * Writes an 8 bit byte.\n     *\n     * @param   val the byte value to be written\n     * @throws  IOException if I/O errors occur while writing to the underlying\n     *          stream\n     ",
    "links" : [ ]
  }, {
    "name" : "public void writeShort(int val) throws IOException",
    "returnType" : "void",
    "comment" : "\n     * Writes a 16 bit short.\n     *\n     * @param   val the short value to be written\n     * @throws  IOException if I/O errors occur while writing to the underlying\n     *          stream\n     ",
    "links" : [ ]
  }, {
    "name" : "public void writeChar(int val) throws IOException",
    "returnType" : "void",
    "comment" : "\n     * Writes a 16 bit char.\n     *\n     * @param   val the char value to be written\n     * @throws  IOException if I/O errors occur while writing to the underlying\n     *          stream\n     ",
    "links" : [ ]
  }, {
    "name" : "public void writeInt(int val) throws IOException",
    "returnType" : "void",
    "comment" : "\n     * Writes a 32 bit int.\n     *\n     * @param   val the integer value to be written\n     * @throws  IOException if I/O errors occur while writing to the underlying\n     *          stream\n     ",
    "links" : [ ]
  }, {
    "name" : "public void writeLong(long val) throws IOException",
    "returnType" : "void",
    "comment" : "\n     * Writes a 64 bit long.\n     *\n     * @param   val the long value to be written\n     * @throws  IOException if I/O errors occur while writing to the underlying\n     *          stream\n     ",
    "links" : [ ]
  }, {
    "name" : "public void writeFloat(float val) throws IOException",
    "returnType" : "void",
    "comment" : "\n     * Writes a 32 bit float.\n     *\n     * @param   val the float value to be written\n     * @throws  IOException if I/O errors occur while writing to the underlying\n     *          stream\n     ",
    "links" : [ ]
  }, {
    "name" : "public void writeDouble(double val) throws IOException",
    "returnType" : "void",
    "comment" : "\n     * Writes a 64 bit double.\n     *\n     * @param   val the double value to be written\n     * @throws  IOException if I/O errors occur while writing to the underlying\n     *          stream\n     ",
    "links" : [ ]
  }, {
    "name" : "public void writeBytes(String str) throws IOException",
    "returnType" : "void",
    "comment" : "\n     * Writes a String as a sequence of bytes.\n     *\n     * @param   str the String of bytes to be written\n     * @throws  IOException if I/O errors occur while writing to the underlying\n     *          stream\n     ",
    "links" : [ ]
  }, {
    "name" : "public void writeChars(String str) throws IOException",
    "returnType" : "void",
    "comment" : "\n     * Writes a String as a sequence of chars.\n     *\n     * @param   str the String of chars to be written\n     * @throws  IOException if I/O errors occur while writing to the underlying\n     *          stream\n     ",
    "links" : [ ]
  }, {
    "name" : "public void writeUTF(String str) throws IOException",
    "returnType" : "void",
    "comment" : "\n     * Primitive data write of this String in\n     * <a href=\"DataInput.html#modified-utf-8\">modified UTF-8</a>\n     * format.  Note that there is a\n     * significant difference between writing a String into the stream as\n     * primitive data or as an Object. A String instance written by writeObject\n     * is written into the stream as a String initially. Future writeObject()\n     * calls write references to the string into the stream.\n     *\n     * @param   str the String to be written\n     * @throws  IOException if I/O errors occur while writing to the underlying\n     *          stream\n     ",
    "links" : [ ]
  }, {
    "name" : " int getProtocolVersion()",
    "returnType" : "int",
    "comment" : "\n     * Returns protocol version in use.\n     ",
    "links" : [ ]
  }, {
    "name" : " void writeTypeString(String str) throws IOException",
    "returnType" : "void",
    "comment" : "\n     * Writes string without allowing it to be replaced in stream.  Used by\n     * ObjectStreamClass to write class descriptor type strings.\n     ",
    "links" : [ ]
  }, {
    "name" : "private void verifySubclass()",
    "returnType" : "void",
    "comment" : "\n     * Verifies that this (possibly subclass) instance can be constructed\n     * without violating security constraints: the subclass must not override\n     * security-sensitive non-final methods, or else the\n     * \"enableSubclassImplementation\" SerializablePermission is checked.\n     ",
    "links" : [ ]
  }, {
    "name" : "private static boolean auditSubclass(final Class<?> subcl)",
    "returnType" : "boolean",
    "comment" : "\n     * Performs reflective checks on given subclass to verify that it doesn't\n     * override security-sensitive non-final methods.  Returns true if subclass\n     * is \"safe\", false otherwise.\n     ",
    "links" : [ ]
  }, {
    "name" : "private void clear()",
    "returnType" : "void",
    "comment" : "\n     * Clears internal data structures.\n     ",
    "links" : [ ]
  }, {
    "name" : "private void writeObject0(Object obj, boolean unshared) throws IOException",
    "returnType" : "void",
    "comment" : "\n     * Underlying writeObject/writeUnshared implementation.\n     ",
    "links" : [ ]
  }, {
    "name" : "private void writeNull() throws IOException",
    "returnType" : "void",
    "comment" : "\n     * Writes null code to stream.\n     ",
    "links" : [ ]
  }, {
    "name" : "private void writeHandle(int handle) throws IOException",
    "returnType" : "void",
    "comment" : "\n     * Writes given object handle to stream.\n     ",
    "links" : [ ]
  }, {
    "name" : "private void writeClass(Class<?> cl, boolean unshared) throws IOException",
    "returnType" : "void",
    "comment" : "\n     * Writes representation of given class to stream.\n     ",
    "links" : [ ]
  }, {
    "name" : "private void writeClassDesc(ObjectStreamClass desc, boolean unshared) throws IOException",
    "returnType" : "void",
    "comment" : "\n     * Writes representation of given class descriptor to stream.\n     ",
    "links" : [ ]
  }, {
    "name" : "private boolean isCustomSubclass()",
    "returnType" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private void writeProxyDesc(ObjectStreamClass desc, boolean unshared) throws IOException",
    "returnType" : "void",
    "comment" : "\n     * Writes class descriptor representing a dynamic proxy class to stream.\n     ",
    "links" : [ ]
  }, {
    "name" : "private void writeNonProxyDesc(ObjectStreamClass desc, boolean unshared) throws IOException",
    "returnType" : "void",
    "comment" : "\n     * Writes class descriptor representing a standard (i.e., not a dynamic\n     * proxy) class to stream.\n     ",
    "links" : [ ]
  }, {
    "name" : "private void writeString(String str, boolean unshared) throws IOException",
    "returnType" : "void",
    "comment" : "\n     * Writes given string to stream, using standard or long UTF format\n     * depending on string length.\n     ",
    "links" : [ ]
  }, {
    "name" : "private void writeArray(Object array, ObjectStreamClass desc, boolean unshared) throws IOException",
    "returnType" : "void",
    "comment" : "\n     * Writes given array object to stream.\n     ",
    "links" : [ ]
  }, {
    "name" : "private void writeEnum(Enum<?> en, ObjectStreamClass desc, boolean unshared) throws IOException",
    "returnType" : "void",
    "comment" : "\n     * Writes given enum constant to stream.\n     ",
    "links" : [ ]
  }, {
    "name" : "private void writeOrdinaryObject(Object obj, ObjectStreamClass desc, boolean unshared) throws IOException",
    "returnType" : "void",
    "comment" : "\n     * Writes representation of a \"ordinary\" (i.e., not a String, Class,\n     * ObjectStreamClass, array, or enum constant) serializable object to the\n     * stream.\n     ",
    "links" : [ ]
  }, {
    "name" : "private void writeExternalData(Externalizable obj) throws IOException",
    "returnType" : "void",
    "comment" : "\n     * Writes externalizable data of given object by invoking its\n     * writeExternal() method.\n     ",
    "links" : [ ]
  }, {
    "name" : "private void writeRecordData(Object obj, ObjectStreamClass desc) throws IOException",
    "returnType" : "void",
    "comment" : " Writes the record component values for the given record object. ",
    "links" : [ ]
  }, {
    "name" : "private void writeSerialData(Object obj, ObjectStreamClass desc) throws IOException",
    "returnType" : "void",
    "comment" : "\n     * Writes instance data for each serializable class of given object, from\n     * superclass to subclass.\n     ",
    "links" : [ ]
  }, {
    "name" : "private void defaultWriteFields(Object obj, ObjectStreamClass desc) throws IOException",
    "returnType" : "void",
    "comment" : "\n     * Fetches and writes values of serializable fields of given object to\n     * stream.  The given class descriptor specifies which field values to\n     * write, and in which order they should be written.\n     ",
    "links" : [ ]
  }, {
    "name" : "private void writeFatalException(IOException ex) throws IOException",
    "returnType" : "void",
    "comment" : "\n     * Attempts to write to stream fatal IOException that has caused\n     * serialization to abort.\n     ",
    "links" : [ ]
  }, {
    "name" : "private static native void floatsToBytes(float[] src, int srcpos, byte[] dst, int dstpos, int nfloats)",
    "returnType" : "void",
    "comment" : " REMIND: remove once hotspot inlines Float.floatToIntBits",
    "links" : [ ]
  }, {
    "name" : "private static native void doublesToBytes(double[] src, int srcpos, byte[] dst, int dstpos, int ndoubles)",
    "returnType" : "void",
    "comment" : " REMIND: remove once hotspot inlines Double.doubleToLongBits",
    "links" : [ ]
  } ],
  "methodNames" : [ "public void useProtocolVersion(int version) throws IOException", "public final void writeObject(Object obj) throws IOException", "protected void writeObjectOverride(Object obj) throws IOException", "public void writeUnshared(Object obj) throws IOException", "public void defaultWriteObject() throws IOException", "public ObjectOutputStream.PutField putFields() throws IOException", "public void writeFields() throws IOException", "public void reset() throws IOException", "protected void annotateClass(Class<?> cl) throws IOException", "protected void annotateProxyClass(Class<?> cl) throws IOException", "protected Object replaceObject(Object obj) throws IOException", "protected boolean enableReplaceObject(boolean enable) throws SecurityException", "protected void writeStreamHeader() throws IOException", "protected void writeClassDescriptor(ObjectStreamClass desc) throws IOException", "public void write(int val) throws IOException", "public void write(byte[] buf) throws IOException", "public void write(byte[] buf, int off, int len) throws IOException", "public void flush() throws IOException", "protected void drain() throws IOException", "public void close() throws IOException", "public void writeBoolean(boolean val) throws IOException", "public void writeByte(int val) throws IOException", "public void writeShort(int val) throws IOException", "public void writeChar(int val) throws IOException", "public void writeInt(int val) throws IOException", "public void writeLong(long val) throws IOException", "public void writeFloat(float val) throws IOException", "public void writeDouble(double val) throws IOException", "public void writeBytes(String str) throws IOException", "public void writeChars(String str) throws IOException", "public void writeUTF(String str) throws IOException", " int getProtocolVersion()", " void writeTypeString(String str) throws IOException", "private void verifySubclass()", "private static boolean auditSubclass(final Class<?> subcl)", "private void clear()", "private void writeObject0(Object obj, boolean unshared) throws IOException", "private void writeNull() throws IOException", "private void writeHandle(int handle) throws IOException", "private void writeClass(Class<?> cl, boolean unshared) throws IOException", "private void writeClassDesc(ObjectStreamClass desc, boolean unshared) throws IOException", "private boolean isCustomSubclass()", "private void writeProxyDesc(ObjectStreamClass desc, boolean unshared) throws IOException", "private void writeNonProxyDesc(ObjectStreamClass desc, boolean unshared) throws IOException", "private void writeString(String str, boolean unshared) throws IOException", "private void writeArray(Object array, ObjectStreamClass desc, boolean unshared) throws IOException", "private void writeEnum(Enum<?> en, ObjectStreamClass desc, boolean unshared) throws IOException", "private void writeOrdinaryObject(Object obj, ObjectStreamClass desc, boolean unshared) throws IOException", "private void writeExternalData(Externalizable obj) throws IOException", "private void writeRecordData(Object obj, ObjectStreamClass desc) throws IOException", "private void writeSerialData(Object obj, ObjectStreamClass desc) throws IOException", "private void defaultWriteFields(Object obj, ObjectStreamClass desc) throws IOException", "private void writeFatalException(IOException ex) throws IOException", "private static native void floatsToBytes(float[] src, int srcpos, byte[] dst, int dstpos, int nfloats)", "private static native void doublesToBytes(double[] src, int srcpos, byte[] dst, int dstpos, int ndoubles)" ],
  "variableNames" : [ "bout", "handles", "subs", "protocol", "depth", "primVals", "enableOverride", "enableReplace", "curContext", "curPut", "debugInfoStack", "extendedDebugInfo" ]
}