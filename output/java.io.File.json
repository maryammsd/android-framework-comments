{
  "filePath" : "/home/maryam/clearblue/files/android-source-35/java/io/File.java",
  "packageName" : "java.io",
  "className" : "File",
  "comment" : "",
  "links" : [ ],
  "variables" : [ {
    "name" : "fs",
    "type" : "FileSystem",
    "comment" : "\n     * The FileSystem object representing the platform's local file system.\n     ",
    "links" : [ ]
  }, {
    "name" : "path",
    "type" : "String",
    "comment" : "\n     * This abstract pathname's normalized pathname string. A normalized\n     * pathname string uses the default name-separator character and does not\n     * contain any duplicate or redundant separators.\n     *\n     * @serial\n     ",
    "links" : [ ]
  }, {
    "name" : "status",
    "type" : "PathStatus",
    "comment" : "\n     * The flag indicating whether the file path is invalid.\n     ",
    "links" : [ ]
  }, {
    "name" : "prefixLength",
    "type" : "int",
    "comment" : "\n     * The length of this abstract pathname's prefix, or zero if it has no\n     * prefix.\n     ",
    "links" : [ ]
  }, {
    "name" : "separatorChar",
    "type" : "char",
    "comment" : "\n     * The system-dependent default name-separator character.  This field is\n     * initialized to contain the first character of the value of the system\n     * property <code>file.separator</code>.  On UNIX systems the value of this\n     * field is <code>'/'</code>; on Microsoft Windows systems it is <code>'\\\\'</code>.\n     *\n     * @see     java.lang.System#getProperty(java.lang.String)\n     ",
    "links" : [ ]
  }, {
    "name" : "separator",
    "type" : "String",
    "comment" : "\n     * The system-dependent default name-separator character, represented as a\n     * string for convenience.  This string contains a single character, namely\n     * <code>{@link #separatorChar}</code>.\n     ",
    "links" : [ "#separatorChar" ]
  }, {
    "name" : "pathSeparatorChar",
    "type" : "char",
    "comment" : "\n     * The system-dependent path-separator character.  This field is\n     * initialized to contain the first character of the value of the system\n     * property <code>path.separator</code>.  This character is used to\n     * separate filenames in a sequence of files given as a <em>path list</em>.\n     * On UNIX systems, this character is <code>':'</code>; on Microsoft Windows systems it\n     * is <code>';'</code>.\n     *\n     * @see     java.lang.System#getProperty(java.lang.String)\n     ",
    "links" : [ ]
  }, {
    "name" : "pathSeparator",
    "type" : "String",
    "comment" : "\n     * The system-dependent path-separator character, represented as a string\n     * for convenience.  This string contains a single character, namely\n     * <code>{@link #pathSeparatorChar}</code>.\n     ",
    "links" : [ "#pathSeparatorChar" ]
  }, {
    "name" : "CANONICALIZE_PARENT_OF_ROOT_DIR",
    "type" : "long",
    "comment" : "\n     * Canonicalize the parent directory of the root directory when app targets SDK level 35\n     * (Android 15) or higher. \"/..\" can be canonicalized into \"/\" according to POSIX.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "PATH_OFFSET",
    "type" : "long",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "PREFIX_LENGTH_OFFSET",
    "type" : "long",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "UNSAFE",
    "type" : "sun.misc.Unsafe",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "serialVersionUID",
    "type" : "long",
    "comment" : " use serialVersionUID from JDK 1.0.2 for interoperability ",
    "links" : [ ]
  }, {
    "name" : "filePath",
    "type" : "Path",
    "comment" : "",
    "links" : [ ]
  } ],
  "methods" : [ {
    "name" : " final boolean isInvalid()",
    "returnType" : "boolean",
    "comment" : "\n     * Check if the file has an invalid path. Currently, the inspection of\n     * a file path is very limited, and it only covers Nul character check.\n     * Returning true means the path is definitely invalid/garbage. But\n     * returning false does not guarantee that the path is valid.\n     *\n     * @return true if the file path is invalid.\n     ",
    "links" : [ ]
  }, {
    "name" : " int getPrefixLength()",
    "returnType" : "int",
    "comment" : "\n     * Returns the length of this abstract pathname's prefix.\n     * For use by FileSystem classes.\n     ",
    "links" : [ ]
  }, {
    "name" : "public String getName()",
    "returnType" : "String",
    "comment" : "\n     * Returns the name of the file or directory denoted by this abstract\n     * pathname.  This is just the last name in the pathname's name\n     * sequence.  If the pathname's name sequence is empty, then the empty\n     * string is returned.\n     *\n     * @return  The name of the file or directory denoted by this abstract\n     *          pathname, or the empty string if this pathname's name sequence\n     *          is empty\n     ",
    "links" : [ ]
  }, {
    "name" : "public String getParent()",
    "returnType" : "String",
    "comment" : "\n     * Returns the pathname string of this abstract pathname's parent, or\n     * <code>null</code> if this pathname does not name a parent directory.\n     *\n     * <p> The <em>parent</em> of an abstract pathname consists of the\n     * pathname's prefix, if any, and each name in the pathname's name\n     * sequence except for the last.  If the name sequence is empty then\n     * the pathname does not name a parent directory.\n     *\n     * @return  The pathname string of the parent directory named by this\n     *          abstract pathname, or <code>null</code> if this pathname\n     *          does not name a parent\n     ",
    "links" : [ ]
  }, {
    "name" : "public File getParentFile()",
    "returnType" : "File",
    "comment" : "\n     * Returns the abstract pathname of this abstract pathname's parent,\n     * or <code>null</code> if this pathname does not name a parent\n     * directory.\n     *\n     * <p> The <em>parent</em> of an abstract pathname consists of the\n     * pathname's prefix, if any, and each name in the pathname's name\n     * sequence except for the last.  If the name sequence is empty then\n     * the pathname does not name a parent directory.\n     *\n     * @return  The abstract pathname of the parent directory named by this\n     *          abstract pathname, or <code>null</code> if this pathname\n     *          does not name a parent\n     *\n     * @since 1.2\n     ",
    "links" : [ ]
  }, {
    "name" : "public String getPath()",
    "returnType" : "String",
    "comment" : "\n     * Converts this abstract pathname into a pathname string.  The resulting\n     * string uses the {@link #separator default name-separator character} to\n     * separate the names in the name sequence.\n     *\n     * @return  The string form of this abstract pathname\n     ",
    "links" : [ "#separator" ]
  }, {
    "name" : "public boolean isAbsolute()",
    "returnType" : "boolean",
    "comment" : "\n     * Tests whether this abstract pathname is absolute.  The definition of\n     * absolute pathname is system dependent.  On Android, absolute paths start with\n     * the character '/'.\n     *\n     * @return  <code>true</code> if this abstract pathname is absolute,\n     *          <code>false</code> otherwise\n     ",
    "links" : [ ]
  }, {
    "name" : "public String getAbsolutePath()",
    "returnType" : "String",
    "comment" : "\n     * Returns the absolute path of this file. An absolute path is a path that starts at a root\n     * of the file system. On Android, there is only one root: {@code /}.\n     *\n     * <p>A common use for absolute paths is when passing paths to a {@code Process} as\n     * command-line arguments, to remove the requirement implied by relative paths, that the\n     * child must have the same working directory as its parent.\n     *\n     * @return  The absolute pathname string denoting the same file or\n     *          directory as this abstract pathname\n     *\n     * @see     java.io.File#isAbsolute()\n     ",
    "links" : [ ]
  }, {
    "name" : "public File getAbsoluteFile()",
    "returnType" : "File",
    "comment" : "\n     * Returns the absolute form of this abstract pathname.  Equivalent to\n     * <code>new&nbsp;File(this.{@link #getAbsolutePath})</code>.\n     *\n     * @return  The absolute abstract pathname denoting the same file or\n     *          directory as this abstract pathname\n     *\n     * @throws  SecurityException\n     *          If a required system property value cannot be accessed.\n     *\n     * @since 1.2\n     ",
    "links" : [ "#getAbsolutePath" ]
  }, {
    "name" : "public String getCanonicalPath() throws IOException",
    "returnType" : "String",
    "comment" : "\n     * Returns the canonical pathname string of this abstract pathname.\n     *\n     * <p> A canonical pathname is both absolute and unique.  The precise\n     * definition of canonical form is system-dependent.  This method first\n     * converts this pathname to absolute form if necessary, as if by invoking the\n     * {@link #getAbsolutePath} method, and then maps it to its unique form in a\n     * system-dependent way.  This typically involves removing redundant names\n     * such as <tt>\".\"</tt> and <tt>\"..\"</tt> from the pathname, resolving\n     * symbolic links (on UNIX platforms), and converting drive letters to a\n     * standard case (on Microsoft Windows platforms).\n     *\n     * <p> Every pathname that denotes an existing file or directory has a\n     * unique canonical form.  Every pathname that denotes a nonexistent file\n     * or directory also has a unique canonical form.  The canonical form of\n     * the pathname of a nonexistent file or directory may be different from\n     * the canonical form of the same pathname after the file or directory is\n     * created.  Similarly, the canonical form of the pathname of an existing\n     * file or directory may be different from the canonical form of the same\n     * pathname after the file or directory is deleted.\n     *\n     * @return  The canonical pathname string denoting the same file or\n     *          directory as this abstract pathname\n     *\n     * @throws  IOException\n     *          If an I/O error occurs, which is possible because the\n     *          construction of the canonical pathname may require\n     *          filesystem queries\n     *\n     * @throws  SecurityException\n     *          If a required system property value cannot be accessed, or\n     *          if a security manager exists and its <code>{@link\n     *          java.lang.SecurityManager#checkRead}</code> method denies\n     *          read access to the file\n     *\n     * @since   JDK1.1\n     * @see     Path#toRealPath\n     ",
    "links" : [ "java.lang.SecurityManager#checkRead", "#getAbsolutePath" ]
  }, {
    "name" : "public File getCanonicalFile() throws IOException",
    "returnType" : "File",
    "comment" : "\n     * Returns the canonical form of this abstract pathname.  Equivalent to\n     * <code>new&nbsp;File(this.{@link #getCanonicalPath})</code>.\n     *\n     * @return  The canonical pathname string denoting the same file or\n     *          directory as this abstract pathname\n     *\n     * @throws  IOException\n     *          If an I/O error occurs, which is possible because the\n     *          construction of the canonical pathname may require\n     *          filesystem queries\n     *\n     * @throws  SecurityException\n     *          If a required system property value cannot be accessed, or\n     *          if a security manager exists and its <code>{@link\n     *          java.lang.SecurityManager#checkRead}</code> method denies\n     *          read access to the file\n     *\n     * @since 1.2\n     * @see     Path#toRealPath\n     ",
    "links" : [ "java.lang.SecurityManager#checkRead", "#getCanonicalPath" ]
  }, {
    "name" : "private static String slashify(String path, boolean isDirectory)",
    "returnType" : "String",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public URL toURL() throws MalformedURLException",
    "returnType" : "URL",
    "comment" : "\n     * Converts this abstract pathname into a <code>file:</code> URL.  The\n     * exact form of the URL is system-dependent.  If it can be determined that\n     * the file denoted by this abstract pathname is a directory, then the\n     * resulting URL will end with a slash.\n     *\n     * @return  A URL object representing the equivalent file URL\n     *\n     * @throws  MalformedURLException\n     *          If the path cannot be parsed as a URL\n     *\n     * @see     #toURI()\n     * @see     java.net.URI\n     * @see     java.net.URI#toURL()\n     * @see     java.net.URL\n     * @since   1.2\n     *\n     * @deprecated This method does not automatically escape characters that\n     * are illegal in URLs.  It is recommended that new code convert an\n     * abstract pathname into a URL by first converting it into a URI, via the\n     * {@link #toURI() toURI} method, and then converting the URI into a URL\n     * via the {@link java.net.URI#toURL() URI.toURL} method.\n     ",
    "links" : [ "#toURI()", "java.net.URI#toURL()" ]
  }, {
    "name" : "public URI toURI()",
    "returnType" : "URI",
    "comment" : "\n     * Constructs a <tt>file:</tt> URI that represents this abstract pathname.\n     *\n     * <p> The exact form of the URI is system-dependent.  If it can be\n     * determined that the file denoted by this abstract pathname is a\n     * directory, then the resulting URI will end with a slash.\n     *\n     * <p> For a given abstract pathname <i>f</i>, it is guaranteed that\n     *\n     * <blockquote><tt>\n     * new {@link #File(java.net.URI) File}(</tt><i>&nbsp;f</i><tt>.toURI()).equals(</tt><i>&nbsp;f</i><tt>.{@link #getAbsoluteFile() getAbsoluteFile}())\n     * </tt></blockquote>\n     *\n     * so long as the original abstract pathname, the URI, and the new abstract\n     * pathname are all created in (possibly different invocations of) the same\n     * Java virtual machine.  Due to the system-dependent nature of abstract\n     * pathnames, however, this relationship typically does not hold when a\n     * <tt>file:</tt> URI that is created in a virtual machine on one operating\n     * system is converted into an abstract pathname in a virtual machine on a\n     * different operating system.\n     *\n     * <p> Note that when this abstract pathname represents a UNC pathname then\n     * all components of the UNC (including the server name component) are encoded\n     * in the {@code URI} path. The authority component is undefined, meaning\n     * that it is represented as {@code null}. The {@link Path} class defines the\n     * {@link Path#toUri toUri} method to encode the server name in the authority\n     * component of the resulting {@code URI}. The {@link #toPath toPath} method\n     * may be used to obtain a {@code Path} representing this abstract pathname.\n     *\n     * @return  An absolute, hierarchical URI with a scheme equal to\n     *          <tt>\"file\"</tt>, a path representing this abstract pathname,\n     *          and undefined authority, query, and fragment components\n     * @throws SecurityException If a required system property value cannot\n     * be accessed.\n     *\n     * @see #File(java.net.URI)\n     * @see java.net.URI\n     * @see java.net.URI#toURL()\n     * @since 1.4\n     ",
    "links" : [ "#File(java.net.URI)", "#getAbsoluteFile()", "java.nio.file.Path", "#toPath", "java.nio.file.Path#toUri" ]
  }, {
    "name" : "public boolean canRead()",
    "returnType" : "boolean",
    "comment" : "\n     * Tests whether the application can read the file denoted by this\n     * abstract pathname.\n     *\n     * @return  <code>true</code> if and only if the file specified by this\n     *          abstract pathname exists <em>and</em> can be read by the\n     *          application; <code>false</code> otherwise\n     *\n     * @throws  SecurityException\n     *          If a security manager exists and its <code>{@link\n     *          java.lang.SecurityManager#checkRead(java.lang.String)}</code>\n     *          method denies read access to the file\n     ",
    "links" : [ "java.lang.SecurityManager#checkRead(java.lang.String)" ]
  }, {
    "name" : "public boolean canWrite()",
    "returnType" : "boolean",
    "comment" : "\n     * Tests whether the application can modify the file denoted by this\n     * abstract pathname.\n     *\n     * @return  <code>true</code> if and only if the file system actually\n     *          contains a file denoted by this abstract pathname <em>and</em>\n     *          the application is allowed to write to the file;\n     *          <code>false</code> otherwise.\n     *\n     * @throws  SecurityException\n     *          If a security manager exists and its <code>{@link\n     *          java.lang.SecurityManager#checkWrite(java.lang.String)}</code>\n     *          method denies write access to the file\n     ",
    "links" : [ "java.lang.SecurityManager#checkWrite(java.lang.String)" ]
  }, {
    "name" : "public boolean exists()",
    "returnType" : "boolean",
    "comment" : "\n     * Tests whether the file or directory denoted by this abstract pathname\n     * exists.\n     *\n     * @return  <code>true</code> if and only if the file or directory denoted\n     *          by this abstract pathname exists; <code>false</code> otherwise\n     *\n     * @throws  SecurityException\n     *          If a security manager exists and its <code>{@link\n     *          java.lang.SecurityManager#checkRead(java.lang.String)}</code>\n     *          method denies read access to the file or directory\n     ",
    "links" : [ "java.lang.SecurityManager#checkRead(java.lang.String)" ]
  }, {
    "name" : "public boolean isDirectory()",
    "returnType" : "boolean",
    "comment" : "\n     * Tests whether the file denoted by this abstract pathname is a\n     * directory.\n     *\n     * <p> Where it is required to distinguish an I/O exception from the case\n     * that the file is not a directory, or where several attributes of the\n     * same file are required at the same time, then the {@link\n     * java.nio.file.Files#readAttributes(Path,Class,LinkOption[])\n     * Files.readAttributes} method may be used.\n     *\n     * @return <code>true</code> if and only if the file denoted by this\n     *          abstract pathname exists <em>and</em> is a directory;\n     *          <code>false</code> otherwise\n     *\n     * @throws  SecurityException\n     *          If a security manager exists and its <code>{@link\n     *          java.lang.SecurityManager#checkRead(java.lang.String)}</code>\n     *          method denies read access to the file\n     ",
    "links" : [ "java.lang.SecurityManager#checkRead(java.lang.String)", "java.nio.file.Files#readAttributes(Path" ]
  }, {
    "name" : "public boolean isFile()",
    "returnType" : "boolean",
    "comment" : "\n     * Tests whether the file denoted by this abstract pathname is a normal\n     * file.  A file is <em>normal</em> if it is not a directory and, in\n     * addition, satisfies other system-dependent criteria.  Any non-directory\n     * file created by a Java application is guaranteed to be a normal file.\n     *\n     * <p> Where it is required to distinguish an I/O exception from the case\n     * that the file is not a normal file, or where several attributes of the\n     * same file are required at the same time, then the {@link\n     * java.nio.file.Files#readAttributes(Path,Class,LinkOption[])\n     * Files.readAttributes} method may be used.\n     *\n     * @return  <code>true</code> if and only if the file denoted by this\n     *          abstract pathname exists <em>and</em> is a normal file;\n     *          <code>false</code> otherwise\n     *\n     * @throws  SecurityException\n     *          If a security manager exists and its <code>{@link\n     *          java.lang.SecurityManager#checkRead(java.lang.String)}</code>\n     *          method denies read access to the file\n     ",
    "links" : [ "java.lang.SecurityManager#checkRead(java.lang.String)", "java.nio.file.Files#readAttributes(Path" ]
  }, {
    "name" : "public boolean isHidden()",
    "returnType" : "boolean",
    "comment" : "\n     * Tests whether the file named by this abstract pathname is a hidden\n     * file.  The exact definition of <em>hidden</em> is system-dependent.  On\n     * UNIX systems, a file is considered to be hidden if its name begins with\n     * a period character (<code>'.'</code>).  On Microsoft Windows systems, a file is\n     * considered to be hidden if it has been marked as such in the filesystem.\n     *\n     * @return  <code>true</code> if and only if the file denoted by this\n     *          abstract pathname is hidden according to the conventions of the\n     *          underlying platform\n     *\n     * @throws  SecurityException\n     *          If a security manager exists and its <code>{@link\n     *          java.lang.SecurityManager#checkRead(java.lang.String)}</code>\n     *          method denies read access to the file\n     *\n     * @since 1.2\n     ",
    "links" : [ "java.lang.SecurityManager#checkRead(java.lang.String)" ]
  }, {
    "name" : "public long lastModified()",
    "returnType" : "long",
    "comment" : "\n     * Returns the time that the file denoted by this abstract pathname was\n     * last modified.\n     *\n     * <p> Where it is required to distinguish an I/O exception from the case\n     * where {@code 0L} is returned, or where several attributes of the\n     * same file are required at the same time, or where the time of last\n     * access or the creation time are required, then the {@link\n     * java.nio.file.Files#readAttributes(Path,Class,LinkOption[])\n     * Files.readAttributes} method may be used.\n     *\n     * @return  A <code>long</code> value representing the time the file was\n     *          last modified, measured in milliseconds since the epoch\n     *          (00:00:00 GMT, January 1, 1970), or <code>0L</code> if the\n     *          file does not exist or if an I/O error occurs\n     *\n     * @throws  SecurityException\n     *          If a security manager exists and its <code>{@link\n     *          java.lang.SecurityManager#checkRead(java.lang.String)}</code>\n     *          method denies read access to the file\n     ",
    "links" : [ "java.lang.SecurityManager#checkRead(java.lang.String)", "java.nio.file.Files#readAttributes(Path" ]
  }, {
    "name" : "public long length()",
    "returnType" : "long",
    "comment" : "\n     * Returns the length of the file denoted by this abstract pathname.\n     * The return value is unspecified if this pathname denotes a directory.\n     *\n     * <p> Where it is required to distinguish an I/O exception from the case\n     * that {@code 0L} is returned, or where several attributes of the same file\n     * are required at the same time, then the {@link\n     * java.nio.file.Files#readAttributes(Path,Class,LinkOption[])\n     * Files.readAttributes} method may be used.\n     *\n     * @return  The length, in bytes, of the file denoted by this abstract\n     *          pathname, or <code>0L</code> if the file does not exist.  Some\n     *          operating systems may return <code>0L</code> for pathnames\n     *          denoting system-dependent entities such as devices or pipes.\n     *\n     * @throws  SecurityException\n     *          If a security manager exists and its <code>{@link\n     *          java.lang.SecurityManager#checkRead(java.lang.String)}</code>\n     *          method denies read access to the file\n     ",
    "links" : [ "java.lang.SecurityManager#checkRead(java.lang.String)", "java.nio.file.Files#readAttributes(Path" ]
  }, {
    "name" : "public boolean createNewFile() throws IOException",
    "returnType" : "boolean",
    "comment" : "\n     * Atomically creates a new, empty file named by this abstract pathname if\n     * and only if a file with this name does not yet exist.  The check for the\n     * existence of the file and the creation of the file if it does not exist\n     * are a single operation that is atomic with respect to all other\n     * filesystem activities that might affect the file.\n     * <P>\n     * Note: this method should <i>not</i> be used for file-locking, as\n     * the resulting protocol cannot be made to work reliably. The\n     * {@link java.nio.channels.FileLock FileLock}\n     * facility should be used instead.\n     *\n     * @return  <code>true</code> if the named file does not exist and was\n     *          successfully created; <code>false</code> if the named file\n     *          already exists\n     *\n     * @throws  IOException\n     *          If an I/O error occurred\n     *\n     * @throws  SecurityException\n     *          If a security manager exists and its <code>{@link\n     *          java.lang.SecurityManager#checkWrite(java.lang.String)}</code>\n     *          method denies write access to the file\n     *\n     * @since 1.2\n     ",
    "links" : [ "java.lang.SecurityManager#checkWrite(java.lang.String)", "java.nio.channels.FileLock" ]
  }, {
    "name" : "public boolean delete()",
    "returnType" : "boolean",
    "comment" : "\n     * Deletes the file or directory denoted by this abstract pathname.  If\n     * this pathname denotes a directory, then the directory must be empty in\n     * order to be deleted.\n     *\n     * <p> Note that the {@link java.nio.file.Files} class defines the {@link\n     * java.nio.file.Files#delete(Path) delete} method to throw an {@link IOException}\n     * when a file cannot be deleted. This is useful for error reporting and to\n     * diagnose why a file cannot be deleted.\n     *\n     * @return  <code>true</code> if and only if the file or directory is\n     *          successfully deleted; <code>false</code> otherwise\n     *\n     * @throws  SecurityException\n     *          If a security manager exists and its <code>{@link\n     *          java.lang.SecurityManager#checkDelete}</code> method denies\n     *          delete access to the file\n     ",
    "links" : [ "java.lang.SecurityManager#checkDelete", "java.nio.file.Files#delete(Path)", "java.nio.file.Files", "java.io.IOException" ]
  }, {
    "name" : "public void deleteOnExit()",
    "returnType" : "void",
    "comment" : "\n     * Requests that the file or directory denoted by this abstract\n     * pathname be deleted when the virtual machine terminates.\n     * Files (or directories) are deleted in the reverse order that\n     * they are registered. Invoking this method to delete a file or\n     * directory that is already registered for deletion has no effect.\n     * Deletion will be attempted only for normal termination of the\n     * virtual machine, as defined by the Java Language Specification.\n     *\n     * <p> Once deletion has been requested, it is not possible to cancel the\n     * request.  This method should therefore be used with care.\n     *\n     * <P>\n     * Note: this method should <i>not</i> be used for file-locking, as\n     * the resulting protocol cannot be made to work reliably. The\n     * {@link java.nio.channels.FileLock FileLock}\n     * facility should be used instead.\n     *\n     * <p><i>Note that on Android, the application lifecycle does not include VM termination,\n     * so calling this method will not ensure that files are deleted</i>. Instead, you should\n     * use the most appropriate out of:\n     * <ul>\n     * <li>Use a {@code finally} clause to manually invoke {@link #delete}.\n     * <li>Maintain your own set of files to delete, and process it at an appropriate point\n     * in your application's lifecycle.\n     * <li>Use the Unix trick of deleting the file as soon as all readers and writers have\n     * opened it. No new readers/writers will be able to access the file, but all existing\n     * ones will still have access until the last one closes the file.\n     * </ul>\n     *\n     * @throws  SecurityException\n     *          If a security manager exists and its <code>{@link\n     *          java.lang.SecurityManager#checkDelete}</code> method denies\n     *          delete access to the file\n     *\n     * @see #delete\n     *\n     * @since 1.2\n     ",
    "links" : [ "java.lang.SecurityManager#checkDelete", "#delete", "java.nio.channels.FileLock" ]
  }, {
    "name" : "public String[] list()",
    "returnType" : "String[]",
    "comment" : "\n     * Returns an array of strings naming the files and directories in the\n     * directory denoted by this abstract pathname.\n     *\n     * <p> If this abstract pathname does not denote a directory, then this\n     * method returns {@code null}.  Otherwise an array of strings is\n     * returned, one for each file or directory in the directory.  Names\n     * denoting the directory itself and the directory's parent directory are\n     * not included in the result.  Each string is a file name rather than a\n     * complete path.\n     *\n     * <p> There is no guarantee that the name strings in the resulting array\n     * will appear in any specific order; they are not, in particular,\n     * guaranteed to appear in alphabetical order.\n     *\n     * <p> Note that the {@link java.nio.file.Files} class defines the {@link\n     * java.nio.file.Files#newDirectoryStream(Path) newDirectoryStream} method to\n     * open a directory and iterate over the names of the files in the directory.\n     * This may use less resources when working with very large directories, and\n     * may be more responsive when working with remote directories.\n     *\n     * @return  An array of strings naming the files and directories in the\n     *          directory denoted by this abstract pathname.  The array will be\n     *          empty if the directory is empty.  Returns {@code null} if\n     *          this abstract pathname does not denote a directory, or if an\n     *          I/O error occurs.\n     *\n     * @throws  SecurityException\n     *          If a security manager exists and its {@link\n     *          SecurityManager#checkRead(String)} method denies read access to\n     *          the directory\n     ",
    "links" : [ "java.nio.file.Files", "#checkRead(String)", "java.nio.file.Files#newDirectoryStream(Path)" ]
  }, {
    "name" : "public String[] list(FilenameFilter filter)",
    "returnType" : "String[]",
    "comment" : "\n     * Returns an array of strings naming the files and directories in the\n     * directory denoted by this abstract pathname that satisfy the specified\n     * filter.  The behavior of this method is the same as that of the\n     * {@link #list()} method, except that the strings in the returned array\n     * must satisfy the filter.  If the given {@code filter} is {@code null}\n     * then all names are accepted.  Otherwise, a name satisfies the filter if\n     * and only if the value {@code true} results when the {@link\n     * FilenameFilter#accept FilenameFilter.accept(File,&nbsp;String)} method\n     * of the filter is invoked on this abstract pathname and the name of a\n     * file or directory in the directory that it denotes.\n     *\n     * @param  filter\n     *         A filename filter\n     *\n     * @return  An array of strings naming the files and directories in the\n     *          directory denoted by this abstract pathname that were accepted\n     *          by the given {@code filter}.  The array will be empty if the\n     *          directory is empty or if no names were accepted by the filter.\n     *          Returns {@code null} if this abstract pathname does not denote\n     *          a directory, or if an I/O error occurs.\n     *\n     * @throws  SecurityException\n     *          If a security manager exists and its {@link\n     *          SecurityManager#checkRead(String)} method denies read access to\n     *          the directory\n     *\n     * @see java.nio.file.Files#newDirectoryStream(Path,String)\n     ",
    "links" : [ "#list()", "java.io.FilenameFilter#accept", "#checkRead(String)" ]
  }, {
    "name" : "public File[] listFiles()",
    "returnType" : "File[]",
    "comment" : "\n     * Returns an array of abstract pathnames denoting the files in the\n     * directory denoted by this abstract pathname.\n     *\n     * <p> If this abstract pathname does not denote a directory, then this\n     * method returns {@code null}.  Otherwise an array of {@code File} objects\n     * is returned, one for each file or directory in the directory.  Pathnames\n     * denoting the directory itself and the directory's parent directory are\n     * not included in the result.  Each resulting abstract pathname is\n     * constructed from this abstract pathname using the {@link #File(File,\n     * String) File(File,&nbsp;String)} constructor.  Therefore if this\n     * pathname is absolute then each resulting pathname is absolute; if this\n     * pathname is relative then each resulting pathname will be relative to\n     * the same directory.\n     *\n     * <p> There is no guarantee that the name strings in the resulting array\n     * will appear in any specific order; they are not, in particular,\n     * guaranteed to appear in alphabetical order.\n     *\n     * <p> Note that the {@link java.nio.file.Files} class defines the {@link\n     * java.nio.file.Files#newDirectoryStream(Path) newDirectoryStream} method\n     * to open a directory and iterate over the names of the files in the\n     * directory. This may use less resources when working with very large\n     * directories.\n     *\n     * @return  An array of abstract pathnames denoting the files and\n     *          directories in the directory denoted by this abstract pathname.\n     *          The array will be empty if the directory is empty.  Returns\n     *          {@code null} if this abstract pathname does not denote a\n     *          directory, or if an I/O error occurs.\n     *\n     * @throws  SecurityException\n     *          If a security manager exists and its {@link\n     *          SecurityManager#checkRead(String)} method denies read access to\n     *          the directory\n     *\n     * @since  1.2\n     ",
    "links" : [ "java.nio.file.Files", "#checkRead(String)", "java.nio.file.Files#newDirectoryStream(Path)", "#File(File" ]
  }, {
    "name" : "public File[] listFiles(FilenameFilter filter)",
    "returnType" : "File[]",
    "comment" : "\n     * Returns an array of abstract pathnames denoting the files and\n     * directories in the directory denoted by this abstract pathname that\n     * satisfy the specified filter.  The behavior of this method is the same\n     * as that of the {@link #listFiles()} method, except that the pathnames in\n     * the returned array must satisfy the filter.  If the given {@code filter}\n     * is {@code null} then all pathnames are accepted.  Otherwise, a pathname\n     * satisfies the filter if and only if the value {@code true} results when\n     * the {@link FilenameFilter#accept\n     * FilenameFilter.accept(File,&nbsp;String)} method of the filter is\n     * invoked on this abstract pathname and the name of a file or directory in\n     * the directory that it denotes.\n     *\n     * @param  filter\n     *         A filename filter\n     *\n     * @return  An array of abstract pathnames denoting the files and\n     *          directories in the directory denoted by this abstract pathname.\n     *          The array will be empty if the directory is empty.  Returns\n     *          {@code null} if this abstract pathname does not denote a\n     *          directory, or if an I/O error occurs.\n     *\n     * @throws  SecurityException\n     *          If a security manager exists and its {@link\n     *          SecurityManager#checkRead(String)} method denies read access to\n     *          the directory\n     *\n     * @since  1.2\n     * @see java.nio.file.Files#newDirectoryStream(Path,String)\n     ",
    "links" : [ "#checkRead(String)", "#listFiles()", "java.io.FilenameFilter#acceptFilenameFilter.accept(File" ]
  }, {
    "name" : "public File[] listFiles(FileFilter filter)",
    "returnType" : "File[]",
    "comment" : "\n     * Returns an array of abstract pathnames denoting the files and\n     * directories in the directory denoted by this abstract pathname that\n     * satisfy the specified filter.  The behavior of this method is the same\n     * as that of the {@link #listFiles()} method, except that the pathnames in\n     * the returned array must satisfy the filter.  If the given {@code filter}\n     * is {@code null} then all pathnames are accepted.  Otherwise, a pathname\n     * satisfies the filter if and only if the value {@code true} results when\n     * the {@link FileFilter#accept FileFilter.accept(File)} method of the\n     * filter is invoked on the pathname.\n     *\n     * @param  filter\n     *         A file filter\n     *\n     * @return  An array of abstract pathnames denoting the files and\n     *          directories in the directory denoted by this abstract pathname.\n     *          The array will be empty if the directory is empty.  Returns\n     *          {@code null} if this abstract pathname does not denote a\n     *          directory, or if an I/O error occurs.\n     *\n     * @throws  SecurityException\n     *          If a security manager exists and its {@link\n     *          SecurityManager#checkRead(String)} method denies read access to\n     *          the directory\n     *\n     * @since  1.2\n     * @see java.nio.file.Files#newDirectoryStream(Path,java.nio.file.DirectoryStream.Filter)\n     ",
    "links" : [ "#checkRead(String)", "#listFiles()", "java.io.FileFilter#accept" ]
  }, {
    "name" : "public boolean mkdir()",
    "returnType" : "boolean",
    "comment" : "\n     * Creates the directory named by this abstract pathname.\n     *\n     * @return  <code>true</code> if and only if the directory was\n     *          created; <code>false</code> otherwise\n     *\n     * @throws  SecurityException\n     *          If a security manager exists and its <code>{@link\n     *          java.lang.SecurityManager#checkWrite(java.lang.String)}</code>\n     *          method does not permit the named directory to be created\n     ",
    "links" : [ "java.lang.SecurityManager#checkWrite(java.lang.String)" ]
  }, {
    "name" : "public boolean mkdirs()",
    "returnType" : "boolean",
    "comment" : "\n     * Creates the directory named by this abstract pathname, including any\n     * necessary but nonexistent parent directories.  Note that if this\n     * operation fails it may have succeeded in creating some of the necessary\n     * parent directories.\n     *\n     * @return  <code>true</code> if and only if the directory was created,\n     *          along with all necessary parent directories; <code>false</code>\n     *          otherwise\n     *\n     * @throws  SecurityException\n     *          If a security manager exists and its <code>{@link\n     *          java.lang.SecurityManager#checkRead(java.lang.String)}</code>\n     *          method does not permit verification of the existence of the\n     *          named directory and all necessary parent directories; or if\n     *          the <code>{@link\n     *          java.lang.SecurityManager#checkWrite(java.lang.String)}</code>\n     *          method does not permit the named directory and all necessary\n     *          parent directories to be created\n     ",
    "links" : [ "java.lang.SecurityManager#checkRead(java.lang.String)", "java.lang.SecurityManager#checkWrite(java.lang.String)" ]
  }, {
    "name" : "public boolean renameTo(File dest)",
    "returnType" : "boolean",
    "comment" : "\n     * Renames the file denoted by this abstract pathname.\n     *\n     * <p>Many failures are possible. Some of the more likely failures include:\n     * <ul>\n     * <li>Write permission is required on the directories containing both the source and\n     * destination paths.\n     * <li>Search permission is required for all parents of both paths.\n     * <li>Both paths be on the same mount point. On Android, applications are most likely to hit\n     * this restriction when attempting to copy between internal storage and an SD card.\n     * </ul>\n     *\n     * <p>The return value should always be checked to make sure\n     * that the rename operation was successful.\n     *\n     * <p> Note that the {@link java.nio.file.Files} class defines the {@link\n     * java.nio.file.Files#move move} method to move or rename a file in a\n     * platform independent manner.\n     *\n     * @param  dest  The new abstract pathname for the named file\n     *\n     * @return  <code>true</code> if and only if the renaming succeeded;\n     *          <code>false</code> otherwise\n     *\n     * @throws  SecurityException\n     *          If a security manager exists and its <code>{@link\n     *          java.lang.SecurityManager#checkWrite(java.lang.String)}</code>\n     *          method denies write access to either the old or new pathnames\n     *\n     * @throws  NullPointerException\n     *          If parameter <code>dest</code> is <code>null</code>\n     ",
    "links" : [ "java.nio.file.Files#move", "java.lang.SecurityManager#checkWrite(java.lang.String)", "java.nio.file.Files" ]
  }, {
    "name" : "public boolean setLastModified(long time)",
    "returnType" : "boolean",
    "comment" : "\n     * Sets the last-modified time of the file or directory named by this\n     * abstract pathname.\n     *\n     * <p> All platforms support file-modification times to the nearest second,\n     * but some provide more precision.  The argument will be truncated to fit\n     * the supported precision.  If the operation succeeds and no intervening\n     * operations on the file take place, then the next invocation of the\n     * <code>{@link #lastModified}</code> method will return the (possibly\n     * truncated) <code>time</code> argument that was passed to this method.\n     *\n     * @param  time  The new last-modified time, measured in milliseconds since\n     *               the epoch (00:00:00 GMT, January 1, 1970)\n     *\n     * @return <code>true</code> if and only if the operation succeeded;\n     *          <code>false</code> otherwise\n     *\n     * @throws  IllegalArgumentException  If the argument is negative\n     *\n     * @throws  SecurityException\n     *          If a security manager exists and its <code>{@link\n     *          java.lang.SecurityManager#checkWrite(java.lang.String)}</code>\n     *          method denies write access to the named file\n     *\n     * @since 1.2\n     ",
    "links" : [ "java.lang.SecurityManager#checkWrite(java.lang.String)", "#lastModified" ]
  }, {
    "name" : "public boolean setReadOnly()",
    "returnType" : "boolean",
    "comment" : "\n     * Marks the file or directory named by this abstract pathname so that\n     * only read operations are allowed. After invoking this method the file\n     * or directory will not change until it is either deleted or marked\n     * to allow write access. Whether or not a read-only file or\n     * directory may be deleted depends upon the underlying system.\n     *\n     * @return <code>true</code> if and only if the operation succeeded;\n     *          <code>false</code> otherwise\n     *\n     * @throws  SecurityException\n     *          If a security manager exists and its <code>{@link\n     *          java.lang.SecurityManager#checkWrite(java.lang.String)}</code>\n     *          method denies write access to the named file\n     *\n     * @since 1.2\n     ",
    "links" : [ "java.lang.SecurityManager#checkWrite(java.lang.String)" ]
  }, {
    "name" : "public boolean setWritable(boolean writable, boolean ownerOnly)",
    "returnType" : "boolean",
    "comment" : "\n     * Sets the owner's or everybody's write permission for this abstract\n     * pathname.\n     *\n     * <p> The {@link java.nio.file.Files} class defines methods that operate on\n     * file attributes including file permissions. This may be used when finer\n     * manipulation of file permissions is required.\n     *\n     * @param   writable\n     *          If <code>true</code>, sets the access permission to allow write\n     *          operations; if <code>false</code> to disallow write operations\n     *\n     * @param   ownerOnly\n     *          If <code>true</code>, the write permission applies only to the\n     *          owner's write permission; otherwise, it applies to everybody.  If\n     *          the underlying file system can not distinguish the owner's write\n     *          permission from that of others, then the permission will apply to\n     *          everybody, regardless of this value.\n     *\n     * @return  <code>true</code> if and only if the operation succeeded. The\n     *          operation will fail if the user does not have permission to change\n     *          the access permissions of this abstract pathname.\n     *\n     * @throws  SecurityException\n     *          If a security manager exists and its <code>{@link\n     *          java.lang.SecurityManager#checkWrite(java.lang.String)}</code>\n     *          method denies write access to the named file\n     *\n     * @since 1.6\n     ",
    "links" : [ "java.lang.SecurityManager#checkWrite(java.lang.String)", "java.nio.file.Files" ]
  }, {
    "name" : "public boolean setWritable(boolean writable)",
    "returnType" : "boolean",
    "comment" : "\n     * A convenience method to set the owner's write permission for this abstract\n     * pathname.\n     *\n     * <p> An invocation of this method of the form <tt>file.setWritable(arg)</tt>\n     * behaves in exactly the same way as the invocation\n     *\n     * <pre>\n     *     file.setWritable(arg, true) </pre>\n     *\n     * @param   writable\n     *          If <code>true</code>, sets the access permission to allow write\n     *          operations; if <code>false</code> to disallow write operations\n     *\n     * @return  <code>true</code> if and only if the operation succeeded.  The\n     *          operation will fail if the user does not have permission to\n     *          change the access permissions of this abstract pathname.\n     *\n     * @throws  SecurityException\n     *          If a security manager exists and its <code>{@link\n     *          java.lang.SecurityManager#checkWrite(java.lang.String)}</code>\n     *          method denies write access to the file\n     *\n     * @since 1.6\n     ",
    "links" : [ "java.lang.SecurityManager#checkWrite(java.lang.String)" ]
  }, {
    "name" : "public boolean setReadable(boolean readable, boolean ownerOnly)",
    "returnType" : "boolean",
    "comment" : "\n     * Sets the owner's or everybody's read permission for this abstract\n     * pathname.\n     *\n     * <p> The {@link java.nio.file.Files} class defines methods that operate on\n     * file attributes including file permissions. This may be used when finer\n     * manipulation of file permissions is required.\n     *\n     * @param   readable\n     *          If <code>true</code>, sets the access permission to allow read\n     *          operations; if <code>false</code> to disallow read operations\n     *\n     * @param   ownerOnly\n     *          If <code>true</code>, the read permission applies only to the\n     *          owner's read permission; otherwise, it applies to everybody.  If\n     *          the underlying file system can not distinguish the owner's read\n     *          permission from that of others, then the permission will apply to\n     *          everybody, regardless of this value.\n     *\n     * @return  <code>true</code> if and only if the operation succeeded.  The\n     *          operation will fail if the user does not have permission to\n     *          change the access permissions of this abstract pathname.  If\n     *          <code>readable</code> is <code>false</code> and the underlying\n     *          file system does not implement a read permission, then the\n     *          operation will fail.\n     *\n     * @throws  SecurityException\n     *          If a security manager exists and its <code>{@link\n     *          java.lang.SecurityManager#checkWrite(java.lang.String)}</code>\n     *          method denies write access to the file\n     *\n     * @since 1.6\n     ",
    "links" : [ "java.lang.SecurityManager#checkWrite(java.lang.String)", "java.nio.file.Files" ]
  }, {
    "name" : "public boolean setReadable(boolean readable)",
    "returnType" : "boolean",
    "comment" : "\n     * A convenience method to set the owner's read permission for this abstract\n     * pathname.\n     *\n     * <p>An invocation of this method of the form <tt>file.setReadable(arg)</tt>\n     * behaves in exactly the same way as the invocation\n     *\n     * <pre>\n     *     file.setReadable(arg, true) </pre>\n     *\n     * @param  readable\n     *          If <code>true</code>, sets the access permission to allow read\n     *          operations; if <code>false</code> to disallow read operations\n     *\n     * @return  <code>true</code> if and only if the operation succeeded.  The\n     *          operation will fail if the user does not have permission to\n     *          change the access permissions of this abstract pathname.  If\n     *          <code>readable</code> is <code>false</code> and the underlying\n     *          file system does not implement a read permission, then the\n     *          operation will fail.\n     *\n     * @throws  SecurityException\n     *          If a security manager exists and its <code>{@link\n     *          java.lang.SecurityManager#checkWrite(java.lang.String)}</code>\n     *          method denies write access to the file\n     *\n     * @since 1.6\n     ",
    "links" : [ "java.lang.SecurityManager#checkWrite(java.lang.String)" ]
  }, {
    "name" : "public boolean setExecutable(boolean executable, boolean ownerOnly)",
    "returnType" : "boolean",
    "comment" : "\n     * Sets the owner's or everybody's execute permission for this abstract\n     * pathname.\n     *\n     * <p> The {@link java.nio.file.Files} class defines methods that operate on\n     * file attributes including file permissions. This may be used when finer\n     * manipulation of file permissions is required.\n     *\n     * @param   executable\n     *          If <code>true</code>, sets the access permission to allow execute\n     *          operations; if <code>false</code> to disallow execute operations\n     *\n     * @param   ownerOnly\n     *          If <code>true</code>, the execute permission applies only to the\n     *          owner's execute permission; otherwise, it applies to everybody.\n     *          If the underlying file system can not distinguish the owner's\n     *          execute permission from that of others, then the permission will\n     *          apply to everybody, regardless of this value.\n     *\n     * @return  <code>true</code> if and only if the operation succeeded.  The\n     *          operation will fail if the user does not have permission to\n     *          change the access permissions of this abstract pathname.  If\n     *          <code>executable</code> is <code>false</code> and the underlying\n     *          file system does not implement an execute permission, then the\n     *          operation will fail.\n     *\n     * @throws  SecurityException\n     *          If a security manager exists and its <code>{@link\n     *          java.lang.SecurityManager#checkWrite(java.lang.String)}</code>\n     *          method denies write access to the file\n     *\n     * @since 1.6\n     ",
    "links" : [ "java.lang.SecurityManager#checkWrite(java.lang.String)", "java.nio.file.Files" ]
  }, {
    "name" : "public boolean setExecutable(boolean executable)",
    "returnType" : "boolean",
    "comment" : "\n     * A convenience method to set the owner's execute permission for this\n     * abstract pathname.\n     *\n     * <p>An invocation of this method of the form <tt>file.setExcutable(arg)</tt>\n     * behaves in exactly the same way as the invocation\n     *\n     * <pre>\n     *     file.setExecutable(arg, true) </pre>\n     *\n     * @param   executable\n     *          If <code>true</code>, sets the access permission to allow execute\n     *          operations; if <code>false</code> to disallow execute operations\n     *\n     * @return   <code>true</code> if and only if the operation succeeded.  The\n     *           operation will fail if the user does not have permission to\n     *           change the access permissions of this abstract pathname.  If\n     *           <code>executable</code> is <code>false</code> and the underlying\n     *           file system does not implement an execute permission, then the\n     *           operation will fail.\n     *\n     * @throws  SecurityException\n     *          If a security manager exists and its <code>{@link\n     *          java.lang.SecurityManager#checkWrite(java.lang.String)}</code>\n     *          method denies write access to the file\n     *\n     * @since 1.6\n     ",
    "links" : [ "java.lang.SecurityManager#checkWrite(java.lang.String)" ]
  }, {
    "name" : "public boolean canExecute()",
    "returnType" : "boolean",
    "comment" : "\n     * Tests whether the application can execute the file denoted by this\n     * abstract pathname.\n     *\n     * @return  <code>true</code> if and only if the abstract pathname exists\n     *          <em>and</em> the application is allowed to execute the file\n     *\n     * @throws  SecurityException\n     *          If a security manager exists and its <code>{@link\n     *          java.lang.SecurityManager#checkExec(java.lang.String)}</code>\n     *          method denies execute access to the file\n     *\n     * @since 1.6\n     ",
    "links" : [ "java.lang.SecurityManager#checkExec(java.lang.String)" ]
  }, {
    "name" : "public static File[] listRoots()",
    "returnType" : "File[]",
    "comment" : "\n     * Returns the file system roots. On Android and other Unix systems, there is\n     * a single root, {@code /}.\n     ",
    "links" : [ ]
  }, {
    "name" : "public long getTotalSpace()",
    "returnType" : "long",
    "comment" : "\n     * Returns the size of the partition <a href=\"#partName\">named</a> by this\n     * abstract pathname.\n     *\n     * @return  The size, in bytes, of the partition or <tt>0L</tt> if this\n     *          abstract pathname does not name a partition\n     *\n     * @throws  SecurityException\n     *          If a security manager has been installed and it denies\n     *          {@link RuntimePermission}<tt>(\"getFileSystemAttributes\")</tt>\n     *          or its {@link SecurityManager#checkRead(String)} method denies\n     *          read access to the file named by this abstract pathname\n     *\n     * @since  1.6\n     ",
    "links" : [ "#checkRead(String)", "RuntimePermission" ]
  }, {
    "name" : "public long getFreeSpace()",
    "returnType" : "long",
    "comment" : "\n     * Returns the number of unallocated bytes in the partition <a\n     * href=\"#partName\">named</a> by this abstract path name.\n     *\n     * <p> The returned number of unallocated bytes is a hint, but not\n     * a guarantee, that it is possible to use most or any of these\n     * bytes.  The number of unallocated bytes is most likely to be\n     * accurate immediately after this call.  It is likely to be made\n     * inaccurate by any external I/O operations including those made\n     * on the system outside of this virtual machine.  This method\n     * makes no guarantee that write operations to this file system\n     * will succeed.\n     *\n     * @return  The number of unallocated bytes on the partition or <tt>0L</tt>\n     *          if the abstract pathname does not name a partition.  This\n     *          value will be less than or equal to the total file system size\n     *          returned by {@link #getTotalSpace}.\n     *\n     * @throws  SecurityException\n     *          If a security manager has been installed and it denies\n     *          {@link RuntimePermission}<tt>(\"getFileSystemAttributes\")</tt>\n     *          or its {@link SecurityManager#checkRead(String)} method denies\n     *          read access to the file named by this abstract pathname\n     *\n     * @since  1.6\n     ",
    "links" : [ "#checkRead(String)", "#getTotalSpace", "RuntimePermission" ]
  }, {
    "name" : "public long getUsableSpace()",
    "returnType" : "long",
    "comment" : "\n     * Returns the number of bytes available to this virtual machine on the\n     * partition <a href=\"#partName\">named</a> by this abstract pathname.  When\n     * possible, this method checks for write permissions and other operating\n     * system restrictions and will therefore usually provide a more accurate\n     * estimate of how much new data can actually be written than {@link\n     * #getFreeSpace}.\n     *\n     * <p> The returned number of available bytes is a hint, but not a\n     * guarantee, that it is possible to use most or any of these bytes.  The\n     * number of unallocated bytes is most likely to be accurate immediately\n     * after this call.  It is likely to be made inaccurate by any external\n     * I/O operations including those made on the system outside of this\n     * virtual machine.  This method makes no guarantee that write operations\n     * to this file system will succeed.\n     *\n     * <p> On Android (and other Unix-based systems), this method returns the number of free bytes\n     * available to non-root users, regardless of whether you're actually running as root,\n     * and regardless of any quota or other restrictions that might apply to the user.\n     * (The {@code getFreeSpace} method returns the number of bytes potentially available to root.)\n     *\n     * @return  The number of available bytes on the partition or <tt>0L</tt>\n     *          if the abstract pathname does not name a partition.  On\n     *          systems where this information is not available, this method\n     *          will be equivalent to a call to {@link #getFreeSpace}.\n     *\n     * @throws  SecurityException\n     *          If a security manager has been installed and it denies\n     *          {@link RuntimePermission}<tt>(\"getFileSystemAttributes\")</tt>\n     *          or its {@link SecurityManager#checkRead(String)} method denies\n     *          read access to the file named by this abstract pathname\n     *\n     * @since  1.6\n     ",
    "links" : [ "#getFreeSpace", "#checkRead(String)", "RuntimePermission" ]
  }, {
    "name" : "public static File createTempFile(String prefix, String suffix, File directory) throws IOException",
    "returnType" : "File",
    "comment" : "\n     * <p> Creates a new empty file in the specified directory, using the\n     * given prefix and suffix strings to generate its name.  If this method\n     * returns successfully then it is guaranteed that:\n     *\n     * <ol>\n     * <li> The file denoted by the returned abstract pathname did not exist\n     *      before this method was invoked, and\n     * <li> Neither this method nor any of its variants will return the same\n     *      abstract pathname again in the current invocation of the virtual\n     *      machine.\n     * </ol>\n     *\n     * This method provides only part of a temporary-file facility.  To arrange\n     * for a file created by this method to be deleted automatically, use the\n     * <code>{@link #deleteOnExit}</code> method.\n     *\n     * <p> The <code>prefix</code> argument must be at least three characters\n     * long.  It is recommended that the prefix be a short, meaningful string\n     * such as <code>\"hjb\"</code> or <code>\"mail\"</code>.  The\n     * <code>suffix</code> argument may be <code>null</code>, in which case the\n     * suffix <code>\".tmp\"</code> will be used.\n     *\n     * <p> To create the new file, the prefix and the suffix may first be\n     * adjusted to fit the limitations of the underlying platform.  If the\n     * prefix is too long then it will be truncated, but its first three\n     * characters will always be preserved.  If the suffix is too long then it\n     * too will be truncated, but if it begins with a period character\n     * (<code>'.'</code>) then the period and the first three characters\n     * following it will always be preserved.  Once these adjustments have been\n     * made the name of the new file will be generated by concatenating the\n     * prefix, five or more internally-generated characters, and the suffix.\n     *\n     * <p> If the <code>directory</code> argument is <code>null</code> then the\n     * system-dependent default temporary-file directory will be used.  The\n     * default temporary-file directory is specified by the system property\n     * <code>java.io.tmpdir</code>.  On UNIX systems the default value of this\n     * property is typically <code>\"/tmp\"</code> or <code>\"/var/tmp\"</code>; on\n     * Microsoft Windows systems it is typically <code>\"C:\\\\WINNT\\\\TEMP\"</code>.  A different\n     * value may be given to this system property when the Java virtual machine\n     * is invoked, but programmatic changes to this property are not guaranteed\n     * to have any effect upon the temporary directory used by this method.\n     *\n     * @param  prefix     The prefix string to be used in generating the file's\n     *                    name; must be at least three characters long\n     *\n     * @param  suffix     The suffix string to be used in generating the file's\n     *                    name; may be <code>null</code>, in which case the\n     *                    suffix <code>\".tmp\"</code> will be used\n     *\n     * @param  directory  The directory in which the file is to be created, or\n     *                    <code>null</code> if the default temporary-file\n     *                    directory is to be used\n     *\n     * @return  An abstract pathname denoting a newly-created empty file\n     *\n     * @throws  IllegalArgumentException\n     *          If the <code>prefix</code> argument contains fewer than three\n     *          characters\n     *\n     * @throws  IOException  If a file could not be created\n     *\n     * @throws  SecurityException\n     *          If a security manager exists and its <code>{@link\n     *          java.lang.SecurityManager#checkWrite(java.lang.String)}</code>\n     *          method does not allow a file to be created\n     *\n     * @since 1.2\n     ",
    "links" : [ "java.lang.SecurityManager#checkWrite(java.lang.String)", "#deleteOnExit" ]
  }, {
    "name" : "public static File createTempFile(String prefix, String suffix) throws IOException",
    "returnType" : "File",
    "comment" : "\n     * Creates an empty file in the default temporary-file directory, using\n     * the given prefix and suffix to generate its name. Invoking this method\n     * is equivalent to invoking <code>{@link #createTempFile(java.lang.String,\n     * java.lang.String, java.io.File)\n     * createTempFile(prefix,&nbsp;suffix,&nbsp;null)}</code>.\n     *\n     * <p> The {@link\n     * java.nio.file.Files#createTempFile(String,String,java.nio.file.attribute.FileAttribute[])\n     * Files.createTempFile} method provides an alternative method to create an\n     * empty file in the temporary-file directory. Files created by that method\n     * may have more restrictive access permissions to files created by this\n     * method and so may be more suited to security-sensitive applications.\n     *\n     * @param  prefix     The prefix string to be used in generating the file's\n     *                    name; must be at least three characters long\n     *\n     * @param  suffix     The suffix string to be used in generating the file's\n     *                    name; may be <code>null</code>, in which case the\n     *                    suffix <code>\".tmp\"</code> will be used\n     *\n     * @return  An abstract pathname denoting a newly-created empty file\n     *\n     * @throws  IllegalArgumentException\n     *          If the <code>prefix</code> argument contains fewer than three\n     *          characters\n     *\n     * @throws  IOException  If a file could not be created\n     *\n     * @throws  SecurityException\n     *          If a security manager exists and its <code>{@link\n     *          java.lang.SecurityManager#checkWrite(java.lang.String)}</code>\n     *          method does not allow a file to be created\n     *\n     * @since 1.2\n     * @see java.nio.file.Files#createTempDirectory(String,FileAttribute[])\n     ",
    "links" : [ "java.lang.SecurityManager#checkWrite(java.lang.String)", "#createTempFile(java.lang.String", "java.nio.file.Files#createTempFile(String" ]
  }, {
    "name" : "public int compareTo(File pathname)",
    "returnType" : "int",
    "comment" : "\n     * Compares two abstract pathnames lexicographically.  The ordering\n     * defined by this method depends upon the underlying system.  On UNIX\n     * systems, alphabetic case is significant in comparing pathnames; on Microsoft Windows\n     * systems it is not.\n     *\n     * @param   pathname  The abstract pathname to be compared to this abstract\n     *                    pathname\n     *\n     * @return  Zero if the argument is equal to this abstract pathname, a\n     *          value less than zero if this abstract pathname is\n     *          lexicographically less than the argument, or a value greater\n     *          than zero if this abstract pathname is lexicographically\n     *          greater than the argument\n     *\n     * @since   1.2\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean equals(Object obj)",
    "returnType" : "boolean",
    "comment" : "\n     * Tests this abstract pathname for equality with the given object.\n     * Returns <code>true</code> if and only if the argument is not\n     * <code>null</code> and is an abstract pathname that denotes the same file\n     * or directory as this abstract pathname.  Whether or not two abstract\n     * pathnames are equal depends upon the underlying system.  On UNIX\n     * systems, alphabetic case is significant in comparing pathnames; on Microsoft Windows\n     * systems it is not.\n     *\n     * @param   obj   The object to be compared with this abstract pathname\n     *\n     * @return  <code>true</code> if and only if the objects are the same;\n     *          <code>false</code> otherwise\n     ",
    "links" : [ ]
  }, {
    "name" : "public int hashCode()",
    "returnType" : "int",
    "comment" : "\n     * Computes a hash code for this abstract pathname.  Because equality of\n     * abstract pathnames is inherently system-dependent, so is the computation\n     * of their hash codes.  On UNIX systems, the hash code of an abstract\n     * pathname is equal to the exclusive <em>or</em> of the hash code\n     * of its pathname string and the decimal value\n     * <code>1234321</code>.  On Microsoft Windows systems, the hash\n     * code is equal to the exclusive <em>or</em> of the hash code of\n     * its pathname string converted to lower case and the decimal\n     * value <code>1234321</code>.  Locale is not taken into account on\n     * lowercasing the pathname string.\n     *\n     * @return  A hash code for this abstract pathname\n     ",
    "links" : [ ]
  }, {
    "name" : "public String toString()",
    "returnType" : "String",
    "comment" : "\n     * Returns the pathname string of this abstract pathname.  This is just the\n     * string returned by the <code>{@link #getPath}</code> method.\n     *\n     * @return  The string form of this abstract pathname\n     ",
    "links" : [ "#getPath" ]
  }, {
    "name" : "private synchronized void writeObject(java.io.ObjectOutputStream s) throws IOException",
    "returnType" : "void",
    "comment" : "\n     * WriteObject is called to save this filename.\n     * The separator character is saved also so it can be replaced\n     * in case the path is reconstituted on a different host type.\n     * <p>\n     * @serialData  Default fields followed by separator character.\n     ",
    "links" : [ ]
  }, {
    "name" : "private synchronized void readObject(java.io.ObjectInputStream s) throws IOException, ClassNotFoundException",
    "returnType" : "void",
    "comment" : "\n     * readObject is called to restore this filename.\n     * The original separator character is read.  If it is different\n     * than the separator character on this system, then the old separator\n     * is replaced by the local separator.\n     ",
    "links" : [ ]
  }, {
    "name" : "public Path toPath()",
    "returnType" : "Path",
    "comment" : "\n     * Returns a {@link Path java.nio.file.Path} object constructed from the\n     * this abstract path. The resulting {@code Path} is associated with the\n     * {@link java.nio.file.FileSystems#getDefault default-filesystem}.\n     *\n     * <p> The first invocation of this method works as if invoking it were\n     * equivalent to evaluating the expression:\n     * <blockquote><pre>\n     * {@link java.nio.file.FileSystems#getDefault FileSystems.getDefault}().{@link\n     * java.nio.file.FileSystem#getPath getPath}(this.{@link #getPath getPath}());\n     * </pre></blockquote>\n     * Subsequent invocations of this method return the same {@code Path}.\n     *\n     * <p> If this abstract pathname is the empty abstract pathname then this\n     * method returns a {@code Path} that may be used to access the current\n     * user directory.\n     *\n     * @return  a {@code Path} constructed from this abstract path\n     *\n     * @throws  java.nio.file.InvalidPathException\n     *          if a {@code Path} object cannot be constructed from the abstract\n     *          path (see {@link java.nio.file.FileSystem#getPath FileSystem.getPath})\n     *\n     * @since   1.7\n     * @see Path#toFile\n     ",
    "links" : [ "java.nio.file.FileSystems#getDefault", "java.nio.file.FileSystem#getPath", "#getPath", "java.nio.file.Path" ]
  } ],
  "methodNames" : [ " final boolean isInvalid()", " int getPrefixLength()", "public String getName()", "public String getParent()", "public File getParentFile()", "public String getPath()", "public boolean isAbsolute()", "public String getAbsolutePath()", "public File getAbsoluteFile()", "public String getCanonicalPath() throws IOException", "public File getCanonicalFile() throws IOException", "private static String slashify(String path, boolean isDirectory)", "public URL toURL() throws MalformedURLException", "public URI toURI()", "public boolean canRead()", "public boolean canWrite()", "public boolean exists()", "public boolean isDirectory()", "public boolean isFile()", "public boolean isHidden()", "public long lastModified()", "public long length()", "public boolean createNewFile() throws IOException", "public boolean delete()", "public void deleteOnExit()", "public String[] list()", "public String[] list(FilenameFilter filter)", "public File[] listFiles()", "public File[] listFiles(FilenameFilter filter)", "public File[] listFiles(FileFilter filter)", "public boolean mkdir()", "public boolean mkdirs()", "public boolean renameTo(File dest)", "public boolean setLastModified(long time)", "public boolean setReadOnly()", "public boolean setWritable(boolean writable, boolean ownerOnly)", "public boolean setWritable(boolean writable)", "public boolean setReadable(boolean readable, boolean ownerOnly)", "public boolean setReadable(boolean readable)", "public boolean setExecutable(boolean executable, boolean ownerOnly)", "public boolean setExecutable(boolean executable)", "public boolean canExecute()", "public static File[] listRoots()", "public long getTotalSpace()", "public long getFreeSpace()", "public long getUsableSpace()", "public static File createTempFile(String prefix, String suffix, File directory) throws IOException", "public static File createTempFile(String prefix, String suffix) throws IOException", "public int compareTo(File pathname)", "public boolean equals(Object obj)", "public int hashCode()", "public String toString()", "private synchronized void writeObject(java.io.ObjectOutputStream s) throws IOException", "private synchronized void readObject(java.io.ObjectInputStream s) throws IOException, ClassNotFoundException", "public Path toPath()" ],
  "variableNames" : [ "fs", "path", "status", "prefixLength", "separatorChar", "separator", "pathSeparatorChar", "pathSeparator", "CANONICALIZE_PARENT_OF_ROOT_DIR", "PATH_OFFSET", "PREFIX_LENGTH_OFFSET", "UNSAFE", "serialVersionUID", "filePath" ]
}