{
  "filePath" : "/home/maryam/clearblue/files/android-source-35/java/util/logging/Logger.java",
  "packageName" : "java.util.logging",
  "className" : "Logger",
  "comment" : "\n * A Logger object is used to log messages for a specific\n * system or application component.  Loggers are normally named,\n * using a hierarchical dot-separated namespace.  Logger names\n * can be arbitrary strings, but they should normally be based on\n * the package name or class name of the logged component, such\n * as java.net or javax.swing.  In addition it is possible to create\n * \"anonymous\" Loggers that are not stored in the Logger namespace.\n * <p>\n * Logger objects may be obtained by calls on one of the getLogger\n * factory methods.  These will either create a new Logger or\n * return a suitable existing Logger. It is important to note that\n * the Logger returned by one of the {@code getLogger} factory methods\n * may be garbage collected at any time if a strong reference to the\n * Logger is not kept.\n * <p>\n * Logging messages will be forwarded to registered Handler\n * objects, which can forward the messages to a variety of\n * destinations, including consoles, files, OS logs, etc.\n * <p>\n * Each Logger keeps track of a \"parent\" Logger, which is its\n * nearest existing ancestor in the Logger namespace.\n * <p>\n * Each Logger has a \"Level\" associated with it.  This reflects\n * a minimum Level that this logger cares about.  If a Logger's\n * level is set to <tt>null</tt>, then its effective level is inherited\n * from its parent, which may in turn obtain it recursively from its\n * parent, and so on up the tree.\n * <p>\n * The log level can be configured based on the properties from the\n * logging configuration file, as described in the description\n * of the LogManager class.  However it may also be dynamically changed\n * by calls on the Logger.setLevel method.  If a logger's level is\n * changed the change may also affect child loggers, since any child\n * logger that has <tt>null</tt> as its level will inherit its\n * effective level from its parent.\n * <p>\n * On each logging call the Logger initially performs a cheap\n * check of the request level (e.g., SEVERE or FINE) against the\n * effective log level of the logger.  If the request level is\n * lower than the log level, the logging call returns immediately.\n * <p>\n * After passing this initial (cheap) test, the Logger will allocate\n * a LogRecord to describe the logging message.  It will then call a\n * Filter (if present) to do a more detailed check on whether the\n * record should be published.  If that passes it will then publish\n * the LogRecord to its output Handlers.  By default, loggers also\n * publish to their parent's Handlers, recursively up the tree.\n * <p>\n * Each Logger may have a {@code ResourceBundle} associated with it.\n * The {@code ResourceBundle} may be specified by name, using the\n * {@link #getLogger(java.lang.String, java.lang.String)} factory\n * method, or by value - using the {@link\n * #setResourceBundle(java.util.ResourceBundle) setResourceBundle} method.\n * This bundle will be used for localizing logging messages.\n * If a Logger does not have its own {@code ResourceBundle} or resource bundle\n * name, then it will inherit the {@code ResourceBundle} or resource bundle name\n * from its parent, recursively up the tree.\n * <p>\n * Most of the logger output methods take a \"msg\" argument.  This\n * msg argument may be either a raw value or a localization key.\n * During formatting, if the logger has (or inherits) a localization\n * {@code ResourceBundle} and if the {@code ResourceBundle} has a mapping for\n * the msg string, then the msg string is replaced by the localized value.\n * Otherwise the original msg string is used.  Typically, formatters use\n * java.text.MessageFormat style formatting to format parameters, so\n * for example a format string \"{0} {1}\" would format two parameters\n * as strings.\n * <p>\n * A set of methods alternatively take a \"msgSupplier\" instead of a \"msg\"\n * argument.  These methods take a {@link Supplier}{@code <String>} function\n * which is invoked to construct the desired log message only when the message\n * actually is to be logged based on the effective log level thus eliminating\n * unnecessary message construction. For example, if the developer wants to\n * log system health status for diagnosis, with the String-accepting version,\n * the code would look like:\n <pre><code>\n\n   class DiagnosisMessages {\n     static String systemHealthStatus() {\n       // collect system health information\n       ...\n     }\n   }\n   ...\n   logger.log(Level.FINER, DiagnosisMessages.systemHealthStatus());\n</code></pre>\n * With the above code, the health status is collected unnecessarily even when\n * the log level FINER is disabled. With the Supplier-accepting version as\n * below, the status will only be collected when the log level FINER is\n * enabled.\n <pre><code>\n\n   logger.log(Level.FINER, DiagnosisMessages::systemHealthStatus);\n</code></pre>\n * <p>\n * When looking for a {@code ResourceBundle}, the logger will first look at\n * whether a bundle was specified using {@link\n * #setResourceBundle(java.util.ResourceBundle) setResourceBundle}, and then\n * only whether a resource bundle name was specified through the {@link\n * #getLogger(java.lang.String, java.lang.String) getLogger} factory method.\n * If no {@code ResourceBundle} or no resource bundle name is found,\n * then it will use the nearest {@code ResourceBundle} or resource bundle\n * name inherited from its parent tree.<br>\n * When a {@code ResourceBundle} was inherited or specified through the\n * {@link\n * #setResourceBundle(java.util.ResourceBundle) setResourceBundle} method, then\n * that {@code ResourceBundle} will be used. Otherwise if the logger only\n * has or inherited a resource bundle name, then that resource bundle name\n * will be mapped to a {@code ResourceBundle} object, using the default Locale\n * at the time of logging.\n * <br id=\"ResourceBundleMapping\">When mapping resource bundle names to\n * {@code ResourceBundle} objects, the logger will first try to use the\n * Thread's {@linkplain java.lang.Thread#getContextClassLoader() context class\n * loader} to map the given resource bundle name to a {@code ResourceBundle}.\n * If the thread context class loader is {@code null}, it will try the\n * {@linkplain java.lang.ClassLoader#getSystemClassLoader() system class loader}\n * instead.  If the {@code ResourceBundle} is still not found, it will use the\n * class loader of the first caller of the {@link\n * #getLogger(java.lang.String, java.lang.String) getLogger} factory method.\n * <p>\n * Formatting (including localization) is the responsibility of\n * the output Handler, which will typically call a Formatter.\n * <p>\n * Note that formatting need not occur synchronously.  It may be delayed\n * until a LogRecord is actually written to an external sink.\n * <p>\n * The logging methods are grouped in five main categories:\n * <ul>\n * <li><p>\n *     There are a set of \"log\" methods that take a log level, a message\n *     string, and optionally some parameters to the message string.\n * <li><p>\n *     There are a set of \"logp\" methods (for \"log precise\") that are\n *     like the \"log\" methods, but also take an explicit source class name\n *     and method name.\n * <li><p>\n *     There are a set of \"logrb\" method (for \"log with resource bundle\")\n *     that are like the \"logp\" method, but also take an explicit resource\n *     bundle object for use in localizing the log message.\n * <li><p>\n *     There are convenience methods for tracing method entries (the\n *     \"entering\" methods), method returns (the \"exiting\" methods) and\n *     throwing exceptions (the \"throwing\" methods).\n * <li><p>\n *     Finally, there are a set of convenience methods for use in the\n *     very simplest cases, when a developer simply wants to log a\n *     simple string at a given log level.  These methods are named\n *     after the standard Level names (\"severe\", \"warning\", \"info\", etc.)\n *     and take a single argument, a message string.\n * </ul>\n * <p>\n * For the methods that do not take an explicit source name and\n * method name, the Logging framework will make a \"best effort\"\n * to determine which class and method called into the logging method.\n * However, it is important to realize that this automatically inferred\n * information may only be approximate (or may even be quite wrong!).\n * Virtual machines are allowed to do extensive optimizations when\n * JITing and may entirely remove stack frames, making it impossible\n * to reliably locate the calling class and method.\n * <P>\n * All methods on Logger are multi-thread safe.\n * <p>\n * <b>Subclassing Information:</b> Note that a LogManager class may\n * provide its own implementation of named Loggers for any point in\n * the namespace.  Therefore, any subclasses of Logger (unless they\n * are implemented in conjunction with a new LogManager class) should\n * take care to obtain a Logger instance from the LogManager class and\n * should delegate operations such as \"isLoggable\" and \"log(LogRecord)\"\n * to that instance.  Note that in order to intercept all logging\n * output, subclasses need only override the log(LogRecord) method.\n * All the other logging methods are implemented as calls on this\n * log(LogRecord) method.\n *\n * @since 1.4\n ",
  "links" : [ "#getLogger(java.lang.String", "#setResourceBundle(java.util.ResourceBundle)", "java.util.function.Supplier" ],
  "variables" : [ {
    "name" : "emptyHandlers",
    "type" : "Handler[]",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "offValue",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "SYSTEM_LOGGER_RB_NAME",
    "type" : "String",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "SYSTEM_BUNDLE",
    "type" : "LoggerBundle",
    "comment" : " code",
    "links" : [ ]
  }, {
    "name" : "NO_RESOURCE_BUNDLE",
    "type" : "LoggerBundle",
    "comment" : " and it will be shared by all loggers which have no resource bundle.",
    "links" : [ ]
  }, {
    "name" : "manager",
    "type" : "LogManager",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "name",
    "type" : "String",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "handlers",
    "type" : "CopyOnWriteArrayList<Handler>",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "loggerBundle",
    "type" : "LoggerBundle",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "useParentHandlers",
    "type" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "filter",
    "type" : "Filter",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "anonymous",
    "type" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "catalog",
    "type" : "ResourceBundle",
    "comment" : " Cached resource bundle",
    "links" : [ ]
  }, {
    "name" : "catalogName",
    "type" : "String",
    "comment" : " name associated with catalog",
    "links" : [ ]
  }, {
    "name" : "catalogLocale",
    "type" : "Locale",
    "comment" : " locale associated with catalog",
    "links" : [ ]
  }, {
    "name" : "treeLock",
    "type" : "Object",
    "comment" : " are managed under a separate lock, the treeLock.",
    "links" : [ ]
  }, {
    "name" : "parent",
    "type" : "Logger",
    "comment" : " our nearest parent.",
    "links" : [ ]
  }, {
    "name" : "kids",
    "type" : "ArrayList<LogManager.LoggerWeakRef>",
    "comment" : " WeakReferences to loggers that have us as parent",
    "links" : [ ]
  }, {
    "name" : "levelObject",
    "type" : "Level",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "levelValue",
    "type" : "int",
    "comment" : " current effective level value",
    "links" : [ ]
  }, {
    "name" : "callersClassLoaderRef",
    "type" : "WeakReference<ClassLoader>",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "isSystemLogger",
    "type" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "GLOBAL_LOGGER_NAME",
    "type" : "String",
    "comment" : "\n     * GLOBAL_LOGGER_NAME is a name for the global logger.\n     *\n     * @since 1.6\n     ",
    "links" : [ ]
  }, {
    "name" : "global",
    "type" : "Logger",
    "comment" : "\n     * The \"global\" Logger object is provided as a convenience to developers\n     * who are making casual use of the Logging package.  Developers\n     * who are making serious use of the logging package (for example\n     * in products) should create and use their own Logger objects,\n     * with appropriate names, so that logging can be controlled on a\n     * suitable per-Logger granularity. Developers also need to keep a\n     * strong reference to their Logger objects to prevent them from\n     * being garbage collected.\n     * <p>\n     * @deprecated Initialization of this field is prone to deadlocks.\n     * The field must be initialized by the Logger class initialization\n     * which may cause deadlocks with the LogManager class initialization.\n     * In such cases two class initialization wait for each other to complete.\n     * The preferred way to get the global logger object is via the call\n     * <code>Logger.getGlobal()</code>.\n     * For compatibility with old JDK versions where the\n     * <code>Logger.getGlobal()</code> is not available use the call\n     * <code>Logger.getLogger(Logger.GLOBAL_LOGGER_NAME)</code>\n     * or <code>Logger.getLogger(\"global\")</code>.\n     ",
    "links" : [ ]
  } ],
  "methods" : [ {
    "name" : "public static final Logger getGlobal()",
    "returnType" : "Logger",
    "comment" : "\n     * Return global logger object with the name Logger.GLOBAL_LOGGER_NAME.\n     *\n     * @return global logger object\n     * @since 1.7\n     ",
    "links" : [ ]
  }, {
    "name" : "private void setCallersClassLoaderRef(Class<?> caller)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private ClassLoader getCallersClassLoader()",
    "returnType" : "ClassLoader",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : " void setLogManager(LogManager manager)",
    "returnType" : "void",
    "comment" : " is actually added to a LogManager.",
    "links" : [ ]
  }, {
    "name" : "private void checkPermission() throws SecurityException",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private static Logger demandLogger(String name, String resourceBundleName, Class<?> caller)",
    "returnType" : "Logger",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public static Logger getLogger(String name)",
    "returnType" : "Logger",
    "comment" : " adding a new Logger object is handled by LogManager.addLogger().",
    "links" : [ ]
  }, {
    "name" : "public static Logger getLogger(String name, String resourceBundleName)",
    "returnType" : "Logger",
    "comment" : " adding a new Logger object is handled by LogManager.addLogger().",
    "links" : [ ]
  }, {
    "name" : " static Logger getPlatformLogger(String name)",
    "returnType" : "Logger",
    "comment" : " i.e. caller of sun.util.logging.PlatformLogger.getLogger",
    "links" : [ ]
  }, {
    "name" : "public static Logger getAnonymousLogger()",
    "returnType" : "Logger",
    "comment" : "\n     * Create an anonymous Logger.  The newly created Logger is not\n     * registered in the LogManager namespace.  There will be no\n     * access checks on updates to the logger.\n     * <p>\n     * This factory method is primarily intended for use from applets.\n     * Because the resulting Logger is anonymous it can be kept private\n     * by the creating class.  This removes the need for normal security\n     * checks, which in turn allows untrusted applet code to update\n     * the control state of the Logger.  For example an applet can do\n     * a setLevel or an addHandler on an anonymous Logger.\n     * <p>\n     * Even although the new logger is anonymous, it is configured\n     * to have the root logger (\"\") as its parent.  This means that\n     * by default it inherits its effective level and handlers\n     * from the root logger. Changing its parent via the\n     * {@link #setParent(java.util.logging.Logger) setParent} method\n     * will still require the security permission specified by that method.\n     * <p>\n     *\n     * @return a newly created private Logger\n     ",
    "links" : [ "#setParent(java.util.logging.Logger)" ]
  }, {
    "name" : "public static Logger getAnonymousLogger(String resourceBundleName)",
    "returnType" : "Logger",
    "comment" : " adding a new anonymous Logger object is handled by doSetParent().",
    "links" : [ ]
  }, {
    "name" : "public ResourceBundle getResourceBundle()",
    "returnType" : "ResourceBundle",
    "comment" : "\n     * Retrieve the localization resource bundle for this\n     * logger.\n     * This method will return a {@code ResourceBundle} that was either\n     * set by the {@link\n     * #setResourceBundle(java.util.ResourceBundle) setResourceBundle} method or\n     * <a href=\"#ResourceBundleMapping\">mapped from the\n     * the resource bundle name</a> set via the {@link\n     * Logger#getLogger(java.lang.String, java.lang.String) getLogger} factory\n     * method for the current default locale.\n     * <br>Note that if the result is {@code null}, then the Logger will use a resource\n     * bundle or resource bundle name inherited from its parent.\n     *\n     * @return localization bundle (may be {@code null})\n     ",
    "links" : [ "java.util.logging.Logger#getLogger(java.lang.String", "#setResourceBundle(java.util.ResourceBundle)" ]
  }, {
    "name" : "public String getResourceBundleName()",
    "returnType" : "String",
    "comment" : "\n     * Retrieve the localization resource bundle name for this\n     * logger.\n     * This is either the name specified through the {@link\n     * #getLogger(java.lang.String, java.lang.String) getLogger} factory method,\n     * or the {@linkplain ResourceBundle#getBaseBundleName() base name} of the\n     * ResourceBundle set through {@link\n     * #setResourceBundle(java.util.ResourceBundle) setResourceBundle} method.\n     * <br>Note that if the result is {@code null}, then the Logger will use a resource\n     * bundle or resource bundle name inherited from its parent.\n     *\n     * @return localization bundle name (may be {@code null})\n     ",
    "links" : [ "#getLogger(java.lang.String", "#setResourceBundle(java.util.ResourceBundle)" ]
  }, {
    "name" : "public void setFilter(Filter newFilter) throws SecurityException",
    "returnType" : "void",
    "comment" : "\n     * Set a filter to control output on this Logger.\n     * <P>\n     * After passing the initial \"level\" check, the Logger will\n     * call this Filter to check if a log record should really\n     * be published.\n     *\n     * @param   newFilter  a filter object (may be null)\n     * @throws  SecurityException if a security manager exists,\n     *          this logger is not anonymous, and the caller\n     *          does not have LoggingPermission(\"control\").\n     ",
    "links" : [ ]
  }, {
    "name" : "public Filter getFilter()",
    "returnType" : "Filter",
    "comment" : "\n     * Get the current filter for this Logger.\n     *\n     * @return  a filter object (may be null)\n     ",
    "links" : [ ]
  }, {
    "name" : "public void log(LogRecord record)",
    "returnType" : "void",
    "comment" : "\n     * Log a LogRecord.\n     * <p>\n     * All the other logging methods in this class call through\n     * this method to actually perform any logging.  Subclasses can\n     * override this single method to capture all log activity.\n     *\n     * @param record the LogRecord to be published\n     ",
    "links" : [ ]
  }, {
    "name" : "private void doLog(LogRecord lr)",
    "returnType" : "void",
    "comment" : " resource bundle and then call \"void log(LogRecord)\".",
    "links" : [ ]
  }, {
    "name" : "public void log(Level level, String msg)",
    "returnType" : "void",
    "comment" : "\n     * Log a message, with no arguments.\n     * <p>\n     * If the logger is currently enabled for the given message\n     * level then the given message is forwarded to all the\n     * registered output Handler objects.\n     * <p>\n     * @param   level   One of the message level identifiers, e.g., SEVERE\n     * @param   msg     The string message (or a key in the message catalog)\n     ",
    "links" : [ ]
  }, {
    "name" : "public void log(Level level, Supplier<String> msgSupplier)",
    "returnType" : "void",
    "comment" : "\n     * Log a message, which is only to be constructed if the logging level\n     * is such that the message will actually be logged.\n     * <p>\n     * If the logger is currently enabled for the given message\n     * level then the message is constructed by invoking the provided\n     * supplier function and forwarded to all the registered output\n     * Handler objects.\n     * <p>\n     * @param   level   One of the message level identifiers, e.g., SEVERE\n     * @param   msgSupplier   A function, which when called, produces the\n     *                        desired log message\n     * @since 1.8\n     ",
    "links" : [ ]
  }, {
    "name" : "public void log(Level level, String msg, Object param1)",
    "returnType" : "void",
    "comment" : "\n     * Log a message, with one object parameter.\n     * <p>\n     * If the logger is currently enabled for the given message\n     * level then a corresponding LogRecord is created and forwarded\n     * to all the registered output Handler objects.\n     * <p>\n     * @param   level   One of the message level identifiers, e.g., SEVERE\n     * @param   msg     The string message (or a key in the message catalog)\n     * @param   param1  parameter to the message\n     ",
    "links" : [ ]
  }, {
    "name" : "public void log(Level level, String msg, Object[] params)",
    "returnType" : "void",
    "comment" : "\n     * Log a message, with an array of object arguments.\n     * <p>\n     * If the logger is currently enabled for the given message\n     * level then a corresponding LogRecord is created and forwarded\n     * to all the registered output Handler objects.\n     * <p>\n     * @param   level   One of the message level identifiers, e.g., SEVERE\n     * @param   msg     The string message (or a key in the message catalog)\n     * @param   params  array of parameters to the message\n     ",
    "links" : [ ]
  }, {
    "name" : "public void log(Level level, String msg, Throwable thrown)",
    "returnType" : "void",
    "comment" : "\n     * Log a message, with associated Throwable information.\n     * <p>\n     * If the logger is currently enabled for the given message\n     * level then the given arguments are stored in a LogRecord\n     * which is forwarded to all registered output handlers.\n     * <p>\n     * Note that the thrown argument is stored in the LogRecord thrown\n     * property, rather than the LogRecord parameters property.  Thus it is\n     * processed specially by output Formatters and is not treated\n     * as a formatting parameter to the LogRecord message property.\n     * <p>\n     * @param   level   One of the message level identifiers, e.g., SEVERE\n     * @param   msg     The string message (or a key in the message catalog)\n     * @param   thrown  Throwable associated with log message.\n     ",
    "links" : [ ]
  }, {
    "name" : "public void log(Level level, Throwable thrown, Supplier<String> msgSupplier)",
    "returnType" : "void",
    "comment" : "\n     * Log a lazily constructed message, with associated Throwable information.\n     * <p>\n     * If the logger is currently enabled for the given message level then the\n     * message is constructed by invoking the provided supplier function. The\n     * message and the given {@link Throwable} are then stored in a {@link\n     * LogRecord} which is forwarded to all registered output handlers.\n     * <p>\n     * Note that the thrown argument is stored in the LogRecord thrown\n     * property, rather than the LogRecord parameters property.  Thus it is\n     * processed specially by output Formatters and is not treated\n     * as a formatting parameter to the LogRecord message property.\n     * <p>\n     * @param   level   One of the message level identifiers, e.g., SEVERE\n     * @param   thrown  Throwable associated with log message.\n     * @param   msgSupplier   A function, which when called, produces the\n     *                        desired log message\n     * @since   1.8\n     ",
    "links" : [ "Throwable", "java.util.logging.LogRecord" ]
  }, {
    "name" : "public void logp(Level level, String sourceClass, String sourceMethod, String msg)",
    "returnType" : "void",
    "comment" : "\n     * Log a message, specifying source class and method,\n     * with no arguments.\n     * <p>\n     * If the logger is currently enabled for the given message\n     * level then the given message is forwarded to all the\n     * registered output Handler objects.\n     * <p>\n     * @param   level   One of the message level identifiers, e.g., SEVERE\n     * @param   sourceClass    name of class that issued the logging request\n     * @param   sourceMethod   name of method that issued the logging request\n     * @param   msg     The string message (or a key in the message catalog)\n     ",
    "links" : [ ]
  }, {
    "name" : "public void logp(Level level, String sourceClass, String sourceMethod, Supplier<String> msgSupplier)",
    "returnType" : "void",
    "comment" : "\n     * Log a lazily constructed message, specifying source class and method,\n     * with no arguments.\n     * <p>\n     * If the logger is currently enabled for the given message\n     * level then the message is constructed by invoking the provided\n     * supplier function and forwarded to all the registered output\n     * Handler objects.\n     * <p>\n     * @param   level   One of the message level identifiers, e.g., SEVERE\n     * @param   sourceClass    name of class that issued the logging request\n     * @param   sourceMethod   name of method that issued the logging request\n     * @param   msgSupplier   A function, which when called, produces the\n     *                        desired log message\n     * @since   1.8\n     ",
    "links" : [ ]
  }, {
    "name" : "public void logp(Level level, String sourceClass, String sourceMethod, String msg, Object param1)",
    "returnType" : "void",
    "comment" : "\n     * Log a message, specifying source class and method,\n     * with a single object parameter to the log message.\n     * <p>\n     * If the logger is currently enabled for the given message\n     * level then a corresponding LogRecord is created and forwarded\n     * to all the registered output Handler objects.\n     * <p>\n     * @param   level   One of the message level identifiers, e.g., SEVERE\n     * @param   sourceClass    name of class that issued the logging request\n     * @param   sourceMethod   name of method that issued the logging request\n     * @param   msg      The string message (or a key in the message catalog)\n     * @param   param1    Parameter to the log message.\n     ",
    "links" : [ ]
  }, {
    "name" : "public void logp(Level level, String sourceClass, String sourceMethod, String msg, Object[] params)",
    "returnType" : "void",
    "comment" : "\n     * Log a message, specifying source class and method,\n     * with an array of object arguments.\n     * <p>\n     * If the logger is currently enabled for the given message\n     * level then a corresponding LogRecord is created and forwarded\n     * to all the registered output Handler objects.\n     * <p>\n     * @param   level   One of the message level identifiers, e.g., SEVERE\n     * @param   sourceClass    name of class that issued the logging request\n     * @param   sourceMethod   name of method that issued the logging request\n     * @param   msg     The string message (or a key in the message catalog)\n     * @param   params  Array of parameters to the message\n     ",
    "links" : [ ]
  }, {
    "name" : "public void logp(Level level, String sourceClass, String sourceMethod, String msg, Throwable thrown)",
    "returnType" : "void",
    "comment" : "\n     * Log a message, specifying source class and method,\n     * with associated Throwable information.\n     * <p>\n     * If the logger is currently enabled for the given message\n     * level then the given arguments are stored in a LogRecord\n     * which is forwarded to all registered output handlers.\n     * <p>\n     * Note that the thrown argument is stored in the LogRecord thrown\n     * property, rather than the LogRecord parameters property.  Thus it is\n     * processed specially by output Formatters and is not treated\n     * as a formatting parameter to the LogRecord message property.\n     * <p>\n     * @param   level   One of the message level identifiers, e.g., SEVERE\n     * @param   sourceClass    name of class that issued the logging request\n     * @param   sourceMethod   name of method that issued the logging request\n     * @param   msg     The string message (or a key in the message catalog)\n     * @param   thrown  Throwable associated with log message.\n     ",
    "links" : [ ]
  }, {
    "name" : "public void logp(Level level, String sourceClass, String sourceMethod, Throwable thrown, Supplier<String> msgSupplier)",
    "returnType" : "void",
    "comment" : "\n     * Log a lazily constructed message, specifying source class and method,\n     * with associated Throwable information.\n     * <p>\n     * If the logger is currently enabled for the given message level then the\n     * message is constructed by invoking the provided supplier function. The\n     * message and the given {@link Throwable} are then stored in a {@link\n     * LogRecord} which is forwarded to all registered output handlers.\n     * <p>\n     * Note that the thrown argument is stored in the LogRecord thrown\n     * property, rather than the LogRecord parameters property.  Thus it is\n     * processed specially by output Formatters and is not treated\n     * as a formatting parameter to the LogRecord message property.\n     * <p>\n     * @param   level   One of the message level identifiers, e.g., SEVERE\n     * @param   sourceClass    name of class that issued the logging request\n     * @param   sourceMethod   name of method that issued the logging request\n     * @param   thrown  Throwable associated with log message.\n     * @param   msgSupplier   A function, which when called, produces the\n     *                        desired log message\n     * @since   1.8\n     ",
    "links" : [ "Throwable", "java.util.logging.LogRecord" ]
  }, {
    "name" : "private void doLog(LogRecord lr, String rbname)",
    "returnType" : "void",
    "comment" : " resource bundle and then call \"void log(LogRecord)\".",
    "links" : [ ]
  }, {
    "name" : "private void doLog(LogRecord lr, ResourceBundle rb)",
    "returnType" : "void",
    "comment" : " Private support method for logging for \"logrb\" methods.",
    "links" : [ ]
  }, {
    "name" : "public void logrb(Level level, String sourceClass, String sourceMethod, String bundleName, String msg)",
    "returnType" : "void",
    "comment" : "\n     * Log a message, specifying source class, method, and resource bundle name\n     * with no arguments.\n     * <p>\n     * If the logger is currently enabled for the given message\n     * level then the given message is forwarded to all the\n     * registered output Handler objects.\n     * <p>\n     * The msg string is localized using the named resource bundle.  If the\n     * resource bundle name is null, or an empty String or invalid\n     * then the msg string is not localized.\n     * <p>\n     * @param   level   One of the message level identifiers, e.g., SEVERE\n     * @param   sourceClass    name of class that issued the logging request\n     * @param   sourceMethod   name of method that issued the logging request\n     * @param   bundleName     name of resource bundle to localize msg,\n     *                         can be null\n     * @param   msg     The string message (or a key in the message catalog)\n     * @deprecated Use {@link #logrb(java.util.logging.Level, java.lang.String,\n     * java.lang.String, java.util.ResourceBundle, java.lang.String,\n     * java.lang.Object...)} instead.\n     ",
    "links" : [ "#logrb(java.util.logging.Level" ]
  }, {
    "name" : "public void logrb(Level level, String sourceClass, String sourceMethod, String bundleName, String msg, Object param1)",
    "returnType" : "void",
    "comment" : "\n     * Log a message, specifying source class, method, and resource bundle name,\n     * with a single object parameter to the log message.\n     * <p>\n     * If the logger is currently enabled for the given message\n     * level then a corresponding LogRecord is created and forwarded\n     * to all the registered output Handler objects.\n     * <p>\n     * The msg string is localized using the named resource bundle.  If the\n     * resource bundle name is null, or an empty String or invalid\n     * then the msg string is not localized.\n     * <p>\n     * @param   level   One of the message level identifiers, e.g., SEVERE\n     * @param   sourceClass    name of class that issued the logging request\n     * @param   sourceMethod   name of method that issued the logging request\n     * @param   bundleName     name of resource bundle to localize msg,\n     *                         can be null\n     * @param   msg      The string message (or a key in the message catalog)\n     * @param   param1    Parameter to the log message.\n     * @deprecated Use {@link #logrb(java.util.logging.Level, java.lang.String,\n     *   java.lang.String, java.util.ResourceBundle, java.lang.String,\n     *   java.lang.Object...)} instead\n     ",
    "links" : [ "#logrb(java.util.logging.Level" ]
  }, {
    "name" : "public void logrb(Level level, String sourceClass, String sourceMethod, String bundleName, String msg, Object[] params)",
    "returnType" : "void",
    "comment" : "\n     * Log a message, specifying source class, method, and resource bundle name,\n     * with an array of object arguments.\n     * <p>\n     * If the logger is currently enabled for the given message\n     * level then a corresponding LogRecord is created and forwarded\n     * to all the registered output Handler objects.\n     * <p>\n     * The msg string is localized using the named resource bundle.  If the\n     * resource bundle name is null, or an empty String or invalid\n     * then the msg string is not localized.\n     * <p>\n     * @param   level   One of the message level identifiers, e.g., SEVERE\n     * @param   sourceClass    name of class that issued the logging request\n     * @param   sourceMethod   name of method that issued the logging request\n     * @param   bundleName     name of resource bundle to localize msg,\n     *                         can be null.\n     * @param   msg     The string message (or a key in the message catalog)\n     * @param   params  Array of parameters to the message\n     * @deprecated Use {@link #logrb(java.util.logging.Level, java.lang.String,\n     *      java.lang.String, java.util.ResourceBundle, java.lang.String,\n     *      java.lang.Object...)} instead.\n     ",
    "links" : [ "#logrb(java.util.logging.Level" ]
  }, {
    "name" : "public void logrb(Level level, String sourceClass, String sourceMethod, ResourceBundle bundle, String msg, Object... params)",
    "returnType" : "void",
    "comment" : "\n     * Log a message, specifying source class, method, and resource bundle,\n     * with an optional list of message parameters.\n     * <p>\n     * If the logger is currently enabled for the given message\n     * level then a corresponding LogRecord is created and forwarded\n     * to all the registered output Handler objects.\n     * <p>\n     * The {@code msg} string is localized using the given resource bundle.\n     * If the resource bundle is {@code null}, then the {@code msg} string is not\n     * localized.\n     * <p>\n     * @param   level   One of the message level identifiers, e.g., SEVERE\n     * @param   sourceClass    Name of the class that issued the logging request\n     * @param   sourceMethod   Name of the method that issued the logging request\n     * @param   bundle         Resource bundle to localize {@code msg},\n     *                         can be {@code null}.\n     * @param   msg     The string message (or a key in the message catalog)\n     * @param   params  Parameters to the message (optional, may be none).\n     * @since 1.8\n     ",
    "links" : [ ]
  }, {
    "name" : "public void logrb(Level level, String sourceClass, String sourceMethod, String bundleName, String msg, Throwable thrown)",
    "returnType" : "void",
    "comment" : "\n     * Log a message, specifying source class, method, and resource bundle name,\n     * with associated Throwable information.\n     * <p>\n     * If the logger is currently enabled for the given message\n     * level then the given arguments are stored in a LogRecord\n     * which is forwarded to all registered output handlers.\n     * <p>\n     * The msg string is localized using the named resource bundle.  If the\n     * resource bundle name is null, or an empty String or invalid\n     * then the msg string is not localized.\n     * <p>\n     * Note that the thrown argument is stored in the LogRecord thrown\n     * property, rather than the LogRecord parameters property.  Thus it is\n     * processed specially by output Formatters and is not treated\n     * as a formatting parameter to the LogRecord message property.\n     * <p>\n     * @param   level   One of the message level identifiers, e.g., SEVERE\n     * @param   sourceClass    name of class that issued the logging request\n     * @param   sourceMethod   name of method that issued the logging request\n     * @param   bundleName     name of resource bundle to localize msg,\n     *                         can be null\n     * @param   msg     The string message (or a key in the message catalog)\n     * @param   thrown  Throwable associated with log message.\n     * @deprecated Use {@link #logrb(java.util.logging.Level, java.lang.String,\n     *     java.lang.String, java.util.ResourceBundle, java.lang.String,\n     *     java.lang.Throwable)} instead.\n     ",
    "links" : [ "#logrb(java.util.logging.Level" ]
  }, {
    "name" : "public void logrb(Level level, String sourceClass, String sourceMethod, ResourceBundle bundle, String msg, Throwable thrown)",
    "returnType" : "void",
    "comment" : "\n     * Log a message, specifying source class, method, and resource bundle,\n     * with associated Throwable information.\n     * <p>\n     * If the logger is currently enabled for the given message\n     * level then the given arguments are stored in a LogRecord\n     * which is forwarded to all registered output handlers.\n     * <p>\n     * The {@code msg} string is localized using the given resource bundle.\n     * If the resource bundle is {@code null}, then the {@code msg} string is not\n     * localized.\n     * <p>\n     * Note that the thrown argument is stored in the LogRecord thrown\n     * property, rather than the LogRecord parameters property.  Thus it is\n     * processed specially by output Formatters and is not treated\n     * as a formatting parameter to the LogRecord message property.\n     * <p>\n     * @param   level   One of the message level identifiers, e.g., SEVERE\n     * @param   sourceClass    Name of the class that issued the logging request\n     * @param   sourceMethod   Name of the method that issued the logging request\n     * @param   bundle         Resource bundle to localize {@code msg},\n     *                         can be {@code null}\n     * @param   msg     The string message (or a key in the message catalog)\n     * @param   thrown  Throwable associated with the log message.\n     * @since 1.8\n     ",
    "links" : [ ]
  }, {
    "name" : "public void entering(String sourceClass, String sourceMethod)",
    "returnType" : "void",
    "comment" : "\n     * Log a method entry.\n     * <p>\n     * This is a convenience method that can be used to log entry\n     * to a method.  A LogRecord with message \"ENTRY\", log level\n     * FINER, and the given sourceMethod and sourceClass is logged.\n     * <p>\n     * @param   sourceClass    name of class that issued the logging request\n     * @param   sourceMethod   name of method that is being entered\n     ",
    "links" : [ ]
  }, {
    "name" : "public void entering(String sourceClass, String sourceMethod, Object param1)",
    "returnType" : "void",
    "comment" : "\n     * Log a method entry, with one parameter.\n     * <p>\n     * This is a convenience method that can be used to log entry\n     * to a method.  A LogRecord with message \"ENTRY {0}\", log level\n     * FINER, and the given sourceMethod, sourceClass, and parameter\n     * is logged.\n     * <p>\n     * @param   sourceClass    name of class that issued the logging request\n     * @param   sourceMethod   name of method that is being entered\n     * @param   param1         parameter to the method being entered\n     ",
    "links" : [ ]
  }, {
    "name" : "public void entering(String sourceClass, String sourceMethod, Object[] params)",
    "returnType" : "void",
    "comment" : "\n     * Log a method entry, with an array of parameters.\n     * <p>\n     * This is a convenience method that can be used to log entry\n     * to a method.  A LogRecord with message \"ENTRY\" (followed by a\n     * format {N} indicator for each entry in the parameter array),\n     * log level FINER, and the given sourceMethod, sourceClass, and\n     * parameters is logged.\n     * <p>\n     * @param   sourceClass    name of class that issued the logging request\n     * @param   sourceMethod   name of method that is being entered\n     * @param   params         array of parameters to the method being entered\n     ",
    "links" : [ ]
  }, {
    "name" : "public void exiting(String sourceClass, String sourceMethod)",
    "returnType" : "void",
    "comment" : "\n     * Log a method return.\n     * <p>\n     * This is a convenience method that can be used to log returning\n     * from a method.  A LogRecord with message \"RETURN\", log level\n     * FINER, and the given sourceMethod and sourceClass is logged.\n     * <p>\n     * @param   sourceClass    name of class that issued the logging request\n     * @param   sourceMethod   name of the method\n     ",
    "links" : [ ]
  }, {
    "name" : "public void exiting(String sourceClass, String sourceMethod, Object result)",
    "returnType" : "void",
    "comment" : "\n     * Log a method return, with result object.\n     * <p>\n     * This is a convenience method that can be used to log returning\n     * from a method.  A LogRecord with message \"RETURN {0}\", log level\n     * FINER, and the gives sourceMethod, sourceClass, and result\n     * object is logged.\n     * <p>\n     * @param   sourceClass    name of class that issued the logging request\n     * @param   sourceMethod   name of the method\n     * @param   result  Object that is being returned\n     ",
    "links" : [ ]
  }, {
    "name" : "public void throwing(String sourceClass, String sourceMethod, Throwable thrown)",
    "returnType" : "void",
    "comment" : "\n     * Log throwing an exception.\n     * <p>\n     * This is a convenience method to log that a method is\n     * terminating by throwing an exception.  The logging is done\n     * using the FINER level.\n     * <p>\n     * If the logger is currently enabled for the given message\n     * level then the given arguments are stored in a LogRecord\n     * which is forwarded to all registered output handlers.  The\n     * LogRecord's message is set to \"THROW\".\n     * <p>\n     * Note that the thrown argument is stored in the LogRecord thrown\n     * property, rather than the LogRecord parameters property.  Thus it is\n     * processed specially by output Formatters and is not treated\n     * as a formatting parameter to the LogRecord message property.\n     * <p>\n     * @param   sourceClass    name of class that issued the logging request\n     * @param   sourceMethod  name of the method.\n     * @param   thrown  The Throwable that is being thrown.\n     ",
    "links" : [ ]
  }, {
    "name" : "public void severe(String msg)",
    "returnType" : "void",
    "comment" : "\n     * Log a SEVERE message.\n     * <p>\n     * If the logger is currently enabled for the SEVERE message\n     * level then the given message is forwarded to all the\n     * registered output Handler objects.\n     * <p>\n     * @param   msg     The string message (or a key in the message catalog)\n     ",
    "links" : [ ]
  }, {
    "name" : "public void warning(String msg)",
    "returnType" : "void",
    "comment" : "\n     * Log a WARNING message.\n     * <p>\n     * If the logger is currently enabled for the WARNING message\n     * level then the given message is forwarded to all the\n     * registered output Handler objects.\n     * <p>\n     * @param   msg     The string message (or a key in the message catalog)\n     ",
    "links" : [ ]
  }, {
    "name" : "public void info(String msg)",
    "returnType" : "void",
    "comment" : "\n     * Log an INFO message.\n     * <p>\n     * If the logger is currently enabled for the INFO message\n     * level then the given message is forwarded to all the\n     * registered output Handler objects.\n     * <p>\n     * @param   msg     The string message (or a key in the message catalog)\n     ",
    "links" : [ ]
  }, {
    "name" : "public void config(String msg)",
    "returnType" : "void",
    "comment" : "\n     * Log a CONFIG message.\n     * <p>\n     * If the logger is currently enabled for the CONFIG message\n     * level then the given message is forwarded to all the\n     * registered output Handler objects.\n     * <p>\n     * @param   msg     The string message (or a key in the message catalog)\n     ",
    "links" : [ ]
  }, {
    "name" : "public void fine(String msg)",
    "returnType" : "void",
    "comment" : "\n     * Log a FINE message.\n     * <p>\n     * If the logger is currently enabled for the FINE message\n     * level then the given message is forwarded to all the\n     * registered output Handler objects.\n     * <p>\n     * @param   msg     The string message (or a key in the message catalog)\n     ",
    "links" : [ ]
  }, {
    "name" : "public void finer(String msg)",
    "returnType" : "void",
    "comment" : "\n     * Log a FINER message.\n     * <p>\n     * If the logger is currently enabled for the FINER message\n     * level then the given message is forwarded to all the\n     * registered output Handler objects.\n     * <p>\n     * @param   msg     The string message (or a key in the message catalog)\n     ",
    "links" : [ ]
  }, {
    "name" : "public void finest(String msg)",
    "returnType" : "void",
    "comment" : "\n     * Log a FINEST message.\n     * <p>\n     * If the logger is currently enabled for the FINEST message\n     * level then the given message is forwarded to all the\n     * registered output Handler objects.\n     * <p>\n     * @param   msg     The string message (or a key in the message catalog)\n     ",
    "links" : [ ]
  }, {
    "name" : "public void severe(Supplier<String> msgSupplier)",
    "returnType" : "void",
    "comment" : "\n     * Log a SEVERE message, which is only to be constructed if the logging\n     * level is such that the message will actually be logged.\n     * <p>\n     * If the logger is currently enabled for the SEVERE message\n     * level then the message is constructed by invoking the provided\n     * supplier function and forwarded to all the registered output\n     * Handler objects.\n     * <p>\n     * @param   msgSupplier   A function, which when called, produces the\n     *                        desired log message\n     * @since   1.8\n     ",
    "links" : [ ]
  }, {
    "name" : "public void warning(Supplier<String> msgSupplier)",
    "returnType" : "void",
    "comment" : "\n     * Log a WARNING message, which is only to be constructed if the logging\n     * level is such that the message will actually be logged.\n     * <p>\n     * If the logger is currently enabled for the WARNING message\n     * level then the message is constructed by invoking the provided\n     * supplier function and forwarded to all the registered output\n     * Handler objects.\n     * <p>\n     * @param   msgSupplier   A function, which when called, produces the\n     *                        desired log message\n     * @since   1.8\n     ",
    "links" : [ ]
  }, {
    "name" : "public void info(Supplier<String> msgSupplier)",
    "returnType" : "void",
    "comment" : "\n     * Log a INFO message, which is only to be constructed if the logging\n     * level is such that the message will actually be logged.\n     * <p>\n     * If the logger is currently enabled for the INFO message\n     * level then the message is constructed by invoking the provided\n     * supplier function and forwarded to all the registered output\n     * Handler objects.\n     * <p>\n     * @param   msgSupplier   A function, which when called, produces the\n     *                        desired log message\n     * @since   1.8\n     ",
    "links" : [ ]
  }, {
    "name" : "public void config(Supplier<String> msgSupplier)",
    "returnType" : "void",
    "comment" : "\n     * Log a CONFIG message, which is only to be constructed if the logging\n     * level is such that the message will actually be logged.\n     * <p>\n     * If the logger is currently enabled for the CONFIG message\n     * level then the message is constructed by invoking the provided\n     * supplier function and forwarded to all the registered output\n     * Handler objects.\n     * <p>\n     * @param   msgSupplier   A function, which when called, produces the\n     *                        desired log message\n     * @since   1.8\n     ",
    "links" : [ ]
  }, {
    "name" : "public void fine(Supplier<String> msgSupplier)",
    "returnType" : "void",
    "comment" : "\n     * Log a FINE message, which is only to be constructed if the logging\n     * level is such that the message will actually be logged.\n     * <p>\n     * If the logger is currently enabled for the FINE message\n     * level then the message is constructed by invoking the provided\n     * supplier function and forwarded to all the registered output\n     * Handler objects.\n     * <p>\n     * @param   msgSupplier   A function, which when called, produces the\n     *                        desired log message\n     * @since   1.8\n     ",
    "links" : [ ]
  }, {
    "name" : "public void finer(Supplier<String> msgSupplier)",
    "returnType" : "void",
    "comment" : "\n     * Log a FINER message, which is only to be constructed if the logging\n     * level is such that the message will actually be logged.\n     * <p>\n     * If the logger is currently enabled for the FINER message\n     * level then the message is constructed by invoking the provided\n     * supplier function and forwarded to all the registered output\n     * Handler objects.\n     * <p>\n     * @param   msgSupplier   A function, which when called, produces the\n     *                        desired log message\n     * @since   1.8\n     ",
    "links" : [ ]
  }, {
    "name" : "public void finest(Supplier<String> msgSupplier)",
    "returnType" : "void",
    "comment" : "\n     * Log a FINEST message, which is only to be constructed if the logging\n     * level is such that the message will actually be logged.\n     * <p>\n     * If the logger is currently enabled for the FINEST message\n     * level then the message is constructed by invoking the provided\n     * supplier function and forwarded to all the registered output\n     * Handler objects.\n     * <p>\n     * @param   msgSupplier   A function, which when called, produces the\n     *                        desired log message\n     * @since   1.8\n     ",
    "links" : [ ]
  }, {
    "name" : "public void setLevel(Level newLevel) throws SecurityException",
    "returnType" : "void",
    "comment" : "\n     * Set the log level specifying which message levels will be\n     * logged by this logger.  Message levels lower than this\n     * value will be discarded.  The level value Level.OFF\n     * can be used to turn off logging.\n     * <p>\n     * If the new level is null, it means that this node should\n     * inherit its level from its nearest ancestor with a specific\n     * (non-null) level value.\n     *\n     * @param newLevel   the new value for the log level (may be null)\n     * @throws  SecurityException if a security manager exists,\n     *          this logger is not anonymous, and the caller\n     *          does not have LoggingPermission(\"control\").\n     ",
    "links" : [ ]
  }, {
    "name" : " final boolean isLevelInitialized()",
    "returnType" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public Level getLevel()",
    "returnType" : "Level",
    "comment" : "\n     * Get the log Level that has been specified for this Logger.\n     * The result may be null, which means that this logger's\n     * effective level will be inherited from its parent.\n     *\n     * @return  this Logger's level\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean isLoggable(Level level)",
    "returnType" : "boolean",
    "comment" : "\n     * Check if a message of the given level would actually be logged\n     * by this logger.  This check is based on the Loggers effective level,\n     * which may be inherited from its parent.\n     *\n     * @param   level   a message logging level\n     * @return  true if the given message level is currently being logged.\n     ",
    "links" : [ ]
  }, {
    "name" : "public String getName()",
    "returnType" : "String",
    "comment" : "\n     * Get the name for this logger.\n     * @return logger name.  Will be null for anonymous Loggers.\n     ",
    "links" : [ ]
  }, {
    "name" : "public void addHandler(Handler handler) throws SecurityException",
    "returnType" : "void",
    "comment" : "\n     * Add a log Handler to receive logging messages.\n     * <p>\n     * By default, Loggers also send their output to their parent logger.\n     * Typically the root Logger is configured with a set of Handlers\n     * that essentially act as default handlers for all loggers.\n     *\n     * @param   handler a logging Handler\n     * @throws  SecurityException if a security manager exists,\n     *          this logger is not anonymous, and the caller\n     *          does not have LoggingPermission(\"control\").\n     ",
    "links" : [ ]
  }, {
    "name" : "public void removeHandler(Handler handler) throws SecurityException",
    "returnType" : "void",
    "comment" : "\n     * Remove a log Handler.\n     * <P>\n     * Returns silently if the given Handler is not found or is null\n     *\n     * @param   handler a logging Handler\n     * @throws  SecurityException if a security manager exists,\n     *          this logger is not anonymous, and the caller\n     *          does not have LoggingPermission(\"control\").\n     ",
    "links" : [ ]
  }, {
    "name" : "public Handler[] getHandlers()",
    "returnType" : "Handler[]",
    "comment" : "\n     * Get the Handlers associated with this logger.\n     * <p>\n     * @return  an array of all registered Handlers\n     ",
    "links" : [ ]
  }, {
    "name" : " Handler[] accessCheckedHandlers()",
    "returnType" : "Handler[]",
    "comment" : " it needs to be overridden by LogManager.RootLogger",
    "links" : [ ]
  }, {
    "name" : "public void setUseParentHandlers(boolean useParentHandlers)",
    "returnType" : "void",
    "comment" : "\n     * Specify whether or not this logger should send its output\n     * to its parent Logger.  This means that any LogRecords will\n     * also be written to the parent's Handlers, and potentially\n     * to its parent, recursively up the namespace.\n     *\n     * @param useParentHandlers   true if output is to be sent to the\n     *          logger's parent.\n     * @throws  SecurityException if a security manager exists,\n     *          this logger is not anonymous, and the caller\n     *          does not have LoggingPermission(\"control\").\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean getUseParentHandlers()",
    "returnType" : "boolean",
    "comment" : "\n     * Discover whether or not this logger is sending its output\n     * to its parent logger.\n     *\n     * @return  true if output is to be sent to the logger's parent\n     ",
    "links" : [ ]
  }, {
    "name" : "private static ResourceBundle findSystemResourceBundle(final Locale locale)",
    "returnType" : "ResourceBundle",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private synchronized ResourceBundle findResourceBundle(String name, boolean useCallersClassLoader)",
    "returnType" : "ResourceBundle",
    "comment" : "\n     * Private utility method to map a resource bundle name to an\n     * actual resource bundle, using a simple one-entry cache.\n     * Returns null for a null name.\n     * May also return null if we can't find the resource bundle and\n     * there is no suitable previous cached value.\n     *\n     * @param name the ResourceBundle to locate\n     * @param userCallersClassLoader if true search using the caller's ClassLoader\n     * @return ResourceBundle specified by name or null if not found\n     ",
    "links" : [ ]
  }, {
    "name" : "private synchronized void setupResourceInfo(String name, Class<?> callersClass)",
    "returnType" : "void",
    "comment" : " Synchronized to prevent races in setting the fields.",
    "links" : [ ]
  }, {
    "name" : "public void setResourceBundle(ResourceBundle bundle)",
    "returnType" : "void",
    "comment" : "\n     * Sets a resource bundle on this logger.\n     * All messages will be logged using the given resource bundle for its\n     * specific {@linkplain ResourceBundle#getLocale locale}.\n     * @param bundle The resource bundle that this logger shall use.\n     * @throws NullPointerException if the given bundle is {@code null}.\n     * @throws IllegalArgumentException if the given bundle doesn't have a\n     *         {@linkplain ResourceBundle#getBaseBundleName base name},\n     *         or if this logger already has a resource bundle set but\n     *         the given bundle has a different base name.\n     * @throws SecurityException if a security manager exists,\n     *         this logger is not anonymous, and the caller\n     *         does not have LoggingPermission(\"control\").\n     * @since 1.8\n     ",
    "links" : [ ]
  }, {
    "name" : "public Logger getParent()",
    "returnType" : "Logger",
    "comment" : "\n     * Return the parent for this Logger.\n     * <p>\n     * This method returns the nearest extant parent in the namespace.\n     * Thus if a Logger is called \"a.b.c.d\", and a Logger called \"a.b\"\n     * has been created but no logger \"a.b.c\" exists, then a call of\n     * getParent on the Logger \"a.b.c.d\" will return the Logger \"a.b\".\n     * <p>\n     * The result will be null if it is called on the root Logger\n     * in the namespace.\n     *\n     * @return nearest existing parent Logger\n     ",
    "links" : [ ]
  }, {
    "name" : "public void setParent(Logger parent)",
    "returnType" : "void",
    "comment" : "\n     * Set the parent for this Logger.  This method is used by\n     * the LogManager to update a Logger when the namespace changes.\n     * <p>\n     * It should not be called from application code.\n     * <p>\n     * @param  parent   the new parent logger\n     * @throws  SecurityException  if a security manager exists and if\n     *          the caller does not have LoggingPermission(\"control\").\n     ",
    "links" : [ ]
  }, {
    "name" : "private void doSetParent(Logger newParent)",
    "returnType" : "void",
    "comment" : " Logger onto a parent logger.",
    "links" : [ ]
  }, {
    "name" : " final void removeChildLogger(LogManager.LoggerWeakRef child)",
    "returnType" : "void",
    "comment" : " kid list. We should only be called from LoggerWeakRef.dispose().",
    "links" : [ ]
  }, {
    "name" : "private void updateEffectiveLevel()",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private LoggerBundle getEffectiveLoggerBundle()",
    "returnType" : "LoggerBundle",
    "comment" : " This method never returns null.",
    "links" : [ ]
  } ],
  "methodNames" : [ "public static final Logger getGlobal()", "private void setCallersClassLoaderRef(Class<?> caller)", "private ClassLoader getCallersClassLoader()", " void setLogManager(LogManager manager)", "private void checkPermission() throws SecurityException", "private static Logger demandLogger(String name, String resourceBundleName, Class<?> caller)", "public static Logger getLogger(String name)", "public static Logger getLogger(String name, String resourceBundleName)", " static Logger getPlatformLogger(String name)", "public static Logger getAnonymousLogger()", "public static Logger getAnonymousLogger(String resourceBundleName)", "public ResourceBundle getResourceBundle()", "public String getResourceBundleName()", "public void setFilter(Filter newFilter) throws SecurityException", "public Filter getFilter()", "public void log(LogRecord record)", "private void doLog(LogRecord lr)", "public void log(Level level, String msg)", "public void log(Level level, Supplier<String> msgSupplier)", "public void log(Level level, String msg, Object param1)", "public void log(Level level, String msg, Object[] params)", "public void log(Level level, String msg, Throwable thrown)", "public void log(Level level, Throwable thrown, Supplier<String> msgSupplier)", "public void logp(Level level, String sourceClass, String sourceMethod, String msg)", "public void logp(Level level, String sourceClass, String sourceMethod, Supplier<String> msgSupplier)", "public void logp(Level level, String sourceClass, String sourceMethod, String msg, Object param1)", "public void logp(Level level, String sourceClass, String sourceMethod, String msg, Object[] params)", "public void logp(Level level, String sourceClass, String sourceMethod, String msg, Throwable thrown)", "public void logp(Level level, String sourceClass, String sourceMethod, Throwable thrown, Supplier<String> msgSupplier)", "private void doLog(LogRecord lr, String rbname)", "private void doLog(LogRecord lr, ResourceBundle rb)", "public void logrb(Level level, String sourceClass, String sourceMethod, String bundleName, String msg)", "public void logrb(Level level, String sourceClass, String sourceMethod, String bundleName, String msg, Object param1)", "public void logrb(Level level, String sourceClass, String sourceMethod, String bundleName, String msg, Object[] params)", "public void logrb(Level level, String sourceClass, String sourceMethod, ResourceBundle bundle, String msg, Object... params)", "public void logrb(Level level, String sourceClass, String sourceMethod, String bundleName, String msg, Throwable thrown)", "public void logrb(Level level, String sourceClass, String sourceMethod, ResourceBundle bundle, String msg, Throwable thrown)", "public void entering(String sourceClass, String sourceMethod)", "public void entering(String sourceClass, String sourceMethod, Object param1)", "public void entering(String sourceClass, String sourceMethod, Object[] params)", "public void exiting(String sourceClass, String sourceMethod)", "public void exiting(String sourceClass, String sourceMethod, Object result)", "public void throwing(String sourceClass, String sourceMethod, Throwable thrown)", "public void severe(String msg)", "public void warning(String msg)", "public void info(String msg)", "public void config(String msg)", "public void fine(String msg)", "public void finer(String msg)", "public void finest(String msg)", "public void severe(Supplier<String> msgSupplier)", "public void warning(Supplier<String> msgSupplier)", "public void info(Supplier<String> msgSupplier)", "public void config(Supplier<String> msgSupplier)", "public void fine(Supplier<String> msgSupplier)", "public void finer(Supplier<String> msgSupplier)", "public void finest(Supplier<String> msgSupplier)", "public void setLevel(Level newLevel) throws SecurityException", " final boolean isLevelInitialized()", "public Level getLevel()", "public boolean isLoggable(Level level)", "public String getName()", "public void addHandler(Handler handler) throws SecurityException", "public void removeHandler(Handler handler) throws SecurityException", "public Handler[] getHandlers()", " Handler[] accessCheckedHandlers()", "public void setUseParentHandlers(boolean useParentHandlers)", "public boolean getUseParentHandlers()", "private static ResourceBundle findSystemResourceBundle(final Locale locale)", "private synchronized ResourceBundle findResourceBundle(String name, boolean useCallersClassLoader)", "private synchronized void setupResourceInfo(String name, Class<?> callersClass)", "public void setResourceBundle(ResourceBundle bundle)", "public Logger getParent()", "public void setParent(Logger parent)", "private void doSetParent(Logger newParent)", " final void removeChildLogger(LogManager.LoggerWeakRef child)", "private void updateEffectiveLevel()", "private LoggerBundle getEffectiveLoggerBundle()" ],
  "variableNames" : [ "emptyHandlers", "offValue", "SYSTEM_LOGGER_RB_NAME", "SYSTEM_BUNDLE", "NO_RESOURCE_BUNDLE", "manager", "name", "handlers", "loggerBundle", "useParentHandlers", "filter", "anonymous", "catalog", "catalogName", "catalogLocale", "treeLock", "parent", "kids", "levelObject", "levelValue", "callersClassLoaderRef", "isSystemLogger", "GLOBAL_LOGGER_NAME", "global" ]
}