{
  "filePath" : "/home/maryam/clearblue/files/android-source-35/java/lang/Class.java",
  "packageName" : "java.lang",
  "className" : "Class",
  "comment" : "\n * Instances of the class {@code Class} represent classes and\n * interfaces in a running Java application. An enum class and a record\n * class are kinds of class; an annotation interface is a kind of\n * interface. Every array also belongs to a class that is reflected as\n * a {@code Class} object that is shared by all arrays with the same\n * element type and number of dimensions.  The primitive Java types\n * ({@code boolean}, {@code byte}, {@code char}, {@code short}, {@code\n * int}, {@code long}, {@code float}, and {@code double}), and the\n * keyword {@code void} are also represented as {@code Class} objects.\n *\n * <p> {@code Class} has no public constructor. Instead a {@code Class}\n * object is constructed automatically by the Java Virtual Machine when\n * a class is derived from the bytes of a {@code class} file through\n * the invocation of one of the following methods:\n * <ul>\n * <li> {@link ClassLoader#defineClass(String, byte[], int, int) ClassLoader::defineClass}\n * </ul>\n *\n * <p> The methods of class {@code Class} expose many characteristics of a\n * class or interface. Most characteristics are derived from the {@code class}\n * file that the class loader passed to the Java Virtual Machine. A few\n * characteristics are determined by the class loading environment at run time.\n *\n * <p> The following example uses a {@code Class} object to print the\n * class name of an object:\n *\n * <blockquote><pre>\n *     void printClassName(Object obj) {\n *         System.out.println(\"The class of \" + obj +\n *                            \" is \" + obj.getClass().getName());\n *     }\n * </pre></blockquote>\n *\n * It is also possible to get the {@code Class} object for a named\n * class or interface (or for {@code void}) using a <i>class literal</i>.\n * For example:\n *\n * <blockquote>\n *     {@code System.out.println(\"The name of class Foo is: \"+Foo.class.getName());}\n * </blockquote>\n *\n * <p> Some methods of class {@code Class} expose whether the declaration of\n * a class or interface in Java source code was <em>enclosed</em> within\n * another declaration. Other methods describe how a class or interface\n * is situated in a <em>nest</em>. A <a id=\"nest\">nest</a> is a set of\n * classes and interfaces, in the same run-time package, that\n * allow mutual access to their {@code private} members.\n * The classes and interfaces are known as <em>nestmates</em>.\n * One nestmate acts as the\n * <em>nest host</em>, and enumerates the other nestmates which\n * belong to the nest; each of them in turn records it as the nest host.\n * The classes and interfaces which belong to a nest, including its host, are\n * determined when\n * {@code class} files are generated, for example, a Java compiler\n * will typically record a top-level class as the host of a nest where the\n * other members are the classes and interfaces whose declarations are\n * enclosed within the top-level class declaration.\n *\n * <p> Some methods of class {@code Class} expose whether the declaration of\n * a class or interface in Java source code was <em>enclosed</em> within\n * another declaration. Other methods describe how a class or interface\n * is situated in a <em>nest</em>. A <a id=\"nest\">nest</a> is a set of\n * classes and interfaces, in the same run-time package, that\n * allow mutual access to their {@code private} members.\n * The classes and interfaces are known as <em>nestmates</em>.\n * One nestmate acts as the\n * <em>nest host</em>, and enumerates the other nestmates which\n * belong to the nest; each of them in turn records it as the nest host.\n * The classes and interfaces which belong to a nest, including its host, are\n * determined when\n * {@code class} files are generated, for example, a Java compiler\n * will typically record a top-level class as the host of a nest where the\n * other members are the classes and interfaces whose declarations are\n * enclosed within the top-level class declaration.\n *\n * @param <T> the type of the class modeled by this {@code Class}\n * object.  For example, the type of {@code String.class} is {@code\n * Class<String>}.  Use {@code Class<?>} if the class being modeled is\n * unknown.\n *\n * @see     java.lang.ClassLoader#defineClass(byte[], int, int)\n * @since   1.0\n * @jls 15.8.2 Class Literals\n ",
  "links" : [ "java.lang.ClassLoader#defineClass(String" ],
  "variables" : [ {
    "name" : "ANNOTATION",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "ENUM",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "SYNTHETIC",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "FINALIZABLE",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "classLoader",
    "type" : "ClassLoader",
    "comment" : " defining class loader, or null for the \"bootstrap\" system loader. ",
    "links" : [ ]
  }, {
    "name" : "componentType",
    "type" : "Class<?>",
    "comment" : "\n     * For array classes, the component class object for instanceof/checkcast (for String[][][],\n     * this will be String[][]). null for non-array classes.\n     ",
    "links" : [ ]
  }, {
    "name" : "dexCache",
    "type" : "Object",
    "comment" : "\n     * DexCache of resolved constant pool entries. Will be null for certain runtime-generated classes\n     * e.g. arrays and primitive classes.\n     ",
    "links" : [ ]
  }, {
    "name" : "extData",
    "type" : "ClassExt",
    "comment" : "\n     * Extra data that only some classes possess. This is allocated lazily as needed.\n     ",
    "links" : [ ]
  }, {
    "name" : "ifTable",
    "type" : "Object[]",
    "comment" : "\n     * The interface table (iftable_) contains pairs of a interface class and an array of the\n     * interface methods. There is one pair per interface supported by this class.  That\n     * means one pair for each interface we support directly, indirectly via superclass, or\n     * indirectly via a superinterface.  This will be null if neither we nor our superclass\n     * implement any interfaces.\n     *\n     * Why we need this: given \"class Foo implements Face\", declare \"Face faceObj = new Foo()\".\n     * Invoke faceObj.blah(), where \"blah\" is part of the Face interface.  We can't easily use a\n     * single vtable.\n     *\n     * For every interface a concrete class implements, we create an array of the concrete vtable_\n     * methods for the methods in the interface.\n     ",
    "links" : [ ]
  }, {
    "name" : "name",
    "type" : "String",
    "comment" : " Lazily computed name of this class; always prefer calling getName(). ",
    "links" : [ ]
  }, {
    "name" : "superClass",
    "type" : "Class<? super T>",
    "comment" : " The superclass, or null if this is java.lang.Object, an interface or primitive type. ",
    "links" : [ ]
  }, {
    "name" : "vtable",
    "type" : "Object",
    "comment" : "\n     * Virtual method table (vtable), for use by \"invoke-virtual\". The vtable from the superclass\n     * is copied in, and virtual methods from our class either replace those from the super or are\n     * appended. For abstract classes, methods may be created in the vtable that aren't in\n     * virtual_ methods_ for miranda methods.\n     ",
    "links" : [ ]
  }, {
    "name" : "iFields",
    "type" : "long",
    "comment" : "\n     * Instance fields. These describe the layout of the contents of an Object. Note that only the\n     * fields directly declared by this class are listed in iFields; fields declared by a\n     * superclass are listed in the superclass's Class.iFields.\n     *\n     * All instance fields that refer to objects are guaranteed to be at the beginning of the field\n     * list.  {@link Class#numReferenceInstanceFields} specifies the number of reference fields.\n     ",
    "links" : [ "java.lang.Class#numReferenceInstanceFields" ]
  }, {
    "name" : "methods",
    "type" : "long",
    "comment" : " All methods with this class as the base for virtual dispatch. ",
    "links" : [ ]
  }, {
    "name" : "sFields",
    "type" : "long",
    "comment" : " Static fields ",
    "links" : [ ]
  }, {
    "name" : "accessFlags",
    "type" : "int",
    "comment" : " access flags; low 16 bits are defined by VM spec ",
    "links" : [ ]
  }, {
    "name" : "classFlags",
    "type" : "int",
    "comment" : " Class flags to help the GC with object scanning. ",
    "links" : [ ]
  }, {
    "name" : "classSize",
    "type" : "int",
    "comment" : "\n     * Total size of the Class instance; used when allocating storage on GC heap.\n     * See also {@link Class#objectSize}.\n     ",
    "links" : [ "java.lang.Class#objectSize" ]
  }, {
    "name" : "clinitThreadId",
    "type" : "int",
    "comment" : "\n     * tid used to check for recursive static initializer invocation.\n     ",
    "links" : [ ]
  }, {
    "name" : "dexClassDefIndex",
    "type" : "int",
    "comment" : "\n     * Class def index from dex file. An index of 65535 indicates that there is no class definition,\n     * for example for an array type.\n     * TODO: really 16bits as type indices are 16bit.\n     ",
    "links" : [ ]
  }, {
    "name" : "dexTypeIndex",
    "type" : "int",
    "comment" : "\n     * Class type index from dex file, lazily computed. An index of 65535 indicates that the type\n     * index isn't known. Volatile to avoid double-checked locking bugs.\n     * TODO: really 16bits as type indices are 16bit.\n     ",
    "links" : [ ]
  }, {
    "name" : "numReferenceInstanceFields",
    "type" : "int",
    "comment" : " Number of instance fields that are object references. ",
    "links" : [ ]
  }, {
    "name" : "numReferenceStaticFields",
    "type" : "int",
    "comment" : " Number of static fields that are object references. ",
    "links" : [ ]
  }, {
    "name" : "objectSize",
    "type" : "int",
    "comment" : "\n     * Total object size; used when allocating storage on GC heap. For interfaces and abstract\n     * classes this will be zero. See also {@link Class#classSize}.\n     ",
    "links" : [ "java.lang.Class#classSize" ]
  }, {
    "name" : "objectSizeAllocFastPath",
    "type" : "int",
    "comment" : "\n     * Aligned object size for allocation fast path. The value is max int if the object is\n     * uninitialized or finalizable, otherwise the aligned object size.\n     ",
    "links" : [ ]
  }, {
    "name" : "primitiveType",
    "type" : "int",
    "comment" : "\n     * The lower 16 bits is the primitive type value, or 0 if not a primitive type; set for\n     * generated primitive classes.\n     ",
    "links" : [ ]
  }, {
    "name" : "referenceInstanceOffsets",
    "type" : "int",
    "comment" : " Bitmap of offsets of iFields. ",
    "links" : [ ]
  }, {
    "name" : "status",
    "type" : "int",
    "comment" : " State of class initialization ",
    "links" : [ ]
  }, {
    "name" : "copiedMethodsOffset",
    "type" : "short",
    "comment" : " Offset of the first virtual method copied from an interface in the methods array. ",
    "links" : [ ]
  }, {
    "name" : "virtualMethodsOffset",
    "type" : "short",
    "comment" : " Offset of the first virtual method defined in this class in the methods array. ",
    "links" : [ ]
  }, {
    "name" : "serialVersionUID",
    "type" : "long",
    "comment" : " use serialVersionUID from JDK 1.1 for interoperability ",
    "links" : [ ]
  } ],
  "methods" : [ {
    "name" : "public String toString()",
    "returnType" : "String",
    "comment" : "\n     * Converts the object to a string. The string representation is the\n     * string \"class\" or \"interface\", followed by a space, and then by the\n     * name of the class in the format returned by {@code getName}.\n     * If this {@code Class} object represents a primitive type,\n     * this method returns the name of the primitive type.  If\n     * this {@code Class} object represents void this method returns\n     * \"void\". If this {@code Class} object represents an array type,\n     * this method returns \"class \" followed by {@code getName}.\n     *\n     * @return a string representation of this {@code Class} object.\n     ",
    "links" : [ ]
  }, {
    "name" : "public String toGenericString()",
    "returnType" : "String",
    "comment" : "\n     * Returns a string describing this {@code Class}, including\n     * information about modifiers and type parameters.\n     *\n     * The string is formatted as a list of type modifiers, if any,\n     * followed by the kind of type (empty string for primitive types\n     * and {@code class}, {@code enum}, {@code interface},\n     * {@code @interface}, or {@code record} as appropriate), followed\n     * by the type's name, followed by an angle-bracketed\n     * comma-separated list of the type's type parameters, if any,\n     * including informative bounds on the type parameters, if any.\n     *\n     * A space is used to separate modifiers from one another and to\n     * separate any modifiers from the kind of type. The modifiers\n     * occur in canonical order. If there are no type parameters, the\n     * type parameter list is elided.\n     *\n     * For an array type, the string starts with the type name,\n     * followed by an angle-bracketed comma-separated list of the\n     * type's type parameters, if any, followed by a sequence of\n     * {@code []} characters, one set of brackets per dimension of\n     * the array.\n     *\n     * <p>Note that since information about the runtime representation\n     * of a type is being generated, modifiers not present on the\n     * originating source code or illegal on the originating source\n     * code may be present.\n     *\n     * @return a string describing this {@code Class}, including\n     * information about modifiers and type parameters\n     *\n     * @since 1.8\n     ",
    "links" : [ ]
  }, {
    "name" : " static String typeVarBounds(TypeVariable<?> typeVar)",
    "returnType" : "String",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public static Class<?> forName(String className) throws ClassNotFoundException",
    "returnType" : "Class<?>",
    "comment" : "\n     * Returns the {@code Class} object associated with the class or\n     * interface with the given string name.  Invoking this method is\n     * equivalent to:\n     *\n     * <blockquote>\n     *  {@code Class.forName(className, true, currentLoader)}\n     * </blockquote>\n     *\n     * where {@code currentLoader} denotes the defining class loader of\n     * the current class.\n     *\n     * <p> For example, the following code fragment returns the\n     * runtime {@code Class} descriptor for the class named\n     * {@code java.lang.Thread}:\n     *\n     * <blockquote>\n     *   {@code Class t = Class.forName(\"java.lang.Thread\")}\n     * </blockquote>\n     * <p>\n     * A call to {@code forName(\"X\")} causes the class named\n     * {@code X} to be initialized.\n     *\n     * @param      className   the fully qualified name of the desired class.\n     * @return     the {@code Class} object for the class with the\n     *             specified name.\n     * @throws    LinkageError if the linkage fails\n     * @throws    ExceptionInInitializerError if the initialization provoked\n     *            by this method fails\n     * @throws    ClassNotFoundException if the class cannot be located\n     *\n     * @jls 12.2 Loading of Classes and Interfaces\n     * @jls 12.3 Linking of Classes and Interfaces\n     * @jls 12.4 Initialization of Classes and Interfaces\n     ",
    "links" : [ ]
  }, {
    "name" : "public static Class<?> forName(String name, boolean initialize, ClassLoader loader) throws ClassNotFoundException",
    "returnType" : "Class<?>",
    "comment" : "\n     * Returns the {@code Class} object associated with the class or\n     * interface with the given string name, using the given class loader.\n     * Given the fully qualified name for a class or interface (in the same\n     * format returned by {@code getName}) this method attempts to\n     * locate and load the class or interface.  The specified class\n     * loader is used to load the class or interface.  If the parameter\n     * {@code loader} is null, the class is loaded through the bootstrap\n     * class loader.  The class is initialized only if the\n     * {@code initialize} parameter is {@code true} and if it has\n     * not been initialized earlier.\n     *\n     * <p> If {@code name} denotes a primitive type or void, an attempt\n     * will be made to locate a user-defined class in the unnamed package whose\n     * name is {@code name}. Therefore, this method cannot be used to\n     * obtain any of the {@code Class} objects representing primitive\n     * types or void.\n     *\n     * <p> If {@code name} denotes an array class, the component type of\n     * the array class is loaded but not initialized.\n     *\n     * <p> For example, in an instance method the expression:\n     *\n     * <blockquote>\n     *  {@code Class.forName(\"Foo\")}\n     * </blockquote>\n     *\n     * is equivalent to:\n     *\n     * <blockquote>\n     *  {@code Class.forName(\"Foo\", true, this.getClass().getClassLoader())}\n     * </blockquote>\n     *\n     * Note that this method throws errors related to loading, linking\n     * or initializing as specified in Sections {@jls 12.2}, {@jls\n     * 12.3}, and {@jls 12.4} of <cite>The Java Language\n     * Specification</cite>.\n     * Note that this method does not check whether the requested class\n     * is accessible to its caller.\n     *\n     * @param name       fully qualified name of the desired class\n\n     * @param initialize if {@code true} the class will be initialized\n     *                   (which implies linking). See Section {@jls\n     *                   12.4} of <cite>The Java Language\n     *                   Specification</cite>.\n     * @param loader     class loader from which the class must be loaded\n     * @return           class object representing the desired class\n     *\n     * @throws    LinkageError if the linkage fails\n     * @throws    ExceptionInInitializerError if the initialization provoked\n     *            by this method fails\n     * @throws    ClassNotFoundException if the class cannot be located by\n     *            the specified class loader\n     *\n     * @see       java.lang.Class#forName(String)\n     * @see       java.lang.ClassLoader\n     *\n     * @jls 12.2 Loading of Classes and Interfaces\n     * @jls 12.3 Linking of Classes and Interfaces\n     * @jls 12.4 Initialization of Classes and Interfaces\n     * @since     1.2\n     ",
    "links" : [ ]
  }, {
    "name" : " static native Class<?> classForName(String className, boolean shouldInitialize, ClassLoader classLoader) throws ClassNotFoundException",
    "returnType" : "Class<?>",
    "comment" : " Called after security checks have been made. ",
    "links" : [ ]
  }, {
    "name" : "public native T newInstance() throws InstantiationException, IllegalAccessException",
    "returnType" : "T",
    "comment" : "\n    @SuppressWarnings(\"removal\")\n    @CallerSensitive\n    public T newInstance()\n        throws InstantiationException, IllegalAccessException\n    {\n        SecurityManager sm = System.getSecurityManager();\n        if (sm != null) {\n            checkMemberAccess(sm, Member.PUBLIC, Reflection.getCallerClass(), false);\n        }\n\n        // Constructor lookup\n        Constructor<T> tmpConstructor = cachedConstructor;\n        if (tmpConstructor == null) {\n            if (this == Class.class) {\n                throw new IllegalAccessException(\n                    \"Can not call newInstance() on the Class for java.lang.Class\"\n                );\n            }\n            try {\n                Class<?>[] empty = {};\n                final Constructor<T> c = getReflectionFactory().copyConstructor(\n                    getConstructor0(empty, Member.DECLARED));\n                // Disable accessibility checks on the constructor\n                // access check is done with the true caller\n                java.security.AccessController.doPrivileged(\n                    new java.security.PrivilegedAction<>() {\n                        public Void run() {\n                                c.setAccessible(true);\n                                return null;\n                            }\n                        });\n                cachedConstructor = tmpConstructor = c;\n            } catch (NoSuchMethodException e) {\n                throw (InstantiationException)\n                    new InstantiationException(getName()).initCause(e);\n            }\n        }\n\n        try {\n            Class<?> caller = Reflection.getCallerClass();\n            return getReflectionFactory().newInstance(tmpConstructor, null, caller);\n        } catch (InvocationTargetException e) {\n            Unsafe.getUnsafe().throwException(e.getTargetException());\n            // Not reached\n            return null;\n        }\n    }\n\n    private transient volatile Constructor<T> cachedConstructor;\n    ",
    "links" : [ ]
  }, {
    "name" : "public boolean isInstance(Object obj)",
    "returnType" : "boolean",
    "comment" : "\n     * Determines if the specified {@code Object} is assignment-compatible\n     * with the object represented by this {@code Class}.  This method is\n     * the dynamic equivalent of the Java language {@code instanceof}\n     * operator. The method returns {@code true} if the specified\n     * {@code Object} argument is non-null and can be cast to the\n     * reference type represented by this {@code Class} object without\n     * raising a {@code ClassCastException.} It returns {@code false}\n     * otherwise.\n     *\n     * <p> Specifically, if this {@code Class} object represents a\n     * declared class, this method returns {@code true} if the specified\n     * {@code Object} argument is an instance of the represented class (or\n     * of any of its subclasses); it returns {@code false} otherwise. If\n     * this {@code Class} object represents an array class, this method\n     * returns {@code true} if the specified {@code Object} argument\n     * can be converted to an object of the array class by an identity\n     * conversion or by a widening reference conversion; it returns\n     * {@code false} otherwise. If this {@code Class} object\n     * represents an interface, this method returns {@code true} if the\n     * class or any superclass of the specified {@code Object} argument\n     * implements this interface; it returns {@code false} otherwise. If\n     * this {@code Class} object represents a primitive type, this method\n     * returns {@code false}.\n     *\n     * @param   obj the object to check\n     * @return  true if {@code obj} is an instance of this class\n     *\n     * @since 1.1\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean isAssignableFrom(Class<?> cls)",
    "returnType" : "boolean",
    "comment" : "\n     * Determines if the class or interface represented by this\n     * {@code Class} object is either the same as, or is a superclass or\n     * superinterface of, the class or interface represented by the specified\n     * {@code Class} parameter. It returns {@code true} if so;\n     * otherwise it returns {@code false}. If this {@code Class}\n     * object represents a primitive type, this method returns\n     * {@code true} if the specified {@code Class} parameter is\n     * exactly this {@code Class} object; otherwise it returns\n     * {@code false}.\n     *\n     * <p> Specifically, this method tests whether the type represented by the\n     * specified {@code Class} parameter can be converted to the type\n     * represented by this {@code Class} object via an identity conversion\n     * or via a widening reference conversion. See <cite>The Java Language\n     * Specification</cite>, sections {@jls 5.1.1} and {@jls 5.1.4},\n     * for details.\n     *\n     * @param     cls the {@code Class} object to be checked\n     * @return    the {@code boolean} value indicating whether objects of the\n     *            type {@code cls} can be assigned to objects of this class\n     * @throws    NullPointerException if the specified Class parameter is\n     *            null.\n     * @since     1.1\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean isInterface()",
    "returnType" : "boolean",
    "comment" : "\n     * Determines if this {@code Class} object represents an\n     * interface type.\n     *\n     * @return  {@code true} if this {@code Class} object represents an interface;\n     *          {@code false} otherwise.\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean isArray()",
    "returnType" : "boolean",
    "comment" : "\n     * Determines if this {@code Class} object represents an array class.\n     *\n     * @return  {@code true} if this {@code Class} object represents an array class;\n     *          {@code false} otherwise.\n     * @since   1.1\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean isPrimitive()",
    "returnType" : "boolean",
    "comment" : "\n     * Determines if the specified {@code Class} object represents a\n     * primitive type.\n     *\n     * <p> There are nine predefined {@code Class} objects to represent\n     * the eight primitive types and void.  These are created by the Java\n     * Virtual Machine, and have the same names as the primitive types that\n     * they represent, namely {@code boolean}, {@code byte},\n     * {@code char}, {@code short}, {@code int},\n     * {@code long}, {@code float}, and {@code double}.\n     *\n     * <p> These objects may only be accessed via the following public static\n     * final variables, and are the only {@code Class} objects for which\n     * this method returns {@code true}.\n     *\n     * @return true if and only if this class represents a primitive type\n     *\n     * @see     java.lang.Boolean#TYPE\n     * @see     java.lang.Character#TYPE\n     * @see     java.lang.Byte#TYPE\n     * @see     java.lang.Short#TYPE\n     * @see     java.lang.Integer#TYPE\n     * @see     java.lang.Long#TYPE\n     * @see     java.lang.Float#TYPE\n     * @see     java.lang.Double#TYPE\n     * @see     java.lang.Void#TYPE\n     * @since 1.1\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean isFinalizable()",
    "returnType" : "boolean",
    "comment" : "\n     * Indicates whether this {@code Class} or its parents override finalize.\n     *\n     * @return {@code true} if and if this class or its parents override\n     *         finalize;\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean isAnnotation()",
    "returnType" : "boolean",
    "comment" : "\n     * Returns true if this {@code Class} object represents an annotation\n     * interface.  Note that if this method returns true, {@link #isInterface()}\n     * would also return true, as all annotation interfaces are also interfaces.\n     *\n     * @return {@code true} if this {@code Class} object represents an annotation\n     *      interface; {@code false} otherwise\n     * @since 1.5\n     ",
    "links" : [ "#isInterface()" ]
  }, {
    "name" : "public boolean isSynthetic()",
    "returnType" : "boolean",
    "comment" : "\n     *{@return {@code true} if and only if this class has the synthetic modifier\n     * bit set}\n     *\n     * @jls 13.1 The Form of a Binary\n     * @jvms 4.1 The {@code ClassFile} Structure\n     * @see <a\n     * href=\"{@docRoot}/java.base/java/lang/reflect/package-summary.html#LanguageJvmModel\">Java\n     * programming language and JVM modeling in core reflection</a>\n     * @since 1.5\n     ",
    "links" : [ ]
  }, {
    "name" : "public String getName()",
    "returnType" : "String",
    "comment" : "\n     * Returns the  name of the entity (class, interface, array class,\n     * primitive type, or void) represented by this {@code Class} object.\n     *\n     * <p> If this {@code Class} object represents a class or interface,\n     * not an array class, then:\n     *\n     * <p> If this {@code Class} object represents an array class, then\n     * the result is a string consisting of one or more '{@code [}' characters\n     * representing the depth of the array nesting, followed by the element\n     * type as encoded using the following table:\n     *\n     * <blockquote><table class=\"striped\">\n     * <caption style=\"display:none\">Element types and encodings</caption>\n     * <thead>\n     * <tr><th scope=\"col\"> Element Type <th scope=\"col\"> Encoding\n     * </thead>\n     * <tbody style=\"text-align:left\">\n     * <tr><th scope=\"row\"> {@code boolean} <td style=\"text-align:center\"> {@code Z}\n     * <tr><th scope=\"row\"> {@code byte}    <td style=\"text-align:center\"> {@code B}\n     * <tr><th scope=\"row\"> {@code char}    <td style=\"text-align:center\"> {@code C}\n     * <tr><th scope=\"row\"> class or interface with <a href=\"ClassLoader.html#binary-name\">binary name</a> <i>N</i>\n     *                                      <td style=\"text-align:center\"> {@code L}<em>N</em>{@code ;}\n     * <tr><th scope=\"row\"> {@code double}  <td style=\"text-align:center\"> {@code D}\n     * <tr><th scope=\"row\"> {@code float}   <td style=\"text-align:center\"> {@code F}\n     * <tr><th scope=\"row\"> {@code int}     <td style=\"text-align:center\"> {@code I}\n     * <tr><th scope=\"row\"> {@code long}    <td style=\"text-align:center\"> {@code J}\n     * <tr><th scope=\"row\"> {@code short}   <td style=\"text-align:center\"> {@code S}\n     * </tbody>\n     * </table></blockquote>\n     *\n     * <p> If this {@code Class} object represents a primitive type or {@code void},\n     * then the result is a string with the same spelling as the Java language\n     * keyword which corresponds to the primitive type or {@code void}.\n     *\n     * <p> Examples:\n     * <blockquote><pre>\n     * String.class.getName()\n     *     returns \"java.lang.String\"\n     * byte.class.getName()\n     *     returns \"byte\"\n     * (new Object[3]).getClass().getName()\n     *     returns \"[Ljava.lang.Object;\"\n     * (new int[3][4][5][6][7][8][9]).getClass().getName()\n     *     returns \"[[[[[[[I\"\n     * </pre></blockquote>\n     *\n     * @return  the name of the class, interface, or other entity\n     *          represented by this {@code Class} object.\n     * @jls 13.1 The Form of a Binary\n     ",
    "links" : [ ]
  }, {
    "name" : "private native String getNameNative()",
    "returnType" : "String",
    "comment" : " private native String initClassName();",
    "links" : [ ]
  }, {
    "name" : "public ClassLoader getClassLoader()",
    "returnType" : "ClassLoader",
    "comment" : " @ForceInline // to ensure Reflection.getCallerClass optimization",
    "links" : [ ]
  }, {
    "name" : "public synchronized TypeVariable<Class<T>>[] getTypeParameters()",
    "returnType" : "TypeVariable<Class<T>>[]",
    "comment" : "\n     * Returns an array of {@code TypeVariable} objects that represent the\n     * type variables declared by the generic declaration represented by this\n     * {@code GenericDeclaration} object, in declaration order.  Returns an\n     * array of length 0 if the underlying generic declaration declares no type\n     * variables.\n     *\n     * @return an array of {@code TypeVariable} objects that represent\n     *     the type variables declared by this generic declaration\n     * @throws java.lang.reflect.GenericSignatureFormatError if the generic\n     *     signature of this generic declaration does not conform to\n     *     the format specified in section {@jvms 4.7.9} of\n     *     <cite>The Java Virtual Machine Specification</cite>\n     * @since 1.5\n     ",
    "links" : [ ]
  }, {
    "name" : "public Class<? super T> getSuperclass()",
    "returnType" : "Class<? super T>",
    "comment" : "\n     * Returns the {@code Class} representing the direct superclass of the\n     * entity (class, interface, primitive type or void) represented by\n     * this {@code Class}.  If this {@code Class} represents either the\n     * {@code Object} class, an interface, a primitive type, or void, then\n     * null is returned.  If this {@code Class} object represents an array class\n     * then the {@code Class} object representing the {@code Object} class is\n     * returned.\n     *\n     * @return the direct superclass of the class represented by this {@code Class} object\n     ",
    "links" : [ ]
  }, {
    "name" : "public Type getGenericSuperclass()",
    "returnType" : "Type",
    "comment" : "\n     * Returns the {@code Type} representing the direct superclass of\n     * the entity (class, interface, primitive type or void) represented by\n     * this {@code Class} object.\n     *\n     * <p>If the superclass is a parameterized type, the {@code Type}\n     * object returned must accurately reflect the actual type\n     * arguments used in the source code. The parameterized type\n     * representing the superclass is created if it had not been\n     * created before. See the declaration of {@link\n     * java.lang.reflect.ParameterizedType ParameterizedType} for the\n     * semantics of the creation process for parameterized types.  If\n     * this {@code Class} object represents either the {@code Object}\n     * class, an interface, a primitive type, or void, then null is\n     * returned.  If this {@code Class} object represents an array class\n     * then the {@code Class} object representing the {@code Object} class is\n     * returned.\n     *\n     * @throws java.lang.reflect.GenericSignatureFormatError if the generic\n     *     class signature does not conform to the format specified in\n     *     section {@jvms 4.7.9} of <cite>The Java Virtual\n     *     Machine Specification</cite>\n     * @throws TypeNotPresentException if the generic superclass\n     *     refers to a non-existent type declaration\n     * @throws java.lang.reflect.MalformedParameterizedTypeException if the\n     *     generic superclass refers to a parameterized type that cannot be\n     *     instantiated  for any reason\n     * @return the direct superclass of the class represented by this {@code Class} object\n     * @since 1.5\n     ",
    "links" : [ "java.lang.reflect.ParameterizedType" ]
  }, {
    "name" : "public Package getPackage()",
    "returnType" : "Package",
    "comment" : "\n     * Gets the package of this class.\n     *\n     * <p>If this class represents an array type, a primitive type or void,\n     * this method returns {@code null}.\n     *\n     * @return the package of this class.\n     * @revised 9\n     ",
    "links" : [ ]
  }, {
    "name" : "public String getPackageName()",
    "returnType" : "String",
    "comment" : "\n     * Returns the fully qualified package name.\n     *\n     * <p> If this class is a top level class, then this method returns the fully\n     * qualified name of the package that the class is a member of, or the\n     * empty string if the class is in an unnamed package.\n     *\n     * <p> If this class is a member class, then this method is equivalent to\n     * invoking {@code getPackageName()} on the {@linkplain #getEnclosingClass\n     * enclosing class}.\n     *\n     * <p> If this class is a {@linkplain #isLocalClass local class} or an {@linkplain\n     * #isAnonymousClass() anonymous class}, then this method is equivalent to\n     * invoking {@code getPackageName()} on the {@linkplain #getDeclaringClass\n     * declaring class} of the {@linkplain #getEnclosingMethod enclosing method} or\n     * {@linkplain #getEnclosingConstructor enclosing constructor}.\n     *\n     * <p> If this class represents an array type then this method returns the\n     * package name of the element type. If this class represents a primitive\n     * type or void then the package name \"{@code java.lang}\" is returned.\n     *\n     * @return the fully qualified package name\n     *\n     * @since 9\n     * @jls 6.7 Fully Qualified Names\n     ",
    "links" : [ ]
  }, {
    "name" : "public Class<?>[] getInterfaces()",
    "returnType" : "Class<?>[]",
    "comment" : "\n     * Returns the interfaces directly implemented by the class or interface\n     * represented by this {@code Class} object.\n     *\n     * <p>If this {@code Class} object represents a class, the return value is an array\n     * containing objects representing all interfaces directly implemented by\n     * the class.  The order of the interface objects in the array corresponds\n     * to the order of the interface names in the {@code implements} clause of\n     * the declaration of the class represented by this {@code Class} object.  For example,\n     * given the declaration:\n     * <blockquote>\n     * {@code class Shimmer implements FloorWax, DessertTopping { ... }}\n     * </blockquote>\n     * suppose the value of {@code s} is an instance of\n     * {@code Shimmer}; the value of the expression:\n     * <blockquote>\n     * {@code s.getClass().getInterfaces()[0]}\n     * </blockquote>\n     * is the {@code Class} object that represents interface\n     * {@code FloorWax}; and the value of:\n     * <blockquote>\n     * {@code s.getClass().getInterfaces()[1]}\n     * </blockquote>\n     * is the {@code Class} object that represents interface\n     * {@code DessertTopping}.\n     *\n     * <p>If this {@code Class} object represents an interface, the array contains objects\n     * representing all interfaces directly extended by the interface.  The\n     * order of the interface objects in the array corresponds to the order of\n     * the interface names in the {@code extends} clause of the declaration of\n     * the interface represented by this {@code Class} object.\n     *\n     * <p>If this {@code Class} object represents a class or interface that implements no\n     * interfaces, the method returns an array of length 0.\n     *\n     * <p>If this {@code Class} object represents a primitive type or void, the method\n     * returns an array of length 0.\n     *\n     * <p>If this {@code Class} object represents an array type, the\n     * interfaces {@code Cloneable} and {@code java.io.Serializable} are\n     * returned in that order.\n     *\n     * @return an array of interfaces directly implemented by this class\n     ",
    "links" : [ ]
  }, {
    "name" : "private native Class<?>[] getInterfacesInternal()",
    "returnType" : "Class<?>[]",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public Type[] getGenericInterfaces()",
    "returnType" : "Type[]",
    "comment" : "\n     * Returns the {@code Type}s representing the interfaces\n     * directly implemented by the class or interface represented by\n     * this {@code Class} object.\n     *\n     * <p>If a superinterface is a parameterized type, the\n     * {@code Type} object returned for it must accurately reflect\n     * the actual type arguments used in the source code. The\n     * parameterized type representing each superinterface is created\n     * if it had not been created before. See the declaration of\n     * {@link java.lang.reflect.ParameterizedType ParameterizedType}\n     * for the semantics of the creation process for parameterized\n     * types.\n     *\n     * <p>If this {@code Class} object represents a class, the return value is an array\n     * containing objects representing all interfaces directly implemented by\n     * the class.  The order of the interface objects in the array corresponds\n     * to the order of the interface names in the {@code implements} clause of\n     * the declaration of the class represented by this {@code Class} object.\n     *\n     * <p>If this {@code Class} object represents an interface, the array contains objects\n     * representing all interfaces directly extended by the interface.  The\n     * order of the interface objects in the array corresponds to the order of\n     * the interface names in the {@code extends} clause of the declaration of\n     * the interface represented by this {@code Class} object.\n     *\n     * <p>If this {@code Class} object represents a class or interface that implements no\n     * interfaces, the method returns an array of length 0.\n     *\n     * <p>If this {@code Class} object represents a primitive type or void, the method\n     * returns an array of length 0.\n     *\n     * <p>If this {@code Class} object represents an array type, the\n     * interfaces {@code Cloneable} and {@code java.io.Serializable} are\n     * returned in that order.\n     *\n     * @throws java.lang.reflect.GenericSignatureFormatError\n     *     if the generic class signature does not conform to the\n     *     format specified in section {@jvms 4.7.9} of <cite>The\n     *     Java Virtual Machine Specification</cite>\n     * @throws TypeNotPresentException if any of the generic\n     *     superinterfaces refers to a non-existent type declaration\n     * @throws java.lang.reflect.MalformedParameterizedTypeException\n     *     if any of the generic superinterfaces refer to a parameterized\n     *     type that cannot be instantiated for any reason\n     * @return an array of interfaces directly implemented by this class\n     * @since 1.5\n     ",
    "links" : [ "java.lang.reflect.ParameterizedType" ]
  }, {
    "name" : "public Class<?> getComponentType()",
    "returnType" : "Class<?>",
    "comment" : "\n     * Returns the {@code Class} representing the component type of an\n     * array.  If this class does not represent an array class this method\n     * returns null.\n     *\n     * @return the {@code Class} representing the component type of this\n     * class if this class is an array\n     * @see     java.lang.reflect.Array\n     * @since 1.1\n     ",
    "links" : [ ]
  }, {
    "name" : "private Class<?> elementType()",
    "returnType" : "Class<?>",
    "comment" : "\n     * Returns the {@code Class} representing the element type of an array class.\n     * If this class does not represent an array class, then this method returns\n     * {@code null}.\n     ",
    "links" : [ ]
  }, {
    "name" : "public int getModifiers()",
    "returnType" : "int",
    "comment" : "\n     * Returns the Java language modifiers for this class or interface, encoded\n     * in an integer. The modifiers consist of the Java Virtual Machine's\n     * constants for {@code public}, {@code protected},\n     * {@code private}, {@code final}, {@code static},\n     * {@code abstract} and {@code interface}; they should be decoded\n     * using the methods of class {@code Modifier}.\n     *\n     * <p> If the underlying class is an array class, then its\n     * {@code public}, {@code private} and {@code protected}\n     * modifiers are the same as those of its component type.  If this\n     * {@code Class} object represents a primitive type or void, its\n     * {@code public} modifier is always {@code true}, and its\n     * {@code protected} and {@code private} modifiers are always\n     * {@code false}. If this {@code Class} object represents an array class, a\n     * primitive type or void, then its {@code final} modifier is always\n     * {@code true} and its interface modifier is always\n     * {@code false}. The values of its other modifiers are not determined\n     * by this specification.\n     *\n     * <p> The modifier encodings are defined in section {@jvms 4.1}\n     * of <cite>The Java Virtual Machine Specification</cite>.\n     *\n     * @return the {@code int} representing the modifiers for this class\n     * @see     java.lang.reflect.Modifier\n     * @see <a\n     * href=\"{@docRoot}/java.base/java/lang/reflect/package-summary.html#LanguageJvmModel\">Java\n     * programming language and JVM modeling in core reflection</a>\n     * @since 1.1\n     * @jls 8.1.1 Class Modifiers\n     * @jls 9.1.1. Interface Modifiers\n     ",
    "links" : [ ]
  }, {
    "name" : "public Object[] getSigners()",
    "returnType" : "Object[]",
    "comment" : "\n     * Gets the signers of this class.\n     *\n     * @return  the signers of this class, or null if there are no signers.  In\n     *          particular, this method returns null if this {@code Class} object represents\n     *          a primitive type or void.\n     * @since   1.1\n     ",
    "links" : [ ]
  }, {
    "name" : "private native Method getEnclosingMethodNative()",
    "returnType" : "Method",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public Method getEnclosingMethod()",
    "returnType" : "Method",
    "comment" : " Android-changed: Removed SecurityException.",
    "links" : [ ]
  }, {
    "name" : "public Constructor<?> getEnclosingConstructor()",
    "returnType" : "Constructor<?>",
    "comment" : " Android-changed: Removed SecurityException.",
    "links" : [ ]
  }, {
    "name" : "private native Constructor<?> getEnclosingConstructorNative()",
    "returnType" : "Constructor<?>",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private boolean classNameImpliesTopLevel()",
    "returnType" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public native Class<?> getDeclaringClass()",
    "returnType" : "Class<?>",
    "comment" : "\n    @CallerSensitive\n    public Class<?> getDeclaringClass() throws SecurityException {\n        final Class<?> candidate = getDeclaringClass0();\n\n        if (candidate != null) {\n            @SuppressWarnings(\"removal\")\n            SecurityManager sm = System.getSecurityManager();\n            if (sm != null) {\n                candidate.checkPackageAccess(sm,\n                    ClassLoader.getClassLoader(Reflection.getCallerClass()), true);\n            }\n        }\n        return candidate;\n    }\n\n    private native Class<?> getDeclaringClass0();\n    ",
    "links" : [ ]
  }, {
    "name" : "public native Class<?> getEnclosingClass()",
    "returnType" : "Class<?>",
    "comment" : "\n    @CallerSensitive\n    public Class<?> getEnclosingClass() throws SecurityException {\n        // There are five kinds of classes (or interfaces):\n        // a) Top level classes\n        // b) Nested classes (static member classes)\n        // c) Inner classes (non-static member classes)\n        // d) Local classes (named classes declared within a method)\n        // e) Anonymous classes\n\n\n        // JVM Spec 4.7.7: A class must have an EnclosingMethod\n        // attribute if and only if it is a local class or an\n        // anonymous class.\n        EnclosingMethodInfo enclosingInfo = getEnclosingMethodInfo();\n        Class<?> enclosingCandidate;\n\n        if (enclosingInfo == null) {\n            // This is a top level or a nested class or an inner class (a, b, or c)\n            enclosingCandidate = getDeclaringClass0();\n        } else {\n            Class<?> enclosingClass = enclosingInfo.getEnclosingClass();\n            // This is a local class or an anonymous class (d or e)\n            if (enclosingClass == this || enclosingClass == null)\n                throw new InternalError(\"Malformed enclosing method information\");\n            else\n                enclosingCandidate = enclosingClass;\n        }\n\n        if (enclosingCandidate != null) {\n            @SuppressWarnings(\"removal\")\n            SecurityManager sm = System.getSecurityManager();\n            if (sm != null) {\n                enclosingCandidate.checkPackageAccess(sm,\n                    ClassLoader.getClassLoader(Reflection.getCallerClass()), true);\n            }\n        }\n        return enclosingCandidate;\n    }\n    ",
    "links" : [ ]
  }, {
    "name" : "public String getSimpleName()",
    "returnType" : "String",
    "comment" : "\n     * Returns the simple name of the underlying class as given in the\n     * source code. An empty string is returned if the underlying class is\n     * {@linkplain #isAnonymousClass() anonymous}.\n     * A {@linkplain #isSynthetic() synthetic class}, one not present\n     * in source code, can have a non-empty name including special\n     * characters, such as \"{@code $}\".\n     *\n     * <p>The simple name of an {@linkplain #isArray() array class} is the simple name of the\n     * component type with \"[]\" appended.  In particular the simple\n     * name of an array class whose component type is anonymous is \"[]\".\n     *\n     * @return the simple name of the underlying class\n     * @since 1.5\n     ",
    "links" : [ ]
  }, {
    "name" : "public String getTypeName()",
    "returnType" : "String",
    "comment" : "\n     * Return an informative string for the name of this class or interface.\n     *\n     * @return an informative string for the name of this class or interface\n     * @since 1.8\n     ",
    "links" : [ ]
  }, {
    "name" : "public String getCanonicalName()",
    "returnType" : "String",
    "comment" : "\n     * Returns the canonical name of the underlying class as\n     * defined by <cite>The Java Language Specification</cite>.\n     * Returns {@code null} if the underlying class does not have a canonical\n     * name. Classes without canonical names include:\n     * <ul>\n     * <li>a {@linkplain #isLocalClass() local class}\n     * <li>a {@linkplain #isAnonymousClass() anonymous class}\n     * <li>an array whose component type does not have a canonical name</li>\n     * </ul>\n     *\n     * @return the canonical name of the underlying class if it exists, and\n     * {@code null} otherwise.\n     * @since 1.5\n     ",
    "links" : [ ]
  }, {
    "name" : "public native boolean isAnonymousClass()",
    "returnType" : "boolean",
    "comment" : "\n    public boolean isAnonymousClass() {\n        return !isArray() && isLocalOrAnonymousClass() &&\n                getSimpleBinaryName0() == null;\n    }\n    ",
    "links" : [ ]
  }, {
    "name" : "public boolean isLocalClass()",
    "returnType" : "boolean",
    "comment" : "\n     * Returns {@code true} if and only if the underlying class\n     * is a local class.\n     *\n     * @return {@code true} if and only if this class is a local class.\n     * @since 1.5\n     * @jls 14.3 Local Class Declarations\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean isMemberClass()",
    "returnType" : "boolean",
    "comment" : "\n     * Returns {@code true} if and only if the underlying class\n     * is a member class.\n     *\n     * @return {@code true} if and only if this class is a member class.\n     * @since 1.5\n     * @jls 8.5 Member Type Declarations\n     ",
    "links" : [ ]
  }, {
    "name" : "private boolean isTopLevelClass()",
    "returnType" : "boolean",
    "comment" : "\n     * Returns {@code true} if this is a top level class.  Returns {@code false}\n     * otherwise.\n     ",
    "links" : [ ]
  }, {
    "name" : "private boolean isLocalOrAnonymousClass()",
    "returnType" : "boolean",
    "comment" : "\n     * Returns {@code true} if this is a local class or an anonymous\n     * class.  Returns {@code false} otherwise.\n     ",
    "links" : [ ]
  }, {
    "name" : "public Class<?>[] getClasses()",
    "returnType" : "Class<?>[]",
    "comment" : "\n     * Returns an array containing {@code Class} objects representing all\n     * the public classes and interfaces that are members of the class\n     * represented by this {@code Class} object.  This includes public\n     * class and interface members inherited from superclasses and public class\n     * and interface members declared by the class.  This method returns an\n     * array of length 0 if this {@code Class} object has no public member\n     * classes or interfaces.  This method also returns an array of length 0 if\n     * this {@code Class} object represents a primitive type, an array\n     * class, or void.\n     *\n     * @return the array of {@code Class} objects representing the public\n     *         members of this class\n     *\n     * @since 1.1\n     ",
    "links" : [ ]
  }, {
    "name" : "public Field[] getFields() throws SecurityException",
    "returnType" : "Field[]",
    "comment" : "\n     * Returns an array containing {@code Field} objects reflecting all\n     * the accessible public fields of the class or interface represented by\n     * this {@code Class} object.\n     *\n     * <p> If this {@code Class} object represents a class or interface with\n     * no accessible public fields, then this method returns an array of length\n     * 0.\n     *\n     * <p> If this {@code Class} object represents a class, then this method\n     * returns the public fields of the class and of all its superclasses and\n     * superinterfaces.\n     *\n     * <p> If this {@code Class} object represents an interface, then this\n     * method returns the fields of the interface and of all its\n     * superinterfaces.\n     *\n     * <p> If this {@code Class} object represents an array type, a primitive\n     * type, or void, then this method returns an array of length 0.\n     *\n     * <p> The elements in the returned array are not sorted and are not in any\n     * particular order.\n     *\n     * @return the array of {@code Field} objects representing the\n     *         public fields\n     * @throws SecurityException\n     *         If a security manager, <i>s</i>, is present and\n     *         the caller's class loader is not the same as or an\n     *         ancestor of the class loader for the current class and\n     *         invocation of {@link SecurityManager#checkPackageAccess\n     *         s.checkPackageAccess()} denies access to the package\n     *         of this class.\n     *\n     * @since 1.1\n     * @jls 8.2 Class Members\n     * @jls 8.3 Field Declarations\n     ",
    "links" : [ "java.lang.SecurityManager#checkPackageAccesss.checkPackageAccess()" ]
  }, {
    "name" : "private void getPublicFieldsRecursive(List<Field> result)",
    "returnType" : "void",
    "comment" : "\n     * Populates {@code result} with public fields defined by this class, its\n     * superclasses, and all implemented interfaces.\n     ",
    "links" : [ ]
  }, {
    "name" : "public Method[] getMethods() throws SecurityException",
    "returnType" : "Method[]",
    "comment" : "\n     * Returns an array containing {@code Method} objects reflecting all the\n     * public methods of the class or interface represented by this {@code\n     * Class} object, including those declared by the class or interface and\n     * those inherited from superclasses and superinterfaces.\n     *\n     * <p> If this {@code Class} object represents an array type, then the\n     * returned array has a {@code Method} object for each of the public\n     * methods inherited by the array type from {@code Object}. It does not\n     * contain a {@code Method} object for {@code clone()}.\n     *\n     * <p> If this {@code Class} object represents an interface then the\n     * returned array does not contain any implicitly declared methods from\n     * {@code Object}. Therefore, if no methods are explicitly declared in\n     * this interface or any of its superinterfaces then the returned array\n     * has length 0. (Note that a {@code Class} object which represents a class\n     * always has public methods, inherited from {@code Object}.)\n     *\n     * <p> The returned array never contains methods with names \"{@code <init>}\"\n     * or \"{@code <clinit>}\".\n     *\n     * <p> The elements in the returned array are not sorted and are not in any\n     * particular order.\n     *\n     * <p> Generally, the result is computed as with the following 4 step algorithm.\n     * Let C be the class or interface represented by this {@code Class} object:\n     * <ol>\n     * <li> A union of methods is composed of:\n     *   <ol type=\"a\">\n     *   <li> C's declared public instance and static methods as returned by\n     *        {@link #getDeclaredMethods()} and filtered to include only public\n     *        methods.</li>\n     *   <li> If C is a class other than {@code Object}, then include the result\n     *        of invoking this algorithm recursively on the superclass of C.</li>\n     *   <li> Include the results of invoking this algorithm recursively on all\n     *        direct superinterfaces of C, but include only instance methods.</li>\n     *   </ol></li>\n     * <li> Union from step 1 is partitioned into subsets of methods with same\n     *      signature (name, parameter types) and return type.</li>\n     * <li> Within each such subset only the most specific methods are selected.\n     *      Let method M be a method from a set of methods with same signature\n     *      and return type. M is most specific if there is no such method\n     *      N != M from the same set, such that N is more specific than M.\n     *      N is more specific than M if:\n     *   <ol type=\"a\">\n     *   <li> N is declared by a class and M is declared by an interface; or</li>\n     *   <li> N and M are both declared by classes or both by interfaces and\n     *        N's declaring type is the same as or a subtype of M's declaring type\n     *        (clearly, if M's and N's declaring types are the same type, then\n     *        M and N are the same method).</li>\n     *   </ol></li>\n     * <li> The result of this algorithm is the union of all selected methods from\n     *      step 3.</li>\n     * </ol>\n     *\n     * @apiNote There may be more than one method with a particular name\n     * and parameter types in a class because while the Java language forbids a\n     * class to declare multiple methods with the same signature but different\n     * return types, the Java virtual machine does not.  This\n     * increased flexibility in the virtual machine can be used to\n     * implement various language features.  For example, covariant\n     * returns can be implemented with {@linkplain\n     * java.lang.reflect.Method#isBridge bridge methods}; the bridge\n     * method and the overriding method would have the same\n     * signature but different return types.\n     *\n     * @return the array of {@code Method} objects representing the\n     *         public methods of this class\n     * @throws SecurityException\n     *         If a security manager, <i>s</i>, is present and\n     *         the caller's class loader is not the same as or an\n     *         ancestor of the class loader for the current class and\n     *         invocation of {@link SecurityManager#checkPackageAccess\n     *         s.checkPackageAccess()} denies access to the package\n     *         of this class.\n     *\n     * @jls 8.2 Class Members\n     * @jls 8.4 Method Declarations\n     * @since 1.1\n     ",
    "links" : [ "#getDeclaredMethods()", "java.lang.SecurityManager#checkPackageAccesss.checkPackageAccess()" ]
  }, {
    "name" : "private void getPublicMethodsInternal(List<Method> result)",
    "returnType" : "void",
    "comment" : "\n     * Populates {@code result} with public methods defined by this class, its\n     * superclasses, and all implemented interfaces, including overridden methods.\n     ",
    "links" : [ ]
  }, {
    "name" : "public Constructor<?>[] getConstructors() throws SecurityException",
    "returnType" : "Constructor<?>[]",
    "comment" : "\n     * Returns an array containing {@code Constructor} objects reflecting\n     * all the public constructors of the class represented by this\n     * {@code Class} object.  An array of length 0 is returned if the\n     * class has no public constructors, or if the class is an array class, or\n     * if the class reflects a primitive type or void.\n     *\n     * @apiNote\n     * While this method returns an array of {@code\n     * Constructor<T>} objects (that is an array of constructors from\n     * this class), the return type of this method is {@code\n     * Constructor<?>[]} and <em>not</em> {@code Constructor<T>[]} as\n     * might be expected.  This less informative return type is\n     * necessary since after being returned from this method, the\n     * array could be modified to hold {@code Constructor} objects for\n     * different classes, which would violate the type guarantees of\n     * {@code Constructor<T>[]}.\n     *\n     * @return the array of {@code Constructor} objects representing the\n     *         public constructors of this class\n     * @throws SecurityException\n     *         If a security manager, <i>s</i>, is present and\n     *         the caller's class loader is not the same as or an\n     *         ancestor of the class loader for the current class and\n     *         invocation of {@link SecurityManager#checkPackageAccess\n     *         s.checkPackageAccess()} denies access to the package\n     *         of this class.\n     *\n     * @since 1.1\n     ",
    "links" : [ "java.lang.SecurityManager#checkPackageAccesss.checkPackageAccess()" ]
  }, {
    "name" : "public Field getField(String name) throws NoSuchFieldException",
    "returnType" : "Field",
    "comment" : " Android-changed: Removed SecurityException.",
    "links" : [ ]
  }, {
    "name" : "private native Field getPublicFieldRecursive(String name)",
    "returnType" : "Field",
    "comment" : "\n     * The native implementation of the {@code getField} method.\n     *\n     * @throws NullPointerException\n     *            if name is null.\n     * @see #getField(String)\n     ",
    "links" : [ ]
  }, {
    "name" : "public Method getMethod(String name, Class<?>... parameterTypes) throws NoSuchMethodException, SecurityException",
    "returnType" : "Method",
    "comment" : "\n     * Returns a {@code Method} object that reflects the specified public\n     * member method of the class or interface represented by this\n     * {@code Class} object. The {@code name} parameter is a\n     * {@code String} specifying the simple name of the desired method. The\n     * {@code parameterTypes} parameter is an array of {@code Class}\n     * objects that identify the method's formal parameter types, in declared\n     * order. If {@code parameterTypes} is {@code null}, it is\n     * treated as if it were an empty array.\n     *\n     * <p> If this {@code Class} object represents an array type, then this\n     * method finds any public method inherited by the array type from\n     * {@code Object} except method {@code clone()}.\n     *\n     * <p> If this {@code Class} object represents an interface then this\n     * method does not find any implicitly declared method from\n     * {@code Object}. Therefore, if no methods are explicitly declared in\n     * this interface or any of its superinterfaces, then this method does not\n     * find any method.\n     *\n     * <p> This method does not find any method with name \"{@code <init>}\" or\n     * \"{@code <clinit>}\".\n     *\n     * <p> Generally, the method to be reflected is determined by the 4 step\n     * algorithm that follows.\n     * Let C be the class or interface represented by this {@code Class} object:\n     * <ol>\n     * <li> A union of methods is composed of:\n     *   <ol type=\"a\">\n     *   <li> C's declared public instance and static methods as returned by\n     *        {@link #getDeclaredMethods()} and filtered to include only public\n     *        methods that match given {@code name} and {@code parameterTypes}</li>\n     *   <li> If C is a class other than {@code Object}, then include the result\n     *        of invoking this algorithm recursively on the superclass of C.</li>\n     *   <li> Include the results of invoking this algorithm recursively on all\n     *        direct superinterfaces of C, but include only instance methods.</li>\n     *   </ol></li>\n     * <li> This union is partitioned into subsets of methods with same\n     *      return type (the selection of methods from step 1 also guarantees that\n     *      they have the same method name and parameter types).</li>\n     * <li> Within each such subset only the most specific methods are selected.\n     *      Let method M be a method from a set of methods with same VM\n     *      signature (return type, name, parameter types).\n     *      M is most specific if there is no such method N != M from the same\n     *      set, such that N is more specific than M. N is more specific than M\n     *      if:\n     *   <ol type=\"a\">\n     *   <li> N is declared by a class and M is declared by an interface; or</li>\n     *   <li> N and M are both declared by classes or both by interfaces and\n     *        N's declaring type is the same as or a subtype of M's declaring type\n     *        (clearly, if M's and N's declaring types are the same type, then\n     *        M and N are the same method).</li>\n     *   </ol></li>\n     * <li> The result of this algorithm is chosen arbitrarily from the methods\n     *      with most specific return type among all selected methods from step 3.\n     *      Let R be a return type of a method M from the set of all selected methods\n     *      from step 3. M is a method with most specific return type if there is\n     *      no such method N != M from the same set, having return type S != R,\n     *      such that S is a subtype of R as determined by\n     *      R.class.{@link #isAssignableFrom}(S.class).\n     * </ol>\n     *\n     * @apiNote There may be more than one method with matching name and\n     * parameter types in a class because while the Java language forbids a\n     * class to declare multiple methods with the same signature but different\n     * return types, the Java virtual machine does not.  This\n     * increased flexibility in the virtual machine can be used to\n     * implement various language features.  For example, covariant\n     * returns can be implemented with {@linkplain\n     * java.lang.reflect.Method#isBridge bridge methods}; the bridge\n     * method and the overriding method would have the same\n     * signature but different return types. This method would return the\n     * overriding method as it would have a more specific return type.\n     *\n     * @param name the name of the method\n     * @param parameterTypes the list of parameters\n     * @return the {@code Method} object that matches the specified\n     *         {@code name} and {@code parameterTypes}\n     * @throws NoSuchMethodException if a matching method is not found\n     *         or if the name is \"&lt;init&gt;\"or \"&lt;clinit&gt;\".\n     * @throws NullPointerException if {@code name} is {@code null}\n     * @throws SecurityException\n     *         If a security manager, <i>s</i>, is present and\n     *         the caller's class loader is not the same as or an\n     *         ancestor of the class loader for the current class and\n     *         invocation of {@link SecurityManager#checkPackageAccess\n     *         s.checkPackageAccess()} denies access to the package\n     *         of this class.\n     *\n     * @jls 8.2 Class Members\n     * @jls 8.4 Method Declarations\n     * @since 1.1\n     ",
    "links" : [ "#getDeclaredMethods()", "java.lang.SecurityManager#checkPackageAccesss.checkPackageAccess()", "#isAssignableFrom" ]
  }, {
    "name" : "public Constructor<T> getConstructor(Class<?>... parameterTypes) throws NoSuchMethodException, SecurityException",
    "returnType" : "Constructor<T>",
    "comment" : "\n     * Returns a {@code Constructor} object that reflects the specified\n     * public constructor of the class represented by this {@code Class}\n     * object. The {@code parameterTypes} parameter is an array of\n     * {@code Class} objects that identify the constructor's formal\n     * parameter types, in declared order.\n     *\n     * If this {@code Class} object represents an inner class\n     * declared in a non-static context, the formal parameter types\n     * include the explicit enclosing instance as the first parameter.\n     *\n     * <p> The constructor to reflect is the public constructor of the class\n     * represented by this {@code Class} object whose formal parameter\n     * types match those specified by {@code parameterTypes}.\n     *\n     * @param parameterTypes the parameter array\n     * @return the {@code Constructor} object of the public constructor that\n     *         matches the specified {@code parameterTypes}\n     * @throws NoSuchMethodException if a matching method is not found.\n     * @throws SecurityException\n     *         If a security manager, <i>s</i>, is present and\n     *         the caller's class loader is not the same as or an\n     *         ancestor of the class loader for the current class and\n     *         invocation of {@link SecurityManager#checkPackageAccess\n     *         s.checkPackageAccess()} denies access to the package\n     *         of this class.\n     *\n     * @since 1.1\n     ",
    "links" : [ "java.lang.SecurityManager#checkPackageAccesss.checkPackageAccess()" ]
  }, {
    "name" : "public native Class<?>[] getDeclaredClasses()",
    "returnType" : "Class<?>[]",
    "comment" : "\n    @CallerSensitive\n    public Class<?>[] getDeclaredClasses() throws SecurityException {\n        @SuppressWarnings(\"removal\")\n        SecurityManager sm = System.getSecurityManager();\n        if (sm != null) {\n            checkMemberAccess(sm, Member.DECLARED, Reflection.getCallerClass(), false);\n        }\n        return getDeclaredClasses0();\n    }\n    ",
    "links" : [ ]
  }, {
    "name" : "public native Field[] getDeclaredFields()",
    "returnType" : "Field[]",
    "comment" : "\n    @CallerSensitive\n    public Field[] getDeclaredFields() throws SecurityException {\n        @SuppressWarnings(\"removal\")\n        SecurityManager sm = System.getSecurityManager();\n        if (sm != null) {\n            checkMemberAccess(sm, Member.DECLARED, Reflection.getCallerClass(), true);\n        }\n        return copyFields(privateGetDeclaredFields(false));\n    }\n    ",
    "links" : [ ]
  }, {
    "name" : "public RecordComponent[] getRecordComponents()",
    "returnType" : "RecordComponent[]",
    "comment" : "\n     * Returns an array of {@code RecordComponent} objects representing all the\n     * record components of this record class, or {@code null} if this class is\n     * not a record class.\n     *\n     * <p> The components are returned in the same order that they are declared\n     * in the record header. The array is empty if this record class has no\n     * components. If the class is not a record class, that is {@link\n     * #isRecord()} returns {@code false}, then this method returns {@code null}.\n     * Conversely, if {@link #isRecord()} returns {@code true}, then this method\n     * returns a non-null value.\n     *\n     * @apiNote\n     * <p> The following method can be used to find the record canonical constructor:\n     *\n     * <pre>{@code\n     * static <T extends Record> Constructor<T> getCanonicalConstructor(Class<T> cls)\n     *     throws NoSuchMethodException {\n     *   Class<?>[] paramTypes =\n     *     Arrays.stream(cls.getRecordComponents())\n     *           .map(RecordComponent::getType)\n     *           .toArray(Class<?>[]::new);\n     *   return cls.getDeclaredConstructor(paramTypes);\n     * }}</pre>\n     *\n     * @return  An array of {@code RecordComponent} objects representing all the\n     *          record components of this record class, or {@code null} if this\n     *          class is not a record class\n     * @throws  SecurityException\n     *          If a security manager, <i>s</i>, is present and any of the\n     *          following conditions is met:\n     *\n     *          <ul>\n     *\n     *          <li> the caller's class loader is not the same as the\n     *          class loader of this class and invocation of\n     *          {@link SecurityManager#checkPermission\n     *          s.checkPermission} method with\n     *          {@code RuntimePermission(\"accessDeclaredMembers\")}\n     *          denies access to the declared methods within this class\n     *\n     *          <li> the caller's class loader is not the same as or an\n     *          ancestor of the class loader for the current class and\n     *          invocation of {@link SecurityManager#checkPackageAccess\n     *          s.checkPackageAccess()} denies access to the package\n     *          of this class\n     *\n     *          </ul>\n     *\n     * @jls 8.10 Record Classes\n     * @since 16\n     ",
    "links" : [ "#isRecord()", "java.lang.SecurityManager#checkPackageAccesss.checkPackageAccess()", "java.lang.SecurityManager#checkPermissions.checkPermission" ]
  }, {
    "name" : "public native Field[] getDeclaredFieldsUnchecked(boolean publicOnly)",
    "returnType" : "Field[]",
    "comment" : "\n     * Populates a list of fields without performing any security or type\n     * resolution checks first. If no fields exist, the list is not modified.\n     *\n     * @param publicOnly Whether to return only public fields.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public Method[] getDeclaredMethods() throws SecurityException",
    "returnType" : "Method[]",
    "comment" : "\n     * Returns an array containing {@code Method} objects reflecting all the\n     * declared methods of the class or interface represented by this {@code\n     * Class} object, including public, protected, default (package)\n     * access, and private methods, but excluding inherited methods.\n     * The declared methods may include methods <em>not</em> in the\n     * source of the class or interface, including {@linkplain\n     * Method#isBridge bridge methods} and other {@linkplain\n     * Executable#isSynthetic synthetic} methods added by compilers.\n     *\n     * <p> If this {@code Class} object represents a class or interface that\n     * has multiple declared methods with the same name and parameter types,\n     * but different return types, then the returned array has a {@code Method}\n     * object for each such method.\n     *\n     * <p> If this {@code Class} object represents a class or interface that\n     * has a class initialization method {@code <clinit>}, then the returned\n     * array does <em>not</em> have a corresponding {@code Method} object.\n     *\n     * <p> If this {@code Class} object represents a class or interface with no\n     * declared methods, then the returned array has length 0.\n     *\n     * <p> If this {@code Class} object represents an array type, a primitive\n     * type, or void, then the returned array has length 0.\n     *\n     * <p> The elements in the returned array are not sorted and are not in any\n     * particular order.\n     *\n     * @return  the array of {@code Method} objects representing all the\n     *          declared methods of this class\n     * @throws  SecurityException\n     *          If a security manager, <i>s</i>, is present and any of the\n     *          following conditions is met:\n     *\n     *          <ul>\n     *\n     *          <li> the caller's class loader is not the same as the\n     *          class loader of this class and invocation of\n     *          {@link SecurityManager#checkPermission\n     *          s.checkPermission} method with\n     *          {@code RuntimePermission(\"accessDeclaredMembers\")}\n     *          denies access to the declared methods within this class\n     *\n     *          <li> the caller's class loader is not the same as or an\n     *          ancestor of the class loader for the current class and\n     *          invocation of {@link SecurityManager#checkPackageAccess\n     *          s.checkPackageAccess()} denies access to the package\n     *          of this class\n     *\n     *          </ul>\n     *\n     * @jls 8.2 Class Members\n     * @jls 8.4 Method Declarations\n     * @see <a\n     * href=\"{@docRoot}/java.base/java/lang/reflect/package-summary.html#LanguageJvmModel\">Java\n     * programming language and JVM modeling in core reflection</a>\n     * @since 1.1\n     ",
    "links" : [ "java.lang.SecurityManager#checkPackageAccesss.checkPackageAccess()", "java.lang.SecurityManager#checkPermissions.checkPermission" ]
  }, {
    "name" : "public native Method[] getDeclaredMethodsUnchecked(boolean publicOnly)",
    "returnType" : "Method[]",
    "comment" : "\n     * Populates a list of methods without performing any security or type\n     * resolution checks first. If no methods exist, the list is not modified.\n     *\n     * @param publicOnly Whether to return only public methods.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public Constructor<?>[] getDeclaredConstructors() throws SecurityException",
    "returnType" : "Constructor<?>[]",
    "comment" : "\n     * Returns an array of {@code Constructor} objects reflecting all the\n     * constructors declared by the class represented by this\n     * {@code Class} object. These are public, protected, default\n     * (package) access, and private constructors.  The elements in the array\n     * returned are not sorted and are not in any particular order.  If the\n     * class has a default constructor, it is included in the returned array.\n     * This method returns an array of length 0 if this {@code Class}\n     * object represents an interface, a primitive type, an array class, or\n     * void.\n     *\n     * <p> See <cite>The Java Language Specification</cite>,\n     * section {@jls 8.2}.\n     *\n     * @return  the array of {@code Constructor} objects representing all the\n     *          declared constructors of this class\n     * @throws  SecurityException\n     *          If a security manager, <i>s</i>, is present and any of the\n     *          following conditions is met:\n     *\n     *          <ul>\n     *\n     *          <li> the caller's class loader is not the same as the\n     *          class loader of this class and invocation of\n     *          {@link SecurityManager#checkPermission\n     *          s.checkPermission} method with\n     *          {@code RuntimePermission(\"accessDeclaredMembers\")}\n     *          denies access to the declared constructors within this class\n     *\n     *          <li> the caller's class loader is not the same as or an\n     *          ancestor of the class loader for the current class and\n     *          invocation of {@link SecurityManager#checkPackageAccess\n     *          s.checkPackageAccess()} denies access to the package\n     *          of this class\n     *\n     *          </ul>\n     *\n     * @since 1.1\n     * @jls 8.8 Constructor Declarations\n     ",
    "links" : [ "java.lang.SecurityManager#checkPackageAccesss.checkPackageAccess()", "java.lang.SecurityManager#checkPermissions.checkPermission" ]
  }, {
    "name" : "private native Constructor<?>[] getDeclaredConstructorsInternal(boolean publicOnly)",
    "returnType" : "Constructor<?>[]",
    "comment" : "\n     * Returns the constructor with the given parameters if it is defined by this class;\n     * {@code null} otherwise. This may return a non-public member.\n     ",
    "links" : [ ]
  }, {
    "name" : "public native Field getDeclaredField(String name) throws NoSuchFieldException",
    "returnType" : "Field",
    "comment" : "\n    @CallerSensitive\n    public Field getDeclaredField(String name)\n        throws NoSuchFieldException, SecurityException {\n        Objects.requireNonNull(name);\n        @SuppressWarnings(\"removal\")\n        SecurityManager sm = System.getSecurityManager();\n        if (sm != null) {\n            checkMemberAccess(sm, Member.DECLARED, Reflection.getCallerClass(), true);\n        }\n        Field field = searchFields(privateGetDeclaredFields(false), name);\n        if (field == null) {\n            throw new NoSuchFieldException(name);\n        }\n        return getReflectionFactory().copyField(field);\n    }\n     ",
    "links" : [ ]
  }, {
    "name" : "private native Field[] getPublicDeclaredFields()",
    "returnType" : "Field[]",
    "comment" : "\n     * Returns the subset of getDeclaredFields which are public.\n     ",
    "links" : [ ]
  }, {
    "name" : "public Method getDeclaredMethod(String name, Class<?>... parameterTypes) throws NoSuchMethodException, SecurityException",
    "returnType" : "Method",
    "comment" : "\n     * Returns a {@code Method} object that reflects the specified\n     * declared method of the class or interface represented by this\n     * {@code Class} object. The {@code name} parameter is a\n     * {@code String} that specifies the simple name of the desired\n     * method, and the {@code parameterTypes} parameter is an array of\n     * {@code Class} objects that identify the method's formal parameter\n     * types, in declared order.  If more than one method with the same\n     * parameter types is declared in a class, and one of these methods has a\n     * return type that is more specific than any of the others, that method is\n     * returned; otherwise one of the methods is chosen arbitrarily.  If the\n     * name is \"&lt;init&gt;\"or \"&lt;clinit&gt;\" a {@code NoSuchMethodException}\n     * is raised.\n     *\n     * <p> If this {@code Class} object represents an array type, then this\n     * method does not find the {@code clone()} method.\n     *\n     * @param name the name of the method\n     * @param parameterTypes the parameter array\n     * @return  the {@code Method} object for the method of this class\n     *          matching the specified name and parameters\n     * @throws  NoSuchMethodException if a matching method is not found.\n     * @throws  NullPointerException if {@code name} is {@code null}\n     * @throws  SecurityException\n     *          If a security manager, <i>s</i>, is present and any of the\n     *          following conditions is met:\n     *\n     *          <ul>\n     *\n     *          <li> the caller's class loader is not the same as the\n     *          class loader of this class and invocation of\n     *          {@link SecurityManager#checkPermission\n     *          s.checkPermission} method with\n     *          {@code RuntimePermission(\"accessDeclaredMembers\")}\n     *          denies access to the declared method\n     *\n     *          <li> the caller's class loader is not the same as or an\n     *          ancestor of the class loader for the current class and\n     *          invocation of {@link SecurityManager#checkPackageAccess\n     *          s.checkPackageAccess()} denies access to the package\n     *          of this class\n     *\n     *          </ul>\n     *\n     * @jls 8.2 Class Members\n     * @jls 8.4 Method Declarations\n     * @since 1.1\n     ",
    "links" : [ "java.lang.SecurityManager#checkPackageAccesss.checkPackageAccess()", "java.lang.SecurityManager#checkPermissions.checkPermission" ]
  }, {
    "name" : "private Method getMethod(String name, Class<?>[] parameterTypes, boolean recursivePublicMethods) throws NoSuchMethodException",
    "returnType" : "Method",
    "comment" : " BEGIN Android-added: Internal methods to implement getMethod(...).",
    "links" : [ ]
  }, {
    "name" : "private Method getPublicMethodRecursive(String name, Class<?>[] parameterTypes)",
    "returnType" : "Method",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public Method getInstanceMethod(String name, Class<?>[] parameterTypes) throws NoSuchMethodException, IllegalAccessException",
    "returnType" : "Method",
    "comment" : "\n     * Returns an instance method that's defined on this class or any super classes, regardless\n     * of its access flags. Constructors are excluded.\n     *\n     * This function does not perform access checks and its semantics don't match any dex byte code\n     * instruction or public reflection API. This is used by {@code MethodHandles.findVirtual}\n     * which will perform access checks on the returned method.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "private Method findInterfaceMethod(String name, Class<?>[] parameterTypes)",
    "returnType" : "Method",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public Constructor<T> getDeclaredConstructor(Class<?>... parameterTypes) throws NoSuchMethodException, SecurityException",
    "returnType" : "Constructor<T>",
    "comment" : "\n     * Returns a {@code Constructor} object that reflects the specified\n     * constructor of the class or interface represented by this\n     * {@code Class} object.  The {@code parameterTypes} parameter is\n     * an array of {@code Class} objects that identify the constructor's\n     * formal parameter types, in declared order.\n     *\n     * If this {@code Class} object represents an inner class\n     * declared in a non-static context, the formal parameter types\n     * include the explicit enclosing instance as the first parameter.\n     *\n     * @param parameterTypes the parameter array\n     * @return  The {@code Constructor} object for the constructor with the\n     *          specified parameter list\n     * @throws  NoSuchMethodException if a matching method is not found.\n     * @throws  SecurityException\n     *          If a security manager, <i>s</i>, is present and any of the\n     *          following conditions is met:\n     *\n     *          <ul>\n     *\n     *          <li> the caller's class loader is not the same as the\n     *          class loader of this class and invocation of\n     *          {@link SecurityManager#checkPermission\n     *          s.checkPermission} method with\n     *          {@code RuntimePermission(\"accessDeclaredMembers\")}\n     *          denies access to the declared constructor\n     *\n     *          <li> the caller's class loader is not the same as or an\n     *          ancestor of the class loader for the current class and\n     *          invocation of {@link SecurityManager#checkPackageAccess\n     *          s.checkPackageAccess()} denies access to the package\n     *          of this class\n     *\n     *          </ul>\n     *\n     * @since 1.1\n     ",
    "links" : [ "java.lang.SecurityManager#checkPackageAccesss.checkPackageAccess()", "java.lang.SecurityManager#checkPermissions.checkPermission" ]
  }, {
    "name" : "public InputStream getResourceAsStream(String name)",
    "returnType" : "InputStream",
    "comment" : "\n     * Finds a resource with a given name.\n     *\n     * <p> The rules for\n     * searching resources associated with a given class are implemented by the\n     * defining {@linkplain ClassLoader class loader} of the class.  This method\n     * delegates to this {@code Class} object's class loader.\n     * If this {@code Class} object was loaded by the bootstrap class loader,\n     * the method delegates to {@link ClassLoader#getSystemResourceAsStream}.\n     *\n     * <p> Before delegation, an absolute resource name is constructed from the\n     * given resource name using this algorithm:\n     *\n     * <ul>\n     *\n     * <li> If the {@code name} begins with a {@code '/'}\n     * (<code>'&#92;u002f'</code>), then the absolute name of the resource is the\n     * portion of the {@code name} following the {@code '/'}.\n     *\n     * <li> Otherwise, the absolute name is of the following form:\n     *\n     * <blockquote>\n     *   {@code modified_package_name/name}\n     * </blockquote>\n     *\n     * <p> Where the {@code modified_package_name} is the package name of this\n     * object with {@code '/'} substituted for {@code '.'}\n     * (<code>'&#92;u002e'</code>).\n     *\n     * </ul>\n     *\n     * @param  name name of the desired resource\n     * @return  A {@link java.io.InputStream} object; {@code null} if no\n     *          resource with this name is found.\n     * @throws  NullPointerException If {@code name} is {@code null}\n     * @since  1.1\n     * @revised 9\n     ",
    "links" : [ "java.lang.ClassLoader#getSystemResourceAsStream", "java.io.InputStream" ]
  }, {
    "name" : "public URL getResource(String name)",
    "returnType" : "URL",
    "comment" : "\n     * Finds a resource with a given name.\n     *\n     * <p> The rules for\n     * searching resources associated with a given class are implemented by the\n     * defining {@linkplain ClassLoader class loader} of the class.  This method\n     * delegates to this {@code Class} object's class loader.\n     * If this {@code Class} object was loaded by the bootstrap class loader,\n     * the method delegates to {@link ClassLoader#getSystemResource}.\n     *\n     * <p> Before delegation, an absolute resource name is constructed from the\n     * given resource name using this algorithm:\n     *\n     * <ul>\n     *\n     * <li> If the {@code name} begins with a {@code '/'}\n     * (<code>'&#92;u002f'</code>), then the absolute name of the resource is the\n     * portion of the {@code name} following the {@code '/'}.\n     *\n     * <li> Otherwise, the absolute name is of the following form:\n     *\n     * <blockquote>\n     *   {@code modified_package_name/name}\n     * </blockquote>\n     *\n     * <p> Where the {@code modified_package_name} is the package name of this\n     * object with {@code '/'} substituted for {@code '.'}\n     * (<code>'&#92;u002e'</code>).\n     *\n     * </ul>\n     *\n     * @param  name name of the desired resource\n     * @return A {@link java.net.URL} object; {@code null} if no resource with\n     *         this name is found.\n     * @throws NullPointerException If {@code name} is {@code null}\n     * @since  1.1\n     * @revised 9\n     ",
    "links" : [ "java.net.URL", "java.lang.ClassLoader#getSystemResource" ]
  }, {
    "name" : "public java.security.ProtectionDomain getProtectionDomain()",
    "returnType" : "java.security.ProtectionDomain",
    "comment" : "\n     * Returns the {@code ProtectionDomain} of this class.  If there is a\n     * security manager installed, this method first calls the security\n     * manager's {@code checkPermission} method with a\n     * {@code RuntimePermission(\"getProtectionDomain\")} permission to\n     * ensure it's ok to get the\n     * {@code ProtectionDomain}.\n     *\n     * @return the ProtectionDomain of this class\n     *\n     * @throws SecurityException\n     *        if a security manager exists and its\n     *        {@code checkPermission} method doesn't allow\n     *        getting the ProtectionDomain.\n     *\n     * @see java.security.ProtectionDomain\n     * @see SecurityManager#checkPermission\n     * @see java.lang.RuntimePermission\n     * @since 1.2\n     ",
    "links" : [ ]
  }, {
    "name" : " static native Class<?> getPrimitiveClass(String name)",
    "returnType" : "Class<?>",
    "comment" : "\n     * Return the runtime's Class object for the named\n     * primitive type.\n     ",
    "links" : [ ]
  }, {
    "name" : "private String resolveName(String name)",
    "returnType" : "String",
    "comment" : "\n     * Add a package name prefix if the name is not absolute. Remove leading \"/\"\n     * if name is absolute\n     ",
    "links" : [ ]
  }, {
    "name" : "private Constructor<T> getConstructor0(Class<?>[] parameterTypes, int which) throws NoSuchMethodException",
    "returnType" : "Constructor<T>",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private RecordComponent[] getRecordComponents0()",
    "returnType" : "RecordComponent[]",
    "comment" : " private native RecordComponent[] getRecordComponents0();",
    "links" : [ ]
  }, {
    "name" : "public native T2[] getRecordAnnotationElement(String elementName, Class<T2[]> arrayClass)",
    "returnType" : "T2[]",
    "comment" : "\n     * Used by {@link libcore.reflect.RecordComponents}\n     *\n     * @hide\n     ",
    "links" : [ "libcore.reflect.RecordComponents" ]
  }, {
    "name" : "private native boolean isRecord0()",
    "returnType" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private native Constructor<T> getDeclaredConstructorInternal(Class<?>[] args)",
    "returnType" : "Constructor<T>",
    "comment" : "\n     * Returns the constructor with the given parameters if it is defined by this class;\n     * {@code null} otherwise. This may return a non-public member.\n     *\n     * @param args the types of the parameters to the constructor.\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean desiredAssertionStatus()",
    "returnType" : "boolean",
    "comment" : "\n     * Returns the assertion status that would be assigned to this\n     * class if it were to be initialized at the time this method is invoked.\n     * If this class has had its assertion status set, the most recent\n     * setting will be returned; otherwise, if any package default assertion\n     * status pertains to this class, the most recent setting for the most\n     * specific pertinent package default assertion status is returned;\n     * otherwise, if this class is not a system class (i.e., it has a\n     * class loader) its class loader's default assertion status is returned;\n     * otherwise, the system class default assertion status is returned.\n     *\n     * @apiNote\n     * Few programmers will have any need for this method; it is provided\n     * for the benefit of the JDK itself.  (It allows a class to determine at\n     * the time that it is initialized whether assertions should be enabled.)\n     * Note that this method is not guaranteed to return the actual\n     * assertion status that was (or will be) associated with the specified\n     * class when it was (or will be) initialized.\n     *\n     * Android-note: AssertionStatuses are unsupported. This method will always return false.\n     *\n     * @return the desired assertion status of the specified class.\n     * @see    java.lang.ClassLoader#setClassAssertionStatus\n     * @see    java.lang.ClassLoader#setPackageAssertionStatus\n     * @see    java.lang.ClassLoader#setDefaultAssertionStatus\n     * @since  1.4\n     ",
    "links" : [ ]
  }, {
    "name" : "private native String getSimpleNameNative()",
    "returnType" : "String",
    "comment" : "\n     * Returns the simple name of a member or local class, or {@code null} otherwise.\n     ",
    "links" : [ ]
  }, {
    "name" : "private native int getInnerClassFlags(int defaultValue)",
    "returnType" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public boolean isEnum()",
    "returnType" : "boolean",
    "comment" : "\n     * Returns true if and only if this class was declared as an enum in the\n     * source code.\n     *\n     * Note that {@link java.lang.Enum} is not itself an enum class.\n     *\n     * Also note that if an enum constant is declared with a class body,\n     * the class of that enum constant object is an anonymous class\n     * and <em>not</em> the class of the declaring enum class. The\n     * {@link Enum#getDeclaringClass} method of an enum constant can\n     * be used to get the class of the enum class declaring the\n     * constant.\n     *\n     * @return true if and only if this class was declared as an enum in the\n     *     source code\n     * @since 1.5\n     * @jls 8.9.1 Enum Constants\n     ",
    "links" : [ "java.lang.Enum", "java.lang.Enum#getDeclaringClass" ]
  }, {
    "name" : "public boolean isRecord()",
    "returnType" : "boolean",
    "comment" : "\n     * Returns {@code true} if and only if this class is a record class.\n     *\n     * <p> The {@linkplain #getSuperclass() direct superclass} of a record\n     * class is {@code java.lang.Record}. A record class is {@linkplain\n     * Modifier#FINAL final}. A record class has (possibly zero) record\n     * components; {@link #getRecordComponents()} returns a non-null but\n     * possibly empty value for a record.\n     *\n     * <p> Note that class {@link Record} is not a record class and thus\n     * invoking this method on class {@code Record} returns {@code false}.\n     *\n     * @return true if and only if this class is a record class, otherwise false\n     * @jls 8.10 Record Classes\n     * @since 16\n     ",
    "links" : [ "#getRecordComponents()", "java.lang.Record" ]
  }, {
    "name" : "public T[] getEnumConstants()",
    "returnType" : "T[]",
    "comment" : "\n     * Returns the elements of this enum class or null if this\n     * Class object does not represent an enum class.\n     *\n     * @return an array containing the values comprising the enum class\n     *     represented by this {@code Class} object in the order they're\n     *     declared, or null if this {@code Class} object does not\n     *     represent an enum class\n     * @since 1.5\n     * @jls 8.9.1 Enum Constants\n     ",
    "links" : [ ]
  }, {
    "name" : "public T[] getEnumConstantsShared()",
    "returnType" : "T[]",
    "comment" : "\n     * Returns the elements of this enum class or null if this\n     * Class object does not represent an enum class;\n     * identical to getEnumConstants except that the result is\n     * uncloned, cached, and shared by all callers.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public T cast(Object obj)",
    "returnType" : "T",
    "comment" : "\n     * Casts an object to the class or interface represented\n     * by this {@code Class} object.\n     *\n     * @param obj the object to be cast\n     * @return the object after casting, or null if obj is null\n     *\n     * @throws ClassCastException if the object is not\n     * null and is not assignable to the type T.\n     *\n     * @since 1.5\n     ",
    "links" : [ ]
  }, {
    "name" : "private String cannotCastMsg(Object obj)",
    "returnType" : "String",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public Class<? extends U> asSubclass(Class<U> clazz)",
    "returnType" : "Class<? extends U>",
    "comment" : "\n     * Casts this {@code Class} object to represent a subclass of the class\n     * represented by the specified class object.  Checks that the cast\n     * is valid, and throws a {@code ClassCastException} if it is not.  If\n     * this method succeeds, it always returns a reference to this {@code Class} object.\n     *\n     * <p>This method is useful when a client needs to \"narrow\" the type of\n     * a {@code Class} object to pass it to an API that restricts the\n     * {@code Class} objects that it is willing to accept.  A cast would\n     * generate a compile-time warning, as the correctness of the cast\n     * could not be checked at runtime (because generic types are implemented\n     * by erasure).\n     *\n     * @param <U> the type to cast this {@code Class} object to\n     * @param clazz the class of the type to cast this {@code Class} object to\n     * @return this {@code Class} object, cast to represent a subclass of\n     *    the specified class object.\n     * @throws ClassCastException if this {@code Class} object does not\n     *    represent a subclass of the specified class (here \"subclass\" includes\n     *    the class itself).\n     * @since 1.5\n     ",
    "links" : [ ]
  }, {
    "name" : "public A getAnnotation(Class<A> annotationClass)",
    "returnType" : "A",
    "comment" : "\n     * {@inheritDoc}\n     * <p>Note that any annotation returned by this method is a\n     * declaration annotation.\n     *\n     * @throws NullPointerException {@inheritDoc}\n     * @since 1.5\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean isAnnotationPresent(Class<? extends Annotation> annotationClass)",
    "returnType" : "boolean",
    "comment" : "\n     * {@inheritDoc}\n     * @throws NullPointerException {@inheritDoc}\n     * @since 1.5\n     ",
    "links" : [ ]
  }, {
    "name" : "public A[] getAnnotationsByType(Class<A> annotationClass)",
    "returnType" : "A[]",
    "comment" : "\n     * {@inheritDoc}\n     * <p>Note that any annotations returned by this method are\n     * declaration annotations.\n     *\n     * @throws NullPointerException {@inheritDoc}\n     * @since 1.8\n     ",
    "links" : [ ]
  }, {
    "name" : "public A[] getDeclaredAnnotationsByType(Class<A> annotationClass)",
    "returnType" : "A[]",
    "comment" : "\n     * {@inheritDoc}\n     * <p>Note that any annotations returned by this method are\n     * declaration annotations.\n     *\n     * @throws NullPointerException {@inheritDoc}\n     * @since 1.8\n     ",
    "links" : [ ]
  }, {
    "name" : "public Annotation[] getAnnotations()",
    "returnType" : "Annotation[]",
    "comment" : "\n     * {@inheritDoc}\n     * <p>Note that any annotations returned by this method are\n     * declaration annotations.\n     *\n     * @since 1.5\n     ",
    "links" : [ ]
  }, {
    "name" : "public native A getDeclaredAnnotation(Class<A> annotationClass)",
    "returnType" : "A",
    "comment" : "\n    @SuppressWarnings(\"unchecked\")\n    public <A extends Annotation> A getDeclaredAnnotation(Class<A> annotationClass) {\n        Objects.requireNonNull(annotationClass);\n\n        return (A) annotationData().declaredAnnotations.get(annotationClass);\n    }\n    ",
    "links" : [ ]
  }, {
    "name" : "public native Annotation[] getDeclaredAnnotations()",
    "returnType" : "Annotation[]",
    "comment" : "\n    public Annotation[] getDeclaredAnnotations()  {\n        return AnnotationParser.toArray(annotationData().declaredAnnotations);\n    }\n    ",
    "links" : [ ]
  }, {
    "name" : "private native boolean isDeclaredAnnotationPresent(Class<? extends Annotation> annotationClass)",
    "returnType" : "boolean",
    "comment" : "\n     * Returns true if the annotation exists.\n     ",
    "links" : [ ]
  }, {
    "name" : "private String getSignatureAttribute()",
    "returnType" : "String",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private native String[] getSignatureAnnotation()",
    "returnType" : "String[]",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public boolean isProxy()",
    "returnType" : "boolean",
    "comment" : "\n     * Is this a runtime created proxy class?\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public int getAccessFlags()",
    "returnType" : "int",
    "comment" : "\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "private native Method getDeclaredMethodInternal(String name, Class<?>[] args)",
    "returnType" : "Method",
    "comment" : "\n     * Returns the method if it is defined by this class; {@code null} otherwise. This may return a\n     * non-public member.\n     *\n     * @param name the method name\n     * @param args the method's parameter types\n     ",
    "links" : [ ]
  }, {
    "name" : " native ClassExt ensureExtDataPresent()",
    "returnType" : "ClassExt",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public Class<?> getNestHost()",
    "returnType" : "Class<?>",
    "comment" : "\n     * Returns the nest host of the <a href=#nest>nest</a> to which the class\n     * or interface represented by this {@code Class} object belongs.\n     * Every class and interface belongs to exactly one nest.\n     *\n     * If the nest host of this class or interface has previously\n     * been determined, then this method returns the nest host.\n     * If the nest host of this class or interface has\n     * not previously been determined, then this method determines the nest\n     * host using the algorithm of JVMS 5.4.4, and returns it.\n     *\n     * Often, a class or interface belongs to a nest consisting only of itself,\n     * in which case this method returns {@code this} to indicate that the class\n     * or interface is the nest host.\n     *\n     * <p>If this {@code Class} object represents a primitive type, an array type,\n     * or {@code void}, then this method returns {@code this},\n     * indicating that the represented entity belongs to the nest consisting only of\n     * itself, and is the nest host.\n     *\n     * @return the nest host of this class or interface\n     * @since 11\n     * @jvms 4.7.28 The {@code NestHost} Attribute\n     * @jvms 4.7.29 The {@code NestMembers} Attribute\n     * @jvms 5.4.4 Access Control\n     ",
    "links" : [ ]
  }, {
    "name" : "private static boolean nestHostHasMember(Class<?> host, Class<?> member)",
    "returnType" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private static boolean nestMembersIncludeMember(Class<?>[] members, Class<?> member)",
    "returnType" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private native Class<?> getNestHostFromAnnotation()",
    "returnType" : "Class<?>",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public boolean isNestmateOf(Class<?> c)",
    "returnType" : "boolean",
    "comment" : "\n     * Determines if the given {@code Class} is a nestmate of the\n     * class or interface represented by this {@code Class} object.\n     * Two classes or interfaces are nestmates\n     * if they have the same {@linkplain #getNestHost() nest host}.\n     *\n     * @param c the class to check\n     * @return {@code true} if this class and {@code c} are members of\n     * the same nest; and {@code false} otherwise.\n     *\n     * @since 11\n     ",
    "links" : [ ]
  }, {
    "name" : "public Class<?>[] getNestMembers()",
    "returnType" : "Class<?>[]",
    "comment" : "\n     * Returns an array containing {@code Class} objects representing all the\n     * classes and interfaces that are members of the nest to which the class\n     * or interface represented by this {@code Class} object belongs.\n     *\n     * First, this method obtains the {@linkplain #getNestHost() nest host},\n     * {@code H}, of the nest to which the class or interface represented by\n     * this {@code Class} object belongs. The zeroth element of the returned\n     * array is {@code H}.\n     *\n     * Then, for each class or interface {@code C} which is recorded by {@code H}\n     * as being a member of its nest, this method attempts to obtain the {@code Class}\n     * object for {@code C} (using {@linkplain #getClassLoader() the defining class\n     * loader} of the current {@code Class} object), and then obtains the\n     * {@linkplain #getNestHost() nest host} of the nest to which {@code C} belongs.\n     * The classes and interfaces which are recorded by {@code H} as being members\n     * of its nest, and for which {@code H} can be determined as their nest host,\n     * are indicated by subsequent elements of the returned array. The order of\n     * such elements is unspecified. Duplicates are permitted.\n     *\n     * <p>If this {@code Class} object represents a primitive type, an array type,\n     * or {@code void}, then this method returns a single-element array containing\n     * {@code this}.\n     *\n     * @apiNote\n     * The returned array includes only the nest members recorded in the {@code NestMembers}\n     * attribute.\n     *\n     * @return an array of all classes and interfaces in the same nest as\n     * this class or interface\n     *\n     * @since 11\n     * @see #getNestHost()\n     * @jvms 4.7.28 The {@code NestHost} Attribute\n     * @jvms 4.7.29 The {@code NestMembers} Attribute\n     ",
    "links" : [ ]
  }, {
    "name" : "private Class<?>[] getNestMembers(Class<?> originatingMember)",
    "returnType" : "Class<?>[]",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private native Class<?>[] getNestMembersFromAnnotation()",
    "returnType" : "Class<?>[]",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public String descriptorString()",
    "returnType" : "String",
    "comment" : "\n     * Returns the descriptor string of the entity (class, interface, array class,\n     * primitive type, or {@code void}) represented by this {@code Class} object.\n     *\n     * <p> If this {@code Class} object represents a class or interface,\n     * not an array class, then:\n     * <ul>\n     * <li> The result is a field descriptor (JVMS {@jvms 4.3.2})\n     *      for the class or interface.\n     * </ul>\n     *\n     * <p> If this {@code Class} object represents an array class, then\n     * the result is a string consisting of one or more '{@code [}' characters\n     * representing the depth of the array nesting, followed by the\n     * descriptor string of the element type.\n     * <ul>\n     * <li> This array class can be described nominally.\n     * </ul>\n     *\n     * <p> If this {@code Class} object represents a primitive type or\n     * {@code void}, then the result is a field descriptor string which\n     * is a one-letter code corresponding to a primitive type or {@code void}\n     * ({@code \"B\", \"C\", \"D\", \"F\", \"I\", \"J\", \"S\", \"Z\", \"V\"}) (JVMS {@jvms 4.3.2}).\n     *\n     * @apiNote\n     * This is not a strict inverse of {@link #forName};\n     * distinct classes which share a common name but have different class loaders\n     * will have identical descriptor strings.\n     *\n     * @return the descriptor string for this {@code Class} object\n     * @jvms 4.3.2 Field Descriptors\n     * @since 12\n     ",
    "links" : [ "#forName" ]
  }, {
    "name" : "public Class<?> componentType()",
    "returnType" : "Class<?>",
    "comment" : "\n     * Returns the component type of this {@code Class}, if it describes\n     * an array type, or {@code null} otherwise.\n     *\n     * @implSpec\n     * Equivalent to {@link Class#getComponentType()}.\n     *\n     * @return a {@code Class} describing the component type, or {@code null}\n     * if this {@code Class} does not describe an array type\n     * @since 12\n     ",
    "links" : [ "java.lang.Class#getComponentType()" ]
  }, {
    "name" : "public Class<?> arrayType()",
    "returnType" : "Class<?>",
    "comment" : "\n     * Returns a {@code Class} for an array type whose component type\n     * is described by this {@linkplain Class}.\n     *\n     * @return a {@code Class} describing the array type\n     * @since 12\n     ",
    "links" : [ ]
  }, {
    "name" : "public Optional<ClassDesc> describeConstable()",
    "returnType" : "Optional<ClassDesc>",
    "comment" : "\n     * Returns a nominal descriptor for this instance, if one can be\n     * constructed, or an empty {@link Optional} if one cannot be.\n     *\n     * @return An {@link Optional} containing the resulting nominal descriptor,\n     * or an empty {@link Optional} if one cannot be constructed.\n     * @since 12\n     * @hide\n     ",
    "links" : [ "java.util.Optional" ]
  }, {
    "name" : "public boolean isHidden()",
    "returnType" : "boolean",
    "comment" : " public native boolean isHidden();",
    "links" : [ ]
  }, {
    "name" : "public Class<?>[] getPermittedSubclasses()",
    "returnType" : "Class<?>[]",
    "comment" : " @CallerSensitive",
    "links" : [ ]
  }, {
    "name" : "private int getDirectSubClassCount(Class<?>[] subClasses)",
    "returnType" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private boolean isDirectSubType(Class<?> c)",
    "returnType" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public boolean isSealed()",
    "returnType" : "boolean",
    "comment" : "\n     * Returns {@code true} if and only if this {@code Class} object represents\n     * a sealed class or interface. If this {@code Class} object represents a\n     * primitive type, {@code void}, or an array type, this method returns\n     * {@code false}. A sealed class or interface has (possibly zero) permitted\n     * subclasses; {@link #getPermittedSubclasses()} returns a non-null but\n     * possibly empty value for a sealed class or interface.\n     *\n     * @return {@code true} if and only if this {@code Class} object represents\n     * a sealed class or interface.\n     *\n     * @since 17\n     ",
    "links" : [ "#getPermittedSubclasses()" ]
  }, {
    "name" : "private native Class<?>[] getPermittedSubclassesFromAnnotation()",
    "returnType" : "Class<?>[]",
    "comment" : " private native Class<?>[] getPermittedSubclasses0();",
    "links" : [ ]
  } ],
  "methodNames" : [ "public String toString()", "public String toGenericString()", " static String typeVarBounds(TypeVariable<?> typeVar)", "public static Class<?> forName(String className) throws ClassNotFoundException", "public static Class<?> forName(String name, boolean initialize, ClassLoader loader) throws ClassNotFoundException", " static native Class<?> classForName(String className, boolean shouldInitialize, ClassLoader classLoader) throws ClassNotFoundException", "public native T newInstance() throws InstantiationException, IllegalAccessException", "public boolean isInstance(Object obj)", "public boolean isAssignableFrom(Class<?> cls)", "public boolean isInterface()", "public boolean isArray()", "public boolean isPrimitive()", "public boolean isFinalizable()", "public boolean isAnnotation()", "public boolean isSynthetic()", "public String getName()", "private native String getNameNative()", "public ClassLoader getClassLoader()", "public synchronized TypeVariable<Class<T>>[] getTypeParameters()", "public Class<? super T> getSuperclass()", "public Type getGenericSuperclass()", "public Package getPackage()", "public String getPackageName()", "public Class<?>[] getInterfaces()", "private native Class<?>[] getInterfacesInternal()", "public Type[] getGenericInterfaces()", "public Class<?> getComponentType()", "private Class<?> elementType()", "public int getModifiers()", "public Object[] getSigners()", "private native Method getEnclosingMethodNative()", "public Method getEnclosingMethod()", "public Constructor<?> getEnclosingConstructor()", "private native Constructor<?> getEnclosingConstructorNative()", "private boolean classNameImpliesTopLevel()", "public native Class<?> getDeclaringClass()", "public native Class<?> getEnclosingClass()", "public String getSimpleName()", "public String getTypeName()", "public String getCanonicalName()", "public native boolean isAnonymousClass()", "public boolean isLocalClass()", "public boolean isMemberClass()", "private boolean isTopLevelClass()", "private boolean isLocalOrAnonymousClass()", "public Class<?>[] getClasses()", "public Field[] getFields() throws SecurityException", "private void getPublicFieldsRecursive(List<Field> result)", "public Method[] getMethods() throws SecurityException", "private void getPublicMethodsInternal(List<Method> result)", "public Constructor<?>[] getConstructors() throws SecurityException", "public Field getField(String name) throws NoSuchFieldException", "private native Field getPublicFieldRecursive(String name)", "public Method getMethod(String name, Class<?>... parameterTypes) throws NoSuchMethodException, SecurityException", "public Constructor<T> getConstructor(Class<?>... parameterTypes) throws NoSuchMethodException, SecurityException", "public native Class<?>[] getDeclaredClasses()", "public native Field[] getDeclaredFields()", "public RecordComponent[] getRecordComponents()", "public native Field[] getDeclaredFieldsUnchecked(boolean publicOnly)", "public Method[] getDeclaredMethods() throws SecurityException", "public native Method[] getDeclaredMethodsUnchecked(boolean publicOnly)", "public Constructor<?>[] getDeclaredConstructors() throws SecurityException", "private native Constructor<?>[] getDeclaredConstructorsInternal(boolean publicOnly)", "public native Field getDeclaredField(String name) throws NoSuchFieldException", "private native Field[] getPublicDeclaredFields()", "public Method getDeclaredMethod(String name, Class<?>... parameterTypes) throws NoSuchMethodException, SecurityException", "private Method getMethod(String name, Class<?>[] parameterTypes, boolean recursivePublicMethods) throws NoSuchMethodException", "private Method getPublicMethodRecursive(String name, Class<?>[] parameterTypes)", "public Method getInstanceMethod(String name, Class<?>[] parameterTypes) throws NoSuchMethodException, IllegalAccessException", "private Method findInterfaceMethod(String name, Class<?>[] parameterTypes)", "public Constructor<T> getDeclaredConstructor(Class<?>... parameterTypes) throws NoSuchMethodException, SecurityException", "public InputStream getResourceAsStream(String name)", "public URL getResource(String name)", "public java.security.ProtectionDomain getProtectionDomain()", " static native Class<?> getPrimitiveClass(String name)", "private String resolveName(String name)", "private Constructor<T> getConstructor0(Class<?>[] parameterTypes, int which) throws NoSuchMethodException", "private RecordComponent[] getRecordComponents0()", "public native T2[] getRecordAnnotationElement(String elementName, Class<T2[]> arrayClass)", "private native boolean isRecord0()", "private native Constructor<T> getDeclaredConstructorInternal(Class<?>[] args)", "public boolean desiredAssertionStatus()", "private native String getSimpleNameNative()", "private native int getInnerClassFlags(int defaultValue)", "public boolean isEnum()", "public boolean isRecord()", "public T[] getEnumConstants()", "public T[] getEnumConstantsShared()", "public T cast(Object obj)", "private String cannotCastMsg(Object obj)", "public Class<? extends U> asSubclass(Class<U> clazz)", "public A getAnnotation(Class<A> annotationClass)", "public boolean isAnnotationPresent(Class<? extends Annotation> annotationClass)", "public A[] getAnnotationsByType(Class<A> annotationClass)", "public A[] getDeclaredAnnotationsByType(Class<A> annotationClass)", "public Annotation[] getAnnotations()", "public native A getDeclaredAnnotation(Class<A> annotationClass)", "public native Annotation[] getDeclaredAnnotations()", "private native boolean isDeclaredAnnotationPresent(Class<? extends Annotation> annotationClass)", "private String getSignatureAttribute()", "private native String[] getSignatureAnnotation()", "public boolean isProxy()", "public int getAccessFlags()", "private native Method getDeclaredMethodInternal(String name, Class<?>[] args)", " native ClassExt ensureExtDataPresent()", "public Class<?> getNestHost()", "private static boolean nestHostHasMember(Class<?> host, Class<?> member)", "private static boolean nestMembersIncludeMember(Class<?>[] members, Class<?> member)", "private native Class<?> getNestHostFromAnnotation()", "public boolean isNestmateOf(Class<?> c)", "public Class<?>[] getNestMembers()", "private Class<?>[] getNestMembers(Class<?> originatingMember)", "private native Class<?>[] getNestMembersFromAnnotation()", "public String descriptorString()", "public Class<?> componentType()", "public Class<?> arrayType()", "public Optional<ClassDesc> describeConstable()", "public boolean isHidden()", "public Class<?>[] getPermittedSubclasses()", "private int getDirectSubClassCount(Class<?>[] subClasses)", "private boolean isDirectSubType(Class<?> c)", "public boolean isSealed()", "private native Class<?>[] getPermittedSubclassesFromAnnotation()" ],
  "variableNames" : [ "ANNOTATION", "ENUM", "SYNTHETIC", "FINALIZABLE", "classLoader", "componentType", "dexCache", "extData", "ifTable", "name", "superClass", "vtable", "iFields", "methods", "sFields", "accessFlags", "classFlags", "classSize", "clinitThreadId", "dexClassDefIndex", "dexTypeIndex", "numReferenceInstanceFields", "numReferenceStaticFields", "objectSize", "objectSizeAllocFastPath", "primitiveType", "referenceInstanceOffsets", "status", "copiedMethodsOffset", "virtualMethodsOffset", "serialVersionUID" ]
}