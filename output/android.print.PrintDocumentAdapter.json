{
  "filePath" : "/home/maryam/clearblue/files/android-source-35/android/print/PrintDocumentAdapter.java",
  "packageName" : "android.print",
  "className" : "PrintDocumentAdapter",
  "comment" : "\n * Base class that provides the content of a document to be printed.\n *\n * <h3>Lifecycle</h3>\n * <p>\n * <ul>\n * <li>\n * Initially, you will receive a call to {@link #onStart()}. This callback\n * can be used to allocate resources.\n * </li>\n * <li>\n * Next, you will get one or more calls to {@link #onLayout(PrintAttributes,\n * PrintAttributes, CancellationSignal, LayoutResultCallback, Bundle)} to\n * inform you that the print attributes (page size, density, etc) changed\n * giving you an opportunity to layout the content to match the new constraints.\n * </li>\n * <li>\n * After every call to {@link #onLayout(PrintAttributes, PrintAttributes,\n * CancellationSignal, LayoutResultCallback, Bundle)}, you <strong>may</strong> get\n * a call to {@link #onWrite(PageRange[], ParcelFileDescriptor, CancellationSignal,\n * WriteResultCallback)} asking you to write a PDF file with the content for\n * specific pages.\n * </li>\n * <li>\n * Finally, you will receive a call to {@link #onFinish()}. You can use this\n * callback to release resources allocated in {@link #onStart()}.\n * </li>\n * </ul>\n * <p>\n * The {@link #onStart()} callback is always the first call you will receive and\n * is useful for doing one time setup or resource allocation before printing. You\n * will not receive a subsequent call here.\n * </p>\n * <p>\n * The {@link #onLayout(PrintAttributes, PrintAttributes, CancellationSignal,\n * LayoutResultCallback, Bundle)} callback requires that you layout the content\n * based on the current {@link PrintAttributes}. The execution of this method is\n * not considered completed until you invoke one of the methods on the passed in\n * callback instance. Hence, you will not receive a subsequent call to any other\n * method of this class until the execution of this method is complete by invoking\n * one of the callback methods.\n * </p>\n * <p>\n * The {@link #onWrite(PageRange[], ParcelFileDescriptor, CancellationSignal,\n * WriteResultCallback)} requires that you render and write the content of some\n * pages to the provided destination. The execution of this method is not\n * considered complete until you invoke one of the methods on the passed in\n * callback instance. Hence, you will not receive a subsequent call to any other\n * method of this class until the execution of this method is complete by invoking\n * one of the callback methods. You will never receive a sequence of one or more\n * calls to this method without a previous call to {@link #onLayout(PrintAttributes,\n * PrintAttributes, CancellationSignal, LayoutResultCallback, Bundle)}.\n * </p>\n * <p>\n * The {@link #onFinish()} callback is always the last call you will receive and\n * is useful for doing one time cleanup or resource deallocation after printing.\n * You will not receive a subsequent call here.\n * </p>\n * </p>\n * <h3>Implementation</h3>\n * <p>\n * The APIs defined in this class are designed to enable doing part or all\n * of the work on an arbitrary thread. For example, if the printed content\n * does not depend on the UI state, i.e. on what is shown on the screen, then\n * you can offload the entire work on a dedicated thread, thus making your\n * application interactive while the print work is being performed. Note that\n * while your activity is covered by the system print UI and a user cannot\n * interact with it, doing the printing work on the main application thread\n * may affect the performance of your other application components as they\n * are also executed on that thread.\n * </p>\n * <p>\n * You can also do work on different threads, for example if you print UI\n * content, you can handle {@link #onStart()} and {@link #onLayout(PrintAttributes,\n * PrintAttributes, CancellationSignal, LayoutResultCallback, Bundle)} on\n * the UI thread (assuming onStart initializes resources needed for layout).\n * This will ensure that the UI does not change while you are laying out the\n * printed content. Then you can handle {@link #onWrite(PageRange[], ParcelFileDescriptor,\n * CancellationSignal, WriteResultCallback)} and {@link #onFinish()} on another\n * thread. This will ensure that the main thread is busy for a minimal amount of\n * time. Also this assumes that you will generate the printed content in\n * {@link #onLayout(PrintAttributes, PrintAttributes, CancellationSignal,\n * LayoutResultCallback, Bundle)} which is not mandatory. If you use multiple\n * threads, you are responsible for proper synchronization.\n * </p>\n ",
  "links" : [ "#onFinish()", "#onStart()", "android.print.PrintAttributes", "#onLayout(PrintAttributes", "#onWrite(PageRange" ],
  "variables" : [ {
    "name" : "EXTRA_PRINT_PREVIEW",
    "type" : "String",
    "comment" : "\n     * Extra: mapped to a boolean value that is <code>true</code> if\n     * the current layout is for a print preview, <code>false</code> otherwise.\n     * This extra is provided in the {@link Bundle} argument of the {@link\n     * #onLayout(PrintAttributes, PrintAttributes, CancellationSignal,\n     * LayoutResultCallback, Bundle)} callback.\n     *\n     * @see #onLayout(PrintAttributes, PrintAttributes, CancellationSignal,\n     * LayoutResultCallback, Bundle)\n     ",
    "links" : [ "android.os.Bundle", "#onLayout(PrintAttributes" ]
  } ],
  "methods" : [ {
    "name" : "public void onStart()",
    "returnType" : "void",
    "comment" : "\n     * Called when printing starts. You can use this callback to allocate\n     * resources. This method is invoked on the main thread.\n     ",
    "links" : [ ]
  }, {
    "name" : "public abstract void onLayout(PrintAttributes oldAttributes, PrintAttributes newAttributes, CancellationSignal cancellationSignal, LayoutResultCallback callback, Bundle extras)",
    "returnType" : "void",
    "comment" : "\n     * Called when the print attributes (page size, density, etc) changed\n     * giving you a chance to layout the content such that it matches the\n     * new constraints. This method is invoked on the main thread.\n     * <p>\n     * After you are done laying out, you <strong>must</strong> invoke: {@link\n     * LayoutResultCallback#onLayoutFinished(PrintDocumentInfo, boolean)} with\n     * the last argument <code>true</code> or <code>false</code> depending on\n     * whether the layout changed the content or not, respectively; or {@link\n     * LayoutResultCallback#onLayoutFailed(CharSequence)}, if an error occurred;\n     * or {@link LayoutResultCallback#onLayoutCancelled()} if layout was\n     * cancelled in a response to a cancellation request via the passed in\n     * {@link CancellationSignal}. Note that you <strong>must</strong> call one of\n     * the methods of the given callback for this method to be considered complete\n     * which is you will not receive any calls to this adapter until the current\n     * layout operation is complete by invoking a method on the callback instance.\n     * The callback methods can be invoked from an arbitrary thread.\n     * </p>\n     * <p>\n     * One of the arguments passed to this method is a {@link CancellationSignal}\n     * which is used to propagate requests from the system to your application for\n     * canceling the current layout operation. For example, a cancellation may be\n     * requested if the user changes a print option that may affect layout while\n     * you are performing a layout operation. In such a case the system will make\n     * an attempt to cancel the current layout as another one will have to be performed.\n     * Typically, you should register a cancellation callback in the cancellation\n     * signal. The cancellation callback <strong>will not</strong> be made on the\n     * main thread and can be registered as follows:\n     * </p>\n     * <pre>\n     * cancellationSignal.setOnCancelListener(new OnCancelListener() {\n     *     &#064;Override\n     *     public void onCancel() {\n     *         // Cancel layout\n     *     }\n     * });\n     * </pre>\n     * <p>\n     * <strong>Note:</strong> If the content is large and a layout will be\n     * performed, it is a good practice to schedule the work on a dedicated\n     * thread and register an observer in the provided {@link\n     * CancellationSignal} upon invocation of which you should stop the\n     * layout.\n     * </p>\n     *\n     * @param oldAttributes The old print attributes.\n     * @param newAttributes The new print attributes.\n     * @param cancellationSignal Signal for observing cancel layout requests.\n     * @param callback Callback to inform the system for the layout result.\n     * @param extras Additional information about how to layout the content.\n     *\n     * @see LayoutResultCallback\n     * @see CancellationSignal\n     * @see #EXTRA_PRINT_PREVIEW\n     ",
    "links" : [ "#onLayoutCancelled()", "#onLayoutFinished(PrintDocumentInfo", "android.os.CancellationSignal", "#onLayoutFailed(CharSequence)" ]
  }, {
    "name" : "public abstract void onWrite(PageRange[] pages, ParcelFileDescriptor destination, CancellationSignal cancellationSignal, WriteResultCallback callback)",
    "returnType" : "void",
    "comment" : "\n     * Called when specific pages of the content should be written in the\n     * form of a PDF file to the given file descriptor. This method is invoked\n     * on the main thread.\n     *<p>\n     * After you are done writing, you should close the file descriptor and\n     * invoke {@link WriteResultCallback#onWriteFinished(PageRange[])}, if writing\n     * completed successfully; or {@link WriteResultCallback#onWriteFailed(\n     * CharSequence)}, if an error occurred; or {@link WriteResultCallback#onWriteCancelled()},\n     * if writing was cancelled in a response to a cancellation request via the passed\n     * in {@link CancellationSignal}. Note that you <strong>must</strong> call one of\n     * the methods of the given callback for this method to be considered complete which\n     * is you will not receive any calls to this adapter until the current write\n     * operation is complete by invoking a method on the callback instance. The callback\n     * methods can be invoked from an arbitrary thread.\n     * </p>\n     * <p>\n     * One of the arguments passed to this method is a {@link CancellationSignal}\n     * which is used to propagate requests from the system to your application for\n     * canceling the current write operation. For example, a cancellation may be\n     * requested if the user changes a print option that may affect layout while\n     * you are performing a write operation. In such a case the system will make\n     * an attempt to cancel the current write as a layout will have to be performed\n     * which then may be followed by a write. Typically, you should register a\n     * cancellation callback in the cancellation signal. The cancellation callback\n     * <strong>will not</strong> be made on the main thread and can be registered\n     * as follows:\n     * </p>\n     * <pre>\n     * cancellationSignal.setOnCancelListener(new OnCancelListener() {\n     *     &#064;Override\n     *     public void onCancel() {\n     *         // Cancel write\n     *     }\n     * });\n     * </pre>\n     * <p>\n     * <strong>Note:</strong> If the printed content is large, it is a good\n     * practice to schedule writing it on a dedicated thread and register an\n     * observer in the provided {@link CancellationSignal} upon invocation of\n     * which you should stop writing.\n     * </p>\n     *\n     * @param pages The pages whose content to print - non-overlapping in ascending order.\n     * @param destination The destination file descriptor to which to write.\n     * @param cancellationSignal Signal for observing cancel writing requests.\n     * @param callback Callback to inform the system for the write result.\n     *\n     * @see WriteResultCallback\n     * @see CancellationSignal\n     ",
    "links" : [ "#onWriteFinished(PageRange", "#onWriteFailed(", "android.os.CancellationSignal", "#onWriteCancelled()" ]
  }, {
    "name" : "public void onFinish()",
    "returnType" : "void",
    "comment" : "\n     * Called when printing finishes. You can use this callback to release\n     * resources acquired in {@link #onStart()}. This method is invoked on\n     * the main thread.\n     ",
    "links" : [ "#onStart()" ]
  } ],
  "methodNames" : [ "public void onStart()", "public abstract void onLayout(PrintAttributes oldAttributes, PrintAttributes newAttributes, CancellationSignal cancellationSignal, LayoutResultCallback callback, Bundle extras)", "public abstract void onWrite(PageRange[] pages, ParcelFileDescriptor destination, CancellationSignal cancellationSignal, WriteResultCallback callback)", "public void onFinish()" ],
  "variableNames" : [ "EXTRA_PRINT_PREVIEW" ]
}