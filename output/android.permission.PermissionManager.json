{
  "filePath" : "/home/maryam/clearblue/files/android-source-35/android/permission/PermissionManager.java",
  "packageName" : "android.permission",
  "className" : "PermissionManager",
  "comment" : "\n * System level service for accessing the permission capabilities of the platform.\n *\n * @hide\n ",
  "links" : [ ],
  "variables" : [ {
    "name" : "LOG_TAG",
    "type" : "String",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "PERMISSION_GRANTED",
    "type" : "int",
    "comment" : "\n     * The permission is granted.\n     ",
    "links" : [ ]
  }, {
    "name" : "PERMISSION_SOFT_DENIED",
    "type" : "int",
    "comment" : "\n     * The permission is denied. Applicable only to runtime permissions.\n     * <p>\n     * The app isn't expecting the permission to be denied so that a \"no-op\" action should be taken,\n     * such as returning an empty result.\n     ",
    "links" : [ ]
  }, {
    "name" : "PERMISSION_HARD_DENIED",
    "type" : "int",
    "comment" : "\n     * The permission is denied.\n     * <p>\n     * The app should receive a {@code SecurityException}, or an error through a relevant callback.\n     ",
    "links" : [ ]
  }, {
    "name" : "EXPLICIT_SET_FLAGS",
    "type" : "int",
    "comment" : "\n     * The set of flags that indicate that a permission state has been explicitly set\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "ACTION_REVIEW_PERMISSION_DECISIONS",
    "type" : "String",
    "comment" : "\n     * Activity action: Launch UI to review permission decisions.\n     * <p>\n     * <strong>Important:</strong>You must protect the activity that handles this action with the\n     * {@link android.Manifest.permission#START_REVIEW_PERMISSION_DECISIONS} permission to ensure\n     * that only the system can launch this activity. The system will not launch activities that are\n     * not properly protected.\n     * <p>\n     * Input: Nothing.\n     * </p>\n     * <p>\n     * Output: Nothing.\n     * </p>\n     ",
    "links" : [ "android.Manifest.permission#START_REVIEW_PERMISSION_DECISIONS" ]
  }, {
    "name" : "LOG_TAG_TRACE_GRANTS",
    "type" : "String",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "KILL_APP_REASON_PERMISSIONS_REVOKED",
    "type" : "String",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "KILL_APP_REASON_GIDS_CHANGED",
    "type" : "String",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "SYSTEM_PKG",
    "type" : "String",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "CANNOT_INSTALL_WITH_BAD_PERMISSION_GROUPS",
    "type" : "long",
    "comment" : "\n     * Refuse to install package if groups of permissions are bad\n     * - Permission groups should only be shared between apps sharing a certificate\n     * - If a permission belongs to a group that group should be defined\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "USE_ACCESS_CHECKING_SERVICE",
    "type" : "boolean",
    "comment" : "\n     * Whether to use the new {@link com.android.server.permission.access.AccessCheckingService}.\n     *\n     * @hide\n     ",
    "links" : [ "com.android.server.permission.access.AccessCheckingService" ]
  }, {
    "name" : "EXEMPTED_INDICATOR_ROLE_UPDATE_FREQUENCY_MS",
    "type" : "long",
    "comment" : "\n     * The time to wait in between refreshing the exempted indicator role packages\n     ",
    "links" : [ ]
  }, {
    "name" : "sLastIndicatorUpdateTime",
    "type" : "long",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "EXEMPTED_ROLES",
    "type" : "int[]",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "INDICATOR_EXEMPTED_PACKAGES",
    "type" : "String[]",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "DEBUG_TRACE_GRANTS",
    "type" : "boolean",
    "comment" : "\n     * Note: Changing this won't do anything on its own - you should also change the filtering in\n     * {@link #shouldTraceGrant}.\n     *\n     * See log output for tag {@link #LOG_TAG_TRACE_GRANTS}\n     *\n     * @hide\n     ",
    "links" : [ "#shouldTraceGrant", "#LOG_TAG_TRACE_GRANTS" ]
  }, {
    "name" : "DEBUG_TRACE_PERMISSION_UPDATES",
    "type" : "boolean",
    "comment" : "\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "DEBUG_DEVICE_PERMISSIONS",
    "type" : "boolean",
    "comment" : "\n     * Additional debug log for virtual device permissions.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "EXTRA_PERMISSION_USAGES",
    "type" : "String",
    "comment" : "\n     * Intent extra: List of PermissionGroupUsages\n     * <p>\n     * Type: {@code List<PermissionGroupUsage>}\n     * </p>\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "DEVICE_AWARE_PERMISSIONS",
    "type" : "Set<String>",
    "comment" : "\n     * Specify what permissions are device aware. Only device aware permissions can be granted to\n     * a remote device.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "mContext",
    "type" : "Context",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mPackageManager",
    "type" : "IPackageManager",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mPermissionManager",
    "type" : "IPermissionManager",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mLegacyPermissionManager",
    "type" : "LegacyPermissionManager",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mPermissionListeners",
    "type" : "ArrayMap<PackageManager.OnPermissionsChangedListener, IOnPermissionsChangeListener>",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mUsageHelper",
    "type" : "PermissionUsageHelper",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mSplitPermissionInfos",
    "type" : "List<SplitPermissionInfo>",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "sShouldWarnMissingActivityManager",
    "type" : "boolean",
    "comment" : " to reduce duplicate logcat output.",
    "links" : [ ]
  }, {
    "name" : "CACHE_KEY_PACKAGE_INFO",
    "type" : "String",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "sPermissionCache",
    "type" : "PropertyInvalidatedCache<PermissionQuery, Integer>",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "sPackageNamePermissionCache",
    "type" : "PropertyInvalidatedCache<PackageNamePermissionQuery, Integer>",
    "comment" : " @hide ",
    "links" : [ ]
  } ],
  "methods" : [ {
    "name" : "public int checkPermissionForDataDelivery(@NonNull String permission, @NonNull AttributionSource attributionSource, @Nullable String message)",
    "returnType" : "int",
    "comment" : "\n     * Checks whether a given data access chain described by the given {@link AttributionSource}\n     * has a given permission.\n     *\n     * <strong>NOTE:</strong> Use this method only for permission checks at the\n     * point where you will deliver the permission protected data to clients.\n     *\n     * <p>For example, if an app registers a location listener it should have the location\n     * permission but no data is actually sent to the app at the moment of registration\n     * and you should use {@link #checkPermissionForPreflight(String, AttributionSource)}\n     * to determine if the app has or may have location permission (if app has only foreground\n     * location the grant state depends on the app's fg/gb state) and this check will not\n     * leave a trace that permission protected data was delivered. When you are about to\n     * deliver the location data to a registered listener you should use this method which\n     * will evaluate the permission access based on the current fg/bg state of the app and\n     * leave a record that the data was accessed.\n     *\n     * <p>Requires the start of the AttributionSource chain to have the UPDATE_APP_OPS_STATS\n     * permission for the app op accesses to be given the TRUSTED_PROXY/PROXIED flags, otherwise the\n     * accesses will have the UNTRUSTED flags.\n     *\n     * @param permission The permission to check.\n     * @param attributionSource the permission identity\n     * @param message A message describing the reason the permission was checked\n     * @return The permission check result which is either {@link #PERMISSION_GRANTED}\n     *     or {@link #PERMISSION_SOFT_DENIED} or {@link #PERMISSION_HARD_DENIED}.\n     *\n     * @see #checkPermissionForPreflight(String, AttributionSource)\n     ",
    "links" : [ "#PERMISSION_HARD_DENIED", "#PERMISSION_GRANTED", "android.content.AttributionSource", "#checkPermissionForPreflight(String", "#PERMISSION_SOFT_DENIED" ]
  }, {
    "name" : "public int checkPermissionForStartDataDelivery(@NonNull String permission, @NonNull AttributionSource attributionSource, @Nullable String message)",
    "returnType" : "int",
    "comment" : "\n     *\n     * Similar to checkPermissionForDataDelivery, except it results in an app op start, rather than\n     * a note. If this method is used, then {@link #finishDataDelivery(String, AttributionSource)}\n     * must be used when access is finished.\n     *\n     * @param permission The permission to check.\n     * @param attributionSource the permission identity\n     * @param message A message describing the reason the permission was checked\n     * @return The permission check result which is either {@link #PERMISSION_GRANTED}\n     *     or {@link #PERMISSION_SOFT_DENIED} or {@link #PERMISSION_HARD_DENIED}.\n     *\n     * <p>Requires the start of the AttributionSource chain to have the UPDATE_APP_OPS_STATS\n     * permission for the app op accesses to be given the TRUSTED_PROXY/PROXIED flags, otherwise the\n     * accesses will have the UNTRUSTED flags.\n     *\n     * @see #checkPermissionForDataDelivery(String, AttributionSource, String)\n     ",
    "links" : [ "#PERMISSION_HARD_DENIED", "#PERMISSION_GRANTED", "#PERMISSION_SOFT_DENIED", "#finishDataDelivery(String" ]
  }, {
    "name" : "public void finishDataDelivery(@NonNull String permission, @NonNull AttributionSource attributionSource)",
    "returnType" : "void",
    "comment" : "\n     * Indicate that usage has finished for an {@link AttributionSource} started with\n     * {@link #checkPermissionForStartDataDelivery(String, AttributionSource, String)}\n     *\n     * @param permission The permission to check.\n     * @param attributionSource the permission identity to finish\n     ",
    "links" : [ "android.content.AttributionSource", "#checkPermissionForStartDataDelivery(String" ]
  }, {
    "name" : "public int checkPermissionForDataDeliveryFromDataSource(@NonNull String permission, @NonNull AttributionSource attributionSource, @Nullable String message)",
    "returnType" : "int",
    "comment" : "\n     * Checks whether a given data access chain described by the given {@link AttributionSource}\n     * has a given permission. Call this method if you are the datasource which would not blame you\n     * for access to the data since you are the data. Use this API if you are the datasource of the\n     * protected state.\n     *\n     * <strong>NOTE:</strong> Use this method only for permission checks at the\n     * point where you will deliver the permission protected data to clients.\n     *\n     * <p>For example, if an app registers a location listener it should have the location\n     * permission but no data is actually sent to the app at the moment of registration\n     * and you should use {@link #checkPermissionForPreflight(String, AttributionSource)}\n     * to determine if the app has or may have location permission (if app has only foreground\n     * location the grant state depends on the app's fg/gb state) and this check will not\n     * leave a trace that permission protected data was delivered. When you are about to\n     * deliver the location data to a registered listener you should use this method which\n     * will evaluate the permission access based on the current fg/bg state of the app and\n     * leave a record that the data was accessed.\n     *\n     * <p>Requires the start of the AttributionSource chain to have the UPDATE_APP_OPS_STATS\n     * permission for the app op accesses to be given the TRUSTED_PROXY/PROXIED flags, otherwise the\n     * accesses will have the UNTRUSTED flags.\n     *\n     * @param permission The permission to check.\n     * @param attributionSource the permission identity\n     * @param message A message describing the reason the permission was checked\n     * @return The permission check result which is either {@link #PERMISSION_GRANTED}\n     *     or {@link #PERMISSION_SOFT_DENIED} or {@link #PERMISSION_HARD_DENIED}.\n     *\n     * @see #checkPermissionForPreflight(String, AttributionSource)\n     ",
    "links" : [ "#PERMISSION_HARD_DENIED", "#PERMISSION_GRANTED", "android.content.AttributionSource", "#checkPermissionForPreflight(String", "#PERMISSION_SOFT_DENIED" ]
  }, {
    "name" : "public int checkPermissionForPreflight(@NonNull String permission, @NonNull AttributionSource attributionSource)",
    "returnType" : "int",
    "comment" : "\n     * Checks whether a given data access chain described by the given {@link AttributionSource}\n     * has a given permission.\n     *\n     * <strong>NOTE:</strong> Use this method only for permission checks at the\n     * preflight point where you will not deliver the permission protected data\n     * to clients but schedule permission data delivery, apps register listeners,\n     * etc.\n     *\n     * <p>For example, if an app registers a data listener it should have the required\n     * permission but no data is actually sent to the app at the moment of registration\n     * and you should use this method to determine if the app has or may have the\n     * permission and this check will not leave a trace that permission protected data\n     * was delivered. When you are about to deliver the protected data to a registered\n     * listener you should use {@link #checkPermissionForDataDelivery(String,\n     * AttributionSource, String)} which will evaluate the permission access based\n     * on the current fg/bg state of the app and leave a record that the data was accessed.\n     *\n     * @param permission The permission to check.\n     * @param attributionSource The identity for which to check the permission.\n     * @return The permission check result which is either {@link #PERMISSION_GRANTED}\n     *     or {@link #PERMISSION_SOFT_DENIED} or {@link #PERMISSION_HARD_DENIED}.\n     ",
    "links" : [ "#checkPermissionForDataDelivery(String", "#PERMISSION_HARD_DENIED", "#PERMISSION_GRANTED", "android.content.AttributionSource", "#PERMISSION_SOFT_DENIED" ]
  }, {
    "name" : "public PermissionInfo getPermissionInfo(@NonNull String permissionName, @PackageManager.PermissionInfoFlags int flags)",
    "returnType" : "PermissionInfo",
    "comment" : "\n     * Retrieve all of the information we know about a particular permission.\n     *\n     * @param permissionName the fully qualified name (e.g. com.android.permission.LOGIN) of the\n     *                       permission you are interested in\n     * @param flags additional option flags to modify the data returned\n     * @return a {@link PermissionInfo} containing information about the permission, or {@code null}\n     *         if not found\n     *\n     * @hide Pending API\n     ",
    "links" : [ "android.content.pm.PermissionInfo" ]
  }, {
    "name" : "public List<PermissionInfo> queryPermissionsByGroup(@Nullable String groupName, @PackageManager.PermissionInfoFlags int flags)",
    "returnType" : "List<PermissionInfo>",
    "comment" : "\n     * Query for all of the permissions associated with a particular group.\n     *\n     * @param groupName the fully qualified name (e.g. com.android.permission.LOGIN) of the\n     *                  permission group you are interested in. Use {@code null} to find all of the\n     *                  permissions not associated with a group\n     * @param flags additional option flags to modify the data returned\n     * @return a list of {@link PermissionInfo} containing information about all of the permissions\n     *         in the given group, or {@code null} if the group is not found\n     *\n     * @hide Pending API\n     ",
    "links" : [ "android.content.pm.PermissionInfo" ]
  }, {
    "name" : "public boolean addPermission(@NonNull PermissionInfo permissionInfo, boolean async)",
    "returnType" : "boolean",
    "comment" : "\n     * Add a new dynamic permission to the system. For this to work, your package must have defined\n     * a permission tree through the\n     * {@link android.R.styleable#AndroidManifestPermissionTree &lt;permission-tree&gt;} tag in its\n     * manifest. A package can only add permissions to trees that were defined by either its own\n     * package or another with the same user id; a permission is in a tree if it matches the name of\n     * the permission tree + \".\": for example, \"com.foo.bar\" is a member of the permission tree\n     * \"com.foo\".\n     * <p>\n     * It is good to make your permission tree name descriptive, because you are taking possession\n     * of that entire set of permission names. Thus, it must be under a domain you control, with a\n     * suffix that will not match any normal permissions that may be declared in any applications\n     * that are part of that domain.\n     * <p>\n     * New permissions must be added before any .apks are installed that use those permissions.\n     * Permissions you add through this method are remembered across reboots of the device. If the\n     * given permission already exists, the info you supply here will be used to update it.\n     *\n     * @param permissionInfo description of the permission to be added\n     * @param async whether the persistence of the permission should be asynchronous, allowing it to\n     *              return quicker and batch a series of adds, at the expense of no guarantee the\n     *              added permission will be retained if the device is rebooted before it is\n     *              written.\n     * @return {@code true} if a new permission was created, {@code false} if an existing one was\n     *         updated\n     * @throws SecurityException if you are not allowed to add the given permission name\n     *\n     * @see #removePermission(String)\n     *\n     * @hide Pending API\n     ",
    "links" : [ "android.R.styleable#AndroidManifestPermissionTree" ]
  }, {
    "name" : "public void removePermission(@NonNull String permissionName)",
    "returnType" : "void",
    "comment" : "\n     * Removes a permission that was previously added with\n     * {@link #addPermission(PermissionInfo, boolean)}. The same ownership rules apply -- you are\n     * only allowed to remove permissions that you are allowed to add.\n     *\n     * @param permissionName the name of the permission to remove\n     * @throws SecurityException if you are not allowed to remove the given permission name\n     *\n     * @see #addPermission(PermissionInfo, boolean)\n     *\n     * @hide Pending API\n     ",
    "links" : [ "#addPermission(PermissionInfo" ]
  }, {
    "name" : "public PermissionGroupInfo getPermissionGroupInfo(@NonNull String groupName, @PackageManager.PermissionGroupInfoFlags int flags)",
    "returnType" : "PermissionGroupInfo",
    "comment" : "\n     * Retrieve all of the information we know about a particular group of permissions.\n     *\n     * @param groupName the fully qualified name (e.g. com.android.permission_group.APPS) of the\n     *                  permission you are interested in\n     * @param flags additional option flags to modify the data returned\n     * @return a {@link PermissionGroupInfo} containing information about the permission, or\n     *         {@code null} if not found\n     *\n     * @hide Pending API\n     ",
    "links" : [ "android.content.pm.PermissionGroupInfo" ]
  }, {
    "name" : "public List<PermissionGroupInfo> getAllPermissionGroups(@PackageManager.PermissionGroupInfoFlags int flags)",
    "returnType" : "List<PermissionGroupInfo>",
    "comment" : "\n     * Retrieve all of the known permission groups in the system.\n     *\n     * @param flags additional option flags to modify the data returned\n     * @return a list of {@link PermissionGroupInfo} containing information about all of the known\n     *         permission groups\n     *\n     * @hide Pending API\n     ",
    "links" : [ "android.content.pm.PermissionGroupInfo" ]
  }, {
    "name" : "public boolean isPermissionRevokedByPolicy(@NonNull String packageName, @NonNull String permissionName)",
    "returnType" : "boolean",
    "comment" : "\n     * Checks whether a particular permissions has been revoked for a package by policy. Typically\n     * the device owner or the profile owner may apply such a policy. The user cannot grant policy\n     * revoked permissions, hence the only way for an app to get such a permission is by a policy\n     * change.\n     *\n     * @param packageName the name of the package you are checking against\n     * @param permissionName the name of the permission you are checking for\n     *\n     * @return whether the permission is restricted by policy\n     *\n     * @hide Pending API\n     ",
    "links" : [ ]
  }, {
    "name" : "public static boolean shouldTraceGrant(@NonNull String packageName, @NonNull String permissionName, int userId)",
    "returnType" : "boolean",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "public void grantRuntimePermission(@NonNull String packageName, @NonNull String permissionName, @NonNull UserHandle user)",
    "returnType" : "void",
    "comment" : "\n     * Grant a runtime permission to an application which the application does not already have. The\n     * permission must have been requested by the application. If the application is not allowed to\n     * hold the permission, a {@link java.lang.SecurityException} is thrown. If the package or\n     * permission is invalid, a {@link java.lang.IllegalArgumentException} is thrown.\n     * <p>\n     * <strong>Note: </strong>Using this API requires holding\n     * {@code android.permission.GRANT_RUNTIME_PERMISSIONS} and if the user ID is not the current\n     * user {@code android.permission.INTERACT_ACROSS_USERS_FULL}.\n     *\n     * @param packageName the package to which to grant the permission\n     * @param permissionName the permission name to grant\n     * @param user the user for which to grant the permission\n     *\n     * @see #revokeRuntimePermission(String, String, android.os.UserHandle, String)\n     *\n     * @hide\n     ",
    "links" : [ "java.lang.SecurityException", "java.lang.IllegalArgumentException" ]
  }, {
    "name" : "public void grantRuntimePermission(@NonNull String packageName, @NonNull String permissionName, @NonNull String persistentDeviceId)",
    "returnType" : "void",
    "comment" : "\n     * Grant a runtime permission to an application which the application does not already have. The\n     * permission must have been requested by the application. If the application is not allowed to\n     * hold the permission, a {@link java.lang.SecurityException} is thrown. If the package or\n     * permission is invalid, a {@link java.lang.IllegalArgumentException} is thrown.\n     *\n     * @param packageName the package to which to grant the permission\n     * @param permissionName the permission name to grant\n     * @param persistentDeviceId the device Id to which to grant the permission\n     *\n     * @see #revokeRuntimePermission(String, String, String, String)\n     *\n     * @hide\n     ",
    "links" : [ "java.lang.SecurityException", "java.lang.IllegalArgumentException" ]
  }, {
    "name" : "private void grantRuntimePermissionInternal(@NonNull String packageName, @NonNull String permissionName, @NonNull String persistentDeviceId, @NonNull UserHandle user)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public void revokeRuntimePermission(@NonNull String packageName, @NonNull String permissionName, @NonNull UserHandle user, @Nullable String reason)",
    "returnType" : "void",
    "comment" : "\n     * Revoke a runtime permission that was previously granted by\n     * {@link #grantRuntimePermission(String, String, android.os.UserHandle)}. The permission must\n     * have been requested by and granted to the application. If the application is not allowed to\n     * hold the permission, a {@link java.lang.SecurityException} is thrown. If the package or\n     * permission is invalid, a {@link java.lang.IllegalArgumentException} is thrown.\n     * <p>\n     * <strong>Note: </strong>Using this API requires holding\n     * {@code android.permission.REVOKE_RUNTIME_PERMISSIONS} and if the user ID is not the current\n     * user {@code android.permission.INTERACT_ACROSS_USERS_FULL}.\n     *\n     * @param packageName the package from which to revoke the permission\n     * @param permissionName the permission name to revoke\n     * @param user the user for which to revoke the permission\n     * @param reason the reason for the revoke, or {@code null} for unspecified\n     *\n     * @see #grantRuntimePermission(String, String, android.os.UserHandle)\n     *\n     * @hide\n     ",
    "links" : [ "#grantRuntimePermission(String", "java.lang.SecurityException", "java.lang.IllegalArgumentException" ]
  }, {
    "name" : "public void revokeRuntimePermission(@NonNull String packageName, @NonNull String permissionName, @NonNull String persistentDeviceId, @Nullable String reason)",
    "returnType" : "void",
    "comment" : "\n     * Revoke a runtime permission that was previously granted by\n     * {@link #grantRuntimePermission(String, String, String)}. The permission must\n     * have been requested by and granted to the application. If the application is not allowed to\n     * hold the permission, a {@link java.lang.SecurityException} is thrown. If the package or\n     * permission is invalid, a {@link java.lang.IllegalArgumentException} is thrown.\n     *\n     * @param packageName the package from which to revoke the permission\n     * @param permissionName the permission name to revoke\n     * @param persistentDeviceId the persistent device id for which to revoke the permission\n     * @param reason the reason for the revoke, or {@code null} for unspecified\n     *\n     * @see #grantRuntimePermission(String, String, String)\n     *\n     * @hide\n     ",
    "links" : [ "#grantRuntimePermission(String", "java.lang.SecurityException", "java.lang.IllegalArgumentException" ]
  }, {
    "name" : "private void revokeRuntimePermissionInternal(@NonNull String packageName, @NonNull String permissionName, @NonNull String persistentDeviceId, @NonNull UserHandle user, @Nullable String reason)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public int getPermissionFlags(@NonNull String packageName, @NonNull String permissionName, @NonNull UserHandle user)",
    "returnType" : "int",
    "comment" : "\n     * Gets the state flags associated with a permission.\n     *\n     * @param packageName the package name for which to get the flags\n     * @param permissionName the permission for which to get the flags\n     * @param user the user for which to get permission flags\n     * @return the permission flags\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public int getPermissionFlags(@NonNull String packageName, @NonNull String permissionName, @NonNull String persistentDeviceId)",
    "returnType" : "int",
    "comment" : "\n     * Gets the state flags associated with a permission.\n     *\n     * @param packageName the package name for which to get the flags\n     * @param permissionName the permission for which to get the flags\n     * @param persistentDeviceId the persistent device Id for which to get permission flags\n     * @return the permission flags\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "private int getPermissionFlagsInternal(@NonNull String packageName, @NonNull String permissionName, @NonNull String persistentDeviceId, @NonNull UserHandle user)",
    "returnType" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public void updatePermissionFlags(@NonNull String packageName, @NonNull String permissionName, @PackageManager.PermissionFlags int flagMask, @PackageManager.PermissionFlags int flagValues, @NonNull UserHandle user)",
    "returnType" : "void",
    "comment" : "\n     * Updates the flags associated with a permission by replacing the flags in the specified mask\n     * with the provided flag values.\n     *\n     * @param packageName The package name for which to update the flags\n     * @param permissionName The permission for which to update the flags\n     * @param flagMask The flags which to replace\n     * @param flagValues The flags with which to replace\n     * @param user The user for which to update the permission flags\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public void updatePermissionFlags(@NonNull String packageName, @NonNull String permissionName, @NonNull String persistentDeviceId, @PackageManager.PermissionFlags int flagMask, @PackageManager.PermissionFlags int flagValues)",
    "returnType" : "void",
    "comment" : "\n     * Updates the flags associated with a permission by replacing the flags in the specified mask\n     * with the provided flag values.\n     *\n     * @param packageName The package name for which to update the flags\n     * @param permissionName The permission for which to update the flags\n     * @param persistentDeviceId The persistent device for which to update the permission flags\n     * @param flagMask The flags which to replace\n     * @param flagValues The flags with which to replace\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "private void updatePermissionFlagsInternal(@NonNull String packageName, @NonNull String permissionName, @PackageManager.PermissionFlags int flagMask, @PackageManager.PermissionFlags int flagValues, @NonNull String persistentDeviceId, @NonNull UserHandle user)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public Set<String> getAllowlistedRestrictedPermissions(@NonNull String packageName, @PackageManager.PermissionWhitelistFlags int allowlistFlag)",
    "returnType" : "Set<String>",
    "comment" : "\n     * Gets the restricted permissions that have been allowlisted and the app is allowed to have\n     * them granted in their full form.\n     * <p>\n     * Permissions can be hard restricted which means that the app cannot hold them or soft\n     * restricted where the app can hold the permission but in a weaker form. Whether a permission\n     * is {@link PermissionInfo#FLAG_HARD_RESTRICTED hard restricted} or\n     * {@link PermissionInfo#FLAG_SOFT_RESTRICTED soft restricted} depends on the permission\n     * declaration. Allowlisting a hard restricted permission allows for the to hold that permission\n     * and allowlisting a soft restricted permission allows the app to hold the permission in its\n     * full, unrestricted form.\n     * <p>\n     * There are four allowlists:\n     * <ol>\n     * <li>\n     * One for cases where the system permission policy allowlists a permission. This list\n     * corresponds to the {@link PackageManager#FLAG_PERMISSION_WHITELIST_SYSTEM} flag. Can only be\n     * accessed by pre-installed holders of a dedicated permission.\n     * <li>\n     * One for cases where the system allowlists the permission when upgrading from an OS version in\n     * which the permission was not restricted to an OS version in which the permission is\n     * restricted. This list corresponds to the\n     * {@link PackageManager#FLAG_PERMISSION_WHITELIST_UPGRADE} flag. Can be accessed by\n     * pre-installed holders of a dedicated permission or the installer on record.\n     * <li>\n     * One for cases where the installer of the package allowlists a permission. This list\n     * corresponds to the {@link PackageManager#FLAG_PERMISSION_WHITELIST_INSTALLER} flag. Can be\n     * accessed by pre-installed holders of a dedicated permission or the installer on record.\n     * </ol>\n     *\n     * @param packageName the app for which to get allowlisted permissions\n     * @param allowlistFlag the flag to determine which allowlist to query. Only one flag can be\n     *                      passed.\n     * @return the allowlisted permissions that are on any of the allowlists you query for\n     * @throws SecurityException if you try to access a allowlist that you have no access to\n     *\n     * @see #addAllowlistedRestrictedPermission(String, String, int)\n     * @see #removeAllowlistedRestrictedPermission(String, String, int)\n     * @see PackageManager#FLAG_PERMISSION_WHITELIST_SYSTEM\n     * @see PackageManager#FLAG_PERMISSION_WHITELIST_UPGRADE\n     * @see PackageManager#FLAG_PERMISSION_WHITELIST_INSTALLER\n     *\n     * @hide Pending API\n     ",
    "links" : [ "android.content.pm.IPackageManager#FLAG_PERMISSION_WHITELIST_SYSTEM", "android.content.pm.IPackageManager#FLAG_PERMISSION_WHITELIST_UPGRADE", "android.content.pm.IPackageManager#FLAG_PERMISSION_WHITELIST_INSTALLER", "android.content.pm.PermissionInfo#FLAG_SOFT_RESTRICTED", "android.content.pm.PermissionInfo#FLAG_HARD_RESTRICTED" ]
  }, {
    "name" : "public boolean addAllowlistedRestrictedPermission(@NonNull String packageName, @NonNull String permissionName, @PackageManager.PermissionWhitelistFlags int allowlistFlags)",
    "returnType" : "boolean",
    "comment" : "\n     * Adds a allowlisted restricted permission for an app.\n     * <p>\n     * Permissions can be hard restricted which means that the app cannot hold them or soft\n     * restricted where the app can hold the permission but in a weaker form. Whether a permission\n     * is {@link PermissionInfo#FLAG_HARD_RESTRICTED hard restricted} or\n     * {@link PermissionInfo#FLAG_SOFT_RESTRICTED soft restricted} depends on the permission\n     * declaration. Allowlisting a hard restricted permission allows for the to hold that permission\n     * and allowlisting a soft restricted permission allows the app to hold the permission in its\n     * full, unrestricted form.\n     * <p>There are four allowlists:\n     * <ol>\n     * <li>\n     * One for cases where the system permission policy allowlists a permission. This list\n     * corresponds to the {@link PackageManager#FLAG_PERMISSION_WHITELIST_SYSTEM} flag. Can only be\n     * accessed by pre-installed holders of a dedicated permission.\n     * <li>\n     * One for cases where the system allowlists the permission when upgrading from an OS version in\n     * which the permission was not restricted to an OS version in which the permission is\n     * restricted. This list corresponds to the\n     * {@link PackageManager#FLAG_PERMISSION_WHITELIST_UPGRADE} flag. Can be accessed by\n     * pre-installed holders of a dedicated permission or the installer on record.\n     * <li>\n     * One for cases where the installer of the package allowlists a permission. This list\n     * corresponds to the {@link PackageManager#FLAG_PERMISSION_WHITELIST_INSTALLER} flag. Can be\n     * accessed by pre-installed holders of a dedicated permission or the installer on record.\n     * </ol>\n     * <p>\n     * You need to specify the allowlists for which to set the allowlisted permissions which will\n     * clear the previous allowlisted permissions and replace them with the provided ones.\n     *\n     * @param packageName the app for which to get allowlisted permissions\n     * @param permissionName the allowlisted permission to add\n     * @param allowlistFlags the allowlists to which to add. Passing multiple flags updates all\n     *                       specified allowlists.\n     * @return whether the permission was added to the allowlist\n     * @throws SecurityException if you try to modify a allowlist that you have no access to.\n     *\n     * @see #getAllowlistedRestrictedPermissions(String, int)\n     * @see #removeAllowlistedRestrictedPermission(String, String, int)\n     * @see PackageManager#FLAG_PERMISSION_WHITELIST_SYSTEM\n     * @see PackageManager#FLAG_PERMISSION_WHITELIST_UPGRADE\n     * @see PackageManager#FLAG_PERMISSION_WHITELIST_INSTALLER\n     *\n     * @hide Pending API\n     ",
    "links" : [ "android.content.pm.IPackageManager#FLAG_PERMISSION_WHITELIST_SYSTEM", "android.content.pm.IPackageManager#FLAG_PERMISSION_WHITELIST_UPGRADE", "android.content.pm.IPackageManager#FLAG_PERMISSION_WHITELIST_INSTALLER", "android.content.pm.PermissionInfo#FLAG_SOFT_RESTRICTED", "android.content.pm.PermissionInfo#FLAG_HARD_RESTRICTED" ]
  }, {
    "name" : "public boolean removeAllowlistedRestrictedPermission(@NonNull String packageName, @NonNull String permissionName, @PackageManager.PermissionWhitelistFlags int allowlistFlags)",
    "returnType" : "boolean",
    "comment" : "\n     * Removes a allowlisted restricted permission for an app.\n     * <p>\n     * Permissions can be hard restricted which means that the app cannot hold them or soft\n     * restricted where the app can hold the permission but in a weaker form. Whether a permission\n     * is {@link PermissionInfo#FLAG_HARD_RESTRICTED hard restricted} or\n     * {@link PermissionInfo#FLAG_SOFT_RESTRICTED soft restricted} depends on the permission\n     * declaration. Allowlisting a hard restricted permission allows for the to hold that permission\n     * and allowlisting a soft restricted permission allows the app to hold the permission in its\n     * full, unrestricted form.\n     * <p>There are four allowlists:\n     * <ol>\n     * <li>\n     * One for cases where the system permission policy allowlists a permission. This list\n     * corresponds to the {@link PackageManager#FLAG_PERMISSION_WHITELIST_SYSTEM} flag. Can only be\n     * accessed by pre-installed holders of a dedicated permission.\n     * <li>\n     * One for cases where the system allowlists the permission when upgrading from an OS version in\n     * which the permission was not restricted to an OS version in which the permission is\n     * restricted. This list corresponds to the\n     * {@link PackageManager#FLAG_PERMISSION_WHITELIST_UPGRADE} flag. Can be accessed by\n     * pre-installed holders of a dedicated permission or the installer on record.\n     * <li>\n     * One for cases where the installer of the package allowlists a permission. This list\n     * corresponds to the {@link PackageManager#FLAG_PERMISSION_WHITELIST_INSTALLER} flag. Can be\n     * accessed by pre-installed holders of a dedicated permission or the installer on record.\n     * </ol>\n     * <p>\n     * You need to specify the allowlists for which to set the allowlisted permissions which will\n     * clear the previous allowlisted permissions and replace them with the provided ones.\n     *\n     * @param packageName the app for which to get allowlisted permissions\n     * @param permissionName the allowlisted permission to remove\n     * @param allowlistFlags the allowlists from which to remove. Passing multiple flags updates all\n     *                       specified allowlists.\n     * @return whether the permission was removed from the allowlist\n     * @throws SecurityException if you try to modify a allowlist that you have no access to.\n     *\n     * @see #getAllowlistedRestrictedPermissions(String, int)\n     * @see #addAllowlistedRestrictedPermission(String, String, int)\n     * @see PackageManager#FLAG_PERMISSION_WHITELIST_SYSTEM\n     * @see PackageManager#FLAG_PERMISSION_WHITELIST_UPGRADE\n     * @see PackageManager#FLAG_PERMISSION_WHITELIST_INSTALLER\n     *\n     * @hide Pending API\n     ",
    "links" : [ "android.content.pm.IPackageManager#FLAG_PERMISSION_WHITELIST_SYSTEM", "android.content.pm.IPackageManager#FLAG_PERMISSION_WHITELIST_UPGRADE", "android.content.pm.IPackageManager#FLAG_PERMISSION_WHITELIST_INSTALLER", "android.content.pm.PermissionInfo#FLAG_SOFT_RESTRICTED", "android.content.pm.PermissionInfo#FLAG_HARD_RESTRICTED" ]
  }, {
    "name" : "public boolean isAutoRevokeExempted(@NonNull String packageName)",
    "returnType" : "boolean",
    "comment" : "\n     * Checks whether an application is exempted from having its permissions be automatically\n     * revoked when the app is unused for an extended period of time.\n     * <p>\n     * Only the installer on record that installed the given package, or a holder of\n     * {@code WHITELIST_AUTO_REVOKE_PERMISSIONS} is allowed to call this.\n     *\n     * @param packageName the app for which to set exemption\n     * @return whether the app is exempted\n     * @throws SecurityException if you you have no access to this\n     *\n     * @see #setAutoRevokeExempted\n     *\n     * @hide Pending API\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean setAutoRevokeExempted(@NonNull String packageName, boolean exempted)",
    "returnType" : "boolean",
    "comment" : "\n     * Marks an application exempted from having its permissions be automatically revoked when the\n     * app is unused for an extended period of time.\n     * <p>\n     * Only the installer on record that installed the given package is allowed to call this.\n     * <p>\n     * Packages start in exempted state, and it is the installer's responsibility to un-exempt the\n     * packages it installs, unless auto-revoking permissions from that package would cause\n     * breakages beyond having to re-request the permission(s).\n     *\n     * @param packageName the app for which to set exemption\n     * @param exempted whether the app should be exempted\n     * @return whether any change took effect\n     * @throws SecurityException if you you have no access to modify this\n     *\n     * @see #isAutoRevokeExempted\n     *\n     * @hide Pending API\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean shouldShowRequestPermissionRationale(@NonNull String permissionName)",
    "returnType" : "boolean",
    "comment" : "@SystemApi(client = SystemApi.Client.MODULE_LIBRARIES)",
    "links" : [ ]
  }, {
    "name" : "public void addOnPermissionsChangeListener(@NonNull PackageManager.OnPermissionsChangedListener listener)",
    "returnType" : "void",
    "comment" : "@SystemApi",
    "links" : [ ]
  }, {
    "name" : "public void removeOnPermissionsChangeListener(@NonNull PackageManager.OnPermissionsChangedListener listener)",
    "returnType" : "void",
    "comment" : "@SystemApi",
    "links" : [ ]
  }, {
    "name" : "public int getRuntimePermissionsVersion()",
    "returnType" : "int",
    "comment" : "\n     * Gets the version of the runtime permission database.\n     *\n     * @return The database version, -1 when this is an upgrade from pre-Q, 0 when this is a fresh\n     * install.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public void setRuntimePermissionsVersion(@IntRange(from = 0) int version)",
    "returnType" : "void",
    "comment" : "\n     * Sets the version of the runtime permission database.\n     *\n     * @param version The new version.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public List<SplitPermissionInfo> getSplitPermissions()",
    "returnType" : "List<SplitPermissionInfo>",
    "comment" : "\n     * Get set of permissions that have been split into more granular or dependent permissions.\n     *\n     * <p>E.g. before {@link android.os.Build.VERSION_CODES#Q} an app that was granted\n     * {@link Manifest.permission#ACCESS_COARSE_LOCATION} could access the location while it was in\n     * foreground and background. On platforms after {@link android.os.Build.VERSION_CODES#Q}\n     * the location permission only grants location access while the app is in foreground. This\n     * would break apps that target before {@link android.os.Build.VERSION_CODES#Q}. Hence whenever\n     * such an old app asks for a location permission (i.e. the\n     * {@link SplitPermissionInfo#getSplitPermission()}), then the\n     * {@link Manifest.permission#ACCESS_BACKGROUND_LOCATION} permission (inside\n     * {@link SplitPermissionInfo#getNewPermissions}) is added.\n     *\n     * <p>Note: Regular apps do not have to worry about this. The platform and permission controller\n     * automatically add the new permissions where needed.\n     *\n     * @return All permissions that are split.\n     ",
    "links" : [ "android.os.Build.VERSION_CODES#Q", "Manifest.permission#ACCESS_COARSE_LOCATION", "Manifest.permission#ACCESS_BACKGROUND_LOCATION", "#getSplitPermission()", "#getNewPermissions" ]
  }, {
    "name" : "public void initializeUsageHelper()",
    "returnType" : "void",
    "comment" : "\n     * Initialize the PermissionUsageHelper, which will register active app op listeners\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public void tearDownUsageHelper()",
    "returnType" : "void",
    "comment" : "\n     * Teardown the PermissionUsageHelper, removing listeners\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public List<PermissionGroupUsage> getIndicatorAppOpUsageData()",
    "returnType" : "List<PermissionGroupUsage>",
    "comment" : "\n     * @return A list of permission groups currently or recently used by all apps by all users in\n     * the current profile group.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public List<PermissionGroupUsage> getIndicatorAppOpUsageData(boolean micMuted)",
    "returnType" : "List<PermissionGroupUsage>",
    "comment" : "\n     * @param micMuted whether to consider the microphone muted when retrieving audio ops\n     * @return A list of permission groups currently or recently used by all apps by all users in\n     * the current profile group.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public static boolean shouldShowPackageForIndicatorCached(@NonNull Context context, @NonNull String packageName)",
    "returnType" : "boolean",
    "comment" : "\n     * Determine if a package should be shown in indicators. Only a select few roles, and the\n     * system app itself, are hidden. These values are updated at most every 15 seconds.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public static Set<String> getIndicatorExemptedPackages(@NonNull Context context)",
    "returnType" : "Set<String>",
    "comment" : "\n     * Get the list of packages that are not shown by the indicators. Only a select few roles, and\n     * the system app itself, are hidden. These values are updated at most every 15 seconds.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public static void updateIndicatorExemptedPackages(@NonNull Context context)",
    "returnType" : "void",
    "comment" : "\n     * Update the cached indicator exempted packages\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public Set<String> getAutoRevokeExemptionRequestedPackages()",
    "returnType" : "Set<String>",
    "comment" : "\n     * Gets the list of packages that have permissions that specified\n     * {@code requestDontAutoRevokePermissions=true} in their\n     * {@code application} manifest declaration.\n     *\n     * @return the list of packages for current user\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public Set<String> getAutoRevokeExemptionGrantedPackages()",
    "returnType" : "Set<String>",
    "comment" : "\n     * Gets the list of packages that have permissions that specified\n     * {@code autoRevokePermissions=disallowed} in their\n     * {@code application} manifest declaration.\n     *\n     * @return the list of packages for current user\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "private List<SplitPermissionInfo> splitPermissionInfoListToNonParcelableList(List<SplitPermissionInfoParcelable> parcelableList)",
    "returnType" : "List<SplitPermissionInfo>",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public static List<SplitPermissionInfoParcelable> splitPermissionInfoListToParcelableList(List<SplitPermissionInfo> splitPermissionsList)",
    "returnType" : "List<SplitPermissionInfoParcelable>",
    "comment" : "\n     * Converts a {@link List} of {@link SplitPermissionInfo} into a List of\n     * {@link SplitPermissionInfoParcelable} and returns it.\n     * @hide\n     ",
    "links" : [ "SplitPermissionInfo", "android.content.pm.permission.SplitPermissionInfoParcelable", "java.util.ArrayList" ]
  }, {
    "name" : "public void startOneTimePermissionSession(@NonNull String packageName, long timeoutMillis, @ActivityManager.RunningAppProcessInfo.Importance int importanceToResetTimer, @ActivityManager.RunningAppProcessInfo.Importance int importanceToKeepSessionAlive)",
    "returnType" : "void",
    "comment" : "\n     * Starts a one-time permission session for a given package.\n     * @see #startOneTimePermissionSession(String, long, long, int, int)\n     * @hide\n     * @deprecated Use {@link #startOneTimePermissionSession(String, long, long, int, int)} instead\n     ",
    "links" : [ "#startOneTimePermissionSession(String" ]
  }, {
    "name" : "public void startOneTimePermissionSession(@NonNull String packageName, @DurationMillisLong long timeoutMillis, @DurationMillisLong long revokeAfterKilledDelayMillis, @ActivityManager.RunningAppProcessInfo.Importance int importanceToResetTimer, @ActivityManager.RunningAppProcessInfo.Importance int importanceToKeepSessionAlive)",
    "returnType" : "void",
    "comment" : "\n     * Starts a one-time permission session for a given package. A one-time permission session is\n     * ended if app becomes inactive. Inactivity is defined as the package's uid importance level\n     * staying > importanceToResetTimer for timeoutMillis milliseconds. If the package's uid\n     * importance level goes <= importanceToResetTimer then the timer is reset and doesn't start\n     * until going > importanceToResetTimer.\n     * <p>\n     * When this timeoutMillis is reached if the importance level is <= importanceToKeepSessionAlive\n     * then the session is extended until either the importance goes above\n     * importanceToKeepSessionAlive which will end the session or <= importanceToResetTimer which\n     * will continue the session and reset the timer.\n     * </p>\n     * <p>\n     * Importance levels are defined in {@link android.app.ActivityManager.RunningAppProcessInfo}.\n     * </p>\n     * <p>\n     * Once the session ends\n     * {@link PermissionControllerService#onOneTimePermissionSessionTimeout(String)} is invoked.\n     * </p>\n     * <p>\n     * Note that if there is currently an active session for a package a new one isn't created but\n     * each parameter of the existing one will be updated to the more aggressive of both sessions.\n     * This means that durations will be set to the shortest parameter and importances will be set\n     * to the lowest one.\n     * </p>\n     * @param packageName The package to start a one-time permission session for\n     * @param timeoutMillis Number of milliseconds for an app to be in an inactive state\n     * @param revokeAfterKilledDelayMillis Number of milliseconds to wait before revoking on the\n     *                                     event an app is terminated. Set to -1 to use default\n     *                                     value for the device.\n     * @param importanceToResetTimer The least important level to uid must be to reset the timer\n     * @param importanceToKeepSessionAlive The least important level the uid must be to keep the\n     *                                     session alive\n     *\n     * @hide\n     ",
    "links" : [ "android.permission.PermissionControllerService#onOneTimePermissionSessionTimeout(String)", "android.app.ActivityManager.RunningAppProcessInfo" ]
  }, {
    "name" : "public void stopOneTimePermissionSession(@NonNull String packageName)",
    "returnType" : "void",
    "comment" : "\n     * Stops the one-time permission session for the package. The callback to the end of session is\n     * not invoked. If there is no one-time session for the package then nothing happens.\n     *\n     * @param packageName Package to stop the one-time permission session for\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public int checkDeviceIdentifierAccess(@Nullable String packageName, @Nullable String message, @Nullable String callingFeatureId, int pid, int uid)",
    "returnType" : "int",
    "comment" : "\n     * Checks whether the package with the given pid/uid can read device identifiers.\n     *\n     * @param packageName      the name of the package to be checked for identifier access\n     * @param message          the message to be used for logging during identifier access\n     *                         verification\n     * @param callingFeatureId the feature in the package\n     * @param pid              the process id of the package to be checked\n     * @param uid              the uid of the package to be checked\n     * @return {@link PackageManager#PERMISSION_GRANTED} if the package is allowed identifier\n     * access, {@link PackageManager#PERMISSION_DENIED} otherwise\n     * @hide\n     ",
    "links" : [ "android.content.pm.IPackageManager#PERMISSION_GRANTED", "android.content.pm.IPackageManager#PERMISSION_DENIED" ]
  }, {
    "name" : "public AttributionSource registerAttributionSource(@NonNull AttributionSource source)",
    "returnType" : "AttributionSource",
    "comment" : "\n     * Registers an attribution source with the OS. An app can only register an attribution\n     * source for itself. Once an attribution source has been registered another app can\n     * check whether this registration exists and thus trust the payload in the source\n     * object. This is important for permission checking and specifically for app op blaming\n     * since a malicious app should not be able to force the OS to blame another app\n     * that doesn't participate in an attribution chain.\n     *\n     * @param source The attribution source to register.\n     * @return The registered new attribution source.\n     *\n     * @see #isRegisteredAttributionSource(AttributionSource)\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean isRegisteredAttributionSource(@NonNull AttributionSource source)",
    "returnType" : "boolean",
    "comment" : "\n     * Checks whether an attribution source is registered.\n     *\n     * @param source The attribution source to check.\n     * @return Whether this is a registered source.\n     *\n     * @see #registerAttributionSource(AttributionSource)\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public int getRegisteredAttributionSourceCountForTest(int uid)",
    "returnType" : "int",
    "comment" : "\n     * Gets the number of currently registered attribution sources for a particular UID. This should\n     * only be used for testing purposes.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public void revokePostNotificationPermissionWithoutKillForTest(@NonNull String packageName, int userId)",
    "returnType" : "void",
    "comment" : "\n     * Revoke the POST_NOTIFICATIONS permission, without killing the app. This method must ONLY BE\n     * USED in CTS or local tests.\n     *\n     * @param packageName The package to be revoked\n     * @param userId The user for which to revoke\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "private static int checkPermissionUncached(@Nullable String permission, int pid, int uid, int deviceId)",
    "returnType" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public static int checkPermission(@Nullable String permission, int pid, int uid, int deviceId)",
    "returnType" : "int",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "public Map<String, PermissionState> getAllPermissionStates(@NonNull String packageName, @NonNull String persistentDeviceId)",
    "returnType" : "Map<String, PermissionState>",
    "comment" : "\n     * Gets the permission states for requested package and persistent device.\n     * <p>\n     * <strong>Note: </strong>Default device permissions are not inherited in this API. Returns the\n     * exact permission states for the requested device.\n     *\n     * @param packageName name of the package you are checking against\n     * @param persistentDeviceId id of the persistent device you are checking against\n     * @return mapping of all permission states keyed by their permission names\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public static void disablePermissionCache()",
    "returnType" : "void",
    "comment" : "\n     * Make checkPermission() above bypass the permission cache in this process.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "private static int checkPackageNamePermissionUncached(String permName, String pkgName, String persistentDeviceId, @UserIdInt int userId)",
    "returnType" : "int",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "public int checkPackageNamePermission(String permName, String pkgName, int deviceId, @UserIdInt int userId)",
    "returnType" : "int",
    "comment" : "\n     * Check whether a package has a permission for given device.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "private String getPersistentDeviceId(int deviceId)",
    "returnType" : "String",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public int checkPermission(@NonNull String permissionName, @NonNull String packageName, @NonNull String persistentDeviceId)",
    "returnType" : "int",
    "comment" : "\n     * Check whether a package has been granted a permission on a given device.\n     * <p>\n     * <strong>Note: </strong>This API returns the underlying permission state\n     * as-is and is mostly intended for permission managing system apps. To\n     * perform an access check for a certain app, please use the\n     * {@link Context#checkPermission} APIs instead.\n     *\n     * @param permissionName The name of the permission you are checking for.\n     * @param packageName The name of the package you are checking against.\n     * @param persistentDeviceId The id of the physical device that you are checking permission\n     *                           against.\n     *\n     * @return If the package has the permission on the device, PERMISSION_GRANTED is\n     * returned.  If it does not have the permission on the device, PERMISSION_DENIED\n     * is returned.\n     *\n     * @see VirtualDevice#getPersistentDeviceId()\n     * @see PackageManager#PERMISSION_GRANTED\n     * @see PackageManager#PERMISSION_DENIED\n     *\n     * @hide\n     ",
    "links" : [ "android.content.Context#checkPermission" ]
  }, {
    "name" : "public static void disablePackageNamePermissionCache()",
    "returnType" : "void",
    "comment" : "\n     * Make checkPackageNamePermission() bypass the cache in this process.\n     *\n     * @hide\n     ",
    "links" : [ ]
  } ],
  "methodNames" : [ "public int checkPermissionForDataDelivery(@NonNull String permission, @NonNull AttributionSource attributionSource, @Nullable String message)", "public int checkPermissionForStartDataDelivery(@NonNull String permission, @NonNull AttributionSource attributionSource, @Nullable String message)", "public void finishDataDelivery(@NonNull String permission, @NonNull AttributionSource attributionSource)", "public int checkPermissionForDataDeliveryFromDataSource(@NonNull String permission, @NonNull AttributionSource attributionSource, @Nullable String message)", "public int checkPermissionForPreflight(@NonNull String permission, @NonNull AttributionSource attributionSource)", "public PermissionInfo getPermissionInfo(@NonNull String permissionName, @PackageManager.PermissionInfoFlags int flags)", "public List<PermissionInfo> queryPermissionsByGroup(@Nullable String groupName, @PackageManager.PermissionInfoFlags int flags)", "public boolean addPermission(@NonNull PermissionInfo permissionInfo, boolean async)", "public void removePermission(@NonNull String permissionName)", "public PermissionGroupInfo getPermissionGroupInfo(@NonNull String groupName, @PackageManager.PermissionGroupInfoFlags int flags)", "public List<PermissionGroupInfo> getAllPermissionGroups(@PackageManager.PermissionGroupInfoFlags int flags)", "public boolean isPermissionRevokedByPolicy(@NonNull String packageName, @NonNull String permissionName)", "public static boolean shouldTraceGrant(@NonNull String packageName, @NonNull String permissionName, int userId)", "public void grantRuntimePermission(@NonNull String packageName, @NonNull String permissionName, @NonNull UserHandle user)", "public void grantRuntimePermission(@NonNull String packageName, @NonNull String permissionName, @NonNull String persistentDeviceId)", "private void grantRuntimePermissionInternal(@NonNull String packageName, @NonNull String permissionName, @NonNull String persistentDeviceId, @NonNull UserHandle user)", "public void revokeRuntimePermission(@NonNull String packageName, @NonNull String permissionName, @NonNull UserHandle user, @Nullable String reason)", "public void revokeRuntimePermission(@NonNull String packageName, @NonNull String permissionName, @NonNull String persistentDeviceId, @Nullable String reason)", "private void revokeRuntimePermissionInternal(@NonNull String packageName, @NonNull String permissionName, @NonNull String persistentDeviceId, @NonNull UserHandle user, @Nullable String reason)", "public int getPermissionFlags(@NonNull String packageName, @NonNull String permissionName, @NonNull UserHandle user)", "public int getPermissionFlags(@NonNull String packageName, @NonNull String permissionName, @NonNull String persistentDeviceId)", "private int getPermissionFlagsInternal(@NonNull String packageName, @NonNull String permissionName, @NonNull String persistentDeviceId, @NonNull UserHandle user)", "public void updatePermissionFlags(@NonNull String packageName, @NonNull String permissionName, @PackageManager.PermissionFlags int flagMask, @PackageManager.PermissionFlags int flagValues, @NonNull UserHandle user)", "public void updatePermissionFlags(@NonNull String packageName, @NonNull String permissionName, @NonNull String persistentDeviceId, @PackageManager.PermissionFlags int flagMask, @PackageManager.PermissionFlags int flagValues)", "private void updatePermissionFlagsInternal(@NonNull String packageName, @NonNull String permissionName, @PackageManager.PermissionFlags int flagMask, @PackageManager.PermissionFlags int flagValues, @NonNull String persistentDeviceId, @NonNull UserHandle user)", "public Set<String> getAllowlistedRestrictedPermissions(@NonNull String packageName, @PackageManager.PermissionWhitelistFlags int allowlistFlag)", "public boolean addAllowlistedRestrictedPermission(@NonNull String packageName, @NonNull String permissionName, @PackageManager.PermissionWhitelistFlags int allowlistFlags)", "public boolean removeAllowlistedRestrictedPermission(@NonNull String packageName, @NonNull String permissionName, @PackageManager.PermissionWhitelistFlags int allowlistFlags)", "public boolean isAutoRevokeExempted(@NonNull String packageName)", "public boolean setAutoRevokeExempted(@NonNull String packageName, boolean exempted)", "public boolean shouldShowRequestPermissionRationale(@NonNull String permissionName)", "public void addOnPermissionsChangeListener(@NonNull PackageManager.OnPermissionsChangedListener listener)", "public void removeOnPermissionsChangeListener(@NonNull PackageManager.OnPermissionsChangedListener listener)", "public int getRuntimePermissionsVersion()", "public void setRuntimePermissionsVersion(@IntRange(from = 0) int version)", "public List<SplitPermissionInfo> getSplitPermissions()", "public void initializeUsageHelper()", "public void tearDownUsageHelper()", "public List<PermissionGroupUsage> getIndicatorAppOpUsageData()", "public List<PermissionGroupUsage> getIndicatorAppOpUsageData(boolean micMuted)", "public static boolean shouldShowPackageForIndicatorCached(@NonNull Context context, @NonNull String packageName)", "public static Set<String> getIndicatorExemptedPackages(@NonNull Context context)", "public static void updateIndicatorExemptedPackages(@NonNull Context context)", "public Set<String> getAutoRevokeExemptionRequestedPackages()", "public Set<String> getAutoRevokeExemptionGrantedPackages()", "private List<SplitPermissionInfo> splitPermissionInfoListToNonParcelableList(List<SplitPermissionInfoParcelable> parcelableList)", "public static List<SplitPermissionInfoParcelable> splitPermissionInfoListToParcelableList(List<SplitPermissionInfo> splitPermissionsList)", "public void startOneTimePermissionSession(@NonNull String packageName, long timeoutMillis, @ActivityManager.RunningAppProcessInfo.Importance int importanceToResetTimer, @ActivityManager.RunningAppProcessInfo.Importance int importanceToKeepSessionAlive)", "public void startOneTimePermissionSession(@NonNull String packageName, @DurationMillisLong long timeoutMillis, @DurationMillisLong long revokeAfterKilledDelayMillis, @ActivityManager.RunningAppProcessInfo.Importance int importanceToResetTimer, @ActivityManager.RunningAppProcessInfo.Importance int importanceToKeepSessionAlive)", "public void stopOneTimePermissionSession(@NonNull String packageName)", "public int checkDeviceIdentifierAccess(@Nullable String packageName, @Nullable String message, @Nullable String callingFeatureId, int pid, int uid)", "public AttributionSource registerAttributionSource(@NonNull AttributionSource source)", "public boolean isRegisteredAttributionSource(@NonNull AttributionSource source)", "public int getRegisteredAttributionSourceCountForTest(int uid)", "public void revokePostNotificationPermissionWithoutKillForTest(@NonNull String packageName, int userId)", "private static int checkPermissionUncached(@Nullable String permission, int pid, int uid, int deviceId)", "public static int checkPermission(@Nullable String permission, int pid, int uid, int deviceId)", "public Map<String, PermissionState> getAllPermissionStates(@NonNull String packageName, @NonNull String persistentDeviceId)", "public static void disablePermissionCache()", "private static int checkPackageNamePermissionUncached(String permName, String pkgName, String persistentDeviceId, @UserIdInt int userId)", "public int checkPackageNamePermission(String permName, String pkgName, int deviceId, @UserIdInt int userId)", "private String getPersistentDeviceId(int deviceId)", "public int checkPermission(@NonNull String permissionName, @NonNull String packageName, @NonNull String persistentDeviceId)", "public static void disablePackageNamePermissionCache()" ],
  "variableNames" : [ "LOG_TAG", "PERMISSION_GRANTED", "PERMISSION_SOFT_DENIED", "PERMISSION_HARD_DENIED", "EXPLICIT_SET_FLAGS", "ACTION_REVIEW_PERMISSION_DECISIONS", "LOG_TAG_TRACE_GRANTS", "KILL_APP_REASON_PERMISSIONS_REVOKED", "KILL_APP_REASON_GIDS_CHANGED", "SYSTEM_PKG", "CANNOT_INSTALL_WITH_BAD_PERMISSION_GROUPS", "USE_ACCESS_CHECKING_SERVICE", "EXEMPTED_INDICATOR_ROLE_UPDATE_FREQUENCY_MS", "sLastIndicatorUpdateTime", "EXEMPTED_ROLES", "INDICATOR_EXEMPTED_PACKAGES", "DEBUG_TRACE_GRANTS", "DEBUG_TRACE_PERMISSION_UPDATES", "DEBUG_DEVICE_PERMISSIONS", "EXTRA_PERMISSION_USAGES", "DEVICE_AWARE_PERMISSIONS", "mContext", "mPackageManager", "mPermissionManager", "mLegacyPermissionManager", "mPermissionListeners", "mUsageHelper", "mSplitPermissionInfos", "sShouldWarnMissingActivityManager", "CACHE_KEY_PACKAGE_INFO", "sPermissionCache", "sPackageNamePermissionCache" ]
}