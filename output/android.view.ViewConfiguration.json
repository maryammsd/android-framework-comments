{
  "filePath" : "/home/maryam/clearblue/files/android-source-35/android/view/ViewConfiguration.java",
  "packageName" : "android.view",
  "className" : "ViewConfiguration",
  "comment" : "\n * Contains methods to standard constants used in the UI for timeouts, sizes, and distances.\n ",
  "links" : [ ],
  "variables" : [ {
    "name" : "TAG",
    "type" : "String",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "SCROLL_BAR_SIZE",
    "type" : "int",
    "comment" : "\n     * Defines the width of the horizontal scrollbar and the height of the vertical scrollbar in\n     * dips\n     ",
    "links" : [ ]
  }, {
    "name" : "SCROLL_BAR_FADE_DURATION",
    "type" : "int",
    "comment" : "\n     * Duration of the fade when scrollbars fade away in milliseconds\n     ",
    "links" : [ ]
  }, {
    "name" : "SCROLL_BAR_DEFAULT_DELAY",
    "type" : "int",
    "comment" : "\n     * Default delay before the scrollbars fade in milliseconds\n     ",
    "links" : [ ]
  }, {
    "name" : "FADING_EDGE_LENGTH",
    "type" : "int",
    "comment" : "\n     * Defines the length of the fading edges in dips\n     ",
    "links" : [ ]
  }, {
    "name" : "PRESSED_STATE_DURATION",
    "type" : "int",
    "comment" : "\n     * Defines the duration in milliseconds of the pressed state in child\n     * components.\n     ",
    "links" : [ ]
  }, {
    "name" : "DEFAULT_LONG_PRESS_TIMEOUT",
    "type" : "int",
    "comment" : "\n     * Defines the default duration in milliseconds before a press turns into\n     * a long press\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "DEFAULT_MULTI_PRESS_TIMEOUT",
    "type" : "int",
    "comment" : "\n     * Defines the default duration in milliseconds between the first tap's up event and the second\n     * tap's down event for an interaction to be considered part of the same multi-press.\n     ",
    "links" : [ ]
  }, {
    "name" : "DEFAULT_KEY_REPEAT_TIMEOUT_MS",
    "type" : "int",
    "comment" : "\n     * Defines the default duration in milliseconds between a key being pressed and its first key\n     * repeat event being generated. Historically, Android used the long press timeout as the\n     * key repeat timeout, so its default value is set to long press timeout's default.\n     ",
    "links" : [ ]
  }, {
    "name" : "DEFAULT_KEY_REPEAT_DELAY_MS",
    "type" : "int",
    "comment" : "\n     * Defines the default duration between successive key repeats in milliseconds.\n     ",
    "links" : [ ]
  }, {
    "name" : "GLOBAL_ACTIONS_KEY_TIMEOUT",
    "type" : "int",
    "comment" : "\n     * Defines the duration in milliseconds a user needs to hold down the\n     * appropriate button to bring up the global actions dialog (power off,\n     * lock screen, etc).\n     ",
    "links" : [ ]
  }, {
    "name" : "SCREENSHOT_CHORD_KEY_TIMEOUT",
    "type" : "int",
    "comment" : "\n     * Defines the duration in milliseconds a user needs to hold down the\n     * appropriate buttons (power + volume down) to trigger the screenshot chord.\n     ",
    "links" : [ ]
  }, {
    "name" : "A11Y_SHORTCUT_KEY_TIMEOUT",
    "type" : "int",
    "comment" : "\n     * Defines the duration in milliseconds a user needs to hold down the\n     * appropriate button to bring up the accessibility shortcut for the first time\n     ",
    "links" : [ ]
  }, {
    "name" : "A11Y_SHORTCUT_KEY_TIMEOUT_AFTER_CONFIRMATION",
    "type" : "int",
    "comment" : "\n     * Defines the duration in milliseconds a user needs to hold down the\n     * appropriate button to enable the accessibility shortcut once it's configured.\n     ",
    "links" : [ ]
  }, {
    "name" : "TAP_TIMEOUT",
    "type" : "int",
    "comment" : "\n     * Defines the duration in milliseconds we will wait to see if a touch event\n     * is a tap or a scroll. If the user does not move within this interval, it is\n     * considered to be a tap.\n     ",
    "links" : [ ]
  }, {
    "name" : "JUMP_TAP_TIMEOUT",
    "type" : "int",
    "comment" : "\n     * Defines the duration in milliseconds we will wait to see if a touch event\n     * is a jump tap. If the user does not complete the jump tap within this interval, it is\n     * considered to be a tap.\n     ",
    "links" : [ ]
  }, {
    "name" : "DOUBLE_TAP_TIMEOUT",
    "type" : "int",
    "comment" : "\n     * Defines the duration in milliseconds between the first tap's up event and\n     * the second tap's down event for an interaction to be considered a\n     * double-tap.\n     ",
    "links" : [ ]
  }, {
    "name" : "DOUBLE_TAP_MIN_TIME",
    "type" : "int",
    "comment" : "\n     * Defines the minimum duration in milliseconds between the first tap's up event and\n     * the second tap's down event for an interaction to be considered a\n     * double-tap.\n     ",
    "links" : [ ]
  }, {
    "name" : "HOVER_TAP_TIMEOUT",
    "type" : "int",
    "comment" : "\n     * Defines the maximum duration in milliseconds between a touch pad\n     * touch and release for a given touch to be considered a tap (click) as\n     * opposed to a hover movement gesture.\n     ",
    "links" : [ ]
  }, {
    "name" : "HOVER_TAP_SLOP",
    "type" : "int",
    "comment" : "\n     * Defines the maximum distance in pixels that a touch pad touch can move\n     * before being released for it to be considered a tap (click) as opposed\n     * to a hover movement gesture.\n     ",
    "links" : [ ]
  }, {
    "name" : "ZOOM_CONTROLS_TIMEOUT",
    "type" : "int",
    "comment" : "\n     * Defines the duration in milliseconds we want to display zoom controls in response\n     * to a user panning within an application.\n     ",
    "links" : [ ]
  }, {
    "name" : "EDGE_SLOP",
    "type" : "int",
    "comment" : "\n     * Inset in dips to look for touchable content when the user touches the edge of the screen\n     ",
    "links" : [ ]
  }, {
    "name" : "TOUCH_SLOP",
    "type" : "int",
    "comment" : "\n     * Distance a touch can wander before we think the user is scrolling in dips.\n     * Note that this value defined here is only used as a fallback by legacy/misbehaving\n     * applications that do not provide a Context for determining density/configuration-dependent\n     * values.\n     *\n     * To alter this value, see the configuration resource config_viewConfigurationTouchSlop\n     * in frameworks/base/core/res/res/values/config.xml or the appropriate device resource overlay.\n     * It may be appropriate to tweak this on a device-specific basis in an overlay based on\n     * the characteristics of the touch panel and firmware.\n     ",
    "links" : [ ]
  }, {
    "name" : "HANDWRITING_SLOP",
    "type" : "int",
    "comment" : " Distance a stylus touch can wander before we think the user is handwriting in dips. ",
    "links" : [ ]
  }, {
    "name" : "MIN_SCROLLBAR_TOUCH_TARGET",
    "type" : "int",
    "comment" : "\n     * Defines the minimum size of the touch target for a scrollbar in dips\n     ",
    "links" : [ ]
  }, {
    "name" : "DOUBLE_TAP_TOUCH_SLOP",
    "type" : "int",
    "comment" : "\n     * Distance the first touch can wander before we stop considering this event a double tap\n     * (in dips)\n     ",
    "links" : [ ]
  }, {
    "name" : "PAGING_TOUCH_SLOP",
    "type" : "int",
    "comment" : "\n     * Distance a touch can wander before we think the user is attempting a paged scroll\n     * (in dips)\n     *\n     * Note that this value defined here is only used as a fallback by legacy/misbehaving\n     * applications that do not provide a Context for determining density/configuration-dependent\n     * values.\n     *\n     * See the note above on {@link #TOUCH_SLOP} regarding the dimen resource\n     * config_viewConfigurationTouchSlop. ViewConfiguration will report a paging touch slop of\n     * config_viewConfigurationTouchSlop * 2 when provided with a Context.\n     ",
    "links" : [ "#TOUCH_SLOP" ]
  }, {
    "name" : "DOUBLE_TAP_SLOP",
    "type" : "int",
    "comment" : "\n     * Distance in dips between the first touch and second touch to still be considered a double tap\n     ",
    "links" : [ ]
  }, {
    "name" : "WINDOW_TOUCH_SLOP",
    "type" : "int",
    "comment" : "\n     * Distance in dips a touch needs to be outside of a window's bounds for it to\n     * count as outside for purposes of dismissing the window.\n     ",
    "links" : [ ]
  }, {
    "name" : "HANDWRITING_GESTURE_LINE_MARGIN",
    "type" : "int",
    "comment" : "\n     * Margin in dips around text line bounds where stylus handwriting gestures should be supported.\n     ",
    "links" : [ ]
  }, {
    "name" : "MINIMUM_FLING_VELOCITY",
    "type" : "int",
    "comment" : "\n     * Minimum velocity to initiate a fling, as measured in dips per second\n     ",
    "links" : [ ]
  }, {
    "name" : "MAXIMUM_FLING_VELOCITY",
    "type" : "int",
    "comment" : "\n     * Maximum velocity to initiate a fling, as measured in dips per second\n     ",
    "links" : [ ]
  }, {
    "name" : "NO_FLING_MIN_VELOCITY",
    "type" : "int",
    "comment" : " Value used as a minimum fling velocity, when fling is not supported. ",
    "links" : [ ]
  }, {
    "name" : "NO_FLING_MAX_VELOCITY",
    "type" : "int",
    "comment" : " Value used as a maximum fling velocity, when fling is not supported. ",
    "links" : [ ]
  }, {
    "name" : "NO_HAPTIC_SCROLL_TICK_INTERVAL",
    "type" : "int",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "SEND_RECURRING_ACCESSIBILITY_EVENTS_INTERVAL_MILLIS",
    "type" : "long",
    "comment" : "\n     * Delay before dispatching a recurring accessibility event in milliseconds.\n     * This delay guarantees that a recurring event will be send at most once\n     * during the {@link #SEND_RECURRING_ACCESSIBILITY_EVENTS_INTERVAL_MILLIS} time\n     * frame.\n     ",
    "links" : [ "#SEND_RECURRING_ACCESSIBILITY_EVENTS_INTERVAL_MILLIS" ]
  }, {
    "name" : "MAXIMUM_DRAWING_CACHE_SIZE",
    "type" : "int",
    "comment" : "\n     * The maximum size of View's drawing cache, expressed in bytes. This size\n     * should be at least equal to the size of the screen in ARGB888 format.\n     ",
    "links" : [ ]
  }, {
    "name" : "SCROLL_FRICTION",
    "type" : "float",
    "comment" : "\n     * The coefficient of friction applied to flings/scrolls.\n     ",
    "links" : [ ]
  }, {
    "name" : "OVERSCROLL_DISTANCE",
    "type" : "int",
    "comment" : "\n     * Max distance in dips to overscroll for edge effects\n     ",
    "links" : [ ]
  }, {
    "name" : "OVERFLING_DISTANCE",
    "type" : "int",
    "comment" : "\n     * Max distance in dips to overfling for edge effects\n     ",
    "links" : [ ]
  }, {
    "name" : "HORIZONTAL_SCROLL_FACTOR",
    "type" : "float",
    "comment" : "\n     * Amount to scroll in response to a horizontal {@link MotionEvent#ACTION_SCROLL} event,\n     * in dips per axis value.\n     ",
    "links" : [ "android.view.MotionEvent#ACTION_SCROLL" ]
  }, {
    "name" : "VERTICAL_SCROLL_FACTOR",
    "type" : "float",
    "comment" : "\n     * Amount to scroll in response to a vertical {@link MotionEvent#ACTION_SCROLL} event,\n     * in dips per axis value.\n     ",
    "links" : [ "android.view.MotionEvent#ACTION_SCROLL" ]
  }, {
    "name" : "ACTION_MODE_HIDE_DURATION_DEFAULT",
    "type" : "long",
    "comment" : "\n     * Default duration to hide an action mode for.\n     ",
    "links" : [ ]
  }, {
    "name" : "LONG_PRESS_TOOLTIP_HIDE_TIMEOUT",
    "type" : "int",
    "comment" : "\n     * Defines the duration in milliseconds before an end of a long press causes a tooltip to be\n     * hidden.\n     ",
    "links" : [ ]
  }, {
    "name" : "HOVER_TOOLTIP_SHOW_TIMEOUT",
    "type" : "int",
    "comment" : "\n     * Defines the duration in milliseconds before a hover event causes a tooltip to be shown.\n     ",
    "links" : [ ]
  }, {
    "name" : "HOVER_TOOLTIP_HIDE_TIMEOUT",
    "type" : "int",
    "comment" : "\n     * Defines the duration in milliseconds before mouse inactivity causes a tooltip to be hidden.\n     * (default variant to be used when {@link View#SYSTEM_UI_FLAG_LOW_PROFILE} is not set).\n     ",
    "links" : [ "android.view.View#SYSTEM_UI_FLAG_LOW_PROFILE" ]
  }, {
    "name" : "HOVER_TOOLTIP_HIDE_SHORT_TIMEOUT",
    "type" : "int",
    "comment" : "\n     * Defines the duration in milliseconds before mouse inactivity causes a tooltip to be hidden\n     * (short version to be used when {@link View#SYSTEM_UI_FLAG_LOW_PROFILE} is set).\n     ",
    "links" : [ "android.view.View#SYSTEM_UI_FLAG_LOW_PROFILE" ]
  }, {
    "name" : "HAS_PERMANENT_MENU_KEY_AUTODETECT",
    "type" : "int",
    "comment" : "\n     * Configuration values for overriding {@link #hasPermanentMenuKey()} behavior.\n     * These constants must match the definition in res/values/config.xml.\n     ",
    "links" : [ "#hasPermanentMenuKey()" ]
  }, {
    "name" : "HAS_PERMANENT_MENU_KEY_TRUE",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "HAS_PERMANENT_MENU_KEY_FALSE",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "AMBIGUOUS_GESTURE_MULTIPLIER",
    "type" : "float",
    "comment" : "\n     * The multiplication factor for inhibiting default gestures.\n     ",
    "links" : [ ]
  }, {
    "name" : "SMART_SELECTION_INITIALIZED_TIMEOUT_IN_MILLISECOND",
    "type" : "int",
    "comment" : "\n     * The timeout value in milliseconds to adjust the selection span and actions for the selected\n     * text when TextClassifier has been initialized.\n     ",
    "links" : [ ]
  }, {
    "name" : "SMART_SELECTION_INITIALIZING_TIMEOUT_IN_MILLISECOND",
    "type" : "int",
    "comment" : "\n     * The timeout value in milliseconds to adjust the selection span and actions for the selected\n     * text when TextClassifier has not been initialized.\n     ",
    "links" : [ ]
  }, {
    "name" : "mConstructedWithContext",
    "type" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mEdgeSlop",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mFadingEdgeLength",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mMinimumFlingVelocity",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mMaximumFlingVelocity",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mMinimumRotaryEncoderFlingVelocity",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mMaximumRotaryEncoderFlingVelocity",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mRotaryEncoderHapticScrollFeedbackTickIntervalPixels",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mRotaryEncoderHapticScrollFeedbackEnabled",
    "type" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mScrollbarSize",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mTouchSlop",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mHandwritingSlop",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mMinScalingSpan",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mHoverSlop",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mMinScrollbarTouchTarget",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mDoubleTapTouchSlop",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mPagingTouchSlop",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mDoubleTapSlop",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mWindowTouchSlop",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mHandwritingGestureLineMargin",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mAmbiguousGestureMultiplier",
    "type" : "float",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mMaximumDrawingCacheSize",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mOverscrollDistance",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mOverflingDistance",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mFadingMarqueeEnabled",
    "type" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mGlobalActionsKeyTimeout",
    "type" : "long",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mVerticalScrollFactor",
    "type" : "float",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mHorizontalScrollFactor",
    "type" : "float",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mShowMenuShortcutsWhenKeyboardPresent",
    "type" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mScreenshotChordKeyTimeout",
    "type" : "long",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mSmartSelectionInitializedTimeout",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mSmartSelectionInitializingTimeout",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mPreferKeepClearForFocusEnabled",
    "type" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mViewBasedRotaryEncoderScrollHapticsEnabledConfig",
    "type" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "sHasPermanentMenuKey",
    "type" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "sHasPermanentMenuKeySet",
    "type" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "sConfigurations",
    "type" : "SparseArray<ViewConfiguration>",
    "comment" : "",
    "links" : [ ]
  } ],
  "methods" : [ {
    "name" : "public static ViewConfiguration get(@NonNull @UiContext Context context)",
    "returnType" : "ViewConfiguration",
    "comment" : " TODO(b/182007470): Use @ConfigurationContext instead",
    "links" : [ ]
  }, {
    "name" : "public static void resetCacheForTesting()",
    "returnType" : "void",
    "comment" : "\n     * Removes cached ViewConfiguration instances, so that we can ensure `get` constructs a new\n     * ViewConfiguration instance. This is useful for testing the behavior and performance of\n     * creating ViewConfiguration the first time.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public static void setInstanceForTesting(Context context, ViewConfiguration instance)",
    "returnType" : "void",
    "comment" : "\n     * Sets the ViewConfiguration cached instanc for a given Context for testing.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public static int getScrollBarSize()",
    "returnType" : "int",
    "comment" : "\n     * @return The width of the horizontal scrollbar and the height of the vertical\n     *         scrollbar in dips\n     *\n     * @deprecated Use {@link #getScaledScrollBarSize()} instead.\n     ",
    "links" : [ "#getScaledScrollBarSize()" ]
  }, {
    "name" : "public int getScaledScrollBarSize()",
    "returnType" : "int",
    "comment" : "\n     * @return The width of the horizontal scrollbar and the height of the vertical\n     *         scrollbar in pixels\n     ",
    "links" : [ ]
  }, {
    "name" : "public int getScaledMinScrollbarTouchTarget()",
    "returnType" : "int",
    "comment" : "\n     * @return the minimum size of the scrollbar thumb's touch target in pixels\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public static int getScrollBarFadeDuration()",
    "returnType" : "int",
    "comment" : "\n     * @return Duration of the fade when scrollbars fade away in milliseconds\n     ",
    "links" : [ ]
  }, {
    "name" : "public static int getScrollDefaultDelay()",
    "returnType" : "int",
    "comment" : "\n     * @return Default delay before the scrollbars fade in milliseconds\n     ",
    "links" : [ ]
  }, {
    "name" : "public static int getFadingEdgeLength()",
    "returnType" : "int",
    "comment" : "\n     * @return the length of the fading edges in dips\n     *\n     * @deprecated Use {@link #getScaledFadingEdgeLength()} instead.\n     ",
    "links" : [ "#getScaledFadingEdgeLength()" ]
  }, {
    "name" : "public int getScaledFadingEdgeLength()",
    "returnType" : "int",
    "comment" : "\n     * @return the length of the fading edges in pixels\n     ",
    "links" : [ ]
  }, {
    "name" : "public static int getPressedStateDuration()",
    "returnType" : "int",
    "comment" : "\n     * @return the duration in milliseconds of the pressed state in child\n     * components.\n     ",
    "links" : [ ]
  }, {
    "name" : "public static int getLongPressTimeout()",
    "returnType" : "int",
    "comment" : "\n     * Used for both key and motion events.\n     *\n     * @return the duration in milliseconds before a press turns into\n     * a long press\n     ",
    "links" : [ ]
  }, {
    "name" : "public static int getMultiPressTimeout()",
    "returnType" : "int",
    "comment" : "\n     * @return the duration in milliseconds between the first tap's up event and the second tap's\n     * down event for an interaction to be considered part of the same multi-press.\n     ",
    "links" : [ ]
  }, {
    "name" : "public static int getKeyRepeatTimeout()",
    "returnType" : "int",
    "comment" : "\n     * @return the time before the first key repeat in milliseconds.\n     ",
    "links" : [ ]
  }, {
    "name" : "public static int getKeyRepeatDelay()",
    "returnType" : "int",
    "comment" : "\n     * @return the time between successive key repeats in milliseconds.\n     ",
    "links" : [ ]
  }, {
    "name" : "public static int getTapTimeout()",
    "returnType" : "int",
    "comment" : "\n     * @return the duration in milliseconds we will wait to see if a touch event\n     * is a tap or a scroll. If the user does not move within this interval, it is\n     * considered to be a tap.\n     ",
    "links" : [ ]
  }, {
    "name" : "public static int getJumpTapTimeout()",
    "returnType" : "int",
    "comment" : "\n     * @return the duration in milliseconds we will wait to see if a touch event\n     * is a jump tap. If the user does not move within this interval, it is\n     * considered to be a tap.\n     ",
    "links" : [ ]
  }, {
    "name" : "public static int getDoubleTapTimeout()",
    "returnType" : "int",
    "comment" : "\n     * @return the duration in milliseconds between the first tap's up event and\n     * the second tap's down event for an interaction to be considered a\n     * double-tap.\n     ",
    "links" : [ ]
  }, {
    "name" : "public static int getDoubleTapMinTime()",
    "returnType" : "int",
    "comment" : "\n     * @return the minimum duration in milliseconds between the first tap's\n     * up event and the second tap's down event for an interaction to be considered a\n     * double-tap.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public static int getHoverTapTimeout()",
    "returnType" : "int",
    "comment" : "\n     * @return the maximum duration in milliseconds between a touch pad\n     * touch and release for a given touch to be considered a tap (click) as\n     * opposed to a hover movement gesture.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public static int getHoverTapSlop()",
    "returnType" : "int",
    "comment" : "\n     * @return the maximum distance in pixels that a touch pad touch can move\n     * before being released for it to be considered a tap (click) as opposed\n     * to a hover movement gesture.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public static int getEdgeSlop()",
    "returnType" : "int",
    "comment" : "\n     * @return Inset in dips to look for touchable content when the user touches the edge of the\n     *         screen\n     *\n     * @deprecated Use {@link #getScaledEdgeSlop()} instead.\n     ",
    "links" : [ "#getScaledEdgeSlop()" ]
  }, {
    "name" : "public int getScaledEdgeSlop()",
    "returnType" : "int",
    "comment" : "\n     * @return Inset in pixels to look for touchable content when the user touches the edge of the\n     *         screen\n     ",
    "links" : [ ]
  }, {
    "name" : "public static int getTouchSlop()",
    "returnType" : "int",
    "comment" : "\n     * @return Distance in dips a touch can wander before we think the user is scrolling\n     *\n     * @deprecated Use {@link #getScaledTouchSlop()} instead.\n     ",
    "links" : [ "#getScaledTouchSlop()" ]
  }, {
    "name" : "public int getScaledTouchSlop()",
    "returnType" : "int",
    "comment" : "\n     * @return Distance in pixels a touch can wander before we think the user is scrolling\n     ",
    "links" : [ ]
  }, {
    "name" : "public int getScaledHandwritingSlop()",
    "returnType" : "int",
    "comment" : "\n     * @return Distance in pixels a stylus touch can wander before we think the user is\n     * handwriting.\n     ",
    "links" : [ ]
  }, {
    "name" : "public int getScaledHoverSlop()",
    "returnType" : "int",
    "comment" : "\n     * @return Distance in pixels a hover can wander while it is still considered \"stationary\".\n     *\n     ",
    "links" : [ ]
  }, {
    "name" : "public int getScaledDoubleTapTouchSlop()",
    "returnType" : "int",
    "comment" : "\n     * @return Distance in pixels the first touch can wander before we do not consider this a\n     * potential double tap event\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public int getScaledPagingTouchSlop()",
    "returnType" : "int",
    "comment" : "\n     * @return Distance in pixels a touch can wander before we think the user is scrolling a full\n     * page\n     ",
    "links" : [ ]
  }, {
    "name" : "public static int getDoubleTapSlop()",
    "returnType" : "int",
    "comment" : "\n     * @return Distance in dips between the first touch and second touch to still be\n     *         considered a double tap\n     * @deprecated Use {@link #getScaledDoubleTapSlop()} instead.\n     * @hide The only client of this should be GestureDetector, which needs this\n     *       for clients that still use its deprecated constructor.\n     ",
    "links" : [ "#getScaledDoubleTapSlop()" ]
  }, {
    "name" : "public int getScaledDoubleTapSlop()",
    "returnType" : "int",
    "comment" : "\n     * @return Distance in pixels between the first touch and second touch to still be\n     *         considered a double tap\n     ",
    "links" : [ ]
  }, {
    "name" : "public int getScaledHandwritingGestureLineMargin()",
    "returnType" : "int",
    "comment" : "\n     * @return margin in pixels around text line bounds where stylus handwriting gestures should be\n     *     supported.\n     ",
    "links" : [ ]
  }, {
    "name" : "public static long getSendRecurringAccessibilityEventsInterval()",
    "returnType" : "long",
    "comment" : "\n     * Interval for dispatching a recurring accessibility event in milliseconds.\n     * This interval guarantees that a recurring event will be send at most once\n     * during the {@link #getSendRecurringAccessibilityEventsInterval()} time frame.\n     *\n     * @return The delay in milliseconds.\n     *\n     * @hide\n     ",
    "links" : [ "#getSendRecurringAccessibilityEventsInterval()" ]
  }, {
    "name" : "public static int getWindowTouchSlop()",
    "returnType" : "int",
    "comment" : "\n     * @return Distance in dips a touch must be outside the bounds of a window for it\n     * to be counted as outside the window for purposes of dismissing that\n     * window.\n     *\n     * @deprecated Use {@link #getScaledWindowTouchSlop()} instead.\n     ",
    "links" : [ "#getScaledWindowTouchSlop()" ]
  }, {
    "name" : "public int getScaledWindowTouchSlop()",
    "returnType" : "int",
    "comment" : "\n     * @return Distance in pixels a touch must be outside the bounds of a window for it\n     * to be counted as outside the window for purposes of dismissing that window.\n     ",
    "links" : [ ]
  }, {
    "name" : "public static int getMinimumFlingVelocity()",
    "returnType" : "int",
    "comment" : "\n     * @return Minimum velocity to initiate a fling, as measured in dips per second.\n     *\n     * @deprecated Use {@link #getScaledMinimumFlingVelocity()} instead.\n     ",
    "links" : [ "#getScaledMinimumFlingVelocity()" ]
  }, {
    "name" : "public int getScaledMinimumFlingVelocity()",
    "returnType" : "int",
    "comment" : "\n     * @return Minimum velocity to initiate a fling, as measured in pixels per second.\n     ",
    "links" : [ ]
  }, {
    "name" : "public static int getMaximumFlingVelocity()",
    "returnType" : "int",
    "comment" : "\n     * @return Maximum velocity to initiate a fling, as measured in dips per second.\n     *\n     * @deprecated Use {@link #getScaledMaximumFlingVelocity()} instead.\n     ",
    "links" : [ "#getScaledMaximumFlingVelocity()" ]
  }, {
    "name" : "public int getScaledMaximumFlingVelocity()",
    "returnType" : "int",
    "comment" : "\n     * @return Maximum velocity to initiate a fling, as measured in pixels per second.\n     ",
    "links" : [ ]
  }, {
    "name" : "public int getScaledScrollFactor()",
    "returnType" : "int",
    "comment" : "\n     * @return Amount to scroll in response to a {@link MotionEvent#ACTION_SCROLL} event. Multiply\n     * this by the event's axis value to obtain the number of pixels to be scrolled.\n     *\n     * @removed\n     ",
    "links" : [ "android.view.MotionEvent#ACTION_SCROLL" ]
  }, {
    "name" : "public float getScaledHorizontalScrollFactor()",
    "returnType" : "float",
    "comment" : "\n     * @return Amount to scroll in response to a horizontal {@link MotionEvent#ACTION_SCROLL} event.\n     * Multiply this by the event's axis value to obtain the number of pixels to be scrolled.\n     ",
    "links" : [ "android.view.MotionEvent#ACTION_SCROLL" ]
  }, {
    "name" : "public float getScaledVerticalScrollFactor()",
    "returnType" : "float",
    "comment" : "\n     * @return Amount to scroll in response to a vertical {@link MotionEvent#ACTION_SCROLL} event.\n     * Multiply this by the event's axis value to obtain the number of pixels to be scrolled.\n     ",
    "links" : [ "android.view.MotionEvent#ACTION_SCROLL" ]
  }, {
    "name" : "public static int getMaximumDrawingCacheSize()",
    "returnType" : "int",
    "comment" : "\n     * The maximum drawing cache size expressed in bytes.\n     *\n     * @return the maximum size of View's drawing cache expressed in bytes\n     *\n     * @deprecated Use {@link #getScaledMaximumDrawingCacheSize()} instead.\n     ",
    "links" : [ "#getScaledMaximumDrawingCacheSize()" ]
  }, {
    "name" : "public int getScaledMaximumDrawingCacheSize()",
    "returnType" : "int",
    "comment" : "\n     * The maximum drawing cache size expressed in bytes.\n     *\n     * @return the maximum size of View's drawing cache expressed in bytes\n     ",
    "links" : [ ]
  }, {
    "name" : "public int getScaledOverscrollDistance()",
    "returnType" : "int",
    "comment" : "\n     * @return The maximum distance a View should overscroll by when showing edge effects (in\n     * pixels).\n     ",
    "links" : [ ]
  }, {
    "name" : "public int getScaledOverflingDistance()",
    "returnType" : "int",
    "comment" : "\n     * @return The maximum distance a View should overfling by when showing edge effects (in\n     * pixels).\n     ",
    "links" : [ ]
  }, {
    "name" : "public static long getZoomControlsTimeout()",
    "returnType" : "long",
    "comment" : "\n     * The amount of time that the zoom controls should be\n     * displayed on the screen expressed in milliseconds.\n     *\n     * @return the time the zoom controls should be visible expressed\n     * in milliseconds.\n     ",
    "links" : [ ]
  }, {
    "name" : "public static long getGlobalActionKeyTimeout()",
    "returnType" : "long",
    "comment" : "\n     * The amount of time a user needs to press the relevant key to bring up\n     * the global actions dialog.\n     *\n     * @return how long a user needs to press the relevant key to bring up\n     *   the global actions dialog.\n     * @deprecated This timeout should not be used by applications\n     ",
    "links" : [ ]
  }, {
    "name" : "public long getDeviceGlobalActionKeyTimeout()",
    "returnType" : "long",
    "comment" : "\n     * The amount of time a user needs to press the relevant key to bring up\n     * the global actions dialog.\n     *\n     * @return how long a user needs to press the relevant key to bring up\n     *   the global actions dialog.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public long getScreenshotChordKeyTimeout()",
    "returnType" : "long",
    "comment" : "\n     * The amount of time a user needs to press the relevant keys to trigger\n     * the screenshot chord.\n     *\n     * @return how long a user needs to press the relevant keys to trigger\n     *   the screenshot chord.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public long getAccessibilityShortcutKeyTimeout()",
    "returnType" : "long",
    "comment" : "\n     * The amount of time a user needs to press the relevant keys to activate the accessibility\n     * shortcut.\n     *\n     * @return how long a user needs to press the relevant keys to activate the accessibility\n     *   shortcut.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public long getAccessibilityShortcutKeyTimeoutAfterConfirmation()",
    "returnType" : "long",
    "comment" : "\n     * @return The amount of time a user needs to press the relevant keys to activate the\n     *   accessibility shortcut after it's confirmed that accessibility shortcut is used.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public static float getScrollFriction()",
    "returnType" : "float",
    "comment" : "\n     * The amount of friction applied to scrolls and flings.\n     *\n     * @return A scalar dimensionless value representing the coefficient of\n     *         friction.\n     ",
    "links" : [ ]
  }, {
    "name" : "public static long getDefaultActionModeHideDuration()",
    "returnType" : "long",
    "comment" : "\n     * @return the default duration in milliseconds for {@link ActionMode#hide(long)}.\n     ",
    "links" : [ "android.view.ActionMode#hide(long)" ]
  }, {
    "name" : "public static float getAmbiguousGestureMultiplier()",
    "returnType" : "float",
    "comment" : "\n     * The multiplication factor for inhibiting default gestures.\n     *\n     * If a MotionEvent has {@link android.view.MotionEvent#CLASSIFICATION_AMBIGUOUS_GESTURE} set,\n     * then certain actions, such as scrolling, will be inhibited. However, to account for the\n     * possibility of an incorrect classification, existing gesture thresholds (e.g. scrolling\n     * touch slop and the long-press timeout) should be scaled by this factor and remain in effect.\n     *\n     * @deprecated Use {@link #getScaledAmbiguousGestureMultiplier()}.\n     ",
    "links" : [ "#getScaledAmbiguousGestureMultiplier()", "android.view.MotionEvent#CLASSIFICATION_AMBIGUOUS_GESTURE" ]
  }, {
    "name" : "public float getScaledAmbiguousGestureMultiplier()",
    "returnType" : "float",
    "comment" : "\n     * The multiplication factor for inhibiting default gestures.\n     *\n     * If a MotionEvent has {@link android.view.MotionEvent#CLASSIFICATION_AMBIGUOUS_GESTURE} set,\n     * then certain actions, such as scrolling, will be inhibited. However, to account for the\n     * possibility of an incorrect classification, existing gesture thresholds (e.g. scrolling\n     * touch slop and the long-press timeout) should be scaled by this factor and remain in effect.\n     ",
    "links" : [ "android.view.MotionEvent#CLASSIFICATION_AMBIGUOUS_GESTURE" ]
  }, {
    "name" : "public boolean hasPermanentMenuKey()",
    "returnType" : "boolean",
    "comment" : "\n     * Report if the device has a permanent menu key available to the user.\n     *\n     * <p>As of Android 3.0, devices may not have a permanent menu key available.\n     * Apps should use the action bar to present menu options to users.\n     * However, there are some apps where the action bar is inappropriate\n     * or undesirable. This method may be used to detect if a menu key is present.\n     * If not, applications should provide another on-screen affordance to access\n     * functionality.\n     *\n     * @return true if a permanent menu key is present, false otherwise.\n     ",
    "links" : [ ]
  }, {
    "name" : "public int getScaledMinimumFlingVelocity(int inputDeviceId, int axis, int source)",
    "returnType" : "int",
    "comment" : "\n     * Minimum absolute value of velocity to initiate a fling for a motion generated by an\n     * {@link InputDevice} with an id of {@code inputDeviceId}, from an input {@code source} and on\n     * a given motion event {@code axis}.\n     *\n     * <p>Before utilizing this method to get a minimum fling velocity for a motion generated by the\n     * input device, scale the velocity of the motion events generated by the input device to pixels\n     * per second.\n     *\n     * <p>For instance, if you tracked {@link MotionEvent#AXIS_SCROLL} vertical velocities generated\n     * from a {@link InputDevice#SOURCE_ROTARY_ENCODER}, the velocity returned from\n     * {@link VelocityTracker} will be in the units with which the axis values were reported in the\n     * motion event. Before comparing that velocity against the minimum fling velocity specified\n     * here, make sure that the {@link MotionEvent#AXIS_SCROLL} velocity from the tracker is\n     * calculated in \"units per second\" (see {@link VelocityTracker#computeCurrentVelocity(int)},\n     * {@link VelocityTracker#computeCurrentVelocity(int, float)} to adjust your velocity\n     * computations to \"per second\"), and use {@link #getScaledVerticalScrollFactor} to change this\n     * velocity value to \"pixels/second\".\n     *\n     * <p>If the provided {@code inputDeviceId} is not valid, or if the input device whose ID is\n     * provided does not support the given motion event source and/or axis, this method will return\n     * {@code Integer.MAX_VALUE}.\n     *\n     * <h3>Obtaining the correct arguments for this method call</h3>\n     * <p><b>inputDeviceId</b>: if calling this method in response to a {@link MotionEvent}, use\n     * the device ID that is reported by the event, which can be obtained using\n     * {@link MotionEvent#getDeviceId()}. Otherwise, use a valid ID that is obtained from\n     * {@link InputDevice#getId()}, or from an {@link InputManager} instance\n     * ({@link InputManager#getInputDeviceIds()} gives all the valid input device IDs).\n     *\n     * <p><b>axis</b>: a {@link MotionEvent} may report data for multiple axes, and each axis may\n     * have multiple data points for different pointers. Use the axis for which you obtained the\n     * velocity for ({@link VelocityTracker} lets you calculate velocities for a specific axis. Use\n     * the axis for which you calculated velocity). You can use\n     * {@link InputDevice#getMotionRanges()} to get all the {@link InputDevice.MotionRange}s for the\n     * {@link InputDevice}, from which you can derive all the valid axes for the device.\n     *\n     * <p><b>source</b>: use {@link MotionEvent#getSource()} if calling this method in response to a\n     * {@link MotionEvent}. Otherwise, use a valid source for the {@link InputDevice}. You can use\n     * {@link InputDevice#getMotionRanges()} to get all the {@link InputDevice.MotionRange}s for the\n     * {@link InputDevice}, from which you can derive all the valid sources for the device.\n     *\n     *\n     * <p>This method optimizes calls over multiple input device IDs, so caching the return value of\n     * the method is not necessary if you are handling multiple input devices.\n     *\n     * @param inputDeviceId the ID of the {@link InputDevice} that generated the motion triggering\n     *          fling.\n     * @param axis the axis on which the motion triggering the fling happened. This axis should be\n     *          a valid axis that can be reported by the provided input device from the provided\n     *          input device source.\n     * @param source the input source of the motion causing fling. This source should be a valid\n     *          source for the {@link InputDevice} whose ID is {@code inputDeviceId}.\n     *\n     * @return the minimum velocity, in pixels/second, to trigger fling.\n     *\n     * @see InputDevice#getMotionRange(int, int)\n     * @see InputDevice#getMotionRanges()\n     * @see VelocityTracker#getAxisVelocity(int, int)\n     * @see VelocityTracker#getAxisVelocity(int)\n     ",
    "links" : [ "android.view.MotionEvent#AXIS_SCROLL", "android.view.InputDevice#getMotionRanges()", "android.view.InputDevice#SOURCE_ROTARY_ENCODER", "android.view.VelocityTracker#computeCurrentVelocity(int)", "android.view.VelocityTracker", "android.view.MotionEvent#getSource()", "android.view.InputDevice", "android.view.MotionEvent#getDeviceId()", "android.hardware.input.InputManager#getInputDeviceIds()", "InputDevice.MotionRange", "android.view.MotionEvent", "android.view.InputDevice#getId()", "android.hardware.input.InputManager", "android.view.VelocityTracker#computeCurrentVelocity(int", "#getScaledVerticalScrollFactor" ]
  }, {
    "name" : "public int getScaledMaximumFlingVelocity(int inputDeviceId, int axis, int source)",
    "returnType" : "int",
    "comment" : "\n     * Maximum absolute value of velocity to initiate a fling for a motion generated by an\n     * {@link InputDevice} with an id of {@code inputDeviceId}, from an input {@code source} and on\n     * a given motion event {@code axis}.\n     *\n     * <p>Similar to {@link #getScaledMinimumFlingVelocity(int, int, int)}, but for maximum fling\n     * velocity, instead of minimum. Also, unlike that method which returns\n     * {@code Integer.MAX_VALUE} for bad input device ID, source and/or motion event axis inputs,\n     * this method returns {@code Integer.MIN_VALUE} for such bad inputs.\n     ",
    "links" : [ "android.view.InputDevice", "#getScaledMinimumFlingVelocity(int" ]
  }, {
    "name" : "public boolean isHapticScrollFeedbackEnabled(int inputDeviceId, int axis, int source)",
    "returnType" : "boolean",
    "comment" : "\n     * Checks if any kind of scroll haptic feedback is enabled for a motion generated by a specific\n     * input device configuration and motion axis.\n     *\n     * <p>See {@link ScrollFeedbackProvider} for details on the arguments that should be passed to\n     * the methods in this class.\n     *\n     * <p>If the provided input device ID, source, and motion axis are not supported by this Android\n     * device, this method returns {@code false}. In other words, if the {@link InputDevice}\n     * represented by the provided {code inputDeviceId} does not have a\n     * {@link InputDevice.MotionRange} with the provided {@code axis} and {@code source}, the method\n     * returns {@code false}.\n     *\n     * <p>If the provided input device ID, source, and motion axis are supported by this Android\n     * device, this method returns {@code true} only if the provided arguments are supported for\n     * scroll haptics. Otherwise, this method returns {@code false}.\n     *\n     * @param inputDeviceId the ID of the {@link InputDevice} that generated the motion that may\n     *      produce scroll haptics.\n     * @param source the input source of the motion that may produce scroll haptics.\n     * @param axis the axis of the motion that may produce scroll haptics.\n     * @return {@code true} if motions generated by the provided input and motion configuration\n     *      can produce scroll haptics. {@code false} otherwise.\n     *\n     * @see #getHapticScrollFeedbackTickInterval(int, int, int)\n     * @see InputDevice#getMotionRanges()\n     * @see InputDevice#getMotionRange(int)\n     * @see InputDevice#getMotionRange(int, int)\n     *\n     * @hide\n     ",
    "links" : [ "android.view.InputDevice", "InputDevice.MotionRange", "android.view.ScrollFeedbackProvider" ]
  }, {
    "name" : "public int getHapticScrollFeedbackTickInterval(int inputDeviceId, int axis, int source)",
    "returnType" : "int",
    "comment" : "\n     * Provides the minimum scroll interval (in pixels) between consecutive scroll tick haptics for\n     * motions generated by a specific input device configuration and motion axis.\n     *\n     * <p><b>Scroll tick</b> here refers to an interval-based, consistent scroll feedback provided\n     * to the user as the user scrolls through a scrollable view.\n     *\n     * <p>If you are supporting scroll tick haptics, use this interval as the minimum pixel scroll\n     * distance between consecutive scroll ticks. That is, once your view has scrolled for at least\n     * this interval, play a haptic, and wait again until the view has further scrolled with this\n     * interval in the same direction before playing the next scroll haptic.\n     *\n     * <p>Some devices may support other types of scroll haptics but not interval based tick\n     * haptics. In those cases, this method will return {@code Integer.MAX_VALUE}. The same value\n     * will be returned if the device does not support scroll haptics at all (which can be checked\n     * via {@link #isHapticScrollFeedbackEnabled(int, int, int)}).\n     *\n     * <p>See {@link #isHapticScrollFeedbackEnabled(int, int, int)} for more details about obtaining\n     * the correct arguments for this method.\n     *\n     * @param inputDeviceId the ID of the {@link InputDevice} that generated the motion that may\n     *      produce scroll haptics.\n     * @param source the input source of the motion that may produce scroll haptics.\n     * @param axis the axis of the motion that may produce scroll haptics.\n     * @return the absolute value of the minimum scroll interval, in pixels, between consecutive\n     *      scroll feedback haptics for motions generated by the provided input and motion\n     *      configuration. If scroll haptics is disabled for the given configuration, or if the\n     *      device does not support scroll tick haptics for the given configuration, this method\n     *      returns {@code Integer.MAX_VALUE}.\n     *\n     * @see #isHapticScrollFeedbackEnabled(int, int, int)\n     *\n     * @hide\n     ",
    "links" : [ "android.view.InputDevice", "#isHapticScrollFeedbackEnabled(int" ]
  }, {
    "name" : "public boolean isViewBasedRotaryEncoderHapticScrollFeedbackEnabled()",
    "returnType" : "boolean",
    "comment" : "\n     * Checks if the View-based haptic scroll feedback implementation is enabled for\n     * {@link InputDevice#SOURCE_ROTARY_ENCODER}s.\n     *\n     * @hide\n     ",
    "links" : [ "android.view.InputDevice#SOURCE_ROTARY_ENCODER" ]
  }, {
    "name" : "private static boolean isInputDeviceInfoValid(int id, int axis, int source)",
    "returnType" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public boolean shouldShowMenuShortcutsWhenKeyboardPresent()",
    "returnType" : "boolean",
    "comment" : "\n     * Check if shortcuts should be displayed in menus.\n     *\n     * @return {@code True} if shortcuts should be displayed in menus.\n     ",
    "links" : [ ]
  }, {
    "name" : "public int getScaledMinimumScalingSpan()",
    "returnType" : "int",
    "comment" : "\n     * Retrieves the distance in pixels between touches that must be reached for a gesture to be\n     * interpreted as scaling.\n     *\n     * In general, scaling shouldn't start until this distance has been met or surpassed, and\n     * scaling should end when the distance in pixels between touches drops below this distance.\n     *\n     * @return The distance in pixels\n     * @throws IllegalStateException if this method is called on a ViewConfiguration that was\n     *         instantiated using a constructor with no Context parameter.\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean isFadingMarqueeEnabled()",
    "returnType" : "boolean",
    "comment" : "\n     * @hide\n     * @return Whether or not marquee should use fading edges.\n     ",
    "links" : [ ]
  }, {
    "name" : "public int getSmartSelectionInitializedTimeout()",
    "returnType" : "int",
    "comment" : "\n     * @return the timeout value in milliseconds to adjust the selection span and actions for the\n     *         selected text when TextClassifier has been initialized.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public int getSmartSelectionInitializingTimeout()",
    "returnType" : "int",
    "comment" : "\n     * @return the timeout value in milliseconds to adjust the selection span and actions for the\n     *         selected text when TextClassifier has not been initialized.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean isPreferKeepClearForFocusEnabled()",
    "returnType" : "boolean",
    "comment" : "\n     * @return {@code true} if Views should set themselves as preferred to keep clear when focused,\n     * {@code false} otherwise.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public static int getLongPressTooltipHideTimeout()",
    "returnType" : "int",
    "comment" : "\n     * @return the duration in milliseconds before an end of a long press causes a tooltip to be\n     * hidden\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public static int getHoverTooltipShowTimeout()",
    "returnType" : "int",
    "comment" : "\n     * @return the duration in milliseconds before a hover event causes a tooltip to be shown\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public static int getHoverTooltipHideTimeout()",
    "returnType" : "int",
    "comment" : "\n     * @return the duration in milliseconds before mouse inactivity causes a tooltip to be hidden\n     * (default variant to be used when {@link View#SYSTEM_UI_FLAG_LOW_PROFILE} is not set).\n     * @hide\n     ",
    "links" : [ "android.view.View#SYSTEM_UI_FLAG_LOW_PROFILE" ]
  }, {
    "name" : "public static int getHoverTooltipHideShortTimeout()",
    "returnType" : "int",
    "comment" : "\n     * @return the duration in milliseconds before mouse inactivity causes a tooltip to be hidden\n     * (shorter variant to be used when {@link View#SYSTEM_UI_FLAG_LOW_PROFILE} is set).\n     * @hide\n     ",
    "links" : [ "android.view.View#SYSTEM_UI_FLAG_LOW_PROFILE" ]
  }, {
    "name" : "private static final int getDisplayDensity(Context context)",
    "returnType" : "int",
    "comment" : "",
    "links" : [ ]
  } ],
  "methodNames" : [ "public static ViewConfiguration get(@NonNull @UiContext Context context)", "public static void resetCacheForTesting()", "public static void setInstanceForTesting(Context context, ViewConfiguration instance)", "public static int getScrollBarSize()", "public int getScaledScrollBarSize()", "public int getScaledMinScrollbarTouchTarget()", "public static int getScrollBarFadeDuration()", "public static int getScrollDefaultDelay()", "public static int getFadingEdgeLength()", "public int getScaledFadingEdgeLength()", "public static int getPressedStateDuration()", "public static int getLongPressTimeout()", "public static int getMultiPressTimeout()", "public static int getKeyRepeatTimeout()", "public static int getKeyRepeatDelay()", "public static int getTapTimeout()", "public static int getJumpTapTimeout()", "public static int getDoubleTapTimeout()", "public static int getDoubleTapMinTime()", "public static int getHoverTapTimeout()", "public static int getHoverTapSlop()", "public static int getEdgeSlop()", "public int getScaledEdgeSlop()", "public static int getTouchSlop()", "public int getScaledTouchSlop()", "public int getScaledHandwritingSlop()", "public int getScaledHoverSlop()", "public int getScaledDoubleTapTouchSlop()", "public int getScaledPagingTouchSlop()", "public static int getDoubleTapSlop()", "public int getScaledDoubleTapSlop()", "public int getScaledHandwritingGestureLineMargin()", "public static long getSendRecurringAccessibilityEventsInterval()", "public static int getWindowTouchSlop()", "public int getScaledWindowTouchSlop()", "public static int getMinimumFlingVelocity()", "public int getScaledMinimumFlingVelocity()", "public static int getMaximumFlingVelocity()", "public int getScaledMaximumFlingVelocity()", "public int getScaledScrollFactor()", "public float getScaledHorizontalScrollFactor()", "public float getScaledVerticalScrollFactor()", "public static int getMaximumDrawingCacheSize()", "public int getScaledMaximumDrawingCacheSize()", "public int getScaledOverscrollDistance()", "public int getScaledOverflingDistance()", "public static long getZoomControlsTimeout()", "public static long getGlobalActionKeyTimeout()", "public long getDeviceGlobalActionKeyTimeout()", "public long getScreenshotChordKeyTimeout()", "public long getAccessibilityShortcutKeyTimeout()", "public long getAccessibilityShortcutKeyTimeoutAfterConfirmation()", "public static float getScrollFriction()", "public static long getDefaultActionModeHideDuration()", "public static float getAmbiguousGestureMultiplier()", "public float getScaledAmbiguousGestureMultiplier()", "public boolean hasPermanentMenuKey()", "public int getScaledMinimumFlingVelocity(int inputDeviceId, int axis, int source)", "public int getScaledMaximumFlingVelocity(int inputDeviceId, int axis, int source)", "public boolean isHapticScrollFeedbackEnabled(int inputDeviceId, int axis, int source)", "public int getHapticScrollFeedbackTickInterval(int inputDeviceId, int axis, int source)", "public boolean isViewBasedRotaryEncoderHapticScrollFeedbackEnabled()", "private static boolean isInputDeviceInfoValid(int id, int axis, int source)", "public boolean shouldShowMenuShortcutsWhenKeyboardPresent()", "public int getScaledMinimumScalingSpan()", "public boolean isFadingMarqueeEnabled()", "public int getSmartSelectionInitializedTimeout()", "public int getSmartSelectionInitializingTimeout()", "public boolean isPreferKeepClearForFocusEnabled()", "public static int getLongPressTooltipHideTimeout()", "public static int getHoverTooltipShowTimeout()", "public static int getHoverTooltipHideTimeout()", "public static int getHoverTooltipHideShortTimeout()", "private static final int getDisplayDensity(Context context)" ],
  "variableNames" : [ "TAG", "SCROLL_BAR_SIZE", "SCROLL_BAR_FADE_DURATION", "SCROLL_BAR_DEFAULT_DELAY", "FADING_EDGE_LENGTH", "PRESSED_STATE_DURATION", "DEFAULT_LONG_PRESS_TIMEOUT", "DEFAULT_MULTI_PRESS_TIMEOUT", "DEFAULT_KEY_REPEAT_TIMEOUT_MS", "DEFAULT_KEY_REPEAT_DELAY_MS", "GLOBAL_ACTIONS_KEY_TIMEOUT", "SCREENSHOT_CHORD_KEY_TIMEOUT", "A11Y_SHORTCUT_KEY_TIMEOUT", "A11Y_SHORTCUT_KEY_TIMEOUT_AFTER_CONFIRMATION", "TAP_TIMEOUT", "JUMP_TAP_TIMEOUT", "DOUBLE_TAP_TIMEOUT", "DOUBLE_TAP_MIN_TIME", "HOVER_TAP_TIMEOUT", "HOVER_TAP_SLOP", "ZOOM_CONTROLS_TIMEOUT", "EDGE_SLOP", "TOUCH_SLOP", "HANDWRITING_SLOP", "MIN_SCROLLBAR_TOUCH_TARGET", "DOUBLE_TAP_TOUCH_SLOP", "PAGING_TOUCH_SLOP", "DOUBLE_TAP_SLOP", "WINDOW_TOUCH_SLOP", "HANDWRITING_GESTURE_LINE_MARGIN", "MINIMUM_FLING_VELOCITY", "MAXIMUM_FLING_VELOCITY", "NO_FLING_MIN_VELOCITY", "NO_FLING_MAX_VELOCITY", "NO_HAPTIC_SCROLL_TICK_INTERVAL", "SEND_RECURRING_ACCESSIBILITY_EVENTS_INTERVAL_MILLIS", "MAXIMUM_DRAWING_CACHE_SIZE", "SCROLL_FRICTION", "OVERSCROLL_DISTANCE", "OVERFLING_DISTANCE", "HORIZONTAL_SCROLL_FACTOR", "VERTICAL_SCROLL_FACTOR", "ACTION_MODE_HIDE_DURATION_DEFAULT", "LONG_PRESS_TOOLTIP_HIDE_TIMEOUT", "HOVER_TOOLTIP_SHOW_TIMEOUT", "HOVER_TOOLTIP_HIDE_TIMEOUT", "HOVER_TOOLTIP_HIDE_SHORT_TIMEOUT", "HAS_PERMANENT_MENU_KEY_AUTODETECT", "HAS_PERMANENT_MENU_KEY_TRUE", "HAS_PERMANENT_MENU_KEY_FALSE", "AMBIGUOUS_GESTURE_MULTIPLIER", "SMART_SELECTION_INITIALIZED_TIMEOUT_IN_MILLISECOND", "SMART_SELECTION_INITIALIZING_TIMEOUT_IN_MILLISECOND", "mConstructedWithContext", "mEdgeSlop", "mFadingEdgeLength", "mMinimumFlingVelocity", "mMaximumFlingVelocity", "mMinimumRotaryEncoderFlingVelocity", "mMaximumRotaryEncoderFlingVelocity", "mRotaryEncoderHapticScrollFeedbackTickIntervalPixels", "mRotaryEncoderHapticScrollFeedbackEnabled", "mScrollbarSize", "mTouchSlop", "mHandwritingSlop", "mMinScalingSpan", "mHoverSlop", "mMinScrollbarTouchTarget", "mDoubleTapTouchSlop", "mPagingTouchSlop", "mDoubleTapSlop", "mWindowTouchSlop", "mHandwritingGestureLineMargin", "mAmbiguousGestureMultiplier", "mMaximumDrawingCacheSize", "mOverscrollDistance", "mOverflingDistance", "mFadingMarqueeEnabled", "mGlobalActionsKeyTimeout", "mVerticalScrollFactor", "mHorizontalScrollFactor", "mShowMenuShortcutsWhenKeyboardPresent", "mScreenshotChordKeyTimeout", "mSmartSelectionInitializedTimeout", "mSmartSelectionInitializingTimeout", "mPreferKeepClearForFocusEnabled", "mViewBasedRotaryEncoderScrollHapticsEnabledConfig", "sHasPermanentMenuKey", "sHasPermanentMenuKeySet", "sConfigurations" ]
}