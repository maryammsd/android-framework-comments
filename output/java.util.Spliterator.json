{
  "filePath" : "/home/maryam/clearblue/files/android-source-35/java/util/Spliterator.java",
  "packageName" : "java.util",
  "className" : "Spliterator",
  "comment" : "\n * An object for traversing and partitioning elements of a source.  The source\n * of elements covered by a Spliterator could be, for example, an array, a\n * {@link Collection}, an IO channel, or a generator function.\n *\n * <p>A Spliterator may traverse elements individually ({@link\n * #tryAdvance tryAdvance()}) or sequentially in bulk\n * ({@link #forEachRemaining forEachRemaining()}).\n *\n * <p>A Spliterator may also partition off some of its elements (using\n * {@link #trySplit}) as another Spliterator, to be used in\n * possibly-parallel operations.  Operations using a Spliterator that\n * cannot split, or does so in a highly imbalanced or inefficient\n * manner, are unlikely to benefit from parallelism.  Traversal\n * and splitting exhaust elements; each Spliterator is useful for only a single\n * bulk computation.\n *\n * <p>A Spliterator also reports a set of {@link #characteristics()} of its\n * structure, source, and elements from among {@link #ORDERED},\n * {@link #DISTINCT}, {@link #SORTED}, {@link #SIZED}, {@link #NONNULL},\n * {@link #IMMUTABLE}, {@link #CONCURRENT}, and {@link #SUBSIZED}. These may\n * be employed by Spliterator clients to control, specialize or simplify\n * computation.  For example, a Spliterator for a {@link Collection} would\n * report {@code SIZED}, a Spliterator for a {@link Set} would report\n * {@code DISTINCT}, and a Spliterator for a {@link SortedSet} would also\n * report {@code SORTED}.  Characteristics are reported as a simple unioned bit\n * set.\n *\n * Some characteristics additionally constrain method behavior; for example if\n * {@code ORDERED}, traversal methods must conform to their documented ordering.\n * New characteristics may be defined in the future, so implementors should not\n * assign meanings to unlisted values.\n *\n * <p><a id=\"binding\">A Spliterator that does not report {@code IMMUTABLE} or\n * {@code CONCURRENT} is expected to have a documented policy concerning:\n * when the spliterator <em>binds</em> to the element source; and detection of\n * structural interference of the element source detected after binding.</a>  A\n * <em>late-binding</em> Spliterator binds to the source of elements at the\n * point of first traversal, first split, or first query for estimated size,\n * rather than at the time the Spliterator is created.  A Spliterator that is\n * not <em>late-binding</em> binds to the source of elements at the point of\n * construction or first invocation of any method.  Modifications made to the\n * source prior to binding are reflected when the Spliterator is traversed.\n * After binding a Spliterator should, on a best-effort basis, throw\n * {@link ConcurrentModificationException} if structural interference is\n * detected.  Spliterators that do this are called <em>fail-fast</em>.  The\n * bulk traversal method ({@link #forEachRemaining forEachRemaining()}) of a\n * Spliterator may optimize traversal and check for structural interference\n * after all elements have been traversed, rather than checking per-element and\n * failing immediately.\n *\n * <p>Spliterators can provide an estimate of the number of remaining elements\n * via the {@link #estimateSize} method.  Ideally, as reflected in characteristic\n * {@link #SIZED}, this value corresponds exactly to the number of elements\n * that would be encountered in a successful traversal.  However, even when not\n * exactly known, an estimated value may still be useful to operations\n * being performed on the source, such as helping to determine whether it is\n * preferable to split further or traverse the remaining elements sequentially.\n *\n * <p>Despite their obvious utility in parallel algorithms, spliterators are not\n * expected to be thread-safe; instead, implementations of parallel algorithms\n * using spliterators should ensure that the spliterator is only used by one\n * thread at a time.  This is generally easy to attain via <em>serial\n * thread-confinement</em>, which often is a natural consequence of typical\n * parallel algorithms that work by recursive decomposition.  A thread calling\n * {@link #trySplit()} may hand over the returned Spliterator to another thread,\n * which in turn may traverse or further split that Spliterator.  The behaviour\n * of splitting and traversal is undefined if two or more threads operate\n * concurrently on the same spliterator.  If the original thread hands a\n * spliterator off to another thread for processing, it is best if that handoff\n * occurs before any elements are consumed with {@link #tryAdvance(Consumer)\n * tryAdvance()}, as certain guarantees (such as the accuracy of\n * {@link #estimateSize()} for {@code SIZED} spliterators) are only valid before\n * traversal has begun.\n *\n * <p>Primitive subtype specializations of {@code Spliterator} are provided for\n * {@link OfInt int}, {@link OfLong long}, and {@link OfDouble double} values.\n * The subtype default implementations of\n * {@link Spliterator#tryAdvance(java.util.function.Consumer)}\n * and {@link Spliterator#forEachRemaining(java.util.function.Consumer)} box\n * primitive values to instances of their corresponding wrapper class.  Such\n * boxing may undermine any performance advantages gained by using the primitive\n * specializations.  To avoid boxing, the corresponding primitive-based methods\n * should be used.  For example,\n * {@link Spliterator.OfInt#tryAdvance(java.util.function.IntConsumer)}\n * and {@link Spliterator.OfInt#forEachRemaining(java.util.function.IntConsumer)}\n * should be used in preference to\n * {@link Spliterator.OfInt#tryAdvance(java.util.function.Consumer)} and\n * {@link Spliterator.OfInt#forEachRemaining(java.util.function.Consumer)}.\n * Traversal of primitive values using boxing-based methods\n * {@link #tryAdvance tryAdvance()} and\n * {@link #forEachRemaining(java.util.function.Consumer) forEachRemaining()}\n * does not affect the order in which the values, transformed to boxed values,\n * are encountered.\n *\n * @apiNote\n * <p>Spliterators, like {@code Iterator}s, are for traversing the elements of\n * a source.  The {@code Spliterator} API was designed to support efficient\n * parallel traversal in addition to sequential traversal, by supporting\n * decomposition as well as single-element iteration.  In addition, the\n * protocol for accessing elements via a Spliterator is designed to impose\n * smaller per-element overhead than {@code Iterator}, and to avoid the inherent\n * race involved in having separate methods for {@code hasNext()} and\n * {@code next()}.\n *\n * <p>For mutable sources, arbitrary and non-deterministic behavior may occur if\n * the source is structurally interfered with (elements added, replaced, or\n * removed) between the time that the Spliterator binds to its data source and\n * the end of traversal.  For example, such interference will produce arbitrary,\n * non-deterministic results when using the {@code java.util.stream} framework.\n *\n * <p>Structural interference of a source can be managed in the following ways\n * (in approximate order of decreasing desirability):\n * <ul>\n * <li>The source cannot be structurally interfered with.\n * <br>For example, an instance of\n * {@link java.util.concurrent.CopyOnWriteArrayList} is an immutable source.\n * A Spliterator created from the source reports a characteristic of\n * {@code IMMUTABLE}.</li>\n * <li>The source manages concurrent modifications.\n * <br>For example, a key set of a {@link java.util.concurrent.ConcurrentHashMap}\n * is a concurrent source.  A Spliterator created from the source reports a\n * characteristic of {@code CONCURRENT}.</li>\n * <li>The mutable source provides a late-binding and fail-fast Spliterator.\n * <br>Late binding narrows the window during which interference can affect\n * the calculation; fail-fast detects, on a best-effort basis, that structural\n * interference has occurred after traversal has commenced and throws\n * {@link ConcurrentModificationException}.  For example, {@link ArrayList},\n * and many other non-concurrent {@code Collection} classes in the JDK, provide\n * a late-binding, fail-fast spliterator.</li>\n * <li>The mutable source provides a non-late-binding but fail-fast Spliterator.\n * <br>The source increases the likelihood of throwing\n * {@code ConcurrentModificationException} since the window of potential\n * interference is larger.</li>\n * <li>The mutable source provides a late-binding and non-fail-fast Spliterator.\n * <br>The source risks arbitrary, non-deterministic behavior after traversal\n * has commenced since interference is not detected.\n * </li>\n * <li>The mutable source provides a non-late-binding and non-fail-fast\n * Spliterator.\n * <br>The source increases the risk of arbitrary, non-deterministic behavior\n * since non-detected interference may occur after construction.\n * </li>\n * </ul>\n *\n * <p><b>Example.</b> Here is a class (not a very useful one, except\n * for illustration) that maintains an array in which the actual data\n * are held in even locations, and unrelated tag data are held in odd\n * locations. Its Spliterator ignores the tags.\n *\n * <pre> {@code\n * class TaggedArray<T> {\n *   private final Object[] elements; // immutable after construction\n *   TaggedArray(T[] data, Object[] tags) {\n *     int size = data.length;\n *     if (tags.length != size) throw new IllegalArgumentException();\n *     this.elements = new Object[2 * size];\n *     for (int i = 0, j = 0; i < size; ++i) {\n *       elements[j++] = data[i];\n *       elements[j++] = tags[i];\n *     }\n *   }\n *\n *   public Spliterator<T> spliterator() {\n *     return new TaggedArraySpliterator<>(elements, 0, elements.length);\n *   }\n *\n *   static class TaggedArraySpliterator<T> implements Spliterator<T> {\n *     private final Object[] array;\n *     private int origin; // current index, advanced on split or traversal\n *     private final int fence; // one past the greatest index\n *\n *     TaggedArraySpliterator(Object[] array, int origin, int fence) {\n *       this.array = array; this.origin = origin; this.fence = fence;\n *     }\n *\n *     public void forEachRemaining(Consumer<? super T> action) {\n *       for (; origin < fence; origin += 2)\n *         action.accept((T) array[origin]);\n *     }\n *\n *     public boolean tryAdvance(Consumer<? super T> action) {\n *       if (origin < fence) {\n *         action.accept((T) array[origin]);\n *         origin += 2;\n *         return true;\n *       }\n *       else // cannot advance\n *         return false;\n *     }\n *\n *     public Spliterator<T> trySplit() {\n *       int lo = origin; // divide range in half\n *       int mid = ((lo + fence) >>> 1) & ~1; // force midpoint to be even\n *       if (lo < mid) { // split out left half\n *         origin = mid; // reset this Spliterator's origin\n *         return new TaggedArraySpliterator<>(array, lo, mid);\n *       }\n *       else       // too small to split\n *         return null;\n *     }\n *\n *     public long estimateSize() {\n *       return (long)((fence - origin) / 2);\n *     }\n *\n *     public int characteristics() {\n *       return ORDERED | SIZED | IMMUTABLE | SUBSIZED;\n *     }\n *   }\n * }}</pre>\n *\n * <p>As an example how a parallel computation framework, such as the\n * {@code java.util.stream} package, would use Spliterator in a parallel\n * computation, here is one way to implement an associated parallel forEach,\n * that illustrates the primary usage idiom of splitting off subtasks until\n * the estimated amount of work is small enough to perform\n * sequentially. Here we assume that the order of processing across\n * subtasks doesn't matter; different (forked) tasks may further split\n * and process elements concurrently in undetermined order.  This\n * example uses a {@link java.util.concurrent.CountedCompleter};\n * similar usages apply to other parallel task constructions.\n *\n * <pre>{@code\n * static <T> void parEach(TaggedArray<T> a, Consumer<T> action) {\n *   Spliterator<T> s = a.spliterator();\n *   long targetBatchSize = s.estimateSize() / (ForkJoinPool.getCommonPoolParallelism() * 8);\n *   new ParEach(null, s, action, targetBatchSize).invoke();\n * }\n *\n * static class ParEach<T> extends CountedCompleter<Void> {\n *   final Spliterator<T> spliterator;\n *   final Consumer<T> action;\n *   final long targetBatchSize;\n *\n *   ParEach(ParEach<T> parent, Spliterator<T> spliterator,\n *           Consumer<T> action, long targetBatchSize) {\n *     super(parent);\n *     this.spliterator = spliterator; this.action = action;\n *     this.targetBatchSize = targetBatchSize;\n *   }\n *\n *   public void compute() {\n *     Spliterator<T> sub;\n *     while (spliterator.estimateSize() > targetBatchSize &&\n *            (sub = spliterator.trySplit()) != null) {\n *       addToPendingCount(1);\n *       new ParEach<>(this, sub, action, targetBatchSize).fork();\n *     }\n *     spliterator.forEachRemaining(action);\n *     propagateCompletion();\n *   }\n * }}</pre>\n *\n * @implNote\n * If the boolean system property {@systemProperty org.openjdk.java.util.stream.tripwire}\n * is set to {@code true} then diagnostic warnings are reported if boxing of\n * primitive values occur when operating on primitive subtype specializations.\n *\n * @param <T> the type of elements returned by this Spliterator\n *\n * @see Collection\n * @since 1.8\n ",
  "links" : [ "OfLong", "#SUBSIZED", "java.util.SortedSet", "Spliterator.OfInt#forEachRemaining(java.util.function.IntConsumer)", "Spliterator.OfInt#tryAdvance(java.util.function.Consumer)", "#SIZED", "#IMMUTABLE", "java.util.ArrayList", "#tryAdvance", "Spliterator.OfInt#forEachRemaining(java.util.function.Consumer)", "java.util.concurrent.CountedCompleter", "#trySplit()", "#NONNULL", "#characteristics()", "java.util.Collection", "#trySplit", "java.util.Spliterator#forEachRemaining(java.util.function.Consumer)", "java.util.concurrent.ConcurrentHashMap", "#DISTINCT", "java.util.Set", "Spliterator.OfInt#tryAdvance(java.util.function.IntConsumer)", "#ORDERED", "#forEachRemaining(java.util.function.Consumer)", "OfInt", "#estimateSize()", "java.util.Spliterator#tryAdvance(java.util.function.Consumer)", "#CONCURRENT", "#estimateSize", "#SORTED", "OfDouble", "java.util.ConcurrentModificationException", "#tryAdvance(Consumer)", "#forEachRemaining", "java.util.concurrent.CopyOnWriteArrayList" ],
  "variables" : [ {
    "name" : "ORDERED",
    "type" : "int",
    "comment" : "\n     * Characteristic value signifying that an encounter order is defined for\n     * elements. If so, this Spliterator guarantees that method\n     * {@link #trySplit} splits a strict prefix of elements, that method\n     * {@link #tryAdvance} steps by one element in prefix order, and that\n     * {@link #forEachRemaining} performs actions in encounter order.\n     *\n     * <p>A {@link Collection} has an encounter order if the corresponding\n     * {@link Collection#iterator} documents an order. If so, the encounter\n     * order is the same as the documented order. Otherwise, a collection does\n     * not have an encounter order.\n     *\n     * @apiNote Encounter order is guaranteed to be ascending index order for\n     * any {@link List}. But no order is guaranteed for hash-based collections\n     * such as {@link HashSet}. Clients of a Spliterator that reports\n     * {@code ORDERED} are expected to preserve ordering constraints in\n     * non-commutative parallel computations.\n     ",
    "links" : [ "java.util.HashSet", "java.util.List", "#tryAdvance", "java.util.Collection", "#trySplit", "java.util.Collection#iterator", "#forEachRemaining" ]
  }, {
    "name" : "DISTINCT",
    "type" : "int",
    "comment" : "\n     * Characteristic value signifying that, for each pair of\n     * encountered elements {@code x, y}, {@code !x.equals(y)}. This\n     * applies for example, to a Spliterator based on a {@link Set}.\n     ",
    "links" : [ "java.util.Set" ]
  }, {
    "name" : "SORTED",
    "type" : "int",
    "comment" : "\n     * Characteristic value signifying that encounter order follows a defined\n     * sort order. If so, method {@link #getComparator()} returns the associated\n     * Comparator, or {@code null} if all elements are {@link Comparable} and\n     * are sorted by their natural ordering.\n     *\n     * <p>A Spliterator that reports {@code SORTED} must also report\n     * {@code ORDERED}.\n     *\n     * @apiNote The spliterators for {@code Collection} classes in the JDK that\n     * implement {@link NavigableSet} or {@link SortedSet} report {@code SORTED}.\n     ",
    "links" : [ "#getComparator()", "Comparable", "java.util.SortedSet", "java.util.NavigableSet" ]
  }, {
    "name" : "SIZED",
    "type" : "int",
    "comment" : "\n     * Characteristic value signifying that the value returned from\n     * {@code estimateSize()} prior to traversal or splitting represents a\n     * finite size that, in the absence of structural source modification,\n     * represents an exact count of the number of elements that would be\n     * encountered by a complete traversal.\n     *\n     * @apiNote Most Spliterators for Collections, that cover all elements of a\n     * {@code Collection} report this characteristic. Sub-spliterators, such as\n     * those for {@link HashSet}, that cover a sub-set of elements and\n     * approximate their reported size do not.\n     ",
    "links" : [ "java.util.HashSet" ]
  }, {
    "name" : "NONNULL",
    "type" : "int",
    "comment" : "\n     * Characteristic value signifying that the source guarantees that\n     * encountered elements will not be {@code null}. (This applies,\n     * for example, to most concurrent collections, queues, and maps.)\n     ",
    "links" : [ ]
  }, {
    "name" : "IMMUTABLE",
    "type" : "int",
    "comment" : "\n     * Characteristic value signifying that the element source cannot be\n     * structurally modified; that is, elements cannot be added, replaced, or\n     * removed, so such changes cannot occur during traversal. A Spliterator\n     * that does not report {@code IMMUTABLE} or {@code CONCURRENT} is expected\n     * to have a documented policy (for example throwing\n     * {@link ConcurrentModificationException}) concerning structural\n     * interference detected during traversal.\n     ",
    "links" : [ "java.util.ConcurrentModificationException" ]
  }, {
    "name" : "CONCURRENT",
    "type" : "int",
    "comment" : "\n     * Characteristic value signifying that the element source may be safely\n     * concurrently modified (allowing additions, replacements, and/or removals)\n     * by multiple threads without external synchronization. If so, the\n     * Spliterator is expected to have a documented policy concerning the impact\n     * of modifications during traversal.\n     *\n     * <p>A top-level Spliterator should not report both {@code CONCURRENT} and\n     * {@code SIZED}, since the finite size, if known, may change if the source\n     * is concurrently modified during traversal. Such a Spliterator is\n     * inconsistent and no guarantees can be made about any computation using\n     * that Spliterator. Sub-spliterators may report {@code SIZED} if the\n     * sub-split size is known and additions or removals to the source are not\n     * reflected when traversing.\n     *\n     * <p>A top-level Spliterator should not report both {@code CONCURRENT} and\n     * {@code IMMUTABLE}, since they are mutually exclusive. Such a Spliterator\n     * is inconsistent and no guarantees can be made about any computation using\n     * that Spliterator. Sub-spliterators may report {@code IMMUTABLE} if\n     * additions or removals to the source are not reflected when traversing.\n     *\n     * @apiNote Most concurrent collections maintain a consistency policy\n     * guaranteeing accuracy with respect to elements present at the point of\n     * Spliterator construction, but possibly not reflecting subsequent\n     * additions or removals.\n     ",
    "links" : [ ]
  }, {
    "name" : "SUBSIZED",
    "type" : "int",
    "comment" : "\n     * Characteristic value signifying that all Spliterators resulting from\n     * {@code trySplit()} will be both {@link #SIZED} and {@link #SUBSIZED}.\n     * (This means that all child Spliterators, whether direct or indirect, will\n     * be {@code SIZED}.)\n     *\n     * <p>A Spliterator that does not report {@code SIZED} as required by\n     * {@code SUBSIZED} is inconsistent and no guarantees can be made about any\n     * computation using that Spliterator.\n     *\n     * @apiNote Some spliterators, such as the top-level spliterator for an\n     * approximately balanced binary tree, will report {@code SIZED} but not\n     * {@code SUBSIZED}, since it is common to know the size of the entire tree\n     * but not the exact sizes of subtrees.\n     ",
    "links" : [ "#SUBSIZED", "#SIZED" ]
  } ],
  "methods" : [ {
    "name" : " boolean tryAdvance(Consumer<? super T> action)",
    "returnType" : "boolean",
    "comment" : "\n     * If a remaining element exists, performs the given action on it,\n     * returning {@code true}; else returns {@code false}.  If this\n     * Spliterator is {@link #ORDERED} the action is performed on the\n     * next element in encounter order.  Exceptions thrown by the\n     * action are relayed to the caller.\n     * <p>\n     * Subsequent behavior of a spliterator is unspecified if the action throws\n     * an exception.\n     *\n     * @param action The action\n     * @return {@code false} if no remaining elements existed\n     * upon entry to this method, else {@code true}.\n     * @throws NullPointerException if the specified action is null\n     ",
    "links" : [ "#ORDERED" ]
  }, {
    "name" : " void forEachRemaining(Consumer<? super T> action)",
    "returnType" : "void",
    "comment" : "\n     * Performs the given action for each remaining element, sequentially in\n     * the current thread, until all elements have been processed or the action\n     * throws an exception.  If this Spliterator is {@link #ORDERED}, actions\n     * are performed in encounter order.  Exceptions thrown by the action\n     * are relayed to the caller.\n     * <p>\n     * Subsequent behavior of a spliterator is unspecified if the action throws\n     * an exception.\n     *\n     * @implSpec\n     * The default implementation repeatedly invokes {@link #tryAdvance} until\n     * it returns {@code false}.  It should be overridden whenever possible.\n     *\n     * @param action The action\n     * @throws NullPointerException if the specified action is null\n     ",
    "links" : [ "#tryAdvance", "#ORDERED" ]
  }, {
    "name" : " Spliterator<T> trySplit()",
    "returnType" : "Spliterator<T>",
    "comment" : "\n     * If this spliterator can be partitioned, returns a Spliterator\n     * covering elements, that will, upon return from this method, not\n     * be covered by this Spliterator.\n     *\n     * <p>If this Spliterator is {@link #ORDERED}, the returned Spliterator\n     * must cover a strict prefix of the elements.\n     *\n     * <p>Unless this Spliterator covers an infinite number of elements,\n     * repeated calls to {@code trySplit()} must eventually return {@code null}.\n     * Upon non-null return:\n     * <ul>\n     * <li>the value reported for {@code estimateSize()} before splitting,\n     * must, after splitting, be greater than or equal to {@code estimateSize()}\n     * for this and the returned Spliterator; and</li>\n     * <li>if this Spliterator is {@code SUBSIZED}, then {@code estimateSize()}\n     * for this spliterator before splitting must be equal to the sum of\n     * {@code estimateSize()} for this and the returned Spliterator after\n     * splitting.</li>\n     * </ul>\n     *\n     * <p>This method may return {@code null} for any reason,\n     * including emptiness, inability to split after traversal has\n     * commenced, data structure constraints, and efficiency\n     * considerations.\n     *\n     * @apiNote\n     * An ideal {@code trySplit} method efficiently (without\n     * traversal) divides its elements exactly in half, allowing\n     * balanced parallel computation.  Many departures from this ideal\n     * remain highly effective; for example, only approximately\n     * splitting an approximately balanced tree, or for a tree in\n     * which leaf nodes may contain either one or two elements,\n     * failing to further split these nodes.  However, large\n     * deviations in balance and/or overly inefficient {@code\n     * trySplit} mechanics typically result in poor parallel\n     * performance.\n     *\n     * @return a {@code Spliterator} covering some portion of the\n     * elements, or {@code null} if this spliterator cannot be split\n     ",
    "links" : [ "#ORDERED" ]
  }, {
    "name" : " long estimateSize()",
    "returnType" : "long",
    "comment" : "\n     * Returns an estimate of the number of elements that would be\n     * encountered by a {@link #forEachRemaining} traversal, or returns {@link\n     * Long#MAX_VALUE} if infinite, unknown, or too expensive to compute.\n     *\n     * <p>If this Spliterator is {@link #SIZED} and has not yet been partially\n     * traversed or split, or this Spliterator is {@link #SUBSIZED} and has\n     * not yet been partially traversed, this estimate must be an accurate\n     * count of elements that would be encountered by a complete traversal.\n     * Otherwise, this estimate may be arbitrarily inaccurate, but must decrease\n     * as specified across invocations of {@link #trySplit}.\n     *\n     * @apiNote\n     * Even an inexact estimate is often useful and inexpensive to compute.\n     * For example, a sub-spliterator of an approximately balanced binary tree\n     * may return a value that estimates the number of elements to be half of\n     * that of its parent; if the root Spliterator does not maintain an\n     * accurate count, it could estimate size to be the power of two\n     * corresponding to its maximum depth.\n     *\n     * @return the estimated size, or {@code Long.MAX_VALUE} if infinite,\n     *         unknown, or too expensive to compute.\n     ",
    "links" : [ "#MAX_VALUE", "#SUBSIZED", "#trySplit", "#SIZED", "#forEachRemaining" ]
  }, {
    "name" : " long getExactSizeIfKnown()",
    "returnType" : "long",
    "comment" : "\n     * Convenience method that returns {@link #estimateSize()} if this\n     * Spliterator is {@link #SIZED}, else {@code -1}.\n     * @implSpec\n     * The default implementation returns the result of {@code estimateSize()}\n     * if the Spliterator reports a characteristic of {@code SIZED}, and\n     * {@code -1} otherwise.\n     *\n     * @return the exact size, if known, else {@code -1}.\n     ",
    "links" : [ "#estimateSize()", "#SIZED" ]
  }, {
    "name" : " int characteristics()",
    "returnType" : "int",
    "comment" : "\n     * Returns a set of characteristics of this Spliterator and its\n     * elements. The result is represented as ORed values from {@link\n     * #ORDERED}, {@link #DISTINCT}, {@link #SORTED}, {@link #SIZED},\n     * {@link #NONNULL}, {@link #IMMUTABLE}, {@link #CONCURRENT},\n     * {@link #SUBSIZED}.  Repeated calls to {@code characteristics()} on\n     * a given spliterator, prior to or in-between calls to {@code trySplit},\n     * should always return the same result.\n     *\n     * <p>If a Spliterator reports an inconsistent set of\n     * characteristics (either those returned from a single invocation\n     * or across multiple invocations), no guarantees can be made\n     * about any computation using this Spliterator.\n     *\n     * @apiNote The characteristics of a given spliterator before splitting\n     * may differ from the characteristics after splitting.  For specific\n     * examples see the characteristic values {@link #SIZED}, {@link #SUBSIZED}\n     * and {@link #CONCURRENT}.\n     *\n     * @return a representation of characteristics\n     ",
    "links" : [ "#CONCURRENT", "#SUBSIZED", "#DISTINCT", "#ORDERED", "#SORTED", "#NONNULL", "#SIZED", "#IMMUTABLE" ]
  }, {
    "name" : " boolean hasCharacteristics(int characteristics)",
    "returnType" : "boolean",
    "comment" : "\n     * Returns {@code true} if this Spliterator's {@link\n     * #characteristics} contain all of the given characteristics.\n     *\n     * @implSpec\n     * The default implementation returns true if the corresponding bits\n     * of the given characteristics are set.\n     *\n     * @param characteristics the characteristics to check for\n     * @return {@code true} if all the specified characteristics are present,\n     * else {@code false}\n     ",
    "links" : [ "#characteristics" ]
  }, {
    "name" : " Comparator<? super T> getComparator()",
    "returnType" : "Comparator<? super T>",
    "comment" : "\n     * If this Spliterator's source is {@link #SORTED} by a {@link Comparator},\n     * returns that {@code Comparator}. If the source is {@code SORTED} in\n     * {@linkplain Comparable natural order}, returns {@code null}.  Otherwise,\n     * if the source is not {@code SORTED}, throws {@link IllegalStateException}.\n     *\n     * @implSpec\n     * The default implementation always throws {@link IllegalStateException}.\n     *\n     * @return a Comparator, or {@code null} if the elements are sorted in the\n     * natural order.\n     * @throws IllegalStateException if the spliterator does not report\n     *         a characteristic of {@code SORTED}.\n     ",
    "links" : [ "IllegalStateException", "#SORTED", "java.util.Comparator" ]
  } ],
  "methodNames" : [ " boolean tryAdvance(Consumer<? super T> action)", " void forEachRemaining(Consumer<? super T> action)", " Spliterator<T> trySplit()", " long estimateSize()", " long getExactSizeIfKnown()", " int characteristics()", " boolean hasCharacteristics(int characteristics)", " Comparator<? super T> getComparator()" ],
  "variableNames" : [ "ORDERED", "DISTINCT", "SORTED", "SIZED", "NONNULL", "IMMUTABLE", "CONCURRENT", "SUBSIZED" ]
}