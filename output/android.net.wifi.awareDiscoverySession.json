{
  "filePath" : "/home/maryam/clearblue/files/android-source-30/android/net/wifi/aware/DiscoverySession.java",
  "packageName" : "android.net.wifi.aware",
  "className" : "DiscoverySession",
  "comment" : "\n * A class representing a single publish or subscribe Aware session. This object\n * will not be created directly - only its child classes are available:\n * {@link PublishDiscoverySession} and {@link SubscribeDiscoverySession}. This\n * class provides functionality common to both publish and subscribe discovery sessions:\n * <ul>\n *      <li>Sending messages: {@link #sendMessage(PeerHandle, int, byte[])} method.\n *      <li>Creating a network-specifier when requesting a Aware connection using\n *      {@link WifiAwareNetworkSpecifier.Builder}.\n * </ul>\n * <p>\n * The {@link #close()} method must be called to destroy discovery sessions once they are\n * no longer needed.\n ",
  "variables" : [ {
    "name" : "TAG",
    "type" : "String",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "DBG",
    "type" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "VDBG",
    "type" : "boolean",
    "comment" : " STOPSHIP if true",
    "links" : [ ]
  }, {
    "name" : "MAX_SEND_RETRY_COUNT",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mMgr",
    "type" : "WeakReference<WifiAwareManager>",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "mClientId",
    "type" : "int",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "mSessionId",
    "type" : "int",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "mTerminated",
    "type" : "boolean",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "mCloseGuard",
    "type" : "CloseGuard",
    "comment" : "",
    "links" : [ ]
  } ],
  "methods" : [ {
    "name" : "public static int getMaxSendRetryCount()",
    "returnType" : "int",
    "comment" : "\n     * Return the maximum permitted retry count when sending messages using\n     * {@link #sendMessage(PeerHandle, int, byte[], int)}.\n     *\n     * @return Maximum retry count when sending messages.\n     *\n     * @hide\n     ",
    "links" : [ "#sendMessage" ]
  }, {
    "name" : "public void close()",
    "returnType" : "void",
    "comment" : "\n     * Destroy the publish or subscribe session - free any resources, and stop\n     * transmitting packets on-air (for an active session) or listening for\n     * matches (for a passive session). The session may not be used for any\n     * additional operations after its destruction.\n     * <p>\n     *     This operation must be done on a session which is no longer needed. Otherwise system\n     *     resources will continue to be utilized until the application exits. The only\n     *     exception is a session for which we received a termination callback,\n     *     {@link DiscoverySessionCallback#onSessionTerminated()}.\n     ",
    "links" : [ "DiscoverySessionCallback#onSessionTerminated" ]
  }, {
    "name" : "public void setTerminated()",
    "returnType" : "void",
    "comment" : "\n     * Sets the status of the session to terminated - i.e. an indication that\n     * already terminated rather than executing a termination.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "protected void finalize() throws Throwable",
    "returnType" : "void",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "public int getClientId()",
    "returnType" : "int",
    "comment" : "\n     * Access the client ID of the Aware session.\n     *\n     * Note: internal visibility for testing.\n     *\n     * @return The internal client ID.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public int getSessionId()",
    "returnType" : "int",
    "comment" : "\n     * Access the discovery session ID of the Aware session.\n     *\n     * Note: internal visibility for testing.\n     *\n     * @return The internal discovery session ID.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public void sendMessage(@NonNull PeerHandle peerHandle, int messageId, @Nullable byte[] message, int retryCount)",
    "returnType" : "void",
    "comment" : "\n     * Sends a message to the specified destination. Aware messages are transmitted in the context\n     * of a discovery session - executed subsequent to a publish/subscribe\n     * {@link DiscoverySessionCallback#onServiceDiscovered(PeerHandle,\n     * byte[], java.util.List)} event.\n     * <p>\n     *     Aware messages are not guaranteed delivery. Callbacks on\n     *     {@link DiscoverySessionCallback} indicate message was transmitted successfully,\n     *     {@link DiscoverySessionCallback#onMessageSendSucceeded(int)}, or transmission\n     *     failed (possibly after several retries) -\n     *     {@link DiscoverySessionCallback#onMessageSendFailed(int)}.\n     * <p>\n     *     The peer will get a callback indicating a message was received using\n     *     {@link DiscoverySessionCallback#onMessageReceived(PeerHandle,\n     *     byte[])}.\n     *\n     * @param peerHandle The peer's handle for the message. Must be a result of an\n     * {@link DiscoverySessionCallback#onServiceDiscovered(PeerHandle,\n     * byte[], java.util.List)} or\n     * {@link DiscoverySessionCallback#onMessageReceived(PeerHandle,\n     * byte[])} events.\n     * @param messageId An arbitrary integer used by the caller to identify the message. The same\n     *            integer ID will be returned in the callbacks indicating message send success or\n     *            failure. The {@code messageId} is not used internally by the Aware service - it\n     *                  can be arbitrary and non-unique.\n     * @param message The message to be transmitted.\n     * @param retryCount An integer specifying how many additional service-level (as opposed to PHY\n     *            or MAC level) retries should be attempted if there is no ACK from the receiver\n     *            (note: no retransmissions are attempted in other failure cases). A value of 0\n     *            indicates no retries. Max permitted value is {@link #getMaxSendRetryCount()}.\n     *\n     * @hide\n     ",
    "links" : [ "DiscoverySessionCallback#onServiceDiscovered", "DiscoverySessionCallback", "DiscoverySessionCallback#onMessageSendSucceeded", "DiscoverySessionCallback#onMessageSendFailed", "DiscoverySessionCallback#onMessageReceived", "DiscoverySessionCallback#onServiceDiscovered", "DiscoverySessionCallback#onMessageReceived", "#getMaxSendRetryCount" ]
  }, {
    "name" : "public void sendMessage(@NonNull PeerHandle peerHandle, int messageId, @Nullable byte[] message)",
    "returnType" : "void",
    "comment" : "\n     * Sends a message to the specified destination. Aware messages are transmitted in the context\n     * of a discovery session - executed subsequent to a publish/subscribe\n     * {@link DiscoverySessionCallback#onServiceDiscovered(PeerHandle,\n     * byte[], java.util.List)} event.\n     * <p>\n     *     Aware messages are not guaranteed delivery. Callbacks on\n     *     {@link DiscoverySessionCallback} indicate message was transmitted successfully,\n     *     {@link DiscoverySessionCallback#onMessageSendSucceeded(int)}, or transmission\n     *     failed (possibly after several retries) -\n     *     {@link DiscoverySessionCallback#onMessageSendFailed(int)}.\n     * <p>\n     * The peer will get a callback indicating a message was received using\n     * {@link DiscoverySessionCallback#onMessageReceived(PeerHandle,\n     * byte[])}.\n     *\n     * @param peerHandle The peer's handle for the message. Must be a result of an\n     * {@link DiscoverySessionCallback#onServiceDiscovered(PeerHandle,\n     * byte[], java.util.List)} or\n     * {@link DiscoverySessionCallback#onMessageReceived(PeerHandle,\n     * byte[])} events.\n     * @param messageId An arbitrary integer used by the caller to identify the message. The same\n     *            integer ID will be returned in the callbacks indicating message send success or\n     *            failure. The {@code messageId} is not used internally by the Aware service - it\n     *                  can be arbitrary and non-unique.\n     * @param message The message to be transmitted.\n     ",
    "links" : [ "DiscoverySessionCallback#onServiceDiscovered", "DiscoverySessionCallback", "DiscoverySessionCallback#onMessageSendSucceeded", "DiscoverySessionCallback#onMessageSendFailed", "DiscoverySessionCallback#onMessageReceived", "DiscoverySessionCallback#onServiceDiscovered", "DiscoverySessionCallback#onMessageReceived" ]
  }, {
    "name" : "public NetworkSpecifier createNetworkSpecifierOpen(@NonNull PeerHandle peerHandle)",
    "returnType" : "NetworkSpecifier",
    "comment" : "\n     * Create a {@link android.net.NetworkRequest.Builder#setNetworkSpecifier(NetworkSpecifier)} for\n     * an unencrypted WiFi Aware connection (link) to the specified peer. The\n     * {@link android.net.NetworkRequest.Builder#addTransportType(int)} should be set to\n     * {@link android.net.NetworkCapabilities#TRANSPORT_WIFI_AWARE}.\n     * <p>\n     * This method should be used when setting up a connection with a peer discovered through Aware\n     * discovery or communication (in such scenarios the MAC address of the peer is shielded by\n     * an opaque peer ID handle). If an Aware connection is needed to a peer discovered using other\n     * OOB (out-of-band) mechanism then use the alternative\n     * {@link WifiAwareSession#createNetworkSpecifierOpen(int, byte[])} method - which uses the\n     * peer's MAC address.\n     * <p>\n     * Note: per the Wi-Fi Aware specification the roles are fixed - a Subscriber is an INITIATOR\n     * and a Publisher is a RESPONDER.\n     * <p>\n     * To set up an encrypted link use the\n     * {@link #createNetworkSpecifierPassphrase(PeerHandle, String)} API.\n     * @deprecated Use the replacement {@link WifiAwareNetworkSpecifier.Builder}.\n     *\n     * @param peerHandle The peer's handle obtained through\n     * {@link DiscoverySessionCallback#onServiceDiscovered(PeerHandle, byte[], java.util.List)}\n     *                   or\n     *                   {@link DiscoverySessionCallback#onMessageReceived(PeerHandle, byte[])}.\n     *                   On a RESPONDER this value is used to gate the acceptance of a connection\n     *                   request from only that peer.\n     *\n     * @return A {@link NetworkSpecifier} to be used to construct\n     * {@link android.net.NetworkRequest.Builder#setNetworkSpecifier(NetworkSpecifier)} to pass to\n     * {@link android.net.ConnectivityManager#requestNetwork(android.net.NetworkRequest,\n     * android.net.ConnectivityManager.NetworkCallback)}\n     * [or other varieties of that API].\n     ",
    "links" : [ "android.net.NetworkRequest.Builder#setNetworkSpecifier", "android.net.NetworkRequest.Builder#addTransportType", "android.net.NetworkCapabilities#TRANSPORT_WIFI_AWARE", "WifiAwareSession#createNetworkSpecifierOpen", "#createNetworkSpecifierPassphrase", "WifiAwareNetworkSpecifier.Builder", "DiscoverySessionCallback#onServiceDiscovered", "DiscoverySessionCallback#onMessageReceived", "NetworkSpecifier", "android.net.NetworkRequest.Builder#setNetworkSpecifier", "android.net.ConnectivityManager#requestNetwork" ]
  }, {
    "name" : "public NetworkSpecifier createNetworkSpecifierPassphrase(@NonNull PeerHandle peerHandle, @NonNull String passphrase)",
    "returnType" : "NetworkSpecifier",
    "comment" : "\n     * Create a {@link android.net.NetworkRequest.Builder#setNetworkSpecifier(NetworkSpecifier)} for\n     * an encrypted WiFi Aware connection (link) to the specified peer. The\n     * {@link android.net.NetworkRequest.Builder#addTransportType(int)} should be set to\n     * {@link android.net.NetworkCapabilities#TRANSPORT_WIFI_AWARE}.\n     * <p>\n     * This method should be used when setting up a connection with a peer discovered through Aware\n     * discovery or communication (in such scenarios the MAC address of the peer is shielded by\n     * an opaque peer ID handle). If an Aware connection is needed to a peer discovered using other\n     * OOB (out-of-band) mechanism then use the alternative\n     * {@link WifiAwareSession#createNetworkSpecifierPassphrase(int, byte[], String)} method -\n     * which uses the peer's MAC address.\n     * <p>\n     * Note: per the Wi-Fi Aware specification the roles are fixed - a Subscriber is an INITIATOR\n     * and a Publisher is a RESPONDER.\n     * @deprecated Use the replacement {@link WifiAwareNetworkSpecifier.Builder}.\n     *\n     * @param peerHandle The peer's handle obtained through\n     * {@link DiscoverySessionCallback#onServiceDiscovered(PeerHandle,\n     * byte[], java.util.List)} or\n     * {@link DiscoverySessionCallback#onMessageReceived(PeerHandle,\n     * byte[])}. On a RESPONDER this value is used to gate the acceptance of a connection request\n     *                   from only that peer.\n     * @param passphrase The passphrase to be used to encrypt the link. The PMK is generated from\n     *                   the passphrase. Use the\n     *                   {@link #createNetworkSpecifierOpen(PeerHandle)} API to\n     *                   specify an open (unencrypted) link.\n     *\n     * @return A {@link NetworkSpecifier} to be used to construct\n     * {@link android.net.NetworkRequest.Builder#setNetworkSpecifier(NetworkSpecifier)} to pass to\n     * {@link android.net.ConnectivityManager#requestNetwork(android.net.NetworkRequest,\n     * android.net.ConnectivityManager.NetworkCallback)}\n     * [or other varieties of that API].\n     ",
    "links" : [ "android.net.NetworkRequest.Builder#setNetworkSpecifier", "android.net.NetworkRequest.Builder#addTransportType", "android.net.NetworkCapabilities#TRANSPORT_WIFI_AWARE", "WifiAwareSession#createNetworkSpecifierPassphrase", "WifiAwareNetworkSpecifier.Builder", "DiscoverySessionCallback#onServiceDiscovered", "DiscoverySessionCallback#onMessageReceived", "#createNetworkSpecifierOpen", "NetworkSpecifier", "android.net.NetworkRequest.Builder#setNetworkSpecifier", "android.net.ConnectivityManager#requestNetwork" ]
  }, {
    "name" : "public NetworkSpecifier createNetworkSpecifierPmk(@NonNull PeerHandle peerHandle, @NonNull byte[] pmk)",
    "returnType" : "NetworkSpecifier",
    "comment" : "\n     * Create a {@link android.net.NetworkRequest.Builder#setNetworkSpecifier(NetworkSpecifier)} for\n     * an encrypted WiFi Aware connection (link) to the specified peer. The\n     * {@link android.net.NetworkRequest.Builder#addTransportType(int)} should be set to\n     * {@link android.net.NetworkCapabilities#TRANSPORT_WIFI_AWARE}.\n     * <p>\n     * This method should be used when setting up a connection with a peer discovered through Aware\n     * discovery or communication (in such scenarios the MAC address of the peer is shielded by\n     * an opaque peer ID handle). If an Aware connection is needed to a peer discovered using other\n     * OOB (out-of-band) mechanism then use the alternative\n     * {@link WifiAwareSession#createNetworkSpecifierPmk(int, byte[], byte[])} method - which uses\n     * the peer's MAC address.\n     * <p>\n     * Note: per the Wi-Fi Aware specification the roles are fixed - a Subscriber is an INITIATOR\n     * and a Publisher is a RESPONDER.\n     * @deprecated Use the replacement {@link WifiAwareNetworkSpecifier.Builder}.\n     *\n     * @param peerHandle The peer's handle obtained through\n     * {@link DiscoverySessionCallback#onServiceDiscovered(PeerHandle,\n     * byte[], java.util.List)} or\n     * {@link DiscoverySessionCallback#onMessageReceived(PeerHandle,\n     * byte[])}. On a RESPONDER this value is used to gate the acceptance of a connection request\n     *                   from only that peer.\n     * @param pmk A PMK (pairwise master key, see IEEE 802.11i) specifying the key to use for\n     *            encrypting the data-path. Use the\n     *            {@link #createNetworkSpecifierPassphrase(PeerHandle, String)} to specify a\n     *            Passphrase or {@link #createNetworkSpecifierOpen(PeerHandle)} to specify an\n     *            open (unencrypted) link.\n     *\n     * @return A {@link NetworkSpecifier} to be used to construct\n     * {@link android.net.NetworkRequest.Builder#setNetworkSpecifier(NetworkSpecifier)} to pass to\n     * {@link android.net.ConnectivityManager#requestNetwork(android.net.NetworkRequest,\n     * android.net.ConnectivityManager.NetworkCallback)}\n     * [or other varieties of that API].\n     *\n     * @hide\n     ",
    "links" : [ "android.net.NetworkRequest.Builder#setNetworkSpecifier", "android.net.NetworkRequest.Builder#addTransportType", "android.net.NetworkCapabilities#TRANSPORT_WIFI_AWARE", "WifiAwareSession#createNetworkSpecifierPmk", "WifiAwareNetworkSpecifier.Builder", "DiscoverySessionCallback#onServiceDiscovered", "DiscoverySessionCallback#onMessageReceived", "#createNetworkSpecifierPassphrase", "#createNetworkSpecifierOpen", "NetworkSpecifier", "android.net.NetworkRequest.Builder#setNetworkSpecifier", "android.net.ConnectivityManager#requestNetwork" ]
  } ],
  "variableNames" : [ "TAG", "DBG", "VDBG", "MAX_SEND_RETRY_COUNT", "mMgr", "mClientId", "mSessionId", "mTerminated", "mCloseGuard" ],
  "methodNames" : [ "public static int getMaxSendRetryCount()", "public void close()", "public void setTerminated()", "protected void finalize() throws Throwable", "public int getClientId()", "public int getSessionId()", "public void sendMessage(@NonNull PeerHandle peerHandle, int messageId, @Nullable byte[] message, int retryCount)", "public void sendMessage(@NonNull PeerHandle peerHandle, int messageId, @Nullable byte[] message)", "public NetworkSpecifier createNetworkSpecifierOpen(@NonNull PeerHandle peerHandle)", "public NetworkSpecifier createNetworkSpecifierPassphrase(@NonNull PeerHandle peerHandle, @NonNull String passphrase)", "public NetworkSpecifier createNetworkSpecifierPmk(@NonNull PeerHandle peerHandle, @NonNull byte[] pmk)" ]
}