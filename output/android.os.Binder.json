{
  "filePath" : "/home/maryam/clearblue/files/android-source-35/android/os/Binder.java",
  "packageName" : "android.os",
  "className" : "Binder",
  "comment" : "\n * Base class for a remotable object, the core part of a lightweight\n * remote procedure call mechanism defined by {@link IBinder}.\n * This class is an implementation of IBinder that provides\n * standard local implementation of such an object.\n *\n * <p>Most developers will not implement this class directly, instead using the\n * <a href=\"{@docRoot}guide/components/aidl.html\">aidl</a> tool to describe the desired\n * interface, having it generate the appropriate Binder subclass. You can,\n * however, derive directly from Binder to implement your own custom RPC\n * protocol or simply instantiate a raw Binder object directly to use as a\n * token that can be shared across processes.\n *\n * <p>This class is just a basic IPC primitive; it has no impact on an application's\n * lifecycle, and is valid only as long as the process that created it continues to run.\n * To use this correctly, you must be doing so within the context of a top-level\n * application component (a {@link android.app.Service}, {@link android.app.Activity},\n * or {@link android.content.ContentProvider}) that lets the system know your process\n * should remain running.\n *\n * <p>You must keep in mind the situations in which your process\n * could go away, and thus require that you later re-create a new Binder and re-attach\n * it when the process starts again. For example, if you are using this within an\n * {@link android.app.Activity}, your activity's process may be killed any time the\n * activity is not started; if the activity is later re-created you will need to\n * create a new Binder and hand it back to the correct place again; you need to be\n * aware that your process may be started for another reason (for example to receive\n * a broadcast) that will not involve re-creating the activity and thus run its code\n * to create a new Binder.\n *\n * @see IBinder\n ",
  "links" : [ "android.app.Service", "android.app.Activity", "android.content.ContentProvider", "android.os.IBinder" ],
  "variables" : [ {
    "name" : "FIND_POTENTIAL_LEAKS",
    "type" : "boolean",
    "comment" : "\n     * Set this flag to true to detect anonymous, local or member classes\n     * that extend this Binder class and that are not static. These kind\n     * of classes can potentially create leaks.\n     ",
    "links" : [ ]
  }, {
    "name" : "CHECK_PARCEL_SIZE",
    "type" : "boolean",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "TAG",
    "type" : "String",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "LOG_RUNTIME_EXCEPTION",
    "type" : "boolean",
    "comment" : " DO NOT SUBMIT WITH TRUE",
    "links" : [ ]
  }, {
    "name" : "UNSET_WORKSOURCE",
    "type" : "int",
    "comment" : "\n     * Value to represents that a calling work source is not set.\n     *\n     * <p>This constant needs to be kept in sync with IPCThreadState::kUnsetWorkSource.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "sDumpDisabled",
    "type" : "String",
    "comment" : "\n     * Control whether {@link #dump(FileDescriptor, PrintWriter, String[]) dump()}\n     * calls are allowed.\n     ",
    "links" : [ "#dump(FileDescriptor" ]
  }, {
    "name" : "sTransactionTracker",
    "type" : "TransactionTracker",
    "comment" : "\n     * Global transaction tracker instance for this process.\n     ",
    "links" : [ ]
  }, {
    "name" : "sObserver",
    "type" : "BinderInternal.Observer",
    "comment" : "\n     * Global observer for this process.\n     ",
    "links" : [ ]
  }, {
    "name" : "NATIVE_ALLOCATION_SIZE",
    "type" : "int",
    "comment" : "\n     * Guestimate of native memory associated with a Binder.\n     ",
    "links" : [ ]
  }, {
    "name" : "sHeavyHitterWatcher",
    "type" : "BinderCallHeavyHitterWatcher",
    "comment" : "\n     * The watcher to monitor the heavy hitter from incoming transactions\n     ",
    "links" : [ ]
  }, {
    "name" : "sStackTrackingEnabled",
    "type" : "boolean",
    "comment" : "\n     * Flag indicating whether we should be tracing transact calls.\n     ",
    "links" : [ ]
  }, {
    "name" : "sWarnOnBlocking",
    "type" : "boolean",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "sWarnOnBlockingOnCurrentThread",
    "type" : "ThreadLocal<Boolean>",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "sIdentity$ravenwood",
    "type" : "ThreadLocal<SomeArgs>",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mObject",
    "type" : "long",
    "comment" : "\n     * Raw native pointer to JavaBBinderHolder object. Owned by this Java object. Not null.\n     ",
    "links" : [ ]
  }, {
    "name" : "mOwner",
    "type" : "IInterface",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mDescriptor",
    "type" : "String",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mTransactionTraceNames",
    "type" : "AtomicReferenceArray<String>",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mSimpleDescriptor",
    "type" : "String",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "TRANSACTION_TRACE_NAME_ID_LIMIT",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "sIsHandlingBinderTransaction",
    "type" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "sBinderCallback",
    "type" : "IBinderCallback",
    "comment" : "\n     * TODO (b/308179628): Move this to libbinder for non-Java usages.\n     ",
    "links" : [ ]
  }, {
    "name" : "sWorkSourceProvider",
    "type" : "BinderInternal.WorkSourceProvider",
    "comment" : "\n     * By default, we use the calling UID since we can always trust it.\n     ",
    "links" : [ ]
  } ],
  "methods" : [ {
    "name" : "private static native long getNativeFinalizer()",
    "returnType" : "long",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public static void enableStackTracking()",
    "returnType" : "void",
    "comment" : "\n     * Enable Binder IPC stack tracking. If enabled, every binder transaction will be logged to\n     * {@link TransactionTracker}.\n     *\n     * @hide\n     ",
    "links" : [ "android.os.TransactionTracker" ]
  }, {
    "name" : "public static void disableStackTracking()",
    "returnType" : "void",
    "comment" : "\n     * Disable Binder IPC stack tracking.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public static boolean isStackTrackingEnabled()",
    "returnType" : "boolean",
    "comment" : "\n     * Check if binder transaction stack tracking is enabled.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public static synchronized TransactionTracker getTransactionTracker()",
    "returnType" : "TransactionTracker",
    "comment" : "\n     * Get the binder transaction tracker for this process.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public static void setObserver(@Nullable BinderInternal.Observer observer)",
    "returnType" : "void",
    "comment" : "\n     * Get the binder transaction observer for this process.\n     *\n     * TODO(b/299356196): only applies to Java code, not C++/Rust\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public static void setWarnOnBlocking(boolean warnOnBlocking)",
    "returnType" : "void",
    "comment" : "\n     * Warn if any blocking binder transactions are made out from this process.\n     * This is typically only useful for the system process, to prevent it from\n     * blocking on calls to external untrusted code. Instead, all outgoing calls\n     * that require a result must be sent as {@link IBinder#FLAG_ONEWAY} calls\n     * which deliver results through a callback interface.\n     *\n     * TODO(b/299355525): only applies to Java code, not C++/Rust\n     *\n     * @hide\n     ",
    "links" : [ "android.os.IBinder#FLAG_ONEWAY" ]
  }, {
    "name" : "public static IBinder allowBlocking(IBinder binder)",
    "returnType" : "IBinder",
    "comment" : "\n     * Allow blocking calls on the given interface, overriding the requested\n     * value of {@link #setWarnOnBlocking(boolean)}.\n     *\n     * <p>This should only be rarely called when you are <em>absolutely sure</em>\n     * the remote interface is a built-in system component that can never be\n     * upgraded. In particular, this <em>must never</em> be called for\n     * interfaces hosted by package that could be upgraded or replaced,\n     * otherwise you risk system instability if that remote interface wedges.\n     *\n     * TODO(b/299355525): only applies to Java code, not C++/Rust\n     *\n     * @hide\n     ",
    "links" : [ "#setWarnOnBlocking(boolean)" ]
  }, {
    "name" : "public static IBinder defaultBlocking(IBinder binder)",
    "returnType" : "IBinder",
    "comment" : "\n     * Reset the given interface back to the default blocking behavior,\n     * reverting any changes made by {@link #allowBlocking(IBinder)}.\n     *\n     * @hide\n     ",
    "links" : [ "#allowBlocking(IBinder)" ]
  }, {
    "name" : "public static void copyAllowBlocking(IBinder fromBinder, IBinder toBinder)",
    "returnType" : "void",
    "comment" : "\n     * Inherit the current {@link #allowBlocking(IBinder)} value from one given\n     * interface to another.\n     *\n     * @hide\n     ",
    "links" : [ "#allowBlocking(IBinder)" ]
  }, {
    "name" : "public static void allowBlockingForCurrentThread()",
    "returnType" : "void",
    "comment" : "\n     * Allow blocking calls for the current thread.\n     *\n     * @see {@link #allowBlocking}.\n     *\n     * @hide\n     ",
    "links" : [ "#allowBlocking" ]
  }, {
    "name" : "public static void defaultBlockingForCurrentThread()",
    "returnType" : "void",
    "comment" : "\n     * Reset the current thread to the default blocking behavior.\n     *\n     * @see {@link #defaultBlocking}.\n     *\n     * @hide\n     ",
    "links" : [ "#defaultBlocking" ]
  }, {
    "name" : "public static void init$ravenwood()",
    "returnType" : "void",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "public static void reset$ravenwood()",
    "returnType" : "void",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "public static final native int getCallingPid()",
    "returnType" : "int",
    "comment" : "\n     * Return the ID of the process that sent you the current transaction\n     * that is being processed. This PID can be used with higher-level\n     * system services to determine its identity and check permissions.\n     * If the current thread is not currently executing an incoming transaction,\n     * then its own PID is returned.\n     *\n     * Warning: oneway transactions do not receive PID. Even if you expect\n     * a transaction to be synchronous, a misbehaving client could send it\n     * as a asynchronous call and result in a 0 PID here. Additionally, if\n     * there is a race and the calling process dies, the PID may still be\n     * 0 for a synchronous call.\n     ",
    "links" : [ ]
  }, {
    "name" : "public static final int getCallingPid$ravenwood()",
    "returnType" : "int",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "public static final native int getCallingUid()",
    "returnType" : "int",
    "comment" : "\n     * Return the Linux UID assigned to the process that sent you the\n     * current transaction that is being processed. This UID can be used with\n     * higher-level system services to determine its identity and check\n     * permissions. If the current thread is not currently executing an\n     * incoming transaction, then its own UID is returned.\n     ",
    "links" : [ ]
  }, {
    "name" : "public static final int getCallingUid$ravenwood()",
    "returnType" : "int",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "public static final native boolean isDirectlyHandlingTransactionNative()",
    "returnType" : "boolean",
    "comment" : "\n     * Returns {@code true} if the current thread is currently executing an\n     * incoming transaction.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public static final boolean isDirectlyHandlingTransactionNative$ravenwood()",
    "returnType" : "boolean",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "public static final boolean isDirectlyHandlingTransaction()",
    "returnType" : "boolean",
    "comment" : "\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public static void setIsDirectlyHandlingTransactionOverride(boolean isInTransaction)",
    "returnType" : "void",
    "comment" : "\n     * This is Test API which will be used to override output of isDirectlyHandlingTransactionNative\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "private static native boolean hasExplicitIdentity()",
    "returnType" : "boolean",
    "comment" : "\n    * Returns {@code true} if the current thread has had its identity\n    * set explicitly via {@link #clearCallingIdentity()}\n    *\n    * @hide\n    ",
    "links" : [ "#clearCallingIdentity()" ]
  }, {
    "name" : "private static boolean hasExplicitIdentity$ravenwood()",
    "returnType" : "boolean",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "public static final int getCallingUidOrThrow()",
    "returnType" : "int",
    "comment" : "\n     * Return the Linux UID assigned to the process that sent the transaction\n     * currently being processed.\n     *\n     * @throws IllegalStateException if the current thread is not currently\n     * executing an incoming transaction and the calling identity has not been\n     * explicitly set with {@link #clearCallingIdentity()}\n     ",
    "links" : [ "#clearCallingIdentity()" ]
  }, {
    "name" : "public static final int getCallingUidOrWtf(String message)",
    "returnType" : "int",
    "comment" : "\n     * Return the Linux UID assigned to the process that sent the transaction\n     * currently being processed.\n     *\n     * Slog.wtf if the current thread is not currently\n     * executing an incoming transaction and the calling identity has not been\n     * explicitly set with {@link #clearCallingIdentity()}\n     *\n     * @hide\n     ",
    "links" : [ "#clearCallingIdentity()" ]
  }, {
    "name" : "public static final UserHandle getCallingUserHandle()",
    "returnType" : "UserHandle",
    "comment" : "\n     * Return the UserHandle assigned to the process that sent you the\n     * current transaction that is being processed. This is the user\n     * of the caller. It is distinct from {@link #getCallingUid()} in that a\n     * particular user will have multiple distinct apps running under it each\n     * with their own UID. If the current thread is not currently executing an\n     * incoming transaction, then its own UserHandle is returned.\n     *\n     * @see UserHandle\n     ",
    "links" : [ "#getCallingUid()" ]
  }, {
    "name" : "public static final native long clearCallingIdentity()",
    "returnType" : "long",
    "comment" : "\n     * Reset the identity of the incoming IPC on the current thread. This can\n     * be useful if, while handling an incoming call, you will be calling\n     * on interfaces of other objects that may be local to your process and\n     * need to do permission checks on the calls coming into them (so they\n     * will check the permission of your own local process, and not whatever\n     * process originally called you).\n     *\n     * @return Returns an opaque token that can be used to restore the\n     * original calling identity by passing it to\n     * {@link #restoreCallingIdentity(long)}.\n     *\n     * @see #getCallingPid()\n     * @see #getCallingUid()\n     * @see #restoreCallingIdentity(long)\n     ",
    "links" : [ "#restoreCallingIdentity(long)" ]
  }, {
    "name" : "public static final long clearCallingIdentity$ravenwood()",
    "returnType" : "long",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "public static final native void restoreCallingIdentity(long token)",
    "returnType" : "void",
    "comment" : "\n     * Restore the identity of the incoming IPC on the current thread\n     * back to a previously identity that was returned by {@link\n     * #clearCallingIdentity}.\n     *\n     * @param token The opaque token that was previously returned by\n     * {@link #clearCallingIdentity}.\n     *\n     * @see #clearCallingIdentity\n     ",
    "links" : [ "#clearCallingIdentity" ]
  }, {
    "name" : "public static final void restoreCallingIdentity$ravenwood(long token)",
    "returnType" : "void",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "public static final void withCleanCallingIdentity(@NonNull ThrowingRunnable action)",
    "returnType" : "void",
    "comment" : "\n     * Convenience method for running the provided action enclosed in\n     * {@link #clearCallingIdentity}/{@link #restoreCallingIdentity}.\n     *\n     * <p>Any exception thrown by the given action will be caught and\n     * rethrown after the call to {@link #restoreCallingIdentity}.\n     *\n     * @hide\n     ",
    "links" : [ "#restoreCallingIdentity", "#clearCallingIdentity" ]
  }, {
    "name" : "public static final T withCleanCallingIdentity(@NonNull ThrowingSupplier<T> action)",
    "returnType" : "T",
    "comment" : "\n     * Convenience method for running the provided action enclosed in\n     * {@link #clearCallingIdentity}/{@link #restoreCallingIdentity} returning the result.\n     *\n     * <p>Any exception thrown by the given action will be caught and rethrown after\n     * the call to {@link #restoreCallingIdentity}.\n     *\n     * @hide\n     ",
    "links" : [ "#restoreCallingIdentity", "#clearCallingIdentity" ]
  }, {
    "name" : "public static final native void setThreadStrictModePolicy(int policyMask)",
    "returnType" : "void",
    "comment" : "\n     * Sets the native thread-local StrictMode policy mask.\n     *\n     * <p>The StrictMode settings are kept in two places: a Java-level\n     * threadlocal for libcore/Dalvik, and a native threadlocal (set\n     * here) for propagation via Binder calls. This is a little\n     * unfortunate, but necessary to break otherwise more unfortunate\n     * dependencies either of Dalvik on Android, or Android\n     * native-only code on Dalvik.\n     *\n     * @see StrictMode\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public static final native int getThreadStrictModePolicy()",
    "returnType" : "int",
    "comment" : "\n     * Gets the current native thread-local StrictMode policy mask.\n     *\n     * @see #setThreadStrictModePolicy\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public static final native long setCallingWorkSourceUid(int workSource)",
    "returnType" : "long",
    "comment" : "\n     * Sets the work source for this thread.\n     *\n     * <p>All the following binder calls on this thread will use the provided work source. If this\n     * is called during an on-going binder transaction, all the following binder calls will use the\n     * work source until the end of the transaction.\n     *\n     * <p>The concept of worksource is similar to {@link WorkSource}. However, for performance\n     * reasons, we only support one UID. This UID represents the original user responsible for the\n     * binder calls.\n     *\n     * <p>{@link #restoreCallingWorkSource(long)} must always be called after setting the\n     * worksource.\n     *\n     * <p>A typical use case would be\n     * <pre>\n     * long token = Binder.setCallingWorkSourceUid(uid);\n     * try {\n     *   // Call an API.\n     * } finally {\n     *   Binder.restoreCallingWorkSource(token);\n     * }\n     * </pre>\n     *\n     * <p>The work source will be propagated for future outgoing binder transactions\n     * executed on this thread.\n     *\n     * @param workSource The original UID responsible for the binder call.\n     * @return token to restore original work source.\n     ",
    "links" : [ "#restoreCallingWorkSource(long)", "android.os.WorkSource" ]
  }, {
    "name" : "public static final native int getCallingWorkSourceUid()",
    "returnType" : "int",
    "comment" : "\n     * Returns the work source set by the caller.\n     *\n     * <p>Unlike {@link #getCallingUid()}, this result of this method cannot be trusted. The\n     * caller can set the value to whatever they want. Only use this value if you trust the calling\n     * UID.\n     *\n     * @return The original UID responsible for the binder transaction.\n     ",
    "links" : [ "#getCallingUid()" ]
  }, {
    "name" : "public static final native long clearCallingWorkSource()",
    "returnType" : "long",
    "comment" : "\n     * Clears the work source on this thread.\n     *\n     * <p>The work source will be propagated for future outgoing binder transactions\n     * executed on this thread.\n     *\n     * <p>{@link #restoreCallingWorkSource(long)} must always be called after clearing the\n     * worksource.\n     *\n     * <p>A typical use case would be\n     * <pre>\n     * long token = Binder.clearCallingWorkSource();\n     * try {\n     *   // Call an API.\n     * } finally {\n     *   Binder.restoreCallingWorkSource(token);\n     * }\n     * </pre>\n     *\n     * @return token to restore original work source.\n     ",
    "links" : [ "#restoreCallingWorkSource(long)" ]
  }, {
    "name" : "public static final native void restoreCallingWorkSource(long token)",
    "returnType" : "void",
    "comment" : "\n     * Restores the work source on this thread using a token returned by\n     * {@link #setCallingWorkSourceUid(int)} or {@link #clearCallingWorkSource()}.\n     *\n     * <p>A typical use case would be\n     * <pre>\n     * long token = Binder.setCallingWorkSourceUid(uid);\n     * try {\n     *   // Call an API.\n     * } finally {\n     *   Binder.restoreCallingWorkSource(token);\n     * }\n     * </pre>\n     ",
    "links" : [ "#clearCallingWorkSource()", "#setCallingWorkSourceUid(int)" ]
  }, {
    "name" : "public final native void markVintfStability()",
    "returnType" : "void",
    "comment" : "\n     * Mark as being built with VINTF-level stability promise. This API should\n     * only ever be invoked by generated code from the aidl compiler. It means\n     * that the interface represented by this binder is guaranteed to be kept\n     * stable for several years, according to the VINTF compatibility lifecycle,\n     * and the build system also keeps snapshots of these APIs and invokes the\n     * AIDL compiler to make sure that these snapshots are backwards compatible.\n     * Instead of using this API, use the @VintfStability annotation on your\n     * AIDL interface.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public final native void forceDowngradeToSystemStability()",
    "returnType" : "void",
    "comment" : "\n     * Use a VINTF-stability binder w/o VINTF requirements. Should be called\n     * on a binder before it is sent out of process.\n     *\n     * <p>This must be called before the object is sent to another process.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public static final native void flushPendingCommands()",
    "returnType" : "void",
    "comment" : "\n     * Flush any Binder commands pending in the current thread to the kernel\n     * driver. This can be\n     * useful to call before performing an operation that may block for a long\n     * time, to ensure that any pending object references have been released\n     * in order to prevent the process from holding on to objects longer than\n     * it needs to.\n     ",
    "links" : [ ]
  }, {
    "name" : "public static final void flushPendingCommands$ravenwood()",
    "returnType" : "void",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "public static final void joinThreadPool()",
    "returnType" : "void",
    "comment" : "\n     * Add the calling thread to the IPC thread pool. This function does\n     * not return until the current process is exiting.\n     ",
    "links" : [ ]
  }, {
    "name" : "public static final boolean isProxy(IInterface iface)",
    "returnType" : "boolean",
    "comment" : "\n     * Returns true if the specified interface is a proxy.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public static final native void blockUntilThreadAvailable()",
    "returnType" : "void",
    "comment" : "\n     * Call blocks until the number of executing binder threads is less\n     * than the maximum number of binder threads allowed for this process.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public static final void setTransactionCallback(IBinderCallback callback)",
    "returnType" : "void",
    "comment" : "\n     * Set callback function for unexpected binder transaction errors.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public static final void transactionCallback(int pid, int code, int flags, int err)",
    "returnType" : "void",
    "comment" : "\n     * Execute the callback function if it's already set.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public void attachInterface(@Nullable IInterface owner, @Nullable String descriptor)",
    "returnType" : "void",
    "comment" : "\n     * Convenience method for associating a specific interface with the Binder.\n     * After calling, {@link #queryLocalInterface(String) queryLocalInterface()}\n     * will be implemented for you to return the given owner IInterface when\n     * the corresponding descriptor is requested.\n     ",
    "links" : [ "#queryLocalInterface(String)" ]
  }, {
    "name" : "public String getInterfaceDescriptor()",
    "returnType" : "String",
    "comment" : "\n     * Default implementation returns an empty interface name.\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean pingBinder()",
    "returnType" : "boolean",
    "comment" : "\n     * Default implementation always returns true -- if you got here,\n     * the object is alive.\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean isBinderAlive()",
    "returnType" : "boolean",
    "comment" : "\n     * {@inheritDoc}\n     *\n     * Note that if you're calling on a local binder, this always returns true\n     * because your process is alive if you're calling it.\n     ",
    "links" : [ ]
  }, {
    "name" : "public IInterface queryLocalInterface(@NonNull String descriptor)",
    "returnType" : "IInterface",
    "comment" : "\n     * Use information supplied to {@link #attachInterface attachInterface()}\n     * to return the associated {@link IInterface} if it matches the requested\n     * descriptor.\n     ",
    "links" : [ "#attachInterface", "android.os.IInterface" ]
  }, {
    "name" : "public static void setDumpDisabled(String msg)",
    "returnType" : "void",
    "comment" : "\n     * Control disabling of dump calls in this process. This is used by the system\n     * process watchdog to disable incoming dump calls while it has detecting the system\n     * is hung and is reporting that back to the activity controller. This is to\n     * prevent the controller from getting hung up on bug reports at this point.\n     *\n     * @param msg The message to show instead of the dump; if null, dumps are\n     * re-enabled.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public static void setProxyTransactListener(@Nullable ProxyTransactListener listener)",
    "returnType" : "void",
    "comment" : "\n     * Sets a listener for the transact method on the proxy-side.\n     *\n     * <li>The listener is global. Only fast operations should be done to avoid thread\n     * contentions.\n     * <li>The listener implementation needs to handle synchronization if needed. The methods on the\n     * listener can be called concurrently.\n     * <li>Listener set will be used for new transactions. On-going transaction will still use the\n     * previous listener (if already set).\n     * <li>The listener is called on the critical path of the binder transaction so be careful about\n     * performance.\n     * <li>Never execute another binder transaction inside the listener.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "protected boolean onTransact(int code, @NonNull Parcel data, @Nullable Parcel reply, int flags) throws RemoteException",
    "returnType" : "boolean",
    "comment" : "\n     * Default implementation is a stub that returns false. You will want\n     * to override this to do the appropriate unmarshalling of transactions.\n     *\n     * <p>If you want to call this, call transact().\n     *\n     * <p>Implementations that are returning a result should generally use\n     * {@link Parcel#writeNoException() Parcel.writeNoException} and\n     * {@link Parcel#writeException(Exception) Parcel.writeException} to propagate\n     * exceptions back to the caller.\n     *\n     * @param code The action to perform. This should be a number between\n     * {@link #FIRST_CALL_TRANSACTION} and {@link #LAST_CALL_TRANSACTION}.\n     * @param data Marshalled data being received from the caller.\n     * @param reply If the caller is expecting a result back, it should be marshalled\n     * in to here.\n     * @param flags Additional operation flags. Either 0 for a normal\n     * RPC, or {@link #FLAG_ONEWAY} for a one-way RPC.\n     *\n     * @return Return true on a successful call; returning false is generally used to\n     * indicate that you did not understand the transaction code.\n     ",
    "links" : [ "#FLAG_ONEWAY", "android.os.Parcel#writeException(Exception)", "android.os.Parcel#writeNoException()", "#FIRST_CALL_TRANSACTION", "#LAST_CALL_TRANSACTION" ]
  }, {
    "name" : "public String getTransactionName(int transactionCode)",
    "returnType" : "String",
    "comment" : "\n     * Resolves a transaction code to a human readable name.\n     *\n     * <p>Default implementation is a stub that returns null.\n     *\n     * <p>AIDL generated code will return the original method name.\n     *\n     * @param transactionCode The code to resolve.\n     * @return A human readable name.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public final String getTransactionTraceName(int transactionCode)",
    "returnType" : "String",
    "comment" : "\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "private String getSimpleDescriptor()",
    "returnType" : "String",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public int getMaxTransactionId()",
    "returnType" : "int",
    "comment" : "\n     * @return The highest user-defined transaction id of all transactions.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public void dump(@NonNull FileDescriptor fd, @Nullable String[] args)",
    "returnType" : "void",
    "comment" : "\n     * Implemented to call the more convenient version\n     * {@link #dump(FileDescriptor, PrintWriter, String[])}.\n     ",
    "links" : [ "#dump(FileDescriptor" ]
  }, {
    "name" : " void doDump(FileDescriptor fd, PrintWriter pw, String[] args)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public void dumpAsync(@NonNull final FileDescriptor fd, @Nullable final String[] args)",
    "returnType" : "void",
    "comment" : "\n     * Like {@link #dump(FileDescriptor, String[])}, but ensures the target\n     * executes asynchronously.\n     ",
    "links" : [ "#dump(FileDescriptor" ]
  }, {
    "name" : "protected void dump(@NonNull FileDescriptor fd, @NonNull PrintWriter fout, @Nullable String[] args)",
    "returnType" : "void",
    "comment" : "\n     * Print the object's state into the given stream.\n     *\n     * @param fd The raw file descriptor that the dump is being sent to.\n     * @param fout The file to which you should dump your state. This will be\n     * closed for you after you return.\n     * @param args additional arguments to the dump request.\n     ",
    "links" : [ ]
  }, {
    "name" : "public void shellCommand(@Nullable FileDescriptor in, @Nullable FileDescriptor out, @Nullable FileDescriptor err, @NonNull String[] args, @Nullable ShellCallback callback, @NonNull ResultReceiver resultReceiver) throws RemoteException",
    "returnType" : "void",
    "comment" : "\n     * @param in The raw file descriptor that an input data stream can be read from.\n     * @param out The raw file descriptor that normal command messages should be written to.\n     * @param err The raw file descriptor that command error messages should be written to.\n     * @param args Command-line arguments.\n     * @param callback Callback through which to interact with the invoking shell.\n     * @param resultReceiver Called when the command has finished executing, with the result code.\n     * @throws RemoteException\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public void onShellCommand(@Nullable FileDescriptor in, @Nullable FileDescriptor out, @Nullable FileDescriptor err, @NonNull String[] args, @Nullable ShellCallback callback, @NonNull ResultReceiver resultReceiver) throws RemoteException",
    "returnType" : "void",
    "comment" : "\n     * Handle a call to {@link #shellCommand}.\n     *\n     * <p>The default implementation performs a caller check to make sure the caller UID is of\n     * SHELL or ROOT, and then call {@link #handleShellCommand}.\n     *\n     * <p class=\"caution\">Note: no permission checking is done before calling this method; you must\n     * apply any security checks as appropriate for the command being executed.\n     * Consider using {@link ShellCommand} to help in the implementation.\n     *\n     * @hide\n     ",
    "links" : [ "android.os.ShellCommand", "#shellCommand", "#handleShellCommand" ]
  }, {
    "name" : "public int handleShellCommand(@NonNull ParcelFileDescriptor in, @NonNull ParcelFileDescriptor out, @NonNull ParcelFileDescriptor err, @NonNull String[] args)",
    "returnType" : "int",
    "comment" : "\n     * System services can implement this method to implement ADB shell commands.\n     *\n     * <p>A system binder service can implement it to handle shell commands on ADB. For example,\n     * the Job Scheduler service implements it to handle {@code adb shell cmd jobscheduler}.\n     *\n     * <p>Commands are only executable by ADB shell; i.e. only {@link Process#SHELL_UID} and\n     * {@link Process#ROOT_UID} can call them.\n     *\n     * @param in standard input\n     * @param out standard output\n     * @param err standard error\n     * @param args arguments passed to the command. Can be empty. The first argument is typically\n     * a subcommand, such as {@code run} for {@code adb shell cmd jobscheduler run}.\n     * @return the status code returned from the {@code cmd} command.\n     *\n     * @hide\n     ",
    "links" : [ "android.os.Process#SHELL_UID", "android.os.Process#ROOT_UID" ]
  }, {
    "name" : "public final native IBinder getExtension()",
    "returnType" : "IBinder",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "public final native void setExtension(@Nullable IBinder extension)",
    "returnType" : "void",
    "comment" : "\n     * Set the binder extension.\n     * This should be called immediately when the object is created.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public final boolean transact(int code, @NonNull Parcel data, @Nullable Parcel reply, int flags) throws RemoteException",
    "returnType" : "boolean",
    "comment" : "\n     * Default implementation rewinds the parcels and calls onTransact. On\n     * the remote side, transact calls into the binder to do the IPC.\n     ",
    "links" : [ ]
  }, {
    "name" : "public void linkToDeath(@NonNull DeathRecipient recipient, int flags)",
    "returnType" : "void",
    "comment" : "\n     * Local implementation is a no-op.\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean unlinkToDeath(@NonNull DeathRecipient recipient, int flags)",
    "returnType" : "boolean",
    "comment" : "\n     * Local implementation is a no-op.\n     ",
    "links" : [ ]
  }, {
    "name" : " static void checkParcel(IBinder obj, int code, Parcel parcel, String msg)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private static native long getNativeBBinderHolder()",
    "returnType" : "long",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private static long getNativeBBinderHolder$ravenwood()",
    "returnType" : "long",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public static void setWorkSourceProvider(BinderInternal.WorkSourceProvider workSourceProvider)",
    "returnType" : "void",
    "comment" : "\n     * Sets the work source provider.\n     *\n     * <li>The callback is global. Only fast operations should be done to avoid thread\n     * contentions.\n     * <li>The callback implementation needs to handle synchronization if needed. The methods on the\n     * callback can be called concurrently.\n     * <li>The callback is called on the critical path of the binder transaction so be careful about\n     * performance.\n     * <li>Never execute another binder transaction inside the callback.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "private boolean execTransact(int code, long dataObj, long replyObj, int flags)",
    "returnType" : "boolean",
    "comment" : " Entry point from android_util_Binder.cpp's onTransact.",
    "links" : [ ]
  }, {
    "name" : "private boolean execTransactInternal(int code, Parcel data, Parcel reply, int flags, int callingUid)",
    "returnType" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public static synchronized void setHeavyHitterWatcherConfig(final boolean enabled, final int batchSize, final float threshold, @Nullable final BinderCallHeavyHitterListener listener)",
    "returnType" : "void",
    "comment" : "\n     * Set the configuration for the heavy hitter watcher.\n     *\n     * @hide\n     ",
    "links" : [ ]
  } ],
  "methodNames" : [ "private static native long getNativeFinalizer()", "public static void enableStackTracking()", "public static void disableStackTracking()", "public static boolean isStackTrackingEnabled()", "public static synchronized TransactionTracker getTransactionTracker()", "public static void setObserver(@Nullable BinderInternal.Observer observer)", "public static void setWarnOnBlocking(boolean warnOnBlocking)", "public static IBinder allowBlocking(IBinder binder)", "public static IBinder defaultBlocking(IBinder binder)", "public static void copyAllowBlocking(IBinder fromBinder, IBinder toBinder)", "public static void allowBlockingForCurrentThread()", "public static void defaultBlockingForCurrentThread()", "public static void init$ravenwood()", "public static void reset$ravenwood()", "public static final native int getCallingPid()", "public static final int getCallingPid$ravenwood()", "public static final native int getCallingUid()", "public static final int getCallingUid$ravenwood()", "public static final native boolean isDirectlyHandlingTransactionNative()", "public static final boolean isDirectlyHandlingTransactionNative$ravenwood()", "public static final boolean isDirectlyHandlingTransaction()", "public static void setIsDirectlyHandlingTransactionOverride(boolean isInTransaction)", "private static native boolean hasExplicitIdentity()", "private static boolean hasExplicitIdentity$ravenwood()", "public static final int getCallingUidOrThrow()", "public static final int getCallingUidOrWtf(String message)", "public static final UserHandle getCallingUserHandle()", "public static final native long clearCallingIdentity()", "public static final long clearCallingIdentity$ravenwood()", "public static final native void restoreCallingIdentity(long token)", "public static final void restoreCallingIdentity$ravenwood(long token)", "public static final void withCleanCallingIdentity(@NonNull ThrowingRunnable action)", "public static final T withCleanCallingIdentity(@NonNull ThrowingSupplier<T> action)", "public static final native void setThreadStrictModePolicy(int policyMask)", "public static final native int getThreadStrictModePolicy()", "public static final native long setCallingWorkSourceUid(int workSource)", "public static final native int getCallingWorkSourceUid()", "public static final native long clearCallingWorkSource()", "public static final native void restoreCallingWorkSource(long token)", "public final native void markVintfStability()", "public final native void forceDowngradeToSystemStability()", "public static final native void flushPendingCommands()", "public static final void flushPendingCommands$ravenwood()", "public static final void joinThreadPool()", "public static final boolean isProxy(IInterface iface)", "public static final native void blockUntilThreadAvailable()", "public static final void setTransactionCallback(IBinderCallback callback)", "public static final void transactionCallback(int pid, int code, int flags, int err)", "public void attachInterface(@Nullable IInterface owner, @Nullable String descriptor)", "public String getInterfaceDescriptor()", "public boolean pingBinder()", "public boolean isBinderAlive()", "public IInterface queryLocalInterface(@NonNull String descriptor)", "public static void setDumpDisabled(String msg)", "public static void setProxyTransactListener(@Nullable ProxyTransactListener listener)", "protected boolean onTransact(int code, @NonNull Parcel data, @Nullable Parcel reply, int flags) throws RemoteException", "public String getTransactionName(int transactionCode)", "public final String getTransactionTraceName(int transactionCode)", "private String getSimpleDescriptor()", "public int getMaxTransactionId()", "public void dump(@NonNull FileDescriptor fd, @Nullable String[] args)", " void doDump(FileDescriptor fd, PrintWriter pw, String[] args)", "public void dumpAsync(@NonNull final FileDescriptor fd, @Nullable final String[] args)", "protected void dump(@NonNull FileDescriptor fd, @NonNull PrintWriter fout, @Nullable String[] args)", "public void shellCommand(@Nullable FileDescriptor in, @Nullable FileDescriptor out, @Nullable FileDescriptor err, @NonNull String[] args, @Nullable ShellCallback callback, @NonNull ResultReceiver resultReceiver) throws RemoteException", "public void onShellCommand(@Nullable FileDescriptor in, @Nullable FileDescriptor out, @Nullable FileDescriptor err, @NonNull String[] args, @Nullable ShellCallback callback, @NonNull ResultReceiver resultReceiver) throws RemoteException", "public int handleShellCommand(@NonNull ParcelFileDescriptor in, @NonNull ParcelFileDescriptor out, @NonNull ParcelFileDescriptor err, @NonNull String[] args)", "public final native IBinder getExtension()", "public final native void setExtension(@Nullable IBinder extension)", "public final boolean transact(int code, @NonNull Parcel data, @Nullable Parcel reply, int flags) throws RemoteException", "public void linkToDeath(@NonNull DeathRecipient recipient, int flags)", "public boolean unlinkToDeath(@NonNull DeathRecipient recipient, int flags)", " static void checkParcel(IBinder obj, int code, Parcel parcel, String msg)", "private static native long getNativeBBinderHolder()", "private static long getNativeBBinderHolder$ravenwood()", "public static void setWorkSourceProvider(BinderInternal.WorkSourceProvider workSourceProvider)", "private boolean execTransact(int code, long dataObj, long replyObj, int flags)", "private boolean execTransactInternal(int code, Parcel data, Parcel reply, int flags, int callingUid)", "public static synchronized void setHeavyHitterWatcherConfig(final boolean enabled, final int batchSize, final float threshold, @Nullable final BinderCallHeavyHitterListener listener)" ],
  "variableNames" : [ "FIND_POTENTIAL_LEAKS", "CHECK_PARCEL_SIZE", "TAG", "LOG_RUNTIME_EXCEPTION", "UNSET_WORKSOURCE", "sDumpDisabled", "sTransactionTracker", "sObserver", "NATIVE_ALLOCATION_SIZE", "sHeavyHitterWatcher", "sStackTrackingEnabled", "sWarnOnBlocking", "sWarnOnBlockingOnCurrentThread", "sIdentity$ravenwood", "mObject", "mOwner", "mDescriptor", "mTransactionTraceNames", "mSimpleDescriptor", "TRANSACTION_TRACE_NAME_ID_LIMIT", "sIsHandlingBinderTransaction", "sBinderCallback", "sWorkSourceProvider" ]
}