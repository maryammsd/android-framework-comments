{
  "filePath" : "/home/maryam/clearblue/files/android-source-35/java/io/DataInput.java",
  "packageName" : "java.io",
  "className" : "DataInput",
  "comment" : "\n * The {@code DataInput} interface provides\n * for reading bytes from a binary stream and\n * reconstructing from them data in any of\n * the Java primitive types. There is also\n * a\n * facility for reconstructing a {@code String}\n * from data in\n * <a href=\"#modified-utf-8\">modified UTF-8</a>\n * format.\n * <p>\n * It is generally true of all the reading\n * routines in this interface that if end of\n * file is reached before the desired number\n * of bytes has been read, an {@code EOFException}\n * (which is a kind of {@code IOException})\n * is thrown. If any byte cannot be read for\n * any reason other than end of file, an {@code IOException}\n * other than {@code EOFException} is\n * thrown. In particular, an {@code IOException}\n * may be thrown if the input stream has been\n * closed.\n *\n * <h3><a id=\"modified-utf-8\">Modified UTF-8</a></h3>\n * <p>\n * Implementations of the DataInput and DataOutput interfaces represent\n * Unicode strings in a format that is a slight modification of UTF-8.\n * (For information regarding the standard UTF-8 format, see section\n * <i>3.9 Unicode Encoding Forms</i> of <i>The Unicode Standard, Version\n * 4.0</i>)\n *\n * <ul>\n * <li>Characters in the range {@code '\\u005Cu0001'} to\n *         {@code '\\u005Cu007F'} are represented by a single byte.\n * <li>The null character {@code '\\u005Cu0000'} and characters\n *         in the range {@code '\\u005Cu0080'} to {@code '\\u005Cu07FF'} are\n *         represented by a pair of bytes.\n * <li>Characters in the range {@code '\\u005Cu0800'}\n *         to {@code '\\u005CuFFFF'} are represented by three bytes.\n * </ul>\n *\n *   <table class=\"plain\" style=\"margin-left:2em;\">\n *     <caption>Encoding of UTF-8 values</caption>\n *     <thead>\n *     <tr>\n *       <th scope=\"col\" rowspan=\"2\">Value</th>\n *       <th scope=\"col\" rowspan=\"2\">Byte</th>\n *       <th scope=\"col\" colspan=\"8\" id=\"bit_a\">Bit Values</th>\n *     </tr>\n *     <tr>\n *       <!-- Value -->\n *       <!-- Byte -->\n *       <th scope=\"col\" style=\"width:3em\"> 7 </th>\n *       <th scope=\"col\" style=\"width:3em\"> 6 </th>\n *       <th scope=\"col\" style=\"width:3em\"> 5 </th>\n *       <th scope=\"col\" style=\"width:3em\"> 4 </th>\n *       <th scope=\"col\" style=\"width:3em\"> 3 </th>\n *       <th scope=\"col\" style=\"width:3em\"> 2 </th>\n *       <th scope=\"col\" style=\"width:3em\"> 1 </th>\n *       <th scope=\"col\" style=\"width:3em\"> 0 </th>\n *     </thead>\n *     <tbody>\n *     <tr>\n *       <th scope=\"row\" style=\"text-align:left; font-weight:normal\">\n *         {@code \\u005Cu0001} to {@code \\u005Cu007F} </th>\n *       <th scope=\"row\" style=\"font-weight:normal; text-align:center\"> 1 </th>\n *       <td style=\"text-align:center\">0\n *       <td colspan=\"7\" style=\"text-align:right; padding-right:6em\">bits 6-0\n *     </tr>\n *     <tr>\n *       <th scope=\"row\" rowspan=\"2\" style=\"text-align:left; font-weight:normal\">\n *           {@code \\u005Cu0000},<br>\n *           {@code \\u005Cu0080} to {@code \\u005Cu07FF} </th>\n *       <th scope=\"row\" style=\"font-weight:normal; text-align:center\"> 1 </th>\n *       <td style=\"text-align:center\">1\n *       <td style=\"text-align:center\">1\n *       <td style=\"text-align:center\">0\n *       <td colspan=\"5\" style=\"text-align:right; padding-right:6em\">bits 10-6\n *     </tr>\n *     <tr>\n *       <!-- (value) -->\n *       <th scope=\"row\" style=\"font-weight:normal; text-align:center\"> 2 </th>\n *       <td style=\"text-align:center\">1\n *       <td style=\"text-align:center\">0\n *       <td colspan=\"6\" style=\"text-align:right; padding-right:6em\">bits 5-0\n *     </tr>\n *     <tr>\n *       <th scope=\"row\" rowspan=\"3\" style=\"text-align:left; font-weight:normal\">\n *         {@code \\u005Cu0800} to {@code \\u005CuFFFF} </th>\n *       <th scope=\"row\" style=\"font-weight:normal; text-align:center\"> 1 </th>\n *       <td style=\"text-align:center\">1\n *       <td style=\"text-align:center\">1\n *       <td style=\"text-align:center\">1\n *       <td style=\"text-align:center\">0\n *       <td colspan=\"4\" style=\"text-align:right; padding-right:6em\">bits 15-12\n *     </tr>\n *     <tr>\n *       <!-- (value) -->\n *       <th scope=\"row\" style=\"font-weight:normal; text-align:center\"> 2 </th>\n *       <td style=\"text-align:center\">1\n *       <td style=\"text-align:center\">0\n *       <td colspan=\"6\" style=\"text-align:right; padding-right:6em\">bits 11-6\n *     </tr>\n *     <tr>\n *       <!-- (value) -->\n *       <th scope=\"row\" style=\"font-weight:normal; text-align:center\"> 3 </th>\n *       <td style=\"text-align:center\">1\n *       <td style=\"text-align:center\">0\n *       <td colspan=\"6\" style=\"text-align:right; padding-right:6em\">bits 5-0\n *     </tr>\n *     </tbody>\n *   </table>\n *\n * <p>\n * The differences between this format and the\n * standard UTF-8 format are the following:\n * <ul>\n * <li>The null byte {@code '\\u005Cu0000'} is encoded in 2-byte format\n *     rather than 1-byte, so that the encoded strings never have\n *     embedded nulls.\n * <li>Only the 1-byte, 2-byte, and 3-byte formats are used.\n * <li><a href=\"../lang/Character.html#unicode\">Supplementary characters</a>\n *     are represented in the form of surrogate pairs.\n * </ul>\n * @author  Frank Yellin\n * @see     java.io.DataInputStream\n * @see     java.io.DataOutput\n * @since   1.0\n ",
  "links" : [ ],
  "variables" : [ ],
  "methods" : [ {
    "name" : " void readFully(byte[] b) throws IOException",
    "returnType" : "void",
    "comment" : "\n     * Reads some bytes from an input\n     * stream and stores them into the buffer\n     * array {@code b}. The number of bytes\n     * read is equal\n     * to the length of {@code b}.\n     * <p>\n     * This method blocks until one of the\n     * following conditions occurs:\n     * <ul>\n     * <li>{@code b.length}\n     * bytes of input data are available, in which\n     * case a normal return is made.\n     *\n     * <li>End of\n     * file is detected, in which case an {@code EOFException}\n     * is thrown.\n     *\n     * <li>An I/O error occurs, in\n     * which case an {@code IOException} other\n     * than {@code EOFException} is thrown.\n     * </ul>\n     * <p>\n     * If {@code b} is {@code null},\n     * a {@code NullPointerException} is thrown.\n     * If {@code b.length} is zero, then\n     * no bytes are read. Otherwise, the first\n     * byte read is stored into element {@code b[0]},\n     * the next one into {@code b[1]}, and\n     * so on.\n     * If an exception is thrown from\n     * this method, then it may be that some but\n     * not all bytes of {@code b} have been\n     * updated with data from the input stream.\n     *\n     * @param   b   the buffer into which the data is read.\n     * @throws  NullPointerException if {@code b} is {@code null}.\n     * @throws  EOFException  if this stream reaches the end before reading\n     *          all the bytes.\n     * @throws  IOException   if an I/O error occurs.\n     ",
    "links" : [ ]
  }, {
    "name" : " void readFully(byte[] b, int off, int len) throws IOException",
    "returnType" : "void",
    "comment" : "\n     *\n     * Reads {@code len}\n     * bytes from\n     * an input stream.\n     * <p>\n     * This method\n     * blocks until one of the following conditions\n     * occurs:\n     * <ul>\n     * <li>{@code len} bytes\n     * of input data are available, in which case\n     * a normal return is made.\n     *\n     * <li>End of file\n     * is detected, in which case an {@code EOFException}\n     * is thrown.\n     *\n     * <li>An I/O error occurs, in\n     * which case an {@code IOException} other\n     * than {@code EOFException} is thrown.\n     * </ul>\n     * <p>\n     * If {@code b} is {@code null},\n     * a {@code NullPointerException} is thrown.\n     * If {@code off} is negative, or {@code len}\n     * is negative, or {@code off+len} is\n     * greater than the length of the array {@code b},\n     * then an {@code IndexOutOfBoundsException}\n     * is thrown.\n     * If {@code len} is zero,\n     * then no bytes are read. Otherwise, the first\n     * byte read is stored into element {@code b[off]},\n     * the next one into {@code b[off+1]},\n     * and so on. The number of bytes read is,\n     * at most, equal to {@code len}.\n     *\n     * @param   b    the buffer into which the data is read.\n     * @param   off  an int specifying the offset in the data array {@code b}.\n     * @param   len  an int specifying the number of bytes to read.\n     * @throws  NullPointerException if {@code b} is {@code null}.\n     * @throws  IndexOutOfBoundsException if {@code off} is negative,\n     *          {@code len} is negative, or {@code len} is greater than\n     *          {@code b.length - off}.\n     * @throws  EOFException  if this stream reaches the end before reading\n     *          all the bytes.\n     * @throws  IOException   if an I/O error occurs.\n     ",
    "links" : [ ]
  }, {
    "name" : " int skipBytes(int n) throws IOException",
    "returnType" : "int",
    "comment" : "\n     * Makes an attempt to skip over\n     * {@code n} bytes\n     * of data from the input\n     * stream, discarding the skipped bytes. However,\n     * it may skip\n     * over some smaller number of\n     * bytes, possibly zero. This may result from\n     * any of a\n     * number of conditions; reaching\n     * end of file before {@code n} bytes\n     * have been skipped is\n     * only one possibility.\n     * This method never throws an {@code EOFException}.\n     * The actual\n     * number of bytes skipped is returned.\n     *\n     * @param      n   the number of bytes to be skipped.\n     * @return     the number of bytes actually skipped.\n     * @exception  IOException   if an I/O error occurs.\n     ",
    "links" : [ ]
  }, {
    "name" : " boolean readBoolean() throws IOException",
    "returnType" : "boolean",
    "comment" : "\n     * Reads one input byte and returns\n     * {@code true} if that byte is nonzero,\n     * {@code false} if that byte is zero.\n     * This method is suitable for reading\n     * the byte written by the {@code writeBoolean}\n     * method of interface {@code DataOutput}.\n     *\n     * @return     the {@code boolean} value read.\n     * @exception  EOFException  if this stream reaches the end before reading\n     *               all the bytes.\n     * @exception  IOException   if an I/O error occurs.\n     ",
    "links" : [ ]
  }, {
    "name" : " byte readByte() throws IOException",
    "returnType" : "byte",
    "comment" : "\n     * Reads and returns one input byte.\n     * The byte is treated as a signed value in\n     * the range {@code -128} through {@code 127},\n     * inclusive.\n     * This method is suitable for\n     * reading the byte written by the {@code writeByte}\n     * method of interface {@code DataOutput}.\n     *\n     * @return     the 8-bit value read.\n     * @exception  EOFException  if this stream reaches the end before reading\n     *               all the bytes.\n     * @exception  IOException   if an I/O error occurs.\n     ",
    "links" : [ ]
  }, {
    "name" : " int readUnsignedByte() throws IOException",
    "returnType" : "int",
    "comment" : "\n     * Reads one input byte, zero-extends\n     * it to type {@code int}, and returns\n     * the result, which is therefore in the range\n     * {@code 0}\n     * through {@code 255}.\n     * This method is suitable for reading\n     * the byte written by the {@code writeByte}\n     * method of interface {@code DataOutput}\n     * if the argument to {@code writeByte}\n     * was intended to be a value in the range\n     * {@code 0} through {@code 255}.\n     *\n     * @return     the unsigned 8-bit value read.\n     * @exception  EOFException  if this stream reaches the end before reading\n     *               all the bytes.\n     * @exception  IOException   if an I/O error occurs.\n     ",
    "links" : [ ]
  }, {
    "name" : " short readShort() throws IOException",
    "returnType" : "short",
    "comment" : "\n     * Reads two input bytes and returns\n     * a {@code short} value. Let {@code a}\n     * be the first byte read and {@code b}\n     * be the second byte. The value\n     * returned\n     * is:\n     * <pre>{@code (short)((a << 8) | (b & 0xff))\n     * }</pre>\n     * This method\n     * is suitable for reading the bytes written\n     * by the {@code writeShort} method of\n     * interface {@code DataOutput}.\n     *\n     * @return     the 16-bit value read.\n     * @exception  EOFException  if this stream reaches the end before reading\n     *               all the bytes.\n     * @exception  IOException   if an I/O error occurs.\n     ",
    "links" : [ ]
  }, {
    "name" : " int readUnsignedShort() throws IOException",
    "returnType" : "int",
    "comment" : "\n     * Reads two input bytes and returns\n     * an {@code int} value in the range {@code 0}\n     * through {@code 65535}. Let {@code a}\n     * be the first byte read and\n     * {@code b}\n     * be the second byte. The value returned is:\n     * <pre>{@code (((a & 0xff) << 8) | (b & 0xff))\n     * }</pre>\n     * This method is suitable for reading the bytes\n     * written by the {@code writeShort} method\n     * of interface {@code DataOutput}  if\n     * the argument to {@code writeShort}\n     * was intended to be a value in the range\n     * {@code 0} through {@code 65535}.\n     *\n     * @return     the unsigned 16-bit value read.\n     * @exception  EOFException  if this stream reaches the end before reading\n     *               all the bytes.\n     * @exception  IOException   if an I/O error occurs.\n     ",
    "links" : [ ]
  }, {
    "name" : " char readChar() throws IOException",
    "returnType" : "char",
    "comment" : "\n     * Reads two input bytes and returns a {@code char} value.\n     * Let {@code a}\n     * be the first byte read and {@code b}\n     * be the second byte. The value\n     * returned is:\n     * <pre>{@code (char)((a << 8) | (b & 0xff))\n     * }</pre>\n     * This method\n     * is suitable for reading bytes written by\n     * the {@code writeChar} method of interface\n     * {@code DataOutput}.\n     *\n     * @return     the {@code char} value read.\n     * @exception  EOFException  if this stream reaches the end before reading\n     *               all the bytes.\n     * @exception  IOException   if an I/O error occurs.\n     ",
    "links" : [ ]
  }, {
    "name" : " int readInt() throws IOException",
    "returnType" : "int",
    "comment" : "\n     * Reads four input bytes and returns an\n     * {@code int} value. Let {@code a-d}\n     * be the first through fourth bytes read. The value returned is:\n     * <pre>{@code\n     * (((a & 0xff) << 24) | ((b & 0xff) << 16) |\n     *  ((c & 0xff) <<  8) | (d & 0xff))\n     * }</pre>\n     * This method is suitable\n     * for reading bytes written by the {@code writeInt}\n     * method of interface {@code DataOutput}.\n     *\n     * @return     the {@code int} value read.\n     * @exception  EOFException  if this stream reaches the end before reading\n     *               all the bytes.\n     * @exception  IOException   if an I/O error occurs.\n     ",
    "links" : [ ]
  }, {
    "name" : " long readLong() throws IOException",
    "returnType" : "long",
    "comment" : "\n     * Reads eight input bytes and returns\n     * a {@code long} value. Let {@code a-h}\n     * be the first through eighth bytes read.\n     * The value returned is:\n     * <pre>{@code\n     * (((long)(a & 0xff) << 56) |\n     *  ((long)(b & 0xff) << 48) |\n     *  ((long)(c & 0xff) << 40) |\n     *  ((long)(d & 0xff) << 32) |\n     *  ((long)(e & 0xff) << 24) |\n     *  ((long)(f & 0xff) << 16) |\n     *  ((long)(g & 0xff) <<  8) |\n     *  ((long)(h & 0xff)))\n     * }</pre>\n     * <p>\n     * This method is suitable\n     * for reading bytes written by the {@code writeLong}\n     * method of interface {@code DataOutput}.\n     *\n     * @return     the {@code long} value read.\n     * @exception  EOFException  if this stream reaches the end before reading\n     *               all the bytes.\n     * @exception  IOException   if an I/O error occurs.\n     ",
    "links" : [ ]
  }, {
    "name" : " float readFloat() throws IOException",
    "returnType" : "float",
    "comment" : "\n     * Reads four input bytes and returns\n     * a {@code float} value. It does this\n     * by first constructing an {@code int}\n     * value in exactly the manner\n     * of the {@code readInt}\n     * method, then converting this {@code int}\n     * value to a {@code float} in\n     * exactly the manner of the method {@code Float.intBitsToFloat}.\n     * This method is suitable for reading\n     * bytes written by the {@code writeFloat}\n     * method of interface {@code DataOutput}.\n     *\n     * @return     the {@code float} value read.\n     * @exception  EOFException  if this stream reaches the end before reading\n     *               all the bytes.\n     * @exception  IOException   if an I/O error occurs.\n     ",
    "links" : [ ]
  }, {
    "name" : " double readDouble() throws IOException",
    "returnType" : "double",
    "comment" : "\n     * Reads eight input bytes and returns\n     * a {@code double} value. It does this\n     * by first constructing a {@code long}\n     * value in exactly the manner\n     * of the {@code readLong}\n     * method, then converting this {@code long}\n     * value to a {@code double} in exactly\n     * the manner of the method {@code Double.longBitsToDouble}.\n     * This method is suitable for reading\n     * bytes written by the {@code writeDouble}\n     * method of interface {@code DataOutput}.\n     *\n     * @return     the {@code double} value read.\n     * @exception  EOFException  if this stream reaches the end before reading\n     *               all the bytes.\n     * @exception  IOException   if an I/O error occurs.\n     ",
    "links" : [ ]
  }, {
    "name" : " String readLine() throws IOException",
    "returnType" : "String",
    "comment" : "\n     * Reads the next line of text from the input stream.\n     * It reads successive bytes, converting\n     * each byte separately into a character,\n     * until it encounters a line terminator or\n     * end of\n     * file; the characters read are then\n     * returned as a {@code String}. Note\n     * that because this\n     * method processes bytes,\n     * it does not support input of the full Unicode\n     * character set.\n     * <p>\n     * If end of file is encountered\n     * before even one byte can be read, then {@code null}\n     * is returned. Otherwise, each byte that is\n     * read is converted to type {@code char}\n     * by zero-extension. If the character {@code '\\n'}\n     * is encountered, it is discarded and reading\n     * ceases. If the character {@code '\\r'}\n     * is encountered, it is discarded and, if\n     * the following byte converts &#32;to the\n     * character {@code '\\n'}, then that is\n     * discarded also; reading then ceases. If\n     * end of file is encountered before either\n     * of the characters {@code '\\n'} and\n     * {@code '\\r'} is encountered, reading\n     * ceases. Once reading has ceased, a {@code String}\n     * is returned that contains all the characters\n     * read and not discarded, taken in order.\n     * Note that every character in this string\n     * will have a value less than {@code \\u005Cu0100},\n     * that is, {@code (char)256}.\n     *\n     * @return the next line of text from the input stream,\n     *         or {@code null} if the end of file is\n     *         encountered before a byte can be read.\n     * @exception  IOException  if an I/O error occurs.\n     ",
    "links" : [ ]
  }, {
    "name" : " String readUTF() throws IOException",
    "returnType" : "String",
    "comment" : "\n     * Reads in a string that has been encoded using a\n     * <a href=\"#modified-utf-8\">modified UTF-8</a>\n     * format.\n     * The general contract of {@code readUTF}\n     * is that it reads a representation of a Unicode\n     * character string encoded in modified\n     * UTF-8 format; this string of characters\n     * is then returned as a {@code String}.\n     * <p>\n     * First, two bytes are read and used to\n     * construct an unsigned 16-bit integer in\n     * exactly the manner of the {@code readUnsignedShort}\n     * method . This integer value is called the\n     * <i>UTF length</i> and specifies the number\n     * of additional bytes to be read. These bytes\n     * are then converted to characters by considering\n     * them in groups. The length of each group\n     * is computed from the value of the first\n     * byte of the group. The byte following a\n     * group, if any, is the first byte of the\n     * next group.\n     * <p>\n     * If the first byte of a group\n     * matches the bit pattern {@code 0xxxxxxx}\n     * (where {@code x} means \"may be {@code 0}\n     * or {@code 1}\"), then the group consists\n     * of just that byte. The byte is zero-extended\n     * to form a character.\n     * <p>\n     * If the first byte\n     * of a group matches the bit pattern {@code 110xxxxx},\n     * then the group consists of that byte {@code a}\n     * and a second byte {@code b}. If there\n     * is no byte {@code b} (because byte\n     * {@code a} was the last of the bytes\n     * to be read), or if byte {@code b} does\n     * not match the bit pattern {@code 10xxxxxx},\n     * then a {@code UTFDataFormatException}\n     * is thrown. Otherwise, the group is converted\n     * to the character:\n     * <pre>{@code (char)(((a & 0x1F) << 6) | (b & 0x3F))\n     * }</pre>\n     * If the first byte of a group\n     * matches the bit pattern {@code 1110xxxx},\n     * then the group consists of that byte {@code a}\n     * and two more bytes {@code b} and {@code c}.\n     * If there is no byte {@code c} (because\n     * byte {@code a} was one of the last\n     * two of the bytes to be read), or either\n     * byte {@code b} or byte {@code c}\n     * does not match the bit pattern {@code 10xxxxxx},\n     * then a {@code UTFDataFormatException}\n     * is thrown. Otherwise, the group is converted\n     * to the character:\n     * <pre>{@code\n     * (char)(((a & 0x0F) << 12) | ((b & 0x3F) << 6) | (c & 0x3F))\n     * }</pre>\n     * If the first byte of a group matches the\n     * pattern {@code 1111xxxx} or the pattern\n     * {@code 10xxxxxx}, then a {@code UTFDataFormatException}\n     * is thrown.\n     * <p>\n     * If end of file is encountered\n     * at any time during this entire process,\n     * then an {@code EOFException} is thrown.\n     * <p>\n     * After every group has been converted to\n     * a character by this process, the characters\n     * are gathered, in the same order in which\n     * their corresponding groups were read from\n     * the input stream, to form a {@code String},\n     * which is returned.\n     * <p>\n     * The {@code writeUTF}\n     * method of interface {@code DataOutput}\n     * may be used to write data that is suitable\n     * for reading by this method.\n     * @return     a Unicode string.\n     * @exception  EOFException            if this stream reaches the end\n     *               before reading all the bytes.\n     * @exception  IOException             if an I/O error occurs.\n     * @exception  UTFDataFormatException  if the bytes do not represent a\n     *               valid modified UTF-8 encoding of a string.\n     ",
    "links" : [ ]
  } ],
  "methodNames" : [ " void readFully(byte[] b) throws IOException", " void readFully(byte[] b, int off, int len) throws IOException", " int skipBytes(int n) throws IOException", " boolean readBoolean() throws IOException", " byte readByte() throws IOException", " int readUnsignedByte() throws IOException", " short readShort() throws IOException", " int readUnsignedShort() throws IOException", " char readChar() throws IOException", " int readInt() throws IOException", " long readLong() throws IOException", " float readFloat() throws IOException", " double readDouble() throws IOException", " String readLine() throws IOException", " String readUTF() throws IOException" ],
  "variableNames" : [ ]
}