{
  "filePath" : "/home/maryam/clearblue/files/android-source-30/android/net/lowpan/LowpanInterface.java",
  "packageName" : "android.net.lowpan",
  "className" : "LowpanInterface",
  "comment" : " @SystemApi",
  "variables" : [ {
    "name" : "TAG",
    "type" : "String",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "ROLE_DETACHED",
    "type" : "String",
    "comment" : " Detached role. The interface is not currently attached to a network. ",
    "links" : [ ]
  }, {
    "name" : "ROLE_END_DEVICE",
    "type" : "String",
    "comment" : " End-device role. End devices do not route traffic for other nodes. ",
    "links" : [ ]
  }, {
    "name" : "ROLE_ROUTER",
    "type" : "String",
    "comment" : " Router role. Routers help route traffic around the mesh network. ",
    "links" : [ ]
  }, {
    "name" : "ROLE_SLEEPY_END_DEVICE",
    "type" : "String",
    "comment" : "\n     * Sleepy End-Device role.\n     *\n     * <p>End devices with this role are nominally asleep, waking up periodically to check in with\n     * their parent to see if there are packets destined for them. Such devices are capable of\n     * extraordinarilly low power consumption, but packet latency can be on the order of dozens of\n     * seconds(depending on how the node is configured).\n     ",
    "links" : [ ]
  }, {
    "name" : "ROLE_SLEEPY_ROUTER",
    "type" : "String",
    "comment" : "\n     * Sleepy-router role.\n     *\n     * <p>Routers with this role are nominally asleep, waking up periodically to check in with other\n     * routers and their children.\n     ",
    "links" : [ ]
  }, {
    "name" : "ROLE_LEADER",
    "type" : "String",
    "comment" : " TODO: doc ",
    "links" : [ ]
  }, {
    "name" : "ROLE_COORDINATOR",
    "type" : "String",
    "comment" : " TODO: doc ",
    "links" : [ ]
  }, {
    "name" : "STATE_OFFLINE",
    "type" : "String",
    "comment" : "\n     * Offline state.\n     *\n     * <p>This is the initial state of the LoWPAN interface when the underlying driver starts. In\n     * this state the NCP is idle and not connected to any network.\n     *\n     * <p>This state can be explicitly entered by calling {@link #reset()}, {@link #leave()}, or\n     * <code>setUp(false)</code>, with the later two only working if we were not previously in the\n     * {@link #STATE_FAULT} state.\n     *\n     * @see #getState()\n     * @see #STATE_FAULT\n     ",
    "links" : [ "#reset()", "#leave()", "#STATE_FAULT" ]
  }, {
    "name" : "STATE_COMMISSIONING",
    "type" : "String",
    "comment" : "\n     * Commissioning state.\n     *\n     * <p>The interface enters this state after a call to {@link #startCommissioningSession()}. This\n     * state may only be entered directly from the {@link #STATE_OFFLINE} state.\n     *\n     * @see #startCommissioningSession()\n     * @see #getState()\n     * @hide\n     ",
    "links" : [ "#STATE_OFFLINE", "#startCommissioningSession()" ]
  }, {
    "name" : "STATE_ATTACHING",
    "type" : "String",
    "comment" : "\n     * Attaching state.\n     *\n     * <p>The interface enters this state when it starts the process of trying to find other nodes\n     * so that it can attach to any pre-existing network fragment, or when it is in the process of\n     * calculating the optimal values for unspecified parameters when forming a new network.\n     *\n     * <p>The interface may stay in this state for a prolonged period of time (or may spontaneously\n     * enter this state from {@link #STATE_ATTACHED}) if the underlying network technology is\n     * heirarchical (like ZigBeeIP) or if the device role is that of an \"end-device\" ({@link\n     * #ROLE_END_DEVICE} or {@link #ROLE_SLEEPY_END_DEVICE}). This is because such roles cannot\n     * create their own network fragments.\n     *\n     * @see #STATE_ATTACHED\n     * @see #getState()\n     ",
    "links" : [ "#ROLE_END_DEVICE", "#STATE_ATTACHED", "#ROLE_SLEEPY_END_DEVICE" ]
  }, {
    "name" : "STATE_ATTACHED",
    "type" : "String",
    "comment" : "\n     * Attached state.\n     *\n     * <p>The interface enters this state from {@link #STATE_ATTACHING} once it is actively\n     * participating on a network fragment.\n     *\n     * @see #STATE_ATTACHING\n     * @see #getState()\n     ",
    "links" : [ "#STATE_ATTACHING" ]
  }, {
    "name" : "STATE_FAULT",
    "type" : "String",
    "comment" : "\n     * Fault state.\n     *\n     * <p>The interface will enter this state when the driver has detected some sort of problem from\n     * which it was not immediately able to recover.\n     *\n     * <p>This state can be entered spontaneously from any other state. Calling {@link #reset} will\n     * cause the device to return to the {@link #STATE_OFFLINE} state.\n     *\n     * @see #getState\n     * @see #STATE_OFFLINE\n     ",
    "links" : [ "#reset", "#STATE_OFFLINE" ]
  }, {
    "name" : "NETWORK_TYPE_THREAD_V1",
    "type" : "String",
    "comment" : "\n     * Network type for Thread 1.x networks.\n     *\n     * @see android.net.lowpan.LowpanIdentity#getType\n     * @see #getLowpanIdentity\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "EMPTY_PARTITION_ID",
    "type" : "String",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mBinder",
    "type" : "ILowpanInterface",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mLooper",
    "type" : "Looper",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mListenerMap",
    "type" : "HashMap<Integer, ILowpanInterfaceListener>",
    "comment" : "",
    "links" : [ ]
  } ],
  "methods" : [ {
    "name" : "public ILowpanInterface getService()",
    "returnType" : "ILowpanInterface",
    "comment" : "\n     * Returns the ILowpanInterface object associated with this interface.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public void form(@NonNull LowpanProvision provision) throws LowpanException",
    "returnType" : "void",
    "comment" : "\n     * Form a new network with the given network information optional credential. Unspecified fields\n     * in the network information will be filled in with reasonable values. If the network\n     * credential is unspecified, one will be generated automatically.\n     *\n     * <p>This method will block until either the network was successfully formed or an error\n     * prevents the network form being formed.\n     *\n     * <p>Upon success, the interface will be up and attached to the newly formed network.\n     *\n     * @see #join(LowpanProvision)\n     ",
    "links" : [ ]
  }, {
    "name" : "public void join(@NonNull LowpanProvision provision) throws LowpanException",
    "returnType" : "void",
    "comment" : "\n     * Attempts to join a new network with the given network information. This method will block\n     * until either the network was successfully joined or an error prevented the network from being\n     * formed. Upon success, the interface will be up and attached to the newly joined network.\n     *\n     * <p>Note that “joining” is distinct from “attaching”: Joining requires at least one other peer\n     * device to be present in order for the operation to complete successfully.\n     ",
    "links" : [ ]
  }, {
    "name" : "public void attach(@NonNull LowpanProvision provision) throws LowpanException",
    "returnType" : "void",
    "comment" : "\n     * Attaches to the network described by identity and credential. This is similar to {@link\n     * #join}, except that (assuming the identity and credential are valid) it will always succeed\n     * and provision the interface, even if there are no peers nearby.\n     *\n     * <p>This method will block execution until the operation has completed.\n     ",
    "links" : [ "#join" ]
  }, {
    "name" : "public void leave() throws LowpanException",
    "returnType" : "void",
    "comment" : "\n     * Bring down the network interface and forget all non-volatile details about the current\n     * network.\n     *\n     * <p>This method will block execution until the operation has completed.\n     ",
    "links" : [ ]
  }, {
    "name" : "public LowpanCommissioningSession startCommissioningSession(@NonNull LowpanBeaconInfo beaconInfo) throws LowpanException",
    "returnType" : "LowpanCommissioningSession",
    "comment" : "\n     * Start a new commissioning session. Will fail if the interface is attached to a network or if\n     * the interface is disabled.\n     ",
    "links" : [ ]
  }, {
    "name" : "public void reset() throws LowpanException",
    "returnType" : "void",
    "comment" : "\n     * Reset this network interface as if it has been power cycled. Will bring the network interface\n     * down if it was previously up. Will not erase any non-volatile settings.\n     *\n     * <p>This method will block execution until the operation has completed.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public String getName()",
    "returnType" : "String",
    "comment" : " Returns the name of this network interface. ",
    "links" : [ ]
  }, {
    "name" : "public boolean isEnabled()",
    "returnType" : "boolean",
    "comment" : "\n     * Indicates if the interface is enabled or disabled.\n     *\n     * @see #setEnabled\n     * @see android.net.lowpan.LowpanException#LOWPAN_DISABLED\n     ",
    "links" : [ ]
  }, {
    "name" : "public void setEnabled(boolean enabled) throws LowpanException",
    "returnType" : "void",
    "comment" : "\n     * Enables or disables the LoWPAN interface. When disabled, the interface is put into a\n     * low-power state and all commands that require the NCP to be queried will fail with {@link\n     * android.net.lowpan.LowpanException#LOWPAN_DISABLED}.\n     *\n     * @see #isEnabled\n     * @see android.net.lowpan.LowpanException#LOWPAN_DISABLED\n     * @hide\n     ",
    "links" : [ "android.net.lowpan.LowpanException#LOWPAN_DISABLED" ]
  }, {
    "name" : "public boolean isUp()",
    "returnType" : "boolean",
    "comment" : "\n     * Indicates if the network interface is up or down.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean isConnected()",
    "returnType" : "boolean",
    "comment" : "\n     * Indicates if there is at least one peer in range.\n     *\n     * @return <code>true</code> if we have at least one other peer in range, <code>false</code>\n     *     otherwise.\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean isCommissioned()",
    "returnType" : "boolean",
    "comment" : "\n     * Indicates if this interface is currently commissioned onto an existing network. If the\n     * interface is commissioned, the interface may be brought up using setUp().\n     ",
    "links" : [ ]
  }, {
    "name" : "public String getState()",
    "returnType" : "String",
    "comment" : "\n     * Get interface state\n     *\n     * <h3>State Diagram</h3>\n     *\n     * <img src=\"LowpanInterface-1.png\" />\n     *\n     * @return The current state of the interface.\n     * @see #STATE_OFFLINE\n     * @see #STATE_COMMISSIONING\n     * @see #STATE_ATTACHING\n     * @see #STATE_ATTACHED\n     * @see #STATE_FAULT\n     ",
    "links" : [ ]
  }, {
    "name" : "public String getPartitionId()",
    "returnType" : "String",
    "comment" : " Get network partition/fragment identifier. ",
    "links" : [ ]
  }, {
    "name" : "public LowpanIdentity getLowpanIdentity()",
    "returnType" : "LowpanIdentity",
    "comment" : " TODO: doc ",
    "links" : [ ]
  }, {
    "name" : "public String getRole()",
    "returnType" : "String",
    "comment" : " TODO: doc ",
    "links" : [ ]
  }, {
    "name" : "public LowpanCredential getLowpanCredential()",
    "returnType" : "LowpanCredential",
    "comment" : " TODO: doc ",
    "links" : [ ]
  }, {
    "name" : "public String[] getSupportedNetworkTypes() throws LowpanException",
    "returnType" : "String[]",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public LowpanChannelInfo[] getSupportedChannels() throws LowpanException",
    "returnType" : "LowpanChannelInfo[]",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public void registerCallback(@NonNull Callback cb, @Nullable Handler handler)",
    "returnType" : "void",
    "comment" : "\n     * Registers a subclass of {@link LowpanInterface.Callback} to receive events.\n     *\n     * @param cb Subclass of {@link LowpanInterface.Callback} which will receive events.\n     * @param handler If not <code>null</code>, events will be dispatched via the given handler\n     *     object. If <code>null</code>, the thread upon which events will be dispatched is\n     *     unspecified.\n     * @see #registerCallback(Callback)\n     * @see #unregisterCallback(Callback)\n     ",
    "links" : [ "LowpanInterface.Callback" ]
  }, {
    "name" : "public void registerCallback(Callback cb)",
    "returnType" : "void",
    "comment" : "\n     * Registers a subclass of {@link LowpanInterface.Callback} to receive events.\n     *\n     * <p>The thread upon which events will be dispatched is unspecified.\n     *\n     * @param cb Subclass of {@link LowpanInterface.Callback} which will receive events.\n     * @see #registerCallback(Callback, Handler)\n     * @see #unregisterCallback(Callback)\n     ",
    "links" : [ "LowpanInterface.Callback" ]
  }, {
    "name" : "public void unregisterCallback(Callback cb)",
    "returnType" : "void",
    "comment" : "\n     * Unregisters a previously registered callback class.\n     *\n     * @param cb Subclass of {@link LowpanInterface.Callback} which was previously registered to\n     *     receive events.\n     * @see #registerCallback(Callback, Handler)\n     * @see #registerCallback(Callback)\n     ",
    "links" : [ "LowpanInterface.Callback" ]
  }, {
    "name" : "public LowpanScanner createScanner()",
    "returnType" : "LowpanScanner",
    "comment" : "\n     * Creates a new {@link android.net.lowpan.LowpanScanner} object for this interface.\n     *\n     * <p>This method allocates a new unique object for each call.\n     *\n     * @see android.net.lowpan.LowpanScanner\n     ",
    "links" : [ "android.net.lowpan.LowpanScanner" ]
  }, {
    "name" : "public LinkAddress[] getLinkAddresses() throws LowpanException",
    "returnType" : "LinkAddress[]",
    "comment" : "\n     * Makes a copy of the internal list of LinkAddresses.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public IpPrefix[] getLinkNetworks() throws LowpanException",
    "returnType" : "IpPrefix[]",
    "comment" : "\n     * Makes a copy of the internal list of networks reachable on via this link.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public void addOnMeshPrefix(IpPrefix prefix, int flags) throws LowpanException",
    "returnType" : "void",
    "comment" : "\n     * Advertise the given IP prefix as an on-mesh prefix.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public void removeOnMeshPrefix(IpPrefix prefix)",
    "returnType" : "void",
    "comment" : "\n     * Remove an IP prefix previously advertised by this device from the list of advertised on-mesh\n     * prefixes.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public void addExternalRoute(IpPrefix prefix, int flags) throws LowpanException",
    "returnType" : "void",
    "comment" : "\n     * Advertise this device to other devices on the mesh network as having a specific route to the\n     * given network. This device will then receive forwarded traffic for that network.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public void removeExternalRoute(IpPrefix prefix)",
    "returnType" : "void",
    "comment" : "\n     * Revoke a previously advertised specific route to the given network.\n     *\n     * @hide\n     ",
    "links" : [ ]
  } ],
  "variableNames" : [ "TAG", "ROLE_DETACHED", "ROLE_END_DEVICE", "ROLE_ROUTER", "ROLE_SLEEPY_END_DEVICE", "ROLE_SLEEPY_ROUTER", "ROLE_LEADER", "ROLE_COORDINATOR", "STATE_OFFLINE", "STATE_COMMISSIONING", "STATE_ATTACHING", "STATE_ATTACHED", "STATE_FAULT", "NETWORK_TYPE_THREAD_V1", "EMPTY_PARTITION_ID", "mBinder", "mLooper", "mListenerMap" ],
  "methodNames" : [ "public ILowpanInterface getService()", "public void form(@NonNull LowpanProvision provision) throws LowpanException", "public void join(@NonNull LowpanProvision provision) throws LowpanException", "public void attach(@NonNull LowpanProvision provision) throws LowpanException", "public void leave() throws LowpanException", "public LowpanCommissioningSession startCommissioningSession(@NonNull LowpanBeaconInfo beaconInfo) throws LowpanException", "public void reset() throws LowpanException", "public String getName()", "public boolean isEnabled()", "public void setEnabled(boolean enabled) throws LowpanException", "public boolean isUp()", "public boolean isConnected()", "public boolean isCommissioned()", "public String getState()", "public String getPartitionId()", "public LowpanIdentity getLowpanIdentity()", "public String getRole()", "public LowpanCredential getLowpanCredential()", "public String[] getSupportedNetworkTypes() throws LowpanException", "public LowpanChannelInfo[] getSupportedChannels() throws LowpanException", "public void registerCallback(@NonNull Callback cb, @Nullable Handler handler)", "public void registerCallback(Callback cb)", "public void unregisterCallback(Callback cb)", "public LowpanScanner createScanner()", "public LinkAddress[] getLinkAddresses() throws LowpanException", "public IpPrefix[] getLinkNetworks() throws LowpanException", "public void addOnMeshPrefix(IpPrefix prefix, int flags) throws LowpanException", "public void removeOnMeshPrefix(IpPrefix prefix)", "public void addExternalRoute(IpPrefix prefix, int flags) throws LowpanException", "public void removeExternalRoute(IpPrefix prefix)" ]
}