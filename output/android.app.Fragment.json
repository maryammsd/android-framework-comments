{
  "filePath" : "/home/maryam/clearblue/files/android-source-30/android/app/Fragment.java",
  "packageName" : "android.app",
  "className" : "Fragment",
  "comment" : "\n * A Fragment is a piece of an application's user interface or behavior\n * that can be placed in an {@link Activity}.  Interaction with fragments\n * is done through {@link FragmentManager}, which can be obtained via\n * {@link Activity#getFragmentManager() Activity.getFragmentManager()} and\n * {@link Fragment#getFragmentManager() Fragment.getFragmentManager()}.\n *\n * <p>The Fragment class can be used many ways to achieve a wide variety of\n * results. In its core, it represents a particular operation or interface\n * that is running within a larger {@link Activity}.  A Fragment is closely\n * tied to the Activity it is in, and can not be used apart from one.  Though\n * Fragment defines its own lifecycle, that lifecycle is dependent on its\n * activity: if the activity is stopped, no fragments inside of it can be\n * started; when the activity is destroyed, all fragments will be destroyed.\n *\n * <p>All subclasses of Fragment must include a public no-argument constructor.\n * The framework will often re-instantiate a fragment class when needed,\n * in particular during state restore, and needs to be able to find this\n * constructor to instantiate it.  If the no-argument constructor is not\n * available, a runtime exception will occur in some cases during state\n * restore.\n *\n * <p>Topics covered here:\n * <ol>\n * <li><a href=\"#OlderPlatforms\">Older Platforms</a>\n * <li><a href=\"#Lifecycle\">Lifecycle</a>\n * <li><a href=\"#Layout\">Layout</a>\n * <li><a href=\"#BackStack\">Back Stack</a>\n * </ol>\n *\n * <div class=\"special reference\">\n * <h3>Developer Guides</h3>\n * <p>For more information about using fragments, read the\n * <a href=\"{@docRoot}guide/components/fragments.html\">Fragments</a> developer guide.</p>\n * </div>\n *\n * <a name=\"OlderPlatforms\"></a>\n * <h3>Older Platforms</h3>\n *\n * While the Fragment API was introduced in\n * {@link android.os.Build.VERSION_CODES#HONEYCOMB}, a version of the API\n * at is also available for use on older platforms through\n * {@link android.support.v4.app.FragmentActivity}.  See the blog post\n * <a href=\"http://android-developers.blogspot.com/2011/03/fragments-for-all.html\">\n * Fragments For All</a> for more details.\n *\n * <a name=\"Lifecycle\"></a>\n * <h3>Lifecycle</h3>\n *\n * <p>Though a Fragment's lifecycle is tied to its owning activity, it has\n * its own wrinkle on the standard activity lifecycle.  It includes basic\n * activity lifecycle methods such as {@link #onResume}, but also important\n * are methods related to interactions with the activity and UI generation.\n *\n * <p>The core series of lifecycle methods that are called to bring a fragment\n * up to resumed state (interacting with the user) are:\n *\n * <ol>\n * <li> {@link #onAttach} called once the fragment is associated with its activity.\n * <li> {@link #onCreate} called to do initial creation of the fragment.\n * <li> {@link #onCreateView} creates and returns the view hierarchy associated\n * with the fragment.\n * <li> {@link #onActivityCreated} tells the fragment that its activity has\n * completed its own {@link Activity#onCreate Activity.onCreate()}.\n * <li> {@link #onViewStateRestored} tells the fragment that all of the saved\n * state of its view hierarchy has been restored.\n * <li> {@link #onStart} makes the fragment visible to the user (based on its\n * containing activity being started).\n * <li> {@link #onResume} makes the fragment begin interacting with the user\n * (based on its containing activity being resumed).\n * </ol>\n *\n * <p>As a fragment is no longer being used, it goes through a reverse\n * series of callbacks:\n *\n * <ol>\n * <li> {@link #onPause} fragment is no longer interacting with the user either\n * because its activity is being paused or a fragment operation is modifying it\n * in the activity.\n * <li> {@link #onStop} fragment is no longer visible to the user either\n * because its activity is being stopped or a fragment operation is modifying it\n * in the activity.\n * <li> {@link #onDestroyView} allows the fragment to clean up resources\n * associated with its View.\n * <li> {@link #onDestroy} called to do final cleanup of the fragment's state.\n * <li> {@link #onDetach} called immediately prior to the fragment no longer\n * being associated with its activity.\n * </ol>\n *\n * <a name=\"Layout\"></a>\n * <h3>Layout</h3>\n *\n * <p>Fragments can be used as part of your application's layout, allowing\n * you to better modularize your code and more easily adjust your user\n * interface to the screen it is running on.  As an example, we can look\n * at a simple program consisting of a list of items, and display of the\n * details of each item.</p>\n *\n * <p>An activity's layout XML can include <code>&lt;fragment&gt;</code> tags\n * to embed fragment instances inside of the layout.  For example, here is\n * a simple layout that embeds one fragment:</p>\n *\n * {@sample development/samples/ApiDemos/res/layout/fragment_layout.xml layout}\n *\n * <p>The layout is installed in the activity in the normal way:</p>\n *\n * {@sample development/samples/ApiDemos/src/com/example/android/apis/app/FragmentLayout.java\n *      main}\n *\n * <p>The titles fragment, showing a list of titles, is fairly simple, relying\n * on {@link ListFragment} for most of its work.  Note the implementation of\n * clicking an item: depending on the current activity's layout, it can either\n * create and display a new fragment to show the details in-place (more about\n * this later), or start a new activity to show the details.</p>\n *\n * {@sample development/samples/ApiDemos/src/com/example/android/apis/app/FragmentLayout.java\n *      titles}\n *\n * <p>The details fragment showing the contents of a selected item just\n * displays a string of text based on an index of a string array built in to\n * the app:</p>\n *\n * {@sample development/samples/ApiDemos/src/com/example/android/apis/app/FragmentLayout.java\n *      details}\n *\n * <p>In this case when the user clicks on a title, there is no details\n * container in the current activity, so the titles fragment's click code will\n * launch a new activity to display the details fragment:</p>\n *\n * {@sample development/samples/ApiDemos/src/com/example/android/apis/app/FragmentLayout.java\n *      details_activity}\n *\n * <p>However the screen may be large enough to show both the list of titles\n * and details about the currently selected title.  To use such a layout on\n * a landscape screen, this alternative layout can be placed under layout-land:</p>\n *\n * {@sample development/samples/ApiDemos/res/layout-land/fragment_layout.xml layout}\n *\n * <p>Note how the prior code will adjust to this alternative UI flow: the titles\n * fragment will now embed the details fragment inside of this activity, and the\n * details activity will finish itself if it is running in a configuration\n * where the details can be shown in-place.\n *\n * <p>When a configuration change causes the activity hosting these fragments\n * to restart, its new instance may use a different layout that doesn't\n * include the same fragments as the previous layout.  In this case all of\n * the previous fragments will still be instantiated and running in the new\n * instance.  However, any that are no longer associated with a &lt;fragment&gt;\n * tag in the view hierarchy will not have their content view created\n * and will return false from {@link #isInLayout}.  (The code here also shows\n * how you can determine if a fragment placed in a container is no longer\n * running in a layout with that container and avoid creating its view hierarchy\n * in that case.)\n *\n * <p>The attributes of the &lt;fragment&gt; tag are used to control the\n * LayoutParams provided when attaching the fragment's view to the parent\n * container.  They can also be parsed by the fragment in {@link #onInflate}\n * as parameters.\n *\n * <p>The fragment being instantiated must have some kind of unique identifier\n * so that it can be re-associated with a previous instance if the parent\n * activity needs to be destroyed and recreated.  This can be provided these\n * ways:\n *\n * <ul>\n * <li>If nothing is explicitly supplied, the view ID of the container will\n * be used.\n * <li><code>android:tag</code> can be used in &lt;fragment&gt; to provide\n * a specific tag name for the fragment.\n * <li><code>android:id</code> can be used in &lt;fragment&gt; to provide\n * a specific identifier for the fragment.\n * </ul>\n *\n * <a name=\"BackStack\"></a>\n * <h3>Back Stack</h3>\n *\n * <p>The transaction in which fragments are modified can be placed on an\n * internal back-stack of the owning activity.  When the user presses back\n * in the activity, any transactions on the back stack are popped off before\n * the activity itself is finished.\n *\n * <p>For example, consider this simple fragment that is instantiated with\n * an integer argument and displays that in a TextView in its UI:</p>\n *\n * {@sample development/samples/ApiDemos/src/com/example/android/apis/app/FragmentStack.java\n *      fragment}\n *\n * <p>A function that creates a new instance of the fragment, replacing\n * whatever current fragment instance is being shown and pushing that change\n * on to the back stack could be written as:\n *\n * {@sample development/samples/ApiDemos/src/com/example/android/apis/app/FragmentStack.java\n *      add_stack}\n *\n * <p>After each call to this function, a new entry is on the stack, and\n * pressing back will pop it to return the user to whatever previous state\n * the activity UI was in.\n *\n * @deprecated Use the <a href=\"{@docRoot}tools/extras/support-library.html\">Support Library</a>\n *      {@link android.support.v4.app.Fragment} for consistent behavior across all devices\n *      and access to <a href=\"{@docRoot}topic/libraries/architecture/lifecycle.html\">Lifecycle</a>.\n ",
  "variables" : [ {
    "name" : "sClassMap",
    "type" : "ArrayMap<String, Class<?>>",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "INVALID_STATE",
    "type" : "int",
    "comment" : " Invalid state used as a null value.",
    "links" : [ ]
  }, {
    "name" : "INITIALIZING",
    "type" : "int",
    "comment" : " Not yet created.",
    "links" : [ ]
  }, {
    "name" : "CREATED",
    "type" : "int",
    "comment" : " Created.",
    "links" : [ ]
  }, {
    "name" : "ACTIVITY_CREATED",
    "type" : "int",
    "comment" : " The activity has finished its creation.",
    "links" : [ ]
  }, {
    "name" : "STOPPED",
    "type" : "int",
    "comment" : " Fully created, not started.",
    "links" : [ ]
  }, {
    "name" : "STARTED",
    "type" : "int",
    "comment" : " Created and started, not resumed.",
    "links" : [ ]
  }, {
    "name" : "RESUMED",
    "type" : "int",
    "comment" : " Created started and resumed.",
    "links" : [ ]
  }, {
    "name" : "USE_DEFAULT_TRANSITION",
    "type" : "Transition",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mState",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mSavedFragmentState",
    "type" : "Bundle",
    "comment" : " When instantiated from saved state, this is the saved state.",
    "links" : [ ]
  }, {
    "name" : "mSavedViewState",
    "type" : "SparseArray<Parcelable>",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mIndex",
    "type" : "int",
    "comment" : " Index into active fragment array.",
    "links" : [ ]
  }, {
    "name" : "mWho",
    "type" : "String",
    "comment" : " Internal unique name for this fragment;",
    "links" : [ ]
  }, {
    "name" : "mArguments",
    "type" : "Bundle",
    "comment" : " Construction arguments;",
    "links" : [ ]
  }, {
    "name" : "mTarget",
    "type" : "Fragment",
    "comment" : " Target fragment.",
    "links" : [ ]
  }, {
    "name" : "mTargetIndex",
    "type" : "int",
    "comment" : " For use when retaining a fragment: this is the index of the last mTarget.",
    "links" : [ ]
  }, {
    "name" : "mTargetRequestCode",
    "type" : "int",
    "comment" : " Target request code.",
    "links" : [ ]
  }, {
    "name" : "mAdded",
    "type" : "boolean",
    "comment" : " True if the fragment is in the list of added fragments.",
    "links" : [ ]
  }, {
    "name" : "mRemoving",
    "type" : "boolean",
    "comment" : " If set this fragment is being removed from its activity.",
    "links" : [ ]
  }, {
    "name" : "mFromLayout",
    "type" : "boolean",
    "comment" : " Set to true if this fragment was instantiated from a layout file.",
    "links" : [ ]
  }, {
    "name" : "mInLayout",
    "type" : "boolean",
    "comment" : " Set to true when the view has actually been inflated in its layout.",
    "links" : [ ]
  }, {
    "name" : "mRestored",
    "type" : "boolean",
    "comment" : " True if this fragment has been restored from previously saved state.",
    "links" : [ ]
  }, {
    "name" : "mPerformedCreateView",
    "type" : "boolean",
    "comment" : " has not yet happened.",
    "links" : [ ]
  }, {
    "name" : "mBackStackNesting",
    "type" : "int",
    "comment" : " Number of active back stack entries this fragment is in.",
    "links" : [ ]
  }, {
    "name" : "mFragmentManager",
    "type" : "FragmentManagerImpl",
    "comment" : " from all transactions.",
    "links" : [ ]
  }, {
    "name" : "mHost",
    "type" : "FragmentHostCallback",
    "comment" : " Activity this fragment is attached to.",
    "links" : [ ]
  }, {
    "name" : "mChildFragmentManager",
    "type" : "FragmentManagerImpl",
    "comment" : " Private fragment manager for child fragments inside of this one.",
    "links" : [ ]
  }, {
    "name" : "mChildNonConfig",
    "type" : "FragmentManagerNonConfig",
    "comment" : " This state is set by FragmentState.instantiate and cleared in onCreate.",
    "links" : [ ]
  }, {
    "name" : "mParentFragment",
    "type" : "Fragment",
    "comment" : " If this Fragment is contained in another Fragment, this is that container.",
    "links" : [ ]
  }, {
    "name" : "mFragmentId",
    "type" : "int",
    "comment" : " layout.",
    "links" : [ ]
  }, {
    "name" : "mContainerId",
    "type" : "int",
    "comment" : " is the identifier of the parent container it is being added to.",
    "links" : [ ]
  }, {
    "name" : "mTag",
    "type" : "String",
    "comment" : " fragments that are not part of the layout.",
    "links" : [ ]
  }, {
    "name" : "mHidden",
    "type" : "boolean",
    "comment" : " from the user.",
    "links" : [ ]
  }, {
    "name" : "mDetached",
    "type" : "boolean",
    "comment" : " Set to true when the app has requested that this fragment be detached.",
    "links" : [ ]
  }, {
    "name" : "mRetainInstance",
    "type" : "boolean",
    "comment" : " configuration changes.",
    "links" : [ ]
  }, {
    "name" : "mRetaining",
    "type" : "boolean",
    "comment" : " If set this fragment is being retained across the current config change.",
    "links" : [ ]
  }, {
    "name" : "mHasMenu",
    "type" : "boolean",
    "comment" : " If set this fragment has menu items to contribute.",
    "links" : [ ]
  }, {
    "name" : "mMenuVisible",
    "type" : "boolean",
    "comment" : " Set to true to allow the fragment's menu to be shown.",
    "links" : [ ]
  }, {
    "name" : "mCalled",
    "type" : "boolean",
    "comment" : " Used to verify that subclasses call through to super class.",
    "links" : [ ]
  }, {
    "name" : "mContainer",
    "type" : "ViewGroup",
    "comment" : " The parent container of the fragment after dynamically added to UI.",
    "links" : [ ]
  }, {
    "name" : "mView",
    "type" : "View",
    "comment" : " The View generated for this fragment.",
    "links" : [ ]
  }, {
    "name" : "mDeferStart",
    "type" : "boolean",
    "comment" : " have been started and their loaders are finished.",
    "links" : [ ]
  }, {
    "name" : "mUserVisibleHint",
    "type" : "boolean",
    "comment" : " Hint provided by the app that this fragment is currently visible to the user.",
    "links" : [ ]
  }, {
    "name" : "mLoaderManager",
    "type" : "LoaderManagerImpl",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mLoadersStarted",
    "type" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mCheckedForLoaderManager",
    "type" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mAnimationInfo",
    "type" : "AnimationInfo",
    "comment" : " without Views.",
    "links" : [ ]
  }, {
    "name" : "mIsNewlyAdded",
    "type" : "boolean",
    "comment" : " animation for this fragment.",
    "links" : [ ]
  }, {
    "name" : "mHiddenChanged",
    "type" : "boolean",
    "comment" : " True if mHidden has been changed and the animation should be scheduled.",
    "links" : [ ]
  }, {
    "name" : "mLayoutInflater",
    "type" : "LayoutInflater",
    "comment" : " getLayoutInflater()",
    "links" : [ ]
  }, {
    "name" : "mIsCreated",
    "type" : "boolean",
    "comment" : " track it separately.",
    "links" : [ ]
  } ],
  "methods" : [ {
    "name" : "public static Fragment instantiate(Context context, String fname)",
    "returnType" : "Fragment",
    "comment" : "\n     * Like {@link #instantiate(Context, String, Bundle)} but with a null\n     * argument Bundle.\n     ",
    "links" : [ "#instantiate(Context" ]
  }, {
    "name" : "public static Fragment instantiate(Context context, String fname, @Nullable Bundle args)",
    "returnType" : "Fragment",
    "comment" : "\n     * Create a new instance of a Fragment with the given class name.  This is\n     * the same as calling its empty constructor.\n     *\n     * @param context The calling context being used to instantiate the fragment.\n     * This is currently just used to get its ClassLoader.\n     * @param fname The class name of the fragment to instantiate.\n     * @param args Bundle of arguments to supply to the fragment, which it\n     * can retrieve with {@link #getArguments()}.  May be null.\n     * @return Returns a new fragment instance.\n     * @throws InstantiationException If there is a failure in instantiating\n     * the given fragment class.  This is a runtime exception; it is not\n     * normally expected to happen.\n     ",
    "links" : [ "#getArguments()" ]
  }, {
    "name" : " final void restoreViewState(Bundle savedInstanceState)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : " final void setIndex(int index, Fragment parent)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : " final boolean isInBackStack()",
    "returnType" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public final boolean equals(Object o)",
    "returnType" : "boolean",
    "comment" : "\n     * Subclasses can not override equals().\n     ",
    "links" : [ ]
  }, {
    "name" : "public final int hashCode()",
    "returnType" : "int",
    "comment" : "\n     * Subclasses can not override hashCode().\n     ",
    "links" : [ ]
  }, {
    "name" : "public String toString()",
    "returnType" : "String",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public final int getId()",
    "returnType" : "int",
    "comment" : "\n     * Return the identifier this fragment is known by.  This is either\n     * the android:id value supplied in a layout or the container view ID\n     * supplied when adding the fragment.\n     ",
    "links" : [ ]
  }, {
    "name" : "public final String getTag()",
    "returnType" : "String",
    "comment" : "\n     * Get the tag name of the fragment, if specified.\n     ",
    "links" : [ ]
  }, {
    "name" : "public void setArguments(Bundle args)",
    "returnType" : "void",
    "comment" : "\n     * Supply the construction arguments for this fragment.\n     * The arguments supplied here will be retained across fragment destroy and\n     * creation.\n     *\n     * <p>This method cannot be called if the fragment is added to a FragmentManager and\n     * if {@link #isStateSaved()} would return true. Prior to {@link Build.VERSION_CODES#O},\n     * this method may only be called if the fragment has not yet been added to a FragmentManager.\n     * </p>\n     ",
    "links" : [ "Build.VERSION_CODES#O", "#isStateSaved()" ]
  }, {
    "name" : "public final Bundle getArguments()",
    "returnType" : "Bundle",
    "comment" : "\n     * Return the arguments supplied to {@link #setArguments}, if any.\n     ",
    "links" : [ "#setArguments" ]
  }, {
    "name" : "public final boolean isStateSaved()",
    "returnType" : "boolean",
    "comment" : "\n     * Returns true if this fragment is added and its state has already been saved\n     * by its host. Any operations that would change saved state should not be performed\n     * if this method returns true, and some operations such as {@link #setArguments(Bundle)}\n     * will fail.\n     *\n     * @return true if this fragment's state has already been saved by its host\n     ",
    "links" : [ "#setArguments(Bundle)" ]
  }, {
    "name" : "public void setInitialSavedState(SavedState state)",
    "returnType" : "void",
    "comment" : "\n     * Set the initial saved state that this Fragment should restore itself\n     * from when first being constructed, as returned by\n     * {@link FragmentManager#saveFragmentInstanceState(Fragment)\n     * FragmentManager.saveFragmentInstanceState}.\n     *\n     * @param state The state the fragment should be restored from.\n     ",
    "links" : [ "android.app.FragmentManager#saveFragmentInstanceState(Fragment)" ]
  }, {
    "name" : "public void setTargetFragment(Fragment fragment, int requestCode)",
    "returnType" : "void",
    "comment" : "\n     * Optional target for this fragment.  This may be used, for example,\n     * if this fragment is being started by another, and when done wants to\n     * give a result back to the first.  The target set here is retained\n     * across instances via {@link FragmentManager#putFragment\n     * FragmentManager.putFragment()}.\n     *\n     * @param fragment The fragment that is the target of this one.\n     * @param requestCode Optional request code, for convenience if you\n     * are going to call back with {@link #onActivityResult(int, int, Intent)}.\n     ",
    "links" : [ "#onActivityResult(int", "android.app.FragmentManager#putFragmentFragmentManager.putFragment()" ]
  }, {
    "name" : "public final Fragment getTargetFragment()",
    "returnType" : "Fragment",
    "comment" : "\n     * Return the target fragment set by {@link #setTargetFragment}.\n     ",
    "links" : [ "#setTargetFragment" ]
  }, {
    "name" : "public final int getTargetRequestCode()",
    "returnType" : "int",
    "comment" : "\n     * Return the target request code set by {@link #setTargetFragment}.\n     ",
    "links" : [ "#setTargetFragment" ]
  }, {
    "name" : "public Context getContext()",
    "returnType" : "Context",
    "comment" : "\n     * Return the {@link Context} this fragment is currently associated with.\n     ",
    "links" : [ "android.content.Context" ]
  }, {
    "name" : "public final Activity getActivity()",
    "returnType" : "Activity",
    "comment" : "\n     * Return the Activity this fragment is currently associated with.\n     ",
    "links" : [ ]
  }, {
    "name" : "public final Object getHost()",
    "returnType" : "Object",
    "comment" : "\n     * Return the host object of this fragment. May return {@code null} if the fragment\n     * isn't currently being hosted.\n     ",
    "links" : [ ]
  }, {
    "name" : "public final Resources getResources()",
    "returnType" : "Resources",
    "comment" : "\n     * Return <code>getActivity().getResources()</code>.\n     ",
    "links" : [ ]
  }, {
    "name" : "public final CharSequence getText(@StringRes int resId)",
    "returnType" : "CharSequence",
    "comment" : "\n     * Return a localized, styled CharSequence from the application's package's\n     * default string table.\n     *\n     * @param resId Resource id for the CharSequence text\n     ",
    "links" : [ ]
  }, {
    "name" : "public final String getString(@StringRes int resId)",
    "returnType" : "String",
    "comment" : "\n     * Return a localized string from the application's package's\n     * default string table.\n     *\n     * @param resId Resource id for the string\n     ",
    "links" : [ ]
  }, {
    "name" : "public final String getString(@StringRes int resId, Object... formatArgs)",
    "returnType" : "String",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public final FragmentManager getFragmentManager()",
    "returnType" : "FragmentManager",
    "comment" : "\n     * Return the FragmentManager for interacting with fragments associated\n     * with this fragment's activity.  Note that this will be non-null slightly\n     * before {@link #getActivity()}, during the time from when the fragment is\n     * placed in a {@link FragmentTransaction} until it is committed and\n     * attached to its activity.\n     *\n     * <p>If this Fragment is a child of another Fragment, the FragmentManager\n     * returned here will be the parent's {@link #getChildFragmentManager()}.\n     ",
    "links" : [ "#getChildFragmentManager()", "android.app.FragmentTransaction", "#getActivity()" ]
  }, {
    "name" : "public final FragmentManager getChildFragmentManager()",
    "returnType" : "FragmentManager",
    "comment" : "\n     * Return a private FragmentManager for placing and managing Fragments\n     * inside of this Fragment.\n     ",
    "links" : [ ]
  }, {
    "name" : "public final Fragment getParentFragment()",
    "returnType" : "Fragment",
    "comment" : "\n     * Returns the parent Fragment containing this Fragment.  If this Fragment\n     * is attached directly to an Activity, returns null.\n     ",
    "links" : [ ]
  }, {
    "name" : "public final boolean isAdded()",
    "returnType" : "boolean",
    "comment" : "\n     * Return true if the fragment is currently added to its activity.\n     ",
    "links" : [ ]
  }, {
    "name" : "public final boolean isDetached()",
    "returnType" : "boolean",
    "comment" : "\n     * Return true if the fragment has been explicitly detached from the UI.\n     * That is, {@link FragmentTransaction#detach(Fragment)\n     * FragmentTransaction.detach(Fragment)} has been used on it.\n     ",
    "links" : [ "android.app.FragmentTransaction#detach(Fragment)" ]
  }, {
    "name" : "public final boolean isRemoving()",
    "returnType" : "boolean",
    "comment" : "\n     * Return true if this fragment is currently being removed from its\n     * activity.  This is  <em>not</em> whether its activity is finishing, but\n     * rather whether it is in the process of being removed from its activity.\n     ",
    "links" : [ ]
  }, {
    "name" : "public final boolean isInLayout()",
    "returnType" : "boolean",
    "comment" : "\n     * Return true if the layout is included as part of an activity view\n     * hierarchy via the &lt;fragment&gt; tag.  This will always be true when\n     * fragments are created through the &lt;fragment&gt; tag, <em>except</em>\n     * in the case where an old fragment is restored from a previous state and\n     * it does not appear in the layout of the current state.\n     ",
    "links" : [ ]
  }, {
    "name" : "public final boolean isResumed()",
    "returnType" : "boolean",
    "comment" : "\n     * Return true if the fragment is in the resumed state.  This is true\n     * for the duration of {@link #onResume()} and {@link #onPause()} as well.\n     ",
    "links" : [ "#onPause()", "#onResume()" ]
  }, {
    "name" : "public final boolean isVisible()",
    "returnType" : "boolean",
    "comment" : "\n     * Return true if the fragment is currently visible to the user.  This means\n     * it: (1) has been added, (2) has its view attached to the window, and\n     * (3) is not hidden.\n     ",
    "links" : [ ]
  }, {
    "name" : "public final boolean isHidden()",
    "returnType" : "boolean",
    "comment" : "\n     * Return true if the fragment has been hidden.  By default fragments\n     * are shown.  You can find out about changes to this state with\n     * {@link #onHiddenChanged}.  Note that the hidden state is orthogonal\n     * to other states -- that is, to be visible to the user, a fragment\n     * must be both started and not hidden.\n     ",
    "links" : [ "#onHiddenChanged" ]
  }, {
    "name" : "public void onHiddenChanged(boolean hidden)",
    "returnType" : "void",
    "comment" : "\n     * Called when the hidden state (as returned by {@link #isHidden()} of\n     * the fragment has changed.  Fragments start out not hidden; this will\n     * be called whenever the fragment changes state from that.\n     * @param hidden True if the fragment is now hidden, false otherwise.\n     ",
    "links" : [ "#isHidden()" ]
  }, {
    "name" : "public void setRetainInstance(boolean retain)",
    "returnType" : "void",
    "comment" : "\n     * Control whether a fragment instance is retained across Activity\n     * re-creation (such as from a configuration change).  This can only\n     * be used with fragments not in the back stack.  If set, the fragment\n     * lifecycle will be slightly different when an activity is recreated:\n     * <ul>\n     * <li> {@link #onDestroy()} will not be called (but {@link #onDetach()} still\n     * will be, because the fragment is being detached from its current activity).\n     * <li> {@link #onCreate(Bundle)} will not be called since the fragment\n     * is not being re-created.\n     * <li> {@link #onAttach(Activity)} and {@link #onActivityCreated(Bundle)} <b>will</b>\n     * still be called.\n     * </ul>\n     ",
    "links" : [ "#onAttach(Activity)", "#onCreate(Bundle)", "#onDestroy()", "#onDetach()", "#onActivityCreated(Bundle)" ]
  }, {
    "name" : "public final boolean getRetainInstance()",
    "returnType" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public void setHasOptionsMenu(boolean hasMenu)",
    "returnType" : "void",
    "comment" : "\n     * Report that this fragment would like to participate in populating\n     * the options menu by receiving a call to {@link #onCreateOptionsMenu}\n     * and related methods.\n     *\n     * @param hasMenu If true, the fragment has menu items to contribute.\n     ",
    "links" : [ "#onCreateOptionsMenu" ]
  }, {
    "name" : "public void setMenuVisibility(boolean menuVisible)",
    "returnType" : "void",
    "comment" : "\n     * Set a hint for whether this fragment's menu should be visible.  This\n     * is useful if you know that a fragment has been placed in your view\n     * hierarchy so that the user can not currently seen it, so any menu items\n     * it has should also not be shown.\n     *\n     * @param menuVisible The default is true, meaning the fragment's menu will\n     * be shown as usual.  If false, the user will not see the menu.\n     ",
    "links" : [ ]
  }, {
    "name" : "public void setUserVisibleHint(boolean isVisibleToUser)",
    "returnType" : "void",
    "comment" : "\n     * Set a hint to the system about whether this fragment's UI is currently visible\n     * to the user. This hint defaults to true and is persistent across fragment instance\n     * state save and restore.\n     *\n     * <p>An app may set this to false to indicate that the fragment's UI is\n     * scrolled out of visibility or is otherwise not directly visible to the user.\n     * This may be used by the system to prioritize operations such as fragment lifecycle updates\n     * or loader ordering behavior.</p>\n     *\n     * <p><strong>Note:</strong> This method may be called outside of the fragment lifecycle\n     * and thus has no ordering guarantees with regard to fragment lifecycle method calls.</p>\n     *\n     * <p><strong>Note:</strong> Prior to Android N there was a platform bug that could cause\n     * <code>setUserVisibleHint</code> to bring a fragment up to the started state before its\n     * <code>FragmentTransaction</code> had been committed. As some apps relied on this behavior,\n     * it is preserved for apps that declare a <code>targetSdkVersion</code> of 23 or lower.</p>\n     *\n     * @param isVisibleToUser true if this fragment's UI is currently visible to the user (default),\n     *                        false if it is not.\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean getUserVisibleHint()",
    "returnType" : "boolean",
    "comment" : "\n     * @return The current value of the user-visible hint on this fragment.\n     * @see #setUserVisibleHint(boolean)\n     ",
    "links" : [ ]
  }, {
    "name" : "public LoaderManager getLoaderManager()",
    "returnType" : "LoaderManager",
    "comment" : "\n     * Return the LoaderManager for this fragment, creating it if needed.\n     *\n     * @deprecated Use {@link android.support.v4.app.Fragment#getLoaderManager()}\n     ",
    "links" : [ "android.support.v4.app.Fragment#getLoaderManager()" ]
  }, {
    "name" : "public void startActivity(Intent intent)",
    "returnType" : "void",
    "comment" : "\n     * Call {@link Activity#startActivity(Intent)} from the fragment's\n     * containing Activity.\n     *\n     * @param intent The intent to start.\n     ",
    "links" : [ "android.app.Activity#startActivity(Intent)" ]
  }, {
    "name" : "public void startActivity(Intent intent, Bundle options)",
    "returnType" : "void",
    "comment" : "\n     * Call {@link Activity#startActivity(Intent, Bundle)} from the fragment's\n     * containing Activity.\n     *\n     * @param intent The intent to start.\n     * @param options Additional options for how the Activity should be started.\n     * See {@link android.content.Context#startActivity(Intent, Bundle)}\n     * Context.startActivity(Intent, Bundle)} for more details.\n     ",
    "links" : [ "android.app.Activity#startActivity(Intent", "android.content.Context#startActivity(Intent" ]
  }, {
    "name" : "public void startActivityForResult(Intent intent, int requestCode)",
    "returnType" : "void",
    "comment" : "\n     * Call {@link Activity#startActivityForResult(Intent, int)} from the fragment's\n     * containing Activity.\n     ",
    "links" : [ "android.app.Activity#startActivityForResult(Intent" ]
  }, {
    "name" : "public void startActivityForResult(Intent intent, int requestCode, Bundle options)",
    "returnType" : "void",
    "comment" : "\n     * Call {@link Activity#startActivityForResult(Intent, int, Bundle)} from the fragment's\n     * containing Activity.\n     ",
    "links" : [ "android.app.Activity#startActivityForResult(Intent" ]
  }, {
    "name" : "public void startActivityForResultAsUser(Intent intent, int requestCode, Bundle options, UserHandle user)",
    "returnType" : "void",
    "comment" : "\n     * @hide\n     * Call {@link Activity#startActivityForResultAsUser(Intent, int, UserHandle)} from the\n     * fragment's containing Activity.\n     ",
    "links" : [ "android.app.Activity#startActivityForResultAsUser(Intent" ]
  }, {
    "name" : "public void startIntentSenderForResult(IntentSender intent, int requestCode, @Nullable Intent fillInIntent, int flagsMask, int flagsValues, int extraFlags, Bundle options) throws IntentSender.SendIntentException",
    "returnType" : "void",
    "comment" : "\n     * Call {@link Activity#startIntentSenderForResult(IntentSender, int, Intent, int, int, int,\n     * Bundle)} from the fragment's containing Activity.\n     ",
    "links" : [ "android.app.Activity#startIntentSenderForResult(IntentSender" ]
  }, {
    "name" : "public void onActivityResult(int requestCode, int resultCode, Intent data)",
    "returnType" : "void",
    "comment" : "\n     * Receive the result from a previous call to\n     * {@link #startActivityForResult(Intent, int)}.  This follows the\n     * related Activity API as described there in\n     * {@link Activity#onActivityResult(int, int, Intent)}.\n     *\n     * @param requestCode The integer request code originally supplied to\n     *                    startActivityForResult(), allowing you to identify who this\n     *                    result came from.\n     * @param resultCode The integer result code returned by the child activity\n     *                   through its setResult().\n     * @param data An Intent, which can return result data to the caller\n     *               (various data can be attached to Intent \"extras\").\n     ",
    "links" : [ "#startActivityForResult(Intent", "android.app.Activity#onActivityResult(int" ]
  }, {
    "name" : "public final void requestPermissions(@NonNull String[] permissions, int requestCode)",
    "returnType" : "void",
    "comment" : "\n     * Requests permissions to be granted to this application. These permissions\n     * must be requested in your manifest, they should not be granted to your app,\n     * and they should have protection level {@link android.content.pm.PermissionInfo\n     * #PROTECTION_DANGEROUS dangerous}, regardless whether they are declared by\n     * the platform or a third-party app.\n     * <p>\n     * Normal permissions {@link android.content.pm.PermissionInfo#PROTECTION_NORMAL}\n     * are granted at install time if requested in the manifest. Signature permissions\n     * {@link android.content.pm.PermissionInfo#PROTECTION_SIGNATURE} are granted at\n     * install time if requested in the manifest and the signature of your app matches\n     * the signature of the app declaring the permissions.\n     * </p>\n     * <p>\n     * Call {@link #shouldShowRequestPermissionRationale(String)} before calling this API\n     * to check if the system recommends to show a rationale UI before asking for a permission.\n     * </p>\n     * <p>\n     * If your app does not have the requested permissions the user will be presented\n     * with UI for accepting them. After the user has accepted or rejected the\n     * requested permissions you will receive a callback on {@link\n     * #onRequestPermissionsResult(int, String[], int[])} reporting whether the\n     * permissions were granted or not.\n     * </p>\n     * <p>\n     * Note that requesting a permission does not guarantee it will be granted and\n     * your app should be able to run without having this permission.\n     * </p>\n     * <p>\n     * This method may start an activity allowing the user to choose which permissions\n     * to grant and which to reject. Hence, you should be prepared that your activity\n     * may be paused and resumed. Further, granting some permissions may require\n     * a restart of you application. In such a case, the system will recreate the\n     * activity stack before delivering the result to {@link\n     * #onRequestPermissionsResult(int, String[], int[])}.\n     * </p>\n     * <p>\n     * When checking whether you have a permission you should use {@link\n     * android.content.Context#checkSelfPermission(String)}.\n     * </p>\n     * <p>\n     * Calling this API for permissions already granted to your app would show UI\n     * to the user to decide whether the app can still hold these permissions. This\n     * can be useful if the way your app uses data guarded by the permissions\n     * changes significantly.\n     * </p>\n     * <p>\n     * You cannot request a permission if your activity sets {@link\n     * android.R.styleable#AndroidManifestActivity_noHistory noHistory} to\n     * <code>true</code> because in this case the activity would not receive\n     * result callbacks including {@link #onRequestPermissionsResult(int, String[], int[])}.\n     * </p>\n     *\n     * @param permissions The requested permissions. Must me non-null and not empty.\n     * @param requestCode Application specific request code to match with a result\n     *    reported to {@link #onRequestPermissionsResult(int, String[], int[])}.\n     *    Should be >= 0.\n     *\n     * @see #onRequestPermissionsResult(int, String[], int[])\n     * @see android.content.Context#checkSelfPermission(String)\n     ",
    "links" : [ "android.content.pm.PermissionInfo#PROTECTION_SIGNATURE", "android.content.pm.PermissionInfo#PROTECTION_DANGEROUS", "android.R.styleable#AndroidManifestActivity_noHistory", "#shouldShowRequestPermissionRationale(String)", "android.content.pm.PermissionInfo#PROTECTION_NORMAL", "#onRequestPermissionsResult(int", "android.content.Context#checkSelfPermission(String)" ]
  }, {
    "name" : "public void onRequestPermissionsResult(int requestCode, @NonNull String[] permissions, @NonNull int[] grantResults)",
    "returnType" : "void",
    "comment" : "\n     * Callback for the result from requesting permissions. This method\n     * is invoked for every call on {@link #requestPermissions(String[], int)}.\n     * <p>\n     * <strong>Note:</strong> It is possible that the permissions request interaction\n     * with the user is interrupted. In this case you will receive empty permissions\n     * and results arrays which should be treated as a cancellation.\n     * </p>\n     *\n     * @param requestCode The request code passed in {@link #requestPermissions(String[], int)}.\n     * @param permissions The requested permissions. Never null.\n     * @param grantResults The grant results for the corresponding permissions\n     *     which is either {@link android.content.pm.PackageManager#PERMISSION_GRANTED}\n     *     or {@link android.content.pm.PackageManager#PERMISSION_DENIED}. Never null.\n     *\n     * @see #requestPermissions(String[], int)\n     ",
    "links" : [ "android.content.pm.PackageManager#PERMISSION_DENIED", "android.content.pm.PackageManager#PERMISSION_GRANTED", "#requestPermissions(String" ]
  }, {
    "name" : "public boolean shouldShowRequestPermissionRationale(@NonNull String permission)",
    "returnType" : "boolean",
    "comment" : "\n     * Gets whether you should show UI with rationale before requesting a permission.\n     *\n     * @param permission A permission your app wants to request.\n     * @return Whether you should show permission rationale UI.\n     *\n     * @see Context#checkSelfPermission(String)\n     * @see #requestPermissions(String[], int)\n     * @see #onRequestPermissionsResult(int, String[], int[])\n     ",
    "links" : [ ]
  }, {
    "name" : "public LayoutInflater onGetLayoutInflater(Bundle savedInstanceState)",
    "returnType" : "LayoutInflater",
    "comment" : "\n     * Returns the LayoutInflater used to inflate Views of this Fragment. The default\n     * implementation will throw an exception if the Fragment is not attached.\n     *\n     * @return The LayoutInflater used to inflate Views of this Fragment.\n     ",
    "links" : [ ]
  }, {
    "name" : "public final LayoutInflater getLayoutInflater()",
    "returnType" : "LayoutInflater",
    "comment" : "\n     * Returns the cached LayoutInflater used to inflate Views of this Fragment. If\n     * {@link #onGetLayoutInflater(Bundle)} has not been called {@link #onGetLayoutInflater(Bundle)}\n     * will be called with a {@code null} argument and that value will be cached.\n     * <p>\n     * The cached LayoutInflater will be replaced immediately prior to\n     * {@link #onCreateView(LayoutInflater, ViewGroup, Bundle)} and cleared immediately after\n     * {@link #onDetach()}.\n     *\n     * @return The LayoutInflater used to inflate Views of this Fragment.\n     ",
    "links" : [ "#onGetLayoutInflater(Bundle)", "#onDetach()", "#onCreateView(LayoutInflater" ]
  }, {
    "name" : " LayoutInflater performGetLayoutInflater(Bundle savedInstanceState)",
    "returnType" : "LayoutInflater",
    "comment" : "\n     * Calls {@link #onGetLayoutInflater(Bundle)} and caches the result for use by\n     * {@link #getLayoutInflater()}.\n     *\n     * @param savedInstanceState If the fragment is being re-created from\n     * a previous saved state, this is the state.\n     * @return The LayoutInflater used to inflate Views of this Fragment.\n     ",
    "links" : [ "#onGetLayoutInflater(Bundle)", "#getLayoutInflater()" ]
  }, {
    "name" : "public void onInflate(AttributeSet attrs, Bundle savedInstanceState)",
    "returnType" : "void",
    "comment" : "\n     * @deprecated Use {@link #onInflate(Context, AttributeSet, Bundle)} instead.\n     ",
    "links" : [ "#onInflate(Context" ]
  }, {
    "name" : "public void onInflate(Context context, AttributeSet attrs, Bundle savedInstanceState)",
    "returnType" : "void",
    "comment" : "\n     * Called when a fragment is being created as part of a view layout\n     * inflation, typically from setting the content view of an activity.  This\n     * may be called immediately after the fragment is created from a <fragment>\n     * tag in a layout file.  Note this is <em>before</em> the fragment's\n     * {@link #onAttach(Activity)} has been called; all you should do here is\n     * parse the attributes and save them away.\n     *\n     * <p>This is called every time the fragment is inflated, even if it is\n     * being inflated into a new instance with saved state.  It typically makes\n     * sense to re-parse the parameters each time, to allow them to change with\n     * different configurations.</p>\n     *\n     * <p>Here is a typical implementation of a fragment that can take parameters\n     * both through attributes supplied here as well from {@link #getArguments()}:</p>\n     *\n     * {@sample development/samples/ApiDemos/src/com/example/android/apis/app/FragmentArguments.java\n     *      fragment}\n     *\n     * <p>Note that parsing the XML attributes uses a \"styleable\" resource.  The\n     * declaration for the styleable used here is:</p>\n     *\n     * {@sample development/samples/ApiDemos/res/values/attrs.xml fragment_arguments}\n     *\n     * <p>The fragment can then be declared within its activity's content layout\n     * through a tag like this:</p>\n     *\n     * {@sample development/samples/ApiDemos/res/layout/fragment_arguments.xml from_attributes}\n     *\n     * <p>This fragment can also be created dynamically from arguments given\n     * at runtime in the arguments Bundle; here is an example of doing so at\n     * creation of the containing activity:</p>\n     *\n     * {@sample development/samples/ApiDemos/src/com/example/android/apis/app/FragmentArguments.java\n     *      create}\n     *\n     * @param context The Context that is inflating this fragment.\n     * @param attrs The attributes at the tag where the fragment is\n     * being created.\n     * @param savedInstanceState If the fragment is being re-created from\n     * a previous saved state, this is the state.\n     ",
    "links" : [ "#onAttach(Activity)", "#getArguments()" ]
  }, {
    "name" : "public void onInflate(Activity activity, AttributeSet attrs, Bundle savedInstanceState)",
    "returnType" : "void",
    "comment" : "\n     * @deprecated Use {@link #onInflate(Context, AttributeSet, Bundle)} instead.\n     ",
    "links" : [ "#onInflate(Context" ]
  }, {
    "name" : "public void onAttachFragment(Fragment childFragment)",
    "returnType" : "void",
    "comment" : "\n     * Called when a fragment is attached as a child of this fragment.\n     *\n     * <p>This is called after the attached fragment's <code>onAttach</code> and before\n     * the attached fragment's <code>onCreate</code> if the fragment has not yet had a previous\n     * call to <code>onCreate</code>.</p>\n     *\n     * @param childFragment child fragment being attached\n     ",
    "links" : [ ]
  }, {
    "name" : "public void onAttach(Context context)",
    "returnType" : "void",
    "comment" : "\n     * Called when a fragment is first attached to its context.\n     * {@link #onCreate(Bundle)} will be called after this.\n     ",
    "links" : [ "#onCreate(Bundle)" ]
  }, {
    "name" : "public void onAttach(Activity activity)",
    "returnType" : "void",
    "comment" : "\n     * @deprecated Use {@link #onAttach(Context)} instead.\n     ",
    "links" : [ "#onAttach(Context)" ]
  }, {
    "name" : "public Animator onCreateAnimator(int transit, boolean enter, int nextAnim)",
    "returnType" : "Animator",
    "comment" : "\n     * Called when a fragment loads an animation.\n     ",
    "links" : [ ]
  }, {
    "name" : "public void onCreate(@Nullable Bundle savedInstanceState)",
    "returnType" : "void",
    "comment" : "\n     * Called to do initial creation of a fragment.  This is called after\n     * {@link #onAttach(Activity)} and before\n     * {@link #onCreateView(LayoutInflater, ViewGroup, Bundle)}, but is not called if the fragment\n     * instance is retained across Activity re-creation (see {@link #setRetainInstance(boolean)}).\n     *\n     * <p>Note that this can be called while the fragment's activity is\n     * still in the process of being created.  As such, you can not rely\n     * on things like the activity's content view hierarchy being initialized\n     * at this point.  If you want to do work once the activity itself is\n     * created, see {@link #onActivityCreated(Bundle)}.\n     *\n     * <p>If your app's <code>targetSdkVersion</code> is {@link android.os.Build.VERSION_CODES#M}\n     * or lower, child fragments being restored from the savedInstanceState are restored after\n     * <code>onCreate</code> returns. When targeting {@link android.os.Build.VERSION_CODES#N} or\n     * above and running on an N or newer platform version\n     * they are restored by <code>Fragment.onCreate</code>.</p>\n     *\n     * @param savedInstanceState If the fragment is being re-created from\n     * a previous saved state, this is the state.\n     ",
    "links" : [ "#onAttach(Activity)", "#setRetainInstance(boolean)", "#onActivityCreated(Bundle)", "#onCreateView(LayoutInflater", "android.os.Build.VERSION_CODES#N", "android.os.Build.VERSION_CODES#M" ]
  }, {
    "name" : " void restoreChildFragmentState(@Nullable Bundle savedInstanceState, boolean provideNonConfig)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public View onCreateView(LayoutInflater inflater, @Nullable ViewGroup container, Bundle savedInstanceState)",
    "returnType" : "View",
    "comment" : "\n     * Called to have the fragment instantiate its user interface view.\n     * This is optional, and non-graphical fragments can return null (which\n     * is the default implementation).  This will be called between\n     * {@link #onCreate(Bundle)} and {@link #onActivityCreated(Bundle)}.\n     *\n     * <p>If you return a View from here, you will later be called in\n     * {@link #onDestroyView} when the view is being released.\n     *\n     * @param inflater The LayoutInflater object that can be used to inflate\n     * any views in the fragment,\n     * @param container If non-null, this is the parent view that the fragment's\n     * UI should be attached to.  The fragment should not add the view itself,\n     * but this can be used to generate the LayoutParams of the view.\n     * @param savedInstanceState If non-null, this fragment is being re-constructed\n     * from a previous saved state as given here.\n     *\n     * @return Return the View for the fragment's UI, or null.\n     ",
    "links" : [ "#onCreate(Bundle)", "#onDestroyView", "#onActivityCreated(Bundle)" ]
  }, {
    "name" : "public void onViewCreated(View view, @Nullable Bundle savedInstanceState)",
    "returnType" : "void",
    "comment" : "\n     * Called immediately after {@link #onCreateView(LayoutInflater, ViewGroup, Bundle)}\n     * has returned, but before any saved state has been restored in to the view.\n     * This gives subclasses a chance to initialize themselves once\n     * they know their view hierarchy has been completely created.  The fragment's\n     * view hierarchy is not however attached to its parent at this point.\n     * @param view The View returned by {@link #onCreateView(LayoutInflater, ViewGroup, Bundle)}.\n     * @param savedInstanceState If non-null, this fragment is being re-constructed\n     * from a previous saved state as given here.\n     ",
    "links" : [ "#onCreateView(LayoutInflater" ]
  }, {
    "name" : "public View getView()",
    "returnType" : "View",
    "comment" : "\n     * Get the root view for the fragment's layout (the one returned by {@link #onCreateView}),\n     * if provided.\n     *\n     * @return The fragment's root view, or null if it has no layout.\n     ",
    "links" : [ "#onCreateView" ]
  }, {
    "name" : "public void onActivityCreated(@Nullable Bundle savedInstanceState)",
    "returnType" : "void",
    "comment" : "\n     * Called when the fragment's activity has been created and this\n     * fragment's view hierarchy instantiated.  It can be used to do final\n     * initialization once these pieces are in place, such as retrieving\n     * views or restoring state.  It is also useful for fragments that use\n     * {@link #setRetainInstance(boolean)} to retain their instance,\n     * as this callback tells the fragment when it is fully associated with\n     * the new activity instance.  This is called after {@link #onCreateView}\n     * and before {@link #onViewStateRestored(Bundle)}.\n     *\n     * @param savedInstanceState If the fragment is being re-created from\n     * a previous saved state, this is the state.\n     ",
    "links" : [ "#onViewStateRestored(Bundle)", "#setRetainInstance(boolean)", "#onCreateView" ]
  }, {
    "name" : "public void onViewStateRestored(Bundle savedInstanceState)",
    "returnType" : "void",
    "comment" : "\n     * Called when all saved state has been restored into the view hierarchy\n     * of the fragment.  This can be used to do initialization based on saved\n     * state that you are letting the view hierarchy track itself, such as\n     * whether check box widgets are currently checked.  This is called\n     * after {@link #onActivityCreated(Bundle)} and before\n     * {@link #onStart()}.\n     *\n     * @param savedInstanceState If the fragment is being re-created from\n     * a previous saved state, this is the state.\n     ",
    "links" : [ "#onActivityCreated(Bundle)", "#onStart()" ]
  }, {
    "name" : "public void onStart()",
    "returnType" : "void",
    "comment" : "\n     * Called when the Fragment is visible to the user.  This is generally\n     * tied to {@link Activity#onStart() Activity.onStart} of the containing\n     * Activity's lifecycle.\n     ",
    "links" : [ "android.app.Activity#onStart()" ]
  }, {
    "name" : "public void onResume()",
    "returnType" : "void",
    "comment" : "\n     * Called when the fragment is visible to the user and actively running.\n     * This is generally\n     * tied to {@link Activity#onResume() Activity.onResume} of the containing\n     * Activity's lifecycle.\n     ",
    "links" : [ "android.app.Activity#onResume()" ]
  }, {
    "name" : "public void onSaveInstanceState(Bundle outState)",
    "returnType" : "void",
    "comment" : "\n     * Called to ask the fragment to save its current dynamic state, so it\n     * can later be reconstructed in a new instance of its process is\n     * restarted.  If a new instance of the fragment later needs to be\n     * created, the data you place in the Bundle here will be available\n     * in the Bundle given to {@link #onCreate(Bundle)},\n     * {@link #onCreateView(LayoutInflater, ViewGroup, Bundle)}, and\n     * {@link #onActivityCreated(Bundle)}.\n     *\n     * <p>This corresponds to {@link Activity#onSaveInstanceState(Bundle)\n     * Activity.onSaveInstanceState(Bundle)} and most of the discussion there\n     * applies here as well.  Note however: <em>this method may be called\n     * at any time before {@link #onDestroy()}</em>.  There are many situations\n     * where a fragment may be mostly torn down (such as when placed on the\n     * back stack with no UI showing), but its state will not be saved until\n     * its owning activity actually needs to save its state.\n     *\n     * @param outState Bundle in which to place your saved state.\n     ",
    "links" : [ "android.app.Activity#onSaveInstanceState(Bundle)", "#onCreate(Bundle)", "#onDestroy()", "#onActivityCreated(Bundle)", "#onCreateView(LayoutInflater" ]
  }, {
    "name" : "public void onMultiWindowModeChanged(boolean isInMultiWindowMode, Configuration newConfig)",
    "returnType" : "void",
    "comment" : "\n     * Called when the Fragment's activity changes from fullscreen mode to multi-window mode and\n     * visa-versa. This is generally tied to {@link Activity#onMultiWindowModeChanged} of the\n     * containing Activity. This method provides the same configuration that will be sent in the\n     * following {@link #onConfigurationChanged(Configuration)} call after the activity enters this\n     * mode.\n     *\n     * @param isInMultiWindowMode True if the activity is in multi-window mode.\n     * @param newConfig The new configuration of the activity with the state\n     *                  {@param isInMultiWindowMode}.\n     ",
    "links" : [ "android.app.Activity#onMultiWindowModeChanged", "#onConfigurationChanged(Configuration)" ]
  }, {
    "name" : "public void onMultiWindowModeChanged(boolean isInMultiWindowMode)",
    "returnType" : "void",
    "comment" : "\n     * Called when the Fragment's activity changes from fullscreen mode to multi-window mode and\n     * visa-versa. This is generally tied to {@link Activity#onMultiWindowModeChanged} of the\n     * containing Activity.\n     *\n     * @param isInMultiWindowMode True if the activity is in multi-window mode.\n     *\n     * @deprecated Use {@link #onMultiWindowModeChanged(boolean, Configuration)} instead.\n     ",
    "links" : [ "android.app.Activity#onMultiWindowModeChanged", "#onMultiWindowModeChanged(boolean" ]
  }, {
    "name" : "public void onPictureInPictureModeChanged(boolean isInPictureInPictureMode, Configuration newConfig)",
    "returnType" : "void",
    "comment" : "\n     * Called by the system when the activity changes to and from picture-in-picture mode. This is\n     * generally tied to {@link Activity#onPictureInPictureModeChanged} of the containing Activity.\n     * This method provides the same configuration that will be sent in the following\n     * {@link #onConfigurationChanged(Configuration)} call after the activity enters this mode.\n     *\n     * @param isInPictureInPictureMode True if the activity is in picture-in-picture mode.\n     * @param newConfig The new configuration of the activity with the state\n     *                  {@param isInPictureInPictureMode}.\n     ",
    "links" : [ "android.app.Activity#onPictureInPictureModeChanged", "#onConfigurationChanged(Configuration)" ]
  }, {
    "name" : "public void onPictureInPictureModeChanged(boolean isInPictureInPictureMode)",
    "returnType" : "void",
    "comment" : "\n     * Called by the system when the activity changes to and from picture-in-picture mode. This is\n     * generally tied to {@link Activity#onPictureInPictureModeChanged} of the containing Activity.\n     *\n     * @param isInPictureInPictureMode True if the activity is in picture-in-picture mode.\n     *\n     * @deprecated Use {@link #onPictureInPictureModeChanged(boolean, Configuration)} instead.\n     ",
    "links" : [ "#onPictureInPictureModeChanged(boolean", "android.app.Activity#onPictureInPictureModeChanged" ]
  }, {
    "name" : "public void onConfigurationChanged(Configuration newConfig)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public void onPause()",
    "returnType" : "void",
    "comment" : "\n     * Called when the Fragment is no longer resumed.  This is generally\n     * tied to {@link Activity#onPause() Activity.onPause} of the containing\n     * Activity's lifecycle.\n     ",
    "links" : [ "android.app.Activity#onPause()" ]
  }, {
    "name" : "public void onStop()",
    "returnType" : "void",
    "comment" : "\n     * Called when the Fragment is no longer started.  This is generally\n     * tied to {@link Activity#onStop() Activity.onStop} of the containing\n     * Activity's lifecycle.\n     ",
    "links" : [ "android.app.Activity#onStop()" ]
  }, {
    "name" : "public void onLowMemory()",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public void onTrimMemory(int level)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public void onDestroyView()",
    "returnType" : "void",
    "comment" : "\n     * Called when the view previously created by {@link #onCreateView} has\n     * been detached from the fragment.  The next time the fragment needs\n     * to be displayed, a new view will be created.  This is called\n     * after {@link #onStop()} and before {@link #onDestroy()}.  It is called\n     * <em>regardless</em> of whether {@link #onCreateView} returned a\n     * non-null view.  Internally it is called after the view's state has\n     * been saved but before it has been removed from its parent.\n     ",
    "links" : [ "#onStop()", "#onDestroy()", "#onCreateView" ]
  }, {
    "name" : "public void onDestroy()",
    "returnType" : "void",
    "comment" : "\n     * Called when the fragment is no longer in use.  This is called\n     * after {@link #onStop()} and before {@link #onDetach()}.\n     ",
    "links" : [ "#onStop()", "#onDetach()" ]
  }, {
    "name" : " void initState()",
    "returnType" : "void",
    "comment" : "\n     * Called by the fragment manager once this fragment has been removed,\n     * so that we don't have any left-over state if the application decides\n     * to re-use the instance.  This only clears state that the framework\n     * internally manages, not things the application sets.\n     ",
    "links" : [ ]
  }, {
    "name" : "public void onDetach()",
    "returnType" : "void",
    "comment" : "\n     * Called when the fragment is no longer attached to its activity.  This is called after\n     * {@link #onDestroy()}, except in the cases where the fragment instance is retained across\n     * Activity re-creation (see {@link #setRetainInstance(boolean)}), in which case it is called\n     * after {@link #onStop()}.\n     ",
    "links" : [ "#onStop()", "#onDestroy()", "#setRetainInstance(boolean)" ]
  }, {
    "name" : "public void onCreateOptionsMenu(Menu menu, MenuInflater inflater)",
    "returnType" : "void",
    "comment" : "\n     * Initialize the contents of the Activity's standard options menu.  You\n     * should place your menu items in to <var>menu</var>.  For this method\n     * to be called, you must have first called {@link #setHasOptionsMenu}.  See\n     * {@link Activity#onCreateOptionsMenu(Menu) Activity.onCreateOptionsMenu}\n     * for more information.\n     *\n     * @param menu The options menu in which you place your items.\n     *\n     * @see #setHasOptionsMenu\n     * @see #onPrepareOptionsMenu\n     * @see #onOptionsItemSelected\n     ",
    "links" : [ "#setHasOptionsMenu", "android.app.Activity#onCreateOptionsMenu(Menu)" ]
  }, {
    "name" : "public void onPrepareOptionsMenu(Menu menu)",
    "returnType" : "void",
    "comment" : "\n     * Prepare the Screen's standard options menu to be displayed.  This is\n     * called right before the menu is shown, every time it is shown.  You can\n     * use this method to efficiently enable/disable items or otherwise\n     * dynamically modify the contents.  See\n     * {@link Activity#onPrepareOptionsMenu(Menu) Activity.onPrepareOptionsMenu}\n     * for more information.\n     *\n     * @param menu The options menu as last shown or first initialized by\n     *             onCreateOptionsMenu().\n     *\n     * @see #setHasOptionsMenu\n     * @see #onCreateOptionsMenu\n     ",
    "links" : [ "android.app.Activity#onPrepareOptionsMenu(Menu)" ]
  }, {
    "name" : "public void onDestroyOptionsMenu()",
    "returnType" : "void",
    "comment" : "\n     * Called when this fragment's option menu items are no longer being\n     * included in the overall options menu.  Receiving this call means that\n     * the menu needed to be rebuilt, but this fragment's items were not\n     * included in the newly built menu (its {@link #onCreateOptionsMenu(Menu, MenuInflater)}\n     * was not called).\n     ",
    "links" : [ "#onCreateOptionsMenu(Menu" ]
  }, {
    "name" : "public boolean onOptionsItemSelected(MenuItem item)",
    "returnType" : "boolean",
    "comment" : "\n     * This hook is called whenever an item in your options menu is selected.\n     * The default implementation simply returns false to have the normal\n     * processing happen (calling the item's Runnable or sending a message to\n     * its Handler as appropriate).  You can use this method for any items\n     * for which you would like to do processing without those other\n     * facilities.\n     *\n     * <p>Derived classes should call through to the base class for it to\n     * perform the default menu handling.\n     *\n     * @param item The menu item that was selected.\n     *\n     * @return boolean Return false to allow normal menu processing to\n     *         proceed, true to consume it here.\n     *\n     * @see #onCreateOptionsMenu\n     ",
    "links" : [ ]
  }, {
    "name" : "public void onOptionsMenuClosed(Menu menu)",
    "returnType" : "void",
    "comment" : "\n     * This hook is called whenever the options menu is being closed (either by the user canceling\n     * the menu with the back/menu button, or when an item is selected).\n     *\n     * @param menu The options menu as last shown or first initialized by\n     *             onCreateOptionsMenu().\n     ",
    "links" : [ ]
  }, {
    "name" : "public void onCreateContextMenu(ContextMenu menu, View v, ContextMenuInfo menuInfo)",
    "returnType" : "void",
    "comment" : "\n     * Called when a context menu for the {@code view} is about to be shown.\n     * Unlike {@link #onCreateOptionsMenu}, this will be called every\n     * time the context menu is about to be shown and should be populated for\n     * the view (or item inside the view for {@link AdapterView} subclasses,\n     * this can be found in the {@code menuInfo})).\n     * <p>\n     * Use {@link #onContextItemSelected(android.view.MenuItem)} to know when an\n     * item has been selected.\n     * <p>\n     * The default implementation calls up to\n     * {@link Activity#onCreateContextMenu Activity.onCreateContextMenu}, though\n     * you can not call this implementation if you don't want that behavior.\n     * <p>\n     * It is not safe to hold onto the context menu after this method returns.\n     * {@inheritDoc}\n     ",
    "links" : [ "#onContextItemSelected(android.view.MenuItem)", "#onCreateOptionsMenu", "android.app.Activity#onCreateContextMenu", "android.widget.AdapterView" ]
  }, {
    "name" : "public void registerForContextMenu(View view)",
    "returnType" : "void",
    "comment" : "\n     * Registers a context menu to be shown for the given view (multiple views\n     * can show the context menu). This method will set the\n     * {@link OnCreateContextMenuListener} on the view to this fragment, so\n     * {@link #onCreateContextMenu(ContextMenu, View, ContextMenuInfo)} will be\n     * called when it is time to show the context menu.\n     *\n     * @see #unregisterForContextMenu(View)\n     * @param view The view that should show a context menu.\n     ",
    "links" : [ "#onCreateContextMenu(ContextMenu", "android.view.View.OnCreateContextMenuListener" ]
  }, {
    "name" : "public void unregisterForContextMenu(View view)",
    "returnType" : "void",
    "comment" : "\n     * Prevents a context menu to be shown for the given view. This method will\n     * remove the {@link OnCreateContextMenuListener} on the view.\n     *\n     * @see #registerForContextMenu(View)\n     * @param view The view that should stop showing a context menu.\n     ",
    "links" : [ "android.view.View.OnCreateContextMenuListener" ]
  }, {
    "name" : "public boolean onContextItemSelected(MenuItem item)",
    "returnType" : "boolean",
    "comment" : "\n     * This hook is called whenever an item in a context menu is selected. The\n     * default implementation simply returns false to have the normal processing\n     * happen (calling the item's Runnable or sending a message to its Handler\n     * as appropriate). You can use this method for any items for which you\n     * would like to do processing without those other facilities.\n     * <p>\n     * Use {@link MenuItem#getMenuInfo()} to get extra information set by the\n     * View that added this menu item.\n     * <p>\n     * Derived classes should call through to the base class for it to perform\n     * the default menu handling.\n     *\n     * @param item The context menu item that was selected.\n     * @return boolean Return false to allow normal context menu processing to\n     *         proceed, true to consume it here.\n     ",
    "links" : [ "android.view.MenuItem#getMenuInfo()" ]
  }, {
    "name" : "public void setEnterSharedElementCallback(SharedElementCallback callback)",
    "returnType" : "void",
    "comment" : "\n     * When custom transitions are used with Fragments, the enter transition callback\n     * is called when this Fragment is attached or detached when not popping the back stack.\n     *\n     * @param callback Used to manipulate the shared element transitions on this Fragment\n     *                 when added not as a pop from the back stack.\n     ",
    "links" : [ ]
  }, {
    "name" : "public void setExitSharedElementCallback(SharedElementCallback callback)",
    "returnType" : "void",
    "comment" : "\n     * When custom transitions are used with Fragments, the exit transition callback\n     * is called when this Fragment is attached or detached when popping the back stack.\n     *\n     * @param callback Used to manipulate the shared element transitions on this Fragment\n     *                 when added as a pop from the back stack.\n     ",
    "links" : [ ]
  }, {
    "name" : "public void setEnterTransition(Transition transition)",
    "returnType" : "void",
    "comment" : "\n     * Sets the Transition that will be used to move Views into the initial scene. The entering\n     * Views will be those that are regular Views or ViewGroups that have\n     * {@link ViewGroup#isTransitionGroup} return true. Typical Transitions will extend\n     * {@link android.transition.Visibility} as entering is governed by changing visibility from\n     * {@link View#INVISIBLE} to {@link View#VISIBLE}. If <code>transition</code> is null,\n     * entering Views will remain unaffected.\n     *\n     * @param transition The Transition to use to move Views into the initial Scene.\n     * @attr ref android.R.styleable#Fragment_fragmentEnterTransition\n     ",
    "links" : [ "android.transition.Visibility", "android.view.View#VISIBLE", "android.view.ViewGroup#isTransitionGroup", "android.view.View#INVISIBLE" ]
  }, {
    "name" : "public Transition getEnterTransition()",
    "returnType" : "Transition",
    "comment" : "\n     * Returns the Transition that will be used to move Views into the initial scene. The entering\n     * Views will be those that are regular Views or ViewGroups that have\n     * {@link ViewGroup#isTransitionGroup} return true. Typical Transitions will extend\n     * {@link android.transition.Visibility} as entering is governed by changing visibility from\n     * {@link View#INVISIBLE} to {@link View#VISIBLE}.\n     *\n     * @return the Transition to use to move Views into the initial Scene.\n     * @attr ref android.R.styleable#Fragment_fragmentEnterTransition\n     ",
    "links" : [ "android.transition.Visibility", "android.view.View#VISIBLE", "android.view.ViewGroup#isTransitionGroup", "android.view.View#INVISIBLE" ]
  }, {
    "name" : "public void setReturnTransition(Transition transition)",
    "returnType" : "void",
    "comment" : "\n     * Sets the Transition that will be used to move Views out of the scene when the Fragment is\n     * preparing to be removed, hidden, or detached because of popping the back stack. The exiting\n     * Views will be those that are regular Views or ViewGroups that have\n     * {@link ViewGroup#isTransitionGroup} return true. Typical Transitions will extend\n     * {@link android.transition.Visibility} as entering is governed by changing visibility from\n     * {@link View#VISIBLE} to {@link View#INVISIBLE}. If <code>transition</code> is null,\n     * entering Views will remain unaffected. If nothing is set, the default will be to\n     * use the same value as set in {@link #setEnterTransition(android.transition.Transition)}.\n     *\n     * @param transition The Transition to use to move Views out of the Scene when the Fragment\n     *                   is preparing to close.\n     * @attr ref android.R.styleable#Fragment_fragmentExitTransition\n     ",
    "links" : [ "android.transition.Visibility", "android.view.View#VISIBLE", "android.view.ViewGroup#isTransitionGroup", "#setEnterTransition(android.transition.Transition)", "android.view.View#INVISIBLE" ]
  }, {
    "name" : "public Transition getReturnTransition()",
    "returnType" : "Transition",
    "comment" : "\n     * Returns the Transition that will be used to move Views out of the scene when the Fragment is\n     * preparing to be removed, hidden, or detached because of popping the back stack. The exiting\n     * Views will be those that are regular Views or ViewGroups that have\n     * {@link ViewGroup#isTransitionGroup} return true. Typical Transitions will extend\n     * {@link android.transition.Visibility} as entering is governed by changing visibility from\n     * {@link View#VISIBLE} to {@link View#INVISIBLE}. If <code>transition</code> is null,\n     * entering Views will remain unaffected.\n     *\n     * @return the Transition to use to move Views out of the Scene when the Fragment\n     *         is preparing to close.\n     * @attr ref android.R.styleable#Fragment_fragmentExitTransition\n     ",
    "links" : [ "android.transition.Visibility", "android.view.View#VISIBLE", "android.view.ViewGroup#isTransitionGroup", "android.view.View#INVISIBLE" ]
  }, {
    "name" : "public void setExitTransition(Transition transition)",
    "returnType" : "void",
    "comment" : "\n     * Sets the Transition that will be used to move Views out of the scene when the\n     * fragment is removed, hidden, or detached when not popping the back stack.\n     * The exiting Views will be those that are regular Views or ViewGroups that\n     * have {@link ViewGroup#isTransitionGroup} return true. Typical Transitions will extend\n     * {@link android.transition.Visibility} as exiting is governed by changing visibility\n     * from {@link View#VISIBLE} to {@link View#INVISIBLE}. If transition is null, the views will\n     * remain unaffected.\n     *\n     * @param transition The Transition to use to move Views out of the Scene when the Fragment\n     *                   is being closed not due to popping the back stack.\n     * @attr ref android.R.styleable#Fragment_fragmentExitTransition\n     ",
    "links" : [ "android.transition.Visibility", "android.view.View#VISIBLE", "android.view.ViewGroup#isTransitionGroup", "android.view.View#INVISIBLE" ]
  }, {
    "name" : "public Transition getExitTransition()",
    "returnType" : "Transition",
    "comment" : "\n     * Returns the Transition that will be used to move Views out of the scene when the\n     * fragment is removed, hidden, or detached when not popping the back stack.\n     * The exiting Views will be those that are regular Views or ViewGroups that\n     * have {@link ViewGroup#isTransitionGroup} return true. Typical Transitions will extend\n     * {@link android.transition.Visibility} as exiting is governed by changing visibility\n     * from {@link View#VISIBLE} to {@link View#INVISIBLE}. If transition is null, the views will\n     * remain unaffected.\n     *\n     * @return the Transition to use to move Views out of the Scene when the Fragment\n     *         is being closed not due to popping the back stack.\n     * @attr ref android.R.styleable#Fragment_fragmentExitTransition\n     ",
    "links" : [ "android.transition.Visibility", "android.view.View#VISIBLE", "android.view.ViewGroup#isTransitionGroup", "android.view.View#INVISIBLE" ]
  }, {
    "name" : "public void setReenterTransition(Transition transition)",
    "returnType" : "void",
    "comment" : "\n     * Sets the Transition that will be used to move Views in to the scene when returning due\n     * to popping a back stack. The entering Views will be those that are regular Views\n     * or ViewGroups that have {@link ViewGroup#isTransitionGroup} return true. Typical Transitions\n     * will extend {@link android.transition.Visibility} as exiting is governed by changing\n     * visibility from {@link View#VISIBLE} to {@link View#INVISIBLE}. If transition is null,\n     * the views will remain unaffected. If nothing is set, the default will be to use the same\n     * transition as {@link #setExitTransition(android.transition.Transition)}.\n     *\n     * @param transition The Transition to use to move Views into the scene when reentering from a\n     *                   previously-started Activity.\n     * @attr ref android.R.styleable#Fragment_fragmentReenterTransition\n     ",
    "links" : [ "android.transition.Visibility", "android.view.View#VISIBLE", "android.view.ViewGroup#isTransitionGroup", "android.view.View#INVISIBLE", "#setExitTransition(android.transition.Transition)" ]
  }, {
    "name" : "public Transition getReenterTransition()",
    "returnType" : "Transition",
    "comment" : "\n     * Returns the Transition that will be used to move Views in to the scene when returning due\n     * to popping a back stack. The entering Views will be those that are regular Views\n     * or ViewGroups that have {@link ViewGroup#isTransitionGroup} return true. Typical Transitions\n     * will extend {@link android.transition.Visibility} as exiting is governed by changing\n     * visibility from {@link View#VISIBLE} to {@link View#INVISIBLE}. If transition is null,\n     * the views will remain unaffected. If nothing is set, the default will be to use the same\n     * transition as {@link #setExitTransition(android.transition.Transition)}.\n     *\n     * @return the Transition to use to move Views into the scene when reentering from a\n     *                   previously-started Activity.\n     * @attr ref android.R.styleable#Fragment_fragmentReenterTransition\n     ",
    "links" : [ "android.transition.Visibility", "android.view.View#VISIBLE", "android.view.ViewGroup#isTransitionGroup", "android.view.View#INVISIBLE", "#setExitTransition(android.transition.Transition)" ]
  }, {
    "name" : "public void setSharedElementEnterTransition(Transition transition)",
    "returnType" : "void",
    "comment" : "\n     * Sets the Transition that will be used for shared elements transferred into the content\n     * Scene. Typical Transitions will affect size and location, such as\n     * {@link android.transition.ChangeBounds}. A null\n     * value will cause transferred shared elements to blink to the final position.\n     *\n     * @param transition The Transition to use for shared elements transferred into the content\n     *                   Scene.\n     * @attr ref android.R.styleable#Fragment_fragmentSharedElementEnterTransition\n     ",
    "links" : [ "android.transition.ChangeBounds" ]
  }, {
    "name" : "public Transition getSharedElementEnterTransition()",
    "returnType" : "Transition",
    "comment" : "\n     * Returns the Transition that will be used for shared elements transferred into the content\n     * Scene. Typical Transitions will affect size and location, such as\n     * {@link android.transition.ChangeBounds}. A null\n     * value will cause transferred shared elements to blink to the final position.\n     *\n     * @return The Transition to use for shared elements transferred into the content\n     *                   Scene.\n     * @attr ref android.R.styleable#Fragment_fragmentSharedElementEnterTransition\n     ",
    "links" : [ "android.transition.ChangeBounds" ]
  }, {
    "name" : "public void setSharedElementReturnTransition(Transition transition)",
    "returnType" : "void",
    "comment" : "\n     * Sets the Transition that will be used for shared elements transferred back during a\n     * pop of the back stack. This Transition acts in the leaving Fragment.\n     * Typical Transitions will affect size and location, such as\n     * {@link android.transition.ChangeBounds}. A null\n     * value will cause transferred shared elements to blink to the final position.\n     * If no value is set, the default will be to use the same value as\n     * {@link #setSharedElementEnterTransition(android.transition.Transition)}.\n     *\n     * @param transition The Transition to use for shared elements transferred out of the content\n     *                   Scene.\n     * @attr ref android.R.styleable#Fragment_fragmentSharedElementReturnTransition\n     ",
    "links" : [ "android.transition.ChangeBounds", "#setSharedElementEnterTransition(android.transition.Transition)" ]
  }, {
    "name" : "public Transition getSharedElementReturnTransition()",
    "returnType" : "Transition",
    "comment" : "\n     * Return the Transition that will be used for shared elements transferred back during a\n     * pop of the back stack. This Transition acts in the leaving Fragment.\n     * Typical Transitions will affect size and location, such as\n     * {@link android.transition.ChangeBounds}. A null\n     * value will cause transferred shared elements to blink to the final position.\n     * If no value is set, the default will be to use the same value as\n     * {@link #setSharedElementEnterTransition(android.transition.Transition)}.\n     *\n     * @return The Transition to use for shared elements transferred out of the content\n     *                   Scene.\n     * @attr ref android.R.styleable#Fragment_fragmentSharedElementReturnTransition\n     ",
    "links" : [ "android.transition.ChangeBounds", "#setSharedElementEnterTransition(android.transition.Transition)" ]
  }, {
    "name" : "public void setAllowEnterTransitionOverlap(boolean allow)",
    "returnType" : "void",
    "comment" : "\n     * Sets whether the exit transition and enter transition overlap or not.\n     * When true, the enter transition will start as soon as possible. When false, the\n     * enter transition will wait until the exit transition completes before starting.\n     *\n     * @param allow true to start the enter transition when possible or false to\n     *              wait until the exiting transition completes.\n     * @attr ref android.R.styleable#Fragment_fragmentAllowEnterTransitionOverlap\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean getAllowEnterTransitionOverlap()",
    "returnType" : "boolean",
    "comment" : "\n     * Returns whether the exit transition and enter transition overlap or not.\n     * When true, the enter transition will start as soon as possible. When false, the\n     * enter transition will wait until the exit transition completes before starting.\n     *\n     * @return true when the enter transition should start as soon as possible or false to\n     * when it should wait until the exiting transition completes.\n     * @attr ref android.R.styleable#Fragment_fragmentAllowEnterTransitionOverlap\n     ",
    "links" : [ ]
  }, {
    "name" : "public void setAllowReturnTransitionOverlap(boolean allow)",
    "returnType" : "void",
    "comment" : "\n     * Sets whether the return transition and reenter transition overlap or not.\n     * When true, the reenter transition will start as soon as possible. When false, the\n     * reenter transition will wait until the return transition completes before starting.\n     *\n     * @param allow true to start the reenter transition when possible or false to wait until the\n     *              return transition completes.\n     * @attr ref android.R.styleable#Fragment_fragmentAllowReturnTransitionOverlap\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean getAllowReturnTransitionOverlap()",
    "returnType" : "boolean",
    "comment" : "\n     * Returns whether the return transition and reenter transition overlap or not.\n     * When true, the reenter transition will start as soon as possible. When false, the\n     * reenter transition will wait until the return transition completes before starting.\n     *\n     * @return true to start the reenter transition when possible or false to wait until the\n     *         return transition completes.\n     * @attr ref android.R.styleable#Fragment_fragmentAllowReturnTransitionOverlap\n     ",
    "links" : [ ]
  }, {
    "name" : "public void postponeEnterTransition()",
    "returnType" : "void",
    "comment" : "\n     * Postpone the entering Fragment transition until {@link #startPostponedEnterTransition()}\n     * or {@link FragmentManager#executePendingTransactions()} has been called.\n     * <p>\n     * This method gives the Fragment the ability to delay Fragment animations\n     * until all data is loaded. Until then, the added, shown, and\n     * attached Fragments will be INVISIBLE and removed, hidden, and detached Fragments won't\n     * be have their Views removed. The transaction runs when all postponed added Fragments in the\n     * transaction have called {@link #startPostponedEnterTransition()}.\n     * <p>\n     * This method should be called before being added to the FragmentTransaction or\n     * in {@link #onCreate(Bundle)}, {@link #onAttach(Context)}, or\n     * {@link #onCreateView(LayoutInflater, ViewGroup, Bundle)}}.\n     * {@link #startPostponedEnterTransition()} must be called to allow the Fragment to\n     * start the transitions.\n     * <p>\n     * When a FragmentTransaction is started that may affect a postponed FragmentTransaction,\n     * based on which containers are in their operations, the postponed FragmentTransaction\n     * will have its start triggered. The early triggering may result in faulty or nonexistent\n     * animations in the postponed transaction. FragmentTransactions that operate only on\n     * independent containers will not interfere with each other's postponement.\n     * <p>\n     * Calling postponeEnterTransition on Fragments with a null View will not postpone the\n     * transition. Likewise, postponement only works if FragmentTransaction optimizations are\n     * enabled.\n     *\n     * @see Activity#postponeEnterTransition()\n     * @see FragmentTransaction#setReorderingAllowed(boolean)\n     ",
    "links" : [ "#onCreate(Bundle)", "#onAttach(Context)", "#startPostponedEnterTransition()", "android.app.FragmentManager#executePendingTransactions()", "#onCreateView(LayoutInflater" ]
  }, {
    "name" : "public void startPostponedEnterTransition()",
    "returnType" : "void",
    "comment" : "\n     * Begin postponed transitions after {@link #postponeEnterTransition()} was called.\n     * If postponeEnterTransition() was called, you must call startPostponedEnterTransition()\n     * or {@link FragmentManager#executePendingTransactions()} to complete the FragmentTransaction.\n     * If postponement was interrupted with {@link FragmentManager#executePendingTransactions()},\n     * before {@code startPostponedEnterTransition()}, animations may not run or may execute\n     * improperly.\n     *\n     * @see Activity#startPostponedEnterTransition()\n     ",
    "links" : [ "#postponeEnterTransition()", "android.app.FragmentManager#executePendingTransactions()" ]
  }, {
    "name" : "private void callStartTransitionListener()",
    "returnType" : "void",
    "comment" : "\n     * Calls the start transition listener. This must be called on the UI thread.\n     ",
    "links" : [ ]
  }, {
    "name" : "private boolean shouldChangeTransition(Transition transition, Transition defaultValue)",
    "returnType" : "boolean",
    "comment" : "\n     * Returns true if mAnimationInfo is not null or the transition differs from the default value.\n     * This is broken out to ensure mAnimationInfo is properly locked when checking.\n     ",
    "links" : [ ]
  }, {
    "name" : "public void dump(String prefix, FileDescriptor fd, PrintWriter writer, String[] args)",
    "returnType" : "void",
    "comment" : "\n     * Print the Fragments's state into the given stream.\n     *\n     * @param prefix Text to print at the front of each line.\n     * @param fd The raw file descriptor that the dump is being sent to.\n     * @param writer The PrintWriter to which you should dump your state.  This will be\n     * closed for you after you return.\n     * @param args additional arguments to the dump request.\n     ",
    "links" : [ ]
  }, {
    "name" : " Fragment findFragmentByWho(String who)",
    "returnType" : "Fragment",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : " void instantiateChildFragmentManager()",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : " void performCreate(Bundle savedInstanceState)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : " View performCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState)",
    "returnType" : "View",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : " void performActivityCreated(Bundle savedInstanceState)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : " void performStart()",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : " void performResume()",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : " void noteStateNotSaved()",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : " void performMultiWindowModeChanged(boolean isInMultiWindowMode)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : " void performMultiWindowModeChanged(boolean isInMultiWindowMode, Configuration newConfig)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : " void performPictureInPictureModeChanged(boolean isInPictureInPictureMode)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : " void performPictureInPictureModeChanged(boolean isInPictureInPictureMode, Configuration newConfig)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : " void performConfigurationChanged(Configuration newConfig)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : " void performLowMemory()",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : " void performTrimMemory(int level)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : " boolean performCreateOptionsMenu(Menu menu, MenuInflater inflater)",
    "returnType" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : " boolean performPrepareOptionsMenu(Menu menu)",
    "returnType" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : " boolean performOptionsItemSelected(MenuItem item)",
    "returnType" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : " boolean performContextItemSelected(MenuItem item)",
    "returnType" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : " void performOptionsMenuClosed(Menu menu)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : " void performSaveInstanceState(Bundle outState)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : " void performPause()",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : " void performStop()",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : " void performDestroyView()",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : " void performDestroy()",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : " void performDetach()",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : " void setOnStartEnterTransitionListener(OnStartEnterTransitionListener listener)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private static Transition loadTransition(Context context, TypedArray typedArray, Transition currentValue, Transition defaultValue, int id)",
    "returnType" : "Transition",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private AnimationInfo ensureAnimationInfo()",
    "returnType" : "AnimationInfo",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : " int getNextAnim()",
    "returnType" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : " void setNextAnim(int animResourceId)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : " int getNextTransition()",
    "returnType" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : " void setNextTransition(int nextTransition, int nextTransitionStyle)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : " int getNextTransitionStyle()",
    "returnType" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : " SharedElementCallback getEnterTransitionCallback()",
    "returnType" : "SharedElementCallback",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : " SharedElementCallback getExitTransitionCallback()",
    "returnType" : "SharedElementCallback",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : " Animator getAnimatingAway()",
    "returnType" : "Animator",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : " void setAnimatingAway(Animator animator)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : " int getStateAfterAnimating()",
    "returnType" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : " void setStateAfterAnimating(int state)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : " boolean isPostponed()",
    "returnType" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : " boolean isHideReplaced()",
    "returnType" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : " void setHideReplaced(boolean replaced)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  } ],
  "variableNames" : [ "sClassMap", "INVALID_STATE", "INITIALIZING", "CREATED", "ACTIVITY_CREATED", "STOPPED", "STARTED", "RESUMED", "USE_DEFAULT_TRANSITION", "mState", "mSavedFragmentState", "mSavedViewState", "mIndex", "mWho", "mArguments", "mTarget", "mTargetIndex", "mTargetRequestCode", "mAdded", "mRemoving", "mFromLayout", "mInLayout", "mRestored", "mPerformedCreateView", "mBackStackNesting", "mFragmentManager", "mHost", "mChildFragmentManager", "mChildNonConfig", "mParentFragment", "mFragmentId", "mContainerId", "mTag", "mHidden", "mDetached", "mRetainInstance", "mRetaining", "mHasMenu", "mMenuVisible", "mCalled", "mContainer", "mView", "mDeferStart", "mUserVisibleHint", "mLoaderManager", "mLoadersStarted", "mCheckedForLoaderManager", "mAnimationInfo", "mIsNewlyAdded", "mHiddenChanged", "mLayoutInflater", "mIsCreated" ],
  "methodNames" : [ "public static Fragment instantiate(Context context, String fname)", "public static Fragment instantiate(Context context, String fname, @Nullable Bundle args)", " final void restoreViewState(Bundle savedInstanceState)", " final void setIndex(int index, Fragment parent)", " final boolean isInBackStack()", "public final boolean equals(Object o)", "public final int hashCode()", "public String toString()", "public final int getId()", "public final String getTag()", "public void setArguments(Bundle args)", "public final Bundle getArguments()", "public final boolean isStateSaved()", "public void setInitialSavedState(SavedState state)", "public void setTargetFragment(Fragment fragment, int requestCode)", "public final Fragment getTargetFragment()", "public final int getTargetRequestCode()", "public Context getContext()", "public final Activity getActivity()", "public final Object getHost()", "public final Resources getResources()", "public final CharSequence getText(@StringRes int resId)", "public final String getString(@StringRes int resId)", "public final String getString(@StringRes int resId, Object... formatArgs)", "public final FragmentManager getFragmentManager()", "public final FragmentManager getChildFragmentManager()", "public final Fragment getParentFragment()", "public final boolean isAdded()", "public final boolean isDetached()", "public final boolean isRemoving()", "public final boolean isInLayout()", "public final boolean isResumed()", "public final boolean isVisible()", "public final boolean isHidden()", "public void onHiddenChanged(boolean hidden)", "public void setRetainInstance(boolean retain)", "public final boolean getRetainInstance()", "public void setHasOptionsMenu(boolean hasMenu)", "public void setMenuVisibility(boolean menuVisible)", "public void setUserVisibleHint(boolean isVisibleToUser)", "public boolean getUserVisibleHint()", "public LoaderManager getLoaderManager()", "public void startActivity(Intent intent)", "public void startActivity(Intent intent, Bundle options)", "public void startActivityForResult(Intent intent, int requestCode)", "public void startActivityForResult(Intent intent, int requestCode, Bundle options)", "public void startActivityForResultAsUser(Intent intent, int requestCode, Bundle options, UserHandle user)", "public void startIntentSenderForResult(IntentSender intent, int requestCode, @Nullable Intent fillInIntent, int flagsMask, int flagsValues, int extraFlags, Bundle options) throws IntentSender.SendIntentException", "public void onActivityResult(int requestCode, int resultCode, Intent data)", "public final void requestPermissions(@NonNull String[] permissions, int requestCode)", "public void onRequestPermissionsResult(int requestCode, @NonNull String[] permissions, @NonNull int[] grantResults)", "public boolean shouldShowRequestPermissionRationale(@NonNull String permission)", "public LayoutInflater onGetLayoutInflater(Bundle savedInstanceState)", "public final LayoutInflater getLayoutInflater()", " LayoutInflater performGetLayoutInflater(Bundle savedInstanceState)", "public void onInflate(AttributeSet attrs, Bundle savedInstanceState)", "public void onInflate(Context context, AttributeSet attrs, Bundle savedInstanceState)", "public void onInflate(Activity activity, AttributeSet attrs, Bundle savedInstanceState)", "public void onAttachFragment(Fragment childFragment)", "public void onAttach(Context context)", "public void onAttach(Activity activity)", "public Animator onCreateAnimator(int transit, boolean enter, int nextAnim)", "public void onCreate(@Nullable Bundle savedInstanceState)", " void restoreChildFragmentState(@Nullable Bundle savedInstanceState, boolean provideNonConfig)", "public View onCreateView(LayoutInflater inflater, @Nullable ViewGroup container, Bundle savedInstanceState)", "public void onViewCreated(View view, @Nullable Bundle savedInstanceState)", "public View getView()", "public void onActivityCreated(@Nullable Bundle savedInstanceState)", "public void onViewStateRestored(Bundle savedInstanceState)", "public void onStart()", "public void onResume()", "public void onSaveInstanceState(Bundle outState)", "public void onMultiWindowModeChanged(boolean isInMultiWindowMode, Configuration newConfig)", "public void onMultiWindowModeChanged(boolean isInMultiWindowMode)", "public void onPictureInPictureModeChanged(boolean isInPictureInPictureMode, Configuration newConfig)", "public void onPictureInPictureModeChanged(boolean isInPictureInPictureMode)", "public void onConfigurationChanged(Configuration newConfig)", "public void onPause()", "public void onStop()", "public void onLowMemory()", "public void onTrimMemory(int level)", "public void onDestroyView()", "public void onDestroy()", " void initState()", "public void onDetach()", "public void onCreateOptionsMenu(Menu menu, MenuInflater inflater)", "public void onPrepareOptionsMenu(Menu menu)", "public void onDestroyOptionsMenu()", "public boolean onOptionsItemSelected(MenuItem item)", "public void onOptionsMenuClosed(Menu menu)", "public void onCreateContextMenu(ContextMenu menu, View v, ContextMenuInfo menuInfo)", "public void registerForContextMenu(View view)", "public void unregisterForContextMenu(View view)", "public boolean onContextItemSelected(MenuItem item)", "public void setEnterSharedElementCallback(SharedElementCallback callback)", "public void setExitSharedElementCallback(SharedElementCallback callback)", "public void setEnterTransition(Transition transition)", "public Transition getEnterTransition()", "public void setReturnTransition(Transition transition)", "public Transition getReturnTransition()", "public void setExitTransition(Transition transition)", "public Transition getExitTransition()", "public void setReenterTransition(Transition transition)", "public Transition getReenterTransition()", "public void setSharedElementEnterTransition(Transition transition)", "public Transition getSharedElementEnterTransition()", "public void setSharedElementReturnTransition(Transition transition)", "public Transition getSharedElementReturnTransition()", "public void setAllowEnterTransitionOverlap(boolean allow)", "public boolean getAllowEnterTransitionOverlap()", "public void setAllowReturnTransitionOverlap(boolean allow)", "public boolean getAllowReturnTransitionOverlap()", "public void postponeEnterTransition()", "public void startPostponedEnterTransition()", "private void callStartTransitionListener()", "private boolean shouldChangeTransition(Transition transition, Transition defaultValue)", "public void dump(String prefix, FileDescriptor fd, PrintWriter writer, String[] args)", " Fragment findFragmentByWho(String who)", " void instantiateChildFragmentManager()", " void performCreate(Bundle savedInstanceState)", " View performCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState)", " void performActivityCreated(Bundle savedInstanceState)", " void performStart()", " void performResume()", " void noteStateNotSaved()", " void performMultiWindowModeChanged(boolean isInMultiWindowMode)", " void performMultiWindowModeChanged(boolean isInMultiWindowMode, Configuration newConfig)", " void performPictureInPictureModeChanged(boolean isInPictureInPictureMode)", " void performPictureInPictureModeChanged(boolean isInPictureInPictureMode, Configuration newConfig)", " void performConfigurationChanged(Configuration newConfig)", " void performLowMemory()", " void performTrimMemory(int level)", " boolean performCreateOptionsMenu(Menu menu, MenuInflater inflater)", " boolean performPrepareOptionsMenu(Menu menu)", " boolean performOptionsItemSelected(MenuItem item)", " boolean performContextItemSelected(MenuItem item)", " void performOptionsMenuClosed(Menu menu)", " void performSaveInstanceState(Bundle outState)", " void performPause()", " void performStop()", " void performDestroyView()", " void performDestroy()", " void performDetach()", " void setOnStartEnterTransitionListener(OnStartEnterTransitionListener listener)", "private static Transition loadTransition(Context context, TypedArray typedArray, Transition currentValue, Transition defaultValue, int id)", "private AnimationInfo ensureAnimationInfo()", " int getNextAnim()", " void setNextAnim(int animResourceId)", " int getNextTransition()", " void setNextTransition(int nextTransition, int nextTransitionStyle)", " int getNextTransitionStyle()", " SharedElementCallback getEnterTransitionCallback()", " SharedElementCallback getExitTransitionCallback()", " Animator getAnimatingAway()", " void setAnimatingAway(Animator animator)", " int getStateAfterAnimating()", " void setStateAfterAnimating(int state)", " boolean isPostponed()", " boolean isHideReplaced()", " void setHideReplaced(boolean replaced)" ]
}