{
  "filePath" : "/home/maryam/clearblue/files/android-source-35/android/hardware/hdmi/HdmiControlManager.java",
  "packageName" : "android.hardware.hdmi",
  "className" : "HdmiControlManager",
  "comment" : "\n * The {@link HdmiControlManager} class is used to send HDMI control messages\n * to attached CEC devices. It also allows to control the eARC feature.\n *\n * <p>Provides various HDMI client instances that represent HDMI-CEC logical devices\n * hosted in the system. {@link #getTvClient()}, for instance will return an\n * {@link HdmiTvClient} object if the system is configured to host one. Android system\n * can host more than one logical CEC devices. If multiple types are configured they\n * all work as if they were independent logical devices running in the system.\n *\n * @hide\n ",
  "links" : [ "android.hardware.hdmi.HdmiControlManager", "#getTvClient()", "android.hardware.hdmi.HdmiTvClient" ],
  "variables" : [ {
    "name" : "TAG",
    "type" : "String",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mService",
    "type" : "IHdmiControlService",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "INVALID_PHYSICAL_ADDRESS",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mLocalPhysicalAddress",
    "type" : "int",
    "comment" : "\n     * A cache of the current device's physical address. When device's HDMI out port\n     * is not connected to any device, it is set to {@link #INVALID_PHYSICAL_ADDRESS}.\n     *\n     * <p>Otherwise it is updated by the {@link ClientHotplugEventListener} registered\n     * with {@link com.android.server.hdmi.HdmiControlService} by the\n     * {@link #addHotplugEventListener(HotplugEventListener)} and the address is from\n     * {@link com.android.server.hdmi.HdmiControlService#getPortInfo()}\n     ",
    "links" : [ "ClientHotplugEventListener", "#INVALID_PHYSICAL_ADDRESS", "com.android.server.hdmi.HdmiControlService#getPortInfo()", "com.android.server.hdmi.HdmiControlService", "#addHotplugEventListener(HotplugEventListener)" ]
  }, {
    "name" : "mLock",
    "type" : "Object",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "ACTION_OSD_MESSAGE",
    "type" : "String",
    "comment" : "\n     * Broadcast Action: Display OSD message.\n     * <p>Send when the service has a message to display on screen for events\n     * that need user's attention such as ARC status change.\n     * <p>Always contains the extra fields {@link #EXTRA_MESSAGE_ID}.\n     * <p>Requires {@link android.Manifest.permission#HDMI_CEC} to receive.\n     ",
    "links" : [ "android.Manifest.permission#HDMI_CEC", "#EXTRA_MESSAGE_ID" ]
  }, {
    "name" : "OSD_MESSAGE_ARC_CONNECTED_INVALID_PORT",
    "type" : "int",
    "comment" : "\n     * Message that ARC enabled device is connected to invalid port (non-ARC port).\n     ",
    "links" : [ ]
  }, {
    "name" : "OSD_MESSAGE_AVR_VOLUME_CHANGED",
    "type" : "int",
    "comment" : "\n     * Message used by TV to receive volume status from Audio Receiver. It should check volume value\n     * that is retrieved from extra value with the key {@link #EXTRA_MESSAGE_EXTRA_PARAM1}. If the\n     * value is in range of [0,100], it is current volume of Audio Receiver. And there is another\n     * value, {@link #AVR_VOLUME_MUTED}, which is used to inform volume mute.\n     ",
    "links" : [ "#AVR_VOLUME_MUTED", "#EXTRA_MESSAGE_EXTRA_PARAM1" ]
  }, {
    "name" : "EXTRA_MESSAGE_ID",
    "type" : "String",
    "comment" : "\n     * Used as an extra field in the intent {@link #ACTION_OSD_MESSAGE}. Contains the ID of\n     * the message to display on screen.\n     ",
    "links" : [ "#ACTION_OSD_MESSAGE" ]
  }, {
    "name" : "EXTRA_MESSAGE_EXTRA_PARAM1",
    "type" : "String",
    "comment" : "\n     * Used as an extra field in the intent {@link #ACTION_OSD_MESSAGE}. Contains the extra value\n     * of the message.\n     ",
    "links" : [ "#ACTION_OSD_MESSAGE" ]
  }, {
    "name" : "EXTRA_LOCALE",
    "type" : "String",
    "comment" : "\n     * Used as an extra field in the Set Menu Language intent. Contains the requested locale.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "ACTION_ON_ACTIVE_SOURCE_RECOVERED_DISMISS_UI",
    "type" : "String",
    "comment" : "\n     * Broadcast Action: Active Source status was recovered by the device.\n     * <p>Send when device becomes the current active source such that the activity\n     * HdmiCecActiveSourceLostActivity can be finished and cleared from the screen.\n     * <p>Requires {@link android.Manifest.permission#HDMI_CEC} to receive.\n     * @hide\n     ",
    "links" : [ "android.Manifest.permission#HDMI_CEC" ]
  }, {
    "name" : "AVR_VOLUME_MUTED",
    "type" : "int",
    "comment" : "\n     * Volume value for mute state.\n     ",
    "links" : [ ]
  }, {
    "name" : "POWER_STATUS_UNKNOWN",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "POWER_STATUS_ON",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "POWER_STATUS_STANDBY",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "POWER_STATUS_TRANSIENT_TO_ON",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "POWER_STATUS_TRANSIENT_TO_STANDBY",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "RESULT_SUCCESS",
    "type" : "int",
    "comment" : " Control operation is successfully handled by the framework. ",
    "links" : [ ]
  }, {
    "name" : "RESULT_TIMEOUT",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "RESULT_SOURCE_NOT_AVAILABLE",
    "type" : "int",
    "comment" : " Source device that the application is using is not available. ",
    "links" : [ ]
  }, {
    "name" : "RESULT_TARGET_NOT_AVAILABLE",
    "type" : "int",
    "comment" : " Target device that the application is controlling is not available. ",
    "links" : [ ]
  }, {
    "name" : "RESULT_ALREADY_IN_PROGRESS",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "RESULT_EXCEPTION",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "RESULT_INCORRECT_MODE",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "RESULT_COMMUNICATION_FAILED",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "DEVICE_EVENT_ADD_DEVICE",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "DEVICE_EVENT_REMOVE_DEVICE",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "DEVICE_EVENT_UPDATE_DEVICE",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "ONE_TOUCH_RECORD_RECORDING_CURRENTLY_SELECTED_SOURCE",
    "type" : "int",
    "comment" : " Recording currently selected source. Indicates the status of a recording. ",
    "links" : [ ]
  }, {
    "name" : "ONE_TOUCH_RECORD_RECORDING_DIGITAL_SERVICE",
    "type" : "int",
    "comment" : " Recording Digital Service. Indicates the status of a recording. ",
    "links" : [ ]
  }, {
    "name" : "ONE_TOUCH_RECORD_RECORDING_ANALOGUE_SERVICE",
    "type" : "int",
    "comment" : " Recording Analogue Service. Indicates the status of a recording. ",
    "links" : [ ]
  }, {
    "name" : "ONE_TOUCH_RECORD_RECORDING_EXTERNAL_INPUT",
    "type" : "int",
    "comment" : " Recording External input. Indicates the status of a recording. ",
    "links" : [ ]
  }, {
    "name" : "ONE_TOUCH_RECORD_UNABLE_DIGITAL_SERVICE",
    "type" : "int",
    "comment" : " No recording – unable to record Digital Service. No suitable tuner. ",
    "links" : [ ]
  }, {
    "name" : "ONE_TOUCH_RECORD_UNABLE_ANALOGUE_SERVICE",
    "type" : "int",
    "comment" : " No recording – unable to record Analogue Service. No suitable tuner. ",
    "links" : [ ]
  }, {
    "name" : "ONE_TOUCH_RECORD_UNABLE_SELECTED_SERVICE",
    "type" : "int",
    "comment" : "\n     * No recording – unable to select required service. as suitable tuner, but the requested\n     * parameters are invalid or out of range for that tuner.\n     ",
    "links" : [ ]
  }, {
    "name" : "ONE_TOUCH_RECORD_INVALID_EXTERNAL_PLUG_NUMBER",
    "type" : "int",
    "comment" : " No recording – invalid External plug number ",
    "links" : [ ]
  }, {
    "name" : "ONE_TOUCH_RECORD_INVALID_EXTERNAL_PHYSICAL_ADDRESS",
    "type" : "int",
    "comment" : " No recording – invalid External Physical Address ",
    "links" : [ ]
  }, {
    "name" : "ONE_TOUCH_RECORD_UNSUPPORTED_CA",
    "type" : "int",
    "comment" : " No recording – CA system not supported ",
    "links" : [ ]
  }, {
    "name" : "ONE_TOUCH_RECORD_NO_OR_INSUFFICIENT_CA_ENTITLEMENTS",
    "type" : "int",
    "comment" : " No Recording – No or Insufficient CA Entitlements” ",
    "links" : [ ]
  }, {
    "name" : "ONE_TOUCH_RECORD_DISALLOW_TO_COPY",
    "type" : "int",
    "comment" : " No recording – Not allowed to copy source. Source is “copy never”. ",
    "links" : [ ]
  }, {
    "name" : "ONE_TOUCH_RECORD_DISALLOW_TO_FUTHER_COPIES",
    "type" : "int",
    "comment" : " No recording – No further copies allowed ",
    "links" : [ ]
  }, {
    "name" : "ONE_TOUCH_RECORD_NO_MEDIA",
    "type" : "int",
    "comment" : " No recording – No media ",
    "links" : [ ]
  }, {
    "name" : "ONE_TOUCH_RECORD_PLAYING",
    "type" : "int",
    "comment" : " No recording – playing ",
    "links" : [ ]
  }, {
    "name" : "ONE_TOUCH_RECORD_ALREADY_RECORDING",
    "type" : "int",
    "comment" : " No recording – already recording ",
    "links" : [ ]
  }, {
    "name" : "ONE_TOUCH_RECORD_MEDIA_PROTECTED",
    "type" : "int",
    "comment" : " No recording – media protected ",
    "links" : [ ]
  }, {
    "name" : "ONE_TOUCH_RECORD_NO_SOURCE_SIGNAL",
    "type" : "int",
    "comment" : " No recording – no source signal ",
    "links" : [ ]
  }, {
    "name" : "ONE_TOUCH_RECORD_MEDIA_PROBLEM",
    "type" : "int",
    "comment" : " No recording – media problem ",
    "links" : [ ]
  }, {
    "name" : "ONE_TOUCH_RECORD_NOT_ENOUGH_SPACE",
    "type" : "int",
    "comment" : " No recording – not enough space available ",
    "links" : [ ]
  }, {
    "name" : "ONE_TOUCH_RECORD_PARENT_LOCK_ON",
    "type" : "int",
    "comment" : " No recording – Parental Lock On ",
    "links" : [ ]
  }, {
    "name" : "ONE_TOUCH_RECORD_RECORDING_TERMINATED_NORMALLY",
    "type" : "int",
    "comment" : " Recording terminated normally ",
    "links" : [ ]
  }, {
    "name" : "ONE_TOUCH_RECORD_RECORDING_ALREADY_TERMINATED",
    "type" : "int",
    "comment" : " Recording has already terminated ",
    "links" : [ ]
  }, {
    "name" : "ONE_TOUCH_RECORD_OTHER_REASON",
    "type" : "int",
    "comment" : " No recording – other reason ",
    "links" : [ ]
  }, {
    "name" : "ONE_TOUCH_RECORD_PREVIOUS_RECORDING_IN_PROGRESS",
    "type" : "int",
    "comment" : " No recording. Previous recording request in progress. ",
    "links" : [ ]
  }, {
    "name" : "ONE_TOUCH_RECORD_CHECK_RECORDER_CONNECTION",
    "type" : "int",
    "comment" : " No recording. Please check recorder and connection. ",
    "links" : [ ]
  }, {
    "name" : "ONE_TOUCH_RECORD_FAIL_TO_RECORD_DISPLAYED_SCREEN",
    "type" : "int",
    "comment" : " Cannot record currently displayed source. ",
    "links" : [ ]
  }, {
    "name" : "ONE_TOUCH_RECORD_CEC_DISABLED",
    "type" : "int",
    "comment" : " CEC is disabled. ",
    "links" : [ ]
  }, {
    "name" : "TIMER_RECORDING_TYPE_DIGITAL",
    "type" : "int",
    "comment" : " Timer recording type for digital service source. ",
    "links" : [ ]
  }, {
    "name" : "TIMER_RECORDING_TYPE_ANALOGUE",
    "type" : "int",
    "comment" : " Timer recording type for analogue service source. ",
    "links" : [ ]
  }, {
    "name" : "TIMER_RECORDING_TYPE_EXTERNAL",
    "type" : "int",
    "comment" : " Timer recording type for external source. ",
    "links" : [ ]
  }, {
    "name" : "TIMER_STATUS_MEDIA_INFO_PRESENT_NOT_PROTECTED",
    "type" : "int",
    "comment" : " [Timer Status Data/Media Info] - Media present and not protected. ",
    "links" : [ ]
  }, {
    "name" : "TIMER_STATUS_MEDIA_INFO_PRESENT_PROTECTED",
    "type" : "int",
    "comment" : " [Timer Status Data/Media Info] - Media present, but protected. ",
    "links" : [ ]
  }, {
    "name" : "TIMER_STATUS_MEDIA_INFO_NOT_PRESENT",
    "type" : "int",
    "comment" : " [Timer Status Data/Media Info] - Media not present. ",
    "links" : [ ]
  }, {
    "name" : "TIMER_STATUS_PROGRAMMED_INFO_ENOUGH_SPACE",
    "type" : "int",
    "comment" : " [Timer Status Data/Programmed Info] - Enough space available for recording. ",
    "links" : [ ]
  }, {
    "name" : "TIMER_STATUS_PROGRAMMED_INFO_NOT_ENOUGH_SPACE",
    "type" : "int",
    "comment" : " [Timer Status Data/Programmed Info] - Not enough space available for recording. ",
    "links" : [ ]
  }, {
    "name" : "TIMER_STATUS_PROGRAMMED_INFO_MIGHT_NOT_ENOUGH_SPACE",
    "type" : "int",
    "comment" : " [Timer Status Data/Programmed Info] - Might not enough space available for recording. ",
    "links" : [ ]
  }, {
    "name" : "TIMER_STATUS_PROGRAMMED_INFO_NO_MEDIA_INFO",
    "type" : "int",
    "comment" : " [Timer Status Data/Programmed Info] - No media info available. ",
    "links" : [ ]
  }, {
    "name" : "TIMER_STATUS_NOT_PROGRAMMED_NO_FREE_TIME",
    "type" : "int",
    "comment" : " [Timer Status Data/Not Programmed Error Info] - No free timer available. ",
    "links" : [ ]
  }, {
    "name" : "TIMER_STATUS_NOT_PROGRAMMED_DATE_OUT_OF_RANGE",
    "type" : "int",
    "comment" : " [Timer Status Data/Not Programmed Error Info] - Date out of range. ",
    "links" : [ ]
  }, {
    "name" : "TIMER_STATUS_NOT_PROGRAMMED_INVALID_SEQUENCE",
    "type" : "int",
    "comment" : " [Timer Status Data/Not Programmed Error Info] - Recording Sequence error. ",
    "links" : [ ]
  }, {
    "name" : "TIMER_STATUS_NOT_PROGRAMMED_INVALID_EXTERNAL_PLUG_NUMBER",
    "type" : "int",
    "comment" : " [Timer Status Data/Not Programmed Error Info] - Invalid External Plug Number. ",
    "links" : [ ]
  }, {
    "name" : "TIMER_STATUS_NOT_PROGRAMMED_INVALID_EXTERNAL_PHYSICAL_NUMBER",
    "type" : "int",
    "comment" : " [Timer Status Data/Not Programmed Error Info] - Invalid External Physical Address. ",
    "links" : [ ]
  }, {
    "name" : "TIMER_STATUS_NOT_PROGRAMMED_CA_NOT_SUPPORTED",
    "type" : "int",
    "comment" : " [Timer Status Data/Not Programmed Error Info] - CA system not supported. ",
    "links" : [ ]
  }, {
    "name" : "TIMER_STATUS_NOT_PROGRAMMED_NO_CA_ENTITLEMENTS",
    "type" : "int",
    "comment" : " [Timer Status Data/Not Programmed Error Info] - No or insufficient CA Entitlements. ",
    "links" : [ ]
  }, {
    "name" : "TIMER_STATUS_NOT_PROGRAMMED_UNSUPPORTED_RESOLUTION",
    "type" : "int",
    "comment" : " [Timer Status Data/Not Programmed Error Info] - Does not support resolution. ",
    "links" : [ ]
  }, {
    "name" : "TIMER_STATUS_NOT_PROGRAMMED_PARENTAL_LOCK_ON",
    "type" : "int",
    "comment" : " [Timer Status Data/Not Programmed Error Info] - Parental Lock On. ",
    "links" : [ ]
  }, {
    "name" : "TIMER_STATUS_NOT_PROGRAMMED_CLOCK_FAILURE",
    "type" : "int",
    "comment" : " [Timer Status Data/Not Programmed Error Info] - Clock Failure. ",
    "links" : [ ]
  }, {
    "name" : "TIMER_STATUS_NOT_PROGRAMMED_DUPLICATED",
    "type" : "int",
    "comment" : " [Timer Status Data/Not Programmed Error Info] - Duplicate: already programmed. ",
    "links" : [ ]
  }, {
    "name" : "TIMER_RECORDING_RESULT_EXTRA_NO_ERROR",
    "type" : "int",
    "comment" : " No extra error. ",
    "links" : [ ]
  }, {
    "name" : "TIMER_RECORDING_RESULT_EXTRA_CHECK_RECORDER_CONNECTION",
    "type" : "int",
    "comment" : " No timer recording - check recorder and connection. ",
    "links" : [ ]
  }, {
    "name" : "TIMER_RECORDING_RESULT_EXTRA_FAIL_TO_RECORD_SELECTED_SOURCE",
    "type" : "int",
    "comment" : " No timer recording - cannot record selected source. ",
    "links" : [ ]
  }, {
    "name" : "TIMER_RECORDING_RESULT_EXTRA_CEC_DISABLED",
    "type" : "int",
    "comment" : " CEC is disabled. ",
    "links" : [ ]
  }, {
    "name" : "CLEAR_TIMER_STATUS_TIMER_NOT_CLEARED_RECORDING",
    "type" : "int",
    "comment" : " Timer not cleared – recording. ",
    "links" : [ ]
  }, {
    "name" : "CLEAR_TIMER_STATUS_TIMER_NOT_CLEARED_NO_MATCHING",
    "type" : "int",
    "comment" : " Timer not cleared – no matching. ",
    "links" : [ ]
  }, {
    "name" : "CLEAR_TIMER_STATUS_TIMER_NOT_CLEARED_NO_INFO_AVAILABLE",
    "type" : "int",
    "comment" : " Timer not cleared – no info available. ",
    "links" : [ ]
  }, {
    "name" : "CLEAR_TIMER_STATUS_TIMER_CLEARED",
    "type" : "int",
    "comment" : " Timer cleared. ",
    "links" : [ ]
  }, {
    "name" : "CLEAR_TIMER_STATUS_CHECK_RECORDER_CONNECTION",
    "type" : "int",
    "comment" : " Clear timer error - check recorder and connection. ",
    "links" : [ ]
  }, {
    "name" : "CLEAR_TIMER_STATUS_FAIL_TO_CLEAR_SELECTED_SOURCE",
    "type" : "int",
    "comment" : " Clear timer error - cannot clear timer for selected source. ",
    "links" : [ ]
  }, {
    "name" : "CLEAR_TIMER_STATUS_CEC_DISABLE",
    "type" : "int",
    "comment" : " Clear timer error - CEC is disabled. ",
    "links" : [ ]
  }, {
    "name" : "CONTROL_STATE_CHANGED_REASON_START",
    "type" : "int",
    "comment" : " The HdmiControlService is started. ",
    "links" : [ ]
  }, {
    "name" : "CONTROL_STATE_CHANGED_REASON_SETTING",
    "type" : "int",
    "comment" : " The state of HdmiControlService is changed by changing of settings. ",
    "links" : [ ]
  }, {
    "name" : "CONTROL_STATE_CHANGED_REASON_WAKEUP",
    "type" : "int",
    "comment" : " The HdmiControlService is enabled to wake up. ",
    "links" : [ ]
  }, {
    "name" : "CONTROL_STATE_CHANGED_REASON_STANDBY",
    "type" : "int",
    "comment" : " The HdmiControlService will be disabled to standby. ",
    "links" : [ ]
  }, {
    "name" : "HDMI_CEC_CONTROL_ENABLED",
    "type" : "int",
    "comment" : "\n     * HDMI CEC enabled.\n     *\n     * @see HdmiControlManager#CEC_SETTING_NAME_HDMI_CEC_ENABLED\n     ",
    "links" : [ ]
  }, {
    "name" : "HDMI_CEC_CONTROL_DISABLED",
    "type" : "int",
    "comment" : "\n     * HDMI CEC disabled.\n     *\n     * @see HdmiControlManager#CEC_SETTING_NAME_HDMI_CEC_ENABLED\n     ",
    "links" : [ ]
  }, {
    "name" : "HDMI_CEC_VERSION_1_4_B",
    "type" : "int",
    "comment" : "\n     * Version constant for HDMI-CEC v1.4b.\n     *\n     * @see HdmiControlManager#CEC_SETTING_NAME_HDMI_CEC_VERSION\n     ",
    "links" : [ ]
  }, {
    "name" : "HDMI_CEC_VERSION_2_0",
    "type" : "int",
    "comment" : "\n     * Version constant for HDMI-CEC v2.0.\n     *\n     * @see HdmiControlManager#CEC_SETTING_NAME_HDMI_CEC_VERSION\n     ",
    "links" : [ ]
  }, {
    "name" : "ROUTING_CONTROL_ENABLED",
    "type" : "int",
    "comment" : "\n     * Routing Control feature enabled.\n     *\n     * @see HdmiControlManager#CEC_SETTING_NAME_ROUTING_CONTROL\n     ",
    "links" : [ ]
  }, {
    "name" : "ROUTING_CONTROL_DISABLED",
    "type" : "int",
    "comment" : "\n     * Routing Control feature disabled.\n     *\n     * @see HdmiControlManager#CEC_SETTING_NAME_ROUTING_CONTROL\n     ",
    "links" : [ ]
  }, {
    "name" : "SOUNDBAR_MODE_ENABLED",
    "type" : "int",
    "comment" : "\n     * Soundbar mode feature enabled.\n     *\n     * @see HdmiControlManager#CEC_SETTING_NAME_SOUNDBAR_MODE\n     ",
    "links" : [ ]
  }, {
    "name" : "SOUNDBAR_MODE_DISABLED",
    "type" : "int",
    "comment" : "\n     * Soundbar mode feature disabled.\n     *\n     * @see HdmiControlManager#CEC_SETTING_NAME_SOUNDBAR_MODE\n     ",
    "links" : [ ]
  }, {
    "name" : "POWER_CONTROL_MODE_TV",
    "type" : "String",
    "comment" : "\n     * Send CEC power control messages to TV only:\n     * Upon going to sleep, send {@code <Standby>} to TV only.\n     * Upon waking up, attempt to turn on the TV via {@code <One Touch Play>} but do not turn on the\n     * Audio system via {@code <System Audio Mode Request>}.\n     *\n     * @see HdmiControlManager#CEC_SETTING_NAME_POWER_CONTROL_MODE\n     ",
    "links" : [ ]
  }, {
    "name" : "POWER_CONTROL_MODE_TV_AND_AUDIO_SYSTEM",
    "type" : "String",
    "comment" : "\n     * Send CEC power control messages to TV and Audio System:\n     * Upon going to sleep, send {@code <Standby>} to TV and Audio system.\n     * Upon waking up, attempt to turn on the TV via {@code <One Touch Play>} and attempt to turn on\n     * the Audio system via {@code <System Audio Mode Request>}.\n     *\n     * @see HdmiControlManager#CEC_SETTING_NAME_POWER_CONTROL_MODE\n     ",
    "links" : [ ]
  }, {
    "name" : "POWER_CONTROL_MODE_BROADCAST",
    "type" : "String",
    "comment" : "\n     * Broadcast CEC power control messages to all devices in the network:\n     * Upon going to sleep, send {@code <Standby>} to all devices in the network.\n     * Upon waking up, attempt to turn on the TV via {@code <One Touch Play>} and attempt to turn on\n     * the Audio system via {@code <System Audio Mode Request>}.\n     *\n     * @see HdmiControlManager#CEC_SETTING_NAME_POWER_CONTROL_MODE\n     ",
    "links" : [ ]
  }, {
    "name" : "POWER_CONTROL_MODE_NONE",
    "type" : "String",
    "comment" : "\n     * Don't send any CEC power control messages:\n     * Upon going to sleep, do not send any {@code <Standby>} message.\n     * Upon waking up, do not turn on the TV via {@code <One Touch Play>} and do not turn on the\n     * Audio system via {@code <System Audio Mode Request>}.\n     *\n     * @see HdmiControlManager#CEC_SETTING_NAME_POWER_CONTROL_MODE\n     ",
    "links" : [ ]
  }, {
    "name" : "POWER_STATE_CHANGE_ON_ACTIVE_SOURCE_LOST_NONE",
    "type" : "String",
    "comment" : "\n     * No action to be taken.\n     *\n     * @see HdmiControlManager#CEC_SETTING_NAME_POWER_STATE_CHANGE_ON_ACTIVE_SOURCE_LOST\n     ",
    "links" : [ ]
  }, {
    "name" : "POWER_STATE_CHANGE_ON_ACTIVE_SOURCE_LOST_STANDBY_NOW",
    "type" : "String",
    "comment" : "\n     * Go to standby immediately.\n     *\n     * @see HdmiControlManager#CEC_SETTING_NAME_POWER_STATE_CHANGE_ON_ACTIVE_SOURCE_LOST\n     ",
    "links" : [ ]
  }, {
    "name" : "SYSTEM_AUDIO_CONTROL_ENABLED",
    "type" : "int",
    "comment" : "\n     * System Audio Control enabled.\n     *\n     * @see HdmiControlManager#CEC_SETTING_NAME_SYSTEM_AUDIO_CONTROL\n     ",
    "links" : [ ]
  }, {
    "name" : "SYSTEM_AUDIO_CONTROL_DISABLED",
    "type" : "int",
    "comment" : "\n     * System Audio Control disabled.\n     *\n     * @see HdmiControlManager#CEC_SETTING_NAME_SYSTEM_AUDIO_CONTROL\n     ",
    "links" : [ ]
  }, {
    "name" : "SYSTEM_AUDIO_MODE_MUTING_ENABLED",
    "type" : "int",
    "comment" : "\n     * System Audio Mode muting enabled.\n     *\n     * @see HdmiControlManager#CEC_SETTING_NAME_SYSTEM_AUDIO_MODE_MUTING\n     ",
    "links" : [ ]
  }, {
    "name" : "SYSTEM_AUDIO_MODE_MUTING_DISABLED",
    "type" : "int",
    "comment" : "\n     * System Audio Mode muting disabled.\n     *\n     * @see HdmiControlManager#CEC_SETTING_NAME_SYSTEM_AUDIO_MODE_MUTING\n     ",
    "links" : [ ]
  }, {
    "name" : "VOLUME_CONTROL_ENABLED",
    "type" : "int",
    "comment" : "\n     * HDMI CEC enabled.\n     *\n     * @see HdmiControlManager#CEC_SETTING_NAME_VOLUME_CONTROL_MODE\n     ",
    "links" : [ ]
  }, {
    "name" : "VOLUME_CONTROL_DISABLED",
    "type" : "int",
    "comment" : "\n     * HDMI CEC disabled.\n     *\n     * @see HdmiControlManager#CEC_SETTING_NAME_VOLUME_CONTROL_MODE\n     ",
    "links" : [ ]
  }, {
    "name" : "TV_WAKE_ON_ONE_TOUCH_PLAY_ENABLED",
    "type" : "int",
    "comment" : "\n     * TV Wake on One Touch Play enabled.\n     *\n     * @see HdmiControlManager#CEC_SETTING_NAME_TV_WAKE_ON_ONE_TOUCH_PLAY\n     ",
    "links" : [ ]
  }, {
    "name" : "TV_WAKE_ON_ONE_TOUCH_PLAY_DISABLED",
    "type" : "int",
    "comment" : "\n     * TV Wake on One Touch Play disabled.\n     *\n     * @see HdmiControlManager#CEC_SETTING_NAME_TV_WAKE_ON_ONE_TOUCH_PLAY\n     ",
    "links" : [ ]
  }, {
    "name" : "TV_SEND_STANDBY_ON_SLEEP_ENABLED",
    "type" : "int",
    "comment" : "\n     * Sending &lt;Standby&gt; on sleep.\n     *\n     * @see HdmiControlManager#CEC_SETTING_NAME_TV_SEND_STANDBY_ON_SLEEP\n     ",
    "links" : [ ]
  }, {
    "name" : "TV_SEND_STANDBY_ON_SLEEP_DISABLED",
    "type" : "int",
    "comment" : "\n     * Not sending &lt;Standby&gt; on sleep.\n     *\n     * @see HdmiControlManager#CEC_SETTING_NAME_TV_SEND_STANDBY_ON_SLEEP\n     ",
    "links" : [ ]
  }, {
    "name" : "SET_MENU_LANGUAGE_ENABLED",
    "type" : "int",
    "comment" : "\n     * Confirmation dialog should be shown upon receiving the CEC message.\n     *\n     * @see HdmiControlManager#CEC_SETTING_NAME_SET_MENU_LANGUAGE\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "SET_MENU_LANGUAGE_DISABLED",
    "type" : "int",
    "comment" : "\n     * The message should be ignored.\n     *\n     * @see HdmiControlManager#CEC_SETTING_NAME_SET_MENU_LANGUAGE\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "RC_PROFILE_TV_NONE",
    "type" : "int",
    "comment" : "\n     * RC profile none.\n     *\n     * @see HdmiControlManager#CEC_SETTING_NAME_RC_PROFILE_TV\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "RC_PROFILE_TV_ONE",
    "type" : "int",
    "comment" : "\n     * RC profile 1.\n     *\n     * @see HdmiControlManager#CEC_SETTING_NAME_RC_PROFILE_TV\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "RC_PROFILE_TV_TWO",
    "type" : "int",
    "comment" : "\n     * RC profile 2.\n     *\n     * @see HdmiControlManager#CEC_SETTING_NAME_RC_PROFILE_TV\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "RC_PROFILE_TV_THREE",
    "type" : "int",
    "comment" : "\n     * RC profile 3.\n     *\n     * @see HdmiControlManager#CEC_SETTING_NAME_RC_PROFILE_TV\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "RC_PROFILE_TV_FOUR",
    "type" : "int",
    "comment" : "\n     * RC profile 4.\n     *\n     * @see HdmiControlManager#CEC_SETTING_NAME_RC_PROFILE_TV\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "RC_PROFILE_SOURCE_MENU_HANDLED",
    "type" : "int",
    "comment" : "\n     * Handles the menu.\n     *\n     * @see HdmiControlManager#CEC_SETTING_NAME_RC_PROFILE_SOURCE_HANDLES_ROOT_MENU\n     * @see HdmiControlManager#CEC_SETTING_NAME_RC_PROFILE_SOURCE_HANDLES_SETUP_MENU\n     * @see HdmiControlManager#CEC_SETTING_NAME_RC_PROFILE_SOURCE_HANDLES_CONTENTS_MENU\n     * @see HdmiControlManager#CEC_SETTING_NAME_RC_PROFILE_SOURCE_HANDLES_TOP_MENU\n     * @see HdmiControlManager#\n     * CEC_SETTING_NAME_RC_PROFILE_SOURCE_HANDLES_MEDIA_CONTEXT_SENSITIVE_MENU\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "RC_PROFILE_SOURCE_MENU_NOT_HANDLED",
    "type" : "int",
    "comment" : "\n     * Doesn't handle the menu.\n     *\n     * @see HdmiControlManager#CEC_SETTING_NAME_RC_PROFILE_SOURCE_HANDLES_ROOT_MENU\n     * @see HdmiControlManager#CEC_SETTING_NAME_RC_PROFILE_SOURCE_HANDLES_SETUP_MENU\n     * @see HdmiControlManager#CEC_SETTING_NAME_RC_PROFILE_SOURCE_HANDLES_CONTENTS_MENU\n     * @see HdmiControlManager#CEC_SETTING_NAME_RC_PROFILE_SOURCE_HANDLES_TOP_MENU\n     * @see HdmiControlManager#\n     * CEC_SETTING_NAME_RC_PROFILE_SOURCE_HANDLES_MEDIA_CONTEXT_SENSITIVE_MENU\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "QUERY_SAD_ENABLED",
    "type" : "int",
    "comment" : "\n     * Query the SAD.\n     *\n     * @see HdmiControlManager#CEC_SETTING_NAME_QUERY_SAD_LPCM\n     * @see HdmiControlManager#CEC_SETTING_NAME_QUERY_SAD_DD\n     * @see HdmiControlManager#CEC_SETTING_NAME_QUERY_SAD_MPEG1\n     * @see HdmiControlManager#CEC_SETTING_NAME_QUERY_SAD_MP3\n     * @see HdmiControlManager#CEC_SETTING_NAME_QUERY_SAD_MPEG2\n     * @see HdmiControlManager#CEC_SETTING_NAME_QUERY_SAD_AAC\n     * @see HdmiControlManager#CEC_SETTING_NAME_QUERY_SAD_DTS\n     * @see HdmiControlManager#CEC_SETTING_NAME_QUERY_SAD_ATRAC\n     * @see HdmiControlManager#CEC_SETTING_NAME_QUERY_SAD_ONEBITAUDIO\n     * @see HdmiControlManager#CEC_SETTING_NAME_QUERY_SAD_DDP\n     * @see HdmiControlManager#CEC_SETTING_NAME_QUERY_SAD_DTSHD\n     * @see HdmiControlManager#CEC_SETTING_NAME_QUERY_SAD_TRUEHD\n     * @see HdmiControlManager#CEC_SETTING_NAME_QUERY_SAD_DST\n     * @see HdmiControlManager#CEC_SETTING_NAME_QUERY_SAD_WMAPRO\n     * @see HdmiControlManager#CEC_SETTING_NAME_QUERY_SAD_MAX\n     ",
    "links" : [ ]
  }, {
    "name" : "QUERY_SAD_DISABLED",
    "type" : "int",
    "comment" : "\n     * Don't query the SAD.\n     *\n     * @see HdmiControlManager#CEC_SETTING_NAME_QUERY_SAD_LPCM\n     * @see HdmiControlManager#CEC_SETTING_NAME_QUERY_SAD_DD\n     * @see HdmiControlManager#CEC_SETTING_NAME_QUERY_SAD_MPEG1\n     * @see HdmiControlManager#CEC_SETTING_NAME_QUERY_SAD_MP3\n     * @see HdmiControlManager#CEC_SETTING_NAME_QUERY_SAD_MPEG2\n     * @see HdmiControlManager#CEC_SETTING_NAME_QUERY_SAD_AAC\n     * @see HdmiControlManager#CEC_SETTING_NAME_QUERY_SAD_DTS\n     * @see HdmiControlManager#CEC_SETTING_NAME_QUERY_SAD_ATRAC\n     * @see HdmiControlManager#CEC_SETTING_NAME_QUERY_SAD_ONEBITAUDIO\n     * @see HdmiControlManager#CEC_SETTING_NAME_QUERY_SAD_DDP\n     * @see HdmiControlManager#CEC_SETTING_NAME_QUERY_SAD_DTSHD\n     * @see HdmiControlManager#CEC_SETTING_NAME_QUERY_SAD_TRUEHD\n     * @see HdmiControlManager#CEC_SETTING_NAME_QUERY_SAD_DST\n     * @see HdmiControlManager#CEC_SETTING_NAME_QUERY_SAD_WMAPRO\n     * @see HdmiControlManager#CEC_SETTING_NAME_QUERY_SAD_MAX\n     ",
    "links" : [ ]
  }, {
    "name" : "EARC_FEATURE_ENABLED",
    "type" : "int",
    "comment" : "\n     * eARC enabled.\n     *\n     * @see HdmiControlManager#SETTING_NAME_EARC_ENABLED\n     ",
    "links" : [ ]
  }, {
    "name" : "EARC_FEATURE_DISABLED",
    "type" : "int",
    "comment" : "\n     * eARC disabled.\n     *\n     * @see HdmiControlManager#SETTING_NAME_EARC_ENABLED\n     ",
    "links" : [ ]
  }, {
    "name" : "CEC_SETTING_NAME_HDMI_CEC_ENABLED",
    "type" : "String",
    "comment" : "\n     * Name of a setting deciding whether the CEC is enabled.\n     *\n     * @see HdmiControlManager#setHdmiCecEnabled(int)\n     ",
    "links" : [ ]
  }, {
    "name" : "CEC_SETTING_NAME_HDMI_CEC_VERSION",
    "type" : "String",
    "comment" : "\n     * Name of a setting controlling the version of HDMI-CEC used.\n     *\n     * @see HdmiControlManager#setHdmiCecVersion(int)\n     ",
    "links" : [ ]
  }, {
    "name" : "CEC_SETTING_NAME_ROUTING_CONTROL",
    "type" : "String",
    "comment" : "\n     * Name of a setting deciding whether the Routing Control feature is enabled.\n     *\n     * @see HdmiControlManager#setRoutingControl(int)\n     ",
    "links" : [ ]
  }, {
    "name" : "CEC_SETTING_NAME_SOUNDBAR_MODE",
    "type" : "String",
    "comment" : "\n     * Name of a setting deciding whether the Soundbar mode feature is enabled.\n     * Before exposing this setting make sure the hardware supports it, otherwise, you may\n     * experience multiple issues.\n     *\n     * @see HdmiControlManager#setSoundbarMode(int)\n     ",
    "links" : [ ]
  }, {
    "name" : "CEC_SETTING_NAME_POWER_CONTROL_MODE",
    "type" : "String",
    "comment" : "\n     * Name of a setting deciding on the power control mode.\n     *\n     * @see HdmiControlManager#setPowerControlMode(String)\n     ",
    "links" : [ ]
  }, {
    "name" : "CEC_SETTING_NAME_POWER_STATE_CHANGE_ON_ACTIVE_SOURCE_LOST",
    "type" : "String",
    "comment" : "\n     * Name of a setting deciding on power state action when losing Active Source.\n     *\n     * @see HdmiControlManager#setPowerStateChangeOnActiveSourceLost(String)\n     ",
    "links" : [ ]
  }, {
    "name" : "CEC_SETTING_NAME_SYSTEM_AUDIO_CONTROL",
    "type" : "String",
    "comment" : "\n     * Name of a setting deciding whether System Audio Control is enabled.\n     *\n     * @see HdmiControlManager#setSystemAudioControl(int)\n     ",
    "links" : [ ]
  }, {
    "name" : "CEC_SETTING_NAME_SYSTEM_AUDIO_MODE_MUTING",
    "type" : "String",
    "comment" : "\n     * Name of a setting deciding whether System Audio Muting is allowed.\n     *\n     * @see HdmiControlManager#setSystemAudioModeMuting(int)\n     ",
    "links" : [ ]
  }, {
    "name" : "CEC_SETTING_NAME_VOLUME_CONTROL_MODE",
    "type" : "String",
    "comment" : "\n     * Controls whether volume control commands via HDMI CEC are enabled.\n     *\n     * <p>Effects on different device types:\n     * <table>\n     *     <tr><th>HDMI CEC device type</th><th>0: disabled</th><th>1: enabled</th></tr>\n     *     <tr>\n     *         <td>TV (type: 0)</td>\n     *         <td>Per CEC specification.</td>\n     *         <td>TV changes system volume. TV no longer reacts to incoming volume changes\n     *         via {@code <User Control Pressed>}. TV no longer handles {@code <Report Audio\n     *         Status>}.</td>\n     *     </tr>\n     *     <tr>\n     *         <td>Playback device (type: 4)</td>\n     *         <td>Device sends volume commands to TV/Audio system via {@code <User Control\n     *         Pressed>}</td>\n     *         <td>Device does not send volume commands via {@code <User Control Pressed>}.</td>\n     *     </tr>\n     *     <tr>\n     *         <td>Audio device (type: 5)</td>\n     *         <td>Full \"System Audio Control\" capabilities.</td>\n     *         <td>Audio device no longer reacts to incoming {@code <User Control Pressed>}\n     *         volume commands. Audio device no longer reports volume changes via {@code\n     *         <Report Audio Status>}.</td>\n     *     </tr>\n     * </table>\n     *\n     * <p> Due to the resulting behavior, usage on TV and Audio devices is discouraged.\n     *\n     * @see HdmiControlManager#setHdmiCecVolumeControlEnabled(int)\n     ",
    "links" : [ ]
  }, {
    "name" : "CEC_SETTING_NAME_TV_WAKE_ON_ONE_TOUCH_PLAY",
    "type" : "String",
    "comment" : "\n     * Name of a setting deciding whether the TV will automatically turn on upon reception\n     * of the CEC command &lt;Text View On&gt; or &lt;Image View On&gt;.\n     *\n     * @see HdmiControlManager#setTvWakeOnOneTouchPlay(int)\n     ",
    "links" : [ ]
  }, {
    "name" : "CEC_SETTING_NAME_TV_SEND_STANDBY_ON_SLEEP",
    "type" : "String",
    "comment" : "\n     * Name of a setting deciding whether the TV will also turn off other CEC devices\n     * when it goes to standby mode.\n     *\n     * @see HdmiControlManager#setTvSendStandbyOnSleep(int)\n     ",
    "links" : [ ]
  }, {
    "name" : "CEC_SETTING_NAME_SET_MENU_LANGUAGE",
    "type" : "String",
    "comment" : "\n     * Name of a setting deciding whether {@code <Set Menu Language>} message should be\n     * handled by the framework or ignored.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "CEC_SETTING_NAME_RC_PROFILE_TV",
    "type" : "String",
    "comment" : "\n     * Name of a setting representing the RC profile of a TV panel.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "CEC_SETTING_NAME_RC_PROFILE_SOURCE_HANDLES_ROOT_MENU",
    "type" : "String",
    "comment" : "\n     * Name of a setting representing the RC profile parameter defining if a source handles the root\n     * menu.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "CEC_SETTING_NAME_RC_PROFILE_SOURCE_HANDLES_SETUP_MENU",
    "type" : "String",
    "comment" : "\n     * Name of a setting representing the RC profile parameter defining if a source handles the\n     * setup menu.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "CEC_SETTING_NAME_RC_PROFILE_SOURCE_HANDLES_CONTENTS_MENU",
    "type" : "String",
    "comment" : "\n     * Name of a setting representing the RC profile parameter defining if a source handles the\n     * contents menu.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "CEC_SETTING_NAME_RC_PROFILE_SOURCE_HANDLES_TOP_MENU",
    "type" : "String",
    "comment" : "\n     * Name of a setting representing the RC profile parameter defining if a source handles the top\n     * menu.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "CEC_SETTING_NAME_RC_PROFILE_SOURCE_HANDLES_MEDIA_CONTEXT_SENSITIVE_MENU",
    "type" : "String",
    "comment" : "\n     * Name of a setting representing the RC profile parameter defining if a source handles the\n     * media context sensitive menu.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "CEC_SETTING_NAME_QUERY_SAD_LPCM",
    "type" : "String",
    "comment" : "\n     * Name of a setting representing whether the Short Audio Descriptor (SAD) for the LPCM codec\n     * (0x1) should be queried or not.\n     *\n     * @see HdmiControlManager#setSadPresenceInQuery(String, int)\n     ",
    "links" : [ ]
  }, {
    "name" : "CEC_SETTING_NAME_QUERY_SAD_DD",
    "type" : "String",
    "comment" : "\n     * Name of a setting representing whether the Short Audio Descriptor (SAD) for the DD codec\n     * (0x2) should be queried or not.\n     *\n     * @see HdmiControlManager#setSadPresenceInQuery(String, int)\n     ",
    "links" : [ ]
  }, {
    "name" : "CEC_SETTING_NAME_QUERY_SAD_MPEG1",
    "type" : "String",
    "comment" : "\n     * Name of a setting representing whether the Short Audio Descriptor (SAD) for the MPEG1 codec\n     * (0x3) should be queried or not.\n     *\n     * @see HdmiControlManager#setSadPresenceInQuery(String, int)\n     ",
    "links" : [ ]
  }, {
    "name" : "CEC_SETTING_NAME_QUERY_SAD_MP3",
    "type" : "String",
    "comment" : "\n     * Name of a setting representing whether the Short Audio Descriptor (SAD) for the MP3 codec\n     * (0x4) should be queried or not.\n     *\n     * @see HdmiControlManager#setSadPresenceInQuery(String, int)\n     ",
    "links" : [ ]
  }, {
    "name" : "CEC_SETTING_NAME_QUERY_SAD_MPEG2",
    "type" : "String",
    "comment" : "\n     * Name of a setting representing whether the Short Audio Descriptor (SAD) for the MPEG2 codec\n     * (0x5) should be queried or not.\n     *\n     * @see HdmiControlManager#setSadPresenceInQuery(String, int)\n     ",
    "links" : [ ]
  }, {
    "name" : "CEC_SETTING_NAME_QUERY_SAD_AAC",
    "type" : "String",
    "comment" : "\n     * Name of a setting representing whether the Short Audio Descriptor (SAD) for the AAC codec\n     * (0x6) should be queried or not.\n     *\n     * @see HdmiControlManager#setSadPresenceInQuery(String, int)\n     ",
    "links" : [ ]
  }, {
    "name" : "CEC_SETTING_NAME_QUERY_SAD_DTS",
    "type" : "String",
    "comment" : "\n     * Name of a setting representing whether the Short Audio Descriptor (SAD) for the DTS codec\n     * (0x7) should be queried or not.\n     *\n     * @see HdmiControlManager#setSadPresenceInQuery(String, int)\n     ",
    "links" : [ ]
  }, {
    "name" : "CEC_SETTING_NAME_QUERY_SAD_ATRAC",
    "type" : "String",
    "comment" : "\n     * Name of a setting representing whether the Short Audio Descriptor (SAD) for the ATRAC codec\n     * (0x8) should be queried or not.\n     *\n     * @see HdmiControlManager#setSadPresenceInQuery(String, int)\n     ",
    "links" : [ ]
  }, {
    "name" : "CEC_SETTING_NAME_QUERY_SAD_ONEBITAUDIO",
    "type" : "String",
    "comment" : "\n     * Name of a setting representing whether the Short Audio Descriptor (SAD) for the ONEBITAUDIO\n     * codec (0x9) should be queried or not.\n     *\n     * @see HdmiControlManager#setSadPresenceInQuery(String, int)\n     ",
    "links" : [ ]
  }, {
    "name" : "CEC_SETTING_NAME_QUERY_SAD_DDP",
    "type" : "String",
    "comment" : "\n     * Name of a setting representing whether the Short Audio Descriptor (SAD) for the DDP codec\n     * (0xA) should be queried or not.\n     *\n     * @see HdmiControlManager#setSadPresenceInQuery(String, int)\n     ",
    "links" : [ ]
  }, {
    "name" : "CEC_SETTING_NAME_QUERY_SAD_DTSHD",
    "type" : "String",
    "comment" : "\n     * Name of a setting representing whether the Short Audio Descriptor (SAD) for the DTSHD codec\n     * (0xB) should be queried or not.\n     *\n     * @see HdmiControlManager#setSadPresenceInQuery(String, int)\n     ",
    "links" : [ ]
  }, {
    "name" : "CEC_SETTING_NAME_QUERY_SAD_TRUEHD",
    "type" : "String",
    "comment" : "\n     * Name of a setting representing whether the Short Audio Descriptor (SAD) for the TRUEHD codec\n     * (0xC) should be queried or not.\n     *\n     * @see HdmiControlManager#setSadPresenceInQuery(String, int)\n     ",
    "links" : [ ]
  }, {
    "name" : "CEC_SETTING_NAME_QUERY_SAD_DST",
    "type" : "String",
    "comment" : "\n     * Name of a setting representing whether the Short Audio Descriptor (SAD) for the DST codec\n     * (0xD) should be queried or not.\n     *\n     * @see HdmiControlManager#setSadPresenceInQuery(String, int)\n     ",
    "links" : [ ]
  }, {
    "name" : "CEC_SETTING_NAME_QUERY_SAD_WMAPRO",
    "type" : "String",
    "comment" : "\n     * Name of a setting representing whether the Short Audio Descriptor (SAD) for the WMAPRO codec\n     * (0xE) should be queried or not.\n     *\n     * @see HdmiControlManager#setSadPresenceInQuery(String, int)\n     ",
    "links" : [ ]
  }, {
    "name" : "CEC_SETTING_NAME_QUERY_SAD_MAX",
    "type" : "String",
    "comment" : "\n     * Name of a setting representing whether the Short Audio Descriptor (SAD) for the MAX codec\n     * (0xF) should be queried or not.\n     *\n     * @see HdmiControlManager#setSadPresenceInQuery(String, int)\n     ",
    "links" : [ ]
  }, {
    "name" : "SETTING_NAME_EARC_ENABLED",
    "type" : "String",
    "comment" : "\n     * Name of a setting representing whether eARC is enabled or not.\n     *\n     * @see HdmiControlManager#setEarcEnabled(int)\n     ",
    "links" : [ ]
  }, {
    "name" : "mHasPlaybackDevice",
    "type" : "boolean",
    "comment" : " True if we have a logical device of type playback hosted in the system.",
    "links" : [ ]
  }, {
    "name" : "mHasTvDevice",
    "type" : "boolean",
    "comment" : " True if we have a logical device of type TV hosted in the system.",
    "links" : [ ]
  }, {
    "name" : "mHasAudioSystemDevice",
    "type" : "boolean",
    "comment" : " True if we have a logical device of type audio system hosted in the system.",
    "links" : [ ]
  }, {
    "name" : "mHasSwitchDevice",
    "type" : "boolean",
    "comment" : " True if we have a logical device of type audio system hosted in the system.",
    "links" : [ ]
  }, {
    "name" : "mIsSwitchDevice",
    "type" : "boolean",
    "comment" : " True if it's a switch device.",
    "links" : [ ]
  }, {
    "name" : "mHotplugEventListeners",
    "type" : "ArrayMap<HotplugEventListener, IHdmiHotplugEventListener>",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mHdmiControlStatusChangeListeners",
    "type" : "ArrayMap<HdmiControlStatusChangeListener, IHdmiControlStatusChangeListener>",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mHdmiCecVolumeControlFeatureListeners",
    "type" : "ArrayMap<HdmiCecVolumeControlFeatureListener, IHdmiCecVolumeControlFeatureListener>",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mCecSettingChangeListeners",
    "type" : "ArrayMap<String, ArrayMap<CecSettingChangeListener, IHdmiCecSettingChangeListener>>",
    "comment" : "",
    "links" : [ ]
  } ],
  "methods" : [ {
    "name" : "private void setLocalPhysicalAddress(int physicalAddress)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private int getLocalPhysicalAddress()",
    "returnType" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private static boolean hasDeviceType(int[] types, int type)",
    "returnType" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public HdmiClient getClient(int type)",
    "returnType" : "HdmiClient",
    "comment" : "\n     * Gets an object that represents an HDMI-CEC logical device of a specified type.\n     *\n     * @param type CEC device type\n     * @return {@link HdmiClient} instance. {@code null} on failure.\n     * See {@link HdmiDeviceInfo#DEVICE_PLAYBACK}\n     * See {@link HdmiDeviceInfo#DEVICE_TV}\n     * See {@link HdmiDeviceInfo#DEVICE_AUDIO_SYSTEM}\n     ",
    "links" : [ "android.hardware.hdmi.HdmiDeviceInfo#DEVICE_PLAYBACK", "android.hardware.hdmi.HdmiDeviceInfo#DEVICE_AUDIO_SYSTEM", "android.hardware.hdmi.HdmiClient", "android.hardware.hdmi.HdmiDeviceInfo#DEVICE_TV" ]
  }, {
    "name" : "public HdmiPlaybackClient getPlaybackClient()",
    "returnType" : "HdmiPlaybackClient",
    "comment" : "\n     * Gets an object that represents an HDMI-CEC logical device of type playback on the system.\n     *\n     * <p>Used to send HDMI control messages to other devices like TV or audio amplifier through\n     * HDMI bus. It is also possible to communicate with other logical devices hosted in the same\n     * system if the system is configured to host more than one type of HDMI-CEC logical devices.\n     *\n     * @return {@link HdmiPlaybackClient} instance. {@code null} on failure.\n     ",
    "links" : [ "android.hardware.hdmi.HdmiPlaybackClient" ]
  }, {
    "name" : "public HdmiTvClient getTvClient()",
    "returnType" : "HdmiTvClient",
    "comment" : "\n     * Gets an object that represents an HDMI-CEC logical device of type TV on the system.\n     *\n     * <p>Used to send HDMI control messages to other devices and manage them through\n     * HDMI bus. It is also possible to communicate with other logical devices hosted in the same\n     * system if the system is configured to host more than one type of HDMI-CEC logical devices.\n     *\n     * @return {@link HdmiTvClient} instance. {@code null} on failure.\n     ",
    "links" : [ "android.hardware.hdmi.HdmiTvClient" ]
  }, {
    "name" : "public HdmiAudioSystemClient getAudioSystemClient()",
    "returnType" : "HdmiAudioSystemClient",
    "comment" : "\n     * Gets an object that represents an HDMI-CEC logical device of type audio system on the system.\n     *\n     * <p>Used to send HDMI control messages to other devices like TV through HDMI bus. It is also\n     * possible to communicate with other logical devices hosted in the same system if the system is\n     * configured to host more than one type of HDMI-CEC logical devices.\n     *\n     * @return {@link HdmiAudioSystemClient} instance. {@code null} on failure.\n     *\n     * @hide\n     ",
    "links" : [ "android.hardware.hdmi.HdmiAudioSystemClient" ]
  }, {
    "name" : "public HdmiSwitchClient getSwitchClient()",
    "returnType" : "HdmiSwitchClient",
    "comment" : "\n     * Gets an object that represents an HDMI-CEC logical device of type switch on the system.\n     *\n     * <p>Used to send HDMI control messages to other devices (e.g. TVs) through HDMI bus.\n     * It is also possible to communicate with other logical devices hosted in the same\n     * system if the system is configured to host more than one type of HDMI-CEC logical device.\n     *\n     * @return {@link HdmiSwitchClient} instance. {@code null} on failure.\n     ",
    "links" : [ "android.hardware.hdmi.HdmiSwitchClient" ]
  }, {
    "name" : "public List<HdmiDeviceInfo> getConnectedDevices()",
    "returnType" : "List<HdmiDeviceInfo>",
    "comment" : "\n     * Get a snapshot of the real-time status of the devices on the CEC bus.\n     *\n     * @return a list of {@link HdmiDeviceInfo} of the connected CEC devices on the CEC bus. An\n     * empty list will be returned if there is none.\n     ",
    "links" : [ "android.hardware.hdmi.HdmiDeviceInfo" ]
  }, {
    "name" : "public List<HdmiDeviceInfo> getConnectedDevicesList()",
    "returnType" : "List<HdmiDeviceInfo>",
    "comment" : "\n     * @removed\n     * @deprecated Please use {@link #getConnectedDevices()} instead.\n     ",
    "links" : [ "#getConnectedDevices()" ]
  }, {
    "name" : "public List<HdmiPortInfo> getPortInfo()",
    "returnType" : "List<HdmiPortInfo>",
    "comment" : "\n     * Get the list of the HDMI ports configuration.\n     *\n     * <p>This returns an empty list when the current device does not have HDMI ports.\n     *\n     * @return a list of {@link HdmiPortInfo}\n     ",
    "links" : [ "android.hardware.hdmi.HdmiPortInfo" ]
  }, {
    "name" : "public void powerOffDevice(@NonNull HdmiDeviceInfo deviceInfo)",
    "returnType" : "void",
    "comment" : "\n     * Power off the target device by sending CEC commands. Note that this device can't be the\n     * current device itself.\n     *\n     * <p>The target device info can be obtained by calling {@link #getConnectedDevicesList()}.\n     *\n     * @param deviceInfo {@link HdmiDeviceInfo} of the device to be powered off.\n     ",
    "links" : [ "#getConnectedDevicesList()", "android.hardware.hdmi.HdmiDeviceInfo" ]
  }, {
    "name" : "public void powerOffRemoteDevice(@NonNull HdmiDeviceInfo deviceInfo)",
    "returnType" : "void",
    "comment" : "\n     * @removed\n     * @deprecated Please use {@link #powerOffDevice(deviceInfo)} instead.\n     ",
    "links" : [ "#powerOffDevice(deviceInfo)" ]
  }, {
    "name" : "public void powerOnDevice(HdmiDeviceInfo deviceInfo)",
    "returnType" : "void",
    "comment" : "\n     * Power on the target device by sending CEC commands. Note that this device can't be the\n     * current device itself.\n     *\n     * <p>The target device info can be obtained by calling {@link #getConnectedDevicesList()}.\n     *\n     * @param deviceInfo {@link HdmiDeviceInfo} of the device to be powered on.\n     *\n     * @hide\n     ",
    "links" : [ "#getConnectedDevicesList()", "android.hardware.hdmi.HdmiDeviceInfo" ]
  }, {
    "name" : "public void powerOnRemoteDevice(HdmiDeviceInfo deviceInfo)",
    "returnType" : "void",
    "comment" : "\n     * @removed\n     * @deprecated Please use {@link #powerOnDevice(deviceInfo)} instead.\n     ",
    "links" : [ "#powerOnDevice(deviceInfo)" ]
  }, {
    "name" : "public void setActiveSource(@NonNull HdmiDeviceInfo deviceInfo)",
    "returnType" : "void",
    "comment" : "\n     * Request the target device to be the new Active Source by sending CEC commands. Note that\n     * this device can't be the current device itself.\n     *\n     * <p>The target device info can be obtained by calling {@link #getConnectedDevicesList()}.\n     *\n     * <p>If the target device responds to the command, the users should see the target device\n     * streaming on their TVs.\n     *\n     * @param deviceInfo HdmiDeviceInfo of the target device\n     ",
    "links" : [ "#getConnectedDevicesList()" ]
  }, {
    "name" : "public void requestRemoteDeviceToBecomeActiveSource(@NonNull HdmiDeviceInfo deviceInfo)",
    "returnType" : "void",
    "comment" : "\n     * @removed\n     * @deprecated Please use {@link #setActiveSource(deviceInfo)} instead.\n     ",
    "links" : [ "#setActiveSource(deviceInfo)" ]
  }, {
    "name" : "public void setStandbyMode(boolean isStandbyModeOn)",
    "returnType" : "void",
    "comment" : "\n     * Controls standby mode of the system. It will also try to turn on/off the connected devices if\n     * necessary.\n     *\n     * @param isStandbyModeOn target status of the system's standby mode\n     ",
    "links" : [ ]
  }, {
    "name" : "public void toggleAndFollowTvPower()",
    "returnType" : "void",
    "comment" : "\n     * For CEC source devices (OTT/STB/Audio system): toggle the power status of the HDMI-connected\n     * display and follow the display's new power status.\n     * For all other devices: no functionality.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean shouldHandleTvPowerKey()",
    "returnType" : "boolean",
    "comment" : "\n     * Determines whether the HDMI CEC stack should handle KEYCODE_TV_POWER.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public void setHdmiCecVolumeControlEnabled(@VolumeControl int hdmiCecVolumeControlEnabled)",
    "returnType" : "void",
    "comment" : "\n     * Controls whether volume control commands via HDMI CEC are enabled.\n     *\n     * <p>When disabled:\n     * <ul>\n     *     <li>the device will not send any HDMI CEC audio messages\n     *     <li>received HDMI CEC audio messages are responded to with {@code <Feature Abort>}\n     * </ul>\n     *\n     * <p>Effects on different device types:\n     * <table>\n     *     <tr><th>HDMI CEC device type</th><th>enabled</th><th>disabled</th></tr>\n     *     <tr>\n     *         <td>TV (type: 0)</td>\n     *         <td>Per CEC specification.</td>\n     *         <td>TV changes system volume. TV no longer reacts to incoming volume changes via\n     *         {@code <User Control Pressed>}. TV no longer handles {@code <Report Audio Status>}\n     *         .</td>\n     *     </tr>\n     *     <tr>\n     *         <td>Playback device (type: 4)</td>\n     *         <td>Device sends volume commands to TV/Audio system via {@code <User Control\n     *         Pressed>}</td><td>Device does not send volume commands via {@code <User Control\n     *         Pressed>}.</td>\n     *     </tr>\n     *     <tr>\n     *         <td>Audio device (type: 5)</td>\n     *         <td>Full \"System Audio Control\" capabilities.</td>\n     *         <td>Audio device no longer reacts to incoming {@code <User Control Pressed>}\n     *         volume commands. Audio device no longer reports volume changes via {@code <Report\n     *         Audio Status>}.</td>\n     *     </tr>\n     * </table>\n     *\n     * <p> Due to the resulting behavior, usage on TV and Audio devices is discouraged.\n     *\n     * @param hdmiCecVolumeControlEnabled target state of HDMI CEC volume control.\n     * @see HdmiControlManager#CEC_SETTING_NAME_VOLUME_CONTROL_MODE\n     ",
    "links" : [ ]
  }, {
    "name" : "public int getHdmiCecVolumeControlEnabled()",
    "returnType" : "int",
    "comment" : "\n     * Returns whether volume changes via HDMI CEC are enabled.\n     *\n     * @see HdmiControlManager#CEC_SETTING_NAME_VOLUME_CONTROL_MODE\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean getSystemAudioMode()",
    "returnType" : "boolean",
    "comment" : "\n     * Gets whether the system is in system audio mode.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public int getPhysicalAddress()",
    "returnType" : "int",
    "comment" : "\n     * Get the physical address of the device.\n     *\n     * <p>Physical address needs to be automatically adjusted when devices are phyiscally or\n     * electrically added or removed from the device tree. Please see HDMI Specification Version\n     * 1.4b 8.7 Physical Address for more details on the address discovery proccess.\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean isDeviceConnected(@NonNull HdmiDeviceInfo targetDevice)",
    "returnType" : "boolean",
    "comment" : "\n     * Check if the target device is connected to the current device.\n     *\n     * <p>The API also returns true if the current device is the target.\n     *\n     * @param targetDevice {@link HdmiDeviceInfo} of the target device.\n     * @return true if {@code targetDevice} is directly or indirectly\n     * connected to the current device.\n     ",
    "links" : [ "android.hardware.hdmi.HdmiDeviceInfo" ]
  }, {
    "name" : "public boolean isRemoteDeviceConnected(@NonNull HdmiDeviceInfo targetDevice)",
    "returnType" : "boolean",
    "comment" : "\n     * @removed\n     * @deprecated Please use {@link #isDeviceConnected(targetDevice)} instead.\n     ",
    "links" : [ "#isDeviceConnected(targetDevice)" ]
  }, {
    "name" : "public void addHotplugEventListener(HotplugEventListener listener)",
    "returnType" : "void",
    "comment" : "\n     * Adds a listener to get informed of {@link HdmiHotplugEvent}.\n     *\n     * <p>To stop getting the notification,\n     * use {@link #removeHotplugEventListener(HotplugEventListener)}.\n     *\n     * Note that each invocation of the callback will be executed on an arbitrary\n     * Binder thread. This means that all callback implementations must be\n     * thread safe. To specify the execution thread, use\n     * {@link addHotplugEventListener(Executor, HotplugEventListener)}.\n     *\n     * @param listener {@link HotplugEventListener} instance\n     * @see HdmiControlManager#removeHotplugEventListener(HotplugEventListener)\n     ",
    "links" : [ "HotplugEventListener", "#removeHotplugEventListener(HotplugEventListener)", "addHotplugEventListener(Executor", "android.hardware.hdmi.HdmiHotplugEvent" ]
  }, {
    "name" : "public void addHotplugEventListener(@NonNull @CallbackExecutor Executor executor, @NonNull HotplugEventListener listener)",
    "returnType" : "void",
    "comment" : "\n     * Adds a listener to get informed of {@link HdmiHotplugEvent}.\n     *\n     * <p>To stop getting the notification,\n     * use {@link #removeHotplugEventListener(HotplugEventListener)}.\n     *\n     * @param listener {@link HotplugEventListener} instance\n     * @see HdmiControlManager#removeHotplugEventListener(HotplugEventListener)\n     ",
    "links" : [ "HotplugEventListener", "#removeHotplugEventListener(HotplugEventListener)", "android.hardware.hdmi.HdmiHotplugEvent" ]
  }, {
    "name" : "public void removeHotplugEventListener(HotplugEventListener listener)",
    "returnType" : "void",
    "comment" : "\n     * Removes a listener to stop getting informed of {@link HdmiHotplugEvent}.\n     *\n     * @param listener {@link HotplugEventListener} instance to be removed\n     ",
    "links" : [ "HotplugEventListener", "android.hardware.hdmi.HdmiHotplugEvent" ]
  }, {
    "name" : "private IHdmiHotplugEventListener getHotplugEventListenerWrapper(Executor executor, final HotplugEventListener listener)",
    "returnType" : "IHdmiHotplugEventListener",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public void addHdmiControlStatusChangeListener(HdmiControlStatusChangeListener listener)",
    "returnType" : "void",
    "comment" : "\n     * Adds a listener to get informed of {@link HdmiControlStatusChange}.\n     *\n     * <p>To stop getting the notification,\n     * use {@link #removeHdmiControlStatusChangeListener(HdmiControlStatusChangeListener)}.\n     *\n     * Note that each invocation of the callback will be executed on an arbitrary\n     * Binder thread. This means that all callback implementations must be\n     * thread safe. To specify the execution thread, use\n     * {@link addHdmiControlStatusChangeListener(Executor, HdmiControlStatusChangeListener)}.\n     *\n     * @param listener {@link HdmiControlStatusChangeListener} instance\n     * @see HdmiControlManager#removeHdmiControlStatusChangeListener(\n     * HdmiControlStatusChangeListener)\n     *\n     * @hide\n     ",
    "links" : [ "HdmiControlStatusChangeListener", "#removeHdmiControlStatusChangeListener(HdmiControlStatusChangeListener)", "addHdmiControlStatusChangeListener(Executor", "HdmiControlStatusChange" ]
  }, {
    "name" : "public void addHdmiControlStatusChangeListener(@NonNull @CallbackExecutor Executor executor, @NonNull HdmiControlStatusChangeListener listener)",
    "returnType" : "void",
    "comment" : "\n     * Adds a listener to get informed of {@link HdmiControlStatusChange}.\n     *\n     * <p>To stop getting the notification,\n     * use {@link #removeHdmiControlStatusChangeListener(HdmiControlStatusChangeListener)}.\n     *\n     * @param listener {@link HdmiControlStatusChangeListener} instance\n     * @see HdmiControlManager#removeHdmiControlStatusChangeListener(\n     * HdmiControlStatusChangeListener)\n     *\n     * @hide\n     ",
    "links" : [ "HdmiControlStatusChangeListener", "#removeHdmiControlStatusChangeListener(HdmiControlStatusChangeListener)", "HdmiControlStatusChange" ]
  }, {
    "name" : "public void removeHdmiControlStatusChangeListener(HdmiControlStatusChangeListener listener)",
    "returnType" : "void",
    "comment" : "\n     * Removes a listener to stop getting informed of {@link HdmiControlStatusChange}.\n     *\n     * @param listener {@link HdmiControlStatusChangeListener} instance to be removed\n     *\n     * @hide\n     ",
    "links" : [ "HdmiControlStatusChangeListener", "HdmiControlStatusChange" ]
  }, {
    "name" : "private IHdmiControlStatusChangeListener getHdmiControlStatusChangeListenerWrapper(Executor executor, final HdmiControlStatusChangeListener listener)",
    "returnType" : "IHdmiControlStatusChangeListener",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public void addHdmiCecVolumeControlFeatureListener(@NonNull @CallbackExecutor Executor executor, @NonNull HdmiCecVolumeControlFeatureListener listener)",
    "returnType" : "void",
    "comment" : "\n     * Adds a listener to get informed of changes to the state of the HDMI CEC volume control\n     * feature.\n     *\n     * Upon adding a listener, the current state of the HDMI CEC volume control feature will be\n     * sent immediately.\n     *\n     * <p>To stop getting the notification,\n     * use {@link #removeHdmiCecVolumeControlFeatureListener(HdmiCecVolumeControlFeatureListener)}.\n     *\n     * @param listener {@link HdmiCecVolumeControlFeatureListener} instance\n     * @hide\n     * @see #removeHdmiCecVolumeControlFeatureListener(HdmiCecVolumeControlFeatureListener)\n     ",
    "links" : [ "#removeHdmiCecVolumeControlFeatureListener(HdmiCecVolumeControlFeatureListener)", "HdmiCecVolumeControlFeatureListener" ]
  }, {
    "name" : "public void removeHdmiCecVolumeControlFeatureListener(HdmiCecVolumeControlFeatureListener listener)",
    "returnType" : "void",
    "comment" : "\n     * Removes a listener to stop getting informed of changes to the state of the HDMI CEC volume\n     * control feature.\n     *\n     * @param listener {@link HdmiCecVolumeControlFeatureListener} instance to be removed\n     * @hide\n     ",
    "links" : [ "HdmiCecVolumeControlFeatureListener" ]
  }, {
    "name" : "private IHdmiCecVolumeControlFeatureListener createHdmiCecVolumeControlFeatureListenerWrapper(Executor executor, final HdmiCecVolumeControlFeatureListener listener)",
    "returnType" : "IHdmiCecVolumeControlFeatureListener",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private void addCecSettingChangeListener(@NonNull @SettingName String setting, @NonNull @CallbackExecutor Executor executor, @NonNull CecSettingChangeListener listener)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private void removeCecSettingChangeListener(@NonNull @SettingName String setting, @NonNull CecSettingChangeListener listener)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private IHdmiCecSettingChangeListener getCecSettingChangeListenerWrapper(Executor executor, final CecSettingChangeListener listener)",
    "returnType" : "IHdmiCecSettingChangeListener",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public List<String> getUserCecSettings()",
    "returnType" : "List<String>",
    "comment" : " settings and not just CEC settings.",
    "links" : [ ]
  }, {
    "name" : "public List<String> getAllowedCecSettingStringValues(@NonNull @SettingName String name)",
    "returnType" : "List<String>",
    "comment" : " settings and not just CEC settings.",
    "links" : [ ]
  }, {
    "name" : "public List<Integer> getAllowedCecSettingIntValues(@NonNull @SettingName String name)",
    "returnType" : "List<Integer>",
    "comment" : " settings and not just CEC settings.",
    "links" : [ ]
  }, {
    "name" : "public void setHdmiCecEnabled(@NonNull @HdmiCecControl int value)",
    "returnType" : "void",
    "comment" : "\n     * Set the global status of HDMI CEC.\n     *\n     * <p>This allows to enable/disable HDMI CEC on the device.\n     ",
    "links" : [ ]
  }, {
    "name" : "public int getHdmiCecEnabled()",
    "returnType" : "int",
    "comment" : "\n     * Get the current global status of HDMI CEC.\n     *\n     * <p>Reflects whether HDMI CEC is currently enabled on the device.\n     ",
    "links" : [ ]
  }, {
    "name" : "public void addHdmiCecEnabledChangeListener(@NonNull CecSettingChangeListener listener)",
    "returnType" : "void",
    "comment" : "\n     * Add change listener for global status of HDMI CEC.\n     *\n     * <p>To stop getting the notification,\n     * use {@link #removeHdmiCecEnabledChangeListener(CecSettingChangeListener)}.\n     *\n     * Note that each invocation of the callback will be executed on an arbitrary\n     * Binder thread. This means that all callback implementations must be\n     * thread safe. To specify the execution thread, use\n     * {@link addHdmiCecEnabledChangeListener(Executor, CecSettingChangeListener)}.\n     ",
    "links" : [ "#removeHdmiCecEnabledChangeListener(CecSettingChangeListener)", "addHdmiCecEnabledChangeListener(Executor" ]
  }, {
    "name" : "public void addHdmiCecEnabledChangeListener(@NonNull @CallbackExecutor Executor executor, @NonNull CecSettingChangeListener listener)",
    "returnType" : "void",
    "comment" : "\n     * Add change listener for global status of HDMI CEC.\n     *\n     * <p>To stop getting the notification,\n     * use {@link #removeHdmiCecEnabledChangeListener(CecSettingChangeListener)}.\n     ",
    "links" : [ "#removeHdmiCecEnabledChangeListener(CecSettingChangeListener)" ]
  }, {
    "name" : "public void removeHdmiCecEnabledChangeListener(@NonNull CecSettingChangeListener listener)",
    "returnType" : "void",
    "comment" : "\n     * Remove change listener for global status of HDMI CEC.\n     ",
    "links" : [ ]
  }, {
    "name" : "public void setHdmiCecVersion(@NonNull @HdmiCecVersion int value)",
    "returnType" : "void",
    "comment" : "\n     * Set the version of the HDMI CEC specification currently used.\n     *\n     * <p>Allows to select either CEC 1.4b or 2.0 to be used by the device.\n     *\n     * @see HdmiControlManager#CEC_SETTING_NAME_HDMI_CEC_VERSION\n     ",
    "links" : [ ]
  }, {
    "name" : "public int getHdmiCecVersion()",
    "returnType" : "int",
    "comment" : "\n     * Get the version of the HDMI CEC specification currently used.\n     *\n     * <p>Reflects which CEC version 1.4b or 2.0 is currently used by the device.\n     *\n     * @see HdmiControlManager#CEC_SETTING_NAME_HDMI_CEC_VERSION\n     ",
    "links" : [ ]
  }, {
    "name" : "public void setRoutingControl(@NonNull @RoutingControl int value)",
    "returnType" : "void",
    "comment" : "\n     * Set the status of Routing Control feature.\n     *\n     * <p>This allows to enable/disable Routing Control on the device.\n     * If enabled, the switch device will route to the correct input source on\n     * receiving Routing Control related messages. If disabled, you can only\n     * switch the input via controls on this device.\n     *\n     * @see HdmiControlManager#CEC_SETTING_NAME_ROUTING_CONTROL\n     ",
    "links" : [ ]
  }, {
    "name" : "public int getRoutingControl()",
    "returnType" : "int",
    "comment" : "\n     * Get the current status of Routing Control feature.\n     *\n     * <p>Reflects whether Routing Control is currently enabled on the device.\n     * If enabled, the switch device will route to the correct input source on\n     * receiving Routing Control related messages. If disabled, you can only\n     * switch the input via controls on this device.\n     *\n     * @see HdmiControlManager#CEC_SETTING_NAME_ROUTING_CONTROL\n     ",
    "links" : [ ]
  }, {
    "name" : "public void setSoundbarMode(@SoundbarMode int value)",
    "returnType" : "void",
    "comment" : "\n     * Set the status of Soundbar mode feature.\n     *\n     * <p>This allows to enable/disable Soundbar mode on the playback device.\n     * The setting's effect will be available on devices where the hardware supports this feature.\n     * If enabled, an audio system local device will be allocated and try to establish an ARC\n     * connection with the TV. If disabled, the ARC connection will be terminated and the audio\n     * system local device will be removed from the network.\n     *\n     * @see HdmiControlManager#CEC_SETTING_NAME_SOUNDBAR_MODE\n     ",
    "links" : [ ]
  }, {
    "name" : "public int getSoundbarMode()",
    "returnType" : "int",
    "comment" : "\n     * Get the current status of Soundbar mode feature.\n     *\n     * <p>Reflects whether Soundbar mode is currently enabled on the playback device.\n     * If enabled, an audio system local device will be allocated and try to establish an ARC\n     * connection with the TV. If disabled, the ARC connection will be terminated and the audio\n     * system local device will be removed from the network.\n     *\n     * @see HdmiControlManager#CEC_SETTING_NAME_SOUNDBAR_MODE\n     ",
    "links" : [ ]
  }, {
    "name" : "public void setPowerControlMode(@NonNull @PowerControlMode String value)",
    "returnType" : "void",
    "comment" : "\n     * Set the status of Power Control.\n     *\n     * <p>Specifies to which devices Power Control messages should be sent:\n     * only to the TV, broadcast to all devices, no power control messages.\n     *\n     * @see HdmiControlManager#CEC_SETTING_NAME_POWER_CONTROL_MODE\n     ",
    "links" : [ ]
  }, {
    "name" : "public String getPowerControlMode()",
    "returnType" : "String",
    "comment" : "\n     * Get the status of Power Control.\n     *\n     * <p>Reflects to which devices Power Control messages should be sent:\n     * only to the TV, broadcast to all devices, no power control messages.\n     *\n     * @see HdmiControlManager#CEC_SETTING_NAME_POWER_CONTROL_MODE\n     ",
    "links" : [ ]
  }, {
    "name" : "public void setPowerStateChangeOnActiveSourceLost(@NonNull @ActiveSourceLostBehavior String value)",
    "returnType" : "void",
    "comment" : "\n     * Set the current power state behaviour when Active Source is lost.\n     *\n     * <p>Sets the action taken: do nothing or go to sleep immediately.\n     *\n     * @see HdmiControlManager#CEC_SETTING_NAME_POWER_STATE_CHANGE_ON_ACTIVE_SOURCE_LOST\n     ",
    "links" : [ ]
  }, {
    "name" : "public String getPowerStateChangeOnActiveSourceLost()",
    "returnType" : "String",
    "comment" : "\n     * Get the current power state behaviour when Active Source is lost.\n     *\n     * <p>Reflects the action taken: do nothing or go to sleep immediately.\n     *\n     * @see HdmiControlManager#CEC_SETTING_NAME_POWER_STATE_CHANGE_ON_ACTIVE_SOURCE_LOST\n     ",
    "links" : [ ]
  }, {
    "name" : "public void setSystemAudioControl(@NonNull @SystemAudioControl int value)",
    "returnType" : "void",
    "comment" : "\n     * Set the current status of System Audio Control.\n     *\n     * <p>Sets whether HDMI System Audio Control feature is enabled. If enabled,\n     * TV or Audio System will try to turn on the System Audio Mode if there's a\n     * connected CEC-enabled AV Receiver. Then an audio stream will be played on\n     * the AVR instead of TV speaker or Audio System speakers. If disabled, the\n     * System Audio Mode will never be activated.\n     *\n     * @see HdmiControlManager#CEC_SETTING_NAME_SYSTEM_AUDIO_CONTROL\n     ",
    "links" : [ ]
  }, {
    "name" : "public int getSystemAudioControl()",
    "returnType" : "int",
    "comment" : "\n     * Get the current status of System Audio Control.\n     *\n     * <p>Reflects whether HDMI System Audio Control feature is enabled. If enabled,\n     * TV or Audio System will try to turn on the System Audio Mode if there's a\n     * connected CEC-enabled AV Receiver. Then an audio stream will be played on\n     * the AVR instead of TV speaker or Audio System speakers. If disabled, the\n     * System Audio Mode will never be activated.\n     *\n     * @see HdmiControlManager#CEC_SETTING_NAME_SYSTEM_AUDIO_CONTROL\n     ",
    "links" : [ ]
  }, {
    "name" : "public void setSystemAudioModeMuting(@NonNull @SystemAudioModeMuting int value)",
    "returnType" : "void",
    "comment" : "\n     * Set the current status of System Audio Mode muting.\n     *\n     * <p>Sets whether the device should be muted when System Audio Mode is turned off.\n     *\n     * @see HdmiControlManager#CEC_SETTING_NAME_SYSTEM_AUDIO_MODE_MUTING\n     ",
    "links" : [ ]
  }, {
    "name" : "public int getSystemAudioModeMuting()",
    "returnType" : "int",
    "comment" : "\n     * Get the current status of System Audio Mode muting.\n     *\n     * <p>Reflects whether the device should be muted when System Audio Mode is turned off.\n     *\n     * @see HdmiControlManager#CEC_SETTING_NAME_SYSTEM_AUDIO_MODE_MUTING\n     ",
    "links" : [ ]
  }, {
    "name" : "public void setTvWakeOnOneTouchPlay(@NonNull @TvWakeOnOneTouchPlay int value)",
    "returnType" : "void",
    "comment" : "\n     * Set the current status of TV Wake on One Touch Play.\n     *\n     * <p>Sets whether the TV should wake up upon reception of &lt;Text View On&gt;\n     * or &lt;Image View On&gt;.\n     *\n     * @see HdmiControlManager#CEC_SETTING_NAME_TV_WAKE_ON_ONE_TOUCH_PLAY\n     ",
    "links" : [ ]
  }, {
    "name" : "public int getTvWakeOnOneTouchPlay()",
    "returnType" : "int",
    "comment" : "\n     * Get the current status of TV Wake on One Touch Play.\n     *\n     * <p>Reflects whether the TV should wake up upon reception of &lt;Text View On&gt;\n     * or &lt;Image View On&gt;.\n     *\n     * @see HdmiControlManager#CEC_SETTING_NAME_TV_WAKE_ON_ONE_TOUCH_PLAY\n     ",
    "links" : [ ]
  }, {
    "name" : "public void setTvSendStandbyOnSleep(@NonNull @TvSendStandbyOnSleep int value)",
    "returnType" : "void",
    "comment" : "\n     * Set the current status of TV send &lt;Standby&gt; on Sleep.\n     *\n     * <p>Sets whether the device will also turn off other CEC devices\n     * when it goes to standby mode.\n     *\n     * @see HdmiControlManager#CEC_SETTING_NAME_TV_SEND_STANDBY_ON_SLEEP\n     ",
    "links" : [ ]
  }, {
    "name" : "public int getTvSendStandbyOnSleep()",
    "returnType" : "int",
    "comment" : "\n     * Get the current status of TV send &lt;Standby&gt; on Sleep.\n     *\n     * <p>Reflects whether the device will also turn off other CEC devices\n     * when it goes to standby mode.\n     *\n     * @see HdmiControlManager#CEC_SETTING_NAME_TV_SEND_STANDBY_ON_SLEEP\n     ",
    "links" : [ ]
  }, {
    "name" : "public void setSadPresenceInQuery(@NonNull @CecSettingSad String setting, @SadPresenceInQuery int value)",
    "returnType" : "void",
    "comment" : "\n     * Set presence of one Short Audio Descriptor (SAD) in the query.\n     *\n     * <p>Allows the caller to specify whether the SAD for a specific audio codec should be\n     * present in the &lt;Request Short Audio Descriptor&gt; query. Each &lt;Request Short Audio\n     * Descriptor&gt; message can carry at most 4 SADs at a time. This method allows the caller to\n     * limit the amount of SADs queried and therefore limit the amount of CEC messages on the bus.\n     *\n     * <p>When an ARC connection is established, the TV sends a\n     * &lt;Request Short Audio Descriptor&gt; query to the Audio System that it's connected to. If\n     * an SAD is queried and the Audio System reports that it supports that SAD, the TV can send\n     * audio in that format to be output on the Audio System via ARC.\n     * If a codec is not queried, the TV doesn't know if the connected Audio System supports this\n     * SAD and doesn't send audio in that format to the Audio System.\n     *\n     * @param setting SAD to set.\n     * @param value Presence to set the SAD to.\n     ",
    "links" : [ ]
  }, {
    "name" : "public void setSadsPresenceInQuery(@NonNull @CecSettingSad List<String> settings, @SadPresenceInQuery int value)",
    "returnType" : "void",
    "comment" : "\n     * Set presence of multiple Short Audio Descriptors (SADs) in the query.\n     *\n     * <p>Allows the caller to specify whether the SADs for specific audio codecs should be present\n     * in the &lt;Request Short Audio Descriptor&gt; query. For audio codecs that are not specified,\n     * the SAD's presence remains at its previous value. Each &lt;Request Short Audio Descriptor&gt;\n     * message can carry at most 4 SADs at a time. This method allows the caller to limit the amount\n     * of SADs queried and therefore limit the amount of CEC messages on the bus.\n     *\n     * <p>When an ARC connection is established, the TV sends a\n     * &lt;Request Short Audio Descriptor&gt; query to the Audio System that it's connected to. If\n     * an SAD is queried and the Audio System reports that it supports that SAD, the TV can send\n     * audio in that format to be output on the Audio System via ARC.\n     * If a codec is not queried, the TV doesn't know if the connected Audio System supports this\n     * SAD and doesn't send audio in that format to the Audio System.\n     *\n     *\n     * @param settings SADs to set.\n     * @param value Presence to set all specified SADs to.\n     ",
    "links" : [ ]
  }, {
    "name" : "public int getSadPresenceInQuery(@NonNull @CecSettingSad String setting)",
    "returnType" : "int",
    "comment" : "\n     * Get presence of one Short Audio Descriptor (SAD) in the query.\n     *\n     * <p>Reflects whether the SAD for a specific audio codec should be present in the\n     * &lt;Request Short Audio Descriptor&gt; query.\n     *\n     * <p>When an ARC connection is established, the TV sends a\n     * &lt;Request Short Audio Descriptor&gt; query to the Audio System that it's connected to. If\n     * an SAD is queried and the Audio System reports that it supports that SAD, the TV can send\n     * audio in that format to be output on the Audio System via ARC.\n     * If a codec is not queried, the TV doesn't know if the connected Audio System supports this\n     * SAD and doesn't send audio in that format to the Audio System.\n     *\n     * @param setting SAD to get.\n     * @return Current presence of the specified SAD.\n     ",
    "links" : [ ]
  }, {
    "name" : "public void setEarcEnabled(@NonNull @EarcFeature int value)",
    "returnType" : "void",
    "comment" : "\n     * Set the global status of eARC.\n     *\n     * <p>This allows to enable/disable the eARC feature on the device. If the feature is enabled\n     * and the hardware supports eARC as well, the device can attempt to establish an eARC\n     * connection.\n     ",
    "links" : [ ]
  }, {
    "name" : "public int getEarcEnabled()",
    "returnType" : "int",
    "comment" : "\n     * Get the current global status of eARC.\n     *\n     * <p>Reflects whether the eARC feature is currently enabled on the device.\n     ",
    "links" : [ ]
  } ],
  "methodNames" : [ "private void setLocalPhysicalAddress(int physicalAddress)", "private int getLocalPhysicalAddress()", "private static boolean hasDeviceType(int[] types, int type)", "public HdmiClient getClient(int type)", "public HdmiPlaybackClient getPlaybackClient()", "public HdmiTvClient getTvClient()", "public HdmiAudioSystemClient getAudioSystemClient()", "public HdmiSwitchClient getSwitchClient()", "public List<HdmiDeviceInfo> getConnectedDevices()", "public List<HdmiDeviceInfo> getConnectedDevicesList()", "public List<HdmiPortInfo> getPortInfo()", "public void powerOffDevice(@NonNull HdmiDeviceInfo deviceInfo)", "public void powerOffRemoteDevice(@NonNull HdmiDeviceInfo deviceInfo)", "public void powerOnDevice(HdmiDeviceInfo deviceInfo)", "public void powerOnRemoteDevice(HdmiDeviceInfo deviceInfo)", "public void setActiveSource(@NonNull HdmiDeviceInfo deviceInfo)", "public void requestRemoteDeviceToBecomeActiveSource(@NonNull HdmiDeviceInfo deviceInfo)", "public void setStandbyMode(boolean isStandbyModeOn)", "public void toggleAndFollowTvPower()", "public boolean shouldHandleTvPowerKey()", "public void setHdmiCecVolumeControlEnabled(@VolumeControl int hdmiCecVolumeControlEnabled)", "public int getHdmiCecVolumeControlEnabled()", "public boolean getSystemAudioMode()", "public int getPhysicalAddress()", "public boolean isDeviceConnected(@NonNull HdmiDeviceInfo targetDevice)", "public boolean isRemoteDeviceConnected(@NonNull HdmiDeviceInfo targetDevice)", "public void addHotplugEventListener(HotplugEventListener listener)", "public void addHotplugEventListener(@NonNull @CallbackExecutor Executor executor, @NonNull HotplugEventListener listener)", "public void removeHotplugEventListener(HotplugEventListener listener)", "private IHdmiHotplugEventListener getHotplugEventListenerWrapper(Executor executor, final HotplugEventListener listener)", "public void addHdmiControlStatusChangeListener(HdmiControlStatusChangeListener listener)", "public void addHdmiControlStatusChangeListener(@NonNull @CallbackExecutor Executor executor, @NonNull HdmiControlStatusChangeListener listener)", "public void removeHdmiControlStatusChangeListener(HdmiControlStatusChangeListener listener)", "private IHdmiControlStatusChangeListener getHdmiControlStatusChangeListenerWrapper(Executor executor, final HdmiControlStatusChangeListener listener)", "public void addHdmiCecVolumeControlFeatureListener(@NonNull @CallbackExecutor Executor executor, @NonNull HdmiCecVolumeControlFeatureListener listener)", "public void removeHdmiCecVolumeControlFeatureListener(HdmiCecVolumeControlFeatureListener listener)", "private IHdmiCecVolumeControlFeatureListener createHdmiCecVolumeControlFeatureListenerWrapper(Executor executor, final HdmiCecVolumeControlFeatureListener listener)", "private void addCecSettingChangeListener(@NonNull @SettingName String setting, @NonNull @CallbackExecutor Executor executor, @NonNull CecSettingChangeListener listener)", "private void removeCecSettingChangeListener(@NonNull @SettingName String setting, @NonNull CecSettingChangeListener listener)", "private IHdmiCecSettingChangeListener getCecSettingChangeListenerWrapper(Executor executor, final CecSettingChangeListener listener)", "public List<String> getUserCecSettings()", "public List<String> getAllowedCecSettingStringValues(@NonNull @SettingName String name)", "public List<Integer> getAllowedCecSettingIntValues(@NonNull @SettingName String name)", "public void setHdmiCecEnabled(@NonNull @HdmiCecControl int value)", "public int getHdmiCecEnabled()", "public void addHdmiCecEnabledChangeListener(@NonNull CecSettingChangeListener listener)", "public void addHdmiCecEnabledChangeListener(@NonNull @CallbackExecutor Executor executor, @NonNull CecSettingChangeListener listener)", "public void removeHdmiCecEnabledChangeListener(@NonNull CecSettingChangeListener listener)", "public void setHdmiCecVersion(@NonNull @HdmiCecVersion int value)", "public int getHdmiCecVersion()", "public void setRoutingControl(@NonNull @RoutingControl int value)", "public int getRoutingControl()", "public void setSoundbarMode(@SoundbarMode int value)", "public int getSoundbarMode()", "public void setPowerControlMode(@NonNull @PowerControlMode String value)", "public String getPowerControlMode()", "public void setPowerStateChangeOnActiveSourceLost(@NonNull @ActiveSourceLostBehavior String value)", "public String getPowerStateChangeOnActiveSourceLost()", "public void setSystemAudioControl(@NonNull @SystemAudioControl int value)", "public int getSystemAudioControl()", "public void setSystemAudioModeMuting(@NonNull @SystemAudioModeMuting int value)", "public int getSystemAudioModeMuting()", "public void setTvWakeOnOneTouchPlay(@NonNull @TvWakeOnOneTouchPlay int value)", "public int getTvWakeOnOneTouchPlay()", "public void setTvSendStandbyOnSleep(@NonNull @TvSendStandbyOnSleep int value)", "public int getTvSendStandbyOnSleep()", "public void setSadPresenceInQuery(@NonNull @CecSettingSad String setting, @SadPresenceInQuery int value)", "public void setSadsPresenceInQuery(@NonNull @CecSettingSad List<String> settings, @SadPresenceInQuery int value)", "public int getSadPresenceInQuery(@NonNull @CecSettingSad String setting)", "public void setEarcEnabled(@NonNull @EarcFeature int value)", "public int getEarcEnabled()" ],
  "variableNames" : [ "TAG", "mService", "INVALID_PHYSICAL_ADDRESS", "mLocalPhysicalAddress", "mLock", "ACTION_OSD_MESSAGE", "OSD_MESSAGE_ARC_CONNECTED_INVALID_PORT", "OSD_MESSAGE_AVR_VOLUME_CHANGED", "EXTRA_MESSAGE_ID", "EXTRA_MESSAGE_EXTRA_PARAM1", "EXTRA_LOCALE", "ACTION_ON_ACTIVE_SOURCE_RECOVERED_DISMISS_UI", "AVR_VOLUME_MUTED", "POWER_STATUS_UNKNOWN", "POWER_STATUS_ON", "POWER_STATUS_STANDBY", "POWER_STATUS_TRANSIENT_TO_ON", "POWER_STATUS_TRANSIENT_TO_STANDBY", "RESULT_SUCCESS", "RESULT_TIMEOUT", "RESULT_SOURCE_NOT_AVAILABLE", "RESULT_TARGET_NOT_AVAILABLE", "RESULT_ALREADY_IN_PROGRESS", "RESULT_EXCEPTION", "RESULT_INCORRECT_MODE", "RESULT_COMMUNICATION_FAILED", "DEVICE_EVENT_ADD_DEVICE", "DEVICE_EVENT_REMOVE_DEVICE", "DEVICE_EVENT_UPDATE_DEVICE", "ONE_TOUCH_RECORD_RECORDING_CURRENTLY_SELECTED_SOURCE", "ONE_TOUCH_RECORD_RECORDING_DIGITAL_SERVICE", "ONE_TOUCH_RECORD_RECORDING_ANALOGUE_SERVICE", "ONE_TOUCH_RECORD_RECORDING_EXTERNAL_INPUT", "ONE_TOUCH_RECORD_UNABLE_DIGITAL_SERVICE", "ONE_TOUCH_RECORD_UNABLE_ANALOGUE_SERVICE", "ONE_TOUCH_RECORD_UNABLE_SELECTED_SERVICE", "ONE_TOUCH_RECORD_INVALID_EXTERNAL_PLUG_NUMBER", "ONE_TOUCH_RECORD_INVALID_EXTERNAL_PHYSICAL_ADDRESS", "ONE_TOUCH_RECORD_UNSUPPORTED_CA", "ONE_TOUCH_RECORD_NO_OR_INSUFFICIENT_CA_ENTITLEMENTS", "ONE_TOUCH_RECORD_DISALLOW_TO_COPY", "ONE_TOUCH_RECORD_DISALLOW_TO_FUTHER_COPIES", "ONE_TOUCH_RECORD_NO_MEDIA", "ONE_TOUCH_RECORD_PLAYING", "ONE_TOUCH_RECORD_ALREADY_RECORDING", "ONE_TOUCH_RECORD_MEDIA_PROTECTED", "ONE_TOUCH_RECORD_NO_SOURCE_SIGNAL", "ONE_TOUCH_RECORD_MEDIA_PROBLEM", "ONE_TOUCH_RECORD_NOT_ENOUGH_SPACE", "ONE_TOUCH_RECORD_PARENT_LOCK_ON", "ONE_TOUCH_RECORD_RECORDING_TERMINATED_NORMALLY", "ONE_TOUCH_RECORD_RECORDING_ALREADY_TERMINATED", "ONE_TOUCH_RECORD_OTHER_REASON", "ONE_TOUCH_RECORD_PREVIOUS_RECORDING_IN_PROGRESS", "ONE_TOUCH_RECORD_CHECK_RECORDER_CONNECTION", "ONE_TOUCH_RECORD_FAIL_TO_RECORD_DISPLAYED_SCREEN", "ONE_TOUCH_RECORD_CEC_DISABLED", "TIMER_RECORDING_TYPE_DIGITAL", "TIMER_RECORDING_TYPE_ANALOGUE", "TIMER_RECORDING_TYPE_EXTERNAL", "TIMER_STATUS_MEDIA_INFO_PRESENT_NOT_PROTECTED", "TIMER_STATUS_MEDIA_INFO_PRESENT_PROTECTED", "TIMER_STATUS_MEDIA_INFO_NOT_PRESENT", "TIMER_STATUS_PROGRAMMED_INFO_ENOUGH_SPACE", "TIMER_STATUS_PROGRAMMED_INFO_NOT_ENOUGH_SPACE", "TIMER_STATUS_PROGRAMMED_INFO_MIGHT_NOT_ENOUGH_SPACE", "TIMER_STATUS_PROGRAMMED_INFO_NO_MEDIA_INFO", "TIMER_STATUS_NOT_PROGRAMMED_NO_FREE_TIME", "TIMER_STATUS_NOT_PROGRAMMED_DATE_OUT_OF_RANGE", "TIMER_STATUS_NOT_PROGRAMMED_INVALID_SEQUENCE", "TIMER_STATUS_NOT_PROGRAMMED_INVALID_EXTERNAL_PLUG_NUMBER", "TIMER_STATUS_NOT_PROGRAMMED_INVALID_EXTERNAL_PHYSICAL_NUMBER", "TIMER_STATUS_NOT_PROGRAMMED_CA_NOT_SUPPORTED", "TIMER_STATUS_NOT_PROGRAMMED_NO_CA_ENTITLEMENTS", "TIMER_STATUS_NOT_PROGRAMMED_UNSUPPORTED_RESOLUTION", "TIMER_STATUS_NOT_PROGRAMMED_PARENTAL_LOCK_ON", "TIMER_STATUS_NOT_PROGRAMMED_CLOCK_FAILURE", "TIMER_STATUS_NOT_PROGRAMMED_DUPLICATED", "TIMER_RECORDING_RESULT_EXTRA_NO_ERROR", "TIMER_RECORDING_RESULT_EXTRA_CHECK_RECORDER_CONNECTION", "TIMER_RECORDING_RESULT_EXTRA_FAIL_TO_RECORD_SELECTED_SOURCE", "TIMER_RECORDING_RESULT_EXTRA_CEC_DISABLED", "CLEAR_TIMER_STATUS_TIMER_NOT_CLEARED_RECORDING", "CLEAR_TIMER_STATUS_TIMER_NOT_CLEARED_NO_MATCHING", "CLEAR_TIMER_STATUS_TIMER_NOT_CLEARED_NO_INFO_AVAILABLE", "CLEAR_TIMER_STATUS_TIMER_CLEARED", "CLEAR_TIMER_STATUS_CHECK_RECORDER_CONNECTION", "CLEAR_TIMER_STATUS_FAIL_TO_CLEAR_SELECTED_SOURCE", "CLEAR_TIMER_STATUS_CEC_DISABLE", "CONTROL_STATE_CHANGED_REASON_START", "CONTROL_STATE_CHANGED_REASON_SETTING", "CONTROL_STATE_CHANGED_REASON_WAKEUP", "CONTROL_STATE_CHANGED_REASON_STANDBY", "HDMI_CEC_CONTROL_ENABLED", "HDMI_CEC_CONTROL_DISABLED", "HDMI_CEC_VERSION_1_4_B", "HDMI_CEC_VERSION_2_0", "ROUTING_CONTROL_ENABLED", "ROUTING_CONTROL_DISABLED", "SOUNDBAR_MODE_ENABLED", "SOUNDBAR_MODE_DISABLED", "POWER_CONTROL_MODE_TV", "POWER_CONTROL_MODE_TV_AND_AUDIO_SYSTEM", "POWER_CONTROL_MODE_BROADCAST", "POWER_CONTROL_MODE_NONE", "POWER_STATE_CHANGE_ON_ACTIVE_SOURCE_LOST_NONE", "POWER_STATE_CHANGE_ON_ACTIVE_SOURCE_LOST_STANDBY_NOW", "SYSTEM_AUDIO_CONTROL_ENABLED", "SYSTEM_AUDIO_CONTROL_DISABLED", "SYSTEM_AUDIO_MODE_MUTING_ENABLED", "SYSTEM_AUDIO_MODE_MUTING_DISABLED", "VOLUME_CONTROL_ENABLED", "VOLUME_CONTROL_DISABLED", "TV_WAKE_ON_ONE_TOUCH_PLAY_ENABLED", "TV_WAKE_ON_ONE_TOUCH_PLAY_DISABLED", "TV_SEND_STANDBY_ON_SLEEP_ENABLED", "TV_SEND_STANDBY_ON_SLEEP_DISABLED", "SET_MENU_LANGUAGE_ENABLED", "SET_MENU_LANGUAGE_DISABLED", "RC_PROFILE_TV_NONE", "RC_PROFILE_TV_ONE", "RC_PROFILE_TV_TWO", "RC_PROFILE_TV_THREE", "RC_PROFILE_TV_FOUR", "RC_PROFILE_SOURCE_MENU_HANDLED", "RC_PROFILE_SOURCE_MENU_NOT_HANDLED", "QUERY_SAD_ENABLED", "QUERY_SAD_DISABLED", "EARC_FEATURE_ENABLED", "EARC_FEATURE_DISABLED", "CEC_SETTING_NAME_HDMI_CEC_ENABLED", "CEC_SETTING_NAME_HDMI_CEC_VERSION", "CEC_SETTING_NAME_ROUTING_CONTROL", "CEC_SETTING_NAME_SOUNDBAR_MODE", "CEC_SETTING_NAME_POWER_CONTROL_MODE", "CEC_SETTING_NAME_POWER_STATE_CHANGE_ON_ACTIVE_SOURCE_LOST", "CEC_SETTING_NAME_SYSTEM_AUDIO_CONTROL", "CEC_SETTING_NAME_SYSTEM_AUDIO_MODE_MUTING", "CEC_SETTING_NAME_VOLUME_CONTROL_MODE", "CEC_SETTING_NAME_TV_WAKE_ON_ONE_TOUCH_PLAY", "CEC_SETTING_NAME_TV_SEND_STANDBY_ON_SLEEP", "CEC_SETTING_NAME_SET_MENU_LANGUAGE", "CEC_SETTING_NAME_RC_PROFILE_TV", "CEC_SETTING_NAME_RC_PROFILE_SOURCE_HANDLES_ROOT_MENU", "CEC_SETTING_NAME_RC_PROFILE_SOURCE_HANDLES_SETUP_MENU", "CEC_SETTING_NAME_RC_PROFILE_SOURCE_HANDLES_CONTENTS_MENU", "CEC_SETTING_NAME_RC_PROFILE_SOURCE_HANDLES_TOP_MENU", "CEC_SETTING_NAME_RC_PROFILE_SOURCE_HANDLES_MEDIA_CONTEXT_SENSITIVE_MENU", "CEC_SETTING_NAME_QUERY_SAD_LPCM", "CEC_SETTING_NAME_QUERY_SAD_DD", "CEC_SETTING_NAME_QUERY_SAD_MPEG1", "CEC_SETTING_NAME_QUERY_SAD_MP3", "CEC_SETTING_NAME_QUERY_SAD_MPEG2", "CEC_SETTING_NAME_QUERY_SAD_AAC", "CEC_SETTING_NAME_QUERY_SAD_DTS", "CEC_SETTING_NAME_QUERY_SAD_ATRAC", "CEC_SETTING_NAME_QUERY_SAD_ONEBITAUDIO", "CEC_SETTING_NAME_QUERY_SAD_DDP", "CEC_SETTING_NAME_QUERY_SAD_DTSHD", "CEC_SETTING_NAME_QUERY_SAD_TRUEHD", "CEC_SETTING_NAME_QUERY_SAD_DST", "CEC_SETTING_NAME_QUERY_SAD_WMAPRO", "CEC_SETTING_NAME_QUERY_SAD_MAX", "SETTING_NAME_EARC_ENABLED", "mHasPlaybackDevice", "mHasTvDevice", "mHasAudioSystemDevice", "mHasSwitchDevice", "mIsSwitchDevice", "mHotplugEventListeners", "mHdmiControlStatusChangeListeners", "mHdmiCecVolumeControlFeatureListeners", "mCecSettingChangeListeners" ]
}