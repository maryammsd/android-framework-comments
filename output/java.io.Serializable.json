{
  "filePath" : "/home/maryam/clearblue/files/android-source-35/java/io/Serializable.java",
  "packageName" : "java.io",
  "className" : "Serializable",
  "comment" : "\n * Serializability of a class is enabled by the class implementing the\n * java.io.Serializable interface.\n *\n * <p><strong>Warning: Deserialization of untrusted data is inherently dangerous\n * and should be avoided. Untrusted data should be carefully validated.\n * </strong></p>\n *\n * Classes that do not implement this\n * interface will not have any of their state serialized or\n * deserialized.  All subtypes of a serializable class are themselves\n * serializable.  The serialization interface has no methods or fields\n * and serves only to identify the semantics of being serializable. <p>\n *\n * To allow subtypes of non-serializable classes to be serialized, the\n * subtype may assume responsibility for saving and restoring the\n * state of the supertype's public, protected, and (if accessible)\n * package fields.  The subtype may assume this responsibility only if\n * the class it extends has an accessible no-arg constructor to\n * initialize the class's state.  It is an error to declare a class\n * Serializable if this is not the case.  The error will be detected at\n * runtime. <p>\n *\n * During deserialization, the fields of non-serializable classes will\n * be initialized using the public or protected no-arg constructor of\n * the class.  A no-arg constructor must be accessible to the subclass\n * that is serializable.  The fields of serializable subclasses will\n * be restored from the stream. <p>\n *\n * When traversing a graph, an object may be encountered that does not\n * support the Serializable interface. In this case the\n * NotSerializableException will be thrown and will identify the class\n * of the non-serializable object. <p>\n *\n * Classes that require special handling during the serialization and\n * deserialization process must implement special methods with these exact\n * signatures:\n *\n * <PRE>\n * private void writeObject(java.io.ObjectOutputStream out)\n *     throws IOException\n * private void readObject(java.io.ObjectInputStream in)\n *     throws IOException, ClassNotFoundException;\n * private void readObjectNoData()\n *     throws ObjectStreamException;\n * </PRE>\n *\n * <p>The writeObject method is responsible for writing the state of the\n * object for its particular class so that the corresponding\n * readObject method can restore it.  The default mechanism for saving\n * the Object's fields can be invoked by calling\n * out.defaultWriteObject. The method does not need to concern\n * itself with the state belonging to its superclasses or subclasses.\n * State is saved by writing the individual fields to the\n * ObjectOutputStream using the writeObject method or by using the\n * methods for primitive data types supported by DataOutput.\n *\n * <p>The readObject method is responsible for reading from the stream and\n * restoring the classes fields. It may call in.defaultReadObject to invoke\n * the default mechanism for restoring the object's non-static and\n * non-transient fields.  The defaultReadObject method uses information in\n * the stream to assign the fields of the object saved in the stream with the\n * correspondingly named fields in the current object.  This handles the case\n * when the class has evolved to add new fields. The method does not need to\n * concern itself with the state belonging to its superclasses or subclasses.\n * State is restored by reading data from the ObjectInputStream for\n * the individual fields and making assignments to the appropriate fields\n * of the object. Reading primitive data types is supported by DataInput.\n *\n * <p>The readObjectNoData method is responsible for initializing the state of\n * the object for its particular class in the event that the serialization\n * stream does not list the given class as a superclass of the object being\n * deserialized.  This may occur in cases where the receiving party uses a\n * different version of the deserialized instance's class than the sending\n * party, and the receiver's version extends classes that are not extended by\n * the sender's version.  This may also occur if the serialization stream has\n * been tampered; hence, readObjectNoData is useful for initializing\n * deserialized objects properly despite a \"hostile\" or incomplete source\n * stream.\n *\n * <p>Serializable classes that need to designate an alternative object to be\n * used when writing an object to the stream should implement this\n * special method with the exact signature:\n *\n * <PRE>\n * ANY-ACCESS-MODIFIER Object writeReplace() throws ObjectStreamException;\n * </PRE><p>\n *\n * This writeReplace method is invoked by serialization if the method\n * exists and it would be accessible from a method defined within the\n * class of the object being serialized. Thus, the method can have private,\n * protected and package-private access. Subclass access to this method\n * follows java accessibility rules. <p>\n *\n * Classes that need to designate a replacement when an instance of it\n * is read from the stream should implement this special method with the\n * exact signature.\n *\n * <PRE>\n * ANY-ACCESS-MODIFIER Object readResolve() throws ObjectStreamException;\n * </PRE><p>\n *\n * This readResolve method follows the same invocation rules and\n * accessibility rules as writeReplace.<p>\n *\n * The serialization runtime associates with each serializable class a version\n * number, called a serialVersionUID, which is used during deserialization to\n * verify that the sender and receiver of a serialized object have loaded\n * classes for that object that are compatible with respect to serialization.\n * If the receiver has loaded a class for the object that has a different\n * serialVersionUID than that of the corresponding sender's class, then\n * deserialization will result in an {@link InvalidClassException}.  A\n * serializable class can declare its own serialVersionUID explicitly by\n * declaring a field named <code>\"serialVersionUID\"</code> that must be static,\n * final, and of type <code>long</code>:\n *\n * <PRE>\n * ANY-ACCESS-MODIFIER static final long serialVersionUID = 42L;\n * </PRE>\n *\n * If a serializable class does not explicitly declare a serialVersionUID, then\n * the serialization runtime will calculate a default serialVersionUID value\n * for that class based on various aspects of the class, as described in the\n * Java(TM) Object Serialization Specification.  However, it is <em>strongly\n * recommended</em> that all serializable classes explicitly declare\n * serialVersionUID values, since the default serialVersionUID computation is\n * highly sensitive to class details that may vary depending on compiler\n * implementations, and can thus result in unexpected\n * <code>InvalidClassException</code>s during deserialization.  Therefore, to\n * guarantee a consistent serialVersionUID value across different java compiler\n * implementations, a serializable class must declare an explicit\n * serialVersionUID value.  It is also strongly advised that explicit\n * serialVersionUID declarations use the <code>private</code> modifier where\n * possible, since such declarations apply only to the immediately declaring\n * class--serialVersionUID fields are not useful as inherited members. Array\n * classes cannot declare an explicit serialVersionUID, so they always have\n * the default computed value, but the requirement for matching\n * serialVersionUID values is waived for array classes.\n *\n * Android implementation of serialVersionUID computation will change slightly\n * for some classes if you're targeting android N. In order to preserve compatibility,\n * this change is only enabled if the application target SDK version is set to\n * 24 or higher. It is highly recommended to use an explicit serialVersionUID\n * field to avoid compatibility issues.\n *\n * <h3>Implement Serializable Judiciously</h3>\n * Refer to <i>Effective Java</i>'s chapter on serialization for thorough\n * coverage of the serialization API. The book explains how to use this\n * interface without harming your application's maintainability.\n *\n * <h3>Recommended Alternatives</h3>\n * <strong>JSON</strong> is concise, human-readable and efficient. Android\n * includes both a {@link android.util.JsonReader streaming API} and a {@link\n * org.json.JSONObject tree API} to read and write JSON. Use a binding library\n * like <a href=\"http://code.google.com/p/google-gson/\">GSON</a> to read and\n * write Java objects directly.\n *\n * @author  unascribed\n * @see java.io.ObjectOutputStream\n * @see java.io.ObjectInputStream\n * @see java.io.ObjectOutput\n * @see java.io.ObjectInput\n * @see java.io.Externalizable\n * @since   1.1\n ",
  "links" : [ "java.io.InvalidClassException", "android.util.JsonReader", "org.json.JSONObject" ],
  "variables" : [ ],
  "methods" : [ ],
  "methodNames" : [ ],
  "variableNames" : [ ]
}