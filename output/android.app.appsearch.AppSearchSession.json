{
  "filePath" : "/home/maryam/clearblue/files/android-source-35/android/app/appsearch/AppSearchSession.java",
  "packageName" : "android.app.appsearch",
  "className" : "AppSearchSession",
  "comment" : "\n * Provides a connection to a single AppSearch database.\n *\n * <p>An {@link AppSearchSession} instance provides access to database operations such as setting a\n * schema, adding documents, and searching.\n *\n * <p>This class is thread safe.\n *\n * @see GlobalSearchSession\n ",
  "links" : [ "android.app.appsearch.AppSearchSession" ],
  "variables" : [ {
    "name" : "TAG",
    "type" : "String",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mCallerAttributionSource",
    "type" : "AppSearchAttributionSource",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mDatabaseName",
    "type" : "String",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mUserHandle",
    "type" : "UserHandle",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mService",
    "type" : "IAppSearchManager",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mCacheDirectory",
    "type" : "File",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mIsMutated",
    "type" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mIsClosed",
    "type" : "boolean",
    "comment" : "",
    "links" : [ ]
  } ],
  "methods" : [ {
    "name" : " static void createSearchSession(@NonNull AppSearchManager.SearchContext searchContext, @NonNull IAppSearchManager service, @NonNull UserHandle userHandle, @NonNull AppSearchAttributionSource callerAttributionSource, @Nullable File cacheDirectory, @NonNull @CallbackExecutor Executor executor, @NonNull Consumer<AppSearchResult<AppSearchSession>> callback)",
    "returnType" : "void",
    "comment" : "\n     * Creates a search session for the client, defined by the {@code userHandle} and {@code\n     * packageName}.\n     *\n     * @param searchContext The {@link AppSearchManager.SearchContext} contains all information to\n     *     create a new {@link AppSearchSession}.\n     * @param service The {@link IAppSearchManager} service from which to make api calls.\n     * @param userHandle The user for which the session should be created.\n     * @param callerAttributionSource The attribution source containing the caller's package name\n     *     and uid.\n     * @param cacheDirectory The directory to create temporary files needed for migration. If this\n     *     is null, the default temporary-file directory (/data/local/tmp) will be used.\n     * @param executor Executor on which to invoke the callback.\n     * @param callback The {@link AppSearchResult}&lt;{@link AppSearchSession}&gt; of performing\n     *     this operation. Or a {@link AppSearchResult} with failure reason code and error\n     *     information.\n     ",
    "links" : [ "android.app.appsearch.AppSearchResult", "AppSearchManager.SearchContext", "android.app.appsearch.aidl.IAppSearchManager", "android.app.appsearch.AppSearchSession" ]
  }, {
    "name" : "private void initialize(@NonNull @CallbackExecutor Executor executor, @NonNull Consumer<AppSearchResult<AppSearchSession>> callback)",
    "returnType" : "void",
    "comment" : " Once the callback.accept has been called here, the class is ready to use.",
    "links" : [ ]
  }, {
    "name" : "public void setSchema(@NonNull SetSchemaRequest request, @NonNull Executor workExecutor, @NonNull @CallbackExecutor Executor callbackExecutor, @NonNull Consumer<AppSearchResult<SetSchemaResponse>> callback)",
    "returnType" : "void",
    "comment" : "\n     * Sets the schema that represents the organizational structure of data within the AppSearch\n     * database.\n     *\n     * <p>Upon creating an {@link AppSearchSession}, {@link #setSchema} should be called. If the\n     * schema needs to be updated, or it has not been previously set, then the provided schema will\n     * be saved and persisted to disk. Otherwise, {@link #setSchema} is handled efficiently as a\n     * no-op call.\n     *\n     * @param request the schema to set or update the AppSearch database to.\n     * @param workExecutor Executor on which to schedule heavy client-side background work such as\n     *     transforming documents.\n     * @param callbackExecutor Executor on which to invoke the callback.\n     * @param callback Callback to receive errors resulting from setting the schema. If the\n     *     operation succeeds, the callback will be invoked with {@code null}.\n     ",
    "links" : [ "#setSchema", "android.app.appsearch.AppSearchSession" ]
  }, {
    "name" : "public void getSchema(@NonNull @CallbackExecutor Executor executor, @NonNull Consumer<AppSearchResult<GetSchemaResponse>> callback)",
    "returnType" : "void",
    "comment" : "\n     * Retrieves the schema most recently successfully provided to {@link #setSchema}.\n     *\n     * @param executor Executor on which to invoke the callback.\n     * @param callback Callback to receive the pending results of schema.\n     ",
    "links" : [ "#setSchema" ]
  }, {
    "name" : "public void getNamespaces(@NonNull @CallbackExecutor Executor executor, @NonNull Consumer<AppSearchResult<Set<String>>> callback)",
    "returnType" : "void",
    "comment" : "\n     * Retrieves the set of all namespaces in the current database with at least one document.\n     *\n     * @param executor Executor on which to invoke the callback.\n     * @param callback Callback to receive the namespaces.\n     ",
    "links" : [ ]
  }, {
    "name" : "public void put(@NonNull PutDocumentsRequest request, @NonNull @CallbackExecutor Executor executor, @NonNull BatchResultCallback<String, Void> callback)",
    "returnType" : "void",
    "comment" : "\n     * Indexes documents into the {@link AppSearchSession} database.\n     *\n     * <p>Each {@link GenericDocument} object must have a {@code schemaType} field set to an {@link\n     * AppSearchSchema} type that has been previously registered by calling the {@link #setSchema}\n     * method.\n     *\n     * @param request containing documents to be indexed.\n     * @param executor Executor on which to invoke the callback.\n     * @param callback Callback to receive pending result of performing this operation. The keys of\n     *     the returned {@link AppSearchBatchResult} are the IDs of the input documents. The values\n     *     are {@code null} if they were successfully indexed, or a failed {@link AppSearchResult}\n     *     otherwise. If an unexpected internal error occurs in the AppSearch service, {@link\n     *     BatchResultCallback#onSystemError} will be invoked with a {@link Throwable}.\n     ",
    "links" : [ "android.app.appsearch.AppSearchSchema", "android.app.appsearch.AppSearchResult", "android.app.appsearch.AppSearchBatchResult", "#setSchema", "android.app.appsearch.aidl.IAppSearchBatchResultCallback#onSystemError", "Throwable", "android.app.appsearch.AppSearchSession", "android.app.appsearch.GenericDocument" ]
  }, {
    "name" : "public void getByDocumentId(@NonNull GetByDocumentIdRequest request, @NonNull @CallbackExecutor Executor executor, @NonNull BatchResultCallback<String, GenericDocument> callback)",
    "returnType" : "void",
    "comment" : "\n     * Gets {@link GenericDocument} objects by document IDs in a namespace from the {@link\n     * AppSearchSession} database.\n     *\n     * @param request a request containing a namespace and IDs to get documents for.\n     * @param executor Executor on which to invoke the callback.\n     * @param callback Callback to receive the pending result of performing this operation. The keys\n     *     of the returned {@link AppSearchBatchResult} are the input IDs. The values are the\n     *     returned {@link GenericDocument}s on success, or a failed {@link AppSearchResult}\n     *     otherwise. IDs that are not found will return a failed {@link AppSearchResult} with a\n     *     result code of {@link AppSearchResult#RESULT_NOT_FOUND}. If an unexpected internal error\n     *     occurs in the AppSearch service, {@link BatchResultCallback#onSystemError} will be\n     *     invoked with a {@link Throwable}.\n     ",
    "links" : [ "android.app.appsearch.AppSearchResult", "android.app.appsearch.AppSearchBatchResult", "android.app.appsearch.AppSearchResult#RESULT_NOT_FOUND", "android.app.appsearch.aidl.IAppSearchBatchResultCallback#onSystemError", "Throwable", "android.app.appsearch.AppSearchSession", "android.app.appsearch.GenericDocument" ]
  }, {
    "name" : "public SearchResults search(@NonNull String queryExpression, @NonNull SearchSpec searchSpec)",
    "returnType" : "SearchResults",
    "comment" : "\n     * Retrieves documents from the open {@link AppSearchSession} that match a given query string\n     * and type of search provided.\n     *\n     * <p>Query strings can be empty, contain one term with no operators, or contain multiple terms\n     * and operators.\n     *\n     * <p>For query strings that are empty, all documents that match the {@link SearchSpec} will be\n     * returned.\n     *\n     * <p>For query strings with a single term and no operators, documents that match the provided\n     * query string and {@link SearchSpec} will be returned.\n     *\n     * <p>The following operators are supported:\n     *\n     * <ul>\n     *   <li>AND (implicit)\n     *       <p>AND is an operator that matches documents that contain <i>all</i> provided terms.\n     *       <p><b>NOTE:</b> A space between terms is treated as an \"AND\" operator. Explicitly\n     *       including \"AND\" in a query string will treat \"AND\" as a term, returning documents that\n     *       also contain \"AND\".\n     *       <p>Example: \"apple AND banana\" matches documents that contain the terms \"apple\", \"and\",\n     *       \"banana\".\n     *       <p>Example: \"apple banana\" matches documents that contain both \"apple\" and \"banana\".\n     *       <p>Example: \"apple banana cherry\" matches documents that contain \"apple\", \"banana\", and\n     *       \"cherry\".\n     *   <li>OR\n     *       <p>OR is an operator that matches documents that contain <i>any</i> provided term.\n     *       <p>Example: \"apple OR banana\" matches documents that contain either \"apple\" or\n     *       \"banana\".\n     *       <p>Example: \"apple OR banana OR cherry\" matches documents that contain any of \"apple\",\n     *       \"banana\", or \"cherry\".\n     *   <li>Exclusion (-)\n     *       <p>Exclusion (-) is an operator that matches documents that <i>do not</i> contain the\n     *       provided term.\n     *       <p>Example: \"-apple\" matches documents that do not contain \"apple\".\n     *   <li>Grouped Terms\n     *       <p>For queries that require multiple operators and terms, terms can be grouped into\n     *       subqueries. Subqueries are contained within an open \"(\" and close \")\" parenthesis.\n     *       <p>Example: \"(donut OR bagel) (coffee OR tea)\" matches documents that contain either\n     *       \"donut\" or \"bagel\" and either \"coffee\" or \"tea\".\n     *   <li>Property Restricts\n     *       <p>For queries that require a term to match a specific {@link AppSearchSchema} property\n     *       of a document, a \":\" must be included between the property name and the term.\n     *       <p>Example: \"subject:important\" matches documents that contain the term \"important\" in\n     *       the \"subject\" property.\n     * </ul>\n     *\n     * <p>The above description covers the basic query operators. Additional advanced query operator\n     * features should be explicitly enabled in the SearchSpec and are described below.\n     *\n     * <p>LIST_FILTER_QUERY_LANGUAGE: This feature covers the expansion of the query language to\n     * conform to the definition of the list filters language (https://aip.dev/160). This includes:\n     *\n     * <ul>\n     *   <li>addition of explicit 'AND' and 'NOT' operators\n     *   <li>property restricts are allowed with groupings (ex. \"prop:(a OR b)\")\n     *   <li>addition of custom functions to control matching\n     * </ul>\n     *\n     * <p>The newly added custom functions covered by this feature are:\n     *\n     * <ul>\n     *   <li>createList(String...)\n     *   <li>search(String, List&lt;String&gt;)\n     *   <li>propertyDefined(String)\n     * </ul>\n     *\n     * <p>createList takes a variable number of strings and returns a list of strings. It is for use\n     * with search.\n     *\n     * <p>search takes a query string that will be parsed according to the supported query language\n     * and an optional list of strings that specify the properties to be restricted to. This exists\n     * as a convenience for multiple property restricts. So, for example, the query `(subject:foo OR\n     * body:foo) (subject:bar OR body:bar)` could be rewritten as `search(\"foo bar\",\n     * createList(\"subject\", \"bar\"))`.\n     *\n     * <p>propertyDefined takes a string specifying the property of interest and matches all\n     * documents of any type that defines the specified property (ex.\n     * `propertyDefined(\"sender.name\")`). Note that propertyDefined will match so long as the\n     * document's type defines the specified property. It does NOT require that the document\n     * actually hold any values for this property.\n     *\n     * <p>NUMERIC_SEARCH: This feature covers numeric search expressions. In the query language, the\n     * values of properties that have {@link AppSearchSchema.LongPropertyConfig#INDEXING_TYPE_RANGE}\n     * set can be matched with a numeric search expression (the property, a supported comparator and\n     * an integer value). Supported comparators are <, <=, ==, >= and >.\n     *\n     * <p>Ex. `price < 10` will match all documents that has a numeric value in its price property\n     * that is less than 10.\n     *\n     * <p>VERBATIM_SEARCH: This feature covers the verbatim string operator (quotation marks).\n     *\n     * <p>Ex. `\"foo/bar\" OR baz` will ensure that 'foo/bar' is treated as a single 'verbatim' token.\n     *\n     * <p>Additional search specifications, such as filtering by {@link AppSearchSchema} type or\n     * adding projection, can be set by calling the corresponding {@link SearchSpec.Builder} setter.\n     *\n     * <p>This method is lightweight. The heavy work will be done in {@link\n     * SearchResults#getNextPage}.\n     *\n     * @param queryExpression query string to search.\n     * @param searchSpec spec for setting document filters, adding projection, setting term match\n     *     type, etc.\n     * @return a {@link SearchResults} object for retrieved matched documents.\n     ",
    "links" : [ "android.app.appsearch.AppSearchSchema", "SearchSpec.Builder", "android.app.appsearch.SearchResults", "android.app.appsearch.SearchResults#getNextPage", "android.app.appsearch.AppSearchSession", "AppSearchSchema.LongPropertyConfig#INDEXING_TYPE_RANGE", "android.app.appsearch.SearchSpec" ]
  }, {
    "name" : "public void searchSuggestion(@NonNull String suggestionQueryExpression, @NonNull SearchSuggestionSpec searchSuggestionSpec, @NonNull @CallbackExecutor Executor executor, @NonNull Consumer<AppSearchResult<List<SearchSuggestionResult>>> callback)",
    "returnType" : "void",
    "comment" : "\n     * Retrieves suggested Strings that could be used as {@code queryExpression} in {@link\n     * #search(String, SearchSpec)} API.\n     *\n     * <p>The {@code suggestionQueryExpression} can contain one term with no operators, or contain\n     * multiple terms and operators. Operators will be considered as a normal term. Please see the\n     * operator examples below. The {@code suggestionQueryExpression} must end with a valid term,\n     * the suggestions are generated based on the last term. If the input {@code\n     * suggestionQueryExpression} doesn't have a valid token, AppSearch will return an empty result\n     * list. Please see the invalid examples below.\n     *\n     * <p>Example: if there are following documents with content stored in AppSearch.\n     *\n     * <ul>\n     *   <li>document1: \"term1\"\n     *   <li>document2: \"term1 term2\"\n     *   <li>document3: \"term1 term2 term3\"\n     *   <li>document4: \"org\"\n     * </ul>\n     *\n     * <p>Search suggestions with the single term {@code suggestionQueryExpression} \"t\", the\n     * suggested results are:\n     *\n     * <ul>\n     *   <li>\"term1\" - Use it to be queryExpression in {@link #search} could get 3 {@link\n     *       SearchResult}s, which contains document 1, 2 and 3.\n     *   <li>\"term2\" - Use it to be queryExpression in {@link #search} could get 2 {@link\n     *       SearchResult}s, which contains document 2 and 3.\n     *   <li>\"term3\" - Use it to be queryExpression in {@link #search} could get 1 {@link\n     *       SearchResult}, which contains document 3.\n     * </ul>\n     *\n     * <p>Search suggestions with the multiple term {@code suggestionQueryExpression} \"org t\", the\n     * suggested result will be \"org term1\" - The last token is completed by the suggested String.\n     *\n     * <p>Operators in {@link #search} are supported.\n     *\n     * <p><b>NOTE:</b> Exclusion and Grouped Terms in the last term is not supported.\n     *\n     * <p>example: \"apple -f\": This Api will throw an {@link\n     * android.app.appsearch.exceptions.AppSearchException} with {@link\n     * AppSearchResult#RESULT_INVALID_ARGUMENT}.\n     *\n     * <p>example: \"apple (f)\": This Api will return an empty results.\n     *\n     * <p>Invalid example: All these input {@code suggestionQueryExpression} don't have a valid last\n     * token, AppSearch will return an empty result list.\n     *\n     * <ul>\n     *   <li>\"\" - Empty {@code suggestionQueryExpression}.\n     *   <li>\"(f)\" - Ending in a closed brackets.\n     *   <li>\"f:\" - Ending in an operator.\n     *   <li>\"f \" - Ending in trailing space.\n     * </ul>\n     *\n     * @param suggestionQueryExpression the non empty query string to search suggestions\n     * @param searchSuggestionSpec spec for setting document filters\n     * @param executor Executor on which to invoke the callback.\n     * @param callback Callback to receive the pending result of performing this operation, which is\n     *     a List of {@link SearchSuggestionResult} on success. The returned suggestion Strings are\n     *     ordered by the number of {@link SearchResult} you could get by using that suggestion in\n     *     {@link #search}.\n     * @see #search(String, SearchSpec)\n     ",
    "links" : [ "android.app.appsearch.AppSearchResult#RESULT_INVALID_ARGUMENT", "android.app.appsearch.SearchSuggestionResult", "#search(String", "#search", "android.app.appsearch.SearchResult", "android.app.appsearch.exceptions.AppSearchException" ]
  }, {
    "name" : "public void reportUsage(@NonNull ReportUsageRequest request, @NonNull @CallbackExecutor Executor executor, @NonNull Consumer<AppSearchResult<Void>> callback)",
    "returnType" : "void",
    "comment" : "\n     * Reports usage of a particular document by namespace and ID.\n     *\n     * <p>A usage report represents an event in which a user interacted with or viewed a document.\n     *\n     * <p>For each call to {@link #reportUsage}, AppSearch updates usage count and usage recency\n     * metrics for that particular document. These metrics are used for ordering {@link #search}\n     * results by the {@link SearchSpec#RANKING_STRATEGY_USAGE_COUNT} and {@link\n     * SearchSpec#RANKING_STRATEGY_USAGE_LAST_USED_TIMESTAMP} ranking strategies.\n     *\n     * <p>Reporting usage of a document is optional.\n     *\n     * @param request The usage reporting request.\n     * @param executor Executor on which to invoke the callback.\n     * @param callback Callback to receive errors. If the operation succeeds, the callback will be\n     *     invoked with {@code null}.\n     ",
    "links" : [ "#reportUsage", "android.app.appsearch.SearchSpec#RANKING_STRATEGY_USAGE_COUNT", "android.app.appsearch.SearchSpec#RANKING_STRATEGY_USAGE_LAST_USED_TIMESTAMP", "#search" ]
  }, {
    "name" : "public void remove(@NonNull RemoveByDocumentIdRequest request, @NonNull @CallbackExecutor Executor executor, @NonNull BatchResultCallback<String, Void> callback)",
    "returnType" : "void",
    "comment" : "\n     * Removes {@link GenericDocument} objects by document IDs in a namespace from the {@link\n     * AppSearchSession} database.\n     *\n     * <p>Removed documents will no longer be surfaced by {@link #search} or {@link\n     * #getByDocumentId} calls.\n     *\n     * <p>Once the database crosses the document count or byte usage threshold, removed documents\n     * will be deleted from disk.\n     *\n     * @param request {@link RemoveByDocumentIdRequest} with IDs in a namespace to remove from the\n     *     index.\n     * @param executor Executor on which to invoke the callback.\n     * @param callback Callback to receive the pending result of performing this operation. The keys\n     *     of the returned {@link AppSearchBatchResult} are the input document IDs. The values are\n     *     {@code null} on success, or a failed {@link AppSearchResult} otherwise. IDs that are not\n     *     found will return a failed {@link AppSearchResult} with a result code of {@link\n     *     AppSearchResult#RESULT_NOT_FOUND}. If an unexpected internal error occurs in the\n     *     AppSearch service, {@link BatchResultCallback#onSystemError} will be invoked with a\n     *     {@link Throwable}.\n     ",
    "links" : [ "android.app.appsearch.AppSearchResult", "android.app.appsearch.AppSearchBatchResult", "android.app.appsearch.AppSearchResult#RESULT_NOT_FOUND", "android.app.appsearch.aidl.IAppSearchBatchResultCallback#onSystemError", "Throwable", "android.app.appsearch.AppSearchSession", "android.app.appsearch.GenericDocument", "android.app.appsearch.RemoveByDocumentIdRequest", "#getByDocumentId", "#search" ]
  }, {
    "name" : "public void remove(@NonNull String queryExpression, @NonNull SearchSpec searchSpec, @NonNull @CallbackExecutor Executor executor, @NonNull Consumer<AppSearchResult<Void>> callback)",
    "returnType" : "void",
    "comment" : "\n     * Removes {@link GenericDocument}s from the index by Query. Documents will be removed if they\n     * match the {@code queryExpression} in given namespaces and schemaTypes which is set via {@link\n     * SearchSpec.Builder#addFilterNamespaces} and {@link SearchSpec.Builder#addFilterSchemas}.\n     *\n     * <p>An empty {@code queryExpression} matches all documents.\n     *\n     * <p>An empty set of namespaces or schemaTypes matches all namespaces or schemaTypes in the\n     * current database.\n     *\n     * @param queryExpression Query String to search.\n     * @param searchSpec Spec containing schemaTypes, namespaces and query expression indicates how\n     *     document will be removed. All specific about how to scoring, ordering, snippeting and\n     *     resulting will be ignored.\n     * @param executor Executor on which to invoke the callback.\n     * @param callback Callback to receive errors resulting from removing the documents. If the\n     *     operation succeeds, the callback will be invoked with {@code null}.\n     ",
    "links" : [ "SearchSpec.Builder#addFilterSchemas", "SearchSpec.Builder#addFilterNamespaces", "android.app.appsearch.GenericDocument" ]
  }, {
    "name" : "public void getStorageInfo(@NonNull @CallbackExecutor Executor executor, @NonNull Consumer<AppSearchResult<StorageInfo>> callback)",
    "returnType" : "void",
    "comment" : "\n     * Gets the storage info for this {@link AppSearchSession} database.\n     *\n     * <p>This may take time proportional to the number of documents and may be inefficient to call\n     * repeatedly.\n     *\n     * @param executor Executor on which to invoke the callback.\n     * @param callback Callback to receive the storage info.\n     ",
    "links" : [ "android.app.appsearch.AppSearchSession" ]
  }, {
    "name" : "public void close()",
    "returnType" : "void",
    "comment" : "\n     * Closes the {@link AppSearchSession} to persist all schema and document updates, additions,\n     * and deletes to disk.\n     ",
    "links" : [ "android.app.appsearch.AppSearchSession" ]
  }, {
    "name" : "private void setSchemaNoMigrations(@NonNull SetSchemaRequest request, @NonNull List<AppSearchSchema> schemas, @NonNull List<InternalVisibilityConfig> visibilityConfigs, @NonNull @CallbackExecutor Executor executor, @NonNull Consumer<AppSearchResult<SetSchemaResponse>> callback)",
    "returnType" : "void",
    "comment" : "\n     * Set schema to Icing for no-migration scenario.\n     *\n     * <p>We only need one time {@link #setSchema} call for no-migration scenario by using the\n     * forceoverride in the request.\n     ",
    "links" : [ "#setSchema" ]
  }, {
    "name" : "private void setSchemaWithMigrations(@NonNull SetSchemaRequest request, @NonNull List<AppSearchSchema> schemas, @NonNull List<InternalVisibilityConfig> visibilityConfigs, @NonNull Executor workExecutor, @NonNull @CallbackExecutor Executor callbackExecutor, @NonNull Consumer<AppSearchResult<SetSchemaResponse>> callback)",
    "returnType" : "void",
    "comment" : "\n     * Set schema to Icing for migration scenario.\n     *\n     * <p>First time {@link #setSchema} call with forceOverride is false gives us all incompatible\n     * changes. After trigger migrations, the second time call {@link #setSchema} will actually\n     * apply the changes.\n     ",
    "links" : [ "#setSchema" ]
  }, {
    "name" : "private static List<GenericDocumentParcel> toGenericDocumentParcels(List<GenericDocument> docs)",
    "returnType" : "List<GenericDocumentParcel>",
    "comment" : "",
    "links" : [ ]
  } ],
  "methodNames" : [ " static void createSearchSession(@NonNull AppSearchManager.SearchContext searchContext, @NonNull IAppSearchManager service, @NonNull UserHandle userHandle, @NonNull AppSearchAttributionSource callerAttributionSource, @Nullable File cacheDirectory, @NonNull @CallbackExecutor Executor executor, @NonNull Consumer<AppSearchResult<AppSearchSession>> callback)", "private void initialize(@NonNull @CallbackExecutor Executor executor, @NonNull Consumer<AppSearchResult<AppSearchSession>> callback)", "public void setSchema(@NonNull SetSchemaRequest request, @NonNull Executor workExecutor, @NonNull @CallbackExecutor Executor callbackExecutor, @NonNull Consumer<AppSearchResult<SetSchemaResponse>> callback)", "public void getSchema(@NonNull @CallbackExecutor Executor executor, @NonNull Consumer<AppSearchResult<GetSchemaResponse>> callback)", "public void getNamespaces(@NonNull @CallbackExecutor Executor executor, @NonNull Consumer<AppSearchResult<Set<String>>> callback)", "public void put(@NonNull PutDocumentsRequest request, @NonNull @CallbackExecutor Executor executor, @NonNull BatchResultCallback<String, Void> callback)", "public void getByDocumentId(@NonNull GetByDocumentIdRequest request, @NonNull @CallbackExecutor Executor executor, @NonNull BatchResultCallback<String, GenericDocument> callback)", "public SearchResults search(@NonNull String queryExpression, @NonNull SearchSpec searchSpec)", "public void searchSuggestion(@NonNull String suggestionQueryExpression, @NonNull SearchSuggestionSpec searchSuggestionSpec, @NonNull @CallbackExecutor Executor executor, @NonNull Consumer<AppSearchResult<List<SearchSuggestionResult>>> callback)", "public void reportUsage(@NonNull ReportUsageRequest request, @NonNull @CallbackExecutor Executor executor, @NonNull Consumer<AppSearchResult<Void>> callback)", "public void remove(@NonNull RemoveByDocumentIdRequest request, @NonNull @CallbackExecutor Executor executor, @NonNull BatchResultCallback<String, Void> callback)", "public void remove(@NonNull String queryExpression, @NonNull SearchSpec searchSpec, @NonNull @CallbackExecutor Executor executor, @NonNull Consumer<AppSearchResult<Void>> callback)", "public void getStorageInfo(@NonNull @CallbackExecutor Executor executor, @NonNull Consumer<AppSearchResult<StorageInfo>> callback)", "public void close()", "private void setSchemaNoMigrations(@NonNull SetSchemaRequest request, @NonNull List<AppSearchSchema> schemas, @NonNull List<InternalVisibilityConfig> visibilityConfigs, @NonNull @CallbackExecutor Executor executor, @NonNull Consumer<AppSearchResult<SetSchemaResponse>> callback)", "private void setSchemaWithMigrations(@NonNull SetSchemaRequest request, @NonNull List<AppSearchSchema> schemas, @NonNull List<InternalVisibilityConfig> visibilityConfigs, @NonNull Executor workExecutor, @NonNull @CallbackExecutor Executor callbackExecutor, @NonNull Consumer<AppSearchResult<SetSchemaResponse>> callback)", "private static List<GenericDocumentParcel> toGenericDocumentParcels(List<GenericDocument> docs)" ],
  "variableNames" : [ "TAG", "mCallerAttributionSource", "mDatabaseName", "mUserHandle", "mService", "mCacheDirectory", "mIsMutated", "mIsClosed" ]
}