{
  "filePath" : "/home/maryam/clearblue/files/android-source-30/android/view/ScrollCaptureTargetResolver.java",
  "packageName" : "android.view",
  "className" : "ScrollCaptureTargetResolver",
  "comment" : "\n * Queries additional state from a list of {@link ScrollCaptureTarget targets} via asynchronous\n * callbacks, then aggregates and reduces the target list to a single target, or null if no target\n * is suitable.\n * <p>\n * The rules for selection are (in order):\n * <ul>\n * <li>prefer getScrollBounds(): non-empty\n * <li>prefer View.getScrollCaptureHint == SCROLL_CAPTURE_HINT_INCLUDE\n * <li>prefer descendants before parents\n * <li>prefer larger area for getScrollBounds() (clipped to view bounds)\n * </ul>\n *\n * <p>\n * All calls to {@link ScrollCaptureCallback#onScrollCaptureSearch} are made on the main thread,\n * with results are queued and consumed to the main thread as well.\n *\n * @see #start(Handler, long, Consumer)\n *\n * @hide\n ",
  "variables" : [ {
    "name" : "TAG",
    "type" : "String",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "DEBUG",
    "type" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mLock",
    "type" : "Object",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mTargets",
    "type" : "Queue<ScrollCaptureTarget>",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mHandler",
    "type" : "Handler",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mTimeLimitMillis",
    "type" : "long",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mWhenComplete",
    "type" : "Consumer<ScrollCaptureTarget>",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mPendingBoundsRequests",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mDeadlineMillis",
    "type" : "long",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mResult",
    "type" : "ScrollCaptureTarget",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mFinished",
    "type" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mStarted",
    "type" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mTimeoutRunnable",
    "type" : "Runnable",
    "comment" : "",
    "links" : [ ]
  } ],
  "methods" : [ {
    "name" : "private static int area(Rect r)",
    "returnType" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private static boolean nullOrEmpty(Rect r)",
    "returnType" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private static ScrollCaptureTarget chooseTarget(ScrollCaptureTarget a, ScrollCaptureTarget b)",
    "returnType" : "ScrollCaptureTarget",
    "comment" : "\n     * Binary operator which selects the best {@link ScrollCaptureTarget}.\n     ",
    "links" : [ "ScrollCaptureTarget" ]
  }, {
    "name" : " void checkThread()",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public ScrollCaptureTarget waitForResult() throws InterruptedException",
    "returnType" : "ScrollCaptureTarget",
    "comment" : "\n     * Blocks until a result is returned (after completion or timeout).\n     * <p>\n     * For testing only. Normal usage should receive a callback after calling {@link #start}.\n     ",
    "links" : [ "#start" ]
  }, {
    "name" : "private void supplyResult(ScrollCaptureTarget target)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public void start(Handler uiHandler, long timeLimitMillis, Consumer<ScrollCaptureTarget> resultConsumer)",
    "returnType" : "void",
    "comment" : "\n     * Asks all targets for {@link ScrollCaptureCallback#onScrollCaptureSearch(Consumer)\n     * scrollBounds}, and selects the primary target according to the {@link\n     * #chooseTarget} function.\n     *\n     * @param timeLimitMillis the amount of time to wait for all responses before delivering the top\n     *                        result\n     * @param resultConsumer  the consumer to receive the primary target\n     ",
    "links" : [ "ScrollCaptureCallback#onScrollCaptureSearch" ]
  }, {
    "name" : "private void run(long timeLimitMillis, Consumer<ScrollCaptureTarget> resultConsumer)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private void queryTarget(@NonNull ScrollCaptureTarget target)",
    "returnType" : "void",
    "comment" : "\n     * Adds a target to the list and requests {@link ScrollCaptureCallback#onScrollCaptureSearch}\n     * scrollBounds} from it. Results are returned by a call to {@link #onScrollBoundsProvided}.\n     *\n     * @param target the target to add\n     ",
    "links" : [ "ScrollCaptureCallback#onScrollCaptureSearch", "#onScrollBoundsProvided" ]
  }, {
    "name" : "private void onScrollBoundsProvided(ScrollCaptureTarget target, @Nullable Rect scrollBounds)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private static boolean hasIncludeHint(View view)",
    "returnType" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private static boolean isDescendant(@NonNull View view, @NonNull View otherView)",
    "returnType" : "boolean",
    "comment" : "\n     * Determines if {@code otherView} is a descendant of {@code view}.\n     *\n     * @param view      a view\n     * @param otherView another view\n     * @return true if {@code view} is an ancestor of {@code otherView}\n     ",
    "links" : [ ]
  }, {
    "name" : "private static int findRelation(@NonNull View a, @NonNull View b)",
    "returnType" : "int",
    "comment" : "",
    "links" : [ ]
  } ],
  "variableNames" : [ "TAG", "DEBUG", "mLock", "mTargets", "mHandler", "mTimeLimitMillis", "mWhenComplete", "mPendingBoundsRequests", "mDeadlineMillis", "mResult", "mFinished", "mStarted", "mTimeoutRunnable" ],
  "methodNames" : [ "private static int area(Rect r)", "private static boolean nullOrEmpty(Rect r)", "private static ScrollCaptureTarget chooseTarget(ScrollCaptureTarget a, ScrollCaptureTarget b)", " void checkThread()", "public ScrollCaptureTarget waitForResult() throws InterruptedException", "private void supplyResult(ScrollCaptureTarget target)", "public void start(Handler uiHandler, long timeLimitMillis, Consumer<ScrollCaptureTarget> resultConsumer)", "private void run(long timeLimitMillis, Consumer<ScrollCaptureTarget> resultConsumer)", "private void queryTarget(@NonNull ScrollCaptureTarget target)", "private void onScrollBoundsProvided(ScrollCaptureTarget target, @Nullable Rect scrollBounds)", "private static boolean hasIncludeHint(View view)", "private static boolean isDescendant(@NonNull View view, @NonNull View otherView)", "private static int findRelation(@NonNull View a, @NonNull View b)" ]
}