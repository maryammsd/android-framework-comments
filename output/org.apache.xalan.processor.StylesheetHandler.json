{
  "filePath" : "/home/maryam/clearblue/files/android-source-35/org/apache/xalan/processor/StylesheetHandler.java",
  "packageName" : "org.apache.xalan.processor",
  "className" : "StylesheetHandler",
  "comment" : "\n * Initializes and processes a stylesheet via SAX events.\n * This class acts as essentially a state machine, maintaining\n * a ContentHandler stack, and pushing appropriate content\n * handlers as parse events occur.\n * @xsl.usage advanced\n ",
  "links" : [ ],
  "variables" : [ {
    "name" : "m_funcTable",
    "type" : "FunctionTable",
    "comment" : "\n   * The function table of XPath and XSLT;\n   ",
    "links" : [ ]
  }, {
    "name" : "m_optimize",
    "type" : "boolean",
    "comment" : "\n   * The flag for the setting of the optimize feature;\n   ",
    "links" : [ ]
  }, {
    "name" : "m_incremental",
    "type" : "boolean",
    "comment" : "\n   * The flag for the setting of the incremental feature;\n   ",
    "links" : [ ]
  }, {
    "name" : "m_source_location",
    "type" : "boolean",
    "comment" : "\n   * The flag for the setting of the source_location feature;\n   ",
    "links" : [ ]
  }, {
    "name" : "m_stylesheetLevel",
    "type" : "int",
    "comment" : "\n   * The level of the stylesheet we are at.\n   ",
    "links" : [ ]
  }, {
    "name" : "m_parsingComplete",
    "type" : "boolean",
    "comment" : " m_parsingComplete becomes true when the top-level stylesheet and all\n   * its included/imported stylesheets have been been fully parsed, as an\n   * indication that composition/optimization/compilation can begin.\n   * @see isStylesheetParsingComplete  ",
    "links" : [ ]
  }, {
    "name" : "m_prefixMappings",
    "type" : "java.util.Vector",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "m_shouldProcess",
    "type" : "boolean",
    "comment" : "\n   * If we have a URL to a XML fragment, this is set\n   * to false until the ID is found.\n   * (warning: I worry that this should be in a stack).\n   ",
    "links" : [ ]
  }, {
    "name" : "m_fragmentIDString",
    "type" : "String",
    "comment" : "\n   * If we have a URL to a XML fragment, the value is stored\n   * in this string, and the m_shouldProcess flag is set to\n   * false until we match an ID with this string.\n   * (warning: I worry that this should be in a stack).\n   ",
    "links" : [ ]
  }, {
    "name" : "m_elementID",
    "type" : "int",
    "comment" : "\n   * Keep track of the elementID, so we can tell when\n   * is has completed.  This isn't a real ID, but rather\n   * a nesting level.  However, it's good enough for\n   * our purposes.\n   * (warning: I worry that this should be in a stack).\n   ",
    "links" : [ ]
  }, {
    "name" : "m_fragmentID",
    "type" : "int",
    "comment" : "\n   * The ID of the fragment that has been found\n   * (warning: I worry that this should be in a stack).\n   ",
    "links" : [ ]
  }, {
    "name" : "m_stylesheetProcessor",
    "type" : "TransformerFactoryImpl",
    "comment" : "\n   *  The XSLT TransformerFactory for needed services.\n   ",
    "links" : [ ]
  }, {
    "name" : "STYPE_ROOT",
    "type" : "int",
    "comment" : "\n   * If getStylesheetType returns this value, the current stylesheet\n   *  is a root stylesheet.\n   * @xsl.usage internal\n   ",
    "links" : [ ]
  }, {
    "name" : "STYPE_INCLUDE",
    "type" : "int",
    "comment" : "\n   * If getStylesheetType returns this value, the current stylesheet\n   *  is an included stylesheet.\n   * @xsl.usage internal\n   ",
    "links" : [ ]
  }, {
    "name" : "STYPE_IMPORT",
    "type" : "int",
    "comment" : "\n   * If getStylesheetType returns this value, the current stylesheet\n   *  is an imported stylesheet.\n   * @xsl.usage internal\n   ",
    "links" : [ ]
  }, {
    "name" : "m_stylesheetType",
    "type" : "int",
    "comment" : " The current stylesheet type. ",
    "links" : [ ]
  }, {
    "name" : "m_stylesheets",
    "type" : "Stack",
    "comment" : "\n   * The stack of stylesheets being processed.\n   ",
    "links" : [ ]
  }, {
    "name" : "m_stylesheetRoot",
    "type" : "StylesheetRoot",
    "comment" : " The root stylesheet of the stylesheets tree. ",
    "links" : [ ]
  }, {
    "name" : "m_lastPoppedStylesheet",
    "type" : "Stylesheet",
    "comment" : " The last stylesheet that was popped off the stylesheets stack. ",
    "links" : [ ]
  }, {
    "name" : "m_processors",
    "type" : "Stack",
    "comment" : "\n   * The stack of current processors.\n   ",
    "links" : [ ]
  }, {
    "name" : "m_schema",
    "type" : "XSLTSchema",
    "comment" : "\n   * The root of the XSLT Schema, which tells us how to\n   * transition content handlers, create elements, etc.\n   * For the moment at least, this can't be static, since\n   * the processors store state.\n   ",
    "links" : [ ]
  }, {
    "name" : "m_elems",
    "type" : "Stack",
    "comment" : "\n   * The stack of elements, pushed and popped as events occur.\n   ",
    "links" : [ ]
  }, {
    "name" : "m_docOrderCount",
    "type" : "int",
    "comment" : " An increasing number that is used to indicate the order in which this element\n   *  was encountered during the parse of the XSLT tree.\n   ",
    "links" : [ ]
  }, {
    "name" : "m_baseIdentifiers",
    "type" : "Stack",
    "comment" : "\n   * This will act as a stack to keep track of the\n   * current include base.\n   ",
    "links" : [ ]
  }, {
    "name" : "m_stylesheetLocatorStack",
    "type" : "Stack",
    "comment" : "\n   * The top of this stack should contain the currently processed\n   * stylesheet SAX locator object.\n   ",
    "links" : [ ]
  }, {
    "name" : "m_importStack",
    "type" : "Stack",
    "comment" : "\n   * A stack of URL hrefs for imported stylesheets.  This is\n   * used to diagnose circular imports.\n   ",
    "links" : [ ]
  }, {
    "name" : "m_importSourceStack",
    "type" : "Stack",
    "comment" : "\n   * A stack of Source objects obtained from a URIResolver,\n   * for each element in this stack there is a 1-1 correspondence\n   * with an element in the m_importStack.\n   ",
    "links" : [ ]
  }, {
    "name" : "warnedAboutOldXSLTNamespace",
    "type" : "boolean",
    "comment" : "\n   * If this is set to true, we've already warned about using the\n   * older XSLT namespace URL.\n   ",
    "links" : [ ]
  }, {
    "name" : "m_nsSupportStack",
    "type" : "Stack",
    "comment" : " Stack of NamespaceSupport objects. ",
    "links" : [ ]
  }, {
    "name" : "m_originatingNode",
    "type" : "Node",
    "comment" : "\n   * The originating node if the current stylesheet is being created\n   *  from a DOM.\n   *  @see org.apache.xml.utils.NodeConsumer\n   ",
    "links" : [ ]
  }, {
    "name" : "m_spacePreserveStack",
    "type" : "BoolStack",
    "comment" : "\n   * Stack of booleans that are pushed and popped in start/endElement depending \n   * on the value of xml:space=default/preserve.\n   ",
    "links" : [ ]
  } ],
  "methods" : [ {
    "name" : " void init(TransformerFactoryImpl processor)",
    "returnType" : "void",
    "comment" : "\n   * Do common initialization.\n   *\n   * @param processor non-null reference to the transformer factory that owns this handler.\n   ",
    "links" : [ ]
  }, {
    "name" : "public XPath createXPath(String str, ElemTemplateElement owningTemplate) throws javax.xml.transform.TransformerException",
    "returnType" : "XPath",
    "comment" : "\n   * Process an expression string into an XPath.\n   * Must be public for access by the AVT class.\n   *\n   * @param str A non-null reference to a valid or invalid XPath expression string.\n   *\n   * @return A non-null reference to an XPath object that represents the string argument.\n   *\n   * @throws javax.xml.transform.TransformerException if the expression can not be processed.\n   * @see <a href=\"http://www.w3.org/TR/xslt#section-Expressions\">Section 4 Expressions in XSLT Specification</a>\n   ",
    "links" : [ ]
  }, {
    "name" : " XPath createMatchPatternXPath(String str, ElemTemplateElement owningTemplate) throws javax.xml.transform.TransformerException",
    "returnType" : "XPath",
    "comment" : "\n   * Process an expression string into an XPath.\n   *\n   * @param str A non-null reference to a valid or invalid match pattern string.\n   *\n   * @return A non-null reference to an XPath object that represents the string argument.\n   *\n   * @throws javax.xml.transform.TransformerException if the pattern can not be processed.\n   * @see <a href=\"http://www.w3.org/TR/xslt#patterns\">Section 5.2 Patterns in XSLT Specification</a>\n   ",
    "links" : [ ]
  }, {
    "name" : "public String getNamespaceForPrefix(String prefix)",
    "returnType" : "String",
    "comment" : "\n   * Given a namespace, get the corrisponding prefix from the current\n   * namespace support context.\n   *\n   * @param prefix The prefix to look up, which may be an empty string (\"\") for the default Namespace.\n   *\n   * @return The associated Namespace URI, or null if the prefix\n   *         is undeclared in this context.\n   ",
    "links" : [ ]
  }, {
    "name" : "public String getNamespaceForPrefix(String prefix, org.w3c.dom.Node context)",
    "returnType" : "String",
    "comment" : "\n   * Given a namespace, get the corrisponding prefix.  This is here only\n   * to support the {@link org.apache.xml.utils.PrefixResolver} interface,\n   * and will throw an error if invoked on this object.\n   *\n   * @param prefix The prefix to look up, which may be an empty string (\"\") for the default Namespace.\n   * @param context The node context from which to look up the URI.\n   *\n   * @return The associated Namespace URI, or null if the prefix\n   *         is undeclared in this context.\n   ",
    "links" : [ "org.apache.xml.utils.PrefixResolver" ]
  }, {
    "name" : "private boolean stackContains(Stack stack, String url)",
    "returnType" : "boolean",
    "comment" : "\n   * Utility function to see if the stack contains the given URL.\n   *\n   * @param stack non-null reference to a Stack.\n   * @param url URL string on which an equality test will be performed.\n   *\n   * @return true if the stack contains the url argument.\n   ",
    "links" : [ ]
  }, {
    "name" : "public Templates getTemplates()",
    "returnType" : "Templates",
    "comment" : "\n   * When this object is used as a ContentHandler or ContentHandler, it will\n   * create a Templates object, which the caller can get once\n   * the SAX events have been completed.\n   * @return The stylesheet object that was created during\n   * the SAX event process, or null if no stylesheet has\n   * been created.\n   * \n   * Author <a href=\"mailto:scott_boag@lotus.com\">Scott Boag</a>\n   *\n   *\n   ",
    "links" : [ ]
  }, {
    "name" : "public void setSystemId(String baseID)",
    "returnType" : "void",
    "comment" : "\n   * Set the base ID (URL or system ID) for the stylesheet\n   * created by this builder.  This must be set in order to\n   * resolve relative URLs in the stylesheet.\n   *\n   * @param baseID Base URL for this stylesheet.\n   ",
    "links" : [ ]
  }, {
    "name" : "public String getSystemId()",
    "returnType" : "String",
    "comment" : "\n   * Get the base ID (URI or system ID) from where relative\n   * URLs will be resolved.\n   *\n   * @return The systemID that was set with {@link #setSystemId}.\n   ",
    "links" : [ "#setSystemId" ]
  }, {
    "name" : "public InputSource resolveEntity(String publicId, String systemId) throws org.xml.sax.SAXException",
    "returnType" : "InputSource",
    "comment" : "\n   * Resolve an external entity.\n   *\n   * @param publicId The public identifer, or null if none is\n   *                 available.\n   * @param systemId The system identifier provided in the XML\n   *                 document.\n   * @return The new input source, or null to require the\n   *         default behaviour.\n   *\n   * @throws org.xml.sax.SAXException if the entity can not be resolved.\n   ",
    "links" : [ ]
  }, {
    "name" : "public void notationDecl(String name, String publicId, String systemId)",
    "returnType" : "void",
    "comment" : "\n   * Receive notification of a notation declaration.\n   *\n   * <p>By default, do nothing.  Application writers may override this\n   * method in a subclass if they wish to keep track of the notations\n   * declared in a document.</p>\n   *\n   * @param name The notation name.\n   * @param publicId The notation public identifier, or null if not\n   *                 available.\n   * @param systemId The notation system identifier.\n   * @see org.xml.sax.DTDHandler#notationDecl\n   ",
    "links" : [ ]
  }, {
    "name" : "public void unparsedEntityDecl(String name, String publicId, String systemId, String notationName)",
    "returnType" : "void",
    "comment" : "\n   * Receive notification of an unparsed entity declaration.\n   *\n   * @param name The entity name.\n   * @param publicId The entity public identifier, or null if not\n   *                 available.\n   * @param systemId The entity system identifier.\n   * @param notationName The name of the associated notation.\n   * @see org.xml.sax.DTDHandler#unparsedEntityDecl\n   ",
    "links" : [ ]
  }, {
    "name" : " XSLTElementProcessor getProcessorFor(String uri, String localName, String rawName) throws org.xml.sax.SAXException",
    "returnType" : "XSLTElementProcessor",
    "comment" : "\n   * Given a namespace URI, and a local name or a node type, get the processor\n   * for the element, or return null if not allowed.\n   *\n   * @param uri The Namespace URI, or an empty string.\n   * @param localName The local name (without prefix), or empty string if not namespace processing.\n   * @param rawName The qualified name (with prefix).\n   *\n   * @return A non-null reference to a element processor.\n   *\n   * @throws org.xml.sax.SAXException if the element is not allowed in the\n   * found position in the stylesheet.\n   ",
    "links" : [ ]
  }, {
    "name" : "public void setDocumentLocator(Locator locator)",
    "returnType" : "void",
    "comment" : "\n   * Receive a Locator object for document events.\n   * This is called by the parser to push a locator for the\n   * stylesheet being parsed. The stack needs to be popped\n   * after the stylesheet has been parsed. We pop in\n   * popStylesheet.\n   *\n   * @param locator A locator for all SAX document events.\n   * @see org.xml.sax.ContentHandler#setDocumentLocator\n   * @see org.xml.sax.Locator\n   ",
    "links" : [ ]
  }, {
    "name" : "public void startDocument() throws org.xml.sax.SAXException",
    "returnType" : "void",
    "comment" : "\n   * Receive notification of the beginning of the document.\n   *\n   * @see org.xml.sax.ContentHandler#startDocument\n   *\n   * @throws org.xml.sax.SAXException Any SAX exception, possibly\n   *            wrapping another exception.\n   ",
    "links" : [ ]
  }, {
    "name" : "public boolean isStylesheetParsingComplete()",
    "returnType" : "boolean",
    "comment" : "\n   * Test whether the _last_ endDocument() has been processed.\n   * This is needed as guidance for stylesheet optimization\n   * and compilation engines, which generally don't want to start\n   * until all included and imported stylesheets have been fully\n   * parsed.\n   *\n   * @return true iff the complete stylesheet tree has been built.\n   ",
    "links" : [ ]
  }, {
    "name" : "public void endDocument() throws org.xml.sax.SAXException",
    "returnType" : "void",
    "comment" : "\n   * Receive notification of the end of the document.\n   *\n   * @see org.xml.sax.ContentHandler#endDocument\n   *\n   * @throws org.xml.sax.SAXException Any SAX exception, possibly\n   *            wrapping another exception.\n   ",
    "links" : [ ]
  }, {
    "name" : "public void startPrefixMapping(String prefix, String uri) throws org.xml.sax.SAXException",
    "returnType" : "void",
    "comment" : "\n   * Receive notification of the start of a Namespace mapping.\n   *\n   * <p>By default, do nothing.  Application writers may override this\n   * method in a subclass to take specific actions at the start of\n   * each element (such as allocating a new tree node or writing\n   * output to a file).</p>\n   *\n   * @param prefix The Namespace prefix being declared.\n   * @param uri The Namespace URI mapped to the prefix.\n   * @see org.xml.sax.ContentHandler#startPrefixMapping\n   *\n   * @throws org.xml.sax.SAXException Any SAX exception, possibly\n   *            wrapping another exception.\n   ",
    "links" : [ ]
  }, {
    "name" : "public void endPrefixMapping(String prefix) throws org.xml.sax.SAXException",
    "returnType" : "void",
    "comment" : "\n   * Receive notification of the end of a Namespace mapping.\n   *\n   * <p>By default, do nothing.  Application writers may override this\n   * method in a subclass to take specific actions at the start of\n   * each element (such as allocating a new tree node or writing\n   * output to a file).</p>\n   *\n   * @param prefix The Namespace prefix being declared.\n   * @see org.xml.sax.ContentHandler#endPrefixMapping\n   *\n   * @throws org.xml.sax.SAXException Any SAX exception, possibly\n   *            wrapping another exception.\n   ",
    "links" : [ ]
  }, {
    "name" : "private void flushCharacters() throws org.xml.sax.SAXException",
    "returnType" : "void",
    "comment" : "\n   * Flush the characters buffer.\n   *\n   * @throws org.xml.sax.SAXException\n   ",
    "links" : [ ]
  }, {
    "name" : "public void startElement(String uri, String localName, String rawName, Attributes attributes) throws org.xml.sax.SAXException",
    "returnType" : "void",
    "comment" : "\n   * Receive notification of the start of an element.\n   *\n   * @param uri The Namespace URI, or an empty string.\n   * @param localName The local name (without prefix), or empty string if not namespace processing.\n   * @param rawName The qualified name (with prefix).\n   * @param attributes The specified or defaulted attributes.\n   *\n   * @throws org.xml.sax.SAXException\n   ",
    "links" : [ ]
  }, {
    "name" : "public void endElement(String uri, String localName, String rawName) throws org.xml.sax.SAXException",
    "returnType" : "void",
    "comment" : "\n   * Receive notification of the end of an element.\n   *\n   * @param uri The Namespace URI, or an empty string.\n   * @param localName The local name (without prefix), or empty string if not namespace processing.\n   * @param rawName The qualified name (with prefix).\n   * @see org.xml.sax.ContentHandler#endElement\n   *\n   * @throws org.xml.sax.SAXException Any SAX exception, possibly\n   *            wrapping another exception.\n   ",
    "links" : [ ]
  }, {
    "name" : "public void characters(char[] ch, int start, int length) throws org.xml.sax.SAXException",
    "returnType" : "void",
    "comment" : "\n   * Receive notification of character data inside an element.\n   *\n   * @param ch The characters.\n   * @param start The start position in the character array.\n   * @param length The number of characters to use from the\n   *               character array.\n   * @see org.xml.sax.ContentHandler#characters\n   *\n   * @throws org.xml.sax.SAXException Any SAX exception, possibly\n   *            wrapping another exception.\n   ",
    "links" : [ ]
  }, {
    "name" : "public void ignorableWhitespace(char[] ch, int start, int length) throws org.xml.sax.SAXException",
    "returnType" : "void",
    "comment" : "\n   * Receive notification of ignorable whitespace in element content.\n   *\n   * @param ch The whitespace characters.\n   * @param start The start position in the character array.\n   * @param length The number of characters to use from the\n   *               character array.\n   * @see org.xml.sax.ContentHandler#ignorableWhitespace\n   *\n   * @throws org.xml.sax.SAXException Any SAX exception, possibly\n   *            wrapping another exception.\n   ",
    "links" : [ ]
  }, {
    "name" : "public void processingInstruction(String target, String data) throws org.xml.sax.SAXException",
    "returnType" : "void",
    "comment" : "\n   * Receive notification of a processing instruction.\n   *\n   * <p>The Parser will invoke this method once for each processing\n   * instruction found: note that processing instructions may occur\n   * before or after the main document element.</p>\n   *\n   * <p>A SAX parser should never report an XML declaration (XML 1.0,\n   * section 2.8) or a text declaration (XML 1.0, section 4.3.1)\n   * using this method.</p>\n   *\n   * <p>By default, do nothing.  Application writers may override this\n   * method in a subclass to take specific actions for each\n   * processing instruction, such as setting status variables or\n   * invoking other methods.</p>\n   *\n   * @param target The processing instruction target.\n   * @param data The processing instruction data, or null if\n   *             none is supplied.\n   * @see org.xml.sax.ContentHandler#processingInstruction\n   *\n   * @throws org.xml.sax.SAXException Any SAX exception, possibly\n   *            wrapping another exception.\n   ",
    "links" : [ ]
  }, {
    "name" : "public void skippedEntity(String name) throws org.xml.sax.SAXException",
    "returnType" : "void",
    "comment" : "\n   * Receive notification of a skipped entity.\n   *\n   * <p>By default, do nothing.  Application writers may override this\n   * method in a subclass to take specific actions for each\n   * processing instruction, such as setting status variables or\n   * invoking other methods.</p>\n   *\n   * @param name The name of the skipped entity.\n   * @see org.xml.sax.ContentHandler#processingInstruction\n   *\n   * @throws org.xml.sax.SAXException Any SAX exception, possibly\n   *            wrapping another exception.\n   ",
    "links" : [ ]
  }, {
    "name" : "public void warn(String msg, Object[] args) throws org.xml.sax.SAXException",
    "returnType" : "void",
    "comment" : "\n   * Warn the user of an problem.\n   *\n   * @param msg An key into the {@link org.apache.xalan.res.XSLTErrorResources}\n   * table, that is one of the WG_ prefixed definitions.\n   * @param args An array of arguments for the given warning.\n   *\n   * @throws org.xml.sax.SAXException that wraps a\n   * {@link javax.xml.transform.TransformerException} if the current\n   * {@link javax.xml.transform.ErrorListener#warning}\n   * method chooses to flag this condition as an error.\n   * @xsl.usage internal\n   ",
    "links" : [ "javax.xml.transform.TransformerException", "org.apache.xalan.res.XSLTErrorResources", "javax.xml.transform.ErrorListener#warning" ]
  }, {
    "name" : "private void assertion(boolean condition, String msg) throws RuntimeException",
    "returnType" : "void",
    "comment" : "\n   * Assert that a condition is true.  If it is not true, throw an error.\n   *\n   * @param condition false if an error should not be thrown, otherwise true.\n   * @param msg Error message to be passed to the RuntimeException as an\n   * argument.\n   * @throws RuntimeException if the condition is not true.\n   * @xsl.usage internal\n   ",
    "links" : [ ]
  }, {
    "name" : "protected void error(String msg, Exception e) throws org.xml.sax.SAXException",
    "returnType" : "void",
    "comment" : "\n   * Tell the user of an error, and probably throw an\n   * exception.\n   *\n   * @param msg An error message.\n   * @param e An error which the SAXException should wrap.\n   *\n   * @throws org.xml.sax.SAXException that wraps a\n   * {@link javax.xml.transform.TransformerException} if the current\n   * {@link javax.xml.transform.ErrorListener#error}\n   * method chooses to flag this condition as an error.\n   * @xsl.usage internal\n   ",
    "links" : [ "javax.xml.transform.TransformerException", "javax.xml.transform.ErrorListener#error" ]
  }, {
    "name" : "protected void error(String msg, Object[] args, Exception e) throws org.xml.sax.SAXException",
    "returnType" : "void",
    "comment" : "\n   * Tell the user of an error, and probably throw an\n   * exception.\n   *\n   * @param msg A key into the {@link org.apache.xalan.res.XSLTErrorResources}\n   * table, that is one of the WG_ prefixed definitions.\n   * @param args An array of arguments for the given warning.\n   * @param e An error which the SAXException should wrap.\n   *\n   * @throws org.xml.sax.SAXException that wraps a\n   * {@link javax.xml.transform.TransformerException} if the current\n   * {@link javax.xml.transform.ErrorListener#error}\n   * method chooses to flag this condition as an error.\n   * @xsl.usage internal\n   ",
    "links" : [ "javax.xml.transform.TransformerException", "org.apache.xalan.res.XSLTErrorResources", "javax.xml.transform.ErrorListener#error" ]
  }, {
    "name" : "public void warning(org.xml.sax.SAXParseException e) throws org.xml.sax.SAXException",
    "returnType" : "void",
    "comment" : "\n   * Receive notification of a XSLT processing warning.\n   *\n   * @param e The warning information encoded as an exception.\n   *\n   * @throws org.xml.sax.SAXException that wraps a\n   * {@link javax.xml.transform.TransformerException} if the current\n   * {@link javax.xml.transform.ErrorListener#warning}\n   * method chooses to flag this condition as an error.\n   ",
    "links" : [ "javax.xml.transform.TransformerException", "javax.xml.transform.ErrorListener#warning" ]
  }, {
    "name" : "public void error(org.xml.sax.SAXParseException e) throws org.xml.sax.SAXException",
    "returnType" : "void",
    "comment" : "\n   * Receive notification of a recoverable XSLT processing error.\n   *\n   * @param e The error information encoded as an exception.\n   *\n   * @throws org.xml.sax.SAXException that wraps a\n   * {@link javax.xml.transform.TransformerException} if the current\n   * {@link javax.xml.transform.ErrorListener#error}\n   * method chooses to flag this condition as an error.\n   ",
    "links" : [ "javax.xml.transform.TransformerException", "javax.xml.transform.ErrorListener#error" ]
  }, {
    "name" : "public void fatalError(org.xml.sax.SAXParseException e) throws org.xml.sax.SAXException",
    "returnType" : "void",
    "comment" : "\n   * Report a fatal XSLT processing error.\n   *\n   * @param e The error information encoded as an exception.\n   *\n   * @throws org.xml.sax.SAXException that wraps a\n   * {@link javax.xml.transform.TransformerException} if the current\n   * {@link javax.xml.transform.ErrorListener#fatalError}\n   * method chooses to flag this condition as an error.\n   ",
    "links" : [ "javax.xml.transform.TransformerException", "javax.xml.transform.ErrorListener#fatalError" ]
  }, {
    "name" : "private void checkForFragmentID(Attributes attributes)",
    "returnType" : "void",
    "comment" : "\n   * Check to see if an ID attribute matched the #id, called\n   * from startElement.\n   *\n   * @param attributes The specified or defaulted attributes.\n   ",
    "links" : [ ]
  }, {
    "name" : "public TransformerFactoryImpl getStylesheetProcessor()",
    "returnType" : "TransformerFactoryImpl",
    "comment" : "\n   * Get the XSLT TransformerFactoryImpl for needed services.\n   * TODO: This method should be renamed.\n   *\n   * @return The TransformerFactoryImpl that owns this handler.\n   ",
    "links" : [ ]
  }, {
    "name" : " int getStylesheetType()",
    "returnType" : "int",
    "comment" : "\n   * Get the type of stylesheet that should be built\n   * or is being processed.\n   *\n   * @return one of STYPE_ROOT, STYPE_INCLUDE, or STYPE_IMPORT.\n   ",
    "links" : [ ]
  }, {
    "name" : " void setStylesheetType(int type)",
    "returnType" : "void",
    "comment" : "\n   * Set the type of stylesheet that should be built\n   * or is being processed.\n   *\n   * @param type Must be one of STYPE_ROOT, STYPE_INCLUDE, or STYPE_IMPORT.\n   ",
    "links" : [ ]
  }, {
    "name" : " Stylesheet getStylesheet()",
    "returnType" : "Stylesheet",
    "comment" : "\n   * Return the stylesheet that this handler is constructing.\n   *\n   * @return The current stylesheet that is on top of the stylesheets stack,\n   *  or null if no stylesheet is on the stylesheets stack.\n   ",
    "links" : [ ]
  }, {
    "name" : " Stylesheet getLastPoppedStylesheet()",
    "returnType" : "Stylesheet",
    "comment" : "\n   * Return the last stylesheet that was popped off the stylesheets stack.\n   *\n   * @return The last popped stylesheet, or null.\n   ",
    "links" : [ ]
  }, {
    "name" : "public StylesheetRoot getStylesheetRoot()",
    "returnType" : "StylesheetRoot",
    "comment" : "\n   * Return the stylesheet root that this handler is constructing.\n   *\n   * @return The root stylesheet of the stylesheets tree.\n   ",
    "links" : [ ]
  }, {
    "name" : "public void pushStylesheet(Stylesheet s)",
    "returnType" : "void",
    "comment" : "\n   * Push the current stylesheet being constructed. If no other stylesheets\n   * have been pushed onto the stack, assume the argument is a stylesheet\n   * root, and also set the stylesheet root member.\n   *\n   * @param s non-null reference to a stylesheet.\n   ",
    "links" : [ ]
  }, {
    "name" : " Stylesheet popStylesheet()",
    "returnType" : "Stylesheet",
    "comment" : "\n   * Pop the last stylesheet pushed, and return the stylesheet that this\n   * handler is constructing, and set the last popped stylesheet member.\n   * Also pop the stylesheet locator stack.\n   *\n   * @return The stylesheet popped off the stack, or the last popped stylesheet.\n   ",
    "links" : [ ]
  }, {
    "name" : " XSLTElementProcessor getCurrentProcessor()",
    "returnType" : "XSLTElementProcessor",
    "comment" : "\n   * Get the current XSLTElementProcessor at the top of the stack.\n   *\n   * @return Valid XSLTElementProcessor, which should never be null.\n   ",
    "links" : [ ]
  }, {
    "name" : " void pushProcessor(XSLTElementProcessor processor)",
    "returnType" : "void",
    "comment" : "\n   * Push the current XSLTElementProcessor onto the top of the stack.\n   *\n   * @param processor non-null reference to the current element processor.\n   ",
    "links" : [ ]
  }, {
    "name" : " XSLTElementProcessor popProcessor()",
    "returnType" : "XSLTElementProcessor",
    "comment" : "\n   * Pop the current XSLTElementProcessor from the top of the stack.\n   * @return the XSLTElementProcessor which was popped.\n   ",
    "links" : [ ]
  }, {
    "name" : "public XSLTSchema getSchema()",
    "returnType" : "XSLTSchema",
    "comment" : "\n   * Get the root of the XSLT Schema, which tells us how to\n   * transition content handlers, create elements, etc.\n   *\n   * @return The root XSLT Schema, which should never be null.\n   * @xsl.usage internal\n   ",
    "links" : [ ]
  }, {
    "name" : " ElemTemplateElement getElemTemplateElement()",
    "returnType" : "ElemTemplateElement",
    "comment" : "\n   * Get the current ElemTemplateElement at the top of the stack.\n   * @return Valid ElemTemplateElement, which may be null.\n   ",
    "links" : [ ]
  }, {
    "name" : " int nextUid()",
    "returnType" : "int",
    "comment" : "\n   * Returns the next m_docOrderCount number and increments the number for future use.\n   ",
    "links" : [ ]
  }, {
    "name" : " void pushElemTemplateElement(ElemTemplateElement elem)",
    "returnType" : "void",
    "comment" : "\n   * Push the current XSLTElementProcessor to the top of the stack.  As a\n   * side-effect, set the document order index (simply because this is a\n   * convenient place to set it).\n   *\n   * @param elem Should be a non-null reference to the intended current\n   * template element.\n   ",
    "links" : [ ]
  }, {
    "name" : " ElemTemplateElement popElemTemplateElement()",
    "returnType" : "ElemTemplateElement",
    "comment" : "\n   * Get the current XSLTElementProcessor from the top of the stack.\n   * @return the ElemTemplateElement which was popped.\n   ",
    "links" : [ ]
  }, {
    "name" : " void pushBaseIndentifier(String baseID)",
    "returnType" : "void",
    "comment" : "\n   * Push a base identifier onto the base URI stack.\n   *\n   * @param baseID The current base identifier for this position in the\n   * stylesheet, which may be a fragment identifier, or which may be null.\n   * @see <a href=\"http://www.w3.org/TR/xslt#base-uri\">\n   * Section 3.2 Base URI of XSLT specification.</a>\n   ",
    "links" : [ ]
  }, {
    "name" : " String popBaseIndentifier()",
    "returnType" : "String",
    "comment" : "\n   * Pop a base URI from the stack.\n   * @return baseIdentifier.\n   ",
    "links" : [ ]
  }, {
    "name" : "public String getBaseIdentifier()",
    "returnType" : "String",
    "comment" : "\n   * Return the base identifier.\n   *\n   * @return The base identifier of the current stylesheet.\n   ",
    "links" : [ ]
  }, {
    "name" : "public SAXSourceLocator getLocator()",
    "returnType" : "SAXSourceLocator",
    "comment" : "\n   * Get the current stylesheet Locator object.\n   *\n   * @return non-null reference to the current locator object.\n   ",
    "links" : [ ]
  }, {
    "name" : " void pushImportURL(String hrefUrl)",
    "returnType" : "void",
    "comment" : "\n   * Push an import href onto the stylesheet stack.\n   *\n   * @param hrefUrl non-null reference to the URL for the current imported\n   * stylesheet.\n   ",
    "links" : [ ]
  }, {
    "name" : " void pushImportSource(Source sourceFromURIResolver)",
    "returnType" : "void",
    "comment" : "\n   * Push the Source of an import href onto the stylesheet stack,\n   * obtained from a URIResolver, null if there is no URIResolver,\n   * or if that resolver returned null.\n   ",
    "links" : [ ]
  }, {
    "name" : " boolean importStackContains(String hrefUrl)",
    "returnType" : "boolean",
    "comment" : "\n   * See if the imported stylesheet stack already contains\n   * the given URL.  Used to test for recursive imports.\n   *\n   * @param hrefUrl non-null reference to a URL string.\n   *\n   * @return true if the URL is on the import stack.\n   ",
    "links" : [ ]
  }, {
    "name" : " String popImportURL()",
    "returnType" : "String",
    "comment" : "\n   * Pop an import href from the stylesheet stack.\n   *\n   * @return non-null reference to the import URL that was popped.\n   ",
    "links" : [ ]
  }, {
    "name" : " String peekImportURL()",
    "returnType" : "String",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : " Source peekSourceFromURIResolver()",
    "returnType" : "Source",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : " Source popImportSource()",
    "returnType" : "Source",
    "comment" : "\n   * Pop a Source from a user provided URIResolver, corresponding\n   * to the URL popped from the m_importStack.\n   ",
    "links" : [ ]
  }, {
    "name" : " void pushNewNamespaceSupport()",
    "returnType" : "void",
    "comment" : "\n   * Push a new NamespaceSupport instance.\n   ",
    "links" : [ ]
  }, {
    "name" : " void popNamespaceSupport()",
    "returnType" : "void",
    "comment" : "\n   * Pop the current NamespaceSupport object.\n   *\n   ",
    "links" : [ ]
  }, {
    "name" : " NamespaceSupport getNamespaceSupport()",
    "returnType" : "NamespaceSupport",
    "comment" : "\n   * Get the current NamespaceSupport object.\n   *\n   * @return a non-null reference to the current NamespaceSupport object,\n   * which is the top of the namespace support stack.\n   ",
    "links" : [ ]
  }, {
    "name" : "public void setOriginatingNode(Node n)",
    "returnType" : "void",
    "comment" : "\n   * Set the node that is originating the SAX event.\n   *\n   * @param n Reference to node that originated the current event.\n   * @see org.apache.xml.utils.NodeConsumer\n   ",
    "links" : [ ]
  }, {
    "name" : "public Node getOriginatingNode()",
    "returnType" : "Node",
    "comment" : "\n   * Set the node that is originating the SAX event.\n   *\n   * @return Reference to node that originated the current event.\n   * @see org.apache.xml.utils.NodeConsumer\n   ",
    "links" : [ ]
  }, {
    "name" : " boolean isSpacePreserve()",
    "returnType" : "boolean",
    "comment" : "\n   * Return boolean value from the spacePreserve stack depending on the value \n   * of xml:space=default/preserve.\n   * \n   * @return true if space should be preserved, false otherwise.\n   ",
    "links" : [ ]
  }, {
    "name" : " void popSpaceHandling()",
    "returnType" : "void",
    "comment" : "\n   * Pop boolean value from the spacePreserve stack.\n   ",
    "links" : [ ]
  }, {
    "name" : " void pushSpaceHandling(boolean b) throws org.xml.sax.SAXParseException",
    "returnType" : "void",
    "comment" : "\n   * Push boolean value on to the spacePreserve stack.\n   * \n   * @param b true if space should be preserved, false otherwise.\n   ",
    "links" : [ ]
  }, {
    "name" : " void pushSpaceHandling(Attributes attrs) throws org.xml.sax.SAXParseException",
    "returnType" : "void",
    "comment" : "\n   * Push boolean value on to the spacePreserve stack depending on the value \n   * of xml:space=default/preserve.\n   * \n   * @param attrs list of attributes that were passed to startElement.\n   ",
    "links" : [ ]
  }, {
    "name" : "private double getElemVersion()",
    "returnType" : "double",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public boolean handlesNullPrefixes()",
    "returnType" : "boolean",
    "comment" : "\n     * @see PrefixResolver#handlesNullPrefixes()\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean getOptimize()",
    "returnType" : "boolean",
    "comment" : "\n     * @return Optimization flag\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean getIncremental()",
    "returnType" : "boolean",
    "comment" : "\n     * @return Incremental flag\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean getSource_location()",
    "returnType" : "boolean",
    "comment" : "\n     * @return Source Location flag\n     ",
    "links" : [ ]
  } ],
  "methodNames" : [ " void init(TransformerFactoryImpl processor)", "public XPath createXPath(String str, ElemTemplateElement owningTemplate) throws javax.xml.transform.TransformerException", " XPath createMatchPatternXPath(String str, ElemTemplateElement owningTemplate) throws javax.xml.transform.TransformerException", "public String getNamespaceForPrefix(String prefix)", "public String getNamespaceForPrefix(String prefix, org.w3c.dom.Node context)", "private boolean stackContains(Stack stack, String url)", "public Templates getTemplates()", "public void setSystemId(String baseID)", "public String getSystemId()", "public InputSource resolveEntity(String publicId, String systemId) throws org.xml.sax.SAXException", "public void notationDecl(String name, String publicId, String systemId)", "public void unparsedEntityDecl(String name, String publicId, String systemId, String notationName)", " XSLTElementProcessor getProcessorFor(String uri, String localName, String rawName) throws org.xml.sax.SAXException", "public void setDocumentLocator(Locator locator)", "public void startDocument() throws org.xml.sax.SAXException", "public boolean isStylesheetParsingComplete()", "public void endDocument() throws org.xml.sax.SAXException", "public void startPrefixMapping(String prefix, String uri) throws org.xml.sax.SAXException", "public void endPrefixMapping(String prefix) throws org.xml.sax.SAXException", "private void flushCharacters() throws org.xml.sax.SAXException", "public void startElement(String uri, String localName, String rawName, Attributes attributes) throws org.xml.sax.SAXException", "public void endElement(String uri, String localName, String rawName) throws org.xml.sax.SAXException", "public void characters(char[] ch, int start, int length) throws org.xml.sax.SAXException", "public void ignorableWhitespace(char[] ch, int start, int length) throws org.xml.sax.SAXException", "public void processingInstruction(String target, String data) throws org.xml.sax.SAXException", "public void skippedEntity(String name) throws org.xml.sax.SAXException", "public void warn(String msg, Object[] args) throws org.xml.sax.SAXException", "private void assertion(boolean condition, String msg) throws RuntimeException", "protected void error(String msg, Exception e) throws org.xml.sax.SAXException", "protected void error(String msg, Object[] args, Exception e) throws org.xml.sax.SAXException", "public void warning(org.xml.sax.SAXParseException e) throws org.xml.sax.SAXException", "public void error(org.xml.sax.SAXParseException e) throws org.xml.sax.SAXException", "public void fatalError(org.xml.sax.SAXParseException e) throws org.xml.sax.SAXException", "private void checkForFragmentID(Attributes attributes)", "public TransformerFactoryImpl getStylesheetProcessor()", " int getStylesheetType()", " void setStylesheetType(int type)", " Stylesheet getStylesheet()", " Stylesheet getLastPoppedStylesheet()", "public StylesheetRoot getStylesheetRoot()", "public void pushStylesheet(Stylesheet s)", " Stylesheet popStylesheet()", " XSLTElementProcessor getCurrentProcessor()", " void pushProcessor(XSLTElementProcessor processor)", " XSLTElementProcessor popProcessor()", "public XSLTSchema getSchema()", " ElemTemplateElement getElemTemplateElement()", " int nextUid()", " void pushElemTemplateElement(ElemTemplateElement elem)", " ElemTemplateElement popElemTemplateElement()", " void pushBaseIndentifier(String baseID)", " String popBaseIndentifier()", "public String getBaseIdentifier()", "public SAXSourceLocator getLocator()", " void pushImportURL(String hrefUrl)", " void pushImportSource(Source sourceFromURIResolver)", " boolean importStackContains(String hrefUrl)", " String popImportURL()", " String peekImportURL()", " Source peekSourceFromURIResolver()", " Source popImportSource()", " void pushNewNamespaceSupport()", " void popNamespaceSupport()", " NamespaceSupport getNamespaceSupport()", "public void setOriginatingNode(Node n)", "public Node getOriginatingNode()", " boolean isSpacePreserve()", " void popSpaceHandling()", " void pushSpaceHandling(boolean b) throws org.xml.sax.SAXParseException", " void pushSpaceHandling(Attributes attrs) throws org.xml.sax.SAXParseException", "private double getElemVersion()", "public boolean handlesNullPrefixes()", "public boolean getOptimize()", "public boolean getIncremental()", "public boolean getSource_location()" ],
  "variableNames" : [ "m_funcTable", "m_optimize", "m_incremental", "m_source_location", "m_stylesheetLevel", "m_parsingComplete", "m_prefixMappings", "m_shouldProcess", "m_fragmentIDString", "m_elementID", "m_fragmentID", "m_stylesheetProcessor", "STYPE_ROOT", "STYPE_INCLUDE", "STYPE_IMPORT", "m_stylesheetType", "m_stylesheets", "m_stylesheetRoot", "m_lastPoppedStylesheet", "m_processors", "m_schema", "m_elems", "m_docOrderCount", "m_baseIdentifiers", "m_stylesheetLocatorStack", "m_importStack", "m_importSourceStack", "warnedAboutOldXSLTNamespace", "m_nsSupportStack", "m_originatingNode", "m_spacePreserveStack" ]
}