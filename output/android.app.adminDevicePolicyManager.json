{
  "filePath" : "/home/maryam/clearblue/files/android-source-30/android/app/admin/DevicePolicyManager.java",
  "packageName" : "android.app.admin",
  "className" : "DevicePolicyManager",
  "comment" : "\n * Public interface for managing policies enforced on a device. Most clients of this class must be\n * registered with the system as a <a href=\"{@docRoot}guide/topics/admin/device-admin.html\">device\n * administrator</a>. Additionally, a device administrator may be registered as either a profile or\n * device owner. A given method is accessible to all device administrators unless the documentation\n * for that method specifies that it is restricted to either device or profile owners. Any\n * application calling an api may only pass as an argument a device administrator component it\n * owns. Otherwise, a {@link SecurityException} will be thrown.\n * <div class=\"special reference\">\n * <h3>Developer Guides</h3>\n * <p>\n * For more information about managing policies for device administration, read the <a href=\n * \"{@docRoot}guide/topics/admin/device-admin.html\">Device Administration</a> developer\n * guide. </div>\n ",
  "variables" : [ {
    "name" : "TAG",
    "type" : "String",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mContext",
    "type" : "Context",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mService",
    "type" : "IDevicePolicyManager",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mParentInstance",
    "type" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "ACTION_PROVISION_MANAGED_PROFILE",
    "type" : "String",
    "comment" : "\n     * Activity action: Starts the provisioning flow which sets up a managed profile.\n     *\n     * <p>A managed profile allows data separation for example for the usage of a\n     * device as a personal and corporate device. The user which provisioning is started from and\n     * the managed profile share a launcher.\n     *\n     * <p>This intent will typically be sent by a mobile device management application (MDM).\n     * Provisioning adds a managed profile and sets the MDM as the profile owner who has full\n     * control over the profile.\n     *\n     * <p>It is possible to check if provisioning is allowed or not by querying the method\n     * {@link #isProvisioningAllowed(String)}.\n     *\n     * <p>In version {@link android.os.Build.VERSION_CODES#LOLLIPOP}, this intent must contain the\n     * extra {@link #EXTRA_PROVISIONING_DEVICE_ADMIN_PACKAGE_NAME}.\n     * As of {@link android.os.Build.VERSION_CODES#M}, it should contain the extra\n     * {@link #EXTRA_PROVISIONING_DEVICE_ADMIN_COMPONENT_NAME} instead, although specifying only\n     * {@link #EXTRA_PROVISIONING_DEVICE_ADMIN_PACKAGE_NAME} is still supported.\n     *\n     * <p>The intent may also contain the following extras:\n     * <ul>\n     * <li>{@link #EXTRA_PROVISIONING_ACCOUNT_TO_MIGRATE}, optional </li>\n     * <li>{@link #EXTRA_PROVISIONING_SKIP_ENCRYPTION}, optional, supported from\n     * {@link android.os.Build.VERSION_CODES#N}</li>\n     * <li>{@link #EXTRA_PROVISIONING_ADMIN_EXTRAS_BUNDLE}, optional</li>\n     * <li>{@link #EXTRA_PROVISIONING_LOGO_URI}, optional</li>\n     * <li>{@link #EXTRA_PROVISIONING_MAIN_COLOR}, optional</li>\n     * <li>{@link #EXTRA_PROVISIONING_SKIP_USER_CONSENT}, optional</li>\n     * <li>{@link #EXTRA_PROVISIONING_KEEP_ACCOUNT_ON_MIGRATION}, optional</li>\n     * <li>{@link #EXTRA_PROVISIONING_DISCLAIMERS}, optional</li>\n     * </ul>\n     *\n     * <p>When managed provisioning has completed, broadcasts are sent to the application specified\n     * in the provisioning intent. The\n     * {@link DeviceAdminReceiver#ACTION_PROFILE_PROVISIONING_COMPLETE} broadcast is sent in the\n     * managed profile and the {@link #ACTION_MANAGED_PROFILE_PROVISIONED} broadcast is sent in\n     * the primary profile.\n     *\n     * <p>From version {@link android.os.Build.VERSION_CODES#O}, when managed provisioning has\n     * completed, along with the above broadcast, activity intent\n     * {@link #ACTION_PROVISIONING_SUCCESSFUL} will also be sent to the profile owner.\n     *\n     * <p>If provisioning fails, the managedProfile is removed so the device returns to its\n     * previous state.\n     *\n     * <p>If launched with {@link android.app.Activity#startActivityForResult(Intent, int)} a\n     * result code of {@link android.app.Activity#RESULT_OK} implies that the synchronous part of\n     * the provisioning flow was successful, although this doesn't guarantee the full flow will\n     * succeed. Conversely a result code of {@link android.app.Activity#RESULT_CANCELED} implies\n     * that the user backed-out of provisioning, or some precondition for provisioning wasn't met.\n     ",
    "links" : [ "#isProvisioningAllowed", "android.os.Build.VERSION_CODES#LOLLIPOP", "#EXTRA_PROVISIONING_DEVICE_ADMIN_PACKAGE_NAME", "android.os.Build.VERSION_CODES#M", "#EXTRA_PROVISIONING_DEVICE_ADMIN_COMPONENT_NAME", "#EXTRA_PROVISIONING_DEVICE_ADMIN_PACKAGE_NAME", "#EXTRA_PROVISIONING_ACCOUNT_TO_MIGRATE", "#EXTRA_PROVISIONING_SKIP_ENCRYPTION", "android.os.Build.VERSION_CODES#N", "#EXTRA_PROVISIONING_ADMIN_EXTRAS_BUNDLE", "#EXTRA_PROVISIONING_LOGO_URI", "#EXTRA_PROVISIONING_MAIN_COLOR", "#EXTRA_PROVISIONING_SKIP_USER_CONSENT", "#EXTRA_PROVISIONING_KEEP_ACCOUNT_ON_MIGRATION", "#EXTRA_PROVISIONING_DISCLAIMERS", "DeviceAdminReceiver#ACTION_PROFILE_PROVISIONING_COMPLETE", "#ACTION_MANAGED_PROFILE_PROVISIONED", "android.os.Build.VERSION_CODES#O", "#ACTION_PROVISIONING_SUCCESSFUL", "android.app.Activity#startActivityForResult", "android.app.Activity#RESULT_OK", "android.app.Activity#RESULT_CANCELED" ]
  }, {
    "name" : "ACTION_PROVISION_MANAGED_USER",
    "type" : "String",
    "comment" : "\n     * Activity action: Starts the provisioning flow which sets up a managed user.\n     *\n     * <p>This intent will typically be sent by a mobile device management application (MDM).\n     * Provisioning configures the user as managed user and sets the MDM as the profile\n     * owner who has full control over the user. Provisioning can only happen before user setup has\n     * been completed. Use {@link #isProvisioningAllowed(String)} to check if provisioning is\n     * allowed.\n     *\n     * <p>The intent contains the following extras:\n     * <ul>\n     * <li>{@link #EXTRA_PROVISIONING_DEVICE_ADMIN_COMPONENT_NAME}</li>\n     * <li>{@link #EXTRA_PROVISIONING_SKIP_ENCRYPTION}, optional</li>\n     * <li>{@link #EXTRA_PROVISIONING_ADMIN_EXTRAS_BUNDLE}, optional</li>\n     * <li>{@link #EXTRA_PROVISIONING_LOGO_URI}, optional</li>\n     * <li>{@link #EXTRA_PROVISIONING_MAIN_COLOR}, optional</li>\n     * </ul>\n     *\n     * <p>If provisioning fails, the device returns to its previous state.\n     *\n     * <p>If launched with {@link android.app.Activity#startActivityForResult(Intent, int)} a\n     * result code of {@link android.app.Activity#RESULT_OK} implies that the synchronous part of\n     * the provisioning flow was successful, although this doesn't guarantee the full flow will\n     * succeed. Conversely a result code of {@link android.app.Activity#RESULT_CANCELED} implies\n     * that the user backed-out of provisioning, or some precondition for provisioning wasn't met.\n     *\n     * @hide\n     ",
    "links" : [ "#isProvisioningAllowed", "#EXTRA_PROVISIONING_DEVICE_ADMIN_COMPONENT_NAME", "#EXTRA_PROVISIONING_SKIP_ENCRYPTION", "#EXTRA_PROVISIONING_ADMIN_EXTRAS_BUNDLE", "#EXTRA_PROVISIONING_LOGO_URI", "#EXTRA_PROVISIONING_MAIN_COLOR", "android.app.Activity#startActivityForResult", "android.app.Activity#RESULT_OK", "android.app.Activity#RESULT_CANCELED" ]
  }, {
    "name" : "ACTION_PROVISION_MANAGED_DEVICE",
    "type" : "String",
    "comment" : "\n     * Activity action: Starts the provisioning flow which sets up a managed device.\n     * Must be started with {@link android.app.Activity#startActivityForResult(Intent, int)}.\n     *\n     * <p> During device owner provisioning a device admin app is set as the owner of the device.\n     * A device owner has full control over the device. The device owner can not be modified by the\n     * user.\n     *\n     * <p> A typical use case would be a device that is owned by a company, but used by either an\n     * employee or client.\n     *\n     * <p> An intent with this action can be sent only on an unprovisioned device.\n     * It is possible to check if provisioning is allowed or not by querying the method\n     * {@link #isProvisioningAllowed(String)}.\n     *\n     * <p>The intent contains the following extras:\n     * <ul>\n     * <li>{@link #EXTRA_PROVISIONING_DEVICE_ADMIN_COMPONENT_NAME}</li>\n     * <li>{@link #EXTRA_PROVISIONING_SKIP_ENCRYPTION}, optional</li>\n     * <li>{@link #EXTRA_PROVISIONING_LEAVE_ALL_SYSTEM_APPS_ENABLED}, optional</li>\n     * <li>{@link #EXTRA_PROVISIONING_ADMIN_EXTRAS_BUNDLE}, optional</li>\n     * <li>{@link #EXTRA_PROVISIONING_LOGO_URI}, optional</li>\n     * <li>{@link #EXTRA_PROVISIONING_MAIN_COLOR}, optional</li>\n     * <li>{@link #EXTRA_PROVISIONING_DISCLAIMERS}, optional</li>\n     * <li>{@link #EXTRA_PROVISIONING_SKIP_EDUCATION_SCREENS}, optional</li>\n     * </ul>\n     *\n     * <p>When device owner provisioning has completed, an intent of the type\n     * {@link DeviceAdminReceiver#ACTION_PROFILE_PROVISIONING_COMPLETE} is broadcast to the\n     * device owner.\n     *\n     * <p>From version {@link android.os.Build.VERSION_CODES#O}, when device owner provisioning has\n     * completed, along with the above broadcast, activity intent\n     * {@link #ACTION_PROVISIONING_SUCCESSFUL} will also be sent to the device owner.\n     *\n     * <p>If provisioning fails, the device is factory reset.\n     *\n     * <p>A result code of {@link android.app.Activity#RESULT_OK} implies that the synchronous part\n     * of the provisioning flow was successful, although this doesn't guarantee the full flow will\n     * succeed. Conversely a result code of {@link android.app.Activity#RESULT_CANCELED} implies\n     * that the user backed-out of provisioning, or some precondition for provisioning wasn't met.\n     ",
    "links" : [ "android.app.Activity#startActivityForResult", "#isProvisioningAllowed", "#EXTRA_PROVISIONING_DEVICE_ADMIN_COMPONENT_NAME", "#EXTRA_PROVISIONING_SKIP_ENCRYPTION", "#EXTRA_PROVISIONING_LEAVE_ALL_SYSTEM_APPS_ENABLED", "#EXTRA_PROVISIONING_ADMIN_EXTRAS_BUNDLE", "#EXTRA_PROVISIONING_LOGO_URI", "#EXTRA_PROVISIONING_MAIN_COLOR", "#EXTRA_PROVISIONING_DISCLAIMERS", "#EXTRA_PROVISIONING_SKIP_EDUCATION_SCREENS", "DeviceAdminReceiver#ACTION_PROFILE_PROVISIONING_COMPLETE", "android.os.Build.VERSION_CODES#O", "#ACTION_PROVISIONING_SUCCESSFUL", "android.app.Activity#RESULT_OK", "android.app.Activity#RESULT_CANCELED" ]
  }, {
    "name" : "ACTION_STATE_USER_SETUP_COMPLETE",
    "type" : "String",
    "comment" : "\n     * Activity action: launch when user provisioning completed, i.e.\n     * {@link #getUserProvisioningState()} returns one of the complete state.\n     *\n     * <p> Please note that the API behavior is not necessarily consistent across various releases,\n     * and devices, as it's contract between SetupWizard and ManagedProvisioning. The default\n     * implementation is that ManagedProvisioning launches SetupWizard in NFC provisioning only.\n     *\n     * <p> The activity must be protected by permission\n     * {@link android.Manifest.permission#BIND_DEVICE_ADMIN}, and the process must hold\n     * {@link android.Manifest.permission#DISPATCH_PROVISIONING_MESSAGE} to be launched.\n     * Only one {@link ComponentName} in the entire system should be enabled, and the rest of the\n     * components are not started by this intent.\n     * @hide\n     ",
    "links" : [ "#getUserProvisioningState", "android.Manifest.permission#BIND_DEVICE_ADMIN", "android.Manifest.permission#DISPATCH_PROVISIONING_MESSAGE", "ComponentName" ]
  }, {
    "name" : "ACTION_PROVISION_MANAGED_DEVICE_FROM_TRUSTED_SOURCE",
    "type" : "String",
    "comment" : "\n     * Activity action: Starts the provisioning flow which sets up a managed device.\n     *\n     * <p>During device owner provisioning, a device admin app is downloaded and set as the owner of\n     * the device. A device owner has full control over the device. The device owner can not be\n     * modified by the user and the only way of resetting the device is via factory reset.\n     *\n     * <p>From version {@link android.os.Build.VERSION_CODES#Q}, the admin app can choose\n     * whether to set up a fully managed device or a managed profile. For the admin app to support\n     * this, it must have an activity with intent filter {@link #ACTION_GET_PROVISIONING_MODE} and\n     * another one with intent filter {@link #ACTION_ADMIN_POLICY_COMPLIANCE}. For example:\n     * <pre>\n     * &lt;activity\n     *     android:name=\".GetProvisioningModeActivity\"\n     *     android:label=\"@string/app_name\"\n     *     android:permission=\"android.permission.BIND_DEVICE_ADMIN\"&gt;\n     *     &lt;intent-filter&gt;\n     *         &lt;action\n     *             android:name=\"android.app.action.GET_PROVISIONING_MODE\" /&gt;\n     *         &lt;category android:name=\"android.intent.category.DEFAULT\" /&gt;\n     *     &lt;/intent-filter&gt;\n     * &lt;/activity&gt;\n     *\n     * &lt;activity\n     *     android:name=\".PolicyComplianceActivity\"\n     *     android:label=\"@string/app_name\"\n     *     android:permission=\"android.permission.BIND_DEVICE_ADMIN\"&gt;\n     *     &lt;intent-filter&gt;\n     *         &lt;action\n     *             android:name=\"android.app.action.ADMIN_POLICY_COMPLIANCE\" /&gt;\n     *         &lt;category android:name=\"android.intent.category.DEFAULT\" /&gt;\n     *     &lt;/intent-filter&gt;\n     * &lt;/activity&gt;</pre>\n     *\n     * <p>A typical use case would be a device that is owned by a company, but used by either an\n     * employee or client.\n     *\n     * <p>The provisioning message should be sent to an unprovisioned device.\n     *\n     * <p>Unlike {@link #ACTION_PROVISION_MANAGED_DEVICE}, the provisioning message can only be sent\n     * by a privileged app with the permission\n     * {@link android.Manifest.permission#DISPATCH_PROVISIONING_MESSAGE}.\n     *\n     * <p>The provisioning intent contains the following properties:\n     * <ul>\n     * <li>{@link #EXTRA_PROVISIONING_DEVICE_ADMIN_COMPONENT_NAME}</li>\n     * <li>{@link #EXTRA_PROVISIONING_DEVICE_ADMIN_PACKAGE_DOWNLOAD_LOCATION}, optional</li>\n     * <li>{@link #EXTRA_PROVISIONING_DEVICE_ADMIN_PACKAGE_DOWNLOAD_COOKIE_HEADER}, optional</li>\n     * <li>{@link #EXTRA_PROVISIONING_DEVICE_ADMIN_PACKAGE_CHECKSUM}, optional</li>\n     * <li>{@link #EXTRA_PROVISIONING_DEVICE_ADMIN_PACKAGE_LABEL}, optional</li>\n     * <li>{@link #EXTRA_PROVISIONING_DEVICE_ADMIN_PACKAGE_ICON_URI}, optional</li>\n     * <li>{@link #EXTRA_PROVISIONING_LOCAL_TIME} (convert to String), optional</li>\n     * <li>{@link #EXTRA_PROVISIONING_TIME_ZONE}, optional</li>\n     * <li>{@link #EXTRA_PROVISIONING_LOCALE}, optional</li>\n     * <li>{@link #EXTRA_PROVISIONING_WIFI_SSID}, optional</li>\n     * <li>{@link #EXTRA_PROVISIONING_WIFI_HIDDEN} (convert to String), optional</li>\n     * <li>{@link #EXTRA_PROVISIONING_WIFI_SECURITY_TYPE}, optional</li>\n     * <li>{@link #EXTRA_PROVISIONING_WIFI_PASSWORD}, optional</li>\n     * <li>{@link #EXTRA_PROVISIONING_WIFI_PROXY_HOST}, optional</li>\n     * <li>{@link #EXTRA_PROVISIONING_WIFI_PROXY_PORT} (convert to String), optional</li>\n     * <li>{@link #EXTRA_PROVISIONING_WIFI_PROXY_BYPASS}, optional</li>\n     * <li>{@link #EXTRA_PROVISIONING_WIFI_PAC_URL}, optional</li>\n     * <li>{@link #EXTRA_PROVISIONING_SUPPORT_URL}, optional</li>\n     * <li>{@link #EXTRA_PROVISIONING_ORGANIZATION_NAME}, optional</li>\n     * <li>{@link #EXTRA_PROVISIONING_ADMIN_EXTRAS_BUNDLE}, optional</li>\n     * <li>{@link #EXTRA_PROVISIONING_USE_MOBILE_DATA}, optional </li>\n     * <li>{@link #EXTRA_PROVISIONING_SKIP_EDUCATION_SCREENS}, optional - when not used for\n     * cloud enrollment, NFC or QR provisioning</li>\n     * </ul>\n     *\n     * @hide\n     ",
    "links" : [ "android.os.Build.VERSION_CODES#Q", "#ACTION_GET_PROVISIONING_MODE", "#ACTION_ADMIN_POLICY_COMPLIANCE", "#ACTION_PROVISION_MANAGED_DEVICE", "android.Manifest.permission#DISPATCH_PROVISIONING_MESSAGE", "#EXTRA_PROVISIONING_DEVICE_ADMIN_COMPONENT_NAME", "#EXTRA_PROVISIONING_DEVICE_ADMIN_PACKAGE_DOWNLOAD_LOCATION", "#EXTRA_PROVISIONING_DEVICE_ADMIN_PACKAGE_DOWNLOAD_COOKIE_HEADER", "#EXTRA_PROVISIONING_DEVICE_ADMIN_PACKAGE_CHECKSUM", "#EXTRA_PROVISIONING_DEVICE_ADMIN_PACKAGE_LABEL", "#EXTRA_PROVISIONING_DEVICE_ADMIN_PACKAGE_ICON_URI", "#EXTRA_PROVISIONING_LOCAL_TIME", "#EXTRA_PROVISIONING_TIME_ZONE", "#EXTRA_PROVISIONING_LOCALE", "#EXTRA_PROVISIONING_WIFI_SSID", "#EXTRA_PROVISIONING_WIFI_HIDDEN", "#EXTRA_PROVISIONING_WIFI_SECURITY_TYPE", "#EXTRA_PROVISIONING_WIFI_PASSWORD", "#EXTRA_PROVISIONING_WIFI_PROXY_HOST", "#EXTRA_PROVISIONING_WIFI_PROXY_PORT", "#EXTRA_PROVISIONING_WIFI_PROXY_BYPASS", "#EXTRA_PROVISIONING_WIFI_PAC_URL", "#EXTRA_PROVISIONING_SUPPORT_URL", "#EXTRA_PROVISIONING_ORGANIZATION_NAME", "#EXTRA_PROVISIONING_ADMIN_EXTRAS_BUNDLE", "#EXTRA_PROVISIONING_USE_MOBILE_DATA", "#EXTRA_PROVISIONING_SKIP_EDUCATION_SCREENS" ]
  }, {
    "name" : "ACTION_PROVISION_FINANCED_DEVICE",
    "type" : "String",
    "comment" : "\n     * Activity action: Starts the provisioning flow which sets up a financed device.\n     *\n     * <p>During financed device provisioning, a device admin app is downloaded and set as the owner\n     * of the device. A device owner has full control over the device. The device owner can not be\n     * modified by the user.\n     *\n     * <p>A typical use case would be a device that is bought from the reseller through financing\n     * program.\n     *\n     * <p>An intent with this action can be sent only on an unprovisioned device.\n     *\n     * <p>Unlike {@link #ACTION_PROVISION_MANAGED_DEVICE}, the provisioning message can only be sent\n     * by a privileged app with the permission\n     * {@link android.Manifest.permission#DISPATCH_PROVISIONING_MESSAGE}.\n     *\n     * <p>The provisioning intent contains the following properties:\n     * <ul>\n     * <li>{@link #EXTRA_PROVISIONING_DEVICE_ADMIN_COMPONENT_NAME}</li>\n     * <li>{@link #EXTRA_PROVISIONING_DEVICE_ADMIN_PACKAGE_DOWNLOAD_LOCATION}, optional</li>\n     * <li>{@link #EXTRA_PROVISIONING_DEVICE_ADMIN_PACKAGE_DOWNLOAD_COOKIE_HEADER}, optional</li>\n     * <li>{@link #EXTRA_PROVISIONING_DEVICE_ADMIN_PACKAGE_CHECKSUM}, optional</li>\n     * <li>{@link #EXTRA_PROVISIONING_DEVICE_ADMIN_PACKAGE_LABEL}, optional</li>\n     * <li>{@link #EXTRA_PROVISIONING_DEVICE_ADMIN_PACKAGE_ICON_URI}, optional</li>\n     * <li>{@link #EXTRA_PROVISIONING_SUPPORT_URL}, optional</li>\n     * <li>{@link #EXTRA_PROVISIONING_ORGANIZATION_NAME}, optional</li>\n     * <li>{@link #EXTRA_PROVISIONING_ADMIN_EXTRAS_BUNDLE}, optional</li>\n     * </ul>\n     *\n     * @hide\n     ",
    "links" : [ "#ACTION_PROVISION_MANAGED_DEVICE", "android.Manifest.permission#DISPATCH_PROVISIONING_MESSAGE", "#EXTRA_PROVISIONING_DEVICE_ADMIN_COMPONENT_NAME", "#EXTRA_PROVISIONING_DEVICE_ADMIN_PACKAGE_DOWNLOAD_LOCATION", "#EXTRA_PROVISIONING_DEVICE_ADMIN_PACKAGE_DOWNLOAD_COOKIE_HEADER", "#EXTRA_PROVISIONING_DEVICE_ADMIN_PACKAGE_CHECKSUM", "#EXTRA_PROVISIONING_DEVICE_ADMIN_PACKAGE_LABEL", "#EXTRA_PROVISIONING_DEVICE_ADMIN_PACKAGE_ICON_URI", "#EXTRA_PROVISIONING_SUPPORT_URL", "#EXTRA_PROVISIONING_ORGANIZATION_NAME", "#EXTRA_PROVISIONING_ADMIN_EXTRAS_BUNDLE" ]
  }, {
    "name" : "ACTION_PROVISION_MANAGED_SHAREABLE_DEVICE",
    "type" : "String",
    "comment" : "\n     * Activity action: Starts the provisioning flow which sets up a managed device.\n     * Must be started with {@link android.app.Activity#startActivityForResult(Intent, int)}.\n     *\n     * <p>NOTE: This is only supported on split system user devices, and puts the device into a\n     * management state that is distinct from that reached by\n     * {@link #ACTION_PROVISION_MANAGED_DEVICE} - specifically the device owner runs on the system\n     * user, and only has control over device-wide policies, not individual users and their data.\n     * The primary benefit is that multiple non-system users are supported when provisioning using\n     * this form of device management.\n     *\n     * <p>During device owner provisioning a device admin app is set as the owner of the device.\n     * A device owner has full control over the device. The device owner can not be modified by the\n     * user.\n     *\n     * <p>A typical use case would be a device that is owned by a company, but used by either an\n     * employee or client.\n     *\n     * <p>An intent with this action can be sent only on an unprovisioned device.\n     * It is possible to check if provisioning is allowed or not by querying the method\n     * {@link #isProvisioningAllowed(String)}.\n     *\n     * <p>The intent contains the following extras:\n     * <ul>\n     * <li>{@link #EXTRA_PROVISIONING_DEVICE_ADMIN_COMPONENT_NAME}</li>\n     * <li>{@link #EXTRA_PROVISIONING_SKIP_ENCRYPTION}, optional</li>\n     * <li>{@link #EXTRA_PROVISIONING_LEAVE_ALL_SYSTEM_APPS_ENABLED}, optional</li>\n     * <li>{@link #EXTRA_PROVISIONING_ADMIN_EXTRAS_BUNDLE}, optional</li>\n     * <li>{@link #EXTRA_PROVISIONING_LOGO_URI}, optional</li>\n     * <li>{@link #EXTRA_PROVISIONING_MAIN_COLOR}, optional</li>\n     * </ul>\n     *\n     * <p>When device owner provisioning has completed, an intent of the type\n     * {@link DeviceAdminReceiver#ACTION_PROFILE_PROVISIONING_COMPLETE} is broadcast to the\n     * device owner.\n     *\n     * <p>From version {@link android.os.Build.VERSION_CODES#O}, when device owner provisioning has\n     * completed, along with the above broadcast, activity intent\n     * {@link #ACTION_PROVISIONING_SUCCESSFUL} will also be sent to the device owner.\n     *\n     * <p>If provisioning fails, the device is factory reset.\n     *\n     * <p>A result code of {@link android.app.Activity#RESULT_OK} implies that the synchronous part\n     * of the provisioning flow was successful, although this doesn't guarantee the full flow will\n     * succeed. Conversely a result code of {@link android.app.Activity#RESULT_CANCELED} implies\n     * that the user backed-out of provisioning, or some precondition for provisioning wasn't met.\n     *\n     * @hide\n     ",
    "links" : [ "android.app.Activity#startActivityForResult", "#ACTION_PROVISION_MANAGED_DEVICE", "#isProvisioningAllowed", "#EXTRA_PROVISIONING_DEVICE_ADMIN_COMPONENT_NAME", "#EXTRA_PROVISIONING_SKIP_ENCRYPTION", "#EXTRA_PROVISIONING_LEAVE_ALL_SYSTEM_APPS_ENABLED", "#EXTRA_PROVISIONING_ADMIN_EXTRAS_BUNDLE", "#EXTRA_PROVISIONING_LOGO_URI", "#EXTRA_PROVISIONING_MAIN_COLOR", "DeviceAdminReceiver#ACTION_PROFILE_PROVISIONING_COMPLETE", "android.os.Build.VERSION_CODES#O", "#ACTION_PROVISIONING_SUCCESSFUL", "android.app.Activity#RESULT_OK", "android.app.Activity#RESULT_CANCELED" ]
  }, {
    "name" : "ACTION_PROVISION_FINALIZATION",
    "type" : "String",
    "comment" : "\n     * Activity action: Finalizes management provisioning, should be used after user-setup\n     * has been completed and {@link #getUserProvisioningState()} returns one of:\n     * <ul>\n     * <li>{@link #STATE_USER_SETUP_INCOMPLETE}</li>\n     * <li>{@link #STATE_USER_SETUP_COMPLETE}</li>\n     * <li>{@link #STATE_USER_PROFILE_COMPLETE}</li>\n     * </ul>\n     *\n     * @hide\n     ",
    "links" : [ "#getUserProvisioningState", "#STATE_USER_SETUP_INCOMPLETE", "#STATE_USER_SETUP_COMPLETE", "#STATE_USER_PROFILE_COMPLETE" ]
  }, {
    "name" : "ACTION_BUGREPORT_SHARING_ACCEPTED",
    "type" : "String",
    "comment" : "\n     * Action: Bugreport sharing with device owner has been accepted by the user.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "ACTION_BUGREPORT_SHARING_DECLINED",
    "type" : "String",
    "comment" : "\n     * Action: Bugreport sharing with device owner has been declined by the user.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "ACTION_REMOTE_BUGREPORT_DISPATCH",
    "type" : "String",
    "comment" : "\n     * Action: Bugreport has been collected and is dispatched to {@code DevicePolicyManagerService}.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "EXTRA_REMOTE_BUGREPORT_HASH",
    "type" : "String",
    "comment" : "\n     * Extra for shared bugreport's SHA-256 hash.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "EXTRA_BUGREPORT_NOTIFICATION_TYPE",
    "type" : "String",
    "comment" : "\n     * Extra for remote bugreport notification shown type.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "NOTIFICATION_BUGREPORT_STARTED",
    "type" : "int",
    "comment" : "\n     * Notification type for a started remote bugreport flow.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "NOTIFICATION_BUGREPORT_ACCEPTED_NOT_FINISHED",
    "type" : "int",
    "comment" : "\n     * Notification type for a bugreport that has already been accepted to be shared, but is still\n     * being taken.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "NOTIFICATION_BUGREPORT_FINISHED_NOT_ACCEPTED",
    "type" : "int",
    "comment" : "\n     * Notification type for a bugreport that has been taken and can be shared or declined.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "DEFAULT_STRONG_AUTH_TIMEOUT_MS",
    "type" : "long",
    "comment" : " 72h",
    "links" : [ ]
  }, {
    "name" : "EXTRA_PROVISIONING_ADMIN_EXTRAS_BUNDLE",
    "type" : "String",
    "comment" : "\n     * A {@link android.os.Parcelable} extra of type {@link android.os.PersistableBundle} that\n     * allows a mobile device management application or NFC programmer application which starts\n     * managed provisioning to pass data to the management application instance after provisioning.\n     * <p>\n     * If used with {@link #ACTION_PROVISION_MANAGED_PROFILE} it can be used by the application that\n     * sends the intent to pass data to itself on the newly created profile.\n     * If used with {@link #ACTION_PROVISION_MANAGED_DEVICE} it allows passing data to the same\n     * instance of the app on the primary user.\n     * Starting from {@link android.os.Build.VERSION_CODES#M}, if used with\n     * {@link #MIME_TYPE_PROVISIONING_NFC} as part of NFC managed device provisioning, the NFC\n     * message should contain a stringified {@link java.util.Properties} instance, whose string\n     * properties will be converted into a {@link android.os.PersistableBundle} and passed to the\n     * management application after provisioning.\n     *\n     * <p>\n     * In both cases the application receives the data in\n     * {@link DeviceAdminReceiver#onProfileProvisioningComplete} via an intent with the action\n     * {@link DeviceAdminReceiver#ACTION_PROFILE_PROVISIONING_COMPLETE}. The bundle is not changed\n     * during the managed provisioning.\n     ",
    "links" : [ "android.os.Parcelable", "android.os.PersistableBundle", "#ACTION_PROVISION_MANAGED_PROFILE", "#ACTION_PROVISION_MANAGED_DEVICE", "android.os.Build.VERSION_CODES#M", "#MIME_TYPE_PROVISIONING_NFC", "java.util.Properties", "android.os.PersistableBundle", "DeviceAdminReceiver#onProfileProvisioningComplete", "DeviceAdminReceiver#ACTION_PROFILE_PROVISIONING_COMPLETE" ]
  }, {
    "name" : "EXTRA_PROVISIONING_DEVICE_ADMIN_PACKAGE_NAME",
    "type" : "String",
    "comment" : "\n     * A String extra holding the package name of the mobile device management application that\n     * will be set as the profile owner or device owner.\n     *\n     * <p>If an application starts provisioning directly via an intent with action\n     * {@link #ACTION_PROVISION_MANAGED_PROFILE} this package has to match the package name of the\n     * application that started provisioning. The package will be set as profile owner in that case.\n     *\n     * <p>This package is set as device owner when device owner provisioning is started by an NFC\n     * message containing an NFC record with MIME type {@link #MIME_TYPE_PROVISIONING_NFC}.\n     *\n     * <p> When this extra is set, the application must have exactly one device admin receiver.\n     * This receiver will be set as the profile or device owner and active admin.\n     *\n     * @see DeviceAdminReceiver\n     * @deprecated Use {@link #EXTRA_PROVISIONING_DEVICE_ADMIN_COMPONENT_NAME}. This extra is still\n     * supported, but only if there is only one device admin receiver in the package that requires\n     * the permission {@link android.Manifest.permission#BIND_DEVICE_ADMIN}.\n     ",
    "links" : [ "#ACTION_PROVISION_MANAGED_PROFILE", "#MIME_TYPE_PROVISIONING_NFC", "#EXTRA_PROVISIONING_DEVICE_ADMIN_COMPONENT_NAME", "android.Manifest.permission#BIND_DEVICE_ADMIN" ]
  }, {
    "name" : "EXTRA_PROVISIONING_DEVICE_ADMIN_COMPONENT_NAME",
    "type" : "String",
    "comment" : "\n     * A ComponentName extra indicating the device admin receiver of the mobile device management\n     * application that will be set as the profile owner or device owner and active admin.\n     *\n     * <p>If an application starts provisioning directly via an intent with action\n     * {@link #ACTION_PROVISION_MANAGED_PROFILE} or\n     * {@link #ACTION_PROVISION_MANAGED_DEVICE} the package name of this\n     * component has to match the package name of the application that started provisioning.\n     *\n     * <p>This component is set as device owner and active admin when device owner provisioning is\n     * started by an intent with action {@link #ACTION_PROVISION_MANAGED_DEVICE} or by an NFC\n     * message containing an NFC record with MIME type\n     * {@link #MIME_TYPE_PROVISIONING_NFC}. For the NFC record, the component name must be\n     * flattened to a string, via {@link ComponentName#flattenToShortString()}.\n     *\n     * @see DeviceAdminReceiver\n     ",
    "links" : [ "#ACTION_PROVISION_MANAGED_PROFILE", "#ACTION_PROVISION_MANAGED_DEVICE", "#ACTION_PROVISION_MANAGED_DEVICE", "#MIME_TYPE_PROVISIONING_NFC", "ComponentName#flattenToShortString" ]
  }, {
    "name" : "EXTRA_PROVISIONING_ACCOUNT_TO_MIGRATE",
    "type" : "String",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "EXTRA_PROVISIONING_KEEP_ACCOUNT_ON_MIGRATION",
    "type" : "String",
    "comment" : "\n     * Boolean extra to indicate that the migrated account should be kept. This is used in\n     * conjunction with {@link #EXTRA_PROVISIONING_ACCOUNT_TO_MIGRATE}. If it's set to {@code true},\n     * the account will not be removed from the primary user after it is migrated to the newly\n     * created user or profile.\n     *\n     * <p> Defaults to {@code false}\n     *\n     * <p> Use with {@link #ACTION_PROVISION_MANAGED_PROFILE} and\n     * {@link #EXTRA_PROVISIONING_ACCOUNT_TO_MIGRATE}\n     ",
    "links" : [ "#EXTRA_PROVISIONING_ACCOUNT_TO_MIGRATE", "#ACTION_PROVISION_MANAGED_PROFILE", "#EXTRA_PROVISIONING_ACCOUNT_TO_MIGRATE" ]
  }, {
    "name" : "EXTRA_PROVISIONING_EMAIL_ADDRESS",
    "type" : "String",
    "comment" : "\n     * @deprecated From {@link android.os.Build.VERSION_CODES#O}, never used while provisioning the\n     * device.\n     ",
    "links" : [ "android.os.Build.VERSION_CODES#O" ]
  }, {
    "name" : "EXTRA_PROVISIONING_MAIN_COLOR",
    "type" : "String",
    "comment" : "\n     * A integer extra indicating the predominant color to show during the provisioning.\n     * Refer to {@link android.graphics.Color} for how the color is represented.\n     *\n     * <p>Use with {@link #ACTION_PROVISION_MANAGED_PROFILE} or\n     * {@link #ACTION_PROVISION_MANAGED_DEVICE}.\n     ",
    "links" : [ "android.graphics.Color", "#ACTION_PROVISION_MANAGED_PROFILE", "#ACTION_PROVISION_MANAGED_DEVICE" ]
  }, {
    "name" : "EXTRA_PROVISIONING_LEAVE_ALL_SYSTEM_APPS_ENABLED",
    "type" : "String",
    "comment" : "\n     * A Boolean extra that can be used by the mobile device management application to skip the\n     * disabling of system apps during provisioning when set to {@code true}.\n     *\n     * <p>Use in an NFC record with {@link #MIME_TYPE_PROVISIONING_NFC} or an intent with action\n     * {@link #ACTION_PROVISION_MANAGED_DEVICE} that starts device owner provisioning.\n     ",
    "links" : [ "#MIME_TYPE_PROVISIONING_NFC", "#ACTION_PROVISION_MANAGED_DEVICE" ]
  }, {
    "name" : "EXTRA_PROVISIONING_TIME_ZONE",
    "type" : "String",
    "comment" : "\n     * A String extra holding the time zone {@link android.app.AlarmManager} that the device\n     * will be set to.\n     *\n     * <p>Use in an NFC record with {@link #MIME_TYPE_PROVISIONING_NFC} that starts device owner\n     * provisioning via an NFC bump.\n     ",
    "links" : [ "android.app.AlarmManager", "#MIME_TYPE_PROVISIONING_NFC" ]
  }, {
    "name" : "EXTRA_PROVISIONING_LOCAL_TIME",
    "type" : "String",
    "comment" : "\n     * A Long extra holding the wall clock time (in milliseconds) to be set on the device's\n     * {@link android.app.AlarmManager}.\n     *\n     * <p>Use in an NFC record with {@link #MIME_TYPE_PROVISIONING_NFC} that starts device owner\n     * provisioning via an NFC bump.\n     ",
    "links" : [ "android.app.AlarmManager", "#MIME_TYPE_PROVISIONING_NFC" ]
  }, {
    "name" : "EXTRA_PROVISIONING_LOCALE",
    "type" : "String",
    "comment" : "\n     * A String extra holding the {@link java.util.Locale} that the device will be set to.\n     * Format: xx_yy, where xx is the language code, and yy the country code.\n     *\n     * <p>Use in an NFC record with {@link #MIME_TYPE_PROVISIONING_NFC} that starts device owner\n     * provisioning via an NFC bump.\n     ",
    "links" : [ "java.util.Locale", "#MIME_TYPE_PROVISIONING_NFC" ]
  }, {
    "name" : "EXTRA_PROVISIONING_WIFI_SSID",
    "type" : "String",
    "comment" : "\n     * A String extra holding the ssid of the wifi network that should be used during nfc device\n     * owner provisioning for downloading the mobile device management application.\n     *\n     * <p>Use in an NFC record with {@link #MIME_TYPE_PROVISIONING_NFC} that starts device owner\n     * provisioning via an NFC bump.\n     ",
    "links" : [ "#MIME_TYPE_PROVISIONING_NFC" ]
  }, {
    "name" : "EXTRA_PROVISIONING_WIFI_HIDDEN",
    "type" : "String",
    "comment" : "\n     * A boolean extra indicating whether the wifi network in {@link #EXTRA_PROVISIONING_WIFI_SSID}\n     * is hidden or not.\n     *\n     * <p>Use in an NFC record with {@link #MIME_TYPE_PROVISIONING_NFC} that starts device owner\n     * provisioning via an NFC bump.\n     ",
    "links" : [ "#EXTRA_PROVISIONING_WIFI_SSID", "#MIME_TYPE_PROVISIONING_NFC" ]
  }, {
    "name" : "EXTRA_PROVISIONING_WIFI_SECURITY_TYPE",
    "type" : "String",
    "comment" : "\n     * A String extra indicating the security type of the wifi network in\n     * {@link #EXTRA_PROVISIONING_WIFI_SSID} and could be one of {@code NONE}, {@code WPA},\n     * {@code WEP} or {@code EAP}.\n     *\n     * <p>Use in an NFC record with {@link #MIME_TYPE_PROVISIONING_NFC} that starts device owner\n     * provisioning via an NFC bump.\n     ",
    "links" : [ "#EXTRA_PROVISIONING_WIFI_SSID", "#MIME_TYPE_PROVISIONING_NFC" ]
  }, {
    "name" : "EXTRA_PROVISIONING_WIFI_PASSWORD",
    "type" : "String",
    "comment" : "\n     * A String extra holding the password of the wifi network in\n     * {@link #EXTRA_PROVISIONING_WIFI_SSID}.\n     *\n     * <p>Use in an NFC record with {@link #MIME_TYPE_PROVISIONING_NFC} that starts device owner\n     * provisioning via an NFC bump.\n     ",
    "links" : [ "#EXTRA_PROVISIONING_WIFI_SSID", "#MIME_TYPE_PROVISIONING_NFC" ]
  }, {
    "name" : "EXTRA_PROVISIONING_WIFI_EAP_METHOD",
    "type" : "String",
    "comment" : "\n     * The EAP method of the wifi network in {@link #EXTRA_PROVISIONING_WIFI_SSID}\n     * and could be one of {@code PEAP}, {@code TLS}, {@code TTLS}, {@code PWD}, {@code SIM},\n     * {@code AKA} or {@code AKA_PRIME}. This is only used if the\n     * {@link #EXTRA_PROVISIONING_WIFI_SECURITY_TYPE} is {@code EAP}.\n     *\n     * <p>Use in an NFC record with {@link #MIME_TYPE_PROVISIONING_NFC} that starts device owner\n     * provisioning via an NFC bump. It can also be used for QR code provisioning.\n     ",
    "links" : [ "#EXTRA_PROVISIONING_WIFI_SSID", "#EXTRA_PROVISIONING_WIFI_SECURITY_TYPE", "#MIME_TYPE_PROVISIONING_NFC" ]
  }, {
    "name" : "EXTRA_PROVISIONING_WIFI_PHASE2_AUTH",
    "type" : "String",
    "comment" : "\n     * The phase 2 authentication of the wifi network in {@link #EXTRA_PROVISIONING_WIFI_SSID}\n     * and could be one of {@code NONE}, {@code PAP}, {@code MSCHAP}, {@code MSCHAPV2}, {@code GTC},\n     * {@code SIM}, {@code AKA} or {@code AKA_PRIME}. This is only used if the\n     * {@link #EXTRA_PROVISIONING_WIFI_SECURITY_TYPE} is {@code EAP}.\n     *\n     * <p>Use in an NFC record with {@link #MIME_TYPE_PROVISIONING_NFC} that starts device owner\n     * provisioning via an NFC bump. It can also be used for QR code provisioning.\n     ",
    "links" : [ "#EXTRA_PROVISIONING_WIFI_SSID", "#EXTRA_PROVISIONING_WIFI_SECURITY_TYPE", "#MIME_TYPE_PROVISIONING_NFC" ]
  }, {
    "name" : "EXTRA_PROVISIONING_WIFI_CA_CERTIFICATE",
    "type" : "String",
    "comment" : "\n     * The CA certificate of the wifi network in {@link #EXTRA_PROVISIONING_WIFI_SSID}. This should\n     * be an X.509 certificate Base64 encoded DER format, ie. PEM representation of a certificate\n     * without header, footer and line breaks. <a href=\n     * \"https://tools.ietf.org/html/rfc7468\"> More information</a> This is only\n     * used if the {@link\n     * #EXTRA_PROVISIONING_WIFI_SECURITY_TYPE} is {@code EAP}.\n     *\n     * <p>Use in an NFC record with {@link #MIME_TYPE_PROVISIONING_NFC} that starts device owner\n     * provisioning via an NFC bump. It can also be used for QR code provisioning.\n     ",
    "links" : [ "#EXTRA_PROVISIONING_WIFI_SSID", "#MIME_TYPE_PROVISIONING_NFC" ]
  }, {
    "name" : "EXTRA_PROVISIONING_WIFI_USER_CERTIFICATE",
    "type" : "String",
    "comment" : "\n     * The user certificate of the wifi network in {@link #EXTRA_PROVISIONING_WIFI_SSID}. This\n     * should be an X.509 certificate and private key Base64 encoded DER format, ie. PEM\n     * representation of a certificate and key without header, footer and line breaks. <a href=\n     * \"https://tools.ietf.org/html/rfc7468\"> More information</a> This is only\n     * used if the {@link #EXTRA_PROVISIONING_WIFI_SECURITY_TYPE} is {@code EAP}.\n     *\n     * <p>Use in an NFC record with {@link #MIME_TYPE_PROVISIONING_NFC} that starts device owner\n     * provisioning via an NFC bump. It can also be used for QR code provisioning.\n     ",
    "links" : [ "#EXTRA_PROVISIONING_WIFI_SSID", "#EXTRA_PROVISIONING_WIFI_SECURITY_TYPE", "#MIME_TYPE_PROVISIONING_NFC" ]
  }, {
    "name" : "EXTRA_PROVISIONING_WIFI_IDENTITY",
    "type" : "String",
    "comment" : "\n     * The identity of the wifi network in {@link #EXTRA_PROVISIONING_WIFI_SSID}. This is only used\n     * if the {@link #EXTRA_PROVISIONING_WIFI_SECURITY_TYPE} is {@code EAP}.\n     *\n     * <p>Use in an NFC record with {@link #MIME_TYPE_PROVISIONING_NFC} that starts device owner\n     * provisioning via an NFC bump. It can also be used for QR code provisioning.\n     ",
    "links" : [ "#EXTRA_PROVISIONING_WIFI_SSID", "#EXTRA_PROVISIONING_WIFI_SECURITY_TYPE", "#MIME_TYPE_PROVISIONING_NFC" ]
  }, {
    "name" : "EXTRA_PROVISIONING_WIFI_ANONYMOUS_IDENTITY",
    "type" : "String",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "EXTRA_PROVISIONING_WIFI_DOMAIN",
    "type" : "String",
    "comment" : "\n     * The domain of the wifi network in {@link #EXTRA_PROVISIONING_WIFI_SSID}. This is only used if\n     * the {@link #EXTRA_PROVISIONING_WIFI_SECURITY_TYPE} is {@code EAP}.\n     *\n     * <p>Use in an NFC record with {@link #MIME_TYPE_PROVISIONING_NFC} that starts device owner\n     * provisioning via an NFC bump. It can also be used for QR code provisioning.\n     ",
    "links" : [ "#EXTRA_PROVISIONING_WIFI_SSID", "#EXTRA_PROVISIONING_WIFI_SECURITY_TYPE", "#MIME_TYPE_PROVISIONING_NFC" ]
  }, {
    "name" : "EXTRA_PROVISIONING_WIFI_PROXY_HOST",
    "type" : "String",
    "comment" : "\n     * A String extra holding the proxy host for the wifi network in\n     * {@link #EXTRA_PROVISIONING_WIFI_SSID}.\n     *\n     * <p>Use in an NFC record with {@link #MIME_TYPE_PROVISIONING_NFC} that starts device owner\n     * provisioning via an NFC bump.\n     ",
    "links" : [ "#EXTRA_PROVISIONING_WIFI_SSID", "#MIME_TYPE_PROVISIONING_NFC" ]
  }, {
    "name" : "EXTRA_PROVISIONING_WIFI_PROXY_PORT",
    "type" : "String",
    "comment" : "\n     * An int extra holding the proxy port for the wifi network in\n     * {@link #EXTRA_PROVISIONING_WIFI_SSID}.\n     *\n     * <p>Use in an NFC record with {@link #MIME_TYPE_PROVISIONING_NFC} that starts device owner\n     * provisioning via an NFC bump.\n     ",
    "links" : [ "#EXTRA_PROVISIONING_WIFI_SSID", "#MIME_TYPE_PROVISIONING_NFC" ]
  }, {
    "name" : "EXTRA_PROVISIONING_WIFI_PROXY_BYPASS",
    "type" : "String",
    "comment" : "\n     * A String extra holding the proxy bypass for the wifi network in\n     * {@link #EXTRA_PROVISIONING_WIFI_SSID}.\n     *\n     * <p>Use in an NFC record with {@link #MIME_TYPE_PROVISIONING_NFC} that starts device owner\n     * provisioning via an NFC bump.\n     ",
    "links" : [ "#EXTRA_PROVISIONING_WIFI_SSID", "#MIME_TYPE_PROVISIONING_NFC" ]
  }, {
    "name" : "EXTRA_PROVISIONING_WIFI_PAC_URL",
    "type" : "String",
    "comment" : "\n     * A String extra holding the proxy auto-config (PAC) URL for the wifi network in\n     * {@link #EXTRA_PROVISIONING_WIFI_SSID}.\n     *\n     * <p>Use in an NFC record with {@link #MIME_TYPE_PROVISIONING_NFC} that starts device owner\n     * provisioning via an NFC bump.\n     ",
    "links" : [ "#EXTRA_PROVISIONING_WIFI_SSID", "#MIME_TYPE_PROVISIONING_NFC" ]
  }, {
    "name" : "EXTRA_PROVISIONING_DEVICE_ADMIN_PACKAGE_DOWNLOAD_LOCATION",
    "type" : "String",
    "comment" : "\n     * A String extra holding a url that specifies the download location of the device admin\n     * package. When not provided it is assumed that the device admin package is already installed.\n     *\n     * <p>Use in an NFC record with {@link #MIME_TYPE_PROVISIONING_NFC} that starts device owner\n     * provisioning via an NFC bump.\n     ",
    "links" : [ "#MIME_TYPE_PROVISIONING_NFC" ]
  }, {
    "name" : "EXTRA_PROVISIONING_ORGANIZATION_NAME",
    "type" : "String",
    "comment" : "\n     * A String extra holding the localized name of the organization under management.\n     *\n     * The name is displayed only during provisioning.\n     *\n     * <p>Use in an intent with action {@link #ACTION_PROVISION_MANAGED_DEVICE_FROM_TRUSTED_SOURCE}\n     * or {@link #ACTION_PROVISION_FINANCED_DEVICE}\n     *\n     * @hide\n     ",
    "links" : [ "#ACTION_PROVISION_MANAGED_DEVICE_FROM_TRUSTED_SOURCE", "#ACTION_PROVISION_FINANCED_DEVICE" ]
  }, {
    "name" : "EXTRA_PROVISIONING_SUPPORT_URL",
    "type" : "String",
    "comment" : "\n     * A String extra holding a url to the website of the device provider so the user can open it\n     * during provisioning. If the url is not HTTPS, an error will be shown.\n     *\n     * <p>Use in an intent with action {@link #ACTION_PROVISION_MANAGED_DEVICE_FROM_TRUSTED_SOURCE}\n     * or {@link #ACTION_PROVISION_FINANCED_DEVICE}\n     *\n     * @hide\n     ",
    "links" : [ "#ACTION_PROVISION_MANAGED_DEVICE_FROM_TRUSTED_SOURCE", "#ACTION_PROVISION_FINANCED_DEVICE" ]
  }, {
    "name" : "EXTRA_PROVISIONING_DEVICE_ADMIN_PACKAGE_LABEL",
    "type" : "String",
    "comment" : "\n     * A String extra holding the localized name of the device admin package. It should be the same\n     * as the app label of the package.\n     *\n     * <p>Use in an intent with action {@link #ACTION_PROVISION_MANAGED_DEVICE_FROM_TRUSTED_SOURCE}\n     * or {@link #ACTION_PROVISION_FINANCED_DEVICE}\n     *\n     * @hide\n     ",
    "links" : [ "#ACTION_PROVISION_MANAGED_DEVICE_FROM_TRUSTED_SOURCE", "#ACTION_PROVISION_FINANCED_DEVICE" ]
  }, {
    "name" : "EXTRA_PROVISIONING_DEVICE_ADMIN_PACKAGE_ICON_URI",
    "type" : "String",
    "comment" : "\n     * A {@link Uri} extra pointing to the app icon of device admin package. This image will be\n     * shown during the provisioning.\n     * <h5>The following URI schemes are accepted:</h5>\n     * <ul>\n     * <li>content ({@link android.content.ContentResolver#SCHEME_CONTENT})</li>\n     * <li>android.resource ({@link android.content.ContentResolver#SCHEME_ANDROID_RESOURCE})</li>\n     * </ul>\n     *\n     * <p> It is the responsibility of the caller to provide an image with a reasonable\n     * pixel density for the device.\n     *\n     * <p> If a content: URI is passed, the intent should have the flag\n     * {@link Intent#FLAG_GRANT_READ_URI_PERMISSION} and the uri should be added to the\n     * {@link android.content.ClipData} of the intent too.\n     *\n     * <p>Use in an intent with action {@link #ACTION_PROVISION_MANAGED_DEVICE_FROM_TRUSTED_SOURCE}\n     * or {@link #ACTION_PROVISION_FINANCED_DEVICE}\n     *\n     * @hide\n     ",
    "links" : [ "Uri", "android.content.ContentResolver#SCHEME_CONTENT", "android.content.ContentResolver#SCHEME_ANDROID_RESOURCE", "Intent#FLAG_GRANT_READ_URI_PERMISSION", "android.content.ClipData", "#ACTION_PROVISION_MANAGED_DEVICE_FROM_TRUSTED_SOURCE", "#ACTION_PROVISION_FINANCED_DEVICE" ]
  }, {
    "name" : "EXTRA_PROVISIONING_DEVICE_ADMIN_MINIMUM_VERSION_CODE",
    "type" : "String",
    "comment" : "\n     * An int extra holding a minimum required version code for the device admin package. If the\n     * device admin is already installed on the device, it will only be re-downloaded from\n     * {@link #EXTRA_PROVISIONING_DEVICE_ADMIN_PACKAGE_DOWNLOAD_LOCATION} if the version of the\n     * installed package is less than this version code.\n     *\n     * <p>Use in an NFC record with {@link #MIME_TYPE_PROVISIONING_NFC} that starts device owner\n     * provisioning via an NFC bump.\n     ",
    "links" : [ "#EXTRA_PROVISIONING_DEVICE_ADMIN_PACKAGE_DOWNLOAD_LOCATION", "#MIME_TYPE_PROVISIONING_NFC" ]
  }, {
    "name" : "EXTRA_PROVISIONING_DEVICE_ADMIN_PACKAGE_DOWNLOAD_COOKIE_HEADER",
    "type" : "String",
    "comment" : "\n     * A String extra holding a http cookie header which should be used in the http request to the\n     * url specified in {@link #EXTRA_PROVISIONING_DEVICE_ADMIN_PACKAGE_DOWNLOAD_LOCATION}.\n     *\n     * <p>Use in an NFC record with {@link #MIME_TYPE_PROVISIONING_NFC} that starts device owner\n     * provisioning via an NFC bump.\n     ",
    "links" : [ "#EXTRA_PROVISIONING_DEVICE_ADMIN_PACKAGE_DOWNLOAD_LOCATION", "#MIME_TYPE_PROVISIONING_NFC" ]
  }, {
    "name" : "EXTRA_PROVISIONING_DEVICE_ADMIN_PACKAGE_CHECKSUM",
    "type" : "String",
    "comment" : "\n     * A String extra holding the URL-safe base64 encoded SHA-256 hash of the file at download\n     * location specified in {@link #EXTRA_PROVISIONING_DEVICE_ADMIN_PACKAGE_DOWNLOAD_LOCATION}.\n     *\n     * <p>Either this extra or {@link #EXTRA_PROVISIONING_DEVICE_ADMIN_SIGNATURE_CHECKSUM} must be\n     * present. The provided checksum must match the checksum of the file at the download\n     * location. If the checksum doesn't match an error will be shown to the user and the user will\n     * be asked to factory reset the device.\n     *\n     * <p>Use in an NFC record with {@link #MIME_TYPE_PROVISIONING_NFC} that starts device owner\n     * provisioning via an NFC bump.\n     *\n     * <p><strong>Note:</strong> for devices running {@link android.os.Build.VERSION_CODES#LOLLIPOP}\n     * and {@link android.os.Build.VERSION_CODES#LOLLIPOP_MR1} only SHA-1 hash is supported.\n     * Starting from {@link android.os.Build.VERSION_CODES#M}, this parameter accepts SHA-256 in\n     * addition to SHA-1. From {@link android.os.Build.VERSION_CODES#Q}, only SHA-256 hash is\n     * supported.\n     ",
    "links" : [ "#EXTRA_PROVISIONING_DEVICE_ADMIN_PACKAGE_DOWNLOAD_LOCATION", "#EXTRA_PROVISIONING_DEVICE_ADMIN_SIGNATURE_CHECKSUM", "#MIME_TYPE_PROVISIONING_NFC", "android.os.Build.VERSION_CODES#LOLLIPOP", "android.os.Build.VERSION_CODES#LOLLIPOP_MR1", "android.os.Build.VERSION_CODES#M", "android.os.Build.VERSION_CODES#Q" ]
  }, {
    "name" : "EXTRA_PROVISIONING_DEVICE_ADMIN_SIGNATURE_CHECKSUM",
    "type" : "String",
    "comment" : "\n     * A String extra holding the URL-safe base64 encoded SHA-256 checksum of any signature of the\n     * android package archive at the download location specified in {@link\n     * #EXTRA_PROVISIONING_DEVICE_ADMIN_PACKAGE_DOWNLOAD_LOCATION}.\n     *\n     * <p>The signatures of an android package archive can be obtained using\n     * {@link android.content.pm.PackageManager#getPackageArchiveInfo} with flag\n     * {@link android.content.pm.PackageManager#GET_SIGNATURES}.\n     *\n     * <p>Either this extra or {@link #EXTRA_PROVISIONING_DEVICE_ADMIN_PACKAGE_CHECKSUM} must be\n     * present. The provided checksum must match the checksum of any signature of the file at\n     * the download location. If the checksum does not match an error will be shown to the user and\n     * the user will be asked to factory reset the device.\n     *\n     * <p>Use in an NFC record with {@link #MIME_TYPE_PROVISIONING_NFC} that starts device owner\n     * provisioning via an NFC bump.\n     ",
    "links" : [ "android.content.pm.PackageManager#getPackageArchiveInfo", "android.content.pm.PackageManager#GET_SIGNATURES", "#EXTRA_PROVISIONING_DEVICE_ADMIN_PACKAGE_CHECKSUM", "#MIME_TYPE_PROVISIONING_NFC" ]
  }, {
    "name" : "ACTION_MANAGED_PROFILE_PROVISIONED",
    "type" : "String",
    "comment" : "\n     * Broadcast Action: This broadcast is sent to indicate that provisioning of a managed profile\n     * has completed successfully.\n     *\n     * <p>The broadcast is limited to the primary profile, to the app specified in the provisioning\n     * intent with action {@link #ACTION_PROVISION_MANAGED_PROFILE}.\n     *\n     * <p>This intent will contain the following extras\n     * <ul>\n     * <li>{@link Intent#EXTRA_USER}, corresponds to the {@link UserHandle} of the managed\n     * profile.</li>\n     * <li>{@link #EXTRA_PROVISIONING_ACCOUNT_TO_MIGRATE}, corresponds to the account requested to\n     * be migrated at provisioning time, if any.</li>\n     * </ul>\n     ",
    "links" : [ "#ACTION_PROVISION_MANAGED_PROFILE", "Intent#EXTRA_USER", "UserHandle", "#EXTRA_PROVISIONING_ACCOUNT_TO_MIGRATE" ]
  }, {
    "name" : "ACTION_PROVISIONING_SUCCESSFUL",
    "type" : "String",
    "comment" : "\n     * Activity action: This activity action is sent to indicate that provisioning of a managed\n     * profile or managed device has completed successfully. It'll be sent at the same time as\n     * {@link DeviceAdminReceiver#ACTION_PROFILE_PROVISIONING_COMPLETE} broadcast but this will be\n     * delivered faster as it's an activity intent.\n     *\n     * <p>The intent is only sent to the new device or profile owner.\n     *\n     * @see #ACTION_PROVISION_MANAGED_PROFILE\n     * @see #ACTION_PROVISION_MANAGED_DEVICE\n     ",
    "links" : [ "DeviceAdminReceiver#ACTION_PROFILE_PROVISIONING_COMPLETE" ]
  }, {
    "name" : "EXTRA_PROVISIONING_SKIP_ENCRYPTION",
    "type" : "String",
    "comment" : "\n     * A boolean extra indicating whether device encryption can be skipped as part of device owner\n     * or managed profile provisioning.\n     *\n     * <p>Use in an NFC record with {@link #MIME_TYPE_PROVISIONING_NFC} or an intent with action\n     * {@link #ACTION_PROVISION_MANAGED_DEVICE} that starts device owner provisioning.\n     *\n     * <p>From {@link android.os.Build.VERSION_CODES#N} onwards, this is also supported for an\n     * intent with action {@link #ACTION_PROVISION_MANAGED_PROFILE}.\n     ",
    "links" : [ "#MIME_TYPE_PROVISIONING_NFC", "#ACTION_PROVISION_MANAGED_DEVICE", "android.os.Build.VERSION_CODES#N", "#ACTION_PROVISION_MANAGED_PROFILE" ]
  }, {
    "name" : "EXTRA_PROVISIONING_LOGO_URI",
    "type" : "String",
    "comment" : "\n     * A {@link Uri} extra pointing to a logo image. This image will be shown during the\n     * provisioning. If this extra is not passed, a default image will be shown.\n     * <h5>The following URI schemes are accepted:</h5>\n     * <ul>\n     * <li>content ({@link android.content.ContentResolver#SCHEME_CONTENT})</li>\n     * <li>android.resource ({@link android.content.ContentResolver#SCHEME_ANDROID_RESOURCE})</li>\n     * </ul>\n     *\n     * <p> It is the responsibility of the caller to provide an image with a reasonable\n     * pixel density for the device.\n     *\n     * <p> If a content: URI is passed, the intent should have the flag\n     * {@link Intent#FLAG_GRANT_READ_URI_PERMISSION} and the uri should be added to the\n     * {@link android.content.ClipData} of the intent too.\n     *\n     * <p>Use in an intent with action {@link #ACTION_PROVISION_MANAGED_PROFILE} or\n     * {@link #ACTION_PROVISION_MANAGED_DEVICE}\n     ",
    "links" : [ "Uri", "android.content.ContentResolver#SCHEME_CONTENT", "android.content.ContentResolver#SCHEME_ANDROID_RESOURCE", "Intent#FLAG_GRANT_READ_URI_PERMISSION", "android.content.ClipData", "#ACTION_PROVISION_MANAGED_PROFILE", "#ACTION_PROVISION_MANAGED_DEVICE" ]
  }, {
    "name" : "EXTRA_PROVISIONING_DISCLAIMERS",
    "type" : "String",
    "comment" : "\n     * A {@link Bundle}[] extra consisting of list of disclaimer headers and disclaimer contents.\n     * Each {@link Bundle} must have both {@link #EXTRA_PROVISIONING_DISCLAIMER_HEADER}\n     * as disclaimer header, and {@link #EXTRA_PROVISIONING_DISCLAIMER_CONTENT} as disclaimer\n     * content.\n     *\n     * <p> The extra typically contains one disclaimer from the company of mobile device\n     * management application (MDM), and one disclaimer from the organization.\n     *\n     * <p> Call {@link Bundle#putParcelableArray(String, Parcelable[])} to put the {@link Bundle}[]\n     *\n     * <p> Maximum 3 key-value pairs can be specified. The rest will be ignored.\n     *\n     * <p> Use in an intent with action {@link #ACTION_PROVISION_MANAGED_PROFILE} or\n     * {@link #ACTION_PROVISION_MANAGED_DEVICE}\n     ",
    "links" : [ "Bundle", "Bundle", "#EXTRA_PROVISIONING_DISCLAIMER_HEADER", "#EXTRA_PROVISIONING_DISCLAIMER_CONTENT", "Bundle#putParcelableArray", "Bundle", "#ACTION_PROVISION_MANAGED_PROFILE", "#ACTION_PROVISION_MANAGED_DEVICE" ]
  }, {
    "name" : "EXTRA_PROVISIONING_DISCLAIMER_HEADER",
    "type" : "String",
    "comment" : "\n     * A String extra of localized disclaimer header.\n     *\n     * <p> The extra is typically the company name of mobile device management application (MDM)\n     * or the organization name.\n     *\n     * <p> Use in Bundle {@link #EXTRA_PROVISIONING_DISCLAIMERS}\n     *\n     * <p> System app, i.e. application with {@link ApplicationInfo#FLAG_SYSTEM}, can also insert a\n     * disclaimer by declaring an application-level meta-data in {@code AndroidManifest.xml}.\n     * Must use it with {@link #EXTRA_PROVISIONING_DISCLAIMER_CONTENT}. Here is the example:\n     *\n     * <pre>\n     *  &lt;meta-data\n     *      android:name=\"android.app.extra.PROVISIONING_DISCLAIMER_HEADER\"\n     *      android:resource=\"@string/disclaimer_header\"\n     * /&gt;</pre>\n     ",
    "links" : [ "#EXTRA_PROVISIONING_DISCLAIMERS", "ApplicationInfo#FLAG_SYSTEM", "#EXTRA_PROVISIONING_DISCLAIMER_CONTENT" ]
  }, {
    "name" : "EXTRA_PROVISIONING_DISCLAIMER_CONTENT",
    "type" : "String",
    "comment" : "\n     * A {@link Uri} extra pointing to disclaimer content.\n     *\n     * <h5>The following URI schemes are accepted:</h5>\n     * <ul>\n     * <li>content ({@link android.content.ContentResolver#SCHEME_CONTENT})</li>\n     * <li>android.resource ({@link android.content.ContentResolver#SCHEME_ANDROID_RESOURCE})</li>\n     * </ul>\n     *\n     * <p> Styled text is supported in the disclaimer content. The content is parsed by\n     * {@link android.text.Html#fromHtml(String)} and displayed in a\n     * {@link android.widget.TextView}.\n     *\n     * <p> If a <code>content:</code> URI is passed, URI is passed, the intent should have the flag\n     * {@link Intent#FLAG_GRANT_READ_URI_PERMISSION} and the uri should be added to the\n     * {@link android.content.ClipData} of the intent too.\n     *\n     * <p> Use in Bundle {@link #EXTRA_PROVISIONING_DISCLAIMERS}\n     *\n     * <p> System app, i.e. application with {@link ApplicationInfo#FLAG_SYSTEM}, can also insert a\n     * disclaimer by declaring an application-level meta-data in {@code AndroidManifest.xml}.\n     * Must use it with {@link #EXTRA_PROVISIONING_DISCLAIMER_HEADER}. Here is the example:\n     *\n     * <pre>\n     *  &lt;meta-data\n     *      android:name=\"android.app.extra.PROVISIONING_DISCLAIMER_CONTENT\"\n     *      android:resource=\"@string/disclaimer_content\"\n     * /&gt;</pre>\n     ",
    "links" : [ "Uri", "android.content.ContentResolver#SCHEME_CONTENT", "android.content.ContentResolver#SCHEME_ANDROID_RESOURCE", "android.text.Html#fromHtml", "android.widget.TextView", "Intent#FLAG_GRANT_READ_URI_PERMISSION", "android.content.ClipData", "#EXTRA_PROVISIONING_DISCLAIMERS", "ApplicationInfo#FLAG_SYSTEM", "#EXTRA_PROVISIONING_DISCLAIMER_HEADER" ]
  }, {
    "name" : "EXTRA_PROVISIONING_SKIP_USER_SETUP",
    "type" : "String",
    "comment" : "\n     * A boolean extra indicating if user setup should be skipped, for when provisioning is started\n     * during setup-wizard.\n     *\n     * <p>If unspecified, defaults to {@code true} to match the behavior in\n     * {@link android.os.Build.VERSION_CODES#M} and earlier.\n     *\n     * <p>Use in an intent with action {@link #ACTION_PROVISION_MANAGED_DEVICE} or\n     * {@link #ACTION_PROVISION_MANAGED_USER}.\n     *\n     * @hide\n     ",
    "links" : [ "android.os.Build.VERSION_CODES#M", "#ACTION_PROVISION_MANAGED_DEVICE", "#ACTION_PROVISION_MANAGED_USER" ]
  }, {
    "name" : "EXTRA_PROVISIONING_SKIP_USER_CONSENT",
    "type" : "String",
    "comment" : "\n     * A boolean extra indicating if the user consent steps from the provisioning flow should be\n     * skipped. If unspecified, defaults to {@code false}.\n     *\n     * It can only be used by an existing device owner trying to create a managed profile via\n     * {@link #ACTION_PROVISION_MANAGED_PROFILE}. Otherwise it is ignored.\n     ",
    "links" : [ "#ACTION_PROVISION_MANAGED_PROFILE" ]
  }, {
    "name" : "EXTRA_PROVISIONING_SKIP_EDUCATION_SCREENS",
    "type" : "String",
    "comment" : "\n     * A boolean extra indicating if the education screens from the provisioning flow should be\n     * skipped. If unspecified, defaults to {@code false}.\n     *\n     * <p>This extra can be set in the following ways:\n     * <ul>\n     * <li>By the admin app when performing the admin-integrated\n     * provisioning flow as a result of the {@link #ACTION_GET_PROVISIONING_MODE} activity</li>\n     * <li>With intent action {@link #ACTION_PROVISION_MANAGED_DEVICE}</li>\n     * </ul>\n     *\n     * <p>If the education screens are skipped, it is the admin application's responsibility\n     * to display its own user education screens.\n     ",
    "links" : [ "#ACTION_GET_PROVISIONING_MODE", "#ACTION_PROVISION_MANAGED_DEVICE" ]
  }, {
    "name" : "EXTRA_PROVISIONING_USE_MOBILE_DATA",
    "type" : "String",
    "comment" : "\n     * A boolean extra indicating if mobile data should be used during NFC device owner provisioning\n     * for downloading the mobile device management application. If {@link\n     * #EXTRA_PROVISIONING_WIFI_SSID} is also specified, wifi network will be used instead.\n     *\n     * <p>Use in an NFC record with {@link #MIME_TYPE_PROVISIONING_NFC} that starts device owner\n     * provisioning via an NFC bump.\n     *\n     * @hide\n     ",
    "links" : [ "#MIME_TYPE_PROVISIONING_NFC" ]
  }, {
    "name" : "EXTRA_PROVISIONING_TRIGGER",
    "type" : "String",
    "comment" : "\n     * A String extra holding the provisioning trigger. It could be one of\n     * {@link #PROVISIONING_TRIGGER_CLOUD_ENROLLMENT}, {@link #PROVISIONING_TRIGGER_QR_CODE},\n     * {@link #PROVISIONING_TRIGGER_PERSISTENT_DEVICE_OWNER} or {@link\n     * #PROVISIONING_TRIGGER_UNSPECIFIED}.\n     *\n     * <p>Use in an intent with action {@link\n     * #ACTION_PROVISION_MANAGED_DEVICE_FROM_TRUSTED_SOURCE}.\n     * @hide\n     ",
    "links" : [ "#PROVISIONING_TRIGGER_CLOUD_ENROLLMENT", "#PROVISIONING_TRIGGER_QR_CODE", "#PROVISIONING_TRIGGER_PERSISTENT_DEVICE_OWNER" ]
  }, {
    "name" : "PROVISIONING_TRIGGER_UNSPECIFIED",
    "type" : "int",
    "comment" : "\n     * A value for {@link #EXTRA_PROVISIONING_TRIGGER} indicating that the provisioning\n     * trigger has not been specified.\n     * @see #PROVISIONING_TRIGGER_CLOUD_ENROLLMENT\n     * @see #PROVISIONING_TRIGGER_QR_CODE\n     * @see #PROVISIONING_TRIGGER_PERSISTENT_DEVICE_OWNER\n     * @hide\n     ",
    "links" : [ "#EXTRA_PROVISIONING_TRIGGER" ]
  }, {
    "name" : "PROVISIONING_TRIGGER_CLOUD_ENROLLMENT",
    "type" : "int",
    "comment" : "\n     * A value for {@link #EXTRA_PROVISIONING_TRIGGER} indicating that the provisioning\n     * trigger is cloud enrollment.\n     * @see #PROVISIONING_TRIGGER_QR_CODE\n     * @see #PROVISIONING_TRIGGER_PERSISTENT_DEVICE_OWNER\n     * @see #PROVISIONING_TRIGGER_UNSPECIFIED\n     * @hide\n     ",
    "links" : [ "#EXTRA_PROVISIONING_TRIGGER" ]
  }, {
    "name" : "PROVISIONING_TRIGGER_QR_CODE",
    "type" : "int",
    "comment" : "\n     * A value for {@link #EXTRA_PROVISIONING_TRIGGER} indicating that the provisioning\n     * trigger is the QR code scanner.\n     * @see #PROVISIONING_TRIGGER_CLOUD_ENROLLMENT\n     * @see #PROVISIONING_TRIGGER_PERSISTENT_DEVICE_OWNER\n     * @see #PROVISIONING_TRIGGER_UNSPECIFIED\n     * @hide\n     ",
    "links" : [ "#EXTRA_PROVISIONING_TRIGGER" ]
  }, {
    "name" : "PROVISIONING_TRIGGER_PERSISTENT_DEVICE_OWNER",
    "type" : "int",
    "comment" : "\n     * A value for {@link #EXTRA_PROVISIONING_TRIGGER} indicating that the provisioning\n     * trigger is persistent device owner enrollment.\n     * @see #PROVISIONING_TRIGGER_CLOUD_ENROLLMENT\n     * @see #PROVISIONING_TRIGGER_QR_CODE\n     * @see #PROVISIONING_TRIGGER_UNSPECIFIED\n     * @hide\n     ",
    "links" : [ "#EXTRA_PROVISIONING_TRIGGER" ]
  }, {
    "name" : "MIME_TYPE_PROVISIONING_NFC",
    "type" : "String",
    "comment" : "\n     * This MIME type is used for starting the device owner provisioning.\n     *\n     * <p>During device owner provisioning a device admin app is set as the owner of the device.\n     * A device owner has full control over the device. The device owner can not be modified by the\n     * user and the only way of resetting the device is if the device owner app calls a factory\n     * reset.\n     *\n     * <p> A typical use case would be a device that is owned by a company, but used by either an\n     * employee or client.\n     *\n     * <p> The NFC message must be sent to an unprovisioned device.\n     *\n     * <p>The NFC record must contain a serialized {@link java.util.Properties} object which\n     * contains the following properties:\n     * <ul>\n     * <li>{@link #EXTRA_PROVISIONING_DEVICE_ADMIN_PACKAGE_NAME}</li>\n     * <li>{@link #EXTRA_PROVISIONING_DEVICE_ADMIN_PACKAGE_DOWNLOAD_LOCATION}, optional</li>\n     * <li>{@link #EXTRA_PROVISIONING_DEVICE_ADMIN_PACKAGE_DOWNLOAD_COOKIE_HEADER}, optional</li>\n     * <li>{@link #EXTRA_PROVISIONING_DEVICE_ADMIN_PACKAGE_CHECKSUM}, optional</li>\n     * <li>{@link #EXTRA_PROVISIONING_LOCAL_TIME} (convert to String), optional</li>\n     * <li>{@link #EXTRA_PROVISIONING_TIME_ZONE}, optional</li>\n     * <li>{@link #EXTRA_PROVISIONING_LOCALE}, optional</li>\n     * <li>{@link #EXTRA_PROVISIONING_WIFI_SSID}, optional</li>\n     * <li>{@link #EXTRA_PROVISIONING_WIFI_HIDDEN} (convert to String), optional</li>\n     * <li>{@link #EXTRA_PROVISIONING_WIFI_SECURITY_TYPE}, optional</li>\n     * <li>{@link #EXTRA_PROVISIONING_WIFI_PASSWORD}, optional</li>\n     * <li>{@link #EXTRA_PROVISIONING_WIFI_PROXY_HOST}, optional</li>\n     * <li>{@link #EXTRA_PROVISIONING_WIFI_PROXY_PORT} (convert to String), optional</li>\n     * <li>{@link #EXTRA_PROVISIONING_WIFI_PROXY_BYPASS}, optional</li>\n     * <li>{@link #EXTRA_PROVISIONING_WIFI_PAC_URL}, optional</li>\n     * <li>{@link #EXTRA_PROVISIONING_ADMIN_EXTRAS_BUNDLE}, optional, supported from {@link\n     * android.os.Build.VERSION_CODES#M} </li>\n     * <li>{@link #EXTRA_PROVISIONING_WIFI_EAP_METHOD}, optional, supported from {@link\n     * android.os.Build.VERSION_CODES#Q}</li>\n     * <li>{@link #EXTRA_PROVISIONING_WIFI_PHASE2_AUTH}, optional, supported from {@link\n     * android.os.Build.VERSION_CODES#Q}</li>\n     * <li>{@link #EXTRA_PROVISIONING_WIFI_CA_CERTIFICATE}, optional, supported from {@link\n     * android.os.Build.VERSION_CODES#Q}</li>\n     * <li>{@link #EXTRA_PROVISIONING_WIFI_USER_CERTIFICATE}, optional, supported from {@link\n     * android.os.Build.VERSION_CODES#Q}</li>\n     * <li>{@link #EXTRA_PROVISIONING_WIFI_IDENTITY}, optional, supported from {@link\n     * android.os.Build.VERSION_CODES#Q}</li>\n     * <li>{@link #EXTRA_PROVISIONING_WIFI_ANONYMOUS_IDENTITY}, optional, supported from {@link\n     * android.os.Build.VERSION_CODES#Q}</li>\n     * <li>{@link #EXTRA_PROVISIONING_WIFI_DOMAIN}, optional, supported from {@link\n     * android.os.Build.VERSION_CODES#Q}</li></ul>\n     *\n     * <p>\n     * As of {@link android.os.Build.VERSION_CODES#M}, the properties should contain\n     * {@link #EXTRA_PROVISIONING_DEVICE_ADMIN_COMPONENT_NAME} instead of\n     * {@link #EXTRA_PROVISIONING_DEVICE_ADMIN_PACKAGE_NAME}, (although specifying only\n     * {@link #EXTRA_PROVISIONING_DEVICE_ADMIN_PACKAGE_NAME} is still supported).\n     ",
    "links" : [ "java.util.Properties", "#EXTRA_PROVISIONING_DEVICE_ADMIN_PACKAGE_NAME", "#EXTRA_PROVISIONING_DEVICE_ADMIN_PACKAGE_DOWNLOAD_LOCATION", "#EXTRA_PROVISIONING_DEVICE_ADMIN_PACKAGE_DOWNLOAD_COOKIE_HEADER", "#EXTRA_PROVISIONING_DEVICE_ADMIN_PACKAGE_CHECKSUM", "#EXTRA_PROVISIONING_LOCAL_TIME", "#EXTRA_PROVISIONING_TIME_ZONE", "#EXTRA_PROVISIONING_LOCALE", "#EXTRA_PROVISIONING_WIFI_SSID", "#EXTRA_PROVISIONING_WIFI_HIDDEN", "#EXTRA_PROVISIONING_WIFI_SECURITY_TYPE", "#EXTRA_PROVISIONING_WIFI_PASSWORD", "#EXTRA_PROVISIONING_WIFI_PROXY_HOST", "#EXTRA_PROVISIONING_WIFI_PROXY_PORT", "#EXTRA_PROVISIONING_WIFI_PROXY_BYPASS", "#EXTRA_PROVISIONING_WIFI_PAC_URL", "#EXTRA_PROVISIONING_ADMIN_EXTRAS_BUNDLE", "#EXTRA_PROVISIONING_WIFI_EAP_METHOD", "#EXTRA_PROVISIONING_WIFI_PHASE2_AUTH", "#EXTRA_PROVISIONING_WIFI_CA_CERTIFICATE", "#EXTRA_PROVISIONING_WIFI_USER_CERTIFICATE", "#EXTRA_PROVISIONING_WIFI_IDENTITY", "#EXTRA_PROVISIONING_WIFI_ANONYMOUS_IDENTITY", "#EXTRA_PROVISIONING_WIFI_DOMAIN", "android.os.Build.VERSION_CODES#M", "#EXTRA_PROVISIONING_DEVICE_ADMIN_COMPONENT_NAME", "#EXTRA_PROVISIONING_DEVICE_ADMIN_PACKAGE_NAME", "#EXTRA_PROVISIONING_DEVICE_ADMIN_PACKAGE_NAME" ]
  }, {
    "name" : "ACTION_ADD_DEVICE_ADMIN",
    "type" : "String",
    "comment" : "\n     * Activity action: ask the user to add a new device administrator to the system.\n     * The desired policy is the ComponentName of the policy in the\n     * {@link #EXTRA_DEVICE_ADMIN} extra field.  This will invoke a UI to\n     * bring the user through adding the device administrator to the system (or\n     * allowing them to reject it).\n     *\n     * <p>You can optionally include the {@link #EXTRA_ADD_EXPLANATION}\n     * field to provide the user with additional explanation (in addition\n     * to your component's description) about what is being added.\n     *\n     * <p>If your administrator is already active, this will ordinarily return immediately (without\n     * user intervention).  However, if your administrator has been updated and is requesting\n     * additional uses-policy flags, the user will be presented with the new list.  New policies\n     * will not be available to the updated administrator until the user has accepted the new list.\n     ",
    "links" : [ "#EXTRA_DEVICE_ADMIN", "#EXTRA_ADD_EXPLANATION" ]
  }, {
    "name" : "ACTION_SET_PROFILE_OWNER",
    "type" : "String",
    "comment" : "\n     * @hide\n     * Activity action: ask the user to add a new device administrator as the profile owner\n     * for this user. Only system apps can launch this intent.\n     *\n     * <p>The ComponentName of the profile owner admin is passed in the {@link #EXTRA_DEVICE_ADMIN}\n     * extra field. This will invoke a UI to bring the user through adding the profile owner admin\n     * to remotely control restrictions on the user.\n     *\n     * <p>The intent must be invoked via {@link Activity#startActivityForResult} to receive the\n     * result of whether or not the user approved the action. If approved, the result will\n     * be {@link Activity#RESULT_OK} and the component will be set as an active admin as well\n     * as a profile owner.\n     *\n     * <p>You can optionally include the {@link #EXTRA_ADD_EXPLANATION}\n     * field to provide the user with additional explanation (in addition\n     * to your component's description) about what is being added.\n     *\n     * <p>If there is already a profile owner active or the caller is not a system app, the\n     * operation will return a failure result.\n     ",
    "links" : [ "#EXTRA_DEVICE_ADMIN", "Activity#startActivityForResult", "Activity#RESULT_OK", "#EXTRA_ADD_EXPLANATION" ]
  }, {
    "name" : "EXTRA_PROFILE_OWNER_NAME",
    "type" : "String",
    "comment" : "\n     * @hide\n     * Name of the profile owner admin that controls the user.\n     ",
    "links" : [ ]
  }, {
    "name" : "ACTION_DEVICE_POLICY_MANAGER_STATE_CHANGED",
    "type" : "String",
    "comment" : "\n     * Broadcast action: send when any policy admin changes a policy.\n     * This is generally used to find out when a new policy is in effect.\n     *\n     * If the profile owner of an organization-owned managed profile changes some user\n     * restriction explicitly on the parent user, this broadcast will <em>not</em> be\n     * sent to the parent user.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "ACTION_DEVICE_OWNER_CHANGED",
    "type" : "String",
    "comment" : "\n     * Broadcast action: sent when the device owner is set, changed or cleared.\n     *\n     * This broadcast is sent only to the primary user.\n     * @see #ACTION_PROVISION_MANAGED_DEVICE\n     * @see DevicePolicyManager#transferOwnership(ComponentName, ComponentName, PersistableBundle)\n     ",
    "links" : [ ]
  }, {
    "name" : "ACTION_RESET_PROTECTION_POLICY_CHANGED",
    "type" : "String",
    "comment" : "\n     * Broadcast action: sent when the factory reset protection (FRP) policy is changed.\n     *\n     * @see #setFactoryResetProtectionPolicy\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "EXTRA_DEVICE_ADMIN",
    "type" : "String",
    "comment" : "\n     * The ComponentName of the administrator component.\n     *\n     * @see #ACTION_ADD_DEVICE_ADMIN\n     ",
    "links" : [ ]
  }, {
    "name" : "EXTRA_ADD_EXPLANATION",
    "type" : "String",
    "comment" : "\n     * An optional CharSequence providing additional explanation for why the\n     * admin is being added.\n     *\n     * @see #ACTION_ADD_DEVICE_ADMIN\n     ",
    "links" : [ ]
  }, {
    "name" : "POLICY_DISABLE_CAMERA",
    "type" : "String",
    "comment" : "\n     * Constant to indicate the feature of disabling the camera. Used as argument to\n     * {@link #createAdminSupportIntent(String)}.\n     * @see #setCameraDisabled(ComponentName, boolean)\n     ",
    "links" : [ "#createAdminSupportIntent" ]
  }, {
    "name" : "POLICY_DISABLE_SCREEN_CAPTURE",
    "type" : "String",
    "comment" : "\n     * Constant to indicate the feature of disabling screen captures. Used as argument to\n     * {@link #createAdminSupportIntent(String)}.\n     * @see #setScreenCaptureDisabled(ComponentName, boolean)\n     ",
    "links" : [ "#createAdminSupportIntent" ]
  }, {
    "name" : "POLICY_SUSPEND_PACKAGES",
    "type" : "String",
    "comment" : "\n     * Constant to indicate the feature of suspending app. Use it as the value of\n     * {@link #EXTRA_RESTRICTION}.\n     * @hide\n     ",
    "links" : [ "#EXTRA_RESTRICTION" ]
  }, {
    "name" : "EXTRA_RESTRICTION",
    "type" : "String",
    "comment" : "\n     * A String indicating a specific restricted feature. Can be a user restriction from the\n     * {@link UserManager}, e.g. {@link UserManager#DISALLOW_ADJUST_VOLUME}, or one of the values\n     * {@link #POLICY_DISABLE_CAMERA} or {@link #POLICY_DISABLE_SCREEN_CAPTURE}.\n     * @see #createAdminSupportIntent(String)\n     * @hide\n     ",
    "links" : [ "UserManager", "UserManager#DISALLOW_ADJUST_VOLUME", "#POLICY_DISABLE_CAMERA", "#POLICY_DISABLE_SCREEN_CAPTURE" ]
  }, {
    "name" : "ACTION_SET_NEW_PASSWORD",
    "type" : "String",
    "comment" : "\n     * Activity action: have the user enter a new password.\n     *\n     * <p>For admin apps, this activity should be launched after using {@link\n     * #setPasswordQuality(ComponentName, int)}, or {@link\n     * #setPasswordMinimumLength(ComponentName, int)} to have the user enter a new password that\n     * meets the current requirements. You can use {@link #isActivePasswordSufficient()} to\n     * determine whether you need to have the user select a new password in order to meet the\n     * current constraints. Upon being resumed from this activity, you can check the new\n     * password characteristics to see if they are sufficient.\n     *\n     * <p>Non-admin apps can use {@link #getPasswordComplexity()} to check the current screen lock\n     * complexity, and use this activity with extra {@link #EXTRA_PASSWORD_COMPLEXITY} to suggest\n     * to users how complex the app wants the new screen lock to be. Note that both {@link\n     * #getPasswordComplexity()} and the extra {@link #EXTRA_PASSWORD_COMPLEXITY} require the\n     * calling app to have the permission {@link permission#REQUEST_PASSWORD_COMPLEXITY}.\n     *\n     * <p>If the intent is launched from within a managed profile with a profile\n     * owner built against {@link android.os.Build.VERSION_CODES#M} or before,\n     * this will trigger entering a new password for the parent of the profile.\n     * For all other cases it will trigger entering a new password for the user\n     * or profile it is launched from.\n     *\n     * @see #ACTION_SET_NEW_PARENT_PROFILE_PASSWORD\n     ",
    "links" : [ "#isActivePasswordSufficient", "#getPasswordComplexity", "#EXTRA_PASSWORD_COMPLEXITY", "#EXTRA_PASSWORD_COMPLEXITY", "permission#REQUEST_PASSWORD_COMPLEXITY", "android.os.Build.VERSION_CODES#M" ]
  }, {
    "name" : "EXTRA_PASSWORD_COMPLEXITY",
    "type" : "String",
    "comment" : "\n     * An integer indicating the complexity level of the new password an app would like the user to\n     * set when launching the action {@link #ACTION_SET_NEW_PASSWORD}.\n     *\n     * <p>Must be one of\n     * <ul>\n     *     <li>{@link #PASSWORD_COMPLEXITY_HIGH}\n     *     <li>{@link #PASSWORD_COMPLEXITY_MEDIUM}\n     *     <li>{@link #PASSWORD_COMPLEXITY_LOW}\n     *     <li>{@link #PASSWORD_COMPLEXITY_NONE}\n     * </ul>\n     *\n     * <p>If an invalid value is used, it will be treated as {@link #PASSWORD_COMPLEXITY_NONE}.\n     ",
    "links" : [ "#ACTION_SET_NEW_PASSWORD", "#PASSWORD_COMPLEXITY_HIGH", "#PASSWORD_COMPLEXITY_MEDIUM", "#PASSWORD_COMPLEXITY_LOW", "#PASSWORD_COMPLEXITY_NONE", "#PASSWORD_COMPLEXITY_NONE" ]
  }, {
    "name" : "PASSWORD_COMPLEXITY_NONE",
    "type" : "int",
    "comment" : "\n     * Constant for {@link #getPasswordComplexity()}: no password.\n     *\n     * <p>Note that these complexity constants are ordered so that higher values are more complex.\n     ",
    "links" : [ "#getPasswordComplexity" ]
  }, {
    "name" : "PASSWORD_COMPLEXITY_LOW",
    "type" : "int",
    "comment" : "\n     * Constant for {@link #getPasswordComplexity()}: password satisfies one of the following:\n     * <ul>\n     * <li>pattern\n     * <li>PIN with repeating (4444) or ordered (1234, 4321, 2468) sequences\n     * </ul>\n     *\n     * <p>Note that these complexity constants are ordered so that higher values are more complex.\n     *\n     * @see #PASSWORD_QUALITY_SOMETHING\n     * @see #PASSWORD_QUALITY_NUMERIC\n     ",
    "links" : [ "#getPasswordComplexity" ]
  }, {
    "name" : "PASSWORD_COMPLEXITY_MEDIUM",
    "type" : "int",
    "comment" : "\n     * Constant for {@link #getPasswordComplexity()}: password satisfies one of the following:\n     * <ul>\n     * <li>PIN with <b>no</b> repeating (4444) or ordered (1234, 4321, 2468) sequences, length at\n     * least 4\n     * <li>alphabetic, length at least 4\n     * <li>alphanumeric, length at least 4\n     * </ul>\n     *\n     * <p>Note that these complexity constants are ordered so that higher values are more complex.\n     *\n     * @see #PASSWORD_QUALITY_NUMERIC_COMPLEX\n     * @see #PASSWORD_QUALITY_ALPHABETIC\n     * @see #PASSWORD_QUALITY_ALPHANUMERIC\n     ",
    "links" : [ "#getPasswordComplexity" ]
  }, {
    "name" : "PASSWORD_COMPLEXITY_HIGH",
    "type" : "int",
    "comment" : "\n     * Constant for {@link #getPasswordComplexity()}: password satisfies one of the following:\n     * <ul>\n     * <li>PIN with <b>no</b> repeating (4444) or ordered (1234, 4321, 2468) sequences, length at\n     * least 8\n     * <li>alphabetic, length at least 6\n     * <li>alphanumeric, length at least 6\n     * </ul>\n     *\n     * <p>Note that these complexity constants are ordered so that higher values are more complex.\n     *\n     * @see #PASSWORD_QUALITY_NUMERIC_COMPLEX\n     * @see #PASSWORD_QUALITY_ALPHABETIC\n     * @see #PASSWORD_QUALITY_ALPHANUMERIC\n     ",
    "links" : [ "#getPasswordComplexity" ]
  }, {
    "name" : "ACTION_SET_NEW_PARENT_PROFILE_PASSWORD",
    "type" : "String",
    "comment" : "\n     * Activity action: have the user enter a new password for the parent profile.\n     * If the intent is launched from within a managed profile, this will trigger\n     * entering a new password for the parent of the profile. In all other cases\n     * the behaviour is identical to {@link #ACTION_SET_NEW_PASSWORD}.\n     ",
    "links" : [ "#ACTION_SET_NEW_PASSWORD" ]
  }, {
    "name" : "ACTION_SHOW_DEVICE_MONITORING_DIALOG",
    "type" : "String",
    "comment" : "\n     * Broadcast action: Tell the status bar to open the device monitoring dialog, e.g. when\n     * Network logging was enabled and the user tapped the notification.\n     * <p class=\"note\">This is a protected intent that can only be sent by the system.</p>\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "ACTION_APPLICATION_DELEGATION_SCOPES_CHANGED",
    "type" : "String",
    "comment" : "\n     * Broadcast Action: Sent after application delegation scopes are changed. The new delegation\n     * scopes will be sent in an {@code ArrayList<String>} extra identified by the\n     * {@link #EXTRA_DELEGATION_SCOPES} key.\n     *\n     * <p class=\"note\"><b>Note:</b> This is a protected intent that can only be sent by the\n     * system.</p>\n     ",
    "links" : [ "#EXTRA_DELEGATION_SCOPES" ]
  }, {
    "name" : "EXTRA_DELEGATION_SCOPES",
    "type" : "String",
    "comment" : "\n     * An {@code ArrayList<String>} corresponding to the delegation scopes given to an app in the\n     * {@link #ACTION_APPLICATION_DELEGATION_SCOPES_CHANGED} broadcast.\n     ",
    "links" : [ "#ACTION_APPLICATION_DELEGATION_SCOPES_CHANGED" ]
  }, {
    "name" : "FLAG_PARENT_CAN_ACCESS_MANAGED",
    "type" : "int",
    "comment" : "\n     * Flag used by {@link #addCrossProfileIntentFilter} to allow activities in\n     * the parent profile to access intents sent from the managed profile.\n     * That is, when an app in the managed profile calls\n     * {@link Activity#startActivity(Intent)}, the intent can be resolved by a\n     * matching activity in the parent profile.\n     ",
    "links" : [ "#addCrossProfileIntentFilter", "Activity#startActivity" ]
  }, {
    "name" : "FLAG_MANAGED_CAN_ACCESS_PARENT",
    "type" : "int",
    "comment" : "\n     * Flag used by {@link #addCrossProfileIntentFilter} to allow activities in\n     * the managed profile to access intents sent from the parent profile.\n     * That is, when an app in the parent profile calls\n     * {@link Activity#startActivity(Intent)}, the intent can be resolved by a\n     * matching activity in the managed profile.\n     ",
    "links" : [ "#addCrossProfileIntentFilter", "Activity#startActivity" ]
  }, {
    "name" : "ACTION_SYSTEM_UPDATE_POLICY_CHANGED",
    "type" : "String",
    "comment" : "\n     * Broadcast action: notify that a new local system update policy has been set by the device\n     * owner. The new policy can be retrieved by {@link #getSystemUpdatePolicy()}.\n     ",
    "links" : [ "#getSystemUpdatePolicy" ]
  }, {
    "name" : "ACTION_DATA_SHARING_RESTRICTION_CHANGED",
    "type" : "String",
    "comment" : "\n     * Broadcast action to notify ManagedProvisioning that\n     * {@link UserManager#DISALLOW_SHARE_INTO_MANAGED_PROFILE} restriction has changed.\n     * @hide\n     ",
    "links" : [ "UserManager#DISALLOW_SHARE_INTO_MANAGED_PROFILE" ]
  }, {
    "name" : "ACTION_DATA_SHARING_RESTRICTION_APPLIED",
    "type" : "String",
    "comment" : "\n     * Broadcast action from ManagedProvisioning to notify that the latest change to\n     * {@link UserManager#DISALLOW_SHARE_INTO_MANAGED_PROFILE} restriction has been successfully\n     * applied (cross profile intent filters updated). Only usesd for CTS tests.\n     * @hide\n     ",
    "links" : [ "UserManager#DISALLOW_SHARE_INTO_MANAGED_PROFILE" ]
  }, {
    "name" : "PERMISSION_POLICY_PROMPT",
    "type" : "int",
    "comment" : "\n     * Permission policy to prompt user for new permission requests for runtime permissions.\n     * Already granted or denied permissions are not affected by this.\n     ",
    "links" : [ ]
  }, {
    "name" : "PERMISSION_POLICY_AUTO_GRANT",
    "type" : "int",
    "comment" : "\n     * Permission policy to always grant new permission requests for runtime permissions.\n     * Already granted or denied permissions are not affected by this.\n     ",
    "links" : [ ]
  }, {
    "name" : "PERMISSION_POLICY_AUTO_DENY",
    "type" : "int",
    "comment" : "\n     * Permission policy to always deny new permission requests for runtime permissions.\n     * Already granted or denied permissions are not affected by this.\n     ",
    "links" : [ ]
  }, {
    "name" : "PERMISSION_GRANT_STATE_DEFAULT",
    "type" : "int",
    "comment" : "\n     * Runtime permission state: The user can manage the permission\n     * through the UI.\n     ",
    "links" : [ ]
  }, {
    "name" : "PERMISSION_GRANT_STATE_GRANTED",
    "type" : "int",
    "comment" : "\n     * Runtime permission state: The permission is granted to the app\n     * and the user cannot manage the permission through the UI.\n     ",
    "links" : [ ]
  }, {
    "name" : "PERMISSION_GRANT_STATE_DENIED",
    "type" : "int",
    "comment" : "\n     * Runtime permission state: The permission is denied to the app\n     * and the user cannot manage the permission through the UI.\n     ",
    "links" : [ ]
  }, {
    "name" : "DELEGATION_CERT_INSTALL",
    "type" : "String",
    "comment" : "\n     * Delegation of certificate installation and management. This scope grants access to the\n     * {@link #getInstalledCaCerts}, {@link #hasCaCertInstalled}, {@link #installCaCert},\n     * {@link #uninstallCaCert}, {@link #uninstallAllUserCaCerts} and {@link #installKeyPair} APIs.\n     ",
    "links" : [ "#getInstalledCaCerts", "#hasCaCertInstalled", "#installCaCert", "#uninstallCaCert", "#uninstallAllUserCaCerts", "#installKeyPair" ]
  }, {
    "name" : "DELEGATION_APP_RESTRICTIONS",
    "type" : "String",
    "comment" : "\n     * Delegation of application restrictions management. This scope grants access to the\n     * {@link #setApplicationRestrictions} and {@link #getApplicationRestrictions} APIs.\n     ",
    "links" : [ "#setApplicationRestrictions", "#getApplicationRestrictions" ]
  }, {
    "name" : "DELEGATION_BLOCK_UNINSTALL",
    "type" : "String",
    "comment" : "\n     * Delegation of application uninstall block. This scope grants access to the\n     * {@link #setUninstallBlocked} API.\n     ",
    "links" : [ "#setUninstallBlocked" ]
  }, {
    "name" : "DELEGATION_PERMISSION_GRANT",
    "type" : "String",
    "comment" : "\n     * Delegation of permission policy and permission grant state. This scope grants access to the\n     * {@link #setPermissionPolicy}, {@link #getPermissionGrantState},\n     * and {@link #setPermissionGrantState} APIs.\n     ",
    "links" : [ "#setPermissionPolicy", "#getPermissionGrantState", "#setPermissionGrantState" ]
  }, {
    "name" : "DELEGATION_PACKAGE_ACCESS",
    "type" : "String",
    "comment" : "\n     * Delegation of package access state. This scope grants access to the\n     * {@link #isApplicationHidden}, {@link #setApplicationHidden}, {@link #isPackageSuspended}, and\n     * {@link #setPackagesSuspended} APIs.\n     ",
    "links" : [ "#isApplicationHidden", "#setApplicationHidden", "#isPackageSuspended", "#setPackagesSuspended" ]
  }, {
    "name" : "DELEGATION_ENABLE_SYSTEM_APP",
    "type" : "String",
    "comment" : "\n     * Delegation for enabling system apps. This scope grants access to the {@link #enableSystemApp}\n     * API.\n     ",
    "links" : [ "#enableSystemApp" ]
  }, {
    "name" : "DELEGATION_INSTALL_EXISTING_PACKAGE",
    "type" : "String",
    "comment" : "\n     * Delegation for installing existing packages. This scope grants access to the\n     * {@link #installExistingPackage} API.\n     ",
    "links" : [ "#installExistingPackage" ]
  }, {
    "name" : "DELEGATION_KEEP_UNINSTALLED_PACKAGES",
    "type" : "String",
    "comment" : "\n     * Delegation of management of uninstalled packages. This scope grants access to the\n     * {@link #setKeepUninstalledPackages} and {@link #getKeepUninstalledPackages} APIs.\n     ",
    "links" : [ "#setKeepUninstalledPackages", "#getKeepUninstalledPackages" ]
  }, {
    "name" : "DELEGATION_NETWORK_LOGGING",
    "type" : "String",
    "comment" : "\n     * Grants access to {@link #setNetworkLoggingEnabled}, {@link #isNetworkLoggingEnabled} and\n     * {@link #retrieveNetworkLogs}. Once granted the delegated app will start receiving\n     * DelegatedAdminReceiver.onNetworkLogsAvailable() callback, and Device owner will no longer\n     * receive the DeviceAdminReceiver.onNetworkLogsAvailable() callback.\n     * There can be at most one app that has this delegation.\n     * If another app already had delegated network logging access,\n     * it will lose the delegation when a new app is delegated.\n     *\n     * <p> Can only be granted by Device Owner.\n     ",
    "links" : [ "#setNetworkLoggingEnabled", "#isNetworkLoggingEnabled", "#retrieveNetworkLogs" ]
  }, {
    "name" : "DELEGATION_CERT_SELECTION",
    "type" : "String",
    "comment" : "\n     * Grants access to selection of KeyChain certificates on behalf of requesting apps.\n     * Once granted the app will start receiving\n     * {@link DelegatedAdminReceiver#onChoosePrivateKeyAlias}. The caller (PO/DO) will\n     * no longer receive {@link DeviceAdminReceiver#onChoosePrivateKeyAlias}.\n     * There can be at most one app that has this delegation.\n     * If another app already had delegated certificate selection access,\n     * it will lose the delegation when a new app is delegated.\n     * <p> The delegaetd app can also call {@link #grantKeyPairToApp} and\n     * {@link #revokeKeyPairFromApp} to directly grant KeyCain keys to other apps.\n     * <p> Can be granted by Device Owner or Profile Owner.\n     ",
    "links" : [ "DelegatedAdminReceiver#onChoosePrivateKeyAlias", "DeviceAdminReceiver#onChoosePrivateKeyAlias", "#grantKeyPairToApp", "#revokeKeyPairFromApp" ]
  }, {
    "name" : "STATE_USER_UNMANAGED",
    "type" : "int",
    "comment" : "\n     * No management for current user in-effect. This is the default.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "STATE_USER_SETUP_INCOMPLETE",
    "type" : "int",
    "comment" : "\n     * Management partially setup, user setup needs to be completed.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "STATE_USER_SETUP_COMPLETE",
    "type" : "int",
    "comment" : "\n     * Management partially setup, user setup completed.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "STATE_USER_SETUP_FINALIZED",
    "type" : "int",
    "comment" : "\n     * Management setup and active on current user.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "STATE_USER_PROFILE_COMPLETE",
    "type" : "int",
    "comment" : "\n     * Management partially setup on a managed profile.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "CODE_OK",
    "type" : "int",
    "comment" : "\n     * Result code for {@link #checkProvisioningPreCondition}.\n     *\n     * <p>Returned for {@link #ACTION_PROVISION_MANAGED_DEVICE},\n     * {@link #ACTION_PROVISION_MANAGED_PROFILE}, {@link #ACTION_PROVISION_MANAGED_USER} and\n     * {@link #ACTION_PROVISION_MANAGED_SHAREABLE_DEVICE} when provisioning is allowed.\n     *\n     * @hide\n     ",
    "links" : [ "#checkProvisioningPreCondition", "#ACTION_PROVISION_MANAGED_DEVICE", "#ACTION_PROVISION_MANAGED_PROFILE", "#ACTION_PROVISION_MANAGED_USER", "#ACTION_PROVISION_MANAGED_SHAREABLE_DEVICE" ]
  }, {
    "name" : "CODE_HAS_DEVICE_OWNER",
    "type" : "int",
    "comment" : "\n     * Result code for {@link #checkProvisioningPreCondition}.\n     *\n     * <p>Returned for {@link #ACTION_PROVISION_MANAGED_DEVICE} and\n     * {@link #ACTION_PROVISION_MANAGED_SHAREABLE_DEVICE} when the device already has a device\n     * owner.\n     *\n     * @hide\n     ",
    "links" : [ "#checkProvisioningPreCondition", "#ACTION_PROVISION_MANAGED_DEVICE", "#ACTION_PROVISION_MANAGED_SHAREABLE_DEVICE" ]
  }, {
    "name" : "CODE_USER_HAS_PROFILE_OWNER",
    "type" : "int",
    "comment" : "\n     * Result code for {@link #checkProvisioningPreCondition}.\n     *\n     * <p>Returned for {@link #ACTION_PROVISION_MANAGED_DEVICE},\n     * {@link #ACTION_PROVISION_MANAGED_SHAREABLE_DEVICE} when the user has a profile owner and for\n     * {@link #ACTION_PROVISION_MANAGED_PROFILE} when the profile owner is already set.\n     *\n     * @hide\n     ",
    "links" : [ "#checkProvisioningPreCondition", "#ACTION_PROVISION_MANAGED_DEVICE", "#ACTION_PROVISION_MANAGED_SHAREABLE_DEVICE", "#ACTION_PROVISION_MANAGED_PROFILE" ]
  }, {
    "name" : "CODE_USER_NOT_RUNNING",
    "type" : "int",
    "comment" : "\n     * Result code for {@link #checkProvisioningPreCondition}.\n     *\n     * <p>Returned for {@link #ACTION_PROVISION_MANAGED_DEVICE} and\n     * {@link #ACTION_PROVISION_MANAGED_SHAREABLE_DEVICE} when the user isn't running.\n     *\n     * @hide\n     ",
    "links" : [ "#checkProvisioningPreCondition", "#ACTION_PROVISION_MANAGED_DEVICE", "#ACTION_PROVISION_MANAGED_SHAREABLE_DEVICE" ]
  }, {
    "name" : "CODE_USER_SETUP_COMPLETED",
    "type" : "int",
    "comment" : "\n     * Result code for {@link #checkProvisioningPreCondition}.\n     *\n     * <p>Returned for {@link #ACTION_PROVISION_MANAGED_DEVICE},\n     * {@link #ACTION_PROVISION_MANAGED_SHAREABLE_DEVICE} if the device has already been setup and\n     * for {@link #ACTION_PROVISION_MANAGED_USER} if the user has already been setup.\n     *\n     * @hide\n     ",
    "links" : [ "#checkProvisioningPreCondition", "#ACTION_PROVISION_MANAGED_DEVICE", "#ACTION_PROVISION_MANAGED_SHAREABLE_DEVICE", "#ACTION_PROVISION_MANAGED_USER" ]
  }, {
    "name" : "CODE_NONSYSTEM_USER_EXISTS",
    "type" : "int",
    "comment" : "\n     * Code used to indicate that the device also has a user other than the system user.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "CODE_ACCOUNTS_NOT_EMPTY",
    "type" : "int",
    "comment" : "\n     * Code used to indicate that device has an account that prevents provisioning.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "CODE_NOT_SYSTEM_USER",
    "type" : "int",
    "comment" : "\n     * Result code for {@link #checkProvisioningPreCondition}.\n     *\n     * <p>Returned for {@link #ACTION_PROVISION_MANAGED_DEVICE} and\n     * {@link #ACTION_PROVISION_MANAGED_SHAREABLE_DEVICE} if the user is not a system user.\n     *\n     * @hide\n     ",
    "links" : [ "#checkProvisioningPreCondition", "#ACTION_PROVISION_MANAGED_DEVICE", "#ACTION_PROVISION_MANAGED_SHAREABLE_DEVICE" ]
  }, {
    "name" : "CODE_HAS_PAIRED",
    "type" : "int",
    "comment" : "\n     * Result code for {@link #checkProvisioningPreCondition}.\n     *\n     * <p>Returned for {@link #ACTION_PROVISION_MANAGED_DEVICE},\n     * {@link #ACTION_PROVISION_MANAGED_SHAREABLE_DEVICE} and {@link #ACTION_PROVISION_MANAGED_USER}\n     * when the device is a watch and is already paired.\n     *\n     * @hide\n     ",
    "links" : [ "#checkProvisioningPreCondition", "#ACTION_PROVISION_MANAGED_DEVICE", "#ACTION_PROVISION_MANAGED_SHAREABLE_DEVICE", "#ACTION_PROVISION_MANAGED_USER" ]
  }, {
    "name" : "CODE_MANAGED_USERS_NOT_SUPPORTED",
    "type" : "int",
    "comment" : "\n     * Result code for {@link #checkProvisioningPreCondition}.\n     *\n     * <p>Returned for {@link #ACTION_PROVISION_MANAGED_PROFILE} and\n     * {@link #ACTION_PROVISION_MANAGED_USER} on devices which do not support managed users.\n     *\n     * @see {@link PackageManager#FEATURE_MANAGED_USERS}\n     * @hide\n     ",
    "links" : [ "#checkProvisioningPreCondition", "#ACTION_PROVISION_MANAGED_PROFILE", "#ACTION_PROVISION_MANAGED_USER", "PackageManager#FEATURE_MANAGED_USERS" ]
  }, {
    "name" : "CODE_SYSTEM_USER",
    "type" : "int",
    "comment" : "\n     * Result code for {@link #checkProvisioningPreCondition}.\n     *\n     * <p>Returned for {@link #ACTION_PROVISION_MANAGED_USER} if the user is a system user.\n     *\n     * @hide\n     ",
    "links" : [ "#checkProvisioningPreCondition", "#ACTION_PROVISION_MANAGED_USER" ]
  }, {
    "name" : "CODE_CANNOT_ADD_MANAGED_PROFILE",
    "type" : "int",
    "comment" : "\n     * Result code for {@link #checkProvisioningPreCondition}.\n     *\n     * <p>Returned for {@link #ACTION_PROVISION_MANAGED_PROFILE} when the user cannot have more\n     * managed profiles.\n     *\n     * @hide\n     ",
    "links" : [ "#checkProvisioningPreCondition", "#ACTION_PROVISION_MANAGED_PROFILE" ]
  }, {
    "name" : "CODE_NOT_SYSTEM_USER_SPLIT",
    "type" : "int",
    "comment" : "\n     * Result code for {@link #checkProvisioningPreCondition}.\n     *\n     * <p>Returned for {@link #ACTION_PROVISION_MANAGED_USER} and\n     * {@link #ACTION_PROVISION_MANAGED_SHAREABLE_DEVICE} on devices not running with split system\n     * user.\n     *\n     * @hide\n     ",
    "links" : [ "#checkProvisioningPreCondition", "#ACTION_PROVISION_MANAGED_USER", "#ACTION_PROVISION_MANAGED_SHAREABLE_DEVICE" ]
  }, {
    "name" : "CODE_DEVICE_ADMIN_NOT_SUPPORTED",
    "type" : "int",
    "comment" : "\n     * Result code for {@link #checkProvisioningPreCondition}.\n     *\n     * <p>Returned for {@link #ACTION_PROVISION_MANAGED_DEVICE},\n     * {@link #ACTION_PROVISION_MANAGED_PROFILE}, {@link #ACTION_PROVISION_MANAGED_USER} and\n     * {@link #ACTION_PROVISION_MANAGED_SHAREABLE_DEVICE} on devices which do no support device\n     * admins.\n     *\n     * @hide\n     ",
    "links" : [ "#checkProvisioningPreCondition", "#ACTION_PROVISION_MANAGED_DEVICE", "#ACTION_PROVISION_MANAGED_PROFILE", "#ACTION_PROVISION_MANAGED_USER", "#ACTION_PROVISION_MANAGED_SHAREABLE_DEVICE" ]
  }, {
    "name" : "CODE_SPLIT_SYSTEM_USER_DEVICE_SYSTEM_USER",
    "type" : "int",
    "comment" : "\n     * Result code for {@link #checkProvisioningPreCondition}.\n     *\n     * <p>Returned for {@link #ACTION_PROVISION_MANAGED_PROFILE} when the device the user is a\n     * system user on a split system user device.\n     *\n     * @hide\n     ",
    "links" : [ "#checkProvisioningPreCondition", "#ACTION_PROVISION_MANAGED_PROFILE" ]
  }, {
    "name" : "LOCK_TASK_FEATURE_NONE",
    "type" : "int",
    "comment" : "\n     * Disable all configurable SystemUI features during LockTask mode. This includes,\n     * <ul>\n     *     <li>system info area in the status bar (connectivity icons, clock, etc.)\n     *     <li>notifications (including alerts, icons, and the notification shade)\n     *     <li>Home button\n     *     <li>Recents button and UI\n     *     <li>global actions menu (i.e. power button menu)\n     *     <li>keyguard\n     * </ul>\n     *\n     * @see #setLockTaskFeatures(ComponentName, int)\n     ",
    "links" : [ ]
  }, {
    "name" : "LOCK_TASK_FEATURE_SYSTEM_INFO",
    "type" : "int",
    "comment" : "\n     * Enable the system info area in the status bar during LockTask mode. The system info area\n     * usually occupies the right side of the status bar (although this can differ across OEMs). It\n     * includes all system information indicators, such as date and time, connectivity, battery,\n     * vibration mode, etc.\n     *\n     * @see #setLockTaskFeatures(ComponentName, int)\n     ",
    "links" : [ ]
  }, {
    "name" : "LOCK_TASK_FEATURE_NOTIFICATIONS",
    "type" : "int",
    "comment" : "\n     * Enable notifications during LockTask mode. This includes notification icons on the status\n     * bar, heads-up notifications, and the expandable notification shade. Note that the Quick\n     * Settings panel remains disabled. This feature flag can only be used in combination with\n     * {@link #LOCK_TASK_FEATURE_HOME}. {@link #setLockTaskFeatures(ComponentName, int)}\n     * throws an {@link IllegalArgumentException} if this feature flag is defined without\n     * {@link #LOCK_TASK_FEATURE_HOME}.\n     *\n     * @see #setLockTaskFeatures(ComponentName, int)\n     ",
    "links" : [ "#LOCK_TASK_FEATURE_HOME", "#setLockTaskFeatures", "IllegalArgumentException", "#LOCK_TASK_FEATURE_HOME" ]
  }, {
    "name" : "LOCK_TASK_FEATURE_HOME",
    "type" : "int",
    "comment" : "\n     * Enable the Home button during LockTask mode. Note that if a custom launcher is used, it has\n     * to be registered as the default launcher with\n     * {@link #addPersistentPreferredActivity(ComponentName, IntentFilter, ComponentName)}, and its\n     * package needs to be whitelisted for LockTask with\n     * {@link #setLockTaskPackages(ComponentName, String[])}.\n     *\n     * @see #setLockTaskFeatures(ComponentName, int)\n     ",
    "links" : [ "#addPersistentPreferredActivity", "#setLockTaskPackages" ]
  }, {
    "name" : "LOCK_TASK_FEATURE_OVERVIEW",
    "type" : "int",
    "comment" : "\n     * Enable the Overview button and the Overview screen during LockTask mode. This feature flag\n     * can only be used in combination with {@link #LOCK_TASK_FEATURE_HOME}, and\n     * {@link #setLockTaskFeatures(ComponentName, int)} will throw an\n     * {@link IllegalArgumentException} if this feature flag is defined without\n     * {@link #LOCK_TASK_FEATURE_HOME}.\n     *\n     * @see #setLockTaskFeatures(ComponentName, int)\n     ",
    "links" : [ "#LOCK_TASK_FEATURE_HOME", "#setLockTaskFeatures", "IllegalArgumentException", "#LOCK_TASK_FEATURE_HOME" ]
  }, {
    "name" : "LOCK_TASK_FEATURE_GLOBAL_ACTIONS",
    "type" : "int",
    "comment" : "\n     * Enable the global actions dialog during LockTask mode. This is the dialog that shows up when\n     * the user long-presses the power button, for example. Note that the user may not be able to\n     * power off the device if this flag is not set.\n     *\n     * <p>This flag is enabled by default until {@link #setLockTaskFeatures(ComponentName, int)} is\n     * called for the first time.\n     *\n     * @see #setLockTaskFeatures(ComponentName, int)\n     ",
    "links" : [ "#setLockTaskFeatures" ]
  }, {
    "name" : "LOCK_TASK_FEATURE_KEYGUARD",
    "type" : "int",
    "comment" : "\n     * Enable the keyguard during LockTask mode. Note that if the keyguard is already disabled with\n     * {@link #setKeyguardDisabled(ComponentName, boolean)}, setting this flag will have no effect.\n     * If this flag is not set, the keyguard will not be shown even if the user has a lock screen\n     * credential.\n     *\n     * @see #setLockTaskFeatures(ComponentName, int)\n     ",
    "links" : [ "#setKeyguardDisabled" ]
  }, {
    "name" : "LOCK_TASK_FEATURE_BLOCK_ACTIVITY_START_IN_TASK",
    "type" : "int",
    "comment" : "\n     * Enable blocking of non-whitelisted activities from being started into a locked task.\n     *\n     * @see #setLockTaskFeatures(ComponentName, int)\n     ",
    "links" : [ ]
  }, {
    "name" : "ACTION_DEVICE_ADMIN_SERVICE",
    "type" : "String",
    "comment" : "\n     * Service action: Action for a service that device owner and profile owner can optionally\n     * own.  If a device owner or a profile owner has such a service, the system tries to keep\n     * a bound connection to it, in order to keep their process always running.\n     * The service must be protected with the {@link android.Manifest.permission#BIND_DEVICE_ADMIN}\n     * permission.\n     ",
    "links" : [ "android.Manifest.permission#BIND_DEVICE_ADMIN" ]
  }, {
    "name" : "ID_TYPE_BASE_INFO",
    "type" : "int",
    "comment" : "\n     * Specifies that the device should attest its manufacturer details. For use with\n     * {@link #generateKeyPair}.\n     *\n     * @see #generateKeyPair\n     ",
    "links" : [ "#generateKeyPair" ]
  }, {
    "name" : "ID_TYPE_SERIAL",
    "type" : "int",
    "comment" : "\n     * Specifies that the device should attest its serial number. For use with\n     * {@link #generateKeyPair}.\n     *\n     * @see #generateKeyPair\n     ",
    "links" : [ "#generateKeyPair" ]
  }, {
    "name" : "ID_TYPE_IMEI",
    "type" : "int",
    "comment" : "\n     * Specifies that the device should attest its IMEI. For use with {@link #generateKeyPair}.\n     *\n     * @see #generateKeyPair\n     ",
    "links" : [ "#generateKeyPair" ]
  }, {
    "name" : "ID_TYPE_MEID",
    "type" : "int",
    "comment" : "\n     * Specifies that the device should attest its MEID. For use with {@link #generateKeyPair}.\n     *\n     * @see #generateKeyPair\n     ",
    "links" : [ "#generateKeyPair" ]
  }, {
    "name" : "ID_TYPE_INDIVIDUAL_ATTESTATION",
    "type" : "int",
    "comment" : "\n     * Specifies that the device should attest using an individual attestation certificate.\n     * For use with {@link #generateKeyPair}.\n     *\n     * @see #generateKeyPair\n     ",
    "links" : [ "#generateKeyPair" ]
  }, {
    "name" : "KEY_GEN_STRONGBOX_UNAVAILABLE",
    "type" : "int",
    "comment" : "\n     * Service-specific error code for {@link #generateKeyPair}:\n     * Indicates the call has failed due to StrongBox unavailability.\n     * @hide\n     ",
    "links" : [ "#generateKeyPair" ]
  }, {
    "name" : "INSTALLKEY_REQUEST_CREDENTIALS_ACCESS",
    "type" : "int",
    "comment" : "\n     * Specifies that the calling app should be granted access to the installed credentials\n     * immediately. Otherwise, access to the credentials will be gated by user approval.\n     * For use with {@link #installKeyPair(ComponentName, PrivateKey, Certificate[], String, int)}\n     *\n     * @see #installKeyPair(ComponentName, PrivateKey, Certificate[], String, int)\n     ",
    "links" : [ "#installKeyPair" ]
  }, {
    "name" : "INSTALLKEY_SET_USER_SELECTABLE",
    "type" : "int",
    "comment" : "\n     * Specifies that a user can select the key via the Certificate Selection prompt.\n     * If this flag is not set when calling {@link #installKeyPair}, the key can only be granted\n     * access by implementing {@link android.app.admin.DeviceAdminReceiver#onChoosePrivateKeyAlias}.\n     * For use with {@link #installKeyPair(ComponentName, PrivateKey, Certificate[], String, int)}\n     *\n     * @see #installKeyPair(ComponentName, PrivateKey, Certificate[], String, int)\n     ",
    "links" : [ "#installKeyPair", "android.app.admin.DeviceAdminReceiver#onChoosePrivateKeyAlias", "#installKeyPair" ]
  }, {
    "name" : "ACTION_PROFILE_OWNER_CHANGED",
    "type" : "String",
    "comment" : "\n     * Broadcast action: sent when the profile owner is set, changed or cleared.\n     *\n     * This broadcast is sent only to the user managed by the new profile owner.\n     * @see DevicePolicyManager#transferOwnership(ComponentName, ComponentName, PersistableBundle)\n     ",
    "links" : [ ]
  }, {
    "name" : "PRIVATE_DNS_MODE_UNKNOWN",
    "type" : "int",
    "comment" : "\n     * Specifies that the Private DNS setting is in an unknown state.\n     ",
    "links" : [ ]
  }, {
    "name" : "PRIVATE_DNS_MODE_OFF",
    "type" : "int",
    "comment" : "\n     * Specifies that Private DNS was turned off completely.\n     ",
    "links" : [ ]
  }, {
    "name" : "PRIVATE_DNS_MODE_OPPORTUNISTIC",
    "type" : "int",
    "comment" : "\n     * Specifies that the device owner requested opportunistic DNS over TLS\n     ",
    "links" : [ ]
  }, {
    "name" : "PRIVATE_DNS_MODE_PROVIDER_HOSTNAME",
    "type" : "int",
    "comment" : "\n     * Specifies that the device owner configured a specific host to use for Private DNS.\n     ",
    "links" : [ ]
  }, {
    "name" : "PRIVATE_DNS_SET_NO_ERROR",
    "type" : "int",
    "comment" : "\n     * The selected mode has been set successfully. If the mode is\n     * {@code PRIVATE_DNS_MODE_PROVIDER_HOSTNAME} then it implies the supplied host is valid\n     * and reachable.\n     ",
    "links" : [ ]
  }, {
    "name" : "PRIVATE_DNS_SET_ERROR_HOST_NOT_SERVING",
    "type" : "int",
    "comment" : "\n     * If the {@code privateDnsHost} provided was of a valid hostname but that host was found\n     * to not support DNS-over-TLS.\n     ",
    "links" : [ ]
  }, {
    "name" : "PRIVATE_DNS_SET_ERROR_FAILURE_SETTING",
    "type" : "int",
    "comment" : "\n     * General failure to set the Private DNS mode, not due to one of the reasons listed above.\n     ",
    "links" : [ ]
  }, {
    "name" : "ACTION_GET_PROVISIONING_MODE",
    "type" : "String",
    "comment" : "\n     * Activity action: Starts the administrator to get the mode for the provisioning.\n     * This intent may contain the following extras:\n     * <ul>\n     *     <li>{@link #EXTRA_PROVISIONING_ADMIN_EXTRAS_BUNDLE}</li>\n     *     <li>{@link #EXTRA_PROVISIONING_IMEI}</li>\n     *     <li>{@link #EXTRA_PROVISIONING_SERIAL_NUMBER}</li>\n     * </ul>\n     *\n     * <p>The target activity should return one of the following values in\n     * {@link #EXTRA_PROVISIONING_MODE} as result:\n     * <ul>\n     *     <li>{@link #PROVISIONING_MODE_FULLY_MANAGED_DEVICE}</li>\n     *     <li>{@link #PROVISIONING_MODE_MANAGED_PROFILE}</li>\n     * </ul>\n     *\n     * <p>If performing fully-managed device provisioning and the admin app desires to show its\n     * own education screens, the target activity can additionally return\n     * {@link #EXTRA_PROVISIONING_SKIP_EDUCATION_SCREENS} set to <code>true</code>.\n     *\n     * <p>The target activity may also return the account that needs to be migrated from primary\n     * user to managed profile in case of a profile owner provisioning in\n     * {@link #EXTRA_PROVISIONING_ACCOUNT_TO_MIGRATE} as result.\n     ",
    "links" : [ "#EXTRA_PROVISIONING_ADMIN_EXTRAS_BUNDLE", "#EXTRA_PROVISIONING_IMEI", "#EXTRA_PROVISIONING_SERIAL_NUMBER", "#EXTRA_PROVISIONING_MODE", "#PROVISIONING_MODE_FULLY_MANAGED_DEVICE", "#PROVISIONING_MODE_MANAGED_PROFILE", "#EXTRA_PROVISIONING_SKIP_EDUCATION_SCREENS", "#EXTRA_PROVISIONING_ACCOUNT_TO_MIGRATE" ]
  }, {
    "name" : "EXTRA_PROVISIONING_IMEI",
    "type" : "String",
    "comment" : "\n     * A string extra holding the IMEI (International Mobile Equipment Identity) of the device.\n     ",
    "links" : [ ]
  }, {
    "name" : "EXTRA_PROVISIONING_SERIAL_NUMBER",
    "type" : "String",
    "comment" : "\n     * A string extra holding the serial number of the device.\n     ",
    "links" : [ ]
  }, {
    "name" : "EXTRA_PROVISIONING_MODE",
    "type" : "String",
    "comment" : "\n     * An intent extra holding the provisioning mode returned by the administrator.\n     * The value for this extra should be one of the following:\n     * <ul>\n     *     <li>{@link #PROVISIONING_MODE_FULLY_MANAGED_DEVICE}</li>\n     *     <li>{@link #PROVISIONING_MODE_MANAGED_PROFILE}</li>\n     * </ul>\n     ",
    "links" : [ "#PROVISIONING_MODE_FULLY_MANAGED_DEVICE", "#PROVISIONING_MODE_MANAGED_PROFILE" ]
  }, {
    "name" : "PROVISIONING_MODE_FULLY_MANAGED_DEVICE",
    "type" : "int",
    "comment" : "\n     * The provisioning mode for fully managed device.\n     ",
    "links" : [ ]
  }, {
    "name" : "PROVISIONING_MODE_MANAGED_PROFILE",
    "type" : "int",
    "comment" : "\n     * The provisioning mode for managed profile.\n     ",
    "links" : [ ]
  }, {
    "name" : "ACTION_ADMIN_POLICY_COMPLIANCE",
    "type" : "String",
    "comment" : "\n     * Activity action: Starts the administrator to show policy compliance for the provisioning.\n     * This action is used any time that the administrator has an opportunity to show policy\n     * compliance before the end of setup wizard. This could happen as part of the admin-integrated\n     * provisioning flow (in which case this gets sent after {@link #ACTION_GET_PROVISIONING_MODE}),\n     * or it could happen during provisioning finalization if the administrator supports\n     * finalization during setup wizard.\n     ",
    "links" : [ "#ACTION_GET_PROVISIONING_MODE" ]
  }, {
    "name" : "MAX_PASSWORD_LENGTH",
    "type" : "int",
    "comment" : "\n     * Maximum supported password length. Kind-of arbitrary.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "ACTION_BIND_SECONDARY_LOCKSCREEN_SERVICE",
    "type" : "String",
    "comment" : "\n     * Service Action: Service implemented by a device owner or profile owner supervision app to\n     * provide a secondary lockscreen.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "PERSONAL_APPS_NOT_SUSPENDED",
    "type" : "int",
    "comment" : "\n     * Return value for {@link #getPersonalAppsSuspendedReasons} when personal apps are not\n     * suspended.\n     ",
    "links" : [ "#getPersonalAppsSuspendedReasons" ]
  }, {
    "name" : "PERSONAL_APPS_SUSPENDED_EXPLICITLY",
    "type" : "int",
    "comment" : "\n     * Flag for {@link #getPersonalAppsSuspendedReasons} return value. Set when personal\n     * apps are suspended by an admin explicitly via {@link #setPersonalAppsSuspended}.\n     ",
    "links" : [ "#getPersonalAppsSuspendedReasons", "#setPersonalAppsSuspended" ]
  }, {
    "name" : "PERSONAL_APPS_SUSPENDED_PROFILE_TIMEOUT",
    "type" : "int",
    "comment" : "\n     * Flag for {@link #getPersonalAppsSuspendedReasons} return value. Set when personal apps are\n     * suspended by framework because managed profile was off for longer than allowed by policy.\n     * @see #setManagedProfileMaximumTimeOff\n     ",
    "links" : [ "#getPersonalAppsSuspendedReasons" ]
  }, {
    "name" : "PASSWORD_QUALITY_UNSPECIFIED",
    "type" : "int",
    "comment" : "\n     * Constant for {@link #setPasswordQuality}: the policy has no requirements\n     * for the password.  Note that quality constants are ordered so that higher\n     * values are more restrictive.\n     ",
    "links" : [ "#setPasswordQuality" ]
  }, {
    "name" : "PASSWORD_QUALITY_BIOMETRIC_WEAK",
    "type" : "int",
    "comment" : "\n     * Constant for {@link #setPasswordQuality}: the policy allows for low-security biometric\n     * recognition technology.  This implies technologies that can recognize the identity of\n     * an individual to about a 3 digit PIN (false detection is less than 1 in 1,000).\n     * Note that quality constants are ordered so that higher values are more restrictive.\n     ",
    "links" : [ "#setPasswordQuality" ]
  }, {
    "name" : "PASSWORD_QUALITY_SOMETHING",
    "type" : "int",
    "comment" : "\n     * Constant for {@link #setPasswordQuality}: the policy requires some kind\n     * of password or pattern, but doesn't care what it is. Note that quality constants\n     * are ordered so that higher values are more restrictive.\n     ",
    "links" : [ "#setPasswordQuality" ]
  }, {
    "name" : "PASSWORD_QUALITY_NUMERIC",
    "type" : "int",
    "comment" : "\n     * Constant for {@link #setPasswordQuality}: the user must have entered a\n     * password containing at least numeric characters.  Note that quality\n     * constants are ordered so that higher values are more restrictive.\n     ",
    "links" : [ "#setPasswordQuality" ]
  }, {
    "name" : "PASSWORD_QUALITY_NUMERIC_COMPLEX",
    "type" : "int",
    "comment" : "\n     * Constant for {@link #setPasswordQuality}: the user must have entered a\n     * password containing at least numeric characters with no repeating (4444)\n     * or ordered (1234, 4321, 2468) sequences.  Note that quality\n     * constants are ordered so that higher values are more restrictive.\n     ",
    "links" : [ "#setPasswordQuality" ]
  }, {
    "name" : "PASSWORD_QUALITY_ALPHABETIC",
    "type" : "int",
    "comment" : "\n     * Constant for {@link #setPasswordQuality}: the user must have entered a\n     * password containing at least alphabetic (or other symbol) characters.\n     * Note that quality constants are ordered so that higher values are more\n     * restrictive.\n     ",
    "links" : [ "#setPasswordQuality" ]
  }, {
    "name" : "PASSWORD_QUALITY_ALPHANUMERIC",
    "type" : "int",
    "comment" : "\n     * Constant for {@link #setPasswordQuality}: the user must have entered a\n     * password containing at least <em>both></em> numeric <em>and</em>\n     * alphabetic (or other symbol) characters.  Note that quality constants are\n     * ordered so that higher values are more restrictive.\n     ",
    "links" : [ "#setPasswordQuality" ]
  }, {
    "name" : "PASSWORD_QUALITY_COMPLEX",
    "type" : "int",
    "comment" : "\n     * Constant for {@link #setPasswordQuality}: allows the admin to set precisely how many\n     * characters of various types the password should contain to satisfy the policy. The admin\n     * should set these requirements via {@link #setPasswordMinimumLetters},\n     * {@link #setPasswordMinimumNumeric}, {@link #setPasswordMinimumSymbols},\n     * {@link #setPasswordMinimumUpperCase}, {@link #setPasswordMinimumLowerCase},\n     * {@link #setPasswordMinimumNonLetter}, and {@link #setPasswordMinimumLength}.\n     * Note that quality constants are ordered so that higher values are more restrictive.\n     ",
    "links" : [ "#setPasswordQuality", "#setPasswordMinimumLetters", "#setPasswordMinimumNumeric", "#setPasswordMinimumSymbols", "#setPasswordMinimumUpperCase", "#setPasswordMinimumLowerCase", "#setPasswordMinimumNonLetter", "#setPasswordMinimumLength" ]
  }, {
    "name" : "PASSWORD_QUALITY_MANAGED",
    "type" : "int",
    "comment" : "\n     * Constant for {@link #setPasswordQuality}: the user is not allowed to\n     * modify password. In case this password quality is set, the password is\n     * managed by a profile owner. The profile owner can set any password,\n     * as if {@link #PASSWORD_QUALITY_UNSPECIFIED} is used. Note\n     * that quality constants are ordered so that higher values are more\n     * restrictive. The value of {@link #PASSWORD_QUALITY_MANAGED} is\n     * the highest.\n     * @hide\n     ",
    "links" : [ "#setPasswordQuality", "#PASSWORD_QUALITY_UNSPECIFIED", "#PASSWORD_QUALITY_MANAGED" ]
  }, {
    "name" : "ACCOUNT_FEATURE_DEVICE_OR_PROFILE_OWNER_ALLOWED",
    "type" : "String",
    "comment" : "\n     * @hide\n     *\n     * adb shell dpm set-{device,profile}-owner will normally not allow installing an owner to\n     * a user with accounts.  {@link #ACCOUNT_FEATURE_DEVICE_OR_PROFILE_OWNER_ALLOWED}\n     * and {@link #ACCOUNT_FEATURE_DEVICE_OR_PROFILE_OWNER_DISALLOWED} are the account features\n     * used by authenticator to exempt their accounts from this:\n     *\n     * <ul>\n     *     <li>Non-test-only DO/PO still can't be installed when there are accounts.\n     *     <p>In order to make an apk test-only, add android:testOnly=\"true\" to the\n     *     &lt;application&gt; tag in the manifest.\n     *\n     *     <li>Test-only DO/PO can be installed even when there are accounts, as long as all the\n     *     accounts have the {@link #ACCOUNT_FEATURE_DEVICE_OR_PROFILE_OWNER_ALLOWED} feature.\n     *     Some authenticators claim to have any features, so to detect it, we also check\n     *     {@link #ACCOUNT_FEATURE_DEVICE_OR_PROFILE_OWNER_DISALLOWED} and disallow installing\n     *     if any of the accounts have it.\n     * </ul>\n     ",
    "links" : [ "#ACCOUNT_FEATURE_DEVICE_OR_PROFILE_OWNER_ALLOWED", "#ACCOUNT_FEATURE_DEVICE_OR_PROFILE_OWNER_DISALLOWED", "#ACCOUNT_FEATURE_DEVICE_OR_PROFILE_OWNER_ALLOWED", "#ACCOUNT_FEATURE_DEVICE_OR_PROFILE_OWNER_DISALLOWED" ]
  }, {
    "name" : "ACCOUNT_FEATURE_DEVICE_OR_PROFILE_OWNER_DISALLOWED",
    "type" : "String",
    "comment" : " @hide See {@link #ACCOUNT_FEATURE_DEVICE_OR_PROFILE_OWNER_ALLOWED} ",
    "links" : [ "#ACCOUNT_FEATURE_DEVICE_OR_PROFILE_OWNER_ALLOWED" ]
  }, {
    "name" : "RESET_PASSWORD_REQUIRE_ENTRY",
    "type" : "int",
    "comment" : "\n     * Flag for {@link #resetPasswordWithToken} and {@link #resetPassword}: don't allow other admins\n     * to change the password again until the user has entered it.\n     ",
    "links" : [ "#resetPasswordWithToken", "#resetPassword" ]
  }, {
    "name" : "RESET_PASSWORD_DO_NOT_ASK_CREDENTIALS_ON_BOOT",
    "type" : "int",
    "comment" : "\n     * Flag for {@link #resetPasswordWithToken} and {@link #resetPassword}: don't ask for user\n     * credentials on device boot.\n     * If the flag is set, the device can be booted without asking for user password.\n     * The absence of this flag does not change the current boot requirements. This flag\n     * can be set by the device owner only. If the app is not the device owner, the flag\n     * is ignored. Once the flag is set, it cannot be reverted back without resetting the\n     * device to factory defaults.\n     ",
    "links" : [ "#resetPasswordWithToken", "#resetPassword" ]
  }, {
    "name" : "FLAG_EVICT_CREDENTIAL_ENCRYPTION_KEY",
    "type" : "int",
    "comment" : "\n     * Flag for {@link #lockNow(int)}: also evict the user's credential encryption key from the\n     * keyring. The user's credential will need to be entered again in order to derive the\n     * credential encryption key that will be stored back in the keyring for future use.\n     * <p>\n     * This flag can only be used by a profile owner when locking a managed profile when\n     * {@link #getStorageEncryptionStatus} returns {@link #ENCRYPTION_STATUS_ACTIVE_PER_USER}.\n     * <p>\n     * In order to secure user data, the user will be stopped and restarted so apps should wait\n     * until they are next run to perform further actions.\n     ",
    "links" : [ "#lockNow", "#getStorageEncryptionStatus", "#ENCRYPTION_STATUS_ACTIVE_PER_USER" ]
  }, {
    "name" : "WIPE_EXTERNAL_STORAGE",
    "type" : "int",
    "comment" : "\n     * Flag for {@link #wipeData(int)}: also erase the device's external\n     * storage (such as SD cards).\n     ",
    "links" : [ "#wipeData" ]
  }, {
    "name" : "WIPE_RESET_PROTECTION_DATA",
    "type" : "int",
    "comment" : "\n     * Flag for {@link #wipeData(int)}: also erase the factory reset protection\n     * data.\n     *\n     * <p>This flag may only be set by device owner admins; if it is set by\n     * other admins a {@link SecurityException} will be thrown.\n     ",
    "links" : [ "#wipeData", "SecurityException" ]
  }, {
    "name" : "WIPE_EUICC",
    "type" : "int",
    "comment" : "\n     * Flag for {@link #wipeData(int)}: also erase the device's eUICC data.\n     ",
    "links" : [ "#wipeData" ]
  }, {
    "name" : "WIPE_SILENTLY",
    "type" : "int",
    "comment" : "\n     * Flag for {@link #wipeData(int)}: won't show reason for wiping to the user.\n     ",
    "links" : [ "#wipeData" ]
  }, {
    "name" : "ENCRYPTION_STATUS_UNSUPPORTED",
    "type" : "int",
    "comment" : "\n     * Result code for {@link #setStorageEncryption} and {@link #getStorageEncryptionStatus}:\n     * indicating that encryption is not supported.\n     ",
    "links" : [ "#setStorageEncryption", "#getStorageEncryptionStatus" ]
  }, {
    "name" : "ENCRYPTION_STATUS_INACTIVE",
    "type" : "int",
    "comment" : "\n     * Result code for {@link #setStorageEncryption} and {@link #getStorageEncryptionStatus}:\n     * indicating that encryption is supported, but is not currently active.\n     ",
    "links" : [ "#setStorageEncryption", "#getStorageEncryptionStatus" ]
  }, {
    "name" : "ENCRYPTION_STATUS_ACTIVATING",
    "type" : "int",
    "comment" : "\n     * Result code for {@link #getStorageEncryptionStatus}:\n     * indicating that encryption is not currently active, but is currently\n     * being activated.  This is only reported by devices that support\n     * encryption of data and only when the storage is currently\n     * undergoing a process of becoming encrypted.  A device that must reboot and/or wipe data\n     * to become encrypted will never return this value.\n     ",
    "links" : [ "#getStorageEncryptionStatus" ]
  }, {
    "name" : "ENCRYPTION_STATUS_ACTIVE",
    "type" : "int",
    "comment" : "\n     * Result code for {@link #setStorageEncryption} and {@link #getStorageEncryptionStatus}:\n     * indicating that encryption is active.\n     * <p>\n     * Also see {@link #ENCRYPTION_STATUS_ACTIVE_PER_USER}.\n     ",
    "links" : [ "#setStorageEncryption", "#getStorageEncryptionStatus", "#ENCRYPTION_STATUS_ACTIVE_PER_USER" ]
  }, {
    "name" : "ENCRYPTION_STATUS_ACTIVE_DEFAULT_KEY",
    "type" : "int",
    "comment" : "\n     * Result code for {@link #getStorageEncryptionStatus}:\n     * indicating that encryption is active, but an encryption key has not\n     * been set by the user.\n     ",
    "links" : [ "#getStorageEncryptionStatus" ]
  }, {
    "name" : "ENCRYPTION_STATUS_ACTIVE_PER_USER",
    "type" : "int",
    "comment" : "\n     * Result code for {@link #getStorageEncryptionStatus}:\n     * indicating that encryption is active and the encryption key is tied to the user or profile.\n     * <p>\n     * This value is only returned to apps targeting API level 24 and above. For apps targeting\n     * earlier API levels, {@link #ENCRYPTION_STATUS_ACTIVE} is returned, even if the\n     * encryption key is specific to the user or profile.\n     ",
    "links" : [ "#getStorageEncryptionStatus", "#ENCRYPTION_STATUS_ACTIVE" ]
  }, {
    "name" : "ACTION_START_ENCRYPTION",
    "type" : "String",
    "comment" : "\n     * Activity action: begin the process of encrypting data on the device.  This activity should\n     * be launched after using {@link #setStorageEncryption} to request encryption be activated.\n     * After resuming from this activity, use {@link #getStorageEncryption}\n     * to check encryption status.  However, on some devices this activity may never return, as\n     * it may trigger a reboot and in some cases a complete data wipe of the device.\n     ",
    "links" : [ "#setStorageEncryption", "#getStorageEncryption" ]
  }, {
    "name" : "ACTION_CHECK_POLICY_COMPLIANCE",
    "type" : "String",
    "comment" : "\n     * Activity action: launch the DPC to check policy compliance. This intent is launched when\n     * the user taps on the notification about personal apps suspension. When handling this intent\n     * the DPC must check if personal apps should still be suspended and either unsuspend them or\n     * instruct the user on how to resolve the noncompliance causing the suspension.\n     *\n     * @see #setPersonalAppsSuspended\n     ",
    "links" : [ ]
  }, {
    "name" : "ACTION_MANAGED_USER_CREATED",
    "type" : "String",
    "comment" : "\n     * Broadcast action: notify managed provisioning that new managed user is created.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "KEYGUARD_DISABLE_FEATURES_NONE",
    "type" : "int",
    "comment" : "\n     * Widgets are enabled in keyguard\n     ",
    "links" : [ ]
  }, {
    "name" : "KEYGUARD_DISABLE_WIDGETS_ALL",
    "type" : "int",
    "comment" : "\n     * Disable all keyguard widgets. Has no effect starting from\n     * {@link android.os.Build.VERSION_CODES#LOLLIPOP} since keyguard widget is only supported\n     * on Android versions lower than 5.0.\n     ",
    "links" : [ "android.os.Build.VERSION_CODES#LOLLIPOP" ]
  }, {
    "name" : "KEYGUARD_DISABLE_SECURE_CAMERA",
    "type" : "int",
    "comment" : "\n     * Disable the camera on secure keyguard screens (e.g. PIN/Pattern/Password)\n     ",
    "links" : [ ]
  }, {
    "name" : "KEYGUARD_DISABLE_SECURE_NOTIFICATIONS",
    "type" : "int",
    "comment" : "\n     * Disable showing all notifications on secure keyguard screens (e.g. PIN/Pattern/Password)\n     ",
    "links" : [ ]
  }, {
    "name" : "KEYGUARD_DISABLE_UNREDACTED_NOTIFICATIONS",
    "type" : "int",
    "comment" : "\n     * Only allow redacted notifications on secure keyguard screens (e.g. PIN/Pattern/Password)\n     ",
    "links" : [ ]
  }, {
    "name" : "KEYGUARD_DISABLE_TRUST_AGENTS",
    "type" : "int",
    "comment" : "\n     * Disable trust agents on secure keyguard screens (e.g. PIN/Pattern/Password).\n     * By setting this flag alone, all trust agents are disabled. If the admin then wants to\n     * whitelist specific features of some trust agent, {@link #setTrustAgentConfiguration} can be\n     * used in conjuction to set trust-agent-specific configurations.\n     ",
    "links" : [ "#setTrustAgentConfiguration" ]
  }, {
    "name" : "KEYGUARD_DISABLE_FINGERPRINT",
    "type" : "int",
    "comment" : "\n     * Disable fingerprint authentication on keyguard secure screens (e.g. PIN/Pattern/Password).\n     ",
    "links" : [ ]
  }, {
    "name" : "KEYGUARD_DISABLE_REMOTE_INPUT",
    "type" : "int",
    "comment" : "\n     * Disable text entry into notifications on secure keyguard screens (e.g. PIN/Pattern/Password).\n     * This flag has no effect starting from version {@link android.os.Build.VERSION_CODES#N}\n     ",
    "links" : [ "android.os.Build.VERSION_CODES#N" ]
  }, {
    "name" : "KEYGUARD_DISABLE_FACE",
    "type" : "int",
    "comment" : "\n     * Disable face authentication on keyguard secure screens (e.g. PIN/Pattern/Password).\n     ",
    "links" : [ ]
  }, {
    "name" : "KEYGUARD_DISABLE_IRIS",
    "type" : "int",
    "comment" : "\n     * Disable iris authentication on keyguard secure screens (e.g. PIN/Pattern/Password).\n     ",
    "links" : [ ]
  }, {
    "name" : "KEYGUARD_DISABLE_BIOMETRICS",
    "type" : "int",
    "comment" : "\n     * Disable all biometric authentication on keyguard secure screens (e.g. PIN/Pattern/Password).\n     ",
    "links" : [ ]
  }, {
    "name" : "KEYGUARD_DISABLE_FEATURES_ALL",
    "type" : "int",
    "comment" : "\n     * Disable all current and future keyguard customizations.\n     ",
    "links" : [ ]
  }, {
    "name" : "NON_ORG_OWNED_PROFILE_KEYGUARD_FEATURES_AFFECT_OWNER",
    "type" : "int",
    "comment" : "\n     * Keyguard features that when set on a non-organization-owned managed profile that doesn't\n     * have its own challenge will affect the profile's parent user. These can also be set on the\n     * managed profile's parent {@link DevicePolicyManager} instance to explicitly control the\n     * parent user.\n     *\n     * <p>\n     * Organization-owned managed profile supports disabling additional keyguard features on the\n     * parent user as defined in {@link #ORG_OWNED_PROFILE_KEYGUARD_FEATURES_PARENT_ONLY}.\n     *\n     * @hide\n     ",
    "links" : [ "DevicePolicyManager", "#ORG_OWNED_PROFILE_KEYGUARD_FEATURES_PARENT_ONLY" ]
  }, {
    "name" : "ORG_OWNED_PROFILE_KEYGUARD_FEATURES_PARENT_ONLY",
    "type" : "int",
    "comment" : "\n     * Keyguard features that when set by the profile owner of an organization-owned managed\n     * profile will affect the profile's parent user if set on the managed profile's parent\n     * {@link DevicePolicyManager} instance.\n     *\n     * @hide\n     ",
    "links" : [ "DevicePolicyManager" ]
  }, {
    "name" : "PROFILE_KEYGUARD_FEATURES_AFFECT_OWNER",
    "type" : "int",
    "comment" : "\n     * Keyguard features that when set on a normal or organization-owned managed profile, have\n     * the potential to affect the profile's parent user.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "ERROR_VPN_PACKAGE_NOT_FOUND",
    "type" : "int",
    "comment" : "\n     * Service-specific error code used in implementation of {@code setAlwaysOnVpnPackage} methods.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "SKIP_SETUP_WIZARD",
    "type" : "int",
    "comment" : "\n      * Flag used by {@link #createAndManageUser} to skip setup wizard after creating a new user.\n      ",
    "links" : [ "#createAndManageUser" ]
  }, {
    "name" : "MAKE_USER_EPHEMERAL",
    "type" : "int",
    "comment" : "\n     * Flag used by {@link #createAndManageUser} to specify that the user should be created\n     * ephemeral. Ephemeral users will be removed after switching to another user or rebooting the\n     * device.\n     ",
    "links" : [ "#createAndManageUser" ]
  }, {
    "name" : "MAKE_USER_DEMO",
    "type" : "int",
    "comment" : "\n     * Flag used by {@link #createAndManageUser} to specify that the user should be created as a\n     * demo user.\n     * @hide\n     ",
    "links" : [ "#createAndManageUser" ]
  }, {
    "name" : "LEAVE_ALL_SYSTEM_APPS_ENABLED",
    "type" : "int",
    "comment" : "\n     * Flag used by {@link #createAndManageUser} to specify that the newly created user should skip\n     * the disabling of system apps during provisioning.\n     ",
    "links" : [ "#createAndManageUser" ]
  } ],
  "methods" : [ {
    "name" : "protected int myUserId()",
    "returnType" : "int",
    "comment" : " @hide test will override it. ",
    "links" : [ ]
  }, {
    "name" : "public boolean isAdminActive(@NonNull ComponentName admin)",
    "returnType" : "boolean",
    "comment" : "\n     * Return true if the given administrator component is currently active (enabled) in the system.\n     *\n     * @param admin The administrator component to check for.\n     * @return {@code true} if {@code admin} is currently enabled in the system, {@code false}\n     *         otherwise\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean isAdminActiveAsUser(@NonNull ComponentName admin, int userId)",
    "returnType" : "boolean",
    "comment" : "\n     * @see #isAdminActive(ComponentName)\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean isRemovingAdmin(@NonNull ComponentName admin, int userId)",
    "returnType" : "boolean",
    "comment" : "\n     * Return true if the given administrator component is currently being removed\n     * for the user.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public List<ComponentName> getActiveAdmins()",
    "returnType" : "List<ComponentName>",
    "comment" : "\n     * Return a list of all currently active device administrators' component\n     * names.  If there are no administrators {@code null} may be\n     * returned.\n     ",
    "links" : [ ]
  }, {
    "name" : "public List<ComponentName> getActiveAdminsAsUser(int userId)",
    "returnType" : "List<ComponentName>",
    "comment" : "\n     * @see #getActiveAdmins()\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean packageHasActiveAdmins(String packageName)",
    "returnType" : "boolean",
    "comment" : "\n     * Used by package administration code to determine if a package can be stopped\n     * or uninstalled.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean packageHasActiveAdmins(String packageName, int userId)",
    "returnType" : "boolean",
    "comment" : "\n     * Used by package administration code to determine if a package can be stopped\n     * or uninstalled.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public void removeActiveAdmin(@NonNull ComponentName admin)",
    "returnType" : "void",
    "comment" : "\n     * Remove a current administration component.  This can only be called\n     * by the application that owns the administration component; if you\n     * try to remove someone else's component, a security exception will be\n     * thrown.\n     *\n     * <p>Note that the operation is not synchronous and the admin might still be active (as\n     * indicated by {@link #getActiveAdmins()}) by the time this method returns.\n     *\n     * @param admin The administration compononent to remove.\n     * @throws SecurityException if the caller is not in the owner application of {@code admin}.\n     ",
    "links" : [ "#getActiveAdmins" ]
  }, {
    "name" : "public boolean hasGrantedPolicy(@NonNull ComponentName admin, int usesPolicy)",
    "returnType" : "boolean",
    "comment" : "\n     * Returns true if an administrator has been granted a particular device policy. This can be\n     * used to check whether the administrator was activated under an earlier set of policies, but\n     * requires additional policies after an upgrade.\n     *\n     * @param admin Which {@link DeviceAdminReceiver} this request is associated with. Must be an\n     *            active administrator, or an exception will be thrown.\n     * @param usesPolicy Which uses-policy to check, as defined in {@link DeviceAdminInfo}.\n     * @throws SecurityException if {@code admin} is not an active administrator.\n     ",
    "links" : [ "DeviceAdminReceiver", "DeviceAdminInfo" ]
  }, {
    "name" : "public boolean isSeparateProfileChallengeAllowed(int userHandle)",
    "returnType" : "boolean",
    "comment" : "\n     * Returns true if the Profile Challenge is available to use for the given profile user.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public void setPasswordQuality(@NonNull ComponentName admin, int quality)",
    "returnType" : "void",
    "comment" : "\n     * Called by an application that is administering the device to set the password restrictions it\n     * is imposing. After setting this, the user will not be able to enter a new password that is\n     * not at least as restrictive as what has been set. Note that the current password will remain\n     * until the user has set a new one, so the change does not take place immediately. To prompt\n     * the user for a new password, use {@link #ACTION_SET_NEW_PASSWORD} or\n     * {@link #ACTION_SET_NEW_PARENT_PROFILE_PASSWORD} after calling this method.\n     * <p>\n     * Quality constants are ordered so that higher values are more restrictive; thus the highest\n     * requested quality constant (between the policy set here, the user's preference, and any other\n     * considerations) is the one that is in effect.\n     * <p>\n     * On devices not supporting {@link PackageManager#FEATURE_SECURE_LOCK_SCREEN} feature, the\n     * password is always treated as empty.\n     * <p>\n     * The calling device admin must have requested\n     * {@link DeviceAdminInfo#USES_POLICY_LIMIT_PASSWORD} to be able to call this method; if it has\n     * not, a security exception will be thrown.\n     * <p>\n     * This method can be called on the {@link DevicePolicyManager} instance returned by\n     * {@link #getParentProfileInstance(ComponentName)} in order to set restrictions on the parent\n     * profile.\n     *\n     * @param admin Which {@link DeviceAdminReceiver} this request is associated with.\n     * @param quality The new desired quality. One of {@link #PASSWORD_QUALITY_UNSPECIFIED},\n     *            {@link #PASSWORD_QUALITY_BIOMETRIC_WEAK},\n     *            {@link #PASSWORD_QUALITY_SOMETHING}, {@link #PASSWORD_QUALITY_NUMERIC},\n     *            {@link #PASSWORD_QUALITY_NUMERIC_COMPLEX}, {@link #PASSWORD_QUALITY_ALPHABETIC},\n     *            {@link #PASSWORD_QUALITY_ALPHANUMERIC} or {@link #PASSWORD_QUALITY_COMPLEX}.\n     * @throws SecurityException if {@code admin} is not an active administrator or if {@code admin}\n     *             does not use {@link DeviceAdminInfo#USES_POLICY_LIMIT_PASSWORD}\n     ",
    "links" : [ "#ACTION_SET_NEW_PASSWORD", "#ACTION_SET_NEW_PARENT_PROFILE_PASSWORD", "PackageManager#FEATURE_SECURE_LOCK_SCREEN", "DeviceAdminInfo#USES_POLICY_LIMIT_PASSWORD", "DevicePolicyManager", "#getParentProfileInstance", "DeviceAdminReceiver", "#PASSWORD_QUALITY_UNSPECIFIED", "#PASSWORD_QUALITY_BIOMETRIC_WEAK", "#PASSWORD_QUALITY_SOMETHING", "#PASSWORD_QUALITY_NUMERIC", "#PASSWORD_QUALITY_NUMERIC_COMPLEX", "#PASSWORD_QUALITY_ALPHABETIC", "#PASSWORD_QUALITY_ALPHANUMERIC", "#PASSWORD_QUALITY_COMPLEX", "DeviceAdminInfo#USES_POLICY_LIMIT_PASSWORD" ]
  }, {
    "name" : "public int getPasswordQuality(@Nullable ComponentName admin)",
    "returnType" : "int",
    "comment" : "\n     * Retrieve the current minimum password quality for a particular admin or all admins that set\n     * restrictions on this user and its participating profiles. Restrictions on profiles that have\n     * a separate challenge are not taken into account.\n     *\n     * <p>This method can be called on the {@link DevicePolicyManager} instance\n     * returned by {@link #getParentProfileInstance(ComponentName)} in order to retrieve\n     * restrictions on the parent profile.\n     *\n     * <p>Note: on devices not supporting {@link PackageManager#FEATURE_SECURE_LOCK_SCREEN} feature,\n     * the password is always treated as empty.\n     *\n     * @param admin The name of the admin component to check, or {@code null} to aggregate\n     * all admins.\n     ",
    "links" : [ "DevicePolicyManager", "#getParentProfileInstance", "PackageManager#FEATURE_SECURE_LOCK_SCREEN" ]
  }, {
    "name" : "public int getPasswordQuality(@Nullable ComponentName admin, int userHandle)",
    "returnType" : "int",
    "comment" : " @hide per-user version ",
    "links" : [ ]
  }, {
    "name" : "public void setPasswordMinimumLength(@NonNull ComponentName admin, int length)",
    "returnType" : "void",
    "comment" : "\n     * Called by an application that is administering the device to set the minimum allowed password\n     * length. After setting this, the user will not be able to enter a new password that is not at\n     * least as restrictive as what has been set. Note that the current password will remain until\n     * the user has set a new one, so the change does not take place immediately. To prompt the user\n     * for a new password, use {@link #ACTION_SET_NEW_PASSWORD} or\n     * {@link #ACTION_SET_NEW_PARENT_PROFILE_PASSWORD} after setting this value. This constraint is\n     * only imposed if the administrator has also requested either {@link #PASSWORD_QUALITY_NUMERIC}\n     * , {@link #PASSWORD_QUALITY_NUMERIC_COMPLEX}, {@link #PASSWORD_QUALITY_ALPHABETIC},\n     * {@link #PASSWORD_QUALITY_ALPHANUMERIC}, or {@link #PASSWORD_QUALITY_COMPLEX} with\n     * {@link #setPasswordQuality}. If an app targeting SDK level\n     * {@link android.os.Build.VERSION_CODES#R} and above enforces this constraint without settings\n     * password quality to one of these values first, this method will throw\n     * {@link IllegalStateException}.\n     * <p>\n     * On devices not supporting {@link PackageManager#FEATURE_SECURE_LOCK_SCREEN} feature, the\n     * password is always treated as empty.\n     * <p>\n     * The calling device admin must have requested\n     * {@link DeviceAdminInfo#USES_POLICY_LIMIT_PASSWORD} to be able to call this method; if it has\n     * not, a security exception will be thrown.\n     * <p>\n     * This method can be called on the {@link DevicePolicyManager} instance returned by\n     * {@link #getParentProfileInstance(ComponentName)} in order to set restrictions on the parent\n     * profile.\n     *\n     * @param admin Which {@link DeviceAdminReceiver} this request is associated with.\n     * @param length The new desired minimum password length. A value of 0 means there is no\n     *     restriction.\n     * @throws SecurityException if {@code admin} is not an active administrator or {@code admin}\n     *     does not use {@link DeviceAdminInfo#USES_POLICY_LIMIT_PASSWORD}\n     * @throws IllegalStateException if the calling app is targeting SDK level\n     *     {@link android.os.Build.VERSION_CODES#R} and above and didn't set a sufficient password\n     *     quality requirement prior to calling this method.\n     ",
    "links" : [ "#ACTION_SET_NEW_PASSWORD", "#ACTION_SET_NEW_PARENT_PROFILE_PASSWORD", "#PASSWORD_QUALITY_NUMERIC", "#PASSWORD_QUALITY_NUMERIC_COMPLEX", "#PASSWORD_QUALITY_ALPHABETIC", "#PASSWORD_QUALITY_ALPHANUMERIC", "#PASSWORD_QUALITY_COMPLEX", "#setPasswordQuality", "android.os.Build.VERSION_CODES#R", "IllegalStateException", "PackageManager#FEATURE_SECURE_LOCK_SCREEN", "DeviceAdminInfo#USES_POLICY_LIMIT_PASSWORD", "DevicePolicyManager", "#getParentProfileInstance", "DeviceAdminReceiver", "DeviceAdminInfo#USES_POLICY_LIMIT_PASSWORD", "android.os.Build.VERSION_CODES#R" ]
  }, {
    "name" : "public int getPasswordMinimumLength(@Nullable ComponentName admin)",
    "returnType" : "int",
    "comment" : "\n     * Retrieve the current minimum password length for a particular admin or all admins that set\n     * restrictions on this user and its participating profiles. Restrictions on profiles that have\n     * a separate challenge are not taken into account.\n     *\n     * <p>On devices not supporting {@link PackageManager#FEATURE_SECURE_LOCK_SCREEN} feature, the\n     * password is always treated as empty.\n     *\n     * <p>This method can be called on the {@link DevicePolicyManager} instance\n     * returned by {@link #getParentProfileInstance(ComponentName)} in order to retrieve\n     * restrictions on the parent profile.\n     *\n     * @param admin The name of the admin component to check, or {@code null} to aggregate\n     * all admins.\n     ",
    "links" : [ "PackageManager#FEATURE_SECURE_LOCK_SCREEN", "DevicePolicyManager", "#getParentProfileInstance" ]
  }, {
    "name" : "public int getPasswordMinimumLength(@Nullable ComponentName admin, int userHandle)",
    "returnType" : "int",
    "comment" : " @hide per-user version ",
    "links" : [ ]
  }, {
    "name" : "public void setPasswordMinimumUpperCase(@NonNull ComponentName admin, int length)",
    "returnType" : "void",
    "comment" : "\n     * Called by an application that is administering the device to set the minimum number of upper\n     * case letters required in the password. After setting this, the user will not be able to enter\n     * a new password that is not at least as restrictive as what has been set. Note that the\n     * current password will remain until the user has set a new one, so the change does not take\n     * place immediately. To prompt the user for a new password, use\n     * {@link #ACTION_SET_NEW_PASSWORD} or {@link #ACTION_SET_NEW_PARENT_PROFILE_PASSWORD} after\n     * setting this value. This constraint is only imposed if the administrator has also requested\n     * {@link #PASSWORD_QUALITY_COMPLEX} with {@link #setPasswordQuality}. If an app targeting\n     * SDK level {@link android.os.Build.VERSION_CODES#R} and above enforces this constraint without\n     * settings password quality to {@link #PASSWORD_QUALITY_COMPLEX} first, this method will throw\n     * {@link IllegalStateException}. The default value is 0.\n     * <p>\n     * On devices not supporting {@link PackageManager#FEATURE_SECURE_LOCK_SCREEN} feature, the\n     * password is always treated as empty.\n     * <p>\n     * The calling device admin must have requested\n     * {@link DeviceAdminInfo#USES_POLICY_LIMIT_PASSWORD} to be able to call this method; if it has\n     * not, a security exception will be thrown.\n     * <p>\n     * This method can be called on the {@link DevicePolicyManager} instance returned by\n     * {@link #getParentProfileInstance(ComponentName)} in order to set restrictions on the parent\n     * profile.\n     *\n     * @param admin Which {@link DeviceAdminReceiver} this request is associated with.\n     * @param length The new desired minimum number of upper case letters required in the password.\n     *            A value of 0 means there is no restriction.\n     * @throws SecurityException if {@code admin} is not an active administrator or {@code admin}\n     *             does not use {@link DeviceAdminInfo#USES_POLICY_LIMIT_PASSWORD}\n     * @throws IllegalStateException if the calling app is targeting SDK level\n     *     {@link android.os.Build.VERSION_CODES#R} and above and didn't set a sufficient password\n     *     quality requirement prior to calling this method.\n     ",
    "links" : [ "#ACTION_SET_NEW_PASSWORD", "#ACTION_SET_NEW_PARENT_PROFILE_PASSWORD", "#PASSWORD_QUALITY_COMPLEX", "#setPasswordQuality", "android.os.Build.VERSION_CODES#R", "#PASSWORD_QUALITY_COMPLEX", "IllegalStateException", "PackageManager#FEATURE_SECURE_LOCK_SCREEN", "DeviceAdminInfo#USES_POLICY_LIMIT_PASSWORD", "DevicePolicyManager", "#getParentProfileInstance", "DeviceAdminReceiver", "DeviceAdminInfo#USES_POLICY_LIMIT_PASSWORD", "android.os.Build.VERSION_CODES#R" ]
  }, {
    "name" : "public int getPasswordMinimumUpperCase(@Nullable ComponentName admin)",
    "returnType" : "int",
    "comment" : "\n     * Retrieve the current number of upper case letters required in the password\n     * for a particular admin or all admins that set restrictions on this user and\n     * its participating profiles. Restrictions on profiles that have a separate challenge\n     * are not taken into account.\n     * This is the same value as set by\n     * {@link #setPasswordMinimumUpperCase(ComponentName, int)}\n     * and only applies when the password quality is\n     * {@link #PASSWORD_QUALITY_COMPLEX}.\n     *\n     * <p>On devices not supporting {@link PackageManager#FEATURE_SECURE_LOCK_SCREEN} feature, the\n     * password is always treated as empty.\n     *\n     * <p>This method can be called on the {@link DevicePolicyManager} instance\n     * returned by {@link #getParentProfileInstance(ComponentName)} in order to retrieve\n     * restrictions on the parent profile.\n     *\n     * @param admin The name of the admin component to check, or {@code null} to\n     *            aggregate all admins.\n     * @return The minimum number of upper case letters required in the\n     *         password.\n     ",
    "links" : [ "#setPasswordMinimumUpperCase", "#PASSWORD_QUALITY_COMPLEX", "PackageManager#FEATURE_SECURE_LOCK_SCREEN", "DevicePolicyManager", "#getParentProfileInstance" ]
  }, {
    "name" : "public int getPasswordMinimumUpperCase(@Nullable ComponentName admin, int userHandle)",
    "returnType" : "int",
    "comment" : " @hide per-user version ",
    "links" : [ ]
  }, {
    "name" : "public void setPasswordMinimumLowerCase(@NonNull ComponentName admin, int length)",
    "returnType" : "void",
    "comment" : "\n     * Called by an application that is administering the device to set the minimum number of lower\n     * case letters required in the password. After setting this, the user will not be able to enter\n     * a new password that is not at least as restrictive as what has been set. Note that the\n     * current password will remain until the user has set a new one, so the change does not take\n     * place immediately. To prompt the user for a new password, use\n     * {@link #ACTION_SET_NEW_PASSWORD} or {@link #ACTION_SET_NEW_PARENT_PROFILE_PASSWORD} after\n     * setting this value. This constraint is only imposed if the administrator has also requested\n     * {@link #PASSWORD_QUALITY_COMPLEX} with {@link #setPasswordQuality}. If an app targeting\n     * SDK level {@link android.os.Build.VERSION_CODES#R} and above enforces this constraint without\n     * settings password quality to {@link #PASSWORD_QUALITY_COMPLEX} first, this method will throw\n     * {@link IllegalStateException}. The default value is 0.\n     * <p>\n     * On devices not supporting {@link PackageManager#FEATURE_SECURE_LOCK_SCREEN} feature, the\n     * password is always treated as empty.\n     * <p>\n     * The calling device admin must have requested\n     * {@link DeviceAdminInfo#USES_POLICY_LIMIT_PASSWORD} to be able to call this method; if it has\n     * not, a security exception will be thrown.\n     * <p>\n     * This method can be called on the {@link DevicePolicyManager} instance returned by\n     * {@link #getParentProfileInstance(ComponentName)} in order to set restrictions on the parent\n     * profile.\n     *\n     * @param admin Which {@link DeviceAdminReceiver} this request is associated with.\n     * @param length The new desired minimum number of lower case letters required in the password.\n     *            A value of 0 means there is no restriction.\n     * @throws SecurityException if {@code admin} is not an active administrator or {@code admin}\n     *             does not use {@link DeviceAdminInfo#USES_POLICY_LIMIT_PASSWORD}\n     * @throws IllegalStateException if the calling app is targeting SDK level\n     *     {@link android.os.Build.VERSION_CODES#R} and above and didn't set a sufficient password\n     *     quality requirement prior to calling this method.\n     ",
    "links" : [ "#ACTION_SET_NEW_PASSWORD", "#ACTION_SET_NEW_PARENT_PROFILE_PASSWORD", "#PASSWORD_QUALITY_COMPLEX", "#setPasswordQuality", "android.os.Build.VERSION_CODES#R", "#PASSWORD_QUALITY_COMPLEX", "IllegalStateException", "PackageManager#FEATURE_SECURE_LOCK_SCREEN", "DeviceAdminInfo#USES_POLICY_LIMIT_PASSWORD", "DevicePolicyManager", "#getParentProfileInstance", "DeviceAdminReceiver", "DeviceAdminInfo#USES_POLICY_LIMIT_PASSWORD", "android.os.Build.VERSION_CODES#R" ]
  }, {
    "name" : "public int getPasswordMinimumLowerCase(@Nullable ComponentName admin)",
    "returnType" : "int",
    "comment" : "\n     * Retrieve the current number of lower case letters required in the password\n     * for a particular admin or all admins that set restrictions on this user\n     * and its participating profiles. Restrictions on profiles that have\n     * a separate challenge are not taken into account.\n     * This is the same value as set by\n     * {@link #setPasswordMinimumLowerCase(ComponentName, int)}\n     * and only applies when the password quality is\n     * {@link #PASSWORD_QUALITY_COMPLEX}.\n     *\n     * <p>On devices not supporting {@link PackageManager#FEATURE_SECURE_LOCK_SCREEN} feature, the\n     * password is always treated as empty.\n     *\n     * <p>This method can be called on the {@link DevicePolicyManager} instance\n     * returned by {@link #getParentProfileInstance(ComponentName)} in order to retrieve\n     * restrictions on the parent profile.\n     *\n     * @param admin The name of the admin component to check, or {@code null} to\n     *            aggregate all admins.\n     * @return The minimum number of lower case letters required in the\n     *         password.\n     ",
    "links" : [ "#setPasswordMinimumLowerCase", "#PASSWORD_QUALITY_COMPLEX", "PackageManager#FEATURE_SECURE_LOCK_SCREEN", "DevicePolicyManager", "#getParentProfileInstance" ]
  }, {
    "name" : "public int getPasswordMinimumLowerCase(@Nullable ComponentName admin, int userHandle)",
    "returnType" : "int",
    "comment" : " @hide per-user version ",
    "links" : [ ]
  }, {
    "name" : "public void setPasswordMinimumLetters(@NonNull ComponentName admin, int length)",
    "returnType" : "void",
    "comment" : "\n     * Called by an application that is administering the device to set the minimum number of\n     * letters required in the password. After setting this, the user will not be able to enter a\n     * new password that is not at least as restrictive as what has been set. Note that the current\n     * password will remain until the user has set a new one, so the change does not take place\n     * immediately. To prompt the user for a new password, use {@link #ACTION_SET_NEW_PASSWORD} or\n     * {@link #ACTION_SET_NEW_PARENT_PROFILE_PASSWORD} after setting this value. This constraint is\n     * only imposed if the administrator has also requested {@link #PASSWORD_QUALITY_COMPLEX} with\n     * {@link #setPasswordQuality}. If an app targeting SDK level\n     * {@link android.os.Build.VERSION_CODES#R} and above enforces this constraint without settings\n     * password quality to {@link #PASSWORD_QUALITY_COMPLEX} first, this method will throw\n     * {@link IllegalStateException}. The default value is 1.\n     * <p>\n     * On devices not supporting {@link PackageManager#FEATURE_SECURE_LOCK_SCREEN} feature, the\n     * password is always treated as empty.\n     * <p>\n     * The calling device admin must have requested\n     * {@link DeviceAdminInfo#USES_POLICY_LIMIT_PASSWORD} to be able to call this method; if it has\n     * not, a security exception will be thrown.\n     * <p>\n     * This method can be called on the {@link DevicePolicyManager} instance returned by\n     * {@link #getParentProfileInstance(ComponentName)} in order to set restrictions on the parent\n     * profile.\n     *\n     * @param admin Which {@link DeviceAdminReceiver} this request is associated with.\n     * @param length The new desired minimum number of letters required in the password. A value of\n     *            0 means there is no restriction.\n     * @throws SecurityException if {@code admin} is not an active administrator or {@code admin}\n     *             does not use {@link DeviceAdminInfo#USES_POLICY_LIMIT_PASSWORD}\n     * @throws IllegalStateException if the calling app is targeting SDK level\n     *     {@link android.os.Build.VERSION_CODES#R} and above and didn't set a sufficient password\n     *     quality requirement prior to calling this method.\n     ",
    "links" : [ "#ACTION_SET_NEW_PASSWORD", "#ACTION_SET_NEW_PARENT_PROFILE_PASSWORD", "#PASSWORD_QUALITY_COMPLEX", "#setPasswordQuality", "android.os.Build.VERSION_CODES#R", "#PASSWORD_QUALITY_COMPLEX", "IllegalStateException", "PackageManager#FEATURE_SECURE_LOCK_SCREEN", "DeviceAdminInfo#USES_POLICY_LIMIT_PASSWORD", "DevicePolicyManager", "#getParentProfileInstance", "DeviceAdminReceiver", "DeviceAdminInfo#USES_POLICY_LIMIT_PASSWORD", "android.os.Build.VERSION_CODES#R" ]
  }, {
    "name" : "public int getPasswordMinimumLetters(@Nullable ComponentName admin)",
    "returnType" : "int",
    "comment" : "\n     * Retrieve the current number of letters required in the password\n     * for a particular admin or all admins that set restrictions on this user\n     * and its participating profiles. Restrictions on profiles that have\n     * a separate challenge are not taken into account.\n     * This is the same value as set by\n     * {@link #setPasswordMinimumLetters(ComponentName, int)}\n     * and only applies when the password quality is\n     * {@link #PASSWORD_QUALITY_COMPLEX}.\n     *\n     * <p>On devices not supporting {@link PackageManager#FEATURE_SECURE_LOCK_SCREEN} feature, the\n     * password is always treated as empty.\n     *\n     * <p>This method can be called on the {@link DevicePolicyManager} instance\n     * returned by {@link #getParentProfileInstance(ComponentName)} in order to retrieve\n     * restrictions on the parent profile.\n     *\n     * @param admin The name of the admin component to check, or {@code null} to\n     *            aggregate all admins.\n     * @return The minimum number of letters required in the password.\n     ",
    "links" : [ "#setPasswordMinimumLetters", "#PASSWORD_QUALITY_COMPLEX", "PackageManager#FEATURE_SECURE_LOCK_SCREEN", "DevicePolicyManager", "#getParentProfileInstance" ]
  }, {
    "name" : "public int getPasswordMinimumLetters(@Nullable ComponentName admin, int userHandle)",
    "returnType" : "int",
    "comment" : " @hide per-user version ",
    "links" : [ ]
  }, {
    "name" : "public void setPasswordMinimumNumeric(@NonNull ComponentName admin, int length)",
    "returnType" : "void",
    "comment" : "\n     * Called by an application that is administering the device to set the minimum number of\n     * numerical digits required in the password. After setting this, the user will not be able to\n     * enter a new password that is not at least as restrictive as what has been set. Note that the\n     * current password will remain until the user has set a new one, so the change does not take\n     * place immediately. To prompt the user for a new password, use\n     * {@link #ACTION_SET_NEW_PASSWORD} or {@link #ACTION_SET_NEW_PARENT_PROFILE_PASSWORD} after\n     * setting this value. This constraint is only imposed if the administrator has also requested\n     * {@link #PASSWORD_QUALITY_COMPLEX} with {@link #setPasswordQuality}. If an app targeting\n     * SDK level {@link android.os.Build.VERSION_CODES#R} and above enforces this constraint without\n     * settings password quality to {@link #PASSWORD_QUALITY_COMPLEX} first, this method will throw\n     * {@link IllegalStateException}. The default value is 1.\n     * <p>\n     * On devices not supporting {@link PackageManager#FEATURE_SECURE_LOCK_SCREEN} feature, the\n     * password is always treated as empty.\n     * <p>\n     * The calling device admin must have requested\n     * {@link DeviceAdminInfo#USES_POLICY_LIMIT_PASSWORD} to be able to call this method; if it has\n     * not, a security exception will be thrown.\n     * <p>\n     * This method can be called on the {@link DevicePolicyManager} instance returned by\n     * {@link #getParentProfileInstance(ComponentName)} in order to set restrictions on the parent\n     * profile.\n     *\n     * @param admin Which {@link DeviceAdminReceiver} this request is associated with.\n     * @param length The new desired minimum number of numerical digits required in the password. A\n     *            value of 0 means there is no restriction.\n     * @throws SecurityException if {@code admin} is not an active administrator or {@code admin}\n     *             does not use {@link DeviceAdminInfo#USES_POLICY_LIMIT_PASSWORD}\n     * @throws IllegalStateException if the calling app is targeting SDK level\n     *     {@link android.os.Build.VERSION_CODES#R} and above and didn't set a sufficient password\n     *     quality requirement prior to calling this method.\n     ",
    "links" : [ "#ACTION_SET_NEW_PASSWORD", "#ACTION_SET_NEW_PARENT_PROFILE_PASSWORD", "#PASSWORD_QUALITY_COMPLEX", "#setPasswordQuality", "android.os.Build.VERSION_CODES#R", "#PASSWORD_QUALITY_COMPLEX", "IllegalStateException", "PackageManager#FEATURE_SECURE_LOCK_SCREEN", "DeviceAdminInfo#USES_POLICY_LIMIT_PASSWORD", "DevicePolicyManager", "#getParentProfileInstance", "DeviceAdminReceiver", "DeviceAdminInfo#USES_POLICY_LIMIT_PASSWORD", "android.os.Build.VERSION_CODES#R" ]
  }, {
    "name" : "public int getPasswordMinimumNumeric(@Nullable ComponentName admin)",
    "returnType" : "int",
    "comment" : "\n     * Retrieve the current number of numerical digits required in the password\n     * for a particular admin or all admins that set restrictions on this user\n     * and its participating profiles. Restrictions on profiles that have\n     * a separate challenge are not taken into account.\n     * This is the same value as set by\n     * {@link #setPasswordMinimumNumeric(ComponentName, int)}\n     * and only applies when the password quality is\n     * {@link #PASSWORD_QUALITY_COMPLEX}.\n     *\n     * <p>On devices not supporting {@link PackageManager#FEATURE_SECURE_LOCK_SCREEN} feature, the\n     * password is always treated as empty.\n     *\n     * <p>This method can be called on the {@link DevicePolicyManager} instance\n     * returned by {@link #getParentProfileInstance(ComponentName)} in order to retrieve\n     * restrictions on the parent profile.\n     *\n     * @param admin The name of the admin component to check, or {@code null} to\n     *            aggregate all admins.\n     * @return The minimum number of numerical digits required in the password.\n     ",
    "links" : [ "#setPasswordMinimumNumeric", "#PASSWORD_QUALITY_COMPLEX", "PackageManager#FEATURE_SECURE_LOCK_SCREEN", "DevicePolicyManager", "#getParentProfileInstance" ]
  }, {
    "name" : "public int getPasswordMinimumNumeric(@Nullable ComponentName admin, int userHandle)",
    "returnType" : "int",
    "comment" : " @hide per-user version ",
    "links" : [ ]
  }, {
    "name" : "public void setPasswordMinimumSymbols(@NonNull ComponentName admin, int length)",
    "returnType" : "void",
    "comment" : "\n     * Called by an application that is administering the device to set the minimum number of\n     * symbols required in the password. After setting this, the user will not be able to enter a\n     * new password that is not at least as restrictive as what has been set. Note that the current\n     * password will remain until the user has set a new one, so the change does not take place\n     * immediately. To prompt the user for a new password, use {@link #ACTION_SET_NEW_PASSWORD} or\n     * {@link #ACTION_SET_NEW_PARENT_PROFILE_PASSWORD} after setting this value. This constraint is\n     * only imposed if the administrator has also requested {@link #PASSWORD_QUALITY_COMPLEX} with\n     * {@link #setPasswordQuality}. If an app targeting SDK level\n     * {@link android.os.Build.VERSION_CODES#R} and above enforces this constraint without settings\n     * password quality to {@link #PASSWORD_QUALITY_COMPLEX} first, this method will throw\n     * {@link IllegalStateException}. The default value is 1.\n     * <p>\n     * On devices not supporting {@link PackageManager#FEATURE_SECURE_LOCK_SCREEN} feature, the\n     * password is always treated as empty.\n     * <p>\n     * The calling device admin must have requested\n     * {@link DeviceAdminInfo#USES_POLICY_LIMIT_PASSWORD} to be able to call this method; if it has\n     * not, a security exception will be thrown.\n     * <p>\n     * This method can be called on the {@link DevicePolicyManager} instance returned by\n     * {@link #getParentProfileInstance(ComponentName)} in order to set restrictions on the parent\n     * profile.\n     *\n     * @param admin Which {@link DeviceAdminReceiver} this request is associated with.\n     * @param length The new desired minimum number of symbols required in the password. A value of\n     *            0 means there is no restriction.\n     * @throws SecurityException if {@code admin} is not an active administrator or {@code admin}\n     *             does not use {@link DeviceAdminInfo#USES_POLICY_LIMIT_PASSWORD}\n     * @throws IllegalStateException if the calling app is targeting SDK level\n     *     {@link android.os.Build.VERSION_CODES#R} and above and didn't set a sufficient password\n     *     quality requirement prior to calling this method.\n     ",
    "links" : [ "#ACTION_SET_NEW_PASSWORD", "#ACTION_SET_NEW_PARENT_PROFILE_PASSWORD", "#PASSWORD_QUALITY_COMPLEX", "#setPasswordQuality", "android.os.Build.VERSION_CODES#R", "#PASSWORD_QUALITY_COMPLEX", "IllegalStateException", "PackageManager#FEATURE_SECURE_LOCK_SCREEN", "DeviceAdminInfo#USES_POLICY_LIMIT_PASSWORD", "DevicePolicyManager", "#getParentProfileInstance", "DeviceAdminReceiver", "DeviceAdminInfo#USES_POLICY_LIMIT_PASSWORD", "android.os.Build.VERSION_CODES#R" ]
  }, {
    "name" : "public int getPasswordMinimumSymbols(@Nullable ComponentName admin)",
    "returnType" : "int",
    "comment" : "\n     * Retrieve the current number of symbols required in the password\n     * for a particular admin or all admins that set restrictions on this user\n     * and its participating profiles. Restrictions on profiles that have\n     * a separate challenge are not taken into account. This is the same value as\n     * set by {@link #setPasswordMinimumSymbols(ComponentName, int)}\n     * and only applies when the password quality is\n     * {@link #PASSWORD_QUALITY_COMPLEX}.\n     *\n     * <p>On devices not supporting {@link PackageManager#FEATURE_SECURE_LOCK_SCREEN} feature, the\n     * password is always treated as empty.\n     *\n     * <p>This method can be called on the {@link DevicePolicyManager} instance\n     * returned by {@link #getParentProfileInstance(ComponentName)} in order to retrieve\n     * restrictions on the parent profile.\n     *\n     * @param admin The name of the admin component to check, or {@code null} to\n     *            aggregate all admins.\n     * @return The minimum number of symbols required in the password.\n     ",
    "links" : [ "#setPasswordMinimumSymbols", "#PASSWORD_QUALITY_COMPLEX", "PackageManager#FEATURE_SECURE_LOCK_SCREEN", "DevicePolicyManager", "#getParentProfileInstance" ]
  }, {
    "name" : "public int getPasswordMinimumSymbols(@Nullable ComponentName admin, int userHandle)",
    "returnType" : "int",
    "comment" : " @hide per-user version ",
    "links" : [ ]
  }, {
    "name" : "public void setPasswordMinimumNonLetter(@NonNull ComponentName admin, int length)",
    "returnType" : "void",
    "comment" : "\n     * Called by an application that is administering the device to set the minimum number of\n     * non-letter characters (numerical digits or symbols) required in the password. After setting\n     * this, the user will not be able to enter a new password that is not at least as restrictive\n     * as what has been set. Note that the current password will remain until the user has set a new\n     * one, so the change does not take place immediately. To prompt the user for a new password,\n     * use {@link #ACTION_SET_NEW_PASSWORD} or {@link #ACTION_SET_NEW_PARENT_PROFILE_PASSWORD} after\n     * setting this value. This constraint is only imposed if the administrator has also requested\n     * {@link #PASSWORD_QUALITY_COMPLEX} with {@link #setPasswordQuality}. If an app targeting\n     * SDK level {@link android.os.Build.VERSION_CODES#R} and above enforces this constraint without\n     * settings password quality to {@link #PASSWORD_QUALITY_COMPLEX} first, this method will throw\n     * {@link IllegalStateException}. The default value is 0.\n     * <p>\n     * On devices not supporting {@link PackageManager#FEATURE_SECURE_LOCK_SCREEN} feature, the\n     * password is always treated as empty.\n     * <p>\n     * The calling device admin must have requested\n     * {@link DeviceAdminInfo#USES_POLICY_LIMIT_PASSWORD} to be able to call this method; if it has\n     * not, a security exception will be thrown.\n     * <p>\n     * This method can be called on the {@link DevicePolicyManager} instance returned by\n     * {@link #getParentProfileInstance(ComponentName)} in order to set restrictions on the parent\n     * profile.\n     *\n     * @param admin Which {@link DeviceAdminReceiver} this request is associated with.\n     * @param length The new desired minimum number of letters required in the password. A value of\n     *            0 means there is no restriction.\n     * @throws SecurityException if {@code admin} is not an active administrator or {@code admin}\n     *             does not use {@link DeviceAdminInfo#USES_POLICY_LIMIT_PASSWORD}\n     * @throws IllegalStateException if the calling app is targeting SDK level\n     *     {@link android.os.Build.VERSION_CODES#R} and above and didn't set a sufficient password\n     *     quality requirement prior to calling this method.\n     ",
    "links" : [ "#ACTION_SET_NEW_PASSWORD", "#ACTION_SET_NEW_PARENT_PROFILE_PASSWORD", "#PASSWORD_QUALITY_COMPLEX", "#setPasswordQuality", "android.os.Build.VERSION_CODES#R", "#PASSWORD_QUALITY_COMPLEX", "IllegalStateException", "PackageManager#FEATURE_SECURE_LOCK_SCREEN", "DeviceAdminInfo#USES_POLICY_LIMIT_PASSWORD", "DevicePolicyManager", "#getParentProfileInstance", "DeviceAdminReceiver", "DeviceAdminInfo#USES_POLICY_LIMIT_PASSWORD", "android.os.Build.VERSION_CODES#R" ]
  }, {
    "name" : "public int getPasswordMinimumNonLetter(@Nullable ComponentName admin)",
    "returnType" : "int",
    "comment" : "\n     * Retrieve the current number of non-letter characters required in the password\n     * for a particular admin or all admins that set restrictions on this user\n     * and its participating profiles. Restrictions on profiles that have\n     * a separate challenge are not taken into account.\n     * This is the same value as set by\n     * {@link #setPasswordMinimumNonLetter(ComponentName, int)}\n     * and only applies when the password quality is\n     * {@link #PASSWORD_QUALITY_COMPLEX}.\n     *\n     * <p>On devices not supporting {@link PackageManager#FEATURE_SECURE_LOCK_SCREEN} feature, the\n     * password is always treated as empty.\n     *\n     * <p>This method can be called on the {@link DevicePolicyManager} instance\n     * returned by {@link #getParentProfileInstance(ComponentName)} in order to retrieve\n     * restrictions on the parent profile.\n     *\n     * @param admin The name of the admin component to check, or {@code null} to\n     *            aggregate all admins.\n     * @return The minimum number of letters required in the password.\n     ",
    "links" : [ "#setPasswordMinimumNonLetter", "#PASSWORD_QUALITY_COMPLEX", "PackageManager#FEATURE_SECURE_LOCK_SCREEN", "DevicePolicyManager", "#getParentProfileInstance" ]
  }, {
    "name" : "public int getPasswordMinimumNonLetter(@Nullable ComponentName admin, int userHandle)",
    "returnType" : "int",
    "comment" : " @hide per-user version ",
    "links" : [ ]
  }, {
    "name" : "public PasswordMetrics getPasswordMinimumMetrics(@UserIdInt int userHandle)",
    "returnType" : "PasswordMetrics",
    "comment" : "\n     * Returns minimum PasswordMetrics that satisfies all admin policies.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public void setPasswordHistoryLength(@NonNull ComponentName admin, int length)",
    "returnType" : "void",
    "comment" : "\n     * Called by an application that is administering the device to set the length of the password\n     * history. After setting this, the user will not be able to enter a new password that is the\n     * same as any password in the history. Note that the current password will remain until the\n     * user has set a new one, so the change does not take place immediately. To prompt the user for\n     * a new password, use {@link #ACTION_SET_NEW_PASSWORD} or\n     * {@link #ACTION_SET_NEW_PARENT_PROFILE_PASSWORD} after setting this value.\n     * <p>\n     * On devices not supporting {@link PackageManager#FEATURE_SECURE_LOCK_SCREEN} feature, the\n     * password history length is always 0.\n     * <p>\n     * The calling device admin must have requested\n     * {@link DeviceAdminInfo#USES_POLICY_LIMIT_PASSWORD} to be able to call this method; if it has\n     * not, a security exception will be thrown.\n     * <p>\n     * This method can be called on the {@link DevicePolicyManager} instance returned by\n     * {@link #getParentProfileInstance(ComponentName)} in order to set restrictions on the parent\n     * profile.\n     *\n     * @param admin Which {@link DeviceAdminReceiver} this request is associated with.\n     * @param length The new desired length of password history. A value of 0 means there is no\n     *            restriction.\n     * @throws SecurityException if {@code admin} is not an active administrator or {@code admin}\n     *             does not use {@link DeviceAdminInfo#USES_POLICY_LIMIT_PASSWORD}\n     ",
    "links" : [ "#ACTION_SET_NEW_PASSWORD", "#ACTION_SET_NEW_PARENT_PROFILE_PASSWORD", "PackageManager#FEATURE_SECURE_LOCK_SCREEN", "DeviceAdminInfo#USES_POLICY_LIMIT_PASSWORD", "DevicePolicyManager", "#getParentProfileInstance", "DeviceAdminReceiver", "DeviceAdminInfo#USES_POLICY_LIMIT_PASSWORD" ]
  }, {
    "name" : "public void setPasswordExpirationTimeout(@NonNull ComponentName admin, long timeout)",
    "returnType" : "void",
    "comment" : "\n     * Called by a device admin to set the password expiration timeout. Calling this method will\n     * restart the countdown for password expiration for the given admin, as will changing the\n     * device password (for all admins).\n     * <p>\n     * The provided timeout is the time delta in ms and will be added to the current time. For\n     * example, to have the password expire 5 days from now, timeout would be 5 * 86400 * 1000 =\n     * 432000000 ms for timeout.\n     * <p>\n     * To disable password expiration, a value of 0 may be used for timeout.\n     * <p>\n     * On devices not supporting {@link PackageManager#FEATURE_SECURE_LOCK_SCREEN} feature, the\n     * password expiration is always disabled.\n     * <p>\n     * The calling device admin must have requested\n     * {@link DeviceAdminInfo#USES_POLICY_EXPIRE_PASSWORD} to be able to call this method; if it has\n     * not, a security exception will be thrown.\n     * <p>\n     * Note that setting the password will automatically reset the expiration time for all active\n     * admins. Active admins do not need to explicitly call this method in that case.\n     * <p>\n     * This method can be called on the {@link DevicePolicyManager} instance returned by\n     * {@link #getParentProfileInstance(ComponentName)} in order to set restrictions on the parent\n     * profile.\n     *\n     * @param admin Which {@link DeviceAdminReceiver} this request is associated with.\n     * @param timeout The limit (in ms) that a password can remain in effect. A value of 0 means\n     *            there is no restriction (unlimited).\n     * @throws SecurityException if {@code admin} is not an active administrator or {@code admin}\n     *             does not use {@link DeviceAdminInfo#USES_POLICY_EXPIRE_PASSWORD}\n     ",
    "links" : [ "PackageManager#FEATURE_SECURE_LOCK_SCREEN", "DeviceAdminInfo#USES_POLICY_EXPIRE_PASSWORD", "DevicePolicyManager", "#getParentProfileInstance", "DeviceAdminReceiver", "DeviceAdminInfo#USES_POLICY_EXPIRE_PASSWORD" ]
  }, {
    "name" : "public long getPasswordExpirationTimeout(@Nullable ComponentName admin)",
    "returnType" : "long",
    "comment" : "\n     * Get the password expiration timeout for the given admin. The expiration timeout is the\n     * recurring expiration timeout provided in the call to\n     * {@link #setPasswordExpirationTimeout(ComponentName, long)} for the given admin or the\n     * aggregate of all participating policy administrators if {@code admin} is null. Admins that\n     * have set restrictions on profiles that have a separate challenge are not taken into account.\n     *\n     * <p>This method can be called on the {@link DevicePolicyManager} instance\n     * returned by {@link #getParentProfileInstance(ComponentName)} in order to retrieve\n     * restrictions on the parent profile.\n     *\n     * <p>On devices not supporting {@link PackageManager#FEATURE_SECURE_LOCK_SCREEN} feature, the\n     * password expiration is always disabled and this method always returns 0.\n     *\n     * @param admin The name of the admin component to check, or {@code null} to aggregate all admins.\n     * @return The timeout for the given admin or the minimum of all timeouts\n     ",
    "links" : [ "#setPasswordExpirationTimeout", "DevicePolicyManager", "#getParentProfileInstance", "PackageManager#FEATURE_SECURE_LOCK_SCREEN" ]
  }, {
    "name" : "public long getPasswordExpiration(@Nullable ComponentName admin)",
    "returnType" : "long",
    "comment" : "\n     * Get the current password expiration time for a particular admin or all admins that set\n     * restrictions on this user and its participating profiles. Restrictions on profiles that have\n     * a separate challenge are not taken into account. If admin is {@code null}, then a composite\n     * of all expiration times is returned - which will be the minimum of all of them.\n     *\n     * <p>This method can be called on the {@link DevicePolicyManager} instance\n     * returned by {@link #getParentProfileInstance(ComponentName)} in order to retrieve\n     * the password expiration for the parent profile.\n     *\n     * <p>On devices not supporting {@link PackageManager#FEATURE_SECURE_LOCK_SCREEN} feature, the\n     * password expiration is always disabled and this method always returns 0.\n     *\n     * @param admin The name of the admin component to check, or {@code null} to aggregate all admins.\n     * @return The password expiration time, in milliseconds since epoch.\n     ",
    "links" : [ "DevicePolicyManager", "#getParentProfileInstance", "PackageManager#FEATURE_SECURE_LOCK_SCREEN" ]
  }, {
    "name" : "public int getPasswordHistoryLength(@Nullable ComponentName admin)",
    "returnType" : "int",
    "comment" : "\n     * Retrieve the current password history length for a particular admin or all admins that\n     * set restrictions on this user and its participating profiles. Restrictions on profiles that\n     * have a separate challenge are not taken into account.\n     *\n     * <p>This method can be called on the {@link DevicePolicyManager} instance\n     * returned by {@link #getParentProfileInstance(ComponentName)} in order to retrieve\n     * restrictions on the parent profile.\n     *\n     * <p>On devices not supporting {@link PackageManager#FEATURE_SECURE_LOCK_SCREEN} feature, the\n     * password history length is always 0.\n     *\n     * @param admin The name of the admin component to check, or {@code null} to aggregate\n     * all admins.\n     * @return The length of the password history\n     ",
    "links" : [ "DevicePolicyManager", "#getParentProfileInstance", "PackageManager#FEATURE_SECURE_LOCK_SCREEN" ]
  }, {
    "name" : "public int getPasswordHistoryLength(@Nullable ComponentName admin, int userHandle)",
    "returnType" : "int",
    "comment" : " @hide per-user version ",
    "links" : [ ]
  }, {
    "name" : "public int getPasswordMaximumLength(int quality)",
    "returnType" : "int",
    "comment" : "\n     * Return the maximum password length that the device supports for a\n     * particular password quality.\n     * <p>On devices not supporting {@link PackageManager#FEATURE_SECURE_LOCK_SCREEN} feature, the\n     * password is always empty and this method always returns 0.\n     * @param quality The quality being interrogated.\n     * @return Returns the maximum length that the user can enter.\n     ",
    "links" : [ "PackageManager#FEATURE_SECURE_LOCK_SCREEN" ]
  }, {
    "name" : "public boolean isActivePasswordSufficient()",
    "returnType" : "boolean",
    "comment" : "\n     * Determines whether the calling user's current password meets policy requirements\n     * (e.g. quality, minimum length). The user must be unlocked to perform this check.\n     *\n     * <p>Policy requirements which affect this check can be set by admins of the user, but also\n     * by the admin of a managed profile associated with the calling user (when the managed profile\n     * doesn't have a separate work challenge). When a managed profile has a separate work\n     * challenge, its policy requirements only affect the managed profile.\n     *\n     * <p>Depending on the user, this method checks the policy requirement against one of the\n     * following passwords:\n     * <ul>\n     * <li>For the primary user or secondary users: the personal keyguard password.\n     * <li>For managed profiles: a work challenge if set, otherwise the parent user's personal\n     *     keyguard password.\n     * <ul/>\n     * In other words, it's always checking the requirement against the password that is protecting\n     * the calling user.\n     *\n     * <p>Note that this method considers all policy requirements targeting the password in\n     * question. For example a profile owner might set a requirement on the parent profile i.e.\n     * personal keyguard but not on the profile itself. When the device has a weak personal keyguard\n     * password and no separate work challenge, calling this method will return {@code false}\n     * despite the profile owner not setting a policy on the profile itself. This is because the\n     * profile's current password is the personal keyguard password, and it does not meet all policy\n     * requirements.\n     *\n     * <p>Device admins must request {@link DeviceAdminInfo#USES_POLICY_LIMIT_PASSWORD} before\n     * calling this method. Note, this policy type is deprecated for device admins in Android 9.0\n     * (API level 28) or higher.\n     *\n     * <p>This method can be called on the {@link DevicePolicyManager} instance returned by\n     * {@link #getParentProfileInstance(ComponentName)} in order to determine if the password set on\n     * the parent profile is sufficient.\n     *\n     * <p>On devices not supporting {@link PackageManager#FEATURE_SECURE_LOCK_SCREEN} feature, the\n     * password is always treated as empty - i.e. this method will always return false on such\n     * devices, provided any password requirements were set.\n     *\n     * @return {@code true} if the password meets the policy requirements, {@code false} otherwise\n     * @throws SecurityException if the calling application isn't an active admin that uses\n     *     {@link DeviceAdminInfo#USES_POLICY_LIMIT_PASSWORD}\n     * @throws IllegalStateException if the user isn't unlocked\n     ",
    "links" : [ "DeviceAdminInfo#USES_POLICY_LIMIT_PASSWORD", "DevicePolicyManager", "#getParentProfileInstance", "PackageManager#FEATURE_SECURE_LOCK_SCREEN", "DeviceAdminInfo#USES_POLICY_LIMIT_PASSWORD" ]
  }, {
    "name" : "public int getPasswordComplexity()",
    "returnType" : "int",
    "comment" : "\n     * Returns how complex the current user's screen lock is.\n     *\n     * <p>Note that when called from a profile which uses an unified challenge with its parent, the\n     * screen lock complexity of the parent will be returned.\n     *\n     * <p>This method can be called on the {@link DevicePolicyManager} instance\n     * returned by {@link #getParentProfileInstance(ComponentName)} in order to retrieve\n     * restrictions on the parent profile.\n     *\n     * @throws IllegalStateException if the user is not unlocked.\n     * @throws SecurityException     if the calling application does not have the permission\n     *                               {@link permission#REQUEST_PASSWORD_COMPLEXITY}\n     ",
    "links" : [ "DevicePolicyManager", "#getParentProfileInstance", "permission#REQUEST_PASSWORD_COMPLEXITY" ]
  }, {
    "name" : "public boolean isUsingUnifiedPassword(@NonNull ComponentName admin)",
    "returnType" : "boolean",
    "comment" : "\n     * When called by a profile owner of a managed profile returns true if the profile uses unified\n     * challenge with its parent user.\n     *\n     * <strong>Note</strong>: This method is not concerned with password quality and will return\n     * false if the profile has empty password as a separate challenge.\n     *\n     * @param admin Which {@link DeviceAdminReceiver} this request is associated with.\n     * @throws SecurityException if {@code admin} is not a profile owner of a managed profile.\n     * @see UserManager#DISALLOW_UNIFIED_PASSWORD\n     ",
    "links" : [ "DeviceAdminReceiver" ]
  }, {
    "name" : "public boolean isProfileActivePasswordSufficientForParent(int userHandle)",
    "returnType" : "boolean",
    "comment" : "\n     * Determine whether the current profile password the user has set is sufficient\n     * to meet the policy requirements (e.g. quality, minimum length) that have been\n     * requested by the admins of the parent user and its profiles.\n     *\n     * @param userHandle the userId of the profile to check the password for.\n     * @return Returns true if the password would meet the current requirements, else false.\n     * @throws SecurityException if {@code userHandle} is not a managed profile.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean isPasswordSufficientAfterProfileUnification(int userHandle, int profileUser)",
    "returnType" : "boolean",
    "comment" : "\n     * Returns whether the given user's credential will be sufficient for all password policy\n     * requirement, once the user's profile has switched to unified challenge.\n     *\n     * <p>This is different from {@link #isActivePasswordSufficient()} since once the profile\n     * switches to unified challenge, policies set explicitly on the profile will start to affect\n     * the parent user.\n     * @param userHandle the user whose password requirement will be checked\n     * @param profileUser the profile user whose lockscreen challenge will be unified.\n     * @hide\n     ",
    "links" : [ "#isActivePasswordSufficient" ]
  }, {
    "name" : "public int getCurrentFailedPasswordAttempts()",
    "returnType" : "int",
    "comment" : "\n     * Retrieve the number of times the user has failed at entering a password since that last\n     * successful password entry.\n     * <p>\n     * This method can be called on the {@link DevicePolicyManager} instance returned by\n     * {@link #getParentProfileInstance(ComponentName)} in order to retrieve the number of failed\n     * password attemts for the parent user.\n     * <p>\n     * The calling device admin must have requested {@link DeviceAdminInfo#USES_POLICY_WATCH_LOGIN}\n     * to be able to call this method; if it has not, a security exception will be thrown.\n     * <p>On devices not supporting {@link PackageManager#FEATURE_SECURE_LOCK_SCREEN} feature, the\n     * password is always empty and this method always returns 0.\n     *\n     * @return The number of times user has entered an incorrect password since the last correct\n     *         password entry.\n     * @throws SecurityException if the calling application does not own an active administrator\n     *             that uses {@link DeviceAdminInfo#USES_POLICY_WATCH_LOGIN}\n     ",
    "links" : [ "DevicePolicyManager", "#getParentProfileInstance", "DeviceAdminInfo#USES_POLICY_WATCH_LOGIN", "PackageManager#FEATURE_SECURE_LOCK_SCREEN", "DeviceAdminInfo#USES_POLICY_WATCH_LOGIN" ]
  }, {
    "name" : "public int getCurrentFailedPasswordAttempts(int userHandle)",
    "returnType" : "int",
    "comment" : "\n     * Retrieve the number of times the given user has failed at entering a\n     * password since that last successful password entry.\n     *\n     * <p>The calling device admin must have requested\n     * {@link DeviceAdminInfo#USES_POLICY_WATCH_LOGIN} to be able to call this method; if it has\n     * not and it is not the system uid, a security exception will be thrown.\n     *\n     * @hide\n     ",
    "links" : [ "DeviceAdminInfo#USES_POLICY_WATCH_LOGIN" ]
  }, {
    "name" : "public boolean getDoNotAskCredentialsOnBoot()",
    "returnType" : "boolean",
    "comment" : "\n     * Queries whether {@link #RESET_PASSWORD_DO_NOT_ASK_CREDENTIALS_ON_BOOT} flag is set.\n     *\n     * @return true if RESET_PASSWORD_DO_NOT_ASK_CREDENTIALS_ON_BOOT flag is set.\n     * @hide\n     ",
    "links" : [ "#RESET_PASSWORD_DO_NOT_ASK_CREDENTIALS_ON_BOOT" ]
  }, {
    "name" : "public void setMaximumFailedPasswordsForWipe(@NonNull ComponentName admin, int num)",
    "returnType" : "void",
    "comment" : "\n     * Setting this to a value greater than zero enables a built-in policy that will perform a\n     * device or profile wipe after too many incorrect device-unlock passwords have been entered.\n     * This built-in policy combines watching for failed passwords and wiping the device, and\n     * requires that you request both {@link DeviceAdminInfo#USES_POLICY_WATCH_LOGIN} and\n     * {@link DeviceAdminInfo#USES_POLICY_WIPE_DATA}}.\n     * <p>\n     * When this policy is set by a device owner, profile owner of an organization-owned device or\n     * an admin on the primary user, the device will be factory reset after too many incorrect\n     * password attempts. When set by a profile owner or an admin on a secondary user or a managed\n     * profile, only the corresponding user or profile will be wiped.\n     * <p>\n     * To implement any other policy (e.g. wiping data for a particular application only, erasing or\n     * revoking credentials, or reporting the failure to a server), you should implement\n     * {@link DeviceAdminReceiver#onPasswordFailed(Context, android.content.Intent)} instead. Do not\n     * use this API, because if the maximum count is reached, the device or profile will be wiped\n     * immediately, and your callback will not be invoked.\n     * <p>\n     * This method can be called on the {@link DevicePolicyManager} instance returned by\n     * {@link #getParentProfileInstance(ComponentName)} in order to set a value on the parent\n     * profile.\n     * <p>On devices not supporting {@link PackageManager#FEATURE_SECURE_LOCK_SCREEN} feature, the\n     * password is always empty and this method has no effect - i.e. the policy is not set.\n     *\n     * @param admin Which {@link DeviceAdminReceiver} this request is associated with.\n     * @param num The number of failed password attempts at which point the device or profile will\n     *            be wiped.\n     * @throws SecurityException if {@code admin} is not an active administrator or does not use\n     *             both {@link DeviceAdminInfo#USES_POLICY_WATCH_LOGIN} and\n     *             {@link DeviceAdminInfo#USES_POLICY_WIPE_DATA}.\n     ",
    "links" : [ "DeviceAdminInfo#USES_POLICY_WATCH_LOGIN", "DeviceAdminInfo#USES_POLICY_WIPE_DATA", "DeviceAdminReceiver#onPasswordFailed", "DevicePolicyManager", "#getParentProfileInstance", "PackageManager#FEATURE_SECURE_LOCK_SCREEN", "DeviceAdminReceiver", "DeviceAdminInfo#USES_POLICY_WATCH_LOGIN", "DeviceAdminInfo#USES_POLICY_WIPE_DATA" ]
  }, {
    "name" : "public int getMaximumFailedPasswordsForWipe(@Nullable ComponentName admin)",
    "returnType" : "int",
    "comment" : "\n     * Retrieve the current maximum number of login attempts that are allowed before the device\n     * or profile is wiped, for a particular admin or all admins that set restrictions on this user\n     * and its participating profiles. Restrictions on profiles that have a separate challenge are\n     * not taken into account.\n     *\n     * <p>This method can be called on the {@link DevicePolicyManager} instance\n     * returned by {@link #getParentProfileInstance(ComponentName)} in order to retrieve\n     * the value for the parent profile.\n     *\n     * <p>On devices not supporting {@link PackageManager#FEATURE_SECURE_LOCK_SCREEN} feature, the\n     * password is always empty and this method returns a default value (0) indicating that the\n     * policy is not set.\n     *\n     * @param admin The name of the admin component to check, or {@code null} to aggregate\n     * all admins.\n     ",
    "links" : [ "DevicePolicyManager", "#getParentProfileInstance", "PackageManager#FEATURE_SECURE_LOCK_SCREEN" ]
  }, {
    "name" : "public int getMaximumFailedPasswordsForWipe(@Nullable ComponentName admin, int userHandle)",
    "returnType" : "int",
    "comment" : " @hide per-user version ",
    "links" : [ ]
  }, {
    "name" : "public int getProfileWithMinimumFailedPasswordsForWipe(int userHandle)",
    "returnType" : "int",
    "comment" : "\n     * Returns the user that will be wiped first when too many failed attempts are made to unlock\n     * user {@code userHandle}. That user is either the same as {@code userHandle} or belongs to the\n     * same profile group. When there is no such policy, returns {@code UserHandle.USER_NULL}.\n     * E.g. managed profile user may be wiped as a result of failed primary profile password\n     * attempts when using unified challenge. Primary user may be wiped as a result of failed\n     * password attempts on the managed profile on an organization-owned device.\n     * @hide Used only by Keyguard\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean resetPassword(String password, int flags)",
    "returnType" : "boolean",
    "comment" : "\n     * Force a new password for device unlock (the password needed to access the entire device) or\n     * the work profile challenge on the current user. This takes effect immediately.\n     *\n     * <p> Before {@link android.os.Build.VERSION_CODES#N}, this API is available to device admin,\n     * profile owner and device owner. Starting from {@link android.os.Build.VERSION_CODES#N},\n     * legacy device admin (who is not also profile owner or device owner) can only call this\n     * API to set a new password if there is currently no password set. Profile owner and device\n     * owner can continue to force change an existing password as long as the target user is\n     * unlocked, although device owner will not be able to call this API at all if there is also a\n     * managed profile on the device.\n     *\n     * <p> Between {@link android.os.Build.VERSION_CODES#O},\n     * {@link android.os.Build.VERSION_CODES#P} and {@link android.os.Build.VERSION_CODES#Q},\n     * profile owner and devices owner targeting SDK level {@link android.os.Build.VERSION_CODES#O}\n     * or above who attempt to call this API will receive {@link SecurityException}; they are\n     * encouraged to migrate to the new {@link #resetPasswordWithToken} API instead.\n     * Profile owner and device owner targeting older SDK levels are not affected: they continue\n     * to experience the existing behaviour described in the previous paragraph.\n     *\n     * <p><em>Starting from {@link android.os.Build.VERSION_CODES#R}, this API is no longer\n     * supported in most cases.</em> Device owner and profile owner calling\n     * this API will receive {@link SecurityException} if they target SDK level\n     * {@link android.os.Build.VERSION_CODES#O} or above, or they will receive a silent failure\n     * (API returning {@code false}) if they target lower SDK level.\n     * For legacy device admins, this API throws {@link SecurityException} if they target SDK level\n     * {@link android.os.Build.VERSION_CODES#N} or above, and returns {@code false} otherwise. Only\n     * privileged apps holding RESET_PASSWORD permission which are part of\n     * the system factory image can still call this API to set a new password if there is currently\n     * no password set. In this case, if the device already has a password, this API will throw\n     * {@link SecurityException}.\n     *\n     * <p>\n     * The given password must be sufficient for the current password quality and length constraints\n     * as returned by {@link #getPasswordQuality(ComponentName)} and\n     * {@link #getPasswordMinimumLength(ComponentName)}; if it does not meet these constraints, then\n     * it will be rejected and false returned. Note that the password may be a stronger quality\n     * (containing alphanumeric characters when the requested quality is only numeric), in which\n     * case the currently active quality will be increased to match.\n     *\n     * <p>On devices not supporting {@link PackageManager#FEATURE_SECURE_LOCK_SCREEN} feature, this\n     * methods does nothing.\n     * <p>\n     * The calling device admin must have requested\n     * {@link DeviceAdminInfo#USES_POLICY_RESET_PASSWORD} to be able to call this method; if it has\n     * not, a security exception will be thrown.\n     *\n     * @param password The new password for the user. Null or empty clears the password.\n     * @param flags May be 0 or combination of {@link #RESET_PASSWORD_REQUIRE_ENTRY} and\n     *            {@link #RESET_PASSWORD_DO_NOT_ASK_CREDENTIALS_ON_BOOT}.\n     * @return Returns true if the password was applied, or false if it is not acceptable for the\n     *         current constraints.\n     * @throws SecurityException if the calling application does not own an active administrator\n     *             that uses {@link DeviceAdminInfo#USES_POLICY_RESET_PASSWORD}\n     * @throws IllegalStateException if the calling user is locked or has a managed profile.\n     * @deprecated Please use {@link #resetPasswordWithToken} instead.\n     ",
    "links" : [ "android.os.Build.VERSION_CODES#N", "android.os.Build.VERSION_CODES#N", "android.os.Build.VERSION_CODES#O", "android.os.Build.VERSION_CODES#P", "android.os.Build.VERSION_CODES#Q", "android.os.Build.VERSION_CODES#O", "SecurityException", "#resetPasswordWithToken", "android.os.Build.VERSION_CODES#R", "SecurityException", "android.os.Build.VERSION_CODES#O", "SecurityException", "android.os.Build.VERSION_CODES#N", "SecurityException", "#getPasswordQuality", "#getPasswordMinimumLength", "PackageManager#FEATURE_SECURE_LOCK_SCREEN", "DeviceAdminInfo#USES_POLICY_RESET_PASSWORD", "#RESET_PASSWORD_REQUIRE_ENTRY", "#RESET_PASSWORD_DO_NOT_ASK_CREDENTIALS_ON_BOOT", "DeviceAdminInfo#USES_POLICY_RESET_PASSWORD", "#resetPasswordWithToken" ]
  }, {
    "name" : "public boolean setResetPasswordToken(ComponentName admin, byte[] token)",
    "returnType" : "boolean",
    "comment" : "\n     * Called by a profile or device owner to provision a token which can later be used to reset the\n     * device lockscreen password (if called by device owner), or managed profile challenge (if\n     * called by profile owner), via {@link #resetPasswordWithToken}.\n     * <p>\n     * If the user currently has a lockscreen password, the provisioned token will not be\n     * immediately usable; it only becomes active after the user performs a confirm credential\n     * operation, which can be triggered by {@link KeyguardManager#createConfirmDeviceCredentialIntent}.\n     * If the user has no lockscreen password, the token is activated immediately. In all cases,\n     * the active state of the current token can be checked by {@link #isResetPasswordTokenActive}.\n     * For security reasons, un-activated tokens are only stored in memory and will be lost once\n     * the device reboots. In this case a new token needs to be provisioned again.\n     * <p>\n     * Once provisioned and activated, the token will remain effective even if the user changes\n     * or clears the lockscreen password.\n     * <p>\n     * <em>This token is highly sensitive and should be treated at the same level as user\n     * credentials. In particular, NEVER store this token on device in plaintext. Do not store\n     * the plaintext token in device-encrypted storage if it will be needed to reset password on\n     * file-based encryption devices before user unlocks. Consider carefully how any password token\n     * will be stored on your server and who will need access to them. Tokens may be the subject of\n     * legal access requests.\n     * </em>\n     * <p>On devices not supporting {@link PackageManager#FEATURE_SECURE_LOCK_SCREEN} feature, the\n     * reset token is not set and this method returns false.\n     *\n     * @param admin Which {@link DeviceAdminReceiver} this request is associated with.\n     * @param token a secure token a least 32-byte long, which must be generated by a\n     *        cryptographically strong random number generator.\n     * @return true if the operation is successful, false otherwise.\n     * @throws SecurityException if admin is not a device or profile owner.\n     * @throws IllegalArgumentException if the supplied token is invalid.\n     ",
    "links" : [ "#resetPasswordWithToken", "KeyguardManager#createConfirmDeviceCredentialIntent", "#isResetPasswordTokenActive", "PackageManager#FEATURE_SECURE_LOCK_SCREEN", "DeviceAdminReceiver" ]
  }, {
    "name" : "public boolean clearResetPasswordToken(ComponentName admin)",
    "returnType" : "boolean",
    "comment" : "\n     * Called by a profile or device owner to revoke the current password reset token.\n     *\n     * <p>On devices not supporting {@link PackageManager#FEATURE_SECURE_LOCK_SCREEN} feature, this\n     * method has no effect - the reset token should not have been set in the first place - and\n     * false is returned.\n     *\n     * @param admin Which {@link DeviceAdminReceiver} this request is associated with.\n     * @return true if the operation is successful, false otherwise.\n     * @throws SecurityException if admin is not a device or profile owner.\n     ",
    "links" : [ "PackageManager#FEATURE_SECURE_LOCK_SCREEN", "DeviceAdminReceiver" ]
  }, {
    "name" : "public boolean isResetPasswordTokenActive(ComponentName admin)",
    "returnType" : "boolean",
    "comment" : "\n     * Called by a profile or device owner to check if the current reset password token is active.\n     *\n     * <p>On devices not supporting {@link PackageManager#FEATURE_SECURE_LOCK_SCREEN} feature,\n     * false is always returned.\n     *\n     * @param admin Which {@link DeviceAdminReceiver} this request is associated with.\n     * @return true if the token is active, false otherwise.\n     * @throws SecurityException if admin is not a device or profile owner.\n     * @throws IllegalStateException if no token has been set.\n     ",
    "links" : [ "PackageManager#FEATURE_SECURE_LOCK_SCREEN", "DeviceAdminReceiver" ]
  }, {
    "name" : "public boolean resetPasswordWithToken(@NonNull ComponentName admin, String password, byte[] token, int flags)",
    "returnType" : "boolean",
    "comment" : "\n     * Called by device or profile owner to force set a new device unlock password or a managed\n     * profile challenge on current user. This takes effect immediately.\n     * <p>\n     * Unlike {@link #resetPassword}, this API can change the password even before the user or\n     * device is unlocked or decrypted. The supplied token must have been previously provisioned via\n     * {@link #setResetPasswordToken}, and in active state {@link #isResetPasswordTokenActive}.\n     * <p>\n     * The given password must be sufficient for the current password quality and length constraints\n     * as returned by {@link #getPasswordQuality(ComponentName)} and\n     * {@link #getPasswordMinimumLength(ComponentName)}; if it does not meet these constraints, then\n     * it will be rejected and false returned. Note that the password may be a stronger quality, for\n     * example, a password containing alphanumeric characters when the requested quality is only\n     * numeric.\n     * <p>\n     * Calling with a {@code null} or empty password will clear any existing PIN, pattern or\n     * password if the current password constraints allow it.\n     * <p>On devices not supporting {@link PackageManager#FEATURE_SECURE_LOCK_SCREEN} feature,\n     * calling this methods has no effect - the password is always empty - and false is returned.\n     *\n     * @param admin Which {@link DeviceAdminReceiver} this request is associated with.\n     * @param password The new password for the user. {@code null} or empty clears the password.\n     * @param token the password reset token previously provisioned by\n     *        {@link #setResetPasswordToken}.\n     * @param flags May be 0 or combination of {@link #RESET_PASSWORD_REQUIRE_ENTRY} and\n     *        {@link #RESET_PASSWORD_DO_NOT_ASK_CREDENTIALS_ON_BOOT}.\n     * @return Returns true if the password was applied, or false if it is not acceptable for the\n     *         current constraints.\n     * @throws SecurityException if admin is not a device or profile owner.\n     * @throws IllegalStateException if the provided token is not valid.\n     ",
    "links" : [ "#resetPassword", "#setResetPasswordToken", "#isResetPasswordTokenActive", "#getPasswordQuality", "#getPasswordMinimumLength", "PackageManager#FEATURE_SECURE_LOCK_SCREEN", "DeviceAdminReceiver", "#setResetPasswordToken", "#RESET_PASSWORD_REQUIRE_ENTRY", "#RESET_PASSWORD_DO_NOT_ASK_CREDENTIALS_ON_BOOT" ]
  }, {
    "name" : "public void setMaximumTimeToLock(@NonNull ComponentName admin, long timeMs)",
    "returnType" : "void",
    "comment" : "\n     * Called by an application that is administering the device to set the maximum time for user\n     * activity until the device will lock. This limits the length that the user can set. It takes\n     * effect immediately.\n     * <p>\n     * The calling device admin must have requested {@link DeviceAdminInfo#USES_POLICY_FORCE_LOCK}\n     * to be able to call this method; if it has not, a security exception will be thrown.\n     * <p>\n     * This method can be called on the {@link DevicePolicyManager} instance returned by\n     * {@link #getParentProfileInstance(ComponentName)} in order to set restrictions on the parent\n     * profile.\n     *\n     * @param admin Which {@link DeviceAdminReceiver} this request is associated with.\n     * @param timeMs The new desired maximum time to lock in milliseconds. A value of 0 means there\n     *            is no restriction.\n     * @throws SecurityException if {@code admin} is not an active administrator or it does not use\n     *             {@link DeviceAdminInfo#USES_POLICY_FORCE_LOCK}\n     ",
    "links" : [ "DeviceAdminInfo#USES_POLICY_FORCE_LOCK", "DevicePolicyManager", "#getParentProfileInstance", "DeviceAdminReceiver", "DeviceAdminInfo#USES_POLICY_FORCE_LOCK" ]
  }, {
    "name" : "public long getMaximumTimeToLock(@Nullable ComponentName admin)",
    "returnType" : "long",
    "comment" : "\n     * Retrieve the current maximum time to unlock for a particular admin or all admins that set\n     * restrictions on this user and its participating profiles. Restrictions on profiles that have\n     * a separate challenge are not taken into account.\n     *\n     * <p>This method can be called on the {@link DevicePolicyManager} instance\n     * returned by {@link #getParentProfileInstance(ComponentName)} in order to retrieve\n     * restrictions on the parent profile.\n     *\n     * @param admin The name of the admin component to check, or {@code null} to aggregate\n     * all admins.\n     * @return time in milliseconds for the given admin or the minimum value (strictest) of\n     * all admins if admin is null. Returns 0 if there are no restrictions.\n     ",
    "links" : [ "DevicePolicyManager", "#getParentProfileInstance" ]
  }, {
    "name" : "public long getMaximumTimeToLock(@Nullable ComponentName admin, int userHandle)",
    "returnType" : "long",
    "comment" : " @hide per-user version ",
    "links" : [ ]
  }, {
    "name" : "public void setRequiredStrongAuthTimeout(@NonNull ComponentName admin, long timeoutMs)",
    "returnType" : "void",
    "comment" : "\n     * Called by a device/profile owner to set the timeout after which unlocking with secondary, non\n     * strong auth (e.g. fingerprint, face, trust agents) times out, i.e. the user has to use a\n     * strong authentication method like password, pin or pattern.\n     *\n     * <p>This timeout is used internally to reset the timer to require strong auth again after\n     * specified timeout each time it has been successfully used.\n     *\n     * <p>Fingerprint can also be disabled altogether using {@link #KEYGUARD_DISABLE_FINGERPRINT}.\n     *\n     * <p>Trust agents can also be disabled altogether using {@link #KEYGUARD_DISABLE_TRUST_AGENTS}.\n     *\n     * <p>The calling device admin must be a device or profile owner. If it is not,\n     * a {@link SecurityException} will be thrown.\n     *\n     * <p>The calling device admin can verify the value it has set by calling\n     * {@link #getRequiredStrongAuthTimeout(ComponentName)} and passing in its instance.\n     *\n     * <p>This method can be called on the {@link DevicePolicyManager} instance returned by\n     * {@link #getParentProfileInstance(ComponentName)} in order to set restrictions on the parent\n     * profile.\n     *\n     * <p>On devices not supporting {@link PackageManager#FEATURE_SECURE_LOCK_SCREEN} feature,\n     * calling this methods has no effect - i.e. the timeout is not set.\n     *\n     * @param admin Which {@link DeviceAdminReceiver} this request is associated with.\n     * @param timeoutMs The new timeout in milliseconds, after which the user will have to unlock\n     *         with strong authentication method. A value of 0 means the admin is not participating\n     *         in controlling the timeout.\n     *         The minimum and maximum timeouts are platform-defined and are typically 1 hour and\n     *         72 hours, respectively. Though discouraged, the admin may choose to require strong\n     *         auth at all times using {@link #KEYGUARD_DISABLE_FINGERPRINT} and/or\n     *         {@link #KEYGUARD_DISABLE_TRUST_AGENTS}.\n     *\n     * @throws SecurityException if {@code admin} is not a device or profile owner.\n     ",
    "links" : [ "#KEYGUARD_DISABLE_FINGERPRINT", "#KEYGUARD_DISABLE_TRUST_AGENTS", "SecurityException", "#getRequiredStrongAuthTimeout", "DevicePolicyManager", "#getParentProfileInstance", "PackageManager#FEATURE_SECURE_LOCK_SCREEN", "DeviceAdminReceiver", "#KEYGUARD_DISABLE_FINGERPRINT", "#KEYGUARD_DISABLE_TRUST_AGENTS" ]
  }, {
    "name" : "public long getRequiredStrongAuthTimeout(@Nullable ComponentName admin)",
    "returnType" : "long",
    "comment" : "\n     * Determine for how long the user will be able to use secondary, non strong auth for\n     * authentication, since last strong method authentication (password, pin or pattern) was used.\n     * After the returned timeout the user is required to use strong authentication method.\n     *\n     * <p>This method can be called on the {@link DevicePolicyManager} instance\n     * returned by {@link #getParentProfileInstance(ComponentName)} in order to retrieve\n     * restrictions on the parent profile.\n     *\n     * <p>On devices not supporting {@link PackageManager#FEATURE_SECURE_LOCK_SCREEN} feature,\n     * 0 is returned to indicate that no timeout is configured.\n     *\n     * @param admin The name of the admin component to check, or {@code null} to aggregate\n     *         across all participating admins.\n     * @return The timeout in milliseconds or 0 if not configured for the provided admin.\n     ",
    "links" : [ "DevicePolicyManager", "#getParentProfileInstance", "PackageManager#FEATURE_SECURE_LOCK_SCREEN" ]
  }, {
    "name" : "public long getRequiredStrongAuthTimeout(@Nullable ComponentName admin, @UserIdInt int userId)",
    "returnType" : "long",
    "comment" : " @hide per-user version ",
    "links" : [ ]
  }, {
    "name" : "public void lockNow()",
    "returnType" : "void",
    "comment" : "\n     * Make the device lock immediately, as if the lock screen timeout has expired at the point of\n     * this call.\n     * <p>\n     * This method secures the device in response to an urgent situation, such as a lost or stolen\n     * device. After this method is called, the device must be unlocked using strong authentication\n     * (PIN, pattern, or password). This API is intended for use only by device admins.\n     * <p>\n     * From version {@link android.os.Build.VERSION_CODES#R} onwards, the caller must either have\n     * the LOCK_DEVICE permission or the device must have the device admin feature; if neither is\n     * true, then the method will return without completing any action. Before version\n     * {@link android.os.Build.VERSION_CODES#R}, the device needed the device admin feature,\n     * regardless of the caller's permissions.\n     * <p>\n     * The calling device admin must have requested {@link DeviceAdminInfo#USES_POLICY_FORCE_LOCK}\n     * to be able to call this method; if it has not, a security exception will be thrown.\n     * <p>\n     * If there's no lock type set, this method forces the device to go to sleep but doesn't lock\n     * the device. Device admins who find the device in this state can lock an otherwise-insecure\n     * device by first calling {@link #resetPassword} to set the password and then lock the device.\n     * <p>\n     * This method can be called on the {@link DevicePolicyManager} instance returned by\n     * {@link #getParentProfileInstance(ComponentName)} in order to lock the parent profile.\n     * <p>\n     * Equivalent to calling {@link #lockNow(int)} with no flags.\n     *\n     * @throws SecurityException if the calling application does not own an active administrator\n     *             that uses {@link DeviceAdminInfo#USES_POLICY_FORCE_LOCK}\n     ",
    "links" : [ "android.os.Build.VERSION_CODES#R", "android.os.Build.VERSION_CODES#R", "DeviceAdminInfo#USES_POLICY_FORCE_LOCK", "#resetPassword", "DevicePolicyManager", "#getParentProfileInstance", "#lockNow", "DeviceAdminInfo#USES_POLICY_FORCE_LOCK" ]
  }, {
    "name" : "public void lockNow(@LockNowFlag int flags)",
    "returnType" : "void",
    "comment" : "\n     * Make the device lock immediately, as if the lock screen timeout has expired at the point of\n     * this call.\n     * <p>\n     * This method secures the device in response to an urgent situation, such as a lost or stolen\n     * device. After this method is called, the device must be unlocked using strong authentication\n     * (PIN, pattern, or password). This API is intended for use only by device admins.\n     * <p>\n     * From version {@link android.os.Build.VERSION_CODES#R} onwards, the caller must either have\n     * the LOCK_DEVICE permission or the device must have the device admin feature; if neither is\n     * true, then the method will return without completing any action. Before version\n     * {@link android.os.Build.VERSION_CODES#R}, the device needed the device admin feature,\n     * regardless of the caller's permissions.\n     * <p>\n     * The calling device admin must have requested {@link DeviceAdminInfo#USES_POLICY_FORCE_LOCK}\n     * to be able to call this method; if it has not, a security exception will be thrown.\n     * <p>\n     * If there's no lock type set, this method forces the device to go to sleep but doesn't lock\n     * the device. Device admins who find the device in this state can lock an otherwise-insecure\n     * device by first calling {@link #resetPassword} to set the password and then lock the device.\n     * <p>\n     * This method can be called on the {@link DevicePolicyManager} instance returned by\n     * {@link #getParentProfileInstance(ComponentName)} in order to lock the parent profile as\n     * well as the managed profile.\n     * <p>\n     * NOTE: In order to lock the parent profile and evict the encryption key of the managed\n     * profile, {@link #lockNow()} must be called twice: First, {@link #lockNow()} should be called\n     * on the {@link DevicePolicyManager} instance returned by\n     * {@link #getParentProfileInstance(ComponentName)}, then {@link #lockNow(int)} should be\n     * called on the {@link DevicePolicyManager} instance associated with the managed profile,\n     * with the {@link #FLAG_EVICT_CREDENTIAL_ENCRYPTION_KEY} flag.\n     * Calling the method twice in this order ensures that all users are locked and does not\n     * stop the device admin on the managed profile from issuing a second call to lock its own\n     * profile.\n     *\n     * @param flags May be 0 or {@link #FLAG_EVICT_CREDENTIAL_ENCRYPTION_KEY}.\n     * @throws SecurityException if the calling application does not own an active administrator\n     *             that uses {@link DeviceAdminInfo#USES_POLICY_FORCE_LOCK} or the\n     *             {@link #FLAG_EVICT_CREDENTIAL_ENCRYPTION_KEY} flag is passed by an application\n     *             that is not a profile\n     *             owner of a managed profile.\n     * @throws IllegalArgumentException if the {@link #FLAG_EVICT_CREDENTIAL_ENCRYPTION_KEY} flag is\n     *             passed when locking the parent profile.\n     * @throws UnsupportedOperationException if the {@link #FLAG_EVICT_CREDENTIAL_ENCRYPTION_KEY}\n     *             flag is passed when {@link #getStorageEncryptionStatus} does not return\n     *             {@link #ENCRYPTION_STATUS_ACTIVE_PER_USER}.\n     ",
    "links" : [ "android.os.Build.VERSION_CODES#R", "android.os.Build.VERSION_CODES#R", "DeviceAdminInfo#USES_POLICY_FORCE_LOCK", "#resetPassword", "DevicePolicyManager", "#getParentProfileInstance", "#lockNow", "#lockNow", "DevicePolicyManager", "#getParentProfileInstance", "#lockNow", "DevicePolicyManager", "#FLAG_EVICT_CREDENTIAL_ENCRYPTION_KEY", "#FLAG_EVICT_CREDENTIAL_ENCRYPTION_KEY", "DeviceAdminInfo#USES_POLICY_FORCE_LOCK", "#FLAG_EVICT_CREDENTIAL_ENCRYPTION_KEY", "#FLAG_EVICT_CREDENTIAL_ENCRYPTION_KEY", "#FLAG_EVICT_CREDENTIAL_ENCRYPTION_KEY", "#getStorageEncryptionStatus", "#ENCRYPTION_STATUS_ACTIVE_PER_USER" ]
  }, {
    "name" : "public void wipeData(int flags)",
    "returnType" : "void",
    "comment" : "\n     * Ask that all user data be wiped. If called as a secondary user, the user will be removed and\n     * other users will remain unaffected. Calling from the primary user will cause the device to\n     * reboot, erasing all device data - including all the secondary users and their data - while\n     * booting up.\n     * <p>\n     * The calling device admin must have requested {@link DeviceAdminInfo#USES_POLICY_WIPE_DATA} to\n     * be able to call this method; if it has not, a security exception will be thrown.\n     *\n     * If the caller is a profile owner of an organization-owned managed profile, it may\n     * additionally call this method on the parent instance.\n     * Calling this method on the parent {@link DevicePolicyManager} instance would wipe the\n     * entire device, while calling it on the current profile instance would relinquish the device\n     * for personal use, removing the managed profile and all policies set by the profile owner.\n     *\n     * @param flags Bit mask of additional options: currently supported flags are\n     *            {@link #WIPE_EXTERNAL_STORAGE}, {@link #WIPE_RESET_PROTECTION_DATA},\n     *            {@link #WIPE_EUICC} and {@link #WIPE_SILENTLY}.\n     * @throws SecurityException if the calling application does not own an active administrator\n     *            that uses {@link DeviceAdminInfo#USES_POLICY_WIPE_DATA}\n     ",
    "links" : [ "DeviceAdminInfo#USES_POLICY_WIPE_DATA", "DevicePolicyManager", "#WIPE_EXTERNAL_STORAGE", "#WIPE_RESET_PROTECTION_DATA", "#WIPE_EUICC", "#WIPE_SILENTLY", "DeviceAdminInfo#USES_POLICY_WIPE_DATA" ]
  }, {
    "name" : "public void wipeData(int flags, @NonNull CharSequence reason)",
    "returnType" : "void",
    "comment" : "\n     * Ask that all user data be wiped. If called as a secondary user, the user will be removed and\n     * other users will remain unaffected, the provided reason for wiping data can be shown to\n     * user. Calling from the primary user will cause the device to reboot, erasing all device data\n     * - including all the secondary users and their data - while booting up. In this case, we don't\n     * show the reason to the user since the device would be factory reset.\n     * <p>\n     * The calling device admin must have requested {@link DeviceAdminInfo#USES_POLICY_WIPE_DATA} to\n     * be able to call this method; if it has not, a security exception will be thrown.\n     *\n     * If the caller is a profile owner of an organization-owned managed profile, it may\n     * additionally call this method on the parent instance.\n     * Calling this method on the parent {@link DevicePolicyManager} instance would wipe the\n     * entire device, while calling it on the current profile instance would relinquish the device\n     * for personal use, removing the managed profile and all policies set by the profile owner.\n     *\n     * @param flags Bit mask of additional options: currently supported flags are\n     *            {@link #WIPE_EXTERNAL_STORAGE}, {@link #WIPE_RESET_PROTECTION_DATA} and\n     *            {@link #WIPE_EUICC}.\n     * @param reason a string that contains the reason for wiping data, which can be\n     *            presented to the user.\n     * @throws SecurityException if the calling application does not own an active administrator\n     *            that uses {@link DeviceAdminInfo#USES_POLICY_WIPE_DATA}\n     * @throws IllegalArgumentException if the input reason string is null or empty, or if\n     *            {@link #WIPE_SILENTLY} is set.\n     ",
    "links" : [ "DeviceAdminInfo#USES_POLICY_WIPE_DATA", "DevicePolicyManager", "#WIPE_EXTERNAL_STORAGE", "#WIPE_RESET_PROTECTION_DATA", "#WIPE_EUICC", "DeviceAdminInfo#USES_POLICY_WIPE_DATA", "#WIPE_SILENTLY" ]
  }, {
    "name" : "private void wipeDataInternal(int flags, @NonNull String wipeReasonForUser)",
    "returnType" : "void",
    "comment" : "\n     * Internal function for both {@link #wipeData(int)} and\n     * {@link #wipeData(int, CharSequence)} to call.\n     *\n     * @see #wipeData(int)\n     * @see #wipeData(int, CharSequence)\n     * @hide\n     ",
    "links" : [ "#wipeData", "#wipeData" ]
  }, {
    "name" : "public void setFactoryResetProtectionPolicy(@NonNull ComponentName admin, @Nullable FactoryResetProtectionPolicy policy)",
    "returnType" : "void",
    "comment" : "\n     * Callable by device owner or profile owner of an organization-owned device, to set a\n     * factory reset protection (FRP) policy. When a new policy is set, the system\n     * notifies the FRP management agent of a policy change by broadcasting\n     * {@code ACTION_RESET_PROTECTION_POLICY_CHANGED}.\n     *\n     * @param admin  Which {@link DeviceAdminReceiver} this request is associated with.\n     * @param policy the new FRP policy, or {@code null} to clear the current policy.\n     * @throws SecurityException if {@code admin} is not a device owner or a profile owner of\n     *                           an organization-owned device.\n     * @throws UnsupportedOperationException if factory reset protection is not\n     *                           supported on the device.\n     ",
    "links" : [ "DeviceAdminReceiver" ]
  }, {
    "name" : "public FactoryResetProtectionPolicy getFactoryResetProtectionPolicy(@Nullable ComponentName admin)",
    "returnType" : "FactoryResetProtectionPolicy",
    "comment" : "\n     * Callable by device owner or profile owner of an organization-owned device, to retrieve\n     * the current factory reset protection (FRP) policy set previously by\n     * {@link #setFactoryResetProtectionPolicy}.\n     * <p>\n     * This method can also be called by the FRP management agent on device or with the permission\n     * {@link android.Manifest.permission#MASTER_CLEAR}, in which case, it can pass {@code null}\n     * as the ComponentName.\n     *\n     * @param admin Which {@link DeviceAdminReceiver} this request is associated with or\n     *              {@code null} if called by the FRP management agent on device or with the\n     *              permission {@link android.Manifest.permission#MASTER_CLEAR}.\n     * @return The current FRP policy object or {@code null} if no policy is set.\n     * @throws SecurityException if {@code admin} is not a device owner, a profile owner of\n     *                           an organization-owned device or the FRP management agent.\n     * @throws UnsupportedOperationException if factory reset protection is not\n     *                           supported on the device.\n     ",
    "links" : [ "#setFactoryResetProtectionPolicy", "android.Manifest.permission#MASTER_CLEAR", "DeviceAdminReceiver", "android.Manifest.permission#MASTER_CLEAR" ]
  }, {
    "name" : "public ComponentName setGlobalProxy(@NonNull ComponentName admin, Proxy proxySpec, List<String> exclusionList)",
    "returnType" : "ComponentName",
    "comment" : "\n     * Called by an application that is administering the device to set the\n     * global proxy and exclusion list.\n     * <p>\n     * The calling device admin must have requested\n     * {@link DeviceAdminInfo#USES_POLICY_SETS_GLOBAL_PROXY} to be able to call\n     * this method; if it has not, a security exception will be thrown.\n     * Only the first device admin can set the proxy. If a second admin attempts\n     * to set the proxy, the {@link ComponentName} of the admin originally setting the\n     * proxy will be returned. If successful in setting the proxy, {@code null} will\n     * be returned.\n     * The method can be called repeatedly by the device admin alrady setting the\n     * proxy to update the proxy and exclusion list.\n     *\n     * @param admin Which {@link DeviceAdminReceiver} this request is associated with.\n     * @param proxySpec the global proxy desired. Must be an HTTP Proxy.\n     *            Pass Proxy.NO_PROXY to reset the proxy.\n     * @param exclusionList a list of domains to be excluded from the global proxy.\n     * @return {@code null} if the proxy was successfully set, or otherwise a {@link ComponentName}\n     *            of the device admin that sets the proxy.\n     * @hide\n     ",
    "links" : [ "DeviceAdminInfo#USES_POLICY_SETS_GLOBAL_PROXY", "ComponentName", "DeviceAdminReceiver", "ComponentName" ]
  }, {
    "name" : "public void setRecommendedGlobalProxy(@NonNull ComponentName admin, @Nullable ProxyInfo proxyInfo)",
    "returnType" : "void",
    "comment" : "\n     * Set a network-independent global HTTP proxy. This is not normally what you want for typical\n     * HTTP proxies - they are generally network dependent. However if you're doing something\n     * unusual like general internal filtering this may be useful. On a private network where the\n     * proxy is not accessible, you may break HTTP using this.\n     * <p>\n     * This method requires the caller to be the device owner.\n     * <p>\n     * This proxy is only a recommendation and it is possible that some apps will ignore it.\n     *\n     * @see ProxyInfo\n     * @param admin Which {@link DeviceAdminReceiver} this request is associated with.\n     * @param proxyInfo The a {@link ProxyInfo} object defining the new global HTTP proxy. A\n     *            {@code null} value will clear the global HTTP proxy.\n     * @throws SecurityException if {@code admin} is not the device owner.\n     ",
    "links" : [ "DeviceAdminReceiver", "ProxyInfo" ]
  }, {
    "name" : "public ComponentName getGlobalProxyAdmin()",
    "returnType" : "ComponentName",
    "comment" : "\n     * Returns the component name setting the global proxy.\n     * @return ComponentName object of the device admin that set the global proxy, or {@code null}\n     *         if no admin has set the proxy.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public int setStorageEncryption(@NonNull ComponentName admin, boolean encrypt)",
    "returnType" : "int",
    "comment" : "\n     * @deprecated This method does not actually modify the storage encryption of the device.\n     * It has never affected the encryption status of a device.\n     *\n     * Called by an application that is administering the device to request that the storage system\n     * be encrypted. Does nothing if the caller is on a secondary user or a managed profile.\n     * <p>\n     * When multiple device administrators attempt to control device encryption, the most secure,\n     * supported setting will always be used. If any device administrator requests device\n     * encryption, it will be enabled; Conversely, if a device administrator attempts to disable\n     * device encryption while another device administrator has enabled it, the call to disable will\n     * fail (most commonly returning {@link #ENCRYPTION_STATUS_ACTIVE}).\n     * <p>\n     * This policy controls encryption of the secure (application data) storage area. Data written\n     * to other storage areas may or may not be encrypted, and this policy does not require or\n     * control the encryption of any other storage areas. There is one exception: If\n     * {@link android.os.Environment#isExternalStorageEmulated()} is {@code true}, then the\n     * directory returned by {@link android.os.Environment#getExternalStorageDirectory()} must be\n     * written to disk within the encrypted storage area.\n     * <p>\n     * Important Note: On some devices, it is possible to encrypt storage without requiring the user\n     * to create a device PIN or Password. In this case, the storage is encrypted, but the\n     * encryption key may not be fully secured. For maximum security, the administrator should also\n     * require (and check for) a pattern, PIN, or password.\n     *\n     * @param admin Which {@link DeviceAdminReceiver} this request is associated with.\n     * @param encrypt true to request encryption, false to release any previous request\n     * @return the new total request status (for all active admins), or {@link\n     *         DevicePolicyManager#ENCRYPTION_STATUS_UNSUPPORTED} if called for a non-system user.\n     *         Will be one of {@link #ENCRYPTION_STATUS_UNSUPPORTED}, {@link\n     *         #ENCRYPTION_STATUS_INACTIVE}, or {@link #ENCRYPTION_STATUS_ACTIVE}. This is the value\n     *         of the requests; use {@link #getStorageEncryptionStatus()} to query the actual device\n     *         state.\n     *\n     * @throws SecurityException if {@code admin} is not an active administrator or does not use\n     *             {@link DeviceAdminInfo#USES_ENCRYPTED_STORAGE}\n     ",
    "links" : [ "#ENCRYPTION_STATUS_ACTIVE", "android.os.Environment#isExternalStorageEmulated", "android.os.Environment#getExternalStorageDirectory", "DeviceAdminReceiver", "#ENCRYPTION_STATUS_UNSUPPORTED", "#ENCRYPTION_STATUS_ACTIVE", "#getStorageEncryptionStatus", "DeviceAdminInfo#USES_ENCRYPTED_STORAGE" ]
  }, {
    "name" : "public boolean getStorageEncryption(@Nullable ComponentName admin)",
    "returnType" : "boolean",
    "comment" : "\n     * @deprecated This method only returns the value set by {@link #setStorageEncryption}.\n     * It does not actually reflect the storage encryption status.\n     * Use {@link #getStorageEncryptionStatus} for that.\n     *\n     * Called by an application that is administering the device to\n     * determine the requested setting for secure storage.\n     *\n     * @param admin Which {@link DeviceAdminReceiver} this request is associated with.  If null,\n     * this will return the requested encryption setting as an aggregate of all active\n     * administrators.\n     * @return true if the admin(s) are requesting encryption, false if not.\n     ",
    "links" : [ "#setStorageEncryption", "#getStorageEncryptionStatus", "DeviceAdminReceiver" ]
  }, {
    "name" : "public int getStorageEncryptionStatus()",
    "returnType" : "int",
    "comment" : "\n     * Called by an application that is administering the device to\n     * determine the current encryption status of the device.\n     * <p>\n     * Depending on the returned status code, the caller may proceed in different\n     * ways.  If the result is {@link #ENCRYPTION_STATUS_UNSUPPORTED}, the\n     * storage system does not support encryption.  If the\n     * result is {@link #ENCRYPTION_STATUS_INACTIVE}, use {@link\n     * #ACTION_START_ENCRYPTION} to begin the process of encrypting or decrypting the\n     * storage.  If the result is {@link #ENCRYPTION_STATUS_ACTIVE_DEFAULT_KEY}, the\n     * storage system has enabled encryption but no password is set so further action\n     * may be required.  If the result is {@link #ENCRYPTION_STATUS_ACTIVATING},\n     * {@link #ENCRYPTION_STATUS_ACTIVE} or {@link #ENCRYPTION_STATUS_ACTIVE_PER_USER},\n     * no further action is required.\n     *\n     * @return current status of encryption. The value will be one of\n     * {@link #ENCRYPTION_STATUS_UNSUPPORTED}, {@link #ENCRYPTION_STATUS_INACTIVE},\n     * {@link #ENCRYPTION_STATUS_ACTIVATING}, {@link #ENCRYPTION_STATUS_ACTIVE_DEFAULT_KEY},\n     * {@link #ENCRYPTION_STATUS_ACTIVE}, or {@link #ENCRYPTION_STATUS_ACTIVE_PER_USER}.\n     ",
    "links" : [ "#ENCRYPTION_STATUS_UNSUPPORTED", "#ENCRYPTION_STATUS_INACTIVE", "#ENCRYPTION_STATUS_ACTIVE_DEFAULT_KEY", "#ENCRYPTION_STATUS_ACTIVATING", "#ENCRYPTION_STATUS_ACTIVE", "#ENCRYPTION_STATUS_ACTIVE_PER_USER", "#ENCRYPTION_STATUS_UNSUPPORTED", "#ENCRYPTION_STATUS_INACTIVE", "#ENCRYPTION_STATUS_ACTIVATING", "#ENCRYPTION_STATUS_ACTIVE_DEFAULT_KEY", "#ENCRYPTION_STATUS_ACTIVE", "#ENCRYPTION_STATUS_ACTIVE_PER_USER" ]
  }, {
    "name" : "public int getStorageEncryptionStatus(int userHandle)",
    "returnType" : "int",
    "comment" : " @hide per-user version ",
    "links" : [ ]
  }, {
    "name" : "public boolean approveCaCert(String alias, int userHandle, boolean approval)",
    "returnType" : "boolean",
    "comment" : "\n     * Mark a CA certificate as approved by the device user. This means that they have been notified\n     * of the installation, were made aware of the risks, viewed the certificate and still wanted to\n     * keep the certificate on the device.\n     *\n     * Calling with {@param approval} as {@code true} will cancel any ongoing warnings related to\n     * this certificate.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean isCaCertApproved(String alias, int userHandle)",
    "returnType" : "boolean",
    "comment" : "\n     * Check whether a CA certificate has been approved by the device user.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean installCaCert(@Nullable ComponentName admin, byte[] certBuffer)",
    "returnType" : "boolean",
    "comment" : "\n     * Installs the given certificate as a user CA.\n     * <p>\n     * Inserted user CAs aren't automatically trusted by apps in Android 7.0 (API level 24) and\n     * higher. App developers can change the default behavior for an app by adding a\n     * <a href=\"{@docRoot}training/articles/security-config.html\">Security Configuration\n     * File</a> to the app manifest file.\n     *\n     * The caller must be a profile or device owner on that user, or a delegate package given the\n     * {@link #DELEGATION_CERT_INSTALL} scope via {@link #setDelegatedScopes}; otherwise a\n     * security exception will be thrown.\n     *\n     * @param admin Which {@link DeviceAdminReceiver} this request is associated with, or\n     *              {@code null} if calling from a delegated certificate installer.\n     * @param certBuffer encoded form of the certificate to install.\n     *\n     * @return false if the certBuffer cannot be parsed or installation is\n     *         interrupted, true otherwise.\n     * @throws SecurityException if {@code admin} is not {@code null} and not a device or profile\n     *         owner.\n     * @see #setDelegatedScopes\n     * @see #DELEGATION_CERT_INSTALL\n     ",
    "links" : [ "#DELEGATION_CERT_INSTALL", "#setDelegatedScopes", "DeviceAdminReceiver" ]
  }, {
    "name" : "public void uninstallCaCert(@Nullable ComponentName admin, byte[] certBuffer)",
    "returnType" : "void",
    "comment" : "\n     * Uninstalls the given certificate from trusted user CAs, if present.\n     *\n     * The caller must be a profile or device owner on that user, or a delegate package given the\n     * {@link #DELEGATION_CERT_INSTALL} scope via {@link #setDelegatedScopes}; otherwise a\n     * security exception will be thrown.\n     *\n     * @param admin Which {@link DeviceAdminReceiver} this request is associated with, or\n     *              {@code null} if calling from a delegated certificate installer.\n     * @param certBuffer encoded form of the certificate to remove.\n     * @throws SecurityException if {@code admin} is not {@code null} and not a device or profile\n     *         owner.\n     * @see #setDelegatedScopes\n     * @see #DELEGATION_CERT_INSTALL\n     ",
    "links" : [ "#DELEGATION_CERT_INSTALL", "#setDelegatedScopes", "DeviceAdminReceiver" ]
  }, {
    "name" : "public List<byte[]> getInstalledCaCerts(@Nullable ComponentName admin)",
    "returnType" : "List<byte[]>",
    "comment" : "\n     * Returns all CA certificates that are currently trusted, excluding system CA certificates.\n     * If a user has installed any certificates by other means than device policy these will be\n     * included too.\n     *\n     * @param admin Which {@link DeviceAdminReceiver} this request is associated with, or\n     *              {@code null} if calling from a delegated certificate installer.\n     * @return a List of byte[] arrays, each encoding one user CA certificate.\n     * @throws SecurityException if {@code admin} is not {@code null} and not a device or profile\n     *         owner.\n     ",
    "links" : [ "DeviceAdminReceiver" ]
  }, {
    "name" : "public void uninstallAllUserCaCerts(@Nullable ComponentName admin)",
    "returnType" : "void",
    "comment" : "\n     * Uninstalls all custom trusted CA certificates from the profile. Certificates installed by\n     * means other than device policy will also be removed, except for system CA certificates.\n     *\n     * @param admin Which {@link DeviceAdminReceiver} this request is associated with, or\n     *              {@code null} if calling from a delegated certificate installer.\n     * @throws SecurityException if {@code admin} is not {@code null} and not a device or profile\n     *         owner.\n     ",
    "links" : [ "DeviceAdminReceiver" ]
  }, {
    "name" : "public boolean hasCaCertInstalled(@Nullable ComponentName admin, byte[] certBuffer)",
    "returnType" : "boolean",
    "comment" : "\n     * Returns whether this certificate is installed as a trusted CA.\n     *\n     * @param admin Which {@link DeviceAdminReceiver} this request is associated with, or\n     *              {@code null} if calling from a delegated certificate installer.\n     * @param certBuffer encoded form of the certificate to look up.\n     * @throws SecurityException if {@code admin} is not {@code null} and not a device or profile\n     *         owner.\n     ",
    "links" : [ "DeviceAdminReceiver" ]
  }, {
    "name" : "public boolean installKeyPair(@Nullable ComponentName admin, @NonNull PrivateKey privKey, @NonNull Certificate cert, @NonNull String alias)",
    "returnType" : "boolean",
    "comment" : "\n     * Called by a device or profile owner, or delegated certificate installer, to install a\n     * certificate and corresponding private key. All apps within the profile will be able to access\n     * the certificate and use the private key, given direct user approval.\n     *\n     * <p>Access to the installed credentials will not be granted to the caller of this API without\n     * direct user approval. This is for security - should a certificate installer become\n     * compromised, certificates it had already installed will be protected.\n     *\n     * <p>If the installer must have access to the credentials, call\n     * {@link #installKeyPair(ComponentName, PrivateKey, Certificate[], String, boolean)} instead.\n     *\n     * <p>Note: If the provided {@code alias} is of an existing alias, all former grants that apps\n     * have been given to access the key and certificates associated with this alias will be\n     * revoked.\n     *\n     * @param admin Which {@link DeviceAdminReceiver} this request is associated with, or\n     *            {@code null} if calling from a delegated certificate installer.\n     * @param privKey The private key to install.\n     * @param cert The certificate to install.\n     * @param alias The private key alias under which to install the certificate. If a certificate\n     * with that alias already exists, it will be overwritten.\n     * @return {@code true} if the keys were installed, {@code false} otherwise.\n     * @throws SecurityException if {@code admin} is not {@code null} and not a device or profile\n     *         owner.\n     * @see #setDelegatedScopes\n     * @see #DELEGATION_CERT_INSTALL\n     ",
    "links" : [ "#installKeyPair", "DeviceAdminReceiver" ]
  }, {
    "name" : "public boolean installKeyPair(@Nullable ComponentName admin, @NonNull PrivateKey privKey, @NonNull Certificate[] certs, @NonNull String alias, boolean requestAccess)",
    "returnType" : "boolean",
    "comment" : "\n     * Called by a device or profile owner, or delegated certificate installer, to install a\n     * certificate chain and corresponding private key for the leaf certificate. All apps within the\n     * profile will be able to access the certificate chain and use the private key, given direct\n     * user approval.\n     *\n     * <p>The caller of this API may grant itself access to the certificate and private key\n     * immediately, without user approval. It is a best practice not to request this unless strictly\n     * necessary since it opens up additional security vulnerabilities.\n     *\n     * <p>Note: If the provided {@code alias} is of an existing alias, all former grants that apps\n     * have been given to access the key and certificates associated with this alias will be\n     * revoked.\n     *\n     * @param admin Which {@link DeviceAdminReceiver} this request is associated with, or\n     *        {@code null} if calling from a delegated certificate installer.\n     * @param privKey The private key to install.\n     * @param certs The certificate chain to install. The chain should start with the leaf\n     *        certificate and include the chain of trust in order. This will be returned by\n     *        {@link android.security.KeyChain#getCertificateChain}.\n     * @param alias The private key alias under which to install the certificate. If a certificate\n     *        with that alias already exists, it will be overwritten.\n     * @param requestAccess {@code true} to request that the calling app be granted access to the\n     *        credentials immediately. Otherwise, access to the credentials will be gated by user\n     *        approval.\n     * @return {@code true} if the keys were installed, {@code false} otherwise.\n     * @throws SecurityException if {@code admin} is not {@code null} and not a device or profile\n     *         owner.\n     * @see android.security.KeyChain#getCertificateChain\n     * @see #setDelegatedScopes\n     * @see #DELEGATION_CERT_INSTALL\n     ",
    "links" : [ "DeviceAdminReceiver", "android.security.KeyChain#getCertificateChain" ]
  }, {
    "name" : "public boolean installKeyPair(@Nullable ComponentName admin, @NonNull PrivateKey privKey, @NonNull Certificate[] certs, @NonNull String alias, int flags)",
    "returnType" : "boolean",
    "comment" : "\n     * Called by a device or profile owner, or delegated certificate installer, to install a\n     * certificate chain and corresponding private key for the leaf certificate. All apps within the\n     * profile will be able to access the certificate chain and use the private key, given direct\n     * user approval (if the user is allowed to select the private key).\n     *\n     * <p>The caller of this API may grant itself access to the certificate and private key\n     * immediately, without user approval. It is a best practice not to request this unless strictly\n     * necessary since it opens up additional security vulnerabilities.\n     *\n     * <p>Include {@link #INSTALLKEY_SET_USER_SELECTABLE} in the {@code flags} argument to allow\n     * the user to select the key from a dialog.\n     *\n     * <p>Note: If the provided {@code alias} is of an existing alias, all former grants that apps\n     * have been given to access the key and certificates associated with this alias will be\n     * revoked.\n     *\n     * @param admin Which {@link DeviceAdminReceiver} this request is associated with, or\n     *        {@code null} if calling from a delegated certificate installer.\n     * @param privKey The private key to install.\n     * @param certs The certificate chain to install. The chain should start with the leaf\n     *        certificate and include the chain of trust in order. This will be returned by\n     *        {@link android.security.KeyChain#getCertificateChain}.\n     * @param alias The private key alias under which to install the certificate. If a certificate\n     *        with that alias already exists, it will be overwritten.\n     * @param flags Flags to request that the calling app be granted access to the credentials\n     *        and set the key to be user-selectable. See {@link #INSTALLKEY_SET_USER_SELECTABLE} and\n     *        {@link #INSTALLKEY_REQUEST_CREDENTIALS_ACCESS}.\n     * @return {@code true} if the keys were installed, {@code false} otherwise.\n     * @throws SecurityException if {@code admin} is not {@code null} and not a device or profile\n     *         owner.\n     * @see android.security.KeyChain#getCertificateChain\n     * @see #setDelegatedScopes\n     * @see #DELEGATION_CERT_INSTALL\n     ",
    "links" : [ "#INSTALLKEY_SET_USER_SELECTABLE", "DeviceAdminReceiver", "android.security.KeyChain#getCertificateChain", "#INSTALLKEY_SET_USER_SELECTABLE", "#INSTALLKEY_REQUEST_CREDENTIALS_ACCESS" ]
  }, {
    "name" : "public boolean removeKeyPair(@Nullable ComponentName admin, @NonNull String alias)",
    "returnType" : "boolean",
    "comment" : "\n     * Called by a device or profile owner, or delegated certificate installer, to remove a\n     * certificate and private key pair installed under a given alias.\n     *\n     * @param admin Which {@link DeviceAdminReceiver} this request is associated with, or\n     *        {@code null} if calling from a delegated certificate installer.\n     * @param alias The private key alias under which the certificate is installed.\n     * @return {@code true} if the private key alias no longer exists, {@code false} otherwise.\n     * @throws SecurityException if {@code admin} is not {@code null} and not a device or profile\n     *         owner.\n     * @see #setDelegatedScopes\n     * @see #DELEGATION_CERT_INSTALL\n     ",
    "links" : [ "DeviceAdminReceiver" ]
  }, {
    "name" : "public AttestedKeyPair generateKeyPair(@Nullable ComponentName admin, @NonNull String algorithm, @NonNull KeyGenParameterSpec keySpec, @AttestationIdType int idAttestationFlags)",
    "returnType" : "AttestedKeyPair",
    "comment" : "\n     * Called by a device or profile owner, or delegated certificate installer, to generate a\n     * new private/public key pair. If the device supports key generation via secure hardware,\n     * this method is useful for creating a key in KeyChain that never left the secure hardware.\n     * Access to the key is controlled the same way as in {@link #installKeyPair}.\n     *\n     * <p>Because this method might take several seconds to complete, it should only be called from\n     * a worker thread. This method returns {@code null} when called from the main thread.\n     *\n     * <p>This method is not thread-safe, calling it from multiple threads at the same time will\n     * result in undefined behavior. If the calling thread is interrupted while the invocation is\n     * in-flight, it will eventually terminate and return {@code null}.\n     *\n     * <p>Note: If the provided {@code alias} is of an existing alias, all former grants that apps\n     * have been given to access the key and certificates associated with this alias will be\n     * revoked.\n     *\n     * <p>Attestation: to enable attestation, set an attestation challenge in {@code keySpec} via\n     * {@link KeyGenParameterSpec.Builder#setAttestationChallenge}. By specifying flags to the\n     * {@code idAttestationFlags} parameter, it is possible to request the device's unique\n     * identity to be included in the attestation record.\n     *\n     * <p>Specific identifiers can be included in the attestation record, and an individual\n     * attestation certificate can be used to sign the attestation record. To find out if the device\n     * supports these features, refer to {@link #isDeviceIdAttestationSupported()} and\n     * {@link #isUniqueDeviceAttestationSupported()}.\n     *\n     * <p>Device owner, profile owner and their delegated certificate installer can use\n     * {@link #ID_TYPE_BASE_INFO} to request inclusion of the general device information\n     * including manufacturer, model, brand, device and product in the attestation record.\n     * Only device owner, profile owner on an organization-owned device and their delegated\n     * certificate installers can use {@link #ID_TYPE_SERIAL}, {@link #ID_TYPE_IMEI} and\n     * {@link #ID_TYPE_MEID} to request unique device identifiers to be attested (the serial number,\n     * IMEI and MEID correspondingly), if supported by the device\n     * (see {@link #isDeviceIdAttestationSupported()}).\n     * Additionally, device owner, profile owner on an organization-owned device and their delegated\n     * certificate installers can also request the attestation record to be signed using an\n     * individual attestation certificate by specifying the {@link #ID_TYPE_INDIVIDUAL_ATTESTATION}\n     * flag (if supported by the device, see {@link #isUniqueDeviceAttestationSupported()}).\n     * <p>\n     * If any of {@link #ID_TYPE_SERIAL}, {@link #ID_TYPE_IMEI} and {@link #ID_TYPE_MEID}\n     * is set, it is implicitly assumed that {@link #ID_TYPE_BASE_INFO} is also set.\n     * <p>\n     * Attestation using {@link #ID_TYPE_INDIVIDUAL_ATTESTATION} can only be requested if\n     * key generation is done in StrongBox.\n     *\n     * @param admin Which {@link DeviceAdminReceiver} this request is associated with, or\n     *            {@code null} if calling from a delegated certificate installer.\n     * @param algorithm The key generation algorithm, see {@link java.security.KeyPairGenerator}.\n     * @param keySpec Specification of the key to generate, see\n     * {@link java.security.KeyPairGenerator}.\n     * @param idAttestationFlags A bitmask of the identifiers that should be included in the\n     *        attestation record ({@code ID_TYPE_BASE_INFO}, {@code ID_TYPE_SERIAL},\n     *        {@code ID_TYPE_IMEI} and {@code ID_TYPE_MEID}), and\n     *        {@code ID_TYPE_INDIVIDUAL_ATTESTATION} if the attestation record should be signed\n     *        using an individual attestation certificate.\n     *        <p>\n     *        {@code 0} should be passed in if no device identification is required in the\n     *        attestation record and the batch attestation certificate should be used.\n     *        <p>\n     *        If any flag is specified, then an attestation challenge must be included in the\n     *        {@code keySpec}.\n     * @return A non-null {@code AttestedKeyPair} if the key generation succeeded, null otherwise.\n     * @throws SecurityException if {@code admin} is not {@code null} and not a device or profile\n     *         owner. If Device ID attestation is requested (using {@link #ID_TYPE_SERIAL},\n     *         {@link #ID_TYPE_IMEI} or {@link #ID_TYPE_MEID}), the caller must be the Device Owner\n     *         or the Certificate Installer delegate.\n     * @throws IllegalArgumentException in the following cases:\n     *         <p>\n     *         <ul>\n     *         <li>The alias in {@code keySpec} is empty.</li>\n     *         <li>The algorithm specification in {@code keySpec} is not\n     *         {@code RSAKeyGenParameterSpec} or {@code ECGenParameterSpec}.</li>\n     *         <li>Device ID attestation was requested but the {@code keySpec} does not contain an\n     *         attestation challenge.</li>\n     *         </ul>\n     * @throws UnsupportedOperationException if Device ID attestation or individual attestation\n     *         was requested but the underlying hardware does not support it.\n     * @throws StrongBoxUnavailableException if the use of StrongBox for key generation was\n     *         specified in {@code keySpec} but the device does not have one.\n     * @see KeyGenParameterSpec.Builder#setAttestationChallenge(byte[])\n     ",
    "links" : [ "#installKeyPair", "KeyGenParameterSpec.Builder#setAttestationChallenge", "#isDeviceIdAttestationSupported", "#isUniqueDeviceAttestationSupported", "#ID_TYPE_BASE_INFO", "#ID_TYPE_SERIAL", "#ID_TYPE_IMEI", "#ID_TYPE_MEID", "#isDeviceIdAttestationSupported", "#ID_TYPE_INDIVIDUAL_ATTESTATION", "#isUniqueDeviceAttestationSupported", "#ID_TYPE_SERIAL", "#ID_TYPE_IMEI", "#ID_TYPE_MEID", "#ID_TYPE_BASE_INFO", "#ID_TYPE_INDIVIDUAL_ATTESTATION", "DeviceAdminReceiver", "java.security.KeyPairGenerator", "java.security.KeyPairGenerator", "#ID_TYPE_SERIAL", "#ID_TYPE_IMEI", "#ID_TYPE_MEID" ]
  }, {
    "name" : "public boolean grantKeyPairToApp(@Nullable ComponentName admin, @NonNull String alias, @NonNull String packageName)",
    "returnType" : "boolean",
    "comment" : "\n     * Called by a device or profile owner, or delegated certificate chooser (an app that has been\n     * delegated the {@link #DELEGATION_CERT_SELECTION} privilege), to grant an application access\n     * to an already-installed (or generated) KeyChain key.\n     * This is useful (in combination with {@link #installKeyPair} or {@link #generateKeyPair}) to\n     * let an application call {@link android.security.KeyChain#getPrivateKey} without having to\n     * call {@link android.security.KeyChain#choosePrivateKeyAlias} first.\n     *\n     * The grantee app will receive the {@link android.security.KeyChain#ACTION_KEY_ACCESS_CHANGED}\n     * broadcast when access to a key is granted.\n     *\n     * @param admin Which {@link DeviceAdminReceiver} this request is associated with, or\n     *        {@code null} if calling from a delegated certificate installer.\n     * @param alias The alias of the key to grant access to.\n     * @param packageName The name of the (already installed) package to grant access to.\n     * @return {@code true} if the grant was set successfully, {@code false} otherwise.\n     *\n     * @throws SecurityException if the caller is not a device owner, a profile owner or\n     *         delegated certificate chooser.\n     * @throws IllegalArgumentException if {@code packageName} or {@code alias} are empty, or if\n     *         {@code packageName} is not a name of an installed package.\n     * @see #revokeKeyPairFromApp\n     ",
    "links" : [ "#DELEGATION_CERT_SELECTION", "#installKeyPair", "#generateKeyPair", "android.security.KeyChain#getPrivateKey", "android.security.KeyChain#choosePrivateKeyAlias", "android.security.KeyChain#ACTION_KEY_ACCESS_CHANGED", "DeviceAdminReceiver" ]
  }, {
    "name" : "public boolean revokeKeyPairFromApp(@Nullable ComponentName admin, @NonNull String alias, @NonNull String packageName)",
    "returnType" : "boolean",
    "comment" : "\n     * Called by a device or profile owner, or delegated certificate chooser (an app that has been\n     * delegated the {@link #DELEGATION_CERT_SELECTION} privilege), to revoke an application's\n     * grant to a KeyChain key pair.\n     * Calls by the application to {@link android.security.KeyChain#getPrivateKey}\n     * will fail after the grant is revoked.\n     *\n     * The grantee app will receive the {@link android.security.KeyChain#ACTION_KEY_ACCESS_CHANGED}\n     * broadcast when access to a key is revoked.\n     *\n     * @param admin Which {@link DeviceAdminReceiver} this request is associated with, or\n     *        {@code null} if calling from a delegated certificate installer.\n     * @param alias The alias of the key to revoke access from.\n     * @param packageName The name of the (already installed) package to revoke access from.\n     * @return {@code true} if the grant was revoked successfully, {@code false} otherwise.\n     *\n     * @throws SecurityException if the caller is not a device owner, a profile owner or\n     *         delegated certificate chooser.\n     * @throws IllegalArgumentException if {@code packageName} or {@code alias} are empty, or if\n     *         {@code packageName} is not a name of an installed package.\n     * @see #grantKeyPairToApp\n     ",
    "links" : [ "#DELEGATION_CERT_SELECTION", "android.security.KeyChain#getPrivateKey", "android.security.KeyChain#ACTION_KEY_ACCESS_CHANGED", "DeviceAdminReceiver" ]
  }, {
    "name" : "public boolean isDeviceIdAttestationSupported()",
    "returnType" : "boolean",
    "comment" : "\n     * Returns {@code true} if the device supports attestation of device identifiers in addition\n     * to key attestation. See\n     * {@link #generateKeyPair(ComponentName, String, KeyGenParameterSpec, int)}\n     * @return {@code true} if Device ID attestation is supported.\n     ",
    "links" : [ "#generateKeyPair" ]
  }, {
    "name" : "public boolean isUniqueDeviceAttestationSupported()",
    "returnType" : "boolean",
    "comment" : "\n     * Returns {@code true} if the StrongBox Keymaster implementation on the device was provisioned\n     * with an individual attestation certificate and can sign attestation records using it (as\n     * attestation using an individual attestation certificate is a feature only Keymaster\n     * implementations with StrongBox security level can implement).\n     * For use prior to calling\n     * {@link #generateKeyPair(ComponentName, String, KeyGenParameterSpec, int)}.\n     * @return {@code true} if individual attestation is supported.\n     ",
    "links" : [ "#generateKeyPair" ]
  }, {
    "name" : "public boolean setKeyPairCertificate(@Nullable ComponentName admin, @NonNull String alias, @NonNull List<Certificate> certs, boolean isUserSelectable)",
    "returnType" : "boolean",
    "comment" : "\n     * Called by a device or profile owner, or delegated certificate installer, to associate\n     * certificates with a key pair that was generated using {@link #generateKeyPair}, and\n     * set whether the key is available for the user to choose in the certificate selection\n     * prompt.\n     *\n     * @param admin Which {@link DeviceAdminReceiver} this request is associated with, or\n     *            {@code null} if calling from a delegated certificate installer.\n     * @param alias The private key alias under which to install the certificate. The {@code alias}\n     *        should denote an existing private key. If a certificate with that alias already\n     *        exists, it will be overwritten.\n     * @param certs The certificate chain to install. The chain should start with the leaf\n     *        certificate and include the chain of trust in order. This will be returned by\n     *        {@link android.security.KeyChain#getCertificateChain}.\n     * @param isUserSelectable {@code true} to indicate that a user can select this key via the\n     *        certificate selection prompt, {@code false} to indicate that this key can only be\n     *        granted access by implementing\n     *        {@link android.app.admin.DeviceAdminReceiver#onChoosePrivateKeyAlias}.\n     * @return {@code true} if the provided {@code alias} exists and the certificates has been\n     *        successfully associated with it, {@code false} otherwise.\n     * @throws SecurityException if {@code admin} is not {@code null} and not a device or profile\n     *         owner, or {@code admin} is null but the calling application is not a delegated\n     *         certificate installer.\n     ",
    "links" : [ "#generateKeyPair", "DeviceAdminReceiver", "android.security.KeyChain#getCertificateChain", "android.app.admin.DeviceAdminReceiver#onChoosePrivateKeyAlias" ]
  }, {
    "name" : "private static String getCaCertAlias(byte[] certBuffer) throws CertificateException",
    "returnType" : "String",
    "comment" : "\n     * @return the alias of a given CA certificate in the certificate store, or {@code null} if it\n     * doesn't exist.\n     ",
    "links" : [ ]
  }, {
    "name" : "public void setCertInstallerPackage(@NonNull ComponentName admin, @Nullable String installerPackage) throws SecurityException",
    "returnType" : "void",
    "comment" : "\n     * Called by a profile owner or device owner to grant access to privileged certificate\n     * manipulation APIs to a third-party certificate installer app. Granted APIs include\n     * {@link #getInstalledCaCerts}, {@link #hasCaCertInstalled}, {@link #installCaCert},\n     * {@link #uninstallCaCert}, {@link #uninstallAllUserCaCerts} and {@link #installKeyPair}.\n     * <p>\n     * Delegated certificate installer is a per-user state. The delegated access is persistent until\n     * it is later cleared by calling this method with a null value or uninstallling the certificate\n     * installer.\n     * <p>\n     * <b>Note:</b>Starting from {@link android.os.Build.VERSION_CODES#N}, if the caller\n     * application's target SDK version is {@link android.os.Build.VERSION_CODES#N} or newer, the\n     * supplied certificate installer package must be installed when calling this API, otherwise an\n     * {@link IllegalArgumentException} will be thrown.\n     *\n     * @param admin Which {@link DeviceAdminReceiver} this request is associated with.\n     * @param installerPackage The package name of the certificate installer which will be given\n     *            access. If {@code null} is given the current package will be cleared.\n     * @throws SecurityException if {@code admin} is not a device or a profile owner.\n     *\n     * @deprecated From {@link android.os.Build.VERSION_CODES#O}. Use {@link #setDelegatedScopes}\n     * with the {@link #DELEGATION_CERT_INSTALL} scope instead.\n     ",
    "links" : [ "#getInstalledCaCerts", "#hasCaCertInstalled", "#installCaCert", "#uninstallCaCert", "#uninstallAllUserCaCerts", "#installKeyPair", "android.os.Build.VERSION_CODES#N", "android.os.Build.VERSION_CODES#N", "IllegalArgumentException", "DeviceAdminReceiver", "android.os.Build.VERSION_CODES#O", "#setDelegatedScopes", "#DELEGATION_CERT_INSTALL" ]
  }, {
    "name" : "public String getCertInstallerPackage(@NonNull ComponentName admin) throws SecurityException",
    "returnType" : "String",
    "comment" : "\n     * Called by a profile owner or device owner to retrieve the certificate installer for the user,\n     * or {@code null} if none is set. If there are multiple delegates this function will return one\n     * of them.\n     *\n     * @param admin Which {@link DeviceAdminReceiver} this request is associated with.\n     * @return The package name of the current delegated certificate installer, or {@code null} if\n     *         none is set.\n     * @throws SecurityException if {@code admin} is not a device or a profile owner.\n     *\n     * @deprecated From {@link android.os.Build.VERSION_CODES#O}. Use {@link #getDelegatePackages}\n     * with the {@link #DELEGATION_CERT_INSTALL} scope instead.\n     ",
    "links" : [ "DeviceAdminReceiver", "android.os.Build.VERSION_CODES#O", "#getDelegatePackages", "#DELEGATION_CERT_INSTALL" ]
  }, {
    "name" : "public void setDelegatedScopes(@NonNull ComponentName admin, @NonNull String delegatePackage, @NonNull List<String> scopes)",
    "returnType" : "void",
    "comment" : "\n     * Called by a profile owner or device owner to grant access to privileged APIs to another app.\n     * Granted APIs are determined by {@code scopes}, which is a list of the {@code DELEGATION_*}\n     * constants.\n     * <p>\n     * A broadcast with the {@link #ACTION_APPLICATION_DELEGATION_SCOPES_CHANGED} action will be\n     * sent to the {@code delegatePackage} with its new scopes in an {@code ArrayList<String>} extra\n     * under the {@link #EXTRA_DELEGATION_SCOPES} key. The broadcast is sent with the\n     * {@link Intent#FLAG_RECEIVER_REGISTERED_ONLY} flag.\n     * <p>\n     * Delegated scopes are a per-user state. The delegated access is persistent until it is later\n     * cleared by calling this method with an empty {@code scopes} list or uninstalling the\n     * {@code delegatePackage}.\n     *\n     * @param admin Which {@link DeviceAdminReceiver} this request is associated with.\n     * @param delegatePackage The package name of the app which will be given access.\n     * @param scopes The groups of privileged APIs whose access should be granted to\n     *            {@code delegatedPackage}.\n     * @throws SecurityException if {@code admin} is not a device or a profile owner.\n     ",
    "links" : [ "#ACTION_APPLICATION_DELEGATION_SCOPES_CHANGED", "#EXTRA_DELEGATION_SCOPES", "Intent#FLAG_RECEIVER_REGISTERED_ONLY", "DeviceAdminReceiver" ]
  }, {
    "name" : "public List<String> getDelegatedScopes(@Nullable ComponentName admin, @NonNull String delegatedPackage)",
    "returnType" : "List<String>",
    "comment" : "\n     * Called by a profile owner or device owner to retrieve a list of the scopes given to a\n     * delegate package. Other apps can use this method to retrieve their own delegated scopes by\n     * passing {@code null} for {@code admin} and their own package name as\n     * {@code delegatedPackage}.\n     *\n     * @param admin Which {@link DeviceAdminReceiver} this request is associated with, or\n     *            {@code null} if the caller is {@code delegatedPackage}.\n     * @param delegatedPackage The package name of the app whose scopes should be retrieved.\n     * @return A list containing the scopes given to {@code delegatedPackage}.\n     * @throws SecurityException if {@code admin} is not a device or a profile owner.\n     ",
    "links" : [ "DeviceAdminReceiver" ]
  }, {
    "name" : "public List<String> getDelegatePackages(@NonNull ComponentName admin, @NonNull String delegationScope)",
    "returnType" : "List<String>",
    "comment" : "\n     * Called by a profile owner or device owner to retrieve a list of delegate packages that were\n     * granted a delegation scope.\n     *\n     * @param admin Which {@link DeviceAdminReceiver} this request is associated with.\n     * @param delegationScope The scope whose delegates should be retrieved.\n     * @return A list of package names of the current delegated packages for\n               {@code delegationScope}.\n     * @throws SecurityException if {@code admin} is not a device or a profile owner.\n     ",
    "links" : [ "DeviceAdminReceiver" ]
  }, {
    "name" : "public void setAlwaysOnVpnPackage(@NonNull ComponentName admin, @Nullable String vpnPackage, boolean lockdownEnabled) throws NameNotFoundException",
    "returnType" : "void",
    "comment" : "\n     * Called by a device or profile owner to configure an always-on VPN connection through a\n     * specific application for the current user. This connection is automatically granted and\n     * persisted after a reboot.\n     * <p> To support the always-on feature, an app must\n     * <ul>\n     *     <li>declare a {@link android.net.VpnService} in its manifest, guarded by\n     *         {@link android.Manifest.permission#BIND_VPN_SERVICE};</li>\n     *     <li>target {@link android.os.Build.VERSION_CODES#N API 24} or above; and</li>\n     *     <li><i>not</i> explicitly opt out of the feature through\n     *         {@link android.net.VpnService#SERVICE_META_DATA_SUPPORTS_ALWAYS_ON}.</li>\n     * </ul>\n     * The call will fail if called with the package name of an unsupported VPN app.\n     * <p> Enabling lockdown via {@code lockdownEnabled} argument carries the risk that any failure\n     * of the VPN provider could break networking for all apps. This method clears any lockdown\n     * whitelist set by {@link #setAlwaysOnVpnPackage(ComponentName, String, boolean, Set)}.\n     *\n     * @param vpnPackage The package name for an installed VPN app on the device, or {@code null} to\n     *        remove an existing always-on VPN configuration.\n     * @param lockdownEnabled {@code true} to disallow networking when the VPN is not connected or\n     *        {@code false} otherwise. This has no effect when clearing.\n     * @throws SecurityException if {@code admin} is not a device or a profile owner.\n     * @throws NameNotFoundException if {@code vpnPackage} is not installed.\n     * @throws UnsupportedOperationException if {@code vpnPackage} exists but does not support being\n     *         set as always-on, or if always-on VPN is not available.\n     * @see #setAlwaysOnVpnPackage(ComponentName, String, boolean, Set)\n     ",
    "links" : [ "android.net.VpnService", "android.Manifest.permission#BIND_VPN_SERVICE", "android.os.Build.VERSION_CODES#N", "android.net.VpnService#SERVICE_META_DATA_SUPPORTS_ALWAYS_ON", "#setAlwaysOnVpnPackage" ]
  }, {
    "name" : "public void setAlwaysOnVpnPackage(@NonNull ComponentName admin, @Nullable String vpnPackage, boolean lockdownEnabled, @Nullable Set<String> lockdownWhitelist) throws NameNotFoundException",
    "returnType" : "void",
    "comment" : "\n     * A version of {@link #setAlwaysOnVpnPackage(ComponentName, String, boolean)} that allows the\n     * admin to specify a set of apps that should be able to access the network directly when VPN\n     * is not connected. When VPN connects these apps switch over to VPN if allowed to use that VPN.\n     * System apps can always bypass VPN.\n     * <p> Note that the system doesn't update the whitelist when packages are installed or\n     * uninstalled, the admin app must call this method to keep the list up to date.\n     * <p> When {@code lockdownEnabled} is false {@code lockdownWhitelist} is ignored . When\n     * {@code lockdownEnabled} is {@code true} and {@code lockdownWhitelist} is {@code null} or\n     * empty, only system apps can bypass VPN.\n     * <p> Setting always-on VPN package to {@code null} or using\n     * {@link #setAlwaysOnVpnPackage(ComponentName, String, boolean)} clears lockdown whitelist.\n     *\n     * @param vpnPackage package name for an installed VPN app on the device, or {@code null}\n     *         to remove an existing always-on VPN configuration\n     * @param lockdownEnabled {@code true} to disallow networking when the VPN is not connected or\n     *         {@code false} otherwise. This has no effect when clearing.\n     * @param lockdownWhitelist Packages that will be able to access the network directly when VPN\n     *         is in lockdown mode but not connected. Has no effect when clearing.\n     * @throws SecurityException if {@code admin} is not a device or a profile\n     *         owner.\n     * @throws NameNotFoundException if {@code vpnPackage} or one of\n     *         {@code lockdownWhitelist} is not installed.\n     * @throws UnsupportedOperationException if {@code vpnPackage} exists but does\n     *         not support being set as always-on, or if always-on VPN is not\n     *         available.\n     ",
    "links" : [ "#setAlwaysOnVpnPackage", "#setAlwaysOnVpnPackage" ]
  }, {
    "name" : "public boolean isAlwaysOnVpnLockdownEnabled(@NonNull ComponentName admin)",
    "returnType" : "boolean",
    "comment" : "\n     * Called by device or profile owner to query whether current always-on VPN is configured in\n     * lockdown mode. Returns {@code false} when no always-on configuration is set.\n     *\n     * @param admin Which {@link DeviceAdminReceiver} this request is associated with.\n     *\n     * @throws SecurityException if {@code admin} is not a device or a profile owner.\n     *\n     * @see #setAlwaysOnVpnPackage(ComponentName, String, boolean)\n     ",
    "links" : [ "DeviceAdminReceiver" ]
  }, {
    "name" : "public boolean isAlwaysOnVpnLockdownEnabled()",
    "returnType" : "boolean",
    "comment" : "\n     * Returns whether the admin has enabled always-on VPN lockdown for the current user.\n     *\n     * Only callable by the system.\n    * @hide\n    ",
    "links" : [ ]
  }, {
    "name" : "public Set<String> getAlwaysOnVpnLockdownWhitelist(@NonNull ComponentName admin)",
    "returnType" : "Set<String>",
    "comment" : "\n     * Called by device or profile owner to query the set of packages that are allowed to access\n     * the network directly when always-on VPN is in lockdown mode but not connected. Returns\n     * {@code null} when always-on VPN is not active or not in lockdown mode.\n     *\n     * @param admin Which {@link DeviceAdminReceiver} this request is associated with.\n     *\n     * @throws SecurityException if {@code admin} is not a device or a profile owner.\n     *\n     * @see #setAlwaysOnVpnPackage(ComponentName, String, boolean, Set)\n     ",
    "links" : [ "DeviceAdminReceiver" ]
  }, {
    "name" : "public String getAlwaysOnVpnPackage(@NonNull ComponentName admin)",
    "returnType" : "String",
    "comment" : "\n     * Called by a device or profile owner to read the name of the package administering an\n     * always-on VPN connection for the current user. If there is no such package, or the always-on\n     * VPN is provided by the system instead of by an application, {@code null} will be returned.\n     *\n     * @return Package name of VPN controller responsible for always-on VPN, or {@code null} if none\n     *         is set.\n     * @throws SecurityException if {@code admin} is not a device or a profile owner.\n     ",
    "links" : [ ]
  }, {
    "name" : "public String getAlwaysOnVpnPackage()",
    "returnType" : "String",
    "comment" : "\n     * Returns the VPN package name if the admin has enabled always-on VPN on the current user,\n     * or {@code null} if none is set.\n     *\n     * Only callable by the system.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public void setCameraDisabled(@NonNull ComponentName admin, boolean disabled)",
    "returnType" : "void",
    "comment" : "\n     * Called by an application that is administering the device to disable all cameras on the\n     * device, for this user. After setting this, no applications running as this user will be able\n     * to access any cameras on the device.\n     * <p>\n     * This method can be called on the {@link DevicePolicyManager} instance,\n     * returned by {@link #getParentProfileInstance(ComponentName)}, where the caller must be\n     * the profile owner of an organization-owned managed profile.\n     * <p>\n     * If the caller is device owner, then the restriction will be applied to all users. If\n     * called on the parent instance, then the restriction will be applied on the personal profile.\n     * <p>\n     * The calling device admin must have requested\n     * {@link DeviceAdminInfo#USES_POLICY_DISABLE_CAMERA} to be able to call this method; if it has\n     * not, a security exception will be thrown.\n     * <p>\n     * <b>Note</b>, this policy type is deprecated for legacy device admins since\n     * {@link android.os.Build.VERSION_CODES#Q}. On Android\n     * {@link android.os.Build.VERSION_CODES#Q} devices, legacy device admins targeting SDK\n     * version {@link android.os.Build.VERSION_CODES#P} or below can still call this API to\n     * disable camera, while legacy device admins targeting SDK version\n     * {@link android.os.Build.VERSION_CODES#Q} will receive a SecurityException. Starting\n     * from Android {@link android.os.Build.VERSION_CODES#R}, requests to disable camera from\n     * legacy device admins targeting SDK version {@link android.os.Build.VERSION_CODES#P} or\n     * below will be silently ignored.\n     *\n     * @param admin Which {@link DeviceAdminReceiver} this request is associated with.\n     * @param disabled Whether or not the camera should be disabled.\n     * @throws SecurityException if {@code admin} is not an active administrator or does not use\n     *             {@link DeviceAdminInfo#USES_POLICY_DISABLE_CAMERA}.\n     ",
    "links" : [ "DevicePolicyManager", "#getParentProfileInstance", "DeviceAdminInfo#USES_POLICY_DISABLE_CAMERA", "android.os.Build.VERSION_CODES#Q", "android.os.Build.VERSION_CODES#Q", "android.os.Build.VERSION_CODES#P", "android.os.Build.VERSION_CODES#Q", "android.os.Build.VERSION_CODES#R", "android.os.Build.VERSION_CODES#P", "DeviceAdminReceiver", "DeviceAdminInfo#USES_POLICY_DISABLE_CAMERA" ]
  }, {
    "name" : "public boolean getCameraDisabled(@Nullable ComponentName admin)",
    "returnType" : "boolean",
    "comment" : "\n     * Determine whether or not the device's cameras have been disabled for this user,\n     * either by the calling admin, if specified, or all admins.\n     * <p>\n     * This method can be called on the {@link DevicePolicyManager} instance,\n     * returned by {@link #getParentProfileInstance(ComponentName)}, where the caller must be\n     * the profile owner of an organization-owned managed profile.\n     *\n     * @param admin The name of the admin component to check, or {@code null} to check whether any admins\n     * have disabled the camera\n     ",
    "links" : [ "DevicePolicyManager", "#getParentProfileInstance" ]
  }, {
    "name" : "public boolean getCameraDisabled(@Nullable ComponentName admin, int userHandle)",
    "returnType" : "boolean",
    "comment" : " @hide per-user version ",
    "links" : [ ]
  }, {
    "name" : "public boolean requestBugreport(@NonNull ComponentName admin)",
    "returnType" : "boolean",
    "comment" : "\n     * Called by a device owner to request a bugreport.\n     * <p>\n     * If the device contains secondary users or profiles, they must be affiliated with the device.\n     * Otherwise a {@link SecurityException} will be thrown. See {@link #isAffiliatedUser}.\n     *\n     * @param admin Which {@link DeviceAdminReceiver} this request is associated with.\n     * @return {@code true} if the bugreport collection started successfully, or {@code false} if it\n     *         wasn't triggered because a previous bugreport operation is still active (either the\n     *         bugreport is still running or waiting for the user to share or decline)\n     * @throws SecurityException if {@code admin} is not a device owner, or there is at least one\n     *         profile or secondary user that is not affiliated with the device.\n     * @see #isAffiliatedUser\n     ",
    "links" : [ "SecurityException", "#isAffiliatedUser", "DeviceAdminReceiver" ]
  }, {
    "name" : "public boolean getGuestUserDisabled(@Nullable ComponentName admin)",
    "returnType" : "boolean",
    "comment" : "\n     * Determine whether or not creating a guest user has been disabled for the device\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public void setScreenCaptureDisabled(@NonNull ComponentName admin, boolean disabled)",
    "returnType" : "void",
    "comment" : "\n     * Called by a device/profile owner to set whether the screen capture is disabled. Disabling\n     * screen capture also prevents the content from being shown on display devices that do not have\n     * a secure video output. See {@link android.view.Display#FLAG_SECURE} for more details about\n     * secure surfaces and secure displays.\n     * <p>\n     * This method can be called on the {@link DevicePolicyManager} instance, returned by\n     * {@link #getParentProfileInstance(ComponentName)}, where the calling device admin must be\n     * the profile owner of an organization-owned managed profile. If it is not, a security\n     * exception will be thrown.\n     * <p>\n     * If the caller is device owner or called on the parent instance by a profile owner of an\n     * organization-owned managed profile, then the restriction will be applied to all users.\n     * <p>\n     * From version {@link android.os.Build.VERSION_CODES#M} disabling screen capture also blocks\n     * assist requests for all activities of the relevant user.\n     *\n     * @param admin Which {@link DeviceAdminReceiver} this request is associated with.\n     * @param disabled Whether screen capture is disabled or not.\n     * @throws SecurityException if {@code admin} is not a device or profile owner or if\n     *                           called on the parent profile and the {@code admin} is not a\n     *                           profile owner of an organization-owned managed profile.\n     ",
    "links" : [ "android.view.Display#FLAG_SECURE", "DevicePolicyManager", "#getParentProfileInstance", "android.os.Build.VERSION_CODES#M", "DeviceAdminReceiver" ]
  }, {
    "name" : "public boolean getScreenCaptureDisabled(@Nullable ComponentName admin)",
    "returnType" : "boolean",
    "comment" : "\n     * Determine whether or not screen capture has been disabled by the calling\n     * admin, if specified, or all admins.\n     * <p>\n     * This method can be called on the {@link DevicePolicyManager} instance,\n     * returned by {@link #getParentProfileInstance(ComponentName)}, where the caller must be\n     * the profile owner of an organization-owned managed profile (the calling admin must be\n     * specified).\n     *\n     * @param admin The name of the admin component to check, or {@code null} to check whether any\n     *              admins have disabled screen capture.\n     ",
    "links" : [ "DevicePolicyManager", "#getParentProfileInstance" ]
  }, {
    "name" : "public boolean getScreenCaptureDisabled(@Nullable ComponentName admin, int userHandle)",
    "returnType" : "boolean",
    "comment" : " @hide per-user version ",
    "links" : [ ]
  }, {
    "name" : "public void setAutoTimeRequired(@NonNull ComponentName admin, boolean required)",
    "returnType" : "void",
    "comment" : "\n     * Called by a device owner, or alternatively a profile owner from Android 8.0 (API level 26) or\n     * higher, to set whether auto time is required. If auto time is required, no user will be able\n     * set the date and time and network date and time will be used.\n     * <p>\n     * Note: if auto time is required the user can still manually set the time zone.\n     * <p>\n     * The calling device admin must be a device owner, or alternatively a profile owner from\n     * Android 8.0 (API level 26) or higher. If it is not, a security exception will be thrown.\n     * <p>\n     * Staring from Android 11, this API switches to use\n     * {@link UserManager#DISALLOW_CONFIG_DATE_TIME} to enforce the auto time settings. Calling\n     * this API to enforce auto time will result in\n     * {@link UserManager#DISALLOW_CONFIG_DATE_TIME} being set, while calling this API to lift\n     * the requirement will result in {@link UserManager#DISALLOW_CONFIG_DATE_TIME} being cleared.\n     * From Android 11, this API can also no longer be called on a managed profile.\n     *\n     * @param admin Which {@link DeviceAdminReceiver} this request is associated with.\n     * @param required Whether auto time is set required or not.\n     * @throws SecurityException if {@code admin} is not a device owner, not a profile owner or\n     * if this API is called on a managed profile.\n     * @deprecated From {@link android.os.Build.VERSION_CODES#R}. Use {@link #setAutoTimeEnabled}\n     * to turn auto time on or off and use {@link UserManager#DISALLOW_CONFIG_DATE_TIME}\n     * to prevent the user from changing this setting.\n     ",
    "links" : [ "UserManager#DISALLOW_CONFIG_DATE_TIME", "UserManager#DISALLOW_CONFIG_DATE_TIME", "UserManager#DISALLOW_CONFIG_DATE_TIME", "DeviceAdminReceiver", "android.os.Build.VERSION_CODES#R", "#setAutoTimeEnabled", "UserManager#DISALLOW_CONFIG_DATE_TIME" ]
  }, {
    "name" : "public boolean getAutoTimeRequired()",
    "returnType" : "boolean",
    "comment" : "\n     * @return true if auto time is required.\n     * @deprecated From {@link android.os.Build.VERSION_CODES#R}. Use {@link #getAutoTimeEnabled}\n     ",
    "links" : [ "android.os.Build.VERSION_CODES#R", "#getAutoTimeEnabled" ]
  }, {
    "name" : "public void setAutoTimeEnabled(@NonNull ComponentName admin, boolean enabled)",
    "returnType" : "void",
    "comment" : "\n     * Called by a device owner, a profile owner for the primary user or a profile\n     * owner of an organization-owned managed profile to turn auto time on and off.\n     * Callers are recommended to use {@link UserManager#DISALLOW_CONFIG_DATE_TIME}\n     * to prevent the user from changing this setting.\n     * <p>\n     * If user restriction {@link UserManager#DISALLOW_CONFIG_DATE_TIME} is used,\n     * no user will be able set the date and time. Instead, the network date\n     * and time will be used.\n     *\n     * @param admin Which {@link DeviceAdminReceiver} this request is associated with.\n     * @param enabled Whether time should be obtained automatically from the network or not.\n     * @throws SecurityException if caller is not a device owner, a profile owner for the\n     * primary user, or a profile owner of an organization-owned managed profile.\n     ",
    "links" : [ "UserManager#DISALLOW_CONFIG_DATE_TIME", "UserManager#DISALLOW_CONFIG_DATE_TIME", "DeviceAdminReceiver" ]
  }, {
    "name" : "public boolean getAutoTimeEnabled(@NonNull ComponentName admin)",
    "returnType" : "boolean",
    "comment" : "\n     * @return true if auto time is enabled on the device.\n     * @throws SecurityException if caller is not a device owner, a profile owner for the\n     * primary user, or a profile owner of an organization-owned managed profile.\n     ",
    "links" : [ ]
  }, {
    "name" : "public void setAutoTimeZoneEnabled(@NonNull ComponentName admin, boolean enabled)",
    "returnType" : "void",
    "comment" : "\n     * Called by a device owner, a profile owner for the primary user or a profile\n     * owner of an organization-owned managed profile to turn auto time zone on and off.\n     * Callers are recommended to use {@link UserManager#DISALLOW_CONFIG_DATE_TIME}\n     * to prevent the user from changing this setting.\n     * <p>\n     * If user restriction {@link UserManager#DISALLOW_CONFIG_DATE_TIME} is used,\n     * no user will be able set the date and time zone. Instead, the network date\n     * and time zone will be used.\n     *\n     * @param admin Which {@link DeviceAdminReceiver} this request is associated with.\n     * @param enabled Whether time zone should be obtained automatically from the network or not.\n     * @throws SecurityException if caller is not a device owner, a profile owner for the\n     * primary user, or a profile owner of an organization-owned managed profile.\n     ",
    "links" : [ "UserManager#DISALLOW_CONFIG_DATE_TIME", "UserManager#DISALLOW_CONFIG_DATE_TIME", "DeviceAdminReceiver" ]
  }, {
    "name" : "public boolean getAutoTimeZoneEnabled(@NonNull ComponentName admin)",
    "returnType" : "boolean",
    "comment" : "\n     * @return true if auto time zone is enabled on the device.\n     * @throws SecurityException if caller is not a device owner, a profile owner for the\n     * primary user, or a profile owner of an organization-owned managed profile.\n     ",
    "links" : [ ]
  }, {
    "name" : "public void setForceEphemeralUsers(@NonNull ComponentName admin, boolean forceEphemeralUsers)",
    "returnType" : "void",
    "comment" : "\n     * Called by a device owner to set whether all users created on the device should be ephemeral.\n     * <p>\n     * The system user is exempt from this policy - it is never ephemeral.\n     * <p>\n     * The calling device admin must be the device owner. If it is not, a security exception will be\n     * thrown.\n     *\n     * @param admin Which {@link DeviceAdminReceiver} this request is associated with.\n     * @param forceEphemeralUsers If true, all the existing users will be deleted and all\n     *            subsequently created users will be ephemeral.\n     * @throws SecurityException if {@code admin} is not a device owner.\n     * @hide\n     ",
    "links" : [ "DeviceAdminReceiver" ]
  }, {
    "name" : "public boolean getForceEphemeralUsers(@NonNull ComponentName admin)",
    "returnType" : "boolean",
    "comment" : "\n     * @return true if all users are created ephemeral.\n     * @throws SecurityException if {@code admin} is not a device owner.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public void setKeyguardDisabledFeatures(@NonNull ComponentName admin, int which)",
    "returnType" : "void",
    "comment" : "\n     * Called by an application that is administering the device to disable keyguard customizations,\n     * such as widgets. After setting this, keyguard features will be disabled according to the\n     * provided feature list.\n     * <p>\n     * The calling device admin must have requested\n     * {@link DeviceAdminInfo#USES_POLICY_DISABLE_KEYGUARD_FEATURES} to be able to call this method;\n     * if it has not, a security exception will be thrown.\n     * <p>\n     * Calling this from a managed profile before version {@link android.os.Build.VERSION_CODES#M}\n     * will throw a security exception. From version {@link android.os.Build.VERSION_CODES#M} the\n     * profile owner of a managed profile can set:\n     * <ul>\n     * <li>{@link #KEYGUARD_DISABLE_TRUST_AGENTS}, which affects the parent user, but only if there\n     * is no separate challenge set on the managed profile.\n     * <li>{@link #KEYGUARD_DISABLE_FINGERPRINT}, {@link #KEYGUARD_DISABLE_FACE} or\n     * {@link #KEYGUARD_DISABLE_IRIS} which affects the managed profile challenge if\n     * there is one, or the parent user otherwise.\n     * <li>{@link #KEYGUARD_DISABLE_UNREDACTED_NOTIFICATIONS} which affects notifications generated\n     * by applications in the managed profile.\n     * </ul>\n     * <p>\n     * From version {@link android.os.Build.VERSION_CODES#R} the profile owner of an\n     * organization-owned managed profile can set:\n     * <ul>\n     * <li>{@link #KEYGUARD_DISABLE_SECURE_CAMERA} which affects the parent user when called on the\n     * parent profile.\n     * <li>{@link #KEYGUARD_DISABLE_SECURE_NOTIFICATIONS} which affects the parent user when called\n     * on the parent profile.\n     * </ul>\n     * {@link #KEYGUARD_DISABLE_TRUST_AGENTS}, {@link #KEYGUARD_DISABLE_FINGERPRINT},\n     * {@link #KEYGUARD_DISABLE_FACE}, {@link #KEYGUARD_DISABLE_IRIS},\n     * {@link #KEYGUARD_DISABLE_SECURE_CAMERA} and {@link #KEYGUARD_DISABLE_SECURE_NOTIFICATIONS}\n     * can also be set on the {@link DevicePolicyManager} instance returned by\n     * {@link #getParentProfileInstance(ComponentName)} in order to set restrictions on the parent\n     * profile. {@link #KEYGUARD_DISABLE_SECURE_CAMERA} can only be set on the parent profile\n     * instance if the calling device admin is the profile owner of an organization-owned\n     * managed profile.\n     * <p>\n     * Requests to disable other features on a managed profile will be ignored.\n     * <p>\n     * The admin can check which features have been disabled by calling\n     * {@link #getKeyguardDisabledFeatures(ComponentName)}\n     *\n     * @param admin Which {@link DeviceAdminReceiver} this request is associated with.\n     * @param which The disabled features flag which can be either\n     *            {@link #KEYGUARD_DISABLE_FEATURES_NONE} (default),\n     *            {@link #KEYGUARD_DISABLE_FEATURES_ALL}, or a combination of\n     *            {@link #KEYGUARD_DISABLE_WIDGETS_ALL}, {@link #KEYGUARD_DISABLE_SECURE_CAMERA},\n     *            {@link #KEYGUARD_DISABLE_SECURE_NOTIFICATIONS},\n     *            {@link #KEYGUARD_DISABLE_TRUST_AGENTS},\n     *            {@link #KEYGUARD_DISABLE_UNREDACTED_NOTIFICATIONS},\n     *            {@link #KEYGUARD_DISABLE_FINGERPRINT},\n     *            {@link #KEYGUARD_DISABLE_FACE},\n     *            {@link #KEYGUARD_DISABLE_IRIS}.\n     * @throws SecurityException if {@code admin} is not an active administrator or does not user\n     *             {@link DeviceAdminInfo#USES_POLICY_DISABLE_KEYGUARD_FEATURES}\n     ",
    "links" : [ "DeviceAdminInfo#USES_POLICY_DISABLE_KEYGUARD_FEATURES", "android.os.Build.VERSION_CODES#M", "android.os.Build.VERSION_CODES#M", "#KEYGUARD_DISABLE_TRUST_AGENTS", "#KEYGUARD_DISABLE_FINGERPRINT", "#KEYGUARD_DISABLE_FACE", "#KEYGUARD_DISABLE_IRIS", "#KEYGUARD_DISABLE_UNREDACTED_NOTIFICATIONS", "android.os.Build.VERSION_CODES#R", "#KEYGUARD_DISABLE_SECURE_CAMERA", "#KEYGUARD_DISABLE_SECURE_NOTIFICATIONS", "#KEYGUARD_DISABLE_TRUST_AGENTS", "#KEYGUARD_DISABLE_FINGERPRINT", "#KEYGUARD_DISABLE_FACE", "#KEYGUARD_DISABLE_IRIS", "#KEYGUARD_DISABLE_SECURE_CAMERA", "#KEYGUARD_DISABLE_SECURE_NOTIFICATIONS", "DevicePolicyManager", "#getParentProfileInstance", "#KEYGUARD_DISABLE_SECURE_CAMERA", "#getKeyguardDisabledFeatures", "DeviceAdminReceiver", "#KEYGUARD_DISABLE_FEATURES_NONE", "#KEYGUARD_DISABLE_FEATURES_ALL", "#KEYGUARD_DISABLE_WIDGETS_ALL", "#KEYGUARD_DISABLE_SECURE_CAMERA", "#KEYGUARD_DISABLE_SECURE_NOTIFICATIONS", "#KEYGUARD_DISABLE_TRUST_AGENTS", "#KEYGUARD_DISABLE_UNREDACTED_NOTIFICATIONS", "#KEYGUARD_DISABLE_FINGERPRINT", "#KEYGUARD_DISABLE_FACE", "#KEYGUARD_DISABLE_IRIS", "DeviceAdminInfo#USES_POLICY_DISABLE_KEYGUARD_FEATURES" ]
  }, {
    "name" : "public int getKeyguardDisabledFeatures(@Nullable ComponentName admin)",
    "returnType" : "int",
    "comment" : "\n     * Determine whether or not features have been disabled in keyguard either by the calling\n     * admin, if specified, or all admins that set restrictions on this user and its participating\n     * profiles. Restrictions on profiles that have a separate challenge are not taken into account.\n     *\n     * <p>This method can be called on the {@link DevicePolicyManager} instance\n     * returned by {@link #getParentProfileInstance(ComponentName)} in order to retrieve\n     * restrictions on the parent profile.\n     *\n     * @param admin The name of the admin component to check, or {@code null} to check whether any\n     * admins have disabled features in keyguard.\n     * @return bitfield of flags. See {@link #setKeyguardDisabledFeatures(ComponentName, int)}\n     * for a list.\n     ",
    "links" : [ "DevicePolicyManager", "#getParentProfileInstance", "#setKeyguardDisabledFeatures" ]
  }, {
    "name" : "public int getKeyguardDisabledFeatures(@Nullable ComponentName admin, int userHandle)",
    "returnType" : "int",
    "comment" : " @hide per-user version ",
    "links" : [ ]
  }, {
    "name" : "public void setActiveAdmin(@NonNull ComponentName policyReceiver, boolean refreshing, int userHandle)",
    "returnType" : "void",
    "comment" : "\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public void setActiveAdmin(@NonNull ComponentName policyReceiver, boolean refreshing)",
    "returnType" : "void",
    "comment" : "\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public void getRemoveWarning(@Nullable ComponentName admin, RemoteCallback result)",
    "returnType" : "void",
    "comment" : "\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public void reportPasswordChanged(@UserIdInt int userId)",
    "returnType" : "void",
    "comment" : "\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public void reportFailedPasswordAttempt(int userHandle)",
    "returnType" : "void",
    "comment" : "\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public void reportSuccessfulPasswordAttempt(int userHandle)",
    "returnType" : "void",
    "comment" : "\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public void reportFailedBiometricAttempt(int userHandle)",
    "returnType" : "void",
    "comment" : "\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public void reportSuccessfulBiometricAttempt(int userHandle)",
    "returnType" : "void",
    "comment" : "\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public void reportKeyguardDismissed(int userHandle)",
    "returnType" : "void",
    "comment" : "\n     * Should be called when keyguard has been dismissed.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public void reportKeyguardSecured(int userHandle)",
    "returnType" : "void",
    "comment" : "\n     * Should be called when keyguard view has been shown to the user.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean setDeviceOwner(ComponentName who)",
    "returnType" : "boolean",
    "comment" : "\n     * @hide\n     * Sets the given package as the device owner.\n     * Same as {@link #setDeviceOwner(ComponentName, String)} but without setting a device owner name.\n     * @param who the component name to be registered as device owner.\n     * @return whether the package was successfully registered as the device owner.\n     * @throws IllegalArgumentException if the package name is null or invalid\n     * @throws IllegalStateException If the preconditions mentioned are not met.\n     ",
    "links" : [ "#setDeviceOwner" ]
  }, {
    "name" : "public boolean setDeviceOwner(ComponentName who, int userId)",
    "returnType" : "boolean",
    "comment" : "\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean setDeviceOwner(ComponentName who, String ownerName)",
    "returnType" : "boolean",
    "comment" : "\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean setDeviceOwner(ComponentName who, String ownerName, int userId) throws IllegalArgumentException, IllegalStateException",
    "returnType" : "boolean",
    "comment" : "\n     * @hide\n     * Sets the given package as the device owner. The package must already be installed. There\n     * must not already be a device owner.\n     * Only apps with the MANAGE_PROFILE_AND_DEVICE_OWNERS permission and the shell uid can call\n     * this method.\n     * Calling this after the setup phase of the primary user has completed is allowed only if\n     * the caller is the shell uid, and there are no additional users and no accounts.\n     * @param who the component name to be registered as device owner.\n     * @param ownerName the human readable name of the institution that owns this device.\n     * @param userId ID of the user on which the device owner runs.\n     * @return whether the package was successfully registered as the device owner.\n     * @throws IllegalArgumentException if the package name is null or invalid\n     * @throws IllegalStateException If the preconditions mentioned are not met.\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean isDeviceOwnerApp(String packageName)",
    "returnType" : "boolean",
    "comment" : "\n     * Used to determine if a particular package has been registered as a Device Owner app.\n     * A device owner app is a special device admin that cannot be deactivated by the user, once\n     * activated as a device admin. It also cannot be uninstalled. To check whether a particular\n     * package is currently registered as the device owner app, pass in the package name from\n     * {@link Context#getPackageName()} to this method.<p/>This is useful for device\n     * admin apps that want to check whether they are also registered as the device owner app. The\n     * exact mechanism by which a device admin app is registered as a device owner app is defined by\n     * the setup process.\n     * @param packageName the package name of the app, to compare with the registered device owner\n     * app, if any.\n     * @return whether or not the package is registered as the device owner app.\n     ",
    "links" : [ "Context#getPackageName" ]
  }, {
    "name" : "public boolean isDeviceOwnerAppOnCallingUser(String packageName)",
    "returnType" : "boolean",
    "comment" : "\n     * @return true if a package is registered as device owner, only when it's running on the\n     * calling user.\n     *\n     * <p>Same as {@link #isDeviceOwnerApp}, but bundled code should use it for clarity.\n     * @hide\n     ",
    "links" : [ "#isDeviceOwnerApp" ]
  }, {
    "name" : "public boolean isDeviceOwnerAppOnAnyUser(String packageName)",
    "returnType" : "boolean",
    "comment" : "\n     * @return true if a package is registered as device owner, even if it's running on a different\n     * user.\n     *\n     * <p>Requires the MANAGE_USERS permission.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public ComponentName getDeviceOwnerComponentOnCallingUser()",
    "returnType" : "ComponentName",
    "comment" : "\n     * @return device owner component name, only when it's running on the calling user.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public ComponentName getDeviceOwnerComponentOnAnyUser()",
    "returnType" : "ComponentName",
    "comment" : "\n     * @return device owner component name, even if it's running on a different user.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "private boolean isDeviceOwnerAppOnAnyUserInner(String packageName, boolean callingUserOnly)",
    "returnType" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private ComponentName getDeviceOwnerComponentInner(boolean callingUserOnly)",
    "returnType" : "ComponentName",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public UserHandle getDeviceOwnerUser()",
    "returnType" : "UserHandle",
    "comment" : "\n     * @return Handle of the user who runs device owner, or {@code null} if there's no device owner.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public int getDeviceOwnerUserId()",
    "returnType" : "int",
    "comment" : "\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public void clearDeviceOwnerApp(String packageName)",
    "returnType" : "void",
    "comment" : "\n     * Clears the current device owner. The caller must be the device owner. This function should be\n     * used cautiously as once it is called it cannot be undone. The device owner can only be set as\n     * a part of device setup, before it completes.\n     * <p>\n     * While some policies previously set by the device owner will be cleared by this method, it is\n     * a best-effort process and some other policies will still remain in place after the device\n     * owner is cleared.\n     *\n     * @param packageName The package name of the device owner.\n     * @throws SecurityException if the caller is not in {@code packageName} or {@code packageName}\n     *             does not own the current device owner component.\n     *\n     * @deprecated This method is expected to be used for testing purposes only. The device owner\n     * will lose control of the device and its data after calling it. In order to protect any\n     * sensitive data that remains on the device, it is advised that the device owner factory resets\n     * the device instead of calling this method. See {@link #wipeData(int)}.\n     ",
    "links" : [ "#wipeData" ]
  }, {
    "name" : "public String getDeviceOwner()",
    "returnType" : "String",
    "comment" : "\n     * Returns the device owner package name, only if it's running on the calling user.\n     *\n     * <p>Bundled components should use {@code getDeviceOwnerComponentOnCallingUser()} for clarity.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean isDeviceManaged()",
    "returnType" : "boolean",
    "comment" : "\n     * Called by the system to find out whether the device is managed by a Device Owner.\n     *\n     * @return whether the device is managed by a Device Owner.\n     * @throws SecurityException if the caller is not the device owner, does not hold the\n     *         MANAGE_USERS permission and is not the system.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public String getDeviceOwnerNameOnAnyUser()",
    "returnType" : "String",
    "comment" : "\n     * Returns the device owner name.  Note this method *will* return the device owner\n     * name when it's running on a different user.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean setActiveProfileOwner(@NonNull ComponentName admin, @Deprecated String ownerName) throws IllegalArgumentException",
    "returnType" : "boolean",
    "comment" : "\n     * @hide\n     * @deprecated Use #ACTION_SET_PROFILE_OWNER\n     * Sets the given component as an active admin and registers the package as the profile\n     * owner for this user. The package must already be installed and there shouldn't be\n     * an existing profile owner registered for this user. Also, this method must be called\n     * before the user setup has been completed.\n     * <p>\n     * This method can only be called by system apps that hold MANAGE_USERS permission and\n     * MANAGE_DEVICE_ADMINS permission.\n     * @param admin The component to register as an active admin and profile owner.\n     * @param ownerName The user-visible name of the entity that is managing this user.\n     * @return whether the admin was successfully registered as the profile owner.\n     * @throws IllegalArgumentException if packageName is null, the package isn't installed, or\n     *         the user has already been set up.\n     ",
    "links" : [ ]
  }, {
    "name" : "public void clearProfileOwner(@NonNull ComponentName admin)",
    "returnType" : "void",
    "comment" : "\n     * Clears the active profile owner. The caller must be the profile owner of this user, otherwise\n     * a SecurityException will be thrown. This method is not available to managed profile owners.\n     * <p>\n     * While some policies previously set by the profile owner will be cleared by this method, it is\n     * a best-effort process and some other policies will still remain in place after the profile\n     * owner is cleared.\n     *\n     * @param admin The component to remove as the profile owner.\n     * @throws SecurityException if {@code admin} is not an active profile owner, or the method is\n     * being called from a managed profile.\n     *\n     * @deprecated This method is expected to be used for testing purposes only. The profile owner\n     * will lose control of the user and its data after calling it. In order to protect any\n     * sensitive data that remains on this user, it is advised that the profile owner deletes it\n     * instead of calling this method. See {@link #wipeData(int)}.\n     ",
    "links" : [ "#wipeData" ]
  }, {
    "name" : "public boolean hasUserSetupCompleted()",
    "returnType" : "boolean",
    "comment" : "\n     * @hide\n     * Checks whether the user was already setup.\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean setProfileOwner(@NonNull ComponentName admin, @Deprecated String ownerName, int userHandle) throws IllegalArgumentException",
    "returnType" : "boolean",
    "comment" : "\n     * @hide\n     * Sets the given component as the profile owner of the given user profile. The package must\n     * already be installed. There must not already be a profile owner for this user.\n     * Only apps with the MANAGE_PROFILE_AND_DEVICE_OWNERS permission and the shell uid can call\n     * this method.\n     * Calling this after the setup phase of the specified user has completed is allowed only if:\n     * - the caller is SYSTEM_UID.\n     * - or the caller is the shell uid, and there are no accounts on the specified user.\n     * @param admin the component name to be registered as profile owner.\n     * @param ownerName the human readable name of the organisation associated with this DPM.\n     * @param userHandle the userId to set the profile owner for.\n     * @return whether the component was successfully registered as the profile owner.\n     * @throws IllegalArgumentException if admin is null, the package isn't installed, or the\n     * preconditions mentioned are not met.\n     ",
    "links" : [ ]
  }, {
    "name" : "public void setDeviceOwnerLockScreenInfo(@NonNull ComponentName admin, CharSequence info)",
    "returnType" : "void",
    "comment" : "\n     * Sets the device owner information to be shown on the lock screen.\n     * <p>\n     * Device owner information set using this method overrides any owner information manually set\n     * by the user and prevents the user from further changing it.\n     * <p>\n     * If the device owner information is {@code null} or empty then the device owner info is\n     * cleared and the user owner info is shown on the lock screen if it is set.\n     * <p>\n     * If the device owner information contains only whitespaces then the message on the lock screen\n     * will be blank and the user will not be allowed to change it.\n     * <p>\n     * If the device owner information needs to be localized, it is the responsibility of the\n     * {@link DeviceAdminReceiver} to listen to the {@link Intent#ACTION_LOCALE_CHANGED} broadcast\n     * and set a new version of this string accordingly.\n     * <p>\n     * May be called by the device owner or the profile owner of an organization-owned device.\n     *\n     * @param admin The name of the admin component to check.\n     * @param info Device owner information which will be displayed instead of the user owner info.\n     * @throws SecurityException if {@code admin} is not a device owner.\n     ",
    "links" : [ "DeviceAdminReceiver", "Intent#ACTION_LOCALE_CHANGED" ]
  }, {
    "name" : "public CharSequence getDeviceOwnerLockScreenInfo()",
    "returnType" : "CharSequence",
    "comment" : "\n     * @return The device owner information. If it is not set returns {@code null}.\n     ",
    "links" : [ ]
  }, {
    "name" : "public String[] setPackagesSuspended(@NonNull ComponentName admin, @NonNull String[] packageNames, boolean suspended)",
    "returnType" : "String[]",
    "comment" : "\n     * Called by device or profile owners to suspend packages for this user. This function can be\n     * called by a device owner, profile owner, or by a delegate given the\n     * {@link #DELEGATION_PACKAGE_ACCESS} scope via {@link #setDelegatedScopes}.\n     * <p>\n     * A suspended package will not be able to start activities. Its notifications will be hidden,\n     * it will not show up in recents, will not be able to show toasts or dialogs or ring the\n     * device.\n     * <p>\n     * The package must already be installed. If the package is uninstalled while suspended the\n     * package will no longer be suspended. The admin can block this by using\n     * {@link #setUninstallBlocked}.\n     *\n     * <p>Some apps cannot be suspended, such as device admins, the active launcher, the required\n     * package installer, the required package uninstaller, the required package verifier, the\n     * default dialer, and the permission controller.\n     *\n     * @param admin The name of the admin component to check, or {@code null} if the caller is a\n     *            package access delegate.\n     * @param packageNames The package names to suspend or unsuspend.\n     * @param suspended If set to {@code true} than the packages will be suspended, if set to\n     *            {@code false} the packages will be unsuspended.\n     * @return an array of package names for which the suspended status is not set as requested in\n     *         this method.\n     * @throws SecurityException if {@code admin} is not a device or profile owner.\n     * @see #setDelegatedScopes\n     * @see #DELEGATION_PACKAGE_ACCESS\n     ",
    "links" : [ "#DELEGATION_PACKAGE_ACCESS", "#setDelegatedScopes", "#setUninstallBlocked" ]
  }, {
    "name" : "public boolean isPackageSuspended(@NonNull ComponentName admin, String packageName) throws NameNotFoundException",
    "returnType" : "boolean",
    "comment" : "\n     * Determine if a package is suspended. This function can be called by a device owner, profile\n     * owner, or by a delegate given the {@link #DELEGATION_PACKAGE_ACCESS} scope via\n     * {@link #setDelegatedScopes}.\n     *\n     * @param admin Which {@link DeviceAdminReceiver} this request is associated with, or\n     *            {@code null} if the caller is a package access delegate.\n     * @param packageName The name of the package to retrieve the suspended status of.\n     * @return {@code true} if the package is suspended or {@code false} if the package is not\n     *         suspended, could not be found or an error occurred.\n     * @throws SecurityException if {@code admin} is not a device or profile owner.\n     * @throws NameNotFoundException if the package could not be found.\n     * @see #setDelegatedScopes\n     * @see #DELEGATION_PACKAGE_ACCESS\n     ",
    "links" : [ "#DELEGATION_PACKAGE_ACCESS", "#setDelegatedScopes", "DeviceAdminReceiver" ]
  }, {
    "name" : "public void setProfileEnabled(@NonNull ComponentName admin)",
    "returnType" : "void",
    "comment" : "\n     * Sets the enabled state of the profile. A profile should be enabled only once it is ready to\n     * be used. Only the profile owner can call this.\n     *\n     * @see #isProfileOwnerApp\n     * @param admin Which {@link DeviceAdminReceiver} this request is associated with.\n     * @throws SecurityException if {@code admin} is not a profile owner.\n     ",
    "links" : [ "DeviceAdminReceiver" ]
  }, {
    "name" : "public void setProfileName(@NonNull ComponentName admin, String profileName)",
    "returnType" : "void",
    "comment" : "\n     * Sets the name of the profile. In the device owner case it sets the name of the user which it\n     * is called from. Only a profile owner or device owner can call this. If this is never called\n     * by the profile or device owner, the name will be set to default values.\n     *\n     * @see #isProfileOwnerApp\n     * @see #isDeviceOwnerApp\n     * @param admin Which {@link DeviceAdminReceiver} this request is associate with.\n     * @param profileName The name of the profile.\n     * @throws SecurityException if {@code admin} is not a device or profile owner.\n     ",
    "links" : [ "DeviceAdminReceiver" ]
  }, {
    "name" : "public boolean isProfileOwnerApp(String packageName)",
    "returnType" : "boolean",
    "comment" : "\n     * Used to determine if a particular package is registered as the profile owner for the\n     * user. A profile owner is a special device admin that has additional privileges\n     * within the profile.\n     *\n     * @param packageName The package name of the app to compare with the registered profile owner.\n     * @return Whether or not the package is registered as the profile owner.\n     ",
    "links" : [ ]
  }, {
    "name" : "public ComponentName getProfileOwner() throws IllegalArgumentException",
    "returnType" : "ComponentName",
    "comment" : "\n     * @hide\n     * @return the packageName of the owner of the given user profile or {@code null} if no profile\n     * owner has been set for that user.\n     * @throws IllegalArgumentException if the userId is invalid.\n     ",
    "links" : [ ]
  }, {
    "name" : "public ComponentName getProfileOwnerAsUser(@NonNull UserHandle user)",
    "returnType" : "ComponentName",
    "comment" : "\n     * @see #getProfileOwner()\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public ComponentName getProfileOwnerAsUser(final int userId)",
    "returnType" : "ComponentName",
    "comment" : "\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public ComponentName getProfileOwnerOrDeviceOwnerSupervisionComponent(@NonNull UserHandle user)",
    "returnType" : "ComponentName",
    "comment" : "\n     * Returns the configured supervision app if it exists and is the device owner or policy owner.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public String getProfileOwnerName() throws IllegalArgumentException",
    "returnType" : "String",
    "comment" : "\n     * @hide\n     * @return the human readable name of the organisation associated with this DPM or {@code null}\n     *         if one is not set.\n     * @throws IllegalArgumentException if the userId is invalid.\n     ",
    "links" : [ ]
  }, {
    "name" : "public String getProfileOwnerNameAsUser(int userId) throws IllegalArgumentException",
    "returnType" : "String",
    "comment" : "\n     * @hide\n     * @param userId The user for whom to fetch the profile owner name, if any.\n     * @return the human readable name of the organisation associated with this profile owner or\n     *         null if one is not set.\n     * @throws IllegalArgumentException if the userId is invalid.\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean isOrganizationOwnedDeviceWithManagedProfile()",
    "returnType" : "boolean",
    "comment" : "\n     * Apps can use this method to find out if the device was provisioned as\n     * organization-owend device with a managed profile.\n     *\n     * This, together with checking whether the device has a device owner (by calling\n     * {@link #isDeviceOwnerApp}), could be used to learn whether the device is owned by an\n     * organization or an individual:\n     * If this method returns true OR {@link #isDeviceOwnerApp} returns true (for any package),\n     * then the device is owned by an organization. Otherwise, it's owned by an individual.\n     *\n     * @return {@code true} if the device was provisioned as organization-owned device,\n     * {@code false} otherwise.\n     ",
    "links" : [ "#isDeviceOwnerApp", "#isDeviceOwnerApp" ]
  }, {
    "name" : "public boolean hasDeviceIdentifierAccess(@NonNull String packageName, int pid, int uid)",
    "returnType" : "boolean",
    "comment" : "\n     * Returns whether the specified package can read the device identifiers.\n     *\n     * @param packageName The package name of the app to check for device identifier access.\n     * @param pid The process id of the package to be checked.\n     * @param uid The uid of the package to be checked.\n     * @return whether the package can read the device identifiers.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public void addPersistentPreferredActivity(@NonNull ComponentName admin, IntentFilter filter, @NonNull ComponentName activity)",
    "returnType" : "void",
    "comment" : "\n     * Called by a profile owner or device owner to set a default activity that the system selects\n     * to handle intents that match the given {@link IntentFilter}. This activity will remain the\n     * default intent handler even if the set of potential event handlers for the intent filter\n     * changes and if the intent preferences are reset.\n     * <p>\n     * Note that the caller should still declare the activity in the manifest, the API just sets\n     * the activity to be the default one to handle the given intent filter.\n     * <p>\n     * The default disambiguation mechanism takes over if the activity is not installed (anymore).\n     * When the activity is (re)installed, it is automatically reset as default intent handler for\n     * the filter.\n     * <p>\n     * The calling device admin must be a profile owner or device owner. If it is not, a security\n     * exception will be thrown.\n     *\n     * <p>NOTE: Performs disk I/O and shouldn't be called on the main thread.\n     *\n     * @param admin Which {@link DeviceAdminReceiver} this request is associated with.\n     * @param filter The IntentFilter for which a default handler is added.\n     * @param activity The Activity that is added as default intent handler.\n     * @throws SecurityException if {@code admin} is not a device or profile owner.\n     ",
    "links" : [ "IntentFilter", "DeviceAdminReceiver" ]
  }, {
    "name" : "public void clearPackagePersistentPreferredActivities(@NonNull ComponentName admin, String packageName)",
    "returnType" : "void",
    "comment" : "\n     * Called by a profile owner or device owner to remove all persistent intent handler preferences\n     * associated with the given package that were set by {@link #addPersistentPreferredActivity}.\n     * <p>\n     * The calling device admin must be a profile owner. If it is not, a security exception will be\n     * thrown.\n     *\n     * @param admin Which {@link DeviceAdminReceiver} this request is associated with.\n     * @param packageName The name of the package for which preferences are removed.\n     * @throws SecurityException if {@code admin} is not a device or profile owner.\n     ",
    "links" : [ "#addPersistentPreferredActivity", "DeviceAdminReceiver" ]
  }, {
    "name" : "public void setDefaultSmsApplication(@NonNull ComponentName admin, @NonNull String packageName)",
    "returnType" : "void",
    "comment" : "\n     * Must be called by a device owner or a profile owner of an organization-owned managed profile\n     * to set the default SMS application.\n     * <p>\n     * This method can be called on the {@link DevicePolicyManager} instance, returned by\n     * {@link #getParentProfileInstance(ComponentName)}, where the caller must be the profile owner\n     * of an organization-owned managed profile and the package must be a pre-installed system\n     * package. If called on the parent instance, then the default SMS application is set on the\n     * personal profile.\n     *\n     * @param admin       Which {@link DeviceAdminReceiver} this request is associated with.\n     * @param packageName The name of the package to set as the default SMS application.\n     * @throws SecurityException        if {@code admin} is not a device or profile owner or if\n     *                                  called on the parent profile and the {@code admin} is not a\n     *                                  profile owner of an organization-owned managed profile.\n     * @throws IllegalArgumentException if called on the parent profile and the package\n     *                                  provided is not a pre-installed system package.\n     ",
    "links" : [ "DevicePolicyManager", "#getParentProfileInstance", "DeviceAdminReceiver" ]
  }, {
    "name" : "public void setApplicationRestrictionsManagingPackage(@NonNull ComponentName admin, @Nullable String packageName) throws NameNotFoundException",
    "returnType" : "void",
    "comment" : "\n     * Called by a profile owner or device owner to grant permission to a package to manage\n     * application restrictions for the calling user via {@link #setApplicationRestrictions} and\n     * {@link #getApplicationRestrictions}.\n     * <p>\n     * This permission is persistent until it is later cleared by calling this method with a\n     * {@code null} value or uninstalling the managing package.\n     * <p>\n     * The supplied application restriction managing package must be installed when calling this\n     * API, otherwise an {@link NameNotFoundException} will be thrown.\n     *\n     * @param admin Which {@link DeviceAdminReceiver} this request is associated with.\n     * @param packageName The package name which will be given access to application restrictions\n     *            APIs. If {@code null} is given the current package will be cleared.\n     * @throws SecurityException if {@code admin} is not a device or profile owner.\n     * @throws NameNotFoundException if {@code packageName} is not found\n     *\n     * @deprecated From {@link android.os.Build.VERSION_CODES#O}. Use {@link #setDelegatedScopes}\n     * with the {@link #DELEGATION_APP_RESTRICTIONS} scope instead.\n     ",
    "links" : [ "#setApplicationRestrictions", "#getApplicationRestrictions", "NameNotFoundException", "DeviceAdminReceiver", "android.os.Build.VERSION_CODES#O", "#setDelegatedScopes", "#DELEGATION_APP_RESTRICTIONS" ]
  }, {
    "name" : "public String getApplicationRestrictionsManagingPackage(@NonNull ComponentName admin)",
    "returnType" : "String",
    "comment" : "\n     * Called by a profile owner or device owner to retrieve the application restrictions managing\n     * package for the current user, or {@code null} if none is set. If there are multiple\n     * delegates this function will return one of them.\n     *\n     * @param admin Which {@link DeviceAdminReceiver} this request is associated with.\n     * @return The package name allowed to manage application restrictions on the current user, or\n     *         {@code null} if none is set.\n     * @throws SecurityException if {@code admin} is not a device or profile owner.\n     *\n     * @deprecated From {@link android.os.Build.VERSION_CODES#O}. Use {@link #getDelegatePackages}\n     * with the {@link #DELEGATION_APP_RESTRICTIONS} scope instead.\n     ",
    "links" : [ "DeviceAdminReceiver", "android.os.Build.VERSION_CODES#O", "#getDelegatePackages", "#DELEGATION_APP_RESTRICTIONS" ]
  }, {
    "name" : "public boolean isCallerApplicationRestrictionsManagingPackage()",
    "returnType" : "boolean",
    "comment" : "\n     * Called by any application to find out whether it has been granted permission via\n     * {@link #setApplicationRestrictionsManagingPackage} to manage application restrictions\n     * for the calling user.\n     *\n     * <p>This is done by comparing the calling Linux uid with the uid of the package specified by\n     * that method.\n     *\n     * @deprecated From {@link android.os.Build.VERSION_CODES#O}. Use {@link #getDelegatedScopes}\n     * instead.\n     ",
    "links" : [ "#setApplicationRestrictionsManagingPackage", "android.os.Build.VERSION_CODES#O", "#getDelegatedScopes" ]
  }, {
    "name" : "public void setApplicationRestrictions(@Nullable ComponentName admin, String packageName, Bundle settings)",
    "returnType" : "void",
    "comment" : "\n     * Sets the application restrictions for a given target application running in the calling user.\n     * <p>\n     * The caller must be a profile or device owner on that user, or the package allowed to manage\n     * application restrictions via {@link #setDelegatedScopes} with the\n     * {@link #DELEGATION_APP_RESTRICTIONS} scope; otherwise a security exception will be thrown.\n     * <p>\n     * The provided {@link Bundle} consists of key-value pairs, where the types of values may be:\n     * <ul>\n     * <li>{@code boolean}\n     * <li>{@code int}\n     * <li>{@code String} or {@code String[]}\n     * <li>From {@link android.os.Build.VERSION_CODES#M}, {@code Bundle} or {@code Bundle[]}\n     * </ul>\n     * <p>\n     * If the restrictions are not available yet, but may be applied in the near future, the caller\n     * can notify the target application of that by adding\n     * {@link UserManager#KEY_RESTRICTIONS_PENDING} to the settings parameter.\n     * <p>\n     * The application restrictions are only made visible to the target application via\n     * {@link UserManager#getApplicationRestrictions(String)}, in addition to the profile or device\n     * owner, and the application restrictions managing package via\n     * {@link #getApplicationRestrictions}.\n     *\n     * <p>NOTE: The method performs disk I/O and shouldn't be called on the main thread\n     *\n     * @param admin Which {@link DeviceAdminReceiver} this request is associated with, or\n     *            {@code null} if called by the application restrictions managing package.\n     * @param packageName The name of the package to update restricted settings for.\n     * @param settings A {@link Bundle} to be parsed by the receiving application, conveying a new\n     *            set of active restrictions.\n     * @throws SecurityException if {@code admin} is not a device or profile owner.\n     * @see #setDelegatedScopes\n     * @see #DELEGATION_APP_RESTRICTIONS\n     * @see UserManager#KEY_RESTRICTIONS_PENDING\n     ",
    "links" : [ "#setDelegatedScopes", "#DELEGATION_APP_RESTRICTIONS", "Bundle", "android.os.Build.VERSION_CODES#M", "UserManager#KEY_RESTRICTIONS_PENDING", "UserManager#getApplicationRestrictions", "#getApplicationRestrictions", "DeviceAdminReceiver", "Bundle" ]
  }, {
    "name" : "public void setTrustAgentConfiguration(@NonNull ComponentName admin, @NonNull ComponentName target, PersistableBundle configuration)",
    "returnType" : "void",
    "comment" : "\n     * Sets a list of configuration features to enable for a trust agent component. This is meant to\n     * be used in conjunction with {@link #KEYGUARD_DISABLE_TRUST_AGENTS}, which disables all trust\n     * agents but those enabled by this function call. If flag\n     * {@link #KEYGUARD_DISABLE_TRUST_AGENTS} is not set, then this call has no effect.\n     * <p>\n     * For any specific trust agent, whether it is disabled or not depends on the aggregated state\n     * of each admin's {@link #KEYGUARD_DISABLE_TRUST_AGENTS} setting and its trust agent\n     * configuration as set by this function call. In particular: if any admin sets\n     * {@link #KEYGUARD_DISABLE_TRUST_AGENTS} and does not additionally set any\n     * trust agent configuration, the trust agent is disabled completely. Otherwise, the trust agent\n     * will receive the list of configurations from all admins who set\n     * {@link #KEYGUARD_DISABLE_TRUST_AGENTS} and aggregate the configurations to determine its\n     * behavior. The exact meaning of aggregation is trust-agent-specific.\n     * <p>\n     * The calling device admin must have requested\n     * {@link DeviceAdminInfo#USES_POLICY_DISABLE_KEYGUARD_FEATURES} to be able to call this method;\n     * if not, a security exception will be thrown.\n     * <p>\n     * This method can be called on the {@link DevicePolicyManager} instance returned by\n     * {@link #getParentProfileInstance(ComponentName)} in order to set the configuration for\n     * the parent profile.\n     * <p>\n     * On devices not supporting {@link PackageManager#FEATURE_SECURE_LOCK_SCREEN} feature, calling\n     * this method has no effect - no trust agent configuration will be set.\n     *\n     * @param admin Which {@link DeviceAdminReceiver} this request is associated with.\n     * @param target Component name of the agent to be configured.\n     * @param configuration Trust-agent-specific feature configuration bundle. Please consult\n     *        documentation of the specific trust agent to determine the interpretation of this\n     *        bundle.\n     * @throws SecurityException if {@code admin} is not an active administrator or does not use\n     *             {@link DeviceAdminInfo#USES_POLICY_DISABLE_KEYGUARD_FEATURES}\n     ",
    "links" : [ "#KEYGUARD_DISABLE_TRUST_AGENTS", "#KEYGUARD_DISABLE_TRUST_AGENTS", "#KEYGUARD_DISABLE_TRUST_AGENTS", "#KEYGUARD_DISABLE_TRUST_AGENTS", "#KEYGUARD_DISABLE_TRUST_AGENTS", "DeviceAdminInfo#USES_POLICY_DISABLE_KEYGUARD_FEATURES", "DevicePolicyManager", "#getParentProfileInstance", "PackageManager#FEATURE_SECURE_LOCK_SCREEN", "DeviceAdminReceiver", "DeviceAdminInfo#USES_POLICY_DISABLE_KEYGUARD_FEATURES" ]
  }, {
    "name" : "public List<PersistableBundle> getTrustAgentConfiguration(@Nullable ComponentName admin, @NonNull ComponentName agent)",
    "returnType" : "List<PersistableBundle>",
    "comment" : "\n     * Gets configuration for the given trust agent based on aggregating all calls to\n     * {@link #setTrustAgentConfiguration(ComponentName, ComponentName, PersistableBundle)} for\n     * all device admins.\n     * <p>\n     * This method can be called on the {@link DevicePolicyManager} instance returned by\n     * {@link #getParentProfileInstance(ComponentName)} in order to retrieve the configuration set\n     * on the parent profile.\n     * <p>\n     * On devices not supporting {@link PackageManager#FEATURE_SECURE_LOCK_SCREEN} feature, null is\n     * always returned.\n     *\n     * @param admin Which {@link DeviceAdminReceiver} this request is associated with. If null,\n     * this function returns a list of configurations for all admins that declare\n     * {@link #KEYGUARD_DISABLE_TRUST_AGENTS}. If any admin declares\n     * {@link #KEYGUARD_DISABLE_TRUST_AGENTS} but doesn't call\n     * {@link #setTrustAgentConfiguration(ComponentName, ComponentName, PersistableBundle)}\n     * for this {@param agent} or calls it with a null configuration, null is returned.\n     * @param agent Which component to get enabled features for.\n     * @return configuration for the given trust agent.\n     ",
    "links" : [ "#setTrustAgentConfiguration", "DevicePolicyManager", "#getParentProfileInstance", "PackageManager#FEATURE_SECURE_LOCK_SCREEN", "DeviceAdminReceiver", "#KEYGUARD_DISABLE_TRUST_AGENTS", "#KEYGUARD_DISABLE_TRUST_AGENTS", "#setTrustAgentConfiguration" ]
  }, {
    "name" : "public List<PersistableBundle> getTrustAgentConfiguration(@Nullable ComponentName admin, @NonNull ComponentName agent, int userHandle)",
    "returnType" : "List<PersistableBundle>",
    "comment" : " @hide per-user version ",
    "links" : [ ]
  }, {
    "name" : "public void setCrossProfileCallerIdDisabled(@NonNull ComponentName admin, boolean disabled)",
    "returnType" : "void",
    "comment" : "\n     * Called by a profile owner of a managed profile to set whether caller-Id information from the\n     * managed profile will be shown in the parent profile, for incoming calls.\n     * <p>\n     * The calling device admin must be a profile owner. If it is not, a security exception will be\n     * thrown.\n     *\n     * @param admin Which {@link DeviceAdminReceiver} this request is associated with.\n     * @param disabled If true caller-Id information in the managed profile is not displayed.\n     * @throws SecurityException if {@code admin} is not a profile owner.\n     ",
    "links" : [ "DeviceAdminReceiver" ]
  }, {
    "name" : "public boolean getCrossProfileCallerIdDisabled(@NonNull ComponentName admin)",
    "returnType" : "boolean",
    "comment" : "\n     * Called by a profile owner of a managed profile to determine whether or not caller-Id\n     * information has been disabled.\n     * <p>\n     * The calling device admin must be a profile owner. If it is not, a security exception will be\n     * thrown.\n     *\n     * @param admin Which {@link DeviceAdminReceiver} this request is associated with.\n     * @throws SecurityException if {@code admin} is not a profile owner.\n     ",
    "links" : [ "DeviceAdminReceiver" ]
  }, {
    "name" : "public boolean getCrossProfileCallerIdDisabled(UserHandle userHandle)",
    "returnType" : "boolean",
    "comment" : "\n     * Determine whether or not caller-Id information has been disabled.\n     *\n     * @param userHandle The user for whom to check the caller-id permission\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public void setCrossProfileContactsSearchDisabled(@NonNull ComponentName admin, boolean disabled)",
    "returnType" : "void",
    "comment" : "\n     * Called by a profile owner of a managed profile to set whether contacts search from the\n     * managed profile will be shown in the parent profile, for incoming calls.\n     * <p>\n     * The calling device admin must be a profile owner. If it is not, a security exception will be\n     * thrown.\n     *\n     * @param admin Which {@link DeviceAdminReceiver} this request is associated with.\n     * @param disabled If true contacts search in the managed profile is not displayed.\n     * @throws SecurityException if {@code admin} is not a profile owner.\n     ",
    "links" : [ "DeviceAdminReceiver" ]
  }, {
    "name" : "public boolean getCrossProfileContactsSearchDisabled(@NonNull ComponentName admin)",
    "returnType" : "boolean",
    "comment" : "\n     * Called by a profile owner of a managed profile to determine whether or not contacts search\n     * has been disabled.\n     * <p>\n     * The calling device admin must be a profile owner. If it is not, a security exception will be\n     * thrown.\n     *\n     * @param admin Which {@link DeviceAdminReceiver} this request is associated with.\n     * @throws SecurityException if {@code admin} is not a profile owner.\n     ",
    "links" : [ "DeviceAdminReceiver" ]
  }, {
    "name" : "public boolean getCrossProfileContactsSearchDisabled(@NonNull UserHandle userHandle)",
    "returnType" : "boolean",
    "comment" : "\n     * Determine whether or not contacts search has been disabled.\n     *\n     * @param userHandle The user for whom to check the contacts search permission\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public void startManagedQuickContact(String actualLookupKey, long actualContactId, boolean isContactIdIgnored, long directoryId, Intent originalIntent)",
    "returnType" : "void",
    "comment" : "\n     * Start Quick Contact on the managed profile for the user, if the policy allows.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public void startManagedQuickContact(String actualLookupKey, long actualContactId, Intent originalIntent)",
    "returnType" : "void",
    "comment" : "\n     * Start Quick Contact on the managed profile for the user, if the policy allows.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public void setBluetoothContactSharingDisabled(@NonNull ComponentName admin, boolean disabled)",
    "returnType" : "void",
    "comment" : "\n     * Called by a profile owner of a managed profile to set whether bluetooth devices can access\n     * enterprise contacts.\n     * <p>\n     * The calling device admin must be a profile owner. If it is not, a security exception will be\n     * thrown.\n     * <p>\n     * This API works on managed profile only.\n     *\n     * @param admin Which {@link DeviceAdminReceiver} this request is associated with.\n     * @param disabled If true, bluetooth devices cannot access enterprise contacts.\n     * @throws SecurityException if {@code admin} is not a profile owner.\n     ",
    "links" : [ "DeviceAdminReceiver" ]
  }, {
    "name" : "public boolean getBluetoothContactSharingDisabled(@NonNull ComponentName admin)",
    "returnType" : "boolean",
    "comment" : "\n     * Called by a profile owner of a managed profile to determine whether or not Bluetooth devices\n     * cannot access enterprise contacts.\n     * <p>\n     * The calling device admin must be a profile owner. If it is not, a security exception will be\n     * thrown.\n     * <p>\n     * This API works on managed profile only.\n     *\n     * @param admin Which {@link DeviceAdminReceiver} this request is associated with.\n     * @throws SecurityException if {@code admin} is not a profile owner.\n     ",
    "links" : [ "DeviceAdminReceiver" ]
  }, {
    "name" : "public boolean getBluetoothContactSharingDisabled(@NonNull UserHandle userHandle)",
    "returnType" : "boolean",
    "comment" : "\n     * Determine whether or not Bluetooth devices cannot access contacts.\n     * <p>\n     * This API works on managed profile UserHandle only.\n     *\n     * @param userHandle The user for whom to check the caller-id permission\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public void addCrossProfileIntentFilter(@NonNull ComponentName admin, IntentFilter filter, int flags)",
    "returnType" : "void",
    "comment" : "\n     * Called by the profile owner of a managed profile so that some intents sent in the managed\n     * profile can also be resolved in the parent, or vice versa. Only activity intents are\n     * supported.\n     *\n     * @param admin Which {@link DeviceAdminReceiver} this request is associated with.\n     * @param filter The {@link IntentFilter} the intent has to match to be also resolved in the\n     *            other profile\n     * @param flags {@link DevicePolicyManager#FLAG_MANAGED_CAN_ACCESS_PARENT} and\n     *            {@link DevicePolicyManager#FLAG_PARENT_CAN_ACCESS_MANAGED} are supported.\n     * @throws SecurityException if {@code admin} is not a device or profile owner.\n     ",
    "links" : [ "DeviceAdminReceiver", "IntentFilter", "DevicePolicyManager#FLAG_MANAGED_CAN_ACCESS_PARENT", "DevicePolicyManager#FLAG_PARENT_CAN_ACCESS_MANAGED" ]
  }, {
    "name" : "public void clearCrossProfileIntentFilters(@NonNull ComponentName admin)",
    "returnType" : "void",
    "comment" : "\n     * Called by a profile owner of a managed profile to remove the cross-profile intent filters\n     * that go from the managed profile to the parent, or from the parent to the managed profile.\n     * Only removes those that have been set by the profile owner.\n     * <p>\n     * <em>Note</em>: A list of default cross profile intent filters are set up by the system when\n     * the profile is created, some of them ensure the proper functioning of the profile, while\n     * others enable sharing of data from the parent to the managed profile for user convenience.\n     * These default intent filters are not cleared when this API is called. If the default cross\n     * profile data sharing is not desired, they can be disabled with\n     * {@link UserManager#DISALLOW_SHARE_INTO_MANAGED_PROFILE}.\n     *\n     * @param admin Which {@link DeviceAdminReceiver} this request is associated with.\n     * @throws SecurityException if {@code admin} is not a profile owner.\n     ",
    "links" : [ "UserManager#DISALLOW_SHARE_INTO_MANAGED_PROFILE", "DeviceAdminReceiver" ]
  }, {
    "name" : "public boolean setPermittedAccessibilityServices(@NonNull ComponentName admin, List<String> packageNames)",
    "returnType" : "boolean",
    "comment" : "\n     * Called by a profile or device owner to set the permitted\n     * {@link android.accessibilityservice.AccessibilityService}. When set by\n     * a device owner or profile owner the restriction applies to all profiles of the user the\n     * device owner or profile owner is an admin for. By default, the user can use any accessibility\n     * service. When zero or more packages have been added, accessibility services that are not in\n     * the list and not part of the system can not be enabled by the user.\n     * <p>\n     * Calling with a null value for the list disables the restriction so that all services can be\n     * used, calling with an empty list only allows the built-in system services. Any non-system\n     * accessibility service that's currently enabled must be included in the list.\n     * <p>\n     * System accessibility services are always available to the user and this method can't\n     * disable them.\n     * @param admin Which {@link DeviceAdminReceiver} this request is associated with.\n     * @param packageNames List of accessibility service package names.\n     * @return {@code true} if the operation succeeded, or {@code false} if the list didn't\n     *         contain every enabled non-system accessibility service.\n     * @throws SecurityException if {@code admin} is not a device or profile owner.\n     ",
    "links" : [ "android.accessibilityservice.AccessibilityService", "DeviceAdminReceiver" ]
  }, {
    "name" : "public List<String> getPermittedAccessibilityServices(@NonNull ComponentName admin)",
    "returnType" : "List<String>",
    "comment" : "\n     * Returns the list of permitted accessibility services set by this device or profile owner.\n     * <p>\n     * An empty list means no accessibility services except system services are allowed. Null means\n     * all accessibility services are allowed.\n     *\n     * @param admin Which {@link DeviceAdminReceiver} this request is associated with.\n     * @return List of accessiblity service package names.\n     * @throws SecurityException if {@code admin} is not a device or profile owner.\n     ",
    "links" : [ "DeviceAdminReceiver" ]
  }, {
    "name" : "public boolean isAccessibilityServicePermittedByAdmin(@NonNull ComponentName admin, @NonNull String packageName, int userHandle)",
    "returnType" : "boolean",
    "comment" : "\n     * Called by the system to check if a specific accessibility service is disabled by admin.\n     *\n     * @param admin Which {@link DeviceAdminReceiver} this request is associated with.\n     * @param packageName Accessibility service package name that needs to be checked.\n     * @param userHandle user id the admin is running as.\n     * @return true if the accessibility service is permitted, otherwise false.\n     *\n     * @hide\n     ",
    "links" : [ "DeviceAdminReceiver" ]
  }, {
    "name" : "public List<String> getPermittedAccessibilityServices(int userId)",
    "returnType" : "List<String>",
    "comment" : "\n     * Returns the list of accessibility services permitted by the device or profiles\n     * owners of this user.\n     *\n     * <p>Null means all accessibility services are allowed, if a non-null list is returned\n     * it will contain the intersection of the permitted lists for any device or profile\n     * owners that apply to this user. It will also include any system accessibility services.\n     *\n     * @param userId which user to check for.\n     * @return List of accessiblity service package names.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean setPermittedInputMethods(@NonNull ComponentName admin, List<String> packageNames)",
    "returnType" : "boolean",
    "comment" : "\n     * Called by a profile or device owner to set the permitted input methods services for this\n     * user. By default, the user can use any input method.\n     * <p>\n     * When zero or more packages have been added, input method that are not in the list and not\n     * part of the system can not be enabled by the user. This method will fail if it is called for\n     * a admin that is not for the foreground user or a profile of the foreground user. Any\n     * non-system input method service that's currently enabled must be included in the list.\n     * <p>\n     * Calling with a null value for the list disables the restriction so that all input methods can\n     * be used, calling with an empty list disables all but the system's own input methods.\n     * <p>\n     * System input methods are always available to the user - this method can't modify this.\n     *\n     * @param admin Which {@link DeviceAdminReceiver} this request is associated with.\n     * @param packageNames List of input method package names.\n     * @return {@code true} if the operation succeeded, or {@code false} if the list didn't\n     *        contain every enabled non-system input method service.\n     * @throws SecurityException if {@code admin} is not a device or profile owner.\n     ",
    "links" : [ "DeviceAdminReceiver" ]
  }, {
    "name" : "public List<String> getPermittedInputMethods(@NonNull ComponentName admin)",
    "returnType" : "List<String>",
    "comment" : "\n     * Returns the list of permitted input methods set by this device or profile owner.\n     * <p>\n     * An empty list means no input methods except system input methods are allowed. Null means all\n     * input methods are allowed.\n     *\n     * @param admin Which {@link DeviceAdminReceiver} this request is associated with.\n     * @return List of input method package names.\n     * @throws SecurityException if {@code admin} is not a device or profile owner.\n     ",
    "links" : [ "DeviceAdminReceiver" ]
  }, {
    "name" : "public boolean isInputMethodPermittedByAdmin(@NonNull ComponentName admin, @NonNull String packageName, int userHandle)",
    "returnType" : "boolean",
    "comment" : "\n     * Called by the system to check if a specific input method is disabled by admin.\n     *\n     * @param admin Which {@link DeviceAdminReceiver} this request is associated with.\n     * @param packageName Input method package name that needs to be checked.\n     * @param userHandle user id the admin is running as.\n     * @return true if the input method is permitted, otherwise false.\n     *\n     * @hide\n     ",
    "links" : [ "DeviceAdminReceiver" ]
  }, {
    "name" : "public List<String> getPermittedInputMethodsForCurrentUser()",
    "returnType" : "List<String>",
    "comment" : "\n     * Returns the list of input methods permitted by the device or profiles owners.\n     *\n     * <p>On {@link android.os.Build.VERSION_CODES#Q} and later devices, this method returns the\n     * result for the calling user.</p>\n     *\n     * <p>On Android P and prior devices, this method returns the result for the current user.</p>\n     *\n     * <p>Null means all input methods are allowed, if a non-null list is returned\n     * it will contain the intersection of the permitted lists for any device or profile\n     * owners that apply to this user. It will also include any system input methods.\n     *\n     * @return List of input method package names.\n     * @hide\n     ",
    "links" : [ "android.os.Build.VERSION_CODES#Q" ]
  }, {
    "name" : "public boolean setPermittedCrossProfileNotificationListeners(@NonNull ComponentName admin, @Nullable List<String> packageList)",
    "returnType" : "boolean",
    "comment" : "\n     * Called by a profile owner of a managed profile to set the packages that are allowed to use\n     * a {@link android.service.notification.NotificationListenerService} in the primary user to\n     * see notifications from the managed profile. By default all packages are permitted by this\n     * policy. When zero or more packages have been added, notification listeners installed on the\n     * primary user that are not in the list and are not part of the system won't receive events\n     * for managed profile notifications.\n     * <p>\n     * Calling with a {@code null} value for the list disables the restriction so that all\n     * notification listener services be used. Calling with an empty list disables all but the\n     * system's own notification listeners. System notification listener services are always\n     * available to the user.\n     * <p>\n     * If a device or profile owner want to stop notification listeners in their user from seeing\n     * that user's notifications they should prevent that service from running instead (e.g. via\n     * {@link #setApplicationHidden(ComponentName, String, boolean)})\n     *\n     * @param admin Which {@link DeviceAdminReceiver} this request is associated with.\n     * @param packageList List of package names to whitelist\n     * @return true if setting the restriction succeeded. It will fail if called outside a managed\n     * profile\n     * @throws SecurityException if {@code admin} is not a profile owner.\n     *\n     * @see android.service.notification.NotificationListenerService\n     ",
    "links" : [ "android.service.notification.NotificationListenerService", "#setApplicationHidden", "DeviceAdminReceiver" ]
  }, {
    "name" : "public List<String> getPermittedCrossProfileNotificationListeners(@NonNull ComponentName admin)",
    "returnType" : "List<String>",
    "comment" : "\n     * Returns the list of packages installed on the primary user that allowed to use a\n     * {@link android.service.notification.NotificationListenerService} to receive\n     * notifications from this managed profile, as set by the profile owner.\n     * <p>\n     * An empty list means no notification listener services except system ones are allowed.\n     * A {@code null} return value indicates that all notification listeners are allowed.\n     ",
    "links" : [ "android.service.notification.NotificationListenerService" ]
  }, {
    "name" : "public boolean isNotificationListenerServicePermitted(@NonNull String packageName, @UserIdInt int userId)",
    "returnType" : "boolean",
    "comment" : "\n     * Returns true if {@code NotificationListenerServices} from the given package are allowed to\n     * receive events for notifications from the given user id. Can only be called by the system uid\n     *\n     * @see #setPermittedCrossProfileNotificationListeners(ComponentName, List)\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public List<String> getKeepUninstalledPackages(@Nullable ComponentName admin)",
    "returnType" : "List<String>",
    "comment" : "\n     * Get the list of apps to keep around as APKs even if no user has currently installed it. This\n     * function can be called by a device owner or by a delegate given the\n     * {@link #DELEGATION_KEEP_UNINSTALLED_PACKAGES} scope via {@link #setDelegatedScopes}.\n     * <p>\n     * Please note that packages returned in this method are not automatically pre-cached.\n     *\n     * @param admin Which {@link DeviceAdminReceiver} this request is associated with, or\n     *            {@code null} if the caller is a keep uninstalled packages delegate.\n     * @return List of package names to keep cached.\n     * @see #setDelegatedScopes\n     * @see #DELEGATION_KEEP_UNINSTALLED_PACKAGES\n     ",
    "links" : [ "#DELEGATION_KEEP_UNINSTALLED_PACKAGES", "#setDelegatedScopes", "DeviceAdminReceiver" ]
  }, {
    "name" : "public void setKeepUninstalledPackages(@Nullable ComponentName admin, @NonNull List<String> packageNames)",
    "returnType" : "void",
    "comment" : "\n     * Set a list of apps to keep around as APKs even if no user has currently installed it. This\n     * function can be called by a device owner or by a delegate given the\n     * {@link #DELEGATION_KEEP_UNINSTALLED_PACKAGES} scope via {@link #setDelegatedScopes}.\n     *\n     * <p>Please note that setting this policy does not imply that specified apps will be\n     * automatically pre-cached.</p>\n     *\n     * @param admin Which {@link DeviceAdminReceiver} this request is associated with, or\n     *            {@code null} if the caller is a keep uninstalled packages delegate.\n     * @param packageNames List of package names to keep cached.\n     * @throws SecurityException if {@code admin} is not a device owner.\n     * @see #setDelegatedScopes\n     * @see #DELEGATION_KEEP_UNINSTALLED_PACKAGES\n     ",
    "links" : [ "#DELEGATION_KEEP_UNINSTALLED_PACKAGES", "#setDelegatedScopes", "DeviceAdminReceiver" ]
  }, {
    "name" : "public UserHandle createAndManageUser(@NonNull ComponentName admin, @NonNull String name, @NonNull ComponentName profileOwner, @Nullable PersistableBundle adminExtras, @CreateAndManageUserFlags int flags)",
    "returnType" : "UserHandle",
    "comment" : "\n     * Called by a device owner to create a user with the specified name and a given component of\n     * the calling package as profile owner. The UserHandle returned by this method should not be\n     * persisted as user handles are recycled as users are removed and created. If you need to\n     * persist an identifier for this user, use {@link UserManager#getSerialNumberForUser}. The new\n     * user will not be started in the background.\n     * <p>\n     * admin is the {@link DeviceAdminReceiver} which is the device owner. profileOwner is also a\n     * DeviceAdminReceiver in the same package as admin, and will become the profile owner and will\n     * be registered as an active admin on the new user. The profile owner package will be installed\n     * on the new user.\n     * <p>\n     * If the adminExtras are not null, they will be stored on the device until the user is started\n     * for the first time. Then the extras will be passed to the admin when onEnable is called.\n     * <p>From {@link android.os.Build.VERSION_CODES#P} onwards, if targeting\n     * {@link android.os.Build.VERSION_CODES#P}, throws {@link UserOperationException} instead of\n     * returning {@code null} on failure.\n     *\n     * @param admin Which {@link DeviceAdminReceiver} this request is associated with.\n     * @param name The user's name.\n     * @param profileOwner Which {@link DeviceAdminReceiver} will be profile owner. Has to be in the\n     *            same package as admin, otherwise no user is created and an\n     *            IllegalArgumentException is thrown.\n     * @param adminExtras Extras that will be passed to onEnable of the admin receiver on the new\n     *            user.\n     * @param flags {@link #SKIP_SETUP_WIZARD}, {@link #MAKE_USER_EPHEMERAL} and\n     *        {@link #LEAVE_ALL_SYSTEM_APPS_ENABLED} are supported.\n     * @see UserHandle\n     * @return the {@link android.os.UserHandle} object for the created user, or {@code null} if the\n     *         user could not be created.\n     * @throws SecurityException if {@code admin} is not a device owner.\n     * @throws UserOperationException if the user could not be created and the calling app is\n     * targeting {@link android.os.Build.VERSION_CODES#P} and running on\n     * {@link android.os.Build.VERSION_CODES#P}.\n     ",
    "links" : [ "UserManager#getSerialNumberForUser", "DeviceAdminReceiver", "android.os.Build.VERSION_CODES#P", "android.os.Build.VERSION_CODES#P", "UserOperationException", "DeviceAdminReceiver", "DeviceAdminReceiver", "#SKIP_SETUP_WIZARD", "#MAKE_USER_EPHEMERAL", "#LEAVE_ALL_SYSTEM_APPS_ENABLED", "android.os.UserHandle", "android.os.Build.VERSION_CODES#P", "android.os.Build.VERSION_CODES#P" ]
  }, {
    "name" : "public boolean removeUser(@NonNull ComponentName admin, @NonNull UserHandle userHandle)",
    "returnType" : "boolean",
    "comment" : "\n     * Called by a device owner to remove a user/profile and all associated data. The primary user\n     * can not be removed.\n     *\n     * @param admin Which {@link DeviceAdminReceiver} this request is associated with.\n     * @param userHandle the user to remove.\n     * @return {@code true} if the user was removed, {@code false} otherwise.\n     * @throws SecurityException if {@code admin} is not a device owner.\n     ",
    "links" : [ "DeviceAdminReceiver" ]
  }, {
    "name" : "public boolean switchUser(@NonNull ComponentName admin, @Nullable UserHandle userHandle)",
    "returnType" : "boolean",
    "comment" : "\n     * Called by a device owner to switch the specified secondary user to the foreground.\n     *\n     * @param admin Which {@link DeviceAdminReceiver} this request is associated with.\n     * @param userHandle the user to switch to; null will switch to primary.\n     * @return {@code true} if the switch was successful, {@code false} otherwise.\n     * @throws SecurityException if {@code admin} is not a device owner.\n     * @see Intent#ACTION_USER_FOREGROUND\n     * @see #getSecondaryUsers(ComponentName)\n     ",
    "links" : [ "DeviceAdminReceiver" ]
  }, {
    "name" : "public int startUserInBackground(@NonNull ComponentName admin, @NonNull UserHandle userHandle)",
    "returnType" : "int",
    "comment" : "\n     * Called by a device owner to start the specified secondary user in background.\n     *\n     * @param admin Which {@link DeviceAdminReceiver} this request is associated with.\n     * @param userHandle the user to be started in background.\n     * @return one of the following result codes:\n     * {@link UserManager#USER_OPERATION_ERROR_UNKNOWN},\n     * {@link UserManager#USER_OPERATION_SUCCESS},\n     * {@link UserManager#USER_OPERATION_ERROR_MANAGED_PROFILE},\n     * {@link UserManager#USER_OPERATION_ERROR_MAX_RUNNING_USERS},\n     * @throws SecurityException if {@code admin} is not a device owner.\n     * @see #getSecondaryUsers(ComponentName)\n     ",
    "links" : [ "DeviceAdminReceiver", "UserManager#USER_OPERATION_ERROR_UNKNOWN", "UserManager#USER_OPERATION_SUCCESS", "UserManager#USER_OPERATION_ERROR_MANAGED_PROFILE", "UserManager#USER_OPERATION_ERROR_MAX_RUNNING_USERS" ]
  }, {
    "name" : "public int stopUser(@NonNull ComponentName admin, @NonNull UserHandle userHandle)",
    "returnType" : "int",
    "comment" : "\n     * Called by a device owner to stop the specified secondary user.\n     *\n     * @param admin Which {@link DeviceAdminReceiver} this request is associated with.\n     * @param userHandle the user to be stopped.\n     * @return one of the following result codes:\n     * {@link UserManager#USER_OPERATION_ERROR_UNKNOWN},\n     * {@link UserManager#USER_OPERATION_SUCCESS},\n     * {@link UserManager#USER_OPERATION_ERROR_MANAGED_PROFILE},\n     * {@link UserManager#USER_OPERATION_ERROR_CURRENT_USER}\n     * @throws SecurityException if {@code admin} is not a device owner.\n     * @see #getSecondaryUsers(ComponentName)\n     ",
    "links" : [ "DeviceAdminReceiver", "UserManager#USER_OPERATION_ERROR_UNKNOWN", "UserManager#USER_OPERATION_SUCCESS", "UserManager#USER_OPERATION_ERROR_MANAGED_PROFILE", "UserManager#USER_OPERATION_ERROR_CURRENT_USER" ]
  }, {
    "name" : "public int logoutUser(@NonNull ComponentName admin)",
    "returnType" : "int",
    "comment" : "\n     * Called by a profile owner of secondary user that is affiliated with the device to stop the\n     * calling user and switch back to primary.\n     *\n     * @param admin Which {@link DeviceAdminReceiver} this request is associated with.\n     * @return one of the following result codes:\n     * {@link UserManager#USER_OPERATION_ERROR_UNKNOWN},\n     * {@link UserManager#USER_OPERATION_SUCCESS},\n     * {@link UserManager#USER_OPERATION_ERROR_MANAGED_PROFILE},\n     * {@link UserManager#USER_OPERATION_ERROR_CURRENT_USER}\n     * @throws SecurityException if {@code admin} is not a profile owner affiliated with the device.\n     * @see #getSecondaryUsers(ComponentName)\n     ",
    "links" : [ "DeviceAdminReceiver", "UserManager#USER_OPERATION_ERROR_UNKNOWN", "UserManager#USER_OPERATION_SUCCESS", "UserManager#USER_OPERATION_ERROR_MANAGED_PROFILE", "UserManager#USER_OPERATION_ERROR_CURRENT_USER" ]
  }, {
    "name" : "public List<UserHandle> getSecondaryUsers(@NonNull ComponentName admin)",
    "returnType" : "List<UserHandle>",
    "comment" : "\n     * Called by a device owner to list all secondary users on the device. Managed profiles are not\n     * considered as secondary users.\n     * <p> Used for various user management APIs, including {@link #switchUser}, {@link #removeUser}\n     * and {@link #stopUser}.\n     *\n     * @param admin Which {@link DeviceAdminReceiver} this request is associated with.\n     * @return list of other {@link UserHandle}s on the device.\n     * @throws SecurityException if {@code admin} is not a device owner.\n     * @see #removeUser(ComponentName, UserHandle)\n     * @see #switchUser(ComponentName, UserHandle)\n     * @see #startUserInBackground(ComponentName, UserHandle)\n     * @see #stopUser(ComponentName, UserHandle)\n     ",
    "links" : [ "#switchUser", "#removeUser", "#stopUser", "DeviceAdminReceiver", "UserHandle" ]
  }, {
    "name" : "public boolean isEphemeralUser(@NonNull ComponentName admin)",
    "returnType" : "boolean",
    "comment" : "\n     * Checks if the profile owner is running in an ephemeral user.\n     *\n     * @param admin Which {@link DeviceAdminReceiver} this request is associated with.\n     * @return whether the profile owner is running in an ephemeral user.\n     ",
    "links" : [ "DeviceAdminReceiver" ]
  }, {
    "name" : "public Bundle getApplicationRestrictions(@Nullable ComponentName admin, String packageName)",
    "returnType" : "Bundle",
    "comment" : "\n     * Retrieves the application restrictions for a given target application running in the calling\n     * user.\n     * <p>\n     * The caller must be a profile or device owner on that user, or the package allowed to manage\n     * application restrictions via {@link #setDelegatedScopes} with the\n     * {@link #DELEGATION_APP_RESTRICTIONS} scope; otherwise a security exception will be thrown.\n     *\n     * <p>NOTE: The method performs disk I/O and shouldn't be called on the main thread\n     *\n     * @param admin Which {@link DeviceAdminReceiver} this request is associated with, or\n     *            {@code null} if called by the application restrictions managing package.\n     * @param packageName The name of the package to fetch restricted settings of.\n     * @return {@link Bundle} of settings corresponding to what was set last time\n     *         {@link DevicePolicyManager#setApplicationRestrictions} was called, or an empty\n     *         {@link Bundle} if no restrictions have been set.\n     * @throws SecurityException if {@code admin} is not a device or profile owner.\n     * @see #setDelegatedScopes\n     * @see #DELEGATION_APP_RESTRICTIONS\n     ",
    "links" : [ "#setDelegatedScopes", "#DELEGATION_APP_RESTRICTIONS", "DeviceAdminReceiver", "Bundle", "DevicePolicyManager#setApplicationRestrictions", "Bundle" ]
  }, {
    "name" : "public void addUserRestriction(@NonNull ComponentName admin, @UserManager.UserRestrictionKey String key)",
    "returnType" : "void",
    "comment" : "\n     * Called by a profile or device owner to set a user restriction specified by the key.\n     * <p>\n     * The calling device admin must be a profile or device owner; if it is not, a security\n     * exception will be thrown.\n     * <p>\n     * The profile owner of an organization-owned managed profile may invoke this method on\n     * the {@link DevicePolicyManager} instance it obtained from\n     * {@link #getParentProfileInstance(ComponentName)}, for enforcing device-wide restrictions.\n     * <p>\n     * See the constants in {@link android.os.UserManager} for the list of restrictions that can\n     * be enforced device-wide.\n     *\n     * @param admin Which {@link DeviceAdminReceiver} this request is associated with.\n     * @param key   The key of the restriction.\n     * @throws SecurityException if {@code admin} is not a device or profile owner.\n     ",
    "links" : [ "DevicePolicyManager", "#getParentProfileInstance", "android.os.UserManager", "DeviceAdminReceiver" ]
  }, {
    "name" : "public void clearUserRestriction(@NonNull ComponentName admin, @UserManager.UserRestrictionKey String key)",
    "returnType" : "void",
    "comment" : "\n     * Called by a profile or device owner to clear a user restriction specified by the key.\n     * <p>\n     * The calling device admin must be a profile or device owner; if it is not, a security\n     * exception will be thrown.\n     * <p>\n     * The profile owner of an organization-owned managed profile may invoke this method on\n     * the {@link DevicePolicyManager} instance it obtained from\n     * {@link #getParentProfileInstance(ComponentName)}, for clearing device-wide restrictions.\n     * <p>\n     * See the constants in {@link android.os.UserManager} for the list of restrictions.\n     *\n     * @param admin Which {@link DeviceAdminReceiver} this request is associated with.\n     * @param key   The key of the restriction.\n     * @throws SecurityException if {@code admin} is not a device or profile owner.\n     ",
    "links" : [ "DevicePolicyManager", "#getParentProfileInstance", "android.os.UserManager", "DeviceAdminReceiver" ]
  }, {
    "name" : "public Bundle getUserRestrictions(@NonNull ComponentName admin)",
    "returnType" : "Bundle",
    "comment" : "\n     * Called by a profile or device owner to get user restrictions set with\n     * {@link #addUserRestriction(ComponentName, String)}.\n     * <p>\n     * The target user may have more restrictions set by the system or other device owner / profile\n     * owner. To get all the user restrictions currently set, use\n     * {@link UserManager#getUserRestrictions()}.\n     * <p>\n     * The profile owner of an organization-owned managed profile may invoke this method on\n     * the {@link DevicePolicyManager} instance it obtained from\n     * {@link #getParentProfileInstance(ComponentName)}, for retrieving device-wide restrictions\n     * it previously set with {@link #addUserRestriction(ComponentName, String)}.\n     *\n     * @param admin Which {@link DeviceAdminReceiver} this request is associated with.\n     * @throws SecurityException if {@code admin} is not a device or profile owner.\n     ",
    "links" : [ "#addUserRestriction", "UserManager#getUserRestrictions", "DevicePolicyManager", "#getParentProfileInstance", "#addUserRestriction", "DeviceAdminReceiver" ]
  }, {
    "name" : "public Intent createAdminSupportIntent(@NonNull String restriction)",
    "returnType" : "Intent",
    "comment" : "\n     * Called by any app to display a support dialog when a feature was disabled by an admin.\n     * This returns an intent that can be used with {@link Context#startActivity(Intent)} to\n     * display the dialog. It will tell the user that the feature indicated by {@code restriction}\n     * was disabled by an admin, and include a link for more information. The default content of\n     * the dialog can be changed by the restricting admin via\n     * {@link #setShortSupportMessage(ComponentName, CharSequence)}. If the restriction is not\n     * set (i.e. the feature is available), then the return value will be {@code null}.\n     * @param restriction Indicates for which feature the dialog should be displayed. Can be a\n     *            user restriction from {@link UserManager}, e.g.\n     *            {@link UserManager#DISALLOW_ADJUST_VOLUME}, or one of the constants\n     *            {@link #POLICY_DISABLE_CAMERA} or {@link #POLICY_DISABLE_SCREEN_CAPTURE}.\n     * @return Intent An intent to be used to start the dialog-activity if the restriction is\n     *            set by an admin, or null if the restriction does not exist or no admin set it.\n     ",
    "links" : [ "Context#startActivity", "#setShortSupportMessage", "UserManager", "UserManager#DISALLOW_ADJUST_VOLUME", "#POLICY_DISABLE_CAMERA", "#POLICY_DISABLE_SCREEN_CAPTURE" ]
  }, {
    "name" : "public boolean setApplicationHidden(@NonNull ComponentName admin, String packageName, boolean hidden)",
    "returnType" : "boolean",
    "comment" : "\n     * Hide or unhide packages. When a package is hidden it is unavailable for use, but the data and\n     * actual package file remain. This function can be called by a device owner, profile owner, or\n     * by a delegate given the {@link #DELEGATION_PACKAGE_ACCESS} scope via\n     * {@link #setDelegatedScopes}.\n     * <p>\n     * This method can be called on the {@link DevicePolicyManager} instance, returned by\n     * {@link #getParentProfileInstance(ComponentName)}, where the caller must be the profile owner\n     * of an organization-owned managed profile and the package must be a system package. If called\n     * on the parent instance, then the package is hidden or unhidden in the personal profile.\n     *\n     * @param admin Which {@link DeviceAdminReceiver} this request is associated with, or\n     *            {@code null} if the caller is a package access delegate.\n     * @param packageName The name of the package to hide or unhide.\n     * @param hidden {@code true} if the package should be hidden, {@code false} if it should be\n     *            unhidden.\n     * @return boolean Whether the hidden setting of the package was successfully updated.\n     * @throws SecurityException if {@code admin} is not a device or profile owner or if called on\n     *            the parent profile and the {@code admin} is not a profile owner of an\n     *            organization-owned managed profile.\n     * @throws IllegalArgumentException if called on the parent profile and the package provided\n     *            is not a system package.\n     * @see #setDelegatedScopes\n     * @see #DELEGATION_PACKAGE_ACCESS\n     ",
    "links" : [ "#DELEGATION_PACKAGE_ACCESS", "#setDelegatedScopes", "DevicePolicyManager", "#getParentProfileInstance", "DeviceAdminReceiver" ]
  }, {
    "name" : "public boolean isApplicationHidden(@NonNull ComponentName admin, String packageName)",
    "returnType" : "boolean",
    "comment" : "\n     * Determine if a package is hidden. This function can be called by a device owner, profile\n     * owner, or by a delegate given the {@link #DELEGATION_PACKAGE_ACCESS} scope via\n     * {@link #setDelegatedScopes}.\n     * <p>\n     * This method can be called on the {@link DevicePolicyManager} instance, returned by\n     * {@link #getParentProfileInstance(ComponentName)}, where the caller must be the profile owner\n     * of an organization-owned managed profile and the package must be a system package. If called\n     * on the parent instance, this will determine whether the package is hidden or unhidden in the\n     * personal profile.\n     *\n     * @param admin Which {@link DeviceAdminReceiver} this request is associated with, or\n     *            {@code null} if the caller is a package access delegate.\n     * @param packageName The name of the package to retrieve the hidden status of.\n     * @return boolean {@code true} if the package is hidden, {@code false} otherwise.\n     * @throws SecurityException if {@code admin} is not a device or profile owner or if called on\n     *            the parent profile and the {@code admin} is not a profile owner of an\n     *            organization-owned managed profile.\n     * @throws IllegalArgumentException if called on the parent profile and the package provided\n     *            is not a system package.\n     * @see #setDelegatedScopes\n     * @see #DELEGATION_PACKAGE_ACCESS\n     ",
    "links" : [ "#DELEGATION_PACKAGE_ACCESS", "#setDelegatedScopes", "DevicePolicyManager", "#getParentProfileInstance", "DeviceAdminReceiver" ]
  }, {
    "name" : "public void enableSystemApp(@NonNull ComponentName admin, String packageName)",
    "returnType" : "void",
    "comment" : "\n     * Re-enable a system app that was disabled by default when the user was initialized. This\n     * function can be called by a device owner, profile owner, or by a delegate given the\n     * {@link #DELEGATION_ENABLE_SYSTEM_APP} scope via {@link #setDelegatedScopes}.\n     *\n     * @param admin Which {@link DeviceAdminReceiver} this request is associated with, or\n     *            {@code null} if the caller is an enable system app delegate.\n     * @param packageName The package to be re-enabled in the calling profile.\n     * @throws SecurityException if {@code admin} is not a device or profile owner.\n     * @see #setDelegatedScopes\n     * @see #DELEGATION_PACKAGE_ACCESS\n     ",
    "links" : [ "#DELEGATION_ENABLE_SYSTEM_APP", "#setDelegatedScopes", "DeviceAdminReceiver" ]
  }, {
    "name" : "public int enableSystemApp(@NonNull ComponentName admin, Intent intent)",
    "returnType" : "int",
    "comment" : "\n     * Re-enable system apps by intent that were disabled by default when the user was initialized.\n     * This function can be called by a device owner, profile owner, or by a delegate given the\n     * {@link #DELEGATION_ENABLE_SYSTEM_APP} scope via {@link #setDelegatedScopes}.\n     *\n     * @param admin Which {@link DeviceAdminReceiver} this request is associated with, or\n     *            {@code null} if the caller is an enable system app delegate.\n     * @param intent An intent matching the app(s) to be installed. All apps that resolve for this\n     *            intent will be re-enabled in the calling profile.\n     * @return int The number of activities that matched the intent and were installed.\n     * @throws SecurityException if {@code admin} is not a device or profile owner.\n     * @see #setDelegatedScopes\n     * @see #DELEGATION_PACKAGE_ACCESS\n     ",
    "links" : [ "#DELEGATION_ENABLE_SYSTEM_APP", "#setDelegatedScopes", "DeviceAdminReceiver" ]
  }, {
    "name" : "public boolean installExistingPackage(@NonNull ComponentName admin, String packageName)",
    "returnType" : "boolean",
    "comment" : "\n     * Install an existing package that has been installed in another user, or has been kept after\n     * removal via {@link #setKeepUninstalledPackages}.\n     * This function can be called by a device owner, profile owner or a delegate given\n     * the {@link #DELEGATION_INSTALL_EXISTING_PACKAGE} scope via {@link #setDelegatedScopes}.\n     * When called in a secondary user or managed profile, the user/profile must be affiliated with\n     * the device. See {@link #isAffiliatedUser}.\n     *\n     * @param admin Which {@link DeviceAdminReceiver} this request is associated with.\n     * @param packageName The package to be installed in the calling profile.\n     * @return {@code true} if the app is installed; {@code false} otherwise.\n     * @throws SecurityException if {@code admin} is not the device owner, or the profile owner of\n     * an affiliated user or profile.\n     * @see #setKeepUninstalledPackages\n     * @see #setDelegatedScopes\n     * @see #isAffiliatedUser\n     * @see #DELEGATION_PACKAGE_ACCESS\n     ",
    "links" : [ "#setKeepUninstalledPackages", "#DELEGATION_INSTALL_EXISTING_PACKAGE", "#setDelegatedScopes", "#isAffiliatedUser", "DeviceAdminReceiver" ]
  }, {
    "name" : "public void setAccountManagementDisabled(@NonNull ComponentName admin, String accountType, boolean disabled)",
    "returnType" : "void",
    "comment" : "\n     * Called by a device owner or profile owner to disable account management for a specific type\n     * of account.\n     * <p>\n     * The calling device admin must be a device owner or profile owner. If it is not, a security\n     * exception will be thrown.\n     * <p>\n     * When account management is disabled for an account type, adding or removing an account of\n     * that type will not be possible.\n     * <p>\n     * From {@link android.os.Build.VERSION_CODES#N} the profile or device owner can still use\n     * {@link android.accounts.AccountManager} APIs to add or remove accounts when account\n     * management for a specific type is disabled.\n     * <p>\n     * This method may be called on the {@code DevicePolicyManager} instance returned from\n     * {@link #getParentProfileInstance(ComponentName)} by the profile owner on an\n     * organization-owned device, to restrict accounts that may not be managed on the primary\n     * profile.\n     *\n     * @param admin Which {@link DeviceAdminReceiver} this request is associated with.\n     * @param accountType For which account management is disabled or enabled.\n     * @param disabled The boolean indicating that account management will be disabled (true) or\n     *            enabled (false).\n     * @throws SecurityException if {@code admin} is not a device or profile owner.\n     ",
    "links" : [ "android.os.Build.VERSION_CODES#N", "android.accounts.AccountManager", "#getParentProfileInstance", "DeviceAdminReceiver" ]
  }, {
    "name" : "public String[] getAccountTypesWithManagementDisabled()",
    "returnType" : "String[]",
    "comment" : "\n     * Gets the array of accounts for which account management is disabled by the profile owner\n     * or device owner.\n     *\n     * <p> Account management can be disabled/enabled by calling\n     * {@link #setAccountManagementDisabled}.\n     * <p>\n     * This method may be called on the {@code DevicePolicyManager} instance returned from\n     * {@link #getParentProfileInstance(ComponentName)}. Note that only a profile owner on\n     * an organization-owned device can affect account types on the parent profile instance.\n     *\n     * @return a list of account types for which account management has been disabled.\n     *\n     * @see #setAccountManagementDisabled\n     ",
    "links" : [ "#setAccountManagementDisabled", "#getParentProfileInstance" ]
  }, {
    "name" : "public String[] getAccountTypesWithManagementDisabledAsUser(int userId)",
    "returnType" : "String[]",
    "comment" : "\n     * @see #getAccountTypesWithManagementDisabled()\n     * Note that calling this method on the parent profile instance will return the same\n     * value as calling it on the main {@code DevicePolicyManager} instance.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public String[] getAccountTypesWithManagementDisabledAsUser(int userId, boolean parentInstance)",
    "returnType" : "String[]",
    "comment" : "\n     * @see #getAccountTypesWithManagementDisabled()\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public void setSecondaryLockscreenEnabled(@NonNull ComponentName admin, boolean enabled)",
    "returnType" : "void",
    "comment" : "\n     * Called by device owner or profile owner to set whether a secondary lockscreen needs to be\n     * shown.\n     *\n     * <p>The secondary lockscreen will by displayed after the primary keyguard security screen\n     * requirements are met. To provide the lockscreen content the DO/PO will need to provide a\n     * service handling the {@link #ACTION_BIND_SECONDARY_LOCKSCREEN_SERVICE} intent action,\n     * extending the {@link DevicePolicyKeyguardService} class.\n     *\n     * <p>Relevant interactions on the secondary lockscreen should be communicated back to the\n     * keyguard via {@link IKeyguardCallback}, such as when the screen is ready to be dismissed.\n     *\n     * <p>This API, and associated APIs, can only be called by the default supervision app when it\n     * is set as the device owner or profile owner.\n     *\n     * @param admin Which {@link DeviceAdminReceiver} this request is associated with.\n     * @param enabled Whether or not the lockscreen needs to be shown.\n     * @throws SecurityException if {@code admin} is not a device or profile owner.\n     * @see #isSecondaryLockscreenEnabled\n     * @hide\n     *",
    "links" : [ "#ACTION_BIND_SECONDARY_LOCKSCREEN_SERVICE", "DevicePolicyKeyguardService", "IKeyguardCallback", "DeviceAdminReceiver" ]
  }, {
    "name" : "public boolean isSecondaryLockscreenEnabled(@NonNull UserHandle userHandle)",
    "returnType" : "boolean",
    "comment" : "\n     * Returns whether the secondary lock screen needs to be shown.\n     * @see #setSecondaryLockscreenEnabled\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public void setLockTaskPackages(@NonNull ComponentName admin, @NonNull String[] packages) throws SecurityException",
    "returnType" : "void",
    "comment" : "\n     * Sets which packages may enter lock task mode.\n     * <p>\n     * Any packages that share uid with an allowed package will also be allowed to activate lock\n     * task. From {@link android.os.Build.VERSION_CODES#M} removing packages from the lock task\n     * package list results in locked tasks belonging to those packages to be finished.\n     * <p>\n     * This function can only be called by the device owner, a profile owner of an affiliated user\n     * or profile, or the profile owner when no device owner is set. See {@link #isAffiliatedUser}.\n     * Any package set via this method will be cleared if the user becomes unaffiliated.\n     *\n     * @param packages The list of packages allowed to enter lock task mode\n     * @param admin Which {@link DeviceAdminReceiver} this request is associated with.\n     * @throws SecurityException if {@code admin} is not the device owner, the profile owner of an\n     * affiliated user or profile, or the profile owner when no device owner is set.\n     * @see #isAffiliatedUser\n     * @see Activity#startLockTask()\n     * @see DeviceAdminReceiver#onLockTaskModeEntering(Context, Intent, String)\n     * @see DeviceAdminReceiver#onLockTaskModeExiting(Context, Intent)\n     * @see UserManager#DISALLOW_CREATE_WINDOWS\n     ",
    "links" : [ "android.os.Build.VERSION_CODES#M", "#isAffiliatedUser", "DeviceAdminReceiver" ]
  }, {
    "name" : "public String[] getLockTaskPackages(@NonNull ComponentName admin)",
    "returnType" : "String[]",
    "comment" : "\n     * Returns the list of packages allowed to start the lock task mode.\n     *\n     * @throws SecurityException if {@code admin} is not the device owner, the profile owner of an\n     * affiliated user or profile, or the profile owner when no device owner is set.\n     * @see #isAffiliatedUser\n     * @see #setLockTaskPackages\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean isLockTaskPermitted(String pkg)",
    "returnType" : "boolean",
    "comment" : "\n     * This function lets the caller know whether the given component is allowed to start the\n     * lock task mode.\n     * @param pkg The package to check\n     ",
    "links" : [ ]
  }, {
    "name" : "public void setLockTaskFeatures(@NonNull ComponentName admin, @LockTaskFeature int flags)",
    "returnType" : "void",
    "comment" : "\n     * Sets which system features are enabled when the device runs in lock task mode. This method\n     * doesn't affect the features when lock task mode is inactive. Any system features not included\n     * in {@code flags} are implicitly disabled when calling this method. By default, only\n     * {@link #LOCK_TASK_FEATURE_GLOBAL_ACTIONS} is enabled; all the other features are disabled. To\n     * disable the global actions dialog, call this method omitting\n     * {@link #LOCK_TASK_FEATURE_GLOBAL_ACTIONS}.\n     *\n     * <p>This method can only be called by the device owner, a profile owner of an affiliated\n     * user or profile, or the profile owner when no device owner is set. See\n     * {@link #isAffiliatedUser}.\n     * Any features set using this method are cleared if the user becomes unaffiliated.\n     *\n     * @param admin Which {@link DeviceAdminReceiver} this request is associated with.\n     * @param flags The system features enabled during lock task mode.\n     * @throws SecurityException if {@code admin} is not the device owner, the profile owner of an\n     * affiliated user or profile, or the profile owner when no device owner is set.\n     * @see #isAffiliatedUser\n     *",
    "links" : [ "#LOCK_TASK_FEATURE_GLOBAL_ACTIONS", "#LOCK_TASK_FEATURE_GLOBAL_ACTIONS", "#isAffiliatedUser", "DeviceAdminReceiver" ]
  }, {
    "name" : "public int getLockTaskFeatures(@NonNull ComponentName admin)",
    "returnType" : "int",
    "comment" : "\n     * Gets which system features are enabled for LockTask mode.\n     *\n     * @param admin Which {@link DeviceAdminReceiver} this request is associated with.\n     * @return bitfield of flags. See {@link #setLockTaskFeatures(ComponentName, int)} for a list.\n     * @throws SecurityException if {@code admin} is not the device owner, the profile owner of an\n     * affiliated user or profile, or the profile owner when no device owner is set.\n     * @see #isAffiliatedUser\n     * @see #setLockTaskFeatures\n     ",
    "links" : [ "DeviceAdminReceiver", "#setLockTaskFeatures" ]
  }, {
    "name" : "public void setGlobalSetting(@NonNull ComponentName admin, String setting, String value)",
    "returnType" : "void",
    "comment" : "\n     * This method is mostly deprecated.\n     * Most of the settings that still have an effect have dedicated setter methods or user\n     * restrictions. See individual settings for details.\n     * <p>\n     * Called by device owner to update {@link android.provider.Settings.Global} settings.\n     * Validation that the value of the setting is in the correct form for the setting type should\n     * be performed by the caller.\n     * <p>\n     * The settings that can be updated with this method are:\n     * <ul>\n     * <li>{@link android.provider.Settings.Global#ADB_ENABLED} : use\n     * {@link UserManager#DISALLOW_DEBUGGING_FEATURES} instead to restrict users from enabling\n     * debugging features and this setting to turn adb on.</li>\n     * <li>{@link android.provider.Settings.Global#USB_MASS_STORAGE_ENABLED}</li>\n     * <li>{@link android.provider.Settings.Global#STAY_ON_WHILE_PLUGGED_IN} This setting is only\n     * available from {@link android.os.Build.VERSION_CODES#M} onwards and can only be set if\n     * {@link #setMaximumTimeToLock} is not used to set a timeout.</li>\n     * <li>{@link android.provider.Settings.Global#WIFI_DEVICE_OWNER_CONFIGS_LOCKDOWN}</li> This\n     * setting is only available from {@link android.os.Build.VERSION_CODES#M} onwards.</li>\n     * </ul>\n     * <p>\n     * The following settings used to be supported, but can be controlled in other ways:\n     * <ul>\n     * <li>{@link android.provider.Settings.Global#AUTO_TIME} : Use {@link #setAutoTimeEnabled} and\n     * {@link UserManager#DISALLOW_CONFIG_DATE_TIME} instead.</li>\n     * <li>{@link android.provider.Settings.Global#AUTO_TIME_ZONE} : Use\n     * {@link #setAutoTimeZoneEnabled} and {@link UserManager#DISALLOW_CONFIG_DATE_TIME}\n     * instead.</li>\n     * <li>{@link android.provider.Settings.Global#DATA_ROAMING} : Use\n     * {@link UserManager#DISALLOW_DATA_ROAMING} instead.</li>\n     * </ul>\n     * <p>\n     * Changing the following settings has no effect as of {@link android.os.Build.VERSION_CODES#M}:\n     * <ul>\n     * <li>{@link android.provider.Settings.Global#BLUETOOTH_ON}. Use\n     * {@link android.bluetooth.BluetoothAdapter#enable()} and\n     * {@link android.bluetooth.BluetoothAdapter#disable()} instead.</li>\n     * <li>{@link android.provider.Settings.Global#DEVELOPMENT_SETTINGS_ENABLED}</li>\n     * <li>{@link android.provider.Settings.Global#MODE_RINGER}. Use\n     * {@link android.media.AudioManager#setRingerMode(int)} instead.</li>\n     * <li>{@link android.provider.Settings.Global#NETWORK_PREFERENCE}</li>\n     * <li>{@link android.provider.Settings.Global#WIFI_ON}. Use\n     * {@link android.net.wifi.WifiManager#setWifiEnabled(boolean)} instead.</li>\n     * <li>{@link android.provider.Settings.Global#WIFI_SLEEP_POLICY}. No longer has effect.</li>\n     * </ul>\n     *\n     * @param admin Which {@link DeviceAdminReceiver} this request is associated with.\n     * @param setting The name of the setting to update.\n     * @param value The value to update the setting to.\n     * @throws SecurityException if {@code admin} is not a device owner.\n     ",
    "links" : [ "android.provider.Settings.Global", "android.provider.Settings.Global#ADB_ENABLED", "UserManager#DISALLOW_DEBUGGING_FEATURES", "android.provider.Settings.Global#USB_MASS_STORAGE_ENABLED", "android.provider.Settings.Global#STAY_ON_WHILE_PLUGGED_IN", "android.os.Build.VERSION_CODES#M", "#setMaximumTimeToLock", "android.provider.Settings.Global#WIFI_DEVICE_OWNER_CONFIGS_LOCKDOWN", "android.os.Build.VERSION_CODES#M", "android.provider.Settings.Global#AUTO_TIME", "#setAutoTimeEnabled", "UserManager#DISALLOW_CONFIG_DATE_TIME", "android.provider.Settings.Global#AUTO_TIME_ZONE", "#setAutoTimeZoneEnabled", "UserManager#DISALLOW_CONFIG_DATE_TIME", "android.provider.Settings.Global#DATA_ROAMING", "UserManager#DISALLOW_DATA_ROAMING", "android.os.Build.VERSION_CODES#M", "android.provider.Settings.Global#BLUETOOTH_ON", "android.bluetooth.BluetoothAdapter#enable", "android.bluetooth.BluetoothAdapter#disable", "android.provider.Settings.Global#DEVELOPMENT_SETTINGS_ENABLED", "android.provider.Settings.Global#MODE_RINGER", "android.media.AudioManager#setRingerMode", "android.provider.Settings.Global#NETWORK_PREFERENCE", "android.provider.Settings.Global#WIFI_ON", "android.net.wifi.WifiManager#setWifiEnabled", "android.provider.Settings.Global#WIFI_SLEEP_POLICY", "DeviceAdminReceiver" ]
  }, {
    "name" : "public void setSystemSetting(@NonNull ComponentName admin, @NonNull @SystemSettingsWhitelist String setting, String value)",
    "returnType" : "void",
    "comment" : "\n     * Called by a device or profile owner to update {@link android.provider.Settings.System}\n     * settings. Validation that the value of the setting is in the correct form for the setting\n     * type should be performed by the caller.\n     * <p>\n     * The settings that can be updated by a device owner or profile owner of secondary user with\n     * this method are:\n     * <ul>\n     * <li>{@link android.provider.Settings.System#SCREEN_BRIGHTNESS}</li>\n     * <li>{@link android.provider.Settings.System#SCREEN_BRIGHTNESS_MODE}</li>\n     * <li>{@link android.provider.Settings.System#SCREEN_OFF_TIMEOUT}</li>\n     * </ul>\n     * <p>\n     *\n     * @see android.provider.Settings.System#SCREEN_OFF_TIMEOUT\n     * @param admin Which {@link DeviceAdminReceiver} this request is associated with.\n     * @param setting The name of the setting to update.\n     * @param value The value to update the setting to.\n     * @throws SecurityException if {@code admin} is not a device or profile owner.\n     ",
    "links" : [ "android.provider.Settings.System", "android.provider.Settings.System#SCREEN_BRIGHTNESS", "android.provider.Settings.System#SCREEN_BRIGHTNESS_MODE", "android.provider.Settings.System#SCREEN_OFF_TIMEOUT", "DeviceAdminReceiver" ]
  }, {
    "name" : "public void setConfiguredNetworksLockdownState(@NonNull ComponentName admin, boolean lockdown)",
    "returnType" : "void",
    "comment" : "\n     * Called by a device owner or a profile owner of an organization-owned managed profile to\n     * control whether the user can change networks configured by the admin.\n     * <p>\n     * WiFi network configuration lockdown is controlled by a global settings\n     * {@link android.provider.Settings.Global#WIFI_DEVICE_OWNER_CONFIGS_LOCKDOWN} and calling\n     * this API effectively modifies the global settings. Previously device owners can also\n     * control this directly via {@link #setGlobalSetting} but they are recommended to switch\n     * to this API.\n     *\n     * @param admin             admin Which {@link DeviceAdminReceiver} this request is associated\n     *                          with.\n     * @param lockdown Whether the admin configured networks should be unmodifiable by the\n     *                          user.\n     * @throws SecurityException if caller is not a device owner or a profile owner of an\n     *                           organization-owned managed profile.\n     ",
    "links" : [ "android.provider.Settings.Global#WIFI_DEVICE_OWNER_CONFIGS_LOCKDOWN", "#setGlobalSetting", "DeviceAdminReceiver" ]
  }, {
    "name" : "public boolean hasLockdownAdminConfiguredNetworks(@NonNull ComponentName admin)",
    "returnType" : "boolean",
    "comment" : "\n     * Called by a device owner or a profile owner of an organization-owned managed profile to\n     * determine whether the user is prevented from modifying networks configured by the admin.\n     *\n     * @param admin             admin Which {@link DeviceAdminReceiver} this request is associated\n     *                          with.\n     * @throws SecurityException if caller is not a device owner or a profile owner of an\n     *                           organization-owned managed profile.\n     ",
    "links" : [ "DeviceAdminReceiver" ]
  }, {
    "name" : "public boolean setTime(@NonNull ComponentName admin, long millis)",
    "returnType" : "boolean",
    "comment" : "\n     * Called by a device owner or a profile owner of an organization-owned managed\n     * profile to set the system wall clock time. This only takes effect if called when\n     * {@link android.provider.Settings.Global#AUTO_TIME} is 0, otherwise {@code false}\n     * will be returned.\n     *\n     * @param admin Which {@link DeviceAdminReceiver} this request is associated with\n     * @param millis time in milliseconds since the Epoch\n     * @return {@code true} if set time succeeded, {@code false} otherwise.\n     * @throws SecurityException if {@code admin} is not a device owner or a profile owner\n     * of an organization-owned managed profile.\n     ",
    "links" : [ "android.provider.Settings.Global#AUTO_TIME", "DeviceAdminReceiver" ]
  }, {
    "name" : "public boolean setTimeZone(@NonNull ComponentName admin, String timeZone)",
    "returnType" : "boolean",
    "comment" : "\n     * Called by a device owner or a profile owner of an organization-owned managed\n     * profile to set the system's persistent default time zone. This only takes\n     * effect if called when {@link android.provider.Settings.Global#AUTO_TIME_ZONE}\n     * is 0, otherwise {@code false} will be returned.\n     *\n     * @see android.app.AlarmManager#setTimeZone(String)\n     * @param admin Which {@link DeviceAdminReceiver} this request is associated with\n     * @param timeZone one of the Olson ids from the list returned by\n     *     {@link java.util.TimeZone#getAvailableIDs}\n     * @return {@code true} if set timezone succeeded, {@code false} otherwise.\n     * @throws SecurityException if {@code admin} is not a device owner or a profile owner\n     * of an organization-owned managed profile.\n     ",
    "links" : [ "android.provider.Settings.Global#AUTO_TIME_ZONE", "DeviceAdminReceiver", "java.util.TimeZone#getAvailableIDs" ]
  }, {
    "name" : "public void setLocationEnabled(@NonNull ComponentName admin, boolean locationEnabled)",
    "returnType" : "void",
    "comment" : "\n     * Called by device owners to set the user's master location setting.\n     *\n     * @param admin Which {@link DeviceAdminReceiver} this request is associated with\n     * @param locationEnabled whether location should be enabled or disabled\n     * @throws SecurityException if {@code admin} is not a device owner.\n     ",
    "links" : [ "DeviceAdminReceiver" ]
  }, {
    "name" : "public void setSecureSetting(@NonNull ComponentName admin, String setting, String value)",
    "returnType" : "void",
    "comment" : "\n     * This method is mostly deprecated.\n     * Most of the settings that still have an effect have dedicated setter methods\n     * (e.g. {@link #setLocationEnabled}) or user restrictions.\n     * <p>\n     *\n     * Called by profile or device owners to update {@link android.provider.Settings.Secure}\n     * settings. Validation that the value of the setting is in the correct form for the setting\n     * type should be performed by the caller.\n     * <p>\n     * The settings that can be updated by a profile or device owner with this method are:\n     * <ul>\n     * <li>{@link android.provider.Settings.Secure#DEFAULT_INPUT_METHOD}</li>\n     * <li>{@link android.provider.Settings.Secure#SKIP_FIRST_USE_HINTS}</li>\n     * </ul>\n     * <p>\n     * A device owner can additionally update the following settings:\n     * <ul>\n     * <li>{@link android.provider.Settings.Secure#LOCATION_MODE}, but see note below.</li>\n     * </ul>\n     *\n     * <strong>Note: Starting from Android O, apps should no longer call this method with the\n     * setting {@link android.provider.Settings.Secure#INSTALL_NON_MARKET_APPS}, which is\n     * deprecated. Instead, device owners or profile owners should use the restriction\n     * {@link UserManager#DISALLOW_INSTALL_UNKNOWN_SOURCES}.\n     * If any app targeting {@link android.os.Build.VERSION_CODES#O} or higher calls this method\n     * with {@link android.provider.Settings.Secure#INSTALL_NON_MARKET_APPS},\n     * an {@link UnsupportedOperationException} is thrown.\n     *\n     * Starting from Android Q, the device and profile owner can also call\n     * {@link UserManager#DISALLOW_INSTALL_UNKNOWN_SOURCES_GLOBALLY} to restrict unknown sources for\n     * all users.\n     * </strong>\n     *\n     * <strong>Note: Starting from Android R, apps should no longer call this method with the\n     * setting {@link android.provider.Settings.Secure#LOCATION_MODE}, which is deprecated. Instead,\n     * device owners should call {@link #setLocationEnabled(ComponentName, boolean)}. This will be\n     * enforced for all apps targeting Android R or above.\n     * </strong>\n     *\n     * @param admin Which {@link DeviceAdminReceiver} this request is associated with.\n     * @param setting The name of the setting to update.\n     * @param value The value to update the setting to.\n     * @throws SecurityException if {@code admin} is not a device or profile owner.\n     ",
    "links" : [ "#setLocationEnabled", "android.provider.Settings.Secure", "android.provider.Settings.Secure#DEFAULT_INPUT_METHOD", "android.provider.Settings.Secure#SKIP_FIRST_USE_HINTS", "android.provider.Settings.Secure#LOCATION_MODE", "android.provider.Settings.Secure#INSTALL_NON_MARKET_APPS", "UserManager#DISALLOW_INSTALL_UNKNOWN_SOURCES", "android.os.Build.VERSION_CODES#O", "android.provider.Settings.Secure#INSTALL_NON_MARKET_APPS", "UnsupportedOperationException", "UserManager#DISALLOW_INSTALL_UNKNOWN_SOURCES_GLOBALLY", "android.provider.Settings.Secure#LOCATION_MODE", "#setLocationEnabled", "DeviceAdminReceiver" ]
  }, {
    "name" : "public void setRestrictionsProvider(@NonNull ComponentName admin, @Nullable ComponentName provider)",
    "returnType" : "void",
    "comment" : "\n     * Designates a specific service component as the provider for making permission requests of a\n     * local or remote administrator of the user.\n     * <p/>\n     * Only a profile owner can designate the restrictions provider.\n     *\n     * @param admin Which {@link DeviceAdminReceiver} this request is associated with.\n     * @param provider The component name of the service that implements\n     *            {@link RestrictionsReceiver}. If this param is null, it removes the restrictions\n     *            provider previously assigned.\n     * @throws SecurityException if {@code admin} is not a device or profile owner.\n     ",
    "links" : [ "DeviceAdminReceiver", "RestrictionsReceiver" ]
  }, {
    "name" : "public void setMasterVolumeMuted(@NonNull ComponentName admin, boolean on)",
    "returnType" : "void",
    "comment" : "\n     * Called by profile or device owners to set the master volume mute on or off.\n     * This has no effect when set on a managed profile.\n     *\n     * @param admin Which {@link DeviceAdminReceiver} this request is associated with.\n     * @param on {@code true} to mute master volume, {@code false} to turn mute off.\n     * @throws SecurityException if {@code admin} is not a device or profile owner.\n     ",
    "links" : [ "DeviceAdminReceiver" ]
  }, {
    "name" : "public boolean isMasterVolumeMuted(@NonNull ComponentName admin)",
    "returnType" : "boolean",
    "comment" : "\n     * Called by profile or device owners to check whether the master volume mute is on or off.\n     *\n     * @param admin Which {@link DeviceAdminReceiver} this request is associated with.\n     * @return {@code true} if master volume is muted, {@code false} if it's not.\n     * @throws SecurityException if {@code admin} is not a device or profile owner.\n     ",
    "links" : [ "DeviceAdminReceiver" ]
  }, {
    "name" : "public void setUninstallBlocked(@Nullable ComponentName admin, String packageName, boolean uninstallBlocked)",
    "returnType" : "void",
    "comment" : "\n     * Change whether a user can uninstall a package. This function can be called by a device owner,\n     * profile owner, or by a delegate given the {@link #DELEGATION_BLOCK_UNINSTALL} scope via\n     * {@link #setDelegatedScopes}.\n     *\n     * @param admin Which {@link DeviceAdminReceiver} this request is associated with, or\n     *             {@code null} if the caller is a block uninstall delegate.\n     * @param packageName package to change.\n     * @param uninstallBlocked true if the user shouldn't be able to uninstall the package.\n     * @throws SecurityException if {@code admin} is not a device or profile owner.\n     * @see #setDelegatedScopes\n     * @see #DELEGATION_BLOCK_UNINSTALL\n     ",
    "links" : [ "#DELEGATION_BLOCK_UNINSTALL", "#setDelegatedScopes", "DeviceAdminReceiver" ]
  }, {
    "name" : "public boolean isUninstallBlocked(@Nullable ComponentName admin, String packageName)",
    "returnType" : "boolean",
    "comment" : "\n     * Check whether the user has been blocked by device policy from uninstalling a package.\n     * Requires the caller to be the profile owner if checking a specific admin's policy.\n     * <p>\n     * <strong>Note:</strong> Starting from {@link android.os.Build.VERSION_CODES#LOLLIPOP_MR1}, the\n     * behavior of this API is changed such that passing {@code null} as the {@code admin} parameter\n     * will return if any admin has blocked the uninstallation. Before L MR1, passing {@code null}\n     * will cause a NullPointerException to be raised.\n     *\n     * @param admin The name of the admin component whose blocking policy will be checked, or\n     *            {@code null} to check whether any admin has blocked the uninstallation.\n     * @param packageName package to check.\n     * @return true if uninstallation is blocked.\n     * @throws SecurityException if {@code admin} is not a device or profile owner.\n     ",
    "links" : [ "android.os.Build.VERSION_CODES#LOLLIPOP_MR1" ]
  }, {
    "name" : "public boolean addCrossProfileWidgetProvider(@NonNull ComponentName admin, String packageName)",
    "returnType" : "boolean",
    "comment" : "\n     * Called by the profile owner of a managed profile to enable widget providers from a given\n     * package to be available in the parent profile. As a result the user will be able to add\n     * widgets from the white-listed package running under the profile to a widget host which runs\n     * under the parent profile, for example the home screen. Note that a package may have zero or\n     * more provider components, where each component provides a different widget type.\n     * <p>\n     * <strong>Note:</strong> By default no widget provider package is white-listed.\n     *\n     * @param admin Which {@link DeviceAdminReceiver} this request is associated with.\n     * @param packageName The package from which widget providers are white-listed.\n     * @return Whether the package was added.\n     * @throws SecurityException if {@code admin} is not a profile owner.\n     * @see #removeCrossProfileWidgetProvider(android.content.ComponentName, String)\n     * @see #getCrossProfileWidgetProviders(android.content.ComponentName)\n     ",
    "links" : [ "DeviceAdminReceiver" ]
  }, {
    "name" : "public boolean removeCrossProfileWidgetProvider(@NonNull ComponentName admin, String packageName)",
    "returnType" : "boolean",
    "comment" : "\n     * Called by the profile owner of a managed profile to disable widget providers from a given\n     * package to be available in the parent profile. For this method to take effect the package\n     * should have been added via\n     * {@link #addCrossProfileWidgetProvider( android.content.ComponentName, String)}.\n     * <p>\n     * <strong>Note:</strong> By default no widget provider package is white-listed.\n     *\n     * @param admin Which {@link DeviceAdminReceiver} this request is associated with.\n     * @param packageName The package from which widget providers are no longer white-listed.\n     * @return Whether the package was removed.\n     * @throws SecurityException if {@code admin} is not a profile owner.\n     * @see #addCrossProfileWidgetProvider(android.content.ComponentName, String)\n     * @see #getCrossProfileWidgetProviders(android.content.ComponentName)\n     ",
    "links" : [ "#addCrossProfileWidgetProvider", "DeviceAdminReceiver" ]
  }, {
    "name" : "public List<String> getCrossProfileWidgetProviders(@NonNull ComponentName admin)",
    "returnType" : "List<String>",
    "comment" : "\n     * Called by the profile owner of a managed profile to query providers from which packages are\n     * available in the parent profile.\n     *\n     * @param admin Which {@link DeviceAdminReceiver} this request is associated with.\n     * @return The white-listed package list.\n     * @see #addCrossProfileWidgetProvider(android.content.ComponentName, String)\n     * @see #removeCrossProfileWidgetProvider(android.content.ComponentName, String)\n     * @throws SecurityException if {@code admin} is not a profile owner.\n     ",
    "links" : [ "DeviceAdminReceiver" ]
  }, {
    "name" : "public void setUserIcon(@NonNull ComponentName admin, Bitmap icon)",
    "returnType" : "void",
    "comment" : "\n     * Called by profile or device owners to set the user's photo.\n     *\n     * @param admin Which {@link DeviceAdminReceiver} this request is associated with.\n     * @param icon the bitmap to set as the photo.\n     * @throws SecurityException if {@code admin} is not a device or profile owner.\n     ",
    "links" : [ "DeviceAdminReceiver" ]
  }, {
    "name" : "public void setSystemUpdatePolicy(@NonNull ComponentName admin, SystemUpdatePolicy policy)",
    "returnType" : "void",
    "comment" : "\n     * Called by device owners or profile owners of an organization-owned managed profile to to set\n     * a local system update policy. When a new policy is set,\n     * {@link #ACTION_SYSTEM_UPDATE_POLICY_CHANGED} is broadcasted.\n     * <p>\n     * If the supplied system update policy has freeze periods set but the freeze periods do not\n     * meet 90-day maximum length or 60-day minimum separation requirement set out in\n     * {@link SystemUpdatePolicy#setFreezePeriods},\n     * {@link SystemUpdatePolicy.ValidationFailedException} will the thrown. Note that the system\n     * keeps a record of freeze periods the device experienced previously, and combines them with\n     * the new freeze periods to be set when checking the maximum freeze length and minimum freeze\n     * separation constraints. As a result, freeze periods that passed validation during\n     * {@link SystemUpdatePolicy#setFreezePeriods} might fail the additional checks here due to\n     * the freeze period history. If this is causing issues during development,\n     * {@code adb shell dpm clear-freeze-period-record} can be used to clear the record.\n     *\n     * @param admin Which {@link DeviceAdminReceiver} this request is associated with. All\n     *            components in the device owner package can set system update policies and the most\n     *            recent policy takes effect.\n     * @param policy the new policy, or {@code null} to clear the current policy.\n     * @throws SecurityException if {@code admin} is not a device owner or a profile owner of an\n     *      organization-owned managed profile.\n     * @throws IllegalArgumentException if the policy type or maintenance window is not valid.\n     * @throws SystemUpdatePolicy.ValidationFailedException if the policy's freeze period does not\n     *             meet the requirement.\n     * @see SystemUpdatePolicy\n     * @see SystemUpdatePolicy#setFreezePeriods(List)\n     ",
    "links" : [ "#ACTION_SYSTEM_UPDATE_POLICY_CHANGED", "SystemUpdatePolicy#setFreezePeriods", "SystemUpdatePolicy.ValidationFailedException", "SystemUpdatePolicy#setFreezePeriods", "DeviceAdminReceiver" ]
  }, {
    "name" : "public SystemUpdatePolicy getSystemUpdatePolicy()",
    "returnType" : "SystemUpdatePolicy",
    "comment" : "\n     * Retrieve a local system update policy set previously by {@link #setSystemUpdatePolicy}.\n     *\n     * @return The current policy object, or {@code null} if no policy is set.\n     ",
    "links" : [ "#setSystemUpdatePolicy" ]
  }, {
    "name" : "public void clearSystemUpdatePolicyFreezePeriodRecord()",
    "returnType" : "void",
    "comment" : "\n     * Reset record of previous system update freeze period the device went through.\n     * Only callable by ADB.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean setKeyguardDisabled(@NonNull ComponentName admin, boolean disabled)",
    "returnType" : "boolean",
    "comment" : "\n     * Called by a device owner or profile owner of secondary users that is affiliated with the\n     * device to disable the keyguard altogether.\n     * <p>\n     * Setting the keyguard to disabled has the same effect as choosing \"None\" as the screen lock\n     * type. However, this call has no effect if a password, pin or pattern is currently set. If a\n     * password, pin or pattern is set after the keyguard was disabled, the keyguard stops being\n     * disabled.\n     *\n     * <p>\n     * As of {@link android.os.Build.VERSION_CODES#P}, this call also dismisses the\n     * keyguard if it is currently shown.\n     *\n     * @param admin Which {@link DeviceAdminReceiver} this request is associated with.\n     * @param disabled {@code true} disables the keyguard, {@code false} reenables it.\n     * @return {@code false} if attempting to disable the keyguard while a lock password was in\n     *         place. {@code true} otherwise.\n     * @throws SecurityException if {@code admin} is not the device owner, or a profile owner of\n     * secondary user that is affiliated with the device.\n     * @see #isAffiliatedUser\n     * @see #getSecondaryUsers\n     ",
    "links" : [ "android.os.Build.VERSION_CODES#P", "DeviceAdminReceiver" ]
  }, {
    "name" : "public boolean setStatusBarDisabled(@NonNull ComponentName admin, boolean disabled)",
    "returnType" : "boolean",
    "comment" : "\n     * Called by device owner or profile owner of secondary users that is affiliated with the\n     * device to disable the status bar. Disabling the status bar blocks notifications and quick\n     * settings.\n     * <p>\n     * <strong>Note:</strong> This method has no effect for LockTask mode. The behavior of the\n     * status bar in LockTask mode can be configured with\n     * {@link #setLockTaskFeatures(ComponentName, int)}. Calls to this method when the device is in\n     * LockTask mode will be registered, but will only take effect when the device leaves LockTask\n     * mode.\n     *\n     * <p>This policy does not have any effect while on the lock screen, where the status bar will\n     * not be disabled. Using LockTask instead of this method is recommended.\n     *\n     * @param admin Which {@link DeviceAdminReceiver} this request is associated with.\n     * @param disabled {@code true} disables the status bar, {@code false} reenables it.\n     * @return {@code false} if attempting to disable the status bar failed. {@code true} otherwise.\n     * @throws SecurityException if {@code admin} is not the device owner, or a profile owner of\n     * secondary user that is affiliated with the device.\n     * @see #isAffiliatedUser\n     * @see #getSecondaryUsers\n     ",
    "links" : [ "#setLockTaskFeatures", "DeviceAdminReceiver" ]
  }, {
    "name" : "public void notifyPendingSystemUpdate(long updateReceivedTime)",
    "returnType" : "void",
    "comment" : "\n     * Called by the system update service to notify device and profile owners of pending system\n     * updates.\n     *\n     * This method should only be used when it is unknown whether the pending system\n     * update is a security patch. Otherwise, use\n     * {@link #notifyPendingSystemUpdate(long, boolean)}.\n     *\n     * @param updateReceivedTime The time as given by {@link System#currentTimeMillis()}\n     *         indicating when the current pending update was first available. {@code -1} if no\n     *         update is available.\n     * @see #notifyPendingSystemUpdate(long, boolean)\n     * @hide\n     ",
    "links" : [ "#notifyPendingSystemUpdate", "System#currentTimeMillis" ]
  }, {
    "name" : "public void notifyPendingSystemUpdate(long updateReceivedTime, boolean isSecurityPatch)",
    "returnType" : "void",
    "comment" : "\n     * Called by the system update service to notify device and profile owners of pending system\n     * updates.\n     *\n     * This method should be used instead of {@link #notifyPendingSystemUpdate(long)}\n     * when it is known whether the pending system update is a security patch.\n     *\n     * @param updateReceivedTime The time as given by {@link System#currentTimeMillis()}\n     *         indicating when the current pending update was first available. {@code -1} if no\n     *         update is available.\n     * @param isSecurityPatch {@code true} if this system update is purely a security patch;\n     *         {@code false} if not.\n     * @see #notifyPendingSystemUpdate(long)\n     * @hide\n     ",
    "links" : [ "#notifyPendingSystemUpdate", "System#currentTimeMillis" ]
  }, {
    "name" : "public SystemUpdateInfo getPendingSystemUpdate(@NonNull ComponentName admin)",
    "returnType" : "SystemUpdateInfo",
    "comment" : "\n     * Called by device or profile owners to get information about a pending system update.\n     *\n     * @param admin Which profile or device owner this request is associated with.\n     * @return Information about a pending system update or {@code null} if no update pending.\n     * @throws SecurityException if {@code admin} is not a device or profile owner.\n     * @see DeviceAdminReceiver#onSystemUpdatePending(Context, Intent, long)\n     ",
    "links" : [ ]
  }, {
    "name" : "public void setPermissionPolicy(@NonNull ComponentName admin, int policy)",
    "returnType" : "void",
    "comment" : "\n     * Set the default response for future runtime permission requests by applications. This\n     * function can be called by a device owner, profile owner, or by a delegate given the\n     * {@link #DELEGATION_PERMISSION_GRANT} scope via {@link #setDelegatedScopes}.\n     * The policy can allow for normal operation which prompts the user to grant a permission, or\n     * can allow automatic granting or denying of runtime permission requests by an application.\n     * This also applies to new permissions declared by app updates. When a permission is denied or\n     * granted this way, the effect is equivalent to setting the permission * grant state via\n     * {@link #setPermissionGrantState}.\n     * <p/>\n     * As this policy only acts on runtime permission requests, it only applies to applications\n     * built with a {@code targetSdkVersion} of {@link android.os.Build.VERSION_CODES#M} or later.\n     *\n     * @param admin Which profile or device owner this request is associated with.\n     * @param policy One of the policy constants {@link #PERMISSION_POLICY_PROMPT},\n     *            {@link #PERMISSION_POLICY_AUTO_GRANT} and {@link #PERMISSION_POLICY_AUTO_DENY}.\n     * @throws SecurityException if {@code admin} is not a device or profile owner.\n     * @see #setPermissionGrantState\n     * @see #setDelegatedScopes\n     * @see #DELEGATION_PERMISSION_GRANT\n     ",
    "links" : [ "#DELEGATION_PERMISSION_GRANT", "#setDelegatedScopes", "#setPermissionGrantState", "android.os.Build.VERSION_CODES#M", "#PERMISSION_POLICY_PROMPT", "#PERMISSION_POLICY_AUTO_GRANT", "#PERMISSION_POLICY_AUTO_DENY" ]
  }, {
    "name" : "public int getPermissionPolicy(ComponentName admin)",
    "returnType" : "int",
    "comment" : "\n     * Returns the current runtime permission policy set by the device or profile owner. The\n     * default is {@link #PERMISSION_POLICY_PROMPT}.\n     *\n     * @param admin Which profile or device owner this request is associated with.\n     * @return the current policy for future permission requests.\n     ",
    "links" : [ "#PERMISSION_POLICY_PROMPT" ]
  }, {
    "name" : "public boolean setPermissionGrantState(@NonNull ComponentName admin, @NonNull String packageName, @NonNull String permission, @PermissionGrantState int grantState)",
    "returnType" : "boolean",
    "comment" : "\n     * Sets the grant state of a runtime permission for a specific application. The state can be\n     * {@link #PERMISSION_GRANT_STATE_DEFAULT default} in which a user can manage it through the UI,\n     * {@link #PERMISSION_GRANT_STATE_DENIED denied}, in which the permission is denied and the user\n     * cannot manage it through the UI, and {@link #PERMISSION_GRANT_STATE_GRANTED granted} in which\n     * the permission is granted and the user cannot manage it through the UI. This method can only\n     * be called by a profile owner, device owner, or a delegate given the\n     * {@link #DELEGATION_PERMISSION_GRANT} scope via {@link #setDelegatedScopes}.\n     * <p/>\n     * Note that user cannot manage other permissions in the affected group through the UI\n     * either and their granted state will be kept as the current value. Thus, it's recommended that\n     * you set the grant state of all the permissions in the affected group.\n     * <p/>\n     * Setting the grant state to {@link #PERMISSION_GRANT_STATE_DEFAULT default} does not revoke\n     * the permission. It retains the previous grant, if any.\n     * <p/>\n     * Device admins with a {@code targetSdkVersion} &lt; {@link android.os.Build.VERSION_CODES#Q}\n     * cannot grant and revoke permissions for applications built with a {@code targetSdkVersion}\n     * &lt; {@link android.os.Build.VERSION_CODES#M}.\n     * <p/>\n     * Admins with a {@code targetSdkVersion} &ge; {@link android.os.Build.VERSION_CODES#Q} can\n     * grant and revoke permissions of all apps. Similar to the user revoking a permission from a\n     * application built with a {@code targetSdkVersion} &lt;\n     * {@link android.os.Build.VERSION_CODES#M} the app-op matching the permission is set to\n     * {@link android.app.AppOpsManager#MODE_IGNORED}, but the permission stays granted.\n     *\n     * @param admin Which profile or device owner this request is associated with.\n     * @param packageName The application to grant or revoke a permission to.\n     * @param permission The permission to grant or revoke.\n     * @param grantState The permission grant state which is one of\n     *            {@link #PERMISSION_GRANT_STATE_DENIED}, {@link #PERMISSION_GRANT_STATE_DEFAULT},\n     *            {@link #PERMISSION_GRANT_STATE_GRANTED},\n     * @return whether the permission was successfully granted or revoked.\n     * @throws SecurityException if {@code admin} is not a device or profile owner.\n     * @see #PERMISSION_GRANT_STATE_DENIED\n     * @see #PERMISSION_GRANT_STATE_DEFAULT\n     * @see #PERMISSION_GRANT_STATE_GRANTED\n     * @see #setDelegatedScopes\n     * @see #DELEGATION_PERMISSION_GRANT\n     ",
    "links" : [ "#PERMISSION_GRANT_STATE_DEFAULT", "#PERMISSION_GRANT_STATE_DENIED", "#PERMISSION_GRANT_STATE_GRANTED", "#DELEGATION_PERMISSION_GRANT", "#setDelegatedScopes", "#PERMISSION_GRANT_STATE_DEFAULT", "android.os.Build.VERSION_CODES#Q", "android.os.Build.VERSION_CODES#M", "android.os.Build.VERSION_CODES#Q", "android.os.Build.VERSION_CODES#M", "android.app.AppOpsManager#MODE_IGNORED", "#PERMISSION_GRANT_STATE_DENIED", "#PERMISSION_GRANT_STATE_DEFAULT", "#PERMISSION_GRANT_STATE_GRANTED" ]
  }, {
    "name" : "public int getPermissionGrantState(@Nullable ComponentName admin, @NonNull String packageName, @NonNull String permission)",
    "returnType" : "int",
    "comment" : "\n     * Returns the current grant state of a runtime permission for a specific application. This\n     * function can be called by a device owner, profile owner, or by a delegate given the\n     * {@link #DELEGATION_PERMISSION_GRANT} scope via {@link #setDelegatedScopes}.\n     *\n     * @param admin Which profile or device owner this request is associated with, or {@code null}\n     *            if the caller is a permission grant delegate.\n     * @param packageName The application to check the grant state for.\n     * @param permission The permission to check for.\n     * @return the current grant state specified by device policy. If the profile or device owner\n     *         has not set a grant state, the return value is\n     *         {@link #PERMISSION_GRANT_STATE_DEFAULT}. This does not indicate whether or not the\n     *         permission is currently granted for the package.\n     *         <p/>\n     *         If a grant state was set by the profile or device owner, then the return value will\n     *         be one of {@link #PERMISSION_GRANT_STATE_DENIED} or\n     *         {@link #PERMISSION_GRANT_STATE_GRANTED}, which indicates if the permission is\n     *         currently denied or granted.\n     * @throws SecurityException if {@code admin} is not a device or profile owner.\n     * @see #setPermissionGrantState(ComponentName, String, String, int)\n     * @see PackageManager#checkPermission(String, String)\n     * @see #setDelegatedScopes\n     * @see #DELEGATION_PERMISSION_GRANT\n     ",
    "links" : [ "#DELEGATION_PERMISSION_GRANT", "#setDelegatedScopes", "#PERMISSION_GRANT_STATE_DEFAULT", "#PERMISSION_GRANT_STATE_DENIED", "#PERMISSION_GRANT_STATE_GRANTED" ]
  }, {
    "name" : "public boolean isProvisioningAllowed(@NonNull String action)",
    "returnType" : "boolean",
    "comment" : "\n     * Returns whether it is possible for the caller to initiate provisioning of a managed profile\n     * or device, setting itself as the device or profile owner.\n     *\n     * @param action One of {@link #ACTION_PROVISION_MANAGED_DEVICE},\n     * {@link #ACTION_PROVISION_MANAGED_PROFILE}.\n     * @return whether provisioning a managed profile or device is possible.\n     * @throws IllegalArgumentException if the supplied action is not valid.\n     ",
    "links" : [ "#ACTION_PROVISION_MANAGED_DEVICE", "#ACTION_PROVISION_MANAGED_PROFILE" ]
  }, {
    "name" : "public int checkProvisioningPreCondition(String action, @NonNull String packageName)",
    "returnType" : "int",
    "comment" : "\n     * Checks whether it is possible to initiate provisioning a managed device,\n     * profile or user, setting the given package as owner.\n     *\n     * @param action One of {@link #ACTION_PROVISION_MANAGED_DEVICE},\n     *        {@link #ACTION_PROVISION_MANAGED_PROFILE},\n     *        {@link #ACTION_PROVISION_MANAGED_SHAREABLE_DEVICE},\n     *        {@link #ACTION_PROVISION_MANAGED_USER}\n     * @param packageName The package of the component that would be set as device, user, or profile\n     *        owner.\n     * @return A {@link ProvisioningPreCondition} value indicating whether provisioning is allowed.\n     * @hide\n     ",
    "links" : [ "#ACTION_PROVISION_MANAGED_DEVICE", "#ACTION_PROVISION_MANAGED_PROFILE", "#ACTION_PROVISION_MANAGED_SHAREABLE_DEVICE", "#ACTION_PROVISION_MANAGED_USER", "ProvisioningPreCondition" ]
  }, {
    "name" : "public boolean isManagedProfile(@NonNull ComponentName admin)",
    "returnType" : "boolean",
    "comment" : "\n     * Return if this user is a managed profile of another user. An admin can become the profile\n     * owner of a managed profile with {@link #ACTION_PROVISION_MANAGED_PROFILE} and of a managed\n     * user with {@link #createAndManageUser}\n     * @param admin Which profile owner this request is associated with.\n     * @return if this user is a managed profile of another user.\n     ",
    "links" : [ "#ACTION_PROVISION_MANAGED_PROFILE", "#createAndManageUser" ]
  }, {
    "name" : "public boolean isSystemOnlyUser(@NonNull ComponentName admin)",
    "returnType" : "boolean",
    "comment" : "\n     * @hide\n     * Return if this user is a system-only user. An admin can manage a device from a system only\n     * user by calling {@link #ACTION_PROVISION_MANAGED_SHAREABLE_DEVICE}.\n     * @param admin Which device owner this request is associated with.\n     * @return if this user is a system-only user.\n     ",
    "links" : [ "#ACTION_PROVISION_MANAGED_SHAREABLE_DEVICE" ]
  }, {
    "name" : "public String getWifiMacAddress(@NonNull ComponentName admin)",
    "returnType" : "String",
    "comment" : "\n     * Called by device owner, or profile owner on organization-owned device, to get the MAC\n     * address of the Wi-Fi device.\n     *\n     * NOTE: The MAC address returned here should only be used for inventory management and is\n     * not likely to be the MAC address used by the device to connect to Wi-Fi networks: MAC\n     * addresses used for scanning and connecting to Wi-Fi networks are randomized by default.\n     * To get the randomized MAC address used, call\n     * {@link android.net.wifi.WifiConfiguration#getRandomizedMacAddress}.\n     *\n     * @param admin Which device owner this request is associated with.\n     * @return the MAC address of the Wi-Fi device, or null when the information is not available.\n     *         (For example, Wi-Fi hasn't been enabled, or the device doesn't support Wi-Fi.)\n     *         <p>\n     *         The address will be in the {@code XX:XX:XX:XX:XX:XX} format.\n     * @throws SecurityException if {@code admin} is not a device owner.\n     ",
    "links" : [ "android.net.wifi.WifiConfiguration#getRandomizedMacAddress" ]
  }, {
    "name" : "public void reboot(@NonNull ComponentName admin)",
    "returnType" : "void",
    "comment" : "\n     * Called by device owner to reboot the device. If there is an ongoing call on the device,\n     * throws an {@link IllegalStateException}.\n     * @param admin Which device owner the request is associated with.\n     * @throws IllegalStateException if device has an ongoing call.\n     * @throws SecurityException if {@code admin} is not a device owner.\n     * @see TelephonyManager#CALL_STATE_IDLE\n     ",
    "links" : [ "IllegalStateException" ]
  }, {
    "name" : "public void setShortSupportMessage(@NonNull ComponentName admin, @Nullable CharSequence message)",
    "returnType" : "void",
    "comment" : "\n     * Called by a device admin to set the short support message. This will be displayed to the user\n     * in settings screens where funtionality has been disabled by the admin. The message should be\n     * limited to a short statement such as \"This setting is disabled by your administrator. Contact\n     * someone@example.com for support.\" If the message is longer than 200 characters it may be\n     * truncated.\n     * <p>\n     * If the short support message needs to be localized, it is the responsibility of the\n     * {@link DeviceAdminReceiver} to listen to the {@link Intent#ACTION_LOCALE_CHANGED} broadcast\n     * and set a new version of this string accordingly.\n     *\n     * @see #setLongSupportMessage\n     * @param admin Which {@link DeviceAdminReceiver} this request is associated with.\n     * @param message Short message to be displayed to the user in settings or null to clear the\n     *            existing message.\n     * @throws SecurityException if {@code admin} is not an active administrator.\n     ",
    "links" : [ "DeviceAdminReceiver", "Intent#ACTION_LOCALE_CHANGED", "DeviceAdminReceiver" ]
  }, {
    "name" : "public CharSequence getShortSupportMessage(@NonNull ComponentName admin)",
    "returnType" : "CharSequence",
    "comment" : "\n     * Called by a device admin to get the short support message.\n     *\n     * @param admin Which {@link DeviceAdminReceiver} this request is associated with.\n     * @return The message set by {@link #setShortSupportMessage(ComponentName, CharSequence)} or\n     *         null if no message has been set.\n     * @throws SecurityException if {@code admin} is not an active administrator.\n     ",
    "links" : [ "DeviceAdminReceiver", "#setShortSupportMessage" ]
  }, {
    "name" : "public void setLongSupportMessage(@NonNull ComponentName admin, @Nullable CharSequence message)",
    "returnType" : "void",
    "comment" : "\n     * Called by a device admin to set the long support message. This will be displayed to the user\n     * in the device administators settings screen.\n     * <p>\n     * If the long support message needs to be localized, it is the responsibility of the\n     * {@link DeviceAdminReceiver} to listen to the {@link Intent#ACTION_LOCALE_CHANGED} broadcast\n     * and set a new version of this string accordingly.\n     *\n     * @see #setShortSupportMessage\n     * @param admin Which {@link DeviceAdminReceiver} this request is associated with.\n     * @param message Long message to be displayed to the user in settings or null to clear the\n     *            existing message.\n     * @throws SecurityException if {@code admin} is not an active administrator.\n     ",
    "links" : [ "DeviceAdminReceiver", "Intent#ACTION_LOCALE_CHANGED", "DeviceAdminReceiver" ]
  }, {
    "name" : "public CharSequence getLongSupportMessage(@NonNull ComponentName admin)",
    "returnType" : "CharSequence",
    "comment" : "\n     * Called by a device admin to get the long support message.\n     *\n     * @param admin Which {@link DeviceAdminReceiver} this request is associated with.\n     * @return The message set by {@link #setLongSupportMessage(ComponentName, CharSequence)} or\n     *         null if no message has been set.\n     * @throws SecurityException if {@code admin} is not an active administrator.\n     ",
    "links" : [ "DeviceAdminReceiver", "#setLongSupportMessage" ]
  }, {
    "name" : "public CharSequence getShortSupportMessageForUser(@NonNull ComponentName admin, int userHandle)",
    "returnType" : "CharSequence",
    "comment" : "\n     * Called by the system to get the short support message.\n     *\n     * @param admin Which {@link DeviceAdminReceiver} this request is associated with.\n     * @param userHandle user id the admin is running as.\n     * @return The message set by {@link #setShortSupportMessage(ComponentName, CharSequence)}\n     *\n     * @hide\n     ",
    "links" : [ "DeviceAdminReceiver", "#setShortSupportMessage" ]
  }, {
    "name" : "public CharSequence getLongSupportMessageForUser(@NonNull ComponentName admin, int userHandle)",
    "returnType" : "CharSequence",
    "comment" : "\n     * Called by the system to get the long support message.\n     *\n     * @param admin Which {@link DeviceAdminReceiver} this request is associated with.\n     * @param userHandle user id the admin is running as.\n     * @return The message set by {@link #setLongSupportMessage(ComponentName, CharSequence)}\n     *\n     * @hide\n     ",
    "links" : [ "DeviceAdminReceiver", "#setLongSupportMessage" ]
  }, {
    "name" : "public DevicePolicyManager getParentProfileInstance(@NonNull ComponentName admin)",
    "returnType" : "DevicePolicyManager",
    "comment" : "\n     * Called by the profile owner of a managed profile to obtain a {@link DevicePolicyManager}\n     * whose calls act on the parent profile.\n     *\n     * <p>The following methods are supported for the parent instance, all other methods will\n     * throw a SecurityException when called on the parent instance:\n     * <ul>\n     * <li>{@link #getPasswordQuality}</li>\n     * <li>{@link #setPasswordQuality}</li>\n     * <li>{@link #getPasswordMinimumLength}</li>\n     * <li>{@link #setPasswordMinimumLength}</li>\n     * <li>{@link #getPasswordMinimumUpperCase}</li>\n     * <li>{@link #setPasswordMinimumUpperCase}</li>\n     * <li>{@link #getPasswordMinimumLowerCase}</li>\n     * <li>{@link #setPasswordMinimumLowerCase}</li>\n     * <li>{@link #getPasswordMinimumLetters}</li>\n     * <li>{@link #setPasswordMinimumLetters}</li>\n     * <li>{@link #getPasswordMinimumNumeric}</li>\n     * <li>{@link #setPasswordMinimumNumeric}</li>\n     * <li>{@link #getPasswordMinimumSymbols}</li>\n     * <li>{@link #setPasswordMinimumSymbols}</li>\n     * <li>{@link #getPasswordMinimumNonLetter}</li>\n     * <li>{@link #setPasswordMinimumNonLetter}</li>\n     * <li>{@link #getPasswordHistoryLength}</li>\n     * <li>{@link #setPasswordHistoryLength}</li>\n     * <li>{@link #getPasswordExpirationTimeout}</li>\n     * <li>{@link #setPasswordExpirationTimeout}</li>\n     * <li>{@link #getPasswordExpiration}</li>\n     * <li>{@link #getPasswordMaximumLength}</li>\n     * <li>{@link #isActivePasswordSufficient}</li>\n     * <li>{@link #getCurrentFailedPasswordAttempts}</li>\n     * <li>{@link #getMaximumFailedPasswordsForWipe}</li>\n     * <li>{@link #setMaximumFailedPasswordsForWipe}</li>\n     * <li>{@link #getMaximumTimeToLock}</li>\n     * <li>{@link #setMaximumTimeToLock}</li>\n     * <li>{@link #lockNow}</li>\n     * <li>{@link #getKeyguardDisabledFeatures}</li>\n     * <li>{@link #setKeyguardDisabledFeatures}</li>\n     * <li>{@link #getTrustAgentConfiguration}</li>\n     * <li>{@link #setTrustAgentConfiguration}</li>\n     * <li>{@link #getRequiredStrongAuthTimeout}</li>\n     * <li>{@link #setRequiredStrongAuthTimeout}</li>\n     * <li>{@link #getAccountTypesWithManagementDisabled}</li>\n     * </ul>\n     * <p>\n     * The following methods are supported for the parent instance but can only be called by the\n     * profile owner of a managed profile that was created during the device provisioning flow:\n     * <ul>\n     * <li>{@link #getPasswordComplexity}</li>\n     * <li>{@link #setCameraDisabled}</li>\n     * <li>{@link #getCameraDisabled}</li>\n     * <li>{@link #setAccountManagementDisabled(ComponentName, String, boolean)}</li>\n     * </ul>\n     *\n     * <p>The following methods can be called by the profile owner of a managed profile\n     * on an organization-owned device:\n     * <ul>\n     * <li>{@link #wipeData}</li>\n     * </ul>\n     *\n     * @return a new instance of {@link DevicePolicyManager} that acts on the parent profile.\n     * @throws SecurityException if {@code admin} is not a profile owner.\n     ",
    "links" : [ "DevicePolicyManager", "#getPasswordQuality", "#setPasswordQuality", "#getPasswordMinimumLength", "#setPasswordMinimumLength", "#getPasswordMinimumUpperCase", "#setPasswordMinimumUpperCase", "#getPasswordMinimumLowerCase", "#setPasswordMinimumLowerCase", "#getPasswordMinimumLetters", "#setPasswordMinimumLetters", "#getPasswordMinimumNumeric", "#setPasswordMinimumNumeric", "#getPasswordMinimumSymbols", "#setPasswordMinimumSymbols", "#getPasswordMinimumNonLetter", "#setPasswordMinimumNonLetter", "#getPasswordHistoryLength", "#setPasswordHistoryLength", "#getPasswordExpirationTimeout", "#setPasswordExpirationTimeout", "#getPasswordExpiration", "#getPasswordMaximumLength", "#isActivePasswordSufficient", "#getCurrentFailedPasswordAttempts", "#getMaximumFailedPasswordsForWipe", "#setMaximumFailedPasswordsForWipe", "#getMaximumTimeToLock", "#setMaximumTimeToLock", "#lockNow", "#getKeyguardDisabledFeatures", "#setKeyguardDisabledFeatures", "#getTrustAgentConfiguration", "#setTrustAgentConfiguration", "#getRequiredStrongAuthTimeout", "#setRequiredStrongAuthTimeout", "#getAccountTypesWithManagementDisabled", "#getPasswordComplexity", "#setCameraDisabled", "#getCameraDisabled", "#setAccountManagementDisabled", "#wipeData", "DevicePolicyManager" ]
  }, {
    "name" : "public void setSecurityLoggingEnabled(@NonNull ComponentName admin, boolean enabled)",
    "returnType" : "void",
    "comment" : "\n     * Called by device owner or a profile owner of an organization-owned managed profile to\n     * control the security logging feature.\n     *\n     * <p> Security logs contain various information intended for security auditing purposes.\n     * When security logging is enabled by a profile owner of\n     * an organization-owned managed profile, certain security logs are not visible (for example\n     * personal app launch events) or they will be redacted (for example, details of the physical\n     * volume mount events). Please see {@link SecurityEvent} for details.\n     *\n     * <p><strong>Note:</strong> The device owner won't be able to retrieve security logs if there\n     * are unaffiliated secondary users or profiles on the device, regardless of whether the\n     * feature is enabled. Logs will be discarded if the internal buffer fills up while waiting for\n     * all users to become affiliated. Therefore it's recommended that affiliation ids are set for\n     * new users as soon as possible after provisioning via {@link #setAffiliationIds}. Profile\n     * owner of organization-owned managed profile is not subject to this restriction since all\n     * privacy-sensitive events happening outside the managed profile would have been redacted\n     * already.\n     *\n     * @param admin Which device admin this request is associated with.\n     * @param enabled whether security logging should be enabled or not.\n     * @throws SecurityException if {@code admin} is not allowed to control security logging.\n     * @see #setAffiliationIds\n     * @see #retrieveSecurityLogs\n     ",
    "links" : [ "SecurityEvent", "#setAffiliationIds" ]
  }, {
    "name" : "public boolean isSecurityLoggingEnabled(@Nullable ComponentName admin)",
    "returnType" : "boolean",
    "comment" : "\n     * Return whether security logging is enabled or not by the admin.\n     *\n     * <p>Can only be called by the device owner or a profile owner of an organization-owned\n     * managed profile, otherwise a {@link SecurityException} will be thrown.\n     *\n     * @param admin Which device admin this request is associated with.\n     * @return {@code true} if security logging is enabled by device owner, {@code false} otherwise.\n     * @throws SecurityException if {@code admin} is not allowed to control security logging.\n     ",
    "links" : [ "SecurityException" ]
  }, {
    "name" : "public List<SecurityEvent> retrieveSecurityLogs(@NonNull ComponentName admin)",
    "returnType" : "List<SecurityEvent>",
    "comment" : "\n     * Called by device owner or profile owner of an organization-owned managed profile to retrieve\n     * all new security logging entries since the last call to this API after device boots.\n     *\n     * <p> Access to the logs is rate limited and it will only return new logs after the device\n     * owner has been notified via {@link DeviceAdminReceiver#onSecurityLogsAvailable}.\n     *\n     * <p> When called by a device owner, if there is any other user or profile on the device,\n     * it must be affiliated with the device. Otherwise a {@link SecurityException} will be thrown.\n     * See {@link #isAffiliatedUser}.\n     *\n     * @param admin Which device admin this request is associated with.\n     * @return the new batch of security logs which is a list of {@link SecurityEvent},\n     * or {@code null} if rate limitation is exceeded or if logging is currently disabled.\n     * @throws SecurityException if {@code admin} is not allowed to access security logging,\n     * or there is at least one profile or secondary user that is not affiliated with the device.\n     * @see #isAffiliatedUser\n     * @see DeviceAdminReceiver#onSecurityLogsAvailable\n     ",
    "links" : [ "DeviceAdminReceiver#onSecurityLogsAvailable", "SecurityException", "#isAffiliatedUser", "SecurityEvent" ]
  }, {
    "name" : "public long forceNetworkLogs()",
    "returnType" : "long",
    "comment" : "\n     * Makes all accumulated network logs available to DPC in a new batch.\n     * Only callable by ADB. If throttled, returns time to wait in milliseconds, otherwise 0.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public long forceSecurityLogs()",
    "returnType" : "long",
    "comment" : "\n     * Forces a batch of security logs to be fetched from logd and makes it available for DPC.\n     * Only callable by ADB. If throttled, returns time to wait in milliseconds, otherwise 0.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public DevicePolicyManager getParentProfileInstance(UserInfo uInfo)",
    "returnType" : "DevicePolicyManager",
    "comment" : "\n     * Called by the system to obtain a {@link DevicePolicyManager} whose calls act on the parent\n     * profile.\n     *\n     * @hide\n     ",
    "links" : [ "DevicePolicyManager" ]
  }, {
    "name" : "public List<String> setMeteredDataDisabledPackages(@NonNull ComponentName admin, @NonNull List<String> packageNames)",
    "returnType" : "List<String>",
    "comment" : "\n     * Called by a device or profile owner to restrict packages from using metered data.\n     *\n     * @param admin which {@link DeviceAdminReceiver} this request is associated with.\n     * @param packageNames the list of package names to be restricted.\n     * @return a list of package names which could not be restricted.\n     * @throws SecurityException if {@code admin} is not a device or profile owner.\n     ",
    "links" : [ "DeviceAdminReceiver" ]
  }, {
    "name" : "public List<String> getMeteredDataDisabledPackages(@NonNull ComponentName admin)",
    "returnType" : "List<String>",
    "comment" : "\n     * Called by a device or profile owner to retrieve the list of packages which are restricted\n     * by the admin from using metered data.\n     *\n     * @param admin which {@link DeviceAdminReceiver} this request is associated with.\n     * @return the list of restricted package names.\n     * @throws SecurityException if {@code admin} is not a device or profile owner.\n     ",
    "links" : [ "DeviceAdminReceiver" ]
  }, {
    "name" : "public boolean isMeteredDataDisabledPackageForUser(@NonNull ComponentName admin, String packageName, @UserIdInt int userId)",
    "returnType" : "boolean",
    "comment" : "\n     * Called by the system to check if a package is restricted from using metered data\n     * by {@param admin}.\n     *\n     * @param admin which {@link DeviceAdminReceiver} this request is associated with.\n     * @param packageName the package whose restricted status is needed.\n     * @param userId the user to which {@param packageName} belongs.\n     * @return {@code true} if the package is restricted by admin, otherwise {@code false}\n     * @throws SecurityException if the caller doesn't run with {@link Process#SYSTEM_UID}\n     * @hide\n     ",
    "links" : [ "DeviceAdminReceiver", "Process#SYSTEM_UID" ]
  }, {
    "name" : "public List<SecurityEvent> retrievePreRebootSecurityLogs(@NonNull ComponentName admin)",
    "returnType" : "List<SecurityEvent>",
    "comment" : "\n     * Called by device owner or profile owner of an organization-owned managed profile to retrieve\n     * device logs from before the device's last reboot.\n     * <p>\n     * <strong> This API is not supported on all devices. Calling this API on unsupported devices\n     * will result in {@code null} being returned. The device logs are retrieved from a RAM region\n     * which is not guaranteed to be corruption-free during power cycles, as a result be cautious\n     * about data corruption when parsing. </strong>\n     *\n     * <p> When called by a device owner, if there is any other user or profile on the device,\n     * it must be affiliated with the device. Otherwise a {@link SecurityException} will be thrown.\n     * See {@link #isAffiliatedUser}.\n     *\n     * @param admin Which device admin this request is associated with.\n     * @return Device logs from before the latest reboot of the system, or {@code null} if this API\n     *         is not supported on the device.\n     * @throws SecurityException if {@code admin} is not allowed to access security logging, or\n     * there is at least one profile or secondary user that is not affiliated with the device.\n     * @see #isAffiliatedUser\n     * @see #retrieveSecurityLogs\n     ",
    "links" : [ "SecurityException", "#isAffiliatedUser" ]
  }, {
    "name" : "public void setOrganizationColor(@NonNull ComponentName admin, int color)",
    "returnType" : "void",
    "comment" : "\n     * Called by a profile owner of a managed profile to set the color used for customization. This\n     * color is used as background color of the confirm credentials screen for that user. The\n     * default color is teal (#00796B).\n     * <p>\n     * The confirm credentials screen can be created using\n     * {@link android.app.KeyguardManager#createConfirmDeviceCredentialIntent}.\n     * <p>\n     * Starting from Android R, the organization color will no longer be used as the background\n     * color of the confirm credentials screen.\n     *\n     * @param admin Which {@link DeviceAdminReceiver} this request is associated with.\n     * @param color The 24bit (0xRRGGBB) representation of the color to be used.\n     * @throws SecurityException if {@code admin} is not a profile owner.\n     ",
    "links" : [ "android.app.KeyguardManager#createConfirmDeviceCredentialIntent", "DeviceAdminReceiver" ]
  }, {
    "name" : "public void setOrganizationColorForUser(@ColorInt int color, @UserIdInt int userId)",
    "returnType" : "void",
    "comment" : "\n     * @hide\n     *\n     * Sets the color used for customization.\n     *\n     * @param color The 24bit (0xRRGGBB) representation of the color to be used.\n     * @param userId which user to set the color to.\n     * @RequiresPermission(allOf = {\n     *       Manifest.permission.MANAGE_USERS,\n     *       Manifest.permission.INTERACT_ACROSS_USERS_FULL})\n     ",
    "links" : [ ]
  }, {
    "name" : "public int getOrganizationColor(@NonNull ComponentName admin)",
    "returnType" : "int",
    "comment" : "\n     * Called by a profile owner of a managed profile to retrieve the color used for customization.\n     * This color is used as background color of the confirm credentials screen for that user.\n     *\n     * @param admin Which {@link DeviceAdminReceiver} this request is associated with.\n     * @return The 24bit (0xRRGGBB) representation of the color to be used.\n     * @throws SecurityException if {@code admin} is not a profile owner.\n     ",
    "links" : [ "DeviceAdminReceiver" ]
  }, {
    "name" : "public int getOrganizationColorForUser(int userHandle)",
    "returnType" : "int",
    "comment" : "\n     * @hide\n     * Retrieve the customization color for a given user.\n     *\n     * @param userHandle The user id of the user we're interested in.\n     * @return The 24bit (0xRRGGBB) representation of the color to be used.\n     ",
    "links" : [ ]
  }, {
    "name" : "public void setOrganizationName(@NonNull ComponentName admin, @Nullable CharSequence title)",
    "returnType" : "void",
    "comment" : "\n     * Called by the device owner (since API 26) or profile owner (since API 24) to set the name of\n     * the organization under management.\n     *\n     * <p>If the organization name needs to be localized, it is the responsibility of the {@link\n     * DeviceAdminReceiver} to listen to the {@link Intent#ACTION_LOCALE_CHANGED} broadcast and set\n     * a new version of this string accordingly.\n     *\n     * @param admin Which {@link DeviceAdminReceiver} this request is associated with.\n     * @param title The organization name or {@code null} to clear a previously set name.\n     * @throws SecurityException if {@code admin} is not a device or profile owner.\n     ",
    "links" : [ "Intent#ACTION_LOCALE_CHANGED", "DeviceAdminReceiver" ]
  }, {
    "name" : "public CharSequence getOrganizationName(@NonNull ComponentName admin)",
    "returnType" : "CharSequence",
    "comment" : "\n     * Called by a profile owner of a managed profile to retrieve the name of the organization under\n     * management.\n     *\n     * @param admin Which {@link DeviceAdminReceiver} this request is associated with.\n     * @return The organization name or {@code null} if none is set.\n     * @throws SecurityException if {@code admin} is not a profile owner.\n     ",
    "links" : [ "DeviceAdminReceiver" ]
  }, {
    "name" : "public CharSequence getDeviceOwnerOrganizationName()",
    "returnType" : "CharSequence",
    "comment" : "\n     * Called by the system to retrieve the name of the organization managing the device.\n     *\n     * @return The organization name or {@code null} if none is set.\n     * @throws SecurityException if the caller is not the device owner, does not hold the\n     *         MANAGE_USERS permission and is not the system.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public CharSequence getOrganizationNameForUser(int userHandle)",
    "returnType" : "CharSequence",
    "comment" : "\n     * Retrieve the default title message used in the confirm credentials screen for a given user.\n     *\n     * @param userHandle The user id of the user we're interested in.\n     * @return The organization name or {@code null} if none is set.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public int getUserProvisioningState()",
    "returnType" : "int",
    "comment" : "\n     * @return the {@link UserProvisioningState} for the current user - for unmanaged users will\n     *         return {@link #STATE_USER_UNMANAGED}\n     * @hide\n     ",
    "links" : [ "UserProvisioningState", "#STATE_USER_UNMANAGED" ]
  }, {
    "name" : "public void setUserProvisioningState(@UserProvisioningState int state, int userHandle)",
    "returnType" : "void",
    "comment" : "\n     * Set the {@link UserProvisioningState} for the supplied user, if they are managed.\n     *\n     * @param state to store\n     * @param userHandle for user\n     * @hide\n     ",
    "links" : [ "UserProvisioningState" ]
  }, {
    "name" : "public void setAffiliationIds(@NonNull ComponentName admin, @NonNull Set<String> ids)",
    "returnType" : "void",
    "comment" : "\n     * Indicates the entity that controls the device. Two users are\n     * affiliated if the set of ids set by the device owner and the admin of the secondary user.\n     *\n     * <p>A user that is affiliated with the device owner user is considered to be\n     * affiliated with the device.\n     *\n     * <p><strong>Note:</strong> Features that depend on user affiliation (such as security logging\n     * or {@link #bindDeviceAdminServiceAsUser}) won't be available when a secondary user\n     * is created, until it becomes affiliated. Therefore it is recommended that the appropriate\n     * affiliation ids are set by its owner as soon as possible after the user is\n     * created.\n     * <p>\n     * Note: This method used to be available for affiliating device owner and profile\n     * owner. However, since Android 11, this combination is not possible. This method is now\n     * only useful for affiliating the primary user with managed secondary users.\n     *\n     * @param admin Which device owner, or owner of secondary user, this request is associated with.\n     * @param ids A set of opaque non-empty affiliation ids.\n     *\n     * @throws IllegalArgumentException if {@code ids} is null or contains an empty string.\n     * @see #isAffiliatedUser\n     ",
    "links" : [ "#bindDeviceAdminServiceAsUser" ]
  }, {
    "name" : "public Set<String> getAffiliationIds(@NonNull ComponentName admin)",
    "returnType" : "Set<String>",
    "comment" : "\n     * Returns the set of affiliation ids previously set via {@link #setAffiliationIds}, or an\n     * empty set if none have been set.\n     ",
    "links" : [ "#setAffiliationIds" ]
  }, {
    "name" : "public boolean isAffiliatedUser()",
    "returnType" : "boolean",
    "comment" : "\n     * Returns whether this user is affiliated with the device.\n     * <p>\n     * By definition, the user that the device owner runs on is always affiliated with the device.\n     * Any other user is considered affiliated with the device if the set specified by its\n     * profile owner via {@link #setAffiliationIds} intersects with the device owner's.\n     * @see #setAffiliationIds\n     ",
    "links" : [ "#setAffiliationIds" ]
  }, {
    "name" : "public boolean isUninstallInQueue(String packageName)",
    "returnType" : "boolean",
    "comment" : "\n     * @hide\n     * Returns whether the uninstall for {@code packageName} for the current user is in queue\n     * to be started\n     * @param packageName the package to check for\n     * @return whether the uninstall intent for {@code packageName} is pending\n     ",
    "links" : [ ]
  }, {
    "name" : "public void uninstallPackageWithActiveAdmins(String packageName)",
    "returnType" : "void",
    "comment" : "\n     * @hide\n     * @param packageName the package containing active DAs to be uninstalled\n     ",
    "links" : [ ]
  }, {
    "name" : "public void forceRemoveActiveAdmin(ComponentName adminReceiver, int userHandle)",
    "returnType" : "void",
    "comment" : "\n     * @hide\n     * Remove a test admin synchronously without sending it a broadcast about being removed.\n     * If the admin is a profile owner or device owner it will still be removed.\n     *\n     * @param userHandle user id to remove the admin for.\n     * @param admin The administration compononent to remove.\n     * @throws SecurityException if the caller is not shell / root or the admin package\n     *         isn't a test application see {@link ApplicationInfo#FLAG_TEST_APP}.\n     ",
    "links" : [ "ApplicationInfo#FLAG_TEST_APP" ]
  }, {
    "name" : "public boolean isDeviceProvisioned()",
    "returnType" : "boolean",
    "comment" : "\n     * Returns whether the device has been provisioned.\n     *\n     * <p>Not for use by third-party applications.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public void setDeviceProvisioningConfigApplied()",
    "returnType" : "void",
    "comment" : "\n      * Writes that the provisioning configuration has been applied.\n      *\n      * <p>The caller must hold the {@link android.Manifest.permission#MANAGE_USERS}\n      * permission.\n      *\n      * <p>Not for use by third-party applications.\n      *\n      * @hide\n      ",
    "links" : [ "android.Manifest.permission#MANAGE_USERS" ]
  }, {
    "name" : "public boolean isDeviceProvisioningConfigApplied()",
    "returnType" : "boolean",
    "comment" : "\n     * Returns whether the provisioning configuration has been applied.\n     *\n     * <p>The caller must hold the {@link android.Manifest.permission#MANAGE_USERS} permission.\n     *\n     * <p>Not for use by third-party applications.\n     *\n     * @return whether the provisioning configuration has been applied.\n     *\n     * @hide\n     ",
    "links" : [ "android.Manifest.permission#MANAGE_USERS" ]
  }, {
    "name" : "public void forceUpdateUserSetupComplete()",
    "returnType" : "void",
    "comment" : "\n     * @hide\n     * Force update user setup completed status. This API has no effect on user build.\n     * @throws {@link SecurityException} if the caller has no\n     *         {@code android.Manifest.permission.MANAGE_PROFILE_AND_DEVICE_OWNERS} or the caller is\n     *         not {@link UserHandle#SYSTEM_USER}\n     ",
    "links" : [ "SecurityException", "UserHandle#SYSTEM_USER" ]
  }, {
    "name" : "private void throwIfParentInstance(String functionName)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public void setBackupServiceEnabled(@NonNull ComponentName admin, boolean enabled)",
    "returnType" : "void",
    "comment" : "\n     * Allows the device owner or profile owner to enable or disable the backup service.\n     *\n     * <p> Each user has its own backup service which manages the backup and restore mechanisms in\n     * that user. Disabling the backup service will prevent data from being backed up or restored.\n     *\n     * <p> Device owner calls this API to control backup services across all users on the device.\n     * Profile owner can use this API to enable or disable the profile's backup service. However,\n     * for a managed profile its backup functionality is only enabled if both the device owner\n     * and the profile owner have enabled the backup service.\n     *\n     * <p> By default, backup service is disabled on a device with device owner, and within a\n     * managed profile.\n     *\n     * @param admin Which {@link DeviceAdminReceiver} this request is associated with.\n     * @param enabled {@code true} to enable the backup service, {@code false} to disable it.\n     * @throws SecurityException if {@code admin} is not a device owner or a profile owner.\n     ",
    "links" : [ "DeviceAdminReceiver" ]
  }, {
    "name" : "public boolean isBackupServiceEnabled(@NonNull ComponentName admin)",
    "returnType" : "boolean",
    "comment" : "\n     * Return whether the backup service is enabled by the device owner or profile owner for the\n     * current user, as previously set by {@link #setBackupServiceEnabled(ComponentName, boolean)}.\n     *\n     * <p> Whether the backup functionality is actually enabled or not depends on settings from both\n     * the current user and the device owner, please see\n     * {@link #setBackupServiceEnabled(ComponentName, boolean)} for details.\n     *\n     * <p> Backup service manages all backup and restore mechanisms on the device.\n     *\n     * @return {@code true} if backup service is enabled, {@code false} otherwise.\n     * @see #setBackupServiceEnabled\n     ",
    "links" : [ "#setBackupServiceEnabled", "#setBackupServiceEnabled" ]
  }, {
    "name" : "public void setNetworkLoggingEnabled(@Nullable ComponentName admin, boolean enabled)",
    "returnType" : "void",
    "comment" : "\n     * Called by a device owner or delegated app with {@link #DELEGATION_NETWORK_LOGGING} to\n     * control the network logging feature.\n     *\n     * <p> Network logs contain DNS lookup and connect() library call events. The following library\n     *     functions are recorded while network logging is active:\n     *     <ul>\n     *       <li>{@code getaddrinfo()}</li>\n     *       <li>{@code gethostbyname()}</li>\n     *       <li>{@code connect()}</li>\n     *     </ul>\n     *\n     * <p> Network logging is a low-overhead tool for forensics but it is not guaranteed to use\n     *     full system call logging; event reporting is enabled by default for all processes but not\n     *     strongly enforced.\n     *     Events from applications using alternative implementations of libc, making direct kernel\n     *     calls, or deliberately obfuscating traffic may not be recorded.\n     *\n     * <p> Some common network events may not be reported. For example:\n     *     <ul>\n     *       <li>Applications may hardcode IP addresses to reduce the number of DNS lookups, or use\n     *           an alternative system for name resolution, and so avoid calling\n     *           {@code getaddrinfo()} or {@code gethostbyname}.</li>\n     *       <li>Applications may use datagram sockets for performance reasons, for example\n     *           for a game client. Calling {@code connect()} is unnecessary for this kind of\n     *           socket, so it will not trigger a network event.</li>\n     *     </ul>\n     *\n     * <p> It is possible to directly intercept layer 3 traffic leaving the device using an\n     *     always-on VPN service.\n     *     See {@link #setAlwaysOnVpnPackage(ComponentName, String, boolean)}\n     *     and {@link android.net.VpnService} for details.\n     *\n     * <p><strong>Note:</strong> The device owner won't be able to retrieve network logs if there\n     * are unaffiliated secondary users or profiles on the device, regardless of whether the\n     * feature is enabled. Logs will be discarded if the internal buffer fills up while waiting for\n     * all users to become affiliated. Therefore it's recommended that affiliation ids are set for\n     * new users as soon as possible after provisioning via {@link #setAffiliationIds}.\n     *\n     * @param admin Which {@link DeviceAdminReceiver} this request is associated with, or\n     *        {@code null} if called by a delegated app.\n     * @param enabled whether network logging should be enabled or not.\n     * @throws SecurityException if {@code admin} is not a device owner.\n     * @see #setAffiliationIds\n     * @see #retrieveNetworkLogs\n     ",
    "links" : [ "#DELEGATION_NETWORK_LOGGING", "#setAlwaysOnVpnPackage", "android.net.VpnService", "#setAffiliationIds", "DeviceAdminReceiver" ]
  }, {
    "name" : "public boolean isNetworkLoggingEnabled(@Nullable ComponentName admin)",
    "returnType" : "boolean",
    "comment" : "\n     * Return whether network logging is enabled by a device owner.\n     *\n     * @param admin Which {@link DeviceAdminReceiver} this request is associated with. Can only\n     * be {@code null} if the caller is a delegated app with {@link #DELEGATION_NETWORK_LOGGING}\n     * or has MANAGE_USERS permission.\n     * @return {@code true} if network logging is enabled by device owner, {@code false} otherwise.\n     * @throws SecurityException if {@code admin} is not a device owner and caller has\n     * no MANAGE_USERS permission\n     ",
    "links" : [ "DeviceAdminReceiver", "#DELEGATION_NETWORK_LOGGING" ]
  }, {
    "name" : "public List<NetworkEvent> retrieveNetworkLogs(@Nullable ComponentName admin, long batchToken)",
    "returnType" : "List<NetworkEvent>",
    "comment" : "\n     * Called by device owner or delegated app with {@link #DELEGATION_NETWORK_LOGGING} to retrieve\n     * the most recent batch of network logging events.\n     * A device owner has to provide a batchToken provided as part of\n     * {@link DeviceAdminReceiver#onNetworkLogsAvailable} callback. If the token doesn't match the\n     * token of the most recent available batch of logs, {@code null} will be returned.\n     *\n     * <p> {@link NetworkEvent} can be one of {@link DnsEvent} or {@link ConnectEvent}.\n     *\n     * <p> The list of network events is sorted chronologically, and contains at most 1200 events.\n     *\n     * <p> Access to the logs is rate limited and this method will only return a new batch of logs\n     * after the device device owner has been notified via\n     * {@link DeviceAdminReceiver#onNetworkLogsAvailable}.\n     *\n     * <p>If a secondary user or profile is created, calling this method will throw a\n     * {@link SecurityException} until all users become affiliated again. It will also no longer be\n     * possible to retrieve the network logs batch with the most recent batchToken provided\n     * by {@link DeviceAdminReceiver#onNetworkLogsAvailable}. See\n     * {@link DevicePolicyManager#setAffiliationIds}.\n     *\n     * @param admin Which {@link DeviceAdminReceiver} this request is associated with, or\n     *        {@code null} if called by a delegated app.\n     * @param batchToken A token of the batch to retrieve\n     * @return A new batch of network logs which is a list of {@link NetworkEvent}. Returns\n     *        {@code null} if the batch represented by batchToken is no longer available or if\n     *        logging is disabled.\n     * @throws SecurityException if {@code admin} is not a device owner, or there is at least one\n     * profile or secondary user that is not affiliated with the device.\n     * @see #setAffiliationIds\n     * @see DeviceAdminReceiver#onNetworkLogsAvailable\n     ",
    "links" : [ "#DELEGATION_NETWORK_LOGGING", "DeviceAdminReceiver#onNetworkLogsAvailable", "NetworkEvent", "DnsEvent", "ConnectEvent", "DeviceAdminReceiver#onNetworkLogsAvailable", "SecurityException", "DeviceAdminReceiver#onNetworkLogsAvailable", "DevicePolicyManager#setAffiliationIds", "DeviceAdminReceiver", "NetworkEvent" ]
  }, {
    "name" : "public boolean bindDeviceAdminServiceAsUser(@NonNull ComponentName admin, Intent serviceIntent, @NonNull ServiceConnection conn, @Context.BindServiceFlags int flags, @NonNull UserHandle targetUser)",
    "returnType" : "boolean",
    "comment" : "\n     * Called by a device owner to bind to a service from a secondary managed user or vice versa.\n     * See {@link #getBindDeviceAdminTargetUsers} for the pre-requirements of a\n     * device owner to bind to services of another managed user.\n     * <p>\n     * The service must be protected by {@link android.Manifest.permission#BIND_DEVICE_ADMIN}.\n     * Note that the {@link Context} used to obtain this\n     * {@link DevicePolicyManager} instance via {@link Context#getSystemService(Class)} will be used\n     * to bind to the {@link android.app.Service}.\n     * <p>\n     * Note: This method used to be available for communication between device owner and profile\n     * owner. However, since Android 11, this combination is not possible. This method is now\n     * only useful for communication between device owner and managed secondary users.\n     *\n     * @param admin Which {@link DeviceAdminReceiver} this request is associated with.\n     * @param serviceIntent Identifies the service to connect to.  The Intent must specify either an\n     *        explicit component name or a package name to match an\n     *        {@link IntentFilter} published by a service.\n     * @param conn Receives information as the service is started and stopped in main thread. This\n     *        must be a valid {@link ServiceConnection} object; it must not be {@code null}.\n     * @param flags Operation options for the binding operation. See\n     *        {@link Context#bindService(Intent, ServiceConnection, int)}.\n     * @param targetUser Which user to bind to. Must be one of the users returned by\n     *        {@link #getBindDeviceAdminTargetUsers}, otherwise a {@link SecurityException} will\n     *        be thrown.\n     * @return If you have successfully bound to the service, {@code true} is returned;\n     *         {@code false} is returned if the connection is not made and you will not\n     *         receive the service object.\n     *\n     * @see Context#bindService(Intent, ServiceConnection, int)\n     * @see #getBindDeviceAdminTargetUsers(ComponentName)\n     ",
    "links" : [ "#getBindDeviceAdminTargetUsers", "android.Manifest.permission#BIND_DEVICE_ADMIN", "Context", "DevicePolicyManager", "Context#getSystemService", "android.app.Service", "DeviceAdminReceiver", "IntentFilter", "ServiceConnection", "Context#bindService", "#getBindDeviceAdminTargetUsers", "SecurityException" ]
  }, {
    "name" : "public List<UserHandle> getBindDeviceAdminTargetUsers(@NonNull ComponentName admin)",
    "returnType" : "List<UserHandle>",
    "comment" : "\n     * Returns the list of target users that the calling device owner or owner of secondary user\n     * can use when calling {@link #bindDeviceAdminServiceAsUser}.\n     * <p>\n     * A device owner can bind to a service from a secondary managed user and vice versa, provided\n     * that both users are affiliated. See {@link #setAffiliationIds}.\n     ",
    "links" : [ "#bindDeviceAdminServiceAsUser", "#setAffiliationIds" ]
  }, {
    "name" : "public long getLastSecurityLogRetrievalTime()",
    "returnType" : "long",
    "comment" : "\n     * Called by the system to get the time at which the device owner last retrieved security\n     * logging entries.\n     *\n     * @return the time at which the device owner most recently retrieved security logging entries,\n     *         in milliseconds since epoch; -1 if security logging entries were never retrieved.\n     * @throws SecurityException if the caller is not the device owner, does not hold the\n     *         MANAGE_USERS permission and is not the system.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public long getLastBugReportRequestTime()",
    "returnType" : "long",
    "comment" : "\n     * Called by the system to get the time at which the device owner last requested a bug report.\n     *\n     * @return the time at which the device owner most recently requested a bug report, in\n     *         milliseconds since epoch; -1 if a bug report was never requested.\n     * @throws SecurityException if the caller is not the device owner, does not hold the\n     *         MANAGE_USERS permission and is not the system.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public long getLastNetworkLogRetrievalTime()",
    "returnType" : "long",
    "comment" : "\n     * Called by the system to get the time at which the device owner last retrieved network logging\n     * events.\n     *\n     * @return the time at which the device owner most recently retrieved network logging events, in\n     *         milliseconds since epoch; -1 if network logging events were never retrieved.\n     * @throws SecurityException if the caller is not the device owner, does not hold the\n     *         MANAGE_USERS permission and is not the system.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean isCurrentInputMethodSetByOwner()",
    "returnType" : "boolean",
    "comment" : "\n     * Called by the system to find out whether the current user's IME was set by the device/profile\n     * owner or the user.\n     *\n     * @return {@code true} if the user's IME was set by the device or profile owner, {@code false}\n     *         otherwise.\n     * @throws SecurityException if the caller is not the device owner/profile owner.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public List<String> getOwnerInstalledCaCerts(@NonNull UserHandle user)",
    "returnType" : "List<String>",
    "comment" : "\n     * Called by the system to get a list of CA certificates that were installed by the device or\n     * profile owner.\n     *\n     * <p> The caller must be the target user's device owner/profile Owner or hold the\n     * {@link android.Manifest.permission#INTERACT_ACROSS_USERS_FULL} permission.\n     *\n     * @param user The user for whom to retrieve information.\n     * @return list of aliases identifying CA certificates installed by the device or profile owner\n     * @throws SecurityException if the caller does not have permission to retrieve information\n     *         about the given user's CA certificates.\n     *\n     * @hide\n     ",
    "links" : [ "android.Manifest.permission#INTERACT_ACROSS_USERS_FULL" ]
  }, {
    "name" : "public boolean isFactoryResetProtectionPolicySupported()",
    "returnType" : "boolean",
    "comment" : "\n     * Returns whether factory reset protection policy is supported on the device.\n     *\n     * @return {@code true} if the device support factory reset protection policy.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public void clearApplicationUserData(@NonNull ComponentName admin, @NonNull String packageName, @NonNull @CallbackExecutor Executor executor, @NonNull OnClearApplicationUserDataListener listener)",
    "returnType" : "void",
    "comment" : "\n     * Called by the device owner or profile owner to clear application user data of a given\n     * package. The behaviour of this is equivalent to the target application calling\n     * {@link android.app.ActivityManager#clearApplicationUserData()}.\n     *\n     * <p><strong>Note:</strong> an application can store data outside of its application data, e.g.\n     * external storage or user dictionary. This data will not be wiped by calling this API.\n     *\n     * @param admin Which {@link DeviceAdminReceiver} this request is associated with.\n     * @param packageName The name of the package which will have its user data wiped.\n     * @param executor The executor through which the listener should be invoked.\n     * @param listener A callback object that will inform the caller when the clearing is done.\n     * @throws SecurityException if the caller is not the device owner/profile owner.\n     ",
    "links" : [ "android.app.ActivityManager#clearApplicationUserData", "DeviceAdminReceiver" ]
  }, {
    "name" : "public void setLogoutEnabled(@NonNull ComponentName admin, boolean enabled)",
    "returnType" : "void",
    "comment" : "\n     * Called by a device owner to specify whether logout is enabled for all secondary users. The\n     * system may show a logout button that stops the user and switches back to the primary user.\n     *\n     * @param admin Which {@link DeviceAdminReceiver} this request is associated with.\n     * @param enabled whether logout should be enabled or not.\n     * @throws SecurityException if {@code admin} is not a device owner.\n     ",
    "links" : [ "DeviceAdminReceiver" ]
  }, {
    "name" : "public boolean isLogoutEnabled()",
    "returnType" : "boolean",
    "comment" : "\n     * Returns whether logout is enabled by a device owner.\n     *\n     * @return {@code true} if logout is enabled by device owner, {@code false} otherwise.\n     ",
    "links" : [ ]
  }, {
    "name" : "public Set<String> getDisallowedSystemApps(ComponentName admin, int userId, String provisioningAction)",
    "returnType" : "Set<String>",
    "comment" : "\n     * Returns set of system apps that should be removed during provisioning.\n     *\n     * @param admin Which {@link DeviceAdminReceiver} this request is associated with.\n     * @param userId ID of the user to be provisioned.\n     * @param provisioningAction action indicating type of provisioning, should be one of\n     * {@link #ACTION_PROVISION_MANAGED_DEVICE}, {@link #ACTION_PROVISION_MANAGED_PROFILE} or\n     * {@link #ACTION_PROVISION_MANAGED_USER}.\n     *\n     * @hide\n     ",
    "links" : [ "DeviceAdminReceiver", "#ACTION_PROVISION_MANAGED_DEVICE", "#ACTION_PROVISION_MANAGED_PROFILE", "#ACTION_PROVISION_MANAGED_USER" ]
  }, {
    "name" : "public void transferOwnership(@NonNull ComponentName admin, @NonNull ComponentName target, @Nullable PersistableBundle bundle)",
    "returnType" : "void",
    "comment" : "\n     * Changes the current administrator to another one. All policies from the current\n     * administrator are migrated to the new administrator. The whole operation is atomic -\n     * the transfer is either complete or not done at all.\n     *\n     * <p>Depending on the current administrator (device owner, profile owner), you have the\n     * following expected behaviour:\n     * <ul>\n     *     <li>A device owner can only be transferred to a new device owner</li>\n     *     <li>A profile owner can only be transferred to a new profile owner</li>\n     * </ul>\n     *\n     * <p>Use the {@code bundle} parameter to pass data to the new administrator. The data\n     * will be received in the\n     * {@link DeviceAdminReceiver#onTransferOwnershipComplete(Context, PersistableBundle)}\n     * callback of the new administrator.\n     *\n     * <p>The transfer has failed if the original administrator is still the corresponding owner\n     * after calling this method.\n     *\n     * <p>The incoming target administrator must have the\n     * <code>&lt;support-transfer-ownership /&gt;</code> tag inside the\n     * <code>&lt;device-admin&gt;&lt;/device-admin&gt;</code> tags in the xml file referenced by\n     * {@link DeviceAdminReceiver#DEVICE_ADMIN_META_DATA}. Otherwise an\n     * {@link IllegalArgumentException} will be thrown.\n     *\n     * @param admin which {@link DeviceAdminReceiver} this request is associated with\n     * @param target which {@link DeviceAdminReceiver} we want the new administrator to be\n     * @param bundle data to be sent to the new administrator\n     * @throws SecurityException if {@code admin} is not a device owner nor a profile owner\n     * @throws IllegalArgumentException if {@code admin} or {@code target} is {@code null}, they\n     * are components in the same package or {@code target} is not an active admin\n     ",
    "links" : [ "DeviceAdminReceiver#onTransferOwnershipComplete", "DeviceAdminReceiver#DEVICE_ADMIN_META_DATA", "IllegalArgumentException", "DeviceAdminReceiver", "DeviceAdminReceiver" ]
  }, {
    "name" : "public void setStartUserSessionMessage(@NonNull ComponentName admin, @Nullable CharSequence startUserSessionMessage)",
    "returnType" : "void",
    "comment" : "\n     * Called by a device owner to specify the user session start message. This may be displayed\n     * during a user switch.\n     * <p>\n     * The message should be limited to a short statement or it may be truncated.\n     * <p>\n     * If the message needs to be localized, it is the responsibility of the\n     * {@link DeviceAdminReceiver} to listen to the {@link Intent#ACTION_LOCALE_CHANGED} broadcast\n     * and set a new version of this message accordingly.\n     *\n     * @param admin which {@link DeviceAdminReceiver} this request is associated with.\n     * @param startUserSessionMessage message for starting user session, or {@code null} to use\n     * system default message.\n     * @throws SecurityException if {@code admin} is not a device owner.\n     ",
    "links" : [ "DeviceAdminReceiver", "Intent#ACTION_LOCALE_CHANGED", "DeviceAdminReceiver" ]
  }, {
    "name" : "public void setEndUserSessionMessage(@NonNull ComponentName admin, @Nullable CharSequence endUserSessionMessage)",
    "returnType" : "void",
    "comment" : "\n     * Called by a device owner to specify the user session end message. This may be displayed\n     * during a user switch.\n     * <p>\n     * The message should be limited to a short statement or it may be truncated.\n     * <p>\n     * If the message needs to be localized, it is the responsibility of the\n     * {@link DeviceAdminReceiver} to listen to the {@link Intent#ACTION_LOCALE_CHANGED} broadcast\n     * and set a new version of this message accordingly.\n     *\n     * @param admin which {@link DeviceAdminReceiver} this request is associated with.\n     * @param endUserSessionMessage message for ending user session, or {@code null} to use system\n     * default message.\n     * @throws SecurityException if {@code admin} is not a device owner.\n     ",
    "links" : [ "DeviceAdminReceiver", "Intent#ACTION_LOCALE_CHANGED", "DeviceAdminReceiver" ]
  }, {
    "name" : "public CharSequence getStartUserSessionMessage(@NonNull ComponentName admin)",
    "returnType" : "CharSequence",
    "comment" : "\n     * Returns the user session start message.\n     *\n     * @param admin which {@link DeviceAdminReceiver} this request is associated with.\n     * @throws SecurityException if {@code admin} is not a device owner.\n     ",
    "links" : [ "DeviceAdminReceiver" ]
  }, {
    "name" : "public CharSequence getEndUserSessionMessage(@NonNull ComponentName admin)",
    "returnType" : "CharSequence",
    "comment" : "\n     * Returns the user session end message.\n     *\n     * @param admin which {@link DeviceAdminReceiver} this request is associated with.\n     * @throws SecurityException if {@code admin} is not a device owner.\n     ",
    "links" : [ "DeviceAdminReceiver" ]
  }, {
    "name" : "public int addOverrideApn(@NonNull ComponentName admin, @NonNull ApnSetting apnSetting)",
    "returnType" : "int",
    "comment" : "\n     * Called by device owner to add an override APN.\n     *\n     * <p>This method may returns {@code -1} if {@code apnSetting} conflicts with an existing\n     * override APN. Update the existing conflicted APN with\n     * {@link #updateOverrideApn(ComponentName, int, ApnSetting)} instead of adding a new entry.\n     * <p>Two override APNs are considered to conflict when all the following APIs return\n     * the same values on both override APNs:\n     * <ul>\n     *   <li>{@link ApnSetting#getOperatorNumeric()}</li>\n     *   <li>{@link ApnSetting#getApnName()}</li>\n     *   <li>{@link ApnSetting#getProxyAddressAsString()}</li>\n     *   <li>{@link ApnSetting#getProxyPort()}</li>\n     *   <li>{@link ApnSetting#getMmsProxyAddressAsString()}</li>\n     *   <li>{@link ApnSetting#getMmsProxyPort()}</li>\n     *   <li>{@link ApnSetting#getMmsc()}</li>\n     *   <li>{@link ApnSetting#isEnabled()}</li>\n     *   <li>{@link ApnSetting#getMvnoType()}</li>\n     *   <li>{@link ApnSetting#getProtocol()}</li>\n     *   <li>{@link ApnSetting#getRoamingProtocol()}</li>\n     * </ul>\n     *\n     * @param admin which {@link DeviceAdminReceiver} this request is associated with\n     * @param apnSetting the override APN to insert\n     * @return The {@code id} of inserted override APN. Or {@code -1} when failed to insert into\n     *         the database.\n     * @throws SecurityException if {@code admin} is not a device owner.\n     *\n     * @see #setOverrideApnsEnabled(ComponentName, boolean)\n     ",
    "links" : [ "#updateOverrideApn", "ApnSetting#getOperatorNumeric", "ApnSetting#getApnName", "ApnSetting#getProxyAddressAsString", "ApnSetting#getProxyPort", "ApnSetting#getMmsProxyAddressAsString", "ApnSetting#getMmsProxyPort", "ApnSetting#getMmsc", "ApnSetting#isEnabled", "ApnSetting#getMvnoType", "ApnSetting#getProtocol", "ApnSetting#getRoamingProtocol", "DeviceAdminReceiver" ]
  }, {
    "name" : "public boolean updateOverrideApn(@NonNull ComponentName admin, int apnId, @NonNull ApnSetting apnSetting)",
    "returnType" : "boolean",
    "comment" : "\n     * Called by device owner to update an override APN.\n     *\n     * <p>This method may returns {@code false} if there is no override APN with the given\n     * {@code apnId}.\n     * <p>This method may also returns {@code false} if {@code apnSetting} conflicts with an\n     * existing override APN. Update the existing conflicted APN instead.\n     * <p>See {@link #addOverrideApn} for the definition of conflict.\n     *\n     * @param admin which {@link DeviceAdminReceiver} this request is associated with\n     * @param apnId the {@code id} of the override APN to update\n     * @param apnSetting the override APN to update\n     * @return {@code true} if the required override APN is successfully updated,\n     *         {@code false} otherwise.\n     * @throws SecurityException if {@code admin} is not a device owner.\n     *\n     * @see #setOverrideApnsEnabled(ComponentName, boolean)\n     ",
    "links" : [ "#addOverrideApn", "DeviceAdminReceiver" ]
  }, {
    "name" : "public boolean removeOverrideApn(@NonNull ComponentName admin, int apnId)",
    "returnType" : "boolean",
    "comment" : "\n     * Called by device owner to remove an override APN.\n     *\n     * <p>This method may returns {@code false} if there is no override APN with the given\n     * {@code apnId}.\n     *\n     * @param admin which {@link DeviceAdminReceiver} this request is associated with\n     * @param apnId the {@code id} of the override APN to remove\n     * @return {@code true} if the required override APN is successfully removed, {@code false}\n     *         otherwise.\n     * @throws SecurityException if {@code admin} is not a device owner.\n     *\n     * @see #setOverrideApnsEnabled(ComponentName, boolean)\n     ",
    "links" : [ "DeviceAdminReceiver" ]
  }, {
    "name" : "public List<ApnSetting> getOverrideApns(@NonNull ComponentName admin)",
    "returnType" : "List<ApnSetting>",
    "comment" : "\n     * Called by device owner to get all override APNs inserted by device owner.\n     *\n     * @param admin which {@link DeviceAdminReceiver} this request is associated with\n     * @return A list of override APNs inserted by device owner.\n     * @throws SecurityException if {@code admin} is not a device owner.\n     *\n     * @see #setOverrideApnsEnabled(ComponentName, boolean)\n     ",
    "links" : [ "DeviceAdminReceiver" ]
  }, {
    "name" : "public void setOverrideApnsEnabled(@NonNull ComponentName admin, boolean enabled)",
    "returnType" : "void",
    "comment" : "\n     * Called by device owner to set if override APNs should be enabled.\n     * <p> Override APNs are separated from other APNs on the device, and can only be inserted or\n     * modified by the device owner. When enabled, only override APNs are in use, any other APNs\n     * are ignored.\n     *\n     * @param admin which {@link DeviceAdminReceiver} this request is associated with\n     * @param enabled {@code true} if override APNs should be enabled, {@code false} otherwise\n     * @throws SecurityException if {@code admin} is not a device owner.\n     ",
    "links" : [ "DeviceAdminReceiver" ]
  }, {
    "name" : "public boolean isOverrideApnEnabled(@NonNull ComponentName admin)",
    "returnType" : "boolean",
    "comment" : "\n     * Called by device owner to check if override APNs are currently enabled.\n     *\n     * @param admin which {@link DeviceAdminReceiver} this request is associated with\n     * @return {@code true} if override APNs are currently enabled, {@code false} otherwise.\n     * @throws SecurityException if {@code admin} is not a device owner.\n     *\n     * @see #setOverrideApnsEnabled(ComponentName, boolean)\n     ",
    "links" : [ "DeviceAdminReceiver" ]
  }, {
    "name" : "public PersistableBundle getTransferOwnershipBundle()",
    "returnType" : "PersistableBundle",
    "comment" : "\n     * Returns the data passed from the current administrator to the new administrator during an\n     * ownership transfer. This is the same {@code bundle} passed in\n     * {@link #transferOwnership(ComponentName, ComponentName, PersistableBundle)}. The bundle is\n     * persisted until the profile owner or device owner is removed.\n     *\n     * <p>This is the same <code>bundle</code> received in the\n     * {@link DeviceAdminReceiver#onTransferOwnershipComplete(Context, PersistableBundle)}.\n     * Use this method to retrieve it after the transfer as long as the new administrator is the\n     * active device or profile owner.\n     *\n     * <p>Returns <code>null</code> if no ownership transfer was started for the calling user.\n     *\n     * @see #transferOwnership\n     * @see DeviceAdminReceiver#onTransferOwnershipComplete(Context, PersistableBundle)\n     * @throws SecurityException if the caller is not a device or profile owner.\n     ",
    "links" : [ "#transferOwnership", "DeviceAdminReceiver#onTransferOwnershipComplete" ]
  }, {
    "name" : "public int setGlobalPrivateDnsModeOpportunistic(@NonNull ComponentName admin)",
    "returnType" : "int",
    "comment" : "\n     * Sets the global Private DNS mode to opportunistic.\n     * May only be called by the device owner.\n     *\n     * <p>In this mode, the DNS subsystem will attempt a TLS handshake to the network-supplied\n     * resolver prior to attempting name resolution in cleartext.\n     *\n     * @param admin which {@link DeviceAdminReceiver} this request is associated with.\n     *\n     * @return {@code PRIVATE_DNS_SET_NO_ERROR} if the mode was set successfully, or\n     *         {@code PRIVATE_DNS_SET_ERROR_FAILURE_SETTING} if it could not be set.\n     *\n     * @throws SecurityException if the caller is not the device owner.\n     ",
    "links" : [ "DeviceAdminReceiver" ]
  }, {
    "name" : "public int setGlobalPrivateDnsModeSpecifiedHost(@NonNull ComponentName admin, @NonNull String privateDnsHost)",
    "returnType" : "int",
    "comment" : "\n     * Sets the global Private DNS host to be used.\n     * May only be called by the device owner.\n     *\n     * <p>Note that the method is blocking as it will perform a connectivity check to the resolver,\n     * to ensure it is valid. Because of that, the method should not be called on any thread that\n     * relates to user interaction, such as the UI thread.\n     *\n     * <p>In case a VPN is used in conjunction with Private DNS resolver, the Private DNS resolver\n     * must be reachable both from within and outside the VPN. Otherwise, the device may lose\n     * the ability to resolve hostnames as system traffic to the resolver may not go through the\n     * VPN.\n     *\n     * @param admin which {@link DeviceAdminReceiver} this request is associated with.\n     * @param privateDnsHost The hostname of a server that implements DNS over TLS (RFC7858).\n     *\n     * @return {@code PRIVATE_DNS_SET_NO_ERROR} if the mode was set successfully,\n     *         {@code PRIVATE_DNS_SET_ERROR_FAILURE_SETTING} if it could not be set or\n     *         {@code PRIVATE_DNS_SET_ERROR_HOST_NOT_SERVING} if the specified host does not\n     *         implement RFC7858.\n     *\n     * @throws IllegalArgumentException if the {@code privateDnsHost} is not a valid hostname.\n     *\n     * @throws SecurityException if the caller is not the device owner.\n     ",
    "links" : [ "DeviceAdminReceiver" ]
  }, {
    "name" : "public void installSystemUpdate(@NonNull ComponentName admin, @NonNull Uri updateFilePath, @NonNull @CallbackExecutor Executor executor, @NonNull InstallSystemUpdateCallback callback)",
    "returnType" : "void",
    "comment" : "\n     * Called by device owner or profile owner of an organization-owned managed profile to install\n     * a system update from the given file. The device will be\n     * rebooted in order to finish installing the update. Note that if the device is rebooted, this\n     * doesn't necessarily mean that the update has been applied successfully. The caller should\n     * additionally check the system version with {@link android.os.Build#FINGERPRINT} or {@link\n     * android.os.Build.VERSION}. If an error occurs during processing the OTA before the reboot,\n     * the caller will be notified by {@link InstallSystemUpdateCallback}. If device does not have\n     * sufficient battery level, the installation will fail with error {@link\n     * InstallSystemUpdateCallback#UPDATE_ERROR_BATTERY_LOW}.\n     *\n     * @param admin The {@link DeviceAdminReceiver} that this request is associated with.\n     * @param updateFilePath An Uri of the file that contains the update. The file should be\n     * readable by the calling app.\n     * @param executor The executor through which the callback should be invoked.\n     * @param callback A callback object that will inform the caller when installing an update\n     * fails.\n     ",
    "links" : [ "android.os.Build#FINGERPRINT", "InstallSystemUpdateCallback", "DeviceAdminReceiver" ]
  }, {
    "name" : "private void executeCallback(int errorCode, String errorMessage, @NonNull @CallbackExecutor Executor executor, @NonNull InstallSystemUpdateCallback callback)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public int getGlobalPrivateDnsMode(@NonNull ComponentName admin)",
    "returnType" : "int",
    "comment" : "\n     * Returns the system-wide Private DNS mode.\n     *\n     * @param admin which {@link DeviceAdminReceiver} this request is associated with.\n     * @return one of {@code PRIVATE_DNS_MODE_OFF}, {@code PRIVATE_DNS_MODE_OPPORTUNISTIC},\n     * {@code PRIVATE_DNS_MODE_PROVIDER_HOSTNAME} or {@code PRIVATE_DNS_MODE_UNKNOWN}.\n     * @throws SecurityException if the caller is not the device owner.\n     ",
    "links" : [ "DeviceAdminReceiver" ]
  }, {
    "name" : "public String getGlobalPrivateDnsHost(@NonNull ComponentName admin)",
    "returnType" : "String",
    "comment" : "\n     * Returns the system-wide Private DNS host.\n     *\n     * @param admin which {@link DeviceAdminReceiver} this request is associated with.\n     * @return The hostname used for Private DNS queries, null if none is set.\n     * @throws SecurityException if the caller is not the device owner.\n     ",
    "links" : [ "DeviceAdminReceiver" ]
  }, {
    "name" : "public void setProfileOwnerCanAccessDeviceIds(@NonNull ComponentName who)",
    "returnType" : "void",
    "comment" : "\n     * Deprecated. Use {@code markProfileOwnerOnOrganizationOwnedDevice} instead.\n     * When called by an app targeting SDK level {@link android.os.Build.VERSION_CODES#Q} or\n     * below, will behave the same as {@link #markProfileOwnerOnOrganizationOwnedDevice}.\n     *\n     * When called by an app targeting SDK level {@link android.os.Build.VERSION_CODES#R}\n     * or above, will throw an UnsupportedOperationException when called.\n     *\n     * @deprecated Use {@link #markProfileOwnerOnOrganizationOwnedDevice} instead.\n     *\n     * @hide\n     ",
    "links" : [ "android.os.Build.VERSION_CODES#Q", "#markProfileOwnerOnOrganizationOwnedDevice", "android.os.Build.VERSION_CODES#R", "#markProfileOwnerOnOrganizationOwnedDevice" ]
  }, {
    "name" : "public void markProfileOwnerOnOrganizationOwnedDevice(@NonNull ComponentName who)",
    "returnType" : "void",
    "comment" : "\n     * Marks the profile owner of the given user as managing an organization-owned device.\n     * That will give it access to device identifiers (such as serial number, IMEI and MEID)\n     * as well as other privileges.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public void setCrossProfileCalendarPackages(@NonNull ComponentName admin, @Nullable Set<String> packageNames)",
    "returnType" : "void",
    "comment" : "\n     * Allows a set of packages to access cross-profile calendar APIs.\n     *\n     * <p>Called by a profile owner of a managed profile.\n     *\n     * <p>Calling with a {@code null} value for the set disables the restriction so that all\n     * packages are allowed to access cross-profile calendar APIs. Calling with an empty set\n     * disallows all packages from accessing cross-profile calendar APIs. If this method isn't\n     * called, no package is allowed to access cross-profile calendar APIs by default.\n     *\n     * @param admin which {@link DeviceAdminReceiver} this request is associated with\n     * @param packageNames set of packages to be whitelisted\n     * @throws SecurityException if {@code admin} is not a profile owner\n     *\n     * @see #getCrossProfileCalendarPackages(ComponentName)\n     ",
    "links" : [ "DeviceAdminReceiver" ]
  }, {
    "name" : "public Set<String> getCrossProfileCalendarPackages(@NonNull ComponentName admin)",
    "returnType" : "Set<String>",
    "comment" : "\n     * Gets a set of package names that are allowed to access cross-profile calendar APIs.\n     *\n     * <p>Called by a profile owner of a managed profile.\n     *\n     * @param admin which {@link DeviceAdminReceiver} this request is associated with\n     * @return the set of names of packages that were previously allowed via\n     * {@link #setCrossProfileCalendarPackages(ComponentName, Set)}, or an\n     * empty set if none have been allowed\n     * @throws SecurityException if {@code admin} is not a profile owner\n     *\n     * @see #setCrossProfileCalendarPackages(ComponentName, Set)\n     ",
    "links" : [ "DeviceAdminReceiver", "#setCrossProfileCalendarPackages" ]
  }, {
    "name" : "public boolean isPackageAllowedToAccessCalendar(@NonNull String packageName)",
    "returnType" : "boolean",
    "comment" : "\n     * Returns if a package is allowed to access cross-profile calendar APIs.\n     *\n     * <p>A package is allowed to access cross-profile calendar APIs if it's allowed by\n     * admins via {@link #setCrossProfileCalendarPackages(ComponentName, Set)} and\n     * {@link android.provider.Settings.Secure#CROSS_PROFILE_CALENDAR_ENABLED}\n     * is turned on in the managed profile.\n     *\n     * <p>To query for a specific user, use\n     * {@link Context#createPackageContextAsUser(String, int, UserHandle)} to create a context for\n     * that user, and get a {@link DevicePolicyManager} from this context.\n     *\n     * @param packageName the name of the package\n     * @return {@code true} if the package is allowed to access cross-profile calendar APIs,\n     * {@code false} otherwise\n     *\n     * @see #setCrossProfileCalendarPackages(ComponentName, Set)\n     * @see #getCrossProfileCalendarPackages(ComponentName)\n     * @hide\n     ",
    "links" : [ "#setCrossProfileCalendarPackages", "android.provider.Settings.Secure#CROSS_PROFILE_CALENDAR_ENABLED", "Context#createPackageContextAsUser", "DevicePolicyManager" ]
  }, {
    "name" : "public Set<String> getCrossProfileCalendarPackages()",
    "returnType" : "Set<String>",
    "comment" : "\n     * Gets a set of package names that are allowed to access cross-profile calendar APIs.\n     *\n     * <p>To query for a specific user, use\n     * {@link Context#createPackageContextAsUser(String, int, UserHandle)} to create a context for\n     * that user, and get a {@link DevicePolicyManager} from this context.\n     *\n     * @return the set of names of packages that were previously allowed via\n     * {@link #setCrossProfileCalendarPackages(ComponentName, Set)}, or an\n     * empty set if none have been allowed\n     *\n     * @see #setCrossProfileCalendarPackages(ComponentName, Set)\n     * @see #getCrossProfileCalendarPackages(ComponentName)\n     * @hide\n     ",
    "links" : [ "Context#createPackageContextAsUser", "DevicePolicyManager", "#setCrossProfileCalendarPackages" ]
  }, {
    "name" : "public void setCrossProfilePackages(@NonNull ComponentName admin, @NonNull Set<String> packageNames)",
    "returnType" : "void",
    "comment" : "\n     * Sets the set of admin-whitelisted package names that are allowed to request user consent for\n     * cross-profile communication.\n     *\n     * <p>Assumes that the caller is a profile owner and is the given {@code admin}.\n     *\n     * <p>Previous calls are overridden by each subsequent call to this method.\n     *\n     * <p>Note that other apps may be able to request user consent for cross-profile communication\n     * if they have been explicitly whitelisted by the OEM.\n     *\n     * <p>When previously-set cross-profile packages are missing from {@code packageNames}, the\n     * app-op for {@code INTERACT_ACROSS_PROFILES} will be reset for those packages. This will not\n     * occur for packages that are whitelisted by the OEM.\n     *\n     * @param admin the {@link DeviceAdminReceiver} this request is associated with\n     * @param packageNames the new cross-profile package names\n     ",
    "links" : [ "DeviceAdminReceiver" ]
  }, {
    "name" : "public Set<String> getCrossProfilePackages(@NonNull ComponentName admin)",
    "returnType" : "Set<String>",
    "comment" : "\n     * Returns the set of package names that the admin has previously set as allowed to request user\n     * consent for cross-profile communication, via {@link #setCrossProfilePackages(ComponentName,\n     * Set)}.\n     *\n     * <p>Assumes that the caller is a profile owner and is the given {@code admin}.\n     *\n     * <p>Note that other apps not included in the returned set may be able to request user consent\n     * for cross-profile communication if they have been explicitly whitelisted by the OEM.\n     *\n     * @param admin the {@link DeviceAdminReceiver} this request is associated with\n     * @return the set of package names the admin has previously set as allowed to request user\n     * consent for cross-profile communication, via {@link #setCrossProfilePackages(ComponentName,\n     * Set)}\n     ",
    "links" : [ "#setCrossProfilePackages", "DeviceAdminReceiver", "#setCrossProfilePackages" ]
  }, {
    "name" : "public Set<String> getAllCrossProfilePackages()",
    "returnType" : "Set<String>",
    "comment" : "\n     * Returns the combined set of the following:\n     * <ul>\n     * <li>The package names that the admin has previously set as allowed to request user consent\n     * for cross-profile communication, via {@link #setCrossProfilePackages(ComponentName,\n     * Set)}.</li>\n     * <li>The default package names set by the OEM that are allowed to request user consent for\n     * cross-profile communication without being explicitly enabled by the admin, via {@link\n     * com.android.internal.R.array#cross_profile_apps} and {@link com.android.internal.R.array\n     * #vendor_cross_profile_apps}.</li>\n     * </ul>\n     *\n     * @return the combined set of whitelisted package names set via\n     * {@link #setCrossProfilePackages(ComponentName, Set)}, {@link com.android.internal.R.array\n     * #cross_profile_apps}, and {@link com.android.internal.R.array#vendor_cross_profile_apps}.\n     *\n     * @hide\n     ",
    "links" : [ "#setCrossProfilePackages", "com.android.internal.R.array", "#setCrossProfilePackages", "com.android.internal.R.array", "com.android.internal.R.array#vendor_cross_profile_apps" ]
  }, {
    "name" : "public Set<String> getDefaultCrossProfilePackages()",
    "returnType" : "Set<String>",
    "comment" : "\n     * Returns the default package names set by the OEM that are allowed to request user consent for\n     * cross-profile communication without being explicitly enabled by the admin, via {@link\n     * com.android.internal.R.array#cross_profile_apps} and {@link com.android.internal.R.array\n     * #vendor_cross_profile_apps}.\n     *\n     * @hide\n     ",
    "links" : [ "com.android.internal.R.array" ]
  }, {
    "name" : "public boolean isManagedKiosk()",
    "returnType" : "boolean",
    "comment" : "\n     * Returns whether the device is being used as a managed kiosk. These requirements are as\n     * follows:\n     * <ul>\n     *     <li>The device is in Lock Task (therefore there is also a Device Owner app on the\n     *     device)</li>\n     *     <li>The Lock Task feature {@link DevicePolicyManager#LOCK_TASK_FEATURE_SYSTEM_INFO} is\n     *     not enabled, so the system info in the status bar is not visible</li>\n     *     <li>The device does not have a secure lock screen (e.g. it has no lock screen or has\n     *     swipe-to-unlock)</li>\n     *     <li>The device is not in the middle of an ephemeral user session</li>\n     * </ul>\n     *\n     * <p>Publicly-accessible dedicated devices don't have the same privacy model as\n     * personally-used devices. In particular, user consent popups don't make sense as a barrier to\n     * accessing persistent data on these devices since the user giving consent and the user whose\n     * data is on the device are unlikely to be the same. These consent popups prevent the true\n     * remote management of these devices.\n     *\n     * <p>This condition is not sufficient to cover APIs that would access data that only lives for\n     * the duration of the user's session, since the user has an expectation of privacy in these\n     * conditions that more closely resembles use of a personal device. In those cases, see {@link\n     * #isUnattendedManagedKiosk()}.\n     *\n     * @hide\n     ",
    "links" : [ "DevicePolicyManager#LOCK_TASK_FEATURE_SYSTEM_INFO" ]
  }, {
    "name" : "public boolean isUnattendedManagedKiosk()",
    "returnType" : "boolean",
    "comment" : "\n     * Returns whether the device is being used as an unattended managed kiosk. These requirements\n     * are as follows:\n     * <ul>\n     *     <li>The device is being used as a managed kiosk, as defined at {@link\n     *     #isManagedKiosk()}</li>\n     *     <li>The device has not received user input for at least 30 minutes</li>\n     * </ul>\n     *\n     * <p>See {@link #isManagedKiosk()} for context. This is a stronger requirement that also\n     * ensures that the device hasn't been interacted with recently, making it an appropriate check\n     * for privacy-sensitive APIs that wouldn't be appropriate during an active user session.\n     *\n     * @hide\n     ",
    "links" : [ "#isManagedKiosk" ]
  }, {
    "name" : "public boolean startViewCalendarEventInManagedProfile(long eventId, long start, long end, boolean allDay, int flags)",
    "returnType" : "boolean",
    "comment" : "\n     * Starts an activity to view calendar events in the managed profile.\n     *\n     * @param eventId the id of the event to be viewed\n     * @param start the start time of the event\n     * @param end the end time of the event\n     * @param allDay if the event is an all-day event\n     * @param flags flags to be set for the intent\n     * @return {@code true} if the activity is started successfully, {@code false} otherwise\n     *\n     * @see CalendarContract#startViewCalendarEventInManagedProfile(Context, String, long, long,\n     * long, boolean, int)\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public void setUserControlDisabledPackages(@NonNull ComponentName admin, @NonNull List<String> packages)",
    "returnType" : "void",
    "comment" : "\n     * Called by Device owner to disable user control over apps. User will not be able to clear\n     * app data or force-stop packages.\n     *\n     * @param admin which {@link DeviceAdminReceiver} this request is associated with\n     * @param packages The package names for the apps.\n     * @throws SecurityException if {@code admin} is not a device owner.\n     ",
    "links" : [ "DeviceAdminReceiver" ]
  }, {
    "name" : "public List<String> getUserControlDisabledPackages(@NonNull ComponentName admin)",
    "returnType" : "List<String>",
    "comment" : "\n     * Returns the list of packages over which user control is disabled by the device owner.\n     *\n     * @param admin which {@link DeviceAdminReceiver} this request is associated with\n     * @throws SecurityException if {@code admin} is not a device owner.\n     ",
    "links" : [ "DeviceAdminReceiver" ]
  }, {
    "name" : "public void setCommonCriteriaModeEnabled(@NonNull ComponentName admin, boolean enabled)",
    "returnType" : "void",
    "comment" : "\n     * Called by device owner or profile owner of an organization-owned managed profile to toggle\n     * Common Criteria mode for the device. When the device is in Common Criteria mode,\n     * certain device functionalities are tuned to meet the higher\n     * security level required by Common Criteria certification. For example:\n     * <ul>\n     * <li> Bluetooth long term key material is additionally integrity-protected with AES-GCM. </li>\n     * <li> WiFi configuration store is additionally integrity-protected with AES-GCM. </li>\n     * </ul>\n     * Common Criteria mode is disabled by default.\n     *\n     * @param admin which {@link DeviceAdminReceiver} this request is associated with.\n     * @param enabled whether Common Criteria mode should be enabled or not.\n     ",
    "links" : [ "DeviceAdminReceiver" ]
  }, {
    "name" : "public boolean isCommonCriteriaModeEnabled(@Nullable ComponentName admin)",
    "returnType" : "boolean",
    "comment" : "\n     * Returns whether Common Criteria mode is currently enabled. Device owner and profile owner of\n     * an organization-owned managed profile can query its own Common Criteria mode setting by\n     * calling this method with its admin {@link ComponentName}. Any caller can obtain the\n     * aggregated device-wide Common Criteria mode state by passing {@code null} as the\n     * {@code admin} argument.\n     *\n     * @param admin which {@link DeviceAdminReceiver} this request is associated with, or\n     *     {@code null} if the caller is not a device admin.\n     * @return {@code true} if Common Criteria mode is enabled, {@code false} otherwise.\n     ",
    "links" : [ "ComponentName", "DeviceAdminReceiver" ]
  }, {
    "name" : "public int getPersonalAppsSuspendedReasons(@NonNull ComponentName admin)",
    "returnType" : "int",
    "comment" : "\n     * Called by profile owner of an organization-owned managed profile to check whether\n     * personal apps are suspended.\n     *\n     * @return a bitmask of reasons for personal apps suspension or\n     *     {@link #PERSONAL_APPS_NOT_SUSPENDED} if apps are not suspended.\n     * @see #setPersonalAppsSuspended\n     ",
    "links" : [ "#PERSONAL_APPS_NOT_SUSPENDED" ]
  }, {
    "name" : "public void setPersonalAppsSuspended(@NonNull ComponentName admin, boolean suspended)",
    "returnType" : "void",
    "comment" : "\n     * Called by a profile owner of an organization-owned managed profile to suspend personal\n     * apps on the device. When personal apps are suspended the device can only be used for calls.\n     *\n     * <p>When personal apps are suspended, an ongoing notification about that is shown to the user.\n     * When the user taps the notification, system invokes {@link #ACTION_CHECK_POLICY_COMPLIANCE}\n     * in the profile owner package. Profile owner implementation that uses personal apps suspension\n     * must handle this intent.\n     *\n     * @param admin Which {@link DeviceAdminReceiver} this request is associated with\n     * @param suspended Whether personal apps should be suspended.\n     * @throws IllegalStateException if the profile owner doesn't have an activity that handles\n     *        {@link #ACTION_CHECK_POLICY_COMPLIANCE}\n     ",
    "links" : [ "#ACTION_CHECK_POLICY_COMPLIANCE", "DeviceAdminReceiver", "#ACTION_CHECK_POLICY_COMPLIANCE" ]
  }, {
    "name" : "public void setManagedProfileMaximumTimeOff(@NonNull ComponentName admin, long timeoutMillis)",
    "returnType" : "void",
    "comment" : "\n     * Called by a profile owner of an organization-owned managed profile to set maximum time\n     * the profile is allowed to be turned off. If the profile is turned off for longer, personal\n     * apps are suspended on the device.\n     *\n     * <p>When personal apps are suspended, an ongoing notification about that is shown to the user.\n     * When the user taps the notification, system invokes {@link #ACTION_CHECK_POLICY_COMPLIANCE}\n     * in the profile owner package. Profile owner implementation that uses personal apps suspension\n     * must handle this intent.\n     *\n     * @param admin Which {@link DeviceAdminReceiver} this request is associated with\n     * @param timeoutMillis Maximum time the profile is allowed to be off in milliseconds or 0 if\n     *        not limited. The minimum non-zero value corresponds to 72 hours. If an admin sets a\n     *        smaller non-zero vaulue, 72 hours will be set instead.\n     * @throws IllegalStateException if the profile owner doesn't have an activity that handles\n     *        {@link #ACTION_CHECK_POLICY_COMPLIANCE}\n     * @see #setPersonalAppsSuspended\n     ",
    "links" : [ "#ACTION_CHECK_POLICY_COMPLIANCE", "DeviceAdminReceiver", "#ACTION_CHECK_POLICY_COMPLIANCE" ]
  }, {
    "name" : "public long getManagedProfileMaximumTimeOff(@NonNull ComponentName admin)",
    "returnType" : "long",
    "comment" : "\n     * Called by a profile owner of an organization-owned managed profile to get maximum time\n     * the profile is allowed to be turned off.\n     *\n     * @param admin Which {@link DeviceAdminReceiver} this request is associated with\n     * @return Maximum time the profile is allowed to be off in milliseconds or 0 if not limited.\n     * @see #setPersonalAppsSuspended\n     ",
    "links" : [ "DeviceAdminReceiver" ]
  }, {
    "name" : "public boolean canProfileOwnerResetPasswordWhenLocked(int userId)",
    "returnType" : "boolean",
    "comment" : "\n     * Returns {@code true} when {@code userId} has a profile owner that is capable of resetting\n     * password in RUNNING_LOCKED state. For that it should have at least one direct boot aware\n     * component and have an active password reset token. Can only be called by the system.\n     * @hide\n     ",
    "links" : [ ]
  } ],
  "variableNames" : [ "TAG", "mContext", "mService", "mParentInstance", "ACTION_PROVISION_MANAGED_PROFILE", "ACTION_PROVISION_MANAGED_USER", "ACTION_PROVISION_MANAGED_DEVICE", "ACTION_STATE_USER_SETUP_COMPLETE", "ACTION_PROVISION_MANAGED_DEVICE_FROM_TRUSTED_SOURCE", "ACTION_PROVISION_FINANCED_DEVICE", "ACTION_PROVISION_MANAGED_SHAREABLE_DEVICE", "ACTION_PROVISION_FINALIZATION", "ACTION_BUGREPORT_SHARING_ACCEPTED", "ACTION_BUGREPORT_SHARING_DECLINED", "ACTION_REMOTE_BUGREPORT_DISPATCH", "EXTRA_REMOTE_BUGREPORT_HASH", "EXTRA_BUGREPORT_NOTIFICATION_TYPE", "NOTIFICATION_BUGREPORT_STARTED", "NOTIFICATION_BUGREPORT_ACCEPTED_NOT_FINISHED", "NOTIFICATION_BUGREPORT_FINISHED_NOT_ACCEPTED", "DEFAULT_STRONG_AUTH_TIMEOUT_MS", "EXTRA_PROVISIONING_ADMIN_EXTRAS_BUNDLE", "EXTRA_PROVISIONING_DEVICE_ADMIN_PACKAGE_NAME", "EXTRA_PROVISIONING_DEVICE_ADMIN_COMPONENT_NAME", "EXTRA_PROVISIONING_ACCOUNT_TO_MIGRATE", "EXTRA_PROVISIONING_KEEP_ACCOUNT_ON_MIGRATION", "EXTRA_PROVISIONING_EMAIL_ADDRESS", "EXTRA_PROVISIONING_MAIN_COLOR", "EXTRA_PROVISIONING_LEAVE_ALL_SYSTEM_APPS_ENABLED", "EXTRA_PROVISIONING_TIME_ZONE", "EXTRA_PROVISIONING_LOCAL_TIME", "EXTRA_PROVISIONING_LOCALE", "EXTRA_PROVISIONING_WIFI_SSID", "EXTRA_PROVISIONING_WIFI_HIDDEN", "EXTRA_PROVISIONING_WIFI_SECURITY_TYPE", "EXTRA_PROVISIONING_WIFI_PASSWORD", "EXTRA_PROVISIONING_WIFI_EAP_METHOD", "EXTRA_PROVISIONING_WIFI_PHASE2_AUTH", "EXTRA_PROVISIONING_WIFI_CA_CERTIFICATE", "EXTRA_PROVISIONING_WIFI_USER_CERTIFICATE", "EXTRA_PROVISIONING_WIFI_IDENTITY", "EXTRA_PROVISIONING_WIFI_ANONYMOUS_IDENTITY", "EXTRA_PROVISIONING_WIFI_DOMAIN", "EXTRA_PROVISIONING_WIFI_PROXY_HOST", "EXTRA_PROVISIONING_WIFI_PROXY_PORT", "EXTRA_PROVISIONING_WIFI_PROXY_BYPASS", "EXTRA_PROVISIONING_WIFI_PAC_URL", "EXTRA_PROVISIONING_DEVICE_ADMIN_PACKAGE_DOWNLOAD_LOCATION", "EXTRA_PROVISIONING_ORGANIZATION_NAME", "EXTRA_PROVISIONING_SUPPORT_URL", "EXTRA_PROVISIONING_DEVICE_ADMIN_PACKAGE_LABEL", "EXTRA_PROVISIONING_DEVICE_ADMIN_PACKAGE_ICON_URI", "EXTRA_PROVISIONING_DEVICE_ADMIN_MINIMUM_VERSION_CODE", "EXTRA_PROVISIONING_DEVICE_ADMIN_PACKAGE_DOWNLOAD_COOKIE_HEADER", "EXTRA_PROVISIONING_DEVICE_ADMIN_PACKAGE_CHECKSUM", "EXTRA_PROVISIONING_DEVICE_ADMIN_SIGNATURE_CHECKSUM", "ACTION_MANAGED_PROFILE_PROVISIONED", "ACTION_PROVISIONING_SUCCESSFUL", "EXTRA_PROVISIONING_SKIP_ENCRYPTION", "EXTRA_PROVISIONING_LOGO_URI", "EXTRA_PROVISIONING_DISCLAIMERS", "EXTRA_PROVISIONING_DISCLAIMER_HEADER", "EXTRA_PROVISIONING_DISCLAIMER_CONTENT", "EXTRA_PROVISIONING_SKIP_USER_SETUP", "EXTRA_PROVISIONING_SKIP_USER_CONSENT", "EXTRA_PROVISIONING_SKIP_EDUCATION_SCREENS", "EXTRA_PROVISIONING_USE_MOBILE_DATA", "EXTRA_PROVISIONING_TRIGGER", "PROVISIONING_TRIGGER_UNSPECIFIED", "PROVISIONING_TRIGGER_CLOUD_ENROLLMENT", "PROVISIONING_TRIGGER_QR_CODE", "PROVISIONING_TRIGGER_PERSISTENT_DEVICE_OWNER", "MIME_TYPE_PROVISIONING_NFC", "ACTION_ADD_DEVICE_ADMIN", "ACTION_SET_PROFILE_OWNER", "EXTRA_PROFILE_OWNER_NAME", "ACTION_DEVICE_POLICY_MANAGER_STATE_CHANGED", "ACTION_DEVICE_OWNER_CHANGED", "ACTION_RESET_PROTECTION_POLICY_CHANGED", "EXTRA_DEVICE_ADMIN", "EXTRA_ADD_EXPLANATION", "POLICY_DISABLE_CAMERA", "POLICY_DISABLE_SCREEN_CAPTURE", "POLICY_SUSPEND_PACKAGES", "EXTRA_RESTRICTION", "ACTION_SET_NEW_PASSWORD", "EXTRA_PASSWORD_COMPLEXITY", "PASSWORD_COMPLEXITY_NONE", "PASSWORD_COMPLEXITY_LOW", "PASSWORD_COMPLEXITY_MEDIUM", "PASSWORD_COMPLEXITY_HIGH", "ACTION_SET_NEW_PARENT_PROFILE_PASSWORD", "ACTION_SHOW_DEVICE_MONITORING_DIALOG", "ACTION_APPLICATION_DELEGATION_SCOPES_CHANGED", "EXTRA_DELEGATION_SCOPES", "FLAG_PARENT_CAN_ACCESS_MANAGED", "FLAG_MANAGED_CAN_ACCESS_PARENT", "ACTION_SYSTEM_UPDATE_POLICY_CHANGED", "ACTION_DATA_SHARING_RESTRICTION_CHANGED", "ACTION_DATA_SHARING_RESTRICTION_APPLIED", "PERMISSION_POLICY_PROMPT", "PERMISSION_POLICY_AUTO_GRANT", "PERMISSION_POLICY_AUTO_DENY", "PERMISSION_GRANT_STATE_DEFAULT", "PERMISSION_GRANT_STATE_GRANTED", "PERMISSION_GRANT_STATE_DENIED", "DELEGATION_CERT_INSTALL", "DELEGATION_APP_RESTRICTIONS", "DELEGATION_BLOCK_UNINSTALL", "DELEGATION_PERMISSION_GRANT", "DELEGATION_PACKAGE_ACCESS", "DELEGATION_ENABLE_SYSTEM_APP", "DELEGATION_INSTALL_EXISTING_PACKAGE", "DELEGATION_KEEP_UNINSTALLED_PACKAGES", "DELEGATION_NETWORK_LOGGING", "DELEGATION_CERT_SELECTION", "STATE_USER_UNMANAGED", "STATE_USER_SETUP_INCOMPLETE", "STATE_USER_SETUP_COMPLETE", "STATE_USER_SETUP_FINALIZED", "STATE_USER_PROFILE_COMPLETE", "CODE_OK", "CODE_HAS_DEVICE_OWNER", "CODE_USER_HAS_PROFILE_OWNER", "CODE_USER_NOT_RUNNING", "CODE_USER_SETUP_COMPLETED", "CODE_NONSYSTEM_USER_EXISTS", "CODE_ACCOUNTS_NOT_EMPTY", "CODE_NOT_SYSTEM_USER", "CODE_HAS_PAIRED", "CODE_MANAGED_USERS_NOT_SUPPORTED", "CODE_SYSTEM_USER", "CODE_CANNOT_ADD_MANAGED_PROFILE", "CODE_NOT_SYSTEM_USER_SPLIT", "CODE_DEVICE_ADMIN_NOT_SUPPORTED", "CODE_SPLIT_SYSTEM_USER_DEVICE_SYSTEM_USER", "LOCK_TASK_FEATURE_NONE", "LOCK_TASK_FEATURE_SYSTEM_INFO", "LOCK_TASK_FEATURE_NOTIFICATIONS", "LOCK_TASK_FEATURE_HOME", "LOCK_TASK_FEATURE_OVERVIEW", "LOCK_TASK_FEATURE_GLOBAL_ACTIONS", "LOCK_TASK_FEATURE_KEYGUARD", "LOCK_TASK_FEATURE_BLOCK_ACTIVITY_START_IN_TASK", "ACTION_DEVICE_ADMIN_SERVICE", "ID_TYPE_BASE_INFO", "ID_TYPE_SERIAL", "ID_TYPE_IMEI", "ID_TYPE_MEID", "ID_TYPE_INDIVIDUAL_ATTESTATION", "KEY_GEN_STRONGBOX_UNAVAILABLE", "INSTALLKEY_REQUEST_CREDENTIALS_ACCESS", "INSTALLKEY_SET_USER_SELECTABLE", "ACTION_PROFILE_OWNER_CHANGED", "PRIVATE_DNS_MODE_UNKNOWN", "PRIVATE_DNS_MODE_OFF", "PRIVATE_DNS_MODE_OPPORTUNISTIC", "PRIVATE_DNS_MODE_PROVIDER_HOSTNAME", "PRIVATE_DNS_SET_NO_ERROR", "PRIVATE_DNS_SET_ERROR_HOST_NOT_SERVING", "PRIVATE_DNS_SET_ERROR_FAILURE_SETTING", "ACTION_GET_PROVISIONING_MODE", "EXTRA_PROVISIONING_IMEI", "EXTRA_PROVISIONING_SERIAL_NUMBER", "EXTRA_PROVISIONING_MODE", "PROVISIONING_MODE_FULLY_MANAGED_DEVICE", "PROVISIONING_MODE_MANAGED_PROFILE", "ACTION_ADMIN_POLICY_COMPLIANCE", "MAX_PASSWORD_LENGTH", "ACTION_BIND_SECONDARY_LOCKSCREEN_SERVICE", "PERSONAL_APPS_NOT_SUSPENDED", "PERSONAL_APPS_SUSPENDED_EXPLICITLY", "PERSONAL_APPS_SUSPENDED_PROFILE_TIMEOUT", "PASSWORD_QUALITY_UNSPECIFIED", "PASSWORD_QUALITY_BIOMETRIC_WEAK", "PASSWORD_QUALITY_SOMETHING", "PASSWORD_QUALITY_NUMERIC", "PASSWORD_QUALITY_NUMERIC_COMPLEX", "PASSWORD_QUALITY_ALPHABETIC", "PASSWORD_QUALITY_ALPHANUMERIC", "PASSWORD_QUALITY_COMPLEX", "PASSWORD_QUALITY_MANAGED", "ACCOUNT_FEATURE_DEVICE_OR_PROFILE_OWNER_ALLOWED", "ACCOUNT_FEATURE_DEVICE_OR_PROFILE_OWNER_DISALLOWED", "RESET_PASSWORD_REQUIRE_ENTRY", "RESET_PASSWORD_DO_NOT_ASK_CREDENTIALS_ON_BOOT", "FLAG_EVICT_CREDENTIAL_ENCRYPTION_KEY", "WIPE_EXTERNAL_STORAGE", "WIPE_RESET_PROTECTION_DATA", "WIPE_EUICC", "WIPE_SILENTLY", "ENCRYPTION_STATUS_UNSUPPORTED", "ENCRYPTION_STATUS_INACTIVE", "ENCRYPTION_STATUS_ACTIVATING", "ENCRYPTION_STATUS_ACTIVE", "ENCRYPTION_STATUS_ACTIVE_DEFAULT_KEY", "ENCRYPTION_STATUS_ACTIVE_PER_USER", "ACTION_START_ENCRYPTION", "ACTION_CHECK_POLICY_COMPLIANCE", "ACTION_MANAGED_USER_CREATED", "KEYGUARD_DISABLE_FEATURES_NONE", "KEYGUARD_DISABLE_WIDGETS_ALL", "KEYGUARD_DISABLE_SECURE_CAMERA", "KEYGUARD_DISABLE_SECURE_NOTIFICATIONS", "KEYGUARD_DISABLE_UNREDACTED_NOTIFICATIONS", "KEYGUARD_DISABLE_TRUST_AGENTS", "KEYGUARD_DISABLE_FINGERPRINT", "KEYGUARD_DISABLE_REMOTE_INPUT", "KEYGUARD_DISABLE_FACE", "KEYGUARD_DISABLE_IRIS", "KEYGUARD_DISABLE_BIOMETRICS", "KEYGUARD_DISABLE_FEATURES_ALL", "NON_ORG_OWNED_PROFILE_KEYGUARD_FEATURES_AFFECT_OWNER", "ORG_OWNED_PROFILE_KEYGUARD_FEATURES_PARENT_ONLY", "PROFILE_KEYGUARD_FEATURES_AFFECT_OWNER", "ERROR_VPN_PACKAGE_NOT_FOUND", "SKIP_SETUP_WIZARD", "MAKE_USER_EPHEMERAL", "MAKE_USER_DEMO", "LEAVE_ALL_SYSTEM_APPS_ENABLED" ],
  "methodNames" : [ "protected int myUserId()", "public boolean isAdminActive(@NonNull ComponentName admin)", "public boolean isAdminActiveAsUser(@NonNull ComponentName admin, int userId)", "public boolean isRemovingAdmin(@NonNull ComponentName admin, int userId)", "public List<ComponentName> getActiveAdmins()", "public List<ComponentName> getActiveAdminsAsUser(int userId)", "public boolean packageHasActiveAdmins(String packageName)", "public boolean packageHasActiveAdmins(String packageName, int userId)", "public void removeActiveAdmin(@NonNull ComponentName admin)", "public boolean hasGrantedPolicy(@NonNull ComponentName admin, int usesPolicy)", "public boolean isSeparateProfileChallengeAllowed(int userHandle)", "public void setPasswordQuality(@NonNull ComponentName admin, int quality)", "public int getPasswordQuality(@Nullable ComponentName admin)", "public int getPasswordQuality(@Nullable ComponentName admin, int userHandle)", "public void setPasswordMinimumLength(@NonNull ComponentName admin, int length)", "public int getPasswordMinimumLength(@Nullable ComponentName admin)", "public int getPasswordMinimumLength(@Nullable ComponentName admin, int userHandle)", "public void setPasswordMinimumUpperCase(@NonNull ComponentName admin, int length)", "public int getPasswordMinimumUpperCase(@Nullable ComponentName admin)", "public int getPasswordMinimumUpperCase(@Nullable ComponentName admin, int userHandle)", "public void setPasswordMinimumLowerCase(@NonNull ComponentName admin, int length)", "public int getPasswordMinimumLowerCase(@Nullable ComponentName admin)", "public int getPasswordMinimumLowerCase(@Nullable ComponentName admin, int userHandle)", "public void setPasswordMinimumLetters(@NonNull ComponentName admin, int length)", "public int getPasswordMinimumLetters(@Nullable ComponentName admin)", "public int getPasswordMinimumLetters(@Nullable ComponentName admin, int userHandle)", "public void setPasswordMinimumNumeric(@NonNull ComponentName admin, int length)", "public int getPasswordMinimumNumeric(@Nullable ComponentName admin)", "public int getPasswordMinimumNumeric(@Nullable ComponentName admin, int userHandle)", "public void setPasswordMinimumSymbols(@NonNull ComponentName admin, int length)", "public int getPasswordMinimumSymbols(@Nullable ComponentName admin)", "public int getPasswordMinimumSymbols(@Nullable ComponentName admin, int userHandle)", "public void setPasswordMinimumNonLetter(@NonNull ComponentName admin, int length)", "public int getPasswordMinimumNonLetter(@Nullable ComponentName admin)", "public int getPasswordMinimumNonLetter(@Nullable ComponentName admin, int userHandle)", "public PasswordMetrics getPasswordMinimumMetrics(@UserIdInt int userHandle)", "public void setPasswordHistoryLength(@NonNull ComponentName admin, int length)", "public void setPasswordExpirationTimeout(@NonNull ComponentName admin, long timeout)", "public long getPasswordExpirationTimeout(@Nullable ComponentName admin)", "public long getPasswordExpiration(@Nullable ComponentName admin)", "public int getPasswordHistoryLength(@Nullable ComponentName admin)", "public int getPasswordHistoryLength(@Nullable ComponentName admin, int userHandle)", "public int getPasswordMaximumLength(int quality)", "public boolean isActivePasswordSufficient()", "public int getPasswordComplexity()", "public boolean isUsingUnifiedPassword(@NonNull ComponentName admin)", "public boolean isProfileActivePasswordSufficientForParent(int userHandle)", "public boolean isPasswordSufficientAfterProfileUnification(int userHandle, int profileUser)", "public int getCurrentFailedPasswordAttempts()", "public int getCurrentFailedPasswordAttempts(int userHandle)", "public boolean getDoNotAskCredentialsOnBoot()", "public void setMaximumFailedPasswordsForWipe(@NonNull ComponentName admin, int num)", "public int getMaximumFailedPasswordsForWipe(@Nullable ComponentName admin)", "public int getMaximumFailedPasswordsForWipe(@Nullable ComponentName admin, int userHandle)", "public int getProfileWithMinimumFailedPasswordsForWipe(int userHandle)", "public boolean resetPassword(String password, int flags)", "public boolean setResetPasswordToken(ComponentName admin, byte[] token)", "public boolean clearResetPasswordToken(ComponentName admin)", "public boolean isResetPasswordTokenActive(ComponentName admin)", "public boolean resetPasswordWithToken(@NonNull ComponentName admin, String password, byte[] token, int flags)", "public void setMaximumTimeToLock(@NonNull ComponentName admin, long timeMs)", "public long getMaximumTimeToLock(@Nullable ComponentName admin)", "public long getMaximumTimeToLock(@Nullable ComponentName admin, int userHandle)", "public void setRequiredStrongAuthTimeout(@NonNull ComponentName admin, long timeoutMs)", "public long getRequiredStrongAuthTimeout(@Nullable ComponentName admin)", "public long getRequiredStrongAuthTimeout(@Nullable ComponentName admin, @UserIdInt int userId)", "public void lockNow()", "public void lockNow(@LockNowFlag int flags)", "public void wipeData(int flags)", "public void wipeData(int flags, @NonNull CharSequence reason)", "private void wipeDataInternal(int flags, @NonNull String wipeReasonForUser)", "public void setFactoryResetProtectionPolicy(@NonNull ComponentName admin, @Nullable FactoryResetProtectionPolicy policy)", "public FactoryResetProtectionPolicy getFactoryResetProtectionPolicy(@Nullable ComponentName admin)", "public ComponentName setGlobalProxy(@NonNull ComponentName admin, Proxy proxySpec, List<String> exclusionList)", "public void setRecommendedGlobalProxy(@NonNull ComponentName admin, @Nullable ProxyInfo proxyInfo)", "public ComponentName getGlobalProxyAdmin()", "public int setStorageEncryption(@NonNull ComponentName admin, boolean encrypt)", "public boolean getStorageEncryption(@Nullable ComponentName admin)", "public int getStorageEncryptionStatus()", "public int getStorageEncryptionStatus(int userHandle)", "public boolean approveCaCert(String alias, int userHandle, boolean approval)", "public boolean isCaCertApproved(String alias, int userHandle)", "public boolean installCaCert(@Nullable ComponentName admin, byte[] certBuffer)", "public void uninstallCaCert(@Nullable ComponentName admin, byte[] certBuffer)", "public List<byte[]> getInstalledCaCerts(@Nullable ComponentName admin)", "public void uninstallAllUserCaCerts(@Nullable ComponentName admin)", "public boolean hasCaCertInstalled(@Nullable ComponentName admin, byte[] certBuffer)", "public boolean installKeyPair(@Nullable ComponentName admin, @NonNull PrivateKey privKey, @NonNull Certificate cert, @NonNull String alias)", "public boolean installKeyPair(@Nullable ComponentName admin, @NonNull PrivateKey privKey, @NonNull Certificate[] certs, @NonNull String alias, boolean requestAccess)", "public boolean installKeyPair(@Nullable ComponentName admin, @NonNull PrivateKey privKey, @NonNull Certificate[] certs, @NonNull String alias, int flags)", "public boolean removeKeyPair(@Nullable ComponentName admin, @NonNull String alias)", "public AttestedKeyPair generateKeyPair(@Nullable ComponentName admin, @NonNull String algorithm, @NonNull KeyGenParameterSpec keySpec, @AttestationIdType int idAttestationFlags)", "public boolean grantKeyPairToApp(@Nullable ComponentName admin, @NonNull String alias, @NonNull String packageName)", "public boolean revokeKeyPairFromApp(@Nullable ComponentName admin, @NonNull String alias, @NonNull String packageName)", "public boolean isDeviceIdAttestationSupported()", "public boolean isUniqueDeviceAttestationSupported()", "public boolean setKeyPairCertificate(@Nullable ComponentName admin, @NonNull String alias, @NonNull List<Certificate> certs, boolean isUserSelectable)", "private static String getCaCertAlias(byte[] certBuffer) throws CertificateException", "public void setCertInstallerPackage(@NonNull ComponentName admin, @Nullable String installerPackage) throws SecurityException", "public String getCertInstallerPackage(@NonNull ComponentName admin) throws SecurityException", "public void setDelegatedScopes(@NonNull ComponentName admin, @NonNull String delegatePackage, @NonNull List<String> scopes)", "public List<String> getDelegatedScopes(@Nullable ComponentName admin, @NonNull String delegatedPackage)", "public List<String> getDelegatePackages(@NonNull ComponentName admin, @NonNull String delegationScope)", "public void setAlwaysOnVpnPackage(@NonNull ComponentName admin, @Nullable String vpnPackage, boolean lockdownEnabled) throws NameNotFoundException", "public void setAlwaysOnVpnPackage(@NonNull ComponentName admin, @Nullable String vpnPackage, boolean lockdownEnabled, @Nullable Set<String> lockdownWhitelist) throws NameNotFoundException", "public boolean isAlwaysOnVpnLockdownEnabled(@NonNull ComponentName admin)", "public boolean isAlwaysOnVpnLockdownEnabled()", "public Set<String> getAlwaysOnVpnLockdownWhitelist(@NonNull ComponentName admin)", "public String getAlwaysOnVpnPackage(@NonNull ComponentName admin)", "public String getAlwaysOnVpnPackage()", "public void setCameraDisabled(@NonNull ComponentName admin, boolean disabled)", "public boolean getCameraDisabled(@Nullable ComponentName admin)", "public boolean getCameraDisabled(@Nullable ComponentName admin, int userHandle)", "public boolean requestBugreport(@NonNull ComponentName admin)", "public boolean getGuestUserDisabled(@Nullable ComponentName admin)", "public void setScreenCaptureDisabled(@NonNull ComponentName admin, boolean disabled)", "public boolean getScreenCaptureDisabled(@Nullable ComponentName admin)", "public boolean getScreenCaptureDisabled(@Nullable ComponentName admin, int userHandle)", "public void setAutoTimeRequired(@NonNull ComponentName admin, boolean required)", "public boolean getAutoTimeRequired()", "public void setAutoTimeEnabled(@NonNull ComponentName admin, boolean enabled)", "public boolean getAutoTimeEnabled(@NonNull ComponentName admin)", "public void setAutoTimeZoneEnabled(@NonNull ComponentName admin, boolean enabled)", "public boolean getAutoTimeZoneEnabled(@NonNull ComponentName admin)", "public void setForceEphemeralUsers(@NonNull ComponentName admin, boolean forceEphemeralUsers)", "public boolean getForceEphemeralUsers(@NonNull ComponentName admin)", "public void setKeyguardDisabledFeatures(@NonNull ComponentName admin, int which)", "public int getKeyguardDisabledFeatures(@Nullable ComponentName admin)", "public int getKeyguardDisabledFeatures(@Nullable ComponentName admin, int userHandle)", "public void setActiveAdmin(@NonNull ComponentName policyReceiver, boolean refreshing, int userHandle)", "public void setActiveAdmin(@NonNull ComponentName policyReceiver, boolean refreshing)", "public void getRemoveWarning(@Nullable ComponentName admin, RemoteCallback result)", "public void reportPasswordChanged(@UserIdInt int userId)", "public void reportFailedPasswordAttempt(int userHandle)", "public void reportSuccessfulPasswordAttempt(int userHandle)", "public void reportFailedBiometricAttempt(int userHandle)", "public void reportSuccessfulBiometricAttempt(int userHandle)", "public void reportKeyguardDismissed(int userHandle)", "public void reportKeyguardSecured(int userHandle)", "public boolean setDeviceOwner(ComponentName who)", "public boolean setDeviceOwner(ComponentName who, int userId)", "public boolean setDeviceOwner(ComponentName who, String ownerName)", "public boolean setDeviceOwner(ComponentName who, String ownerName, int userId) throws IllegalArgumentException, IllegalStateException", "public boolean isDeviceOwnerApp(String packageName)", "public boolean isDeviceOwnerAppOnCallingUser(String packageName)", "public boolean isDeviceOwnerAppOnAnyUser(String packageName)", "public ComponentName getDeviceOwnerComponentOnCallingUser()", "public ComponentName getDeviceOwnerComponentOnAnyUser()", "private boolean isDeviceOwnerAppOnAnyUserInner(String packageName, boolean callingUserOnly)", "private ComponentName getDeviceOwnerComponentInner(boolean callingUserOnly)", "public UserHandle getDeviceOwnerUser()", "public int getDeviceOwnerUserId()", "public void clearDeviceOwnerApp(String packageName)", "public String getDeviceOwner()", "public boolean isDeviceManaged()", "public String getDeviceOwnerNameOnAnyUser()", "public boolean setActiveProfileOwner(@NonNull ComponentName admin, @Deprecated String ownerName) throws IllegalArgumentException", "public void clearProfileOwner(@NonNull ComponentName admin)", "public boolean hasUserSetupCompleted()", "public boolean setProfileOwner(@NonNull ComponentName admin, @Deprecated String ownerName, int userHandle) throws IllegalArgumentException", "public void setDeviceOwnerLockScreenInfo(@NonNull ComponentName admin, CharSequence info)", "public CharSequence getDeviceOwnerLockScreenInfo()", "public String[] setPackagesSuspended(@NonNull ComponentName admin, @NonNull String[] packageNames, boolean suspended)", "public boolean isPackageSuspended(@NonNull ComponentName admin, String packageName) throws NameNotFoundException", "public void setProfileEnabled(@NonNull ComponentName admin)", "public void setProfileName(@NonNull ComponentName admin, String profileName)", "public boolean isProfileOwnerApp(String packageName)", "public ComponentName getProfileOwner() throws IllegalArgumentException", "public ComponentName getProfileOwnerAsUser(@NonNull UserHandle user)", "public ComponentName getProfileOwnerAsUser(final int userId)", "public ComponentName getProfileOwnerOrDeviceOwnerSupervisionComponent(@NonNull UserHandle user)", "public String getProfileOwnerName() throws IllegalArgumentException", "public String getProfileOwnerNameAsUser(int userId) throws IllegalArgumentException", "public boolean isOrganizationOwnedDeviceWithManagedProfile()", "public boolean hasDeviceIdentifierAccess(@NonNull String packageName, int pid, int uid)", "public void addPersistentPreferredActivity(@NonNull ComponentName admin, IntentFilter filter, @NonNull ComponentName activity)", "public void clearPackagePersistentPreferredActivities(@NonNull ComponentName admin, String packageName)", "public void setDefaultSmsApplication(@NonNull ComponentName admin, @NonNull String packageName)", "public void setApplicationRestrictionsManagingPackage(@NonNull ComponentName admin, @Nullable String packageName) throws NameNotFoundException", "public String getApplicationRestrictionsManagingPackage(@NonNull ComponentName admin)", "public boolean isCallerApplicationRestrictionsManagingPackage()", "public void setApplicationRestrictions(@Nullable ComponentName admin, String packageName, Bundle settings)", "public void setTrustAgentConfiguration(@NonNull ComponentName admin, @NonNull ComponentName target, PersistableBundle configuration)", "public List<PersistableBundle> getTrustAgentConfiguration(@Nullable ComponentName admin, @NonNull ComponentName agent)", "public List<PersistableBundle> getTrustAgentConfiguration(@Nullable ComponentName admin, @NonNull ComponentName agent, int userHandle)", "public void setCrossProfileCallerIdDisabled(@NonNull ComponentName admin, boolean disabled)", "public boolean getCrossProfileCallerIdDisabled(@NonNull ComponentName admin)", "public boolean getCrossProfileCallerIdDisabled(UserHandle userHandle)", "public void setCrossProfileContactsSearchDisabled(@NonNull ComponentName admin, boolean disabled)", "public boolean getCrossProfileContactsSearchDisabled(@NonNull ComponentName admin)", "public boolean getCrossProfileContactsSearchDisabled(@NonNull UserHandle userHandle)", "public void startManagedQuickContact(String actualLookupKey, long actualContactId, boolean isContactIdIgnored, long directoryId, Intent originalIntent)", "public void startManagedQuickContact(String actualLookupKey, long actualContactId, Intent originalIntent)", "public void setBluetoothContactSharingDisabled(@NonNull ComponentName admin, boolean disabled)", "public boolean getBluetoothContactSharingDisabled(@NonNull ComponentName admin)", "public boolean getBluetoothContactSharingDisabled(@NonNull UserHandle userHandle)", "public void addCrossProfileIntentFilter(@NonNull ComponentName admin, IntentFilter filter, int flags)", "public void clearCrossProfileIntentFilters(@NonNull ComponentName admin)", "public boolean setPermittedAccessibilityServices(@NonNull ComponentName admin, List<String> packageNames)", "public List<String> getPermittedAccessibilityServices(@NonNull ComponentName admin)", "public boolean isAccessibilityServicePermittedByAdmin(@NonNull ComponentName admin, @NonNull String packageName, int userHandle)", "public List<String> getPermittedAccessibilityServices(int userId)", "public boolean setPermittedInputMethods(@NonNull ComponentName admin, List<String> packageNames)", "public List<String> getPermittedInputMethods(@NonNull ComponentName admin)", "public boolean isInputMethodPermittedByAdmin(@NonNull ComponentName admin, @NonNull String packageName, int userHandle)", "public List<String> getPermittedInputMethodsForCurrentUser()", "public boolean setPermittedCrossProfileNotificationListeners(@NonNull ComponentName admin, @Nullable List<String> packageList)", "public List<String> getPermittedCrossProfileNotificationListeners(@NonNull ComponentName admin)", "public boolean isNotificationListenerServicePermitted(@NonNull String packageName, @UserIdInt int userId)", "public List<String> getKeepUninstalledPackages(@Nullable ComponentName admin)", "public void setKeepUninstalledPackages(@Nullable ComponentName admin, @NonNull List<String> packageNames)", "public UserHandle createAndManageUser(@NonNull ComponentName admin, @NonNull String name, @NonNull ComponentName profileOwner, @Nullable PersistableBundle adminExtras, @CreateAndManageUserFlags int flags)", "public boolean removeUser(@NonNull ComponentName admin, @NonNull UserHandle userHandle)", "public boolean switchUser(@NonNull ComponentName admin, @Nullable UserHandle userHandle)", "public int startUserInBackground(@NonNull ComponentName admin, @NonNull UserHandle userHandle)", "public int stopUser(@NonNull ComponentName admin, @NonNull UserHandle userHandle)", "public int logoutUser(@NonNull ComponentName admin)", "public List<UserHandle> getSecondaryUsers(@NonNull ComponentName admin)", "public boolean isEphemeralUser(@NonNull ComponentName admin)", "public Bundle getApplicationRestrictions(@Nullable ComponentName admin, String packageName)", "public void addUserRestriction(@NonNull ComponentName admin, @UserManager.UserRestrictionKey String key)", "public void clearUserRestriction(@NonNull ComponentName admin, @UserManager.UserRestrictionKey String key)", "public Bundle getUserRestrictions(@NonNull ComponentName admin)", "public Intent createAdminSupportIntent(@NonNull String restriction)", "public boolean setApplicationHidden(@NonNull ComponentName admin, String packageName, boolean hidden)", "public boolean isApplicationHidden(@NonNull ComponentName admin, String packageName)", "public void enableSystemApp(@NonNull ComponentName admin, String packageName)", "public int enableSystemApp(@NonNull ComponentName admin, Intent intent)", "public boolean installExistingPackage(@NonNull ComponentName admin, String packageName)", "public void setAccountManagementDisabled(@NonNull ComponentName admin, String accountType, boolean disabled)", "public String[] getAccountTypesWithManagementDisabled()", "public String[] getAccountTypesWithManagementDisabledAsUser(int userId)", "public String[] getAccountTypesWithManagementDisabledAsUser(int userId, boolean parentInstance)", "public void setSecondaryLockscreenEnabled(@NonNull ComponentName admin, boolean enabled)", "public boolean isSecondaryLockscreenEnabled(@NonNull UserHandle userHandle)", "public void setLockTaskPackages(@NonNull ComponentName admin, @NonNull String[] packages) throws SecurityException", "public String[] getLockTaskPackages(@NonNull ComponentName admin)", "public boolean isLockTaskPermitted(String pkg)", "public void setLockTaskFeatures(@NonNull ComponentName admin, @LockTaskFeature int flags)", "public int getLockTaskFeatures(@NonNull ComponentName admin)", "public void setGlobalSetting(@NonNull ComponentName admin, String setting, String value)", "public void setSystemSetting(@NonNull ComponentName admin, @NonNull @SystemSettingsWhitelist String setting, String value)", "public void setConfiguredNetworksLockdownState(@NonNull ComponentName admin, boolean lockdown)", "public boolean hasLockdownAdminConfiguredNetworks(@NonNull ComponentName admin)", "public boolean setTime(@NonNull ComponentName admin, long millis)", "public boolean setTimeZone(@NonNull ComponentName admin, String timeZone)", "public void setLocationEnabled(@NonNull ComponentName admin, boolean locationEnabled)", "public void setSecureSetting(@NonNull ComponentName admin, String setting, String value)", "public void setRestrictionsProvider(@NonNull ComponentName admin, @Nullable ComponentName provider)", "public void setMasterVolumeMuted(@NonNull ComponentName admin, boolean on)", "public boolean isMasterVolumeMuted(@NonNull ComponentName admin)", "public void setUninstallBlocked(@Nullable ComponentName admin, String packageName, boolean uninstallBlocked)", "public boolean isUninstallBlocked(@Nullable ComponentName admin, String packageName)", "public boolean addCrossProfileWidgetProvider(@NonNull ComponentName admin, String packageName)", "public boolean removeCrossProfileWidgetProvider(@NonNull ComponentName admin, String packageName)", "public List<String> getCrossProfileWidgetProviders(@NonNull ComponentName admin)", "public void setUserIcon(@NonNull ComponentName admin, Bitmap icon)", "public void setSystemUpdatePolicy(@NonNull ComponentName admin, SystemUpdatePolicy policy)", "public SystemUpdatePolicy getSystemUpdatePolicy()", "public void clearSystemUpdatePolicyFreezePeriodRecord()", "public boolean setKeyguardDisabled(@NonNull ComponentName admin, boolean disabled)", "public boolean setStatusBarDisabled(@NonNull ComponentName admin, boolean disabled)", "public void notifyPendingSystemUpdate(long updateReceivedTime)", "public void notifyPendingSystemUpdate(long updateReceivedTime, boolean isSecurityPatch)", "public SystemUpdateInfo getPendingSystemUpdate(@NonNull ComponentName admin)", "public void setPermissionPolicy(@NonNull ComponentName admin, int policy)", "public int getPermissionPolicy(ComponentName admin)", "public boolean setPermissionGrantState(@NonNull ComponentName admin, @NonNull String packageName, @NonNull String permission, @PermissionGrantState int grantState)", "public int getPermissionGrantState(@Nullable ComponentName admin, @NonNull String packageName, @NonNull String permission)", "public boolean isProvisioningAllowed(@NonNull String action)", "public int checkProvisioningPreCondition(String action, @NonNull String packageName)", "public boolean isManagedProfile(@NonNull ComponentName admin)", "public boolean isSystemOnlyUser(@NonNull ComponentName admin)", "public String getWifiMacAddress(@NonNull ComponentName admin)", "public void reboot(@NonNull ComponentName admin)", "public void setShortSupportMessage(@NonNull ComponentName admin, @Nullable CharSequence message)", "public CharSequence getShortSupportMessage(@NonNull ComponentName admin)", "public void setLongSupportMessage(@NonNull ComponentName admin, @Nullable CharSequence message)", "public CharSequence getLongSupportMessage(@NonNull ComponentName admin)", "public CharSequence getShortSupportMessageForUser(@NonNull ComponentName admin, int userHandle)", "public CharSequence getLongSupportMessageForUser(@NonNull ComponentName admin, int userHandle)", "public DevicePolicyManager getParentProfileInstance(@NonNull ComponentName admin)", "public void setSecurityLoggingEnabled(@NonNull ComponentName admin, boolean enabled)", "public boolean isSecurityLoggingEnabled(@Nullable ComponentName admin)", "public List<SecurityEvent> retrieveSecurityLogs(@NonNull ComponentName admin)", "public long forceNetworkLogs()", "public long forceSecurityLogs()", "public DevicePolicyManager getParentProfileInstance(UserInfo uInfo)", "public List<String> setMeteredDataDisabledPackages(@NonNull ComponentName admin, @NonNull List<String> packageNames)", "public List<String> getMeteredDataDisabledPackages(@NonNull ComponentName admin)", "public boolean isMeteredDataDisabledPackageForUser(@NonNull ComponentName admin, String packageName, @UserIdInt int userId)", "public List<SecurityEvent> retrievePreRebootSecurityLogs(@NonNull ComponentName admin)", "public void setOrganizationColor(@NonNull ComponentName admin, int color)", "public void setOrganizationColorForUser(@ColorInt int color, @UserIdInt int userId)", "public int getOrganizationColor(@NonNull ComponentName admin)", "public int getOrganizationColorForUser(int userHandle)", "public void setOrganizationName(@NonNull ComponentName admin, @Nullable CharSequence title)", "public CharSequence getOrganizationName(@NonNull ComponentName admin)", "public CharSequence getDeviceOwnerOrganizationName()", "public CharSequence getOrganizationNameForUser(int userHandle)", "public int getUserProvisioningState()", "public void setUserProvisioningState(@UserProvisioningState int state, int userHandle)", "public void setAffiliationIds(@NonNull ComponentName admin, @NonNull Set<String> ids)", "public Set<String> getAffiliationIds(@NonNull ComponentName admin)", "public boolean isAffiliatedUser()", "public boolean isUninstallInQueue(String packageName)", "public void uninstallPackageWithActiveAdmins(String packageName)", "public void forceRemoveActiveAdmin(ComponentName adminReceiver, int userHandle)", "public boolean isDeviceProvisioned()", "public void setDeviceProvisioningConfigApplied()", "public boolean isDeviceProvisioningConfigApplied()", "public void forceUpdateUserSetupComplete()", "private void throwIfParentInstance(String functionName)", "public void setBackupServiceEnabled(@NonNull ComponentName admin, boolean enabled)", "public boolean isBackupServiceEnabled(@NonNull ComponentName admin)", "public void setNetworkLoggingEnabled(@Nullable ComponentName admin, boolean enabled)", "public boolean isNetworkLoggingEnabled(@Nullable ComponentName admin)", "public List<NetworkEvent> retrieveNetworkLogs(@Nullable ComponentName admin, long batchToken)", "public boolean bindDeviceAdminServiceAsUser(@NonNull ComponentName admin, Intent serviceIntent, @NonNull ServiceConnection conn, @Context.BindServiceFlags int flags, @NonNull UserHandle targetUser)", "public List<UserHandle> getBindDeviceAdminTargetUsers(@NonNull ComponentName admin)", "public long getLastSecurityLogRetrievalTime()", "public long getLastBugReportRequestTime()", "public long getLastNetworkLogRetrievalTime()", "public boolean isCurrentInputMethodSetByOwner()", "public List<String> getOwnerInstalledCaCerts(@NonNull UserHandle user)", "public boolean isFactoryResetProtectionPolicySupported()", "public void clearApplicationUserData(@NonNull ComponentName admin, @NonNull String packageName, @NonNull @CallbackExecutor Executor executor, @NonNull OnClearApplicationUserDataListener listener)", "public void setLogoutEnabled(@NonNull ComponentName admin, boolean enabled)", "public boolean isLogoutEnabled()", "public Set<String> getDisallowedSystemApps(ComponentName admin, int userId, String provisioningAction)", "public void transferOwnership(@NonNull ComponentName admin, @NonNull ComponentName target, @Nullable PersistableBundle bundle)", "public void setStartUserSessionMessage(@NonNull ComponentName admin, @Nullable CharSequence startUserSessionMessage)", "public void setEndUserSessionMessage(@NonNull ComponentName admin, @Nullable CharSequence endUserSessionMessage)", "public CharSequence getStartUserSessionMessage(@NonNull ComponentName admin)", "public CharSequence getEndUserSessionMessage(@NonNull ComponentName admin)", "public int addOverrideApn(@NonNull ComponentName admin, @NonNull ApnSetting apnSetting)", "public boolean updateOverrideApn(@NonNull ComponentName admin, int apnId, @NonNull ApnSetting apnSetting)", "public boolean removeOverrideApn(@NonNull ComponentName admin, int apnId)", "public List<ApnSetting> getOverrideApns(@NonNull ComponentName admin)", "public void setOverrideApnsEnabled(@NonNull ComponentName admin, boolean enabled)", "public boolean isOverrideApnEnabled(@NonNull ComponentName admin)", "public PersistableBundle getTransferOwnershipBundle()", "public int setGlobalPrivateDnsModeOpportunistic(@NonNull ComponentName admin)", "public int setGlobalPrivateDnsModeSpecifiedHost(@NonNull ComponentName admin, @NonNull String privateDnsHost)", "public void installSystemUpdate(@NonNull ComponentName admin, @NonNull Uri updateFilePath, @NonNull @CallbackExecutor Executor executor, @NonNull InstallSystemUpdateCallback callback)", "private void executeCallback(int errorCode, String errorMessage, @NonNull @CallbackExecutor Executor executor, @NonNull InstallSystemUpdateCallback callback)", "public int getGlobalPrivateDnsMode(@NonNull ComponentName admin)", "public String getGlobalPrivateDnsHost(@NonNull ComponentName admin)", "public void setProfileOwnerCanAccessDeviceIds(@NonNull ComponentName who)", "public void markProfileOwnerOnOrganizationOwnedDevice(@NonNull ComponentName who)", "public void setCrossProfileCalendarPackages(@NonNull ComponentName admin, @Nullable Set<String> packageNames)", "public Set<String> getCrossProfileCalendarPackages(@NonNull ComponentName admin)", "public boolean isPackageAllowedToAccessCalendar(@NonNull String packageName)", "public Set<String> getCrossProfileCalendarPackages()", "public void setCrossProfilePackages(@NonNull ComponentName admin, @NonNull Set<String> packageNames)", "public Set<String> getCrossProfilePackages(@NonNull ComponentName admin)", "public Set<String> getAllCrossProfilePackages()", "public Set<String> getDefaultCrossProfilePackages()", "public boolean isManagedKiosk()", "public boolean isUnattendedManagedKiosk()", "public boolean startViewCalendarEventInManagedProfile(long eventId, long start, long end, boolean allDay, int flags)", "public void setUserControlDisabledPackages(@NonNull ComponentName admin, @NonNull List<String> packages)", "public List<String> getUserControlDisabledPackages(@NonNull ComponentName admin)", "public void setCommonCriteriaModeEnabled(@NonNull ComponentName admin, boolean enabled)", "public boolean isCommonCriteriaModeEnabled(@Nullable ComponentName admin)", "public int getPersonalAppsSuspendedReasons(@NonNull ComponentName admin)", "public void setPersonalAppsSuspended(@NonNull ComponentName admin, boolean suspended)", "public void setManagedProfileMaximumTimeOff(@NonNull ComponentName admin, long timeoutMillis)", "public long getManagedProfileMaximumTimeOff(@NonNull ComponentName admin)", "public boolean canProfileOwnerResetPasswordWhenLocked(int userId)" ]
}