{
  "filePath" : "/home/maryam/clearblue/files/android-source-35/org/apache/xml/dtm/ref/DTMDocumentImpl.java",
  "packageName" : "org.apache.xml.dtm.ref",
  "className" : "DTMDocumentImpl",
  "comment" : "\n * This is the implementation of the DTM document interface.  It receives\n * requests from an XML content handler similar to that of an XML DOM or SAX parser\n * to store information from the xml document in an array based\n * dtm table structure.  This informtion is used later for document navigation,\n * query, and SAX event dispatch functions. The DTM can also be used directly as a\n * document composition model for an application.  The requests received are:\n * <ul>\n * <li>initiating DTM to set the doc handle</li>\n * <li>resetting DTM for data structure reuse</li>\n * <li>hinting the end of document to adjust the end of data structure pointers</li>\n * <li>createnodes (element, comment, text, attribute, ....)</li>\n * <li>hinting the end of an element to patch parent and siblings<li>\n * <li>setting application provided symbol name stringpool data structures</li>\n * </ul>\n * <p>State: In progress!!</p>\n *\n * %REVIEW% I _think_ the SAX convention is that \"no namespace\" is expressed\n * as \"\" rather than as null (which is the DOM's convention). What should\n * DTM expect? What should it do with the other?\n *\n * <p>Origin: the implemention is a composite logic based on the DTM of XalanJ1 and\n *     DocImpl, DocumentImpl, ElementImpl, TextImpl, etc. of XalanJ2</p>\n ",
  "links" : [ ],
  "variables" : [ {
    "name" : "DOCHANDLE_SHIFT",
    "type" : "byte",
    "comment" : " Number of lower bits used to represent node index.",
    "links" : [ ]
  }, {
    "name" : "NODEHANDLE_MASK",
    "type" : "int",
    "comment" : " Same as {@link DTMConstructor.IDENT_NODE_DEFAULT}",
    "links" : [ "DTMConstructor.IDENT_NODE_DEFAULT" ]
  }, {
    "name" : "DOCHANDLE_MASK",
    "type" : "int",
    "comment" : " Same as {@link DTMConstructor.IDENT_DOC_DEFAULT}",
    "links" : [ "DTMConstructor.IDENT_DOC_DEFAULT" ]
  }, {
    "name" : "m_docHandle",
    "type" : "int",
    "comment" : " masked document handle for this dtm document",
    "links" : [ ]
  }, {
    "name" : "m_docElement",
    "type" : "int",
    "comment" : " nodeHandle to the root of the actual dtm doc content",
    "links" : [ ]
  }, {
    "name" : "currentParent",
    "type" : "int",
    "comment" : " current parent - default is document root",
    "links" : [ ]
  }, {
    "name" : "previousSibling",
    "type" : "int",
    "comment" : " previous sibling - no previous sibling",
    "links" : [ ]
  }, {
    "name" : "m_currentNode",
    "type" : "int",
    "comment" : " current node",
    "links" : [ ]
  }, {
    "name" : "previousSiblingWasParent",
    "type" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "gotslot",
    "type" : "int[]",
    "comment" : " Local cache for record-at-a-time fetch",
    "links" : [ ]
  }, {
    "name" : "done",
    "type" : "boolean",
    "comment" : " endDocument recieved?",
    "links" : [ ]
  }, {
    "name" : "m_isError",
    "type" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "DEBUG",
    "type" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "m_documentBaseURI",
    "type" : "String",
    "comment" : " The document base URI. ",
    "links" : [ ]
  }, {
    "name" : "m_incrSAXSource",
    "type" : "IncrementalSAXSource",
    "comment" : " If we're building the model incrementally on demand, we need to\n   * be able to tell the source when to send us more data.\n   *\n   * Note that if this has not been set, and you attempt to read ahead\n   * of the current build point, we'll probably throw a null-pointer\n   * exception. We could try to wait-and-retry instead, as a very poor\n   * fallback, but that has all the known problems with multithreading\n   * on multiprocessors and we Don't Want to Go There.\n   *\n   * @see setIncrementalSAXSource\n   ",
    "links" : [ ]
  }, {
    "name" : "nodes",
    "type" : "ChunkedIntArray",
    "comment" : " ({@link DOCHANDLE_SHIFT} bits).",
    "links" : [ "DOCHANDLE_SHIFT" ]
  }, {
    "name" : "m_char",
    "type" : "FastStringBuffer",
    "comment" : " each of which is addressed by the absolute offset and length in the buffer",
    "links" : [ ]
  }, {
    "name" : "m_char_current_start",
    "type" : "int",
    "comment" : " needed because the string may be appended in several chunks.",
    "links" : [ ]
  }, {
    "name" : "m_localNames",
    "type" : "DTMStringPool",
    "comment" : " probably not the right default.",
    "links" : [ ]
  }, {
    "name" : "m_nsNames",
    "type" : "DTMStringPool",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "m_prefixNames",
    "type" : "DTMStringPool",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "m_expandedNames",
    "type" : "ExpandedNameTable",
    "comment" : " an interface _implemented_ by this class... which might be simplest!",
    "links" : [ ]
  }, {
    "name" : "m_xsf",
    "type" : "XMLStringFactory",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "fixednames",
    "type" : "String[]",
    "comment" : "\n         * fixednames\n        ",
    "links" : [ ]
  } ],
  "methods" : [ {
    "name" : "public void setIncrementalSAXSource(IncrementalSAXSource source)",
    "returnType" : "void",
    "comment" : " Bind a IncrementalSAXSource to this DTM. If we discover we need nodes\n   * that have not yet been built, we will ask this object to send us more\n   * events, and it will manage interactions with its data sources.\n   *\n   * Note that we do not actually build the IncrementalSAXSource, since we don't\n   * know what source it's reading from, what thread that source will run in,\n   * or when it will run.\n   *\n   * @param source The IncrementalSAXSource that we want to recieve events from\n   * on demand.\n   ",
    "links" : [ ]
  }, {
    "name" : "private final int appendNode(int w0, int w1, int w2, int w3)",
    "returnType" : "int",
    "comment" : "\n         * Wrapper for ChunkedIntArray.append, to automatically update the\n         * previous sibling's \"next\" reference (if necessary) and periodically\n         * wake a reader who may have encountered incomplete data and entered\n         * a wait state.\n         * @param w0 int As in ChunkedIntArray.append\n         * @param w1 int As in ChunkedIntArray.append\n         * @param w2 int As in ChunkedIntArray.append\n         * @param w3 int As in ChunkedIntArray.append\n         * @return int As in ChunkedIntArray.append\n         * @see ChunkedIntArray.append\n         ",
    "links" : [ ]
  }, {
    "name" : "public void setFeature(String featureId, boolean state)",
    "returnType" : "void",
    "comment" : "\n         * Set an implementation dependent feature.\n         * <p>\n         * %REVIEW% Do we really expect to set features on DTMs?\n         *\n         * @param featureId A feature URL.\n         * @param state true if this feature should be on, false otherwise.\n         ",
    "links" : [ ]
  }, {
    "name" : "public void setLocalNameTable(DTMStringPool poolRef)",
    "returnType" : "void",
    "comment" : "\n         * Set a reference pointer to the element name symbol table.\n         * %REVIEW% Should this really be Public? Changing it while\n         * DTM is in use would be a disaster.\n         *\n         * @param poolRef DTMStringPool reference to an instance of table.\n         ",
    "links" : [ ]
  }, {
    "name" : "public DTMStringPool getLocalNameTable()",
    "returnType" : "DTMStringPool",
    "comment" : "\n         * Get a reference pointer to the element name symbol table.\n         *\n         * @return DTMStringPool reference to an instance of table.\n         ",
    "links" : [ ]
  }, {
    "name" : "public void setNsNameTable(DTMStringPool poolRef)",
    "returnType" : "void",
    "comment" : "\n         * Set a reference pointer to the namespace URI symbol table.\n         * %REVIEW% Should this really be Public? Changing it while\n         * DTM is in use would be a disaster.\n         *\n         * @param poolRef DTMStringPool reference to an instance of table.\n         ",
    "links" : [ ]
  }, {
    "name" : "public DTMStringPool getNsNameTable()",
    "returnType" : "DTMStringPool",
    "comment" : "\n         * Get a reference pointer to the namespace URI symbol table.\n         *\n         * @return DTMStringPool reference to an instance of table.\n         ",
    "links" : [ ]
  }, {
    "name" : "public void setPrefixNameTable(DTMStringPool poolRef)",
    "returnType" : "void",
    "comment" : "\n         * Set a reference pointer to the prefix name symbol table.\n         * %REVIEW% Should this really be Public? Changing it while\n         * DTM is in use would be a disaster.\n         *\n         * @param poolRef DTMStringPool reference to an instance of table.\n         ",
    "links" : [ ]
  }, {
    "name" : "public DTMStringPool getPrefixNameTable()",
    "returnType" : "DTMStringPool",
    "comment" : "\n         * Get a reference pointer to the prefix name symbol table.\n         *\n         * @return DTMStringPool reference to an instance of table.\n         ",
    "links" : [ ]
  }, {
    "name" : " void setContentBuffer(FastStringBuffer buffer)",
    "returnType" : "void",
    "comment" : "\n          * Set a reference pointer to the content-text repository\n          *\n          * @param buffer FastStringBuffer reference to an instance of\n          * buffer\n          ",
    "links" : [ ]
  }, {
    "name" : " FastStringBuffer getContentBuffer()",
    "returnType" : "FastStringBuffer",
    "comment" : "\n          * Get a reference pointer to the content-text repository\n          *\n          * @return FastStringBuffer reference to an instance of buffer\n          ",
    "links" : [ ]
  }, {
    "name" : "public org.xml.sax.ContentHandler getContentHandler()",
    "returnType" : "org.xml.sax.ContentHandler",
    "comment" : " getContentHandler returns \"our SAX builder\" -- the thing that\n   * someone else should send SAX events to in order to extend this\n   * DTM model.\n   *\n   * @return null if this model doesn't respond to SAX events,\n   * \"this\" if the DTM object has a built-in SAX ContentHandler,\n   * the IncrementalSAXSource if we're bound to one and should receive\n   * the SAX stream via it for incremental build purposes...\n   * ",
    "links" : [ ]
  }, {
    "name" : "public LexicalHandler getLexicalHandler()",
    "returnType" : "LexicalHandler",
    "comment" : "\n   * Return this DTM's lexical handler.\n   *\n   * %REVIEW% Should this return null if constrution already done/begun?\n   *\n   * @return null if this model doesn't respond to lexical SAX events,\n   * \"this\" if the DTM object has a built-in SAX ContentHandler,\n   * the IncrementalSAXSource if we're bound to one and should receive\n   * the SAX stream via it for incremental build purposes...\n   ",
    "links" : [ ]
  }, {
    "name" : "public org.xml.sax.EntityResolver getEntityResolver()",
    "returnType" : "org.xml.sax.EntityResolver",
    "comment" : "\n   * Return this DTM's EntityResolver.\n   *\n   * @return null if this model doesn't respond to SAX entity ref events.\n   ",
    "links" : [ ]
  }, {
    "name" : "public org.xml.sax.DTDHandler getDTDHandler()",
    "returnType" : "org.xml.sax.DTDHandler",
    "comment" : "\n   * Return this DTM's DTDHandler.\n   *\n   * @return null if this model doesn't respond to SAX dtd events.\n   ",
    "links" : [ ]
  }, {
    "name" : "public org.xml.sax.ErrorHandler getErrorHandler()",
    "returnType" : "org.xml.sax.ErrorHandler",
    "comment" : "\n   * Return this DTM's ErrorHandler.\n   *\n   * @return null if this model doesn't respond to SAX error events.\n   ",
    "links" : [ ]
  }, {
    "name" : "public org.xml.sax.ext.DeclHandler getDeclHandler()",
    "returnType" : "org.xml.sax.ext.DeclHandler",
    "comment" : "\n   * Return this DTM's DeclHandler.\n   *\n   * @return null if this model doesn't respond to SAX Decl events.\n   ",
    "links" : [ ]
  }, {
    "name" : "public boolean needsTwoThreads()",
    "returnType" : "boolean",
    "comment" : " @return true iff we're building this model incrementally (eg\n   * we're partnered with a IncrementalSAXSource) and thus require that the\n   * transformation and the parse run simultaneously. Guidance to the\n   * DTMManager.\n   * ",
    "links" : [ ]
  }, {
    "name" : "public void characters(char[] ch, int start, int length) throws org.xml.sax.SAXException",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private void processAccumulatedText()",
    "returnType" : "void",
    "comment" : " Flush string accumulation into a text node",
    "links" : [ ]
  }, {
    "name" : "public void endDocument() throws org.xml.sax.SAXException",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public void endElement(java.lang.String namespaceURI, java.lang.String localName, java.lang.String qName) throws org.xml.sax.SAXException",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public void endPrefixMapping(java.lang.String prefix) throws org.xml.sax.SAXException",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public void ignorableWhitespace(char[] ch, int start, int length) throws org.xml.sax.SAXException",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public void processingInstruction(java.lang.String target, java.lang.String data) throws org.xml.sax.SAXException",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public void setDocumentLocator(Locator locator)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public void skippedEntity(java.lang.String name) throws org.xml.sax.SAXException",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public void startDocument() throws org.xml.sax.SAXException",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public void startElement(java.lang.String namespaceURI, java.lang.String localName, java.lang.String qName, Attributes atts) throws org.xml.sax.SAXException",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public void startPrefixMapping(java.lang.String prefix, java.lang.String uri) throws org.xml.sax.SAXException",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public void comment(char[] ch, int start, int length) throws org.xml.sax.SAXException",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public void endCDATA() throws org.xml.sax.SAXException",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public void endDTD() throws org.xml.sax.SAXException",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public void endEntity(java.lang.String name) throws org.xml.sax.SAXException",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public void startCDATA() throws org.xml.sax.SAXException",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public void startDTD(java.lang.String name, java.lang.String publicId, java.lang.String systemId) throws org.xml.sax.SAXException",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public void startEntity(java.lang.String name) throws org.xml.sax.SAXException",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : " final void initDocument(int documentNumber)",
    "returnType" : "void",
    "comment" : "\n         * Reset a dtm document to its initial (empty) state.\n         *\n         * The DTMManager will invoke this method when the dtm is created.\n         *\n         * @param documentNumber the handle for the DTM document.\n         ",
    "links" : [ ]
  }, {
    "name" : "public boolean hasChildNodes(int nodeHandle)",
    "returnType" : "boolean",
    "comment" : " Given a node handle, test if it has child nodes.\n         * <p> %REVIEW% This is obviously useful at the DOM layer, where it\n         * would permit testing this without having to create a proxy\n         * node. It's less useful in the DTM API, where\n         * (dtm.getFirstChild(nodeHandle)!=DTM.NULL) is just as fast and\n         * almost as self-evident. But it's a convenience, and eases porting\n         * of DOM code to DTM.  </p>\n         *\n         * @param nodeHandle int Handle of the node.\n         * @return int true if the given node has child nodes.\n         ",
    "links" : [ ]
  }, {
    "name" : "public int getFirstChild(int nodeHandle)",
    "returnType" : "int",
    "comment" : "\n         * Given a node handle, get the handle of the node's first child.\n         * If not yet resolved, waits for more nodes to be added to the document and\n         * tries again.\n         *\n         * @param nodeHandle int Handle of the node.\n         * @return int DTM node-number of first child, or DTM.NULL to indicate none exists.\n         ",
    "links" : [ ]
  }, {
    "name" : "public int getLastChild(int nodeHandle)",
    "returnType" : "int",
    "comment" : "\n        * Given a node handle, advance to its last child.\n        * If not yet resolved, waits for more nodes to be added to the document and\n        * tries again.\n        *\n        * @param nodeHandle int Handle of the node.\n        * @return int Node-number of last child,\n        * or DTM.NULL to indicate none exists.\n        ",
    "links" : [ ]
  }, {
    "name" : "public int getAttributeNode(int nodeHandle, String namespaceURI, String name)",
    "returnType" : "int",
    "comment" : "\n         * Retrieves an attribute node by by qualified name and namespace URI.\n         *\n         * @param nodeHandle int Handle of the node upon which to look up this attribute.\n         * @param namespaceURI The namespace URI of the attribute to\n         *   retrieve, or null.\n         * @param name The local name of the attribute to\n         *   retrieve.\n         * @return The attribute node handle with the specified name (\n         *   <code>nodeName</code>) or <code>DTM.NULL</code> if there is no such\n         *   attribute.\n         ",
    "links" : [ ]
  }, {
    "name" : "public int getFirstAttribute(int nodeHandle)",
    "returnType" : "int",
    "comment" : "\n         * Given a node handle, get the index of the node's first attribute.\n         *\n         * @param nodeHandle int Handle of the Element node.\n         * @return Handle of first attribute, or DTM.NULL to indicate none exists.\n         ",
    "links" : [ ]
  }, {
    "name" : "public int getFirstNamespaceNode(int nodeHandle, boolean inScope)",
    "returnType" : "int",
    "comment" : "\n         * Given a node handle, get the index of the node's first child.\n         * If not yet resolved, waits for more nodes to be added to the document and\n         * tries again\n         *\n         * @param nodeHandle handle to node, which should probably be an element\n         *                   node, but need not be.\n         *\n         * @param inScope    true if all namespaces in scope should be returned,\n         *                   false if only the namespace declarations should be\n         *                   returned.\n         * @return handle of first namespace, or DTM.NULL to indicate none exists.\n         ",
    "links" : [ ]
  }, {
    "name" : "public int getNextSibling(int nodeHandle)",
    "returnType" : "int",
    "comment" : "\n         * Given a node handle, advance to its next sibling.\n         *\n         * %TBD% This currently uses the DTM-internal definition of\n         * sibling; eg, the last attr's next sib is the first\n         * child. In the old DTM, the DOM proxy layer provided the\n         * additional logic for the public view.  If we're rewriting\n         * for XPath emulation, that test must be done here.\n         *\n         * %TBD% CODE INTERACTION WITH INCREMENTAL PARSE - If not yet\n         * resolved, should wait for more nodes to be added to the document\n         * and tries again.\n         *\n         * @param nodeHandle int Handle of the node.\n         * @return int Node-number of next sibling,\n         * or DTM.NULL to indicate none exists.\n         * ",
    "links" : [ ]
  }, {
    "name" : "public int getPreviousSibling(int nodeHandle)",
    "returnType" : "int",
    "comment" : "\n         * Given a node handle, find its preceeding sibling.\n         * WARNING: DTM is asymmetric; this operation is resolved by search, and is\n         * relatively expensive.\n         *\n         * @param nodeHandle the id of the node.\n         * @return int Node-number of the previous sib,\n         * or DTM.NULL to indicate none exists.\n         ",
    "links" : [ ]
  }, {
    "name" : "public int getNextAttribute(int nodeHandle)",
    "returnType" : "int",
    "comment" : "\n         * Given a node handle, advance to the next attribute. If an\n         * element, we advance to its first attribute; if an attr, we advance to\n         * the next attr on the same node.\n         *\n         * @param nodeHandle int Handle of the node.\n         * @return int DTM node-number of the resolved attr,\n         * or DTM.NULL to indicate none exists.\n         ",
    "links" : [ ]
  }, {
    "name" : "public int getNextNamespaceNode(int baseHandle, int namespaceHandle, boolean inScope)",
    "returnType" : "int",
    "comment" : "\n         * Given a namespace handle, advance to the next namespace.\n         *\n         * %TBD% THIS METHOD DOES NOT MATCH THE CURRENT SIGNATURE IN\n         * THE DTM INTERFACE.  FIX IT, OR JUSTIFY CHANGING THE DTM\n         * API.\n         *\n         * @param namespaceHandle handle to node which must be of type NAMESPACE_NODE.\n         * @return handle of next namespace, or DTM.NULL to indicate none exists.\n         ",
    "links" : [ ]
  }, {
    "name" : "public int getNextDescendant(int subtreeRootHandle, int nodeHandle)",
    "returnType" : "int",
    "comment" : "\n         * Given a node handle, advance to its next descendant.\n         * If not yet resolved, waits for more nodes to be added to the document and\n         * tries again.\n         *\n         * @param subtreeRootHandle\n         * @param nodeHandle int Handle of the node.\n         * @return handle of next descendant,\n         * or DTM.NULL to indicate none exists.\n         ",
    "links" : [ ]
  }, {
    "name" : "public int getNextFollowing(int axisContextHandle, int nodeHandle)",
    "returnType" : "int",
    "comment" : "\n         * Given a node handle, advance to the next node on the following axis.\n         *\n         * @param axisContextHandle the start of the axis that is being traversed.\n         * @param nodeHandle\n         * @return handle of next sibling,\n         * or DTM.NULL to indicate none exists.\n         ",
    "links" : [ ]
  }, {
    "name" : "public int getNextPreceding(int axisContextHandle, int nodeHandle)",
    "returnType" : "int",
    "comment" : "\n         * Given a node handle, advance to the next node on the preceding axis.\n         *\n         * @param axisContextHandle the start of the axis that is being traversed.\n         * @param nodeHandle the id of the node.\n         * @return int Node-number of preceding sibling,\n         * or DTM.NULL to indicate none exists.\n         ",
    "links" : [ ]
  }, {
    "name" : "public int getParent(int nodeHandle)",
    "returnType" : "int",
    "comment" : "\n         * Given a node handle, find its parent node.\n         *\n         * @param nodeHandle the id of the node.\n         * @return int Node-number of parent,\n         * or DTM.NULL to indicate none exists.\n         ",
    "links" : [ ]
  }, {
    "name" : "public int getDocumentRoot()",
    "returnType" : "int",
    "comment" : "\n         * Returns the root element of the document.\n         * @return nodeHandle to the Document Root.\n         ",
    "links" : [ ]
  }, {
    "name" : "public int getDocument()",
    "returnType" : "int",
    "comment" : "\n         * Given a node handle, find the owning document node.\n         *\n         * @return int Node handle of document, which should always be valid.\n         ",
    "links" : [ ]
  }, {
    "name" : "public int getOwnerDocument(int nodeHandle)",
    "returnType" : "int",
    "comment" : "\n         * Given a node handle, find the owning document node.  This has the exact\n         * same semantics as the DOM Document method of the same name, in that if\n         * the nodeHandle is a document node, it will return NULL.\n         *\n         * <p>%REVIEW% Since this is DOM-specific, it may belong at the DOM\n         * binding layer. Included here as a convenience function and to\n         * aid porting of DOM code to DTM.</p>\n         *\n         * @param nodeHandle the id of the node.\n         * @return int Node handle of owning document, or NULL if the nodeHandle is\n         *             a document.\n         ",
    "links" : [ ]
  }, {
    "name" : "public int getDocumentRoot(int nodeHandle)",
    "returnType" : "int",
    "comment" : "\n         * Given a node handle, find the owning document node.  This has the DTM\n         * semantics; a Document node is its own owner.\n         *\n         * <p>%REVIEW% Since this is DOM-specific, it may belong at the DOM\n         * binding layer. Included here as a convenience function and to\n         * aid porting of DOM code to DTM.</p>\n         *\n         * @param nodeHandle the id of the node.\n         * @return int Node handle of owning document, or NULL if the nodeHandle is\n         *             a document.\n         ",
    "links" : [ ]
  }, {
    "name" : "public XMLString getStringValue(int nodeHandle)",
    "returnType" : "XMLString",
    "comment" : "\n         * Get the string-value of a node as a String object\n         * (see http://www.w3.org/TR/xpath#data-model\n         * for the definition of a node's string-value).\n         *\n         * @param nodeHandle The node ID.\n         *\n         * @return A string object that represents the string-value of the given node.\n         ",
    "links" : [ ]
  }, {
    "name" : "public int getStringValueChunkCount(int nodeHandle)",
    "returnType" : "int",
    "comment" : "###zaj - tbd",
    "links" : [ ]
  }, {
    "name" : "public char[] getStringValueChunk(int nodeHandle, int chunkIndex, int[] startAndLen)",
    "returnType" : "char[]",
    "comment" : "###zaj - tbd",
    "links" : [ ]
  }, {
    "name" : "public int getExpandedTypeID(int nodeHandle)",
    "returnType" : "int",
    "comment" : "\n         * Given a node handle, return an ID that represents the node's expanded name.\n         *\n         * @param nodeHandle The handle to the node in question.\n         *\n         * @return the expanded-name id of the node.\n         ",
    "links" : [ ]
  }, {
    "name" : "public int getExpandedTypeID(String namespace, String localName, int type)",
    "returnType" : "int",
    "comment" : "\n         * Given an expanded name, return an ID.  If the expanded-name does not\n         * exist in the internal tables, the entry will be created, and the ID will\n         * be returned.  Any additional nodes that are created that have this\n         * expanded name will use this ID.\n         *\n         * @return the expanded-name id of the node.\n         ",
    "links" : [ ]
  }, {
    "name" : "public String getLocalNameFromExpandedNameID(int ExpandedNameID)",
    "returnType" : "String",
    "comment" : "\n         * Given an expanded-name ID, return the local name part.\n         *\n         * @param ExpandedNameID an ID that represents an expanded-name.\n         * @return String Local name of this node.\n         ",
    "links" : [ ]
  }, {
    "name" : "public String getNamespaceFromExpandedNameID(int ExpandedNameID)",
    "returnType" : "String",
    "comment" : "\n         * Given an expanded-name ID, return the namespace URI part.\n         *\n         * @param ExpandedNameID an ID that represents an expanded-name.\n         * @return String URI value of this node's namespace, or null if no\n         * namespace was resolved.\n        ",
    "links" : [ ]
  }, {
    "name" : "public String getNodeName(int nodeHandle)",
    "returnType" : "String",
    "comment" : "\n         * Given a node handle, return its DOM-style node name. This will\n         * include names such as #text or #document.\n         *\n         * @param nodeHandle the id of the node.\n         * @return String Name of this node, which may be an empty string.\n         * %REVIEW% Document when empty string is possible...\n         ",
    "links" : [ ]
  }, {
    "name" : "public String getNodeNameX(int nodeHandle)",
    "returnType" : "String",
    "comment" : "\n         * Given a node handle, return the XPath node name.  This should be\n         * the name as described by the XPath data model, NOT the DOM-style\n         * name.\n         *\n         * @param nodeHandle the id of the node.\n         * @return String Name of this node.\n         ",
    "links" : [ ]
  }, {
    "name" : "public String getLocalName(int nodeHandle)",
    "returnType" : "String",
    "comment" : "\n         * Given a node handle, return its DOM-style localname.\n         * (As defined in Namespaces, this is the portion of the name after any\n         * colon character)\n         *\n         * %REVIEW% What's the local name of something other than Element/Attr?\n         * Should this be DOM-style (undefined unless namespaced), or other?\n         *\n         * @param nodeHandle the id of the node.\n         * @return String Local name of this node.\n         ",
    "links" : [ ]
  }, {
    "name" : "public String getPrefix(int nodeHandle)",
    "returnType" : "String",
    "comment" : "\n         * Given a namespace handle, return the prefix that the namespace decl is\n         * mapping.\n         * Given a node handle, return the prefix used to map to the namespace.\n         *\n         * <p> %REVIEW% Are you sure you want \"\" for no prefix?  </p>\n         *\n         * %REVIEW%  Should this be DOM-style (undefined unless namespaced),\n         * or other?\n         *\n         * @param nodeHandle the id of the node.\n         * @return String prefix of this node's name, or \"\" if no explicit\n         * namespace prefix was given.\n         ",
    "links" : [ ]
  }, {
    "name" : "public String getNamespaceURI(int nodeHandle)",
    "returnType" : "String",
    "comment" : "\n         * Given a node handle, return its DOM-style namespace URI\n         * (As defined in Namespaces, this is the declared URI which this node's\n         * prefix -- or default in lieu thereof -- was mapped to.)\n         *\n         * @param nodeHandle the id of the node.\n         * @return String URI value of this node's namespace, or null if no\n         * namespace was resolved.\n         ",
    "links" : [ ]
  }, {
    "name" : "public String getNodeValue(int nodeHandle)",
    "returnType" : "String",
    "comment" : "\n         * Given a node handle, return its node value. This is mostly\n         * as defined by the DOM, but may ignore some conveniences.\n         * <p>\n         *\n         * @param nodeHandle The node id.\n         * @return String Value of this node, or null if not\n         * meaningful for this node type.\n         ",
    "links" : [ ]
  }, {
    "name" : "public short getNodeType(int nodeHandle)",
    "returnType" : "short",
    "comment" : "\n         * Given a node handle, return its DOM-style node type.\n         * <p>\n         * %REVIEW% Generally, returning short is false economy. Return int?\n         *\n         * @param nodeHandle The node id.\n         * @return int Node type, as per the DOM's Node._NODE constants.\n         ",
    "links" : [ ]
  }, {
    "name" : "public short getLevel(int nodeHandle)",
    "returnType" : "short",
    "comment" : "\n         * Get the depth level of this node in the tree (equals 1 for\n         * a parentless node).\n         *\n         * @param nodeHandle The node id.\n         * @return the number of ancestors, plus one\n         * @xsl.usage internal\n         ",
    "links" : [ ]
  }, {
    "name" : "public boolean isSupported(String feature, String version)",
    "returnType" : "boolean",
    "comment" : "\n         * Tests whether DTM DOM implementation implements a specific feature and\n         * that feature is supported by this node.\n         *\n         * @param feature The name of the feature to test.\n         * @param version This is the version number of the feature to test.\n         *   If the version is not\n         *   specified, supporting any version of the feature will cause the\n         *   method to return <code>true</code>.\n         * @return Returns <code>true</code> if the specified feature is\n         *   supported on this node, <code>false</code> otherwise.\n         ",
    "links" : [ ]
  }, {
    "name" : "public String getDocumentBaseURI()",
    "returnType" : "String",
    "comment" : "\n         * Return the base URI of the document entity. If it is not known\n         * (because the document was parsed from a socket connection or from\n         * standard input, for example), the value of this property is unknown.\n         *\n         * @return the document base URI String object or null if unknown.\n         ",
    "links" : [ ]
  }, {
    "name" : "public void setDocumentBaseURI(String baseURI)",
    "returnType" : "void",
    "comment" : "\n         * Set the base URI of the document entity.\n         *\n         * @param baseURI the document base URI String object or null if unknown.\n         ",
    "links" : [ ]
  }, {
    "name" : "public String getDocumentSystemIdentifier(int nodeHandle)",
    "returnType" : "String",
    "comment" : "\n         * Return the system identifier of the document entity. If\n         * it is not known, the value of this property is unknown.\n         *\n         * @param nodeHandle The node id, which can be any valid node handle.\n         * @return the system identifier String object or null if unknown.\n         ",
    "links" : [ ]
  }, {
    "name" : "public String getDocumentEncoding(int nodeHandle)",
    "returnType" : "String",
    "comment" : "\n         * Return the name of the character encoding scheme\n         *        in which the document entity is expressed.\n         *\n         * @param nodeHandle The node id, which can be any valid node handle.\n         * @return the document encoding String object.\n         ",
    "links" : [ ]
  }, {
    "name" : "public String getDocumentStandalone(int nodeHandle)",
    "returnType" : "String",
    "comment" : "\n         * Return an indication of the standalone status of the document,\n         *        either \"yes\" or \"no\". This property is derived from the optional\n         *        standalone document declaration in the XML declaration at the\n         *        beginning of the document entity, and has no value if there is no\n         *        standalone document declaration.\n         *\n         * @param nodeHandle The node id, which can be any valid node handle.\n         * @return the document standalone String object, either \"yes\", \"no\", or null.\n         ",
    "links" : [ ]
  }, {
    "name" : "public String getDocumentVersion(int documentHandle)",
    "returnType" : "String",
    "comment" : "\n         * Return a string representing the XML version of the document. This\n         * property is derived from the XML declaration optionally present at the\n         * beginning of the document entity, and has no value if there is no XML\n         * declaration.\n         *\n         * @param documentHandle the document handle\n         *\n         * @return the document version String object\n         ",
    "links" : [ ]
  }, {
    "name" : "public boolean getDocumentAllDeclarationsProcessed()",
    "returnType" : "boolean",
    "comment" : "\n         * Return an indication of\n         * whether the processor has read the complete DTD. Its value is a\n         * boolean. If it is false, then certain properties (indicated in their\n         * descriptions below) may be unknown. If it is true, those properties\n         * are never unknown.\n         *\n         * @return <code>true</code> if all declarations were processed {};\n         *         <code>false</code> otherwise.\n         ",
    "links" : [ ]
  }, {
    "name" : "public String getDocumentTypeDeclarationSystemIdentifier()",
    "returnType" : "String",
    "comment" : "\n         *   A document type declaration information item has the following properties:\n         *\n         *     1. [system identifier] The system identifier of the external subset, if\n         *        it exists. Otherwise this property has no value.\n         *\n         * @return the system identifier String object, or null if there is none.\n         ",
    "links" : [ ]
  }, {
    "name" : "public String getDocumentTypeDeclarationPublicIdentifier()",
    "returnType" : "String",
    "comment" : "\n         * Return the public identifier of the external subset,\n         * normalized as described in 4.2.2 External Entities [XML]. If there is\n         * no external subset or if it has no public identifier, this property\n         * has no value.\n         *\n         * @return the public identifier String object, or null if there is none.\n         ",
    "links" : [ ]
  }, {
    "name" : "public int getElementById(String elementId)",
    "returnType" : "int",
    "comment" : "\n         * Returns the <code>Element</code> whose <code>ID</code> is given by\n         * <code>elementId</code>. If no such element exists, returns\n         * <code>DTM.NULL</code>. Behavior is not defined if more than one element\n         * has this <code>ID</code>. Attributes (including those\n         * with the name \"ID\") are not of type ID unless so defined by DTD/Schema\n         * information available to the DTM implementation.\n         * Implementations that do not know whether attributes are of type ID or\n         * not are expected to return <code>DTM.NULL</code>.\n         *\n         * <p>%REVIEW% Presumably IDs are still scoped to a single document,\n         * and this operation searches only within a single document, right?\n         * Wouldn't want collisions between DTMs in the same process.</p>\n         *\n         * @param elementId The unique <code>id</code> value for an element.\n         * @return The handle of the matching element.\n         ",
    "links" : [ ]
  }, {
    "name" : "public String getUnparsedEntityURI(String name)",
    "returnType" : "String",
    "comment" : "\n         * The getUnparsedEntityURI function returns the URI of the unparsed\n         * entity with the specified name in the same document as the context\n         * node (see [3.3 Unparsed Entities]). It returns the empty string if\n         * there is no such entity.\n         * <p>\n         * XML processors may choose to use the System Identifier (if one\n         * is provided) to resolve the entity, rather than the URI in the\n         * Public Identifier. The details are dependent on the processor, and\n         * we would have to support some form of plug-in resolver to handle\n         * this properly. Currently, we simply return the System Identifier if\n         * present, and hope that it a usable URI or that our caller can\n         * map it to one.\n         * TODO: Resolve Public Identifiers... or consider changing function name.\n         * <p>\n         * If we find a relative URI\n         * reference, XML expects it to be resolved in terms of the base URI\n         * of the document. The DOM doesn't do that for us, and it isn't\n         * entirely clear whether that should be done here; currently that's\n         * pushed up to a higher level of our application. (Note that DOM Level\n         * 1 didn't store the document's base URI.)\n         * TODO: Consider resolving Relative URIs.\n         * <p>\n         * (The DOM's statement that \"An XML processor may choose to\n         * completely expand entities before the structure model is passed\n         * to the DOM\" refers only to parsed entities, not unparsed, and hence\n         * doesn't affect this function.)\n         *\n         * @param name A string containing the Entity Name of the unparsed\n         * entity.\n         *\n         * @return String containing the URI of the Unparsed Entity, or an\n         * empty string if no such entity exists.\n         ",
    "links" : [ ]
  }, {
    "name" : "public boolean supportsPreStripping()",
    "returnType" : "boolean",
    "comment" : "\n         * Return true if the xsl:strip-space or xsl:preserve-space was processed\n         * during construction of the DTM document.\n         *\n         * <p>%REVEIW% Presumes a 1:1 mapping from DTM to Document, since\n         * we aren't saying which Document to query...?</p>\n         ",
    "links" : [ ]
  }, {
    "name" : "public boolean isNodeAfter(int nodeHandle1, int nodeHandle2)",
    "returnType" : "boolean",
    "comment" : "\n         * Figure out whether nodeHandle2 should be considered as being later\n         * in the document than nodeHandle1, in Document Order as defined\n         * by the XPath model. This may not agree with the ordering defined\n         * by other XML applications.\n         * <p>\n         * There are some cases where ordering isn't defined, and neither are\n         * the results of this function -- though we'll generally return true.\n         *\n         * TODO: Make sure this does the right thing with attribute nodes!!!\n         *\n         * @param nodeHandle1 DOM Node to perform position comparison on.\n         * @param nodeHandle2 DOM Node to perform position comparison on .\n         *\n         * @return false if node2 comes before node1, otherwise return true.\n         * You can think of this as\n         * <code>(node1.documentOrderPosition &lt;= node2.documentOrderPosition)</code>.\n         ",
    "links" : [ ]
  }, {
    "name" : "public boolean isCharacterElementContentWhitespace(int nodeHandle)",
    "returnType" : "boolean",
    "comment" : "\n         *     2. [element content whitespace] A boolean indicating whether the\n         *        character is white space appearing within element content (see [XML],\n         *        2.10 \"White Space Handling\"). Note that validating XML processors are\n         *        required by XML 1.0 to provide this information. If there is no\n         *        declaration for the containing element, this property has no value for\n         *        white space characters. If no declaration has been read, but the [all\n         *        declarations processed] property of the document information item is\n         *        false (so there may be an unread declaration), then the value of this\n         *        property is unknown for white space characters. It is always false for\n         *        characters that are not white space.\n         *\n         * @param nodeHandle the node ID.\n         * @return <code>true</code> if the character data is whitespace;\n         *         <code>false</code> otherwise.\n         ",
    "links" : [ ]
  }, {
    "name" : "public boolean isDocumentAllDeclarationsProcessed(int documentHandle)",
    "returnType" : "boolean",
    "comment" : "\n         *    10. [all declarations processed] This property is not strictly speaking\n         *        part of the infoset of the document. Rather it is an indication of\n         *        whether the processor has read the complete DTD. Its value is a\n         *        boolean. If it is false, then certain properties (indicated in their\n         *        descriptions below) may be unknown. If it is true, those properties\n         *        are never unknown.\n         *\n         * @param documentHandle A node handle that must identify a document.\n         * @return <code>true</code> if all declarations were processed;\n         *         <code>false</code> otherwise.\n         ",
    "links" : [ ]
  }, {
    "name" : "public boolean isAttributeSpecified(int attributeHandle)",
    "returnType" : "boolean",
    "comment" : "\n         *     5. [specified] A flag indicating whether this attribute was actually\n         *        specified in the start-tag of its element, or was defaulted from the\n         *        DTD.\n         *\n         * @param attributeHandle the attribute handle\n         * @return <code>true</code> if the attribute was specified;\n         *         <code>false</code> if it was defaulted.\n         ",
    "links" : [ ]
  }, {
    "name" : "public void dispatchCharactersEvents(int nodeHandle, org.xml.sax.ContentHandler ch, boolean normalize) throws org.xml.sax.SAXException",
    "returnType" : "void",
    "comment" : "\n         * Directly call the\n         * characters method on the passed ContentHandler for the\n         * string-value of the given node (see http://www.w3.org/TR/xpath#data-model\n         * for the definition of a node's string-value). Multiple calls to the\n         * ContentHandler's characters methods may well occur for a single call to\n         * this method.\n         *\n         * @param nodeHandle The node ID.\n         * @param ch A non-null reference to a ContentHandler.\n         *\n         * @throws org.xml.sax.SAXException\n         ",
    "links" : [ ]
  }, {
    "name" : "public void dispatchToEvents(int nodeHandle, org.xml.sax.ContentHandler ch) throws org.xml.sax.SAXException",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public org.w3c.dom.Node getNode(int nodeHandle)",
    "returnType" : "org.w3c.dom.Node",
    "comment" : "\n         * Return an DOM node for the given node.\n         *\n         * @param nodeHandle The node ID.\n         *\n         * @return A node representation of the DTM node.\n         ",
    "links" : [ ]
  }, {
    "name" : "public void appendChild(int newChild, boolean clone, boolean cloneDepth)",
    "returnType" : "void",
    "comment" : "\n         * Append a child to the end of the child list of the current node. Please note that the node\n         * is always cloned if it is owned by another document.\n         *\n         * <p>%REVIEW% \"End of the document\" needs to be defined more clearly.\n         * Does it become the last child of the Document? Of the root element?</p>\n         *\n         * @param newChild Must be a valid new node handle.\n         * @param clone true if the child should be cloned into the document.\n         * @param cloneDepth if the clone argument is true, specifies that the\n         *                   clone should include all it's children.\n         ",
    "links" : [ ]
  }, {
    "name" : "public void appendTextChild(String str)",
    "returnType" : "void",
    "comment" : "\n         * Append a text node child that will be constructed from a string,\n         * to the end of the document.\n         *\n         * <p>%REVIEW% \"End of the document\" needs to be defined more clearly.\n         * Does it become the last child of the Document? Of the root element?</p>\n         *\n         * @param str Non-null reference to a string.\n         ",
    "links" : [ ]
  }, {
    "name" : " void appendTextChild(int m_char_current_start, int contentLength)",
    "returnType" : "void",
    "comment" : " Append a text child at the current insertion point. Assumes that the\n   * actual content of the text has previously been appended to the m_char\n   * buffer (shared with the builder).\n   *\n   * @param m_char_current_start int Starting offset of node's content in m_char.\n   * @param contentLength int Length of node's content in m_char.\n   * ",
    "links" : [ ]
  }, {
    "name" : " void appendComment(int m_char_current_start, int contentLength)",
    "returnType" : "void",
    "comment" : " Append a comment child at the current insertion point. Assumes that the\n   * actual content of the comment has previously been appended to the m_char\n   * buffer (shared with the builder).\n   *\n   * @param m_char_current_start int Starting offset of node's content in m_char.\n   * @param contentLength int Length of node's content in m_char.\n   * ",
    "links" : [ ]
  }, {
    "name" : " void appendStartElement(int namespaceIndex, int localNameIndex, int prefixIndex)",
    "returnType" : "void",
    "comment" : " Append an Element child at the current insertion point. This\n   * Element then _becomes_ the insertion point; subsequent appends\n   * become its lastChild until an appendEndElement() call is made.\n   *\n   * Assumes that the symbols (local name, namespace URI and prefix)\n   * have already been added to the pools\n   *\n   * Note that this _only_ handles the Element node itself. Attrs and\n   * namespace nodes are unbundled in the ContentHandler layer\n   * and appended separately.\n   *\n   * @param namespaceIndex: Index within the namespaceURI string pool\n   * @param localNameIndex Index within the local name string pool\n   * @param prefixIndex: Index within the prefix string pool\n   * ",
    "links" : [ ]
  }, {
    "name" : " void appendNSDeclaration(int prefixIndex, int namespaceIndex, boolean isID)",
    "returnType" : "void",
    "comment" : " Append a Namespace Declaration child at the current insertion point.\n   * Assumes that the symbols (namespace URI and prefix) have already been\n   * added to the pools\n   *\n   * @param prefixIndex: Index within the prefix string pool\n   * @param namespaceIndex: Index within the namespaceURI string pool\n   * @param isID: If someone really insists on writing a bad DTD, it is\n   * theoretically possible for a namespace declaration to also be declared\n   * as being a node ID. I don't really want to support that stupidity,\n   * but I'm not sure we can refuse to accept it.\n   * ",
    "links" : [ ]
  }, {
    "name" : " void appendAttribute(int namespaceIndex, int localNameIndex, int prefixIndex, boolean isID, int m_char_current_start, int contentLength)",
    "returnType" : "void",
    "comment" : " Append an Attribute child at the current insertion\n   * point.  Assumes that the symbols (namespace URI, local name, and\n   * prefix) have already been added to the pools, and that the content has\n   * already been appended to m_char. Note that the attribute's content has\n   * been flattened into a single string; DTM does _NOT_ attempt to model\n   * the details of entity references within attribute values.\n   *\n   * @param namespaceIndex int Index within the namespaceURI string pool\n   * @param localNameIndex int Index within the local name string pool\n   * @param prefixIndex int Index within the prefix string pool\n   * @param isID boolean True if this attribute was declared as an ID\n   * (for use in supporting getElementByID).\n   * @param m_char_current_start int Starting offset of node's content in m_char.\n   * @param contentLength int Length of node's content in m_char.\n   * ",
    "links" : [ ]
  }, {
    "name" : "public DTMAxisTraverser getAxisTraverser(final int axis)",
    "returnType" : "DTMAxisTraverser",
    "comment" : "\n   * This returns a stateless \"traverser\", that can navigate over an\n   * XPath axis, though not in document order.\n   *\n   * @param axis One of Axes.ANCESTORORSELF, etc.\n   *\n   * @return A DTMAxisIterator, or null if the given axis isn't supported.\n   ",
    "links" : [ ]
  }, {
    "name" : "public DTMAxisIterator getAxisIterator(final int axis)",
    "returnType" : "DTMAxisIterator",
    "comment" : "\n   * This is a shortcut to the iterators that implement the\n   * supported XPath axes (only namespace::) is not supported.\n   * Returns a bare-bones iterator that must be initialized\n   * with a start node (using iterator.setStartNode()).\n   *\n   * @param axis One of Axes.ANCESTORORSELF, etc.\n   *\n   * @return A DTMAxisIterator, or null if the given axis isn't supported.\n   ",
    "links" : [ ]
  }, {
    "name" : "public DTMAxisIterator getTypedAxisIterator(final int axis, final int type)",
    "returnType" : "DTMAxisIterator",
    "comment" : "\n   * Get an iterator that can navigate over an XPath Axis, predicated by\n   * the extended type ID.\n   *\n   *\n   * @param axis\n   * @param type An extended type ID.\n   *\n   * @return A DTMAxisIterator, or null if the given axis isn't supported.\n   ",
    "links" : [ ]
  }, {
    "name" : " void appendEndElement()",
    "returnType" : "void",
    "comment" : " Terminate the element currently acting as an insertion point. Subsequent\n   * insertions will occur as the last child of this element's parent.\n   * ",
    "links" : [ ]
  }, {
    "name" : " void appendStartDocument()",
    "returnType" : "void",
    "comment" : "  Starting a new document. Perform any resets/initialization\n   * not already handled.\n   * ",
    "links" : [ ]
  }, {
    "name" : " void appendEndDocument()",
    "returnType" : "void",
    "comment" : "  All appends to this document have finished; do whatever final\n   * cleanup is needed.\n   * ",
    "links" : [ ]
  }, {
    "name" : "public void setProperty(String property, Object value)",
    "returnType" : "void",
    "comment" : "\n   * For the moment all the run time properties are ignored by this\n   * class.\n   *\n   * @param property a <code>String</code> value\n   * @param value an <code>Object</code> value\n   ",
    "links" : [ ]
  }, {
    "name" : "public SourceLocator getSourceLocatorFor(int node)",
    "returnType" : "SourceLocator",
    "comment" : "\n   * Source information is not handled yet, so return\n   * <code>null</code> here.\n   *\n   * @param node an <code>int</code> value\n   * @return null\n   ",
    "links" : [ ]
  }, {
    "name" : "public void documentRegistration()",
    "returnType" : "void",
    "comment" : "\n   * A dummy routine to satisify the abstract interface. If the DTM\n   * implememtation that extends the default base requires notification\n   * of registration, they can override this method.\n   ",
    "links" : [ ]
  }, {
    "name" : "public void documentRelease()",
    "returnType" : "void",
    "comment" : "\n   * A dummy routine to satisify the abstract interface. If the DTM\n   * implememtation that extends the default base requires notification\n   * when the document is being released, they can override this method\n   ",
    "links" : [ ]
  }, {
    "name" : "public void migrateTo(DTMManager manager)",
    "returnType" : "void",
    "comment" : "\n    * Migrate a DTM built with an old DTMManager to a new DTMManager.\n    * After the migration, the new DTMManager will treat the DTM as\n    * one that is built by itself.\n    * This is used to support DTM sharing between multiple transformations.\n    * @param manager the DTMManager\n    ",
    "links" : [ ]
  } ],
  "methodNames" : [ "public void setIncrementalSAXSource(IncrementalSAXSource source)", "private final int appendNode(int w0, int w1, int w2, int w3)", "public void setFeature(String featureId, boolean state)", "public void setLocalNameTable(DTMStringPool poolRef)", "public DTMStringPool getLocalNameTable()", "public void setNsNameTable(DTMStringPool poolRef)", "public DTMStringPool getNsNameTable()", "public void setPrefixNameTable(DTMStringPool poolRef)", "public DTMStringPool getPrefixNameTable()", " void setContentBuffer(FastStringBuffer buffer)", " FastStringBuffer getContentBuffer()", "public org.xml.sax.ContentHandler getContentHandler()", "public LexicalHandler getLexicalHandler()", "public org.xml.sax.EntityResolver getEntityResolver()", "public org.xml.sax.DTDHandler getDTDHandler()", "public org.xml.sax.ErrorHandler getErrorHandler()", "public org.xml.sax.ext.DeclHandler getDeclHandler()", "public boolean needsTwoThreads()", "public void characters(char[] ch, int start, int length) throws org.xml.sax.SAXException", "private void processAccumulatedText()", "public void endDocument() throws org.xml.sax.SAXException", "public void endElement(java.lang.String namespaceURI, java.lang.String localName, java.lang.String qName) throws org.xml.sax.SAXException", "public void endPrefixMapping(java.lang.String prefix) throws org.xml.sax.SAXException", "public void ignorableWhitespace(char[] ch, int start, int length) throws org.xml.sax.SAXException", "public void processingInstruction(java.lang.String target, java.lang.String data) throws org.xml.sax.SAXException", "public void setDocumentLocator(Locator locator)", "public void skippedEntity(java.lang.String name) throws org.xml.sax.SAXException", "public void startDocument() throws org.xml.sax.SAXException", "public void startElement(java.lang.String namespaceURI, java.lang.String localName, java.lang.String qName, Attributes atts) throws org.xml.sax.SAXException", "public void startPrefixMapping(java.lang.String prefix, java.lang.String uri) throws org.xml.sax.SAXException", "public void comment(char[] ch, int start, int length) throws org.xml.sax.SAXException", "public void endCDATA() throws org.xml.sax.SAXException", "public void endDTD() throws org.xml.sax.SAXException", "public void endEntity(java.lang.String name) throws org.xml.sax.SAXException", "public void startCDATA() throws org.xml.sax.SAXException", "public void startDTD(java.lang.String name, java.lang.String publicId, java.lang.String systemId) throws org.xml.sax.SAXException", "public void startEntity(java.lang.String name) throws org.xml.sax.SAXException", " final void initDocument(int documentNumber)", "public boolean hasChildNodes(int nodeHandle)", "public int getFirstChild(int nodeHandle)", "public int getLastChild(int nodeHandle)", "public int getAttributeNode(int nodeHandle, String namespaceURI, String name)", "public int getFirstAttribute(int nodeHandle)", "public int getFirstNamespaceNode(int nodeHandle, boolean inScope)", "public int getNextSibling(int nodeHandle)", "public int getPreviousSibling(int nodeHandle)", "public int getNextAttribute(int nodeHandle)", "public int getNextNamespaceNode(int baseHandle, int namespaceHandle, boolean inScope)", "public int getNextDescendant(int subtreeRootHandle, int nodeHandle)", "public int getNextFollowing(int axisContextHandle, int nodeHandle)", "public int getNextPreceding(int axisContextHandle, int nodeHandle)", "public int getParent(int nodeHandle)", "public int getDocumentRoot()", "public int getDocument()", "public int getOwnerDocument(int nodeHandle)", "public int getDocumentRoot(int nodeHandle)", "public XMLString getStringValue(int nodeHandle)", "public int getStringValueChunkCount(int nodeHandle)", "public char[] getStringValueChunk(int nodeHandle, int chunkIndex, int[] startAndLen)", "public int getExpandedTypeID(int nodeHandle)", "public int getExpandedTypeID(String namespace, String localName, int type)", "public String getLocalNameFromExpandedNameID(int ExpandedNameID)", "public String getNamespaceFromExpandedNameID(int ExpandedNameID)", "public String getNodeName(int nodeHandle)", "public String getNodeNameX(int nodeHandle)", "public String getLocalName(int nodeHandle)", "public String getPrefix(int nodeHandle)", "public String getNamespaceURI(int nodeHandle)", "public String getNodeValue(int nodeHandle)", "public short getNodeType(int nodeHandle)", "public short getLevel(int nodeHandle)", "public boolean isSupported(String feature, String version)", "public String getDocumentBaseURI()", "public void setDocumentBaseURI(String baseURI)", "public String getDocumentSystemIdentifier(int nodeHandle)", "public String getDocumentEncoding(int nodeHandle)", "public String getDocumentStandalone(int nodeHandle)", "public String getDocumentVersion(int documentHandle)", "public boolean getDocumentAllDeclarationsProcessed()", "public String getDocumentTypeDeclarationSystemIdentifier()", "public String getDocumentTypeDeclarationPublicIdentifier()", "public int getElementById(String elementId)", "public String getUnparsedEntityURI(String name)", "public boolean supportsPreStripping()", "public boolean isNodeAfter(int nodeHandle1, int nodeHandle2)", "public boolean isCharacterElementContentWhitespace(int nodeHandle)", "public boolean isDocumentAllDeclarationsProcessed(int documentHandle)", "public boolean isAttributeSpecified(int attributeHandle)", "public void dispatchCharactersEvents(int nodeHandle, org.xml.sax.ContentHandler ch, boolean normalize) throws org.xml.sax.SAXException", "public void dispatchToEvents(int nodeHandle, org.xml.sax.ContentHandler ch) throws org.xml.sax.SAXException", "public org.w3c.dom.Node getNode(int nodeHandle)", "public void appendChild(int newChild, boolean clone, boolean cloneDepth)", "public void appendTextChild(String str)", " void appendTextChild(int m_char_current_start, int contentLength)", " void appendComment(int m_char_current_start, int contentLength)", " void appendStartElement(int namespaceIndex, int localNameIndex, int prefixIndex)", " void appendNSDeclaration(int prefixIndex, int namespaceIndex, boolean isID)", " void appendAttribute(int namespaceIndex, int localNameIndex, int prefixIndex, boolean isID, int m_char_current_start, int contentLength)", "public DTMAxisTraverser getAxisTraverser(final int axis)", "public DTMAxisIterator getAxisIterator(final int axis)", "public DTMAxisIterator getTypedAxisIterator(final int axis, final int type)", " void appendEndElement()", " void appendStartDocument()", " void appendEndDocument()", "public void setProperty(String property, Object value)", "public SourceLocator getSourceLocatorFor(int node)", "public void documentRegistration()", "public void documentRelease()", "public void migrateTo(DTMManager manager)" ],
  "variableNames" : [ "DOCHANDLE_SHIFT", "NODEHANDLE_MASK", "DOCHANDLE_MASK", "m_docHandle", "m_docElement", "currentParent", "previousSibling", "m_currentNode", "previousSiblingWasParent", "gotslot", "done", "m_isError", "DEBUG", "m_documentBaseURI", "m_incrSAXSource", "nodes", "m_char", "m_char_current_start", "m_localNames", "m_nsNames", "m_prefixNames", "m_expandedNames", "m_xsf", "fixednames" ]
}