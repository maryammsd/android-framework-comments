{
  "filePath" : "/home/maryam/clearblue/files/android-source-35/java/lang/invoke/MutableCallSite.java",
  "packageName" : "java.lang.invoke",
  "className" : "MutableCallSite",
  "comment" : "\n * A {@code MutableCallSite} is a {@link CallSite} whose target variable\n * behaves like an ordinary field.\n * An {@code invokedynamic} instruction linked to a {@code MutableCallSite} delegates\n * all calls to the site's current target.\n * The {@linkplain CallSite#dynamicInvoker dynamic invoker} of a mutable call site\n * also delegates each call to the site's current target.\n * <p>\n * Here is an example of a mutable call site which introduces a\n * state variable into a method handle chain.\n * <!-- JavaDocExamplesTest.testMutableCallSite -->\n * <blockquote><pre>{@code\nMutableCallSite name = new MutableCallSite(MethodType.methodType(String.class));\nMethodHandle MH_name = name.dynamicInvoker();\nMethodType MT_str1 = MethodType.methodType(String.class);\nMethodHandle MH_upcase = MethodHandles.lookup()\n    .findVirtual(String.class, \"toUpperCase\", MT_str1);\nMethodHandle worker1 = MethodHandles.filterReturnValue(MH_name, MH_upcase);\nname.setTarget(MethodHandles.constant(String.class, \"Rocky\"));\nassertEquals(\"ROCKY\", (String) worker1.invokeExact());\nname.setTarget(MethodHandles.constant(String.class, \"Fred\"));\nassertEquals(\"FRED\", (String) worker1.invokeExact());\n// (mutation can be continued indefinitely)\n * }</pre></blockquote>\n * <p>\n * The same call site may be used in several places at once.\n * <blockquote><pre>{@code\nMethodType MT_str2 = MethodType.methodType(String.class, String.class);\nMethodHandle MH_cat = lookup().findVirtual(String.class,\n  \"concat\", methodType(String.class, String.class));\nMethodHandle MH_dear = MethodHandles.insertArguments(MH_cat, 1, \", dear?\");\nMethodHandle worker2 = MethodHandles.filterReturnValue(MH_name, MH_dear);\nassertEquals(\"Fred, dear?\", (String) worker2.invokeExact());\nname.setTarget(MethodHandles.constant(String.class, \"Wilma\"));\nassertEquals(\"WILMA\", (String) worker1.invokeExact());\nassertEquals(\"Wilma, dear?\", (String) worker2.invokeExact());\n * }</pre></blockquote>\n * <p>\n * <em>Non-synchronization of target values:</em>\n * A write to a mutable call site's target does not force other threads\n * to become aware of the updated value.  Threads which do not perform\n * suitable synchronization actions relative to the updated call site\n * may cache the old target value and delay their use of the new target\n * value indefinitely.\n * (This is a normal consequence of the Java Memory Model as applied\n * to object fields.)\n * <p>\n * For target values which will be frequently updated, consider using\n * a {@linkplain VolatileCallSite volatile call site} instead.\n * @author John Rose, JSR 292 EG\n ",
  "links" : [ "java.lang.invoke.CallSite" ],
  "variables" : [ ],
  "methods" : [ {
    "name" : "public final MethodHandle getTarget()",
    "returnType" : "MethodHandle",
    "comment" : "\n     * Returns the target method of the call site, which behaves\n     * like a normal field of the {@code MutableCallSite}.\n     * <p>\n     * The interactions of {@code getTarget} with memory are the same\n     * as of a read from an ordinary variable, such as an array element or a\n     * non-volatile, non-final field.\n     * <p>\n     * In particular, the current thread may choose to reuse the result\n     * of a previous read of the target from memory, and may fail to see\n     * a recent update to the target by another thread.\n     *\n     * @return the linkage state of this call site, a method handle which can change over time\n     * @see #setTarget\n     ",
    "links" : [ ]
  }, {
    "name" : "public void setTarget(MethodHandle newTarget)",
    "returnType" : "void",
    "comment" : "\n     * Updates the target method of this call site, as a normal variable.\n     * The type of the new target must agree with the type of the old target.\n     * <p>\n     * The interactions with memory are the same\n     * as of a write to an ordinary variable, such as an array element or a\n     * non-volatile, non-final field.\n     * <p>\n     * In particular, unrelated threads may fail to see the updated target\n     * until they perform a read from memory.\n     * Stronger guarantees can be created by putting appropriate operations\n     * into the bootstrap method and/or the target methods used\n     * at any given call site.\n     *\n     * @param newTarget the new target\n     * @throws NullPointerException if the proposed new target is null\n     * @throws WrongMethodTypeException if the proposed new target\n     *         has a method type that differs from the previous target\n     * @see #getTarget\n     ",
    "links" : [ ]
  }, {
    "name" : "public final MethodHandle dynamicInvoker()",
    "returnType" : "MethodHandle",
    "comment" : "\n     * {@inheritDoc}\n     ",
    "links" : [ ]
  } ],
  "methodNames" : [ "public final MethodHandle getTarget()", "public void setTarget(MethodHandle newTarget)", "public final MethodHandle dynamicInvoker()" ],
  "variableNames" : [ ]
}