{
  "filePath" : "/home/maryam/clearblue/files/android-source-30/android/bluetooth/BluetoothAdapter.java",
  "packageName" : "android.bluetooth",
  "className" : "BluetoothAdapter",
  "comment" : "\n * Represents the local device Bluetooth adapter. The {@link BluetoothAdapter}\n * lets you perform fundamental Bluetooth tasks, such as initiate\n * device discovery, query a list of bonded (paired) devices,\n * instantiate a {@link BluetoothDevice} using a known MAC address, and create\n * a {@link BluetoothServerSocket} to listen for connection requests from other\n * devices, and start a scan for Bluetooth LE devices.\n *\n * <p>To get a {@link BluetoothAdapter} representing the local Bluetooth\n * adapter, call the {@link BluetoothManager#getAdapter} function on {@link BluetoothManager}.\n * On JELLY_BEAN_MR1 and below you will need to use the static {@link #getDefaultAdapter}\n * method instead.\n * </p><p>\n * Fundamentally, this is your starting point for all\n * Bluetooth actions. Once you have the local adapter, you can get a set of\n * {@link BluetoothDevice} objects representing all paired devices with\n * {@link #getBondedDevices()}; start device discovery with\n * {@link #startDiscovery()}; or create a {@link BluetoothServerSocket} to\n * listen for incoming RFComm connection requests with {@link\n * #listenUsingRfcommWithServiceRecord(String, UUID)}; listen for incoming L2CAP Connection-oriented\n * Channels (CoC) connection requests with {@link #listenUsingL2capChannel()}; or start a scan for\n * Bluetooth LE devices with {@link #startLeScan(LeScanCallback callback)}.\n * </p>\n * <p>This class is thread safe.</p>\n * <p class=\"note\"><strong>Note:</strong>\n * Most methods require the {@link android.Manifest.permission#BLUETOOTH}\n * permission and some also require the\n * {@link android.Manifest.permission#BLUETOOTH_ADMIN} permission.\n * </p>\n * <div class=\"special reference\">\n * <h3>Developer Guides</h3>\n * <p>\n * For more information about using Bluetooth, read the <a href=\n * \"{@docRoot}guide/topics/connectivity/bluetooth.html\">Bluetooth</a> developer\n * guide.\n * </p>\n * </div>\n *\n * {@see BluetoothDevice}\n * {@see BluetoothServerSocket}\n ",
  "variables" : [ {
    "name" : "TAG",
    "type" : "String",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "DBG",
    "type" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "VDBG",
    "type" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "DEFAULT_MAC_ADDRESS",
    "type" : "String",
    "comment" : "\n     * Default MAC address reported to a client that does not have the\n     * android.permission.LOCAL_MAC_ADDRESS permission.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "ERROR",
    "type" : "int",
    "comment" : "\n     * Sentinel error value for this class. Guaranteed to not equal any other\n     * integer constant in this class. Provided as a convenience for functions\n     * that require a sentinel error value, for example:\n     * <p><code>Intent.getIntExtra(BluetoothAdapter.EXTRA_STATE,\n     * BluetoothAdapter.ERROR)</code>\n     ",
    "links" : [ ]
  }, {
    "name" : "ACTION_STATE_CHANGED",
    "type" : "String",
    "comment" : "\n     * Broadcast Action: The state of the local Bluetooth adapter has been\n     * changed.\n     * <p>For example, Bluetooth has been turned on or off.\n     * <p>Always contains the extra fields {@link #EXTRA_STATE} and {@link\n     * #EXTRA_PREVIOUS_STATE} containing the new and old states\n     * respectively.\n     * <p>Requires {@link android.Manifest.permission#BLUETOOTH} to receive.\n     ",
    "links" : [ "#EXTRA_STATE", "#EXTRA_PREVIOUS_STATE", "android.Manifest.permission#BLUETOOTH" ]
  }, {
    "name" : "EXTRA_STATE",
    "type" : "String",
    "comment" : "\n     * Used as an int extra field in {@link #ACTION_STATE_CHANGED}\n     * intents to request the current power state. Possible values are:\n     * {@link #STATE_OFF},\n     * {@link #STATE_TURNING_ON},\n     * {@link #STATE_ON},\n     * {@link #STATE_TURNING_OFF},\n     ",
    "links" : [ "#STATE_TURNING_OFF", "#STATE_TURNING_ON", "#STATE_ON", "#ACTION_STATE_CHANGED", "#STATE_OFF" ]
  }, {
    "name" : "EXTRA_PREVIOUS_STATE",
    "type" : "String",
    "comment" : "\n     * Used as an int extra field in {@link #ACTION_STATE_CHANGED}\n     * intents to request the previous power state. Possible values are:\n     * {@link #STATE_OFF},\n     * {@link #STATE_TURNING_ON},\n     * {@link #STATE_ON},\n     * {@link #STATE_TURNING_OFF}\n     ",
    "links" : [ "#STATE_TURNING_OFF", "#STATE_TURNING_ON", "#STATE_ON", "#ACTION_STATE_CHANGED", "#STATE_OFF" ]
  }, {
    "name" : "STATE_OFF",
    "type" : "int",
    "comment" : "\n     * Indicates the local Bluetooth adapter is off.\n     ",
    "links" : [ ]
  }, {
    "name" : "STATE_TURNING_ON",
    "type" : "int",
    "comment" : "\n     * Indicates the local Bluetooth adapter is turning on. However local\n     * clients should wait for {@link #STATE_ON} before attempting to\n     * use the adapter.\n     ",
    "links" : [ "#STATE_ON" ]
  }, {
    "name" : "STATE_ON",
    "type" : "int",
    "comment" : "\n     * Indicates the local Bluetooth adapter is on, and ready for use.\n     ",
    "links" : [ ]
  }, {
    "name" : "STATE_TURNING_OFF",
    "type" : "int",
    "comment" : "\n     * Indicates the local Bluetooth adapter is turning off. Local clients\n     * should immediately attempt graceful disconnection of any remote links.\n     ",
    "links" : [ ]
  }, {
    "name" : "STATE_BLE_TURNING_ON",
    "type" : "int",
    "comment" : "\n     * Indicates the local Bluetooth adapter is turning Bluetooth LE mode on.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "STATE_BLE_ON",
    "type" : "int",
    "comment" : "\n     * Indicates the local Bluetooth adapter is in LE only mode.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "STATE_BLE_TURNING_OFF",
    "type" : "int",
    "comment" : "\n     * Indicates the local Bluetooth adapter is turning off LE only mode.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "LE_PSM_CHARACTERISTIC_UUID",
    "type" : "UUID",
    "comment" : "\n     * UUID of the GATT Read Characteristics for LE_PSM value.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "ACTION_REQUEST_DISCOVERABLE",
    "type" : "String",
    "comment" : "\n     * Activity Action: Show a system activity that requests discoverable mode.\n     * This activity will also request the user to turn on Bluetooth if it\n     * is not currently enabled.\n     * <p>Discoverable mode is equivalent to {@link\n     * #SCAN_MODE_CONNECTABLE_DISCOVERABLE}. It allows remote devices to see\n     * this Bluetooth adapter when they perform a discovery.\n     * <p>For privacy, Android is not discoverable by default.\n     * <p>The sender of this Intent can optionally use extra field {@link\n     * #EXTRA_DISCOVERABLE_DURATION} to request the duration of\n     * discoverability. Currently the default duration is 120 seconds, and\n     * maximum duration is capped at 300 seconds for each request.\n     * <p>Notification of the result of this activity is posted using the\n     * {@link android.app.Activity#onActivityResult} callback. The\n     * <code>resultCode</code>\n     * will be the duration (in seconds) of discoverability or\n     * {@link android.app.Activity#RESULT_CANCELED} if the user rejected\n     * discoverability or an error has occurred.\n     * <p>Applications can also listen for {@link #ACTION_SCAN_MODE_CHANGED}\n     * for global notification whenever the scan mode changes. For example, an\n     * application can be notified when the device has ended discoverability.\n     * <p>Requires {@link android.Manifest.permission#BLUETOOTH}\n     ",
    "links" : [ "android.app.Activity#RESULT_CANCELED", "android.app.Activity#onActivityResult", "#ACTION_SCAN_MODE_CHANGED", "#SCAN_MODE_CONNECTABLE_DISCOVERABLE", "#EXTRA_DISCOVERABLE_DURATION", "android.Manifest.permission#BLUETOOTH" ]
  }, {
    "name" : "EXTRA_DISCOVERABLE_DURATION",
    "type" : "String",
    "comment" : "\n     * Used as an optional int extra field in {@link\n     * #ACTION_REQUEST_DISCOVERABLE} intents to request a specific duration\n     * for discoverability in seconds. The current default is 120 seconds, and\n     * requests over 300 seconds will be capped. These values could change.\n     ",
    "links" : [ "#ACTION_REQUEST_DISCOVERABLE" ]
  }, {
    "name" : "ACTION_REQUEST_ENABLE",
    "type" : "String",
    "comment" : "\n     * Activity Action: Show a system activity that allows the user to turn on\n     * Bluetooth.\n     * <p>This system activity will return once Bluetooth has completed turning\n     * on, or the user has decided not to turn Bluetooth on.\n     * <p>Notification of the result of this activity is posted using the\n     * {@link android.app.Activity#onActivityResult} callback. The\n     * <code>resultCode</code>\n     * will be {@link android.app.Activity#RESULT_OK} if Bluetooth has been\n     * turned on or {@link android.app.Activity#RESULT_CANCELED} if the user\n     * has rejected the request or an error has occurred.\n     * <p>Applications can also listen for {@link #ACTION_STATE_CHANGED}\n     * for global notification whenever Bluetooth is turned on or off.\n     * <p>Requires {@link android.Manifest.permission#BLUETOOTH}\n     ",
    "links" : [ "android.app.Activity#RESULT_CANCELED", "android.app.Activity#RESULT_OK", "android.app.Activity#onActivityResult", "#ACTION_STATE_CHANGED", "android.Manifest.permission#BLUETOOTH" ]
  }, {
    "name" : "ACTION_REQUEST_DISABLE",
    "type" : "String",
    "comment" : "\n     * Activity Action: Show a system activity that allows the user to turn off\n     * Bluetooth. This is used only if permission review is enabled which is for\n     * apps targeting API less than 23 require a permission review before any of\n     * the app's components can run.\n     * <p>This system activity will return once Bluetooth has completed turning\n     * off, or the user has decided not to turn Bluetooth off.\n     * <p>Notification of the result of this activity is posted using the\n     * {@link android.app.Activity#onActivityResult} callback. The\n     * <code>resultCode</code>\n     * will be {@link android.app.Activity#RESULT_OK} if Bluetooth has been\n     * turned off or {@link android.app.Activity#RESULT_CANCELED} if the user\n     * has rejected the request or an error has occurred.\n     * <p>Applications can also listen for {@link #ACTION_STATE_CHANGED}\n     * for global notification whenever Bluetooth is turned on or off.\n     * <p>Requires {@link android.Manifest.permission#BLUETOOTH}\n     *\n     * @hide\n     ",
    "links" : [ "android.app.Activity#RESULT_CANCELED", "android.app.Activity#RESULT_OK", "android.app.Activity#onActivityResult", "#ACTION_STATE_CHANGED", "android.Manifest.permission#BLUETOOTH" ]
  }, {
    "name" : "ACTION_REQUEST_BLE_SCAN_ALWAYS_AVAILABLE",
    "type" : "String",
    "comment" : "\n     * Activity Action: Show a system activity that allows user to enable BLE scans even when\n     * Bluetooth is turned off.<p>\n     *\n     * Notification of result of this activity is posted using\n     * {@link android.app.Activity#onActivityResult}. The <code>resultCode</code> will be\n     * {@link android.app.Activity#RESULT_OK} if BLE scan always available setting is turned on or\n     * {@link android.app.Activity#RESULT_CANCELED} if the user has rejected the request or an\n     * error occurred.\n     *\n     * @hide\n     ",
    "links" : [ "android.app.Activity#RESULT_CANCELED", "android.app.Activity#RESULT_OK", "android.app.Activity#onActivityResult" ]
  }, {
    "name" : "ACTION_SCAN_MODE_CHANGED",
    "type" : "String",
    "comment" : "\n     * Broadcast Action: Indicates the Bluetooth scan mode of the local Adapter\n     * has changed.\n     * <p>Always contains the extra fields {@link #EXTRA_SCAN_MODE} and {@link\n     * #EXTRA_PREVIOUS_SCAN_MODE} containing the new and old scan modes\n     * respectively.\n     * <p>Requires {@link android.Manifest.permission#BLUETOOTH}\n     ",
    "links" : [ "#EXTRA_SCAN_MODE", "#EXTRA_PREVIOUS_SCAN_MODE", "android.Manifest.permission#BLUETOOTH" ]
  }, {
    "name" : "EXTRA_SCAN_MODE",
    "type" : "String",
    "comment" : "\n     * Used as an int extra field in {@link #ACTION_SCAN_MODE_CHANGED}\n     * intents to request the current scan mode. Possible values are:\n     * {@link #SCAN_MODE_NONE},\n     * {@link #SCAN_MODE_CONNECTABLE},\n     * {@link #SCAN_MODE_CONNECTABLE_DISCOVERABLE},\n     ",
    "links" : [ "#SCAN_MODE_NONE", "#SCAN_MODE_CONNECTABLE", "#ACTION_SCAN_MODE_CHANGED", "#SCAN_MODE_CONNECTABLE_DISCOVERABLE" ]
  }, {
    "name" : "EXTRA_PREVIOUS_SCAN_MODE",
    "type" : "String",
    "comment" : "\n     * Used as an int extra field in {@link #ACTION_SCAN_MODE_CHANGED}\n     * intents to request the previous scan mode. Possible values are:\n     * {@link #SCAN_MODE_NONE},\n     * {@link #SCAN_MODE_CONNECTABLE},\n     * {@link #SCAN_MODE_CONNECTABLE_DISCOVERABLE},\n     ",
    "links" : [ "#SCAN_MODE_NONE", "#SCAN_MODE_CONNECTABLE", "#ACTION_SCAN_MODE_CHANGED", "#SCAN_MODE_CONNECTABLE_DISCOVERABLE" ]
  }, {
    "name" : "SCAN_MODE_NONE",
    "type" : "int",
    "comment" : "\n     * Indicates that both inquiry scan and page scan are disabled on the local\n     * Bluetooth adapter. Therefore this device is neither discoverable\n     * nor connectable from remote Bluetooth devices.\n     ",
    "links" : [ ]
  }, {
    "name" : "SCAN_MODE_CONNECTABLE",
    "type" : "int",
    "comment" : "\n     * Indicates that inquiry scan is disabled, but page scan is enabled on the\n     * local Bluetooth adapter. Therefore this device is not discoverable from\n     * remote Bluetooth devices, but is connectable from remote devices that\n     * have previously discovered this device.\n     ",
    "links" : [ ]
  }, {
    "name" : "SCAN_MODE_CONNECTABLE_DISCOVERABLE",
    "type" : "int",
    "comment" : "\n     * Indicates that both inquiry scan and page scan are enabled on the local\n     * Bluetooth adapter. Therefore this device is both discoverable and\n     * connectable from remote Bluetooth devices.\n     ",
    "links" : [ ]
  }, {
    "name" : "IO_CAPABILITY_OUT",
    "type" : "int",
    "comment" : "\n     * Device only has a display.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "IO_CAPABILITY_IO",
    "type" : "int",
    "comment" : "\n     * Device has a display and the ability to input Yes/No.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "IO_CAPABILITY_IN",
    "type" : "int",
    "comment" : "\n     * Device only has a keyboard for entry but no display.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "IO_CAPABILITY_NONE",
    "type" : "int",
    "comment" : "\n     * Device has no Input or Output capability.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "IO_CAPABILITY_KBDISP",
    "type" : "int",
    "comment" : "\n     * Device has a display and a full keyboard.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "IO_CAPABILITY_MAX",
    "type" : "int",
    "comment" : "\n     * Maximum range value for Input/Output capabilities.\n     *\n     * <p>This should be updated when adding a new Input/Output capability. Other code\n     * like validation depends on this being accurate.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "IO_CAPABILITY_UNKNOWN",
    "type" : "int",
    "comment" : "\n     * The Input/Output capability of the device is unknown.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "ACTIVE_DEVICE_AUDIO",
    "type" : "int",
    "comment" : "\n     * Use the specified device for audio (a2dp and hearing aid profile)\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "ACTIVE_DEVICE_PHONE_CALL",
    "type" : "int",
    "comment" : "\n     * Use the specified device for phone calls (headset profile and hearing\n     * aid profile)\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "ACTIVE_DEVICE_ALL",
    "type" : "int",
    "comment" : "\n     * Use the specified device for a2dp, hearing aid profile, and headset profile\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "ACTION_DISCOVERY_STARTED",
    "type" : "String",
    "comment" : "\n     * Broadcast Action: The local Bluetooth adapter has started the remote\n     * device discovery process.\n     * <p>This usually involves an inquiry scan of about 12 seconds, followed\n     * by a page scan of each new device to retrieve its Bluetooth name.\n     * <p>Register for {@link BluetoothDevice#ACTION_FOUND} to be notified as\n     * remote Bluetooth devices are found.\n     * <p>Device discovery is a heavyweight procedure. New connections to\n     * remote Bluetooth devices should not be attempted while discovery is in\n     * progress, and existing connections will experience limited bandwidth\n     * and high latency. Use {@link #cancelDiscovery()} to cancel an ongoing\n     * discovery.\n     * <p>Requires {@link android.Manifest.permission#BLUETOOTH} to receive.\n     ",
    "links" : [ "#cancelDiscovery()", "android.bluetooth.BluetoothDevice#ACTION_FOUND", "android.Manifest.permission#BLUETOOTH" ]
  }, {
    "name" : "ACTION_DISCOVERY_FINISHED",
    "type" : "String",
    "comment" : "\n     * Broadcast Action: The local Bluetooth adapter has finished the device\n     * discovery process.\n     * <p>Requires {@link android.Manifest.permission#BLUETOOTH} to receive.\n     ",
    "links" : [ "android.Manifest.permission#BLUETOOTH" ]
  }, {
    "name" : "ACTION_LOCAL_NAME_CHANGED",
    "type" : "String",
    "comment" : "\n     * Broadcast Action: The local Bluetooth adapter has changed its friendly\n     * Bluetooth name.\n     * <p>This name is visible to remote Bluetooth devices.\n     * <p>Always contains the extra field {@link #EXTRA_LOCAL_NAME} containing\n     * the name.\n     * <p>Requires {@link android.Manifest.permission#BLUETOOTH} to receive.\n     ",
    "links" : [ "#EXTRA_LOCAL_NAME", "android.Manifest.permission#BLUETOOTH" ]
  }, {
    "name" : "EXTRA_LOCAL_NAME",
    "type" : "String",
    "comment" : "\n     * Used as a String extra field in {@link #ACTION_LOCAL_NAME_CHANGED}\n     * intents to request the local Bluetooth name.\n     ",
    "links" : [ "#ACTION_LOCAL_NAME_CHANGED" ]
  }, {
    "name" : "ACTION_CONNECTION_STATE_CHANGED",
    "type" : "String",
    "comment" : "\n     * Intent used to broadcast the change in connection state of the local\n     * Bluetooth adapter to a profile of the remote device. When the adapter is\n     * not connected to any profiles of any remote devices and it attempts a\n     * connection to a profile this intent will be sent. Once connected, this intent\n     * will not be sent for any more connection attempts to any profiles of any\n     * remote device. When the adapter disconnects from the last profile its\n     * connected to of any remote device, this intent will be sent.\n     *\n     * <p> This intent is useful for applications that are only concerned about\n     * whether the local adapter is connected to any profile of any device and\n     * are not really concerned about which profile. For example, an application\n     * which displays an icon to display whether Bluetooth is connected or not\n     * can use this intent.\n     *\n     * <p>This intent will have 3 extras:\n     * {@link #EXTRA_CONNECTION_STATE} - The current connection state.\n     * {@link #EXTRA_PREVIOUS_CONNECTION_STATE}- The previous connection state.\n     * {@link BluetoothDevice#EXTRA_DEVICE} - The remote device.\n     *\n     * {@link #EXTRA_CONNECTION_STATE} or {@link #EXTRA_PREVIOUS_CONNECTION_STATE}\n     * can be any of {@link #STATE_DISCONNECTED}, {@link #STATE_CONNECTING},\n     * {@link #STATE_CONNECTED}, {@link #STATE_DISCONNECTING}.\n     *\n     * <p>Requires {@link android.Manifest.permission#BLUETOOTH} to receive.\n     ",
    "links" : [ "#STATE_DISCONNECTED", "#EXTRA_PREVIOUS_CONNECTION_STATE", "#STATE_DISCONNECTING", "android.bluetooth.BluetoothDevice#EXTRA_DEVICE", "#STATE_CONNECTING", "#STATE_CONNECTED", "#EXTRA_CONNECTION_STATE", "android.Manifest.permission#BLUETOOTH" ]
  }, {
    "name" : "EXTRA_CONNECTION_STATE",
    "type" : "String",
    "comment" : "\n     * Extra used by {@link #ACTION_CONNECTION_STATE_CHANGED}\n     *\n     * This extra represents the current connection state.\n     ",
    "links" : [ "#ACTION_CONNECTION_STATE_CHANGED" ]
  }, {
    "name" : "EXTRA_PREVIOUS_CONNECTION_STATE",
    "type" : "String",
    "comment" : "\n     * Extra used by {@link #ACTION_CONNECTION_STATE_CHANGED}\n     *\n     * This extra represents the previous connection state.\n     ",
    "links" : [ "#ACTION_CONNECTION_STATE_CHANGED" ]
  }, {
    "name" : "ACTION_BLE_STATE_CHANGED",
    "type" : "String",
    "comment" : "\n     * Broadcast Action: The Bluetooth adapter state has changed in LE only mode.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "ACTION_BLUETOOTH_ADDRESS_CHANGED",
    "type" : "String",
    "comment" : "\n     * Intent used to broadcast the change in the Bluetooth address\n     * of the local Bluetooth adapter.\n     * <p>Always contains the extra field {@link\n     * #EXTRA_BLUETOOTH_ADDRESS} containing the Bluetooth address.\n     *\n     * Note: only system level processes are allowed to send this\n     * defined broadcast.\n     *\n     * @hide\n     ",
    "links" : [ "#EXTRA_BLUETOOTH_ADDRESS" ]
  }, {
    "name" : "EXTRA_BLUETOOTH_ADDRESS",
    "type" : "String",
    "comment" : "\n     * Used as a String extra field in {@link\n     * #ACTION_BLUETOOTH_ADDRESS_CHANGED} intent to store the local\n     * Bluetooth address.\n     *\n     * @hide\n     ",
    "links" : [ "#ACTION_BLUETOOTH_ADDRESS_CHANGED" ]
  }, {
    "name" : "ACTION_BLE_ACL_CONNECTED",
    "type" : "String",
    "comment" : "\n     * Broadcast Action: The notifys Bluetooth ACL connected event. This will be\n     * by BLE Always on enabled application to know the ACL_CONNECTED event\n     * when Bluetooth state in STATE_BLE_ON. This denotes GATT connection\n     * as Bluetooth LE is the only feature available in STATE_BLE_ON\n     *\n     * This is counterpart of {@link BluetoothDevice#ACTION_ACL_CONNECTED} which\n     * works in Bluetooth state STATE_ON\n     *\n     * @hide\n     ",
    "links" : [ "android.bluetooth.BluetoothDevice#ACTION_ACL_CONNECTED" ]
  }, {
    "name" : "ACTION_BLE_ACL_DISCONNECTED",
    "type" : "String",
    "comment" : "\n     * Broadcast Action: The notifys Bluetooth ACL connected event. This will be\n     * by BLE Always on enabled application to know the ACL_DISCONNECTED event\n     * when Bluetooth state in STATE_BLE_ON. This denotes GATT disconnection as Bluetooth\n     * LE is the only feature available in STATE_BLE_ON\n     *\n     * This is counterpart of {@link BluetoothDevice#ACTION_ACL_DISCONNECTED} which\n     * works in Bluetooth state STATE_ON\n     *\n     * @hide\n     ",
    "links" : [ "android.bluetooth.BluetoothDevice#ACTION_ACL_DISCONNECTED" ]
  }, {
    "name" : "STATE_DISCONNECTED",
    "type" : "int",
    "comment" : " The profile is in disconnected state ",
    "links" : [ ]
  }, {
    "name" : "STATE_CONNECTING",
    "type" : "int",
    "comment" : " The profile is in connecting state ",
    "links" : [ ]
  }, {
    "name" : "STATE_CONNECTED",
    "type" : "int",
    "comment" : " The profile is in connected state ",
    "links" : [ ]
  }, {
    "name" : "STATE_DISCONNECTING",
    "type" : "int",
    "comment" : " The profile is in disconnecting state ",
    "links" : [ ]
  }, {
    "name" : "BLUETOOTH_MANAGER_SERVICE",
    "type" : "String",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "mToken",
    "type" : "IBinder",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "SOCKET_CHANNEL_AUTO_STATIC_NO_SDP",
    "type" : "int",
    "comment" : "\n     * When creating a ServerSocket using listenUsingRfcommOn() or\n     * listenUsingL2capOn() use SOCKET_CHANNEL_AUTO_STATIC to create\n     * a ServerSocket that auto assigns a channel number to the first\n     * bluetooth socket.\n     * The channel number assigned to this first Bluetooth Socket will\n     * be stored in the ServerSocket, and reused for subsequent Bluetooth\n     * sockets.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "ADDRESS_LENGTH",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "sAdapter",
    "type" : "BluetoothAdapter",
    "comment" : "\n     * Lazily initialized singleton. Guaranteed final after first object\n     * constructed.\n     ",
    "links" : [ ]
  }, {
    "name" : "sBluetoothLeScanner",
    "type" : "BluetoothLeScanner",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "sBluetoothLeAdvertiser",
    "type" : "BluetoothLeAdvertiser",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "sPeriodicAdvertisingManager",
    "type" : "PeriodicAdvertisingManager",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mManagerService",
    "type" : "IBluetoothManager",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mService",
    "type" : "IBluetooth",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mContext",
    "type" : "Context",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mServiceLock",
    "type" : "ReentrantReadWriteLock",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mLock",
    "type" : "Object",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mLeScanClients",
    "type" : "Map<LeScanCallback, ScanCallback>",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "sMetadataListeners",
    "type" : "Map<BluetoothDevice, List<Pair<OnMetadataChangedListener, Executor>>>",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "sBluetoothMetadataListener",
    "type" : "IBluetoothMetadataListener",
    "comment" : "\n     * Bluetooth metadata listener. Overrides the default BluetoothMetadataListener\n     * implementation.\n     ",
    "links" : [ ]
  }, {
    "name" : "BLUETOOTH_GET_STATE_CACHE_PROPERTY",
    "type" : "String",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mBluetoothGetStateCache",
    "type" : "PropertyInvalidatedCache<Void, Integer>",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "BLUETOOTH_FILTERING_CACHE_PROPERTY",
    "type" : "String",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mBluetoothFilteringCache",
    "type" : "PropertyInvalidatedCache<Void, Boolean>",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "BLUETOOTH_PROFILE_CACHE_PROPERTY",
    "type" : "String",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mGetProfileConnectionStateCache",
    "type" : "PropertyInvalidatedCache<Integer, Integer>",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mManagerCallback",
    "type" : "IBluetoothManagerCallback",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mProxyServiceStateCallbacks",
    "type" : "ArrayList<IBluetoothManagerCallback>",
    "comment" : "",
    "links" : [ ]
  } ],
  "methods" : [ {
    "name" : "public static String nameForState(@AdapterState int state)",
    "returnType" : "String",
    "comment" : "\n     * Human-readable string helper for AdapterState\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public static synchronized BluetoothAdapter getDefaultAdapter()",
    "returnType" : "BluetoothAdapter",
    "comment" : "\n     * Get a handle to the default local Bluetooth adapter.\n     * <p>Currently Android only supports one Bluetooth adapter, but the API\n     * could be extended to support more. This will always return the default\n     * adapter.\n     * </p>\n     *\n     * @return the default local adapter, or null if Bluetooth is not supported on this hardware\n     * platform\n     ",
    "links" : [ ]
  }, {
    "name" : "public BluetoothDevice getRemoteDevice(String address)",
    "returnType" : "BluetoothDevice",
    "comment" : "\n     * Get a {@link BluetoothDevice} object for the given Bluetooth hardware\n     * address.\n     * <p>Valid Bluetooth hardware addresses must be upper case, in a format\n     * such as \"00:11:22:33:AA:BB\". The helper {@link #checkBluetoothAddress} is\n     * available to validate a Bluetooth address.\n     * <p>A {@link BluetoothDevice} will always be returned for a valid\n     * hardware address, even if this adapter has never seen that device.\n     *\n     * @param address valid Bluetooth MAC address\n     * @throws IllegalArgumentException if address is invalid\n     ",
    "links" : [ "android.bluetooth.BluetoothDevice", "#checkBluetoothAddress" ]
  }, {
    "name" : "public BluetoothDevice getRemoteDevice(byte[] address)",
    "returnType" : "BluetoothDevice",
    "comment" : "\n     * Get a {@link BluetoothDevice} object for the given Bluetooth hardware\n     * address.\n     * <p>Valid Bluetooth hardware addresses must be 6 bytes. This method\n     * expects the address in network byte order (MSB first).\n     * <p>A {@link BluetoothDevice} will always be returned for a valid\n     * hardware address, even if this adapter has never seen that device.\n     *\n     * @param address Bluetooth MAC address (6 bytes)\n     * @throws IllegalArgumentException if address is invalid\n     ",
    "links" : [ "android.bluetooth.BluetoothDevice" ]
  }, {
    "name" : "public BluetoothLeAdvertiser getBluetoothLeAdvertiser()",
    "returnType" : "BluetoothLeAdvertiser",
    "comment" : "\n     * Returns a {@link BluetoothLeAdvertiser} object for Bluetooth LE Advertising operations.\n     * Will return null if Bluetooth is turned off or if Bluetooth LE Advertising is not\n     * supported on this device.\n     * <p>\n     * Use {@link #isMultipleAdvertisementSupported()} to check whether LE Advertising is supported\n     * on this device before calling this method.\n     ",
    "links" : [ "android.bluetooth.le.BluetoothLeAdvertiser", "#isMultipleAdvertisementSupported()" ]
  }, {
    "name" : "public PeriodicAdvertisingManager getPeriodicAdvertisingManager()",
    "returnType" : "PeriodicAdvertisingManager",
    "comment" : "\n     * Returns a {@link PeriodicAdvertisingManager} object for Bluetooth LE Periodic Advertising\n     * operations. Will return null if Bluetooth is turned off or if Bluetooth LE Periodic\n     * Advertising is not supported on this device.\n     * <p>\n     * Use {@link #isLePeriodicAdvertisingSupported()} to check whether LE Periodic Advertising is\n     * supported on this device before calling this method.\n     *\n     * @hide\n     ",
    "links" : [ "android.bluetooth.le.PeriodicAdvertisingManager", "#isLePeriodicAdvertisingSupported()" ]
  }, {
    "name" : "public BluetoothLeScanner getBluetoothLeScanner()",
    "returnType" : "BluetoothLeScanner",
    "comment" : "\n     * Returns a {@link BluetoothLeScanner} object for Bluetooth LE scan operations.\n     ",
    "links" : [ "android.bluetooth.le.BluetoothLeScanner" ]
  }, {
    "name" : "public boolean isEnabled()",
    "returnType" : "boolean",
    "comment" : "\n     * Return true if Bluetooth is currently enabled and ready for use.\n     * <p>Equivalent to:\n     * <code>getBluetoothState() == STATE_ON</code>\n     *\n     * @return true if the local adapter is turned on\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean isLeEnabled()",
    "returnType" : "boolean",
    "comment" : "\n     * Return true if Bluetooth LE(Always BLE On feature) is currently\n     * enabled and ready for use\n     * <p>This returns true if current state is either STATE_ON or STATE_BLE_ON\n     *\n     * @return true if the local Bluetooth LE adapter is turned on\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean disableBLE()",
    "returnType" : "boolean",
    "comment" : "\n     * Turns off Bluetooth LE which was earlier turned on by calling enableBLE().\n     *\n     * <p> If the internal Adapter state is STATE_BLE_ON, this would trigger the transition\n     * to STATE_OFF and completely shut-down Bluetooth\n     *\n     * <p> If the Adapter state is STATE_ON, This would unregister the existance of\n     * special Bluetooth LE application and hence the further turning off of Bluetooth\n     * from UI would ensure the complete turn-off of Bluetooth rather than staying back\n     * BLE only state\n     *\n     * <p>This is an asynchronous call: it will return immediately, and\n     * clients should listen for {@link #ACTION_BLE_STATE_CHANGED}\n     * to be notified of subsequent adapter state changes If this call returns\n     * true, then the adapter state will immediately transition from {@link\n     * #STATE_ON} to {@link #STATE_TURNING_OFF}, and some time\n     * later transition to either {@link #STATE_BLE_ON} or {@link\n     * #STATE_OFF} based on the existance of the further Always BLE ON enabled applications\n     * If this call returns false then there was an\n     * immediate problem that will prevent the QAdapter from being turned off -\n     * such as the QAadapter already being turned off.\n     *\n     * @return true to indicate success, or false on immediate error\n     * @hide\n     ",
    "links" : [ "#STATE_TURNING_OFF", "#STATE_ON", "#ACTION_BLE_STATE_CHANGED", "#STATE_BLE_ON", "#STATE_OFF" ]
  }, {
    "name" : "public boolean enableBLE()",
    "returnType" : "boolean",
    "comment" : "\n     * Applications who want to only use Bluetooth Low Energy (BLE) can call enableBLE.\n     *\n     * enableBLE registers the existence of an app using only LE functions.\n     *\n     * enableBLE may enable Bluetooth to an LE only mode so that an app can use\n     * LE related features (BluetoothGatt or BluetoothGattServer classes)\n     *\n     * If the user disables Bluetooth while an app is registered to use LE only features,\n     * Bluetooth will remain on in LE only mode for the app.\n     *\n     * When Bluetooth is in LE only mode, it is not shown as ON to the UI.\n     *\n     * <p>This is an asynchronous call: it returns immediately, and\n     * clients should listen for {@link #ACTION_BLE_STATE_CHANGED}\n     * to be notified of adapter state changes.\n     *\n     * If this call returns * true, then the adapter state is either in a mode where\n     * LE is available, or will transition from {@link #STATE_OFF} to {@link #STATE_BLE_TURNING_ON},\n     * and some time later transition to either {@link #STATE_OFF} or {@link #STATE_BLE_ON}.\n     *\n     * If this call returns false then there was an immediate problem that prevents the\n     * adapter from being turned on - such as Airplane mode.\n     *\n     * {@link #ACTION_BLE_STATE_CHANGED} returns the Bluetooth Adapter's various\n     * states, It includes all the classic Bluetooth Adapter states along with\n     * internal BLE only states\n     *\n     * @return true to indicate Bluetooth LE will be available, or false on immediate error\n     * @hide\n     ",
    "links" : [ "#ACTION_BLE_STATE_CHANGED", "#STATE_BLE_TURNING_ON", "#STATE_OFF", "#STATE_BLE_ON" ]
  }, {
    "name" : "public void disableBluetoothGetStateCache()",
    "returnType" : "void",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "public static void invalidateBluetoothGetStateCache()",
    "returnType" : "void",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "private int getStateInternal()",
    "returnType" : "int",
    "comment" : "\n     * Fetch the current bluetooth state.  If the service is down, return\n     * OFF.\n     ",
    "links" : [ ]
  }, {
    "name" : "public int getState()",
    "returnType" : "int",
    "comment" : "\n     * Get the current state of the local Bluetooth adapter.\n     * <p>Possible return values are\n     * {@link #STATE_OFF},\n     * {@link #STATE_TURNING_ON},\n     * {@link #STATE_ON},\n     * {@link #STATE_TURNING_OFF}.\n     *\n     * @return current state of Bluetooth adapter\n     ",
    "links" : [ "#STATE_TURNING_OFF", "#STATE_TURNING_ON", "#STATE_ON", "#STATE_OFF" ]
  }, {
    "name" : "public int getLeState()",
    "returnType" : "int",
    "comment" : "\n     * Get the current state of the local Bluetooth adapter\n     * <p>This returns current internal state of Adapter including LE ON/OFF\n     *\n     * <p>Possible return values are\n     * {@link #STATE_OFF},\n     * {@link #STATE_BLE_TURNING_ON},\n     * {@link #STATE_BLE_ON},\n     * {@link #STATE_TURNING_ON},\n     * {@link #STATE_ON},\n     * {@link #STATE_TURNING_OFF},\n     * {@link #STATE_BLE_TURNING_OFF}.\n     *\n     * @return current state of Bluetooth adapter\n     * @hide\n     ",
    "links" : [ "#STATE_TURNING_OFF", "#STATE_TURNING_ON", "#STATE_ON", "#STATE_BLE_TURNING_OFF", "#STATE_BLE_TURNING_ON", "#STATE_OFF", "#STATE_BLE_ON" ]
  }, {
    "name" : " boolean getLeAccess()",
    "returnType" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public boolean enable()",
    "returnType" : "boolean",
    "comment" : "\n     * Turn on the local Bluetooth adapter&mdash;do not use without explicit\n     * user action to turn on Bluetooth.\n     * <p>This powers on the underlying Bluetooth hardware, and starts all\n     * Bluetooth system services.\n     * <p class=\"caution\"><strong>Bluetooth should never be enabled without\n     * direct user consent</strong>. If you want to turn on Bluetooth in order\n     * to create a wireless connection, you should use the {@link\n     * #ACTION_REQUEST_ENABLE} Intent, which will raise a dialog that requests\n     * user permission to turn on Bluetooth. The {@link #enable()} method is\n     * provided only for applications that include a user interface for changing\n     * system settings, such as a \"power manager\" app.</p>\n     * <p>This is an asynchronous call: it will return immediately, and\n     * clients should listen for {@link #ACTION_STATE_CHANGED}\n     * to be notified of subsequent adapter state changes. If this call returns\n     * true, then the adapter state will immediately transition from {@link\n     * #STATE_OFF} to {@link #STATE_TURNING_ON}, and some time\n     * later transition to either {@link #STATE_OFF} or {@link\n     * #STATE_ON}. If this call returns false then there was an\n     * immediate problem that will prevent the adapter from being turned on -\n     * such as Airplane mode, or the adapter is already turned on.\n     *\n     * @return true to indicate adapter startup has begun, or false on immediate error\n     ",
    "links" : [ "#ACTION_REQUEST_ENABLE", "#STATE_TURNING_ON", "#STATE_ON", "#enable()", "#ACTION_STATE_CHANGED", "#STATE_OFF" ]
  }, {
    "name" : "public boolean disable()",
    "returnType" : "boolean",
    "comment" : "\n     * Turn off the local Bluetooth adapter&mdash;do not use without explicit\n     * user action to turn off Bluetooth.\n     * <p>This gracefully shuts down all Bluetooth connections, stops Bluetooth\n     * system services, and powers down the underlying Bluetooth hardware.\n     * <p class=\"caution\"><strong>Bluetooth should never be disabled without\n     * direct user consent</strong>. The {@link #disable()} method is\n     * provided only for applications that include a user interface for changing\n     * system settings, such as a \"power manager\" app.</p>\n     * <p>This is an asynchronous call: it will return immediately, and\n     * clients should listen for {@link #ACTION_STATE_CHANGED}\n     * to be notified of subsequent adapter state changes. If this call returns\n     * true, then the adapter state will immediately transition from {@link\n     * #STATE_ON} to {@link #STATE_TURNING_OFF}, and some time\n     * later transition to either {@link #STATE_OFF} or {@link\n     * #STATE_ON}. If this call returns false then there was an\n     * immediate problem that will prevent the adapter from being turned off -\n     * such as the adapter already being turned off.\n     *\n     * @return true to indicate adapter shutdown has begun, or false on immediate error\n     ",
    "links" : [ "#STATE_TURNING_OFF", "#STATE_ON", "#ACTION_STATE_CHANGED", "#STATE_OFF", "#disable()" ]
  }, {
    "name" : "public boolean disable(boolean persist)",
    "returnType" : "boolean",
    "comment" : "\n     * Turn off the local Bluetooth adapter and don't persist the setting.\n     *\n     * <p>Requires the {@link android.Manifest.permission#BLUETOOTH_ADMIN}\n     * permission\n     *\n     * @return true to indicate adapter shutdown has begun, or false on immediate error\n     * @hide\n     ",
    "links" : [ "android.Manifest.permission#BLUETOOTH_ADMIN" ]
  }, {
    "name" : "public String getAddress()",
    "returnType" : "String",
    "comment" : "\n     * Returns the hardware address of the local Bluetooth adapter.\n     * <p>For example, \"00:11:22:AA:BB:CC\".\n     *\n     * @return Bluetooth hardware address as string\n     ",
    "links" : [ ]
  }, {
    "name" : "public String getName()",
    "returnType" : "String",
    "comment" : "\n     * Get the friendly Bluetooth name of the local Bluetooth adapter.\n     * <p>This name is visible to remote Bluetooth devices.\n     * <p>Requires {@link android.Manifest.permission#BLUETOOTH}\n     *\n     * @return the Bluetooth name, or null on error\n     ",
    "links" : [ "android.Manifest.permission#BLUETOOTH" ]
  }, {
    "name" : "public boolean factoryReset()",
    "returnType" : "boolean",
    "comment" : "\n     * Factory reset bluetooth settings.\n     *\n     * @return true to indicate that the config file was successfully cleared\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public ParcelUuid[] getUuids()",
    "returnType" : "ParcelUuid[]",
    "comment" : "\n     * Get the UUIDs supported by the local Bluetooth adapter.\n     *\n     * @return the UUIDs supported by the local Bluetooth Adapter.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean setName(String name)",
    "returnType" : "boolean",
    "comment" : "\n     * Set the friendly Bluetooth name of the local Bluetooth adapter.\n     * <p>This name is visible to remote Bluetooth devices.\n     * <p>Valid Bluetooth names are a maximum of 248 bytes using UTF-8\n     * encoding, although many remote devices can only display the first\n     * 40 characters, and some may be limited to just 20.\n     * <p>If Bluetooth state is not {@link #STATE_ON}, this API\n     * will return false. After turning on Bluetooth,\n     * wait for {@link #ACTION_STATE_CHANGED} with {@link #STATE_ON}\n     * to get the updated value.\n     *\n     * @param name a valid Bluetooth name\n     * @return true if the name was set, false otherwise\n     ",
    "links" : [ "#STATE_ON", "#ACTION_STATE_CHANGED" ]
  }, {
    "name" : "public BluetoothClass getBluetoothClass()",
    "returnType" : "BluetoothClass",
    "comment" : "\n     * Returns the {@link BluetoothClass} Bluetooth Class of Device (CoD) of the local Bluetooth\n     * adapter.\n     *\n     * @return {@link BluetoothClass} Bluetooth CoD of local Bluetooth device.\n     *\n     * @hide\n     ",
    "links" : [ "android.bluetooth.BluetoothClass" ]
  }, {
    "name" : "public boolean setBluetoothClass(BluetoothClass bluetoothClass)",
    "returnType" : "boolean",
    "comment" : "\n     * Sets the {@link BluetoothClass} Bluetooth Class of Device (CoD) of the local Bluetooth\n     * adapter.\n     *\n     * <p>Note: This value persists across system reboot.\n     *\n     * @param bluetoothClass {@link BluetoothClass} to set the local Bluetooth adapter to.\n     * @return true if successful, false if unsuccessful.\n     *\n     * @hide\n     ",
    "links" : [ "android.bluetooth.BluetoothClass" ]
  }, {
    "name" : "public int getIoCapability()",
    "returnType" : "int",
    "comment" : "\n     * Returns the Input/Output capability of the device for classic Bluetooth.\n     *\n     * @return Input/Output capability of the device. One of {@link #IO_CAPABILITY_OUT},\n     *         {@link #IO_CAPABILITY_IO}, {@link #IO_CAPABILITY_IN}, {@link #IO_CAPABILITY_NONE},\n     *         {@link #IO_CAPABILITY_KBDISP} or {@link #IO_CAPABILITY_UNKNOWN}.\n     *\n     * @hide\n     ",
    "links" : [ "#IO_CAPABILITY_IO", "#IO_CAPABILITY_IN", "#IO_CAPABILITY_OUT", "#IO_CAPABILITY_UNKNOWN", "#IO_CAPABILITY_NONE", "#IO_CAPABILITY_KBDISP" ]
  }, {
    "name" : "public boolean setIoCapability(@IoCapability int capability)",
    "returnType" : "boolean",
    "comment" : "\n     * Sets the Input/Output capability of the device for classic Bluetooth.\n     *\n     * <p>Changing the Input/Output capability of a device only takes effect on restarting the\n     * Bluetooth stack. You would need to restart the stack using {@link BluetoothAdapter#disable()}\n     * and {@link BluetoothAdapter#enable()} to see the changes.\n     *\n     * @param capability Input/Output capability of the device. One of {@link #IO_CAPABILITY_OUT},\n     *                   {@link #IO_CAPABILITY_IO}, {@link #IO_CAPABILITY_IN},\n     *                   {@link #IO_CAPABILITY_NONE} or {@link #IO_CAPABILITY_KBDISP}.\n     *\n     * @hide\n     ",
    "links" : [ "#IO_CAPABILITY_IO", "#IO_CAPABILITY_IN", "android.bluetooth.BluetoothAdapter#enable()", "#IO_CAPABILITY_OUT", "#IO_CAPABILITY_NONE", "android.bluetooth.BluetoothAdapter#disable()", "#IO_CAPABILITY_KBDISP" ]
  }, {
    "name" : "public int getLeIoCapability()",
    "returnType" : "int",
    "comment" : "\n     * Returns the Input/Output capability of the device for BLE operations.\n     *\n     * @return Input/Output capability of the device. One of {@link #IO_CAPABILITY_OUT},\n     *         {@link #IO_CAPABILITY_IO}, {@link #IO_CAPABILITY_IN}, {@link #IO_CAPABILITY_NONE},\n     *         {@link #IO_CAPABILITY_KBDISP} or {@link #IO_CAPABILITY_UNKNOWN}.\n     *\n     * @hide\n     ",
    "links" : [ "#IO_CAPABILITY_IO", "#IO_CAPABILITY_IN", "#IO_CAPABILITY_OUT", "#IO_CAPABILITY_UNKNOWN", "#IO_CAPABILITY_NONE", "#IO_CAPABILITY_KBDISP" ]
  }, {
    "name" : "public boolean setLeIoCapability(@IoCapability int capability)",
    "returnType" : "boolean",
    "comment" : "\n     * Sets the Input/Output capability of the device for BLE operations.\n     *\n     * <p>Changing the Input/Output capability of a device only takes effect on restarting the\n     * Bluetooth stack. You would need to restart the stack using {@link BluetoothAdapter#disable()}\n     * and {@link BluetoothAdapter#enable()} to see the changes.\n     *\n     * @param capability Input/Output capability of the device. One of {@link #IO_CAPABILITY_OUT},\n     *                   {@link #IO_CAPABILITY_IO}, {@link #IO_CAPABILITY_IN},\n     *                   {@link #IO_CAPABILITY_NONE} or {@link #IO_CAPABILITY_KBDISP}.\n     *\n     * @hide\n     ",
    "links" : [ "#IO_CAPABILITY_IO", "#IO_CAPABILITY_IN", "android.bluetooth.BluetoothAdapter#enable()", "#IO_CAPABILITY_OUT", "#IO_CAPABILITY_NONE", "android.bluetooth.BluetoothAdapter#disable()", "#IO_CAPABILITY_KBDISP" ]
  }, {
    "name" : "public int getScanMode()",
    "returnType" : "int",
    "comment" : "\n     * Get the current Bluetooth scan mode of the local Bluetooth adapter.\n     * <p>The Bluetooth scan mode determines if the local adapter is\n     * connectable and/or discoverable from remote Bluetooth devices.\n     * <p>Possible values are:\n     * {@link #SCAN_MODE_NONE},\n     * {@link #SCAN_MODE_CONNECTABLE},\n     * {@link #SCAN_MODE_CONNECTABLE_DISCOVERABLE}.\n     * <p>If Bluetooth state is not {@link #STATE_ON}, this API\n     * will return {@link #SCAN_MODE_NONE}. After turning on Bluetooth,\n     * wait for {@link #ACTION_STATE_CHANGED} with {@link #STATE_ON}\n     * to get the updated value.\n     *\n     * @return scan mode\n     ",
    "links" : [ "#SCAN_MODE_NONE", "#STATE_ON", "#SCAN_MODE_CONNECTABLE", "#ACTION_STATE_CHANGED", "#SCAN_MODE_CONNECTABLE_DISCOVERABLE" ]
  }, {
    "name" : "public boolean setScanMode(@ScanMode int mode, long durationMillis)",
    "returnType" : "boolean",
    "comment" : "\n     * Set the Bluetooth scan mode of the local Bluetooth adapter.\n     * <p>The Bluetooth scan mode determines if the local adapter is\n     * connectable and/or discoverable from remote Bluetooth devices.\n     * <p>For privacy reasons, discoverable mode is automatically turned off\n     * after <code>durationMillis</code> milliseconds. For example, 120000 milliseconds should be\n     * enough for a remote device to initiate and complete its discovery process.\n     * <p>Valid scan mode values are:\n     * {@link #SCAN_MODE_NONE},\n     * {@link #SCAN_MODE_CONNECTABLE},\n     * {@link #SCAN_MODE_CONNECTABLE_DISCOVERABLE}.\n     * <p>If Bluetooth state is not {@link #STATE_ON}, this API\n     * will return false. After turning on Bluetooth,\n     * wait for {@link #ACTION_STATE_CHANGED} with {@link #STATE_ON}\n     * to get the updated value.\n     * <p>Applications cannot set the scan mode. They should use\n     * <code>startActivityForResult(\n     * BluetoothAdapter.ACTION_REQUEST_DISCOVERABLE})\n     * </code>instead.\n     *\n     * @param mode valid scan mode\n     * @param durationMillis time in milliseconds to apply scan mode, only used for {@link\n     * #SCAN_MODE_CONNECTABLE_DISCOVERABLE}\n     * @return true if the scan mode was set, false otherwise\n     * @hide\n     ",
    "links" : [ "#SCAN_MODE_NONE", "#STATE_ON", "#SCAN_MODE_CONNECTABLE", "#ACTION_STATE_CHANGED", "#SCAN_MODE_CONNECTABLE_DISCOVERABLE" ]
  }, {
    "name" : "public boolean setScanMode(@ScanMode int mode)",
    "returnType" : "boolean",
    "comment" : "\n     * Set the Bluetooth scan mode of the local Bluetooth adapter.\n     * <p>The Bluetooth scan mode determines if the local adapter is\n     * connectable and/or discoverable from remote Bluetooth devices.\n     * <p>For privacy reasons, discoverable mode is automatically turned off\n     * after <code>duration</code> seconds. For example, 120 seconds should be\n     * enough for a remote device to initiate and complete its discovery\n     * process.\n     * <p>Valid scan mode values are:\n     * {@link #SCAN_MODE_NONE},\n     * {@link #SCAN_MODE_CONNECTABLE},\n     * {@link #SCAN_MODE_CONNECTABLE_DISCOVERABLE}.\n     * <p>If Bluetooth state is not {@link #STATE_ON}, this API\n     * will return false. After turning on Bluetooth,\n     * wait for {@link #ACTION_STATE_CHANGED} with {@link #STATE_ON}\n     * to get the updated value.\n     * <p>Applications cannot set the scan mode. They should use\n     * <code>startActivityForResult(\n     * BluetoothAdapter.ACTION_REQUEST_DISCOVERABLE})\n     * </code>instead.\n     *\n     * @param mode valid scan mode\n     * @return true if the scan mode was set, false otherwise\n     * @hide\n     ",
    "links" : [ "#SCAN_MODE_NONE", "#STATE_ON", "#SCAN_MODE_CONNECTABLE", "#ACTION_STATE_CHANGED", "#SCAN_MODE_CONNECTABLE_DISCOVERABLE" ]
  }, {
    "name" : "public int getDiscoverableTimeout()",
    "returnType" : "int",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "public void setDiscoverableTimeout(int timeout)",
    "returnType" : "void",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "public long getDiscoveryEndMillis()",
    "returnType" : "long",
    "comment" : "\n     * Get the end time of the latest remote device discovery process.\n     *\n     * @return the latest time that the bluetooth adapter was/will be in discovery mode, in\n     * milliseconds since the epoch. This time can be in the future if {@link #startDiscovery()} has\n     * been called recently.\n     * @hide\n     ",
    "links" : [ "#startDiscovery()" ]
  }, {
    "name" : "public void setContext(Context context)",
    "returnType" : "void",
    "comment" : "\n     * Set the context for this BluetoothAdapter (only called from BluetoothManager)\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "private String getOpPackageName()",
    "returnType" : "String",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private String getAttributionTag()",
    "returnType" : "String",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public boolean startDiscovery()",
    "returnType" : "boolean",
    "comment" : "\n     * Start the remote device discovery process.\n     * <p>The discovery process usually involves an inquiry scan of about 12\n     * seconds, followed by a page scan of each new device to retrieve its\n     * Bluetooth name.\n     * <p>This is an asynchronous call, it will return immediately. Register\n     * for {@link #ACTION_DISCOVERY_STARTED} and {@link\n     * #ACTION_DISCOVERY_FINISHED} intents to determine exactly when the\n     * discovery starts and completes. Register for {@link\n     * BluetoothDevice#ACTION_FOUND} to be notified as remote Bluetooth devices\n     * are found.\n     * <p>Device discovery is a heavyweight procedure. New connections to\n     * remote Bluetooth devices should not be attempted while discovery is in\n     * progress, and existing connections will experience limited bandwidth\n     * and high latency. Use {@link #cancelDiscovery()} to cancel an ongoing\n     * discovery. Discovery is not managed by the Activity,\n     * but is run as a system service, so an application should always call\n     * {@link BluetoothAdapter#cancelDiscovery()} even if it\n     * did not directly request a discovery, just to be sure.\n     * <p>Device discovery will only find remote devices that are currently\n     * <i>discoverable</i> (inquiry scan enabled). Many Bluetooth devices are\n     * not discoverable by default, and need to be entered into a special mode.\n     * <p>If Bluetooth state is not {@link #STATE_ON}, this API\n     * will return false. After turning on Bluetooth,\n     * wait for {@link #ACTION_STATE_CHANGED} with {@link #STATE_ON}\n     * to get the updated value.\n     *\n     * @return true on success, false on error\n     ",
    "links" : [ "#ACTION_DISCOVERY_FINISHED", "#STATE_ON", "android.bluetooth.BluetoothAdapter#cancelDiscovery()", "#cancelDiscovery()", "#ACTION_DISCOVERY_STARTED", "#ACTION_STATE_CHANGED", "android.bluetooth.BluetoothDevice#ACTION_FOUND" ]
  }, {
    "name" : "public boolean cancelDiscovery()",
    "returnType" : "boolean",
    "comment" : "\n     * Cancel the current device discovery process.\n     * <p>Because discovery is a heavyweight procedure for the Bluetooth\n     * adapter, this method should always be called before attempting to connect\n     * to a remote device with {@link\n     * android.bluetooth.BluetoothSocket#connect()}. Discovery is not managed by\n     * the  Activity, but is run as a system service, so an application should\n     * always call cancel discovery even if it did not directly request a\n     * discovery, just to be sure.\n     * <p>If Bluetooth state is not {@link #STATE_ON}, this API\n     * will return false. After turning on Bluetooth,\n     * wait for {@link #ACTION_STATE_CHANGED} with {@link #STATE_ON}\n     * to get the updated value.\n     *\n     * @return true on success, false on error\n     ",
    "links" : [ "#STATE_ON", "android.bluetooth.BluetoothSocket#connect()", "#ACTION_STATE_CHANGED" ]
  }, {
    "name" : "public boolean isDiscovering()",
    "returnType" : "boolean",
    "comment" : "\n     * Return true if the local Bluetooth adapter is currently in the device\n     * discovery process.\n     * <p>Device discovery is a heavyweight procedure. New connections to\n     * remote Bluetooth devices should not be attempted while discovery is in\n     * progress, and existing connections will experience limited bandwidth\n     * and high latency. Use {@link #cancelDiscovery()} to cancel an ongoing\n     * discovery.\n     * <p>Applications can also register for {@link #ACTION_DISCOVERY_STARTED}\n     * or {@link #ACTION_DISCOVERY_FINISHED} to be notified when discovery\n     * starts or completes.\n     * <p>If Bluetooth state is not {@link #STATE_ON}, this API\n     * will return false. After turning on Bluetooth,\n     * wait for {@link #ACTION_STATE_CHANGED} with {@link #STATE_ON}\n     * to get the updated value.\n     *\n     * @return true if discovering\n     ",
    "links" : [ "#ACTION_DISCOVERY_FINISHED", "#STATE_ON", "#cancelDiscovery()", "#ACTION_DISCOVERY_STARTED", "#ACTION_STATE_CHANGED" ]
  }, {
    "name" : "public boolean removeActiveDevice(@ActiveDeviceUse int profiles)",
    "returnType" : "boolean",
    "comment" : "\n     * Removes the active device for the grouping of @ActiveDeviceUse specified\n     *\n     * @param profiles represents the purpose for which we are setting this as the active device.\n     *                 Possible values are:\n     *                 {@link BluetoothAdapter#ACTIVE_DEVICE_AUDIO},\n     *                 {@link BluetoothAdapter#ACTIVE_DEVICE_PHONE_CALL},\n     *                 {@link BluetoothAdapter#ACTIVE_DEVICE_ALL}\n     * @return false on immediate error, true otherwise\n     * @throws IllegalArgumentException if device is null or profiles is not one of\n     * {@link ActiveDeviceUse}\n     * @hide\n     ",
    "links" : [ "android.bluetooth.BluetoothAdapter#ACTIVE_DEVICE_AUDIO", "android.bluetooth.BluetoothAdapter#ACTIVE_DEVICE_ALL", "ActiveDeviceUse", "android.bluetooth.BluetoothAdapter#ACTIVE_DEVICE_PHONE_CALL" ]
  }, {
    "name" : "public boolean setActiveDevice(@NonNull BluetoothDevice device, @ActiveDeviceUse int profiles)",
    "returnType" : "boolean",
    "comment" : "\n     * Sets device as the active devices for the profiles passed into the function\n     *\n     * @param device is the remote bluetooth device\n     * @param profiles represents the purpose for which we are setting this as the active device.\n     *                 Possible values are:\n     *                 {@link BluetoothAdapter#ACTIVE_DEVICE_AUDIO},\n     *                 {@link BluetoothAdapter#ACTIVE_DEVICE_PHONE_CALL},\n     *                 {@link BluetoothAdapter#ACTIVE_DEVICE_ALL}\n     * @return false on immediate error, true otherwise\n     * @throws IllegalArgumentException if device is null or profiles is not one of\n     * {@link ActiveDeviceUse}\n     * @hide\n     ",
    "links" : [ "android.bluetooth.BluetoothAdapter#ACTIVE_DEVICE_AUDIO", "android.bluetooth.BluetoothAdapter#ACTIVE_DEVICE_ALL", "ActiveDeviceUse", "android.bluetooth.BluetoothAdapter#ACTIVE_DEVICE_PHONE_CALL" ]
  }, {
    "name" : "public boolean connectAllEnabledProfiles(@NonNull BluetoothDevice device)",
    "returnType" : "boolean",
    "comment" : "\n     * Connects all enabled and supported bluetooth profiles between the local and remote device.\n     * Connection is asynchronous and you should listen to each profile's broadcast intent\n     * ACTION_CONNECTION_STATE_CHANGED to verify whether connection was successful. For example,\n     * to verify a2dp is connected, you would listen for\n     * {@link BluetoothA2dp#ACTION_CONNECTION_STATE_CHANGED}\n     *\n     * @param device is the remote device with which to connect these profiles\n     * @return true if message sent to try to connect all profiles, false if an error occurred\n     *\n     * @hide\n     ",
    "links" : [ "android.bluetooth.BluetoothA2dp#ACTION_CONNECTION_STATE_CHANGED" ]
  }, {
    "name" : "public boolean disconnectAllEnabledProfiles(@NonNull BluetoothDevice device)",
    "returnType" : "boolean",
    "comment" : "\n     * Disconnects all enabled and supported bluetooth profiles between the local and remote device.\n     * Disconnection is asynchronous and you should listen to each profile's broadcast intent\n     * ACTION_CONNECTION_STATE_CHANGED to verify whether disconnection was successful. For example,\n     * to verify a2dp is disconnected, you would listen for\n     * {@link BluetoothA2dp#ACTION_CONNECTION_STATE_CHANGED}\n     *\n     * @param device is the remote device with which to disconnect these profiles\n     * @return true if message sent to try to disconnect all profiles, false if an error occurred\n     *\n     * @hide\n     ",
    "links" : [ "android.bluetooth.BluetoothA2dp#ACTION_CONNECTION_STATE_CHANGED" ]
  }, {
    "name" : "public boolean isMultipleAdvertisementSupported()",
    "returnType" : "boolean",
    "comment" : "\n     * Return true if the multi advertisement is supported by the chipset\n     *\n     * @return true if Multiple Advertisement feature is supported\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean isBleScanAlwaysAvailable()",
    "returnType" : "boolean",
    "comment" : "\n     * Returns {@code true} if BLE scan is always available, {@code false} otherwise. <p>\n     *\n     * If this returns {@code true}, application can issue {@link BluetoothLeScanner#startScan} and\n     * fetch scan results even when Bluetooth is turned off.<p>\n     *\n     * To change this setting, use {@link #ACTION_REQUEST_BLE_SCAN_ALWAYS_AVAILABLE}.\n     *\n     * @hide\n     ",
    "links" : [ "#ACTION_REQUEST_BLE_SCAN_ALWAYS_AVAILABLE", "android.bluetooth.le.BluetoothLeScanner#startScan" ]
  }, {
    "name" : "public void disableIsOffloadedFilteringSupportedCache()",
    "returnType" : "void",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "public static void invalidateIsOffloadedFilteringSupportedCache()",
    "returnType" : "void",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "public boolean isOffloadedFilteringSupported()",
    "returnType" : "boolean",
    "comment" : "\n     * Return true if offloaded filters are supported\n     *\n     * @return true if chipset supports on-chip filtering\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean isOffloadedScanBatchingSupported()",
    "returnType" : "boolean",
    "comment" : "\n     * Return true if offloaded scan batching is supported\n     *\n     * @return true if chipset supports on-chip scan batching\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean isLe2MPhySupported()",
    "returnType" : "boolean",
    "comment" : "\n     * Return true if LE 2M PHY feature is supported.\n     *\n     * @return true if chipset supports LE 2M PHY feature\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean isLeCodedPhySupported()",
    "returnType" : "boolean",
    "comment" : "\n     * Return true if LE Coded PHY feature is supported.\n     *\n     * @return true if chipset supports LE Coded PHY feature\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean isLeExtendedAdvertisingSupported()",
    "returnType" : "boolean",
    "comment" : "\n     * Return true if LE Extended Advertising feature is supported.\n     *\n     * @return true if chipset supports LE Extended Advertising feature\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean isLePeriodicAdvertisingSupported()",
    "returnType" : "boolean",
    "comment" : "\n     * Return true if LE Periodic Advertising feature is supported.\n     *\n     * @return true if chipset supports LE Periodic Advertising feature\n     ",
    "links" : [ ]
  }, {
    "name" : "public int getLeMaximumAdvertisingDataLength()",
    "returnType" : "int",
    "comment" : "\n     * Return the maximum LE advertising data length in bytes,\n     * if LE Extended Advertising feature is supported, 0 otherwise.\n     *\n     * @return the maximum LE advertising data length.\n     ",
    "links" : [ ]
  }, {
    "name" : "private boolean isHearingAidProfileSupported()",
    "returnType" : "boolean",
    "comment" : "\n     * Return true if Hearing Aid Profile is supported.\n     *\n     * @return true if phone supports Hearing Aid Profile\n     ",
    "links" : [ ]
  }, {
    "name" : "public int getMaxConnectedAudioDevices()",
    "returnType" : "int",
    "comment" : "\n     * Get the maximum number of connected audio devices.\n     *\n     * @return the maximum number of connected audio devices\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean isHardwareTrackingFiltersAvailable()",
    "returnType" : "boolean",
    "comment" : "\n     * Return true if hardware has entries available for matching beacons\n     *\n     * @return true if there are hw entries available for matching beacons\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public BluetoothActivityEnergyInfo getControllerActivityEnergyInfo(int updateType)",
    "returnType" : "BluetoothActivityEnergyInfo",
    "comment" : "\n     * Return the record of {@link BluetoothActivityEnergyInfo} object that\n     * has the activity and energy info. This can be used to ascertain what\n     * the controller has been up to, since the last sample.\n     *\n     * @param updateType Type of info, cached vs refreshed.\n     * @return a record with {@link BluetoothActivityEnergyInfo} or null if report is unavailable or\n     * unsupported\n     * @hide\n     * @deprecated use the asynchronous {@link #requestControllerActivityEnergyInfo(ResultReceiver)}\n     * instead.\n     ",
    "links" : [ "#requestControllerActivityEnergyInfo(ResultReceiver)", "android.bluetooth.BluetoothActivityEnergyInfo" ]
  }, {
    "name" : "public void requestControllerActivityEnergyInfo(ResultReceiver result)",
    "returnType" : "void",
    "comment" : "\n     * Request the record of {@link BluetoothActivityEnergyInfo} object that\n     * has the activity and energy info. This can be used to ascertain what\n     * the controller has been up to, since the last sample.\n     *\n     * A null value for the activity info object may be sent if the bluetooth service is\n     * unreachable or the device does not support reporting such information.\n     *\n     * @param result The callback to which to send the activity info.\n     * @hide\n     ",
    "links" : [ "android.bluetooth.BluetoothActivityEnergyInfo" ]
  }, {
    "name" : "public List<BluetoothDevice> getMostRecentlyConnectedDevices()",
    "returnType" : "List<BluetoothDevice>",
    "comment" : "\n     * Fetches a list of the most recently connected bluetooth devices ordered by how recently they\n     * were connected with most recently first and least recently last\n     *\n     * @return {@link List} of bonded {@link BluetoothDevice} ordered by how recently they were\n     * connected\n     *\n     * @hide\n     ",
    "links" : [ "android.bluetooth.BluetoothDevice", "java.util.ArrayList" ]
  }, {
    "name" : "public Set<BluetoothDevice> getBondedDevices()",
    "returnType" : "Set<BluetoothDevice>",
    "comment" : "\n     * Return the set of {@link BluetoothDevice} objects that are bonded\n     * (paired) to the local adapter.\n     * <p>If Bluetooth state is not {@link #STATE_ON}, this API\n     * will return an empty set. After turning on Bluetooth,\n     * wait for {@link #ACTION_STATE_CHANGED} with {@link #STATE_ON}\n     * to get the updated value.\n     *\n     * @return unmodifiable set of {@link BluetoothDevice}, or null on error\n     ",
    "links" : [ "android.bluetooth.BluetoothDevice", "#STATE_ON", "#ACTION_STATE_CHANGED" ]
  }, {
    "name" : "public List<Integer> getSupportedProfiles()",
    "returnType" : "List<Integer>",
    "comment" : "\n     * Gets the currently supported profiles by the adapter.\n     *\n     * <p> This can be used to check whether a profile is supported before attempting\n     * to connect to its respective proxy.\n     *\n     * @return a list of integers indicating the ids of supported profiles as defined in {@link\n     * BluetoothProfile}.\n     * @hide\n     ",
    "links" : [ "android.bluetooth.BluetoothProfile" ]
  }, {
    "name" : "public int getConnectionState()",
    "returnType" : "int",
    "comment" : "\n     * Get the current connection state of the local Bluetooth adapter.\n     * This can be used to check whether the local Bluetooth adapter is connected\n     * to any profile of any other remote Bluetooth Device.\n     *\n     * <p> Use this function along with {@link #ACTION_CONNECTION_STATE_CHANGED}\n     * intent to get the connection state of the adapter.\n     *\n     * @return One of {@link #STATE_CONNECTED}, {@link #STATE_DISCONNECTED}, {@link\n     * #STATE_CONNECTING} or {@link #STATE_DISCONNECTED}\n     * @hide\n     ",
    "links" : [ "#STATE_DISCONNECTED", "#STATE_CONNECTING", "#STATE_CONNECTED", "#ACTION_CONNECTION_STATE_CHANGED" ]
  }, {
    "name" : "public void disableGetProfileConnectionStateCache()",
    "returnType" : "void",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "public static void invalidateGetProfileConnectionStateCache()",
    "returnType" : "void",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "public int getProfileConnectionState(int profile)",
    "returnType" : "int",
    "comment" : "\n     * Get the current connection state of a profile.\n     * This function can be used to check whether the local Bluetooth adapter\n     * is connected to any remote device for a specific profile.\n     * Profile can be one of {@link BluetoothProfile#HEADSET}, {@link BluetoothProfile#A2DP}.\n     *\n     * <p> Return value can be one of\n     * {@link BluetoothProfile#STATE_DISCONNECTED},\n     * {@link BluetoothProfile#STATE_CONNECTING},\n     * {@link BluetoothProfile#STATE_CONNECTED},\n     * {@link BluetoothProfile#STATE_DISCONNECTING}\n     ",
    "links" : [ "android.bluetooth.BluetoothProfile#HEADSET", "android.bluetooth.BluetoothProfile#STATE_CONNECTED", "android.bluetooth.BluetoothProfile#A2DP", "android.bluetooth.BluetoothProfile#STATE_DISCONNECTING", "android.bluetooth.BluetoothProfile#STATE_CONNECTING", "android.bluetooth.BluetoothProfile#STATE_DISCONNECTED" ]
  }, {
    "name" : "public BluetoothServerSocket listenUsingRfcommOn(int channel) throws IOException",
    "returnType" : "BluetoothServerSocket",
    "comment" : "\n     * Create a listening, secure RFCOMM Bluetooth socket.\n     * <p>A remote device connecting to this socket will be authenticated and\n     * communication on this socket will be encrypted.\n     * <p>Use {@link BluetoothServerSocket#accept} to retrieve incoming\n     * connections from a listening {@link BluetoothServerSocket}.\n     * <p>Valid RFCOMM channels are in range 1 to 30.\n     * <p>Requires {@link android.Manifest.permission#BLUETOOTH_ADMIN}\n     *\n     * @param channel RFCOMM channel to listen on\n     * @return a listening RFCOMM BluetoothServerSocket\n     * @throws IOException on error, for example Bluetooth not available, or insufficient\n     * permissions, or channel in use.\n     * @hide\n     ",
    "links" : [ "android.bluetooth.BluetoothServerSocket", "android.bluetooth.BluetoothServerSocket#accept", "android.Manifest.permission#BLUETOOTH_ADMIN" ]
  }, {
    "name" : "public BluetoothServerSocket listenUsingRfcommOn(int channel, boolean mitm, boolean min16DigitPin) throws IOException",
    "returnType" : "BluetoothServerSocket",
    "comment" : "\n     * Create a listening, secure RFCOMM Bluetooth socket.\n     * <p>A remote device connecting to this socket will be authenticated and\n     * communication on this socket will be encrypted.\n     * <p>Use {@link BluetoothServerSocket#accept} to retrieve incoming\n     * connections from a listening {@link BluetoothServerSocket}.\n     * <p>Valid RFCOMM channels are in range 1 to 30.\n     * <p>Requires {@link android.Manifest.permission#BLUETOOTH_ADMIN}\n     * <p>To auto assign a channel without creating a SDP record use\n     * {@link #SOCKET_CHANNEL_AUTO_STATIC_NO_SDP} as channel number.\n     *\n     * @param channel RFCOMM channel to listen on\n     * @param mitm enforce man-in-the-middle protection for authentication.\n     * @param min16DigitPin enforce a pin key length og minimum 16 digit for sec mode 2\n     * connections.\n     * @return a listening RFCOMM BluetoothServerSocket\n     * @throws IOException on error, for example Bluetooth not available, or insufficient\n     * permissions, or channel in use.\n     * @hide\n     ",
    "links" : [ "android.bluetooth.BluetoothServerSocket", "android.bluetooth.BluetoothServerSocket#accept", "#SOCKET_CHANNEL_AUTO_STATIC_NO_SDP", "android.Manifest.permission#BLUETOOTH_ADMIN" ]
  }, {
    "name" : "public BluetoothServerSocket listenUsingRfcommWithServiceRecord(String name, UUID uuid) throws IOException",
    "returnType" : "BluetoothServerSocket",
    "comment" : "\n     * Create a listening, secure RFCOMM Bluetooth socket with Service Record.\n     * <p>A remote device connecting to this socket will be authenticated and\n     * communication on this socket will be encrypted.\n     * <p>Use {@link BluetoothServerSocket#accept} to retrieve incoming\n     * connections from a listening {@link BluetoothServerSocket}.\n     * <p>The system will assign an unused RFCOMM channel to listen on.\n     * <p>The system will also register a Service Discovery\n     * Protocol (SDP) record with the local SDP server containing the specified\n     * UUID, service name, and auto-assigned channel. Remote Bluetooth devices\n     * can use the same UUID to query our SDP server and discover which channel\n     * to connect to. This SDP record will be removed when this socket is\n     * closed, or if this application closes unexpectedly.\n     * <p>Use {@link BluetoothDevice#createRfcommSocketToServiceRecord} to\n     * connect to this socket from another device using the same {@link UUID}.\n     *\n     * @param name service name for SDP record\n     * @param uuid uuid for SDP record\n     * @return a listening RFCOMM BluetoothServerSocket\n     * @throws IOException on error, for example Bluetooth not available, or insufficient\n     * permissions, or channel in use.\n     ",
    "links" : [ "android.bluetooth.BluetoothServerSocket", "android.bluetooth.BluetoothServerSocket#accept", "android.bluetooth.BluetoothDevice#createRfcommSocketToServiceRecord", "java.util.UUID" ]
  }, {
    "name" : "public BluetoothServerSocket listenUsingInsecureRfcommWithServiceRecord(String name, UUID uuid) throws IOException",
    "returnType" : "BluetoothServerSocket",
    "comment" : "\n     * Create a listening, insecure RFCOMM Bluetooth socket with Service Record.\n     * <p>The link key is not required to be authenticated, i.e the communication may be\n     * vulnerable to Man In the Middle attacks. For Bluetooth 2.1 devices,\n     * the link will be encrypted, as encryption is mandartory.\n     * For legacy devices (pre Bluetooth 2.1 devices) the link will not\n     * be encrypted. Use {@link #listenUsingRfcommWithServiceRecord}, if an\n     * encrypted and authenticated communication channel is desired.\n     * <p>Use {@link BluetoothServerSocket#accept} to retrieve incoming\n     * connections from a listening {@link BluetoothServerSocket}.\n     * <p>The system will assign an unused RFCOMM channel to listen on.\n     * <p>The system will also register a Service Discovery\n     * Protocol (SDP) record with the local SDP server containing the specified\n     * UUID, service name, and auto-assigned channel. Remote Bluetooth devices\n     * can use the same UUID to query our SDP server and discover which channel\n     * to connect to. This SDP record will be removed when this socket is\n     * closed, or if this application closes unexpectedly.\n     * <p>Use {@link BluetoothDevice#createRfcommSocketToServiceRecord} to\n     * connect to this socket from another device using the same {@link UUID}.\n     *\n     * @param name service name for SDP record\n     * @param uuid uuid for SDP record\n     * @return a listening RFCOMM BluetoothServerSocket\n     * @throws IOException on error, for example Bluetooth not available, or insufficient\n     * permissions, or channel in use.\n     ",
    "links" : [ "android.bluetooth.BluetoothServerSocket", "android.bluetooth.BluetoothServerSocket#accept", "android.bluetooth.BluetoothDevice#createRfcommSocketToServiceRecord", "#listenUsingRfcommWithServiceRecord", "java.util.UUID" ]
  }, {
    "name" : "public BluetoothServerSocket listenUsingEncryptedRfcommWithServiceRecord(String name, UUID uuid) throws IOException",
    "returnType" : "BluetoothServerSocket",
    "comment" : "\n     * Create a listening, encrypted,\n     * RFCOMM Bluetooth socket with Service Record.\n     * <p>The link will be encrypted, but the link key is not required to be authenticated\n     * i.e the communication is vulnerable to Man In the Middle attacks. Use\n     * {@link #listenUsingRfcommWithServiceRecord}, to ensure an authenticated link key.\n     * <p> Use this socket if authentication of link key is not possible.\n     * For example, for Bluetooth 2.1 devices, if any of the devices does not have\n     * an input and output capability or just has the ability to display a numeric key,\n     * a secure socket connection is not possible and this socket can be used.\n     * Use {@link #listenUsingInsecureRfcommWithServiceRecord}, if encryption is not required.\n     * For Bluetooth 2.1 devices, the link will be encrypted, as encryption is mandartory.\n     * For more details, refer to the Security Model section 5.2 (vol 3) of\n     * Bluetooth Core Specification version 2.1 + EDR.\n     * <p>Use {@link BluetoothServerSocket#accept} to retrieve incoming\n     * connections from a listening {@link BluetoothServerSocket}.\n     * <p>The system will assign an unused RFCOMM channel to listen on.\n     * <p>The system will also register a Service Discovery\n     * Protocol (SDP) record with the local SDP server containing the specified\n     * UUID, service name, and auto-assigned channel. Remote Bluetooth devices\n     * can use the same UUID to query our SDP server and discover which channel\n     * to connect to. This SDP record will be removed when this socket is\n     * closed, or if this application closes unexpectedly.\n     * <p>Use {@link BluetoothDevice#createRfcommSocketToServiceRecord} to\n     * connect to this socket from another device using the same {@link UUID}.\n     * <p>Requires {@link android.Manifest.permission#BLUETOOTH}\n     *\n     * @param name service name for SDP record\n     * @param uuid uuid for SDP record\n     * @return a listening RFCOMM BluetoothServerSocket\n     * @throws IOException on error, for example Bluetooth not available, or insufficient\n     * permissions, or channel in use.\n     * @hide\n     ",
    "links" : [ "android.bluetooth.BluetoothServerSocket", "android.bluetooth.BluetoothServerSocket#accept", "android.bluetooth.BluetoothDevice#createRfcommSocketToServiceRecord", "#listenUsingInsecureRfcommWithServiceRecord", "#listenUsingRfcommWithServiceRecord", "java.util.UUID", "android.Manifest.permission#BLUETOOTH" ]
  }, {
    "name" : "private BluetoothServerSocket createNewRfcommSocketAndRecord(String name, UUID uuid, boolean auth, boolean encrypt) throws IOException",
    "returnType" : "BluetoothServerSocket",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public BluetoothServerSocket listenUsingInsecureRfcommOn(int port) throws IOException",
    "returnType" : "BluetoothServerSocket",
    "comment" : "\n     * Construct an unencrypted, unauthenticated, RFCOMM server socket.\n     * Call #accept to retrieve connections to this socket.\n     *\n     * @return An RFCOMM BluetoothServerSocket\n     * @throws IOException On error, for example Bluetooth not available, or insufficient\n     * permissions.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public BluetoothServerSocket listenUsingEncryptedRfcommOn(int port) throws IOException",
    "returnType" : "BluetoothServerSocket",
    "comment" : "\n     * Construct an encrypted, RFCOMM server socket.\n     * Call #accept to retrieve connections to this socket.\n     *\n     * @return An RFCOMM BluetoothServerSocket\n     * @throws IOException On error, for example Bluetooth not available, or insufficient\n     * permissions.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public static BluetoothServerSocket listenUsingScoOn() throws IOException",
    "returnType" : "BluetoothServerSocket",
    "comment" : "\n     * Construct a SCO server socket.\n     * Call #accept to retrieve connections to this socket.\n     *\n     * @return A SCO BluetoothServerSocket\n     * @throws IOException On error, for example Bluetooth not available, or insufficient\n     * permissions.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public BluetoothServerSocket listenUsingL2capOn(int port, boolean mitm, boolean min16DigitPin) throws IOException",
    "returnType" : "BluetoothServerSocket",
    "comment" : "\n     * Construct an encrypted, authenticated, L2CAP server socket.\n     * Call #accept to retrieve connections to this socket.\n     * <p>To auto assign a port without creating a SDP record use\n     * {@link #SOCKET_CHANNEL_AUTO_STATIC_NO_SDP} as port number.\n     *\n     * @param port the PSM to listen on\n     * @param mitm enforce man-in-the-middle protection for authentication.\n     * @param min16DigitPin enforce a pin key length og minimum 16 digit for sec mode 2\n     * connections.\n     * @return An L2CAP BluetoothServerSocket\n     * @throws IOException On error, for example Bluetooth not available, or insufficient\n     * permissions.\n     * @hide\n     ",
    "links" : [ "#SOCKET_CHANNEL_AUTO_STATIC_NO_SDP" ]
  }, {
    "name" : "public BluetoothServerSocket listenUsingL2capOn(int port) throws IOException",
    "returnType" : "BluetoothServerSocket",
    "comment" : "\n     * Construct an encrypted, authenticated, L2CAP server socket.\n     * Call #accept to retrieve connections to this socket.\n     * <p>To auto assign a port without creating a SDP record use\n     * {@link #SOCKET_CHANNEL_AUTO_STATIC_NO_SDP} as port number.\n     *\n     * @param port the PSM to listen on\n     * @return An L2CAP BluetoothServerSocket\n     * @throws IOException On error, for example Bluetooth not available, or insufficient\n     * permissions.\n     * @hide\n     ",
    "links" : [ "#SOCKET_CHANNEL_AUTO_STATIC_NO_SDP" ]
  }, {
    "name" : "public BluetoothServerSocket listenUsingInsecureL2capOn(int port) throws IOException",
    "returnType" : "BluetoothServerSocket",
    "comment" : "\n     * Construct an insecure L2CAP server socket.\n     * Call #accept to retrieve connections to this socket.\n     * <p>To auto assign a port without creating a SDP record use\n     * {@link #SOCKET_CHANNEL_AUTO_STATIC_NO_SDP} as port number.\n     *\n     * @param port the PSM to listen on\n     * @return An L2CAP BluetoothServerSocket\n     * @throws IOException On error, for example Bluetooth not available, or insufficient\n     * permissions.\n     * @hide\n     ",
    "links" : [ "#SOCKET_CHANNEL_AUTO_STATIC_NO_SDP" ]
  }, {
    "name" : "public Pair<byte[], byte[]> readOutOfBandData()",
    "returnType" : "Pair<byte[], byte[]>",
    "comment" : "\n     * Read the local Out of Band Pairing Data\n     * <p>Requires {@link android.Manifest.permission#BLUETOOTH}\n     *\n     * @return Pair<byte[], byte[]> of Hash and Randomizer\n     * @hide\n     ",
    "links" : [ "android.Manifest.permission#BLUETOOTH" ]
  }, {
    "name" : "public boolean getProfileProxy(Context context, BluetoothProfile.ServiceListener listener, int profile)",
    "returnType" : "boolean",
    "comment" : "\n     * Get the profile proxy object associated with the profile.\n     *\n     * <p>Profile can be one of {@link BluetoothProfile#HEADSET}, {@link BluetoothProfile#A2DP},\n     * {@link BluetoothProfile#GATT}, {@link BluetoothProfile#HEARING_AID}, or {@link\n     * BluetoothProfile#GATT_SERVER}. Clients must implement {@link\n     * BluetoothProfile.ServiceListener} to get notified of the connection status and to get the\n     * proxy object.\n     *\n     * @param context Context of the application\n     * @param listener The service Listener for connection callbacks.\n     * @param profile The Bluetooth profile; either {@link BluetoothProfile#HEADSET},\n     * {@link BluetoothProfile#A2DP}, {@link BluetoothProfile#GATT}, {@link\n     * BluetoothProfile#HEARING_AID} or {@link BluetoothProfile#GATT_SERVER}.\n     * @return true on success, false on error\n     ",
    "links" : [ "android.bluetooth.BluetoothProfile#HEADSET", "android.bluetooth.BluetoothProfile#HEARING_AID", "android.bluetooth.BluetoothProfile#GATT_SERVER", "android.bluetooth.BluetoothProfile#A2DP", "android.bluetooth.BluetoothProfile#GATT", "BluetoothProfile.ServiceListener" ]
  }, {
    "name" : "public void closeProfileProxy(int profile, BluetoothProfile proxy)",
    "returnType" : "void",
    "comment" : "\n     * Close the connection of the profile proxy to the Service.\n     *\n     * <p> Clients should call this when they are no longer using\n     * the proxy obtained from {@link #getProfileProxy}.\n     * Profile can be one of  {@link BluetoothProfile#HEADSET} or {@link BluetoothProfile#A2DP}\n     *\n     * @param profile\n     * @param proxy Profile proxy object\n     ",
    "links" : [ "android.bluetooth.BluetoothProfile#HEADSET", "android.bluetooth.BluetoothProfile#A2DP", "#getProfileProxy" ]
  }, {
    "name" : "public boolean enableNoAutoConnect()",
    "returnType" : "boolean",
    "comment" : "\n     * Enable the Bluetooth Adapter, but don't auto-connect devices\n     * and don't persist state. Only for use by system applications.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean changeApplicationBluetoothState(boolean on, BluetoothStateChangeCallback callback)",
    "returnType" : "boolean",
    "comment" : "\n     * Enable control of the Bluetooth Adapter for a single application.\n     *\n     * <p>Some applications need to use Bluetooth for short periods of time to\n     * transfer data but don't want all the associated implications like\n     * automatic connection to headsets etc.\n     *\n     * <p> Multiple applications can call this. This is reference counted and\n     * Bluetooth disabled only when no one else is using it. There will be no UI\n     * shown to the user while bluetooth is being enabled. Any user action will\n     * override this call. For example, if user wants Bluetooth on and the last\n     * user of this API wanted to disable Bluetooth, Bluetooth will not be\n     * turned off.\n     *\n     * <p> This API is only meant to be used by internal applications. Third\n     * party applications but use {@link #enable} and {@link #disable} APIs.\n     *\n     * <p> If this API returns true, it means the callback will be called.\n     * The callback will be called with the current state of Bluetooth.\n     * If the state is not what was requested, an internal error would be the\n     * reason. If Bluetooth is already on and if this function is called to turn\n     * it on, the api will return true and a callback will be called.\n     *\n     * <p>Requires {@link android.Manifest.permission#BLUETOOTH}\n     *\n     * @param on True for on, false for off.\n     * @param callback The callback to notify changes to the state.\n     * @hide\n     ",
    "links" : [ "#disable", "#enable", "android.Manifest.permission#BLUETOOTH" ]
  }, {
    "name" : "private Set<BluetoothDevice> toDeviceSet(BluetoothDevice[] devices)",
    "returnType" : "Set<BluetoothDevice>",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "protected void finalize() throws Throwable",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public static boolean checkBluetoothAddress(String address)",
    "returnType" : "boolean",
    "comment" : "\n     * Validate a String Bluetooth address, such as \"00:43:A8:23:10:F0\"\n     * <p>Alphabetic characters must be uppercase to be valid.\n     *\n     * @param address Bluetooth address as string\n     * @return true if the address is valid, false otherwise\n     ",
    "links" : [ ]
  }, {
    "name" : " IBluetoothManager getBluetoothManager()",
    "returnType" : "IBluetoothManager",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : " IBluetooth getBluetoothService(IBluetoothManagerCallback cb)",
    "returnType" : "IBluetooth",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : " void removeServiceStateCallback(IBluetoothManagerCallback cb)",
    "returnType" : "void",
    "comment" : "package",
    "links" : [ ]
  }, {
    "name" : "public boolean startLeScan(LeScanCallback callback)",
    "returnType" : "boolean",
    "comment" : "\n     * Starts a scan for Bluetooth LE devices.\n     *\n     * <p>Results of the scan are reported using the\n     * {@link LeScanCallback#onLeScan} callback.\n     *\n     * @param callback the callback LE scan results are delivered\n     * @return true, if the scan was started successfully\n     * @deprecated use {@link BluetoothLeScanner#startScan(List, ScanSettings, ScanCallback)}\n     * instead.\n     ",
    "links" : [ "android.bluetooth.le.BluetoothLeScanner#startScan(List", "#onLeScan" ]
  }, {
    "name" : "public boolean startLeScan(final UUID[] serviceUuids, final LeScanCallback callback)",
    "returnType" : "boolean",
    "comment" : "\n     * Starts a scan for Bluetooth LE devices, looking for devices that\n     * advertise given services.\n     *\n     * <p>Devices which advertise all specified services are reported using the\n     * {@link LeScanCallback#onLeScan} callback.\n     *\n     * @param serviceUuids Array of services to look for\n     * @param callback the callback LE scan results are delivered\n     * @return true, if the scan was started successfully\n     * @deprecated use {@link BluetoothLeScanner#startScan(List, ScanSettings, ScanCallback)}\n     * instead.\n     ",
    "links" : [ "android.bluetooth.le.BluetoothLeScanner#startScan(List", "#onLeScan" ]
  }, {
    "name" : "public void stopLeScan(LeScanCallback callback)",
    "returnType" : "void",
    "comment" : "\n     * Stops an ongoing Bluetooth LE device scan.\n     *\n     * @param callback used to identify which scan to stop must be the same handle used to start the\n     * scan\n     * @deprecated Use {@link BluetoothLeScanner#stopScan(ScanCallback)} instead.\n     ",
    "links" : [ "android.bluetooth.le.BluetoothLeScanner#stopScan(ScanCallback)" ]
  }, {
    "name" : "public BluetoothServerSocket listenUsingL2capChannel() throws IOException",
    "returnType" : "BluetoothServerSocket",
    "comment" : "\n     * Create a secure L2CAP Connection-oriented Channel (CoC) {@link BluetoothServerSocket} and\n     * assign a dynamic protocol/service multiplexer (PSM) value. This socket can be used to listen\n     * for incoming connections. The supported Bluetooth transport is LE only.\n     * <p>A remote device connecting to this socket will be authenticated and communication on this\n     * socket will be encrypted.\n     * <p>Use {@link BluetoothServerSocket#accept} to retrieve incoming connections from a listening\n     * {@link BluetoothServerSocket}.\n     * <p>The system will assign a dynamic PSM value. This PSM value can be read from the {@link\n     * BluetoothServerSocket#getPsm()} and this value will be released when this server socket is\n     * closed, Bluetooth is turned off, or the application exits unexpectedly.\n     * <p>The mechanism of disclosing the assigned dynamic PSM value to the initiating peer is\n     * defined and performed by the application.\n     * <p>Use {@link BluetoothDevice#createL2capChannel(int)} to connect to this server\n     * socket from another Android device that is given the PSM value.\n     *\n     * @return an L2CAP CoC BluetoothServerSocket\n     * @throws IOException on error, for example Bluetooth not available, or insufficient\n     * permissions, or unable to start this CoC\n     ",
    "links" : [ "android.bluetooth.BluetoothServerSocket", "android.bluetooth.BluetoothDevice#createL2capChannel(int)", "android.bluetooth.BluetoothServerSocket#accept", "android.bluetooth.BluetoothServerSocket#getPsm()" ]
  }, {
    "name" : "public BluetoothServerSocket listenUsingInsecureL2capChannel() throws IOException",
    "returnType" : "BluetoothServerSocket",
    "comment" : "\n     * Create an insecure L2CAP Connection-oriented Channel (CoC) {@link BluetoothServerSocket} and\n     * assign a dynamic PSM value. This socket can be used to listen for incoming connections. The\n     * supported Bluetooth transport is LE only.\n     * <p>The link key is not required to be authenticated, i.e the communication may be vulnerable\n     * to man-in-the-middle attacks. Use {@link #listenUsingL2capChannel}, if an encrypted and\n     * authenticated communication channel is desired.\n     * <p>Use {@link BluetoothServerSocket#accept} to retrieve incoming connections from a listening\n     * {@link BluetoothServerSocket}.\n     * <p>The system will assign a dynamic protocol/service multiplexer (PSM) value. This PSM value\n     * can be read from the {@link BluetoothServerSocket#getPsm()} and this value will be released\n     * when this server socket is closed, Bluetooth is turned off, or the application exits\n     * unexpectedly.\n     * <p>The mechanism of disclosing the assigned dynamic PSM value to the initiating peer is\n     * defined and performed by the application.\n     * <p>Use {@link BluetoothDevice#createInsecureL2capChannel(int)} to connect to this server\n     * socket from another Android device that is given the PSM value.\n     *\n     * @return an L2CAP CoC BluetoothServerSocket\n     * @throws IOException on error, for example Bluetooth not available, or insufficient\n     * permissions, or unable to start this CoC\n     ",
    "links" : [ "android.bluetooth.BluetoothServerSocket", "android.bluetooth.BluetoothServerSocket#accept", "android.bluetooth.BluetoothServerSocket#getPsm()", "android.bluetooth.BluetoothDevice#createInsecureL2capChannel(int)", "#listenUsingL2capChannel" ]
  }, {
    "name" : "public boolean addOnMetadataChangedListener(@NonNull BluetoothDevice device, @NonNull Executor executor, @NonNull OnMetadataChangedListener listener)",
    "returnType" : "boolean",
    "comment" : "\n     * Register a {@link #OnMetadataChangedListener} to receive update about metadata\n     * changes for this {@link BluetoothDevice}.\n     * Registration must be done when Bluetooth is ON and will last until\n     * {@link #removeOnMetadataChangedListener(BluetoothDevice)} is called, even when Bluetooth\n     * restarted in the middle.\n     * All input parameters should not be null or {@link NullPointerException} will be triggered.\n     * The same {@link BluetoothDevice} and {@link #OnMetadataChangedListener} pair can only be\n     * registered once, double registration would cause {@link IllegalArgumentException}.\n     *\n     * @param device {@link BluetoothDevice} that will be registered\n     * @param executor the executor for listener callback\n     * @param listener {@link #OnMetadataChangedListener} that will receive asynchronous callbacks\n     * @return true on success, false on error\n     * @throws NullPointerException If one of {@code listener}, {@code device} or {@code executor}\n     * is null.\n     * @throws IllegalArgumentException The same {@link #OnMetadataChangedListener} and\n     * {@link BluetoothDevice} are registered twice.\n     * @hide\n     ",
    "links" : [ "android.bluetooth.BluetoothDevice", "NullPointerException", "#removeOnMetadataChangedListener(BluetoothDevice)", "#OnMetadataChangedListener", "IllegalArgumentException" ]
  }, {
    "name" : "public boolean removeOnMetadataChangedListener(@NonNull BluetoothDevice device, @NonNull OnMetadataChangedListener listener)",
    "returnType" : "boolean",
    "comment" : "\n     * Unregister a {@link #OnMetadataChangedListener} from a registered {@link BluetoothDevice}.\n     * Unregistration can be done when Bluetooth is either ON or OFF.\n     * {@link #addOnMetadataChangedListener(OnMetadataChangedListener, BluetoothDevice, Executor)}\n     * must be called before unregisteration.\n     *\n     * @param device {@link BluetoothDevice} that will be unregistered. It\n     * should not be null or {@link NullPointerException} will be triggered.\n     * @param listener {@link OnMetadataChangedListener} that will be unregistered. It\n     * should not be null or {@link NullPointerException} will be triggered.\n     * @return true on success, false on error\n     * @throws NullPointerException If {@code listener} or {@code device} is null.\n     * @throws IllegalArgumentException If {@code device} has not been registered before.\n     * @hide\n     ",
    "links" : [ "android.bluetooth.BluetoothDevice", "NullPointerException", "#OnMetadataChangedListener", "OnMetadataChangedListener", "#addOnMetadataChangedListener(OnMetadataChangedListener" ]
  }, {
    "name" : "public static int priorityToConnectionPolicy(int priority)",
    "returnType" : "int",
    "comment" : "\n     * Converts old constant of priority to the new for connection policy\n     *\n     * @param priority is the priority to convert to connection policy\n     * @return the equivalent connection policy constant to the priority\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public static int connectionPolicyToPriority(@ConnectionPolicy int connectionPolicy)",
    "returnType" : "int",
    "comment" : "\n     * Converts new constant of connection policy to the old for priority\n     *\n     * @param connectionPolicy is the connection policy to convert to priority\n     * @return the equivalent priority constant to the connectionPolicy\n     *\n     * @hide\n     ",
    "links" : [ ]
  } ],
  "variableNames" : [ "TAG", "DBG", "VDBG", "DEFAULT_MAC_ADDRESS", "ERROR", "ACTION_STATE_CHANGED", "EXTRA_STATE", "EXTRA_PREVIOUS_STATE", "STATE_OFF", "STATE_TURNING_ON", "STATE_ON", "STATE_TURNING_OFF", "STATE_BLE_TURNING_ON", "STATE_BLE_ON", "STATE_BLE_TURNING_OFF", "LE_PSM_CHARACTERISTIC_UUID", "ACTION_REQUEST_DISCOVERABLE", "EXTRA_DISCOVERABLE_DURATION", "ACTION_REQUEST_ENABLE", "ACTION_REQUEST_DISABLE", "ACTION_REQUEST_BLE_SCAN_ALWAYS_AVAILABLE", "ACTION_SCAN_MODE_CHANGED", "EXTRA_SCAN_MODE", "EXTRA_PREVIOUS_SCAN_MODE", "SCAN_MODE_NONE", "SCAN_MODE_CONNECTABLE", "SCAN_MODE_CONNECTABLE_DISCOVERABLE", "IO_CAPABILITY_OUT", "IO_CAPABILITY_IO", "IO_CAPABILITY_IN", "IO_CAPABILITY_NONE", "IO_CAPABILITY_KBDISP", "IO_CAPABILITY_MAX", "IO_CAPABILITY_UNKNOWN", "ACTIVE_DEVICE_AUDIO", "ACTIVE_DEVICE_PHONE_CALL", "ACTIVE_DEVICE_ALL", "ACTION_DISCOVERY_STARTED", "ACTION_DISCOVERY_FINISHED", "ACTION_LOCAL_NAME_CHANGED", "EXTRA_LOCAL_NAME", "ACTION_CONNECTION_STATE_CHANGED", "EXTRA_CONNECTION_STATE", "EXTRA_PREVIOUS_CONNECTION_STATE", "ACTION_BLE_STATE_CHANGED", "ACTION_BLUETOOTH_ADDRESS_CHANGED", "EXTRA_BLUETOOTH_ADDRESS", "ACTION_BLE_ACL_CONNECTED", "ACTION_BLE_ACL_DISCONNECTED", "STATE_DISCONNECTED", "STATE_CONNECTING", "STATE_CONNECTED", "STATE_DISCONNECTING", "BLUETOOTH_MANAGER_SERVICE", "mToken", "SOCKET_CHANNEL_AUTO_STATIC_NO_SDP", "ADDRESS_LENGTH", "sAdapter", "sBluetoothLeScanner", "sBluetoothLeAdvertiser", "sPeriodicAdvertisingManager", "mManagerService", "mService", "mContext", "mServiceLock", "mLock", "mLeScanClients", "sMetadataListeners", "sBluetoothMetadataListener", "BLUETOOTH_GET_STATE_CACHE_PROPERTY", "mBluetoothGetStateCache", "BLUETOOTH_FILTERING_CACHE_PROPERTY", "mBluetoothFilteringCache", "BLUETOOTH_PROFILE_CACHE_PROPERTY", "mGetProfileConnectionStateCache", "mManagerCallback", "mProxyServiceStateCallbacks" ],
  "methodNames" : [ "public static String nameForState(@AdapterState int state)", "public static synchronized BluetoothAdapter getDefaultAdapter()", "public BluetoothDevice getRemoteDevice(String address)", "public BluetoothDevice getRemoteDevice(byte[] address)", "public BluetoothLeAdvertiser getBluetoothLeAdvertiser()", "public PeriodicAdvertisingManager getPeriodicAdvertisingManager()", "public BluetoothLeScanner getBluetoothLeScanner()", "public boolean isEnabled()", "public boolean isLeEnabled()", "public boolean disableBLE()", "public boolean enableBLE()", "public void disableBluetoothGetStateCache()", "public static void invalidateBluetoothGetStateCache()", "private int getStateInternal()", "public int getState()", "public int getLeState()", " boolean getLeAccess()", "public boolean enable()", "public boolean disable()", "public boolean disable(boolean persist)", "public String getAddress()", "public String getName()", "public boolean factoryReset()", "public ParcelUuid[] getUuids()", "public boolean setName(String name)", "public BluetoothClass getBluetoothClass()", "public boolean setBluetoothClass(BluetoothClass bluetoothClass)", "public int getIoCapability()", "public boolean setIoCapability(@IoCapability int capability)", "public int getLeIoCapability()", "public boolean setLeIoCapability(@IoCapability int capability)", "public int getScanMode()", "public boolean setScanMode(@ScanMode int mode, long durationMillis)", "public boolean setScanMode(@ScanMode int mode)", "public int getDiscoverableTimeout()", "public void setDiscoverableTimeout(int timeout)", "public long getDiscoveryEndMillis()", "public void setContext(Context context)", "private String getOpPackageName()", "private String getAttributionTag()", "public boolean startDiscovery()", "public boolean cancelDiscovery()", "public boolean isDiscovering()", "public boolean removeActiveDevice(@ActiveDeviceUse int profiles)", "public boolean setActiveDevice(@NonNull BluetoothDevice device, @ActiveDeviceUse int profiles)", "public boolean connectAllEnabledProfiles(@NonNull BluetoothDevice device)", "public boolean disconnectAllEnabledProfiles(@NonNull BluetoothDevice device)", "public boolean isMultipleAdvertisementSupported()", "public boolean isBleScanAlwaysAvailable()", "public void disableIsOffloadedFilteringSupportedCache()", "public static void invalidateIsOffloadedFilteringSupportedCache()", "public boolean isOffloadedFilteringSupported()", "public boolean isOffloadedScanBatchingSupported()", "public boolean isLe2MPhySupported()", "public boolean isLeCodedPhySupported()", "public boolean isLeExtendedAdvertisingSupported()", "public boolean isLePeriodicAdvertisingSupported()", "public int getLeMaximumAdvertisingDataLength()", "private boolean isHearingAidProfileSupported()", "public int getMaxConnectedAudioDevices()", "public boolean isHardwareTrackingFiltersAvailable()", "public BluetoothActivityEnergyInfo getControllerActivityEnergyInfo(int updateType)", "public void requestControllerActivityEnergyInfo(ResultReceiver result)", "public List<BluetoothDevice> getMostRecentlyConnectedDevices()", "public Set<BluetoothDevice> getBondedDevices()", "public List<Integer> getSupportedProfiles()", "public int getConnectionState()", "public void disableGetProfileConnectionStateCache()", "public static void invalidateGetProfileConnectionStateCache()", "public int getProfileConnectionState(int profile)", "public BluetoothServerSocket listenUsingRfcommOn(int channel) throws IOException", "public BluetoothServerSocket listenUsingRfcommOn(int channel, boolean mitm, boolean min16DigitPin) throws IOException", "public BluetoothServerSocket listenUsingRfcommWithServiceRecord(String name, UUID uuid) throws IOException", "public BluetoothServerSocket listenUsingInsecureRfcommWithServiceRecord(String name, UUID uuid) throws IOException", "public BluetoothServerSocket listenUsingEncryptedRfcommWithServiceRecord(String name, UUID uuid) throws IOException", "private BluetoothServerSocket createNewRfcommSocketAndRecord(String name, UUID uuid, boolean auth, boolean encrypt) throws IOException", "public BluetoothServerSocket listenUsingInsecureRfcommOn(int port) throws IOException", "public BluetoothServerSocket listenUsingEncryptedRfcommOn(int port) throws IOException", "public static BluetoothServerSocket listenUsingScoOn() throws IOException", "public BluetoothServerSocket listenUsingL2capOn(int port, boolean mitm, boolean min16DigitPin) throws IOException", "public BluetoothServerSocket listenUsingL2capOn(int port) throws IOException", "public BluetoothServerSocket listenUsingInsecureL2capOn(int port) throws IOException", "public Pair<byte[], byte[]> readOutOfBandData()", "public boolean getProfileProxy(Context context, BluetoothProfile.ServiceListener listener, int profile)", "public void closeProfileProxy(int profile, BluetoothProfile proxy)", "public boolean enableNoAutoConnect()", "public boolean changeApplicationBluetoothState(boolean on, BluetoothStateChangeCallback callback)", "private Set<BluetoothDevice> toDeviceSet(BluetoothDevice[] devices)", "protected void finalize() throws Throwable", "public static boolean checkBluetoothAddress(String address)", " IBluetoothManager getBluetoothManager()", " IBluetooth getBluetoothService(IBluetoothManagerCallback cb)", " void removeServiceStateCallback(IBluetoothManagerCallback cb)", "public boolean startLeScan(LeScanCallback callback)", "public boolean startLeScan(final UUID[] serviceUuids, final LeScanCallback callback)", "public void stopLeScan(LeScanCallback callback)", "public BluetoothServerSocket listenUsingL2capChannel() throws IOException", "public BluetoothServerSocket listenUsingInsecureL2capChannel() throws IOException", "public boolean addOnMetadataChangedListener(@NonNull BluetoothDevice device, @NonNull Executor executor, @NonNull OnMetadataChangedListener listener)", "public boolean removeOnMetadataChangedListener(@NonNull BluetoothDevice device, @NonNull OnMetadataChangedListener listener)", "public static int priorityToConnectionPolicy(int priority)", "public static int connectionPolicyToPriority(@ConnectionPolicy int connectionPolicy)" ]
}