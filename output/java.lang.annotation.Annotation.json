{
  "filePath" : "/home/maryam/clearblue/files/android-source-35/java/lang/annotation/Annotation.java",
  "packageName" : "java.lang.annotation",
  "className" : "Annotation",
  "comment" : "\n * The common interface extended by all annotation interfaces.  Note that an\n * interface that manually extends this one does <i>not</i> define\n * an annotation interface.  Also note that this interface does not itself\n * define an annotation interface.\n *\n * More information about annotation interfaces can be found in section\n * {@jls 9.6} of <cite>The Java Language Specification</cite>.\n *\n * The {@link java.lang.reflect.AnnotatedElement} interface discusses\n * compatibility concerns when evolving an annotation interface from being\n * non-repeatable to being repeatable.\n *\n * @author  Josh Bloch\n * @since   1.5\n ",
  "links" : [ "java.lang.reflect.AnnotatedElement" ],
  "variables" : [ ],
  "methods" : [ {
    "name" : " boolean equals(Object obj)",
    "returnType" : "boolean",
    "comment" : "\n     * Returns true if the specified object represents an annotation\n     * that is logically equivalent to this one.  In other words,\n     * returns true if the specified object is an instance of the same\n     * annotation interface as this instance, all of whose members are equal\n     * to the corresponding member of this annotation, as defined below:\n     * <ul>\n     *    <li>Two corresponding primitive typed members whose values are\n     *    {@code x} and {@code y} are considered equal if {@code x == y},\n     *    unless their type is {@code float} or {@code double}.\n     *\n     *    <li>Two corresponding {@code float} members whose values\n     *    are {@code x} and {@code y} are considered equal if\n     *    {@code Float.valueOf(x).equals(Float.valueOf(y))}.\n     *    (Unlike the {@code ==} operator, NaN is considered equal\n     *    to itself, and {@code 0.0f} unequal to {@code -0.0f}.)\n     *\n     *    <li>Two corresponding {@code double} members whose values\n     *    are {@code x} and {@code y} are considered equal if\n     *    {@code Double.valueOf(x).equals(Double.valueOf(y))}.\n     *    (Unlike the {@code ==} operator, NaN is considered equal\n     *    to itself, and {@code 0.0} unequal to {@code -0.0}.)\n     *\n     *    <li>Two corresponding {@code String}, {@code Class}, enum, or\n     *    annotation typed members whose values are {@code x} and {@code y}\n     *    are considered equal if {@code x.equals(y)}.  (Note that this\n     *    definition is recursive for annotation typed members.)\n     *\n     *    <li>Two corresponding array typed members {@code x} and {@code y}\n     *    are considered equal if {@code Arrays.equals(x, y)}, for the\n     *    appropriate overloading of {@link java.util.Arrays#equals Arrays.equals}.\n     * </ul>\n     *\n     * @return true if the specified object represents an annotation\n     *     that is logically equivalent to this one, otherwise false\n     ",
    "links" : [ "java.util.Arrays#equals" ]
  }, {
    "name" : " int hashCode()",
    "returnType" : "int",
    "comment" : "\n     * Returns the hash code of this annotation.\n     *\n     * <p>The hash code of an annotation is the sum of the hash codes\n     * of its members (including those with default values).\n     *\n     * The hash code of an annotation member is (127 times the hash code\n     * of the member-name as computed by {@link String#hashCode()}) XOR\n     * the hash code of the member-value.\n     * The hash code of a member-value depends on its type as defined below:\n     * <ul>\n     * <li>The hash code of a primitive value <i>{@code v}</i> is equal to\n     *     <code><i>WrapperType</i>.valueOf(<i>v</i>).hashCode()</code>, where\n     *     <i>{@code WrapperType}</i> is the wrapper type corresponding\n     *     to the primitive type of <i>{@code v}</i> ({@link Byte},\n     *     {@link Character}, {@link Double}, {@link Float}, {@link Integer},\n     *     {@link Long}, {@link Short}, or {@link Boolean}).\n     *\n     * <li>The hash code of a string, enum, class, or annotation member-value\n     *     <i>{@code v}</i> is computed as by calling\n     *     <code><i>v</i>.hashCode()</code>.  (In the case of annotation\n     *     member values, this is a recursive definition.)\n     *\n     * <li>The hash code of an array member-value is computed by calling\n     *     the appropriate overloading of\n     *     {@link java.util.Arrays#hashCode(long[]) Arrays.hashCode}\n     *     on the value.  (There is one overloading for each primitive\n     *     type, and one for object reference types.)\n     * </ul>\n     *\n     * @return the hash code of this annotation\n     ",
    "links" : [ "Integer", "java.util.Arrays#hashCode(long", "Float", "Character", "Byte", "#hashCode()", "Long", "Boolean", "Double", "Short" ]
  }, {
    "name" : " String toString()",
    "returnType" : "String",
    "comment" : "\n     * Returns a string representation of this annotation.  The details\n     * of the representation are implementation-dependent, but the following\n     * may be regarded as typical:\n     * <pre>\n     *   &#064;com.example.Name(first=\"Duke\", middle=\"of\", last=\"Java\")\n     * </pre>\n     *\n     * @return a string representation of this annotation\n     ",
    "links" : [ ]
  }, {
    "name" : " Class<? extends Annotation> annotationType()",
    "returnType" : "Class<? extends Annotation>",
    "comment" : "\n     * Returns the annotation interface of this annotation.\n     *\n     * @apiNote Implementation-dependent classes are used to provide\n     * the implementations of annotations. Therefore, calling {@link\n     * Object#getClass getClass} on an annotation will return an\n     * implementation-dependent class. In contrast, this method will\n     * reliably return the annotation interface of the annotation.\n     *\n     * @return the annotation interface of this annotation\n     * @see Enum#getDeclaringClass\n     ",
    "links" : [ "#getClass" ]
  } ],
  "methodNames" : [ " boolean equals(Object obj)", " int hashCode()", " String toString()", " Class<? extends Annotation> annotationType()" ],
  "variableNames" : [ ]
}