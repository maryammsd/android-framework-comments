{
  "filePath" : "/home/maryam/clearblue/files/android-source-35/java/io/InputStream.java",
  "packageName" : "java.io",
  "className" : "InputStream",
  "comment" : "\n * This abstract class is the superclass of all classes representing\n * an input stream of bytes.\n *\n * <p> Applications that need to define a subclass of {@code InputStream}\n * must always provide a method that returns the next byte of input.\n *\n * @author  Arthur van Hoff\n * @see     java.io.BufferedInputStream\n * @see     java.io.ByteArrayInputStream\n * @see     java.io.DataInputStream\n * @see     java.io.FilterInputStream\n * @see     java.io.InputStream#read()\n * @see     java.io.OutputStream\n * @see     java.io.PushbackInputStream\n * @since   1.0\n ",
  "links" : [ ],
  "variables" : [ {
    "name" : "MAX_SKIP_BUFFER_SIZE",
    "type" : "int",
    "comment" : " use when skipping.",
    "links" : [ ]
  }, {
    "name" : "DEFAULT_BUFFER_SIZE",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "MAX_BUFFER_SIZE",
    "type" : "int",
    "comment" : "\n     * The maximum size of array to allocate.\n     * Some VMs reserve some header words in an array.\n     * Attempts to allocate larger arrays may result in\n     * OutOfMemoryError: Requested array size exceeds VM limit\n     ",
    "links" : [ ]
  } ],
  "methods" : [ {
    "name" : "public static InputStream nullInputStream()",
    "returnType" : "InputStream",
    "comment" : "\n     * Returns a new {@code InputStream} that reads no bytes. The returned\n     * stream is initially open.  The stream is closed by calling the\n     * {@code close()} method.  Subsequent calls to {@code close()} have no\n     * effect.\n     *\n     * <p> While the stream is open, the {@code available()}, {@code read()},\n     * {@code read(byte[])}, {@code read(byte[], int, int)},\n     * {@code readAllBytes()}, {@code readNBytes(byte[], int, int)},\n     * {@code readNBytes(int)}, {@code skip(long)}, {@code skipNBytes(long)},\n     * and {@code transferTo()} methods all behave as if end of stream has been\n     * reached.  After the stream has been closed, these methods all throw\n     * {@code IOException}.\n     *\n     * <p> The {@code markSupported()} method returns {@code false}.  The\n     * {@code mark()} method does nothing, and the {@code reset()} method\n     * throws {@code IOException}.\n     *\n     * @return an {@code InputStream} which contains no bytes\n     *\n     * @since 11\n     ",
    "links" : [ ]
  }, {
    "name" : "public abstract int read() throws IOException",
    "returnType" : "int",
    "comment" : "\n     * Reads the next byte of data from the input stream. The value byte is\n     * returned as an {@code int} in the range {@code 0} to\n     * {@code 255}. If no byte is available because the end of the stream\n     * has been reached, the value {@code -1} is returned. This method\n     * blocks until input data is available, the end of the stream is detected,\n     * or an exception is thrown.\n     *\n     * <p> A subclass must provide an implementation of this method.\n     *\n     * @return     the next byte of data, or {@code -1} if the end of the\n     *             stream is reached.\n     * @throws     IOException  if an I/O error occurs.\n     ",
    "links" : [ ]
  }, {
    "name" : "public int read(byte[] b) throws IOException",
    "returnType" : "int",
    "comment" : "\n     * Reads some number of bytes from the input stream and stores them into\n     * the buffer array {@code b}. The number of bytes actually read is\n     * returned as an integer.  This method blocks until input data is\n     * available, end of file is detected, or an exception is thrown.\n     *\n     * <p> If the length of {@code b} is zero, then no bytes are read and\n     * {@code 0} is returned; otherwise, there is an attempt to read at\n     * least one byte. If no byte is available because the stream is at the\n     * end of the file, the value {@code -1} is returned; otherwise, at\n     * least one byte is read and stored into {@code b}.\n     *\n     * <p> The first byte read is stored into element {@code b[0]}, the\n     * next one into {@code b[1]}, and so on. The number of bytes read is,\n     * at most, equal to the length of {@code b}. Let <i>k</i> be the\n     * number of bytes actually read; these bytes will be stored in elements\n     * {@code b[0]} through {@code b[}<i>k</i>{@code -1]},\n     * leaving elements {@code b[}<i>k</i>{@code ]} through\n     * {@code b[b.length-1]} unaffected.\n     *\n     * <p> The {@code read(b)} method for class {@code InputStream}\n     * has the same effect as: <pre>{@code  read(b, 0, b.length) }</pre>\n     *\n     * @param      b   the buffer into which the data is read.\n     * @return     the total number of bytes read into the buffer, or\n     *             {@code -1} if there is no more data because the end of\n     *             the stream has been reached.\n     * @throws     IOException  If the first byte cannot be read for any reason\n     *             other than the end of the file, if the input stream has been\n     *             closed, or if some other I/O error occurs.\n     * @throws     NullPointerException  if {@code b} is {@code null}.\n     * @see        java.io.InputStream#read(byte[], int, int)\n     ",
    "links" : [ ]
  }, {
    "name" : "public int read(byte[] b, int off, int len) throws IOException",
    "returnType" : "int",
    "comment" : "\n     * Reads up to {@code len} bytes of data from the input stream into\n     * an array of bytes.  An attempt is made to read as many as\n     * {@code len} bytes, but a smaller number may be read.\n     * The number of bytes actually read is returned as an integer.\n     *\n     * <p> This method blocks until input data is available, end of file is\n     * detected, or an exception is thrown.\n     *\n     * <p> If {@code len} is zero, then no bytes are read and\n     * {@code 0} is returned; otherwise, there is an attempt to read at\n     * least one byte. If no byte is available because the stream is at end of\n     * file, the value {@code -1} is returned; otherwise, at least one\n     * byte is read and stored into {@code b}.\n     *\n     * <p> The first byte read is stored into element {@code b[off]}, the\n     * next one into {@code b[off+1]}, and so on. The number of bytes read\n     * is, at most, equal to {@code len}. Let <i>k</i> be the number of\n     * bytes actually read; these bytes will be stored in elements\n     * {@code b[off]} through {@code b[off+}<i>k</i>{@code -1]},\n     * leaving elements {@code b[off+}<i>k</i>{@code ]} through\n     * {@code b[off+len-1]} unaffected.\n     *\n     * <p> In every case, elements {@code b[0]} through\n     * {@code b[off-1]} and elements {@code b[off+len]} through\n     * {@code b[b.length-1]} are unaffected.\n     *\n     * <p> The {@code read(b, off, len)} method\n     * for class {@code InputStream} simply calls the method\n     * {@code read()} repeatedly. If the first such call results in an\n     * {@code IOException}, that exception is returned from the call to\n     * the {@code read(b,} {@code off,} {@code len)} method.  If\n     * any subsequent call to {@code read()} results in a\n     * {@code IOException}, the exception is caught and treated as if it\n     * were end of file; the bytes read up to that point are stored into\n     * {@code b} and the number of bytes read before the exception\n     * occurred is returned. The default implementation of this method blocks\n     * until the requested amount of input data {@code len} has been read,\n     * end of file is detected, or an exception is thrown. Subclasses are\n     * encouraged to provide a more efficient implementation of this method.\n     *\n     * @param      b     the buffer into which the data is read.\n     * @param      off   the start offset in array {@code b}\n     *                   at which the data is written.\n     * @param      len   the maximum number of bytes to read.\n     * @return     the total number of bytes read into the buffer, or\n     *             {@code -1} if there is no more data because the end of\n     *             the stream has been reached.\n     * @throws     IOException If the first byte cannot be read for any reason\n     *             other than end of file, or if the input stream has been closed,\n     *             or if some other I/O error occurs.\n     * @throws     NullPointerException If {@code b} is {@code null}.\n     * @throws     IndexOutOfBoundsException If {@code off} is negative,\n     *             {@code len} is negative, or {@code len} is greater than\n     *             {@code b.length - off}\n     * @see        java.io.InputStream#read()\n     ",
    "links" : [ ]
  }, {
    "name" : "public byte[] readAllBytes() throws IOException",
    "returnType" : "byte[]",
    "comment" : "\n     * Reads all remaining bytes from the input stream. This method blocks until\n     * all remaining bytes have been read and end of stream is detected, or an\n     * exception is thrown. This method does not close the input stream.\n     *\n     * <p> When this stream reaches end of stream, further invocations of this\n     * method will return an empty byte array.\n     *\n     * <p> Note that this method is intended for simple cases where it is\n     * convenient to read all bytes into a byte array. It is not intended for\n     * reading input streams with large amounts of data.\n     *\n     * <p> The behavior for the case where the input stream is <i>asynchronously\n     * closed</i>, or the thread interrupted during the read, is highly input\n     * stream specific, and therefore not specified.\n     *\n     * <p> If an I/O error occurs reading from the input stream, then it may do\n     * so after some, but not all, bytes have been read. Consequently the input\n     * stream may not be at end of stream and may be in an inconsistent state.\n     * It is strongly recommended that the stream be promptly closed if an I/O\n     * error occurs.\n     *\n     * @implSpec\n     * This method invokes {@link #readNBytes(int)} with a length of\n     * {@link Integer#MAX_VALUE}.\n     *\n     * @return a byte array containing the bytes read from this input stream\n     * @throws IOException if an I/O error occurs\n     * @throws OutOfMemoryError if an array of the required size cannot be\n     *         allocated.\n     *\n     * @since 9\n     ",
    "links" : [ "#MAX_VALUE", "#readNBytes(int)" ]
  }, {
    "name" : "public byte[] readNBytes(int len) throws IOException",
    "returnType" : "byte[]",
    "comment" : "\n     * Reads up to a specified number of bytes from the input stream. This\n     * method blocks until the requested number of bytes has been read, end\n     * of stream is detected, or an exception is thrown. This method does not\n     * close the input stream.\n     *\n     * <p> The length of the returned array equals the number of bytes read\n     * from the stream. If {@code len} is zero, then no bytes are read and\n     * an empty byte array is returned. Otherwise, up to {@code len} bytes\n     * are read from the stream. Fewer than {@code len} bytes may be read if\n     * end of stream is encountered.\n     *\n     * <p> When this stream reaches end of stream, further invocations of this\n     * method will return an empty byte array.\n     *\n     * <p> Note that this method is intended for simple cases where it is\n     * convenient to read the specified number of bytes into a byte array. The\n     * total amount of memory allocated by this method is proportional to the\n     * number of bytes read from the stream which is bounded by {@code len}.\n     * Therefore, the method may be safely called with very large values of\n     * {@code len} provided sufficient memory is available.\n     *\n     * <p> The behavior for the case where the input stream is <i>asynchronously\n     * closed</i>, or the thread interrupted during the read, is highly input\n     * stream specific, and therefore not specified.\n     *\n     * <p> If an I/O error occurs reading from the input stream, then it may do\n     * so after some, but not all, bytes have been read. Consequently the input\n     * stream may not be at end of stream and may be in an inconsistent state.\n     * It is strongly recommended that the stream be promptly closed if an I/O\n     * error occurs.\n     *\n     * @implNote\n     * The number of bytes allocated to read data from this stream and return\n     * the result is bounded by {@code 2*(long)len}, inclusive.\n     *\n     * @param len the maximum number of bytes to read\n     * @return a byte array containing the bytes read from this input stream\n     * @throws IllegalArgumentException if {@code length} is negative\n     * @throws IOException if an I/O error occurs\n     * @throws OutOfMemoryError if an array of the required size cannot be\n     *         allocated.\n     *\n     * @since 11\n     ",
    "links" : [ ]
  }, {
    "name" : "public int readNBytes(byte[] b, int off, int len) throws IOException",
    "returnType" : "int",
    "comment" : "\n     * Reads the requested number of bytes from the input stream into the given\n     * byte array. This method blocks until {@code len} bytes of input data have\n     * been read, end of stream is detected, or an exception is thrown. The\n     * number of bytes actually read, possibly zero, is returned. This method\n     * does not close the input stream.\n     *\n     * <p> In the case where end of stream is reached before {@code len} bytes\n     * have been read, then the actual number of bytes read will be returned.\n     * When this stream reaches end of stream, further invocations of this\n     * method will return zero.\n     *\n     * <p> If {@code len} is zero, then no bytes are read and {@code 0} is\n     * returned; otherwise, there is an attempt to read up to {@code len} bytes.\n     *\n     * <p> The first byte read is stored into element {@code b[off]}, the next\n     * one in to {@code b[off+1]}, and so on. The number of bytes read is, at\n     * most, equal to {@code len}. Let <i>k</i> be the number of bytes actually\n     * read; these bytes will be stored in elements {@code b[off]} through\n     * {@code b[off+}<i>k</i>{@code -1]}, leaving elements {@code b[off+}<i>k</i>\n     * {@code ]} through {@code b[off+len-1]} unaffected.\n     *\n     * <p> The behavior for the case where the input stream is <i>asynchronously\n     * closed</i>, or the thread interrupted during the read, is highly input\n     * stream specific, and therefore not specified.\n     *\n     * <p> If an I/O error occurs reading from the input stream, then it may do\n     * so after some, but not all, bytes of {@code b} have been updated with\n     * data from the input stream. Consequently the input stream and {@code b}\n     * may be in an inconsistent state. It is strongly recommended that the\n     * stream be promptly closed if an I/O error occurs.\n     *\n     * @param  b the byte array into which the data is read\n     * @param  off the start offset in {@code b} at which the data is written\n     * @param  len the maximum number of bytes to read\n     * @return the actual number of bytes read into the buffer\n     * @throws IOException if an I/O error occurs\n     * @throws NullPointerException if {@code b} is {@code null}\n     * @throws IndexOutOfBoundsException If {@code off} is negative, {@code len}\n     *         is negative, or {@code len} is greater than {@code b.length - off}\n     *\n     * @since 9\n     ",
    "links" : [ ]
  }, {
    "name" : "public long skip(long n) throws IOException",
    "returnType" : "long",
    "comment" : "\n     * Skips over and discards {@code n} bytes of data from this input\n     * stream. The {@code skip} method may, for a variety of reasons, end\n     * up skipping over some smaller number of bytes, possibly {@code 0}.\n     * This may result from any of a number of conditions; reaching end of file\n     * before {@code n} bytes have been skipped is only one possibility.\n     * The actual number of bytes skipped is returned. If {@code n} is\n     * negative, the {@code skip} method for class {@code InputStream} always\n     * returns 0, and no bytes are skipped. Subclasses may handle the negative\n     * value differently.\n     *\n     * <p> The {@code skip} method implementation of this class creates a\n     * byte array and then repeatedly reads into it until {@code n} bytes\n     * have been read or the end of the stream has been reached. Subclasses are\n     * encouraged to provide a more efficient implementation of this method.\n     * For instance, the implementation may depend on the ability to seek.\n     *\n     * @param      n   the number of bytes to be skipped.\n     * @return     the actual number of bytes skipped which might be zero.\n     * @throws     IOException  if an I/O error occurs.\n     * @see        java.io.InputStream#skipNBytes(long)\n     ",
    "links" : [ ]
  }, {
    "name" : "public void skipNBytes(long n) throws IOException",
    "returnType" : "void",
    "comment" : "\n     * Skips over and discards exactly {@code n} bytes of data from this input\n     * stream.  If {@code n} is zero, then no bytes are skipped.\n     * If {@code n} is negative, then no bytes are skipped.\n     * Subclasses may handle the negative value differently.\n     *\n     * <p> This method blocks until the requested number of bytes has been\n     * skipped, end of file is reached, or an exception is thrown.\n     *\n     * <p> If end of stream is reached before the stream is at the desired\n     * position, then an {@code EOFException} is thrown.\n     *\n     * <p> If an I/O error occurs, then the input stream may be\n     * in an inconsistent state. It is strongly recommended that the\n     * stream be promptly closed if an I/O error occurs.\n     *\n     * @implNote\n     * Subclasses are encouraged to provide a more efficient implementation\n     * of this method.\n     *\n     * @implSpec\n     * If {@code n} is zero or negative, then no bytes are skipped.\n     * If {@code n} is positive, the default implementation of this method\n     * invokes {@link #skip(long) skip()} repeatedly with its parameter equal\n     * to the remaining number of bytes to skip until the requested number\n     * of bytes has been skipped or an error condition occurs.  If at any\n     * point the return value of {@code skip()} is negative or greater than the\n     * remaining number of bytes to be skipped, then an {@code IOException} is\n     * thrown.  If {@code skip()} ever returns zero, then {@link #read()} is\n     * invoked to read a single byte, and if it returns {@code -1}, then an\n     * {@code EOFException} is thrown.  Any exception thrown by {@code skip()}\n     * or {@code read()} will be propagated.\n     *\n     * @param      n   the number of bytes to be skipped.\n     * @throws     EOFException if end of stream is encountered before the\n     *             stream can be positioned {@code n} bytes beyond its position\n     *             when this method was invoked.\n     * @throws     IOException  if the stream cannot be positioned properly or\n     *             if an I/O error occurs.\n     * @see        java.io.InputStream#skip(long)\n     *\n     * @since 12\n     ",
    "links" : [ "#read()", "#skip(long)" ]
  }, {
    "name" : "public int available() throws IOException",
    "returnType" : "int",
    "comment" : "\n     * Returns an estimate of the number of bytes that can be read (or skipped\n     * over) from this input stream without blocking, which may be 0, or 0 when\n     * end of stream is detected.  The read might be on the same thread or\n     * another thread.  A single read or skip of this many bytes will not block,\n     * but may read or skip fewer bytes.\n     *\n     * <p> Note that while some implementations of {@code InputStream} will\n     * return the total number of bytes in the stream, many will not.  It is\n     * never correct to use the return value of this method to allocate\n     * a buffer intended to hold all data in this stream.\n     *\n     * <p> A subclass's implementation of this method may choose to throw an\n     * {@link IOException} if this input stream has been closed by invoking the\n     * {@link #close()} method.\n     *\n     * <p> The {@code available} method of {@code InputStream} always returns\n     * {@code 0}.\n     *\n     * <p> This method should be overridden by subclasses.\n     *\n     * @return     an estimate of the number of bytes that can be read (or\n     *             skipped over) from this input stream without blocking or\n     *             {@code 0} when it reaches the end of the input stream.\n     * @throws     IOException if an I/O error occurs.\n     ",
    "links" : [ "#close()", "java.io.IOException" ]
  }, {
    "name" : "public void close() throws IOException",
    "returnType" : "void",
    "comment" : "\n     * Closes this input stream and releases any system resources associated\n     * with the stream.\n     *\n     * <p> The {@code close} method of {@code InputStream} does\n     * nothing.\n     *\n     * @throws     IOException  if an I/O error occurs.\n     ",
    "links" : [ ]
  }, {
    "name" : "public synchronized void mark(int readlimit)",
    "returnType" : "void",
    "comment" : "\n     * Marks the current position in this input stream. A subsequent call to\n     * the {@code reset} method repositions this stream at the last marked\n     * position so that subsequent reads re-read the same bytes.\n     *\n     * <p> The {@code readlimit} arguments tells this input stream to\n     * allow that many bytes to be read before the mark position gets\n     * invalidated.\n     *\n     * <p> The general contract of {@code mark} is that, if the method\n     * {@code markSupported} returns {@code true}, the stream somehow\n     * remembers all the bytes read after the call to {@code mark} and\n     * stands ready to supply those same bytes again if and whenever the method\n     * {@code reset} is called.  However, the stream is not required to\n     * remember any data at all if more than {@code readlimit} bytes are\n     * read from the stream before {@code reset} is called.\n     *\n     * <p> Marking a closed stream should not have any effect on the stream.\n     *\n     * <p> The {@code mark} method of {@code InputStream} does\n     * nothing.\n     *\n     * @param   readlimit   the maximum limit of bytes that can be read before\n     *                      the mark position becomes invalid.\n     * @see     java.io.InputStream#reset()\n     ",
    "links" : [ ]
  }, {
    "name" : "public synchronized void reset() throws IOException",
    "returnType" : "void",
    "comment" : "\n     * Repositions this stream to the position at the time the\n     * {@code mark} method was last called on this input stream.\n     *\n     * <p> The general contract of {@code reset} is:\n     *\n     * <ul>\n     * <li> If the method {@code markSupported} returns\n     * {@code true}, then:\n     *\n     *     <ul><li> If the method {@code mark} has not been called since\n     *     the stream was created, or the number of bytes read from the stream\n     *     since {@code mark} was last called is larger than the argument\n     *     to {@code mark} at that last call, then an\n     *     {@code IOException} might be thrown.\n     *\n     *     <li> If such an {@code IOException} is not thrown, then the\n     *     stream is reset to a state such that all the bytes read since the\n     *     most recent call to {@code mark} (or since the start of the\n     *     file, if {@code mark} has not been called) will be resupplied\n     *     to subsequent callers of the {@code read} method, followed by\n     *     any bytes that otherwise would have been the next input data as of\n     *     the time of the call to {@code reset}. </ul>\n     *\n     * <li> If the method {@code markSupported} returns\n     * {@code false}, then:\n     *\n     *     <ul><li> The call to {@code reset} may throw an\n     *     {@code IOException}.\n     *\n     *     <li> If an {@code IOException} is not thrown, then the stream\n     *     is reset to a fixed state that depends on the particular type of the\n     *     input stream and how it was created. The bytes that will be supplied\n     *     to subsequent callers of the {@code read} method depend on the\n     *     particular type of the input stream. </ul></ul>\n     *\n     * <p>The method {@code reset} for class {@code InputStream}\n     * does nothing except throw an {@code IOException}.\n     *\n     * @throws  IOException  if this stream has not been marked or if the\n     *          mark has been invalidated.\n     * @see     java.io.InputStream#mark(int)\n     * @see     java.io.IOException\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean markSupported()",
    "returnType" : "boolean",
    "comment" : "\n     * Tests if this input stream supports the {@code mark} and\n     * {@code reset} methods. Whether or not {@code mark} and\n     * {@code reset} are supported is an invariant property of a\n     * particular input stream instance. The {@code markSupported} method\n     * of {@code InputStream} returns {@code false}.\n     *\n     * @return  {@code true} if this stream instance supports the mark\n     *          and reset methods; {@code false} otherwise.\n     * @see     java.io.InputStream#mark(int)\n     * @see     java.io.InputStream#reset()\n     ",
    "links" : [ ]
  }, {
    "name" : "public long transferTo(OutputStream out) throws IOException",
    "returnType" : "long",
    "comment" : "\n     * Reads all bytes from this input stream and writes the bytes to the\n     * given output stream in the order that they are read. On return, this\n     * input stream will be at end of stream. This method does not close either\n     * stream.\n     * <p>\n     * This method may block indefinitely reading from the input stream, or\n     * writing to the output stream. The behavior for the case where the input\n     * and/or output stream is <i>asynchronously closed</i>, or the thread\n     * interrupted during the transfer, is highly input and output stream\n     * specific, and therefore not specified.\n     * <p>\n     * If an I/O error occurs reading from the input stream or writing to the\n     * output stream, then it may do so after some bytes have been read or\n     * written. Consequently the input stream may not be at end of stream and\n     * one, or both, streams may be in an inconsistent state. It is strongly\n     * recommended that both streams be promptly closed if an I/O error occurs.\n     *\n     * @param  out the output stream, non-null\n     * @return the number of bytes transferred\n     * @throws IOException if an I/O error occurs when reading or writing\n     * @throws NullPointerException if {@code out} is {@code null}\n     *\n     * @since 9\n     ",
    "links" : [ ]
  } ],
  "methodNames" : [ "public static InputStream nullInputStream()", "public abstract int read() throws IOException", "public int read(byte[] b) throws IOException", "public int read(byte[] b, int off, int len) throws IOException", "public byte[] readAllBytes() throws IOException", "public byte[] readNBytes(int len) throws IOException", "public int readNBytes(byte[] b, int off, int len) throws IOException", "public long skip(long n) throws IOException", "public void skipNBytes(long n) throws IOException", "public int available() throws IOException", "public void close() throws IOException", "public synchronized void mark(int readlimit)", "public synchronized void reset() throws IOException", "public boolean markSupported()", "public long transferTo(OutputStream out) throws IOException" ],
  "variableNames" : [ "MAX_SKIP_BUFFER_SIZE", "DEFAULT_BUFFER_SIZE", "MAX_BUFFER_SIZE" ]
}