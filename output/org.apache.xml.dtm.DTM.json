{
  "filePath" : "/home/maryam/clearblue/files/android-source-35/org/apache/xml/dtm/DTM.java",
  "packageName" : "org.apache.xml.dtm",
  "className" : "DTM",
  "comment" : "\n * <code>DTM</code> is an XML document model expressed as a table\n * rather than an object tree. It attempts to provide an interface to\n * a parse tree that has very little object creation. (DTM\n * implementations may also support incremental construction of the\n * model, but that's hidden from the DTM API.)\n *\n * <p>Nodes in the DTM are identified by integer \"handles\".  A handle must\n * be unique within a process, and carries both node identification and\n * document identification.  It must be possible to compare two handles\n * (and thus their nodes) for identity with \"==\".</p>\n *\n * <p>Namespace URLs, local-names, and expanded-names can all be\n * represented by and tested as integer ID values.  An expanded name\n * represents (and may or may not directly contain) a combination of\n * the URL ID, and the local-name ID.  Note that the namespace URL id\n * can be 0, which should have the meaning that the namespace is null.\n * For consistancy, zero should not be used for a local-name index. </p>\n *\n * <p>Text content of a node is represented by an index and length,\n * permitting efficient storage such as a shared FastStringBuffer.</p>\n *\n * <p>The model of the tree, as well as the general navigation model,\n * is that of XPath 1.0, for the moment.  The model will eventually be\n * adapted to match the XPath 2.0 data model, XML Schema, and\n * InfoSet.</p>\n *\n * <p>DTM does _not_ directly support the W3C's Document Object\n * Model. However, it attempts to come close enough that an\n * implementation of DTM can be created that wraps a DOM and vice\n * versa.</p>\n *\n * <p><strong>Please Note:</strong> The DTM API is still\n * <strong>Subject To Change.</strong> This wouldn't affect most\n * users, but might require updating some extensions.</p>\n *\n * <p> The largest change being contemplated is a reconsideration of\n * the Node Handle representation.  We are still not entirely sure\n * that an integer packed with two numeric subfields is really the\n * best solution. It has been suggested that we move up to a Long, to\n * permit more nodes per document without having to reduce the number\n * of slots in the DTMManager. There's even been a proposal that we\n * replace these integers with \"cursor\" objects containing the\n * internal node id and a pointer to the actual DTM object; this might\n * reduce the need to continuously consult the DTMManager to retrieve\n * the latter, and might provide a useful \"hook\" back into normal Java\n * heap management.  But changing this datatype would have huge impact\n * on Xalan's internals -- especially given Java's lack of C-style\n * typedefs -- so we won't cut over unless we're convinced the new\n * solution really would be an improvement!</p>\n * ",
  "links" : [ ],
  "variables" : [ {
    "name" : "NULL",
    "type" : "int",
    "comment" : "\n   * Null node handles are represented by this value.\n   ",
    "links" : [ ]
  }, {
    "name" : "ROOT_NODE",
    "type" : "short",
    "comment" : "\n   * The node is a <code>Root</code>.\n   ",
    "links" : [ ]
  }, {
    "name" : "ELEMENT_NODE",
    "type" : "short",
    "comment" : "\n   * The node is an <code>Element</code>.\n   ",
    "links" : [ ]
  }, {
    "name" : "ATTRIBUTE_NODE",
    "type" : "short",
    "comment" : "\n   * The node is an <code>Attr</code>.\n   ",
    "links" : [ ]
  }, {
    "name" : "TEXT_NODE",
    "type" : "short",
    "comment" : "\n   * The node is a <code>Text</code> node.\n   ",
    "links" : [ ]
  }, {
    "name" : "CDATA_SECTION_NODE",
    "type" : "short",
    "comment" : "\n   * The node is a <code>CDATASection</code>.\n   ",
    "links" : [ ]
  }, {
    "name" : "ENTITY_REFERENCE_NODE",
    "type" : "short",
    "comment" : "\n   * The node is an <code>EntityReference</code>.\n   ",
    "links" : [ ]
  }, {
    "name" : "ENTITY_NODE",
    "type" : "short",
    "comment" : "\n   * The node is an <code>Entity</code>.\n   ",
    "links" : [ ]
  }, {
    "name" : "PROCESSING_INSTRUCTION_NODE",
    "type" : "short",
    "comment" : "\n   * The node is a <code>ProcessingInstruction</code>.\n   ",
    "links" : [ ]
  }, {
    "name" : "COMMENT_NODE",
    "type" : "short",
    "comment" : "\n   * The node is a <code>Comment</code>.\n   ",
    "links" : [ ]
  }, {
    "name" : "DOCUMENT_NODE",
    "type" : "short",
    "comment" : "\n   * The node is a <code>Document</code>.\n   ",
    "links" : [ ]
  }, {
    "name" : "DOCUMENT_TYPE_NODE",
    "type" : "short",
    "comment" : "\n   * The node is a <code>DocumentType</code>.\n   ",
    "links" : [ ]
  }, {
    "name" : "DOCUMENT_FRAGMENT_NODE",
    "type" : "short",
    "comment" : "\n   * The node is a <code>DocumentFragment</code>.\n   ",
    "links" : [ ]
  }, {
    "name" : "NOTATION_NODE",
    "type" : "short",
    "comment" : "\n   * The node is a <code>Notation</code>.\n   ",
    "links" : [ ]
  }, {
    "name" : "NAMESPACE_NODE",
    "type" : "short",
    "comment" : "\n   * The node is a <code>namespace node</code>. Note that this is not\n   * currently a node type defined by the DOM API.\n   ",
    "links" : [ ]
  }, {
    "name" : "NTYPES",
    "type" : "short",
    "comment" : "\n   * The number of valid nodetypes.\n   ",
    "links" : [ ]
  } ],
  "methods" : [ {
    "name" : "public void setFeature(String featureId, boolean state)",
    "returnType" : "void",
    "comment" : "\n   * Set an implementation dependent feature.\n   * <p>\n   * %REVIEW% Do we really expect to set features on DTMs?\n   *\n   * @param featureId A feature URL.\n   * @param state true if this feature should be on, false otherwise.\n   ",
    "links" : [ ]
  }, {
    "name" : "public void setProperty(String property, Object value)",
    "returnType" : "void",
    "comment" : "\n   * Set a run time property for this DTM instance.\n   *\n   * @param property a <code>String</code> value\n   * @param value an <code>Object</code> value\n   ",
    "links" : [ ]
  }, {
    "name" : "public DTMAxisTraverser getAxisTraverser(final int axis)",
    "returnType" : "DTMAxisTraverser",
    "comment" : "\n   * This returns a stateless \"traverser\", that can navigate over an\n   * XPath axis, though not in document order.\n   *\n   * @param axis One of Axes.ANCESTORORSELF, etc.\n   *\n   * @return A DTMAxisIterator, or null if the givin axis isn't supported.\n   ",
    "links" : [ ]
  }, {
    "name" : "public DTMAxisIterator getAxisIterator(final int axis)",
    "returnType" : "DTMAxisIterator",
    "comment" : "\n   * This is a shortcut to the iterators that implement\n   * XPath axes.\n   * Returns a bare-bones iterator that must be initialized\n   * with a start node (using iterator.setStartNode()).\n   *\n   * @param axis One of Axes.ANCESTORORSELF, etc.\n   *\n   * @return A DTMAxisIterator, or null if the givin axis isn't supported.\n   ",
    "links" : [ ]
  }, {
    "name" : "public DTMAxisIterator getTypedAxisIterator(final int axis, final int type)",
    "returnType" : "DTMAxisIterator",
    "comment" : "\n   * Get an iterator that can navigate over an XPath Axis, predicated by\n   * the extended type ID.\n   *\n   * @param axis\n   * @param type An extended type ID.\n   *\n   * @return A DTMAxisIterator, or null if the givin axis isn't supported.\n   ",
    "links" : [ ]
  }, {
    "name" : "public boolean hasChildNodes(int nodeHandle)",
    "returnType" : "boolean",
    "comment" : "\n   * Given a node handle, test if it has child nodes.\n   * <p> %REVIEW% This is obviously useful at the DOM layer, where it\n   * would permit testing this without having to create a proxy\n   * node. It's less useful in the DTM API, where\n   * (dtm.getFirstChild(nodeHandle)!=DTM.NULL) is just as fast and\n   * almost as self-evident. But it's a convenience, and eases porting\n   * of DOM code to DTM.  </p>\n   *\n   * @param nodeHandle int Handle of the node.\n   * @return int true if the given node has child nodes.\n   ",
    "links" : [ ]
  }, {
    "name" : "public int getFirstChild(int nodeHandle)",
    "returnType" : "int",
    "comment" : "\n   * Given a node handle, get the handle of the node's first child.\n   *\n   * @param nodeHandle int Handle of the node.\n   * @return int DTM node-number of first child,\n   * or DTM.NULL to indicate none exists.\n   ",
    "links" : [ ]
  }, {
    "name" : "public int getLastChild(int nodeHandle)",
    "returnType" : "int",
    "comment" : "\n   * Given a node handle, get the handle of the node's last child.\n   *\n   * @param nodeHandle int Handle of the node.\n   * @return int Node-number of last child,\n   * or DTM.NULL to indicate none exists.\n   ",
    "links" : [ ]
  }, {
    "name" : "public int getAttributeNode(int elementHandle, String namespaceURI, String name)",
    "returnType" : "int",
    "comment" : "\n   * Retrieves an attribute node by local name and namespace URI\n   *\n   * %TBD% Note that we currently have no way to support\n   * the DOM's old getAttribute() call, which accesses only the qname.\n   *\n   * @param elementHandle Handle of the node upon which to look up this attribute.\n   * @param namespaceURI The namespace URI of the attribute to\n   *   retrieve, or null.\n   * @param name The local name of the attribute to\n   *   retrieve.\n   * @return The attribute node handle with the specified name (\n   *   <code>nodeName</code>) or <code>DTM.NULL</code> if there is no such\n   *   attribute.\n   ",
    "links" : [ ]
  }, {
    "name" : "public int getFirstAttribute(int nodeHandle)",
    "returnType" : "int",
    "comment" : "\n   * Given a node handle, get the index of the node's first attribute.\n   *\n   * @param nodeHandle int Handle of the node.\n   * @return Handle of first attribute, or DTM.NULL to indicate none exists.\n   ",
    "links" : [ ]
  }, {
    "name" : "public int getFirstNamespaceNode(int nodeHandle, boolean inScope)",
    "returnType" : "int",
    "comment" : "\n   * Given a node handle, get the index of the node's first namespace node.\n   *\n   * @param nodeHandle handle to node, which should probably be an element\n   *                   node, but need not be.\n   *\n   * @param inScope true if all namespaces in scope should be\n   *                   returned, false if only the node's own\n   *                   namespace declarations should be returned.\n   * @return handle of first namespace,\n   * or DTM.NULL to indicate none exists.\n   ",
    "links" : [ ]
  }, {
    "name" : "public int getNextSibling(int nodeHandle)",
    "returnType" : "int",
    "comment" : "\n   * Given a node handle, advance to its next sibling.\n   * @param nodeHandle int Handle of the node.\n   * @return int Node-number of next sibling,\n   * or DTM.NULL to indicate none exists.\n   ",
    "links" : [ ]
  }, {
    "name" : "public int getPreviousSibling(int nodeHandle)",
    "returnType" : "int",
    "comment" : "\n   * Given a node handle, find its preceeding sibling.\n   * WARNING: DTM implementations may be asymmetric; in some,\n   * this operation has been resolved by search, and is relatively expensive.\n   *\n   * @param nodeHandle the id of the node.\n   * @return int Node-number of the previous sib,\n   * or DTM.NULL to indicate none exists.\n   ",
    "links" : [ ]
  }, {
    "name" : "public int getNextAttribute(int nodeHandle)",
    "returnType" : "int",
    "comment" : "\n   * Given a node handle, advance to the next attribute. If an\n   * element, we advance to its first attribute; if an attr, we advance to\n   * the next attr of the same element.\n   *\n   * @param nodeHandle int Handle of the node.\n   * @return int DTM node-number of the resolved attr,\n   * or DTM.NULL to indicate none exists.\n   ",
    "links" : [ ]
  }, {
    "name" : "public int getNextNamespaceNode(int baseHandle, int namespaceHandle, boolean inScope)",
    "returnType" : "int",
    "comment" : "\n   * Given a namespace handle, advance to the next namespace in the same scope\n   * (local or local-plus-inherited, as selected by getFirstNamespaceNode)\n   *\n   * @param baseHandle handle to original node from where the first child\n   * was relative to (needed to return nodes in document order).\n   * @param namespaceHandle handle to node which must be of type\n   * NAMESPACE_NODE.\n   * NEEDSDOC @param inScope\n   * @return handle of next namespace,\n   * or DTM.NULL to indicate none exists.\n   ",
    "links" : [ ]
  }, {
    "name" : "public int getParent(int nodeHandle)",
    "returnType" : "int",
    "comment" : "\n   * Given a node handle, find its parent node.\n   *\n   * @param nodeHandle the id of the node.\n   * @return int Node handle of parent,\n   * or DTM.NULL to indicate none exists.\n   ",
    "links" : [ ]
  }, {
    "name" : "public int getDocument()",
    "returnType" : "int",
    "comment" : "\n   * Given a DTM which contains only a single document, \n   * find the Node Handle of the  Document node. Note \n   * that if the DTM is configured so it can contain multiple\n   * documents, this call will return the Document currently\n   * under construction -- but may return null if it's between\n   * documents. Generally, you should use getOwnerDocument(nodeHandle)\n   * or getDocumentRoot(nodeHandle) instead.\n   *\n   * @return int Node handle of document, or DTM.NULL if a shared DTM\n   * can not tell us which Document is currently active.\n   ",
    "links" : [ ]
  }, {
    "name" : "public int getOwnerDocument(int nodeHandle)",
    "returnType" : "int",
    "comment" : "\n   * Given a node handle, find the owning document node. This version mimics\n   * the behavior of the DOM call by the same name.\n   *\n   * @param nodeHandle the id of the node.\n   * @return int Node handle of owning document, or DTM.NULL if the node was\n   * a Document.\n   * @see #getDocumentRoot(int nodeHandle)\n   ",
    "links" : [ ]
  }, {
    "name" : "public int getDocumentRoot(int nodeHandle)",
    "returnType" : "int",
    "comment" : "\n   * Given a node handle, find the owning document node.\n   *\n   * @param nodeHandle the id of the node.\n   * @return int Node handle of owning document, or the node itself if it was\n   * a Document. (Note difference from DOM, where getOwnerDocument returns\n   * null for the Document node.)\n   * @see #getOwnerDocument(int nodeHandle)\n   ",
    "links" : [ ]
  }, {
    "name" : "public XMLString getStringValue(int nodeHandle)",
    "returnType" : "XMLString",
    "comment" : "\n   * Get the string-value of a node as a String object\n   * (see http://www.w3.org/TR/xpath#data-model\n   * for the definition of a node's string-value).\n   *\n   * @param nodeHandle The node ID.\n   *\n   * @return A string object that represents the string-value of the given node.\n   ",
    "links" : [ ]
  }, {
    "name" : "public int getStringValueChunkCount(int nodeHandle)",
    "returnType" : "int",
    "comment" : "\n   * Get number of character array chunks in\n   * the string-value of a node.\n   * (see http://www.w3.org/TR/xpath#data-model\n   * for the definition of a node's string-value).\n   * Note that a single text node may have multiple text chunks.\n   *\n   * @param nodeHandle The node ID.\n   *\n   * @return number of character array chunks in\n   *         the string-value of a node.\n   ",
    "links" : [ ]
  }, {
    "name" : "public char[] getStringValueChunk(int nodeHandle, int chunkIndex, int[] startAndLen)",
    "returnType" : "char[]",
    "comment" : "\n   * Get a character array chunk in the string-value of a node.\n   * (see http://www.w3.org/TR/xpath#data-model\n   * for the definition of a node's string-value).\n   * Note that a single text node may have multiple text chunks.\n   *\n   * @param nodeHandle The node ID.\n   * @param chunkIndex Which chunk to get.\n   * @param startAndLen  A two-integer array which, upon return, WILL\n   * BE FILLED with values representing the chunk's start position\n   * within the returned character buffer and the length of the chunk.\n   * @return The character array buffer within which the chunk occurs,\n   * setting startAndLen's contents as a side-effect.\n   ",
    "links" : [ ]
  }, {
    "name" : "public int getExpandedTypeID(int nodeHandle)",
    "returnType" : "int",
    "comment" : "\n   * Given a node handle, return an ID that represents the node's expanded name.\n   *\n   * @param nodeHandle The handle to the node in question.\n   *\n   * @return the expanded-name id of the node.\n   ",
    "links" : [ ]
  }, {
    "name" : "public int getExpandedTypeID(String namespace, String localName, int type)",
    "returnType" : "int",
    "comment" : "\n   * Given an expanded name, return an ID.  If the expanded-name does not\n   * exist in the internal tables, the entry will be created, and the ID will\n   * be returned.  Any additional nodes that are created that have this\n   * expanded name will use this ID.\n   *\n   * NEEDSDOC @param namespace\n   * NEEDSDOC @param localName\n   * NEEDSDOC @param type\n   *\n   * @return the expanded-name id of the node.\n   ",
    "links" : [ ]
  }, {
    "name" : "public String getLocalNameFromExpandedNameID(int ExpandedNameID)",
    "returnType" : "String",
    "comment" : "\n   * Given an expanded-name ID, return the local name part.\n   *\n   * @param ExpandedNameID an ID that represents an expanded-name.\n   * @return String Local name of this node.\n   ",
    "links" : [ ]
  }, {
    "name" : "public String getNamespaceFromExpandedNameID(int ExpandedNameID)",
    "returnType" : "String",
    "comment" : "\n   * Given an expanded-name ID, return the namespace URI part.\n   *\n   * @param ExpandedNameID an ID that represents an expanded-name.\n   * @return String URI value of this node's namespace, or null if no\n   * namespace was resolved.\n   ",
    "links" : [ ]
  }, {
    "name" : "public String getNodeName(int nodeHandle)",
    "returnType" : "String",
    "comment" : "\n   * Given a node handle, return its DOM-style node name. This will\n   * include names such as #text or #document.\n   *\n   * @param nodeHandle the id of the node.\n   * @return String Name of this node, which may be an empty string.\n   * %REVIEW% Document when empty string is possible...\n   ",
    "links" : [ ]
  }, {
    "name" : "public String getNodeNameX(int nodeHandle)",
    "returnType" : "String",
    "comment" : "\n   * Given a node handle, return the XPath node name.  This should be\n   * the name as described by the XPath data model, NOT the DOM-style\n   * name.\n   *\n   * @param nodeHandle the id of the node.\n   * @return String Name of this node.\n   ",
    "links" : [ ]
  }, {
    "name" : "public String getLocalName(int nodeHandle)",
    "returnType" : "String",
    "comment" : "\n   * Given a node handle, return its DOM-style localname.\n   * (As defined in Namespaces, this is the portion of the name after the\n   * prefix, if present, or the whole node name if no prefix exists)\n   *\n   * @param nodeHandle the id of the node.\n   * @return String Local name of this node.\n   ",
    "links" : [ ]
  }, {
    "name" : "public String getPrefix(int nodeHandle)",
    "returnType" : "String",
    "comment" : "\n   * Given a namespace handle, return the prefix that the namespace decl is\n   * mapping.\n   * Given a node handle, return the prefix used to map to the namespace.\n   * (As defined in Namespaces, this is the portion of the name before any\n   * colon character).\n   *\n   * <p> %REVIEW% Are you sure you want \"\" for no prefix?  </p>\n   *\n   * @param nodeHandle the id of the node.\n   * @return String prefix of this node's name, or \"\" if no explicit\n   * namespace prefix was given.\n   ",
    "links" : [ ]
  }, {
    "name" : "public String getNamespaceURI(int nodeHandle)",
    "returnType" : "String",
    "comment" : "\n   * Given a node handle, return its DOM-style namespace URI\n   * (As defined in Namespaces, this is the declared URI which this node's\n   * prefix -- or default in lieu thereof -- was mapped to.)\n   * @param nodeHandle the id of the node.\n   * @return String URI value of this node's namespace, or null if no\n   * namespace was resolved.\n   ",
    "links" : [ ]
  }, {
    "name" : "public String getNodeValue(int nodeHandle)",
    "returnType" : "String",
    "comment" : "\n   * Given a node handle, return its node value. This is mostly\n   * as defined by the DOM, but may ignore some conveniences.\n   * <p>\n   * @param nodeHandle The node id.\n   * @return String Value of this node, or null if not\n   * meaningful for this node type.\n   ",
    "links" : [ ]
  }, {
    "name" : "public short getNodeType(int nodeHandle)",
    "returnType" : "short",
    "comment" : "\n   * Given a node handle, return its DOM-style node type.\n   *\n   * <p>%REVIEW% Generally, returning short is false economy. Return int?</p>\n   *\n   * @param nodeHandle The node id.\n   * @return int Node type, as per the DOM's Node._NODE constants.\n   ",
    "links" : [ ]
  }, {
    "name" : "public short getLevel(int nodeHandle)",
    "returnType" : "short",
    "comment" : "\n   * Get the depth level of this node in the tree (equals 1 for\n   * a parentless node).\n   *\n   * @param nodeHandle The node id.\n   * @return the number of ancestors, plus one\n   * @xsl.usage internal\n   ",
    "links" : [ ]
  }, {
    "name" : "public boolean isSupported(String feature, String version)",
    "returnType" : "boolean",
    "comment" : "\n   * Tests whether DTM DOM implementation implements a specific feature and\n   * that feature is supported by this node.\n   * @param feature The name of the feature to test.\n   * @param version This is the version number of the feature to test.\n   *   If the version is not\n   *   specified, supporting any version of the feature will cause the\n   *   method to return <code>true</code>.\n   * @return Returns <code>true</code> if the specified feature is\n   *   supported on this node, <code>false</code> otherwise.\n   ",
    "links" : [ ]
  }, {
    "name" : "public String getDocumentBaseURI()",
    "returnType" : "String",
    "comment" : "\n   * Return the base URI of the document entity. If it is not known\n   * (because the document was parsed from a socket connection or from\n   * standard input, for example), the value of this property is unknown.\n   *\n   * @return the document base URI String object or null if unknown.\n   ",
    "links" : [ ]
  }, {
    "name" : "public void setDocumentBaseURI(String baseURI)",
    "returnType" : "void",
    "comment" : "\n   * Set the base URI of the document entity.\n   *\n   * @param baseURI the document base URI String object or null if unknown.\n   ",
    "links" : [ ]
  }, {
    "name" : "public String getDocumentSystemIdentifier(int nodeHandle)",
    "returnType" : "String",
    "comment" : "\n   * Return the system identifier of the document entity. If\n   * it is not known, the value of this property is null.\n   *\n   * @param nodeHandle The node id, which can be any valid node handle.\n   * @return the system identifier String object or null if unknown.\n   ",
    "links" : [ ]
  }, {
    "name" : "public String getDocumentEncoding(int nodeHandle)",
    "returnType" : "String",
    "comment" : "\n   * Return the name of the character encoding scheme\n   *        in which the document entity is expressed.\n   *\n   * @param nodeHandle The node id, which can be any valid node handle.\n   * @return the document encoding String object.\n   ",
    "links" : [ ]
  }, {
    "name" : "public String getDocumentStandalone(int nodeHandle)",
    "returnType" : "String",
    "comment" : "\n   * Return an indication of the standalone status of the document,\n   *        either \"yes\" or \"no\". This property is derived from the optional\n   *        standalone document declaration in the XML declaration at the\n   *        beginning of the document entity, and has no value if there is no\n   *        standalone document declaration.\n   *\n   * @param nodeHandle The node id, which can be any valid node handle.\n   * @return the document standalone String object, either \"yes\", \"no\", or null.\n   ",
    "links" : [ ]
  }, {
    "name" : "public String getDocumentVersion(int documentHandle)",
    "returnType" : "String",
    "comment" : "\n   * Return a string representing the XML version of the document. This\n   * property is derived from the XML declaration optionally present at the\n   * beginning of the document entity, and has no value if there is no XML\n   * declaration.\n   *\n   * @param documentHandle the document handle\n   * @return the document version String object\n   ",
    "links" : [ ]
  }, {
    "name" : "public boolean getDocumentAllDeclarationsProcessed()",
    "returnType" : "boolean",
    "comment" : "\n   * Return an indication of\n   * whether the processor has read the complete DTD. Its value is a\n   * boolean. If it is false, then certain properties (indicated in their\n   * descriptions below) may be unknown. If it is true, those properties\n   * are never unknown.\n   *\n   * @return <code>true</code> if all declarations were processed;\n   *         <code>false</code> otherwise.\n   ",
    "links" : [ ]
  }, {
    "name" : "public String getDocumentTypeDeclarationSystemIdentifier()",
    "returnType" : "String",
    "comment" : "\n   *   A document type declaration information item has the following properties:\n   *\n   *     1. [system identifier] The system identifier of the external subset, if\n   *        it exists. Otherwise this property has no value.\n   *\n   * @return the system identifier String object, or null if there is none.\n   ",
    "links" : [ ]
  }, {
    "name" : "public String getDocumentTypeDeclarationPublicIdentifier()",
    "returnType" : "String",
    "comment" : "\n   * Return the public identifier of the external subset,\n   * normalized as described in 4.2.2 External Entities [XML]. If there is\n   * no external subset or if it has no public identifier, this property\n   * has no value.\n   *\n   * @return the public identifier String object, or null if there is none.\n   ",
    "links" : [ ]
  }, {
    "name" : "public int getElementById(String elementId)",
    "returnType" : "int",
    "comment" : "\n   * Returns the <code>Element</code> whose <code>ID</code> is given by\n   * <code>elementId</code>. If no such element exists, returns\n   * <code>DTM.NULL</code>. Behavior is not defined if more than one element\n   * has this <code>ID</code>. Attributes (including those\n   * with the name \"ID\") are not of type ID unless so defined by DTD/Schema\n   * information available to the DTM implementation.\n   * Implementations that do not know whether attributes are of type ID or\n   * not are expected to return <code>DTM.NULL</code>.\n   *\n   * <p>%REVIEW% Presumably IDs are still scoped to a single document,\n   * and this operation searches only within a single document, right?\n   * Wouldn't want collisions between DTMs in the same process.</p>\n   *\n   * @param elementId The unique <code>id</code> value for an element.\n   * @return The handle of the matching element.\n   ",
    "links" : [ ]
  }, {
    "name" : "public String getUnparsedEntityURI(String name)",
    "returnType" : "String",
    "comment" : "\n   * The getUnparsedEntityURI function returns the URI of the unparsed\n   * entity with the specified name in the same document as the context\n   * node (see [3.3 Unparsed Entities]). It returns the empty string if\n   * there is no such entity.\n   * <p>\n   * XML processors may choose to use the System Identifier (if one\n   * is provided) to resolve the entity, rather than the URI in the\n   * Public Identifier. The details are dependent on the processor, and\n   * we would have to support some form of plug-in resolver to handle\n   * this properly. Currently, we simply return the System Identifier if\n   * present, and hope that it a usable URI or that our caller can\n   * map it to one.\n   * %REVIEW% Resolve Public Identifiers... or consider changing function name.\n   * <p>\n   * If we find a relative URI\n   * reference, XML expects it to be resolved in terms of the base URI\n   * of the document. The DOM doesn't do that for us, and it isn't\n   * entirely clear whether that should be done here; currently that's\n   * pushed up to a higher level of our application. (Note that DOM Level\n   * 1 didn't store the document's base URI.)\n   * %REVIEW% Consider resolving Relative URIs.\n   * <p>\n   * (The DOM's statement that \"An XML processor may choose to\n   * completely expand entities before the structure model is passed\n   * to the DOM\" refers only to parsed entities, not unparsed, and hence\n   * doesn't affect this function.)\n   *\n   * @param name A string containing the Entity Name of the unparsed\n   * entity.\n   *\n   * @return String containing the URI of the Unparsed Entity, or an\n   * empty string if no such entity exists.\n   ",
    "links" : [ ]
  }, {
    "name" : "public boolean supportsPreStripping()",
    "returnType" : "boolean",
    "comment" : "\n   * Return true if the xsl:strip-space or xsl:preserve-space was processed\n   * during construction of the document contained in this DTM.\n   *\n   * NEEDSDOC ($objectName$) @return\n   ",
    "links" : [ ]
  }, {
    "name" : "public boolean isNodeAfter(int firstNodeHandle, int secondNodeHandle)",
    "returnType" : "boolean",
    "comment" : "\n   * Figure out whether nodeHandle2 should be considered as being later\n   * in the document than nodeHandle1, in Document Order as defined\n   * by the XPath model. This may not agree with the ordering defined\n   * by other XML applications.\n   * <p>\n   * There are some cases where ordering isn't defined, and neither are\n   * the results of this function -- though we'll generally return true.\n   * <p>\n   * %REVIEW% Make sure this does the right thing with attribute nodes!!!\n   * <p>\n   * %REVIEW% Consider renaming for clarity. Perhaps isDocumentOrder(a,b)?\n   *\n   * @param firstNodeHandle DOM Node to perform position comparison on.\n   * @param secondNodeHandle DOM Node to perform position comparison on.\n   *\n   * @return false if secondNode comes before firstNode, otherwise return true.\n   * You can think of this as\n   * <code>(firstNode.documentOrderPosition &lt;= secondNode.documentOrderPosition)</code>.\n   ",
    "links" : [ ]
  }, {
    "name" : "public boolean isCharacterElementContentWhitespace(int nodeHandle)",
    "returnType" : "boolean",
    "comment" : "\n   * 2. [element content whitespace] A boolean indicating whether a\n   * text node represents white space appearing within element content\n   * (see [XML], 2.10 \"White Space Handling\").  Note that validating\n   * XML processors are required by XML 1.0 to provide this\n   * information... but that DOM Level 2 did not support it, since it\n   * depends on knowledge of the DTD which DOM2 could not guarantee\n   * would be available.\n   * <p>\n   * If there is no declaration for the containing element, an XML\n   * processor must assume that the whitespace could be meaningful and\n   * return false. If no declaration has been read, but the [all\n   * declarations processed] property of the document information item\n   * is false (so there may be an unread declaration), then the value\n   * of this property is indeterminate for white space characters and\n   * should probably be reported as false. It is always false for text\n   * nodes that contain anything other than (or in addition to) white\n   * space.\n   * <p>\n   * Note too that it always returns false for non-Text nodes.\n   * <p>\n   * %REVIEW% Joe wants to rename this isWhitespaceInElementContent() for clarity\n   *\n   * @param nodeHandle the node ID.\n   * @return <code>true</code> if the node definitely represents whitespace in\n   * element content; <code>false</code> otherwise.\n   ",
    "links" : [ ]
  }, {
    "name" : "public boolean isDocumentAllDeclarationsProcessed(int documentHandle)",
    "returnType" : "boolean",
    "comment" : "\n   *    10. [all declarations processed] This property is not strictly speaking\n   *        part of the infoset of the document. Rather it is an indication of\n   *        whether the processor has read the complete DTD. Its value is a\n   *        boolean. If it is false, then certain properties (indicated in their\n   *        descriptions below) may be unknown. If it is true, those properties\n   *        are never unknown.\n   *\n   * @param documentHandle A node handle that must identify a document.\n   * @return <code>true</code> if all declarations were processed;\n   *         <code>false</code> otherwise.\n   ",
    "links" : [ ]
  }, {
    "name" : "public boolean isAttributeSpecified(int attributeHandle)",
    "returnType" : "boolean",
    "comment" : "\n   *     5. [specified] A flag indicating whether this attribute was actually\n   *        specified in the start-tag of its element, or was defaulted from the\n   *        DTD (or schema).\n   *\n   * @param attributeHandle The attribute handle\n   * @return <code>true</code> if the attribute was specified;\n   *         <code>false</code> if it was defaulted or the handle doesn't\n   *            refer to an attribute node.\n   ",
    "links" : [ ]
  }, {
    "name" : "public void dispatchCharactersEvents(int nodeHandle, org.xml.sax.ContentHandler ch, boolean normalize) throws org.xml.sax.SAXException",
    "returnType" : "void",
    "comment" : "\n   * Directly call the\n   * characters method on the passed ContentHandler for the\n   * string-value of the given node (see http://www.w3.org/TR/xpath#data-model\n   * for the definition of a node's string-value). Multiple calls to the\n   * ContentHandler's characters methods may well occur for a single call to\n   * this method.\n   *\n   * @param nodeHandle The node ID.\n   * @param ch A non-null reference to a ContentHandler.\n   * @param normalize true if the content should be normalized according to\n   * the rules for the XPath\n   * <a href=\"http://www.w3.org/TR/xpath#function-normalize-space\">normalize-space</a>\n   * function.\n   *\n   * @throws org.xml.sax.SAXException\n   ",
    "links" : [ ]
  }, {
    "name" : "public void dispatchToEvents(int nodeHandle, org.xml.sax.ContentHandler ch) throws org.xml.sax.SAXException",
    "returnType" : "void",
    "comment" : "\n   * Directly create SAX parser events representing the XML content of\n   * a DTM subtree. This is a \"serialize\" operation.\n   *\n   * @param nodeHandle The node ID.\n   * @param ch A non-null reference to a ContentHandler.\n   *\n   * @throws org.xml.sax.SAXException\n   ",
    "links" : [ ]
  }, {
    "name" : "public org.w3c.dom.Node getNode(int nodeHandle)",
    "returnType" : "org.w3c.dom.Node",
    "comment" : "\n   * Return an DOM node for the given node.\n   *\n   * @param nodeHandle The node ID.\n   *\n   * @return A node representation of the DTM node.\n   ",
    "links" : [ ]
  }, {
    "name" : "public boolean needsTwoThreads()",
    "returnType" : "boolean",
    "comment" : "\n   * @return true iff we're building this model incrementally (eg\n   * we're partnered with a CoroutineParser) and thus require that the\n   * transformation and the parse run simultaneously. Guidance to the\n   * DTMManager.\n   ",
    "links" : [ ]
  }, {
    "name" : "public org.xml.sax.ContentHandler getContentHandler()",
    "returnType" : "org.xml.sax.ContentHandler",
    "comment" : "\n   * Return this DTM's content handler, if it has one.\n   *\n   * @return null if this model doesn't respond to SAX events.\n   ",
    "links" : [ ]
  }, {
    "name" : "public org.xml.sax.ext.LexicalHandler getLexicalHandler()",
    "returnType" : "org.xml.sax.ext.LexicalHandler",
    "comment" : "\n   * Return this DTM's lexical handler, if it has one.\n   *\n   * %REVIEW% Should this return null if constrution already done/begun?\n   *\n   * @return null if this model doesn't respond to lexical SAX events.\n   ",
    "links" : [ ]
  }, {
    "name" : "public org.xml.sax.EntityResolver getEntityResolver()",
    "returnType" : "org.xml.sax.EntityResolver",
    "comment" : "\n   * Return this DTM's EntityResolver, if it has one.\n   *\n   * @return null if this model doesn't respond to SAX entity ref events.\n   ",
    "links" : [ ]
  }, {
    "name" : "public org.xml.sax.DTDHandler getDTDHandler()",
    "returnType" : "org.xml.sax.DTDHandler",
    "comment" : "\n   * Return this DTM's DTDHandler, if it has one.\n   *\n   * @return null if this model doesn't respond to SAX dtd events.\n   ",
    "links" : [ ]
  }, {
    "name" : "public org.xml.sax.ErrorHandler getErrorHandler()",
    "returnType" : "org.xml.sax.ErrorHandler",
    "comment" : "\n   * Return this DTM's ErrorHandler, if it has one.\n   *\n   * @return null if this model doesn't respond to SAX error events.\n   ",
    "links" : [ ]
  }, {
    "name" : "public org.xml.sax.ext.DeclHandler getDeclHandler()",
    "returnType" : "org.xml.sax.ext.DeclHandler",
    "comment" : "\n   * Return this DTM's DeclHandler, if it has one.\n   *\n   * @return null if this model doesn't respond to SAX Decl events.\n   ",
    "links" : [ ]
  }, {
    "name" : "public void appendChild(int newChild, boolean clone, boolean cloneDepth)",
    "returnType" : "void",
    "comment" : "\n   * Append a child to \"the end of the document\". Please note that\n   * the node is always cloned in a base DTM, since our basic behavior\n   * is immutable so nodes can't be removed from their previous\n   * location.\n   *\n   * <p> %REVIEW%  DTM maintains an insertion cursor which\n   * performs a depth-first tree walk as nodes come in, and this operation\n   * is really equivalent to:\n   *    insertionCursor.appendChild(document.importNode(newChild)))\n   * where the insert point is the last element that was appended (or\n   * the last one popped back to by an end-element operation).</p>\n   *\n   * @param newChild Must be a valid new node handle.\n   * @param clone true if the child should be cloned into the document.\n   * @param cloneDepth if the clone argument is true, specifies that the\n   *                   clone should include all it's children.\n   ",
    "links" : [ ]
  }, {
    "name" : "public void appendTextChild(String str)",
    "returnType" : "void",
    "comment" : "\n   * Append a text node child that will be constructed from a string,\n   * to the end of the document. Behavior is otherwise like appendChild().\n   *\n   * @param str Non-null reference to a string.\n   ",
    "links" : [ ]
  }, {
    "name" : "public SourceLocator getSourceLocatorFor(int node)",
    "returnType" : "SourceLocator",
    "comment" : "\n   * Get the location of a node in the source document.\n   *\n   * @param node an <code>int</code> value\n   * @return a <code>SourceLocator</code> value or null if no location\n   * is available\n   ",
    "links" : [ ]
  }, {
    "name" : "public void documentRegistration()",
    "returnType" : "void",
    "comment" : "\n   * As the DTM is registered with the DTMManager, this method\n   * will be called. This will give the DTM implementation a\n   * chance to initialize any subsystems that are required to\n   * build the DTM\n   ",
    "links" : [ ]
  }, {
    "name" : "public void documentRelease()",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public void migrateTo(DTMManager manager)",
    "returnType" : "void",
    "comment" : "\n    * Migrate a DTM built with an old DTMManager to a new DTMManager.\n    * After the migration, the new DTMManager will treat the DTM as\n    * one that is built by itself.\n    * This is used to support DTM sharing between multiple transformations.\n    * @param manager the DTMManager\n    ",
    "links" : [ ]
  } ],
  "methodNames" : [ "public void setFeature(String featureId, boolean state)", "public void setProperty(String property, Object value)", "public DTMAxisTraverser getAxisTraverser(final int axis)", "public DTMAxisIterator getAxisIterator(final int axis)", "public DTMAxisIterator getTypedAxisIterator(final int axis, final int type)", "public boolean hasChildNodes(int nodeHandle)", "public int getFirstChild(int nodeHandle)", "public int getLastChild(int nodeHandle)", "public int getAttributeNode(int elementHandle, String namespaceURI, String name)", "public int getFirstAttribute(int nodeHandle)", "public int getFirstNamespaceNode(int nodeHandle, boolean inScope)", "public int getNextSibling(int nodeHandle)", "public int getPreviousSibling(int nodeHandle)", "public int getNextAttribute(int nodeHandle)", "public int getNextNamespaceNode(int baseHandle, int namespaceHandle, boolean inScope)", "public int getParent(int nodeHandle)", "public int getDocument()", "public int getOwnerDocument(int nodeHandle)", "public int getDocumentRoot(int nodeHandle)", "public XMLString getStringValue(int nodeHandle)", "public int getStringValueChunkCount(int nodeHandle)", "public char[] getStringValueChunk(int nodeHandle, int chunkIndex, int[] startAndLen)", "public int getExpandedTypeID(int nodeHandle)", "public int getExpandedTypeID(String namespace, String localName, int type)", "public String getLocalNameFromExpandedNameID(int ExpandedNameID)", "public String getNamespaceFromExpandedNameID(int ExpandedNameID)", "public String getNodeName(int nodeHandle)", "public String getNodeNameX(int nodeHandle)", "public String getLocalName(int nodeHandle)", "public String getPrefix(int nodeHandle)", "public String getNamespaceURI(int nodeHandle)", "public String getNodeValue(int nodeHandle)", "public short getNodeType(int nodeHandle)", "public short getLevel(int nodeHandle)", "public boolean isSupported(String feature, String version)", "public String getDocumentBaseURI()", "public void setDocumentBaseURI(String baseURI)", "public String getDocumentSystemIdentifier(int nodeHandle)", "public String getDocumentEncoding(int nodeHandle)", "public String getDocumentStandalone(int nodeHandle)", "public String getDocumentVersion(int documentHandle)", "public boolean getDocumentAllDeclarationsProcessed()", "public String getDocumentTypeDeclarationSystemIdentifier()", "public String getDocumentTypeDeclarationPublicIdentifier()", "public int getElementById(String elementId)", "public String getUnparsedEntityURI(String name)", "public boolean supportsPreStripping()", "public boolean isNodeAfter(int firstNodeHandle, int secondNodeHandle)", "public boolean isCharacterElementContentWhitespace(int nodeHandle)", "public boolean isDocumentAllDeclarationsProcessed(int documentHandle)", "public boolean isAttributeSpecified(int attributeHandle)", "public void dispatchCharactersEvents(int nodeHandle, org.xml.sax.ContentHandler ch, boolean normalize) throws org.xml.sax.SAXException", "public void dispatchToEvents(int nodeHandle, org.xml.sax.ContentHandler ch) throws org.xml.sax.SAXException", "public org.w3c.dom.Node getNode(int nodeHandle)", "public boolean needsTwoThreads()", "public org.xml.sax.ContentHandler getContentHandler()", "public org.xml.sax.ext.LexicalHandler getLexicalHandler()", "public org.xml.sax.EntityResolver getEntityResolver()", "public org.xml.sax.DTDHandler getDTDHandler()", "public org.xml.sax.ErrorHandler getErrorHandler()", "public org.xml.sax.ext.DeclHandler getDeclHandler()", "public void appendChild(int newChild, boolean clone, boolean cloneDepth)", "public void appendTextChild(String str)", "public SourceLocator getSourceLocatorFor(int node)", "public void documentRegistration()", "public void documentRelease()", "public void migrateTo(DTMManager manager)" ],
  "variableNames" : [ "NULL", "ROOT_NODE", "ELEMENT_NODE", "ATTRIBUTE_NODE", "TEXT_NODE", "CDATA_SECTION_NODE", "ENTITY_REFERENCE_NODE", "ENTITY_NODE", "PROCESSING_INSTRUCTION_NODE", "COMMENT_NODE", "DOCUMENT_NODE", "DOCUMENT_TYPE_NODE", "DOCUMENT_FRAGMENT_NODE", "NOTATION_NODE", "NAMESPACE_NODE", "NTYPES" ]
}