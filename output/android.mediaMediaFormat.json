{
  "filePath" : "/home/maryam/clearblue/files/android-source-30/android/media/MediaFormat.java",
  "packageName" : "android.media",
  "className" : "MediaFormat",
  "comment" : "\n * Encapsulates the information describing the format of media data, be it audio or video, as\n * well as optional feature metadata.\n * <p>\n * The format of the media data is specified as key/value pairs. Keys are strings. Values can\n * be integer, long, float, String or ByteBuffer.\n * <p>\n * The feature metadata is specificed as string/boolean pairs.\n * <p>\n * Keys common to all audio/video formats, <b>all keys not marked optional are mandatory</b>:\n *\n * <table>\n * <tr><th>Name</th><th>Value Type</th><th>Description</th></tr>\n * <tr><td>{@link #KEY_MIME}</td><td>String</td><td>The type of the format.</td></tr>\n * <tr><td>{@link #KEY_CODECS_STRING}</td><td>String</td><td>optional, the RFC 6381 codecs string of the MediaFormat</td></tr>\n * <tr><td>{@link #KEY_MAX_INPUT_SIZE}</td><td>Integer</td><td>optional, maximum size of a buffer of input data</td></tr>\n * <tr><td>{@link #KEY_PIXEL_ASPECT_RATIO_WIDTH}</td><td>Integer</td><td>optional, the pixel aspect ratio width</td></tr>\n * <tr><td>{@link #KEY_PIXEL_ASPECT_RATIO_HEIGHT}</td><td>Integer</td><td>optional, the pixel aspect ratio height</td></tr>\n * <tr><td>{@link #KEY_BIT_RATE}</td><td>Integer</td><td><b>encoder-only</b>, desired bitrate in bits/second</td></tr>\n * <tr><td>{@link #KEY_DURATION}</td><td>long</td><td>the duration of the content (in microseconds)</td></tr>\n * </table>\n *\n * Video formats have the following keys:\n * <table>\n * <tr><th>Name</th><th>Value Type</th><th>Description</th></tr>\n * <tr><td>{@link #KEY_WIDTH}</td><td>Integer</td><td></td></tr>\n * <tr><td>{@link #KEY_HEIGHT}</td><td>Integer</td><td></td></tr>\n * <tr><td>{@link #KEY_COLOR_FORMAT}</td><td>Integer</td><td>set by the user\n *         for encoders, readable in the output format of decoders</b></td></tr>\n * <tr><td>{@link #KEY_FRAME_RATE}</td><td>Integer or Float</td><td>required for <b>encoders</b>,\n *         optional for <b>decoders</b></td></tr>\n * <tr><td>{@link #KEY_CAPTURE_RATE}</td><td>Integer</td><td></td></tr>\n * <tr><td>{@link #KEY_I_FRAME_INTERVAL}</td><td>Integer (or Float)</td><td><b>encoder-only</b>,\n *         time-interval between key frames.\n *         Float support added in {@link android.os.Build.VERSION_CODES#N_MR1}</td></tr>\n * <tr><td>{@link #KEY_INTRA_REFRESH_PERIOD}</td><td>Integer</td><td><b>encoder-only</b>, optional</td></tr>\n * <tr><td>{@link #KEY_LATENCY}</td><td>Integer</td><td><b>encoder-only</b>, optional</td></tr>\n * <tr><td>{@link #KEY_MAX_WIDTH}</td><td>Integer</td><td><b>decoder-only</b>, optional, max-resolution width</td></tr>\n * <tr><td>{@link #KEY_MAX_HEIGHT}</td><td>Integer</td><td><b>decoder-only</b>, optional, max-resolution height</td></tr>\n * <tr><td>{@link #KEY_REPEAT_PREVIOUS_FRAME_AFTER}</td><td>Long</td><td><b>encoder in surface-mode\n *         only</b>, optional</td></tr>\n * <tr><td>{@link #KEY_PUSH_BLANK_BUFFERS_ON_STOP}</td><td>Integer(1)</td><td><b>decoder rendering\n *         to a surface only</b>, optional</td></tr>\n * <tr><td>{@link #KEY_TEMPORAL_LAYERING}</td><td>String</td><td><b>encoder only</b>, optional,\n *         temporal-layering schema</td></tr>\n * </table>\n * Specify both {@link #KEY_MAX_WIDTH} and {@link #KEY_MAX_HEIGHT} to enable\n * adaptive playback (seamless resolution change) for a video decoder that\n * supports it ({@link MediaCodecInfo.CodecCapabilities#FEATURE_AdaptivePlayback}).\n * The values are used as hints for the codec: they are the maximum expected\n * resolution to prepare for.  Depending on codec support, preparing for larger\n * maximum resolution may require more memory even if that resolution is never\n * reached.  These fields have no effect for codecs that do not support adaptive\n * playback.<br /><br />\n *\n * Audio formats have the following keys:\n * <table>\n * <tr><th>Name</th><th>Value Type</th><th>Description</th></tr>\n * <tr><td>{@link #KEY_CHANNEL_COUNT}</td><td>Integer</td><td></td></tr>\n * <tr><td>{@link #KEY_SAMPLE_RATE}</td><td>Integer</td><td></td></tr>\n * <tr><td>{@link #KEY_PCM_ENCODING}</td><td>Integer</td><td>optional</td></tr>\n * <tr><td>{@link #KEY_IS_ADTS}</td><td>Integer</td><td>optional, if <em>decoding</em> AAC audio content, setting this key to 1 indicates that each audio frame is prefixed by the ADTS header.</td></tr>\n * <tr><td>{@link #KEY_AAC_PROFILE}</td><td>Integer</td><td><b>encoder-only</b>, optional, if content is AAC audio, specifies the desired profile.</td></tr>\n * <tr><td>{@link #KEY_AAC_SBR_MODE}</td><td>Integer</td><td><b>encoder-only</b>, optional, if content is AAC audio, specifies the desired SBR mode.</td></tr>\n * <tr><td>{@link #KEY_AAC_DRC_TARGET_REFERENCE_LEVEL}</td><td>Integer</td><td><b>decoder-only</b>, optional, if content is AAC audio, specifies the target reference level.</td></tr>\n * <tr><td>{@link #KEY_AAC_ENCODED_TARGET_LEVEL}</td><td>Integer</td><td><b>decoder-only</b>, optional, if content is AAC audio, specifies the target reference level used at encoder.</td></tr>\n * <tr><td>{@link #KEY_AAC_DRC_BOOST_FACTOR}</td><td>Integer</td><td><b>decoder-only</b>, optional, if content is AAC audio, specifies the DRC boost factor.</td></tr>\n * <tr><td>{@link #KEY_AAC_DRC_ATTENUATION_FACTOR}</td><td>Integer</td><td><b>decoder-only</b>, optional, if content is AAC audio, specifies the DRC attenuation factor.</td></tr>\n * <tr><td>{@link #KEY_AAC_DRC_HEAVY_COMPRESSION}</td><td>Integer</td><td><b>decoder-only</b>, optional, if content is AAC audio, specifies whether to use heavy compression.</td></tr>\n * <tr><td>{@link #KEY_AAC_MAX_OUTPUT_CHANNEL_COUNT}</td><td>Integer</td><td><b>decoder-only</b>, optional, if content is AAC audio, specifies the maximum number of channels the decoder outputs.</td></tr>\n * <tr><td>{@link #KEY_AAC_DRC_EFFECT_TYPE}</td><td>Integer</td><td><b>decoder-only</b>, optional, if content is AAC audio, specifies the MPEG-D DRC effect type to use.</td></tr>\n * <tr><td>{@link #KEY_AAC_DRC_OUTPUT_LOUDNESS}</td><td>Integer</td><td><b>decoder-only</b>, optional, if content is AAC audio, returns the DRC output loudness.</td></tr>\n * <tr><td>{@link #KEY_AAC_DRC_ALBUM_MODE}</td><td>Integer</td><td><b>decoder-only</b>, optional, if content is AAC audio, specifies the whether MPEG-D DRC Album Mode is active or not.</td></tr>\n * <tr><td>{@link #KEY_CHANNEL_MASK}</td><td>Integer</td><td>optional, a mask of audio channel assignments</td></tr>\n * <tr><td>{@link #KEY_ENCODER_DELAY}</td><td>Integer</td><td>optional, the number of frames to trim from the start of the decoded audio stream.</td></tr>\n * <tr><td>{@link #KEY_ENCODER_PADDING}</td><td>Integer</td><td>optional, the number of frames to trim from the end of the decoded audio stream.</td></tr>\n * <tr><td>{@link #KEY_FLAC_COMPRESSION_LEVEL}</td><td>Integer</td><td><b>encoder-only</b>, optional, if content is FLAC audio, specifies the desired compression level.</td></tr>\n * </table>\n *\n * Subtitle formats have the following keys:\n * <table>\n * <tr><td>{@link #KEY_MIME}</td><td>String</td><td>The type of the format.</td></tr>\n * <tr><td>{@link #KEY_LANGUAGE}</td><td>String</td><td>The language of the content.</td></tr>\n * <tr><td>{@link #KEY_CAPTION_SERVICE_NUMBER}</td><td>int</td><td>optional, the closed-caption service or channel number.</td></tr>\n * </table>\n *\n * Image formats have the following keys:\n * <table>\n * <tr><td>{@link #KEY_MIME}</td><td>String</td><td>The type of the format.</td></tr>\n * <tr><td>{@link #KEY_WIDTH}</td><td>Integer</td><td></td></tr>\n * <tr><td>{@link #KEY_HEIGHT}</td><td>Integer</td><td></td></tr>\n * <tr><td>{@link #KEY_COLOR_FORMAT}</td><td>Integer</td><td>set by the user\n *         for encoders, readable in the output format of decoders</b></td></tr>\n * <tr><td>{@link #KEY_TILE_WIDTH}</td><td>Integer</td><td>required if the image has grid</td></tr>\n * <tr><td>{@link #KEY_TILE_HEIGHT}</td><td>Integer</td><td>required if the image has grid</td></tr>\n * <tr><td>{@link #KEY_GRID_ROWS}</td><td>Integer</td><td>required if the image has grid</td></tr>\n * <tr><td>{@link #KEY_GRID_COLUMNS}</td><td>Integer</td><td>required if the image has grid</td></tr>\n * </table>\n ",
  "variables" : [ {
    "name" : "MIMETYPE_VIDEO_VP8",
    "type" : "String",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "MIMETYPE_VIDEO_VP9",
    "type" : "String",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "MIMETYPE_VIDEO_AV1",
    "type" : "String",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "MIMETYPE_VIDEO_AVC",
    "type" : "String",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "MIMETYPE_VIDEO_HEVC",
    "type" : "String",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "MIMETYPE_VIDEO_MPEG4",
    "type" : "String",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "MIMETYPE_VIDEO_H263",
    "type" : "String",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "MIMETYPE_VIDEO_MPEG2",
    "type" : "String",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "MIMETYPE_VIDEO_RAW",
    "type" : "String",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "MIMETYPE_VIDEO_DOLBY_VISION",
    "type" : "String",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "MIMETYPE_VIDEO_SCRAMBLED",
    "type" : "String",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "MIMETYPE_AUDIO_AMR_NB",
    "type" : "String",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "MIMETYPE_AUDIO_AMR_WB",
    "type" : "String",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "MIMETYPE_AUDIO_MPEG",
    "type" : "String",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "MIMETYPE_AUDIO_AAC",
    "type" : "String",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "MIMETYPE_AUDIO_QCELP",
    "type" : "String",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "MIMETYPE_AUDIO_VORBIS",
    "type" : "String",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "MIMETYPE_AUDIO_OPUS",
    "type" : "String",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "MIMETYPE_AUDIO_G711_ALAW",
    "type" : "String",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "MIMETYPE_AUDIO_G711_MLAW",
    "type" : "String",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "MIMETYPE_AUDIO_RAW",
    "type" : "String",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "MIMETYPE_AUDIO_FLAC",
    "type" : "String",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "MIMETYPE_AUDIO_MSGSM",
    "type" : "String",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "MIMETYPE_AUDIO_AC3",
    "type" : "String",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "MIMETYPE_AUDIO_EAC3",
    "type" : "String",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "MIMETYPE_AUDIO_EAC3_JOC",
    "type" : "String",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "MIMETYPE_AUDIO_AC4",
    "type" : "String",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "MIMETYPE_AUDIO_SCRAMBLED",
    "type" : "String",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "MIMETYPE_IMAGE_ANDROID_HEIC",
    "type" : "String",
    "comment" : "\n     * MIME type for HEIF still image data encoded in HEVC.\n     *\n     * To decode such an image, {@link MediaCodec} decoder for\n     * {@link #MIMETYPE_VIDEO_HEVC} shall be used. The client needs to form\n     * the correct {@link #MediaFormat} based on additional information in\n     * the track format, and send it to {@link MediaCodec#configure}.\n     *\n     * The track's MediaFormat will come with {@link #KEY_WIDTH} and\n     * {@link #KEY_HEIGHT} keys, which describes the width and height\n     * of the image. If the image doesn't contain grid (i.e. none of\n     * {@link #KEY_TILE_WIDTH}, {@link #KEY_TILE_HEIGHT},\n     * {@link #KEY_GRID_ROWS}, {@link #KEY_GRID_COLUMNS} are present}), the\n     * track will contain a single sample of coded data for the entire image,\n     * and the image width and height should be used to set up the decoder.\n     *\n     * If the image does come with grid, each sample from the track will\n     * contain one tile in the grid, of which the size is described by\n     * {@link #KEY_TILE_WIDTH} and {@link #KEY_TILE_HEIGHT}. This size\n     * (instead of {@link #KEY_WIDTH} and {@link #KEY_HEIGHT}) should be\n     * used to set up the decoder. The track contains {@link #KEY_GRID_ROWS}\n     * by {@link #KEY_GRID_COLUMNS} samples in row-major, top-row first,\n     * left-to-right order. The output image should be reconstructed by\n     * first tiling the decoding results of the tiles in the correct order,\n     * then trimming (before rotation is applied) on the bottom and right\n     * side, if the tiled area is larger than the image width and height.\n     ",
    "links" : [ "MediaCodec", "#MIMETYPE_VIDEO_HEVC", "#MediaFormat", "MediaCodec#configure", "#KEY_WIDTH", "#KEY_HEIGHT", "#KEY_TILE_WIDTH", "#KEY_TILE_HEIGHT", "#KEY_GRID_ROWS", "#KEY_GRID_COLUMNS", "#KEY_TILE_WIDTH", "#KEY_TILE_HEIGHT", "#KEY_WIDTH", "#KEY_HEIGHT", "#KEY_GRID_ROWS", "#KEY_GRID_COLUMNS" ]
  }, {
    "name" : "MIMETYPE_TEXT_VTT",
    "type" : "String",
    "comment" : "\n     * MIME type for WebVTT subtitle data.\n     ",
    "links" : [ ]
  }, {
    "name" : "MIMETYPE_TEXT_SUBRIP",
    "type" : "String",
    "comment" : "\n     * MIME type for SubRip (SRT) container.\n     ",
    "links" : [ ]
  }, {
    "name" : "MIMETYPE_TEXT_CEA_608",
    "type" : "String",
    "comment" : "\n     * MIME type for CEA-608 closed caption data.\n     ",
    "links" : [ ]
  }, {
    "name" : "MIMETYPE_TEXT_CEA_708",
    "type" : "String",
    "comment" : "\n     * MIME type for CEA-708 closed caption data.\n     ",
    "links" : [ ]
  }, {
    "name" : "mMap",
    "type" : "Map<String, Object>",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "KEY_MIME",
    "type" : "String",
    "comment" : "\n     * A key describing the mime type of the MediaFormat.\n     * The associated value is a string.\n     ",
    "links" : [ ]
  }, {
    "name" : "KEY_CODECS_STRING",
    "type" : "String",
    "comment" : "\n     * A key describing the codecs string of the MediaFormat. See RFC 6381 section 3.2 for the\n     * syntax of the value. The value does not hold {@link MediaCodec}-exposed codec names.\n     * The associated value is a string.\n     *\n     * @see MediaParser.TrackData#mediaFormat\n     ",
    "links" : [ "MediaCodec" ]
  }, {
    "name" : "KEY_LOW_LATENCY",
    "type" : "String",
    "comment" : "\n     * An optional key describing the low latency decoding mode. This is an optional parameter\n     * that applies only to decoders. If enabled, the decoder doesn't hold input and output\n     * data more than required by the codec standards.\n     * The associated value is an integer (0 or 1): 1 when low-latency decoding is enabled,\n     * 0 otherwise. The default value is 0.\n     ",
    "links" : [ ]
  }, {
    "name" : "KEY_LANGUAGE",
    "type" : "String",
    "comment" : "\n     * A key describing the language of the content, using either ISO 639-1\n     * or 639-2/T codes.  The associated value is a string.\n     ",
    "links" : [ ]
  }, {
    "name" : "KEY_CAPTION_SERVICE_NUMBER",
    "type" : "String",
    "comment" : "\n     * A key describing the closed caption service number. For CEA-608 caption tracks, holds the\n     * channel number. For CEA-708, holds the service number.\n     * The associated value is an int.\n     ",
    "links" : [ ]
  }, {
    "name" : "KEY_SAMPLE_RATE",
    "type" : "String",
    "comment" : "\n     * A key describing the sample rate of an audio format.\n     * The associated value is an integer\n     ",
    "links" : [ ]
  }, {
    "name" : "KEY_CHANNEL_COUNT",
    "type" : "String",
    "comment" : "\n     * A key describing the number of channels in an audio format.\n     * The associated value is an integer\n     ",
    "links" : [ ]
  }, {
    "name" : "KEY_WIDTH",
    "type" : "String",
    "comment" : "\n     * A key describing the width of the content in a video format.\n     * The associated value is an integer\n     ",
    "links" : [ ]
  }, {
    "name" : "KEY_HEIGHT",
    "type" : "String",
    "comment" : "\n     * A key describing the height of the content in a video format.\n     * The associated value is an integer\n     ",
    "links" : [ ]
  }, {
    "name" : "KEY_MAX_WIDTH",
    "type" : "String",
    "comment" : "\n     * A key describing the maximum expected width of the content in a video\n     * decoder format, in case there are resolution changes in the video content.\n     * The associated value is an integer\n     ",
    "links" : [ ]
  }, {
    "name" : "KEY_MAX_HEIGHT",
    "type" : "String",
    "comment" : "\n     * A key describing the maximum expected height of the content in a video\n     * decoder format, in case there are resolution changes in the video content.\n     * The associated value is an integer\n     ",
    "links" : [ ]
  }, {
    "name" : "KEY_MAX_INPUT_SIZE",
    "type" : "String",
    "comment" : " A key describing the maximum size in bytes of a buffer of data\n     * described by this MediaFormat.\n     * The associated value is an integer\n     ",
    "links" : [ ]
  }, {
    "name" : "KEY_PIXEL_ASPECT_RATIO_WIDTH",
    "type" : "String",
    "comment" : "\n     * A key describing the pixel aspect ratio width.\n     * The associated value is an integer\n     ",
    "links" : [ ]
  }, {
    "name" : "KEY_PIXEL_ASPECT_RATIO_HEIGHT",
    "type" : "String",
    "comment" : "\n     * A key describing the pixel aspect ratio height.\n     * The associated value is an integer\n     ",
    "links" : [ ]
  }, {
    "name" : "KEY_BIT_RATE",
    "type" : "String",
    "comment" : "\n     * A key describing the average bitrate in bits/sec.\n     * The associated value is an integer\n     ",
    "links" : [ ]
  }, {
    "name" : "KEY_HARDWARE_AV_SYNC_ID",
    "type" : "String",
    "comment" : "\n     * A key describing the hardware AV sync id.\n     * The associated value is an integer\n     *\n     * See android.media.tv.tuner.Tuner#getAvSyncHwId.\n     ",
    "links" : [ ]
  }, {
    "name" : "KEY_MAX_BIT_RATE",
    "type" : "String",
    "comment" : "\n     * A key describing the max bitrate in bits/sec.\n     * This is usually over a one-second sliding window (e.g. over any window of one second).\n     * The associated value is an integer\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "KEY_COLOR_FORMAT",
    "type" : "String",
    "comment" : "\n     * A key describing the color format of the content in a video format.\n     * Constants are declared in {@link android.media.MediaCodecInfo.CodecCapabilities}.\n     ",
    "links" : [ "android.media.MediaCodecInfo.CodecCapabilities" ]
  }, {
    "name" : "KEY_FRAME_RATE",
    "type" : "String",
    "comment" : "\n     * A key describing the frame rate of a video format in frames/sec.\n     * The associated value is normally an integer when the value is used by the platform,\n     * but video codecs also accept float configuration values.\n     * Specifically, {@link MediaExtractor#getTrackFormat MediaExtractor} provides an integer\n     * value corresponding to the frame rate information of the track if specified and non-zero.\n     * Otherwise, this key is not present. {@link MediaCodec#configure MediaCodec} accepts both\n     * float and integer values. This represents the desired operating frame rate if the\n     * {@link #KEY_OPERATING_RATE} is not present and {@link #KEY_PRIORITY} is {@code 0}\n     * (realtime). For video encoders this value corresponds to the intended frame rate,\n     * although encoders are expected\n     * to support variable frame rate based on {@link MediaCodec.BufferInfo#presentationTimeUs\n     * buffer timestamp}. This key is not used in the {@code MediaCodec}\n     * {@link MediaCodec#getInputFormat input}/{@link MediaCodec#getOutputFormat output} formats,\n     * nor by {@link MediaMuxer#addTrack MediaMuxer}.\n     ",
    "links" : [ "MediaExtractor#getTrackFormat", "MediaCodec#configure", "#KEY_OPERATING_RATE", "#KEY_PRIORITY", "MediaCodec.BufferInfo#presentationTimeUs", "MediaCodec#getInputFormat", "MediaCodec#getOutputFormat", "MediaMuxer#addTrack" ]
  }, {
    "name" : "KEY_TILE_WIDTH",
    "type" : "String",
    "comment" : "\n     * A key describing the width (in pixels) of each tile of the content in a\n     * {@link #MIMETYPE_IMAGE_ANDROID_HEIC} track. The associated value is an integer.\n     *\n     * Refer to {@link #MIMETYPE_IMAGE_ANDROID_HEIC} on decoding instructions of such tracks.\n     *\n     * @see #KEY_TILE_HEIGHT\n     * @see #KEY_GRID_ROWS\n     * @see #KEY_GRID_COLUMNS\n     ",
    "links" : [ "#MIMETYPE_IMAGE_ANDROID_HEIC", "#MIMETYPE_IMAGE_ANDROID_HEIC" ]
  }, {
    "name" : "KEY_TILE_HEIGHT",
    "type" : "String",
    "comment" : "\n     * A key describing the height (in pixels) of each tile of the content in a\n     * {@link #MIMETYPE_IMAGE_ANDROID_HEIC} track. The associated value is an integer.\n     *\n     * Refer to {@link #MIMETYPE_IMAGE_ANDROID_HEIC} on decoding instructions of such tracks.\n     *\n     * @see #KEY_TILE_WIDTH\n     * @see #KEY_GRID_ROWS\n     * @see #KEY_GRID_COLUMNS\n     ",
    "links" : [ "#MIMETYPE_IMAGE_ANDROID_HEIC", "#MIMETYPE_IMAGE_ANDROID_HEIC" ]
  }, {
    "name" : "KEY_GRID_ROWS",
    "type" : "String",
    "comment" : "\n     * A key describing the number of grid rows in the content in a\n     * {@link #MIMETYPE_IMAGE_ANDROID_HEIC} track. The associated value is an integer.\n     *\n     * Refer to {@link #MIMETYPE_IMAGE_ANDROID_HEIC} on decoding instructions of such tracks.\n     *\n     * @see #KEY_TILE_WIDTH\n     * @see #KEY_TILE_HEIGHT\n     * @see #KEY_GRID_COLUMNS\n     ",
    "links" : [ "#MIMETYPE_IMAGE_ANDROID_HEIC", "#MIMETYPE_IMAGE_ANDROID_HEIC" ]
  }, {
    "name" : "KEY_GRID_COLUMNS",
    "type" : "String",
    "comment" : "\n     * A key describing the number of grid columns in the content in a\n     * {@link #MIMETYPE_IMAGE_ANDROID_HEIC} track. The associated value is an integer.\n     *\n     * Refer to {@link #MIMETYPE_IMAGE_ANDROID_HEIC} on decoding instructions of such tracks.\n     *\n     * @see #KEY_TILE_WIDTH\n     * @see #KEY_TILE_HEIGHT\n     * @see #KEY_GRID_ROWS\n     ",
    "links" : [ "#MIMETYPE_IMAGE_ANDROID_HEIC", "#MIMETYPE_IMAGE_ANDROID_HEIC" ]
  }, {
    "name" : "KEY_PCM_ENCODING",
    "type" : "String",
    "comment" : "\n     * A key describing the raw audio sample encoding/format.\n     *\n     * <p>The associated value is an integer, using one of the\n     * {@link AudioFormat}.ENCODING_PCM_ values.</p>\n     *\n     * <p>This is an optional key for audio decoders and encoders specifying the\n     * desired raw audio sample format during {@link MediaCodec#configure\n     * MediaCodec.configure(&hellip;)} call. Use {@link MediaCodec#getInputFormat\n     * MediaCodec.getInput}/{@link MediaCodec#getOutputFormat OutputFormat(&hellip;)}\n     * to confirm the actual format. For the PCM decoder this key specifies both\n     * input and output sample encodings.</p>\n     *\n     * <p>This key is also used by {@link MediaExtractor} to specify the sample\n     * format of audio data, if it is specified.</p>\n     *\n     * <p>If this key is missing, the raw audio sample format is signed 16-bit short.</p>\n     ",
    "links" : [ "AudioFormat", "MediaCodec#configure", "MediaCodec#getInputFormat", "MediaCodec#getOutputFormat", "MediaExtractor" ]
  }, {
    "name" : "KEY_CAPTURE_RATE",
    "type" : "String",
    "comment" : "\n     * A key describing the capture rate of a video format in frames/sec.\n     * <p>\n     * When capture rate is different than the frame rate, it means that the\n     * video is acquired at a different rate than the playback, which produces\n     * slow motion or timelapse effect during playback. Application can use the\n     * value of this key to tell the relative speed ratio between capture and\n     * playback rates when the video was recorded.\n     * </p>\n     * <p>\n     * The associated value is an integer or a float.\n     * </p>\n     ",
    "links" : [ ]
  }, {
    "name" : "KEY_I_FRAME_INTERVAL",
    "type" : "String",
    "comment" : "\n     * A key describing the frequency of key frames expressed in seconds between key frames.\n     * <p>\n     * This key is used by video encoders.\n     * A negative value means no key frames are requested after the first frame.\n     * A zero value means a stream containing all key frames is requested.\n     * <p class=note>\n     * Most video encoders will convert this value of the number of non-key-frames between\n     * key-frames, using the {@linkplain #KEY_FRAME_RATE frame rate} information; therefore,\n     * if the actual frame rate differs (e.g. input frames are dropped or the frame rate\n     * changes), the <strong>time interval</strong> between key frames will not be the\n     * configured value.\n     * <p>\n     * The associated value is an integer (or float since\n     * {@link android.os.Build.VERSION_CODES#N_MR1}).\n     ",
    "links" : [ "android.os.Build.VERSION_CODES#N_MR1" ]
  }, {
    "name" : "KEY_INTRA_REFRESH_PERIOD",
    "type" : "String",
    "comment" : "\n    * An optional key describing the period of intra refresh in frames. This is an\n    * optional parameter that applies only to video encoders. If encoder supports it\n    * ({@link MediaCodecInfo.CodecCapabilities#FEATURE_IntraRefresh}), the whole\n    * frame is completely refreshed after the specified period. Also for each frame,\n    * a fix subset of macroblocks must be intra coded which leads to more constant bitrate\n    * than inserting a key frame. This key is recommended for video streaming applications\n    * as it provides low-delay and good error-resilience. This key is ignored if the\n    * video encoder does not support the intra refresh feature. Use the output format to\n    * verify that this feature was enabled.\n    * The associated value is an integer.\n    ",
    "links" : [ "MediaCodecInfo.CodecCapabilities#FEATURE_IntraRefresh" ]
  }, {
    "name" : "KEY_PREPEND_HEADER_TO_SYNC_FRAMES",
    "type" : "String",
    "comment" : "\n     * An optional key describing whether encoders prepend headers to sync frames (e.g.\n     * SPS and PPS to IDR frames for H.264). This is an optional parameter that applies only\n     * to video encoders. A video encoder may not support this feature; the component will fail\n     * to configure in that case. For other components, this key is ignored.\n     *\n     * The value is an integer, with 1 indicating to prepend headers to every sync frames,\n     * or 0 otherwise. The default value is 0.\n     ",
    "links" : [ ]
  }, {
    "name" : "KEY_TEMPORAL_LAYERING",
    "type" : "String",
    "comment" : "\n     * A key describing the temporal layering schema.  This is an optional parameter\n     * that applies only to video encoders.  Use {@link MediaCodec#getOutputFormat}\n     * after {@link MediaCodec#configure configure} to query if the encoder supports\n     * the desired schema. Supported values are {@code webrtc.vp8.N-layer},\n     * {@code android.generic.N}, {@code android.generic.N+M} and {@code none}, where\n     * {@code N} denotes the total number of non-bidirectional layers (which must be at least 1)\n     * and {@code M} denotes the total number of bidirectional layers (which must be non-negative).\n     * <p class=note>{@code android.generic.*} schemas have been added in {@link\n     * android.os.Build.VERSION_CODES#N_MR1}.\n     * <p>\n     * The encoder may support fewer temporal layers, in which case the output format\n     * will contain the configured schema. If the encoder does not support temporal\n     * layering, the output format will not have an entry with this key.\n     * The associated value is a string.\n     ",
    "links" : [ "MediaCodec#getOutputFormat", "MediaCodec#configure" ]
  }, {
    "name" : "KEY_STRIDE",
    "type" : "String",
    "comment" : "\n     * A key describing the stride of the video bytebuffer layout.\n     * Stride (or row increment) is the difference between the index of a pixel\n     * and that of the pixel directly underneath. For YUV 420 formats, the\n     * stride corresponds to the Y plane; the stride of the U and V planes can\n     * be calculated based on the color format, though it is generally undefined\n     * and depends on the device and release.\n     * The associated value is an integer, representing number of bytes.\n     ",
    "links" : [ ]
  }, {
    "name" : "KEY_SLICE_HEIGHT",
    "type" : "String",
    "comment" : "\n     * A key describing the plane height of a multi-planar (YUV) video bytebuffer layout.\n     * Slice height (or plane height/vertical stride) is the number of rows that must be skipped\n     * to get from the top of the Y plane to the top of the U plane in the bytebuffer. In essence\n     * the offset of the U plane is sliceHeight * stride. The height of the U/V planes\n     * can be calculated based on the color format, though it is generally undefined\n     * and depends on the device and release.\n     * The associated value is an integer, representing number of rows.\n     ",
    "links" : [ ]
  }, {
    "name" : "KEY_REPEAT_PREVIOUS_FRAME_AFTER",
    "type" : "String",
    "comment" : "\n     * Applies only when configuring a video encoder in \"surface-input\" mode.\n     * The associated value is a long and gives the time in microseconds\n     * after which the frame previously submitted to the encoder will be\n     * repeated (once) if no new frame became available since.\n     ",
    "links" : [ ]
  }, {
    "name" : "KEY_MAX_FPS_TO_ENCODER",
    "type" : "String",
    "comment" : "\n     * Instruct the video encoder in \"surface-input\" mode to drop excessive\n     * frames from the source, so that the input frame rate to the encoder\n     * does not exceed the specified fps.\n     *\n     * The associated value is a float, representing the max frame rate to\n     * feed the encoder at.\n     *\n     ",
    "links" : [ ]
  }, {
    "name" : "KEY_MAX_PTS_GAP_TO_ENCODER",
    "type" : "String",
    "comment" : "\n     * Instruct the video encoder in \"surface-input\" mode to limit the gap of\n     * timestamp between any two adjacent frames fed to the encoder to the\n     * specified amount (in micro-second).\n     *\n     * The associated value is a long int. When positive, it represents the max\n     * timestamp gap between two adjacent frames fed to the encoder. When negative,\n     * the absolute value represents a fixed timestamp gap between any two adjacent\n     * frames fed to the encoder. Note that this will also apply even when the\n     * original timestamp goes backward in time. Under normal conditions, such frames\n     * would be dropped and not sent to the encoder.\n     *\n     * The output timestamp will be restored to the original timestamp and will\n     * not be affected.\n     *\n     * This is used in some special scenarios where input frames arrive sparingly\n     * but it's undesirable to allocate more bits to any single frame, or when it's\n     * important to ensure all frames are captured (rather than captured in the\n     * correct order).\n     *\n     ",
    "links" : [ ]
  }, {
    "name" : "KEY_CREATE_INPUT_SURFACE_SUSPENDED",
    "type" : "String",
    "comment" : "\n     * If specified when configuring a video encoder that's in \"surface-input\"\n     * mode, it will instruct the encoder to put the surface source in suspended\n     * state when it's connected. No video frames will be accepted until a resume\n     * operation (see {@link MediaCodec#PARAMETER_KEY_SUSPEND}), optionally with\n     * timestamp specified via {@link MediaCodec#PARAMETER_KEY_SUSPEND_TIME}, is\n     * received.\n     *\n     * The value is an integer, with 1 indicating to create with the surface\n     * source suspended, or 0 otherwise. The default value is 0.\n     *\n     * If this key is not set or set to 0, the surface source will accept buffers\n     * as soon as it's connected to the encoder (although they may not be encoded\n     * immediately). This key can be used when the client wants to prepare the\n     * encoder session in advance, but do not want to accept buffers immediately.\n     ",
    "links" : [ "MediaCodec#PARAMETER_KEY_SUSPEND", "MediaCodec#PARAMETER_KEY_SUSPEND_TIME" ]
  }, {
    "name" : "KEY_PUSH_BLANK_BUFFERS_ON_STOP",
    "type" : "String",
    "comment" : "\n     * If specified when configuring a video decoder rendering to a surface,\n     * causes the decoder to output \"blank\", i.e. black frames to the surface\n     * when stopped to clear out any previously displayed contents.\n     * The associated value is an integer of value 1.\n     ",
    "links" : [ ]
  }, {
    "name" : "KEY_DURATION",
    "type" : "String",
    "comment" : "\n     * A key describing the duration (in microseconds) of the content.\n     * The associated value is a long.\n     ",
    "links" : [ ]
  }, {
    "name" : "KEY_IS_ADTS",
    "type" : "String",
    "comment" : "\n     * A key mapping to a value of 1 if the content is AAC audio and\n     * audio frames are prefixed with an ADTS header.\n     * The associated value is an integer (0 or 1).\n     * This key is only supported when _decoding_ content, it cannot\n     * be used to configure an encoder to emit ADTS output.\n     ",
    "links" : [ ]
  }, {
    "name" : "KEY_CHANNEL_MASK",
    "type" : "String",
    "comment" : "\n     * A key describing the channel composition of audio content. This mask\n     * is composed of bits drawn from channel mask definitions in {@link android.media.AudioFormat}.\n     * The associated value is an integer.\n     ",
    "links" : [ "android.media.AudioFormat" ]
  }, {
    "name" : "KEY_ENCODER_DELAY",
    "type" : "String",
    "comment" : "\n     * A key describing the number of frames to trim from the start of the decoded audio stream.\n     * The associated value is an integer.\n     ",
    "links" : [ ]
  }, {
    "name" : "KEY_ENCODER_PADDING",
    "type" : "String",
    "comment" : "\n     * A key describing the number of frames to trim from the end of the decoded audio stream.\n     * The associated value is an integer.\n     ",
    "links" : [ ]
  }, {
    "name" : "KEY_AAC_PROFILE",
    "type" : "String",
    "comment" : "\n     * A key describing the AAC profile to be used (AAC audio formats only).\n     * Constants are declared in {@link android.media.MediaCodecInfo.CodecProfileLevel}.\n     ",
    "links" : [ "android.media.MediaCodecInfo.CodecProfileLevel" ]
  }, {
    "name" : "KEY_AAC_SBR_MODE",
    "type" : "String",
    "comment" : "\n     * A key describing the AAC SBR mode to be used (AAC audio formats only).\n     * The associated value is an integer and can be set to following values:\n     * <ul>\n     * <li>0 - no SBR should be applied</li>\n     * <li>1 - single rate SBR</li>\n     * <li>2 - double rate SBR</li>\n     * </ul>\n     * Note: If this key is not defined the default SRB mode for the desired AAC profile will\n     * be used.\n     * <p>This key is only used during encoding.\n     ",
    "links" : [ ]
  }, {
    "name" : "KEY_AAC_MAX_OUTPUT_CHANNEL_COUNT",
    "type" : "String",
    "comment" : "\n     * A key describing the maximum number of channels that can be output by the AAC decoder.\n     * By default, the decoder will output the same number of channels as present in the encoded\n     * stream, if supported. Set this value to limit the number of output channels, and use\n     * the downmix information in the stream, if available.\n     * <p>Values larger than the number of channels in the content to decode are ignored.\n     * <p>This key is only used during decoding.\n     ",
    "links" : [ ]
  }, {
    "name" : "KEY_AAC_DRC_TARGET_REFERENCE_LEVEL",
    "type" : "String",
    "comment" : "\n     * A key describing the Target Reference Level (Target Loudness).\n     * <p>For normalizing loudness across program items, a gain is applied to the audio output so\n     * that the output loudness matches the Target Reference Level. The gain is derived as the\n     * difference between the Target Reference Level and the Program Reference Level (Program\n     * Loudness). The latter can be given in the bitstream and indicates the actual loudness value\n     * of the program item.</p>\n     * <p>The Target Reference Level controls loudness normalization for both MPEG-4 DRC and\n     * MPEG-D DRC.\n     * <p>The value is given as an integer value between\n     * 40 and 127, and is calculated as -4 * Target Reference Level in LKFS.\n     * Therefore, it represents the range of -10 to -31.75 LKFS.\n     * <p>For MPEG-4 DRC, a value of -1 switches off loudness normalization and DRC processing.</p>\n     * <p>For MPEG-D DRC, a value of -1 switches off loudness normalization only. For DRC processing\n     * options of MPEG-D DRC, see {@link #KEY_AAC_DRC_EFFECT_TYPE}</p>\n     * <p>The default value on mobile devices is 64 (-16 LKFS).\n     * <p>This key is only used during decoding.\n     ",
    "links" : [ "#KEY_AAC_DRC_EFFECT_TYPE" ]
  }, {
    "name" : "KEY_AAC_DRC_EFFECT_TYPE",
    "type" : "String",
    "comment" : "\n     * A key describing for selecting the DRC effect type for MPEG-D DRC.\n     * The supported values are defined in ISO/IEC 23003-4:2015 and are described as follows:\n     * <table>\n     * <tr><th>Value</th><th>Effect</th></tr>\n     * <tr><th>-1</th><th>Off</th></tr>\n     * <tr><th>0</th><th>None</th></tr>\n     * <tr><th>1</th><th>Late night</th></tr>\n     * <tr><th>2</th><th>Noisy environment</th></tr>\n     * <tr><th>3</th><th>Limited playback range</th></tr>\n     * <tr><th>4</th><th>Low playback level</th></tr>\n     * <tr><th>5</th><th>Dialog enhancement</th></tr>\n     * <tr><th>6</th><th>General compression</th></tr>\n     * </table>\n     * <p>The value -1 (Off) disables DRC processing, while loudness normalization may still be\n     * active and dependent on {@link #KEY_AAC_DRC_TARGET_REFERENCE_LEVEL}.<br>\n     * The value 0 (None) automatically enables DRC processing if necessary to prevent signal\n     * clipping<br>\n     * The value 6 (General compression) can be used for enabling MPEG-D DRC without particular\n     * DRC effect type request.<br>\n     * The default DRC effect type is 3 (\"Limited playback range\") on mobile devices.\n     * <p>This key is only used during decoding.\n     ",
    "links" : [ "#KEY_AAC_DRC_TARGET_REFERENCE_LEVEL" ]
  }, {
    "name" : "KEY_AAC_ENCODED_TARGET_LEVEL",
    "type" : "String",
    "comment" : "\n     * A key describing the target reference level that was assumed at the encoder for\n     * calculation of attenuation gains for clipping prevention.\n     * <p>If it is known, this information can be provided as an integer value between\n     * 0 and 127, which is calculated as -4 * Encoded Target Level in LKFS.\n     * If the Encoded Target Level is unknown, the value can be set to -1.\n     * <p>The default value is -1 (unknown).\n     * <p>The value is ignored when heavy compression (see {@link #KEY_AAC_DRC_HEAVY_COMPRESSION})\n     * or MPEG-D DRC is used.\n     * <p>This key is only used during decoding.\n     ",
    "links" : [ "#KEY_AAC_DRC_HEAVY_COMPRESSION" ]
  }, {
    "name" : "KEY_AAC_DRC_BOOST_FACTOR",
    "type" : "String",
    "comment" : "\n     * A key describing the boost factor allowing to adapt the dynamics of the output to the\n     * actual listening requirements. This relies on DRC gain sequences that can be transmitted in\n     * the encoded bitstream to be able to reduce the dynamics of the output signal upon request.\n     * This factor enables the user to select how much of the gains are applied.\n     * <p>Positive gains (boost) and negative gains (attenuation, see\n     * {@link #KEY_AAC_DRC_ATTENUATION_FACTOR}) can be controlled separately for a better match\n     * to different use-cases.\n     * <p>Typically, attenuation gains are sent for loud signal segments, and boost gains are sent\n     * for soft signal segments. If the output is listened to in a noisy environment, for example,\n     * the boost factor is used to enable the positive gains, i.e. to amplify soft signal segments\n     * beyond the noise floor. But for listening late at night, the attenuation\n     * factor is used to enable the negative gains, to prevent loud signal from surprising\n     * the listener. In applications which generally need a low dynamic range, both the boost factor\n     * and the attenuation factor are used in order to enable all DRC gains.\n     * <p>In order to prevent clipping, it is also recommended to apply the attenuation gains\n     * in case of a downmix and/or loudness normalization to high target reference levels.\n     * <p>Both the boost and the attenuation factor parameters are given as integer values\n     * between 0 and 127, representing the range of the factor of 0 (i.e. don't apply)\n     * to 1 (i.e. fully apply boost/attenuation gains respectively).\n     * <p>The default value is 127 (fully apply boost DRC gains).\n     * <p>This key is only used during decoding.\n     ",
    "links" : [ "#KEY_AAC_DRC_ATTENUATION_FACTOR" ]
  }, {
    "name" : "KEY_AAC_DRC_ATTENUATION_FACTOR",
    "type" : "String",
    "comment" : "\n     * A key describing the attenuation factor allowing to adapt the dynamics of the output to the\n     * actual listening requirements.\n     * See {@link #KEY_AAC_DRC_BOOST_FACTOR} for a description of the role of this attenuation\n     * factor and the value range.\n     * <p>The default value is 127 (fully apply attenuation DRC gains).\n     * <p>This key is only used during decoding.\n     ",
    "links" : [ "#KEY_AAC_DRC_BOOST_FACTOR" ]
  }, {
    "name" : "KEY_AAC_DRC_HEAVY_COMPRESSION",
    "type" : "String",
    "comment" : "\n     * A key describing the selection of the heavy compression profile for MPEG-4 DRC.\n     * <p>Two separate DRC gain sequences can be transmitted in one bitstream: light compression\n     * and heavy compression. When selecting the application of the heavy compression, one of\n     * the sequences is selected:\n     * <ul>\n     * <li>0 enables light compression,</li>\n     * <li>1 enables heavy compression instead.\n     * </ul>\n     * Note that heavy compression doesn't offer the features of scaling of DRC gains\n     * (see {@link #KEY_AAC_DRC_BOOST_FACTOR} and {@link #KEY_AAC_DRC_ATTENUATION_FACTOR} for the\n     * boost and attenuation factors), and frequency-selective (multiband) DRC.\n     * Light compression usually contains clipping prevention for stereo downmixing while heavy\n     * compression, if additionally provided in the bitstream, is usually stronger, and contains\n     * clipping prevention for stereo and mono downmixing.\n     * <p>The default is 1 (heavy compression).\n     * <p>This key is only used during decoding.\n     ",
    "links" : [ "#KEY_AAC_DRC_BOOST_FACTOR", "#KEY_AAC_DRC_ATTENUATION_FACTOR" ]
  }, {
    "name" : "KEY_AAC_DRC_OUTPUT_LOUDNESS",
    "type" : "String",
    "comment" : "\n     * A key to retrieve the output loudness of a decoded bitstream.\n     * <p>If loudness normalization is active, the value corresponds to the Target Reference Level\n     * (see {@link #KEY_AAC_DRC_TARGET_REFERENCE_LEVEL}).<br>\n     * If loudness normalization is not active, the value corresponds to the loudness metadata\n     * given in the bitstream.\n     * <p>The value is retrieved with getInteger() and is given as an integer value between 0 and\n     * 231. It is calculated as -4 * Output Loudness in LKFS. Therefore, it represents the range of\n     * 0 to -57.75 LKFS.\n     * <p>A value of -1 indicates that no loudness metadata is present in the bitstream.\n     * <p>Loudness metadata can originate from MPEG-4 DRC or MPEG-D DRC.\n     * <p>This key is only used during decoding.\n     ",
    "links" : [ "#KEY_AAC_DRC_TARGET_REFERENCE_LEVEL" ]
  }, {
    "name" : "KEY_AAC_DRC_ALBUM_MODE",
    "type" : "String",
    "comment" : "\n     * A key describing the album mode for MPEG-D DRC as defined in ISO/IEC 23003-4.\n     * <p>The associated value is an integer and can be set to following values:\n     * <table>\n     * <tr><th>Value</th><th>Album Mode</th></tr>\n     * <tr><th>0</th><th>disabled</th></tr>\n     * <tr><th>1</th><th>enabled</th></tr>\n     * </table>\n     * <p>Disabled album mode leads to application of gain sequences for fading in and out, if\n     * provided in the bitstream. Enabled album mode makes use of dedicated album loudness\n     * information, if provided in the bitstream.\n     * <p>The default value is 0 (album mode disabled).\n     * <p>This key is only used during decoding.\n     ",
    "links" : [ ]
  }, {
    "name" : "KEY_FLAC_COMPRESSION_LEVEL",
    "type" : "String",
    "comment" : "\n     * A key describing the FLAC compression level to be used (FLAC audio format only).\n     * The associated value is an integer ranging from 0 (fastest, least compression)\n     * to 8 (slowest, most compression).\n     ",
    "links" : [ ]
  }, {
    "name" : "KEY_COMPLEXITY",
    "type" : "String",
    "comment" : "\n     * A key describing the encoding complexity.\n     * The associated value is an integer.  These values are device and codec specific,\n     * but lower values generally result in faster and/or less power-hungry encoding.\n     *\n     * @see MediaCodecInfo.EncoderCapabilities#getComplexityRange()\n     ",
    "links" : [ ]
  }, {
    "name" : "KEY_QUALITY",
    "type" : "String",
    "comment" : "\n     * A key describing the desired encoding quality.\n     * The associated value is an integer.  This key is only supported for encoders\n     * that are configured in constant-quality mode.  These values are device and\n     * codec specific, but lower values generally result in more efficient\n     * (smaller-sized) encoding.\n     *\n     * @see MediaCodecInfo.EncoderCapabilities#getQualityRange()\n     ",
    "links" : [ ]
  }, {
    "name" : "KEY_PRIORITY",
    "type" : "String",
    "comment" : "\n     * A key describing the desired codec priority.\n     * <p>\n     * The associated value is an integer. Higher value means lower priority.\n     * <p>\n     * Currently, only two levels are supported:<br>\n     * 0: realtime priority - meaning that the codec shall support the given\n     *    performance configuration (e.g. framerate) at realtime. This should\n     *    only be used by media playback, capture, and possibly by realtime\n     *    communication scenarios if best effort performance is not suitable.<br>\n     * 1: non-realtime priority (best effort).\n     * <p>\n     * This is a hint used at codec configuration and resource planning - to understand\n     * the realtime requirements of the application; however, due to the nature of\n     * media components, performance is not guaranteed.\n     *\n     ",
    "links" : [ ]
  }, {
    "name" : "KEY_OPERATING_RATE",
    "type" : "String",
    "comment" : "\n     * A key describing the desired operating frame rate for video or sample rate for audio\n     * that the codec will need to operate at.\n     * <p>\n     * The associated value is an integer or a float representing frames-per-second or\n     * samples-per-second\n     * <p>\n     * This is used for cases like high-speed/slow-motion video capture, where the video encoder\n     * format contains the target playback rate (e.g. 30fps), but the component must be able to\n     * handle the high operating capture rate (e.g. 240fps).\n     * <p>\n     * This rate will be used by codec for resource planning and setting the operating points.\n     *\n     ",
    "links" : [ ]
  }, {
    "name" : "KEY_PROFILE",
    "type" : "String",
    "comment" : "\n     * A key describing the desired profile to be used by an encoder.\n     * The associated value is an integer.\n     * Constants are declared in {@link MediaCodecInfo.CodecProfileLevel}.\n     * This key is used as a hint, and is only supported for codecs\n     * that specify a profile. Note: Codecs are free to use all the available\n     * coding tools at the specified profile.\n     *\n     * @see MediaCodecInfo.CodecCapabilities#profileLevels\n     ",
    "links" : [ "MediaCodecInfo.CodecProfileLevel" ]
  }, {
    "name" : "KEY_LEVEL",
    "type" : "String",
    "comment" : "\n     * A key describing the desired profile to be used by an encoder.\n     * The associated value is an integer.\n     * Constants are declared in {@link MediaCodecInfo.CodecProfileLevel}.\n     * This key is used as a further hint when specifying a desired profile,\n     * and is only supported for codecs that specify a level.\n     * <p>\n     * This key is ignored if the {@link #KEY_PROFILE profile} is not specified.\n     *\n     * @see MediaCodecInfo.CodecCapabilities#profileLevels\n     ",
    "links" : [ "MediaCodecInfo.CodecProfileLevel", "#KEY_PROFILE" ]
  }, {
    "name" : "KEY_LATENCY",
    "type" : "String",
    "comment" : "\n    * An optional key describing the desired encoder latency in frames. This is an optional\n    * parameter that applies only to video encoders. If encoder supports it, it should ouput\n    * at least one output frame after being queued the specified number of frames. This key\n    * is ignored if the video encoder does not support the latency feature. Use the output\n    * format to verify that this feature was enabled and the actual value used by the encoder.\n    * <p>\n    * If the key is not specified, the default latency will be implenmentation specific.\n    * The associated value is an integer.\n    ",
    "links" : [ ]
  }, {
    "name" : "KEY_OUTPUT_REORDER_DEPTH",
    "type" : "String",
    "comment" : "\n     * An optional key describing the maximum number of non-display-order coded frames.\n     * This is an optional parameter that applies only to video encoders. Application should\n     * check the value for this key in the output format to see if codec will produce\n     * non-display-order coded frames. If encoder supports it, the output frames' order will be\n     * different from the display order and each frame's display order could be retrived from\n     * {@link MediaCodec.BufferInfo#presentationTimeUs}. Before API level 27, application may\n     * receive non-display-order coded frames even though the application did not request it.\n     * Note: Application should not rearrange the frames to display order before feeding them\n     * to {@link MediaMuxer#writeSampleData}.\n     * <p>\n     * The default value is 0.\n     ",
    "links" : [ "MediaCodec.BufferInfo#presentationTimeUs", "MediaMuxer#writeSampleData" ]
  }, {
    "name" : "KEY_ROTATION",
    "type" : "String",
    "comment" : "\n     * A key describing the desired clockwise rotation on an output surface.\n     * This key is only used when the codec is configured using an output surface.\n     * The associated value is an integer, representing degrees. Supported values\n     * are 0, 90, 180 or 270. This is an optional field; if not specified, rotation\n     * defaults to 0.\n     *\n     * @see MediaCodecInfo.CodecCapabilities#profileLevels\n     ",
    "links" : [ ]
  }, {
    "name" : "KEY_BITRATE_MODE",
    "type" : "String",
    "comment" : "\n     * A key describing the desired bitrate mode to be used by an encoder.\n     * Constants are declared in {@link MediaCodecInfo.CodecCapabilities}.\n     *\n     * @see MediaCodecInfo.EncoderCapabilities#isBitrateModeSupported(int)\n     ",
    "links" : [ "MediaCodecInfo.CodecCapabilities" ]
  }, {
    "name" : "KEY_AUDIO_SESSION_ID",
    "type" : "String",
    "comment" : "\n     * A key describing the audio session ID of the AudioTrack associated\n     * to a tunneled video codec.\n     * The associated value is an integer.\n     *\n     * @see MediaCodecInfo.CodecCapabilities#FEATURE_TunneledPlayback\n     ",
    "links" : [ ]
  }, {
    "name" : "KEY_IS_AUTOSELECT",
    "type" : "String",
    "comment" : "\n     * A key for boolean AUTOSELECT behavior for the track. Tracks with AUTOSELECT=true\n     * are considered when automatically selecting a track without specific user\n     * choice, based on the current locale.\n     * This is currently only used for subtitle tracks, when the user selected\n     * 'Default' for the captioning locale.\n     * The associated value is an integer, where non-0 means TRUE.  This is an optional\n     * field; if not specified, AUTOSELECT defaults to TRUE.\n     ",
    "links" : [ ]
  }, {
    "name" : "KEY_IS_DEFAULT",
    "type" : "String",
    "comment" : "\n     * A key for boolean DEFAULT behavior for the track. The track with DEFAULT=true is\n     * selected in the absence of a specific user choice.\n     * This is currently used in two scenarios:\n     * 1) for subtitle tracks, when the user selected 'Default' for the captioning locale.\n     * 2) for a {@link #MIMETYPE_IMAGE_ANDROID_HEIC} track, indicating the image is the\n     * primary item in the file.\n\n     * The associated value is an integer, where non-0 means TRUE.  This is an optional\n     * field; if not specified, DEFAULT is considered to be FALSE.\n     ",
    "links" : [ "#MIMETYPE_IMAGE_ANDROID_HEIC" ]
  }, {
    "name" : "KEY_IS_FORCED_SUBTITLE",
    "type" : "String",
    "comment" : "\n     * A key for the FORCED field for subtitle tracks. True if it is a\n     * forced subtitle track.  Forced subtitle tracks are essential for the\n     * content and are shown even when the user turns off Captions.  They\n     * are used for example to translate foreign/alien dialogs or signs.\n     * The associated value is an integer, where non-0 means TRUE.  This is an\n     * optional field; if not specified, FORCED defaults to FALSE.\n     ",
    "links" : [ ]
  }, {
    "name" : "KEY_HAPTIC_CHANNEL_COUNT",
    "type" : "String",
    "comment" : "\n     * A key describing the number of haptic channels in an audio format.\n     * The associated value is an integer.\n     ",
    "links" : [ ]
  }, {
    "name" : "KEY_IS_TIMED_TEXT",
    "type" : "String",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "KEY_COLOR_STANDARD",
    "type" : "String",
    "comment" : "\n     * An optional key describing the color primaries, white point and\n     * luminance factors for video content.\n     *\n     * The associated value is an integer: 0 if unspecified, or one of the\n     * COLOR_STANDARD_ values.\n     ",
    "links" : [ ]
  }, {
    "name" : "COLOR_STANDARD_BT709",
    "type" : "int",
    "comment" : " BT.709 color chromacity coordinates with KR = 0.2126, KB = 0.0722. ",
    "links" : [ ]
  }, {
    "name" : "COLOR_STANDARD_BT601_PAL",
    "type" : "int",
    "comment" : " BT.601 625 color chromacity coordinates with KR = 0.299, KB = 0.114. ",
    "links" : [ ]
  }, {
    "name" : "COLOR_STANDARD_BT601_NTSC",
    "type" : "int",
    "comment" : " BT.601 525 color chromacity coordinates with KR = 0.299, KB = 0.114. ",
    "links" : [ ]
  }, {
    "name" : "COLOR_STANDARD_BT2020",
    "type" : "int",
    "comment" : " BT.2020 color chromacity coordinates with KR = 0.2627, KB = 0.0593. ",
    "links" : [ ]
  }, {
    "name" : "KEY_COLOR_TRANSFER",
    "type" : "String",
    "comment" : "\n     * An optional key describing the opto-electronic transfer function used\n     * for the video content.\n     *\n     * The associated value is an integer: 0 if unspecified, or one of the\n     * COLOR_TRANSFER_ values.\n     ",
    "links" : [ ]
  }, {
    "name" : "COLOR_TRANSFER_LINEAR",
    "type" : "int",
    "comment" : " Linear transfer characteristic curve. ",
    "links" : [ ]
  }, {
    "name" : "COLOR_TRANSFER_SDR_VIDEO",
    "type" : "int",
    "comment" : " SMPTE 170M transfer characteristic curve used by BT.601/BT.709/BT.2020. This is the curve\n     *  used by most non-HDR video content. ",
    "links" : [ ]
  }, {
    "name" : "COLOR_TRANSFER_ST2084",
    "type" : "int",
    "comment" : " SMPTE ST 2084 transfer function. This is used by some HDR video content. ",
    "links" : [ ]
  }, {
    "name" : "COLOR_TRANSFER_HLG",
    "type" : "int",
    "comment" : " ARIB STD-B67 hybrid-log-gamma transfer function. This is used by some HDR video content. ",
    "links" : [ ]
  }, {
    "name" : "KEY_COLOR_RANGE",
    "type" : "String",
    "comment" : "\n     * An optional key describing the range of the component values of the video content.\n     *\n     * The associated value is an integer: 0 if unspecified, or one of the\n     * COLOR_RANGE_ values.\n     ",
    "links" : [ ]
  }, {
    "name" : "COLOR_RANGE_LIMITED",
    "type" : "int",
    "comment" : " Limited range. Y component values range from 16 to 235 for 8-bit content.\n     *  Cr, Cy values range from 16 to 240 for 8-bit content.\n     *  This is the default for video content. ",
    "links" : [ ]
  }, {
    "name" : "COLOR_RANGE_FULL",
    "type" : "int",
    "comment" : " Full range. Y, Cr and Cb component values range from 0 to 255 for 8-bit content. ",
    "links" : [ ]
  }, {
    "name" : "KEY_HDR_STATIC_INFO",
    "type" : "String",
    "comment" : "\n     * An optional key describing the static metadata of HDR (high-dynamic-range) video content.\n     *\n     * The associated value is a ByteBuffer. This buffer contains the raw contents of the\n     * Static Metadata Descriptor (including the descriptor ID) of an HDMI Dynamic Range and\n     * Mastering InfoFrame as defined by CTA-861.3. This key must be provided to video decoders\n     * for HDR video content unless this information is contained in the bitstream and the video\n     * decoder supports an HDR-capable profile. This key must be provided to video encoders for\n     * HDR video content.\n     ",
    "links" : [ ]
  }, {
    "name" : "KEY_HDR10_PLUS_INFO",
    "type" : "String",
    "comment" : "\n     * An optional key describing the HDR10+ metadata of the video content.\n     *\n     * The associated value is a ByteBuffer containing HDR10+ metadata conforming to the\n     * user_data_registered_itu_t_t35() syntax of SEI message for ST 2094-40. This key will\n     * be present on:\n     *<p>\n     * - The formats of output buffers of a decoder configured for HDR10+ profiles (such as\n     *   {@link MediaCodecInfo.CodecProfileLevel#VP9Profile2HDR10Plus}, {@link\n     *   MediaCodecInfo.CodecProfileLevel#VP9Profile3HDR10Plus} or {@link\n     *   MediaCodecInfo.CodecProfileLevel#HEVCProfileMain10HDR10Plus}), or\n     *<p>\n     * - The formats of output buffers of an encoder configured for an HDR10+ profiles that\n     *   uses out-of-band metadata (such as {@link\n     *   MediaCodecInfo.CodecProfileLevel#VP9Profile2HDR10Plus} or {@link\n     *   MediaCodecInfo.CodecProfileLevel#VP9Profile3HDR10Plus}).\n     *\n     * @see MediaCodec#PARAMETER_KEY_HDR10_PLUS_INFO\n     ",
    "links" : [ "MediaCodecInfo.CodecProfileLevel#VP9Profile2HDR10Plus" ]
  }, {
    "name" : "KEY_TRACK_ID",
    "type" : "String",
    "comment" : "\n     * A key describing a unique ID for the content of a media track.\n     *\n     * <p>This key is used by {@link MediaExtractor}. Some extractors provide multiple encodings\n     * of the same track (e.g. float audio tracks for FLAC and WAV may be expressed as two\n     * tracks via MediaExtractor: a normal PCM track for backward compatibility, and a float PCM\n     * track for added fidelity. Similarly, Dolby Vision extractor may provide a baseline SDR\n     * version of a DV track.) This key can be used to identify which MediaExtractor tracks refer\n     * to the same underlying content.\n     * </p>\n     *\n     * The associated value is an integer.\n     ",
    "links" : [ "MediaExtractor" ]
  }, {
    "name" : "KEY_CA_SYSTEM_ID",
    "type" : "String",
    "comment" : "\n     * A key describing the system id of the conditional access system used to scramble\n     * a media track.\n     * <p>\n     * This key is set by {@link MediaExtractor} if the track is scrambled with a conditional\n     * access system, regardless of the presence of a valid {@link MediaCas} object.\n     * <p>\n     * The associated value is an integer.\n     * @hide\n     ",
    "links" : [ "MediaExtractor", "MediaCas" ]
  }, {
    "name" : "KEY_CA_SESSION_ID",
    "type" : "String",
    "comment" : "\n     * A key describing the {@link MediaCas.Session} object associated with a media track.\n     * <p>\n     * This key is set by {@link MediaExtractor} if the track is scrambled with a conditional\n     * access system, after it receives a valid {@link MediaCas} object.\n     * <p>\n     * The associated value is a ByteBuffer.\n     * @hide\n     ",
    "links" : [ "MediaCas.Session", "MediaExtractor", "MediaCas" ]
  }, {
    "name" : "KEY_CA_PRIVATE_DATA",
    "type" : "String",
    "comment" : "\n     * A key describing the private data in the CA_descriptor associated with a media track.\n     * <p>\n     * This key is set by {@link MediaExtractor} if the track is scrambled with a conditional\n     * access system, before it receives a valid {@link MediaCas} object.\n     * <p>\n     * The associated value is a ByteBuffer.\n     * @hide\n     ",
    "links" : [ "MediaExtractor", "MediaCas" ]
  }, {
    "name" : "KEY_MAX_B_FRAMES",
    "type" : "String",
    "comment" : "\n     * A key describing the maximum number of B frames between I or P frames,\n     * to be used by a video encoder.\n     * The associated value is an integer. The default value is 0, which means\n     * that no B frames are allowed. Note that non-zero value does not guarantee\n     * B frames; it's up to the encoder to decide.\n     ",
    "links" : [ ]
  }, {
    "name" : "TYPE_NULL",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "TYPE_INTEGER",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "TYPE_LONG",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "TYPE_FLOAT",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "TYPE_STRING",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "TYPE_BYTE_BUFFER",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "KEY_FEATURE_",
    "type" : "String",
    "comment" : "\n     * A key prefix used together with a {@link MediaCodecInfo.CodecCapabilities}\n     * feature name describing a required or optional feature for a codec capabilities\n     * query.\n     * The associated value is an integer, where non-0 value means the feature is\n     * requested to be present, while 0 value means the feature is requested to be not\n     * present.\n     * @see MediaCodecList#findDecoderForFormat\n     * @see MediaCodecList#findEncoderForFormat\n     * @see MediaCodecInfo.CodecCapabilities#isFormatSupported\n     *\n     * @hide\n     ",
    "links" : [ "MediaCodecInfo.CodecCapabilities" ]
  } ],
  "methods" : [ {
    "name" : " Map<String, Object> getMap()",
    "returnType" : "Map<String, Object>",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public final boolean containsKey(@NonNull String name)",
    "returnType" : "boolean",
    "comment" : "\n     * Returns true iff a key of the given name exists in the format.\n     ",
    "links" : [ ]
  }, {
    "name" : "public final boolean containsFeature(@NonNull String name)",
    "returnType" : "boolean",
    "comment" : "\n     * Returns true iff a feature of the given name exists in the format.\n     ",
    "links" : [ ]
  }, {
    "name" : "public final int getValueTypeForKey(@NonNull String name)",
    "returnType" : "int",
    "comment" : "\n     * Returns the value type for a key. If the key does not exist, it returns TYPE_NULL.\n     ",
    "links" : [ ]
  }, {
    "name" : "public final Number getNumber(@NonNull String name)",
    "returnType" : "Number",
    "comment" : "\n     * Returns the value of a numeric key. This is provided as a convenience method for keys\n     * that may take multiple numeric types, such as {@link #KEY_FRAME_RATE}, or {@link\n     * #KEY_I_FRAME_INTERVAL}.\n     *\n     * @return null if the key does not exist or the stored value for the key is null\n     * @throws ClassCastException if the stored value for the key is ByteBuffer or String\n     ",
    "links" : [ "#KEY_FRAME_RATE" ]
  }, {
    "name" : "public final Number getNumber(@NonNull String name, @NonNull Number defaultValue)",
    "returnType" : "Number",
    "comment" : "\n     * Returns the value of a numeric key, or the default value if the key is missing.\n     *\n     * @return defaultValue if the key does not exist or the stored value for the key is null\n     * @throws ClassCastException if the stored value for the key is ByteBuffer or String\n     ",
    "links" : [ ]
  }, {
    "name" : "public final int getInteger(@NonNull String name)",
    "returnType" : "int",
    "comment" : "\n     * Returns the value of an integer key.\n     *\n     * @throws NullPointerException if the key does not exist or the stored value for the key is\n     *         null\n     * @throws ClassCastException if the stored value for the key is long, float, ByteBuffer or\n     *         String\n     ",
    "links" : [ ]
  }, {
    "name" : "public final int getInteger(@NonNull String name, int defaultValue)",
    "returnType" : "int",
    "comment" : "\n     * Returns the value of an integer key, or the default value if the key is missing.\n     *\n     * @return defaultValue if the key does not exist or the stored value for the key is null\n     * @throws ClassCastException if the stored value for the key is long, float, ByteBuffer or\n     *         String\n     ",
    "links" : [ ]
  }, {
    "name" : "public final long getLong(@NonNull String name)",
    "returnType" : "long",
    "comment" : "\n     * Returns the value of a long key.\n     *\n     * @throws NullPointerException if the key does not exist or the stored value for the key is\n     *         null\n     * @throws ClassCastException if the stored value for the key is int, float, ByteBuffer or\n     *         String\n     ",
    "links" : [ ]
  }, {
    "name" : "public final long getLong(@NonNull String name, long defaultValue)",
    "returnType" : "long",
    "comment" : "\n     * Returns the value of a long key, or the default value if the key is missing.\n     *\n     * @return defaultValue if the key does not exist or the stored value for the key is null\n     * @throws ClassCastException if the stored value for the key is int, float, ByteBuffer or\n     *         String\n     ",
    "links" : [ ]
  }, {
    "name" : "public final float getFloat(@NonNull String name)",
    "returnType" : "float",
    "comment" : "\n     * Returns the value of a float key.\n     *\n     * @throws NullPointerException if the key does not exist or the stored value for the key is\n     *         null\n     * @throws ClassCastException if the stored value for the key is int, long, ByteBuffer or\n     *         String\n     ",
    "links" : [ ]
  }, {
    "name" : "public final float getFloat(@NonNull String name, float defaultValue)",
    "returnType" : "float",
    "comment" : "\n     * Returns the value of a float key, or the default value if the key is missing.\n     *\n     * @return defaultValue if the key does not exist or the stored value for the key is null\n     * @throws ClassCastException if the stored value for the key is int, long, ByteBuffer or\n     *         String\n     ",
    "links" : [ ]
  }, {
    "name" : "public final String getString(@NonNull String name)",
    "returnType" : "String",
    "comment" : "\n     * Returns the value of a string key.\n     *\n     * @return null if the key does not exist or the stored value for the key is null\n     * @throws ClassCastException if the stored value for the key is int, long, float or ByteBuffer\n     ",
    "links" : [ ]
  }, {
    "name" : "public final String getString(@NonNull String name, @NonNull String defaultValue)",
    "returnType" : "String",
    "comment" : "\n     * Returns the value of a string key, or the default value if the key is missing.\n     *\n     * @return defaultValue if the key does not exist or the stored value for the key is null\n     * @throws ClassCastException if the stored value for the key is int, long, float or ByteBuffer\n     ",
    "links" : [ ]
  }, {
    "name" : "public final ByteBuffer getByteBuffer(@NonNull String name)",
    "returnType" : "ByteBuffer",
    "comment" : "\n     * Returns the value of a ByteBuffer key.\n     *\n     * @return null if the key does not exist or the stored value for the key is null\n     * @throws ClassCastException if the stored value for the key is int, long, float or String\n     ",
    "links" : [ ]
  }, {
    "name" : "public final ByteBuffer getByteBuffer(@NonNull String name, @NonNull ByteBuffer defaultValue)",
    "returnType" : "ByteBuffer",
    "comment" : "\n     * Returns the value of a ByteBuffer key, or the default value if the key is missing.\n     *\n     * @return defaultValue if the key does not exist or the stored value for the key is null\n     * @throws ClassCastException if the stored value for the key is int, long, float or String\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean getFeatureEnabled(@NonNull String feature)",
    "returnType" : "boolean",
    "comment" : "\n     * Returns whether a feature is to be enabled ({@code true}) or disabled\n     * ({@code false}).\n     *\n     * @param feature the name of a {@link MediaCodecInfo.CodecCapabilities} feature.\n     *\n     * @throws IllegalArgumentException if the feature was neither set to be enabled\n     *         nor to be disabled.\n     ",
    "links" : [ "MediaCodecInfo.CodecCapabilities" ]
  }, {
    "name" : "public final void setInteger(@NonNull String name, int value)",
    "returnType" : "void",
    "comment" : "\n     * Sets the value of an integer key.\n     ",
    "links" : [ ]
  }, {
    "name" : "public final void setLong(@NonNull String name, long value)",
    "returnType" : "void",
    "comment" : "\n     * Sets the value of a long key.\n     ",
    "links" : [ ]
  }, {
    "name" : "public final void setFloat(@NonNull String name, float value)",
    "returnType" : "void",
    "comment" : "\n     * Sets the value of a float key.\n     ",
    "links" : [ ]
  }, {
    "name" : "public final void setString(@NonNull String name, @Nullable String value)",
    "returnType" : "void",
    "comment" : "\n     * Sets the value of a string key.\n     * <p>\n     * If value is {@code null}, it sets a null value that behaves similarly to a missing key.\n     * This could be used prior to API level {@link android os.Build.VERSION_CODES#Q} to effectively\n     * remove a key.\n     ",
    "links" : [ "android" ]
  }, {
    "name" : "public final void setByteBuffer(@NonNull String name, @Nullable ByteBuffer bytes)",
    "returnType" : "void",
    "comment" : "\n     * Sets the value of a ByteBuffer key.\n     * <p>\n     * If value is {@code null}, it sets a null value that behaves similarly to a missing key.\n     * This could be used prior to API level {@link android os.Build.VERSION_CODES#Q} to effectively\n     * remove a key.\n     ",
    "links" : [ "android" ]
  }, {
    "name" : "public final void removeKey(@NonNull String name)",
    "returnType" : "void",
    "comment" : "\n     * Removes a value of a given key if present. Has no effect if the key is not present.\n     ",
    "links" : [ ]
  }, {
    "name" : "public final void removeFeature(@NonNull String name)",
    "returnType" : "void",
    "comment" : "\n     * Removes a given feature setting if present. Has no effect if the feature setting is not\n     * present.\n     ",
    "links" : [ ]
  }, {
    "name" : "public final java.util.Set<String> getKeys()",
    "returnType" : "java.util.Set<String>",
    "comment" : "\n     * Returns a {@link java.util.Set Set} view of the keys contained in this MediaFormat.\n     *\n     * The set is backed by the MediaFormat object, so changes to the format are reflected in the\n     * set, and vice-versa. If the format is modified while an iteration over the set is in progress\n     * (except through the iterator's own remove operation), the results of the iteration are\n     * undefined. The set supports element removal, which removes the corresponding mapping from the\n     * format, via the Iterator.remove, Set.remove, removeAll, retainAll, and clear operations.\n     * It does not support the add or addAll operations.\n     ",
    "links" : [ "java.util.Set" ]
  }, {
    "name" : "public final java.util.Set<String> getFeatures()",
    "returnType" : "java.util.Set<String>",
    "comment" : "\n     * Returns a {@link java.util.Set Set} view of the features contained in this MediaFormat.\n     *\n     * The set is backed by the MediaFormat object, so changes to the format are reflected in the\n     * set, and vice-versa. If the format is modified while an iteration over the set is in progress\n     * (except through the iterator's own remove operation), the results of the iteration are\n     * undefined. The set supports element removal, which removes the corresponding mapping from the\n     * format, via the Iterator.remove, Set.remove, removeAll, retainAll, and clear operations.\n     * It does not support the add or addAll operations.\n     ",
    "links" : [ "java.util.Set" ]
  }, {
    "name" : "public void setFeatureEnabled(@NonNull String feature, boolean enabled)",
    "returnType" : "void",
    "comment" : "\n     * Sets whether a feature is to be enabled ({@code true}) or disabled\n     * ({@code false}).\n     *\n     * If {@code enabled} is {@code true}, the feature is requested to be present.\n     * Otherwise, the feature is requested to be not present.\n     *\n     * @param feature the name of a {@link MediaCodecInfo.CodecCapabilities} feature.\n     *\n     * @see MediaCodecList#findDecoderForFormat\n     * @see MediaCodecList#findEncoderForFormat\n     * @see MediaCodecInfo.CodecCapabilities#isFormatSupported\n     ",
    "links" : [ "MediaCodecInfo.CodecCapabilities" ]
  }, {
    "name" : "public static final MediaFormat createAudioFormat(@NonNull String mime, int sampleRate, int channelCount)",
    "returnType" : "MediaFormat",
    "comment" : "\n     * Creates a minimal audio format.\n     * @param mime The mime type of the content.\n     * @param sampleRate The sampling rate of the content.\n     * @param channelCount The number of audio channels in the content.\n     ",
    "links" : [ ]
  }, {
    "name" : "public static final MediaFormat createSubtitleFormat(@NonNull String mime, String language)",
    "returnType" : "MediaFormat",
    "comment" : "\n     * Creates a minimal subtitle format.\n     * @param mime The mime type of the content.\n     * @param language The language of the content, using either ISO 639-1 or 639-2/T\n     *        codes.  Specify null or \"und\" if language information is only included\n     *        in the content.  (This will also work if there are multiple language\n     *        tracks in the content.)\n     ",
    "links" : [ ]
  }, {
    "name" : "public static final MediaFormat createVideoFormat(@NonNull String mime, int width, int height)",
    "returnType" : "MediaFormat",
    "comment" : "\n     * Creates a minimal video format.\n     * @param mime The mime type of the content.\n     * @param width The width of the content (in pixels)\n     * @param height The height of the content (in pixels)\n     ",
    "links" : [ ]
  }, {
    "name" : "public String toString()",
    "returnType" : "String",
    "comment" : "",
    "links" : [ ]
  } ],
  "variableNames" : [ "MIMETYPE_VIDEO_VP8", "MIMETYPE_VIDEO_VP9", "MIMETYPE_VIDEO_AV1", "MIMETYPE_VIDEO_AVC", "MIMETYPE_VIDEO_HEVC", "MIMETYPE_VIDEO_MPEG4", "MIMETYPE_VIDEO_H263", "MIMETYPE_VIDEO_MPEG2", "MIMETYPE_VIDEO_RAW", "MIMETYPE_VIDEO_DOLBY_VISION", "MIMETYPE_VIDEO_SCRAMBLED", "MIMETYPE_AUDIO_AMR_NB", "MIMETYPE_AUDIO_AMR_WB", "MIMETYPE_AUDIO_MPEG", "MIMETYPE_AUDIO_AAC", "MIMETYPE_AUDIO_QCELP", "MIMETYPE_AUDIO_VORBIS", "MIMETYPE_AUDIO_OPUS", "MIMETYPE_AUDIO_G711_ALAW", "MIMETYPE_AUDIO_G711_MLAW", "MIMETYPE_AUDIO_RAW", "MIMETYPE_AUDIO_FLAC", "MIMETYPE_AUDIO_MSGSM", "MIMETYPE_AUDIO_AC3", "MIMETYPE_AUDIO_EAC3", "MIMETYPE_AUDIO_EAC3_JOC", "MIMETYPE_AUDIO_AC4", "MIMETYPE_AUDIO_SCRAMBLED", "MIMETYPE_IMAGE_ANDROID_HEIC", "MIMETYPE_TEXT_VTT", "MIMETYPE_TEXT_SUBRIP", "MIMETYPE_TEXT_CEA_608", "MIMETYPE_TEXT_CEA_708", "mMap", "KEY_MIME", "KEY_CODECS_STRING", "KEY_LOW_LATENCY", "KEY_LANGUAGE", "KEY_CAPTION_SERVICE_NUMBER", "KEY_SAMPLE_RATE", "KEY_CHANNEL_COUNT", "KEY_WIDTH", "KEY_HEIGHT", "KEY_MAX_WIDTH", "KEY_MAX_HEIGHT", "KEY_MAX_INPUT_SIZE", "KEY_PIXEL_ASPECT_RATIO_WIDTH", "KEY_PIXEL_ASPECT_RATIO_HEIGHT", "KEY_BIT_RATE", "KEY_HARDWARE_AV_SYNC_ID", "KEY_MAX_BIT_RATE", "KEY_COLOR_FORMAT", "KEY_FRAME_RATE", "KEY_TILE_WIDTH", "KEY_TILE_HEIGHT", "KEY_GRID_ROWS", "KEY_GRID_COLUMNS", "KEY_PCM_ENCODING", "KEY_CAPTURE_RATE", "KEY_I_FRAME_INTERVAL", "KEY_INTRA_REFRESH_PERIOD", "KEY_PREPEND_HEADER_TO_SYNC_FRAMES", "KEY_TEMPORAL_LAYERING", "KEY_STRIDE", "KEY_SLICE_HEIGHT", "KEY_REPEAT_PREVIOUS_FRAME_AFTER", "KEY_MAX_FPS_TO_ENCODER", "KEY_MAX_PTS_GAP_TO_ENCODER", "KEY_CREATE_INPUT_SURFACE_SUSPENDED", "KEY_PUSH_BLANK_BUFFERS_ON_STOP", "KEY_DURATION", "KEY_IS_ADTS", "KEY_CHANNEL_MASK", "KEY_ENCODER_DELAY", "KEY_ENCODER_PADDING", "KEY_AAC_PROFILE", "KEY_AAC_SBR_MODE", "KEY_AAC_MAX_OUTPUT_CHANNEL_COUNT", "KEY_AAC_DRC_TARGET_REFERENCE_LEVEL", "KEY_AAC_DRC_EFFECT_TYPE", "KEY_AAC_ENCODED_TARGET_LEVEL", "KEY_AAC_DRC_BOOST_FACTOR", "KEY_AAC_DRC_ATTENUATION_FACTOR", "KEY_AAC_DRC_HEAVY_COMPRESSION", "KEY_AAC_DRC_OUTPUT_LOUDNESS", "KEY_AAC_DRC_ALBUM_MODE", "KEY_FLAC_COMPRESSION_LEVEL", "KEY_COMPLEXITY", "KEY_QUALITY", "KEY_PRIORITY", "KEY_OPERATING_RATE", "KEY_PROFILE", "KEY_LEVEL", "KEY_LATENCY", "KEY_OUTPUT_REORDER_DEPTH", "KEY_ROTATION", "KEY_BITRATE_MODE", "KEY_AUDIO_SESSION_ID", "KEY_IS_AUTOSELECT", "KEY_IS_DEFAULT", "KEY_IS_FORCED_SUBTITLE", "KEY_HAPTIC_CHANNEL_COUNT", "KEY_IS_TIMED_TEXT", "KEY_COLOR_STANDARD", "COLOR_STANDARD_BT709", "COLOR_STANDARD_BT601_PAL", "COLOR_STANDARD_BT601_NTSC", "COLOR_STANDARD_BT2020", "KEY_COLOR_TRANSFER", "COLOR_TRANSFER_LINEAR", "COLOR_TRANSFER_SDR_VIDEO", "COLOR_TRANSFER_ST2084", "COLOR_TRANSFER_HLG", "KEY_COLOR_RANGE", "COLOR_RANGE_LIMITED", "COLOR_RANGE_FULL", "KEY_HDR_STATIC_INFO", "KEY_HDR10_PLUS_INFO", "KEY_TRACK_ID", "KEY_CA_SYSTEM_ID", "KEY_CA_SESSION_ID", "KEY_CA_PRIVATE_DATA", "KEY_MAX_B_FRAMES", "TYPE_NULL", "TYPE_INTEGER", "TYPE_LONG", "TYPE_FLOAT", "TYPE_STRING", "TYPE_BYTE_BUFFER", "KEY_FEATURE_" ],
  "methodNames" : [ " Map<String, Object> getMap()", "public final boolean containsKey(@NonNull String name)", "public final boolean containsFeature(@NonNull String name)", "public final int getValueTypeForKey(@NonNull String name)", "public final Number getNumber(@NonNull String name)", "public final Number getNumber(@NonNull String name, @NonNull Number defaultValue)", "public final int getInteger(@NonNull String name)", "public final int getInteger(@NonNull String name, int defaultValue)", "public final long getLong(@NonNull String name)", "public final long getLong(@NonNull String name, long defaultValue)", "public final float getFloat(@NonNull String name)", "public final float getFloat(@NonNull String name, float defaultValue)", "public final String getString(@NonNull String name)", "public final String getString(@NonNull String name, @NonNull String defaultValue)", "public final ByteBuffer getByteBuffer(@NonNull String name)", "public final ByteBuffer getByteBuffer(@NonNull String name, @NonNull ByteBuffer defaultValue)", "public boolean getFeatureEnabled(@NonNull String feature)", "public final void setInteger(@NonNull String name, int value)", "public final void setLong(@NonNull String name, long value)", "public final void setFloat(@NonNull String name, float value)", "public final void setString(@NonNull String name, @Nullable String value)", "public final void setByteBuffer(@NonNull String name, @Nullable ByteBuffer bytes)", "public final void removeKey(@NonNull String name)", "public final void removeFeature(@NonNull String name)", "public final java.util.Set<String> getKeys()", "public final java.util.Set<String> getFeatures()", "public void setFeatureEnabled(@NonNull String feature, boolean enabled)", "public static final MediaFormat createAudioFormat(@NonNull String mime, int sampleRate, int channelCount)", "public static final MediaFormat createSubtitleFormat(@NonNull String mime, String language)", "public static final MediaFormat createVideoFormat(@NonNull String mime, int width, int height)", "public String toString()" ]
}