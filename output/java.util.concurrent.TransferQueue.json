{
  "filePath" : "/home/maryam/clearblue/files/android-source-35/java/util/concurrent/TransferQueue.java",
  "packageName" : "java.util.concurrent",
  "className" : "TransferQueue",
  "comment" : "\n * A {@link BlockingQueue} in which producers may wait for consumers\n * to receive elements.  A {@code TransferQueue} may be useful for\n * example in message passing applications in which producers\n * sometimes (using method {@link #transfer}) await receipt of\n * elements by consumers invoking {@code take} or {@code poll}, while\n * at other times enqueue elements (via method {@code put}) without\n * waiting for receipt.\n * {@linkplain #tryTransfer(Object) Non-blocking} and\n * {@linkplain #tryTransfer(Object,long,TimeUnit) time-out} versions of\n * {@code tryTransfer} are also available.\n * A {@code TransferQueue} may also be queried, via {@link\n * #hasWaitingConsumer}, whether there are any threads waiting for\n * items, which is a converse analogy to a {@code peek} operation.\n *\n * <p>Like other blocking queues, a {@code TransferQueue} may be\n * capacity bounded.  If so, an attempted transfer operation may\n * initially block waiting for available space, and/or subsequently\n * block waiting for reception by a consumer.  Note that in a queue\n * with zero capacity, such as {@link SynchronousQueue}, {@code put}\n * and {@code transfer} are effectively synonymous.\n *\n * <p>This interface is a member of the\n * <a href=\"{@docRoot}/java.base/java/util/package-summary.html#CollectionsFramework\">\n * Java Collections Framework</a>.\n *\n * @since 1.7\n * @author Doug Lea\n * @param <E> the type of elements held in this queue\n ",
  "links" : [ "java.util.concurrent.SynchronousQueue", "java.util.concurrent.BlockingQueue", "#transfer", "#hasWaitingConsumer" ],
  "variables" : [ ],
  "methods" : [ {
    "name" : " boolean tryTransfer(E e)",
    "returnType" : "boolean",
    "comment" : "\n     * Transfers the element to a waiting consumer immediately, if possible.\n     *\n     * <p>More precisely, transfers the specified element immediately\n     * if there exists a consumer already waiting to receive it (in\n     * {@link #take} or timed {@link #poll(long,TimeUnit) poll}),\n     * otherwise returning {@code false} without enqueuing the element.\n     *\n     * @param e the element to transfer\n     * @return {@code true} if the element was transferred, else\n     *         {@code false}\n     * @throws ClassCastException if the class of the specified element\n     *         prevents it from being added to this queue\n     * @throws NullPointerException if the specified element is null\n     * @throws IllegalArgumentException if some property of the specified\n     *         element prevents it from being added to this queue\n     ",
    "links" : [ "#poll(long", "#take" ]
  }, {
    "name" : " void transfer(E e) throws InterruptedException",
    "returnType" : "void",
    "comment" : "\n     * Transfers the element to a consumer, waiting if necessary to do so.\n     *\n     * <p>More precisely, transfers the specified element immediately\n     * if there exists a consumer already waiting to receive it (in\n     * {@link #take} or timed {@link #poll(long,TimeUnit) poll}),\n     * else waits until the element is received by a consumer.\n     *\n     * @param e the element to transfer\n     * @throws InterruptedException if interrupted while waiting,\n     *         in which case the element is not left enqueued\n     * @throws ClassCastException if the class of the specified element\n     *         prevents it from being added to this queue\n     * @throws NullPointerException if the specified element is null\n     * @throws IllegalArgumentException if some property of the specified\n     *         element prevents it from being added to this queue\n     ",
    "links" : [ "#poll(long", "#take" ]
  }, {
    "name" : " boolean tryTransfer(E e, long timeout, TimeUnit unit) throws InterruptedException",
    "returnType" : "boolean",
    "comment" : "\n     * Transfers the element to a consumer if it is possible to do so\n     * before the timeout elapses.\n     *\n     * <p>More precisely, transfers the specified element immediately\n     * if there exists a consumer already waiting to receive it (in\n     * {@link #take} or timed {@link #poll(long,TimeUnit) poll}),\n     * else waits until the element is received by a consumer,\n     * returning {@code false} if the specified wait time elapses\n     * before the element can be transferred.\n     *\n     * @param e the element to transfer\n     * @param timeout how long to wait before giving up, in units of\n     *        {@code unit}\n     * @param unit a {@code TimeUnit} determining how to interpret the\n     *        {@code timeout} parameter\n     * @return {@code true} if successful, or {@code false} if\n     *         the specified waiting time elapses before completion,\n     *         in which case the element is not left enqueued\n     * @throws InterruptedException if interrupted while waiting,\n     *         in which case the element is not left enqueued\n     * @throws ClassCastException if the class of the specified element\n     *         prevents it from being added to this queue\n     * @throws NullPointerException if the specified element is null\n     * @throws IllegalArgumentException if some property of the specified\n     *         element prevents it from being added to this queue\n     ",
    "links" : [ "#poll(long", "#take" ]
  }, {
    "name" : " boolean hasWaitingConsumer()",
    "returnType" : "boolean",
    "comment" : "\n     * Returns {@code true} if there is at least one consumer waiting\n     * to receive an element via {@link #take} or\n     * timed {@link #poll(long,TimeUnit) poll}.\n     * The return value represents a momentary state of affairs.\n     *\n     * @return {@code true} if there is at least one waiting consumer\n     ",
    "links" : [ "#poll(long", "#take" ]
  }, {
    "name" : " int getWaitingConsumerCount()",
    "returnType" : "int",
    "comment" : "\n     * Returns an estimate of the number of consumers waiting to\n     * receive elements via {@link #take} or timed\n     * {@link #poll(long,TimeUnit) poll}.  The return value is an\n     * approximation of a momentary state of affairs, that may be\n     * inaccurate if consumers have completed or given up waiting.\n     * The value may be useful for monitoring and heuristics, but\n     * not for synchronization control.  Implementations of this\n     * method are likely to be noticeably slower than those for\n     * {@link #hasWaitingConsumer}.\n     *\n     * @return the number of consumers waiting to receive elements\n     ",
    "links" : [ "#poll(long", "#take", "#hasWaitingConsumer" ]
  } ],
  "methodNames" : [ " boolean tryTransfer(E e)", " void transfer(E e) throws InterruptedException", " boolean tryTransfer(E e, long timeout, TimeUnit unit) throws InterruptedException", " boolean hasWaitingConsumer()", " int getWaitingConsumerCount()" ],
  "variableNames" : [ ]
}