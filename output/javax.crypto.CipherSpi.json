{
  "filePath" : "/home/maryam/clearblue/files/android-source-35/javax/crypto/CipherSpi.java",
  "packageName" : "javax.crypto",
  "className" : "CipherSpi",
  "comment" : "",
  "links" : [ ],
  "variables" : [ ],
  "methods" : [ {
    "name" : "protected abstract void engineSetMode(String mode) throws NoSuchAlgorithmException",
    "returnType" : "void",
    "comment" : "\n     * Sets the mode of this cipher.\n     *\n     * @param mode the cipher mode\n     *\n     * @exception NoSuchAlgorithmException if the requested cipher mode does\n     * not exist\n     ",
    "links" : [ ]
  }, {
    "name" : "protected abstract void engineSetPadding(String padding) throws NoSuchPaddingException",
    "returnType" : "void",
    "comment" : "\n     * Sets the padding mechanism of this cipher.\n     *\n     * @param padding the padding mechanism\n     *\n     * @exception NoSuchPaddingException if the requested padding mechanism\n     * does not exist\n     ",
    "links" : [ ]
  }, {
    "name" : "protected abstract int engineGetBlockSize()",
    "returnType" : "int",
    "comment" : "\n     * Returns the block size (in bytes).\n     *\n     * @return the block size (in bytes), or 0 if the underlying algorithm is\n     * not a block cipher\n     ",
    "links" : [ ]
  }, {
    "name" : "protected abstract int engineGetOutputSize(int inputLen)",
    "returnType" : "int",
    "comment" : "\n     * Returns the length in bytes that an output buffer would\n     * need to be in order to hold the result of the next <code>update</code>\n     * or <code>doFinal</code> operation, given the input length\n     * <code>inputLen</code> (in bytes).\n     *\n     * <p>This call takes into account any unprocessed (buffered) data from a\n     * previous <code>update</code> call, padding, and AEAD tagging.\n     *\n     * <p>The actual output length of the next <code>update</code> or\n     * <code>doFinal</code> call may be smaller than the length returned by\n     * this method.\n     *\n     * @param inputLen the input length (in bytes)\n     *\n     * @return the required output buffer size (in bytes)\n     ",
    "links" : [ ]
  }, {
    "name" : "protected abstract byte[] engineGetIV()",
    "returnType" : "byte[]",
    "comment" : "\n     * Returns the initialization vector (IV) in a new buffer.\n     *\n     * <p> This is useful in the context of password-based encryption or\n     * decryption, where the IV is derived from a user-provided passphrase.\n     *\n     * @return the initialization vector in a new buffer, or null if the\n     * underlying algorithm does not use an IV, or if the IV has not yet\n     * been set.\n     ",
    "links" : [ ]
  }, {
    "name" : "protected abstract AlgorithmParameters engineGetParameters()",
    "returnType" : "AlgorithmParameters",
    "comment" : "\n     * Returns the parameters used with this cipher.\n     *\n     * <p>The returned parameters may be the same that were used to initialize\n     * this cipher, or may contain a combination of default and random\n     * parameter values used by the underlying cipher implementation if this\n     * cipher requires algorithm parameters but was not initialized with any.\n     *\n     * @return the parameters used with this cipher, or null if this cipher\n     * does not use any parameters.\n     ",
    "links" : [ ]
  }, {
    "name" : "protected abstract void engineInit(int opmode, Key key, SecureRandom random) throws InvalidKeyException",
    "returnType" : "void",
    "comment" : "\n     * Initializes this cipher with a key and a source\n     * of randomness.\n     *\n     * <p>The cipher is initialized for one of the following four operations:\n     * encryption, decryption, key wrapping or key unwrapping, depending on\n     * the value of <code>opmode</code>.\n     *\n     * <p>If this cipher requires any algorithm parameters that cannot be\n     * derived from the given <code>key</code>, the underlying cipher\n     * implementation is supposed to generate the required parameters itself\n     * (using provider-specific default or random values) if it is being\n     * initialized for encryption or key wrapping, and raise an\n     * <code>InvalidKeyException</code> if it is being\n     * initialized for decryption or key unwrapping.\n     * The generated parameters can be retrieved using\n     * {@link #engineGetParameters() engineGetParameters} or\n     * {@link #engineGetIV() engineGetIV} (if the parameter is an IV).\n     *\n     * <p>If this cipher requires algorithm parameters that cannot be\n     * derived from the input parameters, and there are no reasonable\n     * provider-specific default values, initialization will\n     * necessarily fail.\n     *\n     * <p>If this cipher (including its underlying feedback or padding scheme)\n     * requires any random bytes (e.g., for parameter generation), it will get\n     * them from <code>random</code>.\n     *\n     * <p>Note that when a Cipher object is initialized, it loses all\n     * previously-acquired state. In other words, initializing a Cipher is\n     * equivalent to creating a new instance of that Cipher and initializing\n     * it.\n     *\n     * @param opmode the operation mode of this cipher (this is one of\n     * the following:\n     * <code>ENCRYPT_MODE</code>, <code>DECRYPT_MODE</code>,\n     * <code>WRAP_MODE</code> or <code>UNWRAP_MODE</code>)\n     * @param key the encryption key\n     * @param random the source of randomness\n     *\n     * @exception InvalidKeyException if the given key is inappropriate for\n     * initializing this cipher, or requires\n     * algorithm parameters that cannot be\n     * determined from the given key.\n     * @throws UnsupportedOperationException if {@code opmode} is\n     * {@code WRAP_MODE} or {@code UNWRAP_MODE} is not implemented\n     * by the cipher.\n     ",
    "links" : [ "#engineGetParameters()", "#engineGetIV()" ]
  }, {
    "name" : "protected abstract void engineInit(int opmode, Key key, AlgorithmParameterSpec params, SecureRandom random) throws InvalidKeyException, InvalidAlgorithmParameterException",
    "returnType" : "void",
    "comment" : "\n     * Initializes this cipher with a key, a set of\n     * algorithm parameters, and a source of randomness.\n     *\n     * <p>The cipher is initialized for one of the following four operations:\n     * encryption, decryption, key wrapping or key unwrapping, depending on\n     * the value of <code>opmode</code>.\n     *\n     * <p>If this cipher requires any algorithm parameters and\n     * <code>params</code> is null, the underlying cipher implementation is\n     * supposed to generate the required parameters itself (using\n     * provider-specific default or random values) if it is being\n     * initialized for encryption or key wrapping, and raise an\n     * <code>InvalidAlgorithmParameterException</code> if it is being\n     * initialized for decryption or key unwrapping.\n     * The generated parameters can be retrieved using\n     * {@link #engineGetParameters() engineGetParameters} or\n     * {@link #engineGetIV() engineGetIV} (if the parameter is an IV).\n     *\n     * <p>If this cipher requires algorithm parameters that cannot be\n     * derived from the input parameters, and there are no reasonable\n     * provider-specific default values, initialization will\n     * necessarily fail.\n     *\n     * <p>If this cipher (including its underlying feedback or padding scheme)\n     * requires any random bytes (e.g., for parameter generation), it will get\n     * them from <code>random</code>.\n     *\n     * <p>Note that when a Cipher object is initialized, it loses all\n     * previously-acquired state. In other words, initializing a Cipher is\n     * equivalent to creating a new instance of that Cipher and initializing\n     * it.\n     *\n     * @param opmode the operation mode of this cipher (this is one of\n     * the following:\n     * <code>ENCRYPT_MODE</code>, <code>DECRYPT_MODE</code>,\n     * <code>WRAP_MODE</code> or <code>UNWRAP_MODE</code>)\n     * @param key the encryption key\n     * @param params the algorithm parameters\n     * @param random the source of randomness\n     *\n     * @exception InvalidKeyException if the given key is inappropriate for\n     * initializing this cipher\n     * @exception InvalidAlgorithmParameterException if the given algorithm\n     * parameters are inappropriate for this cipher,\n     * or if this cipher requires\n     * algorithm parameters and <code>params</code> is null.\n     * @throws UnsupportedOperationException if {@code opmode} is\n     * {@code WRAP_MODE} or {@code UNWRAP_MODE} is not implemented\n     * by the cipher.\n     ",
    "links" : [ "#engineGetParameters()", "#engineGetIV()" ]
  }, {
    "name" : "protected abstract void engineInit(int opmode, Key key, AlgorithmParameters params, SecureRandom random) throws InvalidKeyException, InvalidAlgorithmParameterException",
    "returnType" : "void",
    "comment" : "\n     * Initializes this cipher with a key, a set of\n     * algorithm parameters, and a source of randomness.\n     *\n     * <p>The cipher is initialized for one of the following four operations:\n     * encryption, decryption, key wrapping or key unwrapping, depending on\n     * the value of <code>opmode</code>.\n     *\n     * <p>If this cipher requires any algorithm parameters and\n     * <code>params</code> is null, the underlying cipher implementation is\n     * supposed to generate the required parameters itself (using\n     * provider-specific default or random values) if it is being\n     * initialized for encryption or key wrapping, and raise an\n     * <code>InvalidAlgorithmParameterException</code> if it is being\n     * initialized for decryption or key unwrapping.\n     * The generated parameters can be retrieved using\n     * {@link #engineGetParameters() engineGetParameters} or\n     * {@link #engineGetIV() engineGetIV} (if the parameter is an IV).\n     *\n     * <p>If this cipher requires algorithm parameters that cannot be\n     * derived from the input parameters, and there are no reasonable\n     * provider-specific default values, initialization will\n     * necessarily fail.\n     *\n     * <p>If this cipher (including its underlying feedback or padding scheme)\n     * requires any random bytes (e.g., for parameter generation), it will get\n     * them from <code>random</code>.\n     *\n     * <p>Note that when a Cipher object is initialized, it loses all\n     * previously-acquired state. In other words, initializing a Cipher is\n     * equivalent to creating a new instance of that Cipher and initializing\n     * it.\n     *\n     * @param opmode the operation mode of this cipher (this is one of\n     * the following:\n     * <code>ENCRYPT_MODE</code>, <code>DECRYPT_MODE</code>,\n     * <code>WRAP_MODE</code> or <code>UNWRAP_MODE</code>)\n     * @param key the encryption key\n     * @param params the algorithm parameters\n     * @param random the source of randomness\n     *\n     * @exception InvalidKeyException if the given key is inappropriate for\n     * initializing this cipher\n     * @exception InvalidAlgorithmParameterException if the given algorithm\n     * parameters are inappropriate for this cipher,\n     * or if this cipher requires\n     * algorithm parameters and <code>params</code> is null.\n     * @throws UnsupportedOperationException if {@code opmode} is\n     * {@code WRAP_MODE} or {@code UNWRAP_MODE} is not implemented\n     * by the cipher.\n     ",
    "links" : [ "#engineGetParameters()", "#engineGetIV()" ]
  }, {
    "name" : "protected abstract byte[] engineUpdate(byte[] input, int inputOffset, int inputLen)",
    "returnType" : "byte[]",
    "comment" : "\n     * Continues a multiple-part encryption or decryption operation\n     * (depending on how this cipher was initialized), processing another data\n     * part.\n     *\n     * <p>The first <code>inputLen</code> bytes in the <code>input</code>\n     * buffer, starting at <code>inputOffset</code> inclusive, are processed,\n     * and the result is stored in a new buffer.\n     *\n     * @param input the input buffer\n     * @param inputOffset the offset in <code>input</code> where the input\n     * starts\n     * @param inputLen the input length\n     *\n     * @return the new buffer with the result, or null if the underlying\n     * cipher is a block cipher and the input data is too short to result in a\n     * new block.\n     ",
    "links" : [ ]
  }, {
    "name" : "protected abstract int engineUpdate(byte[] input, int inputOffset, int inputLen, byte[] output, int outputOffset) throws ShortBufferException",
    "returnType" : "int",
    "comment" : "\n     * Continues a multiple-part encryption or decryption operation\n     * (depending on how this cipher was initialized), processing another data\n     * part.\n     *\n     * <p>The first <code>inputLen</code> bytes in the <code>input</code>\n     * buffer, starting at <code>inputOffset</code> inclusive, are processed,\n     * and the result is stored in the <code>output</code> buffer, starting at\n     * <code>outputOffset</code> inclusive.\n     *\n     * <p>If the <code>output</code> buffer is too small to hold the result,\n     * a <code>ShortBufferException</code> is thrown.\n     *\n     * @param input the input buffer\n     * @param inputOffset the offset in <code>input</code> where the input\n     * starts\n     * @param inputLen the input length\n     * @param output the buffer for the result\n     * @param outputOffset the offset in <code>output</code> where the result\n     * is stored\n     *\n     * @return the number of bytes stored in <code>output</code>\n     *\n     * @exception ShortBufferException if the given output buffer is too small\n     * to hold the result\n     ",
    "links" : [ ]
  }, {
    "name" : "protected int engineUpdate(ByteBuffer input, ByteBuffer output) throws ShortBufferException",
    "returnType" : "int",
    "comment" : "\n     * Continues a multiple-part encryption or decryption operation\n     * (depending on how this cipher was initialized), processing another data\n     * part.\n     *\n     * <p>All <code>input.remaining()</code> bytes starting at\n     * <code>input.position()</code> are processed. The result is stored\n     * in the output buffer.\n     * Upon return, the input buffer's position will be equal\n     * to its limit; its limit will not have changed. The output buffer's\n     * position will have advanced by n, where n is the value returned\n     * by this method; the output buffer's limit will not have changed.\n     *\n     * <p>If <code>output.remaining()</code> bytes are insufficient to\n     * hold the result, a <code>ShortBufferException</code> is thrown.\n     *\n     * <p>Subclasses should consider overriding this method if they can\n     * process ByteBuffers more efficiently than byte arrays.\n     *\n     * @param input the input ByteBuffer\n     * @param output the output ByteByffer\n     *\n     * @return the number of bytes stored in <code>output</code>\n     *\n     * @exception ShortBufferException if there is insufficient space in the\n     * output buffer\n     *\n     * @throws NullPointerException if either parameter is <CODE>null</CODE>\n     * @since 1.5\n     ",
    "links" : [ ]
  }, {
    "name" : "protected abstract byte[] engineDoFinal(byte[] input, int inputOffset, int inputLen) throws IllegalBlockSizeException, BadPaddingException",
    "returnType" : "byte[]",
    "comment" : "\n     * Encrypts or decrypts data in a single-part operation,\n     * or finishes a multiple-part operation.\n     * The data is encrypted or decrypted, depending on how this cipher was\n     * initialized.\n     *\n     * <p>The first <code>inputLen</code> bytes in the <code>input</code>\n     * buffer, starting at <code>inputOffset</code> inclusive, and any input\n     * bytes that may have been buffered during a previous <code>update</code>\n     * operation, are processed, with padding (if requested) being applied.\n     * If an AEAD mode such as GCM/CCM is being used, the authentication\n     * tag is appended in the case of encryption, or verified in the\n     * case of decryption.\n     * The result is stored in a new buffer.\n     *\n     * <p>Upon finishing, this method resets this cipher object to the state\n     * it was in when previously initialized via a call to\n     * <code>engineInit</code>.\n     * That is, the object is reset and available to encrypt or decrypt\n     * (depending on the operation mode that was specified in the call to\n     * <code>engineInit</code>) more data.\n     *\n     * <p>Note: if any exception is thrown, this cipher object may need to\n     * be reset before it can be used again.\n     *\n     * @param input the input buffer\n     * @param inputOffset the offset in <code>input</code> where the input\n     * starts\n     * @param inputLen the input length\n     *\n     * @return the new buffer with the result\n     *\n     * @exception IllegalBlockSizeException if this cipher is a block cipher,\n     * no padding has been requested (only in encryption mode), and the total\n     * input length of the data processed by this cipher is not a multiple of\n     * block size; or if this encryption algorithm is unable to\n     * process the input data provided.\n     * @exception BadPaddingException if this cipher is in decryption mode,\n     * and (un)padding has been requested, but the decrypted data is not\n     * bounded by the appropriate padding bytes\n     * @exception AEADBadTagException if this cipher is decrypting in an\n     * AEAD mode (such as GCM/CCM), and the received authentication tag\n     * does not match the calculated value\n     ",
    "links" : [ ]
  }, {
    "name" : "protected abstract int engineDoFinal(byte[] input, int inputOffset, int inputLen, byte[] output, int outputOffset) throws ShortBufferException, IllegalBlockSizeException, BadPaddingException",
    "returnType" : "int",
    "comment" : "\n     * Encrypts or decrypts data in a single-part operation,\n     * or finishes a multiple-part operation.\n     * The data is encrypted or decrypted, depending on how this cipher was\n     * initialized.\n     *\n     * <p>The first <code>inputLen</code> bytes in the <code>input</code>\n     * buffer, starting at <code>inputOffset</code> inclusive, and any input\n     * bytes that may have been buffered during a previous <code>update</code>\n     * operation, are processed, with padding (if requested) being applied.\n     * If an AEAD mode such as GCM/CCM is being used, the authentication\n     * tag is appended in the case of encryption, or verified in the\n     * case of decryption.\n     * The result is stored in the <code>output</code> buffer, starting at\n     * <code>outputOffset</code> inclusive.\n     *\n     * <p>If the <code>output</code> buffer is too small to hold the result,\n     * a <code>ShortBufferException</code> is thrown.\n     *\n     * <p>Upon finishing, this method resets this cipher object to the state\n     * it was in when previously initialized via a call to\n     * <code>engineInit</code>.\n     * That is, the object is reset and available to encrypt or decrypt\n     * (depending on the operation mode that was specified in the call to\n     * <code>engineInit</code>) more data.\n     *\n     * <p>Note: if any exception is thrown, this cipher object may need to\n     * be reset before it can be used again.\n     *\n     * @param input the input buffer\n     * @param inputOffset the offset in <code>input</code> where the input\n     * starts\n     * @param inputLen the input length\n     * @param output the buffer for the result\n     * @param outputOffset the offset in <code>output</code> where the result\n     * is stored\n     *\n     * @return the number of bytes stored in <code>output</code>\n     *\n     * @exception IllegalBlockSizeException if this cipher is a block cipher,\n     * no padding has been requested (only in encryption mode), and the total\n     * input length of the data processed by this cipher is not a multiple of\n     * block size; or if this encryption algorithm is unable to\n     * process the input data provided.\n     * @exception ShortBufferException if the given output buffer is too small\n     * to hold the result\n     * @exception BadPaddingException if this cipher is in decryption mode,\n     * and (un)padding has been requested, but the decrypted data is not\n     * bounded by the appropriate padding bytes\n     * @exception AEADBadTagException if this cipher is decrypting in an\n     * AEAD mode (such as GCM/CCM), and the received authentication tag\n     * does not match the calculated value\n     ",
    "links" : [ ]
  }, {
    "name" : "protected int engineDoFinal(ByteBuffer input, ByteBuffer output) throws ShortBufferException, IllegalBlockSizeException, BadPaddingException",
    "returnType" : "int",
    "comment" : "\n     * Encrypts or decrypts data in a single-part operation,\n     * or finishes a multiple-part operation.\n     * The data is encrypted or decrypted, depending on how this cipher was\n     * initialized.\n     *\n     * <p>All <code>input.remaining()</code> bytes starting at\n     * <code>input.position()</code> are processed.\n     * If an AEAD mode such as GCM/CCM is being used, the authentication\n     * tag is appended in the case of encryption, or verified in the\n     * case of decryption.\n     * The result is stored in the output buffer.\n     * Upon return, the input buffer's position will be equal\n     * to its limit; its limit will not have changed. The output buffer's\n     * position will have advanced by n, where n is the value returned\n     * by this method; the output buffer's limit will not have changed.\n     *\n     * <p>If <code>output.remaining()</code> bytes are insufficient to\n     * hold the result, a <code>ShortBufferException</code> is thrown.\n     *\n     * <p>Upon finishing, this method resets this cipher object to the state\n     * it was in when previously initialized via a call to\n     * <code>engineInit</code>.\n     * That is, the object is reset and available to encrypt or decrypt\n     * (depending on the operation mode that was specified in the call to\n     * <code>engineInit</code>) more data.\n     *\n     * <p>Note: if any exception is thrown, this cipher object may need to\n     * be reset before it can be used again.\n     *\n     * <p>Subclasses should consider overriding this method if they can\n     * process ByteBuffers more efficiently than byte arrays.\n     *\n     * @param input the input ByteBuffer\n     * @param output the output ByteByffer\n     *\n     * @return the number of bytes stored in <code>output</code>\n     *\n     * @exception IllegalBlockSizeException if this cipher is a block cipher,\n     * no padding has been requested (only in encryption mode), and the total\n     * input length of the data processed by this cipher is not a multiple of\n     * block size; or if this encryption algorithm is unable to\n     * process the input data provided.\n     * @exception ShortBufferException if there is insufficient space in the\n     * output buffer\n     * @exception BadPaddingException if this cipher is in decryption mode,\n     * and (un)padding has been requested, but the decrypted data is not\n     * bounded by the appropriate padding bytes\n     * @exception AEADBadTagException if this cipher is decrypting in an\n     * AEAD mode (such as GCM/CCM), and the received authentication tag\n     * does not match the calculated value\n     *\n     * @throws NullPointerException if either parameter is <CODE>null</CODE>\n     * @since 1.5\n     ",
    "links" : [ ]
  }, {
    "name" : " static int getTempArraySize(int totalSize)",
    "returnType" : "int",
    "comment" : " integrated and promoted",
    "links" : [ ]
  }, {
    "name" : "private int bufferCrypt(ByteBuffer input, ByteBuffer output, boolean isUpdate) throws ShortBufferException, IllegalBlockSizeException, BadPaddingException",
    "returnType" : "int",
    "comment" : "\n     * Implementation for encryption using ByteBuffers. Used for both\n     * engineUpdate() and engineDoFinal().\n     ",
    "links" : [ ]
  }, {
    "name" : "protected byte[] engineWrap(Key key) throws IllegalBlockSizeException, InvalidKeyException",
    "returnType" : "byte[]",
    "comment" : "\n     * Wrap a key.\n     *\n     * <p>This concrete method has been added to this previously-defined\n     * abstract class. (For backwards compatibility, it cannot be abstract.)\n     * It may be overridden by a provider to wrap a key.\n     * Such an override is expected to throw an IllegalBlockSizeException or\n     * InvalidKeyException (under the specified circumstances),\n     * if the given key cannot be wrapped.\n     * If this method is not overridden, it always throws an\n     * UnsupportedOperationException.\n     *\n     * @param key the key to be wrapped.\n     *\n     * @return the wrapped key.\n     *\n     * @exception IllegalBlockSizeException if this cipher is a block cipher,\n     * no padding has been requested, and the length of the encoding of the\n     * key to be wrapped is not a multiple of the block size.\n     *\n     * @exception InvalidKeyException if it is impossible or unsafe to\n     * wrap the key with this cipher (e.g., a hardware protected key is\n     * being passed to a software-only cipher).\n     *\n     * @throws UnsupportedOperationException if this method is not supported.\n     ",
    "links" : [ ]
  }, {
    "name" : "protected Key engineUnwrap(byte[] wrappedKey, String wrappedKeyAlgorithm, int wrappedKeyType) throws InvalidKeyException, NoSuchAlgorithmException",
    "returnType" : "Key",
    "comment" : "\n     * Unwrap a previously wrapped key.\n     *\n     * <p>This concrete method has been added to this previously-defined\n     * abstract class. (For backwards compatibility, it cannot be abstract.)\n     * It may be overridden by a provider to unwrap a previously wrapped key.\n     * Such an override is expected to throw an InvalidKeyException if\n     * the given wrapped key cannot be unwrapped.\n     * If this method is not overridden, it always throws an\n     * UnsupportedOperationException.\n     *\n     * @param wrappedKey the key to be unwrapped.\n     *\n     * @param wrappedKeyAlgorithm the algorithm associated with the wrapped\n     * key.\n     *\n     * @param wrappedKeyType the type of the wrapped key. This is one of\n     * <code>SECRET_KEY</code>, <code>PRIVATE_KEY</code>, or\n     * <code>PUBLIC_KEY</code>.\n     *\n     * @return the unwrapped key.\n     *\n     * @exception NoSuchAlgorithmException if no installed providers\n     * can create keys of type <code>wrappedKeyType</code> for the\n     * <code>wrappedKeyAlgorithm</code>.\n     *\n     * @exception InvalidKeyException if <code>wrappedKey</code> does not\n     * represent a wrapped key of type <code>wrappedKeyType</code> for\n     * the <code>wrappedKeyAlgorithm</code>.\n     *\n     * @throws UnsupportedOperationException if this method is not supported.\n     ",
    "links" : [ ]
  }, {
    "name" : "protected int engineGetKeySize(Key key) throws InvalidKeyException",
    "returnType" : "int",
    "comment" : "\n     * Returns the key size of the given key object in bits.\n     * <p>This concrete method has been added to this previously-defined\n     * abstract class. It throws an <code>UnsupportedOperationException</code>\n     * if it is not overridden by the provider.\n     *\n     * @param key the key object.\n     *\n     * @return the key size of the given key object.\n     *\n     * @exception InvalidKeyException if <code>key</code> is invalid.\n     ",
    "links" : [ ]
  }, {
    "name" : "protected void engineUpdateAAD(byte[] src, int offset, int len)",
    "returnType" : "void",
    "comment" : "\n     * Continues a multi-part update of the Additional Authentication\n     * Data (AAD), using a subset of the provided buffer.\n     * <p>\n     * Calls to this method provide AAD to the cipher when operating in\n     * modes such as AEAD (GCM/CCM).  If this cipher is operating in\n     * either GCM or CCM mode, all AAD must be supplied before beginning\n     * operations on the ciphertext (via the {@code update} and {@code\n     * doFinal} methods).\n     *\n     * @param src the buffer containing the AAD\n     * @param offset the offset in {@code src} where the AAD input starts\n     * @param len the number of AAD bytes\n     *\n     * @throws IllegalStateException if this cipher is in a wrong state\n     * (e.g., has not been initialized), does not accept AAD, or if\n     * operating in either GCM or CCM mode and one of the {@code update}\n     * methods has already been called for the active\n     * encryption/decryption operation\n     * @throws UnsupportedOperationException if this method\n     * has not been overridden by an implementation\n     *\n     * @since 1.7\n     ",
    "links" : [ ]
  }, {
    "name" : "protected void engineUpdateAAD(ByteBuffer src)",
    "returnType" : "void",
    "comment" : "\n     * Continues a multi-part update of the Additional Authentication\n     * Data (AAD).\n     * <p>\n     * Calls to this method provide AAD to the cipher when operating in\n     * modes such as AEAD (GCM/CCM).  If this cipher is operating in\n     * either GCM or CCM mode, all AAD must be supplied before beginning\n     * operations on the ciphertext (via the {@code update} and {@code\n     * doFinal} methods).\n     * <p>\n     * All {@code src.remaining()} bytes starting at\n     * {@code src.position()} are processed.\n     * Upon return, the input buffer's position will be equal\n     * to its limit; its limit will not have changed.\n     *\n     * @param src the buffer containing the AAD\n     *\n     * @throws IllegalStateException if this cipher is in a wrong state\n     * (e.g., has not been initialized), does not accept AAD, or if\n     * operating in either GCM or CCM mode and one of the {@code update}\n     * methods has already been called for the active\n     * encryption/decryption operation\n     * @throws UnsupportedOperationException if this method\n     * has not been overridden by an implementation\n     *\n     * @since 1.7\n     ",
    "links" : [ ]
  } ],
  "methodNames" : [ "protected abstract void engineSetMode(String mode) throws NoSuchAlgorithmException", "protected abstract void engineSetPadding(String padding) throws NoSuchPaddingException", "protected abstract int engineGetBlockSize()", "protected abstract int engineGetOutputSize(int inputLen)", "protected abstract byte[] engineGetIV()", "protected abstract AlgorithmParameters engineGetParameters()", "protected abstract void engineInit(int opmode, Key key, SecureRandom random) throws InvalidKeyException", "protected abstract void engineInit(int opmode, Key key, AlgorithmParameterSpec params, SecureRandom random) throws InvalidKeyException, InvalidAlgorithmParameterException", "protected abstract void engineInit(int opmode, Key key, AlgorithmParameters params, SecureRandom random) throws InvalidKeyException, InvalidAlgorithmParameterException", "protected abstract byte[] engineUpdate(byte[] input, int inputOffset, int inputLen)", "protected abstract int engineUpdate(byte[] input, int inputOffset, int inputLen, byte[] output, int outputOffset) throws ShortBufferException", "protected int engineUpdate(ByteBuffer input, ByteBuffer output) throws ShortBufferException", "protected abstract byte[] engineDoFinal(byte[] input, int inputOffset, int inputLen) throws IllegalBlockSizeException, BadPaddingException", "protected abstract int engineDoFinal(byte[] input, int inputOffset, int inputLen, byte[] output, int outputOffset) throws ShortBufferException, IllegalBlockSizeException, BadPaddingException", "protected int engineDoFinal(ByteBuffer input, ByteBuffer output) throws ShortBufferException, IllegalBlockSizeException, BadPaddingException", " static int getTempArraySize(int totalSize)", "private int bufferCrypt(ByteBuffer input, ByteBuffer output, boolean isUpdate) throws ShortBufferException, IllegalBlockSizeException, BadPaddingException", "protected byte[] engineWrap(Key key) throws IllegalBlockSizeException, InvalidKeyException", "protected Key engineUnwrap(byte[] wrappedKey, String wrappedKeyAlgorithm, int wrappedKeyType) throws InvalidKeyException, NoSuchAlgorithmException", "protected int engineGetKeySize(Key key) throws InvalidKeyException", "protected void engineUpdateAAD(byte[] src, int offset, int len)", "protected void engineUpdateAAD(ByteBuffer src)" ],
  "variableNames" : [ ]
}