{
  "filePath" : "/home/maryam/clearblue/files/android-source-35/android/os/IpcDataCache.java",
  "packageName" : "android.os",
  "className" : "IpcDataCache",
  "comment" : "\n * LRU cache that's invalidated when an opaque value in a property changes. Self-synchronizing,\n * but doesn't hold a lock across data fetches on query misses.\n *\n * The intended use case is caching frequently-read, seldom-changed information normally retrieved\n * across interprocess communication. Imagine that you've written a user birthday information\n * daemon called \"birthdayd\" that exposes an {@code IUserBirthdayService} interface over\n * binder. That binder interface looks something like this:\n *\n * <pre>\n * parcelable Birthday {\n *   int month;\n *   int day;\n * }\n * interface IUserBirthdayService {\n *   Birthday getUserBirthday(int userId);\n * }\n * </pre>\n *\n * Suppose the service implementation itself looks like this...\n *\n * <pre>\n * public class UserBirthdayServiceImpl implements IUserBirthdayService {\n *   private final HashMap&lt;Integer, Birthday%&gt; mUidToBirthday;\n *   {@literal @}Override\n *   public synchronized Birthday getUserBirthday(int userId) {\n *     return mUidToBirthday.get(userId);\n *   }\n *   private synchronized void updateBirthdays(Map&lt;Integer, Birthday%&gt; uidToBirthday) {\n *     mUidToBirthday.clear();\n *     mUidToBirthday.putAll(uidToBirthday);\n *   }\n * }\n * </pre>\n *\n * ... and we have a client in frameworks (loaded into every app process) that looks like this:\n *\n * <pre>\n * public class ActivityThread {\n *   ...\n *   public Birthday getUserBirthday(int userId) {\n *     return GetService(\"birthdayd\").getUserBirthday(userId);\n *   }\n *   ...\n * }\n * </pre>\n *\n * With this code, every time an app calls {@code getUserBirthday(uid)}, we make a binder call to\n * the birthdayd process and consult its database of birthdays. If we query user birthdays\n * frequently, we do a lot of work that we don't have to do, since user birthdays change\n * infrequently.\n *\n * IpcDataCache is part of a pattern for optimizing this kind of information-querying code. Using\n * {@code IpcDataCache}, you'd write the client this way:\n *\n * <pre>\n * public class ActivityThread {\n *   ...\n *   private final IpcDataCache.QueryHandler&lt;Integer, Birthday&gt; mBirthdayQuery =\n *       new IpcDataCache.QueryHandler&lt;Integer, Birthday&gt;() {\n *           {@literal @}Override\n *           public Birthday apply(Integer) {\n *              return GetService(\"birthdayd\").getUserBirthday(userId);\n *           }\n *       };\n *   private static final int BDAY_CACHE_MAX = 8;  // Maximum birthdays to cache\n *   private static final String BDAY_API = \"getUserBirthday\";\n *   private final IpcDataCache&lt;Integer, Birthday%&gt; mBirthdayCache = new\n *     IpcDataCache&lt;Integer, Birthday%&gt;(\n *             BDAY_CACHE_MAX, MODULE_SYSTEM, BDAY_API,  BDAY_API, mBirthdayQuery);\n *\n *   public void disableUserBirthdayCache() {\n *     mBirthdayCache.disableForCurrentProcess();\n *   }\n *   public void invalidateUserBirthdayCache() {\n *     mBirthdayCache.invalidateCache();\n *   }\n *   public Birthday getUserBirthday(int userId) {\n *     return mBirthdayCache.query(userId);\n *   }\n *   ...\n * }\n * </pre>\n *\n * With this cache, clients perform a binder call to birthdayd if asking for a user's birthday\n * for the first time; on subsequent queries, we return the already-known Birthday object.\n *\n * The second parameter to the IpcDataCache constructor is a string that identifies the \"module\"\n * that owns the cache. There are some well-known modules (such as {@code MODULE_SYSTEM} but any\n * string is permitted.  The third parameters is the name of the API being cached; this, too, can\n * any value.  The fourth is the name of the cache.  The cache is usually named after th API.\n * Some things you must know about the three strings:\n * <list>\n * <ul> The system property that controls the cache is named {@code cache_key.<module>.<api>}.\n * Usually, the SELinux rules permit a process to write a system property (and therefore\n * invalidate a cache) based on the wildcard {@code cache_key.<module>.*}.  This means that\n * although the cache can be constructed with any module string, whatever string is chosen must be\n * consistent with the SELinux configuration.\n * <ul> The API name can be any string of alphanumeric characters.  All caches with the same API\n * are invalidated at the same time.  If a server supports several caches and all are invalidated\n * in common, then it is most efficient to assign the same API string to every cache.\n * <ul> The cache name can be any string.  In debug output, the name is used to distiguish between\n * caches with the same API name.  The cache name is also used when disabling caches in the\n * current process.  So, invalidation is based on the module+api but disabling (which is generally\n * a once-per-process operation) is based on the cache name.\n * </list>\n *\n * User birthdays do occasionally change, so we have to modify the server to invalidate this\n * cache when necessary. That invalidation code looks like this:\n *\n * <pre>\n * public class UserBirthdayServiceImpl {\n *   ...\n *   public UserBirthdayServiceImpl() {\n *     ...\n *     ActivityThread.currentActivityThread().disableUserBirthdayCache();\n *     ActivityThread.currentActivityThread().invalidateUserBirthdayCache();\n *   }\n *\n *   private synchronized void updateBirthdays(Map&lt;Integer, Birthday%&gt; uidToBirthday) {\n *     mUidToBirthday.clear();\n *     mUidToBirthday.putAll(uidToBirthday);\n *     ActivityThread.currentActivityThread().invalidateUserBirthdayCache();\n *   }\n *   ...\n * }\n * </pre>\n *\n * The call to {@code IpcDataCache.invalidateCache()} guarantees that all clients will re-fetch\n * birthdays from binder during consequent calls to\n * {@code ActivityThread.getUserBirthday()}. Because the invalidate call happens with the lock\n * held, we maintain consistency between different client views of the birthday state. The use of\n * IpcDataCache in this idiomatic way introduces no new race conditions.\n *\n * IpcDataCache has a few other features for doing things like incremental enhancement of cached\n * values and invalidation of multiple caches (that all share the same property key) at once.\n *\n * {@code BDAY_CACHE_KEY} is the name of a property that we set to an opaque unique value each\n * time we update the cache. SELinux configuration must allow everyone to read this property\n * and it must allow any process that needs to invalidate the cache (here, birthdayd) to write\n * the property. (These properties conventionally begin with the \"cache_key.\" prefix.)\n *\n * The {@code UserBirthdayServiceImpl} constructor calls {@code disableUserBirthdayCache()} so\n * that calls to {@code getUserBirthday} from inside birthdayd don't go through the cache. In this\n * local case, there's no IPC, so use of the cache is (depending on exact circumstance)\n * unnecessary.\n *\n * There may be queries for which it is more efficient to bypass the cache than to cache the\n * result.  This would be true, for example, if some queries would require frequent cache\n * invalidation while other queries require infrequent invalidation.  To expand on the birthday\n * example, suppose that there is a userId that signifies \"the next birthday\".  When passed this\n * userId, the server returns the next birthday among all users - this value changes as time\n * advances.  The userId value can be cached, but the cache must be invalidated whenever a\n * birthday occurs, and this invalidates all birthdays.  If there is a large number of users,\n * invalidation will happen so often that the cache provides no value.\n *\n * The class provides a bypass mechanism to handle this situation.\n * <pre>\n * public class ActivityThread {\n *   ...\n *   private final IpcDataCache.QueryHandler&lt;Integer, Birthday&gt; mBirthdayQuery =\n *       new IpcDataCache.QueryHandler&lt;Integer, Birthday&gt;() {\n *           {@literal @}Override\n *           public Birthday apply(Integer) {\n *              return GetService(\"birthdayd\").getUserBirthday(userId);\n *           }\n *           {@literal @}Override\n *           public boolean shouldBypassQuery(Integer userId) {\n *               return userId == NEXT_BIRTHDAY;\n *           }\n *       };\n *   ...\n * }\n * </pre>\n *\n * If the {@code shouldBypassQuery()} method returns true then the cache is not used for that\n * particular query.  The {@code shouldBypassQuery()} method is not abstract and the default\n * implementation returns false.\n *\n * For security, there is a allowlist of processes that are allowed to invalidate a cache.  The\n * allowlist includes normal runtime processes but does not include test processes.  Test\n * processes must call {@code IpcDataCache.disableForTestMode()} to disable all cache activity in\n * that process.\n *\n * Caching can be disabled completely by initializing {@code sEnabled} to false and rebuilding.\n *\n * To test a binder cache, create one or more tests that exercise the binder method.  This should\n * be done twice: once with production code and once with a special image that sets {@code DEBUG}\n * and {@code VERIFY} true.  In the latter case, verify that no cache inconsistencies are\n * reported.  If a cache inconsistency is reported, however, it might be a false positive.  This\n * happens if the server side data can be read and written non-atomically with respect to cache\n * invalidation.\n *\n * @param <Query> The class used to index cache entries: must be hashable and comparable\n * @param <Result> The class holding cache entries; use a boxed primitive if possible\n * @hide\n ",
  "links" : [ ],
  "variables" : [ {
    "name" : "MODULE_TEST",
    "type" : "String",
    "comment" : "\n     * The module used for unit tests and cts tests.  It is expected that no process in\n     * the system has permissions to write properties with this module.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "MODULE_SYSTEM",
    "type" : "String",
    "comment" : "\n     * The module used for system server/framework caches.  This is not visible outside\n     * the system processes.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "MODULE_BLUETOOTH",
    "type" : "String",
    "comment" : "\n     * The module used for bluetooth caches.\n     * @hide\n     ",
    "links" : [ ]
  } ],
  "methods" : [ {
    "name" : "public void disableForCurrentProcess()",
    "returnType" : "void",
    "comment" : "\n     * {@inheritDoc}\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public static void disableForCurrentProcess(@NonNull String cacheName)",
    "returnType" : "void",
    "comment" : "\n     * {@inheritDoc}\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public Result query(@NonNull Query query)",
    "returnType" : "Result",
    "comment" : "\n     * {@inheritDoc}\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public void invalidateCache()",
    "returnType" : "void",
    "comment" : "\n     * {@inheritDoc}\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public static void invalidateCache(@NonNull @IpcDataCacheModule String module, @NonNull String api)",
    "returnType" : "void",
    "comment" : "\n     * Invalidate caches in all processes that are keyed for the module and api.\n     * @hide\n     ",
    "links" : [ ]
  } ],
  "methodNames" : [ "public void disableForCurrentProcess()", "public static void disableForCurrentProcess(@NonNull String cacheName)", "public Result query(@NonNull Query query)", "public void invalidateCache()", "public static void invalidateCache(@NonNull @IpcDataCacheModule String module, @NonNull String api)" ],
  "variableNames" : [ "MODULE_TEST", "MODULE_SYSTEM", "MODULE_BLUETOOTH" ]
}