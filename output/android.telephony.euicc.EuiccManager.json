{
  "filePath" : "/home/maryam/clearblue/files/android-source-35/android/telephony/euicc/EuiccManager.java",
  "packageName" : "android.telephony.euicc",
  "className" : "EuiccManager",
  "comment" : "\n * EuiccManager is the application interface to eUICCs, or eSIMs/embedded SIMs.\n *\n * <p>You do not instantiate this class directly; instead, you retrieve an instance through\n * {@link Context#getSystemService(String)} and {@link Context#EUICC_SERVICE}. This instance will be\n * created using the default eUICC.\n *\n * <p>On a device with multiple eUICCs, you may want to create multiple EuiccManagers. To do this\n * you can call {@link #createForCardId}.\n *\n * <p>See {@link #isEnabled} before attempting to use these APIs.\n ",
  "links" : [ "android.content.Context#getSystemService(String)", "#createForCardId", "android.content.Context#EUICC_SERVICE", "#isEnabled" ],
  "variables" : [ {
    "name" : "TAG",
    "type" : "String",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "ACTION_MANAGE_EMBEDDED_SUBSCRIPTIONS",
    "type" : "String",
    "comment" : "\n     * Intent action to launch the embedded SIM (eUICC) management settings screen.\n     *\n     * <p>This screen shows a list of embedded profiles and offers the user the ability to switch\n     * between them, download new profiles, and delete unused profiles.\n     *\n     * <p>The activity will immediately finish with {@link android.app.Activity#RESULT_CANCELED} if\n     * {@link #isEnabled} is false.\n     *\n     * This is ued by non-LPA app to bring up LUI.\n     ",
    "links" : [ "android.app.Activity#RESULT_CANCELED", "#isEnabled" ]
  }, {
    "name" : "ACTION_TRANSFER_EMBEDDED_SUBSCRIPTIONS",
    "type" : "String",
    "comment" : "\n     * Intent action to transfer an embedded subscriptions.\n     *\n     * <p> Action sent by apps (such as the Settings app) to the Telephony framework to transfer an\n     * embedded subscription.\n     *\n     * <p> Requires that the calling app has the\n     * {@code android.Manifest.permission#MODIFY_PHONE_STATE} permission.\n     *\n     * <p>The activity will immediately finish with {@link android.app.Activity#RESULT_CANCELED} if\n     * {@link #isEnabled} is false.\n     *\n     * @hide\n     ",
    "links" : [ "android.app.Activity#RESULT_CANCELED", "#isEnabled" ]
  }, {
    "name" : "ACTION_CONVERT_TO_EMBEDDED_SUBSCRIPTION",
    "type" : "String",
    "comment" : "\n     * Intent action to convert the physical subscription to an embedded subscription.\n     *\n     * <p> Action sent by apps (such as the Settings app) to the Telephony framework to convert\n     * physical sim to embedded sim.\n     *\n     * <p> Requires that the calling app has the\n     * {@code android.Manifest.permission#MODIFY_PHONE_STATE} permission.\n     *\n     * <p>The activity will immediately finish with {@link android.app.Activity#RESULT_CANCELED} if\n     * {@link #isEnabled} is false.\n     *\n     * @hide\n     ",
    "links" : [ "android.app.Activity#RESULT_CANCELED", "#isEnabled" ]
  }, {
    "name" : "ACTION_OTA_STATUS_CHANGED",
    "type" : "String",
    "comment" : "\n     * Broadcast Action: The eUICC OTA status is changed.\n     * <p class=\"note\">\n     * Requires the {@link android.Manifest.permission#WRITE_EMBEDDED_SUBSCRIPTIONS} permission.\n     *\n     * <p class=\"note\">This is a protected intent that can only be sent\n     * by the system.\n     *\n     * @hide\n     ",
    "links" : [ "android.Manifest.permission#WRITE_EMBEDDED_SUBSCRIPTIONS" ]
  }, {
    "name" : "ACTION_NOTIFY_CARRIER_SETUP_INCOMPLETE",
    "type" : "String",
    "comment" : "\n     * Broadcast Action: The action sent to carrier app so it knows the carrier setup is not\n     * completed.\n     ",
    "links" : [ ]
  }, {
    "name" : "ACTION_PROVISION_EMBEDDED_SUBSCRIPTION",
    "type" : "String",
    "comment" : "\n     * Intent action to provision an embedded subscription.\n     *\n     * <p>May be called during device provisioning to launch a screen to perform embedded SIM\n     * provisioning, e.g. if no physical SIM is present and the user elects to configure their\n     * embedded SIM.\n     *\n     * <p>The activity will immediately finish with {@link android.app.Activity#RESULT_CANCELED} if\n     * {@link #isEnabled} is false.\n     *\n     * @hide\n     ",
    "links" : [ "android.app.Activity#RESULT_CANCELED", "#isEnabled" ]
  }, {
    "name" : "ACTION_RESOLVE_ERROR",
    "type" : "String",
    "comment" : "\n     * Intent action to handle a resolvable error.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "ACTION_TOGGLE_SUBSCRIPTION_PRIVILEGED",
    "type" : "String",
    "comment" : "\n     * Intent action sent by system apps (such as the Settings app) to the Telephony framework to\n     * enable or disable a subscription. Must be accompanied with {@link #EXTRA_SUBSCRIPTION_ID} and\n     * {@link #EXTRA_ENABLE_SUBSCRIPTION}, and optionally {@link #EXTRA_FROM_SUBSCRIPTION_ID}.\n     *\n     * <p>Requires the caller to be a privileged process with the\n     * {@link android.permission#CALL_PRIVILEGED} permission for the intent to reach the Telephony\n     * stack.\n     *\n     * <p>Unlike {@link #switchToSubscription(int, PendingIntent)}, using this action allows the\n     * underlying eUICC service (i.e. the LPA app) to control the UI experience during this\n     * operation. The action is received by the Telephony framework, which in turn selects and\n     * launches an appropriate LPA activity to present UI to the user. For example, the activity may\n     * show a confirmation dialog, a progress dialog, or an error dialog when necessary.\n     *\n     * <p>The launched activity will immediately finish with\n     * {@link android.app.Activity#RESULT_CANCELED} if {@link #isEnabled} is false.\n     *\n     * @hide\n     ",
    "links" : [ "android.app.Activity#RESULT_CANCELED", "#EXTRA_FROM_SUBSCRIPTION_ID", "android.permission#CALL_PRIVILEGED", "#EXTRA_SUBSCRIPTION_ID", "#EXTRA_ENABLE_SUBSCRIPTION", "#switchToSubscription(int", "#isEnabled" ]
  }, {
    "name" : "ACTION_DELETE_SUBSCRIPTION_PRIVILEGED",
    "type" : "String",
    "comment" : "\n     * Intent action sent by system apps (such as the Settings app) to the Telephony framework to\n     * delete a subscription. Must be accompanied with {@link #EXTRA_SUBSCRIPTION_ID}.\n     *\n     * <p>Requires the caller to be a privileged process with the\n     * {@link android.permission#CALL_PRIVILEGED} permission for the intent to reach the Telephony\n     * stack.\n     *\n     * <p>Unlike {@link #deleteSubscription(int, PendingIntent)}, using this action allows the\n     * underlying eUICC service (i.e. the LPA app) to control the UI experience during this\n     * operation. The action is received by the Telephony framework, which in turn selects and\n     * launches an appropriate LPA activity to present UI to the user. For example, the activity may\n     * show a confirmation dialog, a progress dialog, or an error dialog when necessary.\n     *\n     * <p>The launched activity will immediately finish with\n     * {@link android.app.Activity#RESULT_CANCELED} if {@link #isEnabled} is false.\n     *\n     * @hide\n     ",
    "links" : [ "android.app.Activity#RESULT_CANCELED", "android.permission#CALL_PRIVILEGED", "#EXTRA_SUBSCRIPTION_ID", "#deleteSubscription(int", "#isEnabled" ]
  }, {
    "name" : "ACTION_RENAME_SUBSCRIPTION_PRIVILEGED",
    "type" : "String",
    "comment" : "\n     * Intent action sent by system apps (such as the Settings app) to the Telephony framework to\n     * rename a subscription. Must be accompanied with {@link #EXTRA_SUBSCRIPTION_ID} and\n     * {@link #EXTRA_SUBSCRIPTION_NICKNAME}.\n     *\n     * <p>Requires the caller to be a privileged process with the\n     * {@link android.permission#CALL_PRIVILEGED} permission for the intent to reach the Telephony\n     * stack.\n     *\n     * <p>Unlike {@link #updateSubscriptionNickname(int, String, PendingIntent)}, using this action\n     * allows the the underlying eUICC service (i.e. the LPA app) to control the UI experience\n     * during this operation. The action is received by the Telephony framework, which in turn\n     * selects and launches an appropriate LPA activity to present UI to the user. For example, the\n     * activity may show a confirmation dialog, a progress dialog, or an error dialog when\n     * necessary.\n     *\n     * <p>The launched activity will immediately finish with\n     * {@link android.app.Activity#RESULT_CANCELED} if {@link #isEnabled} is false.\n     *\n     * @hide\n     ",
    "links" : [ "android.app.Activity#RESULT_CANCELED", "android.permission#CALL_PRIVILEGED", "#EXTRA_SUBSCRIPTION_ID", "#EXTRA_SUBSCRIPTION_NICKNAME", "#updateSubscriptionNickname(int", "#isEnabled" ]
  }, {
    "name" : "ACTION_START_EUICC_ACTIVATION",
    "type" : "String",
    "comment" : "\n     * Intent action sent by a carrier app to launch the eSIM activation flow provided by the LPA UI\n     * (LUI). The carrier app must send this intent with one of the following:\n     *\n     * <p>{@link #EXTRA_USE_QR_SCANNER} not set or set to false: The LPA should try to get an\n     * activation code from the carrier app by binding to the carrier app service implementing\n     * {@code android.service.euicc.EuiccService#ACTION_BIND_CARRIER_PROVISIONING_SERVICE}.\n     * <p>{@link #EXTRA_USE_QR_SCANNER} set to true: The LPA should launch a QR scanner for the user\n     * to scan an eSIM profile QR code.\n     *\n     * <p>Upon completion, the LPA should return one of the following results to the carrier app:\n     *\n     * <p>{@code Activity.RESULT_OK}: The LPA has succeeded in downloading the new eSIM profile.\n     * <p>{@code Activity.RESULT_CANCELED}: The carrier app should treat this as if the user pressed\n     * the back button.\n     * <p>Anything else: The carrier app should treat this as an error.\n     *\n     * <p>LPA needs to check if caller's package name is allowed to perform this action.\n     *",
    "links" : [ "#EXTRA_USE_QR_SCANNER" ]
  }, {
    "name" : "EMBEDDED_SUBSCRIPTION_RESULT_OK",
    "type" : "int",
    "comment" : "\n     * Result code for an operation indicating that the operation succeeded.\n     ",
    "links" : [ ]
  }, {
    "name" : "EMBEDDED_SUBSCRIPTION_RESULT_RESOLVABLE_ERROR",
    "type" : "int",
    "comment" : "\n     * Result code for an operation indicating that the user must take some action before the\n     * operation can continue.\n     *\n     * @see #startResolutionActivity\n     ",
    "links" : [ ]
  }, {
    "name" : "EMBEDDED_SUBSCRIPTION_RESULT_ERROR",
    "type" : "int",
    "comment" : "\n     * Result code for an operation indicating that an unresolvable error occurred.\n     *\n     * {@link #EXTRA_EMBEDDED_SUBSCRIPTION_DETAILED_CODE} will be populated with a detailed error\n     * code for logging/debugging purposes only.\n     ",
    "links" : [ "#EXTRA_EMBEDDED_SUBSCRIPTION_DETAILED_CODE" ]
  }, {
    "name" : "EXTRA_ACTIVATION_TYPE",
    "type" : "String",
    "comment" : "\n     * Key for an extra set on the {@link #ACTION_PROVISION_EMBEDDED_SUBSCRIPTION} intent for which\n     * kind of activation flow will be evolved. (see {@code EUICC_ACTIVATION_})\n     *\n     * @hide\n     ",
    "links" : [ "#ACTION_PROVISION_EMBEDDED_SUBSCRIPTION" ]
  }, {
    "name" : "EXTRA_EMBEDDED_SUBSCRIPTION_DETAILED_CODE",
    "type" : "String",
    "comment" : "\n     * Key for an extra set on {@link PendingIntent} result callbacks providing a detailed result\n     * code.\n     *\n     * <p>The value of this key is an integer and contains two portions. The first byte is\n     * OperationCode and the reaming three bytes is the ErrorCode.\n     *\n     * OperationCode is the first byte of the result code and is a categorization which defines what\n     * type of operation took place when an error occurred. e.g {@link #OPERATION_DOWNLOAD} means\n     * the error is related to download.Since the OperationCode only uses at most one byte, the\n     * maximum allowed quantity is 255(0xFF).\n     *\n     * ErrorCode is the remaining three bytes of the result code, and it denotes what happened.\n     * e.g a combination of {@link #OPERATION_DOWNLOAD} and {@link #ERROR_TIME_OUT} will suggest the\n     * download operation has timed out. The only exception here is\n     * {@link #OPERATION_SMDX_SUBJECT_REASON_CODE}, where instead of ErrorCode, SubjectCode[5.2.6.1\n     * from GSMA (SGP.22 v2.2) and ReasonCode[5.2.6.2] from GSMA (SGP.22 v2.2) are encoded. @see\n     * {@link #EXTRA_EMBEDDED_SUBSCRIPTION_SMDX_SUBJECT_CODE} and\n     * {@link #EXTRA_EMBEDDED_SUBSCRIPTION_SMDX_REASON_CODE}\n     *\n     * In the case where ErrorCode contains a value of 0, it means it's an unknown error. E.g Intent\n     * only contains {@link #OPERATION_DOWNLOAD} and ErrorCode is 0 implies this is an unknown\n     * Download error.\n     *\n     * @see #EXTRA_EMBEDDED_SUBSCRIPTION_OPERATION_CODE\n     * @see #EXTRA_EMBEDDED_SUBSCRIPTION_ERROR_CODE\n     * @see #EXTRA_EMBEDDED_SUBSCRIPTION_SMDX_SUBJECT_CODE\n     * @see #EXTRA_EMBEDDED_SUBSCRIPTION_SMDX_REASON_CODE\n     ",
    "links" : [ "#OPERATION_SMDX_SUBJECT_REASON_CODE", "#EXTRA_EMBEDDED_SUBSCRIPTION_SMDX_REASON_CODE", "#EXTRA_EMBEDDED_SUBSCRIPTION_SMDX_SUBJECT_CODE", "#ERROR_TIME_OUT", "android.app.PendingIntent", "#OPERATION_DOWNLOAD" ]
  }, {
    "name" : "EXTRA_EMBEDDED_SUBSCRIPTION_OPERATION_CODE",
    "type" : "String",
    "comment" : "\n     * Key for an extra set on {@link PendingIntent} result callbacks providing a\n     * OperationCode of {@link #EXTRA_EMBEDDED_SUBSCRIPTION_DETAILED_CODE},\n     * value will be an int.\n     ",
    "links" : [ "#EXTRA_EMBEDDED_SUBSCRIPTION_DETAILED_CODE", "android.app.PendingIntent" ]
  }, {
    "name" : "EXTRA_EMBEDDED_SUBSCRIPTION_ERROR_CODE",
    "type" : "String",
    "comment" : "\n     * Key for an extra set on {@link PendingIntent} result callbacks providing a\n     * ErrorCode of {@link #EXTRA_EMBEDDED_SUBSCRIPTION_DETAILED_CODE},\n     * value will be an int.\n     ",
    "links" : [ "#EXTRA_EMBEDDED_SUBSCRIPTION_DETAILED_CODE", "android.app.PendingIntent" ]
  }, {
    "name" : "EXTRA_EMBEDDED_SUBSCRIPTION_SMDX_SUBJECT_CODE",
    "type" : "String",
    "comment" : "\n     * Key for an extra set on {@link PendingIntent} result callbacks providing a\n     * SubjectCode[5.2.6.1] from GSMA (SGP.22 v2.2) decoded from\n     * {@link #EXTRA_EMBEDDED_SUBSCRIPTION_DETAILED_CODE}.\n     * The value of this extra will be a String.\n     ",
    "links" : [ "#EXTRA_EMBEDDED_SUBSCRIPTION_DETAILED_CODE", "android.app.PendingIntent" ]
  }, {
    "name" : "EXTRA_EMBEDDED_SUBSCRIPTION_SMDX_REASON_CODE",
    "type" : "String",
    "comment" : "\n     * Key for an extra set on {@link PendingIntent} result callbacks providing a\n     * ReasonCode[5.2.6.2] from GSMA (SGP.22 v2.2) decoded from\n     * {@link #EXTRA_EMBEDDED_SUBSCRIPTION_DETAILED_CODE}.\n     * The value of this extra will be a String.\n     ",
    "links" : [ "#EXTRA_EMBEDDED_SUBSCRIPTION_DETAILED_CODE", "android.app.PendingIntent" ]
  }, {
    "name" : "EXTRA_EMBEDDED_SUBSCRIPTION_DOWNLOADABLE_SUBSCRIPTION",
    "type" : "String",
    "comment" : "\n     * Key for an extra set on {@code #getDownloadableSubscriptionMetadata} PendingIntent result\n     * callbacks providing the downloadable subscription metadata.\n     ",
    "links" : [ ]
  }, {
    "name" : "EXTRA_EMBEDDED_SUBSCRIPTION_DOWNLOADABLE_SUBSCRIPTIONS",
    "type" : "String",
    "comment" : "\n     * Key for an extra set on {@link #getDefaultDownloadableSubscriptionList} PendingIntent result\n     * callbacks providing the list of available downloadable subscriptions.\n     * @hide\n     ",
    "links" : [ "#getDefaultDownloadableSubscriptionList" ]
  }, {
    "name" : "EXTRA_EMBEDDED_SUBSCRIPTION_RESOLUTION_INTENT",
    "type" : "String",
    "comment" : "\n     * Key for an extra set on {@link PendingIntent} result callbacks providing the resolution\n     * pending intent for {@link #EMBEDDED_SUBSCRIPTION_RESULT_RESOLVABLE_ERROR}s.\n     * @hide\n     ",
    "links" : [ "#EMBEDDED_SUBSCRIPTION_RESULT_RESOLVABLE_ERROR", "android.app.PendingIntent" ]
  }, {
    "name" : "EXTRA_EMBEDDED_SUBSCRIPTION_RESOLUTION_ACTION",
    "type" : "String",
    "comment" : "\n     * Key for an extra set on the {@link #EXTRA_EMBEDDED_SUBSCRIPTION_RESOLUTION_INTENT} intent\n     * containing the EuiccService action to launch for resolution.\n     * @hide\n     ",
    "links" : [ "#EXTRA_EMBEDDED_SUBSCRIPTION_RESOLUTION_INTENT" ]
  }, {
    "name" : "EXTRA_EMBEDDED_SUBSCRIPTION_RESOLUTION_CALLBACK_INTENT",
    "type" : "String",
    "comment" : "\n     * Key for an extra set on the {@link #EXTRA_EMBEDDED_SUBSCRIPTION_RESOLUTION_INTENT} intent\n     * providing the callback to execute after resolution is completed.\n     * @hide\n     ",
    "links" : [ "#EXTRA_EMBEDDED_SUBSCRIPTION_RESOLUTION_INTENT" ]
  }, {
    "name" : "EXTRA_FORCE_PROVISION",
    "type" : "String",
    "comment" : "\n     * Key for an extra set on the {@link #ACTION_PROVISION_EMBEDDED_SUBSCRIPTION} intent for\n     * whether eSIM provisioning flow is forced to be started or not. If this extra hasn't been\n     * set, eSIM provisioning flow may be skipped and the corresponding carrier's app will be\n     * notified. Otherwise, eSIM provisioning flow will be started when\n     * {@link #ACTION_PROVISION_EMBEDDED_SUBSCRIPTION} has been received.\n     * @hide\n     ",
    "links" : [ "#ACTION_PROVISION_EMBEDDED_SUBSCRIPTION" ]
  }, {
    "name" : "EXTRA_SUBSCRIPTION_ID",
    "type" : "String",
    "comment" : "\n     * Key for an extra set on privileged actions {@link #ACTION_TOGGLE_SUBSCRIPTION_PRIVILEGED},\n     * {@link #ACTION_DELETE_SUBSCRIPTION_PRIVILEGED}, and\n     * {@link #ACTION_RENAME_SUBSCRIPTION_PRIVILEGED} providing the ID of the targeted subscription.\n     *\n     * <p>Expected type of the extra data: int\n     *\n     * @hide\n     ",
    "links" : [ "#ACTION_TOGGLE_SUBSCRIPTION_PRIVILEGED", "#ACTION_DELETE_SUBSCRIPTION_PRIVILEGED", "#ACTION_RENAME_SUBSCRIPTION_PRIVILEGED" ]
  }, {
    "name" : "EXTRA_ENABLE_SUBSCRIPTION",
    "type" : "String",
    "comment" : "\n     * Key for an extra set on {@link #ACTION_TOGGLE_SUBSCRIPTION_PRIVILEGED} providing a boolean\n     * value of whether to enable or disable the targeted subscription.\n     *\n     * <p>Expected type of the extra data: boolean\n     *\n     * @hide\n     ",
    "links" : [ "#ACTION_TOGGLE_SUBSCRIPTION_PRIVILEGED" ]
  }, {
    "name" : "EXTRA_SUBSCRIPTION_NICKNAME",
    "type" : "String",
    "comment" : "\n     * Key for an extra set on {@link #ACTION_RENAME_SUBSCRIPTION_PRIVILEGED} providing a new\n     * nickname for the targeted subscription.\n     *\n     * <p>Expected type of the extra data: String\n     *\n     * @hide\n     ",
    "links" : [ "#ACTION_RENAME_SUBSCRIPTION_PRIVILEGED" ]
  }, {
    "name" : "EXTRA_FROM_SUBSCRIPTION_ID",
    "type" : "String",
    "comment" : "\n     * Key for an extra set on {@link #ACTION_TOGGLE_SUBSCRIPTION_PRIVILEGED} providing the ID of\n     * the subscription we're toggling from. This extra is optional and is only used for UI\n     * purposes by the underlying eUICC service (i.e. the LPA app), such as displaying a dialog\n     * titled \"Switch X with Y\". If set, the provided subscription will be used as the \"from\"\n     * subscription in UI (the \"X\" in the dialog example). Otherwise, the currently active\n     * subscription that will be disabled is the \"from\" subscription.\n     *\n     * <p>Expected type of the extra data: int\n     *\n     * @hide\n     ",
    "links" : [ "#ACTION_TOGGLE_SUBSCRIPTION_PRIVILEGED" ]
  }, {
    "name" : "EXTRA_PHYSICAL_SLOT_ID",
    "type" : "String",
    "comment" : "\n     * Key for an extra set on privileged actions {@link #ACTION_TOGGLE_SUBSCRIPTION_PRIVILEGED}\n     * providing the physical slot ID of the target slot.\n     *\n     * <p>Expected type of the extra data: int\n     *\n     * @hide\n     ",
    "links" : [ "#ACTION_TOGGLE_SUBSCRIPTION_PRIVILEGED" ]
  }, {
    "name" : "EXTRA_USE_QR_SCANNER",
    "type" : "String",
    "comment" : "\n     * Key for an extra set on actions {@link #ACTION_START_EUICC_ACTIVATION} providing a boolean\n     * value of whether to start eSIM activation with QR scanner.\n     *\n     * <p>Expected type of the extra data: boolean\n     *",
    "links" : [ "#ACTION_START_EUICC_ACTIVATION" ]
  }, {
    "name" : "META_DATA_CARRIER_ICON",
    "type" : "String",
    "comment" : "\n     * Optional meta-data attribute for a carrier app providing an icon to use to represent the\n     * carrier. If not provided, the app's launcher icon will be used as a fallback.\n     ",
    "links" : [ ]
  }, {
    "name" : "EUICC_ACTIVATION_TYPE_DEFAULT",
    "type" : "int",
    "comment" : "\n     * The default euicc activation type which includes checking server side and downloading the\n     * profile based on carrier's download configuration.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "EUICC_ACTIVATION_TYPE_BACKUP",
    "type" : "int",
    "comment" : "\n     * The euicc activation type used when the default download process failed. LPA will start the\n     * backup flow and try to download the profile for the carrier.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "EUICC_ACTIVATION_TYPE_TRANSFER",
    "type" : "int",
    "comment" : "\n     * The activation flow of eSIM seamless transfer will be used. LPA will start normal eSIM\n     * activation flow and if it's failed, the name of the carrier selected will be recorded. After\n     * the future device pairing, LPA will contact this carrier to transfer it from the other device\n     * to this device.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "EUICC_ACTIVATION_TYPE_ACCOUNT_REQUIRED",
    "type" : "int",
    "comment" : "\n     * The activation flow of eSIM requiring user account will be started. This can only be used\n     * when there is user account signed in. Otherwise, the flow will be failed.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "EUICC_ACTIVATION_TYPE_TRANSFER_FINAL_HOLD",
    "type" : "int",
    "comment" : " TODO(b/329212614): add system api annotation during the allowed api timeline.",
    "links" : [ ]
  }, {
    "name" : "EUICC_OTA_IN_PROGRESS",
    "type" : "int",
    "comment" : "\n     * An OTA is in progress. During this time, the eUICC is not available and the user may lose\n     * network access.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "EUICC_OTA_FAILED",
    "type" : "int",
    "comment" : "\n     * The OTA update failed.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "EUICC_OTA_SUCCEEDED",
    "type" : "int",
    "comment" : "\n     * The OTA update finished successfully.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "EUICC_OTA_NOT_NEEDED",
    "type" : "int",
    "comment" : "\n     * The OTA update not needed since current eUICC OS is latest.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "EUICC_OTA_STATUS_UNAVAILABLE",
    "type" : "int",
    "comment" : "\n     * The OTA status is unavailable since eUICC service is unavailable.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "OPERATION_SYSTEM",
    "type" : "int",
    "comment" : "\n     * Internal system error.\n     * @see #EXTRA_EMBEDDED_SUBSCRIPTION_DETAILED_CODE for details\n     ",
    "links" : [ ]
  }, {
    "name" : "OPERATION_SIM_SLOT",
    "type" : "int",
    "comment" : "\n     * SIM slot error. Failed to switch slot, failed to access the physical slot etc.\n     * @see #EXTRA_EMBEDDED_SUBSCRIPTION_DETAILED_CODE for details\n     ",
    "links" : [ ]
  }, {
    "name" : "OPERATION_EUICC_CARD",
    "type" : "int",
    "comment" : "\n     * eUICC card error.\n     * @see #EXTRA_EMBEDDED_SUBSCRIPTION_DETAILED_CODE for details\n     ",
    "links" : [ ]
  }, {
    "name" : "OPERATION_SWITCH",
    "type" : "int",
    "comment" : "\n     * Generic switching profile error\n     * @see #EXTRA_EMBEDDED_SUBSCRIPTION_DETAILED_CODE for details\n     ",
    "links" : [ ]
  }, {
    "name" : "OPERATION_DOWNLOAD",
    "type" : "int",
    "comment" : "\n     * Download profile error.\n     * @see #EXTRA_EMBEDDED_SUBSCRIPTION_DETAILED_CODE for details\n     ",
    "links" : [ ]
  }, {
    "name" : "OPERATION_METADATA",
    "type" : "int",
    "comment" : "\n     * Subscription's metadata error\n     * @see #EXTRA_EMBEDDED_SUBSCRIPTION_DETAILED_CODE for details\n     ",
    "links" : [ ]
  }, {
    "name" : "OPERATION_EUICC_GSMA",
    "type" : "int",
    "comment" : "\n     * eUICC returned an error defined in GSMA (SGP.22 v2.2) while running one of the ES10x\n     * functions.\n     * @see #EXTRA_EMBEDDED_SUBSCRIPTION_DETAILED_CODE for details\n     ",
    "links" : [ ]
  }, {
    "name" : "OPERATION_APDU",
    "type" : "int",
    "comment" : "\n     * The exception of failing to execute an APDU command. It can be caused by an error\n     * happening on opening the basic or logical channel, or the response of the APDU command is\n     * not success (0x9000).\n     * @see #EXTRA_EMBEDDED_SUBSCRIPTION_DETAILED_CODE for details\n     ",
    "links" : [ ]
  }, {
    "name" : "OPERATION_SMDX",
    "type" : "int",
    "comment" : "\n     * SMDX(SMDP/SMDS) error\n     * @see #EXTRA_EMBEDDED_SUBSCRIPTION_DETAILED_CODE for details\n     ",
    "links" : [ ]
  }, {
    "name" : "OPERATION_SMDX_SUBJECT_REASON_CODE",
    "type" : "int",
    "comment" : "\n     * SubjectCode[5.2.6.1] and ReasonCode[5.2.6.2] error from GSMA (SGP.22 v2.2)\n     * When {@link #OPERATION_SMDX_SUBJECT_REASON_CODE} is used as the\n     * {@link #EXTRA_EMBEDDED_SUBSCRIPTION_DETAILED_CODE}, the remaining three bytes of the integer\n     * result from {@link #EXTRA_EMBEDDED_SUBSCRIPTION_DETAILED_CODE} will be used to stored the\n     * SubjectCode and ReasonCode from the GSMA spec and NOT ErrorCode.\n     *\n     * The encoding will follow the format of:\n     * 1. The first byte of the result will be 255(0xFF).\n     * 2. Remaining three bytes(24 bits) will be split into six sections, 4 bits in each section.\n     * 3. A SubjectCode/ReasonCode will take 12 bits each.\n     * 4. The maximum number can be represented per section is 15, as that is the maximum number\n     * allowed to be stored into 4 bits\n     * 5. Maximum supported nested category from GSMA is three layers. E.g 8.11.1.2 is not\n     * supported.\n     *\n     * E.g given SubjectCode(8.11.1) and ReasonCode(5.1)\n     *\n     * Base10:  0       10      8       11      1       0       5       1\n     * Base2:   0000    1010    1000    1011    0001    0000    0101    0001\n     * Base16:  0       A       8       B       1       0       5       1\n     *\n     * Thus the integer stored in {@link #EXTRA_EMBEDDED_SUBSCRIPTION_DETAILED_CODE} is\n     * 0xA8B1051(176885841)\n     *\n     * @see #EXTRA_EMBEDDED_SUBSCRIPTION_DETAILED_CODE for details\n     ",
    "links" : [ "#EXTRA_EMBEDDED_SUBSCRIPTION_DETAILED_CODE", "#OPERATION_SMDX_SUBJECT_REASON_CODE" ]
  }, {
    "name" : "OPERATION_HTTP",
    "type" : "int",
    "comment" : "\n     * HTTP error\n     * @see #EXTRA_EMBEDDED_SUBSCRIPTION_DETAILED_CODE for details\n     ",
    "links" : [ ]
  }, {
    "name" : "ERROR_CARRIER_LOCKED",
    "type" : "int",
    "comment" : "\n     * Operation such as downloading/switching to another profile failed due to device being\n     * carrier locked.\n     * @see #EXTRA_EMBEDDED_SUBSCRIPTION_DETAILED_CODE for details\n     ",
    "links" : [ ]
  }, {
    "name" : "ERROR_INVALID_ACTIVATION_CODE",
    "type" : "int",
    "comment" : "\n     * The activation code(SGP.22 v2.2 section[4.1]) is invalid.\n     * @see #EXTRA_EMBEDDED_SUBSCRIPTION_DETAILED_CODE for details\n     ",
    "links" : [ ]
  }, {
    "name" : "ERROR_INVALID_CONFIRMATION_CODE",
    "type" : "int",
    "comment" : "\n     * The confirmation code(SGP.22 v2.2 section[4.7]) is invalid.\n     * @see #EXTRA_EMBEDDED_SUBSCRIPTION_DETAILED_CODE for details\n     ",
    "links" : [ ]
  }, {
    "name" : "ERROR_INCOMPATIBLE_CARRIER",
    "type" : "int",
    "comment" : "\n     * The profile's carrier is incompatible with the LPA.\n     * @see #EXTRA_EMBEDDED_SUBSCRIPTION_DETAILED_CODE for details\n     ",
    "links" : [ ]
  }, {
    "name" : "ERROR_EUICC_INSUFFICIENT_MEMORY",
    "type" : "int",
    "comment" : "\n     * There is no more space available on the eUICC for new profiles.\n     * @see #EXTRA_EMBEDDED_SUBSCRIPTION_DETAILED_CODE for details\n     ",
    "links" : [ ]
  }, {
    "name" : "ERROR_TIME_OUT",
    "type" : "int",
    "comment" : "\n     * Timed out while waiting for an operation to complete. i.e restart, disable,\n     * switch reset etc.\n     * @see #EXTRA_EMBEDDED_SUBSCRIPTION_DETAILED_CODE for details\n     ",
    "links" : [ ]
  }, {
    "name" : "ERROR_EUICC_MISSING",
    "type" : "int",
    "comment" : "\n     * eUICC is missing or defective on the device.\n     * @see #EXTRA_EMBEDDED_SUBSCRIPTION_DETAILED_CODE for details\n     ",
    "links" : [ ]
  }, {
    "name" : "ERROR_UNSUPPORTED_VERSION",
    "type" : "int",
    "comment" : "\n     * The eUICC card(hardware) version is incompatible with the software\n     * @see #EXTRA_EMBEDDED_SUBSCRIPTION_DETAILED_CODE for details\n     ",
    "links" : [ ]
  }, {
    "name" : "ERROR_SIM_MISSING",
    "type" : "int",
    "comment" : "\n     * No SIM card is available in the device.\n     * @see #EXTRA_EMBEDDED_SUBSCRIPTION_DETAILED_CODE for details\n     ",
    "links" : [ ]
  }, {
    "name" : "ERROR_INSTALL_PROFILE",
    "type" : "int",
    "comment" : "\n     * Failure to load the profile onto the eUICC card. e.g\n     * 1. iccid of the profile already exists on the eUICC.\n     * 2. GSMA(.22 v2.2) Profile Install Result - installFailedDueToDataMismatch\n     * 3. operation was interrupted\n     * 4. SIMalliance error in PEStatus(SGP.22 v2.2 section 2.5.6.1)\n     * @see #EXTRA_EMBEDDED_SUBSCRIPTION_DETAILED_CODE for details\n     ",
    "links" : [ ]
  }, {
    "name" : "ERROR_DISALLOWED_BY_PPR",
    "type" : "int",
    "comment" : "\n     * Failed to load profile onto eUICC due to Profile Policy Rules.\n     * @see #EXTRA_EMBEDDED_SUBSCRIPTION_DETAILED_CODE for details\n     ",
    "links" : [ ]
  }, {
    "name" : "ERROR_ADDRESS_MISSING",
    "type" : "int",
    "comment" : "\n     * Address is missing e.g SMDS/SMDP address is missing.\n     * @see #EXTRA_EMBEDDED_SUBSCRIPTION_DETAILED_CODE for details\n     ",
    "links" : [ ]
  }, {
    "name" : "ERROR_CERTIFICATE_ERROR",
    "type" : "int",
    "comment" : "\n     * Certificate needed for authentication is not valid or missing. E.g  SMDP/SMDS authentication\n     * failed.\n     * @see #EXTRA_EMBEDDED_SUBSCRIPTION_DETAILED_CODE for details\n     ",
    "links" : [ ]
  }, {
    "name" : "ERROR_NO_PROFILES_AVAILABLE",
    "type" : "int",
    "comment" : "\n     * No profiles available.\n     * @see #EXTRA_EMBEDDED_SUBSCRIPTION_DETAILED_CODE for details\n     ",
    "links" : [ ]
  }, {
    "name" : "ERROR_CONNECTION_ERROR",
    "type" : "int",
    "comment" : "\n     * Failure to create a connection.\n     * @see #EXTRA_EMBEDDED_SUBSCRIPTION_DETAILED_CODE for details\n     ",
    "links" : [ ]
  }, {
    "name" : "ERROR_INVALID_RESPONSE",
    "type" : "int",
    "comment" : "\n     * Response format is invalid. e.g SMDP/SMDS response contains invalid json, header or/and ASN1.\n     * @see #EXTRA_EMBEDDED_SUBSCRIPTION_DETAILED_CODE for details\n     ",
    "links" : [ ]
  }, {
    "name" : "ERROR_OPERATION_BUSY",
    "type" : "int",
    "comment" : "\n     * The operation is currently busy, try again later.\n     * @see #EXTRA_EMBEDDED_SUBSCRIPTION_DETAILED_CODE for details\n     ",
    "links" : [ ]
  }, {
    "name" : "ERROR_INVALID_PORT",
    "type" : "int",
    "comment" : "\n     * Failure due to target port is not supported.\n     * @see #switchToSubscription(int, int, PendingIntent)\n     ",
    "links" : [ ]
  }, {
    "name" : "EUICC_MEMORY_FIELD_UNAVAILABLE",
    "type" : "long",
    "comment" : " Temporary failure to retrieve available memory because eUICC is not ready. ",
    "links" : [ ]
  }, {
    "name" : "SWITCH_WITHOUT_PORT_INDEX_EXCEPTION_ON_DISABLE",
    "type" : "long",
    "comment" : "\n     * Apps targeting on Android T and beyond will get exception whenever switchToSubscription\n     * without portIndex is called for disable subscription.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "SHOULD_RESOLVE_PORT_INDEX_FOR_APPS",
    "type" : "long",
    "comment" : "\n     * With support for MEP(multiple enabled profile) in Android T, a SIM card can enable multiple\n     * profile on different port. If apps are not target SDK T yet and keep calling the\n     * switchToSubscription or download API without specifying the port index, we should\n     * keep the existing behaviour by always use port index 0 even the device itself has MEP eUICC,\n     * this is for carrier app's backward compatibility.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "INACTIVE_PORT_AVAILABILITY_CHECK",
    "type" : "long",
    "comment" : "\n     * Starting with Android U, a port is available if it is active without an enabled profile\n     * on it or calling app can activate a new profile on the selected port without any user\n     * interaction.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "mContext",
    "type" : "Context",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mCardId",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  } ],
  "methods" : [ {
    "name" : "public EuiccManager createForCardId(int cardId)",
    "returnType" : "EuiccManager",
    "comment" : "\n     * Create a new EuiccManager object pinned to the given card ID.\n     *\n     * @return an EuiccManager that uses the given card ID for all calls.\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean isEnabled()",
    "returnType" : "boolean",
    "comment" : "\n     * Whether embedded subscriptions are currently enabled.\n     *\n     * <p>Even on devices with the {@link PackageManager#FEATURE_TELEPHONY_EUICC} feature, embedded\n     * subscriptions may be turned off, e.g. because of a carrier restriction from an inserted\n     * physical SIM. Therefore, this runtime check should be used before accessing embedded\n     * subscription APIs.\n     *\n     * @return true if embedded subscriptions are currently enabled.\n     *\n     * @throws UnsupportedOperationException If the device does not have\n     *          {@link PackageManager#FEATURE_TELEPHONY_EUICC}.\n     ",
    "links" : [ "android.content.pm.PackageManager#FEATURE_TELEPHONY_EUICC" ]
  }, {
    "name" : "public String getEid()",
    "returnType" : "String",
    "comment" : "\n     * Returns the EID identifying the eUICC hardware.\n     *\n     * <p>Requires that the calling app has carrier privileges on the active subscription on the\n     * current eUICC. A calling app with carrier privileges for one eUICC may not necessarily have\n     * access to the EID of another eUICC.\n     *\n     * @return the EID. May be null if the eUICC is not ready.\n     *\n     * @throws UnsupportedOperationException If the device does not have\n     *          {@link PackageManager#FEATURE_TELEPHONY_EUICC}.\n     ",
    "links" : [ "android.content.pm.PackageManager#FEATURE_TELEPHONY_EUICC" ]
  }, {
    "name" : "public long getAvailableMemoryInBytes()",
    "returnType" : "long",
    "comment" : "\n     * Returns the available memory in bytes of the eUICC.\n     *\n     * @return the available memory in bytes. May be {@link #EUICC_MEMORY_FIELD_UNAVAILABLE} if the\n     *     eUICC is not ready. Check {@link #isEnabled} for more information.\n     * @throws UnsupportedOperationException If the device does not have\n     *          {@link PackageManager#FEATURE_TELEPHONY_EUICC} or\n     *          device doesn't support querying this information from the eUICC.\n     ",
    "links" : [ "#EUICC_MEMORY_FIELD_UNAVAILABLE", "android.content.pm.PackageManager#FEATURE_TELEPHONY_EUICC", "#isEnabled" ]
  }, {
    "name" : "public int getOtaStatus()",
    "returnType" : "int",
    "comment" : "\n     * Returns the current status of eUICC OTA.\n     *\n     * <p>Requires the {@link android.Manifest.permission#WRITE_EMBEDDED_SUBSCRIPTIONS} permission.\n     *\n     * @return the status of eUICC OTA. If the eUICC is not ready,\n     *         {@link OtaStatus#EUICC_OTA_STATUS_UNAVAILABLE} will be returned.\n     *\n     * @throws UnsupportedOperationException If the device does not have\n     *          {@link PackageManager#FEATURE_TELEPHONY_EUICC}.\n     * @hide\n     ",
    "links" : [ "#EUICC_OTA_STATUS_UNAVAILABLE", "android.Manifest.permission#WRITE_EMBEDDED_SUBSCRIPTIONS", "android.content.pm.PackageManager#FEATURE_TELEPHONY_EUICC" ]
  }, {
    "name" : "public void downloadSubscription(DownloadableSubscription subscription, boolean switchAfterDownload, PendingIntent callbackIntent)",
    "returnType" : "void",
    "comment" : "\n     * Attempt to download the given {@link DownloadableSubscription}.\n     *\n     * <p>Requires the {@code android.Manifest.permission#WRITE_EMBEDDED_SUBSCRIPTIONS}\n     * or the calling app must be authorized to manage both the currently-active\n     * subscription on the\n     * current eUICC and the subscription to be downloaded according to the subscription metadata.\n     * Without the former, an {@link #EMBEDDED_SUBSCRIPTION_RESULT_RESOLVABLE_ERROR} will be\n     * returned in the callback intent to prompt the user to accept the download.\n     *\n     * <p> Starting from Android {@link android.os.Build.VERSION_CODES#VANILLA_ICE_CREAM},\n     * if the caller has the\n     * {@code android.Manifest.permission#MANAGE_DEVICE_POLICY_MANAGED_SUBSCRIPTIONS} permission or\n     * is a profile owner or device owner, then the downloaded subscription\n     * will be managed by that caller.\n     * In case the caller is device owner or profile owner of an organization-owned device, {@code\n     * switchAfterDownload} can be set to true to automatically enable the subscription after\n     * download. If the caller is a profile owner on non organization owned device\n     * {@code switchAfterDownload} should be false otherwise the operation will fail with\n     * {@link #EMBEDDED_SUBSCRIPTION_RESULT_ERROR}.\n     *\n     * <p>On a multi-active SIM device, requires the\n     * {@code android.Manifest.permission#WRITE_EMBEDDED_SUBSCRIPTIONS} permission, or a calling app\n     * only if the targeted eUICC does not currently have an active subscription or the calling app\n     * is authorized to manage the active subscription on the target eUICC, and the calling app is\n     * authorized to manage any active subscription on any SIM. Without it, an\n     * {@link #EMBEDDED_SUBSCRIPTION_RESULT_RESOLVABLE_ERROR} will be returned in the callback\n     * intent to prompt the user to accept the download. The caller should also be authorized to\n     * manage the subscription to be downloaded.\n     *\n     * <p>If device support {@link PackageManager#FEATURE_TELEPHONY_EUICC_MEP} and\n     * switchAfterDownload is {@code true}, the subscription will be enabled on an esim port based\n     * on the following selection rules:\n     * <ul>\n     *    <li>In SS(Single SIM) mode, if the embedded slot already has an active port, then download\n     *    and enable the subscription on this port.\n     *    <li>In SS mode, if the embedded slot is not active, then try to download and enable the\n     *    subscription on the default port 0 of eUICC.\n     *    <li>In DSDS mode, find first available port to download and enable the subscription.\n     *    (see {@link #isSimPortAvailable(int)})\n     *</ul>\n     * If there is no available port, an {@link #EMBEDDED_SUBSCRIPTION_RESULT_RESOLVABLE_ERROR}\n     * will be returned in the callback intent to prompt the user to disable an already-active\n     * subscription.\n     *\n     * @param subscription the subscription to download.\n     * @param switchAfterDownload if true, the profile will be activated upon successful download.\n     * @param callbackIntent a PendingIntent to launch when the operation completes.\n     *\n     * @throws UnsupportedOperationException If the device does not have\n     *          {@link PackageManager#FEATURE_TELEPHONY_EUICC}.\n     ",
    "links" : [ "android.telephony.euicc.DownloadableSubscription", "#EMBEDDED_SUBSCRIPTION_RESULT_RESOLVABLE_ERROR", "android.os.Build.VERSION_CODES#VANILLA_ICE_CREAM", "#EMBEDDED_SUBSCRIPTION_RESULT_ERROR", "android.content.pm.PackageManager#FEATURE_TELEPHONY_EUICC_MEP", "#isSimPortAvailable(int)", "android.content.pm.PackageManager#FEATURE_TELEPHONY_EUICC" ]
  }, {
    "name" : "public void startResolutionActivity(Activity activity, int requestCode, Intent resultIntent, PendingIntent callbackIntent) throws IntentSender.SendIntentException",
    "returnType" : "void",
    "comment" : "\n     * Start an activity to resolve a user-resolvable error.\n     *\n     * <p>If an operation returns {@link #EMBEDDED_SUBSCRIPTION_RESULT_RESOLVABLE_ERROR}, this\n     * method may be called to prompt the user to resolve the issue.\n     *\n     * <p>This method may only be called once for a particular error.\n     *\n     * @param activity the calling activity (which should be in the foreground).\n     * @param requestCode an application-specific request code which will be provided to\n     *     {@link Activity#onActivityResult} upon completion. Note that the operation may still be\n     *     in progress when the resolution activity completes; it is not fully finished until the\n     *     callback intent is triggered.\n     * @param resultIntent the Intent provided to the initial callback intent which failed with\n     *     {@link #EMBEDDED_SUBSCRIPTION_RESULT_RESOLVABLE_ERROR}.\n     * @param callbackIntent a PendingIntent to launch when the operation completes. This is\n     *     trigered upon completion of the original operation that required user resolution.\n     * @throws android.content.IntentSender.SendIntentException if called more than once.\n     ",
    "links" : [ "#EMBEDDED_SUBSCRIPTION_RESULT_RESOLVABLE_ERROR", "android.app.Activity#onActivityResult" ]
  }, {
    "name" : "public void continueOperation(Intent resolutionIntent, Bundle resolutionExtras)",
    "returnType" : "void",
    "comment" : "\n     * Continue an operation after the user resolves an error.\n     *\n     * <p>To be called by the LUI upon completion of a resolvable error flow.\n     *\n     * <p>Requires that the calling app has the\n     * {@link android.Manifest.permission#WRITE_EMBEDDED_SUBSCRIPTIONS} permission.\n     *\n     * @param resolutionIntent The original intent used to start the LUI.\n     * @param resolutionExtras Resolution-specific extras depending on the result of the resolution.\n     *     For example, this may indicate whether the user has consented or may include the input\n     *     they provided.\n     *\n     * @throws UnsupportedOperationException If the device does not have\n     *          {@link PackageManager#FEATURE_TELEPHONY_EUICC}.\n     * @hide\n     ",
    "links" : [ "android.Manifest.permission#WRITE_EMBEDDED_SUBSCRIPTIONS", "android.content.pm.PackageManager#FEATURE_TELEPHONY_EUICC" ]
  }, {
    "name" : "public void getDownloadableSubscriptionMetadata(DownloadableSubscription subscription, PendingIntent callbackIntent)",
    "returnType" : "void",
    "comment" : "\n     * Fills in the metadata for a DownloadableSubscription.\n     *\n     * <p>May be used in cases that a DownloadableSubscription was constructed to download a\n     * profile, but the metadata for the profile is unknown (e.g. we only know the activation code).\n     * The callback will be triggered with an Intent with\n     * {@link #EXTRA_EMBEDDED_SUBSCRIPTION_DOWNLOADABLE_SUBSCRIPTION} set to the\n     * downloadable subscription metadata upon success.\n     *\n     * <p>Requires that the calling app has the\n     * {@link android.Manifest.permission#WRITE_EMBEDDED_SUBSCRIPTIONS} permission. This is for\n     * internal system use only.\n     *\n     * @param subscription the subscription which needs metadata filled in\n     * @param callbackIntent a PendingIntent to launch when the operation completes.\n     *\n     * @throws UnsupportedOperationException If the device does not have\n     *          {@link PackageManager#FEATURE_TELEPHONY_EUICC}.\n     * @hide\n     ",
    "links" : [ "android.Manifest.permission#WRITE_EMBEDDED_SUBSCRIPTIONS", "android.content.pm.PackageManager#FEATURE_TELEPHONY_EUICC", "#EXTRA_EMBEDDED_SUBSCRIPTION_DOWNLOADABLE_SUBSCRIPTION" ]
  }, {
    "name" : "public void getDefaultDownloadableSubscriptionList(PendingIntent callbackIntent)",
    "returnType" : "void",
    "comment" : "\n     * Gets metadata for subscription which are available for download on this device.\n     *\n     * <p>Subscriptions returned here may be passed to {@link #downloadSubscription}. They may have\n     * been pre-assigned to this particular device, for example. The callback will be triggered with\n     * an Intent with {@link #EXTRA_EMBEDDED_SUBSCRIPTION_DOWNLOADABLE_SUBSCRIPTIONS} set to the\n     * list of available subscriptions upon success.\n     *\n     * <p>Requires that the calling app has the\n     * {@link android.Manifest.permission#WRITE_EMBEDDED_SUBSCRIPTIONS} permission. This is for\n     * internal system use only.\n     *\n     * @param callbackIntent a PendingIntent to launch when the operation completes.\n     *\n     * @throws UnsupportedOperationException If the device does not have\n     *          {@link PackageManager#FEATURE_TELEPHONY_EUICC}.\n     * @hide\n     ",
    "links" : [ "#EXTRA_EMBEDDED_SUBSCRIPTION_DOWNLOADABLE_SUBSCRIPTIONS", "android.Manifest.permission#WRITE_EMBEDDED_SUBSCRIPTIONS", "android.content.pm.PackageManager#FEATURE_TELEPHONY_EUICC", "#downloadSubscription" ]
  }, {
    "name" : "public EuiccInfo getEuiccInfo()",
    "returnType" : "EuiccInfo",
    "comment" : "\n     * Returns information about the eUICC chip/device.\n     *\n     * @return the {@link EuiccInfo}. May be null if the eUICC is not ready.\n     *\n     * @throws UnsupportedOperationException If the device does not have\n     *          {@link PackageManager#FEATURE_TELEPHONY_EUICC}.\n     ",
    "links" : [ "android.telephony.euicc.EuiccInfo", "android.content.pm.PackageManager#FEATURE_TELEPHONY_EUICC" ]
  }, {
    "name" : "public void deleteSubscription(int subscriptionId, PendingIntent callbackIntent)",
    "returnType" : "void",
    "comment" : "\n     * Deletes the given subscription.\n     *\n     * <p>If this subscription is currently active, the device will first switch away from it onto\n     * an \"empty\" subscription.\n     *\n     * <p>Requires that the calling app has carrier privileges according to the metadata of the\n     * profile to be deleted, or the\n     * {@code android.Manifest.permission#WRITE_EMBEDDED_SUBSCRIPTIONS} permission.\n     * Starting from Android {@link android.os.Build.VERSION_CODES#VANILLA_ICE_CREAM}, if the\n     * caller is a device owner, profile owner, or holds the\n     * {@code android.Manifest.permission#MANAGE_DEVICE_POLICY_MANAGED_SUBSCRIPTIONS} permission,\n     * then the caller can delete a subscription that was downloaded by that caller.\n     * If such a caller tries to delete any other subscription then the\n     * operation will fail with {@link #EMBEDDED_SUBSCRIPTION_RESULT_ERROR}.\n     *\n     * @param subscriptionId the ID of the subscription to delete.\n     * @param callbackIntent a PendingIntent to launch when the operation completes.\n     *\n     * @throws UnsupportedOperationException If the device does not have\n     *          {@link PackageManager#FEATURE_TELEPHONY_EUICC}.\n     ",
    "links" : [ "android.os.Build.VERSION_CODES#VANILLA_ICE_CREAM", "#EMBEDDED_SUBSCRIPTION_RESULT_ERROR", "android.content.pm.PackageManager#FEATURE_TELEPHONY_EUICC" ]
  }, {
    "name" : "public void switchToSubscription(int subscriptionId, PendingIntent callbackIntent)",
    "returnType" : "void",
    "comment" : "\n     * Switch to (enable) the given subscription.\n     *\n     * <p>Requires the {@code android.Manifest.permission#WRITE_EMBEDDED_SUBSCRIPTIONS} permission,\n     * or the calling app must be authorized to manage both the currently-active subscription and\n     * the subscription to be enabled according to the subscription metadata. Without the former,\n     * an {@link #EMBEDDED_SUBSCRIPTION_RESULT_RESOLVABLE_ERROR} will be returned in the callback\n     * intent to prompt the user to accept the download.\n     *\n     * <p>On a multi-active SIM device, requires the\n     * {@code android.Manifest.permission#WRITE_EMBEDDED_SUBSCRIPTIONS} permission, or a calling app\n     *  only if the targeted eUICC does not currently have an active subscription or the calling app\n     * is authorized to manage the active subscription on the target eUICC, and the calling app is\n     * authorized to manage any active subscription on any SIM. Without it, an\n     * {@link #EMBEDDED_SUBSCRIPTION_RESULT_RESOLVABLE_ERROR} will be returned in the callback\n     * intent to prompt the user to accept the download. The caller should also be authorized to\n     * manage the subscription to be enabled.\n     *\n     * <p> From Android T, devices might support {@link PackageManager#FEATURE_TELEPHONY_EUICC_MEP},\n     * the subscription can be installed on different port from the eUICC. Calling apps with\n     * carrier privilege (see {@link TelephonyManager#hasCarrierPrivileges}) over the currently\n     * active subscriptions can use {@link #switchToSubscription(int, int, PendingIntent)} to\n     * specify which port to enable the subscription. Otherwise, use this API to enable the\n     * subscription on the eUICC and the platform will internally resolve a port based on following\n     * rules:\n     * <ul>\n     *    <li>always use the default port 0 is eUICC does not support MEP or the apps are\n     *    not targeting on Android T.\n     *    <li>In SS(Single SIM) mode, if the embedded slot already has an active port, then enable\n     *    the subscription on this port.\n     *    <li>In SS mode, if the embedded slot is not active, then try to enable the subscription on\n     *    the default port 0 of eUICC.\n     *    <li>In DSDS mode, find first available port to enable the subscription.\n     *    (see {@link #isSimPortAvailable(int)})\n     *</ul>\n     * If there is no available port, an {@link #EMBEDDED_SUBSCRIPTION_RESULT_RESOLVABLE_ERROR}\n     * will be returned in the callback intent to prompt the user to disable an already-active\n     * subscription.\n     *\n     * @param subscriptionId the ID of the subscription to enable. May be\n     *     {@link android.telephony.SubscriptionManager#INVALID_SUBSCRIPTION_ID} to deactivate the\n     *     current profile without activating another profile to replace it. Calling apps targeting\n     *     on android T must use {@link #switchToSubscription(int, int, PendingIntent)} API for\n     *     disable profile, port index can be found from {@link SubscriptionInfo#getPortIndex()}.\n     *     If it's a disable operation, requires the\n     *     {@code android.Manifest.permission#WRITE_EMBEDDED_SUBSCRIPTIONS} permission, or the\n     *     calling app must be authorized to manage the active subscription on the target eUICC.\n     * @param callbackIntent a PendingIntent to launch when the operation completes.\n     *\n     * @throws UnsupportedOperationException If the device does not have\n     *          {@link PackageManager#FEATURE_TELEPHONY_EUICC}.\n     ",
    "links" : [ "#EMBEDDED_SUBSCRIPTION_RESULT_RESOLVABLE_ERROR", "android.content.pm.PackageManager#FEATURE_TELEPHONY_EUICC_MEP", "#isSimPortAvailable(int)", "android.telephony.SubscriptionManager#INVALID_SUBSCRIPTION_ID", "android.content.pm.PackageManager#FEATURE_TELEPHONY_EUICC", "android.telephony.TelephonyManager#hasCarrierPrivileges", "#switchToSubscription(int", "android.telephony.SubscriptionInfo#getPortIndex()" ]
  }, {
    "name" : "public void switchToSubscription(int subscriptionId, int portIndex, @NonNull PendingIntent callbackIntent)",
    "returnType" : "void",
    "comment" : "\n     * Switch to (enable) the given subscription.\n     *\n     * <p> Requires the {@code android.Manifest.permission#WRITE_EMBEDDED_SUBSCRIPTIONS} permission,\n     * or the caller must be having both the carrier privileges\n     * (see {@link TelephonyManager#hasCarrierPrivileges}) over any currently active subscriptions\n     * and the subscription to be enabled according to the subscription metadata.\n     * Without the former permissions, an SecurityException is thrown.\n     *\n     * <p> If the caller is passing invalid port index,\n     * an {@link #EMBEDDED_SUBSCRIPTION_RESULT_ERROR} with detailed error code\n     * {@link #ERROR_INVALID_PORT} will be returned. The port index is invalid if one of the\n     * following requirements is met:\n     * <ul>\n     *     <li>index is beyond the range of {@link UiccCardInfo#getPorts()}.\n     *     <li>In SS(Single SIM) mode, the embedded slot already has an active port with different\n     *     port index.\n     *     <li>In DSDS mode, if the psim slot is active and the embedded slot already has an active\n     *     empty port with different port index.\n     * </ul>\n     *\n     * <p> Depending on the target port and permission check,\n     * an {@link #EMBEDDED_SUBSCRIPTION_RESULT_RESOLVABLE_ERROR} might be returned to the callback\n     * intent to prompt the user to authorize before the switch.\n     *\n     * @param subscriptionId the ID of the subscription to enable. May be\n     *     {@link android.telephony.SubscriptionManager#INVALID_SUBSCRIPTION_ID} to deactivate the\n     *     current profile without activating another profile to replace it. If it's a disable\n     *     operation, requires the {@code android.Manifest.permission#WRITE_EMBEDDED_SUBSCRIPTIONS}\n     *     permission, or the calling app must be authorized to manage the active subscription on\n     *     the target eUICC. From Android T, multiple enabled profiles is supported. Calling apps\n     *     targeting on android T must use {@link #switchToSubscription(int, int, PendingIntent)}\n     *     API for disable profile, port index can be found from\n     *     {@link SubscriptionInfo#getPortIndex()}.\n     * @param portIndex the index of the port to target for the enabled subscription\n     * @param callbackIntent a PendingIntent to launch when the operation completes.\n     *\n     * @throws UnsupportedOperationException If the device does not have\n     *          {@link PackageManager#FEATURE_TELEPHONY_EUICC}.\n     ",
    "links" : [ "#EMBEDDED_SUBSCRIPTION_RESULT_RESOLVABLE_ERROR", "#EMBEDDED_SUBSCRIPTION_RESULT_ERROR", "android.telephony.SubscriptionManager#INVALID_SUBSCRIPTION_ID", "android.content.pm.PackageManager#FEATURE_TELEPHONY_EUICC", "android.telephony.TelephonyManager#hasCarrierPrivileges", "#switchToSubscription(int", "android.telephony.UiccCardInfo#getPorts()", "android.telephony.SubscriptionInfo#getPortIndex()", "#ERROR_INVALID_PORT" ]
  }, {
    "name" : "public void updateSubscriptionNickname(int subscriptionId, @Nullable String nickname, @NonNull PendingIntent callbackIntent)",
    "returnType" : "void",
    "comment" : "\n     * Update the nickname for the given subscription.\n     *\n     * <p>Requires that the calling app has carrier privileges according to the metadata of the\n     * profile to be updated, or the\n     * {@code android.Manifest.permission#WRITE_EMBEDDED_SUBSCRIPTIONS} permission.\n     *\n     * @param subscriptionId the ID of the subscription to update.\n     * @param nickname the new nickname to apply.\n     * @param callbackIntent a PendingIntent to launch when the operation completes.\n     *\n     * @throws UnsupportedOperationException If the device does not have\n     *          {@link PackageManager#FEATURE_TELEPHONY_EUICC}.\n     ",
    "links" : [ "android.content.pm.PackageManager#FEATURE_TELEPHONY_EUICC" ]
  }, {
    "name" : "public void eraseSubscriptions(@NonNull PendingIntent callbackIntent)",
    "returnType" : "void",
    "comment" : "\n     * Erase all operational subscriptions and reset the eUICC.\n     *\n     * <p>Requires that the calling app has the\n     * {@code android.Manifest.permission#WRITE_EMBEDDED_SUBSCRIPTIONS} permission.\n     *\n     * @param callbackIntent a PendingIntent to launch when the operation completes.\n     *\n     * @deprecated From R, callers should specify a flag for specific set of subscriptions to erase\n     * and use {@link #eraseSubscriptions(int, PendingIntent)} instead\n     *\n     * @throws UnsupportedOperationException If the device does not have\n     *          {@link PackageManager#FEATURE_TELEPHONY_EUICC}.\n     * @hide\n     ",
    "links" : [ "android.content.pm.PackageManager#FEATURE_TELEPHONY_EUICC", "#eraseSubscriptions(int" ]
  }, {
    "name" : "public void eraseSubscriptions(@ResetOption int options, @NonNull PendingIntent callbackIntent)",
    "returnType" : "void",
    "comment" : "\n     * Erase all specific subscriptions and reset the eUICC.\n     *\n     * <p>Requires that the calling app has the\n     * {@code android.Manifest.permission#WRITE_EMBEDDED_SUBSCRIPTIONS} permission.\n     *\n     * @param options flag indicating specific set of subscriptions to erase\n     * @param callbackIntent a PendingIntent to launch when the operation completes.\n     *\n     * @throws UnsupportedOperationException If the device does not have\n     *          {@link PackageManager#FEATURE_TELEPHONY_EUICC}.\n     * @hide\n     ",
    "links" : [ "android.content.pm.PackageManager#FEATURE_TELEPHONY_EUICC" ]
  }, {
    "name" : "public void retainSubscriptionsForFactoryReset(PendingIntent callbackIntent)",
    "returnType" : "void",
    "comment" : "\n     * Ensure that subscriptions will be retained on the next factory reset.\n     *\n     * <p>By default, all subscriptions on the eUICC are erased the first time a device boots (ever\n     * and after factory resets). This ensures that the data is wiped after a factory reset is\n     * performed via fastboot or recovery mode, as these modes do not support the necessary radio\n     * communication needed to wipe the eSIM.\n     *\n     * <p>However, this method may be called right before a factory reset issued via settings when\n     * the user elects to retain subscriptions. Doing so will mark them for retention so that they\n     * are not cleared after the ensuing reset.\n     *\n     * <p>Requires that the calling app has the {@link android.Manifest.permission#MASTER_CLEAR}\n     * permission. This is for internal system use only.\n     *\n     * @param callbackIntent a PendingIntent to launch when the operation completes.\n     * @hide\n     ",
    "links" : [ "android.Manifest.permission#MASTER_CLEAR" ]
  }, {
    "name" : "public void setSupportedCountries(@NonNull List<String> supportedCountries)",
    "returnType" : "void",
    "comment" : "\n     * Sets the supported countries for eUICC.\n     *\n     * <p>Requires that the calling app has the\n     * {@code android.Manifest.permission#WRITE_EMBEDDED_SUBSCRIPTIONS} permission.\n     *\n     * <p>The supported country list will be replaced by {@code supportedCountries}. For how we\n     * determine whether a country is supported please check {@link #isSupportedCountry}.\n     *\n     * @param supportedCountries is a list of strings contains country ISO codes in uppercase.\n     *\n     * @throws UnsupportedOperationException If the device does not have\n     *          {@link PackageManager#FEATURE_TELEPHONY_EUICC}.\n     * @hide\n     ",
    "links" : [ "android.content.pm.PackageManager#FEATURE_TELEPHONY_EUICC", "#isSupportedCountry" ]
  }, {
    "name" : "public void setUnsupportedCountries(@NonNull List<String> unsupportedCountries)",
    "returnType" : "void",
    "comment" : "\n     * Sets the unsupported countries for eUICC.\n     *\n     * <p>Requires that the calling app has the\n     * {@code android.Manifest.permission#WRITE_EMBEDDED_SUBSCRIPTIONS} permission.\n     *\n     * <p>The unsupported country list will be replaced by {@code unsupportedCountries}. For how we\n     * determine whether a country is supported please check {@link #isSupportedCountry}.\n     *\n     * @param unsupportedCountries is a list of strings contains country ISO codes in uppercase.\n     *\n     * @throws UnsupportedOperationException If the device does not have\n     *          {@link PackageManager#FEATURE_TELEPHONY_EUICC}.\n     * @hide\n     ",
    "links" : [ "android.content.pm.PackageManager#FEATURE_TELEPHONY_EUICC", "#isSupportedCountry" ]
  }, {
    "name" : "public List<String> getSupportedCountries()",
    "returnType" : "List<String>",
    "comment" : "\n     * Gets the supported countries for eUICC.\n     *\n     * <p>Requires that the calling app has the\n     * {@code android.Manifest.permission#WRITE_EMBEDDED_SUBSCRIPTIONS} permission.\n     *\n     * @return list of strings contains country ISO codes in uppercase.\n     *\n     * @throws UnsupportedOperationException If the device does not have\n     *          {@link PackageManager#FEATURE_TELEPHONY_EUICC}.\n     * @hide\n     ",
    "links" : [ "android.content.pm.PackageManager#FEATURE_TELEPHONY_EUICC" ]
  }, {
    "name" : "public List<String> getUnsupportedCountries()",
    "returnType" : "List<String>",
    "comment" : "\n     * Gets the unsupported countries for eUICC.\n     *\n     * <p>Requires that the calling app has the\n     * {@code android.Manifest.permission#WRITE_EMBEDDED_SUBSCRIPTIONS} permission.\n     *\n     * @return list of strings contains country ISO codes in uppercase.\n     *\n     * @throws UnsupportedOperationException If the device does not have\n     *          {@link PackageManager#FEATURE_TELEPHONY_EUICC}.\n     * @hide\n     ",
    "links" : [ "android.content.pm.PackageManager#FEATURE_TELEPHONY_EUICC" ]
  }, {
    "name" : "public boolean isSupportedCountry(@NonNull String countryIso)",
    "returnType" : "boolean",
    "comment" : "\n     * Returns whether the given country supports eUICC.\n     *\n     * <p>Supported country list has a higher prority than unsupported country list. If the\n     * supported country list is not empty, {@code countryIso} will be considered as supported when\n     * it exists in the supported country list. Otherwise {@code countryIso} is not supported. If\n     * the supported country list is empty, {@code countryIso} will be considered as supported if it\n     * does not exist in the unsupported country list. Otherwise {@code countryIso} is not\n     * supported. If both supported and unsupported country lists are empty, then all countries are\n     * consider be supported. For how to set supported and unsupported country list, please check\n     * {@link #setSupportedCountries} and {@link #setUnsupportedCountries}.\n     *\n     * @param countryIso should be the ISO-3166 country code is provided in uppercase 2 character\n     * format.\n     * @return whether the given country supports eUICC or not.\n     *\n     * @throws UnsupportedOperationException If the device does not have\n     *          {@link PackageManager#FEATURE_TELEPHONY_EUICC}.\n     * @hide\n     ",
    "links" : [ "#setUnsupportedCountries", "android.content.pm.PackageManager#FEATURE_TELEPHONY_EUICC", "#setSupportedCountries" ]
  }, {
    "name" : "private boolean refreshCardIdIfUninitialized()",
    "returnType" : "boolean",
    "comment" : "\n     * Refreshes the cardId if its uninitialized, and returns whether we should continue the\n     * operation.\n     * <p>\n     * Note that after a successful refresh, the mCardId may be TelephonyManager.UNSUPPORTED_CARD_ID\n     * on older HALs. For backwards compatability, we continue to the LPA and let it decide which\n     * card to use.\n     ",
    "links" : [ ]
  }, {
    "name" : "private static void sendUnavailableError(PendingIntent callbackIntent)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private static IEuiccController getIEuiccController()",
    "returnType" : "IEuiccController",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private int getCardIdForDefaultEuicc()",
    "returnType" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public boolean isSimPortAvailable(int portIndex)",
    "returnType" : "boolean",
    "comment" : "\n     * Returns whether the passing portIndex is available.\n     * A port is available if it is active without enabled profile on it or\n     * calling app has carrier privilege over the profile installed on the selected port.\n     *\n     * <p> From Android U, a port is available if it is active without an enabled profile on it or\n     * calling app can activate a new profile on the selected port without any user interaction.\n     *\n     * Always returns false if the cardId is a physical card.\n     *\n     * @param portIndex is an enumeration of the ports available on the UICC.\n     * @return {@code true} if port is available\n     *\n     * @throws UnsupportedOperationException If the device does not have\n     *          {@link PackageManager#FEATURE_TELEPHONY_EUICC}.\n     ",
    "links" : [ "android.content.pm.PackageManager#FEATURE_TELEPHONY_EUICC" ]
  }, {
    "name" : "public void setPsimConversionSupportedCarriers(@NonNull Set<Integer> carrierIds)",
    "returnType" : "void",
    "comment" : "\n     * Sets the supported carrier ids for pSIM conversion.\n     *\n     * <p>Any existing pSIM conversion supported carrier list will be replaced\n     * by the {@code carrierIds} set here.\n     *\n     * @param carrierIds is a list of carrierIds that supports pSIM conversion\n     *\n     * @throws UnsupportedOperationException If the device does not have\n     *          {@link PackageManager#FEATURE_TELEPHONY_EUICC}.\n     * @throws IllegalStateException if this method is called when {@link #isEnabled} is false.\n     * @hide\n     ",
    "links" : [ "android.content.pm.PackageManager#FEATURE_TELEPHONY_EUICC", "#isEnabled" ]
  }, {
    "name" : "public boolean isPsimConversionSupported(int carrierId)",
    "returnType" : "boolean",
    "comment" : "\n     * Returns whether the given carrier id supports pSIM conversion or not.\n     *\n     * @param carrierId to check whether pSIM conversion is supported or not\n     * @return whether the given carrier id supports pSIM conversion or not,\n     *         or false if {@link #isEnabled} is false\n     *\n     * @throws UnsupportedOperationException If the device does not have\n     *          {@link PackageManager#FEATURE_TELEPHONY_EUICC}.\n     * @hide\n     ",
    "links" : [ "android.content.pm.PackageManager#FEATURE_TELEPHONY_EUICC", "#isEnabled" ]
  } ],
  "methodNames" : [ "public EuiccManager createForCardId(int cardId)", "public boolean isEnabled()", "public String getEid()", "public long getAvailableMemoryInBytes()", "public int getOtaStatus()", "public void downloadSubscription(DownloadableSubscription subscription, boolean switchAfterDownload, PendingIntent callbackIntent)", "public void startResolutionActivity(Activity activity, int requestCode, Intent resultIntent, PendingIntent callbackIntent) throws IntentSender.SendIntentException", "public void continueOperation(Intent resolutionIntent, Bundle resolutionExtras)", "public void getDownloadableSubscriptionMetadata(DownloadableSubscription subscription, PendingIntent callbackIntent)", "public void getDefaultDownloadableSubscriptionList(PendingIntent callbackIntent)", "public EuiccInfo getEuiccInfo()", "public void deleteSubscription(int subscriptionId, PendingIntent callbackIntent)", "public void switchToSubscription(int subscriptionId, PendingIntent callbackIntent)", "public void switchToSubscription(int subscriptionId, int portIndex, @NonNull PendingIntent callbackIntent)", "public void updateSubscriptionNickname(int subscriptionId, @Nullable String nickname, @NonNull PendingIntent callbackIntent)", "public void eraseSubscriptions(@NonNull PendingIntent callbackIntent)", "public void eraseSubscriptions(@ResetOption int options, @NonNull PendingIntent callbackIntent)", "public void retainSubscriptionsForFactoryReset(PendingIntent callbackIntent)", "public void setSupportedCountries(@NonNull List<String> supportedCountries)", "public void setUnsupportedCountries(@NonNull List<String> unsupportedCountries)", "public List<String> getSupportedCountries()", "public List<String> getUnsupportedCountries()", "public boolean isSupportedCountry(@NonNull String countryIso)", "private boolean refreshCardIdIfUninitialized()", "private static void sendUnavailableError(PendingIntent callbackIntent)", "private static IEuiccController getIEuiccController()", "private int getCardIdForDefaultEuicc()", "public boolean isSimPortAvailable(int portIndex)", "public void setPsimConversionSupportedCarriers(@NonNull Set<Integer> carrierIds)", "public boolean isPsimConversionSupported(int carrierId)" ],
  "variableNames" : [ "TAG", "ACTION_MANAGE_EMBEDDED_SUBSCRIPTIONS", "ACTION_TRANSFER_EMBEDDED_SUBSCRIPTIONS", "ACTION_CONVERT_TO_EMBEDDED_SUBSCRIPTION", "ACTION_OTA_STATUS_CHANGED", "ACTION_NOTIFY_CARRIER_SETUP_INCOMPLETE", "ACTION_PROVISION_EMBEDDED_SUBSCRIPTION", "ACTION_RESOLVE_ERROR", "ACTION_TOGGLE_SUBSCRIPTION_PRIVILEGED", "ACTION_DELETE_SUBSCRIPTION_PRIVILEGED", "ACTION_RENAME_SUBSCRIPTION_PRIVILEGED", "ACTION_START_EUICC_ACTIVATION", "EMBEDDED_SUBSCRIPTION_RESULT_OK", "EMBEDDED_SUBSCRIPTION_RESULT_RESOLVABLE_ERROR", "EMBEDDED_SUBSCRIPTION_RESULT_ERROR", "EXTRA_ACTIVATION_TYPE", "EXTRA_EMBEDDED_SUBSCRIPTION_DETAILED_CODE", "EXTRA_EMBEDDED_SUBSCRIPTION_OPERATION_CODE", "EXTRA_EMBEDDED_SUBSCRIPTION_ERROR_CODE", "EXTRA_EMBEDDED_SUBSCRIPTION_SMDX_SUBJECT_CODE", "EXTRA_EMBEDDED_SUBSCRIPTION_SMDX_REASON_CODE", "EXTRA_EMBEDDED_SUBSCRIPTION_DOWNLOADABLE_SUBSCRIPTION", "EXTRA_EMBEDDED_SUBSCRIPTION_DOWNLOADABLE_SUBSCRIPTIONS", "EXTRA_EMBEDDED_SUBSCRIPTION_RESOLUTION_INTENT", "EXTRA_EMBEDDED_SUBSCRIPTION_RESOLUTION_ACTION", "EXTRA_EMBEDDED_SUBSCRIPTION_RESOLUTION_CALLBACK_INTENT", "EXTRA_FORCE_PROVISION", "EXTRA_SUBSCRIPTION_ID", "EXTRA_ENABLE_SUBSCRIPTION", "EXTRA_SUBSCRIPTION_NICKNAME", "EXTRA_FROM_SUBSCRIPTION_ID", "EXTRA_PHYSICAL_SLOT_ID", "EXTRA_USE_QR_SCANNER", "META_DATA_CARRIER_ICON", "EUICC_ACTIVATION_TYPE_DEFAULT", "EUICC_ACTIVATION_TYPE_BACKUP", "EUICC_ACTIVATION_TYPE_TRANSFER", "EUICC_ACTIVATION_TYPE_ACCOUNT_REQUIRED", "EUICC_ACTIVATION_TYPE_TRANSFER_FINAL_HOLD", "EUICC_OTA_IN_PROGRESS", "EUICC_OTA_FAILED", "EUICC_OTA_SUCCEEDED", "EUICC_OTA_NOT_NEEDED", "EUICC_OTA_STATUS_UNAVAILABLE", "OPERATION_SYSTEM", "OPERATION_SIM_SLOT", "OPERATION_EUICC_CARD", "OPERATION_SWITCH", "OPERATION_DOWNLOAD", "OPERATION_METADATA", "OPERATION_EUICC_GSMA", "OPERATION_APDU", "OPERATION_SMDX", "OPERATION_SMDX_SUBJECT_REASON_CODE", "OPERATION_HTTP", "ERROR_CARRIER_LOCKED", "ERROR_INVALID_ACTIVATION_CODE", "ERROR_INVALID_CONFIRMATION_CODE", "ERROR_INCOMPATIBLE_CARRIER", "ERROR_EUICC_INSUFFICIENT_MEMORY", "ERROR_TIME_OUT", "ERROR_EUICC_MISSING", "ERROR_UNSUPPORTED_VERSION", "ERROR_SIM_MISSING", "ERROR_INSTALL_PROFILE", "ERROR_DISALLOWED_BY_PPR", "ERROR_ADDRESS_MISSING", "ERROR_CERTIFICATE_ERROR", "ERROR_NO_PROFILES_AVAILABLE", "ERROR_CONNECTION_ERROR", "ERROR_INVALID_RESPONSE", "ERROR_OPERATION_BUSY", "ERROR_INVALID_PORT", "EUICC_MEMORY_FIELD_UNAVAILABLE", "SWITCH_WITHOUT_PORT_INDEX_EXCEPTION_ON_DISABLE", "SHOULD_RESOLVE_PORT_INDEX_FOR_APPS", "INACTIVE_PORT_AVAILABILITY_CHECK", "mContext", "mCardId" ]
}