{
  "filePath" : "/home/maryam/clearblue/files/android-source-35/android/app/blob/BlobStoreManager.java",
  "packageName" : "android.app.blob",
  "className" : "BlobStoreManager",
  "comment" : "\n * This class provides access to the blob store managed by the system.\n *\n * <p> Apps can publish and access a data blob using a {@link BlobHandle} object which can\n * be created with {@link BlobHandle#createWithSha256(byte[], CharSequence, long, String)}.\n * This {@link BlobHandle} object encapsulates the following pieces of information used for\n * identifying the blobs:\n * <ul>\n *     <li> {@link BlobHandle#getSha256Digest()}\n *     <li> {@link BlobHandle#getLabel()}\n *     <li> {@link BlobHandle#getExpiryTimeMillis()}\n *     <li> {@link BlobHandle#getTag()}\n * </ul>\n * For two {@link BlobHandle} objects to be considered identical, all these pieces of information\n * must be equal.\n *\n * <p> For contributing a new data blob, an app needs to create a session using\n * {@link BlobStoreManager#createSession(BlobHandle)} and then open this session for writing using\n * {@link BlobStoreManager#openSession(long)}.\n *\n * <p> The following code snippet shows how to create and open a session for writing:\n * <pre class=\"prettyprint\">\n *     final long sessionId = blobStoreManager.createSession(blobHandle);\n *     try (BlobStoreManager.Session session = blobStoreManager.openSession(sessionId)) {\n *         try (OutputStream out = new ParcelFileDescriptor.AutoCloseOutputStream(\n *                 session.openWrite(offsetBytes, lengthBytes))) {\n *             writeData(out);\n *         }\n *     }\n * </pre>\n *\n * <p> If all the data could not be written in a single attempt, apps can close this session\n * and re-open it again using the session id obtained via\n * {@link BlobStoreManager#createSession(BlobHandle)}. Note that the session data is persisted\n * and can be re-opened for completing the data contribution, even across device reboots.\n *\n * <p> After the data is written to the session, it can be committed using\n * {@link Session#commit(Executor, Consumer)}. Until the session is committed, data written\n * to the session will not be shared with any app.\n *\n * <p class=\"note\"> Once a session is committed using {@link Session#commit(Executor, Consumer)},\n * any data written as part of this session is sealed and cannot be modified anymore.\n *\n * <p> Before committing the session, apps can indicate which apps are allowed to access the\n * contributed data using one or more of the following access modes:\n * <ul>\n *     <li> {@link Session#allowPackageAccess(String, byte[])} which will allow specific packages\n *          to access the blobs.\n *     <li> {@link Session#allowSameSignatureAccess()} which will allow only apps which are signed\n *          with the same certificate as the app which contributed the blob to access it.\n *     <li> {@link Session#allowPublicAccess()} which will allow any app on the device to access\n *          the blob.\n * </ul>\n *\n * <p> The following code snippet shows how to specify the access mode and commit the session:\n * <pre class=\"prettyprint\">\n *     try (BlobStoreManager.Session session = blobStoreManager.openSession(sessionId)) {\n *         try (OutputStream out = new ParcelFileDescriptor.AutoCloseOutputStream(\n *                 session.openWrite(offsetBytes, lengthBytes))) {\n *             writeData(out);\n *         }\n *         session.allowSameSignatureAccess();\n *         session.allowPackageAccess(packageName, certificate);\n *         session.commit(executor, callback);\n *     }\n * </pre>\n *\n * <p> Apps that satisfy at least one of the access mode constraints specified by the publisher\n * of the data blob will be able to access it.\n *\n * <p> A data blob published without specifying any of\n * these access modes will be considered private and only the app that contributed the data\n * blob will be allowed to access it. This is still useful for overall device system health as\n * the System can try to keep one copy of data blob on disk when multiple apps contribute the\n * same data.\n *\n * <p class=\"note\"> It is strongly recommended that apps use one of\n * {@link Session#allowPackageAccess(String, byte[])} or {@link Session#allowSameSignatureAccess()}\n * when they know, ahead of time, the set of apps they would like to share the blobs with.\n * {@link Session#allowPublicAccess()} is meant for publicly available data committed from\n * libraries and SDKs.\n *\n * <p> Once a data blob is committed with {@link Session#commit(Executor, Consumer)}, it\n * can be accessed using {@link BlobStoreManager#openBlob(BlobHandle)}, assuming the caller\n * satisfies constraints of any of the access modes associated with that data blob. An app may\n * acquire a lease on a blob with {@link BlobStoreManager#acquireLease(BlobHandle, int)} and\n * release the lease with {@link BlobStoreManager#releaseLease(BlobHandle)}. A blob will not be\n * deleted from the system while there is at least one app leasing it.\n *\n * <p> The following code snippet shows how to access the data blob:\n * <pre class=\"prettyprint\">\n *     try (InputStream in = new ParcelFileDescriptor.AutoCloseInputStream(\n *             blobStoreManager.openBlob(blobHandle)) {\n *         useData(in);\n *     }\n * </pre>\n ",
  "links" : [ "#allowPublicAccess()", "android.app.blob.BlobHandle#getTag()", "#commit(Executor", "android.app.blob.BlobHandle#getLabel()", "android.app.blob.BlobHandle#getSha256Digest()", "android.app.blob.BlobHandle#getExpiryTimeMillis()", "android.app.blob.BlobStoreManager#acquireLease(BlobHandle", "#allowPackageAccess(String", "android.app.blob.BlobHandle#createWithSha256(byte", "#allowSameSignatureAccess()", "android.app.blob.BlobStoreManager#openBlob(BlobHandle)", "android.app.blob.BlobStoreManager#releaseLease(BlobHandle)", "android.app.blob.BlobStoreManager#createSession(BlobHandle)", "android.app.blob.BlobStoreManager#openSession(long)", "android.app.blob.BlobHandle" ],
  "variables" : [ {
    "name" : "COMMIT_RESULT_SUCCESS",
    "type" : "int",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "COMMIT_RESULT_ERROR",
    "type" : "int",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "INVALID_RES_ID",
    "type" : "int",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "mContext",
    "type" : "Context",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mService",
    "type" : "IBlobStoreManager",
    "comment" : "",
    "links" : [ ]
  } ],
  "methods" : [ {
    "name" : "public long createSession(@NonNull BlobHandle blobHandle) throws IOException",
    "returnType" : "long",
    "comment" : "\n     * Create a new session using the given {@link BlobHandle}, returning a unique id\n     * that represents the session. Once created, the session can be opened\n     * multiple times across multiple device boots.\n     *\n     * <p> The system may automatically destroy sessions that have not been\n     * finalized (either committed or abandoned) within a reasonable period of\n     * time, typically about a week.\n     *\n     * <p> If an app is planning to acquire a lease on this data (using\n     * {@link #acquireLease(BlobHandle, int)} or one of it's other variants) after committing\n     * this data (using {@link Session#commit(Executor, Consumer)}), it is recommended that\n     * the app checks the remaining quota for acquiring a lease first using\n     * {@link #getRemainingLeaseQuotaBytes()} and can skip contributing this data if needed.\n     *\n     * @param blobHandle the {@link BlobHandle} identifier for which a new session\n     *                   needs to be created.\n     * @return positive, non-zero unique id that represents the created session.\n     *         This id remains consistent across device reboots until the\n     *         session is finalized. IDs are not reused during a given boot.\n     *\n     * @throws IOException when there is an I/O error while creating the session.\n     * @throws SecurityException when the caller is not allowed to create a session, such\n     *                           as when called from an Instant app.\n     * @throws IllegalArgumentException when {@code blobHandle} is invalid.\n     * @throws LimitExceededException when a new session could not be created, such as when the\n     *                                caller is trying to create too many sessions.\n     ",
    "links" : [ "#acquireLease(BlobHandle", "#getRemainingLeaseQuotaBytes()", "#commit(Executor", "android.app.blob.BlobHandle" ]
  }, {
    "name" : "public Session openSession(@IntRange(from = 1) long sessionId) throws IOException",
    "returnType" : "Session",
    "comment" : "\n     * Open an existing session to actively perform work.\n     *\n     * @param sessionId a unique id obtained via {@link #createSession(BlobHandle)} that\n     *                  represents a particular session.\n     * @return the {@link Session} object corresponding to the {@code sessionId}.\n     *\n     * @throws IOException when there is an I/O error while opening the session.\n     * @throws SecurityException when the caller does not own the session, or\n     *                           the session does not exist or is invalid.\n     ",
    "links" : [ "#createSession(BlobHandle)", "Session" ]
  }, {
    "name" : "public void abandonSession(@IntRange(from = 1) long sessionId) throws IOException",
    "returnType" : "void",
    "comment" : "\n     * Abandons an existing session and deletes any data that was written to that session so far.\n     *\n     * @param sessionId a unique id obtained via {@link #createSession(BlobHandle)} that\n     *                  represents a particular session.\n     *\n     * @throws IOException when there is an I/O error while deleting the session.\n     * @throws SecurityException when the caller does not own the session, or\n     *                           the session does not exist or is invalid.\n     ",
    "links" : [ "#createSession(BlobHandle)" ]
  }, {
    "name" : "public ParcelFileDescriptor openBlob(@NonNull BlobHandle blobHandle) throws IOException",
    "returnType" : "ParcelFileDescriptor",
    "comment" : "\n     * Opens an existing blob for reading from the blob store managed by the system.\n     *\n     * @param blobHandle the {@link BlobHandle} representing the blob that the caller\n     *                   wants to access.\n     * @return a {@link ParcelFileDescriptor} that can be used to read the blob content.\n     *\n     * @throws IOException when there is an I/O while opening the blob for read.\n     * @throws IllegalArgumentException when {@code blobHandle} is invalid.\n     * @throws SecurityException when the blob represented by the {@code blobHandle} does not\n     *                           exist or the caller does not have access to it.\n     ",
    "links" : [ "android.os.ParcelFileDescriptor", "android.app.blob.BlobHandle" ]
  }, {
    "name" : "public void acquireLease(@NonNull BlobHandle blobHandle, @IdRes int descriptionResId, @CurrentTimeMillisLong long leaseExpiryTimeMillis) throws IOException",
    "returnType" : "void",
    "comment" : "\n     * Acquire a lease to the blob represented by {@code blobHandle}. This lease indicates to the\n     * system that the caller wants the blob to be kept around.\n     *\n     * <p> Any active leases will be automatically released when the blob's expiry time\n     * ({@link BlobHandle#getExpiryTimeMillis()}) is elapsed.\n     *\n     * <p> This lease information is persisted and calling this more than once will result in\n     * latest lease overriding any previous lease.\n     *\n     * <p> When an app acquires a lease on a blob, the System will try to keep this\n     * blob around but note that it can still be deleted if it was requested by the user.\n     *\n     * <p> In case the resource name for the {@code descriptionResId} is modified as part of\n     * an app update, apps should re-acquire the lease with the new resource id.\n     *\n     * @param blobHandle the {@link BlobHandle} representing the blob that the caller wants to\n     *                   acquire a lease for.\n     * @param descriptionResId the resource id for a short description string that can be surfaced\n     *                         to the user explaining what the blob is used for.\n     * @param leaseExpiryTimeMillis the time in milliseconds after which the lease can be\n     *                              automatically released, in {@link System#currentTimeMillis()}\n     *                              timebase. If its value is {@code 0}, then the behavior of this\n     *                              API is identical to {@link #acquireLease(BlobHandle, int)}\n     *                              where clients have to explicitly call\n     *                              {@link #releaseLease(BlobHandle)} when they don't\n     *                              need the blob anymore.\n     *\n     * @throws IOException when there is an I/O error while acquiring a lease to the blob.\n     * @throws SecurityException when the blob represented by the {@code blobHandle} does not\n     *                           exist or the caller does not have access to it.\n     * @throws IllegalArgumentException when {@code blobHandle} is invalid or\n     *                                  if the {@code leaseExpiryTimeMillis} is greater than the\n     *                                  {@link BlobHandle#getExpiryTimeMillis()}.\n     * @throws LimitExceededException when a lease could not be acquired, such as when the\n     *                                caller is trying to acquire too many leases or acquire\n     *                                leases on too much data. Apps can avoid this by checking\n     *                                the remaining quota using\n     *                                {@link #getRemainingLeaseQuotaBytes()} before trying to\n     *                                acquire a lease.\n     *\n     * @see #acquireLease(BlobHandle, int)\n     * @see #acquireLease(BlobHandle, CharSequence)\n     ",
    "links" : [ "#currentTimeMillis()", "#releaseLease(BlobHandle)", "android.app.blob.BlobHandle#getExpiryTimeMillis()", "#acquireLease(BlobHandle", "#getRemainingLeaseQuotaBytes()", "android.app.blob.BlobHandle" ]
  }, {
    "name" : "public void acquireLease(@NonNull BlobHandle blobHandle, @NonNull CharSequence description, @CurrentTimeMillisLong long leaseExpiryTimeMillis) throws IOException",
    "returnType" : "void",
    "comment" : "\n     * Acquire a lease to the blob represented by {@code blobHandle}. This lease indicates to the\n     * system that the caller wants the blob to be kept around.\n     *\n     * <p> This is a variant of {@link #acquireLease(BlobHandle, int, long)} taking a\n     * {@link CharSequence} for {@code description}. It is highly recommended that callers only\n     * use this when a valid resource ID for {@code description} could not be provided. Otherwise,\n     * apps should prefer using {@link #acquireLease(BlobHandle, int)} which will allow\n     * {@code description} to be localized.\n     *\n     * <p> Any active leases will be automatically released when the blob's expiry time\n     * ({@link BlobHandle#getExpiryTimeMillis()}) is elapsed.\n     *\n     * <p> This lease information is persisted and calling this more than once will result in\n     * latest lease overriding any previous lease.\n     *\n     * <p> When an app acquires a lease on a blob, the System will try to keep this\n     * blob around but note that it can still be deleted if it was requested by the user.\n     *\n     * @param blobHandle the {@link BlobHandle} representing the blob that the caller wants to\n     *                   acquire a lease for.\n     * @param description a short description string that can be surfaced\n     *                    to the user explaining what the blob is used for. It is recommended to\n     *                    keep this description brief. This may be truncated and ellipsized\n     *                    if it is too long to be displayed to the user.\n     * @param leaseExpiryTimeMillis the time in milliseconds after which the lease can be\n     *                              automatically released, in {@link System#currentTimeMillis()}\n     *                              timebase. If its value is {@code 0}, then the behavior of this\n     *                              API is identical to {@link #acquireLease(BlobHandle, int)}\n     *                              where clients have to explicitly call\n     *                              {@link #releaseLease(BlobHandle)} when they don't\n     *                              need the blob anymore.\n     *\n     * @throws IOException when there is an I/O error while acquiring a lease to the blob.\n     * @throws SecurityException when the blob represented by the {@code blobHandle} does not\n     *                           exist or the caller does not have access to it.\n     * @throws IllegalArgumentException when {@code blobHandle} is invalid or\n     *                                  if the {@code leaseExpiryTimeMillis} is greater than the\n     *                                  {@link BlobHandle#getExpiryTimeMillis()}.\n     * @throws LimitExceededException when a lease could not be acquired, such as when the\n     *                                caller is trying to acquire too many leases or acquire\n     *                                leases on too much data. Apps can avoid this by checking\n     *                                the remaining quota using\n     *                                {@link #getRemainingLeaseQuotaBytes()} before trying to\n     *                                acquire a lease.\n     *\n     * @see #acquireLease(BlobHandle, int, long)\n     * @see #acquireLease(BlobHandle, CharSequence)\n     ",
    "links" : [ "#currentTimeMillis()", "#releaseLease(BlobHandle)", "#acquireLease(BlobHandle", "android.app.blob.BlobHandle#getExpiryTimeMillis()", "#getRemainingLeaseQuotaBytes()", "CharSequence", "android.app.blob.BlobHandle" ]
  }, {
    "name" : "public void acquireLease(@NonNull BlobHandle blobHandle, @IdRes int descriptionResId) throws IOException",
    "returnType" : "void",
    "comment" : "\n     * Acquire a lease to the blob represented by {@code blobHandle}. This lease indicates to the\n     * system that the caller wants the blob to be kept around.\n     *\n     * <p> This is similar to {@link #acquireLease(BlobHandle, int, long)} except clients don't\n     * have to specify the lease expiry time upfront using this API and need to explicitly\n     * release the lease using {@link #releaseLease(BlobHandle)} when they no longer like to keep\n     * a blob around.\n     *\n     * <p> Any active leases will be automatically released when the blob's expiry time\n     * ({@link BlobHandle#getExpiryTimeMillis()}) is elapsed.\n     *\n     * <p> This lease information is persisted and calling this more than once will result in\n     * latest lease overriding any previous lease.\n     *\n     * <p> When an app acquires a lease on a blob, the System will try to keep this\n     * blob around but note that it can still be deleted if it was requested by the user.\n     *\n     * <p> In case the resource name for the {@code descriptionResId} is modified as part of\n     * an app update, apps should re-acquire the lease with the new resource id.\n     *\n     * @param blobHandle the {@link BlobHandle} representing the blob that the caller wants to\n     *                   acquire a lease for.\n     * @param descriptionResId the resource id for a short description string that can be surfaced\n     *                         to the user explaining what the blob is used for.\n     *\n     * @throws IOException when there is an I/O error while acquiring a lease to the blob.\n     * @throws SecurityException when the blob represented by the {@code blobHandle} does not\n     *                           exist or the caller does not have access to it.\n     * @throws IllegalArgumentException when {@code blobHandle} is invalid.\n     * @throws LimitExceededException when a lease could not be acquired, such as when the\n     *                                caller is trying to acquire too many leases or acquire\n     *                                leases on too much data. Apps can avoid this by checking\n     *                                the remaining quota using\n     *                                {@link #getRemainingLeaseQuotaBytes()} before trying to\n     *                                acquire a lease.\n     *\n     * @see #acquireLease(BlobHandle, int, long)\n     * @see #acquireLease(BlobHandle, CharSequence, long)\n     ",
    "links" : [ "#releaseLease(BlobHandle)", "#acquireLease(BlobHandle", "android.app.blob.BlobHandle#getExpiryTimeMillis()", "#getRemainingLeaseQuotaBytes()", "android.app.blob.BlobHandle" ]
  }, {
    "name" : "public void acquireLease(@NonNull BlobHandle blobHandle, @NonNull CharSequence description) throws IOException",
    "returnType" : "void",
    "comment" : "\n     * Acquire a lease to the blob represented by {@code blobHandle}. This lease indicates to the\n     * system that the caller wants the blob to be kept around.\n     *\n     * <p> This is a variant of {@link #acquireLease(BlobHandle, int)} taking a {@link CharSequence}\n     * for {@code description}. It is highly recommended that callers only use this when a valid\n     * resource ID for {@code description} could not be provided. Otherwise, apps should prefer\n     * using {@link #acquireLease(BlobHandle, int)} which will allow {@code description} to be\n     * localized.\n     *\n     * <p> This is similar to {@link #acquireLease(BlobHandle, CharSequence, long)} except clients\n     * don't have to specify the lease expiry time upfront using this API and need to explicitly\n     * release the lease using {@link #releaseLease(BlobHandle)} when they no longer like to keep\n     * a blob around.\n     *\n     * <p> Any active leases will be automatically released when the blob's expiry time\n     * ({@link BlobHandle#getExpiryTimeMillis()}) is elapsed.\n     *\n     * <p> This lease information is persisted and calling this more than once will result in\n     * latest lease overriding any previous lease.\n     *\n     * <p> When an app acquires a lease on a blob, the System will try to keep this\n     * blob around but note that it can still be deleted if it was requested by the user.\n     *\n     * @param blobHandle the {@link BlobHandle} representing the blob that the caller wants to\n     *                   acquire a lease for.\n     * @param description a short description string that can be surfaced\n     *                    to the user explaining what the blob is used for. It is recommended to\n     *                    keep this description brief. This may be truncated and\n     *                    ellipsized if it is too long to be displayed to the user.\n     *\n     * @throws IOException when there is an I/O error while acquiring a lease to the blob.\n     * @throws SecurityException when the blob represented by the {@code blobHandle} does not\n     *                           exist or the caller does not have access to it.\n     * @throws IllegalArgumentException when {@code blobHandle} is invalid.\n     * @throws LimitExceededException when a lease could not be acquired, such as when the\n     *                                caller is trying to acquire too many leases or acquire\n     *                                leases on too much data. Apps can avoid this by checking\n     *                                the remaining quota using\n     *                                {@link #getRemainingLeaseQuotaBytes()} before trying to\n     *                                acquire a lease.\n     *\n     * @see #acquireLease(BlobHandle, int)\n     * @see #acquireLease(BlobHandle, CharSequence, long)\n     ",
    "links" : [ "#releaseLease(BlobHandle)", "#acquireLease(BlobHandle", "android.app.blob.BlobHandle#getExpiryTimeMillis()", "#getRemainingLeaseQuotaBytes()", "CharSequence", "android.app.blob.BlobHandle" ]
  }, {
    "name" : "public void releaseLease(@NonNull BlobHandle blobHandle) throws IOException",
    "returnType" : "void",
    "comment" : "\n     * Release any active lease to the blob represented by {@code blobHandle} which is\n     * currently held by the caller.\n     *\n     * @param blobHandle the {@link BlobHandle} representing the blob that the caller wants to\n     *                   release the lease for.\n     *\n     * @throws IOException when there is an I/O error while releasing the release to the blob.\n     * @throws SecurityException when the blob represented by the {@code blobHandle} does not\n     *                           exist or the caller does not have access to it.\n     * @throws IllegalArgumentException when {@code blobHandle} is invalid.\n     ",
    "links" : [ "android.app.blob.BlobHandle" ]
  }, {
    "name" : "public void releaseAllLeases() throws Exception",
    "returnType" : "void",
    "comment" : "\n     * Release all the leases which are currently held by the caller.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public long getRemainingLeaseQuotaBytes()",
    "returnType" : "long",
    "comment" : "\n     * Return the remaining quota size for acquiring a lease (in bytes) which indicates the\n     * remaining amount of data that an app can acquire a lease on before the System starts\n     * rejecting lease requests.\n     *\n     * If an app wants to acquire a lease on a blob but the remaining quota size is not sufficient,\n     * then it can try releasing leases on any older blobs which are not needed anymore.\n     *\n     * @return the remaining quota size for acquiring a lease.\n     ",
    "links" : [ ]
  }, {
    "name" : "public void waitForIdle(long timeoutMillis) throws InterruptedException, TimeoutException",
    "returnType" : "void",
    "comment" : "\n     * Wait until any pending tasks (like persisting data to disk) have finished.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public List<BlobInfo> queryBlobsForUser(@NonNull UserHandle user) throws IOException",
    "returnType" : "List<BlobInfo>",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "public void deleteBlob(@NonNull BlobInfo blobInfo) throws IOException",
    "returnType" : "void",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "public List<BlobHandle> getLeasedBlobs() throws IOException",
    "returnType" : "List<BlobHandle>",
    "comment" : "\n     * Return the {@link BlobHandle BlobHandles} corresponding to the data blobs that\n     * the calling app currently has a lease on.\n     *\n     * @return a list of {@link BlobHandle BlobHandles} that the caller has a lease on.\n     ",
    "links" : [ "android.app.blob.BlobHandle" ]
  }, {
    "name" : "public LeaseInfo getLeaseInfo(@NonNull BlobHandle blobHandle) throws IOException",
    "returnType" : "LeaseInfo",
    "comment" : "\n     * Return {@link LeaseInfo} representing a lease acquired using\n     * {@link #acquireLease(BlobHandle, int)} or one of it's other variants,\n     * or {@code null} if there is no lease acquired.\n     *\n     * @throws SecurityException when the blob represented by the {@code blobHandle} does not\n     *                           exist or the caller does not have access to it.\n     * @throws IllegalArgumentException when {@code blobHandle} is invalid.\n     *\n     * @hide\n     ",
    "links" : [ "#acquireLease(BlobHandle", "android.app.blob.LeaseInfo" ]
  } ],
  "methodNames" : [ "public long createSession(@NonNull BlobHandle blobHandle) throws IOException", "public Session openSession(@IntRange(from = 1) long sessionId) throws IOException", "public void abandonSession(@IntRange(from = 1) long sessionId) throws IOException", "public ParcelFileDescriptor openBlob(@NonNull BlobHandle blobHandle) throws IOException", "public void acquireLease(@NonNull BlobHandle blobHandle, @IdRes int descriptionResId, @CurrentTimeMillisLong long leaseExpiryTimeMillis) throws IOException", "public void acquireLease(@NonNull BlobHandle blobHandle, @NonNull CharSequence description, @CurrentTimeMillisLong long leaseExpiryTimeMillis) throws IOException", "public void acquireLease(@NonNull BlobHandle blobHandle, @IdRes int descriptionResId) throws IOException", "public void acquireLease(@NonNull BlobHandle blobHandle, @NonNull CharSequence description) throws IOException", "public void releaseLease(@NonNull BlobHandle blobHandle) throws IOException", "public void releaseAllLeases() throws Exception", "public long getRemainingLeaseQuotaBytes()", "public void waitForIdle(long timeoutMillis) throws InterruptedException, TimeoutException", "public List<BlobInfo> queryBlobsForUser(@NonNull UserHandle user) throws IOException", "public void deleteBlob(@NonNull BlobInfo blobInfo) throws IOException", "public List<BlobHandle> getLeasedBlobs() throws IOException", "public LeaseInfo getLeaseInfo(@NonNull BlobHandle blobHandle) throws IOException" ],
  "variableNames" : [ "COMMIT_RESULT_SUCCESS", "COMMIT_RESULT_ERROR", "INVALID_RES_ID", "mContext", "mService" ]
}