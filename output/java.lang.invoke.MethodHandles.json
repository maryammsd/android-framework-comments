{
  "filePath" : "/home/maryam/clearblue/files/android-source-35/java/lang/invoke/MethodHandles.java",
  "packageName" : "java.lang.invoke",
  "className" : "MethodHandles",
  "comment" : "\n * This class consists exclusively of static methods that operate on or return\n * method handles. They fall into several categories:\n * <ul>\n * <li>Lookup methods which help create method handles for methods and fields.\n * <li>Combinator methods, which combine or transform pre-existing method handles into new ones.\n * <li>Other factory methods to create method handles that emulate other common JVM operations or control flow patterns.\n * </ul>\n * <p>\n * @author John Rose, JSR 292 EG\n * @since 1.7\n ",
  "links" : [ ],
  "variables" : [ {
    "name" : "IDENTITY_MHS",
    "type" : "MethodHandle[]",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "ZERO_MHS",
    "type" : "MethodHandle[]",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "MH_cast",
    "type" : "int",
    "comment" : " Indexes into constant method handles:",
    "links" : [ ]
  }, {
    "name" : "MH_selectAlternative",
    "type" : "int",
    "comment" : " Indexes into constant method handles:",
    "links" : [ ]
  }, {
    "name" : "MH_copyAsPrimitiveArray",
    "type" : "int",
    "comment" : " Indexes into constant method handles:",
    "links" : [ ]
  }, {
    "name" : "MH_fillNewTypedArray",
    "type" : "int",
    "comment" : " Indexes into constant method handles:",
    "links" : [ ]
  }, {
    "name" : "MH_fillNewArray",
    "type" : "int",
    "comment" : " Indexes into constant method handles:",
    "links" : [ ]
  }, {
    "name" : "MH_arrayIdentity",
    "type" : "int",
    "comment" : " Indexes into constant method handles:",
    "links" : [ ]
  }, {
    "name" : "MH_countedLoopPred",
    "type" : "int",
    "comment" : " Indexes into constant method handles:",
    "links" : [ ]
  }, {
    "name" : "MH_countedLoopStep",
    "type" : "int",
    "comment" : " Indexes into constant method handles:",
    "links" : [ ]
  }, {
    "name" : "MH_initIterator",
    "type" : "int",
    "comment" : " Indexes into constant method handles:",
    "links" : [ ]
  }, {
    "name" : "MH_iteratePred",
    "type" : "int",
    "comment" : " Indexes into constant method handles:",
    "links" : [ ]
  }, {
    "name" : "MH_iterateNext",
    "type" : "int",
    "comment" : " Indexes into constant method handles:",
    "links" : [ ]
  }, {
    "name" : "MH_Array_newInstance",
    "type" : "int",
    "comment" : " Indexes into constant method handles:",
    "links" : [ ]
  }, {
    "name" : "MH_LIMIT",
    "type" : "int",
    "comment" : " Indexes into constant method handles:",
    "links" : [ ]
  }, {
    "name" : "HANDLES",
    "type" : "MethodHandle[]",
    "comment" : " Local constant method handles:",
    "links" : [ ]
  } ],
  "methods" : [ {
    "name" : "public static Lookup lookup()",
    "returnType" : "Lookup",
    "comment" : " @CallerSensitive",
    "links" : [ ]
  }, {
    "name" : "public static Lookup publicLookup()",
    "returnType" : "Lookup",
    "comment" : "\n     * Returns a {@link Lookup lookup object} which is trusted minimally.\n     * It can only be used to create method handles to\n     * publicly accessible fields and methods.\n     * <p>\n     * As a matter of pure convention, the {@linkplain Lookup#lookupClass lookup class}\n     * of this lookup object will be {@link java.lang.Object}.\n     *\n     * <p style=\"font-size:smaller;\">\n     * <em>Discussion:</em>\n     * The lookup class can be changed to any other class {@code C} using an expression of the form\n     * {@link Lookup#in publicLookup().in(C.class)}.\n     * Since all classes have equal access to public names,\n     * such a change would confer no new access rights.\n     * A public lookup object is always subject to\n     * <a href=\"MethodHandles.Lookup.html#secmgr\">security manager checks</a>.\n     * Also, it cannot access\n     * <a href=\"MethodHandles.Lookup.html#callsens\">caller sensitive methods</a>.\n     * @return a lookup object which is trusted minimally\n     ",
    "links" : [ "#in", "Lookup", "java.lang.Object" ]
  }, {
    "name" : "public static Lookup privateLookupIn(Class<?> targetClass, Lookup lookup) throws IllegalAccessException",
    "returnType" : "Lookup",
    "comment" : "\n     * Returns a {@link Lookup lookup object} with full capabilities to emulate all\n     * supported bytecode behaviors, including <a href=\"MethodHandles.Lookup.html#privacc\">\n     * private access</a>, on a target class.\n     * @param targetClass the target class\n     * @param lookup the caller lookup object\n     * @return a lookup object for the target class, with private access\n     * @throws IllegalArgumentException if {@code targetClass} is a primitive type or array class\n     * @throws NullPointerException if {@code targetClass} or {@code caller} is {@code null}\n     * @throws IllegalAccessException is not thrown on Android\n     * @since 9\n     ",
    "links" : [ "Lookup" ]
  }, {
    "name" : "public static T reflectAs(Class<T> expected, MethodHandle target)",
    "returnType" : "T",
    "comment" : "\n     * Performs an unchecked \"crack\" of a\n     * <a href=\"MethodHandleInfo.html#directmh\">direct method handle</a>.\n     * The result is as if the user had obtained a lookup object capable enough\n     * to crack the target method handle, called\n     * {@link java.lang.invoke.MethodHandles.Lookup#revealDirect Lookup.revealDirect}\n     * on the target to obtain its symbolic reference, and then called\n     * {@link java.lang.invoke.MethodHandleInfo#reflectAs MethodHandleInfo.reflectAs}\n     * to resolve the symbolic reference to a member.\n     * <p>\n     * If there is a security manager, its {@code checkPermission} method\n     * is called with a {@code ReflectPermission(\"suppressAccessChecks\")} permission.\n     * @param <T> the desired type of the result, either {@link Member} or a subtype\n     * @param target a direct method handle to crack into symbolic reference components\n     * @param expected a class object representing the desired result type {@code T}\n     * @return a reference to the method, constructor, or field object\n     * @exception SecurityException if the caller is not privileged to call {@code setAccessible}\n     * @exception NullPointerException if either argument is {@code null}\n     * @exception IllegalArgumentException if the target is not a direct method handle\n     * @exception ClassCastException if the member is not of the expected type\n     * @since 1.8\n     ",
    "links" : [ "java.lang.invoke.MethodHandleInfo#reflectAs", "java.lang.invoke.MethodHandles.Lookup#revealDirect", "Member" ]
  }, {
    "name" : "private static MethodHandleImpl getMethodHandleImpl(MethodHandle target)",
    "returnType" : "MethodHandleImpl",
    "comment" : "\n     * \"Cracks\" {@code target} to reveal the underlying {@code MethodHandleImpl}.\n     ",
    "links" : [ ]
  }, {
    "name" : "public static MethodHandle arrayConstructor(Class<?> arrayClass) throws IllegalArgumentException",
    "returnType" : "MethodHandle",
    "comment" : "\n     * Produces a method handle constructing arrays of a desired type,\n     * as if by the {@code anewarray} bytecode.\n     * The return type of the method handle will be the array type.\n     * The type of its sole argument will be {@code int}, which specifies the size of the array.\n     *\n     * <p> If the returned method handle is invoked with a negative\n     * array size, a {@code NegativeArraySizeException} will be thrown.\n     *\n     * @param arrayClass an array type\n     * @return a method handle which can create arrays of the given type\n     * @throws NullPointerException if the argument is {@code null}\n     * @throws IllegalArgumentException if {@code arrayClass} is not an array type\n     * @see java.lang.reflect.Array#newInstance(Class, int)\n     * @since 9\n     ",
    "links" : [ ]
  }, {
    "name" : "public static MethodHandle arrayLength(Class<?> arrayClass) throws IllegalArgumentException",
    "returnType" : "MethodHandle",
    "comment" : "\n     * Produces a method handle returning the length of an array,\n     * as if by the {@code arraylength} bytecode.\n     * The type of the method handle will have {@code int} as return type,\n     * and its sole argument will be the array type.\n     *\n     * <p> If the returned method handle is invoked with a {@code null}\n     * array reference, a {@code NullPointerException} will be thrown.\n     *\n     * @param arrayClass an array type\n     * @return a method handle which can retrieve the length of an array of the given array type\n     * @throws NullPointerException if the argument is {@code null}\n     * @throws IllegalArgumentException if arrayClass is not an array type\n     * @since 9\n     ",
    "links" : [ ]
  }, {
    "name" : "private static void checkClassIsArray(Class<?> c)",
    "returnType" : "void",
    "comment" : " BEGIN Android-added: method to check if a class is an array.",
    "links" : [ ]
  }, {
    "name" : "private static void checkTypeIsViewable(Class<?> componentType)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public static MethodHandle arrayElementGetter(Class<?> arrayClass) throws IllegalArgumentException",
    "returnType" : "MethodHandle",
    "comment" : "\n     * Produces a method handle giving read access to elements of an array.\n     * The type of the method handle will have a return type of the array's\n     * element type.  Its first argument will be the array type,\n     * and the second will be {@code int}.\n     * @param arrayClass an array type\n     * @return a method handle which can load values from the given array type\n     * @throws NullPointerException if the argument is null\n     * @throws  IllegalArgumentException if arrayClass is not an array type\n     ",
    "links" : [ ]
  }, {
    "name" : "public static byte arrayElementGetter(byte[] array, int i)",
    "returnType" : "byte",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "public static boolean arrayElementGetter(boolean[] array, int i)",
    "returnType" : "boolean",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "public static char arrayElementGetter(char[] array, int i)",
    "returnType" : "char",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "public static short arrayElementGetter(short[] array, int i)",
    "returnType" : "short",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "public static int arrayElementGetter(int[] array, int i)",
    "returnType" : "int",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "public static long arrayElementGetter(long[] array, int i)",
    "returnType" : "long",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "public static float arrayElementGetter(float[] array, int i)",
    "returnType" : "float",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "public static double arrayElementGetter(double[] array, int i)",
    "returnType" : "double",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "public static MethodHandle arrayElementSetter(Class<?> arrayClass) throws IllegalArgumentException",
    "returnType" : "MethodHandle",
    "comment" : "\n     * Produces a method handle giving write access to elements of an array.\n     * The type of the method handle will have a void return type.\n     * Its last argument will be the array's element type.\n     * The first and second arguments will be the array type and int.\n     * @param arrayClass the class of an array\n     * @return a method handle which can store values into the array type\n     * @throws NullPointerException if the argument is null\n     * @throws IllegalArgumentException if arrayClass is not an array type\n     ",
    "links" : [ ]
  }, {
    "name" : "public static void arrayElementSetter(byte[] array, int i, byte val)",
    "returnType" : "void",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "public static void arrayElementSetter(boolean[] array, int i, boolean val)",
    "returnType" : "void",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "public static void arrayElementSetter(char[] array, int i, char val)",
    "returnType" : "void",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "public static void arrayElementSetter(short[] array, int i, short val)",
    "returnType" : "void",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "public static void arrayElementSetter(int[] array, int i, int val)",
    "returnType" : "void",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "public static void arrayElementSetter(long[] array, int i, long val)",
    "returnType" : "void",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "public static void arrayElementSetter(float[] array, int i, float val)",
    "returnType" : "void",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "public static void arrayElementSetter(double[] array, int i, double val)",
    "returnType" : "void",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "public static VarHandle arrayElementVarHandle(Class<?> arrayClass) throws IllegalArgumentException",
    "returnType" : "VarHandle",
    "comment" : "\n     * Produces a VarHandle giving access to elements of an array of type\n     * {@code arrayClass}.  The VarHandle's variable type is the component type\n     * of {@code arrayClass} and the list of coordinate types is\n     * {@code (arrayClass, int)}, where the {@code int} coordinate type\n     * corresponds to an argument that is an index into an array.\n     * <p>\n     * Certain access modes of the returned VarHandle are unsupported under\n     * the following conditions:\n     * <ul>\n     * <li>if the component type is anything other than {@code byte},\n     *     {@code short}, {@code char}, {@code int}, {@code long},\n     *     {@code float}, or {@code double} then numeric atomic update access\n     *     modes are unsupported.\n     * <li>if the field type is anything other than {@code boolean},\n     *     {@code byte}, {@code short}, {@code char}, {@code int} or\n     *     {@code long} then bitwise atomic update access modes are\n     *     unsupported.\n     * </ul>\n     * <p>\n     * If the component type is {@code float} or {@code double} then numeric\n     * and atomic update access modes compare values using their bitwise\n     * representation (see {@link Float#floatToRawIntBits} and\n     * {@link Double#doubleToRawLongBits}, respectively).\n     * @apiNote\n     * Bitwise comparison of {@code float} values or {@code double} values,\n     * as performed by the numeric and atomic update access modes, differ\n     * from the primitive {@code ==} operator and the {@link Float#equals}\n     * and {@link Double#equals} methods, specifically with respect to\n     * comparing NaN values or comparing {@code -0.0} with {@code +0.0}.\n     * Care should be taken when performing a compare and set or a compare\n     * and exchange operation with such values since the operation may\n     * unexpectedly fail.\n     * There are many possible NaN values that are considered to be\n     * {@code NaN} in Java, although no IEEE 754 floating-point operation\n     * provided by Java can distinguish between them.  Operation failure can\n     * occur if the expected or witness value is a NaN value and it is\n     * transformed (perhaps in a platform specific manner) into another NaN\n     * value, and thus has a different bitwise representation (see\n     * {@link Float#intBitsToFloat} or {@link Double#longBitsToDouble} for more\n     * details).\n     * The values {@code -0.0} and {@code +0.0} have different bitwise\n     * representations but are considered equal when using the primitive\n     * {@code ==} operator.  Operation failure can occur if, for example, a\n     * numeric algorithm computes an expected value to be say {@code -0.0}\n     * and previously computed the witness value to be say {@code +0.0}.\n     * @param arrayClass the class of an array, of type {@code T[]}\n     * @return a VarHandle giving access to elements of an array\n     * @throws NullPointerException if the arrayClass is null\n     * @throws IllegalArgumentException if arrayClass is not an array type\n     * @since 9\n     ",
    "links" : [ "#equals", "#floatToRawIntBits", "#doubleToRawLongBits", "#intBitsToFloat", "#longBitsToDouble" ]
  }, {
    "name" : "public static VarHandle byteArrayViewVarHandle(Class<?> viewArrayClass, ByteOrder byteOrder) throws IllegalArgumentException",
    "returnType" : "VarHandle",
    "comment" : "\n     * Produces a VarHandle giving access to elements of a {@code byte[]} array\n     * viewed as if it were a different primitive array type, such as\n     * {@code int[]} or {@code long[]}.\n     * The VarHandle's variable type is the component type of\n     * {@code viewArrayClass} and the list of coordinate types is\n     * {@code (byte[], int)}, where the {@code int} coordinate type\n     * corresponds to an argument that is an index into a {@code byte[]} array.\n     * The returned VarHandle accesses bytes at an index in a {@code byte[]}\n     * array, composing bytes to or from a value of the component type of\n     * {@code viewArrayClass} according to the given endianness.\n     * <p>\n     * The supported component types (variables types) are {@code short},\n     * {@code char}, {@code int}, {@code long}, {@code float} and\n     * {@code double}.\n     * <p>\n     * Access of bytes at a given index will result in an\n     * {@code IndexOutOfBoundsException} if the index is less than {@code 0}\n     * or greater than the {@code byte[]} array length minus the size (in bytes)\n     * of {@code T}.\n     * <p>\n     * Access of bytes at an index may be aligned or misaligned for {@code T},\n     * with respect to the underlying memory address, {@code A} say, associated\n     * with the array and index.\n     * If access is misaligned then access for anything other than the\n     * {@code get} and {@code set} access modes will result in an\n     * {@code IllegalStateException}.  In such cases atomic access is only\n     * guaranteed with respect to the largest power of two that divides the GCD\n     * of {@code A} and the size (in bytes) of {@code T}.\n     * If access is aligned then following access modes are supported and are\n     * guaranteed to support atomic access:\n     * <ul>\n     * <li>read write access modes for all {@code T}, with the exception of\n     *     access modes {@code get} and {@code set} for {@code long} and\n     *     {@code double} on 32-bit platforms.\n     * <li>atomic update access modes for {@code int}, {@code long},\n     *     {@code float} or {@code double}.\n     *     (Future major platform releases of the JDK may support additional\n     *     types for certain currently unsupported access modes.)\n     * <li>numeric atomic update access modes for {@code int} and {@code long}.\n     *     (Future major platform releases of the JDK may support additional\n     *     numeric types for certain currently unsupported access modes.)\n     * <li>bitwise atomic update access modes for {@code int} and {@code long}.\n     *     (Future major platform releases of the JDK may support additional\n     *     numeric types for certain currently unsupported access modes.)\n     * </ul>\n     * <p>\n     * Misaligned access, and therefore atomicity guarantees, may be determined\n     * for {@code byte[]} arrays without operating on a specific array.  Given\n     * an {@code index}, {@code T} and it's corresponding boxed type,\n     * {@code T_BOX}, misalignment may be determined as follows:\n     * <pre>{@code\n     * int sizeOfT = T_BOX.BYTES;  // size in bytes of T\n     * int misalignedAtZeroIndex = ByteBuffer.wrap(new byte[0]).\n     *     alignmentOffset(0, sizeOfT);\n     * int misalignedAtIndex = (misalignedAtZeroIndex + index) % sizeOfT;\n     * boolean isMisaligned = misalignedAtIndex != 0;\n     * }</pre>\n     * <p>\n     * If the variable type is {@code float} or {@code double} then atomic\n     * update access modes compare values using their bitwise representation\n     * (see {@link Float#floatToRawIntBits} and\n     * {@link Double#doubleToRawLongBits}, respectively).\n     * @param viewArrayClass the view array class, with a component type of\n     * type {@code T}\n     * @param byteOrder the endianness of the view array elements, as\n     * stored in the underlying {@code byte} array\n     * @return a VarHandle giving access to elements of a {@code byte[]} array\n     * viewed as if elements corresponding to the components type of the view\n     * array class\n     * @throws NullPointerException if viewArrayClass or byteOrder is null\n     * @throws IllegalArgumentException if viewArrayClass is not an array type\n     * @throws UnsupportedOperationException if the component type of\n     * viewArrayClass is not supported as a variable type\n     * @since 9\n     ",
    "links" : [ "#floatToRawIntBits", "#doubleToRawLongBits" ]
  }, {
    "name" : "public static VarHandle byteBufferViewVarHandle(Class<?> viewArrayClass, ByteOrder byteOrder) throws IllegalArgumentException",
    "returnType" : "VarHandle",
    "comment" : "\n     * Produces a VarHandle giving access to elements of a {@code ByteBuffer}\n     * viewed as if it were an array of elements of a different primitive\n     * component type to that of {@code byte}, such as {@code int[]} or\n     * {@code long[]}.\n     * The VarHandle's variable type is the component type of\n     * {@code viewArrayClass} and the list of coordinate types is\n     * {@code (ByteBuffer, int)}, where the {@code int} coordinate type\n     * corresponds to an argument that is an index into a {@code byte[]} array.\n     * The returned VarHandle accesses bytes at an index in a\n     * {@code ByteBuffer}, composing bytes to or from a value of the component\n     * type of {@code viewArrayClass} according to the given endianness.\n     * <p>\n     * The supported component types (variables types) are {@code short},\n     * {@code char}, {@code int}, {@code long}, {@code float} and\n     * {@code double}.\n     * <p>\n     * Access will result in a {@code ReadOnlyBufferException} for anything\n     * other than the read access modes if the {@code ByteBuffer} is read-only.\n     * <p>\n     * Access of bytes at a given index will result in an\n     * {@code IndexOutOfBoundsException} if the index is less than {@code 0}\n     * or greater than the {@code ByteBuffer} limit minus the size (in bytes) of\n     * {@code T}.\n     * <p>\n     * Access of bytes at an index may be aligned or misaligned for {@code T},\n     * with respect to the underlying memory address, {@code A} say, associated\n     * with the {@code ByteBuffer} and index.\n     * If access is misaligned then access for anything other than the\n     * {@code get} and {@code set} access modes will result in an\n     * {@code IllegalStateException}.  In such cases atomic access is only\n     * guaranteed with respect to the largest power of two that divides the GCD\n     * of {@code A} and the size (in bytes) of {@code T}.\n     * If access is aligned then following access modes are supported and are\n     * guaranteed to support atomic access:\n     * <ul>\n     * <li>read write access modes for all {@code T}, with the exception of\n     *     access modes {@code get} and {@code set} for {@code long} and\n     *     {@code double} on 32-bit platforms.\n     * <li>atomic update access modes for {@code int}, {@code long},\n     *     {@code float} or {@code double}.\n     *     (Future major platform releases of the JDK may support additional\n     *     types for certain currently unsupported access modes.)\n     * <li>numeric atomic update access modes for {@code int} and {@code long}.\n     *     (Future major platform releases of the JDK may support additional\n     *     numeric types for certain currently unsupported access modes.)\n     * <li>bitwise atomic update access modes for {@code int} and {@code long}.\n     *     (Future major platform releases of the JDK may support additional\n     *     numeric types for certain currently unsupported access modes.)\n     * </ul>\n     * <p>\n     * Misaligned access, and therefore atomicity guarantees, may be determined\n     * for a {@code ByteBuffer}, {@code bb} (direct or otherwise), an\n     * {@code index}, {@code T} and it's corresponding boxed type,\n     * {@code T_BOX}, as follows:\n     * <pre>{@code\n     * int sizeOfT = T_BOX.BYTES;  // size in bytes of T\n     * ByteBuffer bb = ...\n     * int misalignedAtIndex = bb.alignmentOffset(index, sizeOfT);\n     * boolean isMisaligned = misalignedAtIndex != 0;\n     * }</pre>\n     * <p>\n     * If the variable type is {@code float} or {@code double} then atomic\n     * update access modes compare values using their bitwise representation\n     * (see {@link Float#floatToRawIntBits} and\n     * {@link Double#doubleToRawLongBits}, respectively).\n     * @param viewArrayClass the view array class, with a component type of\n     * type {@code T}\n     * @param byteOrder the endianness of the view array elements, as\n     * stored in the underlying {@code ByteBuffer} (Note this overrides the\n     * endianness of a {@code ByteBuffer})\n     * @return a VarHandle giving access to elements of a {@code ByteBuffer}\n     * viewed as if elements corresponding to the components type of the view\n     * array class\n     * @throws NullPointerException if viewArrayClass or byteOrder is null\n     * @throws IllegalArgumentException if viewArrayClass is not an array type\n     * @throws UnsupportedOperationException if the component type of\n     * viewArrayClass is not supported as a variable type\n     * @since 9\n     ",
    "links" : [ "#floatToRawIntBits", "#doubleToRawLongBits" ]
  }, {
    "name" : "public static MethodHandle spreadInvoker(MethodType type, int leadingArgCount)",
    "returnType" : "MethodHandle",
    "comment" : "\n     * Produces a method handle which will invoke any method handle of the\n     * given {@code type}, with a given number of trailing arguments replaced by\n     * a single trailing {@code Object[]} array.\n     * The resulting invoker will be a method handle with the following\n     * arguments:\n     * <ul>\n     * <li>a single {@code MethodHandle} target\n     * <li>zero or more leading values (counted by {@code leadingArgCount})\n     * <li>an {@code Object[]} array containing trailing arguments\n     * </ul>\n     * <p>\n     * The invoker will invoke its target like a call to {@link MethodHandle#invoke invoke} with\n     * the indicated {@code type}.\n     * That is, if the target is exactly of the given {@code type}, it will behave\n     * like {@code invokeExact}; otherwise it behave as if {@link MethodHandle#asType asType}\n     * is used to convert the target to the required {@code type}.\n     * <p>\n     * The type of the returned invoker will not be the given {@code type}, but rather\n     * will have all parameters except the first {@code leadingArgCount}\n     * replaced by a single array of type {@code Object[]}, which will be\n     * the final parameter.\n     * <p>\n     * Before invoking its target, the invoker will spread the final array, apply\n     * reference casts as necessary, and unbox and widen primitive arguments.\n     * If, when the invoker is called, the supplied array argument does\n     * not have the correct number of elements, the invoker will throw\n     * an {@link IllegalArgumentException} instead of invoking the target.\n     * <p>\n     * This method is equivalent to the following code (though it may be more efficient):\n     * <blockquote><pre>{@code\nMethodHandle invoker = MethodHandles.invoker(type);\nint spreadArgCount = type.parameterCount() - leadingArgCount;\ninvoker = invoker.asSpreader(Object[].class, spreadArgCount);\nreturn invoker;\n     * }</pre></blockquote>\n     * This method throws no reflective or security exceptions.\n     * @param type the desired target type\n     * @param leadingArgCount number of fixed arguments, to be passed unchanged to the target\n     * @return a method handle suitable for invoking any method handle of the given type\n     * @throws NullPointerException if {@code type} is null\n     * @throws IllegalArgumentException if {@code leadingArgCount} is not in\n     *                  the range from 0 to {@code type.parameterCount()} inclusive,\n     *                  or if the resulting method handle's type would have\n     *          <a href=\"MethodHandle.html#maxarity\">too many parameters</a>\n     ",
    "links" : [ "java.lang.invoke.MethodHandle#invoke", "java.lang.invoke.MethodHandle#asType", "java.lang.invoke.MethodHandleStatics.newIllegalArgumentException" ]
  }, {
    "name" : "public static MethodHandle exactInvoker(MethodType type)",
    "returnType" : "MethodHandle",
    "comment" : "\n     * Produces a special <em>invoker method handle</em> which can be used to\n     * invoke any method handle of the given type, as if by {@link MethodHandle#invokeExact invokeExact}.\n     * The resulting invoker will have a type which is\n     * exactly equal to the desired type, except that it will accept\n     * an additional leading argument of type {@code MethodHandle}.\n     * <p>\n     * This method is equivalent to the following code (though it may be more efficient):\n     * {@code publicLookup().findVirtual(MethodHandle.class, \"invokeExact\", type)}\n     *\n     * <p style=\"font-size:smaller;\">\n     * <em>Discussion:</em>\n     * Invoker method handles can be useful when working with variable method handles\n     * of unknown types.\n     * For example, to emulate an {@code invokeExact} call to a variable method\n     * handle {@code M}, extract its type {@code T},\n     * look up the invoker method {@code X} for {@code T},\n     * and call the invoker method, as {@code X.invoke(T, A...)}.\n     * (It would not work to call {@code X.invokeExact}, since the type {@code T}\n     * is unknown.)\n     * If spreading, collecting, or other argument transformations are required,\n     * they can be applied once to the invoker {@code X} and reused on many {@code M}\n     * method handle values, as long as they are compatible with the type of {@code X}.\n     * <p style=\"font-size:smaller;\">\n     * <em>(Note:  The invoker method is not available via the Core Reflection API.\n     * An attempt to call {@linkplain java.lang.reflect.Method#invoke java.lang.reflect.Method.invoke}\n     * on the declared {@code invokeExact} or {@code invoke} method will raise an\n     * {@link java.lang.UnsupportedOperationException UnsupportedOperationException}.)</em>\n     * <p>\n     * This method throws no reflective or security exceptions.\n     * @param type the desired target type\n     * @return a method handle suitable for invoking any method handle of the given type\n     * @throws IllegalArgumentException if the resulting method handle's type would have\n     *          <a href=\"MethodHandle.html#maxarity\">too many parameters</a>\n     ",
    "links" : [ "java.lang.UnsupportedOperationException", "java.lang.invoke.MethodHandle#invokeExact" ]
  }, {
    "name" : "public static MethodHandle invoker(MethodType type)",
    "returnType" : "MethodHandle",
    "comment" : "\n     * Produces a special <em>invoker method handle</em> which can be used to\n     * invoke any method handle compatible with the given type, as if by {@link MethodHandle#invoke invoke}.\n     * The resulting invoker will have a type which is\n     * exactly equal to the desired type, except that it will accept\n     * an additional leading argument of type {@code MethodHandle}.\n     * <p>\n     * Before invoking its target, if the target differs from the expected type,\n     * the invoker will apply reference casts as\n     * necessary and box, unbox, or widen primitive values, as if by {@link MethodHandle#asType asType}.\n     * Similarly, the return value will be converted as necessary.\n     * If the target is a {@linkplain MethodHandle#asVarargsCollector variable arity method handle},\n     * the required arity conversion will be made, again as if by {@link MethodHandle#asType asType}.\n     * <p>\n     * This method is equivalent to the following code (though it may be more efficient):\n     * {@code publicLookup().findVirtual(MethodHandle.class, \"invoke\", type)}\n     * <p style=\"font-size:smaller;\">\n     * <em>Discussion:</em>\n     * A {@linkplain MethodType#genericMethodType general method type} is one which\n     * mentions only {@code Object} arguments and return values.\n     * An invoker for such a type is capable of calling any method handle\n     * of the same arity as the general type.\n     * <p style=\"font-size:smaller;\">\n     * <em>(Note:  The invoker method is not available via the Core Reflection API.\n     * An attempt to call {@linkplain java.lang.reflect.Method#invoke java.lang.reflect.Method.invoke}\n     * on the declared {@code invokeExact} or {@code invoke} method will raise an\n     * {@link java.lang.UnsupportedOperationException UnsupportedOperationException}.)</em>\n     * <p>\n     * This method throws no reflective or security exceptions.\n     * @param type the desired target type\n     * @return a method handle suitable for invoking any method handle convertible to the given type\n     * @throws IllegalArgumentException if the resulting method handle's type would have\n     *          <a href=\"MethodHandle.html#maxarity\">too many parameters</a>\n     ",
    "links" : [ "java.lang.UnsupportedOperationException", "java.lang.invoke.MethodHandle#invoke", "java.lang.invoke.MethodHandle#asType" ]
  }, {
    "name" : "private static MethodHandle methodHandleForVarHandleAccessor(VarHandle.AccessMode accessMode, MethodType type, boolean isExactInvoker)",
    "returnType" : "MethodHandle",
    "comment" : " BEGIN Android-added: resolver for VarHandle accessor methods.",
    "links" : [ ]
  }, {
    "name" : "public static MethodHandle varHandleExactInvoker(VarHandle.AccessMode accessMode, MethodType type)",
    "returnType" : "MethodHandle",
    "comment" : "\n     * Produces a special <em>invoker method handle</em> which can be used to\n     * invoke a signature-polymorphic access mode method on any VarHandle whose\n     * associated access mode type is compatible with the given type.\n     * The resulting invoker will have a type which is exactly equal to the\n     * desired given type, except that it will accept an additional leading\n     * argument of type {@code VarHandle}.\n     *\n     * @param accessMode the VarHandle access mode\n     * @param type the desired target type\n     * @return a method handle suitable for invoking an access mode method of\n     *         any VarHandle whose access mode type is of the given type.\n     * @since 9\n     ",
    "links" : [ ]
  }, {
    "name" : "public static MethodHandle varHandleInvoker(VarHandle.AccessMode accessMode, MethodType type)",
    "returnType" : "MethodHandle",
    "comment" : "\n     * Produces a special <em>invoker method handle</em> which can be used to\n     * invoke a signature-polymorphic access mode method on any VarHandle whose\n     * associated access mode type is compatible with the given type.\n     * The resulting invoker will have a type which is exactly equal to the\n     * desired given type, except that it will accept an additional leading\n     * argument of type {@code VarHandle}.\n     * <p>\n     * Before invoking its target, if the access mode type differs from the\n     * desired given type, the invoker will apply reference casts as necessary\n     * and box, unbox, or widen primitive values, as if by\n     * {@link MethodHandle#asType asType}.  Similarly, the return value will be\n     * converted as necessary.\n     * <p>\n     * This method is equivalent to the following code (though it may be more\n     * efficient): {@code publicLookup().findVirtual(VarHandle.class, accessMode.name(), type)}\n     *\n     * @param accessMode the VarHandle access mode\n     * @param type the desired target type\n     * @return a method handle suitable for invoking an access mode method of\n     *         any VarHandle whose access mode type is convertible to the given\n     *         type.\n     * @since 9\n     ",
    "links" : [ "java.lang.invoke.MethodHandle#asType" ]
  }, {
    "name" : "public static MethodHandle explicitCastArguments(MethodHandle target, MethodType newType)",
    "returnType" : "MethodHandle",
    "comment" : "\n     * Produces a method handle which adapts the type of the\n     * given method handle to a new type by pairwise argument and return type conversion.\n     * The original type and new type must have the same number of arguments.\n     * The resulting method handle is guaranteed to report a type\n     * which is equal to the desired new type.\n     * <p>\n     * If the original type and new type are equal, returns target.\n     * <p>\n     * The same conversions are allowed as for {@link MethodHandle#asType MethodHandle.asType},\n     * and some additional conversions are also applied if those conversions fail.\n     * Given types <em>T0</em>, <em>T1</em>, one of the following conversions is applied\n     * if possible, before or instead of any conversions done by {@code asType}:\n     * <ul>\n     * <li>If <em>T0</em> and <em>T1</em> are references, and <em>T1</em> is an interface type,\n     *     then the value of type <em>T0</em> is passed as a <em>T1</em> without a cast.\n     *     (This treatment of interfaces follows the usage of the bytecode verifier.)\n     * <li>If <em>T0</em> is boolean and <em>T1</em> is another primitive,\n     *     the boolean is converted to a byte value, 1 for true, 0 for false.\n     *     (This treatment follows the usage of the bytecode verifier.)\n     * <li>If <em>T1</em> is boolean and <em>T0</em> is another primitive,\n     *     <em>T0</em> is converted to byte via Java casting conversion (JLS 5.5),\n     *     and the low order bit of the result is tested, as if by {@code (x & 1) != 0}.\n     * <li>If <em>T0</em> and <em>T1</em> are primitives other than boolean,\n     *     then a Java casting conversion (JLS 5.5) is applied.\n     *     (Specifically, <em>T0</em> will convert to <em>T1</em> by\n     *     widening and/or narrowing.)\n     * <li>If <em>T0</em> is a reference and <em>T1</em> a primitive, an unboxing\n     *     conversion will be applied at runtime, possibly followed\n     *     by a Java casting conversion (JLS 5.5) on the primitive value,\n     *     possibly followed by a conversion from byte to boolean by testing\n     *     the low-order bit.\n     * <li>If <em>T0</em> is a reference and <em>T1</em> a primitive,\n     *     and if the reference is null at runtime, a zero value is introduced.\n     * </ul>\n     * @param target the method handle to invoke after arguments are retyped\n     * @param newType the expected type of the new method handle\n     * @return a method handle which delegates to the target after performing\n     *           any necessary argument conversions, and arranges for any\n     *           necessary return value conversions\n     * @throws NullPointerException if either argument is null\n     * @throws WrongMethodTypeException if the conversion cannot be made\n     * @see MethodHandle#asType\n     ",
    "links" : [ "java.lang.invoke.MethodHandle#asType" ]
  }, {
    "name" : "private static void explicitCastArgumentsChecks(MethodHandle target, MethodType newType)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public static MethodHandle permuteArguments(MethodHandle target, MethodType newType, int... reorder)",
    "returnType" : "MethodHandle",
    "comment" : "\n     * Produces a method handle which adapts the calling sequence of the\n     * given method handle to a new type, by reordering the arguments.\n     * The resulting method handle is guaranteed to report a type\n     * which is equal to the desired new type.\n     * <p>\n     * The given array controls the reordering.\n     * Call {@code #I} the number of incoming parameters (the value\n     * {@code newType.parameterCount()}, and call {@code #O} the number\n     * of outgoing parameters (the value {@code target.type().parameterCount()}).\n     * Then the length of the reordering array must be {@code #O},\n     * and each element must be a non-negative number less than {@code #I}.\n     * For every {@code N} less than {@code #O}, the {@code N}-th\n     * outgoing argument will be taken from the {@code I}-th incoming\n     * argument, where {@code I} is {@code reorder[N]}.\n     * <p>\n     * No argument or return value conversions are applied.\n     * The type of each incoming argument, as determined by {@code newType},\n     * must be identical to the type of the corresponding outgoing parameter\n     * or parameters in the target method handle.\n     * The return type of {@code newType} must be identical to the return\n     * type of the original target.\n     * <p>\n     * The reordering array need not specify an actual permutation.\n     * An incoming argument will be duplicated if its index appears\n     * more than once in the array, and an incoming argument will be dropped\n     * if its index does not appear in the array.\n     * As in the case of {@link #dropArguments(MethodHandle,int,List) dropArguments},\n     * incoming arguments which are not mentioned in the reordering array\n     * are may be any type, as determined only by {@code newType}.\n     * <blockquote><pre>{@code\nimport static java.lang.invoke.MethodHandles.*;\nimport static java.lang.invoke.MethodType.*;\n...\nMethodType intfn1 = methodType(int.class, int.class);\nMethodType intfn2 = methodType(int.class, int.class, int.class);\nMethodHandle sub = ... (int x, int y) -> (x-y) ...;\nassert(sub.type().equals(intfn2));\nMethodHandle sub1 = permuteArguments(sub, intfn2, 0, 1);\nMethodHandle rsub = permuteArguments(sub, intfn2, 1, 0);\nassert((int)rsub.invokeExact(1, 100) == 99);\nMethodHandle add = ... (int x, int y) -> (x+y) ...;\nassert(add.type().equals(intfn2));\nMethodHandle twice = permuteArguments(add, intfn1, 0, 0);\nassert(twice.type().equals(intfn1));\nassert((int)twice.invokeExact(21) == 42);\n     * }</pre></blockquote>\n     * @param target the method handle to invoke after arguments are reordered\n     * @param newType the expected type of the new method handle\n     * @param reorder an index array which controls the reordering\n     * @return a method handle which delegates to the target after it\n     *           drops unused arguments and moves and/or duplicates the other arguments\n     * @throws NullPointerException if any argument is null\n     * @throws IllegalArgumentException if the index array length is not equal to\n     *                  the arity of the target, or if any index array element\n     *                  not a valid index for a parameter of {@code newType},\n     *                  or if two corresponding parameter types in\n     *                  {@code target.type()} and {@code newType} are not identical,\n     ",
    "links" : [ "#dropArguments(MethodHandle" ]
  }, {
    "name" : "private static boolean permuteArgumentChecks(int[] reorder, MethodType newType, MethodType oldType)",
    "returnType" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public static MethodHandle constant(Class<?> type, Object value)",
    "returnType" : "MethodHandle",
    "comment" : "\n     * Produces a method handle of the requested return type which returns the given\n     * constant value every time it is invoked.\n     * <p>\n     * Before the method handle is returned, the passed-in value is converted to the requested type.\n     * If the requested type is primitive, widening primitive conversions are attempted,\n     * else reference conversions are attempted.\n     * <p>The returned method handle is equivalent to {@code identity(type).bindTo(value)}.\n     * @param type the return type of the desired method handle\n     * @param value the value to return\n     * @return a method handle of the given return type and no arguments, which always returns the given value\n     * @throws NullPointerException if the {@code type} argument is null\n     * @throws ClassCastException if the value cannot be converted to the required return type\n     * @throws IllegalArgumentException if the given type is {@code void.class}\n     ",
    "links" : [ ]
  }, {
    "name" : "public static MethodHandle identity(Class<?> type)",
    "returnType" : "MethodHandle",
    "comment" : "\n     * Produces a method handle which returns its sole argument when invoked.\n     * @param type the type of the sole parameter and return value of the desired method handle\n     * @return a unary method handle which accepts and returns the given type\n     * @throws NullPointerException if the argument is null\n     * @throws IllegalArgumentException if the given type is {@code void.class}\n     ",
    "links" : [ ]
  }, {
    "name" : "public static MethodHandle zero(Class<?> type)",
    "returnType" : "MethodHandle",
    "comment" : "\n     * Produces a constant method handle of the requested return type which\n     * returns the default value for that type every time it is invoked.\n     * The resulting constant method handle will have no side effects.\n     * <p>The returned method handle is equivalent to {@code empty(methodType(type))}.\n     * It is also equivalent to {@code explicitCastArguments(constant(Object.class, null), methodType(type))},\n     * since {@code explicitCastArguments} converts {@code null} to default values.\n     * @param type the expected return type of the desired method handle\n     * @return a constant method handle that takes no arguments\n     *         and returns the default value of the given type (or void, if the type is void)\n     * @throws NullPointerException if the argument is null\n     * @see MethodHandles#constant\n     * @see MethodHandles#empty\n     * @see MethodHandles#explicitCastArguments\n     * @since 9\n     ",
    "links" : [ ]
  }, {
    "name" : "private static MethodHandle identityOrVoid(Class<?> type)",
    "returnType" : "MethodHandle",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public static MethodHandle empty(MethodType type)",
    "returnType" : "MethodHandle",
    "comment" : "\n     * Produces a method handle of the requested type which ignores any arguments, does nothing,\n     * and returns a suitable default depending on the return type.\n     * That is, it returns a zero primitive value, a {@code null}, or {@code void}.\n     * <p>The returned method handle is equivalent to\n     * {@code dropArguments(zero(type.returnType()), 0, type.parameterList())}.\n     *\n     * @apiNote Given a predicate and target, a useful \"if-then\" construct can be produced as\n     * {@code guardWithTest(pred, target, empty(target.type())}.\n     * @param type the type of the desired method handle\n     * @return a constant method handle of the given type, which returns a default value of the given return type\n     * @throws NullPointerException if the argument is null\n     * @see MethodHandles#zero\n     * @see MethodHandles#constant\n     * @since 9\n     ",
    "links" : [ ]
  }, {
    "name" : "private static MethodHandle makeIdentity(Class<?> ptype)",
    "returnType" : "MethodHandle",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public static byte identity(byte val)",
    "returnType" : "byte",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "public static boolean identity(boolean val)",
    "returnType" : "boolean",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "public static char identity(char val)",
    "returnType" : "char",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "public static short identity(short val)",
    "returnType" : "short",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "public static int identity(int val)",
    "returnType" : "int",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "public static long identity(long val)",
    "returnType" : "long",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "public static float identity(float val)",
    "returnType" : "float",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "public static double identity(double val)",
    "returnType" : "double",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "private static MethodHandle zero(Wrapper btw, Class<?> rtype)",
    "returnType" : "MethodHandle",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private static MethodHandle makeZero(Class<?> rtype)",
    "returnType" : "MethodHandle",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private static synchronized MethodHandle setCachedMethodHandle(MethodHandle[] cache, int pos, MethodHandle value)",
    "returnType" : "MethodHandle",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public static MethodHandle insertArguments(MethodHandle target, int pos, Object... values)",
    "returnType" : "MethodHandle",
    "comment" : "\n     * Provides a target method handle with one or more <em>bound arguments</em>\n     * in advance of the method handle's invocation.\n     * The formal parameters to the target corresponding to the bound\n     * arguments are called <em>bound parameters</em>.\n     * Returns a new method handle which saves away the bound arguments.\n     * When it is invoked, it receives arguments for any non-bound parameters,\n     * binds the saved arguments to their corresponding parameters,\n     * and calls the original target.\n     * <p>\n     * The type of the new method handle will drop the types for the bound\n     * parameters from the original target type, since the new method handle\n     * will no longer require those arguments to be supplied by its callers.\n     * <p>\n     * Each given argument object must match the corresponding bound parameter type.\n     * If a bound parameter type is a primitive, the argument object\n     * must be a wrapper, and will be unboxed to produce the primitive value.\n     * <p>\n     * The {@code pos} argument selects which parameters are to be bound.\n     * It may range between zero and <i>N-L</i> (inclusively),\n     * where <i>N</i> is the arity of the target method handle\n     * and <i>L</i> is the length of the values array.\n     * @param target the method handle to invoke after the argument is inserted\n     * @param pos where to insert the argument (zero for the first)\n     * @param values the series of arguments to insert\n     * @return a method handle which inserts an additional argument,\n     *         before calling the original method handle\n     * @throws NullPointerException if the target or the {@code values} array is null\n     * @see MethodHandle#bindTo\n     ",
    "links" : [ ]
  }, {
    "name" : "private static Class<?>[] insertArgumentsChecks(MethodHandle target, int insCount, int pos) throws RuntimeException",
    "returnType" : "Class<?>[]",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public static MethodHandle dropArguments(MethodHandle target, int pos, List<Class<?>> valueTypes)",
    "returnType" : "MethodHandle",
    "comment" : "\n     * Produces a method handle which will discard some placeholder arguments\n     * before calling some other specified <i>target</i> method handle.\n     * The type of the new method handle will be the same as the target's type,\n     * except it will also include the placeholder argument types,\n     * at some given position.\n     * <p>\n     * The {@code pos} argument may range between zero and <i>N</i>,\n     * where <i>N</i> is the arity of the target.\n     * If {@code pos} is zero, the placeholder arguments will precede\n     * the target's real arguments; if {@code pos} is <i>N</i>\n     * they will come after.\n     * <p>\n     * <b>Example:</b>\n     * <blockquote><pre>{@code\nimport static java.lang.invoke.MethodHandles.*;\nimport static java.lang.invoke.MethodType.*;\n...\nMethodHandle cat = lookup().findVirtual(String.class,\n  \"concat\", methodType(String.class, String.class));\nassertEquals(\"xy\", (String) cat.invokeExact(\"x\", \"y\"));\nMethodType bigType = cat.type().insertParameterTypes(0, int.class, String.class);\nMethodHandle d0 = dropArguments(cat, 0, bigType.parameterList().subList(0,2));\nassertEquals(bigType, d0.type());\nassertEquals(\"yz\", (String) d0.invokeExact(123, \"x\", \"y\", \"z\"));\n     * }</pre></blockquote>\n     * <p>\n     * This method is also equivalent to the following code:\n     * <blockquote><pre>\n     * {@link #dropArguments(MethodHandle,int,Class...) dropArguments}{@code (target, pos, valueTypes.toArray(new Class[0]))}\n     * </pre></blockquote>\n     * @param target the method handle to invoke after the arguments are dropped\n     * @param valueTypes the type(s) of the argument(s) to drop\n     * @param pos position of first argument to drop (zero for the leftmost)\n     * @return a method handle which drops arguments of the given types,\n     *         before calling the original method handle\n     * @throws NullPointerException if the target is null,\n     *                              or if the {@code valueTypes} list or any of its elements is null\n     * @throws IllegalArgumentException if any element of {@code valueTypes} is {@code void.class},\n     *                  or if {@code pos} is negative or greater than the arity of the target,\n     *                  or if the new method handle's type would have too many parameters\n     ",
    "links" : [ "#dropArguments(MethodHandle" ]
  }, {
    "name" : "private static List<Class<?>> copyTypes(Object[] array)",
    "returnType" : "List<Class<?>>",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private static MethodHandle dropArguments0(MethodHandle target, int pos, List<Class<?>> valueTypes)",
    "returnType" : "MethodHandle",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private static int dropArgumentChecks(MethodType oldType, int pos, List<Class<?>> valueTypes)",
    "returnType" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public static MethodHandle dropArguments(MethodHandle target, int pos, Class<?>... valueTypes)",
    "returnType" : "MethodHandle",
    "comment" : "\n     * Produces a method handle which will discard some placeholder arguments\n     * before calling some other specified <i>target</i> method handle.\n     * The type of the new method handle will be the same as the target's type,\n     * except it will also include the placeholder argument types,\n     * at some given position.\n     * <p>\n     * The {@code pos} argument may range between zero and <i>N</i>,\n     * where <i>N</i> is the arity of the target.\n     * If {@code pos} is zero, the placeholder arguments will precede\n     * the target's real arguments; if {@code pos} is <i>N</i>\n     * they will come after.\n     * @apiNote\n     * <blockquote><pre>{@code\nimport static java.lang.invoke.MethodHandles.*;\nimport static java.lang.invoke.MethodType.*;\n...\nMethodHandle cat = lookup().findVirtual(String.class,\n  \"concat\", methodType(String.class, String.class));\nassertEquals(\"xy\", (String) cat.invokeExact(\"x\", \"y\"));\nMethodHandle d0 = dropArguments(cat, 0, String.class);\nassertEquals(\"yz\", (String) d0.invokeExact(\"x\", \"y\", \"z\"));\nMethodHandle d1 = dropArguments(cat, 1, String.class);\nassertEquals(\"xz\", (String) d1.invokeExact(\"x\", \"y\", \"z\"));\nMethodHandle d2 = dropArguments(cat, 2, String.class);\nassertEquals(\"xy\", (String) d2.invokeExact(\"x\", \"y\", \"z\"));\nMethodHandle d12 = dropArguments(cat, 1, int.class, boolean.class);\nassertEquals(\"xz\", (String) d12.invokeExact(\"x\", 12, true, \"z\"));\n     * }</pre></blockquote>\n     * <p>\n     * This method is also equivalent to the following code:\n     * <blockquote><pre>\n     * {@link #dropArguments(MethodHandle,int,List) dropArguments}{@code (target, pos, Arrays.asList(valueTypes))}\n     * </pre></blockquote>\n     * @param target the method handle to invoke after the arguments are dropped\n     * @param valueTypes the type(s) of the argument(s) to drop\n     * @param pos position of first argument to drop (zero for the leftmost)\n     * @return a method handle which drops arguments of the given types,\n     *         before calling the original method handle\n     * @throws NullPointerException if the target is null,\n     *                              or if the {@code valueTypes} array or any of its elements is null\n     * @throws IllegalArgumentException if any element of {@code valueTypes} is {@code void.class},\n     *                  or if {@code pos} is negative or greater than the arity of the target,\n     *                  or if the new method handle's type would have\n     *                  <a href=\"MethodHandle.html#maxarity\">too many parameters</a>\n     ",
    "links" : [ "#dropArguments(MethodHandle" ]
  }, {
    "name" : "private static MethodHandle dropArgumentsToMatch(MethodHandle target, int skip, List<Class<?>> newTypes, int pos, boolean nullOnFailure)",
    "returnType" : "MethodHandle",
    "comment" : " private version which allows caller some freedom with error handling",
    "links" : [ ]
  }, {
    "name" : "public static MethodHandle dropArgumentsToMatch(MethodHandle target, int skip, List<Class<?>> newTypes, int pos)",
    "returnType" : "MethodHandle",
    "comment" : "\n     * Adapts a target method handle to match the given parameter type list. If necessary, adds placeholder arguments. Some\n     * leading parameters can be skipped before matching begins. The remaining types in the {@code target}'s parameter\n     * type list must be a sub-list of the {@code newTypes} type list at the starting position {@code pos}. The\n     * resulting handle will have the target handle's parameter type list, with any non-matching parameter types (before\n     * or after the matching sub-list) inserted in corresponding positions of the target's original parameters, as if by\n     * {@link #dropArguments(MethodHandle, int, Class[])}.\n     * <p>\n     * The resulting handle will have the same return type as the target handle.\n     * <p>\n     * In more formal terms, assume these two type lists:<ul>\n     * <li>The target handle has the parameter type list {@code S..., M...}, with as many types in {@code S} as\n     * indicated by {@code skip}. The {@code M} types are those that are supposed to match part of the given type list,\n     * {@code newTypes}.\n     * <li>The {@code newTypes} list contains types {@code P..., M..., A...}, with as many types in {@code P} as\n     * indicated by {@code pos}. The {@code M} types are precisely those that the {@code M} types in the target handle's\n     * parameter type list are supposed to match. The types in {@code A} are additional types found after the matching\n     * sub-list.\n     * </ul>\n     * Given these assumptions, the result of an invocation of {@code dropArgumentsToMatch} will have the parameter type\n     * list {@code S..., P..., M..., A...}, with the {@code P} and {@code A} types inserted as if by\n     * {@link #dropArguments(MethodHandle, int, Class[])}.\n     *\n     * @apiNote\n     * Two method handles whose argument lists are \"effectively identical\" (i.e., identical in a common prefix) may be\n     * mutually converted to a common type by two calls to {@code dropArgumentsToMatch}, as follows:\n     * <blockquote><pre>{@code\nimport static java.lang.invoke.MethodHandles.*;\nimport static java.lang.invoke.MethodType.*;\n...\n...\nMethodHandle h0 = constant(boolean.class, true);\nMethodHandle h1 = lookup().findVirtual(String.class, \"concat\", methodType(String.class, String.class));\nMethodType bigType = h1.type().insertParameterTypes(1, String.class, int.class);\nMethodHandle h2 = dropArguments(h1, 0, bigType.parameterList());\nif (h1.type().parameterCount() < h2.type().parameterCount())\n    h1 = dropArgumentsToMatch(h1, 0, h2.type().parameterList(), 0);  // lengthen h1\nelse\n    h2 = dropArgumentsToMatch(h2, 0, h1.type().parameterList(), 0);    // lengthen h2\nMethodHandle h3 = guardWithTest(h0, h1, h2);\nassertEquals(\"xy\", h3.invoke(\"x\", \"y\", 1, \"a\", \"b\", \"c\"));\n     * }</pre></blockquote>\n     * @param target the method handle to adapt\n     * @param skip number of targets parameters to disregard (they will be unchanged)\n     * @param newTypes the list of types to match {@code target}'s parameter type list to\n     * @param pos place in {@code newTypes} where the non-skipped target parameters must occur\n     * @return a possibly adapted method handle\n     * @throws NullPointerException if either argument is null\n     * @throws IllegalArgumentException if any element of {@code newTypes} is {@code void.class},\n     *         or if {@code skip} is negative or greater than the arity of the target,\n     *         or if {@code pos} is negative or greater than the newTypes list size,\n     *         or if {@code newTypes} does not contain the {@code target}'s non-skipped parameter types at position\n     *         {@code pos}.\n     * @since 9\n     ",
    "links" : [ "#dropArguments(MethodHandle" ]
  }, {
    "name" : "public static MethodHandle dropReturn(MethodHandle target)",
    "returnType" : "MethodHandle",
    "comment" : "\n     * Drop the return value of the target handle (if any).\n     * The returned method handle will have a {@code void} return type.\n     *\n     * @param target the method handle to adapt\n     * @return a possibly adapted method handle\n     * @throws NullPointerException if {@code target} is null\n     * @since 16\n     ",
    "links" : [ ]
  }, {
    "name" : "public static MethodHandle filterArguments(MethodHandle target, int pos, MethodHandle... filters)",
    "returnType" : "MethodHandle",
    "comment" : "\n     * Adapts a target method handle by pre-processing\n     * one or more of its arguments, each with its own unary filter function,\n     * and then calling the target with each pre-processed argument\n     * replaced by the result of its corresponding filter function.\n     * <p>\n     * The pre-processing is performed by one or more method handles,\n     * specified in the elements of the {@code filters} array.\n     * The first element of the filter array corresponds to the {@code pos}\n     * argument of the target, and so on in sequence.\n     * The filter functions are invoked in left to right order.\n     * <p>\n     * Null arguments in the array are treated as identity functions,\n     * and the corresponding arguments left unchanged.\n     * (If there are no non-null elements in the array, the original target is returned.)\n     * Each filter is applied to the corresponding argument of the adapter.\n     * <p>\n     * If a filter {@code F} applies to the {@code N}th argument of\n     * the target, then {@code F} must be a method handle which\n     * takes exactly one argument.  The type of {@code F}'s sole argument\n     * replaces the corresponding argument type of the target\n     * in the resulting adapted method handle.\n     * The return type of {@code F} must be identical to the corresponding\n     * parameter type of the target.\n     * <p>\n     * It is an error if there are elements of {@code filters}\n     * (null or not)\n     * which do not correspond to argument positions in the target.\n     * <p><b>Example:</b>\n     * <blockquote><pre>{@code\nimport static java.lang.invoke.MethodHandles.*;\nimport static java.lang.invoke.MethodType.*;\n...\nMethodHandle cat = lookup().findVirtual(String.class,\n  \"concat\", methodType(String.class, String.class));\nMethodHandle upcase = lookup().findVirtual(String.class,\n  \"toUpperCase\", methodType(String.class));\nassertEquals(\"xy\", (String) cat.invokeExact(\"x\", \"y\"));\nMethodHandle f0 = filterArguments(cat, 0, upcase);\nassertEquals(\"Xy\", (String) f0.invokeExact(\"x\", \"y\")); // Xy\nMethodHandle f1 = filterArguments(cat, 1, upcase);\nassertEquals(\"xY\", (String) f1.invokeExact(\"x\", \"y\")); // xY\nMethodHandle f2 = filterArguments(cat, 0, upcase, upcase);\nassertEquals(\"XY\", (String) f2.invokeExact(\"x\", \"y\")); // XY\n     * }</pre></blockquote>\n     * <p>Here is pseudocode for the resulting adapter. In the code, {@code T}\n     * denotes the return type of both the {@code target} and resulting adapter.\n     * {@code P}/{@code p} and {@code B}/{@code b} represent the types and values\n     * of the parameters and arguments that precede and follow the filter position\n     * {@code pos}, respectively. {@code A[i]}/{@code a[i]} stand for the types and\n     * values of the filtered parameters and arguments; they also represent the\n     * return types of the {@code filter[i]} handles. The latter accept arguments\n     * {@code v[i]} of type {@code V[i]}, which also appear in the signature of\n     * the resulting adapter.\n     * <blockquote><pre>{@code\n     * T target(P... p, A[i]... a[i], B... b);\n     * A[i] filter[i](V[i]);\n     * T adapter(P... p, V[i]... v[i], B... b) {\n     *   return target(p..., filter[i](v[i])..., b...);\n     * }\n     * }</pre></blockquote>\n     * <p>\n     * <em>Note:</em> The resulting adapter is never a {@linkplain MethodHandle#asVarargsCollector\n     * variable-arity method handle}, even if the original target method handle was.\n     *\n     * @param target the method handle to invoke after arguments are filtered\n     * @param pos the position of the first argument to filter\n     * @param filters method handles to call initially on filtered arguments\n     * @return method handle which incorporates the specified argument filtering logic\n     * @throws NullPointerException if the target is null\n     *                              or if the {@code filters} array is null\n     * @throws IllegalArgumentException if a non-null element of {@code filters}\n     *          does not match a corresponding argument type of target as described above,\n     *          or if the {@code pos+filters.length} is greater than {@code target.type().parameterCount()},\n     *          or if the resulting method handle's type would have\n     *          <a href=\"MethodHandle.html#maxarity\">too many parameters</a>\n     ",
    "links" : [ ]
  }, {
    "name" : " static MethodHandle filterArgument(MethodHandle target, int pos, MethodHandle filter)",
    "returnType" : "MethodHandle",
    "comment" : "non-public",
    "links" : [ ]
  }, {
    "name" : "private static void filterArgumentsCheckArity(MethodHandle target, int pos, MethodHandle[] filters)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private static void filterArgumentChecks(MethodHandle target, int pos, MethodHandle filter) throws RuntimeException",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public static MethodHandle collectArguments(MethodHandle target, int pos, MethodHandle filter)",
    "returnType" : "MethodHandle",
    "comment" : "\n     * Adapts a target method handle by pre-processing\n     * a sub-sequence of its arguments with a filter (another method handle).\n     * The pre-processed arguments are replaced by the result (if any) of the\n     * filter function.\n     * The target is then called on the modified (usually shortened) argument list.\n     * <p>\n     * If the filter returns a value, the target must accept that value as\n     * its argument in position {@code pos}, preceded and/or followed by\n     * any arguments not passed to the filter.\n     * If the filter returns void, the target must accept all arguments\n     * not passed to the filter.\n     * No arguments are reordered, and a result returned from the filter\n     * replaces (in order) the whole subsequence of arguments originally\n     * passed to the adapter.\n     * <p>\n     * The argument types (if any) of the filter\n     * replace zero or one argument types of the target, at position {@code pos},\n     * in the resulting adapted method handle.\n     * The return type of the filter (if any) must be identical to the\n     * argument type of the target at position {@code pos}, and that target argument\n     * is supplied by the return value of the filter.\n     * <p>\n     * In all cases, {@code pos} must be greater than or equal to zero, and\n     * {@code pos} must also be less than or equal to the target's arity.\n     * <p><b>Example:</b>\n     * <blockquote><pre>{@code\nimport static java.lang.invoke.MethodHandles.*;\nimport static java.lang.invoke.MethodType.*;\n...\nMethodHandle deepToString = publicLookup()\n  .findStatic(Arrays.class, \"deepToString\", methodType(String.class, Object[].class));\n\nMethodHandle ts1 = deepToString.asCollector(String[].class, 1);\nassertEquals(\"[strange]\", (String) ts1.invokeExact(\"strange\"));\n\nMethodHandle ts2 = deepToString.asCollector(String[].class, 2);\nassertEquals(\"[up, down]\", (String) ts2.invokeExact(\"up\", \"down\"));\n\nMethodHandle ts3 = deepToString.asCollector(String[].class, 3);\nMethodHandle ts3_ts2 = collectArguments(ts3, 1, ts2);\nassertEquals(\"[top, [up, down], strange]\",\n             (String) ts3_ts2.invokeExact(\"top\", \"up\", \"down\", \"strange\"));\n\nMethodHandle ts3_ts2_ts1 = collectArguments(ts3_ts2, 3, ts1);\nassertEquals(\"[top, [up, down], [strange]]\",\n             (String) ts3_ts2_ts1.invokeExact(\"top\", \"up\", \"down\", \"strange\"));\n\nMethodHandle ts3_ts2_ts3 = collectArguments(ts3_ts2, 1, ts3);\nassertEquals(\"[top, [[up, down, strange], charm], bottom]\",\n             (String) ts3_ts2_ts3.invokeExact(\"top\", \"up\", \"down\", \"strange\", \"charm\", \"bottom\"));\n     * }</pre></blockquote>\n     * <p> Here is pseudocode for the resulting adapter:\n     * <blockquote><pre>{@code\n     * T target(A...,V,C...);\n     * V filter(B...);\n     * T adapter(A... a,B... b,C... c) {\n     *   V v = filter(b...);\n     *   return target(a...,v,c...);\n     * }\n     * // and if the filter has no arguments:\n     * T target2(A...,V,C...);\n     * V filter2();\n     * T adapter2(A... a,C... c) {\n     *   V v = filter2();\n     *   return target2(a...,v,c...);\n     * }\n     * // and if the filter has a void return:\n     * T target3(A...,C...);\n     * void filter3(B...);\n     * void adapter3(A... a,B... b,C... c) {\n     *   filter3(b...);\n     *   return target3(a...,c...);\n     * }\n     * }</pre></blockquote>\n     * <p>\n     * A collection adapter {@code collectArguments(mh, 0, coll)} is equivalent to\n     * one which first \"folds\" the affected arguments, and then drops them, in separate\n     * steps as follows:\n     * <blockquote><pre>{@code\n     * mh = MethodHandles.dropArguments(mh, 1, coll.type().parameterList()); //step 2\n     * mh = MethodHandles.foldArguments(mh, coll); //step 1\n     * }</pre></blockquote>\n     * If the target method handle consumes no arguments besides than the result\n     * (if any) of the filter {@code coll}, then {@code collectArguments(mh, 0, coll)}\n     * is equivalent to {@code filterReturnValue(coll, mh)}.\n     * If the filter method handle {@code coll} consumes one argument and produces\n     * a non-void result, then {@code collectArguments(mh, N, coll)}\n     * is equivalent to {@code filterArguments(mh, N, coll)}.\n     * Other equivalences are possible but would require argument permutation.\n     *\n     * @param target the method handle to invoke after filtering the subsequence of arguments\n     * @param pos the position of the first adapter argument to pass to the filter,\n     *            and/or the target argument which receives the result of the filter\n     * @param filter method handle to call on the subsequence of arguments\n     * @return method handle which incorporates the specified argument subsequence filtering logic\n     * @throws NullPointerException if either argument is null\n     * @throws IllegalArgumentException if the return type of {@code filter}\n     *          is non-void and is not the same as the {@code pos} argument of the target,\n     *          or if {@code pos} is not between 0 and the target's arity, inclusive,\n     *          or if the resulting method handle's type would have\n     *          <a href=\"MethodHandle.html#maxarity\">too many parameters</a>\n     * @see MethodHandles#foldArguments\n     * @see MethodHandles#filterArguments\n     * @see MethodHandles#filterReturnValue\n     ",
    "links" : [ ]
  }, {
    "name" : "private static MethodType collectArgumentsChecks(MethodHandle target, int pos, MethodHandle filter) throws RuntimeException",
    "returnType" : "MethodType",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public static MethodHandle filterReturnValue(MethodHandle target, MethodHandle filter)",
    "returnType" : "MethodHandle",
    "comment" : "\n     * Adapts a target method handle by post-processing\n     * its return value (if any) with a filter (another method handle).\n     * The result of the filter is returned from the adapter.\n     * <p>\n     * If the target returns a value, the filter must accept that value as\n     * its only argument.\n     * If the target returns void, the filter must accept no arguments.\n     * <p>\n     * The return type of the filter\n     * replaces the return type of the target\n     * in the resulting adapted method handle.\n     * The argument type of the filter (if any) must be identical to the\n     * return type of the target.\n     * <p><b>Example:</b>\n     * <blockquote><pre>{@code\nimport static java.lang.invoke.MethodHandles.*;\nimport static java.lang.invoke.MethodType.*;\n...\nMethodHandle cat = lookup().findVirtual(String.class,\n  \"concat\", methodType(String.class, String.class));\nMethodHandle length = lookup().findVirtual(String.class,\n  \"length\", methodType(int.class));\nSystem.out.println((String) cat.invokeExact(\"x\", \"y\")); // xy\nMethodHandle f0 = filterReturnValue(cat, length);\nSystem.out.println((int) f0.invokeExact(\"x\", \"y\")); // 2\n     * }</pre></blockquote>\n     * <p>Here is pseudocode for the resulting adapter. In the code,\n     * {@code T}/{@code t} represent the result type and value of the\n     * {@code target}; {@code V}, the result type of the {@code filter}; and\n     * {@code A}/{@code a}, the types and values of the parameters and arguments\n     * of the {@code target} as well as the resulting adapter.\n     * <blockquote><pre>{@code\n     * T target(A...);\n     * V filter(T);\n     * V adapter(A... a) {\n     *   T t = target(a...);\n     *   return filter(t);\n     * }\n     * // and if the target has a void return:\n     * void target2(A...);\n     * V filter2();\n     * V adapter2(A... a) {\n     *   target2(a...);\n     *   return filter2();\n     * }\n     * // and if the filter has a void return:\n     * T target3(A...);\n     * void filter3(V);\n     * void adapter3(A... a) {\n     *   T t = target3(a...);\n     *   filter3(t);\n     * }\n     * }</pre></blockquote>\n     * <p>\n     * <em>Note:</em> The resulting adapter is never a {@linkplain MethodHandle#asVarargsCollector\n     * variable-arity method handle}, even if the original target method handle was.\n     * @param target the method handle to invoke before filtering the return value\n     * @param filter method handle to call on the return value\n     * @return method handle which incorporates the specified return value filtering logic\n     * @throws NullPointerException if either argument is null\n     * @throws IllegalArgumentException if the argument list of {@code filter}\n     *          does not match the return type of target as described above\n     ",
    "links" : [ ]
  }, {
    "name" : "private static void filterReturnValueChecks(MethodType targetType, MethodType filterType) throws RuntimeException",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public static MethodHandle foldArguments(MethodHandle target, MethodHandle combiner)",
    "returnType" : "MethodHandle",
    "comment" : "\n     * Adapts a target method handle by pre-processing\n     * some of its arguments, and then calling the target with\n     * the result of the pre-processing, inserted into the original\n     * sequence of arguments.\n     * <p>\n     * The pre-processing is performed by {@code combiner}, a second method handle.\n     * Of the arguments passed to the adapter, the first {@code N} arguments\n     * are copied to the combiner, which is then called.\n     * (Here, {@code N} is defined as the parameter count of the combiner.)\n     * After this, control passes to the target, with any result\n     * from the combiner inserted before the original {@code N} incoming\n     * arguments.\n     * <p>\n     * If the combiner returns a value, the first parameter type of the target\n     * must be identical with the return type of the combiner, and the next\n     * {@code N} parameter types of the target must exactly match the parameters\n     * of the combiner.\n     * <p>\n     * If the combiner has a void return, no result will be inserted,\n     * and the first {@code N} parameter types of the target\n     * must exactly match the parameters of the combiner.\n     * <p>\n     * The resulting adapter is the same type as the target, except that the\n     * first parameter type is dropped,\n     * if it corresponds to the result of the combiner.\n     * <p>\n     * (Note that {@link #dropArguments(MethodHandle,int,List) dropArguments} can be used to remove any arguments\n     * that either the combiner or the target does not wish to receive.\n     * If some of the incoming arguments are destined only for the combiner,\n     * consider using {@link MethodHandle#asCollector asCollector} instead, since those\n     * arguments will not need to be live on the stack on entry to the\n     * target.)\n     * <p><b>Example:</b>\n     * <blockquote><pre>{@code\nimport static java.lang.invoke.MethodHandles.*;\nimport static java.lang.invoke.MethodType.*;\n...\nMethodHandle trace = publicLookup().findVirtual(java.io.PrintStream.class,\n  \"println\", methodType(void.class, String.class))\n    .bindTo(System.out);\nMethodHandle cat = lookup().findVirtual(String.class,\n  \"concat\", methodType(String.class, String.class));\nassertEquals(\"boojum\", (String) cat.invokeExact(\"boo\", \"jum\"));\nMethodHandle catTrace = foldArguments(cat, trace);\n// also prints \"boo\":\nassertEquals(\"boojum\", (String) catTrace.invokeExact(\"boo\", \"jum\"));\n     * }</pre></blockquote>\n     * <p>Here is pseudocode for the resulting adapter. In the code, {@code T}\n     * represents the result type of the {@code target} and resulting adapter.\n     * {@code V}/{@code v} represent the type and value of the parameter and argument\n     * of {@code target} that precedes the folding position; {@code V} also is\n     * the result type of the {@code combiner}. {@code A}/{@code a} denote the\n     * types and values of the {@code N} parameters and arguments at the folding\n     * position. {@code B}/{@code b} represent the types and values of the\n     * {@code target} parameters and arguments that follow the folded parameters\n     * and arguments.\n     * <blockquote><pre>{@code\n     * // there are N arguments in A...\n     * T target(V, A[N]..., B...);\n     * V combiner(A...);\n     * T adapter(A... a, B... b) {\n     *   V v = combiner(a...);\n     *   return target(v, a..., b...);\n     * }\n     * // and if the combiner has a void return:\n     * T target2(A[N]..., B...);\n     * void combiner2(A...);\n     * T adapter2(A... a, B... b) {\n     *   combiner2(a...);\n     *   return target2(a..., b...);\n     * }\n     * }</pre></blockquote>\n     * <p>\n     * <em>Note:</em> The resulting adapter is never a {@linkplain MethodHandle#asVarargsCollector\n     * variable-arity method handle}, even if the original target method handle was.\n     * @param target the method handle to invoke after arguments are combined\n     * @param combiner method handle to call initially on the incoming arguments\n     * @return method handle which incorporates the specified argument folding logic\n     * @throws NullPointerException if either argument is null\n     * @throws IllegalArgumentException if {@code combiner}'s return type\n     *          is non-void and not the same as the first argument type of\n     *          the target, or if the initial {@code N} argument types\n     *          of the target\n     *          (skipping one matching the {@code combiner}'s return type)\n     *          are not identical with the argument types of {@code combiner}\n     ",
    "links" : [ "java.lang.invoke.MethodHandle#asCollector", "#dropArguments(MethodHandle" ]
  }, {
    "name" : "public static MethodHandle foldArguments(MethodHandle target, int pos, MethodHandle combiner)",
    "returnType" : "MethodHandle",
    "comment" : "\n     * Adapts a target method handle by pre-processing some of its arguments, starting at a given position, and then\n     * calling the target with the result of the pre-processing, inserted into the original sequence of arguments just\n     * before the folded arguments.\n     * <p>\n     * This method is closely related to {@link #foldArguments(MethodHandle, MethodHandle)}, but allows to control the\n     * position in the parameter list at which folding takes place. The argument controlling this, {@code pos}, is a\n     * zero-based index. The aforementioned method {@link #foldArguments(MethodHandle, MethodHandle)} assumes position\n     * 0.\n     *\n     * @apiNote Example:\n     * <blockquote><pre>{@code\n    import static java.lang.invoke.MethodHandles.*;\n    import static java.lang.invoke.MethodType.*;\n    ...\n    MethodHandle trace = publicLookup().findVirtual(java.io.PrintStream.class,\n    \"println\", methodType(void.class, String.class))\n    .bindTo(System.out);\n    MethodHandle cat = lookup().findVirtual(String.class,\n    \"concat\", methodType(String.class, String.class));\n    assertEquals(\"boojum\", (String) cat.invokeExact(\"boo\", \"jum\"));\n    MethodHandle catTrace = foldArguments(cat, 1, trace);\n    // also prints \"jum\":\n    assertEquals(\"boojum\", (String) catTrace.invokeExact(\"boo\", \"jum\"));\n     * }</pre></blockquote>\n     * <p>Here is pseudocode for the resulting adapter. In the code, {@code T}\n     * represents the result type of the {@code target} and resulting adapter.\n     * {@code V}/{@code v} represent the type and value of the parameter and argument\n     * of {@code target} that precedes the folding position; {@code V} also is\n     * the result type of the {@code combiner}. {@code A}/{@code a} denote the\n     * types and values of the {@code N} parameters and arguments at the folding\n     * position. {@code Z}/{@code z} and {@code B}/{@code b} represent the types\n     * and values of the {@code target} parameters and arguments that precede and\n     * follow the folded parameters and arguments starting at {@code pos},\n     * respectively.\n     * <blockquote><pre>{@code\n     * // there are N arguments in A...\n     * T target(Z..., V, A[N]..., B...);\n     * V combiner(A...);\n     * T adapter(Z... z, A... a, B... b) {\n     *   V v = combiner(a...);\n     *   return target(z..., v, a..., b...);\n     * }\n     * // and if the combiner has a void return:\n     * T target2(Z..., A[N]..., B...);\n     * void combiner2(A...);\n     * T adapter2(Z... z, A... a, B... b) {\n     *   combiner2(a...);\n     *   return target2(z..., a..., b...);\n     * }\n     * }</pre></blockquote>\n     * <p>\n     * <em>Note:</em> The resulting adapter is never a {@linkplain MethodHandle#asVarargsCollector\n     * variable-arity method handle}, even if the original target method handle was.\n     *\n     * @param target the method handle to invoke after arguments are combined\n     * @param pos the position at which to start folding and at which to insert the folding result; if this is {@code\n     *            0}, the effect is the same as for {@link #foldArguments(MethodHandle, MethodHandle)}.\n     * @param combiner method handle to call initially on the incoming arguments\n     * @return method handle which incorporates the specified argument folding logic\n     * @throws NullPointerException if either argument is null\n     * @throws IllegalArgumentException if either of the following two conditions holds:\n     *          (1) {@code combiner}'s return type is non-{@code void} and not the same as the argument type at position\n     *              {@code pos} of the target signature;\n     *          (2) the {@code N} argument types at position {@code pos} of the target signature (skipping one matching\n     *              the {@code combiner}'s return type) are not identical with the argument types of {@code combiner}.\n     *\n     * @see #foldArguments(MethodHandle, MethodHandle)\n     * @since 9\n     ",
    "links" : [ "#foldArguments(MethodHandle" ]
  }, {
    "name" : "private static Class<?> foldArgumentChecks(int foldPos, MethodType targetType, MethodType combinerType)",
    "returnType" : "Class<?>",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public static MethodHandle guardWithTest(MethodHandle test, MethodHandle target, MethodHandle fallback)",
    "returnType" : "MethodHandle",
    "comment" : "\n     * Makes a method handle which adapts a target method handle,\n     * by guarding it with a test, a boolean-valued method handle.\n     * If the guard fails, a fallback handle is called instead.\n     * All three method handles must have the same corresponding\n     * argument and return types, except that the return type\n     * of the test must be boolean, and the test is allowed\n     * to have fewer arguments than the other two method handles.\n     * <p> Here is pseudocode for the resulting adapter:\n     * <blockquote><pre>{@code\n     * boolean test(A...);\n     * T target(A...,B...);\n     * T fallback(A...,B...);\n     * T adapter(A... a,B... b) {\n     *   if (test(a...))\n     *     return target(a..., b...);\n     *   else\n     *     return fallback(a..., b...);\n     * }\n     * }</pre></blockquote>\n     * Note that the test arguments ({@code a...} in the pseudocode) cannot\n     * be modified by execution of the test, and so are passed unchanged\n     * from the caller to the target or fallback as appropriate.\n     * @param test method handle used for test, must return boolean\n     * @param target method handle to call if test passes\n     * @param fallback method handle to call if test fails\n     * @return method handle which incorporates the specified if/then/else logic\n     * @throws NullPointerException if any argument is null\n     * @throws IllegalArgumentException if {@code test} does not return boolean,\n     *          or if all three method types do not match (with the return\n     *          type of {@code test} changed to match that of the target).\n     ",
    "links" : [ ]
  }, {
    "name" : " static RuntimeException misMatchedTypes(String what, T t1, T t2)",
    "returnType" : "RuntimeException",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public static MethodHandle catchException(MethodHandle target, Class<? extends Throwable> exType, MethodHandle handler)",
    "returnType" : "MethodHandle",
    "comment" : "\n     * Makes a method handle which adapts a target method handle,\n     * by running it inside an exception handler.\n     * If the target returns normally, the adapter returns that value.\n     * If an exception matching the specified type is thrown, the fallback\n     * handle is called instead on the exception, plus the original arguments.\n     * <p>\n     * The target and handler must have the same corresponding\n     * argument and return types, except that handler may omit trailing arguments\n     * (similarly to the predicate in {@link #guardWithTest guardWithTest}).\n     * Also, the handler must have an extra leading parameter of {@code exType} or a supertype.\n     * <p>\n     * Here is pseudocode for the resulting adapter. In the code, {@code T}\n     * represents the return type of the {@code target} and {@code handler},\n     * and correspondingly that of the resulting adapter; {@code A}/{@code a},\n     * the types and values of arguments to the resulting handle consumed by\n     * {@code handler}; and {@code B}/{@code b}, those of arguments to the\n     * resulting handle discarded by {@code handler}.\n     * <blockquote><pre>{@code\n     * T target(A..., B...);\n     * T handler(ExType, A...);\n     * T adapter(A... a, B... b) {\n     *   try {\n     *     return target(a..., b...);\n     *   } catch (ExType ex) {\n     *     return handler(ex, a...);\n     *   }\n     * }\n     * }</pre></blockquote>\n     * Note that the saved arguments ({@code a...} in the pseudocode) cannot\n     * be modified by execution of the target, and so are passed unchanged\n     * from the caller to the handler, if the handler is invoked.\n     * <p>\n     * The target and handler must return the same type, even if the handler\n     * always throws.  (This might happen, for instance, because the handler\n     * is simulating a {@code finally} clause).\n     * To create such a throwing handler, compose the handler creation logic\n     * with {@link #throwException throwException},\n     * in order to create a method handle of the correct return type.\n     * @param target method handle to call\n     * @param exType the type of exception which the handler will catch\n     * @param handler method handle to call if a matching exception is thrown\n     * @return method handle which incorporates the specified try/catch logic\n     * @throws NullPointerException if any argument is null\n     * @throws IllegalArgumentException if {@code handler} does not accept\n     *          the given exception type, or if the method handle types do\n     *          not match in their return types and their\n     *          corresponding parameters\n     * @see MethodHandles#tryFinally(MethodHandle, MethodHandle)\n     ",
    "links" : [ "#guardWithTest", "#throwException" ]
  }, {
    "name" : "public static MethodHandle throwException(Class<?> returnType, Class<? extends Throwable> exType)",
    "returnType" : "MethodHandle",
    "comment" : "\n     * Produces a method handle which will throw exceptions of the given {@code exType}.\n     * The method handle will accept a single argument of {@code exType},\n     * and immediately throw it as an exception.\n     * The method type will nominally specify a return of {@code returnType}.\n     * The return type may be anything convenient:  It doesn't matter to the\n     * method handle's behavior, since it will never return normally.\n     * @param returnType the return type of the desired method handle\n     * @param exType the parameter type of the desired method handle\n     * @return method handle which can throw the given exceptions\n     * @throws NullPointerException if either argument is null\n     ",
    "links" : [ ]
  }, {
    "name" : "public static MethodHandle loop(MethodHandle[]... clauses)",
    "returnType" : "MethodHandle",
    "comment" : "\n     * Constructs a method handle representing a loop with several loop variables that are updated and checked upon each\n     * iteration. Upon termination of the loop due to one of the predicates, a corresponding finalizer is run and\n     * delivers the loop's result, which is the return value of the resulting handle.\n     * <p>\n     * Intuitively, every loop is formed by one or more \"clauses\", each specifying a local <em>iteration variable</em> and/or a loop\n     * exit. Each iteration of the loop executes each clause in order. A clause can optionally update its iteration\n     * variable; it can also optionally perform a test and conditional loop exit. In order to express this logic in\n     * terms of method handles, each clause will specify up to four independent actions:<ul>\n     * <li><em>init:</em> Before the loop executes, the initialization of an iteration variable {@code v} of type {@code V}.\n     * <li><em>step:</em> When a clause executes, an update step for the iteration variable {@code v}.\n     * <li><em>pred:</em> When a clause executes, a predicate execution to test for loop exit.\n     * <li><em>fini:</em> If a clause causes a loop exit, a finalizer execution to compute the loop's return value.\n     * </ul>\n     * The full sequence of all iteration variable types, in clause order, will be notated as {@code (V...)}.\n     * The values themselves will be {@code (v...)}.  When we speak of \"parameter lists\", we will usually\n     * be referring to types, but in some contexts (describing execution) the lists will be of actual values.\n     * <p>\n     * Some of these clause parts may be omitted according to certain rules, and useful default behavior is provided in\n     * this case. See below for a detailed description.\n     * <p>\n     * <em>Parameters optional everywhere:</em>\n     * Each clause function is allowed but not required to accept a parameter for each iteration variable {@code v}.\n     * As an exception, the init functions cannot take any {@code v} parameters,\n     * because those values are not yet computed when the init functions are executed.\n     * Any clause function may neglect to take any trailing subsequence of parameters it is entitled to take.\n     * In fact, any clause function may take no arguments at all.\n     * <p>\n     * <em>Loop parameters:</em>\n     * A clause function may take all the iteration variable values it is entitled to, in which case\n     * it may also take more trailing parameters. Such extra values are called <em>loop parameters</em>,\n     * with their types and values notated as {@code (A...)} and {@code (a...)}.\n     * These become the parameters of the resulting loop handle, to be supplied whenever the loop is executed.\n     * (Since init functions do not accept iteration variables {@code v}, any parameter to an\n     * init function is automatically a loop parameter {@code a}.)\n     * As with iteration variables, clause functions are allowed but not required to accept loop parameters.\n     * These loop parameters act as loop-invariant values visible across the whole loop.\n     * <p>\n     * <em>Parameters visible everywhere:</em>\n     * Each non-init clause function is permitted to observe the entire loop state, because it can be passed the full\n     * list {@code (v... a...)} of current iteration variable values and incoming loop parameters.\n     * The init functions can observe initial pre-loop state, in the form {@code (a...)}.\n     * Most clause functions will not need all of this information, but they will be formally connected to it\n     * as if by {@link #dropArguments}.\n     * <a id=\"astar\"></a>\n     * More specifically, we shall use the notation {@code (V*)} to express an arbitrary prefix of a full\n     * sequence {@code (V...)} (and likewise for {@code (v*)}, {@code (A*)}, {@code (a*)}).\n     * In that notation, the general form of an init function parameter list\n     * is {@code (A*)}, and the general form of a non-init function parameter list is {@code (V*)} or {@code (V... A*)}.\n     * <p>\n     * <em>Checking clause structure:</em>\n     * Given a set of clauses, there is a number of checks and adjustments performed to connect all the parts of the\n     * loop. They are spelled out in detail in the steps below. In these steps, every occurrence of the word \"must\"\n     * corresponds to a place where {@link IllegalArgumentException} will be thrown if the required constraint is not\n     * met by the inputs to the loop combinator.\n     * <p>\n     * <em>Effectively identical sequences:</em>\n     * <a id=\"effid\"></a>\n     * A parameter list {@code A} is defined to be <em>effectively identical</em> to another parameter list {@code B}\n     * if {@code A} and {@code B} are identical, or if {@code A} is shorter and is identical with a proper prefix of {@code B}.\n     * When speaking of an unordered set of parameter lists, we say they the set is \"effectively identical\"\n     * as a whole if the set contains a longest list, and all members of the set are effectively identical to\n     * that longest list.\n     * For example, any set of type sequences of the form {@code (V*)} is effectively identical,\n     * and the same is true if more sequences of the form {@code (V... A*)} are added.\n     * <p>\n     * <em>Step 0: Determine clause structure.</em><ol type=\"a\">\n     * <li>The clause array (of type {@code MethodHandle[][]}) must be non-{@code null} and contain at least one element.\n     * <li>The clause array may not contain {@code null}s or sub-arrays longer than four elements.\n     * <li>Clauses shorter than four elements are treated as if they were padded by {@code null} elements to length\n     * four. Padding takes place by appending elements to the array.\n     * <li>Clauses with all {@code null}s are disregarded.\n     * <li>Each clause is treated as a four-tuple of functions, called \"init\", \"step\", \"pred\", and \"fini\".\n     * </ol>\n     * <p>\n     * <em>Step 1A: Determine iteration variable types {@code (V...)}.</em><ol type=\"a\">\n     * <li>The iteration variable type for each clause is determined using the clause's init and step return types.\n     * <li>If both functions are omitted, there is no iteration variable for the corresponding clause ({@code void} is\n     * used as the type to indicate that). If one of them is omitted, the other's return type defines the clause's\n     * iteration variable type. If both are given, the common return type (they must be identical) defines the clause's\n     * iteration variable type.\n     * <li>Form the list of return types (in clause order), omitting all occurrences of {@code void}.\n     * <li>This list of types is called the \"iteration variable types\" ({@code (V...)}).\n     * </ol>\n     * <p>\n     * <em>Step 1B: Determine loop parameters {@code (A...)}.</em><ul>\n     * <li>Examine and collect init function parameter lists (which are of the form {@code (A*)}).\n     * <li>Examine and collect the suffixes of the step, pred, and fini parameter lists, after removing the iteration variable types.\n     * (They must have the form {@code (V... A*)}; collect the {@code (A*)} parts only.)\n     * <li>Do not collect suffixes from step, pred, and fini parameter lists that do not begin with all the iteration variable types.\n     * (These types will be checked in step 2, along with all the clause function types.)\n     * <li>Omitted clause functions are ignored.  (Equivalently, they are deemed to have empty parameter lists.)\n     * <li>All of the collected parameter lists must be effectively identical.\n     * <li>The longest parameter list (which is necessarily unique) is called the \"external parameter list\" ({@code (A...)}).\n     * <li>If there is no such parameter list, the external parameter list is taken to be the empty sequence.\n     * <li>The combined list consisting of iteration variable types followed by the external parameter types is called\n     * the \"internal parameter list\".\n     * </ul>\n     * <p>\n     * <em>Step 1C: Determine loop return type.</em><ol type=\"a\">\n     * <li>Examine fini function return types, disregarding omitted fini functions.\n     * <li>If there are no fini functions, the loop return type is {@code void}.\n     * <li>Otherwise, the common return type {@code R} of the fini functions (their return types must be identical) defines the loop return\n     * type.\n     * </ol>\n     * <p>\n     * <em>Step 1D: Check other types.</em><ol type=\"a\">\n     * <li>There must be at least one non-omitted pred function.\n     * <li>Every non-omitted pred function must have a {@code boolean} return type.\n     * </ol>\n     * <p>\n     * <em>Step 2: Determine parameter lists.</em><ol type=\"a\">\n     * <li>The parameter list for the resulting loop handle will be the external parameter list {@code (A...)}.\n     * <li>The parameter list for init functions will be adjusted to the external parameter list.\n     * (Note that their parameter lists are already effectively identical to this list.)\n     * <li>The parameter list for every non-omitted, non-init (step, pred, and fini) function must be\n     * effectively identical to the internal parameter list {@code (V... A...)}.\n     * </ol>\n     * <p>\n     * <em>Step 3: Fill in omitted functions.</em><ol type=\"a\">\n     * <li>If an init function is omitted, use a {@linkplain #empty default value} for the clause's iteration variable\n     * type.\n     * <li>If a step function is omitted, use an {@linkplain #identity identity function} of the clause's iteration\n     * variable type; insert dropped argument parameters before the identity function parameter for the non-{@code void}\n     * iteration variables of preceding clauses. (This will turn the loop variable into a local loop invariant.)\n     * <li>If a pred function is omitted, use a constant {@code true} function. (This will keep the loop going, as far\n     * as this clause is concerned.  Note that in such cases the corresponding fini function is unreachable.)\n     * <li>If a fini function is omitted, use a {@linkplain #empty default value} for the\n     * loop return type.\n     * </ol>\n     * <p>\n     * <em>Step 4: Fill in missing parameter types.</em><ol type=\"a\">\n     * <li>At this point, every init function parameter list is effectively identical to the external parameter list {@code (A...)},\n     * but some lists may be shorter. For every init function with a short parameter list, pad out the end of the list.\n     * <li>At this point, every non-init function parameter list is effectively identical to the internal parameter\n     * list {@code (V... A...)}, but some lists may be shorter. For every non-init function with a short parameter list,\n     * pad out the end of the list.\n     * <li>Argument lists are padded out by {@linkplain #dropArgumentsToMatch(MethodHandle, int, List, int) dropping unused trailing arguments}.\n     * </ol>\n     * <p>\n     * <em>Final observations.</em><ol type=\"a\">\n     * <li>After these steps, all clauses have been adjusted by supplying omitted functions and arguments.\n     * <li>All init functions have a common parameter type list {@code (A...)}, which the final loop handle will also have.\n     * <li>All fini functions have a common return type {@code R}, which the final loop handle will also have.\n     * <li>All non-init functions have a common parameter type list {@code (V... A...)}, of\n     * (non-{@code void}) iteration variables {@code V} followed by loop parameters.\n     * <li>Each pair of init and step functions agrees in their return type {@code V}.\n     * <li>Each non-init function will be able to observe the current values {@code (v...)} of all iteration variables.\n     * <li>Every function will be able to observe the incoming values {@code (a...)} of all loop parameters.\n     * </ol>\n     * <p>\n     * <em>Example.</em> As a consequence of step 1A above, the {@code loop} combinator has the following property:\n     * <ul>\n     * <li>Given {@code N} clauses {@code Cn = {null, Sn, Pn}} with {@code n = 1..N}.\n     * <li>Suppose predicate handles {@code Pn} are either {@code null} or have no parameters.\n     * (Only one {@code Pn} has to be non-{@code null}.)\n     * <li>Suppose step handles {@code Sn} have signatures {@code (B1..BX)Rn}, for some constant {@code X>=N}.\n     * <li>Suppose {@code Q} is the count of non-void types {@code Rn}, and {@code (V1...VQ)} is the sequence of those types.\n     * <li>It must be that {@code Vn == Bn} for {@code n = 1..min(X,Q)}.\n     * <li>The parameter types {@code Vn} will be interpreted as loop-local state elements {@code (V...)}.\n     * <li>Any remaining types {@code BQ+1..BX} (if {@code Q<X}) will determine\n     * the resulting loop handle's parameter types {@code (A...)}.\n     * </ul>\n     * In this example, the loop handle parameters {@code (A...)} were derived from the step functions,\n     * which is natural if most of the loop computation happens in the steps.  For some loops,\n     * the burden of computation might be heaviest in the pred functions, and so the pred functions\n     * might need to accept the loop parameter values.  For loops with complex exit logic, the fini\n     * functions might need to accept loop parameters, and likewise for loops with complex entry logic,\n     * where the init functions will need the extra parameters.  For such reasons, the rules for\n     * determining these parameters are as symmetric as possible, across all clause parts.\n     * In general, the loop parameters function as common invariant values across the whole\n     * loop, while the iteration variables function as common variant values, or (if there is\n     * no step function) as internal loop invariant temporaries.\n     * <p>\n     * <em>Loop execution.</em><ol type=\"a\">\n     * <li>When the loop is called, the loop input values are saved in locals, to be passed to\n     * every clause function. These locals are loop invariant.\n     * <li>Each init function is executed in clause order (passing the external arguments {@code (a...)})\n     * and the non-{@code void} values are saved (as the iteration variables {@code (v...)}) into locals.\n     * These locals will be loop varying (unless their steps behave as identity functions, as noted above).\n     * <li>All function executions (except init functions) will be passed the internal parameter list, consisting of\n     * the non-{@code void} iteration values {@code (v...)} (in clause order) and then the loop inputs {@code (a...)}\n     * (in argument order).\n     * <li>The step and pred functions are then executed, in clause order (step before pred), until a pred function\n     * returns {@code false}.\n     * <li>The non-{@code void} result from a step function call is used to update the corresponding value in the\n     * sequence {@code (v...)} of loop variables.\n     * The updated value is immediately visible to all subsequent function calls.\n     * <li>If a pred function returns {@code false}, the corresponding fini function is called, and the resulting value\n     * (of type {@code R}) is returned from the loop as a whole.\n     * <li>If all the pred functions always return true, no fini function is ever invoked, and the loop cannot exit\n     * except by throwing an exception.\n     * </ol>\n     * <p>\n     * <em>Usage tips.</em>\n     * <ul>\n     * <li>Although each step function will receive the current values of <em>all</em> the loop variables,\n     * sometimes a step function only needs to observe the current value of its own variable.\n     * In that case, the step function may need to explicitly {@linkplain #dropArguments drop all preceding loop variables}.\n     * This will require mentioning their types, in an expression like {@code dropArguments(step, 0, V0.class, ...)}.\n     * <li>Loop variables are not required to vary; they can be loop invariant.  A clause can create\n     * a loop invariant by a suitable init function with no step, pred, or fini function.  This may be\n     * useful to \"wire\" an incoming loop argument into the step or pred function of an adjacent loop variable.\n     * <li>If some of the clause functions are virtual methods on an instance, the instance\n     * itself can be conveniently placed in an initial invariant loop \"variable\", using an initial clause\n     * like {@code new MethodHandle[]{identity(ObjType.class)}}.  In that case, the instance reference\n     * will be the first iteration variable value, and it will be easy to use virtual\n     * methods as clause parts, since all of them will take a leading instance reference matching that value.\n     * </ul>\n     * <p>\n     * Here is pseudocode for the resulting loop handle. As above, {@code V} and {@code v} represent the types\n     * and values of loop variables; {@code A} and {@code a} represent arguments passed to the whole loop;\n     * and {@code R} is the common result type of all finalizers as well as of the resulting loop.\n     * <blockquote><pre>{@code\n     * V... init...(A...);\n     * boolean pred...(V..., A...);\n     * V... step...(V..., A...);\n     * R fini...(V..., A...);\n     * R loop(A... a) {\n     *   V... v... = init...(a...);\n     *   for (;;) {\n     *     for ((v, p, s, f) in (v..., pred..., step..., fini...)) {\n     *       v = s(v..., a...);\n     *       if (!p(v..., a...)) {\n     *         return f(v..., a...);\n     *       }\n     *     }\n     *   }\n     * }\n     * }</pre></blockquote>\n     * Note that the parameter type lists {@code (V...)} and {@code (A...)} have been expanded\n     * to their full length, even though individual clause functions may neglect to take them all.\n     * As noted above, missing parameters are filled in as if by {@link #dropArgumentsToMatch(MethodHandle, int, List, int)}.\n     *\n     * @apiNote Example:\n     * <blockquote><pre>{@code\n     * // iterative implementation of the factorial function as a loop handle\n     * static int one(int k) { return 1; }\n     * static int inc(int i, int acc, int k) { return i + 1; }\n     * static int mult(int i, int acc, int k) { return i * acc; }\n     * static boolean pred(int i, int acc, int k) { return i < k; }\n     * static int fin(int i, int acc, int k) { return acc; }\n     * // assume MH_one, MH_inc, MH_mult, MH_pred, and MH_fin are handles to the above methods\n     * // null initializer for counter, should initialize to 0\n     * MethodHandle[] counterClause = new MethodHandle[]{null, MH_inc};\n     * MethodHandle[] accumulatorClause = new MethodHandle[]{MH_one, MH_mult, MH_pred, MH_fin};\n     * MethodHandle loop = MethodHandles.loop(counterClause, accumulatorClause);\n     * assertEquals(120, loop.invoke(5));\n     * }</pre></blockquote>\n     * The same example, dropping arguments and using combinators:\n     * <blockquote><pre>{@code\n     * // simplified implementation of the factorial function as a loop handle\n     * static int inc(int i) { return i + 1; } // drop acc, k\n     * static int mult(int i, int acc) { return i * acc; } //drop k\n     * static boolean cmp(int i, int k) { return i < k; }\n     * // assume MH_inc, MH_mult, and MH_cmp are handles to the above methods\n     * // null initializer for counter, should initialize to 0\n     * MethodHandle MH_one = MethodHandles.constant(int.class, 1);\n     * MethodHandle MH_pred = MethodHandles.dropArguments(MH_cmp, 1, int.class); // drop acc\n     * MethodHandle MH_fin = MethodHandles.dropArguments(MethodHandles.identity(int.class), 0, int.class); // drop i\n     * MethodHandle[] counterClause = new MethodHandle[]{null, MH_inc};\n     * MethodHandle[] accumulatorClause = new MethodHandle[]{MH_one, MH_mult, MH_pred, MH_fin};\n     * MethodHandle loop = MethodHandles.loop(counterClause, accumulatorClause);\n     * assertEquals(720, loop.invoke(6));\n     * }</pre></blockquote>\n     * A similar example, using a helper object to hold a loop parameter:\n     * <blockquote><pre>{@code\n     * // instance-based implementation of the factorial function as a loop handle\n     * static class FacLoop {\n     *   final int k;\n     *   FacLoop(int k) { this.k = k; }\n     *   int inc(int i) { return i + 1; }\n     *   int mult(int i, int acc) { return i * acc; }\n     *   boolean pred(int i) { return i < k; }\n     *   int fin(int i, int acc) { return acc; }\n     * }\n     * // assume MH_FacLoop is a handle to the constructor\n     * // assume MH_inc, MH_mult, MH_pred, and MH_fin are handles to the above methods\n     * // null initializer for counter, should initialize to 0\n     * MethodHandle MH_one = MethodHandles.constant(int.class, 1);\n     * MethodHandle[] instanceClause = new MethodHandle[]{MH_FacLoop};\n     * MethodHandle[] counterClause = new MethodHandle[]{null, MH_inc};\n     * MethodHandle[] accumulatorClause = new MethodHandle[]{MH_one, MH_mult, MH_pred, MH_fin};\n     * MethodHandle loop = MethodHandles.loop(instanceClause, counterClause, accumulatorClause);\n     * assertEquals(5040, loop.invoke(7));\n     * }</pre></blockquote>\n     *\n     * @param clauses an array of arrays (4-tuples) of {@link MethodHandle}s adhering to the rules described above.\n     *\n     * @return a method handle embodying the looping behavior as defined by the arguments.\n     *\n     * @throws IllegalArgumentException in case any of the constraints described above is violated.\n     *\n     * @see MethodHandles#whileLoop(MethodHandle, MethodHandle, MethodHandle)\n     * @see MethodHandles#doWhileLoop(MethodHandle, MethodHandle, MethodHandle)\n     * @see MethodHandles#countedLoop(MethodHandle, MethodHandle, MethodHandle)\n     * @see MethodHandles#iteratedLoop(MethodHandle, MethodHandle, MethodHandle)\n     * @since 9\n     ",
    "links" : [ "#dropArguments", "java.lang.invoke.MethodHandle", "java.lang.invoke.MethodHandleStatics.newIllegalArgumentException", "#dropArgumentsToMatch(MethodHandle" ]
  }, {
    "name" : "private static void loopChecks0(MethodHandle[][] clauses)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private static void loopChecks1a(int i, MethodHandle in, MethodHandle st)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private static List<Class<?>> longestParameterList(Stream<MethodHandle> mhs, int skipSize)",
    "returnType" : "List<Class<?>>",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private static List<Class<?>> longestParameterList(List<List<Class<?>>> lists)",
    "returnType" : "List<Class<?>>",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private static List<Class<?>> buildCommonSuffix(List<MethodHandle> init, List<MethodHandle> step, List<MethodHandle> pred, List<MethodHandle> fini, int cpSize)",
    "returnType" : "List<Class<?>>",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private static void loopChecks1b(List<MethodHandle> init, List<Class<?>> commonSuffix)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private static void loopChecks1cd(List<MethodHandle> pred, List<MethodHandle> fini, Class<?> loopReturnType)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private static void loopChecks2(List<MethodHandle> step, List<MethodHandle> pred, List<MethodHandle> fini, List<Class<?>> commonParameterSequence)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private static List<MethodHandle> fillParameterTypes(List<MethodHandle> hs, final List<Class<?>> targetParams)",
    "returnType" : "List<MethodHandle>",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private static List<MethodHandle> fixArities(List<MethodHandle> hs)",
    "returnType" : "List<MethodHandle>",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public static MethodHandle whileLoop(MethodHandle init, MethodHandle pred, MethodHandle body)",
    "returnType" : "MethodHandle",
    "comment" : "\n     * Constructs a {@code while} loop from an initializer, a body, and a predicate.\n     * This is a convenience wrapper for the {@linkplain #loop(MethodHandle[][]) generic loop combinator}.\n     * <p>\n     * The {@code pred} handle describes the loop condition; and {@code body}, its body. The loop resulting from this\n     * method will, in each iteration, first evaluate the predicate and then execute its body (if the predicate\n     * evaluates to {@code true}).\n     * The loop will terminate once the predicate evaluates to {@code false} (the body will not be executed in this case).\n     * <p>\n     * The {@code init} handle describes the initial value of an additional optional loop-local variable.\n     * In each iteration, this loop-local variable, if present, will be passed to the {@code body}\n     * and updated with the value returned from its invocation. The result of loop execution will be\n     * the final value of the additional loop-local variable (if present).\n     * <p>\n     * The following rules hold for these argument handles:<ul>\n     * <li>The {@code body} handle must not be {@code null}; its type must be of the form\n     * {@code (V A...)V}, where {@code V} is non-{@code void}, or else {@code (A...)void}.\n     * (In the {@code void} case, we assign the type {@code void} to the name {@code V},\n     * and we will write {@code (V A...)V} with the understanding that a {@code void} type {@code V}\n     * is quietly dropped from the parameter list, leaving {@code (A...)V}.)\n     * <li>The parameter list {@code (V A...)} of the body is called the <em>internal parameter list</em>.\n     * It will constrain the parameter lists of the other loop parts.\n     * <li>If the iteration variable type {@code V} is dropped from the internal parameter list, the resulting shorter\n     * list {@code (A...)} is called the <em>external parameter list</em>.\n     * <li>The body return type {@code V}, if non-{@code void}, determines the type of an\n     * additional state variable of the loop.\n     * The body must both accept and return a value of this type {@code V}.\n     * <li>If {@code init} is non-{@code null}, it must have return type {@code V}.\n     * Its parameter list (of some <a href=\"MethodHandles.html#astar\">form {@code (A*)}</a>) must be\n     * <a href=\"MethodHandles.html#effid\">effectively identical</a>\n     * to the external parameter list {@code (A...)}.\n     * <li>If {@code init} is {@code null}, the loop variable will be initialized to its\n     * {@linkplain #empty default value}.\n     * <li>The {@code pred} handle must not be {@code null}.  It must have {@code boolean} as its return type.\n     * Its parameter list (either empty or of the form {@code (V A*)}) must be\n     * effectively identical to the internal parameter list.\n     * </ul>\n     * <p>\n     * The resulting loop handle's result type and parameter signature are determined as follows:<ul>\n     * <li>The loop handle's result type is the result type {@code V} of the body.\n     * <li>The loop handle's parameter types are the types {@code (A...)},\n     * from the external parameter list.\n     * </ul>\n     * <p>\n     * Here is pseudocode for the resulting loop handle. In the code, {@code V}/{@code v} represent the type / value of\n     * the sole loop variable as well as the result type of the loop; and {@code A}/{@code a}, that of the argument\n     * passed to the loop.\n     * <blockquote><pre>{@code\n     * V init(A...);\n     * boolean pred(V, A...);\n     * V body(V, A...);\n     * V whileLoop(A... a...) {\n     *   V v = init(a...);\n     *   while (pred(v, a...)) {\n     *     v = body(v, a...);\n     *   }\n     *   return v;\n     * }\n     * }</pre></blockquote>\n     *\n     * @apiNote Example:\n     * <blockquote><pre>{@code\n     * // implement the zip function for lists as a loop handle\n     * static List<String> initZip(Iterator<String> a, Iterator<String> b) { return new ArrayList<>(); }\n     * static boolean zipPred(List<String> zip, Iterator<String> a, Iterator<String> b) { return a.hasNext() && b.hasNext(); }\n     * static List<String> zipStep(List<String> zip, Iterator<String> a, Iterator<String> b) {\n     *   zip.add(a.next());\n     *   zip.add(b.next());\n     *   return zip;\n     * }\n     * // assume MH_initZip, MH_zipPred, and MH_zipStep are handles to the above methods\n     * MethodHandle loop = MethodHandles.whileLoop(MH_initZip, MH_zipPred, MH_zipStep);\n     * List<String> a = Arrays.asList(\"a\", \"b\", \"c\", \"d\");\n     * List<String> b = Arrays.asList(\"e\", \"f\", \"g\", \"h\");\n     * List<String> zipped = Arrays.asList(\"a\", \"e\", \"b\", \"f\", \"c\", \"g\", \"d\", \"h\");\n     * assertEquals(zipped, (List<String>) loop.invoke(a.iterator(), b.iterator()));\n     * }</pre></blockquote>\n     *\n     *\n     * @apiNote The implementation of this method can be expressed as follows:\n     * <blockquote><pre>{@code\n     * MethodHandle whileLoop(MethodHandle init, MethodHandle pred, MethodHandle body) {\n     *     MethodHandle fini = (body.type().returnType() == void.class\n     *                         ? null : identity(body.type().returnType()));\n     *     MethodHandle[]\n     *         checkExit = { null, null, pred, fini },\n     *         varBody   = { init, body };\n     *     return loop(checkExit, varBody);\n     * }\n     * }</pre></blockquote>\n     *\n     * @param init optional initializer, providing the initial value of the loop variable.\n     *             May be {@code null}, implying a default initial value.  See above for other constraints.\n     * @param pred condition for the loop, which may not be {@code null}. Its result type must be {@code boolean}. See\n     *             above for other constraints.\n     * @param body body of the loop, which may not be {@code null}. It controls the loop parameters and result type.\n     *             See above for other constraints.\n     *\n     * @return a method handle implementing the {@code while} loop as described by the arguments.\n     * @throws IllegalArgumentException if the rules for the arguments are violated.\n     * @throws NullPointerException if {@code pred} or {@code body} are {@code null}.\n     *\n     * @see #loop(MethodHandle[][])\n     * @see #doWhileLoop(MethodHandle, MethodHandle, MethodHandle)\n     * @since 9\n     ",
    "links" : [ ]
  }, {
    "name" : "public static MethodHandle doWhileLoop(MethodHandle init, MethodHandle body, MethodHandle pred)",
    "returnType" : "MethodHandle",
    "comment" : "\n     * Constructs a {@code do-while} loop from an initializer, a body, and a predicate.\n     * This is a convenience wrapper for the {@linkplain #loop(MethodHandle[][]) generic loop combinator}.\n     * <p>\n     * The {@code pred} handle describes the loop condition; and {@code body}, its body. The loop resulting from this\n     * method will, in each iteration, first execute its body and then evaluate the predicate.\n     * The loop will terminate once the predicate evaluates to {@code false} after an execution of the body.\n     * <p>\n     * The {@code init} handle describes the initial value of an additional optional loop-local variable.\n     * In each iteration, this loop-local variable, if present, will be passed to the {@code body}\n     * and updated with the value returned from its invocation. The result of loop execution will be\n     * the final value of the additional loop-local variable (if present).\n     * <p>\n     * The following rules hold for these argument handles:<ul>\n     * <li>The {@code body} handle must not be {@code null}; its type must be of the form\n     * {@code (V A...)V}, where {@code V} is non-{@code void}, or else {@code (A...)void}.\n     * (In the {@code void} case, we assign the type {@code void} to the name {@code V},\n     * and we will write {@code (V A...)V} with the understanding that a {@code void} type {@code V}\n     * is quietly dropped from the parameter list, leaving {@code (A...)V}.)\n     * <li>The parameter list {@code (V A...)} of the body is called the <em>internal parameter list</em>.\n     * It will constrain the parameter lists of the other loop parts.\n     * <li>If the iteration variable type {@code V} is dropped from the internal parameter list, the resulting shorter\n     * list {@code (A...)} is called the <em>external parameter list</em>.\n     * <li>The body return type {@code V}, if non-{@code void}, determines the type of an\n     * additional state variable of the loop.\n     * The body must both accept and return a value of this type {@code V}.\n     * <li>If {@code init} is non-{@code null}, it must have return type {@code V}.\n     * Its parameter list (of some <a href=\"MethodHandles.html#astar\">form {@code (A*)}</a>) must be\n     * <a href=\"MethodHandles.html#effid\">effectively identical</a>\n     * to the external parameter list {@code (A...)}.\n     * <li>If {@code init} is {@code null}, the loop variable will be initialized to its\n     * {@linkplain #empty default value}.\n     * <li>The {@code pred} handle must not be {@code null}.  It must have {@code boolean} as its return type.\n     * Its parameter list (either empty or of the form {@code (V A*)}) must be\n     * effectively identical to the internal parameter list.\n     * </ul>\n     * <p>\n     * The resulting loop handle's result type and parameter signature are determined as follows:<ul>\n     * <li>The loop handle's result type is the result type {@code V} of the body.\n     * <li>The loop handle's parameter types are the types {@code (A...)},\n     * from the external parameter list.\n     * </ul>\n     * <p>\n     * Here is pseudocode for the resulting loop handle. In the code, {@code V}/{@code v} represent the type / value of\n     * the sole loop variable as well as the result type of the loop; and {@code A}/{@code a}, that of the argument\n     * passed to the loop.\n     * <blockquote><pre>{@code\n     * V init(A...);\n     * boolean pred(V, A...);\n     * V body(V, A...);\n     * V doWhileLoop(A... a...) {\n     *   V v = init(a...);\n     *   do {\n     *     v = body(v, a...);\n     *   } while (pred(v, a...));\n     *   return v;\n     * }\n     * }</pre></blockquote>\n     *\n     * @apiNote Example:\n     * <blockquote><pre>{@code\n     * // int i = 0; while (i < limit) { ++i; } return i; => limit\n     * static int zero(int limit) { return 0; }\n     * static int step(int i, int limit) { return i + 1; }\n     * static boolean pred(int i, int limit) { return i < limit; }\n     * // assume MH_zero, MH_step, and MH_pred are handles to the above methods\n     * MethodHandle loop = MethodHandles.doWhileLoop(MH_zero, MH_step, MH_pred);\n     * assertEquals(23, loop.invoke(23));\n     * }</pre></blockquote>\n     *\n     *\n     * @apiNote The implementation of this method can be expressed as follows:\n     * <blockquote><pre>{@code\n     * MethodHandle doWhileLoop(MethodHandle init, MethodHandle body, MethodHandle pred) {\n     *     MethodHandle fini = (body.type().returnType() == void.class\n     *                         ? null : identity(body.type().returnType()));\n     *     MethodHandle[] clause = { init, body, pred, fini };\n     *     return loop(clause);\n     * }\n     * }</pre></blockquote>\n     *\n     * @param init optional initializer, providing the initial value of the loop variable.\n     *             May be {@code null}, implying a default initial value.  See above for other constraints.\n     * @param body body of the loop, which may not be {@code null}. It controls the loop parameters and result type.\n     *             See above for other constraints.\n     * @param pred condition for the loop, which may not be {@code null}. Its result type must be {@code boolean}. See\n     *             above for other constraints.\n     *\n     * @return a method handle implementing the {@code while} loop as described by the arguments.\n     * @throws IllegalArgumentException if the rules for the arguments are violated.\n     * @throws NullPointerException if {@code pred} or {@code body} are {@code null}.\n     *\n     * @see #loop(MethodHandle[][])\n     * @see #whileLoop(MethodHandle, MethodHandle, MethodHandle)\n     * @since 9\n     ",
    "links" : [ ]
  }, {
    "name" : "private static void whileLoopChecks(MethodHandle init, MethodHandle pred, MethodHandle body)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public static MethodHandle countedLoop(MethodHandle iterations, MethodHandle init, MethodHandle body)",
    "returnType" : "MethodHandle",
    "comment" : "\n     * Constructs a loop that runs a given number of iterations.\n     * This is a convenience wrapper for the {@linkplain #loop(MethodHandle[][]) generic loop combinator}.\n     * <p>\n     * The number of iterations is determined by the {@code iterations} handle evaluation result.\n     * The loop counter {@code i} is an extra loop iteration variable of type {@code int}.\n     * It will be initialized to 0 and incremented by 1 in each iteration.\n     * <p>\n     * If the {@code body} handle returns a non-{@code void} type {@code V}, a leading loop iteration variable\n     * of that type is also present.  This variable is initialized using the optional {@code init} handle,\n     * or to the {@linkplain #empty default value} of type {@code V} if that handle is {@code null}.\n     * <p>\n     * In each iteration, the iteration variables are passed to an invocation of the {@code body} handle.\n     * A non-{@code void} value returned from the body (of type {@code V}) updates the leading\n     * iteration variable.\n     * The result of the loop handle execution will be the final {@code V} value of that variable\n     * (or {@code void} if there is no {@code V} variable).\n     * <p>\n     * The following rules hold for the argument handles:<ul>\n     * <li>The {@code iterations} handle must not be {@code null}, and must return\n     * the type {@code int}, referred to here as {@code I} in parameter type lists.\n     * <li>The {@code body} handle must not be {@code null}; its type must be of the form\n     * {@code (V I A...)V}, where {@code V} is non-{@code void}, or else {@code (I A...)void}.\n     * (In the {@code void} case, we assign the type {@code void} to the name {@code V},\n     * and we will write {@code (V I A...)V} with the understanding that a {@code void} type {@code V}\n     * is quietly dropped from the parameter list, leaving {@code (I A...)V}.)\n     * <li>The parameter list {@code (V I A...)} of the body contributes to a list\n     * of types called the <em>internal parameter list</em>.\n     * It will constrain the parameter lists of the other loop parts.\n     * <li>As a special case, if the body contributes only {@code V} and {@code I} types,\n     * with no additional {@code A} types, then the internal parameter list is extended by\n     * the argument types {@code A...} of the {@code iterations} handle.\n     * <li>If the iteration variable types {@code (V I)} are dropped from the internal parameter list, the resulting shorter\n     * list {@code (A...)} is called the <em>external parameter list</em>.\n     * <li>The body return type {@code V}, if non-{@code void}, determines the type of an\n     * additional state variable of the loop.\n     * The body must both accept a leading parameter and return a value of this type {@code V}.\n     * <li>If {@code init} is non-{@code null}, it must have return type {@code V}.\n     * Its parameter list (of some <a href=\"MethodHandles.html#astar\">form {@code (A*)}</a>) must be\n     * <a href=\"MethodHandles.html#effid\">effectively identical</a>\n     * to the external parameter list {@code (A...)}.\n     * <li>If {@code init} is {@code null}, the loop variable will be initialized to its\n     * {@linkplain #empty default value}.\n     * <li>The parameter list of {@code iterations} (of some form {@code (A*)}) must be\n     * effectively identical to the external parameter list {@code (A...)}.\n     * </ul>\n     * <p>\n     * The resulting loop handle's result type and parameter signature are determined as follows:<ul>\n     * <li>The loop handle's result type is the result type {@code V} of the body.\n     * <li>The loop handle's parameter types are the types {@code (A...)},\n     * from the external parameter list.\n     * </ul>\n     * <p>\n     * Here is pseudocode for the resulting loop handle. In the code, {@code V}/{@code v} represent the type / value of\n     * the second loop variable as well as the result type of the loop; and {@code A...}/{@code a...} represent\n     * arguments passed to the loop.\n     * <blockquote><pre>{@code\n     * int iterations(A...);\n     * V init(A...);\n     * V body(V, int, A...);\n     * V countedLoop(A... a...) {\n     *   int end = iterations(a...);\n     *   V v = init(a...);\n     *   for (int i = 0; i < end; ++i) {\n     *     v = body(v, i, a...);\n     *   }\n     *   return v;\n     * }\n     * }</pre></blockquote>\n     *\n     * @apiNote Example with a fully conformant body method:\n     * <blockquote><pre>{@code\n     * // String s = \"Lambdaman!\"; for (int i = 0; i < 13; ++i) { s = \"na \" + s; } return s;\n     * // => a variation on a well known theme\n     * static String step(String v, int counter, String init) { return \"na \" + v; }\n     * // assume MH_step is a handle to the method above\n     * MethodHandle fit13 = MethodHandles.constant(int.class, 13);\n     * MethodHandle start = MethodHandles.identity(String.class);\n     * MethodHandle loop = MethodHandles.countedLoop(fit13, start, MH_step);\n     * assertEquals(\"na na na na na na na na na na na na na Lambdaman!\", loop.invoke(\"Lambdaman!\"));\n     * }</pre></blockquote>\n     *\n     * @apiNote Example with the simplest possible body method type,\n     * and passing the number of iterations to the loop invocation:\n     * <blockquote><pre>{@code\n     * // String s = \"Lambdaman!\"; for (int i = 0; i < 13; ++i) { s = \"na \" + s; } return s;\n     * // => a variation on a well known theme\n     * static String step(String v, int counter ) { return \"na \" + v; }\n     * // assume MH_step is a handle to the method above\n     * MethodHandle count = MethodHandles.dropArguments(MethodHandles.identity(int.class), 1, String.class);\n     * MethodHandle start = MethodHandles.dropArguments(MethodHandles.identity(String.class), 0, int.class);\n     * MethodHandle loop = MethodHandles.countedLoop(count, start, MH_step);  // (v, i) -> \"na \" + v\n     * assertEquals(\"na na na na na na na na na na na na na Lambdaman!\", loop.invoke(13, \"Lambdaman!\"));\n     * }</pre></blockquote>\n     *\n     * @apiNote Example that treats the number of iterations, string to append to, and string to append\n     * as loop parameters:\n     * <blockquote><pre>{@code\n     * // String s = \"Lambdaman!\", t = \"na\"; for (int i = 0; i < 13; ++i) { s = t + \" \" + s; } return s;\n     * // => a variation on a well known theme\n     * static String step(String v, int counter, int iterations_, String pre, String start_) { return pre + \" \" + v; }\n     * // assume MH_step is a handle to the method above\n     * MethodHandle count = MethodHandles.identity(int.class);\n     * MethodHandle start = MethodHandles.dropArguments(MethodHandles.identity(String.class), 0, int.class, String.class);\n     * MethodHandle loop = MethodHandles.countedLoop(count, start, MH_step);  // (v, i, _, pre, _) -> pre + \" \" + v\n     * assertEquals(\"na na na na na na na na na na na na na Lambdaman!\", loop.invoke(13, \"na\", \"Lambdaman!\"));\n     * }</pre></blockquote>\n     *\n     * @apiNote Example that illustrates the usage of {@link #dropArgumentsToMatch(MethodHandle, int, List, int)}\n     * to enforce a loop type:\n     * <blockquote><pre>{@code\n     * // String s = \"Lambdaman!\", t = \"na\"; for (int i = 0; i < 13; ++i) { s = t + \" \" + s; } return s;\n     * // => a variation on a well known theme\n     * static String step(String v, int counter, String pre) { return pre + \" \" + v; }\n     * // assume MH_step is a handle to the method above\n     * MethodType loopType = methodType(String.class, String.class, int.class, String.class);\n     * MethodHandle count = MethodHandles.dropArgumentsToMatch(MethodHandles.identity(int.class),    0, loopType.parameterList(), 1);\n     * MethodHandle start = MethodHandles.dropArgumentsToMatch(MethodHandles.identity(String.class), 0, loopType.parameterList(), 2);\n     * MethodHandle body  = MethodHandles.dropArgumentsToMatch(MH_step,                              2, loopType.parameterList(), 0);\n     * MethodHandle loop = MethodHandles.countedLoop(count, start, body);  // (v, i, pre, _, _) -> pre + \" \" + v\n     * assertEquals(\"na na na na na na na na na na na na na Lambdaman!\", loop.invoke(\"na\", 13, \"Lambdaman!\"));\n     * }</pre></blockquote>\n     *\n     * @apiNote The implementation of this method can be expressed as follows:\n     * <blockquote><pre>{@code\n     * MethodHandle countedLoop(MethodHandle iterations, MethodHandle init, MethodHandle body) {\n     *     return countedLoop(empty(iterations.type()), iterations, init, body);\n     * }\n     * }</pre></blockquote>\n     *\n     * @param iterations a non-{@code null} handle to return the number of iterations this loop should run. The handle's\n     *                   result type must be {@code int}. See above for other constraints.\n     * @param init optional initializer, providing the initial value of the loop variable.\n     *             May be {@code null}, implying a default initial value.  See above for other constraints.\n     * @param body body of the loop, which may not be {@code null}.\n     *             It controls the loop parameters and result type in the standard case (see above for details).\n     *             It must accept its own return type (if non-void) plus an {@code int} parameter (for the counter),\n     *             and may accept any number of additional types.\n     *             See above for other constraints.\n     *\n     * @return a method handle representing the loop.\n     * @throws NullPointerException if either of the {@code iterations} or {@code body} handles is {@code null}.\n     * @throws IllegalArgumentException if any argument violates the rules formulated above.\n     *\n     * @see #countedLoop(MethodHandle, MethodHandle, MethodHandle, MethodHandle)\n     * @since 9\n     ",
    "links" : [ "#dropArgumentsToMatch(MethodHandle" ]
  }, {
    "name" : "public static MethodHandle countedLoop(MethodHandle start, MethodHandle end, MethodHandle init, MethodHandle body)",
    "returnType" : "MethodHandle",
    "comment" : "\n     * Constructs a loop that counts over a range of numbers.\n     * This is a convenience wrapper for the {@linkplain #loop(MethodHandle[][]) generic loop combinator}.\n     * <p>\n     * The loop counter {@code i} is a loop iteration variable of type {@code int}.\n     * The {@code start} and {@code end} handles determine the start (inclusive) and end (exclusive)\n     * values of the loop counter.\n     * The loop counter will be initialized to the {@code int} value returned from the evaluation of the\n     * {@code start} handle and run to the value returned from {@code end} (exclusively) with a step width of 1.\n     * <p>\n     * If the {@code body} handle returns a non-{@code void} type {@code V}, a leading loop iteration variable\n     * of that type is also present.  This variable is initialized using the optional {@code init} handle,\n     * or to the {@linkplain #empty default value} of type {@code V} if that handle is {@code null}.\n     * <p>\n     * In each iteration, the iteration variables are passed to an invocation of the {@code body} handle.\n     * A non-{@code void} value returned from the body (of type {@code V}) updates the leading\n     * iteration variable.\n     * The result of the loop handle execution will be the final {@code V} value of that variable\n     * (or {@code void} if there is no {@code V} variable).\n     * <p>\n     * The following rules hold for the argument handles:<ul>\n     * <li>The {@code start} and {@code end} handles must not be {@code null}, and must both return\n     * the common type {@code int}, referred to here as {@code I} in parameter type lists.\n     * <li>The {@code body} handle must not be {@code null}; its type must be of the form\n     * {@code (V I A...)V}, where {@code V} is non-{@code void}, or else {@code (I A...)void}.\n     * (In the {@code void} case, we assign the type {@code void} to the name {@code V},\n     * and we will write {@code (V I A...)V} with the understanding that a {@code void} type {@code V}\n     * is quietly dropped from the parameter list, leaving {@code (I A...)V}.)\n     * <li>The parameter list {@code (V I A...)} of the body contributes to a list\n     * of types called the <em>internal parameter list</em>.\n     * It will constrain the parameter lists of the other loop parts.\n     * <li>As a special case, if the body contributes only {@code V} and {@code I} types,\n     * with no additional {@code A} types, then the internal parameter list is extended by\n     * the argument types {@code A...} of the {@code end} handle.\n     * <li>If the iteration variable types {@code (V I)} are dropped from the internal parameter list, the resulting shorter\n     * list {@code (A...)} is called the <em>external parameter list</em>.\n     * <li>The body return type {@code V}, if non-{@code void}, determines the type of an\n     * additional state variable of the loop.\n     * The body must both accept a leading parameter and return a value of this type {@code V}.\n     * <li>If {@code init} is non-{@code null}, it must have return type {@code V}.\n     * Its parameter list (of some <a href=\"MethodHandles.html#astar\">form {@code (A*)}</a>) must be\n     * <a href=\"MethodHandles.html#effid\">effectively identical</a>\n     * to the external parameter list {@code (A...)}.\n     * <li>If {@code init} is {@code null}, the loop variable will be initialized to its\n     * {@linkplain #empty default value}.\n     * <li>The parameter list of {@code start} (of some form {@code (A*)}) must be\n     * effectively identical to the external parameter list {@code (A...)}.\n     * <li>Likewise, the parameter list of {@code end} must be effectively identical\n     * to the external parameter list.\n     * </ul>\n     * <p>\n     * The resulting loop handle's result type and parameter signature are determined as follows:<ul>\n     * <li>The loop handle's result type is the result type {@code V} of the body.\n     * <li>The loop handle's parameter types are the types {@code (A...)},\n     * from the external parameter list.\n     * </ul>\n     * <p>\n     * Here is pseudocode for the resulting loop handle. In the code, {@code V}/{@code v} represent the type / value of\n     * the second loop variable as well as the result type of the loop; and {@code A...}/{@code a...} represent\n     * arguments passed to the loop.\n     * <blockquote><pre>{@code\n     * int start(A...);\n     * int end(A...);\n     * V init(A...);\n     * V body(V, int, A...);\n     * V countedLoop(A... a...) {\n     *   int e = end(a...);\n     *   int s = start(a...);\n     *   V v = init(a...);\n     *   for (int i = s; i < e; ++i) {\n     *     v = body(v, i, a...);\n     *   }\n     *   return v;\n     * }\n     * }</pre></blockquote>\n     *\n     * @apiNote The implementation of this method can be expressed as follows:\n     * <blockquote><pre>{@code\n     * MethodHandle countedLoop(MethodHandle start, MethodHandle end, MethodHandle init, MethodHandle body) {\n     *     MethodHandle returnVar = dropArguments(identity(init.type().returnType()), 0, int.class, int.class);\n     *     // assume MH_increment and MH_predicate are handles to implementation-internal methods with\n     *     // the following semantics:\n     *     // MH_increment: (int limit, int counter) -> counter + 1\n     *     // MH_predicate: (int limit, int counter) -> counter < limit\n     *     Class<?> counterType = start.type().returnType();  // int\n     *     Class<?> returnType = body.type().returnType();\n     *     MethodHandle incr = MH_increment, pred = MH_predicate, retv = null;\n     *     if (returnType != void.class) {  // ignore the V variable\n     *         incr = dropArguments(incr, 1, returnType);  // (limit, v, i) => (limit, i)\n     *         pred = dropArguments(pred, 1, returnType);  // ditto\n     *         retv = dropArguments(identity(returnType), 0, counterType); // ignore limit\n     *     }\n     *     body = dropArguments(body, 0, counterType);  // ignore the limit variable\n     *     MethodHandle[]\n     *         loopLimit  = { end, null, pred, retv }, // limit = end(); i < limit || return v\n     *         bodyClause = { init, body },            // v = init(); v = body(v, i)\n     *         indexVar   = { start, incr };           // i = start(); i = i + 1\n     *     return loop(loopLimit, bodyClause, indexVar);\n     * }\n     * }</pre></blockquote>\n     *\n     * @param start a non-{@code null} handle to return the start value of the loop counter, which must be {@code int}.\n     *              See above for other constraints.\n     * @param end a non-{@code null} handle to return the end value of the loop counter (the loop will run to\n     *            {@code end-1}). The result type must be {@code int}. See above for other constraints.\n     * @param init optional initializer, providing the initial value of the loop variable.\n     *             May be {@code null}, implying a default initial value.  See above for other constraints.\n     * @param body body of the loop, which may not be {@code null}.\n     *             It controls the loop parameters and result type in the standard case (see above for details).\n     *             It must accept its own return type (if non-void) plus an {@code int} parameter (for the counter),\n     *             and may accept any number of additional types.\n     *             See above for other constraints.\n     *\n     * @return a method handle representing the loop.\n     * @throws NullPointerException if any of the {@code start}, {@code end}, or {@code body} handles is {@code null}.\n     * @throws IllegalArgumentException if any argument violates the rules formulated above.\n     *\n     * @see #countedLoop(MethodHandle, MethodHandle, MethodHandle)\n     * @since 9\n     ",
    "links" : [ ]
  }, {
    "name" : "private static void countedLoopChecks(MethodHandle start, MethodHandle end, MethodHandle init, MethodHandle body)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public static MethodHandle iteratedLoop(MethodHandle iterator, MethodHandle init, MethodHandle body)",
    "returnType" : "MethodHandle",
    "comment" : "\n     * Constructs a loop that ranges over the values produced by an {@code Iterator<T>}.\n     * This is a convenience wrapper for the {@linkplain #loop(MethodHandle[][]) generic loop combinator}.\n     * <p>\n     * The iterator itself will be determined by the evaluation of the {@code iterator} handle.\n     * Each value it produces will be stored in a loop iteration variable of type {@code T}.\n     * <p>\n     * If the {@code body} handle returns a non-{@code void} type {@code V}, a leading loop iteration variable\n     * of that type is also present.  This variable is initialized using the optional {@code init} handle,\n     * or to the {@linkplain #empty default value} of type {@code V} if that handle is {@code null}.\n     * <p>\n     * In each iteration, the iteration variables are passed to an invocation of the {@code body} handle.\n     * A non-{@code void} value returned from the body (of type {@code V}) updates the leading\n     * iteration variable.\n     * The result of the loop handle execution will be the final {@code V} value of that variable\n     * (or {@code void} if there is no {@code V} variable).\n     * <p>\n     * The following rules hold for the argument handles:<ul>\n     * <li>The {@code body} handle must not be {@code null}; its type must be of the form\n     * {@code (V T A...)V}, where {@code V} is non-{@code void}, or else {@code (T A...)void}.\n     * (In the {@code void} case, we assign the type {@code void} to the name {@code V},\n     * and we will write {@code (V T A...)V} with the understanding that a {@code void} type {@code V}\n     * is quietly dropped from the parameter list, leaving {@code (T A...)V}.)\n     * <li>The parameter list {@code (V T A...)} of the body contributes to a list\n     * of types called the <em>internal parameter list</em>.\n     * It will constrain the parameter lists of the other loop parts.\n     * <li>As a special case, if the body contributes only {@code V} and {@code T} types,\n     * with no additional {@code A} types, then the internal parameter list is extended by\n     * the argument types {@code A...} of the {@code iterator} handle; if it is {@code null} the\n     * single type {@code Iterable} is added and constitutes the {@code A...} list.\n     * <li>If the iteration variable types {@code (V T)} are dropped from the internal parameter list, the resulting shorter\n     * list {@code (A...)} is called the <em>external parameter list</em>.\n     * <li>The body return type {@code V}, if non-{@code void}, determines the type of an\n     * additional state variable of the loop.\n     * The body must both accept a leading parameter and return a value of this type {@code V}.\n     * <li>If {@code init} is non-{@code null}, it must have return type {@code V}.\n     * Its parameter list (of some <a href=\"MethodHandles.html#astar\">form {@code (A*)}</a>) must be\n     * <a href=\"MethodHandles.html#effid\">effectively identical</a>\n     * to the external parameter list {@code (A...)}.\n     * <li>If {@code init} is {@code null}, the loop variable will be initialized to its\n     * {@linkplain #empty default value}.\n     * <li>If the {@code iterator} handle is non-{@code null}, it must have the return\n     * type {@code java.util.Iterator} or a subtype thereof.\n     * The iterator it produces when the loop is executed will be assumed\n     * to yield values which can be converted to type {@code T}.\n     * <li>The parameter list of an {@code iterator} that is non-{@code null} (of some form {@code (A*)}) must be\n     * effectively identical to the external parameter list {@code (A...)}.\n     * <li>If {@code iterator} is {@code null} it defaults to a method handle which behaves\n     * like {@link java.lang.Iterable#iterator()}.  In that case, the internal parameter list\n     * {@code (V T A...)} must have at least one {@code A} type, and the default iterator\n     * handle parameter is adjusted to accept the leading {@code A} type, as if by\n     * the {@link MethodHandle#asType asType} conversion method.\n     * The leading {@code A} type must be {@code Iterable} or a subtype thereof.\n     * This conversion step, done at loop construction time, must not throw a {@code WrongMethodTypeException}.\n     * </ul>\n     * <p>\n     * The type {@code T} may be either a primitive or reference.\n     * Since type {@code Iterator<T>} is erased in the method handle representation to the raw type {@code Iterator},\n     * the {@code iteratedLoop} combinator adjusts the leading argument type for {@code body} to {@code Object}\n     * as if by the {@link MethodHandle#asType asType} conversion method.\n     * Therefore, if an iterator of the wrong type appears as the loop is executed, runtime exceptions may occur\n     * as the result of dynamic conversions performed by {@link MethodHandle#asType(MethodType)}.\n     * <p>\n     * The resulting loop handle's result type and parameter signature are determined as follows:<ul>\n     * <li>The loop handle's result type is the result type {@code V} of the body.\n     * <li>The loop handle's parameter types are the types {@code (A...)},\n     * from the external parameter list.\n     * </ul>\n     * <p>\n     * Here is pseudocode for the resulting loop handle. In the code, {@code V}/{@code v} represent the type / value of\n     * the loop variable as well as the result type of the loop; {@code T}/{@code t}, that of the elements of the\n     * structure the loop iterates over, and {@code A...}/{@code a...} represent arguments passed to the loop.\n     * <blockquote><pre>{@code\n     * Iterator<T> iterator(A...);  // defaults to Iterable::iterator\n     * V init(A...);\n     * V body(V,T,A...);\n     * V iteratedLoop(A... a...) {\n     *   Iterator<T> it = iterator(a...);\n     *   V v = init(a...);\n     *   while (it.hasNext()) {\n     *     T t = it.next();\n     *     v = body(v, t, a...);\n     *   }\n     *   return v;\n     * }\n     * }</pre></blockquote>\n     *\n     * @apiNote Example:\n     * <blockquote><pre>{@code\n     * // get an iterator from a list\n     * static List<String> reverseStep(List<String> r, String e) {\n     *   r.add(0, e);\n     *   return r;\n     * }\n     * static List<String> newArrayList() { return new ArrayList<>(); }\n     * // assume MH_reverseStep and MH_newArrayList are handles to the above methods\n     * MethodHandle loop = MethodHandles.iteratedLoop(null, MH_newArrayList, MH_reverseStep);\n     * List<String> list = Arrays.asList(\"a\", \"b\", \"c\", \"d\", \"e\");\n     * List<String> reversedList = Arrays.asList(\"e\", \"d\", \"c\", \"b\", \"a\");\n     * assertEquals(reversedList, (List<String>) loop.invoke(list));\n     * }</pre></blockquote>\n     *\n     * @apiNote The implementation of this method can be expressed approximately as follows:\n     * <blockquote><pre>{@code\n     * MethodHandle iteratedLoop(MethodHandle iterator, MethodHandle init, MethodHandle body) {\n     *     // assume MH_next, MH_hasNext, MH_startIter are handles to methods of Iterator/Iterable\n     *     Class<?> returnType = body.type().returnType();\n     *     Class<?> ttype = body.type().parameterType(returnType == void.class ? 0 : 1);\n     *     MethodHandle nextVal = MH_next.asType(MH_next.type().changeReturnType(ttype));\n     *     MethodHandle retv = null, step = body, startIter = iterator;\n     *     if (returnType != void.class) {\n     *         // the simple thing first:  in (I V A...), drop the I to get V\n     *         retv = dropArguments(identity(returnType), 0, Iterator.class);\n     *         // body type signature (V T A...), internal loop types (I V A...)\n     *         step = swapArguments(body, 0, 1);  // swap V <-> T\n     *     }\n     *     if (startIter == null)  startIter = MH_getIter;\n     *     MethodHandle[]\n     *         iterVar    = { startIter, null, MH_hasNext, retv }, // it = iterator; while (it.hasNext())\n     *         bodyClause = { init, filterArguments(step, 0, nextVal) };  // v = body(v, t, a)\n     *     return loop(iterVar, bodyClause);\n     * }\n     * }</pre></blockquote>\n     *\n     * @param iterator an optional handle to return the iterator to start the loop.\n     *                 If non-{@code null}, the handle must return {@link java.util.Iterator} or a subtype.\n     *                 See above for other constraints.\n     * @param init optional initializer, providing the initial value of the loop variable.\n     *             May be {@code null}, implying a default initial value.  See above for other constraints.\n     * @param body body of the loop, which may not be {@code null}.\n     *             It controls the loop parameters and result type in the standard case (see above for details).\n     *             It must accept its own return type (if non-void) plus a {@code T} parameter (for the iterated values),\n     *             and may accept any number of additional types.\n     *             See above for other constraints.\n     *\n     * @return a method handle embodying the iteration loop functionality.\n     * @throws NullPointerException if the {@code body} handle is {@code null}.\n     * @throws IllegalArgumentException if any argument violates the above requirements.\n     *\n     * @since 9\n     ",
    "links" : [ "java.util.Iterator", "java.lang.invoke.MethodHandle#asType(MethodType)", "java.lang.Iterable#iterator()", "java.lang.invoke.MethodHandle#asType" ]
  }, {
    "name" : "private static Class<?> iteratedLoopChecks(MethodHandle iterator, MethodHandle init, MethodHandle body)",
    "returnType" : "Class<?>",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : " static MethodHandle swapArguments(MethodHandle mh, int i, int j)",
    "returnType" : "MethodHandle",
    "comment" : "non-public",
    "links" : [ ]
  }, {
    "name" : "public static MethodHandle tryFinally(MethodHandle target, MethodHandle cleanup)",
    "returnType" : "MethodHandle",
    "comment" : "\n     * Makes a method handle that adapts a {@code target} method handle by wrapping it in a {@code try-finally} block.\n     * Another method handle, {@code cleanup}, represents the functionality of the {@code finally} block. Any exception\n     * thrown during the execution of the {@code target} handle will be passed to the {@code cleanup} handle. The\n     * exception will be rethrown, unless {@code cleanup} handle throws an exception first.  The\n     * value returned from the {@code cleanup} handle's execution will be the result of the execution of the\n     * {@code try-finally} handle.\n     * <p>\n     * The {@code cleanup} handle will be passed one or two additional leading arguments.\n     * The first is the exception thrown during the\n     * execution of the {@code target} handle, or {@code null} if no exception was thrown.\n     * The second is the result of the execution of the {@code target} handle, or, if it throws an exception,\n     * a {@code null}, zero, or {@code false} value of the required type is supplied as a placeholder.\n     * The second argument is not present if the {@code target} handle has a {@code void} return type.\n     * (Note that, except for argument type conversions, combinators represent {@code void} values in parameter lists\n     * by omitting the corresponding paradoxical arguments, not by inserting {@code null} or zero values.)\n     * <p>\n     * The {@code target} and {@code cleanup} handles must have the same corresponding argument and return types, except\n     * that the {@code cleanup} handle may omit trailing arguments. Also, the {@code cleanup} handle must have one or\n     * two extra leading parameters:<ul>\n     * <li>a {@code Throwable}, which will carry the exception thrown by the {@code target} handle (if any); and\n     * <li>a parameter of the same type as the return type of both {@code target} and {@code cleanup}, which will carry\n     * the result from the execution of the {@code target} handle.\n     * This parameter is not present if the {@code target} returns {@code void}.\n     * </ul>\n     * <p>\n     * The pseudocode for the resulting adapter looks as follows. In the code, {@code V} represents the result type of\n     * the {@code try/finally} construct; {@code A}/{@code a}, the types and values of arguments to the resulting\n     * handle consumed by the cleanup; and {@code B}/{@code b}, those of arguments to the resulting handle discarded by\n     * the cleanup.\n     * <blockquote><pre>{@code\n     * V target(A..., B...);\n     * V cleanup(Throwable, V, A...);\n     * V adapter(A... a, B... b) {\n     *   V result = (zero value for V);\n     *   Throwable throwable = null;\n     *   try {\n     *     result = target(a..., b...);\n     *   } catch (Throwable t) {\n     *     throwable = t;\n     *     throw t;\n     *   } finally {\n     *     result = cleanup(throwable, result, a...);\n     *   }\n     *   return result;\n     * }\n     * }</pre></blockquote>\n     * <p>\n     * Note that the saved arguments ({@code a...} in the pseudocode) cannot\n     * be modified by execution of the target, and so are passed unchanged\n     * from the caller to the cleanup, if it is invoked.\n     * <p>\n     * The target and cleanup must return the same type, even if the cleanup\n     * always throws.\n     * To create such a throwing cleanup, compose the cleanup logic\n     * with {@link #throwException throwException},\n     * in order to create a method handle of the correct return type.\n     * <p>\n     * Note that {@code tryFinally} never converts exceptions into normal returns.\n     * In rare cases where exceptions must be converted in that way, first wrap\n     * the target with {@link #catchException(MethodHandle, Class, MethodHandle)}\n     * to capture an outgoing exception, and then wrap with {@code tryFinally}.\n     * <p>\n     * It is recommended that the first parameter type of {@code cleanup} be\n     * declared {@code Throwable} rather than a narrower subtype.  This ensures\n     * {@code cleanup} will always be invoked with whatever exception that\n     * {@code target} throws.  Declaring a narrower type may result in a\n     * {@code ClassCastException} being thrown by the {@code try-finally}\n     * handle if the type of the exception thrown by {@code target} is not\n     * assignable to the first parameter type of {@code cleanup}.  Note that\n     * various exception types of {@code VirtualMachineError},\n     * {@code LinkageError}, and {@code RuntimeException} can in principle be\n     * thrown by almost any kind of Java code, and a finally clause that\n     * catches (say) only {@code IOException} would mask any of the others\n     * behind a {@code ClassCastException}.\n     *\n     * @param target the handle whose execution is to be wrapped in a {@code try} block.\n     * @param cleanup the handle that is invoked in the finally block.\n     *\n     * @return a method handle embodying the {@code try-finally} block composed of the two arguments.\n     * @throws NullPointerException if any argument is null\n     * @throws IllegalArgumentException if {@code cleanup} does not accept\n     *          the required leading arguments, or if the method handle types do\n     *          not match in their return types and their\n     *          corresponding trailing parameters\n     *\n     * @see MethodHandles#catchException(MethodHandle, Class, MethodHandle)\n     * @since 9\n     ",
    "links" : [ "#throwException", "#catchException(MethodHandle" ]
  }, {
    "name" : "private static void tryFinallyChecks(MethodHandle target, MethodHandle cleanup)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public static MethodHandle tableSwitch(MethodHandle fallback, MethodHandle... targets)",
    "returnType" : "MethodHandle",
    "comment" : "\n     * Creates a table switch method handle, which can be used to switch over a set of target\n     * method handles, based on a given target index, called selector.\n     * <p>\n     * For a selector value of {@code n}, where {@code n} falls in the range {@code [0, N)},\n     * and where {@code N} is the number of target method handles, the table switch method\n     * handle will invoke the n-th target method handle from the list of target method handles.\n     * <p>\n     * For a selector value that does not fall in the range {@code [0, N)}, the table switch\n     * method handle will invoke the given fallback method handle.\n     * <p>\n     * All method handles passed to this method must have the same type, with the additional\n     * requirement that the leading parameter be of type {@code int}. The leading parameter\n     * represents the selector.\n     * <p>\n     * Any trailing parameters present in the type will appear on the returned table switch\n     * method handle as well. Any arguments assigned to these parameters will be forwarded,\n     * together with the selector value, to the selected method handle when invoking it.\n     *\n     * @apiNote Example:\n     * The cases each drop the {@code selector} value they are given, and take an additional\n     * {@code String} argument, which is concatenated (using {@link String#concat(String)})\n     * to a specific constant label string for each case:\n     * <blockquote><pre>{@code\n     * MethodHandles.Lookup lookup = MethodHandles.lookup();\n     * MethodHandle caseMh = lookup.findVirtual(String.class, \"concat\",\n     *         MethodType.methodType(String.class, String.class));\n     * caseMh = MethodHandles.dropArguments(caseMh, 0, int.class);\n     *\n     * MethodHandle caseDefault = MethodHandles.insertArguments(caseMh, 1, \"default: \");\n     * MethodHandle case0 = MethodHandles.insertArguments(caseMh, 1, \"case 0: \");\n     * MethodHandle case1 = MethodHandles.insertArguments(caseMh, 1, \"case 1: \");\n     *\n     * MethodHandle mhSwitch = MethodHandles.tableSwitch(\n     *     caseDefault,\n     *     case0,\n     *     case1\n     * );\n     *\n     * assertEquals(\"default: data\", (String) mhSwitch.invokeExact(-1, \"data\"));\n     * assertEquals(\"case 0: data\", (String) mhSwitch.invokeExact(0, \"data\"));\n     * assertEquals(\"case 1: data\", (String) mhSwitch.invokeExact(1, \"data\"));\n     * assertEquals(\"default: data\", (String) mhSwitch.invokeExact(2, \"data\"));\n     * }</pre></blockquote>\n     *\n     * @param fallback the fallback method handle that is called when the selector is not\n     *                 within the range {@code [0, N)}.\n     * @param targets array of target method handles.\n     * @return the table switch method handle.\n     * @throws NullPointerException if {@code fallback}, the {@code targets} array, or any\n     *                              any of the elements of the {@code targets} array are\n     *                              {@code null}.\n     * @throws IllegalArgumentException if the {@code targets} array is empty, if the leading\n     *                                  parameter of the fallback handle or any of the target\n     *                                  handles is not {@code int}, or if the types of\n     *                                  the fallback handle and all of target handles are\n     *                                  not the same.\n     ",
    "links" : [ "#concat(String)" ]
  }, {
    "name" : "private static MethodType tableSwitchChecks(MethodHandle defaultCase, MethodHandle[] caseActions)",
    "returnType" : "MethodType",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public static boolean countedLoopPredicate(int limit, int counter)",
    "returnType" : "boolean",
    "comment" : "\n     * This method is bound as the predicate in {@linkplain MethodHandles#countedLoop(MethodHandle, MethodHandle,\n     * MethodHandle) counting loops}.\n     *\n     * @param limit the upper bound of the parameter, statically bound at loop creation time.\n     * @param counter the counter parameter, passed in during loop execution.\n     *\n     * @return whether the counter has reached the limit.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public static int countedLoopStep(int limit, int counter)",
    "returnType" : "int",
    "comment" : "\n     * This method is bound as the step function in {@linkplain MethodHandles#countedLoop(MethodHandle, MethodHandle,\n     * MethodHandle) counting loops} to increment the counter.\n     *\n     * @param limit the upper bound of the loop counter (ignored).\n     * @param counter the loop counter.\n     *\n     * @return the loop counter incremented by 1.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public static Iterator<?> initIterator(Iterable<?> it)",
    "returnType" : "Iterator<?>",
    "comment" : "\n     * This is bound to initialize the loop-local iterator in {@linkplain MethodHandles#iteratedLoop iterating loops}.\n     *\n     * @param it the {@link Iterable} over which the loop iterates.\n     *\n     * @return an {@link Iterator} over the argument's elements.\n     * @hide\n     ",
    "links" : [ "Iterable", "java.util.Iterator" ]
  }, {
    "name" : "public static boolean iteratePredicate(Iterator<?> it)",
    "returnType" : "boolean",
    "comment" : "\n     * This method is bound as the predicate in {@linkplain MethodHandles#iteratedLoop iterating loops}.\n     *\n     * @param it the iterator to be checked.\n     *\n     * @return {@code true} iff there are more elements to iterate over.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public static Object iterateNext(Iterator<?> it)",
    "returnType" : "Object",
    "comment" : "\n     * This method is bound as the step for retrieving the current value from the iterator in {@linkplain\n     * MethodHandles#iteratedLoop iterating loops}.\n     *\n     * @param it the iterator.\n     *\n     * @return the next element from the iterator.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : " static MethodHandle getConstantHandle(int idx)",
    "returnType" : "MethodHandle",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private static synchronized MethodHandle setCachedHandle(int idx, final MethodHandle method)",
    "returnType" : "MethodHandle",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private static MethodHandle makeConstantHandle(int idx)",
    "returnType" : "MethodHandle",
    "comment" : "",
    "links" : [ ]
  } ],
  "methodNames" : [ "public static Lookup lookup()", "public static Lookup publicLookup()", "public static Lookup privateLookupIn(Class<?> targetClass, Lookup lookup) throws IllegalAccessException", "public static T reflectAs(Class<T> expected, MethodHandle target)", "private static MethodHandleImpl getMethodHandleImpl(MethodHandle target)", "public static MethodHandle arrayConstructor(Class<?> arrayClass) throws IllegalArgumentException", "public static MethodHandle arrayLength(Class<?> arrayClass) throws IllegalArgumentException", "private static void checkClassIsArray(Class<?> c)", "private static void checkTypeIsViewable(Class<?> componentType)", "public static MethodHandle arrayElementGetter(Class<?> arrayClass) throws IllegalArgumentException", "public static byte arrayElementGetter(byte[] array, int i)", "public static boolean arrayElementGetter(boolean[] array, int i)", "public static char arrayElementGetter(char[] array, int i)", "public static short arrayElementGetter(short[] array, int i)", "public static int arrayElementGetter(int[] array, int i)", "public static long arrayElementGetter(long[] array, int i)", "public static float arrayElementGetter(float[] array, int i)", "public static double arrayElementGetter(double[] array, int i)", "public static MethodHandle arrayElementSetter(Class<?> arrayClass) throws IllegalArgumentException", "public static void arrayElementSetter(byte[] array, int i, byte val)", "public static void arrayElementSetter(boolean[] array, int i, boolean val)", "public static void arrayElementSetter(char[] array, int i, char val)", "public static void arrayElementSetter(short[] array, int i, short val)", "public static void arrayElementSetter(int[] array, int i, int val)", "public static void arrayElementSetter(long[] array, int i, long val)", "public static void arrayElementSetter(float[] array, int i, float val)", "public static void arrayElementSetter(double[] array, int i, double val)", "public static VarHandle arrayElementVarHandle(Class<?> arrayClass) throws IllegalArgumentException", "public static VarHandle byteArrayViewVarHandle(Class<?> viewArrayClass, ByteOrder byteOrder) throws IllegalArgumentException", "public static VarHandle byteBufferViewVarHandle(Class<?> viewArrayClass, ByteOrder byteOrder) throws IllegalArgumentException", "public static MethodHandle spreadInvoker(MethodType type, int leadingArgCount)", "public static MethodHandle exactInvoker(MethodType type)", "public static MethodHandle invoker(MethodType type)", "private static MethodHandle methodHandleForVarHandleAccessor(VarHandle.AccessMode accessMode, MethodType type, boolean isExactInvoker)", "public static MethodHandle varHandleExactInvoker(VarHandle.AccessMode accessMode, MethodType type)", "public static MethodHandle varHandleInvoker(VarHandle.AccessMode accessMode, MethodType type)", "public static MethodHandle explicitCastArguments(MethodHandle target, MethodType newType)", "private static void explicitCastArgumentsChecks(MethodHandle target, MethodType newType)", "public static MethodHandle permuteArguments(MethodHandle target, MethodType newType, int... reorder)", "private static boolean permuteArgumentChecks(int[] reorder, MethodType newType, MethodType oldType)", "public static MethodHandle constant(Class<?> type, Object value)", "public static MethodHandle identity(Class<?> type)", "public static MethodHandle zero(Class<?> type)", "private static MethodHandle identityOrVoid(Class<?> type)", "public static MethodHandle empty(MethodType type)", "private static MethodHandle makeIdentity(Class<?> ptype)", "public static byte identity(byte val)", "public static boolean identity(boolean val)", "public static char identity(char val)", "public static short identity(short val)", "public static int identity(int val)", "public static long identity(long val)", "public static float identity(float val)", "public static double identity(double val)", "private static MethodHandle zero(Wrapper btw, Class<?> rtype)", "private static MethodHandle makeZero(Class<?> rtype)", "private static synchronized MethodHandle setCachedMethodHandle(MethodHandle[] cache, int pos, MethodHandle value)", "public static MethodHandle insertArguments(MethodHandle target, int pos, Object... values)", "private static Class<?>[] insertArgumentsChecks(MethodHandle target, int insCount, int pos) throws RuntimeException", "public static MethodHandle dropArguments(MethodHandle target, int pos, List<Class<?>> valueTypes)", "private static List<Class<?>> copyTypes(Object[] array)", "private static MethodHandle dropArguments0(MethodHandle target, int pos, List<Class<?>> valueTypes)", "private static int dropArgumentChecks(MethodType oldType, int pos, List<Class<?>> valueTypes)", "public static MethodHandle dropArguments(MethodHandle target, int pos, Class<?>... valueTypes)", "private static MethodHandle dropArgumentsToMatch(MethodHandle target, int skip, List<Class<?>> newTypes, int pos, boolean nullOnFailure)", "public static MethodHandle dropArgumentsToMatch(MethodHandle target, int skip, List<Class<?>> newTypes, int pos)", "public static MethodHandle dropReturn(MethodHandle target)", "public static MethodHandle filterArguments(MethodHandle target, int pos, MethodHandle... filters)", " static MethodHandle filterArgument(MethodHandle target, int pos, MethodHandle filter)", "private static void filterArgumentsCheckArity(MethodHandle target, int pos, MethodHandle[] filters)", "private static void filterArgumentChecks(MethodHandle target, int pos, MethodHandle filter) throws RuntimeException", "public static MethodHandle collectArguments(MethodHandle target, int pos, MethodHandle filter)", "private static MethodType collectArgumentsChecks(MethodHandle target, int pos, MethodHandle filter) throws RuntimeException", "public static MethodHandle filterReturnValue(MethodHandle target, MethodHandle filter)", "private static void filterReturnValueChecks(MethodType targetType, MethodType filterType) throws RuntimeException", "public static MethodHandle foldArguments(MethodHandle target, MethodHandle combiner)", "public static MethodHandle foldArguments(MethodHandle target, int pos, MethodHandle combiner)", "private static Class<?> foldArgumentChecks(int foldPos, MethodType targetType, MethodType combinerType)", "public static MethodHandle guardWithTest(MethodHandle test, MethodHandle target, MethodHandle fallback)", " static RuntimeException misMatchedTypes(String what, T t1, T t2)", "public static MethodHandle catchException(MethodHandle target, Class<? extends Throwable> exType, MethodHandle handler)", "public static MethodHandle throwException(Class<?> returnType, Class<? extends Throwable> exType)", "public static MethodHandle loop(MethodHandle[]... clauses)", "private static void loopChecks0(MethodHandle[][] clauses)", "private static void loopChecks1a(int i, MethodHandle in, MethodHandle st)", "private static List<Class<?>> longestParameterList(Stream<MethodHandle> mhs, int skipSize)", "private static List<Class<?>> longestParameterList(List<List<Class<?>>> lists)", "private static List<Class<?>> buildCommonSuffix(List<MethodHandle> init, List<MethodHandle> step, List<MethodHandle> pred, List<MethodHandle> fini, int cpSize)", "private static void loopChecks1b(List<MethodHandle> init, List<Class<?>> commonSuffix)", "private static void loopChecks1cd(List<MethodHandle> pred, List<MethodHandle> fini, Class<?> loopReturnType)", "private static void loopChecks2(List<MethodHandle> step, List<MethodHandle> pred, List<MethodHandle> fini, List<Class<?>> commonParameterSequence)", "private static List<MethodHandle> fillParameterTypes(List<MethodHandle> hs, final List<Class<?>> targetParams)", "private static List<MethodHandle> fixArities(List<MethodHandle> hs)", "public static MethodHandle whileLoop(MethodHandle init, MethodHandle pred, MethodHandle body)", "public static MethodHandle doWhileLoop(MethodHandle init, MethodHandle body, MethodHandle pred)", "private static void whileLoopChecks(MethodHandle init, MethodHandle pred, MethodHandle body)", "public static MethodHandle countedLoop(MethodHandle iterations, MethodHandle init, MethodHandle body)", "public static MethodHandle countedLoop(MethodHandle start, MethodHandle end, MethodHandle init, MethodHandle body)", "private static void countedLoopChecks(MethodHandle start, MethodHandle end, MethodHandle init, MethodHandle body)", "public static MethodHandle iteratedLoop(MethodHandle iterator, MethodHandle init, MethodHandle body)", "private static Class<?> iteratedLoopChecks(MethodHandle iterator, MethodHandle init, MethodHandle body)", " static MethodHandle swapArguments(MethodHandle mh, int i, int j)", "public static MethodHandle tryFinally(MethodHandle target, MethodHandle cleanup)", "private static void tryFinallyChecks(MethodHandle target, MethodHandle cleanup)", "public static MethodHandle tableSwitch(MethodHandle fallback, MethodHandle... targets)", "private static MethodType tableSwitchChecks(MethodHandle defaultCase, MethodHandle[] caseActions)", "public static boolean countedLoopPredicate(int limit, int counter)", "public static int countedLoopStep(int limit, int counter)", "public static Iterator<?> initIterator(Iterable<?> it)", "public static boolean iteratePredicate(Iterator<?> it)", "public static Object iterateNext(Iterator<?> it)", " static MethodHandle getConstantHandle(int idx)", "private static synchronized MethodHandle setCachedHandle(int idx, final MethodHandle method)", "private static MethodHandle makeConstantHandle(int idx)" ],
  "variableNames" : [ "IDENTITY_MHS", "ZERO_MHS", "MH_cast", "MH_selectAlternative", "MH_copyAsPrimitiveArray", "MH_fillNewTypedArray", "MH_fillNewArray", "MH_arrayIdentity", "MH_countedLoopPred", "MH_countedLoopStep", "MH_initIterator", "MH_iteratePred", "MH_iterateNext", "MH_Array_newInstance", "MH_LIMIT", "HANDLES" ]
}