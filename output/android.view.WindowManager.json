{
  "filePath" : "/home/maryam/clearblue/files/android-source-35/android/view/WindowManager.java",
  "packageName" : "android.view",
  "className" : "WindowManager",
  "comment" : "\n * The interface that apps use to talk to the window manager.\n * <p>\n * Each window manager instance is bound to a {@link Display}. To obtain the\n * <code>WindowManager</code> associated with a display,\n * call {@link Context#createWindowContext(Display, int, Bundle)} to get the display's UI context,\n * then call {@link Context#getSystemService(String)} or {@link Context#getSystemService(Class)} on\n * the UI context.\n * <p>\n * The simplest way to show a window on a particular display is to create a {@link Presentation},\n * which automatically obtains a <code>WindowManager</code> and context for the display.\n ",
  "links" : [ "android.app.Presentation", "android.view.Display", "android.content.Context#getSystemService(String)", "android.content.Context#createWindowContext(Display", "android.content.Context#getSystemService(Class)" ],
  "variables" : [ {
    "name" : "DOCKED_INVALID",
    "type" : "int",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "DOCKED_LEFT",
    "type" : "int",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "DOCKED_TOP",
    "type" : "int",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "DOCKED_RIGHT",
    "type" : "int",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "DOCKED_BOTTOM",
    "type" : "int",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "INPUT_CONSUMER_PIP",
    "type" : "String",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "INPUT_CONSUMER_NAVIGATION",
    "type" : "String",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "INPUT_CONSUMER_WALLPAPER",
    "type" : "String",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "INPUT_CONSUMER_RECENTS_ANIMATION",
    "type" : "String",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "SHELL_ROOT_LAYER_DIVIDER",
    "type" : "int",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "SHELL_ROOT_LAYER_PIP",
    "type" : "int",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "TRANSIT_OLD_UNSET",
    "type" : "int",
    "comment" : "\n     * Not set up for a transition.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "TRANSIT_OLD_NONE",
    "type" : "int",
    "comment" : "\n     * No animation for transition.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "TRANSIT_OLD_ACTIVITY_OPEN",
    "type" : "int",
    "comment" : "\n     * A window in a new activity is being opened on top of an existing one in the same task.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "TRANSIT_OLD_ACTIVITY_CLOSE",
    "type" : "int",
    "comment" : "\n     * The window in the top-most activity is being closed to reveal the previous activity in the\n     * same task.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "TRANSIT_OLD_TASK_OPEN",
    "type" : "int",
    "comment" : "\n     * A window in a new task is being opened on top of an existing one in another activity's task.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "TRANSIT_OLD_TASK_CLOSE",
    "type" : "int",
    "comment" : "\n     * A window in the top-most activity is being closed to reveal the previous activity in a\n     * different task.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "TRANSIT_OLD_TASK_TO_FRONT",
    "type" : "int",
    "comment" : "\n     * A window in an existing task is being displayed on top of an existing one in another\n     * activity's task.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "TRANSIT_OLD_TASK_TO_BACK",
    "type" : "int",
    "comment" : "\n     * A window in an existing task is being put below all other tasks.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "TRANSIT_OLD_WALLPAPER_CLOSE",
    "type" : "int",
    "comment" : "\n     * A window in a new activity that doesn't have a wallpaper is being opened on top of one that\n     * does, effectively closing the wallpaper.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "TRANSIT_OLD_WALLPAPER_OPEN",
    "type" : "int",
    "comment" : "\n     * A window in a new activity that does have a wallpaper is being opened on one that didn't,\n     * effectively opening the wallpaper.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "TRANSIT_OLD_WALLPAPER_INTRA_OPEN",
    "type" : "int",
    "comment" : "\n     * A window in a new activity is being opened on top of an existing one, and both are on top\n     * of the wallpaper.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "TRANSIT_OLD_WALLPAPER_INTRA_CLOSE",
    "type" : "int",
    "comment" : "\n     * The window in the top-most activity is being closed to reveal the previous activity, and\n     * both are on top of the wallpaper.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "TRANSIT_OLD_TASK_OPEN_BEHIND",
    "type" : "int",
    "comment" : "\n     * A window in a new task is being opened behind an existing one in another activity's task.\n     * The new window will show briefly and then be gone.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "TRANSIT_OLD_ACTIVITY_RELAUNCH",
    "type" : "int",
    "comment" : "\n     * An activity is being relaunched (e.g. due to configuration change).\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "TRANSIT_OLD_KEYGUARD_GOING_AWAY",
    "type" : "int",
    "comment" : "\n     * Keyguard is going away.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "TRANSIT_OLD_KEYGUARD_GOING_AWAY_ON_WALLPAPER",
    "type" : "int",
    "comment" : "\n     * Keyguard is going away with showing an activity behind that requests wallpaper.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "TRANSIT_OLD_KEYGUARD_OCCLUDE",
    "type" : "int",
    "comment" : "\n     * Keyguard is being occluded by non-Dream.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "TRANSIT_OLD_KEYGUARD_OCCLUDE_BY_DREAM",
    "type" : "int",
    "comment" : "\n     * Keyguard is being occluded by Dream.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "TRANSIT_OLD_KEYGUARD_UNOCCLUDE",
    "type" : "int",
    "comment" : "\n     * Keyguard is being unoccluded.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "TRANSIT_OLD_TRANSLUCENT_ACTIVITY_OPEN",
    "type" : "int",
    "comment" : "\n     * A translucent activity is being opened.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "TRANSIT_OLD_TRANSLUCENT_ACTIVITY_CLOSE",
    "type" : "int",
    "comment" : "\n     * A translucent activity is being closed.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "TRANSIT_OLD_CRASHING_ACTIVITY_CLOSE",
    "type" : "int",
    "comment" : "\n     * A crashing activity is being closed.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "TRANSIT_OLD_TASK_CHANGE_WINDOWING_MODE",
    "type" : "int",
    "comment" : "\n     * A task is changing windowing modes\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "TRANSIT_OLD_TASK_FRAGMENT_OPEN",
    "type" : "int",
    "comment" : "\n     * A window in a new task fragment is being opened.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "TRANSIT_OLD_TASK_FRAGMENT_CLOSE",
    "type" : "int",
    "comment" : "\n     * A window in the top-most activity of task fragment is being closed to reveal the activity\n     * below.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "TRANSIT_OLD_TASK_FRAGMENT_CHANGE",
    "type" : "int",
    "comment" : "\n     * A window of task fragment is changing bounds.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "TRANSIT_OLD_DREAM_ACTIVITY_OPEN",
    "type" : "int",
    "comment" : "\n     * A dream activity is being opened.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "TRANSIT_OLD_DREAM_ACTIVITY_CLOSE",
    "type" : "int",
    "comment" : "\n     * A dream activity is being closed.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "TRANSIT_NONE",
    "type" : "int",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "TRANSIT_OPEN",
    "type" : "int",
    "comment" : "\n     * A window that didn't exist before has been created and made visible.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "TRANSIT_CLOSE",
    "type" : "int",
    "comment" : "\n     * A window that was visible no-longer exists (was finished or destroyed).\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "TRANSIT_TO_FRONT",
    "type" : "int",
    "comment" : "\n     * A window that already existed but was not visible is made visible.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "TRANSIT_TO_BACK",
    "type" : "int",
    "comment" : "\n     * A window that was visible is made invisible but still exists.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "TRANSIT_RELAUNCH",
    "type" : "int",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "TRANSIT_CHANGE",
    "type" : "int",
    "comment" : "\n     * A window is visible before and after but changes in some way (eg. it resizes or changes\n     * windowing-mode).\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "TRANSIT_KEYGUARD_GOING_AWAY",
    "type" : "int",
    "comment" : "\n     * The keyguard was visible and has been dismissed.\n     * @deprecated use {@link #TRANSIT_TO_BACK} + {@link #TRANSIT_FLAG_KEYGUARD_GOING_AWAY} for\n     *             keyguard going away with Shell transition.\n     * @hide\n     ",
    "links" : [ "#TRANSIT_TO_BACK", "#TRANSIT_FLAG_KEYGUARD_GOING_AWAY" ]
  }, {
    "name" : "TRANSIT_KEYGUARD_OCCLUDE",
    "type" : "int",
    "comment" : "\n     * A window is appearing above a locked keyguard.\n     * @deprecated use {@link #TRANSIT_TO_FRONT} + {@link #TRANSIT_FLAG_KEYGUARD_OCCLUDING} for\n     *             keyguard occluding with Shell transition.\n     * @hide\n     ",
    "links" : [ "#TRANSIT_TO_FRONT", "#TRANSIT_FLAG_KEYGUARD_OCCLUDING" ]
  }, {
    "name" : "TRANSIT_KEYGUARD_UNOCCLUDE",
    "type" : "int",
    "comment" : "\n     * A window is made invisible revealing a locked keyguard.\n     * @deprecated use {@link #TRANSIT_TO_BACK} + {@link #TRANSIT_FLAG_KEYGUARD_UNOCCLUDING} for\n     *             keyguard occluding with Shell transition.\n     * @hide\n     ",
    "links" : [ "#TRANSIT_TO_BACK", "#TRANSIT_FLAG_KEYGUARD_UNOCCLUDING" ]
  }, {
    "name" : "TRANSIT_PIP",
    "type" : "int",
    "comment" : "\n     * A window is starting to enter PiP.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "TRANSIT_WAKE",
    "type" : "int",
    "comment" : "\n     * The screen is turning on.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "TRANSIT_SLEEP",
    "type" : "int",
    "comment" : "\n     * The screen is turning off. This is used as a message to stop all animations.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "TRANSIT_FIRST_CUSTOM",
    "type" : "int",
    "comment" : "\n     * The first slot for custom transition types. Callers (like Shell) can make use of custom\n     * transition types for dealing with special cases. These types are effectively ignored by\n     * Core and will just be passed along as part of TransitionInfo objects. An example is\n     * split-screen using a custom type for it's snap-to-dismiss action. By using a custom type,\n     * Shell can properly dispatch the results of that transition to the split-screen\n     * implementation.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "TRANSIT_FLAG_KEYGUARD_GOING_AWAY_TO_SHADE",
    "type" : "int",
    "comment" : " 0x1",
    "links" : [ ]
  }, {
    "name" : "TRANSIT_FLAG_KEYGUARD_GOING_AWAY_NO_ANIMATION",
    "type" : "int",
    "comment" : " 0x2",
    "links" : [ ]
  }, {
    "name" : "TRANSIT_FLAG_KEYGUARD_GOING_AWAY_WITH_WALLPAPER",
    "type" : "int",
    "comment" : " 0x4",
    "links" : [ ]
  }, {
    "name" : "TRANSIT_FLAG_KEYGUARD_GOING_AWAY_SUBTLE_ANIMATION",
    "type" : "int",
    "comment" : " 0x8",
    "links" : [ ]
  }, {
    "name" : "TRANSIT_FLAG_APP_CRASHED",
    "type" : "int",
    "comment" : " 0x10",
    "links" : [ ]
  }, {
    "name" : "TRANSIT_FLAG_OPEN_BEHIND",
    "type" : "int",
    "comment" : " 0x20",
    "links" : [ ]
  }, {
    "name" : "TRANSIT_FLAG_KEYGUARD_LOCKED",
    "type" : "int",
    "comment" : " 0x40",
    "links" : [ ]
  }, {
    "name" : "TRANSIT_FLAG_IS_RECENTS",
    "type" : "int",
    "comment" : " 0x80",
    "links" : [ ]
  }, {
    "name" : "TRANSIT_FLAG_KEYGUARD_GOING_AWAY",
    "type" : "int",
    "comment" : " 0x100",
    "links" : [ ]
  }, {
    "name" : "TRANSIT_FLAG_KEYGUARD_GOING_AWAY_TO_LAUNCHER_CLEAR_SNAPSHOT",
    "type" : "int",
    "comment" : " 0x200",
    "links" : [ ]
  }, {
    "name" : "TRANSIT_FLAG_INVISIBLE",
    "type" : "int",
    "comment" : " 0x400",
    "links" : [ ]
  }, {
    "name" : "TRANSIT_FLAG_KEYGUARD_APPEARING",
    "type" : "int",
    "comment" : " 0x800",
    "links" : [ ]
  }, {
    "name" : "TRANSIT_FLAG_KEYGUARD_OCCLUDING",
    "type" : "int",
    "comment" : " 0x1000",
    "links" : [ ]
  }, {
    "name" : "TRANSIT_FLAG_KEYGUARD_UNOCCLUDING",
    "type" : "int",
    "comment" : " 0x2000",
    "links" : [ ]
  }, {
    "name" : "TRANSIT_FLAG_PHYSICAL_DISPLAY_SWITCH",
    "type" : "int",
    "comment" : " 0x4000",
    "links" : [ ]
  }, {
    "name" : "KEYGUARD_VISIBILITY_TRANSIT_FLAGS",
    "type" : "int",
    "comment" : "\n     * Transit flags used to signal keyguard visibility is changing for animations.\n     *\n     * <p>These roughly correspond to CLOSE, OPEN, TO_BACK, and TO_FRONT on a hypothetical Keyguard\n     * container. Since Keyguard isn't a container we can't include it in changes and need to send\n     * this information in its own channel.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "REMOVE_CONTENT_MODE_UNDEFINED",
    "type" : "int",
    "comment" : "\n     * Remove content mode: Indicates remove content mode is currently not defined.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "REMOVE_CONTENT_MODE_MOVE_TO_PRIMARY",
    "type" : "int",
    "comment" : "\n     * Remove content mode: Indicates that when display is removed, all its activities will be moved\n     * to the primary display and the topmost activity should become focused.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "REMOVE_CONTENT_MODE_DESTROY",
    "type" : "int",
    "comment" : "\n     * Remove content mode: Indicates that when display is removed, all its stacks and tasks will be\n     * removed, all activities will be destroyed according to the usual lifecycle.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "DISPLAY_IME_POLICY_LOCAL",
    "type" : "int",
    "comment" : "\n     * Display IME Policy: The IME should appear on the local display.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "DISPLAY_IME_POLICY_FALLBACK_DISPLAY",
    "type" : "int",
    "comment" : "\n     * Display IME Policy: The IME should appear on a fallback display.\n     *\n     * <p>The fallback display is always {@link Display#DEFAULT_DISPLAY}.</p>\n     *\n     * @hide\n     ",
    "links" : [ "android.view.Display#DEFAULT_DISPLAY" ]
  }, {
    "name" : "DISPLAY_IME_POLICY_HIDE",
    "type" : "int",
    "comment" : "\n     * Display IME Policy: The IME should be hidden.\n     *\n     * <p>Setting this policy will prevent the IME from making a connection. This\n     * will prevent any IME from receiving metadata about input and this display will effectively\n     * have no IME.</p>\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "TAKE_SCREENSHOT_FULLSCREEN",
    "type" : "int",
    "comment" : "\n     * Invoke screenshot flow to capture a full-screen image.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "TAKE_SCREENSHOT_PROVIDED_IMAGE",
    "type" : "int",
    "comment" : "\n     * Invoke screenshot flow with an image provided by the caller.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "LARGE_SCREEN_SMALLEST_SCREEN_WIDTH_DP",
    "type" : "int",
    "comment" : "\n     * If the display {@link Configuration#smallestScreenWidthDp} is greater or equal to this value,\n     * we will treat it as a large screen device, which will have some multi window features enabled\n     * by default.\n     * @hide\n     ",
    "links" : [ "android.content.res.Configuration#smallestScreenWidthDp" ]
  }, {
    "name" : "PROPERTY_COMPAT_IGNORE_REQUESTED_ORIENTATION",
    "type" : "String",
    "comment" : "\n     * Application level {@link android.content.pm.PackageManager.Property PackageManager.Property}\n     * for an app to inform the system that the app can be opted-in or opted-out from the\n     * compatibility treatment that avoids {@link android.app.Activity#setRequestedOrientation\n     * Activity#setRequestedOrientation()} loops. Loops can be triggered by the OEM-configured\n     * ignore requested orientation display setting (on Android 12 (API level 31) and higher) or by\n     * the landscape natural orientation of the device.\n     *\n     * <p>The treatment is disabled by default but device manufacturers can enable the treatment\n     * using their discretion to improve display compatibility.\n     *\n     * <p>With this property set to {@code true}, the system could ignore\n     * {@link android.app.Activity#setRequestedOrientation Activity#setRequestedOrientation()} call\n     * from an app if one of the following conditions are true:\n     * <ul>\n     *     <li>Activity is relaunching due to the previous\n     *     {@link android.app.Activity#setRequestedOrientation Activity#setRequestedOrientation()}\n     *     call.\n     *     <li>Camera compatibility force rotation treatment is active for the package.\n     * </ul>\n     *\n     * <p>Setting this property to {@code false} informs the system that the app must be\n     * opted-out from the compatibility treatment even if the device manufacturer has opted the app\n     * into the treatment.\n     *\n     * <p><b>Syntax:</b>\n     * <pre>\n     * &lt;application&gt;\n     *   &lt;property\n     *     android:name=\"android.window.PROPERTY_COMPAT_IGNORE_REQUESTED_ORIENTATION\"\n     *     android:value=\"true|false\"/&gt;\n     * &lt;/application&gt;\n     * </pre>\n     ",
    "links" : [ "android.app.Activity#setRequestedOrientationActivity", "android.content.pm.PackageManager.Property", "android.app.Activity#setRequestedOrientation" ]
  }, {
    "name" : "PROPERTY_COMPAT_ALLOW_IGNORING_ORIENTATION_REQUEST_WHEN_LOOP_DETECTED",
    "type" : "String",
    "comment" : "\n     * Application level {@link android.content.pm.PackageManager.Property PackageManager.Property}\n     * for an app to inform the system that the app can be opted-out from the compatibility\n     * treatment that avoids {@link android.app.Activity#setRequestedOrientation\n     * Activity#setRequestedOrientation()} loops. Loops can be triggered by the OEM-configured\n     * ignore requested orientation display setting (on Android 12 (API level 31) and higher) or by\n     * the landscape natural orientation of the device.\n     *\n     * <p>The system could ignore {@link android.app.Activity#setRequestedOrientation\n     * Activity#setRequestedOrientation()} call from an app if both of the following conditions are\n     * true:\n     * <ul>\n     *     <li>Activity has requested orientation more than two times within one-second timer\n     *     <li>Activity is not letterboxed for fixed orientation\n     * </ul>\n     *\n     * <p>Setting this property to {@code false} informs the system that the app must be\n     * opted-out from the compatibility treatment even if the device manufacturer has opted the app\n     * into the treatment.\n     *\n     * <p>Not setting this property at all, or setting this property to {@code true} has no effect.\n     *\n     * <p><b>Syntax:</b>\n     * <pre>\n     * &lt;application&gt;\n     *   &lt;property\n     *     android:name=\n     *       \"android.window.PROPERTY_COMPAT_ALLOW_IGNORING_ORIENTATION_REQUEST_WHEN_LOOP_DETECTED\"\n     *     android:value=\"false\"/&gt;\n     * &lt;/application&gt;\n     * </pre>\n     ",
    "links" : [ "android.app.Activity#setRequestedOrientationActivity", "android.content.pm.PackageManager.Property" ]
  }, {
    "name" : "PROPERTY_COMPAT_ALLOW_SANDBOXING_VIEW_BOUNDS_APIS",
    "type" : "String",
    "comment" : "\n     * Application level {@link android.content.pm.PackageManager.Property PackageManager.Property}\n     * for an app to inform the system that it needs to be opted-out from the compatibility\n     * treatment that sandboxes the {@link android.view.View View} API.\n     *\n     * <p>The treatment can be enabled by device manufacturers for applications which misuse\n     * {@link android.view.View View} APIs by expecting that\n     * {@link android.view.View#getLocationOnScreen View#getLocationOnScreen()} and\n     * {@link android.view.View#getWindowVisibleDisplayFrame View#getWindowVisibleDisplayFrame()}\n     * return coordinates as if an activity is positioned in the top-left corner of the screen, with\n     * left coordinate equal to 0. This may not be the case for applications in multi-window and\n     * letterbox modes.\n     *\n     * <p>Setting this property to {@code false} informs the system that the application must be\n     * opted-out from the \"Sandbox View API to Activity bounds\" treatment even if the device\n     * manufacturer has opted the app into the treatment.\n     *\n     * <p>Not setting this property at all, or setting this property to {@code true} has no effect.\n     *\n     * <p><b>Syntax:</b>\n     * <pre>\n     * &lt;application&gt;\n     *   &lt;property\n     *     android:name=\"android.window.PROPERTY_COMPAT_ALLOW_SANDBOXING_VIEW_BOUNDS_APIS\"\n     *     android:value=\"false\"/&gt;\n     * &lt;/application&gt;\n     * </pre>\n     ",
    "links" : [ "android.view.View#getWindowVisibleDisplayFrame", "android.content.pm.PackageManager.Property", "android.view.View#getLocationOnScreen", "android.view.View" ]
  }, {
    "name" : "PROPERTY_COMPAT_ENABLE_FAKE_FOCUS",
    "type" : "String",
    "comment" : "\n     * Application level {@link android.content.pm.PackageManager.Property PackageManager.Property}\n     * for an app to inform the system that the application can be opted-in or opted-out from the\n     * compatibility treatment that enables sending a fake focus event for unfocused resumed\n     * split-screen activities. This is needed because some game engines wait to get focus before\n     * drawing the content of the app which isn't guaranteed by default in multi-window mode.\n     *\n     * <p>Device manufacturers can enable this treatment using their discretion on a per-device\n     * basis to improve display compatibility. The treatment also needs to be specifically enabled\n     * on a per-app basis afterwards. This can either be done by device manufacturers or developers.\n     *\n     * <p>With this property set to {@code true}, the system will apply the treatment only if the\n     * device manufacturer had previously enabled it on the device. A fake focus event will be sent\n     * to the app after it is resumed only if the app is in split-screen.\n     *\n     * <p>Setting this property to {@code false} informs the system that the activity must be\n     * opted-out from the compatibility treatment even if the device manufacturer has opted the app\n     * into the treatment.\n     *\n     * <p>If the property remains unset the system will apply the treatment only if it had\n     * previously been enabled both at the device and app level by the device manufacturer.\n     *\n     * <p><b>Syntax:</b>\n     * <pre>\n     * &lt;application&gt;\n     *   &lt;property\n     *     android:name=\"android.window.PROPERTY_COMPAT_ENABLE_FAKE_FOCUS\"\n     *     android:value=\"true|false\"/&gt;\n     * &lt;/application&gt;\n     * </pre>\n     ",
    "links" : [ "android.content.pm.PackageManager.Property" ]
  }, {
    "name" : "PROPERTY_CAMERA_COMPAT_ALLOW_FORCE_ROTATION",
    "type" : "String",
    "comment" : "\n     * Application level {@link android.content.pm.PackageManager.Property PackageManager.Property}\n     * for an app to inform the system that the app should be excluded from the camera compatibility\n     * force rotation treatment.\n     *\n     * <p>The camera compatibility treatment aligns orientations of portrait app window and natural\n     * orientation of the device and set opposite to natural orientation for a landscape app\n     * window. Mismatch between them can lead to camera issues like sideways or stretched\n     * viewfinder since this is one of the strongest assumptions that apps make when they implement\n     * camera previews. Since app and natural display orientations aren't guaranteed to match, the\n     * rotation can cause letterboxing. The forced rotation is triggered as soon as app opens to\n     * camera and is removed once camera is closed.\n     *\n     * <p>The camera compatibility can be enabled by device manufacturers on displays that have the\n     * ignore requested orientation display setting enabled (enables compatibility mode for fixed\n     * orientation on Android 12 (API level 31) or higher; see\n     * <a href=\"https://developer.android.com/guide/practices/enhanced-letterboxing\">Enhanced\n     * letterboxing</a> for more details).\n     *\n     * <p>With this property set to {@code true} or unset, the system may apply the force rotation\n     * treatment to fixed orientation activities. Device manufacturers can exclude packages from the\n     * treatment using their discretion to improve display compatibility.\n     *\n     * <p>With this property set to {@code false}, the system will not apply the force rotation\n     * treatment.\n     *\n     * <p><b>Syntax:</b>\n     * <pre>\n     * &lt;application&gt;\n     *   &lt;property\n     *     android:name=\"android.window.PROPERTY_CAMERA_COMPAT_ALLOW_FORCE_ROTATION\"\n     *     android:value=\"true|false\"/&gt;\n     * &lt;/application&gt;\n     * </pre>\n     ",
    "links" : [ "android.content.pm.PackageManager.Property" ]
  }, {
    "name" : "PROPERTY_CAMERA_COMPAT_ALLOW_REFRESH",
    "type" : "String",
    "comment" : "\n     * Application level {@link android.content.pm.PackageManager.Property PackageManager.Property}\n     * for an app to inform the system that the app should be excluded from the activity \"refresh\"\n     * after the camera compatibility force rotation treatment.\n     *\n     * <p>The camera compatibility treatment aligns orientations of portrait app window and natural\n     * orientation of the device and set opposite to natural orientation for a landscape app\n     * window. Mismatch between them can lead to camera issues like sideways or stretched\n     * viewfinder since this is one of the strongest assumptions that apps make when they implement\n     * camera previews. Since app and natural display orientations aren't guaranteed to match, the\n     * rotation can cause letterboxing. The forced rotation is triggered as soon as app opens to\n     * camera and is removed once camera is closed.\n     *\n     * <p>Force rotation is followed by the \"Refresh\" of the activity by going through \"resumed ->\n     * ... -> stopped -> ... -> resumed\" cycle (by default) or \"resumed -> paused -> resumed\" cycle\n     * (if overridden, see {@link #PROPERTY_CAMERA_COMPAT_ENABLE_REFRESH_VIA_PAUSE} for context).\n     * This allows to clear cached values in apps (e.g. display or camera rotation) that influence\n     * camera preview and can lead to sideways or stretching issues persisting even after force\n     * rotation.\n     *\n     * <p>The camera compatibility can be enabled by device manufacturers on displays that have the\n     * ignore requested orientation display setting enabled (enables compatibility mode for fixed\n     * orientation on Android 12 (API level 31) or higher; see\n     * <a href=\"https://developer.android.com/guide/practices/enhanced-letterboxing\">Enhanced\n     * letterboxing</a> for more details).\n     *\n     * <p>With this property set to {@code true} or unset, the system may \"refresh\" activity after\n     * the force rotation treatment. Device manufacturers can exclude packages from the \"refresh\"\n     * using their discretion to improve display compatibility.\n     *\n     * <p>With this property set to {@code false}, the system will not \"refresh\" activity after the\n     * force rotation treatment.\n     *\n     * <p><b>Syntax:</b>\n     * <pre>\n     * &lt;application&gt;\n     *   &lt;property\n     *     android:name=\"android.window.PROPERTY_CAMERA_COMPAT_ALLOW_REFRESH\"\n     *     android:value=\"true|false\"/&gt;\n     * &lt;/application&gt;\n     * </pre>\n     ",
    "links" : [ "android.content.pm.PackageManager.Property", "#PROPERTY_CAMERA_COMPAT_ENABLE_REFRESH_VIA_PAUSE" ]
  }, {
    "name" : "PROPERTY_CAMERA_COMPAT_ENABLE_REFRESH_VIA_PAUSE",
    "type" : "String",
    "comment" : "\n     * Application level {@link android.content.pm.PackageManager.Property PackageManager.Property}\n     * for an app to inform the system that the activity should be or shouldn't be \"refreshed\" after\n     * the camera compatibility force rotation treatment using \"paused -> resumed\" cycle rather than\n     * \"stopped -> resumed\".\n     *\n     * <p>The camera compatibility treatment aligns orientations of portrait app window and natural\n     * orientation of the device and set opposite to natural orientation for a landscape app\n     * window. Mismatch between them can lead to camera issues like sideways or stretched\n     * viewfinder since this is one of the strongest assumptions that apps make when they implement\n     * camera previews. Since app and natural display orientations aren't guaranteed to match, the\n     * rotation can cause letterboxing. The forced rotation is triggered as soon as app opens to\n     * camera and is removed once camera is closed.\n     *\n     * <p>Force rotation is followed by the \"Refresh\" of the activity by going through \"resumed ->\n     * ... -> stopped -> ... -> resumed\" cycle (by default) or \"resumed -> paused -> resumed\" cycle\n     * (if overridden by device manufacturers or using this property). This allows to clear cached\n     * values in apps (e.g., display or camera rotation) that influence camera preview and can lead\n     * to sideways or stretching issues persisting even after force rotation.\n     *\n     * <p>The camera compatibility can be enabled by device manufacturers on displays that have the\n     * ignore requested orientation display setting enabled (enables compatibility mode for fixed\n     * orientation on Android 12 (API level 31) or higher; see\n     * <a href=\"https://developer.android.com/guide/practices/enhanced-letterboxing\">Enhanced\n     * letterboxing</a> for more details).\n     *\n     * <p>Device manufacturers can override packages to \"refresh\" via \"resumed -> paused -> resumed\"\n     * cycle using their discretion to improve display compatibility.\n     *\n     * <p>With this property set to {@code true}, the system will \"refresh\" activity after the\n     * force rotation treatment using \"resumed -> paused -> resumed\" cycle.\n     *\n     * <p>With this property set to {@code false}, the system will not \"refresh\" activity after the\n     * force rotation treatment using \"resumed -> paused -> resumed\" cycle even if the device\n     * manufacturer adds the corresponding override.\n     *\n     * <p><b>Syntax:</b>\n     * <pre>\n     * &lt;application&gt;\n     *   &lt;property\n     *     android:name=\"android.window.PROPERTY_CAMERA_COMPAT_ENABLE_REFRESH_VIA_PAUSE\"\n     *     android:value=\"true|false\"/&gt;\n     * &lt;/application&gt;\n     * </pre>\n     ",
    "links" : [ "android.content.pm.PackageManager.Property" ]
  }, {
    "name" : "PROPERTY_COMPAT_ALLOW_ORIENTATION_OVERRIDE",
    "type" : "String",
    "comment" : "\n     * Application level {@link android.content.pm.PackageManager.Property PackageManager.Property}\n     * for an app to inform the system that the app should be excluded from the compatibility\n     * override for orientation set by the device manufacturer. When the orientation override is\n     * applied it can:\n     * <ul>\n     *   <li>Replace the specific orientation requested by the app with another selected by the\n             device manufacturer; for example, replace undefined requested by the app with portrait.\n     *   <li>Always use an orientation selected by the device manufacturer.\n     *   <li>Do one of the above but only when camera connection is open.\n     * </ul>\n     *\n     * <p>This property is different from {@link #PROPERTY_COMPAT_IGNORE_REQUESTED_ORIENTATION}\n     * (which is used to avoid orientation loops caused by the incorrect use of {@link\n     * android.app.Activity#setRequestedOrientation Activity#setRequestedOrientation()}) because\n     * this property overrides the app to an orientation selected by the device manufacturer rather\n     * than ignoring one of orientation requests coming from the app while respecting the previous\n     * one.\n     *\n     * <p>With this property set to {@code true} or unset, device manufacturers can override\n     * orientation for the app using their discretion to improve display compatibility.\n     *\n     * <p>With this property set to {@code false}, device manufactured per-app override for\n     * orientation won't be applied.\n     *\n     * <p><b>Syntax:</b>\n     * <pre>\n     * &lt;application&gt;\n     *   &lt;property\n     *     android:name=\"android.window.PROPERTY_COMPAT_ALLOW_ORIENTATION_OVERRIDE\"\n     *     android:value=\"true|false\"/&gt;\n     * &lt;/application&gt;\n     * </pre>\n     ",
    "links" : [ "android.content.pm.PackageManager.Property", "#PROPERTY_COMPAT_IGNORE_REQUESTED_ORIENTATION", "android.app.Activity#setRequestedOrientation" ]
  }, {
    "name" : "PROPERTY_COMPAT_ALLOW_DISPLAY_ORIENTATION_OVERRIDE",
    "type" : "String",
    "comment" : "\n     * Application level {@link android.content.pm.PackageManager.Property PackageManager.Property}\n     * for an app to inform the system that the app should be opted-out from the compatibility\n     * override that fixes display orientation to landscape natural orientation when an activity is\n     * fullscreen.\n     *\n     * <p>When this compat override is enabled and while display is fixed to the landscape natural\n     * orientation, the orientation requested by the activity will be still respected by bounds\n     * resolution logic. For instance, if an activity requests portrait orientation, then activity\n     * will appear in the letterbox mode for fixed orientation with the display rotated to the\n     * lanscape natural orientation.\n     *\n     * <p>The treatment is disabled by default but device manufacturers can enable the treatment\n     * using their discretion to improve display compatibility on displays that have the ignore\n     * orientation request display setting enabled by OEMs on the device (enables compatibility mode\n     * for fixed orientation on Android 12 (API level 31) or higher; see\n     * <a href=\"https://developer.android.com/guide/practices/enhanced-letterboxing\">Enhanced\n     * letterboxing</a> for more details).\n     *\n     * <p>With this property set to {@code true} or unset, the system wiil use landscape display\n     * orientation when the following conditions are met:\n     * <ul>\n     *     <li>Natural orientation of the display is landscape\n     *     <li>ignore requested orientation display setting is enabled\n     *     <li>Activity is fullscreen.\n     *     <li>Device manufacturer enabled the treatment.\n     * </ul>\n     *\n     * <p>With this property set to {@code false}, device manufactured per-app override for\n     * display orientation won't be applied.\n     *\n     * <p><b>Syntax:</b>\n     * <pre>\n     * &lt;application&gt;\n     *   &lt;property\n     *     android:name=\"android.window.PROPERTY_COMPAT_ALLOW_DISPLAY_ORIENTATION_OVERRIDE\"\n     *     android:value=\"true|false\"/&gt;\n     * &lt;/application&gt;\n     * </pre>\n     ",
    "links" : [ "android.content.pm.PackageManager.Property" ]
  }, {
    "name" : "PROPERTY_COMPAT_ALLOW_MIN_ASPECT_RATIO_OVERRIDE",
    "type" : "String",
    "comment" : "\n     * Application level {@link android.content.pm.PackageManager.Property PackageManager.Property}\n     * for an app to inform the system that the app should be opted-out from the compatibility\n     * override that changes the min aspect ratio.\n     *\n     * <p>When this compat override is enabled the min aspect ratio given in the app's manifest can\n     * be overridden by the device manufacturer using their discretion to improve display\n     * compatibility unless the app's manifest value is higher. This treatment will also apply if\n     * no min aspect ratio value is provided in the manifest. These treatments can apply either in\n     * specific cases (e.g. device is in portrait) or each time the app is displayed on screen.\n     *\n     * <p>Setting this property to {@code false} informs the system that the app must be\n     * opted-out from the compatibility treatment even if the device manufacturer has opted the app\n     * into the treatment.\n     *\n     * <p>Not setting this property at all, or setting this property to {@code true} has no effect.\n     *\n     * <p><b>Syntax:</b>\n     * <pre>\n     * &lt;application&gt;\n     *   &lt;property\n     *     android:name=\"android.window.PROPERTY_COMPAT_ALLOW_MIN_ASPECT_RATIO_OVERRIDE\"\n     *     android:value=\"true|false\"/&gt;\n     * &lt;/application&gt;\n     * </pre>\n     ",
    "links" : [ "android.content.pm.PackageManager.Property" ]
  }, {
    "name" : "PROPERTY_COMPAT_ALLOW_RESIZEABLE_ACTIVITY_OVERRIDES",
    "type" : "String",
    "comment" : "\n     * Application level {@link android.content.pm.PackageManager.Property PackageManager.Property}\n     * for an app to inform the system that the app should be opted-out from the compatibility\n     * overrides that change the resizability of the app.\n     *\n     * <p>When these compat overrides are enabled they force the packages they are applied to to be\n     * resizable/unresizable. If the app is forced to be resizable this won't change whether the app\n     * can be put into multi-windowing mode, but allow the app to resize without going into size\n     * compatibility mode when the window container resizes, such as display size change or screen\n     * rotation.\n     *\n     * <p>Setting this property to {@code false} informs the system that the app must be\n     * opted-out from the compatibility treatment even if the device manufacturer has opted the app\n     * into the treatment.\n     *\n     * <p>Not setting this property at all, or setting this property to {@code true} has no effect.\n     *\n     * <p><b>Syntax:</b>\n     * <pre>\n     * &lt;application&gt;\n     *   &lt;property\n     *     android:name=\"android.window.PROPERTY_COMPAT_ALLOW_RESIZEABLE_ACTIVITY_OVERRIDES\"\n     *     android:value=\"true|false\"/&gt;\n     * &lt;/application&gt;\n     * </pre>\n     ",
    "links" : [ "android.content.pm.PackageManager.Property" ]
  }, {
    "name" : "PROPERTY_COMPAT_ALLOW_USER_ASPECT_RATIO_OVERRIDE",
    "type" : "String",
    "comment" : "\n     * Application level\n     * {@link android.content.pm.PackageManager.Property PackageManager.Property}\n     * tag that (when set to false) informs the system the app has opted out of the\n     * user-facing aspect ratio compatibility override.\n     *\n     * <p>The compatibility override enables device users to set the app's aspect\n     * ratio or force the app to fill the display regardless of the aspect\n     * ratio or orientation specified in the app manifest.\n     *\n     * <p>The aspect ratio compatibility override is exposed to users in device\n     * settings. A menu in device settings lists all apps that have not opted out of\n     * the compatibility override. Users select apps from the menu and set the\n     * app aspect ratio on a per-app basis. Typically, the menu is available\n     * only on large screen devices.\n     *\n     * <p>When users apply the aspect ratio override, the minimum aspect ratio\n     * specified in the app manifest is overridden. If users choose a\n     * full-screen aspect ratio, the orientation of the activity is forced to\n     * {@link android.content.pm.ActivityInfo#SCREEN_ORIENTATION_USER};\n     * see {@link #PROPERTY_COMPAT_ALLOW_USER_ASPECT_RATIO_FULLSCREEN_OVERRIDE} to\n     * disable the full-screen option only.\n     *\n     * <p>The user override is intended to improve the app experience on devices\n     * that have the ignore orientation request display setting enabled by OEMs\n     * (enables compatibility mode for fixed orientation on Android 12 (API\n     * level 31) or higher; see\n     * <a href=\"https://developer.android.com/guide/topics/large-screens/large-screen-compatibility-mode\">\n     * Large screen compatibility mode</a>\n     * for more details).\n     *\n     * <p>To opt out of the user aspect ratio compatibility override, add this property\n     * to your app manifest and set the value to {@code false}. Your app will be excluded\n     * from the list of apps in device settings, and users will not be able to override\n     * the app's aspect ratio.\n     *\n     * <p>Not setting this property at all, or setting this property to {@code true} has no effect.\n     *\n     * <p><b>Syntax:</b>\n     * <pre>\n     * &lt;application&gt;\n     *   &lt;property\n     *     android:name=\"android.window.PROPERTY_COMPAT_ALLOW_USER_ASPECT_RATIO_OVERRIDE\"\n     *     android:value=\"false\"/&gt;\n     * &lt;/application&gt;\n     * </pre>\n     ",
    "links" : [ "#PROPERTY_COMPAT_ALLOW_USER_ASPECT_RATIO_FULLSCREEN_OVERRIDE", "android.content.pm.PackageManager.Property", "android.content.pm.ActivityInfo#SCREEN_ORIENTATION_USER" ]
  }, {
    "name" : "PROPERTY_COMPAT_ALLOW_USER_ASPECT_RATIO_FULLSCREEN_OVERRIDE",
    "type" : "String",
    "comment" : "\n     * Application level\n     * {@link android.content.pm.PackageManager.Property PackageManager.Property}\n     * tag that (when set to false) informs the system the app has opted out of the\n     * full-screen option of the user aspect ratio compatibility override settings. (For\n     * background information about the user aspect ratio compatibility override, see\n     * {@link #PROPERTY_COMPAT_ALLOW_USER_ASPECT_RATIO_OVERRIDE}.)\n     *\n     * <p>When users apply the full-screen compatibility override, the orientation\n     * of the activity is forced to {@link android.content.pm.ActivityInfo#SCREEN_ORIENTATION_USER}.\n     *\n     * <p>The user override is intended to improve the app experience on devices\n     * that have the ignore orientation request display setting enabled by OEMs\n     * (enables compatibility mode for fixed orientation on Android 12 (API\n     * level 31) or higher; see\n     * <a href=\"https://developer.android.com/guide/topics/large-screens/large-screen-compatibility-mode\">\n     * Large screen compatibility mode</a>\n     * for more details).\n     *\n     * <p>To opt out of the full-screen option of the user aspect ratio compatibility\n     * override, add this property to your app manifest and set the value to {@code false}.\n     * Your app will have full-screen option removed from the list of user aspect ratio\n     * override options in device settings, and users will not be able to apply\n     * full-screen override to your app.\n     *\n     * <p><b>Note:</b> If {@link #PROPERTY_COMPAT_ALLOW_USER_ASPECT_RATIO_OVERRIDE} is\n     * {@code false}, this property has no effect.\n     *\n     * <p>Not setting this property at all, or setting this property to {@code true} has no effect.\n     *\n     * <p><b>Syntax:</b>\n     * <pre>\n     * &lt;application&gt;\n     *   &lt;property\n     *     android:name=\"android.window.PROPERTY_COMPAT_ALLOW_USER_ASPECT_RATIO_FULLSCREEN_OVERRIDE\"\n     *     android:value=\"false\"/&gt;\n     * &lt;/application&gt;\n     * </pre>\n     ",
    "links" : [ "android.content.pm.PackageManager.Property", "android.content.pm.ActivityInfo#SCREEN_ORIENTATION_USER", "#PROPERTY_COMPAT_ALLOW_USER_ASPECT_RATIO_OVERRIDE" ]
  }, {
    "name" : "PARCEL_KEY_SHORTCUTS_ARRAY",
    "type" : "String",
    "comment" : "\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "ACTIVITY_EMBEDDING_GUARD_WITH_ANDROID_15",
    "type" : "boolean",
    "comment" : "\n     * Whether the WindowManager Extensions - Activity Embedding feature should be guarded by\n     * the app's target SDK on Android 15.\n     *\n     * WindowManager Extensions are only required for foldable and large screen before Android 15,\n     * so we want to guard the Activity Embedding feature since it can have app compat impact on\n     * devices with a compact size display.\n     *\n     * <p>If {@code true}, the feature is only enabled if the app's target SDK is Android 15 or\n     * above.\n     *\n     * <p>If {@code false}, the feature is enabled for all apps.\n     *\n     * <p>The default value is {@code true}. OEMs can set to {@code false} by having their device\n     * config to inherit window_extensions.mk. This is also required for large screen devices.\n     * <pre>\n     * $(call inherit-product, $(SRC_TARGET_DIR)/product/window_extensions.mk)\n     * </pre>\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "ENABLE_ACTIVITY_EMBEDDING_FOR_ANDROID_15",
    "type" : "long",
    "comment" : "\n     * For devices with {@link #ACTIVITY_EMBEDDING_GUARD_WITH_ANDROID_15} as {@code true},\n     * the Activity Embedding feature is enabled if the app's target SDK is Android 15+.\n     *\n     * @see #ACTIVITY_EMBEDDING_GUARD_WITH_ANDROID_15\n     * @hide\n     ",
    "links" : [ "#ACTIVITY_EMBEDDING_GUARD_WITH_ANDROID_15" ]
  }, {
    "name" : "HAS_WINDOW_EXTENSIONS_ON_DEVICE",
    "type" : "boolean",
    "comment" : "\n     * Whether the device contains the WindowManager Extensions shared library.\n     * This is enabled for all devices through window_extensions_base.mk, but can be dropped if the\n     * device doesn't support multi window.\n     *\n     * <p>Note: Large screen devices must also inherit window_extensions.mk to enable the Activity\n     * Embedding feature by default for all apps.\n     *\n     * @see #ACTIVITY_EMBEDDING_GUARD_WITH_ANDROID_15\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "PROPERTY_ACTIVITY_EMBEDDING_ALLOW_SYSTEM_OVERRIDE",
    "type" : "String",
    "comment" : "\n     * Application-level {@link android.content.pm.PackageManager.Property PackageManager.Property}\n     * tag that specifies whether OEMs are permitted to provide activity embedding split-rule\n     * configurations on behalf of the app.\n     *\n     * <p>If {@code true}, the system is permitted to override the app's windowing behavior and\n     * implement activity embedding split rules, such as displaying activities side by side. A\n     * system override informs the app that the activity embedding APIs are disabled so the app\n     * doesn't provide its own activity embedding rules, which would conflict with the system's\n     * rules.\n     *\n     * <p>If {@code false}, the system is not permitted to override the windowing behavior of the\n     * app. Set the property to {@code false} if the app provides its own activity embedding split\n     * rules, or if you want to prevent the system override for any other reason.\n     *\n     * <p>The default value is {@code false}.\n     *\n     * <p class=\"note\"><b>Note:</b> Refusal to permit the system override is not enforceable. OEMs\n     * can override the app's activity embedding implementation whether or not this property is\n     * specified and set to {@code false}. The property is, in effect, a hint to OEMs.\n     *\n     * <p>OEMs can implement activity embedding on any API level. The best practice for apps is to\n     * always explicitly set this property in the app manifest file regardless of targeted API level\n     * rather than rely on the default value.\n     *\n     * <p><b>Syntax:</b>\n     * <pre>\n     * &lt;application&gt;\n     *   &lt;property\n     *     android:name=\"android.window.PROPERTY_ACTIVITY_EMBEDDING_ALLOW_SYSTEM_OVERRIDE\"\n     *     android:value=\"true|false\"/&gt;\n     * &lt;/application&gt;\n     * </pre>\n     ",
    "links" : [ "android.content.pm.PackageManager.Property" ]
  }, {
    "name" : "PROPERTY_ALLOW_UNTRUSTED_ACTIVITY_EMBEDDING_STATE_SHARING",
    "type" : "String",
    "comment" : "\n     * Activity-level {@link android.content.pm.PackageManager.Property PackageManager.Property}\n     * that declares whether this (embedded) activity allows the system to share its state with the\n     * host app when it is embedded in a different process in\n     * {@link android.R.attr#allowUntrustedActivityEmbedding untrusted mode}.\n     *\n     * <p>If this property is \"true\", the host app may receive event callbacks for the activity\n     * state change, including the reparent event and the component name of the activity, which are\n     * required to restore the embedding state after the embedded activity exits picture-in-picture\n     * mode. This property does not share any of the activity content with the host. Note that, for\n     * {@link android.R.attr#knownActivityEmbeddingCerts trusted embedding}, the reparent event and\n     * the component name are always shared with the host regardless of the value of this property.\n     *\n     * <p>The default value is {@code false}.\n     *\n     * <p><b>Syntax:</b>\n     * <pre>\n     * &lt;activity&gt;\n     *   &lt;property\n     *     android:name=\"android.window.PROPERTY_ALLOW_UNTRUSTED_ACTIVITY_EMBEDDING_STATE_SHARING\"\n     *     android:value=\"true|false\"/&gt;\n     * &lt;/activity&gt;\n     * </pre>\n     *\n     * @hide\n     ",
    "links" : [ "android.content.pm.PackageManager.Property", "android.R.attr#knownActivityEmbeddingCerts", "android.R.attr#allowUntrustedActivityEmbedding" ]
  }, {
    "name" : "PROPERTY_ACTIVITY_EMBEDDING_SPLITS_ENABLED",
    "type" : "String",
    "comment" : "\n     * Application level {@link android.content.pm.PackageManager.Property PackageManager.Property}\n     * that an app can specify to inform the system that the app is activity embedding split feature\n     * enabled.\n     *\n     * <p>With this property, the system could provide custom behaviors for the apps that are\n     * activity embedding split feature enabled. For example, the fixed-portrait orientation\n     * requests of the activities could be ignored by the system in order to provide seamless\n     * activity embedding split experiences while holding large screen devices in landscape\n     * orientation.\n     *\n     * <p><b>Syntax:</b>\n     * <pre>\n     * &lt;application&gt;\n     *   &lt;property\n     *     android:name=\"android.window.PROPERTY_ACTIVITY_EMBEDDING_SPLITS_ENABLED\"\n     *     android:value=\"true|false\"/&gt;\n     * &lt;/application&gt;\n     * </pre>\n     ",
    "links" : [ "android.content.pm.PackageManager.Property" ]
  }, {
    "name" : "PROPERTY_SUPPORTS_MULTI_INSTANCE_SYSTEM_UI",
    "type" : "String",
    "comment" : "\n     * Activity or Application level {@link android.content.pm.PackageManager.Property\n     * PackageManager.Property} for an app to declare that System UI should be shown for this\n     * app/component to allow it to be launched as multiple instances.  This property only affects\n     * SystemUI behavior and does _not_ affect whether a component can actually be launched into\n     * multiple instances, which is determined by the Activity's {@code launchMode} or the launching\n     * Intent's flags.  If the property is set on the Application, then all components within that\n     * application will use that value unless specified per component.\n     *\n     * The value must be a boolean string.\n     *\n     * <p><b>Syntax:</b>\n     * <pre>\n     * &lt;activity&gt;\n     *   &lt;property\n     *     android:name=\"android.window.PROPERTY_SUPPORTS_MULTI_INSTANCE_SYSTEM_UI\"\n     *     android:value=\"true|false\"/&gt;\n     * &lt;/activity&gt;\n     * </pre>\n     ",
    "links" : [ "android.content.pm.PackageManager.PropertyPackageManager.Property" ]
  }, {
    "name" : "PROPERTY_COMPAT_ALLOW_SMALL_COVER_SCREEN",
    "type" : "String",
    "comment" : "\n     * Application or Activity level\n     * {@link android.content.pm.PackageManager.Property PackageManager.Property} to provide any\n     * preferences for showing all or specific Activities on small cover displays of foldable\n     * style devices.\n     *\n     * <p>The only supported value for the property is {@link #COMPAT_SMALL_COVER_SCREEN_OPT_IN}.\n     *\n     * <p><b>Syntax:</b>\n     * <pre>\n     * &lt;application&gt;\n     *   &lt;property\n     *     android:name=\"android.window.PROPERTY_COMPAT_ALLOW_SMALL_COVER_SCREEN\"\n     *     android:value=1 <!-- COMPAT_COVER_SCREEN_OPT_IN -->/&gt;\n     * &lt;/application&gt;\n     * </pre>\n     ",
    "links" : [ "android.content.pm.PackageManager.Property", "#COMPAT_SMALL_COVER_SCREEN_OPT_IN" ]
  }, {
    "name" : "COMPAT_SMALL_COVER_SCREEN_OPT_IN",
    "type" : "int",
    "comment" : "\n     * Value applicable for the {@link #PROPERTY_COMPAT_ALLOW_SMALL_COVER_SCREEN} property to\n     * provide a signal to the system that an application or its specific activities explicitly\n     * opt into being displayed on small cover screens on flippable style foldable devices that\n     * measure at least 1.5 inches up to 2.2 inches for the shorter dimension and at least 2.4\n     * inches up to 3.4 inches for the longer dimension\n     ",
    "links" : [ "#PROPERTY_COMPAT_ALLOW_SMALL_COVER_SCREEN" ]
  }, {
    "name" : "SCREEN_RECORDING_STATE_NOT_VISIBLE",
    "type" : "int",
    "comment" : " Indicates the app that registered the callback is not visible in screen recording. ",
    "links" : [ ]
  }, {
    "name" : "SCREEN_RECORDING_STATE_VISIBLE",
    "type" : "int",
    "comment" : " Indicates the app that registered the callback is visible in screen recording. ",
    "links" : [ ]
  } ],
  "methods" : [ {
    "name" : "public Display getDefaultDisplay()",
    "returnType" : "Display",
    "comment" : "\n     * Returns the {@link Display} upon which this {@link WindowManager} instance\n     * will create new windows.\n     * <p>\n     * Despite the name of this method, the display that is returned is not\n     * necessarily the primary display of the system (see {@link Display#DEFAULT_DISPLAY}).\n     * The returned display could instead be a secondary display that this\n     * window manager instance is managing.  Think of it as the display that\n     * this {@link WindowManager} instance uses by default.\n     * </p><p>\n     * To create windows on a different display, you need to obtain a\n     * {@link WindowManager} for that {@link Display}.  (See the {@link WindowManager}\n     * class documentation for more information.)\n     * </p>\n     *\n     * @return The display that this window manager is managing.\n     * @deprecated Use {@link Context#getDisplay()} instead.\n     ",
    "links" : [ "android.view.WindowManager", "android.view.Display", "android.view.Display#DEFAULT_DISPLAY", "android.content.Context#getDisplay()" ]
  }, {
    "name" : "public void removeViewImmediate(View view)",
    "returnType" : "void",
    "comment" : "\n     * Special variation of {@link #removeView} that immediately invokes\n     * the given view hierarchy's {@link View#onDetachedFromWindow()\n     * View.onDetachedFromWindow()} methods before returning.  This is not\n     * for normal applications; using it correctly requires great care.\n     *\n     * @param view The view to be removed.\n     ",
    "links" : [ "android.view.View#onDetachedFromWindow()", "#removeView" ]
  }, {
    "name" : " WindowMetrics getCurrentWindowMetrics()",
    "returnType" : "WindowMetrics",
    "comment" : "\n     * Returns the {@link WindowMetrics} according to the current system state.\n     * <p>\n     * The metrics describe the size of the area the window would occupy with\n     * {@link LayoutParams#MATCH_PARENT MATCH_PARENT} width and height, and the {@link WindowInsets}\n     * such a window would have.\n     * <p>\n     * The value of this is based on the <b>current</b> windowing state of the system.\n     *\n     * For example, for activities in multi-window mode, the metrics returned are based on the\n     * current bounds that the user has selected for the {@link android.app.Activity Activity}'s\n     * task.\n     * <p>\n     * In most scenarios, {@link #getCurrentWindowMetrics()} rather than\n     * {@link #getMaximumWindowMetrics()} is the correct API to use, since it ensures values reflect\n     * window size when the app is not fullscreen.\n     *\n     * @see #getMaximumWindowMetrics()\n     * @see WindowMetrics\n     ",
    "links" : [ "#getCurrentWindowMetrics()", "android.view.WindowMetrics", "android.view.WindowInsets", "#MATCH_PARENT", "android.app.Activity", "#getMaximumWindowMetrics()" ]
  }, {
    "name" : " WindowMetrics getMaximumWindowMetrics()",
    "returnType" : "WindowMetrics",
    "comment" : "\n     * Returns the largest {@link WindowMetrics} an app may expect in the current system state.\n     * <p>\n     * The value of this is based on the largest <b>potential</b> windowing state of the system.\n     *\n     * For example, for activities in multi-window mode, the metrics returned are based on the\n     * what the bounds would be if the user expanded the {@link android.app.Activity Activity}'s\n     * task to cover the entire screen.\n     * <p>\n     * The metrics describe the size of the largest potential area the window might occupy with\n     * {@link LayoutParams#MATCH_PARENT MATCH_PARENT} width and height, and the {@link WindowInsets}\n     * such a window would have.\n     * <p>\n     * Note that this might still be smaller than the size of the physical display if certain areas\n     * of the display are not available to windows created in this {@link Context}.\n     *\n     * For example, given that there's a device which have a multi-task mode to limit activities\n     * to a half screen. In this case, {@link #getMaximumWindowMetrics()} reports the bounds of\n     * the half screen which the activity is located.\n     * <p>\n     * <b>Generally {@link #getCurrentWindowMetrics()} is the correct API to use</b> for choosing\n     * UI layouts. {@link #getMaximumWindowMetrics()} are only appropriate when the application\n     * needs to know the largest possible size it can occupy if the user expands/maximizes it on the\n     * screen.\n     *\n     * @see #getCurrentWindowMetrics()\n     * @see WindowMetrics\n     * @see Display#getRealSize(Point)\n     ",
    "links" : [ "#getCurrentWindowMetrics()", "android.content.Context", "android.view.WindowMetrics", "android.view.WindowInsets", "#MATCH_PARENT", "android.app.Activity", "#getMaximumWindowMetrics()" ]
  }, {
    "name" : " Set<WindowMetrics> getPossibleMaximumWindowMetrics(int displayId)",
    "returnType" : "Set<WindowMetrics>",
    "comment" : "\n     * Returns a set of {@link WindowMetrics} for the given display. Each WindowMetrics instance\n     * is the maximum WindowMetrics for a device state. This is not guaranteed to include all\n     * possible device states.\n     *\n     * This API can only be used by Launcher.\n     *\n     * @param displayId the id of the logical display\n     * @hide\n     ",
    "links" : [ "android.view.WindowMetrics" ]
  }, {
    "name" : " static boolean hasWindowExtensionsEnabled()",
    "returnType" : "boolean",
    "comment" : "\n     * Whether the WindowManager Extensions are enabled.\n     * If {@code false}, the WM Jetpack will report most of its features as disabled.\n     * @see #HAS_WINDOW_EXTENSIONS_ON_DEVICE\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public void requestAppKeyboardShortcuts(final KeyboardShortcutsReceiver receiver, int deviceId)",
    "returnType" : "void",
    "comment" : "\n     * Request for app's keyboard shortcuts to be retrieved asynchronously.\n     *\n     * @param receiver The callback to be triggered when the result is ready.\n     * @param deviceId The deviceId of KeyEvent by which this request is triggered, or -1 if it's\n     *                 not triggered by a KeyEvent.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : " void requestImeKeyboardShortcuts(KeyboardShortcutsReceiver receiver, int deviceId)",
    "returnType" : "void",
    "comment" : "\n     * Request for ime's keyboard shortcuts to be retrieved asynchronously.\n     *\n     * @param receiver The callback to be triggered when the result is ready.\n     * @param deviceId The deviceId of KeyEvent by which this request is triggered, or -1 if it's\n     *                 not triggered by a KeyEvent.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public Region getCurrentImeTouchRegion()",
    "returnType" : "Region",
    "comment" : "\n     * Return the touch region for the current IME window, or an empty region if there is none.\n     *\n     * @return The region of the IME that is accepting touch inputs, or null if there is no IME, no\n     *         region or there was an error.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : " void setShouldShowWithInsecureKeyguard(int displayId, boolean shouldShow)",
    "returnType" : "void",
    "comment" : "\n     * Sets that the display should show its content when non-secure keyguard is shown.\n     *\n     * @param displayId Display ID.\n     * @param shouldShow Indicates that the display should show its content when non-secure keyguard\n     *                  is shown.\n     * @see KeyguardManager#isDeviceSecure()\n     * @see KeyguardManager#isDeviceLocked()\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : " void setShouldShowSystemDecors(int displayId, boolean shouldShow)",
    "returnType" : "void",
    "comment" : "\n     * Sets that the display should show system decors.\n     * <p>\n     * System decors include status bar, navigation bar, launcher.\n     * </p>\n     *\n     * @param displayId The id of the display.\n     * @param shouldShow Indicates that the display should show system decors.\n     * @see #shouldShowSystemDecors(int)\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : " boolean shouldShowSystemDecors(int displayId)",
    "returnType" : "boolean",
    "comment" : "\n     * Checks if the display supports showing system decors.\n     * <p>\n     * System decors include status bar, navigation bar, launcher.\n     * </p>\n     *\n     * @param displayId The id of the display.\n     * @see #setShouldShowSystemDecors(int, boolean)\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : " void setDisplayImePolicy(int displayId, @DisplayImePolicy int imePolicy)",
    "returnType" : "void",
    "comment" : "\n     * Sets the policy for how the display should show IME.\n     *\n     * @param displayId Display ID.\n     * @param imePolicy Indicates the policy for how the display should show IME.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : " int getDisplayImePolicy(int displayId)",
    "returnType" : "int",
    "comment" : "\n     * Indicates the policy for how the display should show IME.\n     *\n     * @param displayId The id of the display.\n     * @return The policy for how the display should show IME.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : " boolean isGlobalKey(int keyCode)",
    "returnType" : "boolean",
    "comment" : "\n     * Returns {@code true} if the key will be handled globally and not forwarded to all apps.\n     *\n     * @param keyCode the key code to check\n     * @return {@code true} if the key will be handled globally.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : " boolean isCrossWindowBlurEnabled()",
    "returnType" : "boolean",
    "comment" : "\n     * <p>\n     * Returns whether cross-window blur is currently enabled. This affects both window blur behind\n     * (see {@link LayoutParams#setBlurBehindRadius}) and window background blur (see\n     * {@link Window#setBackgroundBlurRadius}).\n     * </p><p>\n     * Cross-window blur might not be supported by some devices due to GPU limitations. It can also\n     * be disabled at runtime, e.g. during battery saving mode, when multimedia tunneling is used or\n     * when minimal post processing is requested. In such situations, no blur will be computed or\n     * drawn, so the blur target area will not be blurred. To handle this, the app might want to\n     * change its theme to one that does not use blurs. To listen for cross-window blur\n     * enabled/disabled events, use {@link #addCrossWindowBlurEnabledListener}.\n     * </p>\n     *\n     * @see #addCrossWindowBlurEnabledListener\n     * @see LayoutParams#setBlurBehindRadius\n     * @see Window#setBackgroundBlurRadius\n     ",
    "links" : [ "android.view.Window#setBackgroundBlurRadius", "#setBlurBehindRadius", "#addCrossWindowBlurEnabledListener" ]
  }, {
    "name" : " void addCrossWindowBlurEnabledListener(@NonNull Consumer<Boolean> listener)",
    "returnType" : "void",
    "comment" : "\n     * <p>\n     * Adds a listener, which will be called when cross-window blurs are enabled/disabled at\n     * runtime. This affects both window blur behind (see {@link LayoutParams#setBlurBehindRadius})\n     * and window background blur (see {@link Window#setBackgroundBlurRadius}).\n     * </p><p>\n     * Cross-window blur might not be supported by some devices due to GPU limitations. It can also\n     * be disabled at runtime, e.g. during battery saving mode, when multimedia tunneling is used or\n     * when minimal post processing is requested. In such situations, no blur will be computed or\n     * drawn, so the blur target area will not be blurred. To handle this, the app might want to\n     * change its theme to one that does not use blurs.\n     * </p><p>\n     * The listener will be called on the main thread.\n     * </p><p>\n     * If the listener is added successfully, it will be called immediately with the current\n     * cross-window blur enabled state.\n     * </p>\n     *\n     * @param listener the listener to be added. It will be called back with a boolean parameter,\n     *                 which is true if cross-window blur is enabled and false if it is disabled\n     *\n     * @see #removeCrossWindowBlurEnabledListener\n     * @see #isCrossWindowBlurEnabled\n     * @see LayoutParams#setBlurBehindRadius\n     * @see Window#setBackgroundBlurRadius\n     ",
    "links" : [ "android.view.Window#setBackgroundBlurRadius", "#setBlurBehindRadius" ]
  }, {
    "name" : " void addCrossWindowBlurEnabledListener(@NonNull @CallbackExecutor Executor executor, @NonNull Consumer<Boolean> listener)",
    "returnType" : "void",
    "comment" : "\n     * <p>\n     * Adds a listener, which will be called when cross-window blurs are enabled/disabled at\n     * runtime. This affects both window blur behind (see {@link LayoutParams#setBlurBehindRadius})\n     * and window background blur (see {@link Window#setBackgroundBlurRadius}).\n     * </p><p>\n     * Cross-window blur might not be supported by some devices due to GPU limitations. It can also\n     * be disabled at runtime, e.g. during battery saving mode, when multimedia tunneling is used or\n     * when minimal post processing is requested. In such situations, no blur will be computed or\n     * drawn, so the blur target area will not be blurred. To handle this, the app might want to\n     * change its theme to one that does not use blurs.\n     * </p><p>\n     * If the listener is added successfully, it will be called immediately with the current\n     * cross-window blur enabled state.\n     * </p>\n     *\n     * @param executor {@link Executor} to handle the listener callback\n     * @param listener the listener to be added. It will be called back with a boolean parameter,\n     *                 which is true if cross-window blur is enabled and false if it is disabled\n     *\n     * @see #removeCrossWindowBlurEnabledListener\n     * @see #isCrossWindowBlurEnabled\n     * @see LayoutParams#setBlurBehindRadius\n     * @see Window#setBackgroundBlurRadius\n     ",
    "links" : [ "android.view.Window#setBackgroundBlurRadius", "#setBlurBehindRadius", "android.annotation.CallbackExecutor" ]
  }, {
    "name" : " void removeCrossWindowBlurEnabledListener(@NonNull Consumer<Boolean> listener)",
    "returnType" : "void",
    "comment" : "\n     * Removes a listener, previously added with {@link #addCrossWindowBlurEnabledListener}\n     *\n     * @param listener the listener to be removed\n     *\n     * @see #addCrossWindowBlurEnabledListener\n     ",
    "links" : [ "#addCrossWindowBlurEnabledListener" ]
  }, {
    "name" : " void addProposedRotationListener(@NonNull @CallbackExecutor Executor executor, @NonNull IntConsumer listener)",
    "returnType" : "void",
    "comment" : "\n     * Adds a listener to start monitoring the proposed rotation of the current associated context.\n     * It reports the current recommendation for the rotation that takes various factors (e.g.\n     * sensor, context, device state, etc) into account. The proposed rotation might not be applied\n     * by the system automatically due to the application's active preference to lock the\n     * orientation (e.g. with {@link android.app.Activity#setRequestedOrientation(int)}). This\n     * listener gives application an opportunity to selectively react to device orientation changes.\n     * The newly added listener will be called with current proposed rotation. Note that the context\n     * of this window manager instance must be a {@code UiContext}.\n     *\n     * @param executor The executor on which callback method will be invoked.\n     * @param listener Called when the proposed rotation for the context is being delivered.\n     *                 The reported rotation can be {@link Surface#ROTATION_0},\n     *                 {@link Surface#ROTATION_90}, {@link Surface#ROTATION_180} and\n     *                 {@link Surface#ROTATION_270}.\n     * @throws UnsupportedOperationException if this method is called on an instance that is not\n     *         associated with a {@code UiContext}.\n     ",
    "links" : [ "android.view.Surface#ROTATION_270", "android.view.Surface#ROTATION_180", "android.app.Activity#setRequestedOrientation(int)", "android.view.Surface#ROTATION_90", "android.view.Surface#ROTATION_0" ]
  }, {
    "name" : " void removeProposedRotationListener(@NonNull IntConsumer listener)",
    "returnType" : "void",
    "comment" : "\n     * Removes a listener, previously added with {@link #addProposedRotationListener}. It is\n     * recommended to call when the associated context no longer has visible components. No-op if\n     * the provided listener is not registered.\n     *\n     * @param listener The listener to be removed.\n     ",
    "links" : [ "#addProposedRotationListener" ]
  }, {
    "name" : " static String transitTypeToString(@TransitionType int type)",
    "returnType" : "String",
    "comment" : "\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : " static float fixScale(float scale)",
    "returnType" : "float",
    "comment" : "\n     * Ensure scales are between 0 and 20.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : " void holdLock(IBinder token, int durationMs)",
    "returnType" : "void",
    "comment" : "\n     * Holds the WM lock for the specified amount of milliseconds.\n     * Intended for use by the tests that need to imitate lock contention.\n     * The token should be obtained by\n     * {@link android.content.pm.PackageManager#getHoldLockToken()}.\n     * @hide\n     ",
    "links" : [ "android.content.pm.PackageManager#getHoldLockToken()" ]
  }, {
    "name" : " boolean isTaskSnapshotSupported()",
    "returnType" : "boolean",
    "comment" : "\n     * Used for testing to check if the system supports TaskSnapshot mechanism.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : " void registerTaskFpsCallback(@IntRange(from = 0) int taskId, @NonNull Executor executor, @NonNull TaskFpsCallback callback)",
    "returnType" : "void",
    "comment" : "\n     * Registers the frame rate per second count callback for one given task ID.\n     * Each callback can only register for receiving FPS callback for one task id until unregister\n     * is called. If there's no task associated with the given task id,\n     * {@link IllegalArgumentException} will be thrown. Registered callbacks should always be\n     * unregistered via {@link #unregisterTaskFpsCallback(TaskFpsCallback)}\n     * even when the task id has been destroyed.\n     *\n     * @param taskId task id of the task.\n     * @param executor Executor to execute the callback.\n     * @param callback callback to be registered.\n     *\n     * @hide\n     ",
    "links" : [ "#unregisterTaskFpsCallback(TaskFpsCallback)", "IllegalArgumentException" ]
  }, {
    "name" : " void unregisterTaskFpsCallback(@NonNull TaskFpsCallback callback)",
    "returnType" : "void",
    "comment" : "\n     * Unregisters the frame rate per second count callback which was registered with\n     * {@link #registerTaskFpsCallback(Executor, int, TaskFpsCallback)}.\n     *\n     * @param callback callback to be unregistered.\n     *\n     * @hide\n     ",
    "links" : [ "#registerTaskFpsCallback(Executor" ]
  }, {
    "name" : " Bitmap snapshotTaskForRecents(@IntRange(from = 0) int taskId)",
    "returnType" : "Bitmap",
    "comment" : "\n     * Take a snapshot using the same path that's used for Recents. This is used for Testing only.\n     *\n     * @param taskId to take the snapshot of\n     *\n     * @return a bitmap of the screenshot or {@code null} if it was unable to screenshot. The\n     * screenshot can fail if the taskId is invalid or if there's no SurfaceControl associated with\n     * that task.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : " List<ComponentName> notifyScreenshotListeners(int displayId)",
    "returnType" : "List<ComponentName>",
    "comment" : "\n     * Invoked when a screenshot is taken of the default display to notify registered listeners.\n     *\n     * Should be invoked only by SysUI.\n     *\n     * @param displayId id of the display screenshot.\n     * @return List of ComponentNames corresponding to the activities that were notified.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : " boolean replaceContentOnDisplayWithMirror(int displayId, @NonNull Window window)",
    "returnType" : "boolean",
    "comment" : "\n     * @param displayId The displayId to that should have its content replaced.\n     * @param window The window that should get mirrored and the mirrored content rendered on\n     *               displayId passed in.\n     *\n     * @return Whether it successfully created a mirror SurfaceControl and replaced the display\n     * content with the mirror of the Window.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : " boolean replaceContentOnDisplayWithSc(int displayId, @NonNull SurfaceControl sc)",
    "returnType" : "boolean",
    "comment" : "\n     * @param displayId The displayId to that should have its content replaced.\n     * @param sc The SurfaceControl that should get rendered onto the displayId passed in.\n     *\n     * @return Whether it successfully created a mirror SurfaceControl and replaced the display\n     * content with the mirror of the Window.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : " void registerTrustedPresentationListener(@NonNull IBinder window, @NonNull TrustedPresentationThresholds thresholds, @NonNull Executor executor, @NonNull Consumer<Boolean> listener)",
    "returnType" : "void",
    "comment" : "\n     * Sets a callback to receive feedback about the presentation of a {@link Window}.\n     * When the {@link Window} is presented according to the passed in\n     * {@link TrustedPresentationThresholds}, it is said to \"enter the state\", and receives the\n     * callback with {@code true}. When the conditions fall out of thresholds, it is then\n     * said to leave the state and the caller will receive a callback with {@code false}. The\n     * callbacks be sent for every state transition thereafter.\n     * <p>\n     * There are a few simple thresholds:\n     * <ul>\n     *    <li>minAlpha: Lower bound on computed alpha</li>\n     *    <li>minFractionRendered: Lower bounds on fraction of pixels that were rendered</li>\n     *    <li>stabilityThresholdMs: A time that alpha and fraction rendered must remain within\n     *    bounds before we can \"enter the state\" </li>\n     * </ul>\n     * <p>\n     * The fraction of pixels rendered is a computation based on scale, crop\n     * and occlusion. The calculation may be somewhat counterintuitive, so we\n     * can work through an example. Imagine we have a Window with a 100x100 buffer\n     * which is occluded by (10x100) pixels on the left, and cropped by (100x10) pixels\n     * on the top. Furthermore imagine this Window is scaled by 0.9 in both dimensions.\n     * (c=crop,o=occluded,b=both,x=none)\n     *\n     * <blockquote>\n     * <table>\n     *   <caption></caption>\n     *   <tr><td>b</td><td>c</td><td>c</td><td>c</td></tr>\n     *   <tr><td>o</td><td>x</td><td>x</td><td>x</td></tr>\n     *   <tr><td>o</td><td>x</td><td>x</td><td>x</td></tr>\n     *   <tr><td>o</td><td>x</td><td>x</td><td>x</td></tr>\n     * </table>\n     * </blockquote>\n     *\n     *<p>\n     * We first start by computing fr=xscale*yscale=0.9*0.9=0.81, indicating\n     * that \"81%\" of the pixels were rendered. This corresponds to what was 100\n     * pixels being displayed in 81 pixels. This is somewhat of an abuse of\n     * language, as the information of merged pixels isn't totally lost, but\n     * we err on the conservative side.\n     * <p>\n     * We then repeat a similar process for the crop and covered regions and\n     * accumulate the results: fr = fr * (fractionNotCropped) * (fractionNotCovered)\n     * So for this example we would get 0.9*0.9*0.9*0.9=0.65...\n     * <p>\n     * Notice that this is not completely accurate, as we have double counted\n     * the region marked as b. However we only wanted a \"lower bound\" and so it\n     * is ok to err in this direction. Selection of the threshold will ultimately\n     * be somewhat arbitrary, and so there are some somewhat arbitrary decisions in\n     * this API as well.\n     * <p>\n     * @param window     The Window to add the trusted presentation listener for. This can be\n     *                   retrieved from {@link View#getWindowToken()}.\n     * @param thresholds The {@link TrustedPresentationThresholds} that will specify when the to\n     *                   invoke the callback.\n     * @param executor   The {@link Executor} where the callback will be invoked on.\n     * @param listener   The {@link Consumer} that will receive the callbacks\n     *                   when entered or exited trusted presentation per the thresholds.\n     * @see TrustedPresentationThresholds\n     ",
    "links" : [ "android.view.View#getWindowToken()", "java.util.function.Consumer", "android.window.TrustedPresentationThresholds", "android.annotation.CallbackExecutor", "android.view.Window" ]
  }, {
    "name" : " void unregisterTrustedPresentationListener(@NonNull Consumer<Boolean> listener)",
    "returnType" : "void",
    "comment" : "\n     * Removes a presentation listener associated with a window. If the listener was not previously\n     * registered, the call will be a noop.\n     *\n     * @see WindowManager#registerTrustedPresentationListener(IBinder, TrustedPresentationThresholds, Executor, Consumer)\n     ",
    "links" : [ ]
  }, {
    "name" : " InputTransferToken registerBatchedSurfaceControlInputReceiver(@NonNull InputTransferToken hostInputTransferToken, @NonNull SurfaceControl surfaceControl, @NonNull Choreographer choreographer, @NonNull SurfaceControlInputReceiver receiver)",
    "returnType" : "InputTransferToken",
    "comment" : "\n     * Registers a {@link SurfaceControlInputReceiver} for a {@link SurfaceControl} that will\n     * receive batched input event. For those events that are batched, the invocation will happen\n     * once per {@link Choreographer} frame, and other input events will be delivered immediately.\n     * This is different from\n     * {@link #registerUnbatchedSurfaceControlInputReceiver(int, InputTransferToken, SurfaceControl,\n     * Looper, SurfaceControlInputReceiver)} in that the input events are received batched. The\n     * caller must invoke {@link #unregisterSurfaceControlInputReceiver(SurfaceControl)} to clean up\n     * the resources when no longer needing to use the {@link SurfaceControlInputReceiver}\n     *\n     * @param surfaceControl         The SurfaceControl to register the InputChannel for\n     * @param hostInputTransferToken The host token to link the embedded. This is used to handle\n     *                               transferring touch gesture from host to embedded and for ANRs\n     *                               to ensure the host receives the ANR if any issues with\n     *                               touch on the embedded.\n     * @param choreographer          The Choreographer used for batching. This should match the\n     *                               rendering Choreographer.\n     * @param receiver               The SurfaceControlInputReceiver that will receive the input\n     *                               events\n     * @return Returns the {@link InputTransferToken} that can be used to transfer touch gesture\n     * to or from other windows.\n     ",
    "links" : [ "#registerUnbatchedSurfaceControlInputReceiver(int", "android.view.SurfaceControl", "android.view.SurfaceControlInputReceiver", "#unregisterSurfaceControlInputReceiver(SurfaceControl)", "android.window.InputTransferToken", "android.view.Choreographer" ]
  }, {
    "name" : " InputTransferToken registerUnbatchedSurfaceControlInputReceiver(@NonNull InputTransferToken hostInputTransferToken, @NonNull SurfaceControl surfaceControl, @NonNull Looper looper, @NonNull SurfaceControlInputReceiver receiver)",
    "returnType" : "InputTransferToken",
    "comment" : "\n     * Registers a {@link SurfaceControlInputReceiver} for a {@link SurfaceControl} that will\n     * receive every input event. This is different than calling\n     * {@link #registerBatchedSurfaceControlInputReceiver(InputTransferToken, SurfaceControl,\n     * Choreographer, SurfaceControlInputReceiver)} in that the input events are received\n     * unbatched.\n     * The caller must invoke {@link #unregisterSurfaceControlInputReceiver(SurfaceControl)} to\n     * clean up the resources when no longer needing to use the {@link SurfaceControlInputReceiver}\n     *\n     * @param surfaceControl         The SurfaceControl to register the InputChannel for\n     * @param hostInputTransferToken The host token to link the embedded. This is used to handle\n     *                               transferring touch gesture from host to embedded and for ANRs\n     *                               to ensure the host receives the ANR if any issues with\n     *                               touch on the embedded.\n     * @param looper                 The looper to use when invoking callbacks.\n     * @param receiver               The SurfaceControlInputReceiver that will receive the input\n     *                               events.\n     * @return Returns the {@link InputTransferToken} that can be used to transfer touch gesture\n     * to or from other windows.\n     ",
    "links" : [ "#registerBatchedSurfaceControlInputReceiver(InputTransferToken", "android.view.SurfaceControl", "android.view.SurfaceControlInputReceiver", "#unregisterSurfaceControlInputReceiver(SurfaceControl)", "android.window.InputTransferToken" ]
  }, {
    "name" : " void unregisterSurfaceControlInputReceiver(@NonNull SurfaceControl surfaceControl)",
    "returnType" : "void",
    "comment" : "\n     * Unregisters and cleans up the registered {@link SurfaceControlInputReceiver} for the\n     * specified token.\n     * <p>\n     * Must be called on the same {@link Looper} thread to which was passed to the\n     * {@link #registerBatchedSurfaceControlInputReceiver(InputTransferToken, SurfaceControl,\n     * Choreographer, SurfaceControlInputReceiver)} or\n     * {@link #registerUnbatchedSurfaceControlInputReceiver(InputTransferToken, SurfaceControl,\n     * Looper, SurfaceControlInputReceiver)}\n     *\n     * @param surfaceControl The SurfaceControl to remove and unregister the input channel for.\n     ",
    "links" : [ "#registerBatchedSurfaceControlInputReceiver(InputTransferToken", "#registerUnbatchedSurfaceControlInputReceiver(InputTransferToken", "android.os.Looper", "android.view.SurfaceControlInputReceiver" ]
  }, {
    "name" : " IBinder getSurfaceControlInputClientToken(@NonNull SurfaceControl surfaceControl)",
    "returnType" : "IBinder",
    "comment" : "\n     * Returns the input client token for the {@link SurfaceControl}. This will only return non\n     * null if the SurfaceControl was registered for input via\n     * {@link #registerBatchedSurfaceControlInputReceiver(InputTransferToken, SurfaceControl,\n     * Choreographer, SurfaceControlInputReceiver)} or\n     * {@link #registerUnbatchedSurfaceControlInputReceiver(InputTransferToken,\n     * SurfaceControl, Looper, SurfaceControlInputReceiver)}.\n     * <p>\n     * This is helpful for testing to ensure the test waits for the layer to be registered with\n     * SurfaceFlinger and Input before proceeding with the test.\n     *\n     * @hide\n     ",
    "links" : [ "#registerBatchedSurfaceControlInputReceiver(InputTransferToken", "#registerUnbatchedSurfaceControlInputReceiver(InputTransferToken", "android.view.SurfaceControl" ]
  }, {
    "name" : " boolean transferTouchGesture(@NonNull InputTransferToken transferFromToken, @NonNull InputTransferToken transferToToken)",
    "returnType" : "boolean",
    "comment" : "\n     * Transfer the currently in progress touch gesture from the transferFromToken to the\n     * transferToToken.\n     * <p><br>\n     * This requires that the fromToken and toToken are associated with each other. The association\n     * can be done different ways, depending on how the embedded window is created.\n     * <ul>\n     * <li>\n     * Creating a {@link SurfaceControlViewHost} and passing the host's\n     * {@link InputTransferToken} for\n     * {@link SurfaceControlViewHost#SurfaceControlViewHost(Context, Display, InputTransferToken)}.\n     * </li>\n     * <li>\n     * Registering a SurfaceControl for input and passing the host's token to either\n     * {@link #registerBatchedSurfaceControlInputReceiver(InputTransferToken, SurfaceControl,\n     * Choreographer, SurfaceControlInputReceiver)} or\n     * {@link #registerUnbatchedSurfaceControlInputReceiver(InputTransferToken,\n     * SurfaceControl, Looper, SurfaceControlInputReceiver)}.\n     * </li>\n     * </ul>\n     * <p>\n     * The host is likely to be an {@link AttachedSurfaceControl} so the host token can be\n     * retrieved via {@link AttachedSurfaceControl#getInputTransferToken()}.\n     * <p><br>\n     * Only the window currently receiving touch is allowed to transfer the gesture so if the caller\n     * attempts to transfer touch gesture from a token that doesn't have touch, it will fail the\n     * transfer.\n     * <p><br>\n     * When the host wants to transfer touch gesture to the embedded, it can retrieve the embedded\n     * token via {@link SurfaceControlViewHost.SurfacePackage#getInputTransferToken()} or use the\n     * value returned from either\n     * {@link #registerBatchedSurfaceControlInputReceiver(InputTransferToken, SurfaceControl,\n     * Choreographer, SurfaceControlInputReceiver)} or\n     * {@link #registerUnbatchedSurfaceControlInputReceiver(InputTransferToken, SurfaceControl,\n     * Looper, SurfaceControlInputReceiver)} and pass its own token as the transferFromToken.\n     * <p>\n     * When the embedded wants to transfer touch gesture to the host, it can pass in its own\n     * token as the transferFromToken and use the associated host's {@link InputTransferToken} as\n     * the transferToToken\n     * <p><br>\n     * When the touch is transferred, the window currently receiving touch gets an ACTION_CANCEL\n     * and does not receive any further input events for this gesture.\n     * <p>\n     * The transferred-to window receives an ACTION_DOWN event and then the remainder of the input\n     * events for this gesture. It does not receive any of the previous events of this gesture that\n     * the originating window received.\n     * <p>\n     * The transferTouchGesture API only works for the current gesture. When a new gesture\n     * arrives, input dispatcher will do a new round of hit testing. So, if the host window is\n     * still the first thing that's being touched, then it will receive the new gesture again. It\n     * will again be up to the host to transfer this new gesture to the embedded.\n     *\n     * @param transferFromToken the InputTransferToken for the currently active gesture\n     * @param transferToToken   the InputTransferToken to transfer the gesture to.\n     * @return Whether the touch stream was transferred.\n     * @see android.view.SurfaceControlViewHost.SurfacePackage#getInputTransferToken()\n     * @see AttachedSurfaceControl#getInputTransferToken()\n     ",
    "links" : [ "SurfaceControlViewHost.SurfacePackage#getInputTransferToken()", "#registerBatchedSurfaceControlInputReceiver(InputTransferToken", "android.view.SurfaceControlViewHost#SurfaceControlViewHost(Context", "#registerUnbatchedSurfaceControlInputReceiver(InputTransferToken", "android.view.AttachedSurfaceControl", "android.window.InputTransferToken", "android.view.SurfaceControlViewHost", "android.view.AttachedSurfaceControl#getInputTransferToken()" ]
  }, {
    "name" : " IBinder getDefaultToken()",
    "returnType" : "IBinder",
    "comment" : "\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : " int addScreenRecordingCallback(@NonNull @CallbackExecutor Executor executor, @NonNull Consumer<@ScreenRecordingState Integer> callback)",
    "returnType" : "int",
    "comment" : "\n     * Adds a screen recording callback. The callback will be invoked whenever the app becomes\n     * visible in screen recording or was visible in screen recording and becomes invisible in\n     * screen recording.\n     *\n     * <p>An app is considered visible in screen recording if any activities owned by the\n     * registering process's UID are being recorded.\n     *\n     * <p>Example:\n     *\n     * <pre>\n     * windowManager.addScreenRecordingCallback(state -> {\n     *     // handle change in screen recording state\n     * });\n     * </pre>\n     *\n     * @param executor The executor on which callback method will be invoked.\n     * @param callback The callback that will be invoked when screen recording visibility changes.\n     * @return the current screen recording state.\n     * @see #SCREEN_RECORDING_STATE_NOT_VISIBLE\n     * @see #SCREEN_RECORDING_STATE_VISIBLE\n     ",
    "links" : [ ]
  }, {
    "name" : " void removeScreenRecordingCallback(@NonNull Consumer<@ScreenRecordingState Integer> callback)",
    "returnType" : "void",
    "comment" : "\n     * Removes a screen recording callback.\n     *\n     * @param callback The callback to remove.\n     * @see #addScreenRecordingCallback(Executor, Consumer)\n     ",
    "links" : [ ]
  } ],
  "methodNames" : [ "public Display getDefaultDisplay()", "public void removeViewImmediate(View view)", " WindowMetrics getCurrentWindowMetrics()", " WindowMetrics getMaximumWindowMetrics()", " Set<WindowMetrics> getPossibleMaximumWindowMetrics(int displayId)", " static boolean hasWindowExtensionsEnabled()", "public void requestAppKeyboardShortcuts(final KeyboardShortcutsReceiver receiver, int deviceId)", " void requestImeKeyboardShortcuts(KeyboardShortcutsReceiver receiver, int deviceId)", "public Region getCurrentImeTouchRegion()", " void setShouldShowWithInsecureKeyguard(int displayId, boolean shouldShow)", " void setShouldShowSystemDecors(int displayId, boolean shouldShow)", " boolean shouldShowSystemDecors(int displayId)", " void setDisplayImePolicy(int displayId, @DisplayImePolicy int imePolicy)", " int getDisplayImePolicy(int displayId)", " boolean isGlobalKey(int keyCode)", " boolean isCrossWindowBlurEnabled()", " void addCrossWindowBlurEnabledListener(@NonNull Consumer<Boolean> listener)", " void addCrossWindowBlurEnabledListener(@NonNull @CallbackExecutor Executor executor, @NonNull Consumer<Boolean> listener)", " void removeCrossWindowBlurEnabledListener(@NonNull Consumer<Boolean> listener)", " void addProposedRotationListener(@NonNull @CallbackExecutor Executor executor, @NonNull IntConsumer listener)", " void removeProposedRotationListener(@NonNull IntConsumer listener)", " static String transitTypeToString(@TransitionType int type)", " static float fixScale(float scale)", " void holdLock(IBinder token, int durationMs)", " boolean isTaskSnapshotSupported()", " void registerTaskFpsCallback(@IntRange(from = 0) int taskId, @NonNull Executor executor, @NonNull TaskFpsCallback callback)", " void unregisterTaskFpsCallback(@NonNull TaskFpsCallback callback)", " Bitmap snapshotTaskForRecents(@IntRange(from = 0) int taskId)", " List<ComponentName> notifyScreenshotListeners(int displayId)", " boolean replaceContentOnDisplayWithMirror(int displayId, @NonNull Window window)", " boolean replaceContentOnDisplayWithSc(int displayId, @NonNull SurfaceControl sc)", " void registerTrustedPresentationListener(@NonNull IBinder window, @NonNull TrustedPresentationThresholds thresholds, @NonNull Executor executor, @NonNull Consumer<Boolean> listener)", " void unregisterTrustedPresentationListener(@NonNull Consumer<Boolean> listener)", " InputTransferToken registerBatchedSurfaceControlInputReceiver(@NonNull InputTransferToken hostInputTransferToken, @NonNull SurfaceControl surfaceControl, @NonNull Choreographer choreographer, @NonNull SurfaceControlInputReceiver receiver)", " InputTransferToken registerUnbatchedSurfaceControlInputReceiver(@NonNull InputTransferToken hostInputTransferToken, @NonNull SurfaceControl surfaceControl, @NonNull Looper looper, @NonNull SurfaceControlInputReceiver receiver)", " void unregisterSurfaceControlInputReceiver(@NonNull SurfaceControl surfaceControl)", " IBinder getSurfaceControlInputClientToken(@NonNull SurfaceControl surfaceControl)", " boolean transferTouchGesture(@NonNull InputTransferToken transferFromToken, @NonNull InputTransferToken transferToToken)", " IBinder getDefaultToken()", " int addScreenRecordingCallback(@NonNull @CallbackExecutor Executor executor, @NonNull Consumer<@ScreenRecordingState Integer> callback)", " void removeScreenRecordingCallback(@NonNull Consumer<@ScreenRecordingState Integer> callback)" ],
  "variableNames" : [ "DOCKED_INVALID", "DOCKED_LEFT", "DOCKED_TOP", "DOCKED_RIGHT", "DOCKED_BOTTOM", "INPUT_CONSUMER_PIP", "INPUT_CONSUMER_NAVIGATION", "INPUT_CONSUMER_WALLPAPER", "INPUT_CONSUMER_RECENTS_ANIMATION", "SHELL_ROOT_LAYER_DIVIDER", "SHELL_ROOT_LAYER_PIP", "TRANSIT_OLD_UNSET", "TRANSIT_OLD_NONE", "TRANSIT_OLD_ACTIVITY_OPEN", "TRANSIT_OLD_ACTIVITY_CLOSE", "TRANSIT_OLD_TASK_OPEN", "TRANSIT_OLD_TASK_CLOSE", "TRANSIT_OLD_TASK_TO_FRONT", "TRANSIT_OLD_TASK_TO_BACK", "TRANSIT_OLD_WALLPAPER_CLOSE", "TRANSIT_OLD_WALLPAPER_OPEN", "TRANSIT_OLD_WALLPAPER_INTRA_OPEN", "TRANSIT_OLD_WALLPAPER_INTRA_CLOSE", "TRANSIT_OLD_TASK_OPEN_BEHIND", "TRANSIT_OLD_ACTIVITY_RELAUNCH", "TRANSIT_OLD_KEYGUARD_GOING_AWAY", "TRANSIT_OLD_KEYGUARD_GOING_AWAY_ON_WALLPAPER", "TRANSIT_OLD_KEYGUARD_OCCLUDE", "TRANSIT_OLD_KEYGUARD_OCCLUDE_BY_DREAM", "TRANSIT_OLD_KEYGUARD_UNOCCLUDE", "TRANSIT_OLD_TRANSLUCENT_ACTIVITY_OPEN", "TRANSIT_OLD_TRANSLUCENT_ACTIVITY_CLOSE", "TRANSIT_OLD_CRASHING_ACTIVITY_CLOSE", "TRANSIT_OLD_TASK_CHANGE_WINDOWING_MODE", "TRANSIT_OLD_TASK_FRAGMENT_OPEN", "TRANSIT_OLD_TASK_FRAGMENT_CLOSE", "TRANSIT_OLD_TASK_FRAGMENT_CHANGE", "TRANSIT_OLD_DREAM_ACTIVITY_OPEN", "TRANSIT_OLD_DREAM_ACTIVITY_CLOSE", "TRANSIT_NONE", "TRANSIT_OPEN", "TRANSIT_CLOSE", "TRANSIT_TO_FRONT", "TRANSIT_TO_BACK", "TRANSIT_RELAUNCH", "TRANSIT_CHANGE", "TRANSIT_KEYGUARD_GOING_AWAY", "TRANSIT_KEYGUARD_OCCLUDE", "TRANSIT_KEYGUARD_UNOCCLUDE", "TRANSIT_PIP", "TRANSIT_WAKE", "TRANSIT_SLEEP", "TRANSIT_FIRST_CUSTOM", "TRANSIT_FLAG_KEYGUARD_GOING_AWAY_TO_SHADE", "TRANSIT_FLAG_KEYGUARD_GOING_AWAY_NO_ANIMATION", "TRANSIT_FLAG_KEYGUARD_GOING_AWAY_WITH_WALLPAPER", "TRANSIT_FLAG_KEYGUARD_GOING_AWAY_SUBTLE_ANIMATION", "TRANSIT_FLAG_APP_CRASHED", "TRANSIT_FLAG_OPEN_BEHIND", "TRANSIT_FLAG_KEYGUARD_LOCKED", "TRANSIT_FLAG_IS_RECENTS", "TRANSIT_FLAG_KEYGUARD_GOING_AWAY", "TRANSIT_FLAG_KEYGUARD_GOING_AWAY_TO_LAUNCHER_CLEAR_SNAPSHOT", "TRANSIT_FLAG_INVISIBLE", "TRANSIT_FLAG_KEYGUARD_APPEARING", "TRANSIT_FLAG_KEYGUARD_OCCLUDING", "TRANSIT_FLAG_KEYGUARD_UNOCCLUDING", "TRANSIT_FLAG_PHYSICAL_DISPLAY_SWITCH", "KEYGUARD_VISIBILITY_TRANSIT_FLAGS", "REMOVE_CONTENT_MODE_UNDEFINED", "REMOVE_CONTENT_MODE_MOVE_TO_PRIMARY", "REMOVE_CONTENT_MODE_DESTROY", "DISPLAY_IME_POLICY_LOCAL", "DISPLAY_IME_POLICY_FALLBACK_DISPLAY", "DISPLAY_IME_POLICY_HIDE", "TAKE_SCREENSHOT_FULLSCREEN", "TAKE_SCREENSHOT_PROVIDED_IMAGE", "LARGE_SCREEN_SMALLEST_SCREEN_WIDTH_DP", "PROPERTY_COMPAT_IGNORE_REQUESTED_ORIENTATION", "PROPERTY_COMPAT_ALLOW_IGNORING_ORIENTATION_REQUEST_WHEN_LOOP_DETECTED", "PROPERTY_COMPAT_ALLOW_SANDBOXING_VIEW_BOUNDS_APIS", "PROPERTY_COMPAT_ENABLE_FAKE_FOCUS", "PROPERTY_CAMERA_COMPAT_ALLOW_FORCE_ROTATION", "PROPERTY_CAMERA_COMPAT_ALLOW_REFRESH", "PROPERTY_CAMERA_COMPAT_ENABLE_REFRESH_VIA_PAUSE", "PROPERTY_COMPAT_ALLOW_ORIENTATION_OVERRIDE", "PROPERTY_COMPAT_ALLOW_DISPLAY_ORIENTATION_OVERRIDE", "PROPERTY_COMPAT_ALLOW_MIN_ASPECT_RATIO_OVERRIDE", "PROPERTY_COMPAT_ALLOW_RESIZEABLE_ACTIVITY_OVERRIDES", "PROPERTY_COMPAT_ALLOW_USER_ASPECT_RATIO_OVERRIDE", "PROPERTY_COMPAT_ALLOW_USER_ASPECT_RATIO_FULLSCREEN_OVERRIDE", "PARCEL_KEY_SHORTCUTS_ARRAY", "ACTIVITY_EMBEDDING_GUARD_WITH_ANDROID_15", "ENABLE_ACTIVITY_EMBEDDING_FOR_ANDROID_15", "HAS_WINDOW_EXTENSIONS_ON_DEVICE", "PROPERTY_ACTIVITY_EMBEDDING_ALLOW_SYSTEM_OVERRIDE", "PROPERTY_ALLOW_UNTRUSTED_ACTIVITY_EMBEDDING_STATE_SHARING", "PROPERTY_ACTIVITY_EMBEDDING_SPLITS_ENABLED", "PROPERTY_SUPPORTS_MULTI_INSTANCE_SYSTEM_UI", "PROPERTY_COMPAT_ALLOW_SMALL_COVER_SCREEN", "COMPAT_SMALL_COVER_SCREEN_OPT_IN", "SCREEN_RECORDING_STATE_NOT_VISIBLE", "SCREEN_RECORDING_STATE_VISIBLE" ]
}