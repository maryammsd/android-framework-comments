{
  "filePath" : "/home/maryam/clearblue/files/android-source-35/java/lang/Character.java",
  "packageName" : "java.lang",
  "className" : "Character",
  "comment" : "\n * The {@code Character} class wraps a value of the primitive\n * type {@code char} in an object. An object of class\n * {@code Character} contains a single field whose type is\n * {@code char}.\n * <p>\n * In addition, this class provides several methods for determining\n * a character's category (lowercase letter, digit, etc.) and for converting\n * characters from uppercase to lowercase and vice versa.\n * <p>\n * Character information is based on the Unicode Standard\n * <p>\n * The methods and data of class {@code Character} are defined by\n * the information in the <i>UnicodeData</i> file that is part of the\n * Unicode Character Database maintained by the Unicode\n * Consortium. This file specifies various properties including name\n * and general category for every defined Unicode code point or\n * character range.\n * <p>\n * The file and its description are available from the Unicode Consortium at:\n * <ul>\n * <li><a href=\"http://www.unicode.org\">http://www.unicode.org</a>\n * </ul>\n *\n * <h2><a id=\"conformance\">Unicode Conformance</a></h2>\n * <p>\n * The fields and methods of class {@code Character} are defined in terms\n * of character information from the Unicode Standard, specifically the\n * <i>UnicodeData</i> file that is part of the Unicode Character Database.\n * This file specifies properties including name and category for every\n * assigned Unicode code point or character range. The file is available\n * from the Unicode Consortium at\n * <a href=\"http://www.unicode.org\">http://www.unicode.org</a>.\n * <p>\n * Character information is based on the Unicode Standard, version 13.0.\n * <p>\n * The Java platform has supported different versions of the Unicode\n * Standard over time. Upgrades to newer versions of the Unicode Standard\n * occurred in the following Java releases, each indicating the new version:\n * <table class=\"striped\">\n * <caption style=\"display:none\">Shows Java releases and supported Unicode versions</caption>\n * <thead>\n * <tr><th scope=\"col\">Java release</th>\n *     <th scope=\"col\">Unicode version</th></tr>\n * </thead>\n * <tbody>\n * <tr><td>Java SE 15</td>\n *     <td>Unicode 13.0</td></tr>\n * <tr><td>Java SE 13</td>\n *     <td>Unicode 12.1</td></tr>\n * <tr><td>Java SE 12</td>\n *     <td>Unicode 11.0</td></tr>\n * <tr><td>Java SE 11</td>\n *     <td>Unicode 10.0</td></tr>\n * <tr><td>Java SE 9</td>\n *     <td>Unicode 8.0</td></tr>\n * <tr><td>Java SE 8</td>\n *     <td>Unicode 6.2</td></tr>\n * <tr><td>Java SE 7</td>\n *     <td>Unicode 6.0</td></tr>\n * <tr><td>Java SE 5.0</td>\n *     <td>Unicode 4.0</td></tr>\n * <tr><td>Java SE 1.4</td>\n *     <td>Unicode 3.0</td></tr>\n * <tr><td>JDK 1.1</td>\n *     <td>Unicode 2.0</td></tr>\n * <tr><td>JDK 1.0.2</td>\n *     <td>Unicode 1.1.5</td></tr>\n * </tbody>\n * </table>\n * Variations from these base Unicode versions, such as recognized appendixes,\n * are documented elsewhere.\n * <h2><a id=\"unicode\">Unicode Character Representations</a></h2>\n *\n * <p>The {@code char} data type (and therefore the value that a\n * {@code Character} object encapsulates) are based on the\n * original Unicode specification, which defined characters as\n * fixed-width 16-bit entities. The Unicode Standard has since been\n * changed to allow for characters whose representation requires more\n * than 16 bits.  The range of legal <em>code point</em>s is now\n * U+0000 to U+10FFFF, known as <em>Unicode scalar value</em>.\n * (Refer to the <a\n * href=\"http://www.unicode.org/reports/tr27/#notation\"><i>\n * definition</i></a> of the U+<i>n</i> notation in the Unicode\n * Standard.)\n *\n * <p><a id=\"BMP\">The set of characters from U+0000 to U+FFFF</a> is\n * sometimes referred to as the <em>Basic Multilingual Plane (BMP)</em>.\n * <a id=\"supplementary\">Characters</a> whose code points are greater\n * than U+FFFF are called <em>supplementary character</em>s.  The Java\n * platform uses the UTF-16 representation in {@code char} arrays and\n * in the {@code String} and {@code StringBuffer} classes. In\n * this representation, supplementary characters are represented as a pair\n * of {@code char} values, the first from the <em>high-surrogates</em>\n * range, (&#92;uD800-&#92;uDBFF), the second from the\n * <em>low-surrogates</em> range (&#92;uDC00-&#92;uDFFF).\n *\n * <p>A {@code char} value, therefore, represents Basic\n * Multilingual Plane (BMP) code points, including the surrogate\n * code points, or code units of the UTF-16 encoding. An\n * {@code int} value represents all Unicode code points,\n * including supplementary code points. The lower (least significant)\n * 21 bits of {@code int} are used to represent Unicode code\n * points and the upper (most significant) 11 bits must be zero.\n * Unless otherwise specified, the behavior with respect to\n * supplementary characters and surrogate {@code char} values is\n * as follows:\n *\n * <ul>\n * <li>The methods that only accept a {@code char} value cannot support\n * supplementary characters. They treat {@code char} values from the\n * surrogate ranges as undefined characters. For example,\n * {@code Character.isLetter('\\u005CuD840')} returns {@code false}, even though\n * this specific value if followed by any low-surrogate value in a string\n * would represent a letter.\n *\n * <li>The methods that accept an {@code int} value support all\n * Unicode characters, including supplementary characters. For\n * example, {@code Character.isLetter(0x2F81A)} returns\n * {@code true} because the code point value represents a letter\n * (a CJK ideograph).\n * </ul>\n *\n * <p>In the Java SE API documentation, <em>Unicode code point</em> is\n * used for character values in the range between U+0000 and U+10FFFF,\n * and <em>Unicode code unit</em> is used for 16-bit\n * {@code char} values that are code units of the <em>UTF-16</em>\n * encoding. For more information on Unicode terminology, refer to the\n * <a href=\"http://www.unicode.org/glossary/\">Unicode Glossary</a>.\n *\n * <!-- Android-removed: paragraph on ValueBased\n * <p>This is a <a href=\"{@docRoot}/java.base/java/lang/doc-files/ValueBased.html\">value-based</a>\n * class; programmers should treat instances that are\n * {@linkplain #equals(Object) equal} as interchangeable and should not\n * use instances for synchronization, or unpredictable behavior may\n * occur. For example, in a future release, synchronization may fail.\n * -->\n *\n * @author  Lee Boynton\n * @author  Guy Steele\n * @author  Akira Tanaka\n * @author  Martin Buchholz\n * @author  Ulf Zibis\n * @since   1.0\n ",
  "links" : [ ],
  "variables" : [ {
    "name" : "MIN_RADIX",
    "type" : "int",
    "comment" : "\n     * The minimum radix available for conversion to and from strings.\n     * The constant value of this field is the smallest value permitted\n     * for the radix argument in radix-conversion methods such as the\n     * {@code digit} method, the {@code forDigit} method, and the\n     * {@code toString} method of class {@code Integer}.\n     *\n     * @see     Character#digit(char, int)\n     * @see     Character#forDigit(int, int)\n     * @see     Integer#toString(int, int)\n     * @see     Integer#valueOf(String)\n     ",
    "links" : [ ]
  }, {
    "name" : "MAX_RADIX",
    "type" : "int",
    "comment" : "\n     * The maximum radix available for conversion to and from strings.\n     * The constant value of this field is the largest value permitted\n     * for the radix argument in radix-conversion methods such as the\n     * {@code digit} method, the {@code forDigit} method, and the\n     * {@code toString} method of class {@code Integer}.\n     *\n     * @see     Character#digit(char, int)\n     * @see     Character#forDigit(int, int)\n     * @see     Integer#toString(int, int)\n     * @see     Integer#valueOf(String)\n     ",
    "links" : [ ]
  }, {
    "name" : "MIN_VALUE",
    "type" : "char",
    "comment" : "\n     * The constant value of this field is the smallest value of type\n     * {@code char}, {@code '\\u005Cu0000'}.\n     *\n     * @since   1.0.2\n     ",
    "links" : [ ]
  }, {
    "name" : "MAX_VALUE",
    "type" : "char",
    "comment" : "\n     * The constant value of this field is the largest value of type\n     * {@code char}, {@code '\\u005CuFFFF'}.\n     *\n     * @since   1.0.2\n     ",
    "links" : [ ]
  }, {
    "name" : "TYPE",
    "type" : "Class<Character>",
    "comment" : "\n     * The {@code Class} instance representing the primitive type\n     * {@code char}.\n     *\n     * @since   1.1\n     ",
    "links" : [ ]
  }, {
    "name" : "UNASSIGNED",
    "type" : "byte",
    "comment" : "\n     * General category \"Cn\" in the Unicode specification.\n     * @since   1.1\n     ",
    "links" : [ ]
  }, {
    "name" : "UPPERCASE_LETTER",
    "type" : "byte",
    "comment" : "\n     * General category \"Lu\" in the Unicode specification.\n     * @since   1.1\n     ",
    "links" : [ ]
  }, {
    "name" : "LOWERCASE_LETTER",
    "type" : "byte",
    "comment" : "\n     * General category \"Ll\" in the Unicode specification.\n     * @since   1.1\n     ",
    "links" : [ ]
  }, {
    "name" : "TITLECASE_LETTER",
    "type" : "byte",
    "comment" : "\n     * General category \"Lt\" in the Unicode specification.\n     * @since   1.1\n     ",
    "links" : [ ]
  }, {
    "name" : "MODIFIER_LETTER",
    "type" : "byte",
    "comment" : "\n     * General category \"Lm\" in the Unicode specification.\n     * @since   1.1\n     ",
    "links" : [ ]
  }, {
    "name" : "OTHER_LETTER",
    "type" : "byte",
    "comment" : "\n     * General category \"Lo\" in the Unicode specification.\n     * @since   1.1\n     ",
    "links" : [ ]
  }, {
    "name" : "NON_SPACING_MARK",
    "type" : "byte",
    "comment" : "\n     * General category \"Mn\" in the Unicode specification.\n     * @since   1.1\n     ",
    "links" : [ ]
  }, {
    "name" : "ENCLOSING_MARK",
    "type" : "byte",
    "comment" : "\n     * General category \"Me\" in the Unicode specification.\n     * @since   1.1\n     ",
    "links" : [ ]
  }, {
    "name" : "COMBINING_SPACING_MARK",
    "type" : "byte",
    "comment" : "\n     * General category \"Mc\" in the Unicode specification.\n     * @since   1.1\n     ",
    "links" : [ ]
  }, {
    "name" : "DECIMAL_DIGIT_NUMBER",
    "type" : "byte",
    "comment" : "\n     * General category \"Nd\" in the Unicode specification.\n     * @since   1.1\n     ",
    "links" : [ ]
  }, {
    "name" : "LETTER_NUMBER",
    "type" : "byte",
    "comment" : "\n     * General category \"Nl\" in the Unicode specification.\n     * @since   1.1\n     ",
    "links" : [ ]
  }, {
    "name" : "OTHER_NUMBER",
    "type" : "byte",
    "comment" : "\n     * General category \"No\" in the Unicode specification.\n     * @since   1.1\n     ",
    "links" : [ ]
  }, {
    "name" : "SPACE_SEPARATOR",
    "type" : "byte",
    "comment" : "\n     * General category \"Zs\" in the Unicode specification.\n     * @since   1.1\n     ",
    "links" : [ ]
  }, {
    "name" : "LINE_SEPARATOR",
    "type" : "byte",
    "comment" : "\n     * General category \"Zl\" in the Unicode specification.\n     * @since   1.1\n     ",
    "links" : [ ]
  }, {
    "name" : "PARAGRAPH_SEPARATOR",
    "type" : "byte",
    "comment" : "\n     * General category \"Zp\" in the Unicode specification.\n     * @since   1.1\n     ",
    "links" : [ ]
  }, {
    "name" : "CONTROL",
    "type" : "byte",
    "comment" : "\n     * General category \"Cc\" in the Unicode specification.\n     * @since   1.1\n     ",
    "links" : [ ]
  }, {
    "name" : "FORMAT",
    "type" : "byte",
    "comment" : "\n     * General category \"Cf\" in the Unicode specification.\n     * @since   1.1\n     ",
    "links" : [ ]
  }, {
    "name" : "PRIVATE_USE",
    "type" : "byte",
    "comment" : "\n     * General category \"Co\" in the Unicode specification.\n     * @since   1.1\n     ",
    "links" : [ ]
  }, {
    "name" : "SURROGATE",
    "type" : "byte",
    "comment" : "\n     * General category \"Cs\" in the Unicode specification.\n     * @since   1.1\n     ",
    "links" : [ ]
  }, {
    "name" : "DASH_PUNCTUATION",
    "type" : "byte",
    "comment" : "\n     * General category \"Pd\" in the Unicode specification.\n     * @since   1.1\n     ",
    "links" : [ ]
  }, {
    "name" : "START_PUNCTUATION",
    "type" : "byte",
    "comment" : "\n     * General category \"Ps\" in the Unicode specification.\n     * @since   1.1\n     ",
    "links" : [ ]
  }, {
    "name" : "END_PUNCTUATION",
    "type" : "byte",
    "comment" : "\n     * General category \"Pe\" in the Unicode specification.\n     * @since   1.1\n     ",
    "links" : [ ]
  }, {
    "name" : "CONNECTOR_PUNCTUATION",
    "type" : "byte",
    "comment" : "\n     * General category \"Pc\" in the Unicode specification.\n     * @since   1.1\n     ",
    "links" : [ ]
  }, {
    "name" : "OTHER_PUNCTUATION",
    "type" : "byte",
    "comment" : "\n     * General category \"Po\" in the Unicode specification.\n     * @since   1.1\n     ",
    "links" : [ ]
  }, {
    "name" : "MATH_SYMBOL",
    "type" : "byte",
    "comment" : "\n     * General category \"Sm\" in the Unicode specification.\n     * @since   1.1\n     ",
    "links" : [ ]
  }, {
    "name" : "CURRENCY_SYMBOL",
    "type" : "byte",
    "comment" : "\n     * General category \"Sc\" in the Unicode specification.\n     * @since   1.1\n     ",
    "links" : [ ]
  }, {
    "name" : "MODIFIER_SYMBOL",
    "type" : "byte",
    "comment" : "\n     * General category \"Sk\" in the Unicode specification.\n     * @since   1.1\n     ",
    "links" : [ ]
  }, {
    "name" : "OTHER_SYMBOL",
    "type" : "byte",
    "comment" : "\n     * General category \"So\" in the Unicode specification.\n     * @since   1.1\n     ",
    "links" : [ ]
  }, {
    "name" : "INITIAL_QUOTE_PUNCTUATION",
    "type" : "byte",
    "comment" : "\n     * General category \"Pi\" in the Unicode specification.\n     * @since   1.4\n     ",
    "links" : [ ]
  }, {
    "name" : "FINAL_QUOTE_PUNCTUATION",
    "type" : "byte",
    "comment" : "\n     * General category \"Pf\" in the Unicode specification.\n     * @since   1.4\n     ",
    "links" : [ ]
  }, {
    "name" : "ERROR",
    "type" : "int",
    "comment" : "\n     * Error flag. Use int (code point) to avoid confusion with U+FFFF.\n     ",
    "links" : [ ]
  }, {
    "name" : "DIRECTIONALITY_UNDEFINED",
    "type" : "byte",
    "comment" : "\n     * Undefined bidirectional character type. Undefined {@code char}\n     * values have undefined directionality in the Unicode specification.\n     * @since 1.4\n     ",
    "links" : [ ]
  }, {
    "name" : "DIRECTIONALITY_LEFT_TO_RIGHT",
    "type" : "byte",
    "comment" : "\n     * Strong bidirectional character type \"L\" in the Unicode specification.\n     * @since 1.4\n     ",
    "links" : [ ]
  }, {
    "name" : "DIRECTIONALITY_RIGHT_TO_LEFT",
    "type" : "byte",
    "comment" : "\n     * Strong bidirectional character type \"R\" in the Unicode specification.\n     * @since 1.4\n     ",
    "links" : [ ]
  }, {
    "name" : "DIRECTIONALITY_RIGHT_TO_LEFT_ARABIC",
    "type" : "byte",
    "comment" : "\n     * Strong bidirectional character type \"AL\" in the Unicode specification.\n     * @since 1.4\n     ",
    "links" : [ ]
  }, {
    "name" : "DIRECTIONALITY_EUROPEAN_NUMBER",
    "type" : "byte",
    "comment" : "\n     * Weak bidirectional character type \"EN\" in the Unicode specification.\n     * @since 1.4\n     ",
    "links" : [ ]
  }, {
    "name" : "DIRECTIONALITY_EUROPEAN_NUMBER_SEPARATOR",
    "type" : "byte",
    "comment" : "\n     * Weak bidirectional character type \"ES\" in the Unicode specification.\n     * @since 1.4\n     ",
    "links" : [ ]
  }, {
    "name" : "DIRECTIONALITY_EUROPEAN_NUMBER_TERMINATOR",
    "type" : "byte",
    "comment" : "\n     * Weak bidirectional character type \"ET\" in the Unicode specification.\n     * @since 1.4\n     ",
    "links" : [ ]
  }, {
    "name" : "DIRECTIONALITY_ARABIC_NUMBER",
    "type" : "byte",
    "comment" : "\n     * Weak bidirectional character type \"AN\" in the Unicode specification.\n     * @since 1.4\n     ",
    "links" : [ ]
  }, {
    "name" : "DIRECTIONALITY_COMMON_NUMBER_SEPARATOR",
    "type" : "byte",
    "comment" : "\n     * Weak bidirectional character type \"CS\" in the Unicode specification.\n     * @since 1.4\n     ",
    "links" : [ ]
  }, {
    "name" : "DIRECTIONALITY_NONSPACING_MARK",
    "type" : "byte",
    "comment" : "\n     * Weak bidirectional character type \"NSM\" in the Unicode specification.\n     * @since 1.4\n     ",
    "links" : [ ]
  }, {
    "name" : "DIRECTIONALITY_BOUNDARY_NEUTRAL",
    "type" : "byte",
    "comment" : "\n     * Weak bidirectional character type \"BN\" in the Unicode specification.\n     * @since 1.4\n     ",
    "links" : [ ]
  }, {
    "name" : "DIRECTIONALITY_PARAGRAPH_SEPARATOR",
    "type" : "byte",
    "comment" : "\n     * Neutral bidirectional character type \"B\" in the Unicode specification.\n     * @since 1.4\n     ",
    "links" : [ ]
  }, {
    "name" : "DIRECTIONALITY_SEGMENT_SEPARATOR",
    "type" : "byte",
    "comment" : "\n     * Neutral bidirectional character type \"S\" in the Unicode specification.\n     * @since 1.4\n     ",
    "links" : [ ]
  }, {
    "name" : "DIRECTIONALITY_WHITESPACE",
    "type" : "byte",
    "comment" : "\n     * Neutral bidirectional character type \"WS\" in the Unicode specification.\n     * @since 1.4\n     ",
    "links" : [ ]
  }, {
    "name" : "DIRECTIONALITY_OTHER_NEUTRALS",
    "type" : "byte",
    "comment" : "\n     * Neutral bidirectional character type \"ON\" in the Unicode specification.\n     * @since 1.4\n     ",
    "links" : [ ]
  }, {
    "name" : "DIRECTIONALITY_LEFT_TO_RIGHT_EMBEDDING",
    "type" : "byte",
    "comment" : "\n     * Strong bidirectional character type \"LRE\" in the Unicode specification.\n     * @since 1.4\n     ",
    "links" : [ ]
  }, {
    "name" : "DIRECTIONALITY_LEFT_TO_RIGHT_OVERRIDE",
    "type" : "byte",
    "comment" : "\n     * Strong bidirectional character type \"LRO\" in the Unicode specification.\n     * @since 1.4\n     ",
    "links" : [ ]
  }, {
    "name" : "DIRECTIONALITY_RIGHT_TO_LEFT_EMBEDDING",
    "type" : "byte",
    "comment" : "\n     * Strong bidirectional character type \"RLE\" in the Unicode specification.\n     * @since 1.4\n     ",
    "links" : [ ]
  }, {
    "name" : "DIRECTIONALITY_RIGHT_TO_LEFT_OVERRIDE",
    "type" : "byte",
    "comment" : "\n     * Strong bidirectional character type \"RLO\" in the Unicode specification.\n     * @since 1.4\n     ",
    "links" : [ ]
  }, {
    "name" : "DIRECTIONALITY_POP_DIRECTIONAL_FORMAT",
    "type" : "byte",
    "comment" : "\n     * Weak bidirectional character type \"PDF\" in the Unicode specification.\n     * @since 1.4\n     ",
    "links" : [ ]
  }, {
    "name" : "DIRECTIONALITY_LEFT_TO_RIGHT_ISOLATE",
    "type" : "byte",
    "comment" : "\n     * Weak bidirectional character type \"LRI\" in the Unicode specification.\n     * @since 9\n     ",
    "links" : [ ]
  }, {
    "name" : "DIRECTIONALITY_RIGHT_TO_LEFT_ISOLATE",
    "type" : "byte",
    "comment" : "\n     * Weak bidirectional character type \"RLI\" in the Unicode specification.\n     * @since 9\n     ",
    "links" : [ ]
  }, {
    "name" : "DIRECTIONALITY_FIRST_STRONG_ISOLATE",
    "type" : "byte",
    "comment" : "\n     * Weak bidirectional character type \"FSI\" in the Unicode specification.\n     * @since 9\n     ",
    "links" : [ ]
  }, {
    "name" : "DIRECTIONALITY_POP_DIRECTIONAL_ISOLATE",
    "type" : "byte",
    "comment" : "\n     * Weak bidirectional character type \"PDI\" in the Unicode specification.\n     * @since 9\n     ",
    "links" : [ ]
  }, {
    "name" : "MIN_HIGH_SURROGATE",
    "type" : "char",
    "comment" : "\n     * The minimum value of a\n     * <a href=\"http://www.unicode.org/glossary/#high_surrogate_code_unit\">\n     * Unicode high-surrogate code unit</a>\n     * in the UTF-16 encoding, constant {@code '\\u005CuD800'}.\n     * A high-surrogate is also known as a <i>leading-surrogate</i>.\n     *\n     * @since 1.5\n     ",
    "links" : [ ]
  }, {
    "name" : "MAX_HIGH_SURROGATE",
    "type" : "char",
    "comment" : "\n     * The maximum value of a\n     * <a href=\"http://www.unicode.org/glossary/#high_surrogate_code_unit\">\n     * Unicode high-surrogate code unit</a>\n     * in the UTF-16 encoding, constant {@code '\\u005CuDBFF'}.\n     * A high-surrogate is also known as a <i>leading-surrogate</i>.\n     *\n     * @since 1.5\n     ",
    "links" : [ ]
  }, {
    "name" : "MIN_LOW_SURROGATE",
    "type" : "char",
    "comment" : "\n     * The minimum value of a\n     * <a href=\"http://www.unicode.org/glossary/#low_surrogate_code_unit\">\n     * Unicode low-surrogate code unit</a>\n     * in the UTF-16 encoding, constant {@code '\\u005CuDC00'}.\n     * A low-surrogate is also known as a <i>trailing-surrogate</i>.\n     *\n     * @since 1.5\n     ",
    "links" : [ ]
  }, {
    "name" : "MAX_LOW_SURROGATE",
    "type" : "char",
    "comment" : "\n     * The maximum value of a\n     * <a href=\"http://www.unicode.org/glossary/#low_surrogate_code_unit\">\n     * Unicode low-surrogate code unit</a>\n     * in the UTF-16 encoding, constant {@code '\\u005CuDFFF'}.\n     * A low-surrogate is also known as a <i>trailing-surrogate</i>.\n     *\n     * @since 1.5\n     ",
    "links" : [ ]
  }, {
    "name" : "MIN_SURROGATE",
    "type" : "char",
    "comment" : "\n     * The minimum value of a Unicode surrogate code unit in the\n     * UTF-16 encoding, constant {@code '\\u005CuD800'}.\n     *\n     * @since 1.5\n     ",
    "links" : [ ]
  }, {
    "name" : "MAX_SURROGATE",
    "type" : "char",
    "comment" : "\n     * The maximum value of a Unicode surrogate code unit in the\n     * UTF-16 encoding, constant {@code '\\u005CuDFFF'}.\n     *\n     * @since 1.5\n     ",
    "links" : [ ]
  }, {
    "name" : "MIN_SUPPLEMENTARY_CODE_POINT",
    "type" : "int",
    "comment" : "\n     * The minimum value of a\n     * <a href=\"http://www.unicode.org/glossary/#supplementary_code_point\">\n     * Unicode supplementary code point</a>, constant {@code U+10000}.\n     *\n     * @since 1.5\n     ",
    "links" : [ ]
  }, {
    "name" : "MIN_CODE_POINT",
    "type" : "int",
    "comment" : "\n     * The minimum value of a\n     * <a href=\"http://www.unicode.org/glossary/#code_point\">\n     * Unicode code point</a>, constant {@code U+0000}.\n     *\n     * @since 1.5\n     ",
    "links" : [ ]
  }, {
    "name" : "MAX_CODE_POINT",
    "type" : "int",
    "comment" : "\n     * The maximum value of a\n     * <a href=\"http://www.unicode.org/glossary/#code_point\">\n     * Unicode code point</a>, constant {@code U+10FFFF}.\n     *\n     * @since 1.5\n     ",
    "links" : [ ]
  }, {
    "name" : "DIRECTIONALITY",
    "type" : "byte[]",
    "comment" : " accessed via getDirectionalityImpl(), implemented in Character.cpp.",
    "links" : [ ]
  }, {
    "name" : "value",
    "type" : "char",
    "comment" : "\n     * The value of the {@code Character}.\n     *\n     * @serial\n     ",
    "links" : [ ]
  }, {
    "name" : "serialVersionUID",
    "type" : "long",
    "comment" : " use serialVersionUID from JDK 1.0.2 for interoperability ",
    "links" : [ ]
  }, {
    "name" : "SIZE",
    "type" : "int",
    "comment" : "\n     * The number of bits used to represent a {@code char} value in unsigned\n     * binary form, constant {@code 16}.\n     *\n     * @since 1.5\n     ",
    "links" : [ ]
  }, {
    "name" : "BYTES",
    "type" : "int",
    "comment" : "\n     * The number of bytes used to represent a {@code char} value in unsigned\n     * binary form.\n     *\n     * @since 1.8\n     ",
    "links" : [ ]
  } ],
  "methods" : [ {
    "name" : "public Optional<DynamicConstantDesc<Character>> describeConstable()",
    "returnType" : "Optional<DynamicConstantDesc<Character>>",
    "comment" : "\n     * Returns an {@link Optional} containing the nominal descriptor for this\n     * instance.\n     *\n     * @return an {@link Optional} describing the {@linkplain Character} instance\n     * @since 15\n     * @hide\n     ",
    "links" : [ "java.util.Optional" ]
  }, {
    "name" : "public static Character valueOf(char c)",
    "returnType" : "Character",
    "comment" : "\n     * Returns a {@code Character} instance representing the specified\n     * {@code char} value.\n     * If a new {@code Character} instance is not required, this method\n     * should generally be used in preference to the constructor\n     * {@link #Character(char)}, as this method is likely to yield\n     * significantly better space and time performance by caching\n     * frequently requested values.\n     *\n     * This method will always cache values in the range {@code\n     * '\\u005Cu0000'} to {@code '\\u005Cu007F'}, inclusive, and may\n     * cache other values outside of this range.\n     *\n     * @param  c a char value.\n     * @return a {@code Character} instance representing {@code c}.\n     * @since  1.5\n     ",
    "links" : [ "#Character(char)" ]
  }, {
    "name" : "public char charValue()",
    "returnType" : "char",
    "comment" : "\n     * Returns the value of this {@code Character} object.\n     * @return  the primitive {@code char} value represented by\n     *          this object.\n     ",
    "links" : [ ]
  }, {
    "name" : "public int hashCode()",
    "returnType" : "int",
    "comment" : "\n     * Returns a hash code for this {@code Character}; equal to the result\n     * of invoking {@code charValue()}.\n     *\n     * @return a hash code value for this {@code Character}\n     ",
    "links" : [ ]
  }, {
    "name" : "public static int hashCode(char value)",
    "returnType" : "int",
    "comment" : "\n     * Returns a hash code for a {@code char} value; compatible with\n     * {@code Character.hashCode()}.\n     *\n     * @since 1.8\n     *\n     * @param value The {@code char} for which to return a hash code.\n     * @return a hash code value for a {@code char} value.\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean equals(Object obj)",
    "returnType" : "boolean",
    "comment" : "\n     * Compares this object against the specified object.\n     * The result is {@code true} if and only if the argument is not\n     * {@code null} and is a {@code Character} object that\n     * represents the same {@code char} value as this object.\n     *\n     * @param   obj   the object to compare with.\n     * @return  {@code true} if the objects are the same;\n     *          {@code false} otherwise.\n     ",
    "links" : [ ]
  }, {
    "name" : "public String toString()",
    "returnType" : "String",
    "comment" : "\n     * Returns a {@code String} object representing this\n     * {@code Character}'s value.  The result is a string of\n     * length 1 whose sole component is the primitive\n     * {@code char} value represented by this\n     * {@code Character} object.\n     *\n     * @return  a string representation of this object.\n     ",
    "links" : [ ]
  }, {
    "name" : "public static String toString(char c)",
    "returnType" : "String",
    "comment" : "\n     * Returns a {@code String} object representing the\n     * specified {@code char}.  The result is a string of length\n     * 1 consisting solely of the specified {@code char}.\n     *\n     * @param c the {@code char} to be converted\n     * @return the string representation of the specified {@code char}\n     * @since 1.4\n     ",
    "links" : [ ]
  }, {
    "name" : "public static String toString(int codePoint)",
    "returnType" : "String",
    "comment" : "\n     * Returns a {@code String} object representing the\n     * specified character (Unicode code point).  The result is a string of\n     * length 1 or 2, consisting solely of the specified {@code codePoint}.\n     *\n     * @param codePoint the {@code codePoint} to be converted\n     * @return the string representation of the specified {@code codePoint}\n     * @throws IllegalArgumentException if the specified\n     *      {@code codePoint} is not a {@linkplain #isValidCodePoint\n     *      valid Unicode code point}.\n     * @since 11\n     ",
    "links" : [ ]
  }, {
    "name" : "public static boolean isValidCodePoint(int codePoint)",
    "returnType" : "boolean",
    "comment" : "\n     * Determines whether the specified code point is a valid\n     * <a href=\"http://www.unicode.org/glossary/#code_point\">\n     * Unicode code point value</a>.\n     *\n     * @param  codePoint the Unicode code point to be tested\n     * @return {@code true} if the specified code point value is between\n     *         {@link #MIN_CODE_POINT} and\n     *         {@link #MAX_CODE_POINT} inclusive;\n     *         {@code false} otherwise.\n     * @since  1.5\n     ",
    "links" : [ "#MIN_CODE_POINT", "#MAX_CODE_POINT" ]
  }, {
    "name" : "public static boolean isBmpCodePoint(int codePoint)",
    "returnType" : "boolean",
    "comment" : "\n     * Determines whether the specified character (Unicode code point)\n     * is in the <a href=\"#BMP\">Basic Multilingual Plane (BMP)</a>.\n     * Such code points can be represented using a single {@code char}.\n     *\n     * @param  codePoint the character (Unicode code point) to be to\n     * @return {@code true} if the specified code point is between\n     *         {@link #MIN_VALUE} and {@link #MAX_VALUE} inclusive;\n     *         {@code false} otherwise.\n     * @since  1.7\n     ",
    "links" : [ "#MIN_VALUE", "#MAX_VALUE" ]
  }, {
    "name" : "public static boolean isSupplementaryCodePoint(int codePoint)",
    "returnType" : "boolean",
    "comment" : "\n     * Determines whether the specified character (Unicode code point)\n     * is in the <a href=\"#supplementary\">supplementary character</a> range.\n     *\n     * @param  codePoint the character (Unicode code point) to be tested\n     * @return {@code true} if the specified code point is between\n     *         {@link #MIN_SUPPLEMENTARY_CODE_POINT} and\n     *         {@link #MAX_CODE_POINT} inclusive;\n     *         {@code false} otherwise.\n     * @since  1.5\n     ",
    "links" : [ "#MIN_SUPPLEMENTARY_CODE_POINT", "#MAX_CODE_POINT" ]
  }, {
    "name" : "public static boolean isHighSurrogate(char ch)",
    "returnType" : "boolean",
    "comment" : "\n     * Determines if the given {@code char} value is a\n     * <a href=\"http://www.unicode.org/glossary/#high_surrogate_code_unit\">\n     * Unicode high-surrogate code unit</a>\n     * (also known as <i>leading-surrogate code unit</i>).\n     *\n     * <p>Such values do not represent characters by themselves,\n     * but are used in the representation of\n     * <a href=\"#supplementary\">supplementary characters</a>\n     * in the UTF-16 encoding.\n     *\n     * @param  ch the {@code char} value to be tested.\n     * @return {@code true} if the {@code char} value is between\n     *         {@link #MIN_HIGH_SURROGATE} and\n     *         {@link #MAX_HIGH_SURROGATE} inclusive;\n     *         {@code false} otherwise.\n     * @see    Character#isLowSurrogate(char)\n     * @see    Character.UnicodeBlock#of(int)\n     * @since  1.5\n     ",
    "links" : [ "#MIN_HIGH_SURROGATE", "#MAX_HIGH_SURROGATE" ]
  }, {
    "name" : "public static boolean isLowSurrogate(char ch)",
    "returnType" : "boolean",
    "comment" : "\n     * Determines if the given {@code char} value is a\n     * <a href=\"http://www.unicode.org/glossary/#low_surrogate_code_unit\">\n     * Unicode low-surrogate code unit</a>\n     * (also known as <i>trailing-surrogate code unit</i>).\n     *\n     * <p>Such values do not represent characters by themselves,\n     * but are used in the representation of\n     * <a href=\"#supplementary\">supplementary characters</a>\n     * in the UTF-16 encoding.\n     *\n     * @param  ch the {@code char} value to be tested.\n     * @return {@code true} if the {@code char} value is between\n     *         {@link #MIN_LOW_SURROGATE} and\n     *         {@link #MAX_LOW_SURROGATE} inclusive;\n     *         {@code false} otherwise.\n     * @see    Character#isHighSurrogate(char)\n     * @since  1.5\n     ",
    "links" : [ "#MAX_LOW_SURROGATE", "#MIN_LOW_SURROGATE" ]
  }, {
    "name" : "public static boolean isSurrogate(char ch)",
    "returnType" : "boolean",
    "comment" : "\n     * Determines if the given {@code char} value is a Unicode\n     * <i>surrogate code unit</i>.\n     *\n     * <p>Such values do not represent characters by themselves,\n     * but are used in the representation of\n     * <a href=\"#supplementary\">supplementary characters</a>\n     * in the UTF-16 encoding.\n     *\n     * <p>A char value is a surrogate code unit if and only if it is either\n     * a {@linkplain #isLowSurrogate(char) low-surrogate code unit} or\n     * a {@linkplain #isHighSurrogate(char) high-surrogate code unit}.\n     *\n     * @param  ch the {@code char} value to be tested.\n     * @return {@code true} if the {@code char} value is between\n     *         {@link #MIN_SURROGATE} and\n     *         {@link #MAX_SURROGATE} inclusive;\n     *         {@code false} otherwise.\n     * @since  1.7\n     ",
    "links" : [ "#MIN_SURROGATE", "#MAX_SURROGATE" ]
  }, {
    "name" : "public static boolean isSurrogatePair(char high, char low)",
    "returnType" : "boolean",
    "comment" : "\n     * Determines whether the specified pair of {@code char}\n     * values is a valid\n     * <a href=\"http://www.unicode.org/glossary/#surrogate_pair\">\n     * Unicode surrogate pair</a>.\n     *\n     * <p>This method is equivalent to the expression:\n     * <blockquote><pre>{@code\n     * isHighSurrogate(high) && isLowSurrogate(low)\n     * }</pre></blockquote>\n     *\n     * @param  high the high-surrogate code value to be tested\n     * @param  low the low-surrogate code value to be tested\n     * @return {@code true} if the specified high and\n     * low-surrogate code values represent a valid surrogate pair;\n     * {@code false} otherwise.\n     * @since  1.5\n     ",
    "links" : [ ]
  }, {
    "name" : "public static int charCount(int codePoint)",
    "returnType" : "int",
    "comment" : "\n     * Determines the number of {@code char} values needed to\n     * represent the specified character (Unicode code point). If the\n     * specified character is equal to or greater than 0x10000, then\n     * the method returns 2. Otherwise, the method returns 1.\n     *\n     * <p>This method doesn't validate the specified character to be a\n     * valid Unicode code point. The caller must validate the\n     * character value using {@link #isValidCodePoint(int) isValidCodePoint}\n     * if necessary.\n     *\n     * @param   codePoint the character (Unicode code point) to be tested.\n     * @return  2 if the character is a valid supplementary character; 1 otherwise.\n     * @see     Character#isSupplementaryCodePoint(int)\n     * @since   1.5\n     ",
    "links" : [ "#isValidCodePoint(int)" ]
  }, {
    "name" : "public static int toCodePoint(char high, char low)",
    "returnType" : "int",
    "comment" : "\n     * Converts the specified surrogate pair to its supplementary code\n     * point value. This method does not validate the specified\n     * surrogate pair. The caller must validate it using {@link\n     * #isSurrogatePair(char, char) isSurrogatePair} if necessary.\n     *\n     * @param  high the high-surrogate code unit\n     * @param  low the low-surrogate code unit\n     * @return the supplementary code point composed from the\n     *         specified surrogate pair.\n     * @since  1.5\n     ",
    "links" : [ "#isSurrogatePair(char" ]
  }, {
    "name" : "public static int codePointAt(CharSequence seq, int index)",
    "returnType" : "int",
    "comment" : "\n     * Returns the code point at the given index of the\n     * {@code CharSequence}. If the {@code char} value at\n     * the given index in the {@code CharSequence} is in the\n     * high-surrogate range, the following index is less than the\n     * length of the {@code CharSequence}, and the\n     * {@code char} value at the following index is in the\n     * low-surrogate range, then the supplementary code point\n     * corresponding to this surrogate pair is returned. Otherwise,\n     * the {@code char} value at the given index is returned.\n     *\n     * @param seq a sequence of {@code char} values (Unicode code\n     * units)\n     * @param index the index to the {@code char} values (Unicode\n     * code units) in {@code seq} to be converted\n     * @return the Unicode code point at the given index\n     * @throws NullPointerException if {@code seq} is null.\n     * @throws IndexOutOfBoundsException if the value\n     * {@code index} is negative or not less than\n     * {@link CharSequence#length() seq.length()}.\n     * @since  1.5\n     ",
    "links" : [ "java.lang.CharSequence#length()" ]
  }, {
    "name" : "public static int codePointAt(char[] a, int index)",
    "returnType" : "int",
    "comment" : "\n     * Returns the code point at the given index of the\n     * {@code char} array. If the {@code char} value at\n     * the given index in the {@code char} array is in the\n     * high-surrogate range, the following index is less than the\n     * length of the {@code char} array, and the\n     * {@code char} value at the following index is in the\n     * low-surrogate range, then the supplementary code point\n     * corresponding to this surrogate pair is returned. Otherwise,\n     * the {@code char} value at the given index is returned.\n     *\n     * @param a the {@code char} array\n     * @param index the index to the {@code char} values (Unicode\n     * code units) in the {@code char} array to be converted\n     * @return the Unicode code point at the given index\n     * @throws NullPointerException if {@code a} is null.\n     * @throws IndexOutOfBoundsException if the value\n     * {@code index} is negative or not less than\n     * the length of the {@code char} array.\n     * @since  1.5\n     ",
    "links" : [ ]
  }, {
    "name" : "public static int codePointAt(char[] a, int index, int limit)",
    "returnType" : "int",
    "comment" : "\n     * Returns the code point at the given index of the\n     * {@code char} array, where only array elements with\n     * {@code index} less than {@code limit} can be used. If\n     * the {@code char} value at the given index in the\n     * {@code char} array is in the high-surrogate range, the\n     * following index is less than the {@code limit}, and the\n     * {@code char} value at the following index is in the\n     * low-surrogate range, then the supplementary code point\n     * corresponding to this surrogate pair is returned. Otherwise,\n     * the {@code char} value at the given index is returned.\n     *\n     * @param a the {@code char} array\n     * @param index the index to the {@code char} values (Unicode\n     * code units) in the {@code char} array to be converted\n     * @param limit the index after the last array element that\n     * can be used in the {@code char} array\n     * @return the Unicode code point at the given index\n     * @throws NullPointerException if {@code a} is null.\n     * @throws IndexOutOfBoundsException if the {@code index}\n     * argument is negative or not less than the {@code limit}\n     * argument, or if the {@code limit} argument is negative or\n     * greater than the length of the {@code char} array.\n     * @since  1.5\n     ",
    "links" : [ ]
  }, {
    "name" : " static int codePointAtImpl(char[] a, int index, int limit)",
    "returnType" : "int",
    "comment" : " throws ArrayIndexOutOfBoundsException if index out of bounds",
    "links" : [ ]
  }, {
    "name" : "public static int codePointBefore(CharSequence seq, int index)",
    "returnType" : "int",
    "comment" : "\n     * Returns the code point preceding the given index of the\n     * {@code CharSequence}. If the {@code char} value at\n     * {@code (index - 1)} in the {@code CharSequence} is in\n     * the low-surrogate range, {@code (index - 2)} is not\n     * negative, and the {@code char} value at {@code (index - 2)}\n     * in the {@code CharSequence} is in the\n     * high-surrogate range, then the supplementary code point\n     * corresponding to this surrogate pair is returned. Otherwise,\n     * the {@code char} value at {@code (index - 1)} is\n     * returned.\n     *\n     * @param seq the {@code CharSequence} instance\n     * @param index the index following the code point that should be returned\n     * @return the Unicode code point value before the given index.\n     * @throws NullPointerException if {@code seq} is null.\n     * @throws IndexOutOfBoundsException if the {@code index}\n     * argument is less than 1 or greater than {@link\n     * CharSequence#length() seq.length()}.\n     * @since  1.5\n     ",
    "links" : [ "java.lang.CharSequence#length()" ]
  }, {
    "name" : "public static int codePointBefore(char[] a, int index)",
    "returnType" : "int",
    "comment" : "\n     * Returns the code point preceding the given index of the\n     * {@code char} array. If the {@code char} value at\n     * {@code (index - 1)} in the {@code char} array is in\n     * the low-surrogate range, {@code (index - 2)} is not\n     * negative, and the {@code char} value at {@code (index - 2)}\n     * in the {@code char} array is in the\n     * high-surrogate range, then the supplementary code point\n     * corresponding to this surrogate pair is returned. Otherwise,\n     * the {@code char} value at {@code (index - 1)} is\n     * returned.\n     *\n     * @param a the {@code char} array\n     * @param index the index following the code point that should be returned\n     * @return the Unicode code point value before the given index.\n     * @throws NullPointerException if {@code a} is null.\n     * @throws IndexOutOfBoundsException if the {@code index}\n     * argument is less than 1 or greater than the length of the\n     * {@code char} array\n     * @since  1.5\n     ",
    "links" : [ ]
  }, {
    "name" : "public static int codePointBefore(char[] a, int index, int start)",
    "returnType" : "int",
    "comment" : "\n     * Returns the code point preceding the given index of the\n     * {@code char} array, where only array elements with\n     * {@code index} greater than or equal to {@code start}\n     * can be used. If the {@code char} value at {@code (index - 1)}\n     * in the {@code char} array is in the\n     * low-surrogate range, {@code (index - 2)} is not less than\n     * {@code start}, and the {@code char} value at\n     * {@code (index - 2)} in the {@code char} array is in\n     * the high-surrogate range, then the supplementary code point\n     * corresponding to this surrogate pair is returned. Otherwise,\n     * the {@code char} value at {@code (index - 1)} is\n     * returned.\n     *\n     * @param a the {@code char} array\n     * @param index the index following the code point that should be returned\n     * @param start the index of the first array element in the\n     * {@code char} array\n     * @return the Unicode code point value before the given index.\n     * @throws NullPointerException if {@code a} is null.\n     * @throws IndexOutOfBoundsException if the {@code index}\n     * argument is not greater than the {@code start} argument or\n     * is greater than the length of the {@code char} array, or\n     * if the {@code start} argument is negative or not less than\n     * the length of the {@code char} array.\n     * @since  1.5\n     ",
    "links" : [ ]
  }, {
    "name" : " static int codePointBeforeImpl(char[] a, int index, int start)",
    "returnType" : "int",
    "comment" : " throws ArrayIndexOutOfBoundsException if index-1 out of bounds",
    "links" : [ ]
  }, {
    "name" : "public static char highSurrogate(int codePoint)",
    "returnType" : "char",
    "comment" : "\n     * Returns the leading surrogate (a\n     * <a href=\"http://www.unicode.org/glossary/#high_surrogate_code_unit\">\n     * high surrogate code unit</a>) of the\n     * <a href=\"http://www.unicode.org/glossary/#surrogate_pair\">\n     * surrogate pair</a>\n     * representing the specified supplementary character (Unicode\n     * code point) in the UTF-16 encoding.  If the specified character\n     * is not a\n     * <a href=\"Character.html#supplementary\">supplementary character</a>,\n     * an unspecified {@code char} is returned.\n     *\n     * <p>If\n     * {@link #isSupplementaryCodePoint isSupplementaryCodePoint(x)}\n     * is {@code true}, then\n     * {@link #isHighSurrogate isHighSurrogate}{@code (highSurrogate(x))} and\n     * {@link #toCodePoint toCodePoint}{@code (highSurrogate(x), }{@link #lowSurrogate lowSurrogate}{@code (x)) == x}\n     * are also always {@code true}.\n     *\n     * @param   codePoint a supplementary character (Unicode code point)\n     * @return  the leading surrogate code unit used to represent the\n     *          character in the UTF-16 encoding\n     * @since   1.7\n     ",
    "links" : [ "#isSupplementaryCodePoint", "#toCodePoint", "#lowSurrogate", "#isHighSurrogate" ]
  }, {
    "name" : "public static char lowSurrogate(int codePoint)",
    "returnType" : "char",
    "comment" : "\n     * Returns the trailing surrogate (a\n     * <a href=\"http://www.unicode.org/glossary/#low_surrogate_code_unit\">\n     * low surrogate code unit</a>) of the\n     * <a href=\"http://www.unicode.org/glossary/#surrogate_pair\">\n     * surrogate pair</a>\n     * representing the specified supplementary character (Unicode\n     * code point) in the UTF-16 encoding.  If the specified character\n     * is not a\n     * <a href=\"Character.html#supplementary\">supplementary character</a>,\n     * an unspecified {@code char} is returned.\n     *\n     * <p>If\n     * {@link #isSupplementaryCodePoint isSupplementaryCodePoint(x)}\n     * is {@code true}, then\n     * {@link #isLowSurrogate isLowSurrogate}{@code (lowSurrogate(x))} and\n     * {@link #toCodePoint toCodePoint}{@code (}{@link #highSurrogate highSurrogate}{@code (x), lowSurrogate(x)) == x}\n     * are also always {@code true}.\n     *\n     * @param   codePoint a supplementary character (Unicode code point)\n     * @return  the trailing surrogate code unit used to represent the\n     *          character in the UTF-16 encoding\n     * @since   1.7\n     ",
    "links" : [ "#isLowSurrogate", "#isSupplementaryCodePoint", "#toCodePoint", "#highSurrogate" ]
  }, {
    "name" : "public static int toChars(int codePoint, char[] dst, int dstIndex)",
    "returnType" : "int",
    "comment" : "\n     * Converts the specified character (Unicode code point) to its\n     * UTF-16 representation. If the specified code point is a BMP\n     * (Basic Multilingual Plane or Plane 0) value, the same value is\n     * stored in {@code dst[dstIndex]}, and 1 is returned. If the\n     * specified code point is a supplementary character, its\n     * surrogate values are stored in {@code dst[dstIndex]}\n     * (high-surrogate) and {@code dst[dstIndex+1]}\n     * (low-surrogate), and 2 is returned.\n     *\n     * @param  codePoint the character (Unicode code point) to be converted.\n     * @param  dst an array of {@code char} in which the\n     * {@code codePoint}'s UTF-16 value is stored.\n     * @param dstIndex the start index into the {@code dst}\n     * array where the converted value is stored.\n     * @return 1 if the code point is a BMP code point, 2 if the\n     * code point is a supplementary code point.\n     * @throws IllegalArgumentException if the specified\n     * {@code codePoint} is not a valid Unicode code point.\n     * @throws NullPointerException if the specified {@code dst} is null.\n     * @throws IndexOutOfBoundsException if {@code dstIndex}\n     * is negative or not less than {@code dst.length}, or if\n     * {@code dst} at {@code dstIndex} doesn't have enough\n     * array element(s) to store the resulting {@code char}\n     * value(s). (If {@code dstIndex} is equal to\n     * {@code dst.length-1} and the specified\n     * {@code codePoint} is a supplementary character, the\n     * high-surrogate value is not stored in\n     * {@code dst[dstIndex]}.)\n     * @since  1.5\n     ",
    "links" : [ ]
  }, {
    "name" : "public static char[] toChars(int codePoint)",
    "returnType" : "char[]",
    "comment" : "\n     * Converts the specified character (Unicode code point) to its\n     * UTF-16 representation stored in a {@code char} array. If\n     * the specified code point is a BMP (Basic Multilingual Plane or\n     * Plane 0) value, the resulting {@code char} array has\n     * the same value as {@code codePoint}. If the specified code\n     * point is a supplementary code point, the resulting\n     * {@code char} array has the corresponding surrogate pair.\n     *\n     * @param  codePoint a Unicode code point\n     * @return a {@code char} array having\n     *         {@code codePoint}'s UTF-16 representation.\n     * @throws IllegalArgumentException if the specified\n     * {@code codePoint} is not a valid Unicode code point.\n     * @since  1.5\n     ",
    "links" : [ ]
  }, {
    "name" : " static void toSurrogates(int codePoint, char[] dst, int index)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public static int codePointCount(CharSequence seq, int beginIndex, int endIndex)",
    "returnType" : "int",
    "comment" : "\n     * Returns the number of Unicode code points in the text range of\n     * the specified char sequence. The text range begins at the\n     * specified {@code beginIndex} and extends to the\n     * {@code char} at index {@code endIndex - 1}. Thus the\n     * length (in {@code char}s) of the text range is\n     * {@code endIndex-beginIndex}. Unpaired surrogates within\n     * the text range count as one code point each.\n     *\n     * @param seq the char sequence\n     * @param beginIndex the index to the first {@code char} of\n     * the text range.\n     * @param endIndex the index after the last {@code char} of\n     * the text range.\n     * @return the number of Unicode code points in the specified text\n     * range\n     * @throws NullPointerException if {@code seq} is null.\n     * @throws IndexOutOfBoundsException if the\n     * {@code beginIndex} is negative, or {@code endIndex}\n     * is larger than the length of the given sequence, or\n     * {@code beginIndex} is larger than {@code endIndex}.\n     * @since  1.5\n     ",
    "links" : [ ]
  }, {
    "name" : "public static int codePointCount(char[] a, int offset, int count)",
    "returnType" : "int",
    "comment" : "\n     * Returns the number of Unicode code points in a subarray of the\n     * {@code char} array argument. The {@code offset}\n     * argument is the index of the first {@code char} of the\n     * subarray and the {@code count} argument specifies the\n     * length of the subarray in {@code char}s. Unpaired\n     * surrogates within the subarray count as one code point each.\n     *\n     * @param a the {@code char} array\n     * @param offset the index of the first {@code char} in the\n     * given {@code char} array\n     * @param count the length of the subarray in {@code char}s\n     * @return the number of Unicode code points in the specified subarray\n     * @throws NullPointerException if {@code a} is null.\n     * @throws IndexOutOfBoundsException if {@code offset} or\n     * {@code count} is negative, or if {@code offset +\n     * count} is larger than the length of the given array.\n     * @since  1.5\n     ",
    "links" : [ ]
  }, {
    "name" : " static int codePointCountImpl(char[] a, int offset, int count)",
    "returnType" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public static int offsetByCodePoints(CharSequence seq, int index, int codePointOffset)",
    "returnType" : "int",
    "comment" : "\n     * Returns the index within the given char sequence that is offset\n     * from the given {@code index} by {@code codePointOffset}\n     * code points. Unpaired surrogates within the text range given by\n     * {@code index} and {@code codePointOffset} count as\n     * one code point each.\n     *\n     * @param seq the char sequence\n     * @param index the index to be offset\n     * @param codePointOffset the offset in code points\n     * @return the index within the char sequence\n     * @throws NullPointerException if {@code seq} is null.\n     * @throws IndexOutOfBoundsException if {@code index}\n     *   is negative or larger then the length of the char sequence,\n     *   or if {@code codePointOffset} is positive and the\n     *   subsequence starting with {@code index} has fewer than\n     *   {@code codePointOffset} code points, or if\n     *   {@code codePointOffset} is negative and the subsequence\n     *   before {@code index} has fewer than the absolute value\n     *   of {@code codePointOffset} code points.\n     * @since 1.5\n     ",
    "links" : [ ]
  }, {
    "name" : "public static int offsetByCodePoints(char[] a, int start, int count, int index, int codePointOffset)",
    "returnType" : "int",
    "comment" : "\n     * Returns the index within the given {@code char} subarray\n     * that is offset from the given {@code index} by\n     * {@code codePointOffset} code points. The\n     * {@code start} and {@code count} arguments specify a\n     * subarray of the {@code char} array. Unpaired surrogates\n     * within the text range given by {@code index} and\n     * {@code codePointOffset} count as one code point each.\n     *\n     * @param a the {@code char} array\n     * @param start the index of the first {@code char} of the\n     * subarray\n     * @param count the length of the subarray in {@code char}s\n     * @param index the index to be offset\n     * @param codePointOffset the offset in code points\n     * @return the index within the subarray\n     * @throws NullPointerException if {@code a} is null.\n     * @throws IndexOutOfBoundsException\n     *   if {@code start} or {@code count} is negative,\n     *   or if {@code start + count} is larger than the length of\n     *   the given array,\n     *   or if {@code index} is less than {@code start} or\n     *   larger then {@code start + count},\n     *   or if {@code codePointOffset} is positive and the text range\n     *   starting with {@code index} and ending with {@code start + count - 1}\n     *   has fewer than {@code codePointOffset} code\n     *   points,\n     *   or if {@code codePointOffset} is negative and the text range\n     *   starting with {@code start} and ending with {@code index - 1}\n     *   has fewer than the absolute value of\n     *   {@code codePointOffset} code points.\n     * @since 1.5\n     ",
    "links" : [ ]
  }, {
    "name" : " static int offsetByCodePointsImpl(char[] a, int start, int count, int index, int codePointOffset)",
    "returnType" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public static boolean isLowerCase(char ch)",
    "returnType" : "boolean",
    "comment" : "\n     * Determines if the specified character is a lowercase character.\n     * <p>\n     * A character is lowercase if its general category type, provided\n     * by {@code Character.getType(ch)}, is\n     * {@code LOWERCASE_LETTER}, or it has contributory property\n     * Other_Lowercase as defined by the Unicode Standard.\n     * <p>\n     * The following are examples of lowercase characters:\n     * <blockquote><pre>\n     * a b c d e f g h i j k l m n o p q r s t u v w x y z\n     * '&#92;u00DF' '&#92;u00E0' '&#92;u00E1' '&#92;u00E2' '&#92;u00E3' '&#92;u00E4' '&#92;u00E5' '&#92;u00E6'\n     * '&#92;u00E7' '&#92;u00E8' '&#92;u00E9' '&#92;u00EA' '&#92;u00EB' '&#92;u00EC' '&#92;u00ED' '&#92;u00EE'\n     * '&#92;u00EF' '&#92;u00F0' '&#92;u00F1' '&#92;u00F2' '&#92;u00F3' '&#92;u00F4' '&#92;u00F5' '&#92;u00F6'\n     * '&#92;u00F8' '&#92;u00F9' '&#92;u00FA' '&#92;u00FB' '&#92;u00FC' '&#92;u00FD' '&#92;u00FE' '&#92;u00FF'\n     * </pre></blockquote>\n     * <p> Many other Unicode characters are lowercase too.\n     *\n     * <p><b>Note:</b> This method cannot handle <a\n     * href=\"#supplementary\"> supplementary characters</a>. To support\n     * all Unicode characters, including supplementary characters, use\n     * the {@link #isLowerCase(int)} method.\n     *\n     * @param   ch   the character to be tested.\n     * @return  {@code true} if the character is lowercase;\n     *          {@code false} otherwise.\n     * @see     Character#isLowerCase(char)\n     * @see     Character#isTitleCase(char)\n     * @see     Character#toLowerCase(char)\n     * @see     Character#getType(char)\n     ",
    "links" : [ "#isLowerCase(int)" ]
  }, {
    "name" : "public static boolean isLowerCase(int codePoint)",
    "returnType" : "boolean",
    "comment" : "\n    public static boolean isLowerCase(int codePoint) {\n        return CharacterData.of(codePoint).isLowerCase(codePoint);\n    }\n    ",
    "links" : [ ]
  }, {
    "name" : " static native boolean isLowerCaseImpl(int codePoint)",
    "returnType" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public static boolean isUpperCase(char ch)",
    "returnType" : "boolean",
    "comment" : "\n     * Determines if the specified character is an uppercase character.\n     * <p>\n     * A character is uppercase if its general category type, provided by\n     * {@code Character.getType(ch)}, is {@code UPPERCASE_LETTER}.\n     * or it has contributory property Other_Uppercase as defined by the Unicode Standard.\n     * <p>\n     * The following are examples of uppercase characters:\n     * <blockquote><pre>\n     * A B C D E F G H I J K L M N O P Q R S T U V W X Y Z\n     * '&#92;u00C0' '&#92;u00C1' '&#92;u00C2' '&#92;u00C3' '&#92;u00C4' '&#92;u00C5' '&#92;u00C6' '&#92;u00C7'\n     * '&#92;u00C8' '&#92;u00C9' '&#92;u00CA' '&#92;u00CB' '&#92;u00CC' '&#92;u00CD' '&#92;u00CE' '&#92;u00CF'\n     * '&#92;u00D0' '&#92;u00D1' '&#92;u00D2' '&#92;u00D3' '&#92;u00D4' '&#92;u00D5' '&#92;u00D6' '&#92;u00D8'\n     * '&#92;u00D9' '&#92;u00DA' '&#92;u00DB' '&#92;u00DC' '&#92;u00DD' '&#92;u00DE'\n     * </pre></blockquote>\n     * <p> Many other Unicode characters are uppercase too.\n     *\n     * <p><b>Note:</b> This method cannot handle <a\n     * href=\"#supplementary\"> supplementary characters</a>. To support\n     * all Unicode characters, including supplementary characters, use\n     * the {@link #isUpperCase(int)} method.\n     *\n     * @param   ch   the character to be tested.\n     * @return  {@code true} if the character is uppercase;\n     *          {@code false} otherwise.\n     * @see     Character#isLowerCase(char)\n     * @see     Character#isTitleCase(char)\n     * @see     Character#toUpperCase(char)\n     * @see     Character#getType(char)\n     * @since   1.0\n     ",
    "links" : [ "#isUpperCase(int)" ]
  }, {
    "name" : "public static boolean isUpperCase(int codePoint)",
    "returnType" : "boolean",
    "comment" : "\n    public static boolean isUpperCase(int codePoint) {\n        return CharacterData.of(codePoint).isUpperCase(codePoint);\n    }\n    ",
    "links" : [ ]
  }, {
    "name" : " static native boolean isUpperCaseImpl(int codePoint)",
    "returnType" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public static boolean isTitleCase(char ch)",
    "returnType" : "boolean",
    "comment" : "\n     * Determines if the specified character is a titlecase character.\n     * <p>\n     * A character is a titlecase character if its general\n     * category type, provided by {@code Character.getType(ch)},\n     * is {@code TITLECASE_LETTER}.\n     * <p>\n     * Some characters look like pairs of Latin letters. For example, there\n     * is an uppercase letter that looks like \"LJ\" and has a corresponding\n     * lowercase letter that looks like \"lj\". A third form, which looks like \"Lj\",\n     * is the appropriate form to use when rendering a word in lowercase\n     * with initial capitals, as for a book title.\n     * <p>\n     * These are some of the Unicode characters for which this method returns\n     * {@code true}:\n     * <ul>\n     * <li>{@code LATIN CAPITAL LETTER D WITH SMALL LETTER Z WITH CARON}\n     * <li>{@code LATIN CAPITAL LETTER L WITH SMALL LETTER J}\n     * <li>{@code LATIN CAPITAL LETTER N WITH SMALL LETTER J}\n     * <li>{@code LATIN CAPITAL LETTER D WITH SMALL LETTER Z}\n     * </ul>\n     * <p> Many other Unicode characters are titlecase too.\n     *\n     * <p><b>Note:</b> This method cannot handle <a\n     * href=\"#supplementary\"> supplementary characters</a>. To support\n     * all Unicode characters, including supplementary characters, use\n     * the {@link #isTitleCase(int)} method.\n     *\n     * @param   ch   the character to be tested.\n     * @return  {@code true} if the character is titlecase;\n     *          {@code false} otherwise.\n     * @see     Character#isLowerCase(char)\n     * @see     Character#isUpperCase(char)\n     * @see     Character#toTitleCase(char)\n     * @see     Character#getType(char)\n     * @since   1.0.2\n     ",
    "links" : [ "#isTitleCase(int)" ]
  }, {
    "name" : "public static boolean isTitleCase(int codePoint)",
    "returnType" : "boolean",
    "comment" : "\n    public static boolean isTitleCase(int codePoint) {\n        return getType(codePoint) == Character.TITLECASE_LETTER;\n    }\n    ",
    "links" : [ ]
  }, {
    "name" : " static native boolean isTitleCaseImpl(int codePoint)",
    "returnType" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public static boolean isDigit(char ch)",
    "returnType" : "boolean",
    "comment" : "\n     * Determines if the specified character is a digit.\n     * <p>\n     * A character is a digit if its general category type, provided\n     * by {@code Character.getType(ch)}, is\n     * {@code DECIMAL_DIGIT_NUMBER}.\n     * <p>\n     * Some Unicode character ranges that contain digits:\n     * <ul>\n     * <li>{@code '\\u005Cu0030'} through {@code '\\u005Cu0039'},\n     *     ISO-LATIN-1 digits ({@code '0'} through {@code '9'})\n     * <li>{@code '\\u005Cu0660'} through {@code '\\u005Cu0669'},\n     *     Arabic-Indic digits\n     * <li>{@code '\\u005Cu06F0'} through {@code '\\u005Cu06F9'},\n     *     Extended Arabic-Indic digits\n     * <li>{@code '\\u005Cu0966'} through {@code '\\u005Cu096F'},\n     *     Devanagari digits\n     * <li>{@code '\\u005CuFF10'} through {@code '\\u005CuFF19'},\n     *     Fullwidth digits\n     * </ul>\n     *\n     * Many other character ranges contain digits as well.\n     *\n     * <p><b>Note:</b> This method cannot handle <a\n     * href=\"#supplementary\"> supplementary characters</a>. To support\n     * all Unicode characters, including supplementary characters, use\n     * the {@link #isDigit(int)} method.\n     *\n     * @param   ch   the character to be tested.\n     * @return  {@code true} if the character is a digit;\n     *          {@code false} otherwise.\n     * @see     Character#digit(char, int)\n     * @see     Character#forDigit(int, int)\n     * @see     Character#getType(char)\n     ",
    "links" : [ "#isDigit(int)" ]
  }, {
    "name" : "public static boolean isDigit(int codePoint)",
    "returnType" : "boolean",
    "comment" : "\n    public static boolean isDigit(int codePoint) {\n        return CharacterData.of(codePoint).isDigit(codePoint);\n    }\n    ",
    "links" : [ ]
  }, {
    "name" : " static native boolean isDigitImpl(int codePoint)",
    "returnType" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public static boolean isDefined(char ch)",
    "returnType" : "boolean",
    "comment" : "\n     * Determines if a character is defined in Unicode.\n     * <p>\n     * A character is defined if at least one of the following is true:\n     * <ul>\n     * <li>It has an entry in the UnicodeData file.\n     * <li>It has a value in a range defined by the UnicodeData file.\n     * </ul>\n     *\n     * <p><b>Note:</b> This method cannot handle <a\n     * href=\"#supplementary\"> supplementary characters</a>. To support\n     * all Unicode characters, including supplementary characters, use\n     * the {@link #isDefined(int)} method.\n     *\n     * @param   ch   the character to be tested\n     * @return  {@code true} if the character has a defined meaning\n     *          in Unicode; {@code false} otherwise.\n     * @see     Character#isDigit(char)\n     * @see     Character#isLetter(char)\n     * @see     Character#isLetterOrDigit(char)\n     * @see     Character#isLowerCase(char)\n     * @see     Character#isTitleCase(char)\n     * @see     Character#isUpperCase(char)\n     * @since   1.0.2\n     ",
    "links" : [ "#isDefined(int)" ]
  }, {
    "name" : "public static boolean isDefined(int codePoint)",
    "returnType" : "boolean",
    "comment" : "\n    public static boolean isDefined(int codePoint) {\n        return getType(codePoint) != Character.UNASSIGNED;\n    }\n    ",
    "links" : [ ]
  }, {
    "name" : " static native boolean isDefinedImpl(int codePoint)",
    "returnType" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public static boolean isLetter(char ch)",
    "returnType" : "boolean",
    "comment" : "\n     * Determines if the specified character is a letter.\n     * <p>\n     * A character is considered to be a letter if its general\n     * category type, provided by {@code Character.getType(ch)},\n     * is any of the following:\n     * <ul>\n     * <li> {@code UPPERCASE_LETTER}\n     * <li> {@code LOWERCASE_LETTER}\n     * <li> {@code TITLECASE_LETTER}\n     * <li> {@code MODIFIER_LETTER}\n     * <li> {@code OTHER_LETTER}\n     * </ul>\n     *\n     * Not all letters have case. Many characters are\n     * letters but are neither uppercase nor lowercase nor titlecase.\n     *\n     * <p><b>Note:</b> This method cannot handle <a\n     * href=\"#supplementary\"> supplementary characters</a>. To support\n     * all Unicode characters, including supplementary characters, use\n     * the {@link #isLetter(int)} method.\n     *\n     * @param   ch   the character to be tested.\n     * @return  {@code true} if the character is a letter;\n     *          {@code false} otherwise.\n     * @see     Character#isDigit(char)\n     * @see     Character#isJavaIdentifierStart(char)\n     * @see     Character#isJavaLetter(char)\n     * @see     Character#isJavaLetterOrDigit(char)\n     * @see     Character#isLetterOrDigit(char)\n     * @see     Character#isLowerCase(char)\n     * @see     Character#isTitleCase(char)\n     * @see     Character#isUnicodeIdentifierStart(char)\n     * @see     Character#isUpperCase(char)\n     ",
    "links" : [ "#isLetter(int)" ]
  }, {
    "name" : "public static boolean isLetter(int codePoint)",
    "returnType" : "boolean",
    "comment" : "\n    public static boolean isLetter(int codePoint) {\n        return ((((1 << Character.UPPERCASE_LETTER) |\n            (1 << Character.LOWERCASE_LETTER) |\n            (1 << Character.TITLECASE_LETTER) |\n            (1 << Character.MODIFIER_LETTER) |\n            (1 << Character.OTHER_LETTER)) >> getType(codePoint)) & 1)\n            != 0;\n    }\n    ",
    "links" : [ ]
  }, {
    "name" : " static native boolean isLetterImpl(int codePoint)",
    "returnType" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public static boolean isLetterOrDigit(char ch)",
    "returnType" : "boolean",
    "comment" : "\n     * Determines if the specified character is a letter or digit.\n     * <p>\n     * A character is considered to be a letter or digit if either\n     * {@code Character.isLetter(char ch)} or\n     * {@code Character.isDigit(char ch)} returns\n     * {@code true} for the character.\n     *\n     * <p><b>Note:</b> This method cannot handle <a\n     * href=\"#supplementary\"> supplementary characters</a>. To support\n     * all Unicode characters, including supplementary characters, use\n     * the {@link #isLetterOrDigit(int)} method.\n     *\n     * @param   ch   the character to be tested.\n     * @return  {@code true} if the character is a letter or digit;\n     *          {@code false} otherwise.\n     * @see     Character#isDigit(char)\n     * @see     Character#isJavaIdentifierPart(char)\n     * @see     Character#isJavaLetter(char)\n     * @see     Character#isJavaLetterOrDigit(char)\n     * @see     Character#isLetter(char)\n     * @see     Character#isUnicodeIdentifierPart(char)\n     * @since   1.0.2\n     ",
    "links" : [ "#isLetterOrDigit(int)" ]
  }, {
    "name" : "public static boolean isLetterOrDigit(int codePoint)",
    "returnType" : "boolean",
    "comment" : "\n    public static boolean isLetterOrDigit(int codePoint) {\n        return ((((1 << Character.UPPERCASE_LETTER) |\n            (1 << Character.LOWERCASE_LETTER) |\n            (1 << Character.TITLECASE_LETTER) |\n            (1 << Character.MODIFIER_LETTER) |\n            (1 << Character.OTHER_LETTER) |\n            (1 << Character.DECIMAL_DIGIT_NUMBER)) >> getType(codePoint)) & 1)\n            != 0;\n    }\n    ",
    "links" : [ ]
  }, {
    "name" : " static native boolean isLetterOrDigitImpl(int codePoint)",
    "returnType" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public static boolean isJavaLetter(char ch)",
    "returnType" : "boolean",
    "comment" : "\n     * Determines if the specified character is permissible as the first\n     * character in a Java identifier.\n     * <p>\n     * A character may start a Java identifier if and only if\n     * one of the following conditions is true:\n     * <ul>\n     * <li> {@link #isLetter(char) isLetter(ch)} returns {@code true}\n     * <li> {@link #getType(char) getType(ch)} returns {@code LETTER_NUMBER}\n     * <li> {@code ch} is a currency symbol (such as {@code '$'})\n     * <li> {@code ch} is a connecting punctuation character (such as {@code '_'}).\n     * </ul>\n     *\n     * @param   ch the character to be tested.\n     * @return  {@code true} if the character may start a Java\n     *          identifier; {@code false} otherwise.\n     * @see     Character#isJavaLetterOrDigit(char)\n     * @see     Character#isJavaIdentifierStart(char)\n     * @see     Character#isJavaIdentifierPart(char)\n     * @see     Character#isLetter(char)\n     * @see     Character#isLetterOrDigit(char)\n     * @see     Character#isUnicodeIdentifierStart(char)\n     * @since   1.0.2\n     * @deprecated Replaced by isJavaIdentifierStart(char).\n     ",
    "links" : [ "#isLetter(char)", "#getType(char)" ]
  }, {
    "name" : "public static boolean isJavaLetterOrDigit(char ch)",
    "returnType" : "boolean",
    "comment" : "\n     * Determines if the specified character may be part of a Java\n     * identifier as other than the first character.\n     * <p>\n     * A character may be part of a Java identifier if and only if one\n     * of the following conditions is true:\n     * <ul>\n     * <li>  it is a letter\n     * <li>  it is a currency symbol (such as {@code '$'})\n     * <li>  it is a connecting punctuation character (such as {@code '_'})\n     * <li>  it is a digit\n     * <li>  it is a numeric letter (such as a Roman numeral character)\n     * <li>  it is a combining mark\n     * <li>  it is a non-spacing mark\n     * <li> {@code isIdentifierIgnorable} returns\n     * {@code true} for the character.\n     * </ul>\n     *\n     * @param   ch the character to be tested.\n     * @return  {@code true} if the character may be part of a\n     *          Java identifier; {@code false} otherwise.\n     * @see     Character#isJavaLetter(char)\n     * @see     Character#isJavaIdentifierStart(char)\n     * @see     Character#isJavaIdentifierPart(char)\n     * @see     Character#isLetter(char)\n     * @see     Character#isLetterOrDigit(char)\n     * @see     Character#isUnicodeIdentifierPart(char)\n     * @see     Character#isIdentifierIgnorable(char)\n     * @since   1.0.2\n     * @deprecated Replaced by isJavaIdentifierPart(char).\n     ",
    "links" : [ ]
  }, {
    "name" : "public static boolean isAlphabetic(int codePoint)",
    "returnType" : "boolean",
    "comment" : "\n    public static boolean isAlphabetic(int codePoint) {\n        return (((((1 << Character.UPPERCASE_LETTER) |\n            (1 << Character.LOWERCASE_LETTER) |\n            (1 << Character.TITLECASE_LETTER) |\n            (1 << Character.MODIFIER_LETTER) |\n            (1 << Character.OTHER_LETTER) |\n            (1 << Character.LETTER_NUMBER)) >> getType(codePoint)) & 1) != 0) ||\n            CharacterData.of(codePoint).isOtherAlphabetic(codePoint);\n    }\n    ",
    "links" : [ ]
  }, {
    "name" : " static native boolean isAlphabeticImpl(int codePoint)",
    "returnType" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public static boolean isIdeographic(int codePoint)",
    "returnType" : "boolean",
    "comment" : "\n    public static boolean isIdeographic(int codePoint) {\n        return CharacterData.of(codePoint).isIdeographic(codePoint);\n    }\n    ",
    "links" : [ ]
  }, {
    "name" : " static native boolean isIdeographicImpl(int codePoint)",
    "returnType" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public static boolean isJavaIdentifierStart(char ch)",
    "returnType" : "boolean",
    "comment" : "\n     * Determines if the specified character is\n     * permissible as the first character in a Java identifier.\n     * <p>\n     * A character may start a Java identifier if and only if\n     * one of the following conditions is true:\n     * <ul>\n     * <li> {@link #isLetter(char) isLetter(ch)} returns {@code true}\n     * <li> {@link #getType(char) getType(ch)} returns {@code LETTER_NUMBER}\n     * <li> {@code ch} is a currency symbol (such as {@code '$'})\n     * <li> {@code ch} is a connecting punctuation character (such as {@code '_'}).\n     * </ul>\n     *\n     * <p><b>Note:</b> This method cannot handle <a\n     * href=\"#supplementary\"> supplementary characters</a>. To support\n     * all Unicode characters, including supplementary characters, use\n     * the {@link #isJavaIdentifierStart(int)} method.\n     *\n     * @param   ch the character to be tested.\n     * @return  {@code true} if the character may start a Java identifier;\n     *          {@code false} otherwise.\n     * @see     Character#isJavaIdentifierPart(char)\n     * @see     Character#isLetter(char)\n     * @see     Character#isUnicodeIdentifierStart(char)\n     * @since   1.1\n     ",
    "links" : [ "#isLetter(char)", "#getType(char)", "#isJavaIdentifierStart(int)" ]
  }, {
    "name" : "public static boolean isJavaIdentifierStart(int codePoint)",
    "returnType" : "boolean",
    "comment" : "\n    public static boolean isJavaIdentifierStart(int codePoint) {\n        return CharacterData.of(codePoint).isJavaIdentifierStart(codePoint);\n    }\n    ",
    "links" : [ ]
  }, {
    "name" : "public static boolean isJavaIdentifierPart(char ch)",
    "returnType" : "boolean",
    "comment" : "\n     * Determines if the specified character may be part of a Java\n     * identifier as other than the first character.\n     * <p>\n     * A character may be part of a Java identifier if any of the following\n     * conditions are true:\n     * <ul>\n     * <li>  it is a letter\n     * <li>  it is a currency symbol (such as {@code '$'})\n     * <li>  it is a connecting punctuation character (such as {@code '_'})\n     * <li>  it is a digit\n     * <li>  it is a numeric letter (such as a Roman numeral character)\n     * <li>  it is a combining mark\n     * <li>  it is a non-spacing mark\n     * <li> {@code isIdentifierIgnorable} returns\n     * {@code true} for the character\n     * </ul>\n     *\n     * <p><b>Note:</b> This method cannot handle <a\n     * href=\"#supplementary\"> supplementary characters</a>. To support\n     * all Unicode characters, including supplementary characters, use\n     * the {@link #isJavaIdentifierPart(int)} method.\n     *\n     * @param   ch      the character to be tested.\n     * @return {@code true} if the character may be part of a\n     *          Java identifier; {@code false} otherwise.\n     * @see     Character#isIdentifierIgnorable(char)\n     * @see     Character#isJavaIdentifierStart(char)\n     * @see     Character#isLetterOrDigit(char)\n     * @see     Character#isUnicodeIdentifierPart(char)\n     * @since   1.1\n     ",
    "links" : [ "#isJavaIdentifierPart(int)" ]
  }, {
    "name" : "public static boolean isJavaIdentifierPart(int codePoint)",
    "returnType" : "boolean",
    "comment" : "\n    public static boolean isJavaIdentifierPart(int codePoint) {\n        return CharacterData.of(codePoint).isJavaIdentifierPart(codePoint);\n    }\n    ",
    "links" : [ ]
  }, {
    "name" : "public static boolean isUnicodeIdentifierStart(char ch)",
    "returnType" : "boolean",
    "comment" : "\n     * Determines if the specified character is permissible as the\n     * first character in a Unicode identifier.\n     * <p>\n     * A character may start a Unicode identifier if and only if\n     * one of the following conditions is true:\n     * <ul>\n     * <li> {@link #isLetter(char) isLetter(ch)} returns {@code true}\n     * <li> {@link #getType(char) getType(ch)} returns\n     *      {@code LETTER_NUMBER}.\n     * <li> it is an <a href=\"http://www.unicode.org/reports/tr44/#Other_ID_Start\">\n     *      {@code Other_ID_Start}</a> character.\n     * </ul>\n     * <p>\n     * This method conforms to <a href=\"https://unicode.org/reports/tr31/#R1\">\n     * UAX31-R1: Default Identifiers</a> requirement of the Unicode Standard,\n     * with the following profile of UAX31:\n     * <pre>\n     * Start := ID_Start + 'VERTICAL TILDE' (U+2E2F)\n     * </pre>\n     * {@code 'VERTICAL TILDE'} is added to {@code Start} for backward\n     * compatibility.\n     *\n     * <p><b>Note:</b> This method cannot handle <a\n     * href=\"#supplementary\"> supplementary characters</a>. To support\n     * all Unicode characters, including supplementary characters, use\n     * the {@link #isUnicodeIdentifierStart(int)} method.\n     *\n     * @param   ch      the character to be tested.\n     * @return  {@code true} if the character may start a Unicode\n     *          identifier; {@code false} otherwise.\n     * @see     Character#isJavaIdentifierStart(char)\n     * @see     Character#isLetter(char)\n     * @see     Character#isUnicodeIdentifierPart(char)\n     * @since   1.1\n     ",
    "links" : [ "#isLetter(char)", "#getType(char)", "#isUnicodeIdentifierStart(int)" ]
  }, {
    "name" : "public static boolean isUnicodeIdentifierStart(int codePoint)",
    "returnType" : "boolean",
    "comment" : "\n    public static boolean isUnicodeIdentifierStart(int codePoint) {\n        return CharacterData.of(codePoint).isUnicodeIdentifierStart(codePoint);\n    }\n    ",
    "links" : [ ]
  }, {
    "name" : " static native boolean isUnicodeIdentifierStartImpl(int codePoint)",
    "returnType" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public static boolean isUnicodeIdentifierPart(char ch)",
    "returnType" : "boolean",
    "comment" : "\n     * Determines if the specified character may be part of a Unicode\n     * identifier as other than the first character.\n     * <p>\n     * A character may be part of a Unicode identifier if and only if\n     * one of the following statements is true:\n     * <ul>\n     * <li>  it is a letter\n     * <li>  it is a connecting punctuation character (such as {@code '_'})\n     * <li>  it is a digit\n     * <li>  it is a numeric letter (such as a Roman numeral character)\n     * <li>  it is a combining mark\n     * <li>  it is a non-spacing mark\n     * <li> {@code isIdentifierIgnorable} returns\n     * {@code true} for this character.\n     * <li> it is an <a href=\"http://www.unicode.org/reports/tr44/#Other_ID_Start\">\n     *      {@code Other_ID_Start}</a> character.\n     * <li> it is an <a href=\"http://www.unicode.org/reports/tr44/#Other_ID_Continue\">\n     *      {@code Other_ID_Continue}</a> character.\n     * </ul>\n     * <p>\n     * This method conforms to <a href=\"https://unicode.org/reports/tr31/#R1\">\n     * UAX31-R1: Default Identifiers</a> requirement of the Unicode Standard,\n     * with the following profile of UAX31:\n     * <pre>\n     * Continue := Start + ID_Continue + ignorable\n     * Medial := empty\n     * ignorable := isIdentifierIgnorable(char) returns true for the character\n     * </pre>\n     * {@code ignorable} is added to {@code Continue} for backward\n     * compatibility.\n     *\n     * <p><b>Note:</b> This method cannot handle <a\n     * href=\"#supplementary\"> supplementary characters</a>. To support\n     * all Unicode characters, including supplementary characters, use\n     * the {@link #isUnicodeIdentifierPart(int)} method.\n     *\n     * @param   ch      the character to be tested.\n     * @return  {@code true} if the character may be part of a\n     *          Unicode identifier; {@code false} otherwise.\n     * @see     Character#isIdentifierIgnorable(char)\n     * @see     Character#isJavaIdentifierPart(char)\n     * @see     Character#isLetterOrDigit(char)\n     * @see     Character#isUnicodeIdentifierStart(char)\n     * @since   1.1\n     ",
    "links" : [ "#isUnicodeIdentifierPart(int)" ]
  }, {
    "name" : "public static boolean isUnicodeIdentifierPart(int codePoint)",
    "returnType" : "boolean",
    "comment" : "\n    public static boolean isUnicodeIdentifierPart(int codePoint) {\n        return CharacterData.of(codePoint).isUnicodeIdentifierPart(codePoint);\n    }\n    ",
    "links" : [ ]
  }, {
    "name" : " static native boolean isUnicodeIdentifierPartImpl(int codePoint)",
    "returnType" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public static boolean isIdentifierIgnorable(char ch)",
    "returnType" : "boolean",
    "comment" : "\n     * Determines if the specified character should be regarded as\n     * an ignorable character in a Java identifier or a Unicode identifier.\n     * <p>\n     * The following Unicode characters are ignorable in a Java identifier\n     * or a Unicode identifier:\n     * <ul>\n     * <li>ISO control characters that are not whitespace\n     * <ul>\n     * <li>{@code '\\u005Cu0000'} through {@code '\\u005Cu0008'}\n     * <li>{@code '\\u005Cu000E'} through {@code '\\u005Cu001B'}\n     * <li>{@code '\\u005Cu007F'} through {@code '\\u005Cu009F'}\n     * </ul>\n     *\n     * <li>all characters that have the {@code FORMAT} general\n     * category value\n     * </ul>\n     *\n     * <p><b>Note:</b> This method cannot handle <a\n     * href=\"#supplementary\"> supplementary characters</a>. To support\n     * all Unicode characters, including supplementary characters, use\n     * the {@link #isIdentifierIgnorable(int)} method.\n     *\n     * @param   ch      the character to be tested.\n     * @return  {@code true} if the character is an ignorable control\n     *          character that may be part of a Java or Unicode identifier;\n     *           {@code false} otherwise.\n     * @see     Character#isJavaIdentifierPart(char)\n     * @see     Character#isUnicodeIdentifierPart(char)\n     * @since   1.1\n     ",
    "links" : [ "#isIdentifierIgnorable(int)" ]
  }, {
    "name" : "public static boolean isIdentifierIgnorable(int codePoint)",
    "returnType" : "boolean",
    "comment" : "\n    public static boolean isIdentifierIgnorable(int codePoint) {\n        return CharacterData.of(codePoint).isIdentifierIgnorable(codePoint);\n    }\n    ",
    "links" : [ ]
  }, {
    "name" : " static native boolean isIdentifierIgnorableImpl(int codePoint)",
    "returnType" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public static char toLowerCase(char ch)",
    "returnType" : "char",
    "comment" : "\n     * Converts the character argument to lowercase using case\n     * mapping information from the UnicodeData file.\n     * <p>\n     * Note that\n     * {@code Character.isLowerCase(Character.toLowerCase(ch))}\n     * does not always return {@code true} for some ranges of\n     * characters, particularly those that are symbols or ideographs.\n     *\n     * <p>In general, {@link String#toLowerCase()} should be used to map\n     * characters to lowercase. {@code String} case mapping methods\n     * have several benefits over {@code Character} case mapping methods.\n     * {@code String} case mapping methods can perform locale-sensitive\n     * mappings, context-sensitive mappings, and 1:M character mappings, whereas\n     * the {@code Character} case mapping methods cannot.\n     *\n     * <p><b>Note:</b> This method cannot handle <a\n     * href=\"#supplementary\"> supplementary characters</a>. To support\n     * all Unicode characters, including supplementary characters, use\n     * the {@link #toLowerCase(int)} method.\n     *\n     * @param   ch   the character to be converted.\n     * @return  the lowercase equivalent of the character, if any;\n     *          otherwise, the character itself.\n     * @see     Character#isLowerCase(char)\n     * @see     String#toLowerCase()\n     ",
    "links" : [ "java.lang.String#toLowerCase()", "#toLowerCase(int)" ]
  }, {
    "name" : "public static int toLowerCase(int codePoint)",
    "returnType" : "int",
    "comment" : "\n    public static int toLowerCase(int codePoint) {\n        return CharacterData.of(codePoint).toLowerCase(codePoint);\n    }\n    ",
    "links" : [ ]
  }, {
    "name" : " static native int toLowerCaseImpl(int codePoint)",
    "returnType" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public static char toUpperCase(char ch)",
    "returnType" : "char",
    "comment" : "\n     * Converts the character argument to uppercase using case mapping\n     * information from the UnicodeData file.\n     * <p>\n     * Note that\n     * {@code Character.isUpperCase(Character.toUpperCase(ch))}\n     * does not always return {@code true} for some ranges of\n     * characters, particularly those that are symbols or ideographs.\n     *\n     * <p>In general, {@link String#toUpperCase()} should be used to map\n     * characters to uppercase. {@code String} case mapping methods\n     * have several benefits over {@code Character} case mapping methods.\n     * {@code String} case mapping methods can perform locale-sensitive\n     * mappings, context-sensitive mappings, and 1:M character mappings, whereas\n     * the {@code Character} case mapping methods cannot.\n     *\n     * <p><b>Note:</b> This method cannot handle <a\n     * href=\"#supplementary\"> supplementary characters</a>. To support\n     * all Unicode characters, including supplementary characters, use\n     * the {@link #toUpperCase(int)} method.\n     *\n     * @param   ch   the character to be converted.\n     * @return  the uppercase equivalent of the character, if any;\n     *          otherwise, the character itself.\n     * @see     Character#isUpperCase(char)\n     * @see     String#toUpperCase()\n     ",
    "links" : [ "#toUpperCase(int)", "java.lang.String#toUpperCase()" ]
  }, {
    "name" : "public static int toUpperCase(int codePoint)",
    "returnType" : "int",
    "comment" : "\n    public static int toUpperCase(int codePoint) {\n        return CharacterData.of(codePoint).toUpperCase(codePoint);\n    }\n    ",
    "links" : [ ]
  }, {
    "name" : " static native int toUpperCaseImpl(int codePoint)",
    "returnType" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public static char toTitleCase(char ch)",
    "returnType" : "char",
    "comment" : "\n     * Converts the character argument to titlecase using case mapping\n     * information from the UnicodeData file. If a character has no\n     * explicit titlecase mapping and is not itself a titlecase char\n     * according to UnicodeData, then the uppercase mapping is\n     * returned as an equivalent titlecase mapping. If the\n     * {@code char} argument is already a titlecase\n     * {@code char}, the same {@code char} value will be\n     * returned.\n     * <p>\n     * Note that\n     * {@code Character.isTitleCase(Character.toTitleCase(ch))}\n     * does not always return {@code true} for some ranges of\n     * characters.\n     *\n     * <p><b>Note:</b> This method cannot handle <a\n     * href=\"#supplementary\"> supplementary characters</a>. To support\n     * all Unicode characters, including supplementary characters, use\n     * the {@link #toTitleCase(int)} method.\n     *\n     * @param   ch   the character to be converted.\n     * @return  the titlecase equivalent of the character, if any;\n     *          otherwise, the character itself.\n     * @see     Character#isTitleCase(char)\n     * @see     Character#toLowerCase(char)\n     * @see     Character#toUpperCase(char)\n     * @since   1.0.2\n     ",
    "links" : [ "#toTitleCase(int)" ]
  }, {
    "name" : "public static int toTitleCase(int codePoint)",
    "returnType" : "int",
    "comment" : "\n    public static int toTitleCase(int codePoint) {\n        return CharacterData.of(codePoint).toTitleCase(codePoint);\n    }\n    ",
    "links" : [ ]
  }, {
    "name" : " static native int toTitleCaseImpl(int codePoint)",
    "returnType" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public static int digit(char ch, int radix)",
    "returnType" : "int",
    "comment" : "\n     * Returns the numeric value of the character {@code ch} in the\n     * specified radix.\n     * <p>\n     * If the radix is not in the range {@code MIN_RADIX} &le;\n     * {@code radix} &le; {@code MAX_RADIX} or if the\n     * value of {@code ch} is not a valid digit in the specified\n     * radix, {@code -1} is returned. A character is a valid digit\n     * if at least one of the following is true:\n     * <ul>\n     * <li>The method {@code isDigit} is {@code true} of the character\n     *     and the Unicode decimal digit value of the character (or its\n     *     single-character decomposition) is less than the specified radix.\n     *     In this case the decimal digit value is returned.\n     * <li>The character is one of the uppercase Latin letters\n     *     {@code 'A'} through {@code 'Z'} and its code is less than\n     *     {@code radix + 'A' - 10}.\n     *     In this case, {@code ch - 'A' + 10}\n     *     is returned.\n     * <li>The character is one of the lowercase Latin letters\n     *     {@code 'a'} through {@code 'z'} and its code is less than\n     *     {@code radix + 'a' - 10}.\n     *     In this case, {@code ch - 'a' + 10}\n     *     is returned.\n     * <li>The character is one of the fullwidth uppercase Latin letters A\n     *     ({@code '\\u005CuFF21'}) through Z ({@code '\\u005CuFF3A'})\n     *     and its code is less than\n     *     {@code radix + '\\u005CuFF21' - 10}.\n     *     In this case, {@code ch - '\\u005CuFF21' + 10}\n     *     is returned.\n     * <li>The character is one of the fullwidth lowercase Latin letters a\n     *     ({@code '\\u005CuFF41'}) through z ({@code '\\u005CuFF5A'})\n     *     and its code is less than\n     *     {@code radix + '\\u005CuFF41' - 10}.\n     *     In this case, {@code ch - '\\u005CuFF41' + 10}\n     *     is returned.\n     * </ul>\n     *\n     * <p><b>Note:</b> This method cannot handle <a\n     * href=\"#supplementary\"> supplementary characters</a>. To support\n     * all Unicode characters, including supplementary characters, use\n     * the {@link #digit(int, int)} method.\n     *\n     * @param   ch      the character to be converted.\n     * @param   radix   the radix.\n     * @return  the numeric value represented by the character in the\n     *          specified radix.\n     * @see     Character#forDigit(int, int)\n     * @see     Character#isDigit(char)\n     ",
    "links" : [ "#digit(int" ]
  }, {
    "name" : "public static int digit(int codePoint, int radix)",
    "returnType" : "int",
    "comment" : "\n    public static int digit(int codePoint, int radix) {\n        return CharacterData.of(codePoint).digit(codePoint, radix);\n    }\n    ",
    "links" : [ ]
  }, {
    "name" : " static native int digitImpl(int codePoint, int radix)",
    "returnType" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public static int getNumericValue(char ch)",
    "returnType" : "int",
    "comment" : "\n     * Returns the {@code int} value that the specified Unicode\n     * character represents. For example, the character\n     * {@code '\\u005Cu216C'} (the roman numeral fifty) will return\n     * an int with a value of 50.\n     * <p>\n     * The letters A-Z in their uppercase ({@code '\\u005Cu0041'} through\n     * {@code '\\u005Cu005A'}), lowercase\n     * ({@code '\\u005Cu0061'} through {@code '\\u005Cu007A'}), and\n     * full width variant ({@code '\\u005CuFF21'} through\n     * {@code '\\u005CuFF3A'} and {@code '\\u005CuFF41'} through\n     * {@code '\\u005CuFF5A'}) forms have numeric values from 10\n     * through 35. This is independent of the Unicode specification,\n     * which does not assign numeric values to these {@code char}\n     * values.\n     * <p>\n     * If the character does not have a numeric value, then -1 is returned.\n     * If the character has a numeric value that cannot be represented as a\n     * nonnegative integer (for example, a fractional value), then -2\n     * is returned.\n     *\n     * <p><b>Note:</b> This method cannot handle <a\n     * href=\"#supplementary\"> supplementary characters</a>. To support\n     * all Unicode characters, including supplementary characters, use\n     * the {@link #getNumericValue(int)} method.\n     *\n     * @param   ch      the character to be converted.\n     * @return  the numeric value of the character, as a nonnegative {@code int}\n     *          value; -2 if the character has a numeric value but the value\n     *          can not be represented as a nonnegative {@code int} value;\n     *          -1 if the character has no numeric value.\n     * @see     Character#forDigit(int, int)\n     * @see     Character#isDigit(char)\n     * @since   1.1\n     ",
    "links" : [ "#getNumericValue(int)" ]
  }, {
    "name" : "public static int getNumericValue(int codePoint)",
    "returnType" : "int",
    "comment" : "\n    public static int getNumericValue(int codePoint) {\n        return CharacterData.of(codePoint).getNumericValue(codePoint);\n    }\n    ",
    "links" : [ ]
  }, {
    "name" : " static native int getNumericValueImpl(int codePoint)",
    "returnType" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public static boolean isSpace(char ch)",
    "returnType" : "boolean",
    "comment" : "\n     * Determines if the specified character is ISO-LATIN-1 white space.\n     * This method returns {@code true} for the following five\n     * characters only:\n     * <table class=\"striped\">\n     * <caption style=\"display:none\">truechars</caption>\n     * <thead>\n     * <tr><th scope=\"col\">Character\n     *     <th scope=\"col\">Code\n     *     <th scope=\"col\">Name\n     * </thead>\n     * <tbody>\n     * <tr><th scope=\"row\">{@code '\\t'}</th>            <td>{@code U+0009}</td>\n     *     <td>{@code HORIZONTAL TABULATION}</td></tr>\n     * <tr><th scope=\"row\">{@code '\\n'}</th>            <td>{@code U+000A}</td>\n     *     <td>{@code NEW LINE}</td></tr>\n     * <tr><th scope=\"row\">{@code '\\f'}</th>            <td>{@code U+000C}</td>\n     *     <td>{@code FORM FEED}</td></tr>\n     * <tr><th scope=\"row\">{@code '\\r'}</th>            <td>{@code U+000D}</td>\n     *     <td>{@code CARRIAGE RETURN}</td></tr>\n     * <tr><th scope=\"row\">{@code ' '}</th>  <td>{@code U+0020}</td>\n     *     <td>{@code SPACE}</td></tr>\n     * </tbody>\n     * </table>\n     *\n     * @param      ch   the character to be tested.\n     * @return     {@code true} if the character is ISO-LATIN-1 white\n     *             space; {@code false} otherwise.\n     * @see        Character#isSpaceChar(char)\n     * @see        Character#isWhitespace(char)\n     * @deprecated Replaced by isWhitespace(char).\n     ",
    "links" : [ ]
  }, {
    "name" : "public static boolean isSpaceChar(char ch)",
    "returnType" : "boolean",
    "comment" : "\n     * Determines if the specified character is a Unicode space character.\n     * A character is considered to be a space character if and only if\n     * it is specified to be a space character by the Unicode Standard. This\n     * method returns true if the character's general category type is any of\n     * the following:\n     * <ul>\n     * <li> {@code SPACE_SEPARATOR}\n     * <li> {@code LINE_SEPARATOR}\n     * <li> {@code PARAGRAPH_SEPARATOR}\n     * </ul>\n     *\n     * <p><b>Note:</b> This method cannot handle <a\n     * href=\"#supplementary\"> supplementary characters</a>. To support\n     * all Unicode characters, including supplementary characters, use\n     * the {@link #isSpaceChar(int)} method.\n     *\n     * @param   ch      the character to be tested.\n     * @return  {@code true} if the character is a space character;\n     *          {@code false} otherwise.\n     * @see     Character#isWhitespace(char)\n     * @since   1.1\n     ",
    "links" : [ "#isSpaceChar(int)" ]
  }, {
    "name" : "public static boolean isSpaceChar(int codePoint)",
    "returnType" : "boolean",
    "comment" : "\n    public static boolean isSpaceChar(int codePoint) {\n        return ((((1 << Character.SPACE_SEPARATOR) |\n                  (1 << Character.LINE_SEPARATOR) |\n                  (1 << Character.PARAGRAPH_SEPARATOR)) >> getType(codePoint)) & 1)\n            != 0;\n    }\n    ",
    "links" : [ ]
  }, {
    "name" : " static native boolean isSpaceCharImpl(int codePoint)",
    "returnType" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public static boolean isWhitespace(char ch)",
    "returnType" : "boolean",
    "comment" : "\n     * Determines if the specified character is white space according to Java.\n     * A character is a Java whitespace character if and only if it satisfies\n     * one of the following criteria:\n     * <ul>\n     * <li> It is a Unicode space character ({@code SPACE_SEPARATOR},\n     *      {@code LINE_SEPARATOR}, or {@code PARAGRAPH_SEPARATOR})\n     *      but is not also a non-breaking space ({@code '\\u005Cu00A0'},\n     *      {@code '\\u005Cu2007'}, {@code '\\u005Cu202F'}).\n     * <li> It is {@code '\\u005Ct'}, U+0009 HORIZONTAL TABULATION.\n     * <li> It is {@code '\\u005Cn'}, U+000A LINE FEED.\n     * <li> It is {@code '\\u005Cu000B'}, U+000B VERTICAL TABULATION.\n     * <li> It is {@code '\\u005Cf'}, U+000C FORM FEED.\n     * <li> It is {@code '\\u005Cr'}, U+000D CARRIAGE RETURN.\n     * <li> It is {@code '\\u005Cu001C'}, U+001C FILE SEPARATOR.\n     * <li> It is {@code '\\u005Cu001D'}, U+001D GROUP SEPARATOR.\n     * <li> It is {@code '\\u005Cu001E'}, U+001E RECORD SEPARATOR.\n     * <li> It is {@code '\\u005Cu001F'}, U+001F UNIT SEPARATOR.\n     * </ul>\n     *\n     * <p><b>Note:</b> This method cannot handle <a\n     * href=\"#supplementary\"> supplementary characters</a>. To support\n     * all Unicode characters, including supplementary characters, use\n     * the {@link #isWhitespace(int)} method.\n     *\n     * @param   ch the character to be tested.\n     * @return  {@code true} if the character is a Java whitespace\n     *          character; {@code false} otherwise.\n     * @see     Character#isSpaceChar(char)\n     * @since   1.1\n     ",
    "links" : [ "#isWhitespace(int)" ]
  }, {
    "name" : "public static boolean isWhitespace(int codePoint)",
    "returnType" : "boolean",
    "comment" : "\n    public static boolean isWhitespace(int codePoint) {\n        return CharacterData.of(codePoint).isWhitespace(codePoint);\n    }\n    ",
    "links" : [ ]
  }, {
    "name" : " static native boolean isWhitespaceImpl(int codePoint)",
    "returnType" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public static boolean isISOControl(char ch)",
    "returnType" : "boolean",
    "comment" : "\n     * Determines if the specified character is an ISO control\n     * character.  A character is considered to be an ISO control\n     * character if its code is in the range {@code '\\u005Cu0000'}\n     * through {@code '\\u005Cu001F'} or in the range\n     * {@code '\\u005Cu007F'} through {@code '\\u005Cu009F'}.\n     *\n     * <p><b>Note:</b> This method cannot handle <a\n     * href=\"#supplementary\"> supplementary characters</a>. To support\n     * all Unicode characters, including supplementary characters, use\n     * the {@link #isISOControl(int)} method.\n     *\n     * @param   ch      the character to be tested.\n     * @return  {@code true} if the character is an ISO control character;\n     *          {@code false} otherwise.\n     *\n     * @see     Character#isSpaceChar(char)\n     * @see     Character#isWhitespace(char)\n     * @since   1.1\n     ",
    "links" : [ "#isISOControl(int)" ]
  }, {
    "name" : "public static boolean isISOControl(int codePoint)",
    "returnType" : "boolean",
    "comment" : "\n     * Determines if the referenced character (Unicode code point) is an ISO control\n     * character.  A character is considered to be an ISO control\n     * character if its code is in the range {@code '\\u005Cu0000'}\n     * through {@code '\\u005Cu001F'} or in the range\n     * {@code '\\u005Cu007F'} through {@code '\\u005Cu009F'}.\n     *\n     * @param   codePoint the character (Unicode code point) to be tested.\n     * @return  {@code true} if the character is an ISO control character;\n     *          {@code false} otherwise.\n     * @see     Character#isSpaceChar(int)\n     * @see     Character#isWhitespace(int)\n     * @since   1.5\n     ",
    "links" : [ ]
  }, {
    "name" : "public static int getType(char ch)",
    "returnType" : "int",
    "comment" : "\n     * Returns a value indicating a character's general category.\n     *\n     * <p><b>Note:</b> This method cannot handle <a\n     * href=\"#supplementary\"> supplementary characters</a>. To support\n     * all Unicode characters, including supplementary characters, use\n     * the {@link #getType(int)} method.\n     *\n     * @param   ch      the character to be tested.\n     * @return  a value of type {@code int} representing the\n     *          character's general category.\n     * @see     Character#COMBINING_SPACING_MARK\n     * @see     Character#CONNECTOR_PUNCTUATION\n     * @see     Character#CONTROL\n     * @see     Character#CURRENCY_SYMBOL\n     * @see     Character#DASH_PUNCTUATION\n     * @see     Character#DECIMAL_DIGIT_NUMBER\n     * @see     Character#ENCLOSING_MARK\n     * @see     Character#END_PUNCTUATION\n     * @see     Character#FINAL_QUOTE_PUNCTUATION\n     * @see     Character#FORMAT\n     * @see     Character#INITIAL_QUOTE_PUNCTUATION\n     * @see     Character#LETTER_NUMBER\n     * @see     Character#LINE_SEPARATOR\n     * @see     Character#LOWERCASE_LETTER\n     * @see     Character#MATH_SYMBOL\n     * @see     Character#MODIFIER_LETTER\n     * @see     Character#MODIFIER_SYMBOL\n     * @see     Character#NON_SPACING_MARK\n     * @see     Character#OTHER_LETTER\n     * @see     Character#OTHER_NUMBER\n     * @see     Character#OTHER_PUNCTUATION\n     * @see     Character#OTHER_SYMBOL\n     * @see     Character#PARAGRAPH_SEPARATOR\n     * @see     Character#PRIVATE_USE\n     * @see     Character#SPACE_SEPARATOR\n     * @see     Character#START_PUNCTUATION\n     * @see     Character#SURROGATE\n     * @see     Character#TITLECASE_LETTER\n     * @see     Character#UNASSIGNED\n     * @see     Character#UPPERCASE_LETTER\n     * @since   1.1\n     ",
    "links" : [ "#getType(int)" ]
  }, {
    "name" : "public static int getType(int codePoint)",
    "returnType" : "int",
    "comment" : "\n    public static int getType(int codePoint) {\n        return CharacterData.of(codePoint).getType(codePoint);\n    }\n    ",
    "links" : [ ]
  }, {
    "name" : " static native int getTypeImpl(int codePoint)",
    "returnType" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public static char forDigit(int digit, int radix)",
    "returnType" : "char",
    "comment" : "\n     * Determines the character representation for a specific digit in\n     * the specified radix. If the value of {@code radix} is not a\n     * valid radix, or the value of {@code digit} is not a valid\n     * digit in the specified radix, the null character\n     * ({@code '\\u005Cu0000'}) is returned.\n     * <p>\n     * The {@code radix} argument is valid if it is greater than or\n     * equal to {@code MIN_RADIX} and less than or equal to\n     * {@code MAX_RADIX}. The {@code digit} argument is valid if\n     * {@code 0 <= digit < radix}.\n     * <p>\n     * If the digit is less than 10, then\n     * {@code '0' + digit} is returned. Otherwise, the value\n     * {@code 'a' + digit - 10} is returned.\n     *\n     * @param   digit   the number to convert to a character.\n     * @param   radix   the radix.\n     * @return  the {@code char} representation of the specified digit\n     *          in the specified radix.\n     * @see     Character#MIN_RADIX\n     * @see     Character#MAX_RADIX\n     * @see     Character#digit(char, int)\n     ",
    "links" : [ ]
  }, {
    "name" : "public static byte getDirectionality(char ch)",
    "returnType" : "byte",
    "comment" : "\n     * Returns the Unicode directionality property for the given\n     * character.  Character directionality is used to calculate the\n     * visual ordering of text. The directionality value of undefined\n     * {@code char} values is {@code DIRECTIONALITY_UNDEFINED}.\n     *\n     * <p><b>Note:</b> This method cannot handle <a\n     * href=\"#supplementary\"> supplementary characters</a>. To support\n     * all Unicode characters, including supplementary characters, use\n     * the {@link #getDirectionality(int)} method.\n     *\n     * @param  ch {@code char} for which the directionality property\n     *            is requested.\n     * @return the directionality property of the {@code char} value.\n     *\n     * @see Character#DIRECTIONALITY_UNDEFINED\n     * @see Character#DIRECTIONALITY_LEFT_TO_RIGHT\n     * @see Character#DIRECTIONALITY_RIGHT_TO_LEFT\n     * @see Character#DIRECTIONALITY_RIGHT_TO_LEFT_ARABIC\n     * @see Character#DIRECTIONALITY_EUROPEAN_NUMBER\n     * @see Character#DIRECTIONALITY_EUROPEAN_NUMBER_SEPARATOR\n     * @see Character#DIRECTIONALITY_EUROPEAN_NUMBER_TERMINATOR\n     * @see Character#DIRECTIONALITY_ARABIC_NUMBER\n     * @see Character#DIRECTIONALITY_COMMON_NUMBER_SEPARATOR\n     * @see Character#DIRECTIONALITY_NONSPACING_MARK\n     * @see Character#DIRECTIONALITY_BOUNDARY_NEUTRAL\n     * @see Character#DIRECTIONALITY_PARAGRAPH_SEPARATOR\n     * @see Character#DIRECTIONALITY_SEGMENT_SEPARATOR\n     * @see Character#DIRECTIONALITY_WHITESPACE\n     * @see Character#DIRECTIONALITY_OTHER_NEUTRALS\n     * @see Character#DIRECTIONALITY_LEFT_TO_RIGHT_EMBEDDING\n     * @see Character#DIRECTIONALITY_LEFT_TO_RIGHT_OVERRIDE\n     * @see Character#DIRECTIONALITY_RIGHT_TO_LEFT_EMBEDDING\n     * @see Character#DIRECTIONALITY_RIGHT_TO_LEFT_OVERRIDE\n     * @see Character#DIRECTIONALITY_POP_DIRECTIONAL_FORMAT\n     * @see Character#DIRECTIONALITY_LEFT_TO_RIGHT_ISOLATE\n     * @see Character#DIRECTIONALITY_RIGHT_TO_LEFT_ISOLATE\n     * @see Character#DIRECTIONALITY_FIRST_STRONG_ISOLATE\n     * @see Character#DIRECTIONALITY_POP_DIRECTIONAL_ISOLATE\n     * @since 1.4\n     ",
    "links" : [ "#getDirectionality(int)" ]
  }, {
    "name" : "public static byte getDirectionality(int codePoint)",
    "returnType" : "byte",
    "comment" : "\n    public static byte getDirectionality(int codePoint) {\n        return CharacterData.of(codePoint).getDirectionality(codePoint);\n    }\n    ",
    "links" : [ ]
  }, {
    "name" : " static native byte getDirectionalityImpl(int codePoint)",
    "returnType" : "byte",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public static boolean isMirrored(char ch)",
    "returnType" : "boolean",
    "comment" : "\n     * Determines whether the character is mirrored according to the\n     * Unicode specification.  Mirrored characters should have their\n     * glyphs horizontally mirrored when displayed in text that is\n     * right-to-left.  For example, {@code '\\u005Cu0028'} LEFT\n     * PARENTHESIS is semantically defined to be an <i>opening\n     * parenthesis</i>.  This will appear as a \"(\" in text that is\n     * left-to-right but as a \")\" in text that is right-to-left.\n     *\n     * <p><b>Note:</b> This method cannot handle <a\n     * href=\"#supplementary\"> supplementary characters</a>. To support\n     * all Unicode characters, including supplementary characters, use\n     * the {@link #isMirrored(int)} method.\n     *\n     * @param  ch {@code char} for which the mirrored property is requested\n     * @return {@code true} if the char is mirrored, {@code false}\n     *         if the {@code char} is not mirrored or is not defined.\n     * @since 1.4\n     ",
    "links" : [ "#isMirrored(int)" ]
  }, {
    "name" : "public static boolean isMirrored(int codePoint)",
    "returnType" : "boolean",
    "comment" : "\n    public static boolean isMirrored(int codePoint) {\n        return CharacterData.of(codePoint).isMirrored(codePoint);\n    }\n    ",
    "links" : [ ]
  }, {
    "name" : " static native boolean isMirroredImpl(int codePoint)",
    "returnType" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public int compareTo(Character anotherCharacter)",
    "returnType" : "int",
    "comment" : "\n     * Compares two {@code Character} objects numerically.\n     *\n     * @param   anotherCharacter   the {@code Character} to be compared.\n     * @return  the value {@code 0} if the argument {@code Character}\n     *          is equal to this {@code Character}; a value less than\n     *          {@code 0} if this {@code Character} is numerically less\n     *          than the {@code Character} argument; and a value greater than\n     *          {@code 0} if this {@code Character} is numerically greater\n     *          than the {@code Character} argument (unsigned comparison).\n     *          Note that this is strictly a numerical comparison; it is not\n     *          locale-dependent.\n     * @since   1.2\n     ",
    "links" : [ ]
  }, {
    "name" : "public static int compare(char x, char y)",
    "returnType" : "int",
    "comment" : "\n     * Compares two {@code char} values numerically.\n     * The value returned is identical to what would be returned by:\n     * <pre>\n     *    Character.valueOf(x).compareTo(Character.valueOf(y))\n     * </pre>\n     *\n     * @param  x the first {@code char} to compare\n     * @param  y the second {@code char} to compare\n     * @return the value {@code 0} if {@code x == y};\n     *         a value less than {@code 0} if {@code x < y}; and\n     *         a value greater than {@code 0} if {@code x > y}\n     * @since 1.7\n     ",
    "links" : [ ]
  }, {
    "name" : "public static char reverseBytes(char ch)",
    "returnType" : "char",
    "comment" : "\n     * Returns the value obtained by reversing the order of the bytes in the\n     * specified {@code char} value.\n     *\n     * @param ch The {@code char} of which to reverse the byte order.\n     * @return the value obtained by reversing (or, equivalently, swapping)\n     *     the bytes in the specified {@code char} value.\n     * @since 1.5\n     ",
    "links" : [ ]
  }, {
    "name" : "public static String getName(int codePoint)",
    "returnType" : "String",
    "comment" : "\n     * Returns the Unicode name of the specified character\n     * {@code codePoint}, or null if the code point is\n     * {@link #UNASSIGNED unassigned}.\n     * <p>\n     * Note: if the specified character is not assigned a name by\n     * the <i>UnicodeData</i> file (part of the Unicode Character\n     * Database maintained by the Unicode Consortium), the returned\n     * name is the same as the result of expression:\n     *\n     * <blockquote>{@code\n     *     Character.UnicodeBlock.of(codePoint).toString().replace('_', ' ')\n     *     + \" \"\n     *     + Integer.toHexString(codePoint).toUpperCase(Locale.ROOT);\n     *\n     * }</blockquote>\n     *\n     * @param  codePoint the character (Unicode code point)\n     *\n     * @return the Unicode name of the specified character, or null if\n     *         the code point is unassigned.\n     *\n     * @throws IllegalArgumentException if the specified\n     *            {@code codePoint} is not a valid Unicode\n     *            code point.\n     *\n     * @since 1.7\n     ",
    "links" : [ "#UNASSIGNED" ]
  }, {
    "name" : "public static int codePointOf(String name)",
    "returnType" : "int",
    "comment" : "\n     * Returns the code point value of the Unicode character specified by\n     * the given Unicode character name.\n     * <p>\n     * Note: if a character is not assigned a name by the <i>UnicodeData</i>\n     * file (part of the Unicode Character Database maintained by the Unicode\n     * Consortium), its name is defined as the result of expression:\n     *\n     * <blockquote>{@code\n     *     Character.UnicodeBlock.of(codePoint).toString().replace('_', ' ')\n     *     + \" \"\n     *     + Integer.toHexString(codePoint).toUpperCase(Locale.ROOT);\n     *\n     * }</blockquote>\n     * <p>\n     * The {@code name} matching is case insensitive, with any leading and\n     * trailing whitespace character removed.\n     *\n     * @param  name the Unicode character name\n     *\n     * @return the code point value of the character specified by its name.\n     *\n     * @throws IllegalArgumentException if the specified {@code name}\n     *         is not a valid Unicode character name.\n     * @throws NullPointerException if {@code name} is {@code null}\n     *\n     * @since 9\n     ",
    "links" : [ ]
  }, {
    "name" : "private static native String getNameImpl(int codePoint)",
    "returnType" : "String",
    "comment" : " Implement getNameImpl() and codePointOfImpl() natively.",
    "links" : [ ]
  }, {
    "name" : "private static native int codePointOfImpl(String name)",
    "returnType" : "int",
    "comment" : "",
    "links" : [ ]
  } ],
  "methodNames" : [ "public Optional<DynamicConstantDesc<Character>> describeConstable()", "public static Character valueOf(char c)", "public char charValue()", "public int hashCode()", "public static int hashCode(char value)", "public boolean equals(Object obj)", "public String toString()", "public static String toString(char c)", "public static String toString(int codePoint)", "public static boolean isValidCodePoint(int codePoint)", "public static boolean isBmpCodePoint(int codePoint)", "public static boolean isSupplementaryCodePoint(int codePoint)", "public static boolean isHighSurrogate(char ch)", "public static boolean isLowSurrogate(char ch)", "public static boolean isSurrogate(char ch)", "public static boolean isSurrogatePair(char high, char low)", "public static int charCount(int codePoint)", "public static int toCodePoint(char high, char low)", "public static int codePointAt(CharSequence seq, int index)", "public static int codePointAt(char[] a, int index)", "public static int codePointAt(char[] a, int index, int limit)", " static int codePointAtImpl(char[] a, int index, int limit)", "public static int codePointBefore(CharSequence seq, int index)", "public static int codePointBefore(char[] a, int index)", "public static int codePointBefore(char[] a, int index, int start)", " static int codePointBeforeImpl(char[] a, int index, int start)", "public static char highSurrogate(int codePoint)", "public static char lowSurrogate(int codePoint)", "public static int toChars(int codePoint, char[] dst, int dstIndex)", "public static char[] toChars(int codePoint)", " static void toSurrogates(int codePoint, char[] dst, int index)", "public static int codePointCount(CharSequence seq, int beginIndex, int endIndex)", "public static int codePointCount(char[] a, int offset, int count)", " static int codePointCountImpl(char[] a, int offset, int count)", "public static int offsetByCodePoints(CharSequence seq, int index, int codePointOffset)", "public static int offsetByCodePoints(char[] a, int start, int count, int index, int codePointOffset)", " static int offsetByCodePointsImpl(char[] a, int start, int count, int index, int codePointOffset)", "public static boolean isLowerCase(char ch)", "public static boolean isLowerCase(int codePoint)", " static native boolean isLowerCaseImpl(int codePoint)", "public static boolean isUpperCase(char ch)", "public static boolean isUpperCase(int codePoint)", " static native boolean isUpperCaseImpl(int codePoint)", "public static boolean isTitleCase(char ch)", "public static boolean isTitleCase(int codePoint)", " static native boolean isTitleCaseImpl(int codePoint)", "public static boolean isDigit(char ch)", "public static boolean isDigit(int codePoint)", " static native boolean isDigitImpl(int codePoint)", "public static boolean isDefined(char ch)", "public static boolean isDefined(int codePoint)", " static native boolean isDefinedImpl(int codePoint)", "public static boolean isLetter(char ch)", "public static boolean isLetter(int codePoint)", " static native boolean isLetterImpl(int codePoint)", "public static boolean isLetterOrDigit(char ch)", "public static boolean isLetterOrDigit(int codePoint)", " static native boolean isLetterOrDigitImpl(int codePoint)", "public static boolean isJavaLetter(char ch)", "public static boolean isJavaLetterOrDigit(char ch)", "public static boolean isAlphabetic(int codePoint)", " static native boolean isAlphabeticImpl(int codePoint)", "public static boolean isIdeographic(int codePoint)", " static native boolean isIdeographicImpl(int codePoint)", "public static boolean isJavaIdentifierStart(char ch)", "public static boolean isJavaIdentifierStart(int codePoint)", "public static boolean isJavaIdentifierPart(char ch)", "public static boolean isJavaIdentifierPart(int codePoint)", "public static boolean isUnicodeIdentifierStart(char ch)", "public static boolean isUnicodeIdentifierStart(int codePoint)", " static native boolean isUnicodeIdentifierStartImpl(int codePoint)", "public static boolean isUnicodeIdentifierPart(char ch)", "public static boolean isUnicodeIdentifierPart(int codePoint)", " static native boolean isUnicodeIdentifierPartImpl(int codePoint)", "public static boolean isIdentifierIgnorable(char ch)", "public static boolean isIdentifierIgnorable(int codePoint)", " static native boolean isIdentifierIgnorableImpl(int codePoint)", "public static char toLowerCase(char ch)", "public static int toLowerCase(int codePoint)", " static native int toLowerCaseImpl(int codePoint)", "public static char toUpperCase(char ch)", "public static int toUpperCase(int codePoint)", " static native int toUpperCaseImpl(int codePoint)", "public static char toTitleCase(char ch)", "public static int toTitleCase(int codePoint)", " static native int toTitleCaseImpl(int codePoint)", "public static int digit(char ch, int radix)", "public static int digit(int codePoint, int radix)", " static native int digitImpl(int codePoint, int radix)", "public static int getNumericValue(char ch)", "public static int getNumericValue(int codePoint)", " static native int getNumericValueImpl(int codePoint)", "public static boolean isSpace(char ch)", "public static boolean isSpaceChar(char ch)", "public static boolean isSpaceChar(int codePoint)", " static native boolean isSpaceCharImpl(int codePoint)", "public static boolean isWhitespace(char ch)", "public static boolean isWhitespace(int codePoint)", " static native boolean isWhitespaceImpl(int codePoint)", "public static boolean isISOControl(char ch)", "public static boolean isISOControl(int codePoint)", "public static int getType(char ch)", "public static int getType(int codePoint)", " static native int getTypeImpl(int codePoint)", "public static char forDigit(int digit, int radix)", "public static byte getDirectionality(char ch)", "public static byte getDirectionality(int codePoint)", " static native byte getDirectionalityImpl(int codePoint)", "public static boolean isMirrored(char ch)", "public static boolean isMirrored(int codePoint)", " static native boolean isMirroredImpl(int codePoint)", "public int compareTo(Character anotherCharacter)", "public static int compare(char x, char y)", "public static char reverseBytes(char ch)", "public static String getName(int codePoint)", "public static int codePointOf(String name)", "private static native String getNameImpl(int codePoint)", "private static native int codePointOfImpl(String name)" ],
  "variableNames" : [ "MIN_RADIX", "MAX_RADIX", "MIN_VALUE", "MAX_VALUE", "TYPE", "UNASSIGNED", "UPPERCASE_LETTER", "LOWERCASE_LETTER", "TITLECASE_LETTER", "MODIFIER_LETTER", "OTHER_LETTER", "NON_SPACING_MARK", "ENCLOSING_MARK", "COMBINING_SPACING_MARK", "DECIMAL_DIGIT_NUMBER", "LETTER_NUMBER", "OTHER_NUMBER", "SPACE_SEPARATOR", "LINE_SEPARATOR", "PARAGRAPH_SEPARATOR", "CONTROL", "FORMAT", "PRIVATE_USE", "SURROGATE", "DASH_PUNCTUATION", "START_PUNCTUATION", "END_PUNCTUATION", "CONNECTOR_PUNCTUATION", "OTHER_PUNCTUATION", "MATH_SYMBOL", "CURRENCY_SYMBOL", "MODIFIER_SYMBOL", "OTHER_SYMBOL", "INITIAL_QUOTE_PUNCTUATION", "FINAL_QUOTE_PUNCTUATION", "ERROR", "DIRECTIONALITY_UNDEFINED", "DIRECTIONALITY_LEFT_TO_RIGHT", "DIRECTIONALITY_RIGHT_TO_LEFT", "DIRECTIONALITY_RIGHT_TO_LEFT_ARABIC", "DIRECTIONALITY_EUROPEAN_NUMBER", "DIRECTIONALITY_EUROPEAN_NUMBER_SEPARATOR", "DIRECTIONALITY_EUROPEAN_NUMBER_TERMINATOR", "DIRECTIONALITY_ARABIC_NUMBER", "DIRECTIONALITY_COMMON_NUMBER_SEPARATOR", "DIRECTIONALITY_NONSPACING_MARK", "DIRECTIONALITY_BOUNDARY_NEUTRAL", "DIRECTIONALITY_PARAGRAPH_SEPARATOR", "DIRECTIONALITY_SEGMENT_SEPARATOR", "DIRECTIONALITY_WHITESPACE", "DIRECTIONALITY_OTHER_NEUTRALS", "DIRECTIONALITY_LEFT_TO_RIGHT_EMBEDDING", "DIRECTIONALITY_LEFT_TO_RIGHT_OVERRIDE", "DIRECTIONALITY_RIGHT_TO_LEFT_EMBEDDING", "DIRECTIONALITY_RIGHT_TO_LEFT_OVERRIDE", "DIRECTIONALITY_POP_DIRECTIONAL_FORMAT", "DIRECTIONALITY_LEFT_TO_RIGHT_ISOLATE", "DIRECTIONALITY_RIGHT_TO_LEFT_ISOLATE", "DIRECTIONALITY_FIRST_STRONG_ISOLATE", "DIRECTIONALITY_POP_DIRECTIONAL_ISOLATE", "MIN_HIGH_SURROGATE", "MAX_HIGH_SURROGATE", "MIN_LOW_SURROGATE", "MAX_LOW_SURROGATE", "MIN_SURROGATE", "MAX_SURROGATE", "MIN_SUPPLEMENTARY_CODE_POINT", "MIN_CODE_POINT", "MAX_CODE_POINT", "DIRECTIONALITY", "value", "serialVersionUID", "SIZE", "BYTES" ]
}