{
  "filePath" : "/home/maryam/clearblue/files/android-source-35/android/view/SurfaceControl.java",
  "packageName" : "android.view",
  "className" : "Transaction",
  "comment" : "\n     * An atomic set of changes to a set of SurfaceControl.\n     ",
  "links" : [ ],
  "variables" : [ {
    "name" : "sRegistry",
    "type" : "NativeAllocationRegistry",
    "comment" : "\n         * @hide\n         ",
    "links" : [ ]
  }, {
    "name" : "mNativeObject",
    "type" : "long",
    "comment" : "\n         * @hide\n         ",
    "links" : [ ]
  }, {
    "name" : "mResizedSurfaces",
    "type" : "ArrayMap<SurfaceControl, Point>",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mReparentedSurfaces",
    "type" : "ArrayMap<SurfaceControl, SurfaceControl>",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mFreeNativeResources",
    "type" : "Runnable",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "INVALID_COLOR",
    "type" : "float[]",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "CREATOR",
    "type" : "Creator<Transaction>",
    "comment" : "",
    "links" : [ ]
  } ],
  "methods" : [ {
    "name" : "protected void checkPreconditions(SurfaceControl sc)",
    "returnType" : "void",
    "comment" : "\n         * @hide\n         ",
    "links" : [ ]
  }, {
    "name" : "public static void setDefaultApplyToken(IBinder token)",
    "returnType" : "void",
    "comment" : "\n         *\n         * @hide\n         ",
    "links" : [ ]
  }, {
    "name" : "public static IBinder getDefaultApplyToken()",
    "returnType" : "IBinder",
    "comment" : "\n         *\n         * @hide\n         ",
    "links" : [ ]
  }, {
    "name" : "public void apply()",
    "returnType" : "void",
    "comment" : "\n         * Apply the transaction, clearing it's state, and making it usable\n         * as a new transaction.\n         ",
    "links" : [ ]
  }, {
    "name" : "public void applyAsyncUnsafe()",
    "returnType" : "void",
    "comment" : "\n         * Applies the transaction as a one way binder call. This transaction will be applied out\n         * of order with other transactions that are applied synchronously. This method is not\n         * safe. It should only be used when the order does not matter.\n         *\n         * @hide\n         ",
    "links" : [ ]
  }, {
    "name" : "public void clear()",
    "returnType" : "void",
    "comment" : "\n         * Clear the transaction object, without applying it.\n         *\n         * @hide\n         ",
    "links" : [ ]
  }, {
    "name" : "public void close()",
    "returnType" : "void",
    "comment" : "\n         * Release the native transaction object, without applying it.\n         ",
    "links" : [ ]
  }, {
    "name" : "public void apply(boolean sync)",
    "returnType" : "void",
    "comment" : "\n         * Jankier version of apply. Avoid use (b/28068298).\n         * @hide\n         ",
    "links" : [ ]
  }, {
    "name" : "private void apply(boolean sync, boolean oneWay)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "protected void applyResizedSurfaces()",
    "returnType" : "void",
    "comment" : "\n         * @hide\n         ",
    "links" : [ ]
  }, {
    "name" : "protected void notifyReparentedSurfaces()",
    "returnType" : "void",
    "comment" : "\n         * @hide\n         ",
    "links" : [ ]
  }, {
    "name" : "public Transaction setVisibility(@NonNull SurfaceControl sc, boolean visible)",
    "returnType" : "Transaction",
    "comment" : "\n         * Toggle the visibility of a given Layer and it's sub-tree.\n         *\n         * @param sc The SurfaceControl for which to set the visibility\n         * @param visible The new visibility\n         * @return This transaction object.\n         ",
    "links" : [ ]
  }, {
    "name" : "public Transaction setFrameRateSelectionPriority(@NonNull SurfaceControl sc, int priority)",
    "returnType" : "Transaction",
    "comment" : "\n         * This information is passed to SurfaceFlinger to decide which window should have a\n         * priority when deciding about the refresh rate of the display. All windows have the\n         * lowest priority by default.\n         * @hide\n         ",
    "links" : [ ]
  }, {
    "name" : "public Transaction show(SurfaceControl sc)",
    "returnType" : "Transaction",
    "comment" : "\n         * Request that a given surface and it's sub-tree be shown.\n         *\n         * @param sc The surface to show.\n         * @return This transaction.\n         * @hide\n         ",
    "links" : [ ]
  }, {
    "name" : "public Transaction hide(SurfaceControl sc)",
    "returnType" : "Transaction",
    "comment" : "\n         * Request that a given surface and it's sub-tree be hidden.\n         *\n         * @param sc The surface to hidden.\n         * @return This transaction.\n         * @hide\n         ",
    "links" : [ ]
  }, {
    "name" : "public Transaction setPosition(@NonNull SurfaceControl sc, float x, float y)",
    "returnType" : "Transaction",
    "comment" : "\n         * Sets the SurfaceControl to the specified position relative to the parent\n         * SurfaceControl\n         *\n         * @param sc The SurfaceControl to change position\n         * @param x the X position\n         * @param y the Y position\n         * @return this transaction\n         ",
    "links" : [ ]
  }, {
    "name" : "public Transaction setScale(@NonNull SurfaceControl sc, float scaleX, float scaleY)",
    "returnType" : "Transaction",
    "comment" : "\n         * Sets the SurfaceControl to the specified scale with (0, 0) as the center point\n         * of the scale.\n         *\n         * @param sc The SurfaceControl to change scale\n         * @param scaleX the X scale\n         * @param scaleY the Y scale\n         * @return this transaction\n         ",
    "links" : [ ]
  }, {
    "name" : "public Transaction setBufferSize(@NonNull SurfaceControl sc, @IntRange(from = 0) int w, @IntRange(from = 0) int h)",
    "returnType" : "Transaction",
    "comment" : "\n         * Set the default buffer size for the SurfaceControl, if there is a\n         * {@link Surface} associated with the control, then\n         * this will be the default size for buffers dequeued from it.\n         * @param sc The surface to set the buffer size for.\n         * @param w The default width\n         * @param h The default height\n         * @return This Transaction\n         ",
    "links" : [ "android.view.Surface" ]
  }, {
    "name" : "public Transaction setFixedTransformHint(@NonNull SurfaceControl sc, @Surface.Rotation int transformHint)",
    "returnType" : "Transaction",
    "comment" : "\n         * Provide the graphic producer a transform hint if the layer and its children are\n         * in an orientation different from the display's orientation. The caller is responsible\n         * for clearing this transform hint if the layer is no longer in a fixed orientation.\n         *\n         * The transform hint is used to prevent allocating a buffer of different size when a\n         * layer is rotated. The producer can choose to consume the hint and allocate the buffer\n         * with the same size.\n         *\n         * @return This Transaction.\n         * @hide\n         ",
    "links" : [ ]
  }, {
    "name" : "public Transaction unsetFixedTransformHint(@NonNull SurfaceControl sc)",
    "returnType" : "Transaction",
    "comment" : "\n         * Clearing any transform hint if set on this layer.\n         *\n         * @return This Transaction.\n         * @hide\n         ",
    "links" : [ ]
  }, {
    "name" : "public Transaction setLayer(@NonNull SurfaceControl sc, @IntRange(from = Integer.MIN_VALUE, to = Integer.MAX_VALUE) int z)",
    "returnType" : "Transaction",
    "comment" : "\n         * Set the Z-order for a given SurfaceControl, relative to it's siblings.\n         * If two siblings share the same Z order the ordering is undefined. Surfaces\n         * with a negative Z will be placed below the parent surface.\n         *\n         * @param sc The SurfaceControl to set the Z order on\n         * @param z The Z-order\n         * @return This Transaction.\n         ",
    "links" : [ ]
  }, {
    "name" : "public Transaction setRelativeLayer(SurfaceControl sc, SurfaceControl relativeTo, int z)",
    "returnType" : "Transaction",
    "comment" : "\n         * @hide\n         ",
    "links" : [ ]
  }, {
    "name" : "public Transaction setTransparentRegionHint(SurfaceControl sc, Region transparentRegion)",
    "returnType" : "Transaction",
    "comment" : "\n         * @hide\n         ",
    "links" : [ ]
  }, {
    "name" : "public Transaction setAlpha(@NonNull SurfaceControl sc, @FloatRange(from = 0.0, to = 1.0) float alpha)",
    "returnType" : "Transaction",
    "comment" : "\n         * Set the alpha for a given surface. If the alpha is non-zero the SurfaceControl\n         * will be blended with the Surfaces under it according to the specified ratio.\n         *\n         * @param sc The given SurfaceControl.\n         * @param alpha The alpha to set.\n         ",
    "links" : [ ]
  }, {
    "name" : "public Transaction setInputWindowInfo(SurfaceControl sc, InputWindowHandle handle)",
    "returnType" : "Transaction",
    "comment" : "\n         * @hide\n         ",
    "links" : [ ]
  }, {
    "name" : "public Transaction addWindowInfosReportedListener(@NonNull Runnable listener)",
    "returnType" : "Transaction",
    "comment" : "\n         * Adds a callback that is called after WindowInfosListeners from the systems server are\n         * complete. This is primarily used to ensure that InputDispatcher::setInputWindowsLocked\n         * has been called before running the added callback.\n         *\n         * @hide\n         ",
    "links" : [ ]
  }, {
    "name" : "public Transaction setGeometry(@NonNull SurfaceControl sc, @Nullable Rect sourceCrop, @Nullable Rect destFrame, @Surface.Rotation int orientation)",
    "returnType" : "Transaction",
    "comment" : "\n         * Specify how the buffer associated with this Surface is mapped in to the\n         * parent coordinate space. The source frame will be scaled to fit the destination\n         * frame, after being rotated according to the orientation parameter.\n         *\n         * @param sc The SurfaceControl to specify the geometry of\n         * @param sourceCrop The source rectangle in buffer space. Or null for the entire buffer.\n         * @param destFrame The destination rectangle in parent space. Or null for the source frame.\n         * @param orientation The buffer rotation\n         * @return This transaction object.\n         * @deprecated Use {@link #setCrop(SurfaceControl, Rect)},\n         * {@link #setBufferTransform(SurfaceControl, int)},\n         * {@link #setPosition(SurfaceControl, float, float)} and\n         * {@link #setScale(SurfaceControl, float, float)} instead.\n         ",
    "links" : [ "#setScale(SurfaceControl", "#setCrop(SurfaceControl", "#setPosition(SurfaceControl", "#setBufferTransform(SurfaceControl" ]
  }, {
    "name" : "public Transaction setMatrix(SurfaceControl sc, float dsdx, float dtdx, float dtdy, float dsdy)",
    "returnType" : "Transaction",
    "comment" : "\n         * @hide\n         ",
    "links" : [ ]
  }, {
    "name" : "public Transaction setMatrix(SurfaceControl sc, Matrix matrix, float[] float9)",
    "returnType" : "Transaction",
    "comment" : "\n         * Sets the transform and position of a {@link SurfaceControl} from a 3x3 transformation\n         * matrix.\n         *\n         * @param sc     SurfaceControl to set matrix of\n         * @param matrix The matrix to apply.\n         * @param float9 An array of 9 floats to be used to extract the values from the matrix.\n         * @hide\n         ",
    "links" : [ "android.view.SurfaceControl" ]
  }, {
    "name" : "public Transaction setColorTransform(SurfaceControl sc, @Size(9) float[] matrix, @Size(3) float[] translation)",
    "returnType" : "Transaction",
    "comment" : "\n         * Sets the color transform for the Surface.\n         *\n         * @param sc          SurfaceControl to set color transform of\n         * @param matrix      A float array with 9 values represents a 3x3 transform matrix\n         * @param translation A float array with 3 values represents a translation vector\n         * @hide\n         ",
    "links" : [ ]
  }, {
    "name" : "public Transaction setColorSpaceAgnostic(SurfaceControl sc, boolean agnostic)",
    "returnType" : "Transaction",
    "comment" : "\n         * Sets the Surface to be color space agnostic. If a surface is color space agnostic,\n         * the color can be interpreted in any color space.\n         * @param agnostic A boolean to indicate whether the surface is color space agnostic\n         * @hide\n         ",
    "links" : [ ]
  }, {
    "name" : "public Transaction setWindowCrop(SurfaceControl sc, Rect crop)",
    "returnType" : "Transaction",
    "comment" : "\n         * Bounds the surface and its children to the bounds specified. Size of the surface will be\n         * ignored and only the crop and buffer size will be used to determine the bounds of the\n         * surface. If no crop is specified and the surface has no buffer, the surface bounds is\n         * only constrained by the size of its parent bounds.\n         *\n         * @param sc   SurfaceControl to set crop of.\n         * @param crop Bounds of the crop to apply.\n         * @hide\n         * @deprecated Use {@link #setCrop(SurfaceControl, Rect)} instead.\n         ",
    "links" : [ "#setCrop(SurfaceControl" ]
  }, {
    "name" : "public Transaction setCrop(@NonNull SurfaceControl sc, @Nullable Rect crop)",
    "returnType" : "Transaction",
    "comment" : "\n         * Bounds the surface and its children to the bounds specified. Size of the surface will be\n         * ignored and only the crop and buffer size will be used to determine the bounds of the\n         * surface. If no crop is specified and the surface has no buffer, the surface bounds is\n         * only constrained by the size of its parent bounds.\n         *\n         * @param sc   SurfaceControl to set crop of.\n         * @param crop Bounds of the crop to apply.\n         * @return this This transaction for chaining\n         ",
    "links" : [ ]
  }, {
    "name" : "public Transaction setWindowCrop(SurfaceControl sc, int width, int height)",
    "returnType" : "Transaction",
    "comment" : "\n         * Same as {@link Transaction#setWindowCrop(SurfaceControl, Rect)} but sets the crop rect\n         * top left at 0, 0.\n         *\n         * @param sc     SurfaceControl to set crop of.\n         * @param width  width of crop rect\n         * @param height height of crop rect\n         * @hide\n         ",
    "links" : [ "#setWindowCrop(SurfaceControl" ]
  }, {
    "name" : "public Transaction setCornerRadius(SurfaceControl sc, float cornerRadius)",
    "returnType" : "Transaction",
    "comment" : "\n         * Sets the corner radius of a {@link SurfaceControl}.\n         * @param sc SurfaceControl\n         * @param cornerRadius Corner radius in pixels.\n         * @return Itself.\n         * @hide\n         ",
    "links" : [ "android.view.SurfaceControl" ]
  }, {
    "name" : "public Transaction setBackgroundBlurRadius(SurfaceControl sc, int radius)",
    "returnType" : "Transaction",
    "comment" : "\n         * Sets the background blur radius of the {@link SurfaceControl}.\n         *\n         * @param sc SurfaceControl.\n         * @param radius Blur radius in pixels.\n         * @return itself.\n         * @hide\n         ",
    "links" : [ "android.view.SurfaceControl" ]
  }, {
    "name" : "public Transaction setBlurRegions(SurfaceControl sc, float[][] regions)",
    "returnType" : "Transaction",
    "comment" : "\n         * Specify what regions should be blurred on the {@link SurfaceControl}.\n         *\n         * @param sc SurfaceControl.\n         * @param regions List of regions that will have blurs.\n         * @return itself.\n         * @see BlurRegion#toFloatArray()\n         * @hide\n         ",
    "links" : [ "android.view.SurfaceControl" ]
  }, {
    "name" : "public Transaction setStretchEffect(SurfaceControl sc, float width, float height, float vecX, float vecY, float maxStretchAmountX, float maxStretchAmountY, float childRelativeLeft, float childRelativeTop, float childRelativeRight, float childRelativeBottom)",
    "returnType" : "Transaction",
    "comment" : "\n         * @hide\n         ",
    "links" : [ ]
  }, {
    "name" : "public Transaction setLayerStack(SurfaceControl sc, int layerStack)",
    "returnType" : "Transaction",
    "comment" : "\n         * @hide\n         ",
    "links" : [ ]
  }, {
    "name" : "public Transaction reparent(@NonNull SurfaceControl sc, @Nullable SurfaceControl newParent)",
    "returnType" : "Transaction",
    "comment" : "\n         * Re-parents a given layer to a new parent. Children inherit transform (position, scaling)\n         * crop, visibility, and Z-ordering from their parents, as if the children were pixels within the\n         * parent Surface.\n         *\n         * @param sc The SurfaceControl to reparent\n         * @param newParent The new parent for the given control.\n         * @return This Transaction\n         ",
    "links" : [ ]
  }, {
    "name" : "public Transaction setColor(SurfaceControl sc, @Size(3) float[] color)",
    "returnType" : "Transaction",
    "comment" : "\n         * Fills the surface with the specified color.\n         * @param color A float array with three values to represent r, g, b in range [0..1]. An\n         * invalid color will remove the color fill.\n         * @hide\n         ",
    "links" : [ ]
  }, {
    "name" : "public Transaction unsetColor(SurfaceControl sc)",
    "returnType" : "Transaction",
    "comment" : "\n         * Removes color fill.\n        * @hide\n        ",
    "links" : [ ]
  }, {
    "name" : "public Transaction setSecure(SurfaceControl sc, boolean isSecure)",
    "returnType" : "Transaction",
    "comment" : "\n         * Sets the security of the surface.  Setting the flag is equivalent to creating the\n         * Surface with the {@link #SECURE} flag.\n         * @hide\n         ",
    "links" : [ "#SECURE" ]
  }, {
    "name" : "public Transaction setDisplayDecoration(SurfaceControl sc, boolean displayDecoration)",
    "returnType" : "Transaction",
    "comment" : "\n         * Sets whether the surface should take advantage of display decoration optimizations.\n         * @hide\n         ",
    "links" : [ ]
  }, {
    "name" : "public Transaction setOpaque(@NonNull SurfaceControl sc, boolean isOpaque)",
    "returnType" : "Transaction",
    "comment" : "\n         * Indicates whether the surface must be considered opaque, even if its pixel format is\n         * set to translucent. This can be useful if an application needs full RGBA 8888 support\n         * for instance but will still draw every pixel opaque.\n         * <p>\n         * This flag only determines whether opacity will be sampled from the alpha channel.\n         * Plane-alpha from calls to setAlpha() can still result in blended composition\n         * regardless of the opaque setting.\n         *\n         * Combined effects are (assuming a buffer format with an alpha channel):\n         * <ul>\n         * <li>OPAQUE + alpha(1.0) == opaque composition\n         * <li>OPAQUE + alpha(0.x) == blended composition\n         * <li>OPAQUE + alpha(0.0) == no composition\n         * <li>!OPAQUE + alpha(1.0) == blended composition\n         * <li>!OPAQUE + alpha(0.x) == blended composition\n         * <li>!OPAQUE + alpha(0.0) == no composition\n         * </ul>\n         * If the underlying buffer lacks an alpha channel, it is as if setOpaque(true)\n         * were set automatically.\n         *\n         * @see Builder#setOpaque(boolean)\n         *\n         * @param sc The SurfaceControl to update\n         * @param isOpaque true if the buffer's alpha should be ignored, false otherwise\n         * @return this\n         ",
    "links" : [ ]
  }, {
    "name" : "public Transaction setDisplaySurface(IBinder displayToken, Surface surface)",
    "returnType" : "Transaction",
    "comment" : "\n         * @hide\n         ",
    "links" : [ ]
  }, {
    "name" : "public Transaction setDisplayLayerStack(IBinder displayToken, int layerStack)",
    "returnType" : "Transaction",
    "comment" : "\n         * @hide\n         ",
    "links" : [ ]
  }, {
    "name" : "public Transaction setDisplayFlags(IBinder displayToken, int flags)",
    "returnType" : "Transaction",
    "comment" : "\n         * @hide\n         ",
    "links" : [ ]
  }, {
    "name" : "public Transaction setDisplayProjection(IBinder displayToken, int orientation, Rect layerStackRect, Rect displayRect)",
    "returnType" : "Transaction",
    "comment" : "\n         * @hide\n         ",
    "links" : [ ]
  }, {
    "name" : "public Transaction setDisplaySize(IBinder displayToken, int width, int height)",
    "returnType" : "Transaction",
    "comment" : "\n         * @hide\n         ",
    "links" : [ ]
  }, {
    "name" : "public Transaction setAnimationTransaction()",
    "returnType" : "Transaction",
    "comment" : " flag the transaction as an animation\n         * @hide\n         ",
    "links" : [ ]
  }, {
    "name" : "public Transaction setEarlyWakeupStart()",
    "returnType" : "Transaction",
    "comment" : "\n          * Provides a hint to SurfaceFlinger to change its offset so that SurfaceFlinger wakes up\n          * earlier to compose surfaces. The caller should use this as a hint to SurfaceFlinger\n          * when the scene is complex enough to use GPU composition. The hint will remain active\n          * until until the client calls {@link Transaction#setEarlyWakeupEnd}.\n          *\n          * @hide\n          ",
    "links" : [ "#setEarlyWakeupEnd" ]
  }, {
    "name" : "public Transaction setEarlyWakeupEnd()",
    "returnType" : "Transaction",
    "comment" : "\n         * Removes the early wake up hint set by {@link Transaction#setEarlyWakeupStart}.\n         *\n         * @hide\n         ",
    "links" : [ "#setEarlyWakeupStart" ]
  }, {
    "name" : "public long getId()",
    "returnType" : "long",
    "comment" : "\n         * @hide\n         * @return The transaction's current id.\n         *         The id changed every time the transaction is applied.\n         ",
    "links" : [ ]
  }, {
    "name" : "public Transaction setMetadata(SurfaceControl sc, int key, int data)",
    "returnType" : "Transaction",
    "comment" : "\n         * Sets an arbitrary piece of metadata on the surface. This is a helper for int data.\n         * @hide\n         ",
    "links" : [ ]
  }, {
    "name" : "public Transaction setMetadata(SurfaceControl sc, int key, Parcel data)",
    "returnType" : "Transaction",
    "comment" : "\n         * Sets an arbitrary piece of metadata on the surface.\n         * @hide\n         ",
    "links" : [ ]
  }, {
    "name" : "public Transaction setShadowRadius(SurfaceControl sc, float shadowRadius)",
    "returnType" : "Transaction",
    "comment" : "\n          * Draws shadows of length {@code shadowRadius} around the surface {@link SurfaceControl}.\n          * If the length is 0.0f then the shadows will not be drawn.\n          *\n          * Shadows are drawn around the screen bounds, these are the post transformed cropped\n          * bounds. They can draw over their parent bounds and will be occluded by layers with a\n          * higher z-order. The shadows will respect the surface's corner radius if the\n          * rounded corner bounds (transformed source bounds) are within the screen bounds.\n          *\n          * A shadow will only be drawn on buffer and color layers. If the radius is applied on a\n          * container layer, it will be passed down the hierarchy to be applied on buffer and color\n          * layers but not its children. A scenario where this is useful is when SystemUI animates\n          * a task by controlling a leash to it, can draw a shadow around the app surface by\n          * setting a shadow on the leash. This is similar to how rounded corners are set.\n          *\n          * @hide\n          ",
    "links" : [ "android.view.SurfaceControl" ]
  }, {
    "name" : "public Transaction setFrameRate(@NonNull SurfaceControl sc, @FloatRange(from = 0.0) float frameRate, @Surface.FrameRateCompatibility int compatibility)",
    "returnType" : "Transaction",
    "comment" : "\n         * Sets the intended frame rate for this surface. Any switching of refresh rates is\n         * most probably going to be seamless.\n         *\n         * @see #setFrameRate(SurfaceControl, float, int, int)\n         ",
    "links" : [ ]
  }, {
    "name" : "public Transaction setFrameRate(@NonNull SurfaceControl sc, @FloatRange(from = 0.0) float frameRate, @Surface.FrameRateCompatibility int compatibility, @Surface.ChangeFrameRateStrategy int changeFrameRateStrategy)",
    "returnType" : "Transaction",
    "comment" : "\n         * Sets the intended frame rate for the surface {@link SurfaceControl}.\n         * <p>\n         * On devices that are capable of running the display at different refresh rates, the system\n         * may choose a display refresh rate to better match this surface's frame rate. Usage of\n         * this API won't directly affect the application's frame production pipeline. However,\n         * because the system may change the display refresh rate, calls to this function may result\n         * in changes to Choreographer callback timings, and changes to the time interval at which\n         * the system releases buffers back to the application.\n         * <p>\n         * Note that this only has an effect for surfaces presented on the display. If this\n         * surface is consumed by something other than the system compositor, e.g. a media\n         * codec, this call has no effect.\n         *\n         * @param sc The SurfaceControl to specify the frame rate of.\n         * @param frameRate The intended frame rate for this surface, in frames per second. 0 is a\n         *                  special value that indicates the app will accept the system's choice for\n         *                  the display frame rate, which is the default behavior if this function\n         *                  isn't called. The <code>frameRate</code> param does <em>not</em> need\n         *                  to be a valid refresh rate for this device's display - e.g., it's fine\n         *                  to pass 30fps to a device that can only run the display at 60fps.\n         * @param compatibility The frame rate compatibility of this surface. The compatibility\n         *                      value may influence the system's choice of display frame rate.\n         *                      This parameter is ignored when <code>frameRate</code> is 0.\n         * @param changeFrameRateStrategy Whether display refresh rate transitions caused by this\n         *                                surface should be seamless. A seamless transition is one\n         *                                that doesn't have any visual interruptions, such as a\n         *                                black screen for a second or two. This parameter is\n         *                                ignored when <code>frameRate</code> is 0.\n         * @return This transaction object.\n         *\n         * @see #clearFrameRate(SurfaceControl)\n         ",
    "links" : [ "android.view.SurfaceControl" ]
  }, {
    "name" : "public Transaction clearFrameRate(@NonNull SurfaceControl sc)",
    "returnType" : "Transaction",
    "comment" : "\n         * Clears the frame rate which was set for the surface {@link SurfaceControl}.\n         *\n         * <p>This is equivalent to calling {@link #setFrameRate(SurfaceControl, float, int, int)}\n         * using {@code 0} for {@code frameRate}.\n         * <p>\n         * Note that this only has an effect for surfaces presented on the display. If this\n         * surface is consumed by something other than the system compositor, e.g. a media\n         * codec, this call has no effect.\n         *\n         * @param sc The SurfaceControl to clear the frame rate of.\n         * @return This transaction object.\n         *\n         * @see #setFrameRate(SurfaceControl, float, int)\n         ",
    "links" : [ "android.view.SurfaceControl", "#setFrameRate(SurfaceControl" ]
  }, {
    "name" : "public Transaction setDefaultFrameRateCompatibility(@NonNull SurfaceControl sc, @Surface.FrameRateCompatibility int compatibility)",
    "returnType" : "Transaction",
    "comment" : "\n         * Sets the default frame rate compatibility for the surface {@link SurfaceControl}\n         *\n         * @param sc The SurfaceControl to specify the frame rate of.\n         * @param compatibility The frame rate compatibility of this surface. The compatibility\n         *               value may influence the system's choice of display frame rate.\n         *\n         * @return This transaction object.\n         *\n         * @hide\n         ",
    "links" : [ "android.view.SurfaceControl" ]
  }, {
    "name" : "public Transaction setFrameRateCategory(@NonNull SurfaceControl sc, @Surface.FrameRateCategory int category, boolean smoothSwitchOnly)",
    "returnType" : "Transaction",
    "comment" : "\n         * Sets the frame rate category for the {@link SurfaceControl}.\n         *\n         * This helps instruct the system on choosing a display refresh rate based on the surface's\n         * chosen category, which is a device-specific range of frame rates.\n         * {@link #setFrameRateCategory} should be used by components such as animations that do not\n         * require an exact frame rate, but has an opinion on an approximate desirable frame rate.\n         * The values of {@code category} gives example use cases for which category to choose.\n         *\n         * To instead specify an exact frame rate, use\n         * {@link #setFrameRate(SurfaceControl, float, int, int)}, which is more suitable for\n         * content that knows specifically which frame rate is optimal.\n         * Although not a common use case, {@link #setFrameRateCategory} and {@link #setFrameRate}\n         * can be called together, with both calls potentially influencing the display refresh rate.\n         * For example, considering only one {@link SurfaceControl}: if {@link #setFrameRate}'s\n         * value is 24 and {@link #setFrameRateCategory}'s value is\n         * {@link Surface#FRAME_RATE_CATEGORY_HIGH}, defined to be the range [90,120] fps for an\n         * example device, then the best refresh rate for the SurfaceControl should be 120 fps.\n         * This is because 120 fps is a multiple of 24 fps, and 120 fps is in the specified\n         * category's range.\n         *\n         * @param sc The SurfaceControl to specify the frame rate category of.\n         * @param category The frame rate category of this surface. The category value may influence\n         * the system's choice of display frame rate.\n         * @param smoothSwitchOnly Set to {@code true} to indicate the display frame rate should not\n         * change if changing it would cause jank. Else {@code false}.\n         * This parameter is ignored when {@code category} is\n         * {@link Surface#FRAME_RATE_CATEGORY_DEFAULT}.\n         *\n         * @return This transaction object.\n         *\n         * @see #setFrameRate(SurfaceControl, float, int, int)\n         *\n         * @hide\n         ",
    "links" : [ "#setFrameRateCategory", "android.view.Surface#FRAME_RATE_CATEGORY_HIGH", "#setFrameRate", "android.view.SurfaceControl", "android.view.Surface#FRAME_RATE_CATEGORY_DEFAULT", "#setFrameRate(SurfaceControl" ]
  }, {
    "name" : "public Transaction setFrameRateSelectionStrategy(@NonNull SurfaceControl sc, @FrameRateSelectionStrategy int strategy)",
    "returnType" : "Transaction",
    "comment" : "\n         * Sets the frame rate selection strategy for the {@link SurfaceControl}.\n         *\n         * This instructs the system on how to choose a display refresh rate, following the\n         * strategy for the layer's frame rate specifications relative to other layers'.\n         *\n         * @param sc The SurfaceControl to specify the frame rate category of.\n         * @param strategy The frame rate selection strategy.\n         *\n         * @return This transaction object.\n         *\n         * @see #setFrameRate(SurfaceControl, float, int, int)\n         * @see #setFrameRateCategory(SurfaceControl, int)\n         * @see #setDefaultFrameRateCompatibility(SurfaceControl, int)\n         *\n         * @hide\n         ",
    "links" : [ "android.view.SurfaceControl" ]
  }, {
    "name" : "public Transaction setFocusedWindow(@NonNull IBinder token, String windowName, int displayId)",
    "returnType" : "Transaction",
    "comment" : "\n         * Sets focus on the window identified by the input {@code token} if the window is focusable\n         * otherwise the request is dropped.\n         *\n         * If the window is not visible, the request will be queued until the window becomes\n         * visible or the request is overrriden by another request. The currently focused window\n         * will lose focus immediately. This is to send the newly focused window any focus\n         * dispatched events that occur while it is completing its first draw.\n         *\n         * @hide\n         ",
    "links" : [ ]
  }, {
    "name" : "public Transaction removeCurrentInputFocus(int displayId)",
    "returnType" : "Transaction",
    "comment" : "\n         * Removes the input focus from the current window which is having the input focus. Should\n         * only be called when the current focused app is not responding and the current focused\n         * window is not beloged to the current focused app.\n         * @hide\n         ",
    "links" : [ ]
  }, {
    "name" : "public Transaction setSkipScreenshot(SurfaceControl sc, boolean skipScrenshot)",
    "returnType" : "Transaction",
    "comment" : "\n         * Adds or removes the flag SKIP_SCREENSHOT of the surface.  Setting the flag is equivalent\n         * to creating the Surface with the {@link #SKIP_SCREENSHOT} flag.\n         *\n         * @hide\n         ",
    "links" : [ "#SKIP_SCREENSHOT" ]
  }, {
    "name" : "public Transaction setBuffer(SurfaceControl sc, GraphicBuffer buffer)",
    "returnType" : "Transaction",
    "comment" : "\n         * Set a buffer for a SurfaceControl. This can only be used for SurfaceControls that were\n         * created as type {@link #FX_SURFACE_BLAST}\n         *\n         * @hide\n         * @deprecated Use {@link #setBuffer(SurfaceControl, HardwareBuffer)} instead\n         ",
    "links" : [ "#setBuffer(SurfaceControl", "#FX_SURFACE_BLAST" ]
  }, {
    "name" : "public Transaction setBuffer(@NonNull SurfaceControl sc, @Nullable HardwareBuffer buffer)",
    "returnType" : "Transaction",
    "comment" : "\n         * Updates the HardwareBuffer displayed for the SurfaceControl.\n         *\n         * Note that the buffer must be allocated with {@link HardwareBuffer#USAGE_COMPOSER_OVERLAY}\n         * as well as {@link HardwareBuffer#USAGE_GPU_SAMPLED_IMAGE} as the surface control might\n         * be composited using either an overlay or using the GPU.\n         *\n         * @param sc The SurfaceControl to update\n         * @param buffer The buffer to be displayed\n         * @return this\n         ",
    "links" : [ "android.hardware.HardwareBuffer#USAGE_COMPOSER_OVERLAY", "android.hardware.HardwareBuffer#USAGE_GPU_SAMPLED_IMAGE" ]
  }, {
    "name" : "public Transaction unsetBuffer(SurfaceControl sc)",
    "returnType" : "Transaction",
    "comment" : "\n         * Unsets the buffer for the SurfaceControl in the current Transaction. This will not clear\n         * the buffer being rendered, but resets the buffer state in the Transaction only. The call\n         * will also invoke the release callback.\n         *\n         * Note, this call is different from passing a null buffer to\n         * {@link SurfaceControl.Transaction#setBuffer} which will release the last displayed\n         * buffer.\n         *\n         * @hide\n         ",
    "links" : [ "SurfaceControl.Transaction#setBuffer" ]
  }, {
    "name" : "public Transaction setBuffer(@NonNull SurfaceControl sc, @Nullable HardwareBuffer buffer, @Nullable SyncFence fence)",
    "returnType" : "Transaction",
    "comment" : "\n         * Updates the HardwareBuffer displayed for the SurfaceControl.\n         *\n         * Note that the buffer must be allocated with {@link HardwareBuffer#USAGE_COMPOSER_OVERLAY}\n         * as well as {@link HardwareBuffer#USAGE_GPU_SAMPLED_IMAGE} as the surface control might\n         * be composited using either an overlay or using the GPU.\n         *\n         * A presentation fence may be passed to improve performance by allowing the buffer\n         * to complete rendering while it is waiting for the transaction to be applied.\n         * For example, if the buffer is being produced by rendering with OpenGL ES then\n         * a fence created with\n         * {@link android.opengl.EGLExt#eglDupNativeFenceFDANDROID(EGLDisplay, EGLSync)} can be\n         * used to allow the GPU rendering to be concurrent with the transaction. The compositor\n         * will wait for the fence to be signaled before the buffer is displayed. If multiple\n         * buffers are set as part of the same transaction, the presentation fences of all of them\n         * must signal before any buffer is displayed. That is, the entire transaction is delayed\n         * until all presentation fences have signaled, ensuring the transaction remains consistent.\n         *\n         * @param sc The SurfaceControl to update\n         * @param buffer The buffer to be displayed. Pass in a null buffer to release the last\n         * displayed buffer.\n         * @param fence The presentation fence. If null or invalid, this is equivalent to\n         *              {@link #setBuffer(SurfaceControl, HardwareBuffer)}\n         * @return this\n         ",
    "links" : [ "#setBuffer(SurfaceControl", "android.hardware.HardwareBuffer#USAGE_COMPOSER_OVERLAY", "android.opengl.EGLExt#eglDupNativeFenceFDANDROID(EGLDisplay", "android.hardware.HardwareBuffer#USAGE_GPU_SAMPLED_IMAGE" ]
  }, {
    "name" : "public Transaction setBuffer(@NonNull SurfaceControl sc, @Nullable HardwareBuffer buffer, @Nullable SyncFence fence, @Nullable Consumer<SyncFence> releaseCallback)",
    "returnType" : "Transaction",
    "comment" : "\n         * Updates the HardwareBuffer displayed for the SurfaceControl.\n         *\n         * Note that the buffer must be allocated with {@link HardwareBuffer#USAGE_COMPOSER_OVERLAY}\n         * as well as {@link HardwareBuffer#USAGE_GPU_SAMPLED_IMAGE} as the surface control might\n         * be composited using either an overlay or using the GPU.\n         *\n         * A presentation fence may be passed to improve performance by allowing the buffer\n         * to complete rendering while it is waiting for the transaction to be applied.\n         * For example, if the buffer is being produced by rendering with OpenGL ES then\n         * a fence created with\n         * {@link android.opengl.EGLExt#eglDupNativeFenceFDANDROID(EGLDisplay, EGLSync)} can be\n         * used to allow the GPU rendering to be concurrent with the transaction. The compositor\n         * will wait for the fence to be signaled before the buffer is displayed. If multiple\n         * buffers are set as part of the same transaction, the presentation fences of all of them\n         * must signal before any buffer is displayed. That is, the entire transaction is delayed\n         * until all presentation fences have signaled, ensuring the transaction remains consistent.\n         *\n         * A releaseCallback may be passed to know when the buffer is safe to be reused. This\n         * is recommended when attempting to render continuously using SurfaceControl transactions\n         * instead of through {@link Surface}, as it provides a safe & reliable way to know when\n         * a buffer can be re-used. The callback will be invoked with a {@link SyncFence} which,\n         * if {@link SyncFence#isValid() valid}, must be waited on prior to using the buffer. This\n         * can either be done directly with {@link SyncFence#awaitForever()} or it may be done\n         * indirectly such as passing it as a release fence to\n         * {@link android.media.Image#setFence(SyncFence)} when using\n         * {@link android.media.ImageReader}.\n         *\n         * @param sc The SurfaceControl to update\n         * @param buffer The buffer to be displayed\n         * @param fence The presentation fence. If null or invalid, this is equivalent to\n         *              {@link #setBuffer(SurfaceControl, HardwareBuffer)}\n         * @param releaseCallback The callback to invoke when the buffer being set has been released\n         *                        by a later transaction. That is, the point at which it is safe\n         *                        to re-use the buffer.\n         * @return this\n         ",
    "links" : [ "#setBuffer(SurfaceControl", "android.hardware.HardwareBuffer#USAGE_COMPOSER_OVERLAY", "android.view.Surface", "android.opengl.EGLExt#eglDupNativeFenceFDANDROID(EGLDisplay", "android.hardware.SyncFence#awaitForever()", "android.media.Image#setFence(SyncFence)", "android.media.ImageReader", "android.hardware.HardwareBuffer#USAGE_GPU_SAMPLED_IMAGE", "android.hardware.SyncFence#isValid()", "android.hardware.SyncFence" ]
  }, {
    "name" : "public Transaction setBufferTransform(@NonNull SurfaceControl sc, @SurfaceControl.BufferTransform int transform)",
    "returnType" : "Transaction",
    "comment" : "\n         * Sets the buffer transform that should be applied to the current buffer.\n         *\n         * This can be used in combination with\n         * {@link AttachedSurfaceControl#addOnBufferTransformHintChangedListener(AttachedSurfaceControl.OnBufferTransformHintChangedListener)}\n         * to pre-rotate the buffer for the current display orientation. This can\n         * improve the performance of displaying the associated buffer.\n         *\n         * @param sc The SurfaceControl to update\n         * @param transform The transform to apply to the buffer.\n         * @return this\n         ",
    "links" : [ "android.view.AttachedSurfaceControl#addOnBufferTransformHintChangedListener(AttachedSurfaceControl.OnBufferTransformHintChangedListener)" ]
  }, {
    "name" : "public Transaction setDamageRegion(@NonNull SurfaceControl sc, @Nullable Region region)",
    "returnType" : "Transaction",
    "comment" : "\n         * Updates the region for the content on this surface updated in this transaction. The\n         * damage region is the area of the buffer that has changed since the previously\n         * sent buffer. This can be used to reduce the amount of recomposition that needs\n         * to happen when only a small region of the buffer is being updated, such as for\n         * a small blinking cursor or a loading indicator.\n         *\n         * @param sc The SurfaceControl on which to set the damage region\n         * @param region The region to set. If null, the entire buffer is assumed dirty. This is\n         *               equivalent to not setting a damage region at all.\n         ",
    "links" : [ ]
  }, {
    "name" : "public Transaction setDimmingEnabled(@NonNull SurfaceControl sc, boolean dimmingEnabled)",
    "returnType" : "Transaction",
    "comment" : "\n         * Set if the layer can be dimmed.\n         *\n         * <p>Dimming is to adjust brightness of the layer.\n         * Default value is {@code true}, which means the layer can be dimmed.\n         * Disabling dimming means the brightness of the layer can not be changed, i.e.,\n         * keep the white point for the layer same as the display brightness.</p>\n         *\n         * @param sc The SurfaceControl on which to enable or disable dimming.\n         * @param dimmingEnabled The dimming flag.\n         * @return this.\n         *\n         * @hide\n         ",
    "links" : [ ]
  }, {
    "name" : "public Transaction setColorSpace(SurfaceControl sc, ColorSpace colorSpace)",
    "returnType" : "Transaction",
    "comment" : "\n         * Set the color space for the SurfaceControl. The supported color spaces are SRGB\n         * and Display P3, other color spaces will be treated as SRGB. This can only be used for\n         * SurfaceControls that were created as type {@link #FX_SURFACE_BLAST}\n         *\n         * @hide\n         * @deprecated use {@link #setDataSpace(SurfaceControl, long)} instead\n         ",
    "links" : [ "#setDataSpace(SurfaceControl", "#FX_SURFACE_BLAST" ]
  }, {
    "name" : "public Transaction setDataSpace(@NonNull SurfaceControl sc, @DataSpace.NamedDataSpace int dataspace)",
    "returnType" : "Transaction",
    "comment" : "\n         * Set the dataspace for the SurfaceControl. This will control how the buffer\n         * set with {@link #setBuffer(SurfaceControl, HardwareBuffer)} is displayed.\n         *\n         * @param sc The SurfaceControl to update\n         * @param dataspace The dataspace to set it to\n         * @return this\n         ",
    "links" : [ "#setBuffer(SurfaceControl" ]
  }, {
    "name" : "public Transaction setExtendedRangeBrightness(@NonNull SurfaceControl sc, float currentBufferRatio, float desiredRatio)",
    "returnType" : "Transaction",
    "comment" : "\n         * Sets the desired extended range brightness for the layer. This only applies for layers\n         * whose dataspace has RANGE_EXTENDED.\n         *\n         * @param sc The layer whose extended range brightness is being specified\n         * @param currentBufferRatio The current HDR/SDR ratio of the current buffer. For example\n         *                           if the buffer was rendered with a target SDR whitepoint of\n         *                           100 nits and a max display brightness of 200 nits, this should\n         *                           be set to 2.0f.\n         *\n         *                           <p>Default value is 1.0f.\n         *\n         *                           <p>Transfer functions that encode their own brightness ranges,\n         *                           such as HLG or PQ, should also set this to 1.0f and instead\n         *                           communicate extended content brightness information via\n         *                           metadata such as CTA861_3 or SMPTE2086.\n         *\n         *                           <p>Must be finite && >= 1.0f\n         *\n         * @param desiredRatio The desired HDR/SDR ratio. This can be used to communicate the max\n         *                     desired brightness range. This is similar to the \"max luminance\"\n         *                     value in other HDR metadata formats, but represented as a ratio of\n         *                     the target SDR whitepoint to the max display brightness. The system\n         *                     may not be able to, or may choose not to, deliver the\n         *                     requested range.\n         *\n         *                     <p>While requesting a large desired ratio will result in the most\n         *                     dynamic range, voluntarily reducing the requested range can help\n         *                     improve battery life as well as can improve quality by ensuring\n         *                     greater bit depth is allocated to the luminance range in use.\n         *\n         *                     <p>Default value is 1.0f and indicates that extended range brightness\n         *                     is not being used, so the resulting SDR or HDR behavior will be\n         *                     determined entirely by the dataspace being used (ie, typically SDR\n         *                     however PQ or HLG transfer functions will still result in HDR)\n         *\n         *                     <p>Must be finite && >= 1.0f\n         * @return this\n         *",
    "links" : [ ]
  }, {
    "name" : "public Transaction setDesiredHdrHeadroom(@NonNull SurfaceControl sc, @FloatRange(from = 0.0f) float desiredRatio)",
    "returnType" : "Transaction",
    "comment" : "\n         * Sets the desired HDR headroom for the layer.\n         *\n         * <p>Prefer using this API over {@link #setExtendedRangeBrightness} for formats that\n         *. conform to HDR video standards like HLG or HDR10 which do not communicate a HDR/SDR\n         * ratio as part of generating the buffer.\n         *\n         * @param sc The layer whose desired HDR headroom is being specified\n         *\n         * @param desiredRatio The desired HDR/SDR ratio. This can be used to communicate the max\n         *                     desired brightness range. This is similar to the \"max luminance\"\n         *                     value in other HDR metadata formats, but represented as a ratio of\n         *                     the target SDR whitepoint to the max display brightness. The system\n         *                     may not be able to, or may choose not to, deliver the\n         *                     requested range.\n         *\n         *                     <p>Default value is 0.0f and indicates that the system will choose\n         *                     the best headroom for this surface control's content. Typically,\n         *                     this means that HLG/PQ encoded content will be displayed with some\n         *                     HDR headroom greater than 1.0.\n         *\n         *                     <p>When called after {@link #setExtendedRangeBrightness}, the\n         *                     desiredHeadroom will override the desiredRatio provided by\n         *                     {@link #setExtendedRangeBrightness}. Conversely, when called\n         *                     before {@link #setExtendedRangeBrightness}, the desiredRatio provided\n         *                     by {@link #setExtendedRangeBrightness} will override the\n         *                     desiredHeadroom.\n         *\n         *                     <p>Must be finite && >= 1.0f or 0.0f.\n         * @return this\n         * @see #setExtendedRangeBrightness\n         *",
    "links" : [ "#setExtendedRangeBrightness" ]
  }, {
    "name" : "public Transaction setCachingHint(@NonNull SurfaceControl sc, @CachingHint int cachingHint)",
    "returnType" : "Transaction",
    "comment" : "\n         * Sets the caching hint for the layer. By default, the caching hint is\n         * {@link CACHING_ENABLED}.\n         *\n         * @param sc The SurfaceControl to update\n         * @param cachingHint The caching hint to apply to the SurfaceControl. The CachingHint is\n         *                    not applied to any children of this SurfaceControl.\n         * @return this\n         * @hide\n         ",
    "links" : [ "CACHING_ENABLED" ]
  }, {
    "name" : "public Transaction setTrustedOverlay(SurfaceControl sc, boolean isTrustedOverlay)",
    "returnType" : "Transaction",
    "comment" : "\n         * Sets the trusted overlay state on this SurfaceControl and it is inherited to all the\n         * children. The caller must hold the ACCESS_SURFACE_FLINGER permission.\n         * @hide\n         ",
    "links" : [ ]
  }, {
    "name" : "public Transaction setDropInputMode(SurfaceControl sc, @DropInputMode int mode)",
    "returnType" : "Transaction",
    "comment" : "\n         * Sets the input event drop mode on this SurfaceControl and its children. The caller must\n         * hold the ACCESS_SURFACE_FLINGER permission. See {@code InputEventDropMode}.\n         * @hide\n         ",
    "links" : [ ]
  }, {
    "name" : "public Transaction setCanOccludePresentation(SurfaceControl sc, boolean canOccludePresentation)",
    "returnType" : "Transaction",
    "comment" : "\n         * Sets a property on this SurfaceControl and all its children indicating that the visible\n         * region of this SurfaceControl should be considered when computing TrustedPresentation\n         * Thresholds.\n         * <p>\n         * API Guidance:\n         * The goal of this API is to identify windows that can be used to occlude content on\n         * another window. This includes windows controlled by the user or the system. If the window\n         * is transient, like Toast or notification shade, the window should not set this flag since\n         * the user or the app cannot use the window to occlude content in a persistent manner. All\n         * apps should have this flag set.\n         * <p>\n         * The caller must hold the ACCESS_SURFACE_FLINGER permission.\n         * @hide\n         ",
    "links" : [ ]
  }, {
    "name" : "public static void sendSurfaceFlushJankData(SurfaceControl sc)",
    "returnType" : "void",
    "comment" : "\n         * Sends a flush jank data transaction for the given surface.\n         * @hide\n         ",
    "links" : [ ]
  }, {
    "name" : "public void sanitize(int pid, int uid)",
    "returnType" : "void",
    "comment" : "\n         * @hide\n         ",
    "links" : [ ]
  }, {
    "name" : "public Transaction setDesintationFrame(SurfaceControl sc, @NonNull Rect destinationFrame)",
    "returnType" : "Transaction",
    "comment" : "\n         * @hide\n         ",
    "links" : [ ]
  }, {
    "name" : "public Transaction setDesintationFrame(SurfaceControl sc, int width, int height)",
    "returnType" : "Transaction",
    "comment" : "\n         * @hide\n         ",
    "links" : [ ]
  }, {
    "name" : "public Transaction merge(@NonNull Transaction other)",
    "returnType" : "Transaction",
    "comment" : "\n         * Merge the other transaction into this transaction, clearing the\n         * other transaction as if it had been applied.\n         *\n         * @param other The transaction to merge in to this one.\n         * @return This transaction.\n         ",
    "links" : [ ]
  }, {
    "name" : "public Transaction remove(@NonNull SurfaceControl sc)",
    "returnType" : "Transaction",
    "comment" : "\n         * Equivalent to reparent with a null parent, in that it removes\n         * the SurfaceControl from the scene, but it also releases\n         * the local resources (by calling {@link SurfaceControl#release})\n         * after this method returns, {@link SurfaceControl#isValid} will return\n         * false for the argument.\n         *\n         * @param sc The surface to remove and release.\n         * @return This transaction\n         * @hide\n         ",
    "links" : [ "android.view.SurfaceControl#isValid", "android.view.SurfaceControl#release" ]
  }, {
    "name" : "public Transaction setFrameTimeline(long vsyncId)",
    "returnType" : "Transaction",
    "comment" : "\n         * Sets the frame timeline to use in SurfaceFlinger.\n         *\n         * A frame timeline should be chosen based on the frame deadline the application\n         * can meet when rendering the frame and the application's desired presentation time.\n         * By setting a frame timeline, SurfaceFlinger tries to present the frame at the\n         * corresponding expected presentation time.\n         *\n         * To receive frame timelines, a callback must be posted to Choreographer using\n         * {@link Choreographer#postVsyncCallback} The vsyncId can then be extracted from the\n         * {@link Choreographer.FrameTimeline#getVsyncId}.\n         *\n         * @param vsyncId The vsync ID received from Choreographer, setting the frame's\n         *                presentation target to the corresponding expected presentation time\n         *                and deadline from the frame to be rendered. A stale or invalid value\n         *                will be ignored.\n         *\n         ",
    "links" : [ "android.view.Choreographer#postVsyncCallback", "Choreographer.FrameTimeline#getVsyncId" ]
  }, {
    "name" : "public Transaction setFrameTimelineVsync(long frameTimelineVsyncId)",
    "returnType" : "Transaction",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "public Transaction addTransactionCommittedListener(@NonNull @CallbackExecutor Executor executor, @NonNull TransactionCommittedListener listener)",
    "returnType" : "Transaction",
    "comment" : "\n         * Request to add a {@link TransactionCommittedListener}.\n         *\n         * The callback is invoked when transaction is applied and the updates are ready to be\n         * presented. This callback does not mean buffers have been released! It simply means that\n         * any new transactions applied will not overwrite the transaction for which we are\n         * receiving a callback and instead will be included in the next frame. If you are trying\n         * to avoid dropping frames (overwriting transactions), and unable to use timestamps (Which\n         * provide a more efficient solution), then this method provides a method to pace your\n         * transaction application.\n         * The listener is invoked once the transaction is applied, and never again. Multiple\n         * listeners can be added to the same transaction, however the order the listeners will\n         * be called is not guaranteed.\n         *\n         * @param executor The executor that the callback should be invoked on.\n         * @param listener The callback that will be invoked when the transaction has been\n         *                 committed.\n         ",
    "links" : [ "TransactionCommittedListener" ]
  }, {
    "name" : "public Transaction addTransactionCompletedListener(@NonNull @CallbackExecutor Executor executor, @NonNull Consumer<TransactionStats> listener)",
    "returnType" : "Transaction",
    "comment" : "\n         * Request to add a TransactionCompletedListener.\n         *\n         * The listener is invoked when transaction is presented, and never again. Multiple\n         * listeners can be added to the same transaction, however the order the listeners will\n         * be called is not guaranteed.\n         *\n         * @param executor The executor that the callback should be invoked on.\n         * @param listener The callback that will be invoked when the transaction has been\n         *                 completed.\n         ",
    "links" : [ ]
  }, {
    "name" : "public Transaction setTrustedPresentationCallback(@NonNull SurfaceControl sc, @NonNull TrustedPresentationThresholds thresholds, @NonNull Executor executor, @NonNull Consumer<Boolean> listener)",
    "returnType" : "Transaction",
    "comment" : "\n         * Sets a callback to receive feedback about the presentation of a {@link SurfaceControl}.\n         * When the {@link SurfaceControl} is presented according to the passed in\n         * {@link TrustedPresentationThresholds}, it is said to \"enter the state\", and receives the\n         * callback with {@code true}. When the conditions fall out of thresholds, it is then\n         * said to leave the state.\n         * <p>\n         * There are a few simple thresholds:\n         * <ul>\n         *    <li>minAlpha: Lower bound on computed alpha</li>\n         *    <li>minFractionRendered: Lower bounds on fraction of pixels that were rendered</li>\n         *    <li>stabilityThresholdMs: A time that alpha and fraction rendered must remain within\n         *    bounds before we can \"enter the state\" </li>\n         * </ul>\n         * <p>\n         * The fraction of pixels rendered is a computation based on scale, crop\n         * and occlusion. The calculation may be somewhat counterintuitive, so we\n         * can work through an example. Imagine we have a SurfaceControl with a 100x100 buffer\n         * which is occluded by (10x100) pixels on the left, and cropped by (100x10) pixels\n         * on the top. Furthermore imagine this SurfaceControl is scaled by 0.9 in both dimensions.\n         * (c=crop,o=occluded,b=both,x=none)\n         *\n         * <blockquote>\n         * <table>\n         *   <caption></caption>\n         *   <tr><td>b</td><td>c</td><td>c</td><td>c</td></tr>\n         *   <tr><td>o</td><td>x</td><td>x</td><td>x</td></tr>\n         *   <tr><td>o</td><td>x</td><td>x</td><td>x</td></tr>\n         *   <tr><td>o</td><td>x</td><td>x</td><td>x</td></tr>\n         * </table>\n         * </blockquote>\n         * <p>\n         * We first start by computing fr=xscale*yscale=0.9*0.9=0.81, indicating\n         * that \"81%\" of the pixels were rendered. This corresponds to what was 100\n         * pixels being displayed in 81 pixels. This is somewhat of an abuse of\n         * language, as the information of merged pixels isn't totally lost, but\n         * we err on the conservative side.\n         * <p>\n         * We then repeat a similar process for the crop and covered regions and\n         * accumulate the results: fr = fr * (fractionNotCropped) * (fractionNotCovered)\n         * So for this example we would get 0.9*0.9*0.9*0.9=0.65...\n         * <p>\n         * Notice that this is not completely accurate, as we have double counted\n         * the region marked as b. However we only wanted a \"lower bound\" and so it\n         * is ok to err in this direction. Selection of the threshold will ultimately\n         * be somewhat arbitrary, and so there are some somewhat arbitrary decisions in\n         * this API as well.\n         * <p>\n         *\n         * @param sc         The {@link SurfaceControl} to set the callback on\n         * @param thresholds The {@link TrustedPresentationThresholds} that will specify when the to\n         *                   invoke the callback.\n         * @param executor   The {@link Executor} where the callback will be invoked on.\n         * @param listener   The {@link Consumer} that will receive the callbacks when entered or\n         *                   exited the threshold.\n         * @return This transaction\n         * @see TrustedPresentationThresholds\n         * @deprecated Use\n         * {@link WindowManager#registerTrustedPresentationListener(IBinder,\n         * android.window.TrustedPresentationThresholds, Executor, Consumer)} instead.\n         ",
    "links" : [ "java.util.function.Consumer", "android.view.SurfaceControl", "TrustedPresentationThresholds", "android.annotation.CallbackExecutor", "android.view.WindowManager#registerTrustedPresentationListener(IBinder" ]
  }, {
    "name" : "public Transaction clearTrustedPresentationCallback(@NonNull SurfaceControl sc)",
    "returnType" : "Transaction",
    "comment" : "\n         * Clears the callback for a specific {@link SurfaceControl}\n         *\n         * @param sc The SurfaceControl that the callback should be cleared from\n         * @return This transaction\n         * @deprecated Use {@link WindowManager#unregisterTrustedPresentationListener(Consumer)}\n         * instead.\n         ",
    "links" : [ "android.view.WindowManager#unregisterTrustedPresentationListener(Consumer)", "android.view.SurfaceControl" ]
  }, {
    "name" : "public Transaction setDesiredPresentTimeNanos(long desiredPresentTimeNanos)",
    "returnType" : "Transaction",
    "comment" : "\n         * Specifies a desiredPresentTimeNanos for the transaction. The framework will try to\n         * present the transaction at or after the time specified.\n         *\n         * Transactions will not be presented until all of their acquire fences have signaled even\n         * if the app requests an earlier present time.\n         *\n         * If an earlier transaction has a desired present time of x, and a later transaction has\n         * a desired present time that is before x, the later transaction will not preempt the\n         * earlier transaction.\n         *\n         * @param desiredPresentTimeNanos The desired time (in CLOCK_MONOTONIC) for the transaction.\n         * @return This transaction\n         ",
    "links" : [ ]
  }, {
    "name" : "public void writeToParcel(@NonNull Parcel dest, @WriteFlags int flags)",
    "returnType" : "void",
    "comment" : "\n         * Writes the transaction to parcel, clearing the transaction as if it had been applied so\n         * it can be used to store future transactions. It's the responsibility of the parcel\n         * reader to apply the original transaction.\n         *\n         * @param dest parcel to write the transaction to\n         * @param flags\n         ",
    "links" : [ ]
  }, {
    "name" : "private void readFromParcel(Parcel in)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public int describeContents()",
    "returnType" : "int",
    "comment" : "",
    "links" : [ ]
  } ],
  "methodNames" : [ "protected void checkPreconditions(SurfaceControl sc)", "public static void setDefaultApplyToken(IBinder token)", "public static IBinder getDefaultApplyToken()", "public void apply()", "public void applyAsyncUnsafe()", "public void clear()", "public void close()", "public void apply(boolean sync)", "private void apply(boolean sync, boolean oneWay)", "protected void applyResizedSurfaces()", "protected void notifyReparentedSurfaces()", "public Transaction setVisibility(@NonNull SurfaceControl sc, boolean visible)", "public Transaction setFrameRateSelectionPriority(@NonNull SurfaceControl sc, int priority)", "public Transaction show(SurfaceControl sc)", "public Transaction hide(SurfaceControl sc)", "public Transaction setPosition(@NonNull SurfaceControl sc, float x, float y)", "public Transaction setScale(@NonNull SurfaceControl sc, float scaleX, float scaleY)", "public Transaction setBufferSize(@NonNull SurfaceControl sc, @IntRange(from = 0) int w, @IntRange(from = 0) int h)", "public Transaction setFixedTransformHint(@NonNull SurfaceControl sc, @Surface.Rotation int transformHint)", "public Transaction unsetFixedTransformHint(@NonNull SurfaceControl sc)", "public Transaction setLayer(@NonNull SurfaceControl sc, @IntRange(from = Integer.MIN_VALUE, to = Integer.MAX_VALUE) int z)", "public Transaction setRelativeLayer(SurfaceControl sc, SurfaceControl relativeTo, int z)", "public Transaction setTransparentRegionHint(SurfaceControl sc, Region transparentRegion)", "public Transaction setAlpha(@NonNull SurfaceControl sc, @FloatRange(from = 0.0, to = 1.0) float alpha)", "public Transaction setInputWindowInfo(SurfaceControl sc, InputWindowHandle handle)", "public Transaction addWindowInfosReportedListener(@NonNull Runnable listener)", "public Transaction setGeometry(@NonNull SurfaceControl sc, @Nullable Rect sourceCrop, @Nullable Rect destFrame, @Surface.Rotation int orientation)", "public Transaction setMatrix(SurfaceControl sc, float dsdx, float dtdx, float dtdy, float dsdy)", "public Transaction setMatrix(SurfaceControl sc, Matrix matrix, float[] float9)", "public Transaction setColorTransform(SurfaceControl sc, @Size(9) float[] matrix, @Size(3) float[] translation)", "public Transaction setColorSpaceAgnostic(SurfaceControl sc, boolean agnostic)", "public Transaction setWindowCrop(SurfaceControl sc, Rect crop)", "public Transaction setCrop(@NonNull SurfaceControl sc, @Nullable Rect crop)", "public Transaction setWindowCrop(SurfaceControl sc, int width, int height)", "public Transaction setCornerRadius(SurfaceControl sc, float cornerRadius)", "public Transaction setBackgroundBlurRadius(SurfaceControl sc, int radius)", "public Transaction setBlurRegions(SurfaceControl sc, float[][] regions)", "public Transaction setStretchEffect(SurfaceControl sc, float width, float height, float vecX, float vecY, float maxStretchAmountX, float maxStretchAmountY, float childRelativeLeft, float childRelativeTop, float childRelativeRight, float childRelativeBottom)", "public Transaction setLayerStack(SurfaceControl sc, int layerStack)", "public Transaction reparent(@NonNull SurfaceControl sc, @Nullable SurfaceControl newParent)", "public Transaction setColor(SurfaceControl sc, @Size(3) float[] color)", "public Transaction unsetColor(SurfaceControl sc)", "public Transaction setSecure(SurfaceControl sc, boolean isSecure)", "public Transaction setDisplayDecoration(SurfaceControl sc, boolean displayDecoration)", "public Transaction setOpaque(@NonNull SurfaceControl sc, boolean isOpaque)", "public Transaction setDisplaySurface(IBinder displayToken, Surface surface)", "public Transaction setDisplayLayerStack(IBinder displayToken, int layerStack)", "public Transaction setDisplayFlags(IBinder displayToken, int flags)", "public Transaction setDisplayProjection(IBinder displayToken, int orientation, Rect layerStackRect, Rect displayRect)", "public Transaction setDisplaySize(IBinder displayToken, int width, int height)", "public Transaction setAnimationTransaction()", "public Transaction setEarlyWakeupStart()", "public Transaction setEarlyWakeupEnd()", "public long getId()", "public Transaction setMetadata(SurfaceControl sc, int key, int data)", "public Transaction setMetadata(SurfaceControl sc, int key, Parcel data)", "public Transaction setShadowRadius(SurfaceControl sc, float shadowRadius)", "public Transaction setFrameRate(@NonNull SurfaceControl sc, @FloatRange(from = 0.0) float frameRate, @Surface.FrameRateCompatibility int compatibility)", "public Transaction setFrameRate(@NonNull SurfaceControl sc, @FloatRange(from = 0.0) float frameRate, @Surface.FrameRateCompatibility int compatibility, @Surface.ChangeFrameRateStrategy int changeFrameRateStrategy)", "public Transaction clearFrameRate(@NonNull SurfaceControl sc)", "public Transaction setDefaultFrameRateCompatibility(@NonNull SurfaceControl sc, @Surface.FrameRateCompatibility int compatibility)", "public Transaction setFrameRateCategory(@NonNull SurfaceControl sc, @Surface.FrameRateCategory int category, boolean smoothSwitchOnly)", "public Transaction setFrameRateSelectionStrategy(@NonNull SurfaceControl sc, @FrameRateSelectionStrategy int strategy)", "public Transaction setFocusedWindow(@NonNull IBinder token, String windowName, int displayId)", "public Transaction removeCurrentInputFocus(int displayId)", "public Transaction setSkipScreenshot(SurfaceControl sc, boolean skipScrenshot)", "public Transaction setBuffer(SurfaceControl sc, GraphicBuffer buffer)", "public Transaction setBuffer(@NonNull SurfaceControl sc, @Nullable HardwareBuffer buffer)", "public Transaction unsetBuffer(SurfaceControl sc)", "public Transaction setBuffer(@NonNull SurfaceControl sc, @Nullable HardwareBuffer buffer, @Nullable SyncFence fence)", "public Transaction setBuffer(@NonNull SurfaceControl sc, @Nullable HardwareBuffer buffer, @Nullable SyncFence fence, @Nullable Consumer<SyncFence> releaseCallback)", "public Transaction setBufferTransform(@NonNull SurfaceControl sc, @SurfaceControl.BufferTransform int transform)", "public Transaction setDamageRegion(@NonNull SurfaceControl sc, @Nullable Region region)", "public Transaction setDimmingEnabled(@NonNull SurfaceControl sc, boolean dimmingEnabled)", "public Transaction setColorSpace(SurfaceControl sc, ColorSpace colorSpace)", "public Transaction setDataSpace(@NonNull SurfaceControl sc, @DataSpace.NamedDataSpace int dataspace)", "public Transaction setExtendedRangeBrightness(@NonNull SurfaceControl sc, float currentBufferRatio, float desiredRatio)", "public Transaction setDesiredHdrHeadroom(@NonNull SurfaceControl sc, @FloatRange(from = 0.0f) float desiredRatio)", "public Transaction setCachingHint(@NonNull SurfaceControl sc, @CachingHint int cachingHint)", "public Transaction setTrustedOverlay(SurfaceControl sc, boolean isTrustedOverlay)", "public Transaction setDropInputMode(SurfaceControl sc, @DropInputMode int mode)", "public Transaction setCanOccludePresentation(SurfaceControl sc, boolean canOccludePresentation)", "public static void sendSurfaceFlushJankData(SurfaceControl sc)", "public void sanitize(int pid, int uid)", "public Transaction setDesintationFrame(SurfaceControl sc, @NonNull Rect destinationFrame)", "public Transaction setDesintationFrame(SurfaceControl sc, int width, int height)", "public Transaction merge(@NonNull Transaction other)", "public Transaction remove(@NonNull SurfaceControl sc)", "public Transaction setFrameTimeline(long vsyncId)", "public Transaction setFrameTimelineVsync(long frameTimelineVsyncId)", "public Transaction addTransactionCommittedListener(@NonNull @CallbackExecutor Executor executor, @NonNull TransactionCommittedListener listener)", "public Transaction addTransactionCompletedListener(@NonNull @CallbackExecutor Executor executor, @NonNull Consumer<TransactionStats> listener)", "public Transaction setTrustedPresentationCallback(@NonNull SurfaceControl sc, @NonNull TrustedPresentationThresholds thresholds, @NonNull Executor executor, @NonNull Consumer<Boolean> listener)", "public Transaction clearTrustedPresentationCallback(@NonNull SurfaceControl sc)", "public Transaction setDesiredPresentTimeNanos(long desiredPresentTimeNanos)", "public void writeToParcel(@NonNull Parcel dest, @WriteFlags int flags)", "private void readFromParcel(Parcel in)", "public int describeContents()" ],
  "variableNames" : [ "sRegistry", "mNativeObject", "mResizedSurfaces", "mReparentedSurfaces", "mFreeNativeResources", "INVALID_COLOR", "CREATOR" ]
}