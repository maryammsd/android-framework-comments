{
  "filePath" : "/home/maryam/clearblue/files/android-source-30/android/media/MediaParser.java",
  "packageName" : "android.media",
  "className" : "MediaParser",
  "comment" : "\n * Parses media container formats and extracts contained media samples and metadata.\n *\n * <p>This class provides access to a battery of low-level media container parsers. Each instance of\n * this class is associated to a specific media parser implementation which is suitable for\n * extraction from a specific media container format. The media parser implementation assignment\n * depends on the factory method (see {@link #create} and {@link #createByName}) used to create the\n * instance.\n *\n * <p>Users must implement the following to use this class.\n *\n * <ul>\n *   <li>{@link InputReader}: Provides the media container's bytes to parse.\n *   <li>{@link OutputConsumer}: Provides a sink for all extracted data and metadata.\n * </ul>\n *\n * <p>The following code snippet includes a usage example:\n *\n * <pre>\n * MyOutputConsumer myOutputConsumer = new MyOutputConsumer();\n * MyInputReader myInputReader = new MyInputReader(\"www.example.com\");\n * MediaParser mediaParser = MediaParser.create(myOutputConsumer);\n *\n * while (mediaParser.advance(myInputReader)) {}\n *\n * mediaParser.release();\n * mediaParser = null;\n * </pre>\n *\n * <p>The following code snippet provides a rudimentary {@link OutputConsumer} sample implementation\n * which extracts and publishes all video samples:\n *\n * <pre>\n * class VideoOutputConsumer implements MediaParser.OutputConsumer {\n *\n *     private byte[] sampleDataBuffer = new byte[4096];\n *     private byte[] discardedDataBuffer = new byte[4096];\n *     private int videoTrackIndex = -1;\n *     private int bytesWrittenCount = 0;\n *\n *     &#64;Override\n *     public void onSeekMapFound(int i, &#64;NonNull MediaFormat mediaFormat) {\n *       // Do nothing.\n *     }\n *\n *     &#64;Override\n *     public void onTrackDataFound(int i, &#64;NonNull TrackData trackData) {\n *       MediaFormat mediaFormat = trackData.mediaFormat;\n *       if (videoTrackIndex == -1 &amp;&amp;\n *           mediaFormat\n *               .getString(MediaFormat.KEY_MIME, &#47;* defaultValue= *&#47; \"\")\n *               .startsWith(\"video/\")) {\n *         videoTrackIndex = i;\n *       }\n *     }\n *\n *     &#64;Override\n *     public void onSampleDataFound(int trackIndex, &#64;NonNull InputReader inputReader)\n *         throws IOException {\n *       int numberOfBytesToRead = (int) inputReader.getLength();\n *       if (videoTrackIndex != trackIndex) {\n *         // Discard contents.\n *         inputReader.read(\n *             discardedDataBuffer,\n *             &#47;* offset= *&#47; 0,\n *             Math.min(discardDataBuffer.length, numberOfBytesToRead));\n *       } else {\n *         ensureSpaceInBuffer(numberOfBytesToRead);\n *         int bytesRead = inputReader.read(\n *             sampleDataBuffer, bytesWrittenCount, numberOfBytesToRead);\n *         bytesWrittenCount += bytesRead;\n *       }\n *     }\n *\n *     &#64;Override\n *     public void onSampleCompleted(\n *         int trackIndex,\n *         long timeMicros,\n *         int flags,\n *         int size,\n *         int offset,\n *         &#64;Nullable CryptoInfo cryptoData) {\n *       if (videoTrackIndex != trackIndex) {\n *         return; // It's not the video track. Ignore.\n *       }\n *       byte[] sampleData = new byte[size];\n *       int sampleStartOffset = bytesWrittenCount - size - offset;\n *       System.arraycopy(\n *           sampleDataBuffer,\n *           sampleStartOffset,\n *           sampleData,\n *           &#47;* destPos= *&#47; 0,\n *           size);\n *       // Place trailing bytes at the start of the buffer.\n *       System.arraycopy(\n *           sampleDataBuffer,\n *           bytesWrittenCount - offset,\n *           sampleDataBuffer,\n *           &#47;* destPos= *&#47; 0,\n *           &#47;* size= *&#47; offset);\n *       bytesWrittenCount = bytesWrittenCount - offset;\n *       publishSample(sampleData, timeMicros, flags);\n *     }\n *\n *    private void ensureSpaceInBuffer(int numberOfBytesToRead) {\n *      int requiredLength = bytesWrittenCount + numberOfBytesToRead;\n *      if (requiredLength &gt; sampleDataBuffer.length) {\n *        sampleDataBuffer = Arrays.copyOf(sampleDataBuffer, requiredLength);\n *      }\n *    }\n *\n *   }\n *\n * </pre>\n ",
  "variables" : [ {
    "name" : "SAMPLE_FLAG_KEY_FRAME",
    "type" : "int",
    "comment" : " Indicates that the sample holds a synchronization sample. ",
    "links" : [ ]
  }, {
    "name" : "SAMPLE_FLAG_HAS_SUPPLEMENTAL_DATA",
    "type" : "int",
    "comment" : "\n     * Indicates that the sample has supplemental data.\n     *\n     * <p>Samples will not have this flag set unless the {@code\n     * \"android.media.mediaparser.includeSupplementalData\"} parameter is set to {@code true} via\n     * {@link #setParameter}.\n     *\n     * <p>Samples with supplemental data have the following sample data format:\n     *\n     * <ul>\n     *   <li>If the {@code \"android.media.mediaparser.inBandCryptoInfo\"} parameter is set, all\n     *       encryption information.\n     *   <li>(4 bytes) {@code sample_data_size}: The size of the actual sample data, not including\n     *       supplemental data or encryption information.\n     *   <li>({@code sample_data_size} bytes): The media sample data.\n     *   <li>(remaining bytes) The supplemental data.\n     * </ul>\n     ",
    "links" : [ "#setParameter" ]
  }, {
    "name" : "SAMPLE_FLAG_LAST_SAMPLE",
    "type" : "int",
    "comment" : " Indicates that the sample is known to contain the last media sample of the stream. ",
    "links" : [ ]
  }, {
    "name" : "SAMPLE_FLAG_ENCRYPTED",
    "type" : "int",
    "comment" : " Indicates that the sample is (at least partially) encrypted. ",
    "links" : [ ]
  }, {
    "name" : "SAMPLE_FLAG_DECODE_ONLY",
    "type" : "int",
    "comment" : " Indicates that the sample should be decoded but not rendered. ",
    "links" : [ ]
  }, {
    "name" : "PARSER_NAME_UNKNOWN",
    "type" : "String",
    "comment" : " Parser name returned by {@link #getParserName()} when no parser has been selected yet. ",
    "links" : [ "#getParserName" ]
  }, {
    "name" : "PARSER_NAME_MATROSKA",
    "type" : "String",
    "comment" : "\n     * Parser for the Matroska container format, as defined in the <a\n     * href=\"https://matroska.org/technical/specs/\">spec</a>.\n     ",
    "links" : [ ]
  }, {
    "name" : "PARSER_NAME_FMP4",
    "type" : "String",
    "comment" : "\n     * Parser for fragmented files using the MP4 container format, as defined in ISO/IEC 14496-12.\n     ",
    "links" : [ ]
  }, {
    "name" : "PARSER_NAME_MP4",
    "type" : "String",
    "comment" : "\n     * Parser for non-fragmented files using the MP4 container format, as defined in ISO/IEC\n     * 14496-12.\n     ",
    "links" : [ ]
  }, {
    "name" : "PARSER_NAME_MP3",
    "type" : "String",
    "comment" : " Parser for the MP3 container format, as defined in ISO/IEC 11172-3. ",
    "links" : [ ]
  }, {
    "name" : "PARSER_NAME_ADTS",
    "type" : "String",
    "comment" : " Parser for the ADTS container format, as defined in ISO/IEC 13818-7. ",
    "links" : [ ]
  }, {
    "name" : "PARSER_NAME_AC3",
    "type" : "String",
    "comment" : "\n     * Parser for the AC-3 container format, as defined in Digital Audio Compression Standard\n     * (AC-3).\n     ",
    "links" : [ ]
  }, {
    "name" : "PARSER_NAME_TS",
    "type" : "String",
    "comment" : " Parser for the TS container format, as defined in ISO/IEC 13818-1. ",
    "links" : [ ]
  }, {
    "name" : "PARSER_NAME_FLV",
    "type" : "String",
    "comment" : "\n     * Parser for the FLV container format, as defined in Adobe Flash Video File Format\n     * Specification.\n     ",
    "links" : [ ]
  }, {
    "name" : "PARSER_NAME_OGG",
    "type" : "String",
    "comment" : " Parser for the OGG container format, as defined in RFC 3533. ",
    "links" : [ ]
  }, {
    "name" : "PARSER_NAME_PS",
    "type" : "String",
    "comment" : " Parser for the PS container format, as defined in ISO/IEC 11172-1. ",
    "links" : [ ]
  }, {
    "name" : "PARSER_NAME_WAV",
    "type" : "String",
    "comment" : "\n     * Parser for the WAV container format, as defined in Multimedia Programming Interface and Data\n     * Specifications.\n     ",
    "links" : [ ]
  }, {
    "name" : "PARSER_NAME_AMR",
    "type" : "String",
    "comment" : " Parser for the AMR container format, as defined in RFC 4867. ",
    "links" : [ ]
  }, {
    "name" : "PARSER_NAME_AC4",
    "type" : "String",
    "comment" : "\n     * Parser for the AC-4 container format, as defined by Dolby AC-4: Audio delivery for\n     * Next-Generation Entertainment Services.\n     ",
    "links" : [ ]
  }, {
    "name" : "PARSER_NAME_FLAC",
    "type" : "String",
    "comment" : "\n     * Parser for the FLAC container format, as defined in the <a\n     * href=\"https://xiph.org/flac/\">spec</a>.\n     ",
    "links" : [ ]
  }, {
    "name" : "PARAMETER_ADTS_ENABLE_CBR_SEEKING",
    "type" : "String",
    "comment" : "\n     * Sets whether constant bitrate seeking should be enabled for ADTS parsing. {@code boolean}\n     * expected. Default value is {@code false}.\n     ",
    "links" : [ ]
  }, {
    "name" : "PARAMETER_AMR_ENABLE_CBR_SEEKING",
    "type" : "String",
    "comment" : "\n     * Sets whether constant bitrate seeking should be enabled for AMR. {@code boolean} expected.\n     * Default value is {@code false}.\n     ",
    "links" : [ ]
  }, {
    "name" : "PARAMETER_FLAC_DISABLE_ID3",
    "type" : "String",
    "comment" : "\n     * Sets whether the ID3 track should be disabled for FLAC. {@code boolean} expected. Default\n     * value is {@code false}.\n     ",
    "links" : [ ]
  }, {
    "name" : "PARAMETER_MP4_IGNORE_EDIT_LISTS",
    "type" : "String",
    "comment" : "\n     * Sets whether MP4 parsing should ignore edit lists. {@code boolean} expected. Default value is\n     * {@code false}.\n     ",
    "links" : [ ]
  }, {
    "name" : "PARAMETER_MP4_IGNORE_TFDT_BOX",
    "type" : "String",
    "comment" : "\n     * Sets whether MP4 parsing should ignore the tfdt box. {@code boolean} expected. Default value\n     * is {@code false}.\n     ",
    "links" : [ ]
  }, {
    "name" : "PARAMETER_MP4_TREAT_VIDEO_FRAMES_AS_KEYFRAMES",
    "type" : "String",
    "comment" : "\n     * Sets whether MP4 parsing should treat all video frames as key frames. {@code boolean}\n     * expected. Default value is {@code false}.\n     ",
    "links" : [ ]
  }, {
    "name" : "PARAMETER_MATROSKA_DISABLE_CUES_SEEKING",
    "type" : "String",
    "comment" : "\n     * Sets whether Matroska parsing should avoid seeking to the cues element. {@code boolean}\n     * expected. Default value is {@code false}.\n     *\n     * <p>If this flag is enabled and the cues element occurs after the first cluster, then the\n     * media is treated as unseekable.\n     ",
    "links" : [ ]
  }, {
    "name" : "PARAMETER_MP3_DISABLE_ID3",
    "type" : "String",
    "comment" : "\n     * Sets whether the ID3 track should be disabled for MP3. {@code boolean} expected. Default\n     * value is {@code false}.\n     ",
    "links" : [ ]
  }, {
    "name" : "PARAMETER_MP3_ENABLE_CBR_SEEKING",
    "type" : "String",
    "comment" : "\n     * Sets whether constant bitrate seeking should be enabled for MP3. {@code boolean} expected.\n     * Default value is {@code false}.\n     ",
    "links" : [ ]
  }, {
    "name" : "PARAMETER_MP3_ENABLE_INDEX_SEEKING",
    "type" : "String",
    "comment" : "\n     * Sets whether MP3 parsing should generate a time-to-byte mapping. {@code boolean} expected.\n     * Default value is {@code false}.\n     *\n     * <p>Enabling this flag may require to scan a significant portion of the file to compute a seek\n     * point. Therefore, it should only be used if:\n     *\n     * <ul>\n     *   <li>the file is small, or\n     *   <li>the bitrate is variable (or the type of bitrate is unknown) and the seeking metadata\n     *       provided in the file is not precise enough (or is not present).\n     * </ul>\n     ",
    "links" : [ ]
  }, {
    "name" : "PARAMETER_TS_MODE",
    "type" : "String",
    "comment" : "\n     * Sets the operation mode for TS parsing. {@code String} expected. Valid values are {@code\n     * \"single_pmt\"}, {@code \"multi_pmt\"}, and {@code \"hls\"}. Default value is {@code \"single_pmt\"}.\n     *\n     * <p>The operation modes alter the way TS behaves so that it can handle certain kinds of\n     * commonly-occurring malformed media.\n     *\n     * <ul>\n     *   <li>{@code \"single_pmt\"}: Only the first found PMT is parsed. Others are ignored, even if\n     *       more PMTs are declared in the PAT.\n     *   <li>{@code \"multi_pmt\"}: Behave as described in ISO/IEC 13818-1.\n     *   <li>{@code \"hls\"}: Enable {@code \"single_pmt\"} mode, and ignore continuity counters.\n     * </ul>\n     ",
    "links" : [ ]
  }, {
    "name" : "PARAMETER_TS_ALLOW_NON_IDR_AVC_KEYFRAMES",
    "type" : "String",
    "comment" : "\n     * Sets whether TS should treat samples consisting of non-IDR I slices as synchronization\n     * samples (key-frames). {@code boolean} expected. Default value is {@code false}.\n     ",
    "links" : [ ]
  }, {
    "name" : "PARAMETER_TS_IGNORE_AAC_STREAM",
    "type" : "String",
    "comment" : "\n     * Sets whether TS parsing should ignore AAC elementary streams. {@code boolean} expected.\n     * Default value is {@code false}.\n     ",
    "links" : [ ]
  }, {
    "name" : "PARAMETER_TS_IGNORE_AVC_STREAM",
    "type" : "String",
    "comment" : "\n     * Sets whether TS parsing should ignore AVC elementary streams. {@code boolean} expected.\n     * Default value is {@code false}.\n     ",
    "links" : [ ]
  }, {
    "name" : "PARAMETER_TS_IGNORE_SPLICE_INFO_STREAM",
    "type" : "String",
    "comment" : "\n     * Sets whether TS parsing should ignore splice information streams. {@code boolean} expected.\n     * Default value is {@code false}.\n     ",
    "links" : [ ]
  }, {
    "name" : "PARAMETER_TS_DETECT_ACCESS_UNITS",
    "type" : "String",
    "comment" : "\n     * Sets whether TS parsing should split AVC stream into access units based on slice headers.\n     * {@code boolean} expected. Default value is {@code false}.\n     *\n     * <p>This flag should be left disabled if the stream contains access units delimiters in order\n     * to avoid unnecessary computational costs.\n     ",
    "links" : [ ]
  }, {
    "name" : "PARAMETER_TS_ENABLE_HDMV_DTS_AUDIO_STREAMS",
    "type" : "String",
    "comment" : "\n     * Sets whether TS parsing should handle HDMV DTS audio streams. {@code boolean} expected.\n     * Default value is {@code false}.\n     *\n     * <p>Enabling this flag will disable the detection of SCTE subtitles.\n     ",
    "links" : [ ]
  }, {
    "name" : "PARAMETER_IN_BAND_CRYPTO_INFO",
    "type" : "String",
    "comment" : "\n     * Sets whether encryption data should be sent in-band with the sample data, as per {@link\n     * OutputConsumer#onSampleDataFound}. {@code boolean} expected. Default value is {@code false}.\n     *\n     * <p>If this parameter is set, encrypted samples' data will be prefixed with the encryption\n     * information bytes. The format for in-band encryption information is:\n     *\n     * <ul>\n     *   <li>(1 byte) {@code encryption_signal_byte}: Most significant bit signals whether the\n     *       encryption data contains subsample encryption data. The remaining bits contain {@code\n     *       initialization_vector_size}.\n     *   <li>({@code initialization_vector_size} bytes) Initialization vector.\n     *   <li>If subsample encryption data is present, as per {@code encryption_signal_byte}, the\n     *       encryption data also contains:\n     *       <ul>\n     *         <li>(2 bytes) {@code subsample_encryption_data_length}.\n     *         <li>({@code subsample_encryption_data_length * 6} bytes) Subsample encryption data\n     *             (repeated {@code subsample_encryption_data_length} times):\n     *             <ul>\n     *               <li>(2 bytes) Size of a clear section in sample.\n     *               <li>(4 bytes) Size of an encryption section in sample.\n     *             </ul>\n     *       </ul>\n     * </ul>\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "PARAMETER_INCLUDE_SUPPLEMENTAL_DATA",
    "type" : "String",
    "comment" : "\n     * Sets whether supplemental data should be included as part of the sample data. {@code boolean}\n     * expected. Default value is {@code false}. See {@link #SAMPLE_FLAG_HAS_SUPPLEMENTAL_DATA} for\n     * information about the sample data format.\n     *\n     * @hide\n     ",
    "links" : [ "#SAMPLE_FLAG_HAS_SUPPLEMENTAL_DATA" ]
  }, {
    "name" : "PARAMETER_IGNORE_TIMESTAMP_OFFSET",
    "type" : "String",
    "comment" : "\n     * Sets whether sample timestamps may start from non-zero offsets. {@code boolean} expected.\n     * Default value is {@code false}.\n     *\n     * <p>When set to true, sample timestamps will not be offset to start from zero, and the media\n     * provided timestamps will be used instead. For example, transport stream sample timestamps\n     * will not be converted to a zero-based timebase.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "PARAMETER_EAGERLY_EXPOSE_TRACKTYPE",
    "type" : "String",
    "comment" : "\n     * Sets whether each track type should be eagerly exposed. {@code boolean} expected. Default\n     * value is {@code false}.\n     *\n     * <p>When set to true, each track type will be eagerly exposed through a call to {@link\n     * OutputConsumer#onTrackDataFound} containing a single-value {@link MediaFormat}. The key for\n     * the track type is {@code \"track-type-string\"}, and the possible values are {@code \"video\"},\n     * {@code \"audio\"}, {@code \"text\"}, {@code \"metadata\"}, and {@code \"unknown\"}.\n     *\n     * @hide\n     ",
    "links" : [ "MediaFormat" ]
  }, {
    "name" : "PARAMETER_EXPOSE_DUMMY_SEEKMAP",
    "type" : "String",
    "comment" : "\n     * Sets whether a dummy {@link SeekMap} should be exposed before starting extraction. {@code\n     * boolean} expected. Default value is {@code false}.\n     *\n     * <p>For each {@link SeekMap#getSeekPoints} call, the dummy {@link SeekMap} returns a single\n     * {@link SeekPoint} whose {@link SeekPoint#timeMicros} matches the requested timestamp, and\n     * whose {@link SeekPoint#position} is 0.\n     *\n     * @hide\n     ",
    "links" : [ "SeekMap", "SeekMap#getSeekPoints", "SeekMap", "SeekPoint", "SeekPoint#timeMicros", "SeekPoint#position" ]
  }, {
    "name" : "PARAMETER_EXPOSE_CHUNK_INDEX_AS_MEDIA_FORMAT",
    "type" : "String",
    "comment" : "\n     * Sets whether chunk indices available in the extracted media should be exposed as {@link\n     * MediaFormat MediaFormats}. {@code boolean} expected. Default value is {@link false}.\n     *\n     * <p>When set to true, any information about media segmentation will be exposed as a {@link\n     * MediaFormat} (with track index 0) containing four {@link ByteBuffer} elements under the\n     * following keys:\n     *\n     * <ul>\n     *   <li>\"chunk-index-int-sizes\": Contains {@code ints} representing the sizes in bytes of each\n     *       of the media segments.\n     *   <li>\"chunk-index-long-offsets\": Contains {@code longs} representing the byte offsets of\n     *       each segment in the stream.\n     *   <li>\"chunk-index-long-us-durations\": Contains {@code longs} representing the media duration\n     *       of each segment, in microseconds.\n     *   <li>\"chunk-index-long-us-times\": Contains {@code longs} representing the start time of each\n     *       segment, in microseconds.\n     * </ul>\n     *\n     * @hide\n     ",
    "links" : [ "false", "ByteBuffer" ]
  }, {
    "name" : "PARAMETER_EXPOSE_CAPTION_FORMATS",
    "type" : "String",
    "comment" : "\n     * Sets a list of closed-caption {@link MediaFormat MediaFormats} that should be exposed as part\n     * of the extracted media. {@code List<MediaFormat>} expected. Default value is an empty list.\n     *\n     * <p>Expected keys in the {@link MediaFormat} are:\n     *\n     * <ul>\n     *   <p>{@link MediaFormat#KEY_MIME}: Determine the type of captions (for example,\n     *   application/cea-608). Mandatory.\n     *   <p>{@link MediaFormat#KEY_CAPTION_SERVICE_NUMBER}: Determine the channel on which the\n     *   captions are transmitted. Optional.\n     * </ul>\n     *\n     * @hide\n     ",
    "links" : [ "MediaFormat", "MediaFormat", "MediaFormat#KEY_MIME", "MediaFormat#KEY_CAPTION_SERVICE_NUMBER" ]
  }, {
    "name" : "PARAMETER_OVERRIDE_IN_BAND_CAPTION_DECLARATIONS",
    "type" : "String",
    "comment" : "\n     * Sets whether the value associated with {@link #PARAMETER_EXPOSE_CAPTION_FORMATS} should\n     * override any in-band caption service declarations. {@code boolean} expected. Default value is\n     * {@link false}.\n     *\n     * <p>When {@code false}, any present in-band caption services information will override the\n     * values associated with {@link #PARAMETER_EXPOSE_CAPTION_FORMATS}.\n     *\n     * @hide\n     ",
    "links" : [ "#PARAMETER_EXPOSE_CAPTION_FORMATS", "false", "#PARAMETER_EXPOSE_CAPTION_FORMATS" ]
  }, {
    "name" : "PARAMETER_EXPOSE_EMSG_TRACK",
    "type" : "String",
    "comment" : "\n     * Sets whether a track for EMSG events should be exposed in case of parsing a container that\n     * supports them. {@code boolean} expected. Default value is {@link false}.\n     *\n     * @hide\n     ",
    "links" : [ "false" ]
  }, {
    "name" : "TAG",
    "type" : "String",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "EXTRACTOR_FACTORIES_BY_NAME",
    "type" : "Map<String, ExtractorFactory>",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "EXPECTED_TYPE_BY_PARAMETER_NAME",
    "type" : "Map<String, Class>",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "TS_MODE_SINGLE_PMT",
    "type" : "String",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "TS_MODE_MULTI_PMT",
    "type" : "String",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "TS_MODE_HLS",
    "type" : "String",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "BYTES_PER_SUBSAMPLE_ENCRYPTION_ENTRY",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "EMPTY_BYTE_ARRAY",
    "type" : "byte[]",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "STATE_READING_SIGNAL_BYTE",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "STATE_READING_INIT_VECTOR",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "STATE_READING_SUBSAMPLE_ENCRYPTION_SIZE",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "STATE_READING_SUBSAMPLE_ENCRYPTION_DATA",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mParserParameters",
    "type" : "Map<String, Object>",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mOutputConsumer",
    "type" : "OutputConsumer",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mParserNamesPool",
    "type" : "String[]",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mPositionHolder",
    "type" : "PositionHolder",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mExoDataReader",
    "type" : "InputReadingDataReader",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mScratchDataReaderAdapter",
    "type" : "DataReaderAdapter",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mScratchParsableByteArrayAdapter",
    "type" : "ParsableByteArrayAdapter",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mSchemeInitDataConstructor",
    "type" : "Constructor<DrmInitData.SchemeInitData>",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mMuxedCaptionFormats",
    "type" : "ArrayList<Format>",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mInBandCryptoInfo",
    "type" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mIncludeSupplementalData",
    "type" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mIgnoreTimestampOffset",
    "type" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mEagerlyExposeTrackType",
    "type" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mExposeDummySeekMap",
    "type" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mExposeChunkIndexAsMediaFormat",
    "type" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mParserName",
    "type" : "String",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mExtractor",
    "type" : "Extractor",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mExtractorInput",
    "type" : "ExtractorInput",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mPendingExtractorInit",
    "type" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mPendingSeekPosition",
    "type" : "long",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mPendingSeekTimeMicros",
    "type" : "long",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mLoggedSchemeInitDataCreationException",
    "type" : "boolean",
    "comment" : "",
    "links" : [ ]
  } ],
  "methods" : [ {
    "name" : "public static MediaParser createByName(@NonNull @ParserName String name, @NonNull OutputConsumer outputConsumer)",
    "returnType" : "MediaParser",
    "comment" : "\n     * Creates an instance backed by the parser with the given {@code name}. The returned instance\n     * will attempt parsing without sniffing the content.\n     *\n     * @param name The name of the parser that will be associated with the created instance.\n     * @param outputConsumer The {@link OutputConsumer} to which track data and samples are pushed.\n     * @return A new instance.\n     * @throws IllegalArgumentException If an invalid name is provided.\n     ",
    "links" : [ "OutputConsumer" ]
  }, {
    "name" : "public static MediaParser create(@NonNull OutputConsumer outputConsumer, @NonNull @ParserName String... parserNames)",
    "returnType" : "MediaParser",
    "comment" : "\n     * Creates an instance whose backing parser will be selected by sniffing the content during the\n     * first {@link #advance} call. Parser implementations will sniff the content in order of\n     * appearance in {@code parserNames}.\n     *\n     * @param outputConsumer The {@link OutputConsumer} to which extracted data is output.\n     * @param parserNames The names of the parsers to sniff the content with. If empty, a default\n     *     array of names is used.\n     * @return A new instance.\n     ",
    "links" : [ "#advance", "OutputConsumer" ]
  }, {
    "name" : "public static List<String> getParserNames(@NonNull MediaFormat mediaFormat)",
    "returnType" : "List<String>",
    "comment" : "\n     * Returns an immutable list with the names of the parsers that are suitable for container\n     * formats with the given {@link MediaFormat}.\n     *\n     * <p>A parser supports a {@link MediaFormat} if the mime type associated with {@link\n     * MediaFormat#KEY_MIME} corresponds to the supported container format.\n     *\n     * @param mediaFormat The {@link MediaFormat} to check support for.\n     * @return The parser names that support the given {@code mediaFormat}, or the list of all\n     *     parsers available if no container specific format information is provided.\n     ",
    "links" : [ "MediaFormat", "MediaFormat", "MediaFormat" ]
  }, {
    "name" : "public MediaParser setParameter(@NonNull @ParameterName String parameterName, @NonNull Object value)",
    "returnType" : "MediaParser",
    "comment" : "\n     * Sets parser-specific parameters which allow customizing behavior.\n     *\n     * <p>Must be called before the first call to {@link #advance}.\n     *\n     * @param parameterName The name of the parameter to set. See {@code PARAMETER_*} constants for\n     *     documentation on possible values.\n     * @param value The value to set for the given {@code parameterName}. See {@code PARAMETER_*}\n     *     constants for documentation on the expected types.\n     * @return This instance, for convenience.\n     * @throws IllegalStateException If called after calling {@link #advance} on the same instance.\n     ",
    "links" : [ "#advance", "#advance" ]
  }, {
    "name" : "public boolean supportsParameter(@NonNull @ParameterName String parameterName)",
    "returnType" : "boolean",
    "comment" : "\n     * Returns whether the given {@code parameterName} is supported by this parser.\n     *\n     * @param parameterName The parameter name to check support for. One of the {@code PARAMETER_*}\n     *     constants.\n     * @return Whether the given {@code parameterName} is supported.\n     ",
    "links" : [ ]
  }, {
    "name" : "public String getParserName()",
    "returnType" : "String",
    "comment" : "\n     * Returns the name of the backing parser implementation.\n     *\n     * <p>If this instance was creating using {@link #createByName}, the provided name is returned.\n     * If this instance was created using {@link #create}, this method will return {@link\n     * #PARSER_NAME_UNKNOWN} until the first call to {@link #advance}, after which the name of the\n     * backing parser implementation is returned.\n     *\n     * @return The name of the backing parser implementation, or null if the backing parser\n     *     implementation has not yet been selected.\n     ",
    "links" : [ "#createByName", "#create", "#advance" ]
  }, {
    "name" : "public boolean advance(@NonNull SeekableInputReader seekableInputReader) throws IOException",
    "returnType" : "boolean",
    "comment" : "\n     * Makes progress in the extraction of the input media stream, unless the end of the input has\n     * been reached.\n     *\n     * <p>This method will block until some progress has been made.\n     *\n     * <p>If this instance was created using {@link #create}, the first call to this method will\n     * sniff the content using the selected parser implementations.\n     *\n     * @param seekableInputReader The {@link SeekableInputReader} from which to obtain the media\n     *     container data.\n     * @return Whether there is any data left to extract. Returns false if the end of input has been\n     *     reached.\n     * @throws IOException If an error occurs while reading from the {@link SeekableInputReader}.\n     * @throws UnrecognizedInputFormatException If the format cannot be recognized by any of the\n     *     underlying parser implementations.\n     ",
    "links" : [ "#create", "SeekableInputReader", "SeekableInputReader" ]
  }, {
    "name" : "public void seek(@NonNull SeekPoint seekPoint)",
    "returnType" : "void",
    "comment" : "\n     * Seeks within the media container being extracted.\n     *\n     * <p>{@link SeekPoint SeekPoints} can be obtained from the {@link SeekMap} passed to {@link\n     * OutputConsumer#onSeekMapFound(SeekMap)}.\n     *\n     * <p>Following a call to this method, the {@link InputReader} passed to the next invocation of\n     * {@link #advance} must provide data starting from {@link SeekPoint#position} in the stream.\n     *\n     * @param seekPoint The {@link SeekPoint} to seek to.\n     ",
    "links" : [ "SeekPoint", "SeekMap", "InputReader", "#advance", "SeekPoint#position", "SeekPoint" ]
  }, {
    "name" : "public void release()",
    "returnType" : "void",
    "comment" : "\n     * Releases any acquired resources.\n     *\n     * <p>After calling this method, this instance becomes unusable and no other methods should be\n     * invoked.\n     ",
    "links" : [ ]
  }, {
    "name" : "private void setMuxedCaptionFormats(List<MediaFormat> mediaFormats)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private boolean isPendingSeek()",
    "returnType" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private void removePendingSeek()",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private Extractor createExtractor(String parserName)",
    "returnType" : "Extractor",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private boolean getBooleanParameter(String name)",
    "returnType" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private String getStringParameter(String name, String defaultValue)",
    "returnType" : "String",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private static Format toExoPlayerCaptionFormat(MediaFormat mediaFormat)",
    "returnType" : "Format",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private static MediaFormat toMediaFormat(Format format)",
    "returnType" : "MediaFormat",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private static ByteBuffer toByteBuffer(long[] longArray)",
    "returnType" : "ByteBuffer",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private static ByteBuffer toByteBuffer(int[] intArray)",
    "returnType" : "ByteBuffer",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private static String toTypeString(int type)",
    "returnType" : "String",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private static void setPcmEncoding(Format format, MediaFormat result)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private static void setOptionalMediaFormatInt(MediaFormat mediaFormat, String key, int value)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private static void setOptionalMediaFormatString(MediaFormat mediaFormat, String key, @Nullable String value)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private DrmInitData toFrameworkDrmInitData(com.google.android.exoplayer2.drm.DrmInitData exoDrmInitData)",
    "returnType" : "DrmInitData",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private static SeekPoint toSeekPoint(com.google.android.exoplayer2.extractor.SeekPoint exoPlayerSeekPoint)",
    "returnType" : "SeekPoint",
    "comment" : " Returns a new {@link SeekPoint} equivalent to the given {@code exoPlayerSeekPoint}. ",
    "links" : [ "SeekPoint" ]
  }, {
    "name" : "private static void assertValidNames(@NonNull String[] names)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private int getMediaParserFlags(int flags)",
    "returnType" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private static Constructor<DrmInitData.SchemeInitData> getSchemeInitDataConstructor()",
    "returnType" : "Constructor<DrmInitData.SchemeInitData>",
    "comment" : "",
    "links" : [ ]
  } ],
  "variableNames" : [ "SAMPLE_FLAG_KEY_FRAME", "SAMPLE_FLAG_HAS_SUPPLEMENTAL_DATA", "SAMPLE_FLAG_LAST_SAMPLE", "SAMPLE_FLAG_ENCRYPTED", "SAMPLE_FLAG_DECODE_ONLY", "PARSER_NAME_UNKNOWN", "PARSER_NAME_MATROSKA", "PARSER_NAME_FMP4", "PARSER_NAME_MP4", "PARSER_NAME_MP3", "PARSER_NAME_ADTS", "PARSER_NAME_AC3", "PARSER_NAME_TS", "PARSER_NAME_FLV", "PARSER_NAME_OGG", "PARSER_NAME_PS", "PARSER_NAME_WAV", "PARSER_NAME_AMR", "PARSER_NAME_AC4", "PARSER_NAME_FLAC", "PARAMETER_ADTS_ENABLE_CBR_SEEKING", "PARAMETER_AMR_ENABLE_CBR_SEEKING", "PARAMETER_FLAC_DISABLE_ID3", "PARAMETER_MP4_IGNORE_EDIT_LISTS", "PARAMETER_MP4_IGNORE_TFDT_BOX", "PARAMETER_MP4_TREAT_VIDEO_FRAMES_AS_KEYFRAMES", "PARAMETER_MATROSKA_DISABLE_CUES_SEEKING", "PARAMETER_MP3_DISABLE_ID3", "PARAMETER_MP3_ENABLE_CBR_SEEKING", "PARAMETER_MP3_ENABLE_INDEX_SEEKING", "PARAMETER_TS_MODE", "PARAMETER_TS_ALLOW_NON_IDR_AVC_KEYFRAMES", "PARAMETER_TS_IGNORE_AAC_STREAM", "PARAMETER_TS_IGNORE_AVC_STREAM", "PARAMETER_TS_IGNORE_SPLICE_INFO_STREAM", "PARAMETER_TS_DETECT_ACCESS_UNITS", "PARAMETER_TS_ENABLE_HDMV_DTS_AUDIO_STREAMS", "PARAMETER_IN_BAND_CRYPTO_INFO", "PARAMETER_INCLUDE_SUPPLEMENTAL_DATA", "PARAMETER_IGNORE_TIMESTAMP_OFFSET", "PARAMETER_EAGERLY_EXPOSE_TRACKTYPE", "PARAMETER_EXPOSE_DUMMY_SEEKMAP", "PARAMETER_EXPOSE_CHUNK_INDEX_AS_MEDIA_FORMAT", "PARAMETER_EXPOSE_CAPTION_FORMATS", "PARAMETER_OVERRIDE_IN_BAND_CAPTION_DECLARATIONS", "PARAMETER_EXPOSE_EMSG_TRACK", "TAG", "EXTRACTOR_FACTORIES_BY_NAME", "EXPECTED_TYPE_BY_PARAMETER_NAME", "TS_MODE_SINGLE_PMT", "TS_MODE_MULTI_PMT", "TS_MODE_HLS", "BYTES_PER_SUBSAMPLE_ENCRYPTION_ENTRY", "EMPTY_BYTE_ARRAY", "STATE_READING_SIGNAL_BYTE", "STATE_READING_INIT_VECTOR", "STATE_READING_SUBSAMPLE_ENCRYPTION_SIZE", "STATE_READING_SUBSAMPLE_ENCRYPTION_DATA", "mParserParameters", "mOutputConsumer", "mParserNamesPool", "mPositionHolder", "mExoDataReader", "mScratchDataReaderAdapter", "mScratchParsableByteArrayAdapter", "mSchemeInitDataConstructor", "mMuxedCaptionFormats", "mInBandCryptoInfo", "mIncludeSupplementalData", "mIgnoreTimestampOffset", "mEagerlyExposeTrackType", "mExposeDummySeekMap", "mExposeChunkIndexAsMediaFormat", "mParserName", "mExtractor", "mExtractorInput", "mPendingExtractorInit", "mPendingSeekPosition", "mPendingSeekTimeMicros", "mLoggedSchemeInitDataCreationException" ],
  "methodNames" : [ "public static MediaParser createByName(@NonNull @ParserName String name, @NonNull OutputConsumer outputConsumer)", "public static MediaParser create(@NonNull OutputConsumer outputConsumer, @NonNull @ParserName String... parserNames)", "public static List<String> getParserNames(@NonNull MediaFormat mediaFormat)", "public MediaParser setParameter(@NonNull @ParameterName String parameterName, @NonNull Object value)", "public boolean supportsParameter(@NonNull @ParameterName String parameterName)", "public String getParserName()", "public boolean advance(@NonNull SeekableInputReader seekableInputReader) throws IOException", "public void seek(@NonNull SeekPoint seekPoint)", "public void release()", "private void setMuxedCaptionFormats(List<MediaFormat> mediaFormats)", "private boolean isPendingSeek()", "private void removePendingSeek()", "private Extractor createExtractor(String parserName)", "private boolean getBooleanParameter(String name)", "private String getStringParameter(String name, String defaultValue)", "private static Format toExoPlayerCaptionFormat(MediaFormat mediaFormat)", "private static MediaFormat toMediaFormat(Format format)", "private static ByteBuffer toByteBuffer(long[] longArray)", "private static ByteBuffer toByteBuffer(int[] intArray)", "private static String toTypeString(int type)", "private static void setPcmEncoding(Format format, MediaFormat result)", "private static void setOptionalMediaFormatInt(MediaFormat mediaFormat, String key, int value)", "private static void setOptionalMediaFormatString(MediaFormat mediaFormat, String key, @Nullable String value)", "private DrmInitData toFrameworkDrmInitData(com.google.android.exoplayer2.drm.DrmInitData exoDrmInitData)", "private static SeekPoint toSeekPoint(com.google.android.exoplayer2.extractor.SeekPoint exoPlayerSeekPoint)", "private static void assertValidNames(@NonNull String[] names)", "private int getMediaParserFlags(int flags)", "private static Constructor<DrmInitData.SchemeInitData> getSchemeInitDataConstructor()" ]
}