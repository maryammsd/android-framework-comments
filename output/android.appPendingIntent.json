{
  "filePath" : "/home/maryam/clearblue/files/android-source-30/android/app/PendingIntent.java",
  "packageName" : "android.app",
  "className" : "PendingIntent",
  "comment" : "\n * A description of an Intent and target action to perform with it.  Instances\n * of this class are created with {@link #getActivity}, {@link #getActivities},\n * {@link #getBroadcast}, and {@link #getService}; the returned object can be\n * handed to other applications so that they can perform the action you\n * described on your behalf at a later time.\n *\n * <p>By giving a PendingIntent to another application,\n * you are granting it the right to perform the operation you have specified\n * as if the other application was yourself (with the same permissions and\n * identity).  As such, you should be careful about how you build the PendingIntent:\n * almost always, for example, the base Intent you supply should have the component\n * name explicitly set to one of your own components, to ensure it is ultimately\n * sent there and nowhere else.\n *\n * <p>A PendingIntent itself is simply a reference to a token maintained by\n * the system describing the original data used to retrieve it.  This means\n * that, even if its owning application's process is killed, the\n * PendingIntent itself will remain usable from other processes that\n * have been given it.  If the creating application later re-retrieves the\n * same kind of PendingIntent (same operation, same Intent action, data,\n * categories, and components, and same flags), it will receive a PendingIntent\n * representing the same token if that is still valid, and can thus call\n * {@link #cancel} to remove it.\n *\n * <p>Because of this behavior, it is important to know when two Intents\n * are considered to be the same for purposes of retrieving a PendingIntent.\n * A common mistake people make is to create multiple PendingIntent objects\n * with Intents that only vary in their \"extra\" contents, expecting to get\n * a different PendingIntent each time.  This does <em>not</em> happen.  The\n * parts of the Intent that are used for matching are the same ones defined\n * by {@link Intent#filterEquals(Intent) Intent.filterEquals}.  If you use two\n * Intent objects that are equivalent as per\n * {@link Intent#filterEquals(Intent) Intent.filterEquals}, then you will get\n * the same PendingIntent for both of them.\n *\n * <p>There are two typical ways to deal with this.\n *\n * <p>If you truly need multiple distinct PendingIntent objects active at\n * the same time (such as to use as two notifications that are both shown\n * at the same time), then you will need to ensure there is something that\n * is different about them to associate them with different PendingIntents.\n * This may be any of the Intent attributes considered by\n * {@link Intent#filterEquals(Intent) Intent.filterEquals}, or different\n * request code integers supplied to {@link #getActivity}, {@link #getActivities},\n * {@link #getBroadcast}, or {@link #getService}.\n *\n * <p>If you only need one PendingIntent active at a time for any of the\n * Intents you will use, then you can alternatively use the flags\n * {@link #FLAG_CANCEL_CURRENT} or {@link #FLAG_UPDATE_CURRENT} to either\n * cancel or modify whatever current PendingIntent is associated with the\n * Intent you are supplying.\n *\n * <p>Also note that flags like {@link #FLAG_ONE_SHOT} or {@link #FLAG_IMMUTABLE} describe the\n * PendingIntent instance and thus, are used to identify it. Any calls to retrieve or modify a\n * PendingIntent created with these flags will also require these flags to be supplied in\n * conjunction with others. E.g. To retrieve an existing PendingIntent created with\n * FLAG_ONE_SHOT, <b>both</b> FLAG_ONE_SHOT and FLAG_NO_CREATE need to be supplied.\n ",
  "variables" : [ {
    "name" : "mTarget",
    "type" : "IIntentSender",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mCancelReceiver",
    "type" : "IResultReceiver",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mWhitelistToken",
    "type" : "IBinder",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mCancelListeners",
    "type" : "ArraySet<CancelListener>",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "FLAG_ONE_SHOT",
    "type" : "int",
    "comment" : "\n     * Flag indicating that this PendingIntent can be used only once.\n     * For use with {@link #getActivity}, {@link #getBroadcast}, and\n     * {@link #getService}. <p>If set, after\n     * {@link #send()} is called on it, it will be automatically\n     * canceled for you and any future attempt to send through it will fail.\n     ",
    "links" : [ "#getActivity", "#getBroadcast", "#getService", "#send" ]
  }, {
    "name" : "FLAG_NO_CREATE",
    "type" : "int",
    "comment" : "\n     * Flag indicating that if the described PendingIntent does not\n     * already exist, then simply return null instead of creating it.\n     * For use with {@link #getActivity}, {@link #getBroadcast}, and\n     * {@link #getService}.\n     ",
    "links" : [ "#getActivity", "#getBroadcast", "#getService" ]
  }, {
    "name" : "FLAG_CANCEL_CURRENT",
    "type" : "int",
    "comment" : "\n     * Flag indicating that if the described PendingIntent already exists,\n     * the current one should be canceled before generating a new one.\n     * For use with {@link #getActivity}, {@link #getBroadcast}, and\n     * {@link #getService}. <p>You can use\n     * this to retrieve a new PendingIntent when you are only changing the\n     * extra data in the Intent; by canceling the previous pending intent,\n     * this ensures that only entities given the new data will be able to\n     * launch it.  If this assurance is not an issue, consider\n     * {@link #FLAG_UPDATE_CURRENT}.\n     ",
    "links" : [ "#getActivity", "#getBroadcast", "#getService", "#FLAG_UPDATE_CURRENT" ]
  }, {
    "name" : "FLAG_UPDATE_CURRENT",
    "type" : "int",
    "comment" : "\n     * Flag indicating that if the described PendingIntent already exists,\n     * then keep it but replace its extra data with what is in this new\n     * Intent. For use with {@link #getActivity}, {@link #getBroadcast}, and\n     * {@link #getService}. <p>This can be used if you are creating intents where only the\n     * extras change, and don't care that any entities that received your\n     * previous PendingIntent will be able to launch it with your new\n     * extras even if they are not explicitly given to it.\n     ",
    "links" : [ "#getActivity", "#getBroadcast", "#getService" ]
  }, {
    "name" : "FLAG_IMMUTABLE",
    "type" : "int",
    "comment" : "\n     * Flag indicating that the created PendingIntent should be immutable.\n     * This means that the additional intent argument passed to the send\n     * methods to fill in unpopulated properties of this intent will be\n     * ignored.\n     ",
    "links" : [ ]
  }, {
    "name" : "sOnMarshaledListener",
    "type" : "ThreadLocal<OnMarshaledListener>",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "CREATOR",
    "type" : "Parcelable.Creator<PendingIntent>",
    "comment" : "",
    "links" : [ ]
  } ],
  "methods" : [ {
    "name" : "public static void setOnMarshaledListener(OnMarshaledListener listener)",
    "returnType" : "void",
    "comment" : "\n     * Registers an listener for pending intents being written to a parcel.\n     *\n     * @param listener The listener, null to clear.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public static PendingIntent getActivity(Context context, int requestCode, Intent intent, @Flags int flags)",
    "returnType" : "PendingIntent",
    "comment" : "\n     * Retrieve a PendingIntent that will start a new activity, like calling\n     * {@link Context#startActivity(Intent) Context.startActivity(Intent)}.\n     * Note that the activity will be started outside of the context of an\n     * existing activity, so you must use the {@link Intent#FLAG_ACTIVITY_NEW_TASK\n     * Intent.FLAG_ACTIVITY_NEW_TASK} launch flag in the Intent.\n     *\n     * <p class=\"note\">For security reasons, the {@link android.content.Intent}\n     * you supply here should almost always be an <em>explicit intent</em>,\n     * that is specify an explicit component to be delivered to through\n     * {@link Intent#setClass(android.content.Context, Class) Intent.setClass}</p>\n     *\n     * @param context The Context in which this PendingIntent should start\n     * the activity.\n     * @param requestCode Private request code for the sender\n     * @param intent Intent of the activity to be launched.\n     * @param flags May be {@link #FLAG_ONE_SHOT}, {@link #FLAG_NO_CREATE},\n     * {@link #FLAG_CANCEL_CURRENT}, {@link #FLAG_UPDATE_CURRENT},\n     * or any of the flags as supported by\n     * {@link Intent#fillIn Intent.fillIn()} to control which unspecified parts\n     * of the intent that can be supplied when the actual send happens.\n     *\n     * @return Returns an existing or new PendingIntent matching the given\n     * parameters.  May return null only if {@link #FLAG_NO_CREATE} has been\n     * supplied.\n     ",
    "links" : [ "Context#startActivity", "Intent#FLAG_ACTIVITY_NEW_TASK", "android.content.Intent", "Intent#setClass", "#FLAG_ONE_SHOT", "#FLAG_NO_CREATE", "#FLAG_CANCEL_CURRENT", "#FLAG_UPDATE_CURRENT", "Intent#fillIn", "#FLAG_NO_CREATE" ]
  }, {
    "name" : "public static PendingIntent getActivity(Context context, int requestCode, @NonNull Intent intent, @Flags int flags, @Nullable Bundle options)",
    "returnType" : "PendingIntent",
    "comment" : "\n     * Retrieve a PendingIntent that will start a new activity, like calling\n     * {@link Context#startActivity(Intent) Context.startActivity(Intent)}.\n     * Note that the activity will be started outside of the context of an\n     * existing activity, so you must use the {@link Intent#FLAG_ACTIVITY_NEW_TASK\n     * Intent.FLAG_ACTIVITY_NEW_TASK} launch flag in the Intent.\n     *\n     * <p class=\"note\">For security reasons, the {@link android.content.Intent}\n     * you supply here should almost always be an <em>explicit intent</em>,\n     * that is specify an explicit component to be delivered to through\n     * {@link Intent#setClass(android.content.Context, Class) Intent.setClass}</p>\n     *\n     * @param context The Context in which this PendingIntent should start\n     * the activity.\n     * @param requestCode Private request code for the sender\n     * @param intent Intent of the activity to be launched.\n     * @param flags May be {@link #FLAG_ONE_SHOT}, {@link #FLAG_NO_CREATE},\n     * {@link #FLAG_CANCEL_CURRENT}, {@link #FLAG_UPDATE_CURRENT},\n     * or any of the flags as supported by\n     * {@link Intent#fillIn Intent.fillIn()} to control which unspecified parts\n     * of the intent that can be supplied when the actual send happens.\n     * @param options Additional options for how the Activity should be started.\n     * May be null if there are no options.\n     *\n     * @return Returns an existing or new PendingIntent matching the given\n     * parameters.  May return null only if {@link #FLAG_NO_CREATE} has been\n     * supplied.\n     ",
    "links" : [ "Context#startActivity", "Intent#FLAG_ACTIVITY_NEW_TASK", "android.content.Intent", "Intent#setClass", "#FLAG_ONE_SHOT", "#FLAG_NO_CREATE", "#FLAG_CANCEL_CURRENT", "#FLAG_UPDATE_CURRENT", "Intent#fillIn", "#FLAG_NO_CREATE" ]
  }, {
    "name" : "public static PendingIntent getActivityAsUser(Context context, int requestCode, @NonNull Intent intent, int flags, Bundle options, UserHandle user)",
    "returnType" : "PendingIntent",
    "comment" : "\n     * @hide\n     * Note that UserHandle.CURRENT will be interpreted at the time the\n     * activity is started, not when the pending intent is created.\n     ",
    "links" : [ ]
  }, {
    "name" : "public static PendingIntent getActivities(Context context, int requestCode, @NonNull Intent[] intents, @Flags int flags)",
    "returnType" : "PendingIntent",
    "comment" : "\n     * Like {@link #getActivity(Context, int, Intent, int)}, but allows an\n     * array of Intents to be supplied.  The last Intent in the array is\n     * taken as the primary key for the PendingIntent, like the single Intent\n     * given to {@link #getActivity(Context, int, Intent, int)}.  Upon sending\n     * the resulting PendingIntent, all of the Intents are started in the same\n     * way as they would be by passing them to {@link Context#startActivities(Intent[])}.\n     *\n     * <p class=\"note\">\n     * The <em>first</em> intent in the array will be started outside of the context of an\n     * existing activity, so you must use the {@link Intent#FLAG_ACTIVITY_NEW_TASK\n     * Intent.FLAG_ACTIVITY_NEW_TASK} launch flag in the Intent.  (Activities after\n     * the first in the array are started in the context of the previous activity\n     * in the array, so FLAG_ACTIVITY_NEW_TASK is not needed nor desired for them.)\n     * </p>\n     *\n     * <p class=\"note\">\n     * The <em>last</em> intent in the array represents the key for the\n     * PendingIntent.  In other words, it is the significant element for matching\n     * (as done with the single intent given to {@link #getActivity(Context, int, Intent, int)},\n     * its content will be the subject of replacement by\n     * {@link #send(Context, int, Intent)} and {@link #FLAG_UPDATE_CURRENT}, etc.\n     * This is because it is the most specific of the supplied intents, and the\n     * UI the user actually sees when the intents are started.\n     * </p>\n     *\n     * <p class=\"note\">For security reasons, the {@link android.content.Intent} objects\n     * you supply here should almost always be <em>explicit intents</em>,\n     * that is specify an explicit component to be delivered to through\n     * {@link Intent#setClass(android.content.Context, Class) Intent.setClass}</p>\n     *\n     * @param context The Context in which this PendingIntent should start\n     * the activity.\n     * @param requestCode Private request code for the sender\n     * @param intents Array of Intents of the activities to be launched.\n     * @param flags May be {@link #FLAG_ONE_SHOT}, {@link #FLAG_NO_CREATE},\n     * {@link #FLAG_CANCEL_CURRENT}, {@link #FLAG_UPDATE_CURRENT},\n     * or any of the flags as supported by\n     * {@link Intent#fillIn Intent.fillIn()} to control which unspecified parts\n     * of the intent that can be supplied when the actual send happens.\n     *\n     * @return Returns an existing or new PendingIntent matching the given\n     * parameters.  May return null only if {@link #FLAG_NO_CREATE} has been\n     * supplied.\n     ",
    "links" : [ "#getActivity", "#getActivity", "Context#startActivities", "Intent#FLAG_ACTIVITY_NEW_TASK", "#getActivity", "#send", "#FLAG_UPDATE_CURRENT", "android.content.Intent", "Intent#setClass", "#FLAG_ONE_SHOT", "#FLAG_NO_CREATE", "#FLAG_CANCEL_CURRENT", "#FLAG_UPDATE_CURRENT", "Intent#fillIn", "#FLAG_NO_CREATE" ]
  }, {
    "name" : "public static PendingIntent getActivities(Context context, int requestCode, @NonNull Intent[] intents, @Flags int flags, @Nullable Bundle options)",
    "returnType" : "PendingIntent",
    "comment" : "\n     * Like {@link #getActivity(Context, int, Intent, int)}, but allows an\n     * array of Intents to be supplied.  The last Intent in the array is\n     * taken as the primary key for the PendingIntent, like the single Intent\n     * given to {@link #getActivity(Context, int, Intent, int)}.  Upon sending\n     * the resulting PendingIntent, all of the Intents are started in the same\n     * way as they would be by passing them to {@link Context#startActivities(Intent[])}.\n     *\n     * <p class=\"note\">\n     * The <em>first</em> intent in the array will be started outside of the context of an\n     * existing activity, so you must use the {@link Intent#FLAG_ACTIVITY_NEW_TASK\n     * Intent.FLAG_ACTIVITY_NEW_TASK} launch flag in the Intent.  (Activities after\n     * the first in the array are started in the context of the previous activity\n     * in the array, so FLAG_ACTIVITY_NEW_TASK is not needed nor desired for them.)\n     * </p>\n     *\n     * <p class=\"note\">\n     * The <em>last</em> intent in the array represents the key for the\n     * PendingIntent.  In other words, it is the significant element for matching\n     * (as done with the single intent given to {@link #getActivity(Context, int, Intent, int)},\n     * its content will be the subject of replacement by\n     * {@link #send(Context, int, Intent)} and {@link #FLAG_UPDATE_CURRENT}, etc.\n     * This is because it is the most specific of the supplied intents, and the\n     * UI the user actually sees when the intents are started.\n     * </p>\n     *\n     * <p class=\"note\">For security reasons, the {@link android.content.Intent} objects\n     * you supply here should almost always be <em>explicit intents</em>,\n     * that is specify an explicit component to be delivered to through\n     * {@link Intent#setClass(android.content.Context, Class) Intent.setClass}</p>\n     *\n     * @param context The Context in which this PendingIntent should start\n     * the activity.\n     * @param requestCode Private request code for the sender\n     * @param intents Array of Intents of the activities to be launched.\n     * @param flags May be {@link #FLAG_ONE_SHOT}, {@link #FLAG_NO_CREATE},\n     * {@link #FLAG_CANCEL_CURRENT}, {@link #FLAG_UPDATE_CURRENT},\n     * {@link #FLAG_IMMUTABLE} or any of the flags as supported by\n     * {@link Intent#fillIn Intent.fillIn()} to control which unspecified parts\n     * of the intent that can be supplied when the actual send happens.\n     *\n     * @return Returns an existing or new PendingIntent matching the given\n     * parameters.  May return null only if {@link #FLAG_NO_CREATE} has been\n     * supplied.\n     ",
    "links" : [ "#getActivity", "#getActivity", "Context#startActivities", "Intent#FLAG_ACTIVITY_NEW_TASK", "#getActivity", "#send", "#FLAG_UPDATE_CURRENT", "android.content.Intent", "Intent#setClass", "#FLAG_ONE_SHOT", "#FLAG_NO_CREATE", "#FLAG_CANCEL_CURRENT", "#FLAG_UPDATE_CURRENT", "#FLAG_IMMUTABLE", "Intent#fillIn", "#FLAG_NO_CREATE" ]
  }, {
    "name" : "public static PendingIntent getActivitiesAsUser(Context context, int requestCode, @NonNull Intent[] intents, int flags, Bundle options, UserHandle user)",
    "returnType" : "PendingIntent",
    "comment" : "\n     * @hide\n     * Note that UserHandle.CURRENT will be interpreted at the time the\n     * activity is started, not when the pending intent is created.\n     ",
    "links" : [ ]
  }, {
    "name" : "public static PendingIntent getBroadcast(Context context, int requestCode, Intent intent, @Flags int flags)",
    "returnType" : "PendingIntent",
    "comment" : "\n     * Retrieve a PendingIntent that will perform a broadcast, like calling\n     * {@link Context#sendBroadcast(Intent) Context.sendBroadcast()}.\n     *\n     * <p class=\"note\">For security reasons, the {@link android.content.Intent}\n     * you supply here should almost always be an <em>explicit intent</em>,\n     * that is specify an explicit component to be delivered to through\n     * {@link Intent#setClass(android.content.Context, Class) Intent.setClass}</p>\n     *\n     * @param context The Context in which this PendingIntent should perform\n     * the broadcast.\n     * @param requestCode Private request code for the sender\n     * @param intent The Intent to be broadcast.\n     * @param flags May be {@link #FLAG_ONE_SHOT}, {@link #FLAG_NO_CREATE},\n     * {@link #FLAG_CANCEL_CURRENT}, {@link #FLAG_UPDATE_CURRENT},\n     * {@link #FLAG_IMMUTABLE} or any of the flags as supported by\n     * {@link Intent#fillIn Intent.fillIn()} to control which unspecified parts\n     * of the intent that can be supplied when the actual send happens.\n     *\n     * @return Returns an existing or new PendingIntent matching the given\n     * parameters.  May return null only if {@link #FLAG_NO_CREATE} has been\n     * supplied.\n     ",
    "links" : [ "Context#sendBroadcast", "android.content.Intent", "Intent#setClass", "#FLAG_ONE_SHOT", "#FLAG_NO_CREATE", "#FLAG_CANCEL_CURRENT", "#FLAG_UPDATE_CURRENT", "#FLAG_IMMUTABLE", "Intent#fillIn", "#FLAG_NO_CREATE" ]
  }, {
    "name" : "public static PendingIntent getBroadcastAsUser(Context context, int requestCode, Intent intent, int flags, UserHandle userHandle)",
    "returnType" : "PendingIntent",
    "comment" : "\n     * @hide\n     * Note that UserHandle.CURRENT will be interpreted at the time the\n     * broadcast is sent, not when the pending intent is created.\n     ",
    "links" : [ ]
  }, {
    "name" : "public static PendingIntent getService(Context context, int requestCode, @NonNull Intent intent, @Flags int flags)",
    "returnType" : "PendingIntent",
    "comment" : "\n     * Retrieve a PendingIntent that will start a service, like calling\n     * {@link Context#startService Context.startService()}.  The start\n     * arguments given to the service will come from the extras of the Intent.\n     *\n     * <p class=\"note\">For security reasons, the {@link android.content.Intent}\n     * you supply here should almost always be an <em>explicit intent</em>,\n     * that is specify an explicit component to be delivered to through\n     * {@link Intent#setClass(android.content.Context, Class) Intent.setClass}</p>\n     *\n     * @param context The Context in which this PendingIntent should start\n     * the service.\n     * @param requestCode Private request code for the sender\n     * @param intent An Intent describing the service to be started.\n     * @param flags May be {@link #FLAG_ONE_SHOT}, {@link #FLAG_NO_CREATE},\n     * {@link #FLAG_CANCEL_CURRENT}, {@link #FLAG_UPDATE_CURRENT},\n     * {@link #FLAG_IMMUTABLE} or any of the flags as supported by\n     * {@link Intent#fillIn Intent.fillIn()} to control which unspecified parts\n     * of the intent that can be supplied when the actual send happens.\n     *\n     * @return Returns an existing or new PendingIntent matching the given\n     * parameters.  May return null only if {@link #FLAG_NO_CREATE} has been\n     * supplied.\n     ",
    "links" : [ "Context#startService", "android.content.Intent", "Intent#setClass", "#FLAG_ONE_SHOT", "#FLAG_NO_CREATE", "#FLAG_CANCEL_CURRENT", "#FLAG_UPDATE_CURRENT", "#FLAG_IMMUTABLE", "Intent#fillIn", "#FLAG_NO_CREATE" ]
  }, {
    "name" : "public static PendingIntent getForegroundService(Context context, int requestCode, @NonNull Intent intent, @Flags int flags)",
    "returnType" : "PendingIntent",
    "comment" : "\n     * Retrieve a PendingIntent that will start a foreground service, like calling\n     * {@link Context#startForegroundService Context.startForegroundService()}.  The start\n     * arguments given to the service will come from the extras of the Intent.\n     *\n     * <p class=\"note\">For security reasons, the {@link android.content.Intent}\n     * you supply here should almost always be an <em>explicit intent</em>,\n     * that is specify an explicit component to be delivered to through\n     * {@link Intent#setClass(android.content.Context, Class) Intent.setClass}</p>\n     *\n     * @param context The Context in which this PendingIntent should start\n     * the service.\n     * @param requestCode Private request code for the sender\n     * @param intent An Intent describing the service to be started.\n     * @param flags May be {@link #FLAG_ONE_SHOT}, {@link #FLAG_NO_CREATE},\n     * {@link #FLAG_CANCEL_CURRENT}, {@link #FLAG_UPDATE_CURRENT},\n     * {@link #FLAG_IMMUTABLE} or any of the flags as supported by\n     * {@link Intent#fillIn Intent.fillIn()} to control which unspecified parts\n     * of the intent that can be supplied when the actual send happens.\n     *\n     * @return Returns an existing or new PendingIntent matching the given\n     * parameters.  May return null only if {@link #FLAG_NO_CREATE} has been\n     * supplied.\n     ",
    "links" : [ "Context#startForegroundService", "android.content.Intent", "Intent#setClass", "#FLAG_ONE_SHOT", "#FLAG_NO_CREATE", "#FLAG_CANCEL_CURRENT", "#FLAG_UPDATE_CURRENT", "#FLAG_IMMUTABLE", "Intent#fillIn", "#FLAG_NO_CREATE" ]
  }, {
    "name" : "private static PendingIntent buildServicePendingIntent(Context context, int requestCode, Intent intent, int flags, int serviceKind)",
    "returnType" : "PendingIntent",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public IntentSender getIntentSender()",
    "returnType" : "IntentSender",
    "comment" : "\n     * Retrieve a IntentSender object that wraps the existing sender of the PendingIntent\n     *\n     * @return Returns a IntentSender object that wraps the sender of PendingIntent\n     *\n     ",
    "links" : [ ]
  }, {
    "name" : "public void cancel()",
    "returnType" : "void",
    "comment" : "\n     * Cancel a currently active PendingIntent.  Only the original application\n     * owning a PendingIntent can cancel it.\n     ",
    "links" : [ ]
  }, {
    "name" : "public void send() throws CanceledException",
    "returnType" : "void",
    "comment" : "\n     * Perform the operation associated with this PendingIntent.\n     *\n     * @see #send(Context, int, Intent, android.app.PendingIntent.OnFinished, Handler)\n     *\n     * @throws CanceledException Throws CanceledException if the PendingIntent\n     * is no longer allowing more intents to be sent through it.\n     ",
    "links" : [ ]
  }, {
    "name" : "public void send(int code) throws CanceledException",
    "returnType" : "void",
    "comment" : "\n     * Perform the operation associated with this PendingIntent.\n     *\n     * @param code Result code to supply back to the PendingIntent's target.\n     *\n     * @see #send(Context, int, Intent, android.app.PendingIntent.OnFinished, Handler)\n     *\n     * @throws CanceledException Throws CanceledException if the PendingIntent\n     * is no longer allowing more intents to be sent through it.\n     ",
    "links" : [ ]
  }, {
    "name" : "public void send(Context context, int code, @Nullable Intent intent) throws CanceledException",
    "returnType" : "void",
    "comment" : "\n     * Perform the operation associated with this PendingIntent, allowing the\n     * caller to specify information about the Intent to use.\n     *\n     * @param context The Context of the caller.\n     * @param code Result code to supply back to the PendingIntent's target.\n     * @param intent Additional Intent data.  See {@link Intent#fillIn\n     * Intent.fillIn()} for information on how this is applied to the\n     * original Intent. If flag {@link #FLAG_IMMUTABLE} was set when this\n     * pending intent was created, this argument will be ignored.\n     *\n     * @see #send(Context, int, Intent, android.app.PendingIntent.OnFinished, Handler)\n     *\n     * @throws CanceledException Throws CanceledException if the PendingIntent\n     * is no longer allowing more intents to be sent through it.\n     ",
    "links" : [ "Intent#fillIn", "#FLAG_IMMUTABLE" ]
  }, {
    "name" : "public void send(int code, @Nullable OnFinished onFinished, @Nullable Handler handler) throws CanceledException",
    "returnType" : "void",
    "comment" : "\n     * Perform the operation associated with this PendingIntent, allowing the\n     * caller to be notified when the send has completed.\n     *\n     * @param code Result code to supply back to the PendingIntent's target.\n     * @param onFinished The object to call back on when the send has\n     * completed, or null for no callback.\n     * @param handler Handler identifying the thread on which the callback\n     * should happen.  If null, the callback will happen from the thread\n     * pool of the process.\n     *\n     * @see #send(Context, int, Intent, android.app.PendingIntent.OnFinished, Handler)\n     *\n     * @throws CanceledException Throws CanceledException if the PendingIntent\n     * is no longer allowing more intents to be sent through it.\n     ",
    "links" : [ ]
  }, {
    "name" : "public void send(Context context, int code, @Nullable Intent intent, @Nullable OnFinished onFinished, @Nullable Handler handler) throws CanceledException",
    "returnType" : "void",
    "comment" : "\n     * Perform the operation associated with this PendingIntent, allowing the\n     * caller to specify information about the Intent to use and be notified\n     * when the send has completed.\n     *\n     * <p>For the intent parameter, a PendingIntent\n     * often has restrictions on which fields can be supplied here, based on\n     * how the PendingIntent was retrieved in {@link #getActivity},\n     * {@link #getBroadcast}, or {@link #getService}.\n     *\n     * @param context The Context of the caller.  This may be null if\n     * <var>intent</var> is also null.\n     * @param code Result code to supply back to the PendingIntent's target.\n     * @param intent Additional Intent data.  See {@link Intent#fillIn\n     * Intent.fillIn()} for information on how this is applied to the\n     * original Intent.  Use null to not modify the original Intent.\n     * If flag {@link #FLAG_IMMUTABLE} was set when this pending intent was\n     * created, this argument will be ignored.\n     * @param onFinished The object to call back on when the send has\n     * completed, or null for no callback.\n     * @param handler Handler identifying the thread on which the callback\n     * should happen.  If null, the callback will happen from the thread\n     * pool of the process.\n     *\n     * @see #send()\n     * @see #send(int)\n     * @see #send(Context, int, Intent)\n     * @see #send(int, android.app.PendingIntent.OnFinished, Handler)\n     * @see #send(Context, int, Intent, OnFinished, Handler, String)\n     *\n     * @throws CanceledException Throws CanceledException if the PendingIntent\n     * is no longer allowing more intents to be sent through it.\n     ",
    "links" : [ "#getActivity", "#getBroadcast", "#getService", "Intent#fillIn", "#FLAG_IMMUTABLE" ]
  }, {
    "name" : "public void send(Context context, int code, @Nullable Intent intent, @Nullable OnFinished onFinished, @Nullable Handler handler, @Nullable String requiredPermission) throws CanceledException",
    "returnType" : "void",
    "comment" : "\n     * Perform the operation associated with this PendingIntent, allowing the\n     * caller to specify information about the Intent to use and be notified\n     * when the send has completed.\n     *\n     * <p>For the intent parameter, a PendingIntent\n     * often has restrictions on which fields can be supplied here, based on\n     * how the PendingIntent was retrieved in {@link #getActivity},\n     * {@link #getBroadcast}, or {@link #getService}.\n     *\n     * @param context The Context of the caller.  This may be null if\n     * <var>intent</var> is also null.\n     * @param code Result code to supply back to the PendingIntent's target.\n     * @param intent Additional Intent data.  See {@link Intent#fillIn\n     * Intent.fillIn()} for information on how this is applied to the\n     * original Intent.  Use null to not modify the original Intent.\n     * If flag {@link #FLAG_IMMUTABLE} was set when this pending intent was\n     * created, this argument will be ignored.\n     * @param onFinished The object to call back on when the send has\n     * completed, or null for no callback.\n     * @param handler Handler identifying the thread on which the callback\n     * should happen.  If null, the callback will happen from the thread\n     * pool of the process.\n     * @param requiredPermission Name of permission that a recipient of the PendingIntent\n     * is required to hold.  This is only valid for broadcast intents, and\n     * corresponds to the permission argument in\n     * {@link Context#sendBroadcast(Intent, String) Context.sendOrderedBroadcast(Intent, String)}.\n     * If null, no permission is required.\n     *\n     * @see #send()\n     * @see #send(int)\n     * @see #send(Context, int, Intent)\n     * @see #send(int, android.app.PendingIntent.OnFinished, Handler)\n     * @see #send(Context, int, Intent, OnFinished, Handler)\n     *\n     * @throws CanceledException Throws CanceledException if the PendingIntent\n     * is no longer allowing more intents to be sent through it.\n     ",
    "links" : [ "#getActivity", "#getBroadcast", "#getService", "Intent#fillIn", "#FLAG_IMMUTABLE", "Context#sendBroadcast" ]
  }, {
    "name" : "public void send(Context context, int code, @Nullable Intent intent, @Nullable OnFinished onFinished, @Nullable Handler handler, @Nullable String requiredPermission, @Nullable Bundle options) throws CanceledException",
    "returnType" : "void",
    "comment" : "\n     * Perform the operation associated with this PendingIntent, allowing the\n     * caller to specify information about the Intent to use and be notified\n     * when the send has completed.\n     *\n     * <p>For the intent parameter, a PendingIntent\n     * often has restrictions on which fields can be supplied here, based on\n     * how the PendingIntent was retrieved in {@link #getActivity},\n     * {@link #getBroadcast}, or {@link #getService}.\n     *\n     * @param context The Context of the caller.  This may be null if\n     * <var>intent</var> is also null.\n     * @param code Result code to supply back to the PendingIntent's target.\n     * @param intent Additional Intent data.  See {@link Intent#fillIn\n     * Intent.fillIn()} for information on how this is applied to the\n     * original Intent.  Use null to not modify the original Intent.\n     * If flag {@link #FLAG_IMMUTABLE} was set when this pending intent was\n     * created, this argument will be ignored.\n     * @param onFinished The object to call back on when the send has\n     * completed, or null for no callback.\n     * @param handler Handler identifying the thread on which the callback\n     * should happen.  If null, the callback will happen from the thread\n     * pool of the process.\n     * @param requiredPermission Name of permission that a recipient of the PendingIntent\n     * is required to hold.  This is only valid for broadcast intents, and\n     * corresponds to the permission argument in\n     * {@link Context#sendBroadcast(Intent, String) Context.sendOrderedBroadcast(Intent, String)}.\n     * If null, no permission is required.\n     * @param options Additional options the caller would like to provide to modify the sending\n     * behavior.  May be built from an {@link ActivityOptions} to apply to an activity start.\n     *\n     * @see #send()\n     * @see #send(int)\n     * @see #send(Context, int, Intent)\n     * @see #send(int, android.app.PendingIntent.OnFinished, Handler)\n     * @see #send(Context, int, Intent, OnFinished, Handler)\n     *\n     * @throws CanceledException Throws CanceledException if the PendingIntent\n     * is no longer allowing more intents to be sent through it.\n     ",
    "links" : [ "#getActivity", "#getBroadcast", "#getService", "Intent#fillIn", "#FLAG_IMMUTABLE", "Context#sendBroadcast", "ActivityOptions" ]
  }, {
    "name" : "public int sendAndReturnResult(Context context, int code, @Nullable Intent intent, @Nullable OnFinished onFinished, @Nullable Handler handler, @Nullable String requiredPermission, @Nullable Bundle options) throws CanceledException",
    "returnType" : "int",
    "comment" : "\n     * Like {@link #send}, but returns the result\n     * @hide\n     ",
    "links" : [ "#send" ]
  }, {
    "name" : "public String getTargetPackage()",
    "returnType" : "String",
    "comment" : "\n     * @deprecated Renamed to {@link #getCreatorPackage()}.\n     ",
    "links" : [ "#getCreatorPackage" ]
  }, {
    "name" : "public String getCreatorPackage()",
    "returnType" : "String",
    "comment" : "\n     * Return the package name of the application that created this\n     * PendingIntent, that is the identity under which you will actually be\n     * sending the Intent.  The returned string is supplied by the system, so\n     * that an application can not spoof its package.\n     *\n     * <p class=\"note\">Be careful about how you use this.  All this tells you is\n     * who created the PendingIntent.  It does <strong>not</strong> tell you who\n     * handed the PendingIntent to you: that is, PendingIntent objects are intended to be\n     * passed between applications, so the PendingIntent you receive from an application\n     * could actually be one it received from another application, meaning the result\n     * you get here will identify the original application.  Because of this, you should\n     * only use this information to identify who you expect to be interacting with\n     * through a {@link #send} call, not who gave you the PendingIntent.</p>\n     *\n     * @return The package name of the PendingIntent, or null if there is\n     * none associated with it.\n     ",
    "links" : [ "#send" ]
  }, {
    "name" : "public int getCreatorUid()",
    "returnType" : "int",
    "comment" : "\n     * Return the uid of the application that created this\n     * PendingIntent, that is the identity under which you will actually be\n     * sending the Intent.  The returned integer is supplied by the system, so\n     * that an application can not spoof its uid.\n     *\n     * <p class=\"note\">Be careful about how you use this.  All this tells you is\n     * who created the PendingIntent.  It does <strong>not</strong> tell you who\n     * handed the PendingIntent to you: that is, PendingIntent objects are intended to be\n     * passed between applications, so the PendingIntent you receive from an application\n     * could actually be one it received from another application, meaning the result\n     * you get here will identify the original application.  Because of this, you should\n     * only use this information to identify who you expect to be interacting with\n     * through a {@link #send} call, not who gave you the PendingIntent.</p>\n     *\n     * @return The uid of the PendingIntent, or -1 if there is\n     * none associated with it.\n     ",
    "links" : [ "#send" ]
  }, {
    "name" : "public void registerCancelListener(CancelListener cancelListener)",
    "returnType" : "void",
    "comment" : "\n     * Register a listener to when this pendingIntent is cancelled. There are no guarantees on which\n     * thread a listener will be called and it's up to the caller to synchronize. This may\n     * trigger a synchronous binder call so should therefore usually be called on a background\n     * thread.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "private void notifyCancelListeners()",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public void unregisterCancelListener(CancelListener cancelListener)",
    "returnType" : "void",
    "comment" : "\n     * Un-register a listener to when this pendingIntent is cancelled.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public UserHandle getCreatorUserHandle()",
    "returnType" : "UserHandle",
    "comment" : "\n     * Return the user handle of the application that created this\n     * PendingIntent, that is the user under which you will actually be\n     * sending the Intent.  The returned UserHandle is supplied by the system, so\n     * that an application can not spoof its user.  See\n     * {@link android.os.Process#myUserHandle() Process.myUserHandle()} for\n     * more explanation of user handles.\n     *\n     * <p class=\"note\">Be careful about how you use this.  All this tells you is\n     * who created the PendingIntent.  It does <strong>not</strong> tell you who\n     * handed the PendingIntent to you: that is, PendingIntent objects are intended to be\n     * passed between applications, so the PendingIntent you receive from an application\n     * could actually be one it received from another application, meaning the result\n     * you get here will identify the original application.  Because of this, you should\n     * only use this information to identify who you expect to be interacting with\n     * through a {@link #send} call, not who gave you the PendingIntent.</p>\n     *\n     * @return The user handle of the PendingIntent, or null if there is\n     * none associated with it.\n     ",
    "links" : [ "android.os.Process#myUserHandle", "#send" ]
  }, {
    "name" : "public boolean isTargetedToPackage()",
    "returnType" : "boolean",
    "comment" : "\n     * @hide\n     * Check to verify that this PendingIntent targets a specific package.\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean isActivity()",
    "returnType" : "boolean",
    "comment" : "\n     * @hide\n     * Check whether this PendingIntent will launch an Activity.\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean isForegroundService()",
    "returnType" : "boolean",
    "comment" : "\n     * @hide\n     * Check whether this PendingIntent will launch a foreground service\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean isBroadcast()",
    "returnType" : "boolean",
    "comment" : "\n     * @hide\n     * Check whether this PendingIntent will launch an Activity.\n     ",
    "links" : [ ]
  }, {
    "name" : "public Intent getIntent()",
    "returnType" : "Intent",
    "comment" : "\n     * @hide\n     * Return the Intent of this PendingIntent.\n     ",
    "links" : [ ]
  }, {
    "name" : "public String getTag(String prefix)",
    "returnType" : "String",
    "comment" : "\n     * @hide\n     * Return descriptive tag for this PendingIntent.\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean equals(Object otherObj)",
    "returnType" : "boolean",
    "comment" : "\n     * Comparison operator on two PendingIntent objects, such that true\n     * is returned then they both represent the same operation from the\n     * same package.  This allows you to use {@link #getActivity},\n     * {@link #getBroadcast}, or {@link #getService} multiple times (even\n     * across a process being killed), resulting in different PendingIntent\n     * objects but whose equals() method identifies them as being the same\n     * operation.\n     ",
    "links" : [ "#getActivity", "#getBroadcast", "#getService" ]
  }, {
    "name" : "public int hashCode()",
    "returnType" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public String toString()",
    "returnType" : "String",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public void dumpDebug(ProtoOutputStream proto, long fieldId)",
    "returnType" : "void",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "public int describeContents()",
    "returnType" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public void writeToParcel(Parcel out, int flags)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public static void writePendingIntentOrNullToParcel(@Nullable PendingIntent sender, @NonNull Parcel out)",
    "returnType" : "void",
    "comment" : "\n     * Convenience function for writing either a PendingIntent or null pointer to\n     * a Parcel.  You must use this with {@link #readPendingIntentOrNullFromParcel}\n     * for later reading it.\n     *\n     * @param sender The PendingIntent to write, or null.\n     * @param out Where to write the PendingIntent.\n     ",
    "links" : [ "#readPendingIntentOrNullFromParcel" ]
  }, {
    "name" : "public static PendingIntent readPendingIntentOrNullFromParcel(@NonNull Parcel in)",
    "returnType" : "PendingIntent",
    "comment" : "\n     * Convenience function for reading either a PendingIntent or null pointer from\n     * a Parcel.  You must have previously written the PendingIntent with\n     * {@link #writePendingIntentOrNullToParcel}.\n     *\n     * @param in The Parcel containing the written PendingIntent.\n     *\n     * @return Returns the PendingIntent read from the Parcel, or null if null had\n     * been written.\n     ",
    "links" : [ "#writePendingIntentOrNullToParcel" ]
  }, {
    "name" : "public IIntentSender getTarget()",
    "returnType" : "IIntentSender",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "public IBinder getWhitelistToken()",
    "returnType" : "IBinder",
    "comment" : " @hide ",
    "links" : [ ]
  } ],
  "variableNames" : [ "mTarget", "mCancelReceiver", "mWhitelistToken", "mCancelListeners", "FLAG_ONE_SHOT", "FLAG_NO_CREATE", "FLAG_CANCEL_CURRENT", "FLAG_UPDATE_CURRENT", "FLAG_IMMUTABLE", "sOnMarshaledListener", "CREATOR" ],
  "methodNames" : [ "public static void setOnMarshaledListener(OnMarshaledListener listener)", "public static PendingIntent getActivity(Context context, int requestCode, Intent intent, @Flags int flags)", "public static PendingIntent getActivity(Context context, int requestCode, @NonNull Intent intent, @Flags int flags, @Nullable Bundle options)", "public static PendingIntent getActivityAsUser(Context context, int requestCode, @NonNull Intent intent, int flags, Bundle options, UserHandle user)", "public static PendingIntent getActivities(Context context, int requestCode, @NonNull Intent[] intents, @Flags int flags)", "public static PendingIntent getActivities(Context context, int requestCode, @NonNull Intent[] intents, @Flags int flags, @Nullable Bundle options)", "public static PendingIntent getActivitiesAsUser(Context context, int requestCode, @NonNull Intent[] intents, int flags, Bundle options, UserHandle user)", "public static PendingIntent getBroadcast(Context context, int requestCode, Intent intent, @Flags int flags)", "public static PendingIntent getBroadcastAsUser(Context context, int requestCode, Intent intent, int flags, UserHandle userHandle)", "public static PendingIntent getService(Context context, int requestCode, @NonNull Intent intent, @Flags int flags)", "public static PendingIntent getForegroundService(Context context, int requestCode, @NonNull Intent intent, @Flags int flags)", "private static PendingIntent buildServicePendingIntent(Context context, int requestCode, Intent intent, int flags, int serviceKind)", "public IntentSender getIntentSender()", "public void cancel()", "public void send() throws CanceledException", "public void send(int code) throws CanceledException", "public void send(Context context, int code, @Nullable Intent intent) throws CanceledException", "public void send(int code, @Nullable OnFinished onFinished, @Nullable Handler handler) throws CanceledException", "public void send(Context context, int code, @Nullable Intent intent, @Nullable OnFinished onFinished, @Nullable Handler handler) throws CanceledException", "public void send(Context context, int code, @Nullable Intent intent, @Nullable OnFinished onFinished, @Nullable Handler handler, @Nullable String requiredPermission) throws CanceledException", "public void send(Context context, int code, @Nullable Intent intent, @Nullable OnFinished onFinished, @Nullable Handler handler, @Nullable String requiredPermission, @Nullable Bundle options) throws CanceledException", "public int sendAndReturnResult(Context context, int code, @Nullable Intent intent, @Nullable OnFinished onFinished, @Nullable Handler handler, @Nullable String requiredPermission, @Nullable Bundle options) throws CanceledException", "public String getTargetPackage()", "public String getCreatorPackage()", "public int getCreatorUid()", "public void registerCancelListener(CancelListener cancelListener)", "private void notifyCancelListeners()", "public void unregisterCancelListener(CancelListener cancelListener)", "public UserHandle getCreatorUserHandle()", "public boolean isTargetedToPackage()", "public boolean isActivity()", "public boolean isForegroundService()", "public boolean isBroadcast()", "public Intent getIntent()", "public String getTag(String prefix)", "public boolean equals(Object otherObj)", "public int hashCode()", "public String toString()", "public void dumpDebug(ProtoOutputStream proto, long fieldId)", "public int describeContents()", "public void writeToParcel(Parcel out, int flags)", "public static void writePendingIntentOrNullToParcel(@Nullable PendingIntent sender, @NonNull Parcel out)", "public static PendingIntent readPendingIntentOrNullFromParcel(@NonNull Parcel in)", "public IIntentSender getTarget()", "public IBinder getWhitelistToken()" ]
}