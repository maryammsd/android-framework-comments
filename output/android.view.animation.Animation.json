{
  "filePath" : "/home/maryam/clearblue/files/android-source-35/android/view/animation/Animation.java",
  "packageName" : "android.view.animation",
  "className" : "Animation",
  "comment" : "\n * Abstraction for an Animation that can be applied to Views, Surfaces, or\n * other objects. See the {@link android.view.animation animation package\n * description file}.\n ",
  "links" : [ "android.view.animation" ],
  "variables" : [ {
    "name" : "INFINITE",
    "type" : "int",
    "comment" : "\n     * Repeat the animation indefinitely.\n     ",
    "links" : [ ]
  }, {
    "name" : "RESTART",
    "type" : "int",
    "comment" : "\n     * When the animation reaches the end and the repeat count is INFINTE_REPEAT\n     * or a positive value, the animation restarts from the beginning.\n     ",
    "links" : [ ]
  }, {
    "name" : "REVERSE",
    "type" : "int",
    "comment" : "\n     * When the animation reaches the end and the repeat count is INFINTE_REPEAT\n     * or a positive value, the animation plays backward (and then forward again).\n     ",
    "links" : [ ]
  }, {
    "name" : "START_ON_FIRST_FRAME",
    "type" : "int",
    "comment" : "\n     * Can be used as the start time to indicate the start time should be the current\n     * time when {@link #getTransformation(long, Transformation)} is invoked for the\n     * first animation frame. This can is useful for short animations.\n     ",
    "links" : [ "#getTransformation(long" ]
  }, {
    "name" : "ABSOLUTE",
    "type" : "int",
    "comment" : "\n     * The specified dimension is an absolute number of pixels.\n     ",
    "links" : [ ]
  }, {
    "name" : "RELATIVE_TO_SELF",
    "type" : "int",
    "comment" : "\n     * The specified dimension holds a float and should be multiplied by the\n     * height or width of the object being animated.\n     ",
    "links" : [ ]
  }, {
    "name" : "RELATIVE_TO_PARENT",
    "type" : "int",
    "comment" : "\n     * The specified dimension holds a float and should be multiplied by the\n     * height or width of the parent of the object being animated.\n     ",
    "links" : [ ]
  }, {
    "name" : "ZORDER_NORMAL",
    "type" : "int",
    "comment" : "\n     * Requests that the content being animated be kept in its current Z\n     * order.\n     ",
    "links" : [ ]
  }, {
    "name" : "ZORDER_TOP",
    "type" : "int",
    "comment" : "\n     * Requests that the content being animated be forced on top of all other\n     * content for the duration of the animation.\n     ",
    "links" : [ ]
  }, {
    "name" : "ZORDER_BOTTOM",
    "type" : "int",
    "comment" : "\n     * Requests that the content being animated be forced under all other\n     * content for the duration of the animation.\n     ",
    "links" : [ ]
  }, {
    "name" : "mEnded",
    "type" : "boolean",
    "comment" : "\n     * Set by {@link #getTransformation(long, Transformation)} when the animation ends.\n     ",
    "links" : [ "#getTransformation(long" ]
  }, {
    "name" : "mStarted",
    "type" : "boolean",
    "comment" : "\n     * Set by {@link #getTransformation(long, Transformation)} when the animation starts.\n     ",
    "links" : [ "#getTransformation(long" ]
  }, {
    "name" : "mCycleFlip",
    "type" : "boolean",
    "comment" : "\n     * Set by {@link #getTransformation(long, Transformation)} when the animation repeats\n     * in REVERSE mode.\n     ",
    "links" : [ "#getTransformation(long" ]
  }, {
    "name" : "mInitialized",
    "type" : "boolean",
    "comment" : "\n     * This value must be set to true by {@link #initialize(int, int, int, int)}. It\n     * indicates the animation was successfully initialized and can be played.\n     ",
    "links" : [ "#initialize(int" ]
  }, {
    "name" : "mFillBefore",
    "type" : "boolean",
    "comment" : "\n     * Indicates whether the animation transformation should be applied before the\n     * animation starts. The value of this variable is only relevant if mFillEnabled is true;\n     * otherwise it is assumed to be true.\n     ",
    "links" : [ ]
  }, {
    "name" : "mFillAfter",
    "type" : "boolean",
    "comment" : "\n     * Indicates whether the animation transformation should be applied after the\n     * animation ends.\n     ",
    "links" : [ ]
  }, {
    "name" : "mFillEnabled",
    "type" : "boolean",
    "comment" : "\n     * Indicates whether fillBefore should be taken into account.\n     ",
    "links" : [ ]
  }, {
    "name" : "mStartTime",
    "type" : "long",
    "comment" : "\n     * The time in milliseconds at which the animation must start;\n     ",
    "links" : [ ]
  }, {
    "name" : "mStartOffset",
    "type" : "long",
    "comment" : "\n     * The delay in milliseconds after which the animation must start. When the\n     * start offset is > 0, the start time of the animation is startTime + startOffset.\n     ",
    "links" : [ ]
  }, {
    "name" : "mDuration",
    "type" : "long",
    "comment" : "\n     * The duration of one animation cycle in milliseconds.\n     ",
    "links" : [ ]
  }, {
    "name" : "mRepeatCount",
    "type" : "int",
    "comment" : "\n     * The number of times the animation must repeat. By default, an animation repeats\n     * indefinitely.\n     ",
    "links" : [ ]
  }, {
    "name" : "mRepeated",
    "type" : "int",
    "comment" : "\n     * Indicates how many times the animation was repeated.\n     ",
    "links" : [ ]
  }, {
    "name" : "mRepeatMode",
    "type" : "int",
    "comment" : "\n     * The behavior of the animation when it repeats. The repeat mode is either\n     * {@link #RESTART} or {@link #REVERSE}.\n     *\n     ",
    "links" : [ "#RESTART", "#REVERSE" ]
  }, {
    "name" : "mInterpolator",
    "type" : "Interpolator",
    "comment" : "\n     * The interpolator used by the animation to smooth the movement.\n     ",
    "links" : [ ]
  }, {
    "name" : "mListener",
    "type" : "AnimationListener",
    "comment" : " and add your new listener to that set",
    "links" : [ ]
  }, {
    "name" : "mZAdjustment",
    "type" : "int",
    "comment" : "\n     * Desired Z order mode during animation.\n     ",
    "links" : [ ]
  }, {
    "name" : "mBackdropColor",
    "type" : "int",
    "comment" : "\n     * The desired color of the backdrop to show behind the animation.\n     ",
    "links" : [ ]
  }, {
    "name" : "mScaleFactor",
    "type" : "float",
    "comment" : "\n     * scalefactor to apply to pivot points, etc. during animation. Subclasses retrieve the\n     * value via getScaleFactor().\n     ",
    "links" : [ ]
  }, {
    "name" : "mShowWallpaper",
    "type" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mHasRoundedCorners",
    "type" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mShowBackdrop",
    "type" : "boolean",
    "comment" : "\n     * Whether to show a background behind the windows during the animation.\n     * @see #getShowBackdrop()\n     * @see #setShowBackdrop(boolean)\n     ",
    "links" : [ ]
  }, {
    "name" : "mMore",
    "type" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mOneMoreTime",
    "type" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mPreviousRegion",
    "type" : "RectF",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mRegion",
    "type" : "RectF",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mTransformation",
    "type" : "Transformation",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mPreviousTransformation",
    "type" : "Transformation",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "guard",
    "type" : "CloseGuard",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mListenerHandler",
    "type" : "Handler",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mOnStart",
    "type" : "Runnable",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mOnRepeat",
    "type" : "Runnable",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mOnEnd",
    "type" : "Runnable",
    "comment" : "",
    "links" : [ ]
  } ],
  "methods" : [ {
    "name" : "protected Animation clone() throws CloneNotSupportedException",
    "returnType" : "Animation",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public void reset()",
    "returnType" : "void",
    "comment" : "\n     * Reset the initialization state of this animation.\n     *\n     * @see #initialize(int, int, int, int)\n     ",
    "links" : [ ]
  }, {
    "name" : "public void cancel()",
    "returnType" : "void",
    "comment" : "\n     * Cancel the animation. Cancelling an animation invokes the animation\n     * listener, if set, to notify the end of the animation.\n     *\n     * If you cancel an animation manually, you must call {@link #reset()}\n     * before starting the animation again.\n     *\n     * @see #reset()\n     * @see #start()\n     * @see #startNow()\n     ",
    "links" : [ "#reset()" ]
  }, {
    "name" : "public void detach()",
    "returnType" : "void",
    "comment" : "\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean isInitialized()",
    "returnType" : "boolean",
    "comment" : "\n     * Whether or not the animation has been initialized.\n     *\n     * @return Has this animation been initialized.\n     * @see #initialize(int, int, int, int)\n     ",
    "links" : [ ]
  }, {
    "name" : "public void initialize(int width, int height, int parentWidth, int parentHeight)",
    "returnType" : "void",
    "comment" : "\n     * Initialize this animation with the dimensions of the object being\n     * animated as well as the objects parents. (This is to support animation\n     * sizes being specified relative to these dimensions.)\n     *\n     * <p>Objects that interpret Animations should call this method when\n     * the sizes of the object being animated and its parent are known, and\n     * before calling {@link #getTransformation}.\n     *\n     *\n     * @param width Width of the object being animated\n     * @param height Height of the object being animated\n     * @param parentWidth Width of the animated object's parent\n     * @param parentHeight Height of the animated object's parent\n     ",
    "links" : [ "#getTransformation" ]
  }, {
    "name" : "public void setListenerHandler(Handler handler)",
    "returnType" : "void",
    "comment" : "\n     * Sets the handler used to invoke listeners.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public void setInterpolator(Context context, @AnimRes @InterpolatorRes int resID)",
    "returnType" : "void",
    "comment" : "\n     * Sets the acceleration curve for this animation. The interpolator is loaded as\n     * a resource from the specified context.\n     *\n     * @param context The application environment\n     * @param resID The resource identifier of the interpolator to load\n     * @attr ref android.R.styleable#Animation_interpolator\n     ",
    "links" : [ ]
  }, {
    "name" : "public void setInterpolator(Interpolator i)",
    "returnType" : "void",
    "comment" : "\n     * Sets the acceleration curve for this animation. Defaults to a linear\n     * interpolation.\n     *\n     * @param i The interpolator which defines the acceleration curve\n     * @attr ref android.R.styleable#Animation_interpolator\n     ",
    "links" : [ ]
  }, {
    "name" : "public void setStartOffset(long startOffset)",
    "returnType" : "void",
    "comment" : "\n     * When this animation should start relative to the start time. This is most\n     * useful when composing complex animations using an {@link AnimationSet }\n     * where some of the animations components start at different times.\n     *\n     * @param startOffset When this Animation should start, in milliseconds from\n     *                    the start time of the root AnimationSet.\n     * @attr ref android.R.styleable#Animation_startOffset\n     ",
    "links" : [ "android.view.animation.AnimationSet" ]
  }, {
    "name" : "public void setDuration(long durationMillis)",
    "returnType" : "void",
    "comment" : "\n     * How long this animation should last. The duration cannot be negative.\n     *\n     * @param durationMillis Duration in milliseconds\n     *\n     * @throws java.lang.IllegalArgumentException if the duration is < 0\n     *\n     * @attr ref android.R.styleable#Animation_duration\n     ",
    "links" : [ ]
  }, {
    "name" : "public void restrictDuration(long durationMillis)",
    "returnType" : "void",
    "comment" : "\n     * Ensure that the duration that this animation will run is not longer\n     * than <var>durationMillis</var>.  In addition to adjusting the duration\n     * itself, this ensures that the repeat count also will not make it run\n     * longer than the given time.\n     *\n     * @param durationMillis The maximum duration the animation is allowed\n     * to run.\n     ",
    "links" : [ ]
  }, {
    "name" : "public void scaleCurrentDuration(float scale)",
    "returnType" : "void",
    "comment" : "\n     * How much to scale the duration by.\n     *\n     * @param scale The amount to scale the duration.\n     ",
    "links" : [ ]
  }, {
    "name" : "public void setStartTime(long startTimeMillis)",
    "returnType" : "void",
    "comment" : "\n     * When this animation should start. When the start time is set to\n     * {@link #START_ON_FIRST_FRAME}, the animation will start the first time\n     * {@link #getTransformation(long, Transformation)} is invoked. The time passed\n     * to this method should be obtained by calling\n     * {@link AnimationUtils#currentAnimationTimeMillis()} instead of\n     * {@link System#currentTimeMillis()}.\n     *\n     * @param startTimeMillis the start time in milliseconds\n     ",
    "links" : [ "#getTransformation(long", "#currentTimeMillis()", "android.view.animation.AnimationUtils#currentAnimationTimeMillis()", "#START_ON_FIRST_FRAME" ]
  }, {
    "name" : "public void start()",
    "returnType" : "void",
    "comment" : "\n     * Convenience method to start the animation the first time\n     * {@link #getTransformation(long, Transformation)} is invoked.\n     ",
    "links" : [ "#getTransformation(long" ]
  }, {
    "name" : "public void startNow()",
    "returnType" : "void",
    "comment" : "\n     * Convenience method to start the animation at the current time in\n     * milliseconds.\n     ",
    "links" : [ ]
  }, {
    "name" : "public void setRepeatMode(int repeatMode)",
    "returnType" : "void",
    "comment" : "\n     * Defines what this animation should do when it reaches the end. This\n     * setting is applied only when the repeat count is either greater than\n     * 0 or {@link #INFINITE}. Defaults to {@link #RESTART}.\n     *\n     * @param repeatMode {@link #RESTART} or {@link #REVERSE}\n     * @attr ref android.R.styleable#Animation_repeatMode\n     ",
    "links" : [ "#RESTART", "#INFINITE", "#REVERSE" ]
  }, {
    "name" : "public void setRepeatCount(int repeatCount)",
    "returnType" : "void",
    "comment" : "\n     * Sets how many times the animation should be repeated. If the repeat\n     * count is 0, the animation is never repeated. If the repeat count is\n     * greater than 0 or {@link #INFINITE}, the repeat mode will be taken\n     * into account. The repeat count is 0 by default.\n     *\n     * @param repeatCount the number of times the animation should be repeated\n     * @attr ref android.R.styleable#Animation_repeatCount\n     ",
    "links" : [ "#INFINITE" ]
  }, {
    "name" : "public boolean isFillEnabled()",
    "returnType" : "boolean",
    "comment" : "\n     * If fillEnabled is true, this animation will apply the value of fillBefore.\n     *\n     * @return true if the animation will take fillBefore into account\n     * @attr ref android.R.styleable#Animation_fillEnabled\n     ",
    "links" : [ ]
  }, {
    "name" : "public void setFillEnabled(boolean fillEnabled)",
    "returnType" : "void",
    "comment" : "\n     * If fillEnabled is true, the animation will apply the value of fillBefore.\n     * Otherwise, fillBefore is ignored and the animation\n     * transformation is always applied until the animation ends.\n     *\n     * @param fillEnabled true if the animation should take the value of fillBefore into account\n     * @attr ref android.R.styleable#Animation_fillEnabled\n     *\n     * @see #setFillBefore(boolean)\n     * @see #setFillAfter(boolean)\n     ",
    "links" : [ ]
  }, {
    "name" : "public void setFillBefore(boolean fillBefore)",
    "returnType" : "void",
    "comment" : "\n     * If fillBefore is true, this animation will apply its transformation\n     * before the start time of the animation. Defaults to true if\n     * {@link #setFillEnabled(boolean)} is not set to true.\n     * Note that this applies when using an {@link\n     * android.view.animation.AnimationSet AnimationSet} to chain\n     * animations. The transformation is not applied before the AnimationSet\n     * itself starts.\n     *\n     * @param fillBefore true if the animation should apply its transformation before it starts\n     * @attr ref android.R.styleable#Animation_fillBefore\n     *\n     * @see #setFillEnabled(boolean)\n     ",
    "links" : [ "android.view.animation.AnimationSet", "#setFillEnabled(boolean)" ]
  }, {
    "name" : "public void setFillAfter(boolean fillAfter)",
    "returnType" : "void",
    "comment" : "\n     * If fillAfter is true, the transformation that this animation performed\n     * will persist when it is finished. Defaults to false if not set.\n     * Note that this applies to individual animations and when using an {@link\n     * android.view.animation.AnimationSet AnimationSet} to chain\n     * animations.\n     *\n     * @param fillAfter true if the animation should apply its transformation after it ends\n     * @attr ref android.R.styleable#Animation_fillAfter\n     *\n     * @see #setFillEnabled(boolean)\n     ",
    "links" : [ "android.view.animation.AnimationSet" ]
  }, {
    "name" : "public void setZAdjustment(int zAdjustment)",
    "returnType" : "void",
    "comment" : "\n     * Set the Z ordering mode to use while running the animation.\n     *\n     * @param zAdjustment The desired mode, one of {@link #ZORDER_NORMAL},\n     * {@link #ZORDER_TOP}, or {@link #ZORDER_BOTTOM}.\n     * @attr ref android.R.styleable#Animation_zAdjustment\n     ",
    "links" : [ "#ZORDER_TOP", "#ZORDER_BOTTOM", "#ZORDER_NORMAL" ]
  }, {
    "name" : "public void setBackgroundColor(@ColorInt int bg)",
    "returnType" : "void",
    "comment" : "\n     * Set background behind animation.\n     *\n     * @param bg The background color.  If 0, no background.  Currently must\n     * be black, with any desired alpha level.\n     *\n     * @deprecated None of window animations are running with background color.\n     * @see #setBackdropColor(int) for an alternative.\n     ",
    "links" : [ ]
  }, {
    "name" : "protected float getScaleFactor()",
    "returnType" : "float",
    "comment" : "\n     * The scale factor is set by the call to <code>getTransformation</code>. Overrides of\n     * {@link #getTransformation(long, Transformation, float)} will get this value\n     * directly. Overrides of {@link #applyTransformation(float, Transformation)} can\n     * call this method to get the value.\n     *\n     * @return float The scale factor that should be applied to pre-scaled values in\n     * an Animation such as the pivot points in {@link ScaleAnimation} and {@link RotateAnimation}.\n     ",
    "links" : [ "#getTransformation(long", "android.view.animation.ScaleAnimation", "#applyTransformation(float", "android.view.animation.RotateAnimation" ]
  }, {
    "name" : "public void setDetachWallpaper(boolean detachWallpaper)",
    "returnType" : "void",
    "comment" : "\n     * If detachWallpaper is true, and this is a window animation of a window\n     * that has a wallpaper background, then the window will be detached from\n     * the wallpaper while it runs.  That is, the animation will only be applied\n     * to the window, and the wallpaper behind it will remain static.\n     *\n     * @param detachWallpaper true if the wallpaper should be detached from the animation\n     * @attr ref android.R.styleable#Animation_detachWallpaper\n     *\n     * @deprecated All window animations are running with detached wallpaper.\n     ",
    "links" : [ ]
  }, {
    "name" : "public void setShowWallpaper(boolean showWallpaper)",
    "returnType" : "void",
    "comment" : "\n     * If this animation is run as a window animation, this will make the wallpaper visible behind\n     * the animation.\n     *\n     * @param showWallpaper Whether the wallpaper should be shown during the animation.\n     * @attr ref android.R.styleable#Animation_detachWallpaper\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public void setHasRoundedCorners(boolean hasRoundedCorners)",
    "returnType" : "void",
    "comment" : "\n     * If this is a window animation, the window will have rounded corners matching the display\n     * corner radius.\n     *\n     * @param hasRoundedCorners Whether the window should have rounded corners or not.\n     * @attr ref android.R.styleable#Animation_hasRoundedCorners\n     * @see com.android.internal.policy.ScreenDecorationsUtils#getWindowCornerRadius(Resources)\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public void setShowBackdrop(boolean showBackdrop)",
    "returnType" : "void",
    "comment" : "\n     * If showBackdrop is {@code true} and this animation is applied on a window, then the windows\n     * in the animation will animate with the background associated with this window behind them.\n     *\n     * If no backdrop color is explicitly set, the backdrop's color comes from the\n     * {@link android.R.styleable#Theme_colorBackground} that is applied to this window through its\n     * theme.\n     *\n     * If multiple animating windows have showBackdrop set to {@code true} during an animation,\n     * the top most window with showBackdrop set to {@code true} and a valid background color\n     * takes precedence.\n     *\n     * @param showBackdrop Whether to show a background behind the windows during the animation.\n     * @attr ref android.R.styleable#Animation_showBackdrop\n     ",
    "links" : [ "android.R.styleable#Theme_colorBackground" ]
  }, {
    "name" : "public void setBackdropColor(@ColorInt int backdropColor)",
    "returnType" : "void",
    "comment" : "\n     * Set the color to use for the backdrop shown behind the animating windows.\n     *\n     * Will only show the backdrop if showBackdrop was set to true.\n     * See {@link #setShowBackdrop(boolean)}.\n     *\n     * @param backdropColor The backdrop color. If 0, the backdrop color will not apply.\n     * @attr ref android.R.styleable#Animation_backdropColor\n     ",
    "links" : [ "#setShowBackdrop(boolean)" ]
  }, {
    "name" : "public Interpolator getInterpolator()",
    "returnType" : "Interpolator",
    "comment" : "\n     * Gets the acceleration curve type for this animation.\n     *\n     * @return the {@link Interpolator} associated to this animation\n     * @attr ref android.R.styleable#Animation_interpolator\n     ",
    "links" : [ "android.view.animation.Interpolator" ]
  }, {
    "name" : "public long getStartTime()",
    "returnType" : "long",
    "comment" : "\n     * When this animation should start. If the animation has not startet yet,\n     * this method might return {@link #START_ON_FIRST_FRAME}.\n     *\n     * @return the time in milliseconds when the animation should start or\n     *         {@link #START_ON_FIRST_FRAME}\n     ",
    "links" : [ "#START_ON_FIRST_FRAME" ]
  }, {
    "name" : "public long getDuration()",
    "returnType" : "long",
    "comment" : "\n     * How long this animation should last\n     *\n     * @return the duration in milliseconds of the animation\n     * @attr ref android.R.styleable#Animation_duration\n     ",
    "links" : [ ]
  }, {
    "name" : "public long getStartOffset()",
    "returnType" : "long",
    "comment" : "\n     * When this animation should start, relative to StartTime\n     *\n     * @return the start offset in milliseconds\n     * @attr ref android.R.styleable#Animation_startOffset\n     ",
    "links" : [ ]
  }, {
    "name" : "public int getRepeatMode()",
    "returnType" : "int",
    "comment" : "\n     * Defines what this animation should do when it reaches the end.\n     *\n     * @return either one of {@link #REVERSE} or {@link #RESTART}\n     * @attr ref android.R.styleable#Animation_repeatMode\n     ",
    "links" : [ "#RESTART", "#REVERSE" ]
  }, {
    "name" : "public int getRepeatCount()",
    "returnType" : "int",
    "comment" : "\n     * Defines how many times the animation should repeat. The default value\n     * is 0.\n     *\n     * @return the number of times the animation should repeat, or {@link #INFINITE}\n     * @attr ref android.R.styleable#Animation_repeatCount\n     ",
    "links" : [ "#INFINITE" ]
  }, {
    "name" : "public boolean getFillBefore()",
    "returnType" : "boolean",
    "comment" : "\n     * If fillBefore is true, this animation will apply its transformation\n     * before the start time of the animation. If fillBefore is false and\n     * {@link #isFillEnabled() fillEnabled} is true, the transformation will not be applied until\n     * the start time of the animation.\n     *\n     * @return true if the animation applies its transformation before it starts\n     * @attr ref android.R.styleable#Animation_fillBefore\n     ",
    "links" : [ "#isFillEnabled()" ]
  }, {
    "name" : "public boolean getFillAfter()",
    "returnType" : "boolean",
    "comment" : "\n     * If fillAfter is true, this animation will apply its transformation\n     * after the end time of the animation.\n     *\n     * @return true if the animation applies its transformation after it ends\n     * @attr ref android.R.styleable#Animation_fillAfter\n     ",
    "links" : [ ]
  }, {
    "name" : "public int getZAdjustment()",
    "returnType" : "int",
    "comment" : "\n     * Returns the Z ordering mode to use while running the animation as\n     * previously set by {@link #setZAdjustment}.\n     *\n     * @return Returns one of {@link #ZORDER_NORMAL},\n     * {@link #ZORDER_TOP}, or {@link #ZORDER_BOTTOM}.\n     * @attr ref android.R.styleable#Animation_zAdjustment\n     ",
    "links" : [ "#ZORDER_TOP", "#ZORDER_BOTTOM", "#setZAdjustment", "#ZORDER_NORMAL" ]
  }, {
    "name" : "public int getBackgroundColor()",
    "returnType" : "int",
    "comment" : "\n     * Returns the background color behind the animation.\n     *\n     * @deprecated None of window animations are running with background color.\n     * @see #getBackdropColor() for an alternative.\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean getDetachWallpaper()",
    "returnType" : "boolean",
    "comment" : "\n     * Return value of {@link #setDetachWallpaper(boolean)}.\n     * @attr ref android.R.styleable#Animation_detachWallpaper\n     *\n     * @deprecated All window animations are running with detached wallpaper.\n     ",
    "links" : [ "#setDetachWallpaper(boolean)" ]
  }, {
    "name" : "public boolean getShowWallpaper()",
    "returnType" : "boolean",
    "comment" : "\n     * @return If run as a window animation, returns whether the wallpaper will be shown behind\n     *         during the animation.\n     * @attr ref android.R.styleable#Animation_showWallpaper\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean hasRoundedCorners()",
    "returnType" : "boolean",
    "comment" : "\n     * @return if a window animation should have rounded corners or not.\n     *\n     * @attr ref android.R.styleable#Animation_hasRoundedCorners\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean hasExtension()",
    "returnType" : "boolean",
    "comment" : "\n     * @return if a window animation has outsets applied to it.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean getShowBackdrop()",
    "returnType" : "boolean",
    "comment" : "\n     * If showBackdrop is {@code true} and this animation is applied on a window, then the windows\n     * in the animation will animate with the background associated with this window behind them.\n     *\n     * If no backdrop color is explicitly set, the backdrop's color comes from the\n     * {@link android.R.styleable#Theme_colorBackground} that is applied to this window\n     * through its theme.\n     *\n     * If multiple animating windows have showBackdrop set to {@code true} during an animation,\n     * the top most window with showBackdrop set to {@code true} and a valid background color\n     * takes precedence.\n     *\n     * @return if a backdrop should be shown behind the animating windows.\n     * @attr ref android.R.styleable#Animation_showBackdrop\n     ",
    "links" : [ "android.R.styleable#Theme_colorBackground" ]
  }, {
    "name" : "public int getBackdropColor()",
    "returnType" : "int",
    "comment" : "\n     * Returns the background color to show behind the animating windows.\n     *\n     * Will only show the background if showBackdrop was set to true.\n     * See {@link #setShowBackdrop(boolean)}.\n     *\n     * @return The backdrop color. If 0, the backdrop color will not apply.\n     * @attr ref android.R.styleable#Animation_backdropColor\n     ",
    "links" : [ "#setShowBackdrop(boolean)" ]
  }, {
    "name" : "public boolean willChangeTransformationMatrix()",
    "returnType" : "boolean",
    "comment" : "\n     * <p>Indicates whether or not this animation will affect the transformation\n     * matrix. For instance, a fade animation will not affect the matrix whereas\n     * a scale animation will.</p>\n     *\n     * @return true if this animation will change the transformation matrix\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean willChangeBounds()",
    "returnType" : "boolean",
    "comment" : "\n     * <p>Indicates whether or not this animation will affect the bounds of the\n     * animated view. For instance, a fade animation will not affect the bounds\n     * whereas a 200% scale animation will.</p>\n     *\n     * @return true if this animation will change the view's bounds\n     ",
    "links" : [ ]
  }, {
    "name" : "private boolean hasAnimationListener()",
    "returnType" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public void setAnimationListener(AnimationListener listener)",
    "returnType" : "void",
    "comment" : "\n     * <p>Binds an animation listener to this animation. The animation listener\n     * is notified of animation events such as the end of the animation or the\n     * repetition of the animation.</p>\n     *\n     * @param listener the animation listener to be notified\n     ",
    "links" : [ ]
  }, {
    "name" : "protected void ensureInterpolator()",
    "returnType" : "void",
    "comment" : "\n     * Gurantees that this animation has an interpolator. Will use\n     * a AccelerateDecelerateInterpolator is nothing else was specified.\n     ",
    "links" : [ ]
  }, {
    "name" : "public long computeDurationHint()",
    "returnType" : "long",
    "comment" : "\n     * Compute a hint at how long the entire animation may last, in milliseconds.\n     * Animations can be written to cause themselves to run for a different\n     * duration than what is computed here, but generally this should be\n     * accurate.\n     ",
    "links" : [ ]
  }, {
    "name" : "public void getTransformationAt(float normalizedTime, Transformation outTransformation)",
    "returnType" : "void",
    "comment" : "\n     * Gets the transformation to apply a specific point in time. Implementations of this method\n     * should always be kept in sync with getTransformation.\n     *\n     * @param normalizedTime time between 0 and 1 where 0 is the start of the animation and 1 the\n     *                       end.\n     * @param outTransformation A transformation object that is provided by the\n     *        caller and will be filled in by the animation.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean getTransformation(long currentTime, Transformation outTransformation)",
    "returnType" : "boolean",
    "comment" : "\n     * Gets the transformation to apply at a specified point in time. Implementations of this\n     * method should always replace the specified Transformation or document they are doing\n     * otherwise.\n     *\n     * @param currentTime Where we are in the animation. This is wall clock time.\n     * @param outTransformation A transformation object that is provided by the\n     *        caller and will be filled in by the animation.\n     * @return True if the animation is still running\n     ",
    "links" : [ ]
  }, {
    "name" : "private boolean isCanceled()",
    "returnType" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private void fireAnimationStart()",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private void fireAnimationRepeat()",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private void fireAnimationEnd()",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : " void dispatchAnimationStart()",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : " void dispatchAnimationRepeat()",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : " void dispatchAnimationEnd()",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public boolean getTransformation(long currentTime, Transformation outTransformation, float scale)",
    "returnType" : "boolean",
    "comment" : "\n     * Gets the transformation to apply at a specified point in time. Implementations of this\n     * method should always replace the specified Transformation or document they are doing\n     * otherwise.\n     *\n     * @param currentTime Where we are in the animation. This is wall clock time.\n     * @param outTransformation A transformation object that is provided by the\n     *        caller and will be filled in by the animation.\n     * @param scale Scaling factor to apply to any inputs to the transform operation, such\n     *        pivot points being rotated or scaled around.\n     * @return True if the animation is still running\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean hasStarted()",
    "returnType" : "boolean",
    "comment" : "\n     * <p>Indicates whether this animation has started or not.</p>\n     *\n     * @return true if the animation has started, false otherwise\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean hasEnded()",
    "returnType" : "boolean",
    "comment" : "\n     * <p>Indicates whether this animation has ended or not.</p>\n     *\n     * @return true if the animation has ended, false otherwise\n     ",
    "links" : [ ]
  }, {
    "name" : "protected void applyTransformation(float interpolatedTime, Transformation t)",
    "returnType" : "void",
    "comment" : "\n     * Helper for getTransformation. Subclasses should implement this to apply\n     * their transforms given an interpolation value.  Implementations of this\n     * method should always replace the specified Transformation or document\n     * they are doing otherwise.\n     *\n     * @param interpolatedTime The value of the normalized time (0.0 to 1.0)\n     *        after it has been run through the interpolation function.\n     * @param t The Transformation object to fill in with the current\n     *        transforms.\n     ",
    "links" : [ ]
  }, {
    "name" : "protected float resolveSize(int type, float value, int size, int parentSize)",
    "returnType" : "float",
    "comment" : "\n     * Convert the information in the description of a size to an actual\n     * dimension\n     *\n     * @param type One of Animation.ABSOLUTE, Animation.RELATIVE_TO_SELF, or\n     *             Animation.RELATIVE_TO_PARENT.\n     * @param value The dimension associated with the type parameter\n     * @param size The size of the object being animated\n     * @param parentSize The size of the parent of the object being animated\n     * @return The dimension to use for the animation\n     ",
    "links" : [ ]
  }, {
    "name" : "public void getInvalidateRegion(int left, int top, int right, int bottom, RectF invalidate, Transformation transformation)",
    "returnType" : "void",
    "comment" : "\n     * @param left\n     * @param top\n     * @param right\n     * @param bottom\n     * @param invalidate\n     * @param transformation\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public void initializeInvalidateRegion(int left, int top, int right, int bottom)",
    "returnType" : "void",
    "comment" : "\n     * @param left\n     * @param top\n     * @param right\n     * @param bottom\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "protected void finalize() throws Throwable",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public boolean hasAlpha()",
    "returnType" : "boolean",
    "comment" : "\n     * Return true if this animation changes the view's alpha property.\n     *\n     * @hide\n     ",
    "links" : [ ]
  } ],
  "methodNames" : [ "protected Animation clone() throws CloneNotSupportedException", "public void reset()", "public void cancel()", "public void detach()", "public boolean isInitialized()", "public void initialize(int width, int height, int parentWidth, int parentHeight)", "public void setListenerHandler(Handler handler)", "public void setInterpolator(Context context, @AnimRes @InterpolatorRes int resID)", "public void setInterpolator(Interpolator i)", "public void setStartOffset(long startOffset)", "public void setDuration(long durationMillis)", "public void restrictDuration(long durationMillis)", "public void scaleCurrentDuration(float scale)", "public void setStartTime(long startTimeMillis)", "public void start()", "public void startNow()", "public void setRepeatMode(int repeatMode)", "public void setRepeatCount(int repeatCount)", "public boolean isFillEnabled()", "public void setFillEnabled(boolean fillEnabled)", "public void setFillBefore(boolean fillBefore)", "public void setFillAfter(boolean fillAfter)", "public void setZAdjustment(int zAdjustment)", "public void setBackgroundColor(@ColorInt int bg)", "protected float getScaleFactor()", "public void setDetachWallpaper(boolean detachWallpaper)", "public void setShowWallpaper(boolean showWallpaper)", "public void setHasRoundedCorners(boolean hasRoundedCorners)", "public void setShowBackdrop(boolean showBackdrop)", "public void setBackdropColor(@ColorInt int backdropColor)", "public Interpolator getInterpolator()", "public long getStartTime()", "public long getDuration()", "public long getStartOffset()", "public int getRepeatMode()", "public int getRepeatCount()", "public boolean getFillBefore()", "public boolean getFillAfter()", "public int getZAdjustment()", "public int getBackgroundColor()", "public boolean getDetachWallpaper()", "public boolean getShowWallpaper()", "public boolean hasRoundedCorners()", "public boolean hasExtension()", "public boolean getShowBackdrop()", "public int getBackdropColor()", "public boolean willChangeTransformationMatrix()", "public boolean willChangeBounds()", "private boolean hasAnimationListener()", "public void setAnimationListener(AnimationListener listener)", "protected void ensureInterpolator()", "public long computeDurationHint()", "public void getTransformationAt(float normalizedTime, Transformation outTransformation)", "public boolean getTransformation(long currentTime, Transformation outTransformation)", "private boolean isCanceled()", "private void fireAnimationStart()", "private void fireAnimationRepeat()", "private void fireAnimationEnd()", " void dispatchAnimationStart()", " void dispatchAnimationRepeat()", " void dispatchAnimationEnd()", "public boolean getTransformation(long currentTime, Transformation outTransformation, float scale)", "public boolean hasStarted()", "public boolean hasEnded()", "protected void applyTransformation(float interpolatedTime, Transformation t)", "protected float resolveSize(int type, float value, int size, int parentSize)", "public void getInvalidateRegion(int left, int top, int right, int bottom, RectF invalidate, Transformation transformation)", "public void initializeInvalidateRegion(int left, int top, int right, int bottom)", "protected void finalize() throws Throwable", "public boolean hasAlpha()" ],
  "variableNames" : [ "INFINITE", "RESTART", "REVERSE", "START_ON_FIRST_FRAME", "ABSOLUTE", "RELATIVE_TO_SELF", "RELATIVE_TO_PARENT", "ZORDER_NORMAL", "ZORDER_TOP", "ZORDER_BOTTOM", "mEnded", "mStarted", "mCycleFlip", "mInitialized", "mFillBefore", "mFillAfter", "mFillEnabled", "mStartTime", "mStartOffset", "mDuration", "mRepeatCount", "mRepeated", "mRepeatMode", "mInterpolator", "mListener", "mZAdjustment", "mBackdropColor", "mScaleFactor", "mShowWallpaper", "mHasRoundedCorners", "mShowBackdrop", "mMore", "mOneMoreTime", "mPreviousRegion", "mRegion", "mTransformation", "mPreviousTransformation", "guard", "mListenerHandler", "mOnStart", "mOnRepeat", "mOnEnd" ]
}