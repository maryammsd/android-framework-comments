{
  "filePath" : "/home/maryam/clearblue/files/android-source-35/android/service/autofill/AutofillService.java",
  "packageName" : "android.service.autofill",
  "className" : "AutofillService",
  "comment" : "\n * An {@code AutofillService} is a service used to automatically fill the contents of the screen\n * on behalf of a given user - for more information about autofill, read\n * <a href=\"{@docRoot}preview/features/autofill.html\">Autofill Framework</a>.\n *\n * <p>An {@code AutofillService} is only bound to the Android System for autofill purposes if:\n * <ol>\n *   <li>It requires the {@code android.permission.BIND_AUTOFILL_SERVICE} permission in its\n *       manifest.\n *   <li>The user explicitly enables it using Android Settings (the\n *       {@link Settings#ACTION_REQUEST_SET_AUTOFILL_SERVICE} intent can be used to launch such\n *       Settings screen).\n * </ol>\n *\n * <a name=\"BasicUsage\"></a>\n * <h3>Basic usage</h3>\n *\n * <p>The basic autofill process is defined by the workflow below:\n * <ol>\n *   <li>User focus an editable {@link View}.\n *   <li>View calls {@link AutofillManager#notifyViewEntered(android.view.View)}.\n *   <li>A {@link ViewStructure} representing all views in the screen is created.\n *   <li>The Android System binds to the service and calls {@link #onConnected()}.\n *   <li>The service receives the view structure through the\n *       {@link #onFillRequest(FillRequest, CancellationSignal, FillCallback)}.\n *   <li>The service replies through {@link FillCallback#onSuccess(FillResponse)}.\n *   <li>The Android System calls {@link #onDisconnected()} and unbinds from the\n *       {@code AutofillService}.\n *   <li>The Android System displays an autofill UI with the options sent by the service.\n *   <li>The user picks an option.\n *   <li>The proper views are autofilled.\n * </ol>\n *\n * <p>This workflow was designed to minimize the time the Android System is bound to the service;\n * for each call, it: binds to service, waits for the reply, and unbinds right away. Furthermore,\n * those calls are considered stateless: if the service needs to keep state between calls, it must\n * do its own state management (keeping in mind that the service's process might be killed by the\n * Android System when unbound; for example, if the device is running low in memory).\n *\n * <p>Typically, the\n * {@link #onFillRequest(FillRequest, CancellationSignal, FillCallback)} will:\n * <ol>\n *   <li>Parse the view structure looking for autofillable views (for example, using\n *       {@link android.app.assist.AssistStructure.ViewNode#getAutofillHints()}.\n *   <li>Match the autofillable views with the user's data.\n *   <li>Create a {@link Dataset} for each set of user's data that match those fields.\n *   <li>Fill the dataset(s) with the proper {@link AutofillId}s and {@link AutofillValue}s.\n *   <li>Add the dataset(s) to the {@link FillResponse} passed to\n *       {@link FillCallback#onSuccess(FillResponse)}.\n * </ol>\n *\n * <p>For example, for a login screen with username and password views where the user only has one\n * account in the service, the response could be:\n *\n * <pre class=\"prettyprint\">\n * new FillResponse.Builder()\n *     .addDataset(new Dataset.Builder()\n *         .setValue(id1, AutofillValue.forText(\"homer\"), createPresentation(\"homer\"))\n *         .setValue(id2, AutofillValue.forText(\"D'OH!\"), createPresentation(\"password for homer\"))\n *         .build())\n *     .build();\n * </pre>\n *\n * <p>But if the user had 2 accounts instead, the response could be:\n *\n * <pre class=\"prettyprint\">\n * new FillResponse.Builder()\n *     .addDataset(new Dataset.Builder()\n *         .setValue(id1, AutofillValue.forText(\"homer\"), createPresentation(\"homer\"))\n *         .setValue(id2, AutofillValue.forText(\"D'OH!\"), createPresentation(\"password for homer\"))\n *         .build())\n *     .addDataset(new Dataset.Builder()\n *         .setValue(id1, AutofillValue.forText(\"flanders\"), createPresentation(\"flanders\"))\n *         .setValue(id2, AutofillValue.forText(\"OkelyDokelyDo\"), createPresentation(\"password for flanders\"))\n *         .build())\n *     .build();\n * </pre>\n *\n * <p>If the service does not find any autofillable view in the view structure, it should pass\n * {@code null} to {@link FillCallback#onSuccess(FillResponse)}; if the service encountered an error\n * processing the request, it should call {@link FillCallback#onFailure(CharSequence)}. For\n * performance reasons, it's paramount that the service calls either\n * {@link FillCallback#onSuccess(FillResponse)} or {@link FillCallback#onFailure(CharSequence)} for\n * each {@link #onFillRequest(FillRequest, CancellationSignal, FillCallback)} received - if it\n * doesn't, the request will eventually time out and be discarded by the Android System.\n *\n * <a name=\"SavingUserData\"></a>\n * <h3>Saving user data</h3>\n *\n * <p>If the service is also interested on saving the data filled by the user, it must set a\n * {@link SaveInfo} object in the {@link FillResponse}. See {@link SaveInfo} for more details and\n * examples.\n *\n * <a name=\"UserAuthentication\"></a>\n * <h3>User authentication</h3>\n *\n * <p>The service can provide an extra degree of security by requiring the user to authenticate\n * before an app can be autofilled. The authentication is typically required in 2 scenarios:\n * <ul>\n *   <li>To unlock the user data (for example, using a main password or fingerprint\n *       authentication) - see\n * {@link FillResponse.Builder#setAuthentication(AutofillId[], android.content.IntentSender, android.widget.RemoteViews)}.\n *   <li>To unlock a specific dataset (for example, by providing a CVC for a credit card) - see\n *       {@link Dataset.Builder#setAuthentication(android.content.IntentSender)}.\n * </ul>\n *\n * <p>When using authentication, it is recommended to encrypt only the sensitive data and leave\n * labels unencrypted, so they can be used on presentation views. For example, if the user has a\n * home and a work address, the {@code Home} and {@code Work} labels should be stored unencrypted\n * (since they don't have any sensitive data) while the address data per se could be stored in an\n * encrypted storage. Then when the user chooses the {@code Home} dataset, the platform starts\n * the authentication flow, and the service can decrypt the sensitive data.\n *\n * <p>The authentication mechanism can also be used in scenarios where the service needs multiple\n * steps to determine the datasets that can fill a screen. For example, when autofilling a financial\n * app where the user has accounts for multiple banks, the workflow could be:\n *\n * <ol>\n *   <li>The first {@link FillResponse} contains datasets with the credentials for the financial\n *       app, plus a \"fake\" dataset whose presentation says \"Tap here for banking apps credentials\".\n *   <li>When the user selects the fake dataset, the service displays a dialog with available\n *       banking apps.\n *   <li>When the user select a banking app, the service replies with a new {@link FillResponse}\n *       containing the datasets for that bank.\n * </ol>\n *\n * <p>Another example of multiple-steps dataset selection is when the service stores the user\n * credentials in \"vaults\": the first response would contain fake datasets with the vault names,\n * and the subsequent response would contain the app credentials stored in that vault.\n *\n * <a name=\"DataPartioning\"></a>\n * <h3>Data partitioning</h3>\n *\n * <p>The autofillable views in a screen should be grouped in logical groups called \"partitions\".\n * Typical partitions are:\n * <ul>\n *   <li>Credentials (username/email address, password).\n *   <li>Address (street, city, state, zip code, etc).\n *   <li>Payment info (credit card number, expiration date, and verification code).\n * </ul>\n * <p>For security reasons, when a screen has more than one partition, it's paramount that the\n * contents of a dataset do not spawn multiple partitions, specially when one of the partitions\n * contains data that is not specific to the application being autofilled. For example, a dataset\n * should not contain fields for username, password, and credit card information. The reason for\n * this rule is that a malicious app could draft a view structure where the credit card fields\n * are not visible, so when the user selects a dataset from the username UI, the credit card info is\n * released to the application without the user knowledge. Similarly, it's recommended to always\n * protect a dataset that contains sensitive information by requiring dataset authentication\n * (see {@link Dataset.Builder#setAuthentication(android.content.IntentSender)}), and to include\n * info about the \"primary\" field of the partition in the custom presentation for \"secondary\"\n * fields&mdash;that would prevent a malicious app from getting the \"primary\" fields without the\n * user realizing they're being released (for example, a malicious app could have fields for a\n * credit card number, verification code, and expiration date crafted in a way that just the latter\n * is visible; by explicitly indicating the expiration date is related to a given credit card\n * number, the service would be providing a visual clue for the users to check what would be\n * released upon selecting that field).\n *\n * <p>When the service detects that a screen has multiple partitions, it should return a\n * {@link FillResponse} with just the datasets for the partition that originated the request (i.e.,\n * the partition that has the {@link android.app.assist.AssistStructure.ViewNode} whose\n * {@link android.app.assist.AssistStructure.ViewNode#isFocused()} returns {@code true}); then if\n * the user selects a field from a different partition, the Android System will make another\n * {@link #onFillRequest(FillRequest, CancellationSignal, FillCallback)} call for that partition,\n * and so on.\n *\n * <p>Notice that when the user autofill a partition with the data provided by the service and the\n * user did not change these fields, the autofilled value is sent back to the service in the\n * subsequent calls (and can be obtained by calling\n * {@link android.app.assist.AssistStructure.ViewNode#getAutofillValue()}). This is useful in the\n * cases where the service must create datasets for a partition based on the choice made in a\n * previous partition. For example, the 1st response for a screen that have credentials and address\n * partitions could be:\n *\n * <pre class=\"prettyprint\">\n * new FillResponse.Builder()\n *     .addDataset(new Dataset.Builder() // partition 1 (credentials)\n *         .setValue(id1, AutofillValue.forText(\"homer\"), createPresentation(\"homer\"))\n *         .setValue(id2, AutofillValue.forText(\"D'OH!\"), createPresentation(\"password for homer\"))\n *         .build())\n *     .addDataset(new Dataset.Builder() // partition 1 (credentials)\n *         .setValue(id1, AutofillValue.forText(\"flanders\"), createPresentation(\"flanders\"))\n *         .setValue(id2, AutofillValue.forText(\"OkelyDokelyDo\"), createPresentation(\"password for flanders\"))\n *         .build())\n *     .setSaveInfo(new SaveInfo.Builder(SaveInfo.SAVE_DATA_TYPE_PASSWORD,\n *         new AutofillId[] { id1, id2 })\n *             .build())\n *     .build();\n * </pre>\n *\n * <p>Then if the user selected {@code flanders}, the service would get a new\n * {@link #onFillRequest(FillRequest, CancellationSignal, FillCallback)} call, with the values of\n * the fields {@code id1} and {@code id2} prepopulated, so the service could then fetch the address\n * for the Flanders account and return the following {@link FillResponse} for the address partition:\n *\n * <pre class=\"prettyprint\">\n * new FillResponse.Builder()\n *     .addDataset(new Dataset.Builder() // partition 2 (address)\n *         .setValue(id3, AutofillValue.forText(\"744 Evergreen Terrace\"), createPresentation(\"744 Evergreen Terrace\")) // street\n *         .setValue(id4, AutofillValue.forText(\"Springfield\"), createPresentation(\"Springfield\")) // city\n *         .build())\n *     .setSaveInfo(new SaveInfo.Builder(SaveInfo.SAVE_DATA_TYPE_PASSWORD | SaveInfo.SAVE_DATA_TYPE_ADDRESS,\n *         new AutofillId[] { id1, id2 }) // username and password\n *              .setOptionalIds(new AutofillId[] { id3, id4 }) // state and zipcode\n *             .build())\n *     .build();\n * </pre>\n *\n * <p>When the service returns multiple {@link FillResponse}, the last one overrides the previous;\n * that's why the {@link SaveInfo} in the 2nd request above has the info for both partitions.\n *\n * <a name=\"PackageVerification\"></a>\n * <h3>Package verification</h3>\n *\n * <p>When autofilling app-specific data (like username and password), the service must verify\n * the authenticity of the request by obtaining all signing certificates of the app being\n * autofilled, and only fulfilling the request when they match the values that were\n * obtained when the data was first saved &mdash; such verification is necessary to avoid phishing\n * attempts by apps that were sideloaded in the device with the same package name of another app.\n * Here's an example on how to achieve that by hashing the signing certificates:\n *\n * <pre class=\"prettyprint\">\n * private String getCertificatesHash(String packageName) throws Exception {\n *   PackageManager pm = mContext.getPackageManager();\n *   PackageInfo info = pm.getPackageInfo(packageName, PackageManager.GET_SIGNATURES);\n *   ArrayList<String> hashes = new ArrayList<>(info.signatures.length);\n *   for (Signature sig : info.signatures) {\n *     byte[] cert = sig.toByteArray();\n *     MessageDigest md = MessageDigest.getInstance(\"SHA-256\");\n *     md.update(cert);\n *     hashes.add(toHexString(md.digest()));\n *   }\n *   Collections.sort(hashes);\n *   StringBuilder hash = new StringBuilder();\n *   for (int i = 0; i < hashes.size(); i++) {\n *     hash.append(hashes.get(i));\n *   }\n *   return hash.toString();\n * }\n * </pre>\n *\n * <p>If the service did not store the signing certificates data the first time the data was saved\n * &mdash; for example, because the data was created by a previous version of the app that did not\n * use the Autofill Framework &mdash; the service should warn the user that the authenticity of the\n * app cannot be confirmed (see an example on how to show such warning in the\n * <a href=\"#WebSecurityDisclaimer\">Web security</a> section below), and if the user agrees,\n * then the service could save the data from the signing ceriticates for future use.\n *\n * <a name=\"IgnoringViews\"></a>\n * <h3>Ignoring views</h3>\n *\n * <p>If the service find views that cannot be autofilled (for example, a text field representing\n * the response to a Captcha challenge), it should mark those views as ignored by\n * calling {@link FillResponse.Builder#setIgnoredIds(AutofillId...)} so the system does not trigger\n * a new {@link #onFillRequest(FillRequest, CancellationSignal, FillCallback)} when these views are\n * focused.\n *\n * <a name=\"WebSecurity\"></a>\n * <h3>Web security</h3>\n *\n * <p>When handling autofill requests that represent web pages (typically\n * view structures whose root's {@link android.app.assist.AssistStructure.ViewNode#getClassName()}\n * is a {@link android.webkit.WebView}), the service should take the following steps to verify if\n * the structure can be autofilled with the data associated with the app requesting it:\n *\n * <ol>\n *   <li>Use the {@link android.app.assist.AssistStructure.ViewNode#getWebDomain()} to get the\n *       source of the document.\n *   <li>Get the canonical domain using the\n *       <a href=\"https://publicsuffix.org/\">Public Suffix List</a> (see example below).\n *   <li>Use <a href=\"https://developers.google.com/digital-asset-links/\">Digital Asset Links</a>\n *       to obtain the package name and certificate fingerprint of the package corresponding to\n *       the canonical domain.\n *   <li>Make sure the certificate fingerprint matches the value returned by Package Manager\n *       (see \"Package verification\" section above).\n * </ol>\n *\n * <p>Here's an example on how to get the canonical domain using\n * <a href=\"https://github.com/google/guava\">Guava</a>:\n *\n * <pre class=\"prettyprint\">\n * private static String getCanonicalDomain(String domain) {\n *   InternetDomainName idn = InternetDomainName.from(domain);\n *   while (idn != null && !idn.isTopPrivateDomain()) {\n *     idn = idn.parent();\n *   }\n *   return idn == null ? null : idn.toString();\n * }\n * </pre>\n *\n * <a name=\"WebSecurityDisclaimer\"></a>\n * <p>If the association between the web domain and app package cannot be verified through the steps\n * above, but the service thinks that it is appropriate to fill persisted credentials that are\n * stored for the web domain, the service should warn the user about the potential data\n * leakage first, and ask for the user to confirm. For example, the service could:\n *\n * <ol>\n *   <li>Create a dataset that requires\n *       {@link Dataset.Builder#setAuthentication(android.content.IntentSender) authentication} to\n *       unlock.\n *   <li>Include the web domain in the custom presentation for the\n *       {@link Dataset.Builder#setValue(AutofillId, AutofillValue, android.widget.RemoteViews)\n *       dataset value}.\n *   <li>When the user selects that dataset, show a disclaimer dialog explaining that the app is\n *       requesting credentials for a web domain, but the service could not verify if the app owns\n *       that domain. If the user agrees, then the service can unlock the dataset.\n *   <li>Similarly, when adding a {@link SaveInfo} object for the request, the service should\n *       include the above disclaimer in the {@link SaveInfo.Builder#setDescription(CharSequence)}.\n * </ol>\n *\n * <p>This same procedure could also be used when the autofillable data is contained inside an\n * {@code IFRAME}, in which case the WebView generates a new autofill context when a node inside\n * the {@code IFRAME} is focused, with the root node containing the {@code IFRAME}'s {@code src}\n * attribute on {@link android.app.assist.AssistStructure.ViewNode#getWebDomain()}. A typical and\n * legitimate use case for this scenario is a financial app that allows the user\n * to login on different bank accounts. For example, a financial app {@code my_financial_app} could\n * use a WebView that loads contents from {@code banklogin.my_financial_app.com}, which contains an\n * {@code IFRAME} node whose {@code src} attribute is {@code login.some_bank.com}. When fulfilling\n * that request, the service could add an\n * {@link Dataset.Builder#setAuthentication(android.content.IntentSender) authenticated dataset}\n * whose presentation displays \"Username for some_bank.com\" and\n * \"Password for some_bank.com\". Then when the user taps one of these options, the service\n * shows the disclaimer dialog explaining that selecting that option would release the\n * {@code login.some_bank.com} credentials to the {@code my_financial_app}; if the user agrees,\n * then the service returns an unlocked dataset with the {@code some_bank.com} credentials.\n *\n * <p><b>Note:</b> The autofill service could also add well-known browser apps into an allowlist and\n * skip the verifications above, as long as the service can verify the authenticity of the browser\n * app by checking its signing certificate.\n *\n * <a name=\"MultipleStepsSave\"></a>\n * <h3>Saving when data is split in multiple screens</h3>\n *\n * Apps often split the user data in multiple screens in the same activity, specially in\n * activities used to create a new user account. For example, the first screen asks for a username,\n * and if the username is available, it moves to a second screen, which asks for a password.\n *\n * <p>It's tricky to handle save for autofill in these situations, because the autofill service must\n * wait until the user enters both fields before the autofill save UI can be shown. But it can be\n * done by following the steps below:\n *\n * <ol>\n * <li>In the first\n * {@link #onFillRequest(FillRequest, CancellationSignal, FillCallback) fill request}, the service\n * adds a {@link FillResponse.Builder#setClientState(android.os.Bundle) client state bundle} in\n * the response, containing the autofill ids of the partial fields present in the screen.\n * <li>In the second\n * {@link #onFillRequest(FillRequest, CancellationSignal, FillCallback) fill request}, the service\n * retrieves the {@link FillRequest#getClientState() client state bundle}, gets the autofill ids\n * set in the previous request from the client state, and adds these ids and the\n * {@link SaveInfo#FLAG_SAVE_ON_ALL_VIEWS_INVISIBLE} to the {@link SaveInfo} used in the second\n * response.\n * <li>In the {@link #onSaveRequest(SaveRequest, SaveCallback) save request}, the service uses the\n * proper {@link FillContext fill contexts} to get the value of each field (there is one fill\n * context per fill request).\n * </ol>\n *\n * <p>For example, in an app that uses 2 steps for the username and password fields, the workflow\n * would be:\n * <pre class=\"prettyprint\">\n *  // On first fill request\n *  AutofillId usernameId = // parse from AssistStructure;\n *  Bundle clientState = new Bundle();\n *  clientState.putParcelable(\"usernameId\", usernameId);\n *  fillCallback.onSuccess(\n *    new FillResponse.Builder()\n *        .setClientState(clientState)\n *        .setSaveInfo(new SaveInfo\n *             .Builder(SaveInfo.SAVE_DATA_TYPE_USERNAME, new AutofillId[] {usernameId})\n *             .build())\n *        .build());\n *\n *  // On second fill request\n *  Bundle clientState = fillRequest.getClientState();\n *  AutofillId usernameId = clientState.getParcelable(\"usernameId\");\n *  AutofillId passwordId = // parse from AssistStructure\n *  clientState.putParcelable(\"passwordId\", passwordId);\n *  fillCallback.onSuccess(\n *    new FillResponse.Builder()\n *        .setClientState(clientState)\n *        .setSaveInfo(new SaveInfo\n *             .Builder(SaveInfo.SAVE_DATA_TYPE_USERNAME | SaveInfo.SAVE_DATA_TYPE_PASSWORD,\n *                      new AutofillId[] {usernameId, passwordId})\n *             .setFlags(SaveInfo.FLAG_SAVE_ON_ALL_VIEWS_INVISIBLE)\n *             .build())\n *        .build());\n *\n *  // On save request\n *  Bundle clientState = saveRequest.getClientState();\n *  AutofillId usernameId = clientState.getParcelable(\"usernameId\");\n *  AutofillId passwordId = clientState.getParcelable(\"passwordId\");\n *  List<FillContext> fillContexts = saveRequest.getFillContexts();\n *\n *  FillContext usernameContext = fillContexts.get(0);\n *  ViewNode usernameNode = findNodeByAutofillId(usernameContext.getStructure(), usernameId);\n *  AutofillValue username = usernameNode.getAutofillValue().getTextValue().toString();\n *\n *  FillContext passwordContext = fillContexts.get(1);\n *  ViewNode passwordNode = findNodeByAutofillId(passwordContext.getStructure(), passwordId);\n *  AutofillValue password = passwordNode.getAutofillValue().getTextValue().toString();\n *\n *  save(username, password);\n *  </pre>\n *\n * <a name=\"Privacy\"></a>\n * <h3>Privacy</h3>\n *\n * <p>The {@link #onFillRequest(FillRequest, CancellationSignal, FillCallback)} method is called\n * without the user content. The Android system strips some properties of the\n * {@link android.app.assist.AssistStructure.ViewNode view nodes} passed to this call, but not all\n * of them. For example, the data provided in the {@link android.view.ViewStructure.HtmlInfo}\n * objects set by {@link android.webkit.WebView} is never stripped out.\n *\n * <p>Because this data could contain PII (Personally Identifiable Information, such as username or\n * email address), the service should only use it locally (i.e., in the app's process) for\n * heuristics purposes, but it should not be sent to external servers.\n *\n * <a name=\"FieldClassification\"></a>\n * <h3>Metrics and field classification</h3>\n *\n * <p>The service can call {@link #getFillEventHistory()} to get metrics representing the user\n * actions, and then use these metrics to improve its heuristics.\n *\n * <p>Prior to Android {@link android.os.Build.VERSION_CODES#P}, the metrics covered just the\n * scenarios where the service knew how to autofill an activity, but Android\n * {@link android.os.Build.VERSION_CODES#P} introduced a new mechanism called field classification,\n * which allows the service to dynamically classify the meaning of fields based on the existing user\n * data known by the service.\n *\n * <p>Typically, field classification can be used to detect fields that can be autofilled with\n * user data that is not associated with a specific app&mdash;such as email and physical\n * address. Once the service identifies that a such field was manually filled by the user, the\n * service could use this signal to improve its heuristics on subsequent requests (for example, by\n * infering which resource ids are associated with known fields).\n *\n * <p>The field classification workflow involves 4 steps:\n *\n * <ol>\n *   <li>Set the user data through {@link AutofillManager#setUserData(UserData)}. This data is\n *   cached until the system restarts (or the service is disabled), so it doesn't need to be set for\n *   all requests.\n *   <li>Identify which fields should be analysed by calling\n *   {@link FillResponse.Builder#setFieldClassificationIds(AutofillId...)}.\n *   <li>Verify the results through {@link FillEventHistory.Event#getFieldsClassification()}.\n *   <li>Use the results to dynamically create {@link Dataset} or {@link SaveInfo} objects in\n *   subsequent requests.\n * </ol>\n *\n * <p>The field classification is an expensive operation and should be used carefully, otherwise it\n * can reach its rate limit and get blocked by the Android System. Ideally, it should be used just\n * in cases where the service could not determine how an activity can be autofilled, but it has a\n * strong suspicious that it could. For example, if an activity has four or more fields and one of\n * them is a list, chances are that these are address fields (like address, city, state, and\n * zip code).\n *\n * <a name=\"CompatibilityMode\"></a>\n * <h3>Compatibility mode</h3>\n *\n * <p>Apps that use standard Android widgets support autofill out-of-the-box and need to do\n * very little to improve their user experience (annotating autofillable views and providing\n * autofill hints). However, some apps (typically browsers) do their own rendering and the rendered\n * content may contain semantic structure that needs to be surfaced to the autofill framework. The\n * platform exposes APIs to achieve this, however it could take some time until these apps implement\n * autofill support.\n *\n * <p>To enable autofill for such apps the platform provides a compatibility mode in which the\n * platform would fall back to the accessibility APIs to generate the state reported to autofill\n * services and fill data. This mode needs to be explicitly requested for a given package up\n * to a specified max version code allowing clean migration path when the target app begins to\n * support autofill natively. Note that enabling compatibility may degrade performance for the\n * target package and should be used with caution. The platform supports creating an allowlist for\n * including which packages can be targeted in compatibility mode to ensure this mode is used only\n * when needed and as long as needed.\n *\n * <p>You can request compatibility mode for packages of interest in the meta-data resource\n * associated with your service. Below is a sample service declaration:\n *\n * <pre> &lt;service android:name=\".MyAutofillService\"\n *              android:permission=\"android.permission.BIND_AUTOFILL_SERVICE\"&gt;\n *     &lt;intent-filter&gt;\n *         &lt;action android:name=\"android.service.autofill.AutofillService\" /&gt;\n *     &lt;/intent-filter&gt;\n *     &lt;meta-data android:name=\"android.autofill\" android:resource=\"@xml/autofillservice\" /&gt;\n * &lt;/service&gt;</pre>\n *\n * <p>In the XML file you can specify one or more packages for which to enable compatibility\n * mode. Below is a sample meta-data declaration:\n *\n * <pre> &lt;autofill-service xmlns:android=\"http://schemas.android.com/apk/res/android\"&gt;\n *     &lt;compatibility-package android:name=\"foo.bar.baz\" android:maxLongVersionCode=\"1000000000\"/&gt;\n * &lt;/autofill-service&gt;</pre>\n *\n * <p>Notice that compatibility mode has limitations such as:\n * <ul>\n * <li>No manual autofill requests. Hence, the {@link FillRequest}\n * {@link FillRequest#getFlags() flags} never have the {@link FillRequest#FLAG_MANUAL_REQUEST} flag.\n * <li>The value of password fields are most likely masked&mdash;for example, {@code ****} instead\n * of {@code 1234}. Hence, you must be careful when using these values to avoid updating the user\n * data with invalid input. For example, when you parse the {@link FillRequest} and detect a\n * password field, you could check if its\n * {@link android.app.assist.AssistStructure.ViewNode#getInputType()\n * input type} has password flags and if so, don't add it to the {@link SaveInfo} object.\n * <li>The autofill context is not always {@link AutofillManager#commit() committed} when an HTML\n * form is submitted. Hence, you must use other mechanisms to trigger save, such as setting the\n * {@link SaveInfo#FLAG_SAVE_ON_ALL_VIEWS_INVISIBLE} flag on {@link SaveInfo.Builder#setFlags(int)}\n * or using {@link SaveInfo.Builder#setTriggerId(AutofillId)}.\n * <li>Browsers often provide their own autofill management system. When both the browser and\n * the platform render an autofill dialog at the same time, the result can be confusing to the user.\n * Such browsers typically offer an option for users to disable autofill, so your service should\n * also allow users to disable compatiblity mode for specific apps. That way, it is up to the user\n * to decide which autofill mechanism&mdash;the browser's or the platform's&mdash;should be used.\n * </ul>\n ",
  "links" : [ "android.service.autofill.FillCallback#onFailure(CharSequence)", "android.service.autofill.SaveInfo", "#onConnected()", "FillResponse.Builder#setIgnoredIds(AutofillId...)", "android.view.autofill.AutofillManager#notifyViewEntered(android.view.View)", "android.view.autofill.AutofillValue", "android.service.autofill.FillContext", "SaveInfo.Builder#setFlags(int)", "android.app.assist.AssistStructure.ViewNode#getClassName()", "android.provider.Settings#ACTION_REQUEST_SET_AUTOFILL_SERVICE", "android.service.autofill.FillRequest", "FillResponse.Builder#setAuthentication(AutofillId", "android.service.autofill.FillRequest#getFlags()", "#onSaveRequest(SaveRequest", "android.service.autofill.FillRequest#FLAG_MANUAL_REQUEST", "android.service.autofill.FillResponse", "#getFillEventHistory()", "android.view.autofill.AutofillManager#commit()", "android.service.autofill.FillRequest#getClientState()", "android.view.View", "FillResponse.Builder#setClientState(android.os.Bundle)", "SaveInfo.Builder#setTriggerId(AutofillId)", "#onFillRequest(FillRequest", "android.view.autofill.AutofillId", "android.webkit.WebView", "#onDisconnected()", "android.service.autofill.Dataset", "android.app.assist.AssistStructure.ViewNode#isFocused()", "android.app.assist.AssistStructure.ViewNode", "android.view.ViewStructure.HtmlInfo", "android.app.assist.AssistStructure.ViewNode#getAutofillValue()", "SaveInfo.Builder#setDescription(CharSequence)", "android.view.autofill.AutofillManager#setUserData(UserData)", "android.app.assist.AssistStructure.ViewNode#getAutofillHints()", "FillEventHistory.Event#getFieldsClassification()", "android.service.autofill.SaveInfo#FLAG_SAVE_ON_ALL_VIEWS_INVISIBLE", "android.os.Build.VERSION_CODES#P", "Dataset.Builder#setAuthentication(android.content.IntentSender)", "android.view.ViewStructure", "android.service.autofill.FillCallback#onSuccess(FillResponse)", "FillResponse.Builder#setFieldClassificationIds(AutofillId...)", "android.app.assist.AssistStructure.ViewNode#getInputType()", "android.app.assist.AssistStructure.ViewNode#getWebDomain()", "Dataset.Builder#setValue(AutofillId" ],
  "variables" : [ {
    "name" : "TAG",
    "type" : "String",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "SERVICE_INTERFACE",
    "type" : "String",
    "comment" : "\n     * The {@link Intent} that must be declared as handled by the service.\n     * To be supported, the service must also require the\n     * {@link android.Manifest.permission#BIND_AUTOFILL_SERVICE} permission so\n     * that other applications can not abuse it.\n     ",
    "links" : [ "android.content.Intent", "android.Manifest.permission#BIND_AUTOFILL_SERVICE" ]
  }, {
    "name" : "SERVICE_META_DATA",
    "type" : "String",
    "comment" : "\n     * Name under which a AutoFillService component publishes information about itself.\n     * This meta-data should reference an XML resource containing a\n     * <code>&lt;{@link\n     * android.R.styleable#AutofillService autofill-service}&gt;</code> tag.\n     * This is a a sample XML file configuring an AutoFillService:\n     * <pre> &lt;autofill-service\n     *     android:settingsActivity=\"foo.bar.SettingsActivity\"\n     *     . . .\n     * /&gt;</pre>\n     ",
    "links" : [ "android.R.styleable#AutofillService" ]
  }, {
    "name" : "EXTRA_FILL_RESPONSE",
    "type" : "String",
    "comment" : "\n     * Name of the {@link FillResponse} extra used to return a delayed fill response.\n     *\n     * <p>Please see {@link FillRequest#getDelayedFillIntentSender()} on how to send a delayed\n     * fill response to framework.</p>\n     ",
    "links" : [ "android.service.autofill.FillResponse", "android.service.autofill.FillRequest#getDelayedFillIntentSender()" ]
  }, {
    "name" : "EXTRA_RESULT",
    "type" : "String",
    "comment" : "\n     * Name of the {@link IResultReceiver} extra used to return the primary result of a request.\n     *\n     * @hide\n     ",
    "links" : [ "com.android.internal.os.IResultReceiver" ]
  }, {
    "name" : "EXTRA_ERROR",
    "type" : "String",
    "comment" : "\n     * Name of the {@link IResultReceiver} extra used to return the error reason of a request.\n     *\n     * @hide\n     ",
    "links" : [ "com.android.internal.os.IResultReceiver" ]
  }, {
    "name" : "WEBVIEW_REQUESTED_CREDENTIAL_KEY",
    "type" : "String",
    "comment" : "\n     * Name of the key used to mark whether the fill response is for a webview.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "mInterface",
    "type" : "IAutoFillService",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mHandler",
    "type" : "Handler",
    "comment" : "",
    "links" : [ ]
  } ],
  "methods" : [ {
    "name" : "public void onCreate()",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public final IBinder onBind(Intent intent)",
    "returnType" : "IBinder",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public void onConnected()",
    "returnType" : "void",
    "comment" : "\n     * Called when the Android system connects to service.\n     *\n     * <p>You should generally do initialization here rather than in {@link #onCreate}.\n     ",
    "links" : [ "#onCreate" ]
  }, {
    "name" : "public abstract void onFillRequest(@NonNull FillRequest request, @NonNull CancellationSignal cancellationSignal, @NonNull FillCallback callback)",
    "returnType" : "void",
    "comment" : "\n     * Called by the Android system do decide if a screen can be autofilled by the service.\n     *\n     * <p>Service must call one of the {@link FillCallback} methods (like\n     * {@link FillCallback#onSuccess(FillResponse)}\n     * or {@link FillCallback#onFailure(CharSequence)})\n     * to notify the result of the request.\n     *\n     * @param request the {@link FillRequest request} to handle.\n     *        See {@link FillResponse} for examples of multiple-sections requests.\n     * @param cancellationSignal signal for observing cancellation requests. The system will use\n     *     this to notify you that the fill result is no longer needed and you should stop\n     *     handling this fill request in order to save resources.\n     * @param callback object used to notify the result of the request.\n     ",
    "links" : [ "android.service.autofill.FillCallback#onFailure(CharSequence)", "android.service.autofill.FillResponse", "android.service.autofill.FillCallback#onSuccess(FillResponse)", "android.service.autofill.FillRequest", "android.service.autofill.FillCallback" ]
  }, {
    "name" : "public void onFillCredentialRequest(@NonNull FillRequest request, @NonNull CancellationSignal cancellationSignal, @NonNull FillCallback callback, @NonNull IBinder autofillClientCallback)",
    "returnType" : "void",
    "comment" : "\n     * Variant of onFillRequest for internal credential manager proxy autofill service only.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public void onConvertCredentialRequest(@NonNull ConvertCredentialRequest convertCredentialRequest, @NonNull ConvertCredentialCallback convertCredentialCallback)",
    "returnType" : "void",
    "comment" : "\n     * Called by the Android system to convert a credential manager response to a dataset\n     *\n     * @param convertCredentialRequest the request that has the original credential manager response\n     * @param convertCredentialCallback callback used to notify the result of the request.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public abstract void onSaveRequest(@NonNull SaveRequest request, @NonNull SaveCallback callback)",
    "returnType" : "void",
    "comment" : "\n     * Called when the user requests the service to save the contents of a screen.\n     *\n     * <p>If the service could not handle the request right away&mdash;for example, because it must\n     * launch an activity asking the user to authenticate first or because the network is\n     * down&mdash;the service could keep the {@link SaveRequest request} and reuse it later,\n     * but the service <b>must always</b> call {@link SaveCallback#onSuccess()} or\n     * {@link SaveCallback#onSuccess(android.content.IntentSender)} right away.\n     *\n     * <p><b>Note:</b> To retrieve the actual value of fields input by the user, the service\n     * should call\n     * {@link android.app.assist.AssistStructure.ViewNode#getAutofillValue()}; if it calls\n     * {@link android.app.assist.AssistStructure.ViewNode#getText()} or other methods, there is no\n     * guarantee such method will return the most recent value of the field.\n     *\n     * @param request the {@link SaveRequest request} to handle.\n     *        See {@link FillResponse} for examples of multiple-sections requests.\n     * @param callback object used to notify the result of the request.\n     ",
    "links" : [ "android.service.autofill.FillResponse", "android.service.autofill.SaveRequest", "android.app.assist.AssistStructure.ViewNode#getText()", "android.app.assist.AssistStructure.ViewNode#getAutofillValue()", "android.service.autofill.SaveCallback#onSuccess()", "android.service.autofill.SaveCallback#onSuccess(android.content.IntentSender)" ]
  }, {
    "name" : "public void onSavedDatasetsInfoRequest(@NonNull SavedDatasetsInfoCallback callback)",
    "returnType" : "void",
    "comment" : "\n     * Called from system settings to display information about the datasets the user saved to this\n     * service.\n     *\n     * <p>There is no timeout for the request, but it's recommended to return the result within a\n     * few seconds, or the user may navigate away from the activity that would display the result.\n     *\n     * @param callback callback for responding to the request\n     ",
    "links" : [ ]
  }, {
    "name" : "public void onDisconnected()",
    "returnType" : "void",
    "comment" : "\n     * Called when the Android system disconnects from the service.\n     *\n     * <p> At this point this service may no longer be an active {@link AutofillService}.\n     * It should not make calls on {@link AutofillManager} that requires the caller to be\n     * the current service.\n     ",
    "links" : [ "android.service.autofill.AutofillService", "android.view.autofill.AutofillManager" ]
  }, {
    "name" : "public final FillEventHistory getFillEventHistory()",
    "returnType" : "FillEventHistory",
    "comment" : "\n     * Gets the events that happened after the last\n     * {@link AutofillService#onFillRequest(FillRequest, android.os.CancellationSignal, FillCallback)}\n     * call.\n     *\n     * <p>This method is typically used to keep track of previous user actions to optimize further\n     * requests. For example, the service might return email addresses in alphabetical order by\n     * default, but change that order based on the address the user picked on previous requests.\n     *\n     * <p>The history is not persisted over reboots, and it's cleared every time the service\n     * replies to a {@link #onFillRequest(FillRequest, CancellationSignal, FillCallback)} by calling\n     * {@link FillCallback#onSuccess(FillResponse)} or {@link FillCallback#onFailure(CharSequence)}\n     * (if the service doesn't call any of these methods, the history will clear out after some\n     * pre-defined time). Hence, the service should call {@link #getFillEventHistory()} before\n     * finishing the {@link FillCallback}.\n     *\n     * @return The history or {@code null} if there are no events.\n     *\n     * @throws RuntimeException if the event history could not be retrieved.\n     ",
    "links" : [ "android.service.autofill.FillCallback#onFailure(CharSequence)", "#getFillEventHistory()", "android.service.autofill.FillCallback#onSuccess(FillResponse)", "android.service.autofill.AutofillService#onFillRequest(FillRequest", "#onFillRequest(FillRequest", "android.service.autofill.FillCallback" ]
  } ],
  "methodNames" : [ "public void onCreate()", "public final IBinder onBind(Intent intent)", "public void onConnected()", "public abstract void onFillRequest(@NonNull FillRequest request, @NonNull CancellationSignal cancellationSignal, @NonNull FillCallback callback)", "public void onFillCredentialRequest(@NonNull FillRequest request, @NonNull CancellationSignal cancellationSignal, @NonNull FillCallback callback, @NonNull IBinder autofillClientCallback)", "public void onConvertCredentialRequest(@NonNull ConvertCredentialRequest convertCredentialRequest, @NonNull ConvertCredentialCallback convertCredentialCallback)", "public abstract void onSaveRequest(@NonNull SaveRequest request, @NonNull SaveCallback callback)", "public void onSavedDatasetsInfoRequest(@NonNull SavedDatasetsInfoCallback callback)", "public void onDisconnected()", "public final FillEventHistory getFillEventHistory()" ],
  "variableNames" : [ "TAG", "SERVICE_INTERFACE", "SERVICE_META_DATA", "EXTRA_FILL_RESPONSE", "EXTRA_RESULT", "EXTRA_ERROR", "WEBVIEW_REQUESTED_CREDENTIAL_KEY", "mInterface", "mHandler" ]
}