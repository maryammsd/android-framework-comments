{
  "filePath" : "/home/maryam/clearblue/files/android-source-30/android/os/UserManager.java",
  "packageName" : "android.os",
  "className" : "UserManager",
  "comment" : "\n * Manages users and user details on a multi-user system. There are two major categories of\n * users: fully customizable users with their own login, and managed profiles that share a workspace\n * with a related user.\n * <p>\n * Users are different from accounts, which are managed by\n * {@link AccountManager}. Each user can have their own set of accounts.\n * <p>\n * See {@link DevicePolicyManager#ACTION_PROVISION_MANAGED_PROFILE} for more on managed profiles.\n ",
  "variables" : [ {
    "name" : "TAG",
    "type" : "String",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mService",
    "type" : "IUserManager",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mContext",
    "type" : "Context",
    "comment" : " Holding the Application context (not constructor param context). ",
    "links" : [ ]
  }, {
    "name" : "mUserId",
    "type" : "int",
    "comment" : " The userId of the constructor param context. To be used instead of mContext.getUserId(). ",
    "links" : [ ]
  }, {
    "name" : "mIsManagedProfileCached",
    "type" : "Boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mIsProfileCached",
    "type" : "Boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "USER_TYPE_FULL_SYSTEM",
    "type" : "String",
    "comment" : "\n     * User type representing a {@link UserHandle#USER_SYSTEM system} user that is a human user.\n     * This type of user cannot be created; it can only pre-exist on first boot.\n     * @hide\n     ",
    "links" : [ "UserHandle#USER_SYSTEM" ]
  }, {
    "name" : "USER_TYPE_FULL_SECONDARY",
    "type" : "String",
    "comment" : "\n     * User type representing a regular non-profile non-{@link UserHandle#USER_SYSTEM system} human\n     * user.\n     * This is sometimes called an ordinary 'secondary user'.\n     * @hide\n     ",
    "links" : [ "UserHandle#USER_SYSTEM" ]
  }, {
    "name" : "USER_TYPE_FULL_GUEST",
    "type" : "String",
    "comment" : "\n     * User type representing a guest user that may be transient.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "USER_TYPE_FULL_DEMO",
    "type" : "String",
    "comment" : "\n     * User type representing a user for demo purposes only, which can be removed at any time.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "USER_TYPE_FULL_RESTRICTED",
    "type" : "String",
    "comment" : "\n     * User type representing a \"restricted profile\" user, which is a full user that is subject to\n     * certain restrictions from a parent user. Note, however, that it is NOT technically a profile.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "USER_TYPE_PROFILE_MANAGED",
    "type" : "String",
    "comment" : "\n     * User type representing a managed profile, which is a profile that is to be managed by a\n     * device policy controller (DPC).\n     * The intended purpose is for work profiles, which are managed by a corporate entity.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "USER_TYPE_SYSTEM_HEADLESS",
    "type" : "String",
    "comment" : "\n     * User type representing a {@link UserHandle#USER_SYSTEM system} user that is <b>not</b> a\n     * human user.\n     * This type of user cannot be created; it can only pre-exist on first boot.\n     * @hide\n     ",
    "links" : [ "UserHandle#USER_SYSTEM" ]
  }, {
    "name" : "QUIET_MODE_DISABLE_ONLY_IF_CREDENTIAL_NOT_REQUIRED",
    "type" : "int",
    "comment" : "\n     * Flag passed to {@link #requestQuietModeEnabled} to request disabling quiet mode only if\n     * there is no need to confirm the user credentials. If credentials are required to disable\n     * quiet mode, {@link #requestQuietModeEnabled} will do nothing and return {@code false}.\n     ",
    "links" : [ "#requestQuietModeEnabled", "#requestQuietModeEnabled" ]
  }, {
    "name" : "QUIET_MODE_DISABLE_DONT_ASK_CREDENTIAL",
    "type" : "int",
    "comment" : "\n     * Flag passed to {@link #requestQuietModeEnabled} to request disabling quiet mode without\n     * asking for credentials. This is used when managed profile password is forgotten. It starts\n     * the user in locked state so that a direct boot aware DPC could reset the password.\n     * Should not be used together with\n     * {@link #QUIET_MODE_DISABLE_ONLY_IF_CREDENTIAL_NOT_REQUIRED} or an exception will be thrown.\n     * @hide\n     ",
    "links" : [ "#requestQuietModeEnabled", "#QUIET_MODE_DISABLE_ONLY_IF_CREDENTIAL_NOT_REQUIRED" ]
  }, {
    "name" : "RESTRICTION_NOT_SET",
    "type" : "int",
    "comment" : "\n     * @hide\n     * No user restriction.\n     ",
    "links" : [ ]
  }, {
    "name" : "RESTRICTION_SOURCE_SYSTEM",
    "type" : "int",
    "comment" : "\n     * @hide\n     * User restriction set by system/user.\n     ",
    "links" : [ ]
  }, {
    "name" : "RESTRICTION_SOURCE_DEVICE_OWNER",
    "type" : "int",
    "comment" : "\n     * @hide\n     * User restriction set by a device owner.\n     ",
    "links" : [ ]
  }, {
    "name" : "RESTRICTION_SOURCE_PROFILE_OWNER",
    "type" : "int",
    "comment" : "\n     * @hide\n     * User restriction set by a profile owner.\n     ",
    "links" : [ ]
  }, {
    "name" : "DISALLOW_MODIFY_ACCOUNTS",
    "type" : "String",
    "comment" : "\n     * Specifies if a user is disallowed from adding and removing accounts, unless they are\n     * {@link android.accounts.AccountManager#addAccountExplicitly programmatically} added by\n     * Authenticator.\n     * The default value is <code>false</code>.\n     *\n     * <p>From {@link android.os.Build.VERSION_CODES#N} a profile or device owner app can still\n     * use {@link android.accounts.AccountManager} APIs to add or remove accounts when account\n     * management is disallowed.\n     *\n     * <p>Key for user restrictions.\n     * <p>Type: Boolean\n     * @see DevicePolicyManager#addUserRestriction(ComponentName, String)\n     * @see DevicePolicyManager#clearUserRestriction(ComponentName, String)\n     * @see #getUserRestrictions()\n     ",
    "links" : [ "android.accounts.AccountManager#addAccountExplicitly", "android.os.Build.VERSION_CODES#N", "android.accounts.AccountManager" ]
  }, {
    "name" : "DISALLOW_CONFIG_WIFI",
    "type" : "String",
    "comment" : "\n     * Specifies if a user is disallowed from changing Wi-Fi access points via Settings.\n     *\n     * <p>A device owner and a profile owner can set this restriction, although the restriction has\n     * no effect in a managed profile. When it is set by a device owner, a profile owner on the\n     * primary user or by a profile owner of an organization-owned managed profile on the parent\n     * profile, it disallows the primary user from changing Wi-Fi access points.\n     *\n     * <p>The default value is <code>false</code>.\n     *\n     * <p>Key for user restrictions.\n     * <p>Type: Boolean\n     * @see DevicePolicyManager#addUserRestriction(ComponentName, String)\n     * @see DevicePolicyManager#clearUserRestriction(ComponentName, String)\n     * @see #getUserRestrictions()\n     ",
    "links" : [ ]
  }, {
    "name" : "DISALLOW_CONFIG_LOCALE",
    "type" : "String",
    "comment" : "\n     * Specifies if a user is disallowed from changing the device\n     * language. The default value is <code>false</code>.\n     *\n     * <p>Key for user restrictions.\n     * <p>Type: Boolean\n     * @see DevicePolicyManager#addUserRestriction(ComponentName, String)\n     * @see DevicePolicyManager#clearUserRestriction(ComponentName, String)\n     * @see #getUserRestrictions()\n     ",
    "links" : [ ]
  }, {
    "name" : "DISALLOW_INSTALL_APPS",
    "type" : "String",
    "comment" : "\n     * Specifies if a user is disallowed from installing applications. This user restriction also\n     * prevents device owners and profile owners installing apps. The default value is\n     * {@code false}.\n     *\n     * <p>Key for user restrictions.\n     * <p>Type: Boolean\n     * @see DevicePolicyManager#addUserRestriction(ComponentName, String)\n     * @see DevicePolicyManager#clearUserRestriction(ComponentName, String)\n     * @see #getUserRestrictions()\n     ",
    "links" : [ ]
  }, {
    "name" : "DISALLOW_UNINSTALL_APPS",
    "type" : "String",
    "comment" : "\n     * Specifies if a user is disallowed from uninstalling applications.\n     * The default value is <code>false</code>.\n     *\n     * <p>Key for user restrictions.\n     * <p>Type: Boolean\n     * @see DevicePolicyManager#addUserRestriction(ComponentName, String)\n     * @see DevicePolicyManager#clearUserRestriction(ComponentName, String)\n     * @see #getUserRestrictions()\n     ",
    "links" : [ ]
  }, {
    "name" : "DISALLOW_SHARE_LOCATION",
    "type" : "String",
    "comment" : "\n     * Specifies if a user is disallowed from turning on location sharing.\n     *\n     * <p>In a managed profile, location sharing by default reflects the primary user's setting, but\n     * can be overridden and forced off by setting this restriction to true in the managed profile.\n     *\n     * <p>A device owner and a profile owner can set this restriction. When it is set by a device\n     * owner, a profile owner on the primary user or by a profile owner of an organization-owned\n     * managed profile on the parent profile, it prevents the primary user from turning on\n     * location sharing.\n     *\n     * <p>The default value is <code>false</code>.\n     *\n     * <p>Key for user restrictions.\n     * <p>Type: Boolean\n     * @see DevicePolicyManager#addUserRestriction(ComponentName, String)\n     * @see DevicePolicyManager#clearUserRestriction(ComponentName, String)\n     * @see #getUserRestrictions()\n     ",
    "links" : [ ]
  }, {
    "name" : "DISALLOW_AIRPLANE_MODE",
    "type" : "String",
    "comment" : "\n     * Specifies if airplane mode is disallowed on the device.\n     *\n     * <p>This restriction can only be set by a device owner, a profile owner on the primary\n     * user or a profile owner of an organization-owned managed profile on the parent profile.\n     * When it is set by any of these owners, it applies globally - i.e., it disables airplane mode\n     * on the entire device.\n     *\n     * <p>The default value is <code>false</code>.\n     *\n     * <p>Key for user restrictions.\n     * <p>Type: Boolean\n     * @see DevicePolicyManager#addUserRestriction(ComponentName, String)\n     * @see DevicePolicyManager#clearUserRestriction(ComponentName, String)\n     * @see #getUserRestrictions()\n     ",
    "links" : [ ]
  }, {
    "name" : "DISALLOW_CONFIG_BRIGHTNESS",
    "type" : "String",
    "comment" : "\n     * Specifies if a user is disallowed from configuring brightness. When device owner sets it,\n     * it'll only be applied on the target(system) user.\n     *\n     * <p>The default value is <code>false</code>.\n     *\n     * <p>This user restriction has no effect on managed profiles.\n     * <p>Key for user restrictions.\n     * <p>Type: Boolean\n     * @see DevicePolicyManager#addUserRestriction(ComponentName, String)\n     * @see DevicePolicyManager#clearUserRestriction(ComponentName, String)\n     * @see #getUserRestrictions()\n     ",
    "links" : [ ]
  }, {
    "name" : "DISALLOW_AMBIENT_DISPLAY",
    "type" : "String",
    "comment" : "\n     * Specifies if ambient display is disallowed for the user.\n     *\n     * <p>The default value is <code>false</code>.\n     *\n     * <p>This user restriction has no effect on managed profiles.\n     * <p>Key for user restrictions.\n     * <p>Type: Boolean\n     * @see DevicePolicyManager#addUserRestriction(ComponentName, String)\n     * @see DevicePolicyManager#clearUserRestriction(ComponentName, String)\n     * @see #getUserRestrictions()\n     ",
    "links" : [ ]
  }, {
    "name" : "DISALLOW_CONFIG_SCREEN_TIMEOUT",
    "type" : "String",
    "comment" : "\n     * Specifies if a user is disallowed from changing screen off timeout.\n     *\n     * <p>The default value is <code>false</code>.\n     *\n     * <p>This user restriction has no effect on managed profiles.\n     * <p>Key for user restrictions.\n     * <p>Type: Boolean\n     * @see DevicePolicyManager#addUserRestriction(ComponentName, String)\n     * @see DevicePolicyManager#clearUserRestriction(ComponentName, String)\n     * @see #getUserRestrictions()\n     ",
    "links" : [ ]
  }, {
    "name" : "DISALLOW_INSTALL_UNKNOWN_SOURCES",
    "type" : "String",
    "comment" : "\n     * Specifies if a user is disallowed from enabling the\n     * \"Unknown Sources\" setting, that allows installation of apps from unknown sources.\n     * Unknown sources exclude adb and special apps such as trusted app stores.\n     * The default value is <code>false</code>.\n     *\n     * <p>Key for user restrictions.\n     * <p>Type: Boolean\n     * @see DevicePolicyManager#addUserRestriction(ComponentName, String)\n     * @see DevicePolicyManager#clearUserRestriction(ComponentName, String)\n     * @see #getUserRestrictions()\n     ",
    "links" : [ ]
  }, {
    "name" : "DISALLOW_INSTALL_UNKNOWN_SOURCES_GLOBALLY",
    "type" : "String",
    "comment" : "\n     * This restriction is a device-wide version of {@link #DISALLOW_INSTALL_UNKNOWN_SOURCES}.\n     *\n     * Specifies if all users on the device are disallowed from enabling the\n     * \"Unknown Sources\" setting, that allows installation of apps from unknown sources.\n     *\n     * This restriction can be enabled by the profile owner, in which case all accounts and\n     * profiles will be affected.\n     *\n     * The default value is <code>false</code>.\n     *\n     * <p>Key for user restrictions.\n     * <p>Type: Boolean\n     * @see DevicePolicyManager#addUserRestriction(ComponentName, String)\n     * @see DevicePolicyManager#clearUserRestriction(ComponentName, String)\n     * @see #getUserRestrictions()\n     ",
    "links" : [ "#DISALLOW_INSTALL_UNKNOWN_SOURCES" ]
  }, {
    "name" : "DISALLOW_CONFIG_BLUETOOTH",
    "type" : "String",
    "comment" : "\n     * Specifies if a user is disallowed from configuring bluetooth via Settings. This does\n     * <em>not</em> restrict the user from turning bluetooth on or off.\n     *\n     * <p>This restriction doesn't prevent the user from using bluetooth. For disallowing usage of\n     * bluetooth completely on the device, use {@link #DISALLOW_BLUETOOTH}.\n     *\n     * <p>A device owner and a profile owner can set this restriction, although the restriction has\n     * no effect in a managed profile. When it is set by a device owner, a profile owner on the\n     * primary user or by a profile owner of an organization-owned managed profile on the parent\n     * profile, it disallows the primary user from configuring bluetooth.\n     *\n     * <p>The default value is <code>false</code>.\n     *\n     * <p>Key for user restrictions.\n     * <p>Type: Boolean\n     * @see DevicePolicyManager#addUserRestriction(ComponentName, String)\n     * @see DevicePolicyManager#clearUserRestriction(ComponentName, String)\n     * @see #getUserRestrictions()\n     ",
    "links" : [ "#DISALLOW_BLUETOOTH" ]
  }, {
    "name" : "DISALLOW_BLUETOOTH",
    "type" : "String",
    "comment" : "\n     * Specifies if bluetooth is disallowed on the device. If bluetooth is disallowed on the device,\n     * bluetooth cannot be turned on or configured via Settings.\n     *\n     * <p>This restriction can only be set by a device owner, a profile owner on the primary\n     * user or a profile owner of an organization-owned managed profile on the parent profile.\n     * When it is set by a device owner, it applies globally - i.e., it disables bluetooth on\n     * the entire device and all users will be affected. When it is set by a profile owner on the\n     * primary user or by a profile owner of an organization-owned managed profile on the parent\n     * profile, it disables the primary user from using bluetooth and configuring bluetooth\n     * in Settings.\n     *\n     * <p>The default value is <code>false</code>.\n     *\n     * <p>Key for user restrictions.\n     * <p>Type: Boolean\n     * @see DevicePolicyManager#addUserRestriction(ComponentName, String)\n     * @see DevicePolicyManager#clearUserRestriction(ComponentName, String)\n     * @see #getUserRestrictions()\n     ",
    "links" : [ ]
  }, {
    "name" : "DISALLOW_BLUETOOTH_SHARING",
    "type" : "String",
    "comment" : "\n     * Specifies if outgoing bluetooth sharing is disallowed.\n     *\n     * <p>A device owner and a profile owner can set this restriction. When it is set by a device\n     * owner, it applies globally. When it is set by a profile owner on the primary user or by a\n     * profile owner of an organization-owned managed profile on the parent profile, it disables\n     * the primary user from any outgoing bluetooth sharing.\n     *\n     * <p>Default is <code>true</code> for managed profiles and false otherwise.\n     *\n     * <p>When a device upgrades to {@link android.os.Build.VERSION_CODES#O}, the system sets it\n     * for all existing managed profiles.\n     *\n     * <p>Key for user restrictions.\n     * <p>Type: Boolean\n     * @see DevicePolicyManager#addUserRestriction(ComponentName, String)\n     * @see DevicePolicyManager#clearUserRestriction(ComponentName, String)\n     * @see #getUserRestrictions()\n     ",
    "links" : [ "android.os.Build.VERSION_CODES#O" ]
  }, {
    "name" : "DISALLOW_USB_FILE_TRANSFER",
    "type" : "String",
    "comment" : "\n     * Specifies if a user is disallowed from transferring files over USB.\n     *\n     * <p>This restriction can only be set by a device owner, a profile owner on the primary\n     * user or a profile owner of an organization-owned managed profile on the parent profile.\n     * When it is set by a device owner, it applies globally. When it is set by a profile owner\n     * on the primary user or by a profile owner of an organization-owned managed profile on\n     * the parent profile, it disables the primary user from transferring files over USB. No other\n     * user on the device is able to use file transfer over USB because the UI for file transfer\n     * is always associated with the primary user.\n     *\n     * <p>The default value is <code>false</code>.\n     *\n     * <p>Key for user restrictions.\n     * <p>Type: Boolean\n     * @see DevicePolicyManager#addUserRestriction(ComponentName, String)\n     * @see DevicePolicyManager#clearUserRestriction(ComponentName, String)\n     * @see #getUserRestrictions()\n     ",
    "links" : [ ]
  }, {
    "name" : "DISALLOW_CONFIG_CREDENTIALS",
    "type" : "String",
    "comment" : "\n     * Specifies if a user is disallowed from configuring user\n     * credentials. The default value is <code>false</code>.\n     *\n     * <p>Key for user restrictions.\n     * <p>Type: Boolean\n     * @see DevicePolicyManager#addUserRestriction(ComponentName, String)\n     * @see DevicePolicyManager#clearUserRestriction(ComponentName, String)\n     * @see #getUserRestrictions()\n     ",
    "links" : [ ]
  }, {
    "name" : "DISALLOW_REMOVE_USER",
    "type" : "String",
    "comment" : "\n     * When set on the admin user this specifies if the user can remove users.\n     * When set on a non-admin secondary user, this specifies if the user can remove itself.\n     * This restriction has no effect on managed profiles.\n     * The default value is <code>false</code>.\n     *\n     * <p>Key for user restrictions.\n     * <p>Type: Boolean\n     * @see DevicePolicyManager#addUserRestriction(ComponentName, String)\n     * @see DevicePolicyManager#clearUserRestriction(ComponentName, String)\n     * @see #getUserRestrictions()\n     ",
    "links" : [ ]
  }, {
    "name" : "DISALLOW_REMOVE_MANAGED_PROFILE",
    "type" : "String",
    "comment" : "\n     * Specifies if managed profiles of this user can be removed, other than by its profile owner.\n     * The default value is <code>false</code>.\n     * <p>\n     * This restriction has no effect on managed profiles.\n     *\n     * <p>Key for user restrictions.\n     * <p>Type: Boolean\n     * @see DevicePolicyManager#addUserRestriction(ComponentName, String)\n     * @see DevicePolicyManager#clearUserRestriction(ComponentName, String)\n     * @see #getUserRestrictions()\n     * @deprecated As the ability to have a managed profile on a fully-managed device has been\n     * removed from the platform, this restriction will be silently ignored when applied by the\n     * device owner.\n     * When the device is provisioned with a managed profile on an organization-owned device,\n     * the managed profile could not be removed anyway.\n     ",
    "links" : [ ]
  }, {
    "name" : "DISALLOW_DEBUGGING_FEATURES",
    "type" : "String",
    "comment" : "\n     * Specifies if a user is disallowed from enabling or accessing debugging features.\n     *\n     * <p>A device owner and a profile owner can set this restriction. When it is set by a device\n     * owner, a profile owner on the primary user or by a profile owner of an organization-owned\n     * managed profile on the parent profile, it disables debugging features altogether, including\n     * USB debugging. When set on a managed profile or a secondary user, it blocks debugging for\n     * that user only, including starting activities, making service calls, accessing content\n     * providers, sending broadcasts, installing/uninstalling packages, clearing user data, etc.\n     *\n     * <p>The default value is <code>false</code>.\n     *\n     * <p>Key for user restrictions.\n     * <p>Type: Boolean\n     * @see DevicePolicyManager#addUserRestriction(ComponentName, String)\n     * @see DevicePolicyManager#clearUserRestriction(ComponentName, String)\n     * @see #getUserRestrictions()\n     ",
    "links" : [ ]
  }, {
    "name" : "DISALLOW_CONFIG_VPN",
    "type" : "String",
    "comment" : "\n     * Specifies if a user is disallowed from configuring a VPN. The default value is\n     * <code>false</code>. This restriction has an effect when set by device owners and, in Android\n     * 6.0 ({@linkplain android.os.Build.VERSION_CODES#M API level 23}) or higher, profile owners.\n     * <p>This restriction also prevents VPNs from starting. However, in Android 7.0\n     * ({@linkplain android.os.Build.VERSION_CODES#N API level 24}) or higher, the system does\n     * start always-on VPNs created by the device or profile owner.\n     *\n     * <p>Key for user restrictions.\n     * <p>Type: Boolean\n     * @see DevicePolicyManager#addUserRestriction(ComponentName, String)\n     * @see DevicePolicyManager#clearUserRestriction(ComponentName, String)\n     * @see #getUserRestrictions()\n     ",
    "links" : [ ]
  }, {
    "name" : "DISALLOW_CONFIG_LOCATION",
    "type" : "String",
    "comment" : "\n     * Specifies if a user is disallowed from enabling or disabling location providers. As a\n     * result, user is disallowed from turning on or off location via Settings.\n     *\n     * <p>A device owner and a profile owner can set this restriction. When it is set by a device\n     * owner, a profile owner on the primary user or by a profile owner of an organization-owned\n     * managed profile on the parent profile, it disallows the primary user from turning location\n     * on or off.\n     *\n     * <p>The default value is <code>false</code>.\n     *\n     * <p>This user restriction is different from {@link #DISALLOW_SHARE_LOCATION},\n     * as a device owner or a profile owner can still enable or disable location mode via\n     * {@link DevicePolicyManager#setLocationEnabled} when this restriction is on.\n     *\n     * <p>Key for user restrictions.\n     * <p>Type: Boolean\n     * @see LocationManager#isLocationEnabled()\n     * @see DevicePolicyManager#addUserRestriction(ComponentName, String)\n     * @see DevicePolicyManager#clearUserRestriction(ComponentName, String)\n     * @see #getUserRestrictions()\n     ",
    "links" : [ "#DISALLOW_SHARE_LOCATION", "DevicePolicyManager#setLocationEnabled" ]
  }, {
    "name" : "DISALLOW_CONFIG_DATE_TIME",
    "type" : "String",
    "comment" : "\n     * Specifies configuring date, time and timezone is disallowed via Settings.\n     *\n     * <p>A device owner and a profile owner can set this restriction, although the restriction has\n     * no effect in a managed profile. When it is set by a device owner or by a profile owner of an\n     * organization-owned managed profile on the parent profile, it applies globally - i.e.,\n     * it disables date, time and timezone setting on the entire device and all users are affected.\n     * When it is set by a profile owner on the primary user, it disables the primary user\n     * from configuring date, time and timezone and disables all configuring of date, time and\n     * timezone in Settings.\n     *\n     * <p>The default value is <code>false</code>.\n     *\n     * <p>Key for user restrictions.\n     * <p>Type: Boolean\n     * @see DevicePolicyManager#addUserRestriction(ComponentName, String)\n     * @see DevicePolicyManager#clearUserRestriction(ComponentName, String)\n     * @see #getUserRestrictions()\n     ",
    "links" : [ ]
  }, {
    "name" : "DISALLOW_CONFIG_TETHERING",
    "type" : "String",
    "comment" : "\n     * Specifies if a user is disallowed from configuring Tethering and portable hotspots\n     * via Settings.\n     *\n     * <p>This restriction can only be set by a device owner, a profile owner on the primary\n     * user or a profile owner of an organization-owned managed profile on the parent profile.\n     * When it is set by a device owner, it applies globally. When it is set by a profile owner\n     * on the primary user or by a profile owner of an organization-owned managed profile on\n     * the parent profile, it disables the primary user from using Tethering and hotspots and\n     * disables all configuring of Tethering and hotspots in Settings.\n     *\n     * <p>The default value is <code>false</code>.\n     *\n     * <p>In Android 9.0 or higher, if tethering is enabled when this restriction is set,\n     * tethering will be automatically turned off.\n     *\n     * <p>Key for user restrictions.\n     * <p>Type: Boolean\n     * @see DevicePolicyManager#addUserRestriction(ComponentName, String)\n     * @see DevicePolicyManager#clearUserRestriction(ComponentName, String)\n     * @see #getUserRestrictions()\n     ",
    "links" : [ ]
  }, {
    "name" : "DISALLOW_NETWORK_RESET",
    "type" : "String",
    "comment" : "\n     * Specifies if a user is disallowed from resetting network settings\n     * from Settings. This can only be set by device owners and profile owners on the primary user.\n     * The default value is <code>false</code>.\n     * <p>This restriction has no effect on secondary users and managed profiles since only the\n     * primary user can reset the network settings of the device.\n     *\n     * <p>Key for user restrictions.\n     * <p>Type: Boolean\n     * @see DevicePolicyManager#addUserRestriction(ComponentName, String)\n     * @see DevicePolicyManager#clearUserRestriction(ComponentName, String)\n     * @see #getUserRestrictions()\n     ",
    "links" : [ ]
  }, {
    "name" : "DISALLOW_FACTORY_RESET",
    "type" : "String",
    "comment" : "\n     * Specifies if a user is disallowed from factory resetting from Settings.\n     * This can only be set by device owners and profile owners on an admin user.\n     * The default value is <code>false</code>.\n     * <p>This restriction has no effect on non-admin users since they cannot factory reset the\n     * device.\n     *\n     * <p>Key for user restrictions.\n     * <p>Type: Boolean\n     * @see DevicePolicyManager#addUserRestriction(ComponentName, String)\n     * @see DevicePolicyManager#clearUserRestriction(ComponentName, String)\n     * @see #getUserRestrictions()\n     ",
    "links" : [ ]
  }, {
    "name" : "DISALLOW_ADD_USER",
    "type" : "String",
    "comment" : "\n     * Specifies if a user is disallowed from adding new users. This can only be set by device\n     * owners or profile owners on the primary user. The default value is <code>false</code>.\n     * <p>This restriction has no effect on secondary users and managed profiles since only the\n     * primary user can add other users.\n     * <p> When the device is an organization-owned device provisioned with a managed profile,\n     * this restriction will be set as a base restriction which cannot be removed by any admin.\n     *\n     * <p>Key for user restrictions.\n     * <p>Type: Boolean\n     * @see DevicePolicyManager#addUserRestriction(ComponentName, String)\n     * @see DevicePolicyManager#clearUserRestriction(ComponentName, String)\n     * @see #getUserRestrictions()\n     ",
    "links" : [ ]
  }, {
    "name" : "DISALLOW_ADD_MANAGED_PROFILE",
    "type" : "String",
    "comment" : "\n     * Specifies if a user is disallowed from adding managed profiles.\n     * <p>The default value for an unmanaged user is <code>false</code>.\n     * For users with a device owner set, the default is <code>true</code>.\n     * <p>This restriction has no effect on managed profiles.\n     *\n     * <p>Key for user restrictions.\n     * <p>Type: Boolean\n     * @see DevicePolicyManager#addUserRestriction(ComponentName, String)\n     * @see DevicePolicyManager#clearUserRestriction(ComponentName, String)\n     * @see #getUserRestrictions()\n     * @deprecated As the ability to have a managed profile on a fully-managed device has been\n     * removed from the platform, this restriction will be silently ignored when applied by the\n     * device owner.\n     ",
    "links" : [ ]
  }, {
    "name" : "ENSURE_VERIFY_APPS",
    "type" : "String",
    "comment" : "\n     * Specifies if a user is disallowed from disabling application verification. The default\n     * value is <code>false</code>.\n     *\n     * <p>In Android 8.0 ({@linkplain android.os.Build.VERSION_CODES#O API level 26}) and higher,\n     * this is a global user restriction. If a device owner or profile owner sets this restriction,\n     * the system enforces app verification across all users on the device. Running in earlier\n     * Android versions, this restriction affects only the profile that sets it.\n     *\n     * <p>Key for user restrictions.\n     * <p>Type: Boolean\n     * @see DevicePolicyManager#addUserRestriction(ComponentName, String)\n     * @see DevicePolicyManager#clearUserRestriction(ComponentName, String)\n     * @see #getUserRestrictions()\n     ",
    "links" : [ ]
  }, {
    "name" : "DISALLOW_CONFIG_CELL_BROADCASTS",
    "type" : "String",
    "comment" : "\n     * Specifies if a user is disallowed from configuring cell broadcasts.\n     *\n     * <p>This restriction can only be set by a device owner, a profile owner on the primary\n     * user or a profile owner of an organization-owned managed profile on the parent profile.\n     * When it is set by a device owner, it applies globally. When it is set by a profile owner\n     * on the primary user or by a profile owner of an organization-owned managed profile on\n     * the parent profile, it disables the primary user from configuring cell broadcasts.\n     *\n     * <p>The default value is <code>false</code>.\n     *\n     * <p>This restriction has no effect on secondary users and managed profiles since only the\n     * primary user can configure cell broadcasts.\n     *\n     * <p>Key for user restrictions.\n     * <p>Type: Boolean\n     * @see DevicePolicyManager#addUserRestriction(ComponentName, String)\n     * @see DevicePolicyManager#clearUserRestriction(ComponentName, String)\n     * @see #getUserRestrictions()\n     ",
    "links" : [ ]
  }, {
    "name" : "DISALLOW_CONFIG_MOBILE_NETWORKS",
    "type" : "String",
    "comment" : "\n     * Specifies if a user is disallowed from configuring mobile networks.\n     *\n     * <p>This restriction can only be set by a device owner, a profile owner on the primary\n     * user or a profile owner of an organization-owned managed profile on the parent profile.\n     * When it is set by a device owner, it applies globally. When it is set by a profile owner\n     * on the primary user or by a profile owner of an organization-owned managed profile on\n     * the parent profile, it disables the primary user from configuring mobile networks.\n     *\n     * <p>The default value is <code>false</code>.\n     *\n     * <p>This restriction has no effect on secondary users and managed profiles since only the\n     * primary user can configure mobile networks.\n     *\n     * <p>Key for user restrictions.\n     * <p>Type: Boolean\n     * @see DevicePolicyManager#addUserRestriction(ComponentName, String)\n     * @see DevicePolicyManager#clearUserRestriction(ComponentName, String)\n     * @see #getUserRestrictions()\n     ",
    "links" : [ ]
  }, {
    "name" : "DISALLOW_APPS_CONTROL",
    "type" : "String",
    "comment" : "\n     * Specifies if a user is disallowed from modifying\n     * applications in Settings or launchers. The following actions will not be allowed when this\n     * restriction is enabled:\n     * <li>uninstalling apps</li>\n     * <li>disabling apps</li>\n     * <li>clearing app caches</li>\n     * <li>clearing app data</li>\n     * <li>force stopping apps</li>\n     * <li>clearing app defaults</li>\n     * <p>\n     * The default value is <code>false</code>.\n     *\n     * <p><strong>Note:</strong> The user will still be able to perform those actions via other\n     * means (such as adb). Third party apps will also be able to uninstall apps via the\n     * {@link android.content.pm.PackageInstaller}. {@link #DISALLOW_UNINSTALL_APPS} or\n     * {@link DevicePolicyManager#setUninstallBlocked(ComponentName, String, boolean)} should be\n     * used to prevent the user from uninstalling apps completely, and\n     * {@link DevicePolicyManager#addPersistentPreferredActivity(ComponentName, IntentFilter, ComponentName)}\n     * to add a default intent handler for a given intent filter.\n     *\n     * <p>Key for user restrictions.\n     * <p>Type: Boolean\n     * @see DevicePolicyManager#addUserRestriction(ComponentName, String)\n     * @see DevicePolicyManager#clearUserRestriction(ComponentName, String)\n     * @see #getUserRestrictions()\n     ",
    "links" : [ "android.content.pm.PackageInstaller", "#DISALLOW_UNINSTALL_APPS", "DevicePolicyManager#setUninstallBlocked", "DevicePolicyManager#addPersistentPreferredActivity" ]
  }, {
    "name" : "DISALLOW_MOUNT_PHYSICAL_MEDIA",
    "type" : "String",
    "comment" : "\n     * Specifies if a user is disallowed from mounting physical external media.\n     *\n     * <p>This restriction can only be set by a device owner, a profile owner on the primary\n     * user or a profile owner of an organization-owned managed profile on the parent profile.\n     * When it is set by a device owner, it applies globally. When it is set by a profile owner\n     * on the primary user or by a profile owner of an organization-owned managed profile on\n     * the parent profile, it disables the primary user from mounting physical external media.\n     *\n     * <p>The default value is <code>false</code>.\n     *\n     * <p>Key for user restrictions.\n     * <p>Type: Boolean\n     * @see DevicePolicyManager#addUserRestriction(ComponentName, String)\n     * @see DevicePolicyManager#clearUserRestriction(ComponentName, String)\n     * @see #getUserRestrictions()\n     ",
    "links" : [ ]
  }, {
    "name" : "DISALLOW_UNMUTE_MICROPHONE",
    "type" : "String",
    "comment" : "\n     * Specifies if a user is disallowed from adjusting microphone volume. If set, the microphone\n     * will be muted.\n     *\n     * <p>A device owner and a profile owner can set this restriction, although the restriction has\n     * no effect in a managed profile. When it is set by a device owner, it applies globally. When\n     * it is set by a profile owner on the primary user or by a profile owner of an\n     * organization-owned managed profile on the parent profile, it will disallow the primary user\n     * from adjusting the microphone volume.\n     *\n     * <p>The default value is <code>false</code>.\n     *\n     * <p>Key for user restrictions.\n     * <p>Type: Boolean\n     * @see DevicePolicyManager#addUserRestriction(ComponentName, String)\n     * @see DevicePolicyManager#clearUserRestriction(ComponentName, String)\n     * @see #getUserRestrictions()\n     ",
    "links" : [ ]
  }, {
    "name" : "DISALLOW_ADJUST_VOLUME",
    "type" : "String",
    "comment" : "\n     * Specifies if a user is disallowed from adjusting the master volume. If set, the master volume\n     * will be muted. This can be set by device owners from API 21 and profile owners from API 24.\n     * The default value is <code>false</code>.\n     *\n     * <p>When the restriction is set by profile owners, then it only applies to relevant\n     * profiles.\n     *\n     * <p>This restriction has no effect on managed profiles.\n     * <p>Key for user restrictions.\n     * <p>Type: Boolean\n     * @see DevicePolicyManager#addUserRestriction(ComponentName, String)\n     * @see DevicePolicyManager#clearUserRestriction(ComponentName, String)\n     * @see #getUserRestrictions()\n     ",
    "links" : [ ]
  }, {
    "name" : "DISALLOW_OUTGOING_CALLS",
    "type" : "String",
    "comment" : "\n     * Specifies that the user is not allowed to make outgoing phone calls. Emergency calls are\n     * still permitted.\n     *\n     * <p>A device owner and a profile owner can set this restriction, although the restriction has\n     * no effect in a managed profile. When it is set by a device owner, a profile owner on the\n     * primary user or by a profile owner of an organization-owned managed profile on the parent\n     * profile, it disallows the primary user from making outgoing phone calls.\n     *\n     * <p>The default value is <code>false</code>.\n     *\n     * <p>Key for user restrictions.\n     * <p>Type: Boolean\n     * @see DevicePolicyManager#addUserRestriction(ComponentName, String)\n     * @see DevicePolicyManager#clearUserRestriction(ComponentName, String)\n     * @see #getUserRestrictions()\n     ",
    "links" : [ ]
  }, {
    "name" : "DISALLOW_SMS",
    "type" : "String",
    "comment" : "\n     * Specifies that the user is not allowed to send or receive SMS messages.\n     *\n     * <p>This restriction can only be set by a device owner, a profile owner on the primary\n     * user or a profile owner of an organization-owned managed profile on the parent profile.\n     * When it is set by a device owner, it applies globally. When it is set by a profile owner\n     * on the primary user or by a profile owner of an organization-owned managed profile on\n     * the parent profile, it disables the primary user from sending or receiving SMS messages.\n     *\n     * <p>The default value is <code>false</code>.\n     *\n     * <p>Key for user restrictions.\n     * <p>Type: Boolean\n     * @see DevicePolicyManager#addUserRestriction(ComponentName, String)\n     * @see DevicePolicyManager#clearUserRestriction(ComponentName, String)\n     * @see #getUserRestrictions()\n     ",
    "links" : [ ]
  }, {
    "name" : "DISALLOW_FUN",
    "type" : "String",
    "comment" : "\n     * Specifies if the user is not allowed to have fun. In some cases, the\n     * device owner may wish to prevent the user from experiencing amusement or\n     * joy while using the device. The default value is <code>false</code>.\n     *\n     * <p>Key for user restrictions.\n     * <p>Type: Boolean\n     * @see DevicePolicyManager#addUserRestriction(ComponentName, String)\n     * @see DevicePolicyManager#clearUserRestriction(ComponentName, String)\n     * @see #getUserRestrictions()\n     ",
    "links" : [ ]
  }, {
    "name" : "DISALLOW_CREATE_WINDOWS",
    "type" : "String",
    "comment" : "\n     * Specifies that windows besides app windows should not be\n     * created. This will block the creation of the following types of windows.\n     * <li>{@link LayoutParams#TYPE_TOAST}</li>\n     * <li>{@link LayoutParams#TYPE_PHONE}</li>\n     * <li>{@link LayoutParams#TYPE_PRIORITY_PHONE}</li>\n     * <li>{@link LayoutParams#TYPE_SYSTEM_ALERT}</li>\n     * <li>{@link LayoutParams#TYPE_SYSTEM_ERROR}</li>\n     * <li>{@link LayoutParams#TYPE_SYSTEM_OVERLAY}</li>\n     * <li>{@link LayoutParams#TYPE_APPLICATION_OVERLAY}</li>\n     *\n     * <p>This can only be set by device owners and profile owners on the primary user.\n     * The default value is <code>false</code>.\n     *\n     * <p>Key for user restrictions.\n     * <p>Type: Boolean\n     * @see DevicePolicyManager#addUserRestriction(ComponentName, String)\n     * @see DevicePolicyManager#clearUserRestriction(ComponentName, String)\n     * @see #getUserRestrictions()\n     ",
    "links" : [ "LayoutParams#TYPE_TOAST", "LayoutParams#TYPE_PHONE", "LayoutParams#TYPE_PRIORITY_PHONE", "LayoutParams#TYPE_SYSTEM_ALERT", "LayoutParams#TYPE_SYSTEM_ERROR", "LayoutParams#TYPE_SYSTEM_OVERLAY", "LayoutParams#TYPE_APPLICATION_OVERLAY" ]
  }, {
    "name" : "DISALLOW_SYSTEM_ERROR_DIALOGS",
    "type" : "String",
    "comment" : "\n     * Specifies that system error dialogs for crashed or unresponsive apps should not be shown.\n     * In this case, the system will force-stop the app as if the user chooses the \"close app\"\n     * option on the UI. A feedback report isn't collected as there is no way for the user to\n     * provide explicit consent. The default value is <code>false</code>.\n     *\n     * <p>When this user restriction is set by device owners, it's applied to all users. When set by\n     * the profile owner of the primary user or a secondary user, the restriction affects only the\n     * calling user. This user restriction has no effect on managed profiles.\n     *\n     * <p>Key for user restrictions.\n     * <p>Type: Boolean\n     * @see DevicePolicyManager#addUserRestriction(ComponentName, String)\n     * @see DevicePolicyManager#clearUserRestriction(ComponentName, String)\n     * @see #getUserRestrictions()\n     ",
    "links" : [ ]
  }, {
    "name" : "DISALLOW_CROSS_PROFILE_COPY_PASTE",
    "type" : "String",
    "comment" : "\n     * Specifies if the clipboard contents can be exported by pasting the data into other users or\n     * profiles. This restriction doesn't prevent import, such as someone pasting clipboard data\n     * from other profiles or users. The default value is {@code false}.\n     *\n     * <p><strong>Note</strong>: Because it's possible to extract data from screenshots using\n     * optical character recognition (OCR), we strongly recommend combining this user restriction\n     * with {@link DevicePolicyManager#setScreenCaptureDisabled(ComponentName, boolean)}.\n     *\n     * <p>Key for user restrictions.\n     * <p>Type: Boolean\n     * @see DevicePolicyManager#addUserRestriction(ComponentName, String)\n     * @see DevicePolicyManager#clearUserRestriction(ComponentName, String)\n     * @see #getUserRestrictions()\n     ",
    "links" : [ "DevicePolicyManager#setScreenCaptureDisabled" ]
  }, {
    "name" : "DISALLOW_OUTGOING_BEAM",
    "type" : "String",
    "comment" : "\n     * Specifies if the user is not allowed to use NFC to beam out data from apps.\n     * The default value is <code>false</code>.\n     *\n     * <p>Key for user restrictions.\n     * <p>Type: Boolean\n     * @see DevicePolicyManager#addUserRestriction(ComponentName, String)\n     * @see DevicePolicyManager#clearUserRestriction(ComponentName, String)\n     * @see #getUserRestrictions()\n     ",
    "links" : [ ]
  }, {
    "name" : "DISALLOW_WALLPAPER",
    "type" : "String",
    "comment" : "\n     * Hidden user restriction to disallow access to wallpaper manager APIs. This restriction\n     * generally means that wallpapers are not supported for the particular user. This user\n     * restriction is always set for managed profiles, because such profiles don't have wallpapers.\n     * @hide\n     * @see #DISALLOW_SET_WALLPAPER\n     * @see DevicePolicyManager#addUserRestriction(ComponentName, String)\n     * @see DevicePolicyManager#clearUserRestriction(ComponentName, String)\n     * @see #getUserRestrictions()\n     ",
    "links" : [ ]
  }, {
    "name" : "DISALLOW_SET_WALLPAPER",
    "type" : "String",
    "comment" : "\n     * User restriction to disallow setting a wallpaper. Profile owner and device owner\n     * are able to set wallpaper regardless of this restriction.\n     * The default value is <code>false</code>.\n     *\n     * <p>Key for user restrictions.\n     * <p>Type: Boolean\n     * @see DevicePolicyManager#addUserRestriction(ComponentName, String)\n     * @see DevicePolicyManager#clearUserRestriction(ComponentName, String)\n     * @see #getUserRestrictions()\n     ",
    "links" : [ ]
  }, {
    "name" : "DISALLOW_SAFE_BOOT",
    "type" : "String",
    "comment" : "\n     * Specifies if the user is not allowed to reboot the device into safe boot mode.\n     *\n     * <p>This restriction can only be set by a device owner, a profile owner on the primary\n     * user or a profile owner of an organization-owned managed profile on the parent profile.\n     * When it is set by a device owner, it applies globally. When it is set by a profile owner\n     * on the primary user or by a profile owner of an organization-owned managed profile on\n     * the parent profile, it disables the primary user from rebooting the device into safe\n     * boot mode.\n     *\n     * <p>The default value is <code>false</code>.\n     *\n     * <p>Key for user restrictions.\n     * <p>Type: Boolean\n     * @see DevicePolicyManager#addUserRestriction(ComponentName, String)\n     * @see DevicePolicyManager#clearUserRestriction(ComponentName, String)\n     * @see #getUserRestrictions()\n     ",
    "links" : [ ]
  }, {
    "name" : "DISALLOW_RECORD_AUDIO",
    "type" : "String",
    "comment" : "\n     * Specifies if a user is not allowed to record audio. This restriction is always enabled for\n     * background users. The default value is <code>false</code>.\n     *\n     * @see DevicePolicyManager#addUserRestriction(ComponentName, String)\n     * @see DevicePolicyManager#clearUserRestriction(ComponentName, String)\n     * @see #getUserRestrictions()\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "DISALLOW_RUN_IN_BACKGROUND",
    "type" : "String",
    "comment" : "\n     * Specifies if a user is not allowed to run in the background and should be stopped during\n     * user switch. The default value is <code>false</code>.\n     *\n     * <p>This restriction can be set by device owners and profile owners.\n     *\n     * @see DevicePolicyManager#addUserRestriction(ComponentName, String)\n     * @see DevicePolicyManager#clearUserRestriction(ComponentName, String)\n     * @see #getUserRestrictions()\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "DISALLOW_CAMERA",
    "type" : "String",
    "comment" : "\n     * Specifies if a user is not allowed to use the camera.\n     *\n     * <p>A device owner and a profile owner can set this restriction. When it is set by a\n     * device owner, it applies globally - i.e., it disables the use of camera on the entire device\n     * and all users are affected. When it is set by a profile owner on the primary user or by a\n     * profile owner of an organization-owned managed profile on the parent profile, it disables\n     * the primary user from using camera.\n     *\n     * <p>The default value is <code>false</code>.\n     *\n     * @see DevicePolicyManager#addUserRestriction(ComponentName, String)\n     * @see DevicePolicyManager#clearUserRestriction(ComponentName, String)\n     * @see #getUserRestrictions()\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "DISALLOW_UNMUTE_DEVICE",
    "type" : "String",
    "comment" : "\n     * Specifies if a user is not allowed to unmute the device's master volume.\n     *\n     * @see DevicePolicyManager#setMasterVolumeMuted(ComponentName, boolean)\n     * @see DevicePolicyManager#clearUserRestriction(ComponentName, String)\n     * @see #getUserRestrictions()\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "DISALLOW_DATA_ROAMING",
    "type" : "String",
    "comment" : "\n     * Specifies if a user is not allowed to use cellular data when roaming.\n     *\n     * <p>This restriction can only be set by a device owner, a profile owner on the primary\n     * user or a profile owner of an organization-owned managed profile on the parent profile.\n     * When it is set by a device owner, it applies globally. When it is set by a profile owner\n     * on the primary user or by a profile owner of an organization-owned managed profile on\n     * the parent profile, it disables the primary user from using cellular data when roaming.\n     *\n     * <p>The default value is <code>false</code>.\n     *\n     * @see DevicePolicyManager#addUserRestriction(ComponentName, String)\n     * @see DevicePolicyManager#clearUserRestriction(ComponentName, String)\n     * @see #getUserRestrictions()\n     ",
    "links" : [ ]
  }, {
    "name" : "DISALLOW_SET_USER_ICON",
    "type" : "String",
    "comment" : "\n     * Specifies if a user is not allowed to change their icon. Device owner and profile owner\n     * can set this restriction. When it is set by device owner, only the target user will be\n     * affected. The default value is <code>false</code>.\n     *\n     * <p>Key for user restrictions.\n     * <p>Type: Boolean\n     * @see DevicePolicyManager#addUserRestriction(ComponentName, String)\n     * @see DevicePolicyManager#clearUserRestriction(ComponentName, String)\n     * @see #getUserRestrictions()\n     ",
    "links" : [ ]
  }, {
    "name" : "DISALLOW_OEM_UNLOCK",
    "type" : "String",
    "comment" : "\n     * Specifies if a user is not allowed to enable the oem unlock setting. The default value is\n     * <code>false</code>. Setting this restriction has no effect if the bootloader is already\n     * unlocked.\n     *\n     * <p>Not for use by third-party applications.\n     *\n     * @see DevicePolicyManager#addUserRestriction(ComponentName, String)\n     * @see DevicePolicyManager#clearUserRestriction(ComponentName, String)\n     * @see #getUserRestrictions()\n     * @deprecated use {@link OemLockManager#setOemUnlockAllowedByCarrier(boolean, byte[])} instead.\n     * @hide\n     ",
    "links" : [ "OemLockManager#setOemUnlockAllowedByCarrier" ]
  }, {
    "name" : "DISALLOW_UNIFIED_PASSWORD",
    "type" : "String",
    "comment" : "\n     * Specifies that the managed profile is not allowed to have unified lock screen challenge with\n     * the primary user.\n     *\n     * <p><strong>Note:</strong> Setting this restriction alone doesn't automatically set a\n     * separate challenge. Profile owner can ask the user to set a new password using\n     * {@link DevicePolicyManager#ACTION_SET_NEW_PASSWORD} and verify it using\n     * {@link DevicePolicyManager#isUsingUnifiedPassword(ComponentName)}.\n     *\n     * <p>Can be set by profile owners. It only has effect on managed profiles when set by managed\n     * profile owner. Has no effect on non-managed profiles or users.\n     * <p>Key for user restrictions.\n     * <p>Type: Boolean\n     * @see DevicePolicyManager#addUserRestriction(ComponentName, String)\n     * @see DevicePolicyManager#clearUserRestriction(ComponentName, String)\n     * @see #getUserRestrictions()\n     ",
    "links" : [ "DevicePolicyManager#ACTION_SET_NEW_PASSWORD", "DevicePolicyManager#isUsingUnifiedPassword" ]
  }, {
    "name" : "ALLOW_PARENT_PROFILE_APP_LINKING",
    "type" : "String",
    "comment" : "\n     * Allows apps in the parent profile to handle web links from the managed profile.\n     *\n     * This user restriction has an effect only in a managed profile.\n     * If set:\n     * Intent filters of activities in the parent profile with action\n     * {@link android.content.Intent#ACTION_VIEW},\n     * category {@link android.content.Intent#CATEGORY_BROWSABLE}, scheme http or https, and which\n     * define a host can handle intents from the managed profile.\n     * The default value is <code>false</code>.\n     *\n     * <p>Key for user restrictions.\n     * <p>Type: Boolean\n     * @see DevicePolicyManager#addUserRestriction(ComponentName, String)\n     * @see DevicePolicyManager#clearUserRestriction(ComponentName, String)\n     * @see #getUserRestrictions()\n     ",
    "links" : [ "android.content.Intent#ACTION_VIEW", "android.content.Intent#CATEGORY_BROWSABLE" ]
  }, {
    "name" : "DISALLOW_AUTOFILL",
    "type" : "String",
    "comment" : "\n     * Specifies if a user is not allowed to use Autofill Services.\n     *\n     * <p>Device owner and profile owner can set this restriction. When it is set by device owner,\n     * only the target user will be affected.\n     *\n     * <p>The default value is <code>false</code>.\n     *\n     * @see DevicePolicyManager#addUserRestriction(ComponentName, String)\n     * @see DevicePolicyManager#clearUserRestriction(ComponentName, String)\n     * @see #getUserRestrictions()\n     ",
    "links" : [ ]
  }, {
    "name" : "DISALLOW_CONTENT_CAPTURE",
    "type" : "String",
    "comment" : "\n     * Specifies if the contents of a user's screen is not allowed to be captured for artificial\n     * intelligence purposes.\n     *\n     * <p>A device owner and a profile owner can set this restriction. When it is set by a device\n     * owner, a profile owner on the primary user or by a profile owner of an organization-owned\n     * managed profile on the parent profile, it disables the primary user's screen from being\n     * captured for artificial intelligence purposes.\n     *\n     * <p>The default value is <code>false</code>.\n     *\n     * @see DevicePolicyManager#addUserRestriction(ComponentName, String)\n     * @see DevicePolicyManager#clearUserRestriction(ComponentName, String)\n     * @see #getUserRestrictions()\n     ",
    "links" : [ ]
  }, {
    "name" : "DISALLOW_CONTENT_SUGGESTIONS",
    "type" : "String",
    "comment" : "\n     * Specifies if the current user is able to receive content suggestions for selections based on\n     * the contents of their screen.\n     *\n     * <p>A device owner and a profile owner can set this restriction. When it is set by a device\n     * owner, a profile owner on the primary user or by a profile owner of an organization-owned\n     * managed profile on the parent profile, it disables the primary user from receiving content\n     * suggestions for selections based on the contents of their screen.\n     *\n     * <p>The default value is <code>false</code>.\n     *\n     * @see DevicePolicyManager#addUserRestriction(ComponentName, String)\n     * @see DevicePolicyManager#clearUserRestriction(ComponentName, String)\n     * @see #getUserRestrictions()\n     ",
    "links" : [ ]
  }, {
    "name" : "DISALLOW_USER_SWITCH",
    "type" : "String",
    "comment" : "\n     * Specifies if user switching is blocked on the current user.\n     *\n     * <p> This restriction can only be set by the device owner, it will be applied to all users.\n     * Device owner can still switch user via\n     * {@link DevicePolicyManager#switchUser(ComponentName, UserHandle)} when this restriction is\n     * set.\n     *\n     * <p>The default value is <code>false</code>.\n     *\n     * @see DevicePolicyManager#addUserRestriction(ComponentName, String)\n     * @see DevicePolicyManager#clearUserRestriction(ComponentName, String)\n     * @see #getUserRestrictions()\n     ",
    "links" : [ "DevicePolicyManager#switchUser" ]
  }, {
    "name" : "DISALLOW_SHARE_INTO_MANAGED_PROFILE",
    "type" : "String",
    "comment" : "\n     * Specifies whether the user can share file / picture / data from the primary user into the\n     * managed profile, either by sending them from the primary side, or by picking up data within\n     * an app in the managed profile.\n     * <p>\n     * When a managed profile is created, the system allows the user to send data from the primary\n     * side to the profile by setting up certain default cross profile intent filters. If\n     * this is undesired, this restriction can be set to disallow it. Note that this restriction\n     * will not block any sharing allowed by explicit\n     * {@link DevicePolicyManager#addCrossProfileIntentFilter} calls by the profile owner.\n     * <p>\n     * This restriction is only meaningful when set by profile owner. When it is set by device\n     * owner, it does not have any effect.\n     * <p>\n     * The default value is <code>false</code>.\n     *\n     * @see DevicePolicyManager#addUserRestriction(ComponentName, String)\n     * @see DevicePolicyManager#clearUserRestriction(ComponentName, String)\n     * @see #getUserRestrictions()\n     ",
    "links" : [ "DevicePolicyManager#addCrossProfileIntentFilter" ]
  }, {
    "name" : "DISALLOW_PRINTING",
    "type" : "String",
    "comment" : "\n     * Specifies whether the user is allowed to print.\n     *\n     * This restriction can be set by device or profile owner.\n     *\n     * The default value is {@code false}.\n     *\n     * @see DevicePolicyManager#addUserRestriction(ComponentName, String)\n     * @see DevicePolicyManager#clearUserRestriction(ComponentName, String)\n     * @see #getUserRestrictions()\n     ",
    "links" : [ ]
  }, {
    "name" : "DISALLOW_CONFIG_PRIVATE_DNS",
    "type" : "String",
    "comment" : "\n     * Specifies whether the user is allowed to modify private DNS settings.\n     *\n     * <p>This restriction can only be set by a device owner or a profile owner of an\n     * organization-owned managed profile on the parent profile. When it is set by either of these\n     * owners, it applies globally.\n     *\n     * <p>The default value is <code>false</code>.\n     *\n     * <p>Key for user restrictions.\n     * <p>Type: Boolean\n     * @see DevicePolicyManager#addUserRestriction(ComponentName, String)\n     * @see DevicePolicyManager#clearUserRestriction(ComponentName, String)\n     * @see #getUserRestrictions()\n     ",
    "links" : [ ]
  }, {
    "name" : "KEY_RESTRICTIONS_PENDING",
    "type" : "String",
    "comment" : "\n     * Application restriction key that is used to indicate the pending arrival\n     * of real restrictions for the app.\n     *\n     * <p>\n     * Applications that support restrictions should check for the presence of this key.\n     * A <code>true</code> value indicates that restrictions may be applied in the near\n     * future but are not available yet. It is the responsibility of any\n     * management application that sets this flag to update it when the final\n     * restrictions are enforced.\n     *\n     * <p>Key for application restrictions.\n     * <p>Type: Boolean\n     * @see android.app.admin.DevicePolicyManager#setApplicationRestrictions(\n     *      android.content.ComponentName, String, Bundle)\n     * @see android.app.admin.DevicePolicyManager#getApplicationRestrictions(\n     *      android.content.ComponentName, String)\n     ",
    "links" : [ ]
  }, {
    "name" : "ACTION_CREATE_USER",
    "type" : "String",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "EXTRA_USER_NAME",
    "type" : "String",
    "comment" : "\n     * Extra containing a name for the user being created. Optional parameter passed to\n     * ACTION_CREATE_USER activity.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "EXTRA_USER_ACCOUNT_NAME",
    "type" : "String",
    "comment" : "\n     * Extra containing account name for the user being created. Optional parameter passed to\n     * ACTION_CREATE_USER activity.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "EXTRA_USER_ACCOUNT_TYPE",
    "type" : "String",
    "comment" : "\n     * Extra containing account type for the user being created. Optional parameter passed to\n     * ACTION_CREATE_USER activity.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "EXTRA_USER_ACCOUNT_OPTIONS",
    "type" : "String",
    "comment" : "\n     * Extra containing account-specific data for the user being created. Optional parameter passed\n     * to ACTION_CREATE_USER activity.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "PIN_VERIFICATION_FAILED_INCORRECT",
    "type" : "int",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "PIN_VERIFICATION_FAILED_NOT_SET",
    "type" : "int",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "PIN_VERIFICATION_SUCCESS",
    "type" : "int",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "ACTION_USER_RESTRICTIONS_CHANGED",
    "type" : "String",
    "comment" : "\n     * Sent when user restrictions have changed.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "USER_CREATION_FAILED_NOT_PERMITTED",
    "type" : "int",
    "comment" : "\n     * Error result indicating that this user is not allowed to add other users on this device.\n     * This is a result code returned from the activity created by the intent\n     * {@link #createUserCreationIntent(String, String, String, PersistableBundle)}.\n     ",
    "links" : [ "#createUserCreationIntent" ]
  }, {
    "name" : "USER_CREATION_FAILED_NO_MORE_USERS",
    "type" : "int",
    "comment" : "\n     * Error result indicating that no more users can be created on this device.\n     * This is a result code returned from the activity created by the intent\n     * {@link #createUserCreationIntent(String, String, String, PersistableBundle)}.\n     ",
    "links" : [ "#createUserCreationIntent" ]
  }, {
    "name" : "SWITCHABILITY_STATUS_OK",
    "type" : "int",
    "comment" : "\n     * Indicates that users are switchable.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "SWITCHABILITY_STATUS_USER_IN_CALL",
    "type" : "int",
    "comment" : "\n     * Indicated that the user is in a phone call.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "SWITCHABILITY_STATUS_USER_SWITCH_DISALLOWED",
    "type" : "int",
    "comment" : "\n     * Indicates that user switching is disallowed ({@link #DISALLOW_USER_SWITCH} is set).\n     * @hide\n     ",
    "links" : [ "#DISALLOW_USER_SWITCH" ]
  }, {
    "name" : "SWITCHABILITY_STATUS_SYSTEM_USER_LOCKED",
    "type" : "int",
    "comment" : "\n     * Indicates that the system user is locked and user switching is not allowed.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "USER_OPERATION_SUCCESS",
    "type" : "int",
    "comment" : "\n     * Indicates user operation is successful.\n     ",
    "links" : [ ]
  }, {
    "name" : "USER_OPERATION_ERROR_UNKNOWN",
    "type" : "int",
    "comment" : "\n     * Indicates user operation failed for unknown reason.\n     ",
    "links" : [ ]
  }, {
    "name" : "USER_OPERATION_ERROR_MANAGED_PROFILE",
    "type" : "int",
    "comment" : "\n     * Indicates user operation failed because target user is a managed profile.\n     ",
    "links" : [ ]
  }, {
    "name" : "USER_OPERATION_ERROR_MAX_RUNNING_USERS",
    "type" : "int",
    "comment" : "\n     * Indicates user operation failed because maximum running user limit has been reached.\n     ",
    "links" : [ ]
  }, {
    "name" : "USER_OPERATION_ERROR_CURRENT_USER",
    "type" : "int",
    "comment" : "\n     * Indicates user operation failed because the target user is in the foreground.\n     ",
    "links" : [ ]
  }, {
    "name" : "USER_OPERATION_ERROR_LOW_STORAGE",
    "type" : "int",
    "comment" : "\n     * Indicates user operation failed because device has low data storage.\n     ",
    "links" : [ ]
  }, {
    "name" : "USER_OPERATION_ERROR_MAX_USERS",
    "type" : "int",
    "comment" : "\n     * Indicates user operation failed because maximum user limit has been reached.\n     ",
    "links" : [ ]
  }, {
    "name" : "CACHE_KEY_IS_USER_UNLOCKED_PROPERTY",
    "type" : "String",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mIsUserUnlockedCache",
    "type" : "PropertyInvalidatedCache<Integer, Boolean>",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mIsUserUnlockingOrUnlockedCache",
    "type" : "PropertyInvalidatedCache<Integer, Boolean>",
    "comment" : " Uses IS_USER_UNLOCKED_PROPERTY for invalidation as the APIs have the same dependencies.",
    "links" : [ ]
  } ],
  "methods" : [ {
    "name" : "private T returnNullOrThrowUserOperationException(ServiceSpecificException exception, boolean throwInsteadOfNull) throws UserOperationException",
    "returnType" : "T",
    "comment" : "\n     * Converts the ServiceSpecificException into a UserOperationException or throws null;\n     *\n     * @param exception exception to convert.\n     * @param throwInsteadOfNull if an exception should be thrown or null returned.\n     * @return null if chosen not to throw exception.\n     * @throws UserOperationException\n     ",
    "links" : [ ]
  }, {
    "name" : "public static UserManager get(Context context)",
    "returnType" : "UserManager",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "public static boolean supportsMultipleUsers()",
    "returnType" : "boolean",
    "comment" : "\n     * Returns whether this device supports multiple users with their own login and customizable\n     * space.\n     * @return whether the device supports multiple users.\n     ",
    "links" : [ ]
  }, {
    "name" : "public static boolean isSplitSystemUser()",
    "returnType" : "boolean",
    "comment" : "\n     * @hide\n     * @return Whether the device is running with split system user. It means the system user and\n     * primary user are two separate users. Previously system user and primary user are combined as\n     * a single owner user.  see @link {android.os.UserHandle#USER_OWNER}\n     ",
    "links" : [ ]
  }, {
    "name" : "public static boolean isGuestUserEphemeral()",
    "returnType" : "boolean",
    "comment" : "\n     * @return Whether guest user is always ephemeral\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public static boolean isHeadlessSystemUserMode()",
    "returnType" : "boolean",
    "comment" : "\n     * @hide\n     * @return Whether the device is running in a headless system user mode. It means the headless\n     * user (system user) runs system services and system UI, but is not associated with any real\n     * person. Secondary users can be created to be associated with real person.\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean canSwitchUsers()",
    "returnType" : "boolean",
    "comment" : "\n     * @deprecated use {@link #getUserSwitchability()} instead.\n     *\n     * @removed\n     * @hide\n     ",
    "links" : [ "#getUserSwitchability" ]
  }, {
    "name" : "public int getUserSwitchability()",
    "returnType" : "int",
    "comment" : "\n     * Returns whether switching users is currently allowed for the user this process is running\n     * under.\n     * <p>\n     * Switching users is not allowed in the following cases:\n     * <li>the user is in a phone call</li>\n     * <li>{@link #DISALLOW_USER_SWITCH} is set</li>\n     * <li>system user hasn't been unlocked yet</li>\n     *\n     * @return A {@link UserSwitchabilityResult} flag indicating if the user is switchable.\n     * @hide\n     ",
    "links" : [ "#DISALLOW_USER_SWITCH", "UserSwitchabilityResult" ]
  }, {
    "name" : "public int getUserSwitchability(UserHandle userHandle)",
    "returnType" : "int",
    "comment" : "\n     * Returns whether switching users is currently allowed for the provided user.\n     * <p>\n     * Switching users is not allowed in the following cases:\n     * <li>the user is in a phone call</li>\n     * <li>{@link #DISALLOW_USER_SWITCH} is set</li>\n     * <li>system user hasn't been unlocked yet</li>\n     *\n     * @return A {@link UserSwitchabilityResult} flag indicating if the user is switchable.\n     * @hide\n     ",
    "links" : [ "#DISALLOW_USER_SWITCH", "UserSwitchabilityResult" ]
  }, {
    "name" : "public int getUserHandle()",
    "returnType" : "int",
    "comment" : "\n     * Returns the user handle for the user that this process is running under.\n     *\n     * @return the user handle of this process.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public String getUserName()",
    "returnType" : "String",
    "comment" : "\n     * Returns the user name of the context user. This call is only available to applications on\n     * the system image; it requires the {@code android.permission.MANAGE_USERS} or {@code\n     * android.permission.GET_ACCOUNTS_PRIVILEGED} permissions.\n     *\n     * @return the user name\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean isUserNameSet()",
    "returnType" : "boolean",
    "comment" : "\n     * Returns whether user name has been set.\n     * <p>This method can be used to check that the value returned by {@link #getUserName()} was\n     * set by the user and is not a placeholder string provided by the system.\n     * @hide\n     ",
    "links" : [ "#getUserName" ]
  }, {
    "name" : "public boolean isUserAGoat()",
    "returnType" : "boolean",
    "comment" : "\n     * Used to determine whether the user making this call is subject to\n     * teleportations.\n     *\n     * <p>As of {@link android.os.Build.VERSION_CODES#LOLLIPOP}, this method can\n     * now automatically identify goats using advanced goat recognition technology.</p>\n     *\n     * <p>As of {@link android.os.Build.VERSION_CODES#R}, this method always returns\n     * {@code false} in order to protect goat privacy.</p>\n     *\n     * @return Returns whether the user making this call is a goat.\n     ",
    "links" : [ "android.os.Build.VERSION_CODES#LOLLIPOP", "android.os.Build.VERSION_CODES#R" ]
  }, {
    "name" : "public boolean isPrimaryUser()",
    "returnType" : "boolean",
    "comment" : "\n     * Used to check if this process is running under the primary user. The primary user\n     * is the first human user on a device. This is not supported in headless system user mode.\n     *\n     * @return whether this process is running under the primary user.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean isSystemUser()",
    "returnType" : "boolean",
    "comment" : "\n     * Used to check if this process is running under the system user. The system user\n     * is the initial user that is implicitly created on first boot and hosts most of the\n     * system services.\n     *\n     * @return whether this process is running under the system user.\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean isAdminUser()",
    "returnType" : "boolean",
    "comment" : "\n     * Used to check if this process is running as an admin user. An admin user is allowed to\n     * modify or configure certain settings that aren't available to non-admin users,\n     * create and delete additional users, etc. There can be more than one admin users.\n     *\n     * @return whether this process is running under an admin user.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean isUserAdmin(@UserIdInt int userId)",
    "returnType" : "boolean",
    "comment" : "\n     * @hide\n     * Returns whether the provided user is an admin user. There can be more than one admin\n     * user.\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean isUserOfType(@NonNull String userType)",
    "returnType" : "boolean",
    "comment" : "\n     * Returns whether the context user is of the given user type.\n     *\n     * @param userType the name of the user's user type, e.g.\n     *                 {@link UserManager#USER_TYPE_PROFILE_MANAGED}.\n     * @return true if the user is of the given user type.\n     * @hide\n     ",
    "links" : [ "UserManager#USER_TYPE_PROFILE_MANAGED" ]
  }, {
    "name" : "public static boolean isUserTypeManagedProfile(String userType)",
    "returnType" : "boolean",
    "comment" : "\n     * Returns whether the user type is a\n     * {@link UserManager#USER_TYPE_PROFILE_MANAGED managed profile}.\n     * @hide\n     ",
    "links" : [ "UserManager#USER_TYPE_PROFILE_MANAGED" ]
  }, {
    "name" : "public static boolean isUserTypeGuest(String userType)",
    "returnType" : "boolean",
    "comment" : "\n     * Returns whether the user type is a {@link UserManager#USER_TYPE_FULL_GUEST guest user}.\n     * @hide\n     ",
    "links" : [ "UserManager#USER_TYPE_FULL_GUEST" ]
  }, {
    "name" : "public static boolean isUserTypeRestricted(String userType)",
    "returnType" : "boolean",
    "comment" : "\n     * Returns whether the user type is a\n     * {@link UserManager#USER_TYPE_FULL_RESTRICTED restricted user}.\n     * @hide\n     ",
    "links" : [ "UserManager#USER_TYPE_FULL_RESTRICTED" ]
  }, {
    "name" : "public static boolean isUserTypeDemo(String userType)",
    "returnType" : "boolean",
    "comment" : "\n     * Returns whether the user type is a {@link UserManager#USER_TYPE_FULL_DEMO demo user}.\n     * @hide\n     ",
    "links" : [ "UserManager#USER_TYPE_FULL_DEMO" ]
  }, {
    "name" : "public static int getUserTypeForStatsd(@NonNull String userType)",
    "returnType" : "int",
    "comment" : "\n     * Returns the enum defined in the statsd UserLifecycleJourneyReported atom corresponding to the\n     * user type.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean isLinkedUser()",
    "returnType" : "boolean",
    "comment" : "\n     * @hide\n     * @deprecated Use {@link #isRestrictedProfile()}\n     ",
    "links" : [ "#isRestrictedProfile" ]
  }, {
    "name" : "public boolean isRestrictedProfile()",
    "returnType" : "boolean",
    "comment" : "\n     * Used to check if this process is running under a restricted profile. Restricted profiles\n     * may have a reduced number of available apps, app restrictions, and account restrictions.\n     *\n     * @return whether this process is running under a restricted profile.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean isRestrictedProfile(@NonNull UserHandle user)",
    "returnType" : "boolean",
    "comment" : "\n     * Check if a user is a restricted profile. Restricted profiles may have a reduced number of\n     * available apps, app restrictions, and account restrictions.\n     *\n     * @param user the user to check\n     * @return whether the user is a restricted profile.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean canHaveRestrictedProfile(@UserIdInt int userId)",
    "returnType" : "boolean",
    "comment" : "\n     * Checks if specified user can have restricted profile.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean hasRestrictedProfiles()",
    "returnType" : "boolean",
    "comment" : "\n     * Returns whether the calling user has at least one restricted profile associated with it.\n     * @return\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean isGuestUser(@UserIdInt int userId)",
    "returnType" : "boolean",
    "comment" : "\n     * Checks if a user is a guest user.\n     * @return whether user is a guest user.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean isGuestUser()",
    "returnType" : "boolean",
    "comment" : "\n     * Used to check if this process is running under a guest user. A guest user may be transient.\n     *\n     * @return whether this process is running under a guest user.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean isDemoUser()",
    "returnType" : "boolean",
    "comment" : "\n     * Checks if the calling app is running in a demo user. When running in a demo user,\n     * apps can be more helpful to the user, or explain their features in more detail.\n     *\n     * @return whether the caller is a demo user.\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean isProfile()",
    "returnType" : "boolean",
    "comment" : "\n     * Checks if the calling context user is running in a profile.\n     *\n     * Requires {@link android.Manifest.permission#MANAGE_USERS} or\n     * {@link android.Manifest.permission#INTERACT_ACROSS_USERS} permission, otherwise the\n     * caller must be in the same profile group of specified user.\n     *\n     * @return whether the caller is in a profile.\n     * @hide\n     ",
    "links" : [ "android.Manifest.permission#MANAGE_USERS", "android.Manifest.permission#INTERACT_ACROSS_USERS" ]
  }, {
    "name" : "private boolean isProfile(@UserIdInt int userId)",
    "returnType" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public boolean isManagedProfile()",
    "returnType" : "boolean",
    "comment" : "\n     * Checks if the calling app is running in a managed profile.\n     *\n     * @return whether the caller is in a managed profile.\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean isManagedProfile(@UserIdInt int userId)",
    "returnType" : "boolean",
    "comment" : "\n     * Checks if the specified user is a managed profile.\n     * Requires {@link android.Manifest.permission#MANAGE_USERS} or\n     * {@link android.Manifest.permission#INTERACT_ACROSS_USERS} permission, otherwise the caller\n     * must be in the same profile group of specified user.\n     *\n     * @return whether the specified user is a managed profile.\n     * @hide\n     ",
    "links" : [ "android.Manifest.permission#MANAGE_USERS", "android.Manifest.permission#INTERACT_ACROSS_USERS" ]
  }, {
    "name" : "public boolean isEphemeralUser()",
    "returnType" : "boolean",
    "comment" : "\n     * Checks if the calling app is running as an ephemeral user.\n     *\n     * @return whether the caller is an ephemeral user.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean isUserEphemeral(@UserIdInt int userId)",
    "returnType" : "boolean",
    "comment" : "\n     * Returns whether the specified user is ephemeral.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean isUserRunning(UserHandle user)",
    "returnType" : "boolean",
    "comment" : "\n     * Return whether the given user is actively running.  This means that\n     * the user is in the \"started\" state, not \"stopped\" -- it is currently\n     * allowed to run code through scheduled alarms, receiving broadcasts,\n     * etc.  A started user may be either the current foreground user or a\n     * background user; the result here does not distinguish between the two.\n     *\n     * <p>Note prior to Android Nougat MR1 (SDK version <= 24;\n     * {@link android.os.Build.VERSION_CODES#N}, this API required a system permission\n     * in order to check other profile's status.\n     * Since Android Nougat MR1 (SDK version >= 25;\n     * {@link android.os.Build.VERSION_CODES#N_MR1}), the restriction has been relaxed, and now\n     * it'll accept any {@link android.os.UserHandle} within the same profile group as the caller.\n     *\n     * @param user The user to retrieve the running state for.\n     ",
    "links" : [ "android.os.Build.VERSION_CODES#N", "android.os.Build.VERSION_CODES#N_MR1", "android.os.UserHandle" ]
  }, {
    "name" : "public boolean isUserRunning(@UserIdInt int userId)",
    "returnType" : "boolean",
    "comment" : " {@hide} ",
    "links" : [ ]
  }, {
    "name" : "public boolean isUserRunningOrStopping(UserHandle user)",
    "returnType" : "boolean",
    "comment" : "\n     * Return whether the given user is actively running <em>or</em> stopping.\n     * This is like {@link #isUserRunning(UserHandle)}, but will also return\n     * true if the user had been running but is in the process of being stopped\n     * (but is not yet fully stopped, and still running some code).\n     *\n     * <p>Note prior to Android Nougat MR1 (SDK version <= 24;\n     * {@link android.os.Build.VERSION_CODES#N}, this API required a system permission\n     * in order to check other profile's status.\n     * Since Android Nougat MR1 (SDK version >= 25;\n     * {@link android.os.Build.VERSION_CODES#N_MR1}), the restriction has been relaxed, and now\n     * it'll accept any {@link android.os.UserHandle} within the same profile group as the caller.\n     *\n     * @param user The user to retrieve the running state for.\n     ",
    "links" : [ "#isUserRunning", "android.os.Build.VERSION_CODES#N", "android.os.Build.VERSION_CODES#N_MR1", "android.os.UserHandle" ]
  }, {
    "name" : "public boolean isUserUnlocked()",
    "returnType" : "boolean",
    "comment" : "\n     * Return whether the calling user is running in an \"unlocked\" state.\n     * <p>\n     * On devices with direct boot, a user is unlocked only after they've\n     * entered their credentials (such as a lock pattern or PIN). On devices\n     * without direct boot, a user is unlocked as soon as it starts.\n     * <p>\n     * When a user is locked, only device-protected data storage is available.\n     * When a user is unlocked, both device-protected and credential-protected\n     * private app data storage is available.\n     *\n     * @see Intent#ACTION_USER_UNLOCKED\n     * @see Context#createDeviceProtectedStorageContext()\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean isUserUnlocked(UserHandle user)",
    "returnType" : "boolean",
    "comment" : "\n     * Return whether the given user is running in an \"unlocked\" state.\n     * <p>\n     * On devices with direct boot, a user is unlocked only after they've\n     * entered their credentials (such as a lock pattern or PIN). On devices\n     * without direct boot, a user is unlocked as soon as it starts.\n     * <p>\n     * When a user is locked, only device-protected data storage is available.\n     * When a user is unlocked, both device-protected and credential-protected\n     * private app data storage is available.\n     * <p>Requires {@code android.permission.MANAGE_USERS} or\n     * {@code android.permission.INTERACT_ACROSS_USERS}, otherwise specified {@link UserHandle user}\n     * must be the calling user or a managed profile associated with it.\n     *\n     * @param user to retrieve the unlocked state for.\n     * @see Intent#ACTION_USER_UNLOCKED\n     * @see Context#createDeviceProtectedStorageContext()\n     ",
    "links" : [ "UserHandle" ]
  }, {
    "name" : "public boolean isUserUnlocked(@UserIdInt int userId)",
    "returnType" : "boolean",
    "comment" : " {@hide} ",
    "links" : [ ]
  }, {
    "name" : "public void disableIsUserUnlockedCache()",
    "returnType" : "void",
    "comment" : " {@hide} ",
    "links" : [ ]
  }, {
    "name" : "public static final void invalidateIsUserUnlockedCache()",
    "returnType" : "void",
    "comment" : " {@hide} ",
    "links" : [ ]
  }, {
    "name" : "public boolean isUserUnlockingOrUnlocked(@NonNull UserHandle user)",
    "returnType" : "boolean",
    "comment" : "\n     * Return whether the provided user is already running in an\n     * \"unlocked\" state or in the process of unlocking.\n     * <p>\n     * On devices with direct boot, a user is unlocked only after they've\n     * entered their credentials (such as a lock pattern or PIN). On devices\n     * without direct boot, a user is unlocked as soon as it starts.\n     * <p>\n     * When a user is locked, only device-protected data storage is available.\n     * When a user is unlocked, both device-protected and credential-protected\n     * private app data storage is available.\n     *\n     * <p>Requires {@code android.permission.MANAGE_USERS} or\n     * {@code android.permission.INTERACT_ACROSS_USERS}, otherwise specified {@link UserHandle user}\n     * must be the calling user or a profile associated with it.\n     *\n     * @hide\n     ",
    "links" : [ "UserHandle" ]
  }, {
    "name" : "public boolean isUserUnlockingOrUnlocked(@UserIdInt int userId)",
    "returnType" : "boolean",
    "comment" : " {@hide} ",
    "links" : [ ]
  }, {
    "name" : "public long getUserStartRealtime()",
    "returnType" : "long",
    "comment" : "\n     * Return the time when the calling user started in elapsed milliseconds since boot,\n     * or 0 if not started.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public long getUserUnlockRealtime()",
    "returnType" : "long",
    "comment" : "\n     * Return the time when the calling user was unlocked elapsed milliseconds since boot,\n     * or 0 if not unlocked.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public UserInfo getUserInfo(@UserIdInt int userId)",
    "returnType" : "UserInfo",
    "comment" : "\n     * Returns the UserInfo object describing a specific user.\n     * @param userId the user handle of the user whose information is being requested.\n     * @return the UserInfo object for a specific user.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public int getUserRestrictionSource(@UserRestrictionKey String restrictionKey, UserHandle userHandle)",
    "returnType" : "int",
    "comment" : "\n     * @hide\n     *\n     * Returns who set a user restriction on a user.\n     * @param restrictionKey the string key representing the restriction\n     * @param userHandle the UserHandle of the user for whom to retrieve the restrictions.\n     * @return The source of user restriction. Any combination of {@link #RESTRICTION_NOT_SET},\n     *         {@link #RESTRICTION_SOURCE_SYSTEM}, {@link #RESTRICTION_SOURCE_DEVICE_OWNER}\n     *         and {@link #RESTRICTION_SOURCE_PROFILE_OWNER}\n     * @deprecated use {@link #getUserRestrictionSources(String, int)} instead.\n     ",
    "links" : [ "#RESTRICTION_NOT_SET", "#RESTRICTION_SOURCE_SYSTEM", "#RESTRICTION_SOURCE_DEVICE_OWNER", "#RESTRICTION_SOURCE_PROFILE_OWNER", "#getUserRestrictionSources" ]
  }, {
    "name" : "public List<EnforcingUser> getUserRestrictionSources(@UserRestrictionKey String restrictionKey, UserHandle userHandle)",
    "returnType" : "List<EnforcingUser>",
    "comment" : "\n     * @hide\n     *\n     * Returns a list of users who set a user restriction on a given user.\n     * @param restrictionKey the string key representing the restriction\n     * @param userHandle the UserHandle of the user for whom to retrieve the restrictions.\n     * @return a list of user ids enforcing this restriction.\n     ",
    "links" : [ ]
  }, {
    "name" : "public Bundle getUserRestrictions()",
    "returnType" : "Bundle",
    "comment" : "\n     * Returns the user-wide restrictions imposed on this user.\n     * @return a Bundle containing all the restrictions.\n     ",
    "links" : [ ]
  }, {
    "name" : "public Bundle getUserRestrictions(UserHandle userHandle)",
    "returnType" : "Bundle",
    "comment" : "\n     * Returns the user-wide restrictions imposed on the user specified by <code>userHandle</code>.\n     * @param userHandle the UserHandle of the user for whom to retrieve the restrictions.\n     * @return a Bundle containing all the restrictions.\n     *\n     * <p>Requires {@code android.permission.MANAGE_USERS} or\n     * {@code android.permission.INTERACT_ACROSS_USERS}, otherwise specified {@link UserHandle user}\n     * must be the calling user or a managed profile associated with it.\n     ",
    "links" : [ "UserHandle" ]
  }, {
    "name" : "public boolean hasBaseUserRestriction(@UserRestrictionKey @NonNull String restrictionKey, @NonNull UserHandle userHandle)",
    "returnType" : "boolean",
    "comment" : "\n     * @hide\n     * Returns whether the given user has been disallowed from performing certain actions\n     * or setting certain settings through UserManager (e.g. this type of restriction would prevent\n     * the guest user from doing certain things, such as making calls). This method disregards\n     * restrictions set by device policy.\n     * @param restrictionKey the string key representing the restriction\n     * @param userHandle the UserHandle of the user for whom to retrieve the restrictions.\n     ",
    "links" : [ ]
  }, {
    "name" : "public void setUserRestrictions(Bundle restrictions)",
    "returnType" : "void",
    "comment" : " System apps should use UserManager.setUserRestriction() instead.",
    "links" : [ ]
  }, {
    "name" : "public void setUserRestrictions(Bundle restrictions, UserHandle userHandle)",
    "returnType" : "void",
    "comment" : " System apps should use UserManager.setUserRestriction() instead.",
    "links" : [ ]
  }, {
    "name" : "public void setUserRestriction(String key, boolean value)",
    "returnType" : "void",
    "comment" : "\n     * Sets the value of a specific restriction.\n     * Requires the MANAGE_USERS permission.\n     * @param key the key of the restriction\n     * @param value the value for the restriction\n     * @deprecated use {@link android.app.admin.DevicePolicyManager#addUserRestriction(\n     * android.content.ComponentName, String)} or\n     * {@link android.app.admin.DevicePolicyManager#clearUserRestriction(\n     * android.content.ComponentName, String)} instead.\n     ",
    "links" : [ "android.app.admin.DevicePolicyManager#addUserRestriction", "android.app.admin.DevicePolicyManager#clearUserRestriction" ]
  }, {
    "name" : "public void setUserRestriction(String key, boolean value, UserHandle userHandle)",
    "returnType" : "void",
    "comment" : "\n     * @hide\n     * Sets the value of a specific restriction on a specific user.\n     * @param key the key of the restriction\n     * @param value the value for the restriction\n     * @param userHandle the user whose restriction is to be changed.\n     * @deprecated use {@link android.app.admin.DevicePolicyManager#addUserRestriction(\n     * android.content.ComponentName, String)} or\n     * {@link android.app.admin.DevicePolicyManager#clearUserRestriction(\n     * android.content.ComponentName, String)} instead.\n     ",
    "links" : [ "android.app.admin.DevicePolicyManager#addUserRestriction", "android.app.admin.DevicePolicyManager#clearUserRestriction" ]
  }, {
    "name" : "public boolean hasUserRestriction(@UserRestrictionKey String restrictionKey)",
    "returnType" : "boolean",
    "comment" : "\n     * Returns whether the current user has been disallowed from performing certain actions\n     * or setting certain settings.\n     *\n     * @param restrictionKey The string key representing the restriction.\n     * @return {@code true} if the current user has the given restriction, {@code false} otherwise.\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean hasUserRestriction(@UserRestrictionKey String restrictionKey, UserHandle userHandle)",
    "returnType" : "boolean",
    "comment" : "\n     * @hide\n     * Returns whether the given user has been disallowed from performing certain actions\n     * or setting certain settings.\n     * @param restrictionKey the string key representing the restriction\n     * @param userHandle the UserHandle of the user for whom to retrieve the restrictions.\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean hasUserRestrictionForUser(@NonNull @UserRestrictionKey String restrictionKey, @NonNull UserHandle userHandle)",
    "returnType" : "boolean",
    "comment" : "\n     * Returns whether the given user has been disallowed from performing certain actions\n     * or setting certain settings.\n     * @param restrictionKey the string key representing the restriction\n     * @param userHandle the UserHandle of the user for whom to retrieve the restrictions.\n     *\n     * <p>Requires {@code android.permission.MANAGE_USERS} or\n     * {@code android.permission.INTERACT_ACROSS_USERS}, otherwise specified {@link UserHandle user}\n     * must be the calling user or a managed profile associated with it.\n     *\n     * @hide\n     ",
    "links" : [ "UserHandle" ]
  }, {
    "name" : "public boolean hasUserRestrictionOnAnyUser(@UserRestrictionKey String restrictionKey)",
    "returnType" : "boolean",
    "comment" : "\n     * @hide\n     * Returns whether any user on the device has the given user restriction set.\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean isSettingRestrictedForUser(String setting, @UserIdInt int userId, String value, int callingUid)",
    "returnType" : "boolean",
    "comment" : "\n     * @hide\n     *\n     * Checks whether changing the given setting to the given value is prohibited\n     * by the corresponding user restriction in the given user.\n     *\n     * May only be called by the OS itself.\n     *\n     * @return {@code true} if the change is prohibited, {@code false} if the change is allowed.\n     ",
    "links" : [ ]
  }, {
    "name" : "public void addUserRestrictionsListener(final IUserRestrictionsListener listener)",
    "returnType" : "void",
    "comment" : "\n     * @hide\n     * Register a binder callback for user restrictions changes.\n     * May only be called by the OS itself.\n     ",
    "links" : [ ]
  }, {
    "name" : "public long getSerialNumberForUser(UserHandle user)",
    "returnType" : "long",
    "comment" : "\n     * Return the serial number for a user.  This is a device-unique\n     * number assigned to that user; if the user is deleted and then a new\n     * user created, the new users will not be given the same serial number.\n     * @param user The user whose serial number is to be retrieved.\n     * @return The serial number of the given user; returns -1 if the\n     * given UserHandle does not exist.\n     * @see #getUserForSerialNumber(long)\n     ",
    "links" : [ ]
  }, {
    "name" : "public UserHandle getUserForSerialNumber(long serialNumber)",
    "returnType" : "UserHandle",
    "comment" : "\n     * Return the user associated with a serial number previously\n     * returned by {@link #getSerialNumberForUser(UserHandle)}.\n     * @param serialNumber The serial number of the user that is being\n     * retrieved.\n     * @return Return the user associated with the serial number, or null\n     * if there is not one.\n     * @see #getSerialNumberForUser(UserHandle)\n     ",
    "links" : [ "#getSerialNumberForUser" ]
  }, {
    "name" : "public UserInfo createUser(@Nullable String name, @UserInfoFlag int flags)",
    "returnType" : "UserInfo",
    "comment" : "\n     * Creates a user with the specified name and options.\n     * Default user restrictions will be applied.\n     * Requires {@link android.Manifest.permission#MANAGE_USERS} permission.\n     *\n     * @param name the user's name\n     * @param flags UserInfo flags that identify the type of user and other properties.\n     * @see UserInfo\n     *\n     * @return the UserInfo object for the created user, or null if the user could not be created.\n     * @throws IllegalArgumentException if flags do not correspond to a valid user type.\n     * @deprecated Use {@link #createUser(String, String, int)} instead.\n     * @hide\n     ",
    "links" : [ "android.Manifest.permission#MANAGE_USERS", "#createUser" ]
  }, {
    "name" : "public UserInfo createUser(@Nullable String name, @NonNull String userType, @UserInfoFlag int flags)",
    "returnType" : "UserInfo",
    "comment" : "\n     * Creates a user with the specified name and options.\n     * Default user restrictions will be applied.\n     *\n     * <p>Requires {@link android.Manifest.permission#MANAGE_USERS}.\n     * {@link android.Manifest.permission#CREATE_USERS} suffices if flags are in\n     * com.android.server.pm.UserManagerService#ALLOWED_FLAGS_FOR_CREATE_USERS_PERMISSION}.\n     *\n     * @param name     the user's name\n     * @param userType the type of user, such as {@link UserManager#USER_TYPE_FULL_GUEST}.\n     * @param flags    UserInfo flags that specify user properties.\n     * @return the {@link UserInfo} object for the created user, or {@code null} if the user\n     *         could not be created.\n     *\n     * @see UserInfo\n     *\n     * @hide\n     ",
    "links" : [ "android.Manifest.permission#MANAGE_USERS", "android.Manifest.permission#CREATE_USERS", "UserManager#USER_TYPE_FULL_GUEST", "UserInfo" ]
  }, {
    "name" : "public UserInfo preCreateUser(@NonNull String userType) throws UserOperationException",
    "returnType" : "UserInfo",
    "comment" : "\n     * Pre-creates a user of the specified type. Default user restrictions will be applied.\n     *\n     * <p>This method can be used by OEMs to \"warm\" up the user creation by pre-creating some users\n     * at the first boot, so they when the \"real\" user is created (for example,\n     * by {@link #createUser(String, String, int)} or {@link #createGuest(Context, String)}), it\n     * takes less time.\n     *\n     * <p>This method completes the majority of work necessary for user creation: it\n     * creates user data, CE and DE encryption keys, app data directories, initializes the user and\n     * grants default permissions. When pre-created users become \"real\" users, only then are\n     * components notified of new user creation by firing user creation broadcasts.\n     *\n     * <p>All pre-created users are removed during system upgrade.\n     *\n     * <p>Requires {@link android.Manifest.permission#MANAGE_USERS}.\n     * {@link android.Manifest.permission#CREATE_USERS} suffices if flags are in\n     * com.android.server.pm.UserManagerService#ALLOWED_FLAGS_FOR_CREATE_USERS_PERMISSION}.\n     *\n     * @param userType the type of user, such as {@link UserManager#USER_TYPE_FULL_GUEST}.\n     * @return the {@link UserInfo} object for the created user.\n     *\n     * @throws UserOperationException if the user could not be created.\n     * @hide\n     ",
    "links" : [ "#createUser", "#createGuest", "android.Manifest.permission#MANAGE_USERS", "android.Manifest.permission#CREATE_USERS", "UserManager#USER_TYPE_FULL_GUEST", "UserInfo" ]
  }, {
    "name" : "public UserInfo createGuest(Context context, String name)",
    "returnType" : "UserInfo",
    "comment" : "\n     * Creates a guest user and configures it.\n     * @param context an application context\n     * @param name the name to set for the user\n     * @return the {@link UserInfo} object for the created user, or {@code null} if the user\n     *         could not be created.\n     *\n     * @hide\n     ",
    "links" : [ "UserInfo" ]
  }, {
    "name" : "public UserInfo findCurrentGuestUser()",
    "returnType" : "UserInfo",
    "comment" : "\n     * Gets the existing guest user if it exists.  This does not include guest users that are dying.\n     * @return The existing guest user if it exists. Null otherwise.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public UserHandle createProfile(@NonNull String name, @NonNull String userType, @NonNull Set<String> disallowedPackages) throws UserOperationException",
    "returnType" : "UserHandle",
    "comment" : "\n     * Creates a user with the specified name and options as a profile of the context's user.\n     *\n     * @param name the user's name.\n     * @param userType the type of user, such as {@link UserManager#USER_TYPE_PROFILE_MANAGED}.\n     * @param disallowedPackages packages to not install for this profile.\n     *\n     * @return the {@link android.os.UserHandle} object for the created user,\n     *         or throws {@link UserOperationException} if the user could not be created\n     *         and calling app is targeting {@link android.os.Build.VERSION_CODES#R} or above\n     *         (otherwise returns {@code null}).\n     *\n     * @throws UserOperationException if the user could not be created and the calling app is\n     *         targeting {@link android.os.Build.VERSION_CODES#R} or above.\n     *\n     * @hide\n     ",
    "links" : [ "UserManager#USER_TYPE_PROFILE_MANAGED", "android.os.UserHandle", "UserOperationException", "android.os.Build.VERSION_CODES#R", "android.os.Build.VERSION_CODES#R" ]
  }, {
    "name" : "public UserInfo createProfileForUser(String name, @UserInfoFlag int flags, @UserIdInt int userId)",
    "returnType" : "UserInfo",
    "comment" : "\n     * Creates a user with the specified name and options as a profile of another user.\n     * <p>Requires MANAGE_USERS. CREATE_USERS suffices for ALLOWED_FLAGS_FOR_CREATE_USERS_PERMISSION\n     *\n     * @param name the user's name\n     * @param flags flags that identify the type of user and other properties.\n     * @param userId new user will be a profile of this user.\n     *\n     * @return the {@link UserInfo} object for the created user, or null if the user\n     *         could not be created.\n     * @throws IllegalArgumentException if flags do not correspond to a valid user type.\n     * @deprecated Use {@link #createProfileForUser(String, String, int, int)} instead.\n     * @hide\n     ",
    "links" : [ "UserInfo", "#createProfileForUser" ]
  }, {
    "name" : "public UserInfo createProfileForUser(String name, @NonNull String userType, @UserInfoFlag int flags, @UserIdInt int userId)",
    "returnType" : "UserInfo",
    "comment" : "\n     * Creates a user with the specified name and options as a profile of another user.\n     *\n     * @param name the user's name\n     * @param userType the type of user, such as {@link UserManager#USER_TYPE_PROFILE_MANAGED}.\n     * @param flags UserInfo flags that specify user properties.\n     * @param userId new user will be a profile of this user.\n     *\n     * @return the {@link UserInfo} object for the created user, or null if the user\n     *         could not be created.\n     * @hide\n     ",
    "links" : [ "UserManager#USER_TYPE_PROFILE_MANAGED", "UserInfo" ]
  }, {
    "name" : "public UserInfo createProfileForUser(String name, @NonNull String userType, @UserInfoFlag int flags, @UserIdInt int userId, String[] disallowedPackages)",
    "returnType" : "UserInfo",
    "comment" : "\n     * Version of {@link #createProfileForUser(String, String, int, int)} that allows you to specify\n     * any packages that should not be installed in the new profile by default, these packages can\n     * still be installed later by the user if needed.\n     *\n     * @param name the user's name\n     * @param userType the type of user, such as {@link UserManager#USER_TYPE_PROFILE_MANAGED}.\n     * @param flags UserInfo flags that specify user properties.\n     * @param userId new user will be a profile of this user.\n     * @param disallowedPackages packages that will not be installed in the profile being created.\n     *\n     * @return the {@link UserInfo} object for the created user, or {@code null} if the user could\n     *         not be created.\n     *\n     * @hide\n     ",
    "links" : [ "#createProfileForUser", "UserManager#USER_TYPE_PROFILE_MANAGED", "UserInfo" ]
  }, {
    "name" : "public UserInfo createProfileForUserEvenWhenDisallowed(String name, @NonNull String userType, @UserInfoFlag int flags, @UserIdInt int userId, String[] disallowedPackages)",
    "returnType" : "UserInfo",
    "comment" : "\n     * Similar to {@link #createProfileForUser(String, String, int, int, String[])}\n     * except bypassing the checking of {@link UserManager#DISALLOW_ADD_MANAGED_PROFILE}.\n     *\n     * @see #createProfileForUser(String, String, int, int, String[])\n     * @hide\n     ",
    "links" : [ "#createProfileForUser", "UserManager#DISALLOW_ADD_MANAGED_PROFILE" ]
  }, {
    "name" : "public UserInfo createRestrictedProfile(String name)",
    "returnType" : "UserInfo",
    "comment" : "\n     * Creates a restricted profile with the specified name. This method also sets necessary\n     * restrictions and adds shared accounts.\n     *\n     * @param name profile's name\n     * @return the {@link UserInfo} object for the created user, or {@code null} if the user\n     *         could not be created.\n     *\n     * @hide\n     ",
    "links" : [ "UserInfo" ]
  }, {
    "name" : "public static Intent createUserCreationIntent(@Nullable String userName, @Nullable String accountName, @Nullable String accountType, @Nullable PersistableBundle accountOptions)",
    "returnType" : "Intent",
    "comment" : "\n     * Returns an intent to create a user for the provided name and account name. The name\n     * and account name will be used when the setup process for the new user is started.\n     * <p>\n     * The intent should be launched using startActivityForResult and the return result will\n     * indicate if the user consented to adding a new user and if the operation succeeded. Any\n     * errors in creating the user will be returned in the result code. If the user cancels the\n     * request, the return result will be {@link Activity#RESULT_CANCELED}. On success, the\n     * result code will be {@link Activity#RESULT_OK}.\n     * <p>\n     * Use {@link #supportsMultipleUsers()} to first check if the device supports this operation\n     * at all.\n     * <p>\n     * The new user is created but not initialized. After switching into the user for the first\n     * time, the preferred user name and account information are used by the setup process for that\n     * user.\n     *\n     * @param userName Optional name to assign to the user.\n     * @param accountName Optional account name that will be used by the setup wizard to initialize\n     *                    the user.\n     * @param accountType Optional account type for the account to be created. This is required\n     *                    if the account name is specified.\n     * @param accountOptions Optional bundle of data to be passed in during account creation in the\n     *                       new user via {@link AccountManager#addAccount(String, String, String[],\n     *                       Bundle, android.app.Activity, android.accounts.AccountManagerCallback,\n     *                       Handler)}.\n     * @return An Intent that can be launched from an Activity.\n     * @see #USER_CREATION_FAILED_NOT_PERMITTED\n     * @see #USER_CREATION_FAILED_NO_MORE_USERS\n     * @see #supportsMultipleUsers\n     ",
    "links" : [ "Activity#RESULT_CANCELED", "Activity#RESULT_OK", "#supportsMultipleUsers", "AccountManager#addAccount" ]
  }, {
    "name" : "public String getSeedAccountName()",
    "returnType" : "String",
    "comment" : "\n     * @hide\n     *\n     * Returns the preferred account name for user creation.\n     ",
    "links" : [ ]
  }, {
    "name" : "public String getSeedAccountType()",
    "returnType" : "String",
    "comment" : "\n     * @hide\n     *\n     * Returns the preferred account type for user creation.\n     ",
    "links" : [ ]
  }, {
    "name" : "public PersistableBundle getSeedAccountOptions()",
    "returnType" : "PersistableBundle",
    "comment" : "\n     * @hide\n     *\n     * Returns the preferred account's options bundle for user creation.\n     * @return Any options set by the requestor that created the user.\n     ",
    "links" : [ ]
  }, {
    "name" : "public void setSeedAccountData(int userId, String accountName, String accountType, PersistableBundle accountOptions)",
    "returnType" : "void",
    "comment" : "\n     * @hide\n     *\n     * Called by a system activity to set the seed account information of a user created\n     * through the user creation intent.\n     * @param userId\n     * @param accountName\n     * @param accountType\n     * @param accountOptions\n     * @see #createUserCreationIntent(String, String, String, PersistableBundle)\n     ",
    "links" : [ ]
  }, {
    "name" : "public void clearSeedAccountData()",
    "returnType" : "void",
    "comment" : "\n     * @hide\n     * Clears the seed information used to create this user.\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean markGuestForDeletion(@UserIdInt int userId)",
    "returnType" : "boolean",
    "comment" : "\n     * @hide\n     * Marks the guest user for deletion to allow a new guest to be created before deleting\n     * the current user who is a guest.\n     * @param userId\n     * @return\n     ",
    "links" : [ ]
  }, {
    "name" : "public void setUserEnabled(@UserIdInt int userId)",
    "returnType" : "void",
    "comment" : "\n     * Sets the user as enabled, if such an user exists.\n     *\n     * <p>Note that the default is true, it's only that managed profiles might not be enabled.\n     * Also ephemeral users can be disabled to indicate that their removal is in progress and they\n     * shouldn't be re-entered. Therefore ephemeral users should not be re-enabled once disabled.\n     *\n     * @param userId the id of the profile to enable\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public void setUserAdmin(@UserIdInt int userId)",
    "returnType" : "void",
    "comment" : "\n     * Assigns admin privileges to the user, if such a user exists.\n     *\n     * <p>Note that this does not alter the user's pre-existing user restrictions.\n     *\n     * @param userId the id of the user to become admin\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public void evictCredentialEncryptionKey(@UserIdInt int userId)",
    "returnType" : "void",
    "comment" : "\n     * Evicts the user's credential encryption key from memory by stopping and restarting the user.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public int getUserCount()",
    "returnType" : "int",
    "comment" : "\n     * Return the number of users currently created on the device.\n     * <p>This API is not for use by third-party apps. It requires the {@code MANAGE_USERS}\n     * permission.</p>\n     ",
    "links" : [ ]
  }, {
    "name" : "public List<UserInfo> getUsers()",
    "returnType" : "List<UserInfo>",
    "comment" : "\n     * Returns information for all users on this device, including ones marked for deletion.\n     * To retrieve only users that are alive, use {@link #getUsers(boolean)}.\n     *\n     * @return the list of users that exist on the device.\n     * @hide\n     ",
    "links" : [ "#getUsers" ]
  }, {
    "name" : "public List<UserInfo> getUsers(boolean excludeDying)",
    "returnType" : "List<UserInfo>",
    "comment" : "\n     * Returns information for all users on this device. Requires\n     * {@link android.Manifest.permission#MANAGE_USERS} permission.\n     *\n     * @param excludeDying specify if the list should exclude users being\n     *            removed.\n     * @return the list of users that were created.\n     * @hide\n     ",
    "links" : [ "android.Manifest.permission#MANAGE_USERS" ]
  }, {
    "name" : "public List<UserInfo> getUsers(boolean excludePartial, boolean excludeDying, boolean excludePreCreated)",
    "returnType" : "List<UserInfo>",
    "comment" : "\n     * Returns information for all users on this device, based on the filtering parameters.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public List<UserHandle> getUserHandles(boolean excludeDying)",
    "returnType" : "List<UserHandle>",
    "comment" : "\n     * Returns the user handles for all users on this device, based on the filtering parameters.\n     *\n     * @param excludeDying specify if the list should exclude users being removed.\n     * @return the list of user handles.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public long[] getSerialNumbersOfUsers(boolean excludeDying)",
    "returnType" : "long[]",
    "comment" : "\n     * Returns serial numbers of all users on this device.\n     *\n     * @param excludeDying specify if the list should exclude users being removed.\n     * @return the list of serial numbers of users that exist on the device.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public String getUserAccount(@UserIdInt int userId)",
    "returnType" : "String",
    "comment" : "\n     * @return the user's account name, null if not found.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public void setUserAccount(@UserIdInt int userId, @Nullable String accountName)",
    "returnType" : "void",
    "comment" : "\n     * Set account name for the given user.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public UserInfo getPrimaryUser()",
    "returnType" : "UserInfo",
    "comment" : "\n     * Returns information for Primary user.\n     *\n     * @return the Primary user, null if not found.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean canAddMoreUsers()",
    "returnType" : "boolean",
    "comment" : "\n     * Checks whether it's possible to add more users. Caller must hold the MANAGE_USERS\n     * permission.\n     *\n     * @return true if more users can be added, false if limit has been reached.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean canAddMoreManagedProfiles(@UserIdInt int userId, boolean allowedToRemoveOne)",
    "returnType" : "boolean",
    "comment" : "\n     * Checks whether it's possible to add more managed profiles. Caller must hold the MANAGE_USERS\n     * permission.\n     * if allowedToRemoveOne is true and if the user already has a managed profile, then return if\n     * we could add a new managed profile to this user after removing the existing one.\n     *\n     * @return true if more managed profiles can be added, false if limit has been reached.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean canAddMoreProfilesToUser(@NonNull String userType, @UserIdInt int userId)",
    "returnType" : "boolean",
    "comment" : "\n     * Checks whether it's possible to add more profiles of the given type to the given user.\n     *\n     * @param userType the type of user, such as {@link UserManager#USER_TYPE_PROFILE_MANAGED}.\n     * @return true if more profiles can be added, false if limit has been reached.\n     * @hide\n     ",
    "links" : [ "UserManager#USER_TYPE_PROFILE_MANAGED" ]
  }, {
    "name" : "public List<UserInfo> getProfiles(@UserIdInt int userId)",
    "returnType" : "List<UserInfo>",
    "comment" : "\n     * Returns list of the profiles of userId including userId itself.\n     * Note that this returns both enabled and not enabled profiles. See\n     * {@link #getEnabledProfiles(int)} if you need only the enabled ones.\n     *\n     * <p>Requires {@link android.Manifest.permission#MANAGE_USERS}.\n     * {@link android.Manifest.permission#CREATE_USERS} suffices if userId is the calling user.\n     * @param userId profiles of this user will be returned.\n     * @return the list of profiles.\n     * @hide\n     ",
    "links" : [ "#getEnabledProfiles", "android.Manifest.permission#MANAGE_USERS", "android.Manifest.permission#CREATE_USERS" ]
  }, {
    "name" : "public boolean isSameProfileGroup(@NonNull UserHandle user, @NonNull UserHandle otherUser)",
    "returnType" : "boolean",
    "comment" : "\n     * Checks if the 2 provided user handles belong to the same profile group.\n     *\n     * @param user one of the two user handles to check.\n     * @param otherUser one of the two user handles to check.\n     * @return true if the two users are in the same profile group.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean isSameProfileGroup(@UserIdInt int userId, int otherUserId)",
    "returnType" : "boolean",
    "comment" : "\n     * Checks if the 2 provided user ids belong to the same profile group.\n     * @param userId one of the two user ids to check.\n     * @param otherUserId one of the two user ids to check.\n     * @return true if the two user ids are in the same profile group.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public List<UserInfo> getEnabledProfiles(@UserIdInt int userId)",
    "returnType" : "List<UserInfo>",
    "comment" : "\n     * Returns list of the profiles of userId including userId itself.\n     * Note that this returns only enabled.\n     *\n     * <p>Requires {@link android.Manifest.permission#MANAGE_USERS}.\n     * {@link android.Manifest.permission#CREATE_USERS} suffices if userId is the calling user.\n     * @param userId profiles of this user will be returned.\n     * @return the list of profiles.\n     * @hide\n     ",
    "links" : [ "android.Manifest.permission#MANAGE_USERS", "android.Manifest.permission#CREATE_USERS" ]
  }, {
    "name" : "public List<UserHandle> getUserProfiles()",
    "returnType" : "List<UserHandle>",
    "comment" : "\n     * Returns a list of UserHandles for profiles associated with the user that the calling process\n     * is running on, including the user itself.\n     *\n     * @return A non-empty list of UserHandles associated with the calling user.\n     ",
    "links" : [ ]
  }, {
    "name" : "public List<UserHandle> getEnabledProfiles()",
    "returnType" : "List<UserHandle>",
    "comment" : "\n     * Returns a list of ids for enabled profiles associated with the context user including the\n     * user itself.\n     *\n     * @return A non-empty list of UserHandles associated with the calling user.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public List<UserHandle> getAllProfiles()",
    "returnType" : "List<UserHandle>",
    "comment" : "\n     * Returns a list of ids for all profiles associated with the context user including the user\n     * itself.\n     *\n     * @return A non-empty list of UserHandles associated with the calling user.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "private List<UserHandle> getProfiles(boolean enabledOnly)",
    "returnType" : "List<UserHandle>",
    "comment" : "\n     * Returns a list of ids for profiles associated with the context user including the user\n     * itself.\n     *\n     * @param enabledOnly whether to return only {@link UserInfo#isEnabled() enabled} profiles\n     * @return A non-empty list of UserHandles associated with the calling user.\n     ",
    "links" : [ "UserInfo#isEnabled" ]
  }, {
    "name" : "public int[] getProfileIds(@UserIdInt int userId, boolean enabledOnly)",
    "returnType" : "int[]",
    "comment" : "\n     * Returns a list of ids for profiles associated with the specified user including the user\n     * itself.\n     *\n     * @param userId      id of the user to return profiles for\n     * @param enabledOnly whether return only {@link UserInfo#isEnabled() enabled} profiles\n     * @return A non-empty list of ids of profiles associated with the specified user.\n     *\n     * @hide\n     ",
    "links" : [ "UserInfo#isEnabled" ]
  }, {
    "name" : "public int[] getProfileIdsWithDisabled(@UserIdInt int userId)",
    "returnType" : "int[]",
    "comment" : "\n     * @see #getProfileIds(int, boolean)\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public int[] getEnabledProfileIds(@UserIdInt int userId)",
    "returnType" : "int[]",
    "comment" : "\n     * @see #getProfileIds(int, boolean)\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public int getCredentialOwnerProfile(@UserIdInt int userId)",
    "returnType" : "int",
    "comment" : "\n     * Returns the device credential owner id of the profile from\n     * which this method is called, or userId if called from a user that\n     * is not a profile.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public UserInfo getProfileParent(@UserIdInt int userId)",
    "returnType" : "UserInfo",
    "comment" : "\n     * Returns the parent of the profile which this method is called from\n     * or null if called from a user that is not a profile.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public UserHandle getProfileParent(@NonNull UserHandle user)",
    "returnType" : "UserHandle",
    "comment" : "\n     * Get the parent of a user profile.\n     *\n     * @param user the handle of the user profile\n     *\n     * @return the parent of the user or {@code null} if the user is not profile\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean requestQuietModeEnabled(boolean enableQuietMode, @NonNull UserHandle userHandle)",
    "returnType" : "boolean",
    "comment" : "\n     * Enables or disables quiet mode for a managed profile. If quiet mode is enabled, apps in a\n     * managed profile don't run, generate notifications, or consume data or battery.\n     * <p>\n     * If a user's credential is needed to turn off quiet mode, a confirm credential screen will be\n     * shown to the user.\n     * <p>\n     * The change may not happen instantly, however apps can listen for\n     * {@link Intent#ACTION_MANAGED_PROFILE_AVAILABLE} and\n     * {@link Intent#ACTION_MANAGED_PROFILE_UNAVAILABLE} broadcasts in order to be notified of\n     * the change of the quiet mode. Apps can also check the current state of quiet mode by\n     * calling {@link #isQuietModeEnabled(UserHandle)}.\n     * <p>\n     * The caller must either be the foreground default launcher or have one of these permissions:\n     * {@code MANAGE_USERS} or {@code MODIFY_QUIET_MODE}.\n     *\n     * @param enableQuietMode whether quiet mode should be enabled or disabled\n     * @param userHandle user handle of the profile\n     * @return {@code false} if user's credential is needed in order to turn off quiet mode,\n     *         {@code true} otherwise\n     * @throws SecurityException if the caller is invalid\n     * @throws IllegalArgumentException if {@code userHandle} is not a managed profile\n     *\n     * @see #isQuietModeEnabled(UserHandle)\n     ",
    "links" : [ "Intent#ACTION_MANAGED_PROFILE_AVAILABLE", "Intent#ACTION_MANAGED_PROFILE_UNAVAILABLE", "#isQuietModeEnabled" ]
  }, {
    "name" : "public boolean requestQuietModeEnabled(boolean enableQuietMode, @NonNull UserHandle userHandle, @QuietModeFlag int flags)",
    "returnType" : "boolean",
    "comment" : "\n     * Perform the same operation as {@link #requestQuietModeEnabled(boolean, UserHandle)}, but\n     * with a flag to tweak the behavior of the request.\n     *\n     * @param enableQuietMode whether quiet mode should be enabled or disabled\n     * @param userHandle user handle of the profile\n     * @param flags Can be 0 or {@link #QUIET_MODE_DISABLE_ONLY_IF_CREDENTIAL_NOT_REQUIRED}.\n     * @return {@code false} if user's credential is needed in order to turn off quiet mode,\n     *         {@code true} otherwise\n     * @throws SecurityException if the caller is invalid\n     * @throws IllegalArgumentException if {@code userHandle} is not a managed profile\n     *\n     * @see #isQuietModeEnabled(UserHandle)\n     ",
    "links" : [ "#requestQuietModeEnabled", "#QUIET_MODE_DISABLE_ONLY_IF_CREDENTIAL_NOT_REQUIRED" ]
  }, {
    "name" : "public boolean requestQuietModeEnabled(boolean enableQuietMode, @NonNull UserHandle userHandle, IntentSender target)",
    "returnType" : "boolean",
    "comment" : "\n     * Similar to {@link #requestQuietModeEnabled(boolean, UserHandle)}, except you can specify\n     * a target to start when user is unlocked. If {@code target} is specified, caller must have\n     * the {@link android.Manifest.permission#MANAGE_USERS} permission.\n     *\n     * @see {@link #requestQuietModeEnabled(boolean, UserHandle)}\n     * @hide\n     ",
    "links" : [ "#requestQuietModeEnabled", "android.Manifest.permission#MANAGE_USERS", "#requestQuietModeEnabled" ]
  }, {
    "name" : "public boolean requestQuietModeEnabled(boolean enableQuietMode, @NonNull UserHandle userHandle, IntentSender target, int flags)",
    "returnType" : "boolean",
    "comment" : "\n     * Similar to {@link #requestQuietModeEnabled(boolean, UserHandle)}, except you can specify\n     * a target to start when user is unlocked. If {@code target} is specified, caller must have\n     * the {@link android.Manifest.permission#MANAGE_USERS} permission.\n     *\n     * @see #requestQuietModeEnabled(boolean, UserHandle)\n     * @hide\n     ",
    "links" : [ "#requestQuietModeEnabled", "android.Manifest.permission#MANAGE_USERS" ]
  }, {
    "name" : "public boolean isQuietModeEnabled(UserHandle userHandle)",
    "returnType" : "boolean",
    "comment" : "\n     * Returns whether the given profile is in quiet mode or not.\n     * Notes: Quiet mode is only supported for managed profiles.\n     *\n     * @param userHandle The user handle of the profile to be queried.\n     * @return true if the profile is in quiet mode, false otherwise.\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean hasBadge(@UserIdInt int userId)",
    "returnType" : "boolean",
    "comment" : "\n     * Returns whether the given user has a badge (generally to put on profiles' icons).\n     *\n     * @param userId userId of the user in question\n     * @return true if the user's icons should display a badge; false otherwise.\n     *\n     * @see #getBadgedIconForUser more information about badging in general\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean hasBadge()",
    "returnType" : "boolean",
    "comment" : "\n     * Returns whether the user associated with the context has a badge (generally to put on\n     * profiles' icons).\n     *\n     * @return true if the user's icons should display a badge; false otherwise.\n     * @see #getBadgedIconForUser more information about badging in general\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public int getUserBadgeColor(@UserIdInt int userId)",
    "returnType" : "int",
    "comment" : "\n     * Returns the light theme badge color for the given user (generally to color a profile's\n     * icon's badge).\n     *\n     * <p>To check whether a badge color is expected for the user, first call {@link #hasBadge}.\n     *\n     * @return the color (not the resource ID) to be used for the user's badge\n     * @throws Resources.NotFoundException if no valid badge color exists for this user\n     *\n     * @see #getBadgedIconForUser more information about badging in general\n     * @hide\n     ",
    "links" : [ "#hasBadge" ]
  }, {
    "name" : "public int getUserBadgeDarkColor(@UserIdInt int userId)",
    "returnType" : "int",
    "comment" : "\n     * Returns the dark theme badge color for the given user (generally to color a profile's icon's\n     * badge).\n     *\n     * <p>To check whether a badge color is expected for the user, first call {@link #hasBadge}.\n     *\n     * @return the color (not the resource ID) to be used for the user's badge\n     * @throws Resources.NotFoundException if no valid badge color exists for this user\n     *\n     * @see #getBadgedIconForUser more information about badging in general\n     * @hide\n     ",
    "links" : [ "#hasBadge" ]
  }, {
    "name" : "public int getUserIconBadgeResId(@UserIdInt int userId)",
    "returnType" : "int",
    "comment" : "\n     * Returns the Resource ID of the user's icon badge.\n     *\n     * @return the Resource ID of the user's icon badge if it has one; otherwise\n     *         {@link Resources#ID_NULL}.\n     *\n     * @see #getBadgedIconForUser more information about badging in general\n     * @hide\n     ",
    "links" : [ "Resources#ID_NULL" ]
  }, {
    "name" : "public int getUserBadgeResId(@UserIdInt int userId)",
    "returnType" : "int",
    "comment" : "\n     * Returns the Resource ID of the user's badge.\n     *\n     * @return the Resource ID of the user's badge if it has one; otherwise\n     *         {@link Resources#ID_NULL}.\n     *\n     * @see #getBadgedIconForUser more information about badging in general\n     * @hide\n     ",
    "links" : [ "Resources#ID_NULL" ]
  }, {
    "name" : "public int getUserBadgeNoBackgroundResId(@UserIdInt int userId)",
    "returnType" : "int",
    "comment" : "\n     * Returns the Resource ID of the user's badge without a background.\n     *\n     * @return the Resource ID of the user's no-background badge if it has one; otherwise\n     *         {@link Resources#ID_NULL}.\n     *\n     * @see #getBadgedIconForUser more information about badging in general\n     * @hide\n     ",
    "links" : [ "Resources#ID_NULL" ]
  }, {
    "name" : "public Drawable getBadgedIconForUser(Drawable icon, UserHandle user)",
    "returnType" : "Drawable",
    "comment" : "\n     * If the target user is a profile of the calling user or the caller\n     * is itself a profile, then this returns a badged copy of the given\n     * icon to be able to distinguish it from the original icon. For badging an\n     * arbitrary drawable use {@link #getBadgedDrawableForUser(\n     * android.graphics.drawable.Drawable, UserHandle, android.graphics.Rect, int)}.\n     * <p>\n     * If the original drawable is a BitmapDrawable and the backing bitmap is\n     * mutable as per {@link android.graphics.Bitmap#isMutable()}, the badging\n     * is performed in place and the original drawable is returned.\n     * </p>\n     *\n     * @param icon The icon to badge.\n     * @param user The target user.\n     * @return A drawable that combines the original icon and a badge as\n     *         determined by the system.\n     * @removed\n     ",
    "links" : [ "#getBadgedDrawableForUser", "android.graphics.Bitmap#isMutable" ]
  }, {
    "name" : "public Drawable getBadgedDrawableForUser(Drawable badgedDrawable, UserHandle user, Rect badgeLocation, int badgeDensity)",
    "returnType" : "Drawable",
    "comment" : "\n     * If the target user is a profile of the calling user or the caller\n     * is itself a profile, then this returns a badged copy of the given\n     * drawable allowing the user to distinguish it from the original drawable.\n     * The caller can specify the location in the bounds of the drawable to be\n     * badged where the badge should be applied as well as the density of the\n     * badge to be used.\n     * <p>\n     * If the original drawable is a BitmapDrawable and the backing bitmap is\n     * mutable as per {@link android.graphics.Bitmap#isMutable()}, the badging\n     * is performed in place and the original drawable is returned.\n     * </p>\n     *\n     * @param badgedDrawable The drawable to badge.\n     * @param user The target user.\n     * @param badgeLocation Where in the bounds of the badged drawable to place\n     *         the badge. If it's {@code null}, the badge is applied on top of the entire\n     *         drawable being badged.\n     * @param badgeDensity The optional desired density for the badge as per\n     *         {@link android.util.DisplayMetrics#densityDpi}. If it's not positive,\n     *         the density of the display is used.\n     * @return A drawable that combines the original drawable and a badge as\n     *         determined by the system.\n     * @removed\n     ",
    "links" : [ "android.graphics.Bitmap#isMutable", "android.util.DisplayMetrics#densityDpi" ]
  }, {
    "name" : "public CharSequence getBadgedLabelForUser(CharSequence label, UserHandle user)",
    "returnType" : "CharSequence",
    "comment" : "\n     * If the target user is a profile of the calling user or the caller\n     * is itself a profile, then this returns a copy of the label with\n     * badging for accessibility services like talkback. E.g. passing in \"Email\"\n     * and it might return \"Work Email\" for Email in the work profile.\n     *\n     * <p>Requires {@link android.Manifest.permission#MANAGE_USERS} or\n     * {@link android.Manifest.permission#INTERACT_ACROSS_USERS} permission, otherwise the caller\n     * must be in the same profile group of specified user.\n     *\n     * @param label The label to change.\n     * @param user The target user.\n     * @return A label that combines the original label and a badge as\n     *         determined by the system.\n     * @removed\n     ",
    "links" : [ "android.Manifest.permission#MANAGE_USERS", "android.Manifest.permission#INTERACT_ACROSS_USERS" ]
  }, {
    "name" : "public boolean removeUser(@UserIdInt int userId)",
    "returnType" : "boolean",
    "comment" : "\n     * Removes a user and all associated data.\n     * @param userId the integer handle of the user.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean removeUser(@NonNull UserHandle user)",
    "returnType" : "boolean",
    "comment" : "\n     * Removes a user and all associated data.\n     *\n     * @param user the user that needs to be removed.\n     * @return {@code true} if the user was successfully removed, {@code false} otherwise.\n     * @throws IllegalArgumentException if {@code user} is {@code null}\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean removeUserEvenWhenDisallowed(@UserIdInt int userId)",
    "returnType" : "boolean",
    "comment" : "\n     * Similar to {@link #removeUser(int)} except bypassing the checking of\n     * {@link UserManager#DISALLOW_REMOVE_USER}\n     * or {@link UserManager#DISALLOW_REMOVE_MANAGED_PROFILE}.\n     *\n     * @see {@link #removeUser(int)}\n     * @hide\n     ",
    "links" : [ "#removeUser", "UserManager#DISALLOW_REMOVE_USER", "UserManager#DISALLOW_REMOVE_MANAGED_PROFILE", "#removeUser" ]
  }, {
    "name" : "public void setUserName(@UserIdInt int userId, String name)",
    "returnType" : "void",
    "comment" : "\n     * Updates the user's name.\n     *\n     * @param userId the user's integer id\n     * @param name the new name for the user\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public void setUserName(@Nullable String name)",
    "returnType" : "void",
    "comment" : "\n     * Updates the context user's name.\n     *\n     * @param name the new name for the user\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public void setUserIcon(@UserIdInt int userId, @NonNull Bitmap icon)",
    "returnType" : "void",
    "comment" : "\n     * Sets the user's photo.\n     * @param userId the user for whom to change the photo.\n     * @param icon the bitmap to set as the photo.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public void setUserIcon(@NonNull Bitmap icon) throws UserOperationException",
    "returnType" : "void",
    "comment" : "\n     * Sets the context user's photo.\n     *\n     * @param icon the bitmap to set as the photo.\n     *\n     * @throws UserOperationException according to the function signature, but may not actually\n     * throw it in practice. Catch RuntimeException instead.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public Bitmap getUserIcon(@UserIdInt int userId)",
    "returnType" : "Bitmap",
    "comment" : "\n     * Returns a bitmap of the user's photo\n     * @param userId the user whose photo we want to read.\n     * @return a {@link Bitmap} of the user's photo, or null if there's no photo.\n     * @see com.android.internal.util.UserIcons#getDefaultUserIcon for a default.\n     * @hide\n     ",
    "links" : [ "Bitmap" ]
  }, {
    "name" : "public Bitmap getUserIcon()",
    "returnType" : "Bitmap",
    "comment" : "\n     * Returns a Bitmap for the context user's photo.\n     *\n     * @return a {@link Bitmap} of the user's photo, or null if there's no photo.\n     * @see com.android.internal.util.UserIcons#getDefaultUserIcon for a default.\n     * @hide\n     ",
    "links" : [ "Bitmap" ]
  }, {
    "name" : "public static int getMaxSupportedUsers()",
    "returnType" : "int",
    "comment" : "\n     * Returns the maximum number of users that can be created on this device. A return value\n     * of 1 means that it is a single user device.\n     * @hide\n     * @return a value greater than or equal to 1\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean isUserSwitcherEnabled()",
    "returnType" : "boolean",
    "comment" : "\n     * Returns true if the user switcher is enabled (regardless of whether there is anything\n     * interesting for it to show).\n     *\n     * @return true if user switcher is enabled\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean isUserSwitcherEnabled(boolean showEvenIfNotActionable)",
    "returnType" : "boolean",
    "comment" : "\n     * Returns true if the user switcher should be shown.\n     *\n     * @param showEvenIfNotActionable value to return if the feature is enabled but there is nothing\n     *                                actionable for the user to do anyway\n     * @return true if user switcher should be shown.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "private boolean areThereUsersToWhichToSwitch()",
    "returnType" : "boolean",
    "comment" : " Returns whether there are any users (other than the current user) to which to switch. ",
    "links" : [ ]
  }, {
    "name" : "public static boolean isDeviceInDemoMode(Context context)",
    "returnType" : "boolean",
    "comment" : "\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public int getUserSerialNumber(@UserIdInt int userId)",
    "returnType" : "int",
    "comment" : "\n     * Returns a serial number on this device for a given userId. User handles can be recycled\n     * when deleting and creating users, but serial numbers are not reused until the device is wiped.\n     * @param userId\n     * @return a serial number associated with that user, or -1 if the userId is not valid.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public int getUserHandle(int userSerialNumber)",
    "returnType" : "int",
    "comment" : "\n     * Returns a userId on this device for a given user serial number. User handles can be\n     * recycled when deleting and creating users, but serial numbers are not reused until the device\n     * is wiped.\n     * @param userSerialNumber\n     * @return the userId associated with that user serial number, or -1 if the serial number\n     * is not valid.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public Bundle getApplicationRestrictions(String packageName)",
    "returnType" : "Bundle",
    "comment" : "\n     * Returns a {@link Bundle} containing any saved application restrictions for this user, for the\n     * given package name. Only an application with this package name can call this method.\n     *\n     * <p>The returned {@link Bundle} consists of key-value pairs, as defined by the application,\n     * where the types of values may be:\n     * <ul>\n     * <li>{@code boolean}\n     * <li>{@code int}\n     * <li>{@code String} or {@code String[]}\n     * <li>From {@link android.os.Build.VERSION_CODES#M}, {@code Bundle} or {@code Bundle[]}\n     * </ul>\n     *\n     * <p>NOTE: The method performs disk I/O and shouldn't be called on the main thread\n     *\n     * @param packageName the package name of the calling application\n     * @return a {@link Bundle} with the restrictions for that package, or an empty {@link Bundle}\n     * if there are no saved restrictions.\n     *\n     * @see #KEY_RESTRICTIONS_PENDING\n     ",
    "links" : [ "Bundle", "Bundle", "android.os.Build.VERSION_CODES#M", "Bundle", "Bundle" ]
  }, {
    "name" : "public Bundle getApplicationRestrictions(String packageName, UserHandle user)",
    "returnType" : "Bundle",
    "comment" : "\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public void setApplicationRestrictions(String packageName, Bundle restrictions, UserHandle user)",
    "returnType" : "void",
    "comment" : "\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean setRestrictionsChallenge(String newPin)",
    "returnType" : "boolean",
    "comment" : "\n     * Sets a new challenge PIN for restrictions. This is only for use by pre-installed\n     * apps and requires the MANAGE_USERS permission.\n     * @param newPin the PIN to use for challenge dialogs.\n     * @return Returns true if the challenge PIN was set successfully.\n     * @deprecated The restrictions PIN functionality is no longer provided by the system.\n     * This method is preserved for backwards compatibility reasons and always returns false.\n     ",
    "links" : [ ]
  }, {
    "name" : "public void setDefaultGuestRestrictions(Bundle restrictions)",
    "returnType" : "void",
    "comment" : "\n     * @hide\n     * Set restrictions that should apply to any future guest user that's created.\n     ",
    "links" : [ ]
  }, {
    "name" : "public Bundle getDefaultGuestRestrictions()",
    "returnType" : "Bundle",
    "comment" : "\n     * @hide\n     * Gets the default guest restrictions.\n     ",
    "links" : [ ]
  }, {
    "name" : "public long getUserCreationTime(UserHandle userHandle)",
    "returnType" : "long",
    "comment" : "\n     * Returns creation time of the user or of a managed profile associated with the calling user.\n     * @param userHandle user handle of the user or a managed profile associated with the\n     *                   calling user.\n     * @return creation time in milliseconds since Epoch time.\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean someUserHasSeedAccount(String accountName, String accountType)",
    "returnType" : "boolean",
    "comment" : "\n     * @hide\n     * Checks if any uninitialized user has the specific seed account name and type.\n     *\n     * @param accountName The account name to check for\n     * @param accountType The account type of the account to check for\n     * @return whether the seed account was found\n     ",
    "links" : [ ]
  } ],
  "variableNames" : [ "TAG", "mService", "mContext", "mUserId", "mIsManagedProfileCached", "mIsProfileCached", "USER_TYPE_FULL_SYSTEM", "USER_TYPE_FULL_SECONDARY", "USER_TYPE_FULL_GUEST", "USER_TYPE_FULL_DEMO", "USER_TYPE_FULL_RESTRICTED", "USER_TYPE_PROFILE_MANAGED", "USER_TYPE_SYSTEM_HEADLESS", "QUIET_MODE_DISABLE_ONLY_IF_CREDENTIAL_NOT_REQUIRED", "QUIET_MODE_DISABLE_DONT_ASK_CREDENTIAL", "RESTRICTION_NOT_SET", "RESTRICTION_SOURCE_SYSTEM", "RESTRICTION_SOURCE_DEVICE_OWNER", "RESTRICTION_SOURCE_PROFILE_OWNER", "DISALLOW_MODIFY_ACCOUNTS", "DISALLOW_CONFIG_WIFI", "DISALLOW_CONFIG_LOCALE", "DISALLOW_INSTALL_APPS", "DISALLOW_UNINSTALL_APPS", "DISALLOW_SHARE_LOCATION", "DISALLOW_AIRPLANE_MODE", "DISALLOW_CONFIG_BRIGHTNESS", "DISALLOW_AMBIENT_DISPLAY", "DISALLOW_CONFIG_SCREEN_TIMEOUT", "DISALLOW_INSTALL_UNKNOWN_SOURCES", "DISALLOW_INSTALL_UNKNOWN_SOURCES_GLOBALLY", "DISALLOW_CONFIG_BLUETOOTH", "DISALLOW_BLUETOOTH", "DISALLOW_BLUETOOTH_SHARING", "DISALLOW_USB_FILE_TRANSFER", "DISALLOW_CONFIG_CREDENTIALS", "DISALLOW_REMOVE_USER", "DISALLOW_REMOVE_MANAGED_PROFILE", "DISALLOW_DEBUGGING_FEATURES", "DISALLOW_CONFIG_VPN", "DISALLOW_CONFIG_LOCATION", "DISALLOW_CONFIG_DATE_TIME", "DISALLOW_CONFIG_TETHERING", "DISALLOW_NETWORK_RESET", "DISALLOW_FACTORY_RESET", "DISALLOW_ADD_USER", "DISALLOW_ADD_MANAGED_PROFILE", "ENSURE_VERIFY_APPS", "DISALLOW_CONFIG_CELL_BROADCASTS", "DISALLOW_CONFIG_MOBILE_NETWORKS", "DISALLOW_APPS_CONTROL", "DISALLOW_MOUNT_PHYSICAL_MEDIA", "DISALLOW_UNMUTE_MICROPHONE", "DISALLOW_ADJUST_VOLUME", "DISALLOW_OUTGOING_CALLS", "DISALLOW_SMS", "DISALLOW_FUN", "DISALLOW_CREATE_WINDOWS", "DISALLOW_SYSTEM_ERROR_DIALOGS", "DISALLOW_CROSS_PROFILE_COPY_PASTE", "DISALLOW_OUTGOING_BEAM", "DISALLOW_WALLPAPER", "DISALLOW_SET_WALLPAPER", "DISALLOW_SAFE_BOOT", "DISALLOW_RECORD_AUDIO", "DISALLOW_RUN_IN_BACKGROUND", "DISALLOW_CAMERA", "DISALLOW_UNMUTE_DEVICE", "DISALLOW_DATA_ROAMING", "DISALLOW_SET_USER_ICON", "DISALLOW_OEM_UNLOCK", "DISALLOW_UNIFIED_PASSWORD", "ALLOW_PARENT_PROFILE_APP_LINKING", "DISALLOW_AUTOFILL", "DISALLOW_CONTENT_CAPTURE", "DISALLOW_CONTENT_SUGGESTIONS", "DISALLOW_USER_SWITCH", "DISALLOW_SHARE_INTO_MANAGED_PROFILE", "DISALLOW_PRINTING", "DISALLOW_CONFIG_PRIVATE_DNS", "KEY_RESTRICTIONS_PENDING", "ACTION_CREATE_USER", "EXTRA_USER_NAME", "EXTRA_USER_ACCOUNT_NAME", "EXTRA_USER_ACCOUNT_TYPE", "EXTRA_USER_ACCOUNT_OPTIONS", "PIN_VERIFICATION_FAILED_INCORRECT", "PIN_VERIFICATION_FAILED_NOT_SET", "PIN_VERIFICATION_SUCCESS", "ACTION_USER_RESTRICTIONS_CHANGED", "USER_CREATION_FAILED_NOT_PERMITTED", "USER_CREATION_FAILED_NO_MORE_USERS", "SWITCHABILITY_STATUS_OK", "SWITCHABILITY_STATUS_USER_IN_CALL", "SWITCHABILITY_STATUS_USER_SWITCH_DISALLOWED", "SWITCHABILITY_STATUS_SYSTEM_USER_LOCKED", "USER_OPERATION_SUCCESS", "USER_OPERATION_ERROR_UNKNOWN", "USER_OPERATION_ERROR_MANAGED_PROFILE", "USER_OPERATION_ERROR_MAX_RUNNING_USERS", "USER_OPERATION_ERROR_CURRENT_USER", "USER_OPERATION_ERROR_LOW_STORAGE", "USER_OPERATION_ERROR_MAX_USERS", "CACHE_KEY_IS_USER_UNLOCKED_PROPERTY", "mIsUserUnlockedCache", "mIsUserUnlockingOrUnlockedCache" ],
  "methodNames" : [ "private T returnNullOrThrowUserOperationException(ServiceSpecificException exception, boolean throwInsteadOfNull) throws UserOperationException", "public static UserManager get(Context context)", "public static boolean supportsMultipleUsers()", "public static boolean isSplitSystemUser()", "public static boolean isGuestUserEphemeral()", "public static boolean isHeadlessSystemUserMode()", "public boolean canSwitchUsers()", "public int getUserSwitchability()", "public int getUserSwitchability(UserHandle userHandle)", "public int getUserHandle()", "public String getUserName()", "public boolean isUserNameSet()", "public boolean isUserAGoat()", "public boolean isPrimaryUser()", "public boolean isSystemUser()", "public boolean isAdminUser()", "public boolean isUserAdmin(@UserIdInt int userId)", "public boolean isUserOfType(@NonNull String userType)", "public static boolean isUserTypeManagedProfile(String userType)", "public static boolean isUserTypeGuest(String userType)", "public static boolean isUserTypeRestricted(String userType)", "public static boolean isUserTypeDemo(String userType)", "public static int getUserTypeForStatsd(@NonNull String userType)", "public boolean isLinkedUser()", "public boolean isRestrictedProfile()", "public boolean isRestrictedProfile(@NonNull UserHandle user)", "public boolean canHaveRestrictedProfile(@UserIdInt int userId)", "public boolean hasRestrictedProfiles()", "public boolean isGuestUser(@UserIdInt int userId)", "public boolean isGuestUser()", "public boolean isDemoUser()", "public boolean isProfile()", "private boolean isProfile(@UserIdInt int userId)", "public boolean isManagedProfile()", "public boolean isManagedProfile(@UserIdInt int userId)", "public boolean isEphemeralUser()", "public boolean isUserEphemeral(@UserIdInt int userId)", "public boolean isUserRunning(UserHandle user)", "public boolean isUserRunning(@UserIdInt int userId)", "public boolean isUserRunningOrStopping(UserHandle user)", "public boolean isUserUnlocked()", "public boolean isUserUnlocked(UserHandle user)", "public boolean isUserUnlocked(@UserIdInt int userId)", "public void disableIsUserUnlockedCache()", "public static final void invalidateIsUserUnlockedCache()", "public boolean isUserUnlockingOrUnlocked(@NonNull UserHandle user)", "public boolean isUserUnlockingOrUnlocked(@UserIdInt int userId)", "public long getUserStartRealtime()", "public long getUserUnlockRealtime()", "public UserInfo getUserInfo(@UserIdInt int userId)", "public int getUserRestrictionSource(@UserRestrictionKey String restrictionKey, UserHandle userHandle)", "public List<EnforcingUser> getUserRestrictionSources(@UserRestrictionKey String restrictionKey, UserHandle userHandle)", "public Bundle getUserRestrictions()", "public Bundle getUserRestrictions(UserHandle userHandle)", "public boolean hasBaseUserRestriction(@UserRestrictionKey @NonNull String restrictionKey, @NonNull UserHandle userHandle)", "public void setUserRestrictions(Bundle restrictions)", "public void setUserRestrictions(Bundle restrictions, UserHandle userHandle)", "public void setUserRestriction(String key, boolean value)", "public void setUserRestriction(String key, boolean value, UserHandle userHandle)", "public boolean hasUserRestriction(@UserRestrictionKey String restrictionKey)", "public boolean hasUserRestriction(@UserRestrictionKey String restrictionKey, UserHandle userHandle)", "public boolean hasUserRestrictionForUser(@NonNull @UserRestrictionKey String restrictionKey, @NonNull UserHandle userHandle)", "public boolean hasUserRestrictionOnAnyUser(@UserRestrictionKey String restrictionKey)", "public boolean isSettingRestrictedForUser(String setting, @UserIdInt int userId, String value, int callingUid)", "public void addUserRestrictionsListener(final IUserRestrictionsListener listener)", "public long getSerialNumberForUser(UserHandle user)", "public UserHandle getUserForSerialNumber(long serialNumber)", "public UserInfo createUser(@Nullable String name, @UserInfoFlag int flags)", "public UserInfo createUser(@Nullable String name, @NonNull String userType, @UserInfoFlag int flags)", "public UserInfo preCreateUser(@NonNull String userType) throws UserOperationException", "public UserInfo createGuest(Context context, String name)", "public UserInfo findCurrentGuestUser()", "public UserHandle createProfile(@NonNull String name, @NonNull String userType, @NonNull Set<String> disallowedPackages) throws UserOperationException", "public UserInfo createProfileForUser(String name, @UserInfoFlag int flags, @UserIdInt int userId)", "public UserInfo createProfileForUser(String name, @NonNull String userType, @UserInfoFlag int flags, @UserIdInt int userId)", "public UserInfo createProfileForUser(String name, @NonNull String userType, @UserInfoFlag int flags, @UserIdInt int userId, String[] disallowedPackages)", "public UserInfo createProfileForUserEvenWhenDisallowed(String name, @NonNull String userType, @UserInfoFlag int flags, @UserIdInt int userId, String[] disallowedPackages)", "public UserInfo createRestrictedProfile(String name)", "public static Intent createUserCreationIntent(@Nullable String userName, @Nullable String accountName, @Nullable String accountType, @Nullable PersistableBundle accountOptions)", "public String getSeedAccountName()", "public String getSeedAccountType()", "public PersistableBundle getSeedAccountOptions()", "public void setSeedAccountData(int userId, String accountName, String accountType, PersistableBundle accountOptions)", "public void clearSeedAccountData()", "public boolean markGuestForDeletion(@UserIdInt int userId)", "public void setUserEnabled(@UserIdInt int userId)", "public void setUserAdmin(@UserIdInt int userId)", "public void evictCredentialEncryptionKey(@UserIdInt int userId)", "public int getUserCount()", "public List<UserInfo> getUsers()", "public List<UserInfo> getUsers(boolean excludeDying)", "public List<UserInfo> getUsers(boolean excludePartial, boolean excludeDying, boolean excludePreCreated)", "public List<UserHandle> getUserHandles(boolean excludeDying)", "public long[] getSerialNumbersOfUsers(boolean excludeDying)", "public String getUserAccount(@UserIdInt int userId)", "public void setUserAccount(@UserIdInt int userId, @Nullable String accountName)", "public UserInfo getPrimaryUser()", "public boolean canAddMoreUsers()", "public boolean canAddMoreManagedProfiles(@UserIdInt int userId, boolean allowedToRemoveOne)", "public boolean canAddMoreProfilesToUser(@NonNull String userType, @UserIdInt int userId)", "public List<UserInfo> getProfiles(@UserIdInt int userId)", "public boolean isSameProfileGroup(@NonNull UserHandle user, @NonNull UserHandle otherUser)", "public boolean isSameProfileGroup(@UserIdInt int userId, int otherUserId)", "public List<UserInfo> getEnabledProfiles(@UserIdInt int userId)", "public List<UserHandle> getUserProfiles()", "public List<UserHandle> getEnabledProfiles()", "public List<UserHandle> getAllProfiles()", "private List<UserHandle> getProfiles(boolean enabledOnly)", "public int[] getProfileIds(@UserIdInt int userId, boolean enabledOnly)", "public int[] getProfileIdsWithDisabled(@UserIdInt int userId)", "public int[] getEnabledProfileIds(@UserIdInt int userId)", "public int getCredentialOwnerProfile(@UserIdInt int userId)", "public UserInfo getProfileParent(@UserIdInt int userId)", "public UserHandle getProfileParent(@NonNull UserHandle user)", "public boolean requestQuietModeEnabled(boolean enableQuietMode, @NonNull UserHandle userHandle)", "public boolean requestQuietModeEnabled(boolean enableQuietMode, @NonNull UserHandle userHandle, @QuietModeFlag int flags)", "public boolean requestQuietModeEnabled(boolean enableQuietMode, @NonNull UserHandle userHandle, IntentSender target)", "public boolean requestQuietModeEnabled(boolean enableQuietMode, @NonNull UserHandle userHandle, IntentSender target, int flags)", "public boolean isQuietModeEnabled(UserHandle userHandle)", "public boolean hasBadge(@UserIdInt int userId)", "public boolean hasBadge()", "public int getUserBadgeColor(@UserIdInt int userId)", "public int getUserBadgeDarkColor(@UserIdInt int userId)", "public int getUserIconBadgeResId(@UserIdInt int userId)", "public int getUserBadgeResId(@UserIdInt int userId)", "public int getUserBadgeNoBackgroundResId(@UserIdInt int userId)", "public Drawable getBadgedIconForUser(Drawable icon, UserHandle user)", "public Drawable getBadgedDrawableForUser(Drawable badgedDrawable, UserHandle user, Rect badgeLocation, int badgeDensity)", "public CharSequence getBadgedLabelForUser(CharSequence label, UserHandle user)", "public boolean removeUser(@UserIdInt int userId)", "public boolean removeUser(@NonNull UserHandle user)", "public boolean removeUserEvenWhenDisallowed(@UserIdInt int userId)", "public void setUserName(@UserIdInt int userId, String name)", "public void setUserName(@Nullable String name)", "public void setUserIcon(@UserIdInt int userId, @NonNull Bitmap icon)", "public void setUserIcon(@NonNull Bitmap icon) throws UserOperationException", "public Bitmap getUserIcon(@UserIdInt int userId)", "public Bitmap getUserIcon()", "public static int getMaxSupportedUsers()", "public boolean isUserSwitcherEnabled()", "public boolean isUserSwitcherEnabled(boolean showEvenIfNotActionable)", "private boolean areThereUsersToWhichToSwitch()", "public static boolean isDeviceInDemoMode(Context context)", "public int getUserSerialNumber(@UserIdInt int userId)", "public int getUserHandle(int userSerialNumber)", "public Bundle getApplicationRestrictions(String packageName)", "public Bundle getApplicationRestrictions(String packageName, UserHandle user)", "public void setApplicationRestrictions(String packageName, Bundle restrictions, UserHandle user)", "public boolean setRestrictionsChallenge(String newPin)", "public void setDefaultGuestRestrictions(Bundle restrictions)", "public Bundle getDefaultGuestRestrictions()", "public long getUserCreationTime(UserHandle userHandle)", "public boolean someUserHasSeedAccount(String accountName, String accountType)" ]
}