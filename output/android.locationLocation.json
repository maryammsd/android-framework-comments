{
  "filePath" : "/home/maryam/clearblue/files/android-source-30/android/location/Location.java",
  "packageName" : "android.location",
  "className" : "Location",
  "comment" : "\n * A data class representing a geographic location.\n *\n * <p>A location can consist of a latitude, longitude, timestamp,\n * and other information such as bearing, altitude and velocity.\n *\n * <p>All locations generated by the {@link LocationManager} are\n * guaranteed to have a valid latitude, longitude, and timestamp\n * (both UTC time and elapsed real-time since boot), all other\n * parameters are optional.\n ",
  "variables" : [ {
    "name" : "FORMAT_DEGREES",
    "type" : "int",
    "comment" : "\n     * Constant used to specify formatting of a latitude or longitude\n     * in the form \"[+-]DDD.DDDDD where D indicates degrees.\n     ",
    "links" : [ ]
  }, {
    "name" : "FORMAT_MINUTES",
    "type" : "int",
    "comment" : "\n     * Constant used to specify formatting of a latitude or longitude\n     * in the form \"[+-]DDD:MM.MMMMM\" where D indicates degrees and\n     * M indicates minutes of arc (1 minute = 1/60th of a degree).\n     ",
    "links" : [ ]
  }, {
    "name" : "FORMAT_SECONDS",
    "type" : "int",
    "comment" : "\n     * Constant used to specify formatting of a latitude or longitude\n     * in the form \"DDD:MM:SS.SSSSS\" where D indicates degrees, M\n     * indicates minutes of arc, and S indicates seconds of arc (1\n     * minute = 1/60th of a degree, 1 second = 1/3600th of a degree).\n     ",
    "links" : [ ]
  }, {
    "name" : "EXTRA_NO_GPS_LOCATION",
    "type" : "String",
    "comment" : "\n     * Bundle key for a version of the location containing no GPS data.\n     * Allows location providers to flag locations as being safe to\n     * feed to LocationFudger.\n     *\n     * @hide\n     * @deprecated As of Android R, this extra is longer in use, since it is not necessary to keep\n     * gps locations separate from other locations for coarsening. Providers that do not need to\n     * support platforms below Android R should not use this constant.\n     ",
    "links" : [ ]
  }, {
    "name" : "HAS_ALTITUDE_MASK",
    "type" : "int",
    "comment" : "\n     * Bit mask for mFieldsMask indicating the presence of mAltitude.\n     ",
    "links" : [ ]
  }, {
    "name" : "HAS_SPEED_MASK",
    "type" : "int",
    "comment" : "\n     * Bit mask for mFieldsMask indicating the presence of mSpeed.\n     ",
    "links" : [ ]
  }, {
    "name" : "HAS_BEARING_MASK",
    "type" : "int",
    "comment" : "\n     * Bit mask for mFieldsMask indicating the presence of mBearing.\n     ",
    "links" : [ ]
  }, {
    "name" : "HAS_HORIZONTAL_ACCURACY_MASK",
    "type" : "int",
    "comment" : "\n     * Bit mask for mFieldsMask indicating the presence of mHorizontalAccuracy.\n     ",
    "links" : [ ]
  }, {
    "name" : "HAS_MOCK_PROVIDER_MASK",
    "type" : "int",
    "comment" : "\n     * Bit mask for mFieldsMask indicating location is from a mock provider.\n     ",
    "links" : [ ]
  }, {
    "name" : "HAS_VERTICAL_ACCURACY_MASK",
    "type" : "int",
    "comment" : "\n     * Bit mask for mFieldsMask indicating the presence of mVerticalAccuracy.\n     ",
    "links" : [ ]
  }, {
    "name" : "HAS_SPEED_ACCURACY_MASK",
    "type" : "int",
    "comment" : "\n     * Bit mask for mFieldsMask indicating the presence of mSpeedAccuracy.\n     ",
    "links" : [ ]
  }, {
    "name" : "HAS_BEARING_ACCURACY_MASK",
    "type" : "int",
    "comment" : "\n     * Bit mask for mFieldsMask indicating the presence of mBearingAccuracy.\n     ",
    "links" : [ ]
  }, {
    "name" : "HAS_ELAPSED_REALTIME_UNCERTAINTY_MASK",
    "type" : "int",
    "comment" : "\n     * Bit mask for mFieldsMask indicating the presence of mElapsedRealtimeUncertaintyNanos.\n     ",
    "links" : [ ]
  }, {
    "name" : "sBearingDistanceCache",
    "type" : "ThreadLocal<BearingDistanceCache>",
    "comment" : " on the same thread for caching purposes.",
    "links" : [ ]
  }, {
    "name" : "mProvider",
    "type" : "String",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mTime",
    "type" : "long",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mElapsedRealtimeNanos",
    "type" : "long",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mElapsedRealtimeUncertaintyNanos",
    "type" : "double",
    "comment" : " timestamp, with the reported measurements in nanoseconds (68% confidence).",
    "links" : [ ]
  }, {
    "name" : "mLatitude",
    "type" : "double",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mLongitude",
    "type" : "double",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mAltitude",
    "type" : "double",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mSpeed",
    "type" : "float",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mBearing",
    "type" : "float",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mHorizontalAccuracyMeters",
    "type" : "float",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mVerticalAccuracyMeters",
    "type" : "float",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mSpeedAccuracyMetersPerSecond",
    "type" : "float",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mBearingAccuracyDegrees",
    "type" : "float",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mExtras",
    "type" : "Bundle",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mFieldsMask",
    "type" : "int",
    "comment" : " A bitmask of fields present in this object (see HAS_* constants defined above).",
    "links" : [ ]
  }, {
    "name" : "CREATOR",
    "type" : "Parcelable.Creator<Location>",
    "comment" : "",
    "links" : [ ]
  } ],
  "methods" : [ {
    "name" : "public void set(Location l)",
    "returnType" : "void",
    "comment" : "\n     * Sets the contents of the location to the values from the given location.\n     ",
    "links" : [ ]
  }, {
    "name" : "public void reset()",
    "returnType" : "void",
    "comment" : "\n     * Clears the contents of the location.\n     ",
    "links" : [ ]
  }, {
    "name" : "public static String convert(double coordinate, int outputType)",
    "returnType" : "String",
    "comment" : "\n     * Converts a coordinate to a String representation. The outputType\n     * may be one of FORMAT_DEGREES, FORMAT_MINUTES, or FORMAT_SECONDS.\n     * The coordinate must be a valid double between -180.0 and 180.0.\n     * This conversion is performed in a method that is dependent on the\n     * default locale, and so is not guaranteed to round-trip with\n     * {@link #convert(String)}.\n     *\n     * @throws IllegalArgumentException if coordinate is less than\n     * -180.0, greater than 180.0, or is not a number.\n     * @throws IllegalArgumentException if outputType is not one of\n     * FORMAT_DEGREES, FORMAT_MINUTES, or FORMAT_SECONDS.\n     ",
    "links" : [ "#convert" ]
  }, {
    "name" : "public static double convert(String coordinate)",
    "returnType" : "double",
    "comment" : "\n     * Converts a String in one of the formats described by\n     * FORMAT_DEGREES, FORMAT_MINUTES, or FORMAT_SECONDS into a\n     * double. This conversion is performed in a locale agnostic\n     * method, and so is not guaranteed to round-trip with\n     * {@link #convert(double, int)}.\n     *\n     * @throws NullPointerException if coordinate is null\n     * @throws IllegalArgumentException if the coordinate is not\n     * in one of the valid formats.\n     ",
    "links" : [ "#convert" ]
  }, {
    "name" : "private static void computeDistanceAndBearing(double lat1, double lon1, double lat2, double lon2, BearingDistanceCache results)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public static void distanceBetween(double startLatitude, double startLongitude, double endLatitude, double endLongitude, float[] results)",
    "returnType" : "void",
    "comment" : "\n     * Computes the approximate distance in meters between two\n     * locations, and optionally the initial and final bearings of the\n     * shortest path between them.  Distance and bearing are defined using the\n     * WGS84 ellipsoid.\n     *\n     * <p> The computed distance is stored in results[0].  If results has length\n     * 2 or greater, the initial bearing is stored in results[1]. If results has\n     * length 3 or greater, the final bearing is stored in results[2].\n     *\n     * @param startLatitude the starting latitude\n     * @param startLongitude the starting longitude\n     * @param endLatitude the ending latitude\n     * @param endLongitude the ending longitude\n     * @param results an array of floats to hold the results\n     *\n     * @throws IllegalArgumentException if results is null or has length < 1\n     ",
    "links" : [ ]
  }, {
    "name" : "public float distanceTo(Location dest)",
    "returnType" : "float",
    "comment" : "\n     * Returns the approximate distance in meters between this\n     * location and the given location.  Distance is defined using\n     * the WGS84 ellipsoid.\n     *\n     * @param dest the destination location\n     * @return the approximate distance in meters\n     ",
    "links" : [ ]
  }, {
    "name" : "public float bearingTo(Location dest)",
    "returnType" : "float",
    "comment" : "\n     * Returns the approximate initial bearing in degrees East of true\n     * North when traveling along the shortest path between this\n     * location and the given location.  The shortest path is defined\n     * using the WGS84 ellipsoid.  Locations that are (nearly)\n     * antipodal may produce meaningless results.\n     *\n     * @param dest the destination location\n     * @return the initial bearing in degrees\n     ",
    "links" : [ ]
  }, {
    "name" : "public String getProvider()",
    "returnType" : "String",
    "comment" : "\n     * Returns the name of the provider that generated this fix.\n     *\n     * @return the provider, or null if it has not been set\n     ",
    "links" : [ ]
  }, {
    "name" : "public void setProvider(String provider)",
    "returnType" : "void",
    "comment" : "\n     * Sets the name of the provider that generated this fix.\n     ",
    "links" : [ ]
  }, {
    "name" : "public long getTime()",
    "returnType" : "long",
    "comment" : "\n     * Return the UTC time of this fix, in milliseconds since January 1, 1970.\n     *\n     * <p>Note that the UTC time on a device is not monotonic: it\n     * can jump forwards or backwards unpredictably. So always use\n     * {@link #getElapsedRealtimeNanos} when calculating time deltas.\n     *\n     * <p>On the other hand, {@link #getTime} is useful for presenting\n     * a human readable time to the user, or for carefully comparing\n     * location fixes across reboot or across devices.\n     *\n     * <p>All locations generated by the {@link LocationManager}\n     * are guaranteed to have a valid UTC time, however remember that\n     * the system time may have changed since the location was generated.\n     *\n     * @return time of fix, in milliseconds since January 1, 1970.\n     ",
    "links" : [ "#getElapsedRealtimeNanos", "#getTime", "LocationManager" ]
  }, {
    "name" : "public void setTime(long time)",
    "returnType" : "void",
    "comment" : "\n     * Set the UTC time of this fix, in milliseconds since January 1,\n     * 1970.\n     *\n     * @param time UTC time of this fix, in milliseconds since January 1, 1970\n     ",
    "links" : [ ]
  }, {
    "name" : "public long getElapsedRealtimeNanos()",
    "returnType" : "long",
    "comment" : "\n     * Return the time of this fix, in elapsed real-time since system boot.\n     *\n     * <p>This value can be reliably compared to\n     * {@link android.os.SystemClock#elapsedRealtimeNanos},\n     * to calculate the age of a fix and to compare Location fixes. This\n     * is reliable because elapsed real-time is guaranteed monotonic for\n     * each system boot and continues to increment even when the system\n     * is in deep sleep (unlike {@link #getTime}.\n     *\n     * <p>All locations generated by the {@link LocationManager}\n     * are guaranteed to have a valid elapsed real-time.\n     *\n     * @return elapsed real-time of fix, in nanoseconds since system boot.\n     ",
    "links" : [ "android.os.SystemClock#elapsedRealtimeNanos", "#getTime", "LocationManager" ]
  }, {
    "name" : "public long getElapsedRealtimeAgeNanos(long referenceRealtimeNs)",
    "returnType" : "long",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "public long getElapsedRealtimeAgeNanos()",
    "returnType" : "long",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "public void setElapsedRealtimeNanos(long time)",
    "returnType" : "void",
    "comment" : "\n     * Set the time of this fix, in elapsed real-time since system boot.\n     *\n     * @param time elapsed real-time of fix, in nanoseconds since system boot.\n     ",
    "links" : [ ]
  }, {
    "name" : "public double getElapsedRealtimeUncertaintyNanos()",
    "returnType" : "double",
    "comment" : "\n     * Get estimate of the relative precision of the alignment of the\n     * ElapsedRealtimeNanos timestamp, with the reported measurements in\n     * nanoseconds (68% confidence).\n     *\n     * This means that we have 68% confidence that the true timestamp of the\n     * event is within ElapsedReatimeNanos +/- uncertainty.\n     *\n     * Example :\n     *   - getElapsedRealtimeNanos() returns 10000000\n     *   - getElapsedRealtimeUncertaintyNanos() returns 1000000 (equivalent to 1millisecond)\n     *   This means that the event most likely happened between 9000000 and 11000000.\n     *\n     * @return uncertainty of elapsed real-time of fix, in nanoseconds.\n     ",
    "links" : [ ]
  }, {
    "name" : "public void setElapsedRealtimeUncertaintyNanos(double time)",
    "returnType" : "void",
    "comment" : "\n     * Set estimate of the relative precision of the alignment of the\n     * ElapsedRealtimeNanos timestamp, with the reported measurements in\n     * nanoseconds (68% confidence).\n     *\n     * @param time uncertainty of the elapsed real-time of fix, in nanoseconds.\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean hasElapsedRealtimeUncertaintyNanos()",
    "returnType" : "boolean",
    "comment" : "\n     * True if this location has a elapsed realtime accuracy.\n     ",
    "links" : [ ]
  }, {
    "name" : "public double getLatitude()",
    "returnType" : "double",
    "comment" : "\n     * Get the latitude, in degrees.\n     *\n     * <p>All locations generated by the {@link LocationManager}\n     * will have a valid latitude.\n     ",
    "links" : [ "LocationManager" ]
  }, {
    "name" : "public void setLatitude(double latitude)",
    "returnType" : "void",
    "comment" : "\n     * Set the latitude, in degrees.\n     ",
    "links" : [ ]
  }, {
    "name" : "public double getLongitude()",
    "returnType" : "double",
    "comment" : "\n     * Get the longitude, in degrees.\n     *\n     * <p>All locations generated by the {@link LocationManager}\n     * will have a valid longitude.\n     ",
    "links" : [ "LocationManager" ]
  }, {
    "name" : "public void setLongitude(double longitude)",
    "returnType" : "void",
    "comment" : "\n     * Set the longitude, in degrees.\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean hasAltitude()",
    "returnType" : "boolean",
    "comment" : "\n     * True if this location has an altitude.\n     ",
    "links" : [ ]
  }, {
    "name" : "public double getAltitude()",
    "returnType" : "double",
    "comment" : "\n     * Get the altitude if available, in meters above the WGS 84 reference\n     * ellipsoid.\n     *\n     * <p>If this location does not have an altitude then 0.0 is returned.\n     ",
    "links" : [ ]
  }, {
    "name" : "public void setAltitude(double altitude)",
    "returnType" : "void",
    "comment" : "\n     * Set the altitude, in meters above the WGS 84 reference ellipsoid.\n     *\n     * <p>Following this call {@link #hasAltitude} will return true.\n     ",
    "links" : [ "#hasAltitude" ]
  }, {
    "name" : "public void removeAltitude()",
    "returnType" : "void",
    "comment" : "\n     * Remove the altitude from this location.\n     *\n     * <p>Following this call {@link #hasAltitude} will return false,\n     * and {@link #getAltitude} will return 0.0.\n     *\n     * @deprecated use a new Location object for location updates.\n     ",
    "links" : [ "#hasAltitude", "#getAltitude" ]
  }, {
    "name" : "public boolean hasSpeed()",
    "returnType" : "boolean",
    "comment" : "\n     * True if this location has a speed.\n     ",
    "links" : [ ]
  }, {
    "name" : "public float getSpeed()",
    "returnType" : "float",
    "comment" : "\n     * Get the speed if it is available, in meters/second over ground.\n     *\n     * <p>If this location does not have a speed then 0.0 is returned.\n     ",
    "links" : [ ]
  }, {
    "name" : "public void setSpeed(float speed)",
    "returnType" : "void",
    "comment" : "\n     * Set the speed, in meters/second over ground.\n     *\n     * <p>Following this call {@link #hasSpeed} will return true.\n     ",
    "links" : [ "#hasSpeed" ]
  }, {
    "name" : "public void removeSpeed()",
    "returnType" : "void",
    "comment" : "\n     * Remove the speed from this location.\n     *\n     * <p>Following this call {@link #hasSpeed} will return false,\n     * and {@link #getSpeed} will return 0.0.\n     *\n     * @deprecated use a new Location object for location updates.\n     ",
    "links" : [ "#hasSpeed", "#getSpeed" ]
  }, {
    "name" : "public boolean hasBearing()",
    "returnType" : "boolean",
    "comment" : "\n     * True if this location has a bearing.\n     ",
    "links" : [ ]
  }, {
    "name" : "public float getBearing()",
    "returnType" : "float",
    "comment" : "\n     * Get the bearing, in degrees.\n     *\n     * <p>Bearing is the horizontal direction of travel of this device,\n     * and is not related to the device orientation. It is guaranteed to\n     * be in the range (0.0, 360.0] if the device has a bearing.\n     *\n     * <p>If this location does not have a bearing then 0.0 is returned.\n     ",
    "links" : [ ]
  }, {
    "name" : "public void setBearing(float bearing)",
    "returnType" : "void",
    "comment" : "\n     * Set the bearing, in degrees.\n     *\n     * <p>Bearing is the horizontal direction of travel of this device,\n     * and is not related to the device orientation.\n     *\n     * <p>The input will be wrapped into the range (0.0, 360.0].\n     ",
    "links" : [ ]
  }, {
    "name" : "public void removeBearing()",
    "returnType" : "void",
    "comment" : "\n     * Remove the bearing from this location.\n     *\n     * <p>Following this call {@link #hasBearing} will return false,\n     * and {@link #getBearing} will return 0.0.\n     *\n     * @deprecated use a new Location object for location updates.\n     ",
    "links" : [ "#hasBearing", "#getBearing" ]
  }, {
    "name" : "public boolean hasAccuracy()",
    "returnType" : "boolean",
    "comment" : "\n     * True if this location has a horizontal accuracy.\n     *\n     * <p>All locations generated by the {@link LocationManager} have an horizontal accuracy.\n     ",
    "links" : [ "LocationManager" ]
  }, {
    "name" : "public float getAccuracy()",
    "returnType" : "float",
    "comment" : "\n     * Get the estimated horizontal accuracy of this location, radial, in meters.\n     *\n     * <p>We define horizontal accuracy as the radius of 68% confidence. In other\n     * words, if you draw a circle centered at this location's\n     * latitude and longitude, and with a radius equal to the accuracy,\n     * then there is a 68% probability that the true location is inside\n     * the circle.\n     *\n     * <p>This accuracy estimation is only concerned with horizontal\n     * accuracy, and does not indicate the accuracy of bearing,\n     * velocity or altitude if those are included in this Location.\n     *\n     * <p>If this location does not have a horizontal accuracy, then 0.0 is returned.\n     * All locations generated by the {@link LocationManager} include horizontal accuracy.\n     ",
    "links" : [ "LocationManager" ]
  }, {
    "name" : "public void setAccuracy(float horizontalAccuracy)",
    "returnType" : "void",
    "comment" : "\n     * Set the estimated horizontal accuracy of this location, meters.\n     *\n     * <p>See {@link #getAccuracy} for the definition of horizontal accuracy.\n     *\n     * <p>Following this call {@link #hasAccuracy} will return true.\n     ",
    "links" : [ "#getAccuracy", "#hasAccuracy" ]
  }, {
    "name" : "public void removeAccuracy()",
    "returnType" : "void",
    "comment" : "\n     * Remove the horizontal accuracy from this location.\n     *\n     * <p>Following this call {@link #hasAccuracy} will return false, and\n     * {@link #getAccuracy} will return 0.0.\n     *\n     * @deprecated use a new Location object for location updates.\n     ",
    "links" : [ "#hasAccuracy", "#getAccuracy" ]
  }, {
    "name" : "public boolean hasVerticalAccuracy()",
    "returnType" : "boolean",
    "comment" : "\n     * True if this location has a vertical accuracy.\n     ",
    "links" : [ ]
  }, {
    "name" : "public float getVerticalAccuracyMeters()",
    "returnType" : "float",
    "comment" : "\n     * Get the estimated vertical accuracy of this location, in meters.\n     *\n     * <p>We define vertical accuracy at 68% confidence.  Specifically, as 1-side of the\n     * 2-sided range above and below the estimated altitude reported by {@link #getAltitude()},\n     * within which there is a 68% probability of finding the true altitude.\n     *\n     * <p>In the case where the underlying distribution is assumed Gaussian normal, this would be\n     * considered 1 standard deviation.\n     *\n     * <p>For example, if {@link #getAltitude()} returns 150, and\n     * {@link #getVerticalAccuracyMeters()} returns 20 then there is a 68% probability\n     * of the true altitude being between 130 and 170 meters.\n     *\n     * <p>If this location does not have a vertical accuracy, then 0.0 is returned.\n     ",
    "links" : [ "#getAltitude", "#getAltitude", "#getVerticalAccuracyMeters" ]
  }, {
    "name" : "public void setVerticalAccuracyMeters(float verticalAccuracyMeters)",
    "returnType" : "void",
    "comment" : "\n     * Set the estimated vertical accuracy of this location, meters.\n     *\n     * <p>See {@link #getVerticalAccuracyMeters} for the definition of vertical accuracy.\n     *\n     * <p>Following this call {@link #hasVerticalAccuracy} will return true.\n     ",
    "links" : [ "#getVerticalAccuracyMeters", "#hasVerticalAccuracy" ]
  }, {
    "name" : "public void removeVerticalAccuracy()",
    "returnType" : "void",
    "comment" : "\n     * Remove the vertical accuracy from this location.\n     *\n     * <p>Following this call {@link #hasVerticalAccuracy} will return false, and\n     * {@link #getVerticalAccuracyMeters} will return 0.0.\n     *\n     * @deprecated use a new Location object for location updates.\n     * @removed\n     ",
    "links" : [ "#hasVerticalAccuracy", "#getVerticalAccuracyMeters" ]
  }, {
    "name" : "public boolean hasSpeedAccuracy()",
    "returnType" : "boolean",
    "comment" : "\n     * True if this location has a speed accuracy.\n     ",
    "links" : [ ]
  }, {
    "name" : "public float getSpeedAccuracyMetersPerSecond()",
    "returnType" : "float",
    "comment" : "\n     * Get the estimated speed accuracy of this location, in meters per second.\n     *\n     * <p>We define speed accuracy at 68% confidence.  Specifically, as 1-side of the\n     * 2-sided range above and below the estimated speed reported by {@link #getSpeed()},\n     * within which there is a 68% probability of finding the true speed.\n     *\n     * <p>In the case where the underlying\n     * distribution is assumed Gaussian normal, this would be considered 1 standard deviation.\n     *\n     * <p>For example, if {@link #getSpeed()} returns 5, and\n     * {@link #getSpeedAccuracyMetersPerSecond()} returns 1, then there is a 68% probability of\n     * the true speed being between 4 and 6 meters per second.\n     *\n     * <p>Note that the speed and speed accuracy is often better than would be obtained simply from\n     * differencing sequential positions, such as when the Doppler measurements from GNSS satellites\n     * are used.\n     *\n     * <p>If this location does not have a speed accuracy, then 0.0 is returned.\n     ",
    "links" : [ "#getSpeed", "#getSpeed", "#getSpeedAccuracyMetersPerSecond" ]
  }, {
    "name" : "public void setSpeedAccuracyMetersPerSecond(float speedAccuracyMeterPerSecond)",
    "returnType" : "void",
    "comment" : "\n     * Set the estimated speed accuracy of this location, meters per second.\n     *\n     * <p>See {@link #getSpeedAccuracyMetersPerSecond} for the definition of speed accuracy.\n     *\n     * <p>Following this call {@link #hasSpeedAccuracy} will return true.\n     ",
    "links" : [ "#getSpeedAccuracyMetersPerSecond", "#hasSpeedAccuracy" ]
  }, {
    "name" : "public void removeSpeedAccuracy()",
    "returnType" : "void",
    "comment" : "\n     * Remove the speed accuracy from this location.\n     *\n     * <p>Following this call {@link #hasSpeedAccuracy} will return false, and\n     * {@link #getSpeedAccuracyMetersPerSecond} will return 0.0.\n     *\n     * @deprecated use a new Location object for location updates.\n     * @removed\n     ",
    "links" : [ "#hasSpeedAccuracy", "#getSpeedAccuracyMetersPerSecond" ]
  }, {
    "name" : "public boolean hasBearingAccuracy()",
    "returnType" : "boolean",
    "comment" : "\n     * True if this location has a bearing accuracy.\n     ",
    "links" : [ ]
  }, {
    "name" : "public float getBearingAccuracyDegrees()",
    "returnType" : "float",
    "comment" : "\n     * Get the estimated bearing accuracy of this location, in degrees.\n     *\n     * <p>We define bearing accuracy at 68% confidence.  Specifically, as 1-side of the\n     * 2-sided range on each side of the estimated bearing reported by {@link #getBearing()},\n     * within which there is a 68% probability of finding the true bearing.\n     *\n     * <p>In the case where the underlying distribution is assumed Gaussian normal, this would be\n     * considered 1 standard deviation.\n     *\n     * <p>For example, if {@link #getBearing()} returns 60, and\n     * {@link #getBearingAccuracyDegrees()} returns 10, then there is a 68% probability of the\n     * true bearing being between 50 and 70 degrees.\n     *\n     * <p>If this location does not have a bearing accuracy, then 0.0 is returned.\n     ",
    "links" : [ "#getBearing", "#getBearing", "#getBearingAccuracyDegrees" ]
  }, {
    "name" : "public void setBearingAccuracyDegrees(float bearingAccuracyDegrees)",
    "returnType" : "void",
    "comment" : "\n     * Set the estimated bearing accuracy of this location, degrees.\n     *\n     * <p>See {@link #getBearingAccuracyDegrees} for the definition of bearing accuracy.\n     *\n     * <p>Following this call {@link #hasBearingAccuracy} will return true.\n     ",
    "links" : [ "#getBearingAccuracyDegrees", "#hasBearingAccuracy" ]
  }, {
    "name" : "public void removeBearingAccuracy()",
    "returnType" : "void",
    "comment" : "\n     * Remove the bearing accuracy from this location.\n     *\n     * <p>Following this call {@link #hasBearingAccuracy} will return false, and\n     * {@link #getBearingAccuracyDegrees} will return 0.0.\n     *\n     * @deprecated use a new Location object for location updates.\n     * @removed\n     ",
    "links" : [ "#hasBearingAccuracy", "#getBearingAccuracyDegrees" ]
  }, {
    "name" : "public boolean isComplete()",
    "returnType" : "boolean",
    "comment" : "\n     * Return true if this Location object is complete.\n     *\n     * <p>A location object is currently considered complete if it has\n     * a valid provider, accuracy, wall-clock time and elapsed real-time.\n     *\n     * <p>All locations supplied by the {@link LocationManager} to\n     * applications must be complete.\n     *\n     * @see #makeComplete\n     * @hide\n     ",
    "links" : [ "LocationManager" ]
  }, {
    "name" : "public void makeComplete()",
    "returnType" : "void",
    "comment" : "\n     * Helper to fill incomplete fields.\n     *\n     * <p>Used to assist in backwards compatibility with\n     * Location objects received from applications.\n     *\n     * @see #isComplete\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public Bundle getExtras()",
    "returnType" : "Bundle",
    "comment" : "\n     * Returns additional provider-specific information about the\n     * location fix as a Bundle.  The keys and values are determined\n     * by the provider.  If no additional information is available,\n     * null is returned.\n     *\n     * <p> A number of common key/value pairs are listed\n     * below. Providers that use any of the keys on this list must\n     * provide the corresponding value as described below.\n     *\n     * <ul>\n     * <li> satellites - the number of satellites used to derive the fix\n     * </ul>\n     ",
    "links" : [ ]
  }, {
    "name" : "public void setExtras(Bundle extras)",
    "returnType" : "void",
    "comment" : "\n     * Sets the extra information associated with this fix to the\n     * given Bundle.\n     *\n     * <p>Note this stores a copy of the given extras, so any changes to extras after calling this\n     * method won't be reflected in the location bundle.\n     ",
    "links" : [ ]
  }, {
    "name" : "public String toString()",
    "returnType" : "String",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public void dump(Printer pw, String prefix)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public int describeContents()",
    "returnType" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public void writeToParcel(Parcel parcel, int flags)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public Location getExtraLocation(String key)",
    "returnType" : "Location",
    "comment" : "\n     * Returns one of the optional extra {@link Location}s that can be attached\n     * to this Location.\n     *\n     * @param key the key associated with the desired extra Location\n     * @return the extra Location, or null if unavailable\n     * @hide\n     ",
    "links" : [ "Location" ]
  }, {
    "name" : "public boolean isFromMockProvider()",
    "returnType" : "boolean",
    "comment" : "\n     * Returns true if the Location came from a mock provider.\n     *\n     * @return true if this Location came from a mock provider, false otherwise\n     ",
    "links" : [ ]
  }, {
    "name" : "public void setIsFromMockProvider(boolean isFromMockProvider)",
    "returnType" : "void",
    "comment" : "\n     * Flag this Location as having come from a mock provider or not.\n     *\n     * @param isFromMockProvider true if this Location came from a mock provider, false otherwise\n     * @hide\n     ",
    "links" : [ ]
  } ],
  "variableNames" : [ "FORMAT_DEGREES", "FORMAT_MINUTES", "FORMAT_SECONDS", "EXTRA_NO_GPS_LOCATION", "HAS_ALTITUDE_MASK", "HAS_SPEED_MASK", "HAS_BEARING_MASK", "HAS_HORIZONTAL_ACCURACY_MASK", "HAS_MOCK_PROVIDER_MASK", "HAS_VERTICAL_ACCURACY_MASK", "HAS_SPEED_ACCURACY_MASK", "HAS_BEARING_ACCURACY_MASK", "HAS_ELAPSED_REALTIME_UNCERTAINTY_MASK", "sBearingDistanceCache", "mProvider", "mTime", "mElapsedRealtimeNanos", "mElapsedRealtimeUncertaintyNanos", "mLatitude", "mLongitude", "mAltitude", "mSpeed", "mBearing", "mHorizontalAccuracyMeters", "mVerticalAccuracyMeters", "mSpeedAccuracyMetersPerSecond", "mBearingAccuracyDegrees", "mExtras", "mFieldsMask", "CREATOR" ],
  "methodNames" : [ "public void set(Location l)", "public void reset()", "public static String convert(double coordinate, int outputType)", "public static double convert(String coordinate)", "private static void computeDistanceAndBearing(double lat1, double lon1, double lat2, double lon2, BearingDistanceCache results)", "public static void distanceBetween(double startLatitude, double startLongitude, double endLatitude, double endLongitude, float[] results)", "public float distanceTo(Location dest)", "public float bearingTo(Location dest)", "public String getProvider()", "public void setProvider(String provider)", "public long getTime()", "public void setTime(long time)", "public long getElapsedRealtimeNanos()", "public long getElapsedRealtimeAgeNanos(long referenceRealtimeNs)", "public long getElapsedRealtimeAgeNanos()", "public void setElapsedRealtimeNanos(long time)", "public double getElapsedRealtimeUncertaintyNanos()", "public void setElapsedRealtimeUncertaintyNanos(double time)", "public boolean hasElapsedRealtimeUncertaintyNanos()", "public double getLatitude()", "public void setLatitude(double latitude)", "public double getLongitude()", "public void setLongitude(double longitude)", "public boolean hasAltitude()", "public double getAltitude()", "public void setAltitude(double altitude)", "public void removeAltitude()", "public boolean hasSpeed()", "public float getSpeed()", "public void setSpeed(float speed)", "public void removeSpeed()", "public boolean hasBearing()", "public float getBearing()", "public void setBearing(float bearing)", "public void removeBearing()", "public boolean hasAccuracy()", "public float getAccuracy()", "public void setAccuracy(float horizontalAccuracy)", "public void removeAccuracy()", "public boolean hasVerticalAccuracy()", "public float getVerticalAccuracyMeters()", "public void setVerticalAccuracyMeters(float verticalAccuracyMeters)", "public void removeVerticalAccuracy()", "public boolean hasSpeedAccuracy()", "public float getSpeedAccuracyMetersPerSecond()", "public void setSpeedAccuracyMetersPerSecond(float speedAccuracyMeterPerSecond)", "public void removeSpeedAccuracy()", "public boolean hasBearingAccuracy()", "public float getBearingAccuracyDegrees()", "public void setBearingAccuracyDegrees(float bearingAccuracyDegrees)", "public void removeBearingAccuracy()", "public boolean isComplete()", "public void makeComplete()", "public Bundle getExtras()", "public void setExtras(Bundle extras)", "public String toString()", "public void dump(Printer pw, String prefix)", "public int describeContents()", "public void writeToParcel(Parcel parcel, int flags)", "public Location getExtraLocation(String key)", "public boolean isFromMockProvider()", "public void setIsFromMockProvider(boolean isFromMockProvider)" ]
}