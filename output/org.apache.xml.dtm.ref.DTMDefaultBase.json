{
  "filePath" : "/home/maryam/clearblue/files/android-source-35/org/apache/xml/dtm/ref/DTMDefaultBase.java",
  "packageName" : "org.apache.xml.dtm.ref",
  "className" : "DTMDefaultBase",
  "comment" : "\n * The <code>DTMDefaultBase</code> class serves as a helper base for DTMs.\n * It sets up structures for navigation and type, while leaving data\n * management and construction to the derived classes.\n ",
  "links" : [ ],
  "variables" : [ {
    "name" : "JJK_DEBUG",
    "type" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "ROOTNODE",
    "type" : "int",
    "comment" : " The identity of the root node. ",
    "links" : [ ]
  }, {
    "name" : "m_size",
    "type" : "int",
    "comment" : "\n   * The number of nodes, which is also used to determine the next\n   *  node index.\n   ",
    "links" : [ ]
  }, {
    "name" : "m_exptype",
    "type" : "SuballocatedIntVector",
    "comment" : " The expanded names, one array element for each node. ",
    "links" : [ ]
  }, {
    "name" : "m_firstch",
    "type" : "SuballocatedIntVector",
    "comment" : " First child values, one array element for each node. ",
    "links" : [ ]
  }, {
    "name" : "m_nextsib",
    "type" : "SuballocatedIntVector",
    "comment" : " Next sibling values, one array element for each node. ",
    "links" : [ ]
  }, {
    "name" : "m_prevsib",
    "type" : "SuballocatedIntVector",
    "comment" : " Previous sibling values, one array element for each node. ",
    "links" : [ ]
  }, {
    "name" : "m_parent",
    "type" : "SuballocatedIntVector",
    "comment" : " Previous sibling values, one array element for each node. ",
    "links" : [ ]
  }, {
    "name" : "m_namespaceDeclSets",
    "type" : "Vector",
    "comment" : " Vector of SuballocatedIntVectors of NS decl sets ",
    "links" : [ ]
  }, {
    "name" : "m_namespaceDeclSetElements",
    "type" : "SuballocatedIntVector",
    "comment" : " SuballocatedIntVector  of elements at which corresponding\n   * namespaceDeclSets were defined ",
    "links" : [ ]
  }, {
    "name" : "m_elemIndexes",
    "type" : "int[][][]",
    "comment" : "\n   * These hold indexes to elements based on namespace and local name.\n   * The base lookup is the the namespace.  The second lookup is the local\n   * name, and the last array contains the the first free element\n   * at the start, and the list of element handles following.\n   ",
    "links" : [ ]
  }, {
    "name" : "DEFAULT_BLOCKSIZE",
    "type" : "int",
    "comment" : " favor small docs.",
    "links" : [ ]
  }, {
    "name" : "DEFAULT_NUMBLOCKS",
    "type" : "int",
    "comment" : " The number of blocks for the node arrays ",
    "links" : [ ]
  }, {
    "name" : "DEFAULT_NUMBLOCKS_SMALL",
    "type" : "int",
    "comment" : " The number of blocks used for small documents & RTFs ",
    "links" : [ ]
  }, {
    "name" : "NOTPROCESSED",
    "type" : "int",
    "comment" : "\n   * The value to use when the information has not been built yet.\n   ",
    "links" : [ ]
  }, {
    "name" : "m_mgr",
    "type" : "DTMManager",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "m_mgrDefault",
    "type" : "DTMManagerDefault",
    "comment" : "\n   * m_mgr cast to DTMManagerDefault, or null if it isn't an instance\n   * (Efficiency hook)\n   ",
    "links" : [ ]
  }, {
    "name" : "m_dtmIdent",
    "type" : "SuballocatedIntVector",
    "comment" : " The document identity number(s). If we have overflowed the addressing\n   * range of the first that was assigned to us, we may add others. ",
    "links" : [ ]
  }, {
    "name" : "m_documentBaseURI",
    "type" : "String",
    "comment" : " The base URI for this document. ",
    "links" : [ ]
  }, {
    "name" : "m_wsfilter",
    "type" : "DTMWSFilter",
    "comment" : "\n   * The whitespace filter that enables elements to strip whitespace or not.\n   ",
    "links" : [ ]
  }, {
    "name" : "m_shouldStripWS",
    "type" : "boolean",
    "comment" : " Flag indicating whether to strip whitespace nodes ",
    "links" : [ ]
  }, {
    "name" : "m_shouldStripWhitespaceStack",
    "type" : "BoolStack",
    "comment" : " Stack of flags indicating whether to strip whitespace nodes ",
    "links" : [ ]
  }, {
    "name" : "m_xstrf",
    "type" : "XMLStringFactory",
    "comment" : " The XMLString factory for creating XMLStrings. ",
    "links" : [ ]
  }, {
    "name" : "m_expandedNameTable",
    "type" : "ExpandedNameTable",
    "comment" : "\n   * The table for exandedNameID lookups.  This may or may not be the same\n   * table as is contained in the DTMManagerDefault.\n   ",
    "links" : [ ]
  }, {
    "name" : "m_indexing",
    "type" : "boolean",
    "comment" : " true if indexing is turned on. ",
    "links" : [ ]
  }, {
    "name" : "m_traversers",
    "type" : "DTMAxisTraverser[]",
    "comment" : " Stateless axis traversers, lazely built. ",
    "links" : [ ]
  }, {
    "name" : "m_namespaceLists",
    "type" : "Vector",
    "comment" : " on demand",
    "links" : [ ]
  } ],
  "methods" : [ {
    "name" : "protected void ensureSizeOfIndex(int namespaceID, int LocalNameID)",
    "returnType" : "void",
    "comment" : "\n   * Ensure that the size of the element indexes can hold the information.\n   *\n   * @param namespaceID Namespace ID index.\n   * @param LocalNameID Local name ID.\n   ",
    "links" : [ ]
  }, {
    "name" : "protected void indexNode(int expandedTypeID, int identity)",
    "returnType" : "void",
    "comment" : "\n   * Add a node to the element indexes. The node will not be added unless\n   * it's an element.\n   *\n   * @param expandedTypeID The expanded type ID of the node.\n   * @param identity The node identity index.\n   ",
    "links" : [ ]
  }, {
    "name" : "protected int findGTE(int[] list, int start, int len, int value)",
    "returnType" : "int",
    "comment" : "\n   * Find the first index that occurs in the list that is greater than or\n   * equal to the given value.\n   *\n   * @param list A list of integers.\n   * @param start The start index to begin the search.\n   * @param len The number of items to search.\n   * @param value Find the slot that has a value that is greater than or\n   * identical to this argument.\n   *\n   * @return The index in the list of the slot that is higher or identical\n   * to the identity argument, or -1 if no node is higher or equal.\n   ",
    "links" : [ ]
  }, {
    "name" : " int findElementFromIndex(int nsIndex, int lnIndex, int firstPotential)",
    "returnType" : "int",
    "comment" : "\n   * Find the first matching element from the index at or after the\n   * given node.\n   *\n   * @param nsIndex The namespace index lookup.\n   * @param lnIndex The local name index lookup.\n   * @param firstPotential The first potential match that is worth looking at.\n   *\n   * @return The first node that is greater than or equal to the\n   *         firstPotential argument, or DTM.NOTPROCESSED if not found.\n   ",
    "links" : [ ]
  }, {
    "name" : "protected abstract int getNextNodeIdentity(int identity)",
    "returnType" : "int",
    "comment" : "\n   * Get the next node identity value in the list, and call the iterator\n   * if it hasn't been added yet.\n   *\n   * @param identity The node identity (index).\n   * @return identity+1, or DTM.NULL.\n   ",
    "links" : [ ]
  }, {
    "name" : "protected abstract boolean nextNode()",
    "returnType" : "boolean",
    "comment" : "\n   * This method should try and build one or more nodes in the table.\n   *\n   * @return The true if a next node is found or false if\n   *         there are no more nodes.\n   ",
    "links" : [ ]
  }, {
    "name" : "protected abstract int getNumberOfNodes()",
    "returnType" : "int",
    "comment" : "\n   * Get the number of nodes that have been added.\n   *\n   * @return the number of nodes that have been mapped.\n   ",
    "links" : [ ]
  }, {
    "name" : "protected short _type(int identity)",
    "returnType" : "short",
    "comment" : "\n   * Get the simple type ID for the given node identity.\n   *\n   * @param identity The node identity.\n   *\n   * @return The simple type ID, or DTM.NULL.\n   ",
    "links" : [ ]
  }, {
    "name" : "protected int _exptype(int identity)",
    "returnType" : "int",
    "comment" : "\n   * Get the expanded type ID for the given node identity.\n   *\n   * @param identity The node identity.\n   *\n   * @return The expanded type ID, or DTM.NULL.\n   ",
    "links" : [ ]
  }, {
    "name" : "protected int _level(int identity)",
    "returnType" : "int",
    "comment" : "\n   * Get the level in the tree for the given node identity.\n   *\n   * @param identity The node identity.\n   *\n   * @return The tree level, or DTM.NULL.\n   ",
    "links" : [ ]
  }, {
    "name" : "protected int _firstch(int identity)",
    "returnType" : "int",
    "comment" : "\n   * Get the first child for the given node identity.\n   *\n   * @param identity The node identity.\n   *\n   * @return The first child identity, or DTM.NULL.\n   ",
    "links" : [ ]
  }, {
    "name" : "protected int _nextsib(int identity)",
    "returnType" : "int",
    "comment" : "\n   * Get the next sibling for the given node identity.\n   *\n   * @param identity The node identity.\n   *\n   * @return The next sibling identity, or DTM.NULL.\n   ",
    "links" : [ ]
  }, {
    "name" : "protected int _prevsib(int identity)",
    "returnType" : "int",
    "comment" : "\n   * Get the previous sibling for the given node identity.\n   *\n   * @param identity The node identity.\n   *\n   * @return The previous sibling identity, or DTM.NULL.\n   ",
    "links" : [ ]
  }, {
    "name" : "protected int _parent(int identity)",
    "returnType" : "int",
    "comment" : "\n   * Get the parent for the given node identity.\n   *\n   * @param identity The node identity.\n   *\n   * @return The parent identity, or DTM.NULL.\n   ",
    "links" : [ ]
  }, {
    "name" : "public void dumpDTM(OutputStream os)",
    "returnType" : "void",
    "comment" : "\n   * Diagnostics function to dump the DTM.\n   ",
    "links" : [ ]
  }, {
    "name" : "public String dumpNode(int nodeHandle)",
    "returnType" : "String",
    "comment" : "\n   * Diagnostics function to dump a single node.\n   * \n   * %REVIEW% KNOWN GLITCH: If you pass it a node index rather than a \n   * node handle, it works just fine... but the displayed identity \n   * number before the colon is different, which complicates comparing\n   * it with nodes printed the other way. We could always OR the DTM ID\n   * into the value, to suppress that distinction...\n   * \n   * %REVIEW% This might want to be moved up to DTMDefaultBase, or possibly\n   * DTM itself, since it's a useful diagnostic and uses only DTM's public\n   * APIs.\n   ",
    "links" : [ ]
  }, {
    "name" : "public void setFeature(String featureId, boolean state)",
    "returnType" : "void",
    "comment" : "\n   * Set an implementation dependent feature.\n   * <p>\n   * %REVIEW% Do we really expect to set features on DTMs?\n   *\n   * @param featureId A feature URL.\n   * @param state true if this feature should be on, false otherwise.\n   ",
    "links" : [ ]
  }, {
    "name" : "public boolean hasChildNodes(int nodeHandle)",
    "returnType" : "boolean",
    "comment" : "\n   * Given a node handle, test if it has child nodes.\n   * <p> %REVIEW% This is obviously useful at the DOM layer, where it\n   * would permit testing this without having to create a proxy\n   * node. It's less useful in the DTM API, where\n   * (dtm.getFirstChild(nodeHandle)!=DTM.NULL) is just as fast and\n   * almost as self-evident. But it's a convenience, and eases porting\n   * of DOM code to DTM.  </p>\n   *\n   * @param nodeHandle int Handle of the node.\n   * @return int true if the given node has child nodes.\n   ",
    "links" : [ ]
  }, {
    "name" : "public final int makeNodeHandle(int nodeIdentity)",
    "returnType" : "int",
    "comment" : " Given a node identity, return a node handle. If extended addressing\n   * has been used (multiple DTM IDs), we need to map the high bits of the\n   * identity into the proper DTM ID.\n   * \n   * This has been made FINAL to facilitate inlining, since we do not expect\n   * any subclass of DTMDefaultBase to ever change the algorithm. (I don't\n   * really like doing so, and would love to have an excuse not to...)\n   * \n   * %REVIEW% Is it worth trying to specialcase small documents?\n   * %REVIEW% Should this be exposed at the package/public layers?\n   * \n   * @param nodeIdentity Internal offset to this node's records.\n   * @return NodeHandle (external representation of node)\n   * ",
    "links" : [ ]
  }, {
    "name" : "public final int makeNodeIdentity(int nodeHandle)",
    "returnType" : "int",
    "comment" : " Given a node handle, return a node identity. If extended addressing\n   * has been used (multiple DTM IDs), we need to map the high bits of the\n   * identity into the proper DTM ID and thence find the proper offset\n   * to add to the low bits of the identity\n   * \n   * This has been made FINAL to facilitate inlining, since we do not expect\n   * any subclass of DTMDefaultBase to ever change the algorithm. (I don't\n   * really like doing so, and would love to have an excuse not to...)\n   * \n   * %OPT% Performance is critical for this operation.\n   *\n   * %REVIEW% Should this be exposed at the package/public layers?\n   * \n   * @param nodeHandle (external representation of node)\n   * @return nodeIdentity Internal offset to this node's records.\n   * ",
    "links" : [ ]
  }, {
    "name" : "public int getFirstChild(int nodeHandle)",
    "returnType" : "int",
    "comment" : "\n   * Given a node handle, get the handle of the node's first child.\n   * If not yet resolved, waits for more nodes to be added to the document and\n   * tries again.\n   *\n   * @param nodeHandle int Handle of the node.\n   * @return int DTM node-number of first child, or DTM.NULL to indicate none exists.\n   ",
    "links" : [ ]
  }, {
    "name" : "public int getTypedFirstChild(int nodeHandle, int nodeType)",
    "returnType" : "int",
    "comment" : "\n   * Given a node handle, get the handle of the node's first child.\n   * If not yet resolved, waits for more nodes to be added to the document and\n   * tries again.\n   *\n   * @param nodeHandle int Handle of the node.\n   * @return int DTM node-number of first child, or DTM.NULL to indicate none exists.\n   ",
    "links" : [ ]
  }, {
    "name" : "public int getLastChild(int nodeHandle)",
    "returnType" : "int",
    "comment" : "\n   * Given a node handle, advance to its last child.\n   * If not yet resolved, waits for more nodes to be added to the document and\n   * tries again.\n   *\n   * @param nodeHandle int Handle of the node.\n   * @return int Node-number of last child,\n   * or DTM.NULL to indicate none exists.\n   ",
    "links" : [ ]
  }, {
    "name" : "public abstract int getAttributeNode(int nodeHandle, String namespaceURI, String name)",
    "returnType" : "int",
    "comment" : "\n   * Retrieves an attribute node by by qualified name and namespace URI.\n   *\n   * @param nodeHandle int Handle of the node upon which to look up this attribute..\n   * @param namespaceURI The namespace URI of the attribute to\n   *   retrieve, or null.\n   * @param name The local name of the attribute to\n   *   retrieve.\n   * @return The attribute node handle with the specified name (\n   *   <code>nodeName</code>) or <code>DTM.NULL</code> if there is no such\n   *   attribute.\n   ",
    "links" : [ ]
  }, {
    "name" : "public int getFirstAttribute(int nodeHandle)",
    "returnType" : "int",
    "comment" : "\n   * Given a node handle, get the index of the node's first attribute.\n   *\n   * @param nodeHandle int Handle of the node.\n   * @return Handle of first attribute, or DTM.NULL to indicate none exists.\n   ",
    "links" : [ ]
  }, {
    "name" : "protected int getFirstAttributeIdentity(int identity)",
    "returnType" : "int",
    "comment" : "\n   * Given a node identity, get the index of the node's first attribute.\n   *\n   * @param identity int identity of the node.\n   * @return Identity of first attribute, or DTM.NULL to indicate none exists.\n   ",
    "links" : [ ]
  }, {
    "name" : "protected int getTypedAttribute(int nodeHandle, int attType)",
    "returnType" : "int",
    "comment" : "\n   * Given a node handle and an expanded type ID, get the index of the node's\n   * attribute of that type, if any.\n   *\n   * @param nodeHandle int Handle of the node.\n   * @param attType int expanded type ID of the required attribute.\n   * @return Handle of attribute of the required type, or DTM.NULL to indicate\n   * none exists.\n   ",
    "links" : [ ]
  }, {
    "name" : "public int getNextSibling(int nodeHandle)",
    "returnType" : "int",
    "comment" : "\n   * Given a node handle, advance to its next sibling.\n   * If not yet resolved, waits for more nodes to be added to the document and\n   * tries again.\n   * @param nodeHandle int Handle of the node.\n   * @return int Node-number of next sibling,\n   * or DTM.NULL to indicate none exists.\n   ",
    "links" : [ ]
  }, {
    "name" : "public int getTypedNextSibling(int nodeHandle, int nodeType)",
    "returnType" : "int",
    "comment" : "\n   * Given a node handle, advance to its next sibling.\n   * If not yet resolved, waits for more nodes to be added to the document and\n   * tries again.\n   * @param nodeHandle int Handle of the node.\n   * @return int Node-number of next sibling,\n   * or DTM.NULL to indicate none exists.\n   ",
    "links" : [ ]
  }, {
    "name" : "public int getPreviousSibling(int nodeHandle)",
    "returnType" : "int",
    "comment" : "\n   * Given a node handle, find its preceeding sibling.\n   * WARNING: DTM is asymmetric; this operation is resolved by search, and is\n   * relatively expensive.\n   *\n   * @param nodeHandle the id of the node.\n   * @return int Node-number of the previous sib,\n   * or DTM.NULL to indicate none exists.\n   ",
    "links" : [ ]
  }, {
    "name" : "public int getNextAttribute(int nodeHandle)",
    "returnType" : "int",
    "comment" : "\n   * Given a node handle, advance to the next attribute.\n   * If an attr, we advance to\n   * the next attr on the same node.  If not an attribute, we return NULL.\n   *\n   * @param nodeHandle int Handle of the node.\n   * @return int DTM node-number of the resolved attr,\n   * or DTM.NULL to indicate none exists.\n   ",
    "links" : [ ]
  }, {
    "name" : "protected int getNextAttributeIdentity(int identity)",
    "returnType" : "int",
    "comment" : "\n   * Given a node identity for an attribute, advance to the next attribute.\n   *\n   * @param identity int identity of the attribute node.  This\n   * <strong>must</strong> be an attribute node.\n   *\n   * @return int DTM node-identity of the resolved attr,\n   * or DTM.NULL to indicate none exists.\n   *\n   ",
    "links" : [ ]
  }, {
    "name" : "protected void declareNamespaceInContext(int elementNodeIndex, int namespaceNodeIndex)",
    "returnType" : "void",
    "comment" : " Build table of namespace declaration\n   * locations during DTM construction. Table is a Vector of\n   * SuballocatedIntVectors containing the namespace node HANDLES declared at\n   * that ID, plus an SuballocatedIntVector of the element node INDEXES at which\n   * these declarations appeared.\n   *\n   * NOTE: Since this occurs during model build, nodes will be encountered\n   * in doucment order and thus the table will be ordered by element,\n   * permitting binary-search as a possible retrieval optimization.\n   *\n   * %REVIEW% Directly managed arrays rather than vectors?\n   * %REVIEW% Handles or IDs? Given usage, I think handles.\n   * ",
    "links" : [ ]
  }, {
    "name" : "protected SuballocatedIntVector findNamespaceContext(int elementNodeIndex)",
    "returnType" : "SuballocatedIntVector",
    "comment" : " Retrieve list of namespace declaration locations\n     * active at this node. List is an SuballocatedIntVector whose\n     * entries are the namespace node HANDLES declared at that ID.\n     *\n     * %REVIEW% Directly managed arrays rather than vectors?\n     * %REVIEW% Handles or IDs? Given usage, I think handles.\n     * ",
    "links" : [ ]
  }, {
    "name" : "protected int findInSortedSuballocatedIntVector(SuballocatedIntVector vector, int lookfor)",
    "returnType" : "int",
    "comment" : "\n     * Subroutine: Locate the specified node within\n     * m_namespaceDeclSetElements, or the last element which\n     * preceeds it in document order\n     *\n     * %REVIEW% Inlne this into findNamespaceContext? Create SortedSuballocatedIntVector type?\n     *\n     * @return If positive or zero, the index of the found item.\n     * If negative, index of the point at which it would have appeared,\n     * encoded as -1-index and hence reconvertable by subtracting\n     * it from -1. (Encoding because I don't want to recompare the strings\n     * but don't want to burn bytes on a datatype to hold a flagged value.)\n     ",
    "links" : [ ]
  }, {
    "name" : "public int getFirstNamespaceNode(int nodeHandle, boolean inScope)",
    "returnType" : "int",
    "comment" : "\n   * Given a node handle, get the index of the node's first child.\n   * If not yet resolved, waits for more nodes to be added to the document and\n   * tries again\n   *\n   * @param nodeHandle handle to node, which should probably be an element\n   *                   node, but need not be.\n   *\n   * @param inScope    true if all namespaces in scope should be returned,\n   *                   false if only the namespace declarations should be\n   *                   returned.\n   * @return handle of first namespace, or DTM.NULL to indicate none exists.\n   ",
    "links" : [ ]
  }, {
    "name" : "public int getNextNamespaceNode(int baseHandle, int nodeHandle, boolean inScope)",
    "returnType" : "int",
    "comment" : "\n   * Given a namespace handle, advance to the next namespace.\n   *\n   * @param baseHandle handle to original node from where the first namespace\n   * was relative to (needed to return nodes in document order).\n   * @param nodeHandle A namespace handle for which we will find the next node.\n   * @param inScope true if all namespaces that are in scope should be processed,\n   * otherwise just process the nodes in the given element handle.\n   * @return handle of next namespace, or DTM.NULL to indicate none exists.\n   ",
    "links" : [ ]
  }, {
    "name" : "public int getParent(int nodeHandle)",
    "returnType" : "int",
    "comment" : "\n   * Given a node handle, find its parent node.\n   *\n   * @param nodeHandle the id of the node.\n   * @return int Node-number of parent,\n   * or DTM.NULL to indicate none exists.\n   ",
    "links" : [ ]
  }, {
    "name" : "public int getDocument()",
    "returnType" : "int",
    "comment" : "\n   * Find the Document node handle for the document currently under construction.\n   * PLEASE NOTE that most people should use getOwnerDocument(nodeHandle) instead;\n   * this version of the operation is primarily intended for use during negotiation\n   * with the DTM Manager.\n   * \n   *  @return int Node handle of document, which should always be valid.\n   ",
    "links" : [ ]
  }, {
    "name" : "public int getOwnerDocument(int nodeHandle)",
    "returnType" : "int",
    "comment" : "\n   * Given a node handle, find the owning document node.  This has the exact\n   * same semantics as the DOM Document method of the same name, in that if\n   * the nodeHandle is a document node, it will return NULL.\n   *\n   * <p>%REVIEW% Since this is DOM-specific, it may belong at the DOM\n   * binding layer. Included here as a convenience function and to\n   * aid porting of DOM code to DTM.</p>\n   *\n   * @param nodeHandle the id of the node.\n   * @return int Node handle of owning document, or -1 if the node was a Docment\n   ",
    "links" : [ ]
  }, {
    "name" : "public int getDocumentRoot(int nodeHandle)",
    "returnType" : "int",
    "comment" : "\n   * Given a node handle, find the owning document node.  Unlike the DOM,\n   * this considers the owningDocument of a Document to be itself.\n   *\n   * @param nodeHandle the id of the node.\n   * @return int Node handle of owning document, or the nodeHandle if it is\n   *             a Document.\n   ",
    "links" : [ ]
  }, {
    "name" : "public abstract XMLString getStringValue(int nodeHandle)",
    "returnType" : "XMLString",
    "comment" : "\n   * Get the string-value of a node as a String object\n   * (see http://www.w3.org/TR/xpath#data-model\n   * for the definition of a node's string-value).\n   *\n   * @param nodeHandle The node ID.\n   *\n   * @return A string object that represents the string-value of the given node.\n   ",
    "links" : [ ]
  }, {
    "name" : "public int getStringValueChunkCount(int nodeHandle)",
    "returnType" : "int",
    "comment" : "\n   * Get number of character array chunks in\n   * the string-value of a node.\n   * (see http://www.w3.org/TR/xpath#data-model\n   * for the definition of a node's string-value).\n   * Note that a single text node may have multiple text chunks.\n   *\n   * @param nodeHandle The node ID.\n   *\n   * @return number of character array chunks in\n   *         the string-value of a node.\n   ",
    "links" : [ ]
  }, {
    "name" : "public char[] getStringValueChunk(int nodeHandle, int chunkIndex, int[] startAndLen)",
    "returnType" : "char[]",
    "comment" : "\n   * Get a character array chunk in the string-value of a node.\n   * (see http://www.w3.org/TR/xpath#data-model\n   * for the definition of a node's string-value).\n   * Note that a single text node may have multiple text chunks.\n   *\n   * @param nodeHandle The node ID.\n   * @param chunkIndex Which chunk to get.\n   * @param startAndLen An array of 2 where the start position and length of\n   *                    the chunk will be returned.\n   *\n   * @return The character array reference where the chunk occurs.\n   ",
    "links" : [ ]
  }, {
    "name" : "public int getExpandedTypeID(int nodeHandle)",
    "returnType" : "int",
    "comment" : "\n   * Given a node handle, return an ID that represents the node's expanded name.\n   *\n   * @param nodeHandle The handle to the node in question.\n   *\n   * @return the expanded-name id of the node.\n   ",
    "links" : [ ]
  }, {
    "name" : "public int getExpandedTypeID(String namespace, String localName, int type)",
    "returnType" : "int",
    "comment" : "\n   * Given an expanded name, return an ID.  If the expanded-name does not\n   * exist in the internal tables, the entry will be created, and the ID will\n   * be returned.  Any additional nodes that are created that have this\n   * expanded name will use this ID.\n   *\n   * @param type The simple type, i.e. one of ELEMENT, ATTRIBUTE, etc.\n   *\n   * @param namespace The namespace URI, which may be null, may be an empty\n   *                  string (which will be the same as null), or may be a\n   *                  namespace URI.\n   * @param localName The local name string, which must be a valid\n   *                  <a href=\"http://www.w3.org/TR/REC-xml-names/\">NCName</a>.\n   *\n   * @return the expanded-name id of the node.\n   ",
    "links" : [ ]
  }, {
    "name" : "public String getLocalNameFromExpandedNameID(int expandedNameID)",
    "returnType" : "String",
    "comment" : "\n   * Given an expanded-name ID, return the local name part.\n   *\n   * @param expandedNameID an ID that represents an expanded-name.\n   * @return String Local name of this node.\n   ",
    "links" : [ ]
  }, {
    "name" : "public String getNamespaceFromExpandedNameID(int expandedNameID)",
    "returnType" : "String",
    "comment" : "\n   * Given an expanded-name ID, return the namespace URI part.\n   *\n   * @param expandedNameID an ID that represents an expanded-name.\n   * @return String URI value of this node's namespace, or null if no\n   * namespace was resolved.\n   ",
    "links" : [ ]
  }, {
    "name" : "public int getNamespaceType(final int nodeHandle)",
    "returnType" : "int",
    "comment" : "\n   * Returns the namespace type of a specific node\n   * @param nodeHandle the id of the node.\n   * @return the ID of the namespace.\n   ",
    "links" : [ ]
  }, {
    "name" : "public abstract String getNodeName(int nodeHandle)",
    "returnType" : "String",
    "comment" : "\n   * Given a node handle, return its DOM-style node name. This will\n   * include names such as #text or #document.\n   *\n   * @param nodeHandle the id of the node.\n   * @return String Name of this node, which may be an empty string.\n   * %REVIEW% Document when empty string is possible...\n   * %REVIEW-COMMENT% It should never be empty, should it?\n   ",
    "links" : [ ]
  }, {
    "name" : "public String getNodeNameX(int nodeHandle)",
    "returnType" : "String",
    "comment" : "\n   * Given a node handle, return the XPath node name.  This should be\n   * the name as described by the XPath data model, NOT the DOM-style\n   * name.\n   *\n   * @param nodeHandle the id of the node.\n   * @return String Name of this node, which may be an empty string.\n   ",
    "links" : [ ]
  }, {
    "name" : "public abstract String getLocalName(int nodeHandle)",
    "returnType" : "String",
    "comment" : "\n   * Given a node handle, return its XPath-style localname.\n   * (As defined in Namespaces, this is the portion of the name after any\n   * colon character).\n   *\n   * @param nodeHandle the id of the node.\n   * @return String Local name of this node.\n   ",
    "links" : [ ]
  }, {
    "name" : "public abstract String getPrefix(int nodeHandle)",
    "returnType" : "String",
    "comment" : "\n   * Given a namespace handle, return the prefix that the namespace decl is\n   * mapping.\n   * Given a node handle, return the prefix used to map to the namespace.\n   *\n   * <p> %REVIEW% Are you sure you want \"\" for no prefix?  </p>\n   * <p> %REVIEW-COMMENT% I think so... not totally sure. -sb  </p>\n   *\n   * @param nodeHandle the id of the node.\n   * @return String prefix of this node's name, or \"\" if no explicit\n   * namespace prefix was given.\n   ",
    "links" : [ ]
  }, {
    "name" : "public abstract String getNamespaceURI(int nodeHandle)",
    "returnType" : "String",
    "comment" : "\n   * Given a node handle, return its DOM-style namespace URI\n   * (As defined in Namespaces, this is the declared URI which this node's\n   * prefix -- or default in lieu thereof -- was mapped to.)\n   *\n   * <p>%REVIEW% Null or \"\"? -sb</p>\n   *\n   * @param nodeHandle the id of the node.\n   * @return String URI value of this node's namespace, or null if no\n   * namespace was resolved.\n   ",
    "links" : [ ]
  }, {
    "name" : "public abstract String getNodeValue(int nodeHandle)",
    "returnType" : "String",
    "comment" : "\n   * Given a node handle, return its node value. This is mostly\n   * as defined by the DOM, but may ignore some conveniences.\n   * <p>\n   *\n   * @param nodeHandle The node id.\n   * @return String Value of this node, or null if not\n   * meaningful for this node type.\n   ",
    "links" : [ ]
  }, {
    "name" : "public short getNodeType(int nodeHandle)",
    "returnType" : "short",
    "comment" : "\n   * Given a node handle, return its DOM-style node type.\n   * <p>\n   * %REVIEW% Generally, returning short is false economy. Return int?\n   * %REVIEW% Make assumption that node has already arrived.  Is OK?\n   *\n   * @param nodeHandle The node id.\n   * @return int Node type, as per the DOM's Node._NODE constants.\n   ",
    "links" : [ ]
  }, {
    "name" : "public short getLevel(int nodeHandle)",
    "returnType" : "short",
    "comment" : "\n   * Get the depth level of this node in the tree (equals 1 for\n   * a parentless node).\n   *\n   * @param nodeHandle The node id.\n   * @return the number of ancestors, plus one\n   * @xsl.usage internal\n   ",
    "links" : [ ]
  }, {
    "name" : "public int getNodeIdent(int nodeHandle)",
    "returnType" : "int",
    "comment" : "\n   * Get the identity of this node in the tree \n   *\n   * @param nodeHandle The node handle.\n   * @return the node identity\n   * @xsl.usage internal\n   ",
    "links" : [ ]
  }, {
    "name" : "public int getNodeHandle(int nodeId)",
    "returnType" : "int",
    "comment" : "\n   * Get the handle of this node in the tree \n   *\n   * @param nodeId The node identity.\n   * @return the node handle\n   * @xsl.usage internal\n   ",
    "links" : [ ]
  }, {
    "name" : "public boolean isSupported(String feature, String version)",
    "returnType" : "boolean",
    "comment" : "\n   * Tests whether DTM DOM implementation implements a specific feature and\n   * that feature is supported by this node.\n   *\n   * @param feature The name of the feature to test.\n   * @param version This is the version number of the feature to test.\n   *   If the version is not\n   *   specified, supporting any version of the feature will cause the\n   *   method to return <code>true</code>.\n   * @return Returns <code>true</code> if the specified feature is\n   *   supported on this node, <code>false</code> otherwise.\n   ",
    "links" : [ ]
  }, {
    "name" : "public String getDocumentBaseURI()",
    "returnType" : "String",
    "comment" : "\n   * Return the base URI of the document entity. If it is not known\n   * (because the document was parsed from a socket connection or from\n   * standard input, for example), the value of this property is unknown.\n   *\n   * @return the document base URI String object or null if unknown.\n   ",
    "links" : [ ]
  }, {
    "name" : "public void setDocumentBaseURI(String baseURI)",
    "returnType" : "void",
    "comment" : "\n   * Set the base URI of the document entity.\n   *\n   * @param baseURI the document base URI String object or null if unknown.\n   ",
    "links" : [ ]
  }, {
    "name" : "public String getDocumentSystemIdentifier(int nodeHandle)",
    "returnType" : "String",
    "comment" : "\n   * Return the system identifier of the document entity. If\n   * it is not known, the value of this property is unknown.\n   *\n   * @param nodeHandle The node id, which can be any valid node handle.\n   * @return the system identifier String object or null if unknown.\n   ",
    "links" : [ ]
  }, {
    "name" : "public String getDocumentEncoding(int nodeHandle)",
    "returnType" : "String",
    "comment" : "\n   * Return the name of the character encoding scheme\n   *        in which the document entity is expressed.\n   *\n   * @param nodeHandle The node id, which can be any valid node handle.\n   * @return the document encoding String object.\n   * @xsl.usage internal\n   ",
    "links" : [ ]
  }, {
    "name" : "public String getDocumentStandalone(int nodeHandle)",
    "returnType" : "String",
    "comment" : "\n   * Return an indication of the standalone status of the document,\n   *        either \"yes\" or \"no\". This property is derived from the optional\n   *        standalone document declaration in the XML declaration at the\n   *        beginning of the document entity, and has no value if there is no\n   *        standalone document declaration.\n   *\n   * @param nodeHandle The node id, which can be any valid node handle.\n   * @return the document standalone String object, either \"yes\", \"no\", or null.\n   ",
    "links" : [ ]
  }, {
    "name" : "public String getDocumentVersion(int documentHandle)",
    "returnType" : "String",
    "comment" : "\n   * Return a string representing the XML version of the document. This\n   * property is derived from the XML declaration optionally present at the\n   * beginning of the document entity, and has no value if there is no XML\n   * declaration.\n   *\n   * @param documentHandle The document handle\n   *\n   * @return the document version String object.\n   ",
    "links" : [ ]
  }, {
    "name" : "public boolean getDocumentAllDeclarationsProcessed()",
    "returnType" : "boolean",
    "comment" : "\n   * Return an indication of\n   * whether the processor has read the complete DTD. Its value is a\n   * boolean. If it is false, then certain properties (indicated in their\n   * descriptions below) may be unknown. If it is true, those properties\n   * are never unknown.\n   *\n   * @return <code>true</code> if all declarations were processed;\n   *         <code>false</code> otherwise.\n   ",
    "links" : [ ]
  }, {
    "name" : "public abstract String getDocumentTypeDeclarationSystemIdentifier()",
    "returnType" : "String",
    "comment" : "\n   *   A document type declaration information item has the following properties:\n   *\n   *     1. [system identifier] The system identifier of the external subset, if\n   *        it exists. Otherwise this property has no value.\n   *\n   * @return the system identifier String object, or null if there is none.\n   ",
    "links" : [ ]
  }, {
    "name" : "public abstract String getDocumentTypeDeclarationPublicIdentifier()",
    "returnType" : "String",
    "comment" : "\n   * Return the public identifier of the external subset,\n   * normalized as described in 4.2.2 External Entities [XML]. If there is\n   * no external subset or if it has no public identifier, this property\n   * has no value.\n   *\n   * @return the public identifier String object, or null if there is none.\n   ",
    "links" : [ ]
  }, {
    "name" : "public abstract int getElementById(String elementId)",
    "returnType" : "int",
    "comment" : "\n   * Returns the <code>Element</code> whose <code>ID</code> is given by\n   * <code>elementId</code>. If no such element exists, returns\n   * <code>DTM.NULL</code>. Behavior is not defined if more than one element\n   * has this <code>ID</code>. Attributes (including those\n   * with the name \"ID\") are not of type ID unless so defined by DTD/Schema\n   * information available to the DTM implementation.\n   * Implementations that do not know whether attributes are of type ID or\n   * not are expected to return <code>DTM.NULL</code>.\n   *\n   * <p>%REVIEW% Presumably IDs are still scoped to a single document,\n   * and this operation searches only within a single document, right?\n   * Wouldn't want collisions between DTMs in the same process.</p>\n   *\n   * @param elementId The unique <code>id</code> value for an element.\n   * @return The handle of the matching element.\n   ",
    "links" : [ ]
  }, {
    "name" : "public abstract String getUnparsedEntityURI(String name)",
    "returnType" : "String",
    "comment" : "\n   * The getUnparsedEntityURI function returns the URI of the unparsed\n   * entity with the specified name in the same document as the context\n   * node (see [3.3 Unparsed Entities]). It returns the empty string if\n   * there is no such entity.\n   * <p>\n   * XML processors may choose to use the System Identifier (if one\n   * is provided) to resolve the entity, rather than the URI in the\n   * Public Identifier. The details are dependent on the processor, and\n   * we would have to support some form of plug-in resolver to handle\n   * this properly. Currently, we simply return the System Identifier if\n   * present, and hope that it a usable URI or that our caller can\n   * map it to one.\n   * TODO: Resolve Public Identifiers... or consider changing function name.\n   * <p>\n   * If we find a relative URI\n   * reference, XML expects it to be resolved in terms of the base URI\n   * of the document. The DOM doesn't do that for us, and it isn't\n   * entirely clear whether that should be done here; currently that's\n   * pushed up to a higher level of our application. (Note that DOM Level\n   * 1 didn't store the document's base URI.)\n   * TODO: Consider resolving Relative URIs.\n   * <p>\n   * (The DOM's statement that \"An XML processor may choose to\n   * completely expand entities before the structure model is passed\n   * to the DOM\" refers only to parsed entities, not unparsed, and hence\n   * doesn't affect this function.)\n   *\n   * @param name A string containing the Entity Name of the unparsed\n   * entity.\n   *\n   * @return String containing the URI of the Unparsed Entity, or an\n   * empty string if no such entity exists.\n   ",
    "links" : [ ]
  }, {
    "name" : "public boolean supportsPreStripping()",
    "returnType" : "boolean",
    "comment" : "\n   * Return true if the xsl:strip-space or xsl:preserve-space was processed\n   * during construction of the DTM document.\n   *\n   * @return true if this DTM supports prestripping.\n   ",
    "links" : [ ]
  }, {
    "name" : "public boolean isNodeAfter(int nodeHandle1, int nodeHandle2)",
    "returnType" : "boolean",
    "comment" : "\n   * Figure out whether nodeHandle2 should be considered as being later\n   * in the document than nodeHandle1, in Document Order as defined\n   * by the XPath model. This may not agree with the ordering defined\n   * by other XML applications.\n   * <p>\n   * There are some cases where ordering isn't defined, and neither are\n   * the results of this function -- though we'll generally return false.\n   *\n   * @param nodeHandle1 Node handle to perform position comparison on.\n   * @param nodeHandle2 Second Node handle to perform position comparison on .\n   *\n   * @return true if node1 comes before node2, otherwise return false.\n   * You can think of this as\n   * <code>(node1.documentOrderPosition &lt;= node2.documentOrderPosition)</code>.\n   ",
    "links" : [ ]
  }, {
    "name" : "public boolean isCharacterElementContentWhitespace(int nodeHandle)",
    "returnType" : "boolean",
    "comment" : "\n   *     2. [element content whitespace] A boolean indicating whether the\n   *        character is white space appearing within element content (see [XML],\n   *        2.10 \"White Space Handling\"). Note that validating XML processors are\n   *        required by XML 1.0 to provide this information. If there is no\n   *        declaration for the containing element, this property has no value for\n   *        white space characters. If no declaration has been read, but the [all\n   *        declarations processed] property of the document information item is\n   *        false (so there may be an unread declaration), then the value of this\n   *        property is unknown for white space characters. It is always false for\n   *        characters that are not white space.\n   *\n   * @param nodeHandle the node ID.\n   * @return <code>true</code> if the character data is whitespace;\n   *         <code>false</code> otherwise.\n   ",
    "links" : [ ]
  }, {
    "name" : "public boolean isDocumentAllDeclarationsProcessed(int documentHandle)",
    "returnType" : "boolean",
    "comment" : "\n   *    10. [all declarations processed] This property is not strictly speaking\n   *        part of the infoset of the document. Rather it is an indication of\n   *        whether the processor has read the complete DTD. Its value is a\n   *        boolean. If it is false, then certain properties (indicated in their\n   *        descriptions below) may be unknown. If it is true, those properties\n   *        are never unknown.\n   *\n   * @param documentHandle A node handle that must identify a document.\n   * @return <code>true</code> if all declarations were processed;\n   *         <code>false</code> otherwise.\n   ",
    "links" : [ ]
  }, {
    "name" : "public abstract boolean isAttributeSpecified(int attributeHandle)",
    "returnType" : "boolean",
    "comment" : "\n   *     5. [specified] A flag indicating whether this attribute was actually\n   *        specified in the start-tag of its element, or was defaulted from the\n   *        DTD.\n   *\n   * @param attributeHandle The attribute handle in question.\n   *\n   * @return <code>true</code> if the attribute was specified;\n   *         <code>false</code> if it was defaulted.\n   ",
    "links" : [ ]
  }, {
    "name" : "public abstract void dispatchCharactersEvents(int nodeHandle, org.xml.sax.ContentHandler ch, boolean normalize) throws org.xml.sax.SAXException",
    "returnType" : "void",
    "comment" : "\n   * Directly call the\n   * characters method on the passed ContentHandler for the\n   * string-value of the given node (see http://www.w3.org/TR/xpath#data-model\n   * for the definition of a node's string-value). Multiple calls to the\n   * ContentHandler's characters methods may well occur for a single call to\n   * this method.\n   *\n   * @param nodeHandle The node ID.\n   * @param ch A non-null reference to a ContentHandler.\n   * @param normalize true if the content should be normalized according to\n   * the rules for the XPath\n   * <a href=\"http://www.w3.org/TR/xpath#function-normalize-space\">normalize-space</a>\n   * function.\n   *\n   * @throws org.xml.sax.SAXException\n   ",
    "links" : [ ]
  }, {
    "name" : "public abstract void dispatchToEvents(int nodeHandle, org.xml.sax.ContentHandler ch) throws org.xml.sax.SAXException",
    "returnType" : "void",
    "comment" : "\n   * Directly create SAX parser events from a subtree.\n   *\n   * @param nodeHandle The node ID.\n   * @param ch A non-null reference to a ContentHandler.\n   *\n   * @throws org.xml.sax.SAXException\n   ",
    "links" : [ ]
  }, {
    "name" : "public org.w3c.dom.Node getNode(int nodeHandle)",
    "returnType" : "org.w3c.dom.Node",
    "comment" : "\n   * Return an DOM node for the given node.\n   *\n   * @param nodeHandle The node ID.\n   *\n   * @return A node representation of the DTM node.\n   ",
    "links" : [ ]
  }, {
    "name" : "public void appendChild(int newChild, boolean clone, boolean cloneDepth)",
    "returnType" : "void",
    "comment" : "\n   * Append a child to the end of the document. Please note that the node\n   * is always cloned if it is owned by another document.\n   *\n   * <p>%REVIEW% \"End of the document\" needs to be defined more clearly.\n   * Does it become the last child of the Document? Of the root element?</p>\n   *\n   * @param newChild Must be a valid new node handle.\n   * @param clone true if the child should be cloned into the document.\n   * @param cloneDepth if the clone argument is true, specifies that the\n   *                   clone should include all it's children.\n   ",
    "links" : [ ]
  }, {
    "name" : "public void appendTextChild(String str)",
    "returnType" : "void",
    "comment" : "\n   * Append a text node child that will be constructed from a string,\n   * to the end of the document.\n   *\n   * <p>%REVIEW% \"End of the document\" needs to be defined more clearly.\n   * Does it become the last child of the Document? Of the root element?</p>\n   *\n   * @param str Non-null reverence to a string.\n   ",
    "links" : [ ]
  }, {
    "name" : "protected void error(String msg)",
    "returnType" : "void",
    "comment" : "\n   * Simple error for asserts and the like.\n   *\n   * @param msg Error message to report.\n   ",
    "links" : [ ]
  }, {
    "name" : "protected boolean getShouldStripWhitespace()",
    "returnType" : "boolean",
    "comment" : "\n   * Find out whether or not to strip whispace nodes.\n   *\n   *\n   * @return whether or not to strip whispace nodes.\n   ",
    "links" : [ ]
  }, {
    "name" : "protected void pushShouldStripWhitespace(boolean shouldStrip)",
    "returnType" : "void",
    "comment" : "\n   * Set whether to strip whitespaces and push in current value of\n   * m_shouldStripWS in m_shouldStripWhitespaceStack.\n   *\n   * @param shouldStrip Flag indicating whether to strip whitespace nodes\n   ",
    "links" : [ ]
  }, {
    "name" : "protected void popShouldStripWhitespace()",
    "returnType" : "void",
    "comment" : "\n   * Set whether to strip whitespaces at this point by popping out\n   * m_shouldStripWhitespaceStack.\n   *\n   ",
    "links" : [ ]
  }, {
    "name" : "protected void setShouldStripWhitespace(boolean shouldStrip)",
    "returnType" : "void",
    "comment" : "\n   * Set whether to strip whitespaces and set the top of the stack to\n   * the current value of m_shouldStripWS.\n   *\n   *\n   * @param shouldStrip Flag indicating whether to strip whitespace nodes\n   ",
    "links" : [ ]
  }, {
    "name" : "public void documentRegistration()",
    "returnType" : "void",
    "comment" : "\n   * A dummy routine to satisify the abstract interface. If the DTM\n   * implememtation that extends the default base requires notification\n   * of registration, they can override this method.\n   ",
    "links" : [ ]
  }, {
    "name" : "public void documentRelease()",
    "returnType" : "void",
    "comment" : "\n   * A dummy routine to satisify the abstract interface. If the DTM\n   * implememtation that extends the default base requires notification\n   * when the document is being released, they can override this method\n   ",
    "links" : [ ]
  }, {
    "name" : "public void migrateTo(DTMManager mgr)",
    "returnType" : "void",
    "comment" : "\n    * Migrate a DTM built with an old DTMManager to a new DTMManager.\n    * After the migration, the new DTMManager will treat the DTM as\n    * one that is built by itself.\n    * This is used to support DTM sharing between multiple transformations.\n    * @param mgr the DTMManager\n    ",
    "links" : [ ]
  }, {
    "name" : "public DTMManager getManager()",
    "returnType" : "DTMManager",
    "comment" : " Query which DTMManager this DTM is currently being handled by.\n\t  * \n\t  * %REVEW% Should this become part of the base DTM API?\n\t  * \n\t  * @return a DTMManager, or null if this is a \"stand-alone\" DTM.\n\t  ",
    "links" : [ ]
  }, {
    "name" : "public SuballocatedIntVector getDTMIDs()",
    "returnType" : "SuballocatedIntVector",
    "comment" : " Query which DTMIDs this DTM is currently using within the DTMManager.\n\t  * \n\t  * %REVEW% Should this become part of the base DTM API?\n\t  * \n\t  * @return an IntVector, or null if this is a \"stand-alone\" DTM.\n\t  ",
    "links" : [ ]
  } ],
  "methodNames" : [ "protected void ensureSizeOfIndex(int namespaceID, int LocalNameID)", "protected void indexNode(int expandedTypeID, int identity)", "protected int findGTE(int[] list, int start, int len, int value)", " int findElementFromIndex(int nsIndex, int lnIndex, int firstPotential)", "protected abstract int getNextNodeIdentity(int identity)", "protected abstract boolean nextNode()", "protected abstract int getNumberOfNodes()", "protected short _type(int identity)", "protected int _exptype(int identity)", "protected int _level(int identity)", "protected int _firstch(int identity)", "protected int _nextsib(int identity)", "protected int _prevsib(int identity)", "protected int _parent(int identity)", "public void dumpDTM(OutputStream os)", "public String dumpNode(int nodeHandle)", "public void setFeature(String featureId, boolean state)", "public boolean hasChildNodes(int nodeHandle)", "public final int makeNodeHandle(int nodeIdentity)", "public final int makeNodeIdentity(int nodeHandle)", "public int getFirstChild(int nodeHandle)", "public int getTypedFirstChild(int nodeHandle, int nodeType)", "public int getLastChild(int nodeHandle)", "public abstract int getAttributeNode(int nodeHandle, String namespaceURI, String name)", "public int getFirstAttribute(int nodeHandle)", "protected int getFirstAttributeIdentity(int identity)", "protected int getTypedAttribute(int nodeHandle, int attType)", "public int getNextSibling(int nodeHandle)", "public int getTypedNextSibling(int nodeHandle, int nodeType)", "public int getPreviousSibling(int nodeHandle)", "public int getNextAttribute(int nodeHandle)", "protected int getNextAttributeIdentity(int identity)", "protected void declareNamespaceInContext(int elementNodeIndex, int namespaceNodeIndex)", "protected SuballocatedIntVector findNamespaceContext(int elementNodeIndex)", "protected int findInSortedSuballocatedIntVector(SuballocatedIntVector vector, int lookfor)", "public int getFirstNamespaceNode(int nodeHandle, boolean inScope)", "public int getNextNamespaceNode(int baseHandle, int nodeHandle, boolean inScope)", "public int getParent(int nodeHandle)", "public int getDocument()", "public int getOwnerDocument(int nodeHandle)", "public int getDocumentRoot(int nodeHandle)", "public abstract XMLString getStringValue(int nodeHandle)", "public int getStringValueChunkCount(int nodeHandle)", "public char[] getStringValueChunk(int nodeHandle, int chunkIndex, int[] startAndLen)", "public int getExpandedTypeID(int nodeHandle)", "public int getExpandedTypeID(String namespace, String localName, int type)", "public String getLocalNameFromExpandedNameID(int expandedNameID)", "public String getNamespaceFromExpandedNameID(int expandedNameID)", "public int getNamespaceType(final int nodeHandle)", "public abstract String getNodeName(int nodeHandle)", "public String getNodeNameX(int nodeHandle)", "public abstract String getLocalName(int nodeHandle)", "public abstract String getPrefix(int nodeHandle)", "public abstract String getNamespaceURI(int nodeHandle)", "public abstract String getNodeValue(int nodeHandle)", "public short getNodeType(int nodeHandle)", "public short getLevel(int nodeHandle)", "public int getNodeIdent(int nodeHandle)", "public int getNodeHandle(int nodeId)", "public boolean isSupported(String feature, String version)", "public String getDocumentBaseURI()", "public void setDocumentBaseURI(String baseURI)", "public String getDocumentSystemIdentifier(int nodeHandle)", "public String getDocumentEncoding(int nodeHandle)", "public String getDocumentStandalone(int nodeHandle)", "public String getDocumentVersion(int documentHandle)", "public boolean getDocumentAllDeclarationsProcessed()", "public abstract String getDocumentTypeDeclarationSystemIdentifier()", "public abstract String getDocumentTypeDeclarationPublicIdentifier()", "public abstract int getElementById(String elementId)", "public abstract String getUnparsedEntityURI(String name)", "public boolean supportsPreStripping()", "public boolean isNodeAfter(int nodeHandle1, int nodeHandle2)", "public boolean isCharacterElementContentWhitespace(int nodeHandle)", "public boolean isDocumentAllDeclarationsProcessed(int documentHandle)", "public abstract boolean isAttributeSpecified(int attributeHandle)", "public abstract void dispatchCharactersEvents(int nodeHandle, org.xml.sax.ContentHandler ch, boolean normalize) throws org.xml.sax.SAXException", "public abstract void dispatchToEvents(int nodeHandle, org.xml.sax.ContentHandler ch) throws org.xml.sax.SAXException", "public org.w3c.dom.Node getNode(int nodeHandle)", "public void appendChild(int newChild, boolean clone, boolean cloneDepth)", "public void appendTextChild(String str)", "protected void error(String msg)", "protected boolean getShouldStripWhitespace()", "protected void pushShouldStripWhitespace(boolean shouldStrip)", "protected void popShouldStripWhitespace()", "protected void setShouldStripWhitespace(boolean shouldStrip)", "public void documentRegistration()", "public void documentRelease()", "public void migrateTo(DTMManager mgr)", "public DTMManager getManager()", "public SuballocatedIntVector getDTMIDs()" ],
  "variableNames" : [ "JJK_DEBUG", "ROOTNODE", "m_size", "m_exptype", "m_firstch", "m_nextsib", "m_prevsib", "m_parent", "m_namespaceDeclSets", "m_namespaceDeclSetElements", "m_elemIndexes", "DEFAULT_BLOCKSIZE", "DEFAULT_NUMBLOCKS", "DEFAULT_NUMBLOCKS_SMALL", "NOTPROCESSED", "m_mgr", "m_mgrDefault", "m_dtmIdent", "m_documentBaseURI", "m_wsfilter", "m_shouldStripWS", "m_shouldStripWhitespaceStack", "m_xstrf", "m_expandedNameTable", "m_indexing", "m_traversers", "m_namespaceLists" ]
}