{
  "filePath" : "/home/maryam/clearblue/files/android-source-35/java/util/stream/Collectors.java",
  "packageName" : "java.util.stream",
  "className" : "Collectors",
  "comment" : "\n * Implementations of {@link Collector} that implement various useful reduction\n * operations, such as accumulating elements into collections, summarizing\n * elements according to various criteria, etc.\n *\n * <p>The following are examples of using the predefined collectors to perform\n * common mutable reduction tasks:\n *\n * <pre>{@code\n * // Accumulate names into a List\n * List<String> list = people.stream()\n *   .map(Person::getName)\n *   .collect(Collectors.toList());\n *\n * // Accumulate names into a TreeSet\n * Set<String> set = people.stream()\n *   .map(Person::getName)\n *   .collect(Collectors.toCollection(TreeSet::new));\n *\n * // Convert elements to strings and concatenate them, separated by commas\n * String joined = things.stream()\n *   .map(Object::toString)\n *   .collect(Collectors.joining(\", \"));\n *\n * // Compute sum of salaries of employee\n * int total = employees.stream()\n *   .collect(Collectors.summingInt(Employee::getSalary));\n *\n * // Group employees by department\n * Map<Department, List<Employee>> byDept = employees.stream()\n *   .collect(Collectors.groupingBy(Employee::getDepartment));\n *\n * // Compute sum of salaries by department\n * Map<Department, Integer> totalByDept = employees.stream()\n *   .collect(Collectors.groupingBy(Employee::getDepartment,\n *                                  Collectors.summingInt(Employee::getSalary)));\n *\n * // Partition students into passing and failing\n * Map<Boolean, List<Student>> passingFailing = students.stream()\n *   .collect(Collectors.partitioningBy(s -> s.getGrade() >= PASS_THRESHOLD));\n *\n * }</pre>\n *\n * @since 1.8\n ",
  "links" : [ "java.util.stream.Collector" ],
  "variables" : [ {
    "name" : "CH_CONCURRENT_ID",
    "type" : "Set<Collector.Characteristics>",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "CH_CONCURRENT_NOID",
    "type" : "Set<Collector.Characteristics>",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "CH_ID",
    "type" : "Set<Collector.Characteristics>",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "CH_UNORDERED_ID",
    "type" : "Set<Collector.Characteristics>",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "CH_NOID",
    "type" : "Set<Collector.Characteristics>",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "CH_UNORDERED_NOID",
    "type" : "Set<Collector.Characteristics>",
    "comment" : "",
    "links" : [ ]
  } ],
  "methods" : [ {
    "name" : "private static IllegalStateException duplicateKeyException(Object k, Object u, Object v)",
    "returnType" : "IllegalStateException",
    "comment" : "\n     * Construct an {@code IllegalStateException} with appropriate message.\n     *\n     * @param k the duplicate key\n     * @param u 1st value to be accumulated/merged\n     * @param v 2nd value to be accumulated/merged\n     ",
    "links" : [ ]
  }, {
    "name" : "private static BinaryOperator<M> uniqKeysMapMerger()",
    "returnType" : "BinaryOperator<M>",
    "comment" : "\n     * {@code BinaryOperator<Map>} that merges the contents of its right\n     * argument into its left argument, throwing {@code IllegalStateException}\n     * if duplicate keys are encountered.\n     *\n     * @param <K> type of the map keys\n     * @param <V> type of the map values\n     * @param <M> type of the map\n     * @return a merge function for two maps\n     ",
    "links" : [ ]
  }, {
    "name" : "private static BiConsumer<Map<K, V>, T> uniqKeysMapAccumulator(Function<? super T, ? extends K> keyMapper, Function<? super T, ? extends V> valueMapper)",
    "returnType" : "BiConsumer<Map<K, V>, T>",
    "comment" : "\n     * {@code BiConsumer<Map, T>} that accumulates (key, value) pairs\n     * extracted from elements into the map, throwing {@code IllegalStateException}\n     * if duplicate keys are encountered.\n     *\n     * @param keyMapper a function that maps an element into a key\n     * @param valueMapper a function that maps an element into a value\n     * @param <T> type of elements\n     * @param <K> type of map keys\n     * @param <V> type of map values\n     * @return an accumulating consumer\n     ",
    "links" : [ ]
  }, {
    "name" : "private static Function<I, R> castingIdentity()",
    "returnType" : "Function<I, R>",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public static Collector<T, ?, C> toCollection(Supplier<C> collectionFactory)",
    "returnType" : "Collector<T, ?, C>",
    "comment" : "\n     * Returns a {@code Collector} that accumulates the input elements into a\n     * new {@code Collection}, in encounter order.  The {@code Collection} is\n     * created by the provided factory.\n     *\n     * @param <T> the type of the input elements\n     * @param <C> the type of the resulting {@code Collection}\n     * @param collectionFactory a supplier providing a new empty {@code Collection}\n     *                          into which the results will be inserted\n     * @return a {@code Collector} which collects all the input elements into a\n     * {@code Collection}, in encounter order\n     ",
    "links" : [ ]
  }, {
    "name" : "public static Collector<T, ?, List<T>> toList()",
    "returnType" : "Collector<T, ?, List<T>>",
    "comment" : "\n     * Returns a {@code Collector} that accumulates the input elements into a\n     * new {@code List}. There are no guarantees on the type, mutability,\n     * serializability, or thread-safety of the {@code List} returned; if more\n     * control over the returned {@code List} is required, use {@link #toCollection(Supplier)}.\n     *\n     * @param <T> the type of the input elements\n     * @return a {@code Collector} which collects all the input elements into a\n     * {@code List}, in encounter order\n     ",
    "links" : [ "#toCollection(Supplier)" ]
  }, {
    "name" : "public static Collector<T, ?, List<T>> toUnmodifiableList()",
    "returnType" : "Collector<T, ?, List<T>>",
    "comment" : "\n     * Returns a {@code Collector} that accumulates the input elements into an\n     * <a href=\"../List.html#unmodifiable\">unmodifiable List</a> in encounter\n     * order. The returned Collector disallows null values and will throw\n     * {@code NullPointerException} if it is presented with a null value.\n     *\n     * @param <T> the type of the input elements\n     * @return a {@code Collector} that accumulates the input elements into an\n     * <a href=\"../List.html#unmodifiable\">unmodifiable List</a> in encounter order\n     * @since 10\n     ",
    "links" : [ ]
  }, {
    "name" : "public static Collector<T, ?, Set<T>> toSet()",
    "returnType" : "Collector<T, ?, Set<T>>",
    "comment" : "\n     * Returns a {@code Collector} that accumulates the input elements into a\n     * new {@code Set}. There are no guarantees on the type, mutability,\n     * serializability, or thread-safety of the {@code Set} returned; if more\n     * control over the returned {@code Set} is required, use\n     * {@link #toCollection(Supplier)}.\n     *\n     * <p>This is an {@link Collector.Characteristics#UNORDERED unordered}\n     * Collector.\n     *\n     * @param <T> the type of the input elements\n     * @return a {@code Collector} which collects all the input elements into a\n     * {@code Set}\n     ",
    "links" : [ "#toCollection(Supplier)", "Collector.Characteristics#UNORDERED" ]
  }, {
    "name" : "public static Collector<T, ?, Set<T>> toUnmodifiableSet()",
    "returnType" : "Collector<T, ?, Set<T>>",
    "comment" : "\n     * Returns a {@code Collector} that accumulates the input elements into an\n     * <a href=\"../Set.html#unmodifiable\">unmodifiable Set</a>. The returned\n     * Collector disallows null values and will throw {@code NullPointerException}\n     * if it is presented with a null value. If the input contains duplicate elements,\n     * an arbitrary element of the duplicates is preserved.\n     *\n     * <p>This is an {@link Collector.Characteristics#UNORDERED unordered}\n     * Collector.\n     *\n     * @param <T> the type of the input elements\n     * @return a {@code Collector} that accumulates the input elements into an\n     * <a href=\"../Set.html#unmodifiable\">unmodifiable Set</a>\n     * @since 10\n     ",
    "links" : [ "Collector.Characteristics#UNORDERED" ]
  }, {
    "name" : "public static Collector<CharSequence, ?, String> joining()",
    "returnType" : "Collector<CharSequence, ?, String>",
    "comment" : "\n     * Returns a {@code Collector} that concatenates the input elements into a\n     * {@code String}, in encounter order.\n     *\n     * @return a {@code Collector} that concatenates the input elements into a\n     * {@code String}, in encounter order\n     ",
    "links" : [ ]
  }, {
    "name" : "public static Collector<CharSequence, ?, String> joining(CharSequence delimiter)",
    "returnType" : "Collector<CharSequence, ?, String>",
    "comment" : "\n     * Returns a {@code Collector} that concatenates the input elements,\n     * separated by the specified delimiter, in encounter order.\n     *\n     * @param delimiter the delimiter to be used between each element\n     * @return A {@code Collector} which concatenates CharSequence elements,\n     * separated by the specified delimiter, in encounter order\n     ",
    "links" : [ ]
  }, {
    "name" : "public static Collector<CharSequence, ?, String> joining(CharSequence delimiter, CharSequence prefix, CharSequence suffix)",
    "returnType" : "Collector<CharSequence, ?, String>",
    "comment" : "\n     * Returns a {@code Collector} that concatenates the input elements,\n     * separated by the specified delimiter, with the specified prefix and\n     * suffix, in encounter order.\n     *\n     * @param delimiter the delimiter to be used between each element\n     * @param  prefix the sequence of characters to be used at the beginning\n     *                of the joined result\n     * @param  suffix the sequence of characters to be used at the end\n     *                of the joined result\n     * @return A {@code Collector} which concatenates CharSequence elements,\n     * separated by the specified delimiter, in encounter order\n     ",
    "links" : [ ]
  }, {
    "name" : "private static BinaryOperator<M> mapMerger(BinaryOperator<V> mergeFunction)",
    "returnType" : "BinaryOperator<M>",
    "comment" : "\n     * {@code BinaryOperator<Map>} that merges the contents of its right\n     * argument into its left argument, using the provided merge function to\n     * handle duplicate keys.\n     *\n     * @param <K> type of the map keys\n     * @param <V> type of the map values\n     * @param <M> type of the map\n     * @param mergeFunction A merge function suitable for\n     * {@link Map#merge(Object, Object, BiFunction) Map.merge()}\n     * @return a merge function for two maps\n     ",
    "links" : [ "java.util.AbstractMap#merge(Object" ]
  }, {
    "name" : "public static Collector<T, ?, R> mapping(Function<? super T, ? extends U> mapper, Collector<? super U, A, R> downstream)",
    "returnType" : "Collector<T, ?, R>",
    "comment" : "\n     * Adapts a {@code Collector} accepting elements of type {@code U} to one\n     * accepting elements of type {@code T} by applying a mapping function to\n     * each input element before accumulation.\n     *\n     * @apiNote\n     * The {@code mapping()} collectors are most useful when used in a\n     * multi-level reduction, such as downstream of a {@code groupingBy} or\n     * {@code partitioningBy}.  For example, given a stream of\n     * {@code Person}, to accumulate the set of last names in each city:\n     * <pre>{@code\n     * Map<City, Set<String>> lastNamesByCity\n     *   = people.stream().collect(\n     *     groupingBy(Person::getCity,\n     *                mapping(Person::getLastName,\n     *                        toSet())));\n     * }</pre>\n     *\n     * @param <T> the type of the input elements\n     * @param <U> type of elements accepted by downstream collector\n     * @param <A> intermediate accumulation type of the downstream collector\n     * @param <R> result type of collector\n     * @param mapper a function to be applied to the input elements\n     * @param downstream a collector which will accept mapped values\n     * @return a collector which applies the mapping function to the input\n     * elements and provides the mapped results to the downstream collector\n     ",
    "links" : [ ]
  }, {
    "name" : "public static Collector<T, ?, R> flatMapping(Function<? super T, ? extends Stream<? extends U>> mapper, Collector<? super U, A, R> downstream)",
    "returnType" : "Collector<T, ?, R>",
    "comment" : "\n     * Adapts a {@code Collector} accepting elements of type {@code U} to one\n     * accepting elements of type {@code T} by applying a flat mapping function\n     * to each input element before accumulation.  The flat mapping function\n     * maps an input element to a {@link Stream stream} covering zero or more\n     * output elements that are then accumulated downstream.  Each mapped stream\n     * is {@link java.util.stream.BaseStream#close() closed} after its contents\n     * have been placed downstream.  (If a mapped stream is {@code null}\n     * an empty stream is used, instead.)\n     *\n     * @apiNote\n     * The {@code flatMapping()} collectors are most useful when used in a\n     * multi-level reduction, such as downstream of a {@code groupingBy} or\n     * {@code partitioningBy}.  For example, given a stream of\n     * {@code Order}, to accumulate the set of line items for each customer:\n     * <pre>{@code\n     * Map<String, Set<LineItem>> itemsByCustomerName\n     *   = orders.stream().collect(\n     *     groupingBy(Order::getCustomerName,\n     *                flatMapping(order -> order.getLineItems().stream(),\n     *                            toSet())));\n     * }</pre>\n     *\n     * @param <T> the type of the input elements\n     * @param <U> type of elements accepted by downstream collector\n     * @param <A> intermediate accumulation type of the downstream collector\n     * @param <R> result type of collector\n     * @param mapper a function to be applied to the input elements, which\n     * returns a stream of results\n     * @param downstream a collector which will receive the elements of the\n     * stream returned by mapper\n     * @return a collector which applies the mapping function to the input\n     * elements and provides the flat mapped results to the downstream collector\n     * @since 9\n     ",
    "links" : [ "java.util.stream.Stream", "java.util.stream.BaseStream#close()" ]
  }, {
    "name" : "public static Collector<T, ?, R> filtering(Predicate<? super T> predicate, Collector<? super T, A, R> downstream)",
    "returnType" : "Collector<T, ?, R>",
    "comment" : "\n     * Adapts a {@code Collector} to one accepting elements of the same type\n     * {@code T} by applying the predicate to each input element and only\n     * accumulating if the predicate returns {@code true}.\n     *\n     * @apiNote\n     * The {@code filtering()} collectors are most useful when used in a\n     * multi-level reduction, such as downstream of a {@code groupingBy} or\n     * {@code partitioningBy}.  For example, given a stream of\n     * {@code Employee}, to accumulate the employees in each department that have a\n     * salary above a certain threshold:\n     * <pre>{@code\n     * Map<Department, Set<Employee>> wellPaidEmployeesByDepartment\n     *   = employees.stream().collect(\n     *     groupingBy(Employee::getDepartment,\n     *                filtering(e -> e.getSalary() > 2000,\n     *                          toSet())));\n     * }</pre>\n     * A filtering collector differs from a stream's {@code filter()} operation.\n     * In this example, suppose there are no employees whose salary is above the\n     * threshold in some department.  Using a filtering collector as shown above\n     * would result in a mapping from that department to an empty {@code Set}.\n     * If a stream {@code filter()} operation were done instead, there would be\n     * no mapping for that department at all.\n     *\n     * @param <T> the type of the input elements\n     * @param <A> intermediate accumulation type of the downstream collector\n     * @param <R> result type of collector\n     * @param predicate a predicate to be applied to the input elements\n     * @param downstream a collector which will accept values that match the\n     * predicate\n     * @return a collector which applies the predicate to the input elements\n     * and provides matching elements to the downstream collector\n     * @since 9\n     ",
    "links" : [ ]
  }, {
    "name" : "public static Collector<T, A, RR> collectingAndThen(Collector<T, A, R> downstream, Function<R, RR> finisher)",
    "returnType" : "Collector<T, A, RR>",
    "comment" : "\n     * Adapts a {@code Collector} to perform an additional finishing\n     * transformation.  For example, one could adapt the {@link #toList()}\n     * collector to always produce an immutable list with:\n     * <pre>{@code\n     * List<String> list = people.stream().collect(\n     *   collectingAndThen(toList(),\n     *                     Collections::unmodifiableList));\n     * }</pre>\n     *\n     * @param <T> the type of the input elements\n     * @param <A> intermediate accumulation type of the downstream collector\n     * @param <R> result type of the downstream collector\n     * @param <RR> result type of the resulting collector\n     * @param downstream a collector\n     * @param finisher a function to be applied to the final result of the downstream collector\n     * @return a collector which performs the action of the downstream collector,\n     * followed by an additional finishing step\n     ",
    "links" : [ "#toList()" ]
  }, {
    "name" : "public static Collector<T, ?, Long> counting()",
    "returnType" : "Collector<T, ?, Long>",
    "comment" : "\n     * Returns a {@code Collector} accepting elements of type {@code T} that\n     * counts the number of input elements.  If no elements are present, the\n     * result is 0.\n     *\n     * @implSpec\n     * This produces a result equivalent to:\n     * <pre>{@code\n     *     reducing(0L, e -> 1L, Long::sum)\n     * }</pre>\n     *\n     * @param <T> the type of the input elements\n     * @return a {@code Collector} that counts the input elements\n     ",
    "links" : [ ]
  }, {
    "name" : "public static Collector<T, ?, Optional<T>> minBy(Comparator<? super T> comparator)",
    "returnType" : "Collector<T, ?, Optional<T>>",
    "comment" : "\n     * Returns a {@code Collector} that produces the minimal element according\n     * to a given {@code Comparator}, described as an {@code Optional<T>}.\n     *\n     * @implSpec\n     * This produces a result equivalent to:\n     * <pre>{@code\n     *     reducing(BinaryOperator.minBy(comparator))\n     * }</pre>\n     *\n     * @param <T> the type of the input elements\n     * @param comparator a {@code Comparator} for comparing elements\n     * @return a {@code Collector} that produces the minimal value\n     ",
    "links" : [ ]
  }, {
    "name" : "public static Collector<T, ?, Optional<T>> maxBy(Comparator<? super T> comparator)",
    "returnType" : "Collector<T, ?, Optional<T>>",
    "comment" : "\n     * Returns a {@code Collector} that produces the maximal element according\n     * to a given {@code Comparator}, described as an {@code Optional<T>}.\n     *\n     * @implSpec\n     * This produces a result equivalent to:\n     * <pre>{@code\n     *     reducing(BinaryOperator.maxBy(comparator))\n     * }</pre>\n     *\n     * @param <T> the type of the input elements\n     * @param comparator a {@code Comparator} for comparing elements\n     * @return a {@code Collector} that produces the maximal value\n     ",
    "links" : [ ]
  }, {
    "name" : "public static Collector<T, ?, Integer> summingInt(ToIntFunction<? super T> mapper)",
    "returnType" : "Collector<T, ?, Integer>",
    "comment" : "\n     * Returns a {@code Collector} that produces the sum of a integer-valued\n     * function applied to the input elements.  If no elements are present,\n     * the result is 0.\n     *\n     * @param <T> the type of the input elements\n     * @param mapper a function extracting the property to be summed\n     * @return a {@code Collector} that produces the sum of a derived property\n     ",
    "links" : [ ]
  }, {
    "name" : "public static Collector<T, ?, Long> summingLong(ToLongFunction<? super T> mapper)",
    "returnType" : "Collector<T, ?, Long>",
    "comment" : "\n     * Returns a {@code Collector} that produces the sum of a long-valued\n     * function applied to the input elements.  If no elements are present,\n     * the result is 0.\n     *\n     * @param <T> the type of the input elements\n     * @param mapper a function extracting the property to be summed\n     * @return a {@code Collector} that produces the sum of a derived property\n     ",
    "links" : [ ]
  }, {
    "name" : "public static Collector<T, ?, Double> summingDouble(ToDoubleFunction<? super T> mapper)",
    "returnType" : "Collector<T, ?, Double>",
    "comment" : "\n     * Returns a {@code Collector} that produces the sum of a double-valued\n     * function applied to the input elements.  If no elements are present,\n     * the result is 0.\n     *\n     * <p>The sum returned can vary depending upon the order in which\n     * values are recorded, due to accumulated rounding error in\n     * addition of values of differing magnitudes. Values sorted by increasing\n     * absolute magnitude tend to yield more accurate results.  If any recorded\n     * value is a {@code NaN} or the sum is at any point a {@code NaN} then the\n     * sum will be {@code NaN}.\n     *\n     * @param <T> the type of the input elements\n     * @param mapper a function extracting the property to be summed\n     * @return a {@code Collector} that produces the sum of a derived property\n     ",
    "links" : [ ]
  }, {
    "name" : " static double[] sumWithCompensation(double[] intermediateSum, double value)",
    "returnType" : "double[]",
    "comment" : "\n     * Incorporate a new double value using Kahan summation /\n     * compensation summation.\n     *\n     * High-order bits of the sum are in intermediateSum[0], low-order\n     * bits of the sum are in intermediateSum[1], any additional\n     * elements are application-specific.\n     *\n     * @param intermediateSum the high-order and low-order words of the intermediate sum\n     * @param value the name value to be included in the running sum\n     ",
    "links" : [ ]
  }, {
    "name" : " static double computeFinalSum(double[] summands)",
    "returnType" : "double",
    "comment" : "\n     * If the compensated sum is spuriously NaN from accumulating one\n     * or more same-signed infinite values, return the\n     * correctly-signed infinity stored in the simple sum.\n     ",
    "links" : [ ]
  }, {
    "name" : "public static Collector<T, ?, Double> averagingInt(ToIntFunction<? super T> mapper)",
    "returnType" : "Collector<T, ?, Double>",
    "comment" : "\n     * Returns a {@code Collector} that produces the arithmetic mean of an integer-valued\n     * function applied to the input elements.  If no elements are present,\n     * the result is 0.\n     *\n     * @param <T> the type of the input elements\n     * @param mapper a function extracting the property to be averaged\n     * @return a {@code Collector} that produces the arithmetic mean of a\n     * derived property\n     ",
    "links" : [ ]
  }, {
    "name" : "public static Collector<T, ?, Double> averagingLong(ToLongFunction<? super T> mapper)",
    "returnType" : "Collector<T, ?, Double>",
    "comment" : "\n     * Returns a {@code Collector} that produces the arithmetic mean of a long-valued\n     * function applied to the input elements.  If no elements are present,\n     * the result is 0.\n     *\n     * @param <T> the type of the input elements\n     * @param mapper a function extracting the property to be averaged\n     * @return a {@code Collector} that produces the arithmetic mean of a\n     * derived property\n     ",
    "links" : [ ]
  }, {
    "name" : "public static Collector<T, ?, Double> averagingDouble(ToDoubleFunction<? super T> mapper)",
    "returnType" : "Collector<T, ?, Double>",
    "comment" : "\n     * Returns a {@code Collector} that produces the arithmetic mean of a double-valued\n     * function applied to the input elements.  If no elements are present,\n     * the result is 0.\n     *\n     * <p>The average returned can vary depending upon the order in which\n     * values are recorded, due to accumulated rounding error in\n     * addition of values of differing magnitudes. Values sorted by increasing\n     * absolute magnitude tend to yield more accurate results.  If any recorded\n     * value is a {@code NaN} or the sum is at any point a {@code NaN} then the\n     * average will be {@code NaN}.\n     *\n     * @implNote The {@code double} format can represent all\n     * consecutive integers in the range -2<sup>53</sup> to\n     * 2<sup>53</sup>. If the pipeline has more than 2<sup>53</sup>\n     * values, the divisor in the average computation will saturate at\n     * 2<sup>53</sup>, leading to additional numerical errors.\n     *\n     * @param <T> the type of the input elements\n     * @param mapper a function extracting the property to be averaged\n     * @return a {@code Collector} that produces the arithmetic mean of a\n     * derived property\n     ",
    "links" : [ ]
  }, {
    "name" : "public static Collector<T, ?, T> reducing(T identity, BinaryOperator<T> op)",
    "returnType" : "Collector<T, ?, T>",
    "comment" : "\n     * Returns a {@code Collector} which performs a reduction of its\n     * input elements under a specified {@code BinaryOperator} using the\n     * provided identity.\n     *\n     * @apiNote\n     * The {@code reducing()} collectors are most useful when used in a\n     * multi-level reduction, downstream of {@code groupingBy} or\n     * {@code partitioningBy}.  To perform a simple reduction on a stream,\n     * use {@link Stream#reduce(Object, BinaryOperator)}} instead.\n     *\n     * @param <T> element type for the input and output of the reduction\n     * @param identity the identity value for the reduction (also, the value\n     *                 that is returned when there are no input elements)\n     * @param op a {@code BinaryOperator<T>} used to reduce the input elements\n     * @return a {@code Collector} which implements the reduction operation\n     *\n     * @see #reducing(BinaryOperator)\n     * @see #reducing(Object, Function, BinaryOperator)\n     ",
    "links" : [ "java.util.stream.Stream#reduce(Object" ]
  }, {
    "name" : "private static Supplier<T[]> boxSupplier(T identity)",
    "returnType" : "Supplier<T[]>",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public static Collector<T, ?, Optional<T>> reducing(BinaryOperator<T> op)",
    "returnType" : "Collector<T, ?, Optional<T>>",
    "comment" : "\n     * Returns a {@code Collector} which performs a reduction of its\n     * input elements under a specified {@code BinaryOperator}.  The result\n     * is described as an {@code Optional<T>}.\n     *\n     * @apiNote\n     * The {@code reducing()} collectors are most useful when used in a\n     * multi-level reduction, downstream of {@code groupingBy} or\n     * {@code partitioningBy}.  To perform a simple reduction on a stream,\n     * use {@link Stream#reduce(BinaryOperator)} instead.\n     *\n     * <p>For example, given a stream of {@code Person}, to calculate tallest\n     * person in each city:\n     * <pre>{@code\n     * Comparator<Person> byHeight = Comparator.comparing(Person::getHeight);\n     * Map<City, Optional<Person>> tallestByCity\n     *   = people.stream().collect(\n     *     groupingBy(Person::getCity,\n     *                reducing(BinaryOperator.maxBy(byHeight))));\n     * }</pre>\n     *\n     * @param <T> element type for the input and output of the reduction\n     * @param op a {@code BinaryOperator<T>} used to reduce the input elements\n     * @return a {@code Collector} which implements the reduction operation\n     *\n     * @see #reducing(Object, BinaryOperator)\n     * @see #reducing(Object, Function, BinaryOperator)\n     ",
    "links" : [ "java.util.stream.Stream#reduce(BinaryOperator)" ]
  }, {
    "name" : "public static Collector<T, ?, U> reducing(U identity, Function<? super T, ? extends U> mapper, BinaryOperator<U> op)",
    "returnType" : "Collector<T, ?, U>",
    "comment" : "\n     * Returns a {@code Collector} which performs a reduction of its\n     * input elements under a specified mapping function and\n     * {@code BinaryOperator}. This is a generalization of\n     * {@link #reducing(Object, BinaryOperator)} which allows a transformation\n     * of the elements before reduction.\n     *\n     * @apiNote\n     * The {@code reducing()} collectors are most useful when used in a\n     * multi-level reduction, downstream of {@code groupingBy} or\n     * {@code partitioningBy}.  To perform a simple map-reduce on a stream,\n     * use {@link Stream#map(Function)} and {@link Stream#reduce(Object, BinaryOperator)}\n     * instead.\n     *\n     * <p>For example, given a stream of {@code Person}, to calculate the longest\n     * last name of residents in each city:\n     * <pre>{@code\n     * Comparator<String> byLength = Comparator.comparing(String::length);\n     * Map<City, String> longestLastNameByCity\n     *   = people.stream().collect(\n     *     groupingBy(Person::getCity,\n     *                reducing(\"\",\n     *                         Person::getLastName,\n     *                         BinaryOperator.maxBy(byLength))));\n     * }</pre>\n     *\n     * @param <T> the type of the input elements\n     * @param <U> the type of the mapped values\n     * @param identity the identity value for the reduction (also, the value\n     *                 that is returned when there are no input elements)\n     * @param mapper a mapping function to apply to each input value\n     * @param op a {@code BinaryOperator<U>} used to reduce the mapped values\n     * @return a {@code Collector} implementing the map-reduce operation\n     *\n     * @see #reducing(Object, BinaryOperator)\n     * @see #reducing(BinaryOperator)\n     ",
    "links" : [ "java.util.stream.Stream#reduce(Object", "#reducing(Object", "java.util.stream.Stream#map(Function)" ]
  }, {
    "name" : "public static Collector<T, ?, Map<K, List<T>>> groupingBy(Function<? super T, ? extends K> classifier)",
    "returnType" : "Collector<T, ?, Map<K, List<T>>>",
    "comment" : "\n     * Returns a {@code Collector} implementing a \"group by\" operation on\n     * input elements of type {@code T}, grouping elements according to a\n     * classification function, and returning the results in a {@code Map}.\n     *\n     * <p>The classification function maps elements to some key type {@code K}.\n     * The collector produces a {@code Map<K, List<T>>} whose keys are the\n     * values resulting from applying the classification function to the input\n     * elements, and whose corresponding values are {@code List}s containing the\n     * input elements which map to the associated key under the classification\n     * function.\n     *\n     * <p>There are no guarantees on the type, mutability, serializability, or\n     * thread-safety of the {@code Map} or {@code List} objects returned.\n     * @implSpec\n     * This produces a result similar to:\n     * <pre>{@code\n     *     groupingBy(classifier, toList());\n     * }</pre>\n     *\n     * @implNote\n     * The returned {@code Collector} is not concurrent.  For parallel stream\n     * pipelines, the {@code combiner} function operates by merging the keys\n     * from one map into another, which can be an expensive operation.  If\n     * preservation of the order in which elements appear in the resulting {@code Map}\n     * collector is not required, using {@link #groupingByConcurrent(Function)}\n     * may offer better parallel performance.\n     *\n     * @param <T> the type of the input elements\n     * @param <K> the type of the keys\n     * @param classifier the classifier function mapping input elements to keys\n     * @return a {@code Collector} implementing the group-by operation\n     *\n     * @see #groupingBy(Function, Collector)\n     * @see #groupingBy(Function, Supplier, Collector)\n     * @see #groupingByConcurrent(Function)\n     ",
    "links" : [ "#groupingByConcurrent(Function)" ]
  }, {
    "name" : "public static Collector<T, ?, Map<K, D>> groupingBy(Function<? super T, ? extends K> classifier, Collector<? super T, A, D> downstream)",
    "returnType" : "Collector<T, ?, Map<K, D>>",
    "comment" : "\n     * Returns a {@code Collector} implementing a cascaded \"group by\" operation\n     * on input elements of type {@code T}, grouping elements according to a\n     * classification function, and then performing a reduction operation on\n     * the values associated with a given key using the specified downstream\n     * {@code Collector}.\n     *\n     * <p>The classification function maps elements to some key type {@code K}.\n     * The downstream collector operates on elements of type {@code T} and\n     * produces a result of type {@code D}. The resulting collector produces a\n     * {@code Map<K, D>}.\n     *\n     * <p>There are no guarantees on the type, mutability,\n     * serializability, or thread-safety of the {@code Map} returned.\n     *\n     * <p>For example, to compute the set of last names of people in each city:\n     * <pre>{@code\n     * Map<City, Set<String>> namesByCity\n     *   = people.stream().collect(\n     *     groupingBy(Person::getCity,\n     *                mapping(Person::getLastName,\n     *                        toSet())));\n     * }</pre>\n     *\n     * @implNote\n     * The returned {@code Collector} is not concurrent.  For parallel stream\n     * pipelines, the {@code combiner} function operates by merging the keys\n     * from one map into another, which can be an expensive operation.  If\n     * preservation of the order in which elements are presented to the downstream\n     * collector is not required, using {@link #groupingByConcurrent(Function, Collector)}\n     * may offer better parallel performance.\n     *\n     * @param <T> the type of the input elements\n     * @param <K> the type of the keys\n     * @param <A> the intermediate accumulation type of the downstream collector\n     * @param <D> the result type of the downstream reduction\n     * @param classifier a classifier function mapping input elements to keys\n     * @param downstream a {@code Collector} implementing the downstream reduction\n     * @return a {@code Collector} implementing the cascaded group-by operation\n     * @see #groupingBy(Function)\n     *\n     * @see #groupingBy(Function, Supplier, Collector)\n     * @see #groupingByConcurrent(Function, Collector)\n     ",
    "links" : [ "#groupingByConcurrent(Function" ]
  }, {
    "name" : "public static Collector<T, ?, M> groupingBy(Function<? super T, ? extends K> classifier, Supplier<M> mapFactory, Collector<? super T, A, D> downstream)",
    "returnType" : "Collector<T, ?, M>",
    "comment" : "\n     * Returns a {@code Collector} implementing a cascaded \"group by\" operation\n     * on input elements of type {@code T}, grouping elements according to a\n     * classification function, and then performing a reduction operation on\n     * the values associated with a given key using the specified downstream\n     * {@code Collector}.  The {@code Map} produced by the Collector is created\n     * with the supplied factory function.\n     *\n     * <p>The classification function maps elements to some key type {@code K}.\n     * The downstream collector operates on elements of type {@code T} and\n     * produces a result of type {@code D}. The resulting collector produces a\n     * {@code Map<K, D>}.\n     *\n     * <p>For example, to compute the set of last names of people in each city,\n     * where the city names are sorted:\n     * <pre>{@code\n     * Map<City, Set<String>> namesByCity\n     *   = people.stream().collect(\n     *     groupingBy(Person::getCity,\n     *                TreeMap::new,\n     *                mapping(Person::getLastName,\n     *                        toSet())));\n     * }</pre>\n     *\n     * @implNote\n     * The returned {@code Collector} is not concurrent.  For parallel stream\n     * pipelines, the {@code combiner} function operates by merging the keys\n     * from one map into another, which can be an expensive operation.  If\n     * preservation of the order in which elements are presented to the downstream\n     * collector is not required, using {@link #groupingByConcurrent(Function, Supplier, Collector)}\n     * may offer better parallel performance.\n     *\n     * @param <T> the type of the input elements\n     * @param <K> the type of the keys\n     * @param <A> the intermediate accumulation type of the downstream collector\n     * @param <D> the result type of the downstream reduction\n     * @param <M> the type of the resulting {@code Map}\n     * @param classifier a classifier function mapping input elements to keys\n     * @param downstream a {@code Collector} implementing the downstream reduction\n     * @param mapFactory a supplier providing a new empty {@code Map}\n     *                   into which the results will be inserted\n     * @return a {@code Collector} implementing the cascaded group-by operation\n     *\n     * @see #groupingBy(Function, Collector)\n     * @see #groupingBy(Function)\n     * @see #groupingByConcurrent(Function, Supplier, Collector)\n     ",
    "links" : [ "#groupingByConcurrent(Function" ]
  }, {
    "name" : "public static Collector<T, ?, ConcurrentMap<K, List<T>>> groupingByConcurrent(Function<? super T, ? extends K> classifier)",
    "returnType" : "Collector<T, ?, ConcurrentMap<K, List<T>>>",
    "comment" : "\n     * Returns a concurrent {@code Collector} implementing a \"group by\"\n     * operation on input elements of type {@code T}, grouping elements\n     * according to a classification function.\n     *\n     * <p>This is a {@link Collector.Characteristics#CONCURRENT concurrent} and\n     * {@link Collector.Characteristics#UNORDERED unordered} Collector.\n     *\n     * <p>The classification function maps elements to some key type {@code K}.\n     * The collector produces a {@code ConcurrentMap<K, List<T>>} whose keys are the\n     * values resulting from applying the classification function to the input\n     * elements, and whose corresponding values are {@code List}s containing the\n     * input elements which map to the associated key under the classification\n     * function.\n     *\n     * <p>There are no guarantees on the type, mutability, or serializability\n     * of the {@code ConcurrentMap} or {@code List} objects returned, or of the\n     * thread-safety of the {@code List} objects returned.\n     * @implSpec\n     * This produces a result similar to:\n     * <pre>{@code\n     *     groupingByConcurrent(classifier, toList());\n     * }</pre>\n     *\n     * @param <T> the type of the input elements\n     * @param <K> the type of the keys\n     * @param classifier a classifier function mapping input elements to keys\n     * @return a concurrent, unordered {@code Collector} implementing the group-by operation\n     *\n     * @see #groupingBy(Function)\n     * @see #groupingByConcurrent(Function, Collector)\n     * @see #groupingByConcurrent(Function, Supplier, Collector)\n     ",
    "links" : [ "Collector.Characteristics#UNORDERED", "Collector.Characteristics#CONCURRENT" ]
  }, {
    "name" : "public static Collector<T, ?, ConcurrentMap<K, D>> groupingByConcurrent(Function<? super T, ? extends K> classifier, Collector<? super T, A, D> downstream)",
    "returnType" : "Collector<T, ?, ConcurrentMap<K, D>>",
    "comment" : "\n     * Returns a concurrent {@code Collector} implementing a cascaded \"group by\"\n     * operation on input elements of type {@code T}, grouping elements\n     * according to a classification function, and then performing a reduction\n     * operation on the values associated with a given key using the specified\n     * downstream {@code Collector}.\n     *\n     * <p>This is a {@link Collector.Characteristics#CONCURRENT concurrent} and\n     * {@link Collector.Characteristics#UNORDERED unordered} Collector.\n     *\n     * <p>The classification function maps elements to some key type {@code K}.\n     * The downstream collector operates on elements of type {@code T} and\n     * produces a result of type {@code D}. The resulting collector produces a\n     * {@code ConcurrentMap<K, D>}.\n     *\n     * <p>There are no guarantees on the type, mutability, or serializability\n     * of the {@code ConcurrentMap} returned.\n     *\n     * <p>For example, to compute the set of last names of people in each city,\n     * where the city names are sorted:\n     * <pre>{@code\n     * ConcurrentMap<City, Set<String>> namesByCity\n     *   = people.stream().collect(\n     *     groupingByConcurrent(Person::getCity,\n     *                          mapping(Person::getLastName,\n     *                                  toSet())));\n     * }</pre>\n     *\n     * @param <T> the type of the input elements\n     * @param <K> the type of the keys\n     * @param <A> the intermediate accumulation type of the downstream collector\n     * @param <D> the result type of the downstream reduction\n     * @param classifier a classifier function mapping input elements to keys\n     * @param downstream a {@code Collector} implementing the downstream reduction\n     * @return a concurrent, unordered {@code Collector} implementing the cascaded group-by operation\n     *\n     * @see #groupingBy(Function, Collector)\n     * @see #groupingByConcurrent(Function)\n     * @see #groupingByConcurrent(Function, Supplier, Collector)\n     ",
    "links" : [ "Collector.Characteristics#UNORDERED", "Collector.Characteristics#CONCURRENT" ]
  }, {
    "name" : "public static Collector<T, ?, M> groupingByConcurrent(Function<? super T, ? extends K> classifier, Supplier<M> mapFactory, Collector<? super T, A, D> downstream)",
    "returnType" : "Collector<T, ?, M>",
    "comment" : "\n     * Returns a concurrent {@code Collector} implementing a cascaded \"group by\"\n     * operation on input elements of type {@code T}, grouping elements\n     * according to a classification function, and then performing a reduction\n     * operation on the values associated with a given key using the specified\n     * downstream {@code Collector}.  The {@code ConcurrentMap} produced by the\n     * Collector is created with the supplied factory function.\n     *\n     * <p>This is a {@link Collector.Characteristics#CONCURRENT concurrent} and\n     * {@link Collector.Characteristics#UNORDERED unordered} Collector.\n     *\n     * <p>The classification function maps elements to some key type {@code K}.\n     * The downstream collector operates on elements of type {@code T} and\n     * produces a result of type {@code D}. The resulting collector produces a\n     * {@code ConcurrentMap<K, D>}.\n     *\n     * <p>For example, to compute the set of last names of people in each city,\n     * where the city names are sorted:\n     * <pre>{@code\n     * ConcurrentMap<City, Set<String>> namesByCity\n     *   = people.stream().collect(\n     *     groupingByConcurrent(Person::getCity,\n     *                          ConcurrentSkipListMap::new,\n     *                          mapping(Person::getLastName,\n     *                                  toSet())));\n     * }</pre>\n     *\n     * @param <T> the type of the input elements\n     * @param <K> the type of the keys\n     * @param <A> the intermediate accumulation type of the downstream collector\n     * @param <D> the result type of the downstream reduction\n     * @param <M> the type of the resulting {@code ConcurrentMap}\n     * @param classifier a classifier function mapping input elements to keys\n     * @param downstream a {@code Collector} implementing the downstream reduction\n     * @param mapFactory a supplier providing a new empty {@code ConcurrentMap}\n     *                   into which the results will be inserted\n     * @return a concurrent, unordered {@code Collector} implementing the cascaded group-by operation\n     *\n     * @see #groupingByConcurrent(Function)\n     * @see #groupingByConcurrent(Function, Collector)\n     * @see #groupingBy(Function, Supplier, Collector)\n     ",
    "links" : [ "Collector.Characteristics#UNORDERED", "Collector.Characteristics#CONCURRENT" ]
  }, {
    "name" : "public static Collector<T, ?, Map<Boolean, List<T>>> partitioningBy(Predicate<? super T> predicate)",
    "returnType" : "Collector<T, ?, Map<Boolean, List<T>>>",
    "comment" : "\n     * Returns a {@code Collector} which partitions the input elements according\n     * to a {@code Predicate}, and organizes them into a\n     * {@code Map<Boolean, List<T>>}.\n     *\n     * The returned {@code Map} always contains mappings for both\n     * {@code false} and {@code true} keys.\n     * There are no guarantees on the type, mutability,\n     * serializability, or thread-safety of the {@code Map} or {@code List}\n     * returned.\n     *\n     * @apiNote\n     * If a partition has no elements, its value in the result Map will be\n     * an empty List.\n     *\n     * @param <T> the type of the input elements\n     * @param predicate a predicate used for classifying input elements\n     * @return a {@code Collector} implementing the partitioning operation\n     *\n     * @see #partitioningBy(Predicate, Collector)\n     ",
    "links" : [ ]
  }, {
    "name" : "public static Collector<T, ?, Map<Boolean, D>> partitioningBy(Predicate<? super T> predicate, Collector<? super T, A, D> downstream)",
    "returnType" : "Collector<T, ?, Map<Boolean, D>>",
    "comment" : "\n     * Returns a {@code Collector} which partitions the input elements according\n     * to a {@code Predicate}, reduces the values in each partition according to\n     * another {@code Collector}, and organizes them into a\n     * {@code Map<Boolean, D>} whose values are the result of the downstream\n     * reduction.\n     *\n     * <p>\n     * The returned {@code Map} always contains mappings for both\n     * {@code false} and {@code true} keys.\n     * There are no guarantees on the type, mutability,\n     * serializability, or thread-safety of the {@code Map} returned.\n     *\n     * @apiNote\n     * If a partition has no elements, its value in the result Map will be\n     * obtained by calling the downstream collector's supplier function and then\n     * applying the finisher function.\n     *\n     * @param <T> the type of the input elements\n     * @param <A> the intermediate accumulation type of the downstream collector\n     * @param <D> the result type of the downstream reduction\n     * @param predicate a predicate used for classifying input elements\n     * @param downstream a {@code Collector} implementing the downstream\n     *                   reduction\n     * @return a {@code Collector} implementing the cascaded partitioning\n     *         operation\n     *\n     * @see #partitioningBy(Predicate)\n     ",
    "links" : [ ]
  }, {
    "name" : "public static Collector<T, ?, Map<K, U>> toMap(Function<? super T, ? extends K> keyMapper, Function<? super T, ? extends U> valueMapper)",
    "returnType" : "Collector<T, ?, Map<K, U>>",
    "comment" : "\n     * Returns a {@code Collector} that accumulates elements into a\n     * {@code Map} whose keys and values are the result of applying the provided\n     * mapping functions to the input elements.\n     *\n     * <p>If the mapped keys contain duplicates (according to\n     * {@link Object#equals(Object)}), an {@code IllegalStateException} is\n     * thrown when the collection operation is performed.  If the mapped keys\n     * might have duplicates, use {@link #toMap(Function, Function, BinaryOperator)}\n     * instead.\n     *\n     * <p>There are no guarantees on the type, mutability, serializability,\n     * or thread-safety of the {@code Map} returned.\n     *\n     * @apiNote\n     * It is common for either the key or the value to be the input elements.\n     * In this case, the utility method\n     * {@link java.util.function.Function#identity()} may be helpful.\n     * For example, the following produces a {@code Map} mapping\n     * students to their grade point average:\n     * <pre>{@code\n     * Map<Student, Double> studentToGPA\n     *   = students.stream().collect(\n     *     toMap(Function.identity(),\n     *           student -> computeGPA(student)));\n     * }</pre>\n     * And the following produces a {@code Map} mapping a unique identifier to\n     * students:\n     * <pre>{@code\n     * Map<String, Student> studentIdToStudent\n     *   = students.stream().collect(\n     *     toMap(Student::getId,\n     *           Function.identity()));\n     * }</pre>\n     *\n     * @implNote\n     * The returned {@code Collector} is not concurrent.  For parallel stream\n     * pipelines, the {@code combiner} function operates by merging the keys\n     * from one map into another, which can be an expensive operation.  If it is\n     * not required that results are inserted into the {@code Map} in encounter\n     * order, using {@link #toConcurrentMap(Function, Function)}\n     * may offer better parallel performance.\n     *\n     * @param <T> the type of the input elements\n     * @param <K> the output type of the key mapping function\n     * @param <U> the output type of the value mapping function\n     * @param keyMapper a mapping function to produce keys\n     * @param valueMapper a mapping function to produce values\n     * @return a {@code Collector} which collects elements into a {@code Map}\n     * whose keys and values are the result of applying mapping functions to\n     * the input elements\n     *\n     * @see #toMap(Function, Function, BinaryOperator)\n     * @see #toMap(Function, Function, BinaryOperator, Supplier)\n     * @see #toConcurrentMap(Function, Function)\n     ",
    "links" : [ "#toMap(Function", "#equals(Object)", "java.util.function.Function#identity()", "#toConcurrentMap(Function" ]
  }, {
    "name" : "public static Collector<T, ?, Map<K, U>> toUnmodifiableMap(Function<? super T, ? extends K> keyMapper, Function<? super T, ? extends U> valueMapper)",
    "returnType" : "Collector<T, ?, Map<K, U>>",
    "comment" : "\n     * Returns a {@code Collector} that accumulates the input elements into an\n     * <a href=\"../Map.html#unmodifiable\">unmodifiable Map</a>,\n     * whose keys and values are the result of applying the provided\n     * mapping functions to the input elements.\n     *\n     * <p>If the mapped keys contain duplicates (according to\n     * {@link Object#equals(Object)}), an {@code IllegalStateException} is\n     * thrown when the collection operation is performed.  If the mapped keys\n     * might have duplicates, use {@link #toUnmodifiableMap(Function, Function, BinaryOperator)}\n     * to handle merging of the values.\n     *\n     * <p>The returned Collector disallows null keys and values. If either mapping function\n     * returns null, {@code NullPointerException} will be thrown.\n     *\n     * @param <T> the type of the input elements\n     * @param <K> the output type of the key mapping function\n     * @param <U> the output type of the value mapping function\n     * @param keyMapper a mapping function to produce keys, must be non-null\n     * @param valueMapper a mapping function to produce values, must be non-null\n     * @return a {@code Collector} that accumulates the input elements into an\n     * <a href=\"../Map.html#unmodifiable\">unmodifiable Map</a>, whose keys and values\n     * are the result of applying the provided mapping functions to the input elements\n     * @throws NullPointerException if either keyMapper or valueMapper is null\n     *\n     * @see #toUnmodifiableMap(Function, Function, BinaryOperator)\n     * @since 10\n     ",
    "links" : [ "#equals(Object)", "#toUnmodifiableMap(Function" ]
  }, {
    "name" : "public static Collector<T, ?, Map<K, U>> toMap(Function<? super T, ? extends K> keyMapper, Function<? super T, ? extends U> valueMapper, BinaryOperator<U> mergeFunction)",
    "returnType" : "Collector<T, ?, Map<K, U>>",
    "comment" : "\n     * Returns a {@code Collector} that accumulates elements into a\n     * {@code Map} whose keys and values are the result of applying the provided\n     * mapping functions to the input elements.\n     *\n     * <p>If the mapped\n     * keys contain duplicates (according to {@link Object#equals(Object)}),\n     * the value mapping function is applied to each equal element, and the\n     * results are merged using the provided merging function.\n     *\n     * <p>There are no guarantees on the type, mutability, serializability,\n     * or thread-safety of the {@code Map} returned.\n     *\n     * @apiNote\n     * There are multiple ways to deal with collisions between multiple elements\n     * mapping to the same key.  The other forms of {@code toMap} simply use\n     * a merge function that throws unconditionally, but you can easily write\n     * more flexible merge policies.  For example, if you have a stream\n     * of {@code Person}, and you want to produce a \"phone book\" mapping name to\n     * address, but it is possible that two persons have the same name, you can\n     * do as follows to gracefully deal with these collisions, and produce a\n     * {@code Map} mapping names to a concatenated list of addresses:\n     * <pre>{@code\n     * Map<String, String> phoneBook\n     *   = people.stream().collect(\n     *     toMap(Person::getName,\n     *           Person::getAddress,\n     *           (s, a) -> s + \", \" + a));\n     * }</pre>\n     *\n     * @implNote\n     * The returned {@code Collector} is not concurrent.  For parallel stream\n     * pipelines, the {@code combiner} function operates by merging the keys\n     * from one map into another, which can be an expensive operation.  If it is\n     * not required that results are merged into the {@code Map} in encounter\n     * order, using {@link #toConcurrentMap(Function, Function, BinaryOperator)}\n     * may offer better parallel performance.\n     *\n     * @param <T> the type of the input elements\n     * @param <K> the output type of the key mapping function\n     * @param <U> the output type of the value mapping function\n     * @param keyMapper a mapping function to produce keys\n     * @param valueMapper a mapping function to produce values\n     * @param mergeFunction a merge function, used to resolve collisions between\n     *                      values associated with the same key, as supplied\n     *                      to {@link Map#merge(Object, Object, BiFunction)}\n     * @return a {@code Collector} which collects elements into a {@code Map}\n     * whose keys are the result of applying a key mapping function to the input\n     * elements, and whose values are the result of applying a value mapping\n     * function to all input elements equal to the key and combining them\n     * using the merge function\n     *\n     * @see #toMap(Function, Function)\n     * @see #toMap(Function, Function, BinaryOperator, Supplier)\n     * @see #toConcurrentMap(Function, Function, BinaryOperator)\n     ",
    "links" : [ "#equals(Object)", "java.util.AbstractMap#merge(Object", "#toConcurrentMap(Function" ]
  }, {
    "name" : "public static Collector<T, ?, Map<K, U>> toUnmodifiableMap(Function<? super T, ? extends K> keyMapper, Function<? super T, ? extends U> valueMapper, BinaryOperator<U> mergeFunction)",
    "returnType" : "Collector<T, ?, Map<K, U>>",
    "comment" : "\n     * Returns a {@code Collector} that accumulates the input elements into an\n     * <a href=\"../Map.html#unmodifiable\">unmodifiable Map</a>,\n     * whose keys and values are the result of applying the provided\n     * mapping functions to the input elements.\n     *\n     * <p>If the mapped\n     * keys contain duplicates (according to {@link Object#equals(Object)}),\n     * the value mapping function is applied to each equal element, and the\n     * results are merged using the provided merging function.\n     *\n     * <p>The returned Collector disallows null keys and values. If either mapping function\n     * returns null, {@code NullPointerException} will be thrown.\n     *\n     * @param <T> the type of the input elements\n     * @param <K> the output type of the key mapping function\n     * @param <U> the output type of the value mapping function\n     * @param keyMapper a mapping function to produce keys, must be non-null\n     * @param valueMapper a mapping function to produce values, must be non-null\n     * @param mergeFunction a merge function, used to resolve collisions between\n     *                      values associated with the same key, as supplied\n     *                      to {@link Map#merge(Object, Object, BiFunction)},\n     *                      must be non-null\n     * @return a {@code Collector} that accumulates the input elements into an\n     * <a href=\"../Map.html#unmodifiable\">unmodifiable Map</a>, whose keys and values\n     * are the result of applying the provided mapping functions to the input elements\n     * @throws NullPointerException if the keyMapper, valueMapper, or mergeFunction is null\n     *\n     * @see #toUnmodifiableMap(Function, Function)\n     * @since 10\n     ",
    "links" : [ "#equals(Object)", "java.util.AbstractMap#merge(Object" ]
  }, {
    "name" : "public static Collector<T, ?, M> toMap(Function<? super T, ? extends K> keyMapper, Function<? super T, ? extends U> valueMapper, BinaryOperator<U> mergeFunction, Supplier<M> mapFactory)",
    "returnType" : "Collector<T, ?, M>",
    "comment" : "\n     * Returns a {@code Collector} that accumulates elements into a\n     * {@code Map} whose keys and values are the result of applying the provided\n     * mapping functions to the input elements.\n     *\n     * <p>If the mapped\n     * keys contain duplicates (according to {@link Object#equals(Object)}),\n     * the value mapping function is applied to each equal element, and the\n     * results are merged using the provided merging function.  The {@code Map}\n     * is created by a provided supplier function.\n     *\n     * @implNote\n     * The returned {@code Collector} is not concurrent.  For parallel stream\n     * pipelines, the {@code combiner} function operates by merging the keys\n     * from one map into another, which can be an expensive operation.  If it is\n     * not required that results are merged into the {@code Map} in encounter\n     * order, using {@link #toConcurrentMap(Function, Function, BinaryOperator, Supplier)}\n     * may offer better parallel performance.\n     *\n     * @param <T> the type of the input elements\n     * @param <K> the output type of the key mapping function\n     * @param <U> the output type of the value mapping function\n     * @param <M> the type of the resulting {@code Map}\n     * @param keyMapper a mapping function to produce keys\n     * @param valueMapper a mapping function to produce values\n     * @param mergeFunction a merge function, used to resolve collisions between\n     *                      values associated with the same key, as supplied\n     *                      to {@link Map#merge(Object, Object, BiFunction)}\n     * @param mapFactory a supplier providing a new empty {@code Map}\n     *                   into which the results will be inserted\n     * @return a {@code Collector} which collects elements into a {@code Map}\n     * whose keys are the result of applying a key mapping function to the input\n     * elements, and whose values are the result of applying a value mapping\n     * function to all input elements equal to the key and combining them\n     * using the merge function\n     *\n     * @see #toMap(Function, Function)\n     * @see #toMap(Function, Function, BinaryOperator)\n     * @see #toConcurrentMap(Function, Function, BinaryOperator, Supplier)\n     ",
    "links" : [ "#equals(Object)", "java.util.AbstractMap#merge(Object", "#toConcurrentMap(Function" ]
  }, {
    "name" : "public static Collector<T, ?, ConcurrentMap<K, U>> toConcurrentMap(Function<? super T, ? extends K> keyMapper, Function<? super T, ? extends U> valueMapper)",
    "returnType" : "Collector<T, ?, ConcurrentMap<K, U>>",
    "comment" : "\n     * Returns a concurrent {@code Collector} that accumulates elements into a\n     * {@code ConcurrentMap} whose keys and values are the result of applying\n     * the provided mapping functions to the input elements.\n     *\n     * <p>If the mapped keys contain duplicates (according to\n     * {@link Object#equals(Object)}), an {@code IllegalStateException} is\n     * thrown when the collection operation is performed.  If the mapped keys\n     * may have duplicates, use\n     * {@link #toConcurrentMap(Function, Function, BinaryOperator)} instead.\n     *\n     * <p>There are no guarantees on the type, mutability, or serializability\n     * of the {@code ConcurrentMap} returned.\n     *\n     * @apiNote\n     * It is common for either the key or the value to be the input elements.\n     * In this case, the utility method\n     * {@link java.util.function.Function#identity()} may be helpful.\n     * For example, the following produces a {@code ConcurrentMap} mapping\n     * students to their grade point average:\n     * <pre>{@code\n     * ConcurrentMap<Student, Double> studentToGPA\n     *   = students.stream().collect(\n     *     toConcurrentMap(Function.identity(),\n     *                     student -> computeGPA(student)));\n     * }</pre>\n     * And the following produces a {@code ConcurrentMap} mapping a\n     * unique identifier to students:\n     * <pre>{@code\n     * ConcurrentMap<String, Student> studentIdToStudent\n     *   = students.stream().collect(\n     *     toConcurrentMap(Student::getId,\n     *                     Function.identity()));\n     * }</pre>\n     *\n     * <p>This is a {@link Collector.Characteristics#CONCURRENT concurrent} and\n     * {@link Collector.Characteristics#UNORDERED unordered} Collector.\n     *\n     * @param <T> the type of the input elements\n     * @param <K> the output type of the key mapping function\n     * @param <U> the output type of the value mapping function\n     * @param keyMapper the mapping function to produce keys\n     * @param valueMapper the mapping function to produce values\n     * @return a concurrent, unordered {@code Collector} which collects elements into a\n     * {@code ConcurrentMap} whose keys are the result of applying a key mapping\n     * function to the input elements, and whose values are the result of\n     * applying a value mapping function to the input elements\n     *\n     * @see #toMap(Function, Function)\n     * @see #toConcurrentMap(Function, Function, BinaryOperator)\n     * @see #toConcurrentMap(Function, Function, BinaryOperator, Supplier)\n     ",
    "links" : [ "#equals(Object)", "Collector.Characteristics#UNORDERED", "Collector.Characteristics#CONCURRENT", "java.util.function.Function#identity()", "#toConcurrentMap(Function" ]
  }, {
    "name" : "public static Collector<T, ?, ConcurrentMap<K, U>> toConcurrentMap(Function<? super T, ? extends K> keyMapper, Function<? super T, ? extends U> valueMapper, BinaryOperator<U> mergeFunction)",
    "returnType" : "Collector<T, ?, ConcurrentMap<K, U>>",
    "comment" : "\n     * Returns a concurrent {@code Collector} that accumulates elements into a\n     * {@code ConcurrentMap} whose keys and values are the result of applying\n     * the provided mapping functions to the input elements.\n     *\n     * <p>If the mapped keys contain duplicates (according to {@link Object#equals(Object)}),\n     * the value mapping function is applied to each equal element, and the\n     * results are merged using the provided merging function.\n     *\n     * <p>There are no guarantees on the type, mutability, or serializability\n     * of the {@code ConcurrentMap} returned.\n     *\n     * @apiNote\n     * There are multiple ways to deal with collisions between multiple elements\n     * mapping to the same key.  The other forms of {@code toConcurrentMap} simply use\n     * a merge function that throws unconditionally, but you can easily write\n     * more flexible merge policies.  For example, if you have a stream\n     * of {@code Person}, and you want to produce a \"phone book\" mapping name to\n     * address, but it is possible that two persons have the same name, you can\n     * do as follows to gracefully deal with these collisions, and produce a\n     * {@code ConcurrentMap} mapping names to a concatenated list of addresses:\n     * <pre>{@code\n     * ConcurrentMap<String, String> phoneBook\n     *   = people.stream().collect(\n     *     toConcurrentMap(Person::getName,\n     *                     Person::getAddress,\n     *                     (s, a) -> s + \", \" + a));\n     * }</pre>\n     *\n     * <p>This is a {@link Collector.Characteristics#CONCURRENT concurrent} and\n     * {@link Collector.Characteristics#UNORDERED unordered} Collector.\n     *\n     * @param <T> the type of the input elements\n     * @param <K> the output type of the key mapping function\n     * @param <U> the output type of the value mapping function\n     * @param keyMapper a mapping function to produce keys\n     * @param valueMapper a mapping function to produce values\n     * @param mergeFunction a merge function, used to resolve collisions between\n     *                      values associated with the same key, as supplied\n     *                      to {@link Map#merge(Object, Object, BiFunction)}\n     * @return a concurrent, unordered {@code Collector} which collects elements into a\n     * {@code ConcurrentMap} whose keys are the result of applying a key mapping\n     * function to the input elements, and whose values are the result of\n     * applying a value mapping function to all input elements equal to the key\n     * and combining them using the merge function\n     *\n     * @see #toConcurrentMap(Function, Function)\n     * @see #toConcurrentMap(Function, Function, BinaryOperator, Supplier)\n     * @see #toMap(Function, Function, BinaryOperator)\n     ",
    "links" : [ "#equals(Object)", "Collector.Characteristics#UNORDERED", "Collector.Characteristics#CONCURRENT", "java.util.AbstractMap#merge(Object" ]
  }, {
    "name" : "public static Collector<T, ?, M> toConcurrentMap(Function<? super T, ? extends K> keyMapper, Function<? super T, ? extends U> valueMapper, BinaryOperator<U> mergeFunction, Supplier<M> mapFactory)",
    "returnType" : "Collector<T, ?, M>",
    "comment" : "\n     * Returns a concurrent {@code Collector} that accumulates elements into a\n     * {@code ConcurrentMap} whose keys and values are the result of applying\n     * the provided mapping functions to the input elements.\n     *\n     * <p>If the mapped keys contain duplicates (according to {@link Object#equals(Object)}),\n     * the value mapping function is applied to each equal element, and the\n     * results are merged using the provided merging function.  The\n     * {@code ConcurrentMap} is created by a provided supplier function.\n     *\n     * <p>This is a {@link Collector.Characteristics#CONCURRENT concurrent} and\n     * {@link Collector.Characteristics#UNORDERED unordered} Collector.\n     *\n     * @param <T> the type of the input elements\n     * @param <K> the output type of the key mapping function\n     * @param <U> the output type of the value mapping function\n     * @param <M> the type of the resulting {@code ConcurrentMap}\n     * @param keyMapper a mapping function to produce keys\n     * @param valueMapper a mapping function to produce values\n     * @param mergeFunction a merge function, used to resolve collisions between\n     *                      values associated with the same key, as supplied\n     *                      to {@link Map#merge(Object, Object, BiFunction)}\n     * @param mapFactory a supplier providing a new empty {@code ConcurrentMap}\n     *                   into which the results will be inserted\n     * @return a concurrent, unordered {@code Collector} which collects elements into a\n     * {@code ConcurrentMap} whose keys are the result of applying a key mapping\n     * function to the input elements, and whose values are the result of\n     * applying a value mapping function to all input elements equal to the key\n     * and combining them using the merge function\n     *\n     * @see #toConcurrentMap(Function, Function)\n     * @see #toConcurrentMap(Function, Function, BinaryOperator)\n     * @see #toMap(Function, Function, BinaryOperator, Supplier)\n     ",
    "links" : [ "#equals(Object)", "Collector.Characteristics#UNORDERED", "Collector.Characteristics#CONCURRENT", "java.util.AbstractMap#merge(Object" ]
  }, {
    "name" : "public static Collector<T, ?, IntSummaryStatistics> summarizingInt(ToIntFunction<? super T> mapper)",
    "returnType" : "Collector<T, ?, IntSummaryStatistics>",
    "comment" : "\n     * Returns a {@code Collector} which applies an {@code int}-producing\n     * mapping function to each input element, and returns summary statistics\n     * for the resulting values.\n     *\n     * @param <T> the type of the input elements\n     * @param mapper a mapping function to apply to each element\n     * @return a {@code Collector} implementing the summary-statistics reduction\n     *\n     * @see #summarizingDouble(ToDoubleFunction)\n     * @see #summarizingLong(ToLongFunction)\n     ",
    "links" : [ ]
  }, {
    "name" : "public static Collector<T, ?, LongSummaryStatistics> summarizingLong(ToLongFunction<? super T> mapper)",
    "returnType" : "Collector<T, ?, LongSummaryStatistics>",
    "comment" : "\n     * Returns a {@code Collector} which applies an {@code long}-producing\n     * mapping function to each input element, and returns summary statistics\n     * for the resulting values.\n     *\n     * @param <T> the type of the input elements\n     * @param mapper the mapping function to apply to each element\n     * @return a {@code Collector} implementing the summary-statistics reduction\n     *\n     * @see #summarizingDouble(ToDoubleFunction)\n     * @see #summarizingInt(ToIntFunction)\n     ",
    "links" : [ ]
  }, {
    "name" : "public static Collector<T, ?, DoubleSummaryStatistics> summarizingDouble(ToDoubleFunction<? super T> mapper)",
    "returnType" : "Collector<T, ?, DoubleSummaryStatistics>",
    "comment" : "\n     * Returns a {@code Collector} which applies an {@code double}-producing\n     * mapping function to each input element, and returns summary statistics\n     * for the resulting values.\n     *\n     * @param <T> the type of the input elements\n     * @param mapper a mapping function to apply to each element\n     * @return a {@code Collector} implementing the summary-statistics reduction\n     *\n     * @see #summarizingLong(ToLongFunction)\n     * @see #summarizingInt(ToIntFunction)\n     ",
    "links" : [ ]
  }, {
    "name" : "public static Collector<T, ?, R> teeing(Collector<? super T, ?, R1> downstream1, Collector<? super T, ?, R2> downstream2, BiFunction<? super R1, ? super R2, R> merger)",
    "returnType" : "Collector<T, ?, R>",
    "comment" : "\n     * Returns a {@code Collector} that is a composite of two downstream collectors.\n     * Every element passed to the resulting collector is processed by both downstream\n     * collectors, then their results are merged using the specified merge function\n     * into the final result.\n     *\n     * <p>The resulting collector functions do the following:\n     *\n     * <ul>\n     * <li>supplier: creates a result container that contains result containers\n     * obtained by calling each collector's supplier\n     * <li>accumulator: calls each collector's accumulator with its result container\n     * and the input element\n     * <li>combiner: calls each collector's combiner with two result containers\n     * <li>finisher: calls each collector's finisher with its result container,\n     * then calls the supplied merger and returns its result.\n     * </ul>\n     *\n     * <p>The resulting collector is {@link Collector.Characteristics#UNORDERED} if both downstream\n     * collectors are unordered and {@link Collector.Characteristics#CONCURRENT} if both downstream\n     * collectors are concurrent.\n     *\n     * @param <T>         the type of the input elements\n     * @param <R1>        the result type of the first collector\n     * @param <R2>        the result type of the second collector\n     * @param <R>         the final result type\n     * @param downstream1 the first downstream collector\n     * @param downstream2 the second downstream collector\n     * @param merger      the function which merges two results into the single one\n     * @return a {@code Collector} which aggregates the results of two supplied collectors.\n     * @since 12\n     ",
    "links" : [ "Collector.Characteristics#UNORDERED", "Collector.Characteristics#CONCURRENT" ]
  }, {
    "name" : "private static Collector<T, ?, R> teeing0(Collector<? super T, A1, R1> downstream1, Collector<? super T, A2, R2> downstream2, BiFunction<? super R1, ? super R2, R> merger)",
    "returnType" : "Collector<T, ?, R>",
    "comment" : "",
    "links" : [ ]
  } ],
  "methodNames" : [ "private static IllegalStateException duplicateKeyException(Object k, Object u, Object v)", "private static BinaryOperator<M> uniqKeysMapMerger()", "private static BiConsumer<Map<K, V>, T> uniqKeysMapAccumulator(Function<? super T, ? extends K> keyMapper, Function<? super T, ? extends V> valueMapper)", "private static Function<I, R> castingIdentity()", "public static Collector<T, ?, C> toCollection(Supplier<C> collectionFactory)", "public static Collector<T, ?, List<T>> toList()", "public static Collector<T, ?, List<T>> toUnmodifiableList()", "public static Collector<T, ?, Set<T>> toSet()", "public static Collector<T, ?, Set<T>> toUnmodifiableSet()", "public static Collector<CharSequence, ?, String> joining()", "public static Collector<CharSequence, ?, String> joining(CharSequence delimiter)", "public static Collector<CharSequence, ?, String> joining(CharSequence delimiter, CharSequence prefix, CharSequence suffix)", "private static BinaryOperator<M> mapMerger(BinaryOperator<V> mergeFunction)", "public static Collector<T, ?, R> mapping(Function<? super T, ? extends U> mapper, Collector<? super U, A, R> downstream)", "public static Collector<T, ?, R> flatMapping(Function<? super T, ? extends Stream<? extends U>> mapper, Collector<? super U, A, R> downstream)", "public static Collector<T, ?, R> filtering(Predicate<? super T> predicate, Collector<? super T, A, R> downstream)", "public static Collector<T, A, RR> collectingAndThen(Collector<T, A, R> downstream, Function<R, RR> finisher)", "public static Collector<T, ?, Long> counting()", "public static Collector<T, ?, Optional<T>> minBy(Comparator<? super T> comparator)", "public static Collector<T, ?, Optional<T>> maxBy(Comparator<? super T> comparator)", "public static Collector<T, ?, Integer> summingInt(ToIntFunction<? super T> mapper)", "public static Collector<T, ?, Long> summingLong(ToLongFunction<? super T> mapper)", "public static Collector<T, ?, Double> summingDouble(ToDoubleFunction<? super T> mapper)", " static double[] sumWithCompensation(double[] intermediateSum, double value)", " static double computeFinalSum(double[] summands)", "public static Collector<T, ?, Double> averagingInt(ToIntFunction<? super T> mapper)", "public static Collector<T, ?, Double> averagingLong(ToLongFunction<? super T> mapper)", "public static Collector<T, ?, Double> averagingDouble(ToDoubleFunction<? super T> mapper)", "public static Collector<T, ?, T> reducing(T identity, BinaryOperator<T> op)", "private static Supplier<T[]> boxSupplier(T identity)", "public static Collector<T, ?, Optional<T>> reducing(BinaryOperator<T> op)", "public static Collector<T, ?, U> reducing(U identity, Function<? super T, ? extends U> mapper, BinaryOperator<U> op)", "public static Collector<T, ?, Map<K, List<T>>> groupingBy(Function<? super T, ? extends K> classifier)", "public static Collector<T, ?, Map<K, D>> groupingBy(Function<? super T, ? extends K> classifier, Collector<? super T, A, D> downstream)", "public static Collector<T, ?, M> groupingBy(Function<? super T, ? extends K> classifier, Supplier<M> mapFactory, Collector<? super T, A, D> downstream)", "public static Collector<T, ?, ConcurrentMap<K, List<T>>> groupingByConcurrent(Function<? super T, ? extends K> classifier)", "public static Collector<T, ?, ConcurrentMap<K, D>> groupingByConcurrent(Function<? super T, ? extends K> classifier, Collector<? super T, A, D> downstream)", "public static Collector<T, ?, M> groupingByConcurrent(Function<? super T, ? extends K> classifier, Supplier<M> mapFactory, Collector<? super T, A, D> downstream)", "public static Collector<T, ?, Map<Boolean, List<T>>> partitioningBy(Predicate<? super T> predicate)", "public static Collector<T, ?, Map<Boolean, D>> partitioningBy(Predicate<? super T> predicate, Collector<? super T, A, D> downstream)", "public static Collector<T, ?, Map<K, U>> toMap(Function<? super T, ? extends K> keyMapper, Function<? super T, ? extends U> valueMapper)", "public static Collector<T, ?, Map<K, U>> toUnmodifiableMap(Function<? super T, ? extends K> keyMapper, Function<? super T, ? extends U> valueMapper)", "public static Collector<T, ?, Map<K, U>> toMap(Function<? super T, ? extends K> keyMapper, Function<? super T, ? extends U> valueMapper, BinaryOperator<U> mergeFunction)", "public static Collector<T, ?, Map<K, U>> toUnmodifiableMap(Function<? super T, ? extends K> keyMapper, Function<? super T, ? extends U> valueMapper, BinaryOperator<U> mergeFunction)", "public static Collector<T, ?, M> toMap(Function<? super T, ? extends K> keyMapper, Function<? super T, ? extends U> valueMapper, BinaryOperator<U> mergeFunction, Supplier<M> mapFactory)", "public static Collector<T, ?, ConcurrentMap<K, U>> toConcurrentMap(Function<? super T, ? extends K> keyMapper, Function<? super T, ? extends U> valueMapper)", "public static Collector<T, ?, ConcurrentMap<K, U>> toConcurrentMap(Function<? super T, ? extends K> keyMapper, Function<? super T, ? extends U> valueMapper, BinaryOperator<U> mergeFunction)", "public static Collector<T, ?, M> toConcurrentMap(Function<? super T, ? extends K> keyMapper, Function<? super T, ? extends U> valueMapper, BinaryOperator<U> mergeFunction, Supplier<M> mapFactory)", "public static Collector<T, ?, IntSummaryStatistics> summarizingInt(ToIntFunction<? super T> mapper)", "public static Collector<T, ?, LongSummaryStatistics> summarizingLong(ToLongFunction<? super T> mapper)", "public static Collector<T, ?, DoubleSummaryStatistics> summarizingDouble(ToDoubleFunction<? super T> mapper)", "public static Collector<T, ?, R> teeing(Collector<? super T, ?, R1> downstream1, Collector<? super T, ?, R2> downstream2, BiFunction<? super R1, ? super R2, R> merger)", "private static Collector<T, ?, R> teeing0(Collector<? super T, A1, R1> downstream1, Collector<? super T, A2, R2> downstream2, BiFunction<? super R1, ? super R2, R> merger)" ],
  "variableNames" : [ "CH_CONCURRENT_ID", "CH_CONCURRENT_NOID", "CH_ID", "CH_UNORDERED_ID", "CH_NOID", "CH_UNORDERED_NOID" ]
}