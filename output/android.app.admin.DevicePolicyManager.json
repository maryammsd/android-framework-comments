{
  "filePath" : "/home/maryam/clearblue/files/android-source-35/android/app/admin/DevicePolicyManager.java",
  "packageName" : "android.app.admin",
  "className" : "DevicePolicyManager",
  "comment" : "",
  "links" : [ ],
  "variables" : [ {
    "name" : "DEPRECATE_USERMANAGERINTERNAL_DEVICEPOLICY_FLAG",
    "type" : "String",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "DEPRECATE_USERMANAGERINTERNAL_DEVICEPOLICY_DEFAULT",
    "type" : "boolean",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "ADD_ISFINANCED_DEVICE_FLAG",
    "type" : "String",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "ADD_ISFINANCED_FEVICE_DEFAULT",
    "type" : "boolean",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "TAG",
    "type" : "String",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mContext",
    "type" : "Context",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mService",
    "type" : "IDevicePolicyManager",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mParentInstance",
    "type" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mResourcesManager",
    "type" : "DevicePolicyResourcesManager",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "ACTION_PROVISION_MANAGED_PROFILE",
    "type" : "String",
    "comment" : "\n     * Activity action: Starts the provisioning flow which sets up a\n     * <a href=\"#managed-profile\">managed profile</a>.\n     *\n     * <p>It is possible to check if provisioning is allowed or not by querying the method\n     * {@link #isProvisioningAllowed(String)}.\n     *\n     * <p>The intent may contain the following extras:\n     *\n     * <table>\n     *  <thead>\n     *      <tr>\n     *          <th>Extra</th>\n     *          <th></th>\n     *          <th>Supported Versions</th>\n     *      </tr>\n     *  </thead>\n     *  <tbody>\n     *      <tr>\n     *          <td>{@link #EXTRA_PROVISIONING_ACCOUNT_TO_MIGRATE}</td>\n     *          <td colspan=\"2\"></td>\n     *      </tr>\n     *      <tr>\n     *          <td>{@link #EXTRA_PROVISIONING_SKIP_ENCRYPTION}</td>\n     *          <td></td>\n     *          <td>{@link android.os.Build.VERSION_CODES#N}+</td>\n     *      </tr>\n     *      <tr>\n     *          <td>{@link #EXTRA_PROVISIONING_ADMIN_EXTRAS_BUNDLE}</td>\n     *          <td colspan=\"2\"></td>\n     *      </tr>\n     *      <tr>\n     *          <td>{@link #EXTRA_PROVISIONING_LOGO_URI}</td>\n     *          <td colspan=\"2\"></td>\n     *      </tr>\n     *      <tr>\n     *          <td>{@link #EXTRA_PROVISIONING_SKIP_USER_CONSENT}</td>\n     *          <td colspan=\"2\"><b>Can only be used by an existing device owner trying to create a\n     *          managed profile</b></td>\n     *      </tr>\n     *      <tr>\n     *          <td>{@link #EXTRA_PROVISIONING_KEEP_ACCOUNT_ON_MIGRATION}</td>\n     *          <td colspan=\"2\"></td>\n     *      </tr>\n     *      <tr>\n     *          <td>{@link #EXTRA_PROVISIONING_DISCLAIMERS}</td>\n     *          <td colspan=\"2\"></td>\n     *      </tr>\n     *      <tr>\n     *          <td>{@link #EXTRA_PROVISIONING_DEVICE_ADMIN_PACKAGE_NAME}</td>\n     *          <td>\n     *              <b>Required if {@link #EXTRA_PROVISIONING_DEVICE_ADMIN_COMPONENT_NAME} is not\n     *              specified. Must match the package name of the calling application.</b>\n     *          </td>\n     *          <td>{@link android.os.Build.VERSION_CODES#LOLLIPOP}+</td>\n     *      </tr>\n     *      <tr>\n     *          <td>{@link #EXTRA_PROVISIONING_DEVICE_ADMIN_COMPONENT_NAME}</td>\n     *          <td>\n     *              <b>Required if {@link #EXTRA_PROVISIONING_DEVICE_ADMIN_PACKAGE_NAME} is not\n     *              specified. Package name must match the package name of the calling\n     *              application.</b>\n     *          </td>\n     *          <td>{@link android.os.Build.VERSION_CODES#M}+</td>\n     *      </tr>\n     *      <tr>\n     *          <td>{@link #EXTRA_PROVISIONING_ALLOW_OFFLINE}</td>\n     *          <td colspan=\"2\">On {@link android.os.Build.VERSION_CODES#TIRAMISU}+, when set to\n     *          true this will <b>force</b> offline provisioning instead of allowing it</td>\n     *      </tr>\n     *  </tbody>\n     * </table>\n     *\n     * <p>When <a href=\"#managedprovisioning\">managed provisioning</a> has completed, broadcasts\n     * are sent to the application specified in the provisioning intent. The\n     * {@link DeviceAdminReceiver#ACTION_PROFILE_PROVISIONING_COMPLETE} broadcast is sent in the\n     * managed profile and the {@link #ACTION_MANAGED_PROFILE_PROVISIONED} broadcast is sent in\n     * the primary profile.\n     *\n     * <p>From version {@link android.os.Build.VERSION_CODES#O}, when managed provisioning has\n     * completed, along with the above broadcast, activity intent\n     * {@link #ACTION_PROVISIONING_SUCCESSFUL} will also be sent to the profile owner.\n     *\n     * <p>If provisioning fails, the managed profile is removed so the device returns to its\n     * previous state.\n     *\n     * <p>If launched with {@link android.app.Activity#startActivityForResult(Intent, int)} a\n     * result code of {@link android.app.Activity#RESULT_OK} indicates that the synchronous part of\n     * the provisioning flow was successful, although this doesn't guarantee the full flow will\n     * succeed. Conversely a result code of {@link android.app.Activity#RESULT_CANCELED} indicates\n     * that the user backed-out of provisioning or some precondition for provisioning wasn't met.\n     *\n     * <p>If a <a href=\"#roleholder\">device policy management role holder</a> updater is present on\n     * the device, an internet connection attempt must be made prior to launching this intent. If\n     * an internet connection can not be established, provisioning will fail unless {@link\n     * #EXTRA_PROVISIONING_ALLOW_OFFLINE} is explicitly set to {@code true}, in which case\n     * provisioning will continue without using the\n     * <a href=\"#roleholder\">device policy management role holder</a>. If an internet connection\n     * has been established, the <a href=\"#roleholder\">device policy management role holder</a>\n     * updater will be launched, which may update the\n     * <a href=\"#roleholder\">device policy management role holder</a> before continuing\n     * provisioning.\n     ",
    "links" : [ "android.app.admin.DeviceAdminReceiver#ACTION_PROFILE_PROVISIONING_COMPLETE", "#EXTRA_PROVISIONING_ACCOUNT_TO_MIGRATE", "#EXTRA_PROVISIONING_SKIP_ENCRYPTION", "android.os.Build.VERSION_CODES#LOLLIPOP", "#ACTION_MANAGED_PROFILE_PROVISIONED", "#EXTRA_PROVISIONING_ALLOW_OFFLINE", "#EXTRA_PROVISIONING_DEVICE_ADMIN_PACKAGE_NAME", "android.os.Build.VERSION_CODES#N", "#EXTRA_PROVISIONING_DEVICE_ADMIN_COMPONENT_NAME", "android.os.Build.VERSION_CODES#M", "android.os.Build.VERSION_CODES#TIRAMISU", "android.app.Activity#RESULT_CANCELED", "#isProvisioningAllowed(String)", "android.os.Build.VERSION_CODES#O", "android.app.Activity#RESULT_OK", "android.app.Activity#startActivityForResult(Intent", "#EXTRA_PROVISIONING_KEEP_ACCOUNT_ON_MIGRATION", "#EXTRA_PROVISIONING_SKIP_USER_CONSENT", "#EXTRA_PROVISIONING_DISCLAIMERS", "#EXTRA_PROVISIONING_LOGO_URI", "#EXTRA_PROVISIONING_ADMIN_EXTRAS_BUNDLE", "#ACTION_PROVISIONING_SUCCESSFUL" ]
  }, {
    "name" : "ACTION_PROVISION_MANAGED_USER",
    "type" : "String",
    "comment" : "\n     * Activity action: Starts the provisioning flow which sets up a managed user.\n     *\n     * <p>This intent will typically be sent by a mobile device management application (MDM).\n     * Provisioning configures the user as managed user and sets the MDM as the profile\n     * owner who has full control over the user. Provisioning can only happen before user setup has\n     * been completed. Use {@link #isProvisioningAllowed(String)} to check if provisioning is\n     * allowed.\n     *\n     * <p>The intent contains the following extras:\n     * <ul>\n     * <li>{@link #EXTRA_PROVISIONING_DEVICE_ADMIN_COMPONENT_NAME}</li>\n     * <li>{@link #EXTRA_PROVISIONING_SKIP_ENCRYPTION}, optional</li>\n     * <li>{@link #EXTRA_PROVISIONING_ADMIN_EXTRAS_BUNDLE}, optional</li>\n     * <li>{@link #EXTRA_PROVISIONING_LOGO_URI}, optional</li>\n     * </ul>\n     *\n     * <p>If provisioning fails, the device returns to its previous state.\n     *\n     * <p>If launched with {@link android.app.Activity#startActivityForResult(Intent, int)} a\n     * result code of {@link android.app.Activity#RESULT_OK} implies that the synchronous part of\n     * the provisioning flow was successful, although this doesn't guarantee the full flow will\n     * succeed. Conversely a result code of {@link android.app.Activity#RESULT_CANCELED} implies\n     * that the user backed-out of provisioning, or some precondition for provisioning wasn't met.\n     *\n     * @hide\n     ",
    "links" : [ "android.app.Activity#RESULT_CANCELED", "#isProvisioningAllowed(String)", "#EXTRA_PROVISIONING_SKIP_ENCRYPTION", "android.app.Activity#RESULT_OK", "android.app.Activity#startActivityForResult(Intent", "#EXTRA_PROVISIONING_LOGO_URI", "#EXTRA_PROVISIONING_ADMIN_EXTRAS_BUNDLE", "#EXTRA_PROVISIONING_DEVICE_ADMIN_COMPONENT_NAME" ]
  }, {
    "name" : "ACTION_PROVISION_MANAGED_DEVICE",
    "type" : "String",
    "comment" : "\n     * Activity action: Starts the provisioning flow which sets up a managed device.\n     * Must be started with {@link android.app.Activity#startActivityForResult(Intent, int)}.\n     *\n     * <p> During device owner provisioning a device admin app is set as the owner of the device.\n     * A device owner has full control over the device. The device owner can not be modified by the\n     * user.\n     *\n     * <p> A typical use case would be a device that is owned by a company, but used by either an\n     * employee or client.\n     *\n     * <p> An intent with this action can be sent only on an unprovisioned device.\n     * It is possible to check if provisioning is allowed or not by querying the method\n     * {@link #isProvisioningAllowed(String)}.\n     *\n     * <p>The intent contains the following extras:\n     * <ul>\n     * <li>{@link #EXTRA_PROVISIONING_DEVICE_ADMIN_COMPONENT_NAME}</li>\n     * <li>{@link #EXTRA_PROVISIONING_SKIP_ENCRYPTION}, optional</li>\n     * <li>{@link #EXTRA_PROVISIONING_LEAVE_ALL_SYSTEM_APPS_ENABLED}, optional</li>\n     * <li>{@link #EXTRA_PROVISIONING_ADMIN_EXTRAS_BUNDLE}, optional</li>\n     * <li>{@link #EXTRA_PROVISIONING_LOGO_URI}, optional</li>\n     * <li>{@link #EXTRA_PROVISIONING_DISCLAIMERS}, optional</li>\n     * <li>{@link #EXTRA_PROVISIONING_SKIP_EDUCATION_SCREENS}, optional</li>\n     * </ul>\n     *\n     * <p>When device owner provisioning has completed, an intent of the type\n     * {@link DeviceAdminReceiver#ACTION_PROFILE_PROVISIONING_COMPLETE} is broadcast to the\n     * device owner.\n     *\n     * <p>From version {@link android.os.Build.VERSION_CODES#O}, when device owner provisioning has\n     * completed, along with the above broadcast, activity intent\n     * {@link #ACTION_PROVISIONING_SUCCESSFUL} will also be sent to the device owner.\n     *\n     * <p>If provisioning fails, the device is factory reset.\n     *\n     * <p>A result code of {@link android.app.Activity#RESULT_OK} implies that the synchronous part\n     * of the provisioning flow was successful, although this doesn't guarantee the full flow will\n     * succeed. Conversely a result code of {@link android.app.Activity#RESULT_CANCELED} implies\n     * that the user backed-out of provisioning, or some precondition for provisioning wasn't met.\n     *\n     * @deprecated to support {@link android.os.Build.VERSION_CODES#S} and later, admin apps must\n     * implement activities with intent filters for the {@link #ACTION_GET_PROVISIONING_MODE} and\n     * {@link #ACTION_ADMIN_POLICY_COMPLIANCE} intent actions; using {@link\n     * #ACTION_PROVISION_MANAGED_DEVICE} to start provisioning will cause the provisioning to fail;\n     * to additionally support pre-{@link android.os.Build.VERSION_CODES#S}, admin apps must also\n     * continue to use this constant.\n     ",
    "links" : [ "android.app.admin.DeviceAdminReceiver#ACTION_PROFILE_PROVISIONING_COMPLETE", "#ACTION_PROVISION_MANAGED_DEVICE", "#EXTRA_PROVISIONING_SKIP_ENCRYPTION", "#EXTRA_PROVISIONING_LEAVE_ALL_SYSTEM_APPS_ENABLED", "#ACTION_ADMIN_POLICY_COMPLIANCE", "#EXTRA_PROVISIONING_DEVICE_ADMIN_COMPONENT_NAME", "android.app.Activity#RESULT_CANCELED", "#isProvisioningAllowed(String)", "android.os.Build.VERSION_CODES#O", "android.app.Activity#RESULT_OK", "android.app.Activity#startActivityForResult(Intent", "#ACTION_GET_PROVISIONING_MODE", "android.os.Build.VERSION_CODES#S", "#EXTRA_PROVISIONING_DISCLAIMERS", "#EXTRA_PROVISIONING_LOGO_URI", "#EXTRA_PROVISIONING_ADMIN_EXTRAS_BUNDLE", "#EXTRA_PROVISIONING_SKIP_EDUCATION_SCREENS", "#ACTION_PROVISIONING_SUCCESSFUL" ]
  }, {
    "name" : "ACTION_STATE_USER_SETUP_COMPLETE",
    "type" : "String",
    "comment" : "\n     * Activity action: launch when user provisioning completed, i.e.\n     * {@link #getUserProvisioningState()} returns one of the complete state.\n     *\n     * <p> Please note that the API behavior is not necessarily consistent across various releases,\n     * and devices, as it's contract between SetupWizard and ManagedProvisioning. The default\n     * implementation is that ManagedProvisioning launches SetupWizard in NFC provisioning only.\n     *\n     * <p> The activity must be protected by permission\n     * {@link android.Manifest.permission#BIND_DEVICE_ADMIN}, and the process must hold\n     * {@link android.Manifest.permission#DISPATCH_PROVISIONING_MESSAGE} to be launched.\n     * Only one {@link ComponentName} in the entire system should be enabled, and the rest of the\n     * components are not started by this intent.\n     *\n     * @deprecated Starting from Android 13, the system no longer launches an intent with this\n     * action when user provisioning completes.\n     * @hide\n     ",
    "links" : [ "#getUserProvisioningState()", "android.Manifest.permission#BIND_DEVICE_ADMIN", "android.content.ComponentName", "android.Manifest.permission#DISPATCH_PROVISIONING_MESSAGE" ]
  }, {
    "name" : "ACTION_PROVISION_MANAGED_DEVICE_FROM_TRUSTED_SOURCE",
    "type" : "String",
    "comment" : "\n     * Activity action: Starts the provisioning flow which sets up a managed device.\n     *\n     * <p>During device owner provisioning, a device admin app is downloaded and set as the owner of\n     * the device. A device owner has full control over the device. The device owner can not be\n     * modified by the user and the only way of resetting the device is via factory reset.\n     *\n     * <p>From version {@link android.os.Build.VERSION_CODES#Q}, the admin app can choose\n     * whether to set up a fully managed device or a managed profile. For the admin app to support\n     * this, it must have an activity with intent filter {@link #ACTION_GET_PROVISIONING_MODE} and\n     * another one with intent filter {@link #ACTION_ADMIN_POLICY_COMPLIANCE}. For example:\n     * <pre>\n     * &lt;activity\n     *     android:name=\".GetProvisioningModeActivity\"\n     *     android:label=\"@string/app_name\"\n     *     android:permission=\"android.permission.BIND_DEVICE_ADMIN\"&gt;\n     *     &lt;intent-filter&gt;\n     *         &lt;action\n     *             android:name=\"android.app.action.GET_PROVISIONING_MODE\" /&gt;\n     *         &lt;category android:name=\"android.intent.category.DEFAULT\" /&gt;\n     *     &lt;/intent-filter&gt;\n     * &lt;/activity&gt;\n     *\n     * &lt;activity\n     *     android:name=\".PolicyComplianceActivity\"\n     *     android:label=\"@string/app_name\"\n     *     android:permission=\"android.permission.BIND_DEVICE_ADMIN\"&gt;\n     *     &lt;intent-filter&gt;\n     *         &lt;action\n     *             android:name=\"android.app.action.ADMIN_POLICY_COMPLIANCE\" /&gt;\n     *         &lt;category android:name=\"android.intent.category.DEFAULT\" /&gt;\n     *     &lt;/intent-filter&gt;\n     * &lt;/activity&gt;</pre>\n     *\n     * <p>A typical use case would be a device that is owned by a company, but used by either an\n     * employee or client.\n     *\n     * <p>The provisioning message should be sent to an unprovisioned device.\n     *\n     * <p>Unlike {@link #ACTION_PROVISION_MANAGED_DEVICE}, the provisioning message can only be sent\n     * by a privileged app with the permission\n     * {@link android.Manifest.permission#DISPATCH_PROVISIONING_MESSAGE}.\n     *\n     * <p>If a device policy management role holder (DPMRH) updater is present on the device, an\n     * internet connection attempt must be made prior to launching this intent. If internet\n     * connection could not be established, provisioning will fail unless {@link\n     * #EXTRA_PROVISIONING_ALLOW_OFFLINE} is explicitly set to {@code true}, in which case\n     * provisioning will continue without using the DPMRH. If an internet connection has been\n     * established, the DPMRH updater will be launched via {@link\n     * #ACTION_UPDATE_DEVICE_MANAGEMENT_ROLE_HOLDER}, which will update the DPMRH if it's not\n     * present on the device, or if it's present and not valid.\n     *\n     * <p>A DPMRH is considered valid if it has intent filters for {@link\n     * #ACTION_ROLE_HOLDER_PROVISION_MANAGED_DEVICE_FROM_TRUSTED_SOURCE}, {@link\n     * #ACTION_ROLE_HOLDER_PROVISION_MANAGED_PROFILE} and {@link\n     * #ACTION_ROLE_HOLDER_PROVISION_FINALIZATION}.\n     *\n     * <p>If a DPMRH is present on the device and valid, the provisioning flow will be deferred to\n     * it via the {@link #ACTION_ROLE_HOLDER_PROVISION_MANAGED_DEVICE_FROM_TRUSTED_SOURCE} intent.\n     *\n     * <p>The provisioning intent contains the following properties:\n     * <ul>\n     * <li>{@link #EXTRA_PROVISIONING_DEVICE_ADMIN_COMPONENT_NAME}</li>\n     * <li>{@link #EXTRA_PROVISIONING_DEVICE_ADMIN_PACKAGE_DOWNLOAD_LOCATION}, optional</li>\n     * <li>{@link #EXTRA_PROVISIONING_DEVICE_ADMIN_PACKAGE_DOWNLOAD_COOKIE_HEADER}, optional</li>\n     * <li>{@link #EXTRA_PROVISIONING_DEVICE_ADMIN_PACKAGE_CHECKSUM}, optional</li>\n     * <li>{@link #EXTRA_PROVISIONING_LOCAL_TIME} (convert to String), optional</li>\n     * <li>{@link #EXTRA_PROVISIONING_TIME_ZONE}, optional</li>\n     * <li>{@link #EXTRA_PROVISIONING_LOCALE}, optional</li>\n     * <li>{@link #EXTRA_PROVISIONING_WIFI_SSID}, optional</li>\n     * <li>{@link #EXTRA_PROVISIONING_WIFI_HIDDEN} (convert to String), optional</li>\n     * <li>{@link #EXTRA_PROVISIONING_WIFI_SECURITY_TYPE}, optional</li>\n     * <li>{@link #EXTRA_PROVISIONING_WIFI_PASSWORD}, optional</li>\n     * <li>{@link #EXTRA_PROVISIONING_WIFI_PROXY_HOST}, optional</li>\n     * <li>{@link #EXTRA_PROVISIONING_WIFI_PROXY_PORT} (convert to String), optional</li>\n     * <li>{@link #EXTRA_PROVISIONING_WIFI_PROXY_BYPASS}, optional</li>\n     * <li>{@link #EXTRA_PROVISIONING_WIFI_PAC_URL}, optional</li>\n     * <li>{@link #EXTRA_PROVISIONING_SUPPORT_URL}, optional</li>\n     * <li>{@link #EXTRA_PROVISIONING_ORGANIZATION_NAME}, optional</li>\n     * <li>{@link #EXTRA_PROVISIONING_ADMIN_EXTRAS_BUNDLE}, optional</li>\n     * <li>{@link #EXTRA_PROVISIONING_USE_MOBILE_DATA}, optional </li>\n     * <li>{@link #EXTRA_PROVISIONING_SKIP_EDUCATION_SCREENS}, optional - when not used for\n     * cloud enrollment, NFC or QR provisioning</li>\n     * </ul>\n     *\n     * @hide\n     ",
    "links" : [ "#EXTRA_PROVISIONING_LOCALE", "#EXTRA_PROVISIONING_WIFI_PROXY_BYPASS", "#EXTRA_PROVISIONING_WIFI_PROXY_HOST", "#EXTRA_PROVISIONING_USE_MOBILE_DATA", "#ACTION_ROLE_HOLDER_PROVISION_FINALIZATION", "#EXTRA_PROVISIONING_DEVICE_ADMIN_COMPONENT_NAME", "#EXTRA_PROVISIONING_WIFI_PROXY_PORT", "#EXTRA_PROVISIONING_LOCAL_TIME", "#EXTRA_PROVISIONING_ORGANIZATION_NAME", "#EXTRA_PROVISIONING_WIFI_HIDDEN", "#EXTRA_PROVISIONING_DEVICE_ADMIN_PACKAGE_DOWNLOAD_LOCATION", "#EXTRA_PROVISIONING_ADMIN_EXTRAS_BUNDLE", "#ACTION_PROVISION_MANAGED_DEVICE", "#ACTION_ROLE_HOLDER_PROVISION_MANAGED_DEVICE_FROM_TRUSTED_SOURCE", "#EXTRA_PROVISIONING_DEVICE_ADMIN_PACKAGE_DOWNLOAD_COOKIE_HEADER", "#EXTRA_PROVISIONING_WIFI_SSID", "#ACTION_ADMIN_POLICY_COMPLIANCE", "#EXTRA_PROVISIONING_WIFI_PASSWORD", "android.Manifest.permission#DISPATCH_PROVISIONING_MESSAGE", "#EXTRA_PROVISIONING_ALLOW_OFFLINE", "#EXTRA_PROVISIONING_TIME_ZONE", "#EXTRA_PROVISIONING_WIFI_SECURITY_TYPE", "#EXTRA_PROVISIONING_SUPPORT_URL", "android.os.Build.VERSION_CODES#Q", "#EXTRA_PROVISIONING_WIFI_PAC_URL", "#ACTION_GET_PROVISIONING_MODE", "#EXTRA_PROVISIONING_DEVICE_ADMIN_PACKAGE_CHECKSUM", "#ACTION_ROLE_HOLDER_PROVISION_MANAGED_PROFILE", "#ACTION_UPDATE_DEVICE_MANAGEMENT_ROLE_HOLDER", "#EXTRA_PROVISIONING_SKIP_EDUCATION_SCREENS" ]
  }, {
    "name" : "ACTION_PROVISION_FINANCED_DEVICE",
    "type" : "String",
    "comment" : "\n     * Activity action: Starts the provisioning flow which sets up a financed device.\n     *\n     * <p>During financed device provisioning, a device admin app is downloaded and set as the owner\n     * of the device. A device owner has full control over the device. The device owner can not be\n     * modified by the user.\n     *\n     * <p>A typical use case would be a device that is bought from the reseller through financing\n     * program.\n     *\n     * <p>An intent with this action can be sent only on an unprovisioned device.\n     *\n     * <p>Unlike {@link #ACTION_PROVISION_MANAGED_DEVICE}, the provisioning message can only be sent\n     * by a privileged app with the permission\n     * {@link android.Manifest.permission#DISPATCH_PROVISIONING_MESSAGE}.\n     *\n     * <p>The provisioning intent contains the following properties:\n     * <ul>\n     * <li>{@link #EXTRA_PROVISIONING_DEVICE_ADMIN_COMPONENT_NAME}</li>\n     * <li>{@link #EXTRA_PROVISIONING_DEVICE_ADMIN_PACKAGE_DOWNLOAD_LOCATION}, optional</li>\n     * <li>{@link #EXTRA_PROVISIONING_DEVICE_ADMIN_PACKAGE_DOWNLOAD_COOKIE_HEADER}, optional</li>\n     * <li>{@link #EXTRA_PROVISIONING_DEVICE_ADMIN_PACKAGE_CHECKSUM}, optional</li>\n     * <li>{@link #EXTRA_PROVISIONING_SUPPORT_URL}, optional</li>\n     * <li>{@link #EXTRA_PROVISIONING_ORGANIZATION_NAME}, optional</li>\n     * <li>{@link #EXTRA_PROVISIONING_ADMIN_EXTRAS_BUNDLE}, optional</li>\n     * </ul>\n     *\n     * <p>Once the device admin app is set as the device owner, the following APIs are available for\n     * managing polices on the device:\n     * <ul>\n     * <li>{@link #isDeviceManaged()}</li>\n     * <li>{@link #isUninstallBlocked(ComponentName, String)}</li>\n     * <li>{@link #setUninstallBlocked(ComponentName, String, boolean)}</li>\n     * <li>{@link #setUserControlDisabledPackages(ComponentName, List)}</li>\n     * <li>{@link #getUserControlDisabledPackages(ComponentName)}</li>\n     * <li>{@link #setOrganizationName(ComponentName, CharSequence)}</li>\n     * <li>{@link #getOrganizationName(ComponentName)} </li>\n     * <li>{@link #setShortSupportMessage(ComponentName, CharSequence)}</li>\n     * <li>{@link #getShortSupportMessage(ComponentName)}</li>\n     * <li>{@link #isBackupServiceEnabled(ComponentName)}</li>\n     * <li>{@link #setBackupServiceEnabled(ComponentName, boolean)}</li>\n     * <li>{@link #isLockTaskPermitted(String)}</li>\n     * <li>{@link #setLockTaskFeatures(ComponentName, int)}, where the following lock task features\n     * can be set (otherwise a {@link SecurityException} will be thrown):</li>\n     * <ul>\n     *     <li>{@link #LOCK_TASK_FEATURE_SYSTEM_INFO}</li>\n     *     <li>{@link #LOCK_TASK_FEATURE_KEYGUARD}</li>\n     *     <li>{@link #LOCK_TASK_FEATURE_HOME}</li>\n     *     <li>{@link #LOCK_TASK_FEATURE_GLOBAL_ACTIONS}</li>\n     *     <li>{@link #LOCK_TASK_FEATURE_NOTIFICATIONS}</li>\n     *     <li>{@link #LOCK_TASK_FEATURE_BLOCK_ACTIVITY_START_IN_TASK}</li>\n     * </ul>\n     * <li>{@link #getLockTaskFeatures(ComponentName)}</li>\n     * <li>{@link #setLockTaskPackages(ComponentName, String[])}</li>\n     * <li>{@link #getLockTaskPackages(ComponentName)}</li>\n     * <li>{@link #addPersistentPreferredActivity(ComponentName, IntentFilter, ComponentName)}</li>\n     * <li>{@link #clearPackagePersistentPreferredActivities(ComponentName, String)} </li>\n     * <li>{@link #wipeData(int)}</li>\n     * <li>{@link #isDeviceOwnerApp(String)}</li>\n     * <li>{@link #clearDeviceOwnerApp(String)}</li>\n     * <li>{@link #setPermissionGrantState(ComponentName, String, String, int)}, where\n     * {@link permission#READ_PHONE_STATE} is the <b>only</b> permission that can be\n     * {@link #PERMISSION_GRANT_STATE_GRANTED}, {@link #PERMISSION_GRANT_STATE_DENIED}, or\n     * {@link #PERMISSION_GRANT_STATE_DEFAULT} and can <b>only</b> be applied to the device admin\n     * app (otherwise a {@link SecurityException} will be thrown)</li>\n     * <li>{@link #getPermissionGrantState(ComponentName, String, String)}, where\n     * {@link permission#READ_PHONE_STATE} is the <b>only</b> permission that can be\n     * used and device admin app is the only package that can be used to retrieve the permission\n     * permission grant state for (otherwise a {@link SecurityException} will be thrown)</li>\n     * <li>{@link #addUserRestriction(ComponentName, String)}, where the following user restrictions\n     * are permitted (otherwise a {@link SecurityException} will be thrown):</li>\n     * <ul>\n     *     <li>{@link UserManager#DISALLOW_ADD_USER}</li>\n     *     <li>{@link UserManager#DISALLOW_DEBUGGING_FEATURES}</li>\n     *     <li>{@link UserManager#DISALLOW_INSTALL_UNKNOWN_SOURCES}</li>\n     *     <li>{@link UserManager#DISALLOW_SAFE_BOOT}</li>\n     *     <li>{@link UserManager#DISALLOW_CONFIG_DATE_TIME}</li>\n     *     <li>{@link UserManager#DISALLOW_OUTGOING_CALLS}</li>\n     * </ul>\n     * <li>{@link #getUserRestrictions(ComponentName)}</li>\n     * <li>{@link #clearUserRestriction(ComponentName, String)}, where the following user\n     * restrictions are permitted (otherwise a {@link SecurityException} will be thrown):</li>\n     * <ul>\n     *     <li>{@link UserManager#DISALLOW_ADD_USER}</li>\n     *     <li>{@link UserManager#DISALLOW_DEBUGGING_FEATURES}</li>\n     *     <li>{@link UserManager#DISALLOW_INSTALL_UNKNOWN_SOURCES}</li>\n     *     <li>{@link UserManager#DISALLOW_SAFE_BOOT}</li>\n     *     <li>{@link UserManager#DISALLOW_CONFIG_DATE_TIME}</li>\n     *     <li>{@link UserManager#DISALLOW_OUTGOING_CALLS}</li>\n     * </ul>\n     * </ul>\n     *\n     * @hide\n     ",
    "links" : [ "#getLockTaskFeatures(ComponentName)", "#isDeviceOwnerApp(String)", "#getLockTaskPackages(ComponentName)", "#setLockTaskPackages(ComponentName", "#LOCK_TASK_FEATURE_GLOBAL_ACTIONS", "#isDeviceManaged()", "#EXTRA_PROVISIONING_ORGANIZATION_NAME", "#PERMISSION_GRANT_STATE_GRANTED", "#getPermissionGrantState(ComponentName", "android.os.UserManager#DISALLOW_INSTALL_UNKNOWN_SOURCES", "#EXTRA_PROVISIONING_DEVICE_ADMIN_PACKAGE_DOWNLOAD_LOCATION", "#EXTRA_PROVISIONING_ADMIN_EXTRAS_BUNDLE", "#LOCK_TASK_FEATURE_BLOCK_ACTIVITY_START_IN_TASK", "android.Manifest.permission#READ_PHONE_STATE", "#ACTION_PROVISION_MANAGED_DEVICE", "#isLockTaskPermitted(String)", "#setOrganizationName(ComponentName", "#setShortSupportMessage(ComponentName", "#addPersistentPreferredActivity(ComponentName", "#LOCK_TASK_FEATURE_KEYGUARD", "android.os.UserManager#DISALLOW_OUTGOING_CALLS", "android.os.UserManager#DISALLOW_CONFIG_DATE_TIME", "#isUninstallBlocked(ComponentName", "#isBackupServiceEnabled(ComponentName)", "#clearPackagePersistentPreferredActivities(ComponentName", "#getShortSupportMessage(ComponentName)", "#PERMISSION_GRANT_STATE_DENIED", "#setBackupServiceEnabled(ComponentName", "#getOrganizationName(ComponentName)", "#setPermissionGrantState(ComponentName", "#PERMISSION_GRANT_STATE_DEFAULT", "#setLockTaskFeatures(ComponentName", "android.os.UserManager#DISALLOW_DEBUGGING_FEATURES", "#EXTRA_PROVISIONING_DEVICE_ADMIN_COMPONENT_NAME", "#wipeData(int)", "#addUserRestriction(ComponentName", "#getUserControlDisabledPackages(ComponentName)", "#LOCK_TASK_FEATURE_NOTIFICATIONS", "#EXTRA_PROVISIONING_DEVICE_ADMIN_PACKAGE_DOWNLOAD_COOKIE_HEADER", "#clearDeviceOwnerApp(String)", "android.os.UserManager#DISALLOW_ADD_USER", "#setUninstallBlocked(ComponentName", "android.os.UserManager#DISALLOW_SAFE_BOOT", "android.Manifest.permission#DISPATCH_PROVISIONING_MESSAGE", "#clearUserRestriction(ComponentName", "SecurityException", "#getUserRestrictions(ComponentName)", "#EXTRA_PROVISIONING_SUPPORT_URL", "#setUserControlDisabledPackages(ComponentName", "#EXTRA_PROVISIONING_DEVICE_ADMIN_PACKAGE_CHECKSUM", "#LOCK_TASK_FEATURE_HOME", "#LOCK_TASK_FEATURE_SYSTEM_INFO" ]
  }, {
    "name" : "ACTION_PROVISION_FINALIZATION",
    "type" : "String",
    "comment" : "\n     * Activity action: Finalizes management provisioning, should be used after user-setup\n     * has been completed and {@link #getUserProvisioningState()} returns one of:\n     * <ul>\n     * <li>{@link #STATE_USER_SETUP_INCOMPLETE}</li>\n     * <li>{@link #STATE_USER_SETUP_COMPLETE}</li>\n     * <li>{@link #STATE_USER_PROFILE_COMPLETE}</li>\n     * </ul>\n     *\n     * <p>If a device policy management role holder (DPMRH) is present on the device and\n     * valid, the provisioning flow will be deferred to it via the {@link\n     * #ACTION_ROLE_HOLDER_PROVISION_FINALIZATION} intent.\n     *\n     * @hide\n     ",
    "links" : [ "#getUserProvisioningState()", "#STATE_USER_SETUP_INCOMPLETE", "#STATE_USER_SETUP_COMPLETE", "#STATE_USER_PROFILE_COMPLETE", "#ACTION_ROLE_HOLDER_PROVISION_FINALIZATION" ]
  }, {
    "name" : "ACTION_ROLE_HOLDER_PROVISION_MANAGED_PROFILE",
    "type" : "String",
    "comment" : "\n     * Activity action: starts the managed profile provisioning flow inside the device policy\n     * management role holder.\n     *\n     * <p>During the managed profile provisioning flow, the platform-provided provisioning handler\n     * will delegate provisioning to the device policy management role holder, by firing this\n     * intent. Third-party mobile device management applications attempting to fire this intent will\n     * receive a {@link SecurityException}.\n     *\n     * <p>Device policy management role holders are required to have a handler for this intent\n     * action.\n     *\n     * <p>If {@link #EXTRA_ROLE_HOLDER_STATE} is supplied to this intent, it is the responsibility\n     * of the role holder to restore its state from this extra. This is the same {@link Bundle}\n     * which the role holder returns alongside {@link #RESULT_UPDATE_ROLE_HOLDER}.\n     *\n     * <p>A result code of {@link Activity#RESULT_OK} implies that managed profile provisioning\n     * finished successfully. If it did not, a result code of {@link Activity#RESULT_CANCELED}\n     * is used instead.\n     *\n     * @see #ACTION_PROVISION_MANAGED_PROFILE\n     *\n     * @hide\n     ",
    "links" : [ "android.app.Activity#RESULT_CANCELED", "android.os.Bundle", "android.app.Activity#RESULT_OK", "#RESULT_UPDATE_ROLE_HOLDER", "SecurityException", "#EXTRA_ROLE_HOLDER_STATE" ]
  }, {
    "name" : "RESULT_WORK_PROFILE_CREATED",
    "type" : "int",
    "comment" : "\n     * Result code that can be returned by the {@link\n     * #ACTION_PROVISION_MANAGED_DEVICE_FROM_TRUSTED_SOURCE} or {@link\n     * #ACTION_ROLE_HOLDER_PROVISION_MANAGED_DEVICE_FROM_TRUSTED_SOURCE} intent handlers if a work\n     * profile has been created.\n     *\n     * @hide\n     ",
    "links" : [ "#ACTION_ROLE_HOLDER_PROVISION_MANAGED_DEVICE_FROM_TRUSTED_SOURCE", "#ACTION_PROVISION_MANAGED_DEVICE_FROM_TRUSTED_SOURCE" ]
  }, {
    "name" : "RESULT_DEVICE_OWNER_SET",
    "type" : "int",
    "comment" : "\n     * Result code that can be returned by the {@link\n     * #ACTION_PROVISION_MANAGED_DEVICE_FROM_TRUSTED_SOURCE} or {@link\n     * #ACTION_ROLE_HOLDER_PROVISION_MANAGED_DEVICE_FROM_TRUSTED_SOURCE} intent handlers if the\n     * device owner was set.\n     *\n     * @hide\n     ",
    "links" : [ "#ACTION_ROLE_HOLDER_PROVISION_MANAGED_DEVICE_FROM_TRUSTED_SOURCE", "#ACTION_PROVISION_MANAGED_DEVICE_FROM_TRUSTED_SOURCE" ]
  }, {
    "name" : "ACTION_ROLE_HOLDER_PROVISION_MANAGED_DEVICE_FROM_TRUSTED_SOURCE",
    "type" : "String",
    "comment" : "\n     * Activity action: starts the trusted source provisioning flow inside the device policy\n     * management role holder.\n     *\n     * <p>During the trusted source provisioning flow, the platform-provided provisioning handler\n     * will delegate provisioning to the device policy management role holder, by firing this\n     * intent. Third-party mobile device management applications attempting to fire this intent will\n     * receive a {@link SecurityException}.\n     *\n     * <p>Device policy management role holders are required to have a handler for this intent\n     * action.\n     *\n     * <p>If {@link #EXTRA_ROLE_HOLDER_STATE} is supplied to this intent, it is the responsibility\n     * of the role holder to restore its state from this extra. This is the same {@link Bundle}\n     * which the role holder returns alongside {@link #RESULT_UPDATE_ROLE_HOLDER}.\n     *\n     * <p>The result codes can be either {@link #RESULT_WORK_PROFILE_CREATED}, {@link\n     * #RESULT_DEVICE_OWNER_SET} or {@link Activity#RESULT_CANCELED} if provisioning failed.\n     *\n     * @see #ACTION_PROVISION_MANAGED_DEVICE_FROM_TRUSTED_SOURCE\n     *\n     * @hide\n     ",
    "links" : [ "android.app.Activity#RESULT_CANCELED", "android.os.Bundle", "#RESULT_UPDATE_ROLE_HOLDER", "SecurityException", "#RESULT_DEVICE_OWNER_SET", "#EXTRA_ROLE_HOLDER_STATE", "#RESULT_WORK_PROFILE_CREATED" ]
  }, {
    "name" : "ACTION_ROLE_HOLDER_PROVISION_FINALIZATION",
    "type" : "String",
    "comment" : "\n     * Activity action: starts the provisioning finalization flow inside the device policy\n     * management role holder.\n     *\n     * <p>During the provisioning finalization flow, the platform-provided provisioning handler\n     * will delegate provisioning to the device policy management role holder, by firing this\n     * intent. Third-party mobile device management applications attempting to fire this intent will\n     * receive a {@link SecurityException}.\n     *\n     * <p>Device policy management role holders are required to have a handler for this intent\n     * action.\n     *\n     * <p>This handler forwards the result from the admin app's {@link\n     * #ACTION_ADMIN_POLICY_COMPLIANCE} handler. Result code {@link Activity#RESULT_CANCELED}\n     * implies the provisioning finalization flow has failed.\n     *\n     * @see #ACTION_PROVISION_FINALIZATION\n     *\n     * @hide\n     ",
    "links" : [ "android.app.Activity#RESULT_CANCELED", "#ACTION_ADMIN_POLICY_COMPLIANCE", "SecurityException" ]
  }, {
    "name" : "RESULT_UPDATE_ROLE_HOLDER",
    "type" : "int",
    "comment" : "\n     * {@link Activity} result code which can be returned by {@link\n     * #ACTION_ROLE_HOLDER_PROVISION_MANAGED_PROFILE} and {@link\n     * #ACTION_ROLE_HOLDER_PROVISION_MANAGED_DEVICE_FROM_TRUSTED_SOURCE} to signal that an update\n     * to the role holder is required.\n     *\n     * <p>This result code can be accompanied by {@link #EXTRA_ROLE_HOLDER_STATE}.\n     *\n     * @hide\n     ",
    "links" : [ "#ACTION_ROLE_HOLDER_PROVISION_MANAGED_DEVICE_FROM_TRUSTED_SOURCE", "#ACTION_ROLE_HOLDER_PROVISION_MANAGED_PROFILE", "android.app.Activity", "#EXTRA_ROLE_HOLDER_STATE" ]
  }, {
    "name" : "EXTRA_ROLE_HOLDER_STATE",
    "type" : "String",
    "comment" : "\n     * A {@link PersistableBundle} extra which the role holder can use to describe its own state\n     * when it returns {@link #RESULT_UPDATE_ROLE_HOLDER}.\n     *\n     * <p>If {@link #RESULT_UPDATE_ROLE_HOLDER} was accompanied by this extra, after the update\n     * completes, the role holder's {@link #ACTION_ROLE_HOLDER_PROVISION_MANAGED_PROFILE} or {@link\n     * #ACTION_ROLE_HOLDER_PROVISION_MANAGED_DEVICE_FROM_TRUSTED_SOURCE} intent will be relaunched,\n     * which will contain this extra. It is the role holder's responsibility to restore its\n     * state from this extra.\n     *\n     * <p>The content of this {@link PersistableBundle} is entirely up to the role holder. It\n     * should contain anything the role holder needs to restore its original state when it gets\n     * restarted.\n     *\n     * @hide\n     ",
    "links" : [ "#ACTION_ROLE_HOLDER_PROVISION_MANAGED_DEVICE_FROM_TRUSTED_SOURCE", "#RESULT_UPDATE_ROLE_HOLDER", "android.os.PersistableBundle", "#ACTION_ROLE_HOLDER_PROVISION_MANAGED_PROFILE" ]
  }, {
    "name" : "EXTRA_FORCE_UPDATE_ROLE_HOLDER",
    "type" : "String",
    "comment" : "\n     * A {@code boolean} extra which determines whether to force a role holder update, regardless\n     * of any internal conditions {@link #ACTION_UPDATE_DEVICE_POLICY_MANAGEMENT_ROLE_HOLDER} might\n     * have.\n     *\n     * <p>This extra can be provided to intents with action {@link\n     * #ACTION_UPDATE_DEVICE_POLICY_MANAGEMENT_ROLE_HOLDER}.\n     *\n     * @hide\n     ",
    "links" : [ "#ACTION_UPDATE_DEVICE_POLICY_MANAGEMENT_ROLE_HOLDER" ]
  }, {
    "name" : "EXTRA_PROVISIONING_ALLOW_OFFLINE",
    "type" : "String",
    "comment" : "\n     * A boolean extra indicating whether offline provisioning should be used.\n     *\n     * <p>The default value is {@code false}.\n     *\n     * <p>Usually during the <a href=\"#managedprovisioning\">provisioning flow</a>, there will be\n     * an attempt to download and install the latest version of the <a href=\"#roleholder\">device\n     * policy management role holder</a>. The platform will then\n     * delegate provisioning to the <a href=\"#roleholder\">device\n     *      * policy management role holder</a>.\n     *\n     * <p>When this extra is set to {@code true}, the\n     * <a href=\"#managedprovisioning\">provisioning flow</a> will always be handled by the platform\n     * and the <a href=\"#roleholder\">device policy management role holder</a>'s part skipped.\n     *\n     * <p>On Android versions prior to {@link Build.VERSION_CODES#TIRAMISU}, when this extra is\n     * {@code false}, the <a href=\"#managedprovisioning\">provisioning flow</a> will enforce that an\n     * internet connection is established, or otherwise fail. When this extra is {@code true}, a\n     * connection will still be attempted but when it cannot be established provisioning will\n     * continue offline.\n     ",
    "links" : [ "Build.VERSION_CODES#TIRAMISU" ]
  }, {
    "name" : "EXTRA_PROVISIONING_ROLE_HOLDER_PACKAGE_DOWNLOAD_LOCATION",
    "type" : "String",
    "comment" : "\n     * A String extra holding a url that specifies the download location of the device policy\n     * management role holder package.\n     *\n     * <p>This is only meant to be used in cases when a specific variant of the role holder package\n     * is needed (such as a debug variant). If not provided, the default variant of the device\n     * manager role holder package is downloaded.\n     *\n     * <p>Use in an intent with action {@link #ACTION_PROVISION_MANAGED_DEVICE_FROM_TRUSTED_SOURCE}\n     * or in an NFC record with {@link #MIME_TYPE_PROVISIONING_NFC} that starts device owner\n     * provisioning via an NFC bump.\n     *\n     * @hide\n     ",
    "links" : [ "#MIME_TYPE_PROVISIONING_NFC", "#ACTION_PROVISION_MANAGED_DEVICE_FROM_TRUSTED_SOURCE" ]
  }, {
    "name" : "EXTRA_PROVISIONING_ROLE_HOLDER_SIGNATURE_CHECKSUM",
    "type" : "String",
    "comment" : "\n     * A String extra holding the URL-safe base64 encoded SHA-256 checksum of any signature of the\n     * android package archive at the download location specified in {@link\n     * #EXTRA_PROVISIONING_ROLE_HOLDER_PACKAGE_DOWNLOAD_LOCATION}.\n     *\n     * <p>The signatures of an android package archive can be obtained using\n     * {@link android.content.pm.PackageManager#getPackageArchiveInfo} with flag\n     * {@link android.content.pm.PackageManager#GET_SIGNING_CERTIFICATES}.\n     *\n     * <p>If {@link #EXTRA_PROVISIONING_ROLE_HOLDER_PACKAGE_DOWNLOAD_LOCATION} is provided, it must\n     * be accompanied by this extra. The provided checksum must match the checksum of any signature\n     * of the file at the download location. If the checksum does not match an error will be shown\n     * to the user and the user will be asked to factory reset the device.\n     *\n     * <p>Use in an intent with action {@link #ACTION_PROVISION_MANAGED_DEVICE_FROM_TRUSTED_SOURCE}\n     * or in an NFC record with {@link #MIME_TYPE_PROVISIONING_NFC} that starts device owner\n     * provisioning via an NFC bump.\n     *\n     * @hide\n     ",
    "links" : [ "android.content.pm.PackageManager#getPackageArchiveInfo", "android.content.pm.PackageManager#GET_SIGNING_CERTIFICATES", "#MIME_TYPE_PROVISIONING_NFC", "#ACTION_PROVISION_MANAGED_DEVICE_FROM_TRUSTED_SOURCE", "#EXTRA_PROVISIONING_ROLE_HOLDER_PACKAGE_DOWNLOAD_LOCATION" ]
  }, {
    "name" : "EXTRA_PROVISIONING_ROLE_HOLDER_PACKAGE_DOWNLOAD_COOKIE_HEADER",
    "type" : "String",
    "comment" : "\n     * A String extra holding a http cookie header which should be used in the http request to the\n     * url specified in {@link #EXTRA_PROVISIONING_ROLE_HOLDER_PACKAGE_DOWNLOAD_LOCATION}.\n     *\n     * <p>Use in an intent with action {@link #ACTION_PROVISION_MANAGED_DEVICE_FROM_TRUSTED_SOURCE}\n     * or in an NFC record with {@link #MIME_TYPE_PROVISIONING_NFC} that starts device owner\n     * provisioning via an NFC bump.\n     *\n     * @hide\n     ",
    "links" : [ "#MIME_TYPE_PROVISIONING_NFC", "#ACTION_PROVISION_MANAGED_DEVICE_FROM_TRUSTED_SOURCE", "#EXTRA_PROVISIONING_ROLE_HOLDER_PACKAGE_DOWNLOAD_LOCATION" ]
  }, {
    "name" : "EXTRA_PROVISIONING_ROLE_HOLDER_EXTRAS_BUNDLE",
    "type" : "String",
    "comment" : "\n     * An extra of type {@link android.os.PersistableBundle} that allows the provisioning initiator\n     * to pass data to the device policy management role holder.\n     *\n     * <p>The device policy management role holder will receive this extra via the {@link\n     * #ACTION_ROLE_HOLDER_PROVISION_MANAGED_DEVICE_FROM_TRUSTED_SOURCE} intent.\n     *\n     * <p>The contents of this extra are up to the contract between the provisioning initiator\n     * and the device policy management role holder.\n     *\n     * <p>Use in an intent with action {@link #ACTION_PROVISION_MANAGED_DEVICE_FROM_TRUSTED_SOURCE}\n     * or in an NFC record with {@link #MIME_TYPE_PROVISIONING_NFC} that starts device owner\n     * provisioning via an NFC bump.\n     *\n     * @hide\n     ",
    "links" : [ "#ACTION_ROLE_HOLDER_PROVISION_MANAGED_DEVICE_FROM_TRUSTED_SOURCE", "android.os.PersistableBundle", "#MIME_TYPE_PROVISIONING_NFC", "#ACTION_PROVISION_MANAGED_DEVICE_FROM_TRUSTED_SOURCE" ]
  }, {
    "name" : "EXTRA_ROLE_HOLDER_PROVISIONING_INITIATOR_PACKAGE",
    "type" : "String",
    "comment" : "\n     * A String extra containing the package name of the provisioning initiator.\n     *\n     * <p>Use in an intent with action {@link\n     * #ACTION_ROLE_HOLDER_PROVISION_MANAGED_DEVICE_FROM_TRUSTED_SOURCE}.\n     *\n     * @hide\n     ",
    "links" : [ "#ACTION_ROLE_HOLDER_PROVISION_MANAGED_DEVICE_FROM_TRUSTED_SOURCE" ]
  }, {
    "name" : "EXTRA_RESULT_LAUNCH_INTENT",
    "type" : "String",
    "comment" : "\n     * An {@link Intent} result extra specifying the {@link Intent} to be launched after\n     * provisioning is finalized.\n     *\n     * <p>If {@link #EXTRA_PROVISIONING_SHOULD_LAUNCH_RESULT_INTENT} is set to {@code false},\n     * this result will be supplied as part of the result {@link Intent} for provisioning actions\n     * such as {@link #ACTION_PROVISION_MANAGED_PROFILE}. This result will also be supplied as\n     * part of the result {@link Intent} for the device policy management role holder provisioning\n     * actions.\n     ",
    "links" : [ "#EXTRA_PROVISIONING_SHOULD_LAUNCH_RESULT_INTENT", "android.content.Intent", "#ACTION_PROVISION_MANAGED_PROFILE" ]
  }, {
    "name" : "EXTRA_PROVISIONING_SHOULD_LAUNCH_RESULT_INTENT",
    "type" : "String",
    "comment" : "\n     * A boolean extra that determines whether the provisioning flow should launch the resulting\n     * launch intent, if one is supplied by the device policy management role holder via {@link\n     * #EXTRA_RESULT_LAUNCH_INTENT}. Default value is {@code false}.\n     *\n     * <p>If {@code true}, the resulting intent will be launched by the provisioning flow, if one\n     * is supplied by the device policy management role holder.\n     *\n     * <p>If {@code false}, the resulting intent will be returned as {@link\n     * #EXTRA_RESULT_LAUNCH_INTENT} to the provisioning initiator, if one is supplied by the device\n     * manager role holder. It will be the responsibility of the provisioning initiator to launch\n     * this {@link Intent} after provisioning completes.\n     *\n     * <p>This extra is respected when provided via the provisioning intent actions such as {@link\n     * #ACTION_PROVISION_MANAGED_PROFILE}.\n     ",
    "links" : [ "android.content.Intent", "#ACTION_PROVISION_MANAGED_PROFILE", "#EXTRA_RESULT_LAUNCH_INTENT" ]
  }, {
    "name" : "ACTION_BUGREPORT_SHARING_ACCEPTED",
    "type" : "String",
    "comment" : "\n     * Action: Bugreport sharing with device owner has been accepted by the user.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "ACTION_BUGREPORT_SHARING_DECLINED",
    "type" : "String",
    "comment" : "\n     * Action: Bugreport sharing with device owner has been declined by the user.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "ACTION_REMOTE_BUGREPORT_DISPATCH",
    "type" : "String",
    "comment" : "\n     * Action: Bugreport has been collected and is dispatched to {@code DevicePolicyManagerService}.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "EXTRA_REMOTE_BUGREPORT_HASH",
    "type" : "String",
    "comment" : "\n     * Extra for shared bugreport's SHA-256 hash.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "EXTRA_REMOTE_BUGREPORT_NONCE",
    "type" : "String",
    "comment" : "\n     * Extra for shared bugreport's nonce in long integer type.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "EXTRA_BUGREPORT_NOTIFICATION_TYPE",
    "type" : "String",
    "comment" : "\n     * Extra for remote bugreport notification shown type.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "PREFERENTIAL_NETWORK_SERVICE_ENABLED_DEFAULT",
    "type" : "boolean",
    "comment" : "\n     * Default value for preferential network service enabling.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "NOTIFICATION_BUGREPORT_STARTED",
    "type" : "int",
    "comment" : "\n     * Notification type for a started remote bugreport flow.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "NOTIFICATION_BUGREPORT_ACCEPTED_NOT_FINISHED",
    "type" : "int",
    "comment" : "\n     * Notification type for a bugreport that has already been accepted to be shared, but is still\n     * being taken.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "NOTIFICATION_BUGREPORT_FINISHED_NOT_ACCEPTED",
    "type" : "int",
    "comment" : "\n     * Notification type for a bugreport that has been taken and can be shared or declined.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "DEFAULT_STRONG_AUTH_TIMEOUT_MS",
    "type" : "long",
    "comment" : " 72h",
    "links" : [ ]
  }, {
    "name" : "EXTRA_PROVISIONING_ADMIN_EXTRAS_BUNDLE",
    "type" : "String",
    "comment" : "\n     * A {@link android.os.Parcelable} extra of type {@link android.os.PersistableBundle} that is\n     * passed directly to the <a href=\"#devicepolicycontroller\">Device Policy Controller</a>\n     * after <a href=\"#managed-provisioning\">provisioning</a>.\n     *\n     * <p>\n     * Starting from {@link android.os.Build.VERSION_CODES#M}, if used with\n     * {@link #MIME_TYPE_PROVISIONING_NFC} as part of NFC managed device provisioning, the NFC\n     * message should contain a stringified {@link java.util.Properties} instance, whose string\n     * properties will be converted into a {@link android.os.PersistableBundle} and passed to the\n     * management application after provisioning.\n     ",
    "links" : [ "android.os.Parcelable", "java.util.Properties", "android.os.PersistableBundle", "#MIME_TYPE_PROVISIONING_NFC", "android.os.Build.VERSION_CODES#M" ]
  }, {
    "name" : "EXTRA_PROVISIONING_DEVICE_ADMIN_PACKAGE_NAME",
    "type" : "String",
    "comment" : "\n     * A String extra holding the package name of the application that\n     * will be set as <a href=\"#devicepolicycontroller\">Device Policy Controller</a>.\n     *\n     * <p>When this extra is set, the application must have exactly one\n     * {@link DeviceAdminReceiver device admin receiver}. This receiver will be set as the\n     * <a href=\"#devicepolicycontroller\">Device Policy Controller</a>.\n     *\n     * @deprecated Use {@link #EXTRA_PROVISIONING_DEVICE_ADMIN_COMPONENT_NAME}.\n     ",
    "links" : [ "android.app.admin.DeviceAdminReceiver", "#EXTRA_PROVISIONING_DEVICE_ADMIN_COMPONENT_NAME" ]
  }, {
    "name" : "EXTRA_PROVISIONING_DEVICE_ADMIN_COMPONENT_NAME",
    "type" : "String",
    "comment" : "\n     * A ComponentName extra indicating the {@link DeviceAdminReceiver device admin receiver} of\n     * the application that will be set as the <a href=\"#devicepolicycontroller\">\n     *     Device Policy Controller</a>.\n     *\n     * <p>If an application starts provisioning directly via an intent with action\n     * {@link #ACTION_PROVISION_MANAGED_DEVICE} the package name of this\n     * component has to match the package name of the application that started provisioning.\n     *\n     * <p>This component is set as device owner and active admin when device owner provisioning is\n     * started by an intent with action {@link #ACTION_PROVISION_MANAGED_DEVICE} or by an NFC\n     * message containing an NFC record with MIME type\n     * {@link #MIME_TYPE_PROVISIONING_NFC}. For the NFC record, the component name must be\n     * flattened to a string, via {@link ComponentName#flattenToShortString()}.\n     ",
    "links" : [ "#ACTION_PROVISION_MANAGED_DEVICE", "android.app.admin.DeviceAdminReceiver", "#MIME_TYPE_PROVISIONING_NFC", "android.content.ComponentName#flattenToShortString()" ]
  }, {
    "name" : "EXTRA_PROVISIONING_ACCOUNT_TO_MIGRATE",
    "type" : "String",
    "comment" : "\n     * An {@link android.accounts.Account} extra holding the account to migrate during managed\n     * profile provisioning.\n     *\n     * <p>If the account supplied is present in the user, it will be copied, along with its\n     * credentials to the managed profile and removed from the user.\n     ",
    "links" : [ "android.accounts.Account" ]
  }, {
    "name" : "EXTRA_PROVISIONING_KEEP_ACCOUNT_ON_MIGRATION",
    "type" : "String",
    "comment" : "\n     * Boolean extra to indicate that the\n     * {@link #EXTRA_PROVISIONING_ACCOUNT_TO_MIGRATE migrated account} should be kept.\n     *\n     * <p>If it's set to {@code true}, the account will not be removed from the user after it is\n     * migrated to the newly created user or profile.\n     *\n     * <p>Defaults to {@code false}\n     *\n     * @see #EXTRA_PROVISIONING_ACCOUNT_TO_MIGRATE\n     ",
    "links" : [ "#EXTRA_PROVISIONING_ACCOUNT_TO_MIGRATE" ]
  }, {
    "name" : "EXTRA_PROVISIONING_EMAIL_ADDRESS",
    "type" : "String",
    "comment" : "\n     * @deprecated From {@link android.os.Build.VERSION_CODES#O}, never used while provisioning the\n     * device.\n     ",
    "links" : [ "android.os.Build.VERSION_CODES#O" ]
  }, {
    "name" : "EXTRA_PROVISIONING_MAIN_COLOR",
    "type" : "String",
    "comment" : "\n     * A integer extra indicating the predominant color to show during the provisioning.\n     * Refer to {@link android.graphics.Color} for how the color is represented.\n     *\n     * <p>Use with {@link #ACTION_PROVISION_MANAGED_PROFILE} or\n     * {@link #ACTION_PROVISION_MANAGED_DEVICE}.\n     *\n     * @deprecated Color customization is no longer supported in the provisioning flow.\n     ",
    "links" : [ "android.graphics.Color", "#ACTION_PROVISION_MANAGED_DEVICE", "#ACTION_PROVISION_MANAGED_PROFILE" ]
  }, {
    "name" : "EXTRA_PROVISIONING_LEAVE_ALL_SYSTEM_APPS_ENABLED",
    "type" : "String",
    "comment" : "\n     * A Boolean extra that can be used by the mobile device management application to skip the\n     * disabling of system apps during provisioning when set to {@code true}.\n     *\n     * <p>Use in an NFC record with {@link #MIME_TYPE_PROVISIONING_NFC}, an intent with action\n     * {@link #ACTION_PROVISION_MANAGED_PROFILE} that starts profile owner provisioning or\n     * set as an extra to the intent result of the {@link #ACTION_GET_PROVISIONING_MODE} activity.\n     ",
    "links" : [ "#ACTION_GET_PROVISIONING_MODE", "#MIME_TYPE_PROVISIONING_NFC", "#ACTION_PROVISION_MANAGED_PROFILE" ]
  }, {
    "name" : "EXTRA_PROVISIONING_TIME_ZONE",
    "type" : "String",
    "comment" : "\n     * A String extra holding the time zone {@link android.app.AlarmManager} that the device\n     * will be set to.\n     *\n     * <p>Use only for device owner provisioning. This extra can be returned by the admin app when\n     * performing the admin-integrated provisioning flow as a result of the {@link\n     * #ACTION_GET_PROVISIONING_MODE} activity.\n     *\n     * <p>Use in an NFC record with {@link #MIME_TYPE_PROVISIONING_NFC} that starts device owner\n     * provisioning via an NFC bump. It can also be used for QR code provisioning.\n     ",
    "links" : [ "#ACTION_GET_PROVISIONING_MODE", "android.app.AlarmManager", "#MIME_TYPE_PROVISIONING_NFC" ]
  }, {
    "name" : "EXTRA_PROVISIONING_LOCAL_TIME",
    "type" : "String",
    "comment" : "\n     * A Long extra holding the wall clock time (in milliseconds) to be set on the device's\n     * {@link android.app.AlarmManager}.\n     *\n     * <p>Use only for device owner provisioning. This extra can be returned by the admin app when\n     * performing the admin-integrated provisioning flow as a result of the {@link\n     * #ACTION_GET_PROVISIONING_MODE} activity.\n     *\n     * <p>Use in an NFC record with {@link #MIME_TYPE_PROVISIONING_NFC} that starts device owner\n     * provisioning via an NFC bump. It can also be used for QR code provisioning.\n     ",
    "links" : [ "#ACTION_GET_PROVISIONING_MODE", "android.app.AlarmManager", "#MIME_TYPE_PROVISIONING_NFC" ]
  }, {
    "name" : "EXTRA_PROVISIONING_LOCALE",
    "type" : "String",
    "comment" : "\n     * A String extra holding the {@link java.util.Locale} that the device will be set to.\n     * Format: xx_yy, where xx is the language code, and yy the country code.\n     *\n     * <p>Use only for device owner provisioning. This extra can be returned by the admin app when\n     * performing the admin-integrated provisioning flow as a result of the {@link\n     * #ACTION_GET_PROVISIONING_MODE} activity.\n     *\n     * <p>Use in an NFC record with {@link #MIME_TYPE_PROVISIONING_NFC} that starts device owner\n     * provisioning via an NFC bump. It can also be used for QR code provisioning.\n     ",
    "links" : [ "#ACTION_GET_PROVISIONING_MODE", "java.util.Locale", "#MIME_TYPE_PROVISIONING_NFC" ]
  }, {
    "name" : "EXTRA_PROVISIONING_WIFI_SSID",
    "type" : "String",
    "comment" : "\n     * A String extra holding the ssid of the wifi network that should be used during nfc device\n     * owner provisioning for downloading the mobile device management application.\n     *\n     * <p>Use in an NFC record with {@link #MIME_TYPE_PROVISIONING_NFC} that starts device owner\n     * provisioning via an NFC bump. It can also be used for QR code provisioning.\n     ",
    "links" : [ "#MIME_TYPE_PROVISIONING_NFC" ]
  }, {
    "name" : "EXTRA_PROVISIONING_WIFI_HIDDEN",
    "type" : "String",
    "comment" : "\n     * A boolean extra indicating whether the wifi network in {@link #EXTRA_PROVISIONING_WIFI_SSID}\n     * is hidden or not.\n     *\n     * <p>Use in an NFC record with {@link #MIME_TYPE_PROVISIONING_NFC} that starts device owner\n     * provisioning via an NFC bump. It can also be used for QR code provisioning.\n     ",
    "links" : [ "#EXTRA_PROVISIONING_WIFI_SSID", "#MIME_TYPE_PROVISIONING_NFC" ]
  }, {
    "name" : "EXTRA_PROVISIONING_WIFI_SECURITY_TYPE",
    "type" : "String",
    "comment" : "\n     * A String extra indicating the security type of the wifi network in\n     * {@link #EXTRA_PROVISIONING_WIFI_SSID} and could be one of {@code NONE}, {@code WPA},\n     * {@code WEP} or {@code EAP}.\n     *\n     * <p>Use in an NFC record with {@link #MIME_TYPE_PROVISIONING_NFC} that starts device owner\n     * provisioning via an NFC bump. It can also be used for QR code provisioning.\n     ",
    "links" : [ "#EXTRA_PROVISIONING_WIFI_SSID", "#MIME_TYPE_PROVISIONING_NFC" ]
  }, {
    "name" : "EXTRA_PROVISIONING_WIFI_PASSWORD",
    "type" : "String",
    "comment" : "\n     * A String extra holding the password of the wifi network in\n     * {@link #EXTRA_PROVISIONING_WIFI_SSID}.\n     *\n     * <p>Use in an NFC record with {@link #MIME_TYPE_PROVISIONING_NFC} that starts device owner\n     * provisioning via an NFC bump. It can also be used for QR code provisioning.\n     ",
    "links" : [ "#EXTRA_PROVISIONING_WIFI_SSID", "#MIME_TYPE_PROVISIONING_NFC" ]
  }, {
    "name" : "EXTRA_PROVISIONING_WIFI_EAP_METHOD",
    "type" : "String",
    "comment" : "\n     * The EAP method of the wifi network in {@link #EXTRA_PROVISIONING_WIFI_SSID}\n     * and could be one of {@code PEAP}, {@code TLS}, {@code TTLS}, {@code PWD}, {@code SIM},\n     * {@code AKA} or {@code AKA_PRIME}. This is only used if the\n     * {@link #EXTRA_PROVISIONING_WIFI_SECURITY_TYPE} is {@code EAP}.\n     *\n     * <p>Use in an NFC record with {@link #MIME_TYPE_PROVISIONING_NFC} that starts device owner\n     * provisioning via an NFC bump. It can also be used for QR code provisioning.\n     ",
    "links" : [ "#EXTRA_PROVISIONING_WIFI_SSID", "#MIME_TYPE_PROVISIONING_NFC", "#EXTRA_PROVISIONING_WIFI_SECURITY_TYPE" ]
  }, {
    "name" : "EXTRA_PROVISIONING_WIFI_PHASE2_AUTH",
    "type" : "String",
    "comment" : "\n     * The phase 2 authentication of the wifi network in {@link #EXTRA_PROVISIONING_WIFI_SSID}\n     * and could be one of {@code NONE}, {@code PAP}, {@code MSCHAP}, {@code MSCHAPV2}, {@code GTC},\n     * {@code SIM}, {@code AKA} or {@code AKA_PRIME}. This is only used if the\n     * {@link #EXTRA_PROVISIONING_WIFI_SECURITY_TYPE} is {@code EAP}.\n     *\n     * <p>Use in an NFC record with {@link #MIME_TYPE_PROVISIONING_NFC} that starts device owner\n     * provisioning via an NFC bump. It can also be used for QR code provisioning.\n     ",
    "links" : [ "#EXTRA_PROVISIONING_WIFI_SSID", "#MIME_TYPE_PROVISIONING_NFC", "#EXTRA_PROVISIONING_WIFI_SECURITY_TYPE" ]
  }, {
    "name" : "EXTRA_PROVISIONING_WIFI_CA_CERTIFICATE",
    "type" : "String",
    "comment" : "\n     * The CA certificate of the wifi network in {@link #EXTRA_PROVISIONING_WIFI_SSID}. This should\n     * be an X.509 certificate Base64 encoded DER format, ie. PEM representation of a certificate\n     * without header, footer and line breaks. <a href=\n     * \"https://tools.ietf.org/html/rfc7468\"> More information</a> This is only\n     * used if the {@link\n     * #EXTRA_PROVISIONING_WIFI_SECURITY_TYPE} is {@code EAP}.\n     *\n     * <p>Use in an NFC record with {@link #MIME_TYPE_PROVISIONING_NFC} that starts device owner\n     * provisioning via an NFC bump. It can also be used for QR code provisioning.\n     ",
    "links" : [ "#EXTRA_PROVISIONING_WIFI_SSID", "#MIME_TYPE_PROVISIONING_NFC", "#EXTRA_PROVISIONING_WIFI_SECURITY_TYPE" ]
  }, {
    "name" : "EXTRA_PROVISIONING_WIFI_USER_CERTIFICATE",
    "type" : "String",
    "comment" : "\n     * The user certificate of the wifi network in {@link #EXTRA_PROVISIONING_WIFI_SSID}. This\n     * should be an X.509 certificate and private key Base64 encoded DER format, ie. PEM\n     * representation of a certificate and key without header, footer and line breaks. <a href=\n     * \"https://tools.ietf.org/html/rfc7468\"> More information</a> This is only\n     * used if the {@link #EXTRA_PROVISIONING_WIFI_SECURITY_TYPE} is {@code EAP}.\n     *\n     * <p>Use in an NFC record with {@link #MIME_TYPE_PROVISIONING_NFC} that starts device owner\n     * provisioning via an NFC bump. It can also be used for QR code provisioning.\n     ",
    "links" : [ "#EXTRA_PROVISIONING_WIFI_SSID", "#MIME_TYPE_PROVISIONING_NFC", "#EXTRA_PROVISIONING_WIFI_SECURITY_TYPE" ]
  }, {
    "name" : "EXTRA_PROVISIONING_WIFI_IDENTITY",
    "type" : "String",
    "comment" : "\n     * The identity of the wifi network in {@link #EXTRA_PROVISIONING_WIFI_SSID}. This is only used\n     * if the {@link #EXTRA_PROVISIONING_WIFI_SECURITY_TYPE} is {@code EAP}.\n     *\n     * <p>Use in an NFC record with {@link #MIME_TYPE_PROVISIONING_NFC} that starts device owner\n     * provisioning via an NFC bump. It can also be used for QR code provisioning.\n     ",
    "links" : [ "#EXTRA_PROVISIONING_WIFI_SSID", "#MIME_TYPE_PROVISIONING_NFC", "#EXTRA_PROVISIONING_WIFI_SECURITY_TYPE" ]
  }, {
    "name" : "EXTRA_PROVISIONING_WIFI_ANONYMOUS_IDENTITY",
    "type" : "String",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "EXTRA_PROVISIONING_WIFI_DOMAIN",
    "type" : "String",
    "comment" : "\n     * The domain of the wifi network in {@link #EXTRA_PROVISIONING_WIFI_SSID}. This is only used if\n     * the {@link #EXTRA_PROVISIONING_WIFI_SECURITY_TYPE} is {@code EAP}.\n     *\n     * <p>Use in an NFC record with {@link #MIME_TYPE_PROVISIONING_NFC} that starts device owner\n     * provisioning via an NFC bump. It can also be used for QR code provisioning.\n     ",
    "links" : [ "#EXTRA_PROVISIONING_WIFI_SSID", "#MIME_TYPE_PROVISIONING_NFC", "#EXTRA_PROVISIONING_WIFI_SECURITY_TYPE" ]
  }, {
    "name" : "EXTRA_PROVISIONING_WIFI_PROXY_HOST",
    "type" : "String",
    "comment" : "\n     * A String extra holding the proxy host for the wifi network in\n     * {@link #EXTRA_PROVISIONING_WIFI_SSID}.\n     *\n     * <p>Use in an NFC record with {@link #MIME_TYPE_PROVISIONING_NFC} that starts device owner\n     * provisioning via an NFC bump. It can also be used for QR code provisioning.\n     ",
    "links" : [ "#EXTRA_PROVISIONING_WIFI_SSID", "#MIME_TYPE_PROVISIONING_NFC" ]
  }, {
    "name" : "EXTRA_PROVISIONING_WIFI_PROXY_PORT",
    "type" : "String",
    "comment" : "\n     * An int extra holding the proxy port for the wifi network in\n     * {@link #EXTRA_PROVISIONING_WIFI_SSID}.\n     *\n     * <p>Use in an NFC record with {@link #MIME_TYPE_PROVISIONING_NFC} that starts device owner\n     * provisioning via an NFC bump. It can also be used for QR code provisioning.\n     ",
    "links" : [ "#EXTRA_PROVISIONING_WIFI_SSID", "#MIME_TYPE_PROVISIONING_NFC" ]
  }, {
    "name" : "EXTRA_PROVISIONING_WIFI_PROXY_BYPASS",
    "type" : "String",
    "comment" : "\n     * A String extra holding the proxy bypass for the wifi network in\n     * {@link #EXTRA_PROVISIONING_WIFI_SSID}.\n     *\n     * <p>Use in an NFC record with {@link #MIME_TYPE_PROVISIONING_NFC} that starts device owner\n     * provisioning via an NFC bump. It can also be used for QR code provisioning.\n     ",
    "links" : [ "#EXTRA_PROVISIONING_WIFI_SSID", "#MIME_TYPE_PROVISIONING_NFC" ]
  }, {
    "name" : "EXTRA_PROVISIONING_WIFI_PAC_URL",
    "type" : "String",
    "comment" : "\n     * A String extra holding the proxy auto-config (PAC) URL for the wifi network in\n     * {@link #EXTRA_PROVISIONING_WIFI_SSID}.\n     *\n     * <p>Use in an NFC record with {@link #MIME_TYPE_PROVISIONING_NFC} that starts device owner\n     * provisioning via an NFC bump. It can also be used for QR code provisioning.\n     ",
    "links" : [ "#EXTRA_PROVISIONING_WIFI_SSID", "#MIME_TYPE_PROVISIONING_NFC" ]
  }, {
    "name" : "EXTRA_PROVISIONING_DEVICE_ADMIN_PACKAGE_DOWNLOAD_LOCATION",
    "type" : "String",
    "comment" : "\n     * A String extra holding a url that specifies the download location of the device admin\n     * package. When not provided it is assumed that the device admin package is already installed.\n     *\n     * <p>Use in an NFC record with {@link #MIME_TYPE_PROVISIONING_NFC} that starts device owner\n     * provisioning via an NFC bump. It can also be used for QR code provisioning.\n     ",
    "links" : [ "#MIME_TYPE_PROVISIONING_NFC" ]
  }, {
    "name" : "EXTRA_PROVISIONING_ORGANIZATION_NAME",
    "type" : "String",
    "comment" : "\n     * A String extra holding the localized name of the organization under management.\n     *\n     * The name is displayed only during provisioning.\n     *\n     * <p>Use in an intent with action {@link #ACTION_PROVISION_FINANCED_DEVICE}\n     *\n     * @hide\n     ",
    "links" : [ "#ACTION_PROVISION_FINANCED_DEVICE" ]
  }, {
    "name" : "EXTRA_PROVISIONING_SUPPORT_URL",
    "type" : "String",
    "comment" : "\n     * A String extra holding a url to the website of the device provider so the user can open it\n     * during provisioning. If the url is not HTTPS, an error will be shown.\n     *\n     * <p>Use in an intent with action {@link #ACTION_PROVISION_MANAGED_DEVICE_FROM_TRUSTED_SOURCE}\n     * or {@link #ACTION_PROVISION_FINANCED_DEVICE}\n     *\n     * @hide\n     ",
    "links" : [ "#ACTION_PROVISION_FINANCED_DEVICE", "#ACTION_PROVISION_MANAGED_DEVICE_FROM_TRUSTED_SOURCE" ]
  }, {
    "name" : "EXTRA_PROVISIONING_DEVICE_ADMIN_PACKAGE_LABEL",
    "type" : "String",
    "comment" : "\n     * A String extra holding the localized name of the device admin package. It should be the same\n     * as the app label of the package.\n     *\n     * <p>Use in an intent with action {@link #ACTION_PROVISION_MANAGED_DEVICE_FROM_TRUSTED_SOURCE}\n     * or {@link #ACTION_PROVISION_FINANCED_DEVICE}\n     *\n     * @deprecated This extra is no longer respected in the provisioning flow.\n     * @hide\n     ",
    "links" : [ "#ACTION_PROVISION_FINANCED_DEVICE", "#ACTION_PROVISION_MANAGED_DEVICE_FROM_TRUSTED_SOURCE" ]
  }, {
    "name" : "EXTRA_PROVISIONING_DEVICE_ADMIN_PACKAGE_ICON_URI",
    "type" : "String",
    "comment" : "\n     * A {@link Uri} extra pointing to the app icon of device admin package. This image will be\n     * shown during the provisioning.\n     * <h5>The following URI schemes are accepted:</h5>\n     * <ul>\n     * <li>content ({@link android.content.ContentResolver#SCHEME_CONTENT})</li>\n     * <li>android.resource ({@link android.content.ContentResolver#SCHEME_ANDROID_RESOURCE})</li>\n     * </ul>\n     *\n     * <p> It is the responsibility of the caller to provide an image with a reasonable\n     * pixel density for the device.\n     *\n     * <p> If a content: URI is passed, the intent should have the flag\n     * {@link Intent#FLAG_GRANT_READ_URI_PERMISSION} and the uri should be added to the\n     * {@link android.content.ClipData} of the intent too.\n     *\n     * <p>Use in an intent with action {@link #ACTION_PROVISION_MANAGED_DEVICE_FROM_TRUSTED_SOURCE}\n     * or {@link #ACTION_PROVISION_FINANCED_DEVICE}\n     *\n     * @deprecated This extra is no longer respected in the provisioning flow.\n     * @hide\n     ",
    "links" : [ "android.content.ClipData", "#ACTION_PROVISION_FINANCED_DEVICE", "android.content.ContentResolver#SCHEME_CONTENT", "android.net.Uri", "#ACTION_PROVISION_MANAGED_DEVICE_FROM_TRUSTED_SOURCE", "android.content.Intent#FLAG_GRANT_READ_URI_PERMISSION", "android.content.ContentResolver#SCHEME_ANDROID_RESOURCE" ]
  }, {
    "name" : "EXTRA_PROVISIONING_DEVICE_ADMIN_MINIMUM_VERSION_CODE",
    "type" : "String",
    "comment" : "\n     * An int extra holding a minimum required version code for the device admin package. If the\n     * device admin is already installed on the device, it will only be re-downloaded from\n     * {@link #EXTRA_PROVISIONING_DEVICE_ADMIN_PACKAGE_DOWNLOAD_LOCATION} if the version of the\n     * installed package is less than this version code.\n     *\n     * <p>Use in an NFC record with {@link #MIME_TYPE_PROVISIONING_NFC} that starts device owner\n     * provisioning via an NFC bump. It can also be used for QR code provisioning.\n     ",
    "links" : [ "#MIME_TYPE_PROVISIONING_NFC", "#EXTRA_PROVISIONING_DEVICE_ADMIN_PACKAGE_DOWNLOAD_LOCATION" ]
  }, {
    "name" : "EXTRA_PROVISIONING_DEVICE_ADMIN_PACKAGE_DOWNLOAD_COOKIE_HEADER",
    "type" : "String",
    "comment" : "\n     * A String extra holding a http cookie header which should be used in the http request to the\n     * url specified in {@link #EXTRA_PROVISIONING_DEVICE_ADMIN_PACKAGE_DOWNLOAD_LOCATION}.\n     *\n     * <p>Use in an NFC record with {@link #MIME_TYPE_PROVISIONING_NFC} that starts device owner\n     * provisioning via an NFC bump. It can also be used for QR code provisioning.\n     ",
    "links" : [ "#MIME_TYPE_PROVISIONING_NFC", "#EXTRA_PROVISIONING_DEVICE_ADMIN_PACKAGE_DOWNLOAD_LOCATION" ]
  }, {
    "name" : "EXTRA_PROVISIONING_DEVICE_ADMIN_PACKAGE_CHECKSUM",
    "type" : "String",
    "comment" : "\n     * A String extra holding the URL-safe base64 encoded SHA-256 hash of the file at download\n     * location specified in {@link #EXTRA_PROVISIONING_DEVICE_ADMIN_PACKAGE_DOWNLOAD_LOCATION}.\n     *\n     * <p>Either this extra or {@link #EXTRA_PROVISIONING_DEVICE_ADMIN_SIGNATURE_CHECKSUM} must be\n     * present. The provided checksum must match the checksum of the file at the download\n     * location. If the checksum doesn't match an error will be shown to the user and the user will\n     * be asked to factory reset the device.\n     *\n     * <p>Use in an NFC record with {@link #MIME_TYPE_PROVISIONING_NFC} that starts device owner\n     * provisioning via an NFC bump. It can also be used for QR code provisioning.\n     *\n     * <p><strong>Note:</strong> for devices running {@link android.os.Build.VERSION_CODES#LOLLIPOP}\n     * and {@link android.os.Build.VERSION_CODES#LOLLIPOP_MR1} only SHA-1 hash is supported.\n     * Starting from {@link android.os.Build.VERSION_CODES#M}, this parameter accepts SHA-256 in\n     * addition to SHA-1. From {@link android.os.Build.VERSION_CODES#Q}, only SHA-256 hash is\n     * supported.\n     ",
    "links" : [ "#EXTRA_PROVISIONING_DEVICE_ADMIN_SIGNATURE_CHECKSUM", "android.os.Build.VERSION_CODES#LOLLIPOP", "android.os.Build.VERSION_CODES#Q", "android.os.Build.VERSION_CODES#LOLLIPOP_MR1", "#MIME_TYPE_PROVISIONING_NFC", "#EXTRA_PROVISIONING_DEVICE_ADMIN_PACKAGE_DOWNLOAD_LOCATION", "android.os.Build.VERSION_CODES#M" ]
  }, {
    "name" : "EXTRA_PROVISIONING_SENSORS_PERMISSION_GRANT_OPT_OUT",
    "type" : "String",
    "comment" : "\n     * A boolean extra indicating the admin of a fully-managed device opts out of controlling\n     * permission grants for sensor-related permissions,\n     * see {@link #setPermissionGrantState(ComponentName, String, String, int)}.\n     *\n     * The default for this extra is {@code false} - by default, the admin of a fully-managed\n     * device has the ability to grant sensors-related permissions.\n     *\n     * <p>Use only for device owner provisioning. This extra can be returned by the\n     * admin app when performing the admin-integrated provisioning flow as a result of the\n     * {@link #ACTION_GET_PROVISIONING_MODE} activity.\n     *\n     * <p>This extra may also be provided to the admin app via an intent extra for {@link\n     * #ACTION_GET_PROVISIONING_MODE}.\n     *\n     * @see #ACTION_GET_PROVISIONING_MODE\n     ",
    "links" : [ "#ACTION_GET_PROVISIONING_MODE", "#setPermissionGrantState(ComponentName" ]
  }, {
    "name" : "EXTRA_PROVISIONING_DEVICE_ADMIN_SIGNATURE_CHECKSUM",
    "type" : "String",
    "comment" : "\n     * A String extra holding the URL-safe base64 encoded SHA-256 checksum of any signature of the\n     * android package archive at the download location specified in {@link\n     * #EXTRA_PROVISIONING_DEVICE_ADMIN_PACKAGE_DOWNLOAD_LOCATION}.\n     *\n     * <p>The signatures of an android package archive can be obtained using\n     * {@link android.content.pm.PackageManager#getPackageArchiveInfo} with flag\n     * {@link android.content.pm.PackageManager#GET_SIGNATURES}.\n     *\n     * <p>Either this extra or {@link #EXTRA_PROVISIONING_DEVICE_ADMIN_PACKAGE_CHECKSUM} must be\n     * present. The provided checksum must match the checksum of any signature of the file at\n     * the download location. If the checksum does not match an error will be shown to the user and\n     * the user will be asked to factory reset the device.\n     *\n     * <p>Use in an NFC record with {@link #MIME_TYPE_PROVISIONING_NFC} that starts device owner\n     * provisioning via an NFC bump. It can also be used for QR code provisioning.\n     ",
    "links" : [ "android.content.pm.PackageManager#getPackageArchiveInfo", "android.content.pm.PackageManager#GET_SIGNATURES", "#EXTRA_PROVISIONING_DEVICE_ADMIN_PACKAGE_CHECKSUM", "#MIME_TYPE_PROVISIONING_NFC", "#EXTRA_PROVISIONING_DEVICE_ADMIN_PACKAGE_DOWNLOAD_LOCATION" ]
  }, {
    "name" : "ACTION_MANAGED_PROFILE_PROVISIONED",
    "type" : "String",
    "comment" : "\n     * Broadcast Action: This broadcast is sent to indicate that provisioning of a managed profile\n     * has completed successfully.\n     *\n     * <p>The broadcast is limited to the primary profile, to the app specified in the provisioning\n     * intent with action {@link #ACTION_PROVISION_MANAGED_PROFILE}.\n     *\n     * <p>This intent will contain the following extras\n     * <ul>\n     * <li>{@link Intent#EXTRA_USER}, corresponds to the {@link UserHandle} of the managed\n     * profile.</li>\n     * <li>{@link #EXTRA_PROVISIONING_ACCOUNT_TO_MIGRATE}, corresponds to the account requested to\n     * be migrated at provisioning time, if any.</li>\n     * </ul>\n     ",
    "links" : [ "#EXTRA_PROVISIONING_ACCOUNT_TO_MIGRATE", "android.os.UserHandle", "#ACTION_PROVISION_MANAGED_PROFILE", "android.content.Intent#EXTRA_USER" ]
  }, {
    "name" : "ACTION_PROVISIONING_SUCCESSFUL",
    "type" : "String",
    "comment" : "\n     * Activity action: This activity action is sent to indicate that provisioning of a managed\n     * profile or managed device has completed successfully. It'll be sent at the same time as\n     * {@link DeviceAdminReceiver#ACTION_PROFILE_PROVISIONING_COMPLETE} broadcast but this will be\n     * delivered faster as it's an activity intent.\n     *\n     * <p>The intent is only sent to the new device or profile owner.\n     *\n     * @see #ACTION_PROVISION_MANAGED_PROFILE\n     * @see #ACTION_PROVISION_MANAGED_DEVICE\n     ",
    "links" : [ "android.app.admin.DeviceAdminReceiver#ACTION_PROFILE_PROVISIONING_COMPLETE" ]
  }, {
    "name" : "EXTRA_PROVISIONING_SKIP_ENCRYPTION",
    "type" : "String",
    "comment" : "\n     * A boolean extra indicating whether device encryption can be skipped as part of\n     * <a href=\"#managed-provisioning>provisioning</a>.\n     *\n     * <p>Use in an NFC record with {@link #MIME_TYPE_PROVISIONING_NFC} or an intent with action\n     * {@link #ACTION_PROVISION_MANAGED_DEVICE} that starts device owner provisioning.\n     *\n     * <p>From {@link android.os.Build.VERSION_CODES#N} onwards, this is also supported for an\n     * intent with action {@link #ACTION_PROVISION_MANAGED_PROFILE}.\n     ",
    "links" : [ "#ACTION_PROVISION_MANAGED_DEVICE", "#MIME_TYPE_PROVISIONING_NFC", "#ACTION_PROVISION_MANAGED_PROFILE", "android.os.Build.VERSION_CODES#N" ]
  }, {
    "name" : "EXTRA_PROVISIONING_LOGO_URI",
    "type" : "String",
    "comment" : "\n     * A {@link Uri} extra pointing to a logo image. This image will be shown during the\n     * provisioning. If this extra is not passed, a default image will be shown.\n     *\n     * <p><b>The following URI schemes are accepted:</b>\n     * <ul>\n     * <li>content ({@link android.content.ContentResolver#SCHEME_CONTENT})</li>\n     * <li>android.resource ({@link android.content.ContentResolver#SCHEME_ANDROID_RESOURCE})</li>\n     * </ul>\n     *\n     * <p>It is the responsibility of the caller to provide an image with a reasonable\n     * pixel density for the device.\n     *\n     * <p>If a content: URI is passed, the intent should also have the flag\n     * {@link Intent#FLAG_GRANT_READ_URI_PERMISSION} and the uri should be added to the\n     * {@link android.content.ClipData} of the intent.\n     *\n     * @deprecated Logo customization is no longer supported in the\n     *             <a href=\"#managedprovisioning\">provisioning flow</a>.\n     ",
    "links" : [ "android.content.ClipData", "android.content.ContentResolver#SCHEME_CONTENT", "android.net.Uri", "android.content.Intent#FLAG_GRANT_READ_URI_PERMISSION", "android.content.ContentResolver#SCHEME_ANDROID_RESOURCE" ]
  }, {
    "name" : "EXTRA_PROVISIONING_DISCLAIMERS",
    "type" : "String",
    "comment" : "\n     * A {@link Bundle}[] extra consisting of list of disclaimer headers and disclaimer contents.\n     *\n     * <p>Each {@link Bundle} must have both {@link #EXTRA_PROVISIONING_DISCLAIMER_HEADER}\n     * as disclaimer header, and {@link #EXTRA_PROVISIONING_DISCLAIMER_CONTENT} as disclaimer\n     * content.\n     *\n     * <p> The extra typically contains one disclaimer from the company of mobile device\n     * management application (MDM), and one disclaimer from the organization.\n     *\n     * <p> Call {@link Bundle#putParcelableArray(String, Parcelable[])} to put the {@link Bundle}[]\n     *\n     * <p> Maximum 3 key-value pairs can be specified. The rest will be ignored.\n     *\n     * <p> Can be used in an intent with action {@link #ACTION_PROVISION_MANAGED_PROFILE}. This\n     * extra can also be returned by the admin app when performing the admin-integrated\n     * provisioning flow as a result of the {@link #ACTION_GET_PROVISIONING_MODE} activity.\n     ",
    "links" : [ "#EXTRA_PROVISIONING_DISCLAIMER_CONTENT", "android.os.Bundle", "#EXTRA_PROVISIONING_DISCLAIMER_HEADER", "#ACTION_GET_PROVISIONING_MODE", "#ACTION_PROVISION_MANAGED_PROFILE", "android.os.Bundle#putParcelableArray(String" ]
  }, {
    "name" : "EXTRA_PROVISIONING_DISCLAIMER_HEADER",
    "type" : "String",
    "comment" : "\n     * A String extra of localized disclaimer header.\n     *\n     * <p>The extra is typically the company name of mobile device management application (MDM)\n     * or the organization name.\n     *\n     * <p>{@link ApplicationInfo#FLAG_SYSTEM System apps} can also insert a disclaimer by declaring\n     * an application-level meta-data in {@code AndroidManifest.xml}.\n     *\n     * <p>For example:\n     * <pre>\n     *  &lt;meta-data\n     *      android:name=\"android.app.extra.PROVISIONING_DISCLAIMER_HEADER\"\n     *      android:resource=\"@string/disclaimer_header\"\n     * /&gt;</pre>\n     *\n     * <p>This must be accompanied with another extra using the key\n     * {@link #EXTRA_PROVISIONING_DISCLAIMER_CONTENT}.\n     ",
    "links" : [ "android.content.pm.ApplicationInfo#FLAG_SYSTEM", "#EXTRA_PROVISIONING_DISCLAIMER_CONTENT" ]
  }, {
    "name" : "EXTRA_PROVISIONING_DISCLAIMER_CONTENT",
    "type" : "String",
    "comment" : "\n     * A {@link Uri} extra pointing to disclaimer content.\n     *\n     * <h5>The following URI schemes are accepted:</h5>\n     * <ul>\n     * <li>content ({@link android.content.ContentResolver#SCHEME_CONTENT})</li>\n     * <li>android.resource ({@link android.content.ContentResolver#SCHEME_ANDROID_RESOURCE})</li>\n     * </ul>\n     *\n     * <p>Styled text is supported. This is parsed by {@link android.text.Html#fromHtml(String)}\n     * and displayed in a {@link android.widget.TextView}.\n     *\n     * <p>If a <code>content:</code> URI is passed, the intent should also have the\n     * flag {@link Intent#FLAG_GRANT_READ_URI_PERMISSION} and the uri should be added to the\n     * {@link android.content.ClipData} of the intent.\n     *\n     * <p>{@link ApplicationInfo#FLAG_SYSTEM System apps} can also insert a\n     * disclaimer by declaring an application-level meta-data in {@code AndroidManifest.xml}.\n     *\n     * <p>For example:\n     *\n     * <pre>\n     *  &lt;meta-data\n     *      android:name=\"android.app.extra.PROVISIONING_DISCLAIMER_CONTENT\"\n     *      android:resource=\"@string/disclaimer_content\"\n     * /&gt;</pre>\n     *\n     * <p>This must be accompanied with another extra using the key\n     * {@link #EXTRA_PROVISIONING_DISCLAIMER_HEADER}.\n     ",
    "links" : [ "android.content.ClipData", "android.content.pm.ApplicationInfo#FLAG_SYSTEM", "android.text.Html#fromHtml(String)", "android.widget.TextView", "#EXTRA_PROVISIONING_DISCLAIMER_HEADER", "android.content.ContentResolver#SCHEME_CONTENT", "android.net.Uri", "android.content.Intent#FLAG_GRANT_READ_URI_PERMISSION", "android.content.ContentResolver#SCHEME_ANDROID_RESOURCE" ]
  }, {
    "name" : "EXTRA_PROVISIONING_SKIP_USER_CONSENT",
    "type" : "String",
    "comment" : "\n     * A boolean extra indicating if the user consent steps from the\n     * <a href=\"#managed-provisioning\">provisioning flow</a> should be skipped.\n     *\n     * <p>If unspecified, defaults to {@code false}.\n     *\n     * @deprecated this extra is no longer relevant as device owners cannot create managed profiles\n     ",
    "links" : [ ]
  }, {
    "name" : "EXTRA_PROVISIONING_SKIP_EDUCATION_SCREENS",
    "type" : "String",
    "comment" : "\n     * A boolean extra indicating if the education screens from the provisioning flow should be\n     * skipped. If unspecified, defaults to {@code false}.\n     *\n     * <p>This extra can be set in the following ways:\n     * <ul>\n     * <li>By the admin app when performing the admin-integrated\n     * provisioning flow as a result of the {@link #ACTION_GET_PROVISIONING_MODE} activity</li>\n     * <li>For managed account enrollment</li>\n     * </ul>\n     *\n     * <p>If the education screens are skipped, it is the admin application's responsibility\n     * to display its own user education screens.\n     ",
    "links" : [ "#ACTION_GET_PROVISIONING_MODE" ]
  }, {
    "name" : "EXTRA_PROVISIONING_USE_MOBILE_DATA",
    "type" : "String",
    "comment" : "\n     * A boolean extra indicating if mobile data should be used during the provisioning flow\n     * for downloading the admin app. If {@link #EXTRA_PROVISIONING_WIFI_SSID} is also specified,\n     * wifi network will be used instead.\n     *\n     * <p>Default value is {@code false}.\n     *\n     * <p>If this extra is set to {@code true} and {@link #EXTRA_PROVISIONING_WIFI_SSID} is not\n     * specified, this extra has different behaviour depending on the way provisioning is triggered:\n     * <ul>\n     * <li>\n     *     For provisioning started via a QR code or an NFC tag, mobile data is always used for\n     *     downloading the admin app.\n     * </li>\n     * <li>\n     *     For all other provisioning methods, a mobile data connection check is made at the start\n     *     of provisioning. If mobile data is connected at that point, the admin app download will\n     *     happen using mobile data. If mobile data is not connected at that point, the end-user\n     *     will be asked to pick a wifi network and the admin app download will proceed over wifi.\n     * </li>\n     * </ul>\n     ",
    "links" : [ "#EXTRA_PROVISIONING_WIFI_SSID" ]
  }, {
    "name" : "EXTRA_PROVISIONING_TRIGGER",
    "type" : "String",
    "comment" : "\n     * An int extra holding the provisioning trigger. It could be one of\n     * {@link #PROVISIONING_TRIGGER_CLOUD_ENROLLMENT}, {@link #PROVISIONING_TRIGGER_QR_CODE},\n     * {@link #PROVISIONING_TRIGGER_MANAGED_ACCOUNT} or {@link\n     * #PROVISIONING_TRIGGER_UNSPECIFIED}.\n     *\n     * <p>Use in an intent with action {@link\n     * #ACTION_PROVISION_MANAGED_DEVICE_FROM_TRUSTED_SOURCE}.\n     * @hide\n     ",
    "links" : [ "#PROVISIONING_TRIGGER_UNSPECIFIED", "#PROVISIONING_TRIGGER_CLOUD_ENROLLMENT", "#PROVISIONING_TRIGGER_QR_CODE", "#ACTION_PROVISION_MANAGED_DEVICE_FROM_TRUSTED_SOURCE", "#PROVISIONING_TRIGGER_MANAGED_ACCOUNT" ]
  }, {
    "name" : "PROVISIONING_TRIGGER_UNSPECIFIED",
    "type" : "int",
    "comment" : "\n     * A value for {@link #EXTRA_PROVISIONING_TRIGGER} indicating that the provisioning\n     * trigger has not been specified.\n     * @see #PROVISIONING_TRIGGER_CLOUD_ENROLLMENT\n     * @see #PROVISIONING_TRIGGER_QR_CODE\n     * @see #PROVISIONING_TRIGGER_MANAGED_ACCOUNT\n     * @see #PROVISIONING_TRIGGER_NFC\n     * @hide\n     ",
    "links" : [ "#EXTRA_PROVISIONING_TRIGGER" ]
  }, {
    "name" : "PROVISIONING_TRIGGER_CLOUD_ENROLLMENT",
    "type" : "int",
    "comment" : "\n     * A value for {@link #EXTRA_PROVISIONING_TRIGGER} indicating that the provisioning\n     * trigger is cloud enrollment.\n     * @see #PROVISIONING_TRIGGER_QR_CODE\n     * @see #PROVISIONING_TRIGGER_MANAGED_ACCOUNT\n     * @see #PROVISIONING_TRIGGER_UNSPECIFIED\n     * @see #PROVISIONING_TRIGGER_NFC\n     * @hide\n     ",
    "links" : [ "#EXTRA_PROVISIONING_TRIGGER" ]
  }, {
    "name" : "PROVISIONING_TRIGGER_QR_CODE",
    "type" : "int",
    "comment" : "\n     * A value for {@link #EXTRA_PROVISIONING_TRIGGER} indicating that the provisioning\n     * trigger is the QR code scanner.\n     * @see #PROVISIONING_TRIGGER_CLOUD_ENROLLMENT\n     * @see #PROVISIONING_TRIGGER_MANAGED_ACCOUNT\n     * @see #PROVISIONING_TRIGGER_UNSPECIFIED\n     * @see #PROVISIONING_TRIGGER_NFC\n     * @hide\n     ",
    "links" : [ "#EXTRA_PROVISIONING_TRIGGER" ]
  }, {
    "name" : "PROVISIONING_TRIGGER_PERSISTENT_DEVICE_OWNER",
    "type" : "int",
    "comment" : "\n     * A value for {@link #EXTRA_PROVISIONING_TRIGGER} indicating that the provisioning\n     * trigger is persistent device owner enrollment.\n     * <p>This constant is meant to represent a specific type of managed account provisioning which\n     * provisions a device to a device owner by invoking the standard provisioning flow (where\n     * the ManagedProvisioning component downloads and installs the admin app), as opposed to\n     * relying on the provisioning trigger to handle download and install of the admin app.\n     * <p>As of {@link android.os.Build.VERSION_CODES#S}, this constant is no longer used in favor\n     * of the more general {@link #PROVISIONING_TRIGGER_MANAGED_ACCOUNT} which handles all managed\n     * account provisioning types.\n     * @deprecated Use the broader {@link #PROVISIONING_TRIGGER_MANAGED_ACCOUNT} instead\n     * @see #PROVISIONING_TRIGGER_CLOUD_ENROLLMENT\n     * @see #PROVISIONING_TRIGGER_QR_CODE\n     * @see #PROVISIONING_TRIGGER_UNSPECIFIED\n     * @see #PROVISIONING_TRIGGER_NFC\n     * @hide\n     ",
    "links" : [ "android.os.Build.VERSION_CODES#S", "#PROVISIONING_TRIGGER_MANAGED_ACCOUNT", "#EXTRA_PROVISIONING_TRIGGER" ]
  }, {
    "name" : "PROVISIONING_TRIGGER_MANAGED_ACCOUNT",
    "type" : "int",
    "comment" : "\n     * A value for {@link #EXTRA_PROVISIONING_TRIGGER} indicating that the provisioning\n     * trigger is managed account enrollment.\n     * <p>\n     * @see #PROVISIONING_TRIGGER_CLOUD_ENROLLMENT\n     * @see #PROVISIONING_TRIGGER_QR_CODE\n     * @see #PROVISIONING_TRIGGER_UNSPECIFIED\n     * @see #PROVISIONING_TRIGGER_NFC\n     * @hide\n     ",
    "links" : [ "#EXTRA_PROVISIONING_TRIGGER" ]
  }, {
    "name" : "PROVISIONING_TRIGGER_NFC",
    "type" : "int",
    "comment" : "\n     * A value for {@link #EXTRA_PROVISIONING_TRIGGER} indicating that the provisioning is\n     * triggered by tapping an NFC tag.\n     * @see #PROVISIONING_TRIGGER_CLOUD_ENROLLMENT\n     * @see #PROVISIONING_TRIGGER_QR_CODE\n     * @see #PROVISIONING_TRIGGER_UNSPECIFIED\n     * @see #PROVISIONING_TRIGGER_MANAGED_ACCOUNT\n     * @hide\n     ",
    "links" : [ "#EXTRA_PROVISIONING_TRIGGER" ]
  }, {
    "name" : "FLAG_SUPPORTED_MODES_ORGANIZATION_OWNED",
    "type" : "int",
    "comment" : "\n     * Flag for {@link #EXTRA_PROVISIONING_SUPPORTED_MODES} indicating that provisioning is\n     * organization-owned.\n     *\n     * <p>Using this value indicates the admin app can only be provisioned in either a\n     * fully-managed device or a corporate-owned work profile. This will cause the admin app's\n     * {@link #ACTION_GET_PROVISIONING_MODE} activity to have the {@link\n     * #EXTRA_PROVISIONING_ALLOWED_PROVISIONING_MODES} array extra contain {@link\n     * #PROVISIONING_MODE_MANAGED_PROFILE} and {@link #PROVISIONING_MODE_FULLY_MANAGED_DEVICE}.\n     *\n     * <p>This flag can be combined with {@link #FLAG_SUPPORTED_MODES_PERSONALLY_OWNED}. In\n     * that case, the admin app's {@link #ACTION_GET_PROVISIONING_MODE} activity will have\n     * the {@link #EXTRA_PROVISIONING_ALLOWED_PROVISIONING_MODES} array extra contain {@link\n     * #PROVISIONING_MODE_MANAGED_PROFILE}, {@link #PROVISIONING_MODE_FULLY_MANAGED_DEVICE} and\n     * {@link #PROVISIONING_MODE_MANAGED_PROFILE_ON_PERSONAL_DEVICE}.\n     *\n     * @hide\n     ",
    "links" : [ "#PROVISIONING_MODE_MANAGED_PROFILE", "#ACTION_GET_PROVISIONING_MODE", "#PROVISIONING_MODE_MANAGED_PROFILE_ON_PERSONAL_DEVICE", "#EXTRA_PROVISIONING_ALLOWED_PROVISIONING_MODES", "#PROVISIONING_MODE_FULLY_MANAGED_DEVICE", "#EXTRA_PROVISIONING_SUPPORTED_MODES", "#FLAG_SUPPORTED_MODES_PERSONALLY_OWNED" ]
  }, {
    "name" : "FLAG_SUPPORTED_MODES_PERSONALLY_OWNED",
    "type" : "int",
    "comment" : "\n     * Flag for {@link #EXTRA_PROVISIONING_SUPPORTED_MODES} indicating that provisioning\n     * is personally-owned.\n     *\n     * <p>Using this flag will cause the admin app's {@link #ACTION_GET_PROVISIONING_MODE}\n     * activity to have the {@link #EXTRA_PROVISIONING_ALLOWED_PROVISIONING_MODES} array extra\n     * contain only {@link #PROVISIONING_MODE_MANAGED_PROFILE}.\n     *\n     * <p>Also, if this flag is set, the admin app's {@link #ACTION_GET_PROVISIONING_MODE} activity\n     * will not receive the {@link #EXTRA_PROVISIONING_IMEI} and {@link\n     * #EXTRA_PROVISIONING_SERIAL_NUMBER} extras.\n     *\n     * <p>This flag can be combined with {@link #FLAG_SUPPORTED_MODES_ORGANIZATION_OWNED}. In\n     * that case, the admin app's {@link #ACTION_GET_PROVISIONING_MODE} activity will have the\n     * {@link #EXTRA_PROVISIONING_ALLOWED_PROVISIONING_MODES} array extra contain {@link\n     * #PROVISIONING_MODE_MANAGED_PROFILE}, {@link #PROVISIONING_MODE_FULLY_MANAGED_DEVICE} and\n     * {@link #PROVISIONING_MODE_MANAGED_PROFILE_ON_PERSONAL_DEVICE}.\n     *\n     * @hide\n     ",
    "links" : [ "#PROVISIONING_MODE_MANAGED_PROFILE", "#ACTION_GET_PROVISIONING_MODE", "#PROVISIONING_MODE_MANAGED_PROFILE_ON_PERSONAL_DEVICE", "#EXTRA_PROVISIONING_ALLOWED_PROVISIONING_MODES", "#PROVISIONING_MODE_FULLY_MANAGED_DEVICE", "#EXTRA_PROVISIONING_IMEI", "#EXTRA_PROVISIONING_SUPPORTED_MODES", "#FLAG_SUPPORTED_MODES_ORGANIZATION_OWNED", "#EXTRA_PROVISIONING_SERIAL_NUMBER" ]
  }, {
    "name" : "FLAG_SUPPORTED_MODES_DEVICE_OWNER",
    "type" : "int",
    "comment" : "\n     * Flag for {@link #EXTRA_PROVISIONING_SUPPORTED_MODES} indicating that the only\n     * supported provisioning mode is device owner.\n     *\n     * @hide\n     ",
    "links" : [ "#EXTRA_PROVISIONING_SUPPORTED_MODES" ]
  }, {
    "name" : "WIFI_SECURITY_OPEN",
    "type" : "int",
    "comment" : "\n     * Constant for {@link #getMinimumRequiredWifiSecurityLevel()} and\n     * {@link #setMinimumRequiredWifiSecurityLevel(int)}: no minimum security level.\n     *\n     * <p> When returned from {@link #getMinimumRequiredWifiSecurityLevel()}, the constant\n     * represents the current minimum security level required.\n     * When passed to {@link #setMinimumRequiredWifiSecurityLevel(int)}, it sets the\n     * minimum security level a Wi-Fi network must meet.\n     *\n     * @see #WIFI_SECURITY_PERSONAL\n     * @see #WIFI_SECURITY_ENTERPRISE_EAP\n     * @see #WIFI_SECURITY_ENTERPRISE_192\n     ",
    "links" : [ "#getMinimumRequiredWifiSecurityLevel()", "#setMinimumRequiredWifiSecurityLevel(int)" ]
  }, {
    "name" : "WIFI_SECURITY_PERSONAL",
    "type" : "int",
    "comment" : "\n     * Constant for {@link #getMinimumRequiredWifiSecurityLevel()} and\n     * {@link #setMinimumRequiredWifiSecurityLevel(int)}: personal network such as WEP, WPA2-PSK.\n     *\n     * <p> When returned from {@link #getMinimumRequiredWifiSecurityLevel()}, the constant\n     * represents the current minimum security level required.\n     * When passed to {@link #setMinimumRequiredWifiSecurityLevel(int)}, it sets the\n     * minimum security level a Wi-Fi network must meet.\n     *\n     * @see #WIFI_SECURITY_OPEN\n     * @see #WIFI_SECURITY_ENTERPRISE_EAP\n     * @see #WIFI_SECURITY_ENTERPRISE_192\n     ",
    "links" : [ "#getMinimumRequiredWifiSecurityLevel()", "#setMinimumRequiredWifiSecurityLevel(int)" ]
  }, {
    "name" : "WIFI_SECURITY_ENTERPRISE_EAP",
    "type" : "int",
    "comment" : "\n     * Constant for {@link #getMinimumRequiredWifiSecurityLevel()} and\n     * {@link #setMinimumRequiredWifiSecurityLevel(int)}: enterprise EAP network.\n     *\n     * <p> When returned from {@link #getMinimumRequiredWifiSecurityLevel()}, the constant\n     * represents the current minimum security level required.\n     * When passed to {@link #setMinimumRequiredWifiSecurityLevel(int)}, it sets the\n     * minimum security level a Wi-Fi network must meet.\n     *\n     * @see #WIFI_SECURITY_OPEN\n     * @see #WIFI_SECURITY_PERSONAL\n     * @see #WIFI_SECURITY_ENTERPRISE_192\n     ",
    "links" : [ "#getMinimumRequiredWifiSecurityLevel()", "#setMinimumRequiredWifiSecurityLevel(int)" ]
  }, {
    "name" : "WIFI_SECURITY_ENTERPRISE_192",
    "type" : "int",
    "comment" : "\n     * Constant for {@link #getMinimumRequiredWifiSecurityLevel()} and\n     * {@link #setMinimumRequiredWifiSecurityLevel(int)}: enterprise 192 bit network.\n     *\n     * <p> When returned from {@link #getMinimumRequiredWifiSecurityLevel()}, the constant\n     * represents the current minimum security level required.\n     * When passed to {@link #setMinimumRequiredWifiSecurityLevel(int)}, it sets the\n     * minimum security level a Wi-Fi network must meet.\n     *\n     * @see #WIFI_SECURITY_OPEN\n     * @see #WIFI_SECURITY_PERSONAL\n     * @see #WIFI_SECURITY_ENTERPRISE_EAP\n     ",
    "links" : [ "#getMinimumRequiredWifiSecurityLevel()", "#setMinimumRequiredWifiSecurityLevel(int)" ]
  }, {
    "name" : "MIME_TYPE_PROVISIONING_NFC",
    "type" : "String",
    "comment" : "\n     * This MIME type is used for starting the device owner provisioning.\n     *\n     * <p>During device owner provisioning a device admin app is set as the owner of the device.\n     * A device owner has full control over the device. The device owner can not be modified by the\n     * user and the only way of resetting the device is if the device owner app calls a factory\n     * reset.\n     *\n     * <p> A typical use case would be a device that is owned by a company, but used by either an\n     * employee or client.\n     *\n     * <p> The NFC message must be sent to an unprovisioned device.\n     *\n     * <p>The NFC record must contain a serialized {@link java.util.Properties} object which\n     * contains the following properties:\n     * <ul>\n     * <li>{@link #EXTRA_PROVISIONING_DEVICE_ADMIN_PACKAGE_NAME}</li>\n     * <li>{@link #EXTRA_PROVISIONING_DEVICE_ADMIN_PACKAGE_DOWNLOAD_LOCATION}, optional</li>\n     * <li>{@link #EXTRA_PROVISIONING_DEVICE_ADMIN_PACKAGE_DOWNLOAD_COOKIE_HEADER}, optional</li>\n     * <li>{@link #EXTRA_PROVISIONING_DEVICE_ADMIN_PACKAGE_CHECKSUM}, optional</li>\n     * <li>{@link #EXTRA_PROVISIONING_LOCAL_TIME} (convert to String), optional</li>\n     * <li>{@link #EXTRA_PROVISIONING_TIME_ZONE}, optional</li>\n     * <li>{@link #EXTRA_PROVISIONING_LOCALE}, optional</li>\n     * <li>{@link #EXTRA_PROVISIONING_WIFI_SSID}, optional</li>\n     * <li>{@link #EXTRA_PROVISIONING_WIFI_HIDDEN} (convert to String), optional</li>\n     * <li>{@link #EXTRA_PROVISIONING_WIFI_SECURITY_TYPE}, optional</li>\n     * <li>{@link #EXTRA_PROVISIONING_WIFI_PASSWORD}, optional</li>\n     * <li>{@link #EXTRA_PROVISIONING_WIFI_PROXY_HOST}, optional</li>\n     * <li>{@link #EXTRA_PROVISIONING_WIFI_PROXY_PORT} (convert to String), optional</li>\n     * <li>{@link #EXTRA_PROVISIONING_WIFI_PROXY_BYPASS}, optional</li>\n     * <li>{@link #EXTRA_PROVISIONING_WIFI_PAC_URL}, optional</li>\n     * <li>{@link #EXTRA_PROVISIONING_ADMIN_EXTRAS_BUNDLE}, optional, supported from {@link\n     * android.os.Build.VERSION_CODES#M} </li>\n     * <li>{@link #EXTRA_PROVISIONING_WIFI_EAP_METHOD}, optional, supported from {@link\n     * android.os.Build.VERSION_CODES#Q}</li>\n     * <li>{@link #EXTRA_PROVISIONING_WIFI_PHASE2_AUTH}, optional, supported from {@link\n     * android.os.Build.VERSION_CODES#Q}</li>\n     * <li>{@link #EXTRA_PROVISIONING_WIFI_CA_CERTIFICATE}, optional, supported from {@link\n     * android.os.Build.VERSION_CODES#Q}</li>\n     * <li>{@link #EXTRA_PROVISIONING_WIFI_USER_CERTIFICATE}, optional, supported from {@link\n     * android.os.Build.VERSION_CODES#Q}</li>\n     * <li>{@link #EXTRA_PROVISIONING_WIFI_IDENTITY}, optional, supported from {@link\n     * android.os.Build.VERSION_CODES#Q}</li>\n     * <li>{@link #EXTRA_PROVISIONING_WIFI_ANONYMOUS_IDENTITY}, optional, supported from {@link\n     * android.os.Build.VERSION_CODES#Q}</li>\n     * <li>{@link #EXTRA_PROVISIONING_WIFI_DOMAIN}, optional, supported from {@link\n     * android.os.Build.VERSION_CODES#Q}</li></ul>\n     *\n     * <p>\n     * As of {@link android.os.Build.VERSION_CODES#M}, the properties should contain\n     * {@link #EXTRA_PROVISIONING_DEVICE_ADMIN_COMPONENT_NAME} instead of\n     * {@link #EXTRA_PROVISIONING_DEVICE_ADMIN_PACKAGE_NAME}, (although specifying only\n     * {@link #EXTRA_PROVISIONING_DEVICE_ADMIN_PACKAGE_NAME} is still supported).\n     ",
    "links" : [ "#EXTRA_PROVISIONING_WIFI_USER_CERTIFICATE", "#EXTRA_PROVISIONING_LOCALE", "#EXTRA_PROVISIONING_WIFI_PHASE2_AUTH", "#EXTRA_PROVISIONING_WIFI_PROXY_BYPASS", "#EXTRA_PROVISIONING_DEVICE_ADMIN_PACKAGE_NAME", "#EXTRA_PROVISIONING_WIFI_PROXY_HOST", "android.os.Build.VERSION_CODES#M", "#EXTRA_PROVISIONING_DEVICE_ADMIN_COMPONENT_NAME", "#EXTRA_PROVISIONING_WIFI_PROXY_PORT", "#EXTRA_PROVISIONING_LOCAL_TIME", "#EXTRA_PROVISIONING_WIFI_HIDDEN", "#EXTRA_PROVISIONING_DEVICE_ADMIN_PACKAGE_DOWNLOAD_LOCATION", "#EXTRA_PROVISIONING_ADMIN_EXTRAS_BUNDLE", "#EXTRA_PROVISIONING_DEVICE_ADMIN_PACKAGE_DOWNLOAD_COOKIE_HEADER", "#EXTRA_PROVISIONING_WIFI_SSID", "java.util.Properties", "#EXTRA_PROVISIONING_WIFI_PASSWORD", "#EXTRA_PROVISIONING_WIFI_CA_CERTIFICATE", "#EXTRA_PROVISIONING_WIFI_IDENTITY", "#EXTRA_PROVISIONING_TIME_ZONE", "#EXTRA_PROVISIONING_WIFI_SECURITY_TYPE", "#EXTRA_PROVISIONING_WIFI_PAC_URL", "android.os.Build.VERSION_CODES#Q", "#EXTRA_PROVISIONING_WIFI_EAP_METHOD", "#EXTRA_PROVISIONING_DEVICE_ADMIN_PACKAGE_CHECKSUM", "#EXTRA_PROVISIONING_WIFI_ANONYMOUS_IDENTITY", "#EXTRA_PROVISIONING_WIFI_DOMAIN" ]
  }, {
    "name" : "ACTION_ADD_DEVICE_ADMIN",
    "type" : "String",
    "comment" : "\n     * Activity action: ask the user to add a new device administrator to the system.\n     * The desired policy is the ComponentName of the policy in the\n     * {@link #EXTRA_DEVICE_ADMIN} extra field.  This will invoke a UI to\n     * bring the user through adding the device administrator to the system (or\n     * allowing them to reject it).\n     *\n     * <p>You can optionally include the {@link #EXTRA_ADD_EXPLANATION}\n     * field to provide the user with additional explanation (in addition\n     * to your component's description) about what is being added.\n     *\n     * <p>If your administrator is already active, this will ordinarily return immediately (without\n     * user intervention).  However, if your administrator has been updated and is requesting\n     * additional uses-policy flags, the user will be presented with the new list.  New policies\n     * will not be available to the updated administrator until the user has accepted the new list.\n     ",
    "links" : [ "#EXTRA_ADD_EXPLANATION", "#EXTRA_DEVICE_ADMIN" ]
  }, {
    "name" : "ACTION_SET_PROFILE_OWNER",
    "type" : "String",
    "comment" : "\n     * @hide\n     * Activity action: ask the user to add a new device administrator as the profile owner\n     * for this user. Only system apps can launch this intent.\n     *\n     * <p>The ComponentName of the profile owner admin is passed in the {@link #EXTRA_DEVICE_ADMIN}\n     * extra field. This will invoke a UI to bring the user through adding the profile owner admin\n     * to remotely control restrictions on the user.\n     *\n     * <p>The intent must be invoked via {@link Activity#startActivityForResult} to receive the\n     * result of whether or not the user approved the action. If approved, the result will\n     * be {@link Activity#RESULT_OK} and the component will be set as an active admin as well\n     * as a profile owner.\n     *\n     * <p>You can optionally include the {@link #EXTRA_ADD_EXPLANATION}\n     * field to provide the user with additional explanation (in addition\n     * to your component's description) about what is being added.\n     *\n     * <p>If there is already a profile owner active or the caller is not a system app, the\n     * operation will return a failure result.\n     ",
    "links" : [ "android.app.Activity#RESULT_OK", "#EXTRA_ADD_EXPLANATION", "android.app.Activity#startActivityForResult", "#EXTRA_DEVICE_ADMIN" ]
  }, {
    "name" : "EXTRA_PROFILE_OWNER_NAME",
    "type" : "String",
    "comment" : "\n     * @hide\n     * Name of the profile owner admin that controls the user.\n     ",
    "links" : [ ]
  }, {
    "name" : "ACTION_DEVICE_POLICY_MANAGER_STATE_CHANGED",
    "type" : "String",
    "comment" : "\n     * Broadcast action: send when any policy admin changes a policy.\n     * This is generally used to find out when a new policy is in effect.\n     *\n     * If the profile owner of an organization-owned managed profile changes some user\n     * restriction explicitly on the parent user, this broadcast will <em>not</em> be\n     * sent to the parent user.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "ACTION_DEVICE_OWNER_CHANGED",
    "type" : "String",
    "comment" : "\n     * Broadcast action: sent when the device owner is set, changed or cleared.\n     *\n     * This broadcast is sent only to the primary user.\n     * @see #ACTION_PROVISION_MANAGED_DEVICE\n     * @see DevicePolicyManager#transferOwnership(ComponentName, ComponentName, PersistableBundle)\n     ",
    "links" : [ ]
  }, {
    "name" : "ACTION_RESET_PROTECTION_POLICY_CHANGED",
    "type" : "String",
    "comment" : "\n     * Broadcast action: sent when the factory reset protection (FRP) policy is changed.\n     *\n     * @see #setFactoryResetProtectionPolicy\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "ACTION_LOST_MODE_LOCATION_UPDATE",
    "type" : "String",
    "comment" : "\n     * Broadcast action: sent when there is a location update on a device in lost mode. This\n     * broadcast is explicitly sent to the device policy controller app only.\n     *\n     * @see DevicePolicyManager#sendLostModeLocationUpdate\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "EXTRA_LOST_MODE_LOCATION",
    "type" : "String",
    "comment" : "\n     * Extra used with {@link #ACTION_LOST_MODE_LOCATION_UPDATE} to send the location of a device\n     * in lost mode. Value is {@code Location}.\n     *\n     * @see DevicePolicyManager#sendLostModeLocationUpdate\n     * @hide\n     ",
    "links" : [ "#ACTION_LOST_MODE_LOCATION_UPDATE" ]
  }, {
    "name" : "EXTRA_DEVICE_ADMIN",
    "type" : "String",
    "comment" : "\n     * The ComponentName of the administrator component.\n     *\n     * @see #ACTION_ADD_DEVICE_ADMIN\n     ",
    "links" : [ ]
  }, {
    "name" : "EXTRA_ADD_EXPLANATION",
    "type" : "String",
    "comment" : "\n     * An optional CharSequence providing additional explanation for why the\n     * admin is being added.\n     *\n     * @see #ACTION_ADD_DEVICE_ADMIN\n     ",
    "links" : [ ]
  }, {
    "name" : "POLICY_DISABLE_CAMERA",
    "type" : "String",
    "comment" : "\n     * Constant to indicate the feature of disabling the camera. Used as argument to\n     * {@link #createAdminSupportIntent(String)}.\n     * @see #setCameraDisabled(ComponentName, boolean)\n     ",
    "links" : [ "#createAdminSupportIntent(String)" ]
  }, {
    "name" : "POLICY_DISABLE_SCREEN_CAPTURE",
    "type" : "String",
    "comment" : "\n     * Constant to indicate the feature of disabling screen captures. Used as argument to\n     * {@link #createAdminSupportIntent(String)}.\n     * @see #setScreenCaptureDisabled(ComponentName, boolean)\n     ",
    "links" : [ "#createAdminSupportIntent(String)" ]
  }, {
    "name" : "POLICY_SUSPEND_PACKAGES",
    "type" : "String",
    "comment" : "\n     * Constant to indicate the feature of suspending app. Use it as the value of\n     * {@link #EXTRA_RESTRICTION}.\n     * @hide\n     ",
    "links" : [ "#EXTRA_RESTRICTION" ]
  }, {
    "name" : "EXTRA_RESTRICTION",
    "type" : "String",
    "comment" : "\n     * A String indicating a specific restricted feature. Can be a user restriction from the\n     * {@link UserManager}, e.g. {@link UserManager#DISALLOW_ADJUST_VOLUME}, or one of the values\n     * {@link #POLICY_DISABLE_CAMERA} or {@link #POLICY_DISABLE_SCREEN_CAPTURE}.\n     * @see #createAdminSupportIntent(String)\n     * @hide\n     ",
    "links" : [ "android.os.UserManager", "android.os.UserManager#DISALLOW_ADJUST_VOLUME", "#POLICY_DISABLE_CAMERA", "#POLICY_DISABLE_SCREEN_CAPTURE" ]
  }, {
    "name" : "ACTION_SET_NEW_PASSWORD",
    "type" : "String",
    "comment" : "\n     * Activity action: have the user enter a new password.\n     *\n     * <p>For admin apps, this activity should be launched after using {@link\n     * #setPasswordQuality(ComponentName, int)}, or {@link\n     * #setPasswordMinimumLength(ComponentName, int)} to have the user enter a new password that\n     * meets the current requirements. You can use {@link #isActivePasswordSufficient()} to\n     * determine whether you need to have the user select a new password in order to meet the\n     * current constraints. Upon being resumed from this activity, you can check the new\n     * password characteristics to see if they are sufficient.\n     *\n     * <p>Non-admin apps can use {@link #getPasswordComplexity()} to check the current screen lock\n     * complexity, and use this activity with extra {@link #EXTRA_PASSWORD_COMPLEXITY} to suggest\n     * to users how complex the app wants the new screen lock to be. Note that both {@link\n     * #getPasswordComplexity()} and the extra {@link #EXTRA_PASSWORD_COMPLEXITY} require the\n     * calling app to have the permission {@link permission#REQUEST_PASSWORD_COMPLEXITY}.\n     *\n     * <p>If the intent is launched from within a managed profile with a profile\n     * owner built against {@link android.os.Build.VERSION_CODES#M} or before,\n     * this will trigger entering a new password for the parent of the profile.\n     * For all other cases it will trigger entering a new password for the user\n     * or profile it is launched from.\n     *\n     * @see #ACTION_SET_NEW_PARENT_PROFILE_PASSWORD\n     ",
    "links" : [ "#setPasswordQuality(ComponentName", "#setPasswordMinimumLength(ComponentName", "#getPasswordComplexity()", "#isActivePasswordSufficient()", "#EXTRA_PASSWORD_COMPLEXITY", "android.Manifest.permission#REQUEST_PASSWORD_COMPLEXITY", "android.os.Build.VERSION_CODES#M" ]
  }, {
    "name" : "EXTRA_PASSWORD_COMPLEXITY",
    "type" : "String",
    "comment" : "\n     * An integer indicating the complexity level of the new password an app would like the user to\n     * set when launching the action {@link #ACTION_SET_NEW_PASSWORD}.\n     *\n     * <p>Must be one of\n     * <ul>\n     *     <li>{@link #PASSWORD_COMPLEXITY_HIGH}\n     *     <li>{@link #PASSWORD_COMPLEXITY_MEDIUM}\n     *     <li>{@link #PASSWORD_COMPLEXITY_LOW}\n     *     <li>{@link #PASSWORD_COMPLEXITY_NONE}\n     * </ul>\n     *\n     * <p>If an invalid value is used, it will be treated as {@link #PASSWORD_COMPLEXITY_NONE}.\n     ",
    "links" : [ "#PASSWORD_COMPLEXITY_MEDIUM", "#PASSWORD_COMPLEXITY_LOW", "#ACTION_SET_NEW_PASSWORD", "#PASSWORD_COMPLEXITY_NONE", "#PASSWORD_COMPLEXITY_HIGH" ]
  }, {
    "name" : "PASSWORD_COMPLEXITY_NONE",
    "type" : "int",
    "comment" : "\n     * Constant for {@link #getPasswordComplexity()} and\n     * {@link #setRequiredPasswordComplexity(int)}: no password.\n     *\n     * <p> When returned from {@link #getPasswordComplexity()}, the constant represents\n     * the exact complexity band the password is in.\n     * When passed to {@link #setRequiredPasswordComplexity(int), it sets the minimum complexity\n     * band which the password must meet.\n     ",
    "links" : [ "#getPasswordComplexity()", "#setRequiredPasswordComplexity(int)" ]
  }, {
    "name" : "PASSWORD_COMPLEXITY_LOW",
    "type" : "int",
    "comment" : "\n     * Constant for {@link #getPasswordComplexity()} and\n     * {@link #setRequiredPasswordComplexity(int)}.\n     * Define the low password complexity band as:\n     * <ul>\n     * <li>pattern\n     * <li>PIN with repeating (4444) or ordered (1234, 4321, 2468) sequences\n     * </ul>\n     *\n     * <p> When returned from {@link #getPasswordComplexity()}, the constant represents\n     * the exact complexity band the password is in.\n     * When passed to {@link #setRequiredPasswordComplexity(int), it sets the minimum complexity\n     * band which the password must meet.\n     *\n     * @see #PASSWORD_QUALITY_SOMETHING\n     * @see #PASSWORD_QUALITY_NUMERIC\n     ",
    "links" : [ "#getPasswordComplexity()", "#setRequiredPasswordComplexity(int)" ]
  }, {
    "name" : "PASSWORD_COMPLEXITY_MEDIUM",
    "type" : "int",
    "comment" : "\n     * Constant for {@link #getPasswordComplexity()} and\n     * {@link #setRequiredPasswordComplexity(int)}.\n     * Define the medium password complexity band as:\n     * <ul>\n     * <li>PIN with <b>no</b> repeating (4444) or ordered (1234, 4321, 2468) sequences, length at\n     * least 4\n     * <li>alphabetic, length at least 4\n     * <li>alphanumeric, length at least 4\n     * </ul>\n     *\n     * <p> When returned from {@link #getPasswordComplexity()}, the constant represents\n     * the exact complexity band the password is in.\n     * When passed to {@link #setRequiredPasswordComplexity(int), it sets the minimum complexity\n     * band which the password must meet.\n     *\n     * @see #PASSWORD_QUALITY_NUMERIC_COMPLEX\n     * @see #PASSWORD_QUALITY_ALPHABETIC\n     * @see #PASSWORD_QUALITY_ALPHANUMERIC\n     ",
    "links" : [ "#getPasswordComplexity()", "#setRequiredPasswordComplexity(int)" ]
  }, {
    "name" : "PASSWORD_COMPLEXITY_HIGH",
    "type" : "int",
    "comment" : "\n     * Constant for {@link #getPasswordComplexity()} and\n     * {@link #setRequiredPasswordComplexity(int)}.\n     * Define the high password complexity band as:\n     * <ul>\n     * <li>PIN with <b>no</b> repeating (4444) or ordered (1234, 4321, 2468) sequences, length at\n     * least 8\n     * <li>alphabetic, length at least 6\n     * <li>alphanumeric, length at least 6\n     * </ul>\n     *\n     * <p> When returned from {@link #getPasswordComplexity()}, the constant represents\n     * the exact complexity band the password is in.\n     * When passed to {@link #setRequiredPasswordComplexity(int), it sets the minimum complexity\n     * band which the password must meet.\n     *\n     * @see #PASSWORD_QUALITY_NUMERIC_COMPLEX\n     * @see #PASSWORD_QUALITY_ALPHABETIC\n     * @see #PASSWORD_QUALITY_ALPHANUMERIC\n     ",
    "links" : [ "#getPasswordComplexity()", "#setRequiredPasswordComplexity(int)" ]
  }, {
    "name" : "EXTRA_DEVICE_PASSWORD_REQUIREMENT_ONLY",
    "type" : "String",
    "comment" : "\n     * A boolean extra for {@link #ACTION_SET_NEW_PARENT_PROFILE_PASSWORD} requesting that only\n     * device password requirement is enforced during the parent profile password enrolment flow.\n     * <p> Normally when enrolling password for the parent profile, both the device-wide password\n     * requirement (requirement set via {@link #getParentProfileInstance(ComponentName)} instance)\n     * and the profile password requirement are enforced, if the profile currently does not have a\n     * separate work challenge. By setting this to {@code true}, profile password requirement is\n     * explicitly disregarded.\n     *\n     * @see #isActivePasswordSufficientForDeviceRequirement()\n     ",
    "links" : [ "#getParentProfileInstance(ComponentName)", "#ACTION_SET_NEW_PARENT_PROFILE_PASSWORD" ]
  }, {
    "name" : "NEARBY_STREAMING_NOT_CONTROLLED_BY_POLICY",
    "type" : "int",
    "comment" : "\n     * Indicates that nearby streaming is not controlled by policy, which means nearby streaming is\n     * allowed.\n     ",
    "links" : [ ]
  }, {
    "name" : "NEARBY_STREAMING_DISABLED",
    "type" : "int",
    "comment" : " Indicates that nearby streaming is disabled. ",
    "links" : [ ]
  }, {
    "name" : "NEARBY_STREAMING_ENABLED",
    "type" : "int",
    "comment" : " Indicates that nearby streaming is enabled. ",
    "links" : [ ]
  }, {
    "name" : "NEARBY_STREAMING_SAME_MANAGED_ACCOUNT_ONLY",
    "type" : "int",
    "comment" : "\n     * Indicates that nearby streaming is enabled only to devices offering a comparable level of\n     * security, with the same authenticated managed account.\n     ",
    "links" : [ ]
  }, {
    "name" : "ACTION_SET_NEW_PARENT_PROFILE_PASSWORD",
    "type" : "String",
    "comment" : "\n     * Activity action: have the user enter a new password for the parent profile.\n     * If the intent is launched from within a managed profile, this will trigger\n     * entering a new password for the parent of the profile. The caller can optionally\n     * set {@link #EXTRA_DEVICE_PASSWORD_REQUIREMENT_ONLY} to only enforce device-wide\n     * password requirement. In all other cases the behaviour is identical to\n     * {@link #ACTION_SET_NEW_PASSWORD}.\n     ",
    "links" : [ "#ACTION_SET_NEW_PASSWORD", "#EXTRA_DEVICE_PASSWORD_REQUIREMENT_ONLY" ]
  }, {
    "name" : "ACTION_SHOW_DEVICE_MONITORING_DIALOG",
    "type" : "String",
    "comment" : "\n     * Broadcast action: Tell the status bar to open the device monitoring dialog, e.g. when\n     * Network logging was enabled and the user tapped the notification.\n     * <p class=\"note\">This is a protected intent that can only be sent by the system.</p>\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "ACTION_APPLICATION_DELEGATION_SCOPES_CHANGED",
    "type" : "String",
    "comment" : "\n     * Broadcast Action: Sent after application delegation scopes are changed. The new delegation\n     * scopes will be sent in an {@code ArrayList<String>} extra identified by the\n     * {@link #EXTRA_DELEGATION_SCOPES} key.\n     *\n     * <p class=\"note\"><b>Note:</b> This is a protected intent that can only be sent by the\n     * system.</p>\n     ",
    "links" : [ "#EXTRA_DELEGATION_SCOPES" ]
  }, {
    "name" : "EXTRA_DELEGATION_SCOPES",
    "type" : "String",
    "comment" : "\n     * An {@code ArrayList<String>} corresponding to the delegation scopes given to an app in the\n     * {@link #ACTION_APPLICATION_DELEGATION_SCOPES_CHANGED} broadcast.\n     ",
    "links" : [ "#ACTION_APPLICATION_DELEGATION_SCOPES_CHANGED" ]
  }, {
    "name" : "FLAG_PARENT_CAN_ACCESS_MANAGED",
    "type" : "int",
    "comment" : "\n     * Flag used by {@link #addCrossProfileIntentFilter} to allow activities in\n     * the parent profile to access intents sent from the managed profile.\n     * That is, when an app in the managed profile calls\n     * {@link Activity#startActivity(Intent)}, the intent can be resolved by a\n     * matching activity in the parent profile.\n     ",
    "links" : [ "android.app.Activity#startActivity(Intent)", "#addCrossProfileIntentFilter" ]
  }, {
    "name" : "FLAG_MANAGED_CAN_ACCESS_PARENT",
    "type" : "int",
    "comment" : "\n     * Flag used by {@link #addCrossProfileIntentFilter} to allow activities in\n     * the managed profile to access intents sent from the parent profile.\n     * That is, when an app in the parent profile calls\n     * {@link Activity#startActivity(Intent)}, the intent can be resolved by a\n     * matching activity in the managed profile.\n     ",
    "links" : [ "android.app.Activity#startActivity(Intent)", "#addCrossProfileIntentFilter" ]
  }, {
    "name" : "ACTION_SYSTEM_UPDATE_POLICY_CHANGED",
    "type" : "String",
    "comment" : "\n     * Broadcast action: notify that a new local system update policy has been set by the device\n     * owner. The new policy can be retrieved by {@link #getSystemUpdatePolicy()}.\n     ",
    "links" : [ "#getSystemUpdatePolicy()" ]
  }, {
    "name" : "ACTION_DATA_SHARING_RESTRICTION_APPLIED",
    "type" : "String",
    "comment" : "\n     * Broadcast action from ManagedProvisioning to notify that the latest change to\n     * {@link UserManager#DISALLOW_SHARE_INTO_MANAGED_PROFILE} restriction has been successfully\n     * applied (cross profile intent filters updated). Only usesd for CTS tests.\n     * @hide\n     ",
    "links" : [ "android.os.UserManager#DISALLOW_SHARE_INTO_MANAGED_PROFILE" ]
  }, {
    "name" : "ACTION_DEVICE_POLICY_CONSTANTS_CHANGED",
    "type" : "String",
    "comment" : "\n     * Broadcast action: notify that a value of {@link Settings.Global#DEVICE_POLICY_CONSTANTS}\n     * has been changed.\n     * @hide\n     ",
    "links" : [ "Settings.Global#DEVICE_POLICY_CONSTANTS" ]
  }, {
    "name" : "PERMISSION_POLICY_PROMPT",
    "type" : "int",
    "comment" : "\n     * Permission policy to prompt user for new permission requests for runtime permissions.\n     * Already granted or denied permissions are not affected by this.\n     ",
    "links" : [ ]
  }, {
    "name" : "PERMISSION_POLICY_AUTO_GRANT",
    "type" : "int",
    "comment" : "\n     * Permission policy to always grant new permission requests for runtime permissions.\n     * Already granted or denied permissions are not affected by this.\n     ",
    "links" : [ ]
  }, {
    "name" : "PERMISSION_POLICY_AUTO_DENY",
    "type" : "int",
    "comment" : "\n     * Permission policy to always deny new permission requests for runtime permissions.\n     * Already granted or denied permissions are not affected by this.\n     ",
    "links" : [ ]
  }, {
    "name" : "PERMISSION_GRANT_STATE_DEFAULT",
    "type" : "int",
    "comment" : "\n     * Runtime permission state: The user can manage the permission\n     * through the UI.\n     ",
    "links" : [ ]
  }, {
    "name" : "PERMISSION_GRANT_STATE_GRANTED",
    "type" : "int",
    "comment" : "\n     * Runtime permission state: The permission is granted to the app\n     * and the user cannot manage the permission through the UI.\n     ",
    "links" : [ ]
  }, {
    "name" : "PERMISSION_GRANT_STATE_DENIED",
    "type" : "int",
    "comment" : "\n     * Runtime permission state: The permission is denied to the app\n     * and the user cannot manage the permission through the UI.\n     ",
    "links" : [ ]
  }, {
    "name" : "DELEGATION_CERT_INSTALL",
    "type" : "String",
    "comment" : "\n     * Delegation of certificate installation and management. This scope grants access to the\n     * {@link #getInstalledCaCerts}, {@link #hasCaCertInstalled}, {@link #installCaCert},\n     * {@link #uninstallCaCert}, {@link #uninstallAllUserCaCerts} and {@link #installKeyPair} APIs.\n     * This scope also grants the ability to read identifiers that the delegating device owner or\n     * profile owner can obtain. See {@link #getEnrollmentSpecificId()}.\n     ",
    "links" : [ "#getInstalledCaCerts", "#uninstallCaCert", "#getEnrollmentSpecificId()", "#hasCaCertInstalled", "#installCaCert", "#uninstallAllUserCaCerts", "#installKeyPair" ]
  }, {
    "name" : "DELEGATION_APP_RESTRICTIONS",
    "type" : "String",
    "comment" : "\n     * Delegation of application restrictions management. This scope grants access to the\n     * {@link #setApplicationRestrictions} and {@link #getApplicationRestrictions} APIs.\n     ",
    "links" : [ "#getApplicationRestrictions", "#setApplicationRestrictions" ]
  }, {
    "name" : "DELEGATION_BLOCK_UNINSTALL",
    "type" : "String",
    "comment" : "\n     * Delegation of application uninstall block. This scope grants access to the\n     * {@link #setUninstallBlocked} API.\n     ",
    "links" : [ "#setUninstallBlocked" ]
  }, {
    "name" : "DELEGATION_PERMISSION_GRANT",
    "type" : "String",
    "comment" : "\n     * Delegation of permission policy and permission grant state. This scope grants access to the\n     * {@link #setPermissionPolicy}, {@link #getPermissionGrantState},\n     * and {@link #setPermissionGrantState} APIs.\n     ",
    "links" : [ "#getPermissionGrantState", "#setPermissionGrantState", "#setPermissionPolicy" ]
  }, {
    "name" : "DELEGATION_PACKAGE_ACCESS",
    "type" : "String",
    "comment" : "\n     * Delegation of package access state. This scope grants access to the\n     * {@link #isApplicationHidden}, {@link #setApplicationHidden}, {@link #isPackageSuspended}, and\n     * {@link #setPackagesSuspended} APIs.\n     ",
    "links" : [ "#isPackageSuspended", "#setPackagesSuspended", "#isApplicationHidden", "#setApplicationHidden" ]
  }, {
    "name" : "DELEGATION_ENABLE_SYSTEM_APP",
    "type" : "String",
    "comment" : "\n     * Delegation for enabling system apps. This scope grants access to the {@link #enableSystemApp}\n     * API.\n     ",
    "links" : [ "#enableSystemApp" ]
  }, {
    "name" : "DELEGATION_INSTALL_EXISTING_PACKAGE",
    "type" : "String",
    "comment" : "\n     * Delegation for installing existing packages. This scope grants access to the\n     * {@link #installExistingPackage} API.\n     ",
    "links" : [ "#installExistingPackage" ]
  }, {
    "name" : "DELEGATION_KEEP_UNINSTALLED_PACKAGES",
    "type" : "String",
    "comment" : "\n     * Delegation of management of uninstalled packages. This scope grants access to the\n     * {@link #setKeepUninstalledPackages} and {@link #getKeepUninstalledPackages} APIs.\n     ",
    "links" : [ "#setKeepUninstalledPackages", "#getKeepUninstalledPackages" ]
  }, {
    "name" : "DELEGATION_NETWORK_LOGGING",
    "type" : "String",
    "comment" : "\n     * Grants access to {@link #setNetworkLoggingEnabled}, {@link #isNetworkLoggingEnabled} and\n     * {@link #retrieveNetworkLogs}. Once granted the delegated app will start receiving\n     * DelegatedAdminReceiver.onNetworkLogsAvailable() callback, and Device owner or Profile Owner\n     * will no longer receive the DeviceAdminReceiver.onNetworkLogsAvailable() callback.\n     * There can be at most one app that has this delegation.\n     * If another app already had delegated network logging access,\n     * it will lose the delegation when a new app is delegated.\n     *\n     * <p> Device Owner can grant this access since Android 10. Profile Owner of a managed profile\n     * can grant this access since Android 12.\n     ",
    "links" : [ "#isNetworkLoggingEnabled", "#setNetworkLoggingEnabled", "#retrieveNetworkLogs" ]
  }, {
    "name" : "DELEGATION_CERT_SELECTION",
    "type" : "String",
    "comment" : "\n     * Grants access to selection of KeyChain certificates on behalf of requesting apps.\n     * Once granted the app will start receiving\n     * {@link DelegatedAdminReceiver#onChoosePrivateKeyAlias}. The caller (PO/DO) will\n     * no longer receive {@link DeviceAdminReceiver#onChoosePrivateKeyAlias}.\n     * There can be at most one app that has this delegation.\n     * If another app already had delegated certificate selection access,\n     * it will lose the delegation when a new app is delegated.\n     * <p> The delegated app can also call {@link #grantKeyPairToApp} and\n     * {@link #revokeKeyPairFromApp} to directly grant KeyChain keys to other apps.\n     * <p> Can be granted by Device Owner or Profile Owner.\n     ",
    "links" : [ "#revokeKeyPairFromApp", "android.app.admin.DeviceAdminReceiver#onChoosePrivateKeyAlias", "android.app.admin.DelegatedAdminReceiver#onChoosePrivateKeyAlias", "#grantKeyPairToApp" ]
  }, {
    "name" : "DELEGATION_SECURITY_LOGGING",
    "type" : "String",
    "comment" : "\n     * Grants access to {@link #setSecurityLoggingEnabled}, {@link #isSecurityLoggingEnabled},\n     * {@link #retrieveSecurityLogs}, and {@link #retrievePreRebootSecurityLogs}. Once granted the\n     * delegated app will start receiving {@link DelegatedAdminReceiver#onSecurityLogsAvailable}\n     * callback, and Device owner or Profile Owner will no longer receive the\n     * {@link DeviceAdminReceiver#onSecurityLogsAvailable} callback. There can be at most one app\n     * that has this delegation. If another app already had delegated security logging access, it\n     * will lose the delegation when a new app is delegated.\n     *\n     * <p> Can only be granted by Device Owner or Profile Owner of an organization-owned\n     * managed profile.\n     ",
    "links" : [ "android.app.admin.DeviceAdminReceiver#onSecurityLogsAvailable", "#isSecurityLoggingEnabled", "android.app.admin.DelegatedAdminReceiver#onSecurityLogsAvailable", "#retrieveSecurityLogs", "#setSecurityLoggingEnabled", "#retrievePreRebootSecurityLogs" ]
  }, {
    "name" : "STATE_USER_UNMANAGED",
    "type" : "int",
    "comment" : "\n     * No management for current user in-effect. This is the default.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "STATE_USER_SETUP_INCOMPLETE",
    "type" : "int",
    "comment" : "\n     * Management partially setup, user setup needs to be completed.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "STATE_USER_SETUP_COMPLETE",
    "type" : "int",
    "comment" : "\n     * Management partially setup, user setup completed.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "STATE_USER_SETUP_FINALIZED",
    "type" : "int",
    "comment" : "\n     * Management setup and active on current user.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "STATE_USER_PROFILE_COMPLETE",
    "type" : "int",
    "comment" : "\n     * Management partially setup on a managed profile.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "STATE_USER_PROFILE_FINALIZED",
    "type" : "int",
    "comment" : "\n     * Management setup on a managed profile.\n     * <p>This is used as an intermediate state after {@link #STATE_USER_PROFILE_COMPLETE} once the\n     * work profile has been created.\n     * @hide\n     ",
    "links" : [ "#STATE_USER_PROFILE_COMPLETE" ]
  }, {
    "name" : "STATUS_UNKNOWN_ERROR",
    "type" : "int",
    "comment" : "\n     * Result code for {@link #checkProvisioningPrecondition}.\n     *\n     * <p>Unknown error code returned  for {@link #ACTION_PROVISION_MANAGED_DEVICE},\n     * {@link #ACTION_PROVISION_MANAGED_PROFILE} and {@link #ACTION_PROVISION_MANAGED_USER}.\n     *\n     * @hide\n     ",
    "links" : [ "#ACTION_PROVISION_MANAGED_DEVICE", "#checkProvisioningPrecondition", "#ACTION_PROVISION_MANAGED_PROFILE", "#ACTION_PROVISION_MANAGED_USER" ]
  }, {
    "name" : "STATUS_OK",
    "type" : "int",
    "comment" : "\n     * Result code for {@link #checkProvisioningPrecondition}.\n     *\n     * <p>Returned for {@link #ACTION_PROVISION_MANAGED_DEVICE},\n     * {@link #ACTION_PROVISION_MANAGED_PROFILE} and {@link #ACTION_PROVISION_MANAGED_USER}\n     * when provisioning is allowed.\n     *\n     * @hide\n     ",
    "links" : [ "#ACTION_PROVISION_MANAGED_DEVICE", "#checkProvisioningPrecondition", "#ACTION_PROVISION_MANAGED_PROFILE", "#ACTION_PROVISION_MANAGED_USER" ]
  }, {
    "name" : "STATUS_HAS_DEVICE_OWNER",
    "type" : "int",
    "comment" : "\n     * Result code for {@link #checkProvisioningPrecondition}.\n     *\n     * <p>Returned for {@link #ACTION_PROVISION_MANAGED_DEVICE} when the device already has a\n     * device owner.\n     *\n     * @hide\n     ",
    "links" : [ "#ACTION_PROVISION_MANAGED_DEVICE", "#checkProvisioningPrecondition" ]
  }, {
    "name" : "STATUS_USER_HAS_PROFILE_OWNER",
    "type" : "int",
    "comment" : "\n     * Result code for {@link #checkProvisioningPrecondition}.\n     *\n     * <p>Returned for {@link #ACTION_PROVISION_MANAGED_DEVICE} when the user has a profile owner\n     *  and for {@link #ACTION_PROVISION_MANAGED_PROFILE} when the profile owner is already set.\n     *\n     * @hide\n     ",
    "links" : [ "#ACTION_PROVISION_MANAGED_DEVICE", "#checkProvisioningPrecondition", "#ACTION_PROVISION_MANAGED_PROFILE" ]
  }, {
    "name" : "STATUS_USER_NOT_RUNNING",
    "type" : "int",
    "comment" : "\n     * Result code for {@link #checkProvisioningPrecondition}.\n     *\n     * <p>Returned for {@link #ACTION_PROVISION_MANAGED_DEVICE} when the user isn't running.\n     *\n     * @hide\n     ",
    "links" : [ "#ACTION_PROVISION_MANAGED_DEVICE", "#checkProvisioningPrecondition" ]
  }, {
    "name" : "STATUS_USER_SETUP_COMPLETED",
    "type" : "int",
    "comment" : "\n     * Result code for {@link #checkProvisioningPrecondition}.\n     *\n     * <p>Returned for {@link #ACTION_PROVISION_MANAGED_DEVICE} if the device has already been\n     * setup and for {@link #ACTION_PROVISION_MANAGED_USER} if the user has already been setup.\n     *\n     * @hide\n     ",
    "links" : [ "#ACTION_PROVISION_MANAGED_DEVICE", "#checkProvisioningPrecondition", "#ACTION_PROVISION_MANAGED_USER" ]
  }, {
    "name" : "STATUS_NONSYSTEM_USER_EXISTS",
    "type" : "int",
    "comment" : "\n     * Code used to indicate that the device also has a user other than the system user.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "STATUS_ACCOUNTS_NOT_EMPTY",
    "type" : "int",
    "comment" : "\n     * Code used to indicate that device has an account that prevents provisioning.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "STATUS_NOT_SYSTEM_USER",
    "type" : "int",
    "comment" : "\n     * Result code for {@link #checkProvisioningPrecondition}.\n     *\n     * <p>Returned for {@link #ACTION_PROVISION_MANAGED_DEVICE} if the user is not a system user.\n     *\n     * @hide\n     ",
    "links" : [ "#ACTION_PROVISION_MANAGED_DEVICE", "#checkProvisioningPrecondition" ]
  }, {
    "name" : "STATUS_HAS_PAIRED",
    "type" : "int",
    "comment" : "\n     * Result code for {@link #checkProvisioningPrecondition}.\n     *\n     * <p>Returned for {@link #ACTION_PROVISION_MANAGED_DEVICE} and\n     * {@link #ACTION_PROVISION_MANAGED_USER} when the device is a watch and is already paired.\n     *\n     * @hide\n     ",
    "links" : [ "#ACTION_PROVISION_MANAGED_DEVICE", "#checkProvisioningPrecondition", "#ACTION_PROVISION_MANAGED_USER" ]
  }, {
    "name" : "STATUS_MANAGED_USERS_NOT_SUPPORTED",
    "type" : "int",
    "comment" : "\n     * Result code for {@link #checkProvisioningPrecondition}.\n     *\n     * <p>Returned for {@link #ACTION_PROVISION_MANAGED_PROFILE} and\n     * {@link #ACTION_PROVISION_MANAGED_USER} on devices which do not support managed users.\n     *\n     * @see {@link PackageManager#FEATURE_MANAGED_USERS}\n     * @hide\n     ",
    "links" : [ "#checkProvisioningPrecondition", "#ACTION_PROVISION_MANAGED_PROFILE", "#ACTION_PROVISION_MANAGED_USER", "android.content.pm.PackageManager#FEATURE_MANAGED_USERS" ]
  }, {
    "name" : "STATUS_SYSTEM_USER",
    "type" : "int",
    "comment" : "\n     * Result code for {@link #checkProvisioningPrecondition}.\n     *\n     * <p>Returned for {@link #ACTION_PROVISION_MANAGED_USER} if the user is a system user and\n     * for {@link #ACTION_PROVISION_MANAGED_DEVICE} on devices running headless system user mode\n     * and the user is a system user.\n     *\n     * @hide\n     ",
    "links" : [ "#ACTION_PROVISION_MANAGED_DEVICE", "#checkProvisioningPrecondition", "#ACTION_PROVISION_MANAGED_USER" ]
  }, {
    "name" : "STATUS_CANNOT_ADD_MANAGED_PROFILE",
    "type" : "int",
    "comment" : "\n     * Result code for {@link #checkProvisioningPrecondition}.\n     *\n     * <p>Returned for {@link #ACTION_PROVISION_MANAGED_PROFILE} when the user cannot have more\n     * managed profiles.\n     *\n     * @hide\n     ",
    "links" : [ "#checkProvisioningPrecondition", "#ACTION_PROVISION_MANAGED_PROFILE" ]
  }, {
    "name" : "STATUS_DEVICE_ADMIN_NOT_SUPPORTED",
    "type" : "int",
    "comment" : "\n     * Result code for {@link #checkProvisioningPrecondition}.\n     *\n     * <p>Returned for {@link #ACTION_PROVISION_MANAGED_DEVICE},\n     * {@link #ACTION_PROVISION_MANAGED_PROFILE} on devices which do not support device\n     * admins.\n     *\n     * @hide\n     ",
    "links" : [ "#ACTION_PROVISION_MANAGED_DEVICE", "#checkProvisioningPrecondition", "#ACTION_PROVISION_MANAGED_PROFILE" ]
  }, {
    "name" : "STATUS_SPLIT_SYSTEM_USER_DEVICE_SYSTEM_USER",
    "type" : "int",
    "comment" : "\n     * TODO (b/137101239): clean up split system user codes\n     * Result code for {@link #checkProvisioningPrecondition}.\n     *\n     * @hide\n     * @deprecated not used anymore but can't be removed since it's a @TestApi.\n     ",
    "links" : [ "#checkProvisioningPrecondition" ]
  }, {
    "name" : "STATUS_PROVISIONING_NOT_ALLOWED_FOR_NON_DEVELOPER_USERS",
    "type" : "int",
    "comment" : "\n     * Result code for {@link #checkProvisioningPrecondition}.\n     *\n     * <p>Returned for {@link #ACTION_PROVISION_MANAGED_DEVICE} and\n     * {@link #ACTION_PROVISION_MANAGED_PROFILE} on devices which do not support provisioning.\n     *\n     * @hide\n     ",
    "links" : [ "#ACTION_PROVISION_MANAGED_DEVICE", "#checkProvisioningPrecondition", "#ACTION_PROVISION_MANAGED_PROFILE" ]
  }, {
    "name" : "STATUS_HEADLESS_SYSTEM_USER_MODE_NOT_SUPPORTED",
    "type" : "int",
    "comment" : "\n     * Result code for {@link #checkProvisioningPrecondition}.\n     *\n     * <p>Returned for {@link #ACTION_PROVISION_MANAGED_DEVICE} when provisioning a DPC which does\n     * not support headless system user mode on a headless system user mode device.\n     *\n     * @hide\n     ",
    "links" : [ "#ACTION_PROVISION_MANAGED_DEVICE", "#checkProvisioningPrecondition" ]
  }, {
    "name" : "STATUS_HEADLESS_ONLY_SYSTEM_USER",
    "type" : "int",
    "comment" : "\n     * Result code for {@link #checkProvisioningPrecondition}.\n     *\n     * <p>Returned for {@link #ACTION_PROVISION_MANAGED_DEVICE} when provisioning a DPC into the\n     * {@link DeviceAdminInfo#HEADLESS_DEVICE_OWNER_MODE_SINGLE_USER} mode but only the system\n     * user exists on the device.\n     *\n     * @hide\n     ",
    "links" : [ "#ACTION_PROVISION_MANAGED_DEVICE", "android.app.admin.DeviceAdminInfo#HEADLESS_DEVICE_OWNER_MODE_SINGLE_USER", "#checkProvisioningPrecondition" ]
  }, {
    "name" : "LOCK_TASK_FEATURE_NONE",
    "type" : "int",
    "comment" : "\n     * Disable all configurable SystemUI features during LockTask mode. This includes,\n     * <ul>\n     *     <li>system info area in the status bar (connectivity icons, clock, etc.)\n     *     <li>notifications (including alerts, icons, and the notification shade)\n     *     <li>Home button\n     *     <li>Recents button and UI\n     *     <li>global actions menu (i.e. power button menu)\n     *     <li>keyguard\n     * </ul>\n     *\n     * @see #setLockTaskFeatures(ComponentName, int)\n     ",
    "links" : [ ]
  }, {
    "name" : "LOCK_TASK_FEATURE_SYSTEM_INFO",
    "type" : "int",
    "comment" : "\n     * Enable the system info area in the status bar during LockTask mode. The system info area\n     * usually occupies the right side of the status bar (although this can differ across OEMs). It\n     * includes all system information indicators, such as date and time, connectivity, battery,\n     * vibration mode, etc.\n     *\n     * @see #setLockTaskFeatures(ComponentName, int)\n     ",
    "links" : [ ]
  }, {
    "name" : "LOCK_TASK_FEATURE_NOTIFICATIONS",
    "type" : "int",
    "comment" : "\n     * Enable notifications during LockTask mode. This includes notification icons on the status\n     * bar, heads-up notifications, and the expandable notification shade. Note that the Quick\n     * Settings panel remains disabled. This feature flag can only be used in combination with\n     * {@link #LOCK_TASK_FEATURE_HOME}. {@link #setLockTaskFeatures(ComponentName, int)}\n     * throws an {@link IllegalArgumentException} if this feature flag is defined without\n     * {@link #LOCK_TASK_FEATURE_HOME}.\n     *\n     * @see #setLockTaskFeatures(ComponentName, int)\n     ",
    "links" : [ "#LOCK_TASK_FEATURE_HOME", "#setLockTaskFeatures(ComponentName", "IllegalArgumentException" ]
  }, {
    "name" : "LOCK_TASK_FEATURE_HOME",
    "type" : "int",
    "comment" : "\n     * Enable the Home button during LockTask mode. Note that if a custom launcher is used, it has\n     * to be registered as the default launcher with\n     * {@link #addPersistentPreferredActivity(ComponentName, IntentFilter, ComponentName)}, and its\n     * package needs to be allowlisted for LockTask with\n     * {@link #setLockTaskPackages(ComponentName, String[])}.\n     *\n     * @see #setLockTaskFeatures(ComponentName, int)\n     ",
    "links" : [ "#addPersistentPreferredActivity(ComponentName", "#setLockTaskPackages(ComponentName" ]
  }, {
    "name" : "LOCK_TASK_FEATURE_OVERVIEW",
    "type" : "int",
    "comment" : "\n     * Enable the Overview button and the Overview screen during LockTask mode. This feature flag\n     * can only be used in combination with {@link #LOCK_TASK_FEATURE_HOME}, and\n     * {@link #setLockTaskFeatures(ComponentName, int)} will throw an\n     * {@link IllegalArgumentException} if this feature flag is defined without\n     * {@link #LOCK_TASK_FEATURE_HOME}.\n     *\n     * @see #setLockTaskFeatures(ComponentName, int)\n     ",
    "links" : [ "#LOCK_TASK_FEATURE_HOME", "#setLockTaskFeatures(ComponentName", "IllegalArgumentException" ]
  }, {
    "name" : "LOCK_TASK_FEATURE_GLOBAL_ACTIONS",
    "type" : "int",
    "comment" : "\n     * Enable the global actions dialog during LockTask mode. This is the dialog that shows up when\n     * the user long-presses the power button, for example. Note that the user may not be able to\n     * power off the device if this flag is not set.\n     *\n     * <p>This flag is enabled by default until {@link #setLockTaskFeatures(ComponentName, int)} is\n     * called for the first time.\n     *\n     * @see #setLockTaskFeatures(ComponentName, int)\n     ",
    "links" : [ "#setLockTaskFeatures(ComponentName" ]
  }, {
    "name" : "LOCK_TASK_FEATURE_KEYGUARD",
    "type" : "int",
    "comment" : "\n     * Enable the keyguard during LockTask mode. Note that if the keyguard is already disabled with\n     * {@link #setKeyguardDisabled(ComponentName, boolean)}, setting this flag will have no effect.\n     * If this flag is not set, the keyguard will not be shown even if the user has a lock screen\n     * credential.\n     *\n     * @see #setLockTaskFeatures(ComponentName, int)\n     ",
    "links" : [ "#setKeyguardDisabled(ComponentName" ]
  }, {
    "name" : "LOCK_TASK_FEATURE_BLOCK_ACTIVITY_START_IN_TASK",
    "type" : "int",
    "comment" : "\n     * Enable blocking of non-allowlisted activities from being started into a locked task.\n     *\n     * @see #setLockTaskFeatures(ComponentName, int)\n     ",
    "links" : [ ]
  }, {
    "name" : "ACTION_DEVICE_ADMIN_SERVICE",
    "type" : "String",
    "comment" : "\n     * Service action: Action for a service that device owner and profile owner can optionally\n     * own.  If a device owner or a profile owner has such a service, the system tries to keep\n     * a bound connection to it, in order to keep their process always running.\n     * The service must be protected with the {@link android.Manifest.permission#BIND_DEVICE_ADMIN}\n     * permission.\n     ",
    "links" : [ "android.Manifest.permission#BIND_DEVICE_ADMIN" ]
  }, {
    "name" : "ID_TYPE_BASE_INFO",
    "type" : "int",
    "comment" : "\n     * Specifies that the device should attest its manufacturer details. For use with\n     * {@link #generateKeyPair}.\n     *\n     * @see #generateKeyPair\n     ",
    "links" : [ "#generateKeyPair" ]
  }, {
    "name" : "ID_TYPE_SERIAL",
    "type" : "int",
    "comment" : "\n     * Specifies that the device should attest its serial number. For use with\n     * {@link #generateKeyPair}.\n     *\n     * @see #generateKeyPair\n     ",
    "links" : [ "#generateKeyPair" ]
  }, {
    "name" : "ID_TYPE_IMEI",
    "type" : "int",
    "comment" : "\n     * Specifies that the device should attest its IMEI. For use with {@link #generateKeyPair}.\n     *\n     * @see #generateKeyPair\n     ",
    "links" : [ "#generateKeyPair" ]
  }, {
    "name" : "ID_TYPE_MEID",
    "type" : "int",
    "comment" : "\n     * Specifies that the device should attest its MEID. For use with {@link #generateKeyPair}.\n     *\n     * @see #generateKeyPair\n     ",
    "links" : [ "#generateKeyPair" ]
  }, {
    "name" : "ID_TYPE_INDIVIDUAL_ATTESTATION",
    "type" : "int",
    "comment" : "\n     * Specifies that the device should attest using an individual attestation certificate.\n     * For use with {@link #generateKeyPair}.\n     *\n     * @see #generateKeyPair\n     ",
    "links" : [ "#generateKeyPair" ]
  }, {
    "name" : "KEY_GEN_STRONGBOX_UNAVAILABLE",
    "type" : "int",
    "comment" : "\n     * Service-specific error code for {@link #generateKeyPair}:\n     * Indicates the call has failed due to StrongBox unavailability.\n     * @hide\n     ",
    "links" : [ "#generateKeyPair" ]
  }, {
    "name" : "INSTALLKEY_REQUEST_CREDENTIALS_ACCESS",
    "type" : "int",
    "comment" : "\n     * Specifies that the calling app should be granted access to the installed credentials\n     * immediately. Otherwise, access to the credentials will be gated by user approval.\n     * For use with {@link #installKeyPair(ComponentName, PrivateKey, Certificate[], String, int)}\n     *\n     * @see #installKeyPair(ComponentName, PrivateKey, Certificate[], String, int)\n     ",
    "links" : [ "#installKeyPair(ComponentName" ]
  }, {
    "name" : "INSTALLKEY_SET_USER_SELECTABLE",
    "type" : "int",
    "comment" : "\n     * Specifies that a user can select the key via the Certificate Selection prompt.\n     * If this flag is not set when calling {@link #installKeyPair}, the key can only be granted\n     * access by implementing {@link android.app.admin.DeviceAdminReceiver#onChoosePrivateKeyAlias}.\n     * For use with {@link #installKeyPair(ComponentName, PrivateKey, Certificate[], String, int)}\n     *\n     * @see #installKeyPair(ComponentName, PrivateKey, Certificate[], String, int)\n     ",
    "links" : [ "android.app.admin.DeviceAdminReceiver#onChoosePrivateKeyAlias", "#installKeyPair(ComponentName", "#installKeyPair" ]
  }, {
    "name" : "ACTION_PROFILE_OWNER_CHANGED",
    "type" : "String",
    "comment" : "\n     * Broadcast action: sent when the profile owner is set, changed or cleared.\n     *\n     * This broadcast is sent only to the user managed by the new profile owner.\n     * @see DevicePolicyManager#transferOwnership(ComponentName, ComponentName, PersistableBundle)\n     ",
    "links" : [ ]
  }, {
    "name" : "PRIVATE_DNS_MODE_UNKNOWN",
    "type" : "int",
    "comment" : "\n     * Specifies that the Private DNS setting is in an unknown state.\n     ",
    "links" : [ ]
  }, {
    "name" : "PRIVATE_DNS_MODE_OFF",
    "type" : "int",
    "comment" : "\n     * Specifies that Private DNS was turned off completely.\n     ",
    "links" : [ ]
  }, {
    "name" : "PRIVATE_DNS_MODE_OPPORTUNISTIC",
    "type" : "int",
    "comment" : "\n     * Specifies that the device owner requested opportunistic DNS over TLS\n     ",
    "links" : [ ]
  }, {
    "name" : "PRIVATE_DNS_MODE_PROVIDER_HOSTNAME",
    "type" : "int",
    "comment" : "\n     * Specifies that the device owner configured a specific host to use for Private DNS.\n     ",
    "links" : [ ]
  }, {
    "name" : "PRIVATE_DNS_SET_NO_ERROR",
    "type" : "int",
    "comment" : "\n     * The selected mode has been set successfully. If the mode is\n     * {@code PRIVATE_DNS_MODE_PROVIDER_HOSTNAME} then it implies the supplied host is valid\n     * and reachable.\n     ",
    "links" : [ ]
  }, {
    "name" : "PRIVATE_DNS_SET_ERROR_HOST_NOT_SERVING",
    "type" : "int",
    "comment" : "\n     * If the {@code privateDnsHost} provided was of a valid hostname but that host was found\n     * to not support DNS-over-TLS.\n     ",
    "links" : [ ]
  }, {
    "name" : "PRIVATE_DNS_SET_ERROR_FAILURE_SETTING",
    "type" : "int",
    "comment" : "\n     * General failure to set the Private DNS mode, not due to one of the reasons listed above.\n     ",
    "links" : [ ]
  }, {
    "name" : "ACTION_GET_PROVISIONING_MODE",
    "type" : "String",
    "comment" : "\n     * Activity action: Starts the administrator to get the mode for the provisioning.\n     * This intent may contain the following extras:\n     * <ul>\n     *     <li>{@link #EXTRA_PROVISIONING_ADMIN_EXTRAS_BUNDLE}</li>\n     *     <li>{@link #EXTRA_PROVISIONING_IMEI}</li>\n     *     <li>{@link #EXTRA_PROVISIONING_SERIAL_NUMBER}</li>\n     *     <li>{@link #EXTRA_PROVISIONING_ALLOWED_PROVISIONING_MODES}</li>\n     *     <li>{@link #EXTRA_PROVISIONING_SENSORS_PERMISSION_GRANT_OPT_OUT}</li>\n     * </ul>\n     *\n     * <p>The target activity should return one of the following values in\n     * {@link #EXTRA_PROVISIONING_MODE} as result:\n     * <ul>\n     *     <li>{@link #PROVISIONING_MODE_FULLY_MANAGED_DEVICE}</li>\n     *     <li>{@link #PROVISIONING_MODE_MANAGED_PROFILE}</li>\n     * </ul>\n     *\n     * <p>If performing fully-managed device provisioning and the admin app desires to show its\n     * own education screens, the target activity can additionally return\n     * {@link #EXTRA_PROVISIONING_SKIP_EDUCATION_SCREENS} set to <code>true</code>.\n     *\n     * <p>The target activity may also return the account that needs to be migrated from primary\n     * user to managed profile in case of a profile owner provisioning in\n     * {@link #EXTRA_PROVISIONING_ACCOUNT_TO_MIGRATE} as result.\n     *\n     * <p>The target activity may also include the {@link #EXTRA_PROVISIONING_ADMIN_EXTRAS_BUNDLE}\n     * extra in the intent result. The values of this {@link android.os.PersistableBundle} will be\n     * sent as an intent extra of the same name to the {@link #ACTION_ADMIN_POLICY_COMPLIANCE}\n     * activity, along with the values of the {@link #EXTRA_PROVISIONING_ADMIN_EXTRAS_BUNDLE} extra\n     * that are already supplied to this activity.\n     *\n     * <p>Other extras the target activity may include in the intent result:\n     * <ul>\n     *     <li>{@link #EXTRA_PROVISIONING_DISCLAIMERS}</li>\n     *     <li>{@link #EXTRA_PROVISIONING_SKIP_ENCRYPTION}</li>\n     *     <li>{@link #EXTRA_PROVISIONING_KEEP_SCREEN_ON}</li>\n     *     <li>{@link #EXTRA_PROVISIONING_KEEP_ACCOUNT_ON_MIGRATION} for work profile\n     *     provisioning</li>\n     *     <li>{@link #EXTRA_PROVISIONING_LEAVE_ALL_SYSTEM_APPS_ENABLED} for work profile\n     *     provisioning</li>\n     *     <li>{@link #EXTRA_PROVISIONING_SENSORS_PERMISSION_GRANT_OPT_OUT} for fully-managed\n     *     device provisioning</li>\n     *     <li>{@link #EXTRA_PROVISIONING_LOCALE} for fully-managed device provisioning</li>\n     *     <li>{@link #EXTRA_PROVISIONING_LOCAL_TIME} for fully-managed device provisioning</li>\n     *     <li>{@link #EXTRA_PROVISIONING_TIME_ZONE} for fully-managed device provisioning</li>\n     * </ul>\n     *\n     * @see #ACTION_ADMIN_POLICY_COMPLIANCE\n     ",
    "links" : [ "#PROVISIONING_MODE_MANAGED_PROFILE", "#EXTRA_PROVISIONING_ACCOUNT_TO_MIGRATE", "#EXTRA_PROVISIONING_SKIP_ENCRYPTION", "#EXTRA_PROVISIONING_LOCALE", "#EXTRA_PROVISIONING_LEAVE_ALL_SYSTEM_APPS_ENABLED", "#ACTION_ADMIN_POLICY_COMPLIANCE", "#EXTRA_PROVISIONING_TIME_ZONE", "#EXTRA_PROVISIONING_MODE", "#EXTRA_PROVISIONING_LOCAL_TIME", "#EXTRA_PROVISIONING_ALLOWED_PROVISIONING_MODES", "#PROVISIONING_MODE_FULLY_MANAGED_DEVICE", "android.os.PersistableBundle", "#EXTRA_PROVISIONING_IMEI", "#EXTRA_PROVISIONING_SENSORS_PERMISSION_GRANT_OPT_OUT", "#EXTRA_PROVISIONING_KEEP_ACCOUNT_ON_MIGRATION", "#EXTRA_PROVISIONING_DISCLAIMERS", "#EXTRA_PROVISIONING_ADMIN_EXTRAS_BUNDLE", "#EXTRA_PROVISIONING_SERIAL_NUMBER", "#EXTRA_PROVISIONING_KEEP_SCREEN_ON", "#EXTRA_PROVISIONING_SKIP_EDUCATION_SCREENS" ]
  }, {
    "name" : "EXTRA_PROVISIONING_IMEI",
    "type" : "String",
    "comment" : "\n     * A string extra holding the IMEI (International Mobile Equipment Identity) of the device.\n     ",
    "links" : [ ]
  }, {
    "name" : "EXTRA_PROVISIONING_SERIAL_NUMBER",
    "type" : "String",
    "comment" : "\n     * A string extra holding the serial number of the device.\n     ",
    "links" : [ ]
  }, {
    "name" : "EXTRA_PROVISIONING_MODE",
    "type" : "String",
    "comment" : "\n     * An intent extra holding the provisioning mode returned by the administrator.\n     * The value of this extra must be one of the values provided in {@link\n     * #EXTRA_PROVISIONING_ALLOWED_PROVISIONING_MODES}, which is provided as an intent extra to\n     * the admin app's {@link #ACTION_GET_PROVISIONING_MODE} activity.\n     *\n     * @see #PROVISIONING_MODE_FULLY_MANAGED_DEVICE\n     * @see #PROVISIONING_MODE_MANAGED_PROFILE\n     ",
    "links" : [ "#ACTION_GET_PROVISIONING_MODE", "#EXTRA_PROVISIONING_ALLOWED_PROVISIONING_MODES" ]
  }, {
    "name" : "EXTRA_PROVISIONING_SUPPORTED_MODES",
    "type" : "String",
    "comment" : "\n     * An integer extra indication what provisioning modes should be available for the admin app\n     * to pick.\n     *\n     * <p>The default value is {@link #FLAG_SUPPORTED_MODES_ORGANIZATION_OWNED}.\n     *\n     * <p>The value of this extra will determine the contents of the {@link\n     * #EXTRA_PROVISIONING_ALLOWED_PROVISIONING_MODES} array that is passed to the admin app as an\n     * extra to its {@link #ACTION_GET_PROVISIONING_MODE} activity.\n     *\n     * <p>If one of the possible admin app choices is a personally-owned work profile, then the\n     * IMEI and serial number will not be passed to the admin app's {@link\n     * #ACTION_GET_PROVISIONING_MODE} activity via the {@link #EXTRA_PROVISIONING_IMEI} and {@link\n     * #EXTRA_PROVISIONING_SERIAL_NUMBER} respectively.\n     *\n     * <p>The allowed flag combinations are:\n     * <ul>\n     *     <li>{@link #FLAG_SUPPORTED_MODES_ORGANIZATION_OWNED}</li>\n     *     <li>{@link #FLAG_SUPPORTED_MODES_PERSONALLY_OWNED}</li>\n     *     <li>{@link #FLAG_SUPPORTED_MODES_DEVICE_OWNER}</li>\n     *     <li>{@link #FLAG_SUPPORTED_MODES_ORGANIZATION_OWNED}\n     *             | {@link #FLAG_SUPPORTED_MODES_PERSONALLY_OWNED}</li>\n     * </ul>\n     *\n     * <p>This extra is only respected when provided alongside the {@link\n     * #ACTION_PROVISION_MANAGED_DEVICE_FROM_TRUSTED_SOURCE} intent action.\n     *\n     * @see #FLAG_SUPPORTED_MODES_ORGANIZATION_OWNED\n     * @see #FLAG_SUPPORTED_MODES_PERSONALLY_OWNED\n     * @see #FLAG_SUPPORTED_MODES_DEVICE_OWNER\n     * @hide\n     ",
    "links" : [ "#ACTION_GET_PROVISIONING_MODE", "#EXTRA_PROVISIONING_ALLOWED_PROVISIONING_MODES", "#EXTRA_PROVISIONING_IMEI", "#FLAG_SUPPORTED_MODES_PERSONALLY_OWNED", "#ACTION_PROVISION_MANAGED_DEVICE_FROM_TRUSTED_SOURCE", "#FLAG_SUPPORTED_MODES_ORGANIZATION_OWNED", "#EXTRA_PROVISIONING_SERIAL_NUMBER", "#FLAG_SUPPORTED_MODES_DEVICE_OWNER" ]
  }, {
    "name" : "EXTRA_PROVISIONING_SKIP_OWNERSHIP_DISCLAIMER",
    "type" : "String",
    "comment" : "\n     * A boolean extra which determines whether to skip the ownership disclaimer screen during the\n     * provisioning flow. The default value is {@code false}.\n     *\n     * If the value is {@code true}, the provisioning initiator must display a device ownership\n     * disclaimer screen similar to that provided in AOSP.\n     *\n     * <p>This extra is only respected when provided alongside the {@link\n     * #ACTION_PROVISION_MANAGED_DEVICE_FROM_TRUSTED_SOURCE} intent action.\n     *\n     * @hide\n     ",
    "links" : [ "#ACTION_PROVISION_MANAGED_DEVICE_FROM_TRUSTED_SOURCE" ]
  }, {
    "name" : "EXTRA_PROVISIONING_ALLOWED_PROVISIONING_MODES",
    "type" : "String",
    "comment" : "\n     * An {@link ArrayList} of {@link Integer} extra specifying the allowed provisioning modes.\n     * <p>This extra will be passed to the admin app's {@link #ACTION_GET_PROVISIONING_MODE}\n     * activity, whose result intent must contain {@link #EXTRA_PROVISIONING_MODE} set to one of\n     * the values in this array.\n     * <p>If the value set to {@link #EXTRA_PROVISIONING_MODE} is not in the array,\n     * provisioning will fail.\n     * @see #PROVISIONING_MODE_MANAGED_PROFILE\n     * @see #PROVISIONING_MODE_FULLY_MANAGED_DEVICE\n     ",
    "links" : [ "Integer", "#EXTRA_PROVISIONING_MODE", "#ACTION_GET_PROVISIONING_MODE", "java.util.ArrayList" ]
  }, {
    "name" : "PROVISIONING_MODE_FULLY_MANAGED_DEVICE",
    "type" : "int",
    "comment" : "\n     * The provisioning mode for fully managed device.\n     ",
    "links" : [ ]
  }, {
    "name" : "PROVISIONING_MODE_MANAGED_PROFILE",
    "type" : "int",
    "comment" : "\n     * The provisioning mode for managed profile.\n     ",
    "links" : [ ]
  }, {
    "name" : "PROVISIONING_MODE_MANAGED_PROFILE_ON_PERSONAL_DEVICE",
    "type" : "int",
    "comment" : "\n     * The provisioning mode for a managed profile on a personal device.\n     * <p>This mode is only available when the provisioning initiator has explicitly instructed the\n     * provisioning flow to support managed profile on a personal device provisioning. In that case,\n     * {@link #PROVISIONING_MODE_MANAGED_PROFILE} corresponds to an organization-owned managed\n     * profile, whereas this constant corresponds to a personally-owned managed profile.\n     *\n     * @see #EXTRA_PROVISIONING_MODE\n     ",
    "links" : [ "#PROVISIONING_MODE_MANAGED_PROFILE" ]
  }, {
    "name" : "EXTRA_PROVISIONING_RETURN_BEFORE_POLICY_COMPLIANCE",
    "type" : "String",
    "comment" : "\n     * A {@code boolean} flag that indicates whether the provisioning flow should return before\n     * starting the admin app's {@link #ACTION_ADMIN_POLICY_COMPLIANCE} handler. The default value\n     * is {@code true}.\n     *\n     * <p>If this extra is set to {@code true}, then when the provisioning flow returns back to the\n     * provisioning initiator, provisioning will not be complete. The provisioning initiator can\n     * use this opportunity to do its own preparatory steps prior to the launch of the admin app's\n     * {@link #ACTION_ADMIN_POLICY_COMPLIANCE} handler. It is the responsibility of the\n     * provisioning initiator to ensure that the provisioning flow is then resumed and completed.\n     *\n     * <p>If this extra is set to {@code false}, then when the provisioning flow returns back to\n     * the provisioning initiator, provisioning will be complete. Note that device owner\n     * provisioning is not currently supported for the this scenario.\n     *\n     * <p>This extra is only respected when provided alongside the {@link\n     * #ACTION_PROVISION_MANAGED_DEVICE_FROM_TRUSTED_SOURCE} intent action.\n     *\n     * @hide\n     ",
    "links" : [ "#ACTION_ADMIN_POLICY_COMPLIANCE", "#ACTION_PROVISION_MANAGED_DEVICE_FROM_TRUSTED_SOURCE" ]
  }, {
    "name" : "EXTRA_PROVISIONING_KEEP_SCREEN_ON",
    "type" : "String",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "ACTION_ADMIN_POLICY_COMPLIANCE",
    "type" : "String",
    "comment" : "\n     * Activity action: Starts the administrator to show policy compliance for the provisioning.\n     * This action is used any time that the administrator has an opportunity to show policy\n     * compliance before the end of setup wizard. This could happen as part of the admin-integrated\n     * provisioning flow (in which case this gets sent after {@link #ACTION_GET_PROVISIONING_MODE}),\n     * or it could happen during provisioning finalization if the administrator supports\n     * finalization during setup wizard.\n     *\n     * <p>Intents with this action may also be supplied with the {@link\n     * #EXTRA_PROVISIONING_ADMIN_EXTRAS_BUNDLE} extra.\n     *\n     * @see #ACTION_GET_PROVISIONING_MODE\n     ",
    "links" : [ "#ACTION_GET_PROVISIONING_MODE", "#EXTRA_PROVISIONING_ADMIN_EXTRAS_BUNDLE" ]
  }, {
    "name" : "ACTION_UPDATE_DEVICE_POLICY_MANAGEMENT_ROLE_HOLDER",
    "type" : "String",
    "comment" : "\n     * Activity action: Starts the device policy management role holder updater.\n     *\n     * <p>The activity must handle the device policy management role holder update and set the\n     * intent result. This can include {@link Activity#RESULT_OK} if the update was successful,\n     * {@link #RESULT_UPDATE_DEVICE_POLICY_MANAGEMENT_ROLE_HOLDER_RECOVERABLE_ERROR} if\n     * it encounters a problem that may be solved by relaunching it again, {@link\n     * #RESULT_UPDATE_DEVICE_POLICY_MANAGEMENT_ROLE_HOLDER_PROVISIONING_DISABLED} if role holder\n     * provisioning is disabled, or {@link\n     * #RESULT_UPDATE_DEVICE_POLICY_MANAGEMENT_ROLE_HOLDER_UNRECOVERABLE_ERROR} if it encounters\n     * any other problem that will not be solved by relaunching it again.\n     *\n     * <p>If this activity has additional internal conditions which are not met, it should return\n     * {@link #RESULT_UPDATE_DEVICE_POLICY_MANAGEMENT_ROLE_HOLDER_UNRECOVERABLE_ERROR}.\n     *\n     * @hide\n     ",
    "links" : [ "#RESULT_UPDATE_DEVICE_POLICY_MANAGEMENT_ROLE_HOLDER_RECOVERABLE_ERROR", "android.app.Activity#RESULT_OK", "#RESULT_UPDATE_DEVICE_POLICY_MANAGEMENT_ROLE_HOLDER_PROVISIONING_DISABLED", "#RESULT_UPDATE_DEVICE_POLICY_MANAGEMENT_ROLE_HOLDER_UNRECOVERABLE_ERROR" ]
  }, {
    "name" : "RESULT_UPDATE_DEVICE_POLICY_MANAGEMENT_ROLE_HOLDER_RECOVERABLE_ERROR",
    "type" : "int",
    "comment" : "\n     * Result code that can be returned by the {@link\n     * #ACTION_UPDATE_DEVICE_POLICY_MANAGEMENT_ROLE_HOLDER} handler if it encounters a problem\n     * that may be solved by relaunching it again.\n     *\n     * @hide\n     ",
    "links" : [ "#ACTION_UPDATE_DEVICE_POLICY_MANAGEMENT_ROLE_HOLDER" ]
  }, {
    "name" : "RESULT_UPDATE_DEVICE_POLICY_MANAGEMENT_ROLE_HOLDER_UNRECOVERABLE_ERROR",
    "type" : "int",
    "comment" : "\n     * Result code that can be returned by the {@link\n     * #ACTION_UPDATE_DEVICE_POLICY_MANAGEMENT_ROLE_HOLDER} handler if it encounters a problem that\n     * will not be solved by relaunching it again.\n     *\n     * @hide\n     ",
    "links" : [ "#ACTION_UPDATE_DEVICE_POLICY_MANAGEMENT_ROLE_HOLDER" ]
  }, {
    "name" : "RESULT_UPDATE_DEVICE_POLICY_MANAGEMENT_ROLE_HOLDER_PROVISIONING_DISABLED",
    "type" : "int",
    "comment" : "\n     * Result code that can be returned by the {@link\n     * #ACTION_UPDATE_DEVICE_POLICY_MANAGEMENT_ROLE_HOLDER} handler if role holder provisioning\n     * is disabled.\n     *\n     * @hide\n     ",
    "links" : [ "#ACTION_UPDATE_DEVICE_POLICY_MANAGEMENT_ROLE_HOLDER" ]
  }, {
    "name" : "EXTRA_ROLE_HOLDER_UPDATE_FAILURE_STRATEGY",
    "type" : "String",
    "comment" : "\n     * An {@code int} extra that specifies one of {@link\n     * #ROLE_HOLDER_UPDATE_FAILURE_STRATEGY_FAIL_PROVISIONING} or {@link\n     * #ROLE_HOLDER_UPDATE_FAILURE_STRATEGY_FALLBACK_TO_PLATFORM_PROVISIONING}.\n     *\n     * <p>The failure strategy specifies how the platform should handle a failed device policy\n     * management role holder update via {@link\n     * #ACTION_UPDATE_DEVICE_POLICY_MANAGEMENT_ROLE_HOLDER} when {@link\n     * #EXTRA_PROVISIONING_ALLOW_OFFLINE} is not set or set to {@code false}.\n     *\n     * <p>This extra may be supplied as part of the {@link\n     * #ACTION_UPDATE_DEVICE_POLICY_MANAGEMENT_ROLE_HOLDER} result intent.\n     *\n     * <p>Default value is {@link #ROLE_HOLDER_UPDATE_FAILURE_STRATEGY_FAIL_PROVISIONING}.\n     *\n     * @hide\n     ",
    "links" : [ "#ROLE_HOLDER_UPDATE_FAILURE_STRATEGY_FAIL_PROVISIONING", "#EXTRA_PROVISIONING_ALLOW_OFFLINE", "#ROLE_HOLDER_UPDATE_FAILURE_STRATEGY_FALLBACK_TO_PLATFORM_PROVISIONING", "#ACTION_UPDATE_DEVICE_POLICY_MANAGEMENT_ROLE_HOLDER" ]
  }, {
    "name" : "ROLE_HOLDER_UPDATE_FAILURE_STRATEGY_FAIL_PROVISIONING",
    "type" : "int",
    "comment" : "\n     * A value for {@link #EXTRA_ROLE_HOLDER_UPDATE_FAILURE_STRATEGY} indicating that upon\n     * failure to update the role holder, provisioning should fail.\n     *\n     * @hide\n     ",
    "links" : [ "#EXTRA_ROLE_HOLDER_UPDATE_FAILURE_STRATEGY" ]
  }, {
    "name" : "ROLE_HOLDER_UPDATE_FAILURE_STRATEGY_FALLBACK_TO_PLATFORM_PROVISIONING",
    "type" : "int",
    "comment" : "\n     * A value for {@link #EXTRA_ROLE_HOLDER_UPDATE_FAILURE_STRATEGY} indicating that upon\n     * failure to update the role holder, provisioning should fallback to be platform-driven.\n     *\n     * @hide\n     ",
    "links" : [ "#EXTRA_ROLE_HOLDER_UPDATE_FAILURE_STRATEGY" ]
  }, {
    "name" : "EXTRA_ROLE_HOLDER_UPDATE_RESULT_CODE",
    "type" : "String",
    "comment" : "\n     * An {@code int} extra which contains the result code of the last attempt to update\n     * the device policy management role holder via {@link\n     * #ACTION_UPDATE_DEVICE_POLICY_MANAGEMENT_ROLE_HOLDER}.\n     *\n     * <p>This extra is provided to the device policy management role holder via either {@link\n     * #ACTION_ROLE_HOLDER_PROVISION_MANAGED_DEVICE_FROM_TRUSTED_SOURCE} or {@link\n     * #ACTION_ROLE_HOLDER_PROVISION_MANAGED_PROFILE} when started after the role holder\n     * had previously returned {@link #RESULT_UPDATE_ROLE_HOLDER}.\n     *\n     * <p>If the role holder update had failed, the role holder can use the value of this extra to\n     * make a decision whether to fail the provisioning flow or to carry on with the older version\n     * of the role holder.\n     *\n     * <p>Possible values can be:\n     * <ul>\n     *    <li>{@link Activity#RESULT_OK} if the update was successful\n     *    <li>{@link #RESULT_UPDATE_DEVICE_POLICY_MANAGEMENT_ROLE_HOLDER_RECOVERABLE_ERROR} if it\n     *    encounters a problem that may be solved by relaunching it again.\n     *    <li>{@link #RESULT_UPDATE_DEVICE_POLICY_MANAGEMENT_ROLE_HOLDER_UNRECOVERABLE_ERROR} if\n     *    it encounters a problem that will not be solved by relaunching it again.\n     *    <li>Any other value returned by {@link\n     *    #ACTION_UPDATE_DEVICE_POLICY_MANAGEMENT_ROLE_HOLDER}\n     * </ul>\n     *\n     * @hide\n     ",
    "links" : [ "#ACTION_ROLE_HOLDER_PROVISION_MANAGED_DEVICE_FROM_TRUSTED_SOURCE", "#RESULT_UPDATE_DEVICE_POLICY_MANAGEMENT_ROLE_HOLDER_RECOVERABLE_ERROR", "android.app.Activity#RESULT_OK", "#RESULT_UPDATE_DEVICE_POLICY_MANAGEMENT_ROLE_HOLDER_UNRECOVERABLE_ERROR", "#RESULT_UPDATE_ROLE_HOLDER", "#ACTION_ROLE_HOLDER_PROVISION_MANAGED_PROFILE", "#ACTION_UPDATE_DEVICE_POLICY_MANAGEMENT_ROLE_HOLDER" ]
  }, {
    "name" : "EXTRA_PROVISIONING_ROLE_HOLDER_CUSTOM_USER_CONSENT_INTENT",
    "type" : "String",
    "comment" : "\n     * An {@link Intent} extra which resolves to a custom user consent screen.\n     *\n     * <p>If this extra is provided to the device policy management role holder via either {@link\n     * #ACTION_ROLE_HOLDER_PROVISION_MANAGED_DEVICE_FROM_TRUSTED_SOURCE} or {@link\n     * #ACTION_ROLE_HOLDER_PROVISION_MANAGED_PROFILE}, the device policy management role holder must\n     * launch this intent which shows the custom user consent screen, replacing its own standard\n     * consent screen.\n     *\n     * <p>If this extra is provided, it is the responsibility of the intent handler to show the\n     * list of disclaimers which are normally shown by the standard consent screen:\n     * <ul>\n     *     <li>Disclaimers set by the IT admin via the {@link #EXTRA_PROVISIONING_DISCLAIMERS}\n     *     provisioning extra</li>\n     *     <li>For fully-managed device provisioning, disclaimers defined in system apps via the\n     *     {@link #EXTRA_PROVISIONING_DISCLAIMER_HEADER} and {@link\n     *     #EXTRA_PROVISIONING_DISCLAIMER_CONTENT} metadata in their manifests</li>\n     *     <li>General disclaimer relevant to the provisioning mode</li>\n     * </ul>\n     *\n     * <p>When this {@link Intent} is started, the following intent extras will be supplied:\n     * <ul>\n     *     <li>{@link #EXTRA_PROVISIONING_DISCLAIMERS}</li>\n     *     <li>{@link #EXTRA_PROVISIONING_MODE}</li>\n     *     <li>{@link #EXTRA_PROVISIONING_LOCALE}</li>\n     *     <li>{@link #EXTRA_PROVISIONING_LOCAL_TIME}</li>\n     *     <li>{@link #EXTRA_PROVISIONING_TIME_ZONE}</li>\n     *     <li>{@link #EXTRA_PROVISIONING_SKIP_EDUCATION_SCREENS}</li>\n     * </ul>\n     *\n     * <p>If the custom consent screens are granted by the user {@link Activity#RESULT_OK} is\n     * returned, otherwise {@link Activity#RESULT_CANCELED} is returned. The device policy\n     * management role holder should ensure that the provisioning flow terminates immediately if\n     * consent is not granted by the user.\n     *\n     * @hide\n     ",
    "links" : [ "#ACTION_ROLE_HOLDER_PROVISION_MANAGED_DEVICE_FROM_TRUSTED_SOURCE", "#EXTRA_PROVISIONING_DISCLAIMER_CONTENT", "#EXTRA_PROVISIONING_LOCALE", "android.content.Intent", "#EXTRA_PROVISIONING_TIME_ZONE", "android.app.Activity#RESULT_CANCELED", "#EXTRA_PROVISIONING_MODE", "#EXTRA_PROVISIONING_LOCAL_TIME", "#EXTRA_PROVISIONING_DISCLAIMER_HEADER", "android.app.Activity#RESULT_OK", "#EXTRA_PROVISIONING_DISCLAIMERS", "#ACTION_ROLE_HOLDER_PROVISION_MANAGED_PROFILE", "#EXTRA_PROVISIONING_SKIP_EDUCATION_SCREENS" ]
  }, {
    "name" : "ACTION_ESTABLISH_NETWORK_CONNECTION",
    "type" : "String",
    "comment" : "\n     * Activity action: attempts to establish network connection\n     *\n     * <p>This intent can be accompanied by any of the relevant provisioning extras related to\n     * network connectivity, such as:\n     * <ul>\n     *     <li>{@link #EXTRA_PROVISIONING_WIFI_SSID}</li>\n     *     <li>{@link #EXTRA_PROVISIONING_WIFI_HIDDEN}</li>\n     *     <li>{@link #EXTRA_PROVISIONING_WIFI_SECURITY_TYPE}</li>\n     *     <li>{@link #EXTRA_PROVISIONING_WIFI_PASSWORD}</li>\n     *     <li>{@link #EXTRA_PROVISIONING_WIFI_PROXY_HOST}</li>\n     *     <li>{@link #EXTRA_PROVISIONING_WIFI_PROXY_PORT}</li>\n     *     <li>{@link #EXTRA_PROVISIONING_WIFI_PROXY_BYPASS}</li>\n     *     <li>{@link #EXTRA_PROVISIONING_WIFI_PAC_URL}</li>\n     *     <li>{@code #EXTRA_PROVISIONING_WIFI_EAP_METHOD}</li>\n     *     <li>{@code #EXTRA_PROVISIONING_WIFI_PHASE2_AUTH}</li>\n     *     <li>{@code #EXTRA_PROVISIONING_WIFI_CA_CERTIFICATE}</li>\n     *     <li>{@code #EXTRA_PROVISIONING_WIFI_USER_CERTIFICATE}</li>\n     *     <li>{@code #EXTRA_PROVISIONING_WIFI_IDENTITY}</li>\n     *     <li>{@code #EXTRA_PROVISIONING_WIFI_ANONYMOUS_IDENTITY}</li>\n     *     <li>{@code #EXTRA_PROVISIONING_WIFI_DOMAIN}</li>\n     * </ul>\n     *\n     * <p>If there are provisioning extras related to network connectivity, this activity\n     * attempts to connect to the specified network. Otherwise it prompts the end-user to connect.\n     *\n     * <p>This activity is meant to be started by the provisioning initiator prior to starting\n     * {@link #ACTION_PROVISION_MANAGED_PROFILE} or {@link\n     * #ACTION_PROVISION_MANAGED_DEVICE_FROM_TRUSTED_SOURCE}.\n     *\n     * <p>Note that network connectivity is still also handled when provisioning via {@link\n     * #ACTION_PROVISION_MANAGED_PROFILE} or {@link\n     * #ACTION_PROVISION_MANAGED_DEVICE_FROM_TRUSTED_SOURCE}. {@link\n     * #ACTION_ESTABLISH_NETWORK_CONNECTION} should only be used in cases when the provisioning\n     * initiator would like to do some additional logic after the network connectivity step and\n     * before the start of provisioning.\n     *\n     * If network connection is established, {@link Activity#RESULT_OK} will be returned. Otherwise\n     * the result will be {@link Activity#RESULT_CANCELED}.\n     *\n     * @hide\n     ",
    "links" : [ "#EXTRA_PROVISIONING_WIFI_SSID", "#EXTRA_PROVISIONING_WIFI_PASSWORD", "#EXTRA_PROVISIONING_WIFI_PROXY_BYPASS", "#EXTRA_PROVISIONING_WIFI_PROXY_HOST", "#EXTRA_PROVISIONING_WIFI_SECURITY_TYPE", "#ACTION_ESTABLISH_NETWORK_CONNECTION", "android.app.Activity#RESULT_CANCELED", "#EXTRA_PROVISIONING_WIFI_PROXY_PORT", "#EXTRA_PROVISIONING_WIFI_PAC_URL", "android.app.Activity#RESULT_OK", "#EXTRA_PROVISIONING_WIFI_HIDDEN", "#ACTION_PROVISION_MANAGED_PROFILE", "#ACTION_PROVISION_MANAGED_DEVICE_FROM_TRUSTED_SOURCE" ]
  }, {
    "name" : "MAX_PASSWORD_LENGTH",
    "type" : "int",
    "comment" : "\n     * Maximum supported password length. Kind-of arbitrary.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "ACTION_BIND_SECONDARY_LOCKSCREEN_SERVICE",
    "type" : "String",
    "comment" : "\n     * Service Action: Service implemented by a device owner or profile owner supervision app to\n     * provide a secondary lockscreen.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "PERSONAL_APPS_NOT_SUSPENDED",
    "type" : "int",
    "comment" : "\n     * Return value for {@link #getPersonalAppsSuspendedReasons} when personal apps are not\n     * suspended.\n     ",
    "links" : [ "#getPersonalAppsSuspendedReasons" ]
  }, {
    "name" : "PERSONAL_APPS_SUSPENDED_EXPLICITLY",
    "type" : "int",
    "comment" : "\n     * Flag for {@link #getPersonalAppsSuspendedReasons} return value. Set when personal\n     * apps are suspended by an admin explicitly via {@link #setPersonalAppsSuspended}.\n     ",
    "links" : [ "#getPersonalAppsSuspendedReasons", "#setPersonalAppsSuspended" ]
  }, {
    "name" : "PERSONAL_APPS_SUSPENDED_PROFILE_TIMEOUT",
    "type" : "int",
    "comment" : "\n     * Flag for {@link #getPersonalAppsSuspendedReasons} return value. Set when personal apps are\n     * suspended by framework because managed profile was off for longer than allowed by policy.\n     * @see #setManagedProfileMaximumTimeOff\n     ",
    "links" : [ "#getPersonalAppsSuspendedReasons" ]
  }, {
    "name" : "DEVICE_OWNER_TYPE_DEFAULT",
    "type" : "int",
    "comment" : "\n     * The default device owner type for a managed device.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "DEVICE_OWNER_TYPE_FINANCED",
    "type" : "int",
    "comment" : "\n     * The device owner type for a financed device.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "OPERATION_LOCK_NOW",
    "type" : "int",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "OPERATION_SWITCH_USER",
    "type" : "int",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "OPERATION_START_USER_IN_BACKGROUND",
    "type" : "int",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "OPERATION_STOP_USER",
    "type" : "int",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "OPERATION_CREATE_AND_MANAGE_USER",
    "type" : "int",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "OPERATION_REMOVE_USER",
    "type" : "int",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "OPERATION_REBOOT",
    "type" : "int",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "OPERATION_WIPE_DATA",
    "type" : "int",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "OPERATION_LOGOUT_USER",
    "type" : "int",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "OPERATION_SET_USER_RESTRICTION",
    "type" : "int",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "OPERATION_SET_SYSTEM_SETTING",
    "type" : "int",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "OPERATION_SET_KEYGUARD_DISABLED",
    "type" : "int",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "OPERATION_SET_STATUS_BAR_DISABLED",
    "type" : "int",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "OPERATION_SET_SYSTEM_UPDATE_POLICY",
    "type" : "int",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "OPERATION_SET_APPLICATION_HIDDEN",
    "type" : "int",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "OPERATION_SET_APPLICATION_RESTRICTIONS",
    "type" : "int",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "OPERATION_SET_KEEP_UNINSTALLED_PACKAGES",
    "type" : "int",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "OPERATION_SET_LOCK_TASK_FEATURES",
    "type" : "int",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "OPERATION_SET_LOCK_TASK_PACKAGES",
    "type" : "int",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "OPERATION_SET_PACKAGES_SUSPENDED",
    "type" : "int",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "OPERATION_SET_TRUST_AGENT_CONFIGURATION",
    "type" : "int",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "OPERATION_SET_USER_CONTROL_DISABLED_PACKAGES",
    "type" : "int",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "OPERATION_CLEAR_APPLICATION_USER_DATA",
    "type" : "int",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "OPERATION_INSTALL_CA_CERT",
    "type" : "int",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "OPERATION_INSTALL_KEY_PAIR",
    "type" : "int",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "OPERATION_INSTALL_SYSTEM_UPDATE",
    "type" : "int",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "OPERATION_REMOVE_ACTIVE_ADMIN",
    "type" : "int",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "OPERATION_REMOVE_KEY_PAIR",
    "type" : "int",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "OPERATION_REQUEST_BUGREPORT",
    "type" : "int",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "OPERATION_SET_ALWAYS_ON_VPN_PACKAGE",
    "type" : "int",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "OPERATION_SET_CAMERA_DISABLED",
    "type" : "int",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "OPERATION_SET_FACTORY_RESET_PROTECTION_POLICY",
    "type" : "int",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "OPERATION_SET_GLOBAL_PRIVATE_DNS",
    "type" : "int",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "OPERATION_SET_LOGOUT_ENABLED",
    "type" : "int",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "OPERATION_SET_MASTER_VOLUME_MUTED",
    "type" : "int",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "OPERATION_SET_OVERRIDE_APNS_ENABLED",
    "type" : "int",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "OPERATION_SET_PERMISSION_GRANT_STATE",
    "type" : "int",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "OPERATION_SET_PERMISSION_POLICY",
    "type" : "int",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "OPERATION_SET_RESTRICTIONS_PROVIDER",
    "type" : "int",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "OPERATION_UNINSTALL_CA_CERT",
    "type" : "int",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "OPERATION_SET_CONTENT_PROTECTION_POLICY",
    "type" : "int",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "PREFIX_OPERATION",
    "type" : "String",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "PREFIX_OPERATION_SAFETY_REASON",
    "type" : "String",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "OPERATION_SAFETY_REASON_NONE",
    "type" : "int",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "OPERATION_SAFETY_REASON_DRIVING_DISTRACTION",
    "type" : "int",
    "comment" : "\n     * Indicates that a {@link UnsafeStateException} was thrown because the operation would distract\n     * the driver of the vehicle.\n     ",
    "links" : [ "android.app.admin.UnsafeStateException" ]
  }, {
    "name" : "EXEMPT_FROM_SUSPENSION",
    "type" : "int",
    "comment" : "\n     * Prevent an app from being suspended.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "EXEMPT_FROM_DISMISSIBLE_NOTIFICATIONS",
    "type" : "int",
    "comment" : "\n     * Prevent an app from dismissible notifications. Starting from Android U, notifications with\n     * the ongoing parameter can be dismissed by a user on an unlocked device. An app with\n     * this exemption can create non-dismissible notifications.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "EXEMPT_FROM_ACTIVITY_BG_START_RESTRICTION",
    "type" : "int",
    "comment" : "\n     * Allows an application to start an activity while running in the background.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "EXEMPT_FROM_HIBERNATION",
    "type" : "int",
    "comment" : "\n     * Prevent an app from entering hibernation.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "EXEMPT_FROM_POWER_RESTRICTIONS",
    "type" : "int",
    "comment" : "\n     * Exempt an app from all power-related restrictions, including app standby and doze.\n     * In addition, the app will be able to start foreground services from the background,\n     * and the user will not be able to stop foreground services run by the app.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "ACTION_DEVICE_POLICY_RESOURCE_UPDATED",
    "type" : "String",
    "comment" : "\n     * Broadcast action: notify system apps (e.g. settings, SysUI, etc) that the device management\n     * resources with IDs {@link #EXTRA_RESOURCE_IDS} has been updated, the updated resources can be\n     * retrieved using {@link DevicePolicyResourcesManager#getDrawable} and\n     * {@link DevicePolicyResourcesManager#getString}.\n     *\n     * <p>This broadcast is sent to registered receivers only.\n     *\n     * <p> {@link #EXTRA_RESOURCE_TYPE} will be included to identify the type of resource being\n     * updated.\n     ",
    "links" : [ "#EXTRA_RESOURCE_IDS", "android.app.admin.DevicePolicyResourcesManager#getDrawable", "android.app.admin.DevicePolicyResourcesManager#getString", "#EXTRA_RESOURCE_TYPE" ]
  }, {
    "name" : "EXTRA_RESOURCE_TYPE",
    "type" : "String",
    "comment" : "\n     * An {@code int} extra for {@link #ACTION_DEVICE_POLICY_RESOURCE_UPDATED} to indicate the type\n     * of the resource being updated, the type can be {@link #EXTRA_RESOURCE_TYPE_DRAWABLE} or\n     * {@link #EXTRA_RESOURCE_TYPE_STRING}\n     ",
    "links" : [ "#EXTRA_RESOURCE_TYPE_DRAWABLE", "#EXTRA_RESOURCE_TYPE_STRING", "#ACTION_DEVICE_POLICY_RESOURCE_UPDATED" ]
  }, {
    "name" : "EXTRA_RESOURCE_TYPE_DRAWABLE",
    "type" : "int",
    "comment" : "\n     * A {@code int} value for {@link #EXTRA_RESOURCE_TYPE} to indicate that a resource of type\n     * {@link Drawable} is being updated.\n     ",
    "links" : [ "#EXTRA_RESOURCE_TYPE", "android.graphics.drawable.Drawable" ]
  }, {
    "name" : "EXTRA_RESOURCE_TYPE_STRING",
    "type" : "int",
    "comment" : "\n     * A {@code int} value for {@link #EXTRA_RESOURCE_TYPE} to indicate that a resource of type\n     * {@link String} is being updated.\n     ",
    "links" : [ "#EXTRA_RESOURCE_TYPE", "String" ]
  }, {
    "name" : "EXTRA_RESOURCE_IDS",
    "type" : "String",
    "comment" : "\n     * An integer array extra for {@link #ACTION_DEVICE_POLICY_RESOURCE_UPDATED} to indicate which\n     * resource IDs (i.e. strings and drawables) have been updated.\n     ",
    "links" : [ "#ACTION_DEVICE_POLICY_RESOURCE_UPDATED" ]
  }, {
    "name" : "ACTION_DEVICE_FINANCING_STATE_CHANGED",
    "type" : "String",
    "comment" : "\n     * Broadcast Action: Broadcast sent to indicate that the device financing state has changed.\n     *\n     * <p>This occurs when, for example, a financing kiosk app has been added or removed.\n     *\n     * <p>To query the current device financing state see {@link #isDeviceFinanced}.\n     *\n     * <p>This will be delivered to the following apps if they include a receiver for this action\n     * in their manifest:\n     * <ul>\n     *     <li>Device owner admins.\n     *     <li>Organization-owned profile owner admins\n     *     <li>The supervision app\n     *     <li>The device management role holder\n     * </ul>\n     ",
    "links" : [ "#isDeviceFinanced" ]
  }, {
    "name" : "MTE_NOT_CONTROLLED_BY_POLICY",
    "type" : "int",
    "comment" : " Allow the user to choose whether to enable MTE on the device. ",
    "links" : [ ]
  }, {
    "name" : "MTE_ENABLED",
    "type" : "int",
    "comment" : "\n     * Require that MTE be enabled on the device, if supported. Can be set by a device owner or a\n     * profile owner of an organization-owned managed profile.\n     ",
    "links" : [ ]
  }, {
    "name" : "MTE_DISABLED",
    "type" : "int",
    "comment" : " Require that MTE be disabled on the device. Can be set by a device owner. ",
    "links" : [ ]
  }, {
    "name" : "CONTENT_PROTECTION_NOT_CONTROLLED_BY_POLICY",
    "type" : "int",
    "comment" : " Indicates that content protection is not controlled by policy, allowing user to choose. ",
    "links" : [ ]
  }, {
    "name" : "CONTENT_PROTECTION_DISABLED",
    "type" : "int",
    "comment" : " Indicates that content protection is controlled and disabled by a policy (default). ",
    "links" : [ ]
  }, {
    "name" : "CONTENT_PROTECTION_ENABLED",
    "type" : "int",
    "comment" : " Indicates that content protection is controlled and enabled by a policy. ",
    "links" : [ ]
  }, {
    "name" : "sDpmCaches",
    "type" : "IpcDataCache.Config",
    "comment" : "\n     * This object is a single place to tack on invalidation and disable calls.  All\n     * binder caches in this class derive from this Config, so all can be invalidated or\n     * disabled through this Config.\n     ",
    "links" : [ ]
  }, {
    "name" : "PASSWORD_QUALITY_UNSPECIFIED",
    "type" : "int",
    "comment" : "\n     * Constant for {@link #setPasswordQuality}: the policy has no requirements\n     * for the password.  Note that quality constants are ordered so that higher\n     * values are more restrictive.\n     ",
    "links" : [ "#setPasswordQuality" ]
  }, {
    "name" : "PASSWORD_QUALITY_BIOMETRIC_WEAK",
    "type" : "int",
    "comment" : "\n     * Constant for {@link #setPasswordQuality}: the policy allows for low-security biometric\n     * recognition technology.  This implies technologies that can recognize the identity of\n     * an individual to about a 3 digit PIN (false detection is less than 1 in 1,000).\n     * Note that quality constants are ordered so that higher values are more restrictive.\n     ",
    "links" : [ "#setPasswordQuality" ]
  }, {
    "name" : "PASSWORD_QUALITY_SOMETHING",
    "type" : "int",
    "comment" : "\n     * Constant for {@link #setPasswordQuality}: the policy requires some kind\n     * of password or pattern, but doesn't care what it is. Note that quality constants\n     * are ordered so that higher values are more restrictive.\n     ",
    "links" : [ "#setPasswordQuality" ]
  }, {
    "name" : "PASSWORD_QUALITY_NUMERIC",
    "type" : "int",
    "comment" : "\n     * Constant for {@link #setPasswordQuality}: the user must have entered a\n     * password containing at least numeric characters.  Note that quality\n     * constants are ordered so that higher values are more restrictive.\n     ",
    "links" : [ "#setPasswordQuality" ]
  }, {
    "name" : "PASSWORD_QUALITY_NUMERIC_COMPLEX",
    "type" : "int",
    "comment" : "\n     * Constant for {@link #setPasswordQuality}: the user must have entered a\n     * password containing at least numeric characters with no repeating (4444)\n     * or ordered (1234, 4321, 2468) sequences.  Note that quality\n     * constants are ordered so that higher values are more restrictive.\n     ",
    "links" : [ "#setPasswordQuality" ]
  }, {
    "name" : "PASSWORD_QUALITY_ALPHABETIC",
    "type" : "int",
    "comment" : "\n     * Constant for {@link #setPasswordQuality}: the user must have entered a\n     * password containing at least alphabetic (or other symbol) characters.\n     * Note that quality constants are ordered so that higher values are more\n     * restrictive.\n     ",
    "links" : [ "#setPasswordQuality" ]
  }, {
    "name" : "PASSWORD_QUALITY_ALPHANUMERIC",
    "type" : "int",
    "comment" : "\n     * Constant for {@link #setPasswordQuality}: the user must have entered a\n     * password containing at least <em>both></em> numeric <em>and</em>\n     * alphabetic (or other symbol) characters.  Note that quality constants are\n     * ordered so that higher values are more restrictive.\n     ",
    "links" : [ "#setPasswordQuality" ]
  }, {
    "name" : "PASSWORD_QUALITY_COMPLEX",
    "type" : "int",
    "comment" : "\n     * Constant for {@link #setPasswordQuality}: allows the admin to set precisely how many\n     * characters of various types the password should contain to satisfy the policy. The admin\n     * should set these requirements via {@link #setPasswordMinimumLetters},\n     * {@link #setPasswordMinimumNumeric}, {@link #setPasswordMinimumSymbols},\n     * {@link #setPasswordMinimumUpperCase}, {@link #setPasswordMinimumLowerCase},\n     * {@link #setPasswordMinimumNonLetter}, and {@link #setPasswordMinimumLength}.\n     * Note that quality constants are ordered so that higher values are more restrictive.\n     ",
    "links" : [ "#setPasswordQuality", "#setPasswordMinimumLowerCase", "#setPasswordMinimumLetters", "#setPasswordMinimumNumeric", "#setPasswordMinimumUpperCase", "#setPasswordMinimumSymbols", "#setPasswordMinimumNonLetter", "#setPasswordMinimumLength" ]
  }, {
    "name" : "PASSWORD_QUALITY_MANAGED",
    "type" : "int",
    "comment" : "\n     * Constant for {@link #setPasswordQuality}: the user is not allowed to\n     * modify password. In case this password quality is set, the password is\n     * managed by a profile owner. The profile owner can set any password,\n     * as if {@link #PASSWORD_QUALITY_UNSPECIFIED} is used. Note\n     * that quality constants are ordered so that higher values are more\n     * restrictive. The value of {@link #PASSWORD_QUALITY_MANAGED} is\n     * the highest.\n     * @hide\n     ",
    "links" : [ "#setPasswordQuality", "#PASSWORD_QUALITY_UNSPECIFIED", "#PASSWORD_QUALITY_MANAGED" ]
  }, {
    "name" : "ACCOUNT_FEATURE_DEVICE_OR_PROFILE_OWNER_ALLOWED",
    "type" : "String",
    "comment" : "\n     * @hide\n     *\n     * adb shell dpm set-{device,profile}-owner will normally not allow installing an owner to\n     * a user with accounts.  {@link #ACCOUNT_FEATURE_DEVICE_OR_PROFILE_OWNER_ALLOWED}\n     * and {@link #ACCOUNT_FEATURE_DEVICE_OR_PROFILE_OWNER_DISALLOWED} are the account features\n     * used by authenticator to exempt their accounts from this:\n     *\n     * <ul>\n     *     <li>Non-test-only DO/PO still can't be installed when there are accounts.\n     *     <p>In order to make an apk test-only, add android:testOnly=\"true\" to the\n     *     &lt;application&gt; tag in the manifest.\n     *\n     *     <li>Test-only DO/PO can be installed even when there are accounts, as long as all the\n     *     accounts have the {@link #ACCOUNT_FEATURE_DEVICE_OR_PROFILE_OWNER_ALLOWED} feature.\n     *     Some authenticators claim to have any features, so to detect it, we also check\n     *     {@link #ACCOUNT_FEATURE_DEVICE_OR_PROFILE_OWNER_DISALLOWED} and disallow installing\n     *     if any of the accounts have it.\n     * </ul>\n     ",
    "links" : [ "#ACCOUNT_FEATURE_DEVICE_OR_PROFILE_OWNER_ALLOWED", "#ACCOUNT_FEATURE_DEVICE_OR_PROFILE_OWNER_DISALLOWED" ]
  }, {
    "name" : "ACCOUNT_FEATURE_DEVICE_OR_PROFILE_OWNER_DISALLOWED",
    "type" : "String",
    "comment" : " @hide See {@link #ACCOUNT_FEATURE_DEVICE_OR_PROFILE_OWNER_ALLOWED} ",
    "links" : [ "#ACCOUNT_FEATURE_DEVICE_OR_PROFILE_OWNER_ALLOWED" ]
  }, {
    "name" : "REQUIRED_APP_MANAGED_USER",
    "type" : "String",
    "comment" : "\n     * A {@code boolean} metadata to be included in a mainline module's {@code <application>}\n     * manifest element, which declares that the module should be considered a required app for\n     * managed users.\n     * <p>Being declared as a required app prevents removal of this package during the\n     * provisioning process.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "REQUIRED_APP_MANAGED_DEVICE",
    "type" : "String",
    "comment" : "\n     * A {@code boolean} metadata to be included in a mainline module's {@code <application>}\n     * manifest element, which declares that the module should be considered a required app for\n     * managed devices.\n     * <p>Being declared as a required app prevents removal of this package during the\n     * provisioning process.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "REQUIRED_APP_MANAGED_PROFILE",
    "type" : "String",
    "comment" : "\n     * A {@code boolean} metadata to be included in a mainline module's {@code <application>}\n     * manifest element, which declares that the module should be considered a required app for\n     * managed profiles.\n     * <p>Being declared as a required app prevents removal of this package during the\n     * provisioning process.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "RESET_PASSWORD_REQUIRE_ENTRY",
    "type" : "int",
    "comment" : "\n     * Flag for {@link #resetPasswordWithToken} and {@link #resetPassword}: don't allow other admins\n     * to change the password again until the user has entered it.\n     ",
    "links" : [ "#resetPassword", "#resetPasswordWithToken" ]
  }, {
    "name" : "RESET_PASSWORD_DO_NOT_ASK_CREDENTIALS_ON_BOOT",
    "type" : "int",
    "comment" : "\n     * Flag for {@link #resetPasswordWithToken} and {@link #resetPassword}: don't ask for user\n     * credentials on device boot.\n     * If the flag is set, the device can be booted without asking for user password.\n     * The absence of this flag does not change the current boot requirements. This flag\n     * can be set by the device owner only. If the app is not the device owner, the flag\n     * is ignored. Once the flag is set, it cannot be reverted back without resetting the\n     * device to factory defaults.\n     ",
    "links" : [ "#resetPassword", "#resetPasswordWithToken" ]
  }, {
    "name" : "FLAG_EVICT_CREDENTIAL_ENCRYPTION_KEY",
    "type" : "int",
    "comment" : "\n     * Flag for {@link #lockNow(int)}: also evict the user's credential encryption key from the\n     * keyring. The user's credential will need to be entered again in order to derive the\n     * credential encryption key that will be stored back in the keyring for future use.\n     * <p>\n     * This flag can only be used by a profile owner when locking a managed profile when\n     * {@link #getStorageEncryptionStatus} returns {@link #ENCRYPTION_STATUS_ACTIVE_PER_USER}.\n     * <p>\n     * In order to secure user data, the user will be stopped and restarted so apps should wait\n     * until they are next run to perform further actions.\n     ",
    "links" : [ "#lockNow(int)", "#getStorageEncryptionStatus", "#ENCRYPTION_STATUS_ACTIVE_PER_USER" ]
  }, {
    "name" : "WIPE_EXTERNAL_STORAGE",
    "type" : "int",
    "comment" : "\n     * Flag for {@link #wipeData(int)}: also erase the device's adopted external storage (such as\n     * adopted SD cards).\n     * @see <a href=\"{@docRoot}about/versions/marshmallow/android-6.0.html#adoptable-storage\">\n     *     Adoptable Storage Devices</a>\n     ",
    "links" : [ "#wipeData(int)" ]
  }, {
    "name" : "WIPE_RESET_PROTECTION_DATA",
    "type" : "int",
    "comment" : "\n     * Flag for {@link #wipeData(int)}: also erase the factory reset protection\n     * data.\n     *\n     * <p>This flag may only be set by device owner admins; if it is set by\n     * other admins a {@link SecurityException} will be thrown.\n     ",
    "links" : [ "#wipeData(int)", "SecurityException" ]
  }, {
    "name" : "WIPE_EUICC",
    "type" : "int",
    "comment" : "\n     * Flag for {@link #wipeData(int)}: also erase the device's eUICC data.\n     ",
    "links" : [ "#wipeData(int)" ]
  }, {
    "name" : "WIPE_SILENTLY",
    "type" : "int",
    "comment" : "\n     * Flag for {@link #wipeData(int)}: won't show reason for wiping to the user.\n     ",
    "links" : [ "#wipeData(int)" ]
  }, {
    "name" : "ENCRYPTION_STATUS_UNSUPPORTED",
    "type" : "int",
    "comment" : "\n     * Result code for {@link #setStorageEncryption} and {@link #getStorageEncryptionStatus}:\n     * indicating that encryption is not supported.\n     ",
    "links" : [ "#setStorageEncryption", "#getStorageEncryptionStatus" ]
  }, {
    "name" : "ENCRYPTION_STATUS_INACTIVE",
    "type" : "int",
    "comment" : "\n     * Result code for {@link #setStorageEncryption} and {@link #getStorageEncryptionStatus}:\n     * indicating that encryption is supported, but is not currently active.\n     * <p>\n     * {@link #getStorageEncryptionStatus} can only return this value on devices that use Full Disk\n     * Encryption.  Support for Full Disk Encryption was entirely removed in API level 33, having\n     * been replaced by File Based Encryption.  Devices that use File Based Encryption always\n     * automatically activate their encryption on first boot.\n     * <p>\n     * {@link #setStorageEncryption} can still return this value for an unrelated reason, but {@link\n     * #setStorageEncryption} is deprecated since it doesn't do anything useful.\n     ",
    "links" : [ "#setStorageEncryption", "#getStorageEncryptionStatus" ]
  }, {
    "name" : "ENCRYPTION_STATUS_ACTIVATING",
    "type" : "int",
    "comment" : "\n     * Result code for {@link #getStorageEncryptionStatus}: indicating that encryption is not\n     * currently active, but is currently being activated.\n     * <p>\n     * @deprecated This result code has never actually been used, so there is no reason for apps to\n     * check for it.\n     ",
    "links" : [ "#getStorageEncryptionStatus" ]
  }, {
    "name" : "ENCRYPTION_STATUS_ACTIVE",
    "type" : "int",
    "comment" : "\n     * Result code for {@link #setStorageEncryption} and {@link #getStorageEncryptionStatus}:\n     * indicating that encryption is active.\n     * <p>\n     * {@link #getStorageEncryptionStatus} can only return this value for apps targeting API level\n     * 23 or lower, or on devices that use Full Disk Encryption.  Support for Full Disk Encryption\n     * was entirely removed in API level 33, having been replaced by File Based Encryption.  The\n     * result code {@link #ENCRYPTION_STATUS_ACTIVE_PER_USER} is used on devices that use File Based\n     * Encryption, except when the app targets API level 23 or lower.\n     * <p>\n     * {@link #setStorageEncryption} can still return this value for an unrelated reason, but {@link\n     * #setStorageEncryption} is deprecated since it doesn't do anything useful.\n     ",
    "links" : [ "#setStorageEncryption", "#getStorageEncryptionStatus", "#ENCRYPTION_STATUS_ACTIVE_PER_USER" ]
  }, {
    "name" : "ENCRYPTION_STATUS_ACTIVE_DEFAULT_KEY",
    "type" : "int",
    "comment" : "\n     * Result code for {@link #getStorageEncryptionStatus}: indicating that encryption is active,\n     * but the encryption key is not cryptographically protected by the user's credentials.\n     * <p>\n     * This value can only be returned on devices that use Full Disk Encryption.  Support for Full\n     * Disk Encryption was entirely removed in API level 33, having been replaced by File Based\n     * Encryption.  With File Based Encryption, each user's credential-encrypted storage is always\n     * cryptographically protected by the user's credentials.\n     ",
    "links" : [ "#getStorageEncryptionStatus" ]
  }, {
    "name" : "ENCRYPTION_STATUS_ACTIVE_PER_USER",
    "type" : "int",
    "comment" : "\n     * Result code for {@link #getStorageEncryptionStatus}:\n     * indicating that encryption is active and the encryption key is tied to the user or profile.\n     * <p>\n     * This value is only returned to apps targeting API level 24 and above. For apps targeting\n     * earlier API levels, {@link #ENCRYPTION_STATUS_ACTIVE} is returned, even if the\n     * encryption key is specific to the user or profile.\n     ",
    "links" : [ "#ENCRYPTION_STATUS_ACTIVE", "#getStorageEncryptionStatus" ]
  }, {
    "name" : "ACTION_START_ENCRYPTION",
    "type" : "String",
    "comment" : "\n     * Activity action: begin the process of encrypting data on the device.  This activity should\n     * be launched after using {@link #setStorageEncryption} to request encryption be activated.\n     * After resuming from this activity, use {@link #getStorageEncryption}\n     * to check encryption status.  However, on some devices this activity may never return, as\n     * it may trigger a reboot and in some cases a complete data wipe of the device.\n     ",
    "links" : [ "#getStorageEncryption", "#setStorageEncryption" ]
  }, {
    "name" : "ACTION_CHECK_POLICY_COMPLIANCE",
    "type" : "String",
    "comment" : "\n     * Activity action: launch the DPC to check policy compliance. This intent is launched when\n     * the user taps on the notification about personal apps suspension. When handling this intent\n     * the DPC must check if personal apps should still be suspended and either unsuspend them or\n     * instruct the user on how to resolve the noncompliance causing the suspension.\n     *\n     * @see #setPersonalAppsSuspended\n     ",
    "links" : [ ]
  }, {
    "name" : "ACTION_PROVISIONING_COMPLETED",
    "type" : "String",
    "comment" : "\n     * Broadcast action: notify managed provisioning that PO/DO provisioning has completed.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "EXTRA_PROVISIONING_ACTION",
    "type" : "String",
    "comment" : "\n     * Extra for {@link #ACTION_PROVISIONING_COMPLETED} to indicate the provisioning action that has\n     * been completed, this can either be {@link #ACTION_PROVISION_MANAGED_PROFILE},\n     * {@link #ACTION_PROVISION_MANAGED_DEVICE}, or {@link #ACTION_PROVISION_MANAGED_USER}.\n     *\n     * @hide\n     ",
    "links" : [ "#ACTION_PROVISION_MANAGED_DEVICE", "#ACTION_PROVISIONING_COMPLETED", "#ACTION_PROVISION_MANAGED_PROFILE", "#ACTION_PROVISION_MANAGED_USER" ]
  }, {
    "name" : "ACTION_SHOW_NEW_USER_DISCLAIMER",
    "type" : "String",
    "comment" : "\n     * Broadcast action: notify system that a new (Android) user was added when the device is\n     * managed by a device owner, so receivers can show the proper disclaimer to the (human) user.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "KEYGUARD_DISABLE_FEATURES_NONE",
    "type" : "int",
    "comment" : "\n     * Widgets are enabled in keyguard\n     ",
    "links" : [ ]
  }, {
    "name" : "KEYGUARD_DISABLE_WIDGETS_ALL",
    "type" : "int",
    "comment" : "\n     * Disable all keyguard widgets. Has no effect between {@link\n     * android.os.Build.VERSION_CODES#LOLLIPOP} and {@link\n     * android.os.Build.VERSION_CODES#UPSIDE_DOWN_CAKE} (both inclusive), since keyguard widget is\n     * only supported on Android versions lower than 5.0 and versions higher than 14.\n     ",
    "links" : [ "android.os.Build.VERSION_CODES#LOLLIPOP", "android.os.Build.VERSION_CODES#UPSIDE_DOWN_CAKE" ]
  }, {
    "name" : "KEYGUARD_DISABLE_SECURE_CAMERA",
    "type" : "int",
    "comment" : "\n     * Disable the camera on secure keyguard screens (e.g. PIN/Pattern/Password)\n     ",
    "links" : [ ]
  }, {
    "name" : "KEYGUARD_DISABLE_SECURE_NOTIFICATIONS",
    "type" : "int",
    "comment" : "\n     * Disable showing all notifications on secure keyguard screens (e.g. PIN/Pattern/Password)\n     ",
    "links" : [ ]
  }, {
    "name" : "KEYGUARD_DISABLE_UNREDACTED_NOTIFICATIONS",
    "type" : "int",
    "comment" : "\n     * Only allow redacted notifications on secure keyguard screens (e.g. PIN/Pattern/Password)\n     ",
    "links" : [ ]
  }, {
    "name" : "KEYGUARD_DISABLE_TRUST_AGENTS",
    "type" : "int",
    "comment" : "\n     * Disable trust agents on secure keyguard screens (e.g. PIN/Pattern/Password).\n     * By setting this flag alone, all trust agents are disabled. If the admin then wants to\n     * allowlist specific features of some trust agent, {@link #setTrustAgentConfiguration} can be\n     * used in conjuction to set trust-agent-specific configurations.\n     ",
    "links" : [ "#setTrustAgentConfiguration" ]
  }, {
    "name" : "KEYGUARD_DISABLE_FINGERPRINT",
    "type" : "int",
    "comment" : "\n     * Disable fingerprint authentication on keyguard secure screens (e.g. PIN/Pattern/Password).\n     ",
    "links" : [ ]
  }, {
    "name" : "KEYGUARD_DISABLE_REMOTE_INPUT",
    "type" : "int",
    "comment" : "\n     * Disable text entry into notifications on secure keyguard screens (e.g. PIN/Pattern/Password).\n     * @deprecated This flag was added in version {@link android.os.Build.VERSION_CODES#N}, but it\n     * never had any effect.\n     ",
    "links" : [ "android.os.Build.VERSION_CODES#N" ]
  }, {
    "name" : "KEYGUARD_DISABLE_FACE",
    "type" : "int",
    "comment" : "\n     * Disable face authentication on keyguard secure screens (e.g. PIN/Pattern/Password).\n     ",
    "links" : [ ]
  }, {
    "name" : "KEYGUARD_DISABLE_IRIS",
    "type" : "int",
    "comment" : "\n     * Disable iris authentication on keyguard secure screens (e.g. PIN/Pattern/Password).\n     ",
    "links" : [ ]
  }, {
    "name" : "KEYGUARD_DISABLE_SHORTCUTS_ALL",
    "type" : "int",
    "comment" : "\n     * Disable all keyguard shortcuts.\n     ",
    "links" : [ ]
  }, {
    "name" : "KEYGUARD_DISABLE_BIOMETRICS",
    "type" : "int",
    "comment" : "\n     * Disable all biometric authentication on keyguard secure screens (e.g. PIN/Pattern/Password).\n     ",
    "links" : [ ]
  }, {
    "name" : "KEYGUARD_DISABLE_FEATURES_ALL",
    "type" : "int",
    "comment" : "\n     * Disable all current and future keyguard customizations.\n     ",
    "links" : [ ]
  }, {
    "name" : "NON_ORG_OWNED_PROFILE_KEYGUARD_FEATURES_AFFECT_OWNER",
    "type" : "int",
    "comment" : "\n     * Keyguard features that when set on a non-organization-owned managed profile that doesn't\n     * have its own challenge will affect the profile's parent user. These can also be set on the\n     * managed profile's parent {@link DevicePolicyManager} instance to explicitly control the\n     * parent user.\n     *\n     * <p>\n     * Organization-owned managed profile supports disabling additional keyguard features on the\n     * parent user as defined in {@link #ORG_OWNED_PROFILE_KEYGUARD_FEATURES_PARENT_ONLY}.\n     *\n     * @hide\n     ",
    "links" : [ "#ORG_OWNED_PROFILE_KEYGUARD_FEATURES_PARENT_ONLY", "android.app.admin.DevicePolicyManager" ]
  }, {
    "name" : "ORG_OWNED_PROFILE_KEYGUARD_FEATURES_PARENT_ONLY",
    "type" : "int",
    "comment" : "\n     * Keyguard features that when set by the profile owner of an organization-owned managed\n     * profile will affect the profile's parent user if set on the managed profile's parent\n     * {@link DevicePolicyManager} instance.\n     *\n     * @hide\n     ",
    "links" : [ "android.app.admin.DevicePolicyManager" ]
  }, {
    "name" : "PROFILE_KEYGUARD_FEATURES_AFFECT_OWNER",
    "type" : "int",
    "comment" : "\n     * Keyguard features that when set on a normal or organization-owned managed profile, have\n     * the potential to affect the profile's parent user.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "ERROR_VPN_PACKAGE_NOT_FOUND",
    "type" : "int",
    "comment" : "\n     * Service-specific error code used in implementation of {@code setAlwaysOnVpnPackage} methods.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "mGetKeyGuardDisabledFeaturesCache",
    "type" : "IpcDataCache<Pair<ComponentName, Integer>, Integer>",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "IS_DEVICE_OWNER_USER_AWARE",
    "type" : "long",
    "comment" : "\n     * For apps targeting {@link Build.VERSION_CODES#VANILLA_ICE_CREAM} and above, the\n     * {@link #isDeviceOwnerApp} method will use the user contained within the\n     * context.\n     * For apps targeting an SDK version <em>below</em> this, the user of the calling process will\n     * be used (Process.myUserHandle()).\n     *\n     * @hide\n     ",
    "links" : [ "Build.VERSION_CODES#VANILLA_ICE_CREAM", "#isDeviceOwnerApp" ]
  }, {
    "name" : "mHasDeviceOwnerCache",
    "type" : "IpcDataCache<Void, Boolean>",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mGetProfileOwnerOrDeviceOwnerSupervisionComponentCache",
    "type" : "IpcDataCache<UserHandle, ComponentName>",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mIsOrganizationOwnedDeviceWithManagedProfileCache",
    "type" : "IpcDataCache<Void, Boolean>",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "SKIP_SETUP_WIZARD",
    "type" : "int",
    "comment" : "\n      * Flag used by {@link #createAndManageUser} to skip setup wizard after creating a new user.\n      ",
    "links" : [ "#createAndManageUser" ]
  }, {
    "name" : "MAKE_USER_EPHEMERAL",
    "type" : "int",
    "comment" : "\n     * Flag used by {@link #createAndManageUser} to specify that the user should be created\n     * ephemeral. Ephemeral users will be removed after switching to another user or rebooting the\n     * device.\n     ",
    "links" : [ "#createAndManageUser" ]
  }, {
    "name" : "MAKE_USER_DEMO",
    "type" : "int",
    "comment" : "\n     * Flag used by {@link #createAndManageUser} to specify that the user should be created as a\n     * demo user.\n     * @hide\n     ",
    "links" : [ "#createAndManageUser" ]
  }, {
    "name" : "LEAVE_ALL_SYSTEM_APPS_ENABLED",
    "type" : "int",
    "comment" : "\n     * Flag used by {@link #createAndManageUser} to specify that the newly created user should skip\n     * the disabling of system apps during provisioning.\n     ",
    "links" : [ "#createAndManageUser" ]
  }, {
    "name" : "mGetDeviceOwnerOrganizationNameCache",
    "type" : "IpcDataCache<Void, CharSequence>",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mGetOrganizationNameForUserCache",
    "type" : "IpcDataCache<Integer, CharSequence>",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mIsNetworkLoggingEnabledCache",
    "type" : "IpcDataCache<ComponentName, Boolean>",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "ERROR_PACKAGE_NAME_NOT_FOUND",
    "type" : "int",
    "comment" : "\n     * Service-specific error code used in {@link #setApplicationExemptions(String, Set)} and\n     * {@link #getApplicationExemptions(String)}.\n     * @hide\n     ",
    "links" : [ "#setApplicationExemptions(String", "#getApplicationExemptions(String)" ]
  } ],
  "methods" : [ {
    "name" : "private IDevicePolicyManager getService()",
    "returnType" : "IDevicePolicyManager",
    "comment" : "\n     * Fetch the current value of mService.  This is used in the binder cache lambda\n     * expressions.\n     ",
    "links" : [ ]
  }, {
    "name" : "private boolean isParentInstance()",
    "returnType" : "boolean",
    "comment" : "\n     * Fetch the current value of mParentInstance.  This is used in the binder cache\n     * lambda expressions.\n     ",
    "links" : [ ]
  }, {
    "name" : "private Context getContext()",
    "returnType" : "Context",
    "comment" : "\n     * Fetch the current value of mContext.  This is used in the binder cache lambda\n     * expressions.\n     ",
    "links" : [ ]
  }, {
    "name" : "protected int myUserId()",
    "returnType" : "int",
    "comment" : " @hide test will override it. ",
    "links" : [ ]
  }, {
    "name" : "public static String operationToString(@DevicePolicyOperation int operation)",
    "returnType" : "String",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "public void setMtePolicy(@MtePolicy int policy)",
    "returnType" : "void",
    "comment" : "\n     * Called by a device owner, profile owner of an organization-owned device, to set the Memory\n     * Tagging Extension (MTE) policy. MTE is a CPU extension that allows to protect against certain\n     * classes of security problems at a small runtime performance cost overhead.\n     *\n     * <p>The MTE policy can only be set to {@link #MTE_DISABLED} if called by a device owner.\n     * Otherwise a {@link SecurityException} will be thrown.\n     *\n     * <p>The device needs to be rebooted to apply changes to the MTE policy.\n     *\n     * @throws SecurityException if caller is not permitted to set Mte policy\n     * @throws UnsupportedOperationException if the device does not support MTE\n     * @param policy the MTE policy to be set\n     ",
    "links" : [ "#MTE_DISABLED", "SecurityException" ]
  }, {
    "name" : "public int getMtePolicy()",
    "returnType" : "int",
    "comment" : "\n     * Called by a device owner, profile owner of an organization-owned device to\n     * get the Memory Tagging Extension (MTE) policy\n     *\n     * <a href=\"https://source.android.com/docs/security/test/memory-safety/arm-mte\">\n     * Learn more about MTE</a>\n     *\n     * @throws SecurityException if caller is not permitted to set Mte policy\n     * @return the currently set MTE policy\n     ",
    "links" : [ ]
  }, {
    "name" : "public static boolean isMtePolicyEnforced()",
    "returnType" : "boolean",
    "comment" : "\n     * Get the current MTE state of the device.\n     *\n     * <a href=\"https://source.android.com/docs/security/test/memory-safety/arm-mte\">\n     * Learn more about MTE</a>\n     *\n     * @return whether MTE is currently enabled on the device.\n     ",
    "links" : [ ]
  }, {
    "name" : "public void setContentProtectionPolicy(@Nullable ComponentName admin, @ContentProtectionPolicy int policy)",
    "returnType" : "void",
    "comment" : "\n     * Sets the content protection policy which controls scanning for deceptive apps.\n     * <p>\n     * This function can only be called by the device owner, a profile owner of an affiliated user\n     * or profile, or the profile owner when no device owner is set or holders of the permission\n     * {@link android.Manifest.permission#MANAGE_DEVICE_POLICY_CONTENT_PROTECTION}. See\n     * {@link #isAffiliatedUser}.\n     * Any policy set via this method will be cleared if the user becomes unaffiliated.\n     * <p>\n     * After the content protection policy has been set,\n     * {@link PolicyUpdateReceiver#onPolicySetResult(Context, String, Bundle, TargetUser,\n     * PolicyUpdateResult)} will notify the admin on whether the policy was successfully set or not.\n     * This callback will contain:\n     * <ul>\n     * <li> The policy identifier {@link DevicePolicyIdentifiers#CONTENT_PROTECTION_POLICY}\n     * <li> The {@link TargetUser} that this policy relates to\n     * <li> The {@link PolicyUpdateResult}, which will be\n     * {@link PolicyUpdateResult#RESULT_POLICY_SET} if the policy was successfully set or the\n     * reason the policy failed to be set\n     * (e.g. {@link PolicyUpdateResult#RESULT_FAILURE_CONFLICTING_ADMIN_POLICY})\n     * </ul>\n     * If there has been a change to the policy,\n     * {@link PolicyUpdateReceiver#onPolicyChanged(Context, String, Bundle, TargetUser,\n     * PolicyUpdateResult)} will notify the admin of this change. This callback will contain the\n     * same parameters as PolicyUpdateReceiver#onPolicySetResult and the {@link PolicyUpdateResult}\n     * will contain the reason why the policy changed.\n     *\n     * @param admin Which {@link DeviceAdminReceiver} this request is associated with. Null if the\n     *               caller is not a device admin.\n     * @param policy The content protection policy to set. One of {@link\n     *               #CONTENT_PROTECTION_NOT_CONTROLLED_BY_POLICY},\n     *               {@link #CONTENT_PROTECTION_DISABLED} or {@link #CONTENT_PROTECTION_ENABLED}.\n     * @throws SecurityException if {@code admin} is not the device owner, the profile owner of an\n     * affiliated user or profile, or the profile owner when no device owner is set or holder of the\n     * permission {@link android.Manifest.permission#MANAGE_DEVICE_POLICY_CONTENT_PROTECTION}.\n     * @see #isAffiliatedUser\n     ",
    "links" : [ "#isAffiliatedUser", "android.app.admin.PolicyUpdateResult#RESULT_FAILURE_CONFLICTING_ADMIN_POLICY", "android.app.admin.PolicyUpdateResult#RESULT_POLICY_SET", "android.app.admin.DevicePolicyIdentifiers#CONTENT_PROTECTION_POLICY", "#CONTENT_PROTECTION_NOT_CONTROLLED_BY_POLICY", "android.app.admin.PolicyUpdateReceiver#onPolicyChanged(Context", "android.app.admin.PolicyUpdateReceiver#onPolicySetResult(Context", "android.app.admin.TargetUser", "android.app.admin.PolicyUpdateResult", "android.app.admin.DeviceAdminReceiver", "android.Manifest.permission#MANAGE_DEVICE_POLICY_CONTENT_PROTECTION", "#CONTENT_PROTECTION_DISABLED", "#CONTENT_PROTECTION_ENABLED" ]
  }, {
    "name" : "public int getContentProtectionPolicy(@Nullable ComponentName admin)",
    "returnType" : "int",
    "comment" : "\n     * Returns the current content protection policy.\n     * <p>\n     * The returned policy will be the current resolved policy rather than the policy set by the\n     * calling admin.\n     *\n     * @param admin Which {@link DeviceAdminReceiver} this request is associated with. Null if the\n     *              caller is not a device admin.\n     * @throws SecurityException if {@code admin} is not the device owner, the profile owner of an\n     * affiliated user or profile, or the profile owner when no device owner is set or holder of the\n     * permission {@link android.Manifest.permission#MANAGE_DEVICE_POLICY_CONTENT_PROTECTION}.\n     * @see #isAffiliatedUser\n     * @see #setContentProtectionPolicy\n     ",
    "links" : [ "android.app.admin.DeviceAdminReceiver", "android.Manifest.permission#MANAGE_DEVICE_POLICY_CONTENT_PROTECTION" ]
  }, {
    "name" : "public static void invalidateBinderCaches()",
    "returnType" : "void",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "public static void disableLocalCaches()",
    "returnType" : "void",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "public static String operationSafetyReasonToString(@OperationSafetyReason int reason)",
    "returnType" : "String",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "public static boolean isValidOperationSafetyReason(@OperationSafetyReason int reason)",
    "returnType" : "boolean",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "public boolean isSafeOperation(@OperationSafetyReason int reason)",
    "returnType" : "boolean",
    "comment" : " TODO(b/173541467): should it throw SecurityException if caller is not admin?",
    "links" : [ ]
  }, {
    "name" : "public void acknowledgeNewUserDisclaimer()",
    "returnType" : "void",
    "comment" : "\n     * Acknoledges that the new managed user disclaimer was viewed by the (human) user\n     * so that {@link #ACTION_SHOW_NEW_USER_DISCLAIMER broadcast} is not sent again the next time\n     * this user is switched to.\n     *\n     * @hide\n     ",
    "links" : [ "#ACTION_SHOW_NEW_USER_DISCLAIMER" ]
  }, {
    "name" : "public boolean isNewUserDisclaimerAcknowledged()",
    "returnType" : "boolean",
    "comment" : "\n     * Checks whether the new managed user disclaimer was viewed by the user.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean isAdminActive(@NonNull ComponentName admin)",
    "returnType" : "boolean",
    "comment" : "\n     * Return true if the given administrator component is currently active (enabled) in the system.\n     *\n     * @param admin The administrator component to check for.\n     * @return {@code true} if {@code admin} is currently enabled in the system, {@code false}\n     *         otherwise\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean isAdminActiveAsUser(@NonNull ComponentName admin, int userId)",
    "returnType" : "boolean",
    "comment" : "\n     * @see #isAdminActive(ComponentName)\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean isRemovingAdmin(@NonNull ComponentName admin, int userId)",
    "returnType" : "boolean",
    "comment" : "\n     * Return true if the given administrator component is currently being removed\n     * for the user.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public List<ComponentName> getActiveAdmins()",
    "returnType" : "List<ComponentName>",
    "comment" : "\n     * Return a list of all currently active device administrators' component\n     * names.  If there are no administrators {@code null} may be\n     * returned.\n     ",
    "links" : [ ]
  }, {
    "name" : "public List<ComponentName> getActiveAdminsAsUser(int userId)",
    "returnType" : "List<ComponentName>",
    "comment" : "\n     * @see #getActiveAdmins()\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean packageHasActiveAdmins(String packageName)",
    "returnType" : "boolean",
    "comment" : "\n     * Used by package administration code to determine if a package can be stopped\n     * or uninstalled.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean packageHasActiveAdmins(String packageName, int userId)",
    "returnType" : "boolean",
    "comment" : "\n     * Used by package administration code to determine if a package can be stopped\n     * or uninstalled.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public void removeActiveAdmin(@NonNull ComponentName admin)",
    "returnType" : "void",
    "comment" : "\n     * Remove a current administration component.  This can only be called\n     * by the application that owns the administration component; if you\n     * try to remove someone else's component, a security exception will be\n     * thrown.\n     *\n     * <p>Note that the operation is not synchronous and the admin might still be active (as\n     * indicated by {@link #getActiveAdmins()}) by the time this method returns.\n     *\n     * @param admin The administration compononent to remove.\n     * @throws SecurityException if the caller is not in the owner application of {@code admin}.\n     ",
    "links" : [ "#getActiveAdmins()" ]
  }, {
    "name" : "public boolean hasGrantedPolicy(@NonNull ComponentName admin, int usesPolicy)",
    "returnType" : "boolean",
    "comment" : "\n     * Returns true if an administrator has been granted a particular device policy. This can be\n     * used to check whether the administrator was activated under an earlier set of policies, but\n     * requires additional policies after an upgrade.\n     *\n     * @param admin Which {@link DeviceAdminReceiver} this request is associated with. Must be an\n     *            active administrator, or an exception will be thrown.\n     * @param usesPolicy Which uses-policy to check, as defined in {@link DeviceAdminInfo}.\n     * @throws SecurityException if {@code admin} is not an active administrator.\n     ",
    "links" : [ "android.app.admin.DeviceAdminReceiver", "android.app.admin.DeviceAdminInfo" ]
  }, {
    "name" : "public void setPasswordQuality(@NonNull ComponentName admin, int quality)",
    "returnType" : "void",
    "comment" : "\n     * Called by an application that is administering the device to set the password restrictions it\n     * is imposing. After setting this, the user will not be able to enter a new password that is\n     * not at least as restrictive as what has been set. Note that the current password will remain\n     * until the user has set a new one, so the change does not take place immediately. To prompt\n     * the user for a new password, use {@link #ACTION_SET_NEW_PASSWORD} or\n     * {@link #ACTION_SET_NEW_PARENT_PROFILE_PASSWORD} after calling this method.\n     * <p>\n     * Quality constants are ordered so that higher values are more restrictive; thus the highest\n     * requested quality constant (between the policy set here, the user's preference, and any other\n     * considerations) is the one that is in effect.\n     * <p>\n     * On devices not supporting {@link PackageManager#FEATURE_SECURE_LOCK_SCREEN} feature, the\n     * password is always treated as empty.\n     * <p>\n     * The calling device admin must have requested\n     * {@link DeviceAdminInfo#USES_POLICY_LIMIT_PASSWORD} to be able to call this method; if it has\n     * not, a security exception will be thrown.\n     * <p>\n     * Apps targeting {@link android.os.Build.VERSION_CODES#R} and below can call this method on the\n     * {@link DevicePolicyManager} instance returned by\n     * {@link #getParentProfileInstance(ComponentName)} in order to set restrictions on the parent\n     * profile. Apps targeting {@link android.os.Build.VERSION_CODES#S} and above, with the\n     * exception of a profile owner on an organization-owned device (as can be identified by\n     * {@link #isOrganizationOwnedDeviceWithManagedProfile}), will get a\n     * {@code IllegalArgumentException} when calling this method on the parent\n     * {@link DevicePolicyManager} instance.\n     *\n     * <p><strong>Note:</strong> Specifying password requirements using this method clears the\n     * password complexity requirements set using {@link #setRequiredPasswordComplexity(int)}.\n     * If this method is called on the {@link DevicePolicyManager} instance returned by\n     * {@link #getParentProfileInstance(ComponentName)}, then password complexity requirements\n     * set on the primary {@link DevicePolicyManager} must be cleared first by calling\n     * {@link #setRequiredPasswordComplexity} with {@link #PASSWORD_COMPLEXITY_NONE) first.\n     *\n     * <p><string>Note:</strong> this method is ignored on\n     * {PackageManager#FEATURE_AUTOMOTIVE automotive builds}.\n     *\n     * @deprecated Prefer using {@link #setRequiredPasswordComplexity(int)}, to require a password\n     * that satisfies a complexity level defined by the platform, rather than specifying custom\n     * password requirement.\n     * Setting custom, overly-complicated password requirements leads to passwords that are hard\n     * for users to remember and may not provide any security benefits given as Android uses\n     * hardware-backed throttling to thwart online and offline brute-forcing of the device's\n     * screen lock. Company-owned devices (fully-managed and organization-owned managed profile\n     * devices) are able to continue using this method, though it is recommended that\n     * {@link #setRequiredPasswordComplexity(int)} should be used instead.\n     *\n     * @param admin Which {@link DeviceAdminReceiver} this request is associated with.\n     * @param quality The new desired quality. One of {@link #PASSWORD_QUALITY_UNSPECIFIED},\n     *            {@link #PASSWORD_QUALITY_BIOMETRIC_WEAK},\n     *            {@link #PASSWORD_QUALITY_SOMETHING}, {@link #PASSWORD_QUALITY_NUMERIC},\n     *            {@link #PASSWORD_QUALITY_NUMERIC_COMPLEX}, {@link #PASSWORD_QUALITY_ALPHABETIC},\n     *            {@link #PASSWORD_QUALITY_ALPHANUMERIC} or {@link #PASSWORD_QUALITY_COMPLEX}.\n     * @throws SecurityException if {@code admin} is not an active administrator, if {@code admin}\n     *             does not use {@link DeviceAdminInfo#USES_POLICY_LIMIT_PASSWORD} or if the\n     *             calling app is targeting {@link android.os.Build.VERSION_CODES#S} and above,\n     *             and is calling the method the {@link DevicePolicyManager} instance returned by\n     *             {@link #getParentProfileInstance(ComponentName)}.\n     * @throws IllegalStateException if the caller is trying to set password quality on the parent\n     *             {@link DevicePolicyManager} instance while password complexity was set on the\n     *             primary {@link DevicePolicyManager} instance.\n     ",
    "links" : [ "#isOrganizationOwnedDeviceWithManagedProfile", "#PASSWORD_COMPLEXITY_NONE)", "#ACTION_SET_NEW_PASSWORD", "android.content.pm.PackageManager#FEATURE_SECURE_LOCK_SCREEN", "#PASSWORD_QUALITY_ALPHANUMERIC", "#PASSWORD_QUALITY_BIOMETRIC_WEAK", "#setRequiredPasswordComplexity(int)", "#ACTION_SET_NEW_PARENT_PROFILE_PASSWORD", "#PASSWORD_QUALITY_COMPLEX", "#getParentProfileInstance(ComponentName)", "#PASSWORD_QUALITY_NUMERIC", "android.os.Build.VERSION_CODES#R", "android.app.admin.DeviceAdminReceiver", "#PASSWORD_QUALITY_SOMETHING", "android.os.Build.VERSION_CODES#S", "#PASSWORD_QUALITY_NUMERIC_COMPLEX", "android.app.admin.DeviceAdminInfo#USES_POLICY_LIMIT_PASSWORD", "android.app.admin.DevicePolicyManager", "#setRequiredPasswordComplexity", "#PASSWORD_QUALITY_UNSPECIFIED", "#PASSWORD_QUALITY_ALPHABETIC" ]
  }, {
    "name" : "public int getPasswordQuality(@Nullable ComponentName admin)",
    "returnType" : "int",
    "comment" : "\n     * Retrieve the current minimum password quality for a particular admin or all admins that set\n     * restrictions on this user and its participating profiles. Restrictions on profiles that have\n     * a separate challenge are not taken into account.\n     *\n     * <p>This method can be called on the {@link DevicePolicyManager} instance\n     * returned by {@link #getParentProfileInstance(ComponentName)} in order to retrieve\n     * restrictions on the parent profile.\n     *\n     * <p>Note: on devices not supporting {@link PackageManager#FEATURE_SECURE_LOCK_SCREEN} feature,\n     * the password is always treated as empty.\n     *\n     * @deprecated see {@link #setPasswordQuality(ComponentName, int)} for details.\n     *\n     * @param admin The name of the admin component to check, or {@code null} to aggregate\n     * all admins.\n     ",
    "links" : [ "#getParentProfileInstance(ComponentName)", "#setPasswordQuality(ComponentName", "android.content.pm.PackageManager#FEATURE_SECURE_LOCK_SCREEN", "android.app.admin.DevicePolicyManager" ]
  }, {
    "name" : "public int getPasswordQuality(@Nullable ComponentName admin, int userHandle)",
    "returnType" : "int",
    "comment" : " @hide per-user version ",
    "links" : [ ]
  }, {
    "name" : "public void setPasswordMinimumLength(@NonNull ComponentName admin, int length)",
    "returnType" : "void",
    "comment" : "\n     * Called by an application that is administering the device to set the minimum allowed password\n     * length. After setting this, the user will not be able to enter a new password that is not at\n     * least as restrictive as what has been set. Note that the current password will remain until\n     * the user has set a new one, so the change does not take place immediately. To prompt the user\n     * for a new password, use {@link #ACTION_SET_NEW_PASSWORD} or\n     * {@link #ACTION_SET_NEW_PARENT_PROFILE_PASSWORD} after setting this value. This constraint is\n     * only imposed if the administrator has also requested either {@link #PASSWORD_QUALITY_NUMERIC}\n     * , {@link #PASSWORD_QUALITY_NUMERIC_COMPLEX}, {@link #PASSWORD_QUALITY_ALPHABETIC},\n     * {@link #PASSWORD_QUALITY_ALPHANUMERIC}, or {@link #PASSWORD_QUALITY_COMPLEX} with\n     * {@link #setPasswordQuality}. If an app targeting SDK level\n     * {@link android.os.Build.VERSION_CODES#R} and above enforces this constraint without settings\n     * password quality to one of these values first, this method will throw\n     * {@link IllegalStateException}.\n     * <p>\n     * On devices not supporting {@link PackageManager#FEATURE_SECURE_LOCK_SCREEN} feature, the\n     * password is always treated as empty.\n     * <p>\n     * The calling device admin must have requested\n     * {@link DeviceAdminInfo#USES_POLICY_LIMIT_PASSWORD} to be able to call this method; if it has\n     * not, a security exception will be thrown.\n     * <p>\n     * Apps targeting {@link android.os.Build.VERSION_CODES#R} and below can call this method on the\n     * {@link DevicePolicyManager} instance returned by\n     * {@link #getParentProfileInstance(ComponentName)} in order to set restrictions on the parent\n     * profile.\n     *\n     * <p><string>Note:</strong> this method is ignored on\n     * {PackageManager#FEATURE_AUTOMOTIVE automotive builds}.\n     *\n     * @deprecated see {@link #setPasswordQuality(ComponentName, int)} for details.\n     *\n     * @param admin Which {@link DeviceAdminReceiver} this request is associated with.\n     * @param length The new desired minimum password length. A value of 0 means there is no\n     *     restriction.\n     * @throws SecurityException if {@code admin} is not an active administrator or {@code admin}\n     *     does not use {@link DeviceAdminInfo#USES_POLICY_LIMIT_PASSWORD}\n     * @throws IllegalStateException if the calling app is targeting SDK level\n     *     {@link android.os.Build.VERSION_CODES#R} and above and didn't set a sufficient password\n     *     quality requirement prior to calling this method.\n     ",
    "links" : [ "IllegalStateException", "#ACTION_SET_NEW_PASSWORD", "#PASSWORD_QUALITY_ALPHANUMERIC", "android.content.pm.PackageManager#FEATURE_SECURE_LOCK_SCREEN", "#ACTION_SET_NEW_PARENT_PROFILE_PASSWORD", "#PASSWORD_QUALITY_COMPLEX", "#PASSWORD_QUALITY_NUMERIC", "#setPasswordQuality", "#getParentProfileInstance(ComponentName)", "#setPasswordQuality(ComponentName", "android.os.Build.VERSION_CODES#R", "android.app.admin.DeviceAdminReceiver", "#PASSWORD_QUALITY_NUMERIC_COMPLEX", "android.app.admin.DeviceAdminInfo#USES_POLICY_LIMIT_PASSWORD", "android.app.admin.DevicePolicyManager", "#PASSWORD_QUALITY_ALPHABETIC" ]
  }, {
    "name" : "public int getPasswordMinimumLength(@Nullable ComponentName admin)",
    "returnType" : "int",
    "comment" : "\n     * Retrieve the current minimum password length for a particular admin or all admins that set\n     * restrictions on this user and its participating profiles. Restrictions on profiles that have\n     * a separate challenge are not taken into account.\n     *\n     * <p>On devices not supporting {@link PackageManager#FEATURE_SECURE_LOCK_SCREEN} feature, the\n     * password is always treated as empty.\n     *\n     * <p>This method can be called on the {@link DevicePolicyManager} instance\n     * returned by {@link #getParentProfileInstance(ComponentName)} in order to retrieve\n     * restrictions on the parent profile.\n     *\n     * @deprecated see {@link #setPasswordQuality(ComponentName, int)} for details.\n     *\n     * @param admin The name of the admin component to check, or {@code null} to aggregate\n     * all admins.\n     ",
    "links" : [ "#getParentProfileInstance(ComponentName)", "#setPasswordQuality(ComponentName", "android.content.pm.PackageManager#FEATURE_SECURE_LOCK_SCREEN", "android.app.admin.DevicePolicyManager" ]
  }, {
    "name" : "public int getPasswordMinimumLength(@Nullable ComponentName admin, int userHandle)",
    "returnType" : "int",
    "comment" : " @hide per-user version ",
    "links" : [ ]
  }, {
    "name" : "public void setPasswordMinimumUpperCase(@NonNull ComponentName admin, int length)",
    "returnType" : "void",
    "comment" : "\n     * Called by an application that is administering the device to set the minimum number of upper\n     * case letters required in the password. After setting this, the user will not be able to enter\n     * a new password that is not at least as restrictive as what has been set. Note that the\n     * current password will remain until the user has set a new one, so the change does not take\n     * place immediately. To prompt the user for a new password, use\n     * {@link #ACTION_SET_NEW_PASSWORD} or {@link #ACTION_SET_NEW_PARENT_PROFILE_PASSWORD} after\n     * setting this value. This constraint is only imposed if the administrator has also requested\n     * {@link #PASSWORD_QUALITY_COMPLEX} with {@link #setPasswordQuality}. If an app targeting\n     * SDK level {@link android.os.Build.VERSION_CODES#R} and above enforces this constraint without\n     * settings password quality to {@link #PASSWORD_QUALITY_COMPLEX} first, this method will throw\n     * {@link IllegalStateException}. The default value is 0.\n     * <p>\n     * On devices not supporting {@link PackageManager#FEATURE_SECURE_LOCK_SCREEN} feature, the\n     * password is always treated as empty.\n     * <p>\n     * The calling device admin must have requested\n     * {@link DeviceAdminInfo#USES_POLICY_LIMIT_PASSWORD} to be able to call this method; if it has\n     * not, a security exception will be thrown.\n     * <p>\n     * Apps targeting {@link android.os.Build.VERSION_CODES#R} and below can call this method on the\n     * {@link DevicePolicyManager} instance returned by\n     * {@link #getParentProfileInstance(ComponentName)} in order to set restrictions on the parent\n     * profile.\n     *\n     * <p><string>Note:</strong> this method is ignored on\n     * {PackageManager#FEATURE_AUTOMOTIVE automotive builds}.\n     *\n     * @deprecated see {@link #setPasswordQuality(ComponentName, int)} for details.\n     *\n     * @param admin Which {@link DeviceAdminReceiver} this request is associated with.\n     * @param length The new desired minimum number of upper case letters required in the password.\n     *            A value of 0 means there is no restriction.\n     * @throws SecurityException if {@code admin} is not an active administrator or {@code admin}\n     *             does not use {@link DeviceAdminInfo#USES_POLICY_LIMIT_PASSWORD}\n     * @throws IllegalStateException if the calling app is targeting SDK level\n     *     {@link android.os.Build.VERSION_CODES#R} and above and didn't set a sufficient password\n     *     quality requirement prior to calling this method.\n     ",
    "links" : [ "#setPasswordQuality", "IllegalStateException", "#getParentProfileInstance(ComponentName)", "#setPasswordQuality(ComponentName", "android.os.Build.VERSION_CODES#R", "android.app.admin.DeviceAdminReceiver", "#ACTION_SET_NEW_PASSWORD", "android.content.pm.PackageManager#FEATURE_SECURE_LOCK_SCREEN", "android.app.admin.DeviceAdminInfo#USES_POLICY_LIMIT_PASSWORD", "android.app.admin.DevicePolicyManager", "#ACTION_SET_NEW_PARENT_PROFILE_PASSWORD", "#PASSWORD_QUALITY_COMPLEX" ]
  }, {
    "name" : "public int getPasswordMinimumUpperCase(@Nullable ComponentName admin)",
    "returnType" : "int",
    "comment" : "\n     * Retrieve the current number of upper case letters required in the password\n     * for a particular admin or all admins that set restrictions on this user and\n     * its participating profiles. Restrictions on profiles that have a separate challenge\n     * are not taken into account.\n     * This is the same value as set by\n     * {@link #setPasswordMinimumUpperCase(ComponentName, int)}\n     * and only applies when the password quality is\n     * {@link #PASSWORD_QUALITY_COMPLEX}.\n     *\n     * <p>On devices not supporting {@link PackageManager#FEATURE_SECURE_LOCK_SCREEN} feature, the\n     * password is always treated as empty.\n     *\n     * <p>This method can be called on the {@link DevicePolicyManager} instance\n     * returned by {@link #getParentProfileInstance(ComponentName)} in order to retrieve\n     * restrictions on the parent profile.\n     *\n     * @deprecated see {@link #setPasswordQuality(ComponentName, int)} for details.\n     *\n     * @param admin The name of the admin component to check, or {@code null} to\n     *            aggregate all admins.\n     * @return The minimum number of upper case letters required in the\n     *         password.\n     ",
    "links" : [ "#getParentProfileInstance(ComponentName)", "#setPasswordQuality(ComponentName", "android.content.pm.PackageManager#FEATURE_SECURE_LOCK_SCREEN", "android.app.admin.DevicePolicyManager", "#setPasswordMinimumUpperCase(ComponentName", "#PASSWORD_QUALITY_COMPLEX" ]
  }, {
    "name" : "public int getPasswordMinimumUpperCase(@Nullable ComponentName admin, int userHandle)",
    "returnType" : "int",
    "comment" : " @hide per-user version ",
    "links" : [ ]
  }, {
    "name" : "public void setPasswordMinimumLowerCase(@NonNull ComponentName admin, int length)",
    "returnType" : "void",
    "comment" : "\n     * Called by an application that is administering the device to set the minimum number of lower\n     * case letters required in the password. After setting this, the user will not be able to enter\n     * a new password that is not at least as restrictive as what has been set. Note that the\n     * current password will remain until the user has set a new one, so the change does not take\n     * place immediately. To prompt the user for a new password, use\n     * {@link #ACTION_SET_NEW_PASSWORD} or {@link #ACTION_SET_NEW_PARENT_PROFILE_PASSWORD} after\n     * setting this value. This constraint is only imposed if the administrator has also requested\n     * {@link #PASSWORD_QUALITY_COMPLEX} with {@link #setPasswordQuality}. If an app targeting\n     * SDK level {@link android.os.Build.VERSION_CODES#R} and above enforces this constraint without\n     * settings password quality to {@link #PASSWORD_QUALITY_COMPLEX} first, this method will throw\n     * {@link IllegalStateException}. The default value is 0.\n     * <p>\n     * On devices not supporting {@link PackageManager#FEATURE_SECURE_LOCK_SCREEN} feature, the\n     * password is always treated as empty.\n     * <p>\n     * The calling device admin must have requested\n     * {@link DeviceAdminInfo#USES_POLICY_LIMIT_PASSWORD} to be able to call this method; if it has\n     * not, a security exception will be thrown.\n     * <p>\n     * Apps targeting {@link android.os.Build.VERSION_CODES#R} and below can call this method on the\n     * {@link DevicePolicyManager} instance returned by\n     * {@link #getParentProfileInstance(ComponentName)} in order to set restrictions on the parent\n     * profile.\n     *\n     * <p><string>Note:</strong> this method is ignored on\n     * {PackageManager#FEATURE_AUTOMOTIVE automotive builds}.\n     *\n     * @deprecated see {@link #setPasswordQuality(ComponentName, int)} for details.\n     *\n     * @param admin Which {@link DeviceAdminReceiver} this request is associated with.\n     * @param length The new desired minimum number of lower case letters required in the password.\n     *            A value of 0 means there is no restriction.\n     * @throws SecurityException if {@code admin} is not an active administrator or {@code admin}\n     *             does not use {@link DeviceAdminInfo#USES_POLICY_LIMIT_PASSWORD}\n     * @throws IllegalStateException if the calling app is targeting SDK level\n     *     {@link android.os.Build.VERSION_CODES#R} and above and didn't set a sufficient password\n     *     quality requirement prior to calling this method.\n     ",
    "links" : [ "#setPasswordQuality", "IllegalStateException", "#getParentProfileInstance(ComponentName)", "#setPasswordQuality(ComponentName", "android.os.Build.VERSION_CODES#R", "android.app.admin.DeviceAdminReceiver", "#ACTION_SET_NEW_PASSWORD", "android.content.pm.PackageManager#FEATURE_SECURE_LOCK_SCREEN", "android.app.admin.DeviceAdminInfo#USES_POLICY_LIMIT_PASSWORD", "android.app.admin.DevicePolicyManager", "#ACTION_SET_NEW_PARENT_PROFILE_PASSWORD", "#PASSWORD_QUALITY_COMPLEX" ]
  }, {
    "name" : "public int getPasswordMinimumLowerCase(@Nullable ComponentName admin)",
    "returnType" : "int",
    "comment" : "\n     * Retrieve the current number of lower case letters required in the password\n     * for a particular admin or all admins that set restrictions on this user\n     * and its participating profiles. Restrictions on profiles that have\n     * a separate challenge are not taken into account.\n     * This is the same value as set by\n     * {@link #setPasswordMinimumLowerCase(ComponentName, int)}\n     * and only applies when the password quality is\n     * {@link #PASSWORD_QUALITY_COMPLEX}.\n     *\n     * <p>On devices not supporting {@link PackageManager#FEATURE_SECURE_LOCK_SCREEN} feature, the\n     * password is always treated as empty.\n     *\n     * <p>This method can be called on the {@link DevicePolicyManager} instance\n     * returned by {@link #getParentProfileInstance(ComponentName)} in order to retrieve\n     * restrictions on the parent profile.\n     *\n     * @deprecated see {@link #setPasswordQuality(ComponentName, int)} for details.\n     *\n     * @param admin The name of the admin component to check, or {@code null} to\n     *            aggregate all admins.\n     * @return The minimum number of lower case letters required in the\n     *         password.\n     ",
    "links" : [ "#getParentProfileInstance(ComponentName)", "#setPasswordQuality(ComponentName", "#setPasswordMinimumLowerCase(ComponentName", "android.content.pm.PackageManager#FEATURE_SECURE_LOCK_SCREEN", "android.app.admin.DevicePolicyManager", "#PASSWORD_QUALITY_COMPLEX" ]
  }, {
    "name" : "public int getPasswordMinimumLowerCase(@Nullable ComponentName admin, int userHandle)",
    "returnType" : "int",
    "comment" : " @hide per-user version ",
    "links" : [ ]
  }, {
    "name" : "public void setPasswordMinimumLetters(@NonNull ComponentName admin, int length)",
    "returnType" : "void",
    "comment" : "\n     * Called by an application that is administering the device to set the minimum number of\n     * letters required in the password. After setting this, the user will not be able to enter a\n     * new password that is not at least as restrictive as what has been set. Note that the current\n     * password will remain until the user has set a new one, so the change does not take place\n     * immediately. To prompt the user for a new password, use {@link #ACTION_SET_NEW_PASSWORD} or\n     * {@link #ACTION_SET_NEW_PARENT_PROFILE_PASSWORD} after setting this value. This constraint is\n     * only imposed if the administrator has also requested {@link #PASSWORD_QUALITY_COMPLEX} with\n     * {@link #setPasswordQuality}. If an app targeting SDK level\n     * {@link android.os.Build.VERSION_CODES#R} and above enforces this constraint without settings\n     * password quality to {@link #PASSWORD_QUALITY_COMPLEX} first, this method will throw\n     * {@link IllegalStateException}. The default value is 1.\n     * <p>\n     * On devices not supporting {@link PackageManager#FEATURE_SECURE_LOCK_SCREEN} feature, the\n     * password is always treated as empty.\n     * <p>\n     * The calling device admin must have requested\n     * {@link DeviceAdminInfo#USES_POLICY_LIMIT_PASSWORD} to be able to call this method; if it has\n     * not, a security exception will be thrown.\n     * <p>\n     * Apps targeting {@link android.os.Build.VERSION_CODES#R} and below can call this method on the\n     * {@link DevicePolicyManager} instance returned by\n     * {@link #getParentProfileInstance(ComponentName)} in order to set restrictions on the parent\n     * profile.\n     *\n     * <p><string>Note:</strong> this method is ignored on\n     * {PackageManager#FEATURE_AUTOMOTIVE automotive builds}.\n     *\n     * @deprecated see {@link #setPasswordQuality(ComponentName, int)} for details.\n     *\n     * @param admin Which {@link DeviceAdminReceiver} this request is associated with.\n     * @param length The new desired minimum number of letters required in the password. A value of\n     *            0 means there is no restriction.\n     * @throws SecurityException if {@code admin} is not an active administrator or {@code admin}\n     *             does not use {@link DeviceAdminInfo#USES_POLICY_LIMIT_PASSWORD}\n     * @throws IllegalStateException if the calling app is targeting SDK level\n     *     {@link android.os.Build.VERSION_CODES#R} and above and didn't set a sufficient password\n     *     quality requirement prior to calling this method.\n     ",
    "links" : [ "#setPasswordQuality", "IllegalStateException", "#getParentProfileInstance(ComponentName)", "#setPasswordQuality(ComponentName", "android.os.Build.VERSION_CODES#R", "android.app.admin.DeviceAdminReceiver", "#ACTION_SET_NEW_PASSWORD", "android.content.pm.PackageManager#FEATURE_SECURE_LOCK_SCREEN", "android.app.admin.DeviceAdminInfo#USES_POLICY_LIMIT_PASSWORD", "android.app.admin.DevicePolicyManager", "#ACTION_SET_NEW_PARENT_PROFILE_PASSWORD", "#PASSWORD_QUALITY_COMPLEX" ]
  }, {
    "name" : "public int getPasswordMinimumLetters(@Nullable ComponentName admin)",
    "returnType" : "int",
    "comment" : "\n     * Retrieve the current number of letters required in the password\n     * for a particular admin or all admins that set restrictions on this user\n     * and its participating profiles. Restrictions on profiles that have\n     * a separate challenge are not taken into account.\n     * This is the same value as set by\n     * {@link #setPasswordMinimumLetters(ComponentName, int)}\n     * and only applies when the password quality is\n     * {@link #PASSWORD_QUALITY_COMPLEX}.\n     *\n     * <p>On devices not supporting {@link PackageManager#FEATURE_SECURE_LOCK_SCREEN} feature, the\n     * password is always treated as empty.\n     *\n     * <p>This method can be called on the {@link DevicePolicyManager} instance\n     * returned by {@link #getParentProfileInstance(ComponentName)} in order to retrieve\n     * restrictions on the parent profile.\n     *\n     * @deprecated see {@link #setPasswordQuality(ComponentName, int)} for details.\n     *\n     * @param admin The name of the admin component to check, or {@code null} to\n     *            aggregate all admins.\n     * @return The minimum number of letters required in the password.\n     ",
    "links" : [ "#getParentProfileInstance(ComponentName)", "#setPasswordQuality(ComponentName", "#setPasswordMinimumLetters(ComponentName", "android.content.pm.PackageManager#FEATURE_SECURE_LOCK_SCREEN", "android.app.admin.DevicePolicyManager", "#PASSWORD_QUALITY_COMPLEX" ]
  }, {
    "name" : "public int getPasswordMinimumLetters(@Nullable ComponentName admin, int userHandle)",
    "returnType" : "int",
    "comment" : " @hide per-user version ",
    "links" : [ ]
  }, {
    "name" : "public void setPasswordMinimumNumeric(@NonNull ComponentName admin, int length)",
    "returnType" : "void",
    "comment" : "\n     * Called by an application that is administering the device to set the minimum number of\n     * numerical digits required in the password. After setting this, the user will not be able to\n     * enter a new password that is not at least as restrictive as what has been set. Note that the\n     * current password will remain until the user has set a new one, so the change does not take\n     * place immediately. To prompt the user for a new password, use\n     * {@link #ACTION_SET_NEW_PASSWORD} or {@link #ACTION_SET_NEW_PARENT_PROFILE_PASSWORD} after\n     * setting this value. This constraint is only imposed if the administrator has also requested\n     * {@link #PASSWORD_QUALITY_COMPLEX} with {@link #setPasswordQuality}. If an app targeting\n     * SDK level {@link android.os.Build.VERSION_CODES#R} and above enforces this constraint without\n     * settings password quality to {@link #PASSWORD_QUALITY_COMPLEX} first, this method will throw\n     * {@link IllegalStateException}. The default value is 1.\n     * <p>\n     * On devices not supporting {@link PackageManager#FEATURE_SECURE_LOCK_SCREEN} feature, the\n     * password is always treated as empty.\n     * <p>\n     * The calling device admin must have requested\n     * {@link DeviceAdminInfo#USES_POLICY_LIMIT_PASSWORD} to be able to call this method; if it has\n     * not, a security exception will be thrown.\n     * <p>\n     * Apps targeting {@link android.os.Build.VERSION_CODES#R} and below can call this method on the\n     * {@link DevicePolicyManager} instance returned by\n     * {@link #getParentProfileInstance(ComponentName)} in order to set restrictions on the parent\n     * profile.\n     *\n     * <p><string>Note:</strong> this method is ignored on\n     * {PackageManager#FEATURE_AUTOMOTIVE automotive builds}.\n     *\n     * @deprecated see {@link #setPasswordQuality(ComponentName, int)} for details.\n     *\n     * @param admin Which {@link DeviceAdminReceiver} this request is associated with.\n     * @param length The new desired minimum number of numerical digits required in the password. A\n     *            value of 0 means there is no restriction.\n     * @throws SecurityException if {@code admin} is not an active administrator or {@code admin}\n     *             does not use {@link DeviceAdminInfo#USES_POLICY_LIMIT_PASSWORD}\n     * @throws IllegalStateException if the calling app is targeting SDK level\n     *     {@link android.os.Build.VERSION_CODES#R} and above and didn't set a sufficient password\n     *     quality requirement prior to calling this method.\n     ",
    "links" : [ "#setPasswordQuality", "IllegalStateException", "#getParentProfileInstance(ComponentName)", "#setPasswordQuality(ComponentName", "android.os.Build.VERSION_CODES#R", "android.app.admin.DeviceAdminReceiver", "#ACTION_SET_NEW_PASSWORD", "android.content.pm.PackageManager#FEATURE_SECURE_LOCK_SCREEN", "android.app.admin.DeviceAdminInfo#USES_POLICY_LIMIT_PASSWORD", "android.app.admin.DevicePolicyManager", "#ACTION_SET_NEW_PARENT_PROFILE_PASSWORD", "#PASSWORD_QUALITY_COMPLEX" ]
  }, {
    "name" : "public int getPasswordMinimumNumeric(@Nullable ComponentName admin)",
    "returnType" : "int",
    "comment" : "\n     * Retrieve the current number of numerical digits required in the password\n     * for a particular admin or all admins that set restrictions on this user\n     * and its participating profiles. Restrictions on profiles that have\n     * a separate challenge are not taken into account.\n     * This is the same value as set by\n     * {@link #setPasswordMinimumNumeric(ComponentName, int)}\n     * and only applies when the password quality is\n     * {@link #PASSWORD_QUALITY_COMPLEX}.\n     *\n     * <p>On devices not supporting {@link PackageManager#FEATURE_SECURE_LOCK_SCREEN} feature, the\n     * password is always treated as empty.\n     *\n     * <p>This method can be called on the {@link DevicePolicyManager} instance\n     * returned by {@link #getParentProfileInstance(ComponentName)} in order to retrieve\n     * restrictions on the parent profile.\n     *\n     * @deprecated see {@link #setPasswordQuality(ComponentName, int)} for details.\n     *\n     * @param admin The name of the admin component to check, or {@code null} to\n     *            aggregate all admins.\n     * @return The minimum number of numerical digits required in the password.\n     ",
    "links" : [ "#getParentProfileInstance(ComponentName)", "#setPasswordQuality(ComponentName", "android.content.pm.PackageManager#FEATURE_SECURE_LOCK_SCREEN", "#setPasswordMinimumNumeric(ComponentName", "android.app.admin.DevicePolicyManager", "#PASSWORD_QUALITY_COMPLEX" ]
  }, {
    "name" : "public int getPasswordMinimumNumeric(@Nullable ComponentName admin, int userHandle)",
    "returnType" : "int",
    "comment" : " @hide per-user version ",
    "links" : [ ]
  }, {
    "name" : "public void setPasswordMinimumSymbols(@NonNull ComponentName admin, int length)",
    "returnType" : "void",
    "comment" : "\n     * Called by an application that is administering the device to set the minimum number of\n     * symbols required in the password. After setting this, the user will not be able to enter a\n     * new password that is not at least as restrictive as what has been set. Note that the current\n     * password will remain until the user has set a new one, so the change does not take place\n     * immediately. To prompt the user for a new password, use {@link #ACTION_SET_NEW_PASSWORD} or\n     * {@link #ACTION_SET_NEW_PARENT_PROFILE_PASSWORD} after setting this value. This constraint is\n     * only imposed if the administrator has also requested {@link #PASSWORD_QUALITY_COMPLEX} with\n     * {@link #setPasswordQuality}. If an app targeting SDK level\n     * {@link android.os.Build.VERSION_CODES#R} and above enforces this constraint without settings\n     * password quality to {@link #PASSWORD_QUALITY_COMPLEX} first, this method will throw\n     * {@link IllegalStateException}. The default value is 1.\n     * <p>\n     * On devices not supporting {@link PackageManager#FEATURE_SECURE_LOCK_SCREEN} feature, the\n     * password is always treated as empty.\n     * <p>\n     * The calling device admin must have requested\n     * {@link DeviceAdminInfo#USES_POLICY_LIMIT_PASSWORD} to be able to call this method; if it has\n     * not, a security exception will be thrown.\n     * <p>\n     * Apps targeting {@link android.os.Build.VERSION_CODES#R} and below can call this method on the\n     * {@link DevicePolicyManager} instance returned by\n     * {@link #getParentProfileInstance(ComponentName)} in order to set restrictions on the parent\n     * profile.\n     *\n     * <p><string>Note:</strong> this method is ignored on\n     * {PackageManager#FEATURE_AUTOMOTIVE automotive builds}.\n     *\n     * @deprecated see {@link #setPasswordQuality(ComponentName, int)} for details.\n     *\n     * @param admin Which {@link DeviceAdminReceiver} this request is associated with.\n     * @param length The new desired minimum number of symbols required in the password. A value of\n     *            0 means there is no restriction.\n     * @throws SecurityException if {@code admin} is not an active administrator or {@code admin}\n     *             does not use {@link DeviceAdminInfo#USES_POLICY_LIMIT_PASSWORD}\n     * @throws IllegalStateException if the calling app is targeting SDK level\n     *     {@link android.os.Build.VERSION_CODES#R} and above and didn't set a sufficient password\n     *     quality requirement prior to calling this method.\n     ",
    "links" : [ "#setPasswordQuality", "IllegalStateException", "#getParentProfileInstance(ComponentName)", "#setPasswordQuality(ComponentName", "android.os.Build.VERSION_CODES#R", "android.app.admin.DeviceAdminReceiver", "#ACTION_SET_NEW_PASSWORD", "android.content.pm.PackageManager#FEATURE_SECURE_LOCK_SCREEN", "android.app.admin.DeviceAdminInfo#USES_POLICY_LIMIT_PASSWORD", "android.app.admin.DevicePolicyManager", "#ACTION_SET_NEW_PARENT_PROFILE_PASSWORD", "#PASSWORD_QUALITY_COMPLEX" ]
  }, {
    "name" : "public int getPasswordMinimumSymbols(@Nullable ComponentName admin)",
    "returnType" : "int",
    "comment" : "\n     * Retrieve the current number of symbols required in the password\n     * for a particular admin or all admins that set restrictions on this user\n     * and its participating profiles. Restrictions on profiles that have\n     * a separate challenge are not taken into account. This is the same value as\n     * set by {@link #setPasswordMinimumSymbols(ComponentName, int)}\n     * and only applies when the password quality is\n     * {@link #PASSWORD_QUALITY_COMPLEX}.\n     *\n     * <p>On devices not supporting {@link PackageManager#FEATURE_SECURE_LOCK_SCREEN} feature, the\n     * password is always treated as empty.\n     *\n     * <p>This method can be called on the {@link DevicePolicyManager} instance\n     * returned by {@link #getParentProfileInstance(ComponentName)} in order to retrieve\n     * restrictions on the parent profile.\n     *\n     * @deprecated see {@link #setPasswordQuality(ComponentName, int)} for details.\n     *\n     * @param admin The name of the admin component to check, or {@code null} to\n     *            aggregate all admins.\n     * @return The minimum number of symbols required in the password.\n     ",
    "links" : [ "#getParentProfileInstance(ComponentName)", "#setPasswordQuality(ComponentName", "android.content.pm.PackageManager#FEATURE_SECURE_LOCK_SCREEN", "android.app.admin.DevicePolicyManager", "#setPasswordMinimumSymbols(ComponentName", "#PASSWORD_QUALITY_COMPLEX" ]
  }, {
    "name" : "public int getPasswordMinimumSymbols(@Nullable ComponentName admin, int userHandle)",
    "returnType" : "int",
    "comment" : " @hide per-user version ",
    "links" : [ ]
  }, {
    "name" : "public void setPasswordMinimumNonLetter(@NonNull ComponentName admin, int length)",
    "returnType" : "void",
    "comment" : "\n     * Called by an application that is administering the device to set the minimum number of\n     * non-letter characters (numerical digits or symbols) required in the password. After setting\n     * this, the user will not be able to enter a new password that is not at least as restrictive\n     * as what has been set. Note that the current password will remain until the user has set a new\n     * one, so the change does not take place immediately. To prompt the user for a new password,\n     * use {@link #ACTION_SET_NEW_PASSWORD} or {@link #ACTION_SET_NEW_PARENT_PROFILE_PASSWORD} after\n     * setting this value. This constraint is only imposed if the administrator has also requested\n     * {@link #PASSWORD_QUALITY_COMPLEX} with {@link #setPasswordQuality}. If an app targeting\n     * SDK level {@link android.os.Build.VERSION_CODES#R} and above enforces this constraint without\n     * settings password quality to {@link #PASSWORD_QUALITY_COMPLEX} first, this method will throw\n     * {@link IllegalStateException}. The default value is 0.\n     * <p>\n     * On devices not supporting {@link PackageManager#FEATURE_SECURE_LOCK_SCREEN} feature, the\n     * password is always treated as empty.\n     * <p>\n     * The calling device admin must have requested\n     * {@link DeviceAdminInfo#USES_POLICY_LIMIT_PASSWORD} to be able to call this method; if it has\n     * not, a security exception will be thrown.\n     * <p>\n     * Apps targeting {@link android.os.Build.VERSION_CODES#R} and below can call this method on the\n     * {@link DevicePolicyManager} instance returned by\n     * {@link #getParentProfileInstance(ComponentName)} in order to set restrictions on the parent\n     * profile.\n     *\n     * <p><string>Note:</strong> this method is ignored on\n     * {PackageManager#FEATURE_AUTOMOTIVE automotive builds}.\n     *\n     * @deprecated see {@link #setPasswordQuality(ComponentName, int)} for details.\n     *\n     * @param admin Which {@link DeviceAdminReceiver} this request is associated with.\n     * @param length The new desired minimum number of letters required in the password. A value of\n     *            0 means there is no restriction.\n     * @throws SecurityException if {@code admin} is not an active administrator or {@code admin}\n     *             does not use {@link DeviceAdminInfo#USES_POLICY_LIMIT_PASSWORD}\n     * @throws IllegalStateException if the calling app is targeting SDK level\n     *     {@link android.os.Build.VERSION_CODES#R} and above and didn't set a sufficient password\n     *     quality requirement prior to calling this method.\n     ",
    "links" : [ "#setPasswordQuality", "IllegalStateException", "#getParentProfileInstance(ComponentName)", "#setPasswordQuality(ComponentName", "android.os.Build.VERSION_CODES#R", "android.app.admin.DeviceAdminReceiver", "#ACTION_SET_NEW_PASSWORD", "android.content.pm.PackageManager#FEATURE_SECURE_LOCK_SCREEN", "android.app.admin.DeviceAdminInfo#USES_POLICY_LIMIT_PASSWORD", "android.app.admin.DevicePolicyManager", "#ACTION_SET_NEW_PARENT_PROFILE_PASSWORD", "#PASSWORD_QUALITY_COMPLEX" ]
  }, {
    "name" : "public int getPasswordMinimumNonLetter(@Nullable ComponentName admin)",
    "returnType" : "int",
    "comment" : "\n     * Retrieve the current number of non-letter characters required in the password\n     * for a particular admin or all admins that set restrictions on this user\n     * and its participating profiles. Restrictions on profiles that have\n     * a separate challenge are not taken into account.\n     * This is the same value as set by\n     * {@link #setPasswordMinimumNonLetter(ComponentName, int)}\n     * and only applies when the password quality is\n     * {@link #PASSWORD_QUALITY_COMPLEX}.\n     *\n     * <p>On devices not supporting {@link PackageManager#FEATURE_SECURE_LOCK_SCREEN} feature, the\n     * password is always treated as empty.\n     *\n     * <p>This method can be called on the {@link DevicePolicyManager} instance\n     * returned by {@link #getParentProfileInstance(ComponentName)} in order to retrieve\n     * restrictions on the parent profile.\n     *\n     * @deprecated see {@link #setPasswordQuality(ComponentName, int)} for details.\n     *\n     * @param admin The name of the admin component to check, or {@code null} to\n     *            aggregate all admins.\n     * @return The minimum number of letters required in the password.\n     ",
    "links" : [ "#setPasswordMinimumNonLetter(ComponentName", "#getParentProfileInstance(ComponentName)", "#setPasswordQuality(ComponentName", "android.content.pm.PackageManager#FEATURE_SECURE_LOCK_SCREEN", "android.app.admin.DevicePolicyManager", "#PASSWORD_QUALITY_COMPLEX" ]
  }, {
    "name" : "public int getPasswordMinimumNonLetter(@Nullable ComponentName admin, int userHandle)",
    "returnType" : "int",
    "comment" : " @hide per-user version ",
    "links" : [ ]
  }, {
    "name" : "public PasswordMetrics getPasswordMinimumMetrics(@UserIdInt int userHandle)",
    "returnType" : "PasswordMetrics",
    "comment" : "\n     * Returns minimum PasswordMetrics that satisfies all admin policies.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public PasswordMetrics getPasswordMinimumMetrics(@UserIdInt int userHandle, boolean deviceWideOnly)",
    "returnType" : "PasswordMetrics",
    "comment" : "\n     * Returns minimum PasswordMetrics that satisfies all admin policies.\n     * If requested, only consider device-wide admin policies and ignore policies set on the\n     * managed profile instance (as if the managed profile had separate work challenge).\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public void setPasswordHistoryLength(@NonNull ComponentName admin, int length)",
    "returnType" : "void",
    "comment" : "\n     * Called by an application that is administering the device to set the length of the password\n     * history. After setting this, the user will not be able to enter a new password that is the\n     * same as any password in the history. Note that the current password will remain until the\n     * user has set a new one, so the change does not take place immediately. To prompt the user for\n     * a new password, use {@link #ACTION_SET_NEW_PASSWORD} or\n     * {@link #ACTION_SET_NEW_PARENT_PROFILE_PASSWORD} after setting this value.\n     * <p>\n     * On devices not supporting {@link PackageManager#FEATURE_SECURE_LOCK_SCREEN} feature, the\n     * password history length is always 0.\n     * <p>\n     * The calling device admin must have requested\n     * {@link DeviceAdminInfo#USES_POLICY_LIMIT_PASSWORD} to be able to call this method; if it has\n     * not, a security exception will be thrown.\n     * <p>\n     * This method can be called on the {@link DevicePolicyManager} instance returned by\n     * {@link #getParentProfileInstance(ComponentName)} in order to set restrictions on the parent\n     * profile.\n     *\n     * @param admin Which {@link DeviceAdminReceiver} this request is associated with.\n     * @param length The new desired length of password history. A value of 0 means there is no\n     *            restriction.\n     * @throws SecurityException if {@code admin} is not an active administrator or {@code admin}\n     *             does not use {@link DeviceAdminInfo#USES_POLICY_LIMIT_PASSWORD}\n     ",
    "links" : [ "#getParentProfileInstance(ComponentName)", "android.app.admin.DeviceAdminReceiver", "#ACTION_SET_NEW_PASSWORD", "android.content.pm.PackageManager#FEATURE_SECURE_LOCK_SCREEN", "android.app.admin.DeviceAdminInfo#USES_POLICY_LIMIT_PASSWORD", "android.app.admin.DevicePolicyManager", "#ACTION_SET_NEW_PARENT_PROFILE_PASSWORD" ]
  }, {
    "name" : "public void setPasswordExpirationTimeout(@Nullable ComponentName admin, long timeout)",
    "returnType" : "void",
    "comment" : "\n     * Called by a device admin to set the password expiration timeout. Calling this method will\n     * restart the countdown for password expiration for the given admin, as will changing the\n     * device password (for all admins).\n     * <p>\n     * The provided timeout is the time delta in ms and will be added to the current time. For\n     * example, to have the password expire 5 days from now, timeout would be 5 * 86400 * 1000 =\n     * 432000000 ms for timeout.\n     * <p>\n     * To disable password expiration, a value of 0 may be used for timeout.\n     * <p>\n     * On devices not supporting {@link PackageManager#FEATURE_SECURE_LOCK_SCREEN} feature, the\n     * password expiration is always disabled.\n     * <p>\n     * A calling device admin must have requested\n     * {@link DeviceAdminInfo#USES_POLICY_EXPIRE_PASSWORD} to be able to call this method; if it has\n     * not, a security exception will be thrown.\n     * <p>\n     * Note that setting the password will automatically reset the expiration time for all active\n     * admins. Active admins do not need to explicitly call this method in that case.\n     * <p>\n     * This method can be called on the {@link DevicePolicyManager} instance returned by\n     * {@link #getParentProfileInstance(ComponentName)} in order to set restrictions on the parent\n     * profile.\n     *\n     * @param admin Which {@link DeviceAdminReceiver} this request is associated with. Null if the\n     *              caller is not a device admin\n     * @param timeout The limit (in ms) that a password can remain in effect. A value of 0 means\n     *            there is no restriction (unlimited).\n     * @throws SecurityException if {@code admin} is not an active administrator or {@code admin}\n     *             does not use {@link DeviceAdminInfo#USES_POLICY_EXPIRE_PASSWORD}\n     ",
    "links" : [ "#getParentProfileInstance(ComponentName)", "android.app.admin.DeviceAdminReceiver", "android.content.pm.PackageManager#FEATURE_SECURE_LOCK_SCREEN", "android.app.admin.DevicePolicyManager", "android.app.admin.DeviceAdminInfo#USES_POLICY_EXPIRE_PASSWORD" ]
  }, {
    "name" : "public long getPasswordExpirationTimeout(@Nullable ComponentName admin)",
    "returnType" : "long",
    "comment" : "\n     * Get the password expiration timeout for the given admin. The expiration timeout is the\n     * recurring expiration timeout provided in the call to\n     * {@link #setPasswordExpirationTimeout(ComponentName, long)} for the given admin or the\n     * aggregate of all participating policy administrators if {@code admin} is null. Admins that\n     * have set restrictions on profiles that have a separate challenge are not taken into account.\n     *\n     * <p>This method can be called on the {@link DevicePolicyManager} instance\n     * returned by {@link #getParentProfileInstance(ComponentName)} in order to retrieve\n     * restrictions on the parent profile.\n     *\n     * <p>On devices not supporting {@link PackageManager#FEATURE_SECURE_LOCK_SCREEN} feature, the\n     * password expiration is always disabled and this method always returns 0.\n     *\n     * @param admin The name of the admin component to check, or {@code null} to aggregate all admins.\n     * @return The timeout for the given admin or the minimum of all timeouts\n     ",
    "links" : [ "#getParentProfileInstance(ComponentName)", "android.content.pm.PackageManager#FEATURE_SECURE_LOCK_SCREEN", "android.app.admin.DevicePolicyManager", "#setPasswordExpirationTimeout(ComponentName" ]
  }, {
    "name" : "public long getPasswordExpiration(@Nullable ComponentName admin)",
    "returnType" : "long",
    "comment" : "\n     * Get the current password expiration time for a particular admin or all admins that set\n     * restrictions on this user and its participating profiles. Restrictions on profiles that have\n     * a separate challenge are not taken into account. If admin is {@code null}, then a composite\n     * of all expiration times is returned - which will be the minimum of all of them.\n     *\n     * <p>This method can be called on the {@link DevicePolicyManager} instance\n     * returned by {@link #getParentProfileInstance(ComponentName)} in order to retrieve\n     * the password expiration for the parent profile.\n     *\n     * <p>On devices not supporting {@link PackageManager#FEATURE_SECURE_LOCK_SCREEN} feature, the\n     * password expiration is always disabled and this method always returns 0.\n     *\n     * @param admin The name of the admin component to check, or {@code null} to aggregate all admins.\n     * @return The password expiration time, in milliseconds since epoch.\n     ",
    "links" : [ "#getParentProfileInstance(ComponentName)", "android.content.pm.PackageManager#FEATURE_SECURE_LOCK_SCREEN", "android.app.admin.DevicePolicyManager" ]
  }, {
    "name" : "public int getPasswordHistoryLength(@Nullable ComponentName admin)",
    "returnType" : "int",
    "comment" : "\n     * Retrieve the current password history length for a particular admin or all admins that\n     * set restrictions on this user and its participating profiles. Restrictions on profiles that\n     * have a separate challenge are not taken into account.\n     *\n     * <p>This method can be called on the {@link DevicePolicyManager} instance\n     * returned by {@link #getParentProfileInstance(ComponentName)} in order to retrieve\n     * restrictions on the parent profile.\n     *\n     * <p>On devices not supporting {@link PackageManager#FEATURE_SECURE_LOCK_SCREEN} feature, the\n     * password history length is always 0.\n     *\n     * @param admin The name of the admin component to check, or {@code null} to aggregate\n     * all admins.\n     * @return The length of the password history\n     ",
    "links" : [ "#getParentProfileInstance(ComponentName)", "android.content.pm.PackageManager#FEATURE_SECURE_LOCK_SCREEN", "android.app.admin.DevicePolicyManager" ]
  }, {
    "name" : "public int getPasswordHistoryLength(@Nullable ComponentName admin, int userHandle)",
    "returnType" : "int",
    "comment" : " @hide per-user version ",
    "links" : [ ]
  }, {
    "name" : "public int getPasswordMaximumLength(int quality)",
    "returnType" : "int",
    "comment" : "\n     * Return the maximum password length that the device supports for a\n     * particular password quality.\n     * <p>On devices not supporting {@link PackageManager#FEATURE_SECURE_LOCK_SCREEN} feature, the\n     * password is always empty and this method always returns 0.\n     * @param quality The quality being interrogated.\n     * @return Returns the maximum length that the user can enter.\n     ",
    "links" : [ "android.content.pm.PackageManager#FEATURE_SECURE_LOCK_SCREEN" ]
  }, {
    "name" : "public boolean isActivePasswordSufficient()",
    "returnType" : "boolean",
    "comment" : "\n     * Determines whether the calling user's current password meets policy requirements\n     * (e.g. quality, minimum length). The user must be unlocked to perform this check.\n     *\n     * <p>Policy requirements which affect this check can be set by admins of the user, but also\n     * by the admin of a managed profile associated with the calling user (when the managed profile\n     * doesn't have a separate work challenge). When a managed profile has a separate work\n     * challenge, its policy requirements only affect the managed profile.\n     *\n     * <p>Depending on the user, this method checks the policy requirement against one of the\n     * following passwords:\n     * <ul>\n     * <li>For the primary user or secondary users: the personal keyguard password.\n     * <li>For managed profiles: a work challenge if set, otherwise the parent user's personal\n     *     keyguard password.\n     * <ul/>\n     * In other words, it's always checking the requirement against the password that is protecting\n     * the calling user.\n     *\n     * <p>Note that this method considers all policy requirements targeting the password in\n     * question. For example a profile owner might set a requirement on the parent profile i.e.\n     * personal keyguard but not on the profile itself. When the device has a weak personal keyguard\n     * password and no separate work challenge, calling this method will return {@code false}\n     * despite the profile owner not setting a policy on the profile itself. This is because the\n     * profile's current password is the personal keyguard password, and it does not meet all policy\n     * requirements.\n     *\n     * <p>Device admins must request {@link DeviceAdminInfo#USES_POLICY_LIMIT_PASSWORD} before\n     * calling this method. Note, this policy type is deprecated for device admins in Android 9.0\n     * (API level 28) or higher.\n     *\n     * <p>This method can be called on the {@link DevicePolicyManager} instance returned by\n     * {@link #getParentProfileInstance(ComponentName)} in order to determine if the password set on\n     * the parent profile is sufficient.\n     *\n     * <p>On devices not supporting {@link PackageManager#FEATURE_SECURE_LOCK_SCREEN} feature, the\n     * password is always treated as empty - i.e. this method will always return false on such\n     * devices, provided any password requirements were set.\n     *\n     * @return {@code true} if the password meets the policy requirements, {@code false} otherwise\n     * @throws SecurityException if the calling application isn't an active admin that uses\n     *     {@link DeviceAdminInfo#USES_POLICY_LIMIT_PASSWORD}\n     * @throws IllegalStateException if the user isn't unlocked\n     ",
    "links" : [ "#getParentProfileInstance(ComponentName)", "android.content.pm.PackageManager#FEATURE_SECURE_LOCK_SCREEN", "android.app.admin.DeviceAdminInfo#USES_POLICY_LIMIT_PASSWORD", "android.app.admin.DevicePolicyManager" ]
  }, {
    "name" : "public boolean isActivePasswordSufficientForDeviceRequirement()",
    "returnType" : "boolean",
    "comment" : "\n     * Called by profile owner of a managed profile to determine whether the current device password\n     * meets policy requirements set explicitly device-wide.\n     * <p> This API is similar to {@link #isActivePasswordSufficient()}, with two notable\n     * differences:\n     * <ul>\n     * <li>this API always targets the device password. As a result it should always be called on\n     *   the {@link #getParentProfileInstance(ComponentName)} instance.</li>\n     * <li>password policy requirement set on the managed profile is not taken into consideration\n     *   by this API, even if the device currently does not have a separate work challenge set.</li>\n     * </ul>\n     *\n     * <p>This API is designed to facilite progressive password enrollment flows when the DPC\n     * imposes both device and profile password policies. DPC applies profile password policy by\n     * calling {@link #setPasswordQuality(ComponentName, int)} or\n     * {@link #setRequiredPasswordComplexity} on the regular {@link DevicePolicyManager} instance,\n     * while it applies device-wide policy by calling {@link #setRequiredPasswordComplexity} on the\n     * {@link #getParentProfileInstance(ComponentName)} instance. The DPC can utilize this check to\n     * guide the user to set a device password first taking into consideration the device-wide\n     * policy only, and then prompt the user to either upgrade it to be fully compliant, or enroll a\n     * separate work challenge to satisfy the profile password policy only.\n     *\n     * <p>The device user must be unlocked (@link {@link UserManager#isUserUnlocked(UserHandle)})\n     * to perform this check.\n     *\n     * @return {@code true} if the device password meets explicit requirement set on it,\n     *   {@code false} otherwise.\n     * @throws SecurityException if the calling application is not a profile owner of a managed\n     *   profile, or if this API is not called on the parent DevicePolicyManager instance.\n     * @throws IllegalStateException if the user isn't unlocked\n     * @see #EXTRA_DEVICE_PASSWORD_REQUIREMENT_ONLY\n     ",
    "links" : [ "#getParentProfileInstance(ComponentName)", "#setPasswordQuality(ComponentName", "#isActivePasswordSufficient()", "android.app.admin.DevicePolicyManager", "#setRequiredPasswordComplexity", "android.os.UserManager#isUserUnlocked(UserHandle)" ]
  }, {
    "name" : "public int getPasswordComplexity()",
    "returnType" : "int",
    "comment" : "\n     * Returns how complex the current user's screen lock is.\n     *\n     * <p>Note that when called from a profile which uses an unified challenge with its parent, the\n     * screen lock complexity of the parent will be returned.\n     *\n     * <p>Apps need the {@link permission#REQUEST_PASSWORD_COMPLEXITY} permission to call this\n     * method. On Android {@link android.os.Build.VERSION_CODES#S} and above, the calling\n     * application does not need this permission if it is a device owner or a profile owner.\n     *\n     * <p>This method can be called on the {@link DevicePolicyManager} instance\n     * returned by {@link #getParentProfileInstance(ComponentName)} in order to retrieve\n     * restrictions on the parent profile.\n     *\n     * @throws IllegalStateException if the user is not unlocked.\n     * @throws SecurityException     if the calling application does not have the permission\n     *                               {@link permission#REQUEST_PASSWORD_COMPLEXITY}, and is not a\n     *                               device owner or a profile owner.\n     ",
    "links" : [ "#getParentProfileInstance(ComponentName)", "android.os.Build.VERSION_CODES#S", "android.app.admin.DevicePolicyManager", "android.Manifest.permission#REQUEST_PASSWORD_COMPLEXITY" ]
  }, {
    "name" : "public void setRequiredPasswordComplexity(@PasswordComplexity int passwordComplexity)",
    "returnType" : "void",
    "comment" : "\n     * Sets a minimum password complexity requirement for the user's screen lock.\n     * The complexity level is one of the pre-defined levels, and the user is unable to set a\n     * password with a lower complexity level.\n     *\n     * <p>Note that when called on a profile which uses an unified challenge with its parent, the\n     * complexity would apply to the unified challenge.\n     *\n     * <p>This method can be called on the {@link DevicePolicyManager} instance\n     * returned by {@link #getParentProfileInstance(ComponentName)} in order to set\n     * restrictions on the parent profile.\n     *\n     * <p><strong>Note:</strong> Specifying password requirements using this method clears any\n     * password requirements set using the obsolete {@link #setPasswordQuality(ComponentName, int)}\n     * and any of its associated methods.\n     * Additionally, if there are password requirements set using the obsolete\n     * {@link #setPasswordQuality(ComponentName, int)} on the parent {@code DevicePolicyManager}\n     * instance, they must be cleared by calling {@link #setPasswordQuality(ComponentName, int)}\n     * with {@link #PASSWORD_QUALITY_UNSPECIFIED} on that instance prior to setting complexity\n     * requirement for the managed profile.\n     *\n     * @throws SecurityException if the calling application is not a device owner or a profile\n     * owner.\n     * @throws IllegalArgumentException if the complexity level is not one of the four above.\n     * @throws IllegalStateException if the caller is trying to set password complexity while there\n     * are password requirements specified using {@link #setPasswordQuality(ComponentName, int)}\n     * on the parent {@code DevicePolicyManager} instance.\n     ",
    "links" : [ "#getParentProfileInstance(ComponentName)", "#setPasswordQuality(ComponentName", "android.app.admin.DevicePolicyManager", "#PASSWORD_QUALITY_UNSPECIFIED" ]
  }, {
    "name" : "public int getRequiredPasswordComplexity()",
    "returnType" : "int",
    "comment" : "\n     * Gets the password complexity requirement set by {@link #setRequiredPasswordComplexity(int)},\n     * for the current user.\n     *\n     * <p>The difference between this method and {@link #getPasswordComplexity()} is that this\n     * method simply returns the value set by {@link #setRequiredPasswordComplexity(int)} while\n     * {@link #getPasswordComplexity()} returns the complexity of the actual password.\n     *\n     * <p>This method can be called on the {@link DevicePolicyManager} instance\n     * returned by {@link #getParentProfileInstance(ComponentName)} in order to get\n     * restrictions on the parent profile.\n     *\n     * @throws SecurityException if the calling application is not a device owner or a profile\n     * owner.\n     ",
    "links" : [ "#getParentProfileInstance(ComponentName)", "#getPasswordComplexity()", "android.app.admin.DevicePolicyManager", "#setRequiredPasswordComplexity(int)" ]
  }, {
    "name" : "public int getAggregatedPasswordComplexityForUser(int userId)",
    "returnType" : "int",
    "comment" : "\n     * Returns the password complexity that applies to this user, aggregated from other users if\n     * necessary (for example, if the DPC has set password complexity requirements on the parent\n     * profile DPM instance of a managed profile user, they would apply to the primary user on the\n     * device).\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public int getAggregatedPasswordComplexityForUser(int userId, boolean deviceWideOnly)",
    "returnType" : "int",
    "comment" : "\n     * Returns the password complexity that applies to this user, aggregated from other users if\n     * necessary (for example, if the DPC has set password complexity requirements on the parent\n     * profile DPM instance of a managed profile user, they would apply to the primary user on the\n     * device). If {@code deviceWideOnly} is {@code true}, ignore policies set on the\n     * managed profile DPM instance (as if the managed profile had separate work challenge).\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean isUsingUnifiedPassword(@NonNull ComponentName admin)",
    "returnType" : "boolean",
    "comment" : "\n     * When called by a profile owner of a managed profile returns true if the profile uses unified\n     * challenge with its parent user.\n     *\n     * <strong>Note</strong>: This method is not concerned with password quality and will return\n     * false if the profile has empty password as a separate challenge.\n     *\n     * @param admin Which {@link DeviceAdminReceiver} this request is associated with.\n     * @throws SecurityException if {@code admin} is not a profile owner of a managed profile.\n     * @see UserManager#DISALLOW_UNIFIED_PASSWORD\n     ",
    "links" : [ "android.app.admin.DeviceAdminReceiver" ]
  }, {
    "name" : "public boolean isPasswordSufficientAfterProfileUnification(int userHandle, int profileUser)",
    "returnType" : "boolean",
    "comment" : "\n     * Returns whether the given user's credential will be sufficient for all password policy\n     * requirement, once the user's profile has switched to unified challenge.\n     *\n     * <p>This is different from {@link #isActivePasswordSufficient()} since once the profile\n     * switches to unified challenge, policies set explicitly on the profile will start to affect\n     * the parent user.\n     * @param userHandle the user whose password requirement will be checked\n     * @param profileUser the profile user whose lockscreen challenge will be unified.\n     * @hide\n     ",
    "links" : [ "#isActivePasswordSufficient()" ]
  }, {
    "name" : "public int getCurrentFailedPasswordAttempts()",
    "returnType" : "int",
    "comment" : "\n     * Retrieve the number of times the user has failed at entering a password since that last\n     * successful password entry.\n     * <p>\n     * This method can be called on the {@link DevicePolicyManager} instance returned by\n     * {@link #getParentProfileInstance(ComponentName)} in order to retrieve the number of failed\n     * password attemts for the parent user.\n     * <p>\n     * The calling device admin must have requested {@link DeviceAdminInfo#USES_POLICY_WATCH_LOGIN}\n     * to be able to call this method; if it has not, a security exception will be thrown.\n     * <p>On devices not supporting {@link PackageManager#FEATURE_SECURE_LOCK_SCREEN} feature, the\n     * password is always empty and this method always returns 0.\n     *\n     * @return The number of times user has entered an incorrect password since the last correct\n     *         password entry.\n     * @throws SecurityException if the calling application does not own an active administrator\n     *             that uses {@link DeviceAdminInfo#USES_POLICY_WATCH_LOGIN}\n     ",
    "links" : [ "#getParentProfileInstance(ComponentName)", "android.content.pm.PackageManager#FEATURE_SECURE_LOCK_SCREEN", "android.app.admin.DevicePolicyManager", "android.app.admin.DeviceAdminInfo#USES_POLICY_WATCH_LOGIN" ]
  }, {
    "name" : "public int getCurrentFailedPasswordAttempts(int userHandle)",
    "returnType" : "int",
    "comment" : "\n     * Retrieve the number of times the given user has failed at entering a\n     * password since that last successful password entry.\n     *\n     * <p>The calling device admin must have requested\n     * {@link DeviceAdminInfo#USES_POLICY_WATCH_LOGIN} to be able to call this method; if it has\n     * not and it is not the system uid, a security exception will be thrown.\n     *\n     * @hide\n     ",
    "links" : [ "android.app.admin.DeviceAdminInfo#USES_POLICY_WATCH_LOGIN" ]
  }, {
    "name" : "public boolean getDoNotAskCredentialsOnBoot()",
    "returnType" : "boolean",
    "comment" : "\n     * Queries whether {@link #RESET_PASSWORD_DO_NOT_ASK_CREDENTIALS_ON_BOOT} flag is set.\n     *\n     * @return true if RESET_PASSWORD_DO_NOT_ASK_CREDENTIALS_ON_BOOT flag is set.\n     * @hide\n     ",
    "links" : [ "#RESET_PASSWORD_DO_NOT_ASK_CREDENTIALS_ON_BOOT" ]
  }, {
    "name" : "public void setMaximumFailedPasswordsForWipe(@Nullable ComponentName admin, int num)",
    "returnType" : "void",
    "comment" : "\n     * Setting this to a value greater than zero enables a policy that will perform a\n     * device or profile wipe after too many incorrect device-unlock passwords have been entered.\n     * This policy combines watching for failed passwords and wiping the device, and\n     * requires that calling Device Admins request both\n     * {@link DeviceAdminInfo#USES_POLICY_WATCH_LOGIN} and\n     * {@link DeviceAdminInfo#USES_POLICY_WIPE_DATA}}.\n     * <p>\n     * When this policy is set on the system or the main user, the device will be factory reset\n     * after too many incorrect password attempts. When set on any other user, only the\n     * corresponding user or profile will be wiped.\n     * <p>\n     * To implement any other policy (e.g. wiping data for a particular application only, erasing or\n     * revoking credentials, or reporting the failure to a server), you should implement\n     * {@link DeviceAdminReceiver#onPasswordFailed(Context, android.content.Intent)} instead. Do not\n     * use this API, because if the maximum count is reached, the device or profile will be wiped\n     * immediately, and your callback will not be invoked.\n     * <p>\n     * This method can be called on the {@link DevicePolicyManager} instance returned by\n     * {@link #getParentProfileInstance(ComponentName)} in order to set a value on the parent\n     * profile. This allows a profile wipe after too many incorrect device-unlock password have\n     * been entered on the parent profile even if each profile has a separate challenge.\n     * <p>On devices not supporting {@link PackageManager#FEATURE_SECURE_LOCK_SCREEN} feature, the\n     * password is always empty and this method has no effect - i.e. the policy is not set.\n     *\n     * @param admin Which {@link DeviceAdminReceiver} this request is associated with. Null if the\n     *              caller is not a device admin.\n     * @param num The number of failed password attempts at which point the device or profile will\n     *            be wiped.\n     * @throws SecurityException if {@code admin} is not null, and {@code admin} is not an active\n     *            administrator or does not use both\n     *            {@link DeviceAdminInfo#USES_POLICY_WATCH_LOGIN} and\n     *            {@link DeviceAdminInfo#USES_POLICY_WIPE_DATA}, or if {@code admin} is null and the\n     *            caller does not have permission to wipe the device.\n     ",
    "links" : [ "#getParentProfileInstance(ComponentName)", "android.app.admin.DeviceAdminReceiver", "android.content.pm.PackageManager#FEATURE_SECURE_LOCK_SCREEN", "android.app.admin.DevicePolicyManager", "android.app.admin.DeviceAdminInfo#USES_POLICY_WIPE_DATA", "android.app.admin.DeviceAdminInfo#USES_POLICY_WATCH_LOGIN", "android.app.admin.DeviceAdminReceiver#onPasswordFailed(Context" ]
  }, {
    "name" : "public int getMaximumFailedPasswordsForWipe(@Nullable ComponentName admin)",
    "returnType" : "int",
    "comment" : "\n     * Retrieve the current maximum number of login attempts that are allowed before the device\n     * or profile is wiped, for a particular admin or all admins that set restrictions on this user\n     * and its participating profiles. Restrictions on profiles that have a separate challenge are\n     * not taken into account.\n     *\n     * <p>This method can be called on the {@link DevicePolicyManager} instance\n     * returned by {@link #getParentProfileInstance(ComponentName)} in order to retrieve\n     * the value for the parent profile.\n     *\n     * <p>On devices not supporting {@link PackageManager#FEATURE_SECURE_LOCK_SCREEN} feature, the\n     * password is always empty and this method returns a default value (0) indicating that the\n     * policy is not set.\n     *\n     * @param admin The name of the admin component to check, or {@code null} to aggregate\n     * all admins.\n     ",
    "links" : [ "#getParentProfileInstance(ComponentName)", "android.content.pm.PackageManager#FEATURE_SECURE_LOCK_SCREEN", "android.app.admin.DevicePolicyManager" ]
  }, {
    "name" : "public int getMaximumFailedPasswordsForWipe(@Nullable ComponentName admin, int userHandle)",
    "returnType" : "int",
    "comment" : " @hide per-user version ",
    "links" : [ ]
  }, {
    "name" : "public int getProfileWithMinimumFailedPasswordsForWipe(int userHandle)",
    "returnType" : "int",
    "comment" : "\n     * Returns the user that will be wiped first when too many failed attempts are made to unlock\n     * user {@code userHandle}. That user is either the same as {@code userHandle} or belongs to the\n     * same profile group. When there is no such policy, returns {@code UserHandle.USER_NULL}.\n     * E.g. managed profile user may be wiped as a result of failed primary profile password\n     * attempts when using unified challenge. Primary user may be wiped as a result of failed\n     * password attempts on the managed profile on an organization-owned device.\n     * @hide Used only by Keyguard\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean resetPassword(String password, int flags)",
    "returnType" : "boolean",
    "comment" : "\n     * Force a new password for device unlock (the password needed to access the entire device) or\n     * the work profile challenge on the current user. This takes effect immediately.\n     *\n     * <p> Before {@link android.os.Build.VERSION_CODES#N}, this API is available to device admin,\n     * profile owner and device owner. Starting from {@link android.os.Build.VERSION_CODES#N},\n     * legacy device admin (who is not also profile owner or device owner) can only call this\n     * API to set a new password if there is currently no password set. Profile owner and device\n     * owner can continue to force change an existing password as long as the target user is\n     * unlocked, although device owner will not be able to call this API at all if there is also a\n     * managed profile on the device.\n     *\n     * <p> Between {@link android.os.Build.VERSION_CODES#O},\n     * {@link android.os.Build.VERSION_CODES#P} and {@link android.os.Build.VERSION_CODES#Q},\n     * profile owner and devices owner targeting SDK level {@link android.os.Build.VERSION_CODES#O}\n     * or above who attempt to call this API will receive {@link SecurityException}; they are\n     * encouraged to migrate to the new {@link #resetPasswordWithToken} API instead.\n     * Profile owner and device owner targeting older SDK levels are not affected: they continue\n     * to experience the existing behaviour described in the previous paragraph.\n     *\n     * <p><em>Starting from {@link android.os.Build.VERSION_CODES#R}, this API is no longer\n     * supported in most cases.</em> Device owner and profile owner calling\n     * this API will receive {@link SecurityException} if they target SDK level\n     * {@link android.os.Build.VERSION_CODES#O} or above, or they will receive a silent failure\n     * (API returning {@code false}) if they target lower SDK level.\n     * For legacy device admins, this API throws {@link SecurityException} if they target SDK level\n     * {@link android.os.Build.VERSION_CODES#N} or above, and returns {@code false} otherwise. Only\n     * privileged apps holding RESET_PASSWORD permission which are part of\n     * the system factory image can still call this API to set a new password if there is currently\n     * no password set. In this case, if the device already has a password, this API will throw\n     * {@link SecurityException}.\n     *\n     * <p>\n     * The given password must be sufficient for the current password quality and length constraints\n     * as returned by {@link #getPasswordQuality(ComponentName)} and\n     * {@link #getPasswordMinimumLength(ComponentName)}; if it does not meet these constraints, then\n     * it will be rejected and false returned. Note that the password may be a stronger quality\n     * (containing alphanumeric characters when the requested quality is only numeric), in which\n     * case the currently active quality will be increased to match.\n     *\n     * <p>On devices not supporting {@link PackageManager#FEATURE_SECURE_LOCK_SCREEN} feature, this\n     * methods does nothing.\n     * <p>\n     * The calling device admin must have requested\n     * {@link DeviceAdminInfo#USES_POLICY_RESET_PASSWORD} to be able to call this method; if it has\n     * not, a security exception will be thrown.\n     *\n     * @param password The new password for the user. Null or empty clears the password.\n     * @param flags May be 0 or combination of {@link #RESET_PASSWORD_REQUIRE_ENTRY} and\n     *            {@link #RESET_PASSWORD_DO_NOT_ASK_CREDENTIALS_ON_BOOT}.\n     * @return Returns true if the password was applied, or false if it is not acceptable for the\n     *         current constraints.\n     * @throws SecurityException if the calling application does not own an active administrator\n     *             that uses {@link DeviceAdminInfo#USES_POLICY_RESET_PASSWORD}\n     * @throws IllegalStateException if the calling user is locked or has a managed profile.\n     * @deprecated Please use {@link #resetPasswordWithToken} instead.\n     ",
    "links" : [ "#RESET_PASSWORD_DO_NOT_ASK_CREDENTIALS_ON_BOOT", "android.content.pm.PackageManager#FEATURE_SECURE_LOCK_SCREEN", "#getPasswordMinimumLength(ComponentName)", "SecurityException", "android.os.Build.VERSION_CODES#N", "android.os.Build.VERSION_CODES#P", "android.os.Build.VERSION_CODES#O", "android.os.Build.VERSION_CODES#R", "android.os.Build.VERSION_CODES#Q", "#getPasswordQuality(ComponentName)", "android.app.admin.DeviceAdminInfo#USES_POLICY_RESET_PASSWORD", "#RESET_PASSWORD_REQUIRE_ENTRY", "#resetPasswordWithToken" ]
  }, {
    "name" : "public boolean setResetPasswordToken(@Nullable ComponentName admin, byte[] token)",
    "returnType" : "boolean",
    "comment" : "\n     * Called by a profile or device owner to provision a token which can later be used to reset the\n     * device lockscreen password (if called by device owner), or managed profile challenge (if\n     * called by profile owner), via {@link #resetPasswordWithToken}.\n     * <p>\n     * If the user currently has a lockscreen password, the provisioned token will not be\n     * immediately usable; it only becomes active after the user performs a confirm credential\n     * operation, which can be triggered by {@link KeyguardManager#createConfirmDeviceCredentialIntent}.\n     * If the user has no lockscreen password, the token is activated immediately. In all cases,\n     * the active state of the current token can be checked by {@link #isResetPasswordTokenActive}.\n     * For security reasons, un-activated tokens are only stored in memory and will be lost once\n     * the device reboots. In this case a new token needs to be provisioned again.\n     * <p>\n     * Once provisioned and activated, the token will remain effective even if the user changes\n     * or clears the lockscreen password.\n     * <p>\n     * <em>This token is highly sensitive and should be treated at the same level as user\n     * credentials. In particular, NEVER store this token on device in plaintext. Do not store\n     * the plaintext token in device-encrypted storage if it will be needed to reset password on\n     * file-based encryption devices before user unlocks. Consider carefully how any password token\n     * will be stored on your server and who will need access to them. Tokens may be the subject of\n     * legal access requests.\n     * </em>\n     * <p>On devices not supporting {@link PackageManager#FEATURE_SECURE_LOCK_SCREEN} feature, the\n     * reset token is not set and this method returns false.\n     *\n     * @param admin Which {@link DeviceAdminReceiver} this request is associated with. Null if the\n     *              caller is not a device admin.\n     * @param token a secure token a least 32-byte long, which must be generated by a\n     *        cryptographically strong random number generator.\n     * @return true if the operation is successful, false otherwise.\n     * @throws SecurityException if admin is not a device or profile owner.\n     * @throws IllegalArgumentException if the supplied token is invalid.\n     ",
    "links" : [ "#isResetPasswordTokenActive", "android.app.admin.DeviceAdminReceiver", "android.content.pm.PackageManager#FEATURE_SECURE_LOCK_SCREEN", "#resetPasswordWithToken", "android.app.KeyguardManager#createConfirmDeviceCredentialIntent" ]
  }, {
    "name" : "public boolean clearResetPasswordToken(@Nullable ComponentName admin)",
    "returnType" : "boolean",
    "comment" : "\n     * Called by a profile, device owner or holder of the permission\n     * {@link android.Manifest.permission#MANAGE_DEVICE_POLICY_RESET_PASSWORD}\n     * to revoke the current password reset token.\n     *\n     * <p>On devices not supporting {@link PackageManager#FEATURE_SECURE_LOCK_SCREEN} feature, this\n     * method has no effect - the reset token should not have been set in the first place - and\n     * false is returned.\n     *\n     * @param admin Which {@link DeviceAdminReceiver} this request is associated with. Null if the\n     *              caller is not a device admin.\n     * @return true if the operation is successful, false otherwise.\n     * @throws SecurityException if admin is not a device or profile owner and if the caller does\n     * not the permission {@link android.Manifest.permission#MANAGE_DEVICE_POLICY_RESET_PASSWORD}.\n     ",
    "links" : [ "android.app.admin.DeviceAdminReceiver", "android.Manifest.permission#MANAGE_DEVICE_POLICY_RESET_PASSWORD", "android.content.pm.PackageManager#FEATURE_SECURE_LOCK_SCREEN" ]
  }, {
    "name" : "public boolean isResetPasswordTokenActive(@Nullable ComponentName admin)",
    "returnType" : "boolean",
    "comment" : "\n     * Called by a profile, device owner or a holder of the permission\n     * {@link android.Manifest.permission#MANAGE_DEVICE_POLICY_RESET_PASSWORD}\n     * to check if the current reset password token is active.\n     *\n     * <p>On devices not supporting {@link PackageManager#FEATURE_SECURE_LOCK_SCREEN} feature,\n     * false is always returned.\n     *\n     * @param admin Which {@link DeviceAdminReceiver} this request is associated with. Null if the\n     *              caller is not a device admin.\n     * @return true if the token is active, false otherwise.\n     * @throws SecurityException if admin is not a device or profile owner and not a holder of the\n     * permission {@link android.Manifest.permission#MANAGE_DEVICE_POLICY_RESET_PASSWORD}\n     * @throws IllegalStateException if no token has been set.\n     ",
    "links" : [ "android.app.admin.DeviceAdminReceiver", "android.Manifest.permission#MANAGE_DEVICE_POLICY_RESET_PASSWORD", "android.content.pm.PackageManager#FEATURE_SECURE_LOCK_SCREEN" ]
  }, {
    "name" : "public boolean resetPasswordWithToken(@Nullable ComponentName admin, String password, byte[] token, int flags)",
    "returnType" : "boolean",
    "comment" : "\n     * Called by device or profile owner to force set a new device unlock password or a managed\n     * profile challenge on current user. This takes effect immediately.\n     * <p>\n     * Unlike {@link #resetPassword}, this API can change the password even before the user or\n     * device is unlocked or decrypted. The supplied token must have been previously provisioned via\n     * {@link #setResetPasswordToken}, and in active state {@link #isResetPasswordTokenActive}.\n     * <p>\n     * The given password must be sufficient for the current password quality and length constraints\n     * as returned by {@link #getPasswordQuality(ComponentName)} and\n     * {@link #getPasswordMinimumLength(ComponentName)}; if it does not meet these constraints, then\n     * it will be rejected and false returned. Note that the password may be a stronger quality, for\n     * example, a password containing alphanumeric characters when the requested quality is only\n     * numeric.\n     * <p>\n     * Calling with a {@code null} or empty password will clear any existing PIN, pattern or\n     * password if the current password constraints allow it.\n     * <p>On devices not supporting {@link PackageManager#FEATURE_SECURE_LOCK_SCREEN} feature,\n     * calling this methods has no effect - the password is always empty - and false is returned.\n     *\n     * @param admin Which {@link DeviceAdminReceiver} this request is associated with. Null if the\n     *              caller is not a device admin.\n     * @param password The new password for the user. {@code null} or empty clears the password.\n     * @param token the password reset token previously provisioned by\n     *        {@link #setResetPasswordToken}.\n     * @param flags May be 0 or combination of {@link #RESET_PASSWORD_REQUIRE_ENTRY} and\n     *        {@link #RESET_PASSWORD_DO_NOT_ASK_CREDENTIALS_ON_BOOT}.\n     * @return Returns true if the password was applied, or false if it is not acceptable for the\n     *         current constraints.\n     * @throws SecurityException if admin is not a device or profile owner.\n     * @throws IllegalStateException if the provided token is not valid.\n     ",
    "links" : [ "#setResetPasswordToken", "#isResetPasswordTokenActive", "#RESET_PASSWORD_DO_NOT_ASK_CREDENTIALS_ON_BOOT", "android.app.admin.DeviceAdminReceiver", "#getPasswordQuality(ComponentName)", "android.content.pm.PackageManager#FEATURE_SECURE_LOCK_SCREEN", "#getPasswordMinimumLength(ComponentName)", "#resetPassword", "#RESET_PASSWORD_REQUIRE_ENTRY" ]
  }, {
    "name" : "public void setMaximumTimeToLock(@Nullable ComponentName admin, long timeMs)",
    "returnType" : "void",
    "comment" : "\n     * Called by an application that is administering the device to set the maximum time for user\n     * activity until the device will lock. This limits the length that the user can set. It takes\n     * effect immediately.\n     * <p>\n     * A calling device admin must have requested {@link DeviceAdminInfo#USES_POLICY_FORCE_LOCK}\n     * to be able to call this method; if it has not, a security exception will be thrown.\n     * <p>\n     * This method can be called on the {@link DevicePolicyManager} instance returned by\n     * {@link #getParentProfileInstance(ComponentName)} in order to set restrictions on the parent\n     * profile.\n     *\n     * @param admin Which {@link DeviceAdminReceiver} this request is associated with. Null if the\n     *              caller is not a device admin\n     * @param timeMs The new desired maximum time to lock in milliseconds. A value of 0 means there\n     *            is no restriction.\n     * @throws SecurityException if {@code admin} is not an active administrator or it does not use\n     *             {@link DeviceAdminInfo#USES_POLICY_FORCE_LOCK}\n     ",
    "links" : [ "#getParentProfileInstance(ComponentName)", "android.app.admin.DeviceAdminReceiver", "android.app.admin.DeviceAdminInfo#USES_POLICY_FORCE_LOCK", "android.app.admin.DevicePolicyManager" ]
  }, {
    "name" : "public long getMaximumTimeToLock(@Nullable ComponentName admin)",
    "returnType" : "long",
    "comment" : "\n     * Retrieve the current maximum time to unlock for a particular admin or all admins that set\n     * restrictions on this user and its participating profiles. Restrictions on profiles that have\n     * a separate challenge are not taken into account.\n     *\n     * <p>This method can be called on the {@link DevicePolicyManager} instance\n     * returned by {@link #getParentProfileInstance(ComponentName)} in order to retrieve\n     * restrictions on the parent profile.\n     *\n     * @param admin The name of the admin component to check, or {@code null} to aggregate\n     * all admins.\n     * @return time in milliseconds for the given admin or the minimum value (strictest) of\n     * all admins if admin is null. Returns 0 if there are no restrictions.\n     ",
    "links" : [ "#getParentProfileInstance(ComponentName)", "android.app.admin.DevicePolicyManager" ]
  }, {
    "name" : "public long getMaximumTimeToLock(@Nullable ComponentName admin, int userHandle)",
    "returnType" : "long",
    "comment" : " @hide per-user version ",
    "links" : [ ]
  }, {
    "name" : "public void setRequiredStrongAuthTimeout(@Nullable ComponentName admin, long timeoutMs)",
    "returnType" : "void",
    "comment" : "\n     * Called by a device/profile owner to set the timeout after which unlocking with secondary, non\n     * strong auth (e.g. fingerprint, face, trust agents) times out, i.e. the user has to use a\n     * strong authentication method like password, pin or pattern.\n     *\n     * <p>This timeout is used internally to reset the timer to require strong auth again after\n     * specified timeout each time it has been successfully used.\n     *\n     * <p>Fingerprint can also be disabled altogether using {@link #KEYGUARD_DISABLE_FINGERPRINT}.\n     *\n     * <p>Trust agents can also be disabled altogether using {@link #KEYGUARD_DISABLE_TRUST_AGENTS}.\n     *\n     * <p>A calling device admin can verify the value it has set by calling\n     * {@link #getRequiredStrongAuthTimeout(ComponentName)} and passing in its instance.\n     *\n     * <p>This method can be called on the {@link DevicePolicyManager} instance returned by\n     * {@link #getParentProfileInstance(ComponentName)} in order to set restrictions on the parent\n     * profile.\n     *\n     * <p>On devices not supporting {@link PackageManager#FEATURE_SECURE_LOCK_SCREEN} feature,\n     * calling this methods has no effect - i.e. the timeout is not set.\n     *\n     * @param admin Which {@link DeviceAdminReceiver} this request is associated with. Null if the\n     *              caller is not a device admin\n     * @param timeoutMs The new timeout in milliseconds, after which the user will have to unlock\n     *         with strong authentication method. A value of 0 means the admin is not participating\n     *         in controlling the timeout.\n     *         The minimum and maximum timeouts are platform-defined and are typically 1 hour and\n     *         72 hours, respectively. Though discouraged, the admin may choose to require strong\n     *         auth at all times using {@link #KEYGUARD_DISABLE_FINGERPRINT} and/or\n     *         {@link #KEYGUARD_DISABLE_TRUST_AGENTS}.\n     *\n     * @throws SecurityException if {@code admin} is not a device or profile owner.\n     ",
    "links" : [ "#KEYGUARD_DISABLE_FINGERPRINT", "#getParentProfileInstance(ComponentName)", "android.app.admin.DeviceAdminReceiver", "android.content.pm.PackageManager#FEATURE_SECURE_LOCK_SCREEN", "#KEYGUARD_DISABLE_TRUST_AGENTS", "android.app.admin.DevicePolicyManager", "#getRequiredStrongAuthTimeout(ComponentName)" ]
  }, {
    "name" : "public long getRequiredStrongAuthTimeout(@Nullable ComponentName admin)",
    "returnType" : "long",
    "comment" : "\n     * Determine for how long the user will be able to use secondary, non strong auth for\n     * authentication, since last strong method authentication (password, pin or pattern) was used.\n     * After the returned timeout the user is required to use strong authentication method.\n     *\n     * <p>This method can be called on the {@link DevicePolicyManager} instance\n     * returned by {@link #getParentProfileInstance(ComponentName)} in order to retrieve\n     * restrictions on the parent profile.\n     *\n     * <p>On devices not supporting {@link PackageManager#FEATURE_SECURE_LOCK_SCREEN} feature,\n     * 0 is returned to indicate that no timeout is configured.\n     *\n     * @param admin The name of the admin component to check, or {@code null} to aggregate\n     *         across all participating admins.\n     * @return The timeout in milliseconds or 0 if not configured for the provided admin.\n     ",
    "links" : [ "#getParentProfileInstance(ComponentName)", "android.content.pm.PackageManager#FEATURE_SECURE_LOCK_SCREEN", "android.app.admin.DevicePolicyManager" ]
  }, {
    "name" : "public long getRequiredStrongAuthTimeout(@Nullable ComponentName admin, @UserIdInt int userId)",
    "returnType" : "long",
    "comment" : " @hide per-user version ",
    "links" : [ ]
  }, {
    "name" : "public void lockNow()",
    "returnType" : "void",
    "comment" : "\n     * Make the device lock immediately, as if the lock screen timeout has expired at the point of\n     * this call.\n     * <p>\n     * This method secures the device in response to an urgent situation, such as a lost or stolen\n     * device. After this method is called, the device must be unlocked using strong authentication\n     * (PIN, pattern, or password). This API is intended for use only by device admins.\n     * <p>\n     * From version {@link android.os.Build.VERSION_CODES#R} onwards, the caller must either have\n     * the LOCK_DEVICE permission or the device must have the\n     * device admin feature; if neither is true, then the method will return without completing\n     * any action. Before version {@link android.os.Build.VERSION_CODES#R},\n     * the device needed the device admin feature, regardless of the caller's permissions.\n     * <p>\n     * The calling device admin must have requested {@link DeviceAdminInfo#USES_POLICY_FORCE_LOCK}\n     * to be able to call this method; if it has not, a security exception will be thrown.\n     * <p>\n     * If there's no lock type set, this method forces the device to go to sleep but doesn't lock\n     * the device. Device admins who find the device in this state can lock an otherwise-insecure\n     * device by first calling {@link #resetPassword} to set the password and then lock the device.\n     * <p>\n     * This method can be called on the {@link DevicePolicyManager} instance returned by\n     * {@link #getParentProfileInstance(ComponentName)} in order to lock the parent profile.\n     * <p>\n     * NOTE: on {@link android.content.pm.PackageManager#FEATURE_AUTOMOTIVE automotive builds}, this\n     * method doesn't turn off the screen as it would be a driving safety distraction.\n     * <p>\n     * Equivalent to calling {@link #lockNow(int)} with no flags.\n     *\n     * @throws SecurityException if the calling application does not own an active administrator\n     *             that uses {@link DeviceAdminInfo#USES_POLICY_FORCE_LOCK}\n     ",
    "links" : [ "#getParentProfileInstance(ComponentName)", "#lockNow(int)", "android.os.Build.VERSION_CODES#R", "android.content.pm.PackageManager#FEATURE_AUTOMOTIVE", "android.app.admin.DeviceAdminInfo#USES_POLICY_FORCE_LOCK", "android.app.admin.DevicePolicyManager", "#resetPassword" ]
  }, {
    "name" : "public void lockNow(@LockNowFlag int flags)",
    "returnType" : "void",
    "comment" : "\n     * Make the device lock immediately, as if the lock screen timeout has expired at the point of\n     * this call.\n     * <p>\n     * This method secures the device in response to an urgent situation, such as a lost or stolen\n     * device. After this method is called, the device must be unlocked using strong authentication\n     * (PIN, pattern, or password). This API is intended for use only by device admins.\n     * <p>\n     * From version {@link android.os.Build.VERSION_CODES#R} onwards, the caller must either have\n     * the LOCK_DEVICE permission or the device must have the\n     * device admin feature; if neither is true, then the method will return without completing any\n     * action. Before version {@link android.os.Build.VERSION_CODES#R}, the device needed the device\n     * admin feature, regardless of the caller's permissions.\n     * <p>\n     * A calling device admin must have requested {@link DeviceAdminInfo#USES_POLICY_FORCE_LOCK}\n     * to be able to call this method; if it has not, a security exception will be thrown.\n     * <p>\n     * If there's no lock type set, this method forces the device to go to sleep but doesn't lock\n     * the device. Device admins who find the device in this state can lock an otherwise-insecure\n     * device by first calling {@link #resetPassword} to set the password and then lock the device.\n     * <p>\n     * This method can be called on the {@link DevicePolicyManager} instance returned by\n     * {@link #getParentProfileInstance(ComponentName)} in order to lock the parent profile as\n     * well as the managed profile.\n     * <p>\n     * NOTE: In order to lock the parent profile and evict the encryption key of the managed\n     * profile, {@link #lockNow()} must be called twice: First, {@link #lockNow()} should be called\n     * on the {@link DevicePolicyManager} instance returned by\n     * {@link #getParentProfileInstance(ComponentName)}, then {@link #lockNow(int)} should be\n     * called on the {@link DevicePolicyManager} instance associated with the managed profile,\n     * with the {@link #FLAG_EVICT_CREDENTIAL_ENCRYPTION_KEY} flag.\n     * Calling the method twice in this order ensures that all users are locked and does not\n     * stop the device admin on the managed profile from issuing a second call to lock its own\n     * profile.\n     * <p>\n     * NOTE: on {@link android.content.pm.PackageManager#FEATURE_AUTOMOTIVE automotive builds}, this\n     * method doesn't turn off the screen as it would be a driving safety distraction.\n     *\n     * @param flags May be 0 or {@link #FLAG_EVICT_CREDENTIAL_ENCRYPTION_KEY}.\n     * @throws SecurityException if the calling application does not own an active administrator\n     *             that uses {@link DeviceAdminInfo#USES_POLICY_FORCE_LOCK} and the does not hold\n     *             the {@link android.Manifest.permission#LOCK_DEVICE} permission, or\n     *             the {@link #FLAG_EVICT_CREDENTIAL_ENCRYPTION_KEY} flag is passed by an\n     *             application that is not a profile owner of a managed profile.\n     * @throws IllegalArgumentException if the {@link #FLAG_EVICT_CREDENTIAL_ENCRYPTION_KEY} flag is\n     *             passed when locking the parent profile.\n     * @throws UnsupportedOperationException if the {@link #FLAG_EVICT_CREDENTIAL_ENCRYPTION_KEY}\n     *             flag is passed when {@link #getStorageEncryptionStatus} does not return\n     *             {@link #ENCRYPTION_STATUS_ACTIVE_PER_USER}.\n     ",
    "links" : [ "#getParentProfileInstance(ComponentName)", "#lockNow(int)", "android.os.Build.VERSION_CODES#R", "#lockNow()", "android.content.pm.PackageManager#FEATURE_AUTOMOTIVE", "android.Manifest.permission#LOCK_DEVICE", "android.app.admin.DeviceAdminInfo#USES_POLICY_FORCE_LOCK", "android.app.admin.DevicePolicyManager", "#resetPassword", "#getStorageEncryptionStatus", "#ENCRYPTION_STATUS_ACTIVE_PER_USER", "#FLAG_EVICT_CREDENTIAL_ENCRYPTION_KEY" ]
  }, {
    "name" : "public void wipeData(int flags)",
    "returnType" : "void",
    "comment" : "\n     * See {@link #wipeData(int, CharSequence)}\n     *\n     * @param flags Bit mask of additional options: currently supported flags are\n     *              {@link #WIPE_EXTERNAL_STORAGE}, {@link #WIPE_RESET_PROTECTION_DATA},\n     *              {@link #WIPE_EUICC} and {@link #WIPE_SILENTLY}.\n     * @throws SecurityException if the calling application does not own an active\n     *                           administrator\n     *                           that uses {@link DeviceAdminInfo#USES_POLICY_WIPE_DATA} and is\n     *                           not granted the\n     *                           {@link android.Manifest.permission#MASTER_CLEAR} or\n     *                           {@link android.Manifest.permission#MANAGE_DEVICE_POLICY_WIPE_DATA}\n     *                            permissions.\n     * @throws IllegalStateException if called on last full-user or system-user\n     * @see #wipeDevice(int)\n     * @see #wipeData(int, CharSequence)\n     ",
    "links" : [ "android.Manifest.permission#MASTER_CLEAR", "#WIPE_RESET_PROTECTION_DATA", "#WIPE_EXTERNAL_STORAGE", "#WIPE_SILENTLY", "android.Manifest.permission#MANAGE_DEVICE_POLICY_WIPE_DATA", "android.app.admin.DeviceAdminInfo#USES_POLICY_WIPE_DATA", "#WIPE_EUICC", "#wipeData(int" ]
  }, {
    "name" : "public void wipeData(int flags, @NonNull CharSequence reason)",
    "returnType" : "void",
    "comment" : "\n     * Ask that all user data be wiped.\n     *\n     * <p>\n     * If called as a secondary user or managed profile, the user itself and its associated user\n     * data will be wiped. In particular, If the caller is a profile owner of an\n     * organization-owned managed profile, calling this method will relinquish the device for\n     * personal use, removing the managed profile and all policies set by the profile owner.\n     * </p>\n     *\n     * <p> Calling this method from the primary user will only work if the calling app is\n     * targeting SDK level {@link Build.VERSION_CODES#TIRAMISU} or below, in which case it will\n     * cause the device to reboot, erasing all device data - including all the secondary users\n     * and their data - while booting up. If an app targeting SDK level\n     * {@link Build.VERSION_CODES#UPSIDE_DOWN_CAKE} and above is calling this method from the\n     * primary user or last full user, {@link IllegalStateException} will be thrown. </p>\n     *\n     * If an app wants to wipe the entire device irrespective of which user they are from, they\n     * should use {@link #wipeDevice} instead.\n     *\n     * @param flags Bit mask of additional options: currently supported flags are\n     *            {@link #WIPE_EXTERNAL_STORAGE}, {@link #WIPE_RESET_PROTECTION_DATA} and\n     *            {@link #WIPE_EUICC}.\n     * @param reason a string that contains the reason for wiping data, which can be\n     *            presented to the user.\n     * @throws SecurityException if the calling application does not own an active administrator\n     *            that uses {@link DeviceAdminInfo#USES_POLICY_WIPE_DATA} and is not granted the\n     *            {@link android.Manifest.permission#MASTER_CLEAR} or\n     *            {@link android.Manifest.permission#MANAGE_DEVICE_POLICY_WIPE_DATA} permissions.\n     * @throws IllegalArgumentException if the input reason string is null or empty, or if\n     *            {@link #WIPE_SILENTLY} is set.\n     * @throws IllegalStateException if called on last full-user or system-user\n     * @see #wipeDevice(int)\n     * @see #wipeData(int)\n     ",
    "links" : [ "android.Manifest.permission#MASTER_CLEAR", "IllegalStateException", "#wipeDevice", "#WIPE_RESET_PROTECTION_DATA", "#WIPE_EXTERNAL_STORAGE", "#WIPE_SILENTLY", "android.Manifest.permission#MANAGE_DEVICE_POLICY_WIPE_DATA", "Build.VERSION_CODES#TIRAMISU", "android.app.admin.DeviceAdminInfo#USES_POLICY_WIPE_DATA", "Build.VERSION_CODES#UPSIDE_DOWN_CAKE", "#WIPE_EUICC" ]
  }, {
    "name" : "public void wipeDevice(int flags)",
    "returnType" : "void",
    "comment" : " TODO(b/255323293) Add host-side tests",
    "links" : [ ]
  }, {
    "name" : "private void wipeDataInternal(int flags, @NonNull String wipeReasonForUser, boolean factoryReset)",
    "returnType" : "void",
    "comment" : "\n     * Internal function for {@link #wipeData(int)}, {@link #wipeData(int, CharSequence)}\n     * and {@link #wipeDevice(int)} to call.\n     *\n     * @hide\n     * @see #wipeData(int)\n     * @see #wipeData(int, CharSequence)\n     * @see #wipeDevice(int)\n     ",
    "links" : [ "#wipeData(int)", "#wipeDevice(int)", "#wipeData(int" ]
  }, {
    "name" : "public void setFactoryResetProtectionPolicy(@Nullable ComponentName admin, @Nullable FactoryResetProtectionPolicy policy)",
    "returnType" : "void",
    "comment" : "\n     * Callable by device owner or profile owner of an organization-owned device, to set a\n     * factory reset protection (FRP) policy. When a new policy is set, the system\n     * notifies the FRP management agent of a policy change by broadcasting\n     * {@code ACTION_RESET_PROTECTION_POLICY_CHANGED}.\n     *\n     * @param admin  Which {@link DeviceAdminReceiver} this request is associated with. Null if the\n     *               caller is not a device admin\n     * @param policy the new FRP policy, or {@code null} to clear the current policy.\n     * @throws SecurityException if {@code admin} is not a device owner or a profile owner of\n     *                           an organization-owned device.\n     * @throws UnsupportedOperationException if factory reset protection is not\n     *                           supported on the device.\n     ",
    "links" : [ "android.app.admin.DeviceAdminReceiver" ]
  }, {
    "name" : "public FactoryResetProtectionPolicy getFactoryResetProtectionPolicy(@Nullable ComponentName admin)",
    "returnType" : "FactoryResetProtectionPolicy",
    "comment" : "\n     * Callable by device owner or profile owner of an organization-owned device, to retrieve\n     * the current factory reset protection (FRP) policy set previously by\n     * {@link #setFactoryResetProtectionPolicy}.\n     * <p>\n     * This method can also be called by the FRP management agent on device or with the permission\n     * {@link android.Manifest.permission#MASTER_CLEAR}, in which case, it can pass {@code null}\n     * as the ComponentName.\n     *\n     * @param admin Which {@link DeviceAdminReceiver} this request is associated with or\n     *              {@code null} if the caller is not a device admin\n     * @return The current FRP policy object or {@code null} if no policy is set.\n     * @throws SecurityException if {@code admin} is not a device owner, a profile owner of\n     *                           an organization-owned device or the FRP management agent.\n     * @throws UnsupportedOperationException if factory reset protection is not\n     *                           supported on the device.\n     ",
    "links" : [ "android.Manifest.permission#MASTER_CLEAR", "android.app.admin.DeviceAdminReceiver", "#setFactoryResetProtectionPolicy" ]
  }, {
    "name" : "public void sendLostModeLocationUpdate(@NonNull @CallbackExecutor Executor executor, @NonNull Consumer<Boolean> callback)",
    "returnType" : "void",
    "comment" : "\n     * Send a lost mode location update to the admin. This API is limited to organization-owned\n     * devices, which includes devices with a device owner or devices with a profile owner on an\n     * organization-owned managed profile.\n     *\n     * <p>The caller must hold the\n     * {@link android.Manifest.permission#TRIGGER_LOST_MODE} permission.\n     *\n     * <p>Register a broadcast receiver to receive lost mode location updates. This receiver should\n     * subscribe to the {@link #ACTION_LOST_MODE_LOCATION_UPDATE} action and receive the location\n     * from an intent extra {@link #EXTRA_LOST_MODE_LOCATION}.\n     *\n     * <p> Not for use by third-party applications.\n     *\n     * @param executor The executor through which the callback should be invoked.\n     * @param callback A callback object that will inform the caller whether a lost mode location\n     *                 update was successfully sent\n     * @hide\n     ",
    "links" : [ "android.Manifest.permission#TRIGGER_LOST_MODE", "#ACTION_LOST_MODE_LOCATION_UPDATE", "#EXTRA_LOST_MODE_LOCATION" ]
  }, {
    "name" : "private void executeCallback(AndroidFuture<Boolean> future, @CallbackExecutor @NonNull Executor executor, Consumer<Boolean> callback)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public ComponentName setGlobalProxy(@NonNull ComponentName admin, Proxy proxySpec, List<String> exclusionList)",
    "returnType" : "ComponentName",
    "comment" : "\n     * Called by an application that is administering the device to set the\n     * global proxy and exclusion list.\n     * <p>\n     * The calling device admin must have requested\n     * {@link DeviceAdminInfo#USES_POLICY_SETS_GLOBAL_PROXY} to be able to call\n     * this method; if it has not, a security exception will be thrown.\n     * Only the first device admin can set the proxy. If a second admin attempts\n     * to set the proxy, the {@link ComponentName} of the admin originally setting the\n     * proxy will be returned. If successful in setting the proxy, {@code null} will\n     * be returned.\n     * The method can be called repeatedly by the device admin alrady setting the\n     * proxy to update the proxy and exclusion list.\n     *\n     * @param admin Which {@link DeviceAdminReceiver} this request is associated with.\n     * @param proxySpec the global proxy desired. Must be an HTTP Proxy.\n     *            Pass Proxy.NO_PROXY to reset the proxy.\n     * @param exclusionList a list of domains to be excluded from the global proxy.\n     * @return {@code null} if the proxy was successfully set, or otherwise a {@link ComponentName}\n     *            of the device admin that sets the proxy.\n     * @hide\n     ",
    "links" : [ "android.app.admin.DeviceAdminReceiver", "android.content.ComponentName", "android.app.admin.DeviceAdminInfo#USES_POLICY_SETS_GLOBAL_PROXY" ]
  }, {
    "name" : "public Pair<String, String> getProxyParameters(Proxy proxySpec, List<String> exclusionList)",
    "returnType" : "Pair<String, String>",
    "comment" : "\n     * Build HTTP proxy parameters for {@link IDevicePolicyManager#setGlobalProxy}.\n     * @throws IllegalArgumentException Invalid proxySpec\n     * @hide\n     ",
    "links" : [ "#setGlobalProxy" ]
  }, {
    "name" : "public void setRecommendedGlobalProxy(@NonNull ComponentName admin, @Nullable ProxyInfo proxyInfo)",
    "returnType" : "void",
    "comment" : "\n     * Set a network-independent global HTTP proxy. This is not normally what you want for typical\n     * HTTP proxies - they are generally network dependent. However if you're doing something\n     * unusual like general internal filtering this may be useful. On a private network where the\n     * proxy is not accessible, you may break HTTP using this.\n     * <p>\n     * This method requires the caller to be the device owner.\n     * <p>\n     * This proxy is only a recommendation and it is possible that some apps will ignore it.\n     * <p>\n     * Note: The device owner won't be able to set a global HTTP proxy if there are unaffiliated\n     * secondary users or profiles on the device. It's recommended that affiliation ids are set for\n     * new users as soon as possible after provisioning via {@link #setAffiliationIds}.\n     *\n     * @see ProxyInfo\n     * @param admin Which {@link DeviceAdminReceiver} this request is associated with.\n     * @param proxyInfo The a {@link ProxyInfo} object defining the new global HTTP proxy. A\n     *            {@code null} value will clear the global HTTP proxy.\n     * @throws SecurityException if {@code admin} is not the device owner.\n     ",
    "links" : [ "android.app.admin.DeviceAdminReceiver", "#setAffiliationIds", "android.net.ProxyInfo" ]
  }, {
    "name" : "public ComponentName getGlobalProxyAdmin()",
    "returnType" : "ComponentName",
    "comment" : "\n     * Returns the component name setting the global proxy.\n     * @return ComponentName object of the device admin that set the global proxy, or {@code null}\n     *         if no admin has set the proxy.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public int setStorageEncryption(@NonNull ComponentName admin, boolean encrypt)",
    "returnType" : "int",
    "comment" : "\n     * @deprecated This method does not actually modify the storage encryption of the device.\n     * It has never affected the encryption status of a device.\n     *\n     * Called by an application that is administering the device to request that the storage system\n     * be encrypted. Does nothing if the caller is on a secondary user or a managed profile.\n     * <p>\n     * When multiple device administrators attempt to control device encryption, the most secure,\n     * supported setting will always be used. If any device administrator requests device\n     * encryption, it will be enabled; Conversely, if a device administrator attempts to disable\n     * device encryption while another device administrator has enabled it, the call to disable will\n     * fail (most commonly returning {@link #ENCRYPTION_STATUS_ACTIVE}).\n     * <p>\n     * This policy controls encryption of the secure (application data) storage area. Data written\n     * to other storage areas may or may not be encrypted, and this policy does not require or\n     * control the encryption of any other storage areas. There is one exception: If\n     * {@link android.os.Environment#isExternalStorageEmulated()} is {@code true}, then the\n     * directory returned by {@link android.os.Environment#getExternalStorageDirectory()} must be\n     * written to disk within the encrypted storage area.\n     * <p>\n     * Important Note: On some devices, it is possible to encrypt storage without requiring the user\n     * to create a device PIN or Password. In this case, the storage is encrypted, but the\n     * encryption key may not be fully secured. For maximum security, the administrator should also\n     * require (and check for) a pattern, PIN, or password.\n     *\n     * @param admin Which {@link DeviceAdminReceiver} this request is associated with.\n     * @param encrypt true to request encryption, false to release any previous request\n     * @return the new total request status (for all active admins), or {@link\n     *         DevicePolicyManager#ENCRYPTION_STATUS_UNSUPPORTED} if called for a non-system user.\n     *         Will be one of {@link #ENCRYPTION_STATUS_UNSUPPORTED}, {@link\n     *         #ENCRYPTION_STATUS_INACTIVE}, or {@link #ENCRYPTION_STATUS_ACTIVE}. This is the value\n     *         of the requests; use {@link #getStorageEncryptionStatus()} to query the actual device\n     *         state.\n     *\n     * @throws SecurityException if {@code admin} is not an active administrator or does not use\n     *             {@link DeviceAdminInfo#USES_ENCRYPTED_STORAGE}\n     ",
    "links" : [ "#ENCRYPTION_STATUS_ACTIVE", "android.os.Environment#isExternalStorageEmulated()", "android.app.admin.DeviceAdminReceiver", "#ENCRYPTION_STATUS_INACTIVE", "android.os.Environment#getExternalStorageDirectory()", "#getStorageEncryptionStatus()", "android.app.admin.DeviceAdminInfo#USES_ENCRYPTED_STORAGE", "#ENCRYPTION_STATUS_UNSUPPORTED", "android.app.admin.DevicePolicyManager#ENCRYPTION_STATUS_UNSUPPORTED" ]
  }, {
    "name" : "public boolean getStorageEncryption(@Nullable ComponentName admin)",
    "returnType" : "boolean",
    "comment" : "\n     * @deprecated This method only returns the value set by {@link #setStorageEncryption}.\n     * It does not actually reflect the storage encryption status.\n     * Use {@link #getStorageEncryptionStatus} for that.\n     *\n     * Called by an application that is administering the device to\n     * determine the requested setting for secure storage.\n     *\n     * @param admin Which {@link DeviceAdminReceiver} this request is associated with.  If null,\n     * this will return the requested encryption setting as an aggregate of all active\n     * administrators.\n     * @return true if the admin(s) are requesting encryption, false if not.\n     ",
    "links" : [ "android.app.admin.DeviceAdminReceiver", "#setStorageEncryption", "#getStorageEncryptionStatus" ]
  }, {
    "name" : "public int getStorageEncryptionStatus()",
    "returnType" : "int",
    "comment" : "\n     * Called by an application that is administering the device to\n     * determine the current encryption status of the device.\n     * <p>\n     * Depending on the returned status code, the caller may proceed in different\n     * ways.  If the result is {@link #ENCRYPTION_STATUS_UNSUPPORTED}, the\n     * storage system does not support encryption.  If the\n     * result is {@link #ENCRYPTION_STATUS_INACTIVE}, use {@link\n     * #ACTION_START_ENCRYPTION} to begin the process of encrypting or decrypting the\n     * storage.  If the result is {@link #ENCRYPTION_STATUS_ACTIVE_DEFAULT_KEY}, the\n     * storage system has enabled encryption but no password is set so further action\n     * may be required.  If the result is {@link #ENCRYPTION_STATUS_ACTIVATING},\n     * {@link #ENCRYPTION_STATUS_ACTIVE} or {@link #ENCRYPTION_STATUS_ACTIVE_PER_USER},\n     * no further action is required.\n     *\n     * @return current status of encryption. The value will be one of\n     * {@link #ENCRYPTION_STATUS_UNSUPPORTED}, {@link #ENCRYPTION_STATUS_INACTIVE},\n     * {@link #ENCRYPTION_STATUS_ACTIVATING}, {@link #ENCRYPTION_STATUS_ACTIVE_DEFAULT_KEY},\n     * {@link #ENCRYPTION_STATUS_ACTIVE}, or {@link #ENCRYPTION_STATUS_ACTIVE_PER_USER}.\n     *\n     * @throws SecurityException if called on a parent instance.\n     ",
    "links" : [ "#ENCRYPTION_STATUS_ACTIVE", "#ENCRYPTION_STATUS_INACTIVE", "#ENCRYPTION_STATUS_ACTIVE_DEFAULT_KEY", "#ACTION_START_ENCRYPTION", "#ENCRYPTION_STATUS_ACTIVATING", "#ENCRYPTION_STATUS_ACTIVE_PER_USER", "#ENCRYPTION_STATUS_UNSUPPORTED" ]
  }, {
    "name" : "public int getStorageEncryptionStatus(int userHandle)",
    "returnType" : "int",
    "comment" : " @hide per-user version ",
    "links" : [ ]
  }, {
    "name" : "public boolean approveCaCert(String alias, int userHandle, boolean approval)",
    "returnType" : "boolean",
    "comment" : "\n     * Mark a CA certificate as approved by the device user. This means that they have been notified\n     * of the installation, were made aware of the risks, viewed the certificate and still wanted to\n     * keep the certificate on the device.\n     *\n     * Calling with {@param approval} as {@code true} will cancel any ongoing warnings related to\n     * this certificate.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean isCaCertApproved(String alias, int userHandle)",
    "returnType" : "boolean",
    "comment" : "\n     * Check whether a CA certificate has been approved by the device user.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean installCaCert(@Nullable ComponentName admin, byte[] certBuffer)",
    "returnType" : "boolean",
    "comment" : "\n     * Installs the given certificate as a user CA.\n     * <p>\n     * Inserted user CAs aren't automatically trusted by apps in Android 7.0 (API level 24) and\n     * higher. App developers can change the default behavior for an app by adding a\n     * <a href=\"{@docRoot}training/articles/security-config.html\">Security Configuration\n     * File</a> to the app manifest file.\n     *\n     * The caller must be a profile or device owner on that user, or a delegate package given the\n     * {@link #DELEGATION_CERT_INSTALL} scope via {@link #setDelegatedScopes}; otherwise a\n     * security exception will be thrown.\n     *\n     * @param admin Which {@link DeviceAdminReceiver} this request is associated with, or\n     *              {@code null} if calling from a delegated certificate installer.\n     * @param certBuffer encoded form of the certificate to install.\n     *\n     * @return false if the certBuffer cannot be parsed or installation is\n     *         interrupted, true otherwise.\n     * @throws SecurityException if {@code admin} is not {@code null} and not a device or profile\n     *         owner.\n     * @see #setDelegatedScopes\n     * @see #DELEGATION_CERT_INSTALL\n     ",
    "links" : [ "#DELEGATION_CERT_INSTALL", "android.app.admin.DeviceAdminReceiver", "#setDelegatedScopes" ]
  }, {
    "name" : "public void uninstallCaCert(@Nullable ComponentName admin, byte[] certBuffer)",
    "returnType" : "void",
    "comment" : "\n     * Uninstalls the given certificate from trusted user CAs, if present.\n     *\n     * The caller must be a profile or device owner on that user, or a delegate package given the\n     * {@link #DELEGATION_CERT_INSTALL} scope via {@link #setDelegatedScopes}; otherwise a\n     * security exception will be thrown.\n     *\n     * @param admin Which {@link DeviceAdminReceiver} this request is associated with, or\n     *              {@code null} if calling from a delegated certificate installer.\n     * @param certBuffer encoded form of the certificate to remove.\n     * @throws SecurityException if {@code admin} is not {@code null} and not a device or profile\n     *         owner.\n     * @see #setDelegatedScopes\n     * @see #DELEGATION_CERT_INSTALL\n     ",
    "links" : [ "#DELEGATION_CERT_INSTALL", "android.app.admin.DeviceAdminReceiver", "#setDelegatedScopes" ]
  }, {
    "name" : "public List<byte[]> getInstalledCaCerts(@Nullable ComponentName admin)",
    "returnType" : "List<byte[]>",
    "comment" : "\n     * Returns all CA certificates that are currently trusted, excluding system CA certificates.\n     * If a user has installed any certificates by other means than device policy these will be\n     * included too.\n     *\n     * @param admin Which {@link DeviceAdminReceiver} this request is associated with, or\n     *              {@code null} if calling from a delegated certificate installer.\n     * @return a List of byte[] arrays, each encoding one user CA certificate.\n     * @throws SecurityException if {@code admin} is not {@code null} and not a device or profile\n     *         owner.\n     ",
    "links" : [ "android.app.admin.DeviceAdminReceiver" ]
  }, {
    "name" : "public void uninstallAllUserCaCerts(@Nullable ComponentName admin)",
    "returnType" : "void",
    "comment" : "\n     * Uninstalls all custom trusted CA certificates from the profile. Certificates installed by\n     * means other than device policy will also be removed, except for system CA certificates.\n     *\n     * @param admin Which {@link DeviceAdminReceiver} this request is associated with, or\n     *              {@code null} if calling from a delegated certificate installer.\n     * @throws SecurityException if {@code admin} is not {@code null} and not a device or profile\n     *         owner.\n     ",
    "links" : [ "android.app.admin.DeviceAdminReceiver" ]
  }, {
    "name" : "public boolean hasCaCertInstalled(@Nullable ComponentName admin, byte[] certBuffer)",
    "returnType" : "boolean",
    "comment" : "\n     * Returns whether this certificate is installed as a trusted CA.\n     *\n     * @param admin Which {@link DeviceAdminReceiver} this request is associated with, or\n     *              {@code null} if calling from a delegated certificate installer.\n     * @param certBuffer encoded form of the certificate to look up.\n     * @throws SecurityException if {@code admin} is not {@code null} and not a device or profile\n     *         owner.\n     ",
    "links" : [ "android.app.admin.DeviceAdminReceiver" ]
  }, {
    "name" : "public boolean installKeyPair(@Nullable ComponentName admin, @NonNull PrivateKey privKey, @NonNull Certificate cert, @NonNull String alias)",
    "returnType" : "boolean",
    "comment" : "\n     * This API can be called by the following to install a certificate and corresponding\n     * private key:\n     * <ul>\n     *    <li>Device owner</li>\n     *    <li>Profile owner</li>\n     *    <li>Delegated certificate installer</li>\n     *    <li>Credential management app</li>\n     *    <li>An app that holds the\n     *    {@link android.Manifest.permission#MANAGE_DEVICE_POLICY_CERTIFICATES} permission</li>\n     * </ul>\n     * All apps within the profile will be able to access the certificate and use the private key,\n     * given direct user approval.\n     *\n     * <p>From Android {@link android.os.Build.VERSION_CODES#S}, the credential management app\n     * can call this API. However, this API sets the key pair as user selectable by default,\n     * which is not permitted when called by the credential management app. Instead,\n     * {@link #installKeyPair(ComponentName, PrivateKey, Certificate[], String, int)} should be\n     * called with {@link #INSTALLKEY_SET_USER_SELECTABLE} not set as a flag.\n     *\n     * <p>Access to the installed credentials will not be granted to the caller of this API without\n     * direct user approval. This is for security - should a certificate installer become\n     * compromised, certificates it had already installed will be protected.\n     *\n     * <p>If the installer must have access to the credentials, call\n     * {@link #installKeyPair(ComponentName, PrivateKey, Certificate[], String, boolean)} instead.\n     *\n     * <p>Note: If the provided {@code alias} is of an existing alias, all former grants that apps\n     * have been given to access the key and certificates associated with this alias will be\n     * revoked.\n     *\n     * @param admin Which {@link DeviceAdminReceiver} this request is associated with, or\n     *            {@code null} if the caller is not a device admin.\n     * @param privKey The private key to install.\n     * @param cert The certificate to install.\n     * @param alias The private key alias under which to install the certificate. If a certificate\n     * with that alias already exists, it will be overwritten.\n     * @return {@code true} if the keys were installed, {@code false} otherwise.\n     * @throws SecurityException if {@code admin} is not {@code null} and not a device or profile\n     *         owner, or {@code admin} is null and the calling application does not have the\n     *         {@link android.Manifest.permission#MANAGE_DEVICE_POLICY_CERTIFICATES} permission.\n     * @see #setDelegatedScopes\n     * @see #DELEGATION_CERT_INSTALL\n     ",
    "links" : [ "android.Manifest.permission#MANAGE_DEVICE_POLICY_CERTIFICATES", "android.app.admin.DeviceAdminReceiver", "android.os.Build.VERSION_CODES#S", "#installKeyPair(ComponentName", "#INSTALLKEY_SET_USER_SELECTABLE" ]
  }, {
    "name" : "public boolean installKeyPair(@Nullable ComponentName admin, @NonNull PrivateKey privKey, @NonNull Certificate[] certs, @NonNull String alias, boolean requestAccess)",
    "returnType" : "boolean",
    "comment" : "\n     * This API can be called by the following to install a certificate chain and corresponding\n     * private key for the leaf certificate:\n     * <ul>\n     *    <li>Device owner</li>\n     *    <li>Profile owner</li>\n     *    <li>Delegated certificate installer</li>\n     *    <li>Credential management app</li>\n     *    <li>An app that holds the\n     *    {@link android.Manifest.permission#MANAGE_DEVICE_POLICY_CERTIFICATES} permission</li>\n     * </ul>\n     * All apps within the profile will be able to access the certificate chain and use the private\n     * key, given direct user approval.\n     *\n     * <p>From Android {@link android.os.Build.VERSION_CODES#S}, the credential management app\n     * can call this API. However, this API sets the key pair as user selectable by default,\n     * which is not permitted when called by the credential management app. Instead,\n     * {@link #installKeyPair(ComponentName, PrivateKey, Certificate[], String, int)} should be\n     * called with {@link #INSTALLKEY_SET_USER_SELECTABLE} not set as a flag.\n     * Note, there can only be a credential management app on an unmanaged device.\n     *\n     * <p>The caller of this API may grant itself access to the certificate and private key\n     * immediately, without user approval. It is a best practice not to request this unless strictly\n     * necessary since it opens up additional security vulnerabilities.\n     *\n     * <p>Note: If the provided {@code alias} is of an existing alias, all former grants that apps\n     * have been given to access the key and certificates associated with this alias will be\n     * revoked.\n     *\n     * @param admin Which {@link DeviceAdminReceiver} this request is associated with, or\n     *        {@code null} if the caller is not a device admin.\n     * @param privKey The private key to install.\n     * @param certs The certificate chain to install. The chain should start with the leaf\n     *        certificate and include the chain of trust in order. This will be returned by\n     *        {@link android.security.KeyChain#getCertificateChain}.\n     * @param alias The private key alias under which to install the certificate. If a certificate\n     *        with that alias already exists, it will be overwritten.\n     * @param requestAccess {@code true} to request that the calling app be granted access to the\n     *        credentials immediately. Otherwise, access to the credentials will be gated by user\n     *        approval.\n     * @return {@code true} if the keys were installed, {@code false} otherwise.\n     * @throws SecurityException if {@code admin} is not {@code null} and not a device or profile\n     *         owner, or {@code admin} is null and the calling application does not have the\n     *         {@link android.Manifest.permission#MANAGE_DEVICE_POLICY_CERTIFICATES} permission.\n     * @see android.security.KeyChain#getCertificateChain\n     * @see #setDelegatedScopes\n     * @see #DELEGATION_CERT_INSTALL\n     ",
    "links" : [ "android.Manifest.permission#MANAGE_DEVICE_POLICY_CERTIFICATES", "android.app.admin.DeviceAdminReceiver", "android.security.KeyChain#getCertificateChain", "android.os.Build.VERSION_CODES#S", "#installKeyPair(ComponentName", "#INSTALLKEY_SET_USER_SELECTABLE" ]
  }, {
    "name" : "public boolean installKeyPair(@Nullable ComponentName admin, @NonNull PrivateKey privKey, @NonNull Certificate[] certs, @NonNull String alias, int flags)",
    "returnType" : "boolean",
    "comment" : "\n     * This API can be called by the following to install a certificate chain and corresponding\n     * private key for the leaf certificate:\n     * <ul>\n     *    <li>Device owner</li>\n     *    <li>Profile owner</li>\n     *    <li>Delegated certificate installer</li>\n     *    <li>Credential management app</li>\n     *    <li>An app that holds the\n     *    {@link android.Manifest.permission#MANAGE_DEVICE_POLICY_CERTIFICATES} permission</li>\n     * </ul>\n     * All apps within the profile will be able to access the certificate chain and use the\n     * private key, given direct user approval (if the user is allowed to select the private key).\n     *\n     * <p>From Android {@link android.os.Build.VERSION_CODES#S}, the credential management app\n     * can call this API. If called by the credential management app:\n     * <ul>\n     *    <li>The componentName must be {@code null}r</li>\n     *    <li>The alias must exist in the credential management app's\n     *    {@link android.security.AppUriAuthenticationPolicy}</li>\n     *    <li>The key pair must not be user selectable</li>\n     * </ul>\n     * Note, there can only be a credential management app on an unmanaged device.\n     *\n     * <p>The caller of this API may grant itself access to the certificate and private key\n     * immediately, without user approval. It is a best practice not to request this unless strictly\n     * necessary since it opens up additional security vulnerabilities.\n     *\n     * <p>Include {@link #INSTALLKEY_SET_USER_SELECTABLE} in the {@code flags} argument to allow\n     * the user to select the key from a dialog.\n     *\n     * <p>Note: If the provided {@code alias} is of an existing alias, all former grants that apps\n     * have been given to access the key and certificates associated with this alias will be\n     * revoked.\n     *\n     * @param admin Which {@link DeviceAdminReceiver} this request is associated with, or\n     *        {@code null} if the caller is not a device admin.\n     * @param privKey The private key to install.\n     * @param certs The certificate chain to install. The chain should start with the leaf\n     *        certificate and include the chain of trust in order. This will be returned by\n     *        {@link android.security.KeyChain#getCertificateChain}.\n     * @param alias The private key alias under which to install the certificate. If a certificate\n     *        with that alias already exists, it will be overwritten.\n     * @param flags Flags to request that the calling app be granted access to the credentials\n     *        and set the key to be user-selectable. See {@link #INSTALLKEY_SET_USER_SELECTABLE} and\n     *        {@link #INSTALLKEY_REQUEST_CREDENTIALS_ACCESS}.\n     * @return {@code true} if the keys were installed, {@code false} otherwise.\n     * @throws SecurityException if {@code admin} is not {@code null} and not a device or\n     *        profile owner, or {@code admin} is null but the calling application is not a\n     *        delegated certificate installer, credential management app and does not have the\n     *        {@link android.Manifest.permission#MANAGE_DEVICE_POLICY_CERTIFICATES} permission.\n     * @see android.security.KeyChain#getCertificateChain\n     * @see #setDelegatedScopes\n     * @see #DELEGATION_CERT_INSTALL\n     ",
    "links" : [ "android.Manifest.permission#MANAGE_DEVICE_POLICY_CERTIFICATES", "android.app.admin.DeviceAdminReceiver", "android.security.KeyChain#getCertificateChain", "android.os.Build.VERSION_CODES#S", "#INSTALLKEY_SET_USER_SELECTABLE", "#INSTALLKEY_REQUEST_CREDENTIALS_ACCESS", "android.security.AppUriAuthenticationPolicy" ]
  }, {
    "name" : "public boolean removeKeyPair(@Nullable ComponentName admin, @NonNull String alias)",
    "returnType" : "boolean",
    "comment" : "\n     * This API can be called by the following to remove a certificate and private key pair\n     * installed under a given alias:\n     * <ul>\n     *    <li>Device owner</li>\n     *    <li>Profile owner</li>\n     *    <li>Delegated certificate installer</li>\n     *    <li>Credential management app</li>\n     * </ul>\n     *\n     * <p>From Android {@link android.os.Build.VERSION_CODES#S}, the credential management app\n     * can call this API. If called by the credential management app, the componentName must be\n     * {@code null}. Note, there can only be a credential management app on an unmanaged device.\n     *\n     * @param admin Which {@link DeviceAdminReceiver} this request is associated with, or\n     *        {@code null} if the caller is not a device admin.\n     * @param alias The private key alias under which the certificate is installed.\n     * @return {@code true} if the private key alias no longer exists, {@code false} otherwise.\n     * @throws SecurityException if {@code admin} is not {@code null} and not a device or profile\n     *         owner, or {@code admin} is null but the calling application is not a delegated\n     *         certificate installer or credential management app.\n     * @see #setDelegatedScopes\n     * @see #DELEGATION_CERT_INSTALL\n     ",
    "links" : [ "android.app.admin.DeviceAdminReceiver", "android.os.Build.VERSION_CODES#S" ]
  }, {
    "name" : "public boolean hasKeyPair(@NonNull String alias)",
    "returnType" : "boolean",
    "comment" : "\n     * This API can be called by the following to query whether a certificate and private key are\n     * installed under a given alias:\n     * <ul>\n     *    <li>Device owner</li>\n     *    <li>Profile owner</li>\n     *    <li>Delegated certificate installer</li>\n     *    <li>Credential management app</li>\n     *    <li>An app that holds the\n     *    {@link android.Manifest.permission#MANAGE_DEVICE_POLICY_CERTIFICATES} permission</li>\n     * </ul>\n     *\n     * If called by the credential management app, the alias must exist in the credential\n     * management app's {@link android.security.AppUriAuthenticationPolicy}.\n     *\n     * @param alias The alias under which the key pair is installed.\n     * @return {@code true} if a key pair with this alias exists, {@code false} otherwise.\n     * @throws SecurityException if the caller is not a device or profile owner, a delegated\n     *         certificate installer, the credential management app and does not have the\n     *         {@link android.Manifest.permission#MANAGE_DEVICE_POLICY_CERTIFICATES} permission.\n     * @see #setDelegatedScopes\n     * @see #DELEGATION_CERT_INSTALL\n     ",
    "links" : [ "android.Manifest.permission#MANAGE_DEVICE_POLICY_CERTIFICATES", "android.security.AppUriAuthenticationPolicy" ]
  }, {
    "name" : "public AttestedKeyPair generateKeyPair(@Nullable ComponentName admin, @NonNull String algorithm, @NonNull KeyGenParameterSpec keySpec, @AttestationIdType int idAttestationFlags)",
    "returnType" : "AttestedKeyPair",
    "comment" : "\n     * This API can be called by the following to generate a new private/public key pair:\n     * <ul>\n     *    <li>Device owner</li>\n     *    <li>Profile owner</li>\n     *    <li>Delegated certificate installer</li>\n     *    <li>Credential management app</li>\n     *    <li>An app that holds the\n     *    {@link android.Manifest.permission#MANAGE_DEVICE_POLICY_CERTIFICATES} permission</li>\n     * </ul>\n     * If the device supports key generation via secure hardware, this method is useful for\n     * creating a key in KeyChain that never left the secure hardware. Access to the key is\n     * controlled the same way as in {@link #installKeyPair}.\n     *\n     * <p>From Android {@link android.os.Build.VERSION_CODES#S}, the credential management app\n     * can call this API. If called by the credential management app, the componentName must be\n     * {@code null}. Note, there can only be a credential management app on an unmanaged device.\n     *\n     * <p>Because this method might take several seconds to complete, it should only be called from\n     * a worker thread. This method returns {@code null} when called from the main thread.\n     *\n     * <p>This method is not thread-safe, calling it from multiple threads at the same time will\n     * result in undefined behavior. If the calling thread is interrupted while the invocation is\n     * in-flight, it will eventually terminate and return {@code null}.\n     *\n     * <p>Note: If the provided {@code alias} is of an existing alias, all former grants that apps\n     * have been given to access the key and certificates associated with this alias will be\n     * revoked.\n     *\n     * <p>Attestation: to enable attestation, set an attestation challenge in {@code keySpec} via\n     * {@link KeyGenParameterSpec.Builder#setAttestationChallenge}. By specifying flags to the\n     * {@code idAttestationFlags} parameter, it is possible to request the device's unique\n     * identity to be included in the attestation record.\n     *\n     * <p>Specific identifiers can be included in the attestation record, and an individual\n     * attestation certificate can be used to sign the attestation record. To find out if the device\n     * supports these features, refer to {@link #isDeviceIdAttestationSupported()} and\n     * {@link #isUniqueDeviceAttestationSupported()}.\n     *\n     * <p>Device owner, profile owner, their delegated certificate installer and the credential\n     * management app can use {@link #ID_TYPE_BASE_INFO} to request inclusion of the general device\n     * information including manufacturer, model, brand, device and product in the attestation\n     * record.\n     * Only device owner, profile owner on an organization-owned device or affiliated user, and\n     * their delegated certificate installers can use {@link #ID_TYPE_SERIAL}, {@link #ID_TYPE_IMEI}\n     * and {@link #ID_TYPE_MEID} to request unique device identifiers to be attested (the serial\n     * number, IMEI and MEID correspondingly), if supported by the device\n     * (see {@link #isDeviceIdAttestationSupported()}).\n     * Additionally, device owner, profile owner on an organization-owned device and their delegated\n     * certificate installers can also request the attestation record to be signed using an\n     * individual attestation certificate by specifying the {@link #ID_TYPE_INDIVIDUAL_ATTESTATION}\n     * flag (if supported by the device, see {@link #isUniqueDeviceAttestationSupported()}).\n     * <p>\n     * If any of {@link #ID_TYPE_SERIAL}, {@link #ID_TYPE_IMEI} and {@link #ID_TYPE_MEID}\n     * is set, it is implicitly assumed that {@link #ID_TYPE_BASE_INFO} is also set.\n     * <p>\n     * Attestation using {@link #ID_TYPE_INDIVIDUAL_ATTESTATION} can only be requested if\n     * key generation is done in StrongBox.\n     *\n     * @param admin Which {@link DeviceAdminReceiver} this request is associated with, or\n     *            {@code null} if the caller is not a device admin.\n     * @param algorithm The key generation algorithm, see {@link java.security.KeyPairGenerator}.\n     * @param keySpec Specification of the key to generate, see\n     * {@link java.security.KeyPairGenerator}.\n     * @param idAttestationFlags A bitmask of the identifiers that should be included in the\n     *        attestation record ({@code ID_TYPE_BASE_INFO}, {@code ID_TYPE_SERIAL},\n     *        {@code ID_TYPE_IMEI} and {@code ID_TYPE_MEID}), and\n     *        {@code ID_TYPE_INDIVIDUAL_ATTESTATION} if the attestation record should be signed\n     *        using an individual attestation certificate.\n     *        <p>\n     *        {@code 0} should be passed in if no device identification is required in the\n     *        attestation record and the batch attestation certificate should be used.\n     *        <p>\n     *        If any flag is specified, then an attestation challenge must be included in the\n     *        {@code keySpec}.\n     * @return A non-null {@code AttestedKeyPair} if the key generation succeeded, null otherwise.\n     * @throws SecurityException if {@code admin} is not {@code null} and not a device or profile\n     *         owner, or {@code admin} is null but the calling application is not a delegated\n     *         certificate installer or credential management app. If Device ID attestation is\n     *         requested (using {@link #ID_TYPE_SERIAL}, {@link #ID_TYPE_IMEI} or\n     *         {@link #ID_TYPE_MEID}), the caller must be the Device Owner or the Certificate\n     *         Installer delegate.\n     * @throws IllegalArgumentException in the following cases:\n     *         <p>\n     *         <ul>\n     *         <li>The alias in {@code keySpec} is empty.</li>\n     *         <li>The algorithm specification in {@code keySpec} is not\n     *         {@code RSAKeyGenParameterSpec} or {@code ECGenParameterSpec}.</li>\n     *         <li>Device ID attestation was requested but the {@code keySpec} does not contain an\n     *         attestation challenge.</li>\n     *         </ul>\n     * @throws UnsupportedOperationException if Device ID attestation or individual attestation\n     *         was requested but the underlying hardware does not support it.\n     * @throws StrongBoxUnavailableException if the use of StrongBox for key generation was\n     *         specified in {@code keySpec} but the device does not have one.\n     * @see KeyGenParameterSpec.Builder#setAttestationChallenge(byte[])\n     ",
    "links" : [ "java.security.KeyPairGenerator", "android.Manifest.permission#MANAGE_DEVICE_POLICY_CERTIFICATES", "#ID_TYPE_BASE_INFO", "#isDeviceIdAttestationSupported()", "#ID_TYPE_MEID", "#isUniqueDeviceAttestationSupported()", "#ID_TYPE_IMEI", "android.app.admin.DeviceAdminReceiver", "android.os.Build.VERSION_CODES#S", "KeyGenParameterSpec.Builder#setAttestationChallenge", "#ID_TYPE_SERIAL", "#ID_TYPE_INDIVIDUAL_ATTESTATION", "#installKeyPair" ]
  }, {
    "name" : "public boolean grantKeyPairToApp(@Nullable ComponentName admin, @NonNull String alias, @NonNull String packageName)",
    "returnType" : "boolean",
    "comment" : "\n     * Called by a device or profile owner, or delegated certificate chooser (an app that has been\n     * delegated the {@link #DELEGATION_CERT_SELECTION} privilege), to grant an application access\n     * to an already-installed (or generated) KeyChain key.\n     * This is useful (in combination with {@link #installKeyPair} or {@link #generateKeyPair}) to\n     * let an application call {@link android.security.KeyChain#getPrivateKey} without having to\n     * call {@link android.security.KeyChain#choosePrivateKeyAlias} first.\n     *\n     * The grantee app will receive the {@link android.security.KeyChain#ACTION_KEY_ACCESS_CHANGED}\n     * broadcast when access to a key is granted.\n     *\n     * Starting from {@link android.os.Build.VERSION_CODES#UPSIDE_DOWN_CAKE} throws an\n     * {@link IllegalArgumentException} if {@code alias} doesn't correspond to an existing key.\n     *\n     * @param admin Which {@link DeviceAdminReceiver} this request is associated with, or\n     *        {@code null} if calling from a delegated certificate chooser.\n     * @param alias The alias of the key to grant access to.\n     * @param packageName The name of the (already installed) package to grant access to.\n     * @return {@code true} if the grant was set successfully, {@code false} otherwise.\n     *\n     * @throws SecurityException if the caller is not a device owner, a profile owner or\n     *         delegated certificate chooser.\n     * @throws IllegalArgumentException if {@code packageName} or {@code alias} are empty, or if\n     *         {@code packageName} is not a name of an installed package.\n     * @see #revokeKeyPairFromApp\n     ",
    "links" : [ "android.security.KeyChain#getPrivateKey", "android.os.Build.VERSION_CODES#UPSIDE_DOWN_CAKE", "android.app.admin.DeviceAdminReceiver", "android.security.KeyChain#ACTION_KEY_ACCESS_CHANGED", "#DELEGATION_CERT_SELECTION", "android.security.KeyChain#choosePrivateKeyAlias", "#generateKeyPair", "#installKeyPair", "IllegalArgumentException" ]
  }, {
    "name" : "public Map<Integer, Set<String>> getKeyPairGrants(@NonNull String alias)",
    "returnType" : "Map<Integer, Set<String>>",
    "comment" : "\n     * Called by a device or profile owner, or delegated certificate chooser (an app that has been\n     * delegated the {@link #DELEGATION_CERT_SELECTION} privilege), to query which apps have access\n     * to a given KeyChain key.\n     *\n     * Key are granted on a per-UID basis, so if several apps share the same UID, granting access to\n     * one of them automatically grants it to others. This method returns a map containing one entry\n     * per grantee UID. Entries have UIDs as keys and sets of corresponding package names as values.\n     * In particular, grantee packages that don't share UID with other packages are represented by\n     * entries having singleton sets as values.\n     *\n     * @param alias The alias of the key to grant access to.\n     * @return apps that have access to a given key, arranged in a map from UID to sets of\n     *       package names.\n     *\n     * @throws SecurityException if the caller is not a device owner, a profile owner or\n     *         delegated certificate chooser.\n     * @throws IllegalArgumentException if {@code alias} doesn't correspond to an existing key.\n     *\n     * @see #grantKeyPairToApp(ComponentName, String, String)\n     ",
    "links" : [ "#DELEGATION_CERT_SELECTION" ]
  }, {
    "name" : "public boolean revokeKeyPairFromApp(@Nullable ComponentName admin, @NonNull String alias, @NonNull String packageName)",
    "returnType" : "boolean",
    "comment" : "\n     * Called by a device or profile owner, or delegated certificate chooser (an app that has been\n     * delegated the {@link #DELEGATION_CERT_SELECTION} privilege), to revoke an application's\n     * grant to a KeyChain key pair.\n     * Calls by the application to {@link android.security.KeyChain#getPrivateKey}\n     * will fail after the grant is revoked.\n     *\n     * The grantee app will receive the {@link android.security.KeyChain#ACTION_KEY_ACCESS_CHANGED}\n     * broadcast when access to a key is revoked.\n     *\n     * Starting from {@link android.os.Build.VERSION_CODES#UPSIDE_DOWN_CAKE} throws an\n     * {@link IllegalArgumentException} if {@code alias} doesn't correspond to an existing key.\n     *\n     * @param admin Which {@link DeviceAdminReceiver} this request is associated with, or\n     *        {@code null} if calling from a delegated certificate chooser.\n     * @param alias The alias of the key to revoke access from.\n     * @param packageName The name of the (already installed) package to revoke access from.\n     * @return {@code true} if the grant was revoked successfully, {@code false} otherwise.\n     *\n     * @throws SecurityException if the caller is not a device owner, a profile owner or\n     *         delegated certificate chooser.\n     * @throws IllegalArgumentException if {@code packageName} or {@code alias} are empty, or if\n     *         {@code packageName} is not a name of an installed package.\n     * @see #grantKeyPairToApp\n     ",
    "links" : [ "android.security.KeyChain#getPrivateKey", "android.os.Build.VERSION_CODES#UPSIDE_DOWN_CAKE", "android.app.admin.DeviceAdminReceiver", "android.security.KeyChain#ACTION_KEY_ACCESS_CHANGED", "#DELEGATION_CERT_SELECTION", "IllegalArgumentException" ]
  }, {
    "name" : "public boolean grantKeyPairToWifiAuth(@NonNull String alias)",
    "returnType" : "boolean",
    "comment" : "\n     * Called by a device or profile owner, or delegated certificate chooser (an app that has been\n     * delegated the {@link #DELEGATION_CERT_SELECTION} privilege), to allow using a KeyChain key\n     * pair for authentication to Wifi networks. The key can then be used in configurations passed\n     * to {@link android.net.wifi.WifiManager#addNetwork}.\n     *\n     * Starting from {@link android.os.Build.VERSION_CODES#UPSIDE_DOWN_CAKE} throws an\n     * {@link IllegalArgumentException} if {@code alias} doesn't correspond to an existing key.\n     *\n     * @param alias The alias of the key pair.\n     * @return {@code true} if the operation was set successfully, {@code false} otherwise.\n     *\n     * @throws SecurityException if the caller is not a device owner, a profile owner or\n     *         delegated certificate chooser.\n     * @see #revokeKeyPairFromWifiAuth\n     ",
    "links" : [ "android.os.Build.VERSION_CODES#UPSIDE_DOWN_CAKE", "android.net.wifi.WifiManager#addNetwork", "#DELEGATION_CERT_SELECTION", "IllegalArgumentException" ]
  }, {
    "name" : "public boolean revokeKeyPairFromWifiAuth(@NonNull String alias)",
    "returnType" : "boolean",
    "comment" : "\n     * Called by a device or profile owner, or delegated certificate chooser (an app that has been\n     * delegated the {@link #DELEGATION_CERT_SELECTION} privilege), to deny using a KeyChain key\n     * pair for authentication to Wifi networks. Configured networks using this key won't be able to\n     * authenticate.\n     *\n     * Starting from {@link android.os.Build.VERSION_CODES#UPSIDE_DOWN_CAKE} throws an\n     * {@link IllegalArgumentException} if {@code alias} doesn't correspond to an existing key.\n     *\n     * @param alias The alias of the key pair.\n     * @return {@code true} if the operation was set successfully, {@code false} otherwise.\n     *\n     * @throws SecurityException if the caller is not a device owner, a profile owner or\n     *         delegated certificate chooser.\n     * @see #grantKeyPairToWifiAuth\n     ",
    "links" : [ "android.os.Build.VERSION_CODES#UPSIDE_DOWN_CAKE", "#DELEGATION_CERT_SELECTION", "IllegalArgumentException" ]
  }, {
    "name" : "public boolean isKeyPairGrantedToWifiAuth(@NonNull String alias)",
    "returnType" : "boolean",
    "comment" : "\n     * Called by a device or profile owner, or delegated certificate chooser (an app that has been\n     * delegated the {@link #DELEGATION_CERT_SELECTION} privilege), to query whether a KeyChain key\n     * pair can be used for authentication to Wifi networks.\n     *\n     * @param alias The alias of the key pair.\n     * @return {@code true} if the key pair can be used, {@code false} otherwise.\n     *\n     * @throws SecurityException if the caller is not a device owner, a profile owner or\n     *         delegated certificate chooser.\n     * @see #grantKeyPairToWifiAuth\n     ",
    "links" : [ "#DELEGATION_CERT_SELECTION" ]
  }, {
    "name" : "public boolean isDeviceIdAttestationSupported()",
    "returnType" : "boolean",
    "comment" : "\n     * Returns {@code true} if the device supports attestation of device identifiers in addition\n     * to key attestation. See\n     * {@link #generateKeyPair(ComponentName, String, KeyGenParameterSpec, int)}\n     * @return {@code true} if Device ID attestation is supported.\n     ",
    "links" : [ "#generateKeyPair(ComponentName" ]
  }, {
    "name" : "public boolean isUniqueDeviceAttestationSupported()",
    "returnType" : "boolean",
    "comment" : "\n     * Returns {@code true} if the StrongBox Keymaster implementation on the device was provisioned\n     * with an individual attestation certificate and can sign attestation records using it (as\n     * attestation using an individual attestation certificate is a feature only Keymaster\n     * implementations with StrongBox security level can implement).\n     * For use prior to calling\n     * {@link #generateKeyPair(ComponentName, String, KeyGenParameterSpec, int)}.\n     * @return {@code true} if individual attestation is supported.\n     ",
    "links" : [ "#generateKeyPair(ComponentName" ]
  }, {
    "name" : "public boolean setKeyPairCertificate(@Nullable ComponentName admin, @NonNull String alias, @NonNull List<Certificate> certs, boolean isUserSelectable)",
    "returnType" : "boolean",
    "comment" : "\n     * This API can be called by the following to associate certificates with a key pair that was\n     * generated using {@link #generateKeyPair}, and set whether the key is available for the user\n     * to choose in the certificate selection prompt:\n     * <ul>\n     *    <li>Device owner</li>\n     *    <li>Profile owner</li>\n     *    <li>Delegated certificate installer</li>\n     *    <li>Credential management app</li>\n     * </ul>\n     *\n     * <p>From Android {@link android.os.Build.VERSION_CODES#S}, the credential management app\n     * can call this API. If called by the credential management app, the componentName must be\n     * {@code null}. Note, there can only be a credential management app on an unmanaged device.\n     *\n     * @param admin Which {@link DeviceAdminReceiver} this request is associated with, or\n     *            {@code null} if the caller is not a device admin.\n     * @param alias The private key alias under which to install the certificate. The {@code alias}\n     *        should denote an existing private key. If a certificate with that alias already\n     *        exists, it will be overwritten.\n     * @param certs The certificate chain to install. The chain should start with the leaf\n     *        certificate and include the chain of trust in order. This will be returned by\n     *        {@link android.security.KeyChain#getCertificateChain}.\n     * @param isUserSelectable {@code true} to indicate that a user can select this key via the\n     *        certificate selection prompt, {@code false} to indicate that this key can only be\n     *        granted access by implementing\n     *        {@link android.app.admin.DeviceAdminReceiver#onChoosePrivateKeyAlias}.\n     * @return {@code true} if the provided {@code alias} exists and the certificates has been\n     *        successfully associated with it, {@code false} otherwise.\n     * @throws SecurityException if {@code admin} is not {@code null} and not a device or profile\n     *         owner, or {@code admin} is null but the calling application is not a delegated\n     *         certificate installer or credential management app.\n     ",
    "links" : [ "android.app.admin.DeviceAdminReceiver", "android.security.KeyChain#getCertificateChain", "android.os.Build.VERSION_CODES#S", "android.app.admin.DeviceAdminReceiver#onChoosePrivateKeyAlias", "#generateKeyPair" ]
  }, {
    "name" : "private static String getCaCertAlias(byte[] certBuffer) throws CertificateException",
    "returnType" : "String",
    "comment" : "\n     * @return the alias of a given CA certificate in the certificate store, or {@code null} if it\n     * doesn't exist.\n     ",
    "links" : [ ]
  }, {
    "name" : "public void setCertInstallerPackage(@NonNull ComponentName admin, @Nullable String installerPackage) throws SecurityException",
    "returnType" : "void",
    "comment" : "\n     * Called by a profile owner or device owner to grant access to privileged certificate\n     * manipulation APIs to a third-party certificate installer app. Granted APIs include\n     * {@link #getInstalledCaCerts}, {@link #hasCaCertInstalled}, {@link #installCaCert},\n     * {@link #uninstallCaCert}, {@link #uninstallAllUserCaCerts} and {@link #installKeyPair}.\n     * <p>\n     * Delegated certificate installer is a per-user state. The delegated access is persistent until\n     * it is later cleared by calling this method with a null value or uninstallling the certificate\n     * installer.\n     * <p>\n     * <b>Note:</b>Starting from {@link android.os.Build.VERSION_CODES#N}, if the caller\n     * application's target SDK version is {@link android.os.Build.VERSION_CODES#N} or newer, the\n     * supplied certificate installer package must be installed when calling this API, otherwise an\n     * {@link IllegalArgumentException} will be thrown.\n     *\n     * @param admin Which {@link DeviceAdminReceiver} this request is associated with.\n     * @param installerPackage The package name of the certificate installer which will be given\n     *            access. If {@code null} is given the current package will be cleared.\n     * @throws SecurityException if {@code admin} is not a device or a profile owner.\n     *\n     * @deprecated From {@link android.os.Build.VERSION_CODES#O}. Use {@link #setDelegatedScopes}\n     * with the {@link #DELEGATION_CERT_INSTALL} scope instead.\n     ",
    "links" : [ "android.os.Build.VERSION_CODES#O", "#DELEGATION_CERT_INSTALL", "#getInstalledCaCerts", "#uninstallCaCert", "android.app.admin.DeviceAdminReceiver", "#hasCaCertInstalled", "#installCaCert", "#uninstallAllUserCaCerts", "#installKeyPair", "android.os.Build.VERSION_CODES#N", "IllegalArgumentException", "#setDelegatedScopes" ]
  }, {
    "name" : "public String getCertInstallerPackage(@NonNull ComponentName admin) throws SecurityException",
    "returnType" : "String",
    "comment" : "\n     * Called by a profile owner or device owner to retrieve the certificate installer for the user,\n     * or {@code null} if none is set. If there are multiple delegates this function will return one\n     * of them.\n     *\n     * @param admin Which {@link DeviceAdminReceiver} this request is associated with.\n     * @return The package name of the current delegated certificate installer, or {@code null} if\n     *         none is set.\n     * @throws SecurityException if {@code admin} is not a device or a profile owner.\n     *\n     * @deprecated From {@link android.os.Build.VERSION_CODES#O}. Use {@link #getDelegatePackages}\n     * with the {@link #DELEGATION_CERT_INSTALL} scope instead.\n     ",
    "links" : [ "android.os.Build.VERSION_CODES#O", "#DELEGATION_CERT_INSTALL", "android.app.admin.DeviceAdminReceiver", "#getDelegatePackages" ]
  }, {
    "name" : "public void setDelegatedScopes(@NonNull ComponentName admin, @NonNull String delegatePackage, @NonNull List<String> scopes)",
    "returnType" : "void",
    "comment" : "\n     * Called by a profile owner or device owner to grant access to privileged APIs to another app.\n     * Granted APIs are determined by {@code scopes}, which is a list of the {@code DELEGATION_*}\n     * constants.\n     * <p>\n     * A broadcast with the {@link #ACTION_APPLICATION_DELEGATION_SCOPES_CHANGED} action will be\n     * sent to the {@code delegatePackage} with its new scopes in an {@code ArrayList<String>} extra\n     * under the {@link #EXTRA_DELEGATION_SCOPES} key. The broadcast is sent with the\n     * {@link Intent#FLAG_RECEIVER_REGISTERED_ONLY} flag.\n     * <p>\n     * Delegated scopes are a per-user state. The delegated access is persistent until it is later\n     * cleared by calling this method with an empty {@code scopes} list or uninstalling the\n     * {@code delegatePackage}.\n     *\n     * @param admin Which {@link DeviceAdminReceiver} this request is associated with.\n     * @param delegatePackage The package name of the app which will be given access.\n     * @param scopes The groups of privileged APIs whose access should be granted to\n     *            {@code delegatedPackage}.\n     * @throws SecurityException if {@code admin} is not a device or a profile owner.\n     ",
    "links" : [ "android.content.Intent#FLAG_RECEIVER_REGISTERED_ONLY", "android.app.admin.DeviceAdminReceiver", "#EXTRA_DELEGATION_SCOPES", "#ACTION_APPLICATION_DELEGATION_SCOPES_CHANGED" ]
  }, {
    "name" : "public List<String> getDelegatedScopes(@Nullable ComponentName admin, @NonNull String delegatedPackage)",
    "returnType" : "List<String>",
    "comment" : "\n     * Called by a profile owner or device owner to retrieve a list of the scopes given to a\n     * delegate package. Other apps can use this method to retrieve their own delegated scopes by\n     * passing {@code null} for {@code admin} and their own package name as\n     * {@code delegatedPackage}.\n     *\n     * @param admin Which {@link DeviceAdminReceiver} this request is associated with, or\n     *            {@code null} if the caller is {@code delegatedPackage}.\n     * @param delegatedPackage The package name of the app whose scopes should be retrieved.\n     * @return A list containing the scopes given to {@code delegatedPackage}.\n     * @throws SecurityException if {@code admin} is not a device or a profile owner.\n     ",
    "links" : [ "android.app.admin.DeviceAdminReceiver" ]
  }, {
    "name" : "public List<String> getDelegatePackages(@NonNull ComponentName admin, @NonNull String delegationScope)",
    "returnType" : "List<String>",
    "comment" : "\n     * Called by a profile owner or device owner to retrieve a list of delegate packages that were\n     * granted a delegation scope.\n     *\n     * @param admin Which {@link DeviceAdminReceiver} this request is associated with.\n     * @param delegationScope The scope whose delegates should be retrieved.\n     * @return A list of package names of the current delegated packages for\n               {@code delegationScope}.\n     * @throws SecurityException if {@code admin} is not a device or a profile owner.\n     ",
    "links" : [ "android.app.admin.DeviceAdminReceiver" ]
  }, {
    "name" : "public void setAlwaysOnVpnPackage(@NonNull ComponentName admin, @Nullable String vpnPackage, boolean lockdownEnabled) throws NameNotFoundException",
    "returnType" : "void",
    "comment" : "\n     * Called by a device or profile owner to configure an always-on VPN connection through a\n     * specific application for the current user. This connection is automatically granted and\n     * persisted after a reboot.\n     * <p> To support the always-on feature, an app must\n     * <ul>\n     *     <li>declare a {@link android.net.VpnService} in its manifest, guarded by\n     *         {@link android.Manifest.permission#BIND_VPN_SERVICE};</li>\n     *     <li>target {@link android.os.Build.VERSION_CODES#N API 24} or above; and</li>\n     *     <li><i>not</i> explicitly opt out of the feature through\n     *         {@link android.net.VpnService#SERVICE_META_DATA_SUPPORTS_ALWAYS_ON}.</li>\n     * </ul>\n     * The call will fail if called with the package name of an unsupported VPN app.\n     * <p> Enabling lockdown via {@code lockdownEnabled} argument carries the risk that any failure\n     * of the VPN provider could break networking for all apps. This method clears any lockdown\n     * allowlist set by {@link #setAlwaysOnVpnPackage(ComponentName, String, boolean, Set)}.\n     * <p> Starting from {@link android.os.Build.VERSION_CODES#S API 31} calling this method with\n     * {@code vpnPackage} set to {@code null} only removes the existing configuration if it was\n     * previously created by this admin. To remove VPN configuration created by the user use\n     * {@link UserManager#DISALLOW_CONFIG_VPN}.\n     *\n     * @param vpnPackage The package name for an installed VPN app on the device, or {@code null} to\n     *        remove an existing always-on VPN configuration.\n     * @param lockdownEnabled {@code true} to disallow networking when the VPN is not connected or\n     *        {@code false} otherwise. This has no effect when clearing.\n     * @throws SecurityException if {@code admin} is not a device or a profile owner.\n     * @throws NameNotFoundException if {@code vpnPackage} is not installed.\n     * @throws UnsupportedOperationException if {@code vpnPackage} exists but does not support being\n     *         set as always-on, or if always-on VPN is not available.\n     * @see #setAlwaysOnVpnPackage(ComponentName, String, boolean, Set)\n     ",
    "links" : [ "android.net.VpnService", "android.Manifest.permission#BIND_VPN_SERVICE", "android.os.UserManager#DISALLOW_CONFIG_VPN", "android.net.VpnService#SERVICE_META_DATA_SUPPORTS_ALWAYS_ON", "android.os.Build.VERSION_CODES#S", "#setAlwaysOnVpnPackage(ComponentName", "android.os.Build.VERSION_CODES#N" ]
  }, {
    "name" : "public void setAlwaysOnVpnPackage(@NonNull ComponentName admin, @Nullable String vpnPackage, boolean lockdownEnabled, @Nullable Set<String> lockdownAllowlist) throws NameNotFoundException",
    "returnType" : "void",
    "comment" : "\n     * A version of {@link #setAlwaysOnVpnPackage(ComponentName, String, boolean)} that allows the\n     * admin to specify a set of apps that should be able to access the network directly when VPN\n     * is not connected. When VPN connects these apps switch over to VPN if allowed to use that VPN.\n     * System apps can always bypass VPN.\n     * <p> Note that the system doesn't update the allowlist when packages are installed or\n     * uninstalled, the admin app must call this method to keep the list up to date.\n     * <p> When {@code lockdownEnabled} is false {@code lockdownAllowlist} is ignored . When\n     * {@code lockdownEnabled} is {@code true} and {@code lockdownAllowlist} is {@code null} or\n     * empty, only system apps can bypass VPN.\n     * <p> Setting always-on VPN package to {@code null} or using\n     * {@link #setAlwaysOnVpnPackage(ComponentName, String, boolean)} clears lockdown allowlist.\n     *\n     * @param vpnPackage package name for an installed VPN app on the device, or {@code null}\n     *         to remove an existing always-on VPN configuration\n     * @param lockdownEnabled {@code true} to disallow networking when the VPN is not connected or\n     *         {@code false} otherwise. This has no effect when clearing.\n     * @param lockdownAllowlist Packages that will be able to access the network directly when VPN\n     *         is in lockdown mode but not connected. Has no effect when clearing.\n     * @throws SecurityException if {@code admin} is not a device or a profile\n     *         owner.\n     * @throws NameNotFoundException if {@code vpnPackage} or one of\n     *         {@code lockdownAllowlist} is not installed.\n     * @throws UnsupportedOperationException if {@code vpnPackage} exists but does\n     *         not support being set as always-on, or if always-on VPN is not\n     *         available.\n     ",
    "links" : [ "#setAlwaysOnVpnPackage(ComponentName" ]
  }, {
    "name" : "public boolean isAlwaysOnVpnLockdownEnabled(@NonNull ComponentName admin)",
    "returnType" : "boolean",
    "comment" : "\n     * Called by device or profile owner to query whether current always-on VPN is configured in\n     * lockdown mode. Returns {@code false} when no always-on configuration is set.\n     *\n     * @param admin Which {@link DeviceAdminReceiver} this request is associated with.\n     *\n     * @throws SecurityException if {@code admin} is not a device or a profile owner.\n     *\n     * @see #setAlwaysOnVpnPackage(ComponentName, String, boolean)\n     ",
    "links" : [ "android.app.admin.DeviceAdminReceiver" ]
  }, {
    "name" : "public boolean isAlwaysOnVpnLockdownEnabled()",
    "returnType" : "boolean",
    "comment" : "\n     * Returns whether the admin has enabled always-on VPN lockdown for the current user.\n     *\n     * Only callable by the system.\n    * @hide\n    ",
    "links" : [ ]
  }, {
    "name" : "public Set<String> getAlwaysOnVpnLockdownWhitelist(@NonNull ComponentName admin)",
    "returnType" : "Set<String>",
    "comment" : "\n     * Called by device or profile owner to query the set of packages that are allowed to access\n     * the network directly when always-on VPN is in lockdown mode but not connected. Returns\n     * {@code null} when always-on VPN is not active or not in lockdown mode.\n     *\n     * @param admin Which {@link DeviceAdminReceiver} this request is associated with.\n     *\n     * @throws SecurityException if {@code admin} is not a device or a profile owner.\n     *\n     * @see #setAlwaysOnVpnPackage(ComponentName, String, boolean, Set)\n     ",
    "links" : [ "android.app.admin.DeviceAdminReceiver" ]
  }, {
    "name" : "public String getAlwaysOnVpnPackage(@NonNull ComponentName admin)",
    "returnType" : "String",
    "comment" : "\n     * Called by a device or profile owner to read the name of the package administering an\n     * always-on VPN connection for the current user. If there is no such package, or the always-on\n     * VPN is provided by the system instead of by an application, {@code null} will be returned.\n     *\n     * @return Package name of VPN controller responsible for always-on VPN, or {@code null} if none\n     *         is set.\n     * @throws SecurityException if {@code admin} is not a device or a profile owner.\n     ",
    "links" : [ ]
  }, {
    "name" : "public String getAlwaysOnVpnPackage()",
    "returnType" : "String",
    "comment" : "\n     * Returns the VPN package name if the admin has enabled always-on VPN on the current user,\n     * or {@code null} if none is set.\n     *\n     * Only callable by the system.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public void setCameraDisabled(@Nullable ComponentName admin, boolean disabled)",
    "returnType" : "void",
    "comment" : "\n     * Called by an application that is administering the device to disable all cameras on the\n     * device, for this user. After setting this, no applications running as this user will be able\n     * to access any cameras on the device.\n     * <p>\n     * This method can be called on the {@link DevicePolicyManager} instance,\n     * returned by {@link #getParentProfileInstance(ComponentName)}, where the caller must be\n     * the profile owner of an organization-owned managed profile.\n     * <p>\n     * If the caller is device owner, then the restriction will be applied to all users. If\n     * called on the parent instance, then the restriction will be applied on the personal profile.\n     * <p>\n     * The calling device admin must have requested\n     * {@link DeviceAdminInfo#USES_POLICY_DISABLE_CAMERA} to be able to call this method; if it has\n     * not, a security exception will be thrown.\n     * <p>\n     * <b>Note</b>, this policy type is deprecated for legacy device admins since\n     * {@link android.os.Build.VERSION_CODES#Q}. On Android\n     * {@link android.os.Build.VERSION_CODES#Q} devices, legacy device admins targeting SDK\n     * version {@link android.os.Build.VERSION_CODES#P} or below can still call this API to\n     * disable camera, while legacy device admins targeting SDK version\n     * {@link android.os.Build.VERSION_CODES#Q} will receive a SecurityException. Starting\n     * from Android {@link android.os.Build.VERSION_CODES#R}, requests to disable camera from\n     * legacy device admins targeting SDK version {@link android.os.Build.VERSION_CODES#P} or\n     * below will be silently ignored.\n     * <p>\n     * Starting from {@link Build.VERSION_CODES#UPSIDE_DOWN_CAKE}, after the camera disabled\n     * policy has been set, {@link PolicyUpdateReceiver#onPolicySetResult(Context, String,\n     * Bundle, TargetUser, PolicyUpdateResult)} will notify the admin on whether the policy was\n     * successfully set or not. This callback will contain:\n     * <ul>\n     * <li> The policy identifier: userRestriction_no_camera\n     * <li> The {@link TargetUser} that this policy relates to\n     * <li> The {@link PolicyUpdateResult}, which will be\n     * {@link PolicyUpdateResult#RESULT_POLICY_SET} if the policy was successfully set or the\n     * reason the policy failed to be set\n     * (e.g. {@link PolicyUpdateResult#RESULT_FAILURE_CONFLICTING_ADMIN_POLICY})\n     * </ul>\n     * If there has been a change to the policy,\n     * {@link PolicyUpdateReceiver#onPolicyChanged(Context, String, Bundle, TargetUser,\n     * PolicyUpdateResult)} will notify the admin of this change. This callback will contain the\n     * same parameters as PolicyUpdateReceiver#onPolicySetResult and the {@link PolicyUpdateResult}\n     * will contain the reason why the policy changed.\n     *\n     * @param admin Which {@link DeviceAdminReceiver} this request is associated with or null if\n                     the caller is not a device admin\n     * @param disabled Whether or not the camera should be disabled.\n     * @throws SecurityException if {@code admin} is not an active administrator or does not use\n     *             {@link DeviceAdminInfo#USES_POLICY_DISABLE_CAMERA}.\n     ",
    "links" : [ "android.app.admin.PolicyUpdateResult#RESULT_FAILURE_CONFLICTING_ADMIN_POLICY", "android.app.admin.PolicyUpdateResult#RESULT_POLICY_SET", "android.app.admin.PolicyUpdateReceiver#onPolicyChanged(Context", "android.app.admin.PolicyUpdateReceiver#onPolicySetResult(Context", "android.app.admin.TargetUser", "android.os.Build.VERSION_CODES#P", "#getParentProfileInstance(ComponentName)", "android.app.admin.DeviceAdminInfo#USES_POLICY_DISABLE_CAMERA", "android.os.Build.VERSION_CODES#R", "android.os.Build.VERSION_CODES#Q", "android.app.admin.PolicyUpdateResult", "android.app.admin.DeviceAdminReceiver", "android.app.admin.DevicePolicyManager", "Build.VERSION_CODES#UPSIDE_DOWN_CAKE" ]
  }, {
    "name" : "public boolean getCameraDisabled(@Nullable ComponentName admin)",
    "returnType" : "boolean",
    "comment" : "\n     * Determine whether or not the device's cameras have been disabled for this user,\n     * either by the calling admin, if specified, or all admins.\n     * <p>\n     * This method can be called on the {@link DevicePolicyManager} instance,\n     * returned by {@link #getParentProfileInstance(ComponentName)}, where the caller must be\n     * the profile owner of an organization-owned managed profile.\n     *\n     * @param admin The name of the admin component to check, or {@code null} to check whether any\n     *              admins have disabled the camera\n     ",
    "links" : [ "#getParentProfileInstance(ComponentName)", "android.app.admin.DevicePolicyManager" ]
  }, {
    "name" : "public boolean getCameraDisabled(@Nullable ComponentName admin, int userHandle)",
    "returnType" : "boolean",
    "comment" : " @hide per-user version ",
    "links" : [ ]
  }, {
    "name" : "public boolean requestBugreport(@NonNull ComponentName admin)",
    "returnType" : "boolean",
    "comment" : "\n     * Called by a device owner to request a bugreport.\n     * <p>\n     * If the device contains secondary users or profiles, they must be affiliated with the device.\n     * Otherwise a {@link SecurityException} will be thrown. See {@link #isAffiliatedUser}.\n     *\n     * @param admin Which {@link DeviceAdminReceiver} this request is associated with.\n     * @return {@code true} if the bugreport collection started successfully, or {@code false} if it\n     *         wasn't triggered because a previous bugreport operation is still active (either the\n     *         bugreport is still running or waiting for the user to share or decline)\n     * @throws SecurityException if {@code admin} is not a device owner, or there is at least one\n     *         profile or secondary user that is not affiliated with the device.\n     * @see #isAffiliatedUser\n     ",
    "links" : [ "#isAffiliatedUser", "android.app.admin.DeviceAdminReceiver", "SecurityException" ]
  }, {
    "name" : "public void setScreenCaptureDisabled(@Nullable ComponentName admin, boolean disabled)",
    "returnType" : "void",
    "comment" : "\n     * Called by a device/profile owner to set whether the screen capture is disabled. Disabling\n     * screen capture also prevents the content from being shown on display devices that do not have\n     * a secure video output. See {@link android.view.Display#FLAG_SECURE} for more details about\n     * secure surfaces and secure displays.\n     * <p>\n     * This method can be called on the {@link DevicePolicyManager} instance, returned by\n     * {@link #getParentProfileInstance(ComponentName)}, where the calling device admin must be\n     * the profile owner of an organization-owned managed profile. If it is not, a security\n     * exception will be thrown.\n     * <p>\n     * If the caller is device owner or called on the parent instance by a profile owner of an\n     * organization-owned managed profile, then the restriction will be applied to all users.\n     * <p>\n     * From version {@link android.os.Build.VERSION_CODES#M} disabling screen capture also blocks\n     * assist requests for all activities of the relevant user.\n     *\n     * @param admin Which {@link DeviceAdminReceiver} this request is associated with. Null if the\n     *              caller is not a device admin.\n     * @param disabled Whether screen capture is disabled or not.\n     * @throws SecurityException if the caller is not permitted to control screen capture policy.\n     ",
    "links" : [ "#getParentProfileInstance(ComponentName)", "android.view.Display#FLAG_SECURE", "android.app.admin.DeviceAdminReceiver", "android.app.admin.DevicePolicyManager", "android.os.Build.VERSION_CODES#M" ]
  }, {
    "name" : "public boolean getScreenCaptureDisabled(@Nullable ComponentName admin)",
    "returnType" : "boolean",
    "comment" : "\n     * Determine whether or not screen capture has been disabled by the calling\n     * admin, if specified, or all admins.\n     * <p>\n     * This method can be called on the {@link DevicePolicyManager} instance,\n     * returned by {@link #getParentProfileInstance(ComponentName)}, where the caller must be\n     * the profile owner of an organization-owned managed profile (the calling admin must be\n     * specified).\n     *\n     * @param admin The name of the admin component to check, or {@code null} to check whether any\n     *              admins have disabled screen capture.\n     ",
    "links" : [ "#getParentProfileInstance(ComponentName)", "android.app.admin.DevicePolicyManager" ]
  }, {
    "name" : "public boolean getScreenCaptureDisabled(@Nullable ComponentName admin, int userHandle)",
    "returnType" : "boolean",
    "comment" : " @hide per-user version ",
    "links" : [ ]
  }, {
    "name" : "public void setNearbyNotificationStreamingPolicy(@NearbyStreamingPolicy int policy)",
    "returnType" : "void",
    "comment" : "\n     * Called by a device/profile owner to set nearby notification streaming policy. Notification\n     * streaming is sending notification data from pre-installed apps to nearby devices.\n     *\n     * @param policy One of the {@code NearbyStreamingPolicy} constants.\n     * @throws SecurityException if caller is not a device or profile owner\n     ",
    "links" : [ ]
  }, {
    "name" : "public int getNearbyNotificationStreamingPolicy()",
    "returnType" : "int",
    "comment" : "\n     * Returns the current runtime nearby notification streaming policy set by the device or profile\n     * owner.\n     * <p>\n     * The caller must be the target user's device owner/profile owner or hold the\n     * {@link android.Manifest.permission#READ_NEARBY_STREAMING_POLICY READ_NEARBY_STREAMING_POLICY}\n     * permission.\n     ",
    "links" : [ "android.Manifest.permission#READ_NEARBY_STREAMING_POLICY" ]
  }, {
    "name" : "public int getNearbyNotificationStreamingPolicy(int userId)",
    "returnType" : "int",
    "comment" : " @hide per-user version ",
    "links" : [ ]
  }, {
    "name" : "public void setNearbyAppStreamingPolicy(@NearbyStreamingPolicy int policy)",
    "returnType" : "void",
    "comment" : "\n     * Called by a device/profile owner to set nearby app streaming policy. App streaming is when\n     * the device starts an app on a virtual display and sends a video stream of the app to nearby\n     * devices.\n     *\n     * @param policy One of the {@code NearbyStreamingPolicy} constants.\n     * @throws SecurityException if caller is not a device or profile owner.\n     ",
    "links" : [ ]
  }, {
    "name" : "public int getNearbyAppStreamingPolicy()",
    "returnType" : "int",
    "comment" : "\n     * Returns the current runtime nearby app streaming policy set by the device or profile owner.\n     * <p>\n     * The caller must be the target user's device owner/profile owner or hold the\n     * {@link android.Manifest.permission#READ_NEARBY_STREAMING_POLICY READ_NEARBY_STREAMING_POLICY}\n     * permission.\n     ",
    "links" : [ "android.Manifest.permission#READ_NEARBY_STREAMING_POLICY" ]
  }, {
    "name" : "public int getNearbyAppStreamingPolicy(int userId)",
    "returnType" : "int",
    "comment" : " @hide per-user version ",
    "links" : [ ]
  }, {
    "name" : "public void setAutoTimeRequired(@NonNull ComponentName admin, boolean required)",
    "returnType" : "void",
    "comment" : "\n     * Called by a device owner, or alternatively a profile owner from Android 8.0 (API level 26) or\n     * higher, to set whether auto time is required. If auto time is required, no user will be able\n     * set the date and time and network date and time will be used.\n     * <p>\n     * Note: If auto time is required the user can still manually set the time zone. Staring from\n     * Android 11, if auto time is required, the user cannot manually set the time zone.\n     * <p>\n     * The calling device admin must be a device owner, or alternatively a profile owner from\n     * Android 8.0 (API level 26) or higher. If it is not, a security exception will be thrown.\n     * <p>\n     * Staring from Android 11, this API switches to use\n     * {@link UserManager#DISALLOW_CONFIG_DATE_TIME} to enforce the auto time settings. Calling\n     * this API to enforce auto time will result in\n     * {@link UserManager#DISALLOW_CONFIG_DATE_TIME} being set, while calling this API to lift\n     * the requirement will result in {@link UserManager#DISALLOW_CONFIG_DATE_TIME} being cleared.\n     * From Android 11, this API can also no longer be called on a managed profile.\n     *\n     * @param admin Which {@link DeviceAdminReceiver} this request is associated with.\n     * @param required Whether auto time is set required or not.\n     * @throws SecurityException if {@code admin} is not a device owner, not a profile owner or\n     * if this API is called on a managed profile.\n     * @deprecated From {@link android.os.Build.VERSION_CODES#R}. Use {@link #setAutoTimeEnabled}\n     * to turn auto time on or off and use {@link UserManager#DISALLOW_CONFIG_DATE_TIME}\n     * to prevent the user from changing this setting.\n     ",
    "links" : [ "android.os.UserManager#DISALLOW_CONFIG_DATE_TIME", "android.os.Build.VERSION_CODES#R", "#setAutoTimeEnabled", "android.app.admin.DeviceAdminReceiver" ]
  }, {
    "name" : "public boolean getAutoTimeRequired()",
    "returnType" : "boolean",
    "comment" : "\n     * @return true if auto time is required.\n     * @deprecated From {@link android.os.Build.VERSION_CODES#R}. Use {@link #getAutoTimeEnabled}\n     ",
    "links" : [ "android.os.Build.VERSION_CODES#R", "#getAutoTimeEnabled" ]
  }, {
    "name" : "public void setAutoTimeEnabled(@Nullable ComponentName admin, boolean enabled)",
    "returnType" : "void",
    "comment" : "\n     * Called by a device owner, a profile owner for the primary user or a profile\n     * owner of an organization-owned managed profile to turn auto time on and off.\n     * Callers are recommended to use {@link UserManager#DISALLOW_CONFIG_DATE_TIME}\n     * to prevent the user from changing this setting.\n     * <p>\n     * If user restriction {@link UserManager#DISALLOW_CONFIG_DATE_TIME} is used,\n     * no user will be able set the date and time. Instead, the network date\n     * and time will be used.\n     *\n     * @param admin Which {@link DeviceAdminReceiver} this request is associated with. Null if the\n     *              caller is not a device admin.\n     * @param enabled Whether time should be obtained automatically from the network or not.\n     * @throws SecurityException if caller is not a device owner, a profile owner for the\n     * primary user, or a profile owner of an organization-owned managed profile.\n     ",
    "links" : [ "android.os.UserManager#DISALLOW_CONFIG_DATE_TIME", "android.app.admin.DeviceAdminReceiver" ]
  }, {
    "name" : "public boolean getAutoTimeEnabled(@Nullable ComponentName admin)",
    "returnType" : "boolean",
    "comment" : "\n     * Returns true if auto time is enabled on the device.\n     *\n     * @param admin Which {@link DeviceAdminReceiver} this request is associated with. Null if the\n     *              caller is not a device admin.\n     * @return true if auto time is enabled on the device.\n     * @throws SecurityException if caller is not a device owner, a profile owner for the\n     * primary user, or a profile owner of an organization-owned managed profile.\n     ",
    "links" : [ "android.app.admin.DeviceAdminReceiver" ]
  }, {
    "name" : "public void setAutoTimeZoneEnabled(@Nullable ComponentName admin, boolean enabled)",
    "returnType" : "void",
    "comment" : "\n     * Called by a device owner, a profile owner for the primary user or a profile\n     * owner of an organization-owned managed profile to turn auto time zone on and off.\n     * Callers are recommended to use {@link UserManager#DISALLOW_CONFIG_DATE_TIME}\n     * to prevent the user from changing this setting.\n     * <p>\n     * If user restriction {@link UserManager#DISALLOW_CONFIG_DATE_TIME} is used,\n     * no user will be able set the date and time zone. Instead, the network date\n     * and time zone will be used.\n     *\n     * @param admin Which {@link DeviceAdminReceiver} this request is associated with or Null if the\n     *              caller is not a device admin.\n     * @param enabled Whether time zone should be obtained automatically from the network or not.\n     * @throws SecurityException if caller is not a device owner, a profile owner for the\n     * primary user, or a profile owner of an organization-owned managed profile.\n     ",
    "links" : [ "android.os.UserManager#DISALLOW_CONFIG_DATE_TIME", "android.app.admin.DeviceAdminReceiver" ]
  }, {
    "name" : "public boolean getAutoTimeZoneEnabled(@Nullable ComponentName admin)",
    "returnType" : "boolean",
    "comment" : "\n     * Returns true if auto time zone is enabled on the device.\n     *\n     * @param admin Which {@link DeviceAdminReceiver} this request is associated with. Null if the\n     *              caller is not a device admin.\n     * @return true if auto time zone is enabled on the device.\n     * @throws SecurityException if caller is not a device owner, a profile owner for the\n     * primary user, or a profile owner of an organization-owned managed profile.\n     ",
    "links" : [ "android.app.admin.DeviceAdminReceiver" ]
  }, {
    "name" : "public void setForceEphemeralUsers(@NonNull ComponentName admin, boolean forceEphemeralUsers)",
    "returnType" : "void",
    "comment" : "\n     * TODO (b/137101239): remove this method in follow-up CL\n     * since it's only used for split system user.\n     * Called by a device owner to set whether all users created on the device should be ephemeral.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean getForceEphemeralUsers(@NonNull ComponentName admin)",
    "returnType" : "boolean",
    "comment" : "\n     * TODO (b/137101239): remove this method in follow-up CL\n     * since it's only used for split system user.\n     * @return true if all users are created ephemeral.\n     * @throws SecurityException if {@code admin} is not a device owner.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public void setKeyguardDisabledFeatures(@Nullable ComponentName admin, int which)",
    "returnType" : "void",
    "comment" : "\n     * Called by an application that is administering the device to disable keyguard customizations,\n     * such as widgets. After setting this, keyguard features will be disabled according to the\n     * provided feature list.\n     * <p>\n     * A calling device admin must have requested\n     * {@link DeviceAdminInfo#USES_POLICY_DISABLE_KEYGUARD_FEATURES} to be able to call this method;\n     * if it has not, a security exception will be thrown.\n     * <p>\n     * Calling this from a managed profile before version {@link android.os.Build.VERSION_CODES#M}\n     * will throw a security exception. From version {@link android.os.Build.VERSION_CODES#M} the\n     * profile owner of a managed profile can set:\n     * <ul>\n     * <li>{@link #KEYGUARD_DISABLE_TRUST_AGENTS}, which affects the parent user, but only if there\n     * is no separate challenge set on the managed profile.\n     * <li>{@link #KEYGUARD_DISABLE_FINGERPRINT}, {@link #KEYGUARD_DISABLE_FACE} or\n     * {@link #KEYGUARD_DISABLE_IRIS} which affects the managed profile challenge if\n     * there is one, or the parent user otherwise.\n     * <li>{@link #KEYGUARD_DISABLE_UNREDACTED_NOTIFICATIONS} which affects notifications generated\n     * by applications in the managed profile.\n     * </ul>\n     * <p>\n     * From version {@link android.os.Build.VERSION_CODES#VANILLA_ICE_CREAM}, the profile owner of a\n     * managed profile can also set {@link #KEYGUARD_DISABLE_WIDGETS_ALL} which disables keyguard\n     * widgets for the managed profile.\n     * <p>\n     * From version {@link android.os.Build.VERSION_CODES#R} the profile owner of an\n     * organization-owned managed profile can set:\n     * <ul>\n     * <li>{@link #KEYGUARD_DISABLE_SECURE_CAMERA} which affects the parent user when called on the\n     * parent profile.\n     * <li>{@link #KEYGUARD_DISABLE_SECURE_NOTIFICATIONS} which affects the parent user when called\n     * on the parent profile.\n     * </ul>\n     * Starting from version {@link android.os.Build.VERSION_CODES#VANILLA_ICE_CREAM} the profile\n     * owner of an organization-owned managed profile can set:\n     * <ul>\n     * <li>{@link #KEYGUARD_DISABLE_WIDGETS_ALL} which affects the parent user when called on the\n     * parent profile.\n     * </ul>\n     * {@link #KEYGUARD_DISABLE_TRUST_AGENTS}, {@link #KEYGUARD_DISABLE_FINGERPRINT},\n     * {@link #KEYGUARD_DISABLE_FACE}, {@link #KEYGUARD_DISABLE_IRIS},\n     * {@link #KEYGUARD_DISABLE_SECURE_CAMERA} and {@link #KEYGUARD_DISABLE_SECURE_NOTIFICATIONS}\n     * can also be set on the {@link DevicePolicyManager} instance returned by\n     * {@link #getParentProfileInstance(ComponentName)} in order to set restrictions on the parent\n     * profile. {@link #KEYGUARD_DISABLE_SECURE_CAMERA} can only be set on the parent profile\n     * instance if the calling device admin is the profile owner of an organization-owned\n     * managed profile.\n     * <p>\n     * Requests to disable other features on a managed profile will be ignored.\n     * <p>\n     * The admin can check which features have been disabled by calling\n     * {@link #getKeyguardDisabledFeatures(ComponentName)}\n     *\n     * @param admin Which {@link DeviceAdminReceiver} this request is associated with. Null if the\n     *              caller is not a device admin\n     * @param which The disabled features flag which can be either\n     *            {@link #KEYGUARD_DISABLE_FEATURES_NONE} (default),\n     *            {@link #KEYGUARD_DISABLE_FEATURES_ALL}, or a combination of\n     *            {@link #KEYGUARD_DISABLE_WIDGETS_ALL}, {@link #KEYGUARD_DISABLE_SECURE_CAMERA},\n     *            {@link #KEYGUARD_DISABLE_SECURE_NOTIFICATIONS},\n     *            {@link #KEYGUARD_DISABLE_TRUST_AGENTS},\n     *            {@link #KEYGUARD_DISABLE_UNREDACTED_NOTIFICATIONS},\n     *            {@link #KEYGUARD_DISABLE_FINGERPRINT},\n     *            {@link #KEYGUARD_DISABLE_FACE},\n     *            {@link #KEYGUARD_DISABLE_IRIS},\n     *            {@link #KEYGUARD_DISABLE_SHORTCUTS_ALL}.\n     * @throws SecurityException if {@code admin} is not an active administrator or does not use\n     *             {@link DeviceAdminInfo#USES_POLICY_DISABLE_KEYGUARD_FEATURES}\n     ",
    "links" : [ "#getKeyguardDisabledFeatures(ComponentName)", "#KEYGUARD_DISABLE_IRIS", "#KEYGUARD_DISABLE_SHORTCUTS_ALL", "android.os.Build.VERSION_CODES#VANILLA_ICE_CREAM", "#KEYGUARD_DISABLE_UNREDACTED_NOTIFICATIONS", "#KEYGUARD_DISABLE_WIDGETS_ALL", "#KEYGUARD_DISABLE_SECURE_NOTIFICATIONS", "#KEYGUARD_DISABLE_FACE", "#KEYGUARD_DISABLE_FEATURES_ALL", "android.os.Build.VERSION_CODES#M", "#KEYGUARD_DISABLE_FINGERPRINT", "#getParentProfileInstance(ComponentName)", "android.os.Build.VERSION_CODES#R", "android.app.admin.DeviceAdminReceiver", "#KEYGUARD_DISABLE_TRUST_AGENTS", "android.app.admin.DevicePolicyManager", "android.app.admin.DeviceAdminInfo#USES_POLICY_DISABLE_KEYGUARD_FEATURES", "#KEYGUARD_DISABLE_FEATURES_NONE", "#KEYGUARD_DISABLE_SECURE_CAMERA" ]
  }, {
    "name" : "public int getKeyguardDisabledFeatures(@Nullable ComponentName admin)",
    "returnType" : "int",
    "comment" : "\n     * Determine whether or not features have been disabled in keyguard either by the calling\n     * admin, if specified, or all admins that set restrictions on this user and its participating\n     * profiles. Restrictions on profiles that have a separate challenge are not taken into account.\n     *\n     * <p>This method can be called on the {@link DevicePolicyManager} instance\n     * returned by {@link #getParentProfileInstance(ComponentName)} in order to retrieve\n     * restrictions on the parent profile.\n     *\n     * @param admin The name of the admin component to check, or {@code null} to check whether any\n     * admins have disabled features in keyguard.\n     * @return bitfield of flags. See {@link #setKeyguardDisabledFeatures(ComponentName, int)}\n     * for a list.\n     ",
    "links" : [ "#getParentProfileInstance(ComponentName)", "android.app.admin.DevicePolicyManager", "#setKeyguardDisabledFeatures(ComponentName" ]
  }, {
    "name" : "public int getKeyguardDisabledFeatures(@Nullable ComponentName admin, int userHandle)",
    "returnType" : "int",
    "comment" : " @hide per-user version ",
    "links" : [ ]
  }, {
    "name" : "public void setActiveAdmin(@NonNull ComponentName policyReceiver, boolean refreshing, int userHandle)",
    "returnType" : "void",
    "comment" : "\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public void setActiveAdmin(@NonNull ComponentName policyReceiver, boolean refreshing)",
    "returnType" : "void",
    "comment" : "\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public void getRemoveWarning(@Nullable ComponentName admin, RemoteCallback result)",
    "returnType" : "void",
    "comment" : "\n     * Called by a privileged caller holding {@code BIND_DEVICE_ADMIN} permission to retrieve\n     * the remove warning for the given device admin.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public void reportPasswordChanged(PasswordMetrics metrics, @UserIdInt int userId)",
    "returnType" : "void",
    "comment" : "\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public void reportFailedPasswordAttempt(int userHandle)",
    "returnType" : "void",
    "comment" : "\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public void reportSuccessfulPasswordAttempt(int userHandle)",
    "returnType" : "void",
    "comment" : "\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public void reportFailedBiometricAttempt(int userHandle)",
    "returnType" : "void",
    "comment" : "\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public void reportSuccessfulBiometricAttempt(int userHandle)",
    "returnType" : "void",
    "comment" : "\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public void reportKeyguardDismissed(int userHandle)",
    "returnType" : "void",
    "comment" : "\n     * Should be called when keyguard has been dismissed.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public void reportKeyguardSecured(int userHandle)",
    "returnType" : "void",
    "comment" : "\n     * Should be called when keyguard view has been shown to the user.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean setDeviceOwner(@NonNull ComponentName who, @UserIdInt int userId)",
    "returnType" : "boolean",
    "comment" : "\n     * Sets the given package as the device owner.\n     *\n     * <p>Preconditions:\n     * <ul>\n     *   <li>The package must already be installed.\n     *   <li>There must not already be a device owner.\n     *   <li>Only apps with the {@code MANAGE_PROFILE_AND_DEVICE_OWNERS} permission or the\n     *       {@link Process#SHELL_UID Shell UID} can call this method.\n     * </ul>\n     *\n     * <p>Calling this after the setup phase of the device owner user has completed is allowed only\n     * if the caller is the {@link Process#SHELL_UID Shell UID}, and there are no additional users\n     * (except when the device runs on headless system user mode, in which case it could have exact\n     * one extra user, which is the current user.\n     *\n     * <p>On a headless devices, if it is in affiliated mode the device owner will be set in the\n     * {@link UserHandle#SYSTEM system} user. If the device is in single user mode, the device owner\n     * will be set in the first secondary user.\n     *\n     * @param who the component name to be registered as device owner.\n     * @param userId ID of the user on which the device owner runs.\n     *\n     * @return whether the package was successfully registered as the device owner.\n     *\n     * @throws IllegalArgumentException if the package name is {@code null} or invalid.\n     * @throws IllegalStateException If the preconditions mentioned are not met.\n     *\n     * @hide\n     ",
    "links" : [ "android.os.Process#SHELL_UID", "android.os.UserHandle#SYSTEM" ]
  }, {
    "name" : "public boolean setDeviceOwnerOnly(@NonNull ComponentName who, @UserIdInt int userId)",
    "returnType" : "boolean",
    "comment" : "\n     * Same as {@link #setDeviceOwner(ComponentName, int)}, but without setting the profile\n     * owner on current user when running on headless system user mode - should be used only by\n     * testing infra.\n     *\n     * @hide\n     ",
    "links" : [ "#setDeviceOwner(ComponentName" ]
  }, {
    "name" : "public boolean isDeviceOwnerApp(String packageName)",
    "returnType" : "boolean",
    "comment" : "\n     * Used to determine if a particular package has been registered as a Device Owner app.\n     * A device owner app is a special device admin that cannot be deactivated by the user, once\n     * activated as a device admin. It also cannot be uninstalled. To check whether a particular\n     * package is currently registered as the device owner app, pass in the package name from\n     * {@link Context#getPackageName()} to this method.<p/>This is useful for device\n     * admin apps that want to check whether they are also registered as the device owner app. The\n     * exact mechanism by which a device admin app is registered as a device owner app is defined by\n     * the setup process.\n     * @param packageName the package name of the app, to compare with the registered device owner\n     * app, if any.\n     * @return whether or not the package is registered as the device owner app.\n     ",
    "links" : [ "android.content.Context#getPackageName()" ]
  }, {
    "name" : "public boolean isDeviceOwnerAppOnCallingUser(String packageName)",
    "returnType" : "boolean",
    "comment" : "\n     * @return true if a package is registered as device owner, only when it's running on the\n     * calling user.\n     *\n     * <p>Same as {@link #isDeviceOwnerApp}, but bundled code should use it for clarity.\n     * @hide\n     ",
    "links" : [ "#isDeviceOwnerApp" ]
  }, {
    "name" : "public boolean isDeviceOwnerAppOnAnyUser(String packageName)",
    "returnType" : "boolean",
    "comment" : "\n     * @return true if a package is registered as device owner, even if it's running on a different\n     * user.\n     *\n     * <p>Requires the MANAGE_USERS permission.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public ComponentName getDeviceOwnerComponentOnCallingUser()",
    "returnType" : "ComponentName",
    "comment" : "\n     * @return device owner component name, only when it's running on the calling user.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public ComponentName getDeviceOwnerComponentOnAnyUser()",
    "returnType" : "ComponentName",
    "comment" : "\n     * @return device owner component name, even if it's running on a different user.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "private boolean isDeviceOwnerAppOnAnyUserInner(String packageName, boolean callingUserOnly)",
    "returnType" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private boolean isDeviceOwnerAppOnContextUser(String packageName)",
    "returnType" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private ComponentName getDeviceOwnerComponentInner(boolean callingUserOnly)",
    "returnType" : "ComponentName",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public UserHandle getDeviceOwnerUser()",
    "returnType" : "UserHandle",
    "comment" : "\n     * @return Handle of the user who runs device owner, or {@code null} if there's no device owner.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public int getDeviceOwnerUserId()",
    "returnType" : "int",
    "comment" : "\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public void clearDeviceOwnerApp(String packageName)",
    "returnType" : "void",
    "comment" : "\n     * Clears the current device owner. The caller must be the device owner. This function should be\n     * used cautiously as once it is called it cannot be undone. The device owner can only be set as\n     * a part of device setup, before it completes.\n     * <p>\n     * While some policies previously set by the device owner will be cleared by this method, it is\n     * a best-effort process and some other policies will still remain in place after the device\n     * owner is cleared.\n     *\n     * @param packageName The package name of the device owner.\n     * @throws SecurityException if the caller is not in {@code packageName} or {@code packageName}\n     *             does not own the current device owner component.\n     *\n     * @deprecated This method is expected to be used for testing purposes only. The device owner\n     * will lose control of the device and its data after calling it. In order to protect any\n     * sensitive data that remains on the device, it is advised that the device owner factory resets\n     * the device instead of calling this method. See {@link #wipeData(int)}.\n     ",
    "links" : [ "#wipeData(int)" ]
  }, {
    "name" : "public String getDeviceOwner()",
    "returnType" : "String",
    "comment" : "\n     * Returns the device owner package name, only if it's running on the calling user.\n     *\n     * <p>Bundled components should use {@code getDeviceOwnerComponentOnCallingUser()} for clarity.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean isDeviceManaged()",
    "returnType" : "boolean",
    "comment" : "\n     * Called by the system to find out whether the device is managed by a Device Owner.\n     *\n     * @return whether the device is managed by a Device Owner.\n     * @throws SecurityException if the caller is not the device owner, does not hold\n     *         MANAGE_USERS or MANAGE_PROFILE_AND_DEVICE_OWNERS permissions and is not the system.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public String getDeviceOwnerNameOnAnyUser()",
    "returnType" : "String",
    "comment" : "\n     * Returns the device owner name.  Note this method *will* return the device owner\n     * name when it's running on a different user.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean setActiveProfileOwner(@NonNull ComponentName admin, String ownerName) throws IllegalArgumentException",
    "returnType" : "boolean",
    "comment" : "\n     * @hide\n     * @deprecated Use #ACTION_SET_PROFILE_OWNER\n     * Sets the given component as an active admin and registers the package as the profile\n     * owner for this user. The package must already be installed and there shouldn't be\n     * an existing profile owner registered for this user. Also, this method must be called\n     * before the user setup has been completed.\n     * <p>\n     * This method can only be called by system apps that hold MANAGE_USERS permission and\n     * MANAGE_DEVICE_ADMINS permission.\n     * @param admin The component to register as an active admin and profile owner.\n     * @param ownerName The user-visible name of the entity that is managing this user.\n     * @return whether the admin was successfully registered as the profile owner.\n     * @throws IllegalArgumentException if packageName is null, the package isn't installed, or\n     *         the user has already been set up.\n     ",
    "links" : [ ]
  }, {
    "name" : "public void clearProfileOwner(@NonNull ComponentName admin)",
    "returnType" : "void",
    "comment" : "\n     * Clears the active profile owner. The caller must be the profile owner of this user, otherwise\n     * a SecurityException will be thrown. This method is not available to managed profile owners.\n     * <p>\n     * While some policies previously set by the profile owner will be cleared by this method, it is\n     * a best-effort process and some other policies will still remain in place after the profile\n     * owner is cleared.\n     *\n     * @param admin The component to remove as the profile owner.\n     * @throws SecurityException if {@code admin} is not an active profile owner, or the method is\n     * being called from a managed profile.\n     *\n     * @deprecated This method is expected to be used for testing purposes only. The profile owner\n     * will lose control of the user and its data after calling it. In order to protect any\n     * sensitive data that remains on this user, it is advised that the profile owner deletes it\n     * instead of calling this method. See {@link #wipeData(int)}.\n     ",
    "links" : [ "#wipeData(int)" ]
  }, {
    "name" : "public boolean hasUserSetupCompleted()",
    "returnType" : "boolean",
    "comment" : "\n     * @hide\n     * Checks whether the user was already setup.\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean setProfileOwner(@NonNull ComponentName admin, int userHandle) throws IllegalArgumentException",
    "returnType" : "boolean",
    "comment" : "\n     * @hide\n     * Sets the given component as the profile owner of the given user profile. The package must\n     * already be installed. There must not already be a profile owner for this user.\n     * Only apps with the MANAGE_PROFILE_AND_DEVICE_OWNERS permission and the shell uid can call\n     * this method.\n     * Calling this after the setup phase of the specified user has completed is allowed only if:\n     * - the caller is SYSTEM_UID.\n     * - or the caller is the shell uid, and there are no accounts on the specified user.\n     * @param admin the component name to be registered as profile owner.\n     * @param userHandle the userId to set the profile owner for.\n     * @return whether the component was successfully registered as the profile owner.\n     * @throws IllegalArgumentException if admin is null, the package isn't installed, or the\n     * preconditions mentioned are not met.\n     ",
    "links" : [ ]
  }, {
    "name" : "public void setDeviceOwnerLockScreenInfo(@NonNull ComponentName admin, CharSequence info)",
    "returnType" : "void",
    "comment" : "\n     * Sets the device owner information to be shown on the lock screen.\n     * <p>\n     * Device owner information set using this method overrides any owner information manually set\n     * by the user and prevents the user from further changing it.\n     * <p>\n     * If the device owner information is {@code null} or empty then the device owner info is\n     * cleared and the user owner info is shown on the lock screen if it is set.\n     * <p>\n     * If the device owner information contains only whitespaces then the message on the lock screen\n     * will be blank and the user will not be allowed to change it.\n     * <p>\n     * If the device owner information needs to be localized, it is the responsibility of the\n     * {@link DeviceAdminReceiver} to listen to the {@link Intent#ACTION_LOCALE_CHANGED} broadcast\n     * and set a new version of this string accordingly.\n     * <p>\n     * May be called by the device owner or the profile owner of an organization-owned device.\n     *\n     * @param admin The name of the admin component to check.\n     * @param info Device owner information which will be displayed instead of the user owner info.\n     * @throws SecurityException if {@code admin} is not a device owner.\n     ",
    "links" : [ "android.content.Intent#ACTION_LOCALE_CHANGED", "android.app.admin.DeviceAdminReceiver" ]
  }, {
    "name" : "public CharSequence getDeviceOwnerLockScreenInfo()",
    "returnType" : "CharSequence",
    "comment" : "\n     * @return The device owner information. If it is not set returns {@code null}.\n     ",
    "links" : [ ]
  }, {
    "name" : "public String[] setPackagesSuspended(@Nullable ComponentName admin, @NonNull String[] packageNames, boolean suspended)",
    "returnType" : "String[]",
    "comment" : "\n     * Called by device or profile owners to suspend packages for this user. This function can be\n     * called by a device owner, profile owner, or by a delegate given the\n     * {@link #DELEGATION_PACKAGE_ACCESS} scope via {@link #setDelegatedScopes}.\n     * <p>\n     * A suspended package will not be able to start activities. Its notifications will be hidden,\n     * it will not show up in recents, will not be able to show toasts or dialogs or ring the\n     * device.\n     * <p>\n     * The package must already be installed. If the package is uninstalled while suspended the\n     * package will no longer be suspended. The admin can block this by using\n     * {@link #setUninstallBlocked}.\n     *\n     * <p>Some apps cannot be suspended, such as device admins, the active launcher, the required\n     * package installer, the required package uninstaller, the required package verifier, the\n     * default dialer, and the permission controller.\n     *\n     * @param admin Which {@link DeviceAdminReceiver} this request is associated with. Null if the\n     *              caller is not a device admin.\n     * @param packageNames The package names to suspend or unsuspend.\n     * @param suspended If set to {@code true} than the packages will be suspended, if set to\n     *            {@code false} the packages will be unsuspended.\n     * @return an array of package names for which the suspended status is not set as requested in\n     *         this method.\n     * @throws SecurityException if {@code admin} is not a device or profile owner.\n     * @see #setDelegatedScopes\n     * @see #DELEGATION_PACKAGE_ACCESS\n     ",
    "links" : [ "#setUninstallBlocked", "android.app.admin.DeviceAdminReceiver", "#DELEGATION_PACKAGE_ACCESS", "#setDelegatedScopes" ]
  }, {
    "name" : "public boolean isPackageSuspended(@Nullable ComponentName admin, String packageName) throws NameNotFoundException",
    "returnType" : "boolean",
    "comment" : "\n     * Determine if a package is suspended. This function can be called by a device owner, profile\n     * owner, or by a delegate given the {@link #DELEGATION_PACKAGE_ACCESS} scope via\n     * {@link #setDelegatedScopes} or by holders of the permission\n     * {@link android.Manifest.permission#MANAGE_DEVICE_POLICY_PACKAGE_STATE}.\n     *\n     * @param admin Which {@link DeviceAdminReceiver} this request is associated with. Null if the\n     *              caller is not a device admin.\n     * @param packageName The name of the package to retrieve the suspended status of.\n     * @return {@code true} if the package is suspended or {@code false} if the package is not\n     *         suspended, could not be found or an error occurred.\n     * @throws SecurityException if {@code admin} is not a device or profile owner or has not been\n     * granted the permission\n     * {@link android.Manifest.permission#MANAGE_DEVICE_POLICY_PACKAGE_STATE}.\n     * @throws NameNotFoundException if the package could not be found.\n     * @see #setDelegatedScopes\n     * @see #DELEGATION_PACKAGE_ACCESS\n     ",
    "links" : [ "android.app.admin.DeviceAdminReceiver", "#DELEGATION_PACKAGE_ACCESS", "android.Manifest.permission#MANAGE_DEVICE_POLICY_PACKAGE_STATE", "#setDelegatedScopes" ]
  }, {
    "name" : "public void setProfileEnabled(@NonNull ComponentName admin)",
    "returnType" : "void",
    "comment" : "\n     * Sets the enabled state of the profile. A profile should be enabled only once it is ready to\n     * be used. Only the profile owner can call this.\n     *\n     * @see #isProfileOwnerApp\n     * @param admin Which {@link DeviceAdminReceiver} this request is associated with.\n     * @throws SecurityException if {@code admin} is not a profile owner.\n     ",
    "links" : [ "android.app.admin.DeviceAdminReceiver" ]
  }, {
    "name" : "public void setProfileName(@NonNull ComponentName admin, String profileName)",
    "returnType" : "void",
    "comment" : "\n     * Sets the name of the profile. In the device owner case it sets the name of the user which it\n     * is called from. Only a profile owner or device owner can call this. If this is never called\n     * by the profile or device owner, the name will be set to default values.\n     *\n     * @see #isProfileOwnerApp\n     * @see #isDeviceOwnerApp\n     * @param admin Which {@link DeviceAdminReceiver} this request is associate with.\n     * @param profileName The name of the profile. If the name is longer than 200 characters\n     *                    it will be truncated.\n     * @throws SecurityException if {@code admin} is not a device or profile owner.\n     ",
    "links" : [ "android.app.admin.DeviceAdminReceiver" ]
  }, {
    "name" : "public boolean isProfileOwnerApp(String packageName)",
    "returnType" : "boolean",
    "comment" : "\n     * Used to determine if a particular package is registered as the profile owner for the\n     * user. A profile owner is a special device admin that has additional privileges\n     * within the profile.\n     *\n     * @param packageName The package name of the app to compare with the registered profile owner.\n     * @return Whether or not the package is registered as the profile owner.\n     ",
    "links" : [ ]
  }, {
    "name" : "public ComponentName getProfileOwner() throws IllegalArgumentException",
    "returnType" : "ComponentName",
    "comment" : "\n     * @hide\n     * @return the packageName of the owner of the given user profile or {@code null} if no profile\n     * owner has been set for that user.\n     * @throws IllegalArgumentException if the userId is invalid.\n     ",
    "links" : [ ]
  }, {
    "name" : "public ComponentName getProfileOwnerAsUser(@NonNull UserHandle user)",
    "returnType" : "ComponentName",
    "comment" : "\n     * @see #getProfileOwner()\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public ComponentName getProfileOwnerAsUser(final int userId)",
    "returnType" : "ComponentName",
    "comment" : "\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public ComponentName getProfileOwnerOrDeviceOwnerSupervisionComponent(@NonNull UserHandle user)",
    "returnType" : "ComponentName",
    "comment" : "\n     * Returns the configured supervision app if it exists and is the device owner or policy owner.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean isSupervisionComponent(@NonNull ComponentName who)",
    "returnType" : "boolean",
    "comment" : "\n     * Checks if the specified component is the supervision component.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public String getProfileOwnerName() throws IllegalArgumentException",
    "returnType" : "String",
    "comment" : "\n     * @hide\n     * @return the human readable name of the organisation associated with this DPM or {@code null}\n     *         if one is not set.\n     * @throws IllegalArgumentException if the userId is invalid.\n     ",
    "links" : [ ]
  }, {
    "name" : "public String getProfileOwnerNameAsUser(int userId) throws IllegalArgumentException",
    "returnType" : "String",
    "comment" : "\n     * @hide\n     * @param userId The user for whom to fetch the profile owner name, if any.\n     * @return the human readable name of the organisation associated with this profile owner or\n     *         null if one is not set.\n     * @throws IllegalArgumentException if the userId is invalid.\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean isOrganizationOwnedDeviceWithManagedProfile()",
    "returnType" : "boolean",
    "comment" : "\n     * Apps can use this method to find out if the device was provisioned as\n     * organization-owend device with a managed profile.\n     *\n     * This, together with checking whether the device has a device owner (by calling\n     * {@link #isDeviceOwnerApp}), could be used to learn whether the device is owned by an\n     * organization or an individual:\n     * If this method returns true OR {@link #isDeviceOwnerApp} returns true (for any package),\n     * then the device is owned by an organization. Otherwise, it's owned by an individual.\n     *\n     * @return {@code true} if the device was provisioned as organization-owned device,\n     * {@code false} otherwise.\n     ",
    "links" : [ "#isDeviceOwnerApp" ]
  }, {
    "name" : "public boolean hasDeviceIdentifierAccess(@NonNull String packageName, int pid, int uid)",
    "returnType" : "boolean",
    "comment" : "\n     * Returns whether the specified package can read the device identifiers.\n     *\n     * @param packageName The package name of the app to check for device identifier access.\n     * @param pid The process id of the package to be checked.\n     * @param uid The uid of the package to be checked.\n     * @return whether the package can read the device identifiers.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public void addPersistentPreferredActivity(@Nullable ComponentName admin, IntentFilter filter, @NonNull ComponentName activity)",
    "returnType" : "void",
    "comment" : "\n     * Called by a profile owner or device owner or holder of the permission\n     * {@link android.Manifest.permission#MANAGE_DEVICE_POLICY_LOCK_TASK}. to set a default activity\n     * that the system selects to handle intents that match the given {@link IntentFilter} instead\n     * of showing the default disambiguation mechanism.\n     * This activity will remain the default intent handler even if the set of potential event\n     * handlers for the intent filter changes and if the intent preferences are reset.\n     * <p>\n     * Note that the target application should still declare the activity in the manifest, the API\n     * just sets the activity to be the default one to handle the given intent filter.\n     * <p>\n     * The default disambiguation mechanism takes over if the activity is not installed (anymore).\n     * When the activity is (re)installed, it is automatically reset as default intent handler for\n     * the filter.\n     * <p>\n     * Note that calling this API to set a default intent handler, only allow to avoid the default\n     * disambiguation mechanism. Implicit intents that do not trigger this mechanism (like invoking\n     * the browser) cannot be configured as they are controlled by other configurations.\n     * <p>\n     * The calling device admin must be a profile owner or device owner. If it is not, a security\n     * exception will be thrown.\n     * <p>\n     * Starting from {@link Build.VERSION_CODES#UPSIDE_DOWN_CAKE}, after the persistent preferred\n     * activity policy has been set, {@link PolicyUpdateReceiver#onPolicySetResult(Context, String,\n     * Bundle, TargetUser, PolicyUpdateResult)} will notify the admin on whether the policy was\n     * successfully set or not. This callback will contain:\n     * <ul>\n     * <li> The policy identifier\n     * {@link DevicePolicyIdentifiers#PERSISTENT_PREFERRED_ACTIVITY_POLICY}\n     * <li> The additional policy params bundle, which contains\n     * {@link PolicyUpdateReceiver#EXTRA_INTENT_FILTER} the intent filter the policy applies to\n     * <li> The {@link TargetUser} that this policy relates to\n     * <li> The {@link PolicyUpdateResult}, which will be\n     * {@link PolicyUpdateResult#RESULT_POLICY_SET} if the policy was successfully set or the\n     * reason the policy failed to be set\n     * (e.g. {@link PolicyUpdateResult#RESULT_FAILURE_CONFLICTING_ADMIN_POLICY})\n     * </ul>\n     * If there has been a change to the policy,\n     * {@link PolicyUpdateReceiver#onPolicyChanged(Context, String, Bundle, TargetUser,\n     * PolicyUpdateResult)} will notify the admin of this change. This callback will contain the\n     * same parameters as PolicyUpdateReceiver#onPolicySetResult and the {@link PolicyUpdateResult}\n     * will contain the reason why the policy changed.\n     *\n     * <p>NOTE: Performs disk I/O and shouldn't be called on the main thread.\n     *\n     * @param admin Which {@link DeviceAdminReceiver} this request is associated with. Null if the\n     *        caller is not a device admin.\n     * @param filter The IntentFilter for which a default handler is added.\n     * @param activity The Activity that is added as default intent handler.\n     * @throws SecurityException if {@code admin} is not a device or profile owner or holder of the\n     * permission {@link android.Manifest.permission#MANAGE_DEVICE_POLICY_LOCK_TASK}.\n     ",
    "links" : [ "android.app.admin.PolicyUpdateReceiver#EXTRA_INTENT_FILTER", "android.app.admin.PolicyUpdateResult#RESULT_FAILURE_CONFLICTING_ADMIN_POLICY", "android.app.admin.PolicyUpdateResult", "android.app.admin.PolicyUpdateResult#RESULT_POLICY_SET", "android.app.admin.DevicePolicyIdentifiers#PERSISTENT_PREFERRED_ACTIVITY_POLICY", "android.app.admin.DeviceAdminReceiver", "android.Manifest.permission#MANAGE_DEVICE_POLICY_LOCK_TASK", "android.content.IntentFilter", "android.app.admin.PolicyUpdateReceiver#onPolicyChanged(Context", "Build.VERSION_CODES#UPSIDE_DOWN_CAKE", "android.app.admin.PolicyUpdateReceiver#onPolicySetResult(Context", "android.app.admin.TargetUser" ]
  }, {
    "name" : "public void clearPackagePersistentPreferredActivities(@Nullable ComponentName admin, String packageName)",
    "returnType" : "void",
    "comment" : "\n     * Called by a profile owner or device owner or holder of the\n     * permission {@link android.Manifest.permission#MANAGE_DEVICE_POLICY_LOCK_TASK} to remove all\n     * persistent intent handler preferences associated with the given package that were set by\n     * {@link #addPersistentPreferredActivity}.\n     * <p>\n     * The calling device admin must be a profile owner. If it is not, a security exception will be\n     * thrown.\n     * <p>\n     * Starting from {@link Build.VERSION_CODES#UPSIDE_DOWN_CAKE}, after the persistent preferred\n     * activity policy has been cleared, {@link PolicyUpdateReceiver#onPolicySetResult(Context,\n     * String, Bundle, TargetUser, PolicyUpdateResult)} will notify the admin on whether the policy\n     * was successfully cleared or not. This callback will contain:\n     * <ul>\n     * <li> The policy identifier\n     * {@link DevicePolicyIdentifiers#PERSISTENT_PREFERRED_ACTIVITY_POLICY}\n     * <li> The additional policy params bundle, which contains\n     * {@link PolicyUpdateReceiver#EXTRA_INTENT_FILTER} the intent filter the policy applies to\n     * <li> The {@link TargetUser} that this policy relates to\n     * <li> The {@link PolicyUpdateResult}, which will be\n     * {@link PolicyUpdateResult#RESULT_POLICY_SET} if the policy was successfully cleared or the\n     * reason the policy failed to be cleared\n     * (e.g. {@link PolicyUpdateResult#RESULT_FAILURE_CONFLICTING_ADMIN_POLICY})\n     * </ul>\n     * If there has been a change to the policy,\n     * {@link PolicyUpdateReceiver#onPolicyChanged(Context, String, Bundle, TargetUser,\n     * PolicyUpdateResult)} will notify the admin of this change. This callback will contain the\n     * same parameters as PolicyUpdateReceiver#onPolicySetResult and the {@link PolicyUpdateResult}\n     * will contain the reason why the policy changed.\n     *\n     * @param admin Which {@link DeviceAdminReceiver} this request is associated with. Null if the\n     *              caller is not a device admin.\n     * @param packageName The name of the package for which preferences are removed.\n     * @throws SecurityException if {@code admin} is not a device or profile owner or holder of the\n     * permission {@link android.Manifest.permission#MANAGE_DEVICE_POLICY_LOCK_TASK}.\n     ",
    "links" : [ "android.app.admin.PolicyUpdateReceiver#EXTRA_INTENT_FILTER", "android.app.admin.PolicyUpdateResult#RESULT_FAILURE_CONFLICTING_ADMIN_POLICY", "android.app.admin.PolicyUpdateResult", "android.app.admin.PolicyUpdateResult#RESULT_POLICY_SET", "android.app.admin.DevicePolicyIdentifiers#PERSISTENT_PREFERRED_ACTIVITY_POLICY", "android.app.admin.DeviceAdminReceiver", "android.Manifest.permission#MANAGE_DEVICE_POLICY_LOCK_TASK", "android.app.admin.PolicyUpdateReceiver#onPolicyChanged(Context", "#addPersistentPreferredActivity", "Build.VERSION_CODES#UPSIDE_DOWN_CAKE", "android.app.admin.PolicyUpdateReceiver#onPolicySetResult(Context", "android.app.admin.TargetUser" ]
  }, {
    "name" : "public void setDefaultSmsApplication(@Nullable ComponentName admin, @NonNull String packageName)",
    "returnType" : "void",
    "comment" : "\n     * Must be called by a device owner or a profile owner of an organization-owned managed profile\n     * to set the default SMS application.\n     * <p>\n     * This method can be called on the {@link DevicePolicyManager} instance, returned by\n     * {@link #getParentProfileInstance(ComponentName)}, where the caller must be the profile owner\n     * of an organization-owned managed profile and the package must be a pre-installed system\n     * package. If called on the parent instance, then the default SMS application is set on the\n     * personal profile.\n     * <p>\n     * Starting from Android {@link android.os.Build.VERSION_CODES#UPSIDE_DOWN_CAKE}, the profile\n     * owner of an organization-owned managed profile can also call this method directly (not on the\n     * parent profile instance) to set the default SMS application in the work profile. This is only\n     * meaningful when work profile telephony is enabled by {@link #setManagedSubscriptionsPolicy}.\n     *\n     * @param admin Which {@link DeviceAdminReceiver} this request is associated with. Null if the\n     *              caller is not a device admin.\n     * @param packageName The name of the package to set as the default SMS application.\n     * @throws SecurityException        if {@code admin} is not a device or profile owner or if\n     *                                  called on the parent profile and the {@code admin} is not a\n     *                                  profile owner of an organization-owned managed profile.\n     * @throws IllegalArgumentException if called on the parent profile and the package\n     *                                  provided is not a pre-installed system package.\n     * @throws IllegalStateException while trying to set default sms app on the profile and\n     *                             {@link ManagedSubscriptionsPolicy#TYPE_ALL_MANAGED_SUBSCRIPTIONS}\n     *                             policy is not set.\n     ",
    "links" : [ "#getParentProfileInstance(ComponentName)", "#setManagedSubscriptionsPolicy", "android.os.Build.VERSION_CODES#UPSIDE_DOWN_CAKE", "android.app.admin.DeviceAdminReceiver", "android.app.admin.DevicePolicyManager", "android.app.admin.ManagedSubscriptionsPolicy#TYPE_ALL_MANAGED_SUBSCRIPTIONS" ]
  }, {
    "name" : "public void setDefaultDialerApplication(@NonNull String packageName)",
    "returnType" : "void",
    "comment" : "\n     * Must be called by a device owner or a profile owner of an organization-owned managed profile\n     * to set the default dialer application for the calling user.\n     * <p>\n     * When the profile owner of an organization-owned managed profile calls this method, it sets\n     * the default dialer application in the work profile. This is only meaningful when work profile\n     * telephony is enabled by {@link #setManagedSubscriptionsPolicy}.\n     * <p>\n     * If the device does not support telephony ({@link PackageManager#FEATURE_TELEPHONY}), calling\n     * this method will do nothing.\n     *\n     * @param packageName The name of the package to set as the default dialer application.\n     * @throws SecurityException        if {@code admin} is not a device or profile owner or a\n     *                                  profile owner of an organization-owned managed profile.\n     * @throws IllegalArgumentException if the package cannot be set as the default dialer, for\n     *                                  example if the package is not installed or does not expose\n     *                                  the expected activities or services that a dialer app is\n     *                                  required to have.\n     ",
    "links" : [ "#setManagedSubscriptionsPolicy", "android.content.pm.PackageManager#FEATURE_TELEPHONY" ]
  }, {
    "name" : "public void setApplicationRestrictionsManagingPackage(@NonNull ComponentName admin, @Nullable String packageName) throws NameNotFoundException",
    "returnType" : "void",
    "comment" : "\n     * Called by a profile owner or device owner to grant permission to a package to manage\n     * application restrictions for the calling user via {@link #setApplicationRestrictions} and\n     * {@link #getApplicationRestrictions}.\n     * <p>\n     * This permission is persistent until it is later cleared by calling this method with a\n     * {@code null} value or uninstalling the managing package.\n     * <p>\n     * The supplied application restriction managing package must be installed when calling this\n     * API, otherwise an {@link NameNotFoundException} will be thrown.\n     *\n     * @param admin Which {@link DeviceAdminReceiver} this request is associated with.\n     * @param packageName The package name which will be given access to application restrictions\n     *            APIs. If {@code null} is given the current package will be cleared.\n     * @throws SecurityException if {@code admin} is not a device or profile owner.\n     * @throws NameNotFoundException if {@code packageName} is not found\n     *\n     * @deprecated From {@link android.os.Build.VERSION_CODES#O}. Use {@link #setDelegatedScopes}\n     * with the {@link #DELEGATION_APP_RESTRICTIONS} scope instead.\n     ",
    "links" : [ "android.content.pm.PackageManager.NameNotFoundException", "#getApplicationRestrictions", "android.os.Build.VERSION_CODES#O", "android.app.admin.DeviceAdminReceiver", "#DELEGATION_APP_RESTRICTIONS", "#setApplicationRestrictions", "#setDelegatedScopes" ]
  }, {
    "name" : "public String getApplicationRestrictionsManagingPackage(@NonNull ComponentName admin)",
    "returnType" : "String",
    "comment" : "\n     * Called by a profile owner or device owner to retrieve the application restrictions managing\n     * package for the current user, or {@code null} if none is set. If there are multiple\n     * delegates this function will return one of them.\n     *\n     * @param admin Which {@link DeviceAdminReceiver} this request is associated with.\n     * @return The package name allowed to manage application restrictions on the current user, or\n     *         {@code null} if none is set.\n     * @throws SecurityException if {@code admin} is not a device or profile owner.\n     *\n     * @deprecated From {@link android.os.Build.VERSION_CODES#O}. Use {@link #getDelegatePackages}\n     * with the {@link #DELEGATION_APP_RESTRICTIONS} scope instead.\n     ",
    "links" : [ "android.os.Build.VERSION_CODES#O", "android.app.admin.DeviceAdminReceiver", "#DELEGATION_APP_RESTRICTIONS", "#getDelegatePackages" ]
  }, {
    "name" : "public boolean isCallerApplicationRestrictionsManagingPackage()",
    "returnType" : "boolean",
    "comment" : "\n     * Called by any application to find out whether it has been granted permission via\n     * {@link #setApplicationRestrictionsManagingPackage} to manage application restrictions\n     * for the calling user.\n     *\n     * <p>This is done by comparing the calling Linux uid with the uid of the package specified by\n     * that method.\n     *\n     * @deprecated From {@link android.os.Build.VERSION_CODES#O}. Use {@link #getDelegatedScopes}\n     * instead.\n     ",
    "links" : [ "android.os.Build.VERSION_CODES#O", "#getDelegatedScopes", "#setApplicationRestrictionsManagingPackage" ]
  }, {
    "name" : "public void setApplicationRestrictions(@Nullable ComponentName admin, String packageName, Bundle settings)",
    "returnType" : "void",
    "comment" : "\n     * Sets the application restrictions for a given target application running in the calling user.\n     * <p>\n     * The caller must be a profile or device owner on that user, or the package allowed to manage\n     * application restrictions via {@link #setDelegatedScopes} with the\n     * {@link #DELEGATION_APP_RESTRICTIONS} scope; otherwise a security exception will be thrown.\n     * <p>\n     * The provided {@link Bundle} consists of key-value pairs, where the types of values may be:\n     * <ul>\n     * <li>{@code boolean}\n     * <li>{@code int}\n     * <li>{@code String} or {@code String[]}\n     * <li>From {@link android.os.Build.VERSION_CODES#M}, {@code Bundle} or {@code Bundle[]}\n     * </ul>\n     * <p>\n     * If the restrictions are not available yet, but may be applied in the near future, the caller\n     * can notify the target application of that by adding\n     * {@link UserManager#KEY_RESTRICTIONS_PENDING} to the settings parameter.\n     * <p>\n     * The application restrictions are only made visible to the target application via\n     * {@link UserManager#getApplicationRestrictions(String)}, in addition to the profile or device\n     * owner, and the application restrictions managing package via\n     * {@link #getApplicationRestrictions}.\n     *\n     * <p>Starting from Android Version {@link android.os.Build.VERSION_CODES#UPSIDE_DOWN_CAKE},\n     * multiple admins can set app restrictions for the same application, the target application can\n     * get the list of app restrictions set by each admin via\n     * {@link android.content.RestrictionsManager#getApplicationRestrictionsPerAdmin}.\n     *\n     * <p>Starting from Android Version {@link android.os.Build.VERSION_CODES#VANILLA_ICE_CREAM},\n     * the device policy management role holder can also set app restrictions on any applications\n     * in the calling user, as well as the parent user of an organization-owned managed profile via\n     * the {@link DevicePolicyManager} instance returned by\n     * {@link #getParentProfileInstance(ComponentName)}. App restrictions set by the device policy\n     * management role holder are not returned by\n     * {@link UserManager#getApplicationRestrictions(String)}. The target application should use\n     * {@link android.content.RestrictionsManager#getApplicationRestrictionsPerAdmin} to retrieve\n     * them, alongside any app restrictions the profile or device owner might have set.\n     *\n     * <p>NOTE: The method performs disk I/O and shouldn't be called on the main thread\n     *\n     * @param admin Which {@link DeviceAdminReceiver} this request is associated with, or\n     *            {@code null} if called by the application restrictions managing package.\n     * @param packageName The name of the package to update restricted settings for.\n     * @param settings A {@link Bundle} to be parsed by the receiving application, conveying a new\n     *            set of active restrictions.\n     * @throws SecurityException if {@code admin} is not a device or profile owner.\n     * @see #setDelegatedScopes\n     * @see #DELEGATION_APP_RESTRICTIONS\n     * @see UserManager#KEY_RESTRICTIONS_PENDING\n     ",
    "links" : [ "#getApplicationRestrictions", "android.content.RestrictionsManager#getApplicationRestrictionsPerAdmin", "android.os.Bundle", "android.os.Build.VERSION_CODES#UPSIDE_DOWN_CAKE", "android.os.Build.VERSION_CODES#VANILLA_ICE_CREAM", "android.os.UserManager#KEY_RESTRICTIONS_PENDING", "android.os.Build.VERSION_CODES#M", "#getParentProfileInstance(ComponentName)", "android.os.UserManager#getApplicationRestrictions(String)", "android.app.admin.DeviceAdminReceiver", "android.app.admin.DevicePolicyManager", "#DELEGATION_APP_RESTRICTIONS", "#setDelegatedScopes" ]
  }, {
    "name" : "public void setTrustAgentConfiguration(@Nullable ComponentName admin, @NonNull ComponentName target, PersistableBundle configuration)",
    "returnType" : "void",
    "comment" : "\n     * Sets a list of configuration features to enable for a trust agent component. This is meant to\n     * be used in conjunction with {@link #KEYGUARD_DISABLE_TRUST_AGENTS}, which disables all trust\n     * agents but those enabled by this function call. If flag\n     * {@link #KEYGUARD_DISABLE_TRUST_AGENTS} is not set, then this call has no effect.\n     * <p>\n     * For any specific trust agent, whether it is disabled or not depends on the aggregated state\n     * of each admin's {@link #KEYGUARD_DISABLE_TRUST_AGENTS} setting and its trust agent\n     * configuration as set by this function call. In particular: if any admin sets\n     * {@link #KEYGUARD_DISABLE_TRUST_AGENTS} and does not additionally set any\n     * trust agent configuration, the trust agent is disabled completely. Otherwise, the trust agent\n     * will receive the list of configurations from all admins who set\n     * {@link #KEYGUARD_DISABLE_TRUST_AGENTS} and aggregate the configurations to determine its\n     * behavior. The exact meaning of aggregation is trust-agent-specific.\n     * <p>\n     * A calling device admin must have requested\n     * {@link DeviceAdminInfo#USES_POLICY_DISABLE_KEYGUARD_FEATURES} to be able to call this method;\n     * if not, a security exception will be thrown.\n     * <p>\n     * This method can be called on the {@link DevicePolicyManager} instance returned by\n     * {@link #getParentProfileInstance(ComponentName)} in order to set the configuration for\n     * the parent profile.\n     * <p>\n     * On devices not supporting {@link PackageManager#FEATURE_SECURE_LOCK_SCREEN} feature, calling\n     * this method has no effect - no trust agent configuration will be set.\n     *\n     * @param admin Which {@link DeviceAdminReceiver} this request is associated with. Null if the\n     *              caller is not a device admin\n     * @param target Component name of the agent to be configured.\n     * @param configuration Trust-agent-specific feature configuration bundle. Please consult\n     *        documentation of the specific trust agent to determine the interpretation of this\n     *        bundle.\n     * @throws SecurityException if {@code admin} is not an active administrator or does not use\n     *             {@link DeviceAdminInfo#USES_POLICY_DISABLE_KEYGUARD_FEATURES}\n     ",
    "links" : [ "#getParentProfileInstance(ComponentName)", "android.app.admin.DeviceAdminReceiver", "android.content.pm.PackageManager#FEATURE_SECURE_LOCK_SCREEN", "#KEYGUARD_DISABLE_TRUST_AGENTS", "android.app.admin.DevicePolicyManager", "android.app.admin.DeviceAdminInfo#USES_POLICY_DISABLE_KEYGUARD_FEATURES" ]
  }, {
    "name" : "public List<PersistableBundle> getTrustAgentConfiguration(@Nullable ComponentName admin, @NonNull ComponentName agent)",
    "returnType" : "List<PersistableBundle>",
    "comment" : "\n     * Gets configuration for the given trust agent based on aggregating all calls to\n     * {@link #setTrustAgentConfiguration(ComponentName, ComponentName, PersistableBundle)} for\n     * all device admins.\n     * <p>\n     * This method can be called on the {@link DevicePolicyManager} instance returned by\n     * {@link #getParentProfileInstance(ComponentName)} in order to retrieve the configuration set\n     * on the parent profile.\n     * <p>\n     * On devices not supporting {@link PackageManager#FEATURE_SECURE_LOCK_SCREEN} feature, null is\n     * always returned.\n     *\n     * @param admin Which {@link DeviceAdminReceiver} this request is associated with. If null,\n     * this function returns a list of configurations for all admins that declare\n     * {@link #KEYGUARD_DISABLE_TRUST_AGENTS}. If any admin declares\n     * {@link #KEYGUARD_DISABLE_TRUST_AGENTS} but doesn't call\n     * {@link #setTrustAgentConfiguration(ComponentName, ComponentName, PersistableBundle)}\n     * for this {@param agent} or calls it with a null configuration, null is returned.\n     * @param agent Which component to get enabled features for.\n     * @return configuration for the given trust agent.\n     ",
    "links" : [ "#getParentProfileInstance(ComponentName)", "android.app.admin.DeviceAdminReceiver", "android.content.pm.PackageManager#FEATURE_SECURE_LOCK_SCREEN", "android.app.admin.DevicePolicyManager", "#KEYGUARD_DISABLE_TRUST_AGENTS", "#setTrustAgentConfiguration(ComponentName" ]
  }, {
    "name" : "public List<PersistableBundle> getTrustAgentConfiguration(@Nullable ComponentName admin, @NonNull ComponentName agent, int userHandle)",
    "returnType" : "List<PersistableBundle>",
    "comment" : " @hide per-user version ",
    "links" : [ ]
  }, {
    "name" : "public void setCrossProfileCallerIdDisabled(@NonNull ComponentName admin, boolean disabled)",
    "returnType" : "void",
    "comment" : "\n     * Called by a profile owner of a managed profile to set whether caller-Id information from the\n     * managed profile will be shown in the parent profile, for incoming calls.\n     * <p>\n     * The calling device admin must be a profile owner. If it is not, a security exception will be\n     * thrown.\n     * <p>\n     * Starting with {@link android.os.Build.VERSION_CODES#UPSIDE_DOWN_CAKE}, calling this function\n     * is similar to calling {@link #setManagedProfileCallerIdAccessPolicy(PackagePolicy)}\n     * with a {@link PackagePolicy#PACKAGE_POLICY_BLOCKLIST} policy type when {@code disabled} is\n     * false or a {@link PackagePolicy#PACKAGE_POLICY_ALLOWLIST} policy type when\n     * {@code disabled} is true.\n     *\n     * @param admin Which {@link DeviceAdminReceiver} this request is associated with.\n     * @param disabled If true caller-Id information in the managed profile is not displayed.\n     * @throws SecurityException if {@code admin} is not a profile owner.\n     * @deprecated starting with {@link android.os.Build.VERSION_CODES#UPSIDE_DOWN_CAKE}, use\n     * {@link #setManagedProfileCallerIdAccessPolicy(PackagePolicy)} instead\n     ",
    "links" : [ "android.os.Build.VERSION_CODES#UPSIDE_DOWN_CAKE", "android.app.admin.DeviceAdminReceiver", "android.app.admin.PackagePolicy#PACKAGE_POLICY_ALLOWLIST", "#setManagedProfileCallerIdAccessPolicy(PackagePolicy)", "android.app.admin.PackagePolicy#PACKAGE_POLICY_BLOCKLIST" ]
  }, {
    "name" : "public boolean getCrossProfileCallerIdDisabled(@NonNull ComponentName admin)",
    "returnType" : "boolean",
    "comment" : "\n     * Called by a profile owner of a managed profile to determine whether or not caller-Id\n     * information has been disabled.\n     * <p>\n     * The calling device admin must be a profile owner. If it is not, a security exception will be\n     * thrown.\n     * <p>\n     * Starting with {@link android.os.Build.VERSION_CODES#UPSIDE_DOWN_CAKE},\n     * this will return true when\n     * {@link #setManagedProfileCallerIdAccessPolicy(PackagePolicy)}\n     * has been set with a non-null policy whose policy type is NOT\n     * {@link PackagePolicy#PACKAGE_POLICY_BLOCKLIST}\n     *\n     * @param admin Which {@link DeviceAdminReceiver} this request is associated with.\n     * @throws SecurityException if {@code admin} is not a profile owner.\n     * @deprecated starting with {@link android.os.Build.VERSION_CODES#UPSIDE_DOWN_CAKE}, use\n     * {@link #getManagedProfileCallerIdAccessPolicy()} instead\n     ",
    "links" : [ "android.os.Build.VERSION_CODES#UPSIDE_DOWN_CAKE", "android.app.admin.DeviceAdminReceiver", "#setManagedProfileCallerIdAccessPolicy(PackagePolicy)", "android.app.admin.PackagePolicy#PACKAGE_POLICY_BLOCKLIST", "#getManagedProfileCallerIdAccessPolicy()" ]
  }, {
    "name" : "public boolean getCrossProfileCallerIdDisabled(UserHandle userHandle)",
    "returnType" : "boolean",
    "comment" : "\n     * Called by the system to determine whether or not caller-Id information has been disabled.\n     * <p>\n     * Starting with {@link android.os.Build.VERSION_CODES#UPSIDE_DOWN_CAKE},\n     * this will return true when\n     * {@link #setManagedProfileCallerIdAccessPolicy(PackagePolicy)}\n     * has been set with a non-null policy whose policy type is NOT\n     * {@link PackagePolicy#PACKAGE_POLICY_BLOCKLIST}\n     *\n     * @param userHandle The user for whom to check the caller-id permission\n     * @deprecated use {@link #hasManagedProfileCallerIdAccess(UserHandle, String)} and provide the\n     * package name requesting access\n     * @hide\n     ",
    "links" : [ "android.os.Build.VERSION_CODES#UPSIDE_DOWN_CAKE", "#setManagedProfileCallerIdAccessPolicy(PackagePolicy)", "#hasManagedProfileCallerIdAccess(UserHandle", "android.app.admin.PackagePolicy#PACKAGE_POLICY_BLOCKLIST" ]
  }, {
    "name" : "public void setCredentialManagerPolicy(@Nullable PackagePolicy policy)",
    "returnType" : "void",
    "comment" : "\n     * Called by a device owner or profile owner of a managed profile to set the credential manager\n     * policy.\n     *\n     * <p>Affects APIs exposed by {@link android.credentials.CredentialManager}.\n     *\n     * <p>A {@link PackagePolicy#PACKAGE_POLICY_ALLOWLIST} policy type will limit the credential\n     * providers that the user can use to the list of packages in the policy.\n     *\n     * <p>A {@link PackagePolicy#PACKAGE_POLICY_ALLOWLIST_AND_SYSTEM} policy type\n     * allows access from the OEM default credential providers and the allowlist of credential\n     * providers.\n     *\n     * <p>A {@link PackagePolicy#PACKAGE_POLICY_BLOCKLIST} policy type will block the credential\n     * providers listed in the policy from being used by the user.\n     *\n     * @param policy the policy to set, setting this value to {@code null} will allow all packages\n     * @throws SecurityException if caller is not a device owner or profile owner of a\n     * managed profile\n     ",
    "links" : [ "android.app.admin.PackagePolicy#PACKAGE_POLICY_ALLOWLIST_AND_SYSTEM", "android.app.admin.PackagePolicy#PACKAGE_POLICY_ALLOWLIST", "android.credentials.CredentialManager", "android.app.admin.PackagePolicy#PACKAGE_POLICY_BLOCKLIST" ]
  }, {
    "name" : "public PackagePolicy getCredentialManagerPolicy()",
    "returnType" : "PackagePolicy",
    "comment" : "\n     * Called by a device owner or profile owner of a managed profile to retrieve the credential\n     * manager policy.\n     *\n     * @throws SecurityException if caller is not a device owner or profile owner of a\n     * managed profile.\n     * @return the current credential manager policy if null then this policy has not been\n     * configured.\n     ",
    "links" : [ ]
  }, {
    "name" : "public void setManagedProfileCallerIdAccessPolicy(@Nullable PackagePolicy policy)",
    "returnType" : "void",
    "comment" : "\n     * Called by a profile owner of a managed profile to set the packages that are allowed to\n     * lookup contacts in the managed profile based on caller id information.\n     * <p>\n     * For example, the policy determines if a dialer app in the parent profile resolving\n     * an incoming call can search the caller id data, such as phone number,\n     * of managed contacts and return managed contacts that match.\n     * <p>\n     * The calling device admin must be a profile owner of a managed profile.\n     * If it is not, a {@link SecurityException} will be thrown.\n     * <p>\n     * A {@link PackagePolicy#PACKAGE_POLICY_ALLOWLIST_AND_SYSTEM} policy type\n     * allows access from the OEM default packages for the Sms, Dialer and Contact roles,\n     * in addition to the packages specified in {@link PackagePolicy#getPackageNames()}\n     *\n     * @param policy the policy to set, setting this value to {@code null} will allow\n     *               all packages\n     * @throws SecurityException if caller is not a profile owner of a managed profile\n     ",
    "links" : [ "android.app.admin.PackagePolicy#getPackageNames()", "android.app.admin.PackagePolicy#PACKAGE_POLICY_ALLOWLIST_AND_SYSTEM", "SecurityException" ]
  }, {
    "name" : "public PackagePolicy getManagedProfileCallerIdAccessPolicy()",
    "returnType" : "PackagePolicy",
    "comment" : "\n     * Called by a profile owner of a managed profile to retrieve the caller id policy.\n     * <p>\n     * The calling device admin must be a profile owner of a managed profile.\n     * If it is not, a {@link SecurityException} will be thrown.\n     *\n     * @throws SecurityException if caller is not a profile owner of a managed profile.\n     * @return the current caller id policy\n     ",
    "links" : [ "SecurityException" ]
  }, {
    "name" : "public boolean hasManagedProfileCallerIdAccess(@NonNull UserHandle userHandle, @NonNull String packageName)",
    "returnType" : "boolean",
    "comment" : "\n     * Determine whether the given package is allowed to query the requested user to\n     * populate caller id information\n     *\n     * @param userHandle The user for whom to check the contacts search permission\n     * @param packageName the name of the package requesting access\n     * @return true if package should be granted access, false otherwise\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public void setManagedProfileContactsAccessPolicy(@Nullable PackagePolicy policy)",
    "returnType" : "void",
    "comment" : "\n     * Called by a profile owner of a managed profile to set the packages that are allowed\n     * access to the managed profile contacts from the parent user.\n     * <p>\n     * For example, the system will enforce the provided policy and determine\n     * if contacts in the managed profile are shown when queried by an application\n     * in the parent user.\n     * <p>\n     * The calling device admin must be a profile owner of a managed profile.\n     * If it is not, a {@link SecurityException} will be thrown.\n     * <p>\n     * A {@link PackagePolicy#PACKAGE_POLICY_ALLOWLIST_AND_SYSTEM} policy type\n     * allows access from the OEM default packages for the Sms, Dialer and Contact roles,\n     * in addition to the packages specified in {@link PackagePolicy#getPackageNames()}\n     *\n     * @param policy the policy to set, setting this value to {@code null} will allow\n     *               all packages\n     * @throws SecurityException if caller is not a profile owner of a managed profile\n     ",
    "links" : [ "android.app.admin.PackagePolicy#getPackageNames()", "android.app.admin.PackagePolicy#PACKAGE_POLICY_ALLOWLIST_AND_SYSTEM", "SecurityException" ]
  }, {
    "name" : "public PackagePolicy getManagedProfileContactsAccessPolicy()",
    "returnType" : "PackagePolicy",
    "comment" : "\n     * Called by a profile owner of a managed profile to determine the current policy applied\n     * to managed profile contacts.\n     * <p>\n     * The calling device admin must be a profile owner of a managed profile.\n     * If it is not, a {@link SecurityException} will be thrown.\n     *\n     * @throws SecurityException if caller is not a profile owner of a managed profile.\n     * @return the current contacts search policy\n     ",
    "links" : [ "SecurityException" ]
  }, {
    "name" : "public boolean hasManagedProfileContactsAccess(@NonNull UserHandle userHandle, @NonNull String packageName)",
    "returnType" : "boolean",
    "comment" : "\n     * Determine whether requesting package has ability to access contacts of the requested user\n     *\n     * @param userHandle The user for whom to check the contacts search permission\n     * @param packageName packageName requesting access to contact search\n     * @return true when package is allowed access, false otherwise\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public void setCrossProfileContactsSearchDisabled(@NonNull ComponentName admin, boolean disabled)",
    "returnType" : "void",
    "comment" : "\n     * Called by a profile owner of a managed profile to set whether contacts search from the\n     * managed profile will be shown in the parent profile, for incoming calls.\n     * <p>\n     * The calling device admin must be a profile owner. If it is not, a security exception will be\n     * thrown.\n     *\n     * Starting with {@link android.os.Build.VERSION_CODES#UPSIDE_DOWN_CAKE}, calling this function\n     * is similar to calling {@link #setManagedProfileContactsAccessPolicy(PackagePolicy)} with a\n     * {@link PackagePolicy#PACKAGE_POLICY_BLOCKLIST} policy type when {@code disabled} is false\n     * or a {@link PackagePolicy#PACKAGE_POLICY_ALLOWLIST} policy type when {@code disabled}\n     * is true.\n     *\n     * @param admin Which {@link DeviceAdminReceiver} this request is associated with.\n     * @param disabled If true contacts search in the managed profile is not displayed.\n     * @throws SecurityException if {@code admin} is not a profile owner.\n     *\n     * @deprecated From {@link android.os.Build.VERSION_CODES#UPSIDE_DOWN_CAKE} use\n     * {@link #setManagedProfileContactsAccessPolicy(PackagePolicy)}\n     ",
    "links" : [ "#setManagedProfileContactsAccessPolicy(PackagePolicy)", "android.os.Build.VERSION_CODES#UPSIDE_DOWN_CAKE", "android.app.admin.DeviceAdminReceiver", "android.app.admin.PackagePolicy#PACKAGE_POLICY_ALLOWLIST", "android.app.admin.PackagePolicy#PACKAGE_POLICY_BLOCKLIST" ]
  }, {
    "name" : "public boolean getCrossProfileContactsSearchDisabled(@NonNull ComponentName admin)",
    "returnType" : "boolean",
    "comment" : "\n     * Called by a profile owner of a managed profile to determine whether or not contacts search\n     * has been disabled.\n     * <p>\n     * The calling device admin must be a profile owner. If it is not, a security exception will be\n     * thrown.\n     * <p>\n     * Starting with {@link android.os.Build.VERSION_CODES#UPSIDE_DOWN_CAKE},\n     * this will return true when\n     * {@link #setManagedProfileContactsAccessPolicy(PackagePolicy)}\n     * has been set with a non-null policy whose policy type is NOT\n     * {@link PackagePolicy#PACKAGE_POLICY_BLOCKLIST}\n     *\n     * @param admin Which {@link DeviceAdminReceiver} this request is associated with.\n     * @throws SecurityException if {@code admin} is not a profile owner.\n     * @deprecated From {@link android.os.Build.VERSION_CODES#UPSIDE_DOWN_CAKE} use\n     * {@link #getManagedProfileContactsAccessPolicy()}\n     ",
    "links" : [ "#setManagedProfileContactsAccessPolicy(PackagePolicy)", "android.os.Build.VERSION_CODES#UPSIDE_DOWN_CAKE", "android.app.admin.DeviceAdminReceiver", "android.app.admin.PackagePolicy#PACKAGE_POLICY_BLOCKLIST", "#getManagedProfileContactsAccessPolicy()" ]
  }, {
    "name" : "public boolean getCrossProfileContactsSearchDisabled(@NonNull UserHandle userHandle)",
    "returnType" : "boolean",
    "comment" : "\n     * Determine whether or not contacts search has been disabled.\n     * <p>\n     * Starting with {@link android.os.Build.VERSION_CODES#UPSIDE_DOWN_CAKE},\n     * this will return true when\n     * {@link #setManagedProfileContactsAccessPolicy(PackagePolicy)}\n     * has been set with a non-null policy whose policy type is NOT\n     * {@link PackagePolicy#PACKAGE_POLICY_BLOCKLIST}\n     * @param userHandle The user for whom to check the contacts search permission\n     * @deprecated use {@link #hasManagedProfileContactsAccess(UserHandle, String)} and provide the\n     * package name requesting access\n     * @hide\n     ",
    "links" : [ "#setManagedProfileContactsAccessPolicy(PackagePolicy)", "android.os.Build.VERSION_CODES#UPSIDE_DOWN_CAKE", "android.app.admin.PackagePolicy#PACKAGE_POLICY_BLOCKLIST", "#hasManagedProfileContactsAccess(UserHandle" ]
  }, {
    "name" : "public void startManagedQuickContact(String actualLookupKey, long actualContactId, boolean isContactIdIgnored, long directoryId, Intent originalIntent)",
    "returnType" : "void",
    "comment" : "\n     * Start Quick Contact on the managed profile for the user, if the policy allows.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public void startManagedQuickContact(String actualLookupKey, long actualContactId, Intent originalIntent)",
    "returnType" : "void",
    "comment" : "\n     * Start Quick Contact on the managed profile for the user, if the policy allows.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public void setBluetoothContactSharingDisabled(@NonNull ComponentName admin, boolean disabled)",
    "returnType" : "void",
    "comment" : "\n     * Called by a profile owner of a managed profile to set whether bluetooth devices can access\n     * enterprise contacts.\n     * <p>\n     * The calling device admin must be a profile owner. If it is not, a security exception will be\n     * thrown.\n     * <p>\n     * This API works on managed profile only.\n     *\n     * @param admin Which {@link DeviceAdminReceiver} this request is associated with.\n     * @param disabled If true, bluetooth devices cannot access enterprise contacts.\n     * @throws SecurityException if {@code admin} is not a profile owner.\n     ",
    "links" : [ "android.app.admin.DeviceAdminReceiver" ]
  }, {
    "name" : "public boolean getBluetoothContactSharingDisabled(@NonNull ComponentName admin)",
    "returnType" : "boolean",
    "comment" : "\n     * Called by a profile owner of a managed profile to determine whether or not Bluetooth devices\n     * cannot access enterprise contacts.\n     * <p>\n     * The calling device admin must be a profile owner. If it is not, a security exception will be\n     * thrown.\n     * <p>\n     * This API works on managed profile only.\n     *\n     * @param admin Which {@link DeviceAdminReceiver} this request is associated with.\n     * @throws SecurityException if {@code admin} is not a profile owner.\n     ",
    "links" : [ "android.app.admin.DeviceAdminReceiver" ]
  }, {
    "name" : "public boolean getBluetoothContactSharingDisabled(@NonNull UserHandle userHandle)",
    "returnType" : "boolean",
    "comment" : "\n     * Determine whether or not Bluetooth devices cannot access contacts.\n     * <p>\n     * This API works on managed profile UserHandle only.\n     *\n     * @param userHandle The user for whom to check the caller-id permission\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public void addCrossProfileIntentFilter(@Nullable ComponentName admin, IntentFilter filter, int flags)",
    "returnType" : "void",
    "comment" : "\n     * Called by the profile owner of a managed profile so that some intents sent in the managed\n     * profile can also be resolved in the parent, or vice versa. Only activity intents are\n     * supported.\n     *\n     * @param admin Which {@link DeviceAdminReceiver} this request is associated with.\n     * @param filter The {@link IntentFilter} the intent has to match to be also resolved in the\n     *            other profile\n     * @param flags {@link DevicePolicyManager#FLAG_MANAGED_CAN_ACCESS_PARENT} and\n     *            {@link DevicePolicyManager#FLAG_PARENT_CAN_ACCESS_MANAGED} are supported.\n     * @throws SecurityException if {@code admin} is not a device or profile owner.\n     ",
    "links" : [ "android.app.admin.DeviceAdminReceiver", "android.content.IntentFilter", "android.app.admin.DevicePolicyManager#FLAG_MANAGED_CAN_ACCESS_PARENT", "android.app.admin.DevicePolicyManager#FLAG_PARENT_CAN_ACCESS_MANAGED" ]
  }, {
    "name" : "public void clearCrossProfileIntentFilters(@Nullable ComponentName admin)",
    "returnType" : "void",
    "comment" : "\n     * Called by a profile owner of a managed profile to remove the cross-profile intent filters\n     * that go from the managed profile to the parent, or from the parent to the managed profile.\n     * Only removes those that have been set by the profile owner.\n     * <p>\n     * <em>Note</em>: A list of default cross profile intent filters are set up by the system when\n     * the profile is created, some of them ensure the proper functioning of the profile, while\n     * others enable sharing of data from the parent to the managed profile for user convenience.\n     * These default intent filters are not cleared when this API is called. If the default cross\n     * profile data sharing is not desired, they can be disabled with\n     * {@link UserManager#DISALLOW_SHARE_INTO_MANAGED_PROFILE}.\n     *\n     * @param admin Which {@link DeviceAdminReceiver} this request is associated with.\n     * @throws SecurityException if {@code admin} is not a profile owner.\n     ",
    "links" : [ "android.app.admin.DeviceAdminReceiver", "android.os.UserManager#DISALLOW_SHARE_INTO_MANAGED_PROFILE" ]
  }, {
    "name" : "public boolean setPermittedAccessibilityServices(@NonNull ComponentName admin, List<String> packageNames)",
    "returnType" : "boolean",
    "comment" : "\n     * Called by a profile or device owner to set the permitted\n     * {@link android.accessibilityservice.AccessibilityService}. When set by\n     * a device owner or profile owner the restriction applies to all profiles of the user the\n     * device owner or profile owner is an admin for. By default, the user can use any accessibility\n     * service. When zero or more packages have been added, accessibility services that are not in\n     * the list and not part of the system can not be enabled by the user.\n     * <p>\n     * Calling with a {@code null} value for the list disables the restriction so that all services\n     * can be used, calling with an empty list only allows the built-in system services. Any\n     * non-system accessibility service that's currently enabled must be included in the list.\n     * <p>\n     * System accessibility services are always available to the user and this method can't\n     * disable them.\n     * @param admin Which {@link DeviceAdminReceiver} this request is associated with.\n     * @param packageNames List of accessibility service package names.\n     * @return {@code true} if the operation succeeded, or {@code false} if the list didn't\n     *         contain every enabled non-system accessibility service.\n     * @throws SecurityException if {@code admin} is not a device or profile owner.\n     ",
    "links" : [ "android.accessibilityservice.AccessibilityService", "android.app.admin.DeviceAdminReceiver" ]
  }, {
    "name" : "public List<String> getPermittedAccessibilityServices(@NonNull ComponentName admin)",
    "returnType" : "List<String>",
    "comment" : "\n     * Returns the list of permitted accessibility services set by this device or profile owner.\n     * <p>\n     * An empty list means no accessibility services except system services are allowed.\n     * {@code null} means all accessibility services are allowed.\n     *\n     * @param admin Which {@link DeviceAdminReceiver} this request is associated with.\n     * @return List of accessiblity service package names.\n     * @throws SecurityException if {@code admin} is not a device or profile owner.\n     ",
    "links" : [ "android.app.admin.DeviceAdminReceiver" ]
  }, {
    "name" : "public boolean isAccessibilityServicePermittedByAdmin(@NonNull ComponentName admin, @NonNull String packageName, int userHandle)",
    "returnType" : "boolean",
    "comment" : "\n     * Called by the system to check if a specific accessibility service is disabled by admin.\n     *\n     * @param admin Which {@link DeviceAdminReceiver} this request is associated with.\n     * @param packageName Accessibility service package name that needs to be checked.\n     * @param userHandle user id the admin is running as.\n     * @return true if the accessibility service is permitted, otherwise false.\n     *\n     * @hide\n     ",
    "links" : [ "android.app.admin.DeviceAdminReceiver" ]
  }, {
    "name" : "public List<String> getPermittedAccessibilityServices(int userId)",
    "returnType" : "List<String>",
    "comment" : "\n     * Returns the list of accessibility services permitted by the device or profiles\n     * owners of this user.\n     *\n     * <p>{@code null} means all accessibility services are allowed, if a non-null list is returned\n     * it will contain the intersection of the permitted lists for any device or profile\n     * owners that apply to this user. It will also include any system accessibility services.\n     *\n     * @param userId which user to check for.\n     * @return List of accessiblity service package names.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean setPermittedInputMethods(@Nullable ComponentName admin, List<String> packageNames)",
    "returnType" : "boolean",
    "comment" : "\n     * Called by a profile or device owner or holder of the\n     * {@link android.Manifest.permission#MANAGE_DEVICE_POLICY_INPUT_METHODS} permission to set\n     * the permitted input methods services for this user. By default, the user can use any input\n     * method.\n     * <p>\n     * This method can be called on the {@link DevicePolicyManager} instance,\n     * returned by {@link #getParentProfileInstance(ComponentName)}, where the caller must be\n     * a profile owner of an organization-owned device.\n     * <p>\n     * If called on the parent instance:\n     * <ul>\n     *    <li>The permitted input methods will be applied on the personal profile</li>\n     *    <li>Can only permit all input methods (calling this method with a {@code null} package\n     *    list) or only permit system input methods (calling this method with an empty package\n     *    list). This is to prevent the caller from learning which packages are installed on\n     *    the personal side</li>\n     * </ul>\n     * <p>\n     * When zero or more packages have been added, input method that are not in the list and not\n     * part of the system can not be enabled by the user. This method will fail if it is called for\n     * a admin that is not for the foreground user or a profile of the foreground user. Any\n     * non-system input method service that's currently enabled must be included in the list.\n     * <p>\n     * Calling with a null value for the list disables the restriction so that all input methods can\n     * be used, calling with an empty list disables all but the system's own input methods.\n     * <p>\n     * System input methods are always available to the user - this method can't modify this.\n     *\n     * @param admin Which {@link DeviceAdminReceiver} this request is associated with. Null if the\n     *              caller is not a device admin\n     * @param packageNames List of input method package names.\n     * @return {@code true} if the operation succeeded, or {@code false} if the list didn't\n     *        contain every enabled non-system input method service.\n     * @throws SecurityException if {@code admin} is not a device or profile owner and does not\n     *                              hold the {@link android.Manifest.permission#MANAGE_DEVICE_POLICY_INPUT_METHODS}\n     *                              permission, or if called on the parent profile and the\n     *                              {@code admin} is not a profile owner of an organization-owned\n     *                              managed profile.\n     * @throws IllegalArgumentException if called on the parent profile, the {@code admin} is a\n     *                           profile owner of an organization-owned managed profile and the\n     *                           list of permitted input method package names is not null or empty.\n     ",
    "links" : [ "#getParentProfileInstance(ComponentName)", "android.app.admin.DeviceAdminReceiver", "android.app.admin.DevicePolicyManager", "android.Manifest.permission#MANAGE_DEVICE_POLICY_INPUT_METHODS" ]
  }, {
    "name" : "public List<String> getPermittedInputMethods(@Nullable ComponentName admin)",
    "returnType" : "List<String>",
    "comment" : "\n     * Returns the list of permitted input methods set by this device or profile owner.\n     * <p>\n     * This method can be called on the {@link DevicePolicyManager} instance,\n     * returned by {@link #getParentProfileInstance(ComponentName)}, where the caller must be\n     * a profile owner of an organization-owned managed profile. If called on the parent instance,\n     * then the returned list of permitted input methods are those which are applied on the\n     * personal profile.\n     * <p>\n     * An empty list means no input methods except system input methods are allowed. Null means all\n     * input methods are allowed.\n     *\n     * @param admin Which {@link DeviceAdminReceiver} this request is associated with. Null if the\n     *              caller is not a device admin\n     * @return List of input method package names.\n     * @throws SecurityException if {@code admin} is not a device, profile owner or if called on\n     *                           the parent profile and the {@code admin} is not a profile owner\n     *                           of an organization-owned managed profile.\n     ",
    "links" : [ "#getParentProfileInstance(ComponentName)", "android.app.admin.DeviceAdminReceiver", "android.app.admin.DevicePolicyManager" ]
  }, {
    "name" : "public boolean isInputMethodPermittedByAdmin(@NonNull ComponentName admin, @NonNull String packageName, int userHandle)",
    "returnType" : "boolean",
    "comment" : "\n     * Called by the system to check if a specific input method is disabled by admin.\n     * <p>\n     * This method can be called on the {@link DevicePolicyManager} instance,\n     * returned by {@link #getParentProfileInstance(ComponentName)}. If called on the parent\n     * instance, this method will check whether the given input method is permitted on\n     * the personal profile.\n     *\n     * @param admin Which {@link DeviceAdminReceiver} this request is associated with.\n     * @param packageName Input method package name that needs to be checked.\n     * @param userHandle user id the admin is running as.\n     * @return true if the input method is permitted, otherwise false.\n     *\n     * @hide\n     ",
    "links" : [ "#getParentProfileInstance(ComponentName)", "android.app.admin.DeviceAdminReceiver", "android.app.admin.DevicePolicyManager" ]
  }, {
    "name" : "public List<String> getPermittedInputMethodsForCurrentUser()",
    "returnType" : "List<String>",
    "comment" : "\n     * Returns the list of input methods permitted by the device or profiles owners.\n     *\n     * <p>On {@link android.os.Build.VERSION_CODES#Q} and later devices, this method returns the\n     * result for the calling user.</p>\n     *\n     * <p>On Android P and prior devices, this method returns the result for the current user.</p>\n     *\n     * <p>Null means all input methods are allowed, if a non-null list is returned\n     * it will contain the intersection of the permitted lists for any device or profile\n     * owners that apply to this user. It will also include any system input methods.\n     *\n     * @return List of input method package names.\n     * @hide\n     *\n     * @see #setPermittedAccessibilityServices(ComponentName, List)\n     ",
    "links" : [ "android.os.Build.VERSION_CODES#Q" ]
  }, {
    "name" : "public List<String> getPermittedInputMethods()",
    "returnType" : "List<String>",
    "comment" : "\n     * Returns the list of input methods permitted.\n     *\n     * <p>{@code null} means all input methods are allowed, if a non-null list is returned\n     * it will contain the intersection of the permitted lists for any device or profile\n     * owners that apply to this user. It will also include any system input methods.\n     *\n     * @return List of input method package names.\n     * @hide\n     *\n     * @see #setPermittedAccessibilityServices(ComponentName, List)\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean setPermittedCrossProfileNotificationListeners(@NonNull ComponentName admin, @Nullable List<String> packageList)",
    "returnType" : "boolean",
    "comment" : "\n     * Called by a profile owner of a managed profile to set the packages that are allowed to use\n     * a {@link android.service.notification.NotificationListenerService} in the primary user to\n     * see notifications from the managed profile. By default all packages are permitted by this\n     * policy. When zero or more packages have been added, notification listeners installed on the\n     * primary user that are not in the list and are not part of the system won't receive events\n     * for managed profile notifications.\n     * <p>\n     * Calling with a {@code null} value for the list disables the restriction so that all\n     * notification listener services be used. Calling with an empty list disables all but the\n     * system's own notification listeners. System notification listener services are always\n     * available to the user.\n     * <p>\n     * If a device or profile owner want to stop notification listeners in their user from seeing\n     * that user's notifications they should prevent that service from running instead (e.g. via\n     * {@link #setApplicationHidden(ComponentName, String, boolean)})\n     *\n     * @param admin Which {@link DeviceAdminReceiver} this request is associated with.\n     * @param packageList List of package names to allowlist\n     * @return true if setting the restriction succeeded. It will fail if called outside a managed\n     * profile\n     * @throws SecurityException if {@code admin} is not a profile owner.\n     *\n     * @see android.service.notification.NotificationListenerService\n     ",
    "links" : [ "android.app.admin.DeviceAdminReceiver", "android.service.notification.NotificationListenerService", "#setApplicationHidden(ComponentName" ]
  }, {
    "name" : "public List<String> getPermittedCrossProfileNotificationListeners(@NonNull ComponentName admin)",
    "returnType" : "List<String>",
    "comment" : "\n     * Returns the list of packages installed on the primary user that allowed to use a\n     * {@link android.service.notification.NotificationListenerService} to receive\n     * notifications from this managed profile, as set by the profile owner.\n     * <p>\n     * An empty list means no notification listener services except system ones are allowed.\n     * A {@code null} return value indicates that all notification listeners are allowed.\n     ",
    "links" : [ "android.service.notification.NotificationListenerService" ]
  }, {
    "name" : "public boolean isNotificationListenerServicePermitted(@NonNull String packageName, @UserIdInt int userId)",
    "returnType" : "boolean",
    "comment" : "\n     * Returns true if {@code NotificationListenerServices} from the given package are allowed to\n     * receive events for notifications from the given user id. Can only be called by the system uid\n     *\n     * @see #setPermittedCrossProfileNotificationListeners(ComponentName, List)\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public List<String> getKeepUninstalledPackages(@Nullable ComponentName admin)",
    "returnType" : "List<String>",
    "comment" : "\n     * Get the list of apps to keep around as APKs even if no user has currently installed it. This\n     * function can be called by a device owner or by a delegate given the\n     * {@link #DELEGATION_KEEP_UNINSTALLED_PACKAGES} scope via {@link #setDelegatedScopes}.\n     * <p>\n     * Please note that packages returned in this method are not automatically pre-cached.\n     *\n     * @param admin Which {@link DeviceAdminReceiver} this request is associated with, or\n     *            {@code null} if the caller is a keep uninstalled packages delegate.\n     * @return List of package names to keep cached.\n     * @see #setDelegatedScopes\n     * @see #DELEGATION_KEEP_UNINSTALLED_PACKAGES\n     ",
    "links" : [ "#DELEGATION_KEEP_UNINSTALLED_PACKAGES", "android.app.admin.DeviceAdminReceiver", "#setDelegatedScopes" ]
  }, {
    "name" : "public void setKeepUninstalledPackages(@Nullable ComponentName admin, @NonNull List<String> packageNames)",
    "returnType" : "void",
    "comment" : "\n     * Set a list of apps to keep around as APKs even if no user has currently installed it. This\n     * function can be called by a device owner or by a delegate given the\n     * {@link #DELEGATION_KEEP_UNINSTALLED_PACKAGES} scope via {@link #setDelegatedScopes}.\n     *\n     * <p>Please note that setting this policy does not imply that specified apps will be\n     * automatically pre-cached.</p>\n     *\n     * @param admin Which {@link DeviceAdminReceiver} this request is associated with, or\n     *            {@code null} if the caller is a keep uninstalled packages delegate.\n     * @param packageNames List of package names to keep cached.\n     * @throws SecurityException if {@code admin} is not a device owner.\n     * @see #setDelegatedScopes\n     * @see #DELEGATION_KEEP_UNINSTALLED_PACKAGES\n     ",
    "links" : [ "#DELEGATION_KEEP_UNINSTALLED_PACKAGES", "android.app.admin.DeviceAdminReceiver", "#setDelegatedScopes" ]
  }, {
    "name" : "public UserHandle createAndManageUser(@NonNull ComponentName admin, @NonNull String name, @NonNull ComponentName profileOwner, @Nullable PersistableBundle adminExtras, @CreateAndManageUserFlags int flags)",
    "returnType" : "UserHandle",
    "comment" : "\n     * Called by a device owner to create a user with the specified name and a given component of\n     * the calling package as profile owner. The UserHandle returned by this method should not be\n     * persisted as user handles are recycled as users are removed and created. If you need to\n     * persist an identifier for this user, use {@link UserManager#getSerialNumberForUser}. The new\n     * user will not be started in the background.\n     * <p>\n     * admin is the {@link DeviceAdminReceiver} which is the device owner. profileOwner is also a\n     * DeviceAdminReceiver in the same package as admin, and will become the profile owner and will\n     * be registered as an active admin on the new user. The profile owner package will be installed\n     * on the new user.\n     * <p>\n     * If the adminExtras are not null, they will be stored on the device until the user is started\n     * for the first time. Then the extras will be passed to the admin when onEnable is called.\n     * <p>From {@link android.os.Build.VERSION_CODES#P} onwards, if targeting\n     * {@link android.os.Build.VERSION_CODES#P}, throws {@link UserOperationException} instead of\n     * returning {@code null} on failure.\n     *\n     * @param admin Which {@link DeviceAdminReceiver} this request is associated with.\n     * @param name The user's name.\n     * @param profileOwner Which {@link DeviceAdminReceiver} will be profile owner. Has to be in the\n     *            same package as admin, otherwise no user is created and an\n     *            IllegalArgumentException is thrown.\n     * @param adminExtras Extras that will be passed to onEnable of the admin receiver on the new\n     *            user.\n     * @param flags {@link #SKIP_SETUP_WIZARD}, {@link #MAKE_USER_EPHEMERAL} and\n     *        {@link #LEAVE_ALL_SYSTEM_APPS_ENABLED} are supported.\n     * @see UserHandle\n     * @return the {@link android.os.UserHandle} object for the created user, or {@code null} if the\n     *         user could not be created.\n     * @throws SecurityException if headless device is in\n     *        {@link DeviceAdminInfo#HEADLESS_DEVICE_OWNER_MODE_SINGLE_USER} mode.\n     * @throws SecurityException if {@code admin} is not a device owner\n     * @throws UserOperationException if the user could not be created and the calling app is\n     * targeting {@link android.os.Build.VERSION_CODES#P} and running on\n     * {@link android.os.Build.VERSION_CODES#P}.\n     ",
    "links" : [ "android.os.Build.VERSION_CODES#P", "#LEAVE_ALL_SYSTEM_APPS_ENABLED", "android.app.admin.DeviceAdminInfo#HEADLESS_DEVICE_OWNER_MODE_SINGLE_USER", "android.app.admin.DeviceAdminReceiver", "android.os.UserManager.UserOperationException", "android.os.UserHandle", "#SKIP_SETUP_WIZARD", "android.os.UserManager#getSerialNumberForUser", "#MAKE_USER_EPHEMERAL" ]
  }, {
    "name" : "public boolean removeUser(@NonNull ComponentName admin, @NonNull UserHandle userHandle)",
    "returnType" : "boolean",
    "comment" : "\n     * Called by a device owner to remove a user/profile and all associated data. The primary user\n     * can not be removed.\n     *\n     * @param admin Which {@link DeviceAdminReceiver} this request is associated with.\n     * @param userHandle the user to remove.\n     * @return {@code true} if the user was removed, {@code false} otherwise.\n     * @throws SecurityException if {@code admin} is not a device owner.\n     ",
    "links" : [ "android.app.admin.DeviceAdminReceiver" ]
  }, {
    "name" : "public boolean switchUser(@NonNull ComponentName admin, @Nullable UserHandle userHandle)",
    "returnType" : "boolean",
    "comment" : "\n     * Called by a device owner to switch the specified secondary user to the foreground.\n     *\n     * @param admin Which {@link DeviceAdminReceiver} this request is associated with.\n     * @param userHandle the user to switch to; null will switch to primary.\n     * @return {@code true} if the switch was successful, {@code false} otherwise.\n     * @throws SecurityException if {@code admin} is not a device owner.\n     * @see Intent#ACTION_USER_FOREGROUND\n     * @see #getSecondaryUsers(ComponentName)\n     ",
    "links" : [ "android.app.admin.DeviceAdminReceiver" ]
  }, {
    "name" : "public int startUserInBackground(@NonNull ComponentName admin, @NonNull UserHandle userHandle)",
    "returnType" : "int",
    "comment" : "\n     * Called by a device owner to start the specified secondary user in background.\n     *\n     * @param admin Which {@link DeviceAdminReceiver} this request is associated with.\n     * @param userHandle the user to be started in background.\n     * @return one of the following result codes:\n     * {@link UserManager#USER_OPERATION_ERROR_UNKNOWN},\n     * {@link UserManager#USER_OPERATION_SUCCESS},\n     * {@link UserManager#USER_OPERATION_ERROR_MANAGED_PROFILE},\n     * {@link UserManager#USER_OPERATION_ERROR_MAX_RUNNING_USERS},\n     * @throws SecurityException if {@code admin} is not a device owner.\n     * @see #getSecondaryUsers(ComponentName)\n     ",
    "links" : [ "android.os.UserManager#USER_OPERATION_ERROR_UNKNOWN", "android.app.admin.DeviceAdminReceiver", "android.os.UserManager#USER_OPERATION_SUCCESS", "android.os.UserManager#USER_OPERATION_ERROR_MANAGED_PROFILE", "android.os.UserManager#USER_OPERATION_ERROR_MAX_RUNNING_USERS" ]
  }, {
    "name" : "public int stopUser(@NonNull ComponentName admin, @NonNull UserHandle userHandle)",
    "returnType" : "int",
    "comment" : "\n     * Called by a device owner to stop the specified secondary user.\n     *\n     * @param admin Which {@link DeviceAdminReceiver} this request is associated with.\n     * @param userHandle the user to be stopped.\n     * @return one of the following result codes:\n     * {@link UserManager#USER_OPERATION_ERROR_UNKNOWN},\n     * {@link UserManager#USER_OPERATION_SUCCESS},\n     * {@link UserManager#USER_OPERATION_ERROR_MANAGED_PROFILE},\n     * {@link UserManager#USER_OPERATION_ERROR_CURRENT_USER}\n     * @throws SecurityException if {@code admin} is not a device owner.\n     * @see #getSecondaryUsers(ComponentName)\n     ",
    "links" : [ "android.os.UserManager#USER_OPERATION_ERROR_UNKNOWN", "android.app.admin.DeviceAdminReceiver", "android.os.UserManager#USER_OPERATION_SUCCESS", "android.os.UserManager#USER_OPERATION_ERROR_MANAGED_PROFILE", "android.os.UserManager#USER_OPERATION_ERROR_CURRENT_USER" ]
  }, {
    "name" : "public int logoutUser(@NonNull ComponentName admin)",
    "returnType" : "int",
    "comment" : "\n     * Called by a profile owner of secondary user that is affiliated with the device to stop the\n     * calling user and switch back to primary user (when the user was\n     * {@link #switchUser(ComponentName, UserHandle)} switched to) or stop the user (when it was\n     * {@link #startUserInBackground(ComponentName, UserHandle) started in background}.\n     *\n     * <p>Notice that on devices running with\n     * {@link UserManager#isHeadlessSystemUserMode() headless system user mode}, there is no primary\n     * user, so it switches back to the user that was in the foreground before the first call to\n     * {@link #switchUser(ComponentName, UserHandle)} (or fails with\n     * {@link UserManager#USER_OPERATION_ERROR_UNKNOWN} if that method was not called prior to this\n     * call).\n     *\n     * @param admin Which {@link DeviceAdminReceiver} this request is associated with.\n     * @return one of the following result codes:\n     * {@link UserManager#USER_OPERATION_ERROR_UNKNOWN},\n     * {@link UserManager#USER_OPERATION_SUCCESS},\n     * {@link UserManager#USER_OPERATION_ERROR_MANAGED_PROFILE},\n     * {@link UserManager#USER_OPERATION_ERROR_CURRENT_USER}\n     * @throws SecurityException if {@code admin} is not a profile owner affiliated with the device.\n     * @see #getSecondaryUsers(ComponentName)\n     ",
    "links" : [ "android.os.UserManager#USER_OPERATION_ERROR_UNKNOWN", "android.app.admin.DeviceAdminReceiver", "#startUserInBackground(ComponentName", "android.os.UserManager#USER_OPERATION_SUCCESS", "android.os.UserManager#USER_OPERATION_ERROR_MANAGED_PROFILE", "android.os.UserManager#USER_OPERATION_ERROR_CURRENT_USER", "android.os.UserManager#isHeadlessSystemUserMode()", "#switchUser(ComponentName" ]
  }, {
    "name" : "public void setManagedSubscriptionsPolicy(@Nullable ManagedSubscriptionsPolicy policy)",
    "returnType" : "void",
    "comment" : "\n     * Called by a profile owner of an organization-owned device to specify {@link\n     * ManagedSubscriptionsPolicy}\n     *\n     * <p>Managed subscriptions policy controls how SIMs would be associated with the\n     * managed profile. For example a policy of type\n     * {@link ManagedSubscriptionsPolicy#TYPE_ALL_MANAGED_SUBSCRIPTIONS} assigns all\n     * SIM-based subscriptions to the managed profile. In this case OEM default\n     * dialer and messages app are automatically installed in the managed profile\n     * and all incoming and outgoing calls and text messages are handled by them.\n     * <p>This API can only be called during device setup.\n     *\n     * @param policy {@link ManagedSubscriptionsPolicy} policy, passing null for this resets the\n     *               policy to be the default.\n     * @throws SecurityException     if the caller is not a profile owner on an organization-owned\n     *                               managed profile.\n     * @throws IllegalStateException if called after the device setup has been completed.\n     * @throws UnsupportedOperationException if managed subscriptions policy is not explicitly\n     *         enabled by the device policy management role holder during device setup.\n     * @see ManagedSubscriptionsPolicy\n     ",
    "links" : [ "android.app.admin.ManagedSubscriptionsPolicy#TYPE_ALL_MANAGED_SUBSCRIPTIONS", "android.app.admin.ManagedSubscriptionsPolicy" ]
  }, {
    "name" : "public ManagedSubscriptionsPolicy getManagedSubscriptionsPolicy()",
    "returnType" : "ManagedSubscriptionsPolicy",
    "comment" : "\n     * Returns the current {@link ManagedSubscriptionsPolicy}.\n     * If the policy has not been set, it will return a default policy of Type {@link\n     * ManagedSubscriptionsPolicy#TYPE_ALL_PERSONAL_SUBSCRIPTIONS}.\n     *\n     * @see #setManagedSubscriptionsPolicy(ManagedSubscriptionsPolicy)\n     ",
    "links" : [ "android.app.admin.ManagedSubscriptionsPolicy#TYPE_ALL_PERSONAL_SUBSCRIPTIONS", "android.app.admin.ManagedSubscriptionsPolicy" ]
  }, {
    "name" : "public int logoutUser()",
    "returnType" : "int",
    "comment" : "\n     * Similar to {@link #logoutUser(ComponentName)}, except:\n     *\n     * <ul>\n     *   <li>Called by system (like Settings), not admin.\n     *   <li>It logs out the current user, not the caller.\n     * </ul>\n     *\n     * @hide\n     ",
    "links" : [ "#logoutUser(ComponentName)" ]
  }, {
    "name" : "public UserHandle getLogoutUser()",
    "returnType" : "UserHandle",
    "comment" : "\n     * Gets the user a {@link #logoutUser(ComponentName)} call would switch to,\n     * or {@code null} if the current user is not in a session (i.e., if it was not\n     * {@link #switchUser(ComponentName, UserHandle) switched} or\n     * {@link #startUserInBackground(ComponentName, UserHandle) started in background} by the\n     * device admin.\n     *\n     * @hide\n     ",
    "links" : [ "#startUserInBackground(ComponentName", "#logoutUser(ComponentName)", "#switchUser(ComponentName" ]
  }, {
    "name" : "public List<UserHandle> getSecondaryUsers(@NonNull ComponentName admin)",
    "returnType" : "List<UserHandle>",
    "comment" : "\n     * Called by a device owner to list all secondary users on the device. Managed profiles are not\n     * considered as secondary users.\n     * <p> Used for various user management APIs, including {@link #switchUser}, {@link #removeUser}\n     * and {@link #stopUser}.\n     *\n     * @param admin Which {@link DeviceAdminReceiver} this request is associated with.\n     * @return list of other {@link UserHandle}s on the device.\n     * @throws SecurityException if {@code admin} is not a device owner.\n     * @see #removeUser(ComponentName, UserHandle)\n     * @see #switchUser(ComponentName, UserHandle)\n     * @see #startUserInBackground(ComponentName, UserHandle)\n     * @see #stopUser(ComponentName, UserHandle)\n     ",
    "links" : [ "#stopUser", "#switchUser", "android.app.admin.DeviceAdminReceiver", "android.os.UserHandle", "#removeUser" ]
  }, {
    "name" : "public boolean isEphemeralUser(@NonNull ComponentName admin)",
    "returnType" : "boolean",
    "comment" : "\n     * Checks if the profile owner is running in an ephemeral user.\n     *\n     * @param admin Which {@link DeviceAdminReceiver} this request is associated with.\n     * @return whether the profile owner is running in an ephemeral user.\n     ",
    "links" : [ "android.app.admin.DeviceAdminReceiver" ]
  }, {
    "name" : "public Bundle getApplicationRestrictions(@Nullable ComponentName admin, String packageName)",
    "returnType" : "Bundle",
    "comment" : "\n     * Retrieves the application restrictions for a given target application running in the calling\n     * user.\n     * <p>\n     * The caller must be a profile or device owner on that user, or the package allowed to manage\n     * application restrictions via {@link #setDelegatedScopes} with the\n     * {@link #DELEGATION_APP_RESTRICTIONS} scope; otherwise a security exception will be thrown.\n     *\n     * <p>NOTE: The method performs disk I/O and shouldn't be called on the main thread\n     *\n     * @param admin Which {@link DeviceAdminReceiver} this request is associated with, or\n     *            {@code null} if called by the application restrictions managing package.\n     * @param packageName The name of the package to fetch restricted settings of.\n     * @return {@link Bundle} of settings corresponding to what was set last time\n     *         {@link DevicePolicyManager#setApplicationRestrictions} was called, or an empty\n     *         {@link Bundle} if no restrictions have been set.\n     * @throws SecurityException if {@code admin} is not a device or profile owner.\n     * @see #setDelegatedScopes\n     * @see #DELEGATION_APP_RESTRICTIONS\n     ",
    "links" : [ "android.os.Bundle", "android.app.admin.DeviceAdminReceiver", "android.app.admin.DevicePolicyManager#setApplicationRestrictions", "#DELEGATION_APP_RESTRICTIONS", "#setDelegatedScopes" ]
  }, {
    "name" : "public void addUserRestriction(@NonNull ComponentName admin, @UserManager.UserRestrictionKey String key)",
    "returnType" : "void",
    "comment" : "\n     * Called by a profile owner, device owner or a holder of any permission that is associated with\n     * a user restriction to set a user restriction specified by the key.\n     * <p>\n     * The calling device admin must be a profile owner, device owner or holder of any permission\n     * that is associated with a user restriction; if it is not, a security\n     * exception will be thrown.\n     * <p>\n     * The profile owner of an organization-owned managed profile may invoke this method on\n     * the {@link DevicePolicyManager} instance it obtained from\n     * {@link #getParentProfileInstance(ComponentName)}, for enforcing device-wide restrictions.\n     * <p>\n     * See the constants in {@link android.os.UserManager} for the list of restrictions that can\n     * be enforced device-wide. These constants will also state in their documentation which\n     * permission is required to manage the restriction using this API.\n     *\n     * <p>For callers targeting Android {@link android.os.Build.VERSION_CODES#UPSIDE_DOWN_CAKE} or\n     * above, calling this API will result in applying the restriction locally on the calling user,\n     * or locally on the parent profile if called from the\n     * {@link DevicePolicyManager} instance obtained from\n     * {@link #getParentProfileInstance(ComponentName)}. To set a restriction globally, call\n     * {@link #addUserRestrictionGlobally} instead.\n     *\n     * <p>\n     * Starting from {@link Build.VERSION_CODES#UPSIDE_DOWN_CAKE}, after the user restriction\n     * policy has been set, {@link PolicyUpdateReceiver#onPolicySetResult(Context, String,\n     * Bundle, TargetUser, PolicyUpdateResult)} will notify the admin on whether the policy was\n     * successfully set or not. This callback will contain:\n     * <ul>\n     * <li> The policy identifier returned from\n     * {@link DevicePolicyIdentifiers#getIdentifierForUserRestriction(String)}\n     * <li> The {@link TargetUser} that this policy relates to\n     * <li> The {@link PolicyUpdateResult}, which will be\n     * {@link PolicyUpdateResult#RESULT_POLICY_SET} if the policy was successfully set or the\n     * reason the policy failed to be set\n     * (e.g. {@link PolicyUpdateResult#RESULT_FAILURE_CONFLICTING_ADMIN_POLICY})\n     * </ul>\n     * If there has been a change to the policy,\n     * {@link PolicyUpdateReceiver#onPolicyChanged(Context, String, Bundle, TargetUser,\n     * PolicyUpdateResult)} will notify the admin of this change. This callback will contain the\n     * same parameters as PolicyUpdateReceiver#onPolicySetResult and the {@link PolicyUpdateResult}\n     * will contain the reason why the policy changed.\n     *\n     * @param admin Which {@link DeviceAdminReceiver} this request is associated with.\n     * @param key   The key of the restriction.\n     * @throws SecurityException if {@code admin} is not a device or profile owner and if the caller\n     * has not been granted the permission to set the given user restriction.\n     ",
    "links" : [ "android.os.UserManager", "android.app.admin.PolicyUpdateResult#RESULT_FAILURE_CONFLICTING_ADMIN_POLICY", "android.app.admin.PolicyUpdateResult#RESULT_POLICY_SET", "android.os.Build.VERSION_CODES#UPSIDE_DOWN_CAKE", "#addUserRestrictionGlobally", "android.app.admin.PolicyUpdateReceiver#onPolicyChanged(Context", "android.app.admin.PolicyUpdateReceiver#onPolicySetResult(Context", "android.app.admin.TargetUser", "#getParentProfileInstance(ComponentName)", "android.app.admin.PolicyUpdateResult", "android.app.admin.DevicePolicyIdentifiers#getIdentifierForUserRestriction(String)", "android.app.admin.DeviceAdminReceiver", "android.app.admin.DevicePolicyManager", "Build.VERSION_CODES#UPSIDE_DOWN_CAKE" ]
  }, {
    "name" : "public void addUserRestrictionGlobally(@NonNull @UserManager.UserRestrictionKey String key)",
    "returnType" : "void",
    "comment" : "\n     * Called by a profile owner, device owner or a holder of any permission that is associated with\n     *  a user restriction to set a user restriction specified by the provided {@code key} globally\n     *  on all users. To clear the restriction use {@link #clearUserRestriction}.\n     *\n     * <p>For a given user, a restriction will be set if it was applied globally or locally by any\n     * admin.\n     *\n     * <p> The calling device admin must be a profile owner, device owner or or a holder of any\n     * permission that is associated with a user restriction; if it is not, a security\n     * exception will be thrown.\n     *\n     * <p> See the constants in {@link android.os.UserManager} for the list of restrictions that can\n     * be enforced device-wide. These constants will also state in their documentation which\n     * permission is required to manage the restriction using this API.\n     * <p>\n     * After the user restriction policy has been set,\n     * {@link PolicyUpdateReceiver#onPolicySetResult(Context, String, Bundle, TargetUser,\n     * PolicyUpdateResult)} will notify the admin on whether the policy was successfully set or not.\n     * This callback will contain:\n     * <ul>\n     * <li> The policy identifier returned from\n     * {@link DevicePolicyIdentifiers#getIdentifierForUserRestriction(String)}\n     * <li> The {@link TargetUser} that this policy relates to\n     * <li> The {@link PolicyUpdateResult}, which will be\n     * {@link PolicyUpdateResult#RESULT_POLICY_SET} if the policy was successfully set or the\n     * reason the policy failed to be set\n     * (e.g. {@link PolicyUpdateResult#RESULT_FAILURE_CONFLICTING_ADMIN_POLICY})\n     * </ul>\n     * If there has been a change to the policy,\n     * {@link PolicyUpdateReceiver#onPolicyChanged(Context, String, Bundle, TargetUser,\n     * PolicyUpdateResult)} will notify the admin of this change. This callback will contain the\n     * same parameters as PolicyUpdateReceiver#onPolicySetResult and the {@link PolicyUpdateResult}\n     * will contain the reason why the policy changed.\n     *\n     * @param key The key of the restriction.\n     * @throws SecurityException if {@code admin} is not a device or profile owner and if the\n     * caller has not been granted the permission to set the given user restriction.\n     * @throws IllegalStateException if caller is not targeting Android\n     * {@link android.os.Build.VERSION_CODES#UPSIDE_DOWN_CAKE} or above.\n     ",
    "links" : [ "#clearUserRestriction", "android.os.UserManager", "android.app.admin.PolicyUpdateResult#RESULT_FAILURE_CONFLICTING_ADMIN_POLICY", "android.app.admin.PolicyUpdateResult", "android.app.admin.PolicyUpdateResult#RESULT_POLICY_SET", "android.app.admin.DevicePolicyIdentifiers#getIdentifierForUserRestriction(String)", "android.os.Build.VERSION_CODES#UPSIDE_DOWN_CAKE", "android.app.admin.PolicyUpdateReceiver#onPolicyChanged(Context", "android.app.admin.PolicyUpdateReceiver#onPolicySetResult(Context", "android.app.admin.TargetUser" ]
  }, {
    "name" : "public void clearUserRestriction(@NonNull ComponentName admin, @UserManager.UserRestrictionKey String key)",
    "returnType" : "void",
    "comment" : "\n     * Called by a profile owner, device owner or a holder of any permission that is associated with\n     * a user restriction to clear a user restriction specified by the key.\n     * <p>\n     * The calling device admin must be a profile or device owner; if it is not, a security\n     * exception will be thrown.\n     * <p>\n     * The profile owner of an organization-owned managed profile may invoke this method on\n     * the {@link DevicePolicyManager} instance it obtained from\n     * {@link #getParentProfileInstance(ComponentName)}, for clearing device-wide restrictions.\n     * <p>\n     * See the constants in {@link android.os.UserManager} for the list of restrictions. These\n     * constants state in their documentation which permission is required to manage the restriction\n     * using this API.\n     *\n     * <p>For callers targeting Android {@link android.os.Build.VERSION_CODES#UPSIDE_DOWN_CAKE} or\n     * above, calling this API will result in clearing any local and global restriction with the\n     * specified key that was previously set by the caller.\n     *\n     * <p>\n     * Starting from {@link Build.VERSION_CODES#UPSIDE_DOWN_CAKE}, after the user restriction\n     * policy has been cleared, {@link PolicyUpdateReceiver#onPolicySetResult(Context, String,\n     * Bundle, TargetUser, PolicyUpdateResult)} will notify the admin on whether the policy was\n     * successfully cleared or not. This callback will contain:\n     * <ul>\n     * <li> The policy identifier returned from\n     * {@link DevicePolicyIdentifiers#getIdentifierForUserRestriction(String)}\n     * <li> The {@link TargetUser} that this policy relates to\n     * <li> The {@link PolicyUpdateResult}, which will be\n     * {@link PolicyUpdateResult#RESULT_POLICY_SET} if the policy was successfully cleared or the\n     * reason the policy failed to be cleared\n     * (e.g. {@link PolicyUpdateResult#RESULT_FAILURE_CONFLICTING_ADMIN_POLICY})\n     * </ul>\n     * If there has been a change to the policy,\n     * {@link PolicyUpdateReceiver#onPolicyChanged(Context, String, Bundle, TargetUser,\n     * PolicyUpdateResult)} will notify the admin of this change. This callback will contain the\n     * same parameters as PolicyUpdateReceiver#onPolicySetResult and the {@link PolicyUpdateResult}\n     * will contain the reason why the policy changed.\n     *\n     * @param admin Which {@link DeviceAdminReceiver} this request is associated with.\n     * @param key   The key of the restriction.\n     * @throws SecurityException if {@code admin} is not a device or profile owner  and if the\n     *  caller has not been granted the permission to set the given user restriction.\n     ",
    "links" : [ "android.os.UserManager", "android.app.admin.PolicyUpdateResult#RESULT_FAILURE_CONFLICTING_ADMIN_POLICY", "android.app.admin.PolicyUpdateResult#RESULT_POLICY_SET", "android.os.Build.VERSION_CODES#UPSIDE_DOWN_CAKE", "android.app.admin.PolicyUpdateReceiver#onPolicyChanged(Context", "android.app.admin.PolicyUpdateReceiver#onPolicySetResult(Context", "android.app.admin.TargetUser", "#getParentProfileInstance(ComponentName)", "android.app.admin.PolicyUpdateResult", "android.app.admin.DevicePolicyIdentifiers#getIdentifierForUserRestriction(String)", "android.app.admin.DeviceAdminReceiver", "android.app.admin.DevicePolicyManager", "Build.VERSION_CODES#UPSIDE_DOWN_CAKE" ]
  }, {
    "name" : "public Bundle getUserRestrictions(@NonNull ComponentName admin)",
    "returnType" : "Bundle",
    "comment" : "\n     * Called by an admin to get user restrictions set by themselves with\n     * {@link #addUserRestriction(ComponentName, String)}.\n     * <p>\n     * The target user may have more restrictions set by the system or other admin.\n     * To get all the user restrictions currently set, use\n     * {@link UserManager#getUserRestrictions()}.\n     * <p>\n     * The profile owner of an organization-owned managed profile may invoke this method on\n     * the {@link DevicePolicyManager} instance it obtained from\n     * {@link #getParentProfileInstance(ComponentName)}, for retrieving device-wide restrictions\n     * it previously set with {@link #addUserRestriction(ComponentName, String)}.\n     *\n     * <p>For callers targeting Android {@link android.os.Build.VERSION_CODES#UPSIDE_DOWN_CAKE} or\n     * above, this API will return the local restrictions set on the calling user, or on the parent\n     * profile if called from the {@link DevicePolicyManager} instance obtained from\n     * {@link #getParentProfileInstance(ComponentName)}. To get global restrictions set by admin,\n     * call {@link #getUserRestrictionsGlobally()} instead.\n     *\n     * <p>Note that this is different that the returned restrictions for callers targeting pre\n     * Android {@link android.os.Build.VERSION_CODES#UPSIDE_DOWN_CAKE}, were this API returns\n     * all local/global restrictions set by the admin on the calling user using\n     * {@link #addUserRestriction(ComponentName, String)} or the parent user if called on the\n     * {@link DevicePolicyManager} instance it obtained from {@link #getParentProfileInstance}.\n     *\n     * @param admin Which {@link DeviceAdminReceiver} this request is associated with.\n     * @return a {@link Bundle} whose keys are the user restrictions, and the values a\n     * {@code boolean} indicating whether the restriction is set.\n     * @throws SecurityException if {@code admin} is not a device or profile owner.\n     ",
    "links" : [ "#getUserRestrictionsGlobally()", "#getParentProfileInstance(ComponentName)", "android.os.Bundle", "#addUserRestriction(ComponentName", "android.os.Build.VERSION_CODES#UPSIDE_DOWN_CAKE", "android.app.admin.DeviceAdminReceiver", "android.app.admin.DevicePolicyManager", "android.os.UserManager#getUserRestrictions()", "#getParentProfileInstance" ]
  }, {
    "name" : "public Bundle getUserRestrictionsGlobally()",
    "returnType" : "Bundle",
    "comment" : "\n     * Called by a profile or device owner to get global user restrictions set with\n     * {@link #addUserRestrictionGlobally(String)}.\n     * <p>\n     * To get all the user restrictions currently set for a certain user, use\n     * {@link UserManager#getUserRestrictions()}.\n     * @return a {@link Bundle} whose keys are the user restrictions, and the values a\n     * {@code boolean} indicating whether the restriction is set.\n     * @throws SecurityException if {@code admin} is not a device or profile owner.\n     * @throws IllegalStateException if caller is not targeting Android\n     * {@link android.os.Build.VERSION_CODES#UPSIDE_DOWN_CAKE} or above.\n     ",
    "links" : [ "android.os.Bundle", "android.os.Build.VERSION_CODES#UPSIDE_DOWN_CAKE", "#addUserRestrictionGlobally(String)", "android.os.UserManager#getUserRestrictions()" ]
  }, {
    "name" : "public Intent createAdminSupportIntent(@NonNull String restriction)",
    "returnType" : "Intent",
    "comment" : "\n     * Called by any app to display a support dialog when a feature was disabled by an admin.\n     * This returns an intent that can be used with {@link Context#startActivity(Intent)} to\n     * display the dialog. It will tell the user that the feature indicated by {@code restriction}\n     * was disabled by an admin, and include a link for more information. The default content of\n     * the dialog can be changed by the restricting admin via\n     * {@link #setShortSupportMessage(ComponentName, CharSequence)}. If the restriction is not\n     * set (i.e. the feature is available), then the return value will be {@code null}.\n     * @param restriction Indicates for which feature the dialog should be displayed. Can be a\n     *            user restriction from {@link UserManager}, e.g.\n     *            {@link UserManager#DISALLOW_ADJUST_VOLUME}, or one of the constants\n     *            {@link #POLICY_DISABLE_CAMERA} or {@link #POLICY_DISABLE_SCREEN_CAPTURE}.\n     * @return Intent An intent to be used to start the dialog-activity if the restriction is\n     *            set by an admin, or null if the restriction does not exist or no admin set it.\n     ",
    "links" : [ "android.os.UserManager", "android.os.UserManager#DISALLOW_ADJUST_VOLUME", "#setShortSupportMessage(ComponentName", "#POLICY_DISABLE_CAMERA", "#POLICY_DISABLE_SCREEN_CAPTURE", "android.content.Context#startActivity(Intent)" ]
  }, {
    "name" : "public Bundle getEnforcingAdminAndUserDetails(int userId, @Nullable String restriction)",
    "returnType" : "Bundle",
    "comment" : "\n     * @param userId      The user for whom to retrieve information.\n     * @param restriction The restriction enforced by admin. It could be any user restriction or\n     *                    policy like {@link DevicePolicyManager#POLICY_DISABLE_CAMERA} and\n     *                    {@link DevicePolicyManager#POLICY_DISABLE_SCREEN_CAPTURE}.\n     * @return Details of admin and user which enforced the restriction for the userId. If\n     * restriction is null, profile owner for the user or device owner info is returned.\n     * @hide\n     ",
    "links" : [ "android.app.admin.DevicePolicyManager#POLICY_DISABLE_CAMERA", "android.app.admin.DevicePolicyManager#POLICY_DISABLE_SCREEN_CAPTURE" ]
  }, {
    "name" : "public Set<EnforcingAdmin> getEnforcingAdminsForRestriction(int userId, @NonNull String restriction)",
    "returnType" : "Set<EnforcingAdmin>",
    "comment" : "\n     * Returns the list of {@link EnforcingAdmin}s who have set this restriction.\n     *\n     * <p>Note that for {@link #POLICY_SUSPEND_PACKAGES} it returns the PO or DO to keep the\n     * behavior the same as before the bug fix for b/192245204.\n     *\n     * <p>This API is only callable by the system UID\n     *\n     * @param userId      The user for whom to retrieve the information.\n     * @param restriction The restriction enforced by admins. It could be any user restriction or\n     *                    policy like {@link DevicePolicyManager#POLICY_DISABLE_CAMERA} and\n     *                    {@link DevicePolicyManager#POLICY_DISABLE_SCREEN_CAPTURE}.\n     *\n     * @hide\n     ",
    "links" : [ "android.app.admin.DevicePolicyManager#POLICY_DISABLE_CAMERA", "#POLICY_SUSPEND_PACKAGES", "android.app.admin.DevicePolicyManager#POLICY_DISABLE_SCREEN_CAPTURE", "android.app.admin.EnforcingAdmin" ]
  }, {
    "name" : "public boolean setApplicationHidden(@Nullable ComponentName admin, String packageName, boolean hidden)",
    "returnType" : "boolean",
    "comment" : "\n     * Hide or unhide packages. When a package is hidden it is unavailable for use, but the data and\n     * actual package file remain. This function can be called by a device owner, profile owner, or\n     * by a delegate given the {@link #DELEGATION_PACKAGE_ACCESS} scope via\n     * {@link #setDelegatedScopes}.\n     * <p>\n     * This method can be called on the {@link DevicePolicyManager} instance, returned by\n     * {@link #getParentProfileInstance(ComponentName)}, where the caller must be the profile owner\n     * of an organization-owned managed profile and the package must be a system package. If called\n     * on the parent instance, then the package is hidden or unhidden in the personal profile.\n     * <p>\n     * Starting from {@link Build.VERSION_CODES#UPSIDE_DOWN_CAKE}, after the application hidden\n     * policy has been set, {@link PolicyUpdateReceiver#onPolicySetResult(Context, String,\n     * Bundle, TargetUser, PolicyUpdateResult)} will notify the admin on whether the policy was\n     * successfully set or not. This callback will contain:\n     * <ul>\n     * <li> The policy identifier\n     * {@link DevicePolicyIdentifiers#APPLICATION_HIDDEN_POLICY}\n     * <li> The additional policy params bundle, which contains\n     * {@link PolicyUpdateReceiver#EXTRA_PACKAGE_NAME} the package name the policy applies to\n     * <li> The {@link TargetUser} that this policy relates to\n     * <li> The {@link PolicyUpdateResult}, which will be\n     * {@link PolicyUpdateResult#RESULT_POLICY_SET} if the policy was successfully set or the\n     * reason the policy failed to be set\n     * (e.g. {@link PolicyUpdateResult#RESULT_FAILURE_CONFLICTING_ADMIN_POLICY})\n     * </ul>\n     * If there has been a change to the policy,\n     * {@link PolicyUpdateReceiver#onPolicyChanged(Context, String, Bundle, TargetUser,\n     * PolicyUpdateResult)} will notify the admin of this change. This callback will contain the\n     * same parameters as PolicyUpdateReceiver#onPolicySetResult and the {@link PolicyUpdateResult}\n     * will contain the reason why the policy changed.\n     *\n     * @param admin Which {@link DeviceAdminReceiver} this request is associated with, or\n     *            {@code null} if the caller is not a device admin.\n     * @param packageName The name of the package to hide or unhide.\n     * @param hidden {@code true} if the package should be hidden, {@code false} if it should be\n     *            unhidden.\n     * @return boolean Whether the hidden setting of the package was successfully updated.\n     * @throws SecurityException if {@code admin} is not a device or profile owner or if called on\n     *            the parent profile and the {@code admin} is not a profile owner of an\n     *            organization-owned managed profile.\n     * @throws IllegalArgumentException if called on the parent profile and the package provided\n     *            is not a system package.\n     * @see #setDelegatedScopes\n     * @see #DELEGATION_PACKAGE_ACCESS\n     ",
    "links" : [ "android.app.admin.PolicyUpdateResult#RESULT_FAILURE_CONFLICTING_ADMIN_POLICY", "android.app.admin.PolicyUpdateResult#RESULT_POLICY_SET", "android.app.admin.PolicyUpdateReceiver#onPolicyChanged(Context", "#DELEGATION_PACKAGE_ACCESS", "android.app.admin.PolicyUpdateReceiver#onPolicySetResult(Context", "android.app.admin.TargetUser", "#getParentProfileInstance(ComponentName)", "android.app.admin.PolicyUpdateResult", "android.app.admin.DeviceAdminReceiver", "android.app.admin.DevicePolicyManager", "android.app.admin.PolicyUpdateReceiver#EXTRA_PACKAGE_NAME", "android.app.admin.DevicePolicyIdentifiers#APPLICATION_HIDDEN_POLICY", "Build.VERSION_CODES#UPSIDE_DOWN_CAKE", "#setDelegatedScopes" ]
  }, {
    "name" : "public boolean isApplicationHidden(@Nullable ComponentName admin, String packageName)",
    "returnType" : "boolean",
    "comment" : "\n     * Determine if a package is hidden. This function can be called by a device owner, profile\n     * owner, or by a delegate given the {@link #DELEGATION_PACKAGE_ACCESS} scope via\n     * {@link #setDelegatedScopes}.\n     * <p>\n     * This method can be called on the {@link DevicePolicyManager} instance, returned by\n     * {@link #getParentProfileInstance(ComponentName)}, where the caller must be the profile owner\n     * of an organization-owned managed profile and the package must be a system package. If called\n     * on the parent instance, this will determine whether the package is hidden or unhidden in the\n     * personal profile.\n     * <p>\n     * Starting from {@link Build.VERSION_CODES#UPSIDE_DOWN_CAKE}, the returned policy will be the\n     * current resolved policy rather than the policy set by the calling admin.\n     *\n     * @param admin Which {@link DeviceAdminReceiver} this request is associated with, or\n     *            {@code null} if the caller is not a device admin.\n     * @param packageName The name of the package to retrieve the hidden status of.\n     * @return boolean {@code true} if the package is hidden, {@code false} otherwise.\n     * @throws SecurityException if {@code admin} is not a device or profile owner or if called on\n     *            the parent profile and the {@code admin} is not a profile owner of an\n     *            organization-owned managed profile.\n     * @throws IllegalArgumentException if called on the parent profile and the package provided\n     *            is not a system package.\n     * @see #setDelegatedScopes\n     * @see #DELEGATION_PACKAGE_ACCESS\n     ",
    "links" : [ "#getParentProfileInstance(ComponentName)", "android.app.admin.DeviceAdminReceiver", "android.app.admin.DevicePolicyManager", "#DELEGATION_PACKAGE_ACCESS", "Build.VERSION_CODES#UPSIDE_DOWN_CAKE", "#setDelegatedScopes" ]
  }, {
    "name" : "public void enableSystemApp(@NonNull ComponentName admin, String packageName)",
    "returnType" : "void",
    "comment" : "\n     * Re-enable a system app that was disabled by default when the user was initialized. This\n     * function can be called by a device owner, profile owner, or by a delegate given the\n     * {@link #DELEGATION_ENABLE_SYSTEM_APP} scope via {@link #setDelegatedScopes}.\n     *\n     * @param admin Which {@link DeviceAdminReceiver} this request is associated with, or\n     *            {@code null} if the caller is an enable system app delegate.\n     * @param packageName The package to be re-enabled in the calling profile.\n     * @throws SecurityException if {@code admin} is not a device or profile owner.\n     * @see #setDelegatedScopes\n     * @see #DELEGATION_PACKAGE_ACCESS\n     ",
    "links" : [ "#DELEGATION_ENABLE_SYSTEM_APP", "android.app.admin.DeviceAdminReceiver", "#setDelegatedScopes" ]
  }, {
    "name" : "public int enableSystemApp(@NonNull ComponentName admin, Intent intent)",
    "returnType" : "int",
    "comment" : "\n     * Re-enable system apps by intent that were disabled by default when the user was initialized.\n     * This function can be called by a device owner, profile owner, or by a delegate given the\n     * {@link #DELEGATION_ENABLE_SYSTEM_APP} scope via {@link #setDelegatedScopes}.\n     *\n     * @param admin Which {@link DeviceAdminReceiver} this request is associated with, or\n     *            {@code null} if the caller is an enable system app delegate.\n     * @param intent An intent matching the app(s) to be installed. All apps that resolve for this\n     *            intent will be re-enabled in the calling profile.\n     * @return int The number of activities that matched the intent and were installed.\n     * @throws SecurityException if {@code admin} is not a device or profile owner.\n     * @see #setDelegatedScopes\n     * @see #DELEGATION_PACKAGE_ACCESS\n     ",
    "links" : [ "#DELEGATION_ENABLE_SYSTEM_APP", "android.app.admin.DeviceAdminReceiver", "#setDelegatedScopes" ]
  }, {
    "name" : "public boolean installExistingPackage(@NonNull ComponentName admin, String packageName)",
    "returnType" : "boolean",
    "comment" : "\n     * Install an existing package that has been installed in another user, or has been kept after\n     * removal via {@link #setKeepUninstalledPackages}.\n     * This function can be called by a device owner, profile owner or a delegate given\n     * the {@link #DELEGATION_INSTALL_EXISTING_PACKAGE} scope via {@link #setDelegatedScopes}.\n     * When called in a secondary user or managed profile, the user/profile must be affiliated with\n     * the device. See {@link #isAffiliatedUser}.\n     *\n     * @param admin Which {@link DeviceAdminReceiver} this request is associated with.\n     * @param packageName The package to be installed in the calling profile.\n     * @return {@code true} if the app is installed; {@code false} otherwise.\n     * @throws SecurityException if {@code admin} is not the device owner, or the profile owner of\n     * an affiliated user or profile.\n     * @see #setKeepUninstalledPackages\n     * @see #setDelegatedScopes\n     * @see #isAffiliatedUser\n     * @see #DELEGATION_PACKAGE_ACCESS\n     ",
    "links" : [ "#setKeepUninstalledPackages", "#isAffiliatedUser", "#DELEGATION_INSTALL_EXISTING_PACKAGE", "android.app.admin.DeviceAdminReceiver", "#setDelegatedScopes" ]
  }, {
    "name" : "public void setAccountManagementDisabled(@Nullable ComponentName admin, String accountType, boolean disabled)",
    "returnType" : "void",
    "comment" : "\n     * Called by a device owner or profile owner to disable account management for a specific type\n     * of account.\n     * <p>\n     * The calling device admin must be a device owner or profile owner. If it is not, a security\n     * exception will be thrown.\n     * <p>\n     * When account management is disabled for an account type, adding or removing an account of\n     * that type will not be possible.\n     * <p>\n     * From {@link android.os.Build.VERSION_CODES#N} the profile or device owner can still use\n     * {@link android.accounts.AccountManager} APIs to add or remove accounts when account\n     * management for a specific type is disabled.\n     * <p>\n     * This method may be called on the {@code DevicePolicyManager} instance returned from\n     * {@link #getParentProfileInstance(ComponentName)} by the profile owner on an\n     * organization-owned device, to restrict accounts that may not be managed on the primary\n     * profile.\n     * <p>\n     * Starting from {@link Build.VERSION_CODES#UPSIDE_DOWN_CAKE}, after the account management\n     * disabled policy has been set, {@link PolicyUpdateReceiver#onPolicySetResult(Context, String,\n     * Bundle, TargetUser, PolicyUpdateResult)} will notify the admin on whether the policy was\n     * successfully set or not. This callback will contain:\n     * <ul>\n     * <li> The policy identifier\n     * {@link DevicePolicyIdentifiers#ACCOUNT_MANAGEMENT_DISABLED_POLICY}\n     * <li> The additional policy params bundle, which contains\n     * {@link PolicyUpdateReceiver#EXTRA_ACCOUNT_TYPE} the account type the policy applies to\n     * <li> The {@link TargetUser} that this policy relates to\n     * <li> The {@link PolicyUpdateResult}, which will be\n     * {@link PolicyUpdateResult#RESULT_POLICY_SET} if the policy was successfully set or the\n     * reason the policy failed to be set\n     * (e.g. {@link PolicyUpdateResult#RESULT_FAILURE_CONFLICTING_ADMIN_POLICY})\n     * </ul>\n     * If there has been a change to the policy,\n     * {@link PolicyUpdateReceiver#onPolicyChanged(Context, String, Bundle, TargetUser,\n     * PolicyUpdateResult)} will notify the admin of this change. This callback will contain the\n     * same parameters as PolicyUpdateReceiver#onPolicySetResult and the {@link PolicyUpdateResult}\n     * will contain the reason why the policy changed.\n     *\n     * @param admin Which {@link DeviceAdminReceiver} this request is associated with. Null if the\n     *              caller is not a device admin.\n     * @param accountType For which account management is disabled or enabled.\n     * @param disabled The boolean indicating that account management will be disabled (true) or\n     *            enabled (false).\n     * @throws SecurityException if {@code admin} is not a device or profile owner.\n     ",
    "links" : [ "android.accounts.AccountManager", "android.app.admin.PolicyUpdateReceiver#EXTRA_ACCOUNT_TYPE", "android.app.admin.PolicyUpdateResult#RESULT_FAILURE_CONFLICTING_ADMIN_POLICY", "android.app.admin.PolicyUpdateResult#RESULT_POLICY_SET", "android.app.admin.PolicyUpdateReceiver#onPolicyChanged(Context", "android.app.admin.PolicyUpdateReceiver#onPolicySetResult(Context", "android.app.admin.TargetUser", "android.os.Build.VERSION_CODES#N", "#getParentProfileInstance(ComponentName)", "android.app.admin.PolicyUpdateResult", "android.app.admin.DeviceAdminReceiver", "Build.VERSION_CODES#UPSIDE_DOWN_CAKE", "android.app.admin.DevicePolicyIdentifiers#ACCOUNT_MANAGEMENT_DISABLED_POLICY" ]
  }, {
    "name" : "public String[] getAccountTypesWithManagementDisabled()",
    "returnType" : "String[]",
    "comment" : "\n     * Gets the array of accounts for which account management is disabled by the profile owner\n     * or device owner.\n     *\n     * <p> Account management can be disabled/enabled by calling\n     * {@link #setAccountManagementDisabled}.\n     * <p>\n     * This method may be called on the {@code DevicePolicyManager} instance returned from\n     * {@link #getParentProfileInstance(ComponentName)}. Note that only a profile owner on\n     * an organization-owned device can affect account types on the parent profile instance.\n     *\n     * @return a list of account types for which account management has been disabled.\n     *\n     * @see #setAccountManagementDisabled\n     ",
    "links" : [ "#getParentProfileInstance(ComponentName)", "#setAccountManagementDisabled" ]
  }, {
    "name" : "public String[] getAccountTypesWithManagementDisabledAsUser(int userId)",
    "returnType" : "String[]",
    "comment" : "\n     * @see #getAccountTypesWithManagementDisabled()\n     * Note that calling this method on the parent profile instance will return the same\n     * value as calling it on the main {@code DevicePolicyManager} instance.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public String[] getAccountTypesWithManagementDisabledAsUser(int userId, boolean parentInstance)",
    "returnType" : "String[]",
    "comment" : "\n     * @see #getAccountTypesWithManagementDisabled()\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public void setSecondaryLockscreenEnabled(@NonNull ComponentName admin, boolean enabled)",
    "returnType" : "void",
    "comment" : "\n     * Called by device owner or profile owner to set whether a secondary lockscreen needs to be\n     * shown.\n     *\n     * <p>The secondary lockscreen will by displayed after the primary keyguard security screen\n     * requirements are met. To provide the lockscreen content the DO/PO will need to provide a\n     * service handling the {@link #ACTION_BIND_SECONDARY_LOCKSCREEN_SERVICE} intent action,\n     * extending the {@link DevicePolicyKeyguardService} class.\n     *\n     * <p>Relevant interactions on the secondary lockscreen should be communicated back to the\n     * keyguard via {@link IKeyguardCallback}, such as when the screen is ready to be dismissed.\n     *\n     * <p>This API, and associated APIs, can only be called by the default supervision app when it\n     * is set as the device owner or profile owner.\n     *\n     * @param admin Which {@link DeviceAdminReceiver} this request is associated with.\n     * @param enabled Whether or not the lockscreen needs to be shown.\n     * @throws SecurityException if {@code admin} is not a device or profile owner.\n     * @see #isSecondaryLockscreenEnabled\n     * @hide\n     *",
    "links" : [ "android.app.admin.DevicePolicyKeyguardService", "IKeyguardCallback", "android.app.admin.DeviceAdminReceiver", "#ACTION_BIND_SECONDARY_LOCKSCREEN_SERVICE" ]
  }, {
    "name" : "public boolean isSecondaryLockscreenEnabled(@NonNull UserHandle userHandle)",
    "returnType" : "boolean",
    "comment" : "\n     * Returns whether the secondary lock screen needs to be shown.\n     * @see #setSecondaryLockscreenEnabled\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public void setLockTaskPackages(@Nullable ComponentName admin, @NonNull String[] packages) throws SecurityException",
    "returnType" : "void",
    "comment" : "\n     * Sets which packages may enter lock task mode.\n     * <p>\n     * Any packages that share uid with an allowed package will also be allowed to activate lock\n     * task. From {@link android.os.Build.VERSION_CODES#M} removing packages from the lock task\n     * package list results in locked tasks belonging to those packages to be finished.\n     * <p>\n     * This function can only be called by the device owner, a profile owner of an affiliated user\n     * or profile, or the profile owner when no device owner is set or holders of the permission\n     * {@link android.Manifest.permission#MANAGE_DEVICE_POLICY_LOCK_TASK}. See\n     * {@link #isAffiliatedUser}.\n     * Any package set via this method will be cleared if the user becomes unaffiliated.\n     * <p>\n     * Starting from {@link Build.VERSION_CODES#UPSIDE_DOWN_CAKE}, after the lock task policy has\n     * been set, {@link PolicyUpdateReceiver#onPolicySetResult(Context, String, Bundle, TargetUser,\n     * PolicyUpdateResult)} will notify the admin on whether the policy was successfully set or not.\n     * This callback will contain:\n     * <ul>\n     * <li> The policy identifier {@link DevicePolicyIdentifiers#LOCK_TASK_POLICY}\n     * <li> The {@link TargetUser} that this policy relates to\n     * <li> The {@link PolicyUpdateResult}, which will be\n     * {@link PolicyUpdateResult#RESULT_POLICY_SET} if the policy was successfully set or the\n     * reason the policy failed to be set\n     * (e.g. {@link PolicyUpdateResult#RESULT_FAILURE_CONFLICTING_ADMIN_POLICY})\n     * </ul>\n     * If there has been a change to the policy,\n     * {@link PolicyUpdateReceiver#onPolicyChanged(Context, String, Bundle, TargetUser,\n     * PolicyUpdateResult)} will notify the admin of this change. This callback will contain the\n     * same parameters as PolicyUpdateReceiver#onPolicySetResult and the {@link PolicyUpdateResult}\n     * will contain the reason why the policy changed.\n     * <p>\n     * Starting from {@link Build.VERSION_CODES#UPSIDE_DOWN_CAKE}, lock task features and lock task\n     * packages are bundled as one policy. A failure to apply one will result in a failure to apply\n     * the other.\n     *\n     * @param packages The list of packages allowed to enter lock task mode\n     * @param admin Which {@link DeviceAdminReceiver} this request is associated with. Null if the\n     *               caller is not a device admin.\n     * @throws SecurityException if {@code admin} is not the device owner, the profile owner of an\n     * affiliated user or profile, or the profile owner when no device owner is set or holder of the\n     * permission {@link android.Manifest.permission#MANAGE_DEVICE_POLICY_LOCK_TASK}.\n     * @see #isAffiliatedUser\n     * @see Activity#startLockTask()\n     * @see DeviceAdminReceiver#onLockTaskModeEntering(Context, Intent, String)\n     * @see DeviceAdminReceiver#onLockTaskModeExiting(Context, Intent)\n     * @see UserManager#DISALLOW_CREATE_WINDOWS\n     ",
    "links" : [ "#isAffiliatedUser", "android.app.admin.PolicyUpdateResult#RESULT_FAILURE_CONFLICTING_ADMIN_POLICY", "android.app.admin.PolicyUpdateResult", "android.app.admin.PolicyUpdateResult#RESULT_POLICY_SET", "android.app.admin.DeviceAdminReceiver", "android.Manifest.permission#MANAGE_DEVICE_POLICY_LOCK_TASK", "android.app.admin.PolicyUpdateReceiver#onPolicyChanged(Context", "Build.VERSION_CODES#UPSIDE_DOWN_CAKE", "android.app.admin.PolicyUpdateReceiver#onPolicySetResult(Context", "android.app.admin.TargetUser", "android.app.admin.DevicePolicyIdentifiers#LOCK_TASK_POLICY", "android.os.Build.VERSION_CODES#M" ]
  }, {
    "name" : "public String[] getLockTaskPackages(@Nullable ComponentName admin)",
    "returnType" : "String[]",
    "comment" : "\n     * Returns the list of packages allowed to start the lock task mode.\n     * <p>\n     * Starting from {@link Build.VERSION_CODES#UPSIDE_DOWN_CAKE}, the returned policy will be the\n     * current resolved policy rather than the policy set by the calling admin.\n     *\n     * @param admin Which {@link DeviceAdminReceiver} this request is associated with. Null if the\n     *              caller is not a device admin.\n     * @throws SecurityException if {@code admin} is not the device owner, the profile owner of an\n     * affiliated user or profile, or the profile owner when no device owner is set or holder of the\n     * permission {@link android.Manifest.permission#MANAGE_DEVICE_POLICY_LOCK_TASK}.\n     * @see #isAffiliatedUser\n     * @see #setLockTaskPackages\n     ",
    "links" : [ "android.app.admin.DeviceAdminReceiver", "android.Manifest.permission#MANAGE_DEVICE_POLICY_LOCK_TASK", "Build.VERSION_CODES#UPSIDE_DOWN_CAKE" ]
  }, {
    "name" : "public boolean isLockTaskPermitted(String pkg)",
    "returnType" : "boolean",
    "comment" : "\n     * This function lets the caller know whether the given component is allowed to start the\n     * lock task mode.\n     * @param pkg The package to check\n     ",
    "links" : [ ]
  }, {
    "name" : "public void setLockTaskFeatures(@Nullable ComponentName admin, @LockTaskFeature int flags)",
    "returnType" : "void",
    "comment" : "\n     * Sets which system features are enabled when the device runs in lock task mode. This method\n     * doesn't affect the features when lock task mode is inactive. Any system features not included\n     * in {@code flags} are implicitly disabled when calling this method. By default, only\n     * {@link #LOCK_TASK_FEATURE_GLOBAL_ACTIONS} is enabled; all the other features are disabled. To\n     * disable the global actions dialog, call this method omitting\n     * {@link #LOCK_TASK_FEATURE_GLOBAL_ACTIONS}.\n     *\n     * <p>This method can only be called by the device owner, a profile owner of an affiliated\n     * user or profile, or the profile owner when no device owner is set or holders of the\n     * permission {@link android.Manifest.permission#MANAGE_DEVICE_POLICY_LOCK_TASK}. See\n     * {@link #isAffiliatedUser}.\n     * Any features set using this method are cleared if the user becomes unaffiliated.\n     * <p>\n     * Starting from {@link Build.VERSION_CODES#UPSIDE_DOWN_CAKE}, after the lock task features\n     * policy has been set, {@link PolicyUpdateReceiver#onPolicySetResult(Context, String, Bundle,\n     * TargetUser, PolicyUpdateResult)} will notify the admin on whether the policy was\n     * successfully set or not. This callback will contain:\n     * <ul>\n     * <li> The policy identifier {@link DevicePolicyIdentifiers#LOCK_TASK_POLICY}\n     * <li> The {@link TargetUser} that this policy relates to\n     * <li> The {@link PolicyUpdateResult}, which will be\n     * {@link PolicyUpdateResult#RESULT_POLICY_SET} if the policy was successfully set or the\n     * reason the policy failed to be set\n     * (e.g. {@link PolicyUpdateResult#RESULT_FAILURE_CONFLICTING_ADMIN_POLICY})\n     * </ul>\n     * If there has been a change to the policy,\n     * {@link PolicyUpdateReceiver#onPolicyChanged(Context, String, Bundle, TargetUser,\n     * PolicyUpdateResult)} will notify the admin of this change. This callback will contain the\n     * same parameters as PolicyUpdateReceiver#onPolicySetResult and the {@link PolicyUpdateResult}\n     * will contain the reason why the policy changed.\n     * <p>\n     * Starting from {@link Build.VERSION_CODES#UPSIDE_DOWN_CAKE}, lock task features and lock task\n     * packages are bundled as one policy. A failure to apply one will result in a failure to apply\n     * the other.\n     *\n     * @param admin Which {@link DeviceAdminReceiver} this request is associated with. Null if the\n     *               caller is not a device admin.\n     * @param flags The system features enabled during lock task mode.\n     * @throws SecurityException if {@code admin} is not the device owner, the profile owner of an\n     * affiliated user or profile, or the profile owner when no device owner is set or holder of the\n     * permission {@link android.Manifest.permission#MANAGE_DEVICE_POLICY_LOCK_TASK}.\n     * @see #isAffiliatedUser\n     *",
    "links" : [ "#LOCK_TASK_FEATURE_GLOBAL_ACTIONS", "#isAffiliatedUser", "android.app.admin.PolicyUpdateResult#RESULT_FAILURE_CONFLICTING_ADMIN_POLICY", "android.app.admin.PolicyUpdateResult", "android.app.admin.PolicyUpdateResult#RESULT_POLICY_SET", "android.app.admin.DeviceAdminReceiver", "android.Manifest.permission#MANAGE_DEVICE_POLICY_LOCK_TASK", "android.app.admin.PolicyUpdateReceiver#onPolicyChanged(Context", "Build.VERSION_CODES#UPSIDE_DOWN_CAKE", "android.app.admin.PolicyUpdateReceiver#onPolicySetResult(Context", "android.app.admin.TargetUser", "android.app.admin.DevicePolicyIdentifiers#LOCK_TASK_POLICY" ]
  }, {
    "name" : "public int getLockTaskFeatures(@Nullable ComponentName admin)",
    "returnType" : "int",
    "comment" : "\n     * Gets which system features are enabled for LockTask mode.\n     * <p>\n     * Starting from {@link Build.VERSION_CODES#UPSIDE_DOWN_CAKE}, the returned policy will be the\n     * current resolved policy rather than the policy set by the calling admin.\n     *\n     * @param admin Which {@link DeviceAdminReceiver} this request is associated with. Null if the\n     *               caller is not a device admin.\n     * @return bitfield of flags. See {@link #setLockTaskFeatures(ComponentName, int)} for a list.\n     * @throws SecurityException if {@code admin} is not the device owner, the profile owner of an\n     * affiliated user or profile, or the profile owner when no device owner is set or holder of the\n     * permission {@link android.Manifest.permission#MANAGE_DEVICE_POLICY_LOCK_TASK}.\n     * @see #isAffiliatedUser\n     * @see #setLockTaskFeatures\n     ",
    "links" : [ "android.app.admin.DeviceAdminReceiver", "android.Manifest.permission#MANAGE_DEVICE_POLICY_LOCK_TASK", "Build.VERSION_CODES#UPSIDE_DOWN_CAKE", "#setLockTaskFeatures(ComponentName" ]
  }, {
    "name" : "public void setPreferentialNetworkServiceEnabled(boolean enabled)",
    "returnType" : "void",
    "comment" : "\n     * Sets whether preferential network service is enabled.\n     * For example, an organization can have a deal/agreement with a carrier that all of\n     * the work data from its employees’ devices will be sent via a network service dedicated\n     * for enterprise use.\n     *\n     * An example of a supported preferential network service is the Enterprise\n     * slice on 5G networks. For devices on 4G networks, the profile owner needs to additionally\n     * configure enterprise APN to set up data call for the preferential network service.\n     * These APNs can be added using {@link #addOverrideApn}.\n     *\n     * By default, preferential network service is disabled on the work profile and\n     * fully managed devices, on supported carriers and devices.\n     * Admins can explicitly enable it with this API.\n     *\n     * <p> This method enables preferential network service with a default configuration.\n     * To fine-tune the configuration, use {@link #setPreferentialNetworkServiceConfigs) instead.\n     * <p> Before Android version {@link android.os.Build.VERSION_CODES#TIRAMISU}:\n     * this method can be called by the profile owner of a managed profile.\n     * <p> Starting from Android version {@link android.os.Build.VERSION_CODES#TIRAMISU}:\n     * This method can be called by the profile owner of a managed profile\n     * or device owner.\n     *\n     * @param enabled whether preferential network service should be enabled.\n     * @throws SecurityException if the caller is not the profile owner or device owner.\n     *",
    "links" : [ "android.os.Build.VERSION_CODES#TIRAMISU", "#setPreferentialNetworkServiceConfigs)", "#addOverrideApn" ]
  }, {
    "name" : "public boolean isPreferentialNetworkServiceEnabled()",
    "returnType" : "boolean",
    "comment" : "\n     * Indicates whether preferential network service is enabled.\n     *\n     * <p> Before Android version {@link android.os.Build.VERSION_CODES#TIRAMISU}:\n     * This method can be called by the profile owner of a managed profile.\n     * <p> Starting from Android version {@link android.os.Build.VERSION_CODES#TIRAMISU}:\n     * This method can be called by the profile owner of a managed profile\n     * or device owner.\n     *\n     * @return whether preferential network service is enabled.\n     * @throws SecurityException if the caller is not the profile owner or device owner.\n     ",
    "links" : [ "android.os.Build.VERSION_CODES#TIRAMISU" ]
  }, {
    "name" : "public void setPreferentialNetworkServiceConfigs(@NonNull List<PreferentialNetworkServiceConfig> preferentialNetworkServiceConfigs)",
    "returnType" : "void",
    "comment" : "\n     * Sets preferential network configurations.\n     * {@see PreferentialNetworkServiceConfig}\n     *\n     * An example of a supported preferential network service is the Enterprise\n     * slice on 5G networks. For devices on 4G networks, the profile owner needs to additionally\n     * configure enterprise APN to set up data call for the preferential network service.\n     * These APNs can be added using {@link #addOverrideApn}.\n     *\n     * By default, preferential network service is disabled on the work profile and fully managed\n     * devices, on supported carriers and devices. Admins can explicitly enable it with this API.\n     * If admin wants to have multiple enterprise slices,\n     * it can be configured by passing list of {@link PreferentialNetworkServiceConfig} objects.\n     *\n     * @param preferentialNetworkServiceConfigs list of preferential network configurations.\n     * @throws SecurityException if the caller is not the profile owner or device owner.\n     *",
    "links" : [ "#addOverrideApn", "android.app.admin.PreferentialNetworkServiceConfig" ]
  }, {
    "name" : "public List<PreferentialNetworkServiceConfig> getPreferentialNetworkServiceConfigs()",
    "returnType" : "List<PreferentialNetworkServiceConfig>",
    "comment" : "\n     * Get preferential network configuration\n     * {@see PreferentialNetworkServiceConfig}\n     *\n     * @return preferential network configuration.\n     * @throws SecurityException if the caller is not the profile owner or device owner.\n     ",
    "links" : [ ]
  }, {
    "name" : "public void setGlobalSetting(@NonNull ComponentName admin, String setting, String value)",
    "returnType" : "void",
    "comment" : "\n     * This method is mostly deprecated.\n     * Most of the settings that still have an effect have dedicated setter methods or user\n     * restrictions. See individual settings for details.\n     * <p>\n     * Called by device owner to update {@link android.provider.Settings.Global} settings.\n     * Validation that the value of the setting is in the correct form for the setting type should\n     * be performed by the caller.\n     * <p>\n     * The settings that can be updated with this method are:\n     * <ul>\n     * <li>{@link android.provider.Settings.Global#ADB_ENABLED} : use\n     * {@link UserManager#DISALLOW_DEBUGGING_FEATURES} instead to restrict users from enabling\n     * debugging features and this setting to turn adb on.</li>\n     * <li>{@link android.provider.Settings.Global#USB_MASS_STORAGE_ENABLED}</li>\n     * <li>{@link android.provider.Settings.Global#STAY_ON_WHILE_PLUGGED_IN} This setting is only\n     * available from {@link android.os.Build.VERSION_CODES#M} onwards and can only be set if\n     * {@link #setMaximumTimeToLock} is not used to set a timeout.</li>\n     * <li>{@link android.provider.Settings.Global#WIFI_DEVICE_OWNER_CONFIGS_LOCKDOWN}</li> This\n     * setting is only available from {@link android.os.Build.VERSION_CODES#M} onwards.</li>\n     * </ul>\n     * <p>\n     * The following settings used to be supported, but can be controlled in other ways:\n     * <ul>\n     * <li>{@link android.provider.Settings.Global#AUTO_TIME} : Use {@link #setAutoTimeEnabled} and\n     * {@link UserManager#DISALLOW_CONFIG_DATE_TIME} instead.</li>\n     * <li>{@link android.provider.Settings.Global#AUTO_TIME_ZONE} : Use\n     * {@link #setAutoTimeZoneEnabled} and {@link UserManager#DISALLOW_CONFIG_DATE_TIME}\n     * instead.</li>\n     * <li>{@link android.provider.Settings.Global#DATA_ROAMING} : Use\n     * {@link UserManager#DISALLOW_DATA_ROAMING} instead.</li>\n     * </ul>\n     * <p>\n     * Changing the following settings has no effect as of {@link android.os.Build.VERSION_CODES#M}:\n     * <ul>\n     * <li>{@link android.provider.Settings.Global#BLUETOOTH_ON}. Use\n     * {@link android.bluetooth.BluetoothAdapter#enable()} and\n     * {@link android.bluetooth.BluetoothAdapter#disable()} instead.</li>\n     * <li>{@link android.provider.Settings.Global#DEVELOPMENT_SETTINGS_ENABLED}</li>\n     * <li>{@link android.provider.Settings.Global#MODE_RINGER}. Use\n     * {@link android.media.AudioManager#setRingerMode(int)} instead.</li>\n     * <li>{@link android.provider.Settings.Global#NETWORK_PREFERENCE}</li>\n     * <li>{@link android.provider.Settings.Global#WIFI_ON}. Use\n     * {@link android.net.wifi.WifiManager#setWifiEnabled(boolean)} instead.</li>\n     * <li>{@link android.provider.Settings.Global#WIFI_SLEEP_POLICY}. No longer has effect.</li>\n     * </ul>\n     *\n     * @param admin Which {@link DeviceAdminReceiver} this request is associated with.\n     * @param setting The name of the setting to update.\n     * @param value The value to update the setting to.\n     * @throws SecurityException if {@code admin} is not a device owner.\n     ",
    "links" : [ "android.provider.Settings.Global#AUTO_TIME_ZONE", "android.provider.Settings.Global#DATA_ROAMING", "android.provider.Settings.Global#WIFI_DEVICE_OWNER_CONFIGS_LOCKDOWN", "android.bluetooth.BluetoothAdapter#enable()", "android.os.UserManager#DISALLOW_DEBUGGING_FEATURES", "android.os.Build.VERSION_CODES#M", "#setAutoTimeZoneEnabled", "android.provider.Settings.Global#ADB_ENABLED", "android.provider.Settings.Global#WIFI_ON", "android.media.AudioManager#setRingerMode(int)", "android.app.admin.DeviceAdminReceiver", "android.bluetooth.BluetoothAdapter#disable()", "android.provider.Settings.Global#WIFI_SLEEP_POLICY", "#setMaximumTimeToLock", "android.provider.Settings.Global#BLUETOOTH_ON", "android.provider.Settings.Global#STAY_ON_WHILE_PLUGGED_IN", "android.provider.Settings.Global", "android.provider.Settings.Global#DEVELOPMENT_SETTINGS_ENABLED", "android.provider.Settings.Global#NETWORK_PREFERENCE", "android.os.UserManager#DISALLOW_CONFIG_DATE_TIME", "#setAutoTimeEnabled", "android.provider.Settings.Global#USB_MASS_STORAGE_ENABLED", "android.provider.Settings.Global#MODE_RINGER", "android.os.UserManager#DISALLOW_DATA_ROAMING", "android.provider.Settings.Global#AUTO_TIME", "android.net.wifi.WifiManager#setWifiEnabled(boolean)" ]
  }, {
    "name" : "public void setSystemSetting(@NonNull ComponentName admin, @NonNull @SystemSettingsWhitelist String setting, String value)",
    "returnType" : "void",
    "comment" : "\n     * Called by a device or profile owner to update {@link android.provider.Settings.System}\n     * settings. Validation that the value of the setting is in the correct form for the setting\n     * type should be performed by the caller.\n     * <p>\n     * The settings that can be updated by a device owner or profile owner of secondary user with\n     * this method are:\n     * <ul>\n     * <li>{@link android.provider.Settings.System#SCREEN_BRIGHTNESS}</li>\n     * <li>{@link android.provider.Settings.System#SCREEN_BRIGHTNESS_MODE}</li>\n     * <li>{@link android.provider.Settings.System#SCREEN_OFF_TIMEOUT}</li>\n     * </ul>\n     * <p>\n     * Starting from Android {@link android.os.Build.VERSION_CODES#VANILLA_ICE_CREAM}, a\n     * profile owner on an organization-owned device can call this method on the parent\n     * {@link DevicePolicyManager} instance returned by\n     * {@link #getParentProfileInstance(ComponentName)} to set system settings on the parent user.\n     *\n     * @see android.provider.Settings.System#SCREEN_OFF_TIMEOUT\n     * @param admin Which {@link DeviceAdminReceiver} this request is associated with.\n     * @param setting The name of the setting to update.\n     * @param value The value to update the setting to.\n     * @throws SecurityException if {@code admin} is not a device or profile owner.\n     ",
    "links" : [ "#getParentProfileInstance(ComponentName)", "android.os.Build.VERSION_CODES#VANILLA_ICE_CREAM", "android.app.admin.DeviceAdminReceiver", "android.app.admin.DevicePolicyManager", "android.provider.Settings.System#SCREEN_OFF_TIMEOUT", "android.provider.Settings.System#SCREEN_BRIGHTNESS", "android.provider.Settings.System", "android.provider.Settings.System#SCREEN_BRIGHTNESS_MODE" ]
  }, {
    "name" : "public void setConfiguredNetworksLockdownState(@Nullable ComponentName admin, boolean lockdown)",
    "returnType" : "void",
    "comment" : "\n     * Called by a device owner or a profile owner of an organization-owned managed profile to\n     * control whether the user can change networks configured by the admin. When this lockdown is\n     * enabled, the user can still configure and connect to other Wi-Fi networks, or use other Wi-Fi\n     * capabilities such as tethering.\n     * <p>\n     * WiFi network configuration lockdown is controlled by a global settings\n     * {@link android.provider.Settings.Global#WIFI_DEVICE_OWNER_CONFIGS_LOCKDOWN} and calling\n     * this API effectively modifies the global settings. Previously device owners can also\n     * control this directly via {@link #setGlobalSetting} but they are recommended to switch\n     * to this API.\n     *\n     * @param admin             admin Which {@link DeviceAdminReceiver} this request is associated\n     *                          with. Null if the caller is not a device admin.\n     * @param lockdown Whether the admin configured networks should be unmodifiable by the\n     *                          user.\n     * @throws SecurityException if caller is not a device owner or a profile owner of an\n     *                           organization-owned managed profile.\n     ",
    "links" : [ "android.app.admin.DeviceAdminReceiver", "android.provider.Settings.Global#WIFI_DEVICE_OWNER_CONFIGS_LOCKDOWN", "#setGlobalSetting" ]
  }, {
    "name" : "public boolean hasLockdownAdminConfiguredNetworks(@Nullable ComponentName admin)",
    "returnType" : "boolean",
    "comment" : "\n     * Called by a device owner or a profile owner of an organization-owned managed profile to\n     * determine whether the user is prevented from modifying networks configured by the admin.\n     *\n     * @param admin             admin Which {@link DeviceAdminReceiver} this request is associated\n     *                          with.\n     * @throws SecurityException if caller is not a device owner or a profile owner of an\n     *                           organization-owned managed profile.\n     ",
    "links" : [ "android.app.admin.DeviceAdminReceiver" ]
  }, {
    "name" : "public boolean setTime(@Nullable ComponentName admin, long millis)",
    "returnType" : "boolean",
    "comment" : "\n     * Called by a device owner or a profile owner of an organization-owned managed\n     * profile to set the system wall clock time. This only takes effect if called when\n     * {@link android.provider.Settings.Global#AUTO_TIME} is 0, otherwise {@code false}\n     * will be returned.\n     *\n     * @param admin Which {@link DeviceAdminReceiver} this request is associated with. Null if the\n     *               caller is not a device admin.\n     * @param millis time in milliseconds since the Epoch\n     * @return {@code true} if set time succeeded, {@code false} otherwise.\n     * @throws SecurityException if {@code admin} is not a device owner or a profile owner\n     * of an organization-owned managed profile.\n     ",
    "links" : [ "android.app.admin.DeviceAdminReceiver", "android.provider.Settings.Global#AUTO_TIME" ]
  }, {
    "name" : "public boolean setTimeZone(@Nullable ComponentName admin, String timeZone)",
    "returnType" : "boolean",
    "comment" : "\n     * Called by a device owner or a profile owner of an organization-owned managed\n     * profile to set the system's persistent default time zone. This only takes\n     * effect if called when {@link android.provider.Settings.Global#AUTO_TIME_ZONE}\n     * is 0, otherwise {@code false} will be returned.\n     *\n     * @see android.app.AlarmManager#setTimeZone(String)\n     * @param admin Which {@link DeviceAdminReceiver} this request is associated with. Null if the\n     *               caller is not a device admin.\n     * @param timeZone one of the Olson ids from the list returned by\n     *     {@link java.util.TimeZone#getAvailableIDs}\n     * @return {@code true} if set timezone succeeded, {@code false} otherwise.\n     * @throws SecurityException if {@code admin} is not a device owner or a profile owner\n     * of an organization-owned managed profile.\n     ",
    "links" : [ "android.provider.Settings.Global#AUTO_TIME_ZONE", "android.app.admin.DeviceAdminReceiver", "java.util.TimeZone#getAvailableIDs" ]
  }, {
    "name" : "public void setLocationEnabled(@NonNull ComponentName admin, boolean locationEnabled)",
    "returnType" : "void",
    "comment" : "\n     * Called by device owners to set the user's global location setting.\n     *\n     *\n     * @param admin Which {@link DeviceAdminReceiver} this request is associated with\n     * @param locationEnabled whether location should be enabled or disabled. <b>Note: </b> on\n     * {@link android.content.pm.PackageManager#FEATURE_AUTOMOTIVE automotive builds}, calls to\n     * disable will be ignored.\n     * @throws SecurityException if {@code admin} is not a device owner.\n     ",
    "links" : [ "android.content.pm.PackageManager#FEATURE_AUTOMOTIVE", "android.app.admin.DeviceAdminReceiver" ]
  }, {
    "name" : "public void setSecureSetting(@NonNull ComponentName admin, String setting, String value)",
    "returnType" : "void",
    "comment" : "\n     * This method is mostly deprecated.\n     * Most of the settings that still have an effect have dedicated setter methods\n     * (e.g. {@link #setLocationEnabled}) or user restrictions.\n     * <p>\n     *\n     * Called by profile or device owners to update {@link android.provider.Settings.Secure}\n     * settings. Validation that the value of the setting is in the correct form for the setting\n     * type should be performed by the caller.\n     * <p>\n     * The settings that can be updated by a profile or device owner with this method are:\n     * <ul>\n     * <li>{@link android.provider.Settings.Secure#DEFAULT_INPUT_METHOD}</li>\n     * <li>{@link android.provider.Settings.Secure#SKIP_FIRST_USE_HINTS}</li>\n     * </ul>\n     * <p>\n     * A device owner can additionally update the following settings:\n     * <ul>\n     * <li>{@link android.provider.Settings.Secure#LOCATION_MODE}, but see note below.</li>\n     * </ul>\n     *\n     * <strong>Note: Starting from Android O, apps should no longer call this method with the\n     * setting {@link android.provider.Settings.Secure#INSTALL_NON_MARKET_APPS}, which is\n     * deprecated. Instead, device owners or profile owners should use the restriction\n     * {@link UserManager#DISALLOW_INSTALL_UNKNOWN_SOURCES}.\n     * If any app targeting {@link android.os.Build.VERSION_CODES#O} or higher calls this method\n     * with {@link android.provider.Settings.Secure#INSTALL_NON_MARKET_APPS},\n     * an {@link UnsupportedOperationException} is thrown.\n     *\n     * Starting from Android Q, the device and profile owner can also call\n     * {@link UserManager#DISALLOW_INSTALL_UNKNOWN_SOURCES_GLOBALLY} to restrict unknown sources for\n     * all users.\n     * </strong>\n     *\n     * <strong>Note: Starting from Android R, apps should no longer call this method with the\n     * setting {@link android.provider.Settings.Secure#LOCATION_MODE}, which is deprecated. Instead,\n     * device owners should call {@link #setLocationEnabled(ComponentName, boolean)}. This will be\n     * enforced for all apps targeting Android R or above.\n     * </strong>\n     *\n     * @param admin Which {@link DeviceAdminReceiver} this request is associated with.\n     * @param setting The name of the setting to update.\n     * @param value The value to update the setting to.\n     * @throws SecurityException if {@code admin} is not a device or profile owner.\n     ",
    "links" : [ "android.os.Build.VERSION_CODES#O", "android.app.admin.DeviceAdminReceiver", "android.provider.Settings.Secure#SKIP_FIRST_USE_HINTS", "android.provider.Settings.Secure#LOCATION_MODE", "#setLocationEnabled(ComponentName", "android.provider.Settings.Secure#DEFAULT_INPUT_METHOD", "android.os.UserManager#DISALLOW_INSTALL_UNKNOWN_SOURCES", "android.provider.Settings.Secure", "android.os.UserManager#DISALLOW_INSTALL_UNKNOWN_SOURCES_GLOBALLY", "#setLocationEnabled", "android.provider.Settings.Secure#INSTALL_NON_MARKET_APPS", "UnsupportedOperationException" ]
  }, {
    "name" : "public void setRestrictionsProvider(@NonNull ComponentName admin, @Nullable ComponentName provider)",
    "returnType" : "void",
    "comment" : "\n     * Designates a specific service component as the provider for making permission requests of a\n     * local or remote administrator of the user.\n     * <p/>\n     * Only a device owner or profile owner can designate the restrictions provider.\n     *\n     * @param admin Which {@link DeviceAdminReceiver} this request is associated with.\n     * @param provider The component name of the service that implements\n     *            {@link RestrictionsReceiver}. If this param is null, it removes the restrictions\n     *            provider previously assigned.\n     * @throws SecurityException if {@code admin} is not a device or profile owner.\n     ",
    "links" : [ "android.service.restrictions.RestrictionsReceiver", "android.app.admin.DeviceAdminReceiver" ]
  }, {
    "name" : "public void setMasterVolumeMuted(@NonNull ComponentName admin, boolean on)",
    "returnType" : "void",
    "comment" : "\n     * Called by profile or device owners to set the global volume mute on or off.\n     * This has no effect when set on a managed profile.\n     *\n     * @param admin Which {@link DeviceAdminReceiver} this request is associated with.\n     * @param on {@code true} to mute global volume, {@code false} to turn mute off.\n     * @throws SecurityException if {@code admin} is not a device or profile owner.\n     ",
    "links" : [ "android.app.admin.DeviceAdminReceiver" ]
  }, {
    "name" : "public boolean isMasterVolumeMuted(@NonNull ComponentName admin)",
    "returnType" : "boolean",
    "comment" : "\n     * Called by profile or device owners to check whether the global volume mute is on or off.\n     *\n     * @param admin Which {@link DeviceAdminReceiver} this request is associated with.\n     * @return {@code true} if global volume is muted, {@code false} if it's not.\n     * @throws SecurityException if {@code admin} is not a device or profile owner.\n     ",
    "links" : [ "android.app.admin.DeviceAdminReceiver" ]
  }, {
    "name" : "public void setUninstallBlocked(@Nullable ComponentName admin, String packageName, boolean uninstallBlocked)",
    "returnType" : "void",
    "comment" : "\n     * Change whether a user can uninstall a package. This function can be called by a device owner,\n     * profile owner, or by a delegate given the {@link #DELEGATION_BLOCK_UNINSTALL} scope via\n     * {@link #setDelegatedScopes} or holders of the permission\n     * {@link android.Manifest.permission#MANAGE_DEVICE_POLICY_APPS_CONTROL}.\n     * <p>\n     * Starting from {@link Build.VERSION_CODES#UPSIDE_DOWN_CAKE}, after the set uninstall blocked\n     * policy has been set, {@link PolicyUpdateReceiver#onPolicySetResult(Context, String,\n     * Bundle, TargetUser, PolicyUpdateResult)} will notify the admin on whether the policy was\n     * successfully set or not. This callback will contain:\n     * <ul>\n     * <li> The policy identifier\n     * {@link DevicePolicyIdentifiers#PACKAGE_UNINSTALL_BLOCKED_POLICY}\n     * <li> The additional policy params bundle, which contains\n     * {@link PolicyUpdateReceiver#EXTRA_PACKAGE_NAME} the package name the policy applies to\n     * <li> The {@link TargetUser} that this policy relates to\n     * <li> The {@link PolicyUpdateResult}, which will be\n     * {@link PolicyUpdateResult#RESULT_POLICY_SET} if the policy was successfully set or the\n     * reason the policy failed to be set\n     * (e.g. {@link PolicyUpdateResult#RESULT_FAILURE_CONFLICTING_ADMIN_POLICY})\n     * </ul>\n     * If there has been a change to the policy,\n     * {@link PolicyUpdateReceiver#onPolicyChanged(Context, String, Bundle, TargetUser,\n     * PolicyUpdateResult)} will notify the admin of this change. This callback will contain the\n     * same parameters as PolicyUpdateReceiver#onPolicySetResult and the {@link PolicyUpdateResult}\n     * will contain the reason why the policy changed.\n     *\n     * @param admin Which {@link DeviceAdminReceiver} this request is associated with. Null if the\n     *               caller is not a device admin.\n     * @param packageName package to change.\n     * @param uninstallBlocked true if the user shouldn't be able to uninstall the package.\n     * @throws SecurityException if {@code admin} is not a device or profile owner or holder of the\n     * permission {@link android.Manifest.permission#MANAGE_DEVICE_POLICY_APPS_CONTROL}.\n     * @see #setDelegatedScopes\n     * @see #DELEGATION_BLOCK_UNINSTALL\n     ",
    "links" : [ "android.app.admin.PolicyUpdateResult#RESULT_FAILURE_CONFLICTING_ADMIN_POLICY", "android.app.admin.PolicyUpdateResult#RESULT_POLICY_SET", "#DELEGATION_BLOCK_UNINSTALL", "android.app.admin.PolicyUpdateReceiver#onPolicyChanged(Context", "android.app.admin.PolicyUpdateReceiver#onPolicySetResult(Context", "android.app.admin.DevicePolicyIdentifiers#PACKAGE_UNINSTALL_BLOCKED_POLICY", "android.app.admin.TargetUser", "android.app.admin.PolicyUpdateResult", "android.app.admin.DeviceAdminReceiver", "android.app.admin.PolicyUpdateReceiver#EXTRA_PACKAGE_NAME", "Build.VERSION_CODES#UPSIDE_DOWN_CAKE", "android.Manifest.permission#MANAGE_DEVICE_POLICY_APPS_CONTROL", "#setDelegatedScopes" ]
  }, {
    "name" : "public boolean isUninstallBlocked(@Nullable ComponentName admin, String packageName)",
    "returnType" : "boolean",
    "comment" : "\n     * Check whether the user has been blocked by device policy from uninstalling a package.\n     * Requires the caller to be the profile owner if checking a specific admin's policy.\n     * <p>\n     * <strong>Note:</strong> Starting from {@link android.os.Build.VERSION_CODES#LOLLIPOP_MR1}, the\n     * behavior of this API is changed such that passing {@code null} as the {@code admin} parameter\n     * will return if any admin has blocked the uninstallation. Before L MR1, passing {@code null}\n     * will cause a NullPointerException to be raised.\n     * <p>\n     * <strong>Note:</strong> If your app targets Android 11 (API level 30) or higher,\n     * this method returns a filtered result. Learn more about how to\n     * <a href=\"/training/basics/intents/package-visibility\">manage package visibility</a>.\n     * <p>\n     * Starting from {@link Build.VERSION_CODES#UPSIDE_DOWN_CAKE}, the returned policy will be the\n     * current resolved policy rather than the policy set by the calling admin.\n     *\n     * @param admin The name of the admin component whose blocking policy will be checked, or\n     *            {@code null} to check whether any admin has blocked the uninstallation. Starting\n     *              from {@link android.os.Build.VERSION_CODES#UPSIDE_DOWN_CAKE} admin will be\n     *              ignored and assumed {@code null}.\n     * @param packageName package to check.\n     * @return true if uninstallation is blocked and the given package is visible to you, false\n     *         otherwise if uninstallation isn't blocked or the given package isn't visible to you.\n     * @throws SecurityException if {@code admin} is not a device or profile owner.\n     ",
    "links" : [ "android.os.Build.VERSION_CODES#UPSIDE_DOWN_CAKE", "android.os.Build.VERSION_CODES#LOLLIPOP_MR1", "Build.VERSION_CODES#UPSIDE_DOWN_CAKE" ]
  }, {
    "name" : "public boolean addCrossProfileWidgetProvider(@Nullable ComponentName admin, String packageName)",
    "returnType" : "boolean",
    "comment" : "\n     * Called by the profile owner of a managed profile or a holder of the permission\n     * {@link android.Manifest.permission#MANAGE_DEVICE_POLICY_PROFILE_INTERACTION} to enable\n     * widget providers from a given package to be available in the parent profile. As a result the\n     * user will be able to add widgets from the allowlisted package running under the profile to a\n     * widget host which runs under the parent profile, for example the home screen. Note that a\n     * package may have zero or more provider components, where each component provides a different\n     * widget type.\n     * <p>\n     * <strong>Note:</strong> By default no widget provider package is allowlisted.\n     *\n     * @param admin Which {@link DeviceAdminReceiver} this request is associated with. Null if the\n     *              caller is not a device admin.\n     * @param packageName The package from which widget providers are allowlisted.\n     * @return Whether the package was added.\n     * @throws SecurityException if {@code admin} is not a profile owner and not a holder of the\n     * permission {@link android.Manifest.permission#MANAGE_DEVICE_POLICY_PROFILE_INTERACTION}.\n     * @see #removeCrossProfileWidgetProvider(android.content.ComponentName, String)\n     * @see #getCrossProfileWidgetProviders(android.content.ComponentName)\n     ",
    "links" : [ "android.app.admin.DeviceAdminReceiver", "android.Manifest.permission#MANAGE_DEVICE_POLICY_PROFILE_INTERACTION" ]
  }, {
    "name" : "public boolean removeCrossProfileWidgetProvider(@Nullable ComponentName admin, String packageName)",
    "returnType" : "boolean",
    "comment" : "\n     * Called by the profile owner of a managed profile or a holder of the permission\n     * {@link android.Manifest.permission#MANAGE_DEVICE_POLICY_PROFILE_INTERACTION} to disable\n     * widget providers from a given package to be available in the parent profile. For this method\n     * to take effect the package should have been added via\n     * {@link #addCrossProfileWidgetProvider( android.content.ComponentName, String)}.\n     * <p>\n     * <strong>Note:</strong> By default no widget provider package is allowlisted.\n     *\n     * @param admin Which {@link DeviceAdminReceiver} this request is associated with. Null if the\n     *              caller is not a device admin.\n     * @param packageName The package from which widget providers are no longer allowlisted.\n     * @return Whether the package was removed.\n     * @throws SecurityException if {@code admin} is not a profile owner and not a holder of the\n     * permission {@link android.Manifest.permission#MANAGE_DEVICE_POLICY_PROFILE_INTERACTION}.\n     * @see #addCrossProfileWidgetProvider(android.content.ComponentName, String)\n     * @see #getCrossProfileWidgetProviders(android.content.ComponentName)\n     ",
    "links" : [ "android.app.admin.DeviceAdminReceiver", "android.Manifest.permission#MANAGE_DEVICE_POLICY_PROFILE_INTERACTION", "#addCrossProfileWidgetProvider(" ]
  }, {
    "name" : "public List<String> getCrossProfileWidgetProviders(@Nullable ComponentName admin)",
    "returnType" : "List<String>",
    "comment" : "\n     * Called by the profile owner of a managed profile or a holder of the permission\n     * {@link android.Manifest.permission#MANAGE_DEVICE_POLICY_PROFILE_INTERACTION} to query\n     * providers from which packages are available in the parent profile.\n     *\n     * @param admin Which {@link DeviceAdminReceiver} this request is associated with. Null if the\n     *              caller is not a device admin.\n     * @return The allowlisted package list.\n     * @see #addCrossProfileWidgetProvider(android.content.ComponentName, String)\n     * @see #removeCrossProfileWidgetProvider(android.content.ComponentName, String)\n     * @throws SecurityException if {@code admin} is not a profile owner and not a holder of the\n     * permission {@link android.Manifest.permission#MANAGE_DEVICE_POLICY_PROFILE_INTERACTION}.\n     ",
    "links" : [ "android.app.admin.DeviceAdminReceiver", "android.Manifest.permission#MANAGE_DEVICE_POLICY_PROFILE_INTERACTION" ]
  }, {
    "name" : "public void setUserIcon(@NonNull ComponentName admin, Bitmap icon)",
    "returnType" : "void",
    "comment" : "\n     * Called by profile or device owners to set the user's photo.\n     *\n     * @param admin Which {@link DeviceAdminReceiver} this request is associated with.\n     * @param icon the bitmap to set as the photo.\n     * @throws SecurityException if {@code admin} is not a device or profile owner.\n     ",
    "links" : [ "android.app.admin.DeviceAdminReceiver" ]
  }, {
    "name" : "public void setSystemUpdatePolicy(@NonNull ComponentName admin, SystemUpdatePolicy policy)",
    "returnType" : "void",
    "comment" : "\n     * Called by device owners or profile owners of an organization-owned managed profile to set\n     * a local system update policy. When a new policy is set,\n     * {@link #ACTION_SYSTEM_UPDATE_POLICY_CHANGED} is broadcast.\n     * <p>\n     * If the supplied system update policy has freeze periods set but the freeze periods do not\n     * meet 90-day maximum length or 60-day minimum separation requirement set out in\n     * {@link SystemUpdatePolicy#setFreezePeriods},\n     * {@link SystemUpdatePolicy.ValidationFailedException} will the thrown. Note that the system\n     * keeps a record of freeze periods the device experienced previously, and combines them with\n     * the new freeze periods to be set when checking the maximum freeze length and minimum freeze\n     * separation constraints. As a result, freeze periods that passed validation during\n     * {@link SystemUpdatePolicy#setFreezePeriods} might fail the additional checks here due to\n     * the freeze period history. If this is causing issues during development,\n     * {@code adb shell dpm clear-freeze-period-record} can be used to clear the record.\n     *\n     * @param admin Which {@link DeviceAdminReceiver} this request is associated with. All\n     *            components in the package can set system update policies and the most\n     *            recent policy takes effect. This should be null if the caller is not a device\n     *              admin.\n     * @param policy the new policy, or {@code null} to clear the current policy.\n     * @throws SecurityException if {@code admin} is not a device owner or a profile owner of an\n     *      organization-owned managed profile, or the caller is not permitted to set this policy\n     * @throws IllegalArgumentException if the policy type or maintenance window is not valid.\n     * @throws SystemUpdatePolicy.ValidationFailedException if the policy's freeze period does not\n     *             meet the requirement.\n     * @see SystemUpdatePolicy\n     * @see SystemUpdatePolicy#setFreezePeriods(List)\n     ",
    "links" : [ "SystemUpdatePolicy.ValidationFailedException", "android.app.admin.DeviceAdminReceiver", "#ACTION_SYSTEM_UPDATE_POLICY_CHANGED", "android.app.admin.SystemUpdatePolicy#setFreezePeriods" ]
  }, {
    "name" : "public SystemUpdatePolicy getSystemUpdatePolicy()",
    "returnType" : "SystemUpdatePolicy",
    "comment" : "\n     * Retrieve a local system update policy set previously by {@link #setSystemUpdatePolicy}.\n     *\n     * @return The current policy object, or {@code null} if no policy is set.\n     ",
    "links" : [ "#setSystemUpdatePolicy" ]
  }, {
    "name" : "public void clearSystemUpdatePolicyFreezePeriodRecord()",
    "returnType" : "void",
    "comment" : "\n     * Reset record of previous system update freeze period the device went through.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean setKeyguardDisabled(@NonNull ComponentName admin, boolean disabled)",
    "returnType" : "boolean",
    "comment" : "\n     * Called by a device owner or profile owner of secondary users that is affiliated with the\n     * device to disable the keyguard altogether.\n     * <p>\n     * Setting the keyguard to disabled has the same effect as choosing \"None\" as the screen lock\n     * type. However, this call has no effect if a password, pin or pattern is currently set. If a\n     * password, pin or pattern is set after the keyguard was disabled, the keyguard stops being\n     * disabled.\n     *\n     * <p>\n     * As of {@link android.os.Build.VERSION_CODES#P}, this call also dismisses the\n     * keyguard if it is currently shown.\n     *\n     * @param admin Which {@link DeviceAdminReceiver} this request is associated with.\n     * @param disabled {@code true} disables the keyguard, {@code false} reenables it.\n     * @return {@code false} if attempting to disable the keyguard while a lock password was in\n     *         place. {@code true} otherwise.\n     * @throws SecurityException if {@code admin} is not the device owner, or a profile owner of\n     * secondary user that is affiliated with the device.\n     * @see #isAffiliatedUser\n     * @see #getSecondaryUsers\n     ",
    "links" : [ "android.os.Build.VERSION_CODES#P", "android.app.admin.DeviceAdminReceiver" ]
  }, {
    "name" : "public boolean setStatusBarDisabled(@Nullable ComponentName admin, boolean disabled)",
    "returnType" : "boolean",
    "comment" : "\n     * Called by device owner or profile owner of secondary users that is affiliated with the\n     * device to disable the status bar. Disabling the status bar blocks notifications and quick\n     * settings.\n     * <p>\n     * <strong>Note:</strong> This method has no effect for LockTask mode. The behavior of the\n     * status bar in LockTask mode can be configured with\n     * {@link #setLockTaskFeatures(ComponentName, int)}. Calls to this method when the device is in\n     * LockTask mode will be registered, but will only take effect when the device leaves LockTask\n     * mode.\n     *\n     * <p>This policy does not have any effect while on the lock screen, where the status bar will\n     * not be disabled. Using LockTask instead of this method is recommended.\n     *\n     * @param admin Which {@link DeviceAdminReceiver} this request is associated with. Null if the\n     *              caller is not a device admin.\n     * @param disabled {@code true} disables the status bar, {@code false} reenables it.\n     * @return {@code false} if attempting to disable the status bar failed. {@code true} otherwise.\n     * @throws SecurityException if {@code admin} is not the device owner, or a profile owner of\n     * secondary user that is affiliated with the device.\n     * @see #isAffiliatedUser\n     * @see #getSecondaryUsers\n     ",
    "links" : [ "android.app.admin.DeviceAdminReceiver", "#setLockTaskFeatures(ComponentName" ]
  }, {
    "name" : "public boolean isStatusBarDisabled()",
    "returnType" : "boolean",
    "comment" : "\n     * Returns whether the status bar is disabled/enabled, see {@link #setStatusBarDisabled}.\n     *\n     * <p>Callable by device owner or profile owner of secondary users that is affiliated with the\n     * device owner.\n     *\n     * <p>This policy has no effect in LockTask mode. The behavior of the\n     * status bar in LockTask mode can be configured with\n     * {@link #setLockTaskFeatures(ComponentName, int)}.\n     *\n     * <p>This policy also does not have any effect while on the lock screen, where the status bar\n     * will not be disabled.\n     *\n     * @throws SecurityException if the caller is not the device owner, or a profile owner of\n     * secondary user that is affiliated with the device.\n     * @see #isAffiliatedUser\n     * @see #getSecondaryUsers\n     ",
    "links" : [ "#setLockTaskFeatures(ComponentName", "#setStatusBarDisabled" ]
  }, {
    "name" : "public void notifyPendingSystemUpdate(long updateReceivedTime)",
    "returnType" : "void",
    "comment" : "\n     * Called by the system update service to notify device and profile owners of pending system\n     * updates.\n     *\n     * This method should only be used when it is unknown whether the pending system\n     * update is a security patch. Otherwise, use\n     * {@link #notifyPendingSystemUpdate(long, boolean)}.\n     *\n     * @param updateReceivedTime The time as given by {@link System#currentTimeMillis()}\n     *         indicating when the current pending update was first available. {@code -1} if no\n     *         update is available.\n     * @see #notifyPendingSystemUpdate(long, boolean)\n     * @hide\n     ",
    "links" : [ "#currentTimeMillis()", "#notifyPendingSystemUpdate(long" ]
  }, {
    "name" : "public void notifyPendingSystemUpdate(long updateReceivedTime, boolean isSecurityPatch)",
    "returnType" : "void",
    "comment" : "\n     * Called by the system update service to notify device and profile owners of pending system\n     * updates.\n     *\n     * This method should be used instead of {@link #notifyPendingSystemUpdate(long)}\n     * when it is known whether the pending system update is a security patch.\n     *\n     * @param updateReceivedTime The time as given by {@link System#currentTimeMillis()}\n     *         indicating when the current pending update was first available. {@code -1} if no\n     *         update is available.\n     * @param isSecurityPatch {@code true} if this system update is purely a security patch;\n     *         {@code false} if not.\n     * @see #notifyPendingSystemUpdate(long)\n     * @hide\n     ",
    "links" : [ "#currentTimeMillis()", "#notifyPendingSystemUpdate(long)" ]
  }, {
    "name" : "public SystemUpdateInfo getPendingSystemUpdate(@Nullable ComponentName admin)",
    "returnType" : "SystemUpdateInfo",
    "comment" : "\n     * Get information about a pending system update.\n     *\n     * Can be called by device or profile owners, and starting from Android\n     * {@link android.os.Build.VERSION_CODES#VANILLA_ICE_CREAM}, holders of the permission\n     * {@link android.Manifest.permission#MANAGE_DEVICE_POLICY_QUERY_SYSTEM_UPDATES}.\n     *\n     * @param admin Which profile or device owner this request is associated with.\n     * @return Information about a pending system update or {@code null} if no update pending.\n     * @throws SecurityException if {@code admin} is not a device, profile owner or holders of\n     * {@link android.Manifest.permission#MANAGE_DEVICE_POLICY_QUERY_SYSTEM_UPDATES}.\n     * @see DeviceAdminReceiver#onSystemUpdatePending(Context, Intent, long)\n     ",
    "links" : [ "android.os.Build.VERSION_CODES#VANILLA_ICE_CREAM", "android.Manifest.permission#MANAGE_DEVICE_POLICY_QUERY_SYSTEM_UPDATES" ]
  }, {
    "name" : "public void setPermissionPolicy(@NonNull ComponentName admin, int policy)",
    "returnType" : "void",
    "comment" : "\n     * Set the default response for future runtime permission requests by applications. This\n     * function can be called by a device owner, profile owner, or by a delegate given the\n     * {@link #DELEGATION_PERMISSION_GRANT} scope via {@link #setDelegatedScopes}.\n     * The policy can allow for normal operation which prompts the user to grant a permission, or\n     * can allow automatic granting or denying of runtime permission requests by an application.\n     * This also applies to new permissions declared by app updates. When a permission is denied or\n     * granted this way, the effect is equivalent to setting the permission * grant state via\n     * {@link #setPermissionGrantState}.\n     * <p/>\n     * As this policy only acts on runtime permission requests, it only applies to applications\n     * built with a {@code targetSdkVersion} of {@link android.os.Build.VERSION_CODES#M} or later.\n     *\n     * <p>\n     * NOTE: On devices running {@link android.os.Build.VERSION_CODES#S} and above, an auto-grant\n     * policy will not apply to certain sensors-related permissions on some configurations.\n     * See {@link #setPermissionGrantState(ComponentName, String, String, int)} for the list of\n     * permissions affected, and the behavior change for managed profiles and fully-managed\n     * devices.\n     *\n     * @param admin Which profile or device owner this request is associated with.\n     * @param policy One of the policy constants {@link #PERMISSION_POLICY_PROMPT},\n     *            {@link #PERMISSION_POLICY_AUTO_GRANT} and {@link #PERMISSION_POLICY_AUTO_DENY}.\n     * @throws SecurityException if {@code admin} is not a device or profile owner.\n     * @see #setPermissionGrantState\n     * @see #setDelegatedScopes\n     * @see #DELEGATION_PERMISSION_GRANT\n     ",
    "links" : [ "#PERMISSION_POLICY_AUTO_GRANT", "#setPermissionGrantState", "android.os.Build.VERSION_CODES#S", "#PERMISSION_POLICY_PROMPT", "#setPermissionGrantState(ComponentName", "#PERMISSION_POLICY_AUTO_DENY", "#DELEGATION_PERMISSION_GRANT", "#setDelegatedScopes", "android.os.Build.VERSION_CODES#M" ]
  }, {
    "name" : "public int getPermissionPolicy(ComponentName admin)",
    "returnType" : "int",
    "comment" : "\n     * Returns the current runtime permission policy set by the device or profile owner. The\n     * default is {@link #PERMISSION_POLICY_PROMPT}.\n     *\n     * @param admin Which profile or device owner this request is associated with.\n     * @return the current policy for future permission requests.\n     ",
    "links" : [ "#PERMISSION_POLICY_PROMPT" ]
  }, {
    "name" : "public boolean setPermissionGrantState(@Nullable ComponentName admin, @NonNull String packageName, @NonNull String permission, @PermissionGrantState int grantState)",
    "returnType" : "boolean",
    "comment" : "\n     * Sets the grant state of a runtime permission for a specific application. The state can be\n     * {@link #PERMISSION_GRANT_STATE_DEFAULT default} in which a user can manage it through the UI,\n     * {@link #PERMISSION_GRANT_STATE_DENIED denied}, in which the permission is denied and the user\n     * cannot manage it through the UI, and {@link #PERMISSION_GRANT_STATE_GRANTED granted} in which\n     * the permission is granted and the user cannot manage it through the UI. This method can only\n     * be called by a profile owner, device owner, or a delegate given the\n     * {@link #DELEGATION_PERMISSION_GRANT} scope via {@link #setDelegatedScopes}.\n     * <p/>\n     * Note that user cannot manage other permissions in the affected group through the UI\n     * either and their granted state will be kept as the current value. Thus, it's recommended that\n     * you set the grant state of all the permissions in the affected group.\n     * <p/>\n     * Setting the grant state to {@link #PERMISSION_GRANT_STATE_DEFAULT default} does not revoke\n     * the permission. It retains the previous grant, if any.\n     * <p/>\n     * Device admins with a {@code targetSdkVersion} &lt; {@link android.os.Build.VERSION_CODES#Q}\n     * cannot grant and revoke permissions for applications built with a {@code targetSdkVersion}\n     * &lt; {@link android.os.Build.VERSION_CODES#M}.\n     * <p/>\n     * Admins with a {@code targetSdkVersion} &ge; {@link android.os.Build.VERSION_CODES#Q} can\n     * grant and revoke permissions of all apps. Similar to the user revoking a permission from a\n     * application built with a {@code targetSdkVersion} &lt;\n     * {@link android.os.Build.VERSION_CODES#M} the app-op matching the permission is set to\n     * {@link android.app.AppOpsManager#MODE_IGNORED}, but the permission stays granted.\n     * <p>\n     * NOTE: On devices running {@link android.os.Build.VERSION_CODES#S} and above, control over\n     * the following, sensors-related, permissions is restricted:\n     * <ul>\n     *    <li>Manifest.permission.ACCESS_FINE_LOCATION</li>\n     *    <li>Manifest.permission.ACCESS_BACKGROUND_LOCATION</li>\n     *    <li>Manifest.permission.ACCESS_COARSE_LOCATION</li>\n     *    <li>Manifest.permission.CAMERA</li>\n     *    <li>Manifest.permission.RECORD_AUDIO</li>\n     *    <li>Manifest.permission.RECORD_BACKGROUND_AUDIO</li>\n     *    <li>Manifest.permission.ACTIVITY_RECOGNITION</li>\n     *    <li>Manifest.permission.BODY_SENSORS</li>\n     * </ul>\n     * <p>\n     * A profile owner may not grant these permissions (i.e. call this method with any of the\n     * permissions listed above and {@code grantState} of {@code #PERMISSION_GRANT_STATE_GRANTED}),\n     * but may deny them.\n     * <p>\n     * A device owner, by default, may continue granting these permissions. However, for increased\n     * user control, the admin may opt out of controlling grants for these permissions by including\n     * {@link #EXTRA_PROVISIONING_SENSORS_PERMISSION_GRANT_OPT_OUT} in the provisioning parameters.\n     * In that case the device owner's control will be limited to denying these permissions.\n     * <p>\n     * NOTE: On devices running {@link android.os.Build.VERSION_CODES#S} and above, control over\n     * the following permissions are restricted for managed profile owners:\n     * <ul>\n     *    <li>Manifest.permission.READ_SMS</li>\n     * </ul>\n     * <p>\n     * A managed profile owner may not grant these permissions (i.e. call this method with any of\n     * the permissions listed above and {@code grantState} of\n     * {@code #PERMISSION_GRANT_STATE_GRANTED}), but may deny them.\n     * <p>\n     * Attempts by the admin to grant these permissions, when the admin is restricted from doing\n     * so, will be silently ignored (no exception will be thrown).\n     *\n     * Control over the following permissions are restricted for managed profile owners:\n     * <ul>\n     *  <li>Manifest.permission.READ_SMS</li>\n     * </ul>\n     * <p>\n     * A managed profile owner may not grant these permissions (i.e. call this method with any of\n     * the permissions listed above and {@code grantState} of\n     * {@code #PERMISSION_GRANT_STATE_GRANTED}), but may deny them.\n     *\n     * @param admin Which {@link DeviceAdminReceiver} this request is associated with. Null if the\n     *               caller is not a device admin.\n     * @param packageName The application to grant or revoke a permission to.\n     * @param permission The permission to grant or revoke.\n     * @param grantState The permission grant state which is one of\n     *            {@link #PERMISSION_GRANT_STATE_DENIED}, {@link #PERMISSION_GRANT_STATE_DEFAULT},\n     *            {@link #PERMISSION_GRANT_STATE_GRANTED},\n     * @return whether the permission was successfully granted or revoked.\n     * @throws SecurityException if {@code admin} is not a device or profile owner.\n     * @see #PERMISSION_GRANT_STATE_DENIED\n     * @see #PERMISSION_GRANT_STATE_DEFAULT\n     * @see #PERMISSION_GRANT_STATE_GRANTED\n     * @see #setDelegatedScopes\n     * @see #DELEGATION_PERMISSION_GRANT\n     ",
    "links" : [ "#PERMISSION_GRANT_STATE_DENIED", "android.os.Build.VERSION_CODES#Q", "android.app.admin.DeviceAdminReceiver", "android.os.Build.VERSION_CODES#S", "#PERMISSION_GRANT_STATE_GRANTED", "#EXTRA_PROVISIONING_SENSORS_PERMISSION_GRANT_OPT_OUT", "#PERMISSION_GRANT_STATE_DEFAULT", "#DELEGATION_PERMISSION_GRANT", "#setDelegatedScopes", "android.os.Build.VERSION_CODES#M", "android.app.AppOpsManager#MODE_IGNORED" ]
  }, {
    "name" : "public int getPermissionGrantState(@Nullable ComponentName admin, @NonNull String packageName, @NonNull String permission)",
    "returnType" : "int",
    "comment" : "\n     * Returns the current grant state of a runtime permission for a specific application. This\n     * function can be called by a device owner, profile owner, or by a delegate given the\n     * {@link #DELEGATION_PERMISSION_GRANT} scope via {@link #setDelegatedScopes}.\n     *\n     * @param admin Which {@link DeviceAdminReceiver} this request is associated with. Null if the\n     *               caller is not a device admin.\n     * @param packageName The application to check the grant state for.\n     * @param permission The permission to check for.\n     * @return the current grant state specified by device policy. If admins have not set a grant\n     *         has not set a grant state, the return value is\n     *         {@link #PERMISSION_GRANT_STATE_DEFAULT}. This does not indicate whether or not the\n     *         permission is currently granted for the package.\n     *         <p/>\n     *         If a grant state was set by the profile or device owner, then the return value will\n     *         be one of {@link #PERMISSION_GRANT_STATE_DENIED} or\n     *         {@link #PERMISSION_GRANT_STATE_GRANTED}, which indicates if the permission is\n     *         currently denied or granted.\n     * @throws SecurityException if {@code admin} is not a device or profile owner.\n     * @see #setPermissionGrantState(ComponentName, String, String, int)\n     * @see PackageManager#checkPermission(String, String)\n     * @see #setDelegatedScopes\n     * @see #DELEGATION_PERMISSION_GRANT\n     ",
    "links" : [ "#PERMISSION_GRANT_STATE_DENIED", "android.app.admin.DeviceAdminReceiver", "#PERMISSION_GRANT_STATE_GRANTED", "#PERMISSION_GRANT_STATE_DEFAULT", "#DELEGATION_PERMISSION_GRANT", "#setDelegatedScopes" ]
  }, {
    "name" : "public boolean isProvisioningAllowed(@NonNull String action)",
    "returnType" : "boolean",
    "comment" : "\n     * Returns whether it is possible for the caller to initiate provisioning of a managed profile\n     * or device, setting itself as the device or profile owner.\n     *\n     * @param action One of {@link #ACTION_PROVISION_MANAGED_DEVICE},\n     * {@link #ACTION_PROVISION_MANAGED_PROFILE}.\n     * @return whether provisioning a managed profile or device is possible.\n     * @throws IllegalArgumentException if the supplied action is not valid.\n     ",
    "links" : [ "#ACTION_PROVISION_MANAGED_DEVICE", "#ACTION_PROVISION_MANAGED_PROFILE" ]
  }, {
    "name" : "public int checkProvisioningPrecondition(@NonNull String action, @NonNull String packageName)",
    "returnType" : "int",
    "comment" : "\n     * Checks whether it is possible to initiate provisioning a managed device,\n     * profile or user, setting the given package as owner.\n     *\n     * @param action One of {@link #ACTION_PROVISION_MANAGED_DEVICE},\n     *        {@link #ACTION_PROVISION_MANAGED_PROFILE}\n     * @param packageName The package of the component that would be set as device, user, or profile\n     *        owner.\n     * @return An int constant value indicating whether provisioning is allowed.\n     * @hide\n     ",
    "links" : [ "#ACTION_PROVISION_MANAGED_DEVICE", "#ACTION_PROVISION_MANAGED_PROFILE" ]
  }, {
    "name" : "public boolean isManagedProfile(@NonNull ComponentName admin)",
    "returnType" : "boolean",
    "comment" : "\n     * Return if this user is a managed profile of another user. An admin can become the profile\n     * owner of a managed profile with {@link #ACTION_PROVISION_MANAGED_PROFILE} and of a managed\n     * user with {@link #createAndManageUser}\n     * @param admin Which profile owner this request is associated with.\n     * @return if this user is a managed profile of another user.\n     ",
    "links" : [ "#createAndManageUser", "#ACTION_PROVISION_MANAGED_PROFILE" ]
  }, {
    "name" : "public String getWifiMacAddress(@Nullable ComponentName admin)",
    "returnType" : "String",
    "comment" : "    @RequiresPermission(value = MANAGE_DEVICE_POLICY_WIFI, conditional = true)",
    "links" : [ ]
  }, {
    "name" : "public void reboot(@NonNull ComponentName admin)",
    "returnType" : "void",
    "comment" : "\n     * Called by device owner to reboot the device. If there is an ongoing call on the device,\n     * throws an {@link IllegalStateException}.\n     * @param admin Which device owner the request is associated with.\n     * @throws IllegalStateException if device has an ongoing call.\n     * @throws SecurityException if {@code admin} is not a device owner.\n     * @see TelephonyManager#CALL_STATE_IDLE\n     ",
    "links" : [ "IllegalStateException" ]
  }, {
    "name" : "public void setShortSupportMessage(@Nullable ComponentName admin, @Nullable CharSequence message)",
    "returnType" : "void",
    "comment" : "\n     * Called by a device admin to set the short support message. This will be displayed to the user\n     * in settings screens where functionality has been disabled by the admin. The message should be\n     * limited to a short statement such as \"This setting is disabled by your administrator. Contact\n     * someone@example.com for support.\" If the message is longer than 200 characters it may be\n     * truncated.\n     * <p>\n     * If the short support message needs to be localized, it is the responsibility of the\n     * {@link DeviceAdminReceiver} to listen to the {@link Intent#ACTION_LOCALE_CHANGED} broadcast\n     * and set a new version of this string accordingly.\n     *\n     * @see #setLongSupportMessage\n     * @param admin Which {@link DeviceAdminReceiver} this request is associated with. Null if the\n     *               caller is not a device admin.\n     * @param message Short message to be displayed to the user in settings or null to clear the\n     *            existing message.\n     * @throws SecurityException if {@code admin} is not an active administrator.\n     ",
    "links" : [ "android.content.Intent#ACTION_LOCALE_CHANGED", "android.app.admin.DeviceAdminReceiver" ]
  }, {
    "name" : "public CharSequence getShortSupportMessage(@Nullable ComponentName admin)",
    "returnType" : "CharSequence",
    "comment" : "\n     * Called by a device admin or holder of the permission\n     * {@link android.Manifest.permission#MANAGE_DEVICE_POLICY_SUPPORT_MESSAGE} to get the short\n     * support message.\n     *\n     * @param admin Which {@link DeviceAdminReceiver} this request is associated with. Null if the\n     *               caller is not a device admin.\n     * @return The message set by {@link #setShortSupportMessage(ComponentName, CharSequence)} or\n     *         null if no message has been set.\n     * @throws SecurityException if {@code admin} is not an active administrator and not a holder of\n     * the permission {@link android.Manifest.permission#MANAGE_DEVICE_POLICY_SUPPORT_MESSAGE}..\n     ",
    "links" : [ "android.app.admin.DeviceAdminReceiver", "#setShortSupportMessage(ComponentName", "android.Manifest.permission#MANAGE_DEVICE_POLICY_SUPPORT_MESSAGE" ]
  }, {
    "name" : "public void setLongSupportMessage(@NonNull ComponentName admin, @Nullable CharSequence message)",
    "returnType" : "void",
    "comment" : "\n     * Called by a device admin to set the long support message. This will be displayed to the user\n     * in the device administrators settings screen. If the message is longer than 20000 characters\n     * it may be truncated.\n     * <p>\n     * If the long support message needs to be localized, it is the responsibility of the\n     * {@link DeviceAdminReceiver} to listen to the {@link Intent#ACTION_LOCALE_CHANGED} broadcast\n     * and set a new version of this string accordingly.\n     *\n     * @see #setShortSupportMessage\n     * @param admin Which {@link DeviceAdminReceiver} this request is associated with.\n     * @param message Long message to be displayed to the user in settings or null to clear the\n     *            existing message.\n     * @throws SecurityException if {@code admin} is not an active administrator.\n     ",
    "links" : [ "android.content.Intent#ACTION_LOCALE_CHANGED", "android.app.admin.DeviceAdminReceiver" ]
  }, {
    "name" : "public CharSequence getLongSupportMessage(@NonNull ComponentName admin)",
    "returnType" : "CharSequence",
    "comment" : "\n     * Called by a device admin to get the long support message.\n     *\n     * @param admin Which {@link DeviceAdminReceiver} this request is associated with.\n     * @return The message set by {@link #setLongSupportMessage(ComponentName, CharSequence)} or\n     *         null if no message has been set.\n     * @throws SecurityException if {@code admin} is not an active administrator.\n     ",
    "links" : [ "android.app.admin.DeviceAdminReceiver", "#setLongSupportMessage(ComponentName" ]
  }, {
    "name" : "public CharSequence getShortSupportMessageForUser(@NonNull ComponentName admin, int userHandle)",
    "returnType" : "CharSequence",
    "comment" : "\n     * Called by the system to get the short support message.\n     *\n     * @param admin Which {@link DeviceAdminReceiver} this request is associated with.\n     * @param userHandle user id the admin is running as.\n     * @return The message set by {@link #setShortSupportMessage(ComponentName, CharSequence)}\n     *\n     * @hide\n     ",
    "links" : [ "android.app.admin.DeviceAdminReceiver", "#setShortSupportMessage(ComponentName" ]
  }, {
    "name" : "public CharSequence getLongSupportMessageForUser(@NonNull ComponentName admin, int userHandle)",
    "returnType" : "CharSequence",
    "comment" : "\n     * Called by the system to get the long support message.\n     *\n     * @param admin Which {@link DeviceAdminReceiver} this request is associated with.\n     * @param userHandle user id the admin is running as.\n     * @return The message set by {@link #setLongSupportMessage(ComponentName, CharSequence)}\n     *\n     * @hide\n     ",
    "links" : [ "android.app.admin.DeviceAdminReceiver", "#setLongSupportMessage(ComponentName" ]
  }, {
    "name" : "public DevicePolicyManager getParentProfileInstance(@NonNull ComponentName admin)",
    "returnType" : "DevicePolicyManager",
    "comment" : "\n     * Called by the profile owner of a managed profile to obtain a {@link DevicePolicyManager}\n     * whose calls act on the parent profile.\n     *\n     * <p>The following methods are supported for the parent instance, all other methods will\n     * throw a SecurityException when called on the parent instance:\n     * <ul>\n     * <li>{@link #getPasswordQuality}</li>\n     * <li>{@link #setPasswordQuality}</li>\n     * <li>{@link #getPasswordMinimumLength}</li>\n     * <li>{@link #setPasswordMinimumLength}</li>\n     * <li>{@link #getPasswordMinimumUpperCase}</li>\n     * <li>{@link #setPasswordMinimumUpperCase}</li>\n     * <li>{@link #getPasswordMinimumLowerCase}</li>\n     * <li>{@link #setPasswordMinimumLowerCase}</li>\n     * <li>{@link #getPasswordMinimumLetters}</li>\n     * <li>{@link #setPasswordMinimumLetters}</li>\n     * <li>{@link #getPasswordMinimumNumeric}</li>\n     * <li>{@link #setPasswordMinimumNumeric}</li>\n     * <li>{@link #getPasswordMinimumSymbols}</li>\n     * <li>{@link #setPasswordMinimumSymbols}</li>\n     * <li>{@link #getPasswordMinimumNonLetter}</li>\n     * <li>{@link #setPasswordMinimumNonLetter}</li>\n     * <li>{@link #getPasswordHistoryLength}</li>\n     * <li>{@link #setPasswordHistoryLength}</li>\n     * <li>{@link #getPasswordExpirationTimeout}</li>\n     * <li>{@link #setPasswordExpirationTimeout}</li>\n     * <li>{@link #getPasswordExpiration}</li>\n     * <li>{@link #getPasswordMaximumLength}</li>\n     * <li>{@link #isActivePasswordSufficient}</li>\n     * <li>{@link #getCurrentFailedPasswordAttempts}</li>\n     * <li>{@link #getMaximumFailedPasswordsForWipe}</li>\n     * <li>{@link #setMaximumFailedPasswordsForWipe}</li>\n     * <li>{@link #getMaximumTimeToLock}</li>\n     * <li>{@link #setMaximumTimeToLock}</li>\n     * <li>{@link #lockNow}</li>\n     * <li>{@link #getKeyguardDisabledFeatures}</li>\n     * <li>{@link #setKeyguardDisabledFeatures}</li>\n     * <li>{@link #getTrustAgentConfiguration}</li>\n     * <li>{@link #setTrustAgentConfiguration}</li>\n     * <li>{@link #getRequiredStrongAuthTimeout}</li>\n     * <li>{@link #setRequiredStrongAuthTimeout}</li>\n     * <li>{@link #getAccountTypesWithManagementDisabled}</li>\n     * <li>{@link #setRequiredPasswordComplexity(int)} </li>\n     * <li>{@link #getRequiredPasswordComplexity()}</li>\n     * </ul>\n     * <p>\n     * The following methods are supported for the parent instance but can only be called by the\n     * profile owner of a managed profile that was created during the device provisioning flow:\n     * <ul>\n     * <li>{@link #getPasswordComplexity}</li>\n     * <li>{@link #setCameraDisabled}</li>\n     * <li>{@link #getCameraDisabled}</li>\n     * <li>{@link #setAccountManagementDisabled(ComponentName, String, boolean)}</li>\n     * <li>{@link #setPermittedInputMethods}</li>\n     * <li>{@link #getPermittedInputMethods}</li>\n     * </ul>\n     *\n     * <p>The following methods can be called by the profile owner of a managed profile\n     * on an organization-owned device:\n     * <ul>\n     * <li>{@link #wipeData}</li>\n     * </ul>\n     *\n     * @return a new instance of {@link DevicePolicyManager} that acts on the parent profile.\n     * @throws SecurityException if {@code admin} is not a profile owner.\n     ",
    "links" : [ "#getPasswordExpirationTimeout", "#getCameraDisabled", "#setPasswordMinimumNumeric", "#setPasswordHistoryLength", "#isActivePasswordSufficient", "#setPasswordMinimumSymbols", "#setAccountManagementDisabled(ComponentName", "#setPasswordMinimumNonLetter", "#setRequiredPasswordComplexity(int)", "#getPasswordMinimumLowerCase", "#getPasswordMaximumLength", "#lockNow", "#setPasswordQuality", "#getPasswordMinimumNumeric", "#getPasswordMinimumNonLetter", "android.app.admin.DevicePolicyManager", "#setPasswordMinimumUpperCase", "#setMaximumFailedPasswordsForWipe", "#getPermittedInputMethods", "#getTrustAgentConfiguration", "#getAccountTypesWithManagementDisabled", "#setMaximumTimeToLock", "#setKeyguardDisabledFeatures", "#setPermittedInputMethods", "#getPasswordMinimumLetters", "#setPasswordExpirationTimeout", "#getMaximumFailedPasswordsForWipe", "#setCameraDisabled", "#getPasswordQuality", "#getPasswordMinimumUpperCase", "#getCurrentFailedPasswordAttempts", "#setTrustAgentConfiguration", "#getPasswordExpiration", "#setPasswordMinimumLowerCase", "#setPasswordMinimumLetters", "#getPasswordMinimumSymbols", "#getPasswordMinimumLength", "#wipeData", "#getRequiredPasswordComplexity()", "#getPasswordHistoryLength", "#getMaximumTimeToLock", "#getPasswordComplexity", "#setPasswordMinimumLength", "#getKeyguardDisabledFeatures", "#getRequiredStrongAuthTimeout", "#setRequiredStrongAuthTimeout" ]
  }, {
    "name" : "public void setSecurityLoggingEnabled(@Nullable ComponentName admin, boolean enabled)",
    "returnType" : "void",
    "comment" : "\n     * Called by device owner or a profile owner of an organization-owned managed profile to\n     * control the security logging feature.\n     *\n     * <p> Security logs contain various information intended for security auditing purposes.\n     * When security logging is enabled by any app other than the device owner, certain security\n     * logs are not visible (for example personal app launch events) or they will be redacted\n     * (for example, details of the physical volume mount events).\n     * Please see {@link SecurityEvent} for details.\n     *\n     * <p><strong>Note:</strong> The device owner won't be able to retrieve security logs if there\n     * are unaffiliated secondary users or profiles on the device, regardless of whether the\n     * feature is enabled. Logs will be discarded if the internal buffer fills up while waiting for\n     * all users to become affiliated. Therefore it's recommended that affiliation ids are set for\n     * new users as soon as possible after provisioning via {@link #setAffiliationIds}. Non device\n     * owners are not subject to this restriction since all\n     * privacy-sensitive events happening outside the managed profile would have been redacted\n     * already.\n     *\n     * Starting from {@link Build.VERSION_CODES#VANILLA_ICE_CREAM}, after the security logging\n     * policy has been set, {@link PolicyUpdateReceiver#onPolicySetResult(Context, String,\n     * Bundle, TargetUser, PolicyUpdateResult)} will notify the admin on whether the policy was\n     * successfully set or not. This callback will contain:\n     * <ul>\n     * <li> The policy identifier {@link DevicePolicyIdentifiers#SECURITY_LOGGING_POLICY}\n     * <li> The {@link TargetUser} that this policy relates to\n     * <li> The {@link PolicyUpdateResult}, which will be\n     * {@link PolicyUpdateResult#RESULT_POLICY_SET} if the policy was successfully set or the\n     * reason the policy failed to be set\n     * e.g. {@link PolicyUpdateResult#RESULT_FAILURE_CONFLICTING_ADMIN_POLICY})\n     * </ul>\n     * If there has been a change to the policy,\n     * {@link PolicyUpdateReceiver#onPolicyChanged(Context, String, Bundle, TargetUser,\n     * PolicyUpdateResult)} will notify the admin of this change. This callback will contain the\n     * same parameters as PolicyUpdateReceiver#onPolicySetResult and the {@link PolicyUpdateResult}\n     * will contain the reason why the policy changed.\n     *\n     * @param admin Which device admin this request is associated with, or {@code null}\n     *              if called by a delegated app.\n     * @param enabled whether security logging should be enabled or not.\n     * @throws SecurityException if the caller is not permitted to control security logging.\n     * @see #setAffiliationIds\n     * @see #retrieveSecurityLogs\n     ",
    "links" : [ "Build.VERSION_CODES#VANILLA_ICE_CREAM", "android.app.admin.SecurityLog.SecurityEvent", "android.app.admin.DevicePolicyIdentifiers#SECURITY_LOGGING_POLICY", "android.app.admin.PolicyUpdateResult#RESULT_FAILURE_CONFLICTING_ADMIN_POLICY", "android.app.admin.PolicyUpdateResult", "android.app.admin.PolicyUpdateResult#RESULT_POLICY_SET", "#setAffiliationIds", "android.app.admin.PolicyUpdateReceiver#onPolicyChanged(Context", "android.app.admin.PolicyUpdateReceiver#onPolicySetResult(Context", "android.app.admin.TargetUser" ]
  }, {
    "name" : "public boolean isSecurityLoggingEnabled(@Nullable ComponentName admin)",
    "returnType" : "boolean",
    "comment" : "\n     * Return whether security logging is enabled or not by the admin.\n     *\n     * <p>Can only be called by the device owner or a profile owner of an organization-owned\n     * managed profile, otherwise a {@link SecurityException} will be thrown.\n     *\n     * @param admin Which device admin this request is associated with. Null if the caller is not\n     *              a device admin\n     * @return {@code true} if security logging is enabled, {@code false} otherwise.\n     * @throws SecurityException if the caller is not allowed to control security logging.\n     ",
    "links" : [ "SecurityException" ]
  }, {
    "name" : "public void setAuditLogEnabled(boolean enabled)",
    "returnType" : "void",
    "comment" : "\n     * Controls whether audit logging is enabled.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean isAuditLogEnabled()",
    "returnType" : "boolean",
    "comment" : "\n     * @return Whether audit logging is enabled.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public void setAuditLogEventCallback(@NonNull @CallbackExecutor Executor executor, @NonNull Consumer<List<SecurityEvent>> callback)",
    "returnType" : "void",
    "comment" : "\n     * Sets audit log event callback. Only one callback per UID is active at any time, when a new\n     * callback is set, the previous one is forgotten. Should only be called when audit log policy\n     * is enforced by the caller. Disabling the policy clears the callback. Each time a new callback\n     * is set, it will first be invoked with all the audit log events available at the time.\n     *\n     * @param callback The callback to invoke when new audit log events become available.\n     * @param executor The executor through which the callback should be invoked.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public void clearAuditLogEventCallback()",
    "returnType" : "void",
    "comment" : "\n     * Clears audit log event callback. If a callback was set previously, it may still get invoked\n     * after this call returns if it was already scheduled.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public List<SecurityEvent> retrieveSecurityLogs(@Nullable ComponentName admin)",
    "returnType" : "List<SecurityEvent>",
    "comment" : "\n     * Called by device owner or profile owner of an organization-owned managed profile to retrieve\n     * all new security logging entries since the last call to this API after device boots.\n     *\n     * <p> Access to the logs is rate limited and it will only return new logs after the admin has\n     * been notified via {@link DeviceAdminReceiver#onSecurityLogsAvailable}.\n     *\n     * <p> When called by a device owner, if there is any other user or profile on the device,\n     * it must be affiliated with the device. Otherwise a {@link SecurityException} will be thrown.\n     * See {@link #isAffiliatedUser}.\n     *\n     * @param admin Which device admin this request is associated with, or {@code null}\n     *              if called by a delegated app.\n     * @return the new batch of security logs which is a list of {@link SecurityEvent},\n     * or {@code null} if rate limitation is exceeded or if logging is currently disabled.\n     * @throws SecurityException if the caller is not allowed to access security logging,\n     * or there is at least one profile or secondary user that is not affiliated with the device.\n     * @see #isAffiliatedUser\n     * @see DeviceAdminReceiver#onSecurityLogsAvailable\n     ",
    "links" : [ "android.app.admin.DeviceAdminReceiver#onSecurityLogsAvailable", "android.app.admin.SecurityLog.SecurityEvent", "#isAffiliatedUser", "SecurityException" ]
  }, {
    "name" : "public long forceNetworkLogs()",
    "returnType" : "long",
    "comment" : "\n     * Makes all accumulated network logs available to DPC in a new batch.\n     * If throttled, returns time to wait in milliseconds, otherwise 0.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public long forceSecurityLogs()",
    "returnType" : "long",
    "comment" : "\n     * Forces a batch of security logs to be fetched from logd and makes it available for DPC.\n     * If throttled, returns time to wait in milliseconds, otherwise 0.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public DevicePolicyManager getParentProfileInstance(UserInfo uInfo)",
    "returnType" : "DevicePolicyManager",
    "comment" : "\n     * Called by the system to obtain a {@link DevicePolicyManager} whose calls act on the parent\n     * profile.\n     *\n     * @hide\n     ",
    "links" : [ "android.app.admin.DevicePolicyManager" ]
  }, {
    "name" : "public List<String> setMeteredDataDisabledPackages(@NonNull ComponentName admin, @NonNull List<String> packageNames)",
    "returnType" : "List<String>",
    "comment" : "\n     * Called by a device or profile owner to restrict packages from using metered data.\n     *\n     * @param admin which {@link DeviceAdminReceiver} this request is associated with.\n     * @param packageNames the list of package names to be restricted.\n     * @return a list of package names which could not be restricted.\n     * @throws SecurityException if {@code admin} is not a device or profile owner.\n     ",
    "links" : [ "android.app.admin.DeviceAdminReceiver" ]
  }, {
    "name" : "public List<String> getMeteredDataDisabledPackages(@NonNull ComponentName admin)",
    "returnType" : "List<String>",
    "comment" : "\n     * Called by a device or profile owner to retrieve the list of packages which are restricted\n     * by the admin from using metered data.\n     *\n     * @param admin which {@link DeviceAdminReceiver} this request is associated with.\n     * @return the list of restricted package names.\n     * @throws SecurityException if {@code admin} is not a device or profile owner.\n     ",
    "links" : [ "android.app.admin.DeviceAdminReceiver" ]
  }, {
    "name" : "public boolean isMeteredDataDisabledPackageForUser(@NonNull ComponentName admin, String packageName, @UserIdInt int userId)",
    "returnType" : "boolean",
    "comment" : "\n     * Called by the system to check if a package is restricted from using metered data\n     * by {@param admin}.\n     *\n     * @param admin which {@link DeviceAdminReceiver} this request is associated with.\n     * @param packageName the package whose restricted status is needed.\n     * @param userId the user to which {@param packageName} belongs.\n     * @return {@code true} if the package is restricted by admin, otherwise {@code false}\n     * @throws SecurityException if the caller doesn't run with {@link Process#SYSTEM_UID}\n     * @hide\n     ",
    "links" : [ "android.app.admin.DeviceAdminReceiver", "android.os.Process#SYSTEM_UID" ]
  }, {
    "name" : "public List<SecurityEvent> retrievePreRebootSecurityLogs(@Nullable ComponentName admin)",
    "returnType" : "List<SecurityEvent>",
    "comment" : "\n     * Called by device owner or profile owner of an organization-owned managed profile to retrieve\n     * device logs from before the device's last reboot.\n     * <p>\n     * <strong> This API is not supported on all devices. Calling this API on unsupported devices\n     * will result in {@code null} being returned. The device logs are retrieved from a RAM region\n     * which is not guaranteed to be corruption-free during power cycles, as a result be cautious\n     * about data corruption when parsing. </strong>\n     *\n     * <p> When called by a device owner, if there is any other user or profile on the device,\n     * it must be affiliated with the device. Otherwise a {@link SecurityException} will be thrown.\n     * See {@link #isAffiliatedUser}.\n     *\n     * @param admin Which device admin this request is associated with, or {@code null}\n     *             if called by a delegated app.\n     * @return Device logs from before the latest reboot of the system, or {@code null} if this API\n     *         is not supported on the device.\n     * @throws SecurityException if the caller is not allowed to access security logging, or\n     * there is at least one profile or secondary user that is not affiliated with the device.\n     * @see #isAffiliatedUser\n     * @see #retrieveSecurityLogs\n     ",
    "links" : [ "#isAffiliatedUser", "SecurityException" ]
  }, {
    "name" : "public void setOrganizationColor(@NonNull ComponentName admin, int color)",
    "returnType" : "void",
    "comment" : "\n     * Called by a profile owner of a managed profile to set the color used for customization. This\n     * color is used as background color of the confirm credentials screen for that user. The\n     * default color is teal (#00796B).\n     * <p>\n     * The confirm credentials screen can be created using\n     * {@link android.app.KeyguardManager#createConfirmDeviceCredentialIntent}.\n     * <p>\n     * Starting from Android R, the organization color will no longer be used as the background\n     * color of the confirm credentials screen.\n     *\n     * @param admin Which {@link DeviceAdminReceiver} this request is associated with.\n     * @param color The 24bit (0xRRGGBB) representation of the color to be used.\n     * @throws SecurityException if {@code admin} is not a profile owner.\n     * @deprecated From {@link android.os.Build.VERSION_CODES#R}, the organization color is never\n     * used as the background color of the confirm credentials screen.\n     ",
    "links" : [ "android.os.Build.VERSION_CODES#R", "android.app.admin.DeviceAdminReceiver", "android.app.KeyguardManager#createConfirmDeviceCredentialIntent" ]
  }, {
    "name" : "public void setOrganizationColorForUser(@ColorInt int color, @UserIdInt int userId)",
    "returnType" : "void",
    "comment" : "\n     * @hide\n     *\n     * Sets the color used for customization.\n     *\n     * @param color The 24bit (0xRRGGBB) representation of the color to be used.\n     * @param userId which user to set the color to.\n     * @RequiresPermission(allOf = {\n     *       Manifest.permission.MANAGE_USERS,\n     *       Manifest.permission.INTERACT_ACROSS_USERS_FULL})\n     * @deprecated From {@link android.os.Build.VERSION_CODES#R}, the organization color is never\n     * used as the background color of the confirm credentials screen.\n     ",
    "links" : [ "android.os.Build.VERSION_CODES#R" ]
  }, {
    "name" : "public int getOrganizationColor(@NonNull ComponentName admin)",
    "returnType" : "int",
    "comment" : "\n     * Called by a profile owner of a managed profile to retrieve the color used for customization.\n     * This color is used as background color of the confirm credentials screen for that user.\n     *\n     * @param admin Which {@link DeviceAdminReceiver} this request is associated with.\n     * @return The 24bit (0xRRGGBB) representation of the color to be used.\n     * @throws SecurityException if {@code admin} is not a profile owner.\n     * @deprecated From {@link android.os.Build.VERSION_CODES#R}, the organization color is never\n     * used as the background color of the confirm credentials screen.\n     ",
    "links" : [ "android.os.Build.VERSION_CODES#R", "android.app.admin.DeviceAdminReceiver" ]
  }, {
    "name" : "public int getOrganizationColorForUser(int userHandle)",
    "returnType" : "int",
    "comment" : "\n     * @hide\n     * Retrieve the customization color for a given user.\n     *\n     * @param userHandle The user id of the user we're interested in.\n     * @return The 24bit (0xRRGGBB) representation of the color to be used.\n     * @deprecated From {@link android.os.Build.VERSION_CODES#R}, the organization color is never\n     * used as the background color of the confirm credentials screen.\n     ",
    "links" : [ "android.os.Build.VERSION_CODES#R" ]
  }, {
    "name" : "public void setOrganizationName(@Nullable ComponentName admin, @Nullable CharSequence title)",
    "returnType" : "void",
    "comment" : "\n     * Called by the device owner (since API 26) or profile owner (since API 24) to set the name of\n     * the organization under management.\n     *\n     * <p>If the organization name needs to be localized, it is the responsibility of the caller\n     * to listen to the {@link Intent#ACTION_LOCALE_CHANGED} broadcast and set a new version of this\n     * string accordingly.\n     *\n     * @param admin Which {@link DeviceAdminReceiver} this request is associated with. Null if the\n     *               caller is not a device admin.\n     * @param title The organization name or {@code null} to clear a previously set name.\n     * @throws SecurityException if {@code admin} is not a device or profile owner.\n     ",
    "links" : [ "android.content.Intent#ACTION_LOCALE_CHANGED", "android.app.admin.DeviceAdminReceiver" ]
  }, {
    "name" : "public CharSequence getOrganizationName(@Nullable ComponentName admin)",
    "returnType" : "CharSequence",
    "comment" : "\n     * Called by the device owner (since API 26) or profile owner (since API 24) or holders of the\n     * permission {@link android.Manifest.permission#MANAGE_DEVICE_POLICY_ORGANIZATION_IDENTITY\n     * to retrieve the name of the organization under management.\n     *\n     * @param admin Which {@link DeviceAdminReceiver} this request is associated with. Null if the\n     *               caller is not a device admin.\n     * @return The organization name or {@code null} if none is set.\n     * @throws SecurityException if {@code admin} if {@code admin} is not a device or profile\n     * owner or holder of the\n     * permission {@link android.Manifest.permission#MANAGE_DEVICE_POLICY_ORGANIZATION_IDENTITY}.\n     ",
    "links" : [ "android.Manifest.permission#MANAGE_DEVICE_POLICY_ORGANIZATION_IDENTITY", "android.Manifest.permission#MANAGE_DEVICE_POLICY_ORGANIZATION_IDENTITYto", "android.app.admin.DeviceAdminReceiver" ]
  }, {
    "name" : "public CharSequence getDeviceOwnerOrganizationName()",
    "returnType" : "CharSequence",
    "comment" : "\n     * Called by the system to retrieve the name of the organization managing the device.\n     *\n     * @return The organization name or {@code null} if none is set.\n     * @throws SecurityException if the caller is not the device owner, does not hold the\n     *         MANAGE_USERS permission and is not the system.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public CharSequence getOrganizationNameForUser(int userHandle)",
    "returnType" : "CharSequence",
    "comment" : "\n     * Retrieve the default title message used in the confirm credentials screen for a given user.\n     *\n     * @param userHandle The user id of the user we're interested in.\n     * @return The organization name or {@code null} if none is set.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public int getUserProvisioningState()",
    "returnType" : "int",
    "comment" : "\n     * @return the {@link UserProvisioningState} for the current user - for unmanaged users will\n     *         return {@link #STATE_USER_UNMANAGED}\n     * @hide\n     ",
    "links" : [ "UserProvisioningState", "#STATE_USER_UNMANAGED" ]
  }, {
    "name" : "public void setUserProvisioningState(@UserProvisioningState int state, int userHandle)",
    "returnType" : "void",
    "comment" : "\n     * Set the {@link UserProvisioningState} for the supplied user, if they are managed.\n     *\n     * @param state to store\n     * @param userHandle for user\n     *\n     * @hide\n     ",
    "links" : [ "UserProvisioningState" ]
  }, {
    "name" : "public void setUserProvisioningState(@UserProvisioningState int state, @NonNull UserHandle userHandle)",
    "returnType" : "void",
    "comment" : "\n     * Set the {@link UserProvisioningState} for the supplied user. The supplied user has to be\n     * manged, otherwise it will throw an {@link IllegalStateException}.\n     *\n     * <p> For managed users/profiles/devices, only the following state changes are allowed:\n     * <ul>\n     *     <li>{@link #STATE_USER_UNMANAGED} can change to any other state except itself\n     *     <li>{@link #STATE_USER_SETUP_INCOMPLETE} and {@link #STATE_USER_SETUP_COMPLETE} can only\n     *     change to {@link #STATE_USER_SETUP_FINALIZED}</li>\n     *     <li>{@link #STATE_USER_PROFILE_COMPLETE} can only change to\n     *     {@link #STATE_USER_PROFILE_FINALIZED}</li>\n     *     <li>{@link #STATE_USER_SETUP_FINALIZED} can't be changed to any other state</li>\n     *     <li>{@link #STATE_USER_PROFILE_FINALIZED} can only change to\n     *     {@link #STATE_USER_UNMANAGED}</li>\n     * </ul>\n     * @param state to store\n     * @param userHandle for user\n     * @throws IllegalStateException if called with an invalid state change.\n     *\n     * @hide\n     ",
    "links" : [ "#STATE_USER_SETUP_FINALIZED", "IllegalStateException", "#STATE_USER_SETUP_INCOMPLETE", "UserProvisioningState", "#STATE_USER_UNMANAGED", "#STATE_USER_SETUP_COMPLETE", "#STATE_USER_PROFILE_COMPLETE", "#STATE_USER_PROFILE_FINALIZED" ]
  }, {
    "name" : "public void setAffiliationIds(@NonNull ComponentName admin, @NonNull Set<String> ids)",
    "returnType" : "void",
    "comment" : "\n     * Indicates the entity that controls the device. Two users are\n     * affiliated if the set of ids set by the device owner and the admin of the secondary user.\n     *\n     * <p>A user that is affiliated with the device owner user is considered to be\n     * affiliated with the device.\n     *\n     * <p><strong>Note:</strong> Features that depend on user affiliation (such as security logging\n     * or {@link #bindDeviceAdminServiceAsUser}) won't be available when a secondary user\n     * is created, until it becomes affiliated. Therefore it is recommended that the appropriate\n     * affiliation ids are set by its owner as soon as possible after the user is\n     * created.\n     * <p>\n     * Note: This method used to be available for affiliating device owner and profile\n     * owner. However, since Android 11, this combination is not possible. This method is now\n     * only useful for affiliating the primary user with managed secondary users.\n     *\n     * @param admin Which device owner, or owner of secondary user, this request is associated with.\n     * @param ids A set of opaque non-empty affiliation ids.\n     *\n     * @throws IllegalArgumentException if {@code ids} is null or contains an empty string.\n     * @see #isAffiliatedUser\n     ",
    "links" : [ "#bindDeviceAdminServiceAsUser" ]
  }, {
    "name" : "public Set<String> getAffiliationIds(@NonNull ComponentName admin)",
    "returnType" : "Set<String>",
    "comment" : "\n     * Returns the set of affiliation ids previously set via {@link #setAffiliationIds}, or an\n     * empty set if none have been set.\n     ",
    "links" : [ "#setAffiliationIds" ]
  }, {
    "name" : "public boolean isAffiliatedUser()",
    "returnType" : "boolean",
    "comment" : "\n     * Returns whether this user is affiliated with the device.\n     * <p>\n     * By definition, the user that the device owner runs on is always affiliated with the device.\n     * Any other user is considered affiliated with the device if the set specified by its\n     * profile owner via {@link #setAffiliationIds} intersects with the device owner's.\n     * @see #setAffiliationIds\n     ",
    "links" : [ "#setAffiliationIds" ]
  }, {
    "name" : "public boolean isAffiliatedUser(@UserIdInt int userId)",
    "returnType" : "boolean",
    "comment" : "\n     * @hide\n     * Returns whether target user is affiliated with the device.\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean isUninstallInQueue(String packageName)",
    "returnType" : "boolean",
    "comment" : "\n     * @hide\n     * Returns whether the uninstall for {@code packageName} for the current user is in queue\n     * to be started\n     * @param packageName the package to check for\n     * @return whether the uninstall intent for {@code packageName} is pending\n     ",
    "links" : [ ]
  }, {
    "name" : "public void uninstallPackageWithActiveAdmins(String packageName)",
    "returnType" : "void",
    "comment" : "\n     * @hide\n     * @param packageName the package containing active DAs to be uninstalled\n     ",
    "links" : [ ]
  }, {
    "name" : "public void forceRemoveActiveAdmin(@NonNull ComponentName adminReceiver, @UserIdInt int userHandle)",
    "returnType" : "void",
    "comment" : "\n     * @hide\n     * Remove a test admin synchronously without sending it a broadcast about being removed.\n     * If the admin is a profile owner or device owner it will still be removed.\n     *\n     * @param userHandle user id to remove the admin for.\n     * @param admin The administration compononent to remove.\n     * @throws SecurityException if the caller is not shell / root or the admin package\n     *         isn't a test application see {@link ApplicationInfo#FLAG_TEST_APP}.\n     ",
    "links" : [ "android.content.pm.ApplicationInfo#FLAG_TEST_APP" ]
  }, {
    "name" : "public boolean isDeviceProvisioned()",
    "returnType" : "boolean",
    "comment" : "\n     * Returns whether the device has been provisioned.\n     *\n     * <p>Not for use by third-party applications.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public void setDeviceProvisioningConfigApplied()",
    "returnType" : "void",
    "comment" : "\n      * Writes that the provisioning configuration has been applied.\n      *\n      * <p>The caller must hold the {@link android.Manifest.permission#MANAGE_USERS}\n      * permission.\n      *\n      * <p>Not for use by third-party applications.\n      *\n      * @hide\n      ",
    "links" : [ "android.Manifest.permission#MANAGE_USERS" ]
  }, {
    "name" : "public boolean isDeviceProvisioningConfigApplied()",
    "returnType" : "boolean",
    "comment" : "\n     * Returns whether the provisioning configuration has been applied.\n     *\n     * <p>The caller must hold the {@link android.Manifest.permission#MANAGE_USERS} permission.\n     *\n     * <p>Not for use by third-party applications.\n     *\n     * @return whether the provisioning configuration has been applied.\n     *\n     * @hide\n     ",
    "links" : [ "android.Manifest.permission#MANAGE_USERS" ]
  }, {
    "name" : "public void forceUpdateUserSetupComplete(@UserIdInt int userId)",
    "returnType" : "void",
    "comment" : "\n     * @hide\n     * Force update user setup completed status for the given {@code userId}.\n     * @throws {@link SecurityException} if the caller has no\n     *         {@code android.Manifest.permission.MANAGE_PROFILE_AND_DEVICE_OWNERS}.\n     ",
    "links" : [ "SecurityException" ]
  }, {
    "name" : "private void throwIfParentInstance(String functionName)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public void setBackupServiceEnabled(@NonNull ComponentName admin, boolean enabled)",
    "returnType" : "void",
    "comment" : "\n     * Allows the device owner or profile owner to enable or disable the backup service.\n     *\n     * <p> Each user has its own backup service which manages the backup and restore mechanisms in\n     * that user. Disabling the backup service will prevent data from being backed up or restored.\n     *\n     * <p> Device owner calls this API to control backup services across all users on the device.\n     * Profile owner can use this API to enable or disable the profile's backup service. However,\n     * for a managed profile its backup functionality is only enabled if both the device owner\n     * and the profile owner have enabled the backup service.\n     *\n     * <p> By default, backup service is disabled on a device with device owner, and within a\n     * managed profile.\n     *\n     * @param admin Which {@link DeviceAdminReceiver} this request is associated with.\n     * @param enabled {@code true} to enable the backup service, {@code false} to disable it.\n     * @throws SecurityException if {@code admin} is not a device owner or a profile owner.\n     ",
    "links" : [ "android.app.admin.DeviceAdminReceiver" ]
  }, {
    "name" : "public boolean isBackupServiceEnabled(@NonNull ComponentName admin)",
    "returnType" : "boolean",
    "comment" : "\n     * Return whether the backup service is enabled by the device owner or profile owner for the\n     * current user, as previously set by {@link #setBackupServiceEnabled(ComponentName, boolean)}.\n     *\n     * <p> Whether the backup functionality is actually enabled or not depends on settings from both\n     * the current user and the device owner, please see\n     * {@link #setBackupServiceEnabled(ComponentName, boolean)} for details.\n     *\n     * <p> Backup service manages all backup and restore mechanisms on the device.\n     *\n     * @return {@code true} if backup service is enabled, {@code false} otherwise.\n     * @see #setBackupServiceEnabled\n     ",
    "links" : [ "#setBackupServiceEnabled(ComponentName" ]
  }, {
    "name" : "public void setNetworkLoggingEnabled(@Nullable ComponentName admin, boolean enabled)",
    "returnType" : "void",
    "comment" : "\n     * Called by a device owner, profile owner of a managed profile or delegated app with\n     * {@link #DELEGATION_NETWORK_LOGGING} to control the network logging feature.\n     *\n     * <p> Supported for a device owner from Android 8 and a delegated app granted by a device\n     * owner from Android 10. Supported for a profile owner of a managed profile and a delegated\n     * app granted by a profile owner from Android 12. When network logging is enabled by a\n     * profile owner, the network logs will only include work profile network activity, not\n     * activity on the personal profile.\n     *\n     * <p> Network logs contain DNS lookup and connect() library call events. The following library\n     *     functions are recorded while network logging is active:\n     *     <ul>\n     *       <li>{@code getaddrinfo()}</li>\n     *       <li>{@code gethostbyname()}</li>\n     *       <li>{@code connect()}</li>\n     *     </ul>\n     *\n     * <p> Network logging is a low-overhead tool for forensics but it is not guaranteed to use\n     *     full system call logging; event reporting is enabled by default for all processes but not\n     *     strongly enforced.\n     *     Events from applications using alternative implementations of libc, making direct kernel\n     *     calls, or deliberately obfuscating traffic may not be recorded.\n     *\n     * <p> Some common network events may not be reported. For example:\n     *     <ul>\n     *       <li>Applications may hardcode IP addresses to reduce the number of DNS lookups, or use\n     *           an alternative system for name resolution, and so avoid calling\n     *           {@code getaddrinfo()} or {@code gethostbyname}.</li>\n     *       <li>Applications may use datagram sockets for performance reasons, for example\n     *           for a game client. Calling {@code connect()} is unnecessary for this kind of\n     *           socket, so it will not trigger a network event.</li>\n     *     </ul>\n     *\n     * <p> It is possible to directly intercept layer 3 traffic leaving the device using an\n     *     always-on VPN service.\n     *     See {@link #setAlwaysOnVpnPackage(ComponentName, String, boolean)}\n     *     and {@link android.net.VpnService} for details.\n     *\n     * <p><strong>Note:</strong> The device owner won't be able to retrieve network logs if there\n     * are unaffiliated secondary users or profiles on the device, regardless of whether the\n     * feature is enabled. Logs will be discarded if the internal buffer fills up while waiting for\n     * all users to become affiliated. Therefore it's recommended that affiliation ids are set for\n     * new users as soon as possible after provisioning via {@link #setAffiliationIds}.\n     *\n     * @param admin Which {@link DeviceAdminReceiver} this request is associated with, or\n     *        {@code null} if called by a delegated app.\n     * @param enabled whether network logging should be enabled or not.\n     * @throws SecurityException if {@code admin} is not a device owner or profile owner.\n     * @see #setAffiliationIds\n     * @see #retrieveNetworkLogs\n     ",
    "links" : [ "android.net.VpnService", "android.app.admin.DeviceAdminReceiver", "#setAffiliationIds", "#setAlwaysOnVpnPackage(ComponentName", "#DELEGATION_NETWORK_LOGGING" ]
  }, {
    "name" : "public boolean isNetworkLoggingEnabled(@Nullable ComponentName admin)",
    "returnType" : "boolean",
    "comment" : "\n     * Return whether network logging is enabled by a device owner or profile owner of\n     * a managed profile.\n     *\n     * @param admin Which {@link DeviceAdminReceiver} this request is associated with. Can only\n     * be {@code null} if the caller is a delegated app with {@link #DELEGATION_NETWORK_LOGGING}\n     * or has MANAGE_USERS permission.\n     * @return {@code true} if network logging is enabled by device owner or profile owner,\n     * {@code false} otherwise.\n     * @throws SecurityException if {@code admin} is not a device owner or profile owner and\n     * caller has no MANAGE_USERS permission\n     ",
    "links" : [ "android.app.admin.DeviceAdminReceiver", "#DELEGATION_NETWORK_LOGGING" ]
  }, {
    "name" : "public List<NetworkEvent> retrieveNetworkLogs(@Nullable ComponentName admin, long batchToken)",
    "returnType" : "List<NetworkEvent>",
    "comment" : "\n     * Called by device owner, profile owner of a managed profile or delegated app with\n     * {@link #DELEGATION_NETWORK_LOGGING} to retrieve the most recent batch of\n     * network logging events.\n     *\n     * <p> When network logging is enabled by a profile owner, the network logs will only include\n     * work profile network activity, not activity on the personal profile.\n     *\n     * A device owner or profile owner has to provide a batchToken provided as part of\n     * {@link DeviceAdminReceiver#onNetworkLogsAvailable} callback. If the token doesn't match the\n     * token of the most recent available batch of logs, {@code null} will be returned.\n     *\n     * <p> {@link NetworkEvent} can be one of {@link DnsEvent} or {@link ConnectEvent}.\n     *\n     * <p> The list of network events is sorted chronologically, and contains at most 1200 events.\n     *\n     * <p> Access to the logs is rate limited and this method will only return a new batch of logs\n     * after the device device owner has been notified via\n     * {@link DeviceAdminReceiver#onNetworkLogsAvailable}.\n     *\n     * <p>If the caller is not a profile owner and a secondary user or profile is created, calling\n     * this method will throw a {@link SecurityException} until all users become affiliated again.\n     * It will also no longer be possible to retrieve the network logs batch with the most recent\n     * batchToken provided by {@link DeviceAdminReceiver#onNetworkLogsAvailable}.\n     * See {@link DevicePolicyManager#setAffiliationIds}.\n     *\n     * @param admin Which {@link DeviceAdminReceiver} this request is associated with, or\n     *        {@code null} if called by a delegated app.\n     * @param batchToken A token of the batch to retrieve\n     * @return A new batch of network logs which is a list of {@link NetworkEvent}. Returns\n     *        {@code null} if the batch represented by batchToken is no longer available or if\n     *        logging is disabled.\n     * @throws SecurityException if {@code admin} is not a device owner, profile owner or if the\n     * {@code admin} is not a profile owner and there is at least one profile or secondary user\n     * that is not affiliated with the device.\n     * @see #setAffiliationIds\n     * @see DeviceAdminReceiver#onNetworkLogsAvailable\n     ",
    "links" : [ "android.app.admin.DeviceAdminReceiver#onNetworkLogsAvailable", "android.app.admin.ConnectEvent", "android.app.admin.DeviceAdminReceiver", "android.app.admin.DevicePolicyManager#setAffiliationIds", "SecurityException", "android.app.admin.NetworkEvent", "android.app.admin.DnsEvent", "#DELEGATION_NETWORK_LOGGING" ]
  }, {
    "name" : "public boolean bindDeviceAdminServiceAsUser(@NonNull ComponentName admin, @NonNull Intent serviceIntent, @NonNull ServiceConnection conn, @Context.BindServiceFlagsBits int flags, @NonNull UserHandle targetUser)",
    "returnType" : "boolean",
    "comment" : "\n     * Called by a device owner to bind to a service from a secondary managed user or vice versa.\n     * See {@link #getBindDeviceAdminTargetUsers} for the pre-requirements of a\n     * device owner to bind to services of another managed user.\n     * <p>\n     * The service must be protected by {@link android.Manifest.permission#BIND_DEVICE_ADMIN}.\n     * Note that the {@link Context} used to obtain this\n     * {@link DevicePolicyManager} instance via {@link Context#getSystemService(Class)} will be used\n     * to bind to the {@link android.app.Service}.\n     * <p>\n     * Note: This method used to be available for communication between device owner and profile\n     * owner. However, since Android 11, this combination is not possible. This method is now\n     * only useful for communication between device owner and managed secondary users.\n     *\n     * @param admin Which {@link DeviceAdminReceiver} this request is associated with.\n     * @param serviceIntent Identifies the service to connect to.  The Intent must specify either an\n     *        explicit component name or a package name to match an\n     *        {@link IntentFilter} published by a service.\n     * @param conn Receives information as the service is started and stopped in main thread. This\n     *        must be a valid {@link ServiceConnection} object; it must not be {@code null}.\n     * @param flags Operation options for the binding operation. See\n     *        {@link Context#bindService(Intent, ServiceConnection, int)}.\n     * @param targetUser Which user to bind to. Must be one of the users returned by\n     *        {@link #getBindDeviceAdminTargetUsers}, otherwise a {@link SecurityException} will\n     *        be thrown.\n     * @return If you have successfully bound to the service, {@code true} is returned;\n     *         {@code false} is returned if the connection is not made and you will not\n     *         receive the service object.\n     *\n     * @see Context#bindService(Intent, ServiceConnection, int)\n     * @see #getBindDeviceAdminTargetUsers(ComponentName)\n     ",
    "links" : [ "android.content.Context", "android.app.admin.DeviceAdminReceiver", "#getBindDeviceAdminTargetUsers", "android.Manifest.permission#BIND_DEVICE_ADMIN", "android.app.admin.DevicePolicyManager", "android.app.Service", "android.content.IntentFilter", "android.app.IServiceConnection", "android.content.Context#bindService(Intent", "SecurityException", "android.content.Context#getSystemService(Class)" ]
  }, {
    "name" : "public boolean bindDeviceAdminServiceAsUser(@NonNull ComponentName admin, @NonNull Intent serviceIntent, @NonNull ServiceConnection conn, @NonNull Context.BindServiceFlags flags, @NonNull UserHandle targetUser)",
    "returnType" : "boolean",
    "comment" : "\n     * See {@link #bindDeviceAdminServiceAsUser(ComponentName, Intent, ServiceConnection, int,\n     *       UserHandle)}.\n     * Call {@link Context.BindServiceFlags#of(long)} to obtain a BindServiceFlags object.\n     ",
    "links" : [ "Context.BindServiceFlags#of(long)", "#bindDeviceAdminServiceAsUser(ComponentName" ]
  }, {
    "name" : "public List<UserHandle> getBindDeviceAdminTargetUsers(@NonNull ComponentName admin)",
    "returnType" : "List<UserHandle>",
    "comment" : "\n     * Returns the list of target users that the calling device owner or owner of secondary user\n     * can use when calling {@link #bindDeviceAdminServiceAsUser}.\n     * <p>\n     * A device owner can bind to a service from a secondary managed user and vice versa, provided\n     * that both users are affiliated. See {@link #setAffiliationIds}.\n     ",
    "links" : [ "#bindDeviceAdminServiceAsUser", "#setAffiliationIds" ]
  }, {
    "name" : "public long getLastSecurityLogRetrievalTime()",
    "returnType" : "long",
    "comment" : "\n     * Called by the system to get the time at which the device owner last retrieved security\n     * logging entries.\n     *\n     * @return the time at which the device owner most recently retrieved security logging entries,\n     *         in milliseconds since epoch; -1 if security logging entries were never retrieved.\n     * @throws SecurityException if the caller is not the device owner, does not hold the\n     *         MANAGE_USERS permission and is not the system.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public long getLastBugReportRequestTime()",
    "returnType" : "long",
    "comment" : "\n     * Called by the system to get the time at which the device owner last requested a bug report.\n     *\n     * @return the time at which the device owner most recently requested a bug report, in\n     *         milliseconds since epoch; -1 if a bug report was never requested.\n     * @throws SecurityException if the caller is not the device owner, does not hold the\n     *         MANAGE_USERS permission and is not the system.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public long getLastNetworkLogRetrievalTime()",
    "returnType" : "long",
    "comment" : "\n     * Called by the system to get the time at which the device owner or profile owner of a\n     * managed profile last retrieved network logging events.\n     *\n     * @return the time at which the device owner or profile owner most recently retrieved network\n     *         logging events, in milliseconds since epoch; -1 if network logging events were\n     *         never retrieved.\n     * @throws SecurityException if the caller is not the device owner, does not hold the\n     *         MANAGE_USERS permission and is not the system.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean isCurrentInputMethodSetByOwner()",
    "returnType" : "boolean",
    "comment" : "\n     * Returns true if the current user's IME was set by an admin.\n     *\n     * <p>Requires the caller to be the system server, a device owner or profile owner, or a holder\n     * of the QUERY_ADMIN_POLICY permission.\n     *\n     * @throws SecurityException if the caller is not authorized\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public List<String> getOwnerInstalledCaCerts(@NonNull UserHandle user)",
    "returnType" : "List<String>",
    "comment" : "\n     * Called by the system to get a list of CA certificates that were installed by the device or\n     * profile owner.\n     *\n     * <p> The caller must be the target user's device owner/profile Owner or hold the\n     * {@link android.Manifest.permission#INTERACT_ACROSS_USERS_FULL} permission.\n     *\n     * @param user The user for whom to retrieve information.\n     * @return list of aliases identifying CA certificates installed by the device or profile owner\n     * @throws SecurityException if the caller does not have permission to retrieve information\n     *         about the given user's CA certificates.\n     *\n     * @hide\n     ",
    "links" : [ "android.Manifest.permission#INTERACT_ACROSS_USERS_FULL" ]
  }, {
    "name" : "public boolean isFactoryResetProtectionPolicySupported()",
    "returnType" : "boolean",
    "comment" : "\n     * Returns whether factory reset protection policy is supported on the device.\n     *\n     * @return {@code true} if the device support factory reset protection policy.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public void clearApplicationUserData(@NonNull ComponentName admin, @NonNull String packageName, @NonNull @CallbackExecutor Executor executor, @NonNull OnClearApplicationUserDataListener listener)",
    "returnType" : "void",
    "comment" : "\n     * Called by the device owner or profile owner to clear application user data of a given\n     * package. The behaviour of this is equivalent to the target application calling\n     * {@link android.app.ActivityManager#clearApplicationUserData()}.\n     *\n     * <p><strong>Note:</strong> an application can store data outside of its application data, e.g.\n     * external storage or user dictionary. This data will not be wiped by calling this API.\n     *\n     * @param admin Which {@link DeviceAdminReceiver} this request is associated with.\n     * @param packageName The name of the package which will have its user data wiped.\n     * @param executor The executor through which the listener should be invoked.\n     * @param listener A callback object that will inform the caller when the clearing is done.\n     * @throws SecurityException if the caller is not the device owner/profile owner.\n     ",
    "links" : [ "android.app.ActivityManager#clearApplicationUserData()", "android.app.admin.DeviceAdminReceiver" ]
  }, {
    "name" : "public void setLogoutEnabled(@NonNull ComponentName admin, boolean enabled)",
    "returnType" : "void",
    "comment" : "\n     * Called by a device owner to specify whether logout is enabled for all secondary users. The\n     * system may show a logout button that stops the user and switches back to the primary user.\n     *\n     * @param admin Which {@link DeviceAdminReceiver} this request is associated with.\n     * @param enabled whether logout should be enabled or not.\n     * @throws SecurityException if {@code admin} is not a device owner.\n     ",
    "links" : [ "android.app.admin.DeviceAdminReceiver" ]
  }, {
    "name" : "public boolean isLogoutEnabled()",
    "returnType" : "boolean",
    "comment" : "\n     * Returns whether logout is enabled by a device owner.\n     *\n     * @return {@code true} if logout is enabled by device owner, {@code false} otherwise.\n     ",
    "links" : [ ]
  }, {
    "name" : "public Set<String> getDisallowedSystemApps(@NonNull ComponentName admin, @UserIdInt int userId, @NonNull String provisioningAction)",
    "returnType" : "Set<String>",
    "comment" : "\n     * Returns set of system apps that should be removed during provisioning.\n     *\n     * @param admin Which {@link DeviceAdminReceiver} this request is associated with.\n     * @param userId ID of the user to be provisioned.\n     * @param provisioningAction action indicating type of provisioning, should be one of\n     * {@link #ACTION_PROVISION_MANAGED_DEVICE}, {@link #ACTION_PROVISION_MANAGED_PROFILE} or\n     * {@link #ACTION_PROVISION_MANAGED_USER}.\n     *\n     * @hide\n     ",
    "links" : [ "#ACTION_PROVISION_MANAGED_DEVICE", "android.app.admin.DeviceAdminReceiver", "#ACTION_PROVISION_MANAGED_PROFILE", "#ACTION_PROVISION_MANAGED_USER" ]
  }, {
    "name" : "public void transferOwnership(@NonNull ComponentName admin, @NonNull ComponentName target, @Nullable PersistableBundle bundle)",
    "returnType" : "void",
    "comment" : "\n     * Changes the current administrator to another one. All policies from the current\n     * administrator are migrated to the new administrator. The whole operation is atomic -\n     * the transfer is either complete or not done at all.\n     *\n     * <p>Depending on the current administrator (device owner, profile owner), you have the\n     * following expected behaviour:\n     * <ul>\n     *     <li>A device owner can only be transferred to a new device owner</li>\n     *     <li>A profile owner can only be transferred to a new profile owner</li>\n     * </ul>\n     *\n     * <p>Use the {@code bundle} parameter to pass data to the new administrator. The data\n     * will be received in the\n     * {@link DeviceAdminReceiver#onTransferOwnershipComplete(Context, PersistableBundle)}\n     * callback of the new administrator.\n     *\n     * <p>The transfer has failed if the original administrator is still the corresponding owner\n     * after calling this method.\n     *\n     * <p>The incoming target administrator must have the\n     * <code>&lt;support-transfer-ownership /&gt;</code> tag inside the\n     * <code>&lt;device-admin&gt;&lt;/device-admin&gt;</code> tags in the xml file referenced by\n     * {@link DeviceAdminReceiver#DEVICE_ADMIN_META_DATA}. Otherwise an\n     * {@link IllegalArgumentException} will be thrown.\n     *\n     * @param admin which {@link DeviceAdminReceiver} this request is associated with.\n     * @param target which {@link DeviceAdminReceiver} we want the new administrator to be.\n     * @param bundle data to be sent to the new administrator.\n     * @throws SecurityException if {@code admin} is not a device owner nor a profile owner.\n     * @throws IllegalArgumentException if {@code admin} or {@code target} is {@code null}, they\n     * are components in the same package or {@code target} is not an active admin.\n     ",
    "links" : [ "android.app.admin.DeviceAdminReceiver#onTransferOwnershipComplete(Context", "android.app.admin.DeviceAdminReceiver", "android.app.admin.DeviceAdminReceiver#DEVICE_ADMIN_META_DATA", "IllegalArgumentException" ]
  }, {
    "name" : "public void setStartUserSessionMessage(@NonNull ComponentName admin, @Nullable CharSequence startUserSessionMessage)",
    "returnType" : "void",
    "comment" : "\n     * Called by a device owner to specify the user session start message. This may be displayed\n     * during a user switch.\n     * <p>\n     * The message should be limited to a short statement or it may be truncated.\n     * <p>\n     * If the message needs to be localized, it is the responsibility of the\n     * {@link DeviceAdminReceiver} to listen to the {@link Intent#ACTION_LOCALE_CHANGED} broadcast\n     * and set a new version of this message accordingly.\n     *\n     * @param admin which {@link DeviceAdminReceiver} this request is associated with.\n     * @param startUserSessionMessage message for starting user session, or {@code null} to use\n     * system default message.\n     * @throws SecurityException if {@code admin} is not a device owner.\n     ",
    "links" : [ "android.content.Intent#ACTION_LOCALE_CHANGED", "android.app.admin.DeviceAdminReceiver" ]
  }, {
    "name" : "public void setEndUserSessionMessage(@NonNull ComponentName admin, @Nullable CharSequence endUserSessionMessage)",
    "returnType" : "void",
    "comment" : "\n     * Called by a device owner to specify the user session end message. This may be displayed\n     * during a user switch.\n     * <p>\n     * The message should be limited to a short statement or it may be truncated.\n     * <p>\n     * If the message needs to be localized, it is the responsibility of the\n     * {@link DeviceAdminReceiver} to listen to the {@link Intent#ACTION_LOCALE_CHANGED} broadcast\n     * and set a new version of this message accordingly.\n     *\n     * @param admin which {@link DeviceAdminReceiver} this request is associated with.\n     * @param endUserSessionMessage message for ending user session, or {@code null} to use system\n     * default message.\n     * @throws SecurityException if {@code admin} is not a device owner.\n     ",
    "links" : [ "android.content.Intent#ACTION_LOCALE_CHANGED", "android.app.admin.DeviceAdminReceiver" ]
  }, {
    "name" : "public CharSequence getStartUserSessionMessage(@NonNull ComponentName admin)",
    "returnType" : "CharSequence",
    "comment" : "\n     * Returns the user session start message.\n     *\n     * @param admin which {@link DeviceAdminReceiver} this request is associated with.\n     * @throws SecurityException if {@code admin} is not a device owner.\n     ",
    "links" : [ "android.app.admin.DeviceAdminReceiver" ]
  }, {
    "name" : "public CharSequence getEndUserSessionMessage(@NonNull ComponentName admin)",
    "returnType" : "CharSequence",
    "comment" : "\n     * Returns the user session end message.\n     *\n     * @param admin which {@link DeviceAdminReceiver} this request is associated with.\n     * @throws SecurityException if {@code admin} is not a device owner.\n     ",
    "links" : [ "android.app.admin.DeviceAdminReceiver" ]
  }, {
    "name" : "public int addOverrideApn(@NonNull ComponentName admin, @NonNull ApnSetting apnSetting)",
    "returnType" : "int",
    "comment" : "\n     * Called by device owner or managed profile owner to add an override APN.\n     *\n     * <p>This method may returns {@code -1} if {@code apnSetting} conflicts with an existing\n     * override APN. Update the existing conflicted APN with\n     * {@link #updateOverrideApn(ComponentName, int, ApnSetting)} instead of adding a new entry.\n     * <p>Two override APNs are considered to conflict when all the following APIs return\n     * the same values on both override APNs:\n     * <ul>\n     *   <li>{@link ApnSetting#getOperatorNumeric()}</li>\n     *   <li>{@link ApnSetting#getApnName()}</li>\n     *   <li>{@link ApnSetting#getProxyAddressAsString()}</li>\n     *   <li>{@link ApnSetting#getProxyPort()}</li>\n     *   <li>{@link ApnSetting#getMmsProxyAddressAsString()}</li>\n     *   <li>{@link ApnSetting#getMmsProxyPort()}</li>\n     *   <li>{@link ApnSetting#getMmsc()}</li>\n     *   <li>{@link ApnSetting#isEnabled()}</li>\n     *   <li>{@link ApnSetting#getMvnoType()}</li>\n     *   <li>{@link ApnSetting#getProtocol()}</li>\n     *   <li>{@link ApnSetting#getRoamingProtocol()}</li>\n     * </ul>\n     *\n     * <p> Before Android version {@link android.os.Build.VERSION_CODES#TIRAMISU}:\n     * Only device owners can add APNs.\n     * <p> Starting from Android version {@link android.os.Build.VERSION_CODES#TIRAMISU}:\n     * Both device owners and managed profile owners can add enterprise APNs\n     * ({@link ApnSetting#TYPE_ENTERPRISE}), while only device owners can add other type of APNs.\n     * Enterprise APNs are specific to the managed profile and do not override any user-configured\n     * VPNs. They are prerequisites for enabling preferential network service on the managed\n     * profile on 4G networks ({@link #setPreferentialNetworkServiceConfigs}).\n     *\n     * @param admin which {@link DeviceAdminReceiver} this request is associated with\n     * @param apnSetting the override APN to insert\n     * @return The {@code id} of inserted override APN. Or {@code -1} when failed to insert into\n     *         the database.\n     * @throws SecurityException If request is for enterprise APN {@code admin} is either device\n     * owner or profile owner and in all other types of APN if {@code admin} is not a device owner.\n     *\n     * @see #setOverrideApnsEnabled(ComponentName, boolean)\n     ",
    "links" : [ "android.telephony.data.ApnSetting#getRoamingProtocol()", "android.telephony.data.ApnSetting#getProxyPort()", "android.telephony.data.ApnSetting#getMmsc()", "android.os.Build.VERSION_CODES#TIRAMISU", "#updateOverrideApn(ComponentName", "#setPreferentialNetworkServiceConfigs", "android.telephony.data.ApnSetting#getMvnoType()", "android.app.admin.DeviceAdminReceiver", "android.telephony.data.ApnSetting#getApnName()", "android.telephony.data.ApnSetting#getMmsProxyAddressAsString()", "android.telephony.data.ApnSetting#TYPE_ENTERPRISE", "android.telephony.data.ApnSetting#getMmsProxyPort()", "android.telephony.data.ApnSetting#isEnabled()", "android.telephony.data.ApnSetting#getProtocol()", "android.telephony.data.ApnSetting#getOperatorNumeric()", "android.telephony.data.ApnSetting#getProxyAddressAsString()" ]
  }, {
    "name" : "public boolean updateOverrideApn(@NonNull ComponentName admin, int apnId, @NonNull ApnSetting apnSetting)",
    "returnType" : "boolean",
    "comment" : "\n     * Called by device owner or managed profile owner to update an override APN.\n     *\n     * <p>This method may returns {@code false} if there is no override APN with the given\n     * {@code apnId}.\n     * <p>This method may also returns {@code false} if {@code apnSetting} conflicts with an\n     * existing override APN. Update the existing conflicted APN instead.\n     * <p>See {@link #addOverrideApn} for the definition of conflict.\n     * <p> Before Android version {@link android.os.Build.VERSION_CODES#TIRAMISU}:\n     * Only device owners can update APNs.\n     * <p> Starting from Android version {@link android.os.Build.VERSION_CODES#TIRAMISU}:\n     * Both device owners and managed profile owners can update enterprise APNs\n     * ({@link ApnSetting#TYPE_ENTERPRISE}), while only device owners can update other type of APNs.\n     *\n     * @param admin which {@link DeviceAdminReceiver} this request is associated with\n     * @param apnId the {@code id} of the override APN to update\n     * @param apnSetting the override APN to update\n     * @return {@code true} if the required override APN is successfully updated,\n     *         {@code false} otherwise.\n     * @throws SecurityException If request is for enterprise APN {@code admin} is either device\n     * owner or profile owner and in all other types of APN if {@code admin} is not a device owner.\n     *\n     * @see #setOverrideApnsEnabled(ComponentName, boolean)\n     ",
    "links" : [ "android.os.Build.VERSION_CODES#TIRAMISU", "android.app.admin.DeviceAdminReceiver", "#addOverrideApn", "android.telephony.data.ApnSetting#TYPE_ENTERPRISE" ]
  }, {
    "name" : "public boolean removeOverrideApn(@NonNull ComponentName admin, int apnId)",
    "returnType" : "boolean",
    "comment" : "\n     * Called by device owner or managed profile owner to remove an override APN.\n     *\n     * <p>This method may returns {@code false} if there is no override APN with the given\n     * {@code apnId}.\n     * <p> Before Android version {@link android.os.Build.VERSION_CODES#TIRAMISU}:\n     * Only device owners can remove APNs.\n     * <p> Starting from Android version {@link android.os.Build.VERSION_CODES#TIRAMISU}:\n     * Both device owners and managed profile owners can remove enterprise APNs\n     * ({@link ApnSetting#TYPE_ENTERPRISE}), while only device owners can remove other type of APNs.\n     *\n     * @param admin which {@link DeviceAdminReceiver} this request is associated with\n     * @param apnId the {@code id} of the override APN to remove\n     * @return {@code true} if the required override APN is successfully removed, {@code false}\n     *         otherwise.\n     * @throws SecurityException If request is for enterprise APN {@code admin} is either device\n     * owner or profile owner and in all other types of APN if {@code admin} is not a device owner.\n     *\n     * @see #setOverrideApnsEnabled(ComponentName, boolean)\n     ",
    "links" : [ "android.os.Build.VERSION_CODES#TIRAMISU", "android.app.admin.DeviceAdminReceiver", "android.telephony.data.ApnSetting#TYPE_ENTERPRISE" ]
  }, {
    "name" : "public List<ApnSetting> getOverrideApns(@NonNull ComponentName admin)",
    "returnType" : "List<ApnSetting>",
    "comment" : "\n     * Called by device owner or managed profile owner to get all override APNs inserted by\n     * device owner or managed profile owner previously using {@link #addOverrideApn}.\n     *\n     * @param admin which {@link DeviceAdminReceiver} this request is associated with\n     * @return A list of override APNs inserted by device owner.\n     * @throws SecurityException if {@code admin} is not a device owner.\n     *\n     * @see #setOverrideApnsEnabled(ComponentName, boolean)\n     ",
    "links" : [ "android.app.admin.DeviceAdminReceiver", "#addOverrideApn" ]
  }, {
    "name" : "public void setOverrideApnsEnabled(@NonNull ComponentName admin, boolean enabled)",
    "returnType" : "void",
    "comment" : "\n     * Called by device owner to set if override APNs should be enabled.\n     * <p> Override APNs are separated from other APNs on the device, and can only be inserted or\n     * modified by the device owner. When enabled, only override APNs are in use, any other APNs\n     * are ignored.\n     * <p>Note: Enterprise APNs added by managed profile owners do not need to be enabled by\n     * this API. They are part of the preferential network service config and is controlled by\n     * {@link #setPreferentialNetworkServiceConfigs}.\n     *\n     * @param admin which {@link DeviceAdminReceiver} this request is associated with\n     * @param enabled {@code true} if override APNs should be enabled, {@code false} otherwise\n     * @throws SecurityException if {@code admin} is not a device owner.\n     ",
    "links" : [ "#setPreferentialNetworkServiceConfigs", "android.app.admin.DeviceAdminReceiver" ]
  }, {
    "name" : "public boolean isOverrideApnEnabled(@NonNull ComponentName admin)",
    "returnType" : "boolean",
    "comment" : "\n     * Called by device owner to check if override APNs are currently enabled.\n     *\n     * @param admin which {@link DeviceAdminReceiver} this request is associated with\n     * @return {@code true} if override APNs are currently enabled, {@code false} otherwise.\n     * @throws SecurityException if {@code admin} is not a device owner.\n     *\n     * @see #setOverrideApnsEnabled(ComponentName, boolean)\n     ",
    "links" : [ "android.app.admin.DeviceAdminReceiver" ]
  }, {
    "name" : "public PersistableBundle getTransferOwnershipBundle()",
    "returnType" : "PersistableBundle",
    "comment" : "\n     * Returns the data passed from the current administrator to the new administrator during an\n     * ownership transfer. This is the same {@code bundle} passed in\n     * {@link #transferOwnership(ComponentName, ComponentName, PersistableBundle)}. The bundle is\n     * persisted until the profile owner or device owner is removed.\n     *\n     * <p>This is the same <code>bundle</code> received in the\n     * {@link DeviceAdminReceiver#onTransferOwnershipComplete(Context, PersistableBundle)}.\n     * Use this method to retrieve it after the transfer as long as the new administrator is the\n     * active device or profile owner.\n     *\n     * <p>Returns <code>null</code> if no ownership transfer was started for the calling user.\n     *\n     * @see #transferOwnership\n     * @see DeviceAdminReceiver#onTransferOwnershipComplete(Context, PersistableBundle)\n     * @throws SecurityException if the caller is not a device or profile owner.\n     ",
    "links" : [ "android.app.admin.DeviceAdminReceiver#onTransferOwnershipComplete(Context", "#transferOwnership(ComponentName" ]
  }, {
    "name" : "public int setGlobalPrivateDnsModeOpportunistic(@NonNull ComponentName admin)",
    "returnType" : "int",
    "comment" : "\n     * Sets the global Private DNS mode to opportunistic.\n     * May only be called by the device owner.\n     *\n     * <p>In this mode, the DNS subsystem will attempt a TLS handshake to the network-supplied\n     * resolver prior to attempting name resolution in cleartext.\n     *\n     * <p>Note: The device owner won't be able to set the global private DNS mode if there are\n     * unaffiliated secondary users or profiles on the device. It's recommended that affiliation\n     * ids are set for new users as soon as possible after provisioning via\n     * {@link #setAffiliationIds}.\n     *\n     * @param admin which {@link DeviceAdminReceiver} this request is associated with.\n     *\n     * @return {@code PRIVATE_DNS_SET_NO_ERROR} if the mode was set successfully, or\n     *         {@code PRIVATE_DNS_SET_ERROR_FAILURE_SETTING} if it could not be set.\n     *\n     * @throws SecurityException if the caller is not the device owner.\n     ",
    "links" : [ "android.app.admin.DeviceAdminReceiver", "#setAffiliationIds" ]
  }, {
    "name" : "public int setGlobalPrivateDnsModeSpecifiedHost(@NonNull ComponentName admin, @NonNull String privateDnsHost)",
    "returnType" : "int",
    "comment" : "\n     * Sets the global Private DNS host to be used.\n     * May only be called by the device owner.\n     *\n     * <p>Note that the method is blocking as it will perform a connectivity check to the resolver,\n     * to ensure it is valid. Because of that, the method should not be called on any thread that\n     * relates to user interaction, such as the UI thread.\n     *\n     * <p>In case a VPN is used in conjunction with Private DNS resolver, the Private DNS resolver\n     * must be reachable both from within and outside the VPN. Otherwise, the device may lose\n     * the ability to resolve hostnames as system traffic to the resolver may not go through the\n     * VPN.\n     *\n     * <p>Note: The device owner won't be able to set the global private DNS mode if there are\n     * unaffiliated secondary users or profiles on the device. It's recommended that affiliation\n     * ids are set for new users as soon as possible after provisioning via\n     * {@link #setAffiliationIds}.\n     *\n     * @param admin which {@link DeviceAdminReceiver} this request is associated with.\n     * @param privateDnsHost The hostname of a server that implements DNS over TLS (RFC7858).\n     *\n     * @return {@code PRIVATE_DNS_SET_NO_ERROR} if the mode was set successfully,\n     *         {@code PRIVATE_DNS_SET_ERROR_FAILURE_SETTING} if it could not be set or\n     *         {@code PRIVATE_DNS_SET_ERROR_HOST_NOT_SERVING} if the specified host does not\n     *         implement RFC7858.\n     *\n     * @throws IllegalArgumentException if the {@code privateDnsHost} is not a valid hostname.\n     *\n     * @throws SecurityException if the caller is not the device owner.\n     ",
    "links" : [ "android.app.admin.DeviceAdminReceiver", "#setAffiliationIds" ]
  }, {
    "name" : "public void installSystemUpdate(@Nullable ComponentName admin, @NonNull Uri updateFilePath, @NonNull @CallbackExecutor Executor executor, @NonNull InstallSystemUpdateCallback callback)",
    "returnType" : "void",
    "comment" : "\n     * Called by device owner or profile owner of an organization-owned managed profile to install\n     * a system update from the given file. The device will be\n     * rebooted in order to finish installing the update. Note that if the device is rebooted, this\n     * doesn't necessarily mean that the update has been applied successfully. The caller should\n     * additionally check the system version with {@link android.os.Build#FINGERPRINT} or {@link\n     * android.os.Build.VERSION}. If an error occurs during processing the OTA before the reboot,\n     * the caller will be notified by {@link InstallSystemUpdateCallback}. If device does not have\n     * sufficient battery level, the installation will fail with error {@link\n     * InstallSystemUpdateCallback#UPDATE_ERROR_BATTERY_LOW}.\n     *\n     * @param admin The {@link DeviceAdminReceiver} that this request is associated with. Null if\n     *              the caller is not a device admin\n     * @param updateFilePath A Uri of the file that contains the update. The file should be\n     * readable by the calling app.\n     * @param executor The executor through which the callback should be invoked.\n     * @param callback A callback object that will inform the caller when installing an update\n     * fails.\n     ",
    "links" : [ "android.os.Build.VERSION", "android.os.Build#FINGERPRINT", "android.app.admin.DeviceAdminReceiver", "InstallSystemUpdateCallback", "#UPDATE_ERROR_BATTERY_LOW" ]
  }, {
    "name" : "private void executeCallback(int errorCode, String errorMessage, @NonNull @CallbackExecutor Executor executor, @NonNull InstallSystemUpdateCallback callback)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public int getGlobalPrivateDnsMode(@NonNull ComponentName admin)",
    "returnType" : "int",
    "comment" : "\n     * Returns the system-wide Private DNS mode.\n     *\n     * @param admin which {@link DeviceAdminReceiver} this request is associated with.\n     * @return one of {@code PRIVATE_DNS_MODE_OFF}, {@code PRIVATE_DNS_MODE_OPPORTUNISTIC},\n     * {@code PRIVATE_DNS_MODE_PROVIDER_HOSTNAME} or {@code PRIVATE_DNS_MODE_UNKNOWN}.\n     * @throws SecurityException if the caller is not the device owner.\n     ",
    "links" : [ "android.app.admin.DeviceAdminReceiver" ]
  }, {
    "name" : "public String getGlobalPrivateDnsHost(@NonNull ComponentName admin)",
    "returnType" : "String",
    "comment" : "\n     * Returns the system-wide Private DNS host.\n     *\n     * @param admin which {@link DeviceAdminReceiver} this request is associated with.\n     * @return The hostname used for Private DNS queries, null if none is set.\n     * @throws SecurityException if the caller is not the device owner.\n     ",
    "links" : [ "android.app.admin.DeviceAdminReceiver" ]
  }, {
    "name" : "public void setProfileOwnerCanAccessDeviceIds(@NonNull ComponentName who)",
    "returnType" : "void",
    "comment" : "\n     * Deprecated. Use {@code markProfileOwnerOnOrganizationOwnedDevice} instead.\n     * When called by an app targeting SDK level {@link android.os.Build.VERSION_CODES#Q} or\n     * below, will behave the same as {@link #setProfileOwnerOnOrganizationOwnedDevice}.\n     *\n     * When called by an app targeting SDK level {@link android.os.Build.VERSION_CODES#R}\n     * or above, will throw an UnsupportedOperationException when called.\n     *\n     * @deprecated Use {@link #setProfileOwnerOnOrganizationOwnedDevice} instead.\n     *\n     * @hide\n     ",
    "links" : [ "#setProfileOwnerOnOrganizationOwnedDevice", "android.os.Build.VERSION_CODES#R", "android.os.Build.VERSION_CODES#Q" ]
  }, {
    "name" : "public void setProfileOwnerOnOrganizationOwnedDevice(@NonNull ComponentName who, boolean isProfileOwnerOnOrganizationOwnedDevice)",
    "returnType" : "void",
    "comment" : "\n     * Sets whether the profile owner of the given user as managing an organization-owned device.\n     * Managing an organization-owned device will give it access to device identifiers (such as\n     * serial number, IMEI and MEID) as well as other privileges.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public void setCrossProfileCalendarPackages(@NonNull ComponentName admin, @Nullable Set<String> packageNames)",
    "returnType" : "void",
    "comment" : "\n     * Allows a set of packages to access cross-profile calendar APIs.\n     *\n     * <p>Called by a profile owner of a managed profile.\n     *\n     * <p>Calling with a {@code null} value for the set disables the restriction so that all\n     * packages are allowed to access cross-profile calendar APIs. Calling with an empty set\n     * disallows all packages from accessing cross-profile calendar APIs. If this method isn't\n     * called, no package is allowed to access cross-profile calendar APIs by default.\n     *\n     * @param admin which {@link DeviceAdminReceiver} this request is associated with\n     * @param packageNames set of packages to be allowlisted\n     * @throws SecurityException if {@code admin} is not a profile owner\n     *\n     * @see #getCrossProfileCalendarPackages(ComponentName)\n     * @deprecated Use {@link #setCrossProfilePackages(ComponentName, Set)}.\n     ",
    "links" : [ "android.app.admin.DeviceAdminReceiver", "#setCrossProfilePackages(ComponentName" ]
  }, {
    "name" : "public Set<String> getCrossProfileCalendarPackages(@NonNull ComponentName admin)",
    "returnType" : "Set<String>",
    "comment" : "\n     * Gets a set of package names that are allowed to access cross-profile calendar APIs.\n     *\n     * <p>Called by a profile owner of a managed profile.\n     *\n     * @param admin which {@link DeviceAdminReceiver} this request is associated with\n     * @return the set of names of packages that were previously allowed via\n     * {@link #setCrossProfileCalendarPackages(ComponentName, Set)}, or an\n     * empty set if none have been allowed\n     * @throws SecurityException if {@code admin} is not a profile owner\n     *\n     * @see #setCrossProfileCalendarPackages(ComponentName, Set)\n     * @deprecated Use {@link #setCrossProfilePackages(ComponentName, Set)}.\n     ",
    "links" : [ "android.app.admin.DeviceAdminReceiver", "#setCrossProfilePackages(ComponentName", "#setCrossProfileCalendarPackages(ComponentName" ]
  }, {
    "name" : "public boolean isPackageAllowedToAccessCalendar(@NonNull String packageName)",
    "returnType" : "boolean",
    "comment" : "\n     * Returns if a package is allowed to access cross-profile calendar APIs.\n     *\n     * <p>A package is allowed to access cross-profile calendar APIs if it's allowed by\n     * admins via {@link #setCrossProfileCalendarPackages(ComponentName, Set)} and\n     * {@link android.provider.Settings.Secure#CROSS_PROFILE_CALENDAR_ENABLED}\n     * is turned on in the managed profile.\n     *\n     * <p>To query for a specific user, use\n     * {@link Context#createPackageContextAsUser(String, int, UserHandle)} to create a context for\n     * that user, and get a {@link DevicePolicyManager} from this context.\n     *\n     * @param packageName the name of the package\n     * @return {@code true} if the package is allowed to access cross-profile calendar APIs,\n     * {@code false} otherwise\n     *\n     * @see #setCrossProfileCalendarPackages(ComponentName, Set)\n     * @see #getCrossProfileCalendarPackages(ComponentName)\n     * @hide\n     ",
    "links" : [ "android.app.admin.DevicePolicyManager", "android.provider.Settings.Secure#CROSS_PROFILE_CALENDAR_ENABLED", "android.content.Context#createPackageContextAsUser(String", "#setCrossProfileCalendarPackages(ComponentName" ]
  }, {
    "name" : "public Set<String> getCrossProfileCalendarPackages()",
    "returnType" : "Set<String>",
    "comment" : "\n     * Gets a set of package names that are allowed to access cross-profile calendar APIs.\n     *\n     * <p>To query for a specific user, use\n     * {@link Context#createPackageContextAsUser(String, int, UserHandle)} to create a context for\n     * that user, and get a {@link DevicePolicyManager} from this context.\n     *\n     * @return the set of names of packages that were previously allowed via\n     * {@link #setCrossProfileCalendarPackages(ComponentName, Set)}, or an\n     * empty set if none have been allowed\n     *\n     * @see #setCrossProfileCalendarPackages(ComponentName, Set)\n     * @see #getCrossProfileCalendarPackages(ComponentName)\n     * @hide\n     ",
    "links" : [ "android.app.admin.DevicePolicyManager", "android.content.Context#createPackageContextAsUser(String", "#setCrossProfileCalendarPackages(ComponentName" ]
  }, {
    "name" : "public void setCrossProfilePackages(@NonNull ComponentName admin, @NonNull Set<String> packageNames)",
    "returnType" : "void",
    "comment" : "\n     * Sets the set of admin-allowlisted package names that are allowed to request user consent for\n     * cross-profile communication.\n     *\n     * <p>Assumes that the caller is a profile owner and is the given {@code admin}.\n     *\n     * <p>Previous calls are overridden by each subsequent call to this method.\n     *\n     * <p>Note that other apps may be able to request user consent for cross-profile communication\n     * if they have been explicitly allowlisted by the OEM.\n     *\n     * <p>When previously-set cross-profile packages are missing from {@code packageNames}, the\n     * app-op for {@code INTERACT_ACROSS_PROFILES} will be reset for those packages. This will not\n     * occur for packages that are allowlisted by the OEM.\n     *\n     * @param admin the {@link DeviceAdminReceiver} this request is associated with\n     * @param packageNames the new cross-profile package names\n     ",
    "links" : [ "android.app.admin.DeviceAdminReceiver" ]
  }, {
    "name" : "public Set<String> getCrossProfilePackages(@NonNull ComponentName admin)",
    "returnType" : "Set<String>",
    "comment" : "\n     * Returns the set of package names that the admin has previously set as allowed to request user\n     * consent for cross-profile communication, via {@link #setCrossProfilePackages(ComponentName,\n     * Set)}.\n     *\n     * <p>Assumes that the caller is a profile owner and is the given {@code admin}.\n     *\n     * <p>Note that other apps not included in the returned set may be able to request user consent\n     * for cross-profile communication if they have been explicitly allowlisted by the OEM.\n     *\n     * @param admin the {@link DeviceAdminReceiver} this request is associated with\n     * @return the set of package names the admin has previously set as allowed to request user\n     * consent for cross-profile communication, via {@link #setCrossProfilePackages(ComponentName,\n     * Set)}\n     ",
    "links" : [ "android.app.admin.DeviceAdminReceiver", "#setCrossProfilePackages(ComponentName" ]
  }, {
    "name" : "public Set<String> getAllCrossProfilePackages()",
    "returnType" : "Set<String>",
    "comment" : "\n     * Returns the combined set of the following:\n     * <ul>\n     * <li>The package names that the admin has previously set as allowed to request user consent\n     * for cross-profile communication, via {@link #setCrossProfilePackages(ComponentName,\n     * Set)}.</li>\n     * <li>The default package names set by the OEM that are allowed to request user consent for\n     * cross-profile communication without being explicitly enabled by the admin, via {@link\n     * com.android.internal.R.array#cross_profile_apps} and {@link com.android.internal.R.array\n     * #vendor_cross_profile_apps}.</li>\n     * </ul>\n     *\n     * @return the combined set of allowlisted package names set via\n     * {@link #setCrossProfilePackages(ComponentName, Set)}, {@link com.android.internal.R.array\n     * #cross_profile_apps}, and {@link com.android.internal.R.array#vendor_cross_profile_apps}.\n     *\n     * @hide\n     ",
    "links" : [ "com.android.internal.R.array#vendor_cross_profile_apps", "#setCrossProfilePackages(ComponentName", "com.android.internal.R.array#cross_profile_apps" ]
  }, {
    "name" : "public Set<String> getDefaultCrossProfilePackages()",
    "returnType" : "Set<String>",
    "comment" : "\n     * Returns the default package names set by the OEM that are allowed to communicate\n     * cross-profile without being explicitly enabled by the admin, via {@link\n     * com.android.internal.R.array#cross_profile_apps} and {@link com.android.internal.R.array\n     * #vendor_cross_profile_apps}.\n     *\n     * @hide\n     ",
    "links" : [ "com.android.internal.R.array#vendor_cross_profile_apps", "com.android.internal.R.array#cross_profile_apps" ]
  }, {
    "name" : "public boolean isManagedKiosk()",
    "returnType" : "boolean",
    "comment" : "\n     * Returns whether the device is being used as a managed kiosk. These requirements are as\n     * follows:\n     * <ul>\n     *     <li>The device is in Lock Task (therefore there is also a Device Owner app on the\n     *     device)</li>\n     *     <li>The Lock Task feature {@link DevicePolicyManager#LOCK_TASK_FEATURE_SYSTEM_INFO} is\n     *     not enabled, so the system info in the status bar is not visible</li>\n     *     <li>The device does not have a secure lock screen (e.g. it has no lock screen or has\n     *     swipe-to-unlock)</li>\n     *     <li>The device is not in the middle of an ephemeral user session</li>\n     * </ul>\n     *\n     * <p>Publicly-accessible dedicated devices don't have the same privacy model as\n     * personally-used devices. In particular, user consent popups don't make sense as a barrier to\n     * accessing persistent data on these devices since the user giving consent and the user whose\n     * data is on the device are unlikely to be the same. These consent popups prevent the true\n     * remote management of these devices.\n     *\n     * <p>This condition is not sufficient to cover APIs that would access data that only lives for\n     * the duration of the user's session, since the user has an expectation of privacy in these\n     * conditions that more closely resembles use of a personal device. In those cases, see {@link\n     * #isUnattendedManagedKiosk()}.\n     *\n     * @hide\n     ",
    "links" : [ "#isUnattendedManagedKiosk()", "android.app.admin.DevicePolicyManager#LOCK_TASK_FEATURE_SYSTEM_INFO" ]
  }, {
    "name" : "public boolean isUnattendedManagedKiosk()",
    "returnType" : "boolean",
    "comment" : "\n     * Returns whether the device is being used as an unattended managed kiosk. These requirements\n     * are as follows:\n     * <ul>\n     *     <li>The device is being used as a managed kiosk, as defined at {@link\n     *     #isManagedKiosk()}</li>\n     *     <li>The device has not received user input for at least 30 minutes</li>\n     * </ul>\n     *\n     * <p>See {@link #isManagedKiosk()} for context. This is a stronger requirement that also\n     * ensures that the device hasn't been interacted with recently, making it an appropriate check\n     * for privacy-sensitive APIs that wouldn't be appropriate during an active user session.\n     *\n     * @hide\n     ",
    "links" : [ "#isManagedKiosk()" ]
  }, {
    "name" : "public boolean startViewCalendarEventInManagedProfile(long eventId, long start, long end, boolean allDay, int flags)",
    "returnType" : "boolean",
    "comment" : "\n     * Starts an activity to view calendar events in the managed profile.\n     *\n     * @param eventId the id of the event to be viewed\n     * @param start the start time of the event\n     * @param end the end time of the event\n     * @param allDay if the event is an all-day event\n     * @param flags flags to be set for the intent\n     * @return {@code true} if the activity is started successfully, {@code false} otherwise\n     *\n     * @see CalendarContract#startViewCalendarEventInManagedProfile(Context, String, long, long,\n     * long, boolean, int)\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public void setApplicationExemptions(@NonNull String packageName, @NonNull @ApplicationExemptionConstants Set<Integer> exemptions) throws NameNotFoundException",
    "returnType" : "void",
    "comment" : "\n     * Called by an application with the\n     * {@link  android.Manifest.permission#MANAGE_DEVICE_POLICY_APP_EXEMPTIONS} permission, to\n     * grant platform restriction exemptions to a given application.\n     *\n     * @param  packageName The package name of the application to be exempt.\n     * @param  exemptions The set of exemptions to be applied.\n     * @throws SecurityException If the caller does not have\n     *             {@link  android.Manifest.permission#MANAGE_DEVICE_POLICY_APP_EXEMPTIONS}\n     * @throws NameNotFoundException If either the package is not installed or the package is not\n     *              visible to the caller.\n     * @hide\n     ",
    "links" : [ "android.Manifest.permission#MANAGE_DEVICE_POLICY_APP_EXEMPTIONS" ]
  }, {
    "name" : "public Set<Integer> getApplicationExemptions(@NonNull String packageName) throws NameNotFoundException",
    "returnType" : "Set<Integer>",
    "comment" : "\n     * Returns all the platform restriction exemptions currently applied to an application. Called\n     * by an application with the\n     * {@link  android.Manifest.permission#MANAGE_DEVICE_POLICY_APP_EXEMPTIONS} permission.\n     *\n     * @param  packageName The package name to check.\n     * @return A set of platform restrictions an application is exempt from.\n     * @throws SecurityException If the caller does not have\n     *             {@link  android.Manifest.permission#MANAGE_DEVICE_POLICY_APP_EXEMPTIONS}\n     * @throws NameNotFoundException If either the package is not installed or the package is not\n     *              visible to the caller.\n     * @hide\n     ",
    "links" : [ "android.Manifest.permission#MANAGE_DEVICE_POLICY_APP_EXEMPTIONS" ]
  }, {
    "name" : "private Set<Integer> intArrayToSet(int[] array)",
    "returnType" : "Set<Integer>",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public void setUserControlDisabledPackages(@Nullable ComponentName admin, @NonNull List<String> packages)",
    "returnType" : "void",
    "comment" : "\n     * Called by a device owner or a profile owner or holder of the permission\n     * {@link android.Manifest.permission#MANAGE_DEVICE_POLICY_APPS_CONTROL} to disable user\n     * control over apps. User will not be able to clear app data or force-stop packages. When\n     * called by a device owner, applies to all users on the device. Packages with user control\n     * disabled are exempted from App Standby Buckets.\n     * <p>\n     * Starting from {@link Build.VERSION_CODES#UPSIDE_DOWN_CAKE}, after the user control disabled\n     * packages policy has been set, {@link PolicyUpdateReceiver#onPolicySetResult(Context, String,\n     * Bundle, TargetUser, PolicyUpdateResult)} will notify the admin on whether the policy was\n     * successfully set or not. This callback will contain:\n     * <ul>\n     * <li> The policy identifier\n     * {@link DevicePolicyIdentifiers#USER_CONTROL_DISABLED_PACKAGES_POLICY}\n     * <li> The {@link TargetUser} that this policy relates to\n     * <li> The {@link PolicyUpdateResult}, which will be\n     * {@link PolicyUpdateResult#RESULT_POLICY_SET} if the policy was successfully set or the\n     * reason the policy failed to be set\n     * (e.g. {@link PolicyUpdateResult#RESULT_FAILURE_CONFLICTING_ADMIN_POLICY})\n     * </ul>\n     * If there has been a change to the policy,\n     * {@link PolicyUpdateReceiver#onPolicyChanged(Context, String, Bundle, TargetUser,\n     * PolicyUpdateResult)} will notify the admin of this change. This callback will contain the\n     * same parameters as PolicyUpdateReceiver#onPolicySetResult and the {@link PolicyUpdateResult}\n     * will contain the reason why the policy changed.\n     *\n     * @param admin Which {@link DeviceAdminReceiver} this request is associated with. Null if the\n     *               caller is not a device admin.\n     * @param packages The package names for the apps.\n     * @throws SecurityException if {@code admin} is not a device owner or a profile owner or\n     * holder of the permission\n     * {@link android.Manifest.permission#MANAGE_DEVICE_POLICY_APPS_CONTROL}.\n     ",
    "links" : [ "android.app.admin.PolicyUpdateResult#RESULT_FAILURE_CONFLICTING_ADMIN_POLICY", "android.app.admin.PolicyUpdateResult", "android.app.admin.PolicyUpdateResult#RESULT_POLICY_SET", "android.app.admin.DeviceAdminReceiver", "android.app.admin.PolicyUpdateReceiver#onPolicyChanged(Context", "Build.VERSION_CODES#UPSIDE_DOWN_CAKE", "android.app.admin.PolicyUpdateReceiver#onPolicySetResult(Context", "android.Manifest.permission#MANAGE_DEVICE_POLICY_APPS_CONTROL", "android.app.admin.TargetUser", "android.app.admin.DevicePolicyIdentifiers#USER_CONTROL_DISABLED_PACKAGES_POLICY" ]
  }, {
    "name" : "public List<String> getUserControlDisabledPackages(@Nullable ComponentName admin)",
    "returnType" : "List<String>",
    "comment" : "\n     * Returns the list of packages over which user control is disabled by a device or profile\n     * owner or holders of the permission\n     * {@link android.Manifest.permission#MANAGE_DEVICE_POLICY_APPS_CONTROL}.\n     * <p>\n     * Starting from {@link Build.VERSION_CODES#UPSIDE_DOWN_CAKE}, the returned policy will be the\n     * current resolved policy rather than the policy set by the calling admin.\n     *\n     * @param admin Which {@link DeviceAdminReceiver} this request is associated with. Null if the\n     *               caller is not a device admin.\n     * @throws SecurityException if {@code admin} is not a device or profile owner or holder of the\n     * permission {@link android.Manifest.permission#MANAGE_DEVICE_POLICY_APPS_CONTROL}.\n     ",
    "links" : [ "android.app.admin.DeviceAdminReceiver", "Build.VERSION_CODES#UPSIDE_DOWN_CAKE", "android.Manifest.permission#MANAGE_DEVICE_POLICY_APPS_CONTROL" ]
  }, {
    "name" : "public void setCommonCriteriaModeEnabled(@Nullable ComponentName admin, boolean enabled)",
    "returnType" : "void",
    "comment" : "\n     * Called by device owner or profile owner of an organization-owned managed profile to toggle\n     * Common Criteria mode for the device. When the device is in Common Criteria mode,\n     * certain device functionalities are tuned to meet the higher\n     * security level required by Common Criteria certification. For example:\n     * <ul>\n     * <li> Bluetooth long term key material is additionally integrity-protected with AES-GCM. </li>\n     * <li> WiFi configuration store is additionally integrity-protected with AES-GCM. </li>\n     * </ul>\n     * Common Criteria mode is disabled by default.\n     *\n     * <p><em>Note:</em> if Common Critera mode is turned off after being enabled previously,\n     * all existing WiFi configurations will be lost.\n     *\n     * @param admin Which {@link DeviceAdminReceiver} this request is associated with. Null if the\n     *              caller is not a device admin.\n     * @param enabled whether Common Criteria mode should be enabled or not.\n     ",
    "links" : [ "android.app.admin.DeviceAdminReceiver" ]
  }, {
    "name" : "public boolean isCommonCriteriaModeEnabled(@Nullable ComponentName admin)",
    "returnType" : "boolean",
    "comment" : "\n     * Returns whether Common Criteria mode is currently enabled. Device owner and profile owner of\n     * an organization-owned managed profile can query its own Common Criteria mode setting by\n     * calling this method with its admin {@link ComponentName}. Any caller can obtain the\n     * aggregated device-wide Common Criteria mode state by passing {@code null} as the\n     * {@code admin} argument.\n     *\n     * @param admin Which {@link DeviceAdminReceiver} this request is associated with. Null if the\n     *              caller is not a device admin.\n     * @return {@code true} if Common Criteria mode is enabled, {@code false} otherwise.\n     ",
    "links" : [ "android.app.admin.DeviceAdminReceiver", "android.content.ComponentName" ]
  }, {
    "name" : "public int getPersonalAppsSuspendedReasons(@NonNull ComponentName admin)",
    "returnType" : "int",
    "comment" : "\n     * Called by profile owner of an organization-owned managed profile to check whether\n     * personal apps are suspended.\n     *\n     * @return a bitmask of reasons for personal apps suspension or\n     *     {@link #PERSONAL_APPS_NOT_SUSPENDED} if apps are not suspended.\n     * @see #setPersonalAppsSuspended\n     ",
    "links" : [ "#PERSONAL_APPS_NOT_SUSPENDED" ]
  }, {
    "name" : "public void setPersonalAppsSuspended(@NonNull ComponentName admin, boolean suspended)",
    "returnType" : "void",
    "comment" : "\n     * Called by a profile owner of an organization-owned managed profile to suspend personal\n     * apps on the device. When personal apps are suspended the device can only be used for calls.\n     *\n     * @param admin Which {@link DeviceAdminReceiver} this request is associated with\n     * @param suspended Whether personal apps should be suspended.\n     * @throws IllegalStateException if the profile owner doesn't have an activity that handles\n     *        {@link #ACTION_CHECK_POLICY_COMPLIANCE}\n     ",
    "links" : [ "android.app.admin.DeviceAdminReceiver", "#ACTION_CHECK_POLICY_COMPLIANCE" ]
  }, {
    "name" : "public void setManagedProfileMaximumTimeOff(@NonNull ComponentName admin, long timeoutMillis)",
    "returnType" : "void",
    "comment" : "\n     * Called by a profile owner of an organization-owned managed profile to set maximum time\n     * the profile is allowed to be turned off. If the profile is turned off for longer, personal\n     * apps are suspended on the device.\n     *\n     * <p>When personal apps are suspended, an ongoing notification about that is shown to the user.\n     * When the user taps the notification, system invokes {@link #ACTION_CHECK_POLICY_COMPLIANCE}\n     * in the profile owner package. Profile owner implementation that uses personal apps suspension\n     * must handle this intent.\n     *\n     * @param admin Which {@link DeviceAdminReceiver} this request is associated with\n     * @param timeoutMillis Maximum time the profile is allowed to be off in milliseconds or 0 if\n     *        not limited. The minimum non-zero value corresponds to 72 hours. If an admin sets a\n     *        smaller non-zero vaulue, 72 hours will be set instead.\n     * @throws IllegalStateException if the profile owner doesn't have an activity that handles\n     *        {@link #ACTION_CHECK_POLICY_COMPLIANCE}\n     * @see #setPersonalAppsSuspended\n     ",
    "links" : [ "android.app.admin.DeviceAdminReceiver", "#ACTION_CHECK_POLICY_COMPLIANCE" ]
  }, {
    "name" : "public long getManagedProfileMaximumTimeOff(@NonNull ComponentName admin)",
    "returnType" : "long",
    "comment" : "\n     * Called by a profile owner of an organization-owned managed profile to get maximum time\n     * the profile is allowed to be turned off.\n     *\n     * @param admin Which {@link DeviceAdminReceiver} this request is associated with\n     * @return Maximum time the profile is allowed to be off in milliseconds or 0 if not limited.\n     * @see #setPersonalAppsSuspended\n     ",
    "links" : [ "android.app.admin.DeviceAdminReceiver" ]
  }, {
    "name" : "public void acknowledgeDeviceCompliant()",
    "returnType" : "void",
    "comment" : "\n     * Called by a profile owner of an organization-owned managed profile to acknowledge that the\n     * device is compliant and the user can turn the profile off if needed according to the maximum\n     * time off policy.\n     *\n     * This method should be called when the device is deemed compliant after getting\n     * {@link DeviceAdminReceiver#onComplianceAcknowledgementRequired(Context, Intent)} callback in\n     * case it is overridden. Before this method is called the user is still free to turn the\n     * profile off, but the timer won't be reset, so personal apps will be suspended sooner.\n     *\n     * DPCs only need acknowledging device compliance if they override\n     * {@link DeviceAdminReceiver#onComplianceAcknowledgementRequired(Context, Intent)}, otherwise\n     * compliance is acknowledged automatically.\n     *\n     * @throws IllegalStateException if the user isn't unlocked\n     * @see #isComplianceAcknowledgementRequired()\n     * @see #setManagedProfileMaximumTimeOff(ComponentName, long)\n     * @see DeviceAdminReceiver#onComplianceAcknowledgementRequired(Context, Intent)\n     ",
    "links" : [ "android.app.admin.DeviceAdminReceiver#onComplianceAcknowledgementRequired(Context" ]
  }, {
    "name" : "public boolean isComplianceAcknowledgementRequired()",
    "returnType" : "boolean",
    "comment" : "\n     * Called by a profile owner of an organization-owned managed profile to query whether it needs\n     * to acknowledge device compliance to allow the user to turn the profile off if needed\n     * according to the maximum profile time off policy.\n     *\n     * Normally when acknowledgement is needed the DPC gets a\n     * {@link DeviceAdminReceiver#onComplianceAcknowledgementRequired(Context, Intent)} callback.\n     * But if the callback was not delivered or handled for some reason, this method can be used to\n     * verify if acknowledgement is needed.\n     *\n     * @throws IllegalStateException if the user isn't unlocked\n     * @see #acknowledgeDeviceCompliant()\n     * @see #setManagedProfileMaximumTimeOff(ComponentName, long)\n     * @see DeviceAdminReceiver#onComplianceAcknowledgementRequired(Context, Intent)\n     ",
    "links" : [ "android.app.admin.DeviceAdminReceiver#onComplianceAcknowledgementRequired(Context" ]
  }, {
    "name" : "public boolean canProfileOwnerResetPasswordWhenLocked(int userId)",
    "returnType" : "boolean",
    "comment" : "\n     * Returns {@code true} when {@code userId} has a profile owner that is capable of resetting\n     * password in RUNNING_LOCKED state. For that it should have at least one direct boot aware\n     * component and have an active password reset token. Can only be called by the system.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public void setNextOperationSafety(@DevicePolicyOperation int operation, @OperationSafetyReason int reason)",
    "returnType" : "void",
    "comment" : "\n     * Used by CTS to set the result of the next safety operation check.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public String getEnrollmentSpecificId()",
    "returnType" : "String",
    "comment" : "\n     * Returns an enrollment-specific identifier of this device, which is guaranteed to be the same\n     * value for the same device, enrolled into the same organization by the same managing app.\n     * This identifier is high-entropy, useful for uniquely identifying individual devices within\n     * the same organisation.\n     * It is available both in a work profile and on a fully-managed device.\n     * The identifier would be consistent even if the work profile is removed and enrolled again\n     * (to the same organization), or the device is factory reset and re-enrolled.\n     *\n     * Can only be called by the Profile Owner and Device Owner, and starting from Android\n     * {@link android.os.Build.VERSION_CODES#VANILLA_ICE_CREAM}, holders of the permission\n     * {@link android.Manifest.permission#MANAGE_DEVICE_POLICY_CERTIFICATES}.\n     * If {@link #setOrganizationId(String)} was not called, then the returned value will be an\n     * empty string.\n     *\n     * <p>Note about access to device identifiers: a device owner, a profile owner of an\n     * organization-owned device or the delegated certificate installer (holding the\n     * {@link #DELEGATION_CERT_INSTALL} delegation) on such a device can still obtain hardware\n     * identifiers by calling e.g. {@link android.os.Build#getSerial()}, in addition to using\n     * this method. However, a profile owner on a personal (non organization-owned) device, or the\n     * delegated certificate installer on such a device, cannot obtain hardware identifiers anymore\n     * and must switch to using this method.\n     *\n     * @return A stable, enrollment-specific identifier.\n     * @throws SecurityException if the caller is not a profile owner, device owner or holding the\n     * {@link android.Manifest.permission#MANAGE_DEVICE_POLICY_CERTIFICATES} permission\n     ",
    "links" : [ "#DELEGATION_CERT_INSTALL", "android.Manifest.permission#MANAGE_DEVICE_POLICY_CERTIFICATES", "android.os.Build.VERSION_CODES#VANILLA_ICE_CREAM", "android.os.Build#getSerial()", "#setOrganizationId(String)" ]
  }, {
    "name" : "public void setOrganizationId(@NonNull String enterpriseId)",
    "returnType" : "void",
    "comment" : "\n     * Sets the Enterprise ID for the work profile or managed device. This is a requirement for\n     * generating an enrollment-specific ID for the device, see {@link #getEnrollmentSpecificId()}.\n     *\n     * It is recommended that the Enterprise ID is at least 6 characters long, and no more than\n     * 64 characters.\n     *\n     * @param enterpriseId An identifier of the organization this work profile or device is\n     *                     enrolled into.\n     ",
    "links" : [ "#getEnrollmentSpecificId()" ]
  }, {
    "name" : "public void setOrganizationIdForUser(@NonNull String packageName, @NonNull String enterpriseId, @UserIdInt int userId)",
    "returnType" : "void",
    "comment" : "\n     * Sets the Enterprise ID for the work profile or managed device. This is a requirement for\n     * generating an enrollment-specific ID for the device, see\n     * {@link #getEnrollmentSpecificId()}.\n     *\n     * @hide\n     ",
    "links" : [ "#getEnrollmentSpecificId()" ]
  }, {
    "name" : "public void clearOrganizationId()",
    "returnType" : "void",
    "comment" : "\n     * Clears organization ID set by the DPC and resets the precomputed enrollment specific ID.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public UserHandle createAndProvisionManagedProfile(@NonNull ManagedProfileProvisioningParams provisioningParams) throws ProvisioningException",
    "returnType" : "UserHandle",
    "comment" : "\n     * Creates and provisions a managed profile and sets the\n     * {@link ManagedProfileProvisioningParams#getProfileAdminComponentName()} as the profile\n     * owner.\n     *\n     * <p>The method {@link #checkProvisioningPrecondition} must be returning {@link #STATUS_OK}\n     * before calling this method.\n     *\n     * @param provisioningParams Params required to provision a managed profile,\n     * see {@link ManagedProfileProvisioningParams}.\n     * @return The {@link UserHandle} of the created profile or {@code null} if the service is\n     * not available.\n     * @throws SecurityException if the caller does not hold\n     * {@link android.Manifest.permission#MANAGE_PROFILE_AND_DEVICE_OWNERS}.\n     * @throws ProvisioningException if an error occurred during provisioning.\n     * @hide\n     ",
    "links" : [ "#checkProvisioningPrecondition", "android.app.admin.ManagedProfileProvisioningParams#getProfileAdminComponentName()", "android.os.UserHandle", "android.Manifest.permission#MANAGE_PROFILE_AND_DEVICE_OWNERS", "#STATUS_OK", "android.app.admin.ManagedProfileProvisioningParams" ]
  }, {
    "name" : "public void finalizeWorkProfileProvisioning(@NonNull UserHandle managedProfileUser, @Nullable Account migratedAccount)",
    "returnType" : "void",
    "comment" : "\n     * Called when a managed profile has been provisioned.\n     *\n     * @throws SecurityException if the caller does not hold\n     * {@link android.Manifest.permission#MANAGE_PROFILE_AND_DEVICE_OWNERS}.\n     * @hide\n     ",
    "links" : [ "android.Manifest.permission#MANAGE_PROFILE_AND_DEVICE_OWNERS" ]
  }, {
    "name" : "private String getErrorMessage(ServiceSpecificException e)",
    "returnType" : "String",
    "comment" : "\n     * The localized error message to show to the end-user. If {@code null}, a generic error\n     * message will be shown.\n     ",
    "links" : [ ]
  }, {
    "name" : "public void provisionFullyManagedDevice(@NonNull FullyManagedDeviceProvisioningParams provisioningParams) throws ProvisioningException",
    "returnType" : "void",
    "comment" : "\n     * Provisions a managed device and sets the {@code deviceAdminComponentName} as the device\n     * owner.\n     *\n     * <p>The method {@link #checkProvisioningPrecondition} must be returning {@link #STATUS_OK}\n     * before calling this method.\n     *\n     * <p>Holders of {@link android.Manifest.permission#PROVISION_DEMO_DEVICE} can call this API\n     * only if {@link FullyManagedDeviceProvisioningParams#isDemoDevice()} is {@code true}.\n     *\n     * <p>If headless device is in {@link DeviceAdminInfo#HEADLESS_DEVICE_OWNER_MODE_SINGLE_USER}\n     * mode then it sets the device owner on the first secondary user.</p>\n     *\n     * @param provisioningParams Params required to provision a fully managed device,\n     * see {@link FullyManagedDeviceProvisioningParams}.\n     *\n     * @throws ProvisioningException if an error occurred during provisioning.\n     *\n     * @hide\n     ",
    "links" : [ "android.app.admin.DeviceAdminInfo#HEADLESS_DEVICE_OWNER_MODE_SINGLE_USER", "#checkProvisioningPrecondition", "android.app.admin.FullyManagedDeviceProvisioningParams#isDemoDevice()", "android.app.admin.FullyManagedDeviceProvisioningParams", "#STATUS_OK", "android.Manifest.permission#PROVISION_DEMO_DEVICE" ]
  }, {
    "name" : "public void resetDefaultCrossProfileIntentFilters(@UserIdInt int userId)",
    "returnType" : "void",
    "comment" : "\n     * Resets the default cross profile intent filters that were set during\n     * {@link #createAndProvisionManagedProfile} between {@code userId} and all it's managed\n     * profiles if any.\n     *\n     * @hide\n     ",
    "links" : [ "#createAndProvisionManagedProfile" ]
  }, {
    "name" : "public boolean canAdminGrantSensorsPermissions()",
    "returnType" : "boolean",
    "comment" : "\n     * Returns true if the caller is running on a device where an admin can grant\n     * permissions related to device sensors.\n     * This is a signal that the device is a fully-managed device where personal usage is\n     * discouraged.\n     * The list of permissions is listed in\n     * {@link #setPermissionGrantState(ComponentName, String, String, int)}.\n     *\n     * May be called by any app.\n     * @return true if an admin can grant device sensors-related permissions, false otherwise.\n     ",
    "links" : [ "#setPermissionGrantState(ComponentName" ]
  }, {
    "name" : "public void setDeviceOwnerType(@NonNull ComponentName admin, @DeviceOwnerType int deviceOwnerType)",
    "returnType" : "void",
    "comment" : "\n     * Sets the device owner type for a managed device (e.g. financed device).\n     *\n     * @param admin The {@link DeviceAdminReceiver} that is the device owner.\n     * @param deviceOwnerType The device owner type is set to. Use\n     * {@link #DEVICE_OWNER_TYPE_DEFAULT} for the default device owner type. Use\n     * {@link #DEVICE_OWNER_TYPE_FINANCED} for the financed device owner type.\n     *\n     * @throws IllegalStateException When admin is not the device owner, or there is no device\n     *     owner, or attempting to set the device owner type again for the same admin.\n     * @throws SecurityException If the caller does not have the permission\n     *     {@link permission#MANAGE_PROFILE_AND_DEVICE_OWNERS}.\n     *\n     * @hide\n     ",
    "links" : [ "#DEVICE_OWNER_TYPE_FINANCED", "android.app.admin.DeviceAdminReceiver", "android.Manifest.permission#MANAGE_PROFILE_AND_DEVICE_OWNERS", "#DEVICE_OWNER_TYPE_DEFAULT" ]
  }, {
    "name" : "public int getDeviceOwnerType(@NonNull ComponentName admin)",
    "returnType" : "int",
    "comment" : "\n     * Returns the device owner type for the admin used in\n     * {@link #setDeviceOwnerType(ComponentName, int)}. {@link #DEVICE_OWNER_TYPE_DEFAULT}\n     * would be returned when the device owner type is not set for the device owner admin.\n     *\n     * @param admin The {@link DeviceAdminReceiver} that is the device owner.\n     *\n     * @throws IllegalStateException When admin is not the device owner or there is no device owner.\n     *\n     * @deprecated Use type-specific APIs (e.g. {@link #isFinancedDevice}).\n     * @hide\n     ",
    "links" : [ "#setDeviceOwnerType(ComponentName", "android.app.admin.DeviceAdminReceiver", "#isFinancedDevice", "#DEVICE_OWNER_TYPE_DEFAULT" ]
  }, {
    "name" : "public boolean isFinancedDevice()",
    "returnType" : "boolean",
    "comment" : "\n     * {@code true} if this device is financed.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public void setUsbDataSignalingEnabled(boolean enabled)",
    "returnType" : "void",
    "comment" : "\n     * Called by a device owner or profile owner of an organization-owned managed profile to enable\n     * or disable USB data signaling for the device. When disabled, USB data connections\n     * (except from charging functions) are prohibited.\n     *\n     * <p> This API is not supported on all devices, the caller should call\n     * {@link #canUsbDataSignalingBeDisabled()} to check whether enabling or disabling USB data\n     * signaling is supported on the device.\n     *\n     * Starting from Android 15, after the USB data signaling\n     * policy has been set, {@link PolicyUpdateReceiver#onPolicySetResult(Context, String,\n     * Bundle, TargetUser, PolicyUpdateResult)} will notify the admin on whether the policy was\n     * successfully set or not. This callback will contain:\n     * <ul>\n     * <li> The {@link TargetUser} that this policy relates to\n     * <li> The {@link PolicyUpdateResult}, which will be\n     * {@link PolicyUpdateResult#RESULT_POLICY_SET} if the policy was successfully set or the\n     * reason the policy failed to be set\n     * e.g. {@link PolicyUpdateResult#RESULT_FAILURE_CONFLICTING_ADMIN_POLICY})\n     * </ul>\n     * If there has been a change to the policy,\n     * {@link PolicyUpdateReceiver#onPolicyChanged(Context, String, Bundle, TargetUser,\n     * PolicyUpdateResult)} will notify the admin of this change. This callback will contain the\n     * same parameters as PolicyUpdateReceiver#onPolicySetResult and the {@link PolicyUpdateResult}\n     * will contain the reason why the policy changed.\n     *\n     * @param enabled whether USB data signaling should be enabled or not.\n     * @throws SecurityException if the caller is not permitted to set this policy\n     * @throws IllegalStateException if disabling USB data signaling is not supported or\n     * if USB data signaling fails to be enabled/disabled.\n     ",
    "links" : [ "android.app.admin.PolicyUpdateResult#RESULT_FAILURE_CONFLICTING_ADMIN_POLICY", "android.app.admin.PolicyUpdateResult", "android.app.admin.PolicyUpdateResult#RESULT_POLICY_SET", "#canUsbDataSignalingBeDisabled()", "android.app.admin.PolicyUpdateReceiver#onPolicyChanged(Context", "android.app.admin.PolicyUpdateReceiver#onPolicySetResult(Context", "android.app.admin.TargetUser" ]
  }, {
    "name" : "public boolean isUsbDataSignalingEnabled()",
    "returnType" : "boolean",
    "comment" : "\n     * Returns whether USB data signaling is currently enabled.\n     *\n     * <p> When called by a device owner or profile owner of an organization-owned managed profile,\n     * this API returns whether USB data signaling is currently enabled by that admin. When called\n     * by any other app, returns whether USB data signaling is currently enabled on the device.\n     *\n     * @return {@code true} if USB data signaling is enabled, {@code false} otherwise.\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean canUsbDataSignalingBeDisabled()",
    "returnType" : "boolean",
    "comment" : "\n     * Returns whether enabling or disabling USB data signaling is supported on the device.\n     *\n     * @return {@code true} if the device supports enabling and disabling USB data signaling.\n     ",
    "links" : [ ]
  }, {
    "name" : "public List<UserHandle> listForegroundAffiliatedUsers()",
    "returnType" : "List<UserHandle>",
    "comment" : "\n     * Gets the list of {@link #isAffiliatedUser() affiliated} users running on foreground.\n     *\n     * @return list of {@link #isAffiliatedUser() affiliated} users running on foreground.\n     *\n     * @throws SecurityException if the calling application is not a device owner\n     ",
    "links" : [ "#isAffiliatedUser()" ]
  }, {
    "name" : "public Set<String> getPolicyExemptApps()",
    "returnType" : "Set<String>",
    "comment" : "\n     * Lists apps that are exempt from policies (such as\n     * {@link #setPackagesSuspended(ComponentName, String[], boolean)}).\n     *\n     * @hide\n     ",
    "links" : [ "#setPackagesSuspended(ComponentName" ]
  }, {
    "name" : "public Intent createProvisioningIntentFromNfcIntent(@NonNull Intent nfcIntent)",
    "returnType" : "Intent",
    "comment" : "\n     * Creates a {@link #ACTION_PROVISION_MANAGED_DEVICE_FROM_TRUSTED_SOURCE} intent\n     * from the provided {@code nfcIntent}.\n     *\n     * <p>Prerequisites to create the provisioning intent:\n     *\n     * <ul>\n     * <li>{@code nfcIntent}'s action is {@link NfcAdapter#ACTION_NDEF_DISCOVERED}</li>\n     * <li>{@code nfcIntent}'s NFC properties contain either\n     * {@link #EXTRA_PROVISIONING_DEVICE_ADMIN_PACKAGE_NAME} or\n     * {@link #EXTRA_PROVISIONING_DEVICE_ADMIN_COMPONENT_NAME} </li>\n     * </ul>\n     *\n     * This method returns {@code null} if the prerequisites are not met or if an error occurs\n     * when reading the NFC properties.\n     *\n     * @param nfcIntent the nfc intent generated from scanning a NFC tag\n     * @return a {@link #ACTION_PROVISION_MANAGED_DEVICE_FROM_TRUSTED_SOURCE} intent with\n     * intent extras as read by {@code nfcIntent}'s NFC properties or {@code null} if the\n     * prerequisites are not met or if an error occurs when reading the NFC properties.\n     *\n     * @hide\n     ",
    "links" : [ "#ACTION_PROVISION_MANAGED_DEVICE_FROM_TRUSTED_SOURCE", "#EXTRA_PROVISIONING_DEVICE_ADMIN_PACKAGE_NAME", "android.nfc.NfcAdapter#ACTION_NDEF_DISCOVERED", "#EXTRA_PROVISIONING_DEVICE_ADMIN_COMPONENT_NAME" ]
  }, {
    "name" : "public void setMinimumRequiredWifiSecurityLevel(@WifiSecurity int level)",
    "returnType" : "void",
    "comment" : "\n     * Called by device owner or profile owner of an organization-owned managed profile to\n     * specify the minimum security level required for Wi-Fi networks.\n     * The device may not connect to networks that do not meet the minimum security level.\n     * If the current network does not meet the minimum security level set, it will be disconnected.\n     *\n     * The following shows the Wi-Fi security levels from the lowest to the highest security level:\n     * {@link #WIFI_SECURITY_OPEN}\n     * {@link #WIFI_SECURITY_PERSONAL}\n     * {@link #WIFI_SECURITY_ENTERPRISE_EAP}\n     * {@link #WIFI_SECURITY_ENTERPRISE_192}\n     *\n     * @param level minimum security level\n     * @throws SecurityException if the caller is not permitted to set this policy\n     ",
    "links" : [ "#WIFI_SECURITY_ENTERPRISE_192", "#WIFI_SECURITY_OPEN", "#WIFI_SECURITY_PERSONAL", "#WIFI_SECURITY_ENTERPRISE_EAP" ]
  }, {
    "name" : "public int getMinimumRequiredWifiSecurityLevel()",
    "returnType" : "int",
    "comment" : "\n     * Returns the current Wi-Fi minimum security level.\n     *\n     * @see #setMinimumRequiredWifiSecurityLevel(int)\n     ",
    "links" : [ ]
  }, {
    "name" : "public void setWifiSsidPolicy(@Nullable WifiSsidPolicy policy)",
    "returnType" : "void",
    "comment" : "\n     * Called by device owner or profile owner of an organization-owned managed profile to\n     * specify the Wi-Fi SSID policy ({@link WifiSsidPolicy}).\n     * Wi-Fi SSID policy specifies the SSID restriction the network must satisfy\n     * in order to be eligible for a connection. Providing a null policy results in the\n     * deactivation of the SSID restriction\n     *\n     * @param policy Wi-Fi SSID policy\n     * @throws SecurityException if the caller is not permitted to manage wifi policy\n     ",
    "links" : [ "android.app.admin.WifiSsidPolicy" ]
  }, {
    "name" : "public WifiSsidPolicy getWifiSsidPolicy()",
    "returnType" : "WifiSsidPolicy",
    "comment" : "\n     * Returns the current Wi-Fi SSID policy.\n     * If the policy has not been set, it will return NULL.\n     *\n     * @see #setWifiSsidPolicy(WifiSsidPolicy)\n     * @throws SecurityException if the caller is not a device owner or a profile owner on\n     * an organization-owned managed profile.\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean isDevicePotentiallyStolen()",
    "returnType" : "boolean",
    "comment" : "\n     *\n     * Returns whether the device considers itself to be potentially stolen.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public DevicePolicyResourcesManager getResources()",
    "returnType" : "DevicePolicyResourcesManager",
    "comment" : "\n     * Returns a {@link DevicePolicyResourcesManager} containing the required APIs to set, reset,\n     * and get device policy related resources.\n     ",
    "links" : [ "android.app.admin.DevicePolicyResourcesManager" ]
  }, {
    "name" : "public boolean isDpcDownloaded()",
    "returnType" : "boolean",
    "comment" : "\n     * Returns a boolean for whether the DPC\n     * (Device Policy Controller, the agent responsible for enforcing policy)\n     * has been downloaded during provisioning.\n     *\n     * <p>If true is returned, then any attempts to begin setup again should result in factory reset\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public void setDpcDownloaded(boolean downloaded)",
    "returnType" : "void",
    "comment" : "\n     * Indicates that the DPC (Device Policy Controller, the agent responsible for enforcing policy)\n     * has or has not been downloaded during provisioning.\n     *\n     * @param downloaded {@code true} if the dpc has been downloaded during provisioning.\n     *                               {@code false} otherwise.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public String getDevicePolicyManagementRoleHolderPackage()",
    "returnType" : "String",
    "comment" : "\n     * Returns the package name of the device policy management role holder.\n     *\n     * <p>If the device policy management role holder is not configured for this device, returns\n     * {@code null}.\n     ",
    "links" : [ ]
  }, {
    "name" : "public String getDevicePolicyManagementRoleHolderUpdaterPackage()",
    "returnType" : "String",
    "comment" : "\n     * Returns the package name of the device policy management role holder updater.\n     *\n     * <p>If the device policy management role holder updater is not configured for this device,\n     * returns {@code null}.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public List<UserHandle> getPolicyManagedProfiles(@NonNull UserHandle user)",
    "returnType" : "List<UserHandle>",
    "comment" : "\n     * Returns a {@link List} of managed profiles managed by some profile owner within the profile\n     * group of the given user, or an empty {@link List} if there is not one.\n     *\n     * @param user the user whose profile group to look within to return managed profiles\n     *\n     * @hide\n     ",
    "links" : [ "java.util.ArrayList" ]
  }, {
    "name" : "private String extractPackageNameFromDeviceManagerConfig(@Nullable String deviceManagerConfig)",
    "returnType" : "String",
    "comment" : "\n     * Retrieves the package name for a given {@code deviceManagerConfig}.\n     *\n     * <p>Valid configs look like:\n     * <ul>\n     *     <li>{@code com.package.name}</li>\n     *     <li>{@code com.package.name:<SHA256 checksum>}</li>\n     * </ul>\n     *\n     * <p>If the supplied {@code deviceManagerConfig} is {@code null} or empty, returns\n     * {@code null}.\n     ",
    "links" : [ ]
  }, {
    "name" : "public void resetShouldAllowBypassingDevicePolicyManagementRoleQualificationState()",
    "returnType" : "void",
    "comment" : "\n     * Reset cache for {@link #shouldAllowBypassingDevicePolicyManagementRoleQualification}.\n     *\n     * @hide\n     ",
    "links" : [ "#shouldAllowBypassingDevicePolicyManagementRoleQualification" ]
  }, {
    "name" : "public void calculateHasIncompatibleAccounts()",
    "returnType" : "void",
    "comment" : "\n     * Recalculate the incompatible accounts cache.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean shouldAllowBypassingDevicePolicyManagementRoleQualification()",
    "returnType" : "boolean",
    "comment" : "\n     * @return {@code true} if bypassing the device policy management role qualification is allowed\n     * with the current state of the device.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public DevicePolicyState getDevicePolicyState()",
    "returnType" : "DevicePolicyState",
    "comment" : "\n     * Returns a {@link DevicePolicyState} object containing information about the current state\n     * of device policies (e.g. values set by different admins, info about the enforcing admins,\n     * resolved policy, etc).\n     *\n     * @hide\n     ",
    "links" : [ "android.app.admin.DevicePolicyState" ]
  }, {
    "name" : "public boolean triggerDevicePolicyEngineMigration(boolean forceMigration)",
    "returnType" : "boolean",
    "comment" : "\n     * Triggers the data migration of device policies for existing DPCs to the Device Policy Engine.\n     * If {@code forceMigration} is set to {@code true} it skips the prerequisite checks before\n     * triggering the migration.\n     *\n     * <p>Returns {@code true} if migration was completed successfully, {@code false} otherwise.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean isDeviceFinanced()",
    "returnType" : "boolean",
    "comment" : "\n     * Returns {@code true} if this device is marked as a financed device.\n     *\n     * <p>A financed device can be entered into lock task mode (see {@link #setLockTaskPackages})\n     * by the holder of the role {@code android.app.role.RoleManager#ROLE_FINANCED_DEVICE_KIOSK}.\n     * If this occurs, Device Owners and Profile Owners that have set lock task packages or\n     * features, or that attempt to set lock task packages or features, will receive a callback\n     * indicating that it could not be set. See {@link PolicyUpdateReceiver#onPolicyChanged} and\n     * {@link PolicyUpdateReceiver#onPolicySetResult}.\n     *\n     * <p>To be informed of changes to this status you can subscribe to the broadcast\n     * {@link #ACTION_DEVICE_FINANCING_STATE_CHANGED}.\n     *\n     * @throws SecurityException if the caller is not a device owner, profile owner of an\n     * organization-owned managed profile, profile owner on the primary user or holder of one of the\n     * following roles: {@code android.app.role.RoleManager.ROLE_DEVICE_POLICY_MANAGEMENT},\n     * {@code android.app.role.RoleManager.ROLE_SYSTEM_SUPERVISION}.\n     ",
    "links" : [ "#ACTION_DEVICE_FINANCING_STATE_CHANGED", "android.app.admin.PolicyUpdateReceiver#onPolicyChanged", "#setLockTaskPackages", "android.app.admin.PolicyUpdateReceiver#onPolicySetResult" ]
  }, {
    "name" : "public String getFinancedDeviceKioskRoleHolder()",
    "returnType" : "String",
    "comment" : "\n     * Returns the package name of the application holding the role:\n     * {@link android.app.role.RoleManager#ROLE_FINANCED_DEVICE_KIOSK}.\n     *\n     * @return the package name of the application holding the role or {@code null} if the role is\n     * not held by any applications.\n     * @hide\n     ",
    "links" : [ "android.app.role.RoleManager#ROLE_FINANCED_DEVICE_KIOSK" ]
  }, {
    "name" : "public boolean isOnboardingBugreportV2FlagEnabled()",
    "returnType" : "boolean",
    "comment" : "\n     * Returns true if the flag for the onboarding bugreport V2 is enabled.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public Set<Integer> getSubscriptionIds()",
    "returnType" : "Set<Integer>",
    "comment" : "\n     * Returns the subscription ids of all subscriptions which were downloaded by the calling\n     * admin.\n     *\n     * <p> This returns only the subscriptions which were downloaded by the calling admin via\n     *      {@link android.telephony.euicc.EuiccManager#downloadSubscription}.\n     *      If a subscription is returned by this method then in it subject to management controls\n     *      and cannot be removed by users.\n     *\n     * <p> Callable by device owners and profile owners.\n     *\n     * @throws SecurityException if the caller is not authorized to call this method.\n     * @return ids of all managed subscriptions currently downloaded by an admin on the device.\n     ",
    "links" : [ "android.telephony.euicc.EuiccManager#downloadSubscription" ]
  }, {
    "name" : "public void setMaxPolicyStorageLimit(int storageLimit)",
    "returnType" : "void",
    "comment" : "\n     * Controls the maximum storage size allowed for policies associated with an admin.\n     * Setting a limit of -1 effectively removes any storage restrictions.\n     *\n     * @param storageLimit Maximum storage allowed in bytes. Use -1 to disable limits.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public int getMaxPolicyStorageLimit()",
    "returnType" : "int",
    "comment" : "\n     * Retrieves the current maximum storage limit for policies associated with an admin.\n     *\n     * @return The maximum storage limit in bytes, or -1 if no limit is enforced.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public void forceSetMaxPolicyStorageLimit(int storageLimit)",
    "returnType" : "void",
    "comment" : "\n     * Force sets the maximum storage size allowed for policies associated with an admin regardless\n     * of the default value set in the system, unlike {@link #setMaxPolicyStorageLimit} which can\n     * only set it to a value higher than the default value set by the system.Setting a limit of -1\n     * effectively removes any storage restrictions.\n     *\n     * @param storageLimit Maximum storage allowed in bytes. Use -1 to disable limits.\n     *\n     * @hide\n     ",
    "links" : [ "#setMaxPolicyStorageLimit" ]
  }, {
    "name" : "public int getPolicySizeForAdmin(@NonNull EnforcingAdmin admin)",
    "returnType" : "int",
    "comment" : "\n     * Retrieves the size of the current policies set by the {@code admin}.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public int getHeadlessDeviceOwnerMode()",
    "returnType" : "int",
    "comment" : "\n     * @return The headless device owner mode for the current set DO, returns\n     * {@link DeviceAdminInfo#HEADLESS_DEVICE_OWNER_MODE_UNSUPPORTED} if no DO is set.\n     *\n     * @hide\n     ",
    "links" : [ "android.app.admin.DeviceAdminInfo#HEADLESS_DEVICE_OWNER_MODE_UNSUPPORTED" ]
  } ],
  "methodNames" : [ "private IDevicePolicyManager getService()", "private boolean isParentInstance()", "private Context getContext()", "protected int myUserId()", "public static String operationToString(@DevicePolicyOperation int operation)", "public void setMtePolicy(@MtePolicy int policy)", "public int getMtePolicy()", "public static boolean isMtePolicyEnforced()", "public void setContentProtectionPolicy(@Nullable ComponentName admin, @ContentProtectionPolicy int policy)", "public int getContentProtectionPolicy(@Nullable ComponentName admin)", "public static void invalidateBinderCaches()", "public static void disableLocalCaches()", "public static String operationSafetyReasonToString(@OperationSafetyReason int reason)", "public static boolean isValidOperationSafetyReason(@OperationSafetyReason int reason)", "public boolean isSafeOperation(@OperationSafetyReason int reason)", "public void acknowledgeNewUserDisclaimer()", "public boolean isNewUserDisclaimerAcknowledged()", "public boolean isAdminActive(@NonNull ComponentName admin)", "public boolean isAdminActiveAsUser(@NonNull ComponentName admin, int userId)", "public boolean isRemovingAdmin(@NonNull ComponentName admin, int userId)", "public List<ComponentName> getActiveAdmins()", "public List<ComponentName> getActiveAdminsAsUser(int userId)", "public boolean packageHasActiveAdmins(String packageName)", "public boolean packageHasActiveAdmins(String packageName, int userId)", "public void removeActiveAdmin(@NonNull ComponentName admin)", "public boolean hasGrantedPolicy(@NonNull ComponentName admin, int usesPolicy)", "public void setPasswordQuality(@NonNull ComponentName admin, int quality)", "public int getPasswordQuality(@Nullable ComponentName admin)", "public int getPasswordQuality(@Nullable ComponentName admin, int userHandle)", "public void setPasswordMinimumLength(@NonNull ComponentName admin, int length)", "public int getPasswordMinimumLength(@Nullable ComponentName admin)", "public int getPasswordMinimumLength(@Nullable ComponentName admin, int userHandle)", "public void setPasswordMinimumUpperCase(@NonNull ComponentName admin, int length)", "public int getPasswordMinimumUpperCase(@Nullable ComponentName admin)", "public int getPasswordMinimumUpperCase(@Nullable ComponentName admin, int userHandle)", "public void setPasswordMinimumLowerCase(@NonNull ComponentName admin, int length)", "public int getPasswordMinimumLowerCase(@Nullable ComponentName admin)", "public int getPasswordMinimumLowerCase(@Nullable ComponentName admin, int userHandle)", "public void setPasswordMinimumLetters(@NonNull ComponentName admin, int length)", "public int getPasswordMinimumLetters(@Nullable ComponentName admin)", "public int getPasswordMinimumLetters(@Nullable ComponentName admin, int userHandle)", "public void setPasswordMinimumNumeric(@NonNull ComponentName admin, int length)", "public int getPasswordMinimumNumeric(@Nullable ComponentName admin)", "public int getPasswordMinimumNumeric(@Nullable ComponentName admin, int userHandle)", "public void setPasswordMinimumSymbols(@NonNull ComponentName admin, int length)", "public int getPasswordMinimumSymbols(@Nullable ComponentName admin)", "public int getPasswordMinimumSymbols(@Nullable ComponentName admin, int userHandle)", "public void setPasswordMinimumNonLetter(@NonNull ComponentName admin, int length)", "public int getPasswordMinimumNonLetter(@Nullable ComponentName admin)", "public int getPasswordMinimumNonLetter(@Nullable ComponentName admin, int userHandle)", "public PasswordMetrics getPasswordMinimumMetrics(@UserIdInt int userHandle)", "public PasswordMetrics getPasswordMinimumMetrics(@UserIdInt int userHandle, boolean deviceWideOnly)", "public void setPasswordHistoryLength(@NonNull ComponentName admin, int length)", "public void setPasswordExpirationTimeout(@Nullable ComponentName admin, long timeout)", "public long getPasswordExpirationTimeout(@Nullable ComponentName admin)", "public long getPasswordExpiration(@Nullable ComponentName admin)", "public int getPasswordHistoryLength(@Nullable ComponentName admin)", "public int getPasswordHistoryLength(@Nullable ComponentName admin, int userHandle)", "public int getPasswordMaximumLength(int quality)", "public boolean isActivePasswordSufficient()", "public boolean isActivePasswordSufficientForDeviceRequirement()", "public int getPasswordComplexity()", "public void setRequiredPasswordComplexity(@PasswordComplexity int passwordComplexity)", "public int getRequiredPasswordComplexity()", "public int getAggregatedPasswordComplexityForUser(int userId)", "public int getAggregatedPasswordComplexityForUser(int userId, boolean deviceWideOnly)", "public boolean isUsingUnifiedPassword(@NonNull ComponentName admin)", "public boolean isPasswordSufficientAfterProfileUnification(int userHandle, int profileUser)", "public int getCurrentFailedPasswordAttempts()", "public int getCurrentFailedPasswordAttempts(int userHandle)", "public boolean getDoNotAskCredentialsOnBoot()", "public void setMaximumFailedPasswordsForWipe(@Nullable ComponentName admin, int num)", "public int getMaximumFailedPasswordsForWipe(@Nullable ComponentName admin)", "public int getMaximumFailedPasswordsForWipe(@Nullable ComponentName admin, int userHandle)", "public int getProfileWithMinimumFailedPasswordsForWipe(int userHandle)", "public boolean resetPassword(String password, int flags)", "public boolean setResetPasswordToken(@Nullable ComponentName admin, byte[] token)", "public boolean clearResetPasswordToken(@Nullable ComponentName admin)", "public boolean isResetPasswordTokenActive(@Nullable ComponentName admin)", "public boolean resetPasswordWithToken(@Nullable ComponentName admin, String password, byte[] token, int flags)", "public void setMaximumTimeToLock(@Nullable ComponentName admin, long timeMs)", "public long getMaximumTimeToLock(@Nullable ComponentName admin)", "public long getMaximumTimeToLock(@Nullable ComponentName admin, int userHandle)", "public void setRequiredStrongAuthTimeout(@Nullable ComponentName admin, long timeoutMs)", "public long getRequiredStrongAuthTimeout(@Nullable ComponentName admin)", "public long getRequiredStrongAuthTimeout(@Nullable ComponentName admin, @UserIdInt int userId)", "public void lockNow()", "public void lockNow(@LockNowFlag int flags)", "public void wipeData(int flags)", "public void wipeData(int flags, @NonNull CharSequence reason)", "public void wipeDevice(int flags)", "private void wipeDataInternal(int flags, @NonNull String wipeReasonForUser, boolean factoryReset)", "public void setFactoryResetProtectionPolicy(@Nullable ComponentName admin, @Nullable FactoryResetProtectionPolicy policy)", "public FactoryResetProtectionPolicy getFactoryResetProtectionPolicy(@Nullable ComponentName admin)", "public void sendLostModeLocationUpdate(@NonNull @CallbackExecutor Executor executor, @NonNull Consumer<Boolean> callback)", "private void executeCallback(AndroidFuture<Boolean> future, @CallbackExecutor @NonNull Executor executor, Consumer<Boolean> callback)", "public ComponentName setGlobalProxy(@NonNull ComponentName admin, Proxy proxySpec, List<String> exclusionList)", "public Pair<String, String> getProxyParameters(Proxy proxySpec, List<String> exclusionList)", "public void setRecommendedGlobalProxy(@NonNull ComponentName admin, @Nullable ProxyInfo proxyInfo)", "public ComponentName getGlobalProxyAdmin()", "public int setStorageEncryption(@NonNull ComponentName admin, boolean encrypt)", "public boolean getStorageEncryption(@Nullable ComponentName admin)", "public int getStorageEncryptionStatus()", "public int getStorageEncryptionStatus(int userHandle)", "public boolean approveCaCert(String alias, int userHandle, boolean approval)", "public boolean isCaCertApproved(String alias, int userHandle)", "public boolean installCaCert(@Nullable ComponentName admin, byte[] certBuffer)", "public void uninstallCaCert(@Nullable ComponentName admin, byte[] certBuffer)", "public List<byte[]> getInstalledCaCerts(@Nullable ComponentName admin)", "public void uninstallAllUserCaCerts(@Nullable ComponentName admin)", "public boolean hasCaCertInstalled(@Nullable ComponentName admin, byte[] certBuffer)", "public boolean installKeyPair(@Nullable ComponentName admin, @NonNull PrivateKey privKey, @NonNull Certificate cert, @NonNull String alias)", "public boolean installKeyPair(@Nullable ComponentName admin, @NonNull PrivateKey privKey, @NonNull Certificate[] certs, @NonNull String alias, boolean requestAccess)", "public boolean installKeyPair(@Nullable ComponentName admin, @NonNull PrivateKey privKey, @NonNull Certificate[] certs, @NonNull String alias, int flags)", "public boolean removeKeyPair(@Nullable ComponentName admin, @NonNull String alias)", "public boolean hasKeyPair(@NonNull String alias)", "public AttestedKeyPair generateKeyPair(@Nullable ComponentName admin, @NonNull String algorithm, @NonNull KeyGenParameterSpec keySpec, @AttestationIdType int idAttestationFlags)", "public boolean grantKeyPairToApp(@Nullable ComponentName admin, @NonNull String alias, @NonNull String packageName)", "public Map<Integer, Set<String>> getKeyPairGrants(@NonNull String alias)", "public boolean revokeKeyPairFromApp(@Nullable ComponentName admin, @NonNull String alias, @NonNull String packageName)", "public boolean grantKeyPairToWifiAuth(@NonNull String alias)", "public boolean revokeKeyPairFromWifiAuth(@NonNull String alias)", "public boolean isKeyPairGrantedToWifiAuth(@NonNull String alias)", "public boolean isDeviceIdAttestationSupported()", "public boolean isUniqueDeviceAttestationSupported()", "public boolean setKeyPairCertificate(@Nullable ComponentName admin, @NonNull String alias, @NonNull List<Certificate> certs, boolean isUserSelectable)", "private static String getCaCertAlias(byte[] certBuffer) throws CertificateException", "public void setCertInstallerPackage(@NonNull ComponentName admin, @Nullable String installerPackage) throws SecurityException", "public String getCertInstallerPackage(@NonNull ComponentName admin) throws SecurityException", "public void setDelegatedScopes(@NonNull ComponentName admin, @NonNull String delegatePackage, @NonNull List<String> scopes)", "public List<String> getDelegatedScopes(@Nullable ComponentName admin, @NonNull String delegatedPackage)", "public List<String> getDelegatePackages(@NonNull ComponentName admin, @NonNull String delegationScope)", "public void setAlwaysOnVpnPackage(@NonNull ComponentName admin, @Nullable String vpnPackage, boolean lockdownEnabled) throws NameNotFoundException", "public void setAlwaysOnVpnPackage(@NonNull ComponentName admin, @Nullable String vpnPackage, boolean lockdownEnabled, @Nullable Set<String> lockdownAllowlist) throws NameNotFoundException", "public boolean isAlwaysOnVpnLockdownEnabled(@NonNull ComponentName admin)", "public boolean isAlwaysOnVpnLockdownEnabled()", "public Set<String> getAlwaysOnVpnLockdownWhitelist(@NonNull ComponentName admin)", "public String getAlwaysOnVpnPackage(@NonNull ComponentName admin)", "public String getAlwaysOnVpnPackage()", "public void setCameraDisabled(@Nullable ComponentName admin, boolean disabled)", "public boolean getCameraDisabled(@Nullable ComponentName admin)", "public boolean getCameraDisabled(@Nullable ComponentName admin, int userHandle)", "public boolean requestBugreport(@NonNull ComponentName admin)", "public void setScreenCaptureDisabled(@Nullable ComponentName admin, boolean disabled)", "public boolean getScreenCaptureDisabled(@Nullable ComponentName admin)", "public boolean getScreenCaptureDisabled(@Nullable ComponentName admin, int userHandle)", "public void setNearbyNotificationStreamingPolicy(@NearbyStreamingPolicy int policy)", "public int getNearbyNotificationStreamingPolicy()", "public int getNearbyNotificationStreamingPolicy(int userId)", "public void setNearbyAppStreamingPolicy(@NearbyStreamingPolicy int policy)", "public int getNearbyAppStreamingPolicy()", "public int getNearbyAppStreamingPolicy(int userId)", "public void setAutoTimeRequired(@NonNull ComponentName admin, boolean required)", "public boolean getAutoTimeRequired()", "public void setAutoTimeEnabled(@Nullable ComponentName admin, boolean enabled)", "public boolean getAutoTimeEnabled(@Nullable ComponentName admin)", "public void setAutoTimeZoneEnabled(@Nullable ComponentName admin, boolean enabled)", "public boolean getAutoTimeZoneEnabled(@Nullable ComponentName admin)", "public void setForceEphemeralUsers(@NonNull ComponentName admin, boolean forceEphemeralUsers)", "public boolean getForceEphemeralUsers(@NonNull ComponentName admin)", "public void setKeyguardDisabledFeatures(@Nullable ComponentName admin, int which)", "public int getKeyguardDisabledFeatures(@Nullable ComponentName admin)", "public int getKeyguardDisabledFeatures(@Nullable ComponentName admin, int userHandle)", "public void setActiveAdmin(@NonNull ComponentName policyReceiver, boolean refreshing, int userHandle)", "public void setActiveAdmin(@NonNull ComponentName policyReceiver, boolean refreshing)", "public void getRemoveWarning(@Nullable ComponentName admin, RemoteCallback result)", "public void reportPasswordChanged(PasswordMetrics metrics, @UserIdInt int userId)", "public void reportFailedPasswordAttempt(int userHandle)", "public void reportSuccessfulPasswordAttempt(int userHandle)", "public void reportFailedBiometricAttempt(int userHandle)", "public void reportSuccessfulBiometricAttempt(int userHandle)", "public void reportKeyguardDismissed(int userHandle)", "public void reportKeyguardSecured(int userHandle)", "public boolean setDeviceOwner(@NonNull ComponentName who, @UserIdInt int userId)", "public boolean setDeviceOwnerOnly(@NonNull ComponentName who, @UserIdInt int userId)", "public boolean isDeviceOwnerApp(String packageName)", "public boolean isDeviceOwnerAppOnCallingUser(String packageName)", "public boolean isDeviceOwnerAppOnAnyUser(String packageName)", "public ComponentName getDeviceOwnerComponentOnCallingUser()", "public ComponentName getDeviceOwnerComponentOnAnyUser()", "private boolean isDeviceOwnerAppOnAnyUserInner(String packageName, boolean callingUserOnly)", "private boolean isDeviceOwnerAppOnContextUser(String packageName)", "private ComponentName getDeviceOwnerComponentInner(boolean callingUserOnly)", "public UserHandle getDeviceOwnerUser()", "public int getDeviceOwnerUserId()", "public void clearDeviceOwnerApp(String packageName)", "public String getDeviceOwner()", "public boolean isDeviceManaged()", "public String getDeviceOwnerNameOnAnyUser()", "public boolean setActiveProfileOwner(@NonNull ComponentName admin, String ownerName) throws IllegalArgumentException", "public void clearProfileOwner(@NonNull ComponentName admin)", "public boolean hasUserSetupCompleted()", "public boolean setProfileOwner(@NonNull ComponentName admin, int userHandle) throws IllegalArgumentException", "public void setDeviceOwnerLockScreenInfo(@NonNull ComponentName admin, CharSequence info)", "public CharSequence getDeviceOwnerLockScreenInfo()", "public String[] setPackagesSuspended(@Nullable ComponentName admin, @NonNull String[] packageNames, boolean suspended)", "public boolean isPackageSuspended(@Nullable ComponentName admin, String packageName) throws NameNotFoundException", "public void setProfileEnabled(@NonNull ComponentName admin)", "public void setProfileName(@NonNull ComponentName admin, String profileName)", "public boolean isProfileOwnerApp(String packageName)", "public ComponentName getProfileOwner() throws IllegalArgumentException", "public ComponentName getProfileOwnerAsUser(@NonNull UserHandle user)", "public ComponentName getProfileOwnerAsUser(final int userId)", "public ComponentName getProfileOwnerOrDeviceOwnerSupervisionComponent(@NonNull UserHandle user)", "public boolean isSupervisionComponent(@NonNull ComponentName who)", "public String getProfileOwnerName() throws IllegalArgumentException", "public String getProfileOwnerNameAsUser(int userId) throws IllegalArgumentException", "public boolean isOrganizationOwnedDeviceWithManagedProfile()", "public boolean hasDeviceIdentifierAccess(@NonNull String packageName, int pid, int uid)", "public void addPersistentPreferredActivity(@Nullable ComponentName admin, IntentFilter filter, @NonNull ComponentName activity)", "public void clearPackagePersistentPreferredActivities(@Nullable ComponentName admin, String packageName)", "public void setDefaultSmsApplication(@Nullable ComponentName admin, @NonNull String packageName)", "public void setDefaultDialerApplication(@NonNull String packageName)", "public void setApplicationRestrictionsManagingPackage(@NonNull ComponentName admin, @Nullable String packageName) throws NameNotFoundException", "public String getApplicationRestrictionsManagingPackage(@NonNull ComponentName admin)", "public boolean isCallerApplicationRestrictionsManagingPackage()", "public void setApplicationRestrictions(@Nullable ComponentName admin, String packageName, Bundle settings)", "public void setTrustAgentConfiguration(@Nullable ComponentName admin, @NonNull ComponentName target, PersistableBundle configuration)", "public List<PersistableBundle> getTrustAgentConfiguration(@Nullable ComponentName admin, @NonNull ComponentName agent)", "public List<PersistableBundle> getTrustAgentConfiguration(@Nullable ComponentName admin, @NonNull ComponentName agent, int userHandle)", "public void setCrossProfileCallerIdDisabled(@NonNull ComponentName admin, boolean disabled)", "public boolean getCrossProfileCallerIdDisabled(@NonNull ComponentName admin)", "public boolean getCrossProfileCallerIdDisabled(UserHandle userHandle)", "public void setCredentialManagerPolicy(@Nullable PackagePolicy policy)", "public PackagePolicy getCredentialManagerPolicy()", "public void setManagedProfileCallerIdAccessPolicy(@Nullable PackagePolicy policy)", "public PackagePolicy getManagedProfileCallerIdAccessPolicy()", "public boolean hasManagedProfileCallerIdAccess(@NonNull UserHandle userHandle, @NonNull String packageName)", "public void setManagedProfileContactsAccessPolicy(@Nullable PackagePolicy policy)", "public PackagePolicy getManagedProfileContactsAccessPolicy()", "public boolean hasManagedProfileContactsAccess(@NonNull UserHandle userHandle, @NonNull String packageName)", "public void setCrossProfileContactsSearchDisabled(@NonNull ComponentName admin, boolean disabled)", "public boolean getCrossProfileContactsSearchDisabled(@NonNull ComponentName admin)", "public boolean getCrossProfileContactsSearchDisabled(@NonNull UserHandle userHandle)", "public void startManagedQuickContact(String actualLookupKey, long actualContactId, boolean isContactIdIgnored, long directoryId, Intent originalIntent)", "public void startManagedQuickContact(String actualLookupKey, long actualContactId, Intent originalIntent)", "public void setBluetoothContactSharingDisabled(@NonNull ComponentName admin, boolean disabled)", "public boolean getBluetoothContactSharingDisabled(@NonNull ComponentName admin)", "public boolean getBluetoothContactSharingDisabled(@NonNull UserHandle userHandle)", "public void addCrossProfileIntentFilter(@Nullable ComponentName admin, IntentFilter filter, int flags)", "public void clearCrossProfileIntentFilters(@Nullable ComponentName admin)", "public boolean setPermittedAccessibilityServices(@NonNull ComponentName admin, List<String> packageNames)", "public List<String> getPermittedAccessibilityServices(@NonNull ComponentName admin)", "public boolean isAccessibilityServicePermittedByAdmin(@NonNull ComponentName admin, @NonNull String packageName, int userHandle)", "public List<String> getPermittedAccessibilityServices(int userId)", "public boolean setPermittedInputMethods(@Nullable ComponentName admin, List<String> packageNames)", "public List<String> getPermittedInputMethods(@Nullable ComponentName admin)", "public boolean isInputMethodPermittedByAdmin(@NonNull ComponentName admin, @NonNull String packageName, int userHandle)", "public List<String> getPermittedInputMethodsForCurrentUser()", "public List<String> getPermittedInputMethods()", "public boolean setPermittedCrossProfileNotificationListeners(@NonNull ComponentName admin, @Nullable List<String> packageList)", "public List<String> getPermittedCrossProfileNotificationListeners(@NonNull ComponentName admin)", "public boolean isNotificationListenerServicePermitted(@NonNull String packageName, @UserIdInt int userId)", "public List<String> getKeepUninstalledPackages(@Nullable ComponentName admin)", "public void setKeepUninstalledPackages(@Nullable ComponentName admin, @NonNull List<String> packageNames)", "public UserHandle createAndManageUser(@NonNull ComponentName admin, @NonNull String name, @NonNull ComponentName profileOwner, @Nullable PersistableBundle adminExtras, @CreateAndManageUserFlags int flags)", "public boolean removeUser(@NonNull ComponentName admin, @NonNull UserHandle userHandle)", "public boolean switchUser(@NonNull ComponentName admin, @Nullable UserHandle userHandle)", "public int startUserInBackground(@NonNull ComponentName admin, @NonNull UserHandle userHandle)", "public int stopUser(@NonNull ComponentName admin, @NonNull UserHandle userHandle)", "public int logoutUser(@NonNull ComponentName admin)", "public void setManagedSubscriptionsPolicy(@Nullable ManagedSubscriptionsPolicy policy)", "public ManagedSubscriptionsPolicy getManagedSubscriptionsPolicy()", "public int logoutUser()", "public UserHandle getLogoutUser()", "public List<UserHandle> getSecondaryUsers(@NonNull ComponentName admin)", "public boolean isEphemeralUser(@NonNull ComponentName admin)", "public Bundle getApplicationRestrictions(@Nullable ComponentName admin, String packageName)", "public void addUserRestriction(@NonNull ComponentName admin, @UserManager.UserRestrictionKey String key)", "public void addUserRestrictionGlobally(@NonNull @UserManager.UserRestrictionKey String key)", "public void clearUserRestriction(@NonNull ComponentName admin, @UserManager.UserRestrictionKey String key)", "public Bundle getUserRestrictions(@NonNull ComponentName admin)", "public Bundle getUserRestrictionsGlobally()", "public Intent createAdminSupportIntent(@NonNull String restriction)", "public Bundle getEnforcingAdminAndUserDetails(int userId, @Nullable String restriction)", "public Set<EnforcingAdmin> getEnforcingAdminsForRestriction(int userId, @NonNull String restriction)", "public boolean setApplicationHidden(@Nullable ComponentName admin, String packageName, boolean hidden)", "public boolean isApplicationHidden(@Nullable ComponentName admin, String packageName)", "public void enableSystemApp(@NonNull ComponentName admin, String packageName)", "public int enableSystemApp(@NonNull ComponentName admin, Intent intent)", "public boolean installExistingPackage(@NonNull ComponentName admin, String packageName)", "public void setAccountManagementDisabled(@Nullable ComponentName admin, String accountType, boolean disabled)", "public String[] getAccountTypesWithManagementDisabled()", "public String[] getAccountTypesWithManagementDisabledAsUser(int userId)", "public String[] getAccountTypesWithManagementDisabledAsUser(int userId, boolean parentInstance)", "public void setSecondaryLockscreenEnabled(@NonNull ComponentName admin, boolean enabled)", "public boolean isSecondaryLockscreenEnabled(@NonNull UserHandle userHandle)", "public void setLockTaskPackages(@Nullable ComponentName admin, @NonNull String[] packages) throws SecurityException", "public String[] getLockTaskPackages(@Nullable ComponentName admin)", "public boolean isLockTaskPermitted(String pkg)", "public void setLockTaskFeatures(@Nullable ComponentName admin, @LockTaskFeature int flags)", "public int getLockTaskFeatures(@Nullable ComponentName admin)", "public void setPreferentialNetworkServiceEnabled(boolean enabled)", "public boolean isPreferentialNetworkServiceEnabled()", "public void setPreferentialNetworkServiceConfigs(@NonNull List<PreferentialNetworkServiceConfig> preferentialNetworkServiceConfigs)", "public List<PreferentialNetworkServiceConfig> getPreferentialNetworkServiceConfigs()", "public void setGlobalSetting(@NonNull ComponentName admin, String setting, String value)", "public void setSystemSetting(@NonNull ComponentName admin, @NonNull @SystemSettingsWhitelist String setting, String value)", "public void setConfiguredNetworksLockdownState(@Nullable ComponentName admin, boolean lockdown)", "public boolean hasLockdownAdminConfiguredNetworks(@Nullable ComponentName admin)", "public boolean setTime(@Nullable ComponentName admin, long millis)", "public boolean setTimeZone(@Nullable ComponentName admin, String timeZone)", "public void setLocationEnabled(@NonNull ComponentName admin, boolean locationEnabled)", "public void setSecureSetting(@NonNull ComponentName admin, String setting, String value)", "public void setRestrictionsProvider(@NonNull ComponentName admin, @Nullable ComponentName provider)", "public void setMasterVolumeMuted(@NonNull ComponentName admin, boolean on)", "public boolean isMasterVolumeMuted(@NonNull ComponentName admin)", "public void setUninstallBlocked(@Nullable ComponentName admin, String packageName, boolean uninstallBlocked)", "public boolean isUninstallBlocked(@Nullable ComponentName admin, String packageName)", "public boolean addCrossProfileWidgetProvider(@Nullable ComponentName admin, String packageName)", "public boolean removeCrossProfileWidgetProvider(@Nullable ComponentName admin, String packageName)", "public List<String> getCrossProfileWidgetProviders(@Nullable ComponentName admin)", "public void setUserIcon(@NonNull ComponentName admin, Bitmap icon)", "public void setSystemUpdatePolicy(@NonNull ComponentName admin, SystemUpdatePolicy policy)", "public SystemUpdatePolicy getSystemUpdatePolicy()", "public void clearSystemUpdatePolicyFreezePeriodRecord()", "public boolean setKeyguardDisabled(@NonNull ComponentName admin, boolean disabled)", "public boolean setStatusBarDisabled(@Nullable ComponentName admin, boolean disabled)", "public boolean isStatusBarDisabled()", "public void notifyPendingSystemUpdate(long updateReceivedTime)", "public void notifyPendingSystemUpdate(long updateReceivedTime, boolean isSecurityPatch)", "public SystemUpdateInfo getPendingSystemUpdate(@Nullable ComponentName admin)", "public void setPermissionPolicy(@NonNull ComponentName admin, int policy)", "public int getPermissionPolicy(ComponentName admin)", "public boolean setPermissionGrantState(@Nullable ComponentName admin, @NonNull String packageName, @NonNull String permission, @PermissionGrantState int grantState)", "public int getPermissionGrantState(@Nullable ComponentName admin, @NonNull String packageName, @NonNull String permission)", "public boolean isProvisioningAllowed(@NonNull String action)", "public int checkProvisioningPrecondition(@NonNull String action, @NonNull String packageName)", "public boolean isManagedProfile(@NonNull ComponentName admin)", "public String getWifiMacAddress(@Nullable ComponentName admin)", "public void reboot(@NonNull ComponentName admin)", "public void setShortSupportMessage(@Nullable ComponentName admin, @Nullable CharSequence message)", "public CharSequence getShortSupportMessage(@Nullable ComponentName admin)", "public void setLongSupportMessage(@NonNull ComponentName admin, @Nullable CharSequence message)", "public CharSequence getLongSupportMessage(@NonNull ComponentName admin)", "public CharSequence getShortSupportMessageForUser(@NonNull ComponentName admin, int userHandle)", "public CharSequence getLongSupportMessageForUser(@NonNull ComponentName admin, int userHandle)", "public DevicePolicyManager getParentProfileInstance(@NonNull ComponentName admin)", "public void setSecurityLoggingEnabled(@Nullable ComponentName admin, boolean enabled)", "public boolean isSecurityLoggingEnabled(@Nullable ComponentName admin)", "public void setAuditLogEnabled(boolean enabled)", "public boolean isAuditLogEnabled()", "public void setAuditLogEventCallback(@NonNull @CallbackExecutor Executor executor, @NonNull Consumer<List<SecurityEvent>> callback)", "public void clearAuditLogEventCallback()", "public List<SecurityEvent> retrieveSecurityLogs(@Nullable ComponentName admin)", "public long forceNetworkLogs()", "public long forceSecurityLogs()", "public DevicePolicyManager getParentProfileInstance(UserInfo uInfo)", "public List<String> setMeteredDataDisabledPackages(@NonNull ComponentName admin, @NonNull List<String> packageNames)", "public List<String> getMeteredDataDisabledPackages(@NonNull ComponentName admin)", "public boolean isMeteredDataDisabledPackageForUser(@NonNull ComponentName admin, String packageName, @UserIdInt int userId)", "public List<SecurityEvent> retrievePreRebootSecurityLogs(@Nullable ComponentName admin)", "public void setOrganizationColor(@NonNull ComponentName admin, int color)", "public void setOrganizationColorForUser(@ColorInt int color, @UserIdInt int userId)", "public int getOrganizationColor(@NonNull ComponentName admin)", "public int getOrganizationColorForUser(int userHandle)", "public void setOrganizationName(@Nullable ComponentName admin, @Nullable CharSequence title)", "public CharSequence getOrganizationName(@Nullable ComponentName admin)", "public CharSequence getDeviceOwnerOrganizationName()", "public CharSequence getOrganizationNameForUser(int userHandle)", "public int getUserProvisioningState()", "public void setUserProvisioningState(@UserProvisioningState int state, int userHandle)", "public void setUserProvisioningState(@UserProvisioningState int state, @NonNull UserHandle userHandle)", "public void setAffiliationIds(@NonNull ComponentName admin, @NonNull Set<String> ids)", "public Set<String> getAffiliationIds(@NonNull ComponentName admin)", "public boolean isAffiliatedUser()", "public boolean isAffiliatedUser(@UserIdInt int userId)", "public boolean isUninstallInQueue(String packageName)", "public void uninstallPackageWithActiveAdmins(String packageName)", "public void forceRemoveActiveAdmin(@NonNull ComponentName adminReceiver, @UserIdInt int userHandle)", "public boolean isDeviceProvisioned()", "public void setDeviceProvisioningConfigApplied()", "public boolean isDeviceProvisioningConfigApplied()", "public void forceUpdateUserSetupComplete(@UserIdInt int userId)", "private void throwIfParentInstance(String functionName)", "public void setBackupServiceEnabled(@NonNull ComponentName admin, boolean enabled)", "public boolean isBackupServiceEnabled(@NonNull ComponentName admin)", "public void setNetworkLoggingEnabled(@Nullable ComponentName admin, boolean enabled)", "public boolean isNetworkLoggingEnabled(@Nullable ComponentName admin)", "public List<NetworkEvent> retrieveNetworkLogs(@Nullable ComponentName admin, long batchToken)", "public boolean bindDeviceAdminServiceAsUser(@NonNull ComponentName admin, @NonNull Intent serviceIntent, @NonNull ServiceConnection conn, @Context.BindServiceFlagsBits int flags, @NonNull UserHandle targetUser)", "public boolean bindDeviceAdminServiceAsUser(@NonNull ComponentName admin, @NonNull Intent serviceIntent, @NonNull ServiceConnection conn, @NonNull Context.BindServiceFlags flags, @NonNull UserHandle targetUser)", "public List<UserHandle> getBindDeviceAdminTargetUsers(@NonNull ComponentName admin)", "public long getLastSecurityLogRetrievalTime()", "public long getLastBugReportRequestTime()", "public long getLastNetworkLogRetrievalTime()", "public boolean isCurrentInputMethodSetByOwner()", "public List<String> getOwnerInstalledCaCerts(@NonNull UserHandle user)", "public boolean isFactoryResetProtectionPolicySupported()", "public void clearApplicationUserData(@NonNull ComponentName admin, @NonNull String packageName, @NonNull @CallbackExecutor Executor executor, @NonNull OnClearApplicationUserDataListener listener)", "public void setLogoutEnabled(@NonNull ComponentName admin, boolean enabled)", "public boolean isLogoutEnabled()", "public Set<String> getDisallowedSystemApps(@NonNull ComponentName admin, @UserIdInt int userId, @NonNull String provisioningAction)", "public void transferOwnership(@NonNull ComponentName admin, @NonNull ComponentName target, @Nullable PersistableBundle bundle)", "public void setStartUserSessionMessage(@NonNull ComponentName admin, @Nullable CharSequence startUserSessionMessage)", "public void setEndUserSessionMessage(@NonNull ComponentName admin, @Nullable CharSequence endUserSessionMessage)", "public CharSequence getStartUserSessionMessage(@NonNull ComponentName admin)", "public CharSequence getEndUserSessionMessage(@NonNull ComponentName admin)", "public int addOverrideApn(@NonNull ComponentName admin, @NonNull ApnSetting apnSetting)", "public boolean updateOverrideApn(@NonNull ComponentName admin, int apnId, @NonNull ApnSetting apnSetting)", "public boolean removeOverrideApn(@NonNull ComponentName admin, int apnId)", "public List<ApnSetting> getOverrideApns(@NonNull ComponentName admin)", "public void setOverrideApnsEnabled(@NonNull ComponentName admin, boolean enabled)", "public boolean isOverrideApnEnabled(@NonNull ComponentName admin)", "public PersistableBundle getTransferOwnershipBundle()", "public int setGlobalPrivateDnsModeOpportunistic(@NonNull ComponentName admin)", "public int setGlobalPrivateDnsModeSpecifiedHost(@NonNull ComponentName admin, @NonNull String privateDnsHost)", "public void installSystemUpdate(@Nullable ComponentName admin, @NonNull Uri updateFilePath, @NonNull @CallbackExecutor Executor executor, @NonNull InstallSystemUpdateCallback callback)", "private void executeCallback(int errorCode, String errorMessage, @NonNull @CallbackExecutor Executor executor, @NonNull InstallSystemUpdateCallback callback)", "public int getGlobalPrivateDnsMode(@NonNull ComponentName admin)", "public String getGlobalPrivateDnsHost(@NonNull ComponentName admin)", "public void setProfileOwnerCanAccessDeviceIds(@NonNull ComponentName who)", "public void setProfileOwnerOnOrganizationOwnedDevice(@NonNull ComponentName who, boolean isProfileOwnerOnOrganizationOwnedDevice)", "public void setCrossProfileCalendarPackages(@NonNull ComponentName admin, @Nullable Set<String> packageNames)", "public Set<String> getCrossProfileCalendarPackages(@NonNull ComponentName admin)", "public boolean isPackageAllowedToAccessCalendar(@NonNull String packageName)", "public Set<String> getCrossProfileCalendarPackages()", "public void setCrossProfilePackages(@NonNull ComponentName admin, @NonNull Set<String> packageNames)", "public Set<String> getCrossProfilePackages(@NonNull ComponentName admin)", "public Set<String> getAllCrossProfilePackages()", "public Set<String> getDefaultCrossProfilePackages()", "public boolean isManagedKiosk()", "public boolean isUnattendedManagedKiosk()", "public boolean startViewCalendarEventInManagedProfile(long eventId, long start, long end, boolean allDay, int flags)", "public void setApplicationExemptions(@NonNull String packageName, @NonNull @ApplicationExemptionConstants Set<Integer> exemptions) throws NameNotFoundException", "public Set<Integer> getApplicationExemptions(@NonNull String packageName) throws NameNotFoundException", "private Set<Integer> intArrayToSet(int[] array)", "public void setUserControlDisabledPackages(@Nullable ComponentName admin, @NonNull List<String> packages)", "public List<String> getUserControlDisabledPackages(@Nullable ComponentName admin)", "public void setCommonCriteriaModeEnabled(@Nullable ComponentName admin, boolean enabled)", "public boolean isCommonCriteriaModeEnabled(@Nullable ComponentName admin)", "public int getPersonalAppsSuspendedReasons(@NonNull ComponentName admin)", "public void setPersonalAppsSuspended(@NonNull ComponentName admin, boolean suspended)", "public void setManagedProfileMaximumTimeOff(@NonNull ComponentName admin, long timeoutMillis)", "public long getManagedProfileMaximumTimeOff(@NonNull ComponentName admin)", "public void acknowledgeDeviceCompliant()", "public boolean isComplianceAcknowledgementRequired()", "public boolean canProfileOwnerResetPasswordWhenLocked(int userId)", "public void setNextOperationSafety(@DevicePolicyOperation int operation, @OperationSafetyReason int reason)", "public String getEnrollmentSpecificId()", "public void setOrganizationId(@NonNull String enterpriseId)", "public void setOrganizationIdForUser(@NonNull String packageName, @NonNull String enterpriseId, @UserIdInt int userId)", "public void clearOrganizationId()", "public UserHandle createAndProvisionManagedProfile(@NonNull ManagedProfileProvisioningParams provisioningParams) throws ProvisioningException", "public void finalizeWorkProfileProvisioning(@NonNull UserHandle managedProfileUser, @Nullable Account migratedAccount)", "private String getErrorMessage(ServiceSpecificException e)", "public void provisionFullyManagedDevice(@NonNull FullyManagedDeviceProvisioningParams provisioningParams) throws ProvisioningException", "public void resetDefaultCrossProfileIntentFilters(@UserIdInt int userId)", "public boolean canAdminGrantSensorsPermissions()", "public void setDeviceOwnerType(@NonNull ComponentName admin, @DeviceOwnerType int deviceOwnerType)", "public int getDeviceOwnerType(@NonNull ComponentName admin)", "public boolean isFinancedDevice()", "public void setUsbDataSignalingEnabled(boolean enabled)", "public boolean isUsbDataSignalingEnabled()", "public boolean canUsbDataSignalingBeDisabled()", "public List<UserHandle> listForegroundAffiliatedUsers()", "public Set<String> getPolicyExemptApps()", "public Intent createProvisioningIntentFromNfcIntent(@NonNull Intent nfcIntent)", "public void setMinimumRequiredWifiSecurityLevel(@WifiSecurity int level)", "public int getMinimumRequiredWifiSecurityLevel()", "public void setWifiSsidPolicy(@Nullable WifiSsidPolicy policy)", "public WifiSsidPolicy getWifiSsidPolicy()", "public boolean isDevicePotentiallyStolen()", "public DevicePolicyResourcesManager getResources()", "public boolean isDpcDownloaded()", "public void setDpcDownloaded(boolean downloaded)", "public String getDevicePolicyManagementRoleHolderPackage()", "public String getDevicePolicyManagementRoleHolderUpdaterPackage()", "public List<UserHandle> getPolicyManagedProfiles(@NonNull UserHandle user)", "private String extractPackageNameFromDeviceManagerConfig(@Nullable String deviceManagerConfig)", "public void resetShouldAllowBypassingDevicePolicyManagementRoleQualificationState()", "public void calculateHasIncompatibleAccounts()", "public boolean shouldAllowBypassingDevicePolicyManagementRoleQualification()", "public DevicePolicyState getDevicePolicyState()", "public boolean triggerDevicePolicyEngineMigration(boolean forceMigration)", "public boolean isDeviceFinanced()", "public String getFinancedDeviceKioskRoleHolder()", "public boolean isOnboardingBugreportV2FlagEnabled()", "public Set<Integer> getSubscriptionIds()", "public void setMaxPolicyStorageLimit(int storageLimit)", "public int getMaxPolicyStorageLimit()", "public void forceSetMaxPolicyStorageLimit(int storageLimit)", "public int getPolicySizeForAdmin(@NonNull EnforcingAdmin admin)", "public int getHeadlessDeviceOwnerMode()" ],
  "variableNames" : [ "DEPRECATE_USERMANAGERINTERNAL_DEVICEPOLICY_FLAG", "DEPRECATE_USERMANAGERINTERNAL_DEVICEPOLICY_DEFAULT", "ADD_ISFINANCED_DEVICE_FLAG", "ADD_ISFINANCED_FEVICE_DEFAULT", "TAG", "mContext", "mService", "mParentInstance", "mResourcesManager", "ACTION_PROVISION_MANAGED_PROFILE", "ACTION_PROVISION_MANAGED_USER", "ACTION_PROVISION_MANAGED_DEVICE", "ACTION_STATE_USER_SETUP_COMPLETE", "ACTION_PROVISION_MANAGED_DEVICE_FROM_TRUSTED_SOURCE", "ACTION_PROVISION_FINANCED_DEVICE", "ACTION_PROVISION_FINALIZATION", "ACTION_ROLE_HOLDER_PROVISION_MANAGED_PROFILE", "RESULT_WORK_PROFILE_CREATED", "RESULT_DEVICE_OWNER_SET", "ACTION_ROLE_HOLDER_PROVISION_MANAGED_DEVICE_FROM_TRUSTED_SOURCE", "ACTION_ROLE_HOLDER_PROVISION_FINALIZATION", "RESULT_UPDATE_ROLE_HOLDER", "EXTRA_ROLE_HOLDER_STATE", "EXTRA_FORCE_UPDATE_ROLE_HOLDER", "EXTRA_PROVISIONING_ALLOW_OFFLINE", "EXTRA_PROVISIONING_ROLE_HOLDER_PACKAGE_DOWNLOAD_LOCATION", "EXTRA_PROVISIONING_ROLE_HOLDER_SIGNATURE_CHECKSUM", "EXTRA_PROVISIONING_ROLE_HOLDER_PACKAGE_DOWNLOAD_COOKIE_HEADER", "EXTRA_PROVISIONING_ROLE_HOLDER_EXTRAS_BUNDLE", "EXTRA_ROLE_HOLDER_PROVISIONING_INITIATOR_PACKAGE", "EXTRA_RESULT_LAUNCH_INTENT", "EXTRA_PROVISIONING_SHOULD_LAUNCH_RESULT_INTENT", "ACTION_BUGREPORT_SHARING_ACCEPTED", "ACTION_BUGREPORT_SHARING_DECLINED", "ACTION_REMOTE_BUGREPORT_DISPATCH", "EXTRA_REMOTE_BUGREPORT_HASH", "EXTRA_REMOTE_BUGREPORT_NONCE", "EXTRA_BUGREPORT_NOTIFICATION_TYPE", "PREFERENTIAL_NETWORK_SERVICE_ENABLED_DEFAULT", "NOTIFICATION_BUGREPORT_STARTED", "NOTIFICATION_BUGREPORT_ACCEPTED_NOT_FINISHED", "NOTIFICATION_BUGREPORT_FINISHED_NOT_ACCEPTED", "DEFAULT_STRONG_AUTH_TIMEOUT_MS", "EXTRA_PROVISIONING_ADMIN_EXTRAS_BUNDLE", "EXTRA_PROVISIONING_DEVICE_ADMIN_PACKAGE_NAME", "EXTRA_PROVISIONING_DEVICE_ADMIN_COMPONENT_NAME", "EXTRA_PROVISIONING_ACCOUNT_TO_MIGRATE", "EXTRA_PROVISIONING_KEEP_ACCOUNT_ON_MIGRATION", "EXTRA_PROVISIONING_EMAIL_ADDRESS", "EXTRA_PROVISIONING_MAIN_COLOR", "EXTRA_PROVISIONING_LEAVE_ALL_SYSTEM_APPS_ENABLED", "EXTRA_PROVISIONING_TIME_ZONE", "EXTRA_PROVISIONING_LOCAL_TIME", "EXTRA_PROVISIONING_LOCALE", "EXTRA_PROVISIONING_WIFI_SSID", "EXTRA_PROVISIONING_WIFI_HIDDEN", "EXTRA_PROVISIONING_WIFI_SECURITY_TYPE", "EXTRA_PROVISIONING_WIFI_PASSWORD", "EXTRA_PROVISIONING_WIFI_EAP_METHOD", "EXTRA_PROVISIONING_WIFI_PHASE2_AUTH", "EXTRA_PROVISIONING_WIFI_CA_CERTIFICATE", "EXTRA_PROVISIONING_WIFI_USER_CERTIFICATE", "EXTRA_PROVISIONING_WIFI_IDENTITY", "EXTRA_PROVISIONING_WIFI_ANONYMOUS_IDENTITY", "EXTRA_PROVISIONING_WIFI_DOMAIN", "EXTRA_PROVISIONING_WIFI_PROXY_HOST", "EXTRA_PROVISIONING_WIFI_PROXY_PORT", "EXTRA_PROVISIONING_WIFI_PROXY_BYPASS", "EXTRA_PROVISIONING_WIFI_PAC_URL", "EXTRA_PROVISIONING_DEVICE_ADMIN_PACKAGE_DOWNLOAD_LOCATION", "EXTRA_PROVISIONING_ORGANIZATION_NAME", "EXTRA_PROVISIONING_SUPPORT_URL", "EXTRA_PROVISIONING_DEVICE_ADMIN_PACKAGE_LABEL", "EXTRA_PROVISIONING_DEVICE_ADMIN_PACKAGE_ICON_URI", "EXTRA_PROVISIONING_DEVICE_ADMIN_MINIMUM_VERSION_CODE", "EXTRA_PROVISIONING_DEVICE_ADMIN_PACKAGE_DOWNLOAD_COOKIE_HEADER", "EXTRA_PROVISIONING_DEVICE_ADMIN_PACKAGE_CHECKSUM", "EXTRA_PROVISIONING_SENSORS_PERMISSION_GRANT_OPT_OUT", "EXTRA_PROVISIONING_DEVICE_ADMIN_SIGNATURE_CHECKSUM", "ACTION_MANAGED_PROFILE_PROVISIONED", "ACTION_PROVISIONING_SUCCESSFUL", "EXTRA_PROVISIONING_SKIP_ENCRYPTION", "EXTRA_PROVISIONING_LOGO_URI", "EXTRA_PROVISIONING_DISCLAIMERS", "EXTRA_PROVISIONING_DISCLAIMER_HEADER", "EXTRA_PROVISIONING_DISCLAIMER_CONTENT", "EXTRA_PROVISIONING_SKIP_USER_CONSENT", "EXTRA_PROVISIONING_SKIP_EDUCATION_SCREENS", "EXTRA_PROVISIONING_USE_MOBILE_DATA", "EXTRA_PROVISIONING_TRIGGER", "PROVISIONING_TRIGGER_UNSPECIFIED", "PROVISIONING_TRIGGER_CLOUD_ENROLLMENT", "PROVISIONING_TRIGGER_QR_CODE", "PROVISIONING_TRIGGER_PERSISTENT_DEVICE_OWNER", "PROVISIONING_TRIGGER_MANAGED_ACCOUNT", "PROVISIONING_TRIGGER_NFC", "FLAG_SUPPORTED_MODES_ORGANIZATION_OWNED", "FLAG_SUPPORTED_MODES_PERSONALLY_OWNED", "FLAG_SUPPORTED_MODES_DEVICE_OWNER", "WIFI_SECURITY_OPEN", "WIFI_SECURITY_PERSONAL", "WIFI_SECURITY_ENTERPRISE_EAP", "WIFI_SECURITY_ENTERPRISE_192", "MIME_TYPE_PROVISIONING_NFC", "ACTION_ADD_DEVICE_ADMIN", "ACTION_SET_PROFILE_OWNER", "EXTRA_PROFILE_OWNER_NAME", "ACTION_DEVICE_POLICY_MANAGER_STATE_CHANGED", "ACTION_DEVICE_OWNER_CHANGED", "ACTION_RESET_PROTECTION_POLICY_CHANGED", "ACTION_LOST_MODE_LOCATION_UPDATE", "EXTRA_LOST_MODE_LOCATION", "EXTRA_DEVICE_ADMIN", "EXTRA_ADD_EXPLANATION", "POLICY_DISABLE_CAMERA", "POLICY_DISABLE_SCREEN_CAPTURE", "POLICY_SUSPEND_PACKAGES", "EXTRA_RESTRICTION", "ACTION_SET_NEW_PASSWORD", "EXTRA_PASSWORD_COMPLEXITY", "PASSWORD_COMPLEXITY_NONE", "PASSWORD_COMPLEXITY_LOW", "PASSWORD_COMPLEXITY_MEDIUM", "PASSWORD_COMPLEXITY_HIGH", "EXTRA_DEVICE_PASSWORD_REQUIREMENT_ONLY", "NEARBY_STREAMING_NOT_CONTROLLED_BY_POLICY", "NEARBY_STREAMING_DISABLED", "NEARBY_STREAMING_ENABLED", "NEARBY_STREAMING_SAME_MANAGED_ACCOUNT_ONLY", "ACTION_SET_NEW_PARENT_PROFILE_PASSWORD", "ACTION_SHOW_DEVICE_MONITORING_DIALOG", "ACTION_APPLICATION_DELEGATION_SCOPES_CHANGED", "EXTRA_DELEGATION_SCOPES", "FLAG_PARENT_CAN_ACCESS_MANAGED", "FLAG_MANAGED_CAN_ACCESS_PARENT", "ACTION_SYSTEM_UPDATE_POLICY_CHANGED", "ACTION_DATA_SHARING_RESTRICTION_APPLIED", "ACTION_DEVICE_POLICY_CONSTANTS_CHANGED", "PERMISSION_POLICY_PROMPT", "PERMISSION_POLICY_AUTO_GRANT", "PERMISSION_POLICY_AUTO_DENY", "PERMISSION_GRANT_STATE_DEFAULT", "PERMISSION_GRANT_STATE_GRANTED", "PERMISSION_GRANT_STATE_DENIED", "DELEGATION_CERT_INSTALL", "DELEGATION_APP_RESTRICTIONS", "DELEGATION_BLOCK_UNINSTALL", "DELEGATION_PERMISSION_GRANT", "DELEGATION_PACKAGE_ACCESS", "DELEGATION_ENABLE_SYSTEM_APP", "DELEGATION_INSTALL_EXISTING_PACKAGE", "DELEGATION_KEEP_UNINSTALLED_PACKAGES", "DELEGATION_NETWORK_LOGGING", "DELEGATION_CERT_SELECTION", "DELEGATION_SECURITY_LOGGING", "STATE_USER_UNMANAGED", "STATE_USER_SETUP_INCOMPLETE", "STATE_USER_SETUP_COMPLETE", "STATE_USER_SETUP_FINALIZED", "STATE_USER_PROFILE_COMPLETE", "STATE_USER_PROFILE_FINALIZED", "STATUS_UNKNOWN_ERROR", "STATUS_OK", "STATUS_HAS_DEVICE_OWNER", "STATUS_USER_HAS_PROFILE_OWNER", "STATUS_USER_NOT_RUNNING", "STATUS_USER_SETUP_COMPLETED", "STATUS_NONSYSTEM_USER_EXISTS", "STATUS_ACCOUNTS_NOT_EMPTY", "STATUS_NOT_SYSTEM_USER", "STATUS_HAS_PAIRED", "STATUS_MANAGED_USERS_NOT_SUPPORTED", "STATUS_SYSTEM_USER", "STATUS_CANNOT_ADD_MANAGED_PROFILE", "STATUS_DEVICE_ADMIN_NOT_SUPPORTED", "STATUS_SPLIT_SYSTEM_USER_DEVICE_SYSTEM_USER", "STATUS_PROVISIONING_NOT_ALLOWED_FOR_NON_DEVELOPER_USERS", "STATUS_HEADLESS_SYSTEM_USER_MODE_NOT_SUPPORTED", "STATUS_HEADLESS_ONLY_SYSTEM_USER", "LOCK_TASK_FEATURE_NONE", "LOCK_TASK_FEATURE_SYSTEM_INFO", "LOCK_TASK_FEATURE_NOTIFICATIONS", "LOCK_TASK_FEATURE_HOME", "LOCK_TASK_FEATURE_OVERVIEW", "LOCK_TASK_FEATURE_GLOBAL_ACTIONS", "LOCK_TASK_FEATURE_KEYGUARD", "LOCK_TASK_FEATURE_BLOCK_ACTIVITY_START_IN_TASK", "ACTION_DEVICE_ADMIN_SERVICE", "ID_TYPE_BASE_INFO", "ID_TYPE_SERIAL", "ID_TYPE_IMEI", "ID_TYPE_MEID", "ID_TYPE_INDIVIDUAL_ATTESTATION", "KEY_GEN_STRONGBOX_UNAVAILABLE", "INSTALLKEY_REQUEST_CREDENTIALS_ACCESS", "INSTALLKEY_SET_USER_SELECTABLE", "ACTION_PROFILE_OWNER_CHANGED", "PRIVATE_DNS_MODE_UNKNOWN", "PRIVATE_DNS_MODE_OFF", "PRIVATE_DNS_MODE_OPPORTUNISTIC", "PRIVATE_DNS_MODE_PROVIDER_HOSTNAME", "PRIVATE_DNS_SET_NO_ERROR", "PRIVATE_DNS_SET_ERROR_HOST_NOT_SERVING", "PRIVATE_DNS_SET_ERROR_FAILURE_SETTING", "ACTION_GET_PROVISIONING_MODE", "EXTRA_PROVISIONING_IMEI", "EXTRA_PROVISIONING_SERIAL_NUMBER", "EXTRA_PROVISIONING_MODE", "EXTRA_PROVISIONING_SUPPORTED_MODES", "EXTRA_PROVISIONING_SKIP_OWNERSHIP_DISCLAIMER", "EXTRA_PROVISIONING_ALLOWED_PROVISIONING_MODES", "PROVISIONING_MODE_FULLY_MANAGED_DEVICE", "PROVISIONING_MODE_MANAGED_PROFILE", "PROVISIONING_MODE_MANAGED_PROFILE_ON_PERSONAL_DEVICE", "EXTRA_PROVISIONING_RETURN_BEFORE_POLICY_COMPLIANCE", "EXTRA_PROVISIONING_KEEP_SCREEN_ON", "ACTION_ADMIN_POLICY_COMPLIANCE", "ACTION_UPDATE_DEVICE_POLICY_MANAGEMENT_ROLE_HOLDER", "RESULT_UPDATE_DEVICE_POLICY_MANAGEMENT_ROLE_HOLDER_RECOVERABLE_ERROR", "RESULT_UPDATE_DEVICE_POLICY_MANAGEMENT_ROLE_HOLDER_UNRECOVERABLE_ERROR", "RESULT_UPDATE_DEVICE_POLICY_MANAGEMENT_ROLE_HOLDER_PROVISIONING_DISABLED", "EXTRA_ROLE_HOLDER_UPDATE_FAILURE_STRATEGY", "ROLE_HOLDER_UPDATE_FAILURE_STRATEGY_FAIL_PROVISIONING", "ROLE_HOLDER_UPDATE_FAILURE_STRATEGY_FALLBACK_TO_PLATFORM_PROVISIONING", "EXTRA_ROLE_HOLDER_UPDATE_RESULT_CODE", "EXTRA_PROVISIONING_ROLE_HOLDER_CUSTOM_USER_CONSENT_INTENT", "ACTION_ESTABLISH_NETWORK_CONNECTION", "MAX_PASSWORD_LENGTH", "ACTION_BIND_SECONDARY_LOCKSCREEN_SERVICE", "PERSONAL_APPS_NOT_SUSPENDED", "PERSONAL_APPS_SUSPENDED_EXPLICITLY", "PERSONAL_APPS_SUSPENDED_PROFILE_TIMEOUT", "DEVICE_OWNER_TYPE_DEFAULT", "DEVICE_OWNER_TYPE_FINANCED", "OPERATION_LOCK_NOW", "OPERATION_SWITCH_USER", "OPERATION_START_USER_IN_BACKGROUND", "OPERATION_STOP_USER", "OPERATION_CREATE_AND_MANAGE_USER", "OPERATION_REMOVE_USER", "OPERATION_REBOOT", "OPERATION_WIPE_DATA", "OPERATION_LOGOUT_USER", "OPERATION_SET_USER_RESTRICTION", "OPERATION_SET_SYSTEM_SETTING", "OPERATION_SET_KEYGUARD_DISABLED", "OPERATION_SET_STATUS_BAR_DISABLED", "OPERATION_SET_SYSTEM_UPDATE_POLICY", "OPERATION_SET_APPLICATION_HIDDEN", "OPERATION_SET_APPLICATION_RESTRICTIONS", "OPERATION_SET_KEEP_UNINSTALLED_PACKAGES", "OPERATION_SET_LOCK_TASK_FEATURES", "OPERATION_SET_LOCK_TASK_PACKAGES", "OPERATION_SET_PACKAGES_SUSPENDED", "OPERATION_SET_TRUST_AGENT_CONFIGURATION", "OPERATION_SET_USER_CONTROL_DISABLED_PACKAGES", "OPERATION_CLEAR_APPLICATION_USER_DATA", "OPERATION_INSTALL_CA_CERT", "OPERATION_INSTALL_KEY_PAIR", "OPERATION_INSTALL_SYSTEM_UPDATE", "OPERATION_REMOVE_ACTIVE_ADMIN", "OPERATION_REMOVE_KEY_PAIR", "OPERATION_REQUEST_BUGREPORT", "OPERATION_SET_ALWAYS_ON_VPN_PACKAGE", "OPERATION_SET_CAMERA_DISABLED", "OPERATION_SET_FACTORY_RESET_PROTECTION_POLICY", "OPERATION_SET_GLOBAL_PRIVATE_DNS", "OPERATION_SET_LOGOUT_ENABLED", "OPERATION_SET_MASTER_VOLUME_MUTED", "OPERATION_SET_OVERRIDE_APNS_ENABLED", "OPERATION_SET_PERMISSION_GRANT_STATE", "OPERATION_SET_PERMISSION_POLICY", "OPERATION_SET_RESTRICTIONS_PROVIDER", "OPERATION_UNINSTALL_CA_CERT", "OPERATION_SET_CONTENT_PROTECTION_POLICY", "PREFIX_OPERATION", "PREFIX_OPERATION_SAFETY_REASON", "OPERATION_SAFETY_REASON_NONE", "OPERATION_SAFETY_REASON_DRIVING_DISTRACTION", "EXEMPT_FROM_SUSPENSION", "EXEMPT_FROM_DISMISSIBLE_NOTIFICATIONS", "EXEMPT_FROM_ACTIVITY_BG_START_RESTRICTION", "EXEMPT_FROM_HIBERNATION", "EXEMPT_FROM_POWER_RESTRICTIONS", "ACTION_DEVICE_POLICY_RESOURCE_UPDATED", "EXTRA_RESOURCE_TYPE", "EXTRA_RESOURCE_TYPE_DRAWABLE", "EXTRA_RESOURCE_TYPE_STRING", "EXTRA_RESOURCE_IDS", "ACTION_DEVICE_FINANCING_STATE_CHANGED", "MTE_NOT_CONTROLLED_BY_POLICY", "MTE_ENABLED", "MTE_DISABLED", "CONTENT_PROTECTION_NOT_CONTROLLED_BY_POLICY", "CONTENT_PROTECTION_DISABLED", "CONTENT_PROTECTION_ENABLED", "sDpmCaches", "PASSWORD_QUALITY_UNSPECIFIED", "PASSWORD_QUALITY_BIOMETRIC_WEAK", "PASSWORD_QUALITY_SOMETHING", "PASSWORD_QUALITY_NUMERIC", "PASSWORD_QUALITY_NUMERIC_COMPLEX", "PASSWORD_QUALITY_ALPHABETIC", "PASSWORD_QUALITY_ALPHANUMERIC", "PASSWORD_QUALITY_COMPLEX", "PASSWORD_QUALITY_MANAGED", "ACCOUNT_FEATURE_DEVICE_OR_PROFILE_OWNER_ALLOWED", "ACCOUNT_FEATURE_DEVICE_OR_PROFILE_OWNER_DISALLOWED", "REQUIRED_APP_MANAGED_USER", "REQUIRED_APP_MANAGED_DEVICE", "REQUIRED_APP_MANAGED_PROFILE", "RESET_PASSWORD_REQUIRE_ENTRY", "RESET_PASSWORD_DO_NOT_ASK_CREDENTIALS_ON_BOOT", "FLAG_EVICT_CREDENTIAL_ENCRYPTION_KEY", "WIPE_EXTERNAL_STORAGE", "WIPE_RESET_PROTECTION_DATA", "WIPE_EUICC", "WIPE_SILENTLY", "ENCRYPTION_STATUS_UNSUPPORTED", "ENCRYPTION_STATUS_INACTIVE", "ENCRYPTION_STATUS_ACTIVATING", "ENCRYPTION_STATUS_ACTIVE", "ENCRYPTION_STATUS_ACTIVE_DEFAULT_KEY", "ENCRYPTION_STATUS_ACTIVE_PER_USER", "ACTION_START_ENCRYPTION", "ACTION_CHECK_POLICY_COMPLIANCE", "ACTION_PROVISIONING_COMPLETED", "EXTRA_PROVISIONING_ACTION", "ACTION_SHOW_NEW_USER_DISCLAIMER", "KEYGUARD_DISABLE_FEATURES_NONE", "KEYGUARD_DISABLE_WIDGETS_ALL", "KEYGUARD_DISABLE_SECURE_CAMERA", "KEYGUARD_DISABLE_SECURE_NOTIFICATIONS", "KEYGUARD_DISABLE_UNREDACTED_NOTIFICATIONS", "KEYGUARD_DISABLE_TRUST_AGENTS", "KEYGUARD_DISABLE_FINGERPRINT", "KEYGUARD_DISABLE_REMOTE_INPUT", "KEYGUARD_DISABLE_FACE", "KEYGUARD_DISABLE_IRIS", "KEYGUARD_DISABLE_SHORTCUTS_ALL", "KEYGUARD_DISABLE_BIOMETRICS", "KEYGUARD_DISABLE_FEATURES_ALL", "NON_ORG_OWNED_PROFILE_KEYGUARD_FEATURES_AFFECT_OWNER", "ORG_OWNED_PROFILE_KEYGUARD_FEATURES_PARENT_ONLY", "PROFILE_KEYGUARD_FEATURES_AFFECT_OWNER", "ERROR_VPN_PACKAGE_NOT_FOUND", "mGetKeyGuardDisabledFeaturesCache", "IS_DEVICE_OWNER_USER_AWARE", "mHasDeviceOwnerCache", "mGetProfileOwnerOrDeviceOwnerSupervisionComponentCache", "mIsOrganizationOwnedDeviceWithManagedProfileCache", "SKIP_SETUP_WIZARD", "MAKE_USER_EPHEMERAL", "MAKE_USER_DEMO", "LEAVE_ALL_SYSTEM_APPS_ENABLED", "mGetDeviceOwnerOrganizationNameCache", "mGetOrganizationNameForUserCache", "mIsNetworkLoggingEnabledCache", "ERROR_PACKAGE_NAME_NOT_FOUND" ]
}