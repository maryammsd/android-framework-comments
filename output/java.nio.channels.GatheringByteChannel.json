{
  "filePath" : "/home/maryam/clearblue/files/android-source-35/java/nio/channels/GatheringByteChannel.java",
  "packageName" : "java.nio.channels",
  "className" : "GatheringByteChannel",
  "comment" : "",
  "links" : [ ],
  "variables" : [ ],
  "methods" : [ {
    "name" : "public long write(ByteBuffer[] srcs, int offset, int length) throws IOException",
    "returnType" : "long",
    "comment" : "\n     * Writes a sequence of bytes to this channel from a subsequence of the\n     * given buffers.\n     *\n     * <p> An attempt is made to write up to <i>r</i> bytes to this channel,\n     * where <i>r</i> is the total number of bytes remaining in the specified\n     * subsequence of the given buffer array, that is,\n     *\n     * <blockquote><pre>\n     * srcs[offset].remaining()\n     *     + srcs[offset+1].remaining()\n     *     + ... + srcs[offset+length-1].remaining()</pre></blockquote>\n     *\n     * at the moment that this method is invoked.\n     *\n     * <p> Suppose that a byte sequence of length <i>n</i> is written, where\n     * {@code 0}&nbsp;{@code <=}&nbsp;<i>n</i>&nbsp;{@code <=}&nbsp;<i>r</i>.\n     * Up to the first {@code srcs[offset].remaining()} bytes of this sequence\n     * are written from buffer {@code srcs[offset]}, up to the next\n     * {@code srcs[offset+1].remaining()} bytes are written from buffer\n     * {@code srcs[offset+1]}, and so forth, until the entire byte sequence is\n     * written.  As many bytes as possible are written from each buffer, hence\n     * the final position of each updated buffer, except the last updated\n     * buffer, is guaranteed to be equal to that buffer's limit.\n     *\n     * <p> Unless otherwise specified, a write operation will return only after\n     * writing all of the <i>r</i> requested bytes.  Some types of channels,\n     * depending upon their state, may write only some of the bytes or possibly\n     * none at all.  A socket channel in non-blocking mode, for example, cannot\n     * write any more bytes than are free in the socket's output buffer.\n     *\n     * <p> This method may be invoked at any time.  If another thread has\n     * already initiated a write operation upon this channel, however, then an\n     * invocation of this method will block until the first operation is\n     * complete. </p>\n     *\n     * @param  srcs\n     *         The buffers from which bytes are to be retrieved\n     *\n     * @param  offset\n     *         The offset within the buffer array of the first buffer from\n     *         which bytes are to be retrieved; must be non-negative and no\n     *         larger than {@code srcs.length}\n     *\n     * @param  length\n     *         The maximum number of buffers to be accessed; must be\n     *         non-negative and no larger than\n     *         {@code srcs.length}&nbsp;-&nbsp;{@code offset}\n     *\n     * @return  The number of bytes written, possibly zero\n     *\n     * @throws  IndexOutOfBoundsException\n     *          If the preconditions on the {@code offset} and {@code length}\n     *          parameters do not hold\n     *\n     * @throws  NonWritableChannelException\n     *          If this channel was not opened for writing\n     *\n     * @throws  ClosedChannelException\n     *          If this channel is closed\n     *\n     * @throws  AsynchronousCloseException\n     *          If another thread closes this channel\n     *          while the write operation is in progress\n     *\n     * @throws  ClosedByInterruptException\n     *          If another thread interrupts the current thread\n     *          while the write operation is in progress, thereby\n     *          closing the channel and setting the current thread's\n     *          interrupt status\n     *\n     * @throws  IOException\n     *          If some other I/O error occurs\n     ",
    "links" : [ ]
  }, {
    "name" : "public long write(ByteBuffer[] srcs) throws IOException",
    "returnType" : "long",
    "comment" : "\n     * Writes a sequence of bytes to this channel from the given buffers.\n     *\n     * <p> An invocation of this method of the form {@code c.write(srcs)}\n     * behaves in exactly the same manner as the invocation\n     *\n     * <blockquote><pre>\n     * c.write(srcs, 0, srcs.length);</pre></blockquote>\n     *\n     * @param  srcs\n     *         The buffers from which bytes are to be retrieved\n     *\n     * @return  The number of bytes written, possibly zero\n     *\n     * @throws  NonWritableChannelException\n     *          If this channel was not opened for writing\n     *\n     * @throws  ClosedChannelException\n     *          If this channel is closed\n     *\n     * @throws  AsynchronousCloseException\n     *          If another thread closes this channel\n     *          while the write operation is in progress\n     *\n     * @throws  ClosedByInterruptException\n     *          If another thread interrupts the current thread\n     *          while the write operation is in progress, thereby\n     *          closing the channel and setting the current thread's\n     *          interrupt status\n     *\n     * @throws  IOException\n     *          If some other I/O error occurs\n     ",
    "links" : [ ]
  } ],
  "methodNames" : [ "public long write(ByteBuffer[] srcs, int offset, int length) throws IOException", "public long write(ByteBuffer[] srcs) throws IOException" ],
  "variableNames" : [ ]
}