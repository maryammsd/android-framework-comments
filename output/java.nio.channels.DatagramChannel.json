{
  "filePath" : "/home/maryam/clearblue/files/android-source-35/java/nio/channels/DatagramChannel.java",
  "packageName" : "java.nio.channels",
  "className" : "DatagramChannel",
  "comment" : "",
  "links" : [ ],
  "variables" : [ ],
  "methods" : [ {
    "name" : "public static DatagramChannel open() throws IOException",
    "returnType" : "DatagramChannel",
    "comment" : "\n     * Opens a datagram channel.\n     *\n     * <p> The new channel is created by invoking the {@link\n     * java.nio.channels.spi.SelectorProvider#openDatagramChannel()\n     * openDatagramChannel} method of the system-wide default {@link\n     * java.nio.channels.spi.SelectorProvider} object.  The channel will not be\n     * connected.\n     *\n     * <p> The {@link ProtocolFamily ProtocolFamily} of the channel's socket\n     * is platform (and possibly configuration) dependent and therefore unspecified.\n     * The {@link #open(ProtocolFamily) open} allows the protocol family to be\n     * selected when opening a datagram channel, and should be used to open\n     * datagram channels that are intended for Internet Protocol multicasting.\n     *\n     * @return  A new datagram channel\n     *\n     * @throws  IOException\n     *          If an I/O error occurs\n     ",
    "links" : [ "java.nio.channels.spi.SelectorProvider", "#open(ProtocolFamily)", "java.net.ProtocolFamily", "java.nio.channels.spi.SelectorProvider#openDatagramChannel()" ]
  }, {
    "name" : "public static DatagramChannel open(ProtocolFamily family) throws IOException",
    "returnType" : "DatagramChannel",
    "comment" : "\n     * Opens a datagram channel.\n     *\n     * <p> The {@code family} parameter is used to specify the {@link\n     * ProtocolFamily}. If the datagram channel is to be used for IP multicasting\n     * then this should correspond to the address type of the multicast groups\n     * that this channel will join.\n     *\n     * <p> The new channel is created by invoking the {@link\n     * java.nio.channels.spi.SelectorProvider#openDatagramChannel(ProtocolFamily)\n     * openDatagramChannel} method of the system-wide default {@link\n     * java.nio.channels.spi.SelectorProvider} object.  The channel will not be\n     * connected.\n     *\n     * @param   family\n     *          The protocol family\n     *\n     * @return  A new datagram channel\n     *\n     * @throws  UnsupportedOperationException\n     *          If the specified protocol family is not supported. For example,\n     *          suppose the parameter is specified as {@link\n     *          java.net.StandardProtocolFamily#INET6 StandardProtocolFamily.INET6}\n     *          but IPv6 is not enabled on the platform.\n     * @throws  IOException\n     *          If an I/O error occurs\n     *\n     * @since   1.7\n     ",
    "links" : [ "java.nio.channels.spi.SelectorProvider", "java.net.ProtocolFamily", "java.net.StandardProtocolFamily#INET6", "java.nio.channels.spi.SelectorProvider#openDatagramChannel(ProtocolFamily)" ]
  }, {
    "name" : "public final int validOps()",
    "returnType" : "int",
    "comment" : "\n     * Returns an operation set identifying this channel's supported\n     * operations.\n     *\n     * <p> Datagram channels support reading and writing, so this method\n     * returns {@code (}{@link SelectionKey#OP_READ} {@code |}&nbsp;{@link\n     * SelectionKey#OP_WRITE}{@code )}.\n     *\n     * @return  The valid-operation set\n     ",
    "links" : [ "java.nio.channels.SelectionKey#OP_READ", "java.nio.channels.SelectionKey#OP_WRITE" ]
  }, {
    "name" : "public abstract DatagramChannel bind(SocketAddress local) throws IOException",
    "returnType" : "DatagramChannel",
    "comment" : "\n     * @throws  AlreadyBoundException               {@inheritDoc}\n     * @throws  UnsupportedAddressTypeException     {@inheritDoc}\n     * @throws  ClosedChannelException              {@inheritDoc}\n     * @throws  IOException                         {@inheritDoc}\n     * @throws  SecurityException\n     *          If a security manager has been installed and its {@link\n     *          SecurityManager#checkListen checkListen} method denies the\n     *          operation\n     *\n     * @since 1.7\n     ",
    "links" : [ "#checkListen" ]
  }, {
    "name" : "public abstract DatagramChannel setOption(SocketOption<T> name, T value) throws IOException",
    "returnType" : "DatagramChannel",
    "comment" : "\n     * @throws  UnsupportedOperationException           {@inheritDoc}\n     * @throws  IllegalArgumentException                {@inheritDoc}\n     * @throws  ClosedChannelException                  {@inheritDoc}\n     * @throws  IOException                             {@inheritDoc}\n     *\n     * @since 1.7\n     ",
    "links" : [ ]
  }, {
    "name" : "public abstract DatagramSocket socket()",
    "returnType" : "DatagramSocket",
    "comment" : "\n     * Retrieves a datagram socket associated with this channel.\n     *\n     * <p> The returned object will not declare any public methods that are not\n     * declared in the {@link java.net.DatagramSocket} class.  </p>\n     *\n     * @return  A datagram socket associated with this channel\n     ",
    "links" : [ "java.net.DatagramSocket" ]
  }, {
    "name" : "public abstract boolean isConnected()",
    "returnType" : "boolean",
    "comment" : "\n     * Tells whether or not this channel's socket is connected.\n     *\n     * @return  {@code true} if, and only if, this channel's socket\n     *          is {@link #isOpen open} and connected\n     ",
    "links" : [ "#isOpen" ]
  }, {
    "name" : "public abstract DatagramChannel connect(SocketAddress remote) throws IOException",
    "returnType" : "DatagramChannel",
    "comment" : "\n     * Connects this channel's socket.\n     *\n     * <p> The channel's socket is configured so that it only receives\n     * datagrams from, and sends datagrams to, the given remote <i>peer</i>\n     * address.  Once connected, datagrams may not be received from or sent to\n     * any other address.  A datagram socket remains connected until it is\n     * explicitly disconnected or until it is closed.\n     *\n     * <p> This method performs exactly the same security checks as the {@link\n     * java.net.DatagramSocket#connect connect} method of the {@link\n     * java.net.DatagramSocket} class.  That is, if a security manager has been\n     * installed then this method verifies that its {@link\n     * java.lang.SecurityManager#checkAccept checkAccept} and {@link\n     * java.lang.SecurityManager#checkConnect checkConnect} methods permit\n     * datagrams to be received from and sent to, respectively, the given\n     * remote address.\n     *\n     * <p> This method may be invoked at any time.  It will not have any effect\n     * on read or write operations that are already in progress at the moment\n     * that it is invoked. If this channel's socket is not bound then this method\n     * will first cause the socket to be bound to an address that is assigned\n     * automatically, as if invoking the {@link #bind bind} method with a\n     * parameter of {@code null}. </p>\n     *\n     * @param  remote\n     *         The remote address to which this channel is to be connected\n     *\n     * @return  This datagram channel\n     *\n     * @throws  AlreadyConnectedException\n     *          If this channel is already connected\n     *\n     * @throws  ClosedChannelException\n     *          If this channel is closed\n     *\n     * @throws  AsynchronousCloseException\n     *          If another thread closes this channel\n     *          while the connect operation is in progress\n     *\n     * @throws  ClosedByInterruptException\n     *          If another thread interrupts the current thread\n     *          while the connect operation is in progress, thereby\n     *          closing the channel and setting the current thread's\n     *          interrupt status\n     *\n     * @throws  UnresolvedAddressException\n     *          If the given remote address is not fully resolved\n     *\n     * @throws  UnsupportedAddressTypeException\n     *          If the type of the given remote address is not supported\n     *\n     * @throws  SecurityException\n     *          If a security manager has been installed\n     *          and it does not permit access to the given remote address\n     *\n     * @throws  IOException\n     *          If some other I/O error occurs\n     ",
    "links" : [ "java.net.DatagramSocket#connect", "java.net.DatagramSocket", "java.lang.SecurityManager#checkConnect", "#bind", "java.lang.SecurityManager#checkAccept" ]
  }, {
    "name" : "public abstract DatagramChannel disconnect() throws IOException",
    "returnType" : "DatagramChannel",
    "comment" : "\n     * Disconnects this channel's socket.\n     *\n     * <p> The channel's socket is configured so that it can receive datagrams\n     * from, and sends datagrams to, any remote address so long as the security\n     * manager, if installed, permits it.\n     *\n     * <p> This method may be invoked at any time.  It will not have any effect\n     * on read or write operations that are already in progress at the moment\n     * that it is invoked.\n     *\n     * <p> If this channel's socket is not connected, or if the channel is\n     * closed, then invoking this method has no effect.  </p>\n     *\n     * @return  This datagram channel\n     *\n     * @throws  IOException\n     *          If some other I/O error occurs\n     ",
    "links" : [ ]
  }, {
    "name" : "public abstract SocketAddress getRemoteAddress() throws IOException",
    "returnType" : "SocketAddress",
    "comment" : "\n     * Returns the remote address to which this channel's socket is connected.\n     *\n     * @return  The remote address; {@code null} if the channel's socket is not\n     *          connected\n     *\n     * @throws  ClosedChannelException\n     *          If the channel is closed\n     * @throws  IOException\n     *          If an I/O error occurs\n     *\n     * @since 1.7\n     ",
    "links" : [ ]
  }, {
    "name" : "public abstract SocketAddress receive(ByteBuffer dst) throws IOException",
    "returnType" : "SocketAddress",
    "comment" : "\n     * Receives a datagram via this channel.\n     *\n     * <p> If a datagram is immediately available, or if this channel is in\n     * blocking mode and one eventually becomes available, then the datagram is\n     * copied into the given byte buffer and its source address is returned.\n     * If this channel is in non-blocking mode and a datagram is not\n     * immediately available then this method immediately returns\n     * {@code null}.\n     *\n     * <p> The datagram is transferred into the given byte buffer starting at\n     * its current position, as if by a regular {@link\n     * ReadableByteChannel#read(java.nio.ByteBuffer) read} operation.  If there\n     * are fewer bytes remaining in the buffer than are required to hold the\n     * datagram then the remainder of the datagram is silently discarded.\n     *\n     * <p> This method performs exactly the same security checks as the {@link\n     * java.net.DatagramSocket#receive receive} method of the {@link\n     * java.net.DatagramSocket} class.  That is, if the socket is not connected\n     * to a specific remote address and a security manager has been installed\n     * then for each datagram received this method verifies that the source's\n     * address and port number are permitted by the security manager's {@link\n     * java.lang.SecurityManager#checkAccept checkAccept} method.  The overhead\n     * of this security check can be avoided by first connecting the socket via\n     * the {@link #connect connect} method.\n     *\n     * <p> This method may be invoked at any time.  If another thread has\n     * already initiated a read operation upon this channel, however, then an\n     * invocation of this method will block until the first operation is\n     * complete. If this channel's socket is not bound then this method will\n     * first cause the socket to be bound to an address that is assigned\n     * automatically, as if invoking the {@link #bind bind} method with a\n     * parameter of {@code null}. </p>\n     *\n     * @param  dst\n     *         The buffer into which the datagram is to be transferred\n     *\n     * @return  The datagram's source address,\n     *          or {@code null} if this channel is in non-blocking mode\n     *          and no datagram was immediately available\n     *\n     * @throws  ClosedChannelException\n     *          If this channel is closed\n     *\n     * @throws  AsynchronousCloseException\n     *          If another thread closes this channel\n     *          while the read operation is in progress\n     *\n     * @throws  ClosedByInterruptException\n     *          If another thread interrupts the current thread\n     *          while the read operation is in progress, thereby\n     *          closing the channel and setting the current thread's\n     *          interrupt status\n     *\n     * @throws  SecurityException\n     *          If a security manager has been installed\n     *          and it does not permit datagrams to be accepted\n     *          from the datagram's sender\n     *\n     * @throws  IOException\n     *          If some other I/O error occurs\n     ",
    "links" : [ "java.net.DatagramSocket", "java.nio.channels.ReadableByteChannel#read(java.nio.ByteBuffer)", "java.net.DatagramSocket#receive", "#connect", "#bind", "java.lang.SecurityManager#checkAccept" ]
  }, {
    "name" : "public abstract int send(ByteBuffer src, SocketAddress target) throws IOException",
    "returnType" : "int",
    "comment" : "\n     * Sends a datagram via this channel.\n     *\n     * <p> If this channel is in non-blocking mode and there is sufficient room\n     * in the underlying output buffer, or if this channel is in blocking mode\n     * and sufficient room becomes available, then the remaining bytes in the\n     * given buffer are transmitted as a single datagram to the given target\n     * address.\n     *\n     * <p> The datagram is transferred from the byte buffer as if by a regular\n     * {@link WritableByteChannel#write(java.nio.ByteBuffer) write} operation.\n     *\n     * <p> This method performs exactly the same security checks as the {@link\n     * java.net.DatagramSocket#send send} method of the {@link\n     * java.net.DatagramSocket} class.  That is, if the socket is not connected\n     * to a specific remote address and a security manager has been installed\n     * then for each datagram sent this method verifies that the target address\n     * and port number are permitted by the security manager's {@link\n     * java.lang.SecurityManager#checkConnect checkConnect} method.  The\n     * overhead of this security check can be avoided by first connecting the\n     * socket via the {@link #connect connect} method.\n     *\n     * <p> This method may be invoked at any time.  If another thread has\n     * already initiated a write operation upon this channel, however, then an\n     * invocation of this method will block until the first operation is\n     * complete. If this channel's socket is not bound then this method will\n     * first cause the socket to be bound to an address that is assigned\n     * automatically, as if by invoking the {@link #bind bind} method with a\n     * parameter of {@code null}. </p>\n     *\n     * @param  src\n     *         The buffer containing the datagram to be sent\n     *\n     * @param  target\n     *         The address to which the datagram is to be sent\n     *\n     * @return   The number of bytes sent, which will be either the number\n     *           of bytes that were remaining in the source buffer when this\n     *           method was invoked or, if this channel is non-blocking, may be\n     *           zero if there was insufficient room for the datagram in the\n     *           underlying output buffer\n     *\n     * @throws  AlreadyConnectedException\n     *          If this channel is connected to a different address\n     *          from that specified by {@code target}\n     *\n     * @throws  ClosedChannelException\n     *          If this channel is closed\n     *\n     * @throws  AsynchronousCloseException\n     *          If another thread closes this channel\n     *          while the read operation is in progress\n     *\n     * @throws  ClosedByInterruptException\n     *          If another thread interrupts the current thread\n     *          while the read operation is in progress, thereby\n     *          closing the channel and setting the current thread's\n     *          interrupt status\n     *\n     * @throws  UnresolvedAddressException\n     *          If the given remote address is not fully resolved\n     *\n     * @throws  UnsupportedAddressTypeException\n     *          If the type of the given remote address is not supported\n     *\n     * @throws  SecurityException\n     *          If a security manager has been installed\n     *          and it does not permit datagrams to be sent\n     *          to the given address\n     *\n     * @throws  IOException\n     *          If some other I/O error occurs\n     ",
    "links" : [ "java.net.DatagramSocket", "java.nio.channels.WritableByteChannel#write(java.nio.ByteBuffer)", "java.net.DatagramSocket#send", "#connect", "java.lang.SecurityManager#checkConnect", "#bind" ]
  }, {
    "name" : "public abstract int read(ByteBuffer dst) throws IOException",
    "returnType" : "int",
    "comment" : "\n     * Reads a datagram from this channel.\n     *\n     * <p> This method may only be invoked if this channel's socket is\n     * connected, and it only accepts datagrams from the socket's peer.  If\n     * there are more bytes in the datagram than remain in the given buffer\n     * then the remainder of the datagram is silently discarded.  Otherwise\n     * this method behaves exactly as specified in the {@link\n     * ReadableByteChannel} interface.  </p>\n     *\n     * @throws  NotYetConnectedException\n     *          If this channel's socket is not connected\n     ",
    "links" : [ "java.nio.channels.ReadableByteChannel" ]
  }, {
    "name" : "public abstract long read(ByteBuffer[] dsts, int offset, int length) throws IOException",
    "returnType" : "long",
    "comment" : "\n     * Reads a datagram from this channel.\n     *\n     * <p> This method may only be invoked if this channel's socket is\n     * connected, and it only accepts datagrams from the socket's peer.  If\n     * there are more bytes in the datagram than remain in the given buffers\n     * then the remainder of the datagram is silently discarded.  Otherwise\n     * this method behaves exactly as specified in the {@link\n     * ScatteringByteChannel} interface.  </p>\n     *\n     * @throws  NotYetConnectedException\n     *          If this channel's socket is not connected\n     ",
    "links" : [ "java.nio.channels.ScatteringByteChannel" ]
  }, {
    "name" : "public final long read(ByteBuffer[] dsts) throws IOException",
    "returnType" : "long",
    "comment" : "\n     * Reads a datagram from this channel.\n     *\n     * <p> This method may only be invoked if this channel's socket is\n     * connected, and it only accepts datagrams from the socket's peer.  If\n     * there are more bytes in the datagram than remain in the given buffers\n     * then the remainder of the datagram is silently discarded.  Otherwise\n     * this method behaves exactly as specified in the {@link\n     * ScatteringByteChannel} interface.  </p>\n     *\n     * @throws  NotYetConnectedException\n     *          If this channel's socket is not connected\n     ",
    "links" : [ "java.nio.channels.ScatteringByteChannel" ]
  }, {
    "name" : "public abstract int write(ByteBuffer src) throws IOException",
    "returnType" : "int",
    "comment" : "\n     * Writes a datagram to this channel.\n     *\n     * <p> This method may only be invoked if this channel's socket is\n     * connected, in which case it sends datagrams directly to the socket's\n     * peer.  Otherwise it behaves exactly as specified in the {@link\n     * WritableByteChannel} interface.  </p>\n     *\n     * @throws  NotYetConnectedException\n     *          If this channel's socket is not connected\n     ",
    "links" : [ "java.nio.channels.WritableByteChannel" ]
  }, {
    "name" : "public abstract long write(ByteBuffer[] srcs, int offset, int length) throws IOException",
    "returnType" : "long",
    "comment" : "\n     * Writes a datagram to this channel.\n     *\n     * <p> This method may only be invoked if this channel's socket is\n     * connected, in which case it sends datagrams directly to the socket's\n     * peer.  Otherwise it behaves exactly as specified in the {@link\n     * GatheringByteChannel} interface.  </p>\n     *\n     * @return   The number of bytes sent, which will be either the number\n     *           of bytes that were remaining in the source buffer when this\n     *           method was invoked or, if this channel is non-blocking, may be\n     *           zero if there was insufficient room for the datagram in the\n     *           underlying output buffer\n     *\n     * @throws  NotYetConnectedException\n     *          If this channel's socket is not connected\n     ",
    "links" : [ "java.nio.channels.GatheringByteChannel" ]
  }, {
    "name" : "public final long write(ByteBuffer[] srcs) throws IOException",
    "returnType" : "long",
    "comment" : "\n     * Writes a datagram to this channel.\n     *\n     * <p> This method may only be invoked if this channel's socket is\n     * connected, in which case it sends datagrams directly to the socket's\n     * peer.  Otherwise it behaves exactly as specified in the {@link\n     * GatheringByteChannel} interface.  </p>\n     *\n     * @return   The number of bytes sent, which will be either the number\n     *           of bytes that were remaining in the source buffer when this\n     *           method was invoked or, if this channel is non-blocking, may be\n     *           zero if there was insufficient room for the datagram in the\n     *           underlying output buffer\n     *\n     * @throws  NotYetConnectedException\n     *          If this channel's socket is not connected\n     ",
    "links" : [ "java.nio.channels.GatheringByteChannel" ]
  }, {
    "name" : "public abstract SocketAddress getLocalAddress() throws IOException",
    "returnType" : "SocketAddress",
    "comment" : "\n     * {@inheritDoc}\n     * <p>\n     * If there is a security manager set, its {@code checkConnect} method is\n     * called with the local address and {@code -1} as its arguments to see\n     * if the operation is allowed. If the operation is not allowed,\n     * a {@code SocketAddress} representing the\n     * {@link java.net.InetAddress#getLoopbackAddress loopback} address and the\n     * local port of the channel's socket is returned.\n     *\n     * @return  The {@code SocketAddress} that the socket is bound to, or the\n     *          {@code SocketAddress} representing the loopback address if\n     *          denied by the security manager, or {@code null} if the\n     *          channel's socket is not bound\n     *\n     * @throws  ClosedChannelException     {@inheritDoc}\n     * @throws  IOException                {@inheritDoc}\n     ",
    "links" : [ "java.net.InetAddress#getLoopbackAddress" ]
  } ],
  "methodNames" : [ "public static DatagramChannel open() throws IOException", "public static DatagramChannel open(ProtocolFamily family) throws IOException", "public final int validOps()", "public abstract DatagramChannel bind(SocketAddress local) throws IOException", "public abstract DatagramChannel setOption(SocketOption<T> name, T value) throws IOException", "public abstract DatagramSocket socket()", "public abstract boolean isConnected()", "public abstract DatagramChannel connect(SocketAddress remote) throws IOException", "public abstract DatagramChannel disconnect() throws IOException", "public abstract SocketAddress getRemoteAddress() throws IOException", "public abstract SocketAddress receive(ByteBuffer dst) throws IOException", "public abstract int send(ByteBuffer src, SocketAddress target) throws IOException", "public abstract int read(ByteBuffer dst) throws IOException", "public abstract long read(ByteBuffer[] dsts, int offset, int length) throws IOException", "public final long read(ByteBuffer[] dsts) throws IOException", "public abstract int write(ByteBuffer src) throws IOException", "public abstract long write(ByteBuffer[] srcs, int offset, int length) throws IOException", "public final long write(ByteBuffer[] srcs) throws IOException", "public abstract SocketAddress getLocalAddress() throws IOException" ],
  "variableNames" : [ ]
}