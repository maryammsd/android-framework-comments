{
  "filePath" : "/home/maryam/clearblue/files/android-source-35/java/lang/AbstractStringBuilder.java",
  "packageName" : "java.lang",
  "className" : "AbstractStringBuilder",
  "comment" : "\n * A mutable sequence of characters.\n * <p>\n * Implements a modifiable string. At any point in time it contains some\n * particular sequence of characters, but the length and content of the\n * sequence can be changed through certain method calls.\n *\n * <p>Unless otherwise noted, passing a {@code null} argument to a constructor\n * or method in this class will cause a {@link NullPointerException} to be\n * thrown.\n *\n * @author      Michael McCloskey\n * @author      Martin Buchholz\n * @author      Ulf Zibis\n * @since       1.5\n ",
  "links" : [ "java.lang.NullPointerException" ],
  "variables" : [ {
    "name" : "value",
    "type" : "byte[]",
    "comment" : "\n     * The value is used for character storage.\n     ",
    "links" : [ ]
  }, {
    "name" : "coder",
    "type" : "byte",
    "comment" : "\n     * The id of the encoding used to encode the bytes in {@code value}.\n     ",
    "links" : [ ]
  }, {
    "name" : "count",
    "type" : "int",
    "comment" : "\n     * The count is the number of characters used.\n     ",
    "links" : [ ]
  }, {
    "name" : "EMPTYVALUE",
    "type" : "byte[]",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "MAX_ARRAY_SIZE",
    "type" : "int",
    "comment" : "\n     * The maximum size of array to allocate (unless necessary).\n     * Some VMs reserve some header words in an array.\n     * Attempts to allocate larger arrays may result in\n     * OutOfMemoryError: Requested array size exceeds VM limit\n     ",
    "links" : [ ]
  } ],
  "methods" : [ {
    "name" : " int compareTo(AbstractStringBuilder another)",
    "returnType" : "int",
    "comment" : "\n     * Compares the objects of two AbstractStringBuilder implementations lexicographically.\n     *\n     * @since 11\n     ",
    "links" : [ ]
  }, {
    "name" : "public int length()",
    "returnType" : "int",
    "comment" : "\n     * Returns the length (character count).\n     *\n     * @return  the length of the sequence of characters currently\n     *          represented by this object\n     ",
    "links" : [ ]
  }, {
    "name" : "public int capacity()",
    "returnType" : "int",
    "comment" : "\n     * Returns the current capacity. The capacity is the amount of storage\n     * available for newly inserted characters, beyond which an allocation\n     * will occur.\n     *\n     * @return  the current capacity\n     ",
    "links" : [ ]
  }, {
    "name" : "public void ensureCapacity(int minimumCapacity)",
    "returnType" : "void",
    "comment" : "\n     * Ensures that the capacity is at least equal to the specified minimum.\n     * If the current capacity is less than the argument, then a new internal\n     * array is allocated with greater capacity. The new capacity is the\n     * larger of:\n     * <ul>\n     * <li>The {@code minimumCapacity} argument.\n     * <li>Twice the old capacity, plus {@code 2}.\n     * </ul>\n     * If the {@code minimumCapacity} argument is nonpositive, this\n     * method takes no action and simply returns.\n     * Note that subsequent operations on this object can reduce the\n     * actual capacity below that requested here.\n     *\n     * @param   minimumCapacity   the minimum desired capacity.\n     ",
    "links" : [ ]
  }, {
    "name" : "private void ensureCapacityInternal(int minimumCapacity)",
    "returnType" : "void",
    "comment" : "\n     * For positive values of {@code minimumCapacity}, this method\n     * behaves like {@code ensureCapacity}, however it is never\n     * synchronized.\n     * If {@code minimumCapacity} is non positive due to numeric\n     * overflow, this method throws {@code OutOfMemoryError}.\n     ",
    "links" : [ ]
  }, {
    "name" : "private int newCapacity(int minCapacity)",
    "returnType" : "int",
    "comment" : "\n     * Returns a capacity at least as large as the given minimum capacity.\n     * Returns the current capacity increased by the same amount + 2 if\n     * that suffices.\n     * Will not return a capacity greater than\n     * {@code (MAX_ARRAY_SIZE >> coder)} unless the given minimum capacity\n     * is greater than that.\n     *\n     * @param  minCapacity the desired minimum capacity\n     * @throws OutOfMemoryError if minCapacity is less than zero or\n     *         greater than (Integer.MAX_VALUE >> coder)\n     ",
    "links" : [ ]
  }, {
    "name" : "private int hugeCapacity(int minCapacity)",
    "returnType" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private void inflate()",
    "returnType" : "void",
    "comment" : "\n     * If the coder is \"isLatin1\", this inflates the internal 8-bit storage\n     * to 16-bit <hi=0, low> pair storage.\n     ",
    "links" : [ ]
  }, {
    "name" : "public void trimToSize()",
    "returnType" : "void",
    "comment" : "\n     * Attempts to reduce storage used for the character sequence.\n     * If the buffer is larger than necessary to hold its current sequence of\n     * characters, then it may be resized to become more space efficient.\n     * Calling this method may, but is not required to, affect the value\n     * returned by a subsequent call to the {@link #capacity()} method.\n     ",
    "links" : [ "#capacity()" ]
  }, {
    "name" : "public void setLength(int newLength)",
    "returnType" : "void",
    "comment" : "\n     * Sets the length of the character sequence.\n     * The sequence is changed to a new character sequence\n     * whose length is specified by the argument. For every nonnegative\n     * index <i>k</i> less than {@code newLength}, the character at\n     * index <i>k</i> in the new character sequence is the same as the\n     * character at index <i>k</i> in the old sequence if <i>k</i> is less\n     * than the length of the old character sequence; otherwise, it is the\n     * null character {@code '\\u005Cu0000'}.\n     *\n     * In other words, if the {@code newLength} argument is less than\n     * the current length, the length is changed to the specified length.\n     * <p>\n     * If the {@code newLength} argument is greater than or equal\n     * to the current length, sufficient null characters\n     * ({@code '\\u005Cu0000'}) are appended so that\n     * length becomes the {@code newLength} argument.\n     * <p>\n     * The {@code newLength} argument must be greater than or equal\n     * to {@code 0}.\n     *\n     * @param      newLength   the new length\n     * @throws     IndexOutOfBoundsException  if the\n     *               {@code newLength} argument is negative.\n     ",
    "links" : [ ]
  }, {
    "name" : "public char charAt(int index)",
    "returnType" : "char",
    "comment" : "\n     * Returns the {@code char} value in this sequence at the specified index.\n     * The first {@code char} value is at index {@code 0}, the next at index\n     * {@code 1}, and so on, as in array indexing.\n     * <p>\n     * The index argument must be greater than or equal to\n     * {@code 0}, and less than the length of this sequence.\n     *\n     * <p>If the {@code char} value specified by the index is a\n     * <a href=\"Character.html#unicode\">surrogate</a>, the surrogate\n     * value is returned.\n     *\n     * @param      index   the index of the desired {@code char} value.\n     * @return     the {@code char} value at the specified index.\n     * @throws     IndexOutOfBoundsException  if {@code index} is\n     *             negative or greater than or equal to {@code length()}.\n     ",
    "links" : [ ]
  }, {
    "name" : "public int codePointAt(int index)",
    "returnType" : "int",
    "comment" : "\n     * Returns the character (Unicode code point) at the specified\n     * index. The index refers to {@code char} values\n     * (Unicode code units) and ranges from {@code 0} to\n     * {@link #length()}{@code  - 1}.\n     *\n     * <p> If the {@code char} value specified at the given index\n     * is in the high-surrogate range, the following index is less\n     * than the length of this sequence, and the\n     * {@code char} value at the following index is in the\n     * low-surrogate range, then the supplementary code point\n     * corresponding to this surrogate pair is returned. Otherwise,\n     * the {@code char} value at the given index is returned.\n     *\n     * @param      index the index to the {@code char} values\n     * @return     the code point value of the character at the\n     *             {@code index}\n     * @throws     IndexOutOfBoundsException  if the {@code index}\n     *             argument is negative or not less than the length of this\n     *             sequence.\n     ",
    "links" : [ "#length()" ]
  }, {
    "name" : "public int codePointBefore(int index)",
    "returnType" : "int",
    "comment" : "\n     * Returns the character (Unicode code point) before the specified\n     * index. The index refers to {@code char} values\n     * (Unicode code units) and ranges from {@code 1} to {@link\n     * #length()}.\n     *\n     * <p> If the {@code char} value at {@code (index - 1)}\n     * is in the low-surrogate range, {@code (index - 2)} is not\n     * negative, and the {@code char} value at {@code (index -\n     * 2)} is in the high-surrogate range, then the\n     * supplementary code point value of the surrogate pair is\n     * returned. If the {@code char} value at {@code index -\n     * 1} is an unpaired low-surrogate or a high-surrogate, the\n     * surrogate value is returned.\n     *\n     * @param     index the index following the code point that should be returned\n     * @return    the Unicode code point value before the given index.\n     * @throws    IndexOutOfBoundsException if the {@code index}\n     *            argument is less than 1 or greater than the length\n     *            of this sequence.\n     ",
    "links" : [ "#length()" ]
  }, {
    "name" : "public int codePointCount(int beginIndex, int endIndex)",
    "returnType" : "int",
    "comment" : "\n     * Returns the number of Unicode code points in the specified text\n     * range of this sequence. The text range begins at the specified\n     * {@code beginIndex} and extends to the {@code char} at\n     * index {@code endIndex - 1}. Thus the length (in\n     * {@code char}s) of the text range is\n     * {@code endIndex-beginIndex}. Unpaired surrogates within\n     * this sequence count as one code point each.\n     *\n     * @param beginIndex the index to the first {@code char} of\n     * the text range.\n     * @param endIndex the index after the last {@code char} of\n     * the text range.\n     * @return the number of Unicode code points in the specified text\n     * range\n     * @throws    IndexOutOfBoundsException if the\n     * {@code beginIndex} is negative, or {@code endIndex}\n     * is larger than the length of this sequence, or\n     * {@code beginIndex} is larger than {@code endIndex}.\n     ",
    "links" : [ ]
  }, {
    "name" : "public int offsetByCodePoints(int index, int codePointOffset)",
    "returnType" : "int",
    "comment" : "\n     * Returns the index within this sequence that is offset from the\n     * given {@code index} by {@code codePointOffset} code\n     * points. Unpaired surrogates within the text range given by\n     * {@code index} and {@code codePointOffset} count as\n     * one code point each.\n     *\n     * @param index the index to be offset\n     * @param codePointOffset the offset in code points\n     * @return the index within this sequence\n     * @throws    IndexOutOfBoundsException if {@code index}\n     *   is negative or larger then the length of this sequence,\n     *   or if {@code codePointOffset} is positive and the subsequence\n     *   starting with {@code index} has fewer than\n     *   {@code codePointOffset} code points,\n     *   or if {@code codePointOffset} is negative and the subsequence\n     *   before {@code index} has fewer than the absolute value of\n     *   {@code codePointOffset} code points.\n     ",
    "links" : [ ]
  }, {
    "name" : "public void getChars(int srcBegin, int srcEnd, char[] dst, int dstBegin)",
    "returnType" : "void",
    "comment" : "\n     * Characters are copied from this sequence into the\n     * destination character array {@code dst}. The first character to\n     * be copied is at index {@code srcBegin}; the last character to\n     * be copied is at index {@code srcEnd-1}. The total number of\n     * characters to be copied is {@code srcEnd-srcBegin}. The\n     * characters are copied into the subarray of {@code dst} starting\n     * at index {@code dstBegin} and ending at index:\n     * <pre>{@code\n     * dstbegin + (srcEnd-srcBegin) - 1\n     * }</pre>\n     *\n     * @param      srcBegin   start copying at this offset.\n     * @param      srcEnd     stop copying at this offset.\n     * @param      dst        the array to copy the data into.\n     * @param      dstBegin   offset into {@code dst}.\n     * @throws     IndexOutOfBoundsException  if any of the following is true:\n     *             <ul>\n     *             <li>{@code srcBegin} is negative\n     *             <li>{@code dstBegin} is negative\n     *             <li>the {@code srcBegin} argument is greater than\n     *             the {@code srcEnd} argument.\n     *             <li>{@code srcEnd} is greater than\n     *             {@code this.length()}.\n     *             <li>{@code dstBegin+srcEnd-srcBegin} is greater than\n     *             {@code dst.length}\n     *             </ul>\n     ",
    "links" : [ ]
  }, {
    "name" : "public void setCharAt(int index, char ch)",
    "returnType" : "void",
    "comment" : "\n     * The character at the specified index is set to {@code ch}. This\n     * sequence is altered to represent a new character sequence that is\n     * identical to the old character sequence, except that it contains the\n     * character {@code ch} at position {@code index}.\n     * <p>\n     * The index argument must be greater than or equal to\n     * {@code 0}, and less than the length of this sequence.\n     *\n     * @param      index   the index of the character to modify.\n     * @param      ch      the new character.\n     * @throws     IndexOutOfBoundsException  if {@code index} is\n     *             negative or greater than or equal to {@code length()}.\n     ",
    "links" : [ ]
  }, {
    "name" : "public AbstractStringBuilder append(Object obj)",
    "returnType" : "AbstractStringBuilder",
    "comment" : "\n     * Appends the string representation of the {@code Object} argument.\n     * <p>\n     * The overall effect is exactly as if the argument were converted\n     * to a string by the method {@link String#valueOf(Object)},\n     * and the characters of that string were then\n     * {@link #append(String) appended} to this character sequence.\n     *\n     * @param   obj   an {@code Object}.\n     * @return  a reference to this object.\n     ",
    "links" : [ "java.lang.String#valueOf(Object)", "#append(String)" ]
  }, {
    "name" : "public AbstractStringBuilder append(String str)",
    "returnType" : "AbstractStringBuilder",
    "comment" : "\n     * Appends the specified string to this character sequence.\n     * <p>\n     * The characters of the {@code String} argument are appended, in\n     * order, increasing the length of this sequence by the length of the\n     * argument. If {@code str} is {@code null}, then the four\n     * characters {@code \"null\"} are appended.\n     * <p>\n     * Let <i>n</i> be the length of this character sequence just prior to\n     * execution of the {@code append} method. Then the character at\n     * index <i>k</i> in the new character sequence is equal to the character\n     * at index <i>k</i> in the old character sequence, if <i>k</i> is less\n     * than <i>n</i>; otherwise, it is equal to the character at index\n     * <i>k-n</i> in the argument {@code str}.\n     *\n     * @param   str   a string.\n     * @return  a reference to this object.\n     ",
    "links" : [ ]
  }, {
    "name" : "public AbstractStringBuilder append(StringBuffer sb)",
    "returnType" : "AbstractStringBuilder",
    "comment" : " Documentation in subclasses because of synchro difference",
    "links" : [ ]
  }, {
    "name" : " AbstractStringBuilder append(AbstractStringBuilder asb)",
    "returnType" : "AbstractStringBuilder",
    "comment" : "\n     * @since 1.8\n     ",
    "links" : [ ]
  }, {
    "name" : "public AbstractStringBuilder append(CharSequence s)",
    "returnType" : "AbstractStringBuilder",
    "comment" : " Documentation in subclasses because of synchro difference",
    "links" : [ ]
  }, {
    "name" : "private AbstractStringBuilder appendNull()",
    "returnType" : "AbstractStringBuilder",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public AbstractStringBuilder append(CharSequence s, int start, int end)",
    "returnType" : "AbstractStringBuilder",
    "comment" : "\n     * Appends a subsequence of the specified {@code CharSequence} to this\n     * sequence.\n     * <p>\n     * Characters of the argument {@code s}, starting at\n     * index {@code start}, are appended, in order, to the contents of\n     * this sequence up to the (exclusive) index {@code end}. The length\n     * of this sequence is increased by the value of {@code end - start}.\n     * <p>\n     * Let <i>n</i> be the length of this character sequence just prior to\n     * execution of the {@code append} method. Then the character at\n     * index <i>k</i> in this character sequence becomes equal to the\n     * character at index <i>k</i> in this sequence, if <i>k</i> is less than\n     * <i>n</i>; otherwise, it is equal to the character at index\n     * <i>k+start-n</i> in the argument {@code s}.\n     * <p>\n     * If {@code s} is {@code null}, then this method appends\n     * characters as if the s parameter was a sequence containing the four\n     * characters {@code \"null\"}.\n     *\n     * @param   s the sequence to append.\n     * @param   start   the starting index of the subsequence to be appended.\n     * @param   end     the end index of the subsequence to be appended.\n     * @return  a reference to this object.\n     * @throws     IndexOutOfBoundsException if\n     *             {@code start} is negative, or\n     *             {@code start} is greater than {@code end} or\n     *             {@code end} is greater than {@code s.length()}\n     ",
    "links" : [ ]
  }, {
    "name" : "public AbstractStringBuilder append(char[] str)",
    "returnType" : "AbstractStringBuilder",
    "comment" : "\n     * Appends the string representation of the {@code char} array\n     * argument to this sequence.\n     * <p>\n     * The characters of the array argument are appended, in order, to\n     * the contents of this sequence. The length of this sequence\n     * increases by the length of the argument.\n     * <p>\n     * The overall effect is exactly as if the argument were converted\n     * to a string by the method {@link String#valueOf(char[])},\n     * and the characters of that string were then\n     * {@link #append(String) appended} to this character sequence.\n     *\n     * @param   str   the characters to be appended.\n     * @return  a reference to this object.\n     ",
    "links" : [ "java.lang.String#valueOf(char", "#append(String)" ]
  }, {
    "name" : "public AbstractStringBuilder append(char[] str, int offset, int len)",
    "returnType" : "AbstractStringBuilder",
    "comment" : "\n     * Appends the string representation of a subarray of the\n     * {@code char} array argument to this sequence.\n     * <p>\n     * Characters of the {@code char} array {@code str}, starting at\n     * index {@code offset}, are appended, in order, to the contents\n     * of this sequence. The length of this sequence increases\n     * by the value of {@code len}.\n     * <p>\n     * The overall effect is exactly as if the arguments were converted\n     * to a string by the method {@link String#valueOf(char[],int,int)},\n     * and the characters of that string were then\n     * {@link #append(String) appended} to this character sequence.\n     *\n     * @param   str      the characters to be appended.\n     * @param   offset   the index of the first {@code char} to append.\n     * @param   len      the number of {@code char}s to append.\n     * @return  a reference to this object.\n     * @throws IndexOutOfBoundsException\n     *         if {@code offset < 0} or {@code len < 0}\n     *         or {@code offset+len > str.length}\n     ",
    "links" : [ "java.lang.String#valueOf(char", "#append(String)" ]
  }, {
    "name" : "public AbstractStringBuilder append(boolean b)",
    "returnType" : "AbstractStringBuilder",
    "comment" : "\n     * Appends the string representation of the {@code boolean}\n     * argument to the sequence.\n     * <p>\n     * The overall effect is exactly as if the argument were converted\n     * to a string by the method {@link String#valueOf(boolean)},\n     * and the characters of that string were then\n     * {@link #append(String) appended} to this character sequence.\n     *\n     * @param   b   a {@code boolean}.\n     * @return  a reference to this object.\n     ",
    "links" : [ "java.lang.String#valueOf(boolean)", "#append(String)" ]
  }, {
    "name" : "public AbstractStringBuilder append(char c)",
    "returnType" : "AbstractStringBuilder",
    "comment" : "\n     * Appends the string representation of the {@code char}\n     * argument to this sequence.\n     * <p>\n     * The argument is appended to the contents of this sequence.\n     * The length of this sequence increases by {@code 1}.\n     * <p>\n     * The overall effect is exactly as if the argument were converted\n     * to a string by the method {@link String#valueOf(char)},\n     * and the character in that string were then\n     * {@link #append(String) appended} to this character sequence.\n     *\n     * @param   c   a {@code char}.\n     * @return  a reference to this object.\n     ",
    "links" : [ "#append(String)", "java.lang.String#valueOf(char)" ]
  }, {
    "name" : "public AbstractStringBuilder append(int i)",
    "returnType" : "AbstractStringBuilder",
    "comment" : "\n     * Appends the string representation of the {@code int}\n     * argument to this sequence.\n     * <p>\n     * The overall effect is exactly as if the argument were converted\n     * to a string by the method {@link String#valueOf(int)},\n     * and the characters of that string were then\n     * {@link #append(String) appended} to this character sequence.\n     *\n     * @param   i   an {@code int}.\n     * @return  a reference to this object.\n     ",
    "links" : [ "#append(String)", "java.lang.String#valueOf(int)" ]
  }, {
    "name" : "public AbstractStringBuilder append(long l)",
    "returnType" : "AbstractStringBuilder",
    "comment" : "\n     * Appends the string representation of the {@code long}\n     * argument to this sequence.\n     * <p>\n     * The overall effect is exactly as if the argument were converted\n     * to a string by the method {@link String#valueOf(long)},\n     * and the characters of that string were then\n     * {@link #append(String) appended} to this character sequence.\n     *\n     * @param   l   a {@code long}.\n     * @return  a reference to this object.\n     ",
    "links" : [ "java.lang.String#valueOf(long)", "#append(String)" ]
  }, {
    "name" : "public AbstractStringBuilder append(float f)",
    "returnType" : "AbstractStringBuilder",
    "comment" : "\n     * Appends the string representation of the {@code float}\n     * argument to this sequence.\n     * <p>\n     * The overall effect is exactly as if the argument were converted\n     * to a string by the method {@link String#valueOf(float)},\n     * and the characters of that string were then\n     * {@link #append(String) appended} to this character sequence.\n     *\n     * @param   f   a {@code float}.\n     * @return  a reference to this object.\n     ",
    "links" : [ "java.lang.String#valueOf(float)", "#append(String)" ]
  }, {
    "name" : "public AbstractStringBuilder append(double d)",
    "returnType" : "AbstractStringBuilder",
    "comment" : "\n     * Appends the string representation of the {@code double}\n     * argument to this sequence.\n     * <p>\n     * The overall effect is exactly as if the argument were converted\n     * to a string by the method {@link String#valueOf(double)},\n     * and the characters of that string were then\n     * {@link #append(String) appended} to this character sequence.\n     *\n     * @param   d   a {@code double}.\n     * @return  a reference to this object.\n     ",
    "links" : [ "java.lang.String#valueOf(double)", "#append(String)" ]
  }, {
    "name" : "public AbstractStringBuilder delete(int start, int end)",
    "returnType" : "AbstractStringBuilder",
    "comment" : "\n     * Removes the characters in a substring of this sequence.\n     * The substring begins at the specified {@code start} and extends to\n     * the character at index {@code end - 1} or to the end of the\n     * sequence if no such character exists. If\n     * {@code start} is equal to {@code end}, no changes are made.\n     *\n     * @param      start  The beginning index, inclusive.\n     * @param      end    The ending index, exclusive.\n     * @return     This object.\n     * @throws     StringIndexOutOfBoundsException  if {@code start}\n     *             is negative, greater than {@code length()}, or\n     *             greater than {@code end}.\n     ",
    "links" : [ ]
  }, {
    "name" : "public AbstractStringBuilder appendCodePoint(int codePoint)",
    "returnType" : "AbstractStringBuilder",
    "comment" : "\n     * Appends the string representation of the {@code codePoint}\n     * argument to this sequence.\n     *\n     * <p> The argument is appended to the contents of this sequence.\n     * The length of this sequence increases by\n     * {@link Character#charCount(int) Character.charCount(codePoint)}.\n     *\n     * <p> The overall effect is exactly as if the argument were\n     * converted to a {@code char} array by the method\n     * {@link Character#toChars(int)} and the character in that array\n     * were then {@link #append(char[]) appended} to this character\n     * sequence.\n     *\n     * @param   codePoint   a Unicode code point\n     * @return  a reference to this object.\n     * @throws    IllegalArgumentException if the specified\n     * {@code codePoint} isn't a valid Unicode code point\n     ",
    "links" : [ "java.lang.Character#charCount(int)", "java.lang.Character#toChars(int)", "#append(char" ]
  }, {
    "name" : "public AbstractStringBuilder deleteCharAt(int index)",
    "returnType" : "AbstractStringBuilder",
    "comment" : "\n     * Removes the {@code char} at the specified position in this\n     * sequence. This sequence is shortened by one {@code char}.\n     *\n     * <p>Note: If the character at the given index is a supplementary\n     * character, this method does not remove the entire character. If\n     * correct handling of supplementary characters is required,\n     * determine the number of {@code char}s to remove by calling\n     * {@code Character.charCount(thisSequence.codePointAt(index))},\n     * where {@code thisSequence} is this sequence.\n     *\n     * @param       index  Index of {@code char} to remove\n     * @return      This object.\n     * @throws      StringIndexOutOfBoundsException  if the {@code index}\n     *              is negative or greater than or equal to\n     *              {@code length()}.\n     ",
    "links" : [ ]
  }, {
    "name" : "public AbstractStringBuilder replace(int start, int end, String str)",
    "returnType" : "AbstractStringBuilder",
    "comment" : "\n     * Replaces the characters in a substring of this sequence\n     * with characters in the specified {@code String}. The substring\n     * begins at the specified {@code start} and extends to the character\n     * at index {@code end - 1} or to the end of the\n     * sequence if no such character exists. First the\n     * characters in the substring are removed and then the specified\n     * {@code String} is inserted at {@code start}. (This\n     * sequence will be lengthened to accommodate the\n     * specified String if necessary.)\n     *\n     * @param      start    The beginning index, inclusive.\n     * @param      end      The ending index, exclusive.\n     * @param      str   String that will replace previous contents.\n     * @return     This object.\n     * @throws     StringIndexOutOfBoundsException  if {@code start}\n     *             is negative, greater than {@code length()}, or\n     *             greater than {@code end}.\n     ",
    "links" : [ ]
  }, {
    "name" : "public String substring(int start)",
    "returnType" : "String",
    "comment" : "\n     * Returns a new {@code String} that contains a subsequence of\n     * characters currently contained in this character sequence. The\n     * substring begins at the specified index and extends to the end of\n     * this sequence.\n     *\n     * @param      start    The beginning index, inclusive.\n     * @return     The new string.\n     * @throws     StringIndexOutOfBoundsException  if {@code start} is\n     *             less than zero, or greater than the length of this object.\n     ",
    "links" : [ ]
  }, {
    "name" : "public CharSequence subSequence(int start, int end)",
    "returnType" : "CharSequence",
    "comment" : "\n     * Returns a new character sequence that is a subsequence of this sequence.\n     *\n     * <p> An invocation of this method of the form\n     *\n     * <pre>{@code\n     * sb.subSequence(begin,&nbsp;end)}</pre>\n     *\n     * behaves in exactly the same way as the invocation\n     *\n     * <pre>{@code\n     * sb.substring(begin,&nbsp;end)}</pre>\n     *\n     * This method is provided so that this class can\n     * implement the {@link CharSequence} interface.\n     *\n     * @param      start   the start index, inclusive.\n     * @param      end     the end index, exclusive.\n     * @return     the specified subsequence.\n     *\n     * @throws  IndexOutOfBoundsException\n     *          if {@code start} or {@code end} are negative,\n     *          if {@code end} is greater than {@code length()},\n     *          or if {@code start} is greater than {@code end}\n     * @spec JSR-51\n     ",
    "links" : [ "java.lang.CharSequence" ]
  }, {
    "name" : "public String substring(int start, int end)",
    "returnType" : "String",
    "comment" : "\n     * Returns a new {@code String} that contains a subsequence of\n     * characters currently contained in this sequence. The\n     * substring begins at the specified {@code start} and\n     * extends to the character at index {@code end - 1}.\n     *\n     * @param      start    The beginning index, inclusive.\n     * @param      end      The ending index, exclusive.\n     * @return     The new string.\n     * @throws     StringIndexOutOfBoundsException  if {@code start}\n     *             or {@code end} are negative or greater than\n     *             {@code length()}, or {@code start} is\n     *             greater than {@code end}.\n     ",
    "links" : [ ]
  }, {
    "name" : "private void shift(int offset, int n)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public AbstractStringBuilder insert(int index, char[] str, int offset, int len)",
    "returnType" : "AbstractStringBuilder",
    "comment" : "\n     * Inserts the string representation of a subarray of the {@code str}\n     * array argument into this sequence. The subarray begins at the\n     * specified {@code offset} and extends {@code len} {@code char}s.\n     * The characters of the subarray are inserted into this sequence at\n     * the position indicated by {@code index}. The length of this\n     * sequence increases by {@code len} {@code char}s.\n     *\n     * @param      index    position at which to insert subarray.\n     * @param      str       A {@code char} array.\n     * @param      offset   the index of the first {@code char} in subarray to\n     *             be inserted.\n     * @param      len      the number of {@code char}s in the subarray to\n     *             be inserted.\n     * @return     This object\n     * @throws     StringIndexOutOfBoundsException  if {@code index}\n     *             is negative or greater than {@code length()}, or\n     *             {@code offset} or {@code len} are negative, or\n     *             {@code (offset+len)} is greater than\n     *             {@code str.length}.\n     ",
    "links" : [ ]
  }, {
    "name" : "public AbstractStringBuilder insert(int offset, Object obj)",
    "returnType" : "AbstractStringBuilder",
    "comment" : "\n     * Inserts the string representation of the {@code Object}\n     * argument into this character sequence.\n     * <p>\n     * The overall effect is exactly as if the second argument were\n     * converted to a string by the method {@link String#valueOf(Object)},\n     * and the characters of that string were then\n     * {@link #insert(int,String) inserted} into this character\n     * sequence at the indicated offset.\n     * <p>\n     * The {@code offset} argument must be greater than or equal to\n     * {@code 0}, and less than or equal to the {@linkplain #length() length}\n     * of this sequence.\n     *\n     * @param      offset   the offset.\n     * @param      obj      an {@code Object}.\n     * @return     a reference to this object.\n     * @throws     StringIndexOutOfBoundsException  if the offset is invalid.\n     ",
    "links" : [ "java.lang.String#valueOf(Object)", "#insert(int" ]
  }, {
    "name" : "public AbstractStringBuilder insert(int offset, String str)",
    "returnType" : "AbstractStringBuilder",
    "comment" : "\n     * Inserts the string into this character sequence.\n     * <p>\n     * The characters of the {@code String} argument are inserted, in\n     * order, into this sequence at the indicated offset, moving up any\n     * characters originally above that position and increasing the length\n     * of this sequence by the length of the argument. If\n     * {@code str} is {@code null}, then the four characters\n     * {@code \"null\"} are inserted into this sequence.\n     * <p>\n     * The character at index <i>k</i> in the new character sequence is\n     * equal to:\n     * <ul>\n     * <li>the character at index <i>k</i> in the old character sequence, if\n     * <i>k</i> is less than {@code offset}\n     * <li>the character at index <i>k</i>{@code -offset} in the\n     * argument {@code str}, if <i>k</i> is not less than\n     * {@code offset} but is less than {@code offset+str.length()}\n     * <li>the character at index <i>k</i>{@code -str.length()} in the\n     * old character sequence, if <i>k</i> is not less than\n     * {@code offset+str.length()}\n     * </ul><p>\n     * The {@code offset} argument must be greater than or equal to\n     * {@code 0}, and less than or equal to the {@linkplain #length() length}\n     * of this sequence.\n     *\n     * @param      offset   the offset.\n     * @param      str      a string.\n     * @return     a reference to this object.\n     * @throws     StringIndexOutOfBoundsException  if the offset is invalid.\n     ",
    "links" : [ ]
  }, {
    "name" : "public AbstractStringBuilder insert(int offset, char[] str)",
    "returnType" : "AbstractStringBuilder",
    "comment" : "\n     * Inserts the string representation of the {@code char} array\n     * argument into this sequence.\n     * <p>\n     * The characters of the array argument are inserted into the\n     * contents of this sequence at the position indicated by\n     * {@code offset}. The length of this sequence increases by\n     * the length of the argument.\n     * <p>\n     * The overall effect is exactly as if the second argument were\n     * converted to a string by the method {@link String#valueOf(char[])},\n     * and the characters of that string were then\n     * {@link #insert(int,String) inserted} into this character\n     * sequence at the indicated offset.\n     * <p>\n     * The {@code offset} argument must be greater than or equal to\n     * {@code 0}, and less than or equal to the {@linkplain #length() length}\n     * of this sequence.\n     *\n     * @param      offset   the offset.\n     * @param      str      a character array.\n     * @return     a reference to this object.\n     * @throws     StringIndexOutOfBoundsException  if the offset is invalid.\n     ",
    "links" : [ "#insert(int", "java.lang.String#valueOf(char" ]
  }, {
    "name" : "public AbstractStringBuilder insert(int dstOffset, CharSequence s)",
    "returnType" : "AbstractStringBuilder",
    "comment" : "\n     * Inserts the specified {@code CharSequence} into this sequence.\n     * <p>\n     * The characters of the {@code CharSequence} argument are inserted,\n     * in order, into this sequence at the indicated offset, moving up\n     * any characters originally above that position and increasing the length\n     * of this sequence by the length of the argument s.\n     * <p>\n     * The result of this method is exactly the same as if it were an\n     * invocation of this object's\n     * {@link #insert(int,CharSequence,int,int) insert}(dstOffset, s, 0, s.length())\n     * method.\n     *\n     * <p>If {@code s} is {@code null}, then the four characters\n     * {@code \"null\"} are inserted into this sequence.\n     *\n     * @param      dstOffset   the offset.\n     * @param      s the sequence to be inserted\n     * @return     a reference to this object.\n     * @throws     IndexOutOfBoundsException  if the offset is invalid.\n     ",
    "links" : [ "#insert(int" ]
  }, {
    "name" : "public AbstractStringBuilder insert(int dstOffset, CharSequence s, int start, int end)",
    "returnType" : "AbstractStringBuilder",
    "comment" : "\n     * Inserts a subsequence of the specified {@code CharSequence} into\n     * this sequence.\n     * <p>\n     * The subsequence of the argument {@code s} specified by\n     * {@code start} and {@code end} are inserted,\n     * in order, into this sequence at the specified destination offset, moving\n     * up any characters originally above that position. The length of this\n     * sequence is increased by {@code end - start}.\n     * <p>\n     * The character at index <i>k</i> in this sequence becomes equal to:\n     * <ul>\n     * <li>the character at index <i>k</i> in this sequence, if\n     * <i>k</i> is less than {@code dstOffset}\n     * <li>the character at index <i>k</i>{@code +start-dstOffset} in\n     * the argument {@code s}, if <i>k</i> is greater than or equal to\n     * {@code dstOffset} but is less than {@code dstOffset+end-start}\n     * <li>the character at index <i>k</i>{@code -(end-start)} in this\n     * sequence, if <i>k</i> is greater than or equal to\n     * {@code dstOffset+end-start}\n     * </ul><p>\n     * The {@code dstOffset} argument must be greater than or equal to\n     * {@code 0}, and less than or equal to the {@linkplain #length() length}\n     * of this sequence.\n     * <p>The start argument must be nonnegative, and not greater than\n     * {@code end}.\n     * <p>The end argument must be greater than or equal to\n     * {@code start}, and less than or equal to the length of s.\n     *\n     * <p>If {@code s} is {@code null}, then this method inserts\n     * characters as if the s parameter was a sequence containing the four\n     * characters {@code \"null\"}.\n     *\n     * @param      dstOffset   the offset in this sequence.\n     * @param      s       the sequence to be inserted.\n     * @param      start   the starting index of the subsequence to be inserted.\n     * @param      end     the end index of the subsequence to be inserted.\n     * @return     a reference to this object.\n     * @throws     IndexOutOfBoundsException  if {@code dstOffset}\n     *             is negative or greater than {@code this.length()}, or\n     *              {@code start} or {@code end} are negative, or\n     *              {@code start} is greater than {@code end} or\n     *              {@code end} is greater than {@code s.length()}\n     ",
    "links" : [ ]
  }, {
    "name" : "public AbstractStringBuilder insert(int offset, boolean b)",
    "returnType" : "AbstractStringBuilder",
    "comment" : "\n     * Inserts the string representation of the {@code boolean}\n     * argument into this sequence.\n     * <p>\n     * The overall effect is exactly as if the second argument were\n     * converted to a string by the method {@link String#valueOf(boolean)},\n     * and the characters of that string were then\n     * {@link #insert(int,String) inserted} into this character\n     * sequence at the indicated offset.\n     * <p>\n     * The {@code offset} argument must be greater than or equal to\n     * {@code 0}, and less than or equal to the {@linkplain #length() length}\n     * of this sequence.\n     *\n     * @param      offset   the offset.\n     * @param      b        a {@code boolean}.\n     * @return     a reference to this object.\n     * @throws     StringIndexOutOfBoundsException  if the offset is invalid.\n     ",
    "links" : [ "java.lang.String#valueOf(boolean)", "#insert(int" ]
  }, {
    "name" : "public AbstractStringBuilder insert(int offset, char c)",
    "returnType" : "AbstractStringBuilder",
    "comment" : "\n     * Inserts the string representation of the {@code char}\n     * argument into this sequence.\n     * <p>\n     * The overall effect is exactly as if the second argument were\n     * converted to a string by the method {@link String#valueOf(char)},\n     * and the character in that string were then\n     * {@link #insert(int,String) inserted} into this character\n     * sequence at the indicated offset.\n     * <p>\n     * The {@code offset} argument must be greater than or equal to\n     * {@code 0}, and less than or equal to the {@linkplain #length() length}\n     * of this sequence.\n     *\n     * @param      offset   the offset.\n     * @param      c        a {@code char}.\n     * @return     a reference to this object.\n     * @throws     IndexOutOfBoundsException  if the offset is invalid.\n     ",
    "links" : [ "#insert(int", "java.lang.String#valueOf(char)" ]
  }, {
    "name" : "public AbstractStringBuilder insert(int offset, int i)",
    "returnType" : "AbstractStringBuilder",
    "comment" : "\n     * Inserts the string representation of the second {@code int}\n     * argument into this sequence.\n     * <p>\n     * The overall effect is exactly as if the second argument were\n     * converted to a string by the method {@link String#valueOf(int)},\n     * and the characters of that string were then\n     * {@link #insert(int,String) inserted} into this character\n     * sequence at the indicated offset.\n     * <p>\n     * The {@code offset} argument must be greater than or equal to\n     * {@code 0}, and less than or equal to the {@linkplain #length() length}\n     * of this sequence.\n     *\n     * @param      offset   the offset.\n     * @param      i        an {@code int}.\n     * @return     a reference to this object.\n     * @throws     StringIndexOutOfBoundsException  if the offset is invalid.\n     ",
    "links" : [ "#insert(int", "java.lang.String#valueOf(int)" ]
  }, {
    "name" : "public AbstractStringBuilder insert(int offset, long l)",
    "returnType" : "AbstractStringBuilder",
    "comment" : "\n     * Inserts the string representation of the {@code long}\n     * argument into this sequence.\n     * <p>\n     * The overall effect is exactly as if the second argument were\n     * converted to a string by the method {@link String#valueOf(long)},\n     * and the characters of that string were then\n     * {@link #insert(int,String) inserted} into this character\n     * sequence at the indicated offset.\n     * <p>\n     * The {@code offset} argument must be greater than or equal to\n     * {@code 0}, and less than or equal to the {@linkplain #length() length}\n     * of this sequence.\n     *\n     * @param      offset   the offset.\n     * @param      l        a {@code long}.\n     * @return     a reference to this object.\n     * @throws     StringIndexOutOfBoundsException  if the offset is invalid.\n     ",
    "links" : [ "java.lang.String#valueOf(long)", "#insert(int" ]
  }, {
    "name" : "public AbstractStringBuilder insert(int offset, float f)",
    "returnType" : "AbstractStringBuilder",
    "comment" : "\n     * Inserts the string representation of the {@code float}\n     * argument into this sequence.\n     * <p>\n     * The overall effect is exactly as if the second argument were\n     * converted to a string by the method {@link String#valueOf(float)},\n     * and the characters of that string were then\n     * {@link #insert(int,String) inserted} into this character\n     * sequence at the indicated offset.\n     * <p>\n     * The {@code offset} argument must be greater than or equal to\n     * {@code 0}, and less than or equal to the {@linkplain #length() length}\n     * of this sequence.\n     *\n     * @param      offset   the offset.\n     * @param      f        a {@code float}.\n     * @return     a reference to this object.\n     * @throws     StringIndexOutOfBoundsException  if the offset is invalid.\n     ",
    "links" : [ "#insert(int", "java.lang.String#valueOf(float)" ]
  }, {
    "name" : "public AbstractStringBuilder insert(int offset, double d)",
    "returnType" : "AbstractStringBuilder",
    "comment" : "\n     * Inserts the string representation of the {@code double}\n     * argument into this sequence.\n     * <p>\n     * The overall effect is exactly as if the second argument were\n     * converted to a string by the method {@link String#valueOf(double)},\n     * and the characters of that string were then\n     * {@link #insert(int,String) inserted} into this character\n     * sequence at the indicated offset.\n     * <p>\n     * The {@code offset} argument must be greater than or equal to\n     * {@code 0}, and less than or equal to the {@linkplain #length() length}\n     * of this sequence.\n     *\n     * @param      offset   the offset.\n     * @param      d        a {@code double}.\n     * @return     a reference to this object.\n     * @throws     StringIndexOutOfBoundsException  if the offset is invalid.\n     ",
    "links" : [ "java.lang.String#valueOf(double)", "#insert(int" ]
  }, {
    "name" : "public int indexOf(String str)",
    "returnType" : "int",
    "comment" : "\n     * Returns the index within this string of the first occurrence of the\n     * specified substring.\n     *\n     * <p>The returned index is the smallest value {@code k} for which:\n     * <pre>{@code\n     * this.toString().startsWith(str, k)\n     * }</pre>\n     * If no such value of {@code k} exists, then {@code -1} is returned.\n     *\n     * @param   str   the substring to search for.\n     * @return  the index of the first occurrence of the specified substring,\n     *          or {@code -1} if there is no such occurrence.\n     ",
    "links" : [ ]
  }, {
    "name" : "public int indexOf(String str, int fromIndex)",
    "returnType" : "int",
    "comment" : "\n     * Returns the index within this string of the first occurrence of the\n     * specified substring, starting at the specified index.\n     *\n     * <p>The returned index is the smallest value {@code k} for which:\n     * <pre>{@code\n     *     k >= Math.min(fromIndex, this.length()) &&\n     *                   this.toString().startsWith(str, k)\n     * }</pre>\n     * If no such value of {@code k} exists, then {@code -1} is returned.\n     *\n     * @param   str         the substring to search for.\n     * @param   fromIndex   the index from which to start the search.\n     * @return  the index of the first occurrence of the specified substring,\n     *          starting at the specified index,\n     *          or {@code -1} if there is no such occurrence.\n     ",
    "links" : [ ]
  }, {
    "name" : "public int lastIndexOf(String str)",
    "returnType" : "int",
    "comment" : "\n     * Returns the index within this string of the last occurrence of the\n     * specified substring.  The last occurrence of the empty string \"\" is\n     * considered to occur at the index value {@code this.length()}.\n     *\n     * <p>The returned index is the largest value {@code k} for which:\n     * <pre>{@code\n     * this.toString().startsWith(str, k)\n     * }</pre>\n     * If no such value of {@code k} exists, then {@code -1} is returned.\n     *\n     * @param   str   the substring to search for.\n     * @return  the index of the last occurrence of the specified substring,\n     *          or {@code -1} if there is no such occurrence.\n     ",
    "links" : [ ]
  }, {
    "name" : "public int lastIndexOf(String str, int fromIndex)",
    "returnType" : "int",
    "comment" : "\n     * Returns the index within this string of the last occurrence of the\n     * specified substring, searching backward starting at the specified index.\n     *\n     * <p>The returned index is the largest value {@code k} for which:\n     * <pre>{@code\n     *     k <= Math.min(fromIndex, this.length()) &&\n     *                   this.toString().startsWith(str, k)\n     * }</pre>\n     * If no such value of {@code k} exists, then {@code -1} is returned.\n     *\n     * @param   str         the substring to search for.\n     * @param   fromIndex   the index to start the search from.\n     * @return  the index of the last occurrence of the specified substring,\n     *          searching backward from the specified index,\n     *          or {@code -1} if there is no such occurrence.\n     ",
    "links" : [ ]
  }, {
    "name" : "public AbstractStringBuilder reverse()",
    "returnType" : "AbstractStringBuilder",
    "comment" : "\n     * Causes this character sequence to be replaced by the reverse of\n     * the sequence. If there are any surrogate pairs included in the\n     * sequence, these are treated as single characters for the\n     * reverse operation. Thus, the order of the high-low surrogates\n     * is never reversed.\n     *\n     * Let <i>n</i> be the character length of this character sequence\n     * (not the length in {@code char} values) just prior to\n     * execution of the {@code reverse} method. Then the\n     * character at index <i>k</i> in the new character sequence is\n     * equal to the character at index <i>n-k-1</i> in the old\n     * character sequence.\n     *\n     * <p>Note that the reverse operation may result in producing\n     * surrogate pairs that were unpaired low-surrogates and\n     * high-surrogates before the operation. For example, reversing\n     * \"\\u005CuDC00\\u005CuD800\" produces \"\\u005CuD800\\u005CuDC00\" which is\n     * a valid surrogate pair.\n     *\n     * @return  a reference to this object.\n     ",
    "links" : [ ]
  }, {
    "name" : "public abstract String toString()",
    "returnType" : "String",
    "comment" : "\n     * Returns a string representing the data in this sequence.\n     * A new {@code String} object is allocated and initialized to\n     * contain the character sequence currently represented by this\n     * object. This {@code String} is then returned. Subsequent\n     * changes to this sequence do not affect the contents of the\n     * {@code String}.\n     *\n     * @return  a string representation of this sequence of characters.\n     ",
    "links" : [ ]
  }, {
    "name" : "public IntStream chars()",
    "returnType" : "IntStream",
    "comment" : "\n     * {@inheritDoc}\n     * @since 9\n     ",
    "links" : [ ]
  }, {
    "name" : "public IntStream codePoints()",
    "returnType" : "IntStream",
    "comment" : "\n     * {@inheritDoc}\n     * @since 9\n     ",
    "links" : [ ]
  }, {
    "name" : " final byte[] getValue()",
    "returnType" : "byte[]",
    "comment" : "\n     * Needed by {@code String} for the contentEquals method.\n     ",
    "links" : [ ]
  }, {
    "name" : " void getBytes(byte[] dst, int dstBegin, byte coder)",
    "returnType" : "void",
    "comment" : "\n     * Invoker guarantees it is in UTF16 (inflate itself for asb), if two\n     * coders are different and the dstBegin has enough space\n     *\n     * @param dstBegin  the char index, not offset of byte[]\n     * @param coder     the coder of dst[]\n     ",
    "links" : [ ]
  }, {
    "name" : " void initBytes(char[] value, int off, int len)",
    "returnType" : "void",
    "comment" : " for readObject() ",
    "links" : [ ]
  }, {
    "name" : " final byte getCoder()",
    "returnType" : "byte",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : " final boolean isLatin1()",
    "returnType" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private final void putCharsAt(int index, char[] s, int off, int end)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private final void putCharsAt(int index, CharSequence s, int off, int end)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private final void putStringAt(int index, String str)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private final void appendChars(char[] s, int off, int end)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private final void appendChars(CharSequence s, int off, int end)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private static void checkRange(int start, int end, int len)",
    "returnType" : "void",
    "comment" : " IndexOutOfBoundsException, if out of bounds ",
    "links" : [ ]
  }, {
    "name" : "private static void checkRangeSIOOBE(int start, int end, int len)",
    "returnType" : "void",
    "comment" : " StringIndexOutOfBoundsException, if out of bounds ",
    "links" : [ ]
  } ],
  "methodNames" : [ " int compareTo(AbstractStringBuilder another)", "public int length()", "public int capacity()", "public void ensureCapacity(int minimumCapacity)", "private void ensureCapacityInternal(int minimumCapacity)", "private int newCapacity(int minCapacity)", "private int hugeCapacity(int minCapacity)", "private void inflate()", "public void trimToSize()", "public void setLength(int newLength)", "public char charAt(int index)", "public int codePointAt(int index)", "public int codePointBefore(int index)", "public int codePointCount(int beginIndex, int endIndex)", "public int offsetByCodePoints(int index, int codePointOffset)", "public void getChars(int srcBegin, int srcEnd, char[] dst, int dstBegin)", "public void setCharAt(int index, char ch)", "public AbstractStringBuilder append(Object obj)", "public AbstractStringBuilder append(String str)", "public AbstractStringBuilder append(StringBuffer sb)", " AbstractStringBuilder append(AbstractStringBuilder asb)", "public AbstractStringBuilder append(CharSequence s)", "private AbstractStringBuilder appendNull()", "public AbstractStringBuilder append(CharSequence s, int start, int end)", "public AbstractStringBuilder append(char[] str)", "public AbstractStringBuilder append(char[] str, int offset, int len)", "public AbstractStringBuilder append(boolean b)", "public AbstractStringBuilder append(char c)", "public AbstractStringBuilder append(int i)", "public AbstractStringBuilder append(long l)", "public AbstractStringBuilder append(float f)", "public AbstractStringBuilder append(double d)", "public AbstractStringBuilder delete(int start, int end)", "public AbstractStringBuilder appendCodePoint(int codePoint)", "public AbstractStringBuilder deleteCharAt(int index)", "public AbstractStringBuilder replace(int start, int end, String str)", "public String substring(int start)", "public CharSequence subSequence(int start, int end)", "public String substring(int start, int end)", "private void shift(int offset, int n)", "public AbstractStringBuilder insert(int index, char[] str, int offset, int len)", "public AbstractStringBuilder insert(int offset, Object obj)", "public AbstractStringBuilder insert(int offset, String str)", "public AbstractStringBuilder insert(int offset, char[] str)", "public AbstractStringBuilder insert(int dstOffset, CharSequence s)", "public AbstractStringBuilder insert(int dstOffset, CharSequence s, int start, int end)", "public AbstractStringBuilder insert(int offset, boolean b)", "public AbstractStringBuilder insert(int offset, char c)", "public AbstractStringBuilder insert(int offset, int i)", "public AbstractStringBuilder insert(int offset, long l)", "public AbstractStringBuilder insert(int offset, float f)", "public AbstractStringBuilder insert(int offset, double d)", "public int indexOf(String str)", "public int indexOf(String str, int fromIndex)", "public int lastIndexOf(String str)", "public int lastIndexOf(String str, int fromIndex)", "public AbstractStringBuilder reverse()", "public abstract String toString()", "public IntStream chars()", "public IntStream codePoints()", " final byte[] getValue()", " void getBytes(byte[] dst, int dstBegin, byte coder)", " void initBytes(char[] value, int off, int len)", " final byte getCoder()", " final boolean isLatin1()", "private final void putCharsAt(int index, char[] s, int off, int end)", "private final void putCharsAt(int index, CharSequence s, int off, int end)", "private final void putStringAt(int index, String str)", "private final void appendChars(char[] s, int off, int end)", "private final void appendChars(CharSequence s, int off, int end)", "private static void checkRange(int start, int end, int len)", "private static void checkRangeSIOOBE(int start, int end, int len)" ],
  "variableNames" : [ "value", "coder", "count", "EMPTYVALUE", "MAX_ARRAY_SIZE" ]
}