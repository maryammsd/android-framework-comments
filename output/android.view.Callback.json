{
  "filePath" : "/home/maryam/clearblue/files/android-source-35/android/view/WindowInsetsAnimation.java",
  "packageName" : "android.view",
  "className" : "Callback",
  "comment" : "\n     * Interface that allows the application to listen to animation events for windows that cause\n     * insets.\n     ",
  "links" : [ ],
  "variables" : [ {
    "name" : "DISPATCH_MODE_STOP",
    "type" : "int",
    "comment" : "\n         * Return value for {@link #getDispatchMode()}: Dispatching of animation events should\n         * stop at this level in the view hierarchy, and no animation events should be dispatch to\n         * the subtree of the view hierarchy.\n         ",
    "links" : [ "#getDispatchMode()" ]
  }, {
    "name" : "DISPATCH_MODE_CONTINUE_ON_SUBTREE",
    "type" : "int",
    "comment" : "\n         * Return value for {@link #getDispatchMode()}: Dispatching of animation events should\n         * continue in the view hierarchy.\n         ",
    "links" : [ "#getDispatchMode()" ]
  }, {
    "name" : "mDispatchMode",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  } ],
  "methods" : [ {
    "name" : "public final int getDispatchMode()",
    "returnType" : "int",
    "comment" : "\n         * Retrieves the dispatch mode of this listener. Dispatch of the all animation events is\n         * hierarchical: It will starts at the root of the view hierarchy and then traverse it and\n         * invoke the callback of the specific {@link View} that is being traversed.\n         * The method may return either {@link #DISPATCH_MODE_CONTINUE_ON_SUBTREE} to indicate that\n         * animation events should be propagated to the subtree of the view hierarchy, or\n         * {@link #DISPATCH_MODE_STOP} to stop dispatching. In that case, all animation callbacks\n         * related to the animation passed in will be stopped from propagating to the subtree of the\n         * hierarchy.\n         * <p>\n         * Also note that {@link #DISPATCH_MODE_STOP} behaves the same way as\n         * returning {@link WindowInsets#CONSUMED} during the regular insets dispatch in\n         * {@link View#onApplyWindowInsets}.\n         *\n         * @return Either {@link #DISPATCH_MODE_CONTINUE_ON_SUBTREE} to indicate that dispatching of\n         *         animation events will continue to the subtree of the view hierarchy, or\n         *         {@link #DISPATCH_MODE_STOP} to indicate that animation events will stop\n         *         dispatching.\n         ",
    "links" : [ "#DISPATCH_MODE_CONTINUE_ON_SUBTREE", "android.view.View", "android.view.View#onApplyWindowInsets", "#DISPATCH_MODE_STOP", "android.view.WindowInsets#CONSUMED" ]
  }, {
    "name" : "public void onPrepare(@NonNull WindowInsetsAnimation animation)",
    "returnType" : "void",
    "comment" : "\n         * Called when an insets animation is about to start and before the views have been laid out\n         * in the end state of the animation. The ordering of events during an insets animation is\n         * the following:\n         * <p>\n         * <ul>\n         *     <li>Application calls {@link WindowInsetsController#hide(int)},\n         *     {@link WindowInsetsController#show(int)},\n         *     {@link WindowInsetsController#controlWindowInsetsAnimation}</li>\n         *     <li>onPrepare is called on the view hierarchy listeners</li>\n         *     <li>{@link View#onApplyWindowInsets} will be called with the end state of the\n         *     animation</li>\n         *     <li>View hierarchy gets laid out according to the changes the application has\n         *     requested due to the new insets being dispatched</li>\n         *     <li>{@link #onStart} is called <em>before</em> the view\n         *     hierarchy gets drawn in the new laid out state</li>\n         *     <li>{@link #onProgress} is called immediately after with the animation start\n         *     state</li>\n         *     <li>The frame gets drawn.</li>\n         * </ul>\n         * <p>\n         * This ordering allows the application to inspect the end state after the animation has\n         * finished, and then revert to the starting state of the animation in the first\n         * {@link #onProgress} callback by using post-layout view properties like {@link View#setX}\n         * and related methods.\n         *\n         * <p>Note that the animation might be cancelled before {@link #onStart} is dispatched. On\n         * {@link android.os.Build.VERSION_CODES#S S} and later, {@link #onEnd} is immediately\n         * dispatched without an {@link #onStart} in that case.\n         * On {@link android.os.Build.VERSION_CODES#R R}, no callbacks are dispatched after\n         * {@code #onPrepare} for such an animation.\n         *\n         * <p>\n         * Note: If the animation is application controlled by using\n         * {@link WindowInsetsController#controlWindowInsetsAnimation}, the end state of the\n         * animation is undefined as the application may decide on the end state only by passing in\n         * {@code shown} parameter when calling {@link WindowInsetsAnimationController#finish}. In\n         * this situation, the system will dispatch the insets in the opposite visibility state\n         * before the animation starts. Example: When controlling the input method with\n         * {@link WindowInsetsController#controlWindowInsetsAnimation} and the input method is\n         * currently showing, {@link View#onApplyWindowInsets} will receive a {@link WindowInsets}\n         * instance for which {@link WindowInsets#isVisible} will return {@code false} for\n         * {@link WindowInsets.Type#ime}.\n         *\n         * @param animation The animation that is about to start.\n         ",
    "links" : [ "android.view.WindowInsetsController#hide(int)", "android.view.View#onApplyWindowInsets", "android.view.View#setX", "android.view.WindowInsetsController#controlWindowInsetsAnimation", "android.view.WindowInsets#isVisible", "#onEnd", "android.view.WindowInsetsAnimationController#finish", "android.os.Build.VERSION_CODES#R", "WindowInsets.Type#ime", "android.view.WindowInsetsController#show(int)", "android.os.Build.VERSION_CODES#S", "android.view.WindowInsets", "#onStart", "#onProgress" ]
  }, {
    "name" : "public Bounds onStart(@NonNull WindowInsetsAnimation animation, @NonNull Bounds bounds)",
    "returnType" : "Bounds",
    "comment" : "\n         * Called when an insets animation gets started.\n         * <p>\n         * Note that, like {@link #onProgress}, dispatch of the animation start event is\n         * hierarchical: It will starts at the root of the view hierarchy and then traverse it\n         * and invoke the callback of the specific {@link View} that is being traversed.\n         * The method may return a modified\n         * instance of the bounds by calling {@link Bounds#inset} to indicate that a part of\n         * the insets have been used to offset or clip its children, and the children shouldn't\n         * worry about that part anymore. Furthermore, if {@link #getDispatchMode()} returns\n         * {@link #DISPATCH_MODE_STOP}, children of this view will not receive the callback anymore.\n         *\n         * @param animation The animation that is about to start.\n         * @param bounds The bounds in which animation happens.\n         * @return The animation representing the part of the insets that should be dispatched to\n         *         the subtree of the hierarchy.\n         ",
    "links" : [ "android.view.View", "#getDispatchMode()", "#onProgress", "#DISPATCH_MODE_STOP", "#inset" ]
  }, {
    "name" : "public abstract WindowInsets onProgress(@NonNull WindowInsets insets, @NonNull List<WindowInsetsAnimation> runningAnimations)",
    "returnType" : "WindowInsets",
    "comment" : "\n         * Called when the insets change as part of running an animation. Note that even if multiple\n         * animations for different types are running, there will only be one progress callback per\n         * frame. The {@code insets} passed as an argument represents the overall state and will\n         * include all types, regardless of whether they are animating or not.\n         * <p>\n         * Note that insets dispatch is hierarchical: It will start at the root of the view\n         * hierarchy, and then traverse it and invoke the callback of the specific {@link View}\n         * being traversed. The method may return a modified instance by calling\n         * {@link WindowInsets#inset(int, int, int, int)} to indicate that a part of the insets have\n         * been used to offset or clip its children, and the children shouldn't worry about that\n         * part anymore. Furthermore, if {@link #getDispatchMode()} returns\n         * {@link #DISPATCH_MODE_STOP}, children of this view will not receive the callback anymore.\n         *\n         * @param insets The current insets.\n         * @param runningAnimations The currently running animations.\n         * @return The insets to dispatch to the subtree of the hierarchy.\n         ",
    "links" : [ "android.view.WindowInsets#inset(int", "android.view.View", "#getDispatchMode()", "#DISPATCH_MODE_STOP" ]
  }, {
    "name" : "public void onEnd(@NonNull WindowInsetsAnimation animation)",
    "returnType" : "void",
    "comment" : "\n         * Called when an insets animation has ended.\n         *\n         * @param animation The animation that has ended. This will be the same instance\n         *                  as passed into {@link #onStart}\n         ",
    "links" : [ "#onStart" ]
  } ],
  "methodNames" : [ "public final int getDispatchMode()", "public void onPrepare(@NonNull WindowInsetsAnimation animation)", "public Bounds onStart(@NonNull WindowInsetsAnimation animation, @NonNull Bounds bounds)", "public abstract WindowInsets onProgress(@NonNull WindowInsets insets, @NonNull List<WindowInsetsAnimation> runningAnimations)", "public void onEnd(@NonNull WindowInsetsAnimation animation)" ],
  "variableNames" : [ "DISPATCH_MODE_STOP", "DISPATCH_MODE_CONTINUE_ON_SUBTREE", "mDispatchMode" ]
}