{
  "filePath" : "/home/maryam/clearblue/files/android-source-35/java/util/random/RandomGenerator.java",
  "packageName" : "java.util.random",
  "className" : "RandomGenerator",
  "comment" : "\n * The {@link RandomGenerator} interface is designed to provide a common\n * protocol for objects that generate random or (more typically) pseudorandom\n * sequences of numbers (or Boolean values). Such a sequence may be obtained by\n * either repeatedly invoking a method that returns a single pseudorandomly\n * chosen value, or by invoking a method that returns a stream of\n * pseudorandomly chosen values.\n *\n * <p> Ideally, given an implicitly or explicitly specified range of values,\n * each value would be chosen independently and uniformly from that range. In\n * practice, one may have to settle for some approximation to independence and\n * uniformity.\n *\n * <p> In the case of {@code int}, {@code long}, and {@code boolean} values, if\n * there is no explicit specification of range, then the range includes all\n * possible values of the type. In the case of {@code float} and {@code double}\n * values, first a value is always chosen uniformly from the set of\n * 2<sup><i>w</i></sup> values between 0.0 (inclusive) and 1.0 (exclusive),\n * where <i>w</i> is 23 for {@code float} values and 52 for {@code double}\n * values, such that adjacent values differ by 2<sup>&minus;<i>w</i></sup>\n * (notice that this set is a <i>subset</i> of the set of\n * <i>all representable floating-point values</i> between 0.0 (inclusive) and 1.0 (exclusive));\n * then if an explicit range was specified, then the chosen number is\n * computationally scaled and translated so as to appear to have been chosen\n * approximately uniformly from that explicit range.\n *\n * <p> Each method that returns a stream produces a stream of values each of\n * which is chosen in the same manner as for a method that returns a single\n * pseudorandomly chosen value. For example, if {@code r} implements\n * {@link RandomGenerator}, then the method call {@code r.ints(100)} returns a\n * stream of 100 {@code int} values. These are not necessarily the exact same\n * values that would have been returned if instead {@code r.nextInt()} had been\n * called 100 times; all that is guaranteed is that each value in the stream is\n * chosen in a similar pseudorandom manner from the same range.\n *\n * <p> Every object that implements the {@link RandomGenerator} interface by\n * using a pseudorandom algorithm is assumed to contain a finite amount of\n * state. Using such an object to generate a pseudorandomly chosen value alters\n * its state by computing a new state as a function of the current state,\n * without reference to any information other than the current state. The number\n * of distinct possible states of such an object is called its <i>period</i>.\n * (Some implementations of the {@link RandomGenerator} interface may be truly\n * random rather than pseudorandom, for example relying on the statistical\n * behavior of a physical object to derive chosen values. Such implementations\n * do not have a fixed period.)\n *\n * <p> As a rule, objects that implement the {@link RandomGenerator} interface\n * need not be thread-safe. It is recommended that multithreaded applications\n * use either {@link ThreadLocalRandom} or (preferably) pseudorandom number\n * generators that implement the {@link SplittableGenerator} or\n * {@link JumpableGenerator} interface.\n *\n * <p> Objects that implement {@link RandomGenerator} are typically not\n * cryptographically secure. Consider instead using {@link SecureRandom} to get\n * a cryptographically secure pseudorandom number generator for use by\n * security-sensitive applications. Note, however, that {@link SecureRandom}\n * does implement the {@link RandomGenerator} interface, so that instances of\n * {@link SecureRandom} may be used interchangeably with other types of\n * pseudorandom generators in applications that do not require a secure\n * generator.\n *\n * <p>Unless explicit stated otherwise, the use of null for any method argument\n * will cause a NullPointerException.\n *\n * @since 17\n *\n ",
  "links" : [ "java.util.random.RandomGenerator", "java.security.SecureRandom", "java.util.concurrent.ThreadLocalRandom", "JumpableGenerator", "SplittableGenerator" ],
  "variables" : [ ],
  "methods" : [ {
    "name" : " static RandomGenerator of(String name)",
    "returnType" : "RandomGenerator",
    "comment" : "\n     * Returns an instance of {@link RandomGenerator} that utilizes the\n     * {@code name} <a href=\"package-summary.html#algorithms\">algorithm</a>.\n     *\n     * @param name  Name of random number generator\n     *              <a href=\"package-summary.html#algorithms\">algorithm</a>\n     *\n     * @return An instance of {@link RandomGenerator}\n     *\n     * @throws NullPointerException if name is null\n     * @throws IllegalArgumentException if the named algorithm is not found\n     ",
    "links" : [ "java.util.random.RandomGenerator" ]
  }, {
    "name" : " static RandomGenerator getDefault()",
    "returnType" : "RandomGenerator",
    "comment" : "\n     * Returns a {@link RandomGenerator} meeting the minimal requirement\n     * of having an <a href=\"package-summary.html#algorithms\">algorithm</a>\n     * whose state bits are greater than or equal 64.\n     *\n     * @implSpec  Since algorithms will improve over time, there is no\n     * guarantee that this method will return the same algorithm over time.\n     * <p> The default implementation selects L32X64MixRandom.\n     *\n     * @return a {@link RandomGenerator}\n     ",
    "links" : [ "java.util.random.RandomGenerator" ]
  }, {
    "name" : " boolean isDeprecated()",
    "returnType" : "boolean",
    "comment" : "\n     * Return true if the implementation of RandomGenerator (algorithm) has been\n     * marked for deprecation.\n     *\n     * @implNote Random number generator algorithms evolve over time; new\n     * algorithms will be introduced and old algorithms will\n     * lose standing. If an older algorithm is deemed unsuitable\n     * for continued use, it will be marked as deprecated to indicate\n     * that it may be removed at some point in the future.\n     *\n     * @return true if the implementation of RandomGenerator (algorithm) has been\n     *         marked for deprecation\n     *\n     * @implSpec The default implementation checks for the @Deprecated annotation.\n     ",
    "links" : [ ]
  }, {
    "name" : " DoubleStream doubles()",
    "returnType" : "DoubleStream",
    "comment" : "\n     * Returns an effectively unlimited stream of pseudorandomly chosen\n     * {@code double} values.\n     *\n     * @return a stream of pseudorandomly chosen {@code double} values\n     *\n     * @implNote It is permitted to implement this method in a manner equivalent to\n     * {@link RandomGenerator#doubles(long) doubles}\n     * ({@link Long#MAX_VALUE Long.MAX_VALUE}).\n     *\n     * @implSpec The default implementation produces a sequential stream\n     * that repeatedly calls {@link RandomGenerator#nextDouble nextDouble}().\n     ",
    "links" : [ "#MAX_VALUE", "java.util.random.RandomGenerator#doubles(long)", "java.util.random.RandomGenerator#nextDouble" ]
  }, {
    "name" : " DoubleStream doubles(double randomNumberOrigin, double randomNumberBound)",
    "returnType" : "DoubleStream",
    "comment" : "\n     * Returns an effectively unlimited stream of pseudorandomly chosen\n     * {@code double} values, where each value is between the specified origin\n     * (inclusive) and the specified bound (exclusive).\n     *\n     * @param randomNumberOrigin the least value that can be produced\n     * @param randomNumberBound the upper bound (exclusive) for each value produced\n     *\n     * @return a stream of pseudorandomly chosen {@code double} values, each between\n     *         the specified origin (inclusive) and the specified bound (exclusive)\n     *\n     * @throws IllegalArgumentException if {@code randomNumberOrigin} is not finite,\n     *         or {@code randomNumberBound} is not finite, or {@code randomNumberOrigin}\n     *         is greater than or equal to {@code randomNumberBound}\n     *\n     * @implNote It is permitted to implement this method in a manner equivalent to\n     * {@link RandomGenerator#doubles(long, double, double) doubles}\n     * ({@link Long#MAX_VALUE Long.MAX_VALUE}, randomNumberOrigin, randomNumberBound).\n     *\n     * @implSpec The default implementation produces a sequential stream that repeatedly\n     * calls {@link RandomGenerator#nextDouble(double, double) nextDouble}(randomNumberOrigin, randomNumberBound).\n     ",
    "links" : [ "java.util.random.RandomGenerator#doubles(long", "java.util.random.RandomGenerator#nextDouble(double", "#MAX_VALUE" ]
  }, {
    "name" : " DoubleStream doubles(long streamSize)",
    "returnType" : "DoubleStream",
    "comment" : "\n     * Returns a stream producing the given {@code streamSize} number of\n     * pseudorandomly chosen {@code double} values.\n     *\n     * @param streamSize the number of values to generate\n     *\n     * @return a stream of pseudorandomly chosen {@code double} values\n     *\n     * @throws IllegalArgumentException if {@code streamSize} is\n     *         less than zero\n     *\n     * @implSpec The default implementation produces a sequential stream\n     * that repeatedly calls {@link RandomGenerator#nextDouble nextDouble()}.\n     ",
    "links" : [ "java.util.random.RandomGenerator#nextDouble" ]
  }, {
    "name" : " DoubleStream doubles(long streamSize, double randomNumberOrigin, double randomNumberBound)",
    "returnType" : "DoubleStream",
    "comment" : "\n     * Returns a stream producing the given {@code streamSize} number of\n     * pseudorandomly chosen {@code double} values, where each value is\n     * between the specified origin (inclusive) and the specified bound\n     * (exclusive).\n     *\n     * @param streamSize the number of values to generate\n     * @param randomNumberOrigin the least value that can be produced\n     * @param randomNumberBound the upper bound (exclusive) for each value produced\n     *\n     * @return a stream of pseudorandomly chosen {@code double} values, each between\n     *         the specified origin (inclusive) and the specified bound (exclusive)\n     *\n     * @throws IllegalArgumentException if {@code streamSize} is less than zero,\n     *         or {@code randomNumberOrigin} is not finite,\n     *         or {@code randomNumberBound} is not finite, or {@code randomNumberOrigin}\n     *         is greater than or equal to {@code randomNumberBound}\n     *\n     * @implSpec The default implementation produces a sequential stream that repeatedly\n     * calls {@link RandomGenerator#nextDouble(double, double)  nextDouble}(randomNumberOrigin, randomNumberBound).\n     ",
    "links" : [ "java.util.random.RandomGenerator#nextDouble(double" ]
  }, {
    "name" : " IntStream ints()",
    "returnType" : "IntStream",
    "comment" : "\n     * Returns an effectively unlimited stream of pseudorandomly chosen\n     * {@code int} values.\n     *\n     * @return a stream of pseudorandomly chosen {@code int} values\n     *\n     * @implNote It is permitted to implement this method in a manner\n     * equivalent to {@link RandomGenerator#ints(long) ints}\n     * ({@link Long#MAX_VALUE Long.MAX_VALUE}).\n     *\n     * @implSpec The default implementation produces a sequential stream\n     * that repeatedly calls {@link RandomGenerator#nextInt() nextInt}().\n     ",
    "links" : [ "#MAX_VALUE", "java.util.random.RandomGenerator#nextInt()", "java.util.random.RandomGenerator#ints(long)" ]
  }, {
    "name" : " IntStream ints(int randomNumberOrigin, int randomNumberBound)",
    "returnType" : "IntStream",
    "comment" : "\n     * Returns an effectively unlimited stream of pseudorandomly chosen\n     * {@code int} values, where each value is between the specified origin\n     * (inclusive) and the specified bound (exclusive).\n     *\n     * @param randomNumberOrigin the least value that can be produced\n     * @param randomNumberBound the upper bound (exclusive) for each value produced\n     *\n     * @return a stream of pseudorandomly chosen {@code int} values, each between\n     *         the specified origin (inclusive) and the specified bound (exclusive)\n     *\n     * @throws IllegalArgumentException if {@code randomNumberOrigin}\n     *         is greater than or equal to {@code randomNumberBound}\n     *\n     * @implNote It is permitted to implement this method in a manner equivalent to\n     * {@link RandomGenerator#ints(long, int, int) ints}\n     * ({@link Long#MAX_VALUE Long.MAX_VALUE}, randomNumberOrigin, randomNumberBound).\n     *\n     * @implSpec The default implementation produces a sequential stream that repeatedly\n     * calls {@link RandomGenerator#nextInt(int, int) nextInt}(randomNumberOrigin, randomNumberBound).\n     ",
    "links" : [ "java.util.random.RandomGenerator#ints(long", "#MAX_VALUE", "java.util.random.RandomGenerator#nextInt(int" ]
  }, {
    "name" : " IntStream ints(long streamSize)",
    "returnType" : "IntStream",
    "comment" : "\n     * Returns a stream producing the given {@code streamSize} number of\n     * pseudorandomly chosen {@code int} values.\n     *\n     * @param streamSize the number of values to generate\n     *\n     * @return a stream of pseudorandomly chosen {@code int} values\n     *\n     * @throws IllegalArgumentException if {@code streamSize} is\n     *         less than zero\n     *\n     * @implSpec The default implementation produces a sequential stream\n     * that repeatedly calls {@link RandomGenerator#nextInt() nextInt}().\n     ",
    "links" : [ "java.util.random.RandomGenerator#nextInt()" ]
  }, {
    "name" : " IntStream ints(long streamSize, int randomNumberOrigin, int randomNumberBound)",
    "returnType" : "IntStream",
    "comment" : "\n     * Returns a stream producing the given {@code streamSize} number of\n     * pseudorandomly chosen {@code int} values, where each value is between\n     * the specified origin (inclusive) and the specified bound (exclusive).\n     *\n     * @param streamSize the number of values to generate\n     * @param randomNumberOrigin the least value that can be produced\n     * @param randomNumberBound the upper bound (exclusive) for each value produced\n     *\n     * @return a stream of pseudorandomly chosen {@code int} values, each between\n     *         the specified origin (inclusive) and the specified bound (exclusive)\n     *\n     * @throws IllegalArgumentException if {@code streamSize} is\n     *         less than zero, or {@code randomNumberOrigin}\n     *         is greater than or equal to {@code randomNumberBound}\n     *\n     * @implSpec The default implementation produces a sequential stream that repeatedly\n     * calls {@link RandomGenerator#nextInt(int, int) nextInt}(randomNumberOrigin, randomNumberBound).\n     ",
    "links" : [ "java.util.random.RandomGenerator#nextInt(int" ]
  }, {
    "name" : " LongStream longs()",
    "returnType" : "LongStream",
    "comment" : "\n     * Returns an effectively unlimited stream of pseudorandomly chosen\n     * {@code long} values.\n     *\n     * @return a stream of pseudorandomly chosen {@code long} values\n     *\n     * @implNote It is permitted to implement this method in a manner\n     * equivalent to {@link RandomGenerator#longs(long) longs}\n     * ({@link Long#MAX_VALUE Long.MAX_VALUE}).\n     *\n     * @implSpec The default implementation produces a sequential stream\n     * that repeatedly calls {@link RandomGenerator#nextLong() nextLong}().\n     ",
    "links" : [ "java.util.random.RandomGenerator#longs(long)", "#MAX_VALUE", "java.util.random.RandomGenerator#nextLong()" ]
  }, {
    "name" : " LongStream longs(long randomNumberOrigin, long randomNumberBound)",
    "returnType" : "LongStream",
    "comment" : "\n     * Returns an effectively unlimited stream of pseudorandomly chosen\n     * {@code long} values, where each value is between the specified origin\n     * (inclusive) and the specified bound (exclusive).\n     *\n     * @param randomNumberOrigin the least value that can be produced\n     * @param randomNumberBound the upper bound (exclusive) for each value produced\n     *\n     * @return a stream of pseudorandomly chosen {@code long} values, each between\n     *         the specified origin (inclusive) and the specified bound (exclusive)\n     *\n     * @throws IllegalArgumentException if {@code randomNumberOrigin}\n     *         is greater than or equal to {@code randomNumberBound}\n     *\n     * @implNote It is permitted to implement this method in a manner equivalent to\n     * {@link RandomGenerator#longs(long, long, long) longs}\n     * ({@link Long#MAX_VALUE Long.MAX_VALUE}, randomNumberOrigin, randomNumberBound).\n     *\n     * @implSpec The default implementation produces a sequential stream that repeatedly\n     * calls {@link RandomGenerator#nextLong(long, long) nextLong}(randomNumberOrigin, randomNumberBound).\n     ",
    "links" : [ "java.util.random.RandomGenerator#longs(long", "#MAX_VALUE", "java.util.random.RandomGenerator#nextLong(long" ]
  }, {
    "name" : " LongStream longs(long streamSize)",
    "returnType" : "LongStream",
    "comment" : "\n     * Returns a stream producing the given {@code streamSize} number of\n     * pseudorandomly chosen {@code long} values.\n     *\n     * @param streamSize the number of values to generate\n     *\n     * @return a stream of pseudorandomly chosen {@code long} values\n     *\n     * @throws IllegalArgumentException if {@code streamSize} is\n     *         less than zero\n     *\n     * @implSpec The default implementation produces a sequential stream\n     * that repeatedly calls {@link RandomGenerator#nextLong() nextLong}().\n     ",
    "links" : [ "java.util.random.RandomGenerator#nextLong()" ]
  }, {
    "name" : " LongStream longs(long streamSize, long randomNumberOrigin, long randomNumberBound)",
    "returnType" : "LongStream",
    "comment" : "\n     * Returns a stream producing the given {@code streamSize} number of\n     * pseudorandomly chosen {@code long} values, where each value is between\n     * the specified origin (inclusive) and the specified bound (exclusive).\n     *\n     * @param streamSize the number of values to generate\n     * @param randomNumberOrigin the least value that can be produced\n     * @param randomNumberBound the upper bound (exclusive) for each value produced\n     *\n     * @return a stream of pseudorandomly chosen {@code long} values, each between\n     *         the specified origin (inclusive) and the specified bound (exclusive)\n     *\n     * @throws IllegalArgumentException if {@code streamSize} is\n     *         less than zero, or {@code randomNumberOrigin}\n     *         is greater than or equal to {@code randomNumberBound}\n     *\n     * @implSpec The default implementation produces a sequential stream that repeatedly\n     * calls {@link RandomGenerator#nextLong(long, long) nextLong}(randomNumberOrigin, randomNumberBound).\n     ",
    "links" : [ "java.util.random.RandomGenerator#nextLong(long" ]
  }, {
    "name" : " boolean nextBoolean()",
    "returnType" : "boolean",
    "comment" : "\n     * Returns a pseudorandomly chosen {@code boolean} value.\n     *\n     * <p> The default implementation tests the high-order bit (sign bit) of a\n     * value produced by {@link RandomGenerator#nextInt() nextInt}(), on the\n     * grounds that some algorithms for pseudorandom number generation produce\n     * values whose high-order bits have better statistical quality than the\n     * low-order bits.\n     *\n     * @return a pseudorandomly chosen {@code boolean} value\n     *\n     * @implSpec The default implementation produces a result based on the\n     * sign bit of a number generated by {@link #nextInt()}.\n     ",
    "links" : [ "java.util.random.RandomGenerator#nextInt()", "#nextInt()" ]
  }, {
    "name" : " void nextBytes(byte[] bytes)",
    "returnType" : "void",
    "comment" : "\n     * Fills a user-supplied byte array with generated byte values\n     * pseudorandomly chosen uniformly from the range of values between -128\n     * (inclusive) and 127 (inclusive).\n     *\n     * @implNote Algorithm used to fill the byte array;\n     *           <pre>{@code\n     *           void nextBytes(byte[] bytes) {\n     *               int i = 0;\n     *               int len = bytes.length;\n     *               for (int words = len >> 3; words--> 0; ) {\n     *                   long rnd = nextLong();\n     *                   for (int n = 8; n--> 0; rnd >>>= Byte.SIZE)\n     *                       bytes[i++] = (byte)rnd;\n     *               }\n     *               if (i < len)\n     *                   for (long rnd = nextLong(); i < len; rnd >>>= Byte.SIZE)\n     *                       bytes[i++] = (byte)rnd;\n     *           }}</pre>\n     *\n     * @param  bytes the byte array to fill with pseudorandom bytes\n     * @throws NullPointerException if bytes is null\n     *\n     * @implSpec The default implementation produces results from repeated calls\n     * to {@link #nextLong()}.\n     ",
    "links" : [ "#nextLong()" ]
  }, {
    "name" : " float nextFloat()",
    "returnType" : "float",
    "comment" : "\n     * Returns a pseudorandom {@code float} value between zero (inclusive) and\n     * one (exclusive).\n     *\n     * @return a pseudorandom {@code float} value between zero (inclusive) and one (exclusive)\n     *\n     * @implSpec The default implementation uses the 24 high-order bits from a call to\n     * {@link RandomGenerator#nextInt() nextInt}().\n     ",
    "links" : [ "java.util.random.RandomGenerator#nextInt()" ]
  }, {
    "name" : " float nextFloat(float bound)",
    "returnType" : "float",
    "comment" : "\n     * Returns a pseudorandomly chosen {@code float} value between zero\n     * (inclusive) and the specified bound (exclusive).\n     *\n     * @param bound the upper bound (exclusive) for the returned value.\n     *        Must be positive and finite\n     *\n     * @return a pseudorandomly chosen {@code float} value between\n     *         zero (inclusive) and the bound (exclusive)\n     *\n     * @throws IllegalArgumentException if {@code bound} is not\n     *         both positive and finite\n     *\n     * @implSpec The default implementation checks that {@code bound} is a\n     * positive finite float. Then invokes {@code nextFloat()}, scaling\n     * the result so that the final result lies between {@code 0.0f} (inclusive)\n     * and {@code bound} (exclusive).\n     ",
    "links" : [ ]
  }, {
    "name" : " float nextFloat(float origin, float bound)",
    "returnType" : "float",
    "comment" : "\n     * Returns a pseudorandomly chosen {@code float} value between the\n     * specified origin (inclusive) and the specified bound (exclusive).\n     *\n     * @param origin the least value that can be returned\n     * @param bound the upper bound (exclusive)\n     *\n     * @return a pseudorandomly chosen {@code float} value between the\n     *         origin (inclusive) and the bound (exclusive)\n     *\n     * @throws IllegalArgumentException if {@code origin} is not finite,\n     *         or {@code bound} is not finite, or {@code origin}\n     *         is greater than or equal to {@code bound}\n     *\n     * @implSpec The default implementation checks that {@code origin} and\n     * {@code bound} are positive finite floats. Then invokes\n     * {@code nextFloat()}, scaling and translating the result so that the final\n     * result lies between {@code origin} (inclusive) and {@code bound}\n     * (exclusive).\n     ",
    "links" : [ ]
  }, {
    "name" : " double nextDouble()",
    "returnType" : "double",
    "comment" : "\n     * Returns a pseudorandom {@code double} value between zero (inclusive) and\n     * one (exclusive).\n     *\n     * @return a pseudorandom {@code double} value between zero (inclusive)\n     *         and one (exclusive)\n     *\n     * @implSpec The default implementation uses the 53 high-order bits from a call to\n     * {@link RandomGenerator#nextLong nextLong}().\n     ",
    "links" : [ "java.util.random.RandomGenerator#nextLong" ]
  }, {
    "name" : " double nextDouble(double bound)",
    "returnType" : "double",
    "comment" : "\n     * Returns a pseudorandomly chosen {@code double} value between zero\n     * (inclusive) and the specified bound (exclusive).\n     *\n     * @param bound the upper bound (exclusive) for the returned value.\n     *        Must be positive and finite\n     *\n     * @return a pseudorandomly chosen {@code double} value between\n     *         zero (inclusive) and the bound (exclusive)\n     *\n     * @throws IllegalArgumentException if {@code bound} is not\n     *         both positive and finite\n     *\n     * @implSpec The default implementation checks that {@code bound} is a\n     * positive finite double. Then invokes {@code nextDouble()}, scaling\n     * the result so that the final result lies between {@code 0.0} (inclusive)\n     * and {@code bound} (exclusive).\n     ",
    "links" : [ ]
  }, {
    "name" : " double nextDouble(double origin, double bound)",
    "returnType" : "double",
    "comment" : "\n     * Returns a pseudorandomly chosen {@code double} value between the\n     * specified origin (inclusive) and the specified bound (exclusive).\n     *\n     * @param origin the least value that can be returned\n     * @param bound the upper bound (exclusive) for the returned value\n     *\n     * @return a pseudorandomly chosen {@code double} value between the\n     *         origin (inclusive) and the bound (exclusive)\n     *\n     * @throws IllegalArgumentException if {@code origin} is not finite,\n     *         or {@code bound} is not finite, or {@code origin}\n     *         is greater than or equal to {@code bound}\n     *\n     * @implSpec The default implementation checks that {@code origin} and\n     * {@code bound} are positive finite doubles. Then calls\n     * {@code nextDouble()}, scaling and translating the result so that the final\n     * result lies between {@code origin} (inclusive) and {@code bound}\n     * (exclusive).\n     ",
    "links" : [ ]
  }, {
    "name" : " int nextInt()",
    "returnType" : "int",
    "comment" : "\n     * Returns a pseudorandomly chosen {@code int} value.\n     *\n     * @return a pseudorandomly chosen {@code int} value\n     *\n     * @implSpec The default implementation uses the 32 high-order bits from a call to\n     * {@link RandomGenerator#nextLong nextLong}().\n     ",
    "links" : [ "java.util.random.RandomGenerator#nextLong" ]
  }, {
    "name" : " int nextInt(int bound)",
    "returnType" : "int",
    "comment" : "\n     * Returns a pseudorandomly chosen {@code int} value between zero\n     * (inclusive) and the specified bound (exclusive).\n     *\n     * @param bound the upper bound (exclusive) for the returned value.\n     * Must be positive.\n     *\n     * @return a pseudorandomly chosen {@code int} value between\n     *         zero (inclusive) and the bound (exclusive)\n     *\n     * @throws IllegalArgumentException if {@code bound} is not positive\n     *\n     * @implSpec The default implementation checks that {@code bound} is a\n     * positive {@code int}. Then invokes {@code nextInt()}, limiting the result\n     * to be greater than or equal zero and less than {@code bound}. If {@code bound}\n     * is a power of two then limiting is a simple masking operation. Otherwise,\n     * the result is re-calculated by invoking {@code nextInt()} until the\n     * result is greater than or equal zero and less than {@code bound}.\n     ",
    "links" : [ ]
  }, {
    "name" : " int nextInt(int origin, int bound)",
    "returnType" : "int",
    "comment" : "\n     * Returns a pseudorandomly chosen {@code int} value between the specified\n     * origin (inclusive) and the specified bound (exclusive).\n     *\n     * @param origin the least value that can be returned\n     * @param bound the upper bound (exclusive) for the returned value\n     *\n     * @return a pseudorandomly chosen {@code int} value between the\n     *         origin (inclusive) and the bound (exclusive)\n     *\n     * @throws IllegalArgumentException if {@code origin} is greater than\n     *         or equal to {@code bound}\n     *\n     * @implSpec The default implementation checks that {@code origin} and\n     * {@code bound} are positive {@code ints}. Then invokes {@code nextInt()},\n     * limiting the result to be greater that or equal {@code origin} and less\n     * than {@code bound}. If {@code bound} is a power of two then limiting is a\n     * simple masking operation. Otherwise, the result is re-calculated  by\n     * invoking {@code nextInt()} until the result is greater than or equal\n     * {@code origin} and less than {@code bound}.\n     ",
    "links" : [ ]
  }, {
    "name" : " long nextLong()",
    "returnType" : "long",
    "comment" : "\n     * Returns a pseudorandomly chosen {@code long} value.\n     *\n     * @return a pseudorandomly chosen {@code long} value\n     ",
    "links" : [ ]
  }, {
    "name" : " long nextLong(long bound)",
    "returnType" : "long",
    "comment" : "\n     * Returns a pseudorandomly chosen {@code long} value between zero\n     * (inclusive) and the specified bound (exclusive).\n     *\n     * @param bound the upper bound (exclusive) for the returned value.\n     * Must be positive.\n     *\n     * @return a pseudorandomly chosen {@code long} value between\n     *         zero (inclusive) and the bound (exclusive)\n     *\n     * @throws IllegalArgumentException if {@code bound} is not positive\n     *\n     * @implSpec The default implementation checks that {@code bound} is a\n     * positive  {@code long}. Then invokes {@code nextLong()}, limiting the\n     * result to be greater than or equal zero and less than {@code bound}. If\n     * {@code bound} is a power of two then limiting is a simple masking\n     * operation. Otherwise, the result is re-calculated by invoking\n     * {@code nextLong()} until the result is greater than or equal zero and\n     * less than {@code bound}.\n     ",
    "links" : [ ]
  }, {
    "name" : " long nextLong(long origin, long bound)",
    "returnType" : "long",
    "comment" : "\n     * Returns a pseudorandomly chosen {@code long} value between the\n     * specified origin (inclusive) and the specified bound (exclusive).\n     *\n     * @param origin the least value that can be returned\n     * @param bound the upper bound (exclusive) for the returned value\n     *\n     * @return a pseudorandomly chosen {@code long} value between the\n     *         origin (inclusive) and the bound (exclusive)\n     *\n     * @throws IllegalArgumentException if {@code origin} is greater than\n     *         or equal to {@code bound}\n     *\n     * @implSpec The default implementation checks that {@code origin} and\n     * {@code bound} are positive {@code longs}. Then invokes {@code nextLong()},\n     * limiting the result to be greater than or equal {@code origin} and less\n     * than {@code bound}. If {@code bound} is a power of two then limiting is a\n     * simple masking operation. Otherwise, the result is re-calculated by\n     * invoking {@code nextLong()} until the result is greater than or equal\n     * {@code origin} and less than {@code bound}.\n     ",
    "links" : [ ]
  }, {
    "name" : " double nextGaussian()",
    "returnType" : "double",
    "comment" : "\n     * Returns a {@code double} value pseudorandomly chosen from a Gaussian\n     * (normal) distribution whose mean is 0 and whose standard deviation is 1.\n     *\n     * @return a {@code double} value pseudorandomly chosen from a\n     *         Gaussian distribution\n     *\n     * @implSpec The default implementation uses McFarland's fast modified\n     * ziggurat algorithm (largely table-driven, with rare cases handled by\n     * computation and rejection sampling). Walker's alias method for sampling\n     * a discrete distribution also plays a role.\n     ",
    "links" : [ ]
  }, {
    "name" : " double nextGaussian(double mean, double stddev)",
    "returnType" : "double",
    "comment" : "\n     * Returns a {@code double} value pseudorandomly chosen from a Gaussian\n     * (normal) distribution with a mean and standard deviation specified by the\n     * arguments.\n     *\n     * @param mean the mean of the Gaussian distribution to be drawn from\n     * @param stddev the standard deviation (square root of the variance)\n     *        of the Gaussian distribution to be drawn from\n     *\n     * @return a {@code double} value pseudorandomly chosen from the\n     *         specified Gaussian distribution\n     *\n     * @throws IllegalArgumentException if {@code stddev} is negative\n     *\n     * @implSpec The default implementation uses McFarland's fast modified\n     * ziggurat algorithm (largely table-driven, with rare cases handled by\n     * computation and rejection sampling). Walker's alias method for sampling\n     * a discrete distribution also plays a role.\n     ",
    "links" : [ ]
  }, {
    "name" : " double nextExponential()",
    "returnType" : "double",
    "comment" : "\n     * Returns a nonnegative {@code double} value pseudorandomly chosen from\n     * an exponential distribution whose mean is 1.\n     *\n     * @return a nonnegative {@code double} value pseudorandomly chosen from an\n     *         exponential distribution\n     *\n     * @implSpec The default implementation uses McFarland's fast modified\n     * ziggurat algorithm (largely table-driven, with rare cases handled by\n     * computation and rejection sampling). Walker's alias method for sampling\n     * a discrete distribution also plays a role.\n     ",
    "links" : [ ]
  } ],
  "methodNames" : [ " static RandomGenerator of(String name)", " static RandomGenerator getDefault()", " boolean isDeprecated()", " DoubleStream doubles()", " DoubleStream doubles(double randomNumberOrigin, double randomNumberBound)", " DoubleStream doubles(long streamSize)", " DoubleStream doubles(long streamSize, double randomNumberOrigin, double randomNumberBound)", " IntStream ints()", " IntStream ints(int randomNumberOrigin, int randomNumberBound)", " IntStream ints(long streamSize)", " IntStream ints(long streamSize, int randomNumberOrigin, int randomNumberBound)", " LongStream longs()", " LongStream longs(long randomNumberOrigin, long randomNumberBound)", " LongStream longs(long streamSize)", " LongStream longs(long streamSize, long randomNumberOrigin, long randomNumberBound)", " boolean nextBoolean()", " void nextBytes(byte[] bytes)", " float nextFloat()", " float nextFloat(float bound)", " float nextFloat(float origin, float bound)", " double nextDouble()", " double nextDouble(double bound)", " double nextDouble(double origin, double bound)", " int nextInt()", " int nextInt(int bound)", " int nextInt(int origin, int bound)", " long nextLong()", " long nextLong(long bound)", " long nextLong(long origin, long bound)", " double nextGaussian()", " double nextGaussian(double mean, double stddev)", " double nextExponential()" ],
  "variableNames" : [ ]
}