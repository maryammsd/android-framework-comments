{
  "filePath" : "/home/maryam/clearblue/files/android-source-35/android/media/tv/tuner/Tuner.java",
  "packageName" : "android.media.tv.tuner",
  "className" : "Tuner",
  "comment" : "\n * This class is used to interact with hardware tuners devices.\n *\n * <p> Each TvInputService Session should create one instance of this class.\n *\n * <p> This class controls the TIS interaction with Tuner HAL.\n *\n * @hide\n ",
  "links" : [ ],
  "variables" : [ {
    "name" : "INVALID_TS_PID",
    "type" : "int",
    "comment" : "\n     * Invalid TS packet ID.\n     ",
    "links" : [ ]
  }, {
    "name" : "INVALID_STREAM_ID",
    "type" : "int",
    "comment" : "\n     * Invalid stream ID.\n     ",
    "links" : [ ]
  }, {
    "name" : "INVALID_FILTER_ID",
    "type" : "int",
    "comment" : "\n     * Invalid filter ID.\n     ",
    "links" : [ ]
  }, {
    "name" : "INVALID_AV_SYNC_ID",
    "type" : "int",
    "comment" : "\n     * Invalid AV Sync ID.\n     ",
    "links" : [ ]
  }, {
    "name" : "INVALID_TIMESTAMP",
    "type" : "long",
    "comment" : "\n     * Invalid timestamp.\n     *\n     * <p>Returned by {@link android.media.tv.tuner.filter.TimeFilter#getSourceTime()},\n     * {@link android.media.tv.tuner.filter.TimeFilter#getTimeStamp()},\n     * {@link Tuner#getAvSyncTime(int)} or {@link TsRecordEvent#getPts()} and\n     * {@link MmtpRecordEvent#getPts()} when the requested timestamp is not available.\n     *\n     * @see android.media.tv.tuner.filter.TimeFilter#getSourceTime()\n     * @see android.media.tv.tuner.filter.TimeFilter#getTimeStamp()\n     * @see Tuner#getAvSyncTime(int)\n     * @see android.media.tv.tuner.filter.TsRecordEvent#getPts()\n     * @see android.media.tv.tuner.filter.MmtpRecordEvent#getPts()\n     ",
    "links" : [ "android.media.tv.tuner.MmtpRecordEvent#getPts()", "android.media.tv.tuner.TsRecordEvent#getPts()", "android.media.tv.tuner.filter.TimeFilter#getSourceTime()", "android.media.tv.tuner.Tuner#getAvSyncTime(int)", "android.media.tv.tuner.filter.TimeFilter#getTimeStamp()" ]
  }, {
    "name" : "INVALID_MMTP_RECORD_EVENT_MPT_SEQUENCE_NUM",
    "type" : "int",
    "comment" : "\n     * Invalid mpu sequence number in MmtpRecordEvent.\n     *\n     * <p>Returned by {@link MmtpRecordEvent#getMpuSequenceNumber()} when the requested sequence\n     * number is not available.\n     *\n     * @see android.media.tv.tuner.filter.MmtpRecordEvent#getMpuSequenceNumber()\n     ",
    "links" : [ "android.media.tv.tuner.MmtpRecordEvent#getMpuSequenceNumber()" ]
  }, {
    "name" : "INVALID_FIRST_MACROBLOCK_IN_SLICE",
    "type" : "int",
    "comment" : "\n     * Invalid first macroblock address in MmtpRecordEvent and TsRecordEvent.\n     *\n     * <p>Returned by {@link MmtpRecordEvent#getMbInSlice()} and\n     * {@link TsRecordEvent#getMbInSlice()} when the requested sequence number is not available.\n     *\n     * @see android.media.tv.tuner.filter.MmtpRecordEvent#getMbInSlice()\n     * @see android.media.tv.tuner.filter.TsRecordEvent#getMbInSlice()\n     ",
    "links" : [ "android.media.tv.tuner.TsRecordEvent#getMbInSlice()", "android.media.tv.tuner.MmtpRecordEvent#getMbInSlice()" ]
  }, {
    "name" : "INVALID_LTS_ID",
    "type" : "int",
    "comment" : "\n     * Invalid local transport stream id.\n     *\n     * <p>Returned by {@link #linkFrontendToCiCam(int)} when the requested failed\n     * or the hal implementation does not support the operation.\n     *\n     * @see #linkFrontendToCiCam(int)\n     ",
    "links" : [ "#linkFrontendToCiCam(int)" ]
  }, {
    "name" : "INVALID_FILTER_ID_LONG",
    "type" : "long",
    "comment" : "\n     * Invalid 64-bit filter ID.\n     ",
    "links" : [ ]
  }, {
    "name" : "INVALID_FRONTEND_SETTING_FREQUENCY",
    "type" : "int",
    "comment" : "\n     * Invalid frequency that is used as the default frontend frequency setting.\n     ",
    "links" : [ ]
  }, {
    "name" : "INVALID_FRONTEND_ID",
    "type" : "int",
    "comment" : "\n     * Invalid frontend id.\n     ",
    "links" : [ ]
  }, {
    "name" : "INVALID_LNB_ID",
    "type" : "int",
    "comment" : "\n     * Invalid LNB id.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "VOID_KEYTOKEN",
    "type" : "byte[]",
    "comment" : "\n     * A void key token. It is used to remove the current key from descrambler.\n     *\n     * <p>If the current keyToken comes from a MediaCas session, App is recommended to\n     * to use this constant to remove current key before closing MediaCas session.\n     ",
    "links" : [ ]
  }, {
    "name" : "SCAN_TYPE_UNDEFINED",
    "type" : "int",
    "comment" : "\n     * Scan type undefined.\n     ",
    "links" : [ ]
  }, {
    "name" : "SCAN_TYPE_AUTO",
    "type" : "int",
    "comment" : "\n     * Scan type auto.\n     *\n     * <p> Tuner will send {@link android.media.tv.tuner.frontend.ScanCallback#onLocked}\n     ",
    "links" : [ "android.media.tv.tuner.frontend.ScanCallback#onLocked" ]
  }, {
    "name" : "SCAN_TYPE_BLIND",
    "type" : "int",
    "comment" : "\n     * Blind scan.\n     *\n     * <p>Frequency range is not specified. The {@link android.media.tv.tuner.Tuner} will scan an\n     * implementation specific range.\n     ",
    "links" : [ "android.media.tv.tuner.Tuner" ]
  }, {
    "name" : "RESULT_SUCCESS",
    "type" : "int",
    "comment" : "\n     * Operation succeeded.\n     ",
    "links" : [ ]
  }, {
    "name" : "RESULT_UNAVAILABLE",
    "type" : "int",
    "comment" : "\n     * Operation failed because the corresponding resources are not available.\n     ",
    "links" : [ ]
  }, {
    "name" : "RESULT_NOT_INITIALIZED",
    "type" : "int",
    "comment" : "\n     * Operation failed because the corresponding resources are not initialized.\n     ",
    "links" : [ ]
  }, {
    "name" : "RESULT_INVALID_STATE",
    "type" : "int",
    "comment" : "\n     * Operation failed because it's not in a valid state.\n     ",
    "links" : [ ]
  }, {
    "name" : "RESULT_INVALID_ARGUMENT",
    "type" : "int",
    "comment" : "\n     * Operation failed because there are invalid arguments.\n     ",
    "links" : [ ]
  }, {
    "name" : "RESULT_OUT_OF_MEMORY",
    "type" : "int",
    "comment" : "\n     * Memory allocation failed.\n     ",
    "links" : [ ]
  }, {
    "name" : "RESULT_UNKNOWN_ERROR",
    "type" : "int",
    "comment" : "\n     * Operation failed due to unknown errors.\n     ",
    "links" : [ ]
  }, {
    "name" : "TAG",
    "type" : "String",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "DEBUG",
    "type" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "MSG_RESOURCE_LOST",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "MSG_ON_FILTER_EVENT",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "MSG_ON_FILTER_STATUS",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "MSG_ON_LNB_EVENT",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "FILTER_CLEANUP_THRESHOLD",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "DVR_TYPE_RECORD",
    "type" : "int",
    "comment" : "\n     * DVR for recording.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "DVR_TYPE_PLAYBACK",
    "type" : "int",
    "comment" : "\n     * DVR for playback of recorded programs.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "mContext",
    "type" : "Context",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mTunerResourceManager",
    "type" : "TunerResourceManager",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mClientId",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "sTunerVersion",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mDesiredDemuxInfo",
    "type" : "DemuxInfo",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mFrontend",
    "type" : "Frontend",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mHandler",
    "type" : "EventHandler",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mFrontendInfo",
    "type" : "FrontendInfo",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mFrontendHandle",
    "type" : "Integer",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mFeOwnerTuner",
    "type" : "Tuner",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mFrontendType",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mDesiredFrontendId",
    "type" : "Integer",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mUserId",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mLnb",
    "type" : "Lnb",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mLnbHandle",
    "type" : "Integer",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mOnTuneEventListener",
    "type" : "OnTuneEventListener",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mOnTuneEventExecutor",
    "type" : "Executor",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mScanCallback",
    "type" : "ScanCallback",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mScanCallbackExecutor",
    "type" : "Executor",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mOnResourceLostListener",
    "type" : "OnResourceLostListener",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mOnResourceLostListenerExecutor",
    "type" : "Executor",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mOnTuneEventLock",
    "type" : "Object",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mScanCallbackLock",
    "type" : "Object",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mOnResourceLostListenerLock",
    "type" : "Object",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mFrontendLock",
    "type" : "ReentrantLock",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mLnbLock",
    "type" : "ReentrantLock",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mFrontendCiCamLock",
    "type" : "ReentrantLock",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mDemuxLock",
    "type" : "ReentrantLock",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mRequestedCiCamId",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mDemuxHandle",
    "type" : "Integer",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mFrontendCiCamHandle",
    "type" : "Integer",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mFrontendCiCamId",
    "type" : "Integer",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mDescramblers",
    "type" : "Map<Integer, WeakReference<Descrambler>>",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mFilters",
    "type" : "List<WeakReference<Filter>>",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mResourceListener",
    "type" : "TunerResourceManager.ResourcesReclaimListener",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mNativeContext",
    "type" : "long",
    "comment" : " used by native jMediaTuner",
    "links" : [ ]
  } ],
  "methods" : [ {
    "name" : "private FrontendInfo[] getFrontendInfoListInternal()",
    "returnType" : "FrontendInfo[]",
    "comment" : "\n     * Get frontend info list from native and build them into a {@link FrontendInfo} list. Any\n     * {@code null} FrontendInfo element would be removed.\n     ",
    "links" : [ "android.media.tv.tuner.frontend.FrontendInfo" ]
  }, {
    "name" : "public static int getTunerVersion()",
    "returnType" : "int",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "public List<Integer> getFrontendIds()",
    "returnType" : "List<Integer>",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "public void setResourceLostListener(@NonNull @CallbackExecutor Executor executor, @NonNull OnResourceLostListener listener)",
    "returnType" : "void",
    "comment" : "\n     * Sets the listener for resource lost.\n     *\n     * @param executor the executor on which the listener should be invoked.\n     * @param listener the listener that will be run.\n     ",
    "links" : [ ]
  }, {
    "name" : "public void clearResourceLostListener()",
    "returnType" : "void",
    "comment" : "\n     * Removes the listener for resource lost.\n     ",
    "links" : [ ]
  }, {
    "name" : "public void shareFrontendFromTuner(@NonNull Tuner tuner)",
    "returnType" : "void",
    "comment" : "\n     * Shares the frontend resource with another Tuner instance\n     *\n     * @param tuner the Tuner instance to share frontend resource with.\n     ",
    "links" : [ ]
  }, {
    "name" : "public int transferOwner(@NonNull Tuner newOwner)",
    "returnType" : "int",
    "comment" : "\n     * Transfers the ownership of shared frontend and its associated resources.\n     *\n     * @param newOwner the Tuner instance to be the new owner.\n     *\n     * @return result status of tune operation.\n     ",
    "links" : [ ]
  }, {
    "name" : "private void replicateFrontendSettings(@Nullable Tuner src)",
    "returnType" : "void",
    "comment" : "\n     * Resets or copies Frontend related settings.\n     ",
    "links" : [ ]
  }, {
    "name" : "private void setFrontendOwner(Tuner owner)",
    "returnType" : "void",
    "comment" : "\n     * Sets the frontend owner. mFeOwnerTuner should be null for the owner Tuner instance.\n     ",
    "links" : [ ]
  }, {
    "name" : "private void replicateCiCamSettings(@Nullable Tuner src)",
    "returnType" : "void",
    "comment" : "\n     * Resets or copies the CiCam related settings.\n     ",
    "links" : [ ]
  }, {
    "name" : "private void replicateLnbSettings(@Nullable Tuner src)",
    "returnType" : "void",
    "comment" : "\n     * Resets or copies Lnb related settings.\n     ",
    "links" : [ ]
  }, {
    "name" : "private boolean isFrontendOwner()",
    "returnType" : "boolean",
    "comment" : "\n     * Checks if it is a frontend resource owner.\n     * Proper mutex must be held prior to calling this.\n     ",
    "links" : [ ]
  }, {
    "name" : "private boolean isNewOwnerQualifiedForTransfer(@NonNull Tuner newOwner)",
    "returnType" : "boolean",
    "comment" : "\n     * Checks if the newOwner is qualified.\n     * Proper mutex must be held prior to calling this.\n     ",
    "links" : [ ]
  }, {
    "name" : "private int transferFeOwner(@NonNull Tuner newOwner)",
    "returnType" : "int",
    "comment" : "\n     * Transfers the ownership of the already held frontend resource.\n     * Proper mutex must be held prior to calling this.\n     ",
    "links" : [ ]
  }, {
    "name" : "private int transferCiCamOwner(Tuner newOwner)",
    "returnType" : "int",
    "comment" : "\n     * Transfers the ownership of CiCam resource.\n     * This is a no-op if the CiCam resource is not held.\n     * Proper mutex must be held prior to calling this.\n     ",
    "links" : [ ]
  }, {
    "name" : "private int transferLnbOwner(Tuner newOwner)",
    "returnType" : "int",
    "comment" : "\n     * Transfers the ownership of Lnb resource.\n     * This is a no-op if the Lnb resource is not held.\n     * Proper mutex must be held prior to calling this.\n     ",
    "links" : [ ]
  }, {
    "name" : "public void updateResourcePriority(int priority, int niceValue)",
    "returnType" : "void",
    "comment" : "\n     * Updates client priority with an arbitrary value along with a nice value.\n     *\n     * <p>Tuner resource manager (TRM) uses the client priority value to decide whether it is able\n     * to reclaim insufficient resources from another client.\n     *\n     * <p>The nice value represents how much the client intends to give up the resource when an\n     * insufficient resource situation happens.\n     *\n     * @param priority the new priority. Any negative value would cause no-op on priority setting\n     *                 and the API would only process nice value setting in that case.\n     * @param niceValue the nice value.\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean hasUnusedFrontend(int frontendType)",
    "returnType" : "boolean",
    "comment" : "\n     * Checks if there is an unused frontend resource available.\n     *\n     * @param frontendType {@link android.media.tv.tuner.frontend.FrontendSettings.Type} for the\n     * query to be done for.\n     ",
    "links" : [ "android.media.tv.tuner.frontend.FrontendSettings.Type" ]
  }, {
    "name" : "public boolean isLowestPriority(int frontendType)",
    "returnType" : "boolean",
    "comment" : "\n     * Checks if the calling Tuner object has the lowest priority as a client to\n     * {@link TunerResourceManager}\n     *\n     * <p>The priority comparison is done against the current holders of the frontend resource.\n     *\n     * <p>The behavior of this function is independent of the availability of unused resources.\n     *\n     * <p>The function returns {@code true} in any of the following sceanrios:\n     * <ul>\n     * <li>The caller has the priority <= other clients</li>\n     * <li>No one is holding the frontend resource of the specified type</li>\n     * <li>The caller is the only one who is holding the resource</li>\n     * <li>The frontend resource of the specified type does not exist</li>\n     *\n     * </ul>\n     * @param frontendType {@link android.media.tv.tuner.frontend.FrontendSettings.Type} for the\n     * query to be done for.\n     *\n     * @return {@code false} only if someone else with strictly lower priority is holding the\n     *         resourece.\n     *         {@code true} otherwise.\n     ",
    "links" : [ "android.media.tv.tuner.frontend.FrontendSettings.Type", "android.media.tv.tunerresourcemanager.TunerResourceManager" ]
  }, {
    "name" : "private void registerFrontendCallbackListener(Tuner tuner)",
    "returnType" : "void",
    "comment" : "\n     * Registers a tuner as a listener for frontend callbacks.\n     ",
    "links" : [ ]
  }, {
    "name" : "private void unregisterFrontendCallbackListener(Tuner tuner)",
    "returnType" : "void",
    "comment" : "\n     * Unregisters a tuner as a listener for frontend callbacks.\n     ",
    "links" : [ ]
  }, {
    "name" : " long getNativeContext()",
    "returnType" : "long",
    "comment" : "\n     * Returns the pointer to the associated JTuner.\n     ",
    "links" : [ ]
  }, {
    "name" : "public void close()",
    "returnType" : "void",
    "comment" : "\n     * Releases the Tuner instance.\n     ",
    "links" : [ ]
  }, {
    "name" : "public void closeFrontend()",
    "returnType" : "void",
    "comment" : "\n     * Either unshares the frontend resource (for sharee) or release Frontend (for owner)\n     ",
    "links" : [ ]
  }, {
    "name" : "private void releaseFrontend()",
    "returnType" : "void",
    "comment" : "\n     * Releases frontend resource for the owner. Unshares frontend resource for the sharee.\n     ",
    "links" : [ ]
  }, {
    "name" : "private void releaseCiCam()",
    "returnType" : "void",
    "comment" : "\n     * Releases CiCam resource if held. No-op otherwise.\n     ",
    "links" : [ ]
  }, {
    "name" : "private void closeLnb()",
    "returnType" : "void",
    "comment" : "\n     * Releases Lnb resource if held. TRMS lock must be acquired prior to calling this function.\n     ",
    "links" : [ ]
  }, {
    "name" : "private void releaseFilters()",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private void releaseDescramblers()",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private void releaseDemux()",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private void releaseAll()",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private static native void nativeInit()",
    "returnType" : "void",
    "comment" : "\n     * Native Initialization.\n     ",
    "links" : [ ]
  }, {
    "name" : "private native void nativeSetup()",
    "returnType" : "void",
    "comment" : "\n     * Native setup.\n     ",
    "links" : [ ]
  }, {
    "name" : "private native int nativeGetTunerVersion()",
    "returnType" : "int",
    "comment" : "\n     * Native method to get all frontend IDs.\n     ",
    "links" : [ ]
  }, {
    "name" : "private native List<Integer> nativeGetFrontendIds()",
    "returnType" : "List<Integer>",
    "comment" : "\n     * Native method to get all frontend IDs.\n     ",
    "links" : [ ]
  }, {
    "name" : "private native Frontend nativeOpenFrontendByHandle(int handle)",
    "returnType" : "Frontend",
    "comment" : "\n     * Native method to open frontend of the given ID.\n     ",
    "links" : [ ]
  }, {
    "name" : "private native int nativeShareFrontend(int id)",
    "returnType" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private native int nativeUnshareFrontend()",
    "returnType" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private native void nativeRegisterFeCbListener(long nativeContext)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private native void nativeUnregisterFeCbListener(long nativeContext)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private native void nativeUpdateFrontend(long nativeContext)",
    "returnType" : "void",
    "comment" : " nativeUpdateFrontend must be called on the new owner first",
    "links" : [ ]
  }, {
    "name" : "private native int nativeTune(int type, FrontendSettings settings)",
    "returnType" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private native int nativeStopTune()",
    "returnType" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private native int nativeScan(int settingsType, FrontendSettings settings, int scanType)",
    "returnType" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private native int nativeStopScan()",
    "returnType" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private native int nativeSetLnb(Lnb lnb)",
    "returnType" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private native boolean nativeIsLnaSupported()",
    "returnType" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private native int nativeSetLna(boolean enable)",
    "returnType" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private native FrontendStatus nativeGetFrontendStatus(int[] statusTypes)",
    "returnType" : "FrontendStatus",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private native Integer nativeGetAvSyncHwId(Filter filter)",
    "returnType" : "Integer",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private native Long nativeGetAvSyncTime(int avSyncId)",
    "returnType" : "Long",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private native int nativeConnectCiCam(int ciCamId)",
    "returnType" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private native int nativeLinkCiCam(int ciCamId)",
    "returnType" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private native int nativeDisconnectCiCam()",
    "returnType" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private native int nativeUnlinkCiCam(int ciCamId)",
    "returnType" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private native FrontendInfo nativeGetFrontendInfo(int id)",
    "returnType" : "FrontendInfo",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private native Filter nativeOpenFilter(int type, int subType, long bufferSize)",
    "returnType" : "Filter",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private native TimeFilter nativeOpenTimeFilter()",
    "returnType" : "TimeFilter",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private native String nativeGetFrontendHardwareInfo()",
    "returnType" : "String",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private native int nativeSetMaxNumberOfFrontends(int frontendType, int maxNumber)",
    "returnType" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private native int nativeGetMaxNumberOfFrontends(int frontendType)",
    "returnType" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private native int nativeRemoveOutputPid(int pid)",
    "returnType" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private native Lnb nativeOpenLnbByHandle(int handle)",
    "returnType" : "Lnb",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private native Lnb nativeOpenLnbByName(String name)",
    "returnType" : "Lnb",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private native FrontendStatusReadiness[] nativeGetFrontendStatusReadiness(int[] statusTypes)",
    "returnType" : "FrontendStatusReadiness[]",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private native Descrambler nativeOpenDescramblerByHandle(int handle)",
    "returnType" : "Descrambler",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private native int nativeOpenDemuxByhandle(int handle)",
    "returnType" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private native DvrRecorder nativeOpenDvrRecorder(long bufferSize)",
    "returnType" : "DvrRecorder",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private native DvrPlayback nativeOpenDvrPlayback(long bufferSize)",
    "returnType" : "DvrPlayback",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private native DemuxCapabilities nativeGetDemuxCapabilities()",
    "returnType" : "DemuxCapabilities",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private native DemuxInfo nativeGetDemuxInfo(int demuxHandle)",
    "returnType" : "DemuxInfo",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private native int nativeCloseDemux(int handle)",
    "returnType" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private native int nativeCloseFrontend(int handle)",
    "returnType" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private native int nativeClose()",
    "returnType" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private static native SharedFilter nativeOpenSharedFilter(String token)",
    "returnType" : "SharedFilter",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private EventHandler createEventHandler()",
    "returnType" : "EventHandler",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public void setOnTuneEventListener(@NonNull @CallbackExecutor Executor executor, @NonNull OnTuneEventListener eventListener)",
    "returnType" : "void",
    "comment" : "\n     * Listens for tune events.\n     *\n     * <p>\n     * Tuner events are started when {@link #tune(FrontendSettings)} is called and end when {@link\n     * #cancelTuning()} is called.\n     *\n     * @param eventListener receives tune events.\n     * @throws SecurityException if the caller does not have appropriate permissions.\n     * @see #tune(FrontendSettings)\n     ",
    "links" : [ "#cancelTuning()", "#tune(FrontendSettings)" ]
  }, {
    "name" : "public void clearOnTuneEventListener()",
    "returnType" : "void",
    "comment" : "\n     * Clears the {@link OnTuneEventListener} and its associated {@link Executor}.\n     *\n     * @throws SecurityException if the caller does not have appropriate permissions.\n     * @see #setOnTuneEventListener(Executor, OnTuneEventListener)\n     ",
    "links" : [ "android.media.tv.tuner.frontend.OnTuneEventListener", "android.annotation.CallbackExecutor" ]
  }, {
    "name" : "public int tune(@NonNull FrontendSettings settings)",
    "returnType" : "int",
    "comment" : "\n     * Tunes the frontend to using the settings given.\n     *\n     * <p>Tuner resource manager (TRM) uses the client priority value to decide whether it is able\n     * to get frontend resource. If the client can't get the resource, this call returns {@link\n     * #RESULT_UNAVAILABLE}.\n     *\n     * <p>\n     * This locks the frontend to a frequency by providing signal\n     * delivery information. If previous tuning isn't completed, this stop the previous tuning, and\n     * start a new tuning.\n     *\n     * <p>\n     * Tune is an async call, with {@link OnTuneEventListener#SIGNAL_LOCKED} and {@link\n     * OnTuneEventListener#SIGNAL_NO_SIGNAL} events sent to the {@link OnTuneEventListener}\n     * specified in {@link #setOnTuneEventListener(Executor, OnTuneEventListener)}.\n     *\n     * <p>Tuning with {@link android.media.tv.tuner.frontend.DtmbFrontendSettings} is only\n     * supported in Tuner 1.1 or higher version. Unsupported version will cause no-op. Use {@link\n     * TunerVersionChecker#getTunerVersion()} to get the version information.\n     *\n     * <p>Tuning with {@link\n     * android.media.tv.tuner.frontend.IsdbtFrontendSettings.PartialReceptionFlag} or {@link\n     * android.media.tv.tuner.frontend.IsdbtFrontendSettings.IsdbtLayerSettings} is only supported\n     * in Tuner 2.0 or higher version. Unsupported version will cause no-op. Use {@link\n     * TunerVersionChecker#getTunerVersion()} to get the version information.\n     *\n     * <p>Tuning with {@link\n     * android.media.tv.tuner.frontend.IptvFrontendSettings} is only supported\n     * in Tuner 3.0 or higher version. Unsupported version will cause no-op. Use {@link\n     * TunerVersionChecker#getTunerVersion()} to get the version information.\n     *\n     * @param settings Signal delivery information the frontend uses to\n     *                 search and lock the signal.\n     * @return result status of tune operation.\n     * @throws SecurityException if the caller does not have appropriate permissions.\n     * @see #setOnTuneEventListener(Executor, OnTuneEventListener)\n     ",
    "links" : [ "#setOnTuneEventListener(Executor", "android.media.tv.tuner.frontend.OnTuneEventListener", "android.media.tv.tuner.frontend.OnTuneEventListener#SIGNAL_NO_SIGNAL", "android.media.tv.tuner.frontend.OnTuneEventListener#SIGNAL_LOCKED", "android.media.tv.tuner.TunerVersionChecker#getTunerVersion()", "android.media.tv.tuner.frontend.DtmbFrontendSettings", "android.media.tv.tuner.frontend.IsdbtFrontendSettings.IsdbtLayerSettings", "android.media.tv.tuner.frontend.IptvFrontendSettings", "android.media.tv.tuner.frontend.IsdbtFrontendSettings.PartialReceptionFlag", "#RESULT_UNAVAILABLE" ]
  }, {
    "name" : "public int cancelTuning()",
    "returnType" : "int",
    "comment" : "\n     * Stops a previous tuning.\n     *\n     * <p>If the method completes successfully, the frontend is no longer tuned and no data\n     * will be sent to attached filters.\n     *\n     * @return result status of the operation.\n     ",
    "links" : [ ]
  }, {
    "name" : "public int scan(@NonNull FrontendSettings settings, @ScanType int scanType, @NonNull @CallbackExecutor Executor executor, @NonNull ScanCallback scanCallback)",
    "returnType" : "int",
    "comment" : "\n     * Scan for channels.\n     *\n     * <p>Details for channels found are returned via {@link ScanCallback}.\n     *\n     * <p>Scanning with {@link android.media.tv.tuner.frontend.DtmbFrontendSettings} is only\n     * supported in Tuner 1.1 or higher version. Unsupported version will cause no-op. Use {@link\n     * TunerVersionChecker#getTunerVersion()} to get the version information.\n     *\n     * * <p>Scanning with {@link\n     * android.media.tv.tuner.frontend.IsdbtFrontendSettings.PartialReceptionFlag} or {@link\n     * android.media.tv.tuner.frontend.IsdbtFrontendSettings.IsdbtLayerSettings} is only supported\n     * in Tuner 2.0 or higher version. Unsupported version will cause no-op. Use {@link\n     * TunerVersionChecker#getTunerVersion()} to get the version information.\n     *\n     * @param settings A {@link FrontendSettings} to configure the frontend.\n     * @param scanType The scan type.\n     * @throws SecurityException     if the caller does not have appropriate permissions.\n     * @throws IllegalStateException if {@code scan} is called again before\n     *                               {@link #cancelScanning()} is called.\n     ",
    "links" : [ "android.media.tv.tuner.frontend.FrontendSettings", "android.media.tv.tuner.TunerVersionChecker#getTunerVersion()", "android.media.tv.tuner.frontend.DtmbFrontendSettings", "android.media.tv.tuner.frontend.IsdbtFrontendSettings.IsdbtLayerSettings", "android.media.tv.tuner.frontend.ScanCallback", "android.media.tv.tuner.frontend.IsdbtFrontendSettings.PartialReceptionFlag", "#cancelScanning()" ]
  }, {
    "name" : "public int cancelScanning()",
    "returnType" : "int",
    "comment" : "\n     * Stops a previous scanning.\n     *\n     * <p>\n     * The {@link ScanCallback} and it's {@link Executor} will be removed.\n     *\n     * <p>\n     * If the method completes successfully, the frontend stopped previous scanning.\n     *\n     * @throws SecurityException if the caller does not have appropriate permissions.\n     ",
    "links" : [ "android.media.tv.tuner.frontend.ScanCallback", "android.annotation.CallbackExecutor" ]
  }, {
    "name" : "private boolean requestFrontend()",
    "returnType" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private int setLnb(@NonNull Lnb lnb)",
    "returnType" : "int",
    "comment" : "\n     * Sets Low-Noise Block downconverter (LNB) for satellite frontend.\n     *\n     * <p>This assigns a hardware LNB resource to the satellite tuner. It can be\n     * called multiple times to update LNB assignment.\n     *\n     * @param lnb the LNB instance.\n     *\n     * @return result status of the operation.\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean isLnaSupported()",
    "returnType" : "boolean",
    "comment" : "\n     * Is Low Noise Amplifier (LNA) supported by the Tuner.\n     *\n     * <p>This API is only supported by Tuner HAL 3.0 or higher.\n     * Unsupported version would throw UnsupportedOperationException. Use\n     * {@link TunerVersionChecker#getTunerVersion()} to check the version.\n     *\n     * @return {@code true} if supported, otherwise {@code false}.\n     * @throws UnsupportedOperationException if the Tuner HAL version is lower than 3.0\n     * @see android.media.tv.tuner.TunerVersionChecker#TUNER_VERSION_3_0\n     ",
    "links" : [ "android.media.tv.tuner.TunerVersionChecker#getTunerVersion()" ]
  }, {
    "name" : "public int setLnaEnabled(boolean enable)",
    "returnType" : "int",
    "comment" : "\n     * Enable or Disable Low Noise Amplifier (LNA).\n     *\n     * @param enable {@code true} to activate LNA module; {@code false} to deactivate LNA.\n     *\n     * @return result status of the operation. {@link #RESULT_UNAVAILABLE} if the device doesn't\n     *         support LNA.\n     ",
    "links" : [ "#RESULT_UNAVAILABLE" ]
  }, {
    "name" : "public FrontendStatus getFrontendStatus(@NonNull @FrontendStatusType int[] statusTypes)",
    "returnType" : "FrontendStatus",
    "comment" : "\n     * Gets the statuses of the frontend.\n     *\n     * <p>This retrieve the statuses of the frontend for given status types.\n     *\n     * @param statusTypes an array of status types which the caller requests. Any types that are not\n     *        in {@link FrontendInfo#getStatusCapabilities()} would be ignored.\n     * @return statuses which response the caller's requests. {@code null} if the operation failed.\n     ",
    "links" : [ "android.media.tv.tuner.frontend.FrontendInfo#getStatusCapabilities()" ]
  }, {
    "name" : "public int getAvSyncHwId(@NonNull Filter filter)",
    "returnType" : "int",
    "comment" : "\n     * Gets hardware sync ID for audio and video.\n     *\n     * @param filter the filter instance for the hardware sync ID.\n     * @return the id of hardware A/V sync.\n     ",
    "links" : [ ]
  }, {
    "name" : "public long getAvSyncTime(int avSyncHwId)",
    "returnType" : "long",
    "comment" : "\n     * Gets the current timestamp for Audio/Video sync\n     *\n     * <p>The timestamp is maintained by hardware. The timestamp based on 90KHz, and it's format is\n     * the same as PTS (Presentation Time Stamp).\n     *\n     * @param avSyncHwId the hardware id of A/V sync.\n     * @return the current timestamp of hardware A/V sync.\n     ",
    "links" : [ ]
  }, {
    "name" : "public int connectCiCam(int ciCamId)",
    "returnType" : "int",
    "comment" : "\n     * Connects Conditional Access Modules (CAM) through Common Interface (CI).\n     *\n     * <p>The demux uses the output from the frontend as the input by default, and must change to\n     * use the output from CI-CAM as the input after this call.\n     *\n     * <p> Note that this API is used to connect the CI-CAM to the Demux module while\n     * {@link #connectFrontendToCiCam(int)} is used to connect CI-CAM to the Frontend module.\n     *\n     * @param ciCamId specify CI-CAM Id to connect.\n     * @return result status of the operation.\n     ",
    "links" : [ "#connectFrontendToCiCam(int)" ]
  }, {
    "name" : "public int connectFrontendToCiCam(int ciCamId)",
    "returnType" : "int",
    "comment" : "\n     * Connect Conditional Access Modules (CAM) Frontend to support Common Interface (CI)\n     * by-pass mode.\n     *\n     * <p>It is used by the client to link CI-CAM to a Frontend. CI by-pass mode requires that\n     * the CICAM also receives the TS concurrently from the frontend when the Demux is receiving\n     * the TS directly from the frontend.\n     *\n     * <p> Note that this API is used to connect the CI-CAM to the Frontend module while\n     * {@link #connectCiCam(int)} is used to connect CI-CAM to the Demux module.\n     *\n     * <p>Use {@link #disconnectFrontendToCiCam(int)} to disconnect.\n     *\n     * <p>This API is only supported by Tuner HAL 1.1 or higher. Unsupported version would cause\n     * no-op and return {@link #INVALID_LTS_ID}. Use {@link TunerVersionChecker#getTunerVersion()}\n     * to check the version.\n     *\n     * @param ciCamId specify CI-CAM Id, which is the id of the Conditional Access Modules (CAM)\n     *                Common Interface (CI), to link.\n     * @return Local transport stream id when connection is successfully established. Failed\n     *         operation returns {@link #INVALID_LTS_ID} while unsupported version also returns\n     *         {@link #INVALID_LTS_ID}. Check the current HAL version using\n     *         {@link TunerVersionChecker#getTunerVersion()}.\n     ",
    "links" : [ "android.media.tv.tuner.TunerVersionChecker#getTunerVersion()", "#connectCiCam(int)", "#INVALID_LTS_ID", "#disconnectFrontendToCiCam(int)" ]
  }, {
    "name" : "public int disconnectCiCam()",
    "returnType" : "int",
    "comment" : "\n     * Disconnects Conditional Access Modules (CAM).\n     *\n     * <p>The demux will use the output from the frontend as the input after this call.\n     *\n     * <p> Note that this API is used to disconnect the CI-CAM to the Demux module while\n     * {@link #disconnectFrontendToCiCam(int)} is used to disconnect CI-CAM to the Frontend module.\n     *\n     * @return result status of the operation.\n     ",
    "links" : [ "#disconnectFrontendToCiCam(int)" ]
  }, {
    "name" : "public int disconnectFrontendToCiCam(int ciCamId)",
    "returnType" : "int",
    "comment" : "\n     * Disconnect Conditional Access Modules (CAM) Frontend.\n     *\n     * <p>It is used by the client to unlink CI-CAM to a Frontend.\n     *\n     * <p> Note that this API is used to disconnect the CI-CAM to the Demux module while\n     * {@link #disconnectCiCam(int)} is used to disconnect CI-CAM to the Frontend module.\n     *\n     * <p>This API is only supported by Tuner HAL 1.1 or higher. Unsupported version would cause\n     * no-op. Use {@link TunerVersionChecker#getTunerVersion()} to check the version.\n     *\n     * @param ciCamId specify CI-CAM Id, which is the id of the Conditional Access Modules (CAM)\n     *                Common Interface (CI), to disconnect.\n     * @return result status of the operation. Unsupported version would return\n     *         {@link #RESULT_UNAVAILABLE}\n     ",
    "links" : [ "android.media.tv.tuner.TunerVersionChecker#getTunerVersion()", "#disconnectCiCam(int)", "#RESULT_UNAVAILABLE" ]
  }, {
    "name" : "public int removeOutputPid(@IntRange(from = 0) int pid)",
    "returnType" : "int",
    "comment" : "\n     * Remove PID (packet identifier) from frontend output.\n     *\n     * <p>It is used by the client to remove a video or audio PID of other program to reduce the\n     * total amount of recorded TS.\n     *\n     * <p>This API is only supported by Tuner HAL 2.0 or higher. Unsupported version would cause\n     * no-op. Use {@link TunerVersionChecker#getTunerVersion()} to check the version.\n     *\n     * @return result status of the operation. Unsupported version or if current active frontend\n     *         doesn’t support PID filtering out would return {@link #RESULT_UNAVAILABLE}.\n     * @throws IllegalStateException if there is no active frontend currently.\n     ",
    "links" : [ "android.media.tv.tuner.TunerVersionChecker#getTunerVersion()", "#RESULT_UNAVAILABLE" ]
  }, {
    "name" : "public List<FrontendStatusReadiness> getFrontendStatusReadiness(@NonNull @FrontendStatusType int[] statusTypes)",
    "returnType" : "List<FrontendStatusReadiness>",
    "comment" : "\n     * Gets Frontend Status Readiness statuses for given status types.\n     *\n     * <p>This API is only supported by Tuner HAL 2.0 or higher. Unsupported versions would cause\n     * no-op. Use {@link TunerVersionChecker#getTunerVersion()} to check the version.\n     *\n     * @param statusTypes an array of status types.\n     *\n     * @return a list of current readiness states. It is empty if the operation fails or unsupported\n     *         versions.\n     * @throws IllegalStateException if there is no active frontend currently.\n     ",
    "links" : [ "android.media.tv.tuner.TunerVersionChecker#getTunerVersion()" ]
  }, {
    "name" : "public FrontendInfo getFrontendInfo()",
    "returnType" : "FrontendInfo",
    "comment" : "\n     * Gets the currently initialized and activated frontend information. To get all the available\n     * frontend info on the device, use {@link getAvailableFrontendInfos()}.\n     *\n     * @return The active frontend information. {@code null} if the operation failed.\n     * @throws IllegalStateException if there is no active frontend currently.\n     ",
    "links" : [ "getAvailableFrontendInfos()" ]
  }, {
    "name" : "public List<FrontendInfo> getAvailableFrontendInfos()",
    "returnType" : "List<FrontendInfo>",
    "comment" : "\n     * Gets a list of all the available frontend information on the device. To get the information\n     * of the currently active frontend, use {@link getFrontendInfo()}. The active frontend\n     * information is also included in the list of the available frontend information.\n     *\n     * @return The list of all the available frontend information. {@code null} if the operation\n     * failed.\n     ",
    "links" : [ "getFrontendInfo()" ]
  }, {
    "name" : "public String getCurrentFrontendHardwareInfo()",
    "returnType" : "String",
    "comment" : "\n     * Gets the currently initialized and activated frontend hardware information. The return values\n     * would differ per device makers. E.g. RF chip version, Demod chip version, detailed status of\n     * dvbs blind scan, etc\n     *\n     * <p>This API is only supported by Tuner HAL 2.0 or higher. Unsupported version would return\n     * {@code null}. Use {@link TunerVersionChecker#getTunerVersion()} to check the version.\n     *\n     * @return The active frontend hardware information. {@code null} if the operation failed.\n     * @throws IllegalStateException if there is no active frontend currently.\n     ",
    "links" : [ "android.media.tv.tuner.TunerVersionChecker#getTunerVersion()" ]
  }, {
    "name" : "public int setMaxNumberOfFrontends(@FrontendSettings.Type int frontendType, @IntRange(from = 0) int maxNumber)",
    "returnType" : "int",
    "comment" : "\n     * Sets the maximum usable frontends number of a given frontend type. It is used to enable or\n     * disable frontends when cable connection status is changed by user.\n     *\n     * <p>This API is only supported by Tuner HAL 2.0 or higher. Unsupported version would return\n     * {@link RESULT_UNAVAILABLE}. Use {@link TunerVersionChecker#getTunerVersion()} to check the\n     * version.\n     *\n     * @param frontendType the {@link android.media.tv.tuner.frontend.FrontendSettings.Type} which\n     *                     the maximum usable number will be set.\n     * @param maxNumber the new maximum usable number.\n     * @return result status of the operation.\n     ",
    "links" : [ "android.media.tv.tuner.frontend.FrontendSettings.Type", "android.media.tv.tuner.TunerVersionChecker#getTunerVersion()", "RESULT_UNAVAILABLE" ]
  }, {
    "name" : "public int getMaxNumberOfFrontends(@FrontendSettings.Type int frontendType)",
    "returnType" : "int",
    "comment" : "\n     * Get the maximum usable frontends number of a given frontend type.\n     *\n     * <p>This API is only supported by Tuner HAL 2.0 or higher. Unsupported version would return\n     * {@code -1}. Use {@link TunerVersionChecker#getTunerVersion()} to check the version.\n     *\n     * @param frontendType the {@link android.media.tv.tuner.frontend.FrontendSettings.Type} which\n     *                     the maximum usable number will be queried.\n     * @return the maximum usable number of the queried frontend type.\n     ",
    "links" : [ "android.media.tv.tuner.frontend.FrontendSettings.Type", "android.media.tv.tuner.TunerVersionChecker#getTunerVersion()" ]
  }, {
    "name" : "public FrontendInfo getFrontendInfoById(int id)",
    "returnType" : "FrontendInfo",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "public DemuxCapabilities getDemuxCapabilities()",
    "returnType" : "DemuxCapabilities",
    "comment" : "\n     * Gets Demux capabilities.\n     *\n     * @return A {@link DemuxCapabilities} instance that represents the demux capabilities.\n     *         {@code null} if the operation failed.\n     ",
    "links" : [ "android.media.tv.tuner.DemuxCapabilities" ]
  }, {
    "name" : "public DemuxInfo getCurrentDemuxInfo()",
    "returnType" : "DemuxInfo",
    "comment" : "\n     * Gets DemuxInfo of the currently held demux\n     *\n     * @return A {@link DemuxInfo} of currently held demux resource.\n     *         Returns null if no demux resource is held.\n     ",
    "links" : [ "android.media.tv.tuner.DemuxInfo" ]
  }, {
    "name" : "public DemuxInfo getDesiredDemuxInfo()",
    "returnType" : "DemuxInfo",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "private void onFrontendEvent(int eventType)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private void onLocked()",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private void onUnlocked()",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private void onScanStopped()",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private void onProgress(int percent)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private void onFrequenciesReport(long[] frequencies)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private void onSymbolRates(int[] rate)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private void onHierarchy(int hierarchy)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private void onSignalType(int signalType)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private void onPlpIds(int[] plpIds)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private void onGroupIds(int[] groupIds)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private void onInputStreamIds(int[] inputStreamIds)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private void onDvbsStandard(int dvbsStandandard)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private void onDvbtStandard(int dvbtStandard)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private void onAnalogSifStandard(int sif)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private void onAtsc3PlpInfos(Atsc3PlpInfo[] atsc3PlpInfos)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private void onModulationReported(int modulation)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private void onPriorityReported(boolean isHighPriority)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private void onDvbcAnnexReported(int dvbcAnnex)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private void onDvbtCellIdsReported(int[] dvbtCellIds)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public Filter openFilter(@Type int mainType, @Subtype int subType, @BytesLong long bufferSize, @CallbackExecutor @Nullable Executor executor, @Nullable FilterCallback cb)",
    "returnType" : "Filter",
    "comment" : "\n     * Opens a filter object based on the given types and buffer size.\n     *\n     * <p>For TUNER_VERSION_3_0 and above, configureDemuxInternal() will be called with mainType.\n     * However, unlike when configureDemux() is called directly, the desired filter types will not\n     * be changed when previously set desired filter types are the superset of the newly desired\n     * ones.\n     *\n     * @param mainType the main type of the filter.\n     * @param subType the subtype of the filter.\n     * @param bufferSize the buffer size of the filter to be opened in bytes. The buffer holds the\n     * data output from the filter.\n     * @param executor the executor on which callback will be invoked. The default event handler\n     * executor is used if it's {@code null}.\n     * @param cb the callback to receive notifications from filter.\n     * @return the opened filter. {@code null} if the operation failed.\n     ",
    "links" : [ ]
  }, {
    "name" : "public Lnb openLnb(@CallbackExecutor @NonNull Executor executor, @NonNull LnbCallback cb)",
    "returnType" : "Lnb",
    "comment" : "\n     * Opens an LNB (low-noise block downconverter) object.\n     *\n     * <p>If there is an existing Lnb object, it will be replace by the newly opened one.\n     *\n     * @param executor the executor on which callback will be invoked. The default event handler\n     * executor is used if it's {@code null}.\n     * @param cb the callback to receive notifications from LNB.\n     * @return the opened LNB object. {@code null} if the operation failed.\n     ",
    "links" : [ ]
  }, {
    "name" : "public Lnb openLnbByName(@NonNull String name, @CallbackExecutor @NonNull Executor executor, @NonNull LnbCallback cb)",
    "returnType" : "Lnb",
    "comment" : "\n     * Opens an LNB (low-noise block downconverter) object specified by the give name.\n     *\n     * @param name the LNB name.\n     * @param executor the executor on which callback will be invoked. The default event handler\n     * executor is used if it's {@code null}.\n     * @param cb the callback to receive notifications from LNB.\n     * @return the opened LNB object. {@code null} if the operation failed.\n     ",
    "links" : [ ]
  }, {
    "name" : "private boolean requestLnb()",
    "returnType" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public TimeFilter openTimeFilter()",
    "returnType" : "TimeFilter",
    "comment" : "\n     * Open a time filter object.\n     *\n     * @return the opened time filter object. {@code null} if the operation failed.\n     ",
    "links" : [ ]
  }, {
    "name" : "public Descrambler openDescrambler()",
    "returnType" : "Descrambler",
    "comment" : "\n     * Opens a Descrambler in tuner.\n     *\n     * @return a {@link Descrambler} object.\n     ",
    "links" : [ "android.media.tv.tuner.Descrambler" ]
  }, {
    "name" : "public DvrRecorder openDvrRecorder(@BytesLong long bufferSize, @CallbackExecutor @NonNull Executor executor, @NonNull OnRecordStatusChangedListener l)",
    "returnType" : "DvrRecorder",
    "comment" : "\n     * Open a DVR (Digital Video Record) recorder instance.\n     *\n     * @param bufferSize the buffer size of the output in bytes. It's used to hold output data of\n     * the attached filters.\n     * @param executor the executor on which callback will be invoked. The default event handler\n     * executor is used if it's {@code null}.\n     * @param l the listener to receive notifications from DVR recorder.\n     * @return the opened DVR recorder object. {@code null} if the operation failed.\n     ",
    "links" : [ ]
  }, {
    "name" : "public DvrPlayback openDvrPlayback(@BytesLong long bufferSize, @CallbackExecutor @NonNull Executor executor, @NonNull OnPlaybackStatusChangedListener l)",
    "returnType" : "DvrPlayback",
    "comment" : "\n     * Open a DVR (Digital Video Record) playback instance.\n     *\n     * @param bufferSize the buffer size of the output in bytes. It's used to hold output data of\n     * the attached filters.\n     * @param executor the executor on which callback will be invoked. The default event handler\n     * executor is used if it's {@code null}.\n     * @param l the listener to receive notifications from DVR recorder.\n     * @return the opened DVR playback object. {@code null} if the operation failed.\n     ",
    "links" : [ ]
  }, {
    "name" : "public int applyFrontend(@NonNull FrontendInfo desiredFrontendInfo)",
    "returnType" : "int",
    "comment" : "\n     * Request a frontend by frontend info.\n     *\n     * <p> This API is used if the applications want to select a desired frontend before\n     * {@link tune} to use a specific satellite or sending SatCR DiSEqC command for {@link tune}.\n     *\n     * @param desiredFrontendInfo the FrontendInfo of the desired fronted. It can be retrieved by\n     * {@link getAvailableFrontendInfos}\n     *\n     * @return result status of open operation.\n     * @throws SecurityException if the caller does not have appropriate permissions.\n     ",
    "links" : [ "getAvailableFrontendInfos", "tune" ]
  }, {
    "name" : "public static SharedFilter openSharedFilter(@NonNull Context context, @NonNull String sharedFilterToken, @CallbackExecutor @NonNull Executor executor, @NonNull SharedFilterCallback cb)",
    "returnType" : "SharedFilter",
    "comment" : "\n     * Open a shared filter instance.\n     *\n     * @param context the context of the caller.\n     * @param sharedFilterToken the token of the shared filter being opened.\n     * @param executor the executor on which callback will be invoked.\n     * @param cb the listener to receive notifications from shared filter.\n     * @return the opened shared filter object. {@code null} if the operation failed.\n     ",
    "links" : [ ]
  }, {
    "name" : "public int configureDemux(@Nullable DemuxInfo desiredDemuxInfo)",
    "returnType" : "int",
    "comment" : "\n     * Configures the desired {@link DemuxInfo}\n     *\n     * <p>The already held demux and filters will be released when desiredDemuxInfo is null or the\n     * desireDemuxInfo.getFilterTypes() is not supported by the already held demux.\n     *\n     * @param desiredDemuxInfo the desired {@link DemuxInfo}, which includes information such as\n     *                         filterTypes ({@link DemuxFilterMainType}).\n     * @return result status of configure demux operation. {@link #RESULT_UNAVAILABLE} is returned\n     *                when a) the desired capabilities are not supported by the system,\n     *                b) this API is called on unsupported version, or\n     *                c) either getDemuxCapabilities or getFilterTypeCapabilityList()\n     *                returns an empty array\n     ",
    "links" : [ "DemuxFilterMainType", "android.media.tv.tuner.DemuxInfo", "#RESULT_UNAVAILABLE" ]
  }, {
    "name" : "private int configureDemuxInternal(@Nullable DemuxInfo desiredDemuxInfo, boolean reduceDesiredFilterTypes)",
    "returnType" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private boolean requestDemux()",
    "returnType" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private Descrambler requestDescrambler()",
    "returnType" : "Descrambler",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private boolean requestFrontendCiCam(int ciCamId)",
    "returnType" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private boolean checkResource(int resourceType, ReentrantLock localLock)",
    "returnType" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private boolean requestResource(int resourceType, ReentrantLock localLock)",
    "returnType" : "boolean",
    "comment" : " If localLock is null, we'll assume the caller does not want the lock related operations",
    "links" : [ ]
  }, {
    "name" : " void releaseLnb()",
    "returnType" : "void",
    "comment" : " package ",
    "links" : [ ]
  }, {
    "name" : "public int getClientId()",
    "returnType" : "int",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : " TunerResourceManager getTunerResourceManager()",
    "returnType" : "TunerResourceManager",
    "comment" : " package ",
    "links" : [ ]
  }, {
    "name" : "private void acquireTRMSLock(String functionNameForLog)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private void releaseTRMSLock()",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  } ],
  "methodNames" : [ "private FrontendInfo[] getFrontendInfoListInternal()", "public static int getTunerVersion()", "public List<Integer> getFrontendIds()", "public void setResourceLostListener(@NonNull @CallbackExecutor Executor executor, @NonNull OnResourceLostListener listener)", "public void clearResourceLostListener()", "public void shareFrontendFromTuner(@NonNull Tuner tuner)", "public int transferOwner(@NonNull Tuner newOwner)", "private void replicateFrontendSettings(@Nullable Tuner src)", "private void setFrontendOwner(Tuner owner)", "private void replicateCiCamSettings(@Nullable Tuner src)", "private void replicateLnbSettings(@Nullable Tuner src)", "private boolean isFrontendOwner()", "private boolean isNewOwnerQualifiedForTransfer(@NonNull Tuner newOwner)", "private int transferFeOwner(@NonNull Tuner newOwner)", "private int transferCiCamOwner(Tuner newOwner)", "private int transferLnbOwner(Tuner newOwner)", "public void updateResourcePriority(int priority, int niceValue)", "public boolean hasUnusedFrontend(int frontendType)", "public boolean isLowestPriority(int frontendType)", "private void registerFrontendCallbackListener(Tuner tuner)", "private void unregisterFrontendCallbackListener(Tuner tuner)", " long getNativeContext()", "public void close()", "public void closeFrontend()", "private void releaseFrontend()", "private void releaseCiCam()", "private void closeLnb()", "private void releaseFilters()", "private void releaseDescramblers()", "private void releaseDemux()", "private void releaseAll()", "private static native void nativeInit()", "private native void nativeSetup()", "private native int nativeGetTunerVersion()", "private native List<Integer> nativeGetFrontendIds()", "private native Frontend nativeOpenFrontendByHandle(int handle)", "private native int nativeShareFrontend(int id)", "private native int nativeUnshareFrontend()", "private native void nativeRegisterFeCbListener(long nativeContext)", "private native void nativeUnregisterFeCbListener(long nativeContext)", "private native void nativeUpdateFrontend(long nativeContext)", "private native int nativeTune(int type, FrontendSettings settings)", "private native int nativeStopTune()", "private native int nativeScan(int settingsType, FrontendSettings settings, int scanType)", "private native int nativeStopScan()", "private native int nativeSetLnb(Lnb lnb)", "private native boolean nativeIsLnaSupported()", "private native int nativeSetLna(boolean enable)", "private native FrontendStatus nativeGetFrontendStatus(int[] statusTypes)", "private native Integer nativeGetAvSyncHwId(Filter filter)", "private native Long nativeGetAvSyncTime(int avSyncId)", "private native int nativeConnectCiCam(int ciCamId)", "private native int nativeLinkCiCam(int ciCamId)", "private native int nativeDisconnectCiCam()", "private native int nativeUnlinkCiCam(int ciCamId)", "private native FrontendInfo nativeGetFrontendInfo(int id)", "private native Filter nativeOpenFilter(int type, int subType, long bufferSize)", "private native TimeFilter nativeOpenTimeFilter()", "private native String nativeGetFrontendHardwareInfo()", "private native int nativeSetMaxNumberOfFrontends(int frontendType, int maxNumber)", "private native int nativeGetMaxNumberOfFrontends(int frontendType)", "private native int nativeRemoveOutputPid(int pid)", "private native Lnb nativeOpenLnbByHandle(int handle)", "private native Lnb nativeOpenLnbByName(String name)", "private native FrontendStatusReadiness[] nativeGetFrontendStatusReadiness(int[] statusTypes)", "private native Descrambler nativeOpenDescramblerByHandle(int handle)", "private native int nativeOpenDemuxByhandle(int handle)", "private native DvrRecorder nativeOpenDvrRecorder(long bufferSize)", "private native DvrPlayback nativeOpenDvrPlayback(long bufferSize)", "private native DemuxCapabilities nativeGetDemuxCapabilities()", "private native DemuxInfo nativeGetDemuxInfo(int demuxHandle)", "private native int nativeCloseDemux(int handle)", "private native int nativeCloseFrontend(int handle)", "private native int nativeClose()", "private static native SharedFilter nativeOpenSharedFilter(String token)", "private EventHandler createEventHandler()", "public void setOnTuneEventListener(@NonNull @CallbackExecutor Executor executor, @NonNull OnTuneEventListener eventListener)", "public void clearOnTuneEventListener()", "public int tune(@NonNull FrontendSettings settings)", "public int cancelTuning()", "public int scan(@NonNull FrontendSettings settings, @ScanType int scanType, @NonNull @CallbackExecutor Executor executor, @NonNull ScanCallback scanCallback)", "public int cancelScanning()", "private boolean requestFrontend()", "private int setLnb(@NonNull Lnb lnb)", "public boolean isLnaSupported()", "public int setLnaEnabled(boolean enable)", "public FrontendStatus getFrontendStatus(@NonNull @FrontendStatusType int[] statusTypes)", "public int getAvSyncHwId(@NonNull Filter filter)", "public long getAvSyncTime(int avSyncHwId)", "public int connectCiCam(int ciCamId)", "public int connectFrontendToCiCam(int ciCamId)", "public int disconnectCiCam()", "public int disconnectFrontendToCiCam(int ciCamId)", "public int removeOutputPid(@IntRange(from = 0) int pid)", "public List<FrontendStatusReadiness> getFrontendStatusReadiness(@NonNull @FrontendStatusType int[] statusTypes)", "public FrontendInfo getFrontendInfo()", "public List<FrontendInfo> getAvailableFrontendInfos()", "public String getCurrentFrontendHardwareInfo()", "public int setMaxNumberOfFrontends(@FrontendSettings.Type int frontendType, @IntRange(from = 0) int maxNumber)", "public int getMaxNumberOfFrontends(@FrontendSettings.Type int frontendType)", "public FrontendInfo getFrontendInfoById(int id)", "public DemuxCapabilities getDemuxCapabilities()", "public DemuxInfo getCurrentDemuxInfo()", "public DemuxInfo getDesiredDemuxInfo()", "private void onFrontendEvent(int eventType)", "private void onLocked()", "private void onUnlocked()", "private void onScanStopped()", "private void onProgress(int percent)", "private void onFrequenciesReport(long[] frequencies)", "private void onSymbolRates(int[] rate)", "private void onHierarchy(int hierarchy)", "private void onSignalType(int signalType)", "private void onPlpIds(int[] plpIds)", "private void onGroupIds(int[] groupIds)", "private void onInputStreamIds(int[] inputStreamIds)", "private void onDvbsStandard(int dvbsStandandard)", "private void onDvbtStandard(int dvbtStandard)", "private void onAnalogSifStandard(int sif)", "private void onAtsc3PlpInfos(Atsc3PlpInfo[] atsc3PlpInfos)", "private void onModulationReported(int modulation)", "private void onPriorityReported(boolean isHighPriority)", "private void onDvbcAnnexReported(int dvbcAnnex)", "private void onDvbtCellIdsReported(int[] dvbtCellIds)", "public Filter openFilter(@Type int mainType, @Subtype int subType, @BytesLong long bufferSize, @CallbackExecutor @Nullable Executor executor, @Nullable FilterCallback cb)", "public Lnb openLnb(@CallbackExecutor @NonNull Executor executor, @NonNull LnbCallback cb)", "public Lnb openLnbByName(@NonNull String name, @CallbackExecutor @NonNull Executor executor, @NonNull LnbCallback cb)", "private boolean requestLnb()", "public TimeFilter openTimeFilter()", "public Descrambler openDescrambler()", "public DvrRecorder openDvrRecorder(@BytesLong long bufferSize, @CallbackExecutor @NonNull Executor executor, @NonNull OnRecordStatusChangedListener l)", "public DvrPlayback openDvrPlayback(@BytesLong long bufferSize, @CallbackExecutor @NonNull Executor executor, @NonNull OnPlaybackStatusChangedListener l)", "public int applyFrontend(@NonNull FrontendInfo desiredFrontendInfo)", "public static SharedFilter openSharedFilter(@NonNull Context context, @NonNull String sharedFilterToken, @CallbackExecutor @NonNull Executor executor, @NonNull SharedFilterCallback cb)", "public int configureDemux(@Nullable DemuxInfo desiredDemuxInfo)", "private int configureDemuxInternal(@Nullable DemuxInfo desiredDemuxInfo, boolean reduceDesiredFilterTypes)", "private boolean requestDemux()", "private Descrambler requestDescrambler()", "private boolean requestFrontendCiCam(int ciCamId)", "private boolean checkResource(int resourceType, ReentrantLock localLock)", "private boolean requestResource(int resourceType, ReentrantLock localLock)", " void releaseLnb()", "public int getClientId()", " TunerResourceManager getTunerResourceManager()", "private void acquireTRMSLock(String functionNameForLog)", "private void releaseTRMSLock()" ],
  "variableNames" : [ "INVALID_TS_PID", "INVALID_STREAM_ID", "INVALID_FILTER_ID", "INVALID_AV_SYNC_ID", "INVALID_TIMESTAMP", "INVALID_MMTP_RECORD_EVENT_MPT_SEQUENCE_NUM", "INVALID_FIRST_MACROBLOCK_IN_SLICE", "INVALID_LTS_ID", "INVALID_FILTER_ID_LONG", "INVALID_FRONTEND_SETTING_FREQUENCY", "INVALID_FRONTEND_ID", "INVALID_LNB_ID", "VOID_KEYTOKEN", "SCAN_TYPE_UNDEFINED", "SCAN_TYPE_AUTO", "SCAN_TYPE_BLIND", "RESULT_SUCCESS", "RESULT_UNAVAILABLE", "RESULT_NOT_INITIALIZED", "RESULT_INVALID_STATE", "RESULT_INVALID_ARGUMENT", "RESULT_OUT_OF_MEMORY", "RESULT_UNKNOWN_ERROR", "TAG", "DEBUG", "MSG_RESOURCE_LOST", "MSG_ON_FILTER_EVENT", "MSG_ON_FILTER_STATUS", "MSG_ON_LNB_EVENT", "FILTER_CLEANUP_THRESHOLD", "DVR_TYPE_RECORD", "DVR_TYPE_PLAYBACK", "mContext", "mTunerResourceManager", "mClientId", "sTunerVersion", "mDesiredDemuxInfo", "mFrontend", "mHandler", "mFrontendInfo", "mFrontendHandle", "mFeOwnerTuner", "mFrontendType", "mDesiredFrontendId", "mUserId", "mLnb", "mLnbHandle", "mOnTuneEventListener", "mOnTuneEventExecutor", "mScanCallback", "mScanCallbackExecutor", "mOnResourceLostListener", "mOnResourceLostListenerExecutor", "mOnTuneEventLock", "mScanCallbackLock", "mOnResourceLostListenerLock", "mFrontendLock", "mLnbLock", "mFrontendCiCamLock", "mDemuxLock", "mRequestedCiCamId", "mDemuxHandle", "mFrontendCiCamHandle", "mFrontendCiCamId", "mDescramblers", "mFilters", "mResourceListener", "mNativeContext" ]
}