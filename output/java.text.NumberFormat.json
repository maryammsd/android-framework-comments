{
  "filePath" : "/home/maryam/clearblue/files/android-source-35/java/text/NumberFormat.java",
  "packageName" : "java.text",
  "className" : "NumberFormat",
  "comment" : "\n * {@code NumberFormat} is the abstract base class for all number\n * formats. This class provides the interface for formatting and parsing\n * numbers. {@code NumberFormat} also provides methods for determining\n * which locales have number formats, and what their names are.\n *\n * <p>\n * {@code NumberFormat} helps you to format and parse numbers for any locale.\n * Your code can be completely independent of the locale conventions for\n * decimal points, thousands-separators, or even the particular decimal\n * digits used, or whether the number format is even decimal.\n *\n * <p>\n * To format a number for the current Locale, use one of the factory\n * class methods:\n * <blockquote>\n * <pre>{@code\n * myString = NumberFormat.getInstance().format(myNumber);\n * }</pre>\n * </blockquote>\n * If you are formatting multiple numbers, it is\n * more efficient to get the format and use it multiple times so that\n * the system doesn't have to fetch the information about the local\n * language and country conventions multiple times.\n * <blockquote>\n * <pre>{@code\n * NumberFormat nf = NumberFormat.getInstance();\n * for (int i = 0; i < myNumber.length; ++i) {\n *     output.println(nf.format(myNumber[i]) + \"; \");\n * }\n * }</pre>\n * </blockquote>\n * To format a number for a different Locale, specify it in the\n * call to {@code getInstance}.\n * <blockquote>\n * <pre>{@code\n * NumberFormat nf = NumberFormat.getInstance(Locale.FRENCH);\n * }</pre>\n * </blockquote>\n *\n * <p>If the locale contains \"nu\" (numbers)\n * <a href=\"../util/Locale.html#def_locale_extension\">Unicode extensions</a>,\n * the decimal digits, and/or the country used for formatting are overridden.\n *\n * <p>You can also use a {@code NumberFormat} to parse numbers:\n * <blockquote>\n * <pre>{@code\n * myNumber = nf.parse(myString);\n * }</pre>\n * </blockquote>\n * Use {@code getInstance} or {@code getNumberInstance} to get the\n * normal number format. Use {@code getIntegerInstance} to get an\n * integer number format. Use {@code getCurrencyInstance} to get the\n * currency number format. Use {@code getCompactNumberInstance} to get the\n * compact number format to format a number in shorter form. For example,\n * {@code 2000} can be formatted as {@code \"2K\"} in\n * {@link java.util.Locale#US US locale}. Use {@code getPercentInstance}\n * to get a format for displaying percentages. With this format, a fraction\n * like 0.53 is displayed as 53%.\n *\n * <p>\n * You can also control the display of numbers with such methods as\n * {@code setMinimumFractionDigits}.\n * If you want even more control over the format or parsing,\n * or want to give your users more control,\n * you can try casting the {@code NumberFormat} you get from the factory methods\n * to a {@code DecimalFormat} or {@code CompactNumberFormat} depending on\n * the factory method used. This will work for the vast majority of locales;\n * just remember to put it in a {@code try} block in case you encounter\n * an unusual one.\n *\n * <p>\n * NumberFormat and DecimalFormat are designed such that some controls\n * work for formatting and others work for parsing.  The following is\n * the detailed description for each these control methods,\n * <p>\n * setParseIntegerOnly : only affects parsing, e.g.\n * if true,  \"3456.78\" &rarr; 3456 (and leaves the parse position just after index 6)\n * if false, \"3456.78\" &rarr; 3456.78 (and leaves the parse position just after index 8)\n * This is independent of formatting.  If you want to not show a decimal point\n * where there might be no digits after the decimal point, use\n * setDecimalSeparatorAlwaysShown.\n * <p>\n * setDecimalSeparatorAlwaysShown : only affects formatting, and only where\n * there might be no digits after the decimal point, such as with a pattern\n * like \"#,##0.##\", e.g.,\n * if true,  3456.00 &rarr; \"3,456.\"\n * if false, 3456.00 &rarr; \"3456\"\n * This is independent of parsing.  If you want parsing to stop at the decimal\n * point, use setParseIntegerOnly.\n *\n * <p>\n * You can also use forms of the {@code parse} and {@code format}\n * methods with {@code ParsePosition} and {@code FieldPosition} to\n * allow you to:\n * <ul>\n * <li> progressively parse through pieces of a string\n * <li> align the decimal point and other areas\n * </ul>\n * For example, you can align numbers in two ways:\n * <ol>\n * <li> If you are using a monospaced font with spacing for alignment,\n *      you can pass the {@code FieldPosition} in your format call, with\n *      {@code field} = {@code INTEGER_FIELD}. On output,\n *      {@code getEndIndex} will be set to the offset between the\n *      last character of the integer and the decimal. Add\n *      (desiredSpaceCount - getEndIndex) spaces at the front of the string.\n *\n * <li> If you are using proportional fonts,\n *      instead of padding with spaces, measure the width\n *      of the string in pixels from the start to {@code getEndIndex}.\n *      Then move the pen by\n *      (desiredPixelWidth - widthToAlignmentPoint) before drawing the text.\n *      It also works where there is no decimal, but possibly additional\n *      characters at the end, e.g., with parentheses in negative\n *      numbers: \"(12)\" for -12.\n * </ol>\n *\n * <h2><a id=\"synchronization\">Synchronization</a></h2>\n *\n * <p>\n * Number formats are generally not synchronized.\n * It is recommended to create separate format instances for each thread.\n * If multiple threads access a format concurrently, it must be synchronized\n * externally.\n *\n * @implSpec The {@link #format(double, StringBuffer, FieldPosition)},\n * {@link #format(long, StringBuffer, FieldPosition)} and\n * {@link #parse(String, ParsePosition)} methods may throw\n * {@code NullPointerException}, if any of their parameter is {@code null}.\n * The subclass may provide its own implementation and specification about\n * {@code NullPointerException}.\n *\n * <p>\n * The default implementation provides rounding modes defined\n * in {@link java.math.RoundingMode} for formatting numbers. It\n * uses the {@linkplain java.math.RoundingMode#HALF_EVEN\n * round half-even algorithm}. To change the rounding mode use\n * {@link #setRoundingMode(java.math.RoundingMode) setRoundingMode}.\n * The {@code NumberFormat} returned by the static factory methods is\n * configured to round floating point numbers using half-even\n * rounding (see {@link java.math.RoundingMode#HALF_EVEN\n * RoundingMode.HALF_EVEN}) for formatting.\n *\n * @see          DecimalFormat\n * @see          ChoiceFormat\n * @author       Mark Davis\n * @author       Helena Shih\n * @since 1.1\n ",
  "links" : [ "java.math.RoundingMode#HALF_EVENRoundingMode.HALF_EVEN", "#format(long", "#setRoundingMode(java.math.RoundingMode)", "java.util.Locale#US", "#format(double", "#parse(String", "java.math.RoundingMode" ],
  "variables" : [ {
    "name" : "INTEGER_FIELD",
    "type" : "int",
    "comment" : "\n     * Field constant used to construct a FieldPosition object. Signifies that\n     * the position of the integer part of a formatted number should be returned.\n     * @see java.text.FieldPosition\n     ",
    "links" : [ ]
  }, {
    "name" : "FRACTION_FIELD",
    "type" : "int",
    "comment" : "\n     * Field constant used to construct a FieldPosition object. Signifies that\n     * the position of the fraction part of a formatted number should be returned.\n     * @see java.text.FieldPosition\n     ",
    "links" : [ ]
  }, {
    "name" : "NUMBERSTYLE",
    "type" : "int",
    "comment" : " Constants used by factory methods to specify a style of format.",
    "links" : [ ]
  }, {
    "name" : "CURRENCYSTYLE",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "PERCENTSTYLE",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "INTEGERSTYLE",
    "type" : "int",
    "comment" : "private static final int SCIENTIFICSTYLE = 3;",
    "links" : [ ]
  }, {
    "name" : "groupingUsed",
    "type" : "boolean",
    "comment" : "\n     * True if the grouping (i.e. thousands) separator is used when\n     * formatting and parsing numbers.\n     *\n     * @serial\n     * @see #isGroupingUsed\n     ",
    "links" : [ ]
  }, {
    "name" : "maxIntegerDigits",
    "type" : "byte",
    "comment" : "\n     * The maximum number of digits allowed in the integer portion of a\n     * number.  {@code maxIntegerDigits} must be greater than or equal to\n     * {@code minIntegerDigits}.\n     * <p>\n     * <strong>Note:</strong> This field exists only for serialization\n     * compatibility with JDK 1.1.  In Java platform 2 v1.2 and higher, the new\n     * {@code int} field {@code maximumIntegerDigits} is used instead.\n     * When writing to a stream, {@code maxIntegerDigits} is set to\n     * {@code maximumIntegerDigits} or {@code Byte.MAX_VALUE},\n     * whichever is smaller.  When reading from a stream, this field is used\n     * only if {@code serialVersionOnStream} is less than 1.\n     *\n     * @serial\n     * @see #getMaximumIntegerDigits\n     ",
    "links" : [ ]
  }, {
    "name" : "minIntegerDigits",
    "type" : "byte",
    "comment" : "\n     * The minimum number of digits allowed in the integer portion of a\n     * number.  {@code minimumIntegerDigits} must be less than or equal to\n     * {@code maximumIntegerDigits}.\n     * <p>\n     * <strong>Note:</strong> This field exists only for serialization\n     * compatibility with JDK 1.1.  In Java platform 2 v1.2 and higher, the new\n     * {@code int} field {@code minimumIntegerDigits} is used instead.\n     * When writing to a stream, {@code minIntegerDigits} is set to\n     * {@code minimumIntegerDigits} or {@code Byte.MAX_VALUE},\n     * whichever is smaller.  When reading from a stream, this field is used\n     * only if {@code serialVersionOnStream} is less than 1.\n     *\n     * @serial\n     * @see #getMinimumIntegerDigits\n     ",
    "links" : [ ]
  }, {
    "name" : "maxFractionDigits",
    "type" : "byte",
    "comment" : " invariant, >= minFractionDigits",
    "links" : [ ]
  }, {
    "name" : "minFractionDigits",
    "type" : "byte",
    "comment" : "\n     * The minimum number of digits allowed in the fractional portion of a\n     * number.  {@code minimumFractionDigits} must be less than or equal to\n     * {@code maximumFractionDigits}.\n     * <p>\n     * <strong>Note:</strong> This field exists only for serialization\n     * compatibility with JDK 1.1.  In Java platform 2 v1.2 and higher, the new\n     * {@code int} field {@code minimumFractionDigits} is used instead.\n     * When writing to a stream, {@code minFractionDigits} is set to\n     * {@code minimumFractionDigits} or {@code Byte.MAX_VALUE},\n     * whichever is smaller.  When reading from a stream, this field is used\n     * only if {@code serialVersionOnStream} is less than 1.\n     *\n     * @serial\n     * @see #getMinimumFractionDigits\n     ",
    "links" : [ ]
  }, {
    "name" : "parseIntegerOnly",
    "type" : "boolean",
    "comment" : "\n     * True if this format will parse numbers as integers only.\n     *\n     * @serial\n     * @see #isParseIntegerOnly\n     ",
    "links" : [ ]
  }, {
    "name" : "maximumIntegerDigits",
    "type" : "int",
    "comment" : "\n     * The maximum number of digits allowed in the integer portion of a\n     * number.  {@code maximumIntegerDigits} must be greater than or equal to\n     * {@code minimumIntegerDigits}.\n     *\n     * @serial\n     * @since 1.2\n     * @see #getMaximumIntegerDigits\n     ",
    "links" : [ ]
  }, {
    "name" : "minimumIntegerDigits",
    "type" : "int",
    "comment" : "\n     * The minimum number of digits allowed in the integer portion of a\n     * number.  {@code minimumIntegerDigits} must be less than or equal to\n     * {@code maximumIntegerDigits}.\n     *\n     * @serial\n     * @since 1.2\n     * @see #getMinimumIntegerDigits\n     ",
    "links" : [ ]
  }, {
    "name" : "maximumFractionDigits",
    "type" : "int",
    "comment" : " invariant, >= minFractionDigits",
    "links" : [ ]
  }, {
    "name" : "minimumFractionDigits",
    "type" : "int",
    "comment" : "\n     * The minimum number of digits allowed in the fractional portion of a\n     * number.  {@code minimumFractionDigits} must be less than or equal to\n     * {@code maximumFractionDigits}.\n     *\n     * @serial\n     * @since 1.2\n     * @see #getMinimumFractionDigits\n     ",
    "links" : [ ]
  }, {
    "name" : "currentSerialVersion",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "serialVersionOnStream",
    "type" : "int",
    "comment" : "\n     * Describes the version of {@code NumberFormat} present on the stream.\n     * Possible values are:\n     * <ul>\n     * <li><b>0</b> (or uninitialized): the JDK 1.1 version of the stream format.\n     *     In this version, the {@code int} fields such as\n     *     {@code maximumIntegerDigits} were not present, and the {@code byte}\n     *     fields such as {@code maxIntegerDigits} are used instead.\n     *\n     * <li><b>1</b>: the 1.2 version of the stream format.  The values of the\n     *     {@code byte} fields such as {@code maxIntegerDigits} are ignored,\n     *     and the {@code int} fields such as {@code maximumIntegerDigits}\n     *     are used instead.\n     * </ul>\n     * When streaming out a {@code NumberFormat}, the most recent format\n     * (corresponding to the highest allowable {@code serialVersionOnStream})\n     * is always written.\n     *\n     * @serial\n     * @since 1.2\n     ",
    "links" : [ ]
  }, {
    "name" : "serialVersionUID",
    "type" : "long",
    "comment" : " ID for backward compatibility.",
    "links" : [ ]
  } ],
  "methods" : [ {
    "name" : "public StringBuffer format(Object number, StringBuffer toAppendTo, FieldPosition pos)",
    "returnType" : "StringBuffer",
    "comment" : "\n     * Formats a number and appends the resulting text to the given string\n     * buffer.\n     * The number can be of any subclass of {@link java.lang.Number}.\n     * <p>\n     * This implementation extracts the number's value using\n     * {@link java.lang.Number#longValue()} for all integral type values that\n     * can be converted to {@code long} without loss of information,\n     * including {@code BigInteger} values with a\n     * {@link java.math.BigInteger#bitLength() bit length} of less than 64,\n     * and {@link java.lang.Number#doubleValue()} for all other types. It\n     * then calls\n     * {@link #format(long,java.lang.StringBuffer,java.text.FieldPosition)}\n     * or {@link #format(double,java.lang.StringBuffer,java.text.FieldPosition)}.\n     * This may result in loss of magnitude information and precision for\n     * {@code BigInteger} and {@code BigDecimal} values.\n     * @param number     the number to format\n     * @param toAppendTo the {@code StringBuffer} to which the formatted\n     *                   text is to be appended\n     * @param pos        keeps track on the position of the field within the\n     *                   returned string. For example, for formatting a number\n     *                   {@code 1234567.89} in {@code Locale.US} locale,\n     *                   if the given {@code fieldPosition} is\n     *                   {@link NumberFormat#INTEGER_FIELD}, the begin index\n     *                   and end index of {@code fieldPosition} will be set\n     *                   to 0 and 9, respectively for the output string\n     *                   {@code 1,234,567.89}.\n     * @return           the value passed in as {@code toAppendTo}\n     * @throws           IllegalArgumentException if {@code number} is\n     *                   null or not an instance of {@code Number}.\n     * @throws           NullPointerException if {@code toAppendTo} or\n     *                   {@code pos} is null\n     * @throws           ArithmeticException if rounding is needed with rounding\n     *                   mode being set to RoundingMode.UNNECESSARY\n     * @see              java.text.FieldPosition\n     ",
    "links" : [ "java.text.NumberFormat#INTEGER_FIELD", "java.lang.Number#doubleValue()", "#format(long", "java.math.BigInteger#bitLength()", "java.lang.Number", "#format(double", "java.lang.Number#longValue()" ]
  }, {
    "name" : "public final Object parseObject(String source, ParsePosition pos)",
    "returnType" : "Object",
    "comment" : "\n     * Parses text from a string to produce a {@code Number}.\n     * <p>\n     * The method attempts to parse text starting at the index given by\n     * {@code pos}.\n     * If parsing succeeds, then the index of {@code pos} is updated\n     * to the index after the last character used (parsing does not necessarily\n     * use all characters up to the end of the string), and the parsed\n     * number is returned. The updated {@code pos} can be used to\n     * indicate the starting point for the next call to this method.\n     * If an error occurs, then the index of {@code pos} is not\n     * changed, the error index of {@code pos} is set to the index of\n     * the character where the error occurred, and null is returned.\n     * <p>\n     * See the {@link #parse(String, ParsePosition)} method for more information\n     * on number parsing.\n     *\n     * @param source A {@code String}, part of which should be parsed.\n     * @param pos A {@code ParsePosition} object with index and error\n     *            index information as described above.\n     * @return A {@code Number} parsed from the string. In case of\n     *         error, returns null.\n     * @throws NullPointerException if {@code source} or {@code pos} is null.\n     ",
    "links" : [ "#parse(String" ]
  }, {
    "name" : "public final String format(double number)",
    "returnType" : "String",
    "comment" : "\n     * Specialization of format.\n     *\n     * @param number the double number to format\n     * @return the formatted String\n     * @throws           ArithmeticException if rounding is needed with rounding\n     *                   mode being set to RoundingMode.UNNECESSARY\n     * @see java.text.Format#format\n     ",
    "links" : [ ]
  }, {
    "name" : "public final String format(long number)",
    "returnType" : "String",
    "comment" : "\n     * Specialization of format.\n     *\n     * @param number the long number to format\n     * @return the formatted String\n     * @throws           ArithmeticException if rounding is needed with rounding\n     *                   mode being set to RoundingMode.UNNECESSARY\n     * @see java.text.Format#format\n     ",
    "links" : [ ]
  }, {
    "name" : "public abstract StringBuffer format(double number, StringBuffer toAppendTo, FieldPosition pos)",
    "returnType" : "StringBuffer",
    "comment" : "\n     * Specialization of format.\n     *\n     * @param number     the double number to format\n     * @param toAppendTo the StringBuffer to which the formatted text is to be\n     *                   appended\n     * @param pos        keeps track on the position of the field within the\n     *                   returned string. For example, for formatting a number\n     *                   {@code 1234567.89} in {@code Locale.US} locale,\n     *                   if the given {@code fieldPosition} is\n     *                   {@link NumberFormat#INTEGER_FIELD}, the begin index\n     *                   and end index of {@code fieldPosition} will be set\n     *                   to 0 and 9, respectively for the output string\n     *                   {@code 1,234,567.89}.\n     * @return the formatted StringBuffer\n     * @throws           ArithmeticException if rounding is needed with rounding\n     *                   mode being set to RoundingMode.UNNECESSARY\n     * @see java.text.Format#format\n     ",
    "links" : [ "java.text.NumberFormat#INTEGER_FIELD" ]
  }, {
    "name" : "public abstract StringBuffer format(long number, StringBuffer toAppendTo, FieldPosition pos)",
    "returnType" : "StringBuffer",
    "comment" : "\n     * Specialization of format.\n     *\n     * @param number     the long number to format\n     * @param toAppendTo the StringBuffer to which the formatted text is to be\n     *                   appended\n     * @param pos        keeps track on the position of the field within the\n     *                   returned string. For example, for formatting a number\n     *                   {@code 123456789} in {@code Locale.US} locale,\n     *                   if the given {@code fieldPosition} is\n     *                   {@link NumberFormat#INTEGER_FIELD}, the begin index\n     *                   and end index of {@code fieldPosition} will be set\n     *                   to 0 and 11, respectively for the output string\n     *                   {@code 123,456,789}.\n     * @return the formatted StringBuffer\n     * @throws           ArithmeticException if rounding is needed with rounding\n     *                   mode being set to RoundingMode.UNNECESSARY\n     * @see java.text.Format#format\n     ",
    "links" : [ "java.text.NumberFormat#INTEGER_FIELD" ]
  }, {
    "name" : "public abstract Number parse(String source, ParsePosition parsePosition)",
    "returnType" : "Number",
    "comment" : "\n     * Returns a Long if possible (e.g., within the range [Long.MIN_VALUE,\n     * Long.MAX_VALUE] and with no decimals), otherwise a Double.\n     * If IntegerOnly is set, will stop at a decimal\n     * point (or equivalent; e.g., for rational numbers \"1 2/3\", will stop\n     * after the 1).\n     * Does not throw an exception; if no object can be parsed, index is\n     * unchanged!\n     *\n     * @param source the String to parse\n     * @param parsePosition the parse position\n     * @return the parsed value\n     * @see java.text.NumberFormat#isParseIntegerOnly\n     * @see java.text.Format#parseObject\n     ",
    "links" : [ ]
  }, {
    "name" : "public Number parse(String source) throws ParseException",
    "returnType" : "Number",
    "comment" : "\n     * Parses text from the beginning of the given string to produce a number.\n     * The method may not use the entire text of the given string.\n     * <p>\n     * See the {@link #parse(String, ParsePosition)} method for more information\n     * on number parsing.\n     *\n     * @param source A {@code String} whose beginning should be parsed.\n     * @return A {@code Number} parsed from the string.\n     * @throws    ParseException if the beginning of the specified string\n     *            cannot be parsed.\n     ",
    "links" : [ "#parse(String" ]
  }, {
    "name" : "public boolean isParseIntegerOnly()",
    "returnType" : "boolean",
    "comment" : "\n     * Returns true if this format will parse numbers as integers only.\n     * For example in the English locale, with ParseIntegerOnly true, the\n     * string \"1234.\" would be parsed as the integer value 1234 and parsing\n     * would stop at the \".\" character.  Of course, the exact format accepted\n     * by the parse operation is locale dependent and determined by sub-classes\n     * of NumberFormat.\n     *\n     * @return {@code true} if numbers should be parsed as integers only;\n     *         {@code false} otherwise\n     ",
    "links" : [ ]
  }, {
    "name" : "public void setParseIntegerOnly(boolean value)",
    "returnType" : "void",
    "comment" : "\n     * Sets whether or not numbers should be parsed as integers only.\n     *\n     * @param value {@code true} if numbers should be parsed as integers only;\n     *              {@code false} otherwise\n     * @see #isParseIntegerOnly\n     ",
    "links" : [ ]
  }, {
    "name" : "public static final NumberFormat getInstance()",
    "returnType" : "NumberFormat",
    "comment" : "\n     * Returns a general-purpose number format for the current default\n     * {@link java.util.Locale.Category#FORMAT FORMAT} locale.\n     * This is the same as calling\n     * {@link #getNumberInstance() getNumberInstance()}.\n     *\n     * @return the {@code NumberFormat} instance for general-purpose number\n     * formatting\n     ",
    "links" : [ "java.util.Locale.Category#FORMAT", "#getNumberInstance()" ]
  }, {
    "name" : "public static NumberFormat getInstance(Locale inLocale)",
    "returnType" : "NumberFormat",
    "comment" : "\n     * Returns a general-purpose number format for the specified locale.\n     * This is the same as calling\n     * {@link #getNumberInstance(java.util.Locale) getNumberInstance(inLocale)}.\n     *\n     * @param inLocale the desired locale\n     * @return the {@code NumberFormat} instance for general-purpose number\n     * formatting\n     ",
    "links" : [ "#getNumberInstance(java.util.Locale)" ]
  }, {
    "name" : "public static final NumberFormat getNumberInstance()",
    "returnType" : "NumberFormat",
    "comment" : "\n     * Returns a general-purpose number format for the current default\n     * {@link java.util.Locale.Category#FORMAT FORMAT} locale.\n     * <p>This is equivalent to calling\n     * {@link #getNumberInstance(Locale)\n     *     getNumberInstance(Locale.getDefault(Locale.Category.FORMAT))}.\n     *\n     * @return the {@code NumberFormat} instance for general-purpose number\n     * formatting\n     * @see java.util.Locale#getDefault(java.util.Locale.Category)\n     * @see java.util.Locale.Category#FORMAT\n     ",
    "links" : [ "java.util.Locale.Category#FORMAT", "#getNumberInstance(Locale)" ]
  }, {
    "name" : "public static NumberFormat getNumberInstance(Locale inLocale)",
    "returnType" : "NumberFormat",
    "comment" : "\n     * Returns a general-purpose number format for the specified locale.\n     *\n     * @param inLocale the desired locale\n     * @return the {@code NumberFormat} instance for general-purpose number\n     * formatting\n     ",
    "links" : [ ]
  }, {
    "name" : "public static final NumberFormat getIntegerInstance()",
    "returnType" : "NumberFormat",
    "comment" : "\n     * Returns an integer number format for the current default\n     * {@link java.util.Locale.Category#FORMAT FORMAT} locale. The\n     * returned number format is configured to round floating point numbers\n     * to the nearest integer using half-even rounding (see {@link\n     * java.math.RoundingMode#HALF_EVEN RoundingMode.HALF_EVEN}) for formatting,\n     * and to parse only the integer part of an input string (see {@link\n     * #isParseIntegerOnly isParseIntegerOnly}).\n     * <p>This is equivalent to calling\n     * {@link #getIntegerInstance(Locale)\n     *     getIntegerInstance(Locale.getDefault(Locale.Category.FORMAT))}.\n     *\n     * @see #getRoundingMode()\n     * @see java.util.Locale#getDefault(java.util.Locale.Category)\n     * @see java.util.Locale.Category#FORMAT\n     * @return a number format for integer values\n     * @since 1.4\n     ",
    "links" : [ "#isParseIntegerOnly", "java.util.Locale.Category#FORMAT", "#getIntegerInstance(Locale)", "java.math.RoundingMode#HALF_EVEN" ]
  }, {
    "name" : "public static NumberFormat getIntegerInstance(Locale inLocale)",
    "returnType" : "NumberFormat",
    "comment" : "\n     * Returns an integer number format for the specified locale. The\n     * returned number format is configured to round floating point numbers\n     * to the nearest integer using half-even rounding (see {@link\n     * java.math.RoundingMode#HALF_EVEN RoundingMode.HALF_EVEN}) for formatting,\n     * and to parse only the integer part of an input string (see {@link\n     * #isParseIntegerOnly isParseIntegerOnly}).\n     *\n     * @param inLocale the desired locale\n     * @see #getRoundingMode()\n     * @return a number format for integer values\n     * @since 1.4\n     ",
    "links" : [ "#isParseIntegerOnly", "java.math.RoundingMode#HALF_EVEN" ]
  }, {
    "name" : "public static final NumberFormat getCurrencyInstance()",
    "returnType" : "NumberFormat",
    "comment" : "\n     * Returns a currency format for the current default\n     * {@link java.util.Locale.Category#FORMAT FORMAT} locale.\n     * <p>This is equivalent to calling\n     * {@link #getCurrencyInstance(Locale)\n     *     getCurrencyInstance(Locale.getDefault(Locale.Category.FORMAT))}.\n     *\n     * @return the {@code NumberFormat} instance for currency formatting\n     * @see java.util.Locale#getDefault(java.util.Locale.Category)\n     * @see java.util.Locale.Category#FORMAT\n     ",
    "links" : [ "#getCurrencyInstance(Locale)", "java.util.Locale.Category#FORMAT" ]
  }, {
    "name" : "public static NumberFormat getCurrencyInstance(Locale inLocale)",
    "returnType" : "NumberFormat",
    "comment" : "\n     * Returns a currency format for the specified locale.\n     *\n     * <p>If the specified locale contains the \"{@code cf}\" (\n     * <a href=\"https://www.unicode.org/reports/tr35/tr35.html#UnicodeCurrencyFormatIdentifier\">\n     * currency format style</a>)\n     * <a href=\"../util/Locale.html#def_locale_extension\">Unicode extension</a>,\n     * the returned currency format uses the style if it is available.\n     * Otherwise, the style uses the default \"{@code standard}\" currency format.\n     * For example, if the style designates \"{@code account}\", negative\n     * currency amounts use a pair of parentheses in some locales.\n     *\n     * @param inLocale the desired locale\n     * @return the {@code NumberFormat} instance for currency formatting\n     ",
    "links" : [ ]
  }, {
    "name" : "public static final NumberFormat getPercentInstance()",
    "returnType" : "NumberFormat",
    "comment" : "\n     * Returns a percentage format for the current default\n     * {@link java.util.Locale.Category#FORMAT FORMAT} locale.\n     * <p>This is equivalent to calling\n     * {@link #getPercentInstance(Locale)\n     *     getPercentInstance(Locale.getDefault(Locale.Category.FORMAT))}.\n     *\n     * @return the {@code NumberFormat} instance for percentage formatting\n     * @see java.util.Locale#getDefault(java.util.Locale.Category)\n     * @see java.util.Locale.Category#FORMAT\n     ",
    "links" : [ "#getPercentInstance(Locale)", "java.util.Locale.Category#FORMAT" ]
  }, {
    "name" : "public static NumberFormat getPercentInstance(Locale inLocale)",
    "returnType" : "NumberFormat",
    "comment" : "\n     * Returns a percentage format for the specified locale.\n     *\n     * @param inLocale the desired locale\n     * @return the {@code NumberFormat} instance for percentage formatting\n     ",
    "links" : [ ]
  }, {
    "name" : "public static Locale[] getAvailableLocales()",
    "returnType" : "Locale[]",
    "comment" : "\n     * Returns a compact number format for the default\n     * {@link java.util.Locale.Category#FORMAT FORMAT} locale with\n     * {@link NumberFormat.Style#SHORT \"SHORT\"} format style.\n     *\n     * @return A {@code NumberFormat} instance for compact number\n     *         formatting\n     *\n     * @see CompactNumberFormat\n     * @see NumberFormat.Style\n     * @see java.util.Locale#getDefault(java.util.Locale.Category)\n     * @see java.util.Locale.Category#FORMAT\n     * @since 12\n     *\n    public static NumberFormat getCompactNumberInstance() {\n        return getInstance(Locale.getDefault(\n                Locale.Category.FORMAT), NumberFormat.Style.SHORT, COMPACTSTYLE);\n    }\n\n    /*\n     * Returns a compact number format for the specified {@link java.util.Locale locale}\n     * and {@link NumberFormat.Style formatStyle}.\n     *\n     * @param locale the desired locale\n     * @param formatStyle the style for formatting a number\n     * @return A {@code NumberFormat} instance for compact number\n     *         formatting\n     * @throws NullPointerException if {@code locale} or {@code formatStyle}\n     *                              is {@code null}\n     *\n     * @see CompactNumberFormat\n     * @see NumberFormat.Style\n     * @see java.util.Locale\n     * @since 12\n     *\n    public static NumberFormat getCompactNumberInstance(Locale locale,\n            NumberFormat.Style formatStyle) {\n\n        Objects.requireNonNull(locale);\n        Objects.requireNonNull(formatStyle);\n        return getInstance(locale, formatStyle, COMPACTSTYLE);\n    }\n    // END Android-removed: Remove unsupprted CompactNumberFormat.\n\n    // Android-changed: Removed reference to NumberFormatProvider.\n    /**\n     * Returns an array of all locales for which the\n     * {@code get*Instance} methods of this class can return\n     * localized instances.\n     * It must contain at least a {@code Locale} instance equal to\n     * {@link java.util.Locale#US Locale.US}.\n     *\n     * @return An array of locales for which localized\n     *         {@code NumberFormat} instances are available.\n     ",
    "links" : [ "java.util.Locale.Category#FORMAT", "java.util.Locale", "NumberFormat.Style", "java.util.Locale#US", "NumberFormat.Style#SHORT" ]
  }, {
    "name" : "public int hashCode()",
    "returnType" : "int",
    "comment" : "\n     * Overrides hashCode.\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean equals(Object obj)",
    "returnType" : "boolean",
    "comment" : "\n     * Overrides equals.\n     ",
    "links" : [ ]
  }, {
    "name" : "public Object clone()",
    "returnType" : "Object",
    "comment" : "\n     * Overrides Cloneable.\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean isGroupingUsed()",
    "returnType" : "boolean",
    "comment" : "\n     * Returns true if grouping is used in this format. For example, in the\n     * English locale, with grouping on, the number 1234567 might be formatted\n     * as \"1,234,567\". The grouping separator as well as the size of each group\n     * is locale dependent and is determined by sub-classes of NumberFormat.\n     *\n     * @return {@code true} if grouping is used;\n     *         {@code false} otherwise\n     * @see #setGroupingUsed\n     ",
    "links" : [ ]
  }, {
    "name" : "public void setGroupingUsed(boolean newValue)",
    "returnType" : "void",
    "comment" : "\n     * Set whether or not grouping will be used in this format.\n     *\n     * @param newValue {@code true} if grouping is used;\n     *                 {@code false} otherwise\n     * @see #isGroupingUsed\n     ",
    "links" : [ ]
  }, {
    "name" : "public int getMaximumIntegerDigits()",
    "returnType" : "int",
    "comment" : "\n     * Returns the maximum number of digits allowed in the integer portion of a\n     * number.\n     *\n     * @return the maximum number of digits\n     * @see #setMaximumIntegerDigits\n     ",
    "links" : [ ]
  }, {
    "name" : "public void setMaximumIntegerDigits(int newValue)",
    "returnType" : "void",
    "comment" : "\n     * Sets the maximum number of digits allowed in the integer portion of a\n     * number. maximumIntegerDigits must be &ge; minimumIntegerDigits.  If the\n     * new value for maximumIntegerDigits is less than the current value\n     * of minimumIntegerDigits, then minimumIntegerDigits will also be set to\n     * the new value.\n     *\n     * @param newValue the maximum number of integer digits to be shown; if\n     * less than zero, then zero is used. The concrete subclass may enforce an\n     * upper limit to this value appropriate to the numeric type being formatted.\n     * @see #getMaximumIntegerDigits\n     ",
    "links" : [ ]
  }, {
    "name" : "public int getMinimumIntegerDigits()",
    "returnType" : "int",
    "comment" : "\n     * Returns the minimum number of digits allowed in the integer portion of a\n     * number.\n     *\n     * @return the minimum number of digits\n     * @see #setMinimumIntegerDigits\n     ",
    "links" : [ ]
  }, {
    "name" : "public void setMinimumIntegerDigits(int newValue)",
    "returnType" : "void",
    "comment" : "\n     * Sets the minimum number of digits allowed in the integer portion of a\n     * number. minimumIntegerDigits must be &le; maximumIntegerDigits.  If the\n     * new value for minimumIntegerDigits exceeds the current value\n     * of maximumIntegerDigits, then maximumIntegerDigits will also be set to\n     * the new value\n     *\n     * @param newValue the minimum number of integer digits to be shown; if\n     * less than zero, then zero is used. The concrete subclass may enforce an\n     * upper limit to this value appropriate to the numeric type being formatted.\n     * @see #getMinimumIntegerDigits\n     ",
    "links" : [ ]
  }, {
    "name" : "public int getMaximumFractionDigits()",
    "returnType" : "int",
    "comment" : "\n     * Returns the maximum number of digits allowed in the fraction portion of a\n     * number.\n     *\n     * @return the maximum number of digits.\n     * @see #setMaximumFractionDigits\n     ",
    "links" : [ ]
  }, {
    "name" : "public void setMaximumFractionDigits(int newValue)",
    "returnType" : "void",
    "comment" : "\n     * Sets the maximum number of digits allowed in the fraction portion of a\n     * number. maximumFractionDigits must be &ge; minimumFractionDigits.  If the\n     * new value for maximumFractionDigits is less than the current value\n     * of minimumFractionDigits, then minimumFractionDigits will also be set to\n     * the new value.\n     *\n     * @param newValue the maximum number of fraction digits to be shown; if\n     * less than zero, then zero is used. The concrete subclass may enforce an\n     * upper limit to this value appropriate to the numeric type being formatted.\n     * @see #getMaximumFractionDigits\n     ",
    "links" : [ ]
  }, {
    "name" : "public int getMinimumFractionDigits()",
    "returnType" : "int",
    "comment" : "\n     * Returns the minimum number of digits allowed in the fraction portion of a\n     * number.\n     *\n     * @return the minimum number of digits\n     * @see #setMinimumFractionDigits\n     ",
    "links" : [ ]
  }, {
    "name" : "public void setMinimumFractionDigits(int newValue)",
    "returnType" : "void",
    "comment" : "\n     * Sets the minimum number of digits allowed in the fraction portion of a\n     * number. minimumFractionDigits must be &le; maximumFractionDigits.  If the\n     * new value for minimumFractionDigits exceeds the current value\n     * of maximumFractionDigits, then maximumFractionDigits will also be set to\n     * the new value\n     *\n     * @param newValue the minimum number of fraction digits to be shown; if\n     * less than zero, then zero is used. The concrete subclass may enforce an\n     * upper limit to this value appropriate to the numeric type being formatted.\n     * @see #getMinimumFractionDigits\n     ",
    "links" : [ ]
  }, {
    "name" : "public Currency getCurrency()",
    "returnType" : "Currency",
    "comment" : "\n     * Gets the currency used by this number format when formatting\n     * currency values. The initial value is derived in a locale dependent\n     * way. The returned value may be null if no valid\n     * currency could be determined and no currency has been set using\n     * {@link #setCurrency(java.util.Currency) setCurrency}.\n     * <p>\n     * The default implementation throws\n     * {@code UnsupportedOperationException}.\n     *\n     * @return the currency used by this number format, or {@code null}\n     * @throws    UnsupportedOperationException if the number format class\n     * doesn't implement currency formatting\n     * @since 1.4\n     ",
    "links" : [ "#setCurrency(java.util.Currency)" ]
  }, {
    "name" : "public void setCurrency(Currency currency)",
    "returnType" : "void",
    "comment" : "\n     * Sets the currency used by this number format when formatting\n     * currency values. This does not update the minimum or maximum\n     * number of fraction digits used by the number format.\n     * <p>\n     * The default implementation throws\n     * {@code UnsupportedOperationException}.\n     *\n     * @param currency the new currency to be used by this number format\n     * @throws    UnsupportedOperationException if the number format class\n     * doesn't implement currency formatting\n     * @throws    NullPointerException if {@code currency} is null\n     * @since 1.4\n     ",
    "links" : [ ]
  }, {
    "name" : "public RoundingMode getRoundingMode()",
    "returnType" : "RoundingMode",
    "comment" : "\n     * Gets the {@link java.math.RoundingMode} used in this NumberFormat.\n     * The default implementation of this method in NumberFormat\n     * always throws {@link java.lang.UnsupportedOperationException}.\n     * Subclasses which handle different rounding modes should override\n     * this method.\n     *\n     * @throws    UnsupportedOperationException The default implementation\n     *     always throws this exception\n     * @return The {@code RoundingMode} used for this NumberFormat.\n     * @see #setRoundingMode(RoundingMode)\n     * @since 1.6\n     ",
    "links" : [ "java.lang.UnsupportedOperationException", "java.math.RoundingMode" ]
  }, {
    "name" : "public void setRoundingMode(RoundingMode roundingMode)",
    "returnType" : "void",
    "comment" : "\n     * Sets the {@link java.math.RoundingMode} used in this NumberFormat.\n     * The default implementation of this method in NumberFormat always\n     * throws {@link java.lang.UnsupportedOperationException}.\n     * Subclasses which handle different rounding modes should override\n     * this method.\n     *\n     * @throws    UnsupportedOperationException The default implementation\n     *     always throws this exception\n     * @throws    NullPointerException if {@code roundingMode} is null\n     * @param roundingMode The {@code RoundingMode} to be used\n     * @see #getRoundingMode()\n     * @since 1.6\n     ",
    "links" : [ "java.lang.UnsupportedOperationException", "java.math.RoundingMode" ]
  }, {
    "name" : "private static NumberFormat getInstance(Locale desiredLocale, Style formatStyle, int choice)",
    "returnType" : "NumberFormat",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private void readObject(ObjectInputStream stream) throws IOException, ClassNotFoundException",
    "returnType" : "void",
    "comment" : "\n     * First, read in the default serializable data.\n     *\n     * Then, if {@code serialVersionOnStream} is less than 1, indicating that\n     * the stream was written by JDK 1.1,\n     * set the {@code int} fields such as {@code maximumIntegerDigits}\n     * to be equal to the {@code byte} fields such as {@code maxIntegerDigits},\n     * since the {@code int} fields were not present in JDK 1.1.\n     * Finally, set serialVersionOnStream back to the maximum allowed value so that\n     * default serialization will work properly if this object is streamed out again.\n     *\n     * <p>If {@code minimumIntegerDigits} is greater than\n     * {@code maximumIntegerDigits} or {@code minimumFractionDigits}\n     * is greater than {@code maximumFractionDigits}, then the stream data\n     * is invalid and this method throws an {@code InvalidObjectException}.\n     * In addition, if any of these values is negative, then this method throws\n     * an {@code InvalidObjectException}.\n     *\n     * @since 1.2\n     ",
    "links" : [ ]
  }, {
    "name" : "private void writeObject(ObjectOutputStream stream) throws IOException",
    "returnType" : "void",
    "comment" : "\n     * Write out the default serializable data, after first setting\n     * the {@code byte} fields such as {@code maxIntegerDigits} to be\n     * equal to the {@code int} fields such as {@code maximumIntegerDigits}\n     * (or to {@code Byte.MAX_VALUE}, whichever is smaller), for compatibility\n     * with the JDK 1.1 version of the stream format.\n     *\n     * @since 1.2\n     ",
    "links" : [ ]
  } ],
  "methodNames" : [ "public StringBuffer format(Object number, StringBuffer toAppendTo, FieldPosition pos)", "public final Object parseObject(String source, ParsePosition pos)", "public final String format(double number)", "public final String format(long number)", "public abstract StringBuffer format(double number, StringBuffer toAppendTo, FieldPosition pos)", "public abstract StringBuffer format(long number, StringBuffer toAppendTo, FieldPosition pos)", "public abstract Number parse(String source, ParsePosition parsePosition)", "public Number parse(String source) throws ParseException", "public boolean isParseIntegerOnly()", "public void setParseIntegerOnly(boolean value)", "public static final NumberFormat getInstance()", "public static NumberFormat getInstance(Locale inLocale)", "public static final NumberFormat getNumberInstance()", "public static NumberFormat getNumberInstance(Locale inLocale)", "public static final NumberFormat getIntegerInstance()", "public static NumberFormat getIntegerInstance(Locale inLocale)", "public static final NumberFormat getCurrencyInstance()", "public static NumberFormat getCurrencyInstance(Locale inLocale)", "public static final NumberFormat getPercentInstance()", "public static NumberFormat getPercentInstance(Locale inLocale)", "public static Locale[] getAvailableLocales()", "public int hashCode()", "public boolean equals(Object obj)", "public Object clone()", "public boolean isGroupingUsed()", "public void setGroupingUsed(boolean newValue)", "public int getMaximumIntegerDigits()", "public void setMaximumIntegerDigits(int newValue)", "public int getMinimumIntegerDigits()", "public void setMinimumIntegerDigits(int newValue)", "public int getMaximumFractionDigits()", "public void setMaximumFractionDigits(int newValue)", "public int getMinimumFractionDigits()", "public void setMinimumFractionDigits(int newValue)", "public Currency getCurrency()", "public void setCurrency(Currency currency)", "public RoundingMode getRoundingMode()", "public void setRoundingMode(RoundingMode roundingMode)", "private static NumberFormat getInstance(Locale desiredLocale, Style formatStyle, int choice)", "private void readObject(ObjectInputStream stream) throws IOException, ClassNotFoundException", "private void writeObject(ObjectOutputStream stream) throws IOException" ],
  "variableNames" : [ "INTEGER_FIELD", "FRACTION_FIELD", "NUMBERSTYLE", "CURRENCYSTYLE", "PERCENTSTYLE", "INTEGERSTYLE", "groupingUsed", "maxIntegerDigits", "minIntegerDigits", "maxFractionDigits", "minFractionDigits", "parseIntegerOnly", "maximumIntegerDigits", "minimumIntegerDigits", "maximumFractionDigits", "minimumFractionDigits", "currentSerialVersion", "serialVersionOnStream", "serialVersionUID" ]
}