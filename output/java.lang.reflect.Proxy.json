{
  "filePath" : "/home/maryam/clearblue/files/android-source-35/java/lang/reflect/Proxy.java",
  "packageName" : "java.lang.reflect",
  "className" : "Proxy",
  "comment" : "\n * {@code Proxy} provides static methods for creating dynamic proxy\n * classes and instances, and it is also the superclass of all\n * dynamic proxy classes created by those methods.\n *\n * <p>To create a proxy for some interface {@code Foo}:\n * <pre>\n *     InvocationHandler handler = new MyInvocationHandler(...);\n *     Class&lt;?&gt; proxyClass = Proxy.getProxyClass(Foo.class.getClassLoader(), Foo.class);\n *     Foo f = (Foo) proxyClass.getConstructor(InvocationHandler.class).\n *                     newInstance(handler);\n * </pre>\n * or more simply:\n * <pre>\n *     Foo f = (Foo) Proxy.newProxyInstance(Foo.class.getClassLoader(),\n *                                          new Class&lt;?&gt;[] { Foo.class },\n *                                          handler);\n * </pre>\n *\n * <p>A <i>dynamic proxy class</i> (simply referred to as a <i>proxy\n * class</i> below) is a class that implements a list of interfaces\n * specified at runtime when the class is created, with behavior as\n * described below.\n *\n * A <i>proxy interface</i> is such an interface that is implemented\n * by a proxy class.\n *\n * A <i>proxy instance</i> is an instance of a proxy class.\n *\n * Each proxy instance has an associated <i>invocation handler</i>\n * object, which implements the interface {@link InvocationHandler}.\n * A method invocation on a proxy instance through one of its proxy\n * interfaces will be dispatched to the {@link InvocationHandler#invoke\n * invoke} method of the instance's invocation handler, passing the proxy\n * instance, a {@code java.lang.reflect.Method} object identifying\n * the method that was invoked, and an array of type {@code Object}\n * containing the arguments.  The invocation handler processes the\n * encoded method invocation as appropriate and the result that it\n * returns will be returned as the result of the method invocation on\n * the proxy instance.\n *\n * <p>A proxy class has the following properties:\n *\n * <ul>\n * <li>Proxy classes are <em>public, final, and not abstract</em> if\n * all proxy interfaces are public.</li>\n *\n * <li>Proxy classes are <em>non-public, final, and not abstract</em> if\n * any of the proxy interfaces is non-public.</li>\n *\n * <li>The unqualified name of a proxy class is unspecified.  The space\n * of class names that begin with the string {@code \"$Proxy\"}\n * should be, however, reserved for proxy classes.\n *\n * <li>A proxy class extends {@code java.lang.reflect.Proxy}.\n *\n * <li>A proxy class implements exactly the interfaces specified at its\n * creation, in the same order.\n *\n * <li>If a proxy class implements a non-public interface, then it will\n * be defined in the same package as that interface.  Otherwise, the\n * package of a proxy class is also unspecified.  Note that package\n * sealing will not prevent a proxy class from being successfully defined\n * in a particular package at runtime, and neither will classes already\n * defined by the same class loader and the same package with particular\n * signers.\n *\n * <li>Since a proxy class implements all of the interfaces specified at\n * its creation, invoking {@code getInterfaces} on its\n * {@code Class} object will return an array containing the same\n * list of interfaces (in the order specified at its creation), invoking\n * {@code getMethods} on its {@code Class} object will return\n * an array of {@code Method} objects that include all of the\n * methods in those interfaces, and invoking {@code getMethod} will\n * find methods in the proxy interfaces as would be expected.\n *\n * <li>The {@link Proxy#isProxyClass Proxy.isProxyClass} method will\n * return true if it is passed a proxy class-- a class returned by\n * {@code Proxy.getProxyClass} or the class of an object returned by\n * {@code Proxy.newProxyInstance}-- and false otherwise.\n *\n * <li>The {@code java.security.ProtectionDomain} of a proxy class\n * is the same as that of system classes loaded by the bootstrap class\n * loader, such as {@code java.lang.Object}, because the code for a\n * proxy class is generated by trusted system code.  This protection\n * domain will typically be granted\n * {@code java.security.AllPermission}.\n *\n * <li>Each proxy class has one public constructor that takes one argument,\n * an implementation of the interface {@link InvocationHandler}, to set\n * the invocation handler for a proxy instance.  Rather than having to use\n * the reflection API to access the public constructor, a proxy instance\n * can be also be created by calling the {@link Proxy#newProxyInstance\n * Proxy.newProxyInstance} method, which combines the actions of calling\n * {@link Proxy#getProxyClass Proxy.getProxyClass} with invoking the\n * constructor with an invocation handler.\n * </ul>\n *\n * <p>A proxy instance has the following properties:\n *\n * <ul>\n * <li>Given a proxy instance {@code proxy} and one of the\n * interfaces implemented by its proxy class {@code Foo}, the\n * following expression will return true:\n * <pre>\n *     {@code proxy instanceof Foo}\n * </pre>\n * and the following cast operation will succeed (rather than throwing\n * a {@code ClassCastException}):\n * <pre>\n *     {@code (Foo) proxy}\n * </pre>\n *\n * <li>Each proxy instance has an associated invocation handler, the one\n * that was passed to its constructor.  The static\n * {@link Proxy#getInvocationHandler Proxy.getInvocationHandler} method\n * will return the invocation handler associated with the proxy instance\n * passed as its argument.\n *\n * <li>An interface method invocation on a proxy instance will be\n * encoded and dispatched to the invocation handler's {@link\n * InvocationHandler#invoke invoke} method as described in the\n * documentation for that method.\n *\n * <li>An invocation of the {@code hashCode},\n * {@code equals}, or {@code toString} methods declared in\n * {@code java.lang.Object} on a proxy instance will be encoded and\n * dispatched to the invocation handler's {@code invoke} method in\n * the same manner as interface method invocations are encoded and\n * dispatched, as described above.  The declaring class of the\n * {@code Method} object passed to {@code invoke} will be\n * {@code java.lang.Object}.  Other public methods of a proxy\n * instance inherited from {@code java.lang.Object} are not\n * overridden by a proxy class, so invocations of those methods behave\n * like they do for instances of {@code java.lang.Object}.\n * </ul>\n *\n * <h3>Methods Duplicated in Multiple Proxy Interfaces</h3>\n *\n * <p>When two or more interfaces of a proxy class contain a method with\n * the same name and parameter signature, the order of the proxy class's\n * interfaces becomes significant.  When such a <i>duplicate method</i>\n * is invoked on a proxy instance, the {@code Method} object passed\n * to the invocation handler will not necessarily be the one whose\n * declaring class is assignable from the reference type of the interface\n * that the proxy's method was invoked through.  This limitation exists\n * because the corresponding method implementation in the generated proxy\n * class cannot determine which interface it was invoked through.\n * Therefore, when a duplicate method is invoked on a proxy instance,\n * the {@code Method} object for the method in the foremost interface\n * that contains the method (either directly or inherited through a\n * superinterface) in the proxy class's list of interfaces is passed to\n * the invocation handler's {@code invoke} method, regardless of the\n * reference type through which the method invocation occurred.\n *\n * <p>If a proxy interface contains a method with the same name and\n * parameter signature as the {@code hashCode}, {@code equals},\n * or {@code toString} methods of {@code java.lang.Object},\n * when such a method is invoked on a proxy instance, the\n * {@code Method} object passed to the invocation handler will have\n * {@code java.lang.Object} as its declaring class.  In other words,\n * the public, non-final methods of {@code java.lang.Object}\n * logically precede all of the proxy interfaces for the determination of\n * which {@code Method} object to pass to the invocation handler.\n *\n * <p>Note also that when a duplicate method is dispatched to an\n * invocation handler, the {@code invoke} method may only throw\n * checked exception types that are assignable to one of the exception\n * types in the {@code throws} clause of the method in <i>all</i> of\n * the proxy interfaces that it can be invoked through.  If the\n * {@code invoke} method throws a checked exception that is not\n * assignable to any of the exception types declared by the method in one\n * of the proxy interfaces that it can be invoked through, then an\n * unchecked {@code UndeclaredThrowableException} will be thrown by\n * the invocation on the proxy instance.  This restriction means that not\n * all of the exception types returned by invoking\n * {@code getExceptionTypes} on the {@code Method} object\n * passed to the {@code invoke} method can necessarily be thrown\n * successfully by the {@code invoke} method.\n *\n * @author      Peter Jones\n * @see         InvocationHandler\n * @since       1.3\n ",
  "links" : [ "java.lang.reflect.Proxy#isProxyClass", "java.lang.reflect.Proxy#getProxyClass", "java.lang.reflect.Proxy#getInvocationHandler", "java.lang.reflect.InvocationHandler#invoke", "java.lang.reflect.Proxy#newProxyInstanceProxy.newProxyInstance", "java.lang.reflect.InvocationHandler#invokeinvoke", "java.lang.reflect.InvocationHandler" ],
  "variables" : [ {
    "name" : "serialVersionUID",
    "type" : "long",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "constructorParams",
    "type" : "Class<?>[]",
    "comment" : " parameter types of a proxy class constructor ",
    "links" : [ ]
  }, {
    "name" : "proxyClassCache",
    "type" : "WeakCache<ClassLoader, Class<?>[], Class<?>>",
    "comment" : "\n     * a cache of proxy classes\n     ",
    "links" : [ ]
  }, {
    "name" : "h",
    "type" : "InvocationHandler",
    "comment" : "\n     * the invocation handler for this proxy instance.\n     * @serial\n     ",
    "links" : [ ]
  }, {
    "name" : "key0",
    "type" : "Object",
    "comment" : "\n     * a key used for proxy class with 0 implemented interfaces\n     ",
    "links" : [ ]
  }, {
    "name" : "ORDER_BY_SIGNATURE_AND_SUBTYPE",
    "type" : "Comparator<Method>",
    "comment" : "\n     * Orders methods by their name, parameters, return type and inheritance relationship.\n     *\n     * @hide\n     ",
    "links" : [ ]
  } ],
  "methods" : [ {
    "name" : "public static Class<?> getProxyClass(ClassLoader loader, Class<?>... interfaces) throws IllegalArgumentException",
    "returnType" : "Class<?>",
    "comment" : "\n     * Returns the {@code java.lang.Class} object for a proxy class\n     * given a class loader and an array of interfaces.  The proxy class\n     * will be defined by the specified class loader and will implement\n     * all of the supplied interfaces.  If any of the given interfaces\n     * is non-public, the proxy class will be non-public. If a proxy class\n     * for the same permutation of interfaces has already been defined by the\n     * class loader, then the existing proxy class will be returned; otherwise,\n     * a proxy class for those interfaces will be generated dynamically\n     * and defined by the class loader.\n     *\n     * <p>There are several restrictions on the parameters that may be\n     * passed to {@code Proxy.getProxyClass}:\n     *\n     * <ul>\n     * <li>All of the {@code Class} objects in the\n     * {@code interfaces} array must represent interfaces, not\n     * classes or primitive types.\n     *\n     * <li>No two elements in the {@code interfaces} array may\n     * refer to identical {@code Class} objects.\n     *\n     * <li>All of the interface types must be visible by name through the\n     * specified class loader.  In other words, for class loader\n     * {@code cl} and every interface {@code i}, the following\n     * expression must be true:\n     * <pre>\n     *     Class.forName(i.getName(), false, cl) == i\n     * </pre>\n     *\n     * <li>All non-public interfaces must be in the same package;\n     * otherwise, it would not be possible for the proxy class to\n     * implement all of the interfaces, regardless of what package it is\n     * defined in.\n     *\n     * <li>For any set of member methods of the specified interfaces\n     * that have the same signature:\n     * <ul>\n     * <li>If the return type of any of the methods is a primitive\n     * type or void, then all of the methods must have that same\n     * return type.\n     * <li>Otherwise, one of the methods must have a return type that\n     * is assignable to all of the return types of the rest of the\n     * methods.\n     * </ul>\n     *\n     * <li>The resulting proxy class must not exceed any limits imposed\n     * on classes by the virtual machine.  For example, the VM may limit\n     * the number of interfaces that a class may implement to 65535; in\n     * that case, the size of the {@code interfaces} array must not\n     * exceed 65535.\n     * </ul>\n     *\n     * <p>If any of these restrictions are violated,\n     * {@code Proxy.getProxyClass} will throw an\n     * {@code IllegalArgumentException}.  If the {@code interfaces}\n     * array argument or any of its elements are {@code null}, a\n     * {@code NullPointerException} will be thrown.\n     *\n     * <p>Note that the order of the specified proxy interfaces is\n     * significant: two requests for a proxy class with the same combination\n     * of interfaces but in a different order will result in two distinct\n     * proxy classes.\n     *\n     * @param   loader the class loader to define the proxy class\n     * @param   interfaces the list of interfaces for the proxy class\n     *          to implement\n     * @return  a proxy class that is defined in the specified class loader\n     *          and that implements the specified interfaces\n     * @throws  IllegalArgumentException if any of the restrictions on the\n     *          parameters that may be passed to {@code getProxyClass}\n     *          are violated\n     * @throws  SecurityException if a security manager, <em>s</em>, is present\n     *          and any of the following conditions is met:\n     *          <ul>\n     *             <li> the given {@code loader} is {@code null} and\n     *             the caller's class loader is not {@code null} and the\n     *             invocation of {@link SecurityManager#checkPermission\n     *             s.checkPermission} with\n     *             {@code RuntimePermission(\"getClassLoader\")} permission\n     *             denies access.</li>\n     *             <li> for each proxy interface, {@code intf},\n     *             the caller's class loader is not the same as or an\n     *             ancestor of the class loader for {@code intf} and\n     *             invocation of {@link SecurityManager#checkPackageAccess\n     *             s.checkPackageAccess()} denies access to {@code intf}.</li>\n     *          </ul>\n     * @throws  NullPointerException if the {@code interfaces} array\n     *          argument or any of its elements are {@code null}\n     ",
    "links" : [ "#checkPackageAccesss.checkPackageAccess()", "#checkPermissions.checkPermission" ]
  }, {
    "name" : "private static Class<?> getProxyClass0(ClassLoader loader, Class<?>... interfaces)",
    "returnType" : "Class<?>",
    "comment" : "\n     * Generate a proxy class.  Must call the checkProxyAccess method\n     * to perform permission checks before calling this.\n     ",
    "links" : [ ]
  }, {
    "name" : "private static List<Class<?>[]> deduplicateAndGetExceptions(List<Method> methods)",
    "returnType" : "List<Class<?>[]>",
    "comment" : "\n     * Remove methods that have the same name, parameters and return type. This\n     * computes the exceptions of each method; this is the intersection of the\n     * exceptions of equivalent methods.\n     *\n     * @param methods the methods to find exceptions for, ordered by name and\n     *     signature.\n     ",
    "links" : [ ]
  }, {
    "name" : "private static Class<?>[] intersectExceptions(Class<?>[] aExceptions, Class<?>[] bExceptions)",
    "returnType" : "Class<?>[]",
    "comment" : "\n     * Returns the exceptions that are declared in both {@code aExceptions} and\n     * {@code bExceptions}. If an exception type in one array is a subtype of an\n     * exception from the other, the subtype is included in the intersection.\n     ",
    "links" : [ ]
  }, {
    "name" : "private static void validateReturnTypes(List<Method> methods)",
    "returnType" : "void",
    "comment" : "\n     * Throws if any two methods in {@code methods} have the same name and\n     * parameters but incompatible return types.\n     *\n     * @param methods the methods to find exceptions for, ordered by name and\n     *     signature.\n     ",
    "links" : [ ]
  }, {
    "name" : "private static List<Method> getMethods(Class<?>[] interfaces)",
    "returnType" : "List<Method>",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private static void getMethodsRecursive(Class<?>[] interfaces, List<Method> methods)",
    "returnType" : "void",
    "comment" : "\n     * Fills {@code proxiedMethods} with the methods of {@code interfaces} and\n     * the interfaces they extend. May contain duplicates.\n     ",
    "links" : [ ]
  }, {
    "name" : "private static native Class<?> generateProxy(String name, Class<?>[] interfaces, ClassLoader loader, Method[] methods, Class<?>[][] exceptions)",
    "returnType" : "Class<?>",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public static Object newProxyInstance(ClassLoader loader, Class<?>[] interfaces, InvocationHandler h) throws IllegalArgumentException",
    "returnType" : "Object",
    "comment" : "\n     * Returns an instance of a proxy class for the specified interfaces\n     * that dispatches method invocations to the specified invocation\n     * handler.\n     *\n     * <p>{@code Proxy.newProxyInstance} throws\n     * {@code IllegalArgumentException} for the same reasons that\n     * {@code Proxy.getProxyClass} does.\n     *\n     * @param   loader the class loader to define the proxy class\n     * @param   interfaces the list of interfaces for the proxy class\n     *          to implement\n     * @param   h the invocation handler to dispatch method invocations to\n     * @return  a proxy instance with the specified invocation handler of a\n     *          proxy class that is defined by the specified class loader\n     *          and that implements the specified interfaces\n     * @throws  IllegalArgumentException if any of the restrictions on the\n     *          parameters that may be passed to {@code getProxyClass}\n     *          are violated\n     * @throws  SecurityException if a security manager, <em>s</em>, is present\n     *          and any of the following conditions is met:\n     *          <ul>\n     *          <li> the given {@code loader} is {@code null} and\n     *               the caller's class loader is not {@code null} and the\n     *               invocation of {@link SecurityManager#checkPermission\n     *               s.checkPermission} with\n     *               {@code RuntimePermission(\"getClassLoader\")} permission\n     *               denies access;</li>\n     *          <li> for each proxy interface, {@code intf},\n     *               the caller's class loader is not the same as or an\n     *               ancestor of the class loader for {@code intf} and\n     *               invocation of {@link SecurityManager#checkPackageAccess\n     *               s.checkPackageAccess()} denies access to {@code intf};</li>\n     *          <li> any of the given proxy interfaces is non-public and the\n     *               caller class is not in the same {@linkplain Package runtime package}\n     *               as the non-public interface and the invocation of\n     *               {@link SecurityManager#checkPermission s.checkPermission} with\n     *               {@code ReflectPermission(\"newProxyInPackage.{package name}\")}\n     *               permission denies access.</li>\n     *          </ul>\n     * @throws  NullPointerException if the {@code interfaces} array\n     *          argument or any of its elements are {@code null}, or\n     *          if the invocation handler, {@code h}, is\n     *          {@code null}\n     ",
    "links" : [ "#checkPackageAccesss.checkPackageAccess()", "#checkPermission", "#checkPermissions.checkPermission" ]
  }, {
    "name" : "public static boolean isProxyClass(Class<?> cl)",
    "returnType" : "boolean",
    "comment" : "\n     * Returns true if and only if the specified class was dynamically\n     * generated to be a proxy class using the {@code getProxyClass}\n     * method or the {@code newProxyInstance} method.\n     *\n     * <p>The reliability of this method is important for the ability\n     * to use it to make security decisions, so its implementation should\n     * not just test if the class in question extends {@code Proxy}.\n     *\n     * @param   cl the class to test\n     * @return  {@code true} if the class is a proxy class and\n     *          {@code false} otherwise\n     * @throws  NullPointerException if {@code cl} is {@code null}\n     ",
    "links" : [ ]
  }, {
    "name" : "public static InvocationHandler getInvocationHandler(Object proxy) throws IllegalArgumentException",
    "returnType" : "InvocationHandler",
    "comment" : "\n     * Returns the invocation handler for the specified proxy instance.\n     *\n     * @param   proxy the proxy instance to return the invocation handler for\n     * @return  the invocation handler for the proxy instance\n     * @throws  IllegalArgumentException if the argument is not a\n     *          proxy instance\n     * @throws  SecurityException if a security manager, <em>s</em>, is present\n     *          and the caller's class loader is not the same as or an\n     *          ancestor of the class loader for the invocation handler\n     *          and invocation of {@link SecurityManager#checkPackageAccess\n     *          s.checkPackageAccess()} denies access to the invocation\n     *          handler's class.\n     ",
    "links" : [ "#checkPackageAccesss.checkPackageAccess()" ]
  }, {
    "name" : "private static Object invoke(Proxy proxy, Method method, Object[] args) throws Throwable",
    "returnType" : "Object",
    "comment" : " Android-added: Helper method invoke(Proxy, Method, Object[]) for ART native code.",
    "links" : [ ]
  } ],
  "methodNames" : [ "public static Class<?> getProxyClass(ClassLoader loader, Class<?>... interfaces) throws IllegalArgumentException", "private static Class<?> getProxyClass0(ClassLoader loader, Class<?>... interfaces)", "private static List<Class<?>[]> deduplicateAndGetExceptions(List<Method> methods)", "private static Class<?>[] intersectExceptions(Class<?>[] aExceptions, Class<?>[] bExceptions)", "private static void validateReturnTypes(List<Method> methods)", "private static List<Method> getMethods(Class<?>[] interfaces)", "private static void getMethodsRecursive(Class<?>[] interfaces, List<Method> methods)", "private static native Class<?> generateProxy(String name, Class<?>[] interfaces, ClassLoader loader, Method[] methods, Class<?>[][] exceptions)", "public static Object newProxyInstance(ClassLoader loader, Class<?>[] interfaces, InvocationHandler h) throws IllegalArgumentException", "public static boolean isProxyClass(Class<?> cl)", "public static InvocationHandler getInvocationHandler(Object proxy) throws IllegalArgumentException", "private static Object invoke(Proxy proxy, Method method, Object[] args) throws Throwable" ],
  "variableNames" : [ "serialVersionUID", "constructorParams", "proxyClassCache", "h", "key0", "ORDER_BY_SIGNATURE_AND_SUBTYPE" ]
}