{
  "filePath" : "/home/maryam/clearblue/files/android-source-30/android/perftests/utils/ManualBenchmarkState.java",
  "packageName" : "android.perftests.utils",
  "className" : "ManualBenchmarkState",
  "comment" : "\n * Provides a benchmark framework.\n *\n * This differs from BenchmarkState in that rather than the class measuring the the elapsed time,\n * the test passes in the elapsed time.\n *\n * Example usage:\n *\n * public void sampleMethod() {\n *     ManualBenchmarkState state = new ManualBenchmarkState();\n *\n *     int[] src = new int[] { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 };\n *     long elapsedTime = 0;\n *     while (state.keepRunning(elapsedTime)) {\n *         long startTime = System.nanoTime();\n *         int[] dest = new int[src.length];\n *         System.arraycopy(src, 0, dest, 0, src.length);\n *         elapsedTime = System.nanoTime() - startTime;\n *     }\n *     System.out.println(state.summaryLine());\n * }\n *\n * Or use the PerfManualStatusReporter TestRule.\n *\n * Make sure that the overhead of checking the clock does not noticeably affect the results.\n ",
  "variables" : [ {
    "name" : "TAG",
    "type" : "String",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "DEFAULT_STATS_REPORT",
    "type" : "int",
    "comment" : " It means the entire {@link StatsReport} is not given. ",
    "links" : [ "StatsReport" ]
  }, {
    "name" : "WARMUP_DURATION_NS",
    "type" : "long",
    "comment" : " warm-up for duration",
    "links" : [ ]
  }, {
    "name" : "WARMUP_MIN_ITERATIONS",
    "type" : "int",
    "comment" : " minimum iterations to warm-up for",
    "links" : [ ]
  }, {
    "name" : "TARGET_TEST_DURATION_NS",
    "type" : "long",
    "comment" : " target testing for duration",
    "links" : [ ]
  }, {
    "name" : "MAX_TEST_ITERATIONS",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "MIN_TEST_ITERATIONS",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "NOT_STARTED",
    "type" : "int",
    "comment" : " The benchmark has not started yet.",
    "links" : [ ]
  }, {
    "name" : "WARMUP",
    "type" : "int",
    "comment" : " The benchmark is warming up.",
    "links" : [ ]
  }, {
    "name" : "RUNNING",
    "type" : "int",
    "comment" : " The benchmark is running.",
    "links" : [ ]
  }, {
    "name" : "RUNNING_CUSTOMIZED",
    "type" : "int",
    "comment" : " Running for customized measurement.",
    "links" : [ ]
  }, {
    "name" : "FINISHED",
    "type" : "int",
    "comment" : " The benchmark has stopped.",
    "links" : [ ]
  }, {
    "name" : "mState",
    "type" : "int",
    "comment" : " Current benchmark state.",
    "links" : [ ]
  }, {
    "name" : "mWarmupDurationNs",
    "type" : "long",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mTargetTestDurationNs",
    "type" : "long",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mWarmupStartTime",
    "type" : "long",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mWarmupIterations",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mMaxIterations",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mMaxCustomizedIterations",
    "type" : "int",
    "comment" : "\n     * Additinal iteration that used to apply customized measurement. The result during these\n     * iterations won't be counted into {@link #mStats}.\n     ",
    "links" : [ "#mStats" ]
  }, {
    "name" : "mCustomizedIterations",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mCustomizedIterationListener",
    "type" : "CustomizedIterationListener",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mResults",
    "type" : "ArrayList<Long>",
    "comment" : " Individual duration in nano seconds.",
    "links" : [ ]
  }, {
    "name" : "mExtraResults",
    "type" : "ArrayMap<String, ArrayList<Long>>",
    "comment" : " @see #addExtraResult(String, long) ",
    "links" : [ ]
  }, {
    "name" : "mTmpDurations",
    "type" : "List<Long>",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mStats",
    "type" : "Stats",
    "comment" : " The computation needs double precision, but long int is fine for final reporting.",
    "links" : [ ]
  }, {
    "name" : "mStatsReportFlags",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mStatsReportPercentiles",
    "type" : "int[]",
    "comment" : "",
    "links" : [ ]
  } ],
  "methods" : [ {
    "name" : "private boolean shouldReport(int statsReportFlag)",
    "returnType" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : " void configure(ManualBenchmarkTest testAnnotation)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private void beginBenchmark(long warmupDuration, int iterations)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public boolean keepRunning(long duration)",
    "returnType" : "boolean",
    "comment" : "\n     * Judges whether the benchmark needs more samples.\n     *\n     * For the usage, see class comment.\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean keepRunning(List<Long> durations)",
    "returnType" : "boolean",
    "comment" : "\n     * Similar to the {@link #keepRunning(long)} but accepts a list of durations\n     ",
    "links" : [ "#keepRunning(long)" ]
  }, {
    "name" : "public boolean isWarmingUp()",
    "returnType" : "boolean",
    "comment" : "\n     * @return {@code true} if the benchmark is in warmup state. It can be used to skip the\n     *         operations or measurements that are unnecessary while the test isn't running the\n     *         actual benchmark.\n     ",
    "links" : [ ]
  }, {
    "name" : "public void setCustomizedIterations(int iterations, CustomizedIterationListener listener)",
    "returnType" : "void",
    "comment" : "\n     * This is used to run the benchmark with more information by enabling some debug mechanism but\n     * we don't want to account the special runs (slower) in the stats report.\n     ",
    "links" : [ ]
  }, {
    "name" : "public void addExtraResult(String key, long duration)",
    "returnType" : "void",
    "comment" : "\n     * Adds additional result while this benchmark isn't warming up or running in customized state.\n     * It is used when a sequence of operations is executed consecutively, the duration of each\n     * operation can also be recorded.\n     ",
    "links" : [ ]
  }, {
    "name" : "private static String summaryLine(String key, Stats stats, ArrayList<Long> results)",
    "returnType" : "String",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private void fillStatus(Bundle status, String key, Stats stats)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public void sendFullStatusReport(Instrumentation instrumentation, String key)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  } ],
  "variableNames" : [ "TAG", "DEFAULT_STATS_REPORT", "WARMUP_DURATION_NS", "WARMUP_MIN_ITERATIONS", "TARGET_TEST_DURATION_NS", "MAX_TEST_ITERATIONS", "MIN_TEST_ITERATIONS", "NOT_STARTED", "WARMUP", "RUNNING", "RUNNING_CUSTOMIZED", "FINISHED", "mState", "mWarmupDurationNs", "mTargetTestDurationNs", "mWarmupStartTime", "mWarmupIterations", "mMaxIterations", "mMaxCustomizedIterations", "mCustomizedIterations", "mCustomizedIterationListener", "mResults", "mExtraResults", "mTmpDurations", "mStats", "mStatsReportFlags", "mStatsReportPercentiles" ],
  "methodNames" : [ "private boolean shouldReport(int statsReportFlag)", " void configure(ManualBenchmarkTest testAnnotation)", "private void beginBenchmark(long warmupDuration, int iterations)", "public boolean keepRunning(long duration)", "public boolean keepRunning(List<Long> durations)", "public boolean isWarmingUp()", "public void setCustomizedIterations(int iterations, CustomizedIterationListener listener)", "public void addExtraResult(String key, long duration)", "private static String summaryLine(String key, Stats stats, ArrayList<Long> results)", "private void fillStatus(Bundle status, String key, Stats stats)", "public void sendFullStatusReport(Instrumentation instrumentation, String key)" ]
}