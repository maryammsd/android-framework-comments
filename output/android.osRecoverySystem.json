{
  "filePath" : "/home/maryam/clearblue/files/android-source-30/android/os/RecoverySystem.java",
  "packageName" : "android.os",
  "className" : "RecoverySystem",
  "comment" : "\n * RecoverySystem contains methods for interacting with the Android\n * recovery system (the separate partition that can be used to install\n * system updates, wipe user data, etc.)\n ",
  "variables" : [ {
    "name" : "TAG",
    "type" : "String",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "DEFAULT_KEYSTORE",
    "type" : "File",
    "comment" : "\n     * Default location of zip file containing public keys (X509\n     * certs) authorized to sign OTA updates.\n     ",
    "links" : [ ]
  }, {
    "name" : "PUBLISH_PROGRESS_INTERVAL_MS",
    "type" : "long",
    "comment" : " Send progress to listeners no more often than this (in ms). ",
    "links" : [ ]
  }, {
    "name" : "DEFAULT_EUICC_FACTORY_RESET_TIMEOUT_MILLIS",
    "type" : "long",
    "comment" : " 30 s",
    "links" : [ ]
  }, {
    "name" : "MIN_EUICC_FACTORY_RESET_TIMEOUT_MILLIS",
    "type" : "long",
    "comment" : " 5 s",
    "links" : [ ]
  }, {
    "name" : "MAX_EUICC_FACTORY_RESET_TIMEOUT_MILLIS",
    "type" : "long",
    "comment" : " 60 s",
    "links" : [ ]
  }, {
    "name" : "DEFAULT_EUICC_REMOVING_INVISIBLE_PROFILES_TIMEOUT_MILLIS",
    "type" : "long",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "MIN_EUICC_REMOVING_INVISIBLE_PROFILES_TIMEOUT_MILLIS",
    "type" : "long",
    "comment" : " 15 s",
    "links" : [ ]
  }, {
    "name" : "MAX_EUICC_REMOVING_INVISIBLE_PROFILES_TIMEOUT_MILLIS",
    "type" : "long",
    "comment" : " 90 s",
    "links" : [ ]
  }, {
    "name" : "RECOVERY_DIR",
    "type" : "File",
    "comment" : " Used to communicate with recovery.  See bootable/recovery/recovery.cpp. ",
    "links" : [ ]
  }, {
    "name" : "LOG_FILE",
    "type" : "File",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "LAST_INSTALL_PATH",
    "type" : "String",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "LAST_PREFIX",
    "type" : "String",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "ACTION_EUICC_FACTORY_RESET",
    "type" : "String",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "ACTION_EUICC_REMOVE_INVISIBLE_SUBSCRIPTIONS",
    "type" : "String",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "PACKAGE_NAME_EUICC_DATA_MANAGEMENT_CALLBACK",
    "type" : "String",
    "comment" : "\n     * Used in {@link #wipeEuiccData} & {@link #removeEuiccInvisibleSubs} as package name of\n     * callback intent.\n     ",
    "links" : [ "#wipeEuiccData", "#removeEuiccInvisibleSubs" ]
  }, {
    "name" : "BLOCK_MAP_FILE",
    "type" : "File",
    "comment" : "\n     * The recovery image uses this file to identify the location (i.e. blocks)\n     * of an OTA package on the /data partition. The block map file is\n     * generated by uncrypt.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "UNCRYPT_PACKAGE_FILE",
    "type" : "File",
    "comment" : "\n     * UNCRYPT_PACKAGE_FILE stores the filename to be uncrypt'd, which will be\n     * read by uncrypt.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "UNCRYPT_STATUS_FILE",
    "type" : "File",
    "comment" : "\n     * UNCRYPT_STATUS_FILE stores the time cost (and error code in the case of a failure)\n     * of uncrypt.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "LOG_FILE_MAX_LENGTH",
    "type" : "int",
    "comment" : " Length limits for reading files.",
    "links" : [ ]
  }, {
    "name" : "sRequestLock",
    "type" : "Object",
    "comment" : " Prevent concurrent execution of requests.",
    "links" : [ ]
  }, {
    "name" : "mService",
    "type" : "IRecoverySystem",
    "comment" : "",
    "links" : [ ]
  } ],
  "methods" : [ {
    "name" : "private static HashSet<X509Certificate> getTrustedCerts(File keystore) throws IOException, GeneralSecurityException",
    "returnType" : "HashSet<X509Certificate>",
    "comment" : " @return the set of certs that can be used to sign an OTA package. ",
    "links" : [ ]
  }, {
    "name" : "public static void verifyPackage(File packageFile, ProgressListener listener, File deviceCertsZipFile) throws IOException, GeneralSecurityException",
    "returnType" : "void",
    "comment" : "\n     * Verify the cryptographic signature of a system update package\n     * before installing it.  Note that the package is also verified\n     * separately by the installer once the device is rebooted into\n     * the recovery system.  This function will return only if the\n     * package was successfully verified; otherwise it will throw an\n     * exception.\n     *\n     * Verification of a package can take significant time, so this\n     * function should not be called from a UI thread.  Interrupting\n     * the thread while this function is in progress will result in a\n     * SecurityException being thrown (and the thread's interrupt flag\n     * will be cleared).\n     *\n     * @param packageFile  the package to be verified\n     * @param listener     an object to receive periodic progress\n     * updates as verification proceeds.  May be null.\n     * @param deviceCertsZipFile  the zip file of certificates whose\n     * public keys we will accept.  Verification succeeds if the\n     * package is signed by the private key corresponding to any\n     * public key in this file.  May be null to use the system default\n     * file (currently \"/system/etc/security/otacerts.zip\").\n     *\n     * @throws IOException if there were any errors reading the\n     * package or certs files.\n     * @throws GeneralSecurityException if verification failed\n     ",
    "links" : [ ]
  }, {
    "name" : "private static boolean verifyPackageCompatibility(InputStream inputStream) throws IOException",
    "returnType" : "boolean",
    "comment" : "\n     * Verifies the compatibility entry from an {@link InputStream}.\n     *\n     * @return the verification result.\n     ",
    "links" : [ "InputStream" ]
  }, {
    "name" : "private static boolean readAndVerifyPackageCompatibilityEntry(File packageFile) throws IOException",
    "returnType" : "boolean",
    "comment" : "\n     * Reads and verifies the compatibility entry in an OTA zip package. The compatibility entry is\n     * a zip file (inside the OTA package zip).\n     *\n     * @return {@code true} if the entry doesn't exist or verification passes.\n     ",
    "links" : [ ]
  }, {
    "name" : "public static boolean verifyPackageCompatibility(File compatibilityFile) throws IOException",
    "returnType" : "boolean",
    "comment" : "\n     * Verifies the package compatibility info against the current system.\n     *\n     * @param compatibilityFile the {@link File} that contains the package compatibility info.\n     * @throws IOException if there were any errors reading the compatibility file.\n     * @return the compatibility verification result.\n     *\n     * {@hide}\n     ",
    "links" : [ "File" ]
  }, {
    "name" : "public static void processPackage(Context context, File packageFile, final ProgressListener listener, final Handler handler) throws IOException",
    "returnType" : "void",
    "comment" : "\n     * Process a given package with uncrypt. No-op if the package is not on the\n     * /data partition.\n     *\n     * @param Context      the Context to use\n     * @param packageFile  the package to be processed\n     * @param listener     an object to receive periodic progress updates as\n     *                     processing proceeds.  May be null.\n     * @param handler      the Handler upon which the callbacks will be\n     *                     executed.\n     *\n     * @throws IOException if there were any errors processing the package file.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public static void processPackage(Context context, File packageFile, final ProgressListener listener) throws IOException",
    "returnType" : "void",
    "comment" : "\n     * Process a given package with uncrypt. No-op if the package is not on the\n     * /data partition.\n     *\n     * @param Context      the Context to use\n     * @param packageFile  the package to be processed\n     * @param listener     an object to receive periodic progress updates as\n     *                     processing proceeds.  May be null.\n     *\n     * @throws IOException if there were any errors processing the package file.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public static void installPackage(Context context, File packageFile) throws IOException",
    "returnType" : "void",
    "comment" : "\n     * Reboots the device in order to install the given update\n     * package.\n     * Requires the {@link android.Manifest.permission#REBOOT} permission.\n     *\n     * @param context      the Context to use\n     * @param packageFile  the update package to install.  Must be on\n     * a partition mountable by recovery.  (The set of partitions\n     * known to recovery may vary from device to device.  Generally,\n     * /cache and /data are safe.)\n     *\n     * @throws IOException  if writing the recovery command file\n     * fails, or if the reboot itself fails.\n     ",
    "links" : [ "android.Manifest.permission#REBOOT" ]
  }, {
    "name" : "public static void installPackage(Context context, File packageFile, boolean processed) throws IOException",
    "returnType" : "void",
    "comment" : "\n     * If the package hasn't been processed (i.e. uncrypt'd), set up\n     * UNCRYPT_PACKAGE_FILE and delete BLOCK_MAP_FILE to trigger uncrypt during the\n     * reboot.\n     *\n     * @param context      the Context to use\n     * @param packageFile  the update package to install.  Must be on a\n     * partition mountable by recovery.\n     * @param processed    if the package has been processed (uncrypt'd).\n     *\n     * @throws IOException if writing the recovery command file fails, or if\n     * the reboot itself fails.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public static void prepareForUnattendedUpdate(@NonNull Context context, @NonNull String updateToken, @Nullable IntentSender intentSender) throws IOException",
    "returnType" : "void",
    "comment" : "\n     * Prepare to apply an unattended update by asking the user for their Lock Screen Knowledge\n     * Factor (LSKF). If supplied, the {@code intentSender} will be called when the system is setup\n     * and ready to apply the OTA.\n     * <p>\n     * When the system is already prepared for update and this API is called again with the same\n     * {@code updateToken}, it will not call the intent sender nor request the user enter their Lock\n     * Screen Knowledge Factor.\n     * <p>\n     * When this API is called again with a different {@code updateToken}, the prepared-for-update\n     * status is reset and process repeats as though it's the initial call to this method as\n     * described in the first paragraph.\n     *\n     * @param context the Context to use.\n     * @param updateToken token used to indicate which update was prepared\n     * @param intentSender the intent to call when the update is prepared; may be {@code null}\n     * @throws IOException if there were any errors setting up unattended update\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public static void clearPrepareForUnattendedUpdate(@NonNull Context context) throws IOException",
    "returnType" : "void",
    "comment" : "\n     * Request that any previously requested Lock Screen Knowledge Factor (LSKF) is cleared and\n     * the preparation for unattended update is reset.\n     *\n     * @param context the Context to use.\n     * @throws IOException if there were any errors clearing the unattended update state\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public static void rebootAndApply(@NonNull Context context, @NonNull String updateToken, @NonNull String reason) throws IOException",
    "returnType" : "void",
    "comment" : "\n     * Request that the device reboot and apply the update that has been prepared. The\n     * {@code updateToken} must match what was given for {@link #prepareForUnattendedUpdate} or\n     * this will return {@code false}.\n     *\n     * @param context the Context to use.\n     * @param updateToken the token used to call {@link #prepareForUnattendedUpdate} before\n     * @param reason the reboot reason to give to the {@link PowerManager}\n     * @throws IOException if the reboot couldn't proceed because the device wasn't ready for an\n     *               unattended reboot or if the {@code updateToken} did not match the previously\n     *               given token\n     * @hide\n     ",
    "links" : [ "#prepareForUnattendedUpdate", "#prepareForUnattendedUpdate", "PowerManager" ]
  }, {
    "name" : "public static void scheduleUpdateOnBoot(Context context, File packageFile) throws IOException",
    "returnType" : "void",
    "comment" : "\n     * Schedule to install the given package on next boot. The caller needs to ensure that the\n     * package must have been processed (uncrypt'd) if needed. It sets up the command in BCB\n     * (bootloader control block), which will be read by the bootloader and the recovery image.\n     *\n     * @param context the Context to use.\n     * @param packageFile the package to be installed.\n     * @throws IOException if there were any errors setting up the BCB.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public static void cancelScheduledUpdate(Context context) throws IOException",
    "returnType" : "void",
    "comment" : "\n     * Cancel any scheduled update by clearing up the BCB (bootloader control\n     * block).\n     *\n     * @param Context      the Context to use.\n     *\n     * @throws IOException if there were any errors clearing up the BCB.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public static void rebootWipeUserData(Context context) throws IOException",
    "returnType" : "void",
    "comment" : "\n     * Reboots the device and wipes the user data and cache\n     * partitions.  This is sometimes called a \"factory reset\", which\n     * is something of a misnomer because the system partition is not\n     * restored to its factory state.  Requires the\n     * {@link android.Manifest.permission#REBOOT} permission.\n     *\n     * @param context  the Context to use\n     *\n     * @throws IOException  if writing the recovery command file\n     * fails, or if the reboot itself fails.\n     * @throws SecurityException if the current user is not allowed to wipe data.\n     ",
    "links" : [ "android.Manifest.permission#REBOOT" ]
  }, {
    "name" : "public static void rebootWipeUserData(Context context, String reason) throws IOException",
    "returnType" : "void",
    "comment" : " {@hide} ",
    "links" : [ ]
  }, {
    "name" : "public static void rebootWipeUserData(Context context, boolean shutdown) throws IOException",
    "returnType" : "void",
    "comment" : " {@hide} ",
    "links" : [ ]
  }, {
    "name" : "public static void rebootWipeUserData(Context context, boolean shutdown, String reason, boolean force) throws IOException",
    "returnType" : "void",
    "comment" : " {@hide} ",
    "links" : [ ]
  }, {
    "name" : "public static void rebootWipeUserData(Context context, boolean shutdown, String reason, boolean force, boolean wipeEuicc) throws IOException",
    "returnType" : "void",
    "comment" : "\n     * Reboots the device and wipes the user data and cache\n     * partitions.  This is sometimes called a \"factory reset\", which\n     * is something of a misnomer because the system partition is not\n     * restored to its factory state.  Requires the\n     * {@link android.Manifest.permission#REBOOT} permission.\n     *\n     * @param context   the Context to use\n     * @param shutdown  if true, the device will be powered down after\n     *                  the wipe completes, rather than being rebooted\n     *                  back to the regular system.\n     * @param reason    the reason for the wipe that is visible in the logs\n     * @param force     whether the {@link UserManager.DISALLOW_FACTORY_RESET} user restriction\n     *                  should be ignored\n     * @param wipeEuicc whether wipe the euicc data\n     *\n     * @throws IOException  if writing the recovery command file\n     * fails, or if the reboot itself fails.\n     * @throws SecurityException if the current user is not allowed to wipe data.\n     *\n     * @hide\n     ",
    "links" : [ "android.Manifest.permission#REBOOT", "UserManager.DISALLOW_FACTORY_RESET" ]
  }, {
    "name" : "public static boolean wipeEuiccData(Context context, final String packageName)",
    "returnType" : "boolean",
    "comment" : "\n     * Returns whether wipe Euicc data successfully or not.\n     *\n     * @param packageName the package name of the caller app.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "private static void removeEuiccInvisibleSubs(Context context, EuiccManager euiccManager)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private static boolean removeEuiccInvisibleSubs(Context context, List<SubscriptionInfo> subscriptionInfos, EuiccManager euiccManager)",
    "returnType" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public static void rebootPromptAndWipeUserData(Context context, String reason) throws IOException",
    "returnType" : "void",
    "comment" : " {@hide} ",
    "links" : [ ]
  }, {
    "name" : "public static void rebootWipeCache(Context context) throws IOException",
    "returnType" : "void",
    "comment" : "\n     * Reboot into the recovery system to wipe the /cache partition.\n     * @throws IOException if something goes wrong.\n     ",
    "links" : [ ]
  }, {
    "name" : "public static void rebootWipeCache(Context context, String reason) throws IOException",
    "returnType" : "void",
    "comment" : " {@hide} ",
    "links" : [ ]
  }, {
    "name" : "public static void rebootWipeAb(Context context, File packageFile, String reason) throws IOException",
    "returnType" : "void",
    "comment" : "\n     * Reboot into recovery and wipe the A/B device.\n     *\n     * @param Context      the Context to use.\n     * @param packageFile  the wipe package to be applied.\n     * @param reason       the reason to wipe.\n     *\n     * @throws IOException if something goes wrong.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "private static void bootCommand(Context context, String... args) throws IOException",
    "returnType" : "void",
    "comment" : "\n     * Reboot into the recovery system with the supplied argument.\n     * @param args to pass to the recovery utility.\n     * @throws IOException if something goes wrong.\n     ",
    "links" : [ ]
  }, {
    "name" : "public static String handleAftermath(Context context)",
    "returnType" : "String",
    "comment" : "\n     * Called after booting to process and remove recovery-related files.\n     * @return the log file from recovery, or null if none was found.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "private static void recursiveDelete(File name)",
    "returnType" : "void",
    "comment" : "\n     * Internally, delete a given file or directory recursively.\n     ",
    "links" : [ ]
  }, {
    "name" : "private boolean uncrypt(String packageFile, IRecoverySystemProgressListener listener)",
    "returnType" : "boolean",
    "comment" : "\n     * Talks to RecoverySystemService via Binder to trigger uncrypt.\n     ",
    "links" : [ ]
  }, {
    "name" : "private boolean setupBcb(String command)",
    "returnType" : "boolean",
    "comment" : "\n     * Talks to RecoverySystemService via Binder to set up the BCB.\n     ",
    "links" : [ ]
  }, {
    "name" : "private boolean clearBcb()",
    "returnType" : "boolean",
    "comment" : "\n     * Talks to RecoverySystemService via Binder to clear up the BCB.\n     ",
    "links" : [ ]
  }, {
    "name" : "private void rebootRecoveryWithCommand(String command)",
    "returnType" : "void",
    "comment" : "\n     * Talks to RecoverySystemService via Binder to set up the BCB command and\n     * reboot into recovery accordingly.\n     ",
    "links" : [ ]
  }, {
    "name" : "private boolean requestLskf(String updateToken, IntentSender sender) throws IOException",
    "returnType" : "boolean",
    "comment" : "\n     * Begins the process of asking the user for the Lock Screen Knowledge Factor.\n     *\n     * @param updateToken token that will be used in calls to {@link #rebootAndApply} to ensure\n     *                    that the preparation was for the correct update\n     * @return true if the request was correct\n     * @throws IOException if the recovery system service could not be contacted\n     ",
    "links" : [ "#rebootAndApply" ]
  }, {
    "name" : "private boolean clearLskf() throws IOException",
    "returnType" : "boolean",
    "comment" : "\n     * Calls the recovery system service and clears the setup for the OTA.\n     *\n     * @return true if the setup for OTA was cleared\n     * @throws IOException if the recovery system service could not be contacted\n     ",
    "links" : [ ]
  }, {
    "name" : "private boolean rebootWithLskf(String updateToken, String reason) throws IOException",
    "returnType" : "boolean",
    "comment" : "\n     * Calls the recovery system service to reboot and apply update.\n     *\n     * @param updateToken the update token for which the update was prepared\n     ",
    "links" : [ ]
  }, {
    "name" : "private static String sanitizeArg(String arg)",
    "returnType" : "String",
    "comment" : "\n     * Internally, recovery treats each line of the command file as a separate\n     * argv, so we only need to protect against newlines and nulls.\n     ",
    "links" : [ ]
  } ],
  "variableNames" : [ "TAG", "DEFAULT_KEYSTORE", "PUBLISH_PROGRESS_INTERVAL_MS", "DEFAULT_EUICC_FACTORY_RESET_TIMEOUT_MILLIS", "MIN_EUICC_FACTORY_RESET_TIMEOUT_MILLIS", "MAX_EUICC_FACTORY_RESET_TIMEOUT_MILLIS", "DEFAULT_EUICC_REMOVING_INVISIBLE_PROFILES_TIMEOUT_MILLIS", "MIN_EUICC_REMOVING_INVISIBLE_PROFILES_TIMEOUT_MILLIS", "MAX_EUICC_REMOVING_INVISIBLE_PROFILES_TIMEOUT_MILLIS", "RECOVERY_DIR", "LOG_FILE", "LAST_INSTALL_PATH", "LAST_PREFIX", "ACTION_EUICC_FACTORY_RESET", "ACTION_EUICC_REMOVE_INVISIBLE_SUBSCRIPTIONS", "PACKAGE_NAME_EUICC_DATA_MANAGEMENT_CALLBACK", "BLOCK_MAP_FILE", "UNCRYPT_PACKAGE_FILE", "UNCRYPT_STATUS_FILE", "LOG_FILE_MAX_LENGTH", "sRequestLock", "mService" ],
  "methodNames" : [ "private static HashSet<X509Certificate> getTrustedCerts(File keystore) throws IOException, GeneralSecurityException", "public static void verifyPackage(File packageFile, ProgressListener listener, File deviceCertsZipFile) throws IOException, GeneralSecurityException", "private static boolean verifyPackageCompatibility(InputStream inputStream) throws IOException", "private static boolean readAndVerifyPackageCompatibilityEntry(File packageFile) throws IOException", "public static boolean verifyPackageCompatibility(File compatibilityFile) throws IOException", "public static void processPackage(Context context, File packageFile, final ProgressListener listener, final Handler handler) throws IOException", "public static void processPackage(Context context, File packageFile, final ProgressListener listener) throws IOException", "public static void installPackage(Context context, File packageFile) throws IOException", "public static void installPackage(Context context, File packageFile, boolean processed) throws IOException", "public static void prepareForUnattendedUpdate(@NonNull Context context, @NonNull String updateToken, @Nullable IntentSender intentSender) throws IOException", "public static void clearPrepareForUnattendedUpdate(@NonNull Context context) throws IOException", "public static void rebootAndApply(@NonNull Context context, @NonNull String updateToken, @NonNull String reason) throws IOException", "public static void scheduleUpdateOnBoot(Context context, File packageFile) throws IOException", "public static void cancelScheduledUpdate(Context context) throws IOException", "public static void rebootWipeUserData(Context context) throws IOException", "public static void rebootWipeUserData(Context context, String reason) throws IOException", "public static void rebootWipeUserData(Context context, boolean shutdown) throws IOException", "public static void rebootWipeUserData(Context context, boolean shutdown, String reason, boolean force) throws IOException", "public static void rebootWipeUserData(Context context, boolean shutdown, String reason, boolean force, boolean wipeEuicc) throws IOException", "public static boolean wipeEuiccData(Context context, final String packageName)", "private static void removeEuiccInvisibleSubs(Context context, EuiccManager euiccManager)", "private static boolean removeEuiccInvisibleSubs(Context context, List<SubscriptionInfo> subscriptionInfos, EuiccManager euiccManager)", "public static void rebootPromptAndWipeUserData(Context context, String reason) throws IOException", "public static void rebootWipeCache(Context context) throws IOException", "public static void rebootWipeCache(Context context, String reason) throws IOException", "public static void rebootWipeAb(Context context, File packageFile, String reason) throws IOException", "private static void bootCommand(Context context, String... args) throws IOException", "public static String handleAftermath(Context context)", "private static void recursiveDelete(File name)", "private boolean uncrypt(String packageFile, IRecoverySystemProgressListener listener)", "private boolean setupBcb(String command)", "private boolean clearBcb()", "private void rebootRecoveryWithCommand(String command)", "private boolean requestLskf(String updateToken, IntentSender sender) throws IOException", "private boolean clearLskf() throws IOException", "private boolean rebootWithLskf(String updateToken, String reason) throws IOException", "private static String sanitizeArg(String arg)" ]
}