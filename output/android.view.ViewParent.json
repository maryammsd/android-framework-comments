{
  "filePath" : "/home/maryam/clearblue/files/android-source-35/android/view/ViewParent.java",
  "packageName" : "android.view",
  "className" : "ViewParent",
  "comment" : "\n * Defines the responsibilities for a class that will be a parent of a View.\n * This is the API that a view sees when it wants to interact with its parent.\n * \n ",
  "links" : [ ],
  "variables" : [ ],
  "methods" : [ {
    "name" : "public void requestLayout()",
    "returnType" : "void",
    "comment" : "\n     * Called when something has changed which has invalidated the layout of a\n     * child of this view parent. This will schedule a layout pass of the view\n     * tree.\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean isLayoutRequested()",
    "returnType" : "boolean",
    "comment" : "\n     * Indicates whether layout was requested on this view parent.\n     *\n     * @return true if layout was requested, false otherwise\n     ",
    "links" : [ ]
  }, {
    "name" : "public void requestTransparentRegion(View child)",
    "returnType" : "void",
    "comment" : "\n     * Called when a child wants the view hierarchy to gather and report\n     * transparent regions to the window compositor. Views that \"punch\" holes in\n     * the view hierarchy, such as SurfaceView can use this API to improve\n     * performance of the system. When no such a view is present in the\n     * hierarchy, this optimization in unnecessary and might slightly reduce the\n     * view hierarchy performance.\n     * \n     * @param child the view requesting the transparent region computation\n     * \n     ",
    "links" : [ ]
  }, {
    "name" : " void onDescendantInvalidated(@NonNull View child, @NonNull View target)",
    "returnType" : "void",
    "comment" : "\n     * The target View has been invalidated, or has had a drawing property changed that\n     * requires the hierarchy to re-render.\n     *\n     * This method is called by the View hierarchy to signal ancestors that a View either needs to\n     * re-record its drawing commands, or drawing properties have changed. This is how Views\n     * schedule a drawing traversal.\n     *\n     * This signal is generally only dispatched for attached Views, since only they need to draw.\n     *\n     * @param child Direct child of this ViewParent containing target\n     * @param target The view that needs to redraw\n     ",
    "links" : [ ]
  }, {
    "name" : "public void invalidateChild(View child, Rect r)",
    "returnType" : "void",
    "comment" : "\n     * All or part of a child is dirty and needs to be redrawn.\n     * \n     * @param child The child which is dirty\n     * @param r The area within the child that is invalid\n     *\n     * @deprecated Use {@link #onDescendantInvalidated(View, View)} instead.\n     ",
    "links" : [ "#onDescendantInvalidated(View" ]
  }, {
    "name" : "public ViewParent invalidateChildInParent(int[] location, Rect r)",
    "returnType" : "ViewParent",
    "comment" : "\n     * All or part of a child is dirty and needs to be redrawn.\n     *\n     * <p>The location array is an array of two int values which respectively\n     * define the left and the top position of the dirty child.</p>\n     *\n     * <p>This method must return the parent of this ViewParent if the specified\n     * rectangle must be invalidated in the parent. If the specified rectangle\n     * does not require invalidation in the parent or if the parent does not\n     * exist, this method must return null.</p>\n     *\n     * <p>When this method returns a non-null value, the location array must\n     * have been updated with the left and top coordinates of this ViewParent.</p>\n     *\n     * @param location An array of 2 ints containing the left and top\n     *        coordinates of the child to invalidate\n     * @param r The area within the child that is invalid\n     *\n     * @return the parent of this ViewParent or null\n     *\n     * @deprecated Use {@link #onDescendantInvalidated(View, View)} instead.\n     ",
    "links" : [ "#onDescendantInvalidated(View" ]
  }, {
    "name" : "public ViewParent getParent()",
    "returnType" : "ViewParent",
    "comment" : "\n     * Returns the parent if it exists, or null.\n     *\n     * @return a ViewParent or null if this ViewParent does not have a parent\n     ",
    "links" : [ ]
  }, {
    "name" : "public void requestChildFocus(View child, View focused)",
    "returnType" : "void",
    "comment" : "\n     * Called when a child of this parent wants focus\n     * \n     * @param child The child of this ViewParent that wants focus. This view\n     *        will contain the focused view. It is not necessarily the view that\n     *        actually has focus.\n     * @param focused The view that is a descendant of child that actually has\n     *        focus\n     ",
    "links" : [ ]
  }, {
    "name" : "public void recomputeViewAttributes(View child)",
    "returnType" : "void",
    "comment" : "\n     * Tell view hierarchy that the global view attributes need to be\n     * re-evaluated.\n     * \n     * @param child View whose attributes have changed.\n     ",
    "links" : [ ]
  }, {
    "name" : "public void clearChildFocus(View child)",
    "returnType" : "void",
    "comment" : "\n     * Called when a child of this parent is giving up focus\n     * \n     * @param child The view that is giving up focus\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean getChildVisibleRect(View child, Rect r, android.graphics.Point offset)",
    "returnType" : "boolean",
    "comment" : "\n     * Compute the visible part of a rectangular region defined in terms of a child view's\n     * coordinates.\n     *\n     * <p>Returns the clipped visible part of the rectangle <code>r</code>, defined in the\n     * <code>child</code>'s local coordinate system. <code>r</code> is modified by this method to\n     * contain the result, expressed in the global (root) coordinate system.</p>\n     *\n     * <p>The resulting rectangle is always axis aligned. If a rotation is applied to a node in the\n     * View hierarchy, the result is the axis-aligned bounding box of the visible rectangle.</p>\n     *\n     * @param child A child View, whose rectangular visible region we want to compute\n     * @param r The input rectangle, defined in the child coordinate system. Will be overwritten to\n     * contain the resulting visible rectangle, expressed in global (root) coordinates\n     * @param offset The input coordinates of a point, defined in the child coordinate system.\n     * As with the <code>r</code> parameter, this will be overwritten to contain the global (root)\n     * coordinates of that point.\n     * A <code>null</code> value is valid (in case you are not interested in this result)\n     * @return true if the resulting rectangle is not empty, false otherwise\n     ",
    "links" : [ ]
  }, {
    "name" : "public View focusSearch(View v, int direction)",
    "returnType" : "View",
    "comment" : "\n     * Find the nearest view in the specified direction that wants to take focus\n     * \n     * @param v The view that currently has focus\n     * @param direction One of FOCUS_UP, FOCUS_DOWN, FOCUS_LEFT, and FOCUS_RIGHT\n     ",
    "links" : [ ]
  }, {
    "name" : " View keyboardNavigationClusterSearch(View currentCluster, int direction)",
    "returnType" : "View",
    "comment" : "\n     * Find the nearest keyboard navigation cluster in the specified direction.\n     * This does not actually give focus to that cluster.\n     *\n     * @param currentCluster The starting point of the search. Null means the current cluster is not\n     *                       found yet\n     * @param direction Direction to look\n     *\n     * @return The nearest keyboard navigation cluster in the specified direction, or null if none\n     *         can be found\n     ",
    "links" : [ ]
  }, {
    "name" : "public void bringChildToFront(View child)",
    "returnType" : "void",
    "comment" : "\n     * Change the z order of the child so it's on top of all other children.\n     * This ordering change may affect layout, if this container\n     * uses an order-dependent layout scheme (e.g., LinearLayout). Prior\n     * to {@link android.os.Build.VERSION_CODES#KITKAT} this\n     * method should be followed by calls to {@link #requestLayout()} and\n     * {@link View#invalidate()} on this parent to force the parent to redraw\n     * with the new child ordering.\n     * \n     * @param child The child to bring to the top of the z order\n     ",
    "links" : [ "android.view.View#invalidate()", "android.os.Build.VERSION_CODES#KITKAT", "#requestLayout()" ]
  }, {
    "name" : "public void focusableViewAvailable(View v)",
    "returnType" : "void",
    "comment" : "\n     * Tells the parent that a new focusable view has become available. This is\n     * to handle transitions from the case where there are no focusable views to\n     * the case where the first focusable view appears.\n     * \n     * @param v The view that has become newly focusable\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean showContextMenuForChild(View originalView)",
    "returnType" : "boolean",
    "comment" : "\n     * Shows the context menu for the specified view or its ancestors.\n     * <p>\n     * In most cases, a subclass does not need to override this. However, if\n     * the subclass is added directly to the window manager (for example,\n     * {@link ViewManager#addView(View, android.view.ViewGroup.LayoutParams)})\n     * then it should override this and show the context menu.\n     *\n     * @param originalView the source view where the context menu was first\n     *                     invoked\n     * @return {@code true} if the context menu was shown, {@code false}\n     *         otherwise\n     * @see #showContextMenuForChild(View, float, float)\n     ",
    "links" : [ "android.view.ViewManager#addView(View" ]
  }, {
    "name" : " boolean showContextMenuForChild(View originalView, float x, float y)",
    "returnType" : "boolean",
    "comment" : "\n     * Shows the context menu for the specified view or its ancestors anchored\n     * to the specified view-relative coordinate.\n     * <p>\n     * In most cases, a subclass does not need to override this. However, if\n     * the subclass is added directly to the window manager (for example,\n     * {@link ViewManager#addView(View, android.view.ViewGroup.LayoutParams)})\n     * then it should override this and show the context menu.\n     * <p>\n     * If a subclass overrides this method it should also override\n     * {@link #showContextMenuForChild(View)}.\n     *\n     * @param originalView the source view where the context menu was first\n     *                     invoked\n     * @param x the X coordinate in pixels relative to the original view to\n     *          which the menu should be anchored, or {@link Float#NaN} to\n     *          disable anchoring\n     * @param y the Y coordinate in pixels relative to the original view to\n     *          which the menu should be anchored, or {@link Float#NaN} to\n     *          disable anchoring\n     * @return {@code true} if the context menu was shown, {@code false}\n     *         otherwise\n     ",
    "links" : [ "android.view.ViewManager#addView(View", "#NaN", "#showContextMenuForChild(View)" ]
  }, {
    "name" : "public void createContextMenu(ContextMenu menu)",
    "returnType" : "void",
    "comment" : "\n     * Have the parent populate the specified context menu if it has anything to\n     * add (and then recurse on its parent).\n     * \n     * @param menu The menu to populate\n     ",
    "links" : [ ]
  }, {
    "name" : "public ActionMode startActionModeForChild(View originalView, ActionMode.Callback callback)",
    "returnType" : "ActionMode",
    "comment" : "\n     * Start an action mode for the specified view with the default type\n     * {@link ActionMode#TYPE_PRIMARY}.\n     *\n     * <p>In most cases, a subclass does not need to override this. However, if the\n     * subclass is added directly to the window manager (for example,\n     * {@link ViewManager#addView(View, android.view.ViewGroup.LayoutParams)})\n     * then it should override this and start the action mode.</p>\n     *\n     * @param originalView The source view where the action mode was first invoked\n     * @param callback The callback that will handle lifecycle events for the action mode\n     * @return The new action mode if it was started, null otherwise\n     *\n     * @see #startActionModeForChild(View, android.view.ActionMode.Callback, int)\n     ",
    "links" : [ "android.view.ViewManager#addView(View", "android.view.ActionMode#TYPE_PRIMARY" ]
  }, {
    "name" : "public ActionMode startActionModeForChild(View originalView, ActionMode.Callback callback, int type)",
    "returnType" : "ActionMode",
    "comment" : "\n     * Start an action mode of a specific type for the specified view.\n     *\n     * <p>In most cases, a subclass does not need to override this. However, if the\n     * subclass is added directly to the window manager (for example,\n     * {@link ViewManager#addView(View, android.view.ViewGroup.LayoutParams)})\n     * then it should override this and start the action mode.</p>\n     *\n     * @param originalView The source view where the action mode was first invoked\n     * @param callback The callback that will handle lifecycle events for the action mode\n     * @param type One of {@link ActionMode#TYPE_PRIMARY} or {@link ActionMode#TYPE_FLOATING}.\n     * @return The new action mode if it was started, null otherwise\n     ",
    "links" : [ "android.view.ViewManager#addView(View", "android.view.ActionMode#TYPE_FLOATING", "android.view.ActionMode#TYPE_PRIMARY" ]
  }, {
    "name" : "public void childDrawableStateChanged(@NonNull View child)",
    "returnType" : "void",
    "comment" : "\n     * This method is called on the parent when a child's drawable state\n     * has changed.\n     *\n     * @param child The child whose drawable state has changed.\n     ",
    "links" : [ ]
  }, {
    "name" : "public void requestDisallowInterceptTouchEvent(boolean disallowIntercept)",
    "returnType" : "void",
    "comment" : "\n     * Called when a child does not want this parent and its ancestors to\n     * intercept touch events with\n     * {@link ViewGroup#onInterceptTouchEvent(MotionEvent)}.\n     *\n     * <p>This parent should pass this call onto its parents. This parent must obey\n     * this request for the duration of the touch (that is, only clear the flag\n     * after this parent has received an up or a cancel.</p>\n     * \n     * @param disallowIntercept True if the child does not want the parent to\n     *            intercept touch events.\n     ",
    "links" : [ "android.view.ViewGroup#onInterceptTouchEvent(MotionEvent)" ]
  }, {
    "name" : "public boolean requestChildRectangleOnScreen(@NonNull View child, Rect rectangle, boolean immediate)",
    "returnType" : "boolean",
    "comment" : "\n     * Called when a child of this group wants a particular rectangle to be\n     * positioned onto the screen.  {@link ViewGroup}s overriding this can trust\n     * that:\n     * <ul>\n     *   <li>child will be a direct child of this group</li>\n     *   <li>rectangle will be in the child's content coordinates</li>\n     * </ul>\n     *\n     * <p>{@link ViewGroup}s overriding this should uphold the contract:</p>\n     * <ul>\n     *   <li>nothing will change if the rectangle is already visible</li>\n     *   <li>the view port will be scrolled only just enough to make the\n     *       rectangle visible</li>\n     * <ul>\n     *\n     * @param child The direct child making the request.\n     * @param rectangle The rectangle in the child's coordinates the child\n     *        wishes to be on the screen.\n     * @param immediate True to forbid animated or delayed scrolling,\n     *        false otherwise\n     * @return Whether the group scrolled to handle the operation\n     ",
    "links" : [ "android.view.ViewGroup" ]
  }, {
    "name" : "public boolean requestSendAccessibilityEvent(@NonNull View child, AccessibilityEvent event)",
    "returnType" : "boolean",
    "comment" : "\n     * Called by a child to request from its parent to send an {@link AccessibilityEvent}.\n     * The child has already populated a record for itself in the event and is delegating\n     * to its parent to send the event. The parent can optionally add a record for itself.\n     * <p>\n     * Note: An accessibility event is fired by an individual view which populates the\n     *       event with a record for its state and requests from its parent to perform\n     *       the sending. The parent can optionally add a record for itself before\n     *       dispatching the request to its parent. A parent can also choose not to\n     *       respect the request for sending the event. The accessibility event is sent\n     *       by the topmost view in the view tree.</p>\n     *\n     * @param child The child which requests sending the event.\n     * @param event The event to be sent.\n     * @return True if the event was sent.\n     ",
    "links" : [ "android.view.accessibility.AccessibilityEvent" ]
  }, {
    "name" : "public void childHasTransientStateChanged(@NonNull View child, boolean hasTransientState)",
    "returnType" : "void",
    "comment" : "\n     * Called when a child view now has or no longer is tracking transient state.\n     *\n     * <p>\"Transient state\" is any state that a View might hold that is not expected to\n     * be reflected in the data model that the View currently presents. This state only\n     * affects the presentation to the user within the View itself, such as the current\n     * state of animations in progress or the state of a text selection operation.</p>\n     *\n     * <p>Transient state is useful for hinting to other components of the View system\n     * that a particular view is tracking something complex but encapsulated.\n     * A <code>ListView</code> for example may acknowledge that list item Views\n     * with transient state should be preserved within their position or stable item ID\n     * instead of treating that view as trivially replaceable by the backing adapter.\n     * This allows adapter implementations to be simpler instead of needing to track\n     * the state of item view animations in progress such that they could be restored\n     * in the event of an unexpected recycling and rebinding of attached item views.</p>\n     *\n     * <p>This method is called on a parent view when a child view or a view within\n     * its subtree begins or ends tracking of internal transient state.</p>\n     *\n     * @param child Child view whose state has changed\n     * @param hasTransientState true if this child has transient state\n     ",
    "links" : [ ]
  }, {
    "name" : "public void requestFitSystemWindows()",
    "returnType" : "void",
    "comment" : "\n     * Ask that a new dispatch of {@link View#fitSystemWindows(Rect)\n     * View.fitSystemWindows(Rect)} be performed.\n     ",
    "links" : [ "android.view.View#fitSystemWindows(Rect)" ]
  }, {
    "name" : "public ViewParent getParentForAccessibility()",
    "returnType" : "ViewParent",
    "comment" : "\n     * Gets the parent of a given View for accessibility. Since some Views are not\n     * exposed to the accessibility layer the parent for accessibility is not\n     * necessarily the direct parent of the View, rather it is a predecessor.\n     *\n     * @return The parent or <code>null</code> if no such is found.\n     ",
    "links" : [ ]
  }, {
    "name" : "public void notifySubtreeAccessibilityStateChanged(@NonNull View child, @NonNull View source, int changeType)",
    "returnType" : "void",
    "comment" : "\n     * Notifies a view parent that the accessibility state of one of its\n     * descendants has changed and that the structure of the subtree is\n     * different.\n     * @param child The direct child whose subtree has changed.\n     * @param source The descendant view that changed. May not be {@code null}.\n     * @param changeType A bit mask of the types of changes that occurred. One\n     *            or more of:\n     *            <ul>\n     *            <li>{@link AccessibilityEvent#CONTENT_CHANGE_TYPE_CONTENT_DESCRIPTION}\n     *            <li>{@link AccessibilityEvent#CONTENT_CHANGE_TYPE_STATE_DESCRIPTION}\n     *            <li>{@link AccessibilityEvent#CONTENT_CHANGE_TYPE_SUBTREE}\n     *            <li>{@link AccessibilityEvent#CONTENT_CHANGE_TYPE_TEXT}\n     *            <li>{@link AccessibilityEvent#CONTENT_CHANGE_TYPE_UNDEFINED}\n     *            <li>{@link AccessibilityEvent#CONTENT_CHANGE_TYPE_DRAG_STARTED}\n     *            <li>{@link AccessibilityEvent#CONTENT_CHANGE_TYPE_DRAG_CANCELLED}\n     *            <li>{@link AccessibilityEvent#CONTENT_CHANGE_TYPE_DRAG_DROPPED}\n     *            </ul>\n     ",
    "links" : [ "android.view.accessibility.AccessibilityEvent#CONTENT_CHANGE_TYPE_SUBTREE", "android.view.accessibility.AccessibilityEvent#CONTENT_CHANGE_TYPE_DRAG_STARTED", "android.view.accessibility.AccessibilityEvent#CONTENT_CHANGE_TYPE_DRAG_DROPPED", "android.view.accessibility.AccessibilityEvent#CONTENT_CHANGE_TYPE_STATE_DESCRIPTION", "android.view.accessibility.AccessibilityEvent#CONTENT_CHANGE_TYPE_CONTENT_DESCRIPTION", "android.view.accessibility.AccessibilityEvent#CONTENT_CHANGE_TYPE_TEXT", "android.view.accessibility.AccessibilityEvent#CONTENT_CHANGE_TYPE_UNDEFINED", "android.view.accessibility.AccessibilityEvent#CONTENT_CHANGE_TYPE_DRAG_CANCELLED" ]
  }, {
    "name" : "public boolean canResolveLayoutDirection()",
    "returnType" : "boolean",
    "comment" : "\n     * Tells if this view parent can resolve the layout direction.\n     * See {@link View#setLayoutDirection(int)}\n     *\n     * @return True if this view parent can resolve the layout direction.\n     ",
    "links" : [ "android.view.View#setLayoutDirection(int)" ]
  }, {
    "name" : "public boolean isLayoutDirectionResolved()",
    "returnType" : "boolean",
    "comment" : "\n     * Tells if this view parent layout direction is resolved.\n     * See {@link View#setLayoutDirection(int)}\n     *\n     * @return True if this view parent layout direction is resolved.\n     ",
    "links" : [ "android.view.View#setLayoutDirection(int)" ]
  }, {
    "name" : "public int getLayoutDirection()",
    "returnType" : "int",
    "comment" : "\n     * Return this view parent layout direction. See {@link View#getLayoutDirection()}\n     *\n     * @return {@link View#LAYOUT_DIRECTION_RTL} if the layout direction is RTL or returns\n     * {@link View#LAYOUT_DIRECTION_LTR} if the layout direction is not RTL.\n     ",
    "links" : [ "android.view.View#LAYOUT_DIRECTION_RTL", "android.view.View#LAYOUT_DIRECTION_LTR", "android.view.View#getLayoutDirection()" ]
  }, {
    "name" : "public boolean canResolveTextDirection()",
    "returnType" : "boolean",
    "comment" : "\n     * Tells if this view parent can resolve the text direction.\n     * See {@link View#setTextDirection(int)}\n     *\n     * @return True if this view parent can resolve the text direction.\n     ",
    "links" : [ "android.view.View#setTextDirection(int)" ]
  }, {
    "name" : "public boolean isTextDirectionResolved()",
    "returnType" : "boolean",
    "comment" : "\n     * Tells if this view parent text direction is resolved.\n     * See {@link View#setTextDirection(int)}\n     *\n     * @return True if this view parent text direction is resolved.\n     ",
    "links" : [ "android.view.View#setTextDirection(int)" ]
  }, {
    "name" : "public int getTextDirection()",
    "returnType" : "int",
    "comment" : "\n     * Return this view parent text direction. See {@link View#getTextDirection()}\n     *\n     * @return the resolved text direction. Returns one of:\n     *\n     * {@link View#TEXT_DIRECTION_FIRST_STRONG}\n     * {@link View#TEXT_DIRECTION_ANY_RTL},\n     * {@link View#TEXT_DIRECTION_LTR},\n     * {@link View#TEXT_DIRECTION_RTL},\n     * {@link View#TEXT_DIRECTION_LOCALE}\n     ",
    "links" : [ "android.view.View#TEXT_DIRECTION_ANY_RTL", "android.view.View#TEXT_DIRECTION_LTR", "android.view.View#TEXT_DIRECTION_RTL", "android.view.View#TEXT_DIRECTION_LOCALE", "android.view.View#getTextDirection()", "android.view.View#TEXT_DIRECTION_FIRST_STRONG" ]
  }, {
    "name" : "public boolean canResolveTextAlignment()",
    "returnType" : "boolean",
    "comment" : "\n     * Tells if this view parent can resolve the text alignment.\n     * See {@link View#setTextAlignment(int)}\n     *\n     * @return True if this view parent can resolve the text alignment.\n     ",
    "links" : [ "android.view.View#setTextAlignment(int)" ]
  }, {
    "name" : "public boolean isTextAlignmentResolved()",
    "returnType" : "boolean",
    "comment" : "\n     * Tells if this view parent text alignment is resolved.\n     * See {@link View#setTextAlignment(int)}\n     *\n     * @return True if this view parent text alignment is resolved.\n     ",
    "links" : [ "android.view.View#setTextAlignment(int)" ]
  }, {
    "name" : "public int getTextAlignment()",
    "returnType" : "int",
    "comment" : "\n     * Return this view parent text alignment. See {@link android.view.View#getTextAlignment()}\n     *\n     * @return the resolved text alignment. Returns one of:\n     *\n     * {@link View#TEXT_ALIGNMENT_GRAVITY},\n     * {@link View#TEXT_ALIGNMENT_CENTER},\n     * {@link View#TEXT_ALIGNMENT_TEXT_START},\n     * {@link View#TEXT_ALIGNMENT_TEXT_END},\n     * {@link View#TEXT_ALIGNMENT_VIEW_START},\n     * {@link View#TEXT_ALIGNMENT_VIEW_END}\n     ",
    "links" : [ "android.view.View#TEXT_ALIGNMENT_TEXT_END", "android.view.View#TEXT_ALIGNMENT_CENTER", "android.view.View#TEXT_ALIGNMENT_VIEW_START", "android.view.View#TEXT_ALIGNMENT_VIEW_END", "android.view.View#TEXT_ALIGNMENT_TEXT_START", "android.view.View#getTextAlignment()", "android.view.View#TEXT_ALIGNMENT_GRAVITY" ]
  }, {
    "name" : "public boolean onStartNestedScroll(@NonNull View child, @NonNull View target, int nestedScrollAxes)",
    "returnType" : "boolean",
    "comment" : "\n     * React to a descendant view initiating a nestable scroll operation, claiming the\n     * nested scroll operation if appropriate.\n     *\n     * <p>This method will be called in response to a descendant view invoking\n     * {@link View#startNestedScroll(int)}. Each parent up the view hierarchy will be\n     * given an opportunity to respond and claim the nested scrolling operation by returning\n     * <code>true</code>.</p>\n     *\n     * <p>This method may be overridden by ViewParent implementations to indicate when the view\n     * is willing to support a nested scrolling operation that is about to begin. If it returns\n     * true, this ViewParent will become the target view's nested scrolling parent for the duration\n     * of the scroll operation in progress. When the nested scroll is finished this ViewParent\n     * will receive a call to {@link #onStopNestedScroll(View)}.\n     * </p>\n     *\n     * @param child Direct child of this ViewParent containing target\n     * @param target View that initiated the nested scroll\n     * @param nestedScrollAxes Flags consisting of {@link View#SCROLL_AXIS_HORIZONTAL},\n     *                         {@link View#SCROLL_AXIS_VERTICAL} or both\n     * @return true if this ViewParent accepts the nested scroll operation\n     ",
    "links" : [ "android.view.View#startNestedScroll(int)", "android.view.View#SCROLL_AXIS_HORIZONTAL", "android.view.View#SCROLL_AXIS_VERTICAL", "#onStopNestedScroll(View)" ]
  }, {
    "name" : "public void onNestedScrollAccepted(@NonNull View child, @NonNull View target, int nestedScrollAxes)",
    "returnType" : "void",
    "comment" : "\n     * React to the successful claiming of a nested scroll operation.\n     *\n     * <p>This method will be called after\n     * {@link #onStartNestedScroll(View, View, int) onStartNestedScroll} returns true. It offers\n     * an opportunity for the view and its superclasses to perform initial configuration\n     * for the nested scroll. Implementations of this method should always call their superclass's\n     * implementation of this method if one is present.</p>\n     *\n     * @param child Direct child of this ViewParent containing target\n     * @param target View that initiated the nested scroll\n     * @param nestedScrollAxes Flags consisting of {@link View#SCROLL_AXIS_HORIZONTAL},\n     *                         {@link View#SCROLL_AXIS_VERTICAL} or both\n     * @see #onStartNestedScroll(View, View, int)\n     * @see #onStopNestedScroll(View)\n     ",
    "links" : [ "android.view.View#SCROLL_AXIS_HORIZONTAL", "#onStartNestedScroll(View", "android.view.View#SCROLL_AXIS_VERTICAL" ]
  }, {
    "name" : "public void onStopNestedScroll(@NonNull View target)",
    "returnType" : "void",
    "comment" : "\n     * React to a nested scroll operation ending.\n     *\n     * <p>Perform cleanup after a nested scrolling operation.\n     * This method will be called when a nested scroll stops, for example when a nested touch\n     * scroll ends with a {@link MotionEvent#ACTION_UP} or {@link MotionEvent#ACTION_CANCEL} event.\n     * Implementations of this method should always call their superclass's implementation of this\n     * method if one is present.</p>\n     *\n     * @param target View that initiated the nested scroll\n     ",
    "links" : [ "android.view.MotionEvent#ACTION_UP", "android.view.MotionEvent#ACTION_CANCEL" ]
  }, {
    "name" : "public void onNestedScroll(@NonNull View target, int dxConsumed, int dyConsumed, int dxUnconsumed, int dyUnconsumed)",
    "returnType" : "void",
    "comment" : "\n     * React to a nested scroll in progress.\n     *\n     * <p>This method will be called when the ViewParent's current nested scrolling child view\n     * dispatches a nested scroll event. To receive calls to this method the ViewParent must have\n     * previously returned <code>true</code> for a call to\n     * {@link #onStartNestedScroll(View, View, int)}.</p>\n     *\n     * <p>Both the consumed and unconsumed portions of the scroll distance are reported to the\n     * ViewParent. An implementation may choose to use the consumed portion to match or chase scroll\n     * position of multiple child elements, for example. The unconsumed portion may be used to\n     * allow continuous dragging of multiple scrolling or draggable elements, such as scrolling\n     * a list within a vertical drawer where the drawer begins dragging once the edge of inner\n     * scrolling content is reached.</p>\n     *\n     * @param target The descendent view controlling the nested scroll\n     * @param dxConsumed Horizontal scroll distance in pixels already consumed by target\n     * @param dyConsumed Vertical scroll distance in pixels already consumed by target\n     * @param dxUnconsumed Horizontal scroll distance in pixels not consumed by target\n     * @param dyUnconsumed Vertical scroll distance in pixels not consumed by target\n     ",
    "links" : [ "#onStartNestedScroll(View" ]
  }, {
    "name" : "public void onNestedPreScroll(@NonNull View target, int dx, int dy, @NonNull int[] consumed)",
    "returnType" : "void",
    "comment" : "\n     * React to a nested scroll in progress before the target view consumes a portion of the scroll.\n     *\n     * <p>When working with nested scrolling often the parent view may want an opportunity\n     * to consume the scroll before the nested scrolling child does. An example of this is a\n     * drawer that contains a scrollable list. The user will want to be able to scroll the list\n     * fully into view before the list itself begins scrolling.</p>\n     *\n     * <p><code>onNestedPreScroll</code> is called when a nested scrolling child invokes\n     * {@link View#dispatchNestedPreScroll(int, int, int[], int[])}. The implementation should\n     * report how any pixels of the scroll reported by dx, dy were consumed in the\n     * <code>consumed</code> array. Index 0 corresponds to dx and index 1 corresponds to dy.\n     * This parameter will never be null. Initial values for consumed[0] and consumed[1]\n     * will always be 0.</p>\n     *\n     * @param target View that initiated the nested scroll\n     * @param dx Horizontal scroll distance in pixels\n     * @param dy Vertical scroll distance in pixels\n     * @param consumed Output. The horizontal and vertical scroll distance consumed by this parent\n     ",
    "links" : [ "android.view.View#dispatchNestedPreScroll(int" ]
  }, {
    "name" : "public boolean onNestedFling(@NonNull View target, float velocityX, float velocityY, boolean consumed)",
    "returnType" : "boolean",
    "comment" : "\n     * Request a fling from a nested scroll.\n     *\n     * <p>This method signifies that a nested scrolling child has detected suitable conditions\n     * for a fling. Generally this means that a touch scroll has ended with a\n     * {@link VelocityTracker velocity} in the direction of scrolling that meets or exceeds\n     * the {@link ViewConfiguration#getScaledMinimumFlingVelocity() minimum fling velocity}\n     * along a scrollable axis.</p>\n     *\n     * <p>If a nested scrolling child view would normally fling but it is at the edge of\n     * its own content, it can use this method to delegate the fling to its nested scrolling\n     * parent instead. The parent may optionally consume the fling or observe a child fling.</p>\n     *\n     * @param target View that initiated the nested scroll\n     * @param velocityX Horizontal velocity in pixels per second\n     * @param velocityY Vertical velocity in pixels per second\n     * @param consumed true if the child consumed the fling, false otherwise\n     * @return true if this parent consumed or otherwise reacted to the fling\n     ",
    "links" : [ "android.view.ViewConfiguration#getScaledMinimumFlingVelocity()", "android.view.VelocityTracker" ]
  }, {
    "name" : "public boolean onNestedPreFling(@NonNull View target, float velocityX, float velocityY)",
    "returnType" : "boolean",
    "comment" : "\n     * React to a nested fling before the target view consumes it.\n     *\n     * <p>This method siginfies that a nested scrolling child has detected a fling with the given\n     * velocity along each axis. Generally this means that a touch scroll has ended with a\n     * {@link VelocityTracker velocity} in the direction of scrolling that meets or exceeds\n     * the {@link ViewConfiguration#getScaledMinimumFlingVelocity() minimum fling velocity}\n     * along a scrollable axis.</p>\n     *\n     * <p>If a nested scrolling parent is consuming motion as part of a\n     * {@link #onNestedPreScroll(View, int, int, int[]) pre-scroll}, it may be appropriate for\n     * it to also consume the pre-fling to complete that same motion. By returning\n     * <code>true</code> from this method, the parent indicates that the child should not\n     * fling its own internal content as well.</p>\n     *\n     * @param target View that initiated the nested scroll\n     * @param velocityX Horizontal velocity in pixels per second\n     * @param velocityY Vertical velocity in pixels per second\n     * @return true if this parent consumed the fling ahead of the target view\n     ",
    "links" : [ "android.view.ViewConfiguration#getScaledMinimumFlingVelocity()", "android.view.VelocityTracker", "#onNestedPreScroll(View" ]
  }, {
    "name" : "public boolean onNestedPrePerformAccessibilityAction(@NonNull View target, int action, @Nullable Bundle arguments)",
    "returnType" : "boolean",
    "comment" : "\n     * React to an accessibility action delegated by a target descendant view before the target\n     * processes it.\n     *\n     * <p>This method may be called by a target descendant view if the target wishes to give\n     * a view in its parent chain a chance to react to the event before normal processing occurs.\n     * Most commonly this will be a scroll event such as\n     * {@link android.view.accessibility.AccessibilityNodeInfo#ACTION_SCROLL_FORWARD}.\n     * A ViewParent that supports acting as a nested scrolling parent should override this\n     * method and act accordingly to implement scrolling via accesibility systems.</p>\n     *\n     * @param target The target view dispatching this action\n     * @param action Action being performed; see\n     *               {@link android.view.accessibility.AccessibilityNodeInfo}\n     * @param arguments Optional action arguments\n     * @return true if the action was consumed by this ViewParent\n     ",
    "links" : [ "android.view.accessibility.AccessibilityNodeInfo", "android.view.accessibility.AccessibilityNodeInfo#ACTION_SCROLL_FORWARD" ]
  }, {
    "name" : " void subtractObscuredTouchableRegion(Region touchableRegion, View view)",
    "returnType" : "void",
    "comment" : "\n     * Given a touchable region of a child, this method reduces region by the bounds of all views on\n     * top of the child for which {@link View#canReceivePointerEvents} returns {@code true}. This\n     * applies recursively for all views in the view hierarchy on top of this one.\n     *\n     * @param touchableRegion The touchable region we want to modify.\n     * @param view A child view of this ViewGroup which indicates the z-order of the touchable\n     *             region.\n     * @hide\n     ",
    "links" : [ "android.view.View#canReceivePointerEvents" ]
  }, {
    "name" : " boolean getChildLocalHitRegion(@NonNull View child, @NonNull Region region, @NonNull Matrix matrix, boolean isHover)",
    "returnType" : "boolean",
    "comment" : "\n     * Compute the region where the child can receive the {@link MotionEvent}s from the root view.\n     *\n     * <p> Given region where the child will accept {@link MotionEvent}s.\n     * Modify the region to the unblocked region where the child can receive the\n     * {@link MotionEvent}s from the view root.\n     * </p>\n     *\n     * <p> The given region is always clipped by the bounds of the parent views. When there are\n     * on-going {@link MotionEvent}s, this method also makes use of the event dispatching results to\n     * determine whether a sibling view will also block the child's hit region.\n     * </p>\n     *\n     * @param child a child View, whose hit region we want to compute.\n     * @param region the initial hit region where the child view will handle {@link MotionEvent}s,\n     *              defined in the child coordinates. Will be overwritten to the result hit region.\n     * @param matrix the matrix that maps the given child view's coordinates to the region\n     *               coordinates. It will be modified to a matrix that maps window coordinates to\n     *               the result region's coordinates.\n     * @param isHover if true it will return the hover events' hit region, otherwise it will\n     *               return the touch events' hit region.\n     * @return true if the returned region is not empty.\n     * @hide\n     ",
    "links" : [ "android.view.MotionEvent" ]
  }, {
    "name" : " void onDescendantUnbufferedRequested()",
    "returnType" : "void",
    "comment" : "\n     * Unbuffered dispatch has been requested by a child of this view parent.\n     * This method is called by the View hierarchy to signal ancestors that a View needs to\n     * request unbuffered dispatch.\n     *\n     * @see View#requestUnbufferedDispatch(int)\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : " OnBackInvokedDispatcher findOnBackInvokedDispatcherForChild(@NonNull View child, @NonNull View requester)",
    "returnType" : "OnBackInvokedDispatcher",
    "comment" : "\n     * Walk up the View hierarchy to find the nearest {@link OnBackInvokedDispatcher}.\n     *\n     * @return The {@link OnBackInvokedDispatcher} from this or the nearest\n     * ancestor, or null if the view is both not attached and have no ancestor providing an\n     * {@link OnBackInvokedDispatcher}.\n     *\n     * @param child The direct child of this view for which to find a dispatcher.\n     * @param requester The requester that will use the dispatcher. Can be the same as child.\n     ",
    "links" : [ "android.window.OnBackInvokedDispatcher" ]
  } ],
  "methodNames" : [ "public void requestLayout()", "public boolean isLayoutRequested()", "public void requestTransparentRegion(View child)", " void onDescendantInvalidated(@NonNull View child, @NonNull View target)", "public void invalidateChild(View child, Rect r)", "public ViewParent invalidateChildInParent(int[] location, Rect r)", "public ViewParent getParent()", "public void requestChildFocus(View child, View focused)", "public void recomputeViewAttributes(View child)", "public void clearChildFocus(View child)", "public boolean getChildVisibleRect(View child, Rect r, android.graphics.Point offset)", "public View focusSearch(View v, int direction)", " View keyboardNavigationClusterSearch(View currentCluster, int direction)", "public void bringChildToFront(View child)", "public void focusableViewAvailable(View v)", "public boolean showContextMenuForChild(View originalView)", " boolean showContextMenuForChild(View originalView, float x, float y)", "public void createContextMenu(ContextMenu menu)", "public ActionMode startActionModeForChild(View originalView, ActionMode.Callback callback)", "public ActionMode startActionModeForChild(View originalView, ActionMode.Callback callback, int type)", "public void childDrawableStateChanged(@NonNull View child)", "public void requestDisallowInterceptTouchEvent(boolean disallowIntercept)", "public boolean requestChildRectangleOnScreen(@NonNull View child, Rect rectangle, boolean immediate)", "public boolean requestSendAccessibilityEvent(@NonNull View child, AccessibilityEvent event)", "public void childHasTransientStateChanged(@NonNull View child, boolean hasTransientState)", "public void requestFitSystemWindows()", "public ViewParent getParentForAccessibility()", "public void notifySubtreeAccessibilityStateChanged(@NonNull View child, @NonNull View source, int changeType)", "public boolean canResolveLayoutDirection()", "public boolean isLayoutDirectionResolved()", "public int getLayoutDirection()", "public boolean canResolveTextDirection()", "public boolean isTextDirectionResolved()", "public int getTextDirection()", "public boolean canResolveTextAlignment()", "public boolean isTextAlignmentResolved()", "public int getTextAlignment()", "public boolean onStartNestedScroll(@NonNull View child, @NonNull View target, int nestedScrollAxes)", "public void onNestedScrollAccepted(@NonNull View child, @NonNull View target, int nestedScrollAxes)", "public void onStopNestedScroll(@NonNull View target)", "public void onNestedScroll(@NonNull View target, int dxConsumed, int dyConsumed, int dxUnconsumed, int dyUnconsumed)", "public void onNestedPreScroll(@NonNull View target, int dx, int dy, @NonNull int[] consumed)", "public boolean onNestedFling(@NonNull View target, float velocityX, float velocityY, boolean consumed)", "public boolean onNestedPreFling(@NonNull View target, float velocityX, float velocityY)", "public boolean onNestedPrePerformAccessibilityAction(@NonNull View target, int action, @Nullable Bundle arguments)", " void subtractObscuredTouchableRegion(Region touchableRegion, View view)", " boolean getChildLocalHitRegion(@NonNull View child, @NonNull Region region, @NonNull Matrix matrix, boolean isHover)", " void onDescendantUnbufferedRequested()", " OnBackInvokedDispatcher findOnBackInvokedDispatcherForChild(@NonNull View child, @NonNull View requester)" ],
  "variableNames" : [ ]
}