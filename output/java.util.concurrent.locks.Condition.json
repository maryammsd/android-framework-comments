{
  "filePath" : "/home/maryam/clearblue/files/android-source-35/java/util/concurrent/locks/Condition.java",
  "packageName" : "java.util.concurrent.locks",
  "className" : "Condition",
  "comment" : "\n * {@code Condition} factors out the {@code Object} monitor\n * methods ({@link Object#wait() wait}, {@link Object#notify notify}\n * and {@link Object#notifyAll notifyAll}) into distinct objects to\n * give the effect of having multiple wait-sets per object, by\n * combining them with the use of arbitrary {@link Lock} implementations.\n * Where a {@code Lock} replaces the use of {@code synchronized} methods\n * and statements, a {@code Condition} replaces the use of the Object\n * monitor methods.\n *\n * <p>Conditions (also known as <em>condition queues</em> or\n * <em>condition variables</em>) provide a means for one thread to\n * suspend execution (to &quot;wait&quot;) until notified by another\n * thread that some state condition may now be true.  Because access\n * to this shared state information occurs in different threads, it\n * must be protected, so a lock of some form is associated with the\n * condition. The key property that waiting for a condition provides\n * is that it <em>atomically</em> releases the associated lock and\n * suspends the current thread, just like {@code Object.wait}.\n *\n * <p>A {@code Condition} instance is intrinsically bound to a lock.\n * To obtain a {@code Condition} instance for a particular {@link Lock}\n * instance use its {@link Lock#newCondition newCondition()} method.\n *\n * <p>As an example, suppose we have a bounded buffer which supports\n * {@code put} and {@code take} methods.  If a\n * {@code take} is attempted on an empty buffer, then the thread will block\n * until an item becomes available; if a {@code put} is attempted on a\n * full buffer, then the thread will block until a space becomes available.\n * We would like to keep waiting {@code put} threads and {@code take}\n * threads in separate wait-sets so that we can use the optimization of\n * only notifying a single thread at a time when items or spaces become\n * available in the buffer. This can be achieved using two\n * {@link Condition} instances.\n * <pre>\n * class BoundedBuffer&lt;E&gt; {\n *   <b>final Lock lock = new ReentrantLock();</b>\n *   final Condition notFull  = <b>lock.newCondition(); </b>\n *   final Condition notEmpty = <b>lock.newCondition(); </b>\n *\n *   final Object[] items = new Object[100];\n *   int putptr, takeptr, count;\n *\n *   public void put(E x) throws InterruptedException {\n *     <b>lock.lock();\n *     try {</b>\n *       while (count == items.length)\n *         <b>notFull.await();</b>\n *       items[putptr] = x;\n *       if (++putptr == items.length) putptr = 0;\n *       ++count;\n *       <b>notEmpty.signal();</b>\n *     <b>} finally {\n *       lock.unlock();\n *     }</b>\n *   }\n *\n *   public E take() throws InterruptedException {\n *     <b>lock.lock();\n *     try {</b>\n *       while (count == 0)\n *         <b>notEmpty.await();</b>\n *       E x = (E) items[takeptr];\n *       if (++takeptr == items.length) takeptr = 0;\n *       --count;\n *       <b>notFull.signal();</b>\n *       return x;\n *     <b>} finally {\n *       lock.unlock();\n *     }</b>\n *   }\n * }\n * </pre>\n *\n * (The {@link java.util.concurrent.ArrayBlockingQueue} class provides\n * this functionality, so there is no reason to implement this\n * sample usage class.)\n *\n * <p>A {@code Condition} implementation can provide behavior and semantics\n * that is\n * different from that of the {@code Object} monitor methods, such as\n * guaranteed ordering for notifications, or not requiring a lock to be held\n * when performing notifications.\n * If an implementation provides such specialized semantics then the\n * implementation must document those semantics.\n *\n * <p>Note that {@code Condition} instances are just normal objects and can\n * themselves be used as the target in a {@code synchronized} statement,\n * and can have their own monitor {@link Object#wait wait} and\n * {@link Object#notify notify} methods invoked.\n * Acquiring the monitor lock of a {@code Condition} instance, or using its\n * monitor methods, has no specified relationship with acquiring the\n * {@link Lock} associated with that {@code Condition} or the use of its\n * {@linkplain #await waiting} and {@linkplain #signal signalling} methods.\n * It is recommended that to avoid confusion you never use {@code Condition}\n * instances in this way, except perhaps within their own implementation.\n *\n * <p>Except where noted, passing a {@code null} value for any parameter\n * will result in a {@link NullPointerException} being thrown.\n *\n * <h2>Implementation Considerations</h2>\n *\n * <p>When waiting upon a {@code Condition}, a &quot;<em>spurious\n * wakeup</em>&quot; is permitted to occur, in\n * general, as a concession to the underlying platform semantics.\n * This has little practical impact on most application programs as a\n * {@code Condition} should always be waited upon in a loop, testing\n * the state predicate that is being waited for.  An implementation is\n * free to remove the possibility of spurious wakeups but it is\n * recommended that applications programmers always assume that they can\n * occur and so always wait in a loop.\n *\n * <p>The three forms of condition waiting\n * (interruptible, non-interruptible, and timed) may differ in their ease of\n * implementation on some platforms and in their performance characteristics.\n * In particular, it may be difficult to provide these features and maintain\n * specific semantics such as ordering guarantees.\n * Further, the ability to interrupt the actual suspension of the thread may\n * not always be feasible to implement on all platforms.\n *\n * <p>Consequently, an implementation is not required to define exactly the\n * same guarantees or semantics for all three forms of waiting, nor is it\n * required to support interruption of the actual suspension of the thread.\n *\n * <p>An implementation is required to\n * clearly document the semantics and guarantees provided by each of the\n * waiting methods, and when an implementation does support interruption of\n * thread suspension then it must obey the interruption semantics as defined\n * in this interface.\n *\n * <p>As interruption generally implies cancellation, and checks for\n * interruption are often infrequent, an implementation can favor responding\n * to an interrupt over normal method return. This is true even if it can be\n * shown that the interrupt occurred after another action that may have\n * unblocked the thread. An implementation should document this behavior.\n *\n * @since 1.5\n * @author Doug Lea\n ",
  "links" : [ "java.util.concurrent.ArrayBlockingQueue", "java.util.concurrent.locks.Lock", "java.util.concurrent.locks.Condition", "NullPointerException", "java.util.concurrent.locks.Lock#newCondition", "#wait()", "#notifyAll", "#wait", "#notify" ],
  "variables" : [ ],
  "methods" : [ {
    "name" : " void await() throws InterruptedException",
    "returnType" : "void",
    "comment" : "\n     * Causes the current thread to wait until it is signalled or\n     * {@linkplain Thread#interrupt interrupted}.\n     *\n     * <p>The lock associated with this {@code Condition} is atomically\n     * released and the current thread becomes disabled for thread scheduling\n     * purposes and lies dormant until <em>one</em> of four things happens:\n     * <ul>\n     * <li>Some other thread invokes the {@link #signal} method for this\n     * {@code Condition} and the current thread happens to be chosen as the\n     * thread to be awakened; or\n     * <li>Some other thread invokes the {@link #signalAll} method for this\n     * {@code Condition}; or\n     * <li>Some other thread {@linkplain Thread#interrupt interrupts} the\n     * current thread, and interruption of thread suspension is supported; or\n     * <li>A &quot;<em>spurious wakeup</em>&quot; occurs.\n     * </ul>\n     *\n     * <p>In all cases, before this method can return the current thread must\n     * re-acquire the lock associated with this condition. When the\n     * thread returns it is <em>guaranteed</em> to hold this lock.\n     *\n     * <p>If the current thread:\n     * <ul>\n     * <li>has its interrupted status set on entry to this method; or\n     * <li>is {@linkplain Thread#interrupt interrupted} while waiting\n     * and interruption of thread suspension is supported,\n     * </ul>\n     * then {@link InterruptedException} is thrown and the current thread's\n     * interrupted status is cleared. It is not specified, in the first\n     * case, whether or not the test for interruption occurs before the lock\n     * is released.\n     *\n     * <p><b>Implementation Considerations</b>\n     *\n     * <p>The current thread is assumed to hold the lock associated with this\n     * {@code Condition} when this method is called.\n     * It is up to the implementation to determine if this is\n     * the case and if not, how to respond. Typically, an exception will be\n     * thrown (such as {@link IllegalMonitorStateException}) and the\n     * implementation must document that fact.\n     *\n     * <p>An implementation can favor responding to an interrupt over normal\n     * method return in response to a signal. In that case the implementation\n     * must ensure that the signal is redirected to another waiting thread, if\n     * there is one.\n     *\n     * @throws InterruptedException if the current thread is interrupted\n     *         (and interruption of thread suspension is supported)\n     ",
    "links" : [ "#signal", "#signalAll", "InterruptedException", "IllegalMonitorStateException" ]
  }, {
    "name" : " void awaitUninterruptibly()",
    "returnType" : "void",
    "comment" : "\n     * Causes the current thread to wait until it is signalled.\n     *\n     * <p>The lock associated with this condition is atomically\n     * released and the current thread becomes disabled for thread scheduling\n     * purposes and lies dormant until <em>one</em> of three things happens:\n     * <ul>\n     * <li>Some other thread invokes the {@link #signal} method for this\n     * {@code Condition} and the current thread happens to be chosen as the\n     * thread to be awakened; or\n     * <li>Some other thread invokes the {@link #signalAll} method for this\n     * {@code Condition}; or\n     * <li>A &quot;<em>spurious wakeup</em>&quot; occurs.\n     * </ul>\n     *\n     * <p>In all cases, before this method can return the current thread must\n     * re-acquire the lock associated with this condition. When the\n     * thread returns it is <em>guaranteed</em> to hold this lock.\n     *\n     * <p>If the current thread's interrupted status is set when it enters\n     * this method, or it is {@linkplain Thread#interrupt interrupted}\n     * while waiting, it will continue to wait until signalled. When it finally\n     * returns from this method its interrupted status will still\n     * be set.\n     *\n     * <p><b>Implementation Considerations</b>\n     *\n     * <p>The current thread is assumed to hold the lock associated with this\n     * {@code Condition} when this method is called.\n     * It is up to the implementation to determine if this is\n     * the case and if not, how to respond. Typically, an exception will be\n     * thrown (such as {@link IllegalMonitorStateException}) and the\n     * implementation must document that fact.\n     ",
    "links" : [ "#signal", "#signalAll", "IllegalMonitorStateException" ]
  }, {
    "name" : " long awaitNanos(long nanosTimeout) throws InterruptedException",
    "returnType" : "long",
    "comment" : "\n     * Causes the current thread to wait until it is signalled or interrupted,\n     * or the specified waiting time elapses.\n     *\n     * <p>The lock associated with this condition is atomically\n     * released and the current thread becomes disabled for thread scheduling\n     * purposes and lies dormant until <em>one</em> of five things happens:\n     * <ul>\n     * <li>Some other thread invokes the {@link #signal} method for this\n     * {@code Condition} and the current thread happens to be chosen as the\n     * thread to be awakened; or\n     * <li>Some other thread invokes the {@link #signalAll} method for this\n     * {@code Condition}; or\n     * <li>Some other thread {@linkplain Thread#interrupt interrupts} the\n     * current thread, and interruption of thread suspension is supported; or\n     * <li>The specified waiting time elapses; or\n     * <li>A &quot;<em>spurious wakeup</em>&quot; occurs.\n     * </ul>\n     *\n     * <p>In all cases, before this method can return the current thread must\n     * re-acquire the lock associated with this condition. When the\n     * thread returns it is <em>guaranteed</em> to hold this lock.\n     *\n     * <p>If the current thread:\n     * <ul>\n     * <li>has its interrupted status set on entry to this method; or\n     * <li>is {@linkplain Thread#interrupt interrupted} while waiting\n     * and interruption of thread suspension is supported,\n     * </ul>\n     * then {@link InterruptedException} is thrown and the current thread's\n     * interrupted status is cleared. It is not specified, in the first\n     * case, whether or not the test for interruption occurs before the lock\n     * is released.\n     *\n     * <p>The method returns an estimate of the number of nanoseconds\n     * remaining to wait given the supplied {@code nanosTimeout}\n     * value upon return, or a value less than or equal to zero if it\n     * timed out. This value can be used to determine whether and how\n     * long to re-wait in cases where the wait returns but an awaited\n     * condition still does not hold. Typical uses of this method take\n     * the following form:\n     *\n     * <pre> {@code\n     * boolean aMethod(long timeout, TimeUnit unit)\n     *     throws InterruptedException {\n     *   long nanosRemaining = unit.toNanos(timeout);\n     *   lock.lock();\n     *   try {\n     *     while (!conditionBeingWaitedFor()) {\n     *       if (nanosRemaining <= 0L)\n     *         return false;\n     *       nanosRemaining = theCondition.awaitNanos(nanosRemaining);\n     *     }\n     *     // ...\n     *     return true;\n     *   } finally {\n     *     lock.unlock();\n     *   }\n     * }}</pre>\n     *\n     * <p>Design note: This method requires a nanosecond argument so\n     * as to avoid truncation errors in reporting remaining times.\n     * Such precision loss would make it difficult for programmers to\n     * ensure that total waiting times are not systematically shorter\n     * than specified when re-waits occur.\n     *\n     * <p><b>Implementation Considerations</b>\n     *\n     * <p>The current thread is assumed to hold the lock associated with this\n     * {@code Condition} when this method is called.\n     * It is up to the implementation to determine if this is\n     * the case and if not, how to respond. Typically, an exception will be\n     * thrown (such as {@link IllegalMonitorStateException}) and the\n     * implementation must document that fact.\n     *\n     * <p>An implementation can favor responding to an interrupt over normal\n     * method return in response to a signal, or over indicating the elapse\n     * of the specified waiting time. In either case the implementation\n     * must ensure that the signal is redirected to another waiting thread, if\n     * there is one.\n     *\n     * @param nanosTimeout the maximum time to wait, in nanoseconds\n     * @return an estimate of the {@code nanosTimeout} value minus\n     *         the time spent waiting upon return from this method.\n     *         A positive value may be used as the argument to a\n     *         subsequent call to this method to finish waiting out\n     *         the desired time.  A value less than or equal to zero\n     *         indicates that no time remains.\n     * @throws InterruptedException if the current thread is interrupted\n     *         (and interruption of thread suspension is supported)\n     ",
    "links" : [ "#signal", "#signalAll", "InterruptedException", "IllegalMonitorStateException" ]
  }, {
    "name" : " boolean await(long time, TimeUnit unit) throws InterruptedException",
    "returnType" : "boolean",
    "comment" : "\n     * Causes the current thread to wait until it is signalled or interrupted,\n     * or the specified waiting time elapses. This method is behaviorally\n     * equivalent to:\n     * <pre> {@code awaitNanos(unit.toNanos(time)) > 0}</pre>\n     *\n     * @param time the maximum time to wait\n     * @param unit the time unit of the {@code time} argument\n     * @return {@code false} if the waiting time detectably elapsed\n     *         before return from the method, else {@code true}\n     * @throws InterruptedException if the current thread is interrupted\n     *         (and interruption of thread suspension is supported)\n     ",
    "links" : [ ]
  }, {
    "name" : " boolean awaitUntil(Date deadline) throws InterruptedException",
    "returnType" : "boolean",
    "comment" : "\n     * Causes the current thread to wait until it is signalled or interrupted,\n     * or the specified deadline elapses.\n     *\n     * <p>The lock associated with this condition is atomically\n     * released and the current thread becomes disabled for thread scheduling\n     * purposes and lies dormant until <em>one</em> of five things happens:\n     * <ul>\n     * <li>Some other thread invokes the {@link #signal} method for this\n     * {@code Condition} and the current thread happens to be chosen as the\n     * thread to be awakened; or\n     * <li>Some other thread invokes the {@link #signalAll} method for this\n     * {@code Condition}; or\n     * <li>Some other thread {@linkplain Thread#interrupt interrupts} the\n     * current thread, and interruption of thread suspension is supported; or\n     * <li>The specified deadline elapses; or\n     * <li>A &quot;<em>spurious wakeup</em>&quot; occurs.\n     * </ul>\n     *\n     * <p>In all cases, before this method can return the current thread must\n     * re-acquire the lock associated with this condition. When the\n     * thread returns it is <em>guaranteed</em> to hold this lock.\n     *\n     * <p>If the current thread:\n     * <ul>\n     * <li>has its interrupted status set on entry to this method; or\n     * <li>is {@linkplain Thread#interrupt interrupted} while waiting\n     * and interruption of thread suspension is supported,\n     * </ul>\n     * then {@link InterruptedException} is thrown and the current thread's\n     * interrupted status is cleared. It is not specified, in the first\n     * case, whether or not the test for interruption occurs before the lock\n     * is released.\n     *\n     * <p>The return value indicates whether the deadline has elapsed,\n     * which can be used as follows:\n     * <pre> {@code\n     * boolean aMethod(Date deadline)\n     *     throws InterruptedException {\n     *   boolean stillWaiting = true;\n     *   lock.lock();\n     *   try {\n     *     while (!conditionBeingWaitedFor()) {\n     *       if (!stillWaiting)\n     *         return false;\n     *       stillWaiting = theCondition.awaitUntil(deadline);\n     *     }\n     *     // ...\n     *     return true;\n     *   } finally {\n     *     lock.unlock();\n     *   }\n     * }}</pre>\n     *\n     * <p><b>Implementation Considerations</b>\n     *\n     * <p>The current thread is assumed to hold the lock associated with this\n     * {@code Condition} when this method is called.\n     * It is up to the implementation to determine if this is\n     * the case and if not, how to respond. Typically, an exception will be\n     * thrown (such as {@link IllegalMonitorStateException}) and the\n     * implementation must document that fact.\n     *\n     * <p>An implementation can favor responding to an interrupt over normal\n     * method return in response to a signal, or over indicating the passing\n     * of the specified deadline. In either case the implementation\n     * must ensure that the signal is redirected to another waiting thread, if\n     * there is one.\n     *\n     * @param deadline the absolute time to wait until\n     * @return {@code false} if the deadline has elapsed upon return, else\n     *         {@code true}\n     * @throws InterruptedException if the current thread is interrupted\n     *         (and interruption of thread suspension is supported)\n     ",
    "links" : [ "#signal", "#signalAll", "InterruptedException", "IllegalMonitorStateException" ]
  }, {
    "name" : " void signal()",
    "returnType" : "void",
    "comment" : "\n     * Wakes up one waiting thread.\n     *\n     * <p>If any threads are waiting on this condition then one\n     * is selected for waking up. That thread must then re-acquire the\n     * lock before returning from {@code await}.\n     *\n     * <p><b>Implementation Considerations</b>\n     *\n     * <p>An implementation may (and typically does) require that the\n     * current thread hold the lock associated with this {@code\n     * Condition} when this method is called. Implementations must\n     * document this precondition and any actions taken if the lock is\n     * not held. Typically, an exception such as {@link\n     * IllegalMonitorStateException} will be thrown.\n     ",
    "links" : [ "IllegalMonitorStateException" ]
  }, {
    "name" : " void signalAll()",
    "returnType" : "void",
    "comment" : "\n     * Wakes up all waiting threads.\n     *\n     * <p>If any threads are waiting on this condition then they are\n     * all woken up. Each thread must re-acquire the lock before it can\n     * return from {@code await}.\n     *\n     * <p><b>Implementation Considerations</b>\n     *\n     * <p>An implementation may (and typically does) require that the\n     * current thread hold the lock associated with this {@code\n     * Condition} when this method is called. Implementations must\n     * document this precondition and any actions taken if the lock is\n     * not held. Typically, an exception such as {@link\n     * IllegalMonitorStateException} will be thrown.\n     ",
    "links" : [ "IllegalMonitorStateException" ]
  } ],
  "methodNames" : [ " void await() throws InterruptedException", " void awaitUninterruptibly()", " long awaitNanos(long nanosTimeout) throws InterruptedException", " boolean await(long time, TimeUnit unit) throws InterruptedException", " boolean awaitUntil(Date deadline) throws InterruptedException", " void signal()", " void signalAll()" ],
  "variableNames" : [ ]
}