{
  "filePath" : "/home/maryam/clearblue/files/android-source-30/android/bluetooth/BluetoothDevice.java",
  "packageName" : "android.bluetooth",
  "className" : "BluetoothDevice",
  "comment" : "\n * Represents a remote Bluetooth device. A {@link BluetoothDevice} lets you\n * create a connection with the respective device or query information about\n * it, such as the name, address, class, and bonding state.\n *\n * <p>This class is really just a thin wrapper for a Bluetooth hardware\n * address. Objects of this class are immutable. Operations on this class\n * are performed on the remote Bluetooth hardware address, using the\n * {@link BluetoothAdapter} that was used to create this {@link\n * BluetoothDevice}.\n *\n * <p>To get a {@link BluetoothDevice}, use\n * {@link BluetoothAdapter#getRemoteDevice(String)\n * BluetoothAdapter.getRemoteDevice(String)} to create one representing a device\n * of a known MAC address (which you can get through device discovery with\n * {@link BluetoothAdapter}) or get one from the set of bonded devices\n * returned by {@link BluetoothAdapter#getBondedDevices()\n * BluetoothAdapter.getBondedDevices()}. You can then open a\n * {@link BluetoothSocket} for communication with the remote device, using\n * {@link #createRfcommSocketToServiceRecord(UUID)} over Bluetooth BR/EDR or using\n * {@link #createL2capChannel(int)} over Bluetooth LE.\n *\n * <p class=\"note\"><strong>Note:</strong>\n * Requires the {@link android.Manifest.permission#BLUETOOTH} permission.\n *\n * <div class=\"special reference\">\n * <h3>Developer Guides</h3>\n * <p>\n * For more information about using Bluetooth, read the <a href=\n * \"{@docRoot}guide/topics/connectivity/bluetooth.html\">Bluetooth</a> developer\n * guide.\n * </p>\n * </div>\n *\n * {@see BluetoothAdapter}\n * {@see BluetoothSocket}\n ",
  "variables" : [ {
    "name" : "TAG",
    "type" : "String",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "DBG",
    "type" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "CONNECTION_STATE_DISCONNECTED",
    "type" : "int",
    "comment" : "\n     * Connection state bitmask as returned by getConnectionState.\n     ",
    "links" : [ ]
  }, {
    "name" : "CONNECTION_STATE_CONNECTED",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "CONNECTION_STATE_ENCRYPTED_BREDR",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "CONNECTION_STATE_ENCRYPTED_LE",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "ERROR",
    "type" : "int",
    "comment" : "\n     * Sentinel error value for this class. Guaranteed to not equal any other\n     * integer constant in this class. Provided as a convenience for functions\n     * that require a sentinel error value, for example:\n     * <p><code>Intent.getIntExtra(BluetoothDevice.EXTRA_BOND_STATE,\n     * BluetoothDevice.ERROR)</code>\n     ",
    "links" : [ ]
  }, {
    "name" : "ACTION_FOUND",
    "type" : "String",
    "comment" : " TODO: Change API to not broadcast RSSI if not available (incoming connection)",
    "links" : [ ]
  }, {
    "name" : "ACTION_CLASS_CHANGED",
    "type" : "String",
    "comment" : "\n     * Broadcast Action: Bluetooth class of a remote device has changed.\n     * <p>Always contains the extra fields {@link #EXTRA_DEVICE} and {@link\n     * #EXTRA_CLASS}.\n     * <p>Requires {@link android.Manifest.permission#BLUETOOTH} to receive.\n     * {@see BluetoothClass}\n     ",
    "links" : [ "#EXTRA_DEVICE", "android.Manifest.permission#BLUETOOTH" ]
  }, {
    "name" : "ACTION_ACL_CONNECTED",
    "type" : "String",
    "comment" : "\n     * Broadcast Action: Indicates a low level (ACL) connection has been\n     * established with a remote device.\n     * <p>Always contains the extra field {@link #EXTRA_DEVICE}.\n     * <p>ACL connections are managed automatically by the Android Bluetooth\n     * stack.\n     * <p>Requires {@link android.Manifest.permission#BLUETOOTH} to receive.\n     ",
    "links" : [ "#EXTRA_DEVICE", "android.Manifest.permission#BLUETOOTH" ]
  }, {
    "name" : "ACTION_ACL_DISCONNECT_REQUESTED",
    "type" : "String",
    "comment" : "\n     * Broadcast Action: Indicates that a low level (ACL) disconnection has\n     * been requested for a remote device, and it will soon be disconnected.\n     * <p>This is useful for graceful disconnection. Applications should use\n     * this intent as a hint to immediately terminate higher level connections\n     * (RFCOMM, L2CAP, or profile connections) to the remote device.\n     * <p>Always contains the extra field {@link #EXTRA_DEVICE}.\n     * <p>Requires {@link android.Manifest.permission#BLUETOOTH} to receive.\n     ",
    "links" : [ "#EXTRA_DEVICE", "android.Manifest.permission#BLUETOOTH" ]
  }, {
    "name" : "ACTION_ACL_DISCONNECTED",
    "type" : "String",
    "comment" : "\n     * Broadcast Action: Indicates a low level (ACL) disconnection from a\n     * remote device.\n     * <p>Always contains the extra field {@link #EXTRA_DEVICE}.\n     * <p>ACL connections are managed automatically by the Android Bluetooth\n     * stack.\n     * <p>Requires {@link android.Manifest.permission#BLUETOOTH} to receive.\n     ",
    "links" : [ "#EXTRA_DEVICE", "android.Manifest.permission#BLUETOOTH" ]
  }, {
    "name" : "ACTION_NAME_CHANGED",
    "type" : "String",
    "comment" : "\n     * Broadcast Action: Indicates the friendly name of a remote device has\n     * been retrieved for the first time, or changed since the last retrieval.\n     * <p>Always contains the extra fields {@link #EXTRA_DEVICE} and {@link\n     * #EXTRA_NAME}.\n     * <p>Requires {@link android.Manifest.permission#BLUETOOTH} to receive.\n     ",
    "links" : [ "#EXTRA_DEVICE", "android.Manifest.permission#BLUETOOTH" ]
  }, {
    "name" : "ACTION_ALIAS_CHANGED",
    "type" : "String",
    "comment" : "\n     * Broadcast Action: Indicates the alias of a remote device has been\n     * changed.\n     * <p>Always contains the extra field {@link #EXTRA_DEVICE}.\n     * <p>Requires {@link android.Manifest.permission#BLUETOOTH} to receive.\n     ",
    "links" : [ "#EXTRA_DEVICE", "android.Manifest.permission#BLUETOOTH" ]
  }, {
    "name" : "ACTION_BOND_STATE_CHANGED",
    "type" : "String",
    "comment" : " contain a hidden extra field EXTRA_REASON with the result code.",
    "links" : [ ]
  }, {
    "name" : "ACTION_BATTERY_LEVEL_CHANGED",
    "type" : "String",
    "comment" : "\n     * Broadcast Action: Indicates the battery level of a remote device has\n     * been retrieved for the first time, or changed since the last retrieval\n     * <p>Always contains the extra fields {@link #EXTRA_DEVICE} and {@link\n     * #EXTRA_BATTERY_LEVEL}.\n     * <p>Requires {@link android.Manifest.permission#BLUETOOTH} to receive.\n     *\n     * @hide\n     ",
    "links" : [ "#EXTRA_DEVICE", "android.Manifest.permission#BLUETOOTH" ]
  }, {
    "name" : "EXTRA_BATTERY_LEVEL",
    "type" : "String",
    "comment" : "\n     * Used as an Integer extra field in {@link #ACTION_BATTERY_LEVEL_CHANGED}\n     * intent. It contains the most recently retrieved battery level information\n     * ranging from 0% to 100% for a remote device, {@link #BATTERY_LEVEL_UNKNOWN}\n     * when the valid is unknown or there is an error\n     *\n     * @hide\n     ",
    "links" : [ "#ACTION_BATTERY_LEVEL_CHANGED", "#BATTERY_LEVEL_UNKNOWN" ]
  }, {
    "name" : "BATTERY_LEVEL_UNKNOWN",
    "type" : "int",
    "comment" : "\n     * Used as the unknown value for {@link #EXTRA_BATTERY_LEVEL} and {@link #getBatteryLevel()}\n     *\n     * @hide\n     ",
    "links" : [ "#EXTRA_BATTERY_LEVEL", "#getBatteryLevel" ]
  }, {
    "name" : "BATTERY_LEVEL_BLUETOOTH_OFF",
    "type" : "int",
    "comment" : "\n     * Used as an error value for {@link #getBatteryLevel()} to represent bluetooth is off\n     *\n     * @hide\n     ",
    "links" : [ "#getBatteryLevel" ]
  }, {
    "name" : "EXTRA_DEVICE",
    "type" : "String",
    "comment" : "\n     * Used as a Parcelable {@link BluetoothDevice} extra field in every intent\n     * broadcast by this class. It contains the {@link BluetoothDevice} that\n     * the intent applies to.\n     ",
    "links" : [ "BluetoothDevice", "BluetoothDevice" ]
  }, {
    "name" : "EXTRA_NAME",
    "type" : "String",
    "comment" : "\n     * Used as a String extra field in {@link #ACTION_NAME_CHANGED} and {@link\n     * #ACTION_FOUND} intents. It contains the friendly Bluetooth name.\n     ",
    "links" : [ "#ACTION_NAME_CHANGED" ]
  }, {
    "name" : "EXTRA_RSSI",
    "type" : "String",
    "comment" : "\n     * Used as an optional short extra field in {@link #ACTION_FOUND} intents.\n     * Contains the RSSI value of the remote device as reported by the\n     * Bluetooth hardware.\n     ",
    "links" : [ "#ACTION_FOUND" ]
  }, {
    "name" : "EXTRA_CLASS",
    "type" : "String",
    "comment" : "\n     * Used as a Parcelable {@link BluetoothClass} extra field in {@link\n     * #ACTION_FOUND} and {@link #ACTION_CLASS_CHANGED} intents.\n     ",
    "links" : [ "BluetoothClass", "#ACTION_CLASS_CHANGED" ]
  }, {
    "name" : "EXTRA_BOND_STATE",
    "type" : "String",
    "comment" : "\n     * Used as an int extra field in {@link #ACTION_BOND_STATE_CHANGED} intents.\n     * Contains the bond state of the remote device.\n     * <p>Possible values are:\n     * {@link #BOND_NONE},\n     * {@link #BOND_BONDING},\n     * {@link #BOND_BONDED}.\n     ",
    "links" : [ "#ACTION_BOND_STATE_CHANGED", "#BOND_NONE", "#BOND_BONDING", "#BOND_BONDED" ]
  }, {
    "name" : "EXTRA_PREVIOUS_BOND_STATE",
    "type" : "String",
    "comment" : "\n     * Used as an int extra field in {@link #ACTION_BOND_STATE_CHANGED} intents.\n     * Contains the previous bond state of the remote device.\n     * <p>Possible values are:\n     * {@link #BOND_NONE},\n     * {@link #BOND_BONDING},\n     * {@link #BOND_BONDED}.\n     ",
    "links" : [ "#ACTION_BOND_STATE_CHANGED", "#BOND_NONE", "#BOND_BONDING", "#BOND_BONDED" ]
  }, {
    "name" : "BOND_NONE",
    "type" : "int",
    "comment" : "\n     * Indicates the remote device is not bonded (paired).\n     * <p>There is no shared link key with the remote device, so communication\n     * (if it is allowed at all) will be unauthenticated and unencrypted.\n     ",
    "links" : [ ]
  }, {
    "name" : "BOND_BONDING",
    "type" : "int",
    "comment" : "\n     * Indicates bonding (pairing) is in progress with the remote device.\n     ",
    "links" : [ ]
  }, {
    "name" : "BOND_BONDED",
    "type" : "int",
    "comment" : "\n     * Indicates the remote device is bonded (paired).\n     * <p>A shared link keys exists locally for the remote device, so\n     * communication can be authenticated and encrypted.\n     * <p><i>Being bonded (paired) with a remote device does not necessarily\n     * mean the device is currently connected. It just means that the pending\n     * procedure was completed at some earlier time, and the link key is still\n     * stored locally, ready to use on the next connection.\n     * </i>\n     ",
    "links" : [ ]
  }, {
    "name" : "EXTRA_REASON",
    "type" : "String",
    "comment" : "\n     * Used as an int extra field in {@link #ACTION_PAIRING_REQUEST}\n     * intents for unbond reason.\n     *\n     * @hide\n     ",
    "links" : [ "#ACTION_PAIRING_REQUEST" ]
  }, {
    "name" : "EXTRA_PAIRING_VARIANT",
    "type" : "String",
    "comment" : "\n     * Used as an int extra field in {@link #ACTION_PAIRING_REQUEST}\n     * intents to indicate pairing method used. Possible values are:\n     * {@link #PAIRING_VARIANT_PIN},\n     * {@link #PAIRING_VARIANT_PASSKEY_CONFIRMATION},\n     ",
    "links" : [ "#ACTION_PAIRING_REQUEST", "#PAIRING_VARIANT_PIN", "#PAIRING_VARIANT_PASSKEY_CONFIRMATION" ]
  }, {
    "name" : "EXTRA_PAIRING_KEY",
    "type" : "String",
    "comment" : "\n     * Used as an int extra field in {@link #ACTION_PAIRING_REQUEST}\n     * intents as the value of passkey.\n     ",
    "links" : [ "#ACTION_PAIRING_REQUEST" ]
  }, {
    "name" : "DEVICE_TYPE_UNKNOWN",
    "type" : "int",
    "comment" : "\n     * Bluetooth device type, Unknown\n     ",
    "links" : [ ]
  }, {
    "name" : "DEVICE_TYPE_CLASSIC",
    "type" : "int",
    "comment" : "\n     * Bluetooth device type, Classic - BR/EDR devices\n     ",
    "links" : [ ]
  }, {
    "name" : "DEVICE_TYPE_LE",
    "type" : "int",
    "comment" : "\n     * Bluetooth device type, Low Energy - LE-only\n     ",
    "links" : [ ]
  }, {
    "name" : "DEVICE_TYPE_DUAL",
    "type" : "int",
    "comment" : "\n     * Bluetooth device type, Dual Mode - BR/EDR/LE\n     ",
    "links" : [ ]
  }, {
    "name" : "ACTION_SDP_RECORD",
    "type" : "String",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "METADATA_MAX_LENGTH",
    "type" : "int",
    "comment" : "\n     * Maximum length of a metadata entry, this is to avoid exploding Bluetooth\n     * disk usage\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "METADATA_MANUFACTURER_NAME",
    "type" : "int",
    "comment" : "\n     * Manufacturer name of this Bluetooth device\n     * Data type should be {@String} as {@link Byte} array.\n     * @hide\n     ",
    "links" : [ "Byte" ]
  }, {
    "name" : "METADATA_MODEL_NAME",
    "type" : "int",
    "comment" : "\n     * Model name of this Bluetooth device\n     * Data type should be {@String} as {@link Byte} array.\n     * @hide\n     ",
    "links" : [ "Byte" ]
  }, {
    "name" : "METADATA_SOFTWARE_VERSION",
    "type" : "int",
    "comment" : "\n     * Software version of this Bluetooth device\n     * Data type should be {@String} as {@link Byte} array.\n     * @hide\n     ",
    "links" : [ "Byte" ]
  }, {
    "name" : "METADATA_HARDWARE_VERSION",
    "type" : "int",
    "comment" : "\n     * Hardware version of this Bluetooth device\n     * Data type should be {@String} as {@link Byte} array.\n     * @hide\n     ",
    "links" : [ "Byte" ]
  }, {
    "name" : "METADATA_COMPANION_APP",
    "type" : "int",
    "comment" : "\n     * Package name of the companion app, if any\n     * Data type should be {@String} as {@link Byte} array.\n     * @hide\n     ",
    "links" : [ "Byte" ]
  }, {
    "name" : "METADATA_MAIN_ICON",
    "type" : "int",
    "comment" : "\n     * URI to the main icon shown on the settings UI\n     * Data type should be {@link Byte} array.\n     * @hide\n     ",
    "links" : [ "Byte" ]
  }, {
    "name" : "METADATA_IS_UNTETHERED_HEADSET",
    "type" : "int",
    "comment" : "\n     * Whether this device is an untethered headset with left, right and case\n     * Data type should be {@String} as {@link Byte} array.\n     * @hide\n     ",
    "links" : [ "Byte" ]
  }, {
    "name" : "METADATA_UNTETHERED_LEFT_ICON",
    "type" : "int",
    "comment" : "\n     * URI to icon of the left headset\n     * Data type should be {@link Byte} array.\n     * @hide\n     ",
    "links" : [ "Byte" ]
  }, {
    "name" : "METADATA_UNTETHERED_RIGHT_ICON",
    "type" : "int",
    "comment" : "\n     * URI to icon of the right headset\n     * Data type should be {@link Byte} array.\n     * @hide\n     ",
    "links" : [ "Byte" ]
  }, {
    "name" : "METADATA_UNTETHERED_CASE_ICON",
    "type" : "int",
    "comment" : "\n     * URI to icon of the headset charging case\n     * Data type should be {@link Byte} array.\n     * @hide\n     ",
    "links" : [ "Byte" ]
  }, {
    "name" : "METADATA_UNTETHERED_LEFT_BATTERY",
    "type" : "int",
    "comment" : "\n     * Battery level of left headset\n     * Data type should be {@String} 0-100 as {@link Byte} array, otherwise\n     * as invalid.\n     * @hide\n     ",
    "links" : [ "Byte" ]
  }, {
    "name" : "METADATA_UNTETHERED_RIGHT_BATTERY",
    "type" : "int",
    "comment" : "\n     * Battery level of rigth headset\n     * Data type should be {@String} 0-100 as {@link Byte} array, otherwise\n     * as invalid.\n     * @hide\n     ",
    "links" : [ "Byte" ]
  }, {
    "name" : "METADATA_UNTETHERED_CASE_BATTERY",
    "type" : "int",
    "comment" : "\n     * Battery level of the headset charging case\n     * Data type should be {@String} 0-100 as {@link Byte} array, otherwise\n     * as invalid.\n     * @hide\n     ",
    "links" : [ "Byte" ]
  }, {
    "name" : "METADATA_UNTETHERED_LEFT_CHARGING",
    "type" : "int",
    "comment" : "\n     * Whether the left headset is charging\n     * Data type should be {@String} as {@link Byte} array.\n     * @hide\n     ",
    "links" : [ "Byte" ]
  }, {
    "name" : "METADATA_UNTETHERED_RIGHT_CHARGING",
    "type" : "int",
    "comment" : "\n     * Whether the right headset is charging\n     * Data type should be {@String} as {@link Byte} array.\n     * @hide\n     ",
    "links" : [ "Byte" ]
  }, {
    "name" : "METADATA_UNTETHERED_CASE_CHARGING",
    "type" : "int",
    "comment" : "\n     * Whether the headset charging case is charging\n     * Data type should be {@String} as {@link Byte} array.\n     * @hide\n     ",
    "links" : [ "Byte" ]
  }, {
    "name" : "METADATA_ENHANCED_SETTINGS_UI_URI",
    "type" : "int",
    "comment" : "\n     * URI to the enhanced settings UI slice\n     * Data type should be {@String} as {@link Byte} array, null means\n     * the UI does not exist.\n     * @hide\n     ",
    "links" : [ "Byte" ]
  }, {
    "name" : "ACTION_UUID",
    "type" : "String",
    "comment" : "\n     * Broadcast Action: This intent is used to broadcast the {@link UUID}\n     * wrapped as a {@link android.os.ParcelUuid} of the remote device after it\n     * has been fetched. This intent is sent only when the UUIDs of the remote\n     * device are requested to be fetched using Service Discovery Protocol\n     * <p> Always contains the extra field {@link #EXTRA_DEVICE}\n     * <p> Always contains the extra field {@link #EXTRA_UUID}\n     * <p>Requires {@link android.Manifest.permission#BLUETOOTH_ADMIN} to receive.\n     ",
    "links" : [ "UUID", "android.os.ParcelUuid", "#EXTRA_DEVICE", "#EXTRA_UUID", "android.Manifest.permission#BLUETOOTH_ADMIN" ]
  }, {
    "name" : "ACTION_MAS_INSTANCE",
    "type" : "String",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "ACTION_NAME_FAILED",
    "type" : "String",
    "comment" : "TODO: is this actually useful?",
    "links" : [ ]
  }, {
    "name" : "ACTION_PAIRING_REQUEST",
    "type" : "String",
    "comment" : "\n     * Broadcast Action: This intent is used to broadcast PAIRING REQUEST\n     * <p>Requires {@link android.Manifest.permission#BLUETOOTH_ADMIN} to\n     * receive.\n     ",
    "links" : [ "android.Manifest.permission#BLUETOOTH_ADMIN" ]
  }, {
    "name" : "ACTION_PAIRING_CANCEL",
    "type" : "String",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "ACTION_CONNECTION_ACCESS_REQUEST",
    "type" : "String",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "ACTION_CONNECTION_ACCESS_REPLY",
    "type" : "String",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "ACTION_CONNECTION_ACCESS_CANCEL",
    "type" : "String",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "ACTION_SILENCE_MODE_CHANGED",
    "type" : "String",
    "comment" : "\n     * Intent to broadcast silence mode changed.\n     * Alway contains the extra field {@link #EXTRA_DEVICE}\n     *\n     * @hide\n     ",
    "links" : [ "#EXTRA_DEVICE" ]
  }, {
    "name" : "EXTRA_ACCESS_REQUEST_TYPE",
    "type" : "String",
    "comment" : "\n     * Used as an extra field in {@link #ACTION_CONNECTION_ACCESS_REQUEST} intent.\n     *\n     * @hide\n     ",
    "links" : [ "#ACTION_CONNECTION_ACCESS_REQUEST" ]
  }, {
    "name" : "REQUEST_TYPE_PROFILE_CONNECTION",
    "type" : "int",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "REQUEST_TYPE_PHONEBOOK_ACCESS",
    "type" : "int",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "REQUEST_TYPE_MESSAGE_ACCESS",
    "type" : "int",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "REQUEST_TYPE_SIM_ACCESS",
    "type" : "int",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "EXTRA_PACKAGE_NAME",
    "type" : "String",
    "comment" : "\n     * Used as an extra field in {@link #ACTION_CONNECTION_ACCESS_REQUEST} intents,\n     * Contains package name to return reply intent to.\n     *\n     * @hide\n     ",
    "links" : [ "#ACTION_CONNECTION_ACCESS_REQUEST" ]
  }, {
    "name" : "EXTRA_CLASS_NAME",
    "type" : "String",
    "comment" : "\n     * Used as an extra field in {@link #ACTION_CONNECTION_ACCESS_REQUEST} intents,\n     * Contains class name to return reply intent to.\n     *\n     * @hide\n     ",
    "links" : [ "#ACTION_CONNECTION_ACCESS_REQUEST" ]
  }, {
    "name" : "EXTRA_CONNECTION_ACCESS_RESULT",
    "type" : "String",
    "comment" : "\n     * Used as an extra field in {@link #ACTION_CONNECTION_ACCESS_REPLY} intent.\n     *\n     * @hide\n     ",
    "links" : [ "#ACTION_CONNECTION_ACCESS_REPLY" ]
  }, {
    "name" : "CONNECTION_ACCESS_YES",
    "type" : "int",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "CONNECTION_ACCESS_NO",
    "type" : "int",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "EXTRA_ALWAYS_ALLOWED",
    "type" : "String",
    "comment" : "\n     * Used as an extra field in {@link #ACTION_CONNECTION_ACCESS_REPLY} intents,\n     * Contains boolean to indicate if the allowed response is once-for-all so that\n     * next request will be granted without asking user again.\n     *\n     * @hide\n     ",
    "links" : [ "#ACTION_CONNECTION_ACCESS_REPLY" ]
  }, {
    "name" : "BOND_SUCCESS",
    "type" : "int",
    "comment" : "\n     * A bond attempt succeeded\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "UNBOND_REASON_AUTH_FAILED",
    "type" : "int",
    "comment" : "\n     * A bond attempt failed because pins did not match, or remote device did\n     * not respond to pin request in time\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "UNBOND_REASON_AUTH_REJECTED",
    "type" : "int",
    "comment" : "\n     * A bond attempt failed because the other side explicitly rejected\n     * bonding\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "UNBOND_REASON_AUTH_CANCELED",
    "type" : "int",
    "comment" : "\n     * A bond attempt failed because we canceled the bonding process\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "UNBOND_REASON_REMOTE_DEVICE_DOWN",
    "type" : "int",
    "comment" : "\n     * A bond attempt failed because we could not contact the remote device\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "UNBOND_REASON_DISCOVERY_IN_PROGRESS",
    "type" : "int",
    "comment" : "\n     * A bond attempt failed because a discovery is in progress\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "UNBOND_REASON_AUTH_TIMEOUT",
    "type" : "int",
    "comment" : "\n     * A bond attempt failed because of authentication timeout\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "UNBOND_REASON_REPEATED_ATTEMPTS",
    "type" : "int",
    "comment" : "\n     * A bond attempt failed because of repeated attempts\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "UNBOND_REASON_REMOTE_AUTH_CANCELED",
    "type" : "int",
    "comment" : "\n     * A bond attempt failed because we received an Authentication Cancel\n     * by remote end\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "UNBOND_REASON_REMOVED",
    "type" : "int",
    "comment" : "\n     * An existing bond was explicitly revoked\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "PAIRING_VARIANT_PIN",
    "type" : "int",
    "comment" : "\n     * The user will be prompted to enter a pin or\n     * an app will enter a pin for user.\n     ",
    "links" : [ ]
  }, {
    "name" : "PAIRING_VARIANT_PASSKEY",
    "type" : "int",
    "comment" : "\n     * The user will be prompted to enter a passkey\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "PAIRING_VARIANT_PASSKEY_CONFIRMATION",
    "type" : "int",
    "comment" : "\n     * The user will be prompted to confirm the passkey displayed on the screen or\n     * an app will confirm the passkey for the user.\n     ",
    "links" : [ ]
  }, {
    "name" : "PAIRING_VARIANT_CONSENT",
    "type" : "int",
    "comment" : "\n     * The user will be prompted to accept or deny the incoming pairing request\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "PAIRING_VARIANT_DISPLAY_PASSKEY",
    "type" : "int",
    "comment" : "\n     * The user will be prompted to enter the passkey displayed on remote device\n     * This is used for Bluetooth 2.1 pairing.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "PAIRING_VARIANT_DISPLAY_PIN",
    "type" : "int",
    "comment" : "\n     * The user will be prompted to enter the PIN displayed on remote device.\n     * This is used for Bluetooth 2.0 pairing.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "PAIRING_VARIANT_OOB_CONSENT",
    "type" : "int",
    "comment" : "\n     * The user will be prompted to accept or deny the OOB pairing request\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "PAIRING_VARIANT_PIN_16_DIGITS",
    "type" : "int",
    "comment" : "\n     * The user will be prompted to enter a 16 digit pin or\n     * an app will enter a 16 digit pin for user.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "EXTRA_UUID",
    "type" : "String",
    "comment" : "\n     * Used as an extra field in {@link #ACTION_UUID} intents,\n     * Contains the {@link android.os.ParcelUuid}s of the remote device which\n     * is a parcelable version of {@link UUID}.\n     ",
    "links" : [ "#ACTION_UUID", "android.os.ParcelUuid", "UUID" ]
  }, {
    "name" : "EXTRA_SDP_RECORD",
    "type" : "String",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "EXTRA_SDP_SEARCH_STATUS",
    "type" : "String",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "ACCESS_UNKNOWN",
    "type" : "int",
    "comment" : "\n     * For {@link #getPhonebookAccessPermission}, {@link #setPhonebookAccessPermission},\n     * {@link #getMessageAccessPermission} and {@link #setMessageAccessPermission}.\n     *\n     * @hide\n     ",
    "links" : [ "#getPhonebookAccessPermission", "#setPhonebookAccessPermission", "#getMessageAccessPermission", "#setMessageAccessPermission" ]
  }, {
    "name" : "ACCESS_ALLOWED",
    "type" : "int",
    "comment" : "\n     * For {@link #getPhonebookAccessPermission}, {@link #setPhonebookAccessPermission},\n     * {@link #getMessageAccessPermission} and {@link #setMessageAccessPermission}.\n     *\n     * @hide\n     ",
    "links" : [ "#getPhonebookAccessPermission", "#setPhonebookAccessPermission", "#getMessageAccessPermission", "#setMessageAccessPermission" ]
  }, {
    "name" : "ACCESS_REJECTED",
    "type" : "int",
    "comment" : "\n     * For {@link #getPhonebookAccessPermission}, {@link #setPhonebookAccessPermission},\n     * {@link #getMessageAccessPermission} and {@link #setMessageAccessPermission}.\n     *\n     * @hide\n     ",
    "links" : [ "#getPhonebookAccessPermission", "#setPhonebookAccessPermission", "#getMessageAccessPermission", "#setMessageAccessPermission" ]
  }, {
    "name" : "TRANSPORT_AUTO",
    "type" : "int",
    "comment" : "\n     * No preference of physical transport for GATT connections to remote dual-mode devices\n     ",
    "links" : [ ]
  }, {
    "name" : "TRANSPORT_BREDR",
    "type" : "int",
    "comment" : "\n     * Prefer BR/EDR transport for GATT connections to remote dual-mode devices\n     ",
    "links" : [ ]
  }, {
    "name" : "TRANSPORT_LE",
    "type" : "int",
    "comment" : "\n     * Prefer LE transport for GATT connections to remote dual-mode devices\n     ",
    "links" : [ ]
  }, {
    "name" : "PHY_LE_1M",
    "type" : "int",
    "comment" : "\n     * Bluetooth LE 1M PHY. Used to refer to LE 1M Physical Channel for advertising, scanning or\n     * connection.\n     ",
    "links" : [ ]
  }, {
    "name" : "PHY_LE_2M",
    "type" : "int",
    "comment" : "\n     * Bluetooth LE 2M PHY. Used to refer to LE 2M Physical Channel for advertising, scanning or\n     * connection.\n     ",
    "links" : [ ]
  }, {
    "name" : "PHY_LE_CODED",
    "type" : "int",
    "comment" : "\n     * Bluetooth LE Coded PHY. Used to refer to LE Coded Physical Channel for advertising, scanning\n     * or connection.\n     ",
    "links" : [ ]
  }, {
    "name" : "PHY_LE_1M_MASK",
    "type" : "int",
    "comment" : "\n     * Bluetooth LE 1M PHY mask. Used to specify LE 1M Physical Channel as one of many available\n     * options in a bitmask.\n     ",
    "links" : [ ]
  }, {
    "name" : "PHY_LE_2M_MASK",
    "type" : "int",
    "comment" : "\n     * Bluetooth LE 2M PHY mask. Used to specify LE 2M Physical Channel as one of many available\n     * options in a bitmask.\n     ",
    "links" : [ ]
  }, {
    "name" : "PHY_LE_CODED_MASK",
    "type" : "int",
    "comment" : "\n     * Bluetooth LE Coded PHY mask. Used to specify LE Coded Physical Channel as one of many\n     * available options in a bitmask.\n     ",
    "links" : [ ]
  }, {
    "name" : "PHY_OPTION_NO_PREFERRED",
    "type" : "int",
    "comment" : "\n     * No preferred coding when transmitting on the LE Coded PHY.\n     ",
    "links" : [ ]
  }, {
    "name" : "PHY_OPTION_S2",
    "type" : "int",
    "comment" : "\n     * Prefer the S=2 coding to be used when transmitting on the LE Coded PHY.\n     ",
    "links" : [ ]
  }, {
    "name" : "PHY_OPTION_S8",
    "type" : "int",
    "comment" : "\n     * Prefer the S=8 coding to be used when transmitting on the LE Coded PHY.\n     ",
    "links" : [ ]
  }, {
    "name" : "EXTRA_MAS_INSTANCE",
    "type" : "String",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "sService",
    "type" : "IBluetooth",
    "comment" : "\n     * Lazy initialization. Guaranteed final after first object constructed, or\n     * getService() called.\n     * TODO: Unify implementation of sService amongst BluetoothFoo API's\n     ",
    "links" : [ ]
  }, {
    "name" : "mAddress",
    "type" : "String",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "sStateChangeCallback",
    "type" : "IBluetoothManagerCallback",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "CREATOR",
    "type" : "Parcelable.Creator<BluetoothDevice>",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "BLUETOOTH_BONDING_CACHE_PROPERTY",
    "type" : "String",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mBluetoothBondCache",
    "type" : "PropertyInvalidatedCache<BluetoothDevice, Integer>",
    "comment" : "",
    "links" : [ ]
  } ],
  "methods" : [ {
    "name" : " static IBluetooth getService()",
    "returnType" : "IBluetooth",
    "comment" : "package",
    "links" : [ ]
  }, {
    "name" : "public boolean equals(Object o)",
    "returnType" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public int hashCode()",
    "returnType" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public String toString()",
    "returnType" : "String",
    "comment" : "\n     * Returns a string representation of this BluetoothDevice.\n     * <p>Currently this is the Bluetooth hardware address, for example\n     * \"00:11:22:AA:BB:CC\". However, you should always use {@link #getAddress}\n     * if you explicitly require the Bluetooth hardware address in case the\n     * {@link #toString} representation changes in the future.\n     *\n     * @return string representation of this BluetoothDevice\n     ",
    "links" : [ "#getAddress", "#toString" ]
  }, {
    "name" : "public int describeContents()",
    "returnType" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public void writeToParcel(Parcel out, int flags)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public String getAddress()",
    "returnType" : "String",
    "comment" : "\n     * Returns the hardware address of this BluetoothDevice.\n     * <p> For example, \"00:11:22:AA:BB:CC\".\n     *\n     * @return Bluetooth hardware address as string\n     ",
    "links" : [ ]
  }, {
    "name" : "public String getName()",
    "returnType" : "String",
    "comment" : "\n     * Get the friendly Bluetooth name of the remote device.\n     *\n     * <p>The local adapter will automatically retrieve remote names when\n     * performing a device scan, and will cache them. This method just returns\n     * the name for this device from the cache.\n     *\n     * @return the Bluetooth name, or null if there was a problem.\n     ",
    "links" : [ ]
  }, {
    "name" : "public int getType()",
    "returnType" : "int",
    "comment" : "\n     * Get the Bluetooth device type of the remote device.\n     *\n     * @return the device type {@link #DEVICE_TYPE_CLASSIC}, {@link #DEVICE_TYPE_LE} {@link\n     * #DEVICE_TYPE_DUAL}. {@link #DEVICE_TYPE_UNKNOWN} if it's not available\n     ",
    "links" : [ "#DEVICE_TYPE_CLASSIC", "#DEVICE_TYPE_LE", "#DEVICE_TYPE_UNKNOWN" ]
  }, {
    "name" : "public String getAlias()",
    "returnType" : "String",
    "comment" : "\n     * Get the Bluetooth alias of the remote device.\n     * <p>Alias is the locally modified name of a remote device.\n     *\n     * @return the Bluetooth alias, the friendly device name if no alias, or\n     * null if there was a problem\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean setAlias(@NonNull String alias)",
    "returnType" : "boolean",
    "comment" : "\n     * Set the Bluetooth alias of the remote device.\n     * <p>Alias is the locally modified name of a remote device.\n     * <p>This methoid overwrites the alias. The changed\n     * alias is saved in the local storage so that the change\n     * is preserved over power cycle.\n     *\n     * @return true on success, false on error\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public int getBatteryLevel()",
    "returnType" : "int",
    "comment" : "\n     * Get the most recent identified battery level of this Bluetooth device\n     *\n     * @return Battery level in percents from 0 to 100, {@link #BATTERY_LEVEL_BLUETOOTH_OFF} if\n     * Bluetooth is disabled or {@link #BATTERY_LEVEL_UNKNOWN} if device is disconnected, or does\n     * not have any battery reporting service, or return value is invalid\n     * @hide\n     ",
    "links" : [ "#BATTERY_LEVEL_BLUETOOTH_OFF", "#BATTERY_LEVEL_UNKNOWN" ]
  }, {
    "name" : "public boolean createBond()",
    "returnType" : "boolean",
    "comment" : "\n     * Start the bonding (pairing) process with the remote device.\n     * <p>This is an asynchronous call, it will return immediately. Register\n     * for {@link #ACTION_BOND_STATE_CHANGED} intents to be notified when\n     * the bonding process completes, and its result.\n     * <p>Android system services will handle the necessary user interactions\n     * to confirm and complete the bonding process.\n     *\n     * @return false on immediate error, true if bonding will begin\n     ",
    "links" : [ "#ACTION_BOND_STATE_CHANGED" ]
  }, {
    "name" : "public boolean createBond(int transport)",
    "returnType" : "boolean",
    "comment" : "\n     * Start the bonding (pairing) process with the remote device using the\n     * specified transport.\n     *\n     * <p>This is an asynchronous call, it will return immediately. Register\n     * for {@link #ACTION_BOND_STATE_CHANGED} intents to be notified when\n     * the bonding process completes, and its result.\n     * <p>Android system services will handle the necessary user interactions\n     * to confirm and complete the bonding process.\n     * <p>Requires {@link android.Manifest.permission#BLUETOOTH_ADMIN}.\n     *\n     * @param transport The transport to use for the pairing procedure.\n     * @return false on immediate error, true if bonding will begin\n     * @throws IllegalArgumentException if an invalid transport was specified\n     * @hide\n     ",
    "links" : [ "#ACTION_BOND_STATE_CHANGED", "android.Manifest.permission#BLUETOOTH_ADMIN" ]
  }, {
    "name" : "public boolean createBondOutOfBand(int transport, OobData oobData)",
    "returnType" : "boolean",
    "comment" : "\n     * Start the bonding (pairing) process with the remote device using the\n     * Out Of Band mechanism.\n     *\n     * <p>This is an asynchronous call, it will return immediately. Register\n     * for {@link #ACTION_BOND_STATE_CHANGED} intents to be notified when\n     * the bonding process completes, and its result.\n     *\n     * <p>Android system services will handle the necessary user interactions\n     * to confirm and complete the bonding process.\n     *\n     * <p>Requires {@link android.Manifest.permission#BLUETOOTH_ADMIN}.\n     *\n     * @param transport - Transport to use\n     * @param oobData - Out Of Band data\n     * @return false on immediate error, true if bonding will begin\n     * @hide\n     ",
    "links" : [ "#ACTION_BOND_STATE_CHANGED", "android.Manifest.permission#BLUETOOTH_ADMIN" ]
  }, {
    "name" : "public boolean isBondingInitiatedLocally()",
    "returnType" : "boolean",
    "comment" : "\n     * Gets whether bonding was initiated locally\n     *\n     * @return true if bonding is initiated locally, false otherwise\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean setDeviceOutOfBandData(byte[] hash, byte[] randomizer)",
    "returnType" : "boolean",
    "comment" : "\n     * Set the Out Of Band data for a remote device to be used later\n     * in the pairing mechanism. Users can obtain this data through other\n     * trusted channels\n     *\n     * <p>Requires {@link android.Manifest.permission#BLUETOOTH_ADMIN}.\n     *\n     * @param hash Simple Secure pairing hash\n     * @param randomizer The random key obtained using OOB\n     * @return false on error; true otherwise\n     * @hide\n     ",
    "links" : [ "android.Manifest.permission#BLUETOOTH_ADMIN" ]
  }, {
    "name" : "public boolean cancelBondProcess()",
    "returnType" : "boolean",
    "comment" : "\n     * Cancel an in-progress bonding request started with {@link #createBond}.\n     *\n     * @return true on success, false on error\n     * @hide\n     ",
    "links" : [ "#createBond" ]
  }, {
    "name" : "public boolean removeBond()",
    "returnType" : "boolean",
    "comment" : "\n     * Remove bond (pairing) with the remote device.\n     * <p>Delete the link key associated with the remote device, and\n     * immediately terminate connections to that device that require\n     * authentication and encryption.\n     *\n     * @return true on success, false on error\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public void disableBluetoothGetBondStateCache()",
    "returnType" : "void",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "public static void invalidateBluetoothGetBondStateCache()",
    "returnType" : "void",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "public int getBondState()",
    "returnType" : "int",
    "comment" : "\n     * Get the bond state of the remote device.\n     * <p>Possible values for the bond state are:\n     * {@link #BOND_NONE},\n     * {@link #BOND_BONDING},\n     * {@link #BOND_BONDED}.\n     *\n     * @return the bond state\n     ",
    "links" : [ "#BOND_NONE", "#BOND_BONDING", "#BOND_BONDED" ]
  }, {
    "name" : "public boolean isConnected()",
    "returnType" : "boolean",
    "comment" : "\n     * Returns whether there is an open connection to this device.\n     *\n     * @return True if there is at least one open connection to this device.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean isEncrypted()",
    "returnType" : "boolean",
    "comment" : "\n     * Returns whether there is an open connection to this device\n     * that has been encrypted.\n     *\n     * @return True if there is at least one encrypted connection to this device.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public BluetoothClass getBluetoothClass()",
    "returnType" : "BluetoothClass",
    "comment" : "\n     * Get the Bluetooth class of the remote device.\n     *\n     * @return Bluetooth class object, or null on error\n     ",
    "links" : [ ]
  }, {
    "name" : "public ParcelUuid[] getUuids()",
    "returnType" : "ParcelUuid[]",
    "comment" : "\n     * Returns the supported features (UUIDs) of the remote device.\n     *\n     * <p>This method does not start a service discovery procedure to retrieve the UUIDs\n     * from the remote device. Instead, the local cached copy of the service\n     * UUIDs are returned.\n     * <p>Use {@link #fetchUuidsWithSdp} if fresh UUIDs are desired.\n     *\n     * @return the supported features (UUIDs) of the remote device, or null on error\n     ",
    "links" : [ "#fetchUuidsWithSdp" ]
  }, {
    "name" : "public boolean fetchUuidsWithSdp()",
    "returnType" : "boolean",
    "comment" : "\n     * Perform a service discovery on the remote device to get the UUIDs supported.\n     *\n     * <p>This API is asynchronous and {@link #ACTION_UUID} intent is sent,\n     * with the UUIDs supported by the remote end. If there is an error\n     * in getting the SDP records or if the process takes a long time,\n     * {@link #ACTION_UUID} intent is sent with the UUIDs that is currently\n     * present in the cache. Clients should use the {@link #getUuids} to get UUIDs\n     * if service discovery is not to be performed.\n     *\n     * @return False if the sanity check fails, True if the process of initiating an ACL connection\n     * to the remote device was started.\n     ",
    "links" : [ "#ACTION_UUID", "#ACTION_UUID", "#getUuids" ]
  }, {
    "name" : "public boolean sdpSearch(ParcelUuid uuid)",
    "returnType" : "boolean",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "public boolean setPin(byte[] pin)",
    "returnType" : "boolean",
    "comment" : "\n     * Set the pin during pairing when the pairing method is {@link #PAIRING_VARIANT_PIN}\n     * <p>Requires {@link android.Manifest.permission#BLUETOOTH_ADMIN}.\n     *\n     * @return true pin has been set false for error\n     ",
    "links" : [ "#PAIRING_VARIANT_PIN", "android.Manifest.permission#BLUETOOTH_ADMIN" ]
  }, {
    "name" : "public boolean setPin(@NonNull String pin)",
    "returnType" : "boolean",
    "comment" : "\n     * Set the pin during pairing when the pairing method is {@link #PAIRING_VARIANT_PIN}\n     *\n     * @return true pin has been set false for error\n     * @hide\n     ",
    "links" : [ "#PAIRING_VARIANT_PIN" ]
  }, {
    "name" : "public boolean setPairingConfirmation(boolean confirm)",
    "returnType" : "boolean",
    "comment" : "\n     * Confirm passkey for {@link #PAIRING_VARIANT_PASSKEY_CONFIRMATION} pairing.\n     *\n     * @return true confirmation has been sent out false for error\n     ",
    "links" : [ "#PAIRING_VARIANT_PASSKEY_CONFIRMATION" ]
  }, {
    "name" : "public boolean cancelPairing()",
    "returnType" : "boolean",
    "comment" : "\n     * Cancels pairing to this device\n     *\n     * @return true if pairing cancelled successfully, false otherwise\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : " boolean isBluetoothEnabled()",
    "returnType" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public int getPhonebookAccessPermission()",
    "returnType" : "int",
    "comment" : "\n     * Gets whether the phonebook access is allowed for this bluetooth device\n     *\n     * @return Whether the phonebook access is allowed to this device. Can be {@link\n     * #ACCESS_UNKNOWN}, {@link #ACCESS_ALLOWED} or {@link #ACCESS_REJECTED}.\n     * @hide\n     ",
    "links" : [ "#ACCESS_ALLOWED", "#ACCESS_REJECTED" ]
  }, {
    "name" : "public boolean setSilenceMode(boolean silence)",
    "returnType" : "boolean",
    "comment" : "\n     * Sets whether the {@link BluetoothDevice} enters silence mode. Audio will not\n     * be routed to the {@link BluetoothDevice} if set to {@code true}.\n     *\n     * When the {@link BluetoothDevice} enters silence mode, and the {@link BluetoothDevice}\n     * is an active device (for A2DP or HFP), the active device for that profile\n     * will be set to null.\n     * If the {@link BluetoothDevice} exits silence mode while the A2DP or HFP\n     * active device is null, the {@link BluetoothDevice} will be set as the\n     * active device for that profile.\n     * If the {@link BluetoothDevice} is disconnected, it exits silence mode.\n     * If the {@link BluetoothDevice} is set as the active device for A2DP or\n     * HFP, while silence mode is enabled, then the device will exit silence mode.\n     * If the {@link BluetoothDevice} is in silence mode, AVRCP position change\n     * event and HFP AG indicators will be disabled.\n     * If the {@link BluetoothDevice} is not connected with A2DP or HFP, it cannot\n     * enter silence mode.\n     *\n     * <p> Requires {@link android.Manifest.permission#BLUETOOTH_PRIVILEGED}.\n     *\n     * @param silence true to enter silence mode, false to exit\n     * @return true on success, false on error.\n     * @throws IllegalStateException if Bluetooth is not turned ON.\n     * @hide\n     ",
    "links" : [ "BluetoothDevice", "BluetoothDevice", "BluetoothDevice", "BluetoothDevice", "BluetoothDevice", "BluetoothDevice", "BluetoothDevice", "BluetoothDevice", "BluetoothDevice", "BluetoothDevice", "android.Manifest.permission#BLUETOOTH_PRIVILEGED" ]
  }, {
    "name" : "public boolean isInSilenceMode()",
    "returnType" : "boolean",
    "comment" : "\n     * Check whether the {@link BluetoothDevice} is in silence mode\n     *\n     * <p> Requires {@link android.Manifest.permission#BLUETOOTH_PRIVILEGED}.\n     *\n     * @return true on device in silence mode, otherwise false.\n     * @throws IllegalStateException if Bluetooth is not turned ON.\n     * @hide\n     ",
    "links" : [ "BluetoothDevice", "android.Manifest.permission#BLUETOOTH_PRIVILEGED" ]
  }, {
    "name" : "public boolean setPhonebookAccessPermission(@AccessPermission int value)",
    "returnType" : "boolean",
    "comment" : "\n     * Sets whether the phonebook access is allowed to this device.\n     *\n     * @param value Can be {@link #ACCESS_UNKNOWN}, {@link #ACCESS_ALLOWED} or {@link\n     * #ACCESS_REJECTED}.\n     * @return Whether the value has been successfully set.\n     * @hide\n     ",
    "links" : [ "#ACCESS_UNKNOWN", "#ACCESS_ALLOWED" ]
  }, {
    "name" : "public int getMessageAccessPermission()",
    "returnType" : "int",
    "comment" : "\n     * Gets whether message access is allowed to this bluetooth device\n     *\n     * @return Whether the message access is allowed to this device.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean setMessageAccessPermission(@AccessPermission int value)",
    "returnType" : "boolean",
    "comment" : "\n     * Sets whether the message access is allowed to this device.\n     *\n     * @param value Can be {@link #ACCESS_UNKNOWN} if the device is unbonded,\n     * {@link #ACCESS_ALLOWED} if the permission is being granted, or {@link #ACCESS_REJECTED} if\n     * the permission is not being granted.\n     * @return Whether the value has been successfully set.\n     * @hide\n     ",
    "links" : [ "#ACCESS_UNKNOWN", "#ACCESS_ALLOWED", "#ACCESS_REJECTED" ]
  }, {
    "name" : "public int getSimAccessPermission()",
    "returnType" : "int",
    "comment" : "\n     * Gets whether sim access is allowed for this bluetooth device\n     *\n     * @return Whether the Sim access is allowed to this device.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean setSimAccessPermission(int value)",
    "returnType" : "boolean",
    "comment" : "\n     * Sets whether the Sim access is allowed to this device.\n     *\n     * @param value Can be {@link #ACCESS_UNKNOWN} if the device is unbonded,\n     * {@link #ACCESS_ALLOWED} if the permission is being granted, or {@link #ACCESS_REJECTED} if\n     * the permission is not being granted.\n     * @return Whether the value has been successfully set.\n     * @hide\n     ",
    "links" : [ "#ACCESS_UNKNOWN", "#ACCESS_ALLOWED", "#ACCESS_REJECTED" ]
  }, {
    "name" : "public BluetoothSocket createRfcommSocket(int channel) throws IOException",
    "returnType" : "BluetoothSocket",
    "comment" : "\n     * Create an RFCOMM {@link BluetoothSocket} ready to start a secure\n     * outgoing connection to this remote device on given channel.\n     * <p>The remote device will be authenticated and communication on this\n     * socket will be encrypted.\n     * <p> Use this socket only if an authenticated socket link is possible.\n     * Authentication refers to the authentication of the link key to\n     * prevent man-in-the-middle type of attacks.\n     * For example, for Bluetooth 2.1 devices, if any of the devices does not\n     * have an input and output capability or just has the ability to\n     * display a numeric key, a secure socket connection is not possible.\n     * In such a case, use {@link createInsecureRfcommSocket}.\n     * For more details, refer to the Security Model section 5.2 (vol 3) of\n     * Bluetooth Core Specification version 2.1 + EDR.\n     * <p>Use {@link BluetoothSocket#connect} to initiate the outgoing\n     * connection.\n     * <p>Valid RFCOMM channels are in range 1 to 30.\n     * <p>Requires {@link android.Manifest.permission#BLUETOOTH}\n     *\n     * @param channel RFCOMM channel to connect to\n     * @return a RFCOMM BluetoothServerSocket ready for an outgoing connection\n     * @throws IOException on error, for example Bluetooth not available, or insufficient\n     * permissions\n     * @hide\n     ",
    "links" : [ "BluetoothSocket", "createInsecureRfcommSocket", "BluetoothSocket#connect", "android.Manifest.permission#BLUETOOTH" ]
  }, {
    "name" : "public BluetoothSocket createL2capSocket(int channel) throws IOException",
    "returnType" : "BluetoothSocket",
    "comment" : "\n     * Create an L2cap {@link BluetoothSocket} ready to start a secure\n     * outgoing connection to this remote device on given channel.\n     * <p>The remote device will be authenticated and communication on this\n     * socket will be encrypted.\n     * <p> Use this socket only if an authenticated socket link is possible.\n     * Authentication refers to the authentication of the link key to\n     * prevent man-in-the-middle type of attacks.\n     * For example, for Bluetooth 2.1 devices, if any of the devices does not\n     * have an input and output capability or just has the ability to\n     * display a numeric key, a secure socket connection is not possible.\n     * In such a case, use {@link createInsecureRfcommSocket}.\n     * For more details, refer to the Security Model section 5.2 (vol 3) of\n     * Bluetooth Core Specification version 2.1 + EDR.\n     * <p>Use {@link BluetoothSocket#connect} to initiate the outgoing\n     * connection.\n     * <p>Valid L2CAP PSM channels are in range 1 to 2^16.\n     * <p>Requires {@link android.Manifest.permission#BLUETOOTH}\n     *\n     * @param channel L2cap PSM/channel to connect to\n     * @return a RFCOMM BluetoothServerSocket ready for an outgoing connection\n     * @throws IOException on error, for example Bluetooth not available, or insufficient\n     * permissions\n     * @hide\n     ",
    "links" : [ "BluetoothSocket", "createInsecureRfcommSocket", "BluetoothSocket#connect", "android.Manifest.permission#BLUETOOTH" ]
  }, {
    "name" : "public BluetoothSocket createInsecureL2capSocket(int channel) throws IOException",
    "returnType" : "BluetoothSocket",
    "comment" : "\n     * Create an L2cap {@link BluetoothSocket} ready to start an insecure\n     * outgoing connection to this remote device on given channel.\n     * <p>The remote device will be not authenticated and communication on this\n     * socket will not be encrypted.\n     * <p>Use {@link BluetoothSocket#connect} to initiate the outgoing\n     * connection.\n     * <p>Valid L2CAP PSM channels are in range 1 to 2^16.\n     * <p>Requires {@link android.Manifest.permission#BLUETOOTH}\n     *\n     * @param channel L2cap PSM/channel to connect to\n     * @return a RFCOMM BluetoothServerSocket ready for an outgoing connection\n     * @throws IOException on error, for example Bluetooth not available, or insufficient\n     * permissions\n     * @hide\n     ",
    "links" : [ "BluetoothSocket", "BluetoothSocket#connect", "android.Manifest.permission#BLUETOOTH" ]
  }, {
    "name" : "public BluetoothSocket createRfcommSocketToServiceRecord(UUID uuid) throws IOException",
    "returnType" : "BluetoothSocket",
    "comment" : "\n     * Create an RFCOMM {@link BluetoothSocket} ready to start a secure\n     * outgoing connection to this remote device using SDP lookup of uuid.\n     * <p>This is designed to be used with {@link\n     * BluetoothAdapter#listenUsingRfcommWithServiceRecord} for peer-peer\n     * Bluetooth applications.\n     * <p>Use {@link BluetoothSocket#connect} to initiate the outgoing\n     * connection. This will also perform an SDP lookup of the given uuid to\n     * determine which channel to connect to.\n     * <p>The remote device will be authenticated and communication on this\n     * socket will be encrypted.\n     * <p> Use this socket only if an authenticated socket link is possible.\n     * Authentication refers to the authentication of the link key to\n     * prevent man-in-the-middle type of attacks.\n     * For example, for Bluetooth 2.1 devices, if any of the devices does not\n     * have an input and output capability or just has the ability to\n     * display a numeric key, a secure socket connection is not possible.\n     * In such a case, use {@link #createInsecureRfcommSocketToServiceRecord}.\n     * For more details, refer to the Security Model section 5.2 (vol 3) of\n     * Bluetooth Core Specification version 2.1 + EDR.\n     * <p>Hint: If you are connecting to a Bluetooth serial board then try\n     * using the well-known SPP UUID 00001101-0000-1000-8000-00805F9B34FB.\n     * However if you are connecting to an Android peer then please generate\n     * your own unique UUID.\n     *\n     * @param uuid service record uuid to lookup RFCOMM channel\n     * @return a RFCOMM BluetoothServerSocket ready for an outgoing connection\n     * @throws IOException on error, for example Bluetooth not available, or insufficient\n     * permissions\n     ",
    "links" : [ "BluetoothSocket", "BluetoothSocket#connect", "#createInsecureRfcommSocketToServiceRecord" ]
  }, {
    "name" : "public BluetoothSocket createInsecureRfcommSocketToServiceRecord(UUID uuid) throws IOException",
    "returnType" : "BluetoothSocket",
    "comment" : "\n     * Create an RFCOMM {@link BluetoothSocket} socket ready to start an insecure\n     * outgoing connection to this remote device using SDP lookup of uuid.\n     * <p> The communication channel will not have an authenticated link key\n     * i.e it will be subject to man-in-the-middle attacks. For Bluetooth 2.1\n     * devices, the link key will be encrypted, as encryption is mandatory.\n     * For legacy devices (pre Bluetooth 2.1 devices) the link key will\n     * be not be encrypted. Use {@link #createRfcommSocketToServiceRecord} if an\n     * encrypted and authenticated communication channel is desired.\n     * <p>This is designed to be used with {@link\n     * BluetoothAdapter#listenUsingInsecureRfcommWithServiceRecord} for peer-peer\n     * Bluetooth applications.\n     * <p>Use {@link BluetoothSocket#connect} to initiate the outgoing\n     * connection. This will also perform an SDP lookup of the given uuid to\n     * determine which channel to connect to.\n     * <p>The remote device will be authenticated and communication on this\n     * socket will be encrypted.\n     * <p>Hint: If you are connecting to a Bluetooth serial board then try\n     * using the well-known SPP UUID 00001101-0000-1000-8000-00805F9B34FB.\n     * However if you are connecting to an Android peer then please generate\n     * your own unique UUID.\n     *\n     * @param uuid service record uuid to lookup RFCOMM channel\n     * @return a RFCOMM BluetoothServerSocket ready for an outgoing connection\n     * @throws IOException on error, for example Bluetooth not available, or insufficient\n     * permissions\n     ",
    "links" : [ "BluetoothSocket", "#createRfcommSocketToServiceRecord", "BluetoothSocket#connect" ]
  }, {
    "name" : "public BluetoothSocket createInsecureRfcommSocket(int port) throws IOException",
    "returnType" : "BluetoothSocket",
    "comment" : "\n     * Construct an insecure RFCOMM socket ready to start an outgoing\n     * connection.\n     * Call #connect on the returned #BluetoothSocket to begin the connection.\n     * The remote device will not be authenticated and communication on this\n     * socket will not be encrypted.\n     * <p>Requires {@link android.Manifest.permission#BLUETOOTH_ADMIN}\n     *\n     * @param port remote port\n     * @return An RFCOMM BluetoothSocket\n     * @throws IOException On error, for example Bluetooth not available, or insufficient\n     * permissions.\n     * @hide\n     ",
    "links" : [ "android.Manifest.permission#BLUETOOTH_ADMIN" ]
  }, {
    "name" : "public BluetoothSocket createScoSocket() throws IOException",
    "returnType" : "BluetoothSocket",
    "comment" : "\n     * Construct a SCO socket ready to start an outgoing connection.\n     * Call #connect on the returned #BluetoothSocket to begin the connection.\n     * <p>Requires {@link android.Manifest.permission#BLUETOOTH_ADMIN}\n     *\n     * @return a SCO BluetoothSocket\n     * @throws IOException on error, for example Bluetooth not available, or insufficient\n     * permissions.\n     * @hide\n     ",
    "links" : [ "android.Manifest.permission#BLUETOOTH_ADMIN" ]
  }, {
    "name" : "public static byte[] convertPinToBytes(String pin)",
    "returnType" : "byte[]",
    "comment" : "\n     * Check that a pin is valid and convert to byte array.\n     *\n     * Bluetooth pin's are 1 to 16 bytes of UTF-8 characters.\n     *\n     * @param pin pin as java String\n     * @return the pin code as a UTF-8 byte array, or null if it is an invalid Bluetooth pin.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public BluetoothGatt connectGatt(Context context, boolean autoConnect, BluetoothGattCallback callback)",
    "returnType" : "BluetoothGatt",
    "comment" : "\n     * Connect to GATT Server hosted by this device. Caller acts as GATT client.\n     * The callback is used to deliver results to Caller, such as connection status as well\n     * as any further GATT client operations.\n     * The method returns a BluetoothGatt instance. You can use BluetoothGatt to conduct\n     * GATT client operations.\n     *\n     * @param callback GATT callback handler that will receive asynchronous callbacks.\n     * @param autoConnect Whether to directly connect to the remote device (false) or to\n     * automatically connect as soon as the remote device becomes available (true).\n     * @throws IllegalArgumentException if callback is null\n     ",
    "links" : [ ]
  }, {
    "name" : "public BluetoothGatt connectGatt(Context context, boolean autoConnect, BluetoothGattCallback callback, int transport)",
    "returnType" : "BluetoothGatt",
    "comment" : "\n     * Connect to GATT Server hosted by this device. Caller acts as GATT client.\n     * The callback is used to deliver results to Caller, such as connection status as well\n     * as any further GATT client operations.\n     * The method returns a BluetoothGatt instance. You can use BluetoothGatt to conduct\n     * GATT client operations.\n     *\n     * @param callback GATT callback handler that will receive asynchronous callbacks.\n     * @param autoConnect Whether to directly connect to the remote device (false) or to\n     * automatically connect as soon as the remote device becomes available (true).\n     * @param transport preferred transport for GATT connections to remote dual-mode devices {@link\n     * BluetoothDevice#TRANSPORT_AUTO} or {@link BluetoothDevice#TRANSPORT_BREDR} or {@link\n     * BluetoothDevice#TRANSPORT_LE}\n     * @throws IllegalArgumentException if callback is null\n     ",
    "links" : [ "BluetoothDevice#TRANSPORT_BREDR" ]
  }, {
    "name" : "public BluetoothGatt connectGatt(Context context, boolean autoConnect, BluetoothGattCallback callback, int transport, int phy)",
    "returnType" : "BluetoothGatt",
    "comment" : "\n     * Connect to GATT Server hosted by this device. Caller acts as GATT client.\n     * The callback is used to deliver results to Caller, such as connection status as well\n     * as any further GATT client operations.\n     * The method returns a BluetoothGatt instance. You can use BluetoothGatt to conduct\n     * GATT client operations.\n     *\n     * @param callback GATT callback handler that will receive asynchronous callbacks.\n     * @param autoConnect Whether to directly connect to the remote device (false) or to\n     * automatically connect as soon as the remote device becomes available (true).\n     * @param transport preferred transport for GATT connections to remote dual-mode devices {@link\n     * BluetoothDevice#TRANSPORT_AUTO} or {@link BluetoothDevice#TRANSPORT_BREDR} or {@link\n     * BluetoothDevice#TRANSPORT_LE}\n     * @param phy preferred PHY for connections to remote LE device. Bitwise OR of any of {@link\n     * BluetoothDevice#PHY_LE_1M_MASK}, {@link BluetoothDevice#PHY_LE_2M_MASK}, and {@link\n     * BluetoothDevice#PHY_LE_CODED_MASK}. This option does not take effect if {@code autoConnect}\n     * is set to true.\n     * @throws NullPointerException if callback is null\n     ",
    "links" : [ "BluetoothDevice#TRANSPORT_BREDR", "BluetoothDevice#PHY_LE_2M_MASK" ]
  }, {
    "name" : "public BluetoothGatt connectGatt(Context context, boolean autoConnect, BluetoothGattCallback callback, int transport, int phy, Handler handler)",
    "returnType" : "BluetoothGatt",
    "comment" : "\n     * Connect to GATT Server hosted by this device. Caller acts as GATT client.\n     * The callback is used to deliver results to Caller, such as connection status as well\n     * as any further GATT client operations.\n     * The method returns a BluetoothGatt instance. You can use BluetoothGatt to conduct\n     * GATT client operations.\n     *\n     * @param callback GATT callback handler that will receive asynchronous callbacks.\n     * @param autoConnect Whether to directly connect to the remote device (false) or to\n     * automatically connect as soon as the remote device becomes available (true).\n     * @param transport preferred transport for GATT connections to remote dual-mode devices {@link\n     * BluetoothDevice#TRANSPORT_AUTO} or {@link BluetoothDevice#TRANSPORT_BREDR} or {@link\n     * BluetoothDevice#TRANSPORT_LE}\n     * @param phy preferred PHY for connections to remote LE device. Bitwise OR of any of {@link\n     * BluetoothDevice#PHY_LE_1M_MASK}, {@link BluetoothDevice#PHY_LE_2M_MASK}, an d{@link\n     * BluetoothDevice#PHY_LE_CODED_MASK}. This option does not take effect if {@code autoConnect}\n     * is set to true.\n     * @param handler The handler to use for the callback. If {@code null}, callbacks will happen on\n     * an un-specified background thread.\n     * @throws NullPointerException if callback is null\n     ",
    "links" : [ "BluetoothDevice#TRANSPORT_BREDR", "BluetoothDevice#PHY_LE_2M_MASK" ]
  }, {
    "name" : "public BluetoothGatt connectGatt(Context context, boolean autoConnect, BluetoothGattCallback callback, int transport, boolean opportunistic, int phy, Handler handler)",
    "returnType" : "BluetoothGatt",
    "comment" : "\n     * Connect to GATT Server hosted by this device. Caller acts as GATT client.\n     * The callback is used to deliver results to Caller, such as connection status as well\n     * as any further GATT client operations.\n     * The method returns a BluetoothGatt instance. You can use BluetoothGatt to conduct\n     * GATT client operations.\n     *\n     * @param callback GATT callback handler that will receive asynchronous callbacks.\n     * @param autoConnect Whether to directly connect to the remote device (false) or to\n     * automatically connect as soon as the remote device becomes available (true).\n     * @param transport preferred transport for GATT connections to remote dual-mode devices {@link\n     * BluetoothDevice#TRANSPORT_AUTO} or {@link BluetoothDevice#TRANSPORT_BREDR} or {@link\n     * BluetoothDevice#TRANSPORT_LE}\n     * @param opportunistic Whether this GATT client is opportunistic. An opportunistic GATT client\n     * does not hold a GATT connection. It automatically disconnects when no other GATT connections\n     * are active for the remote device.\n     * @param phy preferred PHY for connections to remote LE device. Bitwise OR of any of {@link\n     * BluetoothDevice#PHY_LE_1M_MASK}, {@link BluetoothDevice#PHY_LE_2M_MASK}, an d{@link\n     * BluetoothDevice#PHY_LE_CODED_MASK}. This option does not take effect if {@code autoConnect}\n     * is set to true.\n     * @param handler The handler to use for the callback. If {@code null}, callbacks will happen on\n     * an un-specified background thread.\n     * @return A BluetoothGatt instance. You can use BluetoothGatt to conduct GATT client\n     * operations.\n     * @hide\n     ",
    "links" : [ "BluetoothDevice#TRANSPORT_BREDR", "BluetoothDevice#PHY_LE_2M_MASK" ]
  }, {
    "name" : "public BluetoothSocket createL2capChannel(int psm) throws IOException",
    "returnType" : "BluetoothSocket",
    "comment" : "\n     * Create a Bluetooth L2CAP Connection-oriented Channel (CoC) {@link BluetoothSocket} that can\n     * be used to start a secure outgoing connection to the remote device with the same dynamic\n     * protocol/service multiplexer (PSM) value. The supported Bluetooth transport is LE only.\n     * <p>This is designed to be used with {@link BluetoothAdapter#listenUsingL2capChannel()} for\n     * peer-peer Bluetooth applications.\n     * <p>Use {@link BluetoothSocket#connect} to initiate the outgoing connection.\n     * <p>Application using this API is responsible for obtaining PSM value from remote device.\n     * <p>The remote device will be authenticated and communication on this socket will be\n     * encrypted.\n     * <p> Use this socket if an authenticated socket link is possible. Authentication refers\n     * to the authentication of the link key to prevent man-in-the-middle type of attacks.\n     *\n     * @param psm dynamic PSM value from remote device\n     * @return a CoC #BluetoothSocket ready for an outgoing connection\n     * @throws IOException on error, for example Bluetooth not available, or insufficient\n     * permissions\n     ",
    "links" : [ "BluetoothSocket", "BluetoothAdapter#listenUsingL2capChannel", "BluetoothSocket#connect" ]
  }, {
    "name" : "public BluetoothSocket createInsecureL2capChannel(int psm) throws IOException",
    "returnType" : "BluetoothSocket",
    "comment" : "\n     * Create a Bluetooth L2CAP Connection-oriented Channel (CoC) {@link BluetoothSocket} that can\n     * be used to start a secure outgoing connection to the remote device with the same dynamic\n     * protocol/service multiplexer (PSM) value. The supported Bluetooth transport is LE only.\n     * <p>This is designed to be used with {@link\n     * BluetoothAdapter#listenUsingInsecureL2capChannel()} for peer-peer Bluetooth applications.\n     * <p>Use {@link BluetoothSocket#connect} to initiate the outgoing connection.\n     * <p>Application using this API is responsible for obtaining PSM value from remote device.\n     * <p> The communication channel may not have an authenticated link key, i.e. it may be subject\n     * to man-in-the-middle attacks. Use {@link #createL2capChannel(int)} if an encrypted and\n     * authenticated communication channel is possible.\n     *\n     * @param psm dynamic PSM value from remote device\n     * @return a CoC #BluetoothSocket ready for an outgoing connection\n     * @throws IOException on error, for example Bluetooth not available, or insufficient\n     * permissions\n     ",
    "links" : [ "BluetoothSocket", "BluetoothSocket#connect", "#createL2capChannel" ]
  }, {
    "name" : "public boolean setMetadata(int key, @NonNull byte[] value)",
    "returnType" : "boolean",
    "comment" : "\n     * Set a keyed metadata of this {@link BluetoothDevice} to a\n     * {@link String} value.\n     * Only bonded devices's metadata will be persisted across Bluetooth\n     * restart.\n     * Metadata will be removed when the device's bond state is moved to\n     * {@link #BOND_NONE}.\n     *\n     * @param key must be within the list of BluetoothDevice.METADATA_*\n     * @param value a byte array data to set for key. Must be less than\n     * {@link BluetoothAdapter#METADATA_MAX_LENGTH} characters in length\n     * @return true on success, false on error\n     * @hide\n    ",
    "links" : [ "BluetoothDevice", "String", "#BOND_NONE", "BluetoothAdapter#METADATA_MAX_LENGTH" ]
  }, {
    "name" : "public byte[] getMetadata(int key)",
    "returnType" : "byte[]",
    "comment" : "\n     * Get a keyed metadata for this {@link BluetoothDevice} as {@link String}\n     *\n     * @param key must be within the list of BluetoothDevice.METADATA_*\n     * @return Metadata of the key as byte array, null on error or not found\n     * @hide\n     ",
    "links" : [ "BluetoothDevice", "String" ]
  } ],
  "variableNames" : [ "TAG", "DBG", "CONNECTION_STATE_DISCONNECTED", "CONNECTION_STATE_CONNECTED", "CONNECTION_STATE_ENCRYPTED_BREDR", "CONNECTION_STATE_ENCRYPTED_LE", "ERROR", "ACTION_FOUND", "ACTION_CLASS_CHANGED", "ACTION_ACL_CONNECTED", "ACTION_ACL_DISCONNECT_REQUESTED", "ACTION_ACL_DISCONNECTED", "ACTION_NAME_CHANGED", "ACTION_ALIAS_CHANGED", "ACTION_BOND_STATE_CHANGED", "ACTION_BATTERY_LEVEL_CHANGED", "EXTRA_BATTERY_LEVEL", "BATTERY_LEVEL_UNKNOWN", "BATTERY_LEVEL_BLUETOOTH_OFF", "EXTRA_DEVICE", "EXTRA_NAME", "EXTRA_RSSI", "EXTRA_CLASS", "EXTRA_BOND_STATE", "EXTRA_PREVIOUS_BOND_STATE", "BOND_NONE", "BOND_BONDING", "BOND_BONDED", "EXTRA_REASON", "EXTRA_PAIRING_VARIANT", "EXTRA_PAIRING_KEY", "DEVICE_TYPE_UNKNOWN", "DEVICE_TYPE_CLASSIC", "DEVICE_TYPE_LE", "DEVICE_TYPE_DUAL", "ACTION_SDP_RECORD", "METADATA_MAX_LENGTH", "METADATA_MANUFACTURER_NAME", "METADATA_MODEL_NAME", "METADATA_SOFTWARE_VERSION", "METADATA_HARDWARE_VERSION", "METADATA_COMPANION_APP", "METADATA_MAIN_ICON", "METADATA_IS_UNTETHERED_HEADSET", "METADATA_UNTETHERED_LEFT_ICON", "METADATA_UNTETHERED_RIGHT_ICON", "METADATA_UNTETHERED_CASE_ICON", "METADATA_UNTETHERED_LEFT_BATTERY", "METADATA_UNTETHERED_RIGHT_BATTERY", "METADATA_UNTETHERED_CASE_BATTERY", "METADATA_UNTETHERED_LEFT_CHARGING", "METADATA_UNTETHERED_RIGHT_CHARGING", "METADATA_UNTETHERED_CASE_CHARGING", "METADATA_ENHANCED_SETTINGS_UI_URI", "ACTION_UUID", "ACTION_MAS_INSTANCE", "ACTION_NAME_FAILED", "ACTION_PAIRING_REQUEST", "ACTION_PAIRING_CANCEL", "ACTION_CONNECTION_ACCESS_REQUEST", "ACTION_CONNECTION_ACCESS_REPLY", "ACTION_CONNECTION_ACCESS_CANCEL", "ACTION_SILENCE_MODE_CHANGED", "EXTRA_ACCESS_REQUEST_TYPE", "REQUEST_TYPE_PROFILE_CONNECTION", "REQUEST_TYPE_PHONEBOOK_ACCESS", "REQUEST_TYPE_MESSAGE_ACCESS", "REQUEST_TYPE_SIM_ACCESS", "EXTRA_PACKAGE_NAME", "EXTRA_CLASS_NAME", "EXTRA_CONNECTION_ACCESS_RESULT", "CONNECTION_ACCESS_YES", "CONNECTION_ACCESS_NO", "EXTRA_ALWAYS_ALLOWED", "BOND_SUCCESS", "UNBOND_REASON_AUTH_FAILED", "UNBOND_REASON_AUTH_REJECTED", "UNBOND_REASON_AUTH_CANCELED", "UNBOND_REASON_REMOTE_DEVICE_DOWN", "UNBOND_REASON_DISCOVERY_IN_PROGRESS", "UNBOND_REASON_AUTH_TIMEOUT", "UNBOND_REASON_REPEATED_ATTEMPTS", "UNBOND_REASON_REMOTE_AUTH_CANCELED", "UNBOND_REASON_REMOVED", "PAIRING_VARIANT_PIN", "PAIRING_VARIANT_PASSKEY", "PAIRING_VARIANT_PASSKEY_CONFIRMATION", "PAIRING_VARIANT_CONSENT", "PAIRING_VARIANT_DISPLAY_PASSKEY", "PAIRING_VARIANT_DISPLAY_PIN", "PAIRING_VARIANT_OOB_CONSENT", "PAIRING_VARIANT_PIN_16_DIGITS", "EXTRA_UUID", "EXTRA_SDP_RECORD", "EXTRA_SDP_SEARCH_STATUS", "ACCESS_UNKNOWN", "ACCESS_ALLOWED", "ACCESS_REJECTED", "TRANSPORT_AUTO", "TRANSPORT_BREDR", "TRANSPORT_LE", "PHY_LE_1M", "PHY_LE_2M", "PHY_LE_CODED", "PHY_LE_1M_MASK", "PHY_LE_2M_MASK", "PHY_LE_CODED_MASK", "PHY_OPTION_NO_PREFERRED", "PHY_OPTION_S2", "PHY_OPTION_S8", "EXTRA_MAS_INSTANCE", "sService", "mAddress", "sStateChangeCallback", "CREATOR", "BLUETOOTH_BONDING_CACHE_PROPERTY", "mBluetoothBondCache" ],
  "methodNames" : [ " static IBluetooth getService()", "public boolean equals(Object o)", "public int hashCode()", "public String toString()", "public int describeContents()", "public void writeToParcel(Parcel out, int flags)", "public String getAddress()", "public String getName()", "public int getType()", "public String getAlias()", "public boolean setAlias(@NonNull String alias)", "public int getBatteryLevel()", "public boolean createBond()", "public boolean createBond(int transport)", "public boolean createBondOutOfBand(int transport, OobData oobData)", "public boolean isBondingInitiatedLocally()", "public boolean setDeviceOutOfBandData(byte[] hash, byte[] randomizer)", "public boolean cancelBondProcess()", "public boolean removeBond()", "public void disableBluetoothGetBondStateCache()", "public static void invalidateBluetoothGetBondStateCache()", "public int getBondState()", "public boolean isConnected()", "public boolean isEncrypted()", "public BluetoothClass getBluetoothClass()", "public ParcelUuid[] getUuids()", "public boolean fetchUuidsWithSdp()", "public boolean sdpSearch(ParcelUuid uuid)", "public boolean setPin(byte[] pin)", "public boolean setPin(@NonNull String pin)", "public boolean setPairingConfirmation(boolean confirm)", "public boolean cancelPairing()", " boolean isBluetoothEnabled()", "public int getPhonebookAccessPermission()", "public boolean setSilenceMode(boolean silence)", "public boolean isInSilenceMode()", "public boolean setPhonebookAccessPermission(@AccessPermission int value)", "public int getMessageAccessPermission()", "public boolean setMessageAccessPermission(@AccessPermission int value)", "public int getSimAccessPermission()", "public boolean setSimAccessPermission(int value)", "public BluetoothSocket createRfcommSocket(int channel) throws IOException", "public BluetoothSocket createL2capSocket(int channel) throws IOException", "public BluetoothSocket createInsecureL2capSocket(int channel) throws IOException", "public BluetoothSocket createRfcommSocketToServiceRecord(UUID uuid) throws IOException", "public BluetoothSocket createInsecureRfcommSocketToServiceRecord(UUID uuid) throws IOException", "public BluetoothSocket createInsecureRfcommSocket(int port) throws IOException", "public BluetoothSocket createScoSocket() throws IOException", "public static byte[] convertPinToBytes(String pin)", "public BluetoothGatt connectGatt(Context context, boolean autoConnect, BluetoothGattCallback callback)", "public BluetoothGatt connectGatt(Context context, boolean autoConnect, BluetoothGattCallback callback, int transport)", "public BluetoothGatt connectGatt(Context context, boolean autoConnect, BluetoothGattCallback callback, int transport, int phy)", "public BluetoothGatt connectGatt(Context context, boolean autoConnect, BluetoothGattCallback callback, int transport, int phy, Handler handler)", "public BluetoothGatt connectGatt(Context context, boolean autoConnect, BluetoothGattCallback callback, int transport, boolean opportunistic, int phy, Handler handler)", "public BluetoothSocket createL2capChannel(int psm) throws IOException", "public BluetoothSocket createInsecureL2capChannel(int psm) throws IOException", "public boolean setMetadata(int key, @NonNull byte[] value)", "public byte[] getMetadata(int key)" ]
}