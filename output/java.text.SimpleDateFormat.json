{
  "filePath" : "/home/maryam/clearblue/files/android-source-35/java/text/SimpleDateFormat.java",
  "packageName" : "java.text",
  "className" : "SimpleDateFormat",
  "comment" : "\n * {@code SimpleDateFormat} is a concrete class for formatting and\n * parsing dates in a locale-sensitive manner. It allows for formatting\n * (date &rarr; text), parsing (text &rarr; date), and normalization.\n *\n * <p>\n * {@code SimpleDateFormat} allows you to start by choosing\n * any user-defined patterns for date-time formatting. However, you\n * are encouraged to create a date-time formatter with either\n * {@code getTimeInstance}, {@code getDateInstance}, or\n * {@code getDateTimeInstance} in {@code DateFormat}. Each\n * of these class methods can return a date/time formatter initialized\n * with a default format pattern. You may modify the format pattern\n * using the {@code applyPattern} methods as desired.\n * For more information on using these methods, see\n * {@link DateFormat}.\n *\n * <h2>Date and Time Patterns</h2>\n * <p>\n * Date and time formats are specified by <em>date and time pattern</em>\n * strings.\n * Within date and time pattern strings, unquoted letters from\n * {@code 'A'} to {@code 'Z'} and from {@code 'a'} to\n * {@code 'z'} are interpreted as pattern letters representing the\n * components of a date or time string.\n * Text can be quoted using single quotes ({@code '}) to avoid\n * interpretation.\n * {@code \"''\"} represents a single quote.\n * All other characters are not interpreted; they're simply copied into the\n * output string during formatting or matched against the input string\n * during parsing.\n * <p>\n * The following pattern letters are defined (all other characters from\n * {@code 'A'} to {@code 'Z'} and from {@code 'a'} to\n * {@code 'z'} are reserved):\n * <blockquote>\n * <table class=\"striped\">\n * <caption style=\"display:none\">Chart shows pattern letters, date/time component, presentation, and examples.</caption>\n * <thead>\n *     <tr>\n *         <th scope=\"col\" style=\"text-align:left\">Letter\n *         <th scope=\"col\" style=\"text-align:left\">Date or Time Component\n *         <th scope=\"col\" style=\"text-align:left\">Presentation\n *         <th scope=\"col\" style=\"text-align:left\">Examples\n *         <th scope=\"col\" style=\"text-align:left\">Supported (API Levels)\n * </thead>\n * <tbody>\n *     <tr>\n *         <th scope=\"row\">{@code G}\n *         <td>Era designator\n *         <td><a href=\"#text\">Text</a>\n *         <td>{@code AD}\n *         <td>1+</td>\n *     <tr>\n *         <th scope=\"row\">{@code y}\n *         <td>Year\n *         <td><a href=\"#year\">Year</a>\n *         <td>{@code 1996}; {@code 96}\n *         <td>1+</td>\n *     <tr>\n *         <th scope=\"row\">{@code Y}\n *         <td>Week year\n *         <td><a href=\"#year\">Year</a>\n *         <td>{@code 2009}; {@code 09}\n *         <td>24+</td>\n *     <tr>\n *         <th scope=\"row\">{@code M}\n *         <td>Month in year (context sensitive)\n *         <td><a href=\"#month\">Month</a>\n *         <td>{@code July}; {@code Jul}; {@code 07}\n *         <td>1+</td>\n *     <tr>\n *         <th scope=\"row\">{@code L}\n *         <td>Month in year (standalone form)\n *         <td><a href=\"#month\">Month</a>\n *         <td>{@code July}; {@code Jul}; {@code 07}\n *         <td>TBD</td>\n *     <tr>\n *         <th scope=\"row\">{@code w}\n *         <td>Week in year\n *         <td><a href=\"#number\">Number</a>\n *         <td>{@code 27}\n *         <td>1+</td>\n *     <tr>\n *         <th scope=\"row\">{@code W}\n *         <td>Week in month\n *         <td><a href=\"#number\">Number</a>\n *         <td>{@code 2}\n *         <td>1+</td>\n *     <tr>\n *         <th scope=\"row\">{@code D}\n *         <td>Day in year\n *         <td><a href=\"#number\">Number</a>\n *         <td>{@code 189}\n *         <td>1+</td>\n *     <tr>\n *         <th scope=\"row\">{@code d}\n *         <td>Day in month\n *         <td><a href=\"#number\">Number</a>\n *         <td>{@code 10}\n *         <td>1+</td>\n *     <tr>\n *         <th scope=\"row\">{@code F}\n *         <td>Day of week in month\n *         <td><a href=\"#number\">Number</a>\n *         <td>{@code 2}\n *         <td>1+</td>\n *     <tr>\n *         <th scope=\"row\">{@code E}\n *         <td>Day name in week\n *         <td><a href=\"#text\">Text</a>\n *         <td>{@code Tuesday}; {@code Tue}\n *         <td>1+</td>\n *     <tr>\n *         <th scope=\"row\">{@code u}\n *         <td>Day number of week (1 = Monday, ..., 7 = Sunday)\n *         <td><a href=\"#number\">Number</a>\n *         <td>{@code 1}\n *         <td>24+</td>\n *     <tr>\n *         <th scope=\"row\">{@code a}\n *         <td>Am/pm marker\n *         <td><a href=\"#text\">Text</a>\n *         <td>{@code PM}\n *         <td>1+</td>\n *     <tr>\n *         <th scope=\"row\">{@code H}\n *         <td>Hour in day (0-23)\n *         <td><a href=\"#number\">Number</a>\n *         <td>{@code 0}\n *         <td>1+</td>\n *     <tr>\n *         <th scope=\"row\">{@code k}\n *         <td>Hour in day (1-24)\n *         <td><a href=\"#number\">Number</a>\n *         <td>{@code 24}\n *         <td>1+</td>\n *     <tr>\n *         <th scope=\"row\">{@code K}\n *         <td>Hour in am/pm (0-11)\n *         <td><a href=\"#number\">Number</a>\n *         <td>{@code 0}\n *         <td>1+</td>\n *     <tr>\n *         <th scope=\"row\">{@code h}\n *         <td>Hour in am/pm (1-12)\n *         <td><a href=\"#number\">Number</a>\n *         <td>{@code 12}\n *         <td>1+</td>\n *     <tr>\n *         <th scope=\"row\">{@code m}\n *         <td>Minute in hour\n *         <td><a href=\"#number\">Number</a>\n *         <td>{@code 30}\n *         <td>1+</td>\n *     <tr>\n *         <th scope=\"row\">{@code s}\n *         <td>Second in minute\n *         <td><a href=\"#number\">Number</a>\n *         <td>{@code 55}\n *         <td>1+</td>\n *     <tr>\n *         <th scope=\"row\">{@code S}\n *         <td>Millisecond\n *         <td><a href=\"#number\">Number</a>\n *         <td>{@code 978}\n *         <td>1+</td>\n *     <tr>\n *         <th scope=\"row\">{@code z}\n *         <td>Time zone\n *         <td><a href=\"#timezone\">General time zone</a>\n *         <td>{@code Pacific Standard Time}; {@code PST}; {@code GMT-08:00}\n *         <td>1+</td>\n *     <tr>\n *         <th scope=\"row\">{@code Z}\n *         <td>Time zone\n *         <td><a href=\"#rfc822timezone\">RFC 822 time zone</a>\n *         <td>{@code -0800}\n *         <td>1+</td>\n *     <tr>\n *         <th scope=\"row\">{@code X}\n *         <td>Time zone\n *         <td><a href=\"#iso8601timezone\">ISO 8601 time zone</a>\n *         <td>{@code -08}; {@code -0800};  {@code -08:00}\n *         <td>24+</td>\n * </tbody>\n * </table>\n * </blockquote>\n * Pattern letters are usually repeated, as their number determines the\n * exact presentation:\n * <ul>\n * <li><strong><a id=\"text\">Text:</a></strong>\n *     For formatting, if the number of pattern letters is 4 or more,\n *     the full form is used; otherwise a short or abbreviated form\n *     is used if available.\n *     For parsing, both forms are accepted, independent of the number\n *     of pattern letters.</li>\n * <li><strong><a id=\"number\">Number:</a></strong>\n *     For formatting, the number of pattern letters is the minimum\n *     number of digits, and shorter numbers are zero-padded to this amount.\n *     For parsing, the number of pattern letters is ignored unless\n *     it's needed to separate two adjacent fields.</li>\n * <li><strong><a id=\"year\">Year:</a></strong>\n *     If the formatter's {@link #getCalendar() Calendar} is the Gregorian\n *     calendar, the following rules are applied.\n *     <ul>\n *     <li>For formatting, if the number of pattern letters is 2, the year\n *         is truncated to 2 digits; otherwise it is interpreted as a\n *         <a href=\"#number\">number</a>.\n *     <li>For parsing, if the number of pattern letters is more than 2,\n *         the year is interpreted literally, regardless of the number of\n *         digits. So using the pattern \"MM/dd/yyyy\", \"01/11/12\" parses to\n *         Jan 11, 12 A.D.\n *     <li>For parsing with the abbreviated year pattern (\"y\" or \"yy\"),\n *         {@code SimpleDateFormat} must interpret the abbreviated year\n *         relative to some century.  It does this by adjusting dates to be\n *         within 80 years before and 20 years after the time the {@code SimpleDateFormat}\n *         instance is created. For example, using a pattern of \"MM/dd/yy\" and a\n *         {@code SimpleDateFormat} instance created on Jan 1, 1997,  the string\n *         \"01/11/12\" would be interpreted as Jan 11, 2012 while the string \"05/04/64\"\n *         would be interpreted as May 4, 1964.\n *         During parsing, only strings consisting of exactly two digits, as defined by\n *         {@link Character#isDigit(char)}, will be parsed into the default century.\n *         Any other numeric string, such as a one digit string, a three or more digit\n *         string, or a two digit string that isn't all digits (for example, \"-1\"), is\n *         interpreted literally.  So \"01/02/3\" or \"01/02/003\" are parsed, using the\n *         same pattern, as Jan 2, 3 AD.  Likewise, \"01/02/-3\" is parsed as Jan 2, 4 BC.\n *     </ul>\n *     Otherwise, calendar system specific forms are applied.\n *     For both formatting and parsing, if the number of pattern\n *     letters is 4 or more, a calendar specific {@linkplain\n *     Calendar#LONG long form} is used. Otherwise, a calendar\n *     specific {@linkplain Calendar#SHORT short or abbreviated form}\n *     is used.\n *     <br>\n *     If week year {@code 'Y'} is specified and the {@linkplain\n *     #getCalendar() calendar} doesn't support any <a\n *     href=\"../util/GregorianCalendar.html#week_year\"> week\n *     years</a>, the calendar year ({@code 'y'}) is used instead. The\n *     support of week years can be tested with a call to {@link\n *     DateFormat#getCalendar() getCalendar()}.{@link\n *     java.util.Calendar#isWeekDateSupported()\n *     isWeekDateSupported()}.</li>\n * <li><strong><a id=\"month\">Month:</a></strong>\n *     If the number of pattern letters is 3 or more, the month is\n *     interpreted as <a href=\"#text\">text</a>; otherwise,\n *     it is interpreted as a <a href=\"#number\">number</a>.\n *     <ul>\n *     <li>Letter <em>M</em> produces context-sensitive month names, such as the\n *         embedded form of names. Letter <em>M</em> is context-sensitive in the\n *         sense that when it is used in the standalone pattern, for example,\n *         \"MMMM\", it gives the standalone form of a month name and when it is\n *         used in the pattern containing other field(s), for example, \"d MMMM\",\n *         it gives the format form of a month name. For example, January in the\n *         Catalan language is \"de gener\" in the format form while it is \"gener\"\n *         in the standalone form. In this case, \"MMMM\" will produce \"gener\" and\n *         the month part of the \"d MMMM\" will produce \"de gener\". If a\n *         {@code DateFormatSymbols} has been set explicitly with constructor\n *         {@link #SimpleDateFormat(String,DateFormatSymbols)} or method {@link\n *         #setDateFormatSymbols(DateFormatSymbols)}, the month names given by\n *         the {@code DateFormatSymbols} are used.</li>\n *     <li>Letter <em>L</em> produces the standalone form of month names.</li>\n *     </ul>\n *     <br></li>\n * <li><strong><a id=\"timezone\">General time zone:</a></strong>\n *     Time zones are interpreted as <a href=\"#text\">text</a> if they have\n *     names. For time zones representing a GMT offset value, the\n *     following syntax is used:\n *     <pre>\n *     <a id=\"GMTOffsetTimeZone\"><i>GMTOffsetTimeZone:</i></a>\n *             {@code GMT} <i>Sign</i> <i>Hours</i> {@code :} <i>Minutes</i>\n *     <i>Sign:</i> one of\n *             {@code + -}\n *     <i>Hours:</i>\n *             <i>Digit</i>\n *             <i>Digit</i> <i>Digit</i>\n *     <i>Minutes:</i>\n *             <i>Digit</i> <i>Digit</i>\n *     <i>Digit:</i> one of\n *             {@code 0 1 2 3 4 5 6 7 8 9}</pre>\n *     <i>Hours</i> must be between 0 and 23, and <i>Minutes</i> must be between\n *     00 and 59. The format is locale independent and digits must be taken\n *     from the Basic Latin block of the Unicode standard.\n *     <p>For parsing, <a href=\"#rfc822timezone\">RFC 822 time zones</a> are also\n *     accepted.</li>\n * <li><strong><a id=\"rfc822timezone\">RFC 822 time zone:</a></strong>\n *     For formatting, the RFC 822 4-digit time zone format is used:\n *\n *     <pre>\n *     <i>RFC822TimeZone:</i>\n *             <i>Sign</i> <i>TwoDigitHours</i> <i>Minutes</i>\n *     <i>TwoDigitHours:</i>\n *             <i>Digit Digit</i></pre>\n *     <i>TwoDigitHours</i> must be between 00 and 23. Other definitions\n *     are as for <a href=\"#timezone\">general time zones</a>.\n *\n *     <p>For parsing, <a href=\"#timezone\">general time zones</a> are also\n *     accepted.\n * <li><strong><a id=\"iso8601timezone\">ISO 8601 Time zone:</a></strong>\n *     The number of pattern letters designates the format for both formatting\n *     and parsing as follows:\n *     <pre>\n *     <i>ISO8601TimeZone:</i>\n *             <i>OneLetterISO8601TimeZone</i>\n *             <i>TwoLetterISO8601TimeZone</i>\n *             <i>ThreeLetterISO8601TimeZone</i>\n *     <i>OneLetterISO8601TimeZone:</i>\n *             <i>Sign</i> <i>TwoDigitHours</i>\n *             {@code Z}\n *     <i>TwoLetterISO8601TimeZone:</i>\n *             <i>Sign</i> <i>TwoDigitHours</i> <i>Minutes</i>\n *             {@code Z}\n *     <i>ThreeLetterISO8601TimeZone:</i>\n *             <i>Sign</i> <i>TwoDigitHours</i> {@code :} <i>Minutes</i>\n *             {@code Z}</pre>\n *     Other definitions are as for <a href=\"#timezone\">general time zones</a> or\n *     <a href=\"#rfc822timezone\">RFC 822 time zones</a>.\n *\n *     <p>For formatting, if the offset value from GMT is 0, {@code \"Z\"} is\n *     produced. If the number of pattern letters is 1, any fraction of an hour\n *     is ignored. For example, if the pattern is {@code \"X\"} and the time zone is\n *     {@code \"GMT+05:30\"}, {@code \"+05\"} is produced.\n *\n *     <p>For parsing, the letter {@code \"Z\"} is parsed as the UTC time zone designator (therefore\n *     {@code \"09:30Z\"} is parsed as {@code \"09:30 UTC\"}.\n *     <a href=\"#timezone\">General time zones</a> are <em>not</em> accepted.\n *     <p>If the number of {@code \"X\"} pattern letters is 4 or more (e.g. {@code XXXX}), {@link\n *     IllegalArgumentException} is thrown when constructing a {@code\n *     SimpleDateFormat} or {@linkplain #applyPattern(String) applying a\n *     pattern}.\n * </ul>\n * {@code SimpleDateFormat} also supports <em>localized date and time\n * pattern</em> strings. In these strings, the pattern letters described above\n * may be replaced with other, locale dependent, pattern letters.\n * {@code SimpleDateFormat} does not deal with the localization of text\n * other than the pattern letters; that's up to the client of the class.\n *\n * <h3>Examples</h3>\n *\n * The following examples show how date and time patterns are interpreted in\n * the U.S. locale. The given date and time are 2001-07-04 12:08:56 local time\n * in the U.S. Pacific Time time zone.\n * <blockquote>\n * <table class=\"striped\">\n * <caption style=\"display:none\">Examples of date and time patterns interpreted in the U.S. locale</caption>\n * <thead>\n *     <tr>\n *         <th scope=\"col\" style=\"text-align:left\">Date and Time Pattern\n *         <th scope=\"col\" style=\"text-align:left\">Result\n * </thead>\n * <tbody>\n *     <tr>\n *         <th scope=\"row\">{@code \"yyyy.MM.dd G 'at' HH:mm:ss z\"}\n *         <td>{@code 2001.07.04 AD at 12:08:56 PDT}\n *     <tr>\n *         <th scope=\"row\">{@code \"EEE, MMM d, ''yy\"}\n *         <td>{@code Wed, Jul 4, '01}\n *     <tr>\n *         <th scope=\"row\">{@code \"h:mm a\"}\n *         <td>{@code 12:08 PM}\n *     <tr>\n *         <th scope=\"row\">{@code \"hh 'o''clock' a, zzzz\"}\n *         <td>{@code 12 o'clock PM, Pacific Daylight Time}\n *     <tr>\n *         <th scope=\"row\">{@code \"K:mm a, z\"}\n *         <td>{@code 0:08 PM, PDT}\n *     <tr>\n *         <th scope=\"row\">{@code \"yyyyy.MMMMM.dd GGG hh:mm aaa\"}\n *         <td>{@code 02001.July.04 AD 12:08 PM}\n *     <tr>\n *         <th scope=\"row\">{@code \"EEE, d MMM yyyy HH:mm:ss Z\"}\n *         <td>{@code Wed, 4 Jul 2001 12:08:56 -0700}\n *     <tr>\n *         <th scope=\"row\">{@code \"yyMMddHHmmssZ\"}\n *         <td>{@code 010704120856-0700}\n *     <tr>\n *         <th scope=\"row\">{@code \"yyyy-MM-dd'T'HH:mm:ss.SSSZ\"}\n *         <td>{@code 2001-07-04T12:08:56.235-0700}\n *     <tr>\n *         <th scope=\"row\">{@code \"yyyy-MM-dd'T'HH:mm:ss.SSSXXX\"}\n *         <td>{@code 2001-07-04T12:08:56.235-07:00}\n *     <tr>\n *         <th scope=\"row\">{@code \"YYYY-'W'ww-u\"}\n *         <td>{@code 2001-W27-3}\n * </tbody>\n * </table>\n * </blockquote>\n *\n * <h3><a id=\"synchronization\">Synchronization</a></h3>\n *\n * <p>\n * Date formats are not synchronized.\n * It is recommended to create separate format instances for each thread.\n * If multiple threads access a format concurrently, it must be synchronized\n * externally.\n * @apiNote Consider using {@link java.time.format.DateTimeFormatter} as an\n * immutable and thread-safe alternative.\n *\n * @see          <a href=\"http://docs.oracle.com/javase/tutorial/i18n/format/simpleDateFormat.html\">Java Tutorial</a>\n * @see          java.util.Calendar\n * @see          java.util.TimeZone\n * @see          DateFormat\n * @see          DateFormatSymbols\n * @see          java.time.format.DateTimeFormatter\n * @author       Mark Davis, Chen-Lieh Huang, Alan Liu\n * @since 1.1\n ",
  "links" : [ "#getCalendar()", "#isDigit(char)", "#setDateFormatSymbols(DateFormatSymbols)", "java.time.format.DateTimeFormatter", "#SimpleDateFormat(String", "java.util.Calendar#isWeekDateSupported()", "java.text.DateFormat", "IllegalArgumentException", "java.text.DateFormat#getCalendar()" ],
  "variables" : [ {
    "name" : "serialVersionUID",
    "type" : "long",
    "comment" : " which version we're compatible with",
    "links" : [ ]
  }, {
    "name" : "currentSerialVersion",
    "type" : "int",
    "comment" : " - 1 for version from JDK 1.1.4, which includes a new field",
    "links" : [ ]
  }, {
    "name" : "serialVersionOnStream",
    "type" : "int",
    "comment" : "\n     * The version of the serialized data on the stream.  Possible values:\n     * <ul>\n     * <li><b>0</b> or not present on stream: JDK 1.1.3.  This version\n     * has no {@code defaultCenturyStart} on stream.\n     * <li><b>1</b> JDK 1.1.4 or later.  This version adds\n     * {@code defaultCenturyStart}.\n     * </ul>\n     * When streaming out this class, the most recent format\n     * and the highest allowable {@code serialVersionOnStream}\n     * is written.\n     * @serial\n     * @since 1.1.4\n     ",
    "links" : [ ]
  }, {
    "name" : "pattern",
    "type" : "String",
    "comment" : "\n     * The pattern string of this formatter.  This is always a non-localized\n     * pattern.  May not be null.  See class documentation for details.\n     * @serial\n     ",
    "links" : [ ]
  }, {
    "name" : "originalNumberFormat",
    "type" : "NumberFormat",
    "comment" : "\n     * Saved numberFormat and pattern.\n     * @see SimpleDateFormat#checkNegativeNumberExpression\n     ",
    "links" : [ ]
  }, {
    "name" : "originalNumberPattern",
    "type" : "String",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "minusSign",
    "type" : "char",
    "comment" : "\n     * The minus sign to be used with format and parse.\n     ",
    "links" : [ ]
  }, {
    "name" : "hasFollowingMinusSign",
    "type" : "boolean",
    "comment" : "\n     * True when a negative sign follows a number.\n     * (True as default in Arabic.)\n     ",
    "links" : [ ]
  }, {
    "name" : "compiledPattern",
    "type" : "char[]",
    "comment" : "\n     * The compiled pattern.\n     ",
    "links" : [ ]
  }, {
    "name" : "TAG_QUOTE_ASCII_CHAR",
    "type" : "int",
    "comment" : "\n     * Tags for the compiled pattern.\n     ",
    "links" : [ ]
  }, {
    "name" : "TAG_QUOTE_CHARS",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "zeroDigit",
    "type" : "char",
    "comment" : "\n     * Locale dependent digit zero.\n     * @see #zeroPaddingNumber\n     * @see java.text.DecimalFormatSymbols#getZeroDigit\n     ",
    "links" : [ ]
  }, {
    "name" : "formatData",
    "type" : "DateFormatSymbols",
    "comment" : "\n     * The symbols used by this formatter for week names, month names,\n     * etc.  May not be null.\n     * @serial\n     * @see java.text.DateFormatSymbols\n     ",
    "links" : [ ]
  }, {
    "name" : "defaultCenturyStart",
    "type" : "Date",
    "comment" : "\n     * We map dates with two-digit years into the century starting at\n     * {@code defaultCenturyStart}, which may be any date.  May\n     * not be null.\n     * @serial\n     * @since 1.1.4\n     ",
    "links" : [ ]
  }, {
    "name" : "defaultCenturyStartYear",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "MILLIS_PER_MINUTE",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "GMT",
    "type" : "String",
    "comment" : " GMT-minutes. For instance, in France the time zone is GMT+60.",
    "links" : [ ]
  }, {
    "name" : "cachedNumberFormatData",
    "type" : "ConcurrentMap<Locale, NumberFormat>",
    "comment" : "\n     * Cache NumberFormat instances with Locale key.\n     ",
    "links" : [ ]
  }, {
    "name" : "locale",
    "type" : "Locale",
    "comment" : "\n     * The Locale used to instantiate this\n     * {@code SimpleDateFormat}. The value may be null if this object\n     * has been created by an older {@code SimpleDateFormat} and\n     * deserialized.\n     *\n     * @serial\n     * @since 1.6\n     ",
    "links" : [ ]
  }, {
    "name" : "useDateFormatSymbols",
    "type" : "boolean",
    "comment" : "\n     * Indicates whether this {@code SimpleDateFormat} should use\n     * the DateFormatSymbols. If true, the format and parse methods\n     * use the DateFormatSymbols values. If false, the format and\n     * parse methods call Calendar.getDisplayName or\n     * Calendar.getDisplayNames.\n     ",
    "links" : [ ]
  }, {
    "name" : "timeZoneNames",
    "type" : "ExtendedTimeZoneNames",
    "comment" : "\n     * ICU TimeZoneNames used to format and parse time zone names.\n     ",
    "links" : [ ]
  }, {
    "name" : "PATTERN_INDEX_TO_CALENDAR_FIELD",
    "type" : "int[]",
    "comment" : " Map index into pattern character string to Calendar field number",
    "links" : [ ]
  }, {
    "name" : "PATTERN_INDEX_TO_DATE_FORMAT_FIELD",
    "type" : "int[]",
    "comment" : " Map index into pattern character string to DateFormat field number",
    "links" : [ ]
  }, {
    "name" : "PATTERN_INDEX_TO_DATE_FORMAT_FIELD_ID",
    "type" : "Field[]",
    "comment" : " Maps from DecimalFormatSymbols index to Field constant",
    "links" : [ ]
  }, {
    "name" : "REST_OF_STYLES",
    "type" : "int[]",
    "comment" : "",
    "links" : [ ]
  } ],
  "methods" : [ {
    "name" : "private static String getDateTimeFormat(int timeStyle, int dateStyle, Locale locale)",
    "returnType" : "String",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private void initialize(Locale loc)",
    "returnType" : "void",
    "comment" : " Initialize compiledPattern and numberFormat fields ",
    "links" : [ ]
  }, {
    "name" : "private void initializeCalendar(Locale loc)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private char[] compile(String pattern)",
    "returnType" : "char[]",
    "comment" : "\n     * Returns the compiled form of the given pattern. The syntax of\n     * the compiled pattern is:\n     * <blockquote>\n     * CompiledPattern:\n     *     EntryList\n     * EntryList:\n     *     Entry\n     *     EntryList Entry\n     * Entry:\n     *     TagField\n     *     TagField data\n     * TagField:\n     *     Tag Length\n     *     TaggedData\n     * Tag:\n     *     pattern_char_index\n     *     TAG_QUOTE_CHARS\n     * Length:\n     *     short_length\n     *     long_length\n     * TaggedData:\n     *     TAG_QUOTE_ASCII_CHAR ascii_char\n     *\n     * </blockquote>\n     *\n     * where `short_length' is an 8-bit unsigned integer between 0 and\n     * 254.  `long_length' is a sequence of an 8-bit integer 255 and a\n     * 32-bit signed integer value which is split into upper and lower\n     * 16-bit fields in two char's. `pattern_char_index' is an 8-bit\n     * integer between 0 and 18. `ascii_char' is an 7-bit ASCII\n     * character value. `data' depends on its Tag value.\n     * <p>\n     * If Length is short_length, Tag and short_length are packed in a\n     * single char, as illustrated below.\n     * <blockquote>\n     *     char[0] = (Tag << 8) | short_length;\n     * </blockquote>\n     *\n     * If Length is long_length, Tag and 255 are packed in the first\n     * char and a 32-bit integer, as illustrated below.\n     * <blockquote>\n     *     char[0] = (Tag << 8) | 255;\n     *     char[1] = (char) (long_length >>> 16);\n     *     char[2] = (char) (long_length & 0xffff);\n     * </blockquote>\n     * <p>\n     * If Tag is a pattern_char_index, its Length is the number of\n     * pattern characters. For example, if the given pattern is\n     * \"yyyy\", Tag is 1 and Length is 4, followed by no data.\n     * <p>\n     * If Tag is TAG_QUOTE_CHARS, its Length is the number of char's\n     * following the TagField. For example, if the given pattern is\n     * \"'o''clock'\", Length is 7 followed by a char sequence of\n     * <code>o&nbs;'&nbs;c&nbs;l&nbs;o&nbs;c&nbs;k</code>.\n     * <p>\n     * TAG_QUOTE_ASCII_CHAR is a special tag and has an ASCII\n     * character in place of Length. For example, if the given pattern\n     * is \"'o'\", the TaggedData entry is\n     * <code>((TAG_QUOTE_ASCII_CHAR&nbs;<<&nbs;8)&nbs;|&nbs;'o')</code>.\n     *\n     * @throws    NullPointerException if the given pattern is null\n     * @throws    IllegalArgumentException if the given pattern is invalid\n     ",
    "links" : [ ]
  }, {
    "name" : "private static void encode(int tag, int length, StringBuilder buffer)",
    "returnType" : "void",
    "comment" : "\n     * Encodes the given tag and length and puts encoded char(s) into buffer.\n     ",
    "links" : [ ]
  }, {
    "name" : "private void initializeDefaultCentury()",
    "returnType" : "void",
    "comment" : " Initialize the fields we use to disambiguate ambiguous years. Separate\n     * so we can call it from readObject().\n     ",
    "links" : [ ]
  }, {
    "name" : "private void parseAmbiguousDatesAsAfter(Date startDate)",
    "returnType" : "void",
    "comment" : " Define one-century window into which to disambiguate dates using\n     * two-digit years.\n     ",
    "links" : [ ]
  }, {
    "name" : "public void set2DigitYearStart(Date startDate)",
    "returnType" : "void",
    "comment" : "\n     * Sets the 100-year period 2-digit years will be interpreted as being in\n     * to begin on the date the user specifies.\n     *\n     * @param startDate During parsing, two digit years will be placed in the range\n     * {@code startDate} to {@code startDate + 100 years}.\n     * @see #get2DigitYearStart\n     * @throws NullPointerException if {@code startDate} is {@code null}.\n     * @since 1.2\n     ",
    "links" : [ ]
  }, {
    "name" : "public Date get2DigitYearStart()",
    "returnType" : "Date",
    "comment" : "\n     * Returns the beginning date of the 100-year period 2-digit years are interpreted\n     * as being within.\n     *\n     * @return the start of the 100-year period into which two digit years are\n     * parsed\n     * @see #set2DigitYearStart\n     * @since 1.2\n     ",
    "links" : [ ]
  }, {
    "name" : "public StringBuffer format(Date date, StringBuffer toAppendTo, FieldPosition pos)",
    "returnType" : "StringBuffer",
    "comment" : "\n     * Formats the given {@code Date} into a date/time string and appends\n     * the result to the given {@code StringBuffer}.\n     *\n     * @param date the date-time value to be formatted into a date-time string.\n     * @param toAppendTo where the new date-time text is to be appended.\n     * @param pos keeps track on the position of the field within\n     * the returned string. For example, given a date-time text\n     * {@code \"1996.07.10 AD at 15:08:56 PDT\"}, if the given {@code fieldPosition}\n     * is {@link DateFormat#YEAR_FIELD}, the begin index and end index of\n     * {@code fieldPosition} will be set to 0 and 4, respectively.\n     * Notice that if the same date-time field appears more than once in a\n     * pattern, the {@code fieldPosition} will be set for the first occurrence\n     * of that date-time field. For instance, formatting a {@code Date} to the\n     * date-time string {@code \"1 PM PDT (Pacific Daylight Time)\"} using the\n     * pattern {@code \"h a z (zzzz)\"} and the alignment field\n     * {@link DateFormat#TIMEZONE_FIELD}, the begin index and end index of\n     * {@code fieldPosition} will be set to 5 and 8, respectively, for the\n     * first occurrence of the timezone pattern character {@code 'z'}.\n     * @return the formatted date-time string.\n     * @throws    NullPointerException if any of the parameters is {@code null}.\n     ",
    "links" : [ "java.text.DateFormat#TIMEZONE_FIELD", "java.text.DateFormat#YEAR_FIELD" ]
  }, {
    "name" : "private StringBuffer format(Date date, StringBuffer toAppendTo, FieldDelegate delegate)",
    "returnType" : "StringBuffer",
    "comment" : " Called from Format after creating a FieldDelegate",
    "links" : [ ]
  }, {
    "name" : "public AttributedCharacterIterator formatToCharacterIterator(Object obj)",
    "returnType" : "AttributedCharacterIterator",
    "comment" : "\n     * Formats an Object producing an {@code AttributedCharacterIterator}.\n     * You can use the returned {@code AttributedCharacterIterator}\n     * to build the resulting String, as well as to determine information\n     * about the resulting String.\n     * <p>\n     * Each attribute key of the AttributedCharacterIterator will be of type\n     * {@code DateFormat.Field}, with the corresponding attribute value\n     * being the same as the attribute key.\n     *\n     * @throws    NullPointerException if obj is null.\n     * @throws    IllegalArgumentException if the Format cannot format the\n     *            given object, or if the Format's pattern string is invalid.\n     * @param obj The object to format\n     * @return AttributedCharacterIterator describing the formatted value.\n     * @since 1.4\n     ",
    "links" : [ ]
  }, {
    "name" : "private void subFormat(int patternCharIndex, int count, FieldDelegate delegate, StringBuffer buffer, boolean useDateFormatSymbols)",
    "returnType" : "void",
    "comment" : "\n     * Private member function that does the real date/time formatting.\n     ",
    "links" : [ ]
  }, {
    "name" : "private String formatWeekday(int count, int value, boolean useDateFormatSymbols, boolean standalone)",
    "returnType" : "String",
    "comment" : " BEGIN Android-added: formatWeekday() and formatMonth() methods to format using ICU data.",
    "links" : [ ]
  }, {
    "name" : "private String formatMonth(int count, int value, int maxIntCount, StringBuffer buffer, boolean useDateFormatSymbols, boolean standalone, int field, int style)",
    "returnType" : "String",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private void zeroPaddingNumber(int value, int minDigits, int maxDigits, StringBuffer buffer)",
    "returnType" : "void",
    "comment" : "\n     * Formats a number with the specified minimum and maximum number of digits.\n     ",
    "links" : [ ]
  }, {
    "name" : "public Date parse(String text, ParsePosition pos)",
    "returnType" : "Date",
    "comment" : "\n     * Parses text from a string to produce a {@code Date}.\n     * <p>\n     * The method attempts to parse text starting at the index given by\n     * {@code pos}.\n     * If parsing succeeds, then the index of {@code pos} is updated\n     * to the index after the last character used (parsing does not necessarily\n     * use all characters up to the end of the string), and the parsed\n     * date is returned. The updated {@code pos} can be used to\n     * indicate the starting point for the next call to this method.\n     * If an error occurs, then the index of {@code pos} is not\n     * changed, the error index of {@code pos} is set to the index of\n     * the character where the error occurred, and null is returned.\n     *\n     * <p>This parsing operation uses the {@link DateFormat#calendar\n     * calendar} to produce a {@code Date}. All of the {@code\n     * calendar}'s date-time fields are {@linkplain Calendar#clear()\n     * cleared} before parsing, and the {@code calendar}'s default\n     * values of the date-time fields are used for any missing\n     * date-time information. For example, the year value of the\n     * parsed {@code Date} is 1970 with {@link GregorianCalendar} if\n     * no year value is given from the parsing operation.  The {@code\n     * TimeZone} value may be overwritten, depending on the given\n     * pattern and the time zone value in {@code text}. Any {@code\n     * TimeZone} value that has previously been set by a call to\n     * {@link #setTimeZone(java.util.TimeZone) setTimeZone} may need\n     * to be restored for further operations.\n     *\n     * @param text  A {@code String}, part of which should be parsed.\n     * @param pos   A {@code ParsePosition} object with index and error\n     *              index information as described above.\n     * @return A {@code Date} parsed from the string. In case of\n     *         error, returns null.\n     * @throws    NullPointerException if {@code text} or {@code pos} is null.\n     ",
    "links" : [ "#setTimeZone(java.util.TimeZone)", "java.util.GregorianCalendar", "java.text.DateFormat#calendarcalendar" ]
  }, {
    "name" : "private Date parseInternal(String text, ParsePosition pos)",
    "returnType" : "Date",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private boolean shouldObeyCount(int tag, int count)",
    "returnType" : "boolean",
    "comment" : " If the next tag/pattern is a <Numeric_Field> then the parser\n     * should consider the count of digits while parsing the contigous digits\n     * for the current tag/pattern\n     ",
    "links" : [ ]
  }, {
    "name" : "private int matchString(String text, int start, int field, String[] data, CalendarBuilder calb)",
    "returnType" : "int",
    "comment" : "\n     * Private code-size reduction function used by subParse.\n     * @param text the time text being parsed.\n     * @param start where to start parsing.\n     * @param field the date field being parsed.\n     * @param data the string array to parsed.\n     * @return the new start position if matching succeeded; a negative number\n     * indicating matching failure, otherwise.\n     ",
    "links" : [ ]
  }, {
    "name" : "private int matchString(String text, int start, int field, Map<String, Integer> data, CalendarBuilder calb)",
    "returnType" : "int",
    "comment" : "\n     * Performs the same thing as matchString(String, int, int,\n     * String[]). This method takes a Map<String, Integer> instead of\n     * String[].\n     ",
    "links" : [ ]
  }, {
    "name" : "private int matchZoneString(String text, int start, String[] zoneNames)",
    "returnType" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private int subParseZoneString(String text, int start, CalendarBuilder calb)",
    "returnType" : "int",
    "comment" : "\n     * Parses the string in {@code text} (starting at {@code start}), interpreting it as a time zone\n     * name. If a time zone is found, the internal calendar is set to that timezone and the index of\n     * the first character after the time zone name is returned. Otherwise, returns {@code 0}.\n     * @return the index of the next character to parse or {@code 0} on error.\n     ",
    "links" : [ ]
  }, {
    "name" : "private ExtendedTimeZoneNames getExtendedTimeZoneNames()",
    "returnType" : "ExtendedTimeZoneNames",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private TimeZoneNames getTimeZoneNames()",
    "returnType" : "TimeZoneNames",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private int subParseZoneStringFromICU(String text, int start, CalendarBuilder calb)",
    "returnType" : "int",
    "comment" : "\n     * Parses the time zone string using the ICU4J class {@link TimeZoneNames}.\n     ",
    "links" : [ "android.icu.text.TimeZoneNames" ]
  }, {
    "name" : "private int subParseZoneStringFromSymbols(String text, int start, CalendarBuilder calb)",
    "returnType" : "int",
    "comment" : "\n     * Parses the time zone string using the information in {@link #formatData}.\n     ",
    "links" : [ "#formatData" ]
  }, {
    "name" : "private int subParseNumericZone(String text, int start, int sign, int count, boolean colon, CalendarBuilder calb)",
    "returnType" : "int",
    "comment" : "\n     * Parses numeric forms of time zone offset, such as \"hh:mm\", and\n     * sets calb to the parsed value.\n     *\n     * @param text  the text to be parsed\n     * @param start the character position to start parsing\n     * @param sign  1: positive; -1: negative\n     * @param count 0: 'Z' or \"GMT+hh:mm\" parsing; 1 - 3: the number of 'X's\n     * @param colon true - colon required between hh and mm; false - no colon required\n     * @param calb  a CalendarBuilder in which the parsed value is stored\n     * @return updated parsed position, or its negative value to indicate a parsing error\n     ",
    "links" : [ ]
  }, {
    "name" : "private boolean isDigit(char c)",
    "returnType" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private int subParse(String text, int start, int patternCharIndex, int count, boolean obeyCount, boolean[] ambiguousYear, ParsePosition origPos, boolean useFollowingMinusSignAsDelimiter, CalendarBuilder calb)",
    "returnType" : "int",
    "comment" : "\n     * Private member function that converts the parsed date strings into\n     * timeFields. Returns -start (for ParsePosition) if failed.\n     * @param text the time text to be parsed.\n     * @param start where to start parsing.\n     * @param patternCharIndex the index of the pattern character.\n     * @param count the count of a pattern character.\n     * @param obeyCount if true, then the next field directly abuts this one,\n     * and we should use the count to know when to stop parsing.\n     * @param ambiguousYear return parameter; upon return, if ambiguousYear[0]\n     * is true, then a two-digit year was parsed and may need to be readjusted.\n     * @param origPos origPos.errorIndex is used to return an error index\n     * at which a parse error occurred, if matching failure occurs.\n     * @return the new start position if matching succeeded; -1 indicating\n     * matching failure, otherwise. In case matching failure occurred,\n     * an error index is set to origPos.errorIndex.\n     ",
    "links" : [ ]
  }, {
    "name" : "private int parseMonth(String text, int count, int value, int start, int field, ParsePosition pos, boolean useDateFormatSymbols, boolean standalone, CalendarBuilder out)",
    "returnType" : "int",
    "comment" : " BEGIN Android-added: parseMonth and parseWeekday methods to parse using ICU data.",
    "links" : [ ]
  }, {
    "name" : "private int parseWeekday(String text, int start, int field, boolean useDateFormatSymbols, boolean standalone, CalendarBuilder out)",
    "returnType" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private boolean useDateFormatSymbols()",
    "returnType" : "boolean",
    "comment" : "\n     * Returns true if the DateFormatSymbols has been set explicitly or locale\n     * is null or calendar is Gregorian.\n     ",
    "links" : [ ]
  }, {
    "name" : "private String translatePattern(String pattern, String from, String to)",
    "returnType" : "String",
    "comment" : "\n     * Translates a pattern, mapping each character in the from string to the\n     * corresponding character in the to string.\n     *\n     * @throws    IllegalArgumentException if the given pattern is invalid\n     ",
    "links" : [ ]
  }, {
    "name" : "public String toPattern()",
    "returnType" : "String",
    "comment" : "\n     * Returns a pattern string describing this date format.\n     *\n     * @return a pattern string describing this date format.\n     ",
    "links" : [ ]
  }, {
    "name" : "public String toLocalizedPattern()",
    "returnType" : "String",
    "comment" : "\n     * Returns a localized pattern string describing this date format.\n     *\n     * @return a localized pattern string describing this date format.\n     ",
    "links" : [ ]
  }, {
    "name" : "public void applyPattern(String pattern)",
    "returnType" : "void",
    "comment" : "\n     * Applies the given pattern string to this date format.\n     *\n     * @param pattern the new date and time pattern for this date format\n     * @throws    NullPointerException if the given pattern is null\n     * @throws    IllegalArgumentException if the given pattern is invalid\n     ",
    "links" : [ ]
  }, {
    "name" : "private void applyPatternImpl(String pattern)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public void applyLocalizedPattern(String pattern)",
    "returnType" : "void",
    "comment" : "\n     * Applies the given localized pattern string to this date format.\n     *\n     * @param pattern a String to be mapped to the new date and time format\n     *        pattern for this format\n     * @throws    NullPointerException if the given pattern is null\n     * @throws    IllegalArgumentException if the given pattern is invalid\n     ",
    "links" : [ ]
  }, {
    "name" : "public DateFormatSymbols getDateFormatSymbols()",
    "returnType" : "DateFormatSymbols",
    "comment" : "\n     * Gets a copy of the date and time format symbols of this date format.\n     *\n     * @return the date and time format symbols of this date format\n     * @see #setDateFormatSymbols\n     ",
    "links" : [ ]
  }, {
    "name" : "public void setDateFormatSymbols(DateFormatSymbols newFormatSymbols)",
    "returnType" : "void",
    "comment" : "\n     * Sets the date and time format symbols of this date format.\n     *\n     * @param newFormatSymbols the new date and time format symbols\n     * @throws    NullPointerException if the given newFormatSymbols is null\n     * @see #getDateFormatSymbols\n     ",
    "links" : [ ]
  }, {
    "name" : "public Object clone()",
    "returnType" : "Object",
    "comment" : "\n     * Creates a copy of this {@code SimpleDateFormat}. This also\n     * clones the format's date format symbols.\n     *\n     * @return a clone of this {@code SimpleDateFormat}\n     ",
    "links" : [ ]
  }, {
    "name" : "public int hashCode()",
    "returnType" : "int",
    "comment" : "\n     * Returns the hash code value for this {@code SimpleDateFormat} object.\n     *\n     * @return the hash code value for this {@code SimpleDateFormat} object.\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean equals(Object obj)",
    "returnType" : "boolean",
    "comment" : "\n     * Compares the given object with this {@code SimpleDateFormat} for\n     * equality.\n     *\n     * @return true if the given object is equal to this\n     * {@code SimpleDateFormat}\n     ",
    "links" : [ ]
  }, {
    "name" : "private Map<String, Integer> getDisplayNamesMap(int field, Locale locale)",
    "returnType" : "Map<String, Integer>",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private void readObject(ObjectInputStream stream) throws IOException, ClassNotFoundException",
    "returnType" : "void",
    "comment" : "\n     * After reading an object from the input stream, the format\n     * pattern in the object is verified.\n     *\n     * @throws    InvalidObjectException if the pattern is invalid\n     ",
    "links" : [ ]
  }, {
    "name" : "private void checkNegativeNumberExpression()",
    "returnType" : "void",
    "comment" : "\n     * Analyze the negative subpattern of DecimalFormat and set/update values\n     * as necessary.\n     ",
    "links" : [ ]
  } ],
  "methodNames" : [ "private static String getDateTimeFormat(int timeStyle, int dateStyle, Locale locale)", "private void initialize(Locale loc)", "private void initializeCalendar(Locale loc)", "private char[] compile(String pattern)", "private static void encode(int tag, int length, StringBuilder buffer)", "private void initializeDefaultCentury()", "private void parseAmbiguousDatesAsAfter(Date startDate)", "public void set2DigitYearStart(Date startDate)", "public Date get2DigitYearStart()", "public StringBuffer format(Date date, StringBuffer toAppendTo, FieldPosition pos)", "private StringBuffer format(Date date, StringBuffer toAppendTo, FieldDelegate delegate)", "public AttributedCharacterIterator formatToCharacterIterator(Object obj)", "private void subFormat(int patternCharIndex, int count, FieldDelegate delegate, StringBuffer buffer, boolean useDateFormatSymbols)", "private String formatWeekday(int count, int value, boolean useDateFormatSymbols, boolean standalone)", "private String formatMonth(int count, int value, int maxIntCount, StringBuffer buffer, boolean useDateFormatSymbols, boolean standalone, int field, int style)", "private void zeroPaddingNumber(int value, int minDigits, int maxDigits, StringBuffer buffer)", "public Date parse(String text, ParsePosition pos)", "private Date parseInternal(String text, ParsePosition pos)", "private boolean shouldObeyCount(int tag, int count)", "private int matchString(String text, int start, int field, String[] data, CalendarBuilder calb)", "private int matchString(String text, int start, int field, Map<String, Integer> data, CalendarBuilder calb)", "private int matchZoneString(String text, int start, String[] zoneNames)", "private int subParseZoneString(String text, int start, CalendarBuilder calb)", "private ExtendedTimeZoneNames getExtendedTimeZoneNames()", "private TimeZoneNames getTimeZoneNames()", "private int subParseZoneStringFromICU(String text, int start, CalendarBuilder calb)", "private int subParseZoneStringFromSymbols(String text, int start, CalendarBuilder calb)", "private int subParseNumericZone(String text, int start, int sign, int count, boolean colon, CalendarBuilder calb)", "private boolean isDigit(char c)", "private int subParse(String text, int start, int patternCharIndex, int count, boolean obeyCount, boolean[] ambiguousYear, ParsePosition origPos, boolean useFollowingMinusSignAsDelimiter, CalendarBuilder calb)", "private int parseMonth(String text, int count, int value, int start, int field, ParsePosition pos, boolean useDateFormatSymbols, boolean standalone, CalendarBuilder out)", "private int parseWeekday(String text, int start, int field, boolean useDateFormatSymbols, boolean standalone, CalendarBuilder out)", "private boolean useDateFormatSymbols()", "private String translatePattern(String pattern, String from, String to)", "public String toPattern()", "public String toLocalizedPattern()", "public void applyPattern(String pattern)", "private void applyPatternImpl(String pattern)", "public void applyLocalizedPattern(String pattern)", "public DateFormatSymbols getDateFormatSymbols()", "public void setDateFormatSymbols(DateFormatSymbols newFormatSymbols)", "public Object clone()", "public int hashCode()", "public boolean equals(Object obj)", "private Map<String, Integer> getDisplayNamesMap(int field, Locale locale)", "private void readObject(ObjectInputStream stream) throws IOException, ClassNotFoundException", "private void checkNegativeNumberExpression()" ],
  "variableNames" : [ "serialVersionUID", "currentSerialVersion", "serialVersionOnStream", "pattern", "originalNumberFormat", "originalNumberPattern", "minusSign", "hasFollowingMinusSign", "compiledPattern", "TAG_QUOTE_ASCII_CHAR", "TAG_QUOTE_CHARS", "zeroDigit", "formatData", "defaultCenturyStart", "defaultCenturyStartYear", "MILLIS_PER_MINUTE", "GMT", "cachedNumberFormatData", "locale", "useDateFormatSymbols", "timeZoneNames", "PATTERN_INDEX_TO_CALENDAR_FIELD", "PATTERN_INDEX_TO_DATE_FORMAT_FIELD", "PATTERN_INDEX_TO_DATE_FORMAT_FIELD_ID", "REST_OF_STYLES" ]
}