{
  "filePath" : "/home/maryam/clearblue/files/android-source-35/javax/net/ssl/X509ExtendedTrustManager.java",
  "packageName" : "javax.net.ssl",
  "className" : "X509ExtendedTrustManager",
  "comment" : "\n * Extensions to the <code>X509TrustManager</code> interface to support\n * SSL/TLS connection sensitive trust management.\n * <p>\n * To prevent man-in-the-middle attacks, hostname checks can be done\n * to verify that the hostname in an end-entity certificate matches the\n * targeted hostname.  TLS does not require such checks, but some protocols\n * over TLS (such as HTTPS) do.  In earlier versions of the JDK, the\n * certificate chain checks were done at the SSL/TLS layer, and the hostname\n * verification checks were done at the layer over TLS.  This class allows\n * for the checking to be done during a single call to this class.\n * <p>\n * RFC 2830 defines the server identification specification for the \"LDAPS\"\n * algorithm. RFC 2818 defines both the server identification and the\n * client identification specification for the \"HTTPS\" algorithm.\n *\n * @see X509TrustManager\n * @see HostnameVerifier\n *\n * @since 1.7\n ",
  "links" : [ ],
  "variables" : [ ],
  "methods" : [ {
    "name" : "public abstract void checkClientTrusted(X509Certificate[] chain, String authType, Socket socket) throws CertificateException",
    "returnType" : "void",
    "comment" : "\n     * Given the partial or complete certificate chain provided by the\n     * peer, build and validate the certificate path based on the\n     * authentication type and ssl parameters.\n     * <p>\n     * The authentication type is determined by the actual certificate\n     * used. For instance, if RSAPublicKey is used, the authType\n     * should be \"RSA\". Checking is case-sensitive.\n     * <p>\n     * If the <code>socket</code> parameter is an instance of\n     * {@link javax.net.ssl.SSLSocket}, and the endpoint identification\n     * algorithm of the <code>SSLParameters</code> is non-empty, to prevent\n     * man-in-the-middle attacks, the address that the <code>socket</code>\n     * connected to should be checked against the peer's identity presented\n     * in the end-entity X509 certificate, as specified in the endpoint\n     * identification algorithm.\n     * <p>\n     * If the <code>socket</code> parameter is an instance of\n     * {@link javax.net.ssl.SSLSocket}, and the algorithm constraints of the\n     * <code>SSLParameters</code> is non-null, for every certificate in the\n     * certification path, fields such as subject public key, the signature\n     * algorithm, key usage, extended key usage, etc. need to conform to the\n     * algorithm constraints in place on this socket.\n     *\n     * @param chain the peer certificate chain\n     * @param authType the key exchange algorithm used\n     * @param socket the socket used for this connection. This parameter\n     *        can be null, which indicates that implementations need not check\n     *        the ssl parameters\n     * @throws IllegalArgumentException if null or zero-length array is passed\n     *        in for the <code>chain</code> parameter or if null or zero-length\n     *        string is passed in for the <code>authType</code> parameter\n     * @throws CertificateException if the certificate chain is not trusted\n     *        by this TrustManager\n     *\n     * @see SSLParameters#getEndpointIdentificationAlgorithm\n     * @see SSLParameters#setEndpointIdentificationAlgorithm(String)\n     * @see SSLParameters#getAlgorithmConstraints\n     * @see SSLParameters#setAlgorithmConstraints(AlgorithmConstraints)\n     ",
    "links" : [ "javax.net.ssl.SSLSocket" ]
  }, {
    "name" : "public abstract void checkServerTrusted(X509Certificate[] chain, String authType, Socket socket) throws CertificateException",
    "returnType" : "void",
    "comment" : "\n     * Given the partial or complete certificate chain provided by the\n     * peer, build and validate the certificate path based on the\n     * authentication type and ssl parameters.\n     * <p>\n     * The authentication type is the key exchange algorithm portion\n     * of the cipher suites represented as a String, such as \"RSA\",\n     * \"DHE_DSS\". Note: for some exportable cipher suites, the key\n     * exchange algorithm is determined at run time during the\n     * handshake. For instance, for TLS_RSA_EXPORT_WITH_RC4_40_MD5,\n     * the authType should be RSA_EXPORT when an ephemeral RSA key is\n     * used for the key exchange, and RSA when the key from the server\n     * certificate is used. Checking is case-sensitive.\n     * <p>\n     * If the <code>socket</code> parameter is an instance of\n     * {@link javax.net.ssl.SSLSocket}, and the endpoint identification\n     * algorithm of the <code>SSLParameters</code> is non-empty, to prevent\n     * man-in-the-middle attacks, the address that the <code>socket</code>\n     * connected to should be checked against the peer's identity presented\n     * in the end-entity X509 certificate, as specified in the endpoint\n     * identification algorithm.\n     * <p>\n     * If the <code>socket</code> parameter is an instance of\n     * {@link javax.net.ssl.SSLSocket}, and the algorithm constraints of the\n     *  <code>SSLParameters</code> is non-null, for every certificate in the\n     * certification path, fields such as subject public key, the signature\n     * algorithm, key usage, extended key usage, etc. need to conform to the\n     * algorithm constraints in place on this socket.\n     *\n     * @param chain the peer certificate chain\n     * @param authType the key exchange algorithm used\n     * @param socket the socket used for this connection. This parameter\n     *        can be null, which indicates that implementations need not check\n     *        the ssl parameters\n     * @throws IllegalArgumentException if null or zero-length array is passed\n     *        in for the <code>chain</code> parameter or if null or zero-length\n     *        string is passed in for the <code>authType</code> parameter\n     * @throws CertificateException if the certificate chain is not trusted\n     *        by this TrustManager\n     *\n     * @see SSLParameters#getEndpointIdentificationAlgorithm\n     * @see SSLParameters#setEndpointIdentificationAlgorithm(String)\n     * @see SSLParameters#getAlgorithmConstraints\n     * @see SSLParameters#setAlgorithmConstraints(AlgorithmConstraints)\n     ",
    "links" : [ "javax.net.ssl.SSLSocket" ]
  }, {
    "name" : "public abstract void checkClientTrusted(X509Certificate[] chain, String authType, SSLEngine engine) throws CertificateException",
    "returnType" : "void",
    "comment" : "\n     * Given the partial or complete certificate chain provided by the\n     * peer, build and validate the certificate path based on the\n     * authentication type and ssl parameters.\n     * <p>\n     * The authentication type is determined by the actual certificate\n     * used. For instance, if RSAPublicKey is used, the authType\n     * should be \"RSA\". Checking is case-sensitive.\n     * <p>\n     * If the <code>engine</code> parameter is available, and the endpoint\n     * identification algorithm of the <code>SSLParameters</code> is\n     * non-empty, to prevent man-in-the-middle attacks, the address that\n     * the <code>engine</code> connected to should be checked against\n     * the peer's identity presented in the end-entity X509 certificate,\n     * as specified in the endpoint identification algorithm.\n     * <p>\n     * If the <code>engine</code> parameter is available, and the algorithm\n     * constraints of the <code>SSLParameters</code> is non-null, for every\n     * certificate in the certification path, fields such as subject public\n     * key, the signature algorithm, key usage, extended key usage, etc.\n     * need to conform to the algorithm constraints in place on this engine.\n     *\n     * @param chain the peer certificate chain\n     * @param authType the key exchange algorithm used\n     * @param engine the engine used for this connection. This parameter\n     *        can be null, which indicates that implementations need not check\n     *        the ssl parameters\n     * @throws IllegalArgumentException if null or zero-length array is passed\n     *        in for the <code>chain</code> parameter or if null or zero-length\n     *        string is passed in for the <code>authType</code> parameter\n     * @throws CertificateException if the certificate chain is not trusted\n     *        by this TrustManager\n     *\n     * @see SSLParameters#getEndpointIdentificationAlgorithm\n     * @see SSLParameters#setEndpointIdentificationAlgorithm(String)\n     * @see SSLParameters#getAlgorithmConstraints\n     * @see SSLParameters#setAlgorithmConstraints(AlgorithmConstraints)\n     ",
    "links" : [ ]
  }, {
    "name" : "public abstract void checkServerTrusted(X509Certificate[] chain, String authType, SSLEngine engine) throws CertificateException",
    "returnType" : "void",
    "comment" : "\n     * Given the partial or complete certificate chain provided by the\n     * peer, build and validate the certificate path based on the\n     * authentication type and ssl parameters.\n     * <p>\n     * The authentication type is the key exchange algorithm portion\n     * of the cipher suites represented as a String, such as \"RSA\",\n     * \"DHE_DSS\". Note: for some exportable cipher suites, the key\n     * exchange algorithm is determined at run time during the\n     * handshake. For instance, for TLS_RSA_EXPORT_WITH_RC4_40_MD5,\n     * the authType should be RSA_EXPORT when an ephemeral RSA key is\n     * used for the key exchange, and RSA when the key from the server\n     * certificate is used. Checking is case-sensitive.\n     * <p>\n     * If the <code>engine</code> parameter is available, and the endpoint\n     * identification algorithm of the <code>SSLParameters</code> is\n     * non-empty, to prevent man-in-the-middle attacks, the address that\n     * the <code>engine</code> connected to should be checked against\n     * the peer's identity presented in the end-entity X509 certificate,\n     * as specified in the endpoint identification algorithm.\n     * <p>\n     * If the <code>engine</code> parameter is available, and the algorithm\n     * constraints of the <code>SSLParameters</code> is non-null, for every\n     * certificate in the certification path, fields such as subject public\n     * key, the signature algorithm, key usage, extended key usage, etc.\n     * need to conform to the algorithm constraints in place on this engine.\n     *\n     * @param chain the peer certificate chain\n     * @param authType the key exchange algorithm used\n     * @param engine the engine used for this connection. This parameter\n     *        can be null, which indicates that implementations need not check\n     *        the ssl parameters\n     * @throws IllegalArgumentException if null or zero-length array is passed\n     *        in for the <code>chain</code> parameter or if null or zero-length\n     *        string is passed in for the <code>authType</code> parameter\n     * @throws CertificateException if the certificate chain is not trusted\n     *        by this TrustManager\n     *\n     * @see SSLParameters#getEndpointIdentificationAlgorithm\n     * @see SSLParameters#setEndpointIdentificationAlgorithm(String)\n     * @see SSLParameters#getAlgorithmConstraints\n     * @see SSLParameters#setAlgorithmConstraints(AlgorithmConstraints)\n     ",
    "links" : [ ]
  } ],
  "methodNames" : [ "public abstract void checkClientTrusted(X509Certificate[] chain, String authType, Socket socket) throws CertificateException", "public abstract void checkServerTrusted(X509Certificate[] chain, String authType, Socket socket) throws CertificateException", "public abstract void checkClientTrusted(X509Certificate[] chain, String authType, SSLEngine engine) throws CertificateException", "public abstract void checkServerTrusted(X509Certificate[] chain, String authType, SSLEngine engine) throws CertificateException" ],
  "variableNames" : [ ]
}