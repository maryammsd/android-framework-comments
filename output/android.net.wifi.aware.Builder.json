{
  "filePath" : "/home/maryam/clearblue/files/android-source-30/android/net/wifi/aware/SubscribeConfig.java",
  "packageName" : "android.net.wifi.aware",
  "className" : "Builder",
  "comment" : "\n     * Builder used to build {@link SubscribeConfig} objects.\n     ",
  "variables" : [ {
    "name" : "mServiceName",
    "type" : "byte[]",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mServiceSpecificInfo",
    "type" : "byte[]",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mMatchFilter",
    "type" : "byte[]",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mSubscribeType",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mTtlSec",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mEnableTerminateNotification",
    "type" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mMinDistanceMmSet",
    "type" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mMinDistanceMm",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mMaxDistanceMmSet",
    "type" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mMaxDistanceMm",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  } ],
  "methods" : [ {
    "name" : "public Builder setServiceName(@NonNull String serviceName)",
    "returnType" : "Builder",
    "comment" : "\n         * Specify the service name of the subscribe session. The actual on-air\n         * value is a 6 byte hashed representation of this string.\n         * <p>\n         * The Service Name is a UTF-8 encoded string from 1 to 255 bytes in length.\n         * The only acceptable single-byte UTF-8 symbols for a Service Name are alphanumeric\n         * values (A-Z, a-z, 0-9), the hyphen ('-'), and the period ('.'). All valid multi-byte\n         * UTF-8 characters are acceptable in a Service Name.\n         * <p>\n         * Must be called - an empty ServiceName is not valid.\n         *\n         * @param serviceName The service name for the subscribe session.\n         *\n         * @return The builder to facilitate chaining\n         *         {@code builder.setXXX(..).setXXX(..)}.\n         ",
    "links" : [ ]
  }, {
    "name" : "public Builder setServiceSpecificInfo(@Nullable byte[] serviceSpecificInfo)",
    "returnType" : "Builder",
    "comment" : "\n         * Specify service specific information for the subscribe session. This is\n         * a free-form byte array available to the application to send\n         * additional information as part of the discovery operation - i.e. it\n         * will not be used to determine whether a publish/subscribe match\n         * occurs.\n         * <p>\n         *     Optional. Empty by default.\n         *\n         * @param serviceSpecificInfo A byte-array for the service-specific\n         *            information field.\n         *\n         * @return The builder to facilitate chaining\n         *         {@code builder.setXXX(..).setXXX(..)}.\n         ",
    "links" : [ ]
  }, {
    "name" : "public Builder setMatchFilter(@Nullable List<byte[]> matchFilter)",
    "returnType" : "Builder",
    "comment" : "\n         * The match filter for a subscribe session. Used to determine whether a service\n         * discovery occurred - in addition to relying on the service name.\n         * <p>\n         *     Optional. Empty by default.\n         *\n         * @param matchFilter A list of match filter entries (each of which is an arbitrary byte\n         *                    array).\n         *\n         * @return The builder to facilitate chaining\n         *         {@code builder.setXXX(..).setXXX(..)}.\n         ",
    "links" : [ ]
  }, {
    "name" : "public Builder setSubscribeType(@SubscribeTypes int subscribeType)",
    "returnType" : "Builder",
    "comment" : "\n         * Sets the type of the subscribe session: active (subscribe packets are\n         * transmitted over-the-air), or passive (no subscribe packets are\n         * transmitted, a match is made against a solicited/active publish\n         * session whose packets are transmitted over-the-air).\n         *\n         * @param subscribeType Subscribe session type:\n         *            {@link SubscribeConfig#SUBSCRIBE_TYPE_ACTIVE} or\n         *            {@link SubscribeConfig#SUBSCRIBE_TYPE_PASSIVE}.\n         *\n         * @return The builder to facilitate chaining\n         *         {@code builder.setXXX(..).setXXX(..)}.\n         ",
    "links" : [ "android.net.wifi.aware.SubscribeConfig#SUBSCRIBE_TYPE_PASSIVE", "android.net.wifi.aware.SubscribeConfig#SUBSCRIBE_TYPE_ACTIVE" ]
  }, {
    "name" : "public Builder setTtlSec(int ttlSec)",
    "returnType" : "Builder",
    "comment" : "\n         * Sets the time interval (in seconds) an active (\n         * {@link SubscribeConfig.Builder#setSubscribeType(int)}) subscribe session\n         * will be alive - i.e. broadcasting a packet. When the TTL is reached\n         * an event will be generated for\n         * {@link DiscoverySessionCallback#onSessionTerminated()}.\n         * <p>\n         *     Optional. 0 by default - indicating the session doesn't terminate on its own.\n         *     Session will be terminated when {@link DiscoverySession#close()} is\n         *     called.\n         *\n         * @param ttlSec Lifetime of a subscribe session in seconds.\n         *\n         * @return The builder to facilitate chaining\n         *         {@code builder.setXXX(..).setXXX(..)}.\n         ",
    "links" : [ "android.net.wifi.aware.DiscoverySessionCallback#onSessionTerminated()", "android.net.wifi.aware.DiscoverySession#close()", "SubscribeConfig.Builder#setSubscribeType(int)" ]
  }, {
    "name" : "public Builder setTerminateNotificationEnabled(boolean enable)",
    "returnType" : "Builder",
    "comment" : "\n         * Configure whether a subscribe terminate notification\n         * {@link DiscoverySessionCallback#onSessionTerminated()} is reported\n         * back to the callback.\n         *\n         * @param enable If true the terminate callback will be called when the\n         *            subscribe is terminated. Otherwise it will not be called.\n         *\n         * @return The builder to facilitate chaining\n         *         {@code builder.setXXX(..).setXXX(..)}.\n         ",
    "links" : [ "android.net.wifi.aware.DiscoverySessionCallback#onSessionTerminated()" ]
  }, {
    "name" : "public Builder setMinDistanceMm(int minDistanceMm)",
    "returnType" : "Builder",
    "comment" : "\n         * Configure the minimum distance to a discovered publisher at which to trigger a discovery\n         * notification. I.e. discovery will be triggered if we've found a matching publisher\n         * (based on the other criteria in this configuration) <b>and</b> the distance to the\n         * publisher is larger than the value specified in this API. Can be used in conjunction with\n         * {@link #setMaxDistanceMm(int)} to specify a geofence, i.e. discovery with min <=\n         * distance <= max.\n         * <p>\n         * For ranging to be used in discovery it must also be enabled on the publisher using\n         * {@link PublishConfig.Builder#setRangingEnabled(boolean)}. However, ranging may\n         * not be available or enabled on the publisher or may be temporarily disabled on either\n         * subscriber or publisher - in such cases discovery will proceed without ranging.\n         * <p>\n         * When ranging is enabled and available on both publisher and subscriber and a service\n         * is discovered based on geofence constraints the\n         * {@link DiscoverySessionCallback#onServiceDiscoveredWithinRange(PeerHandle, byte[], List, int)}\n         * is called, otherwise the\n         * {@link DiscoverySessionCallback#onServiceDiscovered(PeerHandle, byte[], List)}\n         * is called.\n         * <p>\n         * The device must support Wi-Fi RTT for this feature to be used. Feature support is checked\n         * as described in {@link android.net.wifi.rtt}.\n         *\n         * @param minDistanceMm Minimum distance, in mm, to the publisher above which to trigger\n         *                      discovery.\n         *\n         * @return The builder to facilitate chaining\n         *         {@code builder.setXXX(..).setXXX(..)}.\n         ",
    "links" : [ "PublishConfig.Builder#setRangingEnabled(boolean)", "#setMaxDistanceMm(int)", "android.net.wifi.aware.DiscoverySessionCallback#onServiceDiscovered(PeerHandle", "android.net.wifi.rtt", "android.net.wifi.aware.DiscoverySessionCallback#onServiceDiscoveredWithinRange(PeerHandle" ]
  }, {
    "name" : "public Builder setMaxDistanceMm(int maxDistanceMm)",
    "returnType" : "Builder",
    "comment" : "\n         * Configure the maximum distance to a discovered publisher at which to trigger a discovery\n         * notification. I.e. discovery will be triggered if we've found a matching publisher\n         * (based on the other criteria in this configuration) <b>and</b> the distance to the\n         * publisher is smaller than the value specified in this API. Can be used in conjunction\n         * with {@link #setMinDistanceMm(int)} to specify a geofence, i.e. discovery with min <=\n         * distance <= max.\n         * <p>\n         * For ranging to be used in discovery it must also be enabled on the publisher using\n         * {@link PublishConfig.Builder#setRangingEnabled(boolean)}. However, ranging may\n         * not be available or enabled on the publisher or may be temporarily disabled on either\n         * subscriber or publisher - in such cases discovery will proceed without ranging.\n         * <p>\n         * When ranging is enabled and available on both publisher and subscriber and a service\n         * is discovered based on geofence constraints the\n         * {@link DiscoverySessionCallback#onServiceDiscoveredWithinRange(PeerHandle, byte[], List, int)}\n         * is called, otherwise the\n         * {@link DiscoverySessionCallback#onServiceDiscovered(PeerHandle, byte[], List)}\n         * is called.\n         * <p>\n         * The device must support Wi-Fi RTT for this feature to be used. Feature support is checked\n         * as described in {@link android.net.wifi.rtt}.\n         *\n         * @param maxDistanceMm Maximum distance, in mm, to the publisher below which to trigger\n         *                      discovery.\n         *\n         * @return The builder to facilitate chaining\n         *         {@code builder.setXXX(..).setXXX(..)}.\n         ",
    "links" : [ "#setMinDistanceMm(int)", "PublishConfig.Builder#setRangingEnabled(boolean)", "android.net.wifi.aware.DiscoverySessionCallback#onServiceDiscovered(PeerHandle", "android.net.wifi.rtt", "android.net.wifi.aware.DiscoverySessionCallback#onServiceDiscoveredWithinRange(PeerHandle" ]
  }, {
    "name" : "public SubscribeConfig build()",
    "returnType" : "SubscribeConfig",
    "comment" : "\n         * Build {@link SubscribeConfig} given the current requests made on the\n         * builder.\n         ",
    "links" : [ "android.net.wifi.aware.SubscribeConfig" ]
  } ],
  "variableNames" : [ "mServiceName", "mServiceSpecificInfo", "mMatchFilter", "mSubscribeType", "mTtlSec", "mEnableTerminateNotification", "mMinDistanceMmSet", "mMinDistanceMm", "mMaxDistanceMmSet", "mMaxDistanceMm" ],
  "methodNames" : [ "public Builder setServiceName(@NonNull String serviceName)", "public Builder setServiceSpecificInfo(@Nullable byte[] serviceSpecificInfo)", "public Builder setMatchFilter(@Nullable List<byte[]> matchFilter)", "public Builder setSubscribeType(@SubscribeTypes int subscribeType)", "public Builder setTtlSec(int ttlSec)", "public Builder setTerminateNotificationEnabled(boolean enable)", "public Builder setMinDistanceMm(int minDistanceMm)", "public Builder setMaxDistanceMm(int maxDistanceMm)", "public SubscribeConfig build()" ]
}