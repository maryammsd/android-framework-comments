{
  "filePath" : "/home/maryam/clearblue/files/android-source-35/java/io/LineNumberReader.java",
  "packageName" : "java.io",
  "className" : "LineNumberReader",
  "comment" : "",
  "links" : [ ],
  "variables" : [ {
    "name" : "lineNumber",
    "type" : "int",
    "comment" : " The current line number ",
    "links" : [ ]
  }, {
    "name" : "markedLineNumber",
    "type" : "int",
    "comment" : " Defaults to 0",
    "links" : [ ]
  }, {
    "name" : "skipLF",
    "type" : "boolean",
    "comment" : " If the next character is a line feed, skip it ",
    "links" : [ ]
  }, {
    "name" : "markedSkipLF",
    "type" : "boolean",
    "comment" : " The skipLF flag when the mark was set ",
    "links" : [ ]
  }, {
    "name" : "maxSkipBufferSize",
    "type" : "int",
    "comment" : " Maximum skip-buffer size ",
    "links" : [ ]
  }, {
    "name" : "skipBuffer",
    "type" : "char[]",
    "comment" : " Skip buffer, null until allocated ",
    "links" : [ ]
  } ],
  "methods" : [ {
    "name" : "public void setLineNumber(int lineNumber)",
    "returnType" : "void",
    "comment" : "\n     * Set the current line number.\n     *\n     * @param  lineNumber\n     *         An int specifying the line number\n     *\n     * @see #getLineNumber\n     ",
    "links" : [ ]
  }, {
    "name" : "public int getLineNumber()",
    "returnType" : "int",
    "comment" : "\n     * Get the current line number.\n     *\n     * @return  The current line number\n     *\n     * @see #setLineNumber\n     ",
    "links" : [ ]
  }, {
    "name" : "public int read() throws IOException",
    "returnType" : "int",
    "comment" : "\n     * Read a single character.  <a href=\"#lt\">Line terminators</a> are\n     * compressed into single newline ('\\n') characters.  Whenever a line\n     * terminator is read the current line number is incremented.\n     *\n     * @return  The character read, or -1 if the end of the stream has been\n     *          reached\n     *\n     * @throws  IOException\n     *          If an I/O error occurs\n     ",
    "links" : [ ]
  }, {
    "name" : "public int read(char[] cbuf, int off, int len) throws IOException",
    "returnType" : "int",
    "comment" : "\n     * Read characters into a portion of an array.  Whenever a <a\n     * href=\"#lt\">line terminator</a> is read the current line number is\n     * incremented.\n     *\n     * @param  cbuf\n     *         Destination buffer\n     *\n     * @param  off\n     *         Offset at which to start storing characters\n     *\n     * @param  len\n     *         Maximum number of characters to read\n     *\n     * @return  The number of bytes read, or -1 if the end of the stream has\n     *          already been reached\n     *\n     * @throws  IOException\n     *          If an I/O error occurs\n     *\n     * @throws  IndexOutOfBoundsException {@inheritDoc}\n     ",
    "links" : [ ]
  }, {
    "name" : "public String readLine() throws IOException",
    "returnType" : "String",
    "comment" : "\n     * Read a line of text.  Whenever a <a href=\"#lt\">line terminator</a> is\n     * read the current line number is incremented.\n     *\n     * @return  A String containing the contents of the line, not including\n     *          any <a href=\"#lt\">line termination characters</a>, or\n     *          {@code null} if the end of the stream has been reached\n     *\n     * @throws  IOException\n     *          If an I/O error occurs\n     ",
    "links" : [ ]
  }, {
    "name" : "public long skip(long n) throws IOException",
    "returnType" : "long",
    "comment" : "\n     * Skip characters.\n     *\n     * @param  n\n     *         The number of characters to skip\n     *\n     * @return  The number of characters actually skipped\n     *\n     * @throws  IOException\n     *          If an I/O error occurs\n     *\n     * @throws  IllegalArgumentException\n     *          If {@code n} is negative\n     ",
    "links" : [ ]
  }, {
    "name" : "public void mark(int readAheadLimit) throws IOException",
    "returnType" : "void",
    "comment" : "\n     * Mark the present position in the stream.  Subsequent calls to reset()\n     * will attempt to reposition the stream to this point, and will also reset\n     * the line number appropriately.\n     *\n     * @param  readAheadLimit\n     *         Limit on the number of characters that may be read while still\n     *         preserving the mark.  After reading this many characters,\n     *         attempting to reset the stream may fail.\n     *\n     * @throws  IOException\n     *          If an I/O error occurs\n     ",
    "links" : [ ]
  }, {
    "name" : "public void reset() throws IOException",
    "returnType" : "void",
    "comment" : "\n     * Reset the stream to the most recent mark.\n     *\n     * @throws  IOException\n     *          If the stream has not been marked, or if the mark has been\n     *          invalidated\n     ",
    "links" : [ ]
  } ],
  "methodNames" : [ "public void setLineNumber(int lineNumber)", "public int getLineNumber()", "public int read() throws IOException", "public int read(char[] cbuf, int off, int len) throws IOException", "public String readLine() throws IOException", "public long skip(long n) throws IOException", "public void mark(int readAheadLimit) throws IOException", "public void reset() throws IOException" ],
  "variableNames" : [ "lineNumber", "markedLineNumber", "skipLF", "markedSkipLF", "maxSkipBufferSize", "skipBuffer" ]
}