{
  "filePath" : "/home/maryam/clearblue/files/android-source-30/android/text/SpannableStringBuilder.java",
  "packageName" : "android.text",
  "className" : "SpannableStringBuilder",
  "comment" : "\n * This is the class for text whose content and markup can both be changed.\n ",
  "variables" : [ {
    "name" : "TAG",
    "type" : "String",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "NO_FILTERS",
    "type" : "InputFilter[]",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "sCachedIntBuffer",
    "type" : "int[][]",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mFilters",
    "type" : "InputFilter[]",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mText",
    "type" : "char[]",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mGapStart",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mGapLength",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mSpans",
    "type" : "Object[]",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mSpanStarts",
    "type" : "int[]",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mSpanEnds",
    "type" : "int[]",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mSpanMax",
    "type" : "int[]",
    "comment" : " see calcMax() for an explanation of what this array stores",
    "links" : [ ]
  }, {
    "name" : "mSpanFlags",
    "type" : "int[]",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mSpanOrder",
    "type" : "int[]",
    "comment" : " store the order of span insertion",
    "links" : [ ]
  }, {
    "name" : "mSpanInsertCount",
    "type" : "int",
    "comment" : " counter for the span insertion",
    "links" : [ ]
  }, {
    "name" : "mSpanCount",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mIndexOfSpan",
    "type" : "IdentityHashMap<Object, Integer>",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mLowWaterMark",
    "type" : "int",
    "comment" : " indices below this have not been touched",
    "links" : [ ]
  }, {
    "name" : "mTextWatcherDepth",
    "type" : "int",
    "comment" : " how deep the callbacks go.",
    "links" : [ ]
  }, {
    "name" : "MARK",
    "type" : "int",
    "comment" : " TODO These value are tightly related to the public SPAN_MARK/POINT values in {@link Spanned}",
    "links" : [ "Spanned" ]
  }, {
    "name" : "POINT",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "PARAGRAPH",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "START_MASK",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "END_MASK",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "START_SHIFT",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "SPAN_ADDED",
    "type" : "int",
    "comment" : " These bits are not (currently) used by SPANNED flags",
    "links" : [ ]
  }, {
    "name" : "SPAN_START_AT_START",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "SPAN_START_AT_END",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "SPAN_END_AT_START",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "SPAN_END_AT_END",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "SPAN_START_END_MASK",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  } ],
  "methods" : [ {
    "name" : "public static SpannableStringBuilder valueOf(CharSequence source)",
    "returnType" : "SpannableStringBuilder",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public char charAt(int where)",
    "returnType" : "char",
    "comment" : "\n     * Return the char at the specified offset within the buffer.\n     ",
    "links" : [ ]
  }, {
    "name" : "public int length()",
    "returnType" : "int",
    "comment" : "\n     * Return the number of chars in the buffer.\n     ",
    "links" : [ ]
  }, {
    "name" : "private void resizeFor(int size)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private void moveGapTo(int where)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public SpannableStringBuilder insert(int where, CharSequence tb, int start, int end)",
    "returnType" : "SpannableStringBuilder",
    "comment" : " Documentation from interface",
    "links" : [ ]
  }, {
    "name" : "public SpannableStringBuilder insert(int where, CharSequence tb)",
    "returnType" : "SpannableStringBuilder",
    "comment" : " Documentation from interface",
    "links" : [ ]
  }, {
    "name" : "public SpannableStringBuilder delete(int start, int end)",
    "returnType" : "SpannableStringBuilder",
    "comment" : " Documentation from interface",
    "links" : [ ]
  }, {
    "name" : "public void clear()",
    "returnType" : "void",
    "comment" : " Documentation from interface",
    "links" : [ ]
  }, {
    "name" : "public void clearSpans()",
    "returnType" : "void",
    "comment" : " Documentation from interface",
    "links" : [ ]
  }, {
    "name" : "public SpannableStringBuilder append(CharSequence text)",
    "returnType" : "SpannableStringBuilder",
    "comment" : " Documentation from interface",
    "links" : [ ]
  }, {
    "name" : "public SpannableStringBuilder append(CharSequence text, Object what, int flags)",
    "returnType" : "SpannableStringBuilder",
    "comment" : "\n     * Appends the character sequence {@code text} and spans {@code what} over the appended part.\n     * See {@link Spanned} for an explanation of what the flags mean.\n     * @param text the character sequence to append.\n     * @param what the object to be spanned over the appended text.\n     * @param flags see {@link Spanned}.\n     * @return this {@code SpannableStringBuilder}.\n     ",
    "links" : [ "Spanned", "Spanned" ]
  }, {
    "name" : "public SpannableStringBuilder append(CharSequence text, int start, int end)",
    "returnType" : "SpannableStringBuilder",
    "comment" : " Documentation from interface",
    "links" : [ ]
  }, {
    "name" : "public SpannableStringBuilder append(char text)",
    "returnType" : "SpannableStringBuilder",
    "comment" : " Documentation from interface",
    "links" : [ ]
  }, {
    "name" : "private boolean removeSpansForChange(int start, int end, boolean textIsRemoved, int i)",
    "returnType" : "boolean",
    "comment" : " Returns true if a node was removed (so we can restart search from root)",
    "links" : [ ]
  }, {
    "name" : "private void change(int start, int end, CharSequence cs, int csStart, int csEnd)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private int updatedIntervalBound(int offset, int start, int nbNewChars, int flag, boolean atEnd, boolean textIsRemoved)",
    "returnType" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private void removeSpan(int i, int flags)",
    "returnType" : "void",
    "comment" : " Note: caller is responsible for removing the mIndexOfSpan entry.",
    "links" : [ ]
  }, {
    "name" : "public SpannableStringBuilder replace(int start, int end, CharSequence tb)",
    "returnType" : "SpannableStringBuilder",
    "comment" : " Documentation from interface",
    "links" : [ ]
  }, {
    "name" : "public SpannableStringBuilder replace(final int start, final int end, CharSequence tb, int tbstart, int tbend)",
    "returnType" : "SpannableStringBuilder",
    "comment" : " Documentation from interface",
    "links" : [ ]
  }, {
    "name" : "private static boolean hasNonExclusiveExclusiveSpanAt(CharSequence text, int offset)",
    "returnType" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private void sendToSpanWatchers(int replaceStart, int replaceEnd, int nbNewChars)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public void setSpan(Object what, int start, int end, int flags)",
    "returnType" : "void",
    "comment" : "\n     * Mark the specified range of text with the specified object.\n     * The flags determine how the span will behave when text is\n     * inserted at the start or end of the span's range.\n     ",
    "links" : [ ]
  }, {
    "name" : "private void setSpan(boolean send, Object what, int start, int end, int flags, boolean enforceParagraph)",
    "returnType" : "void",
    "comment" : " will not change the index of any spans.",
    "links" : [ ]
  }, {
    "name" : "private boolean isInvalidParagraph(int index, int flag)",
    "returnType" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public void removeSpan(Object what)",
    "returnType" : "void",
    "comment" : "\n     * Remove the specified markup object from the buffer.\n     ",
    "links" : [ ]
  }, {
    "name" : "public void removeSpan(Object what, int flags)",
    "returnType" : "void",
    "comment" : "\n     * Remove the specified markup object from the buffer.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "private int resolveGap(int i)",
    "returnType" : "int",
    "comment" : "\n     * Return externally visible offset given offset into gapped buffer.\n     ",
    "links" : [ ]
  }, {
    "name" : "public int getSpanStart(Object what)",
    "returnType" : "int",
    "comment" : "\n     * Return the buffer offset of the beginning of the specified\n     * markup object, or -1 if it is not attached to this buffer.\n     ",
    "links" : [ ]
  }, {
    "name" : "public int getSpanEnd(Object what)",
    "returnType" : "int",
    "comment" : "\n     * Return the buffer offset of the end of the specified\n     * markup object, or -1 if it is not attached to this buffer.\n     ",
    "links" : [ ]
  }, {
    "name" : "public int getSpanFlags(Object what)",
    "returnType" : "int",
    "comment" : "\n     * Return the flags of the end of the specified\n     * markup object, or 0 if it is not attached to this buffer.\n     ",
    "links" : [ ]
  }, {
    "name" : "public T[] getSpans(int queryStart, int queryEnd, @Nullable Class<T> kind)",
    "returnType" : "T[]",
    "comment" : "\n     * Return an array of the spans of the specified type that overlap\n     * the specified range of the buffer.  The kind may be Object.class to get\n     * a list of all the spans regardless of type.\n     ",
    "links" : [ ]
  }, {
    "name" : "public T[] getSpans(int queryStart, int queryEnd, @Nullable Class<T> kind, boolean sortByInsertionOrder)",
    "returnType" : "T[]",
    "comment" : "\n     * Return an array of the spans of the specified type that overlap\n     * the specified range of the buffer.  The kind may be Object.class to get\n     * a list of all the spans regardless of type.\n     *\n     * @param queryStart Start index.\n     * @param queryEnd End index.\n     * @param kind Class type to search for.\n     * @param sortByInsertionOrder If true the results are sorted by the insertion order.\n     * @param <T>\n     * @return Array of the spans. Empty array if no results are found.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "private int countSpans(int queryStart, int queryEnd, Class kind, int i)",
    "returnType" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private int getSpansRec(int queryStart, int queryEnd, Class<T> kind, int i, T[] ret, int[] priority, int[] insertionOrder, int count, boolean sort)",
    "returnType" : "int",
    "comment" : "\n     * Fills the result array with the spans found under the current interval tree node.\n     *\n     * @param queryStart Start index for the interval query.\n     * @param queryEnd End index for the interval query.\n     * @param kind Class type to search for.\n     * @param i Index of the current tree node.\n     * @param ret Array to be filled with results.\n     * @param priority Buffer to keep record of the priorities of spans found.\n     * @param insertionOrder Buffer to keep record of the insertion orders of spans found.\n     * @param count The number of found spans.\n     * @param sort Flag to fill the priority and insertion order buffers. If false then\n     *             the spans with priority flag will be sorted in the result array.\n     * @param <T>\n     * @return The total number of spans found.\n     ",
    "links" : [ ]
  }, {
    "name" : "private static int[] obtain(final int elementCount)",
    "returnType" : "int[]",
    "comment" : "\n     * Obtain a temporary sort buffer.\n     *\n     * @param elementCount the size of the int[] to be returned\n     * @return an int[] with elementCount length\n     ",
    "links" : [ ]
  }, {
    "name" : "private static void recycle(int[] buffer)",
    "returnType" : "void",
    "comment" : "\n     * Recycle sort buffer.\n     *\n     * @param buffer buffer to be recycled\n     ",
    "links" : [ ]
  }, {
    "name" : "private static int[] checkSortBuffer(int[] buffer, int size)",
    "returnType" : "int[]",
    "comment" : "\n     * Check the size of the buffer and grow if required.\n     *\n     * @param buffer buffer to be checked.\n     * @param size   required size.\n     * @return Same buffer instance if the current size is greater than required size. Otherwise a\n     * new instance is created and returned.\n     ",
    "links" : [ ]
  }, {
    "name" : "private final void sort(T[] array, int[] priority, int[] insertionOrder)",
    "returnType" : "void",
    "comment" : "\n     * An iterative heap sort implementation. It will sort the spans using first their priority\n     * then insertion order. A span with higher priority will be before a span with lower\n     * priority. If priorities are the same, the spans will be sorted with insertion order. A\n     * span with a lower insertion order will be before a span with a higher insertion order.\n     *\n     * @param array Span array to be sorted.\n     * @param priority Priorities of the spans\n     * @param insertionOrder Insertion orders of the spans\n     * @param <T> Span object type.\n     * @param <T>\n     ",
    "links" : [ ]
  }, {
    "name" : "private final void siftDown(int index, T[] array, int size, int[] priority, int[] insertionOrder)",
    "returnType" : "void",
    "comment" : "\n     * Helper function for heap sort.\n     *\n     * @param index Index of the element to sift down.\n     * @param array Span array to be sorted.\n     * @param size Current heap size.\n     * @param priority Priorities of the spans\n     * @param insertionOrder Insertion orders of the spans\n     * @param <T> Span object type.\n     ",
    "links" : [ ]
  }, {
    "name" : "private final int compareSpans(int left, int right, int[] priority, int[] insertionOrder)",
    "returnType" : "int",
    "comment" : "\n     * Compare two span elements in an array. Comparison is based first on the priority flag of\n     * the span, and then the insertion order of the span.\n     *\n     * @param left Index of the element to compare.\n     * @param right Index of the other element to compare.\n     * @param priority Priorities of the spans\n     * @param insertionOrder Insertion orders of the spans\n     * @return\n     ",
    "links" : [ ]
  }, {
    "name" : "public int nextSpanTransition(int start, int limit, Class kind)",
    "returnType" : "int",
    "comment" : "\n     * Return the next offset after <code>start</code> but less than or\n     * equal to <code>limit</code> where a span of the specified type\n     * begins or ends.\n     ",
    "links" : [ ]
  }, {
    "name" : "private int nextSpanTransitionRec(int start, int limit, Class kind, int i)",
    "returnType" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public CharSequence subSequence(int start, int end)",
    "returnType" : "CharSequence",
    "comment" : "\n     * Return a new CharSequence containing a copy of the specified\n     * range of this buffer, including the overlapping spans.\n     ",
    "links" : [ ]
  }, {
    "name" : "public void getChars(int start, int end, char[] dest, int destoff)",
    "returnType" : "void",
    "comment" : "\n     * Copy the specified range of chars from this buffer into the\n     * specified array, beginning at the specified offset.\n     ",
    "links" : [ ]
  }, {
    "name" : "public String toString()",
    "returnType" : "String",
    "comment" : "\n     * Return a String containing a copy of the chars in this buffer.\n     ",
    "links" : [ ]
  }, {
    "name" : "public String substring(int start, int end)",
    "returnType" : "String",
    "comment" : "\n     * Return a String containing a copy of the chars in this buffer, limited to the\n     * [start, end[ range.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public int getTextWatcherDepth()",
    "returnType" : "int",
    "comment" : "\n     * Returns the depth of TextWatcher callbacks. Returns 0 when the object is not handling\n     * TextWatchers. A return value greater than 1 implies that a TextWatcher caused a change that\n     * recursively triggered a TextWatcher.\n     ",
    "links" : [ ]
  }, {
    "name" : "private void sendBeforeTextChanged(TextWatcher[] watchers, int start, int before, int after)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private void sendTextChanged(TextWatcher[] watchers, int start, int before, int after)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private void sendAfterTextChanged(TextWatcher[] watchers)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private void sendSpanAdded(Object what, int start, int end)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private void sendSpanRemoved(Object what, int start, int end)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private void sendSpanChanged(Object what, int oldStart, int oldEnd, int start, int end)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private static String region(int start, int end)",
    "returnType" : "String",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private void checkRange(final String operation, int start, int end)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public void drawText(BaseCanvas c, int start, int end, float x, float y, Paint p)",
    "returnType" : "void",
    "comment" : "\n     * Don't call this yourself -- exists for Canvas to use internally.\n     * {@hide}\n     ",
    "links" : [ ]
  }, {
    "name" : "public void drawTextRun(BaseCanvas c, int start, int end, int contextStart, int contextEnd, float x, float y, boolean isRtl, Paint p)",
    "returnType" : "void",
    "comment" : "\n     * Don't call this yourself -- exists for Canvas to use internally.\n     * {@hide}\n     ",
    "links" : [ ]
  }, {
    "name" : "public float measureText(int start, int end, Paint p)",
    "returnType" : "float",
    "comment" : "\n     * Don't call this yourself -- exists for Paint to use internally.\n     * {@hide}\n     ",
    "links" : [ ]
  }, {
    "name" : "public int getTextWidths(int start, int end, float[] widths, Paint p)",
    "returnType" : "int",
    "comment" : "\n     * Don't call this yourself -- exists for Paint to use internally.\n     * {@hide}\n     ",
    "links" : [ ]
  }, {
    "name" : "public float getTextRunAdvances(int start, int end, int contextStart, int contextEnd, boolean isRtl, float[] advances, int advancesPos, Paint p)",
    "returnType" : "float",
    "comment" : "\n     * Don't call this yourself -- exists for Paint to use internally.\n     * {@hide}\n     ",
    "links" : [ ]
  }, {
    "name" : "public int getTextRunCursor(int contextStart, int contextEnd, int dir, int offset, int cursorOpt, Paint p)",
    "returnType" : "int",
    "comment" : "\n     * Returns the next cursor position in the run.  This avoids placing the cursor between\n     * surrogates, between characters that form conjuncts, between base characters and combining\n     * marks, or within a reordering cluster.\n     *\n     * <p>The context is the shaping context for cursor movement, generally the bounds of the metric\n     * span enclosing the cursor in the direction of movement.\n     * <code>contextStart</code>, <code>contextEnd</code> and <code>offset</code> are relative to\n     * the start of the string.</p>\n     *\n     * <p>If cursorOpt is CURSOR_AT and the offset is not a valid cursor position,\n     * this returns -1.  Otherwise this will never return a value before contextStart or after\n     * contextEnd.</p>\n     *\n     * @param contextStart the start index of the context\n     * @param contextEnd the (non-inclusive) end index of the context\n     * @param dir 1 if the run is RTL, otherwise 0\n     * @param offset the cursor position to move from\n     * @param cursorOpt how to move the cursor, one of CURSOR_AFTER,\n     * CURSOR_AT_OR_AFTER, CURSOR_BEFORE,\n     * CURSOR_AT_OR_BEFORE, or CURSOR_AT\n     * @param p the Paint object that is requesting this information\n     * @return the offset of the next position, or -1\n     * @deprecated This is an internal method, refrain from using it in your code\n     ",
    "links" : [ ]
  }, {
    "name" : "public int getTextRunCursor(int contextStart, int contextEnd, boolean isRtl, int offset, int cursorOpt, Paint p)",
    "returnType" : "int",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "public void setFilters(InputFilter[] filters)",
    "returnType" : "void",
    "comment" : " Documentation from interface",
    "links" : [ ]
  }, {
    "name" : "public InputFilter[] getFilters()",
    "returnType" : "InputFilter[]",
    "comment" : " Documentation from interface",
    "links" : [ ]
  }, {
    "name" : "public boolean equals(Object o)",
    "returnType" : "boolean",
    "comment" : " Same as SpannableStringInternal",
    "links" : [ ]
  }, {
    "name" : "public int hashCode()",
    "returnType" : "int",
    "comment" : " Same as SpannableStringInternal",
    "links" : [ ]
  }, {
    "name" : "private int treeRoot()",
    "returnType" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private static int leftChild(int i)",
    "returnType" : "int",
    "comment" : " (i+1) & ~i is equal to 2^(the number of trailing ones in i)",
    "links" : [ ]
  }, {
    "name" : "private static int rightChild(int i)",
    "returnType" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private int calcMax(int i)",
    "returnType" : "int",
    "comment" : " descendants. This is a consequence of the perfect binary tree structure.",
    "links" : [ ]
  }, {
    "name" : "private void restoreInvariants()",
    "returnType" : "void",
    "comment" : " restores binary interval tree invariants after any mutation of span structure",
    "links" : [ ]
  }, {
    "name" : "private void invalidateIndex(int i)",
    "returnType" : "void",
    "comment" : " Call this on any update to mSpans[], so that mIndexOfSpan can be updated",
    "links" : [ ]
  } ],
  "variableNames" : [ "TAG", "NO_FILTERS", "sCachedIntBuffer", "mFilters", "mText", "mGapStart", "mGapLength", "mSpans", "mSpanStarts", "mSpanEnds", "mSpanMax", "mSpanFlags", "mSpanOrder", "mSpanInsertCount", "mSpanCount", "mIndexOfSpan", "mLowWaterMark", "mTextWatcherDepth", "MARK", "POINT", "PARAGRAPH", "START_MASK", "END_MASK", "START_SHIFT", "SPAN_ADDED", "SPAN_START_AT_START", "SPAN_START_AT_END", "SPAN_END_AT_START", "SPAN_END_AT_END", "SPAN_START_END_MASK" ],
  "methodNames" : [ "public static SpannableStringBuilder valueOf(CharSequence source)", "public char charAt(int where)", "public int length()", "private void resizeFor(int size)", "private void moveGapTo(int where)", "public SpannableStringBuilder insert(int where, CharSequence tb, int start, int end)", "public SpannableStringBuilder insert(int where, CharSequence tb)", "public SpannableStringBuilder delete(int start, int end)", "public void clear()", "public void clearSpans()", "public SpannableStringBuilder append(CharSequence text)", "public SpannableStringBuilder append(CharSequence text, Object what, int flags)", "public SpannableStringBuilder append(CharSequence text, int start, int end)", "public SpannableStringBuilder append(char text)", "private boolean removeSpansForChange(int start, int end, boolean textIsRemoved, int i)", "private void change(int start, int end, CharSequence cs, int csStart, int csEnd)", "private int updatedIntervalBound(int offset, int start, int nbNewChars, int flag, boolean atEnd, boolean textIsRemoved)", "private void removeSpan(int i, int flags)", "public SpannableStringBuilder replace(int start, int end, CharSequence tb)", "public SpannableStringBuilder replace(final int start, final int end, CharSequence tb, int tbstart, int tbend)", "private static boolean hasNonExclusiveExclusiveSpanAt(CharSequence text, int offset)", "private void sendToSpanWatchers(int replaceStart, int replaceEnd, int nbNewChars)", "public void setSpan(Object what, int start, int end, int flags)", "private void setSpan(boolean send, Object what, int start, int end, int flags, boolean enforceParagraph)", "private boolean isInvalidParagraph(int index, int flag)", "public void removeSpan(Object what)", "public void removeSpan(Object what, int flags)", "private int resolveGap(int i)", "public int getSpanStart(Object what)", "public int getSpanEnd(Object what)", "public int getSpanFlags(Object what)", "public T[] getSpans(int queryStart, int queryEnd, @Nullable Class<T> kind)", "public T[] getSpans(int queryStart, int queryEnd, @Nullable Class<T> kind, boolean sortByInsertionOrder)", "private int countSpans(int queryStart, int queryEnd, Class kind, int i)", "private int getSpansRec(int queryStart, int queryEnd, Class<T> kind, int i, T[] ret, int[] priority, int[] insertionOrder, int count, boolean sort)", "private static int[] obtain(final int elementCount)", "private static void recycle(int[] buffer)", "private static int[] checkSortBuffer(int[] buffer, int size)", "private final void sort(T[] array, int[] priority, int[] insertionOrder)", "private final void siftDown(int index, T[] array, int size, int[] priority, int[] insertionOrder)", "private final int compareSpans(int left, int right, int[] priority, int[] insertionOrder)", "public int nextSpanTransition(int start, int limit, Class kind)", "private int nextSpanTransitionRec(int start, int limit, Class kind, int i)", "public CharSequence subSequence(int start, int end)", "public void getChars(int start, int end, char[] dest, int destoff)", "public String toString()", "public String substring(int start, int end)", "public int getTextWatcherDepth()", "private void sendBeforeTextChanged(TextWatcher[] watchers, int start, int before, int after)", "private void sendTextChanged(TextWatcher[] watchers, int start, int before, int after)", "private void sendAfterTextChanged(TextWatcher[] watchers)", "private void sendSpanAdded(Object what, int start, int end)", "private void sendSpanRemoved(Object what, int start, int end)", "private void sendSpanChanged(Object what, int oldStart, int oldEnd, int start, int end)", "private static String region(int start, int end)", "private void checkRange(final String operation, int start, int end)", "public void drawText(BaseCanvas c, int start, int end, float x, float y, Paint p)", "public void drawTextRun(BaseCanvas c, int start, int end, int contextStart, int contextEnd, float x, float y, boolean isRtl, Paint p)", "public float measureText(int start, int end, Paint p)", "public int getTextWidths(int start, int end, float[] widths, Paint p)", "public float getTextRunAdvances(int start, int end, int contextStart, int contextEnd, boolean isRtl, float[] advances, int advancesPos, Paint p)", "public int getTextRunCursor(int contextStart, int contextEnd, int dir, int offset, int cursorOpt, Paint p)", "public int getTextRunCursor(int contextStart, int contextEnd, boolean isRtl, int offset, int cursorOpt, Paint p)", "public void setFilters(InputFilter[] filters)", "public InputFilter[] getFilters()", "public boolean equals(Object o)", "public int hashCode()", "private int treeRoot()", "private static int leftChild(int i)", "private static int rightChild(int i)", "private int calcMax(int i)", "private void restoreInvariants()", "private void invalidateIndex(int i)" ]
}