{
  "filePath" : "/home/maryam/clearblue/files/android-source-35/android/graphics/ColorSpace.java",
  "packageName" : "android.graphics",
  "className" : "ColorSpace",
  "comment" : "\n * {@usesMathJax}\n *\n * <p>A {@link ColorSpace} is used to identify a specific organization of colors.\n * Each color space is characterized by a {@link Model color model} that defines\n * how a color value is represented (for instance the {@link Model#RGB RGB} color\n * model defines a color value as a triplet of numbers).</p>\n *\n * <p>Each component of a color must fall within a valid range, specific to each\n * color space, defined by {@link #getMinValue(int)} and {@link #getMaxValue(int)}\n * This range is commonly \\([0..1]\\). While it is recommended to use values in the\n * valid range, a color space always clamps input and output values when performing\n * operations such as converting to a different color space.</p>\n *\n * <h3>Using color spaces</h3>\n *\n * <p>This implementation provides a pre-defined set of common color spaces\n * described in the {@link Named} enum. To obtain an instance of one of the\n * pre-defined color spaces, simply invoke {@link #get(Named)}:</p>\n *\n * <pre class=\"prettyprint\">\n * ColorSpace sRgb = ColorSpace.get(ColorSpace.Named.SRGB);\n * </pre>\n *\n * <p>The {@link #get(Named)} method always returns the same instance for a given\n * name. Color spaces with an {@link Model#RGB RGB} color model can be safely\n * cast to {@link Rgb}. Doing so gives you access to more APIs to query various\n * properties of RGB color models: color gamut primaries, transfer functions,\n * conversions to and from linear space, etc. Please refer to {@link Rgb} for\n * more information.</p>\n *\n * <p>The documentation of {@link Named} provides a detailed description of the\n * various characteristics of each available color space.</p>\n *\n * <h3>Color space conversions</h3>\n\n * <p>To allow conversion between color spaces, this implementation uses the CIE\n * XYZ profile connection space (PCS). Color values can be converted to and from\n * this PCS using {@link #toXyz(float[])} and {@link #fromXyz(float[])}.</p>\n *\n * <p>For color space with a non-RGB color model, the white point of the PCS\n * <em>must be</em> the CIE standard illuminant D50. RGB color spaces use their\n * native white point (D65 for {@link Named#SRGB sRGB} for instance and must\n * undergo {@link Adaptation chromatic adaptation} as necessary.</p>\n *\n * <p>Since the white point of the PCS is not defined for RGB color space, it is\n * highly recommended to use the variants of the {@link #connect(ColorSpace, ColorSpace)}\n * method to perform conversions between color spaces. A color space can be\n * manually adapted to a specific white point using {@link #adapt(ColorSpace, float[])}.\n * Please refer to the documentation of {@link Rgb RGB color spaces} for more\n * information. Several common CIE standard illuminants are provided in this\n * class as reference (see {@link #ILLUMINANT_D65} or {@link #ILLUMINANT_D50}\n * for instance).</p>\n *\n * <p>Here is an example of how to convert from a color space to another:</p>\n *\n * <pre class=\"prettyprint\">\n * // Convert from DCI-P3 to Rec.2020\n * ColorSpace.Connector connector = ColorSpace.connect(\n *         ColorSpace.get(ColorSpace.Named.DCI_P3),\n *         ColorSpace.get(ColorSpace.Named.BT2020));\n *\n * float[] bt2020 = connector.transform(p3r, p3g, p3b);\n * </pre>\n *\n * <p>You can easily convert to {@link Named#SRGB sRGB} by omitting the second\n * parameter:</p>\n *\n * <pre class=\"prettyprint\">\n * // Convert from DCI-P3 to sRGB\n * ColorSpace.Connector connector = ColorSpace.connect(ColorSpace.get(ColorSpace.Named.DCI_P3));\n *\n * float[] sRGB = connector.transform(p3r, p3g, p3b);\n * </pre>\n *\n * <p>Conversions also work between color spaces with different color models:</p>\n *\n * <pre class=\"prettyprint\">\n * // Convert from CIE L*a*b* (color model Lab) to Rec.709 (color model RGB)\n * ColorSpace.Connector connector = ColorSpace.connect(\n *         ColorSpace.get(ColorSpace.Named.CIE_LAB),\n *         ColorSpace.get(ColorSpace.Named.BT709));\n * </pre>\n *\n * <h3>Color spaces and multi-threading</h3>\n *\n * <p>Color spaces and other related classes ({@link Connector} for instance)\n * are immutable and stateless. They can be safely used from multiple concurrent\n * threads.</p>\n *\n * <p>Public static methods provided by this class, such as {@link #get(Named)}\n * and {@link #connect(ColorSpace, ColorSpace)}, are also guaranteed to be\n * thread-safe.</p>\n *\n * @see #get(Named)\n * @see Named\n * @see Model\n * @see Connector\n * @see Adaptation\n ",
  "links" : [ "Named", "Connector", "#getMinValue(int)", "#ILLUMINANT_D50", "#SRGB", "#ILLUMINANT_D65", "Rgb", "#toXyz(float", "#fromXyz(float", "#get(Named)", "#getMaxValue(int)", "Model", "#connect(ColorSpace", "android.graphics.ColorSpace", "#RGB", "#adapt(ColorSpace", "Adaptation" ],
  "variables" : [ {
    "name" : "ILLUMINANT_A",
    "type" : "float[]",
    "comment" : "\n     * Standard CIE 1931 2° illuminant A, encoded in xyY.\n     * This illuminant has a color temperature of 2856K.\n     ",
    "links" : [ ]
  }, {
    "name" : "ILLUMINANT_B",
    "type" : "float[]",
    "comment" : "\n     * Standard CIE 1931 2° illuminant B, encoded in xyY.\n     * This illuminant has a color temperature of 4874K.\n     ",
    "links" : [ ]
  }, {
    "name" : "ILLUMINANT_C",
    "type" : "float[]",
    "comment" : "\n     * Standard CIE 1931 2° illuminant C, encoded in xyY.\n     * This illuminant has a color temperature of 6774K.\n     ",
    "links" : [ ]
  }, {
    "name" : "ILLUMINANT_D50",
    "type" : "float[]",
    "comment" : "\n     * Standard CIE 1931 2° illuminant D50, encoded in xyY.\n     * This illuminant has a color temperature of 5003K. This illuminant\n     * is used by the profile connection space in ICC profiles.\n     ",
    "links" : [ ]
  }, {
    "name" : "ILLUMINANT_D55",
    "type" : "float[]",
    "comment" : "\n     * Standard CIE 1931 2° illuminant D55, encoded in xyY.\n     * This illuminant has a color temperature of 5503K.\n     ",
    "links" : [ ]
  }, {
    "name" : "ILLUMINANT_D60",
    "type" : "float[]",
    "comment" : "\n     * Standard CIE 1931 2° illuminant D60, encoded in xyY.\n     * This illuminant has a color temperature of 6004K.\n     ",
    "links" : [ ]
  }, {
    "name" : "ILLUMINANT_D65",
    "type" : "float[]",
    "comment" : "\n     * Standard CIE 1931 2° illuminant D65, encoded in xyY.\n     * This illuminant has a color temperature of 6504K. This illuminant\n     * is commonly used in RGB color spaces such as sRGB, BT.709, etc.\n     ",
    "links" : [ ]
  }, {
    "name" : "ILLUMINANT_D75",
    "type" : "float[]",
    "comment" : "\n     * Standard CIE 1931 2° illuminant D75, encoded in xyY.\n     * This illuminant has a color temperature of 7504K.\n     ",
    "links" : [ ]
  }, {
    "name" : "ILLUMINANT_E",
    "type" : "float[]",
    "comment" : "\n     * Standard CIE 1931 2° illuminant E, encoded in xyY.\n     * This illuminant has a color temperature of 5454K.\n     ",
    "links" : [ ]
  }, {
    "name" : "MIN_ID",
    "type" : "int",
    "comment" : " Do not change",
    "links" : [ ]
  }, {
    "name" : "MAX_ID",
    "type" : "int",
    "comment" : " Do not change, used to encode in longs",
    "links" : [ ]
  }, {
    "name" : "SRGB_PRIMARIES",
    "type" : "float[]",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "NTSC_1953_PRIMARIES",
    "type" : "float[]",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "DCI_P3_PRIMARIES",
    "type" : "float[]",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "BT2020_PRIMARIES",
    "type" : "float[]",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "GRAY_PRIMARIES",
    "type" : "float[]",
    "comment" : "\n     * A gray color space does not have meaningful primaries, so we use this arbitrary set.\n     ",
    "links" : [ ]
  }, {
    "name" : "ILLUMINANT_D50_XYZ",
    "type" : "float[]",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "SRGB_TRANSFER_PARAMETERS",
    "type" : "Rgb.TransferParameters",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "SMPTE_170M_TRANSFER_PARAMETERS",
    "type" : "Rgb.TransferParameters",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "BT2020_HLG_TRANSFER_PARAMETERS",
    "type" : "Rgb.TransferParameters",
    "comment" : " HLG transfer with an SDR whitepoint of 203 nits",
    "links" : [ ]
  }, {
    "name" : "BT2020_PQ_TRANSFER_PARAMETERS",
    "type" : "Rgb.TransferParameters",
    "comment" : " PQ transfer with an SDR whitepoint of 203 nits",
    "links" : [ ]
  }, {
    "name" : "sNamedColorSpaces",
    "type" : "ColorSpace[]",
    "comment" : " See static initialization block next to #get(Named)",
    "links" : [ ]
  }, {
    "name" : "sDataToColorSpaces",
    "type" : "SparseIntArray",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mName",
    "type" : "String",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mModel",
    "type" : "Model",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mId",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  } ],
  "methods" : [ {
    "name" : "public String getName()",
    "returnType" : "String",
    "comment" : "\n     * <p>Returns the name of this color space. The name is never null\n     * and contains always at least 1 character.</p>\n     *\n     * <p>Color space names are recommended to be unique but are not\n     * guaranteed to be. There is no defined format but the name usually\n     * falls in one of the following categories:</p>\n     * <ul>\n     *     <li>Generic names used to identify color spaces in non-RGB\n     *     color models. For instance: {@link Named#CIE_LAB Generic L*a*b*}.</li>\n     *     <li>Names tied to a particular specification. For instance:\n     *     {@link Named#SRGB sRGB IEC61966-2.1} or\n     *     {@link Named#ACES SMPTE ST 2065-1:2012 ACES}.</li>\n     *     <li>Ad-hoc names, often generated procedurally or by the user\n     *     during a calibration workflow. These names often contain the\n     *     make and model of the display.</li>\n     * </ul>\n     *\n     * <p>Because the format of color space names is not defined, it is\n     * not recommended to programmatically identify a color space by its\n     * name alone. Names can be used as a first approximation.</p>\n     *\n     * <p>It is however perfectly acceptable to display color space names to\n     * users in a UI, or in debuggers and logs. When displaying a color space\n     * name to the user, it is recommended to add extra information to avoid\n     * ambiguities: color model, a representation of the color space's gamut,\n     * white point, etc.</p>\n     *\n     * @return A non-null String of length >= 1\n     ",
    "links" : [ "#ACES", "#SRGB", "#CIE_LAB" ]
  }, {
    "name" : "public int getId()",
    "returnType" : "int",
    "comment" : "\n     * Returns the ID of this color space. Positive IDs match the color\n     * spaces enumerated in {@link Named}. A negative ID indicates a\n     * color space created by calling one of the public constructors.\n     *\n     * @return An integer between {@link #MIN_ID} and {@link #MAX_ID}\n     ",
    "links" : [ "Named", "#MIN_ID", "#MAX_ID" ]
  }, {
    "name" : "public Model getModel()",
    "returnType" : "Model",
    "comment" : "\n     * Return the color model of this color space.\n     *\n     * @return A non-null {@link Model}\n     *\n     * @see Model\n     * @see #getComponentCount()\n     ",
    "links" : [ "Model" ]
  }, {
    "name" : "public int getComponentCount()",
    "returnType" : "int",
    "comment" : "\n     * Returns the number of components that form a color value according\n     * to this color space's color model.\n     *\n     * @return An integer between 1 and 4\n     *\n     * @see Model\n     * @see #getModel()\n     ",
    "links" : [ ]
  }, {
    "name" : "public abstract boolean isWideGamut()",
    "returnType" : "boolean",
    "comment" : "\n     * Returns whether this color space is a wide-gamut color space.\n     * An RGB color space is wide-gamut if its gamut entirely contains\n     * the {@link Named#SRGB sRGB} gamut and if the area of its gamut is\n     * 90% of greater than the area of the {@link Named#NTSC_1953 NTSC}\n     * gamut.\n     *\n     * @return True if this color space is a wide-gamut color space,\n     *         false otherwise\n     ",
    "links" : [ "#SRGB", "#NTSC_1953" ]
  }, {
    "name" : "public boolean isSrgb()",
    "returnType" : "boolean",
    "comment" : "\n     * <p>Indicates whether this color space is the sRGB color space or\n     * equivalent to the sRGB color space.</p>\n     * <p>A color space is considered sRGB if it meets all the following\n     * conditions:</p>\n     * <ul>\n     *     <li>Its color model is {@link Model#RGB}.</li>\n     *     <li>\n     *         Its primaries are within 1e-3 of the true\n     *         {@link Named#SRGB sRGB} primaries.\n     *     </li>\n     *     <li>\n     *         Its white point is within 1e-3 of the CIE standard\n     *         illuminant {@link #ILLUMINANT_D65 D65}.\n     *     </li>\n     *     <li>Its opto-electronic transfer function is not linear.</li>\n     *     <li>Its electro-optical transfer function is not linear.</li>\n     *     <li>Its transfer functions yield values within 1e-3 of {@link Named#SRGB}.</li>\n     *     <li>Its range is \\([0..1]\\).</li>\n     * </ul>\n     * <p>This method always returns true for {@link Named#SRGB}.</p>\n     *\n     * @return True if this color space is the sRGB color space (or a\n     *         close approximation), false otherwise\n     ",
    "links" : [ "#SRGB", "#ILLUMINANT_D65", "#RGB" ]
  }, {
    "name" : "public abstract float getMinValue(@IntRange(from = 0, to = 3) int component)",
    "returnType" : "float",
    "comment" : "\n     * Returns the minimum valid value for the specified component of this\n     * color space's color model.\n     *\n     * @param component The index of the component\n     * @return A floating point value less than {@link #getMaxValue(int)}\n     *\n     * @see #getMaxValue(int)\n     * @see Model#getComponentCount()\n     ",
    "links" : [ "#getMaxValue(int)" ]
  }, {
    "name" : "public abstract float getMaxValue(@IntRange(from = 0, to = 3) int component)",
    "returnType" : "float",
    "comment" : "\n     * Returns the maximum valid value for the specified component of this\n     * color space's color model.\n     *\n     * @param component The index of the component\n     * @return A floating point value greater than {@link #getMinValue(int)}\n     *\n     * @see #getMinValue(int)\n     * @see Model#getComponentCount()\n     ",
    "links" : [ "#getMinValue(int)" ]
  }, {
    "name" : "public float[] toXyz(float r, float g, float b)",
    "returnType" : "float[]",
    "comment" : "\n     * <p>Converts a color value from this color space's model to\n     * tristimulus CIE XYZ values. If the color model of this color\n     * space is not {@link Model#RGB RGB}, it is assumed that the\n     * target CIE XYZ space uses a {@link #ILLUMINANT_D50 D50}\n     * standard illuminant.</p>\n     *\n     * <p>This method is a convenience for color spaces with a model\n     * of 3 components ({@link Model#RGB RGB} or {@link Model#LAB}\n     * for instance). With color spaces using fewer or more components,\n     * use {@link #toXyz(float[])} instead</p>.\n     *\n     * @param r The first component of the value to convert from (typically R in RGB)\n     * @param g The second component of the value to convert from (typically G in RGB)\n     * @param b The third component of the value to convert from (typically B in RGB)\n     * @return A new array of 3 floats, containing tristimulus XYZ values\n     *\n     * @see #toXyz(float[])\n     * @see #fromXyz(float, float, float)\n     ",
    "links" : [ "#ILLUMINANT_D50", "#RGB", "#LAB", "#toXyz(float" ]
  }, {
    "name" : "public abstract float[] toXyz(@NonNull @Size(min = 3) float[] v)",
    "returnType" : "float[]",
    "comment" : "\n     * <p>Converts a color value from this color space's model to\n     * tristimulus CIE XYZ values. If the color model of this color\n     * space is not {@link Model#RGB RGB}, it is assumed that the\n     * target CIE XYZ space uses a {@link #ILLUMINANT_D50 D50}\n     * standard illuminant.</p>\n     *\n     * <p class=\"note\">The specified array's length  must be at least\n     * equal to to the number of color components as returned by\n     * {@link Model#getComponentCount()}.</p>\n     *\n     * @param v An array of color components containing the color space's\n     *          color value to convert to XYZ, and large enough to hold\n     *          the resulting tristimulus XYZ values\n     * @return The array passed in parameter\n     *\n     * @see #toXyz(float, float, float)\n     * @see #fromXyz(float[])\n     ",
    "links" : [ "#ILLUMINANT_D50", "#RGB", "#getComponentCount()" ]
  }, {
    "name" : "public float[] fromXyz(float x, float y, float z)",
    "returnType" : "float[]",
    "comment" : "\n     * <p>Converts tristimulus values from the CIE XYZ space to this\n     * color space's color model.</p>\n     *\n     * @param x The X component of the color value\n     * @param y The Y component of the color value\n     * @param z The Z component of the color value\n     * @return A new array whose size is equal to the number of color\n     *         components as returned by {@link Model#getComponentCount()}\n     *\n     * @see #fromXyz(float[])\n     * @see #toXyz(float, float, float)\n     ",
    "links" : [ "#getComponentCount()" ]
  }, {
    "name" : "public abstract float[] fromXyz(@NonNull @Size(min = 3) float[] v)",
    "returnType" : "float[]",
    "comment" : "\n     * <p>Converts tristimulus values from the CIE XYZ space to this color\n     * space's color model. The resulting value is passed back in the specified\n     * array.</p>\n     *\n     * <p class=\"note\">The specified array's length  must be at least equal to\n     * to the number of color components as returned by\n     * {@link Model#getComponentCount()}, and its first 3 values must\n     * be the XYZ components to convert from.</p>\n     *\n     * @param v An array of color components containing the XYZ values\n     *          to convert from, and large enough to hold the number\n     *          of components of this color space's model\n     * @return The array passed in parameter\n     *\n     * @see #fromXyz(float, float, float)\n     * @see #toXyz(float[])\n     ",
    "links" : [ "#getComponentCount()" ]
  }, {
    "name" : "public String toString()",
    "returnType" : "String",
    "comment" : "\n     * <p>Returns a string representation of the object. This method returns\n     * a string equal to the value of:</p>\n     *\n     * <pre class=\"prettyprint\">\n     * getName() + \"(id=\" + getId() + \", model=\" + getModel() + \")\"\n     * </pre>\n     *\n     * <p>For instance, the string representation of the {@link Named#SRGB sRGB}\n     * color space is equal to the following value:</p>\n     *\n     * <pre>\n     * sRGB IEC61966-2.1 (id=0, model=RGB)\n     * </pre>\n     *\n     * @return A string representation of the object\n     ",
    "links" : [ "#SRGB" ]
  }, {
    "name" : "public boolean equals(Object o)",
    "returnType" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public int hashCode()",
    "returnType" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public static Connector connect(@NonNull ColorSpace source, @NonNull ColorSpace destination)",
    "returnType" : "Connector",
    "comment" : "\n     * <p>Connects two color spaces to allow conversion from the source color\n     * space to the destination color space. If the source and destination\n     * color spaces do not have the same profile connection space (CIE XYZ\n     * with the same white point), they are chromatically adapted to use the\n     * CIE standard illuminant {@link #ILLUMINANT_D50 D50} as needed.</p>\n     *\n     * <p>If the source and destination are the same, an optimized connector\n     * is returned to avoid unnecessary computations and loss of precision.</p>\n     *\n     * <p>Colors are mapped from the source color space to the destination color\n     * space using the {@link RenderIntent#PERCEPTUAL perceptual} render intent.</p>\n     *\n     * @param source The color space to convert colors from\n     * @param destination The color space to convert colors to\n     * @return A non-null connector between the two specified color spaces\n     *\n     * @see #connect(ColorSpace)\n     * @see #connect(ColorSpace, RenderIntent)\n     * @see #connect(ColorSpace, ColorSpace, RenderIntent)\n     ",
    "links" : [ "#ILLUMINANT_D50", "#PERCEPTUAL" ]
  }, {
    "name" : "public static Connector connect(@NonNull ColorSpace source, @NonNull ColorSpace destination, @NonNull RenderIntent intent)",
    "returnType" : "Connector",
    "comment" : "\n     * <p>Connects two color spaces to allow conversion from the source color\n     * space to the destination color space. If the source and destination\n     * color spaces do not have the same profile connection space (CIE XYZ\n     * with the same white point), they are chromatically adapted to use the\n     * CIE standard illuminant {@link #ILLUMINANT_D50 D50} as needed.</p>\n     *\n     * <p>If the source and destination are the same, an optimized connector\n     * is returned to avoid unnecessary computations and loss of precision.</p>\n     *\n     * @param source The color space to convert colors from\n     * @param destination The color space to convert colors to\n     * @param intent The render intent to map colors from the source to the destination\n     * @return A non-null connector between the two specified color spaces\n     *\n     * @see #connect(ColorSpace)\n     * @see #connect(ColorSpace, RenderIntent)\n     * @see #connect(ColorSpace, ColorSpace)\n     ",
    "links" : [ "#ILLUMINANT_D50" ]
  }, {
    "name" : "public static Connector connect(@NonNull ColorSpace source)",
    "returnType" : "Connector",
    "comment" : "\n     * <p>Connects the specified color spaces to sRGB.\n     * If the source color space does not use CIE XYZ D65 as its profile\n     * connection space, the two spaces are chromatically adapted to use the\n     * CIE standard illuminant {@link #ILLUMINANT_D50 D50} as needed.</p>\n     *\n     * <p>If the source is the sRGB color space, an optimized connector\n     * is returned to avoid unnecessary computations and loss of precision.</p>\n     *\n     * <p>Colors are mapped from the source color space to the destination color\n     * space using the {@link RenderIntent#PERCEPTUAL perceptual} render intent.</p>\n     *\n     * @param source The color space to convert colors from\n     * @return A non-null connector between the specified color space and sRGB\n     *\n     * @see #connect(ColorSpace, RenderIntent)\n     * @see #connect(ColorSpace, ColorSpace)\n     * @see #connect(ColorSpace, ColorSpace, RenderIntent)\n     ",
    "links" : [ "#ILLUMINANT_D50", "#PERCEPTUAL" ]
  }, {
    "name" : "public static Connector connect(@NonNull ColorSpace source, @NonNull RenderIntent intent)",
    "returnType" : "Connector",
    "comment" : "\n     * <p>Connects the specified color spaces to sRGB.\n     * If the source color space does not use CIE XYZ D65 as its profile\n     * connection space, the two spaces are chromatically adapted to use the\n     * CIE standard illuminant {@link #ILLUMINANT_D50 D50} as needed.</p>\n     *\n     * <p>If the source is the sRGB color space, an optimized connector\n     * is returned to avoid unnecessary computations and loss of precision.</p>\n     *\n     * @param source The color space to convert colors from\n     * @param intent The render intent to map colors from the source to the destination\n     * @return A non-null connector between the specified color space and sRGB\n     *\n     * @see #connect(ColorSpace)\n     * @see #connect(ColorSpace, ColorSpace)\n     * @see #connect(ColorSpace, ColorSpace, RenderIntent)\n     ",
    "links" : [ "#ILLUMINANT_D50" ]
  }, {
    "name" : "public static ColorSpace adapt(@NonNull ColorSpace colorSpace, @NonNull @Size(min = 2, max = 3) float[] whitePoint)",
    "returnType" : "ColorSpace",
    "comment" : "\n     * <p>Performs the chromatic adaptation of a color space from its native\n     * white point to the specified white point.</p>\n     *\n     * <p>The chromatic adaptation is performed using the\n     * {@link Adaptation#BRADFORD} matrix.</p>\n     *\n     * <p class=\"note\">The color space returned by this method always has\n     * an ID of {@link #MIN_ID}.</p>\n     *\n     * @param colorSpace The color space to chromatically adapt\n     * @param whitePoint The new white point\n     * @return A {@link ColorSpace} instance with the same name, primaries,\n     *         transfer functions and range as the specified color space\n     *\n     * @see Adaptation\n     * @see #adapt(ColorSpace, float[], Adaptation)\n     ",
    "links" : [ "#BRADFORD", "#MIN_ID", "android.graphics.ColorSpace" ]
  }, {
    "name" : "public static ColorSpace adapt(@NonNull ColorSpace colorSpace, @NonNull @Size(min = 2, max = 3) float[] whitePoint, @NonNull Adaptation adaptation)",
    "returnType" : "ColorSpace",
    "comment" : "\n     * <p>Performs the chromatic adaptation of a color space from its native\n     * white point to the specified white point. If the specified color space\n     * does not have an {@link Model#RGB RGB} color model, or if the color\n     * space already has the target white point, the color space is returned\n     * unmodified.</p>\n     *\n     * <p>The chromatic adaptation is performed using the von Kries method\n     * described in the documentation of {@link Adaptation}.</p>\n     *\n     * <p class=\"note\">The color space returned by this method always has\n     * an ID of {@link #MIN_ID}.</p>\n     *\n     * @param colorSpace The color space to chromatically adapt\n     * @param whitePoint The new white point\n     * @param adaptation The adaptation matrix\n     * @return A new color space if the specified color space has an RGB\n     *         model and a white point different from the specified white\n     *         point; the specified color space otherwise\n     *\n     * @see Adaptation\n     * @see #adapt(ColorSpace, float[])\n     ",
    "links" : [ "#MIN_ID", "#RGB", "Adaptation" ]
  }, {
    "name" : "private static float[] adaptToIlluminantD50(@NonNull @Size(2) float[] origWhitePoint, @NonNull @Size(9) float[] origTransform)",
    "returnType" : "float[]",
    "comment" : "\n     * Helper method for creating native SkColorSpace.\n     *\n     * This essentially calls adapt on a ColorSpace that has not been fully\n     * created. It also does not fully create the adapted ColorSpace, but\n     * just returns the transform.\n     ",
    "links" : [ ]
  }, {
    "name" : " static ColorSpace get(@IntRange(from = MIN_ID, to = MAX_ID) int index)",
    "returnType" : "ColorSpace",
    "comment" : "\n     * <p>Returns an instance of {@link ColorSpace} whose ID matches the\n     * specified ID.</p>\n     *\n     * <p>This method always returns the same instance for a given ID.</p>\n     *\n     * <p>This method is thread-safe.</p>\n     *\n     * @param index An integer ID between {@link #MIN_ID} and {@link #MAX_ID}\n     * @return A non-null {@link ColorSpace} instance\n     * @throws IllegalArgumentException If the ID does not match the ID of one of the\n     *         {@link Named named color spaces}\n     ",
    "links" : [ "Named", "#MIN_ID", "#MAX_ID", "android.graphics.ColorSpace" ]
  }, {
    "name" : "public static ColorSpace getFromDataSpace(@ColorDataSpace int dataSpace)",
    "returnType" : "ColorSpace",
    "comment" : "\n     * Create a {@link ColorSpace} object using a {@link android.hardware.DataSpace DataSpace}\n     * value.\n     *\n     * <p>This function maps from a dataspace to a {@link Named} ColorSpace.\n     * If no {@link Named} ColorSpace object matching the {@code dataSpace} value can be created,\n     * {@code null} will return.</p>\n     *\n     * @param dataSpace The dataspace value\n     * @return the ColorSpace object or {@code null} if no matching colorspace can be found.\n     ",
    "links" : [ "Named", "android.graphics.ColorSpace", "android.hardware.DataSpace" ]
  }, {
    "name" : "public int getDataSpace()",
    "returnType" : "int",
    "comment" : "\n     * Retrieve the {@link android.hardware.DataSpace DataSpace} value from a {@link ColorSpace}\n     * object.\n     *\n     * <p>If this {@link ColorSpace} object has no matching {@code dataSpace} value,\n     * {@link android.hardware.DataSpace#DATASPACE_UNKNOWN DATASPACE_UNKNOWN} will return.</p>\n     *\n     * @return the dataspace value.\n     ",
    "links" : [ "android.hardware.DataSpace#DATASPACE_UNKNOWN", "android.graphics.ColorSpace", "android.hardware.DataSpace" ]
  }, {
    "name" : "public static ColorSpace get(@NonNull Named name)",
    "returnType" : "ColorSpace",
    "comment" : "\n     * <p>Returns an instance of {@link ColorSpace} identified by the specified\n     * name. The list of names provided in the {@link Named} enum gives access\n     * to a variety of common RGB color spaces.</p>\n     *\n     * <p>This method always returns the same instance for a given name.</p>\n     *\n     * <p>This method is thread-safe.</p>\n     *\n     * @param name The name of the color space to get an instance of\n     * @return A non-null {@link ColorSpace} instance\n     ",
    "links" : [ "Named", "android.graphics.ColorSpace" ]
  }, {
    "name" : "public static ColorSpace match(@NonNull @Size(9) float[] toXYZD50, @NonNull Rgb.TransferParameters function)",
    "returnType" : "ColorSpace",
    "comment" : "\n     * <p>Returns a {@link Named} instance of {@link ColorSpace} that matches\n     * the specified RGB to CIE XYZ transform and transfer functions. If no\n     * instance can be found, this method returns null.</p>\n     *\n     * <p>The color transform matrix is assumed to target the CIE XYZ space\n     * a {@link #ILLUMINANT_D50 D50} standard illuminant.</p>\n     *\n     * @param toXYZD50 3x3 column-major transform matrix from RGB to the profile\n     *                 connection space CIE XYZ as an array of 9 floats, cannot be null\n     * @param function Parameters for the transfer functions\n     * @return A non-null {@link ColorSpace} if a match is found, null otherwise\n     ",
    "links" : [ "Named", "#ILLUMINANT_D50", "android.graphics.ColorSpace" ]
  }, {
    "name" : "private static double transferHLGOETF(Rgb.TransferParameters params, double x)",
    "returnType" : "double",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private static double transferHLGEOTF(Rgb.TransferParameters params, double x)",
    "returnType" : "double",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private static double transferST2048OETF(Rgb.TransferParameters params, double x)",
    "returnType" : "double",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private static double transferST2048EOTF(Rgb.TransferParameters pq, double x)",
    "returnType" : "double",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private static double rcpResponse(double x, double a, double b, double c, double d, double g)",
    "returnType" : "double",
    "comment" : " Reciprocal piecewise gamma response",
    "links" : [ ]
  }, {
    "name" : "private static double response(double x, double a, double b, double c, double d, double g)",
    "returnType" : "double",
    "comment" : " Piecewise gamma response",
    "links" : [ ]
  }, {
    "name" : "private static double rcpResponse(double x, double a, double b, double c, double d, double e, double f, double g)",
    "returnType" : "double",
    "comment" : " Reciprocal piecewise gamma response",
    "links" : [ ]
  }, {
    "name" : "private static double response(double x, double a, double b, double c, double d, double e, double f, double g)",
    "returnType" : "double",
    "comment" : " Piecewise gamma response",
    "links" : [ ]
  }, {
    "name" : "private static double absRcpResponse(double x, double a, double b, double c, double d, double g)",
    "returnType" : "double",
    "comment" : " spaces that allow negative values",
    "links" : [ ]
  }, {
    "name" : "private static double absResponse(double x, double a, double b, double c, double d, double g)",
    "returnType" : "double",
    "comment" : " allow negative values",
    "links" : [ ]
  }, {
    "name" : "private static boolean compare(@Nullable Rgb.TransferParameters a, @Nullable Rgb.TransferParameters b)",
    "returnType" : "boolean",
    "comment" : "\n     * Compares two sets of parametric transfer functions parameters with a precision of 1e-3.\n     *\n     * @param a The first set of parameters to compare\n     * @param b The second set of parameters to compare\n     * @return True if the two sets are equal, false otherwise\n     ",
    "links" : [ ]
  }, {
    "name" : "private static boolean compare(@NonNull float[] a, @NonNull float[] b)",
    "returnType" : "boolean",
    "comment" : "\n     * Compares two arrays of float with a precision of 1e-3.\n     *\n     * @param a The first array to compare\n     * @param b The second array to compare\n     * @return True if the two arrays are equal, false otherwise\n     ",
    "links" : [ ]
  }, {
    "name" : "private static float[] inverse3x3(@NonNull @Size(9) float[] m)",
    "returnType" : "float[]",
    "comment" : "\n     * Inverts a 3x3 matrix. This method assumes the matrix is invertible.\n     *\n     * @param m A 3x3 matrix as a non-null array of 9 floats\n     * @return A new array of 9 floats containing the inverse of the input matrix\n     ",
    "links" : [ ]
  }, {
    "name" : "private static float[] mul3x3(@NonNull @Size(9) float[] lhs, @NonNull @Size(9) float[] rhs)",
    "returnType" : "float[]",
    "comment" : "\n     * Multiplies two 3x3 matrices, represented as non-null arrays of 9 floats.\n     *\n     * @param lhs 3x3 matrix, as a non-null array of 9 floats\n     * @param rhs 3x3 matrix, as a non-null array of 9 floats\n     * @return A new array of 9 floats containing the result of the multiplication\n     *         of rhs by lhs\n     ",
    "links" : [ ]
  }, {
    "name" : "private static float[] mul3x3Float3(@NonNull @Size(9) float[] lhs, @NonNull @Size(min = 3) float[] rhs)",
    "returnType" : "float[]",
    "comment" : "\n     * Multiplies a vector of 3 components by a 3x3 matrix and stores the\n     * result in the input vector.\n     *\n     * @param lhs 3x3 matrix, as a non-null array of 9 floats\n     * @param rhs Vector of 3 components, as a non-null array of 3 floats\n     * @return The array of 3 passed as the rhs parameter\n     ",
    "links" : [ ]
  }, {
    "name" : "private static float[] mul3x3Diag(@NonNull @Size(3) float[] lhs, @NonNull @Size(9) float[] rhs)",
    "returnType" : "float[]",
    "comment" : "\n     * Multiplies a diagonal 3x3 matrix lhs, represented as an array of 3 floats,\n     * by a 3x3 matrix represented as an array of 9 floats.\n     *\n     * @param lhs Diagonal 3x3 matrix, as a non-null array of 3 floats\n     * @param rhs 3x3 matrix, as a non-null array of 9 floats\n     * @return A new array of 9 floats containing the result of the multiplication\n     *         of rhs by lhs\n     ",
    "links" : [ ]
  }, {
    "name" : "private static float[] xyYToXyz(@NonNull @Size(2) float[] xyY)",
    "returnType" : "float[]",
    "comment" : "\n     * Converts a value from CIE xyY to CIE XYZ. Y is assumed to be 1 so the\n     * input xyY array only contains the x and y components.\n     *\n     * @param xyY The xyY value to convert to XYZ, cannot be null, length must be 2\n     * @return A new float array of length 3 containing XYZ values\n     ",
    "links" : [ ]
  }, {
    "name" : "private static float[] chromaticAdaptation(@NonNull @Size(9) float[] matrix, @NonNull @Size(3) float[] srcWhitePoint, @NonNull @Size(3) float[] dstWhitePoint)",
    "returnType" : "float[]",
    "comment" : "\n     * <p>Computes the chromatic adaptation transform from the specified\n     * source white point to the specified destination white point.</p>\n     *\n     * <p>The transform is computed using the von Kries method, described\n     * in more details in the documentation of {@link Adaptation}. The\n     * {@link Adaptation} enum provides different matrices that can be\n     * used to perform the adaptation.</p>\n     *\n     * @param matrix The adaptation matrix\n     * @param srcWhitePoint The white point to adapt from, *will be modified*\n     * @param dstWhitePoint The white point to adapt to, *will be modified*\n     * @return A 3x3 matrix as a non-null array of 9 floats\n     ",
    "links" : [ "Adaptation" ]
  }, {
    "name" : "public static float[] cctToXyz(@IntRange(from = 1) int cct)",
    "returnType" : "float[]",
    "comment" : "\n     * <p>Computes the chromaticity coordinates of a specified correlated color\n     * temperature (CCT) on the Planckian locus. The specified CCT must be\n     * greater than 0. A meaningful CCT range is [1667, 25000].</p>\n     *\n     * <p>The transform is computed using the methods in Kang et\n     * al., <i>Design of Advanced Color - Temperature Control System for HDTV\n     * Applications</i>, Journal of Korean Physical Society 41, 865-871\n     * (2002).</p>\n     *\n     * @param cct The correlated color temperature, in Kelvin\n     * @return Corresponding XYZ values\n     * @throws IllegalArgumentException If cct is invalid\n     ",
    "links" : [ ]
  }, {
    "name" : "public static float[] chromaticAdaptation(@NonNull Adaptation adaptation, @NonNull @Size(min = 2, max = 3) float[] srcWhitePoint, @NonNull @Size(min = 2, max = 3) float[] dstWhitePoint)",
    "returnType" : "float[]",
    "comment" : "\n     * <p>Computes the chromatic adaptation transform from the specified\n     * source white point to the specified destination white point.</p>\n     *\n     * <p>The transform is computed using the von Kries method, described\n     * in more details in the documentation of {@link Adaptation}. The\n     * {@link Adaptation} enum provides different matrices that can be\n     * used to perform the adaptation.</p>\n     *\n     * @param adaptation The adaptation method\n     * @param srcWhitePoint The white point to adapt from\n     * @param dstWhitePoint The white point to adapt to\n     * @return A 3x3 matrix as a non-null array of 9 floats\n     ",
    "links" : [ "Adaptation" ]
  }, {
    "name" : " long getNativeInstance()",
    "returnType" : "long",
    "comment" : "\n     * Retrieve the native SkColorSpace object for passing to native.\n     *\n     * Only valid on ColorSpace.Rgb.\n     ",
    "links" : [ ]
  } ],
  "methodNames" : [ "public String getName()", "public int getId()", "public Model getModel()", "public int getComponentCount()", "public abstract boolean isWideGamut()", "public boolean isSrgb()", "public abstract float getMinValue(@IntRange(from = 0, to = 3) int component)", "public abstract float getMaxValue(@IntRange(from = 0, to = 3) int component)", "public float[] toXyz(float r, float g, float b)", "public abstract float[] toXyz(@NonNull @Size(min = 3) float[] v)", "public float[] fromXyz(float x, float y, float z)", "public abstract float[] fromXyz(@NonNull @Size(min = 3) float[] v)", "public String toString()", "public boolean equals(Object o)", "public int hashCode()", "public static Connector connect(@NonNull ColorSpace source, @NonNull ColorSpace destination)", "public static Connector connect(@NonNull ColorSpace source, @NonNull ColorSpace destination, @NonNull RenderIntent intent)", "public static Connector connect(@NonNull ColorSpace source)", "public static Connector connect(@NonNull ColorSpace source, @NonNull RenderIntent intent)", "public static ColorSpace adapt(@NonNull ColorSpace colorSpace, @NonNull @Size(min = 2, max = 3) float[] whitePoint)", "public static ColorSpace adapt(@NonNull ColorSpace colorSpace, @NonNull @Size(min = 2, max = 3) float[] whitePoint, @NonNull Adaptation adaptation)", "private static float[] adaptToIlluminantD50(@NonNull @Size(2) float[] origWhitePoint, @NonNull @Size(9) float[] origTransform)", " static ColorSpace get(@IntRange(from = MIN_ID, to = MAX_ID) int index)", "public static ColorSpace getFromDataSpace(@ColorDataSpace int dataSpace)", "public int getDataSpace()", "public static ColorSpace get(@NonNull Named name)", "public static ColorSpace match(@NonNull @Size(9) float[] toXYZD50, @NonNull Rgb.TransferParameters function)", "private static double transferHLGOETF(Rgb.TransferParameters params, double x)", "private static double transferHLGEOTF(Rgb.TransferParameters params, double x)", "private static double transferST2048OETF(Rgb.TransferParameters params, double x)", "private static double transferST2048EOTF(Rgb.TransferParameters pq, double x)", "private static double rcpResponse(double x, double a, double b, double c, double d, double g)", "private static double response(double x, double a, double b, double c, double d, double g)", "private static double rcpResponse(double x, double a, double b, double c, double d, double e, double f, double g)", "private static double response(double x, double a, double b, double c, double d, double e, double f, double g)", "private static double absRcpResponse(double x, double a, double b, double c, double d, double g)", "private static double absResponse(double x, double a, double b, double c, double d, double g)", "private static boolean compare(@Nullable Rgb.TransferParameters a, @Nullable Rgb.TransferParameters b)", "private static boolean compare(@NonNull float[] a, @NonNull float[] b)", "private static float[] inverse3x3(@NonNull @Size(9) float[] m)", "private static float[] mul3x3(@NonNull @Size(9) float[] lhs, @NonNull @Size(9) float[] rhs)", "private static float[] mul3x3Float3(@NonNull @Size(9) float[] lhs, @NonNull @Size(min = 3) float[] rhs)", "private static float[] mul3x3Diag(@NonNull @Size(3) float[] lhs, @NonNull @Size(9) float[] rhs)", "private static float[] xyYToXyz(@NonNull @Size(2) float[] xyY)", "private static float[] chromaticAdaptation(@NonNull @Size(9) float[] matrix, @NonNull @Size(3) float[] srcWhitePoint, @NonNull @Size(3) float[] dstWhitePoint)", "public static float[] cctToXyz(@IntRange(from = 1) int cct)", "public static float[] chromaticAdaptation(@NonNull Adaptation adaptation, @NonNull @Size(min = 2, max = 3) float[] srcWhitePoint, @NonNull @Size(min = 2, max = 3) float[] dstWhitePoint)", " long getNativeInstance()" ],
  "variableNames" : [ "ILLUMINANT_A", "ILLUMINANT_B", "ILLUMINANT_C", "ILLUMINANT_D50", "ILLUMINANT_D55", "ILLUMINANT_D60", "ILLUMINANT_D65", "ILLUMINANT_D75", "ILLUMINANT_E", "MIN_ID", "MAX_ID", "SRGB_PRIMARIES", "NTSC_1953_PRIMARIES", "DCI_P3_PRIMARIES", "BT2020_PRIMARIES", "GRAY_PRIMARIES", "ILLUMINANT_D50_XYZ", "SRGB_TRANSFER_PARAMETERS", "SMPTE_170M_TRANSFER_PARAMETERS", "BT2020_HLG_TRANSFER_PARAMETERS", "BT2020_PQ_TRANSFER_PARAMETERS", "sNamedColorSpaces", "sDataToColorSpaces", "mName", "mModel", "mId" ]
}