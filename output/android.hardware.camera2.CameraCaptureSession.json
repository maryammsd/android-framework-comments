{
  "filePath" : "/home/maryam/clearblue/files/android-source-35/android/hardware/camera2/CameraCaptureSession.java",
  "packageName" : "android.hardware.camera2",
  "className" : "CameraCaptureSession",
  "comment" : "\n * A configured capture session for a {@link CameraDevice}, used for capturing images from the\n * camera or reprocessing images captured from the camera in the same session previously.\n *\n * <p>A CameraCaptureSession is created by providing a set of target output surfaces to\n * {@link CameraDevice#createCaptureSession createCaptureSession}, or by providing an\n * {@link android.hardware.camera2.params.InputConfiguration} and a set of target output surfaces to\n * {@link CameraDevice#createReprocessableCaptureSession createReprocessableCaptureSession} for a\n * reprocessable capture session. Once created, the session is active until a new session is\n * created by the camera device, or the camera device is closed.</p>\n *\n * <p>All capture sessions can be used for capturing images from the camera but only reprocessable\n * capture sessions can reprocess images captured from the camera in the same session previously.\n * </p>\n *\n * <p>Creating a session is an expensive operation and can take several hundred milliseconds, since\n * it requires configuring the camera device's internal pipelines and allocating memory buffers for\n * sending images to the desired targets. Therefore the setup is done asynchronously, and\n * {@link CameraDevice#createCaptureSession createCaptureSession} and\n * {@link CameraDevice#createReprocessableCaptureSession createReprocessableCaptureSession} will\n * send the ready-to-use CameraCaptureSession to the provided listener's\n * {@link CameraCaptureSession.StateCallback#onConfigured onConfigured} callback. If configuration\n * cannot be completed, then the\n * {@link CameraCaptureSession.StateCallback#onConfigureFailed onConfigureFailed} is called, and the\n * session will not become active.</p>\n *<!--\n * <p>Any capture requests (repeating or non-repeating) submitted before the session is ready will\n * be queued up and will begin capture once the session becomes ready. In case the session cannot be\n * configured and {@link StateCallback#onConfigureFailed onConfigureFailed} is called, all queued\n * capture requests are discarded.</p>\n *-->\n * <p>If a new session is created by the camera device, then the previous session is closed, and its\n * associated {@link StateCallback#onClosed onClosed} callback will be invoked.  All\n * of the session methods will throw an IllegalStateException if called once the session is\n * closed.</p>\n *\n * <p>A closed session clears any repeating requests (as if {@link #stopRepeating} had been called),\n * but will still complete all of its in-progress capture requests as normal, before a newly\n * created session takes over and reconfigures the camera device.</p>\n ",
  "links" : [ "CameraCaptureSession.StateCallback#onConfigureFailed", "#onConfigureFailed", "android.hardware.camera2.CameraDevice", "CameraCaptureSession.StateCallback#onConfigured", "#stopRepeating", "android.hardware.camera2.CameraDevice#createCaptureSession", "#onClosed", "android.hardware.camera2.params.InputConfiguration", "android.hardware.camera2.CameraDevice#createReprocessableCaptureSession" ],
  "variables" : [ {
    "name" : "SESSION_ID_NONE",
    "type" : "int",
    "comment" : "\n     * Used to identify invalid session ID.\n     * @hide\n     ",
    "links" : [ ]
  } ],
  "methods" : [ {
    "name" : "public abstract CameraDevice getDevice()",
    "returnType" : "CameraDevice",
    "comment" : "\n     * Get the camera device that this session is created for.\n     ",
    "links" : [ ]
  }, {
    "name" : "public abstract void prepare(@NonNull Surface surface) throws CameraAccessException",
    "returnType" : "void",
    "comment" : "\n     * <p>Pre-allocate all buffers for an output Surface.</p>\n     *\n     * <p>Normally, the image buffers for a given output Surface are allocated on-demand,\n     * to minimize startup latency and memory overhead.</p>\n     *\n     * <p>However, in some cases, it may be desirable for the buffers to be allocated before\n     * any requests targeting the Surface are actually submitted to the device. Large buffers\n     * may take some time to allocate, which can result in delays in submitting requests until\n     * sufficient buffers are allocated to reach steady-state behavior. Such delays can cause\n     * bursts to take longer than desired, or cause skips or stutters in preview output.</p>\n     *\n     * <p>The prepare() method can be used to perform this preallocation. It may only be called for\n     * a given output Surface before that Surface is used as a target for a request. The number of\n     * buffers allocated is the sum of the count needed by the consumer providing the output\n     * Surface, and the maximum number needed by the camera device to fill its pipeline. Since this\n     * may be a larger number than what is actually required for steady-state operation, using\n     * prepare may result in higher memory consumption than the normal on-demand behavior results\n     * in. Prepare() will also delay the time to first output to a given Surface, in exchange for\n     * smoother frame rate once the allocation is complete.</p>\n     *\n     * <p>For example, an application that creates an\n     * {@link android.media.ImageReader#newInstance ImageReader} with a maxImages argument of 10,\n     * but only uses 3 simultaneous Images at once would normally only cause those 3 images to be\n     * allocated (plus what is needed by the camera device for smooth operation).  But using\n     * prepare() on the ImageReader Surface will result in all 10 Images being allocated. So\n     * applications using this method should take care to request only the number of buffers\n     * actually necessary for their application.</p>\n     *\n     * <p>If the same output Surface is used in consecutive sessions (without closing the first\n     * session explicitly), then its already-allocated buffers are carried over, and if it was\n     * used as a target of a capture request in the first session, prepare cannot be called on it\n     * in the second session.</p>\n     *\n     * <p>Once allocation is complete, {@link StateCallback#onSurfacePrepared} will be invoked with\n     * the Surface provided to this method. Between the prepare call and the onSurfacePrepared call,\n     * the Surface provided to prepare must not be used as a target of a CaptureRequest submitted\n     * to this session.</p>\n     *\n     * <p>Note that if 2 surfaces share the same stream via {@link\n     * OutputConfiguration#enableSurfaceSharing} and {@link OutputConfiguration#addSurface},\n     * prepare() only needs to be called on one surface, and {@link\n     * StateCallback#onSurfacePrepared} will be triggered for both surfaces.</p>\n     *\n     * <p>{@link android.hardware.camera2.CameraCharacteristics#INFO_SUPPORTED_HARDWARE_LEVEL_LEGACY LEGACY}\n     * devices cannot pre-allocate output buffers; for those devices,\n     * {@link StateCallback#onSurfacePrepared} will be immediately called, and no preallocation is\n     * done.</p>\n     *\n     * @param surface the output Surface for which buffers should be pre-allocated. Must be one of\n     * the output Surfaces used to create this session.\n     *\n     * @throws CameraAccessException if the camera device is no longer connected or has\n     *                               encountered a fatal error\n     * @throws IllegalStateException if this session is no longer active, either because the session\n     *                               was explicitly closed, a new session has been created\n     *                               or the camera device has been closed.\n     * @throws IllegalArgumentException if the Surface is invalid, not part of this Session, or has\n     *                                  already been used as a target of a CaptureRequest in this\n     *                                  session or immediately prior sessions.\n     *\n     * @see StateCallback#onSurfacePrepared\n     ",
    "links" : [ "android.hardware.camera2.params.OutputConfiguration#enableSurfaceSharing", "android.media.ImageReader#newInstance", "android.hardware.camera2.params.OutputConfiguration#addSurface", "#onSurfacePrepared", "android.hardware.camera2.CameraCharacteristics#INFO_SUPPORTED_HARDWARE_LEVEL_LEGACY" ]
  }, {
    "name" : "public abstract void prepare(int maxCount, @NonNull Surface surface) throws CameraAccessException",
    "returnType" : "void",
    "comment" : "\n     * <p>Pre-allocate at most maxCount buffers for an output Surface.</p>\n     *\n     * <p>Like the {@link #prepare(Surface)} method, this method can be used to allocate output\n     * buffers for a given Surface.  However, while the {@link #prepare(Surface)} method allocates\n     * the maximum possible buffer count, this method allocates at most maxCount buffers.</p>\n     *\n     * <p>If maxCount is greater than the possible maximum count (which is the sum of the buffer\n     * count requested by the creator of the Surface and the count requested by the camera device),\n     * only the possible maximum count is allocated, in which case the function acts exactly like\n     * {@link #prepare(Surface)}.</p>\n     *\n     * <p>The restrictions on when this method can be called are the same as for\n     * {@link #prepare(Surface)}.</p>\n     *\n     * <p>Repeated calls to this method are allowed, and a mix of {@link #prepare(Surface)} and\n     * this method is also allowed. Note that after the first call to {@link #prepare(Surface)},\n     * subsequent calls to either prepare method are effectively no-ops.  In addition, this method\n     * is not additive in terms of buffer count.  This means calling it twice with maxCount = 2\n     * will only allocate 2 buffers, not 4 (assuming the possible maximum is at least 2); to\n     * allocate two buffers on the first call and two on the second, the application needs to call\n     * prepare with prepare(surface, 2) and prepare(surface, 4).</p>\n     *\n     * @param maxCount the buffer count to try to allocate. If this is greater than the possible\n     *                 maximum for this output, the possible maximum is allocated instead. If\n     *                 maxCount buffers are already allocated, then prepare will do nothing.\n     * @param surface the output Surface for which buffers should be pre-allocated.\n     *\n     * @throws CameraAccessException if the camera device is no longer connected or has\n     *                               encountered a fatal error.\n     * @throws IllegalStateException if this session is no longer active, either because the\n     *                               session was explicitly closed, a new session has been created\n     *                               or the camera device has been closed.\n     * @throws IllegalArgumentException if the Surface is invalid, not part of this Session,\n     *                                  or has already been used as a target of a CaptureRequest in\n     *                                  this session or immediately prior sessions without an\n     *                                  intervening tearDown call.\n     *\n     * @hide\n     ",
    "links" : [ "#prepare(Surface)" ]
  }, {
    "name" : "public abstract void tearDown(@NonNull Surface surface) throws CameraAccessException",
    "returnType" : "void",
    "comment" : "\n     * <p>Free all buffers allocated for an output Surface.</p>\n     *\n     * <p>Normally, once allocated, the image buffers for a given output Surface remain allocated\n     * for the lifetime of the capture session, to minimize latency of captures and to reduce\n     * memory allocation overhead.</p>\n     *\n     * <p>However, in some cases, it may be desirable for allocated buffers to be freed to reduce\n     * the application's memory consumption, if the particular output Surface will not be used by\n     * the application for some time.</p>\n     *\n     * <p>The tearDown() method can be used to perform this operation. After the call finishes, all\n     * unfilled image buffers will have been freed. Any future use of the target Surface may require\n     * allocation of additional buffers, as if the session had just been created.  Buffers being\n     * held by the application (either explicitly as Image objects from ImageReader, or implicitly\n     * as the current texture in a SurfaceTexture or the current contents of a RS Allocation, will\n     * remain valid and allocated even when tearDown is invoked.</p>\n     *\n     * <p>A Surface that has had tearDown() called on it is eligible to have prepare() invoked on it\n     * again even if it was used as a request target before the tearDown() call, as long as it\n     * doesn't get used as a target of a request between the tearDown() and prepare() calls.</p>\n     *\n     * @param surface the output Surface for which buffers should be freed. Must be one of the\n     * the output Surfaces used to create this session.\n     *\n     * @throws CameraAccessException if the camera device is no longer connected or has\n     *                               encountered a fatal error.\n     * @throws IllegalStateException if this session is no longer active, either because the session\n     *                               was explicitly closed, a new session has been created\n     *                               or the camera device has been closed.\n     * @throws IllegalArgumentException if the Surface is invalid, not part of this Session, or has\n     *                                  already been used as a target of a CaptureRequest in this\n     *                                  session or immediately prior sessions.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public abstract void finalizeOutputConfigurations(List<OutputConfiguration> outputConfigs) throws CameraAccessException",
    "returnType" : "void",
    "comment" : "\n     * <p>Finalize the output configurations that now have their deferred and/or extra Surfaces\n     * included.</p>\n     *\n     * <p>For camera use cases where a preview and other output configurations need to be\n     * configured, it can take some time for the preview Surface to be ready. For example, if the\n     * preview Surface is obtained from {@link android.view.SurfaceView}, the SurfaceView will only\n     * be ready after the UI layout is done, potentially delaying camera startup.</p>\n     *\n     * <p>To speed up camera startup time, the application can configure the\n     * {@link CameraCaptureSession} with the eventual preview size (via\n     * {@link OutputConfiguration#OutputConfiguration(Size,Class) a deferred OutputConfiguration}),\n     * and defer the preview output configuration until the Surface is ready. After the\n     * {@link CameraCaptureSession} is created successfully with this deferred output and other\n     * normal outputs, the application can start submitting requests as long as they do not include\n     * deferred output Surfaces. Once a deferred Surface is ready, the application can add the\n     * Surface to the deferred output configuration with the\n     * {@link OutputConfiguration#addSurface} method, and then update the deferred output\n     * configuration via this method, before it can submit capture requests with this output\n     * target.</p>\n     *\n     * <p>This function can also be called in case where multiple surfaces share the same\n     * OutputConfiguration, and one of the surfaces becomes available after the {@link\n     * CameraCaptureSession} is created. In that case, the application must first create the\n     * OutputConfiguration with the available Surface, then enable further surface sharing via\n     * {@link OutputConfiguration#enableSurfaceSharing}, before creating the CameraCaptureSession.\n     * After the CameraCaptureSession is created, and once the extra Surface becomes available, the\n     * application must then call {@link OutputConfiguration#addSurface} before finalizing the\n     * configuration with this method.</p>\n     *\n     * <p>If the provided OutputConfigurations are unchanged from session creation, this function\n     * call has no effect. This function must only be called once for a particular output\n     * configuration. </p>\n     *\n     * <p>The output Surfaces included by this list of\n     * {@link OutputConfiguration OutputConfigurations} can be used as {@link CaptureRequest}\n     * targets as soon as this call returns.</p>\n     *\n     * <p>This method is not supported by\n     * {@link CameraCharacteristics#INFO_SUPPORTED_HARDWARE_LEVEL_LEGACY LEGACY}-level devices.</p>\n     *\n     * @param outputConfigs a list of {@link OutputConfiguration OutputConfigurations} that\n     *            have had {@link OutputConfiguration#addSurface addSurface} invoked with a valid\n     *            output Surface after {@link CameraDevice#createCaptureSessionByOutputConfigurations}.\n     * @throws CameraAccessException if the camera device is no longer connected or has encountered\n     *             a fatal error.\n     * @throws IllegalStateException if this session is no longer active, either because the session\n     *             was explicitly closed, a new session has been created, or the camera device has\n     *             been closed.\n     * @throws IllegalArgumentException for invalid output configurations, including ones where the\n     *             source of the Surface is no longer valid or the Surface is from a unsupported\n     *             source. Or if one of the output configuration was already finished with an\n     *             included surface in a prior call.\n     ",
    "links" : [ "android.hardware.camera2.params.OutputConfiguration#enableSurfaceSharing", "android.hardware.camera2.CameraDevice#createCaptureSessionByOutputConfigurations", "android.hardware.camera2.params.OutputConfiguration#addSurface", "android.hardware.camera2.params.OutputConfiguration", "android.view.SurfaceView", "android.hardware.camera2.CameraCaptureSession", "android.hardware.camera2.CaptureRequest", "android.hardware.camera2.params.OutputConfiguration#OutputConfiguration(Size", "android.hardware.camera2.CameraCharacteristics#INFO_SUPPORTED_HARDWARE_LEVEL_LEGACY" ]
  }, {
    "name" : "public abstract int capture(@NonNull CaptureRequest request, @Nullable CaptureCallback listener, @Nullable Handler handler) throws CameraAccessException",
    "returnType" : "int",
    "comment" : "\n     * <p>Submit a request for an image to be captured by the camera device.</p>\n     *\n     * <p>The request defines all the parameters for capturing the single image,\n     * including sensor, lens, flash, and post-processing settings.</p>\n     *\n     * <p>Each request will produce one {@link CaptureResult} and produce new frames for one or more\n     * target Surfaces, set with the CaptureRequest builder's\n     * {@link CaptureRequest.Builder#addTarget} method. The target surfaces (set with\n     * {@link CaptureRequest.Builder#addTarget}) must be a subset of the surfaces provided when this\n     * capture session was created.</p>\n     *\n     * <p>Multiple regular and reprocess requests can be in progress at once. If there are only\n     * regular requests or reprocess requests in progress, they are processed in first-in,\n     * first-out order. If there are both regular and reprocess requests in progress, regular\n     * requests are processed in first-in, first-out order and reprocess requests are processed in\n     * first-in, first-out order, respectively. However, the processing order of a regular request\n     * and a reprocess request in progress is not specified. In other words, a regular request\n     * will always be processed before regular requests that are submitted later. A reprocess\n     * request will always be processed before reprocess requests that are submitted later. However,\n     * a regular request may not be processed before reprocess requests that are submitted later.<p>\n     *\n     * <p>Requests submitted through this method have higher priority than\n     * those submitted through {@link #setRepeatingRequest} or\n     * {@link #setRepeatingBurst}, and will be processed as soon as the current\n     * repeat/repeatBurst processing completes.</p>\n     *\n     * <p>All capture sessions can be used for capturing images from the camera but only capture\n     * sessions created by\n     * {@link CameraDevice#createReprocessableCaptureSession createReprocessableCaptureSession}\n     * can submit reprocess capture requests. Submitting a reprocess request to a regular capture\n     * session will result in an {@link IllegalArgumentException}.</p>\n     *\n     * <p>Submitting a request that targets Surfaces with an unsupported dynamic range combination\n     * will result in an {@link IllegalArgumentException}.</p>\n     *\n     * @param request the settings for this capture\n     * @param listener The callback object to notify once this request has been\n     * processed. If null, no metadata will be produced for this capture,\n     * although image data will still be produced.\n     * @param handler the handler on which the listener should be invoked, or\n     * {@code null} to use the current thread's {@link android.os.Looper\n     * looper}.\n     *\n     * @return int A unique capture sequence ID used by\n     *             {@link CaptureCallback#onCaptureSequenceCompleted}.\n     *\n     * @throws CameraAccessException if the camera device is no longer connected or has\n     *                               encountered a fatal error\n     * @throws IllegalStateException if this session is no longer active, either because the session\n     *                               was explicitly closed, a new session has been created\n     *                               or the camera device has been closed.\n     * @throws IllegalArgumentException if the request targets no Surfaces or Surfaces that are not\n     *                                  configured as outputs for this session; or the request\n     *                                  targets a set of Surfaces that cannot be submitted\n     *                                  simultaneously in a reprocessable capture session; or a\n     *                                  reprocess capture request is submitted in a\n     *                                  non-reprocessable capture session; or the reprocess capture\n     *                                  request was created with a {@link TotalCaptureResult} from\n     *                                  a different session; or the capture targets a Surface in\n     *                                  the middle of being {@link #prepare prepared}; or the\n     *                                  handler is null, the listener is not null, and the calling\n     *                                  thread has no looper; or the request targets Surfaces with\n     *                                  an unsupported dynamic range combination\n     *\n     * @see #captureBurst\n     * @see #setRepeatingRequest\n     * @see #setRepeatingBurst\n     * @see #abortCaptures\n     * @see CameraDevice#createReprocessableCaptureSession\n     * @see android.hardware.camera2.params.DynamicRangeProfiles#getProfileCaptureRequestConstraints\n     ",
    "links" : [ "CaptureRequest.Builder#addTarget", "android.hardware.camera2.CaptureCallback#onCaptureSequenceCompleted", "android.hardware.camera2.CaptureResult", "#setRepeatingRequest", "#setRepeatingBurst", "android.hardware.camera2.TotalCaptureResult", "#prepare", "android.os.Looperlooper", "android.hardware.camera2.CameraDevice#createReprocessableCaptureSession", "IllegalArgumentException" ]
  }, {
    "name" : "public int captureSingleRequest(@NonNull CaptureRequest request, @NonNull @CallbackExecutor Executor executor, @NonNull CaptureCallback listener) throws CameraAccessException",
    "returnType" : "int",
    "comment" : "\n     * <p>Submit a request for an image to be captured by the camera device.</p>\n     *\n     * <p>The behavior of this method matches that of\n     * {@link #capture(CaptureRequest, CaptureCallback, Handler)},\n     * except that it uses {@link java.util.concurrent.Executor} as an argument\n     * instead of {@link android.os.Handler}.</p>\n     *\n     * @param request the settings for this capture\n     * @param executor the executor which will be used for invoking the listener.\n     * @param listener The callback object to notify once this request has been\n     * processed.\n     *\n     * @return int A unique capture sequence ID used by\n     *             {@link CaptureCallback#onCaptureSequenceCompleted}.\n     *\n     * @throws CameraAccessException if the camera device is no longer connected or has\n     *                               encountered a fatal error\n     * @throws IllegalStateException if this session is no longer active, either because the session\n     *                               was explicitly closed, a new session has been created\n     *                               or the camera device has been closed.\n     * @throws IllegalArgumentException if the request targets no Surfaces or Surfaces that are not\n     *                                  configured as outputs for this session; or the request\n     *                                  targets a set of Surfaces that cannot be submitted\n     *                                  simultaneously in a reprocessable capture session; or a\n     *                                  reprocess capture request is submitted in a\n     *                                  non-reprocessable capture session; or the reprocess capture\n     *                                  request was created with a {@link TotalCaptureResult} from\n     *                                  a different session; or the capture targets a Surface in\n     *                                  the middle of being {@link #prepare prepared}; or the\n     *                                  executor is null, or the listener is not null;\n     *                                  or the request targets Surfaces with an unsupported dynamic\n     *                                  range combination;\n     *\n     * @see #captureBurst\n     * @see #setRepeatingRequest\n     * @see #setRepeatingBurst\n     * @see #abortCaptures\n     * @see CameraDevice#createReprocessableCaptureSession\n     * @see android.hardware.camera2.params.DynamicRangeProfiles#getProfileCaptureRequestConstraints\n     ",
    "links" : [ "android.hardware.camera2.CaptureCallback#onCaptureSequenceCompleted", "#capture(CaptureRequest", "java.util.concurrent.Executor", "android.os.Handler", "android.hardware.camera2.TotalCaptureResult", "#prepare" ]
  }, {
    "name" : "public abstract int captureBurst(@NonNull List<CaptureRequest> requests, @Nullable CaptureCallback listener, @Nullable Handler handler) throws CameraAccessException",
    "returnType" : "int",
    "comment" : "\n     * Submit a list of requests to be captured in sequence as a burst. The\n     * burst will be captured in the minimum amount of time possible, and will\n     * not be interleaved with requests submitted by other capture or repeat\n     * calls.\n     *\n     * <p>Regular and reprocess requests can be mixed together in a single burst. Regular requests\n     * will be captured in order and reprocess requests will be processed in order, respectively.\n     * However, the processing order between a regular request and a reprocess request is not\n     * specified. Each capture produces one {@link CaptureResult} and image buffers for one or more\n     * target {@link android.view.Surface surfaces}. The target surfaces (set with\n     * {@link CaptureRequest.Builder#addTarget}) must be a subset of the surfaces provided when\n     * this capture session was created.</p>\n     *\n     * <p>The main difference between this method and simply calling\n     * {@link #capture} repeatedly is that this method guarantees that no\n     * other requests will be interspersed with the burst.</p>\n     *\n     * <p>All capture sessions can be used for capturing images from the camera but only capture\n     * sessions created by\n     * {@link CameraDevice#createReprocessableCaptureSession createReprocessableCaptureSession}\n     * can submit reprocess capture requests. Submitting a reprocess request to a regular\n     * capture session will result in an {@link IllegalArgumentException}.</p>\n     *\n     * <p>Submitting a request that targets Surfaces with an unsupported dynamic range combination\n     * will result in an {@link IllegalArgumentException}.</p>\n     *\n     * @param requests the list of settings for this burst capture\n     * @param listener The callback object to notify each time one of the\n     * requests in the burst has been processed. If null, no metadata will be\n     * produced for any requests in this burst, although image data will still\n     * be produced.\n     * @param handler the handler on which the listener should be invoked, or\n     * {@code null} to use the current thread's {@link android.os.Looper\n     * looper}.\n     *\n     * @return int A unique capture sequence ID used by\n     *             {@link CaptureCallback#onCaptureSequenceCompleted}.\n     *\n     * @throws CameraAccessException if the camera device is no longer connected or has\n     *                               encountered a fatal error\n     * @throws IllegalStateException if this session is no longer active, either because the session\n     *                               was explicitly closed, a new session has been created\n     *                               or the camera device has been closed.\n     * @throws IllegalArgumentException If the requests target no Surfaces, or the requests target\n     *                                  Surfaces not currently configured as outputs; or one of the\n     *                                  requests targets a set of Surfaces that cannot be submitted\n     *                                  simultaneously in a reprocessable capture session; or a\n     *                                  reprocess capture request is submitted in a\n     *                                  non-reprocessable capture session; or one of the reprocess\n     *                                  capture requests was created with a\n     *                                  {@link TotalCaptureResult} from a different session; or one\n     *                                  of the captures targets a Surface in the middle of being\n     *                                  {@link #prepare prepared}; or if the handler is null, the\n     *                                  listener is not null, and the calling thread has no looper;\n     *                                  or the request targets Surfaces with an unsupported dynamic\n     *                                  range combination.\n     *\n     * @see #capture\n     * @see #setRepeatingRequest\n     * @see #setRepeatingBurst\n     * @see #abortCaptures\n     * @see android.hardware.camera2.params.DynamicRangeProfiles#getProfileCaptureRequestConstraints\n     ",
    "links" : [ "CaptureRequest.Builder#addTarget", "android.hardware.camera2.CaptureCallback#onCaptureSequenceCompleted", "android.hardware.camera2.CaptureResult", "android.view.Surface", "#capture", "android.hardware.camera2.TotalCaptureResult", "#prepare", "android.os.Looperlooper", "android.hardware.camera2.CameraDevice#createReprocessableCaptureSession", "IllegalArgumentException" ]
  }, {
    "name" : "public int captureBurstRequests(@NonNull List<CaptureRequest> requests, @NonNull @CallbackExecutor Executor executor, @NonNull CaptureCallback listener) throws CameraAccessException",
    "returnType" : "int",
    "comment" : "\n     * Submit a list of requests to be captured in sequence as a burst. The\n     * burst will be captured in the minimum amount of time possible, and will\n     * not be interleaved with requests submitted by other capture or repeat\n     * calls.\n     *\n     * <p>The behavior of this method matches that of\n     * {@link #captureBurst(List, CaptureCallback, Handler)},\n     * except that it uses {@link java.util.concurrent.Executor} as an argument\n     * instead of {@link android.os.Handler}.</p>\n     *\n     * @param requests the list of settings for this burst capture\n     * @param executor the executor which will be used for invoking the listener.\n     * @param listener The callback object to notify each time one of the\n     * requests in the burst has been processed.\n     *\n     * @return int A unique capture sequence ID used by\n     *             {@link CaptureCallback#onCaptureSequenceCompleted}.\n     *\n     * @throws CameraAccessException if the camera device is no longer connected or has\n     *                               encountered a fatal error\n     * @throws IllegalStateException if this session is no longer active, either because the session\n     *                               was explicitly closed, a new session has been created\n     *                               or the camera device has been closed.\n     * @throws IllegalArgumentException If the requests target no Surfaces, or the requests target\n     *                                  Surfaces not currently configured as outputs; or one of the\n     *                                  requests targets a set of Surfaces that cannot be submitted\n     *                                  simultaneously in a reprocessable capture session; or a\n     *                                  reprocess capture request is submitted in a\n     *                                  non-reprocessable capture session; or one of the reprocess\n     *                                  capture requests was created with a\n     *                                  {@link TotalCaptureResult} from a different session; or one\n     *                                  of the captures targets a Surface in the middle of being\n     *                                  {@link #prepare prepared}; or if the executor is null; or if\n     *                                  the listener is null;\n     *                                  or the request targets Surfaces with an unsupported dynamic\n     *                                  range combination.\n     *\n     * @see #capture\n     * @see #setRepeatingRequest\n     * @see #setRepeatingBurst\n     * @see #abortCaptures\n     * @see android.hardware.camera2.params.DynamicRangeProfiles#getProfileCaptureRequestConstraints\n     ",
    "links" : [ "android.hardware.camera2.CaptureCallback#onCaptureSequenceCompleted", "java.util.concurrent.Executor", "android.os.Handler", "#captureBurst(List", "android.hardware.camera2.TotalCaptureResult", "#prepare" ]
  }, {
    "name" : "public abstract int setRepeatingRequest(@NonNull CaptureRequest request, @Nullable CaptureCallback listener, @Nullable Handler handler) throws CameraAccessException",
    "returnType" : "int",
    "comment" : "\n     * Request endlessly repeating capture of images by this capture session.\n     *\n     * <p>With this method, the camera device will continually capture images\n     * using the settings in the provided {@link CaptureRequest}, at the maximum\n     * rate possible.</p>\n     *\n     * <p>Repeating requests are a simple way for an application to maintain a\n     * preview or other continuous stream of frames, without having to\n     * continually submit identical requests through {@link #capture}.</p>\n     *\n     * <p>Repeat requests have lower priority than those submitted\n     * through {@link #capture} or {@link #captureBurst}, so if\n     * {@link #capture} is called when a repeating request is active, the\n     * capture request will be processed before any further repeating\n     * requests are processed.<p>\n     *\n     * <p>To stop the repeating capture, call {@link #stopRepeating}. Calling\n     * {@link #abortCaptures} will also clear the request.</p>\n     *\n     * <p>Calling this method will replace any earlier repeating request or\n     * burst set up by this method or {@link #setRepeatingBurst}, although any\n     * in-progress burst will be completed before the new repeat request will be\n     * used.</p>\n     *\n     * <p>This method does not support reprocess capture requests because each reprocess\n     * {@link CaptureRequest} must be created from the {@link TotalCaptureResult} that matches\n     * the input image to be reprocessed. This is either the {@link TotalCaptureResult} of capture\n     * that is sent for reprocessing, or one of the {@link TotalCaptureResult TotalCaptureResults}\n     * of a set of captures, when data from the whole set is combined by the application into a\n     * single reprocess input image. The request must be capturing images from the camera. If a\n     * reprocess capture request is submitted, this method will throw IllegalArgumentException.</p>\n     *\n     * <p>Submitting a request that targets Surfaces with an unsupported dynamic range combination\n     * will result in an {@link IllegalArgumentException}.</p>\n     *\n     * @param request the request to repeat indefinitely\n     * @param listener The callback object to notify every time the\n     * request finishes processing. If null, no metadata will be\n     * produced for this stream of requests, although image data will\n     * still be produced.\n     * @param handler the handler on which the listener should be invoked, or\n     * {@code null} to use the current thread's {@link android.os.Looper\n     * looper}.\n     *\n     * @return int A unique capture sequence ID used by\n     *             {@link CaptureCallback#onCaptureSequenceCompleted}.\n     *\n     * @throws CameraAccessException if the camera device is no longer connected or has\n     *                               encountered a fatal error\n     * @throws IllegalStateException if this session is no longer active, either because the session\n     *                               was explicitly closed, a new session has been created\n     *                               or the camera device has been closed.\n     * @throws IllegalArgumentException If the request references no Surfaces or references Surfaces\n     *                                  that are not currently configured as outputs; or the request\n     *                                  is a reprocess capture request; or the capture targets a\n     *                                  Surface in the middle of being {@link #prepare prepared}; or\n     *                                  the handler is null, the listener is not null, and the\n     *                                  calling thread has no looper; or no requests were passed in;\n     *                                  or the request targets Surfaces with an unsupported dynamic\n     *                                  range combination.\n     *\n     * @see #capture\n     * @see #captureBurst\n     * @see #setRepeatingBurst\n     * @see #stopRepeating\n     * @see #abortCaptures\n     * @see android.hardware.camera2.params.DynamicRangeProfiles#getProfileCaptureRequestConstraints\n     ",
    "links" : [ "android.hardware.camera2.CaptureCallback#onCaptureSequenceCompleted", "#captureBurst", "#abortCaptures", "#stopRepeating", "#capture", "#setRepeatingBurst", "android.hardware.camera2.TotalCaptureResult", "#prepare", "android.hardware.camera2.CaptureRequest", "android.os.Looperlooper", "IllegalArgumentException" ]
  }, {
    "name" : "public int setSingleRepeatingRequest(@NonNull CaptureRequest request, @NonNull @CallbackExecutor Executor executor, @NonNull CaptureCallback listener) throws CameraAccessException",
    "returnType" : "int",
    "comment" : "\n     * Request endlessly repeating capture of images by this capture session.\n     *\n     * <p>The behavior of this method matches that of\n     * {@link #setRepeatingRequest(CaptureRequest, CaptureCallback, Handler)},\n     * except that it uses {@link java.util.concurrent.Executor} as an argument\n     * instead of {@link android.os.Handler}.</p>\n     *\n     * @param request the request to repeat indefinitely\n     * @param executor the executor which will be used for invoking the listener.\n     * @param listener The callback object to notify every time the\n     * request finishes processing.\n     *\n     * @return int A unique capture sequence ID used by\n     *             {@link CaptureCallback#onCaptureSequenceCompleted}.\n     *\n     * @throws CameraAccessException if the camera device is no longer connected or has\n     *                               encountered a fatal error\n     * @throws IllegalStateException if this session is no longer active, either because the session\n     *                               was explicitly closed, a new session has been created\n     *                               or the camera device has been closed.\n     * @throws IllegalArgumentException If the request references no Surfaces or references Surfaces\n     *                                  that are not currently configured as outputs; or the request\n     *                                  is a reprocess capture request; or the capture targets a\n     *                                  Surface in the middle of being {@link #prepare prepared}; or\n     *                                  the executor is null; or the listener is null;\n     *                                  or the request targets Surfaces with an unsupported dynamic\n     *                                  range combination.\n     *\n     * @see #capture\n     * @see #captureBurst\n     * @see #setRepeatingBurst\n     * @see #stopRepeating\n     * @see #abortCaptures\n     * @see android.hardware.camera2.params.DynamicRangeProfiles#getProfileCaptureRequestConstraints\n     ",
    "links" : [ "android.hardware.camera2.CaptureCallback#onCaptureSequenceCompleted", "#setRepeatingRequest(CaptureRequest", "java.util.concurrent.Executor", "android.os.Handler", "#prepare" ]
  }, {
    "name" : "public abstract int setRepeatingBurst(@NonNull List<CaptureRequest> requests, @Nullable CaptureCallback listener, @Nullable Handler handler) throws CameraAccessException",
    "returnType" : "int",
    "comment" : "\n     * <p>Request endlessly repeating capture of a sequence of images by this\n     * capture session.</p>\n     *\n     * <p>With this method, the camera device will continually capture images,\n     * cycling through the settings in the provided list of\n     * {@link CaptureRequest CaptureRequests}, at the maximum rate possible.</p>\n     *\n     * <p>If a request is submitted through {@link #capture} or\n     * {@link #captureBurst}, the current repetition of the request list will be\n     * completed before the higher-priority request is handled. This guarantees\n     * that the application always receives a complete repeat burst captured in\n     * minimal time, instead of bursts interleaved with higher-priority\n     * captures, or incomplete captures.</p>\n     *\n     * <p>Repeating burst requests are a simple way for an application to\n     * maintain a preview or other continuous stream of frames where each\n     * request is different in a predictable way, without having to continually\n     * submit requests through {@link #captureBurst}.</p>\n     *\n     * <p>To stop the repeating capture, call {@link #stopRepeating}. Any\n     * ongoing burst will still be completed, however. Calling\n     * {@link #abortCaptures} will also clear the request.</p>\n     *\n     * <p>Calling this method will replace a previously-set repeating request or\n     * burst set up by this method or {@link #setRepeatingRequest}, although any\n     * in-progress burst will be completed before the new repeat burst will be\n     * used.</p>\n     *\n     * <p>This method does not support reprocess capture requests because each reprocess\n     * {@link CaptureRequest} must be created from the {@link TotalCaptureResult} that matches\n     * the input image to be reprocessed. This is either the {@link TotalCaptureResult} of capture\n     * that is sent for reprocessing, or one of the {@link TotalCaptureResult TotalCaptureResults}\n     * of a set of captures, when data from the whole set is combined by the application into a\n     * single reprocess input image. The request must be capturing images from the camera. If a\n     * reprocess capture request is submitted, this method will throw IllegalArgumentException.</p>\n     *\n     * <p>Submitting a request that targets Surfaces with an unsupported dynamic range combination\n     * will result in an {@link IllegalArgumentException}.</p>\n     *\n     * @param requests the list of requests to cycle through indefinitely\n     * @param listener The callback object to notify each time one of the\n     * requests in the repeating bursts has finished processing. If null, no\n     * metadata will be produced for this stream of requests, although image\n     * data will still be produced.\n     * @param handler the handler on which the listener should be invoked, or\n     * {@code null} to use the current thread's {@link android.os.Looper\n     * looper}.\n     *\n     * @return int A unique capture sequence ID used by\n     *             {@link CaptureCallback#onCaptureSequenceCompleted}.\n     *\n     * @throws CameraAccessException if the camera device is no longer connected or has\n     *                               encountered a fatal error\n     * @throws IllegalStateException if this session is no longer active, either because the session\n     *                               was explicitly closed, a new session has been created\n     *                               or the camera device has been closed.\n     * @throws IllegalArgumentException If the requests reference no Surfaces or reference Surfaces\n     *                                  not currently configured as outputs; or one of the requests\n     *                                  is a reprocess capture request; or one of the captures\n     *                                  targets a Surface in the middle of being\n     *                                  {@link #prepare prepared}; or the handler is null, the\n     *                                  listener is not null, and the calling thread has no looper;\n     *                                  or no requests were passed in;\n     *                                  or the request targets Surfaces with an unsupported dynamic\n     *                                  range combination.\n     *\n     * @see #capture\n     * @see #captureBurst\n     * @see #setRepeatingRequest\n     * @see #stopRepeating\n     * @see #abortCaptures\n     * @see android.hardware.camera2.params.DynamicRangeProfiles#getProfileCaptureRequestConstraints\n     ",
    "links" : [ "android.hardware.camera2.CaptureCallback#onCaptureSequenceCompleted", "#captureBurst", "#abortCaptures", "#stopRepeating", "#setRepeatingRequest", "#capture", "android.hardware.camera2.TotalCaptureResult", "#prepare", "android.hardware.camera2.CaptureRequest", "android.os.Looperlooper", "IllegalArgumentException" ]
  }, {
    "name" : "public int setRepeatingBurstRequests(@NonNull List<CaptureRequest> requests, @NonNull @CallbackExecutor Executor executor, @NonNull CaptureCallback listener) throws CameraAccessException",
    "returnType" : "int",
    "comment" : "\n     * <p>Request endlessly repeating capture of a sequence of images by this\n     * capture session.</p>\n     *\n     * <p>The behavior of this method matches that of\n     * {@link #setRepeatingBurst(List, CaptureCallback, Handler)},\n     * except that it uses {@link java.util.concurrent.Executor} as an argument\n     * instead of {@link android.os.Handler}.</p>\n     *\n     * @param requests the list of requests to cycle through indefinitely\n     * @param executor the executor which will be used for invoking the listener.\n     * @param listener The callback object to notify each time one of the\n     * requests in the repeating bursts has finished processing.\n     *\n     * @return int A unique capture sequence ID used by\n     *             {@link CaptureCallback#onCaptureSequenceCompleted}.\n     *\n     * @throws CameraAccessException if the camera device is no longer connected or has\n     *                               encountered a fatal error\n     * @throws IllegalStateException if this session is no longer active, either because the session\n     *                               was explicitly closed, a new session has been created\n     *                               or the camera device has been closed.\n     * @throws IllegalArgumentException If the requests reference no Surfaces or reference Surfaces\n     *                                  not currently configured as outputs; or one of the requests\n     *                                  is a reprocess capture request; or one of the captures\n     *                                  targets a Surface in the middle of being\n     *                                  {@link #prepare prepared}; or the executor is null; or the\n     *                                  listener is null;\n     *                                  or the request targets Surfaces with an unsupported dynamic\n     *                                  range combination.\n     *\n     * @see #capture\n     * @see #captureBurst\n     * @see #setRepeatingRequest\n     * @see #stopRepeating\n     * @see #abortCaptures\n     * @see android.hardware.camera2.params.DynamicRangeProfiles#getProfileCaptureRequestConstraints\n     ",
    "links" : [ "android.hardware.camera2.CaptureCallback#onCaptureSequenceCompleted", "java.util.concurrent.Executor", "android.os.Handler", "#prepare", "#setRepeatingBurst(List" ]
  }, {
    "name" : "public abstract void stopRepeating() throws CameraAccessException",
    "returnType" : "void",
    "comment" : "\n     * <p>Cancel any ongoing repeating capture set by either\n     * {@link #setRepeatingRequest setRepeatingRequest} or\n     * {@link #setRepeatingBurst}. Has no effect on requests submitted through\n     * {@link #capture capture} or {@link #captureBurst captureBurst}.</p>\n     *\n     * <p>Any currently in-flight captures will still complete, as will any burst that is\n     * mid-capture. To ensure that the device has finished processing all of its capture requests\n     * and is in ready state, wait for the {@link StateCallback#onReady} callback after\n     * calling this method.</p>\n     *\n     * @throws CameraAccessException if the camera device is no longer connected or has\n     *                               encountered a fatal error\n     * @throws IllegalStateException if this session is no longer active, either because the session\n     *                               was explicitly closed, a new session has been created\n     *                               or the camera device has been closed.\n     *\n     * @see #setRepeatingRequest\n     * @see #setRepeatingBurst\n     * @see StateCallback#onReady\n     ",
    "links" : [ "#onReady", "#captureBurst", "#setRepeatingRequest", "#setRepeatingBurst", "#capture" ]
  }, {
    "name" : "public abstract void abortCaptures() throws CameraAccessException",
    "returnType" : "void",
    "comment" : "\n     * Discard all captures currently pending and in-progress as fast as possible.\n     *\n     * <p>The camera device will discard all of its current work as fast as possible. Some in-flight\n     * captures may complete successfully and call {@link CaptureCallback#onCaptureCompleted}, while\n     * others will trigger their {@link CaptureCallback#onCaptureFailed} callbacks. If a repeating\n     * request or a repeating burst is set, it will be cleared.</p>\n     *\n     * <p>This method is the fastest way to switch the camera device to a new session with\n     * {@link CameraDevice#createCaptureSession} or\n     * {@link CameraDevice#createReprocessableCaptureSession}, at the cost of discarding in-progress\n     * work. It must be called before the new session is created. Once all pending requests are\n     * either completed or thrown away, the {@link StateCallback#onReady} callback will be called,\n     * if the session has not been closed. Otherwise, the {@link StateCallback#onClosed}\n     * callback will be fired when a new session is created by the camera device.</p>\n     *\n     * <p>Cancelling will introduce at least a brief pause in the stream of data from the camera\n     * device, since once the camera device is emptied, the first new request has to make it through\n     * the entire camera pipeline before new output buffers are produced.</p>\n     *\n     * <p>This means that using {@code abortCaptures()} to simply remove pending requests is not\n     * recommended; it's best used for quickly switching output configurations, or for cancelling\n     * long in-progress requests (such as a multi-second capture).</p>\n     *\n     * @throws CameraAccessException if the camera device is no longer connected or has\n     *                               encountered a fatal error\n     * @throws IllegalStateException if this session is no longer active, either because the session\n     *                               was explicitly closed, a new session has been created\n     *                               or the camera device has been closed.\n     *\n     * @see #setRepeatingRequest\n     * @see #setRepeatingBurst\n     * @see CameraDevice#createCaptureSession\n     * @see CameraDevice#createReprocessableCaptureSession\n     ",
    "links" : [ "#onReady", "android.hardware.camera2.CaptureCallback#onCaptureCompleted", "android.hardware.camera2.CameraDevice#createCaptureSession", "#onClosed", "android.hardware.camera2.CaptureCallback#onCaptureFailed", "android.hardware.camera2.CameraDevice#createReprocessableCaptureSession" ]
  }, {
    "name" : "public abstract boolean isReprocessable()",
    "returnType" : "boolean",
    "comment" : "\n     * Return if the application can submit reprocess capture requests with this camera capture\n     * session.\n     *\n     * @return {@code true} if the application can submit reprocess capture requests with this\n     *         camera capture session. {@code false} otherwise.\n     *\n     * @see CameraDevice#createReprocessableCaptureSession\n     ",
    "links" : [ ]
  }, {
    "name" : "public abstract Surface getInputSurface()",
    "returnType" : "Surface",
    "comment" : "\n     * Get the input Surface associated with a reprocessable capture session.\n     *\n     * <p>Each reprocessable capture session has an input {@link Surface} where the reprocess\n     * capture requests get the input images from, rather than the camera device. The application\n     * can create a {@link android.media.ImageWriter ImageWriter} with this input {@link Surface}\n     * and use it to provide input images for reprocess capture requests. When the reprocessable\n     * capture session is closed, the input {@link Surface} is abandoned and becomes invalid.</p>\n     *\n     * @return The {@link Surface} where reprocessing capture requests get the input images from. If\n     *         this is not a reprocess capture session, {@code null} will be returned.\n     *\n     * @see CameraDevice#createReprocessableCaptureSession\n     * @see android.media.ImageWriter\n     * @see android.media.ImageReader\n     ",
    "links" : [ "android.view.Surface", "android.media.ImageWriter" ]
  }, {
    "name" : "public void updateOutputConfiguration(OutputConfiguration config) throws CameraAccessException",
    "returnType" : "void",
    "comment" : "\n     * Update {@link OutputConfiguration} after configuration finalization see\n     * {@link #finalizeOutputConfigurations}.\n     *\n     * <p>Any {@link OutputConfiguration} that has been modified via calls to\n     * {@link OutputConfiguration#addSurface} or {@link OutputConfiguration#removeSurface} must be\n     * updated. After the update call returns without throwing exceptions any newly added surfaces\n     * can be referenced in subsequent capture requests.</p>\n     *\n     * <p>Surfaces that get removed must not be part of any active repeating or single/burst\n     * request or have any pending results. Consider updating any repeating requests first via\n     * {@link #setRepeatingRequest} or {@link #setRepeatingBurst} and then wait for the last frame\n     * number when the sequence completes {@link CaptureCallback#onCaptureSequenceCompleted}\n     * before calling updateOutputConfiguration to remove a previously active Surface.</p>\n     *\n     * <p>Surfaces that get added must not be part of any other registered\n     * {@link OutputConfiguration}.</p>\n     *\n     * @param config Modified output configuration.\n     *\n     * @throws CameraAccessException if the camera device is no longer connected or has\n     *                               encountered a fatal error.\n     * @throws IllegalArgumentException if an attempt was made to add a {@link Surface} already\n     *                               in use by another buffer-producing API, such as MediaCodec or\n     *                               a different camera device or {@link OutputConfiguration}; or\n     *                               new surfaces are not compatible (see\n     *                               {@link OutputConfiguration#enableSurfaceSharing}); or a\n     *                               {@link Surface} that was removed from the modified\n     *                               {@link OutputConfiguration} still has pending requests.\n     * @throws IllegalStateException if this session is no longer active, either because the session\n     *                               was explicitly closed, a new session has been created\n     *                               or the camera device has been closed.\n     ",
    "links" : [ "android.hardware.camera2.CaptureCallback#onCaptureSequenceCompleted", "android.hardware.camera2.params.OutputConfiguration#enableSurfaceSharing", "android.hardware.camera2.params.OutputConfiguration", "android.hardware.camera2.params.OutputConfiguration#addSurface", "#finalizeOutputConfigurations", "android.view.Surface", "android.hardware.camera2.params.OutputConfiguration#removeSurface", "#setRepeatingRequest", "#setRepeatingBurst" ]
  }, {
    "name" : "public CameraOfflineSession switchToOffline(@NonNull Collection<Surface> offlineSurfaces, @NonNull @CallbackExecutor Executor executor, @NonNull CameraOfflineSessionCallback listener) throws CameraAccessException",
    "returnType" : "CameraOfflineSession",
    "comment" : "\n     * Switch the current capture session and a given set of registered camera surfaces\n     * to offline processing mode.\n     *\n     * <p>Devices support this method will report\n     * {@link CameraMetadata#REQUEST_AVAILABLE_CAPABILITIES_OFFLINE_PROCESSING OFFLINE_PROCESSING}\n     * capability in {@link CameraCharacteristics#REQUEST_AVAILABLE_CAPABILITIES}. When this method\n     * is supported, applications can use it to improve the latency of closing camera or recreating\n     * capture session without losing the in progress capture request outputs.</p>\n     *\n     * <p>Offline processing mode and the corresponding {@link CameraOfflineSession} differ from\n     * a regular online camera capture session in several ways. Successful offline switches will\n     * close the currently active camera capture session. Camera clients are also allowed\n     * to call {@link CameraDevice#close} while offline processing of selected capture\n     * requests is still in progress. Such side effects free device close is only possible\n     * when the offline session moves to the ready state. Once this happens, closing the camera\n     * device will not affect the pending offline requests and they must complete as normal.</p>\n     *\n     * <p>Offline processing mode switches may need several hundred milliseconds to complete\n     * as the underlying camera implementation must abort all currently active repeating requests\n     * as well as all other pending requests not specified by the client. Additionally the switch\n     * will be blocked until all requests that continue processing within the offline session\n     * acquire their initial input frame from camera sensor. The call to {@link #switchToOffline}\n     * itself is not blocking and will only trigger the offline switch sequence. Clients will\n     * be notified via {@link CameraOfflineSessionCallback#onReady} once the entire sequence is\n     * complete.</p>\n     *\n     * <p>Please note that after a successful call to this method the currently active capture\n     * session will no longer be valid and clients will begin receiving capture\n     * callbacks with a corresponding {@link CameraOfflineSession} passed as a session\n     * argument.</p>\n     *\n     * @param offlineSurfaces Client-specified collection of input/output camera registered surfaces\n     *                        that need to be switched to offline mode along with their pending\n     *                        capture requests. Do note that not all camera registered\n     *                        surfaces can be switched to offline mode. Offline processing\n     *                        support for individual surfaces can be queried using\n     *                        {@link #supportsOfflineProcessing}. Additionally offline mode\n     *                        switches are not available for shared surfaces\n     *                        {@link OutputConfiguration#enableSurfaceSharing} and surfaces\n     *                        as part of a surface group.\n     *\n     * @param executor The executor which will be used for invoking the offline callback listener.\n     *\n     * @param listener The callback object to notify for offline session events.\n     *\n     * @return camera offline session which in case of successful offline switch will move in ready\n     *         state after clients receive {@link CameraOfflineSessionCallback#onReady}. In case the\n     *         offline switch was not successful clients will receive respective\n     *         {@link CameraOfflineSessionCallback#onSwitchFailed} notification.\n     *\n     * @throws IllegalArgumentException if an attempt was made to pass a {@link Surface} that was\n     *                                  not registered with this capture session or a shared\n     *                                  surface {@link OutputConfiguration#enableSurfaceSharing} or\n     *                                  surface as part of a surface group. The current capture\n     *                                  session will remain valid and active in case of this\n     *                                  exception.\n     *\n     * @throws CameraAccessException if the camera device is no longer connected or has\n     *                               encountered a fatal error.\n     *\n     * @see CameraOfflineSession\n     * @see CameraOfflineSessionCallback\n     * @see #supportsOfflineProcessing\n     * @see CameraMetadata#REQUEST_AVAILABLE_CAPABILITIES_OFFLINE_PROCESSING\n     ",
    "links" : [ "android.hardware.camera2.CameraCharacteristics#REQUEST_AVAILABLE_CAPABILITIES", "android.hardware.camera2.params.OutputConfiguration#enableSurfaceSharing", "android.hardware.camera2.CameraOfflineSession.CameraOfflineSessionCallback#onSwitchFailed", "android.hardware.camera2.CameraOfflineSession.CameraOfflineSessionCallback#onReady", "android.view.Surface", "android.hardware.camera2.CameraOfflineSession", "#supportsOfflineProcessing", "android.hardware.camera2.CameraMetadata#REQUEST_AVAILABLE_CAPABILITIES_OFFLINE_PROCESSING", "android.hardware.camera2.CameraDevice#close", "#switchToOffline" ]
  }, {
    "name" : "public boolean supportsOfflineProcessing(@NonNull Surface surface)",
    "returnType" : "boolean",
    "comment" : "\n     * <p>Query whether a given Surface is able to support offline mode. </p>\n     *\n     * <p>Surfaces that support offline mode can be passed as arguments to {@link #switchToOffline}.\n     * </p>\n     *\n     * @param surface An input/output surface that was used to create this session or the result of\n     *                {@link #getInputSurface}.\n     *\n     * @return {@code true} if the surface can support offline mode and can be passed as argument to\n     *         {@link #switchToOffline}. {@code false} otherwise.\n     *\n     * @throws IllegalArgumentException if an attempt was made to pass a {@link Surface} that was\n     *                                  not registered with this capture session.\n     * @throws UnsupportedOperationException if an attempt was made to call this method using\n     *                                       unsupported camera capture session like\n     *                                       {@link CameraConstrainedHighSpeedCaptureSession} or\n     *                                       {@link CameraOfflineSession}.\n     *\n     * @see #switchToOffline\n     ",
    "links" : [ "android.view.Surface", "android.hardware.camera2.CameraOfflineSession", "#switchToOffline", "#getInputSurface", "android.hardware.camera2.CameraConstrainedHighSpeedCaptureSession" ]
  }, {
    "name" : "public abstract void close()",
    "returnType" : "void",
    "comment" : "\n     * Close this capture session asynchronously.\n     *\n     * <p>Closing a session frees up the target output Surfaces of the session for reuse with either\n     * a new session, or to other APIs that can draw to Surfaces.</p>\n     *\n     * <p>Note that for common usage scenarios like creating a new session or closing the camera\n     * device, it is faster to call respective APIs directly (see below for more details) without\n     * calling into this method. This API is only useful when application wants to unconfigure the\n     * camera but keep the device open for later use.</p>\n     *\n     * <p>Creating a new capture session with {@link CameraDevice#createCaptureSession}\n     * will close any existing capture session automatically, and call the older session listener's\n     * {@link StateCallback#onClosed} callback. Using {@link CameraDevice#createCaptureSession}\n     * directly without closing is the recommended approach for quickly switching to a new session,\n     * since unchanged target outputs can be reused more efficiently.</p>\n     *\n     * <p>Closing the device with {@link CameraDevice#close} directly without calling this API is\n     * also recommended for quickly closing the camera.</p>\n     *\n     * <p>Once a session is closed, all methods on it will throw an IllegalStateException, and any\n     * repeating requests or bursts are stopped (as if {@link #stopRepeating()} was called).\n     * However, any in-progress capture requests submitted to the session will be completed as\n     * normal; once all captures have completed and the session has been torn down,\n     * {@link StateCallback#onClosed} will be called.</p>\n     *\n     * <p>Closing a session is idempotent; closing more than once has no effect.</p>\n     ",
    "links" : [ "#stopRepeating()", "android.hardware.camera2.CameraDevice#createCaptureSession", "#onClosed", "android.hardware.camera2.CameraDevice#close" ]
  } ],
  "methodNames" : [ "public abstract CameraDevice getDevice()", "public abstract void prepare(@NonNull Surface surface) throws CameraAccessException", "public abstract void prepare(int maxCount, @NonNull Surface surface) throws CameraAccessException", "public abstract void tearDown(@NonNull Surface surface) throws CameraAccessException", "public abstract void finalizeOutputConfigurations(List<OutputConfiguration> outputConfigs) throws CameraAccessException", "public abstract int capture(@NonNull CaptureRequest request, @Nullable CaptureCallback listener, @Nullable Handler handler) throws CameraAccessException", "public int captureSingleRequest(@NonNull CaptureRequest request, @NonNull @CallbackExecutor Executor executor, @NonNull CaptureCallback listener) throws CameraAccessException", "public abstract int captureBurst(@NonNull List<CaptureRequest> requests, @Nullable CaptureCallback listener, @Nullable Handler handler) throws CameraAccessException", "public int captureBurstRequests(@NonNull List<CaptureRequest> requests, @NonNull @CallbackExecutor Executor executor, @NonNull CaptureCallback listener) throws CameraAccessException", "public abstract int setRepeatingRequest(@NonNull CaptureRequest request, @Nullable CaptureCallback listener, @Nullable Handler handler) throws CameraAccessException", "public int setSingleRepeatingRequest(@NonNull CaptureRequest request, @NonNull @CallbackExecutor Executor executor, @NonNull CaptureCallback listener) throws CameraAccessException", "public abstract int setRepeatingBurst(@NonNull List<CaptureRequest> requests, @Nullable CaptureCallback listener, @Nullable Handler handler) throws CameraAccessException", "public int setRepeatingBurstRequests(@NonNull List<CaptureRequest> requests, @NonNull @CallbackExecutor Executor executor, @NonNull CaptureCallback listener) throws CameraAccessException", "public abstract void stopRepeating() throws CameraAccessException", "public abstract void abortCaptures() throws CameraAccessException", "public abstract boolean isReprocessable()", "public abstract Surface getInputSurface()", "public void updateOutputConfiguration(OutputConfiguration config) throws CameraAccessException", "public CameraOfflineSession switchToOffline(@NonNull Collection<Surface> offlineSurfaces, @NonNull @CallbackExecutor Executor executor, @NonNull CameraOfflineSessionCallback listener) throws CameraAccessException", "public boolean supportsOfflineProcessing(@NonNull Surface surface)", "public abstract void close()" ],
  "variableNames" : [ "SESSION_ID_NONE" ]
}