{
  "filePath" : "/home/maryam/clearblue/files/android-source-35/android/hardware/Camera.java",
  "packageName" : "android.hardware",
  "className" : "Camera",
  "comment" : "\n * The Camera class is used to set image capture settings, start/stop preview,\n * snap pictures, and retrieve frames for encoding for video.  This class is a\n * client for the Camera service, which manages the actual camera hardware.\n *\n * <p>To access the device camera, you must declare the\n * {@link android.Manifest.permission#CAMERA} permission in your Android\n * Manifest. Also be sure to include the\n * <a href=\"{@docRoot}guide/topics/manifest/uses-feature-element.html\">&lt;uses-feature></a>\n * manifest element to declare camera features used by your application.\n * For example, if you use the camera and auto-focus feature, your Manifest\n * should include the following:</p>\n * <pre> &lt;uses-permission android:name=\"android.permission.CAMERA\" />\n * &lt;uses-feature android:name=\"android.hardware.camera\" />\n * &lt;uses-feature android:name=\"android.hardware.camera.autofocus\" /></pre>\n *\n * <p>To take pictures with this class, use the following steps:</p>\n *\n * <ol>\n * <li>Obtain an instance of Camera from {@link #open(int)}.\n *\n * <li>Get existing (default) settings with {@link #getParameters()}.\n *\n * <li>If necessary, modify the returned {@link Camera.Parameters} object and call\n * {@link #setParameters(Camera.Parameters)}.\n *\n * <li>Call {@link #setDisplayOrientation(int)} to ensure correct orientation of preview.\n *\n * <li><b>Important</b>: Pass a fully initialized {@link SurfaceHolder} to\n * {@link #setPreviewDisplay(SurfaceHolder)}.  Without a surface, the camera\n * will be unable to start the preview.\n *\n * <li><b>Important</b>: Call {@link #startPreview()} to start updating the\n * preview surface.  Preview must be started before you can take a picture.\n *\n * <li>When you want, call {@link #takePicture(Camera.ShutterCallback,\n * Camera.PictureCallback, Camera.PictureCallback, Camera.PictureCallback)} to\n * capture a photo.  Wait for the callbacks to provide the actual image data.\n *\n * <li>After taking a picture, preview display will have stopped.  To take more\n * photos, call {@link #startPreview()} again first.\n *\n * <li>Call {@link #stopPreview()} to stop updating the preview surface.\n *\n * <li><b>Important:</b> Call {@link #release()} to release the camera for\n * use by other applications.  Applications should release the camera\n * immediately in {@link android.app.Activity#onPause()} (and re-{@link #open()}\n * it in {@link android.app.Activity#onResume()}).\n * </ol>\n *\n * <p>To quickly switch to video recording mode, use these steps:</p>\n *\n * <ol>\n * <li>Obtain and initialize a Camera and start preview as described above.\n *\n * <li>Call {@link #unlock()} to allow the media process to access the camera.\n *\n * <li>Pass the camera to {@link android.media.MediaRecorder#setCamera(Camera)}.\n * See {@link android.media.MediaRecorder} information about video recording.\n *\n * <li>When finished recording, call {@link #reconnect()} to re-acquire\n * and re-lock the camera.\n *\n * <li>If desired, restart preview and take more photos or videos.\n *\n * <li>Call {@link #stopPreview()} and {@link #release()} as described above.\n * </ol>\n *\n * <p>This class is not thread-safe, and is meant for use from one event thread.\n * Most long-running operations (preview, focus, photo capture, etc) happen\n * asynchronously and invoke callbacks as necessary.  Callbacks will be invoked\n * on the event thread {@link #open(int)} was called from.  This class's methods\n * must never be called from multiple threads at once.</p>\n *\n * <p class=\"caution\"><strong>Caution:</strong> Different Android-powered devices\n * may have different hardware specifications, such as megapixel ratings and\n * auto-focus capabilities. In order for your application to be compatible with\n * more devices, you should not make assumptions about the device camera\n * specifications.</p>\n *\n * <div class=\"special reference\">\n * <h3>Developer Guides</h3>\n * <p>For more information about using cameras, read the\n * <a href=\"{@docRoot}guide/topics/media/camera.html\">Camera</a> developer guide.</p>\n * </div>\n *\n * @deprecated We recommend using the new {@link android.hardware.camera2} API for new\n *             applications.\n ",
  "links" : [ "#unlock()", "#reconnect()", "Camera.Parameters", "#release()", "android.app.Activity#onResume()", "android.media.MediaRecorder#setCamera(Camera)", "android.hardware.camera2", "#getParameters()", "#stopPreview()", "android.media.MediaRecorder", "#takePicture(Camera.ShutterCallback", "#open()", "#startPreview()", "#setDisplayOrientation(int)", "android.Manifest.permission#CAMERA", "#setPreviewDisplay(SurfaceHolder)", "#setParameters(Camera.Parameters)", "#open(int)", "android.view.SurfaceHolder", "android.app.Activity#onPause()" ],
  "variables" : [ {
    "name" : "TAG",
    "type" : "String",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "CAMERA_MSG_ERROR",
    "type" : "int",
    "comment" : " These match the enums in frameworks/base/include/camera/Camera.h",
    "links" : [ ]
  }, {
    "name" : "CAMERA_MSG_SHUTTER",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "CAMERA_MSG_FOCUS",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "CAMERA_MSG_ZOOM",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "CAMERA_MSG_PREVIEW_FRAME",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "CAMERA_MSG_VIDEO_FRAME",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "CAMERA_MSG_POSTVIEW_FRAME",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "CAMERA_MSG_RAW_IMAGE",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "CAMERA_MSG_COMPRESSED_IMAGE",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "CAMERA_MSG_RAW_IMAGE_NOTIFY",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "CAMERA_MSG_PREVIEW_METADATA",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "CAMERA_MSG_FOCUS_MOVE",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mNativeContext",
    "type" : "long",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mEventHandler",
    "type" : "EventHandler",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mShutterCallback",
    "type" : "ShutterCallback",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mRawImageCallback",
    "type" : "PictureCallback",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mJpegCallback",
    "type" : "PictureCallback",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mPreviewCallback",
    "type" : "PreviewCallback",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mUsingPreviewAllocation",
    "type" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mPostviewCallback",
    "type" : "PictureCallback",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mAutoFocusCallback",
    "type" : "AutoFocusCallback",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mAutoFocusMoveCallback",
    "type" : "AutoFocusMoveCallback",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mZoomListener",
    "type" : "OnZoomChangeListener",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mFaceListener",
    "type" : "FaceDetectionListener",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mErrorCallback",
    "type" : "ErrorCallback",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mDetailedErrorCallback",
    "type" : "ErrorCallback",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mOneShot",
    "type" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mWithBuffer",
    "type" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mFaceDetectionRunning",
    "type" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mAutoFocusCallbackLock",
    "type" : "Object",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mShutterSoundLock",
    "type" : "Object",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mAppOps",
    "type" : "IAppOpsService",
    "comment" : " for AppOps",
    "links" : [ ]
  }, {
    "name" : "mAppOpsCallback",
    "type" : "IAppOpsCallback",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mHasAppOpsPlayAudio",
    "type" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mShutterSoundEnabledFromApp",
    "type" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "NO_ERROR",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "ACTION_NEW_PICTURE",
    "type" : "String",
    "comment" : "\n     * Broadcast Action:  A new picture is taken by the camera, and the entry of\n     * the picture has been added to the media store.\n     * {@link android.content.Intent#getData} is URI of the picture.\n     *\n     * <p>In {@link android.os.Build.VERSION_CODES#N Android N} this broadcast was removed, and\n     * applications are recommended to use\n     * {@link android.app.job.JobInfo.Builder JobInfo.Builder}.{@link android.app.job.JobInfo.Builder#addTriggerContentUri}\n     * instead.</p>\n     *\n     * <p>In {@link android.os.Build.VERSION_CODES#O Android O} this broadcast has been brought\n     * back, but only for <em>registered</em> receivers.  Apps that are actively running can\n     * again listen to the broadcast if they want an immediate clear signal about a picture\n     * being taken, however anything doing heavy work (or needing to be launched) as a result of\n     * this should still use JobScheduler.</p>\n     ",
    "links" : [ "android.os.Build.VERSION_CODES#O", "android.content.Intent#getData", "android.app.job.JobInfo.Builder#addTriggerContentUri", "android.os.Build.VERSION_CODES#N", "android.app.job.JobInfo.Builder" ]
  }, {
    "name" : "ACTION_NEW_VIDEO",
    "type" : "String",
    "comment" : "\n     * Broadcast Action:  A new video is recorded by the camera, and the entry\n     * of the video has been added to the media store.\n     * {@link android.content.Intent#getData} is URI of the video.\n     *\n     * <p>In {@link android.os.Build.VERSION_CODES#N Android N} this broadcast was removed, and\n     * applications are recommended to use\n     * {@link android.app.job.JobInfo.Builder JobInfo.Builder}.{@link android.app.job.JobInfo.Builder#addTriggerContentUri}\n     * instead.</p>\n     *\n     * <p>In {@link android.os.Build.VERSION_CODES#O Android O} this broadcast has been brought\n     * back, but only for <em>registered</em> receivers.  Apps that are actively running can\n     * again listen to the broadcast if they want an immediate clear signal about a video\n     * being taken, however anything doing heavy work (or needing to be launched) as a result of\n     * this should still use JobScheduler.</p>\n     ",
    "links" : [ "android.os.Build.VERSION_CODES#O", "android.content.Intent#getData", "android.app.job.JobInfo.Builder#addTriggerContentUri", "android.os.Build.VERSION_CODES#N", "android.app.job.JobInfo.Builder" ]
  }, {
    "name" : "CAMERA_HAL_API_VERSION_1_0",
    "type" : "int",
    "comment" : "\n     * Camera HAL device API version 1.0\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "CAMERA_HAL_API_VERSION_3_0",
    "type" : "int",
    "comment" : "\n     * Camera HAL device API version 3.0\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "CAMERA_FACE_DETECTION_HW",
    "type" : "int",
    "comment" : "\n     * Hardware face detection. It does not use much CPU.\n     ",
    "links" : [ ]
  }, {
    "name" : "CAMERA_FACE_DETECTION_SW",
    "type" : "int",
    "comment" : "\n     * Software face detection. It uses some CPU.\n     ",
    "links" : [ ]
  }, {
    "name" : "CAMERA_ERROR_UNKNOWN",
    "type" : "int",
    "comment" : "\n     * Unspecified camera error.\n     * @see Camera.ErrorCallback\n     ",
    "links" : [ ]
  }, {
    "name" : "CAMERA_ERROR_EVICTED",
    "type" : "int",
    "comment" : "\n     * Camera was disconnected due to use by higher priority user.\n     * @see Camera.ErrorCallback\n     ",
    "links" : [ ]
  }, {
    "name" : "CAMERA_ERROR_DISABLED",
    "type" : "int",
    "comment" : "\n     * Camera was disconnected due to device policy change or client\n     * application going to background.\n     * @see Camera.ErrorCallback\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "CAMERA_ERROR_SERVER_DIED",
    "type" : "int",
    "comment" : "\n     * Media server died. In this case, the application must release the\n     * Camera object and instantiate a new one.\n     * @see Camera.ErrorCallback\n     ",
    "links" : [ ]
  } ],
  "methods" : [ {
    "name" : "public static int getNumberOfCameras()",
    "returnType" : "int",
    "comment" : "\n     * Returns the number of physical cameras available on this device.\n     * The return value of this method might change dynamically if the device\n     * supports external cameras and an external camera is connected or\n     * disconnected.\n     *\n     * If there is a\n     * {@link android.hardware.camera2.CameraCharacteristics#REQUEST_AVAILABLE_CAPABILITIES_LOGICAL_MULTI_CAMERA\n     * logical multi-camera} in the system, to maintain app backward compatibility, this method will\n     * only expose one camera per facing for all logical camera and physical camera groups.\n     * Use camera2 API to see all cameras.\n     *\n     * @return total number of accessible camera devices, or 0 if there are no\n     *   cameras or an error was encountered enumerating them.\n     ",
    "links" : [ "android.hardware.camera2.CameraCharacteristics#REQUEST_AVAILABLE_CAPABILITIES_LOGICAL_MULTI_CAMERAlogical" ]
  }, {
    "name" : "public static int getNumberOfCameras(@NonNull Context context)",
    "returnType" : "int",
    "comment" : "\n     * Returns the number of physical cameras available on this device for the given context.\n     * The return value of this method might change dynamically if the device supports external\n     * cameras and an external camera is connected or disconnected.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "private static native int _getNumberOfCameras(int deviceId, int devicePolicy)",
    "returnType" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public static void getCameraInfo(int cameraId, CameraInfo cameraInfo)",
    "returnType" : "void",
    "comment" : "\n     * Returns the information about a particular camera.\n     * If {@link #getNumberOfCameras()} returns N, the valid id is 0 to N-1.\n     *\n     * @throws RuntimeException if an invalid ID is provided, or if there is an\n     *    error retrieving the information (generally due to a hardware or other\n     *    low-level failure).\n     ",
    "links" : [ "#getNumberOfCameras()" ]
  }, {
    "name" : "public static void getCameraInfo(int cameraId, @NonNull Context context, int rotationOverride, CameraInfo cameraInfo)",
    "returnType" : "void",
    "comment" : "\n     * Returns the information about a particular camera for the given context.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "private static native void _getCameraInfo(int cameraId, int rotationOverride, int deviceId, int devicePolicy, CameraInfo cameraInfo)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private static int getDevicePolicyFromContext(Context context)",
    "returnType" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public static Camera open(int cameraId)",
    "returnType" : "Camera",
    "comment" : "\n     * Creates a new Camera object to access a particular hardware camera. If\n     * the same camera is opened by other applications, this will throw a\n     * RuntimeException.\n     *\n     * <p>You must call {@link #release()} when you are done using the camera,\n     * otherwise it will remain locked and be unavailable to other applications.\n     *\n     * <p>Your application should only have one Camera object active at a time\n     * for a particular hardware camera.\n     *\n     * <p>Callbacks from other methods are delivered to the event loop of the\n     * thread which called open().  If this thread has no event loop, then\n     * callbacks are delivered to the main application event loop.  If there\n     * is no main application event loop, callbacks are not delivered.\n     *\n     * <p class=\"caution\"><b>Caution:</b> On some devices, this method may\n     * take a long time to complete.  It is best to call this method from a\n     * worker thread (possibly using {@link android.os.AsyncTask}) to avoid\n     * blocking the main application UI thread.\n     *\n     * @param cameraId the hardware camera to access, between 0 and\n     *     {@link #getNumberOfCameras()}-1.\n     * @return a new Camera object, connected, locked and ready for use.\n     * @throws RuntimeException if opening the camera fails (for example, if the\n     *     camera is in use by another process or device policy manager has\n     *     disabled the camera).\n     * @see android.app.admin.DevicePolicyManager#getCameraDisabled(android.content.ComponentName)\n     ",
    "links" : [ "#getNumberOfCameras()", "#release()", "android.os.AsyncTask" ]
  }, {
    "name" : "public static Camera open(int cameraId, @NonNull Context context, int rotationOverride)",
    "returnType" : "Camera",
    "comment" : "\n     * Creates a new Camera object for a given camera id for the given context.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public static Camera open()",
    "returnType" : "Camera",
    "comment" : "\n     * Creates a new Camera object to access the first back-facing camera on the\n     * device. If the device does not have a back-facing camera, this returns\n     * null. Otherwise acts like the {@link #open(int)} call.\n     *\n     * @return a new Camera object for the first back-facing camera, or null if there is no\n     *  backfacing camera\n     * @see #open(int)\n     ",
    "links" : [ "#open(int)" ]
  }, {
    "name" : "public static Camera openLegacy(int cameraId, int halVersion)",
    "returnType" : "Camera",
    "comment" : "\n     * Creates a new Camera object to access a particular hardware camera with\n     * given hal API version. If the same camera is opened by other applications\n     * or the hal API version is not supported by this device, this will throw a\n     * RuntimeException. As of Android 12, HAL version 1 is no longer supported.\n     * <p>\n     * You must call {@link #release()} when you are done using the camera,\n     * otherwise it will remain locked and be unavailable to other applications.\n     * <p>\n     * Your application should only have one Camera object active at a time for\n     * a particular hardware camera.\n     * <p>\n     * Callbacks from other methods are delivered to the event loop of the\n     * thread which called open(). If this thread has no event loop, then\n     * callbacks are delivered to the main application event loop. If there is\n     * no main application event loop, callbacks are not delivered.\n     * <p class=\"caution\">\n     * <b>Caution:</b> On some devices, this method may take a long time to\n     * complete. It is best to call this method from a worker thread (possibly\n     * using {@link android.os.AsyncTask}) to avoid blocking the main\n     * application UI thread.\n     *\n     * @param cameraId The hardware camera to access, between 0 and\n     * {@link #getNumberOfCameras()}-1.\n     * @param halVersion The HAL API version this camera device to be opened as.\n     * @return a new Camera object, connected, locked and ready for use.\n     *\n     * @throws IllegalArgumentException if the {@code halVersion} is invalid\n     *\n     * @throws RuntimeException if opening the camera fails (for example, if the\n     * camera is in use by another process or device policy manager has disabled\n     * the camera).\n     *\n     * @see android.app.admin.DevicePolicyManager#getCameraDisabled(android.content.ComponentName)\n     * @see #CAMERA_HAL_API_VERSION_1_0\n     *\n     * @hide\n     ",
    "links" : [ "#getNumberOfCameras()", "#release()", "android.os.AsyncTask" ]
  }, {
    "name" : "private int cameraInit(int cameraId, Context context, int rotationOverride)",
    "returnType" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private boolean shouldForceSlowJpegMode()",
    "returnType" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public static boolean checkInitErrors(int err)",
    "returnType" : "boolean",
    "comment" : "\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public static Camera openUninitialized()",
    "returnType" : "Camera",
    "comment" : "\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "private void initAppOps()",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private void releaseAppOps()",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "protected void finalize()",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private native int native_setup(Object cameraThis, int cameraId, String packageName, int rotationOverride, boolean forceSlowJpegMode, int deviceId, int devicePolicy)",
    "returnType" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private final native void native_release()",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public final void release()",
    "returnType" : "void",
    "comment" : "\n     * Disconnects and releases the Camera object resources.\n     *\n     * <p>You must call this as soon as you're done with the Camera object.</p>\n     ",
    "links" : [ ]
  }, {
    "name" : "public final native void unlock()",
    "returnType" : "void",
    "comment" : "\n     * Unlocks the camera to allow another process to access it.\n     * Normally, the camera is locked to the process with an active Camera\n     * object until {@link #release()} is called.  To allow rapid handoff\n     * between processes, you can call this method to release the camera\n     * temporarily for another process to use; once the other process is done\n     * you can call {@link #reconnect()} to reclaim the camera.\n     *\n     * <p>This must be done before calling\n     * {@link android.media.MediaRecorder#setCamera(Camera)}. This cannot be\n     * called after recording starts.\n     *\n     * <p>If you are not recording video, you probably do not need this method.\n     *\n     * @throws RuntimeException if the camera cannot be unlocked.\n     ",
    "links" : [ "#reconnect()", "#release()", "android.media.MediaRecorder#setCamera(Camera)" ]
  }, {
    "name" : "public final native void lock()",
    "returnType" : "void",
    "comment" : "\n     * Re-locks the camera to prevent other processes from accessing it.\n     * Camera objects are locked by default unless {@link #unlock()} is\n     * called.  Normally {@link #reconnect()} is used instead.\n     *\n     * <p>Since API level 14, camera is automatically locked for applications in\n     * {@link android.media.MediaRecorder#start()}. Applications can use the\n     * camera (ex: zoom) after recording starts. There is no need to call this\n     * after recording starts or stops.\n     *\n     * <p>If you are not recording video, you probably do not need this method.\n     *\n     * @throws RuntimeException if the camera cannot be re-locked (for\n     *     example, if the camera is still in use by another process).\n     ",
    "links" : [ "#unlock()", "#reconnect()", "android.media.MediaRecorder#start()" ]
  }, {
    "name" : "public final native void reconnect() throws IOException",
    "returnType" : "void",
    "comment" : "\n     * Reconnects to the camera service after another process used it.\n     * After {@link #unlock()} is called, another process may use the\n     * camera; when the process is done, you must reconnect to the camera,\n     * which will re-acquire the lock and allow you to continue using the\n     * camera.\n     *\n     * <p>Since API level 14, camera is automatically locked for applications in\n     * {@link android.media.MediaRecorder#start()}. Applications can use the\n     * camera (ex: zoom) after recording starts. There is no need to call this\n     * after recording starts or stops.\n     *\n     * <p>If you are not recording video, you probably do not need this method.\n     *\n     * @throws IOException if a connection cannot be re-established (for\n     *     example, if the camera is still in use by another process).\n     * @throws RuntimeException if release() has been called on this Camera\n     *     instance.\n     ",
    "links" : [ "#unlock()", "android.media.MediaRecorder#start()" ]
  }, {
    "name" : "public final void setPreviewDisplay(SurfaceHolder holder) throws IOException",
    "returnType" : "void",
    "comment" : "\n     * Sets the {@link Surface} to be used for live preview.\n     * Either a surface or surface texture is necessary for preview, and\n     * preview is necessary to take pictures.  The same surface can be re-set\n     * without harm.  Setting a preview surface will un-set any preview surface\n     * texture that was set via {@link #setPreviewTexture}.\n     *\n     * <p>The {@link SurfaceHolder} must already contain a surface when this\n     * method is called.  If you are using {@link android.view.SurfaceView},\n     * you will need to register a {@link SurfaceHolder.Callback} with\n     * {@link SurfaceHolder#addCallback(SurfaceHolder.Callback)} and wait for\n     * {@link SurfaceHolder.Callback#surfaceCreated(SurfaceHolder)} before\n     * calling setPreviewDisplay() or starting preview.\n     *\n     * <p>This method must be called before {@link #startPreview()}.  The\n     * one exception is that if the preview surface is not set (or set to null)\n     * before startPreview() is called, then this method may be called once\n     * with a non-null parameter to set the preview surface.  (This allows\n     * camera setup and surface creation to happen in parallel, saving time.)\n     * The preview surface may not otherwise change while preview is running.\n     *\n     * @param holder containing the Surface on which to place the preview,\n     *     or null to remove the preview surface\n     * @throws IOException if the method fails (for example, if the surface\n     *     is unavailable or unsuitable).\n     * @throws RuntimeException if release() has been called on this Camera\n     *    instance.\n     ",
    "links" : [ "#setPreviewTexture", "SurfaceHolder.Callback#surfaceCreated(SurfaceHolder)", "SurfaceHolder.Callback", "android.view.SurfaceView", "android.view.Surface", "#startPreview()", "android.view.SurfaceHolder#addCallback(SurfaceHolder.Callback)", "android.view.SurfaceHolder" ]
  }, {
    "name" : "public final native void setPreviewSurface(Surface surface) throws IOException",
    "returnType" : "void",
    "comment" : "\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public final native void setPreviewTexture(SurfaceTexture surfaceTexture) throws IOException",
    "returnType" : "void",
    "comment" : "\n     * Sets the {@link SurfaceTexture} to be used for live preview.\n     * Either a surface or surface texture is necessary for preview, and\n     * preview is necessary to take pictures.  The same surface texture can be\n     * re-set without harm.  Setting a preview surface texture will un-set any\n     * preview surface that was set via {@link #setPreviewDisplay}.\n     *\n     * <p>This method must be called before {@link #startPreview()}.  The\n     * one exception is that if the preview surface texture is not set (or set\n     * to null) before startPreview() is called, then this method may be called\n     * once with a non-null parameter to set the preview surface.  (This allows\n     * camera setup and surface creation to happen in parallel, saving time.)\n     * The preview surface texture may not otherwise change while preview is\n     * running.\n     *\n     * <p>The timestamps provided by {@link SurfaceTexture#getTimestamp()} for a\n     * SurfaceTexture set as the preview texture have an unspecified zero point,\n     * and cannot be directly compared between different cameras or different\n     * instances of the same camera, or across multiple runs of the same\n     * program.\n     *\n     * <p>If you are using the preview data to create video or still images,\n     * strongly consider using {@link android.media.MediaActionSound} to\n     * properly indicate image capture or recording start/stop to the user.</p>\n     *\n     * @see android.media.MediaActionSound\n     * @see android.graphics.SurfaceTexture\n     * @see android.view.TextureView\n     * @param surfaceTexture the {@link SurfaceTexture} to which the preview\n     *     images are to be sent or null to remove the current preview surface\n     *     texture\n     * @throws IOException if the method fails (for example, if the surface\n     *     texture is unavailable or unsuitable).\n     * @throws RuntimeException if release() has been called on this Camera\n     *    instance.\n     ",
    "links" : [ "android.graphics.SurfaceTexture", "android.graphics.SurfaceTexture#getTimestamp()", "#setPreviewDisplay", "#startPreview()", "android.media.MediaActionSound" ]
  }, {
    "name" : "public final native void startPreview()",
    "returnType" : "void",
    "comment" : "\n     * Starts capturing and drawing preview frames to the screen.\n     * Preview will not actually start until a surface is supplied\n     * with {@link #setPreviewDisplay(SurfaceHolder)} or\n     * {@link #setPreviewTexture(SurfaceTexture)}.\n     *\n     * <p>If {@link #setPreviewCallback(Camera.PreviewCallback)},\n     * {@link #setOneShotPreviewCallback(Camera.PreviewCallback)}, or\n     * {@link #setPreviewCallbackWithBuffer(Camera.PreviewCallback)} were\n     * called, {@link Camera.PreviewCallback#onPreviewFrame(byte[], Camera)}\n     * will be called when preview data becomes available.\n     *\n     * @throws RuntimeException if starting preview fails; usually this would be\n     *    because of a hardware or other low-level error, or because release()\n     *    has been called on this Camera instance. The QCIF (176x144) exception\n     *    mentioned in {@link Parameters#setPreviewSize setPreviewSize} and\n     *    {@link Parameters#setPictureSize setPictureSize} can also cause this\n     *    exception be thrown.\n     ",
    "links" : [ "#setPictureSize", "#setPreviewCallback(Camera.PreviewCallback)", "Camera.PreviewCallback#onPreviewFrame(byte", "#setPreviewDisplay(SurfaceHolder)", "#setPreviewCallbackWithBuffer(Camera.PreviewCallback)", "#setOneShotPreviewCallback(Camera.PreviewCallback)", "#setPreviewTexture(SurfaceTexture)", "#setPreviewSize" ]
  }, {
    "name" : "public final void stopPreview()",
    "returnType" : "void",
    "comment" : "\n     * Stops capturing and drawing preview frames to the surface, and\n     * resets the camera for a future call to {@link #startPreview()}.\n     *\n     * @throws RuntimeException if stopping preview fails; usually this would be\n     *    because of a hardware or other low-level error, or because release()\n     *    has been called on this Camera instance.\n     ",
    "links" : [ "#startPreview()" ]
  }, {
    "name" : "private final native void _stopPreview()",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public final native boolean previewEnabled()",
    "returnType" : "boolean",
    "comment" : "\n     * Return current preview state.\n     *\n     * FIXME: Unhide before release\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public final void setPreviewCallback(PreviewCallback cb)",
    "returnType" : "void",
    "comment" : "\n     * <p>Installs a callback to be invoked for every preview frame in addition\n     * to displaying them on the screen.  The callback will be repeatedly called\n     * for as long as preview is active.  This method can be called at any time,\n     * even while preview is live.  Any other preview callbacks are\n     * overridden.</p>\n     *\n     * <p>If you are using the preview data to create video or still images,\n     * strongly consider using {@link android.media.MediaActionSound} to\n     * properly indicate image capture or recording start/stop to the user.</p>\n     *\n     * @param cb a callback object that receives a copy of each preview frame,\n     *     or null to stop receiving callbacks.\n     * @throws RuntimeException if release() has been called on this Camera\n     *     instance.\n     * @see android.media.MediaActionSound\n     ",
    "links" : [ "android.media.MediaActionSound" ]
  }, {
    "name" : "public final void setOneShotPreviewCallback(PreviewCallback cb)",
    "returnType" : "void",
    "comment" : "\n     * <p>Installs a callback to be invoked for the next preview frame in\n     * addition to displaying it on the screen.  After one invocation, the\n     * callback is cleared. This method can be called any time, even when\n     * preview is live.  Any other preview callbacks are overridden.</p>\n     *\n     * <p>If you are using the preview data to create video or still images,\n     * strongly consider using {@link android.media.MediaActionSound} to\n     * properly indicate image capture or recording start/stop to the user.</p>\n     *\n     * @param cb a callback object that receives a copy of the next preview frame,\n     *     or null to stop receiving callbacks.\n     * @throws RuntimeException if release() has been called on this Camera\n     *     instance.\n     * @see android.media.MediaActionSound\n     ",
    "links" : [ "android.media.MediaActionSound" ]
  }, {
    "name" : "private final native void setHasPreviewCallback(boolean installed, boolean manualBuffer)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public final void setPreviewCallbackWithBuffer(PreviewCallback cb)",
    "returnType" : "void",
    "comment" : "\n     * <p>Installs a callback to be invoked for every preview frame, using\n     * buffers supplied with {@link #addCallbackBuffer(byte[])}, in addition to\n     * displaying them on the screen.  The callback will be repeatedly called\n     * for as long as preview is active and buffers are available.  Any other\n     * preview callbacks are overridden.</p>\n     *\n     * <p>The purpose of this method is to improve preview efficiency and frame\n     * rate by allowing preview frame memory reuse.  You must call\n     * {@link #addCallbackBuffer(byte[])} at some point -- before or after\n     * calling this method -- or no callbacks will received.</p>\n     *\n     * <p>The buffer queue will be cleared if this method is called with a null\n     * callback, {@link #setPreviewCallback(Camera.PreviewCallback)} is called,\n     * or {@link #setOneShotPreviewCallback(Camera.PreviewCallback)} is\n     * called.</p>\n     *\n     * <p>If you are using the preview data to create video or still images,\n     * strongly consider using {@link android.media.MediaActionSound} to\n     * properly indicate image capture or recording start/stop to the user.</p>\n     *\n     * @param cb a callback object that receives a copy of the preview frame,\n     *     or null to stop receiving callbacks and clear the buffer queue.\n     * @throws RuntimeException if release() has been called on this Camera\n     *     instance.\n     * @see #addCallbackBuffer(byte[])\n     * @see android.media.MediaActionSound\n     ",
    "links" : [ "#setPreviewCallback(Camera.PreviewCallback)", "android.media.MediaActionSound", "#setOneShotPreviewCallback(Camera.PreviewCallback)", "#addCallbackBuffer(byte" ]
  }, {
    "name" : "public final void addCallbackBuffer(byte[] callbackBuffer)",
    "returnType" : "void",
    "comment" : "\n     * Adds a pre-allocated buffer to the preview callback buffer queue.\n     * Applications can add one or more buffers to the queue. When a preview\n     * frame arrives and there is still at least one available buffer, the\n     * buffer will be used and removed from the queue. Then preview callback is\n     * invoked with the buffer. If a frame arrives and there is no buffer left,\n     * the frame is discarded. Applications should add buffers back when they\n     * finish processing the data in them.\n     *\n     * <p>For formats besides YV12, the size of the buffer is determined by\n     * multiplying the preview image width, height, and bytes per pixel. The\n     * width and height can be read from\n     * {@link Camera.Parameters#getPreviewSize()}. Bytes per pixel can be\n     * computed from {@link android.graphics.ImageFormat#getBitsPerPixel(int)} /\n     * 8, using the image format from\n     * {@link Camera.Parameters#getPreviewFormat()}.\n     *\n     * <p>If using the {@link android.graphics.ImageFormat#YV12} format, the\n     * size can be calculated using the equations listed in\n     * {@link Camera.Parameters#setPreviewFormat}.\n     *\n     * <p>This method is only necessary when\n     * {@link #setPreviewCallbackWithBuffer(PreviewCallback)} is used. When\n     * {@link #setPreviewCallback(PreviewCallback)} or\n     * {@link #setOneShotPreviewCallback(PreviewCallback)} are used, buffers\n     * are automatically allocated. When a supplied buffer is too small to\n     * hold the preview frame data, preview callback will return null and\n     * the buffer will be removed from the buffer queue.\n     *\n     * @param callbackBuffer the buffer to add to the queue. The size of the\n     *   buffer must match the values described above.\n     * @see #setPreviewCallbackWithBuffer(PreviewCallback)\n     ",
    "links" : [ "android.graphics.ImageFormat#YV12", "android.graphics.ImageFormat#getBitsPerPixel(int)", "#setPreviewCallbackWithBuffer(PreviewCallback)", "Camera.Parameters#setPreviewFormat", "#setOneShotPreviewCallback(PreviewCallback)", "Camera.Parameters#getPreviewSize()", "Camera.Parameters#getPreviewFormat()", "#setPreviewCallback(PreviewCallback)" ]
  }, {
    "name" : "public final void addRawImageCallbackBuffer(byte[] callbackBuffer)",
    "returnType" : "void",
    "comment" : "\n     * Adds a pre-allocated buffer to the raw image callback buffer queue.\n     * Applications can add one or more buffers to the queue. When a raw image\n     * frame arrives and there is still at least one available buffer, the\n     * buffer will be used to hold the raw image data and removed from the\n     * queue. Then raw image callback is invoked with the buffer. If a raw\n     * image frame arrives but there is no buffer left, the frame is\n     * discarded. Applications should add buffers back when they finish\n     * processing the data in them by calling this method again in order\n     * to avoid running out of raw image callback buffers.\n     *\n     * <p>The size of the buffer is determined by multiplying the raw image\n     * width, height, and bytes per pixel. The width and height can be\n     * read from {@link Camera.Parameters#getPictureSize()}. Bytes per pixel\n     * can be computed from\n     * {@link android.graphics.ImageFormat#getBitsPerPixel(int)} / 8,\n     * using the image format from {@link Camera.Parameters#getPreviewFormat()}.\n     *\n     * <p>This method is only necessary when the PictureCallbck for raw image\n     * is used while calling {@link #takePicture(Camera.ShutterCallback,\n     * Camera.PictureCallback, Camera.PictureCallback, Camera.PictureCallback)}.\n     *\n     * <p>Please note that by calling this method, the mode for\n     * application-managed callback buffers is triggered. If this method has\n     * never been called, null will be returned by the raw image callback since\n     * there is no image callback buffer available. Furthermore, When a supplied\n     * buffer is too small to hold the raw image data, raw image callback will\n     * return null and the buffer will be removed from the buffer queue.\n     *\n     * @param callbackBuffer the buffer to add to the raw image callback buffer\n     *     queue. The size should be width * height * (bits per pixel) / 8. An\n     *     null callbackBuffer will be ignored and won't be added to the queue.\n     *\n     * @see #takePicture(Camera.ShutterCallback,\n     * Camera.PictureCallback, Camera.PictureCallback, Camera.PictureCallback)}.\n     *\n     * {@hide}\n     ",
    "links" : [ "#takePicture(Camera.ShutterCallback", "android.graphics.ImageFormat#getBitsPerPixel(int)", "Camera.Parameters#getPictureSize()", "Camera.Parameters#getPreviewFormat()" ]
  }, {
    "name" : "private final void addCallbackBuffer(byte[] callbackBuffer, int msgType)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private final native void _addCallbackBuffer(byte[] callbackBuffer, int msgType)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private final native void setPreviewCallbackSurface(Surface s)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private static void postEventFromNative(Object camera_ref, int what, int arg1, int arg2, Object obj)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public final void autoFocus(AutoFocusCallback cb)",
    "returnType" : "void",
    "comment" : "\n     * Starts camera auto-focus and registers a callback function to run when\n     * the camera is focused.  This method is only valid when preview is active\n     * (between {@link #startPreview()} and before {@link #stopPreview()}).\n     *\n     * <p>Callers should check\n     * {@link android.hardware.Camera.Parameters#getFocusMode()} to determine if\n     * this method should be called. If the camera does not support auto-focus,\n     * it is a no-op and {@link AutoFocusCallback#onAutoFocus(boolean, Camera)}\n     * callback will be called immediately.\n     *\n     * <p>If your application should not be installed\n     * on devices without auto-focus, you must declare that your application\n     * uses auto-focus with the\n     * <a href=\"{@docRoot}guide/topics/manifest/uses-feature-element.html\">&lt;uses-feature></a>\n     * manifest element.</p>\n     *\n     * <p>If the current flash mode is not\n     * {@link android.hardware.Camera.Parameters#FLASH_MODE_OFF}, flash may be\n     * fired during auto-focus, depending on the driver and camera hardware.<p>\n     *\n     * <p>Auto-exposure lock {@link android.hardware.Camera.Parameters#getAutoExposureLock()}\n     * and auto-white balance locks {@link android.hardware.Camera.Parameters#getAutoWhiteBalanceLock()}\n     * do not change during and after autofocus. But auto-focus routine may stop\n     * auto-exposure and auto-white balance transiently during focusing.\n     *\n     * <p>Stopping preview with {@link #stopPreview()}, or triggering still\n     * image capture with {@link #takePicture(Camera.ShutterCallback,\n     * Camera.PictureCallback, Camera.PictureCallback)}, will not change the\n     * the focus position. Applications must call cancelAutoFocus to reset the\n     * focus.</p>\n     *\n     * <p>If autofocus is successful, consider using\n     * {@link android.media.MediaActionSound} to properly play back an autofocus\n     * success sound to the user.</p>\n     *\n     * @param cb the callback to run\n     * @throws RuntimeException if starting autofocus fails; usually this would\n     *    be because of a hardware or other low-level error, or because\n     *    release() has been called on this Camera instance.\n     * @see #cancelAutoFocus()\n     * @see android.hardware.Camera.Parameters#setAutoExposureLock(boolean)\n     * @see android.hardware.Camera.Parameters#setAutoWhiteBalanceLock(boolean)\n     * @see android.media.MediaActionSound\n     ",
    "links" : [ "android.hardware.Camera.Parameters#getAutoExposureLock()", "#takePicture(Camera.ShutterCallback", "#onAutoFocus(boolean", "#startPreview()", "android.hardware.Camera.Parameters#FLASH_MODE_OFF", "android.hardware.Camera.Parameters#getFocusMode()", "android.media.MediaActionSound", "android.hardware.Camera.Parameters#getAutoWhiteBalanceLock()", "#stopPreview()" ]
  }, {
    "name" : "private final native void native_autoFocus()",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public final void cancelAutoFocus()",
    "returnType" : "void",
    "comment" : "\n     * Cancels any auto-focus function in progress.\n     * Whether or not auto-focus is currently in progress,\n     * this function will return the focus position to the default.\n     * If the camera does not support auto-focus, this is a no-op.\n     *\n     * @throws RuntimeException if canceling autofocus fails; usually this would\n     *    be because of a hardware or other low-level error, or because\n     *    release() has been called on this Camera instance.\n     * @see #autoFocus(Camera.AutoFocusCallback)\n     ",
    "links" : [ ]
  }, {
    "name" : "private final native void native_cancelAutoFocus()",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public void setAutoFocusMoveCallback(AutoFocusMoveCallback cb)",
    "returnType" : "void",
    "comment" : "\n     * Sets camera auto-focus move callback.\n     *\n     * @param cb the callback to run\n     * @throws RuntimeException if enabling the focus move callback fails;\n     *    usually this would be because of a hardware or other low-level error,\n     *    or because release() has been called on this Camera instance.\n     ",
    "links" : [ ]
  }, {
    "name" : "private native void enableFocusMoveCallback(int enable)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public final void takePicture(ShutterCallback shutter, PictureCallback raw, PictureCallback jpeg)",
    "returnType" : "void",
    "comment" : "\n     * Equivalent to <pre>takePicture(Shutter, raw, null, jpeg)</pre>.\n     *\n     * @see #takePicture(ShutterCallback, PictureCallback, PictureCallback, PictureCallback)\n     ",
    "links" : [ ]
  }, {
    "name" : "private final native void native_takePicture(int msgType)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public final void takePicture(ShutterCallback shutter, PictureCallback raw, PictureCallback postview, PictureCallback jpeg)",
    "returnType" : "void",
    "comment" : "\n     * Triggers an asynchronous image capture. The camera service will initiate\n     * a series of callbacks to the application as the image capture progresses.\n     * The shutter callback occurs after the image is captured. This can be used\n     * to trigger a sound to let the user know that image has been captured. The\n     * raw callback occurs when the raw image data is available (NOTE: the data\n     * will be null if there is no raw image callback buffer available or the\n     * raw image callback buffer is not large enough to hold the raw image).\n     * The postview callback occurs when a scaled, fully processed postview\n     * image is available (NOTE: not all hardware supports this). The jpeg\n     * callback occurs when the compressed image is available. If the\n     * application does not need a particular callback, a null can be passed\n     * instead of a callback method.\n     *\n     * <p>This method is only valid when preview is active (after\n     * {@link #startPreview()}).  Preview will be stopped after the image is\n     * taken; callers must call {@link #startPreview()} again if they want to\n     * re-start preview or take more pictures. This should not be called between\n     * {@link android.media.MediaRecorder#start()} and\n     * {@link android.media.MediaRecorder#stop()}.\n     *\n     * <p>After calling this method, you must not call {@link #startPreview()}\n     * or take another picture until the JPEG callback has returned.\n     *\n     * @param shutter   the callback for image capture moment, or null\n     * @param raw       the callback for raw (uncompressed) image data, or null\n     * @param postview  callback with postview image data, may be null\n     * @param jpeg      the callback for JPEG image data, or null\n     * @throws RuntimeException if starting picture capture fails; usually this\n     *    would be because of a hardware or other low-level error, or because\n     *    release() has been called on this Camera instance.\n     ",
    "links" : [ "android.media.MediaRecorder#start()", "#startPreview()", "android.media.MediaRecorder#stop()" ]
  }, {
    "name" : "public final native void startSmoothZoom(int value)",
    "returnType" : "void",
    "comment" : "\n     * Zooms to the requested value smoothly. The driver will notify {@link\n     * OnZoomChangeListener} of the zoom value and whether zoom is stopped at\n     * the time. For example, suppose the current zoom is 0 and startSmoothZoom\n     * is called with value 3. The\n     * {@link Camera.OnZoomChangeListener#onZoomChange(int, boolean, Camera)}\n     * method will be called three times with zoom values 1, 2, and 3.\n     * Applications can call {@link #stopSmoothZoom} to stop the zoom earlier.\n     * Applications should not call startSmoothZoom again or change the zoom\n     * value before zoom stops. If the supplied zoom value equals to the current\n     * zoom value, no zoom callback will be generated. This method is supported\n     * if {@link android.hardware.Camera.Parameters#isSmoothZoomSupported}\n     * returns true.\n     *\n     * @param value zoom value. The valid range is 0 to {@link\n     *              android.hardware.Camera.Parameters#getMaxZoom}.\n     * @throws IllegalArgumentException if the zoom value is invalid.\n     * @throws RuntimeException if the method fails.\n     * @see #setZoomChangeListener(OnZoomChangeListener)\n     ",
    "links" : [ "#stopSmoothZoom", "Camera.OnZoomChangeListener#onZoomChange(int", "android.hardware.Camera.Parameters#getMaxZoom", "OnZoomChangeListener", "android.hardware.Camera.Parameters#isSmoothZoomSupported" ]
  }, {
    "name" : "public final native void stopSmoothZoom()",
    "returnType" : "void",
    "comment" : "\n     * Stops the smooth zoom. Applications should wait for the {@link\n     * OnZoomChangeListener} to know when the zoom is actually stopped. This\n     * method is supported if {@link\n     * android.hardware.Camera.Parameters#isSmoothZoomSupported} is true.\n     *\n     * @throws RuntimeException if the method fails.\n     ",
    "links" : [ "OnZoomChangeListener", "android.hardware.Camera.Parameters#isSmoothZoomSupported" ]
  }, {
    "name" : "public final native void setDisplayOrientation(int degrees)",
    "returnType" : "void",
    "comment" : "\n     * Set the clockwise rotation of preview display in degrees. This affects\n     * the preview frames and the picture displayed after snapshot. This method\n     * is useful for portrait mode applications. Note that preview display of\n     * front-facing cameras is flipped horizontally before the rotation, that\n     * is, the image is reflected along the central vertical axis of the camera\n     * sensor. So the users can see themselves as looking into a mirror.\n     *\n     * <p>This does not affect the order of byte array passed in {@link\n     * PreviewCallback#onPreviewFrame}, JPEG pictures, or recorded videos. This\n     * method is not allowed to be called during preview.\n     *\n     * <p>If you want to make the camera image show in the same orientation as\n     * the display, you can use the following code.\n     * <pre>\n     * public static void setCameraDisplayOrientation(Activity activity,\n     *         int cameraId, android.hardware.Camera camera) {\n     *     android.hardware.Camera.CameraInfo info =\n     *             new android.hardware.Camera.CameraInfo();\n     *     android.hardware.Camera.getCameraInfo(cameraId, info);\n     *     int rotation = activity.getWindowManager().getDefaultDisplay()\n     *             .getRotation();\n     *     int degrees = 0;\n     *     switch (rotation) {\n     *         case Surface.ROTATION_0: degrees = 0; break;\n     *         case Surface.ROTATION_90: degrees = 90; break;\n     *         case Surface.ROTATION_180: degrees = 180; break;\n     *         case Surface.ROTATION_270: degrees = 270; break;\n     *     }\n     *\n     *     int result;\n     *     if (info.facing == Camera.CameraInfo.CAMERA_FACING_FRONT) {\n     *         result = (info.orientation + degrees) % 360;\n     *         result = (360 - result) % 360;  // compensate the mirror\n     *     } else {  // back-facing\n     *         result = (info.orientation - degrees + 360) % 360;\n     *     }\n     *     camera.setDisplayOrientation(result);\n     * }\n     * </pre>\n     *\n     * <p>Starting from API level 14, this method can be called when preview is\n     * active.\n     *\n     * <p><b>Note: </b>Before API level 24, the default value for orientation is 0. Starting in\n     * API level 24, the default orientation will be such that applications in forced-landscape mode\n     * will have correct preview orientation, which may be either a default of 0 or\n     * 180. Applications that operate in portrait mode or allow for changing orientation must still\n     * call this method after each orientation change to ensure correct preview display in all\n     * cases.</p>\n     *\n     * @param degrees the angle that the picture will be rotated clockwise.\n     *                Valid values are 0, 90, 180, and 270.\n     * @throws RuntimeException if setting orientation fails; usually this would\n     *    be because of a hardware or other low-level error, or because\n     *    release() has been called on this Camera instance.\n     * @see #setPreviewDisplay(SurfaceHolder)\n     ",
    "links" : [ "#onPreviewFrame" ]
  }, {
    "name" : "public final boolean enableShutterSound(boolean enabled)",
    "returnType" : "boolean",
    "comment" : "\n     * <p>Enable or disable the default shutter sound when taking a picture.</p>\n     *\n     * <p>By default, the camera plays the system-defined camera shutter sound\n     * when {@link #takePicture} is called. Using this method, the shutter sound\n     * can be disabled. It is strongly recommended that an alternative shutter\n     * sound is played in the {@link ShutterCallback} when the system shutter\n     * sound is disabled.</p>\n     *\n     * <p>Note that devices may not always allow disabling the camera shutter\n     * sound. If the shutter sound state cannot be set to the desired value,\n     * this method will return false. {@link CameraInfo#canDisableShutterSound}\n     * can be used to determine whether the device will allow the shutter sound\n     * to be disabled.</p>\n     *\n     * @param enabled whether the camera should play the system shutter sound\n     *                when {@link #takePicture takePicture} is called.\n     * @return {@code true} if the shutter sound state was successfully\n     *         changed. {@code false} if the shutter sound state could not be\n     *         changed. {@code true} is also returned if shutter sound playback\n     *         is already set to the requested state.\n     * @throws RuntimeException if the call fails; usually this would be because\n     *    of a hardware or other low-level error, or because release() has been\n     *    called on this Camera instance.\n     * @see #takePicture\n     * @see CameraInfo#canDisableShutterSound\n     * @see ShutterCallback\n     ",
    "links" : [ "android.hardware.CameraInfo#canDisableShutterSound", "ShutterCallback", "#takePicture" ]
  }, {
    "name" : "public final boolean disableShutterSound()",
    "returnType" : "boolean",
    "comment" : "\n     * Disable the shutter sound unconditionally.\n     *\n     * <p>\n     * This is only guaranteed to work for legacy cameras\n     * (i.e. initialized with {@link #cameraInitUnspecified}). Trying to call this on\n     * a regular camera will force a conditional check in the camera service.\n     * </p>\n     *\n     * @return {@code true} if the shutter sound state was successfully\n     *         changed. {@code false} if the shutter sound state could not be\n     *         changed. {@code true} is also returned if shutter sound playback\n     *         is already set to the requested state.\n     *\n     * @hide\n     ",
    "links" : [ "#cameraInitUnspecified" ]
  }, {
    "name" : "private final native boolean _enableShutterSound(boolean enabled)",
    "returnType" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private void updateAppOpsPlayAudio()",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public final void setZoomChangeListener(OnZoomChangeListener listener)",
    "returnType" : "void",
    "comment" : "\n     * Registers a listener to be notified when the zoom value is updated by the\n     * camera driver during smooth zoom.\n     *\n     * @param listener the listener to notify\n     * @see #startSmoothZoom(int)\n     ",
    "links" : [ ]
  }, {
    "name" : "public final void setFaceDetectionListener(FaceDetectionListener listener)",
    "returnType" : "void",
    "comment" : "\n     * Registers a listener to be notified about the faces detected in the\n     * preview frame.\n     *\n     * @param listener the listener to notify\n     * @see #startFaceDetection()\n     ",
    "links" : [ ]
  }, {
    "name" : "public final void startFaceDetection()",
    "returnType" : "void",
    "comment" : "\n     * Starts the face detection. This should be called after preview is started.\n     * The camera will notify {@link FaceDetectionListener} of the detected\n     * faces in the preview frame. The detected faces may be the same as the\n     * previous ones. Applications should call {@link #stopFaceDetection} to\n     * stop the face detection. This method is supported if {@link\n     * Parameters#getMaxNumDetectedFaces()} returns a number larger than 0.\n     * If the face detection has started, apps should not call this again.\n     *\n     * <p>When the face detection is running, {@link Parameters#setWhiteBalance(String)},\n     * {@link Parameters#setFocusAreas(List)}, and {@link Parameters#setMeteringAreas(List)}\n     * have no effect. The camera uses the detected faces to do auto-white balance,\n     * auto exposure, and autofocus.\n     *\n     * <p>If the apps call {@link #autoFocus(AutoFocusCallback)}, the camera\n     * will stop sending face callbacks. The last face callback indicates the\n     * areas used to do autofocus. After focus completes, face detection will\n     * resume sending face callbacks. If the apps call {@link\n     * #cancelAutoFocus()}, the face callbacks will also resume.</p>\n     *\n     * <p>After calling {@link #takePicture(Camera.ShutterCallback, Camera.PictureCallback,\n     * Camera.PictureCallback)} or {@link #stopPreview()}, and then resuming\n     * preview with {@link #startPreview()}, the apps should call this method\n     * again to resume face detection.</p>\n     *\n     * @throws IllegalArgumentException if the face detection is unsupported.\n     * @throws RuntimeException if the method fails or the face detection is\n     *         already running.\n     * @see FaceDetectionListener\n     * @see #stopFaceDetection()\n     * @see Parameters#getMaxNumDetectedFaces()\n     ",
    "links" : [ "#getMaxNumDetectedFaces()", "#takePicture(Camera.ShutterCallback", "#setFocusAreas(List)", "FaceDetectionListener", "#setMeteringAreas(List)", "#startPreview()", "#autoFocus(AutoFocusCallback)", "#cancelAutoFocus()", "#stopPreview()", "#stopFaceDetection", "#setWhiteBalance(String)" ]
  }, {
    "name" : "public final void stopFaceDetection()",
    "returnType" : "void",
    "comment" : "\n     * Stops the face detection.\n     *\n     * @see #startFaceDetection()\n     ",
    "links" : [ ]
  }, {
    "name" : "private final native void _startFaceDetection(int type)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private final native void _stopFaceDetection()",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public final void setErrorCallback(ErrorCallback cb)",
    "returnType" : "void",
    "comment" : "\n     * Registers a callback to be invoked when an error occurs.\n     * @param cb The callback to run\n     ",
    "links" : [ ]
  }, {
    "name" : "public final void setDetailedErrorCallback(ErrorCallback cb)",
    "returnType" : "void",
    "comment" : "\n     * Registers a callback to be invoked when an error occurs.\n     * The detailed error callback may contain error code that\n     * gives more detailed information about the error.\n     *\n     * When a detailed callback is set, the callback set via\n     * #setErrorCallback(ErrorCallback) will stop receiving\n     * onError call.\n     *\n     * @param cb The callback to run\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "private final native void native_setParameters(String params)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private final native String native_getParameters()",
    "returnType" : "String",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public void setParameters(Parameters params)",
    "returnType" : "void",
    "comment" : "\n     * Changes the settings for this Camera service.\n     *\n     * @param params the Parameters to use for this Camera service\n     * @throws RuntimeException if any parameter is invalid or not supported.\n     * @see #getParameters()\n     ",
    "links" : [ ]
  }, {
    "name" : "public Parameters getParameters()",
    "returnType" : "Parameters",
    "comment" : "\n     * Returns the current settings for this Camera service.\n     * If modifications are made to the returned Parameters, they must be passed\n     * to {@link #setParameters(Camera.Parameters)} to take effect.\n     *\n     * @throws RuntimeException if reading parameters fails; usually this would\n     *    be because of a hardware or other low-level error, or because\n     *    release() has been called on this Camera instance.\n     * @see #setParameters(Camera.Parameters)\n     ",
    "links" : [ "#setParameters(Camera.Parameters)" ]
  }, {
    "name" : "public static Parameters getEmptyParameters()",
    "returnType" : "Parameters",
    "comment" : "\n     * Returns an empty {@link Parameters} for testing purpose.\n     *\n     * @return a Parameter object.\n     *\n     * @hide\n     ",
    "links" : [ "Parameters" ]
  }, {
    "name" : "public static Parameters getParametersCopy(Camera.Parameters parameters)",
    "returnType" : "Parameters",
    "comment" : "\n     * Returns a copied {@link Parameters}; for shim use only.\n     *\n     * @param parameters a non-{@code null} parameters\n     * @return a Parameter object, with all the parameters copied from {@code parameters}.\n     *\n     * @throws NullPointerException if {@code parameters} was {@code null}\n     * @hide\n     ",
    "links" : [ "Parameters" ]
  }, {
    "name" : "public final native void setAudioRestriction(int mode)",
    "returnType" : "void",
    "comment" : "\n     * Set camera audio restriction mode.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public final native int getAudioRestriction()",
    "returnType" : "int",
    "comment" : "\n     * Get currently applied camera audio restriction mode.\n     *\n     * @hide\n     ",
    "links" : [ ]
  } ],
  "methodNames" : [ "public static int getNumberOfCameras()", "public static int getNumberOfCameras(@NonNull Context context)", "private static native int _getNumberOfCameras(int deviceId, int devicePolicy)", "public static void getCameraInfo(int cameraId, CameraInfo cameraInfo)", "public static void getCameraInfo(int cameraId, @NonNull Context context, int rotationOverride, CameraInfo cameraInfo)", "private static native void _getCameraInfo(int cameraId, int rotationOverride, int deviceId, int devicePolicy, CameraInfo cameraInfo)", "private static int getDevicePolicyFromContext(Context context)", "public static Camera open(int cameraId)", "public static Camera open(int cameraId, @NonNull Context context, int rotationOverride)", "public static Camera open()", "public static Camera openLegacy(int cameraId, int halVersion)", "private int cameraInit(int cameraId, Context context, int rotationOverride)", "private boolean shouldForceSlowJpegMode()", "public static boolean checkInitErrors(int err)", "public static Camera openUninitialized()", "private void initAppOps()", "private void releaseAppOps()", "protected void finalize()", "private native int native_setup(Object cameraThis, int cameraId, String packageName, int rotationOverride, boolean forceSlowJpegMode, int deviceId, int devicePolicy)", "private final native void native_release()", "public final void release()", "public final native void unlock()", "public final native void lock()", "public final native void reconnect() throws IOException", "public final void setPreviewDisplay(SurfaceHolder holder) throws IOException", "public final native void setPreviewSurface(Surface surface) throws IOException", "public final native void setPreviewTexture(SurfaceTexture surfaceTexture) throws IOException", "public final native void startPreview()", "public final void stopPreview()", "private final native void _stopPreview()", "public final native boolean previewEnabled()", "public final void setPreviewCallback(PreviewCallback cb)", "public final void setOneShotPreviewCallback(PreviewCallback cb)", "private final native void setHasPreviewCallback(boolean installed, boolean manualBuffer)", "public final void setPreviewCallbackWithBuffer(PreviewCallback cb)", "public final void addCallbackBuffer(byte[] callbackBuffer)", "public final void addRawImageCallbackBuffer(byte[] callbackBuffer)", "private final void addCallbackBuffer(byte[] callbackBuffer, int msgType)", "private final native void _addCallbackBuffer(byte[] callbackBuffer, int msgType)", "private final native void setPreviewCallbackSurface(Surface s)", "private static void postEventFromNative(Object camera_ref, int what, int arg1, int arg2, Object obj)", "public final void autoFocus(AutoFocusCallback cb)", "private final native void native_autoFocus()", "public final void cancelAutoFocus()", "private final native void native_cancelAutoFocus()", "public void setAutoFocusMoveCallback(AutoFocusMoveCallback cb)", "private native void enableFocusMoveCallback(int enable)", "public final void takePicture(ShutterCallback shutter, PictureCallback raw, PictureCallback jpeg)", "private final native void native_takePicture(int msgType)", "public final void takePicture(ShutterCallback shutter, PictureCallback raw, PictureCallback postview, PictureCallback jpeg)", "public final native void startSmoothZoom(int value)", "public final native void stopSmoothZoom()", "public final native void setDisplayOrientation(int degrees)", "public final boolean enableShutterSound(boolean enabled)", "public final boolean disableShutterSound()", "private final native boolean _enableShutterSound(boolean enabled)", "private void updateAppOpsPlayAudio()", "public final void setZoomChangeListener(OnZoomChangeListener listener)", "public final void setFaceDetectionListener(FaceDetectionListener listener)", "public final void startFaceDetection()", "public final void stopFaceDetection()", "private final native void _startFaceDetection(int type)", "private final native void _stopFaceDetection()", "public final void setErrorCallback(ErrorCallback cb)", "public final void setDetailedErrorCallback(ErrorCallback cb)", "private final native void native_setParameters(String params)", "private final native String native_getParameters()", "public void setParameters(Parameters params)", "public Parameters getParameters()", "public static Parameters getEmptyParameters()", "public static Parameters getParametersCopy(Camera.Parameters parameters)", "public final native void setAudioRestriction(int mode)", "public final native int getAudioRestriction()" ],
  "variableNames" : [ "TAG", "CAMERA_MSG_ERROR", "CAMERA_MSG_SHUTTER", "CAMERA_MSG_FOCUS", "CAMERA_MSG_ZOOM", "CAMERA_MSG_PREVIEW_FRAME", "CAMERA_MSG_VIDEO_FRAME", "CAMERA_MSG_POSTVIEW_FRAME", "CAMERA_MSG_RAW_IMAGE", "CAMERA_MSG_COMPRESSED_IMAGE", "CAMERA_MSG_RAW_IMAGE_NOTIFY", "CAMERA_MSG_PREVIEW_METADATA", "CAMERA_MSG_FOCUS_MOVE", "mNativeContext", "mEventHandler", "mShutterCallback", "mRawImageCallback", "mJpegCallback", "mPreviewCallback", "mUsingPreviewAllocation", "mPostviewCallback", "mAutoFocusCallback", "mAutoFocusMoveCallback", "mZoomListener", "mFaceListener", "mErrorCallback", "mDetailedErrorCallback", "mOneShot", "mWithBuffer", "mFaceDetectionRunning", "mAutoFocusCallbackLock", "mShutterSoundLock", "mAppOps", "mAppOpsCallback", "mHasAppOpsPlayAudio", "mShutterSoundEnabledFromApp", "NO_ERROR", "ACTION_NEW_PICTURE", "ACTION_NEW_VIDEO", "CAMERA_HAL_API_VERSION_1_0", "CAMERA_HAL_API_VERSION_3_0", "CAMERA_FACE_DETECTION_HW", "CAMERA_FACE_DETECTION_SW", "CAMERA_ERROR_UNKNOWN", "CAMERA_ERROR_EVICTED", "CAMERA_ERROR_DISABLED", "CAMERA_ERROR_SERVER_DIED" ]
}