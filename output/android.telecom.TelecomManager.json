{
  "filePath" : "/home/maryam/clearblue/files/android-source-35/android/telecom/TelecomManager.java",
  "packageName" : "android.telecom",
  "className" : "TelecomManager",
  "comment" : "\n * Provides access to information about active calls and registration/call-management functionality.\n * Apps can use methods in this class to determine the current call state.\n * <p>\n * Apps do not instantiate this class directly; instead, they retrieve a reference to an instance\n * through {@link Context#getSystemService Context.getSystemService(Context.TELECOM_SERVICE)}.\n * <p>\n * Note that access to some telecom information is permission-protected. Your app cannot access the\n * protected information or gain access to protected functionality unless it has the appropriate\n * permissions declared in its manifest file. Where permissions apply, they are noted in the method\n * descriptions.\n ",
  "links" : [ "android.content.Context#getSystemService" ],
  "variables" : [ {
    "name" : "ACTION_INCOMING_CALL",
    "type" : "String",
    "comment" : "\n     * Activity action: Starts the UI for handing an incoming call. This intent starts the in-call\n     * UI by notifying the Telecom system that an incoming call exists for a specific call service\n     * (see {@link android.telecom.ConnectionService}). Telecom reads the Intent extras to find\n     * and bind to the appropriate {@link android.telecom.ConnectionService} which Telecom will\n     * ultimately use to control and get information about the call.\n     * <p>\n     * Input: get*Extra field {@link #EXTRA_PHONE_ACCOUNT_HANDLE} contains the component name of the\n     * {@link android.telecom.ConnectionService} that Telecom should bind to. Telecom will then\n     * ask the connection service for more information about the call prior to showing any UI.\n     *\n     * @deprecated Use {@link #addNewIncomingCall} instead.\n     ",
    "links" : [ "android.telecom.ConnectionService", "#EXTRA_PHONE_ACCOUNT_HANDLE", "#addNewIncomingCall" ]
  }, {
    "name" : "ACTION_NEW_UNKNOWN_CALL",
    "type" : "String",
    "comment" : "\n     * Similar to {@link #ACTION_INCOMING_CALL}, but is used only by Telephony to add a new\n     * sim-initiated MO call for carrier testing.\n     * @deprecated Use {@link #addNewUnknownCall} instead.\n     * @hide\n     ",
    "links" : [ "#addNewUnknownCall", "#ACTION_INCOMING_CALL" ]
  }, {
    "name" : "ACTION_CONFIGURE_PHONE_ACCOUNT",
    "type" : "String",
    "comment" : "\n     * An {@link android.content.Intent} action sent by the telecom framework to start a\n     * configuration dialog for a registered {@link PhoneAccount}. There is no default dialog\n     * and each app that registers a {@link PhoneAccount} should provide one if desired.\n     * <p>\n     * A user can access the list of enabled {@link android.telecom.PhoneAccount}s through the Phone\n     * app's settings menu. For each entry, the settings app will add a click action. When\n     * triggered, the click-action will start this intent along with the extra\n     * {@link #EXTRA_PHONE_ACCOUNT_HANDLE} to indicate the {@link PhoneAccount} to configure. If the\n     * {@link PhoneAccount} package does not register an {@link android.app.Activity} for this\n     * intent, then it will not be sent.\n     ",
    "links" : [ "android.telecom.PhoneAccount", "android.content.Intent", "android.app.Activity", "#EXTRA_PHONE_ACCOUNT_HANDLE" ]
  }, {
    "name" : "ACTION_SHOW_CALL_ACCESSIBILITY_SETTINGS",
    "type" : "String",
    "comment" : "\n     * The {@link android.content.Intent} action used to show the call accessibility settings page.\n     ",
    "links" : [ "android.content.Intent" ]
  }, {
    "name" : "ACTION_SHOW_CALL_SETTINGS",
    "type" : "String",
    "comment" : "\n     * The {@link android.content.Intent} action used to show the call settings page.\n     ",
    "links" : [ "android.content.Intent" ]
  }, {
    "name" : "ACTION_SHOW_RESPOND_VIA_SMS_SETTINGS",
    "type" : "String",
    "comment" : "\n     * The {@link android.content.Intent} action used to show the respond via SMS settings page.\n     ",
    "links" : [ "android.content.Intent" ]
  }, {
    "name" : "ACTION_CHANGE_PHONE_ACCOUNTS",
    "type" : "String",
    "comment" : "\n     * The {@link android.content.Intent} action used to show the settings page used to configure\n     * {@link PhoneAccount} preferences.\n     ",
    "links" : [ "android.telecom.PhoneAccount", "android.content.Intent" ]
  }, {
    "name" : "ACTION_PHONE_ACCOUNT_REGISTERED",
    "type" : "String",
    "comment" : "\n     * {@link android.content.Intent} action used indicate that a new phone account was just\n     * registered.\n     * <p>\n     * The Intent {@link Intent#getExtras() extras} will contain {@link #EXTRA_PHONE_ACCOUNT_HANDLE}\n     * to indicate which {@link PhoneAccount} was registered.\n     * <p>\n     * Will only be sent to the default dialer app (see {@link #getDefaultDialerPackage()}).\n     ",
    "links" : [ "android.content.Intent#getExtras()", "android.telecom.PhoneAccount", "#getDefaultDialerPackage()", "android.content.Intent", "#EXTRA_PHONE_ACCOUNT_HANDLE" ]
  }, {
    "name" : "ACTION_PHONE_ACCOUNT_UNREGISTERED",
    "type" : "String",
    "comment" : "\n     * {@link android.content.Intent} action used indicate that a phone account was just\n     * unregistered.\n     * <p>\n     * The Intent {@link Intent#getExtras() extras} will contain {@link #EXTRA_PHONE_ACCOUNT_HANDLE}\n     * to indicate which {@link PhoneAccount} was unregistered.\n     * <p>\n     * Will only be sent to the default dialer app (see {@link #getDefaultDialerPackage()}).\n     ",
    "links" : [ "android.content.Intent#getExtras()", "android.telecom.PhoneAccount", "#getDefaultDialerPackage()", "android.content.Intent", "#EXTRA_PHONE_ACCOUNT_HANDLE" ]
  }, {
    "name" : "ACTION_CHANGE_DEFAULT_DIALER",
    "type" : "String",
    "comment" : "\n     * Activity action: Shows a dialog asking the user whether or not they want to replace the\n     * current default Dialer with the one specified in\n     * {@link #EXTRA_CHANGE_DEFAULT_DIALER_PACKAGE_NAME}.\n     *\n     * Usage example:\n     * <pre>\n     * Intent intent = new Intent(TelecomManager.ACTION_CHANGE_DEFAULT_DIALER);\n     * intent.putExtra(TelecomManager.EXTRA_CHANGE_DEFAULT_DIALER_PACKAGE_NAME,\n     *         getActivity().getPackageName());\n     * startActivity(intent);\n     * </pre>\n     * <p>\n     * This is no longer supported since Q, please use\n     * {@link android.app.role.RoleManager#createRequestRoleIntent(String)} with\n     * {@link android.app.role.RoleManager#ROLE_DIALER} instead.\n     ",
    "links" : [ "android.app.role.RoleManager#ROLE_DIALER", "android.app.role.RoleManager#createRequestRoleIntent(String)", "#EXTRA_CHANGE_DEFAULT_DIALER_PACKAGE_NAME" ]
  }, {
    "name" : "ACTION_DEFAULT_DIALER_CHANGED",
    "type" : "String",
    "comment" : "\n     * Broadcast intent action indicating that the current default dialer has changed.\n     * The string extra {@link #EXTRA_CHANGE_DEFAULT_DIALER_PACKAGE_NAME} will contain the\n     * name of the package that the default dialer was changed to.\n     *\n     * @see #EXTRA_CHANGE_DEFAULT_DIALER_PACKAGE_NAME\n     ",
    "links" : [ "#EXTRA_CHANGE_DEFAULT_DIALER_PACKAGE_NAME" ]
  }, {
    "name" : "EXTRA_CHANGE_DEFAULT_DIALER_PACKAGE_NAME",
    "type" : "String",
    "comment" : "\n     * Extra value used to provide the package name for {@link #ACTION_CHANGE_DEFAULT_DIALER}.\n     ",
    "links" : [ "#ACTION_CHANGE_DEFAULT_DIALER" ]
  }, {
    "name" : "ACTION_DEFAULT_CALL_SCREENING_APP_CHANGED",
    "type" : "String",
    "comment" : "\n     * Broadcast intent action indicating that the current default call screening app has changed.\n     * <p>\n     * Note: This intent is NEVER actually broadcast and will be deprecated in the future.\n     * <p>\n     * An app that want to know if it holds the\n     * {@link android.app.role.RoleManager#ROLE_CALL_SCREENING} role can use\n     * {@link android.app.role.RoleManager#isRoleHeld(String)} to confirm if it holds the role or\n     * not.\n     ",
    "links" : [ "android.app.role.RoleManager#ROLE_CALL_SCREENING", "android.app.role.RoleManager#isRoleHeld(String)" ]
  }, {
    "name" : "EXTRA_DEFAULT_CALL_SCREENING_APP_COMPONENT_NAME",
    "type" : "String",
    "comment" : "\n     * Extra value used with {@link #ACTION_DEFAULT_CALL_SCREENING_APP_CHANGED} broadcast to\n     * indicate the ComponentName of the call screening app which has changed.\n     * <p>\n     * Note: This extra is NOT used and will be deprecated in the future.\n     ",
    "links" : [ "#ACTION_DEFAULT_CALL_SCREENING_APP_CHANGED" ]
  }, {
    "name" : "EXTRA_DO_NOT_LOG_CALL",
    "type" : "String",
    "comment" : "\n     * Optional extra to indicate a call should not be added to the call log.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "EXTRA_IS_DEFAULT_CALL_SCREENING_APP",
    "type" : "String",
    "comment" : "\n     * Extra value used with {@link #ACTION_DEFAULT_CALL_SCREENING_APP_CHANGED} broadcast to\n     * indicate whether an app is the default call screening app.\n     * <p>\n     * Note: This extra is NOT used and will be deprecated in the future.\n     ",
    "links" : [ "#ACTION_DEFAULT_CALL_SCREENING_APP_CHANGED" ]
  }, {
    "name" : "EXTRA_START_CALL_WITH_SPEAKERPHONE",
    "type" : "String",
    "comment" : "\n     * Optional extra for {@link android.content.Intent#ACTION_CALL} containing a boolean that\n     * determines whether the speakerphone should be automatically turned on for an outgoing call.\n     ",
    "links" : [ "android.content.Intent#ACTION_CALL" ]
  }, {
    "name" : "EXTRA_START_CALL_WITH_VIDEO_STATE",
    "type" : "String",
    "comment" : "\n     * Optional extra for {@link android.content.Intent#ACTION_CALL} containing an integer that\n     * determines the desired video state for an outgoing call.\n     * Valid options:\n     * {@link VideoProfile#STATE_AUDIO_ONLY},\n     * {@link VideoProfile#STATE_BIDIRECTIONAL},\n     * {@link VideoProfile#STATE_RX_ENABLED},\n     * {@link VideoProfile#STATE_TX_ENABLED}.\n     ",
    "links" : [ "android.content.Intent#ACTION_CALL", "android.telecom.VideoProfile#STATE_BIDIRECTIONAL", "android.telecom.VideoProfile#STATE_RX_ENABLED", "android.telecom.VideoProfile#STATE_AUDIO_ONLY", "android.telecom.VideoProfile#STATE_TX_ENABLED" ]
  }, {
    "name" : "EXTRA_INCOMING_VIDEO_STATE",
    "type" : "String",
    "comment" : "\n     * Optional extra for {@link #addNewIncomingCall(PhoneAccountHandle, Bundle)} containing an\n     * integer that determines the requested video state for an incoming call.\n     * Valid options:\n     * {@link VideoProfile#STATE_AUDIO_ONLY},\n     * {@link VideoProfile#STATE_BIDIRECTIONAL},\n     * {@link VideoProfile#STATE_RX_ENABLED},\n     * {@link VideoProfile#STATE_TX_ENABLED}.\n     ",
    "links" : [ "android.telecom.VideoProfile#STATE_BIDIRECTIONAL", "android.telecom.VideoProfile#STATE_RX_ENABLED", "#addNewIncomingCall(PhoneAccountHandle", "android.telecom.VideoProfile#STATE_AUDIO_ONLY", "android.telecom.VideoProfile#STATE_TX_ENABLED" ]
  }, {
    "name" : "EXTRA_PHONE_ACCOUNT_HANDLE",
    "type" : "String",
    "comment" : "\n     * The extra used with an {@link android.content.Intent#ACTION_CALL} and\n     * {@link android.content.Intent#ACTION_DIAL} {@code Intent} to specify a\n     * {@link PhoneAccountHandle} to use when making the call.\n     * <p class=\"note\">\n     * Retrieve with {@link android.content.Intent#getParcelableExtra(String)}.\n     ",
    "links" : [ "android.telecom.PhoneAccountHandle", "android.content.Intent#ACTION_DIAL", "android.content.Intent#ACTION_CALL", "android.content.Intent#getParcelableExtra(String)" ]
  }, {
    "name" : "EXTRA_CALL_SUBJECT",
    "type" : "String",
    "comment" : "\n     * Optional extra for {@link android.content.Intent#ACTION_CALL} containing a string call\n     * subject which will be associated with an outgoing call.  Should only be specified if the\n     * {@link PhoneAccount} supports the capability {@link PhoneAccount#CAPABILITY_CALL_SUBJECT}\n     * or {@link PhoneAccount#CAPABILITY_CALL_COMPOSER}.\n     ",
    "links" : [ "android.telecom.PhoneAccount", "android.telecom.PhoneAccount#CAPABILITY_CALL_COMPOSER", "android.content.Intent#ACTION_CALL", "android.telecom.PhoneAccount#CAPABILITY_CALL_SUBJECT" ]
  }, {
    "name" : "PRIORITY_NORMAL",
    "type" : "int",
    "comment" : "\n     * Indicates the call composer call priority is normal.\n     *\n     * Reference: RCC.20 Section 2.4.4.2\n     ",
    "links" : [ ]
  }, {
    "name" : "PRIORITY_URGENT",
    "type" : "int",
    "comment" : "\n     * Indicates the call composer call priority is urgent.\n     *\n     * Reference: RCC.20 Section 2.4.4.2\n     ",
    "links" : [ ]
  }, {
    "name" : "EXTRA_PRIORITY",
    "type" : "String",
    "comment" : "\n     * Extra for the call composer call priority, either {@link #PRIORITY_NORMAL} or\n     * {@link #PRIORITY_URGENT}.\n     *\n     * Reference: RCC.20 Section 2.4.4.2\n     ",
    "links" : [ "#PRIORITY_URGENT", "#PRIORITY_NORMAL" ]
  }, {
    "name" : "EXTRA_LOCATION",
    "type" : "String",
    "comment" : "\n     * Extra for the call composer call location, an {@link android.location.Location} parcelable\n     * class to represent the geolocation as a latitude and longitude pair.\n     *\n     * Reference: RCC.20 Section 2.4.3.2\n     ",
    "links" : [ "android.location.Location" ]
  }, {
    "name" : "EXTRA_HAS_PICTURE",
    "type" : "String",
    "comment" : "\n     * A boolean extra set on incoming calls to indicate that the call has a picture specified.\n     * Given that image download could take a (short) time, the EXTRA is set immediately upon\n     * adding the call to the Dialer app, this allows the Dialer app to reserve space for an image\n     * if one is expected. The EXTRA may be unset if the image download ends up failing for some\n     * reason.\n     ",
    "links" : [ ]
  }, {
    "name" : "EXTRA_PICTURE_URI",
    "type" : "String",
    "comment" : "\n     * A {@link Uri} representing the picture that was downloaded when a call is received or\n     * uploaded when a call is placed.\n     *\n     * This is a content URI within the call log provider which can be used to open a file\n     * descriptor. This could be set a short time after a call is added to the Dialer app if the\n     * download/upload is delayed for some reason. The Dialer app will receive a callback via\n     * {@link Call.Callback#onDetailsChanged} when this value has changed.\n     *\n     * Reference: RCC.20 Section 2.4.3.2\n     ",
    "links" : [ "android.net.Uri", "Call.Callback#onDetailsChanged" ]
  }, {
    "name" : "EXTRA_OUTGOING_PICTURE",
    "type" : "String",
    "comment" : "\n     * A ParcelUuid used as a token to represent a picture that was uploaded prior to the call\n     * being placed. The value of this extra should be set using the {@link android.os.ParcelUuid}\n     * obtained from the callback in {@link TelephonyManager#uploadCallComposerPicture}.\n     ",
    "links" : [ "android.os.ParcelUuid", "android.telephony.TelephonyManager#uploadCallComposerPicture" ]
  }, {
    "name" : "EXTRA_INCOMING_CALL_ADDRESS",
    "type" : "String",
    "comment" : "\n     * The extra used by a {@link ConnectionService} to provide the handle of the caller that\n     * has initiated a new incoming call.\n     ",
    "links" : [ "android.telecom.ConnectionService" ]
  }, {
    "name" : "EXTRA_INCOMING_CALL_EXTRAS",
    "type" : "String",
    "comment" : "\n     * Optional extra for {@link #ACTION_INCOMING_CALL} containing a {@link Bundle} which contains\n     * metadata about the call. This {@link Bundle} will be returned to the\n     * {@link ConnectionService}.\n     ",
    "links" : [ "android.os.Bundle", "#ACTION_INCOMING_CALL", "android.telecom.ConnectionService" ]
  }, {
    "name" : "EXTRA_CALL_HAS_IN_BAND_RINGTONE",
    "type" : "String",
    "comment" : "\n     * Optional extra for {@link #addNewIncomingCall(PhoneAccountHandle, Bundle)} used to indicate\n     * that a call has an in-band ringtone associated with it.  This is used when the device is\n     * acting as an HFP headset and the Bluetooth stack has received an in-band ringtone from the\n     * the HFP host which must be played instead of any local ringtone the device would otherwise\n     * have generated.\n     *\n     * @hide\n     ",
    "links" : [ "#addNewIncomingCall(PhoneAccountHandle" ]
  }, {
    "name" : "EXTRA_OUTGOING_CALL_EXTRAS",
    "type" : "String",
    "comment" : "\n     * Optional extra for {@link android.content.Intent#ACTION_CALL} and\n     * {@link android.content.Intent#ACTION_DIAL} {@code Intent} containing a {@link Bundle}\n     * which contains metadata about the call. This {@link Bundle} will be saved into\n     * {@code Call.Details} and passed to the {@link ConnectionService} when placing the call.\n     ",
    "links" : [ "android.content.Intent#ACTION_DIAL", "android.os.Bundle", "android.content.Intent#ACTION_CALL", "android.telecom.ConnectionService" ]
  }, {
    "name" : "EXTRA_IS_USER_INTENT_EMERGENCY_CALL",
    "type" : "String",
    "comment" : "\n     * An optional boolean extra on {@link android.content.Intent#ACTION_CALL_EMERGENCY} to tell\n     * whether the user's dial intent is emergency; this is required to specify when the dialed\n     * number is ambiguous, identified as both emergency number and any other non-emergency number;\n     * e.g. in some situation, 611 could be both an emergency number in a country and a\n     * non-emergency number of a carrier's customer service hotline.\n     *\n     * @hide\n     ",
    "links" : [ "android.content.Intent#ACTION_CALL_EMERGENCY" ]
  }, {
    "name" : "EXTRA_UNKNOWN_CALL_HANDLE",
    "type" : "String",
    "comment" : "\n     * A mandatory extra containing a {@link Uri} to be passed in when calling\n     * {@link #addNewUnknownCall(PhoneAccountHandle, Bundle)}. The {@link Uri} value indicates\n     * the remote handle of the new call.\n     * @hide\n     ",
    "links" : [ "android.net.Uri", "#addNewUnknownCall(PhoneAccountHandle" ]
  }, {
    "name" : "EXTRA_CALL_CREATED_TIME_MILLIS",
    "type" : "String",
    "comment" : "\n     * Optional extra for incoming and outgoing calls containing a long which specifies the time the\n     * call was created. This value is in milliseconds since boot.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "EXTRA_CALL_LOG_URI",
    "type" : "String",
    "comment" : "\n     * Extra URI that is used by a dialer to query the {@link android.provider.CallLog} content\n     * provider and associate a missed call notification with a call log entry.\n     ",
    "links" : [ "android.provider.CallLog" ]
  }, {
    "name" : "EXTRA_CALL_ANSWERED_TIME_MILLIS",
    "type" : "String",
    "comment" : "\n     * Optional extra for incoming containing a long which specifies the time the\n     * call was answered by user. This value is in milliseconds.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "EXTRA_CALL_CREATED_EPOCH_TIME_MILLIS",
    "type" : "String",
    "comment" : "\n     * Optional extra for incoming and outgoing calls containing a long which specifies the Epoch\n     * time the call was created.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "EXTRA_CALL_TELECOM_ROUTING_START_TIME_MILLIS",
    "type" : "String",
    "comment" : "\n     * Optional extra for incoming and outgoing calls containing a long which specifies the time\n     * telecom began routing the call. This value is in milliseconds since boot.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "EXTRA_CALL_TELECOM_ROUTING_END_TIME_MILLIS",
    "type" : "String",
    "comment" : "\n     * Optional extra for incoming and outgoing calls containing a long which specifies the time\n     * telecom finished routing the call. This value is in milliseconds since boot.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "EXTRA_CALL_DISCONNECT_CAUSE",
    "type" : "String",
    "comment" : "\n     * Optional extra for {@link android.telephony.TelephonyManager#ACTION_PHONE_STATE_CHANGED}\n     * containing the disconnect code.\n     ",
    "links" : [ "android.telephony.TelephonyManager#ACTION_PHONE_STATE_CHANGED" ]
  }, {
    "name" : "EXTRA_CALL_DISCONNECT_MESSAGE",
    "type" : "String",
    "comment" : "\n     * Optional extra for {@link android.telephony.TelephonyManager#ACTION_PHONE_STATE_CHANGED}\n     * containing the disconnect message.\n     ",
    "links" : [ "android.telephony.TelephonyManager#ACTION_PHONE_STATE_CHANGED" ]
  }, {
    "name" : "CALL_AUTO_DISCONNECT_MESSAGE_STRING",
    "type" : "String",
    "comment" : "\n     * A string value for {@link #EXTRA_CALL_DISCONNECT_MESSAGE}, indicates the call was dropped by\n     * lower layers\n     * @hide\n     ",
    "links" : [ "#EXTRA_CALL_DISCONNECT_MESSAGE" ]
  }, {
    "name" : "EXTRA_CONNECTION_SERVICE",
    "type" : "String",
    "comment" : "\n     * Optional extra for {@link android.telephony.TelephonyManager#ACTION_PHONE_STATE_CHANGED}\n     * containing the component name of the associated connection service.\n     * @hide\n     ",
    "links" : [ "android.telephony.TelephonyManager#ACTION_PHONE_STATE_CHANGED" ]
  }, {
    "name" : "EXTRA_CALL_TECHNOLOGY_TYPE",
    "type" : "String",
    "comment" : "\n     * Optional extra for communicating the call technology used by a {@link ConnectionService}\n     * to Telecom. Valid values are:\n     * <ul>\n     *     <li>{@link TelephonyManager#PHONE_TYPE_CDMA}</li>\n     *     <li>{@link TelephonyManager#PHONE_TYPE_GSM}</li>\n     *     <li>{@link TelephonyManager#PHONE_TYPE_IMS}</li>\n     *     <li>{@link TelephonyManager#PHONE_TYPE_THIRD_PARTY}</li>\n     *     <li>{@link TelephonyManager#PHONE_TYPE_SIP}</li>\n     * </ul>\n     * @hide\n     ",
    "links" : [ "android.telephony.TelephonyManager#PHONE_TYPE_CDMA", "android.telephony.TelephonyManager#PHONE_TYPE_SIP", "android.telephony.TelephonyManager#PHONE_TYPE_THIRD_PARTY", "android.telephony.TelephonyManager#PHONE_TYPE_IMS", "android.telecom.ConnectionService", "android.telephony.TelephonyManager#PHONE_TYPE_GSM" ]
  }, {
    "name" : "EXTRA_CALL_NETWORK_TYPE",
    "type" : "String",
    "comment" : "\n     * Optional extra for communicating the call network technology used by a\n     * {@link android.telecom.Connection} to Telecom and InCallUI.\n     *\n     * {@code NETWORK_TYPE_*} in {@link android.telephony.TelephonyManager}.\n     ",
    "links" : [ "android.telephony.TelephonyManager", "android.telecom.Connection" ]
  }, {
    "name" : "GATEWAY_PROVIDER_PACKAGE",
    "type" : "String",
    "comment" : "\n     * An optional {@link android.content.Intent#ACTION_CALL} intent extra denoting the\n     * package name of the app specifying an alternative gateway for the call.\n     * The value is a string.\n     *\n     * (The following comment corresponds to the all GATEWAY_* extras)\n     * An app which sends the {@link android.content.Intent#ACTION_CALL} intent can specify an\n     * alternative address to dial which is different from the one specified and displayed to\n     * the user. This alternative address is referred to as the gateway address.\n     ",
    "links" : [ "android.content.Intent#ACTION_CALL" ]
  }, {
    "name" : "GATEWAY_ORIGINAL_ADDRESS",
    "type" : "String",
    "comment" : "\n     * An optional {@link android.content.Intent#ACTION_CALL} intent extra corresponding to the\n     * original address to dial for the call. This is used when an alternative gateway address is\n     * provided to recall the original address.\n     * The value is a {@link android.net.Uri}.\n     *\n     * (See {@link #GATEWAY_PROVIDER_PACKAGE} for details)\n     ",
    "links" : [ "android.content.Intent#ACTION_CALL", "#GATEWAY_PROVIDER_PACKAGE", "android.net.Uri" ]
  }, {
    "name" : "EXTRA_CALL_BACK_NUMBER",
    "type" : "String",
    "comment" : "\n     * The number which the party on the other side of the line will see (and use to return the\n     * call).\n     * <p>\n     * {@link ConnectionService}s which interact with {@link RemoteConnection}s should only populate\n     * this if the {@link android.telephony.TelephonyManager#getLine1Number()} value, as that is the\n     * user's expected caller ID.\n     ",
    "links" : [ "android.telephony.TelephonyManager#getLine1Number()", "android.telecom.ConnectionService", "android.telecom.RemoteConnection" ]
  }, {
    "name" : "EXTRA_NEW_OUTGOING_CALL_CANCEL_TIMEOUT",
    "type" : "String",
    "comment" : "\n     * The number of milliseconds that Telecom should wait after disconnecting a call via the\n     * ACTION_NEW_OUTGOING_CALL broadcast, in order to wait for the app which cancelled the call\n     * to make a new one.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "EXTRA_IS_HANDOVER",
    "type" : "String",
    "comment" : "\n     * Boolean extra specified to indicate that the intention of adding a call is to handover an\n     * existing call from the user's device to a different {@link PhoneAccount}.\n     * <p>\n     * Used when calling {@link #addNewIncomingCall(PhoneAccountHandle, Bundle)}\n     * to indicate to Telecom that the purpose of adding a new incoming call is to handover an\n     * existing call from the user's device to a different {@link PhoneAccount}.  This occurs on\n     * the receiving side of a handover.\n     * <p>\n     * Used when Telecom calls\n     * {@link ConnectionService#onCreateOutgoingConnection(PhoneAccountHandle, ConnectionRequest)}\n     * to indicate that the purpose of Telecom requesting a new outgoing connection it to request\n     * a handover to this {@link ConnectionService} from an ongoing call on the user's device.  This\n     * occurs on the initiating side of a handover.\n     * <p>\n     * The phone number of the call used by Telecom to determine which call should be handed over.\n     * @hide\n     * @deprecated Use the public handover APIs.  See\n     * {@link Call#handoverTo(PhoneAccountHandle, int, Bundle)} for more information.\n     ",
    "links" : [ "android.telecom.PhoneAccount", "#addNewIncomingCall(PhoneAccountHandle", "android.telecom.ConnectionService#onCreateOutgoingConnection(PhoneAccountHandle", "android.telecom.ConnectionService", "android.telecom.Call#handoverTo(PhoneAccountHandle" ]
  }, {
    "name" : "EXTRA_IS_HANDOVER_CONNECTION",
    "type" : "String",
    "comment" : "\n     * When {@code true} indicates that a request to create a new connection is for the purpose of\n     * a handover.  Note: This is used with the\n     * {@link android.telecom.Call#handoverTo(PhoneAccountHandle, int, Bundle)} API as part of the\n     * internal communication mechanism with the {@link android.telecom.ConnectionService}.  It is\n     * not the same as the legacy {@link #EXTRA_IS_HANDOVER} extra.\n     * @hide\n     ",
    "links" : [ "#EXTRA_IS_HANDOVER", "android.telecom.ConnectionService", "android.telecom.Call#handoverTo(PhoneAccountHandle" ]
  }, {
    "name" : "EXTRA_HANDOVER_FROM_PHONE_ACCOUNT",
    "type" : "String",
    "comment" : "\n     * Parcelable extra used with {@link #EXTRA_IS_HANDOVER} to indicate the source\n     * {@link PhoneAccountHandle} when initiating a handover which {@link ConnectionService}\n     * the handover is from.\n     * @hide\n     ",
    "links" : [ "android.telecom.PhoneAccountHandle", "#EXTRA_IS_HANDOVER", "android.telecom.ConnectionService" ]
  }, {
    "name" : "EXTRA_CALL_AUDIO_STATE",
    "type" : "String",
    "comment" : "\n     * Extra key specified in the {@link ConnectionRequest#getExtras()} when Telecom calls\n     * {@link ConnectionService#onCreateOutgoingConnection(PhoneAccountHandle, ConnectionRequest)}\n     * to inform the {@link ConnectionService} what the initial {@link CallAudioState} of the\n     * {@link Connection} will be.\n     * @hide\n     ",
    "links" : [ "android.telecom.CallAudioState", "android.telecom.ConnectionRequest#getExtras()", "android.telecom.ConnectionService#onCreateOutgoingConnection(PhoneAccountHandle", "android.telecom.Connection", "android.telecom.ConnectionService" ]
  }, {
    "name" : "EXTRA_START_CALL_WITH_RTT",
    "type" : "String",
    "comment" : "\n     * A boolean extra, which when set on the {@link Intent#ACTION_CALL} intent or on the bundle\n     * passed into {@link #placeCall(Uri, Bundle)}, indicates that the call should be initiated with\n     * an RTT session open. See {@link android.telecom.Call.RttCall} for more information on RTT.\n     ",
    "links" : [ "android.content.Intent#ACTION_CALL", "#placeCall(Uri", "android.telecom.Call.RttCall" ]
  }, {
    "name" : "ACTION_POST_CALL",
    "type" : "String",
    "comment" : "\n     * Start an activity indicating that the completion of an outgoing call or an incoming call\n     * which was not blocked by the {@link CallScreeningService}, and which was NOT terminated\n     * while the call was in {@link Call#STATE_AUDIO_PROCESSING}.\n     *\n     * The {@link Uri} extra {@link #EXTRA_HANDLE} will contain the uri handle(phone number) for the\n     * call which completed.\n     *\n     * The integer extra {@link #EXTRA_DISCONNECT_CAUSE} will indicate the reason for the call\n     * disconnection. See {@link #EXTRA_DISCONNECT_CAUSE} for more information.\n     *\n     * The integer extra {@link #EXTRA_CALL_DURATION} will indicate the duration of the call. See\n     * {@link #EXTRA_CALL_DURATION} for more information.\n     ",
    "links" : [ "#EXTRA_CALL_DURATION", "#EXTRA_HANDLE", "android.telecom.Call#STATE_AUDIO_PROCESSING", "android.net.Uri", "#EXTRA_DISCONNECT_CAUSE", "android.telecom.CallScreeningService" ]
  }, {
    "name" : "EXTRA_HANDLE",
    "type" : "String",
    "comment" : "\n     * A {@link Uri} extra, which when set on the {@link #ACTION_POST_CALL} intent, indicates the\n     * uri handle(phone number) of the completed call.\n     ",
    "links" : [ "android.net.Uri", "#ACTION_POST_CALL" ]
  }, {
    "name" : "EXTRA_DISCONNECT_CAUSE",
    "type" : "String",
    "comment" : "\n     * A integer value provided for completed calls to indicate the reason for the call\n     * disconnection.\n     * <p>\n     * Allowed values:\n     * <ul>\n     * <li>{@link DisconnectCause#UNKNOWN}</li>\n     * <li>{@link DisconnectCause#LOCAL}</li>\n     * <li>{@link DisconnectCause#REMOTE}</li>\n     * <li>{@link DisconnectCause#REJECTED}</li>\n     * <li>{@link DisconnectCause#MISSED}</li>\n     * </ul>\n     * </p>\n     ",
    "links" : [ "android.telecom.DisconnectCause#REJECTED", "android.telecom.DisconnectCause#UNKNOWN", "android.telecom.DisconnectCause#REMOTE", "android.telecom.DisconnectCause#MISSED", "android.telecom.DisconnectCause#LOCAL" ]
  }, {
    "name" : "EXTRA_CALL_DURATION",
    "type" : "String",
    "comment" : "\n     * A integer value provided for completed calls to indicate the duration of the call.\n     * <p>\n     * Allowed values:\n     * <ul>\n     * <li>{@link #DURATION_VERY_SHORT}</li>\n     * <li>{@link #DURATION_SHORT}</li>\n     * <li>{@link #DURATION_MEDIUM}</li>\n     * <li>{@link #DURATION_LONG}</li>\n     * </ul>\n     * </p>\n     ",
    "links" : [ "#DURATION_VERY_SHORT", "#DURATION_SHORT", "#DURATION_LONG", "#DURATION_MEDIUM" ]
  }, {
    "name" : "DURATION_VERY_SHORT",
    "type" : "int",
    "comment" : "\n     * A integer value for {@link #EXTRA_CALL_DURATION}, indicates the duration of the completed\n     * call was < 3 seconds.\n     ",
    "links" : [ "#EXTRA_CALL_DURATION" ]
  }, {
    "name" : "DURATION_SHORT",
    "type" : "int",
    "comment" : "\n     * A integer value for {@link #EXTRA_CALL_DURATION}, indicates the duration of the completed\n     * call was >= 3 seconds and < 60 seconds.\n     ",
    "links" : [ "#EXTRA_CALL_DURATION" ]
  }, {
    "name" : "DURATION_MEDIUM",
    "type" : "int",
    "comment" : "\n     * A integer value for {@link #EXTRA_CALL_DURATION}, indicates the duration of the completed\n     * call was >= 60 seconds and < 120 seconds.\n     ",
    "links" : [ "#EXTRA_CALL_DURATION" ]
  }, {
    "name" : "DURATION_LONG",
    "type" : "int",
    "comment" : "\n     * A integer value for {@link #EXTRA_CALL_DURATION}, indicates the duration of the completed\n     * call was >= 120 seconds.\n     ",
    "links" : [ "#EXTRA_CALL_DURATION" ]
  }, {
    "name" : "VERY_SHORT_CALL_TIME_MS",
    "type" : "long",
    "comment" : "\n     * The threshold between {@link #DURATION_VERY_SHORT} calls and {@link #DURATION_SHORT} calls in\n     * milliseconds.\n     * @hide\n     ",
    "links" : [ "#DURATION_VERY_SHORT", "#DURATION_SHORT" ]
  }, {
    "name" : "SHORT_CALL_TIME_MS",
    "type" : "long",
    "comment" : "\n     * The threshold between {@link #DURATION_SHORT} calls and {@link #DURATION_MEDIUM} calls in\n     * milliseconds.\n     * @hide\n     ",
    "links" : [ "#DURATION_SHORT", "#DURATION_MEDIUM" ]
  }, {
    "name" : "MEDIUM_CALL_TIME_MS",
    "type" : "long",
    "comment" : "\n     * The threshold between {@link #DURATION_MEDIUM} calls and {@link #DURATION_LONG} calls in\n     * milliseconds.\n     * @hide\n     ",
    "links" : [ "#DURATION_LONG", "#DURATION_MEDIUM" ]
  }, {
    "name" : "METADATA_IN_CALL_SERVICE_UI",
    "type" : "String",
    "comment" : "\n     * A boolean meta-data value indicating whether an {@link InCallService} implements an\n     * in-call user interface. Dialer implementations (see {@link #getDefaultDialerPackage()}) which\n     * would also like to replace the in-call interface should set this meta-data to {@code true} in\n     * the manifest registration of their {@link InCallService}.\n     ",
    "links" : [ "android.telecom.InCallService", "#getDefaultDialerPackage()" ]
  }, {
    "name" : "METADATA_IN_CALL_SERVICE_CAR_MODE_UI",
    "type" : "String",
    "comment" : "\n     * A boolean meta-data value indicating whether an {@link InCallService} implements an\n     * in-call user interface to be used while the device is in car-mode (see\n     * {@link android.content.res.Configuration#UI_MODE_TYPE_CAR}).\n     ",
    "links" : [ "android.telecom.InCallService", "android.content.res.Configuration#UI_MODE_TYPE_CAR" ]
  }, {
    "name" : "METADATA_IN_CALL_SERVICE_RINGING",
    "type" : "String",
    "comment" : "\n     * A boolean meta-data value indicating whether an {@link InCallService} implements ringing.\n     * Dialer implementations (see {@link #getDefaultDialerPackage()}) which would also like to\n     * override the system provided ringing should set this meta-data to {@code true} in the\n     * manifest registration of their {@link InCallService}.\n     * <p>\n     * When {@code true}, it is the {@link InCallService}'s responsibility to play a ringtone for\n     * all incoming calls.\n     ",
    "links" : [ "android.telecom.InCallService", "#getDefaultDialerPackage()" ]
  }, {
    "name" : "METADATA_INCLUDE_EXTERNAL_CALLS",
    "type" : "String",
    "comment" : "\n     * A boolean meta-data value indicating whether an {@link InCallService} wants to be informed of\n     * calls which have the {@link Call.Details#PROPERTY_IS_EXTERNAL_CALL} property.  An external\n     * call is one which a {@link ConnectionService} knows about, but is not connected to directly.\n     * Dialer implementations (see {@link #getDefaultDialerPackage()}) which would like to be\n     * informed of external calls should set this meta-data to {@code true} in the manifest\n     * registration of their {@link InCallService}.  By default, the {@link InCallService} will NOT\n     * be informed of external calls.\n     ",
    "links" : [ "android.telecom.InCallService", "Call.Details#PROPERTY_IS_EXTERNAL_CALL", "#getDefaultDialerPackage()", "android.telecom.ConnectionService" ]
  }, {
    "name" : "METADATA_INCLUDE_SELF_MANAGED_CALLS",
    "type" : "String",
    "comment" : "\n     * A boolean meta-data value indicating whether an {@link InCallService} wants to be informed of\n     * calls which have the {@link Call.Details#PROPERTY_SELF_MANAGED} property.  A self-managed\n     * call is one which originates from a self-managed {@link ConnectionService} which has chosen\n     * to implement its own call user interface.  An {@link InCallService} implementation which\n     * would like to be informed of external calls should set this meta-data to {@code true} in the\n     * manifest registration of their {@link InCallService}.  By default, the {@link InCallService}\n     * will NOT be informed about self-managed calls.\n     * <p>\n     * An {@link InCallService} which receives self-managed calls is free to view and control the\n     * state of calls in the self-managed {@link ConnectionService}.  An example use-case is\n     * exposing these calls to an automotive device via its companion app.\n     * <p>\n     * See also {@link Connection#PROPERTY_SELF_MANAGED}.\n     ",
    "links" : [ "android.telecom.InCallService", "android.telecom.Connection#PROPERTY_SELF_MANAGED", "Call.Details#PROPERTY_SELF_MANAGED", "android.telecom.ConnectionService" ]
  }, {
    "name" : "DTMF_CHARACTER_PAUSE",
    "type" : "char",
    "comment" : "\n     * The dual tone multi-frequency signaling character sent to indicate the dialing system should\n     * pause for a predefined period.\n     ",
    "links" : [ ]
  }, {
    "name" : "DTMF_CHARACTER_WAIT",
    "type" : "char",
    "comment" : "\n     * The dual-tone multi-frequency signaling character sent to indicate the dialing system should\n     * wait for user confirmation before proceeding.\n     ",
    "links" : [ ]
  }, {
    "name" : "TTY_MODE_OFF",
    "type" : "int",
    "comment" : "\n     * TTY (teletypewriter) mode is off.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "TTY_MODE_FULL",
    "type" : "int",
    "comment" : "\n     * TTY (teletypewriter) mode is on. The speaker is off and the microphone is muted. The user\n     * will communicate with the remote party by sending and receiving text messages.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "TTY_MODE_HCO",
    "type" : "int",
    "comment" : "\n     * TTY (teletypewriter) mode is in hearing carryover mode (HCO). The microphone is muted but the\n     * speaker is on. The user will communicate with the remote party by sending text messages and\n     * hearing an audible reply.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "TTY_MODE_VCO",
    "type" : "int",
    "comment" : "\n     * TTY (teletypewriter) mode is in voice carryover mode (VCO). The speaker is off but the\n     * microphone is still on. User will communicate with the remote party by speaking and receiving\n     * text message replies.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "ACTION_CURRENT_TTY_MODE_CHANGED",
    "type" : "String",
    "comment" : "\n     * Broadcast intent action indicating that the current TTY mode has changed.\n     *\n     * This intent will contain {@link #EXTRA_CURRENT_TTY_MODE} as an intent extra, giving the new\n     * TTY mode.\n     * @hide\n     ",
    "links" : [ "#EXTRA_CURRENT_TTY_MODE" ]
  }, {
    "name" : "EXTRA_CURRENT_TTY_MODE",
    "type" : "String",
    "comment" : "\n     * Integer extra key that indicates the current TTY mode.\n     *\n     * Used with {@link #ACTION_CURRENT_TTY_MODE_CHANGED}.\n     *\n     * Valid modes are:\n     * <ul>\n     *     <li>{@link #TTY_MODE_OFF}</li>\n     *     <li>{@link #TTY_MODE_FULL}</li>\n     *     <li>{@link #TTY_MODE_HCO}</li>\n     *     <li>{@link #TTY_MODE_VCO}</li>\n     * </ul>\n     *\n     * This TTY mode is distinct from the one sent via {@link #ACTION_TTY_PREFERRED_MODE_CHANGED},\n     * since the current TTY mode will always be {@link #TTY_MODE_OFF}unless a TTY terminal is\n     * plugged into the device.\n     * @hide\n     ",
    "links" : [ "#TTY_MODE_FULL", "#ACTION_TTY_PREFERRED_MODE_CHANGED", "#TTY_MODE_HCO", "#TTY_MODE_OFF", "#TTY_MODE_VCO", "#ACTION_CURRENT_TTY_MODE_CHANGED" ]
  }, {
    "name" : "ACTION_TTY_PREFERRED_MODE_CHANGED",
    "type" : "String",
    "comment" : "\n     * Broadcast intent action indicating that the TTY preferred operating mode has changed.\n     *\n     * This intent will contain {@link #EXTRA_TTY_PREFERRED_MODE} as an intent extra, giving the new\n     * preferred TTY mode.\n     * @hide\n     ",
    "links" : [ "#EXTRA_TTY_PREFERRED_MODE" ]
  }, {
    "name" : "EXTRA_TTY_PREFERRED_MODE",
    "type" : "String",
    "comment" : "\n     * Integer extra key that indicates the preferred TTY mode.\n     *\n     * Used with {@link #ACTION_TTY_PREFERRED_MODE_CHANGED}.\n     *\n     * Valid modes are:\n     * <ul>\n     *     <li>{@link #TTY_MODE_OFF}</li>\n     *     <li>{@link #TTY_MODE_FULL}</li>\n     *     <li>{@link #TTY_MODE_HCO}</li>\n     *     <li>{@link #TTY_MODE_VCO}</li>\n     * </ul>\n     * @hide\n     ",
    "links" : [ "#TTY_MODE_FULL", "#ACTION_TTY_PREFERRED_MODE_CHANGED", "#TTY_MODE_HCO", "#TTY_MODE_OFF", "#TTY_MODE_VCO" ]
  }, {
    "name" : "ACTION_SHOW_MISSED_CALLS_NOTIFICATION",
    "type" : "String",
    "comment" : "\n     * Broadcast intent action for letting custom component know to show the missed call\n     * notification. If no custom component exists then this is sent to the default dialer which\n     * should post a missed-call notification.\n     ",
    "links" : [ ]
  }, {
    "name" : "EXTRA_NOTIFICATION_COUNT",
    "type" : "String",
    "comment" : "\n     * The number of calls associated with the notification. If the number is zero then the missed\n     * call notification should be dismissed.\n     ",
    "links" : [ ]
  }, {
    "name" : "EXTRA_NOTIFICATION_PHONE_NUMBER",
    "type" : "String",
    "comment" : "\n     * The number associated with the missed calls. This number is only relevant\n     * when EXTRA_NOTIFICATION_COUNT is 1.\n     ",
    "links" : [ ]
  }, {
    "name" : "EXTRA_CLEAR_MISSED_CALLS_INTENT",
    "type" : "String",
    "comment" : "\n     * Included in the extras of the {@link #ACTION_SHOW_MISSED_CALLS_NOTIFICATION}, provides a\n     * pending intent which can be used to clear the missed calls notification and mark unread\n     * missed call log entries as read.\n     * @hide\n     * @deprecated Use {@link #cancelMissedCallsNotification()} instead.\n     ",
    "links" : [ "#ACTION_SHOW_MISSED_CALLS_NOTIFICATION", "#cancelMissedCallsNotification()" ]
  }, {
    "name" : "EXTRA_CALL_BACK_INTENT",
    "type" : "String",
    "comment" : "\n     * The intent to call back a missed call.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "EMERGENCY_DIALER_COMPONENT",
    "type" : "ComponentName",
    "comment" : "\n     * The dialer activity responsible for placing emergency calls from, for example, a locked\n     * keyguard.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "EXTRA_USE_ASSISTED_DIALING",
    "type" : "String",
    "comment" : "\n     * The boolean indicated by this extra controls whether or not a call is eligible to undergo\n     * assisted dialing. This extra is stored under {@link #EXTRA_OUTGOING_CALL_EXTRAS}.\n     * <p>\n     * The call initiator can use this extra to indicate that a call used assisted dialing to help\n     * place the call.  This is most commonly used by a Dialer app which provides the ability to\n     * automatically add dialing prefixes when placing international calls.\n     * <p>\n     * Setting this extra on the outgoing call extras will cause the\n     * {@link Connection#PROPERTY_ASSISTED_DIALING} property and\n     * {@link Call.Details#PROPERTY_ASSISTED_DIALING} property to be set on the\n     * {@link Connection}/{@link Call} in question.  When the call is logged to the call log, the\n     * {@link android.provider.CallLog.Calls#FEATURES_ASSISTED_DIALING_USED} call feature is set to\n     * indicate that assisted dialing was used for the call.\n     ",
    "links" : [ "#EXTRA_OUTGOING_CALL_EXTRAS", "Call.Details#PROPERTY_ASSISTED_DIALING", "android.provider.CallLog.Calls#FEATURES_ASSISTED_DIALING_USED", "android.telecom.Connection#PROPERTY_ASSISTED_DIALING", "android.telecom.Connection", "android.telecom.Call" ]
  }, {
    "name" : "EXTRA_CALL_SOURCE",
    "type" : "String",
    "comment" : "\n     * Optional extra for {@link #placeCall(Uri, Bundle)} containing an integer that specifies\n     * the source where user initiated this call. This data is used in metrics.\n     * Valid sources are:\n     * {@link TelecomManager#CALL_SOURCE_UNSPECIFIED},\n     * {@link TelecomManager#CALL_SOURCE_EMERGENCY_DIALPAD},\n     * {@link TelecomManager#CALL_SOURCE_EMERGENCY_SHORTCUT}.\n     *\n     * Intended for use with the platform emergency dialer only.\n     * @hide\n     ",
    "links" : [ "android.telecom.TelecomManager#CALL_SOURCE_UNSPECIFIED", "android.telecom.TelecomManager#CALL_SOURCE_EMERGENCY_DIALPAD", "#placeCall(Uri", "android.telecom.TelecomManager#CALL_SOURCE_EMERGENCY_SHORTCUT" ]
  }, {
    "name" : "ACTION_SHOW_SWITCH_TO_WORK_PROFILE_FOR_CALL_DIALOG",
    "type" : "String",
    "comment" : "\n     * Intent action to trigger \"switch to managed profile\" dialog for call in SystemUI\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "EXTRA_MANAGED_PROFILE_USER_ID",
    "type" : "String",
    "comment" : "\n     * Extra specifying the managed profile user id.\n     * This is used with {@link TelecomManager#ACTION_SHOW_SWITCH_TO_WORK_PROFILE_FOR_CALL_DIALOG}\n     *\n     * @hide\n     ",
    "links" : [ "android.telecom.TelecomManager#ACTION_SHOW_SWITCH_TO_WORK_PROFILE_FOR_CALL_DIALOG" ]
  }, {
    "name" : "CALL_SOURCE_EMERGENCY_SHORTCUT",
    "type" : "int",
    "comment" : "\n     * Indicating the call is initiated via emergency dialer's shortcut button.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "CALL_SOURCE_EMERGENCY_DIALPAD",
    "type" : "int",
    "comment" : "\n     * Indicating the call is initiated via emergency dialer's dialpad.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "CALL_SOURCE_UNSPECIFIED",
    "type" : "int",
    "comment" : "\n     * Indicating the call source is not specified.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "PRESENTATION_ALLOWED",
    "type" : "int",
    "comment" : "\n     * Indicates that the address or number of a call is allowed to be displayed for caller ID.\n     ",
    "links" : [ ]
  }, {
    "name" : "PRESENTATION_RESTRICTED",
    "type" : "int",
    "comment" : "\n     * Indicates that the address or number of a call is blocked by the other party.\n     ",
    "links" : [ ]
  }, {
    "name" : "PRESENTATION_UNKNOWN",
    "type" : "int",
    "comment" : "\n     * Indicates that the address or number of a call is not specified or known by the carrier.\n     ",
    "links" : [ ]
  }, {
    "name" : "PRESENTATION_PAYPHONE",
    "type" : "int",
    "comment" : "\n     * Indicates that the address or number of a call belongs to a pay phone.\n     ",
    "links" : [ ]
  }, {
    "name" : "PRESENTATION_UNAVAILABLE",
    "type" : "int",
    "comment" : "\n     * Indicates that the address or number of a call is unavailable.\n     ",
    "links" : [ ]
  }, {
    "name" : "PROPERTY_VIDEOCALL_AUDIO_OUTPUT",
    "type" : "String",
    "comment" : "\n     * Controls audio route for video calls.\n     * 0 - Use the default audio routing strategy.\n     * 1 - Disable the speaker. Route the audio to Headset or Bluetooth\n     *     or Earpiece, based on the default audio routing strategy.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "AUDIO_OUTPUT_ENABLE_SPEAKER",
    "type" : "int",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "AUDIO_OUTPUT_DISABLE_SPEAKER",
    "type" : "int",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "AUDIO_OUTPUT_DEFAULT",
    "type" : "int",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "ENABLE_GET_CALL_STATE_PERMISSION_PROTECTION",
    "type" : "long",
    "comment" : "\n     * Enable READ_PHONE_STATE protection on APIs querying and notifying call state, such as\n     * {@code TelecomManager#getCallState}, {@link TelephonyManager#getCallStateForSubscription()},\n     * and {@link android.telephony.TelephonyCallback.CallStateListener}.\n     * @hide\n     ",
    "links" : [ "android.telephony.TelephonyManager#getCallStateForSubscription()", "android.telephony.TelephonyCallback.CallStateListener" ]
  }, {
    "name" : "ENABLE_GET_PHONE_ACCOUNT_PERMISSION_PROTECTION",
    "type" : "long",
    "comment" : "\n     * Enable READ_PHONE_NUMBERS or READ_PRIVILEGED_PHONE_STATE protections on\n     * {@link TelecomManager#getPhoneAccount(PhoneAccountHandle)}.\n     * @hide\n     ",
    "links" : [ "android.telecom.TelecomManager#getPhoneAccount(PhoneAccountHandle)" ]
  }, {
    "name" : "TAG",
    "type" : "String",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "CACHE_LOCK",
    "type" : "Object",
    "comment" : " Cached service handles, cleared by resetServiceCache() at death ",
    "links" : [ ]
  }, {
    "name" : "sTelecomService",
    "type" : "ITelecomService",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "SERVICE_DEATH",
    "type" : "DeathRecipient",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mContext",
    "type" : "Context",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mTelecomServiceOverride",
    "type" : "ITelecomService",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mTransactionalServiceRepository",
    "type" : "ClientTransactionalServiceRepository",
    "comment" : " @hide *",
    "links" : [ ]
  }, {
    "name" : "TELECOM_TRANSACTION_SUCCESS",
    "type" : "int",
    "comment" : " @hide *",
    "links" : [ ]
  }, {
    "name" : "TRANSACTION_CALL_ID_KEY",
    "type" : "String",
    "comment" : " @hide *",
    "links" : [ ]
  } ],
  "methods" : [ {
    "name" : "public static TelecomManager from(Context context)",
    "returnType" : "TelecomManager",
    "comment" : "\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public PhoneAccountHandle getDefaultOutgoingPhoneAccount(String uriScheme)",
    "returnType" : "PhoneAccountHandle",
    "comment" : "\n     * Return the {@link PhoneAccount} which will be used to place outgoing calls to addresses with\n     * the specified {@code uriScheme}. This {@link PhoneAccount} will always be a member of the\n     * list which is returned from invoking {@link #getCallCapablePhoneAccounts()}. The specific\n     * account returned depends on the following priorities:\n     * <ul>\n     * <li> If the user-selected default {@link PhoneAccount} supports the specified scheme, it will\n     * be returned.\n     * </li>\n     * <li> If there exists only one {@link PhoneAccount} that supports the specified scheme, it\n     * will be returned.\n     * </li>\n     * </ul>\n     * <p>\n     * If no {@link PhoneAccount} fits the criteria above, this method will return {@code null}.\n     *\n     * @param uriScheme The URI scheme.\n     * @return The {@link PhoneAccountHandle} corresponding to the account to be used.\n     ",
    "links" : [ "android.telecom.PhoneAccountHandle", "android.telecom.PhoneAccount", "#getCallCapablePhoneAccounts()" ]
  }, {
    "name" : "public PhoneAccountHandle getUserSelectedOutgoingPhoneAccount()",
    "returnType" : "PhoneAccountHandle",
    "comment" : "\n     * Return the {@link PhoneAccount} which is the user-chosen default for making outgoing phone\n     * calls. This {@code PhoneAccount} will always be a member of the list which is returned from\n     * calling {@link #getCallCapablePhoneAccounts()}\n     * <p>\n     * Apps must be prepared for this method to return {@code null}, indicating that there currently\n     * exists no user-chosen default {@code PhoneAccount}.\n     * <p>\n     * The default dialer has access to use this method.\n     *\n     * @return The user outgoing phone account selected by the user, or {@code null} if there is no\n     * user selected outgoing {@link PhoneAccountHandle}.\n     ",
    "links" : [ "android.telecom.PhoneAccountHandle", "android.telecom.PhoneAccount", "#getCallCapablePhoneAccounts()" ]
  }, {
    "name" : "public void setUserSelectedOutgoingPhoneAccount(@Nullable PhoneAccountHandle accountHandle)",
    "returnType" : "void",
    "comment" : "\n     * Sets the user-chosen default {@link PhoneAccountHandle} for making outgoing phone calls.\n     *\n     * @param accountHandle The {@link PhoneAccountHandle} which will be used by default for making\n     *                      outgoing voice calls, or {@code null} if no default is specified (the\n     *                      user will be asked each time a call is placed in this case).\n     * @hide\n     ",
    "links" : [ "android.telecom.PhoneAccountHandle" ]
  }, {
    "name" : "public PhoneAccountHandle getSimCallManager()",
    "returnType" : "PhoneAccountHandle",
    "comment" : "\n     * Returns the current SIM call manager. Apps must be prepared for this method to return\n     * {@code null}, indicating that there currently exists no SIM call manager {@link PhoneAccount}\n     * for the default voice subscription.\n     *\n     * @return The phone account handle of the current sim call manager for the default voice\n     * subscription.\n     * @see SubscriptionManager#getDefaultVoiceSubscriptionId()\n     ",
    "links" : [ "android.telecom.PhoneAccount" ]
  }, {
    "name" : "public PhoneAccountHandle getSimCallManagerForSubscription(int subscriptionId)",
    "returnType" : "PhoneAccountHandle",
    "comment" : "\n     * Returns current SIM call manager for the Telephony Subscription ID specified. Apps must be\n     * prepared for this method to return {@code null}, indicating that there currently exists no\n     * SIM call manager {@link PhoneAccount} for the subscription specified.\n     *\n     * @param subscriptionId The Telephony Subscription ID that the SIM call manager should be\n     *                       queried for.\n     * @return The phone account handle of the current sim call manager.\n     * @see SubscriptionManager#getActiveSubscriptionInfoList()\n     ",
    "links" : [ "android.telecom.PhoneAccount" ]
  }, {
    "name" : "public PhoneAccountHandle getSimCallManager(int userId)",
    "returnType" : "PhoneAccountHandle",
    "comment" : "\n     * Returns the current SIM call manager for the user-chosen default Telephony Subscription ID\n     * (see {@link SubscriptionManager#getDefaultSubscriptionId()}) and the specified user. Apps\n     * must be prepared for this method to return {@code null}, indicating that there currently\n     * exists no SIM call manager {@link PhoneAccount} for the default voice subscription.\n     *\n     * @return The phone account handle of the current sim call manager.\n     *\n     * @hide\n     * @deprecated Use {@link #getSimCallManager()}.\n     ",
    "links" : [ "android.telephony.SubscriptionManager#getDefaultSubscriptionId()", "android.telecom.PhoneAccount", "#getSimCallManager()" ]
  }, {
    "name" : "public PhoneAccountHandle getConnectionManager()",
    "returnType" : "PhoneAccountHandle",
    "comment" : "\n     * Returns the current connection manager. Apps must be prepared for this method to return\n     * {@code null}, indicating that there currently exists no Connection Manager\n     * {@link PhoneAccount} for the default voice subscription.\n     *\n     * @return The phone account handle of the current connection manager.\n     * @hide\n     ",
    "links" : [ "android.telecom.PhoneAccount" ]
  }, {
    "name" : "public List<PhoneAccountHandle> getPhoneAccountsSupportingScheme(String uriScheme)",
    "returnType" : "List<PhoneAccountHandle>",
    "comment" : "\n     * Returns a list of the {@link PhoneAccountHandle}s which can be used to make and receive phone\n     * calls which support the specified URI scheme.\n     * <P>\n     * For example, invoking with {@code \"tel\"} will find all {@link PhoneAccountHandle}s which\n     * support telephone calls (e.g. URIs such as {@code tel:555-555-1212}).  Invoking with\n     * {@code \"sip\"} will find all {@link PhoneAccountHandle}s which support SIP calls (e.g. URIs\n     * such as {@code sip:example@sipexample.com}).\n     *\n     * @param uriScheme The URI scheme.\n     * @return A list of {@code PhoneAccountHandle} objects supporting the URI scheme.\n     * @hide\n     ",
    "links" : [ "android.telecom.PhoneAccountHandle" ]
  }, {
    "name" : "public List<PhoneAccountHandle> getCallCapablePhoneAccounts()",
    "returnType" : "List<PhoneAccountHandle>",
    "comment" : "\n     * Returns a list of {@link PhoneAccountHandle}s which can be used to make and receive phone\n     * calls. The returned list includes only those accounts which have been explicitly enabled\n     * by the user.\n     *\n     * @see #EXTRA_PHONE_ACCOUNT_HANDLE\n     * @return A list of {@code PhoneAccountHandle} objects.\n     ",
    "links" : [ "android.telecom.PhoneAccountHandle" ]
  }, {
    "name" : "public List<PhoneAccountHandle> getCallCapablePhoneAccountsAcrossProfiles()",
    "returnType" : "List<PhoneAccountHandle>",
    "comment" : "\n     * Returns a list of {@link PhoneAccountHandle}s which can be used to make and receive phone\n     * calls. The returned list includes those accounts which have been explicitly enabled.\n     * In contrast to {@link #getCallCapablePhoneAccounts}, this also includes accounts from\n     * the calling user's {@link android.os.UserManager#getUserProfiles} profile group.\n     *\n     * @see #EXTRA_PHONE_ACCOUNT_HANDLE\n     * @return A list of {@code PhoneAccountHandle} objects.\n     *\n     * @throws IllegalStateException if telecom service is null.\n     ",
    "links" : [ "android.telecom.PhoneAccountHandle", "#getCallCapablePhoneAccounts", "android.os.UserManager#getUserProfiles" ]
  }, {
    "name" : "public List<PhoneAccountHandle> getSelfManagedPhoneAccounts()",
    "returnType" : "List<PhoneAccountHandle>",
    "comment" : "\n     * Returns a list of {@link PhoneAccountHandle}s for all self-managed\n     * {@link ConnectionService}s owned by the calling {@link UserHandle}.\n     * <p>\n     * Self-Managed {@link ConnectionService}s have a {@link PhoneAccount} with\n     * {@link PhoneAccount#CAPABILITY_SELF_MANAGED}.\n     * <p>\n     * Requires permission {@link android.Manifest.permission#READ_PHONE_STATE}, or that the caller\n     * is the default dialer app.\n     * <p>\n     * A {@link SecurityException} will be thrown if a called is not the default dialer, or lacks\n     * the {@link android.Manifest.permission#READ_PHONE_STATE} permission.\n     *\n     * @return A list of {@code PhoneAccountHandle} objects.\n     ",
    "links" : [ "android.telecom.PhoneAccountHandle", "android.telecom.PhoneAccount", "android.os.UserHandle", "SecurityException", "android.telecom.PhoneAccount#CAPABILITY_SELF_MANAGED", "android.Manifest.permission#READ_PHONE_STATE", "android.telecom.ConnectionService" ]
  }, {
    "name" : "public List<PhoneAccountHandle> getOwnSelfManagedPhoneAccounts()",
    "returnType" : "List<PhoneAccountHandle>",
    "comment" : "\n     * Returns a list of {@link PhoneAccountHandle}s owned by the calling self-managed\n     * {@link ConnectionService}.\n     * <p>\n     * Self-Managed {@link ConnectionService}s have a {@link PhoneAccount} with\n     * {@link PhoneAccount#CAPABILITY_SELF_MANAGED}.\n     * <p>\n     * Requires permission {@link android.Manifest.permission#MANAGE_OWN_CALLS}\n     * <p>\n     * A {@link SecurityException} will be thrown if a caller lacks the\n     * {@link android.Manifest.permission#MANAGE_OWN_CALLS} permission.\n     *\n     * @return A list of {@code PhoneAccountHandle} objects.\n     ",
    "links" : [ "android.telecom.PhoneAccountHandle", "android.telecom.PhoneAccount", "android.Manifest.permission#MANAGE_OWN_CALLS", "SecurityException", "android.telecom.PhoneAccount#CAPABILITY_SELF_MANAGED", "android.telecom.ConnectionService" ]
  }, {
    "name" : "public List<PhoneAccount> getRegisteredPhoneAccounts()",
    "returnType" : "List<PhoneAccount>",
    "comment" : "\n     * This API will return all {@link PhoneAccount}s the caller registered via\n     * {@link TelecomManager#registerPhoneAccount(PhoneAccount)}.  If a {@link PhoneAccount} appears\n     * to be missing from the list, Telecom has either unregistered the {@link PhoneAccount} (for\n     * cleanup purposes) or the caller registered the {@link PhoneAccount} under a different user\n     * and does not have the  {@link android.Manifest.permission#INTERACT_ACROSS_USERS} permission.\n     * <b>Note:</b> This API will only return {@link PhoneAccount}s registered by the same app.  For\n     * system Dialers that need all the {@link PhoneAccount}s registered by every application, see\n     * {@link TelecomManager#getAllPhoneAccounts()}.\n     *\n     * @return all the {@link PhoneAccount}s registered by the caller.\n     ",
    "links" : [ "android.telecom.TelecomManager#getAllPhoneAccounts()", "android.telecom.TelecomManager#registerPhoneAccount(PhoneAccount)", "android.telecom.PhoneAccount", "android.Manifest.permission#INTERACT_ACROSS_USERS" ]
  }, {
    "name" : "public List<PhoneAccountHandle> getCallCapablePhoneAccounts(boolean includeDisabledAccounts)",
    "returnType" : "List<PhoneAccountHandle>",
    "comment" : "\n     * Returns a list of {@link PhoneAccountHandle}s including those which have not been enabled\n     * by the user.\n     *\n     * @param includeDisabledAccounts When {@code true}, disabled phone accounts will be included,\n     *                                when {@code false}, only enabled phone accounts will be\n     *                                included.\n     * @return A list of {@code PhoneAccountHandle} objects.\n     * @hide\n     ",
    "links" : [ "android.telecom.PhoneAccountHandle" ]
  }, {
    "name" : "public List<PhoneAccountHandle> getCallCapablePhoneAccountsAcrossProfiles(boolean includeDisabledAccounts)",
    "returnType" : "List<PhoneAccountHandle>",
    "comment" : "\n     * Returns a list of {@link PhoneAccountHandle}s visible to current user including those which\n     * have not been enabled by the user.\n     *\n     * @param includeDisabledAccounts When {@code true}, disabled phone accounts will be included,\n     *                                when {@code false}, only enabled phone accounts will be\n     *                                included.\n     * @return A list of {@code PhoneAccountHandle} objects.\n     *\n     * @throws IllegalStateException if telecom service is null.\n     * @hide\n     ",
    "links" : [ "android.telecom.PhoneAccountHandle" ]
  }, {
    "name" : "public List<PhoneAccountHandle> getPhoneAccountsForPackage()",
    "returnType" : "List<PhoneAccountHandle>",
    "comment" : "\n     *  Returns a list of all {@link PhoneAccount}s registered for the calling package.\n     *\n     * @deprecated Use {@link #getSelfManagedPhoneAccounts()} instead to get only self-managed\n     * {@link PhoneAccountHandle} for the calling package.\n     * @return A list of {@code PhoneAccountHandle} objects.\n     * @hide\n     ",
    "links" : [ "android.telecom.PhoneAccountHandle", "#getSelfManagedPhoneAccounts()", "android.telecom.PhoneAccount" ]
  }, {
    "name" : "public PhoneAccount getPhoneAccount(PhoneAccountHandle account)",
    "returnType" : "PhoneAccount",
    "comment" : "\n     * Return the {@link PhoneAccount} for a specified {@link PhoneAccountHandle}. Object includes\n     * resources which can be used in a user interface.\n     *\n     * Requires Permission:\n     * {@link android.Manifest.permission#READ_PHONE_NUMBERS} for applications targeting API\n     * level 31+.\n     * @param account The {@link PhoneAccountHandle}.\n     * @return The {@link PhoneAccount} object.\n     ",
    "links" : [ "android.telecom.PhoneAccountHandle", "android.telecom.PhoneAccount", "android.Manifest.permission#READ_PHONE_NUMBERS" ]
  }, {
    "name" : "public int getAllPhoneAccountsCount()",
    "returnType" : "int",
    "comment" : "\n     * Returns a count of all {@link PhoneAccount}s.\n     *\n     * @return The count of {@link PhoneAccount}s.\n     * @hide\n     ",
    "links" : [ "android.telecom.PhoneAccount" ]
  }, {
    "name" : "public List<PhoneAccount> getAllPhoneAccounts()",
    "returnType" : "List<PhoneAccount>",
    "comment" : "\n     * Returns a list of all {@link PhoneAccount}s.\n     *\n     * @return All {@link PhoneAccount}s.\n     * @hide\n     ",
    "links" : [ "android.telecom.PhoneAccount" ]
  }, {
    "name" : "public List<PhoneAccountHandle> getAllPhoneAccountHandles()",
    "returnType" : "List<PhoneAccountHandle>",
    "comment" : "\n     * Returns a list of all {@link PhoneAccountHandle}s.\n     *\n     * @return All {@link PhoneAccountHandle}s.\n     * @hide\n     ",
    "links" : [ "android.telecom.PhoneAccountHandle" ]
  }, {
    "name" : "public void registerPhoneAccount(PhoneAccount account)",
    "returnType" : "void",
    "comment" : "\n     * Register a {@link PhoneAccount} for use by the system that will be stored in Device Encrypted\n     * storage. When registering {@link PhoneAccount}s, existing registrations will be overwritten\n     * if the {@link PhoneAccountHandle} matches that of a {@link PhoneAccount} which is already\n     * registered. Once registered, the {@link PhoneAccount} is listed to the user as an option\n     * when placing calls. The user may still need to enable the {@link PhoneAccount} within\n     * the phone app settings before the account is usable.\n     * <p>\n     * Note: Each package is limited to 10 {@link PhoneAccount} registrations.\n     * <p>\n     * A {@link SecurityException} will be thrown if an app tries to register a\n     * {@link PhoneAccountHandle} where the package name specified within\n     * {@link PhoneAccountHandle#getComponentName()} does not match the package name of the app.\n     * <p>\n     * A {@link IllegalArgumentException} will be thrown if an app tries to register a\n     * {@link PhoneAccount} when the upper bound limit, 10, has already been reached.\n     *\n     * @param account The complete {@link PhoneAccount}.\n     * @throws UnsupportedOperationException if the caller cannot modify phone state and the device\n     * does not have the Telecom feature.\n     * @throws SecurityException if:\n     * <ol>\n     *     <li>the caller cannot modify phone state and the phone account doesn't belong to the\n     *     calling user.</li>\n     *     <li>the caller is registering a self-managed phone and either they are not allowed to\n     *     manage their own calls or if the account is call capable, a connection manager, or a\n     *     sim account.</li>\n     *     <li>the caller is registering a sim account without the ability to do so.</li>\n     *     <li>the caller is registering a multi-user phone account but isn't a system app.</li>\n     *     <li>the account can make SIM-based voice calls but the caller cannot register sim\n     *     accounts or isn't a sim call manager.</li>\n     *     <li>the account defines the EXTRA_SKIP_CALL_FILTERING extra but the caller isn't\n     *     able to modify the phone state.</li>\n     *     <li>the caller is registering an account for a different user but isn't able to\n     *     interact across users.</li>\n     *     <li>if simultaneous calling is available and the phone account package name doesn't\n     *     correspond to the simultaneous calling accounts associated with this phone account.</li>\n     * </ol>\n     ",
    "links" : [ "android.telecom.PhoneAccountHandle", "android.telecom.PhoneAccount", "SecurityException", "android.telecom.PhoneAccountHandle#getComponentName()", "IllegalArgumentException" ]
  }, {
    "name" : "public void unregisterPhoneAccount(PhoneAccountHandle accountHandle)",
    "returnType" : "void",
    "comment" : "\n     * Remove a {@link PhoneAccount} registration from the system.\n     *\n     * @param accountHandle A {@link PhoneAccountHandle} for the {@link PhoneAccount} to unregister.\n     ",
    "links" : [ "android.telecom.PhoneAccountHandle", "android.telecom.PhoneAccount" ]
  }, {
    "name" : "public void clearPhoneAccounts()",
    "returnType" : "void",
    "comment" : "\n     * Remove all Accounts that belong to the calling package from the system.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public void clearAccounts()",
    "returnType" : "void",
    "comment" : "\n     * Remove all Accounts that belong to the calling package from the system.\n     * @deprecated Use {@link #clearPhoneAccounts()} instead.\n     * @hide\n     ",
    "links" : [ "#clearPhoneAccounts()" ]
  }, {
    "name" : "public void clearAccountsForPackage(String packageName)",
    "returnType" : "void",
    "comment" : "\n     * Remove all Accounts that belong to the specified package from the system.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public ComponentName getDefaultPhoneApp()",
    "returnType" : "ComponentName",
    "comment" : "\n     * @deprecated - Use {@link TelecomManager#getDefaultDialerPackage} to directly access\n     *         the default dialer's package name instead.\n     * @hide\n     ",
    "links" : [ "android.telecom.TelecomManager#getDefaultDialerPackage" ]
  }, {
    "name" : "public String getDefaultDialerPackage()",
    "returnType" : "String",
    "comment" : "\n     * Used to determine the currently selected default dialer package.\n     *\n     * @return package name for the default dialer package or null if no package has been\n     *         selected as the default dialer.\n     ",
    "links" : [ ]
  }, {
    "name" : "public String getDefaultDialerPackage(@NonNull UserHandle userHandle)",
    "returnType" : "String",
    "comment" : "\n     * Used to determine the currently selected default dialer package for a specific user.\n     *\n     * @param userHandle the user id to query the default dialer package for.\n     * @return package name for the default dialer package or null if no package has been\n     *         selected as the default dialer.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean setDefaultDialer(@Nullable String packageName)",
    "returnType" : "boolean",
    "comment" : "\n     * Used to set the default dialer package.\n     *\n     * @param packageName to set the default dialer to, or {@code null} if the system provided\n     *                    dialer should be used instead.\n     *\n     * @result {@code true} if the default dialer was successfully changed, {@code false} if\n     *         the specified package does not correspond to an installed dialer, or is already\n     *         the default dialer.\n     *\n     * @hide\n     * @deprecated Use\n     * {@link android.app.role.RoleManager#addRoleHolderAsUser(String, String, int, UserHandle,\n     * Executor, java.util.function.Consumer)} instead.\n     * @removed\n     ",
    "links" : [ "android.app.role.RoleManager#addRoleHolderAsUser(String" ]
  }, {
    "name" : "public String getSystemDialerPackage()",
    "returnType" : "String",
    "comment" : "\n     * Determines the package name of the system-provided default phone app.\n     *\n     * @return package name for the system dialer package or {@code null} if no system dialer is\n     *         preloaded.\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean isVoiceMailNumber(PhoneAccountHandle accountHandle, String number)",
    "returnType" : "boolean",
    "comment" : "\n     * Return whether a given phone number is the configured voicemail number for a\n     * particular phone account.\n     *\n     * @param accountHandle The handle for the account to check the voicemail number against\n     * @param number The number to look up.\n     ",
    "links" : [ ]
  }, {
    "name" : "public String getVoiceMailNumber(PhoneAccountHandle accountHandle)",
    "returnType" : "String",
    "comment" : "\n     * Return the voicemail number for a given phone account.\n     *\n     * @param accountHandle The handle for the phone account.\n     * @return The voicemail number for the phone account, and {@code null} if one has not been\n     *         configured.\n     ",
    "links" : [ ]
  }, {
    "name" : "public String getLine1Number(PhoneAccountHandle accountHandle)",
    "returnType" : "String",
    "comment" : "\n     * Return the line 1 phone number for given phone account.\n     *\n     * <p>Requires Permission:\n     *     {@link android.Manifest.permission#READ_SMS READ_SMS},\n     *     {@link android.Manifest.permission#READ_PHONE_NUMBERS READ_PHONE_NUMBERS},\n     *     or that the caller is the default SMS app for any API level.\n     *     {@link android.Manifest.permission#READ_PHONE_STATE READ_PHONE_STATE}\n     *     for apps targeting SDK API level 29 and below.\n     *\n     * @param accountHandle The handle for the account retrieve a number for.\n     * @return A string representation of the line 1 phone number.\n     * @deprecated use {@link SubscriptionManager#getPhoneNumber(int)} instead, which takes a\n     *             Telephony Subscription ID that can be retrieved with the {@code accountHandle}\n     *             from {@link TelephonyManager#getSubscriptionId(PhoneAccountHandle)}.\n     ",
    "links" : [ "android.telephony.SubscriptionManager#getPhoneNumber(int)", "android.Manifest.permission#READ_SMS", "android.telephony.TelephonyManager#getSubscriptionId(PhoneAccountHandle)", "android.Manifest.permission#READ_PHONE_STATE", "android.Manifest.permission#READ_PHONE_NUMBERS" ]
  }, {
    "name" : "public boolean isInCall()",
    "returnType" : "boolean",
    "comment" : "\n     * Returns whether there is an ongoing phone call (can be in dialing, ringing, active or holding\n     * states) originating from either a manager or self-managed {@link ConnectionService}.\n     *\n     * @return {@code true} if there is an ongoing call in either a managed or self-managed\n     *      {@link ConnectionService}, {@code false} otherwise.\n     ",
    "links" : [ "android.telecom.ConnectionService" ]
  }, {
    "name" : "public boolean hasManageOngoingCallsPermission()",
    "returnType" : "boolean",
    "comment" : "\n     * Returns whether the caller has {@link android.Manifest.permission#MANAGE_ONGOING_CALLS}\n     * permission. The permission can be obtained by associating with a physical wearable device\n     * via the {@link android.companion.CompanionDeviceManager} API as a companion app. If the\n     * caller app has the permission, it has {@link InCallService} access to manage ongoing calls.\n     *\n     * @return {@code true} if the caller has {@link InCallService} access for\n     *      companion app; {@code false} otherwise.\n     ",
    "links" : [ "android.companion.CompanionDeviceManager", "android.Manifest.permission#MANAGE_ONGOING_CALLS", "android.telecom.InCallService" ]
  }, {
    "name" : "public boolean isInManagedCall()",
    "returnType" : "boolean",
    "comment" : "\n     * Returns whether there is an ongoing call originating from a managed\n     * {@link ConnectionService}.  An ongoing call can be in dialing, ringing, active or holding\n     * states.\n     * <p>\n     * If you also need to know if there are ongoing self-managed calls, use {@link #isInCall()}\n     * instead.\n     *\n     * @return {@code true} if there is an ongoing call in a managed {@link ConnectionService},\n     *      {@code false} otherwise.\n     ",
    "links" : [ "#isInCall()", "android.telecom.ConnectionService" ]
  }, {
    "name" : "public int getCallState()",
    "returnType" : "int",
    "comment" : "\n     * Returns one of the following constants that represents the current state of Telecom:\n     *\n     * {@link TelephonyManager#CALL_STATE_RINGING}\n     * {@link TelephonyManager#CALL_STATE_OFFHOOK}\n     * {@link TelephonyManager#CALL_STATE_IDLE}\n     *\n     * Takes into consideration both managed and self-managed calls.\n     * <p>\n     * Requires Permission:\n     * {@link android.Manifest.permission#READ_PHONE_STATE READ_PHONE_STATE} for applications\n     * targeting API level 31+.\n     *\n     * @hide\n     ",
    "links" : [ "android.telephony.TelephonyManager#CALL_STATE_IDLE", "android.telephony.TelephonyManager#CALL_STATE_OFFHOOK", "android.Manifest.permission#READ_PHONE_STATE", "android.telephony.TelephonyManager#CALL_STATE_RINGING" ]
  }, {
    "name" : "public boolean isRinging()",
    "returnType" : "boolean",
    "comment" : "\n     * Returns whether there currently exists is a ringing incoming-call.\n     *\n     * @return {@code true} if there is a managed or self-managed ringing call.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean endCall()",
    "returnType" : "boolean",
    "comment" : "\n     * Ends the foreground call on the device.\n     * <p>\n     * If there is a ringing call, calling this method rejects the ringing call.  Otherwise the\n     * foreground call is ended.\n     * <p>\n     * Note: this method CANNOT be used to end ongoing emergency calls and will return {@code false}\n     * if an attempt is made to end an emergency call.\n     *\n     * @return {@code true} if there is a call which will be rejected or terminated, {@code false}\n     * otherwise.\n     * @deprecated Companion apps for wearable devices should use the {@link InCallService} API\n     * instead.  Apps performing call screening should use the {@link CallScreeningService} API\n     * instead.\n     ",
    "links" : [ "android.telecom.InCallService", "android.telecom.CallScreeningService" ]
  }, {
    "name" : "public void acceptRingingCall()",
    "returnType" : "void",
    "comment" : " this method (clockwork & gearhead).",
    "links" : [ ]
  }, {
    "name" : "public void acceptRingingCall(int videoState)",
    "returnType" : "void",
    "comment" : "\n     * If there is a ringing incoming call, this method accepts the call on behalf of the user,\n     * with the specified video state.\n     *\n     * @param videoState The desired video state to answer the call with.\n     * @deprecated Companion apps for wearable devices should use the {@link InCallService} API\n     * instead.\n     ",
    "links" : [ "android.telecom.InCallService" ]
  }, {
    "name" : "public void silenceRinger()",
    "returnType" : "void",
    "comment" : "\n     * Silences the ringer if a ringing call exists.\n     * <p>\n     * This method can only be relied upon to stop the ringtone for a call if the ringtone has\n     * already started playing.  It is intended to handle use-cases such as silencing a ringing call\n     * when the user presses the volume button during ringing.\n     * <p>\n     * If this method is called prior to when the ringtone begins playing, the ringtone will not be\n     * silenced.  As such it is not intended as a means to avoid playing of a ringtone.\n     * <p>\n     * A dialer app which wants to have more control over ringtone playing should declare\n     * {@link TelecomManager#METADATA_IN_CALL_SERVICE_RINGING} in the manifest entry for their\n     * {@link InCallService} implementation to indicate that the app wants to be responsible for\n     * playing the ringtone for all incoming calls.\n     * <p>\n     * Requires permission: {@link android.Manifest.permission#MODIFY_PHONE_STATE} or that the\n     * app fills the dialer role (see {@link #getDefaultDialerPackage()}).\n     ",
    "links" : [ "android.telecom.InCallService", "android.telecom.TelecomManager#METADATA_IN_CALL_SERVICE_RINGING", "#getDefaultDialerPackage()", "android.Manifest.permission#MODIFY_PHONE_STATE" ]
  }, {
    "name" : "public boolean isTtySupported()",
    "returnType" : "boolean",
    "comment" : "\n     * Returns whether TTY is supported on this device.\n     ",
    "links" : [ ]
  }, {
    "name" : "public int getCurrentTtyMode()",
    "returnType" : "int",
    "comment" : "\n     * Returns the current TTY mode of the device. For TTY to be on the user must enable it in\n     * settings and have a wired headset plugged in.\n     * Valid modes are:\n     * - {@link TelecomManager#TTY_MODE_OFF}\n     * - {@link TelecomManager#TTY_MODE_FULL}\n     * - {@link TelecomManager#TTY_MODE_HCO}\n     * - {@link TelecomManager#TTY_MODE_VCO}\n     * @hide\n     ",
    "links" : [ "android.telecom.TelecomManager#TTY_MODE_FULL", "android.telecom.TelecomManager#TTY_MODE_HCO", "android.telecom.TelecomManager#TTY_MODE_OFF", "android.telecom.TelecomManager#TTY_MODE_VCO" ]
  }, {
    "name" : "public void addNewIncomingCall(PhoneAccountHandle phoneAccount, Bundle extras)",
    "returnType" : "void",
    "comment" : "\n     * Registers a new incoming call. A {@link ConnectionService} should invoke this method when it\n     * has an incoming call. For managed {@link ConnectionService}s, the specified\n     * {@link PhoneAccountHandle} must have been registered with {@link #registerPhoneAccount} and\n     * the user must have enabled the corresponding {@link PhoneAccount}.  This can be checked using\n     * {@link #getPhoneAccount}. Self-managed {@link ConnectionService}s must have\n     * {@link android.Manifest.permission#MANAGE_OWN_CALLS} to add a new incoming call.\n     * <p>\n     * Specify the address associated with the incoming call using\n     * {@link #EXTRA_INCOMING_CALL_ADDRESS}.  If an incoming call is from an anonymous source, omit\n     * this extra and ensure you specify a valid number presentation via\n     * {@link Connection#setAddress(Uri, int)} on the {@link Connection} instance you return in\n     * your\n     * {@link ConnectionService#onCreateIncomingConnection(PhoneAccountHandle, ConnectionRequest)}\n     * implementation.\n     * <p>\n     * The incoming call you are adding is assumed to have a video state of\n     * {@link VideoProfile#STATE_AUDIO_ONLY}, unless the extra value\n     * {@link #EXTRA_INCOMING_VIDEO_STATE} is specified.\n     * <p>\n     * Once invoked, this method will cause the system to bind to the {@link ConnectionService}\n     * associated with the {@link PhoneAccountHandle} and request additional information about the\n     * call (See {@link ConnectionService#onCreateIncomingConnection}) before starting the incoming\n     * call UI.\n     * <p>\n     * For a managed {@link ConnectionService}, a {@link SecurityException} will be thrown if either\n     * the {@link PhoneAccountHandle} does not correspond to a registered {@link PhoneAccount} or\n     * the associated {@link PhoneAccount} is not currently enabled by the user.\n     * <p>\n     * For a self-managed {@link ConnectionService}, a {@link SecurityException} will be thrown if\n     * the {@link PhoneAccount} has {@link PhoneAccount#CAPABILITY_SELF_MANAGED} and the calling app\n     * does not have {@link android.Manifest.permission#MANAGE_OWN_CALLS}.\n     * <p>\n     * <p>\n     * <b>Note</b>: {@link android.app.Notification.CallStyle} notifications should be posted after\n     * the call is added to Telecom in order for the notification to be non-dismissible.\n     * @param phoneAccount A {@link PhoneAccountHandle} registered with\n     *            {@link #registerPhoneAccount}.\n     * @param extras A bundle that will be passed through to\n     *            {@link ConnectionService#onCreateIncomingConnection}.\n     ",
    "links" : [ "#registerPhoneAccount", "android.telecom.ConnectionService#onCreateIncomingConnection", "SecurityException", "android.app.Notification.CallStyle", "android.telecom.Connection", "android.telecom.PhoneAccountHandle", "#EXTRA_INCOMING_CALL_ADDRESS", "#EXTRA_INCOMING_VIDEO_STATE", "android.telecom.Connection#setAddress(Uri", "android.telecom.PhoneAccount", "#getPhoneAccount", "android.Manifest.permission#MANAGE_OWN_CALLS", "android.telecom.ConnectionService#onCreateIncomingConnection(PhoneAccountHandle", "android.telecom.VideoProfile#STATE_AUDIO_ONLY", "android.telecom.PhoneAccount#CAPABILITY_SELF_MANAGED", "android.telecom.ConnectionService" ]
  }, {
    "name" : "public void addNewIncomingConference(@NonNull PhoneAccountHandle phoneAccount, @NonNull Bundle extras)",
    "returnType" : "void",
    "comment" : "\n     * Registers a new incoming conference. A {@link ConnectionService} should invoke this method\n     * when it has an incoming conference. An incoming {@link Conference} is an adhoc conference\n     * call initiated on another device which the user is being invited to join in. For managed\n     * {@link ConnectionService}s, the specified {@link PhoneAccountHandle} must have been\n     * registered with {@link #registerPhoneAccount} and the user must have enabled the\n     * corresponding {@link PhoneAccount}.  This can be checked using\n     * {@link #getPhoneAccount(PhoneAccountHandle)}. Self-managed {@link ConnectionService}s must\n     * have {@link android.Manifest.permission#MANAGE_OWN_CALLS} to add a new incoming call.\n     * <p>\n     * The incoming conference you are adding is assumed to have a video state of\n     * {@link VideoProfile#STATE_AUDIO_ONLY}, unless the extra value\n     * {@link #EXTRA_INCOMING_VIDEO_STATE} is specified.\n     * <p>\n     * Once invoked, this method will cause the system to bind to the {@link ConnectionService}\n     * associated with the {@link PhoneAccountHandle} and request additional information about the\n     * call (See\n     * {@link ConnectionService#onCreateIncomingConference(PhoneAccountHandle, ConnectionRequest)})\n     * before starting the incoming call UI.\n     * <p>\n     * For a managed {@link ConnectionService}, a {@link SecurityException} will be thrown if either\n     * the {@link PhoneAccountHandle} does not correspond to a registered {@link PhoneAccount} or\n     * the associated {@link PhoneAccount} is not currently enabled by the user.\n     *\n     * @param phoneAccount A {@link PhoneAccountHandle} registered with\n     *            {@link #registerPhoneAccount}.\n     * @param extras A bundle that will be passed through to\n     *            {@link ConnectionService#onCreateIncomingConference}.\n     ",
    "links" : [ "android.telecom.PhoneAccountHandle", "#getPhoneAccount(PhoneAccountHandle)", "#EXTRA_INCOMING_VIDEO_STATE", "android.telecom.PhoneAccount", "android.telecom.Conference", "android.Manifest.permission#MANAGE_OWN_CALLS", "#registerPhoneAccount", "android.telecom.ConnectionService#onCreateIncomingConference", "android.telecom.ConnectionService#onCreateIncomingConference(PhoneAccountHandle", "SecurityException", "android.telecom.VideoProfile#STATE_AUDIO_ONLY", "android.telecom.ConnectionService" ]
  }, {
    "name" : "public void addNewUnknownCall(PhoneAccountHandle phoneAccount, Bundle extras)",
    "returnType" : "void",
    "comment" : "\n     * Registers a new unknown call with Telecom. This can only be called by the system Telephony\n     * service. This is invoked when Telephony detects a new unknown connection that was neither\n     * a new incoming call, nor an user-initiated outgoing call.\n     *\n     * @param phoneAccount A {@link PhoneAccountHandle} registered with\n     *            {@link #registerPhoneAccount}.\n     * @param extras A bundle that will be passed through to\n     *            {@link ConnectionService#onCreateIncomingConnection}.\n     * @hide\n     ",
    "links" : [ "android.telecom.PhoneAccountHandle", "#registerPhoneAccount", "android.telecom.ConnectionService#onCreateIncomingConnection" ]
  }, {
    "name" : "public boolean handleMmi(String dialString)",
    "returnType" : "boolean",
    "comment" : "\n     * Processes the specified dial string as an MMI code.\n     * MMI codes are any sequence of characters entered into the dialpad that contain a \"*\" or \"#\".\n     * Some of these sequences launch special behavior through handled by Telephony.\n     * This method uses the default subscription.\n     * <p>\n     * Requires that the method-caller be set as the system dialer app.\n     * </p>\n     *\n     * @param dialString The digits to dial.\n     * @return True if the digits were processed as an MMI code, false otherwise.\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean handleMmi(String dialString, PhoneAccountHandle accountHandle)",
    "returnType" : "boolean",
    "comment" : "\n     * Processes the specified dial string as an MMI code.\n     * MMI codes are any sequence of characters entered into the dialpad that contain a \"*\" or \"#\".\n     * Some of these sequences launch special behavior through handled by Telephony.\n     * <p>\n     * Requires that the method-caller be set as the system dialer app.\n     * </p>\n     *\n     * @param accountHandle The handle for the account the MMI code should apply to.\n     * @param dialString The digits to dial.\n     * @return True if the digits were processed as an MMI code, false otherwise.\n     ",
    "links" : [ ]
  }, {
    "name" : "public Uri getAdnUriForPhoneAccount(PhoneAccountHandle accountHandle)",
    "returnType" : "Uri",
    "comment" : "\n     * Returns a URI (with the content:// scheme) specific to the specified {@link PhoneAccount}\n     * for ADN content retrieval.\n     * @param accountHandle The handle for the account to derive an adn query URI for or\n     * {@code null} to return a URI which will use the default account.\n     * @return The URI (with the content:// scheme) specific to the specified {@link PhoneAccount}\n     * for the the content retrieve.\n     ",
    "links" : [ "android.telecom.PhoneAccount" ]
  }, {
    "name" : "public void cancelMissedCallsNotification()",
    "returnType" : "void",
    "comment" : "\n     * Removes the missed-call notification if one is present and marks missed calls in the call\n     * log as read.\n     * <p>\n     * Requires that the method-caller be set as the default dialer app.\n     * </p>\n     ",
    "links" : [ ]
  }, {
    "name" : "public void showInCallScreen(boolean showDialpad)",
    "returnType" : "void",
    "comment" : "\n     * Brings the in-call screen to the foreground if there is an ongoing call. If there is\n     * currently no ongoing call, then this method does nothing.\n     * <p>\n     * Requires that the method-caller be set as the system dialer app or have the\n     * {@link android.Manifest.permission#READ_PHONE_STATE} permission.\n     * </p>\n     *\n     * @param showDialpad Brings up the in-call dialpad as part of showing the in-call screen.\n     ",
    "links" : [ "android.Manifest.permission#READ_PHONE_STATE" ]
  }, {
    "name" : "public void placeCall(Uri address, Bundle extras)",
    "returnType" : "void",
    "comment" : "\n     * Places a new outgoing call to the provided address using the system telecom service with\n     * the specified extras.\n     *\n     * This method is equivalent to placing an outgoing call using {@link Intent#ACTION_CALL},\n     * except that the outgoing call will always be sent via the system telecom service. If\n     * method-caller is either the user selected default dialer app or preloaded system dialer\n     * app, then emergency calls will also be allowed.\n     *\n     * Placing a call via a managed {@link ConnectionService} requires permission:\n     * {@link android.Manifest.permission#CALL_PHONE}\n     *\n     * Usage example:\n     * <pre>\n     * Uri uri = Uri.fromParts(\"tel\", \"12345\", null);\n     * Bundle extras = new Bundle();\n     * extras.putBoolean(TelecomManager.EXTRA_START_CALL_WITH_SPEAKERPHONE, true);\n     * telecomManager.placeCall(uri, extras);\n     * </pre>\n     *\n     * The following keys are supported in the supplied extras.\n     * <ul>\n     *   <li>{@link #EXTRA_OUTGOING_CALL_EXTRAS}</li>\n     *   <li>{@link #EXTRA_PHONE_ACCOUNT_HANDLE}</li>\n     *   <li>{@link #EXTRA_START_CALL_WITH_SPEAKERPHONE}</li>\n     *   <li>{@link #EXTRA_START_CALL_WITH_VIDEO_STATE}</li>\n     * </ul>\n     * <p>\n     * An app which implements the self-managed {@link ConnectionService} API uses\n     * {@link #placeCall(Uri, Bundle)} to inform Telecom of a new outgoing call.  A self-managed\n     * {@link ConnectionService} must include {@link #EXTRA_PHONE_ACCOUNT_HANDLE} to specify its\n     * associated {@link android.telecom.PhoneAccountHandle}.\n     *\n     * Self-managed {@link ConnectionService}s require permission\n     * {@link android.Manifest.permission#MANAGE_OWN_CALLS}.\n     *\n     * <p class=\"note\"><strong>Note:</strong> If this method is used to place an emergency call, it\n     * is not guaranteed that the call will be placed on the {@link PhoneAccount} provided in\n     * the {@link #EXTRA_PHONE_ACCOUNT_HANDLE} extra (if specified) and may be placed on another\n     * {@link PhoneAccount} with the {@link PhoneAccount#CAPABILITY_PLACE_EMERGENCY_CALLS}\n     * capability, depending on external factors, such as network conditions and Modem/SIM status.\n     * </p>\n     * <p>\n     * <p>\n     * <b>Note</b>: {@link android.app.Notification.CallStyle} notifications should be posted after\n     * the call is placed in order for the notification to be non-dismissible.\n     * <p><b>Note</b>: Call Forwarding MMI codes can only be dialed by applications that are\n     * configured as the user defined default dialer or system dialer role. If a call containing a\n     * call forwarding MMI code is placed by an application that is not in one of these roles, the\n     * dialer will be launched with a UI showing the MMI code already populated so that the user can\n     * confirm the action before the call is placed.\n     * @param address The address to make the call to.\n     * @param extras Bundle of extras to use with the call.\n     ",
    "links" : [ "#EXTRA_OUTGOING_CALL_EXTRAS", "android.telecom.PhoneAccount#CAPABILITY_PLACE_EMERGENCY_CALLS", "#EXTRA_START_CALL_WITH_VIDEO_STATE", "android.content.Intent#ACTION_CALL", "#EXTRA_START_CALL_WITH_SPEAKERPHONE", "#placeCall(Uri", "android.Manifest.permission#CALL_PHONE", "android.app.Notification.CallStyle", "#EXTRA_PHONE_ACCOUNT_HANDLE", "android.telecom.PhoneAccountHandle", "android.telecom.PhoneAccount", "android.Manifest.permission#MANAGE_OWN_CALLS", "android.telecom.ConnectionService" ]
  }, {
    "name" : "public void startConference(@NonNull List<Uri> participants, @NonNull Bundle extras)",
    "returnType" : "void",
    "comment" : "\n     * Place a new adhoc conference call with the provided participants using the system telecom\n     * service. This method doesn't support placing of emergency calls.\n     *\n     * An adhoc conference call is established by providing a list of addresses to\n     * {@code TelecomManager#startConference(List<Uri>, int videoState)} where the\n     * {@link ConnectionService} is responsible for connecting all indicated participants\n     * to a conference simultaneously.\n     * This is in contrast to conferences formed by merging calls together (e.g. using\n     * {@link android.telecom.Call#mergeConference()}).\n     *\n     * The following keys are supported in the supplied extras.\n     * <ul>\n     *   <li>{@link #EXTRA_PHONE_ACCOUNT_HANDLE}</li>\n     *   <li>{@link #EXTRA_START_CALL_WITH_SPEAKERPHONE}</li>\n     *   <li>{@link #EXTRA_START_CALL_WITH_VIDEO_STATE}</li>\n     * </ul>\n     *\n     * @param participants List of participants to start conference with\n     * @param extras Bundle of extras to use with the call\n     ",
    "links" : [ "#EXTRA_START_CALL_WITH_VIDEO_STATE", "#EXTRA_START_CALL_WITH_SPEAKERPHONE", "android.telecom.Call#mergeConference()", "android.telecom.ConnectionService", "#EXTRA_PHONE_ACCOUNT_HANDLE" ]
  }, {
    "name" : "public void enablePhoneAccount(PhoneAccountHandle handle, boolean isEnabled)",
    "returnType" : "void",
    "comment" : "\n     * Enables and disables specified phone account.\n     *\n     * @param handle Handle to the phone account.\n     * @param isEnabled Enable state of the phone account.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public TelecomAnalytics dumpAnalytics()",
    "returnType" : "TelecomAnalytics",
    "comment" : "\n     * Dumps telecom analytics for uploading.\n     *\n     * @return\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public Intent createManageBlockedNumbersIntent()",
    "returnType" : "Intent",
    "comment" : "\n     * Creates the {@link Intent} which can be used with {@link Context#startActivity(Intent)} to\n     * launch the activity to manage blocked numbers.\n     * <p> The activity will display the UI to manage blocked numbers only if\n     * {@link android.provider.BlockedNumberContract#canCurrentUserBlockNumbers(Context)} returns\n     * {@code true} for the current user.\n     ",
    "links" : [ "android.provider.BlockedNumberContract#canCurrentUserBlockNumbers(Context)", "android.content.Intent", "android.content.Context#startActivity(Intent)" ]
  }, {
    "name" : "public Intent createLaunchEmergencyDialerIntent(@Nullable String number)",
    "returnType" : "Intent",
    "comment" : "\n     * Creates the {@link Intent} which can be used with {@link Context#startActivity(Intent)} to\n     * launch the activity for emergency dialer.\n     *\n     * @param number Optional number to call in emergency dialer\n     * @hide\n     ",
    "links" : [ "android.content.Intent", "android.content.Context#startActivity(Intent)" ]
  }, {
    "name" : "public boolean isIncomingCallPermitted(PhoneAccountHandle phoneAccountHandle)",
    "returnType" : "boolean",
    "comment" : "\n     * Determines whether Telecom would permit an incoming call to be added via the\n     * {@link #addNewIncomingCall(PhoneAccountHandle, Bundle)} API for the specified\n     * {@link PhoneAccountHandle}.\n     * <p>\n     * A {@link ConnectionService} may not add a call for the specified {@link PhoneAccountHandle}\n     * in the following situations:\n     * <ul>\n     *     <li>{@link PhoneAccount} does not have property\n     *     {@link PhoneAccount#CAPABILITY_SELF_MANAGED} set (i.e. it is a managed\n     *     {@link ConnectionService}), and the active or held call limit has\n     *     been reached.</li>\n     *     <li>There is an ongoing emergency call.</li>\n     * </ul>\n     *\n     * @param phoneAccountHandle The {@link PhoneAccountHandle} the call will be added for.\n     * @return {@code true} if telecom will permit an incoming call to be added, {@code false}\n     *      otherwise.\n     ",
    "links" : [ "android.telecom.PhoneAccountHandle", "android.telecom.PhoneAccount", "#addNewIncomingCall(PhoneAccountHandle", "android.telecom.PhoneAccount#CAPABILITY_SELF_MANAGED", "android.telecom.ConnectionService" ]
  }, {
    "name" : "public boolean isOutgoingCallPermitted(PhoneAccountHandle phoneAccountHandle)",
    "returnType" : "boolean",
    "comment" : "\n     * Determines whether Telecom would permit an outgoing call to be placed via the\n     * {@link #placeCall(Uri, Bundle)} API for the specified {@link PhoneAccountHandle}.\n     * <p>\n     * A {@link ConnectionService} may not place a call for the specified {@link PhoneAccountHandle}\n     * in the following situations:\n     * <ul>\n     *     <li>{@link PhoneAccount} does not have property\n     *     {@link PhoneAccount#CAPABILITY_SELF_MANAGED} set (i.e. it is a managed\n     *     {@link ConnectionService}), and the active, held or ringing call limit has\n     *     been reached.</li>\n     *     <li>{@link PhoneAccount} has property {@link PhoneAccount#CAPABILITY_SELF_MANAGED} set\n     *     (i.e. it is a self-managed {@link ConnectionService} and there is an ongoing call in\n     *     another {@link ConnectionService}.</li>\n     *     <li>There is an ongoing emergency call.</li>\n     * </ul>\n     *\n     * @param phoneAccountHandle The {@link PhoneAccountHandle} the call will be added for.\n     * @return {@code true} if telecom will permit an outgoing call to be placed, {@code false}\n     *      otherwise.\n     ",
    "links" : [ "android.telecom.PhoneAccountHandle", "android.telecom.PhoneAccount", "#placeCall(Uri", "android.telecom.PhoneAccount#CAPABILITY_SELF_MANAGED", "android.telecom.ConnectionService" ]
  }, {
    "name" : "public void acceptHandover(Uri srcAddr, @VideoProfile.VideoState int videoState, PhoneAccountHandle destAcct)",
    "returnType" : "void",
    "comment" : "\n     * Called by an app to indicate that it wishes to accept the handover of an ongoing call to a\n     * {@link PhoneAccountHandle} it defines.\n     * <p>\n     * A call handover is the process where an ongoing call is transferred from one app (i.e.\n     * {@link ConnectionService} to another app.  The user could, for example, choose to continue a\n     * mobile network call in a video calling app.  The mobile network call via the Telephony stack\n     * is referred to as the source of the handover, and the video calling app is referred to as the\n     * destination.\n     * <p>\n     * When considering a handover scenario the <em>initiating</em> device is where a user initiated\n     * the handover process (e.g. by calling {@link android.telecom.Call#handoverTo(\n     * PhoneAccountHandle, int, Bundle)}, and the other device is considered the <em>receiving</em>\n     * device.\n     * <p>\n     * For a full discussion of the handover process and the APIs involved, see\n     * {@link android.telecom.Call#handoverTo(PhoneAccountHandle, int, Bundle)}.\n     * <p>\n     * This method is called from the <em>receiving</em> side of a handover to indicate a desire to\n     * accept the handover of an ongoing call to another {@link ConnectionService} identified by\n     * {@link PhoneAccountHandle} destAcct. For managed {@link ConnectionService}s, the specified\n     * {@link PhoneAccountHandle} must have been registered with {@link #registerPhoneAccount} and\n     * the user must have enabled the corresponding {@link PhoneAccount}.  This can be checked using\n     * {@link #getPhoneAccount}. Self-managed {@link ConnectionService}s must have\n     * {@link android.Manifest.permission#MANAGE_OWN_CALLS} to handover a call to it.\n     * <p>\n     * Once invoked, this method will cause the system to bind to the {@link ConnectionService}\n     * associated with the {@link PhoneAccountHandle} destAcct and call\n     * (See {@link ConnectionService#onCreateIncomingHandoverConnection}).\n     * <p>\n     * For a managed {@link ConnectionService}, a {@link SecurityException} will be thrown if either\n     * the {@link PhoneAccountHandle} destAcct does not correspond to a registered\n     * {@link PhoneAccount} or the associated {@link PhoneAccount} is not currently enabled by the\n     * user.\n     * <p>\n     * For a self-managed {@link ConnectionService}, a {@link SecurityException} will be thrown if\n     * the calling app does not have {@link android.Manifest.permission#MANAGE_OWN_CALLS}.\n     *\n     * @param srcAddr The {@link android.net.Uri} of the ongoing call to handover to the callers\n     *                {@link ConnectionService}.\n     * @param videoState Video state after the handover.\n     * @param destAcct The {@link PhoneAccountHandle} registered to the calling package.\n     ",
    "links" : [ "android.telecom.PhoneAccountHandle", "android.telecom.PhoneAccount", "#getPhoneAccount", "android.Manifest.permission#MANAGE_OWN_CALLS", "android.telecom.ConnectionService#onCreateIncomingHandoverConnection", "android.telecom.Call#handoverTo(", "android.net.Uri", "#registerPhoneAccount", "SecurityException", "android.telecom.ConnectionService", "android.telecom.Call#handoverTo(PhoneAccountHandle" ]
  }, {
    "name" : "public boolean isInEmergencyCall()",
    "returnType" : "boolean",
    "comment" : "\n     * Determines if there is an ongoing emergency call.  This can be either an outgoing emergency\n     * call, as identified by the dialed number, or because a call was identified by the network\n     * as an emergency call.\n     * @return {@code true} if there is an ongoing emergency call, {@code false} otherwise.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean isInSelfManagedCall(@NonNull String packageName, @NonNull UserHandle userHandle)",
    "returnType" : "boolean",
    "comment" : "\n     * Determines whether there are any ongoing {@link PhoneAccount#CAPABILITY_SELF_MANAGED}\n     * calls for a given {@code packageName} and {@code userHandle}. If UserHandle.ALL or a user\n     * that isn't the calling user is passed in, the caller will need to have granted the ability\n     * to interact across users.\n     *\n     * @param packageName the package name of the app to check calls for.\n     * @param userHandle the user handle to check calls for.\n     * @return {@code true} if there are ongoing calls, {@code false} otherwise.\n     * @throws SecurityException if the userHandle is not the calling user and the caller does not\n     * grant the ability to interact across users.\n     * @hide\n     ",
    "links" : [ "android.telecom.PhoneAccount#CAPABILITY_SELF_MANAGED" ]
  }, {
    "name" : "public void addCall(@NonNull CallAttributes callAttributes, @NonNull @CallbackExecutor Executor executor, @NonNull OutcomeReceiver<CallControl, CallException> pendingControl, @NonNull CallControlCallback handshakes, @NonNull CallEventCallback events)",
    "returnType" : "void",
    "comment" : "\n     * Add a call to the Android system service Telecom. This allows the system to start tracking an\n     * incoming or outgoing call with the specified {@link CallAttributes}.  Once a call is added,\n     * a {@link android.app.Notification.CallStyle} notification should be posted and when the\n     * call is ready to be disconnected, use {@link CallControl#disconnect(DisconnectCause,\n     * Executor, OutcomeReceiver)} which is provided by the\n     * {@code pendingControl#onResult(CallControl)}.\n     * <p>\n     * <p>\n     * <p>\n     * <b>Call Lifecycle</b>: Your app is given foreground execution priority as long as you have a\n     * valid call and are posting a {@link android.app.Notification.CallStyle} notification.\n     * When your application is given foreground execution priority, your app is treated as a\n     * foreground service. Foreground execution priority will prevent the\n     * {@link android.app.ActivityManager} from killing your application when it is placed the\n     * background. Foreground execution priority is removed from your app when all of your app's\n     * calls terminate or your app no longer posts a valid notification.\n     * <p>\n     * <p>\n     * <p>\n     * <b>Note</b>: Only packages that register with\n     * {@link PhoneAccount#CAPABILITY_SUPPORTS_TRANSACTIONAL_OPERATIONS}\n     * can utilize this API. {@link PhoneAccount}s that set the capabilities\n     * {@link PhoneAccount#CAPABILITY_SIM_SUBSCRIPTION},\n     * {@link PhoneAccount#CAPABILITY_CALL_PROVIDER},\n     * {@link PhoneAccount#CAPABILITY_CONNECTION_MANAGER}\n     * are not supported and will cause an exception to be thrown.\n     * <p>\n     * <p>\n     * <p>\n     * <b>Usage example:</b>\n     * <pre>\n     *  // Its up to your app on how you want to wrap the objects. One such implementation can be:\n     *  class MyVoipCall {\n     *    ...\n     *      public CallControlCallEventCallback handshakes = new  CallControlCallback() {\n     *                         ...\n     *                        }\n     *\n     *      public CallEventCallback events = new CallEventCallback() {\n     *                         ...\n     *                        }\n     *\n     *      public MyVoipCall(String id){\n     *          ...\n     *      }\n     *  }\n     *\n     * MyVoipCall myFirstOutgoingCall = new MyVoipCall(\"1\");\n     *\n     * telecomManager.addCall(callAttributes,\n     *                        Runnable::run,\n     *                        new OutcomeReceiver() {\n     *                              public void onResult(CallControl callControl) {\n     *                                 // The call has been added successfully. For demonstration\n     *                                 // purposes, the call is disconnected immediately ...\n     *                                 callControl.disconnect(\n     *                                                 new DisconnectCause(DisconnectCause.LOCAL) )\n     *                              }\n     *                           },\n     *                           myFirstOutgoingCall.handshakes,\n     *                           myFirstOutgoingCall.events);\n     * </pre>\n     *\n     * @param callAttributes attributes of the new call (incoming or outgoing, address, etc.)\n     * @param executor       execution context to run {@link CallControlCallback} updates on\n     * @param pendingControl Receives the result of addCall transaction. Upon success, a\n     *                       CallControl object is provided which can be used to do things like\n     *                       disconnect the call that was added.\n     * @param handshakes     callback that receives <b>actionable</b> updates that originate from\n     *                       Telecom.\n     * @param events         callback that receives <b>non</b>-actionable updates that originate\n     *                       from Telecom.\n     ",
    "links" : [ "android.telecom.PhoneAccount#CAPABILITY_CONNECTION_MANAGER", "android.telecom.CallControlCallback", "android.telecom.CallAttributes", "android.app.ActivityManager", "android.telecom.PhoneAccount#CAPABILITY_CALL_PROVIDER", "android.telecom.PhoneAccount#CAPABILITY_SUPPORTS_TRANSACTIONAL_OPERATIONS", "android.telecom.CallControl#disconnect(DisconnectCause", "android.telecom.PhoneAccount", "android.telecom.PhoneAccount#CAPABILITY_SIM_SUBSCRIPTION", "android.app.Notification.CallStyle" ]
  }, {
    "name" : "public void handleCallIntent(Intent intent, String callingPackageProxy)",
    "returnType" : "void",
    "comment" : "\n     * Handles {@link Intent#ACTION_CALL} intents trampolined from UserCallActivity.\n     * @param intent The {@link Intent#ACTION_CALL} intent to handle.\n     * @param callingPackageProxy The original package that called this before it was trampolined.\n     * @hide\n     ",
    "links" : [ "android.content.Intent#ACTION_CALL" ]
  }, {
    "name" : "private boolean isSystemProcess()",
    "returnType" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private ITelecomService getTelecomService()",
    "returnType" : "ITelecomService",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private static void resetServiceCache()",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  } ],
  "methodNames" : [ "public static TelecomManager from(Context context)", "public PhoneAccountHandle getDefaultOutgoingPhoneAccount(String uriScheme)", "public PhoneAccountHandle getUserSelectedOutgoingPhoneAccount()", "public void setUserSelectedOutgoingPhoneAccount(@Nullable PhoneAccountHandle accountHandle)", "public PhoneAccountHandle getSimCallManager()", "public PhoneAccountHandle getSimCallManagerForSubscription(int subscriptionId)", "public PhoneAccountHandle getSimCallManager(int userId)", "public PhoneAccountHandle getConnectionManager()", "public List<PhoneAccountHandle> getPhoneAccountsSupportingScheme(String uriScheme)", "public List<PhoneAccountHandle> getCallCapablePhoneAccounts()", "public List<PhoneAccountHandle> getCallCapablePhoneAccountsAcrossProfiles()", "public List<PhoneAccountHandle> getSelfManagedPhoneAccounts()", "public List<PhoneAccountHandle> getOwnSelfManagedPhoneAccounts()", "public List<PhoneAccount> getRegisteredPhoneAccounts()", "public List<PhoneAccountHandle> getCallCapablePhoneAccounts(boolean includeDisabledAccounts)", "public List<PhoneAccountHandle> getCallCapablePhoneAccountsAcrossProfiles(boolean includeDisabledAccounts)", "public List<PhoneAccountHandle> getPhoneAccountsForPackage()", "public PhoneAccount getPhoneAccount(PhoneAccountHandle account)", "public int getAllPhoneAccountsCount()", "public List<PhoneAccount> getAllPhoneAccounts()", "public List<PhoneAccountHandle> getAllPhoneAccountHandles()", "public void registerPhoneAccount(PhoneAccount account)", "public void unregisterPhoneAccount(PhoneAccountHandle accountHandle)", "public void clearPhoneAccounts()", "public void clearAccounts()", "public void clearAccountsForPackage(String packageName)", "public ComponentName getDefaultPhoneApp()", "public String getDefaultDialerPackage()", "public String getDefaultDialerPackage(@NonNull UserHandle userHandle)", "public boolean setDefaultDialer(@Nullable String packageName)", "public String getSystemDialerPackage()", "public boolean isVoiceMailNumber(PhoneAccountHandle accountHandle, String number)", "public String getVoiceMailNumber(PhoneAccountHandle accountHandle)", "public String getLine1Number(PhoneAccountHandle accountHandle)", "public boolean isInCall()", "public boolean hasManageOngoingCallsPermission()", "public boolean isInManagedCall()", "public int getCallState()", "public boolean isRinging()", "public boolean endCall()", "public void acceptRingingCall()", "public void acceptRingingCall(int videoState)", "public void silenceRinger()", "public boolean isTtySupported()", "public int getCurrentTtyMode()", "public void addNewIncomingCall(PhoneAccountHandle phoneAccount, Bundle extras)", "public void addNewIncomingConference(@NonNull PhoneAccountHandle phoneAccount, @NonNull Bundle extras)", "public void addNewUnknownCall(PhoneAccountHandle phoneAccount, Bundle extras)", "public boolean handleMmi(String dialString)", "public boolean handleMmi(String dialString, PhoneAccountHandle accountHandle)", "public Uri getAdnUriForPhoneAccount(PhoneAccountHandle accountHandle)", "public void cancelMissedCallsNotification()", "public void showInCallScreen(boolean showDialpad)", "public void placeCall(Uri address, Bundle extras)", "public void startConference(@NonNull List<Uri> participants, @NonNull Bundle extras)", "public void enablePhoneAccount(PhoneAccountHandle handle, boolean isEnabled)", "public TelecomAnalytics dumpAnalytics()", "public Intent createManageBlockedNumbersIntent()", "public Intent createLaunchEmergencyDialerIntent(@Nullable String number)", "public boolean isIncomingCallPermitted(PhoneAccountHandle phoneAccountHandle)", "public boolean isOutgoingCallPermitted(PhoneAccountHandle phoneAccountHandle)", "public void acceptHandover(Uri srcAddr, @VideoProfile.VideoState int videoState, PhoneAccountHandle destAcct)", "public boolean isInEmergencyCall()", "public boolean isInSelfManagedCall(@NonNull String packageName, @NonNull UserHandle userHandle)", "public void addCall(@NonNull CallAttributes callAttributes, @NonNull @CallbackExecutor Executor executor, @NonNull OutcomeReceiver<CallControl, CallException> pendingControl, @NonNull CallControlCallback handshakes, @NonNull CallEventCallback events)", "public void handleCallIntent(Intent intent, String callingPackageProxy)", "private boolean isSystemProcess()", "private ITelecomService getTelecomService()", "private static void resetServiceCache()" ],
  "variableNames" : [ "ACTION_INCOMING_CALL", "ACTION_NEW_UNKNOWN_CALL", "ACTION_CONFIGURE_PHONE_ACCOUNT", "ACTION_SHOW_CALL_ACCESSIBILITY_SETTINGS", "ACTION_SHOW_CALL_SETTINGS", "ACTION_SHOW_RESPOND_VIA_SMS_SETTINGS", "ACTION_CHANGE_PHONE_ACCOUNTS", "ACTION_PHONE_ACCOUNT_REGISTERED", "ACTION_PHONE_ACCOUNT_UNREGISTERED", "ACTION_CHANGE_DEFAULT_DIALER", "ACTION_DEFAULT_DIALER_CHANGED", "EXTRA_CHANGE_DEFAULT_DIALER_PACKAGE_NAME", "ACTION_DEFAULT_CALL_SCREENING_APP_CHANGED", "EXTRA_DEFAULT_CALL_SCREENING_APP_COMPONENT_NAME", "EXTRA_DO_NOT_LOG_CALL", "EXTRA_IS_DEFAULT_CALL_SCREENING_APP", "EXTRA_START_CALL_WITH_SPEAKERPHONE", "EXTRA_START_CALL_WITH_VIDEO_STATE", "EXTRA_INCOMING_VIDEO_STATE", "EXTRA_PHONE_ACCOUNT_HANDLE", "EXTRA_CALL_SUBJECT", "PRIORITY_NORMAL", "PRIORITY_URGENT", "EXTRA_PRIORITY", "EXTRA_LOCATION", "EXTRA_HAS_PICTURE", "EXTRA_PICTURE_URI", "EXTRA_OUTGOING_PICTURE", "EXTRA_INCOMING_CALL_ADDRESS", "EXTRA_INCOMING_CALL_EXTRAS", "EXTRA_CALL_HAS_IN_BAND_RINGTONE", "EXTRA_OUTGOING_CALL_EXTRAS", "EXTRA_IS_USER_INTENT_EMERGENCY_CALL", "EXTRA_UNKNOWN_CALL_HANDLE", "EXTRA_CALL_CREATED_TIME_MILLIS", "EXTRA_CALL_LOG_URI", "EXTRA_CALL_ANSWERED_TIME_MILLIS", "EXTRA_CALL_CREATED_EPOCH_TIME_MILLIS", "EXTRA_CALL_TELECOM_ROUTING_START_TIME_MILLIS", "EXTRA_CALL_TELECOM_ROUTING_END_TIME_MILLIS", "EXTRA_CALL_DISCONNECT_CAUSE", "EXTRA_CALL_DISCONNECT_MESSAGE", "CALL_AUTO_DISCONNECT_MESSAGE_STRING", "EXTRA_CONNECTION_SERVICE", "EXTRA_CALL_TECHNOLOGY_TYPE", "EXTRA_CALL_NETWORK_TYPE", "GATEWAY_PROVIDER_PACKAGE", "GATEWAY_ORIGINAL_ADDRESS", "EXTRA_CALL_BACK_NUMBER", "EXTRA_NEW_OUTGOING_CALL_CANCEL_TIMEOUT", "EXTRA_IS_HANDOVER", "EXTRA_IS_HANDOVER_CONNECTION", "EXTRA_HANDOVER_FROM_PHONE_ACCOUNT", "EXTRA_CALL_AUDIO_STATE", "EXTRA_START_CALL_WITH_RTT", "ACTION_POST_CALL", "EXTRA_HANDLE", "EXTRA_DISCONNECT_CAUSE", "EXTRA_CALL_DURATION", "DURATION_VERY_SHORT", "DURATION_SHORT", "DURATION_MEDIUM", "DURATION_LONG", "VERY_SHORT_CALL_TIME_MS", "SHORT_CALL_TIME_MS", "MEDIUM_CALL_TIME_MS", "METADATA_IN_CALL_SERVICE_UI", "METADATA_IN_CALL_SERVICE_CAR_MODE_UI", "METADATA_IN_CALL_SERVICE_RINGING", "METADATA_INCLUDE_EXTERNAL_CALLS", "METADATA_INCLUDE_SELF_MANAGED_CALLS", "DTMF_CHARACTER_PAUSE", "DTMF_CHARACTER_WAIT", "TTY_MODE_OFF", "TTY_MODE_FULL", "TTY_MODE_HCO", "TTY_MODE_VCO", "ACTION_CURRENT_TTY_MODE_CHANGED", "EXTRA_CURRENT_TTY_MODE", "ACTION_TTY_PREFERRED_MODE_CHANGED", "EXTRA_TTY_PREFERRED_MODE", "ACTION_SHOW_MISSED_CALLS_NOTIFICATION", "EXTRA_NOTIFICATION_COUNT", "EXTRA_NOTIFICATION_PHONE_NUMBER", "EXTRA_CLEAR_MISSED_CALLS_INTENT", "EXTRA_CALL_BACK_INTENT", "EMERGENCY_DIALER_COMPONENT", "EXTRA_USE_ASSISTED_DIALING", "EXTRA_CALL_SOURCE", "ACTION_SHOW_SWITCH_TO_WORK_PROFILE_FOR_CALL_DIALOG", "EXTRA_MANAGED_PROFILE_USER_ID", "CALL_SOURCE_EMERGENCY_SHORTCUT", "CALL_SOURCE_EMERGENCY_DIALPAD", "CALL_SOURCE_UNSPECIFIED", "PRESENTATION_ALLOWED", "PRESENTATION_RESTRICTED", "PRESENTATION_UNKNOWN", "PRESENTATION_PAYPHONE", "PRESENTATION_UNAVAILABLE", "PROPERTY_VIDEOCALL_AUDIO_OUTPUT", "AUDIO_OUTPUT_ENABLE_SPEAKER", "AUDIO_OUTPUT_DISABLE_SPEAKER", "AUDIO_OUTPUT_DEFAULT", "ENABLE_GET_CALL_STATE_PERMISSION_PROTECTION", "ENABLE_GET_PHONE_ACCOUNT_PERMISSION_PROTECTION", "TAG", "CACHE_LOCK", "sTelecomService", "SERVICE_DEATH", "mContext", "mTelecomServiceOverride", "mTransactionalServiceRepository", "TELECOM_TRANSACTION_SUCCESS", "TRANSACTION_CALL_ID_KEY" ]
}