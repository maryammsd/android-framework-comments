{
  "filePath" : "/home/maryam/clearblue/files/android-source-35/android/app/ActivityManager.java",
  "packageName" : "android.app",
  "className" : "ActivityManager",
  "comment" : "\n * <p>\n * This class gives information about, and interacts\n * with, activities, services, and the containing\n * process.\n * </p>\n *\n * <p>\n * A number of the methods in this class are for\n * debugging or informational purposes and they should\n * not be used to affect any runtime behavior of\n * your app. These methods are called out as such in\n * the method level documentation.\n * </p>\n *\n *<p>\n * Most application developers should not have the need to\n * use this class, most of whose methods are for specialized\n * use cases. However, a few methods are more broadly applicable.\n * For instance, {@link android.app.ActivityManager#isLowRamDevice() isLowRamDevice()}\n * enables your app to detect whether it is running on a low-memory device,\n * and behave accordingly.\n * {@link android.app.ActivityManager#clearApplicationUserData() clearApplicationUserData()}\n * is for apps with reset-data functionality.\n * </p>\n *\n * <p>\n * In some special use cases, where an app interacts with\n * its Task stack, the app may use the\n * {@link android.app.ActivityManager.AppTask} and\n * {@link android.app.ActivityManager.RecentTaskInfo} inner\n * classes. However, in general, the methods in this class should\n * be used for testing and debugging purposes only.\n * </p>\n ",
  "links" : [ "android.app.ActivityManager#clearApplicationUserData()", "android.app.ActivityManager.AppTask", "android.app.ActivityManager#isLowRamDevice()", "android.app.ActivityManager.RecentTaskInfo" ],
  "variables" : [ {
    "name" : "TAG",
    "type" : "String",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mContext",
    "type" : "Context",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "sSystemReady",
    "type" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "FIRST_START_FATAL_ERROR_CODE",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "LAST_START_FATAL_ERROR_CODE",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "FIRST_START_SUCCESS_CODE",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "LAST_START_SUCCESS_CODE",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "FIRST_START_NON_FATAL_ERROR_CODE",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "LAST_START_NON_FATAL_ERROR_CODE",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "INSTR_FLAG_DISABLE_HIDDEN_API_CHECKS",
    "type" : "int",
    "comment" : "\n     * Disable hidden API checks for the newly started instrumentation.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "INSTR_FLAG_DISABLE_ISOLATED_STORAGE",
    "type" : "int",
    "comment" : "\n     * Grant full access to the external storage for the newly started instrumentation.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "INSTR_FLAG_DISABLE_TEST_API_CHECKS",
    "type" : "int",
    "comment" : "\n     * Disable test API access for the newly started instrumentation.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "INSTR_FLAG_NO_RESTART",
    "type" : "int",
    "comment" : "\n     * Do not restart the target process when starting or finishing instrumentation.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "INSTR_FLAG_ALWAYS_CHECK_SIGNATURE",
    "type" : "int",
    "comment" : "\n     * Force the check that instrumentation and the target package are signed with the same\n     * certificate even if {@link Build#IS_DEBUGGABLE} is {@code true}.\n     * @hide\n     ",
    "links" : [ "android.os.Build#IS_DEBUGGABLE" ]
  }, {
    "name" : "INSTR_FLAG_INSTRUMENT_SDK_SANDBOX",
    "type" : "int",
    "comment" : "\n     * Instrument Sdk Sandbox process that corresponds to the target package.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "INSTR_FLAG_INSTRUMENT_SDK_IN_SANDBOX",
    "type" : "int",
    "comment" : "\n     * Instrument an Sdk Sandbox process corresponding to an Sdk running inside the sandbox.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "mImportanceListeners",
    "type" : "ArrayMap<OnUidImportanceListener, MyUidObserver>",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mFrozenStateChangedCallbacks",
    "type" : "ArrayMap<UidFrozenStateChangedCallback, Executor>",
    "comment" : "\n     * Map of callbacks that have registered for {@link UidFrozenStateChanged} events.\n     * Will be called when a Uid has become frozen or unfrozen.\n     ",
    "links" : [ "UidFrozenStateChanged" ]
  }, {
    "name" : "mFrozenStateChangedCallback",
    "type" : "IUidFrozenStateChangedCallback",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "META_HOME_ALTERNATE",
    "type" : "String",
    "comment" : "\n     * <a href=\"{@docRoot}guide/topics/manifest/meta-data-element.html\">{@code\n     * <meta-data>}</a> name for a 'home' Activity that declares a package that is to be\n     * uninstalled in lieu of the declaring one.  The package named here must be\n     * signed with the same certificate as the one declaring the {@code <meta-data>}.\n     ",
    "links" : [ ]
  }, {
    "name" : "START_VOICE_HIDDEN_SESSION",
    "type" : "int",
    "comment" : "\n     * Result for IActivityManager.startVoiceActivity: active session is currently hidden.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "START_VOICE_NOT_ACTIVE_SESSION",
    "type" : "int",
    "comment" : "\n     * Result for IActivityManager.startVoiceActivity: active session does not match\n     * the requesting token.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "START_NOT_CURRENT_USER_ACTIVITY",
    "type" : "int",
    "comment" : "\n     * Result for IActivityManager.startActivity: trying to start a background user\n     * activity that shouldn't be displayed for all users.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "START_NOT_VOICE_COMPATIBLE",
    "type" : "int",
    "comment" : "\n     * Result for IActivityManager.startActivity: trying to start an activity under voice\n     * control when that activity does not support the VOICE category.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "START_CANCELED",
    "type" : "int",
    "comment" : "\n     * Result for IActivityManager.startActivity: an error where the\n     * start had to be canceled.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "START_NOT_ACTIVITY",
    "type" : "int",
    "comment" : "\n     * Result for IActivityManager.startActivity: an error where the\n     * thing being started is not an activity.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "START_PERMISSION_DENIED",
    "type" : "int",
    "comment" : "\n     * Result for IActivityManager.startActivity: an error where the\n     * caller does not have permission to start the activity.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "START_FORWARD_AND_REQUEST_CONFLICT",
    "type" : "int",
    "comment" : "\n     * Result for IActivityManager.startActivity: an error where the\n     * caller has requested both to forward a result and to receive\n     * a result.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "START_CLASS_NOT_FOUND",
    "type" : "int",
    "comment" : "\n     * Result for IActivityManager.startActivity: an error where the\n     * requested class is not found.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "START_INTENT_NOT_RESOLVED",
    "type" : "int",
    "comment" : "\n     * Result for IActivityManager.startActivity: an error where the\n     * given Intent could not be resolved to an activity.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "START_ASSISTANT_HIDDEN_SESSION",
    "type" : "int",
    "comment" : "\n     * Result for IActivityManager.startAssistantActivity: active session is currently hidden.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "START_ASSISTANT_NOT_ACTIVE_SESSION",
    "type" : "int",
    "comment" : "\n     * Result for IActivityManager.startAssistantActivity: active session does not match\n     * the requesting token.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "START_SUCCESS",
    "type" : "int",
    "comment" : "\n     * Result for IActivityManaqer.startActivity: the activity was started\n     * successfully as normal.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "START_RETURN_INTENT_TO_CALLER",
    "type" : "int",
    "comment" : "\n     * Result for IActivityManaqer.startActivity: the caller asked that the Intent not\n     * be executed if it is the recipient, and that is indeed the case.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "START_TASK_TO_FRONT",
    "type" : "int",
    "comment" : "\n     * Result for IActivityManaqer.startActivity: activity was started or brought forward in an\n     * existing task which was brought to the foreground.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "START_DELIVERED_TO_TOP",
    "type" : "int",
    "comment" : "\n     * Result for IActivityManaqer.startActivity: activity wasn't really started, but\n     * the given Intent was given to the existing top activity.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "START_SWITCHES_CANCELED",
    "type" : "int",
    "comment" : "\n     * Result for IActivityManaqer.startActivity: request was canceled because\n     * app switches are temporarily canceled to ensure the user's last request\n     * (such as pressing home) is performed.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "START_RETURN_LOCK_TASK_MODE_VIOLATION",
    "type" : "int",
    "comment" : "\n     * Result for IActivityManaqer.startActivity: a new activity was attempted to be started\n     * while in Lock Task Mode.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "START_ABORTED",
    "type" : "int",
    "comment" : "\n     * Result for IActivityManaqer.startActivity: a new activity start was aborted. Never returned\n     * externally.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "START_FLAG_ONLY_IF_NEEDED",
    "type" : "int",
    "comment" : "\n     * Flag for IActivityManaqer.startActivity: do special start mode where\n     * a new activity is launched only if it is needed.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "START_FLAG_DEBUG",
    "type" : "int",
    "comment" : "\n     * Flag for IActivityManaqer.startActivity: launch the app for\n     * debugging.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "START_FLAG_TRACK_ALLOCATION",
    "type" : "int",
    "comment" : "\n     * Flag for IActivityManaqer.startActivity: launch the app for\n     * allocation tracking.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "START_FLAG_NATIVE_DEBUGGING",
    "type" : "int",
    "comment" : "\n     * Flag for IActivityManaqer.startActivity: launch the app with\n     * native debugging support.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "START_FLAG_DEBUG_SUSPEND",
    "type" : "int",
    "comment" : "\n     * Flag for IActivityManaqer.startActivity: launch the app for\n     * debugging and suspend threads.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "BROADCAST_SUCCESS",
    "type" : "int",
    "comment" : "\n     * Result for IActivityManaqer.broadcastIntent: success!\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "BROADCAST_STICKY_CANT_HAVE_PERMISSION",
    "type" : "int",
    "comment" : "\n     * Result for IActivityManaqer.broadcastIntent: attempt to broadcast\n     * a sticky intent without appropriate permission.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "BROADCAST_FAILED_USER_STOPPED",
    "type" : "int",
    "comment" : "\n     * Result for IActivityManager.broadcastIntent: trying to send a broadcast\n     * to a stopped user. Fail.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "INTENT_SENDER_UNKNOWN",
    "type" : "int",
    "comment" : "\n     * Type for IActivityManaqer.getIntentSender: this PendingIntent type is unknown.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "INTENT_SENDER_BROADCAST",
    "type" : "int",
    "comment" : "\n     * Type for IActivityManaqer.getIntentSender: this PendingIntent is\n     * for a sendBroadcast operation.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "INTENT_SENDER_ACTIVITY",
    "type" : "int",
    "comment" : "\n     * Type for IActivityManaqer.getIntentSender: this PendingIntent is\n     * for a startActivity operation.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "INTENT_SENDER_ACTIVITY_RESULT",
    "type" : "int",
    "comment" : "\n     * Type for IActivityManaqer.getIntentSender: this PendingIntent is\n     * for an activity result operation.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "INTENT_SENDER_SERVICE",
    "type" : "int",
    "comment" : "\n     * Type for IActivityManaqer.getIntentSender: this PendingIntent is\n     * for a startService operation.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "INTENT_SENDER_FOREGROUND_SERVICE",
    "type" : "int",
    "comment" : "\n     * Type for IActivityManaqer.getIntentSender: this PendingIntent is\n     * for a startForegroundService operation.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "USER_OP_SUCCESS",
    "type" : "int",
    "comment" : " @hide User operation call: success! ",
    "links" : [ ]
  }, {
    "name" : "USER_OP_UNKNOWN_USER",
    "type" : "int",
    "comment" : " @hide User operation call: given user id is not known. ",
    "links" : [ ]
  }, {
    "name" : "USER_OP_IS_CURRENT",
    "type" : "int",
    "comment" : " @hide User operation call: given user id is the current user, can't be stopped. ",
    "links" : [ ]
  }, {
    "name" : "USER_OP_ERROR_IS_SYSTEM",
    "type" : "int",
    "comment" : " @hide User operation call: system user can't be stopped. ",
    "links" : [ ]
  }, {
    "name" : "USER_OP_ERROR_RELATED_USERS_CANNOT_STOP",
    "type" : "int",
    "comment" : " @hide User operation call: one of related users cannot be stopped. ",
    "links" : [ ]
  }, {
    "name" : "PROCESS_STATE_UNKNOWN",
    "type" : "int",
    "comment" : " @hide Not a real process state. ",
    "links" : [ ]
  }, {
    "name" : "PROCESS_STATE_PERSISTENT",
    "type" : "int",
    "comment" : " @hide Process is a persistent system process. ",
    "links" : [ ]
  }, {
    "name" : "PROCESS_STATE_PERSISTENT_UI",
    "type" : "int",
    "comment" : " @hide Process is a persistent system process and is doing UI. ",
    "links" : [ ]
  }, {
    "name" : "PROCESS_STATE_TOP",
    "type" : "int",
    "comment" : " @hide Process is hosting the current top activities.  Note that this covers\n     * all activities that are visible to the user. ",
    "links" : [ ]
  }, {
    "name" : "PROCESS_STATE_BOUND_TOP",
    "type" : "int",
    "comment" : " @hide Process is bound to a TOP app. ",
    "links" : [ ]
  }, {
    "name" : "PROCESS_STATE_FOREGROUND_SERVICE",
    "type" : "int",
    "comment" : " @hide Process is hosting a foreground service. ",
    "links" : [ ]
  }, {
    "name" : "PROCESS_STATE_BOUND_FOREGROUND_SERVICE",
    "type" : "int",
    "comment" : " @hide Process is hosting a foreground service due to a system binding. ",
    "links" : [ ]
  }, {
    "name" : "PROCESS_STATE_IMPORTANT_FOREGROUND",
    "type" : "int",
    "comment" : " @hide Process is important to the user, and something they are aware of. ",
    "links" : [ ]
  }, {
    "name" : "PROCESS_STATE_IMPORTANT_BACKGROUND",
    "type" : "int",
    "comment" : " @hide Process is important to the user, but not something they are aware of. ",
    "links" : [ ]
  }, {
    "name" : "PROCESS_STATE_TRANSIENT_BACKGROUND",
    "type" : "int",
    "comment" : " @hide Process is in the background transient so we will try to keep running. ",
    "links" : [ ]
  }, {
    "name" : "PROCESS_STATE_BACKUP",
    "type" : "int",
    "comment" : " @hide Process is in the background running a backup/restore operation. ",
    "links" : [ ]
  }, {
    "name" : "PROCESS_STATE_SERVICE",
    "type" : "int",
    "comment" : " @hide Process is in the background running a service.  Unlike oom_adj, this level\n     * is used for both the normal running in background state and the executing\n     * operations state. ",
    "links" : [ ]
  }, {
    "name" : "PROCESS_STATE_RECEIVER",
    "type" : "int",
    "comment" : " @hide Process is in the background running a receiver.   Note that from the\n     * perspective of oom_adj, receivers run at a higher foreground level, but for our\n     * prioritization here that is not necessary and putting them below services means\n     * many fewer changes in some process states as they receive broadcasts. ",
    "links" : [ ]
  }, {
    "name" : "PROCESS_STATE_TOP_SLEEPING",
    "type" : "int",
    "comment" : " @hide Same as {@link #PROCESS_STATE_TOP} but while device is sleeping. ",
    "links" : [ "#PROCESS_STATE_TOP" ]
  }, {
    "name" : "PROCESS_STATE_HEAVY_WEIGHT",
    "type" : "int",
    "comment" : " @hide Process is in the background, but it can't restore its state so we want\n     * to try to avoid killing it. ",
    "links" : [ ]
  }, {
    "name" : "PROCESS_STATE_HOME",
    "type" : "int",
    "comment" : " @hide Process is in the background but hosts the home activity. ",
    "links" : [ ]
  }, {
    "name" : "PROCESS_STATE_LAST_ACTIVITY",
    "type" : "int",
    "comment" : " @hide Process is in the background but hosts the last shown activity. ",
    "links" : [ ]
  }, {
    "name" : "PROCESS_STATE_CACHED_ACTIVITY",
    "type" : "int",
    "comment" : " @hide Process is being cached for later use and contains activities. ",
    "links" : [ ]
  }, {
    "name" : "PROCESS_STATE_CACHED_ACTIVITY_CLIENT",
    "type" : "int",
    "comment" : " @hide Process is being cached for later use and is a client of another cached\n     * process that contains activities. ",
    "links" : [ ]
  }, {
    "name" : "PROCESS_STATE_CACHED_RECENT",
    "type" : "int",
    "comment" : " @hide Process is being cached for later use and has an activity that corresponds\n     * to an existing recent task. ",
    "links" : [ ]
  }, {
    "name" : "PROCESS_STATE_CACHED_EMPTY",
    "type" : "int",
    "comment" : " @hide Process is being cached for later use and is empty. ",
    "links" : [ ]
  }, {
    "name" : "PROCESS_STATE_NONEXISTENT",
    "type" : "int",
    "comment" : " @hide Process does not exist. ",
    "links" : [ ]
  }, {
    "name" : "FOREGROUND_SERVICE_API_TYPE_CAMERA",
    "type" : "int",
    "comment" : "\n     * Used to log FGS API events from CAMERA API\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "FOREGROUND_SERVICE_API_TYPE_BLUETOOTH",
    "type" : "int",
    "comment" : "\n     * Used to log FGS API events from BLUETOOTH API, used\n     * with FGS type of CONNECTED_DEVICE\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "FOREGROUND_SERVICE_API_TYPE_LOCATION",
    "type" : "int",
    "comment" : "\n     * Used to log FGS API events from Location API.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "FOREGROUND_SERVICE_API_TYPE_MEDIA_PLAYBACK",
    "type" : "int",
    "comment" : "\n     * Used to log FGS API events from media playback API\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "FOREGROUND_SERVICE_API_TYPE_AUDIO",
    "type" : "int",
    "comment" : "\n     * Used to log FGS API events from Audio API\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "FOREGROUND_SERVICE_API_TYPE_MICROPHONE",
    "type" : "int",
    "comment" : "\n     * Used to log FGS API events from microphone API\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "FOREGROUND_SERVICE_API_TYPE_PHONE_CALL",
    "type" : "int",
    "comment" : "\n     * Used to log FGS API events from phone API\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "FOREGROUND_SERVICE_API_TYPE_USB",
    "type" : "int",
    "comment" : "\n     * Used to log FGS API events from USB API\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "FOREGROUND_SERVICE_API_TYPE_CDM",
    "type" : "int",
    "comment" : "\n     * Used to log FGS API events from CDM API\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "FOREGROUND_SERVICE_API_EVENT_BEGIN",
    "type" : "int",
    "comment" : "\n     * Used to log a start event for an FGS API\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "FOREGROUND_SERVICE_API_EVENT_END",
    "type" : "int",
    "comment" : "\n     * Used to log a stop event for an FGS API\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "PROCESS_CAPABILITY_NONE",
    "type" : "int",
    "comment" : " @hide Process does not have any capability ",
    "links" : [ ]
  }, {
    "name" : "PROCESS_CAPABILITY_FOREGROUND_LOCATION",
    "type" : "int",
    "comment" : " @hide Process can access location while in foreground ",
    "links" : [ ]
  }, {
    "name" : "PROCESS_CAPABILITY_FOREGROUND_CAMERA",
    "type" : "int",
    "comment" : " @hide Process can access camera while in foreground ",
    "links" : [ ]
  }, {
    "name" : "PROCESS_CAPABILITY_FOREGROUND_MICROPHONE",
    "type" : "int",
    "comment" : " @hide Process can access microphone while in foreground ",
    "links" : [ ]
  }, {
    "name" : "PROCESS_CAPABILITY_POWER_RESTRICTED_NETWORK",
    "type" : "int",
    "comment" : " @hide Process can access network despite any power saving restrictions ",
    "links" : [ ]
  }, {
    "name" : "PROCESS_CAPABILITY_BFSL",
    "type" : "int",
    "comment" : "\n     * Flag used to indicate whether an app is allowed to start a foreground service from the\n     * background, decided by the procstates. (\"BFSL\" == \"background foreground service launch\")\n     *\n     * - BFSL has a number of exemptions -- e.g. when an app is power-allowlisted, including\n     *   temp-allowlist -- but this capability is *not* used to represent such exemptions.\n     *   This is set only based on the procstate and the foreground service type.\n     * - Basically, procstates <= BFGS (i.e. BFGS, FGS, BTOP, TOP, ...) are BFSL-allowed,\n     *   and that's how things worked on Android S/T.\n     *   However, Android U added a \"SHORT_SERVICE\" FGS type, which gets the FGS procstate\n     *   *but* can't start another FGS. So now we use this flag to decide whether FGS/BFGS\n     *   procstates are BFSL-allowed. (higher procstates, such as BTOP, will still always be\n     *   BFSL-allowed.)\n     *   We propagate this flag across via service bindings and provider references.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "PROCESS_CAPABILITY_USER_RESTRICTED_NETWORK",
    "type" : "int",
    "comment" : "\n     * @hide\n     * Process can access network at a high enough proc state despite any user restrictions.\n     ",
    "links" : [ ]
  }, {
    "name" : "PROCESS_CAPABILITY_FOREGROUND_AUDIO_CONTROL",
    "type" : "int",
    "comment" : "\n     * @hide\n     * Process can access volume APIs and can request audio focus with GAIN.\n     ",
    "links" : [ ]
  }, {
    "name" : "PROCESS_CAPABILITY_ALL",
    "type" : "int",
    "comment" : "\n     * @hide all capabilities, the ORing of all flags in {@link ProcessCapability}.\n     *\n     * Don't expose it as TestApi -- we may add new capabilities any time, which could\n     * break CTS tests if they relied on it.\n     ",
    "links" : [ "ProcessCapability" ]
  }, {
    "name" : "PROCESS_CAPABILITY_ALL_IMPLICIT",
    "type" : "int",
    "comment" : "\n     * All implicit capabilities. There are capabilities that process automatically have.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "MIN_PROCESS_STATE",
    "type" : "int",
    "comment" : " @hide The lowest process state number ",
    "links" : [ ]
  }, {
    "name" : "MAX_PROCESS_STATE",
    "type" : "int",
    "comment" : " @hide The highest process state number ",
    "links" : [ ]
  }, {
    "name" : "ASSIST_CONTEXT_BASIC",
    "type" : "int",
    "comment" : " @hide requestType for assist context: only basic information. ",
    "links" : [ ]
  }, {
    "name" : "ASSIST_CONTEXT_FULL",
    "type" : "int",
    "comment" : " @hide requestType for assist context: generate full AssistStructure. ",
    "links" : [ ]
  }, {
    "name" : "ASSIST_CONTEXT_AUTOFILL",
    "type" : "int",
    "comment" : " @hide requestType for assist context: generate full AssistStructure for autofill. ",
    "links" : [ ]
  }, {
    "name" : "ASSIST_CONTEXT_CONTENT",
    "type" : "int",
    "comment" : " @hide requestType for assist context: generate AssistContent but not AssistStructure. ",
    "links" : [ ]
  }, {
    "name" : "UID_OBSERVER_PROCSTATE",
    "type" : "int",
    "comment" : " @hide Flag for registerUidObserver: report changes in process state. ",
    "links" : [ ]
  }, {
    "name" : "UID_OBSERVER_GONE",
    "type" : "int",
    "comment" : " @hide Flag for registerUidObserver: report uid gone. ",
    "links" : [ ]
  }, {
    "name" : "UID_OBSERVER_IDLE",
    "type" : "int",
    "comment" : " @hide Flag for registerUidObserver: report uid has become idle. ",
    "links" : [ ]
  }, {
    "name" : "UID_OBSERVER_ACTIVE",
    "type" : "int",
    "comment" : " @hide Flag for registerUidObserver: report uid has become active. ",
    "links" : [ ]
  }, {
    "name" : "UID_OBSERVER_CACHED",
    "type" : "int",
    "comment" : " @hide Flag for registerUidObserver: report uid cached state has changed. ",
    "links" : [ ]
  }, {
    "name" : "UID_OBSERVER_CAPABILITY",
    "type" : "int",
    "comment" : " @hide Flag for registerUidObserver: report uid capability has changed. ",
    "links" : [ ]
  }, {
    "name" : "UID_OBSERVER_PROC_OOM_ADJ",
    "type" : "int",
    "comment" : " @hide Flag for registerUidObserver: report pid oom adj has changed. ",
    "links" : [ ]
  }, {
    "name" : "APP_START_MODE_NORMAL",
    "type" : "int",
    "comment" : " @hide Mode for {@link IActivityManager#isAppStartModeDisabled}: normal free-to-run operation. ",
    "links" : [ "#isAppStartModeDisabled" ]
  }, {
    "name" : "APP_START_MODE_DELAYED",
    "type" : "int",
    "comment" : " @hide Mode for {@link IActivityManager#isAppStartModeDisabled}: delay running until later. ",
    "links" : [ "#isAppStartModeDisabled" ]
  }, {
    "name" : "APP_START_MODE_DELAYED_RIGID",
    "type" : "int",
    "comment" : " @hide Mode for {@link IActivityManager#isAppStartModeDisabled}: delay running until later, with\n     * rigid errors (throwing exception). ",
    "links" : [ "#isAppStartModeDisabled" ]
  }, {
    "name" : "APP_START_MODE_DISABLED",
    "type" : "int",
    "comment" : " @hide Mode for {@link IActivityManager#isAppStartModeDisabled}: disable/cancel pending\n     * launches; this is the mode for ephemeral apps. ",
    "links" : [ "#isAppStartModeDisabled" ]
  }, {
    "name" : "LOCK_TASK_MODE_NONE",
    "type" : "int",
    "comment" : "\n     * Lock task mode is not active.\n     ",
    "links" : [ ]
  }, {
    "name" : "LOCK_TASK_MODE_LOCKED",
    "type" : "int",
    "comment" : "\n     * Full lock task mode is active.\n     ",
    "links" : [ ]
  }, {
    "name" : "LOCK_TASK_MODE_PINNED",
    "type" : "int",
    "comment" : "\n     * App pinning mode is active.\n     ",
    "links" : [ ]
  }, {
    "name" : "mAppTaskThumbnailSize",
    "type" : "Point",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "sCurrentUser$ravenwood",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "COMPAT_MODE_ALWAYS",
    "type" : "int",
    "comment" : "\n     * Screen compatibility mode: the application most always run in\n     * compatibility mode.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "COMPAT_MODE_NEVER",
    "type" : "int",
    "comment" : "\n     * Screen compatibility mode: the application can never run in\n     * compatibility mode.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "COMPAT_MODE_UNKNOWN",
    "type" : "int",
    "comment" : "\n     * Screen compatibility mode: unknown.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "COMPAT_MODE_DISABLED",
    "type" : "int",
    "comment" : "\n     * Screen compatibility mode: the application currently has compatibility\n     * mode disabled.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "COMPAT_MODE_ENABLED",
    "type" : "int",
    "comment" : "\n     * Screen compatibility mode: the application currently has compatibility\n     * mode enabled.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "COMPAT_MODE_TOGGLE",
    "type" : "int",
    "comment" : "\n     * Screen compatibility mode: request to toggle the application's\n     * compatibility mode.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "DEVELOPMENT_FORCE_LOW_RAM",
    "type" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "DROP_CLOSE_SYSTEM_DIALOGS",
    "type" : "long",
    "comment" : "\n     * Intent {@link Intent#ACTION_CLOSE_SYSTEM_DIALOGS} is too powerful to be unrestricted. We\n     * restrict its usage for a few legitimate use-cases only, regardless of targetSdk. For the\n     * other use-cases we drop the intent with a log message.\n     *\n     * Note that this is the lighter version of {@link ActivityManager\n     * #LOCK_DOWN_CLOSE_SYSTEM_DIALOGS} which is not gated on targetSdk in order to eliminate the\n     * abuse vector.\n     *\n     * @hide\n     ",
    "links" : [ "android.content.Intent#ACTION_CLOSE_SYSTEM_DIALOGS", "android.app.ActivityManager#LOCK_DOWN_CLOSE_SYSTEM_DIALOGS" ]
  }, {
    "name" : "LOCK_DOWN_CLOSE_SYSTEM_DIALOGS",
    "type" : "long",
    "comment" : "\n     * Intent {@link Intent#ACTION_CLOSE_SYSTEM_DIALOGS} is too powerful to be unrestricted. So,\n     * apps targeting {@link Build.VERSION_CODES#S} or higher will crash if they try to send such\n     * intent and don't have permission {@code android.permission.BROADCAST_CLOSE_SYSTEM_DIALOGS}.\n     *\n     * Note that this is the more restrict version of {@link ActivityManager\n     * #DROP_CLOSE_SYSTEM_DIALOGS} that expects the app to stop sending aforementioned intent once\n     * it bumps its targetSdk to {@link Build.VERSION_CODES#S} or higher.\n     *\n     * @hide\n     ",
    "links" : [ "Build.VERSION_CODES#S", "android.app.ActivityManager#DROP_CLOSE_SYSTEM_DIALOGS", "android.content.Intent#ACTION_CLOSE_SYSTEM_DIALOGS" ]
  }, {
    "name" : "RESTRICTION_LEVEL_UNKNOWN",
    "type" : "int",
    "comment" : "\n     * Not a valid restriction level.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "RESTRICTION_LEVEL_UNRESTRICTED",
    "type" : "int",
    "comment" : "\n     * No background restrictions at all, this should NEVER be used\n     * for any process other than selected system processes, currently it's reserved.\n     *\n     * <p>In the future, apps in {@link #RESTRICTION_LEVEL_EXEMPTED} would receive permissive\n     * background restrictions to protect the system from buggy behaviors; in other words,\n     * the {@link #RESTRICTION_LEVEL_EXEMPTED} would not be the truly \"unrestricted\" state, while\n     * the {@link #RESTRICTION_LEVEL_UNRESTRICTED} here would be the last resort if there is\n     * a strong reason to grant such a capability to a system app. </p>\n     *\n     * @hide\n     ",
    "links" : [ "#RESTRICTION_LEVEL_EXEMPTED", "#RESTRICTION_LEVEL_UNRESTRICTED" ]
  }, {
    "name" : "RESTRICTION_LEVEL_EXEMPTED",
    "type" : "int",
    "comment" : "\n     * The default background restriction level for the \"unrestricted\" apps set by the user,\n     * where it'll have the {@link android.app.AppOpsManager#OP_RUN_ANY_IN_BACKGROUND} set to\n     * ALLOWED, being added into the device idle allow list; however there will be still certain\n     * restrictions to apps in this level.\n     *\n     * @hide\n     ",
    "links" : [ "android.app.AppOpsManager#OP_RUN_ANY_IN_BACKGROUND" ]
  }, {
    "name" : "RESTRICTION_LEVEL_ADAPTIVE_BUCKET",
    "type" : "int",
    "comment" : "\n     * The default background restriction level for all other apps, they'll be moved between\n     * various standby buckets, including\n     * {@link android.app.usage.UsageStatsManager#STANDBY_BUCKET_ACTIVE},\n     * {@link android.app.usage.UsageStatsManager#STANDBY_BUCKET_WORKING_SET},\n     * {@link android.app.usage.UsageStatsManager#STANDBY_BUCKET_FREQUENT},\n     * {@link android.app.usage.UsageStatsManager#STANDBY_BUCKET_RARE}.\n     *\n     * @hide\n     ",
    "links" : [ "android.app.usage.UsageStatsManager#STANDBY_BUCKET_WORKING_SET", "android.app.usage.UsageStatsManager#STANDBY_BUCKET_FREQUENT", "android.app.usage.UsageStatsManager#STANDBY_BUCKET_ACTIVE", "android.app.usage.UsageStatsManager#STANDBY_BUCKET_RARE" ]
  }, {
    "name" : "RESTRICTION_LEVEL_RESTRICTED_BUCKET",
    "type" : "int",
    "comment" : "\n     * The background restriction level where the apps will be placed in the restricted bucket\n     * {@link android.app.usage.UsageStatsManager#STANDBY_BUCKET_RESTRICTED}.\n     *\n     * @hide\n     ",
    "links" : [ "android.app.usage.UsageStatsManager#STANDBY_BUCKET_RESTRICTED" ]
  }, {
    "name" : "RESTRICTION_LEVEL_BACKGROUND_RESTRICTED",
    "type" : "int",
    "comment" : "\n     * The background restricted level, where apps would get more restrictions,\n     * such as not allowed to launch foreground services besides on TOP.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "RESTRICTION_LEVEL_FORCE_STOPPED",
    "type" : "int",
    "comment" : "\n     * The restricted level where the apps are in a force-stopped state.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "RESTRICTION_LEVEL_USER_LAUNCH_ONLY",
    "type" : "int",
    "comment" : "\n     * The heavily background restricted level, where apps cannot start without an explicit\n     * launch by the user.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "RESTRICTION_LEVEL_CUSTOM",
    "type" : "int",
    "comment" : "\n     * A reserved restriction level that is not well-defined.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "RESTRICTION_LEVEL_MAX",
    "type" : "int",
    "comment" : "\n     * Not a valid restriction level, it defines the maximum numerical value of restriction level.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "RESTRICTION_SUBREASON_MAX_LENGTH",
    "type" : "int",
    "comment" : "\n     * Maximum string length for sub reason for restriction.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "RESTRICTION_REASON_UNKNOWN",
    "type" : "int",
    "comment" : "\n     * Restriction reason unknown - do not use directly.\n     *\n     * For use with noteAppRestrictionEnabled()\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "RESTRICTION_REASON_DEFAULT",
    "type" : "int",
    "comment" : "\n     * Restriction reason to be used when this is normal behavior for the state.\n     *\n     * For use with noteAppRestrictionEnabled()\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "RESTRICTION_REASON_DORMANT",
    "type" : "int",
    "comment" : "\n     * Restriction reason is some kind of timeout that moves the app to a more restricted state.\n     * The threshold should specify how long the app was dormant, in milliseconds.\n     *\n     * For use with noteAppRestrictionEnabled()\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "RESTRICTION_REASON_USAGE",
    "type" : "int",
    "comment" : "\n     * Restriction reason to be used when removing a restriction due to direct or indirect usage\n     * of the app, especially to undo any automatic restrictions.\n     *\n     * For use with noteAppRestrictionEnabled()\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "RESTRICTION_REASON_USER",
    "type" : "int",
    "comment" : "\n     * Restriction reason to be used when the user chooses to manually restrict the app, through\n     * UI or command line interface.\n     *\n     * For use with noteAppRestrictionEnabled()\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "RESTRICTION_REASON_USER_NUDGED",
    "type" : "int",
    "comment" : "\n     * Restriction reason to be used when the user chooses to manually restrict the app on being\n     * prompted by the OS or some anomaly detection algorithm. For example, if the app is causing\n     * high battery drain or affecting system performance and the OS recommends that the user\n     * restrict the app.\n     *\n     * For use with noteAppRestrictionEnabled()\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "RESTRICTION_REASON_SYSTEM_HEALTH",
    "type" : "int",
    "comment" : "\n     * Restriction reason to be used when the OS automatically detects that the app is causing\n     * system health issues such as performance degradation, battery drain, high memory usage, etc.\n     *\n     * For use with noteAppRestrictionEnabled()\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "RESTRICTION_REASON_REMOTE_TRIGGER",
    "type" : "int",
    "comment" : "\n     * Restriction reason to be used when there is a server-side decision made to restrict an app\n     * that is showing widespread problems on user devices, or violating policy in some way.\n     *\n     * For use with noteAppRestrictionEnabled()\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "RESTRICTION_REASON_OTHER",
    "type" : "int",
    "comment" : "\n     * Restriction reason to be used when some other problem requires restricting the app.\n     *\n     * For use with noteAppRestrictionEnabled()\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "RECENT_WITH_EXCLUDED",
    "type" : "int",
    "comment" : "\n     * Flag for use with {@link #getRecentTasks}: return all tasks, even those\n     * that have set their\n     * {@link android.content.Intent#FLAG_ACTIVITY_EXCLUDE_FROM_RECENTS} flag.\n     ",
    "links" : [ "#getRecentTasks", "android.content.Intent#FLAG_ACTIVITY_EXCLUDE_FROM_RECENTS" ]
  }, {
    "name" : "RECENT_IGNORE_UNAVAILABLE",
    "type" : "int",
    "comment" : "\n     * Provides a list that does not contain any\n     * recent tasks that currently are not available to the user.\n     ",
    "links" : [ ]
  }, {
    "name" : "MOVE_TASK_WITH_HOME",
    "type" : "int",
    "comment" : "\n     * Flag for {@link #moveTaskToFront(int, int)}: also move the \"home\"\n     * activity along with the task, so it is positioned immediately behind\n     * the task.\n     ",
    "links" : [ "#moveTaskToFront(int" ]
  }, {
    "name" : "MOVE_TASK_NO_USER_ACTION",
    "type" : "int",
    "comment" : "\n     * Flag for {@link #moveTaskToFront(int, int)}: don't count this as a\n     * user-instigated action, so the current activity will not receive a\n     * hint that the user is leaving.\n     ",
    "links" : [ "#moveTaskToFront(int" ]
  }, {
    "name" : "mAppStartInfoCallbacks",
    "type" : "ArrayList<AppStartInfoCallbackWrapper>",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mAppStartInfoCompleteListener",
    "type" : "IApplicationStartInfoCompleteListener",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "STOP_USER_ON_SWITCH_DEFAULT",
    "type" : "int",
    "comment" : "\n     * Uses the value defined by the platform.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "STOP_USER_ON_SWITCH_TRUE",
    "type" : "int",
    "comment" : "\n     * Overrides value defined by the platform and stop user on switch.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "STOP_USER_ON_SWITCH_FALSE",
    "type" : "int",
    "comment" : "\n     * Overrides value defined by the platform and don't stop user on switch.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "FLAG_OR_STOPPED",
    "type" : "int",
    "comment" : " {@hide} ",
    "links" : [ ]
  }, {
    "name" : "FLAG_AND_LOCKED",
    "type" : "int",
    "comment" : " {@hide} ",
    "links" : [ ]
  }, {
    "name" : "FLAG_AND_UNLOCKED",
    "type" : "int",
    "comment" : " {@hide} ",
    "links" : [ ]
  }, {
    "name" : "FLAG_AND_UNLOCKING_OR_UNLOCKED",
    "type" : "int",
    "comment" : " {@hide} ",
    "links" : [ ]
  }, {
    "name" : "IActivityManagerSingleton",
    "type" : "Singleton<IActivityManager>",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "ACTION_REPORT_HEAP_LIMIT",
    "type" : "String",
    "comment" : "\n     * Action an app can implement to handle reports from {@link #setWatchHeapLimit(long)}.\n     * If your package has an activity handling this action, it will be launched with the\n     * heap data provided to it the same way as {@link Intent#ACTION_SEND}.  Note that to\n     * match, the activity must support this action and a MIME type of \"*&#47;*\".\n     ",
    "links" : [ "android.content.Intent#ACTION_SEND", "#setWatchHeapLimit(long)" ]
  } ],
  "methods" : [ {
    "name" : "public void registerUidFrozenStateChangedCallback(@NonNull Executor executor, @NonNull UidFrozenStateChangedCallback callback)",
    "returnType" : "void",
    "comment" : "\n     * Register a {@link UidFrozenStateChangedCallback} object to receive notification\n     * when a UID is frozen or unfrozen. Will throw an exception if the same\n     * callback object is registered more than once.\n     *\n     * @param executor The executor that the callback will be run from.\n     * @param callback The callback to be registered. Callbacks for previous frozen/unfrozen\n     *                 UID changes will not be delivered. Only changes in state from the point of\n     *                 registration onward will be reported.\n     * @throws IllegalStateException if the {@code callback} is already registered.\n     *\n     * @hide\n     ",
    "links" : [ "UidFrozenStateChangedCallback" ]
  }, {
    "name" : "public void unregisterUidFrozenStateChangedCallback(@NonNull UidFrozenStateChangedCallback callback)",
    "returnType" : "void",
    "comment" : "\n     * Unregister a {@link UidFrozenStateChangedCallback} callback.\n     * @param callback The callback to be unregistered.\n     *\n     * @hide\n     ",
    "links" : [ "UidFrozenStateChangedCallback" ]
  }, {
    "name" : "public int[] getUidFrozenState(@NonNull int[] uids)",
    "returnType" : "int[]",
    "comment" : "\n     * Query the frozen state of a list of UIDs.\n     *\n     * @param uids the array of UIDs which the client would like to know the frozen state of.\n     * @return An array containing the frozen state for each requested UID, by index. Will be set\n     *               to {@link UidFrozenStateChangedCallback#UID_FROZEN_STATE_FROZEN}\n     *               if the UID is frozen. If the UID is not frozen or not found,\n     *               {@link UidFrozenStateChangedCallback#UID_FROZEN_STATE_UNFROZEN}\n     *               will be set.\n     *\n     * @hide\n     ",
    "links" : [ "#UID_FROZEN_STATE_UNFROZEN", "#UID_FROZEN_STATE_FROZEN" ]
  }, {
    "name" : "public static void printCapabilitiesSummary(PrintWriter pw, @ProcessCapability int caps)",
    "returnType" : "void",
    "comment" : "\n     * Print capability bits in human-readable form.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public static void printCapabilitiesSummary(StringBuilder sb, @ProcessCapability int caps)",
    "returnType" : "void",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "public static void printCapabilitiesFull(PrintWriter pw, @ProcessCapability int caps)",
    "returnType" : "void",
    "comment" : "\n     * Print capability bits in human-readable form.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public static String getCapabilitiesSummary(@ProcessCapability int caps)",
    "returnType" : "String",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "public static final int processStateAmToProto(int amInt)",
    "returnType" : "int",
    "comment" : "\n     * Maps ActivityManager.PROCESS_STATE_ values to enums.proto ProcessStateEnum value.\n     *\n     * @param amInt a process state of the form ActivityManager.PROCESS_STATE_\n     * @return the value of the corresponding enums.proto ProcessStateEnum value.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public static final boolean isProcStateBackground(int procState)",
    "returnType" : "boolean",
    "comment" : " @hide Should this process state be considered a background state? ",
    "links" : [ ]
  }, {
    "name" : "public static final boolean isProcStateCached(int procState)",
    "returnType" : "boolean",
    "comment" : " @hide Should this process state be considered in the cache? ",
    "links" : [ ]
  }, {
    "name" : "public static boolean isForegroundService(int procState)",
    "returnType" : "boolean",
    "comment" : " @hide Is this a foreground service type? ",
    "links" : [ ]
  }, {
    "name" : "public static void init$ravenwood(int currentUser)",
    "returnType" : "void",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "public static void reset$ravenwood()",
    "returnType" : "void",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "public static final boolean isStartResultSuccessful(int result)",
    "returnType" : "boolean",
    "comment" : "\n     * Returns whether the launch was successful.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public static final boolean isStartResultFatalError(int result)",
    "returnType" : "boolean",
    "comment" : "\n     * Returns whether the launch result was a fatal error.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public static String restrictionLevelToName(@RestrictionLevel int level)",
    "returnType" : "String",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "public int getFrontActivityScreenCompatMode()",
    "returnType" : "int",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "public void setFrontActivityScreenCompatMode(int mode)",
    "returnType" : "void",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "public int getPackageScreenCompatMode(String packageName)",
    "returnType" : "int",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "public void setPackageScreenCompatMode(String packageName, int mode)",
    "returnType" : "void",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "public boolean getPackageAskScreenCompat(String packageName)",
    "returnType" : "boolean",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "public void setPackageAskScreenCompat(String packageName, boolean ask)",
    "returnType" : "void",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "public int getMemoryClass()",
    "returnType" : "int",
    "comment" : "\n     * Return the approximate per-application memory class of the current\n     * device.  This gives you an idea of how hard a memory limit you should\n     * impose on your application to let the overall system work best.  The\n     * returned value is in megabytes; the baseline Android memory class is\n     * 16 (which happens to be the Java heap limit of those devices); some\n     * devices with more memory may return 24 or even higher numbers.\n     ",
    "links" : [ ]
  }, {
    "name" : "public static int staticGetMemoryClass()",
    "returnType" : "int",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "public int getLargeMemoryClass()",
    "returnType" : "int",
    "comment" : "\n     * Return the approximate per-application memory class of the current\n     * device when an application is running with a large heap.  This is the\n     * space available for memory-intensive applications; most applications\n     * should not need this amount of memory, and should instead stay with the\n     * {@link #getMemoryClass()} limit.  The returned value is in megabytes.\n     * This may be the same size as {@link #getMemoryClass()} on memory\n     * constrained devices, or it may be significantly larger on devices with\n     * a large amount of available RAM.\n     *\n     * <p>This is the size of the application's Dalvik heap if it has\n     * specified <code>android:largeHeap=\"true\"</code> in its manifest.\n     ",
    "links" : [ "#getMemoryClass()" ]
  }, {
    "name" : "public static int staticGetLargeMemoryClass()",
    "returnType" : "int",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "public boolean isLowRamDevice()",
    "returnType" : "boolean",
    "comment" : "\n     * Returns true if this is a low-RAM device.  Exactly whether a device is low-RAM\n     * is ultimately up to the device configuration, but currently it generally means\n     * something with 1GB or less of RAM.  This is mostly intended to be used by apps\n     * to determine whether they should turn off certain features that require more RAM.\n     ",
    "links" : [ ]
  }, {
    "name" : "public static boolean isLowRamDeviceStatic()",
    "returnType" : "boolean",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "public static boolean isSmallBatteryDevice()",
    "returnType" : "boolean",
    "comment" : "\n     * Returns true if this is a small battery device. Exactly whether a device is considered to be\n     * small battery is ultimately up to the device configuration, but currently it generally means\n     * something in the class of a device with 1000 mAh or less. This is mostly intended to be used\n     * to determine whether certain features should be altered to account for a drastically smaller\n     * battery.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public static boolean isHighEndGfx()",
    "returnType" : "boolean",
    "comment" : "\n     * Used by persistent processes to determine if they are running on a\n     * higher-end device so should be okay using hardware drawing acceleration\n     * (which tends to consume a lot more RAM).\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public long getTotalRam()",
    "returnType" : "long",
    "comment" : "\n     * Return the total number of bytes of RAM this device has.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public static int getMaxRecentTasksStatic()",
    "returnType" : "int",
    "comment" : "\n     * TODO(b/80414790): Remove once no longer on hiddenapi-light-greylist.txt\n     * @hide\n     * @deprecated Use {@link ActivityTaskManager#getMaxRecentTasksStatic()}\n     ",
    "links" : [ "android.app.ActivityTaskManager#getMaxRecentTasksStatic()" ]
  }, {
    "name" : "public List<RecentTaskInfo> getRecentTasks(int maxNum, int flags) throws SecurityException",
    "returnType" : "List<RecentTaskInfo>",
    "comment" : "\n     * <p></p>Return a list of the tasks that the user has recently launched, with\n     * the most recent being first and older ones after in order.\n     *\n     * <p><b>Note: this method is only intended for debugging and presenting\n     * task management user interfaces</b>.  This should never be used for\n     * core logic in an application, such as deciding between different\n     * behaviors based on the information found here.  Such uses are\n     * <em>not</em> supported, and will likely break in the future.  For\n     * example, if multiple applications can be actively running at the\n     * same time, assumptions made about the meaning of the data here for\n     * purposes of control flow will be incorrect.</p>\n     *\n     * @deprecated As of {@link android.os.Build.VERSION_CODES#LOLLIPOP}, this method is\n     * no longer available to third party applications: the introduction of\n     * document-centric recents means\n     * it can leak personal information to the caller.  For backwards compatibility,\n     * it will still return a small subset of its data: at least the caller's\n     * own tasks (though see {@link #getAppTasks()} for the correct supported\n     * way to retrieve that information), and possibly some other tasks\n     * such as home that are known to not be sensitive.\n     *\n     * @param maxNum The maximum number of entries to return in the list.  The\n     * actual number returned may be smaller, depending on how many tasks the\n     * user has started and the maximum number the system can remember.\n     * @param flags Information about what to return.  May be any combination\n     * of {@link #RECENT_WITH_EXCLUDED} and {@link #RECENT_IGNORE_UNAVAILABLE}.\n     *\n     * @return Returns a list of RecentTaskInfo records describing each of\n     * the recent tasks.\n     ",
    "links" : [ "#getAppTasks()", "android.os.Build.VERSION_CODES#LOLLIPOP", "#RECENT_IGNORE_UNAVAILABLE", "#RECENT_WITH_EXCLUDED" ]
  }, {
    "name" : "public List<ActivityManager.AppTask> getAppTasks()",
    "returnType" : "List<ActivityManager.AppTask>",
    "comment" : "\n     * Get the list of tasks associated with the calling application.\n     *\n     * @return The list of tasks associated with the application making this call.\n     * @throws SecurityException\n     ",
    "links" : [ ]
  }, {
    "name" : "public Size getAppTaskThumbnailSize()",
    "returnType" : "Size",
    "comment" : "\n     * Return the current design dimensions for {@link AppTask} thumbnails, for use\n     * with {@link #addAppTask}.\n     ",
    "links" : [ "AppTask", "#addAppTask" ]
  }, {
    "name" : "private void ensureAppTaskThumbnailSizeLocked()",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public int addAppTask(@NonNull Activity activity, @NonNull Intent intent, @Nullable TaskDescription description, @NonNull Bitmap thumbnail)",
    "returnType" : "int",
    "comment" : "\n     * Add a new {@link AppTask} for the calling application.  This will create a new\n     * recents entry that is added to the <b>end</b> of all existing recents.\n     *\n     * @param activity The activity that is adding the entry.   This is used to help determine\n     * the context that the new recents entry will be in.\n     * @param intent The Intent that describes the recents entry.  This is the same Intent that\n     * you would have used to launch the activity for it.  In generally you will want to set\n     * both {@link Intent#FLAG_ACTIVITY_NEW_DOCUMENT} and\n     * {@link Intent#FLAG_ACTIVITY_RETAIN_IN_RECENTS}; the latter is required since this recents\n     * entry will exist without an activity, so it doesn't make sense to not retain it when\n     * its activity disappears.  The given Intent here also must have an explicit ComponentName\n     * set on it.\n     * @param description Optional additional description information.\n     * @param thumbnail Thumbnail to use for the recents entry.  Should be the size given by\n     * {@link #getAppTaskThumbnailSize()}.  If the bitmap is not that exact size, it will be\n     * recreated in your process, probably in a way you don't like, before the recents entry\n     * is added.\n     *\n     * @return Returns the task id of the newly added app task, or -1 if the add failed.  The\n     * most likely cause of failure is that there is no more room for more tasks for your app.\n     ",
    "links" : [ "AppTask", "android.content.Intent#FLAG_ACTIVITY_NEW_DOCUMENT", "android.content.Intent#FLAG_ACTIVITY_RETAIN_IN_RECENTS", "#getAppTaskThumbnailSize()" ]
  }, {
    "name" : "public List<RunningTaskInfo> getRunningTasks(int maxNum) throws SecurityException",
    "returnType" : "List<RunningTaskInfo>",
    "comment" : "\n     * Return a list of the tasks that are currently running, with\n     * the most recent being first and older ones after in order.  Note that\n     * \"running\" does not mean any of the task's code is currently loaded or\n     * activity -- the task may have been frozen by the system, so that it\n     * can be restarted in its previous state when next brought to the\n     * foreground.\n     *\n     * <p><b>Note: this method is only intended for debugging and presenting\n     * task management user interfaces</b>.  This should never be used for\n     * core logic in an application, such as deciding between different\n     * behaviors based on the information found here.  Such uses are\n     * <em>not</em> supported, and will likely break in the future.  For\n     * example, if multiple applications can be actively running at the\n     * same time, assumptions made about the meaning of the data here for\n     * purposes of control flow will be incorrect.</p>\n     *\n     * @deprecated As of {@link android.os.Build.VERSION_CODES#LOLLIPOP}, this method\n     * is no longer available to third party\n     * applications: the introduction of document-centric recents means\n     * it can leak person information to the caller.  For backwards compatibility,\n     * it will still return a small subset of its data: at least the caller's\n     * own tasks, and possibly some other tasks\n     * such as home that are known to not be sensitive.\n     *\n     * @param maxNum The maximum number of entries to return in the list.  The\n     * actual number returned may be smaller, depending on how many tasks the\n     * user has started.\n     *\n     * @return Returns a list of RunningTaskInfo records describing each of\n     * the running tasks.\n     ",
    "links" : [ "android.os.Build.VERSION_CODES#LOLLIPOP" ]
  }, {
    "name" : "public void moveTaskToFront(int taskId, @MoveTaskFlags int flags)",
    "returnType" : "void",
    "comment" : "\n     * Equivalent to calling {@link #moveTaskToFront(int, int, Bundle)}\n     * with a null options argument.\n     *\n     * @param taskId The identifier of the task to be moved, as found in\n     * {@link RunningTaskInfo} or {@link RecentTaskInfo}.\n     * @param flags Additional operational flags.\n     ",
    "links" : [ "RecentTaskInfo", "#moveTaskToFront(int", "RunningTaskInfo" ]
  }, {
    "name" : "public void moveTaskToFront(int taskId, @MoveTaskFlags int flags, Bundle options)",
    "returnType" : "void",
    "comment" : "\n     * Ask that the task associated with a given task ID be moved to the\n     * front of the stack, so it is now visible to the user.\n     *\n     * @param taskId The identifier of the task to be moved, as found in\n     * {@link RunningTaskInfo} or {@link RecentTaskInfo}.\n     * @param flags Additional operational flags.\n     * @param options Additional options for the operation, either null or\n     * as per {@link Context#startActivity(Intent, android.os.Bundle)\n     * Context.startActivity(Intent, Bundle)}.\n     ",
    "links" : [ "RecentTaskInfo", "RunningTaskInfo", "android.content.Context#startActivity(Intent" ]
  }, {
    "name" : "public boolean isActivityStartAllowedOnDisplay(@NonNull Context context, int displayId, @NonNull Intent intent)",
    "returnType" : "boolean",
    "comment" : "\n     * Check if the context is allowed to start an activity on specified display. Some launch\n     * restrictions may apply to secondary displays that are private, virtual, or owned by the\n     * system, in which case an activity start may throw a {@link SecurityException}. Call this\n     * method prior to starting an activity on a secondary display to check if the current context\n     * has access to it.\n     *\n     * @see ActivityOptions#setLaunchDisplayId(int)\n     * @see android.view.Display#FLAG_PRIVATE\n     *\n     * @param context Source context, from which an activity will be started.\n     * @param displayId Target display id.\n     * @param intent Intent used to launch an activity.\n     * @return {@code true} if a call to start an activity on the target display is allowed for the\n     * provided context and no {@link SecurityException} will be thrown, {@code false} otherwise.\n     ",
    "links" : [ "SecurityException" ]
  }, {
    "name" : "public List<RunningServiceInfo> getRunningServices(int maxNum) throws SecurityException",
    "returnType" : "List<RunningServiceInfo>",
    "comment" : "\n     * Return a list of the services that are currently running.\n     *\n     * <p><b>Note: this method is only intended for debugging or implementing\n     * service management type user interfaces.</b></p>\n     *\n     * @deprecated As of {@link android.os.Build.VERSION_CODES#O}, this method\n     * is no longer available to third party applications.  For backwards compatibility,\n     * it will still return the caller's own services.\n     *\n     * @param maxNum The maximum number of entries to return in the list.  The\n     * actual number returned may be smaller, depending on how many services\n     * are running.\n     *\n     * @return Returns a list of RunningServiceInfo records describing each of\n     * the running tasks.\n     ",
    "links" : [ "android.os.Build.VERSION_CODES#O" ]
  }, {
    "name" : "public PendingIntent getRunningServiceControlPanel(ComponentName service) throws SecurityException",
    "returnType" : "PendingIntent",
    "comment" : "\n     * Returns a PendingIntent you can start to show a control panel for the\n     * given running service.  If the service does not have a control panel,\n     * null is returned.\n     ",
    "links" : [ ]
  }, {
    "name" : "public void getMemoryInfo(MemoryInfo outInfo)",
    "returnType" : "void",
    "comment" : "\n     * Return general information about the memory state of the system.  This\n     * can be used to help decide how to manage your own memory, though note\n     * that polling is not recommended and\n     * {@link android.content.ComponentCallbacks2#onTrimMemory(int)\n     * ComponentCallbacks2.onTrimMemory(int)} is the preferred way to do this.\n     * Also see {@link #getMyMemoryState} for how to retrieve the current trim\n     * level of your process as needed, which gives a better hint for how to\n     * manage its memory.\n     ",
    "links" : [ "android.content.ComponentCallbacks2#onTrimMemory(int)", "#getMyMemoryState" ]
  }, {
    "name" : "public boolean clearApplicationUserData(String packageName, IPackageDataObserver observer)",
    "returnType" : "boolean",
    "comment" : "\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean clearApplicationUserData()",
    "returnType" : "boolean",
    "comment" : "\n     * Permits an application to erase its own data from disk.  This is equivalent to\n     * the user choosing to clear the app's data from within the device settings UI.  It\n     * erases all dynamic data associated with the app -- its private data and data in its\n     * private area on external storage -- but does not remove the installed application\n     * itself, nor any OBB files. It also revokes all runtime permissions that the app has acquired,\n     * clears all notifications and removes all Uri grants related to this application.\n     *\n     * @return {@code true} if the application successfully requested that the application's\n     *     data be erased; {@code false} otherwise.\n     ",
    "links" : [ ]
  }, {
    "name" : "public ParceledListSlice<GrantedUriPermission> getGrantedUriPermissions(@Nullable String packageName)",
    "returnType" : "ParceledListSlice<GrantedUriPermission>",
    "comment" : "\n     * Permits an application to get the persistent URI permissions granted to another.\n     *\n     * <p>Typically called by Settings or DocumentsUI, requires\n     * {@code GET_APP_GRANTED_URI_PERMISSIONS}.\n     *\n     * @param packageName application to look for the granted permissions, or {@code null} to get\n     * granted permissions for all applications\n     * @return list of granted URI permissions\n     *\n     * @hide\n     * @deprecated use {@link UriGrantsManager#getGrantedUriPermissions(String)} instead.\n     ",
    "links" : [ "android.app.UriGrantsManager#getGrantedUriPermissions(String)" ]
  }, {
    "name" : "public void clearGrantedUriPermissions(String packageName)",
    "returnType" : "void",
    "comment" : "\n     * Permits an application to clear the persistent URI permissions granted to another.\n     *\n     * <p>Typically called by Settings, requires {@code CLEAR_APP_GRANTED_URI_PERMISSIONS}.\n     *\n     * @param packageName application to clear its granted permissions\n     *\n     * @hide\n     * @deprecated use {@link UriGrantsManager#clearGrantedUriPermissions(String)} instead.\n     ",
    "links" : [ "android.app.UriGrantsManager#clearGrantedUriPermissions(String)" ]
  }, {
    "name" : "public List<ProcessErrorStateInfo> getProcessesInErrorState()",
    "returnType" : "List<ProcessErrorStateInfo>",
    "comment" : "\n     * Returns a list of any processes that are currently in an error condition.  The result\n     * will be null if all processes are running properly at this time.\n     *\n     * <p>As of {@link android.os.Build.VERSION_CODES#TIRAMISU Android TIRAMISU}, for regular apps\n     * this method will only return {@link ProcessErrorStateInfo} records for the processes running\n     * as the caller's uid, unless the caller has the permission\n     * {@link android.Manifest.permission#DUMP}.\n     * </p>\n     *\n     * @return Returns a list of {@link ProcessErrorStateInfo} records, or null if there are no\n     * current error conditions (it will not return an empty list).  This list ordering is not\n     * specified.\n     ",
    "links" : [ "android.os.Build.VERSION_CODES#TIRAMISU", "ProcessErrorStateInfo", "android.Manifest.permission#DUMP" ]
  }, {
    "name" : "public List<ApplicationInfo> getRunningExternalApplications()",
    "returnType" : "List<ApplicationInfo>",
    "comment" : "\n     * Returns a list of application processes installed on external media\n     * that are running on the device.\n     *\n     * <p><b>Note: this method is only intended for debugging or building\n     * a user-facing process management UI.</b></p>\n     *\n     * @return Returns a list of ApplicationInfo records, or null if none\n     * This list ordering is not specified.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean isBackgroundRestricted()",
    "returnType" : "boolean",
    "comment" : "\n     * Query whether the user has enabled background restrictions for this app.\n     *\n     * <p> The user may chose to do this, if they see that an app is consuming an unreasonable\n     * amount of battery while in the background. </p>\n     *\n     * <p> If true, any work that the app tries to do will be aggressively restricted while it is in\n     * the background. At a minimum, jobs and alarms will not execute and foreground services\n     * cannot be started unless an app activity is in the foreground. </p>\n     *\n     * <p><b> Note that these restrictions stay in effect even when the device is charging.</b></p>\n     *\n     * @return true if user has enforced background restrictions for this app, false otherwise.\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean setProcessMemoryTrimLevel(String process, int userId, int level)",
    "returnType" : "boolean",
    "comment" : "\n     * Sets the memory trim mode for a process and schedules a memory trim operation.\n     *\n     * <p><b>Note: this method is only intended for testing framework.</b></p>\n     *\n     * @return Returns true if successful.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public List<RunningAppProcessInfo> getRunningAppProcesses()",
    "returnType" : "List<RunningAppProcessInfo>",
    "comment" : "\n     * Returns a list of application processes that are running on the device.\n     *\n     * <p><b>Note: this method is only intended for debugging or building\n     * a user-facing process management UI.</b></p>\n     *\n     * @return Returns a list of RunningAppProcessInfo records, or null if there are no\n     * running processes (it will not return an empty list).  This list ordering is not\n     * specified.\n     ",
    "links" : [ ]
  }, {
    "name" : "public List<ApplicationStartInfo> getHistoricalProcessStartReasons(@IntRange(from = 0) int maxNum)",
    "returnType" : "List<ApplicationStartInfo>",
    "comment" : "\n     * Return a list of {@link ApplicationStartInfo} records containing the information about the\n     * most recent app startups.\n     *\n     * <p class=\"note\"> Note: System stores this historical information in a ring buffer and only\n     * the most recent records will be returned. </p>\n     *\n     * @param maxNum      The maximum number of results to be returned; a value of 0\n     *                    means to ignore this parameter and return all matching records. If fewer\n     *                    records exist, all existing records will be returned.\n     *\n     * @return a list of {@link ApplicationStartInfo} records matching the criteria, sorted in\n     *         the order from most recent to least recent.\n     ",
    "links" : [ "android.app.ApplicationStartInfo" ]
  }, {
    "name" : "public List<ApplicationStartInfo> getExternalHistoricalProcessStartReasons(@NonNull String packageName, @IntRange(from = 0) int maxNum)",
    "returnType" : "List<ApplicationStartInfo>",
    "comment" : "\n     * Return a list of {@link ApplicationStartInfo} records containing the information about the\n     * most recent app startups.\n     *\n     * <p class=\"note\"> Note: System stores this historical information in a ring buffer and only\n     * the most recent records will be returned. </p>\n     *\n     * @param packageName Package name for which app startups to receive.\n     * @param maxNum      The maximum number of results to be returned; a value of 0\n     *                    means to ignore this parameter and return all matching records. If fewer\n     *                    records exist, all existing records will be returned.\n     *\n     * @return a list of {@link ApplicationStartInfo} records matching the criteria, sorted in\n     *         the order from most recent to least recent.\n     *\n     * @hide\n     ",
    "links" : [ "android.app.ApplicationStartInfo" ]
  }, {
    "name" : "public void addApplicationStartInfoCompletionListener(@NonNull final Executor executor, @NonNull final Consumer<ApplicationStartInfo> listener)",
    "returnType" : "void",
    "comment" : "\n     * Adds a callback to be notified when the {@link ApplicationStartInfo} records of this startup\n     * are complete.\n     *\n     * <p class=\"note\"> Note: callback will be removed automatically after being triggered.</p>\n     *\n     * <p class=\"note\"> Note: callback will not wait for {@link Activity#reportFullyDrawn} to occur.\n     * Timestamp for fully drawn may be added after callback occurs. Set callback after invoking\n     * {@link Activity#reportFullyDrawn} if timestamp for fully drawn is required.</p>\n     *\n     * <p class=\"note\"> Note: if start records have already been retrieved, the callback will be\n     * invoked immediately on the specified executor with the previously resolved AppStartInfo.</p>\n     *\n     * <p class=\"note\"> Note: callback is asynchronous and should be made from a background thread.\n     * </p>\n     *\n     * @param executor    The executor on which the listener should be called.\n     * @param listener    Callback to be called when collection of {@link ApplicationStartInfo} is\n     *                    complete. Will replace existing listener if one is already attached.\n     *\n     * @throws IllegalArgumentException if executor or listener are null.\n     ",
    "links" : [ "android.app.ApplicationStartInfo", "android.app.Activity#reportFullyDrawn" ]
  }, {
    "name" : "public void removeApplicationStartInfoCompletionListener(@NonNull final Consumer<ApplicationStartInfo> listener)",
    "returnType" : "void",
    "comment" : "\n     * Removes the provided callback set by {@link #addApplicationStartInfoCompletionListener}.\n     ",
    "links" : [ "#addApplicationStartInfoCompletionListener" ]
  }, {
    "name" : "public void addStartInfoTimestamp(@IntRange(from = ApplicationStartInfo.START_TIMESTAMP_RESERVED_RANGE_DEVELOPER_START, to = ApplicationStartInfo.START_TIMESTAMP_RESERVED_RANGE_DEVELOPER) int key, long timestampNs)",
    "returnType" : "void",
    "comment" : "\n     * Adds an optional developer supplied timestamp to the calling apps most recent\n     * {@link ApplicationStartInfo}. This is in addition to system recorded timestamps.\n     *\n     * <p class=\"note\"> Note: timestamps added after {@link Activity#reportFullyDrawn} is called\n     * will be discarded.</p>\n     *\n     * <p class=\"note\"> Note: will overwrite existing timestamp if called with same key.</p>\n     *\n     * @param key         Unique key for timestamp. Must be greater than\n     *                    {@link ApplicationStartInfo#START_TIMESTAMP_RESERVED_RANGE_SYSTEM} and\n     *                    less than or equal to\n     *                    {@link ApplicationStartInfo#START_TIMESTAMP_RESERVED_RANGE_DEVELOPER}.\n     *                    Will thow {@link java.lang.IllegalArgumentException} if not in range.\n     * @param timestampNs Clock monotonic time in nanoseconds of event to be recorded.\n     ",
    "links" : [ "android.app.ApplicationStartInfo", "android.app.ApplicationStartInfo#START_TIMESTAMP_RESERVED_RANGE_DEVELOPER", "android.app.ApplicationStartInfo#START_TIMESTAMP_RESERVED_RANGE_SYSTEM", "android.app.Activity#reportFullyDrawn", "java.lang.IllegalArgumentException" ]
  }, {
    "name" : "public List<ApplicationExitInfo> getHistoricalProcessExitReasons(@Nullable String packageName, @IntRange(from = 0) int pid, @IntRange(from = 0) int maxNum)",
    "returnType" : "List<ApplicationExitInfo>",
    "comment" : "\n     * Return a list of {@link ApplicationExitInfo} records containing the reasons for the most\n     * recent app deaths.\n     *\n     * <p class=\"note\"> Note: System stores this historical information in a ring buffer and only\n     * the most recent records will be returned. </p>\n     *\n     * <p class=\"note\"> Note: In the case that this application was bound to an external service\n     * with flag {@link android.content.Context#BIND_EXTERNAL_SERVICE}, the process of that external\n     * service will be included in this package's exit info. </p>\n     *\n     * @param packageName Optional, a null value means match all packages belonging to the\n     *                    caller's UID. If this package belongs to another UID, you must hold\n     *                    {@link android.Manifest.permission#DUMP} in order to retrieve it.\n     * @param pid         A process ID that used to belong to this package but died later; a value\n     *                    of 0 means to ignore this parameter and return all matching records.\n     * @param maxNum      The maximum number of results to be returned; a value of 0\n     *                    means to ignore this parameter and return all matching records\n     *\n     * @return a list of {@link ApplicationExitInfo} records matching the criteria, sorted in\n     *         the order from most recent to least recent.\n     ",
    "links" : [ "android.app.ApplicationExitInfo", "android.Manifest.permission#DUMP", "android.content.Context#BIND_EXTERNAL_SERVICE" ]
  }, {
    "name" : "public void setProcessStateSummary(@Nullable byte[] state)",
    "returnType" : "void",
    "comment" : "\n     * Set custom state data for this process. It will be included in the record of\n     * {@link ApplicationExitInfo} on the death of the current calling process; the new process\n     * of the app can retrieve this state data by calling\n     * {@link android.app.ApplicationExitInfo#getProcessStateSummary()\n     * ApplicationExitInfo.getProcessStateSummary()} on the record returned by\n     * {@link #getHistoricalProcessExitReasons}.\n     *\n     * <p> This would be useful for the calling app to save its stateful data: if it's\n     * killed later for any reason, the new process of the app can know what the\n     * previous process of the app was doing. For instance, you could use this to encode\n     * the current level in a game, or a set of features/experiments that were enabled. Later you\n     * could analyze under what circumstances the app tends to crash or use too much memory.\n     * However, it's not suggested to rely on this to restore the applications previous UI state\n     * or so, it's only meant for analyzing application healthy status.</p>\n     *\n     * <p> System might decide to throttle the calls to this API; so call this API in a reasonable\n     * manner, excessive calls to this API could result a {@link java.lang.RuntimeException}.\n     * </p>\n     *\n     * @param state The state data. To be advised, <b>DO NOT</b> include sensitive information/data\n     * (PII, SPII, or other sensitive user data) here. Maximum length is 128 bytes.\n     ",
    "links" : [ "android.app.ApplicationExitInfo", "android.app.ApplicationExitInfo#getProcessStateSummary()", "#getHistoricalProcessExitReasons", "java.lang.RuntimeException" ]
  }, {
    "name" : "public static boolean isLowMemoryKillReportSupported()",
    "returnType" : "boolean",
    "comment" : "\n     * @return Whether or not the low memory kill will be reported in\n     * {@link #getHistoricalProcessExitReasons}.\n     *\n     * @see ApplicationExitInfo#REASON_LOW_MEMORY\n     ",
    "links" : [ "#getHistoricalProcessExitReasons" ]
  }, {
    "name" : "public int getUidProcessState(int uid)",
    "returnType" : "int",
    "comment" : "\n     * Returns the process state of this uid.\n     *\n     * If the caller does not hold {@link Manifest.permission#INTERACT_ACROSS_USERS_FULL}\n     * permission, they can only query process state of UIDs running in the same user as the caller.\n     *\n     * @hide\n     ",
    "links" : [ "Manifest.permission#INTERACT_ACROSS_USERS_FULL" ]
  }, {
    "name" : "public int getUidProcessCapabilities(int uid)",
    "returnType" : "int",
    "comment" : "\n     * Returns the process capability of this uid.\n     *\n     * If the caller does not hold {@link Manifest.permission#INTERACT_ACROSS_USERS_FULL}\n     * permission, they can only query process capabilities of UIDs running in the same user\n     * as the caller.\n     *\n     * @hide\n     ",
    "links" : [ "Manifest.permission#INTERACT_ACROSS_USERS_FULL" ]
  }, {
    "name" : "public int getPackageImportance(String packageName)",
    "returnType" : "int",
    "comment" : "\n     * Return the importance of a given package name, based on the processes that are\n     * currently running.  The return value is one of the importance constants defined\n     * in {@link RunningAppProcessInfo}, giving you the highest importance of all the\n     * processes that this package has code running inside of.  If there are no processes\n     * running its code, {@link RunningAppProcessInfo#IMPORTANCE_GONE} is returned.\n     * @hide\n     ",
    "links" : [ "RunningAppProcessInfo", "#IMPORTANCE_GONE" ]
  }, {
    "name" : "public int getUidImportance(int uid)",
    "returnType" : "int",
    "comment" : "\n     * Return the importance of a given uid, based on the processes that are\n     * currently running.  The return value is one of the importance constants defined\n     * in {@link RunningAppProcessInfo}, giving you the highest importance of all the\n     * processes that this uid has running.  If there are no processes\n     * running its code, {@link RunningAppProcessInfo#IMPORTANCE_GONE} is returned.\n     * @hide\n     ",
    "links" : [ "RunningAppProcessInfo", "#IMPORTANCE_GONE" ]
  }, {
    "name" : "public int getBindingUidImportance(int uid)",
    "returnType" : "int",
    "comment" : "\n     * Same as {@link #getUidImportance(int)}, but it only works on UIDs that currently\n     * have a service binding, or provider reference, to the calling UID, even if the target UID\n     * belong to another android user or profile.\n     *\n     * <p>This will return {@link RunningAppProcessInfo#IMPORTANCE_GONE} on all other UIDs,\n     * regardless of if they're valid or not.\n     *\n     * <p>Privileged system apps may prefer this API to {@link #getUidImportance(int)} to\n     * avoid requesting the permission {@link Manifest.permission#PACKAGE_USAGE_STATS}, which\n     * would allow access to APIs that return more senstive information.\n     *\n     * @hide\n     ",
    "links" : [ "Manifest.permission#PACKAGE_USAGE_STATS", "#getUidImportance(int)", "#IMPORTANCE_GONE" ]
  }, {
    "name" : "public void addOnUidImportanceListener(OnUidImportanceListener listener, @RunningAppProcessInfo.Importance int importanceCutpoint)",
    "returnType" : "void",
    "comment" : "\n     * Start monitoring changes to the importance of all uids running in the system.\n     * @param listener The listener callback that will receive change reports.\n     * @param importanceCutpoint The level of importance in which the caller is interested\n     * in differences.  For example, if {@link RunningAppProcessInfo#IMPORTANCE_PERCEPTIBLE}\n     * is used here, you will receive a call each time a uids importance transitions between\n     * being <= {@link RunningAppProcessInfo#IMPORTANCE_PERCEPTIBLE} and\n     * > {@link RunningAppProcessInfo#IMPORTANCE_PERCEPTIBLE}.\n     *\n     * <p>The caller must hold the {@link android.Manifest.permission#PACKAGE_USAGE_STATS}\n     * permission to use this feature.</p>\n     *\n     * <p>Calling this API with the same instance of {@code listener} without\n     * unregistering with {@link #removeOnUidImportanceListener} before it will result in\n     * an {@link IllegalArgumentException}.</p>\n     *\n     * @throws IllegalArgumentException If the listener is already registered.\n     * @throws SecurityException If the caller does not hold\n     * {@link android.Manifest.permission#PACKAGE_USAGE_STATS}.\n     * @hide\n     ",
    "links" : [ "android.Manifest.permission#PACKAGE_USAGE_STATS", "#IMPORTANCE_PERCEPTIBLE", "#removeOnUidImportanceListener", "IllegalArgumentException" ]
  }, {
    "name" : "public void addOnUidImportanceListener(@NonNull OnUidImportanceListener listener, @RunningAppProcessInfo.Importance int importanceCutpoint, @NonNull int[] uids)",
    "returnType" : "void",
    "comment" : "\n     * Start monitoring changes to the importance of given uids running in the system.\n     *\n     * @param listener The listener callback that will receive change reports.\n     * @param importanceCutpoint The level of importance in which the caller is interested\n     * in differences.  For example, if {@link RunningAppProcessInfo#IMPORTANCE_PERCEPTIBLE}\n     * is used here, you will receive a call each time a uids importance transitions between\n     * being <= {@link RunningAppProcessInfo#IMPORTANCE_PERCEPTIBLE} and\n     * > {@link RunningAppProcessInfo#IMPORTANCE_PERCEPTIBLE}.\n     * @param uids The UIDs that this listener is interested with.\n     * {@link #addOnUidImportanceListener(OnUidImportanceListener, int)} in this case.\n     *\n     * <p>Calling this API with the same instance of {@code listener} without\n     * unregistering with {@link #removeOnUidImportanceListener} before it will result in\n     * an {@link IllegalArgumentException}.</p>\n     *\n     * @throws IllegalArgumentException If the listener is already registered.\n     * @hide\n     ",
    "links" : [ "#IMPORTANCE_PERCEPTIBLE", "#removeOnUidImportanceListener", "#addOnUidImportanceListener(OnUidImportanceListener", "IllegalArgumentException" ]
  }, {
    "name" : "private void addOnUidImportanceListenerInternal(@NonNull OnUidImportanceListener listener, @RunningAppProcessInfo.Importance int importanceCutpoint, @Nullable int[] uids)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public void removeOnUidImportanceListener(OnUidImportanceListener listener)",
    "returnType" : "void",
    "comment" : "\n     * Remove an importance listener that was previously registered with\n     * {@link #addOnUidImportanceListener}.\n     *\n     * @throws IllegalArgumentException If the listener is not registered.\n     * @hide\n     ",
    "links" : [ "#addOnUidImportanceListener" ]
  }, {
    "name" : "public static void getMyMemoryState(RunningAppProcessInfo outState)",
    "returnType" : "void",
    "comment" : "\n     * Return global memory state information for the calling process.  This\n     * does not fill in all fields of the {@link RunningAppProcessInfo}.  The\n     * only fields that will be filled in are\n     * {@link RunningAppProcessInfo#pid},\n     * {@link RunningAppProcessInfo#uid},\n     * {@link RunningAppProcessInfo#lastTrimLevel},\n     * {@link RunningAppProcessInfo#importance},\n     * {@link RunningAppProcessInfo#lru}, and\n     * {@link RunningAppProcessInfo#importanceReasonCode}.\n     ",
    "links" : [ "#importance", "RunningAppProcessInfo", "#pid", "#importanceReasonCode", "#uid", "#lastTrimLevel", "#lru" ]
  }, {
    "name" : "public Debug.MemoryInfo[] getProcessMemoryInfo(int[] pids)",
    "returnType" : "Debug.MemoryInfo[]",
    "comment" : "\n     * Return information about the memory usage of one or more processes.\n     *\n     * <p><b>Note: this method is only intended for debugging or building\n     * a user-facing process management UI.</b></p>\n     *\n     * <p>As of {@link android.os.Build.VERSION_CODES#Q Android Q}, for regular apps this method\n     * will only return information about the memory info for the processes running as the\n     * caller's uid; no other process memory info is available and will be zero.\n     * Also of {@link android.os.Build.VERSION_CODES#Q Android Q} the sample rate allowed\n     * by this API is significantly limited, if called faster the limit you will receive the\n     * same data as the previous call.</p>\n     *\n     * @param pids The pids of the processes whose memory usage is to be\n     * retrieved.\n     * @return Returns an array of memory information, one for each\n     * requested pid.\n     ",
    "links" : [ "android.os.Build.VERSION_CODES#Q" ]
  }, {
    "name" : "public void restartPackage(String packageName)",
    "returnType" : "void",
    "comment" : "\n     * @deprecated This is now just a wrapper for\n     * {@link #killBackgroundProcesses(String)}; the previous behavior here\n     * is no longer available to applications because it allows them to\n     * break other applications by removing their alarms, stopping their\n     * services, etc.\n     ",
    "links" : [ "#killBackgroundProcesses(String)" ]
  }, {
    "name" : "public void killBackgroundProcesses(String packageName)",
    "returnType" : "void",
    "comment" : "\n     * Have the system immediately kill all background processes associated\n     * with the given package.  This is the same as the kernel killing those\n     * processes to reclaim memory; the system will take care of restarting\n     * these processes in the future as needed.\n     *\n     * <p class=\"note\">On devices that run Android 14 or higher,\n     * third party applications can only use this API to kill their own processes.\n     * </p>\n     *\n     * @param packageName The name of the package whose processes are to\n     * be killed.\n     ",
    "links" : [ ]
  }, {
    "name" : "public void killUid(int uid, String reason)",
    "returnType" : "void",
    "comment" : "\n     * Kills the specified UID.\n     * @param uid The UID to kill.\n     * @param reason The reason for the kill.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public void forceStopPackageAsUser(String packageName, int userId)",
    "returnType" : "void",
    "comment" : "\n     * Have the system perform a force stop of everything associated with\n     * the given application package.  All processes that share its uid\n     * will be killed, all services it has running stopped, all activities\n     * removed, etc.  In addition, a {@link Intent#ACTION_PACKAGE_RESTARTED}\n     * broadcast will be sent, so that any of its registered alarms can\n     * be stopped, notifications removed, etc.\n     *\n     * <p>You must hold the permission\n     * {@link android.Manifest.permission#FORCE_STOP_PACKAGES} to be able to\n     * call this method.\n     *\n     * @param packageName The name of the package to be stopped.\n     * @param userId The user for which the running package is to be stopped.\n     *\n     * @hide This is not available to third party applications due to\n     * it allowing them to break other applications by stopping their\n     * services, removing their alarms, etc.\n     ",
    "links" : [ "android.Manifest.permission#FORCE_STOP_PACKAGES", "android.content.Intent#ACTION_PACKAGE_RESTARTED" ]
  }, {
    "name" : "public void forceStopPackage(String packageName)",
    "returnType" : "void",
    "comment" : "\n     * @see #forceStopPackageAsUser(String, int)\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public void forceStopPackageAsUserEvenWhenStopping(String packageName, @UserIdInt int userId)",
    "returnType" : "void",
    "comment" : "\n     * Similar to {@link #forceStopPackageAsUser(String, int)} but will also stop the package even\n     * when the user is in the stopping state.\n     *\n     * @hide\n     ",
    "links" : [ "#forceStopPackageAsUser(String" ]
  }, {
    "name" : "public void setDeviceLocales(@NonNull LocaleList locales)",
    "returnType" : "void",
    "comment" : "\n     * Sets the current locales of the device. Calling app must have the permission\n     * {@code android.permission.CHANGE_CONFIGURATION} and\n     * {@code android.permission.WRITE_SETTINGS}.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public Collection<Locale> getSupportedLocales()",
    "returnType" : "Collection<Locale>",
    "comment" : "\n     * Returns a list of supported locales by this system. It includes all locales that are\n     * selectable by the user, potentially including locales that the framework does not have\n     * translated resources for. To get locales that the framework has translated resources for, use\n     * {@code Resources.getSystem().getAssets().getLocales()} instead.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public ConfigurationInfo getDeviceConfigurationInfo()",
    "returnType" : "ConfigurationInfo",
    "comment" : "\n     * Get the device configuration attributes.\n     ",
    "links" : [ ]
  }, {
    "name" : "public int getLauncherLargeIconDensity()",
    "returnType" : "int",
    "comment" : "\n     * Get the preferred density of icons for the launcher. This is used when\n     * custom drawables are created (e.g., for shortcuts).\n     *\n     * @return density in terms of DPI\n     ",
    "links" : [ ]
  }, {
    "name" : "public int getLauncherLargeIconSize()",
    "returnType" : "int",
    "comment" : "\n     * Get the preferred launcher icon size. This is used when custom drawables\n     * are created (e.g., for shortcuts).\n     *\n     * @return dimensions of square icons in terms of pixels\n     ",
    "links" : [ ]
  }, {
    "name" : " static int getLauncherLargeIconSizeInner(Context context)",
    "returnType" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public static boolean isUserAMonkey()",
    "returnType" : "boolean",
    "comment" : "\n     * Returns \"true\" if the user interface is currently being messed with\n     * by a monkey.\n     ",
    "links" : [ ]
  }, {
    "name" : "public static boolean isUserAMonkey$ravenwood()",
    "returnType" : "boolean",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "public static boolean isRunningInTestHarness()",
    "returnType" : "boolean",
    "comment" : "\n     * Returns \"true\" if device is running in a test harness.\n     *\n     * @deprecated this method is false for all user builds. Users looking to check if their device\n     * is running in a device farm should see {@link #isRunningInUserTestHarness()}.\n     ",
    "links" : [ "#isRunningInUserTestHarness()" ]
  }, {
    "name" : "public static boolean isRunningInUserTestHarness()",
    "returnType" : "boolean",
    "comment" : "\n     * Returns \"true\" if the device is running in Test Harness Mode.\n     *\n     * <p>Test Harness Mode is a feature that allows devices to run without human interaction in a\n     * device farm/testing harness (such as Firebase Test Lab). You should check this method if you\n     * want your app to behave differently when running in a test harness to skip setup screens that\n     * would impede UI testing. e.g. a keyboard application that has a full screen setup page for\n     * the first time it is launched.\n     *\n     * <p>Note that you should <em>not</em> use this to determine whether or not your app is running\n     * an instrumentation test, as it is not set for a standard device running a test.\n     ",
    "links" : [ ]
  }, {
    "name" : "public void alwaysShowUnsupportedCompileSdkWarning(ComponentName activity)",
    "returnType" : "void",
    "comment" : "\n     * Unsupported compiled sdk warning should always be shown for the intput activity\n     * even in cases where the system would normally not show the warning. E.g. when running in a\n     * test harness.\n     *\n     * @param activity The component name of the activity to always show the warning for.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public static boolean canAccessUnexportedComponents(int uid)",
    "returnType" : "boolean",
    "comment" : " @hide\n     * Determines whether the given UID can access unexported components\n     * @param uid the calling UID\n     * @return true if the calling UID is ROOT or SYSTEM\n     ",
    "links" : [ ]
  }, {
    "name" : "public static int checkComponentPermission(String permission, int uid, int owningUid, boolean exported)",
    "returnType" : "int",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "public static int checkComponentPermission(String permission, int uid, int deviceId, int owningUid, boolean exported)",
    "returnType" : "int",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "public static int checkUidPermission(String permission, int uid)",
    "returnType" : "int",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "public static int handleIncomingUser(int callingPid, int callingUid, int userId, boolean allowAll, boolean requireFull, String name, String callerPackage)",
    "returnType" : "int",
    "comment" : "\n     * @hide\n     * Helper for dealing with incoming user arguments to system service calls.\n     * Takes care of checking permissions and converting USER_CURRENT to the\n     * actual current user.\n     *\n     * @param callingPid The pid of the incoming call, as per Binder.getCallingPid().\n     * @param callingUid The uid of the incoming call, as per Binder.getCallingUid().\n     * @param userId The user id argument supplied by the caller -- this is the user\n     * they want to run as.\n     * @param allowAll If true, we will allow USER_ALL.  This means you must be prepared\n     * to get a USER_ALL returned and deal with it correctly.  If false,\n     * an exception will be thrown if USER_ALL is supplied.\n     * @param requireFull If true, the caller must hold\n     * {@link android.Manifest.permission#INTERACT_ACROSS_USERS_FULL} to be able to run as a\n     * different user than their current process; otherwise they must hold\n     * {@link android.Manifest.permission#INTERACT_ACROSS_USERS}.\n     * @param name Optional textual name of the incoming call; only for generating error messages.\n     * @param callerPackage Optional package name of caller; only for error messages.\n     *\n     * @return Returns the user ID that the call should run as.  Will always be a concrete\n     * user number, unless <var>allowAll</var> is true in which case it could also be\n     * USER_ALL.\n     ",
    "links" : [ "android.Manifest.permission#INTERACT_ACROSS_USERS_FULL", "android.Manifest.permission#INTERACT_ACROSS_USERS" ]
  }, {
    "name" : "public static int getCurrentUser()",
    "returnType" : "int",
    "comment" : "\n     * Gets the userId of the current foreground user. Requires system permissions.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public static int getCurrentUser$ravenwood()",
    "returnType" : "int",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "public boolean switchUser(int userid)",
    "returnType" : "boolean",
    "comment" : "\n     * @param userid the user's id. Zero indicates the default user.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean switchUser(@NonNull UserHandle user)",
    "returnType" : "boolean",
    "comment" : "\n     * Returns whether switching to provided user was successful.\n     *\n     * @param user the user to switch to.\n     *\n     * @throws IllegalArgumentException if the user is null.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean startUserInBackgroundVisibleOnDisplay(@UserIdInt int userId, int displayId)",
    "returnType" : "boolean",
    "comment" : "\n     * Starts the given user in background and assign the user to the given display.\n     *\n     * <p>This method will allow the user to launch activities on that display, and it's typically\n     * used only on automotive builds when the vehicle has multiple displays (you can verify if it's\n     * supported by calling {@link UserManager#isVisibleBackgroundUsersSupported()}).\n     *\n     * <p><b>NOTE:</b> differently from {@link #switchUser(int)}, which stops the current foreground\n     * user before starting a new one, this method does not stop the previous user running in\n     * background in the display, and it will return {@code false} in this case. It's up to the\n     * caller to call {@link #stopUser(int)} before starting a new user.\n     *\n     * @param userId user to be started in the display. It will return {@code false} if the user is\n     * a profile, the {@link #getCurrentUser()}, the {@link UserHandle#SYSTEM system user}, or\n     * does not exist.\n     *\n     * @param displayId id of the display.\n     *\n     * @return whether the operation succeeded. Notice that if the user was already started in such\n     * display before, it will return {@code false}.\n     *\n     * @throws UnsupportedOperationException if the device does not support background users on\n     * secondary displays.\n     *\n     * @hide\n     ",
    "links" : [ "#switchUser(int)", "#getCurrentUser()", "#stopUser(int)", "android.os.UserManager#isVisibleBackgroundUsersSupported()", "android.os.UserHandle#SYSTEM" ]
  }, {
    "name" : "public int[] getDisplayIdsForStartingVisibleBackgroundUsers()",
    "returnType" : "int[]",
    "comment" : "\n     * Gets the id of displays that can be used by\n     * {@link #startUserInBackgroundOnSecondaryDisplay(int, int)}.\n     *\n     * @hide\n     ",
    "links" : [ "#startUserInBackgroundOnSecondaryDisplay(int" ]
  }, {
    "name" : "public String getSwitchingFromUserMessage()",
    "returnType" : "String",
    "comment" : "\n     * Gets the message that is shown when a user is switched from.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public String getSwitchingToUserMessage()",
    "returnType" : "String",
    "comment" : "\n     * Gets the message that is shown when a user is switched to.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public void setStopUserOnSwitch(@StopUserOnSwitch int value)",
    "returnType" : "void",
    "comment" : "\n     * Sets whether the current foreground user (and its profiles) should be stopped after switched\n     * out.\n     *\n     * <p>Should only be used on tests. Doesn't apply to {@link UserHandle#SYSTEM system user}.\n     *\n     * @hide\n     ",
    "links" : [ "android.os.UserHandle#SYSTEM" ]
  }, {
    "name" : "public boolean startProfile(@NonNull UserHandle userHandle)",
    "returnType" : "boolean",
    "comment" : "\n     * Starts a profile.\n     * To be used with non-managed profiles, managed profiles should use\n     * {@link UserManager#requestQuietModeEnabled}\n     *\n     * @param userHandle user handle of the profile.\n     * @return true if the profile has been successfully started or if the profile is already\n     * running, false if profile failed to start.\n     * @throws IllegalArgumentException if {@code userHandle} is not a profile.\n     *\n     * @hide\n     ",
    "links" : [ "android.os.UserManager#requestQuietModeEnabled" ]
  }, {
    "name" : "public boolean stopProfile(@NonNull UserHandle userHandle)",
    "returnType" : "boolean",
    "comment" : "\n     * Stops a running profile.\n     * To be used with non-managed profiles, managed profiles should use\n     * {@link UserManager#requestQuietModeEnabled}\n     *\n     * @param userHandle user handle of the profile.\n     * @return true if the profile has been successfully stopped or is already stopped. Otherwise\n     * the exceptions listed below are thrown.\n     * @throws IllegalArgumentException if {@code userHandle} is not a profile.\n     *\n     * @hide\n     ",
    "links" : [ "android.os.UserManager#requestQuietModeEnabled" ]
  }, {
    "name" : "public boolean updateMccMncConfiguration(@NonNull String mcc, @NonNull String mnc)",
    "returnType" : "boolean",
    "comment" : "\n     * Updates the MCC (Mobile Country Code) and MNC (Mobile Network Code) in the\n     * system configuration.\n     *\n     * @param mcc The new MCC.\n     * @param mnc The new MNC.\n     * @throws RemoteException; IllegalArgumentException if mcc or mnc is null;\n     * @return Returns {@code true} if the configuration was updated successfully;\n     *         {@code false} otherwise.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean stopUser(@UserIdInt int userId)",
    "returnType" : "boolean",
    "comment" : "\n     * Stops the given {@code userId}.\n     *\n     * <p><b>NOTE:</b> on systems that support\n     * {@link UserManager#isVisibleBackgroundUsersSupported() background users on secondary\n     * displays}, this method will also unassign the user from the display it was started on.\n     *\n     * @hide\n     ",
    "links" : [ "android.os.UserManager#isVisibleBackgroundUsersSupported()" ]
  }, {
    "name" : "public boolean isUserRunning(int userId)",
    "returnType" : "boolean",
    "comment" : "\n     * Return whether the given user is actively running.  This means that\n     * the user is in the \"started\" state, not \"stopped\" -- it is currently\n     * allowed to run code through scheduled alarms, receiving broadcasts,\n     * etc.  A started user may be either the current foreground user or a\n     * background user; the result here does not distinguish between the two.\n     * @param userId the user's id. Zero indicates the default user.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean isVrModePackageEnabled(ComponentName component)",
    "returnType" : "boolean",
    "comment" : " {@hide} ",
    "links" : [ ]
  }, {
    "name" : "public void dumpPackageState(FileDescriptor fd, String packageName)",
    "returnType" : "void",
    "comment" : "\n     * Perform a system dump of various state associated with the given application\n     * package name.  This call blocks while the dump is being performed, so should\n     * not be done on a UI thread.  The data will be written to the given file\n     * descriptor as text.\n     * @param fd The file descriptor that the dump should be written to.  The file\n     * descriptor is <em>not</em> closed by this function; the caller continues to\n     * own it.\n     * @param packageName The name of the package that is to be dumped.\n     ",
    "links" : [ ]
  }, {
    "name" : "public static void dumpPackageStateStatic(FileDescriptor fd, String packageName)",
    "returnType" : "void",
    "comment" : "\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public static boolean isSystemReady()",
    "returnType" : "boolean",
    "comment" : "\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public static boolean isSystemReady$ravenwood()",
    "returnType" : "boolean",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "public static void broadcastStickyIntent(Intent intent, int userId)",
    "returnType" : "void",
    "comment" : "\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public static void broadcastStickyIntent(Intent intent, int appOp, int userId)",
    "returnType" : "void",
    "comment" : "\n     * Convenience for sending a sticky broadcast.  For internal use only.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public static void broadcastStickyIntent(Intent intent, int appOp, Bundle options, int userId)",
    "returnType" : "void",
    "comment" : "\n     * Convenience for sending a sticky broadcast.  For internal use only.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public static void broadcastStickyIntent(Intent intent, String[] excludedPackages, int appOp, Bundle options, int userId)",
    "returnType" : "void",
    "comment" : "\n     * Convenience for sending a sticky broadcast.  For internal use only.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public static void resumeAppSwitches() throws RemoteException",
    "returnType" : "void",
    "comment" : "\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public static void noteWakeupAlarm(PendingIntent ps, WorkSource workSource, int sourceUid, String sourcePkg, String tag)",
    "returnType" : "void",
    "comment" : "\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public static void noteAlarmStart(PendingIntent ps, WorkSource workSource, int sourceUid, String tag)",
    "returnType" : "void",
    "comment" : "\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public static void noteAlarmFinish(PendingIntent ps, WorkSource workSource, int sourceUid, String tag)",
    "returnType" : "void",
    "comment" : "\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public static IActivityManager getService()",
    "returnType" : "IActivityManager",
    "comment" : "\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "private static IActivityTaskManager getTaskService()",
    "returnType" : "IActivityTaskManager",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private static void dumpService(PrintWriter pw, FileDescriptor fd, String name, String[] args)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public void setWatchHeapLimit(long pssSize)",
    "returnType" : "void",
    "comment" : "\n     * Request that the system start watching for the calling process to exceed a pss\n     * size as given here.  Once called, the system will look for any occasions where it\n     * sees the associated process with a larger pss size and, when this happens, automatically\n     * pull a heap dump from it and allow the user to share the data.  Note that this request\n     * continues running even if the process is killed and restarted.  To remove the watch,\n     * use {@link #clearWatchHeapLimit()}.\n     *\n     * <p>This API only works if the calling process has been marked as\n     * {@link ApplicationInfo#FLAG_DEBUGGABLE} or this is running on a debuggable\n     * (userdebug or eng) build.</p>\n     *\n     * <p>Callers can optionally implement {@link #ACTION_REPORT_HEAP_LIMIT} to directly\n     * handle heap limit reports themselves.</p>\n     *\n     * @param pssSize The size in bytes to set the limit at.\n     ",
    "links" : [ "#clearWatchHeapLimit()", "android.content.pm.ApplicationInfo#FLAG_DEBUGGABLE", "#ACTION_REPORT_HEAP_LIMIT" ]
  }, {
    "name" : "public void clearWatchHeapLimit()",
    "returnType" : "void",
    "comment" : "\n     * Clear a heap watch limit previously set by {@link #setWatchHeapLimit(long)}.\n     ",
    "links" : [ "#setWatchHeapLimit(long)" ]
  }, {
    "name" : "public boolean isInLockTaskMode()",
    "returnType" : "boolean",
    "comment" : "\n     * Return whether currently in lock task mode.  When in this mode\n     * no new tasks can be created or switched to.\n     *\n     * @see Activity#startLockTask()\n     *\n     * @deprecated Use {@link #getLockTaskModeState} instead.\n     ",
    "links" : [ "#getLockTaskModeState" ]
  }, {
    "name" : "public int getLockTaskModeState()",
    "returnType" : "int",
    "comment" : "\n     * Return the current state of task locking. The three possible outcomes\n     * are {@link #LOCK_TASK_MODE_NONE}, {@link #LOCK_TASK_MODE_LOCKED}\n     * and {@link #LOCK_TASK_MODE_PINNED}.\n     *\n     * @see Activity#startLockTask()\n     ",
    "links" : [ "#LOCK_TASK_MODE_PINNED", "#LOCK_TASK_MODE_LOCKED", "#LOCK_TASK_MODE_NONE" ]
  }, {
    "name" : "public static void setVrThread(int tid)",
    "returnType" : "void",
    "comment" : "\n     * Enable more aggressive scheduling for latency-sensitive low-runtime VR threads. Only one\n     * thread can be a VR thread in a process at a time, and that thread may be subject to\n     * restrictions on the amount of time it can run.\n     *\n     * If persistent VR mode is set, whatever thread has been granted aggressive scheduling via this\n     * method will return to normal operation, and calling this method will do nothing while\n     * persistent VR mode is enabled.\n     *\n     * To reset the VR thread for an application, a tid of 0 can be passed.\n     *\n     * @see android.os.Process#myTid()\n     * @param tid tid of the VR thread\n     ",
    "links" : [ ]
  }, {
    "name" : "public static void setPersistentVrThread(int tid)",
    "returnType" : "void",
    "comment" : "\n     * Enable more aggressive scheduling for latency-sensitive low-runtime VR threads that persist\n     * beyond a single process. Only one thread can be a\n     * persistent VR thread at a time, and that thread may be subject to restrictions on the amount\n     * of time it can run. Calling this method will disable aggressive scheduling for non-persistent\n     * VR threads set via {@link #setVrThread}. If persistent VR mode is disabled then the\n     * persistent VR thread loses its new scheduling priority; this method must be called again to\n     * set the persistent thread.\n     *\n     * To reset the persistent VR thread, a tid of 0 can be passed.\n     *\n     * @see android.os.Process#myTid()\n     * @param tid tid of the VR thread\n     * @hide\n     ",
    "links" : [ "#setVrThread" ]
  }, {
    "name" : "public void scheduleApplicationInfoChanged(List<String> packages, int userId)",
    "returnType" : "void",
    "comment" : "\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean isProfileForeground(@NonNull UserHandle userHandle)",
    "returnType" : "boolean",
    "comment" : "\n     * Returns whether the given user, or its parent (if the user is a profile), is in the\n     * foreground.\n     * @param userHandle UserHandle to check\n     * @return whether the user is the foreground user or, if it is a profile, whether its parent\n     *         is the foreground user\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public void killProcessesWhenImperceptible(@NonNull int[] pids, @NonNull String reason)",
    "returnType" : "void",
    "comment" : "\n     * Kill the given PIDs, but the killing will be delayed until the device is idle\n     * and the given process is imperceptible.\n     *\n     * <p>You must hold the permission\n     * {@link android.Manifest.permission#FORCE_STOP_PACKAGES} to be able to\n     * call this method.\n     * </p>\n     *\n     * @param pids The list of the pids to be killed\n     * @pram reason The reason of the kill\n     *\n     * @hide\n     ",
    "links" : [ "android.Manifest.permission#FORCE_STOP_PACKAGES" ]
  }, {
    "name" : "public static boolean isProcStateConsideredInteraction(@ProcessState int procState)",
    "returnType" : "boolean",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "public static String procStateToString(int procState)",
    "returnType" : "String",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "public List<String> getBugreportWhitelistedPackages()",
    "returnType" : "List<String>",
    "comment" : "\n     * Get packages of bugreport-allowlisted apps to handle a bug report.\n     *\n     * @return packages of bugreport-allowlisted apps to handle a bug report.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public void appNotResponding(@NonNull final String reason)",
    "returnType" : "void",
    "comment" : "\n     * Method for the app to tell system that it's wedged and would like to trigger an ANR.\n     *\n     * @param reason The description of that what happened\n     ",
    "links" : [ ]
  }, {
    "name" : "public void addHomeVisibilityListener(@NonNull Executor executor, @NonNull HomeVisibilityListener listener)",
    "returnType" : "void",
    "comment" : "\n     * Register to be notified when the visibility of the home screen changes.\n     *\n     * @param executor The executor on which the listener should be called.\n     * @param listener The listener that is called when home visibility changes.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public void removeHomeVisibilityListener(@NonNull HomeVisibilityListener listener)",
    "returnType" : "void",
    "comment" : "\n     * Removes a listener that was previously added with {@link #addHomeVisibilityListener}.\n     *\n     * @param listener The listener that was previously added.\n     * @hide\n     ",
    "links" : [ "#addHomeVisibilityListener" ]
  }, {
    "name" : "public void setThemeOverlayReady(@UserIdInt int userId)",
    "returnType" : "void",
    "comment" : "\n     * Used by ThemeOverlayController to notify when color\n     * palette is ready.\n     *\n     * @param userId The ID of the user where ThemeOverlayController is ready.\n     *\n     * @throws RemoteException\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public void resetAppErrors()",
    "returnType" : "void",
    "comment" : "\n     * Resets the state of the {@link com.android.server.am.AppErrors} instance.\n     * This is intended for use with CTS only.\n     * @hide\n     ",
    "links" : [ "com.android.server.am.AppErrors" ]
  }, {
    "name" : "public void holdLock(IBinder token, int durationMs)",
    "returnType" : "void",
    "comment" : "\n     * Holds the AM lock for the specified amount of milliseconds.\n     * This is intended for use by the tests that need to imitate lock contention.\n     * The token should be obtained by\n     * {@link android.content.pm.PackageManager#getHoldLockToken()}.\n     * @hide\n     ",
    "links" : [ "android.content.pm.PackageManager#getHoldLockToken()" ]
  }, {
    "name" : "public void waitForBroadcastIdle()",
    "returnType" : "void",
    "comment" : "\n     * Blocks until all broadcast queues become idle.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public void forceDelayBroadcastDelivery(@NonNull String targetPackage, @IntRange(from = 0) long delayedDurationMs)",
    "returnType" : "void",
    "comment" : "\n     * Delays delivering broadcasts to the specified package.\n     *\n     * <p> When {@code delayedDurationMs} is {@code 0}, it will clears any previously\n     * set forced delays.\n     *\n     * <p><b>Note: This method is only intended for testing and it only\n     * works for packages that are already running.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean isProcessFrozen(int pid)",
    "returnType" : "boolean",
    "comment" : "\n     * Checks if the process represented by the given {@code pid} is frozen.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public void noteForegroundResourceUseBegin(@ForegroundServiceApiType int apiType, int uid, int pid) throws SecurityException",
    "returnType" : "void",
    "comment" : "\n     * Internal method for logging API starts. Used with\n     * FGS metrics logging. Is called by APIs that are\n     * used with FGS to log an API event (eg when\n     * the camera starts).\n     * @hide\n     *\n     ",
    "links" : [ ]
  }, {
    "name" : "public void noteForegroundResourceUseEnd(@ForegroundServiceApiType int apiType, int uid, int pid) throws SecurityException",
    "returnType" : "void",
    "comment" : "\n     * Internal method for logging API end. Used with\n     * FGS metrics logging. Is called by APIs that are\n     * used with FGS to log an API event (eg when\n     * the camera starts).\n     * @hide\n     *\n     ",
    "links" : [ ]
  }, {
    "name" : "public int getBackgroundRestrictionExemptionReason(int uid)",
    "returnType" : "int",
    "comment" : "\n     * @return The reason code of whether or not the given UID should be exempted from background\n     * restrictions here.\n     *\n     * <p>\n     * Note: Call it with caution as it'll try to acquire locks in other services.\n     * </p>\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public void noteAppRestrictionEnabled(@NonNull String packageName, int uid, @RestrictionLevel int restrictionLevel, boolean enabled, @RestrictionReason int reason, @Nullable String subReason, long threshold)",
    "returnType" : "void",
    "comment" : "\n     * Requests the system to log the reason for restricting/unrestricting an app. This API\n     * should be called before applying any change to the restriction level.\n     * <p>\n     * The {@code enabled} value determines whether the state is being applied or removed.\n     * Not all restrictions are actual restrictions. For example,\n     * {@link #RESTRICTION_LEVEL_ADAPTIVE} is a normal state, where there is default lifecycle\n     * management applied to the app. Also, {@link #RESTRICTION_LEVEL_EXEMPTED} is used when the\n     * app is being put in a power-save allowlist.\n     * <p>\n     * Example arguments when user force-stops an app from Settings:\n     * <pre>\n     * noteAppRestrictionEnabled(\n     *     \"com.example.app\",\n     *     appUid,\n     *     RESTRICTION_LEVEL_FORCE_STOPPED,\n     *     true,\n     *     RESTRICTION_REASON_USER,\n     *     \"settings\",\n     *     0);\n     * </pre>\n     * Example arguments when app is put in restricted standby bucket for exceeding X hours of jobs:\n     * <pre>\n     * noteAppRestrictionEnabled(\n     *     \"com.example.app\",\n     *     appUid,\n     *     RESTRICTION_LEVEL_RESTRICTED_BUCKET,\n     *     true,\n     *     RESTRICTION_REASON_SYSTEM_HEALTH,\n     *     \"job_duration\",\n     *     X * 3600 * 1000L);\n     * </pre>\n     *\n     * @param packageName the package name of the app\n     * @param uid the uid of the app\n     * @param restrictionLevel the restriction level specified in {@code RestrictionLevel}\n     * @param enabled whether the state is being applied or removed\n     * @param reason the reason for the restriction state change, from {@code RestrictionReason}\n     * @param subReason a string sub reason limited to 16 characters that specifies additional\n     *                  information about the reason for restriction. This string must only contain\n     *                  reasons related to excessive system resource usage or in some cases,\n     *                  source of the restriction. This string must not contain any details that\n     *                  identify user behavior beyond their actions to restrict/unrestrict/launch\n     *                  apps in some way.\n     *                  Examples of system resource usage: wakelock, wakeups, mobile_data,\n     *                  binder_calls, memory, excessive_threads, excessive_cpu, gps_scans, etc.\n     *                  Examples of user actions: settings, notification, command_line, launch, etc.\n     *\n     * @param threshold for reasons that are due to exceeding some threshold, the threshold value\n     *                  must be specified. The unit of the threshold depends on the reason and/or\n     *                  subReason. For time, use milliseconds. For memory, use KB. For count, use\n     *                  the actual count or if rate limited, normalized per-hour. For power,\n     *                  use milliwatts. For CPU, use mcycles.\n     *\n     * @hide\n     ",
    "links" : [ "#RESTRICTION_LEVEL_ADAPTIVE", "#RESTRICTION_LEVEL_EXEMPTED" ]
  }, {
    "name" : "public void notifySystemPropertiesChanged()",
    "returnType" : "void",
    "comment" : "\n     * Notifies {@link #getRunningAppProcesses app processes} that the system properties\n     * have changed.\n     *\n     * @see SystemProperties#addChangeCallback\n     *\n     * @hide\n     ",
    "links" : [ "#getRunningAppProcesses" ]
  } ],
  "methodNames" : [ "public void registerUidFrozenStateChangedCallback(@NonNull Executor executor, @NonNull UidFrozenStateChangedCallback callback)", "public void unregisterUidFrozenStateChangedCallback(@NonNull UidFrozenStateChangedCallback callback)", "public int[] getUidFrozenState(@NonNull int[] uids)", "public static void printCapabilitiesSummary(PrintWriter pw, @ProcessCapability int caps)", "public static void printCapabilitiesSummary(StringBuilder sb, @ProcessCapability int caps)", "public static void printCapabilitiesFull(PrintWriter pw, @ProcessCapability int caps)", "public static String getCapabilitiesSummary(@ProcessCapability int caps)", "public static final int processStateAmToProto(int amInt)", "public static final boolean isProcStateBackground(int procState)", "public static final boolean isProcStateCached(int procState)", "public static boolean isForegroundService(int procState)", "public static void init$ravenwood(int currentUser)", "public static void reset$ravenwood()", "public static final boolean isStartResultSuccessful(int result)", "public static final boolean isStartResultFatalError(int result)", "public static String restrictionLevelToName(@RestrictionLevel int level)", "public int getFrontActivityScreenCompatMode()", "public void setFrontActivityScreenCompatMode(int mode)", "public int getPackageScreenCompatMode(String packageName)", "public void setPackageScreenCompatMode(String packageName, int mode)", "public boolean getPackageAskScreenCompat(String packageName)", "public void setPackageAskScreenCompat(String packageName, boolean ask)", "public int getMemoryClass()", "public static int staticGetMemoryClass()", "public int getLargeMemoryClass()", "public static int staticGetLargeMemoryClass()", "public boolean isLowRamDevice()", "public static boolean isLowRamDeviceStatic()", "public static boolean isSmallBatteryDevice()", "public static boolean isHighEndGfx()", "public long getTotalRam()", "public static int getMaxRecentTasksStatic()", "public List<RecentTaskInfo> getRecentTasks(int maxNum, int flags) throws SecurityException", "public List<ActivityManager.AppTask> getAppTasks()", "public Size getAppTaskThumbnailSize()", "private void ensureAppTaskThumbnailSizeLocked()", "public int addAppTask(@NonNull Activity activity, @NonNull Intent intent, @Nullable TaskDescription description, @NonNull Bitmap thumbnail)", "public List<RunningTaskInfo> getRunningTasks(int maxNum) throws SecurityException", "public void moveTaskToFront(int taskId, @MoveTaskFlags int flags)", "public void moveTaskToFront(int taskId, @MoveTaskFlags int flags, Bundle options)", "public boolean isActivityStartAllowedOnDisplay(@NonNull Context context, int displayId, @NonNull Intent intent)", "public List<RunningServiceInfo> getRunningServices(int maxNum) throws SecurityException", "public PendingIntent getRunningServiceControlPanel(ComponentName service) throws SecurityException", "public void getMemoryInfo(MemoryInfo outInfo)", "public boolean clearApplicationUserData(String packageName, IPackageDataObserver observer)", "public boolean clearApplicationUserData()", "public ParceledListSlice<GrantedUriPermission> getGrantedUriPermissions(@Nullable String packageName)", "public void clearGrantedUriPermissions(String packageName)", "public List<ProcessErrorStateInfo> getProcessesInErrorState()", "public List<ApplicationInfo> getRunningExternalApplications()", "public boolean isBackgroundRestricted()", "public boolean setProcessMemoryTrimLevel(String process, int userId, int level)", "public List<RunningAppProcessInfo> getRunningAppProcesses()", "public List<ApplicationStartInfo> getHistoricalProcessStartReasons(@IntRange(from = 0) int maxNum)", "public List<ApplicationStartInfo> getExternalHistoricalProcessStartReasons(@NonNull String packageName, @IntRange(from = 0) int maxNum)", "public void addApplicationStartInfoCompletionListener(@NonNull final Executor executor, @NonNull final Consumer<ApplicationStartInfo> listener)", "public void removeApplicationStartInfoCompletionListener(@NonNull final Consumer<ApplicationStartInfo> listener)", "public void addStartInfoTimestamp(@IntRange(from = ApplicationStartInfo.START_TIMESTAMP_RESERVED_RANGE_DEVELOPER_START, to = ApplicationStartInfo.START_TIMESTAMP_RESERVED_RANGE_DEVELOPER) int key, long timestampNs)", "public List<ApplicationExitInfo> getHistoricalProcessExitReasons(@Nullable String packageName, @IntRange(from = 0) int pid, @IntRange(from = 0) int maxNum)", "public void setProcessStateSummary(@Nullable byte[] state)", "public static boolean isLowMemoryKillReportSupported()", "public int getUidProcessState(int uid)", "public int getUidProcessCapabilities(int uid)", "public int getPackageImportance(String packageName)", "public int getUidImportance(int uid)", "public int getBindingUidImportance(int uid)", "public void addOnUidImportanceListener(OnUidImportanceListener listener, @RunningAppProcessInfo.Importance int importanceCutpoint)", "public void addOnUidImportanceListener(@NonNull OnUidImportanceListener listener, @RunningAppProcessInfo.Importance int importanceCutpoint, @NonNull int[] uids)", "private void addOnUidImportanceListenerInternal(@NonNull OnUidImportanceListener listener, @RunningAppProcessInfo.Importance int importanceCutpoint, @Nullable int[] uids)", "public void removeOnUidImportanceListener(OnUidImportanceListener listener)", "public static void getMyMemoryState(RunningAppProcessInfo outState)", "public Debug.MemoryInfo[] getProcessMemoryInfo(int[] pids)", "public void restartPackage(String packageName)", "public void killBackgroundProcesses(String packageName)", "public void killUid(int uid, String reason)", "public void forceStopPackageAsUser(String packageName, int userId)", "public void forceStopPackage(String packageName)", "public void forceStopPackageAsUserEvenWhenStopping(String packageName, @UserIdInt int userId)", "public void setDeviceLocales(@NonNull LocaleList locales)", "public Collection<Locale> getSupportedLocales()", "public ConfigurationInfo getDeviceConfigurationInfo()", "public int getLauncherLargeIconDensity()", "public int getLauncherLargeIconSize()", " static int getLauncherLargeIconSizeInner(Context context)", "public static boolean isUserAMonkey()", "public static boolean isUserAMonkey$ravenwood()", "public static boolean isRunningInTestHarness()", "public static boolean isRunningInUserTestHarness()", "public void alwaysShowUnsupportedCompileSdkWarning(ComponentName activity)", "public static boolean canAccessUnexportedComponents(int uid)", "public static int checkComponentPermission(String permission, int uid, int owningUid, boolean exported)", "public static int checkComponentPermission(String permission, int uid, int deviceId, int owningUid, boolean exported)", "public static int checkUidPermission(String permission, int uid)", "public static int handleIncomingUser(int callingPid, int callingUid, int userId, boolean allowAll, boolean requireFull, String name, String callerPackage)", "public static int getCurrentUser()", "public static int getCurrentUser$ravenwood()", "public boolean switchUser(int userid)", "public boolean switchUser(@NonNull UserHandle user)", "public boolean startUserInBackgroundVisibleOnDisplay(@UserIdInt int userId, int displayId)", "public int[] getDisplayIdsForStartingVisibleBackgroundUsers()", "public String getSwitchingFromUserMessage()", "public String getSwitchingToUserMessage()", "public void setStopUserOnSwitch(@StopUserOnSwitch int value)", "public boolean startProfile(@NonNull UserHandle userHandle)", "public boolean stopProfile(@NonNull UserHandle userHandle)", "public boolean updateMccMncConfiguration(@NonNull String mcc, @NonNull String mnc)", "public boolean stopUser(@UserIdInt int userId)", "public boolean isUserRunning(int userId)", "public boolean isVrModePackageEnabled(ComponentName component)", "public void dumpPackageState(FileDescriptor fd, String packageName)", "public static void dumpPackageStateStatic(FileDescriptor fd, String packageName)", "public static boolean isSystemReady()", "public static boolean isSystemReady$ravenwood()", "public static void broadcastStickyIntent(Intent intent, int userId)", "public static void broadcastStickyIntent(Intent intent, int appOp, int userId)", "public static void broadcastStickyIntent(Intent intent, int appOp, Bundle options, int userId)", "public static void broadcastStickyIntent(Intent intent, String[] excludedPackages, int appOp, Bundle options, int userId)", "public static void resumeAppSwitches() throws RemoteException", "public static void noteWakeupAlarm(PendingIntent ps, WorkSource workSource, int sourceUid, String sourcePkg, String tag)", "public static void noteAlarmStart(PendingIntent ps, WorkSource workSource, int sourceUid, String tag)", "public static void noteAlarmFinish(PendingIntent ps, WorkSource workSource, int sourceUid, String tag)", "public static IActivityManager getService()", "private static IActivityTaskManager getTaskService()", "private static void dumpService(PrintWriter pw, FileDescriptor fd, String name, String[] args)", "public void setWatchHeapLimit(long pssSize)", "public void clearWatchHeapLimit()", "public boolean isInLockTaskMode()", "public int getLockTaskModeState()", "public static void setVrThread(int tid)", "public static void setPersistentVrThread(int tid)", "public void scheduleApplicationInfoChanged(List<String> packages, int userId)", "public boolean isProfileForeground(@NonNull UserHandle userHandle)", "public void killProcessesWhenImperceptible(@NonNull int[] pids, @NonNull String reason)", "public static boolean isProcStateConsideredInteraction(@ProcessState int procState)", "public static String procStateToString(int procState)", "public List<String> getBugreportWhitelistedPackages()", "public void appNotResponding(@NonNull final String reason)", "public void addHomeVisibilityListener(@NonNull Executor executor, @NonNull HomeVisibilityListener listener)", "public void removeHomeVisibilityListener(@NonNull HomeVisibilityListener listener)", "public void setThemeOverlayReady(@UserIdInt int userId)", "public void resetAppErrors()", "public void holdLock(IBinder token, int durationMs)", "public void waitForBroadcastIdle()", "public void forceDelayBroadcastDelivery(@NonNull String targetPackage, @IntRange(from = 0) long delayedDurationMs)", "public boolean isProcessFrozen(int pid)", "public void noteForegroundResourceUseBegin(@ForegroundServiceApiType int apiType, int uid, int pid) throws SecurityException", "public void noteForegroundResourceUseEnd(@ForegroundServiceApiType int apiType, int uid, int pid) throws SecurityException", "public int getBackgroundRestrictionExemptionReason(int uid)", "public void noteAppRestrictionEnabled(@NonNull String packageName, int uid, @RestrictionLevel int restrictionLevel, boolean enabled, @RestrictionReason int reason, @Nullable String subReason, long threshold)", "public void notifySystemPropertiesChanged()" ],
  "variableNames" : [ "TAG", "mContext", "sSystemReady", "FIRST_START_FATAL_ERROR_CODE", "LAST_START_FATAL_ERROR_CODE", "FIRST_START_SUCCESS_CODE", "LAST_START_SUCCESS_CODE", "FIRST_START_NON_FATAL_ERROR_CODE", "LAST_START_NON_FATAL_ERROR_CODE", "INSTR_FLAG_DISABLE_HIDDEN_API_CHECKS", "INSTR_FLAG_DISABLE_ISOLATED_STORAGE", "INSTR_FLAG_DISABLE_TEST_API_CHECKS", "INSTR_FLAG_NO_RESTART", "INSTR_FLAG_ALWAYS_CHECK_SIGNATURE", "INSTR_FLAG_INSTRUMENT_SDK_SANDBOX", "INSTR_FLAG_INSTRUMENT_SDK_IN_SANDBOX", "mImportanceListeners", "mFrozenStateChangedCallbacks", "mFrozenStateChangedCallback", "META_HOME_ALTERNATE", "START_VOICE_HIDDEN_SESSION", "START_VOICE_NOT_ACTIVE_SESSION", "START_NOT_CURRENT_USER_ACTIVITY", "START_NOT_VOICE_COMPATIBLE", "START_CANCELED", "START_NOT_ACTIVITY", "START_PERMISSION_DENIED", "START_FORWARD_AND_REQUEST_CONFLICT", "START_CLASS_NOT_FOUND", "START_INTENT_NOT_RESOLVED", "START_ASSISTANT_HIDDEN_SESSION", "START_ASSISTANT_NOT_ACTIVE_SESSION", "START_SUCCESS", "START_RETURN_INTENT_TO_CALLER", "START_TASK_TO_FRONT", "START_DELIVERED_TO_TOP", "START_SWITCHES_CANCELED", "START_RETURN_LOCK_TASK_MODE_VIOLATION", "START_ABORTED", "START_FLAG_ONLY_IF_NEEDED", "START_FLAG_DEBUG", "START_FLAG_TRACK_ALLOCATION", "START_FLAG_NATIVE_DEBUGGING", "START_FLAG_DEBUG_SUSPEND", "BROADCAST_SUCCESS", "BROADCAST_STICKY_CANT_HAVE_PERMISSION", "BROADCAST_FAILED_USER_STOPPED", "INTENT_SENDER_UNKNOWN", "INTENT_SENDER_BROADCAST", "INTENT_SENDER_ACTIVITY", "INTENT_SENDER_ACTIVITY_RESULT", "INTENT_SENDER_SERVICE", "INTENT_SENDER_FOREGROUND_SERVICE", "USER_OP_SUCCESS", "USER_OP_UNKNOWN_USER", "USER_OP_IS_CURRENT", "USER_OP_ERROR_IS_SYSTEM", "USER_OP_ERROR_RELATED_USERS_CANNOT_STOP", "PROCESS_STATE_UNKNOWN", "PROCESS_STATE_PERSISTENT", "PROCESS_STATE_PERSISTENT_UI", "PROCESS_STATE_TOP", "PROCESS_STATE_BOUND_TOP", "PROCESS_STATE_FOREGROUND_SERVICE", "PROCESS_STATE_BOUND_FOREGROUND_SERVICE", "PROCESS_STATE_IMPORTANT_FOREGROUND", "PROCESS_STATE_IMPORTANT_BACKGROUND", "PROCESS_STATE_TRANSIENT_BACKGROUND", "PROCESS_STATE_BACKUP", "PROCESS_STATE_SERVICE", "PROCESS_STATE_RECEIVER", "PROCESS_STATE_TOP_SLEEPING", "PROCESS_STATE_HEAVY_WEIGHT", "PROCESS_STATE_HOME", "PROCESS_STATE_LAST_ACTIVITY", "PROCESS_STATE_CACHED_ACTIVITY", "PROCESS_STATE_CACHED_ACTIVITY_CLIENT", "PROCESS_STATE_CACHED_RECENT", "PROCESS_STATE_CACHED_EMPTY", "PROCESS_STATE_NONEXISTENT", "FOREGROUND_SERVICE_API_TYPE_CAMERA", "FOREGROUND_SERVICE_API_TYPE_BLUETOOTH", "FOREGROUND_SERVICE_API_TYPE_LOCATION", "FOREGROUND_SERVICE_API_TYPE_MEDIA_PLAYBACK", "FOREGROUND_SERVICE_API_TYPE_AUDIO", "FOREGROUND_SERVICE_API_TYPE_MICROPHONE", "FOREGROUND_SERVICE_API_TYPE_PHONE_CALL", "FOREGROUND_SERVICE_API_TYPE_USB", "FOREGROUND_SERVICE_API_TYPE_CDM", "FOREGROUND_SERVICE_API_EVENT_BEGIN", "FOREGROUND_SERVICE_API_EVENT_END", "PROCESS_CAPABILITY_NONE", "PROCESS_CAPABILITY_FOREGROUND_LOCATION", "PROCESS_CAPABILITY_FOREGROUND_CAMERA", "PROCESS_CAPABILITY_FOREGROUND_MICROPHONE", "PROCESS_CAPABILITY_POWER_RESTRICTED_NETWORK", "PROCESS_CAPABILITY_BFSL", "PROCESS_CAPABILITY_USER_RESTRICTED_NETWORK", "PROCESS_CAPABILITY_FOREGROUND_AUDIO_CONTROL", "PROCESS_CAPABILITY_ALL", "PROCESS_CAPABILITY_ALL_IMPLICIT", "MIN_PROCESS_STATE", "MAX_PROCESS_STATE", "ASSIST_CONTEXT_BASIC", "ASSIST_CONTEXT_FULL", "ASSIST_CONTEXT_AUTOFILL", "ASSIST_CONTEXT_CONTENT", "UID_OBSERVER_PROCSTATE", "UID_OBSERVER_GONE", "UID_OBSERVER_IDLE", "UID_OBSERVER_ACTIVE", "UID_OBSERVER_CACHED", "UID_OBSERVER_CAPABILITY", "UID_OBSERVER_PROC_OOM_ADJ", "APP_START_MODE_NORMAL", "APP_START_MODE_DELAYED", "APP_START_MODE_DELAYED_RIGID", "APP_START_MODE_DISABLED", "LOCK_TASK_MODE_NONE", "LOCK_TASK_MODE_LOCKED", "LOCK_TASK_MODE_PINNED", "mAppTaskThumbnailSize", "sCurrentUser$ravenwood", "COMPAT_MODE_ALWAYS", "COMPAT_MODE_NEVER", "COMPAT_MODE_UNKNOWN", "COMPAT_MODE_DISABLED", "COMPAT_MODE_ENABLED", "COMPAT_MODE_TOGGLE", "DEVELOPMENT_FORCE_LOW_RAM", "DROP_CLOSE_SYSTEM_DIALOGS", "LOCK_DOWN_CLOSE_SYSTEM_DIALOGS", "RESTRICTION_LEVEL_UNKNOWN", "RESTRICTION_LEVEL_UNRESTRICTED", "RESTRICTION_LEVEL_EXEMPTED", "RESTRICTION_LEVEL_ADAPTIVE_BUCKET", "RESTRICTION_LEVEL_RESTRICTED_BUCKET", "RESTRICTION_LEVEL_BACKGROUND_RESTRICTED", "RESTRICTION_LEVEL_FORCE_STOPPED", "RESTRICTION_LEVEL_USER_LAUNCH_ONLY", "RESTRICTION_LEVEL_CUSTOM", "RESTRICTION_LEVEL_MAX", "RESTRICTION_SUBREASON_MAX_LENGTH", "RESTRICTION_REASON_UNKNOWN", "RESTRICTION_REASON_DEFAULT", "RESTRICTION_REASON_DORMANT", "RESTRICTION_REASON_USAGE", "RESTRICTION_REASON_USER", "RESTRICTION_REASON_USER_NUDGED", "RESTRICTION_REASON_SYSTEM_HEALTH", "RESTRICTION_REASON_REMOTE_TRIGGER", "RESTRICTION_REASON_OTHER", "RECENT_WITH_EXCLUDED", "RECENT_IGNORE_UNAVAILABLE", "MOVE_TASK_WITH_HOME", "MOVE_TASK_NO_USER_ACTION", "mAppStartInfoCallbacks", "mAppStartInfoCompleteListener", "STOP_USER_ON_SWITCH_DEFAULT", "STOP_USER_ON_SWITCH_TRUE", "STOP_USER_ON_SWITCH_FALSE", "FLAG_OR_STOPPED", "FLAG_AND_LOCKED", "FLAG_AND_UNLOCKED", "FLAG_AND_UNLOCKING_OR_UNLOCKED", "IActivityManagerSingleton", "ACTION_REPORT_HEAP_LIMIT" ]
}