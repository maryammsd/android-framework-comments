{
  "filePath" : "/home/maryam/clearblue/files/android-source-30/android/text/DynamicLayout.java",
  "packageName" : "android.text",
  "className" : "DynamicLayout",
  "comment" : "\n * DynamicLayout is a text layout that updates itself as the text is edited.\n * <p>This is used by widgets to control text layout. You should not need\n * to use this class directly unless you are implementing your own widget\n * or custom display object, or need to call\n * {@link android.graphics.Canvas#drawText(java.lang.CharSequence, int, int, float, float, android.graphics.Paint)\n *  Canvas.drawText()} directly.</p>\n ",
  "variables" : [ {
    "name" : "PRIORITY",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "BLOCK_MINIMUM_CHARACTER_LENGTH",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mBase",
    "type" : "CharSequence",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mDisplay",
    "type" : "CharSequence",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mWatcher",
    "type" : "ChangeWatcher",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mIncludePad",
    "type" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mFallbackLineSpacing",
    "type" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mEllipsize",
    "type" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mEllipsizedWidth",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mEllipsizeAt",
    "type" : "TextUtils.TruncateAt",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mBreakStrategy",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mHyphenationFrequency",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mJustificationMode",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mInts",
    "type" : "PackedIntVector",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mObjects",
    "type" : "PackedObjectVector<Directions>",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "INVALID_BLOCK_INDEX",
    "type" : "int",
    "comment" : "\n     * Value used in mBlockIndices when a block has been created or recycled and indicating that its\n     * display list needs to be re-created.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "mBlockEndLines",
    "type" : "int[]",
    "comment" : " Stores the line numbers of the last line of each block (inclusive)",
    "links" : [ ]
  }, {
    "name" : "mBlockIndices",
    "type" : "int[]",
    "comment" : " INVALID_BLOCK_INDEX if this block has been invalidated during an edition",
    "links" : [ ]
  }, {
    "name" : "mBlocksAlwaysNeedToBeRedrawn",
    "type" : "ArraySet<Integer>",
    "comment" : " Set of blocks that always need to be redrawn.",
    "links" : [ ]
  }, {
    "name" : "mNumberOfBlocks",
    "type" : "int",
    "comment" : " Number of items actually currently being used in the above 2 arrays",
    "links" : [ ]
  }, {
    "name" : "mIndexFirstChangedBlock",
    "type" : "int",
    "comment" : " The first index of the blocks whose locations are changed",
    "links" : [ ]
  }, {
    "name" : "mTopPadding",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mBottomPadding",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mTempRect",
    "type" : "Rect",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "sStaticLayout",
    "type" : "StaticLayout",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "sBuilder",
    "type" : "StaticLayout.Builder",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "sLock",
    "type" : "Object[]",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "START",
    "type" : "int",
    "comment" : " START, DIR, and TAB share the same entry.",
    "links" : [ ]
  }, {
    "name" : "DIR",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "TAB",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "TOP",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "DESCENT",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "EXTRA",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "HYPHEN",
    "type" : "int",
    "comment" : " HYPHEN and MAY_PROTRUDE_FROM_TOP_OR_BOTTOM share the same entry.",
    "links" : [ ]
  }, {
    "name" : "MAY_PROTRUDE_FROM_TOP_OR_BOTTOM",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "COLUMNS_NORMAL",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "ELLIPSIS_START",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "ELLIPSIS_COUNT",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "COLUMNS_ELLIPSIZE",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "START_MASK",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "DIR_SHIFT",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "TAB_MASK",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "HYPHEN_MASK",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "MAY_PROTRUDE_FROM_TOP_OR_BOTTOM_MASK",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "ELLIPSIS_UNDEFINED",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  } ],
  "methods" : [ {
    "name" : "private static CharSequence createEllipsizer(@Nullable TextUtils.TruncateAt ellipsize, @NonNull CharSequence display)",
    "returnType" : "CharSequence",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private void generate(@NonNull Builder b)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public void reflow(CharSequence s, int where, int before, int after)",
    "returnType" : "void",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "private boolean contentMayProtrudeFromLineTopOrBottom(CharSequence text, int start, int end)",
    "returnType" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private void createBlocks()",
    "returnType" : "void",
    "comment" : "\n     * Create the initial block structure, cutting the text into blocks of at least\n     * BLOCK_MINIMUM_CHARACTER_SIZE characters, aligned on the ends of paragraphs.\n     ",
    "links" : [ ]
  }, {
    "name" : "public ArraySet<Integer> getBlocksAlwaysNeedToBeRedrawn()",
    "returnType" : "ArraySet<Integer>",
    "comment" : "\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "private void updateAlwaysNeedsToBeRedrawn(int blockIndex)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private void addBlockAtOffset(int offset)",
    "returnType" : "void",
    "comment" : "\n     * Create a new block, ending at the specified character offset.\n     * A block will actually be created only if has at least one line, i.e. this offset is\n     * not on the end line of the previous block.\n     ",
    "links" : [ ]
  }, {
    "name" : "public void updateBlocks(int startLine, int endLine, int newLineCount)",
    "returnType" : "void",
    "comment" : "\n     * This method is called every time the layout is reflowed after an edition.\n     * It updates the internal block data structure. The text is split in blocks\n     * of contiguous lines, with at least one block for the entire text.\n     * When a range of lines is edited, new blocks (from 0 to 3 depending on the\n     * overlap structure) will replace the set of overlapping blocks.\n     * Blocks are listed in order and are represented by their ending line number.\n     * An index is associated to each block (which will be used by display lists),\n     * this class simply invalidates the index of blocks overlapping a modification.\n     *\n     * @param startLine the first line of the range of modified lines\n     * @param endLine the last line of the range, possibly equal to startLine, lower\n     * than getLineCount()\n     * @param newLineCount the number of lines that will replace the range, possibly 0\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public void setBlocksDataForTest(int[] blockEndLines, int[] blockIndices, int numberOfBlocks, int totalLines)",
    "returnType" : "void",
    "comment" : "\n     * This method is used for test purposes only.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public int[] getBlockEndLines()",
    "returnType" : "int[]",
    "comment" : "\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public int[] getBlockIndices()",
    "returnType" : "int[]",
    "comment" : "\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public int getBlockIndex(int index)",
    "returnType" : "int",
    "comment" : "\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public void setBlockIndex(int index, int blockIndex)",
    "returnType" : "void",
    "comment" : "\n     * @hide\n     * @param index\n     ",
    "links" : [ ]
  }, {
    "name" : "public int getNumberOfBlocks()",
    "returnType" : "int",
    "comment" : "\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public int getIndexFirstChangedBlock()",
    "returnType" : "int",
    "comment" : "\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public void setIndexFirstChangedBlock(int i)",
    "returnType" : "void",
    "comment" : "\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public int getLineCount()",
    "returnType" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public int getLineTop(int line)",
    "returnType" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public int getLineDescent(int line)",
    "returnType" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public int getLineExtra(int line)",
    "returnType" : "int",
    "comment" : "\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public int getLineStart(int line)",
    "returnType" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public boolean getLineContainsTab(int line)",
    "returnType" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public int getParagraphDirection(int line)",
    "returnType" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public final Directions getLineDirections(int line)",
    "returnType" : "Directions",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public int getTopPadding()",
    "returnType" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public int getBottomPadding()",
    "returnType" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public int getStartHyphenEdit(int line)",
    "returnType" : "int",
    "comment" : "\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public int getEndHyphenEdit(int line)",
    "returnType" : "int",
    "comment" : "\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "private boolean getContentMayProtrudeFromTopOrBottom(int line)",
    "returnType" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public int getEllipsizedWidth()",
    "returnType" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public int getEllipsisStart(int line)",
    "returnType" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public int getEllipsisCount(int line)",
    "returnType" : "int",
    "comment" : "",
    "links" : [ ]
  } ],
  "variableNames" : [ "PRIORITY", "BLOCK_MINIMUM_CHARACTER_LENGTH", "mBase", "mDisplay", "mWatcher", "mIncludePad", "mFallbackLineSpacing", "mEllipsize", "mEllipsizedWidth", "mEllipsizeAt", "mBreakStrategy", "mHyphenationFrequency", "mJustificationMode", "mInts", "mObjects", "INVALID_BLOCK_INDEX", "mBlockEndLines", "mBlockIndices", "mBlocksAlwaysNeedToBeRedrawn", "mNumberOfBlocks", "mIndexFirstChangedBlock", "mTopPadding", "mBottomPadding", "mTempRect", "sStaticLayout", "sBuilder", "sLock", "START", "DIR", "TAB", "TOP", "DESCENT", "EXTRA", "HYPHEN", "MAY_PROTRUDE_FROM_TOP_OR_BOTTOM", "COLUMNS_NORMAL", "ELLIPSIS_START", "ELLIPSIS_COUNT", "COLUMNS_ELLIPSIZE", "START_MASK", "DIR_SHIFT", "TAB_MASK", "HYPHEN_MASK", "MAY_PROTRUDE_FROM_TOP_OR_BOTTOM_MASK", "ELLIPSIS_UNDEFINED" ],
  "methodNames" : [ "private static CharSequence createEllipsizer(@Nullable TextUtils.TruncateAt ellipsize, @NonNull CharSequence display)", "private void generate(@NonNull Builder b)", "public void reflow(CharSequence s, int where, int before, int after)", "private boolean contentMayProtrudeFromLineTopOrBottom(CharSequence text, int start, int end)", "private void createBlocks()", "public ArraySet<Integer> getBlocksAlwaysNeedToBeRedrawn()", "private void updateAlwaysNeedsToBeRedrawn(int blockIndex)", "private void addBlockAtOffset(int offset)", "public void updateBlocks(int startLine, int endLine, int newLineCount)", "public void setBlocksDataForTest(int[] blockEndLines, int[] blockIndices, int numberOfBlocks, int totalLines)", "public int[] getBlockEndLines()", "public int[] getBlockIndices()", "public int getBlockIndex(int index)", "public void setBlockIndex(int index, int blockIndex)", "public int getNumberOfBlocks()", "public int getIndexFirstChangedBlock()", "public void setIndexFirstChangedBlock(int i)", "public int getLineCount()", "public int getLineTop(int line)", "public int getLineDescent(int line)", "public int getLineExtra(int line)", "public int getLineStart(int line)", "public boolean getLineContainsTab(int line)", "public int getParagraphDirection(int line)", "public final Directions getLineDirections(int line)", "public int getTopPadding()", "public int getBottomPadding()", "public int getStartHyphenEdit(int line)", "public int getEndHyphenEdit(int line)", "private boolean getContentMayProtrudeFromTopOrBottom(int line)", "public int getEllipsizedWidth()", "public int getEllipsisStart(int line)", "public int getEllipsisCount(int line)" ]
}