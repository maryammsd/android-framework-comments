{
  "filePath" : "/home/maryam/clearblue/files/android-source-35/java/lang/StrictMath.java",
  "packageName" : "java.lang",
  "className" : "StrictMath",
  "comment" : "\n * The class {@code StrictMath} contains methods for performing basic\n * numeric operations such as the elementary exponential, logarithm,\n * square root, and trigonometric functions.\n *\n * <p>To help ensure portability of Java programs, the definitions of\n * some of the numeric functions in this package require that they\n * produce the same results as certain published algorithms. These\n * algorithms are available from the well-known network library\n * {@code netlib} as the package \"Freely Distributable Math\n * Library,\" <a\n * href=\"https://www.netlib.org/fdlibm/\">{@code fdlibm}</a>. These\n * algorithms, which are written in the C programming language, are\n * then to be understood to be transliterated into Java and executed\n * with all floating-point and integer operations following the rules\n * of Java arithmetic. The following transformations are used in the\n * transliteration:\n *\n * <ul>\n * <li>Extraction and setting of the high and low halves of a 64-bit\n * {@code double} in C is expressed using Java platform methods that\n * perform bit-wise conversions {@linkplain\n * Double#doubleToRawLongBits(double) from {@code double} to {@code\n * long}} and {@linkplain Double#longBitsToDouble(long) {@code long}\n * to {@code double}}.\n *\n * <li>Unsigned {@code int} values in C are mapped to signed {@code\n * int} values in Java with updates to operations to replicate\n * unsigned semantics where the results on the same textual operation\n * would differ. For example, {@code >>} shifts on unsigned C values\n * are replaced with {@code >>>} shifts on signed Java values. Sized\n * comparisons on unsigned C values ({@code <}, {@code <=}, {@code >},\n * {@code >=}) are replaced with semantically equivalent calls to\n * {@link Integer#compareUnsigned(int, int) compareUnsigned}.\n * </ul>\n *\n * <p>The Java math library is defined with respect to\n * {@code fdlibm} version 5.3. Where {@code fdlibm} provides\n * more than one definition for a function (such as\n * {@code acos}), use the \"IEEE 754 core function\" version\n * (residing in a file whose name begins with the letter\n * {@code e}).  The methods which require {@code fdlibm}\n * semantics are {@code sin}, {@code cos}, {@code tan},\n * {@code asin}, {@code acos}, {@code atan},\n * {@code exp}, {@code log}, {@code log10},\n * {@code cbrt}, {@code atan2}, {@code pow},\n * {@code sinh}, {@code cosh}, {@code tanh},\n * {@code hypot}, {@code expm1}, and {@code log1p}.\n *\n * <p>\n * The platform uses signed two's complement integer arithmetic with\n * int and long primitive types.  The developer should choose\n * the primitive type to ensure that arithmetic operations consistently\n * produce correct results, which in some cases means the operations\n * will not overflow the range of values of the computation.\n * The best practice is to choose the primitive type and algorithm to avoid\n * overflow. In cases where the size is {@code int} or {@code long} and\n * overflow errors need to be detected, the methods whose names end with\n * {@code Exact} throw an {@code ArithmeticException} when the results overflow.\n *\n * <h2><a id=Ieee754RecommendedOps>IEEE 754 Recommended\n * Operations</a></h2>\n *\n * The {@link java.lang.Math Math} class discusses how the shared\n * quality of implementation criteria for selected {@code Math} and\n * {@code StrictMath} methods <a\n * href=\"Math.html#Ieee754RecommendedOps\">relate to the IEEE 754\n * recommended operations</a>.\n *\n * @see <a href=\"https://standards.ieee.org/ieee/754/6210/\">\n *      <cite>IEEE Standard for Floating-Point Arithmetic</cite></a>\n *\n * @author  Joseph D. Darcy\n * @since   1.3\n ",
  "links" : [ "java.lang.Math", "java.lang.Integer#compareUnsigned(int" ],
  "variables" : [ {
    "name" : "E",
    "type" : "double",
    "comment" : "\n     * The {@code double} value that is closer than any other to\n     * <i>e</i>, the base of the natural logarithms.\n     ",
    "links" : [ ]
  }, {
    "name" : "PI",
    "type" : "double",
    "comment" : "\n     * The {@code double} value that is closer than any other to\n     * <i>pi</i> (&pi;), the ratio of the circumference of a circle to its\n     * diameter.\n     ",
    "links" : [ ]
  }, {
    "name" : "TAU",
    "type" : "double",
    "comment" : "\n     * The {@code double} value that is closer than any other to\n     * <i>tau</i> (&tau;), the ratio of the circumference of a circle\n     * to its radius.\n     *\n     * @apiNote\n     * The value of <i>pi</i> is one half that of <i>tau</i>; in other\n     * words, <i>tau</i> is double <i>pi</i> .\n     *\n     * @since 19\n     ",
    "links" : [ ]
  }, {
    "name" : "DEGREES_TO_RADIANS",
    "type" : "double",
    "comment" : "\n     * Constant by which to multiply an angular value in degrees to obtain an\n     * angular value in radians.\n     ",
    "links" : [ ]
  }, {
    "name" : "RADIANS_TO_DEGREES",
    "type" : "double",
    "comment" : "",
    "links" : [ ]
  } ],
  "methods" : [ {
    "name" : "public static native double sin(double a)",
    "returnType" : "double",
    "comment" : " }",
    "links" : [ ]
  }, {
    "name" : "public static native double cos(double a)",
    "returnType" : "double",
    "comment" : " }",
    "links" : [ ]
  }, {
    "name" : "public static native double tan(double a)",
    "returnType" : "double",
    "comment" : " }",
    "links" : [ ]
  }, {
    "name" : "public static native double asin(double a)",
    "returnType" : "double",
    "comment" : " }",
    "links" : [ ]
  }, {
    "name" : "public static native double acos(double a)",
    "returnType" : "double",
    "comment" : " }",
    "links" : [ ]
  }, {
    "name" : "public static native double atan(double a)",
    "returnType" : "double",
    "comment" : " }",
    "links" : [ ]
  }, {
    "name" : "public static double toRadians(double angdeg)",
    "returnType" : "double",
    "comment" : "\n     * Converts an angle measured in degrees to an approximately\n     * equivalent angle measured in radians.  The conversion from\n     * degrees to radians is generally inexact.\n     *\n     * @param   angdeg   an angle, in degrees\n     * @return  the measurement of the angle {@code angdeg}\n     *          in radians.\n     ",
    "links" : [ ]
  }, {
    "name" : "public static double toDegrees(double angrad)",
    "returnType" : "double",
    "comment" : "\n     * Converts an angle measured in radians to an approximately\n     * equivalent angle measured in degrees.  The conversion from\n     * radians to degrees is generally inexact; users should\n     * <i>not</i> expect {@code cos(toRadians(90.0))} to exactly\n     * equal {@code 0.0}.\n     *\n     * @param   angrad   an angle, in radians\n     * @return  the measurement of the angle {@code angrad}\n     *          in degrees.\n     ",
    "links" : [ ]
  }, {
    "name" : "public static native double exp(double a)",
    "returnType" : "double",
    "comment" : " END Android-changed: Reimplement in native",
    "links" : [ ]
  }, {
    "name" : "public static native double log(double a)",
    "returnType" : "double",
    "comment" : " }",
    "links" : [ ]
  }, {
    "name" : "public static native double log10(double a)",
    "returnType" : "double",
    "comment" : " }",
    "links" : [ ]
  }, {
    "name" : "public static native double sqrt(double a)",
    "returnType" : "double",
    "comment" : "\n     * Returns the correctly rounded positive square root of a\n     * {@code double} value.\n     * Special cases:\n     * <ul><li>If the argument is NaN or less than zero, then the result\n     * is NaN.\n     * <li>If the argument is positive infinity, then the result is positive\n     * infinity.\n     * <li>If the argument is positive zero or negative zero, then the\n     * result is the same as the argument.</ul>\n     * Otherwise, the result is the {@code double} value closest to\n     * the true mathematical square root of the argument value.\n     *\n     * @param   a   a value.\n     * @return  the positive square root of {@code a}.\n     ",
    "links" : [ ]
  }, {
    "name" : "public static native double cbrt(double a)",
    "returnType" : "double",
    "comment" : " END Android-changed: Reimplement in native",
    "links" : [ ]
  }, {
    "name" : "public static native double IEEEremainder(double f1, double f2)",
    "returnType" : "double",
    "comment" : " }",
    "links" : [ ]
  }, {
    "name" : "public static double ceil(double a)",
    "returnType" : "double",
    "comment" : "\n     * Returns the smallest (closest to negative infinity)\n     * {@code double} value that is greater than or equal to the\n     * argument and is equal to a mathematical integer. Special cases:\n     * <ul><li>If the argument value is already equal to a\n     * mathematical integer, then the result is the same as the\n     * argument.  <li>If the argument is NaN or an infinity or\n     * positive zero or negative zero, then the result is the same as\n     * the argument.  <li>If the argument value is less than zero but\n     * greater than -1.0, then the result is negative zero.</ul> Note\n     * that the value of {@code StrictMath.ceil(x)} is exactly the\n     * value of {@code -StrictMath.floor(-x)}.\n     *\n     * @param   a   a value.\n     * @return  the smallest (closest to negative infinity)\n     *          floating-point value that is greater than or equal to\n     *          the argument and is equal to a mathematical integer.\n     ",
    "links" : [ ]
  }, {
    "name" : "public static double floor(double a)",
    "returnType" : "double",
    "comment" : "\n     * Returns the largest (closest to positive infinity)\n     * {@code double} value that is less than or equal to the\n     * argument and is equal to a mathematical integer. Special cases:\n     * <ul><li>If the argument value is already equal to a\n     * mathematical integer, then the result is the same as the\n     * argument.  <li>If the argument is NaN or an infinity or\n     * positive zero or negative zero, then the result is the same as\n     * the argument.</ul>\n     *\n     * @param   a   a value.\n     * @return  the largest (closest to positive infinity)\n     *          floating-point value that less than or equal to the argument\n     *          and is equal to a mathematical integer.\n     ",
    "links" : [ ]
  }, {
    "name" : "private static double floorOrCeil(double a, double negativeBoundary, double positiveBoundary, double sign)",
    "returnType" : "double",
    "comment" : "\n     * Internal method to share logic between floor and ceil.\n     *\n     * @param a the value to be floored or ceiled\n     * @param negativeBoundary result for values in (-1, 0)\n     * @param positiveBoundary result for values in (0, 1)\n     * @param sign the sign of the result\n     ",
    "links" : [ ]
  }, {
    "name" : "public static double rint(double a)",
    "returnType" : "double",
    "comment" : "\n     * Returns the {@code double} value that is closest in value\n     * to the argument and is equal to a mathematical integer. If two\n     * {@code double} values that are mathematical integers are\n     * equally close to the value of the argument, the result is the\n     * integer value that is even. Special cases:\n     * <ul><li>If the argument value is already equal to a mathematical\n     * integer, then the result is the same as the argument.\n     * <li>If the argument is NaN or an infinity or positive zero or negative\n     * zero, then the result is the same as the argument.</ul>\n     *\n     * @param   a   a value.\n     * @return  the closest floating-point value to {@code a} that is\n     *          equal to a mathematical integer.\n     * @author Joseph D. Darcy\n     ",
    "links" : [ ]
  }, {
    "name" : "public static native double atan2(double y, double x)",
    "returnType" : "double",
    "comment" : " }",
    "links" : [ ]
  }, {
    "name" : "public static native double pow(double a, double b)",
    "returnType" : "double",
    "comment" : " END Android-changed: Reimplement in native",
    "links" : [ ]
  }, {
    "name" : "public static int round(float a)",
    "returnType" : "int",
    "comment" : "\n     * Returns the closest {@code int} to the argument, with ties\n     * rounding to positive infinity.\n     *\n     * <p>Special cases:\n     * <ul><li>If the argument is NaN, the result is 0.\n     * <li>If the argument is negative infinity or any value less than or\n     * equal to the value of {@code Integer.MIN_VALUE}, the result is\n     * equal to the value of {@code Integer.MIN_VALUE}.\n     * <li>If the argument is positive infinity or any value greater than or\n     * equal to the value of {@code Integer.MAX_VALUE}, the result is\n     * equal to the value of {@code Integer.MAX_VALUE}.</ul>\n     *\n     * @param   a   a floating-point value to be rounded to an integer.\n     * @return  the value of the argument rounded to the nearest\n     *          {@code int} value.\n     * @see     java.lang.Integer#MAX_VALUE\n     * @see     java.lang.Integer#MIN_VALUE\n     ",
    "links" : [ ]
  }, {
    "name" : "public static long round(double a)",
    "returnType" : "long",
    "comment" : "\n     * Returns the closest {@code long} to the argument, with ties\n     * rounding to positive infinity.\n     *\n     * <p>Special cases:\n     * <ul><li>If the argument is NaN, the result is 0.\n     * <li>If the argument is negative infinity or any value less than or\n     * equal to the value of {@code Long.MIN_VALUE}, the result is\n     * equal to the value of {@code Long.MIN_VALUE}.\n     * <li>If the argument is positive infinity or any value greater than or\n     * equal to the value of {@code Long.MAX_VALUE}, the result is\n     * equal to the value of {@code Long.MAX_VALUE}.</ul>\n     *\n     * @param   a  a floating-point value to be rounded to a\n     *          {@code long}.\n     * @return  the value of the argument rounded to the nearest\n     *          {@code long} value.\n     * @see     java.lang.Long#MAX_VALUE\n     * @see     java.lang.Long#MIN_VALUE\n     ",
    "links" : [ ]
  }, {
    "name" : "public static double random()",
    "returnType" : "double",
    "comment" : "\n     * Returns a {@code double} value with a positive sign, greater\n     * than or equal to {@code 0.0} and less than {@code 1.0}.\n     * Returned values are chosen pseudorandomly with (approximately)\n     * uniform distribution from that range.\n     *\n     * <p>When this method is first called, it creates a single new\n     * pseudorandom-number generator, exactly as if by the expression\n     *\n     * <blockquote>{@code new java.util.Random()}</blockquote>\n     *\n     * This new pseudorandom-number generator is used thereafter for\n     * all calls to this method and is used nowhere else.\n     *\n     * <p>This method is properly synchronized to allow correct use by\n     * more than one thread. However, if many threads need to generate\n     * pseudorandom numbers at a great rate, it may reduce contention\n     * for each thread to have its own pseudorandom-number generator.\n     *\n     * @return  a pseudorandom {@code double} greater than or equal\n     * to {@code 0.0} and less than {@code 1.0}.\n     * @see Random#nextDouble()\n     ",
    "links" : [ ]
  }, {
    "name" : "public static int addExact(int x, int y)",
    "returnType" : "int",
    "comment" : "\n     * Returns the sum of its arguments,\n     * throwing an exception if the result overflows an {@code int}.\n     *\n     * @param x the first value\n     * @param y the second value\n     * @return the result\n     * @throws ArithmeticException if the result overflows an int\n     * @see Math#addExact(int,int)\n     * @since 1.8\n     ",
    "links" : [ ]
  }, {
    "name" : "public static long addExact(long x, long y)",
    "returnType" : "long",
    "comment" : "\n     * Returns the sum of its arguments,\n     * throwing an exception if the result overflows a {@code long}.\n     *\n     * @param x the first value\n     * @param y the second value\n     * @return the result\n     * @throws ArithmeticException if the result overflows a long\n     * @see Math#addExact(long,long)\n     * @since 1.8\n     ",
    "links" : [ ]
  }, {
    "name" : "public static int subtractExact(int x, int y)",
    "returnType" : "int",
    "comment" : "\n     * Returns the difference of the arguments,\n     * throwing an exception if the result overflows an {@code int}.\n     *\n     * @param x the first value\n     * @param y the second value to subtract from the first\n     * @return the result\n     * @throws ArithmeticException if the result overflows an int\n     * @see Math#subtractExact(int,int)\n     * @since 1.8\n     ",
    "links" : [ ]
  }, {
    "name" : "public static long subtractExact(long x, long y)",
    "returnType" : "long",
    "comment" : "\n     * Returns the difference of the arguments,\n     * throwing an exception if the result overflows a {@code long}.\n     *\n     * @param x the first value\n     * @param y the second value to subtract from the first\n     * @return the result\n     * @throws ArithmeticException if the result overflows a long\n     * @see Math#subtractExact(long,long)\n     * @since 1.8\n     ",
    "links" : [ ]
  }, {
    "name" : "public static int multiplyExact(int x, int y)",
    "returnType" : "int",
    "comment" : "\n     * Returns the product of the arguments,\n     * throwing an exception if the result overflows an {@code int}.\n     *\n     * @param x the first value\n     * @param y the second value\n     * @return the result\n     * @throws ArithmeticException if the result overflows an int\n     * @see Math#multiplyExact(int,int)\n     * @since 1.8\n     ",
    "links" : [ ]
  }, {
    "name" : "public static long multiplyExact(long x, int y)",
    "returnType" : "long",
    "comment" : "\n     * Returns the product of the arguments, throwing an exception if the result\n     * overflows a {@code long}.\n     *\n     * @param x the first value\n     * @param y the second value\n     * @return the result\n     * @throws ArithmeticException if the result overflows a long\n     * @see Math#multiplyExact(long,int)\n     * @since 9\n     ",
    "links" : [ ]
  }, {
    "name" : "public static long multiplyExact(long x, long y)",
    "returnType" : "long",
    "comment" : "\n     * Returns the product of the arguments,\n     * throwing an exception if the result overflows a {@code long}.\n     *\n     * @param x the first value\n     * @param y the second value\n     * @return the result\n     * @throws ArithmeticException if the result overflows a long\n     * @see Math#multiplyExact(long,long)\n     * @since 1.8\n     ",
    "links" : [ ]
  }, {
    "name" : "public static int divideExact(int x, int y)",
    "returnType" : "int",
    "comment" : "\n     * Returns the quotient of the arguments, throwing an exception if the\n     * result overflows an {@code int}.  Such overflow occurs in this method if\n     * {@code x} is {@link Integer#MIN_VALUE} and {@code y} is {@code -1}.\n     * In contrast, if {@code Integer.MIN_VALUE / -1} were evaluated directly,\n     * the result would be {@code Integer.MIN_VALUE} and no exception would be\n     * thrown.\n     * <p>\n     * If {@code y} is zero, an {@code ArithmeticException} is thrown\n     * (JLS {@jls 15.17.2}).\n     * <p>\n     * The built-in remainder operator \"{@code %}\" is a suitable counterpart\n     * both for this method and for the built-in division operator \"{@code /}\".\n     *\n     * @param x the dividend\n     * @param y the divisor\n     * @return the quotient {@code x / y}\n     * @throws ArithmeticException if {@code y} is zero or the quotient\n     * overflows an int\n     * @jls 15.17.2 Division Operator /\n     * @see Math#divideExact(int,int)\n     * @since 18\n     ",
    "links" : [ "java.lang.Integer#MIN_VALUE" ]
  }, {
    "name" : "public static long divideExact(long x, long y)",
    "returnType" : "long",
    "comment" : "\n     * Returns the quotient of the arguments, throwing an exception if the\n     * result overflows a {@code long}.  Such overflow occurs in this method if\n     * {@code x} is {@link Long#MIN_VALUE} and {@code y} is {@code -1}.\n     * In contrast, if {@code Long.MIN_VALUE / -1} were evaluated directly,\n     * the result would be {@code Long.MIN_VALUE} and no exception would be\n     * thrown.\n     * <p>\n     * If {@code y} is zero, an {@code ArithmeticException} is thrown\n     * (JLS {@jls 15.17.2}).\n     * <p>\n     * The built-in remainder operator \"{@code %}\" is a suitable counterpart\n     * both for this method and for the built-in division operator \"{@code /}\".\n     *\n     * @param x the dividend\n     * @param y the divisor\n     * @return the quotient {@code x / y}\n     * @throws ArithmeticException if {@code y} is zero or the quotient\n     * overflows a long\n     * @jls 15.17.2 Division Operator /\n     * @see Math#divideExact(long,long)\n     * @since 18\n     ",
    "links" : [ "java.lang.Long#MIN_VALUE" ]
  }, {
    "name" : "public static int floorDivExact(int x, int y)",
    "returnType" : "int",
    "comment" : "\n     * Returns the largest (closest to positive infinity)\n     * {@code int} value that is less than or equal to the algebraic quotient.\n     * This method is identical to {@link #floorDiv(int,int)} except that it\n     * throws an {@code ArithmeticException} when the dividend is\n     * {@linkplain Integer#MIN_VALUE Integer.MIN_VALUE} and the divisor is\n     * {@code -1} instead of ignoring the integer overflow and returning\n     * {@code Integer.MIN_VALUE}.\n     * <p>\n     * The floor modulus method {@link #floorMod(int,int)} is a suitable\n     * counterpart both for this method and for the {@link #floorDiv(int,int)}\n     * method.\n     * <p>\n     * See {@link Math#floorDiv(int, int) Math.floorDiv} for examples and\n     * a comparison to the integer division {@code /} operator.\n     *\n     * @param x the dividend\n     * @param y the divisor\n     * @return the largest (closest to positive infinity)\n     * {@code int} value that is less than or equal to the algebraic quotient.\n     * @throws ArithmeticException if the divisor {@code y} is zero, or the\n     * dividend {@code x} is {@code Integer.MIN_VALUE} and the divisor {@code y}\n     * is {@code -1}.\n     * @see Math#floorDiv(int, int)\n     * @since 18\n     ",
    "links" : [ "#floorDiv(int", "#floorMod(int", "java.lang.Math#floorDiv(int" ]
  }, {
    "name" : "public static long floorDivExact(long x, long y)",
    "returnType" : "long",
    "comment" : "\n     * Returns the largest (closest to positive infinity)\n     * {@code long} value that is less than or equal to the algebraic quotient.\n     * This method is identical to {@link #floorDiv(long,long)} except that it\n     * throws an {@code ArithmeticException} when the dividend is\n     * {@linkplain Long#MIN_VALUE Long.MIN_VALUE} and the divisor is\n     * {@code -1} instead of ignoring the integer overflow and returning\n     * {@code Long.MIN_VALUE}.\n     * <p>\n     * The floor modulus method {@link #floorMod(long,long)} is a suitable\n     * counterpart both for this method and for the {@link #floorDiv(long,long)}\n     * method.\n     * <p>\n     * For examples, see {@link Math#floorDiv(int, int) Math.floorDiv}.\n     *\n     * @param x the dividend\n     * @param y the divisor\n     * @return the largest (closest to positive infinity)\n     * {@code long} value that is less than or equal to the algebraic quotient.\n     * @throws ArithmeticException if the divisor {@code y} is zero, or the\n     * dividend {@code x} is {@code Long.MIN_VALUE} and the divisor {@code y}\n     * is {@code -1}.\n     * @see Math#floorDiv(int, int)\n     * @see Math#floorDiv(long,long)\n     * @since 18\n     ",
    "links" : [ "#floorMod(long", "#floorDiv(long", "java.lang.Math#floorDiv(int" ]
  }, {
    "name" : "public static int ceilDivExact(int x, int y)",
    "returnType" : "int",
    "comment" : "\n     * Returns the smallest (closest to negative infinity)\n     * {@code int} value that is greater than or equal to the algebraic quotient.\n     * This method is identical to {@link #ceilDiv(int,int)} except that it\n     * throws an {@code ArithmeticException} when the dividend is\n     * {@linkplain Integer#MIN_VALUE Integer.MIN_VALUE} and the divisor is\n     * {@code -1} instead of ignoring the integer overflow and returning\n     * {@code Integer.MIN_VALUE}.\n     * <p>\n     * The ceil modulus method {@link #ceilMod(int,int)} is a suitable\n     * counterpart both for this method and for the {@link #ceilDiv(int,int)}\n     * method.\n     * <p>\n     * See {@link Math#ceilDiv(int, int) Math.ceilDiv} for examples and\n     * a comparison to the integer division {@code /} operator.\n     *\n     * @param x the dividend\n     * @param y the divisor\n     * @return the smallest (closest to negative infinity)\n     * {@code int} value that is greater than or equal to the algebraic quotient.\n     * @throws ArithmeticException if the divisor {@code y} is zero, or the\n     * dividend {@code x} is {@code Integer.MIN_VALUE} and the divisor {@code y}\n     * is {@code -1}.\n     * @see Math#ceilDiv(int, int)\n     * @since 18\n     ",
    "links" : [ "#ceilMod(int", "java.lang.Math#ceilDiv(int", "#ceilDiv(int" ]
  }, {
    "name" : "public static long ceilDivExact(long x, long y)",
    "returnType" : "long",
    "comment" : "\n     * Returns the smallest (closest to negative infinity)\n     * {@code long} value that is greater than or equal to the algebraic quotient.\n     * This method is identical to {@link #ceilDiv(long,long)} except that it\n     * throws an {@code ArithmeticException} when the dividend is\n     * {@linkplain Long#MIN_VALUE Long.MIN_VALUE} and the divisor is\n     * {@code -1} instead of ignoring the integer overflow and returning\n     * {@code Long.MIN_VALUE}.\n     * <p>\n     * The ceil modulus method {@link #ceilMod(long,long)} is a suitable\n     * counterpart both for this method and for the {@link #ceilDiv(long,long)}\n     * method.\n     * <p>\n     * For examples, see {@link Math#ceilDiv(int, int) Math.ceilDiv}.\n     *\n     * @param x the dividend\n     * @param y the divisor\n     * @return the smallest (closest to negative infinity)\n     * {@code long} value that is greater than or equal to the algebraic quotient.\n     * @throws ArithmeticException if the divisor {@code y} is zero, or the\n     * dividend {@code x} is {@code Long.MIN_VALUE} and the divisor {@code y}\n     * is {@code -1}.\n     * @see Math#ceilDiv(int, int)\n     * @see Math#ceilDiv(long,long)\n     * @since 18\n     ",
    "links" : [ "#ceilMod(long", "java.lang.Math#ceilDiv(int", "#ceilDiv(long" ]
  }, {
    "name" : "public static int incrementExact(int a)",
    "returnType" : "int",
    "comment" : "\n     * Returns the argument incremented by one,\n     * throwing an exception if the result overflows an {@code int}.\n     * The overflow only occurs for {@linkplain Integer#MAX_VALUE the maximum value}.\n     *\n     * @param a the value to increment\n     * @return the result\n     * @throws ArithmeticException if the result overflows an int\n     * @see Math#incrementExact(int)\n     * @since 14\n     ",
    "links" : [ ]
  }, {
    "name" : "public static long incrementExact(long a)",
    "returnType" : "long",
    "comment" : "\n     * Returns the argument incremented by one,\n     * throwing an exception if the result overflows a {@code long}.\n     * The overflow only occurs for {@linkplain Long#MAX_VALUE the maximum value}.\n     *\n     * @param a the value to increment\n     * @return the result\n     * @throws ArithmeticException if the result overflows a long\n     * @see Math#incrementExact(long)\n     * @since 14\n     ",
    "links" : [ ]
  }, {
    "name" : "public static int decrementExact(int a)",
    "returnType" : "int",
    "comment" : "\n     * Returns the argument decremented by one,\n     * throwing an exception if the result overflows an {@code int}.\n     * The overflow only occurs for {@linkplain Integer#MIN_VALUE the minimum value}.\n     *\n     * @param a the value to decrement\n     * @return the result\n     * @throws ArithmeticException if the result overflows an int\n     * @see Math#decrementExact(int)\n     * @since 14\n     ",
    "links" : [ ]
  }, {
    "name" : "public static long decrementExact(long a)",
    "returnType" : "long",
    "comment" : "\n     * Returns the argument decremented by one,\n     * throwing an exception if the result overflows a {@code long}.\n     * The overflow only occurs for {@linkplain Long#MIN_VALUE the minimum value}.\n     *\n     * @param a the value to decrement\n     * @return the result\n     * @throws ArithmeticException if the result overflows a long\n     * @see Math#decrementExact(long)\n     * @since 14\n     ",
    "links" : [ ]
  }, {
    "name" : "public static int negateExact(int a)",
    "returnType" : "int",
    "comment" : "\n     * Returns the negation of the argument,\n     * throwing an exception if the result overflows an {@code int}.\n     * The overflow only occurs for {@linkplain Integer#MIN_VALUE the minimum value}.\n     *\n     * @param a the value to negate\n     * @return the result\n     * @throws ArithmeticException if the result overflows an int\n     * @see Math#negateExact(int)\n     * @since 14\n     ",
    "links" : [ ]
  }, {
    "name" : "public static long negateExact(long a)",
    "returnType" : "long",
    "comment" : "\n     * Returns the negation of the argument,\n     * throwing an exception if the result overflows a {@code long}.\n     * The overflow only occurs for {@linkplain Long#MIN_VALUE the minimum value}.\n     *\n     * @param a the value to negate\n     * @return the result\n     * @throws ArithmeticException if the result overflows a long\n     * @see Math#negateExact(long)\n     * @since 14\n     ",
    "links" : [ ]
  }, {
    "name" : "public static int toIntExact(long value)",
    "returnType" : "int",
    "comment" : "\n     * Returns the value of the {@code long} argument, throwing an exception\n     * if the value overflows an {@code int}.\n     *\n     * @param value the long value\n     * @return the argument as an int\n     * @throws ArithmeticException if the {@code argument} overflows an int\n     * @see Math#toIntExact(long)\n     * @since 1.8\n     ",
    "links" : [ ]
  }, {
    "name" : "public static long multiplyFull(int x, int y)",
    "returnType" : "long",
    "comment" : "\n     * Returns the exact mathematical product of the arguments.\n     *\n     * @param x the first value\n     * @param y the second value\n     * @return the result\n     * @see Math#multiplyFull(int,int)\n     * @since 9\n     ",
    "links" : [ ]
  }, {
    "name" : "public static long multiplyHigh(long x, long y)",
    "returnType" : "long",
    "comment" : "\n     * Returns as a {@code long} the most significant 64 bits of the 128-bit\n     * product of two 64-bit factors.\n     *\n     * @param x the first value\n     * @param y the second value\n     * @return the result\n     * @see #unsignedMultiplyHigh\n     * @see Math#multiplyHigh(long,long)\n     * @since 9\n     ",
    "links" : [ ]
  }, {
    "name" : "public static long unsignedMultiplyHigh(long x, long y)",
    "returnType" : "long",
    "comment" : "\n     * Returns as a {@code long} the most significant 64 bits of the unsigned\n     * 128-bit product of two unsigned 64-bit factors.\n     *\n     * @param x the first value\n     * @param y the second value\n     * @return the result\n     * @see #multiplyHigh\n     * @see Math#unsignedMultiplyHigh(long,long)\n     * @since 18\n     ",
    "links" : [ ]
  }, {
    "name" : "public static int floorDiv(int x, int y)",
    "returnType" : "int",
    "comment" : "\n     * Returns the largest (closest to positive infinity)\n     * {@code int} value that is less than or equal to the algebraic quotient.\n     * There is one special case: if the dividend is\n     * {@linkplain Integer#MIN_VALUE Integer.MIN_VALUE} and the divisor is {@code -1},\n     * then integer overflow occurs and\n     * the result is equal to {@code Integer.MIN_VALUE}.\n     * <p>\n     * See {@link Math#floorDiv(int, int) Math.floorDiv} for examples and\n     * a comparison to the integer division {@code /} operator.\n     *\n     * @param x the dividend\n     * @param y the divisor\n     * @return the largest (closest to positive infinity)\n     * {@code int} value that is less than or equal to the algebraic quotient.\n     * @throws ArithmeticException if the divisor {@code y} is zero\n     * @see Math#floorDiv(int, int)\n     * @see Math#floor(double)\n     * @since 1.8\n     ",
    "links" : [ "java.lang.Math#floorDiv(int" ]
  }, {
    "name" : "public static long floorDiv(long x, int y)",
    "returnType" : "long",
    "comment" : "\n     * Returns the largest (closest to positive infinity)\n     * {@code long} value that is less than or equal to the algebraic quotient.\n     * There is one special case: if the dividend is\n     * {@linkplain Long#MIN_VALUE Long.MIN_VALUE} and the divisor is {@code -1},\n     * then integer overflow occurs and\n     * the result is equal to {@code Long.MIN_VALUE}.\n     * <p>\n     * See {@link Math#floorDiv(int, int) Math.floorDiv} for examples and\n     * a comparison to the integer division {@code /} operator.\n     *\n     * @param x the dividend\n     * @param y the divisor\n     * @return the largest (closest to positive infinity)\n     * {@code long} value that is less than or equal to the algebraic quotient.\n     * @throws ArithmeticException if the divisor {@code y} is zero\n     * @see Math#floorDiv(long, int)\n     * @see Math#floor(double)\n     * @since 9\n     ",
    "links" : [ "java.lang.Math#floorDiv(int" ]
  }, {
    "name" : "public static long floorDiv(long x, long y)",
    "returnType" : "long",
    "comment" : "\n     * Returns the largest (closest to positive infinity)\n     * {@code long} value that is less than or equal to the algebraic quotient.\n     * There is one special case: if the dividend is\n     * {@linkplain Long#MIN_VALUE Long.MIN_VALUE} and the divisor is {@code -1},\n     * then integer overflow occurs and\n     * the result is equal to {@code Long.MIN_VALUE}.\n     * <p>\n     * See {@link Math#floorDiv(int, int) Math.floorDiv} for examples and\n     * a comparison to the integer division {@code /} operator.\n     *\n     * @param x the dividend\n     * @param y the divisor\n     * @return the largest (closest to positive infinity)\n     * {@code long} value that is less than or equal to the algebraic quotient.\n     * @throws ArithmeticException if the divisor {@code y} is zero\n     * @see Math#floorDiv(long, long)\n     * @see Math#floor(double)\n     * @since 1.8\n     ",
    "links" : [ "java.lang.Math#floorDiv(int" ]
  }, {
    "name" : "public static int floorMod(int x, int y)",
    "returnType" : "int",
    "comment" : "\n     * Returns the floor modulus of the {@code int} arguments.\n     * <p>\n     * The floor modulus is {@code r = x - (floorDiv(x, y) * y)},\n     * has the same sign as the divisor {@code y} or is zero, and\n     * is in the range of {@code -abs(y) < r < +abs(y)}.\n     *\n     * <p>\n     * The relationship between {@code floorDiv} and {@code floorMod} is such that:\n     * <ul>\n     *   <li>{@code floorDiv(x, y) * y + floorMod(x, y) == x}</li>\n     * </ul>\n     * <p>\n     * See {@link Math#floorMod(int, int) Math.floorMod} for examples and\n     * a comparison to the {@code %} operator.\n     *\n     * @param x the dividend\n     * @param y the divisor\n     * @return the floor modulus {@code x - (floorDiv(x, y) * y)}\n     * @throws ArithmeticException if the divisor {@code y} is zero\n     * @see Math#floorMod(int, int)\n     * @see StrictMath#floorDiv(int, int)\n     * @since 1.8\n     ",
    "links" : [ "java.lang.Math#floorMod(int" ]
  }, {
    "name" : "public static int floorMod(long x, int y)",
    "returnType" : "int",
    "comment" : "\n     * Returns the floor modulus of the {@code long} and {@code int} arguments.\n     * <p>\n     * The floor modulus is {@code r = x - (floorDiv(x, y) * y)},\n     * has the same sign as the divisor {@code y} or is zero, and\n     * is in the range of {@code -abs(y) < r < +abs(y)}.\n     *\n     * <p>\n     * The relationship between {@code floorDiv} and {@code floorMod} is such that:\n     * <ul>\n     *   <li>{@code floorDiv(x, y) * y + floorMod(x, y) == x}</li>\n     * </ul>\n     * <p>\n     * See {@link Math#floorMod(int, int) Math.floorMod} for examples and\n     * a comparison to the {@code %} operator.\n     *\n     * @param x the dividend\n     * @param y the divisor\n     * @return the floor modulus {@code x - (floorDiv(x, y) * y)}\n     * @throws ArithmeticException if the divisor {@code y} is zero\n     * @see Math#floorMod(long, int)\n     * @see StrictMath#floorDiv(long, int)\n     * @since 9\n     ",
    "links" : [ "java.lang.Math#floorMod(int" ]
  }, {
    "name" : "public static long floorMod(long x, long y)",
    "returnType" : "long",
    "comment" : "\n     * Returns the floor modulus of the {@code long} arguments.\n     * <p>\n     * The floor modulus is {@code r = x - (floorDiv(x, y) * y)},\n     * has the same sign as the divisor {@code y} or is zero, and\n     * is in the range of {@code -abs(y) < r < +abs(y)}.\n     *\n     * <p>\n     * The relationship between {@code floorDiv} and {@code floorMod} is such that:\n     * <ul>\n     *   <li>{@code floorDiv(x, y) * y + floorMod(x, y) == x}</li>\n     * </ul>\n     * <p>\n     * See {@link Math#floorMod(int, int) Math.floorMod} for examples and\n     * a comparison to the {@code %} operator.\n     *\n     * @param x the dividend\n     * @param y the divisor\n     * @return the floor modulus {@code x - (floorDiv(x, y) * y)}\n     * @throws ArithmeticException if the divisor {@code y} is zero\n     * @see Math#floorMod(long, long)\n     * @see StrictMath#floorDiv(long, long)\n     * @since 1.8\n     ",
    "links" : [ "java.lang.Math#floorMod(int" ]
  }, {
    "name" : "public static int ceilDiv(int x, int y)",
    "returnType" : "int",
    "comment" : "\n     * Returns the smallest (closest to negative infinity)\n     * {@code int} value that is greater than or equal to the algebraic quotient.\n     * There is one special case: if the dividend is\n     * {@linkplain Integer#MIN_VALUE Integer.MIN_VALUE} and the divisor is {@code -1},\n     * then integer overflow occurs and\n     * the result is equal to {@code Integer.MIN_VALUE}.\n     * <p>\n     * See {@link Math#ceilDiv(int, int) Math.ceilDiv} for examples and\n     * a comparison to the integer division {@code /} operator.\n     *\n     * @param x the dividend\n     * @param y the divisor\n     * @return the smallest (closest to negative infinity)\n     * {@code int} value that is greater than or equal to the algebraic quotient.\n     * @throws ArithmeticException if the divisor {@code y} is zero\n     * @see Math#ceilDiv(int, int)\n     * @see Math#ceil(double)\n     * @since 18\n     ",
    "links" : [ "java.lang.Math#ceilDiv(int" ]
  }, {
    "name" : "public static long ceilDiv(long x, int y)",
    "returnType" : "long",
    "comment" : "\n     * Returns the smallest (closest to negative infinity)\n     * {@code long} value that is greater than or equal to the algebraic quotient.\n     * There is one special case: if the dividend is\n     * {@linkplain Long#MIN_VALUE Long.MIN_VALUE} and the divisor is {@code -1},\n     * then integer overflow occurs and\n     * the result is equal to {@code Long.MIN_VALUE}.\n     * <p>\n     * See {@link Math#ceilDiv(int, int) Math.ceilDiv} for examples and\n     * a comparison to the integer division {@code /} operator.\n     *\n     * @param x the dividend\n     * @param y the divisor\n     * @return the smallest (closest to negative infinity)\n     * {@code long} value that is greater than or equal to the algebraic quotient.\n     * @throws ArithmeticException if the divisor {@code y} is zero\n     * @see Math#ceilDiv(long, int)\n     * @see Math#ceil(double)\n     * @since 18\n     ",
    "links" : [ "java.lang.Math#ceilDiv(int" ]
  }, {
    "name" : "public static long ceilDiv(long x, long y)",
    "returnType" : "long",
    "comment" : "\n     * Returns the smallest (closest to negative infinity)\n     * {@code long} value that is greater than or equal to the algebraic quotient.\n     * There is one special case: if the dividend is\n     * {@linkplain Long#MIN_VALUE Long.MIN_VALUE} and the divisor is {@code -1},\n     * then integer overflow occurs and\n     * the result is equal to {@code Long.MIN_VALUE}.\n     * <p>\n     * See {@link Math#ceilDiv(int, int) Math.ceilDiv} for examples and\n     * a comparison to the integer division {@code /} operator.\n     *\n     * @param x the dividend\n     * @param y the divisor\n     * @return the smallest (closest to negative infinity)\n     * {@code long} value that is greater than or equal to the algebraic quotient.\n     * @throws ArithmeticException if the divisor {@code y} is zero\n     * @see Math#ceilDiv(long, long)\n     * @see Math#ceil(double)\n     * @since 18\n     ",
    "links" : [ "java.lang.Math#ceilDiv(int" ]
  }, {
    "name" : "public static int ceilMod(int x, int y)",
    "returnType" : "int",
    "comment" : "\n     * Returns the ceiling modulus of the {@code int} arguments.\n     * <p>\n     * The ceiling modulus is {@code r = x - (ceilDiv(x, y) * y)},\n     * has the opposite sign as the divisor {@code y} or is zero, and\n     * is in the range of {@code -abs(y) < r < +abs(y)}.\n     *\n     * <p>\n     * The relationship between {@code ceilDiv} and {@code ceilMod} is such that:\n     * <ul>\n     *   <li>{@code ceilDiv(x, y) * y + ceilMod(x, y) == x}</li>\n     * </ul>\n     * <p>\n     * See {@link Math#ceilMod(int, int) Math.ceilMod} for examples and\n     * a comparison to the {@code %} operator.\n     *\n     * @param x the dividend\n     * @param y the divisor\n     * @return the ceiling modulus {@code x - (ceilDiv(x, y) * y)}\n     * @throws ArithmeticException if the divisor {@code y} is zero\n     * @see Math#ceilMod(int, int)\n     * @see StrictMath#ceilDiv(int, int)\n     * @since 18\n     ",
    "links" : [ "java.lang.Math#ceilMod(int" ]
  }, {
    "name" : "public static int ceilMod(long x, int y)",
    "returnType" : "int",
    "comment" : "\n     * Returns the ceiling modulus of the {@code long} and {@code int} arguments.\n     * <p>\n     * The ceiling modulus is {@code r = x - (ceilDiv(x, y) * y)},\n     * has the opposite sign as the divisor {@code y} or is zero, and\n     * is in the range of {@code -abs(y) < r < +abs(y)}.\n     *\n     * <p>\n     * The relationship between {@code ceilDiv} and {@code ceilMod} is such that:\n     * <ul>\n     *   <li>{@code ceilDiv(x, y) * y + ceilMod(x, y) == x}</li>\n     * </ul>\n     * <p>\n     * See {@link Math#ceilMod(int, int) Math.ceilMod} for examples and\n     * a comparison to the {@code %} operator.\n     *\n     * @param x the dividend\n     * @param y the divisor\n     * @return the ceiling modulus {@code x - (ceilDiv(x, y) * y)}\n     * @throws ArithmeticException if the divisor {@code y} is zero\n     * @see Math#ceilMod(long, int)\n     * @see StrictMath#ceilDiv(long, int)\n     * @since 18\n     ",
    "links" : [ "java.lang.Math#ceilMod(int" ]
  }, {
    "name" : "public static long ceilMod(long x, long y)",
    "returnType" : "long",
    "comment" : "\n     * Returns the ceiling modulus of the {@code long} arguments.\n     * <p>\n     * The ceiling modulus is {@code r = x - (ceilDiv(x, y) * y)},\n     * has the opposite sign as the divisor {@code y} or is zero, and\n     * is in the range of {@code -abs(y) < r < +abs(y)}.\n     *\n     * <p>\n     * The relationship between {@code ceilDiv} and {@code ceilMod} is such that:\n     * <ul>\n     *   <li>{@code ceilDiv(x, y) * y + ceilMod(x, y) == x}</li>\n     * </ul>\n     * <p>\n     * See {@link Math#ceilMod(int, int) Math.ceilMod} for examples and\n     * a comparison to the {@code %} operator.\n     *\n     * @param x the dividend\n     * @param y the divisor\n     * @return the ceiling modulus {@code x - (ceilDiv(x, y) * y)}\n     * @throws ArithmeticException if the divisor {@code y} is zero\n     * @see Math#ceilMod(long, long)\n     * @see StrictMath#ceilDiv(long, long)\n     * @since 18\n     ",
    "links" : [ "java.lang.Math#ceilMod(int" ]
  }, {
    "name" : "public static int abs(int a)",
    "returnType" : "int",
    "comment" : "\n     * Returns the absolute value of an {@code int} value.\n     * If the argument is not negative, the argument is returned.\n     * If the argument is negative, the negation of the argument is returned.\n     *\n     * <p>Note that if the argument is equal to the value of {@link\n     * Integer#MIN_VALUE}, the most negative representable {@code int}\n     * value, the result is that same value, which is negative. In\n     * contrast, the {@link StrictMath#absExact(int)} method throws an\n     * {@code ArithmeticException} for this value.\n     *\n     * @param   a   the  argument whose absolute value is to be determined.\n     * @return  the absolute value of the argument.\n     * @see Math#absExact(int)\n     ",
    "links" : [ "java.lang.Integer#MIN_VALUE", "java.lang.StrictMath#absExact(int)" ]
  }, {
    "name" : "public static int absExact(int a)",
    "returnType" : "int",
    "comment" : "\n     * Returns the mathematical absolute value of an {@code int} value\n     * if it is exactly representable as an {@code int}, throwing\n     * {@code ArithmeticException} if the result overflows the\n     * positive {@code int} range.\n     *\n     * <p>Since the range of two's complement integers is asymmetric\n     * with one additional negative value (JLS {@jls 4.2.1}), the\n     * mathematical absolute value of {@link Integer#MIN_VALUE}\n     * overflows the positive {@code int} range, so an exception is\n     * thrown for that argument.\n     *\n     * @param  a  the argument whose absolute value is to be determined\n     * @return the absolute value of the argument, unless overflow occurs\n     * @throws ArithmeticException if the argument is {@link Integer#MIN_VALUE}\n     * @see Math#abs(int)\n     * @see Math#absExact(int)\n     * @since 15\n     ",
    "links" : [ "java.lang.Integer#MIN_VALUE" ]
  }, {
    "name" : "public static long abs(long a)",
    "returnType" : "long",
    "comment" : "\n     * Returns the absolute value of a {@code long} value.\n     * If the argument is not negative, the argument is returned.\n     * If the argument is negative, the negation of the argument is returned.\n     *\n     * <p>Note that if the argument is equal to the value of {@link\n     * Long#MIN_VALUE}, the most negative representable {@code long}\n     * value, the result is that same value, which is negative. In\n     * contrast, the {@link StrictMath#absExact(long)} method throws\n     * an {@code ArithmeticException} for this value.\n     *\n     * @param   a   the  argument whose absolute value is to be determined.\n     * @return  the absolute value of the argument.\n     * @see Math#absExact(long)\n     ",
    "links" : [ "java.lang.Long#MIN_VALUE", "java.lang.StrictMath#absExact(long)" ]
  }, {
    "name" : "public static long absExact(long a)",
    "returnType" : "long",
    "comment" : "\n     * Returns the mathematical absolute value of an {@code long} value\n     * if it is exactly representable as an {@code long}, throwing\n     * {@code ArithmeticException} if the result overflows the\n     * positive {@code long} range.\n     *\n     * <p>Since the range of two's complement integers is asymmetric\n     * with one additional negative value (JLS {@jls 4.2.1}), the\n     * mathematical absolute value of {@link Long#MIN_VALUE} overflows\n     * the positive {@code long} range, so an exception is thrown for\n     * that argument.\n     *\n     * @param  a  the argument whose absolute value is to be determined\n     * @return the absolute value of the argument, unless overflow occurs\n     * @throws ArithmeticException if the argument is {@link Long#MIN_VALUE}\n     * @see Math#abs(long)\n     * @see Math#absExact(long)\n     * @since 15\n     ",
    "links" : [ "java.lang.Long#MIN_VALUE" ]
  }, {
    "name" : "public static float abs(float a)",
    "returnType" : "float",
    "comment" : "\n     * Returns the absolute value of a {@code float} value.\n     * If the argument is not negative, the argument is returned.\n     * If the argument is negative, the negation of the argument is returned.\n     * Special cases:\n     * <ul><li>If the argument is positive zero or negative zero, the\n     * result is positive zero.\n     * <li>If the argument is infinite, the result is positive infinity.\n     * <li>If the argument is NaN, the result is NaN.</ul>\n     *\n     * @apiNote As implied by the above, one valid implementation of\n     * this method is given by the expression below which computes a\n     * {@code float} with the same exponent and significand as the\n     * argument but with a guaranteed zero sign bit indicating a\n     * positive value: <br>\n     * {@code Float.intBitsToFloat(0x7fffffff & Float.floatToRawIntBits(a))}\n     *\n     * @param   a   the argument whose absolute value is to be determined\n     * @return  the absolute value of the argument.\n     ",
    "links" : [ ]
  }, {
    "name" : "public static double abs(double a)",
    "returnType" : "double",
    "comment" : "\n     * Returns the absolute value of a {@code double} value.\n     * If the argument is not negative, the argument is returned.\n     * If the argument is negative, the negation of the argument is returned.\n     * Special cases:\n     * <ul><li>If the argument is positive zero or negative zero, the result\n     * is positive zero.\n     * <li>If the argument is infinite, the result is positive infinity.\n     * <li>If the argument is NaN, the result is NaN.</ul>\n     *\n     * @apiNote As implied by the above, one valid implementation of\n     * this method is given by the expression below which computes a\n     * {@code double} with the same exponent and significand as the\n     * argument but with a guaranteed zero sign bit indicating a\n     * positive value: <br>\n     * {@code Double.longBitsToDouble((Double.doubleToRawLongBits(a)<<1)>>>1)}\n     *\n     * @param   a   the argument whose absolute value is to be determined\n     * @return  the absolute value of the argument.\n     ",
    "links" : [ ]
  }, {
    "name" : "public static int max(int a, int b)",
    "returnType" : "int",
    "comment" : "\n     * Returns the greater of two {@code int} values. That is, the\n     * result is the argument closer to the value of\n     * {@link Integer#MAX_VALUE}. If the arguments have the same value,\n     * the result is that same value.\n     *\n     * @param   a   an argument.\n     * @param   b   another argument.\n     * @return  the larger of {@code a} and {@code b}.\n     ",
    "links" : [ "java.lang.Integer#MAX_VALUE" ]
  }, {
    "name" : "public static long max(long a, long b)",
    "returnType" : "long",
    "comment" : "\n     * Returns the greater of two {@code long} values. That is, the\n     * result is the argument closer to the value of\n     * {@link Long#MAX_VALUE}. If the arguments have the same value,\n     * the result is that same value.\n     *\n     * @param   a   an argument.\n     * @param   b   another argument.\n     * @return  the larger of {@code a} and {@code b}.\n     ",
    "links" : [ "java.lang.Long#MAX_VALUE" ]
  }, {
    "name" : "public static float max(float a, float b)",
    "returnType" : "float",
    "comment" : "\n     * Returns the greater of two {@code float} values.  That is,\n     * the result is the argument closer to positive infinity. If the\n     * arguments have the same value, the result is that same\n     * value. If either value is NaN, then the result is NaN.  Unlike\n     * the numerical comparison operators, this method considers\n     * negative zero to be strictly smaller than positive zero. If one\n     * argument is positive zero and the other negative zero, the\n     * result is positive zero.\n     *\n     * @param   a   an argument.\n     * @param   b   another argument.\n     * @return  the larger of {@code a} and {@code b}.\n     ",
    "links" : [ ]
  }, {
    "name" : "public static double max(double a, double b)",
    "returnType" : "double",
    "comment" : "\n     * Returns the greater of two {@code double} values.  That\n     * is, the result is the argument closer to positive infinity. If\n     * the arguments have the same value, the result is that same\n     * value. If either value is NaN, then the result is NaN.  Unlike\n     * the numerical comparison operators, this method considers\n     * negative zero to be strictly smaller than positive zero. If one\n     * argument is positive zero and the other negative zero, the\n     * result is positive zero.\n     *\n     * @param   a   an argument.\n     * @param   b   another argument.\n     * @return  the larger of {@code a} and {@code b}.\n     ",
    "links" : [ ]
  }, {
    "name" : "public static int min(int a, int b)",
    "returnType" : "int",
    "comment" : "\n     * Returns the smaller of two {@code int} values. That is,\n     * the result the argument closer to the value of\n     * {@link Integer#MIN_VALUE}.  If the arguments have the same\n     * value, the result is that same value.\n     *\n     * @param   a   an argument.\n     * @param   b   another argument.\n     * @return  the smaller of {@code a} and {@code b}.\n     ",
    "links" : [ "java.lang.Integer#MIN_VALUE" ]
  }, {
    "name" : "public static long min(long a, long b)",
    "returnType" : "long",
    "comment" : "\n     * Returns the smaller of two {@code long} values. That is,\n     * the result is the argument closer to the value of\n     * {@link Long#MIN_VALUE}. If the arguments have the same\n     * value, the result is that same value.\n     *\n     * @param   a   an argument.\n     * @param   b   another argument.\n     * @return  the smaller of {@code a} and {@code b}.\n     ",
    "links" : [ "java.lang.Long#MIN_VALUE" ]
  }, {
    "name" : "public static float min(float a, float b)",
    "returnType" : "float",
    "comment" : "\n     * Returns the smaller of two {@code float} values.  That is,\n     * the result is the value closer to negative infinity. If the\n     * arguments have the same value, the result is that same\n     * value. If either value is NaN, then the result is NaN.  Unlike\n     * the numerical comparison operators, this method considers\n     * negative zero to be strictly smaller than positive zero.  If\n     * one argument is positive zero and the other is negative zero,\n     * the result is negative zero.\n     *\n     * @param   a   an argument.\n     * @param   b   another argument.\n     * @return  the smaller of {@code a} and {@code b.}\n     ",
    "links" : [ ]
  }, {
    "name" : "public static double min(double a, double b)",
    "returnType" : "double",
    "comment" : "\n     * Returns the smaller of two {@code double} values.  That\n     * is, the result is the value closer to negative infinity. If the\n     * arguments have the same value, the result is that same\n     * value. If either value is NaN, then the result is NaN.  Unlike\n     * the numerical comparison operators, this method considers\n     * negative zero to be strictly smaller than positive zero. If one\n     * argument is positive zero and the other is negative zero, the\n     * result is negative zero.\n     *\n     * @param   a   an argument.\n     * @param   b   another argument.\n     * @return  the smaller of {@code a} and {@code b}.\n     ",
    "links" : [ ]
  }, {
    "name" : "public static int clamp(long value, int min, int max)",
    "returnType" : "int",
    "comment" : "\n     * Clamps the value to fit between min and max. If the value is less\n     * than {@code min}, then {@code min} is returned. If the value is greater\n     * than {@code max}, then {@code max} is returned. Otherwise, the original\n     * value is returned.\n     * <p>\n     * While the original value of type long may not fit into the int type,\n     * the bounds have the int type, so the result always fits the int type.\n     * This allows to use method to safely cast long value to int with\n     * saturation.\n     *\n     * @param value value to clamp\n     * @param min minimal allowed value\n     * @param max maximal allowed value\n     * @return a clamped value that fits into {@code min..max} interval\n     * @throws IllegalArgumentException if {@code min > max}\n     *\n     * @since 21\n     ",
    "links" : [ ]
  }, {
    "name" : "public static long clamp(long value, long min, long max)",
    "returnType" : "long",
    "comment" : "\n     * Clamps the value to fit between min and max. If the value is less\n     * than {@code min}, then {@code min} is returned. If the value is greater\n     * than {@code max}, then {@code max} is returned. Otherwise, the original\n     * value is returned.\n     *\n     * @param value value to clamp\n     * @param min minimal allowed value\n     * @param max maximal allowed value\n     * @return a clamped value that fits into {@code min..max} interval\n     * @throws IllegalArgumentException if {@code min > max}\n     *\n     * @since 21\n     ",
    "links" : [ ]
  }, {
    "name" : "public static double clamp(double value, double min, double max)",
    "returnType" : "double",
    "comment" : "\n     * Clamps the value to fit between min and max. If the value is less\n     * than {@code min}, then {@code min} is returned. If the value is greater\n     * than {@code max}, then {@code max} is returned. Otherwise, the original\n     * value is returned. If value is NaN, the result is also NaN.\n     * <p>\n     * Unlike the numerical comparison operators, this method considers\n     * negative zero to be strictly smaller than positive zero.\n     * E.g., {@code clamp(-0.0, 0.0, 1.0)} returns 0.0.\n     *\n     * @param value value to clamp\n     * @param min minimal allowed value\n     * @param max maximal allowed value\n     * @return a clamped value that fits into {@code min..max} interval\n     * @throws IllegalArgumentException if either of {@code min} and {@code max}\n     * arguments is NaN, or {@code min > max}, or {@code min} is +0.0, and\n     * {@code max} is -0.0.\n     *\n     * @since 21\n     ",
    "links" : [ ]
  }, {
    "name" : "public static float clamp(float value, float min, float max)",
    "returnType" : "float",
    "comment" : "\n     * Clamps the value to fit between min and max. If the value is less\n     * than {@code min}, then {@code min} is returned. If the value is greater\n     * than {@code max}, then {@code max} is returned. Otherwise, the original\n     * value is returned. If value is NaN, the result is also NaN.\n     * <p>\n     * Unlike the numerical comparison operators, this method considers\n     * negative zero to be strictly smaller than positive zero.\n     * E.g., {@code clamp(-0.0f, 0.0f, 1.0f)} returns 0.0f.\n     *\n     * @param value value to clamp\n     * @param min minimal allowed value\n     * @param max maximal allowed value\n     * @return a clamped value that fits into {@code min..max} interval\n     * @throws IllegalArgumentException if either of {@code min} and {@code max}\n     * arguments is NaN, or {@code min > max}, or {@code min} is +0.0f, and\n     * {@code max} is -0.0f.\n     *\n     * @since 21\n     ",
    "links" : [ ]
  }, {
    "name" : "public static double fma(double a, double b, double c)",
    "returnType" : "double",
    "comment" : "\n     * Returns the fused multiply add of the three arguments; that is,\n     * returns the exact product of the first two arguments summed\n     * with the third argument and then rounded once to the nearest\n     * {@code double}.\n     *\n     * The rounding is done using the {@linkplain\n     * java.math.RoundingMode#HALF_EVEN round to nearest even\n     * rounding mode}.\n     *\n     * In contrast, if {@code a * b + c} is evaluated as a regular\n     * floating-point expression, two rounding errors are involved,\n     * the first for the multiply operation, the second for the\n     * addition operation.\n     *\n     * <p>Special cases:\n     * <ul>\n     * <li> If any argument is NaN, the result is NaN.\n     *\n     * <li> If one of the first two arguments is infinite and the\n     * other is zero, the result is NaN.\n     *\n     * <li> If the exact product of the first two arguments is infinite\n     * (in other words, at least one of the arguments is infinite and\n     * the other is neither zero nor NaN) and the third argument is an\n     * infinity of the opposite sign, the result is NaN.\n     *\n     * </ul>\n     *\n     * <p>Note that {@code fusedMac(a, 1.0, c)} returns the same\n     * result as ({@code a + c}).  However,\n     * {@code fusedMac(a, b, +0.0)} does <em>not</em> always return the\n     * same result as ({@code a * b}) since\n     * {@code fusedMac(-0.0, +0.0, +0.0)} is {@code +0.0} while\n     * ({@code -0.0 * +0.0}) is {@code -0.0}; {@code fusedMac(a, b, -0.0)} is\n     * equivalent to ({@code a * b}) however.\n     *\n     * @apiNote This method corresponds to the fusedMultiplyAdd\n     * operation defined in IEEE 754-2008.\n     *\n     * @param a a value\n     * @param b a value\n     * @param c a value\n     *\n     * @return (<i>a</i>&nbsp;&times;&nbsp;<i>b</i>&nbsp;+&nbsp;<i>c</i>)\n     * computed, as if with unlimited range and precision, and rounded\n     * once to the nearest {@code double} value\n     *\n     * @since 9\n     ",
    "links" : [ ]
  }, {
    "name" : "public static float fma(float a, float b, float c)",
    "returnType" : "float",
    "comment" : "\n     * Returns the fused multiply add of the three arguments; that is,\n     * returns the exact product of the first two arguments summed\n     * with the third argument and then rounded once to the nearest\n     * {@code float}.\n     *\n     * The rounding is done using the {@linkplain\n     * java.math.RoundingMode#HALF_EVEN round to nearest even\n     * rounding mode}.\n     *\n     * In contrast, if {@code a * b + c} is evaluated as a regular\n     * floating-point expression, two rounding errors are involved,\n     * the first for the multiply operation, the second for the\n     * addition operation.\n     *\n     * <p>Special cases:\n     * <ul>\n     * <li> If any argument is NaN, the result is NaN.\n     *\n     * <li> If one of the first two arguments is infinite and the\n     * other is zero, the result is NaN.\n     *\n     * <li> If the exact product of the first two arguments is infinite\n     * (in other words, at least one of the arguments is infinite and\n     * the other is neither zero nor NaN) and the third argument is an\n     * infinity of the opposite sign, the result is NaN.\n     *\n     * </ul>\n     *\n     * <p>Note that {@code fma(a, 1.0f, c)} returns the same\n     * result as ({@code a + c}).  However,\n     * {@code fma(a, b, +0.0f)} does <em>not</em> always return the\n     * same result as ({@code a * b}) since\n     * {@code fma(-0.0f, +0.0f, +0.0f)} is {@code +0.0f} while\n     * ({@code -0.0f * +0.0f}) is {@code -0.0f}; {@code fma(a, b, -0.0f)} is\n     * equivalent to ({@code a * b}) however.\n     *\n     * @apiNote This method corresponds to the fusedMultiplyAdd\n     * operation defined in IEEE 754-2008.\n     *\n     * @param a a value\n     * @param b a value\n     * @param c a value\n     *\n     * @return (<i>a</i>&nbsp;&times;&nbsp;<i>b</i>&nbsp;+&nbsp;<i>c</i>)\n     * computed, as if with unlimited range and precision, and rounded\n     * once to the nearest {@code float} value\n     *\n     * @since 9\n     ",
    "links" : [ ]
  }, {
    "name" : "public static double ulp(double d)",
    "returnType" : "double",
    "comment" : "\n     * Returns the size of an ulp of the argument.  An ulp, unit in\n     * the last place, of a {@code double} value is the positive\n     * distance between this floating-point value and the {@code\n     * double} value next larger in magnitude.  Note that for non-NaN\n     * <i>x</i>, <code>ulp(-<i>x</i>) == ulp(<i>x</i>)</code>.\n     *\n     * <p>Special Cases:\n     * <ul>\n     * <li> If the argument is NaN, then the result is NaN.\n     * <li> If the argument is positive or negative infinity, then the\n     * result is positive infinity.\n     * <li> If the argument is positive or negative zero, then the result is\n     * {@code Double.MIN_VALUE}.\n     * <li> If the argument is &plusmn;{@code Double.MAX_VALUE}, then\n     * the result is equal to 2<sup>971</sup>.\n     * </ul>\n     *\n     * @param d the floating-point value whose ulp is to be returned\n     * @return the size of an ulp of the argument\n     * @author Joseph D. Darcy\n     * @since 1.5\n     ",
    "links" : [ ]
  }, {
    "name" : "public static float ulp(float f)",
    "returnType" : "float",
    "comment" : "\n     * Returns the size of an ulp of the argument.  An ulp, unit in\n     * the last place, of a {@code float} value is the positive\n     * distance between this floating-point value and the {@code\n     * float} value next larger in magnitude.  Note that for non-NaN\n     * <i>x</i>, <code>ulp(-<i>x</i>) == ulp(<i>x</i>)</code>.\n     *\n     * <p>Special Cases:\n     * <ul>\n     * <li> If the argument is NaN, then the result is NaN.\n     * <li> If the argument is positive or negative infinity, then the\n     * result is positive infinity.\n     * <li> If the argument is positive or negative zero, then the result is\n     * {@code Float.MIN_VALUE}.\n     * <li> If the argument is &plusmn;{@code Float.MAX_VALUE}, then\n     * the result is equal to 2<sup>104</sup>.\n     * </ul>\n     *\n     * @param f the floating-point value whose ulp is to be returned\n     * @return the size of an ulp of the argument\n     * @author Joseph D. Darcy\n     * @since 1.5\n     ",
    "links" : [ ]
  }, {
    "name" : "public static double signum(double d)",
    "returnType" : "double",
    "comment" : "\n     * Returns the signum function of the argument; zero if the argument\n     * is zero, 1.0 if the argument is greater than zero, -1.0 if the\n     * argument is less than zero.\n     *\n     * <p>Special Cases:\n     * <ul>\n     * <li> If the argument is NaN, then the result is NaN.\n     * <li> If the argument is positive zero or negative zero, then the\n     *      result is the same as the argument.\n     * </ul>\n     *\n     * @param d the floating-point value whose signum is to be returned\n     * @return the signum function of the argument\n     * @author Joseph D. Darcy\n     * @since 1.5\n     ",
    "links" : [ ]
  }, {
    "name" : "public static float signum(float f)",
    "returnType" : "float",
    "comment" : "\n     * Returns the signum function of the argument; zero if the argument\n     * is zero, 1.0f if the argument is greater than zero, -1.0f if the\n     * argument is less than zero.\n     *\n     * <p>Special Cases:\n     * <ul>\n     * <li> If the argument is NaN, then the result is NaN.\n     * <li> If the argument is positive zero or negative zero, then the\n     *      result is the same as the argument.\n     * </ul>\n     *\n     * @param f the floating-point value whose signum is to be returned\n     * @return the signum function of the argument\n     * @author Joseph D. Darcy\n     * @since 1.5\n     ",
    "links" : [ ]
  }, {
    "name" : "public static native double sinh(double x)",
    "returnType" : "double",
    "comment" : " }",
    "links" : [ ]
  }, {
    "name" : "public static native double cosh(double x)",
    "returnType" : "double",
    "comment" : " }",
    "links" : [ ]
  }, {
    "name" : "public static native double tanh(double x)",
    "returnType" : "double",
    "comment" : " }",
    "links" : [ ]
  }, {
    "name" : "public static native double hypot(double x, double y)",
    "returnType" : "double",
    "comment" : " END Android-changed: Reimplement in native",
    "links" : [ ]
  }, {
    "name" : "public static native double expm1(double x)",
    "returnType" : "double",
    "comment" : " }",
    "links" : [ ]
  }, {
    "name" : "public static native double log1p(double x)",
    "returnType" : "double",
    "comment" : " }",
    "links" : [ ]
  }, {
    "name" : "public static double copySign(double magnitude, double sign)",
    "returnType" : "double",
    "comment" : "\n     * Returns the first floating-point argument with the sign of the\n     * second floating-point argument.  For this method, a NaN\n     * {@code sign} argument is always treated as if it were\n     * positive.\n     *\n     * @param magnitude  the parameter providing the magnitude of the result\n     * @param sign   the parameter providing the sign of the result\n     * @return a value with the magnitude of {@code magnitude}\n     * and the sign of {@code sign}.\n     * @since 1.6\n     ",
    "links" : [ ]
  }, {
    "name" : "public static float copySign(float magnitude, float sign)",
    "returnType" : "float",
    "comment" : "\n     * Returns the first floating-point argument with the sign of the\n     * second floating-point argument.  For this method, a NaN\n     * {@code sign} argument is always treated as if it were\n     * positive.\n     *\n     * @param magnitude  the parameter providing the magnitude of the result\n     * @param sign   the parameter providing the sign of the result\n     * @return a value with the magnitude of {@code magnitude}\n     * and the sign of {@code sign}.\n     * @since 1.6\n     ",
    "links" : [ ]
  }, {
    "name" : "public static int getExponent(float f)",
    "returnType" : "int",
    "comment" : "\n     * Returns the unbiased exponent used in the representation of a\n     * {@code float}.  Special cases:\n     *\n     * <ul>\n     * <li>If the argument is NaN or infinite, then the result is\n     * {@link Float#MAX_EXPONENT} + 1.\n     * <li>If the argument is zero or subnormal, then the result is\n     * {@link Float#MIN_EXPONENT} -1.\n     * </ul>\n     * @param f a {@code float} value\n     * @return the unbiased exponent of the argument\n     * @since 1.6\n     ",
    "links" : [ "java.lang.Float#MAX_EXPONENT", "java.lang.Float#MIN_EXPONENT" ]
  }, {
    "name" : "public static int getExponent(double d)",
    "returnType" : "int",
    "comment" : "\n     * Returns the unbiased exponent used in the representation of a\n     * {@code double}.  Special cases:\n     *\n     * <ul>\n     * <li>If the argument is NaN or infinite, then the result is\n     * {@link Double#MAX_EXPONENT} + 1.\n     * <li>If the argument is zero or subnormal, then the result is\n     * {@link Double#MIN_EXPONENT} -1.\n     * </ul>\n     * @param d a {@code double} value\n     * @return the unbiased exponent of the argument\n     * @since 1.6\n     ",
    "links" : [ "java.lang.Double#MAX_EXPONENT", "java.lang.Double#MIN_EXPONENT" ]
  }, {
    "name" : "public static double nextAfter(double start, double direction)",
    "returnType" : "double",
    "comment" : "\n     * Returns the floating-point number adjacent to the first\n     * argument in the direction of the second argument.  If both\n     * arguments compare as equal the second argument is returned.\n     *\n     * <p>Special cases:\n     * <ul>\n     * <li> If either argument is a NaN, then NaN is returned.\n     *\n     * <li> If both arguments are signed zeros, {@code direction}\n     * is returned unchanged (as implied by the requirement of\n     * returning the second argument if the arguments compare as\n     * equal).\n     *\n     * <li> If {@code start} is\n     * &plusmn;{@link Double#MIN_VALUE} and {@code direction}\n     * has a value such that the result should have a smaller\n     * magnitude, then a zero with the same sign as {@code start}\n     * is returned.\n     *\n     * <li> If {@code start} is infinite and\n     * {@code direction} has a value such that the result should\n     * have a smaller magnitude, {@link Double#MAX_VALUE} with the\n     * same sign as {@code start} is returned.\n     *\n     * <li> If {@code start} is equal to &plusmn;\n     * {@link Double#MAX_VALUE} and {@code direction} has a\n     * value such that the result should have a larger magnitude, an\n     * infinity with same sign as {@code start} is returned.\n     * </ul>\n     *\n     * @param start  starting floating-point value\n     * @param direction value indicating which of\n     * {@code start}'s neighbors or {@code start} should\n     * be returned\n     * @return The floating-point number adjacent to {@code start} in the\n     * direction of {@code direction}.\n     * @since 1.6\n     ",
    "links" : [ "java.lang.Double#MIN_VALUE", "java.lang.Double#MAX_VALUE" ]
  }, {
    "name" : "public static float nextAfter(float start, double direction)",
    "returnType" : "float",
    "comment" : "\n     * Returns the floating-point number adjacent to the first\n     * argument in the direction of the second argument.  If both\n     * arguments compare as equal a value equivalent to the second argument\n     * is returned.\n     *\n     * <p>Special cases:\n     * <ul>\n     * <li> If either argument is a NaN, then NaN is returned.\n     *\n     * <li> If both arguments are signed zeros, a value equivalent\n     * to {@code direction} is returned.\n     *\n     * <li> If {@code start} is\n     * &plusmn;{@link Float#MIN_VALUE} and {@code direction}\n     * has a value such that the result should have a smaller\n     * magnitude, then a zero with the same sign as {@code start}\n     * is returned.\n     *\n     * <li> If {@code start} is infinite and\n     * {@code direction} has a value such that the result should\n     * have a smaller magnitude, {@link Float#MAX_VALUE} with the\n     * same sign as {@code start} is returned.\n     *\n     * <li> If {@code start} is equal to &plusmn;\n     * {@link Float#MAX_VALUE} and {@code direction} has a\n     * value such that the result should have a larger magnitude, an\n     * infinity with same sign as {@code start} is returned.\n     * </ul>\n     *\n     * @param start  starting floating-point value\n     * @param direction value indicating which of\n     * {@code start}'s neighbors or {@code start} should\n     * be returned\n     * @return The floating-point number adjacent to {@code start} in the\n     * direction of {@code direction}.\n     * @since 1.6\n     ",
    "links" : [ "java.lang.Float#MIN_VALUE", "java.lang.Float#MAX_VALUE" ]
  }, {
    "name" : "public static double nextUp(double d)",
    "returnType" : "double",
    "comment" : "\n     * Returns the floating-point value adjacent to {@code d} in\n     * the direction of positive infinity.  This method is\n     * semantically equivalent to {@code nextAfter(d,\n     * Double.POSITIVE_INFINITY)}; however, a {@code nextUp}\n     * implementation may run faster than its equivalent\n     * {@code nextAfter} call.\n     *\n     * <p>Special Cases:\n     * <ul>\n     * <li> If the argument is NaN, the result is NaN.\n     *\n     * <li> If the argument is positive infinity, the result is\n     * positive infinity.\n     *\n     * <li> If the argument is zero, the result is\n     * {@link Double#MIN_VALUE}\n     *\n     * </ul>\n     *\n     * @param d starting floating-point value\n     * @return The adjacent floating-point value closer to positive\n     * infinity.\n     * @since 1.6\n     ",
    "links" : [ "java.lang.Double#MIN_VALUE" ]
  }, {
    "name" : "public static float nextUp(float f)",
    "returnType" : "float",
    "comment" : "\n     * Returns the floating-point value adjacent to {@code f} in\n     * the direction of positive infinity.  This method is\n     * semantically equivalent to {@code nextAfter(f,\n     * Float.POSITIVE_INFINITY)}; however, a {@code nextUp}\n     * implementation may run faster than its equivalent\n     * {@code nextAfter} call.\n     *\n     * <p>Special Cases:\n     * <ul>\n     * <li> If the argument is NaN, the result is NaN.\n     *\n     * <li> If the argument is positive infinity, the result is\n     * positive infinity.\n     *\n     * <li> If the argument is zero, the result is\n     * {@link Float#MIN_VALUE}\n     *\n     * </ul>\n     *\n     * @param f starting floating-point value\n     * @return The adjacent floating-point value closer to positive\n     * infinity.\n     * @since 1.6\n     ",
    "links" : [ "java.lang.Float#MIN_VALUE" ]
  }, {
    "name" : "public static double nextDown(double d)",
    "returnType" : "double",
    "comment" : "\n     * Returns the floating-point value adjacent to {@code d} in\n     * the direction of negative infinity.  This method is\n     * semantically equivalent to {@code nextAfter(d,\n     * Double.NEGATIVE_INFINITY)}; however, a\n     * {@code nextDown} implementation may run faster than its\n     * equivalent {@code nextAfter} call.\n     *\n     * <p>Special Cases:\n     * <ul>\n     * <li> If the argument is NaN, the result is NaN.\n     *\n     * <li> If the argument is negative infinity, the result is\n     * negative infinity.\n     *\n     * <li> If the argument is zero, the result is\n     * {@code -Double.MIN_VALUE}\n     *\n     * </ul>\n     *\n     * @param d  starting floating-point value\n     * @return The adjacent floating-point value closer to negative\n     * infinity.\n     * @since 1.8\n     ",
    "links" : [ ]
  }, {
    "name" : "public static float nextDown(float f)",
    "returnType" : "float",
    "comment" : "\n     * Returns the floating-point value adjacent to {@code f} in\n     * the direction of negative infinity.  This method is\n     * semantically equivalent to {@code nextAfter(f,\n     * Float.NEGATIVE_INFINITY)}; however, a\n     * {@code nextDown} implementation may run faster than its\n     * equivalent {@code nextAfter} call.\n     *\n     * <p>Special Cases:\n     * <ul>\n     * <li> If the argument is NaN, the result is NaN.\n     *\n     * <li> If the argument is negative infinity, the result is\n     * negative infinity.\n     *\n     * <li> If the argument is zero, the result is\n     * {@code -Float.MIN_VALUE}\n     *\n     * </ul>\n     *\n     * @param f  starting floating-point value\n     * @return The adjacent floating-point value closer to negative\n     * infinity.\n     * @since 1.8\n     ",
    "links" : [ ]
  }, {
    "name" : "public static double scalb(double d, int scaleFactor)",
    "returnType" : "double",
    "comment" : "\n     * Returns {@code d} &times; 2<sup>{@code scaleFactor}</sup>\n     * rounded as if performed by a single correctly rounded\n     * floating-point multiply.  If the exponent of the result is\n     * between {@link Double#MIN_EXPONENT} and {@link\n     * Double#MAX_EXPONENT}, the answer is calculated exactly.  If the\n     * exponent of the result would be larger than {@code\n     * Double.MAX_EXPONENT}, an infinity is returned.  Note that if\n     * the result is subnormal, precision may be lost; that is, when\n     * {@code scalb(x, n)} is subnormal, {@code scalb(scalb(x, n),\n     * -n)} may not equal <i>x</i>.  When the result is non-NaN, the\n     * result has the same sign as {@code d}.\n     *\n     * <p>Special cases:\n     * <ul>\n     * <li> If the first argument is NaN, NaN is returned.\n     * <li> If the first argument is infinite, then an infinity of the\n     * same sign is returned.\n     * <li> If the first argument is zero, then a zero of the same\n     * sign is returned.\n     * </ul>\n     *\n     * @param d number to be scaled by a power of two.\n     * @param scaleFactor power of 2 used to scale {@code d}\n     * @return {@code d} &times; 2<sup>{@code scaleFactor}</sup>\n     * @since 1.6\n     ",
    "links" : [ "java.lang.Double#MAX_EXPONENT", "java.lang.Double#MIN_EXPONENT" ]
  }, {
    "name" : "public static float scalb(float f, int scaleFactor)",
    "returnType" : "float",
    "comment" : "\n     * Returns {@code f} &times; 2<sup>{@code scaleFactor}</sup>\n     * rounded as if performed by a single correctly rounded\n     * floating-point multiply.  If the exponent of the result is\n     * between {@link Float#MIN_EXPONENT} and {@link\n     * Float#MAX_EXPONENT}, the answer is calculated exactly.  If the\n     * exponent of the result would be larger than {@code\n     * Float.MAX_EXPONENT}, an infinity is returned.  Note that if the\n     * result is subnormal, precision may be lost; that is, when\n     * {@code scalb(x, n)} is subnormal, {@code scalb(scalb(x, n),\n     * -n)} may not equal <i>x</i>.  When the result is non-NaN, the\n     * result has the same sign as {@code f}.\n     *\n     * <p>Special cases:\n     * <ul>\n     * <li> If the first argument is NaN, NaN is returned.\n     * <li> If the first argument is infinite, then an infinity of the\n     * same sign is returned.\n     * <li> If the first argument is zero, then a zero of the same\n     * sign is returned.\n     * </ul>\n     *\n     * @param f number to be scaled by a power of two.\n     * @param scaleFactor power of 2 used to scale {@code f}\n     * @return {@code f} &times; 2<sup>{@code scaleFactor}</sup>\n     * @since 1.6\n     ",
    "links" : [ "java.lang.Float#MAX_EXPONENT", "java.lang.Float#MIN_EXPONENT" ]
  } ],
  "methodNames" : [ "public static native double sin(double a)", "public static native double cos(double a)", "public static native double tan(double a)", "public static native double asin(double a)", "public static native double acos(double a)", "public static native double atan(double a)", "public static double toRadians(double angdeg)", "public static double toDegrees(double angrad)", "public static native double exp(double a)", "public static native double log(double a)", "public static native double log10(double a)", "public static native double sqrt(double a)", "public static native double cbrt(double a)", "public static native double IEEEremainder(double f1, double f2)", "public static double ceil(double a)", "public static double floor(double a)", "private static double floorOrCeil(double a, double negativeBoundary, double positiveBoundary, double sign)", "public static double rint(double a)", "public static native double atan2(double y, double x)", "public static native double pow(double a, double b)", "public static int round(float a)", "public static long round(double a)", "public static double random()", "public static int addExact(int x, int y)", "public static long addExact(long x, long y)", "public static int subtractExact(int x, int y)", "public static long subtractExact(long x, long y)", "public static int multiplyExact(int x, int y)", "public static long multiplyExact(long x, int y)", "public static long multiplyExact(long x, long y)", "public static int divideExact(int x, int y)", "public static long divideExact(long x, long y)", "public static int floorDivExact(int x, int y)", "public static long floorDivExact(long x, long y)", "public static int ceilDivExact(int x, int y)", "public static long ceilDivExact(long x, long y)", "public static int incrementExact(int a)", "public static long incrementExact(long a)", "public static int decrementExact(int a)", "public static long decrementExact(long a)", "public static int negateExact(int a)", "public static long negateExact(long a)", "public static int toIntExact(long value)", "public static long multiplyFull(int x, int y)", "public static long multiplyHigh(long x, long y)", "public static long unsignedMultiplyHigh(long x, long y)", "public static int floorDiv(int x, int y)", "public static long floorDiv(long x, int y)", "public static long floorDiv(long x, long y)", "public static int floorMod(int x, int y)", "public static int floorMod(long x, int y)", "public static long floorMod(long x, long y)", "public static int ceilDiv(int x, int y)", "public static long ceilDiv(long x, int y)", "public static long ceilDiv(long x, long y)", "public static int ceilMod(int x, int y)", "public static int ceilMod(long x, int y)", "public static long ceilMod(long x, long y)", "public static int abs(int a)", "public static int absExact(int a)", "public static long abs(long a)", "public static long absExact(long a)", "public static float abs(float a)", "public static double abs(double a)", "public static int max(int a, int b)", "public static long max(long a, long b)", "public static float max(float a, float b)", "public static double max(double a, double b)", "public static int min(int a, int b)", "public static long min(long a, long b)", "public static float min(float a, float b)", "public static double min(double a, double b)", "public static int clamp(long value, int min, int max)", "public static long clamp(long value, long min, long max)", "public static double clamp(double value, double min, double max)", "public static float clamp(float value, float min, float max)", "public static double fma(double a, double b, double c)", "public static float fma(float a, float b, float c)", "public static double ulp(double d)", "public static float ulp(float f)", "public static double signum(double d)", "public static float signum(float f)", "public static native double sinh(double x)", "public static native double cosh(double x)", "public static native double tanh(double x)", "public static native double hypot(double x, double y)", "public static native double expm1(double x)", "public static native double log1p(double x)", "public static double copySign(double magnitude, double sign)", "public static float copySign(float magnitude, float sign)", "public static int getExponent(float f)", "public static int getExponent(double d)", "public static double nextAfter(double start, double direction)", "public static float nextAfter(float start, double direction)", "public static double nextUp(double d)", "public static float nextUp(float f)", "public static double nextDown(double d)", "public static float nextDown(float f)", "public static double scalb(double d, int scaleFactor)", "public static float scalb(float f, int scaleFactor)" ],
  "variableNames" : [ "E", "PI", "TAU", "DEGREES_TO_RADIANS", "RADIANS_TO_DEGREES" ]
}