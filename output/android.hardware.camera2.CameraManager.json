{
  "filePath" : "/home/maryam/clearblue/files/android-source-35/android/hardware/camera2/CameraManager.java",
  "packageName" : "android.hardware.camera2",
  "className" : "CameraManager",
  "comment" : "\n * <p>A system service manager for detecting, characterizing, and connecting to\n * {@link CameraDevice CameraDevices}.</p>\n *\n * <p>For more details about communicating with camera devices, read the Camera\n * developer guide or the {@link android.hardware.camera2 camera2}\n * package documentation.</p>\n ",
  "links" : [ "android.hardware.camera2.CameraDevice", "android.hardware.camera2" ],
  "variables" : [ {
    "name" : "TAG",
    "type" : "String",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "DEBUG",
    "type" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "USE_CALLING_UID",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "API_VERSION_1",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "API_VERSION_2",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "CAMERA_TYPE_BACKWARD_COMPATIBLE",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "CAMERA_TYPE_ALL",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mCameraIdToMultiResolutionStreamConfigurationMap",
    "type" : "Map<String, Map<String, StreamConfiguration[]>>",
    "comment" : "\n     * Caches the mapping between a logical camera ID and 'MultiResolutionStreamConfigurationMap'\n     * that is calculated by {@link #getPhysicalCameraMultiResolutionConfigs} as the calculation\n     * might take many binder calls.\n     * <p>\n     * Note, this is a map of maps. The structure is:\n     * <pre>\n     * {\n     *     logicalCameraId_1 -> {\n     *         physicalCameraId_1 -> [\n     *             streamConfiguration_1,\n     *             streamConfiguration_2,\n     *             ...\n     *         ],\n     *         physicalCameraId_2 -> [...],\n     *         ...\n     *     },\n     *     logicalCameraId_2 -> {\n     *         ...\n     *     },\n     *     ...\n     * }\n     * </pre>\n     * </p>\n     ",
    "links" : [ "#getPhysicalCameraMultiResolutionConfigs" ]
  }, {
    "name" : "mContext",
    "type" : "Context",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mLock",
    "type" : "Object",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "CAMERA_OPEN_CLOSE_LISTENER_PERMISSION",
    "type" : "String",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mHasOpenCloseListenerPermission",
    "type" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mVirtualDeviceManager",
    "type" : "VirtualDeviceManager",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "OVERRIDE_CAMERA_LANDSCAPE_TO_PORTRAIT",
    "type" : "long",
    "comment" : "\n     * Force camera output to be rotated to portrait orientation on landscape cameras.\n     * Many apps do not handle this situation and display stretched images otherwise.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "LANDSCAPE_TO_PORTRAIT_PROP",
    "type" : "String",
    "comment" : "\n     * System property for allowing the above\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "ROTATION_OVERRIDE_NONE",
    "type" : "int",
    "comment" : "\n     * Does not override landscape feed to portrait.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "ROTATION_OVERRIDE_OVERRIDE_TO_PORTRAIT",
    "type" : "int",
    "comment" : "\n     * Crops and rotates landscape camera feed to portrait, and changes sensor orientation to\n     * portrait.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "ROTATION_OVERRIDE_ROTATION_ONLY",
    "type" : "int",
    "comment" : "\n     * Crops and rotates landscape camera feed to portrait, but doesn't change sensor orientation.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "ENABLE_PHYSICAL_CAMERA_CALLBACK_FOR_UNAVAILABLE_LOGICAL_CAMERA",
    "type" : "long",
    "comment" : "\n     * Enable physical camera availability callbacks when the logical camera is unavailable\n     *\n     * <p>Previously once a logical camera becomes unavailable, no\n     * {@link AvailabilityCallback#onPhysicalCameraAvailable} or\n     * {@link AvailabilityCallback#onPhysicalCameraUnavailable} will\n     * be called until the logical camera becomes available again. The\n     * results in the app opening the logical camera not able to\n     * receive physical camera availability change.</p>\n     *\n     * <p>With this change, the {@link\n     * AvailabilityCallback#onPhysicalCameraAvailable} and {@link\n     * AvailabilityCallback#onPhysicalCameraUnavailable} can still be\n     * called while the logical camera is unavailable.  </p>\n     ",
    "links" : [ "#onPhysicalCameraUnavailable", "#onPhysicalCameraAvailable" ]
  } ],
  "methods" : [ {
    "name" : "public void registerDeviceStateListener(@NonNull CameraCharacteristics chars)",
    "returnType" : "void",
    "comment" : "\n     * Register a {@link CameraCharacteristics} device state listener\n     *\n     * @param chars Camera characteristics that need to receive device state updates\n     *\n     * @hide\n     ",
    "links" : [ "android.hardware.camera2.CameraCharacteristics" ]
  }, {
    "name" : "public String[] getCameraIdList() throws CameraAccessException",
    "returnType" : "String[]",
    "comment" : "\n     * Return the list of currently connected camera devices by identifier, including\n     * cameras that may be in use by other camera API clients.\n     *\n     * <p>Non-removable cameras use integers starting at 0 for their\n     * identifiers, while removable cameras have a unique identifier for each\n     * individual device, even if they are the same model.</p>\n     *\n     * <p>This list doesn't contain physical cameras that can only be used as part of a logical\n     * multi-camera device.</p>\n     *\n     * @return The list of currently connected camera devices.\n     ",
    "links" : [ ]
  }, {
    "name" : "public String[] getCameraIdListNoLazy() throws CameraAccessException",
    "returnType" : "String[]",
    "comment" : "\n     * Similar to getCameraIdList(). However, getCamerIdListNoLazy() necessarily communicates with\n     * cameraserver in order to get the list of camera ids. This is to facilitate testing since some\n     * camera ids may go 'offline' without callbacks from cameraserver because of changes in\n     * SYSTEM_CAMERA permissions (though this is not a changeable permission, tests may call\n     * adopt(drop)ShellPermissionIdentity() and effectively change their permissions). This call\n     * affects the camera ids returned by getCameraIdList() as well. Tests which do adopt shell\n     * permission identity should not mix getCameraIdList() and getCameraListNoLazyCalls().\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public Set<Set<String>> getConcurrentCameraIds() throws CameraAccessException",
    "returnType" : "Set<Set<String>>",
    "comment" : "\n     * Return the set of combinations of currently connected camera device identifiers, which\n     * support configuring camera device sessions concurrently.\n     *\n     * <p>The devices in these combinations can be concurrently configured by the same\n     * client camera application. Using these camera devices concurrently by two different\n     * applications is not guaranteed to be supported, however.</p>\n     *\n     * <p>For concurrent operation, in chronological order :\n     * <ul>\n     * <li> Applications must first close any open cameras that have sessions configured, using\n     *   {@link CameraDevice#close}. </li>\n     * <li> All camera devices intended to be operated concurrently, must be opened using\n     *   {@link #openCamera}, before configuring sessions on any of the camera devices.</li>\n     *</ul>\n     *</p>\n     * <p>Each device in a combination, is guaranteed to support stream combinations which may be\n     * obtained by querying {@link #getCameraCharacteristics} for the key\n     * {@link android.hardware.camera2.CameraCharacteristics#SCALER_MANDATORY_CONCURRENT_STREAM_COMBINATIONS}.</p>\n     *\n     * <p>For concurrent operation, if a camera device has a non null zoom ratio range as specified\n     * by\n     * {@link android.hardware.camera2.CameraCharacteristics#CONTROL_ZOOM_RATIO_RANGE},\n     * its complete zoom ratio range may not apply. Applications can use\n     * {@link android.hardware.camera2.CaptureRequest#CONTROL_ZOOM_RATIO} >=1 and  <=\n     * {@link android.hardware.camera2.CameraCharacteristics#SCALER_AVAILABLE_MAX_DIGITAL_ZOOM}\n     * during concurrent operation.\n     * <p>\n     *\n     * <p>The set of combinations may include camera devices that may be in use by other camera API\n     * clients.</p>\n     *\n     * <p>Concurrent camera extension sessions {@link CameraExtensionSession} are not currently\n     * supported.</p>\n     *\n     * <p>The set of combinations doesn't contain physical cameras that can only be used as\n     * part of a logical multi-camera device.</p>\n     *\n     * <p> If a new camera id becomes available through\n     * {@link AvailabilityCallback#onCameraUnavailable(String)}, clients can call\n     * this method to check if new combinations of camera ids which can stream concurrently are\n     * available.\n     *\n     * @return The set of combinations of currently connected camera devices, that may have\n     *         sessions configured concurrently. The set of combinations will be empty if no such\n     *         combinations are supported by the camera subsystem.\n     *\n     * @throws CameraAccessException if the camera device has been disconnected.\n     ",
    "links" : [ "#getCameraCharacteristics", "android.hardware.camera2.CameraExtensionSession", "#onCameraUnavailable(String)", "android.hardware.camera2.CameraCharacteristics#SCALER_MANDATORY_CONCURRENT_STREAM_COMBINATIONS", "android.hardware.camera2.CameraCharacteristics#SCALER_AVAILABLE_MAX_DIGITAL_ZOOM", "android.hardware.camera2.CameraCharacteristics#CONTROL_ZOOM_RATIO_RANGE", "android.hardware.camera2.CaptureRequest#CONTROL_ZOOM_RATIO", "#openCamera", "android.hardware.camera2.CameraDevice#close" ]
  }, {
    "name" : "public boolean isConcurrentSessionConfigurationSupported(@NonNull Map<String, SessionConfiguration> cameraIdAndSessionConfig) throws CameraAccessException",
    "returnType" : "boolean",
    "comment" : "\n     * Checks whether the provided set of camera devices and their corresponding\n     * {@link SessionConfiguration} can be configured concurrently.\n     *\n     * <p>This method performs a runtime check of the given {@link SessionConfiguration} and camera\n     * id combinations. The result confirms whether or not the passed session configurations can be\n     * successfully used to create camera capture sessions concurrently, on the given camera\n     * devices using {@link CameraDevice#createCaptureSession(SessionConfiguration)}.\n     * </p>\n     *\n     * <p>The method can be called at any point before, during and after active capture sessions.\n     * It will not impact normal camera behavior in any way and must complete significantly\n     * faster than creating a regular or constrained capture session.</p>\n     *\n     * <p>Although this method is faster than creating a new capture session, it is not intended\n     * to be used for exploring the entire space of supported concurrent stream combinations. The\n     * available mandatory concurrent stream combinations may be obtained by querying\n     * {@link #getCameraCharacteristics} for the key\n     * {@link android.hardware.camera2.CameraCharacteristics#SCALER_MANDATORY_CONCURRENT_STREAM_COMBINATIONS}. </p>\n     *\n     * <p>Note that session parameters will be ignored and calls to\n     * {@link SessionConfiguration#setSessionParameters} are not required.</p>\n     *\n     * @return {@code true} if the given combination of session configurations and corresponding\n     *                      camera ids are concurrently supported by the camera sub-system,\n     *         {@code false} otherwise OR if the set of camera devices provided is not a subset of\n     *                       those returned by {@link #getConcurrentCameraIds}.\n     *\n     * @throws CameraAccessException if one of the camera devices queried is no longer connected.\n     *\n     ",
    "links" : [ "#getCameraCharacteristics", "#getConcurrentCameraIds", "android.hardware.camera2.params.ExtensionSessionConfiguration#setSessionParameters", "android.hardware.camera2.CameraCharacteristics#SCALER_MANDATORY_CONCURRENT_STREAM_COMBINATIONS", "android.hardware.camera2.params.ExtensionSessionConfiguration", "android.hardware.camera2.CameraDevice#createCaptureSession(SessionConfiguration)" ]
  }, {
    "name" : "public void registerAvailabilityCallback(@NonNull AvailabilityCallback callback, @Nullable Handler handler)",
    "returnType" : "void",
    "comment" : "\n     * Register a callback to be notified about camera device availability.\n     *\n     * <p>Registering the same callback again will replace the handler with the\n     * new one provided.</p>\n     *\n     * <p>The first time a callback is registered, it is immediately called\n     * with the availability status of all currently known camera devices.</p>\n     *\n     * <p>{@link AvailabilityCallback#onCameraUnavailable(String)} will be called whenever a camera\n     * device is opened by any camera API client. As of API level 23, other camera API clients may\n     * still be able to open such a camera device, evicting the existing client if they have higher\n     * priority than the existing client of a camera device. See open() for more details.</p>\n     *\n     * <p>Since this callback will be registered with the camera service, remember to unregister it\n     * once it is no longer needed; otherwise the callback will continue to receive events\n     * indefinitely and it may prevent other resources from being released. Specifically, the\n     * callbacks will be invoked independently of the general activity lifecycle and independently\n     * of the state of individual CameraManager instances.</p>\n     *\n     * @param callback the new callback to send camera availability notices to\n     * @param handler The handler on which the callback should be invoked, or {@code null} to use\n     *             the current thread's {@link android.os.Looper looper}.\n     *\n     * @throws IllegalArgumentException if the handler is {@code null} but the current thread has\n     *             no looper.\n     ",
    "links" : [ "#onCameraUnavailable(String)", "android.os.Looper" ]
  }, {
    "name" : "public void registerAvailabilityCallback(@NonNull @CallbackExecutor Executor executor, @NonNull AvailabilityCallback callback)",
    "returnType" : "void",
    "comment" : "\n     * Register a callback to be notified about camera device availability.\n     *\n     * <p>The behavior of this method matches that of\n     * {@link #registerAvailabilityCallback(AvailabilityCallback, Handler)},\n     * except that it uses {@link java.util.concurrent.Executor} as an argument\n     * instead of {@link android.os.Handler}.</p>\n     *\n     * <p>Note: If the order between some availability callbacks matters, the implementation of the\n     * executor should handle those callbacks in the same thread to maintain the callbacks' order.\n     * Some examples are:</p>\n     *\n     * <ul>\n     *\n     * <li>{@link AvailabilityCallback#onCameraAvailable} and\n     * {@link AvailabilityCallback#onCameraUnavailable} of the same camera ID.</li>\n     *\n     * <li>{@link AvailabilityCallback#onCameraAvailable} or\n     * {@link AvailabilityCallback#onCameraUnavailable} of a logical multi-camera, and {@link\n     * AvailabilityCallback#onPhysicalCameraUnavailable} or\n     * {@link AvailabilityCallback#onPhysicalCameraAvailable} of its physical\n     * cameras.</li>\n     *\n     * </ul>\n     *\n     * @param executor The executor which will be used to invoke the callback.\n     * @param callback the new callback to send camera availability notices to\n     *\n     * @throws IllegalArgumentException if the executor is {@code null}.\n     ",
    "links" : [ "#onPhysicalCameraUnavailable", "java.util.concurrent.Executor", "#onPhysicalCameraAvailable", "android.os.Handler", "#onCameraUnavailable", "#onCameraAvailable", "#registerAvailabilityCallback(AvailabilityCallback" ]
  }, {
    "name" : "public void unregisterAvailabilityCallback(@NonNull AvailabilityCallback callback)",
    "returnType" : "void",
    "comment" : "\n     * Remove a previously-added callback; the callback will no longer receive connection and\n     * disconnection callbacks.\n     *\n     * <p>Removing a callback that isn't registered has no effect.</p>\n     *\n     * @param callback The callback to remove from the notification list\n     ",
    "links" : [ ]
  }, {
    "name" : "public void registerTorchCallback(@NonNull TorchCallback callback, @Nullable Handler handler)",
    "returnType" : "void",
    "comment" : "\n     * Register a callback to be notified about torch mode status.\n     *\n     * <p>Registering the same callback again will replace the handler with the\n     * new one provided.</p>\n     *\n     * <p>The first time a callback is registered, it is immediately called\n     * with the torch mode status of all currently known camera devices with a flash unit.</p>\n     *\n     * <p>Since this callback will be registered with the camera service, remember to unregister it\n     * once it is no longer needed; otherwise the callback will continue to receive events\n     * indefinitely and it may prevent other resources from being released. Specifically, the\n     * callbacks will be invoked independently of the general activity lifecycle and independently\n     * of the state of individual CameraManager instances.</p>\n     *\n     * @param callback The new callback to send torch mode status to\n     * @param handler The handler on which the callback should be invoked, or {@code null} to use\n     *             the current thread's {@link android.os.Looper looper}.\n     *\n     * @throws IllegalArgumentException if the handler is {@code null} but the current thread has\n     *             no looper.\n     ",
    "links" : [ "android.os.Looper" ]
  }, {
    "name" : "public void registerTorchCallback(@NonNull @CallbackExecutor Executor executor, @NonNull TorchCallback callback)",
    "returnType" : "void",
    "comment" : "\n     * Register a callback to be notified about torch mode status.\n     *\n     * <p>The behavior of this method matches that of\n     * {@link #registerTorchCallback(TorchCallback, Handler)},\n     * except that it uses {@link java.util.concurrent.Executor} as an argument\n     * instead of {@link android.os.Handler}.</p>\n     *\n     * @param executor The executor which will be used to invoke the callback\n     * @param callback The new callback to send torch mode status to\n     *\n     * @throws IllegalArgumentException if the executor is {@code null}.\n     ",
    "links" : [ "java.util.concurrent.Executor", "android.os.Handler", "#registerTorchCallback(TorchCallback" ]
  }, {
    "name" : "public void unregisterTorchCallback(@NonNull TorchCallback callback)",
    "returnType" : "void",
    "comment" : "\n     * Remove a previously-added callback; the callback will no longer receive torch mode status\n     * callbacks.\n     *\n     * <p>Removing a callback that isn't registered has no effect.</p>\n     *\n     * @param callback The callback to remove from the notification list\n     ",
    "links" : [ ]
  }, {
    "name" : "public int getDevicePolicyFromContext(@NonNull Context context)",
    "returnType" : "int",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "private Size getDisplaySize()",
    "returnType" : "Size",
    "comment" : " TODO(b/147726300): Investigate how to support foldables/multi-display devices.",
    "links" : [ ]
  }, {
    "name" : "private Map<String, StreamConfiguration[]> getPhysicalCameraMultiResolutionConfigs(String cameraId, CameraMetadataNative info, ICameraService cameraService) throws CameraAccessException",
    "returnType" : "Map<String, StreamConfiguration[]>",
    "comment" : "\n     * Get all physical cameras' multi-resolution stream configuration map\n     *\n     * <p>For a logical multi-camera, query the map between physical camera id and\n     * the physical camera's multi-resolution stream configuration. This map is in turn\n     * combined to form the logical camera's multi-resolution stream configuration map.</p>\n     *\n     * <p>For an ultra high resolution camera, directly use\n     * android.scaler.physicalCameraMultiResolutionStreamConfigurations as the camera device's\n     * multi-resolution stream configuration map.</p>\n     ",
    "links" : [ ]
  }, {
    "name" : "public CameraCharacteristics getCameraCharacteristics(@NonNull String cameraId) throws CameraAccessException",
    "returnType" : "CameraCharacteristics",
    "comment" : "\n     * <p>Query the capabilities of a camera device. These capabilities are\n     * immutable for a given camera.</p>\n     *\n     * <p>From API level 29, this function can also be used to query the capabilities of physical\n     * cameras that can only be used as part of logical multi-camera. These cameras cannot be\n     * opened directly via {@link #openCamera}</p>\n     *\n     * <p>Also starting with API level 29, while most basic camera information is still available\n     * even without the CAMERA permission, some values are not available to apps that do not hold\n     * that permission. The keys not available are listed by\n     * {@link CameraCharacteristics#getKeysNeedingPermission}.</p>\n     *\n     * @param cameraId The id of the camera device to query. This could be either a standalone\n     * camera ID which can be directly opened by {@link #openCamera}, or a physical camera ID that\n     * can only used as part of a logical multi-camera.\n     * @return The properties of the given camera\n     *\n     * @throws IllegalArgumentException if the cameraId does not match any\n     *         known camera device.\n     * @throws CameraAccessException if the camera device has been disconnected.\n     *\n     * @see #getCameraIdList\n     * @see android.app.admin.DevicePolicyManager#setCameraDisabled\n     ",
    "links" : [ "#openCamera", "android.hardware.camera2.CameraCharacteristics#getKeysNeedingPermission" ]
  }, {
    "name" : "public CameraCharacteristics getCameraCharacteristics(@NonNull String cameraId, boolean overrideToPortrait) throws CameraAccessException",
    "returnType" : "CameraCharacteristics",
    "comment" : "\n     * <p>Query the capabilities of a camera device. These capabilities are\n     * immutable for a given camera.</p>\n     *\n     * <p>The value of {@link CameraCharacteristics.SENSOR_ORIENTATION} will change for landscape\n     * cameras depending on whether overrideToPortrait is enabled. If enabled, these cameras will\n     * appear to be portrait orientation instead, provided that the override is supported by the\n     * camera device. Only devices that can be opened by {@link #openCamera} will report a changed\n     * {@link CameraCharacteristics.SENSOR_ORIENTATION}.</p>\n     *\n     * @param cameraId The id of the camera device to query. This could be either a standalone\n     * camera ID which can be directly opened by {@link #openCamera}, or a physical camera ID that\n     * can only used as part of a logical multi-camera.\n     * @param overrideToPortrait Whether to apply the landscape to portrait override.\n     * @return The properties of the given camera\n     *\n     * @hide\n     ",
    "links" : [ "CameraCharacteristics.SENSOR_ORIENTATION", "#openCamera" ]
  }, {
    "name" : "private CameraCharacteristics getCameraCharacteristics(@NonNull String cameraId, int rotationOverride) throws CameraAccessException",
    "returnType" : "CameraCharacteristics",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public CameraCharacteristics prepareCameraCharacteristics(@NonNull String cameraId, CameraMetadataNative metadata, ICameraService cameraService) throws CameraAccessException",
    "returnType" : "CameraCharacteristics",
    "comment" : "\n     * Utility method to take a {@link CameraMetadataNative} object and wrap it into a\n     * {@link CameraCharacteristics} object that has all required fields and keys set and is fit\n     * for apps to consume.\n     *\n     * @param cameraId      camera Id that the CameraMetadataNative was fetched for.\n     * @param metadata      base CameraMetadataNative to be wrapped\n     * @param cameraService remote cameraservice instance to be used if binder calls need\n     *                      to be made.\n     * @return A CameraCharacteristics object that can be used by the apps.\n     * @hide\n     ",
    "links" : [ "android.hardware.camera2.impl.CameraMetadataNative", "android.hardware.camera2.CameraCharacteristics" ]
  }, {
    "name" : "public CameraExtensionCharacteristics getCameraExtensionCharacteristics(@NonNull String cameraId) throws CameraAccessException",
    "returnType" : "CameraExtensionCharacteristics",
    "comment" : "\n     * <p>Query the camera extension capabilities of a camera device.</p>\n     *\n     * @param cameraId The id of the camera device to query. This must be a standalone\n     * camera ID which can be directly opened by {@link #openCamera}.\n     * @return The properties of the given camera\n     *\n     * @throws IllegalArgumentException if the cameraId does not match any\n     *         known camera device.\n     * @throws CameraAccessException if the camera device has been disconnected.\n     *\n     * @see CameraExtensionCharacteristics\n     * @see CameraDevice#createExtensionSession(ExtensionSessionConfiguration)\n     * @see CameraExtensionSession\n     ",
    "links" : [ "#openCamera" ]
  }, {
    "name" : "public Map<String, CameraCharacteristics> getPhysicalIdToCharsMap(CameraCharacteristics chars) throws CameraAccessException",
    "returnType" : "Map<String, CameraCharacteristics>",
    "comment" : "\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public CameraDevice.CameraDeviceSetup getCameraDeviceSetup(@NonNull String cameraId) throws CameraAccessException",
    "returnType" : "CameraDevice.CameraDeviceSetup",
    "comment" : "\n     * Returns a {@link CameraDevice.CameraDeviceSetup} object for the given {@code cameraId},\n     * which provides limited access to CameraDevice setup and query functionality without\n     * requiring an {@link #openCamera} call. The {@link CameraDevice} can later be obtained either\n     * by calling {@link #openCamera}, or {@link CameraDevice.CameraDeviceSetup#openCamera}.\n     *\n     * <p>Support for {@link CameraDevice.CameraDeviceSetup} for a given {@code cameraId} must be\n     * checked with {@link #isCameraDeviceSetupSupported}. If {@code isCameraDeviceSetupSupported}\n     * returns {@code false} for a {@code cameraId}, this method will throw an\n     * {@link UnsupportedOperationException}</p>\n     *\n     * @param cameraId The unique identifier of the camera device for which\n     *                 {@link CameraDevice.CameraDeviceSetup} object must be constructed. This\n     *                 identifier must be present in {@link #getCameraIdList()}\n     *\n     * @return {@link CameraDevice.CameraDeviceSetup} object corresponding to the provided\n     * {@code cameraId}\n     *\n     * @throws IllegalArgumentException If {@code cameraId} is null, or if {@code cameraId} does not\n     * match any device in {@link #getCameraIdList()}.\n     * @throws CameraAccessException if the camera device is not accessible\n     * @throws UnsupportedOperationException if {@link CameraDevice.CameraDeviceSetup} instance\n     * cannot be constructed for the given {@code cameraId}, i.e.\n     * {@link #isCameraDeviceSetupSupported} returns false.\n     *\n     * @see CameraDevice.CameraDeviceSetup\n     * @see #getCameraIdList()\n     * @see #openCamera\n     ",
    "links" : [ "#isCameraDeviceSetupSupported", "CameraDevice.CameraDeviceSetup", "#getCameraIdList()", "android.hardware.camera2.CameraDevice", "CameraDevice.CameraDeviceSetup#openCamera", "#openCamera", "UnsupportedOperationException" ]
  }, {
    "name" : "private CameraDevice.CameraDeviceSetup getCameraDeviceSetupUnsafe(@NonNull String cameraId)",
    "returnType" : "CameraDevice.CameraDeviceSetup",
    "comment" : "\n     * Creates and returns a {@link CameraDeviceSetup} instance without any error checking. To\n     * be used (carefully) by callers who are sure that CameraDeviceSetup instance can be legally\n     * created and don't want to pay the latency cost of calling {@link #getCameraDeviceSetup}.\n     ",
    "links" : [ "CameraDeviceSetup", "#getCameraDeviceSetup" ]
  }, {
    "name" : "public boolean isCameraDeviceSetupSupported(@NonNull String cameraId) throws CameraAccessException",
    "returnType" : "boolean",
    "comment" : "\n     * Checks a Camera Device's characteristics to ensure that a\n     * {@link CameraDevice.CameraDeviceSetup} instance can be constructed for a given\n     * {@code cameraId}. If this method returns false for a {@code cameraId}, calling\n     * {@link #getCameraDeviceSetup} for that {@code cameraId} will throw an\n     * {@link UnsupportedOperationException}.\n     *\n     * <p>{@link CameraDevice.CameraDeviceSetup} is supported for all devices that report\n     * {@link CameraCharacteristics#INFO_SESSION_CONFIGURATION_QUERY_VERSION} >\n     * {@link android.os.Build.VERSION_CODES#UPSIDE_DOWN_CAKE}</p>\n     *\n     * @param cameraId The unique identifier of the camera device for which\n     *                 {@link CameraDevice.CameraDeviceSetup} support is being queried. This\n     *                 identifier must be present in {@link #getCameraIdList()}.\n     *\n     * @return {@code true} if {@link CameraDevice.CameraDeviceSetup} object can be constructed\n     * for the provided {@code cameraId}; {@code false} otherwise.\n     *\n     * @throws IllegalArgumentException If {@code cameraId} is null, or if {@code cameraId} does not\n     *                                  match any device in {@link #getCameraIdList()}.\n     * @throws CameraAccessException    if the camera device is not accessible\n     *\n     * @see CameraCharacteristics#INFO_SESSION_CONFIGURATION_QUERY_VERSION\n     * @see CameraDevice.CameraDeviceSetup\n     * @see #getCameraDeviceSetup(String)\n     * @see #getCameraIdList()\n     ",
    "links" : [ "#getCameraDeviceSetup", "android.os.Build.VERSION_CODES#UPSIDE_DOWN_CAKE", "CameraDevice.CameraDeviceSetup", "#getCameraIdList()", "android.hardware.camera2.CameraCharacteristics#INFO_SESSION_CONFIGURATION_QUERY_VERSION", "UnsupportedOperationException" ]
  }, {
    "name" : "private CameraDevice openCameraDeviceUserAsync(String cameraId, CameraDevice.StateCallback callback, Executor executor, final int uid, final int oomScoreOffset, int rotationOverride) throws CameraAccessException",
    "returnType" : "CameraDevice",
    "comment" : "\n     * Helper for opening a connection to a camera with the given ID.\n     *\n     * @param cameraId The unique identifier of the camera device to open\n     * @param callback The callback for the camera. Must not be null.\n     * @param executor The executor to invoke the callback with. Must not be null.\n     * @param uid      The UID of the application actually opening the camera.\n     *                 Must be USE_CALLING_UID unless the caller is a service\n     *                 that is trusted to open the device on behalf of an\n     *                 application and to forward the real UID.\n     *\n     * @throws CameraAccessException if the camera is disabled by device policy,\n     * too many camera devices are already open, or the cameraId does not match\n     * any currently available camera device.\n     *\n     * @throws SecurityException if the application does not have permission to\n     * access the camera\n     * @throws IllegalArgumentException if callback or handler is null.\n     * @return A handle to the newly-created camera device.\n     *\n     * @see #getCameraIdList\n     * @see android.app.admin.DevicePolicyManager#setCameraDisabled\n     ",
    "links" : [ ]
  }, {
    "name" : "public void openCamera(@NonNull String cameraId, @NonNull final CameraDevice.StateCallback callback, @Nullable Handler handler) throws CameraAccessException",
    "returnType" : "void",
    "comment" : "\n     * Open a connection to a camera with the given ID.\n     *\n     * <p>Use {@link #getCameraIdList} to get the list of available camera\n     * devices. Note that even if an id is listed, open may fail if the device\n     * is disconnected between the calls to {@link #getCameraIdList} and\n     * {@link #openCamera}, or if a higher-priority camera API client begins using the\n     * camera device.</p>\n     *\n     * <p>As of API level 23, devices for which the\n     * {@link AvailabilityCallback#onCameraUnavailable(String)} callback has been called due to the\n     * device being in use by a lower-priority, background camera API client can still potentially\n     * be opened by calling this method when the calling camera API client has a higher priority\n     * than the current camera API client using this device.  In general, if the top, foreground\n     * activity is running within your application process, your process will be given the highest\n     * priority when accessing the camera, and this method will succeed even if the camera device is\n     * in use by another camera API client. Any lower-priority application that loses control of the\n     * camera in this way will receive an\n     * {@link android.hardware.camera2.CameraDevice.StateCallback#onDisconnected} callback.\n     * Opening the same camera ID twice in the same application will similarly cause the\n     * {@link android.hardware.camera2.CameraDevice.StateCallback#onDisconnected} callback\n     * being fired for the {@link CameraDevice} from the first open call and all ongoing tasks\n     * being dropped.</p>\n     *\n     * <p>Once the camera is successfully opened, {@link CameraDevice.StateCallback#onOpened} will\n     * be invoked with the newly opened {@link CameraDevice}. The camera device can then be set up\n     * for operation by calling {@link CameraDevice#createCaptureSession} and\n     * {@link CameraDevice#createCaptureRequest}</p>\n     *\n     * <p>Before API level 30, when the application tries to open multiple {@link CameraDevice} of\n     * different IDs and the device does not support opening such combination, either the\n     * {@link #openCamera} will fail and throw a {@link CameraAccessException} or one or more of\n     * already opened {@link CameraDevice} will be disconnected and receive\n     * {@link android.hardware.camera2.CameraDevice.StateCallback#onDisconnected} callback. Which\n     * behavior will happen depends on the device implementation and can vary on different devices.\n     * Starting in API level 30, if the device does not support the combination of cameras being\n     * opened, it is guaranteed the {@link #openCamera} call will fail and none of existing\n     * {@link CameraDevice} will be disconnected.</p>\n     *\n     * <!--\n     * <p>Since the camera device will be opened asynchronously, any asynchronous operations done\n     * on the returned CameraDevice instance will be queued up until the device startup has\n     * completed and the callback's {@link CameraDevice.StateCallback#onOpened onOpened} method is\n     * called. The pending operations are then processed in order.</p>\n     * -->\n     * <p>If the camera becomes disconnected during initialization\n     * after this function call returns,\n     * {@link CameraDevice.StateCallback#onDisconnected} with a\n     * {@link CameraDevice} in the disconnected state (and\n     * {@link CameraDevice.StateCallback#onOpened} will be skipped).</p>\n     *\n     * <p>If opening the camera device fails, then the device callback's\n     * {@link CameraDevice.StateCallback#onError onError} method will be called, and subsequent\n     * calls on the camera device will throw a {@link CameraAccessException}.</p>\n     *\n     * @param cameraId\n     *             The unique identifier of the camera device to open\n     * @param callback\n     *             The callback which is invoked once the camera is opened\n     * @param handler\n     *             The handler on which the callback should be invoked, or\n     *             {@code null} to use the current thread's {@link android.os.Looper looper}.\n     *\n     * @throws CameraAccessException if the camera is disabled by device policy,\n     * has been disconnected, is being used by a higher-priority camera API client, or the device\n     * has reached its maximal resource and cannot open this camera device.\n     *\n     * @throws IllegalArgumentException if cameraId or the callback was null,\n     * or the cameraId does not match any currently or previously available\n     * camera device returned by {@link #getCameraIdList}.\n     *\n     * @throws SecurityException if the application does not have permission to\n     * access the camera\n     *\n     * @see #getCameraIdList\n     * @see android.app.admin.DevicePolicyManager#setCameraDisabled\n     ",
    "links" : [ "android.hardware.camera2.CameraDevice#createCaptureRequest", "#onCameraUnavailable(String)", "CameraDevice.StateCallback#onDisconnected", "CameraDevice.StateCallback#onError", "CameraDevice.StateCallback#onOpened", "android.os.Looper", "android.hardware.camera2.CameraDevice", "android.hardware.camera2.CameraAccessException", "android.hardware.camera2.CameraDevice#createCaptureSession", "#getCameraIdList", "#openCamera", "android.hardware.camera2.CameraDevice.StateCallback#onDisconnected" ]
  }, {
    "name" : "public void openCamera(@NonNull String cameraId, boolean overrideToPortrait, @Nullable Handler handler, @NonNull final CameraDevice.StateCallback callback) throws CameraAccessException",
    "returnType" : "void",
    "comment" : "\n     * Open a connection to a camera with the given ID. Also specify overrideToPortrait for testing.\n     *\n     * @param cameraId\n     *             The unique identifier of the camera device to open\n     * @param handler\n     *             The handler on which the callback should be invoked, or\n     *             {@code null} to use the current thread's {@link android.os.Looper looper}.\n     * @param callback\n     *             The callback which is invoked once the camera is opened\n     * @param overrideToPortrait\n     *             Whether to apply the landscape to portrait override, using rotate and crop.\n     *\n     * @throws CameraAccessException if the camera is disabled by device policy,\n     * has been disconnected, or is being used by a higher-priority camera API client.\n     *\n     * @throws IllegalArgumentException if cameraId, the callback or the executor was null,\n     * or the cameraId does not match any currently or previously available\n     * camera device.\n     *\n     * @throws SecurityException if the application does not have permission to\n     * access the camera\n     *\n     * @see #getCameraIdList\n     * @see android.app.admin.DevicePolicyManager#setCameraDisabled\n     *\n     * @hide\n     ",
    "links" : [ "android.os.Looper" ]
  }, {
    "name" : "public void openCamera(@NonNull String cameraId, @NonNull @CallbackExecutor Executor executor, @NonNull final CameraDevice.StateCallback callback) throws CameraAccessException",
    "returnType" : "void",
    "comment" : "\n     * Open a connection to a camera with the given ID.\n     *\n     * <p>The behavior of this method matches that of\n     * {@link #openCamera(String, StateCallback, Handler)}, except that it uses\n     * {@link java.util.concurrent.Executor} as an argument instead of\n     * {@link android.os.Handler}.</p>\n     *\n     * <p>Do note that typically callbacks are expected to be dispatched\n     * by the executor in a single thread. If the executor uses two or\n     * more threads to dispatch callbacks, then clients must ensure correct\n     * synchronization and must also be able to handle potentially different\n     * ordering of the incoming callbacks.</p>\n     *\n     * @param cameraId\n     *             The unique identifier of the camera device to open\n     * @param executor\n     *             The executor which will be used when invoking the callback.\n     * @param callback\n     *             The callback which is invoked once the camera is opened\n     *\n     * @throws CameraAccessException if the camera is disabled by device policy,\n     * has been disconnected, or is being used by a higher-priority camera API client.\n     *\n     * @throws IllegalArgumentException if cameraId, the callback or the executor was null,\n     * or the cameraId does not match any currently or previously available\n     * camera device.\n     *\n     * @throws SecurityException if the application does not have permission to\n     * access the camera\n     *\n     * @see #getCameraIdList\n     * @see android.app.admin.DevicePolicyManager#setCameraDisabled\n     ",
    "links" : [ "java.util.concurrent.Executor", "android.os.Handler", "#openCamera(String" ]
  }, {
    "name" : "public void openCamera(@NonNull String cameraId, int oomScoreOffset, @NonNull @CallbackExecutor Executor executor, @NonNull final CameraDevice.StateCallback callback) throws CameraAccessException",
    "returnType" : "void",
    "comment" : "\n     * Open a connection to a camera with the given ID. Also specify what oom score must be offset\n     * by cameraserver for this client. This api can be useful for system\n     * components which want to assume a lower priority (for camera arbitration) than other clients\n     * which it might contend for camera devices with. Increasing the oom score of a client reduces\n     * its priority when the camera framework manages camera arbitration.\n     * Considering typical use cases:\n     *\n     * 1) oom score(apps hosting activities visible to the user) - oom score(of a foreground app)\n     *    is approximately 100.\n     *\n     * 2) The oom score (process which hosts components which that are perceptible to the user /\n     *    native vendor camera clients) - oom (foreground app) is approximately 200.\n     *\n     * 3) The oom score (process which is cached hosting activities not visible) - oom (foreground\n     *    app) is approximately 999.\n     *\n     * <p>The behavior of this method matches that of\n     * {@link #openCamera(String, StateCallback, Handler)}, except that it uses\n     * {@link java.util.concurrent.Executor} as an argument instead of\n     * {@link android.os.Handler}.</p>\n     *\n     * @param cameraId\n     *             The unique identifier of the camera device to open\n     * @param executor\n     *             The executor which will be used when invoking the callback.\n     * @param callback\n     *             The callback which is invoked once the camera is opened\n     * @param oomScoreOffset\n     *             The value by which the oom score of this client must be offset by the camera\n     *             framework in order to assist it with camera arbitration. This value must be > 0.\n     *             A positive value lowers the priority of this camera client compared to what the\n     *             camera framework would have originally seen.\n     *\n     * @throws CameraAccessException if the camera is disabled by device policy,\n     * has been disconnected, or is being used by a higher-priority camera API client.\n     *\n     * @throws IllegalArgumentException if cameraId, the callback or the executor was null,\n     * or the cameraId does not match any currently or previously available\n     * camera device.\n     *\n     * @throws SecurityException if the application does not have permission to\n     * access the camera\n     *\n     * @see #getCameraIdList\n     * @see android.app.admin.DevicePolicyManager#setCameraDisabled\n     *\n     * @hide\n     ",
    "links" : [ "java.util.concurrent.Executor", "android.os.Handler", "#openCamera(String" ]
  }, {
    "name" : "public void openCameraForUid(@NonNull String cameraId, @NonNull final CameraDevice.StateCallback callback, @NonNull Executor executor, int clientUid, int oomScoreOffset, int rotationOverride) throws CameraAccessException",
    "returnType" : "void",
    "comment" : "\n     * Open a connection to a camera with the given ID, on behalf of another application\n     * specified by clientUid. Also specify the minimum oom score and process state the application\n     * should have, as seen by the cameraserver.\n     *\n     * <p>The behavior of this method matches that of {@link #openCamera}, except that it allows\n     * the caller to specify the UID to use for permission/etc verification. This can only be\n     * done by services trusted by the camera subsystem to act on behalf of applications and\n     * to forward the real UID.</p>\n     *\n     * @param clientUid\n     *             The UID of the application on whose behalf the camera is being opened.\n     *             Must be USE_CALLING_UID unless the caller is a trusted service.\n     * @param oomScoreOffset\n     *             The minimum oom score that cameraservice must see for this client.\n     * @param rotationOverride\n     *             The type of rotation override (none, override_to_portrait, rotation_only)\n     *             that should be followed for this camera id connection\n     * @hide\n     ",
    "links" : [ "#openCamera" ]
  }, {
    "name" : "public void openCameraForUid(@NonNull String cameraId, @NonNull final CameraDevice.StateCallback callback, @NonNull Executor executor, int clientUid) throws CameraAccessException",
    "returnType" : "void",
    "comment" : "\n     * Open a connection to a camera with the given ID, on behalf of another application\n     * specified by clientUid.\n     *\n     * <p>The behavior of this method matches that of {@link #openCamera}, except that it allows\n     * the caller to specify the UID to use for permission/etc verification. This can only be\n     * done by services trusted by the camera subsystem to act on behalf of applications and\n     * to forward the real UID.</p>\n     *\n     * @param clientUid\n     *             The UID of the application on whose behalf the camera is being opened.\n     *             Must be USE_CALLING_UID unless the caller is a trusted service.\n     *\n     * @hide\n     ",
    "links" : [ "#openCamera" ]
  }, {
    "name" : "public void setTorchMode(@NonNull String cameraId, boolean enabled) throws CameraAccessException",
    "returnType" : "void",
    "comment" : "\n     * Set the flash unit's torch mode of the camera of the given ID without opening the camera\n     * device.\n     *\n     * <p>Use {@link #getCameraIdList} to get the list of available camera devices and use\n     * {@link #getCameraCharacteristics} to check whether the camera device has a flash unit.\n     * Note that even if a camera device has a flash unit, turning on the torch mode may fail\n     * if the camera device or other camera resources needed to turn on the torch mode are in use.\n     * </p>\n     *\n     * <p> If {@link #setTorchMode} is called to turn on or off the torch mode successfully,\n     * {@link CameraManager.TorchCallback#onTorchModeChanged} will be invoked.\n     * However, even if turning on the torch mode is successful, the application does not have the\n     * exclusive ownership of the flash unit or the camera device. The torch mode will be turned\n     * off and becomes unavailable when the camera device that the flash unit belongs to becomes\n     * unavailable or when other camera resources to keep the torch on become unavailable (\n     * {@link CameraManager.TorchCallback#onTorchModeUnavailable} will be invoked). Also,\n     * other applications are free to call {@link #setTorchMode} to turn off the torch mode (\n     * {@link CameraManager.TorchCallback#onTorchModeChanged} will be invoked). If the latest\n     * application that turned on the torch mode exits, the torch mode will be turned off.\n     *\n     * @param cameraId\n     *             The unique identifier of the camera device that the flash unit belongs to.\n     * @param enabled\n     *             The desired state of the torch mode for the target camera device. Set to\n     *             {@code true} to turn on the torch mode. Set to {@code false} to turn off the\n     *             torch mode.\n     *\n     * @throws CameraAccessException if it failed to access the flash unit.\n     *             {@link CameraAccessException#CAMERA_IN_USE} will be thrown if the camera device\n     *             is in use. {@link CameraAccessException#MAX_CAMERAS_IN_USE} will be thrown if\n     *             other camera resources needed to turn on the torch mode are in use.\n     *             {@link CameraAccessException#CAMERA_DISCONNECTED} will be thrown if camera\n     *             service is not available.\n     *\n     * @throws IllegalArgumentException if cameraId was null, cameraId doesn't match any currently\n     *             or previously available camera device, or the camera device doesn't have a\n     *             flash unit.\n     ",
    "links" : [ "#getCameraCharacteristics", "#setTorchMode", "android.hardware.camera2.CameraAccessException#MAX_CAMERAS_IN_USE", "android.hardware.camera2.CameraAccessException#CAMERA_DISCONNECTED", "#getCameraIdList", "CameraManager.TorchCallback#onTorchModeUnavailable", "CameraManager.TorchCallback#onTorchModeChanged", "android.hardware.camera2.CameraAccessException#CAMERA_IN_USE" ]
  }, {
    "name" : "public void turnOnTorchWithStrengthLevel(@NonNull String cameraId, int torchStrength) throws CameraAccessException",
    "returnType" : "void",
    "comment" : "\n     * Set the brightness level of the flashlight associated with the given cameraId in torch\n     * mode. If the torch is OFF and torchStrength is >= 1, torch will turn ON with the\n     * strength level specified in torchStrength.\n     *\n     * <p>Use\n     * {@link android.hardware.camera2.CameraCharacteristics#FLASH_INFO_STRENGTH_MAXIMUM_LEVEL}\n     * to check whether the camera device supports flash unit strength control or not. If this value\n     * is greater than 1, applications can call this API to control the flashlight brightness level.\n     * </p>\n     *\n     * <p>If {@link #turnOnTorchWithStrengthLevel} is called to change the brightness level of the\n     * flash unit {@link CameraManager.TorchCallback#onTorchStrengthLevelChanged} will be invoked.\n     * If the new desired strength level is same as previously set level, then this callback will\n     * not be invoked.\n     * If the torch is OFF and {@link #turnOnTorchWithStrengthLevel} is called with level >= 1,\n     * the torch will be turned ON with that brightness level. In this case\n     * {@link CameraManager.TorchCallback#onTorchModeChanged} will also be invoked.\n     * </p>\n     *\n     * <p>When the torch is turned OFF via {@link #setTorchMode}, the flashlight brightness level\n     * will reset to default value\n     * {@link android.hardware.camera2.CameraCharacteristics#FLASH_INFO_STRENGTH_DEFAULT_LEVEL}\n     * In this case the {@link CameraManager.TorchCallback#onTorchStrengthLevelChanged} will not be\n     * invoked.\n     * </p>\n     *\n     * <p>If torch is enabled via {@link #setTorchMode} after calling\n     * {@link #turnOnTorchWithStrengthLevel} with level N then the flash unit will have the\n     * brightness level N.\n     * Since multiple applications are free to call {@link #setTorchMode}, when the latest\n     * application that turned ON the torch mode exits, the torch mode will be turned OFF\n     * and in this case the brightness level will reset to default level.\n     * </p>\n     *\n     * @param cameraId\n     *             The unique identifier of the camera device that the flash unit belongs to.\n     * @param torchStrength\n     *             The desired brightness level to be set for the flash unit in the range 1 to\n     *             {@link android.hardware.camera2.CameraCharacteristics#FLASH_INFO_STRENGTH_MAXIMUM_LEVEL}.\n     *\n     * @throws CameraAccessException if it failed to access the flash unit.\n     *             {@link CameraAccessException#CAMERA_IN_USE} will be thrown if the camera device\n     *             is in use. {@link CameraAccessException#MAX_CAMERAS_IN_USE} will be thrown if\n     *             other camera resources needed to turn on the torch mode are in use.\n     *             {@link CameraAccessException#CAMERA_DISCONNECTED} will be thrown if camera\n     *             service is not available.\n     * @throws IllegalArgumentException if cameraId was null, cameraId doesn't match any currently\n     *              or previously available camera device, the camera device doesn't have a\n     *              flash unit or if torchStrength is not within the range i.e. is greater than\n     *              the maximum level\n     *              {@link android.hardware.camera2.CameraCharacteristics#FLASH_INFO_STRENGTH_MAXIMUM_LEVEL}\n     *              or <= 0.\n     *\n     ",
    "links" : [ "#setTorchMode", "android.hardware.camera2.CameraAccessException#MAX_CAMERAS_IN_USE", "android.hardware.camera2.CameraAccessException#CAMERA_DISCONNECTED", "android.hardware.camera2.CameraCharacteristics#FLASH_INFO_STRENGTH_MAXIMUM_LEVEL", "#turnOnTorchWithStrengthLevel", "android.hardware.camera2.CameraCharacteristics#FLASH_INFO_STRENGTH_DEFAULT_LEVEL", "CameraManager.TorchCallback#onTorchStrengthLevelChanged", "CameraManager.TorchCallback#onTorchModeChanged", "android.hardware.camera2.CameraAccessException#CAMERA_IN_USE" ]
  }, {
    "name" : "public int getTorchStrengthLevel(@NonNull String cameraId) throws CameraAccessException",
    "returnType" : "int",
    "comment" : "\n     * Returns the brightness level of the flash unit associated with the cameraId.\n     *\n     * @param cameraId\n     *              The unique identifier of the camera device that the flash unit belongs to.\n     * @return The brightness level of the flash unit associated with cameraId.\n     *         When the torch is turned OFF, the strength level will reset to a default level\n     *         {@link android.hardware.camera2.CameraCharacteristics#FLASH_INFO_STRENGTH_DEFAULT_LEVEL}.\n     *         In this case the return value will be\n     *         {@link android.hardware.camera2.CameraCharacteristics#FLASH_INFO_STRENGTH_DEFAULT_LEVEL}\n     *         rather than 0.\n     *\n     * @throws CameraAccessException if it failed to access the flash unit.\n     * @throws IllegalArgumentException if cameraId was null, cameraId doesn't match any currently\n     *              or previously available camera device, or the camera device doesn't have a\n     *              flash unit.\n     *\n     ",
    "links" : [ "android.hardware.camera2.CameraCharacteristics#FLASH_INFO_STRENGTH_DEFAULT_LEVEL" ]
  }, {
    "name" : "public static int getRotationOverride(@Nullable Context context)",
    "returnType" : "int",
    "comment" : "\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public static int getRotationOverride(@Nullable Context context, @Nullable PackageManager packageManager, @Nullable String packageName)",
    "returnType" : "int",
    "comment" : "\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public static int getRotationOverrideInternal(@Nullable Context context, @Nullable PackageManager packageManager, @Nullable String packageName)",
    "returnType" : "int",
    "comment" : "\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public static boolean shouldOverrideToPortrait(@Nullable PackageManager packageManager, @Nullable String packageName)",
    "returnType" : "boolean",
    "comment" : "\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public static boolean physicalCallbacksAreEnabledForUnavailableCamera()",
    "returnType" : "boolean",
    "comment" : "\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public static boolean isHiddenPhysicalCamera(String cameraId)",
    "returnType" : "boolean",
    "comment" : "\n     * Queries the camera service if a cameraId is a hidden physical camera that belongs to a\n     * logical camera device.\n     *\n     * A hidden physical camera is a camera that cannot be opened by the application. But it\n     * can be used as part of a logical camera.\n     *\n     * @param cameraId a non-{@code null} camera identifier\n     * @return {@code true} if cameraId is a hidden physical camera device\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public void injectCamera(@NonNull String packageName, @NonNull String internalCamId, @NonNull String externalCamId, @NonNull @CallbackExecutor Executor executor, @NonNull CameraInjectionSession.InjectionStatusCallback callback) throws CameraAccessException, SecurityException, IllegalArgumentException",
    "returnType" : "void",
    "comment" : "\n     * Inject the external camera to replace the internal camera session.\n     *\n     * <p>If injecting the external camera device fails, then the injection callback's\n     * {@link CameraInjectionSession.InjectionStatusCallback#onInjectionError\n     * onInjectionError} method will be called.</p>\n     *\n     * @param packageName   It scopes the injection to a particular app.\n     * @param internalCamId The id of one of the physical or logical cameras on the phone.\n     * @param externalCamId The id of one of the remote cameras that are provided by the dynamic\n     *                      camera HAL.\n     * @param executor      The executor which will be used when invoking the callback.\n     * @param callback      The callback which is invoked once the external camera is injected.\n     *\n     * @throws CameraAccessException    If the camera device has been disconnected.\n     *                                  {@link CameraAccessException#CAMERA_DISCONNECTED} will be\n     *                                  thrown if camera service is not available.\n     * @throws SecurityException        If the specific application that can cast to external\n     *                                  devices does not have permission to inject the external\n     *                                  camera.\n     * @throws IllegalArgumentException If cameraId doesn't match any currently or previously\n     *                                  available camera device or some camera functions might not\n     *                                  work properly or the injection camera runs into a fatal\n     *                                  error.\n     * @hide\n     ",
    "links" : [ "android.hardware.camera2.CameraAccessException#CAMERA_DISCONNECTED", "CameraInjectionSession.InjectionStatusCallback#onInjectionErroronInjectionError" ]
  }, {
    "name" : "public void injectSessionParams(@NonNull String cameraId, @NonNull CaptureRequest sessionParams) throws CameraAccessException, SecurityException",
    "returnType" : "void",
    "comment" : "\n     * Injects session params into existing clients in the CameraService.\n     *\n     * @param cameraId       The camera id of client to inject session params into.\n     *                       If no such client exists for cameraId, no injection will\n     *                       take place.\n     * @param sessionParams  A {@link CaptureRequest} object containing the\n     *                       the sessionParams to inject into the existing client.\n     *\n     * @throws CameraAccessException    {@link CameraAccessException#CAMERA_DISCONNECTED} will be\n     *                                  thrown if camera service is not available. Further, if\n     *                                  if no such client exists for cameraId,\n     *                                  {@link CameraAccessException#CAMERA_ERROR} will be thrown.\n     * @throws SecurityException        If the caller does not have permission to inject session\n     *                                  params\n     * @hide\n     ",
    "links" : [ "android.hardware.camera2.CameraAccessException#CAMERA_ERROR", "android.hardware.camera2.CameraAccessException#CAMERA_DISCONNECTED", "android.hardware.camera2.CaptureRequest" ]
  }, {
    "name" : "public ICameraService getCameraService()",
    "returnType" : "ICameraService",
    "comment" : "\n     * Returns the current CameraService instance connected to Global\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean isCameraServiceDisabled()",
    "returnType" : "boolean",
    "comment" : "\n     * Returns true if cameraservice is currently disabled. If true, {@link #getCameraService()}\n     * will definitely return null.\n     * @hide\n     ",
    "links" : [ "#getCameraService()" ]
  }, {
    "name" : "public static String reportExtensionSessionStats(CameraExtensionSessionStats extStats)",
    "returnType" : "String",
    "comment" : "\n     * Reports {@link CameraExtensionSessionStats} to the {@link ICameraService} to be logged for\n     * currently active session. Validation is done downstream.\n     *\n     * @param extStats Extension Session stats to be logged by cameraservice\n     *\n     * @return the key to be used with the next call.\n     *         See {@link ICameraService#reportExtensionSessionStats}.\n     * @hide\n     ",
    "links" : [ "android.hardware.ICameraService#reportExtensionSessionStats", "android.hardware.CameraExtensionSessionStats", "android.hardware.ICameraService" ]
  } ],
  "methodNames" : [ "public void registerDeviceStateListener(@NonNull CameraCharacteristics chars)", "public String[] getCameraIdList() throws CameraAccessException", "public String[] getCameraIdListNoLazy() throws CameraAccessException", "public Set<Set<String>> getConcurrentCameraIds() throws CameraAccessException", "public boolean isConcurrentSessionConfigurationSupported(@NonNull Map<String, SessionConfiguration> cameraIdAndSessionConfig) throws CameraAccessException", "public void registerAvailabilityCallback(@NonNull AvailabilityCallback callback, @Nullable Handler handler)", "public void registerAvailabilityCallback(@NonNull @CallbackExecutor Executor executor, @NonNull AvailabilityCallback callback)", "public void unregisterAvailabilityCallback(@NonNull AvailabilityCallback callback)", "public void registerTorchCallback(@NonNull TorchCallback callback, @Nullable Handler handler)", "public void registerTorchCallback(@NonNull @CallbackExecutor Executor executor, @NonNull TorchCallback callback)", "public void unregisterTorchCallback(@NonNull TorchCallback callback)", "public int getDevicePolicyFromContext(@NonNull Context context)", "private Size getDisplaySize()", "private Map<String, StreamConfiguration[]> getPhysicalCameraMultiResolutionConfigs(String cameraId, CameraMetadataNative info, ICameraService cameraService) throws CameraAccessException", "public CameraCharacteristics getCameraCharacteristics(@NonNull String cameraId) throws CameraAccessException", "public CameraCharacteristics getCameraCharacteristics(@NonNull String cameraId, boolean overrideToPortrait) throws CameraAccessException", "private CameraCharacteristics getCameraCharacteristics(@NonNull String cameraId, int rotationOverride) throws CameraAccessException", "public CameraCharacteristics prepareCameraCharacteristics(@NonNull String cameraId, CameraMetadataNative metadata, ICameraService cameraService) throws CameraAccessException", "public CameraExtensionCharacteristics getCameraExtensionCharacteristics(@NonNull String cameraId) throws CameraAccessException", "public Map<String, CameraCharacteristics> getPhysicalIdToCharsMap(CameraCharacteristics chars) throws CameraAccessException", "public CameraDevice.CameraDeviceSetup getCameraDeviceSetup(@NonNull String cameraId) throws CameraAccessException", "private CameraDevice.CameraDeviceSetup getCameraDeviceSetupUnsafe(@NonNull String cameraId)", "public boolean isCameraDeviceSetupSupported(@NonNull String cameraId) throws CameraAccessException", "private CameraDevice openCameraDeviceUserAsync(String cameraId, CameraDevice.StateCallback callback, Executor executor, final int uid, final int oomScoreOffset, int rotationOverride) throws CameraAccessException", "public void openCamera(@NonNull String cameraId, @NonNull final CameraDevice.StateCallback callback, @Nullable Handler handler) throws CameraAccessException", "public void openCamera(@NonNull String cameraId, boolean overrideToPortrait, @Nullable Handler handler, @NonNull final CameraDevice.StateCallback callback) throws CameraAccessException", "public void openCamera(@NonNull String cameraId, @NonNull @CallbackExecutor Executor executor, @NonNull final CameraDevice.StateCallback callback) throws CameraAccessException", "public void openCamera(@NonNull String cameraId, int oomScoreOffset, @NonNull @CallbackExecutor Executor executor, @NonNull final CameraDevice.StateCallback callback) throws CameraAccessException", "public void openCameraForUid(@NonNull String cameraId, @NonNull final CameraDevice.StateCallback callback, @NonNull Executor executor, int clientUid, int oomScoreOffset, int rotationOverride) throws CameraAccessException", "public void openCameraForUid(@NonNull String cameraId, @NonNull final CameraDevice.StateCallback callback, @NonNull Executor executor, int clientUid) throws CameraAccessException", "public void setTorchMode(@NonNull String cameraId, boolean enabled) throws CameraAccessException", "public void turnOnTorchWithStrengthLevel(@NonNull String cameraId, int torchStrength) throws CameraAccessException", "public int getTorchStrengthLevel(@NonNull String cameraId) throws CameraAccessException", "public static int getRotationOverride(@Nullable Context context)", "public static int getRotationOverride(@Nullable Context context, @Nullable PackageManager packageManager, @Nullable String packageName)", "public static int getRotationOverrideInternal(@Nullable Context context, @Nullable PackageManager packageManager, @Nullable String packageName)", "public static boolean shouldOverrideToPortrait(@Nullable PackageManager packageManager, @Nullable String packageName)", "public static boolean physicalCallbacksAreEnabledForUnavailableCamera()", "public static boolean isHiddenPhysicalCamera(String cameraId)", "public void injectCamera(@NonNull String packageName, @NonNull String internalCamId, @NonNull String externalCamId, @NonNull @CallbackExecutor Executor executor, @NonNull CameraInjectionSession.InjectionStatusCallback callback) throws CameraAccessException, SecurityException, IllegalArgumentException", "public void injectSessionParams(@NonNull String cameraId, @NonNull CaptureRequest sessionParams) throws CameraAccessException, SecurityException", "public ICameraService getCameraService()", "public boolean isCameraServiceDisabled()", "public static String reportExtensionSessionStats(CameraExtensionSessionStats extStats)" ],
  "variableNames" : [ "TAG", "DEBUG", "USE_CALLING_UID", "API_VERSION_1", "API_VERSION_2", "CAMERA_TYPE_BACKWARD_COMPATIBLE", "CAMERA_TYPE_ALL", "mCameraIdToMultiResolutionStreamConfigurationMap", "mContext", "mLock", "CAMERA_OPEN_CLOSE_LISTENER_PERMISSION", "mHasOpenCloseListenerPermission", "mVirtualDeviceManager", "OVERRIDE_CAMERA_LANDSCAPE_TO_PORTRAIT", "LANDSCAPE_TO_PORTRAIT_PROP", "ROTATION_OVERRIDE_NONE", "ROTATION_OVERRIDE_OVERRIDE_TO_PORTRAIT", "ROTATION_OVERRIDE_ROTATION_ONLY", "ENABLE_PHYSICAL_CAMERA_CALLBACK_FOR_UNAVAILABLE_LOGICAL_CAMERA" ]
}