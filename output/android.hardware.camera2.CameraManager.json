{
  "filePath" : "/home/maryam/clearblue/files/android-source-30/android/hardware/camera2/CameraManager.java",
  "packageName" : "android.hardware.camera2",
  "className" : "CameraManager",
  "comment" : "\n * <p>A system service manager for detecting, characterizing, and connecting to\n * {@link CameraDevice CameraDevices}.</p>\n *\n * <p>For more details about communicating with camera devices, read the Camera\n * developer guide or the {@link android.hardware.camera2 camera2}\n * package documentation.</p>\n ",
  "variables" : [ {
    "name" : "TAG",
    "type" : "String",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "DEBUG",
    "type" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "USE_CALLING_UID",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "API_VERSION_1",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "API_VERSION_2",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "CAMERA_TYPE_BACKWARD_COMPATIBLE",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "CAMERA_TYPE_ALL",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mDeviceIdList",
    "type" : "ArrayList<String>",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mContext",
    "type" : "Context",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mLock",
    "type" : "Object",
    "comment" : "",
    "links" : [ ]
  } ],
  "methods" : [ {
    "name" : "public String[] getCameraIdList() throws CameraAccessException",
    "returnType" : "String[]",
    "comment" : "\n     * Return the list of currently connected camera devices by identifier, including\n     * cameras that may be in use by other camera API clients.\n     *\n     * <p>Non-removable cameras use integers starting at 0 for their\n     * identifiers, while removable cameras have a unique identifier for each\n     * individual device, even if they are the same model.</p>\n     *\n     * <p>This list doesn't contain physical cameras that can only be used as part of a logical\n     * multi-camera device.</p>\n     *\n     * @return The list of currently connected camera devices.\n     ",
    "links" : [ ]
  }, {
    "name" : "public String[] getCameraIdListNoLazy() throws CameraAccessException",
    "returnType" : "String[]",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "public Set<Set<String>> getConcurrentCameraIds() throws CameraAccessException",
    "returnType" : "Set<Set<String>>",
    "comment" : "\n     * Return the set of combinations of currently connected camera device identifiers, which\n     * support configuring camera device sessions concurrently.\n     *\n     * <p>The devices in these combinations can be concurrently configured by the same\n     * client camera application. Using these camera devices concurrently by two different\n     * applications is not guaranteed to be supported, however.</p>\n     *\n     * <p>For concurrent operation, in chronological order :\n     * - Applications must first close any open cameras that have sessions configured, using\n     *   {@link CameraDevice#close}.\n     * - All camera devices intended to be operated concurrently, must be opened using\n     *   {@link #openCamera}, before configuring sessions on any of the camera devices.</p>\n     *\n     * <p>Each device in a combination, is guaranteed to support stream combinations which may be\n     * obtained by querying {@link #getCameraCharacteristics} for the key\n     * {@link android.hardware.camera2.CameraCharacteristics#SCALER_MANDATORY_CONCURRENT_STREAM_COMBINATIONS}.</p>\n     *\n     * <p>For concurrent operation, if a camera device has a non null zoom ratio range as specified\n     * by\n     * {@link android.hardware.camera2.CameraCharacteristics#CONTROL_ZOOM_RATIO_RANGE},\n     * its complete zoom ratio range may not apply. Applications can use\n     * {@link android.hardware.camera2.CaptureRequest#CONTROL_ZOOM_RATIO} >=1 and  <=\n     * {@link android.hardware.camera2.CameraCharacteristics#SCALER_AVAILABLE_MAX_DIGITAL_ZOOM}\n     * during concurrent operation.\n     * <p>\n     *\n     * <p>The set of combinations may include camera devices that may be in use by other camera API\n     * clients.</p>\n     *\n     * <p>The set of combinations doesn't contain physical cameras that can only be used as\n     * part of a logical multi-camera device.</p>\n     *\n     * <p> If a new camera id becomes available through\n     * {@link AvailabilityCallback#onCameraUnavailable(String)}, clients can call\n     * this method to check if new combinations of camera ids which can stream concurrently are\n     * available.\n     *\n     * @return The set of combinations of currently connected camera devices, that may have\n     *         sessions configured concurrently. The set of combinations will be empty if no such\n     *         combinations are supported by the camera subsystem.\n     *\n     * @throws CameraAccessException if the camera device has been disconnected.\n     ",
    "links" : [ "#getCameraCharacteristics", "#onCameraUnavailable(String)", "android.hardware.camera2.CameraCharacteristics#SCALER_MANDATORY_CONCURRENT_STREAM_COMBINATIONS", "android.hardware.camera2.CameraCharacteristics#SCALER_AVAILABLE_MAX_DIGITAL_ZOOM", "android.hardware.camera2.CameraCharacteristics#CONTROL_ZOOM_RATIO_RANGE", "android.hardware.camera2.CaptureRequest#CONTROL_ZOOM_RATIO", "#openCamera", "android.hardware.camera2.CameraDevice#close" ]
  }, {
    "name" : "public boolean isConcurrentSessionConfigurationSupported(@NonNull Map<String, SessionConfiguration> cameraIdAndSessionConfig) throws CameraAccessException",
    "returnType" : "boolean",
    "comment" : "\n     * Checks whether the provided set of camera devices and their corresponding\n     * {@link SessionConfiguration} can be configured concurrently.\n     *\n     * <p>This method performs a runtime check of the given {@link SessionConfiguration} and camera\n     * id combinations. The result confirms whether or not the passed session configurations can be\n     * successfully used to create camera capture sessions concurrently, on the given camera\n     * devices using {@link CameraDevice#createCaptureSession(SessionConfiguration)}.\n     * </p>\n     *\n     * <p>The method can be called at any point before, during and after active capture sessions.\n     * It will not impact normal camera behavior in any way and must complete significantly\n     * faster than creating a regular or constrained capture session.</p>\n     *\n     * <p>Although this method is faster than creating a new capture session, it is not intended\n     * to be used for exploring the entire space of supported concurrent stream combinations. The\n     * available mandatory concurrent stream combinations may be obtained by querying\n     * {@link #getCameraCharacteristics} for the key\n     * {@link android.hardware.camera2.CameraCharacteristics#SCALER_MANDATORY_CONCURRENT_STREAM_COMBINATIONS}. </p>\n     *\n     * <p>Note that session parameters will be ignored and calls to\n     * {@link SessionConfiguration#setSessionParameters} are not required.</p>\n     *\n     * @return {@code true} if the given combination of session configurations and corresponding\n     *                      camera ids are concurrently supported by the camera sub-system,\n     *         {@code false} otherwise OR if the set of camera devices provided is not a subset of\n     *                       those returned by {@link #getConcurrentCameraIds}.\n     *\n     * @throws CameraAccessException if one of the camera devices queried is no longer connected.\n     *\n     ",
    "links" : [ "#getCameraCharacteristics", "#getConcurrentCameraIds", "android.hardware.camera2.params.SessionConfiguration#setSessionParameters", "android.hardware.camera2.params.SessionConfiguration", "android.hardware.camera2.CameraCharacteristics#SCALER_MANDATORY_CONCURRENT_STREAM_COMBINATIONS", "android.hardware.camera2.CameraDevice#createCaptureSession(SessionConfiguration)" ]
  }, {
    "name" : "public void registerAvailabilityCallback(@NonNull AvailabilityCallback callback, @Nullable Handler handler)",
    "returnType" : "void",
    "comment" : "\n     * Register a callback to be notified about camera device availability.\n     *\n     * <p>Registering the same callback again will replace the handler with the\n     * new one provided.</p>\n     *\n     * <p>The first time a callback is registered, it is immediately called\n     * with the availability status of all currently known camera devices.</p>\n     *\n     * <p>{@link AvailabilityCallback#onCameraUnavailable(String)} will be called whenever a camera\n     * device is opened by any camera API client. As of API level 23, other camera API clients may\n     * still be able to open such a camera device, evicting the existing client if they have higher\n     * priority than the existing client of a camera device. See open() for more details.</p>\n     *\n     * <p>Since this callback will be registered with the camera service, remember to unregister it\n     * once it is no longer needed; otherwise the callback will continue to receive events\n     * indefinitely and it may prevent other resources from being released. Specifically, the\n     * callbacks will be invoked independently of the general activity lifecycle and independently\n     * of the state of individual CameraManager instances.</p>\n     *\n     * @param callback the new callback to send camera availability notices to\n     * @param handler The handler on which the callback should be invoked, or {@code null} to use\n     *             the current thread's {@link android.os.Looper looper}.\n     *\n     * @throws IllegalArgumentException if the handler is {@code null} but the current thread has\n     *             no looper.\n     ",
    "links" : [ "#onCameraUnavailable(String)", "android.os.Looper" ]
  }, {
    "name" : "public void registerAvailabilityCallback(@NonNull @CallbackExecutor Executor executor, @NonNull AvailabilityCallback callback)",
    "returnType" : "void",
    "comment" : "\n     * Register a callback to be notified about camera device availability.\n     *\n     * <p>The behavior of this method matches that of\n     * {@link #registerAvailabilityCallback(AvailabilityCallback, Handler)},\n     * except that it uses {@link java.util.concurrent.Executor} as an argument\n     * instead of {@link android.os.Handler}.</p>\n     *\n     * @param executor The executor which will be used to invoke the callback.\n     * @param callback the new callback to send camera availability notices to\n     *\n     * @throws IllegalArgumentException if the executor is {@code null}.\n     ",
    "links" : [ "java.util.concurrent.Executor", "android.os.Handler", "#registerAvailabilityCallback(AvailabilityCallback" ]
  }, {
    "name" : "public void unregisterAvailabilityCallback(@NonNull AvailabilityCallback callback)",
    "returnType" : "void",
    "comment" : "\n     * Remove a previously-added callback; the callback will no longer receive connection and\n     * disconnection callbacks.\n     *\n     * <p>Removing a callback that isn't registered has no effect.</p>\n     *\n     * @param callback The callback to remove from the notification list\n     ",
    "links" : [ ]
  }, {
    "name" : "public void registerTorchCallback(@NonNull TorchCallback callback, @Nullable Handler handler)",
    "returnType" : "void",
    "comment" : "\n     * Register a callback to be notified about torch mode status.\n     *\n     * <p>Registering the same callback again will replace the handler with the\n     * new one provided.</p>\n     *\n     * <p>The first time a callback is registered, it is immediately called\n     * with the torch mode status of all currently known camera devices with a flash unit.</p>\n     *\n     * <p>Since this callback will be registered with the camera service, remember to unregister it\n     * once it is no longer needed; otherwise the callback will continue to receive events\n     * indefinitely and it may prevent other resources from being released. Specifically, the\n     * callbacks will be invoked independently of the general activity lifecycle and independently\n     * of the state of individual CameraManager instances.</p>\n     *\n     * @param callback The new callback to send torch mode status to\n     * @param handler The handler on which the callback should be invoked, or {@code null} to use\n     *             the current thread's {@link android.os.Looper looper}.\n     *\n     * @throws IllegalArgumentException if the handler is {@code null} but the current thread has\n     *             no looper.\n     ",
    "links" : [ "android.os.Looper" ]
  }, {
    "name" : "public void registerTorchCallback(@NonNull @CallbackExecutor Executor executor, @NonNull TorchCallback callback)",
    "returnType" : "void",
    "comment" : "\n     * Register a callback to be notified about torch mode status.\n     *\n     * <p>The behavior of this method matches that of\n     * {@link #registerTorchCallback(TorchCallback, Handler)},\n     * except that it uses {@link java.util.concurrent.Executor} as an argument\n     * instead of {@link android.os.Handler}.</p>\n     *\n     * @param executor The executor which will be used to invoke the callback\n     * @param callback The new callback to send torch mode status to\n     *\n     * @throws IllegalArgumentException if the executor is {@code null}.\n     ",
    "links" : [ "java.util.concurrent.Executor", "android.os.Handler", "#registerTorchCallback(TorchCallback" ]
  }, {
    "name" : "public void unregisterTorchCallback(@NonNull TorchCallback callback)",
    "returnType" : "void",
    "comment" : "\n     * Remove a previously-added callback; the callback will no longer receive torch mode status\n     * callbacks.\n     *\n     * <p>Removing a callback that isn't registered has no effect.</p>\n     *\n     * @param callback The callback to remove from the notification list\n     ",
    "links" : [ ]
  }, {
    "name" : "private Size getDisplaySize()",
    "returnType" : "Size",
    "comment" : " TODO(b/147726300): Investigate how to support foldables/multi-display devices.",
    "links" : [ ]
  }, {
    "name" : "public CameraCharacteristics getCameraCharacteristics(@NonNull String cameraId) throws CameraAccessException",
    "returnType" : "CameraCharacteristics",
    "comment" : "\n     * <p>Query the capabilities of a camera device. These capabilities are\n     * immutable for a given camera.</p>\n     *\n     * <p>From API level 29, this function can also be used to query the capabilities of physical\n     * cameras that can only be used as part of logical multi-camera. These cameras cannot be\n     * opened directly via {@link #openCamera}</p>\n     *\n     * <p>Also starting with API level 29, while most basic camera information is still available\n     * even without the CAMERA permission, some values are not available to apps that do not hold\n     * that permission. The keys not available are listed by\n     * {@link CameraCharacteristics#getKeysNeedingPermission}.</p>\n     *\n     * @param cameraId The id of the camera device to query. This could be either a standalone\n     * camera ID which can be directly opened by {@link #openCamera}, or a physical camera ID that\n     * can only used as part of a logical multi-camera.\n     * @return The properties of the given camera\n     *\n     * @throws IllegalArgumentException if the cameraId does not match any\n     *         known camera device.\n     * @throws CameraAccessException if the camera device has been disconnected.\n     *\n     * @see #getCameraIdList\n     * @see android.app.admin.DevicePolicyManager#setCameraDisabled\n     ",
    "links" : [ "#openCamera", "android.hardware.camera2.CameraCharacteristics#getKeysNeedingPermission" ]
  }, {
    "name" : "private CameraDevice openCameraDeviceUserAsync(String cameraId, CameraDevice.StateCallback callback, Executor executor, final int uid) throws CameraAccessException",
    "returnType" : "CameraDevice",
    "comment" : "\n     * Helper for opening a connection to a camera with the given ID.\n     *\n     * @param cameraId The unique identifier of the camera device to open\n     * @param callback The callback for the camera. Must not be null.\n     * @param executor The executor to invoke the callback with. Must not be null.\n     * @param uid      The UID of the application actually opening the camera.\n     *                 Must be USE_CALLING_UID unless the caller is a service\n     *                 that is trusted to open the device on behalf of an\n     *                 application and to forward the real UID.\n     *\n     * @throws CameraAccessException if the camera is disabled by device policy,\n     * too many camera devices are already open, or the cameraId does not match\n     * any currently available camera device.\n     *\n     * @throws SecurityException if the application does not have permission to\n     * access the camera\n     * @throws IllegalArgumentException if callback or handler is null.\n     * @return A handle to the newly-created camera device.\n     *\n     * @see #getCameraIdList\n     * @see android.app.admin.DevicePolicyManager#setCameraDisabled\n     ",
    "links" : [ ]
  }, {
    "name" : "public void openCamera(@NonNull String cameraId, @NonNull final CameraDevice.StateCallback callback, @Nullable Handler handler) throws CameraAccessException",
    "returnType" : "void",
    "comment" : "\n     * Open a connection to a camera with the given ID.\n     *\n     * <p>Use {@link #getCameraIdList} to get the list of available camera\n     * devices. Note that even if an id is listed, open may fail if the device\n     * is disconnected between the calls to {@link #getCameraIdList} and\n     * {@link #openCamera}, or if a higher-priority camera API client begins using the\n     * camera device.</p>\n     *\n     * <p>As of API level 23, devices for which the\n     * {@link AvailabilityCallback#onCameraUnavailable(String)} callback has been called due to the\n     * device being in use by a lower-priority, background camera API client can still potentially\n     * be opened by calling this method when the calling camera API client has a higher priority\n     * than the current camera API client using this device.  In general, if the top, foreground\n     * activity is running within your application process, your process will be given the highest\n     * priority when accessing the camera, and this method will succeed even if the camera device is\n     * in use by another camera API client. Any lower-priority application that loses control of the\n     * camera in this way will receive an\n     * {@link android.hardware.camera2.CameraDevice.StateCallback#onDisconnected} callback.\n     * Opening the same camera ID twice in the same application will similarly cause the\n     * {@link android.hardware.camera2.CameraDevice.StateCallback#onDisconnected} callback\n     * being fired for the {@link CameraDevice} from the first open call and all ongoing tasks\n     * being droppped.</p>\n     *\n     * <p>Once the camera is successfully opened, {@link CameraDevice.StateCallback#onOpened} will\n     * be invoked with the newly opened {@link CameraDevice}. The camera device can then be set up\n     * for operation by calling {@link CameraDevice#createCaptureSession} and\n     * {@link CameraDevice#createCaptureRequest}</p>\n     *\n     * <p>Before API level 30, when the application tries to open multiple {@link CameraDevice} of\n     * different IDs and the device does not support opening such combination, either the\n     * {@link #openCamera} will fail and throw a {@link CameraAccessException} or one or more of\n     * already opened {@link CameraDevice} will be disconnected and receive\n     * {@link android.hardware.camera2.CameraDevice.StateCallback#onDisconnected} callback. Which\n     * behavior will happen depends on the device implementation and can vary on different devices.\n     * Starting in API level 30, if the device does not support the combination of cameras being\n     * opened, it is guaranteed the {@link #openCamera} call will fail and none of existing\n     * {@link CameraDevice} will be disconnected.</p>\n     *\n     * <!--\n     * <p>Since the camera device will be opened asynchronously, any asynchronous operations done\n     * on the returned CameraDevice instance will be queued up until the device startup has\n     * completed and the callback's {@link CameraDevice.StateCallback#onOpened onOpened} method is\n     * called. The pending operations are then processed in order.</p>\n     * -->\n     * <p>If the camera becomes disconnected during initialization\n     * after this function call returns,\n     * {@link CameraDevice.StateCallback#onDisconnected} with a\n     * {@link CameraDevice} in the disconnected state (and\n     * {@link CameraDevice.StateCallback#onOpened} will be skipped).</p>\n     *\n     * <p>If opening the camera device fails, then the device callback's\n     * {@link CameraDevice.StateCallback#onError onError} method will be called, and subsequent\n     * calls on the camera device will throw a {@link CameraAccessException}.</p>\n     *\n     * @param cameraId\n     *             The unique identifier of the camera device to open\n     * @param callback\n     *             The callback which is invoked once the camera is opened\n     * @param handler\n     *             The handler on which the callback should be invoked, or\n     *             {@code null} to use the current thread's {@link android.os.Looper looper}.\n     *\n     * @throws CameraAccessException if the camera is disabled by device policy,\n     * has been disconnected, is being used by a higher-priority camera API client, or the device\n     * has reached its maximal resource and cannot open this camera device.\n     *\n     * @throws IllegalArgumentException if cameraId or the callback was null,\n     * or the cameraId does not match any currently or previously available\n     * camera device returned by {@link #getCameraIdList}.\n     *\n     * @throws SecurityException if the application does not have permission to\n     * access the camera\n     *\n     * @see #getCameraIdList\n     * @see android.app.admin.DevicePolicyManager#setCameraDisabled\n     ",
    "links" : [ "android.hardware.camera2.CameraDevice#createCaptureRequest", "#onCameraUnavailable(String)", "CameraDevice.StateCallback#onDisconnected", "CameraDevice.StateCallback#onError", "CameraDevice.StateCallback#onOpened", "android.os.Looper", "android.hardware.camera2.CameraDevice", "android.hardware.camera2.CameraAccessException", "android.hardware.camera2.CameraDevice#createCaptureSession", "#getCameraIdList", "#openCamera", "android.hardware.camera2.CameraDevice.StateCallback#onDisconnected" ]
  }, {
    "name" : "public void openCamera(@NonNull String cameraId, @NonNull @CallbackExecutor Executor executor, @NonNull final CameraDevice.StateCallback callback) throws CameraAccessException",
    "returnType" : "void",
    "comment" : "\n     * Open a connection to a camera with the given ID.\n     *\n     * <p>The behavior of this method matches that of\n     * {@link #openCamera(String, StateCallback, Handler)}, except that it uses\n     * {@link java.util.concurrent.Executor} as an argument instead of\n     * {@link android.os.Handler}.</p>\n     *\n     * @param cameraId\n     *             The unique identifier of the camera device to open\n     * @param executor\n     *             The executor which will be used when invoking the callback.\n     * @param callback\n     *             The callback which is invoked once the camera is opened\n     *\n     * @throws CameraAccessException if the camera is disabled by device policy,\n     * has been disconnected, or is being used by a higher-priority camera API client.\n     *\n     * @throws IllegalArgumentException if cameraId, the callback or the executor was null,\n     * or the cameraId does not match any currently or previously available\n     * camera device.\n     *\n     * @throws SecurityException if the application does not have permission to\n     * access the camera\n     *\n     * @see #getCameraIdList\n     * @see android.app.admin.DevicePolicyManager#setCameraDisabled\n     ",
    "links" : [ "java.util.concurrent.Executor", "android.os.Handler", "#openCamera(String" ]
  }, {
    "name" : "public void openCameraForUid(@NonNull String cameraId, @NonNull final CameraDevice.StateCallback callback, @NonNull Executor executor, int clientUid) throws CameraAccessException",
    "returnType" : "void",
    "comment" : "\n     * Open a connection to a camera with the given ID, on behalf of another application\n     * specified by clientUid.\n     *\n     * <p>The behavior of this method matches that of {@link #openCamera}, except that it allows\n     * the caller to specify the UID to use for permission/etc verification. This can only be\n     * done by services trusted by the camera subsystem to act on behalf of applications and\n     * to forward the real UID.</p>\n     *\n     * @param clientUid\n     *             The UID of the application on whose behalf the camera is being opened.\n     *             Must be USE_CALLING_UID unless the caller is a trusted service.\n     *\n     * @hide\n     ",
    "links" : [ "#openCamera" ]
  }, {
    "name" : "public void setTorchMode(@NonNull String cameraId, boolean enabled) throws CameraAccessException",
    "returnType" : "void",
    "comment" : "\n     * Set the flash unit's torch mode of the camera of the given ID without opening the camera\n     * device.\n     *\n     * <p>Use {@link #getCameraIdList} to get the list of available camera devices and use\n     * {@link #getCameraCharacteristics} to check whether the camera device has a flash unit.\n     * Note that even if a camera device has a flash unit, turning on the torch mode may fail\n     * if the camera device or other camera resources needed to turn on the torch mode are in use.\n     * </p>\n     *\n     * <p> If {@link #setTorchMode} is called to turn on or off the torch mode successfully,\n     * {@link CameraManager.TorchCallback#onTorchModeChanged} will be invoked.\n     * However, even if turning on the torch mode is successful, the application does not have the\n     * exclusive ownership of the flash unit or the camera device. The torch mode will be turned\n     * off and becomes unavailable when the camera device that the flash unit belongs to becomes\n     * unavailable or when other camera resources to keep the torch on become unavailable (\n     * {@link CameraManager.TorchCallback#onTorchModeUnavailable} will be invoked). Also,\n     * other applications are free to call {@link #setTorchMode} to turn off the torch mode (\n     * {@link CameraManager.TorchCallback#onTorchModeChanged} will be invoked). If the latest\n     * application that turned on the torch mode exits, the torch mode will be turned off.\n     *\n     * @param cameraId\n     *             The unique identifier of the camera device that the flash unit belongs to.\n     * @param enabled\n     *             The desired state of the torch mode for the target camera device. Set to\n     *             {@code true} to turn on the torch mode. Set to {@code false} to turn off the\n     *             torch mode.\n     *\n     * @throws CameraAccessException if it failed to access the flash unit.\n     *             {@link CameraAccessException#CAMERA_IN_USE} will be thrown if the camera device\n     *             is in use. {@link CameraAccessException#MAX_CAMERAS_IN_USE} will be thrown if\n     *             other camera resources needed to turn on the torch mode are in use.\n     *             {@link CameraAccessException#CAMERA_DISCONNECTED} will be thrown if camera\n     *             service is not available.\n     *\n     * @throws IllegalArgumentException if cameraId was null, cameraId doesn't match any currently\n     *             or previously available camera device, or the camera device doesn't have a\n     *             flash unit.\n     ",
    "links" : [ "#getCameraCharacteristics", "#setTorchMode", "android.hardware.camera2.CameraAccessException#MAX_CAMERAS_IN_USE", "android.hardware.camera2.CameraAccessException#CAMERA_DISCONNECTED", "#getCameraIdList", "CameraManager.TorchCallback#onTorchModeUnavailable", "CameraManager.TorchCallback#onTorchModeChanged", "android.hardware.camera2.CameraAccessException#CAMERA_IN_USE" ]
  }, {
    "name" : "public static void throwAsPublicException(Throwable t) throws CameraAccessException",
    "returnType" : "void",
    "comment" : "\n     * Convert ServiceSpecificExceptions and Binder RemoteExceptions from camera binder interfaces\n     * into the correct public exceptions.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "private boolean supportsCamera2ApiLocked(String cameraId)",
    "returnType" : "boolean",
    "comment" : "\n     * Queries the camera service if it supports the camera2 api directly, or needs a shim.\n     *\n     * @param cameraId a non-{@code null} camera identifier\n     * @return {@code false} if the legacy shim needs to be used, {@code true} otherwise.\n     ",
    "links" : [ ]
  }, {
    "name" : "private boolean supportsCameraApiLocked(String cameraId, int apiVersion)",
    "returnType" : "boolean",
    "comment" : "\n     * Queries the camera service if it supports a camera api directly, or needs a shim.\n     *\n     * @param cameraId a non-{@code null} camera identifier\n     * @param apiVersion the version, i.e. {@code API_VERSION_1} or {@code API_VERSION_2}\n     * @return {@code true} if connecting will work for that device version.\n     ",
    "links" : [ ]
  }, {
    "name" : "public static boolean isHiddenPhysicalCamera(String cameraId)",
    "returnType" : "boolean",
    "comment" : "\n     * Queries the camera service if a cameraId is a hidden physical camera that belongs to a\n     * logical camera device.\n     *\n     * A hidden physical camera is a camera that cannot be opened by the application. But it\n     * can be used as part of a logical camera.\n     *\n     * @param cameraId a non-{@code null} camera identifier\n     * @return {@code true} if cameraId is a hidden physical camera device\n     *\n     * @hide\n     ",
    "links" : [ ]
  } ],
  "variableNames" : [ "TAG", "DEBUG", "USE_CALLING_UID", "API_VERSION_1", "API_VERSION_2", "CAMERA_TYPE_BACKWARD_COMPATIBLE", "CAMERA_TYPE_ALL", "mDeviceIdList", "mContext", "mLock" ],
  "methodNames" : [ "public String[] getCameraIdList() throws CameraAccessException", "public String[] getCameraIdListNoLazy() throws CameraAccessException", "public Set<Set<String>> getConcurrentCameraIds() throws CameraAccessException", "public boolean isConcurrentSessionConfigurationSupported(@NonNull Map<String, SessionConfiguration> cameraIdAndSessionConfig) throws CameraAccessException", "public void registerAvailabilityCallback(@NonNull AvailabilityCallback callback, @Nullable Handler handler)", "public void registerAvailabilityCallback(@NonNull @CallbackExecutor Executor executor, @NonNull AvailabilityCallback callback)", "public void unregisterAvailabilityCallback(@NonNull AvailabilityCallback callback)", "public void registerTorchCallback(@NonNull TorchCallback callback, @Nullable Handler handler)", "public void registerTorchCallback(@NonNull @CallbackExecutor Executor executor, @NonNull TorchCallback callback)", "public void unregisterTorchCallback(@NonNull TorchCallback callback)", "private Size getDisplaySize()", "public CameraCharacteristics getCameraCharacteristics(@NonNull String cameraId) throws CameraAccessException", "private CameraDevice openCameraDeviceUserAsync(String cameraId, CameraDevice.StateCallback callback, Executor executor, final int uid) throws CameraAccessException", "public void openCamera(@NonNull String cameraId, @NonNull final CameraDevice.StateCallback callback, @Nullable Handler handler) throws CameraAccessException", "public void openCamera(@NonNull String cameraId, @NonNull @CallbackExecutor Executor executor, @NonNull final CameraDevice.StateCallback callback) throws CameraAccessException", "public void openCameraForUid(@NonNull String cameraId, @NonNull final CameraDevice.StateCallback callback, @NonNull Executor executor, int clientUid) throws CameraAccessException", "public void setTorchMode(@NonNull String cameraId, boolean enabled) throws CameraAccessException", "public static void throwAsPublicException(Throwable t) throws CameraAccessException", "private boolean supportsCamera2ApiLocked(String cameraId)", "private boolean supportsCameraApiLocked(String cameraId, int apiVersion)", "public static boolean isHiddenPhysicalCamera(String cameraId)" ]
}