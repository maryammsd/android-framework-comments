{
  "filePath" : "/home/maryam/clearblue/files/android-source-35/android/view/InputFilter.java",
  "packageName" : "android.view",
  "className" : "InputFilter",
  "comment" : "\n * Filters input events before they are dispatched to the system.\n * <p>\n * At most one input filter can be installed by calling\n * {@link WindowManagerService#setInputFilter}.  When an input filter is installed, the\n * system's behavior changes as follows:\n * <ul>\n * <li>Input events are first delivered to the {@link WindowManagerPolicy}\n * interception methods before queuing as usual.  This critical step takes care of managing\n * the power state of the device and handling wake keys.</li>\n * <li>Input events are then asynchronously delivered to the input filter's\n * {@link #onInputEvent(InputEvent)} method instead of being enqueued for dispatch to\n * applications as usual.  The input filter only receives input events that were\n * generated by an input device; the input filter will not receive input events that were\n * injected into the system by other means, such as by instrumentation.</li>\n * <li>The input filter processes and optionally transforms the stream of events.  For example,\n * it may transform a sequence of motion events representing an accessibility gesture into\n * a different sequence of motion events, key presses or other system-level interactions.\n * The input filter can send events to be dispatched by calling\n * {@link #sendInputEvent(InputEvent)} and passing appropriate policy flags for the\n * input event.</li>\n * </ul>\n * </p>\n * <h3>The importance of input event consistency</h3>\n * <p>\n * The input filter mechanism is very low-level.  At a minimum, it needs to ensure that it\n * sends an internally consistent stream of input events to the dispatcher.  There are\n * very important invariants to be maintained.\n * </p><p>\n * For example, if a key down is sent, a corresponding key up should also be sent eventually.\n * Likewise, for touch events, each pointer must individually go down with\n * {@link MotionEvent#ACTION_DOWN} or {@link MotionEvent#ACTION_POINTER_DOWN} and then\n * individually go up with {@link MotionEvent#ACTION_POINTER_UP} or {@link MotionEvent#ACTION_UP}\n * and the sequence of pointer ids used must be consistent throughout the gesture.\n * </p><p>\n * Sometimes a filter may wish to cancel a previously dispatched key or motion.  It should\n * use {@link KeyEvent#FLAG_CANCELED} or {@link MotionEvent#ACTION_CANCEL} accordingly.\n * </p><p>\n * The input filter must take into account the fact that the input events coming from different\n * devices or even different sources all consist of distinct streams of input.\n * Use {@link InputEvent#getDeviceId()} and {@link InputEvent#getSource()} to identify\n * the source of the event and its semantics.  There may be multiple sources of keys,\n * touches and other input: they must be kept separate.\n * </p>\n * <h3>Policy flags</h3>\n * <p>\n * Input events received from the dispatcher and sent to the dispatcher have policy flags\n * associated with them.  Policy flags control some functions of the dispatcher.\n * </p><p>\n * The early policy interception decides whether an input event should be delivered\n * to applications or dropped.  The policy indicates its decision by setting the\n * {@link WindowManagerPolicyConstants#FLAG_PASS_TO_USER} policy flag.  The input filter may\n * sometimes receive events that do not have this flag set.  It should take note of\n * the fact that the policy intends to drop the event, clean up its state, and\n * then send appropriate cancellation events to the dispatcher if needed.\n * </p><p>\n * For example, suppose the input filter is processing a gesture and one of the touch events\n * it receives does not have the {@link WindowManagerPolicyConstants#FLAG_PASS_TO_USER} flag set.\n * The input filter should clear its internal state about the gesture and then send key or\n * motion events to the dispatcher to cancel any keys or pointers that are down.\n * </p><p>\n * Corollary: Events that get sent to the dispatcher should usually include the\n * {@link WindowManagerPolicyConstants#FLAG_PASS_TO_USER} flag.  Otherwise, they will be dropped!\n * </p><p>\n * It may be prudent to disable automatic key repeating for synthetic key events\n * by setting the {@link WindowManagerPolicyConstants#FLAG_DISABLE_KEY_REPEAT} policy flag.\n * </p>\n *\n * @hide\n ",
  "links" : [ "android.view.MotionEvent#ACTION_POINTER_UP", "android.view.WindowManagerPolicyConstants#FLAG_DISABLE_KEY_REPEAT", "android.view.WindowManagerPolicyConstants#FLAG_PASS_TO_USER", "android.view.MotionEvent#ACTION_CANCEL", "#setInputFilter", "android.view.MotionEvent#ACTION_UP", "WindowManagerPolicy", "android.view.InputEvent#getSource()", "#sendInputEvent(InputEvent)", "android.view.KeyEvent#FLAG_CANCELED", "android.view.MotionEvent#ACTION_DOWN", "android.view.MotionEvent#ACTION_POINTER_DOWN", "android.view.InputEvent#getDeviceId()", "#onInputEvent(InputEvent)" ],
  "variables" : [ {
    "name" : "MSG_INSTALL",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "MSG_UNINSTALL",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "MSG_INPUT_EVENT",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mInboundInputEventConsistencyVerifier",
    "type" : "InputEventConsistencyVerifier",
    "comment" : " Consistency verifiers for debugging purposes.",
    "links" : [ ]
  }, {
    "name" : "mOutboundInputEventConsistencyVerifier",
    "type" : "InputEventConsistencyVerifier",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mH",
    "type" : "H",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mHost",
    "type" : "IInputFilterHost",
    "comment" : "",
    "links" : [ ]
  } ],
  "methods" : [ {
    "name" : "public final void install(IInputFilterHost host)",
    "returnType" : "void",
    "comment" : "\n     * Called when the input filter is installed.\n     * This method is guaranteed to be non-reentrant.\n     *\n     * @param host The input filter host environment.\n     ",
    "links" : [ ]
  }, {
    "name" : "public final void uninstall()",
    "returnType" : "void",
    "comment" : "\n     * Called when the input filter is uninstalled.\n     * This method is guaranteed to be non-reentrant.\n     ",
    "links" : [ ]
  }, {
    "name" : "public final void filterInputEvent(InputEvent event, int policyFlags)",
    "returnType" : "void",
    "comment" : "\n     * Called to enqueue the input event for filtering.\n     * The event will be recycled after the input filter processes it.\n     * This method is guaranteed to be non-reentrant.\n     *\n     * @param event The input event to enqueue.\n     ",
    "links" : [ ]
  }, {
    "name" : "public void sendInputEvent(InputEvent event, int policyFlags)",
    "returnType" : "void",
    "comment" : "\n     * Sends an input event to the dispatcher.\n     *\n     * @param event The input event to publish.\n     * @param policyFlags The input event policy flags.\n     ",
    "links" : [ ]
  }, {
    "name" : "public void onInputEvent(InputEvent event, int policyFlags)",
    "returnType" : "void",
    "comment" : "\n     * Called when an input event has been received from the dispatcher.\n     * <p>\n     * The default implementation sends the input event back to the dispatcher, unchanged.\n     * </p><p>\n     * The event will be recycled when this method returns.  If you want to keep it around,\n     * make a copy!\n     * </p>\n     *\n     * @param event The input event that was received.\n     * @param policyFlags The input event policy flags.\n     ",
    "links" : [ ]
  }, {
    "name" : "public void onInstalled()",
    "returnType" : "void",
    "comment" : "\n     * Called when the filter is installed into the dispatch pipeline.\n     * <p>\n     * This method is called before the input filter receives any input events.\n     * The input filter should take this opportunity to prepare itself.\n     * </p>\n     ",
    "links" : [ ]
  }, {
    "name" : "public void onUninstalled()",
    "returnType" : "void",
    "comment" : "\n     * Called when the filter is uninstalled from the dispatch pipeline.\n     * <p>\n     * This method is called after the input filter receives its last input event.\n     * The input filter should take this opportunity to clean up.\n     * </p>\n     ",
    "links" : [ ]
  } ],
  "methodNames" : [ "public final void install(IInputFilterHost host)", "public final void uninstall()", "public final void filterInputEvent(InputEvent event, int policyFlags)", "public void sendInputEvent(InputEvent event, int policyFlags)", "public void onInputEvent(InputEvent event, int policyFlags)", "public void onInstalled()", "public void onUninstalled()" ],
  "variableNames" : [ "MSG_INSTALL", "MSG_UNINSTALL", "MSG_INPUT_EVENT", "mInboundInputEventConsistencyVerifier", "mOutboundInputEventConsistencyVerifier", "mH", "mHost" ]
}