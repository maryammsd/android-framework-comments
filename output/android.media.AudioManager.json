{
  "filePath" : "/home/maryam/clearblue/files/android-source-30/android/media/AudioManager.java",
  "packageName" : "android.media",
  "className" : "AudioManager",
  "comment" : "\n * AudioManager provides access to volume and ringer mode control.\n ",
  "variables" : [ {
    "name" : "mOriginalContext",
    "type" : "Context",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mApplicationContext",
    "type" : "Context",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mVolumeKeyUpTime",
    "type" : "long",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mUseVolumeKeySounds",
    "type" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mUseFixedVolume",
    "type" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "TAG",
    "type" : "String",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "DEBUG",
    "type" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "sAudioPortEventHandler",
    "type" : "AudioPortEventHandler",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "sAudioAudioVolumeGroupChangedHandler",
    "type" : "AudioVolumeGroupChangeHandler",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "ACTION_AUDIO_BECOMING_NOISY",
    "type" : "String",
    "comment" : "\n     * Broadcast intent, a hint for applications that audio is about to become\n     * 'noisy' due to a change in audio outputs. For example, this intent may\n     * be sent when a wired headset is unplugged, or when an A2DP audio\n     * sink is disconnected, and the audio system is about to automatically\n     * switch audio route to the speaker. Applications that are controlling\n     * audio streams may consider pausing, reducing volume or some other action\n     * on receipt of this intent so as not to surprise the user with audio\n     * from the speaker.\n     ",
    "links" : [ ]
  }, {
    "name" : "RINGER_MODE_CHANGED_ACTION",
    "type" : "String",
    "comment" : "\n     * Sticky broadcast intent action indicating that the ringer mode has\n     * changed. Includes the new ringer mode.\n     *\n     * @see #EXTRA_RINGER_MODE\n     ",
    "links" : [ ]
  }, {
    "name" : "INTERNAL_RINGER_MODE_CHANGED_ACTION",
    "type" : "String",
    "comment" : "\n     * @hide\n     * Sticky broadcast intent action indicating that the internal ringer mode has\n     * changed. Includes the new ringer mode.\n     *\n     * @see #EXTRA_RINGER_MODE\n     ",
    "links" : [ ]
  }, {
    "name" : "EXTRA_RINGER_MODE",
    "type" : "String",
    "comment" : "\n     * The new ringer mode.\n     *\n     * @see #RINGER_MODE_CHANGED_ACTION\n     * @see #RINGER_MODE_NORMAL\n     * @see #RINGER_MODE_SILENT\n     * @see #RINGER_MODE_VIBRATE\n     ",
    "links" : [ ]
  }, {
    "name" : "VIBRATE_SETTING_CHANGED_ACTION",
    "type" : "String",
    "comment" : "\n     * Broadcast intent action indicating that the vibrate setting has\n     * changed. Includes the vibrate type and its new setting.\n     *\n     * @see #EXTRA_VIBRATE_TYPE\n     * @see #EXTRA_VIBRATE_SETTING\n     * @deprecated Applications should maintain their own vibrate policy based on\n     * current ringer mode and listen to {@link #RINGER_MODE_CHANGED_ACTION} instead.\n     ",
    "links" : [ "#RINGER_MODE_CHANGED_ACTION" ]
  }, {
    "name" : "VOLUME_CHANGED_ACTION",
    "type" : "String",
    "comment" : "\n     * @hide Broadcast intent when the volume for a particular stream type changes.\n     * Includes the stream, the new volume and previous volumes.\n     * Notes:\n     *  - for internal platform use only, do not make public,\n     *  - never used for \"remote\" volume changes\n     *\n     * @see #EXTRA_VOLUME_STREAM_TYPE\n     * @see #EXTRA_VOLUME_STREAM_VALUE\n     * @see #EXTRA_PREV_VOLUME_STREAM_VALUE\n     ",
    "links" : [ ]
  }, {
    "name" : "STREAM_DEVICES_CHANGED_ACTION",
    "type" : "String",
    "comment" : "\n     * @hide Broadcast intent when the devices for a particular stream type changes.\n     * Includes the stream, the new devices and previous devices.\n     * Notes:\n     *  - for internal platform use only, do not make public,\n     *  - never used for \"remote\" volume changes\n     *\n     * @see #EXTRA_VOLUME_STREAM_TYPE\n     * @see #EXTRA_VOLUME_STREAM_DEVICES\n     * @see #EXTRA_PREV_VOLUME_STREAM_DEVICES\n     * @see #getDevicesForStream\n     ",
    "links" : [ ]
  }, {
    "name" : "STREAM_MUTE_CHANGED_ACTION",
    "type" : "String",
    "comment" : "\n     * @hide Broadcast intent when a stream mute state changes.\n     * Includes the stream that changed and the new mute state\n     *\n     * @see #EXTRA_VOLUME_STREAM_TYPE\n     * @see #EXTRA_STREAM_VOLUME_MUTED\n     ",
    "links" : [ ]
  }, {
    "name" : "MASTER_MUTE_CHANGED_ACTION",
    "type" : "String",
    "comment" : "\n     * @hide Broadcast intent when the master mute state changes.\n     * Includes the the new volume\n     *\n     * @see #EXTRA_MASTER_VOLUME_MUTED\n     ",
    "links" : [ ]
  }, {
    "name" : "EXTRA_VIBRATE_SETTING",
    "type" : "String",
    "comment" : "\n     * The new vibrate setting for a particular type.\n     *\n     * @see #VIBRATE_SETTING_CHANGED_ACTION\n     * @see #EXTRA_VIBRATE_TYPE\n     * @see #VIBRATE_SETTING_ON\n     * @see #VIBRATE_SETTING_OFF\n     * @see #VIBRATE_SETTING_ONLY_SILENT\n     * @deprecated Applications should maintain their own vibrate policy based on\n     * current ringer mode and listen to {@link #RINGER_MODE_CHANGED_ACTION} instead.\n     ",
    "links" : [ "#RINGER_MODE_CHANGED_ACTION" ]
  }, {
    "name" : "EXTRA_VIBRATE_TYPE",
    "type" : "String",
    "comment" : "\n     * The vibrate type whose setting has changed.\n     *\n     * @see #VIBRATE_SETTING_CHANGED_ACTION\n     * @see #VIBRATE_TYPE_NOTIFICATION\n     * @see #VIBRATE_TYPE_RINGER\n     * @deprecated Applications should maintain their own vibrate policy based on\n     * current ringer mode and listen to {@link #RINGER_MODE_CHANGED_ACTION} instead.\n     ",
    "links" : [ "#RINGER_MODE_CHANGED_ACTION" ]
  }, {
    "name" : "EXTRA_VOLUME_STREAM_TYPE",
    "type" : "String",
    "comment" : "\n     * @hide The stream type for the volume changed intent.\n     ",
    "links" : [ ]
  }, {
    "name" : "EXTRA_VOLUME_STREAM_TYPE_ALIAS",
    "type" : "String",
    "comment" : "\n     * @hide\n     * The stream type alias for the volume changed intent.\n     * For instance the intent may indicate a change of the {@link #STREAM_NOTIFICATION} stream\n     * type (as indicated by the {@link #EXTRA_VOLUME_STREAM_TYPE} extra), but this is also\n     * reflected by a change of the volume of its alias, {@link #STREAM_RING} on some devices,\n     * {@link #STREAM_MUSIC} on others (e.g. a television).\n     ",
    "links" : [ "#EXTRA_VOLUME_STREAM_TYPE", "#STREAM_MUSIC", "#STREAM_RING", "#STREAM_NOTIFICATION" ]
  }, {
    "name" : "EXTRA_VOLUME_STREAM_VALUE",
    "type" : "String",
    "comment" : "\n     * @hide The volume associated with the stream for the volume changed intent.\n     ",
    "links" : [ ]
  }, {
    "name" : "EXTRA_PREV_VOLUME_STREAM_VALUE",
    "type" : "String",
    "comment" : "\n     * @hide The previous volume associated with the stream for the volume changed intent.\n     ",
    "links" : [ ]
  }, {
    "name" : "EXTRA_VOLUME_STREAM_DEVICES",
    "type" : "String",
    "comment" : "\n     * @hide The devices associated with the stream for the stream devices changed intent.\n     ",
    "links" : [ ]
  }, {
    "name" : "EXTRA_PREV_VOLUME_STREAM_DEVICES",
    "type" : "String",
    "comment" : "\n     * @hide The previous devices associated with the stream for the stream devices changed intent.\n     ",
    "links" : [ ]
  }, {
    "name" : "EXTRA_MASTER_VOLUME_MUTED",
    "type" : "String",
    "comment" : "\n     * @hide The new master volume mute state for the master mute changed intent.\n     * Value is boolean\n     ",
    "links" : [ ]
  }, {
    "name" : "EXTRA_STREAM_VOLUME_MUTED",
    "type" : "String",
    "comment" : "\n     * @hide The new stream volume mute state for the stream mute changed intent.\n     * Value is boolean\n     ",
    "links" : [ ]
  }, {
    "name" : "ACTION_HEADSET_PLUG",
    "type" : "String",
    "comment" : "\n     * Broadcast Action: Wired Headset plugged in or unplugged.\n     *\n     * You <em>cannot</em> receive this through components declared\n     * in manifests, only by explicitly registering for it with\n     * {@link Context#registerReceiver(BroadcastReceiver, IntentFilter)\n     * Context.registerReceiver()}.\n     *\n     * <p>The intent will have the following extra values:\n     * <ul>\n     *   <li><em>state</em> - 0 for unplugged, 1 for plugged. </li>\n     *   <li><em>name</em> - Headset type, human readable string </li>\n     *   <li><em>microphone</em> - 1 if headset has a microphone, 0 otherwise </li>\n     * </ul>\n     * </ul>\n     ",
    "links" : [ "android.content.Context#registerReceiver(BroadcastReceiver" ]
  }, {
    "name" : "ACTION_HDMI_AUDIO_PLUG",
    "type" : "String",
    "comment" : "\n     * Broadcast Action: A sticky broadcast indicating an HDMI cable was plugged or unplugged.\n     *\n     * The intent will have the following extra values: {@link #EXTRA_AUDIO_PLUG_STATE},\n     * {@link #EXTRA_MAX_CHANNEL_COUNT}, {@link #EXTRA_ENCODINGS}.\n     * <p>It can only be received by explicitly registering for it with\n     * {@link Context#registerReceiver(BroadcastReceiver, IntentFilter)}.\n     ",
    "links" : [ "#EXTRA_AUDIO_PLUG_STATE", "#EXTRA_ENCODINGS", "#EXTRA_MAX_CHANNEL_COUNT", "android.content.Context#registerReceiver(BroadcastReceiver" ]
  }, {
    "name" : "EXTRA_AUDIO_PLUG_STATE",
    "type" : "String",
    "comment" : "\n     * Extra used in {@link #ACTION_HDMI_AUDIO_PLUG} to communicate whether HDMI is plugged in\n     * or unplugged.\n     * An integer value of 1 indicates a plugged-in state, 0 is unplugged.\n     ",
    "links" : [ "#ACTION_HDMI_AUDIO_PLUG" ]
  }, {
    "name" : "EXTRA_MAX_CHANNEL_COUNT",
    "type" : "String",
    "comment" : "\n     * Extra used in {@link #ACTION_HDMI_AUDIO_PLUG} to define the maximum number of channels\n     * supported by the HDMI device.\n     * The corresponding integer value is only available when the device is plugged in (as expressed\n     * by {@link #EXTRA_AUDIO_PLUG_STATE}).\n     ",
    "links" : [ "#EXTRA_AUDIO_PLUG_STATE", "#ACTION_HDMI_AUDIO_PLUG" ]
  }, {
    "name" : "EXTRA_ENCODINGS",
    "type" : "String",
    "comment" : "\n     * Extra used in {@link #ACTION_HDMI_AUDIO_PLUG} to define the audio encodings supported by\n     * the connected HDMI device.\n     * The corresponding array of encoding values is only available when the device is plugged in\n     * (as expressed by {@link #EXTRA_AUDIO_PLUG_STATE}). Encoding values are defined in\n     * {@link AudioFormat} (for instance see {@link AudioFormat#ENCODING_PCM_16BIT}). Use\n     * {@link android.content.Intent#getIntArrayExtra(String)} to retrieve the encoding values.\n     ",
    "links" : [ "#EXTRA_AUDIO_PLUG_STATE", "#ACTION_HDMI_AUDIO_PLUG", "android.media.AudioFormat", "android.content.Intent#getIntArrayExtra(String)", "android.media.AudioFormat#ENCODING_PCM_16BIT" ]
  }, {
    "name" : "STREAM_VOICE_CALL",
    "type" : "int",
    "comment" : " Used to identify the volume of audio streams for phone calls ",
    "links" : [ ]
  }, {
    "name" : "STREAM_SYSTEM",
    "type" : "int",
    "comment" : " Used to identify the volume of audio streams for system sounds ",
    "links" : [ ]
  }, {
    "name" : "STREAM_RING",
    "type" : "int",
    "comment" : " Used to identify the volume of audio streams for the phone ring ",
    "links" : [ ]
  }, {
    "name" : "STREAM_MUSIC",
    "type" : "int",
    "comment" : " Used to identify the volume of audio streams for music playback ",
    "links" : [ ]
  }, {
    "name" : "STREAM_ALARM",
    "type" : "int",
    "comment" : " Used to identify the volume of audio streams for alarms ",
    "links" : [ ]
  }, {
    "name" : "STREAM_NOTIFICATION",
    "type" : "int",
    "comment" : " Used to identify the volume of audio streams for notifications ",
    "links" : [ ]
  }, {
    "name" : "STREAM_BLUETOOTH_SCO",
    "type" : "int",
    "comment" : " @hide Used to identify the volume of audio streams for phone calls when connected\n     *        to bluetooth ",
    "links" : [ ]
  }, {
    "name" : "STREAM_SYSTEM_ENFORCED",
    "type" : "int",
    "comment" : " @hide Used to identify the volume of audio streams for enforced system sounds\n     *        in certain countries (e.g camera in Japan) ",
    "links" : [ ]
  }, {
    "name" : "STREAM_DTMF",
    "type" : "int",
    "comment" : " Used to identify the volume of audio streams for DTMF Tones ",
    "links" : [ ]
  }, {
    "name" : "STREAM_TTS",
    "type" : "int",
    "comment" : " @hide Used to identify the volume of audio streams exclusively transmitted through the\n     *        speaker (TTS) of the device ",
    "links" : [ ]
  }, {
    "name" : "STREAM_ACCESSIBILITY",
    "type" : "int",
    "comment" : " Used to identify the volume of audio streams for accessibility prompts ",
    "links" : [ ]
  }, {
    "name" : "STREAM_ASSISTANT",
    "type" : "int",
    "comment" : " @hide Used to identify the volume of audio streams for virtual assistant ",
    "links" : [ ]
  }, {
    "name" : "NUM_STREAMS",
    "type" : "int",
    "comment" : "\n     * @deprecated Do not iterate on volume stream type values.\n     ",
    "links" : [ ]
  }, {
    "name" : "ADJUST_RAISE",
    "type" : "int",
    "comment" : "\n     * Increase the ringer volume.\n     *\n     * @see #adjustVolume(int, int)\n     * @see #adjustStreamVolume(int, int, int)\n     ",
    "links" : [ ]
  }, {
    "name" : "ADJUST_LOWER",
    "type" : "int",
    "comment" : "\n     * Decrease the ringer volume.\n     *\n     * @see #adjustVolume(int, int)\n     * @see #adjustStreamVolume(int, int, int)\n     ",
    "links" : [ ]
  }, {
    "name" : "ADJUST_SAME",
    "type" : "int",
    "comment" : "\n     * Maintain the previous ringer volume. This may be useful when needing to\n     * show the volume toast without actually modifying the volume.\n     *\n     * @see #adjustVolume(int, int)\n     * @see #adjustStreamVolume(int, int, int)\n     ",
    "links" : [ ]
  }, {
    "name" : "ADJUST_MUTE",
    "type" : "int",
    "comment" : "\n     * Mute the volume. Has no effect if the stream is already muted.\n     *\n     * @see #adjustVolume(int, int)\n     * @see #adjustStreamVolume(int, int, int)\n     ",
    "links" : [ ]
  }, {
    "name" : "ADJUST_UNMUTE",
    "type" : "int",
    "comment" : "\n     * Unmute the volume. Has no effect if the stream is not muted.\n     *\n     * @see #adjustVolume(int, int)\n     * @see #adjustStreamVolume(int, int, int)\n     ",
    "links" : [ ]
  }, {
    "name" : "ADJUST_TOGGLE_MUTE",
    "type" : "int",
    "comment" : "\n     * Toggle the mute state. If muted the stream will be unmuted. If not muted\n     * the stream will be muted.\n     *\n     * @see #adjustVolume(int, int)\n     * @see #adjustStreamVolume(int, int, int)\n     ",
    "links" : [ ]
  }, {
    "name" : "FLAG_SHOW_UI",
    "type" : "int",
    "comment" : "\n     * Show a toast containing the current volume.\n     *\n     * @see #adjustStreamVolume(int, int, int)\n     * @see #adjustVolume(int, int)\n     * @see #setStreamVolume(int, int, int)\n     * @see #setRingerMode(int)\n     ",
    "links" : [ ]
  }, {
    "name" : "FLAG_ALLOW_RINGER_MODES",
    "type" : "int",
    "comment" : "\n     * Whether to include ringer modes as possible options when changing volume.\n     * For example, if true and volume level is 0 and the volume is adjusted\n     * with {@link #ADJUST_LOWER}, then the ringer mode may switch the silent or\n     * vibrate mode.\n     * <p>\n     * By default this is on for the ring stream. If this flag is included,\n     * this behavior will be present regardless of the stream type being\n     * affected by the ringer mode.\n     *\n     * @see #adjustVolume(int, int)\n     * @see #adjustStreamVolume(int, int, int)\n     ",
    "links" : [ "#ADJUST_LOWER" ]
  }, {
    "name" : "FLAG_PLAY_SOUND",
    "type" : "int",
    "comment" : "\n     * Whether to play a sound when changing the volume.\n     * <p>\n     * If this is given to {@link #adjustVolume(int, int)} or\n     * {@link #adjustSuggestedStreamVolume(int, int, int)}, it may be ignored\n     * in some cases (for example, the decided stream type is not\n     * {@link AudioManager#STREAM_RING}, or the volume is being adjusted\n     * downward).\n     *\n     * @see #adjustStreamVolume(int, int, int)\n     * @see #adjustVolume(int, int)\n     * @see #setStreamVolume(int, int, int)\n     ",
    "links" : [ "android.media.AudioManager#STREAM_RING", "#adjustSuggestedStreamVolume(int", "#adjustVolume(int" ]
  }, {
    "name" : "FLAG_REMOVE_SOUND_AND_VIBRATE",
    "type" : "int",
    "comment" : "\n     * Removes any sounds/vibrate that may be in the queue, or are playing (related to\n     * changing volume).\n     ",
    "links" : [ ]
  }, {
    "name" : "FLAG_VIBRATE",
    "type" : "int",
    "comment" : "\n     * Whether to vibrate if going into the vibrate ringer mode.\n     ",
    "links" : [ ]
  }, {
    "name" : "FLAG_FIXED_VOLUME",
    "type" : "int",
    "comment" : "\n     * Indicates to VolumePanel that the volume slider should be disabled as user\n     * cannot change the stream volume\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "FLAG_BLUETOOTH_ABS_VOLUME",
    "type" : "int",
    "comment" : "\n     * Indicates the volume set/adjust call is for Bluetooth absolute volume\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "FLAG_SHOW_SILENT_HINT",
    "type" : "int",
    "comment" : "\n     * Adjusting the volume was prevented due to silent mode, display a hint in the UI.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "FLAG_HDMI_SYSTEM_AUDIO_VOLUME",
    "type" : "int",
    "comment" : "\n     * Indicates the volume call is for Hdmi Cec system audio volume\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "FLAG_ACTIVE_MEDIA_ONLY",
    "type" : "int",
    "comment" : "\n     * Indicates that this should only be handled if media is actively playing.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "FLAG_SHOW_UI_WARNINGS",
    "type" : "int",
    "comment" : "\n     * Like FLAG_SHOW_UI, but only dialog warnings and confirmations, no sliders.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "FLAG_SHOW_VIBRATE_HINT",
    "type" : "int",
    "comment" : "\n     * Adjusting the volume down from vibrated was prevented, display a hint in the UI.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "FLAG_FROM_KEY",
    "type" : "int",
    "comment" : "\n     * Adjusting the volume due to a hardware key press.\n     * This flag can be used in the places in order to denote (or check) that a volume adjustment\n     * request is from a hardware key press. (e.g. {@link MediaController}).\n     * @hide\n     ",
    "links" : [ "android.media.session.MediaController" ]
  }, {
    "name" : "FLAG_NAMES",
    "type" : "TreeMap<Integer, String>",
    "comment" : " The iterator of TreeMap#entrySet() returns the entries in ascending key order.",
    "links" : [ ]
  }, {
    "name" : "RINGER_MODE_SILENT",
    "type" : "int",
    "comment" : "\n     * Ringer mode that will be silent and will not vibrate. (This overrides the\n     * vibrate setting.)\n     *\n     * @see #setRingerMode(int)\n     * @see #getRingerMode()\n     ",
    "links" : [ ]
  }, {
    "name" : "RINGER_MODE_VIBRATE",
    "type" : "int",
    "comment" : "\n     * Ringer mode that will be silent and will vibrate. (This will cause the\n     * phone ringer to always vibrate, but the notification vibrate to only\n     * vibrate if set.)\n     *\n     * @see #setRingerMode(int)\n     * @see #getRingerMode()\n     ",
    "links" : [ ]
  }, {
    "name" : "RINGER_MODE_NORMAL",
    "type" : "int",
    "comment" : "\n     * Ringer mode that may be audible and may vibrate. It will be audible if\n     * the volume before changing out of this mode was audible. It will vibrate\n     * if the vibrate setting is on.\n     *\n     * @see #setRingerMode(int)\n     * @see #getRingerMode()\n     ",
    "links" : [ ]
  }, {
    "name" : "RINGER_MODE_MAX",
    "type" : "int",
    "comment" : "\n     * Maximum valid ringer mode value. Values must start from 0 and be contiguous.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "VIBRATE_TYPE_RINGER",
    "type" : "int",
    "comment" : "\n     * Vibrate type that corresponds to the ringer.\n     *\n     * @see #setVibrateSetting(int, int)\n     * @see #getVibrateSetting(int)\n     * @see #shouldVibrate(int)\n     * @deprecated Applications should maintain their own vibrate policy based on\n     * current ringer mode that can be queried via {@link #getRingerMode()}.\n     ",
    "links" : [ "#getRingerMode()" ]
  }, {
    "name" : "VIBRATE_TYPE_NOTIFICATION",
    "type" : "int",
    "comment" : "\n     * Vibrate type that corresponds to notifications.\n     *\n     * @see #setVibrateSetting(int, int)\n     * @see #getVibrateSetting(int)\n     * @see #shouldVibrate(int)\n     * @deprecated Applications should maintain their own vibrate policy based on\n     * current ringer mode that can be queried via {@link #getRingerMode()}.\n     ",
    "links" : [ "#getRingerMode()" ]
  }, {
    "name" : "VIBRATE_SETTING_OFF",
    "type" : "int",
    "comment" : "\n     * Vibrate setting that suggests to never vibrate.\n     *\n     * @see #setVibrateSetting(int, int)\n     * @see #getVibrateSetting(int)\n     * @deprecated Applications should maintain their own vibrate policy based on\n     * current ringer mode that can be queried via {@link #getRingerMode()}.\n     ",
    "links" : [ "#getRingerMode()" ]
  }, {
    "name" : "VIBRATE_SETTING_ON",
    "type" : "int",
    "comment" : "\n     * Vibrate setting that suggests to vibrate when possible.\n     *\n     * @see #setVibrateSetting(int, int)\n     * @see #getVibrateSetting(int)\n     * @deprecated Applications should maintain their own vibrate policy based on\n     * current ringer mode that can be queried via {@link #getRingerMode()}.\n     ",
    "links" : [ "#getRingerMode()" ]
  }, {
    "name" : "VIBRATE_SETTING_ONLY_SILENT",
    "type" : "int",
    "comment" : "\n     * Vibrate setting that suggests to only vibrate when in the vibrate ringer\n     * mode.\n     *\n     * @see #setVibrateSetting(int, int)\n     * @see #getVibrateSetting(int)\n     * @deprecated Applications should maintain their own vibrate policy based on\n     * current ringer mode that can be queried via {@link #getRingerMode()}.\n     ",
    "links" : [ "#getRingerMode()" ]
  }, {
    "name" : "USE_DEFAULT_STREAM_TYPE",
    "type" : "int",
    "comment" : "\n     * Suggests using the default stream type. This may not be used in all\n     * places a stream type is needed.\n     ",
    "links" : [ ]
  }, {
    "name" : "sService",
    "type" : "IAudioService",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "VOLUME_MIN_DB",
    "type" : "float",
    "comment" : " keep in sync with frameworks/av/services/audiopolicy/common/include/Volume.h",
    "links" : [ ]
  }, {
    "name" : "mPrefDevListenerLock",
    "type" : "Object",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mPrefDevListeners",
    "type" : "ArrayList<PrefDevListenerInfo>",
    "comment" : "\n     * List of listeners for preferred device for strategy and their associated Executor.\n     * List is lazy-initialized on first registration\n     ",
    "links" : [ ]
  }, {
    "name" : "mPrefDevDispatcherStub",
    "type" : "StrategyPreferredDeviceDispatcherStub",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "ACTION_SCO_AUDIO_STATE_CHANGED",
    "type" : "String",
    "comment" : "\n     * Sticky broadcast intent action indicating that the Bluetooth SCO audio\n     * connection state has changed. The intent contains on extra {@link #EXTRA_SCO_AUDIO_STATE}\n     * indicating the new state which is either {@link #SCO_AUDIO_STATE_DISCONNECTED}\n     * or {@link #SCO_AUDIO_STATE_CONNECTED}\n     *\n     * @see #startBluetoothSco()\n     * @deprecated Use  {@link #ACTION_SCO_AUDIO_STATE_UPDATED} instead\n     ",
    "links" : [ "#ACTION_SCO_AUDIO_STATE_UPDATED", "#SCO_AUDIO_STATE_DISCONNECTED", "#EXTRA_SCO_AUDIO_STATE", "#SCO_AUDIO_STATE_CONNECTED" ]
  }, {
    "name" : "ACTION_SCO_AUDIO_STATE_UPDATED",
    "type" : "String",
    "comment" : "\n     * Sticky broadcast intent action indicating that the Bluetooth SCO audio\n     * connection state has been updated.\n     * <p>This intent has two extras:\n     * <ul>\n     *   <li> {@link #EXTRA_SCO_AUDIO_STATE} - The new SCO audio state. </li>\n     *   <li> {@link #EXTRA_SCO_AUDIO_PREVIOUS_STATE}- The previous SCO audio state. </li>\n     * </ul>\n     * <p> EXTRA_SCO_AUDIO_STATE or EXTRA_SCO_AUDIO_PREVIOUS_STATE can be any of:\n     * <ul>\n     *   <li> {@link #SCO_AUDIO_STATE_DISCONNECTED}, </li>\n     *   <li> {@link #SCO_AUDIO_STATE_CONNECTING} or </li>\n     *   <li> {@link #SCO_AUDIO_STATE_CONNECTED}, </li>\n     * </ul>\n     * @see #startBluetoothSco()\n     ",
    "links" : [ "#EXTRA_SCO_AUDIO_PREVIOUS_STATE", "#SCO_AUDIO_STATE_CONNECTING", "#SCO_AUDIO_STATE_DISCONNECTED", "#EXTRA_SCO_AUDIO_STATE", "#SCO_AUDIO_STATE_CONNECTED" ]
  }, {
    "name" : "EXTRA_SCO_AUDIO_STATE",
    "type" : "String",
    "comment" : "\n     * Extra for intent {@link #ACTION_SCO_AUDIO_STATE_CHANGED} or\n     * {@link #ACTION_SCO_AUDIO_STATE_UPDATED} containing the new bluetooth SCO connection state.\n     ",
    "links" : [ "#ACTION_SCO_AUDIO_STATE_UPDATED", "#ACTION_SCO_AUDIO_STATE_CHANGED" ]
  }, {
    "name" : "EXTRA_SCO_AUDIO_PREVIOUS_STATE",
    "type" : "String",
    "comment" : "\n     * Extra for intent {@link #ACTION_SCO_AUDIO_STATE_UPDATED} containing the previous\n     * bluetooth SCO connection state.\n     ",
    "links" : [ "#ACTION_SCO_AUDIO_STATE_UPDATED" ]
  }, {
    "name" : "SCO_AUDIO_STATE_DISCONNECTED",
    "type" : "int",
    "comment" : "\n     * Value for extra EXTRA_SCO_AUDIO_STATE or EXTRA_SCO_AUDIO_PREVIOUS_STATE\n     * indicating that the SCO audio channel is not established\n     ",
    "links" : [ ]
  }, {
    "name" : "SCO_AUDIO_STATE_CONNECTED",
    "type" : "int",
    "comment" : "\n     * Value for extra {@link #EXTRA_SCO_AUDIO_STATE} or {@link #EXTRA_SCO_AUDIO_PREVIOUS_STATE}\n     * indicating that the SCO audio channel is established\n     ",
    "links" : [ "#EXTRA_SCO_AUDIO_PREVIOUS_STATE", "#EXTRA_SCO_AUDIO_STATE" ]
  }, {
    "name" : "SCO_AUDIO_STATE_CONNECTING",
    "type" : "int",
    "comment" : "\n     * Value for extra EXTRA_SCO_AUDIO_STATE or EXTRA_SCO_AUDIO_PREVIOUS_STATE\n     * indicating that the SCO audio channel is being established\n     ",
    "links" : [ ]
  }, {
    "name" : "SCO_AUDIO_STATE_ERROR",
    "type" : "int",
    "comment" : "\n     * Value for extra EXTRA_SCO_AUDIO_STATE indicating that\n     * there was an error trying to obtain the state\n     ",
    "links" : [ ]
  }, {
    "name" : "ACTION_MICROPHONE_MUTE_CHANGED",
    "type" : "String",
    "comment" : "\n     * Broadcast Action: microphone muting state changed.\n     *\n     * You <em>cannot</em> receive this through components declared\n     * in manifests, only by explicitly registering for it with\n     * {@link Context#registerReceiver(BroadcastReceiver, IntentFilter)\n     * Context.registerReceiver()}.\n     *\n     * <p>The intent has no extra values, use {@link #isMicrophoneMute} to check whether the\n     * microphone is muted.\n     ",
    "links" : [ "android.content.Context#registerReceiver(BroadcastReceiver", "#isMicrophoneMute" ]
  }, {
    "name" : "ACTION_SPEAKERPHONE_STATE_CHANGED",
    "type" : "String",
    "comment" : "\n     * Broadcast Action: speakerphone state changed.\n     *\n     * You <em>cannot</em> receive this through components declared\n     * in manifests, only by explicitly registering for it with\n     * {@link Context#registerReceiver(BroadcastReceiver, IntentFilter)\n     * Context.registerReceiver()}.\n     *\n     * <p>The intent has no extra values, use {@link #isSpeakerphoneOn} to check whether the\n     * speakerphone functionality is enabled or not.\n     ",
    "links" : [ "android.content.Context#registerReceiver(BroadcastReceiver", "#isSpeakerphoneOn" ]
  }, {
    "name" : "MODE_INVALID",
    "type" : "int",
    "comment" : "\n     * Invalid audio mode.\n     ",
    "links" : [ ]
  }, {
    "name" : "MODE_CURRENT",
    "type" : "int",
    "comment" : "\n     * Current audio mode. Used to apply audio routing to current mode.\n     ",
    "links" : [ ]
  }, {
    "name" : "MODE_NORMAL",
    "type" : "int",
    "comment" : "\n     * Normal audio mode: not ringing and no call established.\n     ",
    "links" : [ ]
  }, {
    "name" : "MODE_RINGTONE",
    "type" : "int",
    "comment" : "\n     * Ringing audio mode. An incoming is being signaled.\n     ",
    "links" : [ ]
  }, {
    "name" : "MODE_IN_CALL",
    "type" : "int",
    "comment" : "\n     * In call audio mode. A telephony call is established.\n     ",
    "links" : [ ]
  }, {
    "name" : "MODE_IN_COMMUNICATION",
    "type" : "int",
    "comment" : "\n     * In communication audio mode. An audio/video chat or VoIP call is established.\n     ",
    "links" : [ ]
  }, {
    "name" : "MODE_CALL_SCREENING",
    "type" : "int",
    "comment" : "\n     * Call screening in progress. Call is connected and audio is accessible to call\n     * screening applications but other audio use cases are still possible.\n     ",
    "links" : [ ]
  }, {
    "name" : "ROUTE_EARPIECE",
    "type" : "int",
    "comment" : "\n     * Routing audio output to earpiece\n     * @deprecated   Do not set audio routing directly, use setSpeakerphoneOn(),\n     * setBluetoothScoOn() methods instead.\n     ",
    "links" : [ ]
  }, {
    "name" : "ROUTE_SPEAKER",
    "type" : "int",
    "comment" : "\n     * Routing audio output to speaker\n     * @deprecated   Do not set audio routing directly, use setSpeakerphoneOn(),\n     * setBluetoothScoOn() methods instead.\n     ",
    "links" : [ ]
  }, {
    "name" : "ROUTE_BLUETOOTH",
    "type" : "int",
    "comment" : "\n     * @deprecated use {@link #ROUTE_BLUETOOTH_SCO}\n     * @deprecated   Do not set audio routing directly, use setSpeakerphoneOn(),\n     * setBluetoothScoOn() methods instead.\n     ",
    "links" : [ "#ROUTE_BLUETOOTH_SCO" ]
  }, {
    "name" : "ROUTE_BLUETOOTH_SCO",
    "type" : "int",
    "comment" : "\n     * Routing audio output to bluetooth SCO\n     * @deprecated   Do not set audio routing directly, use setSpeakerphoneOn(),\n     * setBluetoothScoOn() methods instead.\n     ",
    "links" : [ ]
  }, {
    "name" : "ROUTE_HEADSET",
    "type" : "int",
    "comment" : "\n     * Routing audio output to headset\n     * @deprecated   Do not set audio routing directly, use setSpeakerphoneOn(),\n     * setBluetoothScoOn() methods instead.\n     ",
    "links" : [ ]
  }, {
    "name" : "ROUTE_BLUETOOTH_A2DP",
    "type" : "int",
    "comment" : "\n     * Routing audio output to bluetooth A2DP\n     * @deprecated   Do not set audio routing directly, use setSpeakerphoneOn(),\n     * setBluetoothScoOn() methods instead.\n     ",
    "links" : [ ]
  }, {
    "name" : "ROUTE_ALL",
    "type" : "int",
    "comment" : "\n     * Used for mask parameter of {@link #setRouting(int,int,int)}.\n     * @deprecated   Do not set audio routing directly, use setSpeakerphoneOn(),\n     * setBluetoothScoOn() methods instead.\n     ",
    "links" : [ "#setRouting(int" ]
  }, {
    "name" : "AUDIO_SESSION_ID_GENERATE",
    "type" : "int",
    "comment" : "\n     * A special audio session ID to indicate that the audio session ID isn't known and the\n     * framework should generate a new value. This can be used when building a new\n     * {@link AudioTrack} instance with\n     * {@link AudioTrack#AudioTrack(AudioAttributes, AudioFormat, int, int, int)}.\n     ",
    "links" : [ "android.media.AudioTrack#AudioTrack(AudioAttributes", "android.media.AudioTrack" ]
  }, {
    "name" : "FX_KEY_CLICK",
    "type" : "int",
    "comment" : "\n     * Keyboard and direction pad click sound\n     * @see #playSoundEffect(int)\n     ",
    "links" : [ ]
  }, {
    "name" : "FX_FOCUS_NAVIGATION_UP",
    "type" : "int",
    "comment" : "\n     * Focus has moved up\n     * @see #playSoundEffect(int)\n     ",
    "links" : [ ]
  }, {
    "name" : "FX_FOCUS_NAVIGATION_DOWN",
    "type" : "int",
    "comment" : "\n     * Focus has moved down\n     * @see #playSoundEffect(int)\n     ",
    "links" : [ ]
  }, {
    "name" : "FX_FOCUS_NAVIGATION_LEFT",
    "type" : "int",
    "comment" : "\n     * Focus has moved left\n     * @see #playSoundEffect(int)\n     ",
    "links" : [ ]
  }, {
    "name" : "FX_FOCUS_NAVIGATION_RIGHT",
    "type" : "int",
    "comment" : "\n     * Focus has moved right\n     * @see #playSoundEffect(int)\n     ",
    "links" : [ ]
  }, {
    "name" : "FX_KEYPRESS_STANDARD",
    "type" : "int",
    "comment" : "\n     * IME standard keypress sound\n     * @see #playSoundEffect(int)\n     ",
    "links" : [ ]
  }, {
    "name" : "FX_KEYPRESS_SPACEBAR",
    "type" : "int",
    "comment" : "\n     * IME spacebar keypress sound\n     * @see #playSoundEffect(int)\n     ",
    "links" : [ ]
  }, {
    "name" : "FX_KEYPRESS_DELETE",
    "type" : "int",
    "comment" : "\n     * IME delete keypress sound\n     * @see #playSoundEffect(int)\n     ",
    "links" : [ ]
  }, {
    "name" : "FX_KEYPRESS_RETURN",
    "type" : "int",
    "comment" : "\n     * IME return_keypress sound\n     * @see #playSoundEffect(int)\n     ",
    "links" : [ ]
  }, {
    "name" : "FX_KEYPRESS_INVALID",
    "type" : "int",
    "comment" : "\n     * Invalid keypress sound\n     * @see #playSoundEffect(int)\n     ",
    "links" : [ ]
  }, {
    "name" : "NUM_SOUND_EFFECTS",
    "type" : "int",
    "comment" : "\n     * @hide Number of sound effects\n     ",
    "links" : [ ]
  }, {
    "name" : "AUDIOFOCUS_NONE",
    "type" : "int",
    "comment" : "\n     * Used to indicate no audio focus has been gained or lost, or requested.\n     ",
    "links" : [ ]
  }, {
    "name" : "AUDIOFOCUS_GAIN",
    "type" : "int",
    "comment" : "\n     * Used to indicate a gain of audio focus, or a request of audio focus, of unknown duration.\n     * @see OnAudioFocusChangeListener#onAudioFocusChange(int)\n     * @see #requestAudioFocus(OnAudioFocusChangeListener, int, int)\n     ",
    "links" : [ ]
  }, {
    "name" : "AUDIOFOCUS_GAIN_TRANSIENT",
    "type" : "int",
    "comment" : "\n     * Used to indicate a temporary gain or request of audio focus, anticipated to last a short\n     * amount of time. Examples of temporary changes are the playback of driving directions, or an\n     * event notification.\n     * @see OnAudioFocusChangeListener#onAudioFocusChange(int)\n     * @see #requestAudioFocus(OnAudioFocusChangeListener, int, int)\n     ",
    "links" : [ ]
  }, {
    "name" : "AUDIOFOCUS_GAIN_TRANSIENT_MAY_DUCK",
    "type" : "int",
    "comment" : "\n     * Used to indicate a temporary request of audio focus, anticipated to last a short\n     * amount of time, and where it is acceptable for other audio applications to keep playing\n     * after having lowered their output level (also referred to as \"ducking\").\n     * Examples of temporary changes are the playback of driving directions where playback of music\n     * in the background is acceptable.\n     * @see OnAudioFocusChangeListener#onAudioFocusChange(int)\n     * @see #requestAudioFocus(OnAudioFocusChangeListener, int, int)\n     ",
    "links" : [ ]
  }, {
    "name" : "AUDIOFOCUS_GAIN_TRANSIENT_EXCLUSIVE",
    "type" : "int",
    "comment" : "\n     * Used to indicate a temporary request of audio focus, anticipated to last a short\n     * amount of time, during which no other applications, or system components, should play\n     * anything. Examples of exclusive and transient audio focus requests are voice\n     * memo recording and speech recognition, during which the system shouldn't play any\n     * notifications, and media playback should have paused.\n     * @see #requestAudioFocus(OnAudioFocusChangeListener, int, int)\n     ",
    "links" : [ ]
  }, {
    "name" : "AUDIOFOCUS_LOSS",
    "type" : "int",
    "comment" : "\n     * Used to indicate a loss of audio focus of unknown duration.\n     * @see OnAudioFocusChangeListener#onAudioFocusChange(int)\n     ",
    "links" : [ ]
  }, {
    "name" : "AUDIOFOCUS_LOSS_TRANSIENT",
    "type" : "int",
    "comment" : "\n     * Used to indicate a transient loss of audio focus.\n     * @see OnAudioFocusChangeListener#onAudioFocusChange(int)\n     ",
    "links" : [ ]
  }, {
    "name" : "AUDIOFOCUS_LOSS_TRANSIENT_CAN_DUCK",
    "type" : "int",
    "comment" : "\n     * Used to indicate a transient loss of audio focus where the loser of the audio focus can\n     * lower its output volume if it wants to continue playing (also referred to as \"ducking\"), as\n     * the new focus owner doesn't require others to be silent.\n     * @see OnAudioFocusChangeListener#onAudioFocusChange(int)\n     ",
    "links" : [ ]
  }, {
    "name" : "mAudioFocusIdListenerMap",
    "type" : "ConcurrentHashMap<String, FocusRequestInfo>",
    "comment" : "\n     * Map to convert focus event listener IDs, as used in the AudioService audio focus stack,\n     * to actual listener objects.\n     ",
    "links" : [ ]
  }, {
    "name" : "mServiceEventHandlerDelegate",
    "type" : "ServiceEventHandlerDelegate",
    "comment" : "\n     * Handler for events (audio focus change, recording config change) coming from the\n     * audio service.\n     ",
    "links" : [ ]
  }, {
    "name" : "MSSG_FOCUS_CHANGE",
    "type" : "int",
    "comment" : "\n     * Event types\n     ",
    "links" : [ ]
  }, {
    "name" : "MSSG_RECORDING_CONFIG_CHANGE",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "MSSG_PLAYBACK_CONFIG_CHANGE",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mAudioFocusDispatcher",
    "type" : "IAudioFocusDispatcher",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "AUDIOFOCUS_REQUEST_FAILED",
    "type" : "int",
    "comment" : "\n     * A failed focus change request.\n     ",
    "links" : [ ]
  }, {
    "name" : "AUDIOFOCUS_REQUEST_GRANTED",
    "type" : "int",
    "comment" : "\n     * A successful focus change request.\n     ",
    "links" : [ ]
  }, {
    "name" : "AUDIOFOCUS_REQUEST_DELAYED",
    "type" : "int",
    "comment" : "\n      * A focus change request whose granting is delayed: the request was successful, but the\n      * requester will only be granted audio focus once the condition that prevented immediate\n      * granting has ended.\n      * See {@link #requestAudioFocus(AudioFocusRequest)} and\n      * {@link AudioFocusRequest.Builder#setAcceptsDelayedFocusGain(boolean)}\n      ",
    "links" : [ "AudioFocusRequest.Builder#setAcceptsDelayedFocusGain(boolean)", "#requestAudioFocus(AudioFocusRequest)" ]
  }, {
    "name" : "AUDIOFOCUS_REQUEST_WAITING_FOR_EXT_POLICY",
    "type" : "int",
    "comment" : "\n     * @hide\n     * code returned when a synchronous focus request on the client-side is to be blocked\n     * until the external audio focus policy decides on the response for the client\n     ",
    "links" : [ ]
  }, {
    "name" : "EXT_FOCUS_POLICY_TIMEOUT_MS",
    "type" : "int",
    "comment" : "\n     * Timeout duration in ms when waiting on an external focus policy for the result for a\n     * focus request\n     ",
    "links" : [ ]
  }, {
    "name" : "FOCUS_CLIENT_ID_STRING",
    "type" : "String",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mFocusRequestsLock",
    "type" : "Object",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mFocusRequestsAwaitingResult",
    "type" : "HashMap<String, BlockingFocusResultReceiver>",
    "comment" : "\n     * Map of all receivers of focus request results, one per unresolved focus request.\n     * Receivers are added before sending the request to the external focus policy,\n     * and are removed either after receiving the result, or after the timeout.\n     * This variable is lazily initialized.\n     ",
    "links" : [ ]
  }, {
    "name" : "AUDIOFOCUS_FLAG_DELAY_OK",
    "type" : "int",
    "comment" : "\n     * @hide\n     * Use this flag when requesting audio focus to indicate it is ok for the requester to not be\n     * granted audio focus immediately (as indicated by {@link #AUDIOFOCUS_REQUEST_DELAYED}) when\n     * the system is in a state where focus cannot change, but be granted focus later when\n     * this condition ends.\n     ",
    "links" : [ "#AUDIOFOCUS_REQUEST_DELAYED" ]
  }, {
    "name" : "AUDIOFOCUS_FLAG_PAUSES_ON_DUCKABLE_LOSS",
    "type" : "int",
    "comment" : "\n     * @hide\n     * Use this flag when requesting audio focus to indicate that the requester\n     * will pause its media playback (if applicable) when losing audio focus with\n     * {@link #AUDIOFOCUS_LOSS_TRANSIENT_CAN_DUCK}, rather than ducking.\n     * <br>On some platforms, the ducking may be handled without the application being aware of it\n     * (i.e. it will not transiently lose focus). For applications that for instance play spoken\n     * content, such as audio book or podcast players, ducking may never be acceptable, and will\n     * thus always pause. This flag enables them to be declared as such whenever they request focus.\n     ",
    "links" : [ "#AUDIOFOCUS_LOSS_TRANSIENT_CAN_DUCK" ]
  }, {
    "name" : "AUDIOFOCUS_FLAG_LOCK",
    "type" : "int",
    "comment" : "\n     * @hide\n     * Use this flag to lock audio focus so granting is temporarily disabled.\n     * <br>This flag can only be used by owners of a registered\n     * {@link android.media.audiopolicy.AudioPolicy} in\n     * {@link #requestAudioFocus(OnAudioFocusChangeListener, AudioAttributes, int, int, AudioPolicy)}\n     ",
    "links" : [ "#requestAudioFocus(OnAudioFocusChangeListener", "android.media.audiopolicy.AudioPolicy" ]
  }, {
    "name" : "AUDIOFOCUS_FLAGS_APPS",
    "type" : "int",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "AUDIOFOCUS_FLAGS_SYSTEM",
    "type" : "int",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "mPlaybackCallbackList",
    "type" : "List<AudioPlaybackCallbackInfo>",
    "comment" : "\n     * All operations on this list are sync'd on mPlaybackCallbackLock.\n     * List is lazy-initialized in\n     * {@link #registerAudioPlaybackCallback(AudioPlaybackCallback, Handler)}.\n     * List can be null.\n     ",
    "links" : [ "#registerAudioPlaybackCallback(AudioPlaybackCallback" ]
  }, {
    "name" : "mPlaybackCallbackLock",
    "type" : "Object",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mPlayCb",
    "type" : "IPlaybackConfigDispatcher",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "RECORD_CONFIG_EVENT_NONE",
    "type" : "int",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "RECORD_CONFIG_EVENT_START",
    "type" : "int",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "RECORD_CONFIG_EVENT_STOP",
    "type" : "int",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "RECORD_CONFIG_EVENT_UPDATE",
    "type" : "int",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "RECORD_CONFIG_EVENT_RELEASE",
    "type" : "int",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "RECORD_RIID_INVALID",
    "type" : "int",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "RECORDER_STATE_STARTED",
    "type" : "int",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "RECORDER_STATE_STOPPED",
    "type" : "int",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "mRecordCallbackList",
    "type" : "List<AudioRecordingCallbackInfo>",
    "comment" : "\n     * All operations on this list are sync'd on mRecordCallbackLock.\n     * List is lazy-initialized in\n     * {@link #registerAudioRecordingCallback(AudioRecordingCallback, Handler)}.\n     * List can be null.\n     ",
    "links" : [ "#registerAudioRecordingCallback(AudioRecordingCallback" ]
  }, {
    "name" : "mRecordCallbackLock",
    "type" : "Object",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mRecCb",
    "type" : "IRecordingConfigDispatcher",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mICallBack",
    "type" : "IBinder",
    "comment" : "\n      * {@hide}\n      ",
    "links" : [ ]
  }, {
    "name" : "DEVICE_NONE",
    "type" : "int",
    "comment" : " @hide\n     * The audio device code for representing \"no device.\" ",
    "links" : [ ]
  }, {
    "name" : "DEVICE_OUT_EARPIECE",
    "type" : "int",
    "comment" : " @hide\n     *  The audio output device code for the small speaker at the front of the device used\n     *  when placing calls.  Does not refer to an in-ear headphone without attached microphone,\n     *  such as earbuds, earphones, or in-ear monitors (IEM). Those would be handled as a\n     *  {@link #DEVICE_OUT_WIRED_HEADPHONE}.\n     ",
    "links" : [ "#DEVICE_OUT_WIRED_HEADPHONE" ]
  }, {
    "name" : "DEVICE_OUT_SPEAKER",
    "type" : "int",
    "comment" : " @hide\n     *  The audio output device code for the built-in speaker ",
    "links" : [ ]
  }, {
    "name" : "DEVICE_OUT_WIRED_HEADSET",
    "type" : "int",
    "comment" : " @hide\n     * The audio output device code for a wired headset with attached microphone ",
    "links" : [ ]
  }, {
    "name" : "DEVICE_OUT_WIRED_HEADPHONE",
    "type" : "int",
    "comment" : " @hide\n     * The audio output device code for a wired headphone without attached microphone ",
    "links" : [ ]
  }, {
    "name" : "DEVICE_OUT_USB_HEADSET",
    "type" : "int",
    "comment" : " @hide\n     * The audio output device code for a USB headphone with attached microphone ",
    "links" : [ ]
  }, {
    "name" : "DEVICE_OUT_BLUETOOTH_SCO",
    "type" : "int",
    "comment" : " @hide\n     * The audio output device code for generic Bluetooth SCO, for voice ",
    "links" : [ ]
  }, {
    "name" : "DEVICE_OUT_BLUETOOTH_SCO_HEADSET",
    "type" : "int",
    "comment" : " @hide\n     * The audio output device code for Bluetooth SCO Headset Profile (HSP) and\n     * Hands-Free Profile (HFP), for voice\n     ",
    "links" : [ ]
  }, {
    "name" : "DEVICE_OUT_BLUETOOTH_SCO_CARKIT",
    "type" : "int",
    "comment" : " @hide\n     * The audio output device code for Bluetooth SCO car audio, for voice ",
    "links" : [ ]
  }, {
    "name" : "DEVICE_OUT_BLUETOOTH_A2DP",
    "type" : "int",
    "comment" : " @hide\n     * The audio output device code for generic Bluetooth A2DP, for music ",
    "links" : [ ]
  }, {
    "name" : "DEVICE_OUT_BLUETOOTH_A2DP_HEADPHONES",
    "type" : "int",
    "comment" : " @hide\n     * The audio output device code for Bluetooth A2DP headphones, for music ",
    "links" : [ ]
  }, {
    "name" : "DEVICE_OUT_BLUETOOTH_A2DP_SPEAKER",
    "type" : "int",
    "comment" : " @hide\n     * The audio output device code for Bluetooth A2DP external speaker, for music ",
    "links" : [ ]
  }, {
    "name" : "DEVICE_OUT_AUX_DIGITAL",
    "type" : "int",
    "comment" : " @hide\n     * The audio output device code for S/PDIF (legacy) or HDMI\n     * Deprecated: replaced by {@link #DEVICE_OUT_HDMI} ",
    "links" : [ "#DEVICE_OUT_HDMI" ]
  }, {
    "name" : "DEVICE_OUT_HDMI",
    "type" : "int",
    "comment" : " @hide\n     * The audio output device code for HDMI ",
    "links" : [ ]
  }, {
    "name" : "DEVICE_OUT_ANLG_DOCK_HEADSET",
    "type" : "int",
    "comment" : " @hide\n     * The audio output device code for an analog wired headset attached via a\n     *  docking station\n     ",
    "links" : [ ]
  }, {
    "name" : "DEVICE_OUT_DGTL_DOCK_HEADSET",
    "type" : "int",
    "comment" : " @hide\n     * The audio output device code for a digital wired headset attached via a\n     *  docking station\n     ",
    "links" : [ ]
  }, {
    "name" : "DEVICE_OUT_USB_ACCESSORY",
    "type" : "int",
    "comment" : " @hide\n     * The audio output device code for a USB audio accessory. The accessory is in USB host\n     * mode and the Android device in USB device mode\n     ",
    "links" : [ ]
  }, {
    "name" : "DEVICE_OUT_USB_DEVICE",
    "type" : "int",
    "comment" : " @hide\n     * The audio output device code for a USB audio device. The device is in USB device\n     * mode and the Android device in USB host mode\n     ",
    "links" : [ ]
  }, {
    "name" : "DEVICE_OUT_REMOTE_SUBMIX",
    "type" : "int",
    "comment" : " @hide\n     * The audio output device code for projection output.\n     ",
    "links" : [ ]
  }, {
    "name" : "DEVICE_OUT_TELEPHONY_TX",
    "type" : "int",
    "comment" : " @hide\n     * The audio output device code the telephony voice TX path.\n     ",
    "links" : [ ]
  }, {
    "name" : "DEVICE_OUT_LINE",
    "type" : "int",
    "comment" : " @hide\n     * The audio output device code for an analog jack with line impedance detected.\n     ",
    "links" : [ ]
  }, {
    "name" : "DEVICE_OUT_HDMI_ARC",
    "type" : "int",
    "comment" : " @hide\n     * The audio output device code for HDMI Audio Return Channel.\n     ",
    "links" : [ ]
  }, {
    "name" : "DEVICE_OUT_SPDIF",
    "type" : "int",
    "comment" : " @hide\n     * The audio output device code for S/PDIF digital connection.\n     ",
    "links" : [ ]
  }, {
    "name" : "DEVICE_OUT_FM",
    "type" : "int",
    "comment" : " @hide\n     * The audio output device code for built-in FM transmitter.\n     ",
    "links" : [ ]
  }, {
    "name" : "DEVICE_OUT_DEFAULT",
    "type" : "int",
    "comment" : " @hide\n     * This is not used as a returned value from {@link #getDevicesForStream}, but could be\n     *  used in the future in a set method to select whatever default device is chosen by the\n     *  platform-specific implementation.\n     ",
    "links" : [ "#getDevicesForStream" ]
  }, {
    "name" : "DEVICE_IN_BUILTIN_MIC",
    "type" : "int",
    "comment" : " @hide\n     * The audio input device code for default built-in microphone\n     ",
    "links" : [ ]
  }, {
    "name" : "DEVICE_IN_BLUETOOTH_SCO_HEADSET",
    "type" : "int",
    "comment" : " @hide\n     * The audio input device code for a Bluetooth SCO headset\n     ",
    "links" : [ ]
  }, {
    "name" : "DEVICE_IN_WIRED_HEADSET",
    "type" : "int",
    "comment" : " @hide\n     * The audio input device code for wired headset microphone\n     ",
    "links" : [ ]
  }, {
    "name" : "DEVICE_IN_HDMI",
    "type" : "int",
    "comment" : " @hide\n     * The audio input device code for HDMI\n     ",
    "links" : [ ]
  }, {
    "name" : "DEVICE_IN_HDMI_ARC",
    "type" : "int",
    "comment" : " @hide\n     * The audio input device code for HDMI ARC\n     ",
    "links" : [ ]
  }, {
    "name" : "DEVICE_IN_TELEPHONY_RX",
    "type" : "int",
    "comment" : " @hide\n     * The audio input device code for telephony voice RX path\n     ",
    "links" : [ ]
  }, {
    "name" : "DEVICE_IN_BACK_MIC",
    "type" : "int",
    "comment" : " @hide\n     * The audio input device code for built-in microphone pointing to the back\n     ",
    "links" : [ ]
  }, {
    "name" : "DEVICE_IN_ANLG_DOCK_HEADSET",
    "type" : "int",
    "comment" : " @hide\n     * The audio input device code for analog from a docking station\n     ",
    "links" : [ ]
  }, {
    "name" : "DEVICE_IN_DGTL_DOCK_HEADSET",
    "type" : "int",
    "comment" : " @hide\n     * The audio input device code for digital from a docking station\n     ",
    "links" : [ ]
  }, {
    "name" : "DEVICE_IN_USB_ACCESSORY",
    "type" : "int",
    "comment" : " @hide\n     * The audio input device code for a USB audio accessory. The accessory is in USB host\n     * mode and the Android device in USB device mode\n     ",
    "links" : [ ]
  }, {
    "name" : "DEVICE_IN_USB_DEVICE",
    "type" : "int",
    "comment" : " @hide\n     * The audio input device code for a USB audio device. The device is in USB device\n     * mode and the Android device in USB host mode\n     ",
    "links" : [ ]
  }, {
    "name" : "DEVICE_IN_FM_TUNER",
    "type" : "int",
    "comment" : " @hide\n     * The audio input device code for a FM radio tuner\n     ",
    "links" : [ ]
  }, {
    "name" : "DEVICE_IN_TV_TUNER",
    "type" : "int",
    "comment" : " @hide\n     * The audio input device code for a TV tuner\n     ",
    "links" : [ ]
  }, {
    "name" : "DEVICE_IN_LINE",
    "type" : "int",
    "comment" : " @hide\n     * The audio input device code for an analog jack with line impedance detected\n     ",
    "links" : [ ]
  }, {
    "name" : "DEVICE_IN_SPDIF",
    "type" : "int",
    "comment" : " @hide\n     * The audio input device code for a S/PDIF digital connection\n     ",
    "links" : [ ]
  }, {
    "name" : "DEVICE_IN_LOOPBACK",
    "type" : "int",
    "comment" : " @hide\n     * The audio input device code for audio loopback\n     ",
    "links" : [ ]
  }, {
    "name" : "DEVICE_VOLUME_BEHAVIOR_UNSET",
    "type" : "int",
    "comment" : "\n     * @hide\n     * Volume behavior for an audio device that has no particular volume behavior set. Invalid as\n     * an argument to {@link #setDeviceVolumeBehavior(int, String, int)}.\n     ",
    "links" : [ "#setDeviceVolumeBehavior(int" ]
  }, {
    "name" : "DEVICE_VOLUME_BEHAVIOR_VARIABLE",
    "type" : "int",
    "comment" : "\n     * @hide\n     * Volume behavior for an audio device where a software attenuation is applied\n     * @see #setDeviceVolumeBehavior(int, String, int)\n     ",
    "links" : [ ]
  }, {
    "name" : "DEVICE_VOLUME_BEHAVIOR_FULL",
    "type" : "int",
    "comment" : "\n     * @hide\n     * Volume behavior for an audio device where the volume is always set to provide no attenuation\n     *     nor gain (e.g. unit gain).\n     * @see #setDeviceVolumeBehavior(int, String, int)\n     ",
    "links" : [ ]
  }, {
    "name" : "DEVICE_VOLUME_BEHAVIOR_FIXED",
    "type" : "int",
    "comment" : "\n     * @hide\n     * Volume behavior for an audio device where the volume is either set to muted, or to provide\n     *     no attenuation nor gain (e.g. unit gain).\n     * @see #setDeviceVolumeBehavior(int, String, int)\n     ",
    "links" : [ ]
  }, {
    "name" : "DEVICE_VOLUME_BEHAVIOR_ABSOLUTE",
    "type" : "int",
    "comment" : "\n     * @hide\n     * Volume behavior for an audio device where no software attenuation is applied, and\n     *     the volume is kept synchronized between the host and the device itself through a\n     *     device-specific protocol such as BT AVRCP.\n     * @see #setDeviceVolumeBehavior(int, String, int)\n     ",
    "links" : [ ]
  }, {
    "name" : "DEVICE_VOLUME_BEHAVIOR_ABSOLUTE_MULTI_MODE",
    "type" : "int",
    "comment" : "\n     * @hide\n     * Volume behavior for an audio device where no software attenuation is applied, and\n     *     the volume is kept synchronized between the host and the device itself through a\n     *     device-specific protocol (such as for hearing aids), based on the audio mode (e.g.\n     *     normal vs in phone call).\n     * @see #setMode(int)\n     * @see #setDeviceVolumeBehavior(int, String, int)\n     ",
    "links" : [ ]
  }, {
    "name" : "PROPERTY_OUTPUT_SAMPLE_RATE",
    "type" : "String",
    "comment" : " FIXME Deprecate",
    "links" : [ ]
  }, {
    "name" : "PROPERTY_OUTPUT_FRAMES_PER_BUFFER",
    "type" : "String",
    "comment" : " FIXME Deprecate",
    "links" : [ ]
  }, {
    "name" : "PROPERTY_SUPPORT_MIC_NEAR_ULTRASOUND",
    "type" : "String",
    "comment" : "\n     * Used as a key for {@link #getProperty} to determine if the default microphone audio source\n     * supports near-ultrasound frequencies (range of 18 - 21 kHz).\n     ",
    "links" : [ "#getProperty" ]
  }, {
    "name" : "PROPERTY_SUPPORT_SPEAKER_NEAR_ULTRASOUND",
    "type" : "String",
    "comment" : "\n     * Used as a key for {@link #getProperty} to determine if the default speaker audio path\n     * supports near-ultrasound frequencies (range of 18 - 21 kHz).\n     ",
    "links" : [ "#getProperty" ]
  }, {
    "name" : "PROPERTY_SUPPORT_AUDIO_SOURCE_UNPROCESSED",
    "type" : "String",
    "comment" : "\n     * Used as a key for {@link #getProperty} to determine if the unprocessed audio source is\n     * available and supported with the expected frequency range and level response.\n     ",
    "links" : [ "#getProperty" ]
  }, {
    "name" : "SUCCESS",
    "type" : "int",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "ERROR",
    "type" : "int",
    "comment" : "\n     * A default error code.\n     ",
    "links" : [ ]
  }, {
    "name" : "ERROR_BAD_VALUE",
    "type" : "int",
    "comment" : " @hide\n     * CANDIDATE FOR PUBLIC API\n     ",
    "links" : [ ]
  }, {
    "name" : "ERROR_INVALID_OPERATION",
    "type" : "int",
    "comment" : " @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "ERROR_PERMISSION_DENIED",
    "type" : "int",
    "comment" : " @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "ERROR_NO_INIT",
    "type" : "int",
    "comment" : " @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "ERROR_DEAD_OBJECT",
    "type" : "int",
    "comment" : "\n     * An error code indicating that the object reporting it is no longer valid and needs to\n     * be recreated.\n     ",
    "links" : [ ]
  }, {
    "name" : "AUDIOPORT_GENERATION_INIT",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "sAudioPortGeneration",
    "type" : "Integer",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "sAudioPortsCached",
    "type" : "ArrayList<AudioPort>",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "sPreviousAudioPortsCached",
    "type" : "ArrayList<AudioPort>",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "sAudioPatchesCached",
    "type" : "ArrayList<AudioPatch>",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mPortListener",
    "type" : "OnAmPortUpdateListener",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "MSG_DEVICES_CALLBACK_REGISTERED",
    "type" : "int",
    "comment" : "\n     * The message sent to apps when the contents of the device list changes if they provide\n     * a {@link Handler} object to addOnAudioDeviceConnectionListener().\n     ",
    "links" : [ "android.media.audiopolicy.AudioVolumeGroupChangeHandler" ]
  }, {
    "name" : "MSG_DEVICES_DEVICES_ADDED",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "MSG_DEVICES_DEVICES_REMOVED",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mDeviceCallbacks",
    "type" : "ArrayMap<AudioDeviceCallback, NativeEventHandlerDelegate>",
    "comment" : "\n     * The list of {@link AudioDeviceCallback} objects to receive add/remove notifications.\n     ",
    "links" : [ "android.media.AudioDeviceCallback" ]
  }, {
    "name" : "GET_DEVICES_INPUTS",
    "type" : "int",
    "comment" : "\n     * Specifies to the {@link AudioManager#getDevices(int)} method to include\n     * source (i.e. input) audio devices.\n     ",
    "links" : [ "android.media.AudioManager#getDevices(int)" ]
  }, {
    "name" : "GET_DEVICES_OUTPUTS",
    "type" : "int",
    "comment" : "\n     * Specifies to the {@link AudioManager#getDevices(int)} method to include\n     * sink (i.e. output) audio devices.\n     ",
    "links" : [ "android.media.AudioManager#getDevices(int)" ]
  }, {
    "name" : "GET_DEVICES_ALL",
    "type" : "int",
    "comment" : "\n     * Specifies to the {@link AudioManager#getDevices(int)} method to include both\n     * source and sink devices.\n     ",
    "links" : [ "android.media.AudioManager#getDevices(int)" ]
  }, {
    "name" : "mPreviousPorts",
    "type" : "ArrayList<AudioDevicePort>",
    "comment" : " of the ports that exist at the time of the last notification.",
    "links" : [ ]
  }, {
    "name" : "mAudioServerStateExec",
    "type" : "Executor",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mAudioServerStateCb",
    "type" : "AudioServerStateCallback",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mAudioServerStateCbLock",
    "type" : "Object",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mAudioServerStateDispatcher",
    "type" : "IAudioServerStateDispatcher",
    "comment" : "",
    "links" : [ ]
  } ],
  "methods" : [ {
    "name" : "public static final String adjustToString(int adj)",
    "returnType" : "String",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "public static String flagsToString(int flags)",
    "returnType" : "String",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "private Context getContext()",
    "returnType" : "Context",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private void setContext(Context context)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private static IAudioService getService()",
    "returnType" : "IAudioService",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public void dispatchMediaKeyEvent(KeyEvent keyEvent)",
    "returnType" : "void",
    "comment" : "\n     * Sends a simulated key event for a media button.\n     * To simulate a key press, you must first send a KeyEvent built with a\n     * {@link KeyEvent#ACTION_DOWN} action, then another event with the {@link KeyEvent#ACTION_UP}\n     * action.\n     * <p>The key event will be sent to the current media key event consumer which registered with\n     * {@link AudioManager#registerMediaButtonEventReceiver(PendingIntent)}.\n     * @param keyEvent a {@link KeyEvent} instance whose key code is one of\n     *     {@link KeyEvent#KEYCODE_MUTE},\n     *     {@link KeyEvent#KEYCODE_HEADSETHOOK},\n     *     {@link KeyEvent#KEYCODE_MEDIA_PLAY},\n     *     {@link KeyEvent#KEYCODE_MEDIA_PAUSE},\n     *     {@link KeyEvent#KEYCODE_MEDIA_PLAY_PAUSE},\n     *     {@link KeyEvent#KEYCODE_MEDIA_STOP},\n     *     {@link KeyEvent#KEYCODE_MEDIA_NEXT},\n     *     {@link KeyEvent#KEYCODE_MEDIA_PREVIOUS},\n     *     {@link KeyEvent#KEYCODE_MEDIA_REWIND},\n     *     {@link KeyEvent#KEYCODE_MEDIA_RECORD},\n     *     {@link KeyEvent#KEYCODE_MEDIA_FAST_FORWARD},\n     *     {@link KeyEvent#KEYCODE_MEDIA_CLOSE},\n     *     {@link KeyEvent#KEYCODE_MEDIA_EJECT},\n     *     or {@link KeyEvent#KEYCODE_MEDIA_AUDIO_TRACK}.\n     ",
    "links" : [ "android.view.KeyEvent", "android.view.KeyEvent#KEYCODE_MEDIA_RECORD", "android.view.KeyEvent#KEYCODE_MEDIA_REWIND", "android.view.KeyEvent#KEYCODE_MEDIA_EJECT", "android.view.KeyEvent#KEYCODE_MEDIA_NEXT", "android.view.KeyEvent#KEYCODE_MEDIA_AUDIO_TRACK", "android.view.KeyEvent#KEYCODE_MEDIA_PAUSE", "android.view.KeyEvent#KEYCODE_MUTE", "android.view.KeyEvent#ACTION_UP", "android.view.KeyEvent#KEYCODE_MEDIA_PLAY", "android.view.KeyEvent#ACTION_DOWN", "android.media.AudioManager#registerMediaButtonEventReceiver(PendingIntent)", "android.view.KeyEvent#KEYCODE_MEDIA_FAST_FORWARD", "android.view.KeyEvent#KEYCODE_MEDIA_STOP", "android.view.KeyEvent#KEYCODE_HEADSETHOOK", "android.view.KeyEvent#KEYCODE_MEDIA_PLAY_PAUSE", "android.view.KeyEvent#KEYCODE_MEDIA_PREVIOUS", "android.view.KeyEvent#KEYCODE_MEDIA_CLOSE" ]
  }, {
    "name" : "public void preDispatchKeyEvent(KeyEvent event, int stream)",
    "returnType" : "void",
    "comment" : "\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean isVolumeFixed()",
    "returnType" : "boolean",
    "comment" : "\n     * Indicates if the device implements a fixed volume policy.\n     * <p>Some devices may not have volume control and may operate at a fixed volume,\n     * and may not enable muting or changing the volume of audio streams.\n     * This method will return true on such devices.\n     * <p>The following APIs have no effect when volume is fixed:\n     * <ul>\n     *   <li> {@link #adjustVolume(int, int)}\n     *   <li> {@link #adjustSuggestedStreamVolume(int, int, int)}\n     *   <li> {@link #adjustStreamVolume(int, int, int)}\n     *   <li> {@link #setStreamVolume(int, int, int)}\n     *   <li> {@link #setRingerMode(int)}\n     *   <li> {@link #setStreamSolo(int, boolean)}\n     *   <li> {@link #setStreamMute(int, boolean)}\n     * </ul>\n     ",
    "links" : [ "#setStreamVolume(int", "#adjustStreamVolume(int", "#setRingerMode(int)", "#adjustSuggestedStreamVolume(int", "#setStreamMute(int", "#setStreamSolo(int", "#adjustVolume(int" ]
  }, {
    "name" : "public void adjustStreamVolume(int streamType, int direction, int flags)",
    "returnType" : "void",
    "comment" : "\n     * Adjusts the volume of a particular stream by one step in a direction.\n     * <p>\n     * This method should only be used by applications that replace the platform-wide\n     * management of audio settings or the main telephony application.\n     * <p>This method has no effect if the device implements a fixed volume policy\n     * as indicated by {@link #isVolumeFixed()}.\n     * <p>From N onward, ringer mode adjustments that would toggle Do Not Disturb are not allowed\n     * unless the app has been granted Do Not Disturb Access.\n     * See {@link NotificationManager#isNotificationPolicyAccessGranted()}.\n     *\n     * @param streamType The stream type to adjust. One of {@link #STREAM_VOICE_CALL},\n     * {@link #STREAM_SYSTEM}, {@link #STREAM_RING}, {@link #STREAM_MUSIC},\n     * {@link #STREAM_ALARM} or {@link #STREAM_ACCESSIBILITY}.\n     * @param direction The direction to adjust the volume. One of\n     *            {@link #ADJUST_LOWER}, {@link #ADJUST_RAISE}, or\n     *            {@link #ADJUST_SAME}.\n     * @param flags One or more flags.\n     * @see #adjustVolume(int, int)\n     * @see #setStreamVolume(int, int, int)\n     * @throws SecurityException if the adjustment triggers a Do Not Disturb change\n     *   and the caller is not granted notification policy access.\n     ",
    "links" : [ "#STREAM_ALARM", "#ADJUST_LOWER", "#isVolumeFixed()", "#STREAM_SYSTEM", "#ADJUST_SAME", "android.app.NotificationManager#isNotificationPolicyAccessGranted()", "#STREAM_VOICE_CALL", "#STREAM_MUSIC", "#STREAM_RING", "#ADJUST_RAISE", "#STREAM_ACCESSIBILITY" ]
  }, {
    "name" : "public void adjustVolume(int direction, int flags)",
    "returnType" : "void",
    "comment" : "\n     * Adjusts the volume of the most relevant stream. For example, if a call is\n     * active, it will have the highest priority regardless of if the in-call\n     * screen is showing. Another example, if music is playing in the background\n     * and a call is not active, the music stream will be adjusted.\n     * <p>\n     * This method should only be used by applications that replace the\n     * platform-wide management of audio settings or the main telephony\n     * application.\n     * <p>\n     * This method has no effect if the device implements a fixed volume policy\n     * as indicated by {@link #isVolumeFixed()}.\n     *\n     * @param direction The direction to adjust the volume. One of\n     *            {@link #ADJUST_LOWER}, {@link #ADJUST_RAISE},\n     *            {@link #ADJUST_SAME}, {@link #ADJUST_MUTE},\n     *            {@link #ADJUST_UNMUTE}, or {@link #ADJUST_TOGGLE_MUTE}.\n     * @param flags One or more flags.\n     * @see #adjustSuggestedStreamVolume(int, int, int)\n     * @see #adjustStreamVolume(int, int, int)\n     * @see #setStreamVolume(int, int, int)\n     * @see #isVolumeFixed()\n     ",
    "links" : [ "#ADJUST_LOWER", "#ADJUST_MUTE", "#ADJUST_TOGGLE_MUTE", "#isVolumeFixed()", "#ADJUST_SAME", "#ADJUST_RAISE", "#ADJUST_UNMUTE" ]
  }, {
    "name" : "public void adjustSuggestedStreamVolume(int direction, int suggestedStreamType, int flags)",
    "returnType" : "void",
    "comment" : "\n     * Adjusts the volume of the most relevant stream, or the given fallback\n     * stream.\n     * <p>\n     * This method should only be used by applications that replace the\n     * platform-wide management of audio settings or the main telephony\n     * application.\n     * <p>\n     * This method has no effect if the device implements a fixed volume policy\n     * as indicated by {@link #isVolumeFixed()}.\n     *\n     * @param direction The direction to adjust the volume. One of\n     *            {@link #ADJUST_LOWER}, {@link #ADJUST_RAISE},\n     *            {@link #ADJUST_SAME}, {@link #ADJUST_MUTE},\n     *            {@link #ADJUST_UNMUTE}, or {@link #ADJUST_TOGGLE_MUTE}.\n     * @param suggestedStreamType The stream type that will be used if there\n     *            isn't a relevant stream. {@link #USE_DEFAULT_STREAM_TYPE} is\n     *            valid here.\n     * @param flags One or more flags.\n     * @see #adjustVolume(int, int)\n     * @see #adjustStreamVolume(int, int, int)\n     * @see #setStreamVolume(int, int, int)\n     * @see #isVolumeFixed()\n     ",
    "links" : [ "#ADJUST_LOWER", "#ADJUST_MUTE", "#ADJUST_TOGGLE_MUTE", "#isVolumeFixed()", "#ADJUST_SAME", "#USE_DEFAULT_STREAM_TYPE", "#ADJUST_RAISE", "#ADJUST_UNMUTE" ]
  }, {
    "name" : "public void setMasterMute(boolean mute, int flags)",
    "returnType" : "void",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "public int getRingerMode()",
    "returnType" : "int",
    "comment" : "\n     * Returns the current ringtone mode.\n     *\n     * @return The current ringtone mode, one of {@link #RINGER_MODE_NORMAL},\n     *         {@link #RINGER_MODE_SILENT}, or {@link #RINGER_MODE_VIBRATE}.\n     * @see #setRingerMode(int)\n     ",
    "links" : [ "#RINGER_MODE_SILENT", "#RINGER_MODE_VIBRATE", "#RINGER_MODE_NORMAL" ]
  }, {
    "name" : "public static boolean isValidRingerMode(int ringerMode)",
    "returnType" : "boolean",
    "comment" : "\n     * Checks valid ringer mode values.\n     *\n     * @return true if the ringer mode indicated is valid, false otherwise.\n     *\n     * @see #setRingerMode(int)\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public int getStreamMaxVolume(int streamType)",
    "returnType" : "int",
    "comment" : "\n     * Returns the maximum volume index for a particular stream.\n     *\n     * @param streamType The stream type whose maximum volume index is returned.\n     * @return The maximum valid volume index for the stream.\n     * @see #getStreamVolume(int)\n     ",
    "links" : [ ]
  }, {
    "name" : "public int getStreamMinVolume(int streamType)",
    "returnType" : "int",
    "comment" : "\n     * Returns the minimum volume index for a particular stream.\n     * @param streamType The stream type whose minimum volume index is returned. Must be one of\n     *     {@link #STREAM_VOICE_CALL}, {@link #STREAM_SYSTEM},\n     *     {@link #STREAM_RING}, {@link #STREAM_MUSIC}, {@link #STREAM_ALARM},\n     *     {@link #STREAM_NOTIFICATION}, {@link #STREAM_DTMF} or {@link #STREAM_ACCESSIBILITY}.\n     * @return The minimum valid volume index for the stream.\n     * @see #getStreamVolume(int)\n     ",
    "links" : [ "#STREAM_ALARM", "#STREAM_SYSTEM", "#STREAM_VOICE_CALL", "#STREAM_MUSIC", "#STREAM_RING", "#STREAM_NOTIFICATION", "#STREAM_DTMF", "#STREAM_ACCESSIBILITY" ]
  }, {
    "name" : "public int getStreamMinVolumeInt(int streamType)",
    "returnType" : "int",
    "comment" : "\n     * @hide\n     * Same as {@link #getStreamMinVolume(int)} but without the check on the public stream type.\n     * @param streamType The stream type whose minimum volume index is returned.\n     * @return The minimum valid volume index for the stream.\n     * @see #getStreamVolume(int)\n     ",
    "links" : [ "#getStreamMinVolume(int)" ]
  }, {
    "name" : "public int getStreamVolume(int streamType)",
    "returnType" : "int",
    "comment" : "\n     * Returns the current volume index for a particular stream.\n     *\n     * @param streamType The stream type whose volume index is returned.\n     * @return The current volume index for the stream.\n     * @see #getStreamMaxVolume(int)\n     * @see #setStreamVolume(int, int, int)\n     ",
    "links" : [ ]
  }, {
    "name" : "public float getStreamVolumeDb(@PublicStreamTypes int streamType, int index, @AudioDeviceInfo.AudioDeviceTypeOut int deviceType)",
    "returnType" : "float",
    "comment" : "\n     * Returns the volume in dB (decibel) for the given stream type at the given volume index, on\n     * the given type of audio output device.\n     * @param streamType stream type for which the volume is queried.\n     * @param index the volume index for which the volume is queried. The index value must be\n     *     between the minimum and maximum index values for the given stream type (see\n     *     {@link #getStreamMinVolume(int)} and {@link #getStreamMaxVolume(int)}).\n     * @param deviceType the type of audio output device for which volume is queried.\n     * @return a volume expressed in dB.\n     *     A negative value indicates the audio signal is attenuated. A typical maximum value\n     *     at the maximum volume index is 0 dB (no attenuation nor amplification). Muting is\n     *     reflected by a value of {@link Float#NEGATIVE_INFINITY}.\n     ",
    "links" : [ "#getStreamMinVolume(int)", "#getStreamMaxVolume(int)", "#NEGATIVE_INFINITY" ]
  }, {
    "name" : "private static boolean isPublicStreamType(int streamType)",
    "returnType" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public int getLastAudibleStreamVolume(int streamType)",
    "returnType" : "int",
    "comment" : "\n     * Get last audible volume before stream was muted.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public int getUiSoundsStreamType()",
    "returnType" : "int",
    "comment" : "\n     * Get the stream type whose volume is driving the UI sounds volume.\n     * UI sounds are screen lock/unlock, camera shutter, key clicks...\n     * It is assumed that this stream type is also tied to ringer mode changes.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public void setRingerMode(int ringerMode)",
    "returnType" : "void",
    "comment" : "\n     * Sets the ringer mode.\n     * <p>\n     * Silent mode will mute the volume and will not vibrate. Vibrate mode will\n     * mute the volume and vibrate. Normal mode will be audible and may vibrate\n     * according to user settings.\n     * <p>This method has no effect if the device implements a fixed volume policy\n     * as indicated by {@link #isVolumeFixed()}.\n     * * <p>From N onward, ringer mode adjustments that would toggle Do Not Disturb are not allowed\n     * unless the app has been granted Do Not Disturb Access.\n     * See {@link NotificationManager#isNotificationPolicyAccessGranted()}.\n     * @param ringerMode The ringer mode, one of {@link #RINGER_MODE_NORMAL},\n     *            {@link #RINGER_MODE_SILENT}, or {@link #RINGER_MODE_VIBRATE}.\n     * @see #getRingerMode()\n     * @see #isVolumeFixed()\n     ",
    "links" : [ "#isVolumeFixed()", "#RINGER_MODE_SILENT", "android.app.NotificationManager#isNotificationPolicyAccessGranted()", "#RINGER_MODE_VIBRATE", "#RINGER_MODE_NORMAL" ]
  }, {
    "name" : "public void setStreamVolume(int streamType, int index, int flags)",
    "returnType" : "void",
    "comment" : "\n     * Sets the volume index for a particular stream.\n     * <p>This method has no effect if the device implements a fixed volume policy\n     * as indicated by {@link #isVolumeFixed()}.\n     * <p>From N onward, volume adjustments that would toggle Do Not Disturb are not allowed unless\n     * the app has been granted Do Not Disturb Access.\n     * See {@link NotificationManager#isNotificationPolicyAccessGranted()}.\n     * @param streamType The stream whose volume index should be set.\n     * @param index The volume index to set. See\n     *            {@link #getStreamMaxVolume(int)} for the largest valid value.\n     * @param flags One or more flags.\n     * @see #getStreamMaxVolume(int)\n     * @see #getStreamVolume(int)\n     * @see #isVolumeFixed()\n     * @throws SecurityException if the volume change triggers a Do Not Disturb change\n     *   and the caller is not granted notification policy access.\n     ",
    "links" : [ "#isVolumeFixed()", "#getStreamMaxVolume(int)", "android.app.NotificationManager#isNotificationPolicyAccessGranted()" ]
  }, {
    "name" : "public void setVolumeIndexForAttributes(@NonNull AudioAttributes attr, int index, int flags)",
    "returnType" : "void",
    "comment" : "\n     * Sets the volume index for a particular {@link AudioAttributes}.\n     * @param attr The {@link AudioAttributes} whose volume index should be set.\n     * @param index The volume index to set. See\n     *          {@link #getMaxVolumeIndexForAttributes(AudioAttributes)} for the largest valid value\n     *          {@link #getMinVolumeIndexForAttributes(AudioAttributes)} for the lowest valid value.\n     * @param flags One or more flags.\n     * @see #getMaxVolumeIndexForAttributes(AudioAttributes)\n     * @see #getMinVolumeIndexForAttributes(AudioAttributes)\n     * @see #isVolumeFixed()\n     * @hide\n     ",
    "links" : [ "#getMaxVolumeIndexForAttributes(AudioAttributes)", "android.media.AudioAttributes", "#getMinVolumeIndexForAttributes(AudioAttributes)" ]
  }, {
    "name" : "public int getVolumeIndexForAttributes(@NonNull AudioAttributes attr)",
    "returnType" : "int",
    "comment" : "\n     * Returns the current volume index for a particular {@link AudioAttributes}.\n     *\n     * @param attr The {@link AudioAttributes} whose volume index is returned.\n     * @return The current volume index for the stream.\n     * @see #getMaxVolumeIndexForAttributes(AudioAttributes)\n     * @see #getMinVolumeIndexForAttributes(AudioAttributes)\n     * @see #setVolumeForAttributes(AudioAttributes, int, int)\n     * @hide\n     ",
    "links" : [ "android.media.AudioAttributes" ]
  }, {
    "name" : "public int getMaxVolumeIndexForAttributes(@NonNull AudioAttributes attr)",
    "returnType" : "int",
    "comment" : "\n     * Returns the maximum volume index for a particular {@link AudioAttributes}.\n     *\n     * @param attr The {@link AudioAttributes} whose maximum volume index is returned.\n     * @return The maximum valid volume index for the {@link AudioAttributes}.\n     * @see #getVolumeIndexForAttributes(AudioAttributes)\n     * @hide\n     ",
    "links" : [ "android.media.AudioAttributes" ]
  }, {
    "name" : "public int getMinVolumeIndexForAttributes(@NonNull AudioAttributes attr)",
    "returnType" : "int",
    "comment" : "\n     * Returns the minimum volume index for a particular {@link AudioAttributes}.\n     *\n     * @param attr The {@link AudioAttributes} whose minimum volume index is returned.\n     * @return The minimum valid volume index for the {@link AudioAttributes}.\n     * @see #getVolumeIndexForAttributes(AudioAttributes)\n     * @hide\n     ",
    "links" : [ "android.media.AudioAttributes" ]
  }, {
    "name" : "public void setSupportedSystemUsages(@NonNull @AttributeSystemUsage int[] systemUsages)",
    "returnType" : "void",
    "comment" : "\n     * Set the system usages to be supported on this device.\n     * @param systemUsages array of system usages to support {@link AttributeSystemUsage}\n     * @hide\n     ",
    "links" : [ "android.media.AudioAttributes.AttributeSystemUsage" ]
  }, {
    "name" : "public int[] getSupportedSystemUsages()",
    "returnType" : "int[]",
    "comment" : "\n     * Get the system usages supported on this device.\n     * @return array of supported system usages {@link AttributeSystemUsage}\n     * @hide\n     ",
    "links" : [ "android.media.AudioAttributes.AttributeSystemUsage" ]
  }, {
    "name" : "public void setStreamSolo(int streamType, boolean state)",
    "returnType" : "void",
    "comment" : "\n     * Solo or unsolo a particular stream.\n     * <p>\n     * Do not use. This method has been deprecated and is now a no-op.\n     * {@link #requestAudioFocus} should be used for exclusive audio playback.\n     *\n     * @param streamType The stream to be soloed/unsoloed.\n     * @param state The required solo state: true for solo ON, false for solo\n     *            OFF\n     * @see #isVolumeFixed()\n     * @deprecated Do not use. If you need exclusive audio playback use\n     *             {@link #requestAudioFocus}.\n     ",
    "links" : [ "#requestAudioFocus" ]
  }, {
    "name" : "public void setStreamMute(int streamType, boolean state)",
    "returnType" : "void",
    "comment" : "\n     * Mute or unmute an audio stream.\n     * <p>\n     * This method should only be used by applications that replace the\n     * platform-wide management of audio settings or the main telephony\n     * application.\n     * <p>\n     * This method has no effect if the device implements a fixed volume policy\n     * as indicated by {@link #isVolumeFixed()}.\n     * <p>\n     * This method was deprecated in API level 22. Prior to API level 22 this\n     * method had significantly different behavior and should be used carefully.\n     * The following applies only to pre-22 platforms:\n     * <ul>\n     * <li>The mute command is protected against client process death: if a\n     * process with an active mute request on a stream dies, this stream will be\n     * unmuted automatically.</li>\n     * <li>The mute requests for a given stream are cumulative: the AudioManager\n     * can receive several mute requests from one or more clients and the stream\n     * will be unmuted only when the same number of unmute requests are\n     * received.</li>\n     * <li>For a better user experience, applications MUST unmute a muted stream\n     * in onPause() and mute is again in onResume() if appropriate.</li>\n     * </ul>\n     *\n     * @param streamType The stream to be muted/unmuted.\n     * @param state The required mute state: true for mute ON, false for mute\n     *            OFF\n     * @see #isVolumeFixed()\n     * @deprecated Use {@link #adjustStreamVolume(int, int, int)} with\n     *             {@link #ADJUST_MUTE} or {@link #ADJUST_UNMUTE} instead.\n     ",
    "links" : [ "#ADJUST_MUTE", "#isVolumeFixed()", "#adjustStreamVolume(int", "#ADJUST_UNMUTE" ]
  }, {
    "name" : "public boolean isStreamMute(int streamType)",
    "returnType" : "boolean",
    "comment" : "\n     * Returns the current mute state for a particular stream.\n     *\n     * @param streamType The stream to get mute state for.\n     * @return The mute state for the given stream.\n     * @see #adjustStreamVolume(int, int, int)\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean isMasterMute()",
    "returnType" : "boolean",
    "comment" : "\n     * get master mute state.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public void forceVolumeControlStream(int streamType)",
    "returnType" : "void",
    "comment" : "\n     * forces the stream controlled by hard volume keys\n     * specifying streamType == -1 releases control to the\n     * logic.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean shouldVibrate(int vibrateType)",
    "returnType" : "boolean",
    "comment" : "\n     * Returns whether a particular type should vibrate according to user\n     * settings and the current ringer mode.\n     * <p>\n     * This shouldn't be needed by most clients that use notifications to\n     * vibrate. The notification manager will not vibrate if the policy doesn't\n     * allow it, so the client should always set a vibrate pattern and let the\n     * notification manager control whether or not to actually vibrate.\n     *\n     * @param vibrateType The type of vibrate. One of\n     *            {@link #VIBRATE_TYPE_NOTIFICATION} or\n     *            {@link #VIBRATE_TYPE_RINGER}.\n     * @return Whether the type should vibrate at the instant this method is\n     *         called.\n     * @see #setVibrateSetting(int, int)\n     * @see #getVibrateSetting(int)\n     * @deprecated Applications should maintain their own vibrate policy based on\n     * current ringer mode that can be queried via {@link #getRingerMode()}.\n     ",
    "links" : [ "#getRingerMode()", "#VIBRATE_TYPE_NOTIFICATION", "#VIBRATE_TYPE_RINGER" ]
  }, {
    "name" : "public int getVibrateSetting(int vibrateType)",
    "returnType" : "int",
    "comment" : "\n     * Returns whether the user's vibrate setting for a vibrate type.\n     * <p>\n     * This shouldn't be needed by most clients that want to vibrate, instead\n     * see {@link #shouldVibrate(int)}.\n     *\n     * @param vibrateType The type of vibrate. One of\n     *            {@link #VIBRATE_TYPE_NOTIFICATION} or\n     *            {@link #VIBRATE_TYPE_RINGER}.\n     * @return The vibrate setting, one of {@link #VIBRATE_SETTING_ON},\n     *         {@link #VIBRATE_SETTING_OFF}, or\n     *         {@link #VIBRATE_SETTING_ONLY_SILENT}.\n     * @see #setVibrateSetting(int, int)\n     * @see #shouldVibrate(int)\n     * @deprecated Applications should maintain their own vibrate policy based on\n     * current ringer mode that can be queried via {@link #getRingerMode()}.\n     ",
    "links" : [ "#VIBRATE_SETTING_ONLY_SILENT", "#getRingerMode()", "#shouldVibrate(int)", "#VIBRATE_TYPE_NOTIFICATION", "#VIBRATE_SETTING_ON", "#VIBRATE_TYPE_RINGER", "#VIBRATE_SETTING_OFF" ]
  }, {
    "name" : "public void setVibrateSetting(int vibrateType, int vibrateSetting)",
    "returnType" : "void",
    "comment" : "\n     * Sets the setting for when the vibrate type should vibrate.\n     * <p>\n     * This method should only be used by applications that replace the platform-wide\n     * management of audio settings or the main telephony application.\n     *\n     * @param vibrateType The type of vibrate. One of\n     *            {@link #VIBRATE_TYPE_NOTIFICATION} or\n     *            {@link #VIBRATE_TYPE_RINGER}.\n     * @param vibrateSetting The vibrate setting, one of\n     *            {@link #VIBRATE_SETTING_ON},\n     *            {@link #VIBRATE_SETTING_OFF}, or\n     *            {@link #VIBRATE_SETTING_ONLY_SILENT}.\n     * @see #getVibrateSetting(int)\n     * @see #shouldVibrate(int)\n     * @deprecated Applications should maintain their own vibrate policy based on\n     * current ringer mode that can be queried via {@link #getRingerMode()}.\n     ",
    "links" : [ "#VIBRATE_SETTING_ONLY_SILENT", "#getRingerMode()", "#VIBRATE_TYPE_NOTIFICATION", "#VIBRATE_SETTING_ON", "#VIBRATE_TYPE_RINGER", "#VIBRATE_SETTING_OFF" ]
  }, {
    "name" : "public void setSpeakerphoneOn(boolean on)",
    "returnType" : "void",
    "comment" : "\n     * Sets the speakerphone on or off.\n     * <p>\n     * This method should only be used by applications that replace the platform-wide\n     * management of audio settings or the main telephony application.\n     *\n     * @param on set <var>true</var> to turn on speakerphone;\n     *           <var>false</var> to turn it off\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean isSpeakerphoneOn()",
    "returnType" : "boolean",
    "comment" : "\n     * Checks whether the speakerphone is on or off.\n     *\n     * @return true if speakerphone is on, false if it's off\n     ",
    "links" : [ ]
  }, {
    "name" : "public void setAllowedCapturePolicy(@AudioAttributes.CapturePolicy int capturePolicy)",
    "returnType" : "void",
    "comment" : "\n     * Specifies whether the audio played by this app may or may not be captured by other apps or\n     * the system.\n     *\n     * The default is {@link AudioAttributes#ALLOW_CAPTURE_BY_ALL}.\n     *\n     * There are multiple ways to set this policy:\n     * <ul>\n     * <li> for each track independently, see\n     *    {@link AudioAttributes.Builder#setAllowedCapturePolicy(int)} </li>\n     * <li> application-wide at runtime, with this method </li>\n     * <li> application-wide at build time, see {@code allowAudioPlaybackCapture} in the application\n     *       manifest. </li>\n     * </ul>\n     * The most restrictive policy is always applied.\n     *\n     * See {@link AudioPlaybackCaptureConfiguration} for more details on\n     * which audio signals can be captured.\n     *\n     * @param capturePolicy one of\n     *     {@link AudioAttributes#ALLOW_CAPTURE_BY_ALL},\n     *     {@link AudioAttributes#ALLOW_CAPTURE_BY_SYSTEM},\n     *     {@link AudioAttributes#ALLOW_CAPTURE_BY_NONE}.\n     * @throws RuntimeException if the argument is not a valid value.\n     ",
    "links" : [ "android.media.AudioAttributes#ALLOW_CAPTURE_BY_ALL", "android.media.AudioAttributes#ALLOW_CAPTURE_BY_SYSTEM", "android.media.AudioPlaybackCaptureConfiguration", "android.media.AudioAttributes#ALLOW_CAPTURE_BY_NONE", "AudioAttributes.Builder#setAllowedCapturePolicy(int)" ]
  }, {
    "name" : "public int getAllowedCapturePolicy()",
    "returnType" : "int",
    "comment" : "\n     * Return the capture policy.\n     * @return the capture policy set by {@link #setAllowedCapturePolicy(int)} or\n     *         the default if it was not called.\n     ",
    "links" : [ "#setAllowedCapturePolicy(int)" ]
  }, {
    "name" : "public boolean setPreferredDeviceForStrategy(@NonNull AudioProductStrategy strategy, @NonNull AudioDeviceAttributes device)",
    "returnType" : "boolean",
    "comment" : "\n     * @hide\n     * Set the preferred device for a given strategy, i.e. the audio routing to be used by\n     * this audio strategy. Note that the device may not be available at the time the preferred\n     * device is set, but it will be used once made available.\n     * <p>Use {@link #removePreferredDeviceForStrategy(AudioProductStrategy)} to cancel setting\n     * this preference for this strategy.</p>\n     * @param strategy the audio strategy whose routing will be affected\n     * @param device the audio device to route to when available\n     * @return true if the operation was successful, false otherwise\n     ",
    "links" : [ "#removePreferredDeviceForStrategy(AudioProductStrategy)" ]
  }, {
    "name" : "public boolean removePreferredDeviceForStrategy(@NonNull AudioProductStrategy strategy)",
    "returnType" : "boolean",
    "comment" : "\n     * @hide\n     * Removes the preferred audio device previously set with\n     * {@link #setPreferredDeviceForStrategy(AudioProductStrategy, AudioDeviceAttributes)}.\n     * @param strategy the audio strategy whose routing will be affected\n     * @return true if the operation was successful, false otherwise (invalid strategy, or no\n     *     device set for example)\n     ",
    "links" : [ "#setPreferredDeviceForStrategy(AudioProductStrategy" ]
  }, {
    "name" : "public AudioDeviceAttributes getPreferredDeviceForStrategy(@NonNull AudioProductStrategy strategy)",
    "returnType" : "AudioDeviceAttributes",
    "comment" : "\n     * @hide\n     * Return the preferred device for an audio strategy, previously set with\n     * {@link #setPreferredDeviceForStrategy(AudioProductStrategy, AudioDeviceAttributes)}\n     * @param strategy the strategy to query\n     * @return the preferred device for that strategy, or null if none was ever set or if the\n     *    strategy is invalid\n     ",
    "links" : [ "#setPreferredDeviceForStrategy(AudioProductStrategy" ]
  }, {
    "name" : "public void addOnPreferredDeviceForStrategyChangedListener(@NonNull @CallbackExecutor Executor executor, @NonNull OnPreferredDeviceForStrategyChangedListener listener) throws SecurityException",
    "returnType" : "void",
    "comment" : "\n     * @hide\n     * Adds a listener for being notified of changes to the strategy-preferred audio device.\n     * @param executor\n     * @param listener\n     * @throws SecurityException if the caller doesn't hold the required permission\n     ",
    "links" : [ ]
  }, {
    "name" : "public void removeOnPreferredDeviceForStrategyChangedListener(@NonNull OnPreferredDeviceForStrategyChangedListener listener)",
    "returnType" : "void",
    "comment" : "\n     * @hide\n     * Removes a previously added listener of changes to the strategy-preferred audio device.\n     * @param listener\n     ",
    "links" : [ ]
  }, {
    "name" : "private PrefDevListenerInfo getPrefDevListenerInfo(OnPreferredDeviceForStrategyChangedListener listener)",
    "returnType" : "PrefDevListenerInfo",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private boolean hasPrefDevListener(OnPreferredDeviceForStrategyChangedListener listener)",
    "returnType" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private boolean removePrefDevListener(OnPreferredDeviceForStrategyChangedListener listener)",
    "returnType" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public static boolean isOffloadedPlaybackSupported(@NonNull AudioFormat format, @NonNull AudioAttributes attributes)",
    "returnType" : "boolean",
    "comment" : "\n     * Returns whether offloaded playback of an audio format is supported on the device.\n     * <p>Offloaded playback is the feature where the decoding and playback of an audio stream\n     * is not competing with other software resources. In general, it is supported by dedicated\n     * hardware, such as audio DSPs.\n     * <p>Note that this query only provides information about the support of an audio format,\n     * it does not indicate whether the resources necessary for the offloaded playback are\n     * available at that instant.\n     * @param format the audio format (codec, sample rate, channels) being checked.\n     * @param attributes the {@link AudioAttributes} to be used for playback\n     * @return true if the given audio format can be offloaded.\n     ",
    "links" : [ "android.media.AudioAttributes" ]
  }, {
    "name" : "public boolean isBluetoothScoAvailableOffCall()",
    "returnType" : "boolean",
    "comment" : "\n     * Indicates if current platform supports use of SCO for off call use cases.\n     * Application wanted to use bluetooth SCO audio when the phone is not in call\n     * must first call this method to make sure that the platform supports this\n     * feature.\n     * @return true if bluetooth SCO can be used for audio when not in call\n     *         false otherwise\n     * @see #startBluetoothSco()\n    ",
    "links" : [ ]
  }, {
    "name" : "public void startBluetoothSco()",
    "returnType" : "void",
    "comment" : "\n     * Start bluetooth SCO audio connection.\n     * <p>Requires Permission:\n     *   {@link android.Manifest.permission#MODIFY_AUDIO_SETTINGS}.\n     * <p>This method can be used by applications wanting to send and received audio\n     * to/from a bluetooth SCO headset while the phone is not in call.\n     * <p>As the SCO connection establishment can take several seconds,\n     * applications should not rely on the connection to be available when the method\n     * returns but instead register to receive the intent {@link #ACTION_SCO_AUDIO_STATE_UPDATED}\n     * and wait for the state to be {@link #SCO_AUDIO_STATE_CONNECTED}.\n     * <p>As the ACTION_SCO_AUDIO_STATE_UPDATED intent is sticky, the application can check the SCO\n     * audio state before calling startBluetoothSco() by reading the intent returned by the receiver\n     * registration. If the state is already CONNECTED, no state change will be received via the\n     * intent after calling startBluetoothSco(). It is however useful to call startBluetoothSco()\n     * so that the connection stays active in case the current initiator stops the connection.\n     * <p>Unless the connection is already active as described above, the state will always\n     * transition from DISCONNECTED to CONNECTING and then either to CONNECTED if the connection\n     * succeeds or back to DISCONNECTED if the connection fails (e.g no headset is connected).\n     * <p>When finished with the SCO connection or if the establishment fails, the application must\n     * call {@link #stopBluetoothSco()} to clear the request and turn down the bluetooth connection.\n     * <p>Even if a SCO connection is established, the following restrictions apply on audio\n     * output streams so that they can be routed to SCO headset:\n     * <ul>\n     *   <li> the stream type must be {@link #STREAM_VOICE_CALL} </li>\n     *   <li> the format must be mono </li>\n     *   <li> the sampling must be 16kHz or 8kHz </li>\n     * </ul>\n     * <p>The following restrictions apply on input streams:\n     * <ul>\n     *   <li> the format must be mono </li>\n     *   <li> the sampling must be 8kHz </li>\n     * </ul>\n     * <p>Note that the phone application always has the priority on the usage of the SCO\n     * connection for telephony. If this method is called while the phone is in call\n     * it will be ignored. Similarly, if a call is received or sent while an application\n     * is using the SCO connection, the connection will be lost for the application and NOT\n     * returned automatically when the call ends.\n     * <p>NOTE: up to and including API version\n     * {@link android.os.Build.VERSION_CODES#JELLY_BEAN_MR1}, this method initiates a virtual\n     * voice call to the bluetooth headset.\n     * After API version {@link android.os.Build.VERSION_CODES#JELLY_BEAN_MR2} only a raw SCO audio\n     * connection is established.\n     * @see #stopBluetoothSco()\n     * @see #ACTION_SCO_AUDIO_STATE_UPDATED\n     ",
    "links" : [ "android.os.Build.VERSION_CODES#JELLY_BEAN_MR1", "#ACTION_SCO_AUDIO_STATE_UPDATED", "android.os.Build.VERSION_CODES#JELLY_BEAN_MR2", "android.Manifest.permission#MODIFY_AUDIO_SETTINGS", "#STREAM_VOICE_CALL", "#stopBluetoothSco()", "#SCO_AUDIO_STATE_CONNECTED" ]
  }, {
    "name" : "public void startBluetoothScoVirtualCall()",
    "returnType" : "void",
    "comment" : "\n     * @hide\n     * Start bluetooth SCO audio connection in virtual call mode.\n     * <p>Requires Permission:\n     *   {@link android.Manifest.permission#MODIFY_AUDIO_SETTINGS}.\n     * <p>Similar to {@link #startBluetoothSco()} with explicit selection of virtual call mode.\n     * Telephony and communication applications (VoIP, Video Chat) should preferably select\n     * virtual call mode.\n     * Applications using voice input for search or commands should first try raw audio connection\n     * with {@link #startBluetoothSco()} and fall back to startBluetoothScoVirtualCall() in case of\n     * failure.\n     * @see #startBluetoothSco()\n     * @see #stopBluetoothSco()\n     * @see #ACTION_SCO_AUDIO_STATE_UPDATED\n     ",
    "links" : [ "#startBluetoothSco()", "android.Manifest.permission#MODIFY_AUDIO_SETTINGS" ]
  }, {
    "name" : "public void stopBluetoothSco()",
    "returnType" : "void",
    "comment" : " Also used for connections started with {@link #startBluetoothScoVirtualCall()}",
    "links" : [ "#startBluetoothScoVirtualCall()" ]
  }, {
    "name" : "public void setBluetoothScoOn(boolean on)",
    "returnType" : "void",
    "comment" : "\n     * Request use of Bluetooth SCO headset for communications.\n     * <p>\n     * This method should only be used by applications that replace the platform-wide\n     * management of audio settings or the main telephony application.\n     *\n     * @param on set <var>true</var> to use bluetooth SCO for communications;\n     *               <var>false</var> to not use bluetooth SCO for communications\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean isBluetoothScoOn()",
    "returnType" : "boolean",
    "comment" : "\n     * Checks whether communications use Bluetooth SCO.\n     *\n     * @return true if SCO is used for communications;\n     *         false if otherwise\n     ",
    "links" : [ ]
  }, {
    "name" : "public void setBluetoothA2dpOn(boolean on)",
    "returnType" : "void",
    "comment" : "\n     * @param on set <var>true</var> to route A2DP audio to/from Bluetooth\n     *           headset; <var>false</var> disable A2DP audio\n     * @deprecated Do not use.\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean isBluetoothA2dpOn()",
    "returnType" : "boolean",
    "comment" : "\n     * Checks whether a Bluetooth A2DP audio peripheral is connected or not.\n     *\n     * @return true if a Bluetooth A2DP peripheral is connected\n     *         false if otherwise\n     * @deprecated Use {@link AudioManager#getDevices(int)} instead to list available audio devices.\n     ",
    "links" : [ "android.media.AudioManager#getDevices(int)" ]
  }, {
    "name" : "public void setWiredHeadsetOn(boolean on)",
    "returnType" : "void",
    "comment" : "\n     * Sets audio routing to the wired headset on or off.\n     *\n     * @param on set <var>true</var> to route audio to/from wired\n     *           headset; <var>false</var> disable wired headset audio\n     * @deprecated Do not use.\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean isWiredHeadsetOn()",
    "returnType" : "boolean",
    "comment" : "\n     * Checks whether a wired headset is connected or not.\n     * <p>This is not a valid indication that audio playback is\n     * actually over the wired headset as audio routing depends on other conditions.\n     *\n     * @return true if a wired headset is connected.\n     *         false if otherwise\n     * @deprecated Use {@link AudioManager#getDevices(int)} instead to list available audio devices.\n     ",
    "links" : [ "android.media.AudioManager#getDevices(int)" ]
  }, {
    "name" : "public void setMicrophoneMute(boolean on)",
    "returnType" : "void",
    "comment" : "\n     * Sets the microphone mute on or off.\n     * <p>\n     * This method should only be used by applications that replace the platform-wide\n     * management of audio settings or the main telephony application.\n     *\n     * @param on set <var>true</var> to mute the microphone;\n     *           <var>false</var> to turn mute off\n     ",
    "links" : [ ]
  }, {
    "name" : "public void setMicrophoneMuteFromSwitch(boolean on)",
    "returnType" : "void",
    "comment" : "\n     * @hide\n     * Sets the microphone from switch mute on or off.\n     * <p>\n     * This method should only be used by InputManager to notify\n     * Audio Subsystem about Microphone Mute switch state.\n     *\n     * @param on set <var>true</var> to mute the microphone;\n     *           <var>false</var> to turn mute off\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean isMicrophoneMute()",
    "returnType" : "boolean",
    "comment" : "\n     * Checks whether the microphone mute is on or off.\n     *\n     * @return true if microphone is muted, false if it's not\n     ",
    "links" : [ ]
  }, {
    "name" : "public void setMode(@AudioMode int mode)",
    "returnType" : "void",
    "comment" : "\n     * Sets the audio mode.\n     * <p>\n     * The audio mode encompasses audio routing AND the behavior of\n     * the telephony layer. Therefore this method should only be used by applications that\n     * replace the platform-wide management of audio settings or the main telephony application.\n     * In particular, the {@link #MODE_IN_CALL} mode should only be used by the telephony\n     * application when it places a phone call, as it will cause signals from the radio layer\n     * to feed the platform mixer.\n     *\n     * @param mode  the requested audio mode.\n     *              Informs the HAL about the current audio state so that\n     *              it can route the audio appropriately.\n     ",
    "links" : [ "#MODE_IN_CALL" ]
  }, {
    "name" : "public int getMode()",
    "returnType" : "int",
    "comment" : "\n     * Returns the current audio mode.\n     *\n     * @return      the current audio mode.\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean isCallScreeningModeSupported()",
    "returnType" : "boolean",
    "comment" : "\n    * Indicates if the platform supports a special call screening and call monitoring mode.\n    * <p>\n    * When this mode is supported, it is possible to perform call screening and monitoring\n    * functions while other use cases like music or movie playback are active.\n    * <p>\n    * Use {@link #setMode(int)} with mode {@link #MODE_CALL_SCREENING} to place the platform in\n    * call screening mode.\n    * <p>\n    * If call screening mode is not supported, setting mode to\n    * MODE_CALL_SCREENING will be ignored and will not change current mode reported by\n    *  {@link #getMode()}.\n    * @return true if call screening mode is supported, false otherwise.\n    ",
    "links" : [ "#getMode()", "#setMode(int)", "#MODE_CALL_SCREENING" ]
  }, {
    "name" : "public void setRouting(int mode, int routes, int mask)",
    "returnType" : "void",
    "comment" : "\n     * Sets the audio routing for a specified mode\n     *\n     * @param mode   audio mode to change route. E.g., MODE_RINGTONE.\n     * @param routes bit vector of routes requested, created from one or\n     *               more of ROUTE_xxx types. Set bits indicate that route should be on\n     * @param mask   bit vector of routes to change, created from one or more of\n     * ROUTE_xxx types. Unset bits indicate the route should be left unchanged\n     *\n     * @deprecated   Do not set audio routing directly, use setSpeakerphoneOn(),\n     * setBluetoothScoOn() methods instead.\n     ",
    "links" : [ ]
  }, {
    "name" : "public int getRouting(int mode)",
    "returnType" : "int",
    "comment" : "\n     * Returns the current audio routing bit vector for a specified mode.\n     *\n     * @param mode audio mode to get route (e.g., MODE_RINGTONE)\n     * @return an audio route bit vector that can be compared with ROUTE_xxx\n     * bits\n     * @deprecated   Do not query audio routing directly, use isSpeakerphoneOn(),\n     * isBluetoothScoOn(), isBluetoothA2dpOn() and isWiredHeadsetOn() methods instead.\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean isMusicActive()",
    "returnType" : "boolean",
    "comment" : "\n     * Checks whether any music is active.\n     *\n     * @return true if any music tracks are active.\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean isMusicActiveRemotely()",
    "returnType" : "boolean",
    "comment" : "\n     * @hide\n     * Checks whether any music or media is actively playing on a remote device (e.g. wireless\n     *   display). Note that BT audio sinks are not considered remote devices.\n     * @return true if {@link AudioManager#STREAM_MUSIC} is active on a remote device\n     ",
    "links" : [ "android.media.AudioManager#STREAM_MUSIC" ]
  }, {
    "name" : "public boolean isAudioFocusExclusive()",
    "returnType" : "boolean",
    "comment" : "\n     * @hide\n     * Checks whether the current audio focus is exclusive.\n     * @return true if the top of the audio focus stack requested focus\n     *     with {@link #AUDIOFOCUS_GAIN_TRANSIENT_EXCLUSIVE}\n     ",
    "links" : [ "#AUDIOFOCUS_GAIN_TRANSIENT_EXCLUSIVE" ]
  }, {
    "name" : "public int generateAudioSessionId()",
    "returnType" : "int",
    "comment" : "\n     * Return a new audio session identifier not associated with any player or effect.\n     * An audio session identifier is a system wide unique identifier for a set of audio streams\n     * (one or more mixed together).\n     * <p>The primary use of the audio session ID is to associate audio effects to audio players,\n     * such as {@link MediaPlayer} or {@link AudioTrack}: all audio effects sharing the same audio\n     * session ID will be applied to the mixed audio content of the players that share the same\n     * audio session.\n     * <p>This method can for instance be used when creating one of the\n     * {@link android.media.audiofx.AudioEffect} objects to define the audio session of the effect,\n     * or to specify a session for a speech synthesis utterance\n     * in {@link android.speech.tts.TextToSpeech.Engine}.\n     * @return a new unclaimed and unused audio session identifier, or {@link #ERROR} when the\n     *   system failed to generate a new session, a condition in which audio playback or recording\n     *   will subsequently fail as well.\n     ",
    "links" : [ "android.media.audiofx.AudioEffect", "#ERROR", "android.media.MediaPlayer", "android.speech.tts.TextToSpeech.Engine", "android.media.AudioTrack" ]
  }, {
    "name" : "public void setParameter(String key, String value)",
    "returnType" : "void",
    "comment" : "\n     * @hide\n     * @deprecated Use {@link #setParameters(String)} instead\n     ",
    "links" : [ "#setParameters(String)" ]
  }, {
    "name" : "public void setParameters(String keyValuePairs)",
    "returnType" : "void",
    "comment" : "\n     * Sets a variable number of parameter values to audio hardware.\n     *\n     * @param keyValuePairs list of parameters key value pairs in the form:\n     *    key1=value1;key2=value2;...\n     *\n     ",
    "links" : [ ]
  }, {
    "name" : "public String getParameters(String keys)",
    "returnType" : "String",
    "comment" : "\n     * Gets a variable number of parameter values from audio hardware.\n     *\n     * @param keys list of parameters\n     * @return list of parameters key value pairs in the form:\n     *    key1=value1;key2=value2;...\n     ",
    "links" : [ ]
  }, {
    "name" : "public void playSoundEffect(int effectType)",
    "returnType" : "void",
    "comment" : "\n     * Plays a sound effect (Key clicks, lid open/close...)\n     * @param effectType The type of sound effect. One of\n     *            {@link #FX_KEY_CLICK},\n     *            {@link #FX_FOCUS_NAVIGATION_UP},\n     *            {@link #FX_FOCUS_NAVIGATION_DOWN},\n     *            {@link #FX_FOCUS_NAVIGATION_LEFT},\n     *            {@link #FX_FOCUS_NAVIGATION_RIGHT},\n     *            {@link #FX_KEYPRESS_STANDARD},\n     *            {@link #FX_KEYPRESS_SPACEBAR},\n     *            {@link #FX_KEYPRESS_DELETE},\n     *            {@link #FX_KEYPRESS_RETURN},\n     *            {@link #FX_KEYPRESS_INVALID},\n     * NOTE: This version uses the UI settings to determine\n     * whether sounds are heard or not.\n     ",
    "links" : [ "#FX_FOCUS_NAVIGATION_RIGHT", "#FX_KEYPRESS_SPACEBAR", "#FX_KEYPRESS_DELETE", "#FX_KEYPRESS_RETURN", "#FX_FOCUS_NAVIGATION_DOWN", "#FX_FOCUS_NAVIGATION_LEFT", "#FX_KEYPRESS_STANDARD", "#FX_KEY_CLICK", "#FX_FOCUS_NAVIGATION_UP", "#FX_KEYPRESS_INVALID" ]
  }, {
    "name" : "public void playSoundEffect(int effectType, int userId)",
    "returnType" : "void",
    "comment" : "\n     * Plays a sound effect (Key clicks, lid open/close...)\n     * @param effectType The type of sound effect. One of\n     *            {@link #FX_KEY_CLICK},\n     *            {@link #FX_FOCUS_NAVIGATION_UP},\n     *            {@link #FX_FOCUS_NAVIGATION_DOWN},\n     *            {@link #FX_FOCUS_NAVIGATION_LEFT},\n     *            {@link #FX_FOCUS_NAVIGATION_RIGHT},\n     *            {@link #FX_KEYPRESS_STANDARD},\n     *            {@link #FX_KEYPRESS_SPACEBAR},\n     *            {@link #FX_KEYPRESS_DELETE},\n     *            {@link #FX_KEYPRESS_RETURN},\n     *            {@link #FX_KEYPRESS_INVALID},\n     * @param userId The current user to pull sound settings from\n     * NOTE: This version uses the UI settings to determine\n     * whether sounds are heard or not.\n     * @hide\n     ",
    "links" : [ "#FX_FOCUS_NAVIGATION_RIGHT", "#FX_KEYPRESS_SPACEBAR", "#FX_KEYPRESS_DELETE", "#FX_KEYPRESS_RETURN", "#FX_FOCUS_NAVIGATION_DOWN", "#FX_FOCUS_NAVIGATION_LEFT", "#FX_KEYPRESS_STANDARD", "#FX_KEY_CLICK", "#FX_FOCUS_NAVIGATION_UP", "#FX_KEYPRESS_INVALID" ]
  }, {
    "name" : "public void playSoundEffect(int effectType, float volume)",
    "returnType" : "void",
    "comment" : "\n     * Plays a sound effect (Key clicks, lid open/close...)\n     * @param effectType The type of sound effect. One of\n     *            {@link #FX_KEY_CLICK},\n     *            {@link #FX_FOCUS_NAVIGATION_UP},\n     *            {@link #FX_FOCUS_NAVIGATION_DOWN},\n     *            {@link #FX_FOCUS_NAVIGATION_LEFT},\n     *            {@link #FX_FOCUS_NAVIGATION_RIGHT},\n     *            {@link #FX_KEYPRESS_STANDARD},\n     *            {@link #FX_KEYPRESS_SPACEBAR},\n     *            {@link #FX_KEYPRESS_DELETE},\n     *            {@link #FX_KEYPRESS_RETURN},\n     *            {@link #FX_KEYPRESS_INVALID},\n     * @param volume Sound effect volume.\n     * The volume value is a raw scalar so UI controls should be scaled logarithmically.\n     * If a volume of -1 is specified, the AudioManager.STREAM_MUSIC stream volume minus 3dB will be used.\n     * NOTE: This version is for applications that have their own\n     * settings panel for enabling and controlling volume.\n     ",
    "links" : [ "#FX_FOCUS_NAVIGATION_RIGHT", "#FX_KEYPRESS_SPACEBAR", "#FX_KEYPRESS_DELETE", "#FX_KEYPRESS_RETURN", "#FX_FOCUS_NAVIGATION_DOWN", "#FX_FOCUS_NAVIGATION_LEFT", "#FX_KEYPRESS_STANDARD", "#FX_KEY_CLICK", "#FX_FOCUS_NAVIGATION_UP", "#FX_KEYPRESS_INVALID" ]
  }, {
    "name" : "private boolean querySoundEffectsEnabled(int user)",
    "returnType" : "boolean",
    "comment" : "\n     * Settings has an in memory cache, so this is fast.\n     ",
    "links" : [ ]
  }, {
    "name" : "public void loadSoundEffects()",
    "returnType" : "void",
    "comment" : "\n     *  Load Sound effects.\n     *  This method must be called when sound effects are enabled.\n     ",
    "links" : [ ]
  }, {
    "name" : "public void unloadSoundEffects()",
    "returnType" : "void",
    "comment" : "\n     *  Unload Sound effects.\n     *  This method can be called to free some memory when\n     *  sound effects are disabled.\n     ",
    "links" : [ ]
  }, {
    "name" : "public static String audioFocusToString(int focus)",
    "returnType" : "String",
    "comment" : "\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "private FocusRequestInfo findFocusRequestInfo(String id)",
    "returnType" : "FocusRequestInfo",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private String getIdForAudioFocusListener(OnAudioFocusChangeListener l)",
    "returnType" : "String",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public void registerAudioFocusRequest(@NonNull AudioFocusRequest afr)",
    "returnType" : "void",
    "comment" : "\n     * @hide\n     * Registers a listener to be called when audio focus changes and keeps track of the associated\n     * focus request (including Handler to use for the listener).\n     * @param afr the full request parameters\n     ",
    "links" : [ ]
  }, {
    "name" : "public void unregisterAudioFocusRequest(OnAudioFocusChangeListener l)",
    "returnType" : "void",
    "comment" : "\n     * @hide\n     * Causes the specified listener to not be called anymore when focus is gained or lost.\n     * @param l the listener to unregister.\n     ",
    "links" : [ ]
  }, {
    "name" : "public int requestAudioFocus(OnAudioFocusChangeListener l, int streamType, int durationHint)",
    "returnType" : "int",
    "comment" : "\n     *  Request audio focus.\n     *  Send a request to obtain the audio focus\n     *  @param l the listener to be notified of audio focus changes\n     *  @param streamType the main audio stream type affected by the focus request\n     *  @param durationHint use {@link #AUDIOFOCUS_GAIN_TRANSIENT} to indicate this focus request\n     *      is temporary, and focus will be abandonned shortly. Examples of transient requests are\n     *      for the playback of driving directions, or notifications sounds.\n     *      Use {@link #AUDIOFOCUS_GAIN_TRANSIENT_MAY_DUCK} to indicate also that it's ok for\n     *      the previous focus owner to keep playing if it ducks its audio output.\n     *      Alternatively use {@link #AUDIOFOCUS_GAIN_TRANSIENT_EXCLUSIVE} for a temporary request\n     *      that benefits from the system not playing disruptive sounds like notifications, for\n     *      usecases such as voice memo recording, or speech recognition.\n     *      Use {@link #AUDIOFOCUS_GAIN} for a focus request of unknown duration such\n     *      as the playback of a song or a video.\n     *  @return {@link #AUDIOFOCUS_REQUEST_FAILED} or {@link #AUDIOFOCUS_REQUEST_GRANTED}\n     *  @deprecated use {@link #requestAudioFocus(AudioFocusRequest)}\n     ",
    "links" : [ "#AUDIOFOCUS_GAIN_TRANSIENT_MAY_DUCK", "#AUDIOFOCUS_GAIN_TRANSIENT_EXCLUSIVE", "#AUDIOFOCUS_REQUEST_GRANTED", "#AUDIOFOCUS_GAIN_TRANSIENT", "#AUDIOFOCUS_REQUEST_FAILED", "#AUDIOFOCUS_GAIN", "#requestAudioFocus(AudioFocusRequest)" ]
  }, {
    "name" : "public int requestAudioFocus(@NonNull AudioFocusRequest focusRequest)",
    "returnType" : "int",
    "comment" : "\n     * Request audio focus.\n     * See the {@link AudioFocusRequest} for information about the options available to configure\n     * your request, and notification of focus gain and loss.\n     * @param focusRequest a {@link AudioFocusRequest} instance used to configure how focus is\n     *   requested.\n     * @return {@link #AUDIOFOCUS_REQUEST_FAILED}, {@link #AUDIOFOCUS_REQUEST_GRANTED}\n     *     or {@link #AUDIOFOCUS_REQUEST_DELAYED}.\n     *     <br>Note that the return value is never {@link #AUDIOFOCUS_REQUEST_DELAYED} when focus\n     *     is requested without building the {@link AudioFocusRequest} with\n     *     {@link AudioFocusRequest.Builder#setAcceptsDelayedFocusGain(boolean)} set to\n     *     {@code true}.\n     * @throws NullPointerException if passed a null argument\n     ",
    "links" : [ "#AUDIOFOCUS_REQUEST_DELAYED", "#AUDIOFOCUS_REQUEST_GRANTED", "android.media.AudioFocusRequest", "AudioFocusRequest.Builder#setAcceptsDelayedFocusGain(boolean)", "#AUDIOFOCUS_REQUEST_FAILED" ]
  }, {
    "name" : "public int abandonAudioFocusRequest(@NonNull AudioFocusRequest focusRequest)",
    "returnType" : "int",
    "comment" : "\n     *  Abandon audio focus. Causes the previous focus owner, if any, to receive focus.\n     *  @param focusRequest the {@link AudioFocusRequest} that was used when requesting focus\n     *      with {@link #requestAudioFocus(AudioFocusRequest)}.\n     *  @return {@link #AUDIOFOCUS_REQUEST_FAILED} or {@link #AUDIOFOCUS_REQUEST_GRANTED}\n     *  @throws IllegalArgumentException if passed a null argument\n     ",
    "links" : [ "#AUDIOFOCUS_REQUEST_GRANTED", "android.media.AudioFocusRequest", "#AUDIOFOCUS_REQUEST_FAILED", "#requestAudioFocus(AudioFocusRequest)" ]
  }, {
    "name" : "public int requestAudioFocus(OnAudioFocusChangeListener l, @NonNull AudioAttributes requestAttributes, int durationHint, int flags) throws IllegalArgumentException",
    "returnType" : "int",
    "comment" : "\n     * @hide\n     * Request audio focus.\n     * Send a request to obtain the audio focus. This method differs from\n     * {@link #requestAudioFocus(OnAudioFocusChangeListener, int, int)} in that it can express\n     * that the requester accepts delayed grants of audio focus.\n     * @param l the listener to be notified of audio focus changes. It is not allowed to be null\n     *     when the request is flagged with {@link #AUDIOFOCUS_FLAG_DELAY_OK}.\n     * @param requestAttributes non null {@link AudioAttributes} describing the main reason for\n     *     requesting audio focus.\n     * @param durationHint use {@link #AUDIOFOCUS_GAIN_TRANSIENT} to indicate this focus request\n     *      is temporary, and focus will be abandonned shortly. Examples of transient requests are\n     *      for the playback of driving directions, or notifications sounds.\n     *      Use {@link #AUDIOFOCUS_GAIN_TRANSIENT_MAY_DUCK} to indicate also that it's ok for\n     *      the previous focus owner to keep playing if it ducks its audio output.\n     *      Alternatively use {@link #AUDIOFOCUS_GAIN_TRANSIENT_EXCLUSIVE} for a temporary request\n     *      that benefits from the system not playing disruptive sounds like notifications, for\n     *      usecases such as voice memo recording, or speech recognition.\n     *      Use {@link #AUDIOFOCUS_GAIN} for a focus request of unknown duration such\n     *      as the playback of a song or a video.\n     * @param flags 0 or a combination of {link #AUDIOFOCUS_FLAG_DELAY_OK},\n     *     {@link #AUDIOFOCUS_FLAG_PAUSES_ON_DUCKABLE_LOSS} and {@link #AUDIOFOCUS_FLAG_LOCK}.\n     *     <br>Use 0 when not using any flags for the request, which behaves like\n     *     {@link #requestAudioFocus(OnAudioFocusChangeListener, int, int)}, where either audio\n     *     focus is granted immediately, or the grant request fails because the system is in a\n     *     state where focus cannot change (e.g. a phone call).\n     * @return {@link #AUDIOFOCUS_REQUEST_FAILED}, {@link #AUDIOFOCUS_REQUEST_GRANTED}\n     *     or {@link #AUDIOFOCUS_REQUEST_DELAYED}.\n     *     The return value is never {@link #AUDIOFOCUS_REQUEST_DELAYED} when focus is requested\n     *     without the {@link #AUDIOFOCUS_FLAG_DELAY_OK} flag.\n     * @throws IllegalArgumentException\n     ",
    "links" : [ "#AUDIOFOCUS_GAIN_TRANSIENT_MAY_DUCK", "#AUDIOFOCUS_FLAG_LOCK", "#AUDIOFOCUS_REQUEST_DELAYED", "#AUDIOFOCUS_GAIN_TRANSIENT_EXCLUSIVE", "#AUDIOFOCUS_REQUEST_GRANTED", "android.media.AudioAttributes", "#AUDIOFOCUS_FLAG_PAUSES_ON_DUCKABLE_LOSS", "#requestAudioFocus(OnAudioFocusChangeListener", "#AUDIOFOCUS_GAIN_TRANSIENT", "#AUDIOFOCUS_REQUEST_FAILED", "#AUDIOFOCUS_FLAG_DELAY_OK", "#AUDIOFOCUS_GAIN" ]
  }, {
    "name" : "public int requestAudioFocus(OnAudioFocusChangeListener l, @NonNull AudioAttributes requestAttributes, int durationHint, int flags, AudioPolicy ap) throws IllegalArgumentException",
    "returnType" : "int",
    "comment" : "\n     * @hide\n     * Request or lock audio focus.\n     * This method is to be used by system components that have registered an\n     * {@link android.media.audiopolicy.AudioPolicy} to request audio focus, but also to \"lock\" it\n     * so focus granting is temporarily disabled.\n     * @param l see the description of the same parameter in\n     *     {@link #requestAudioFocus(OnAudioFocusChangeListener, AudioAttributes, int, int)}\n     * @param requestAttributes non null {@link AudioAttributes} describing the main reason for\n     *     requesting audio focus.\n     * @param durationHint see the description of the same parameter in\n     *     {@link #requestAudioFocus(OnAudioFocusChangeListener, AudioAttributes, int, int)}\n     * @param flags 0 or a combination of {link #AUDIOFOCUS_FLAG_DELAY_OK},\n     *     {@link #AUDIOFOCUS_FLAG_PAUSES_ON_DUCKABLE_LOSS}, and {@link #AUDIOFOCUS_FLAG_LOCK}.\n     *     <br>Use 0 when not using any flags for the request, which behaves like\n     *     {@link #requestAudioFocus(OnAudioFocusChangeListener, int, int)}, where either audio\n     *     focus is granted immediately, or the grant request fails because the system is in a\n     *     state where focus cannot change (e.g. a phone call).\n     * @param ap a registered {@link android.media.audiopolicy.AudioPolicy} instance when locking\n     *     focus, or null.\n     * @return see the description of the same return value in\n     *     {@link #requestAudioFocus(OnAudioFocusChangeListener, AudioAttributes, int, int)}\n     * @throws IllegalArgumentException\n     * @deprecated use {@link #requestAudioFocus(AudioFocusRequest, AudioPolicy)}\n     ",
    "links" : [ "#AUDIOFOCUS_FLAG_LOCK", "#requestAudioFocus(AudioFocusRequest", "android.media.AudioAttributes", "#AUDIOFOCUS_FLAG_PAUSES_ON_DUCKABLE_LOSS", "#requestAudioFocus(OnAudioFocusChangeListener", "android.media.audiopolicy.AudioPolicy" ]
  }, {
    "name" : "public int requestAudioFocus(@NonNull AudioFocusRequest afr, @Nullable AudioPolicy ap)",
    "returnType" : "int",
    "comment" : "\n     * @hide\n     * Request or lock audio focus.\n     * This method is to be used by system components that have registered an\n     * {@link android.media.audiopolicy.AudioPolicy} to request audio focus, but also to \"lock\" it\n     * so focus granting is temporarily disabled.\n     * @param afr see the description of the same parameter in\n     *     {@link #requestAudioFocus(AudioFocusRequest)}\n     * @param ap a registered {@link android.media.audiopolicy.AudioPolicy} instance when locking\n     *     focus, or null.\n     * @return {@link #AUDIOFOCUS_REQUEST_FAILED}, {@link #AUDIOFOCUS_REQUEST_GRANTED}\n     *     or {@link #AUDIOFOCUS_REQUEST_DELAYED}.\n     * @throws NullPointerException if the AudioFocusRequest is null\n     * @throws IllegalArgumentException when trying to lock focus without an AudioPolicy\n     ",
    "links" : [ "#AUDIOFOCUS_REQUEST_DELAYED", "#AUDIOFOCUS_REQUEST_GRANTED", "android.media.audiopolicy.AudioPolicy", "#AUDIOFOCUS_REQUEST_FAILED", "#requestAudioFocus(AudioFocusRequest)" ]
  }, {
    "name" : "public void requestAudioFocusForCall(int streamType, int durationHint)",
    "returnType" : "void",
    "comment" : "\n     * @hide\n     * Used internally by telephony package to request audio focus. Will cause the focus request\n     * to be associated with the \"voice communication\" identifier only used in AudioService\n     * to identify this use case.\n     * @param streamType use STREAM_RING for focus requests when ringing, VOICE_CALL for\n     *    the establishment of the call\n     * @param durationHint the type of focus request. AUDIOFOCUS_GAIN_TRANSIENT is recommended so\n     *    media applications resume after a call\n     ",
    "links" : [ ]
  }, {
    "name" : "public int getFocusRampTimeMs(int focusGain, AudioAttributes attr)",
    "returnType" : "int",
    "comment" : "\n     * @hide\n     * Return the volume ramping time for a sound to be played after the given focus request,\n     *   and to play a sound of the given attributes\n     * @param focusGain\n     * @param attr\n     * @return\n     ",
    "links" : [ ]
  }, {
    "name" : "public void setFocusRequestResult(@NonNull AudioFocusInfo afi, @FocusRequestResult int requestResult, @NonNull AudioPolicy ap)",
    "returnType" : "void",
    "comment" : "\n     * @hide\n     * Set the result to the audio focus request received through\n     * {@link AudioPolicyFocusListener#onAudioFocusRequest(AudioFocusInfo, int)}.\n     * @param afi the information about the focus requester\n     * @param requestResult the result to the focus request to be passed to the requester\n     * @param ap a valid registered {@link AudioPolicy} configured as a focus policy.\n     ",
    "links" : [ "android.media.audiopolicy.AudioPolicy.AudioPolicyFocusListener#onAudioFocusRequest(AudioFocusInfo", "android.media.audiopolicy.AudioPolicy" ]
  }, {
    "name" : "public int dispatchAudioFocusChange(@NonNull AudioFocusInfo afi, int focusChange, @NonNull AudioPolicy ap)",
    "returnType" : "int",
    "comment" : "\n     * @hide\n     * Notifies an application with a focus listener of gain or loss of audio focus.\n     * This method can only be used by owners of an {@link AudioPolicy} configured with\n     * {@link AudioPolicy.Builder#setIsAudioFocusPolicy(boolean)} set to true.\n     * @param afi the recipient of the focus change, that has previously requested audio focus, and\n     *     that was received by the {@code AudioPolicy} through\n     *     {@link AudioPolicy.AudioPolicyFocusListener#onAudioFocusRequest(AudioFocusInfo, int)}.\n     * @param focusChange one of focus gain types ({@link #AUDIOFOCUS_GAIN},\n     *     {@link #AUDIOFOCUS_GAIN_TRANSIENT}, {@link #AUDIOFOCUS_GAIN_TRANSIENT_MAY_DUCK} or\n     *     {@link #AUDIOFOCUS_GAIN_TRANSIENT_EXCLUSIVE})\n     *     or one of the focus loss types ({@link AudioManager#AUDIOFOCUS_LOSS},\n     *     {@link AudioManager#AUDIOFOCUS_LOSS_TRANSIENT},\n     *     or {@link AudioManager#AUDIOFOCUS_LOSS_TRANSIENT_CAN_DUCK}).\n     *     <br>For the focus gain, the change type should be the same as the app requested.\n     * @param ap a valid registered {@link AudioPolicy} configured as a focus policy.\n     * @return {@link #AUDIOFOCUS_REQUEST_GRANTED} if the dispatch was successfully sent, or\n     *     {@link #AUDIOFOCUS_REQUEST_FAILED} if the focus client didn't have a listener, or\n     *     if there was an error sending the request.\n     * @throws NullPointerException if the {@link AudioFocusInfo} or {@link AudioPolicy} are null.\n     ",
    "links" : [ "#AUDIOFOCUS_GAIN_TRANSIENT_MAY_DUCK", "android.media.AudioManager#AUDIOFOCUS_LOSS_TRANSIENT", "AudioPolicy.Builder#setIsAudioFocusPolicy(boolean)", "#AUDIOFOCUS_GAIN_TRANSIENT_EXCLUSIVE", "AudioPolicy.AudioPolicyFocusListener#onAudioFocusRequest(AudioFocusInfo", "android.media.AudioManager#AUDIOFOCUS_LOSS_TRANSIENT_CAN_DUCK", "#AUDIOFOCUS_REQUEST_GRANTED", "#AUDIOFOCUS_GAIN_TRANSIENT", "android.media.AudioFocusInfo", "android.media.audiopolicy.AudioPolicy", "#AUDIOFOCUS_REQUEST_FAILED", "#AUDIOFOCUS_GAIN", "android.media.AudioManager#AUDIOFOCUS_LOSS" ]
  }, {
    "name" : "public void abandonAudioFocusForCall()",
    "returnType" : "void",
    "comment" : "\n     * @hide\n     * Used internally by telephony package to abandon audio focus, typically after a call or\n     * when ringing ends and the call is rejected or not answered.\n     * Should match one or more calls to {@link #requestAudioFocusForCall(int, int)}.\n     ",
    "links" : [ "#requestAudioFocusForCall(int" ]
  }, {
    "name" : "public int abandonAudioFocus(OnAudioFocusChangeListener l)",
    "returnType" : "int",
    "comment" : "\n     *  Abandon audio focus. Causes the previous focus owner, if any, to receive focus.\n     *  @param l the listener with which focus was requested.\n     *  @return {@link #AUDIOFOCUS_REQUEST_FAILED} or {@link #AUDIOFOCUS_REQUEST_GRANTED}\n     *  @deprecated use {@link #abandonAudioFocusRequest(AudioFocusRequest)}\n     ",
    "links" : [ "#abandonAudioFocusRequest(AudioFocusRequest)", "#AUDIOFOCUS_REQUEST_GRANTED", "#AUDIOFOCUS_REQUEST_FAILED" ]
  }, {
    "name" : "public int abandonAudioFocus(OnAudioFocusChangeListener l, AudioAttributes aa)",
    "returnType" : "int",
    "comment" : "\n     * @hide\n     * Abandon audio focus. Causes the previous focus owner, if any, to receive focus.\n     *  @param l the listener with which focus was requested.\n     * @param aa the {@link AudioAttributes} with which audio focus was requested\n     * @return {@link #AUDIOFOCUS_REQUEST_FAILED} or {@link #AUDIOFOCUS_REQUEST_GRANTED}\n     * @deprecated use {@link #abandonAudioFocusRequest(AudioFocusRequest)}\n     ",
    "links" : [ "#abandonAudioFocusRequest(AudioFocusRequest)", "#AUDIOFOCUS_REQUEST_GRANTED", "android.media.AudioAttributes", "#AUDIOFOCUS_REQUEST_FAILED" ]
  }, {
    "name" : "public void registerMediaButtonEventReceiver(ComponentName eventReceiver)",
    "returnType" : "void",
    "comment" : "\n     * Register a component to be the sole receiver of MEDIA_BUTTON intents.\n     * @param eventReceiver identifier of a {@link android.content.BroadcastReceiver}\n     *      that will receive the media button intent. This broadcast receiver must be declared\n     *      in the application manifest. The package of the component must match that of\n     *      the context you're registering from.\n     * @deprecated Use {@link MediaSession#setMediaButtonReceiver(PendingIntent)} instead.\n     ",
    "links" : [ "android.media.session.MediaSession#setMediaButtonReceiver(PendingIntent)", "android.content.BroadcastReceiver" ]
  }, {
    "name" : "public void registerMediaButtonEventReceiver(PendingIntent eventReceiver)",
    "returnType" : "void",
    "comment" : "\n     * Register a component to be the sole receiver of MEDIA_BUTTON intents.  This is like\n     * {@link #registerMediaButtonEventReceiver(android.content.ComponentName)}, but allows\n     * the buttons to go to any PendingIntent.  Note that you should only use this form if\n     * you know you will continue running for the full time until unregistering the\n     * PendingIntent.\n     * @param eventReceiver target that will receive media button intents.  The PendingIntent\n     * will be sent an {@link Intent#ACTION_MEDIA_BUTTON} event when a media button action\n     * occurs, with {@link Intent#EXTRA_KEY_EVENT} added and holding the key code of the\n     * media button that was pressed.\n     * @deprecated Use {@link MediaSession#setMediaButtonReceiver(PendingIntent)} instead.\n     ",
    "links" : [ "#registerMediaButtonEventReceiver(android.content.ComponentName)", "android.app.PendingIntent#ACTION_MEDIA_BUTTON", "android.media.session.MediaSession#setMediaButtonReceiver(PendingIntent)", "android.app.PendingIntent#EXTRA_KEY_EVENT" ]
  }, {
    "name" : "public void registerMediaButtonIntent(PendingIntent pi, ComponentName eventReceiver)",
    "returnType" : "void",
    "comment" : "\n     * @hide\n     * no-op if (pi == null) or (eventReceiver == null)\n     ",
    "links" : [ ]
  }, {
    "name" : "public void unregisterMediaButtonEventReceiver(ComponentName eventReceiver)",
    "returnType" : "void",
    "comment" : "\n     * Unregister the receiver of MEDIA_BUTTON intents.\n     * @param eventReceiver identifier of a {@link android.content.BroadcastReceiver}\n     *      that was registered with {@link #registerMediaButtonEventReceiver(ComponentName)}.\n     * @deprecated Use {@link MediaSession} instead.\n     ",
    "links" : [ "#registerMediaButtonEventReceiver(ComponentName)", "android.media.session.MediaSession", "android.content.BroadcastReceiver" ]
  }, {
    "name" : "public void unregisterMediaButtonEventReceiver(PendingIntent eventReceiver)",
    "returnType" : "void",
    "comment" : "\n     * Unregister the receiver of MEDIA_BUTTON intents.\n     * @param eventReceiver same PendingIntent that was registed with\n     *      {@link #registerMediaButtonEventReceiver(PendingIntent)}.\n     * @deprecated Use {@link MediaSession} instead.\n     ",
    "links" : [ "android.media.session.MediaSession", "#registerMediaButtonEventReceiver(PendingIntent)" ]
  }, {
    "name" : "public void unregisterMediaButtonIntent(PendingIntent pi)",
    "returnType" : "void",
    "comment" : "\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public void registerRemoteControlClient(RemoteControlClient rcClient)",
    "returnType" : "void",
    "comment" : "\n     * Registers the remote control client for providing information to display on the remote\n     * controls.\n     * @param rcClient The remote control client from which remote controls will receive\n     *      information to display.\n     * @see RemoteControlClient\n     * @deprecated Use {@link MediaSession} instead.\n     ",
    "links" : [ "android.media.session.MediaSession" ]
  }, {
    "name" : "public void unregisterRemoteControlClient(RemoteControlClient rcClient)",
    "returnType" : "void",
    "comment" : "\n     * Unregisters the remote control client that was providing information to display on the\n     * remote controls.\n     * @param rcClient The remote control client to unregister.\n     * @see #registerRemoteControlClient(RemoteControlClient)\n     * @deprecated Use {@link MediaSession} instead.\n     ",
    "links" : [ "android.media.session.MediaSession" ]
  }, {
    "name" : "public boolean registerRemoteController(RemoteController rctlr)",
    "returnType" : "boolean",
    "comment" : "\n     * Registers a {@link RemoteController} instance for it to receive media\n     * metadata updates and playback state information from applications using\n     * {@link RemoteControlClient}, and control their playback.\n     * <p>\n     * Registration requires the {@link RemoteController.OnClientUpdateListener} listener to be\n     * one of the enabled notification listeners (see\n     * {@link android.service.notification.NotificationListenerService}).\n     *\n     * @param rctlr the object to register.\n     * @return true if the {@link RemoteController} was successfully registered,\n     *         false if an error occurred, due to an internal system error, or\n     *         insufficient permissions.\n     * @deprecated Use\n     *             {@link MediaSessionManager#addOnActiveSessionsChangedListener(android.media.session.MediaSessionManager.OnActiveSessionsChangedListener, ComponentName)}\n     *             and {@link MediaController} instead.\n     ",
    "links" : [ "android.media.RemoteControlClient", "android.media.session.MediaSessionManager#addOnActiveSessionsChangedListener(android.media.session.MediaSessionManager.OnActiveSessionsChangedListener", "android.media.RemoteController", "RemoteController.OnClientUpdateListener", "android.service.notification.NotificationListenerService", "android.media.session.MediaController" ]
  }, {
    "name" : "public void unregisterRemoteController(RemoteController rctlr)",
    "returnType" : "void",
    "comment" : "\n     * Unregisters a {@link RemoteController}, causing it to no longer receive\n     * media metadata and playback state information, and no longer be capable\n     * of controlling playback.\n     *\n     * @param rctlr the object to unregister.\n     * @deprecated Use\n     *             {@link MediaSessionManager#removeOnActiveSessionsChangedListener(android.media.session.MediaSessionManager.OnActiveSessionsChangedListener)}\n     *             instead.\n     ",
    "links" : [ "android.media.RemoteController", "android.media.session.MediaSessionManager#removeOnActiveSessionsChangedListener(android.media.session.MediaSessionManager.OnActiveSessionsChangedListener)" ]
  }, {
    "name" : "public int registerAudioPolicy(@NonNull AudioPolicy policy)",
    "returnType" : "int",
    "comment" : "\n     * @hide\n     * Register the given {@link AudioPolicy}.\n     * This call is synchronous and blocks until the registration process successfully completed\n     * or failed to complete.\n     * @param policy the non-null {@link AudioPolicy} to register.\n     * @return {@link #ERROR} if there was an error communicating with the registration service\n     *    or if the user doesn't have the required\n     *    {@link android.Manifest.permission#MODIFY_AUDIO_ROUTING} permission,\n     *    {@link #SUCCESS} otherwise.\n     ",
    "links" : [ "android.Manifest.permission#MODIFY_AUDIO_ROUTING", "#ERROR", "#SUCCESS", "android.media.audiopolicy.AudioPolicy" ]
  }, {
    "name" : " static int registerAudioPolicyStatic(@NonNull AudioPolicy policy)",
    "returnType" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public void unregisterAudioPolicyAsync(@NonNull AudioPolicy policy)",
    "returnType" : "void",
    "comment" : "\n     * @hide\n     * Unregisters an {@link AudioPolicy} asynchronously.\n     * @param policy the non-null {@link AudioPolicy} to unregister.\n     ",
    "links" : [ "android.media.audiopolicy.AudioPolicy" ]
  }, {
    "name" : " static void unregisterAudioPolicyAsyncStatic(@NonNull AudioPolicy policy)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public void unregisterAudioPolicy(@NonNull AudioPolicy policy)",
    "returnType" : "void",
    "comment" : "\n     * @hide\n     * Unregisters an {@link AudioPolicy} synchronously.\n     * This method also invalidates all {@link AudioRecord} and {@link AudioTrack} objects\n     * associated with mixes of this policy.\n     * @param policy the non-null {@link AudioPolicy} to unregister.\n     ",
    "links" : [ "android.media.AudioRecord", "android.media.AudioTrack", "android.media.audiopolicy.AudioPolicy" ]
  }, {
    "name" : "public boolean hasRegisteredDynamicPolicy()",
    "returnType" : "boolean",
    "comment" : "\n     * @hide\n     * @return true if an AudioPolicy was previously registered\n     ",
    "links" : [ ]
  }, {
    "name" : "public void registerAudioPlaybackCallback(@NonNull AudioPlaybackCallback cb, @Nullable Handler handler)",
    "returnType" : "void",
    "comment" : "\n     * Register a callback to be notified of audio playback changes through\n     * {@link AudioPlaybackCallback}\n     * @param cb non-null callback to register\n     * @param handler the {@link Handler} object for the thread on which to execute\n     * the callback. If <code>null</code>, the {@link Handler} associated with the main\n     * {@link Looper} will be used.\n     ",
    "links" : [ "AudioPlaybackCallback", "android.media.audiopolicy.AudioVolumeGroupChangeHandler", "android.os.Looper" ]
  }, {
    "name" : "public void unregisterAudioPlaybackCallback(@NonNull AudioPlaybackCallback cb)",
    "returnType" : "void",
    "comment" : "\n     * Unregister an audio playback callback previously registered with\n     * {@link #registerAudioPlaybackCallback(AudioPlaybackCallback, Handler)}.\n     * @param cb non-null callback to unregister\n     ",
    "links" : [ "#registerAudioPlaybackCallback(AudioPlaybackCallback" ]
  }, {
    "name" : "public List<AudioPlaybackConfiguration> getActivePlaybackConfigurations()",
    "returnType" : "List<AudioPlaybackConfiguration>",
    "comment" : "\n     * Returns the current active audio playback configurations of the device\n     * @return a non-null list of playback configurations. An empty list indicates there is no\n     *     playback active when queried.\n     * @see AudioPlaybackConfiguration\n     ",
    "links" : [ ]
  }, {
    "name" : "private boolean hasPlaybackCallback_sync(@NonNull AudioPlaybackCallback cb)",
    "returnType" : "boolean",
    "comment" : "\n     * Must be called synchronized on mPlaybackCallbackLock\n     ",
    "links" : [ ]
  }, {
    "name" : "private boolean removePlaybackCallback_sync(@NonNull AudioPlaybackCallback cb)",
    "returnType" : "boolean",
    "comment" : "\n     * Must be called synchronized on mPlaybackCallbackLock\n     ",
    "links" : [ ]
  }, {
    "name" : "public void registerAudioRecordingCallback(@NonNull AudioRecordingCallback cb, @Nullable Handler handler)",
    "returnType" : "void",
    "comment" : "\n     * Register a callback to be notified of audio recording changes through\n     * {@link AudioRecordingCallback}\n     * @param cb non-null callback to register\n     * @param handler the {@link Handler} object for the thread on which to execute\n     * the callback. If <code>null</code>, the {@link Handler} associated with the main\n     * {@link Looper} will be used.\n     ",
    "links" : [ "android.media.audiopolicy.AudioVolumeGroupChangeHandler", "android.os.Looper", "AudioRecordingCallback" ]
  }, {
    "name" : "public void unregisterAudioRecordingCallback(@NonNull AudioRecordingCallback cb)",
    "returnType" : "void",
    "comment" : "\n     * Unregister an audio recording callback previously registered with\n     * {@link #registerAudioRecordingCallback(AudioRecordingCallback, Handler)}.\n     * @param cb non-null callback to unregister\n     ",
    "links" : [ "#registerAudioRecordingCallback(AudioRecordingCallback" ]
  }, {
    "name" : "public List<AudioRecordingConfiguration> getActiveRecordingConfigurations()",
    "returnType" : "List<AudioRecordingConfiguration>",
    "comment" : "\n     * Returns the current active audio recording configurations of the device.\n     * @return a non-null list of recording configurations. An empty list indicates there is\n     *     no recording active when queried.\n     * @see AudioRecordingConfiguration\n     ",
    "links" : [ ]
  }, {
    "name" : "private boolean hasRecordCallback_sync(@NonNull AudioRecordingCallback cb)",
    "returnType" : "boolean",
    "comment" : "\n     * Must be called synchronized on mRecordCallbackLock\n     ",
    "links" : [ ]
  }, {
    "name" : "private boolean removeRecordCallback_sync(@NonNull AudioRecordingCallback cb)",
    "returnType" : "boolean",
    "comment" : "\n     * Must be called synchronized on mRecordCallbackLock\n     ",
    "links" : [ ]
  }, {
    "name" : "public void reloadAudioSettings()",
    "returnType" : "void",
    "comment" : "\n     *  @hide\n     *  Reload audio settings. This method is called by Settings backup\n     *  agent when audio settings are restored and causes the AudioService\n     *  to read and apply restored settings.\n     ",
    "links" : [ ]
  }, {
    "name" : "public void avrcpSupportsAbsoluteVolume(String address, boolean support)",
    "returnType" : "void",
    "comment" : "\n     * @hide\n     * Notifies AudioService that it is connected to an A2DP device that supports absolute volume,\n     * so that AudioService can send volume change events to the A2DP device, rather than handling\n     * them.\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean isSilentMode()",
    "returnType" : "boolean",
    "comment" : "\n     * Checks whether the phone is in silent mode, with or without vibrate.\n     *\n     * @return true if phone is in silent mode, with or without vibrate.\n     *\n     * @see #getRingerMode()\n     *\n     * @hide pending API Council approval\n     ",
    "links" : [ ]
  }, {
    "name" : "public static boolean isOutputDevice(int device)",
    "returnType" : "boolean",
    "comment" : "\n     * Return true if the device code corresponds to an output device.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public static boolean isInputDevice(int device)",
    "returnType" : "boolean",
    "comment" : "\n     * Return true if the device code corresponds to an input device.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public int getDevicesForStream(int streamType)",
    "returnType" : "int",
    "comment" : "\n     * Return the enabled devices for the specified output stream type.\n     *\n     * @param streamType The stream type to query. One of\n     *            {@link #STREAM_VOICE_CALL},\n     *            {@link #STREAM_SYSTEM},\n     *            {@link #STREAM_RING},\n     *            {@link #STREAM_MUSIC},\n     *            {@link #STREAM_ALARM},\n     *            {@link #STREAM_NOTIFICATION},\n     *            {@link #STREAM_DTMF},\n     *            {@link #STREAM_ACCESSIBILITY}.\n     *\n     * @return The bit-mask \"or\" of audio output device codes for all enabled devices on this\n     *         stream. Zero or more of\n     *            {@link #DEVICE_OUT_EARPIECE},\n     *            {@link #DEVICE_OUT_SPEAKER},\n     *            {@link #DEVICE_OUT_WIRED_HEADSET},\n     *            {@link #DEVICE_OUT_WIRED_HEADPHONE},\n     *            {@link #DEVICE_OUT_BLUETOOTH_SCO},\n     *            {@link #DEVICE_OUT_BLUETOOTH_SCO_HEADSET},\n     *            {@link #DEVICE_OUT_BLUETOOTH_SCO_CARKIT},\n     *            {@link #DEVICE_OUT_BLUETOOTH_A2DP},\n     *            {@link #DEVICE_OUT_BLUETOOTH_A2DP_HEADPHONES},\n     *            {@link #DEVICE_OUT_BLUETOOTH_A2DP_SPEAKER},\n     *            {@link #DEVICE_OUT_HDMI},\n     *            {@link #DEVICE_OUT_ANLG_DOCK_HEADSET},\n     *            {@link #DEVICE_OUT_DGTL_DOCK_HEADSET}.\n     *            {@link #DEVICE_OUT_USB_ACCESSORY}.\n     *            {@link #DEVICE_OUT_USB_DEVICE}.\n     *            {@link #DEVICE_OUT_REMOTE_SUBMIX}.\n     *            {@link #DEVICE_OUT_TELEPHONY_TX}.\n     *            {@link #DEVICE_OUT_LINE}.\n     *            {@link #DEVICE_OUT_HDMI_ARC}.\n     *            {@link #DEVICE_OUT_SPDIF}.\n     *            {@link #DEVICE_OUT_FM}.\n     *            {@link #DEVICE_OUT_DEFAULT} is not used here.\n     *\n     * The implementation may support additional device codes beyond those listed, so\n     * the application should ignore any bits which it does not recognize.\n     * Note that the information may be imprecise when the implementation\n     * cannot distinguish whether a particular device is enabled.\n     *\n     * {@hide}\n     ",
    "links" : [ "#DEVICE_OUT_WIRED_HEADSET", "#DEVICE_OUT_HDMI_ARC", "#DEVICE_OUT_BLUETOOTH_SCO", "#DEVICE_OUT_BLUETOOTH_SCO_CARKIT", "#DEVICE_OUT_EARPIECE", "#DEVICE_OUT_DEFAULT", "#DEVICE_OUT_DGTL_DOCK_HEADSET", "#DEVICE_OUT_FM", "#DEVICE_OUT_REMOTE_SUBMIX", "#STREAM_ALARM", "#DEVICE_OUT_BLUETOOTH_A2DP_SPEAKER", "#DEVICE_OUT_SPDIF", "#STREAM_SYSTEM", "#DEVICE_OUT_HDMI", "#DEVICE_OUT_USB_ACCESSORY", "#STREAM_VOICE_CALL", "#STREAM_MUSIC", "#STREAM_NOTIFICATION", "#STREAM_DTMF", "#DEVICE_OUT_TELEPHONY_TX", "#DEVICE_OUT_BLUETOOTH_A2DP", "#DEVICE_OUT_BLUETOOTH_SCO_HEADSET", "#STREAM_RING", "#DEVICE_OUT_ANLG_DOCK_HEADSET", "#DEVICE_OUT_USB_DEVICE", "#DEVICE_OUT_SPEAKER", "#DEVICE_OUT_LINE", "#DEVICE_OUT_BLUETOOTH_A2DP_HEADPHONES", "#DEVICE_OUT_WIRED_HEADPHONE", "#STREAM_ACCESSIBILITY" ]
  }, {
    "name" : "public List<AudioDeviceAttributes> getDevicesForAttributes(@NonNull AudioAttributes attributes)",
    "returnType" : "List<AudioDeviceAttributes>",
    "comment" : "\n     * @hide\n     * Get the audio devices that would be used for the routing of the given audio attributes.\n     * @param attributes the {@link AudioAttributes} for which the routing is being queried\n     * @return an empty list if there was an issue with the request, a list of audio devices\n     *   otherwise (typically one device, except for duplicated paths).\n     ",
    "links" : [ "android.media.AudioAttributes" ]
  }, {
    "name" : "public static void enforceValidVolumeBehavior(int volumeBehavior)",
    "returnType" : "void",
    "comment" : "\n     * @hide\n     * Throws IAE on an invalid volume behavior value\n     * @param volumeBehavior behavior value to check\n     ",
    "links" : [ ]
  }, {
    "name" : "public void setDeviceVolumeBehavior(int deviceType, @Nullable String deviceAddress, @DeviceVolumeBehavior int deviceVolumeBehavior)",
    "returnType" : "void",
    "comment" : "\n     * @hide\n     * Sets the volume behavior for an audio output device.\n     * @param deviceType the type of audio device to be affected. Currently only supports\n     *     {@link AudioDeviceInfo#TYPE_HDMI}, {@link AudioDeviceInfo#TYPE_HDMI_ARC},\n     *     {@link AudioDeviceInfo#TYPE_LINE_DIGITAL} and {@link AudioDeviceInfo#TYPE_AUX_LINE}\n     * @param deviceAddress the address of the device, if any\n     * @param deviceVolumeBehavior one of the device behaviors\n     ",
    "links" : [ "android.media.AudioDeviceInfo#TYPE_HDMI", "android.media.AudioDeviceInfo#TYPE_LINE_DIGITAL", "android.media.AudioDeviceInfo#TYPE_AUX_LINE", "android.media.AudioDeviceInfo#TYPE_HDMI_ARC" ]
  }, {
    "name" : "public void setDeviceVolumeBehavior(@NonNull AudioDeviceAttributes device, @DeviceVolumeBehavior int deviceVolumeBehavior)",
    "returnType" : "void",
    "comment" : "\n     * @hide\n     * Sets the volume behavior for an audio output device.\n     * @param device the device to be affected. Currently only supports devices of type\n     *     {@link AudioDeviceInfo#TYPE_HDMI}, {@link AudioDeviceInfo#TYPE_HDMI_ARC},\n     *     {@link AudioDeviceInfo#TYPE_LINE_DIGITAL} and {@link AudioDeviceInfo#TYPE_AUX_LINE}\n     * @param deviceVolumeBehavior one of the device behaviors\n     ",
    "links" : [ "android.media.AudioDeviceInfo#TYPE_HDMI", "android.media.AudioDeviceInfo#TYPE_LINE_DIGITAL", "android.media.AudioDeviceInfo#TYPE_AUX_LINE", "android.media.AudioDeviceInfo#TYPE_HDMI_ARC" ]
  }, {
    "name" : "public int getDeviceVolumeBehavior(int deviceType, @Nullable String deviceAddress)",
    "returnType" : "int",
    "comment" : "\n     * @hide\n     * Returns the volume device behavior for the given device type and address\n     * @param deviceType an audio output device type, as defined in {@link AudioDeviceInfo}\n     * @param deviceAddress the address of the audio device, if any.\n     * @return the volume behavior for the device\n     ",
    "links" : [ "android.media.AudioDeviceInfo" ]
  }, {
    "name" : "public int getDeviceVolumeBehavior(@NonNull AudioDeviceAttributes device)",
    "returnType" : "int",
    "comment" : "\n     * @hide\n     * Returns the volume device behavior for the given audio device\n     * @param device the audio device\n     * @return the volume behavior for the device\n     ",
    "links" : [ ]
  }, {
    "name" : "public void setWiredDeviceConnectionState(int type, int state, String address, String name)",
    "returnType" : "void",
    "comment" : "\n     * Indicate wired accessory connection state change.\n     * @param device type of device connected/disconnected (AudioManager.DEVICE_OUT_xxx)\n     * @param state  new connection state: 1 connected, 0 disconnected\n     * @param name   device name\n     * {@hide}\n     ",
    "links" : [ ]
  }, {
    "name" : "public void setBluetoothHearingAidDeviceConnectionState(BluetoothDevice device, int state, boolean suppressNoisyIntent, int musicDevice)",
    "returnType" : "void",
    "comment" : "\n     * Indicate Hearing Aid connection state change and eventually suppress\n     * the {@link AudioManager.ACTION_AUDIO_BECOMING_NOISY} intent.\n     * This operation is asynchronous but its execution will still be sequentially scheduled\n     * relative to calls to {@link #setBluetoothA2dpDeviceConnectionStateSuppressNoisyIntent(\n     * * BluetoothDevice, int, int, boolean, int)} and\n     * and {@link #handleBluetoothA2dpDeviceConfigChange(BluetoothDevice)}.\n     * @param device Bluetooth device connected/disconnected\n     * @param state new connection state (BluetoothProfile.STATE_xxx)\n     * @param musicDevice Default get system volume for the connecting device.\n     * (either {@link android.bluetooth.BluetoothProfile.hearingaid} or\n     * {@link android.bluetooth.BluetoothProfile.HEARING_AID})\n     * @param suppressNoisyIntent if true the\n     * {@link AudioManager.ACTION_AUDIO_BECOMING_NOISY} intent will not be sent.\n     * {@hide}\n     ",
    "links" : [ "#setBluetoothA2dpDeviceConnectionStateSuppressNoisyIntent(", "android.bluetooth.BluetoothProfile.HEARING_AID", "#handleBluetoothA2dpDeviceConfigChange(BluetoothDevice)", "AudioManager.ACTION_AUDIO_BECOMING_NOISY", "android.bluetooth.BluetoothProfile.hearingaid" ]
  }, {
    "name" : "public void setBluetoothA2dpDeviceConnectionStateSuppressNoisyIntent(BluetoothDevice device, int state, int profile, boolean suppressNoisyIntent, int a2dpVolume)",
    "returnType" : "void",
    "comment" : "\n     * Indicate A2DP source or sink connection state change and eventually suppress\n     * the {@link AudioManager.ACTION_AUDIO_BECOMING_NOISY} intent.\n     * This operation is asynchronous but its execution will still be sequentially scheduled\n     * relative to calls to {@link #setBluetoothHearingAidDeviceConnectionState(BluetoothDevice,\n     * int, boolean, int)} and\n     * {@link #handleBluetoothA2dpDeviceConfigChange(BluetoothDevice)}.\n     * @param device Bluetooth device connected/disconnected\n     * @param state  new connection state, {@link BluetoothProfile#STATE_CONNECTED}\n     *     or {@link BluetoothProfile#STATE_DISCONNECTED}\n     * @param profile profile for the A2DP device\n     * @param a2dpVolume New volume for the connecting device. Does nothing if disconnecting.\n     * (either {@link android.bluetooth.BluetoothProfile.A2DP} or\n     * {@link android.bluetooth.BluetoothProfile.A2DP_SINK})\n     * @param suppressNoisyIntent if true the\n     * {@link AudioManager.ACTION_AUDIO_BECOMING_NOISY} intent will not be sent.\n     * {@hide}\n     ",
    "links" : [ "android.bluetooth.BluetoothProfile#STATE_CONNECTED", "#handleBluetoothA2dpDeviceConfigChange(BluetoothDevice)", "AudioManager.ACTION_AUDIO_BECOMING_NOISY", "#setBluetoothHearingAidDeviceConnectionState(BluetoothDevice", "android.bluetooth.BluetoothProfile.A2DP_SINK", "android.bluetooth.BluetoothProfile.A2DP", "android.bluetooth.BluetoothProfile#STATE_DISCONNECTED" ]
  }, {
    "name" : "public void handleBluetoothA2dpDeviceConfigChange(BluetoothDevice device)",
    "returnType" : "void",
    "comment" : "\n     * Indicate A2DP device configuration has changed.\n     * This operation is asynchronous but its execution will still be sequentially scheduled\n     * relative to calls to\n     * {@link #setBluetoothA2dpDeviceConnectionStateSuppressNoisyIntent(BluetoothDevice, int, int,\n     * boolean, int)} and\n     * {@link #setBluetoothHearingAidDeviceConnectionState(BluetoothDevice, int, boolean, int)}\n     * @param device Bluetooth device whose configuration has changed.\n     * {@hide}\n     ",
    "links" : [ "#setBluetoothA2dpDeviceConnectionStateSuppressNoisyIntent(BluetoothDevice", "#setBluetoothHearingAidDeviceConnectionState(BluetoothDevice" ]
  }, {
    "name" : "public IRingtonePlayer getRingtonePlayer()",
    "returnType" : "IRingtonePlayer",
    "comment" : " {@hide} ",
    "links" : [ ]
  }, {
    "name" : "public String getProperty(String key)",
    "returnType" : "String",
    "comment" : "\n     * Returns the value of the property with the specified key.\n     * @param key One of the strings corresponding to a property key: either\n     *            {@link #PROPERTY_OUTPUT_SAMPLE_RATE},\n     *            {@link #PROPERTY_OUTPUT_FRAMES_PER_BUFFER},\n     *            {@link #PROPERTY_SUPPORT_MIC_NEAR_ULTRASOUND},\n     *            {@link #PROPERTY_SUPPORT_SPEAKER_NEAR_ULTRASOUND}, or\n     *            {@link #PROPERTY_SUPPORT_AUDIO_SOURCE_UNPROCESSED}.\n     * @return A string representing the associated value for that property key,\n     *         or null if there is no value for that key.\n     ",
    "links" : [ "#PROPERTY_OUTPUT_SAMPLE_RATE", "#PROPERTY_SUPPORT_AUDIO_SOURCE_UNPROCESSED", "#PROPERTY_OUTPUT_FRAMES_PER_BUFFER", "#PROPERTY_SUPPORT_MIC_NEAR_ULTRASOUND", "#PROPERTY_SUPPORT_SPEAKER_NEAR_ULTRASOUND" ]
  }, {
    "name" : "public boolean setAdditionalOutputDeviceDelay(@NonNull AudioDeviceInfo device, @IntRange(from = 0) long delayMillis)",
    "returnType" : "boolean",
    "comment" : "\n     * @hide\n     * Sets an additional audio output device delay in milliseconds.\n     *\n     * The additional output delay is a request to the output device to\n     * delay audio presentation (generally with respect to video presentation for better\n     * synchronization).\n     * It may not be supported by all output devices,\n     * and typically increases the audio latency by the amount of additional\n     * audio delay requested.\n     *\n     * If additional audio delay is supported by an audio output device,\n     * it is expected to be supported for all output streams (and configurations)\n     * opened on that device.\n     *\n     * @param device an instance of {@link AudioDeviceInfo} returned from {@link getDevices()}.\n     * @param delayMillis delay in milliseconds desired.  This should be in range of {@code 0}\n     *     to the value returned by {@link #getMaxAdditionalOutputDeviceDelay()}.\n     * @return true if successful, false if the device does not support output device delay\n     *     or the delay is not in range of {@link #getMaxAdditionalOutputDeviceDelay()}.\n     ",
    "links" : [ "getDevices()", "#getMaxAdditionalOutputDeviceDelay()", "android.media.AudioDeviceInfo" ]
  }, {
    "name" : "public long getAdditionalOutputDeviceDelay(@NonNull AudioDeviceInfo device)",
    "returnType" : "long",
    "comment" : "\n     * @hide\n     * Returns the current additional audio output device delay in milliseconds.\n     *\n     * @param device an instance of {@link AudioDeviceInfo} returned from {@link getDevices()}.\n     * @return the additional output device delay. This is a non-negative number.\n     *     {@code 0} is returned if unsupported.\n     ",
    "links" : [ "getDevices()", "android.media.AudioDeviceInfo" ]
  }, {
    "name" : "public long getMaxAdditionalOutputDeviceDelay(@NonNull AudioDeviceInfo device)",
    "returnType" : "long",
    "comment" : "\n     * @hide\n     * Returns the maximum additional audio output device delay in milliseconds.\n     *\n     * @param device an instance of {@link AudioDeviceInfo} returned from {@link getDevices()}.\n     * @return the maximum output device delay in milliseconds that can be set.\n     *     This is a non-negative number\n     *     representing the additional audio delay supported for the device.\n     *     {@code 0} is returned if unsupported.\n     ",
    "links" : [ "getDevices()", "android.media.AudioDeviceInfo" ]
  }, {
    "name" : "public int getOutputLatency(int streamType)",
    "returnType" : "int",
    "comment" : "\n     * Returns the estimated latency for the given stream type in milliseconds.\n     *\n     * DO NOT UNHIDE. The existing approach for doing A/V sync has too many problems. We need\n     * a better solution.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public void setVolumeController(IVolumeController controller)",
    "returnType" : "void",
    "comment" : "\n     * Registers a global volume controller interface.  Currently limited to SystemUI.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public void notifyVolumeControllerVisible(IVolumeController controller, boolean visible)",
    "returnType" : "void",
    "comment" : "\n     * Notify audio manager about volume controller visibility changes.\n     * Currently limited to SystemUI.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean isStreamAffectedByRingerMode(int streamType)",
    "returnType" : "boolean",
    "comment" : "\n     * Only useful for volume controllers.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean isStreamAffectedByMute(int streamType)",
    "returnType" : "boolean",
    "comment" : "\n     * Only useful for volume controllers.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public void disableSafeMediaVolume()",
    "returnType" : "void",
    "comment" : "\n     * Only useful for volume controllers.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public void setRingerModeInternal(int ringerMode)",
    "returnType" : "void",
    "comment" : "\n     * Only useful for volume controllers.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public int getRingerModeInternal()",
    "returnType" : "int",
    "comment" : "\n     * Only useful for volume controllers.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public void setVolumePolicy(VolumePolicy policy)",
    "returnType" : "void",
    "comment" : "\n     * Only useful for volume controllers.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public int setHdmiSystemAudioSupported(boolean on)",
    "returnType" : "int",
    "comment" : "\n     * Set Hdmi Cec system audio mode.\n     *\n     * @param on whether to be on system audio mode\n     * @return output device type. 0 (DEVICE_NONE) if failed to set device.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean isHdmiSystemAudioSupported()",
    "returnType" : "boolean",
    "comment" : "\n     * Returns true if Hdmi Cec system audio mode is supported.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public static int listAudioPorts(ArrayList<AudioPort> ports)",
    "returnType" : "int",
    "comment" : "\n     * Returns a list of descriptors for all audio ports managed by the audio framework.\n     * Audio ports are nodes in the audio framework or audio hardware that can be configured\n     * or connected and disconnected with createAudioPatch() or releaseAudioPatch().\n     * See AudioPort for a list of attributes of each audio port.\n     * @param ports An AudioPort ArrayList where the list will be returned.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public static int listPreviousAudioPorts(ArrayList<AudioPort> ports)",
    "returnType" : "int",
    "comment" : "\n     * Returns a list of descriptors for all audio ports managed by the audio framework as\n     * it was before the last update calback.\n     * @param ports An AudioPort ArrayList where the list will be returned.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public static int listAudioDevicePorts(ArrayList<AudioDevicePort> devices)",
    "returnType" : "int",
    "comment" : "\n     * Specialized version of listAudioPorts() listing only audio devices (AudioDevicePort)\n     * @see listAudioPorts(ArrayList<AudioPort>)\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public static int listPreviousAudioDevicePorts(ArrayList<AudioDevicePort> devices)",
    "returnType" : "int",
    "comment" : "\n     * Specialized version of listPreviousAudioPorts() listing only audio devices (AudioDevicePort)\n     * @see listPreviousAudioPorts(ArrayList<AudioPort>)\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "private static void filterDevicePorts(ArrayList<AudioPort> ports, ArrayList<AudioDevicePort> devices)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public static int createAudioPatch(AudioPatch[] patch, AudioPortConfig[] sources, AudioPortConfig[] sinks)",
    "returnType" : "int",
    "comment" : "\n     * Create a connection between two or more devices. The framework will reject the request if\n     * device types are not compatible or the implementation does not support the requested\n     * configuration.\n     * NOTE: current implementation is limited to one source and one sink per patch.\n     * @param patch AudioPatch array where the newly created patch will be returned.\n     *              As input, if patch[0] is not null, the specified patch will be replaced by the\n     *              new patch created. This avoids calling releaseAudioPatch() when modifying a\n     *              patch and allows the implementation to optimize transitions.\n     * @param sources List of source audio ports. All must be AudioPort.ROLE_SOURCE.\n     * @param sinks   List of sink audio ports. All must be AudioPort.ROLE_SINK.\n     *\n     * @return - {@link #SUCCESS} if connection is successful.\n     *         - {@link #ERROR_BAD_VALUE} if incompatible device types are passed.\n     *         - {@link #ERROR_INVALID_OPERATION} if the requested connection is not supported.\n     *         - {@link #ERROR_PERMISSION_DENIED} if the client does not have permission to create\n     *         a patch.\n     *         - {@link #ERROR_DEAD_OBJECT} if the server process is dead\n     *         - {@link #ERROR} if patch cannot be connected for any other reason.\n     *\n     *         patch[0] contains the newly created patch\n     * @hide\n     ",
    "links" : [ "#ERROR_DEAD_OBJECT", "#ERROR_PERMISSION_DENIED", "#ERROR_BAD_VALUE", "#SUCCESS", "#ERROR", "#ERROR_INVALID_OPERATION" ]
  }, {
    "name" : "public static int releaseAudioPatch(AudioPatch patch)",
    "returnType" : "int",
    "comment" : "\n     * Releases an existing audio patch connection.\n     * @param patch The audio patch to disconnect.\n     * @return - {@link #SUCCESS} if disconnection is successful.\n     *         - {@link #ERROR_BAD_VALUE} if the specified patch does not exist.\n     *         - {@link #ERROR_PERMISSION_DENIED} if the client does not have permission to release\n     *         a patch.\n     *         - {@link #ERROR_DEAD_OBJECT} if the server process is dead\n     *         - {@link #ERROR} if patch cannot be released for any other reason.\n     * @hide\n     ",
    "links" : [ "#ERROR_DEAD_OBJECT", "#ERROR_PERMISSION_DENIED", "#ERROR_BAD_VALUE", "#SUCCESS", "#ERROR" ]
  }, {
    "name" : "public static int listAudioPatches(ArrayList<AudioPatch> patches)",
    "returnType" : "int",
    "comment" : "\n     * List all existing connections between audio ports.\n     * @param patches An AudioPatch array where the list will be returned.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public static int setAudioPortGain(AudioPort port, AudioGainConfig gain)",
    "returnType" : "int",
    "comment" : "\n     * Set the gain on the specified AudioPort. The AudioGainConfig config is build by\n     * AudioGain.buildConfig()\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public void registerAudioPortUpdateListener(OnAudioPortUpdateListener l)",
    "returnType" : "void",
    "comment" : "\n     * Register an audio port list update listener.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public void unregisterAudioPortUpdateListener(OnAudioPortUpdateListener l)",
    "returnType" : "void",
    "comment" : "\n     * Unregister an audio port list update listener.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : " static int resetAudioPortGeneration()",
    "returnType" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : " static int updateAudioPortCache(ArrayList<AudioPort> ports, ArrayList<AudioPatch> patches, ArrayList<AudioPort> previousPorts)",
    "returnType" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : " static AudioPortConfig updatePortConfig(AudioPortConfig portCfg, ArrayList<AudioPort> ports)",
    "returnType" : "AudioPortConfig",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private static boolean checkFlags(AudioDevicePort port, int flags)",
    "returnType" : "boolean",
    "comment" : "\n     * Determines if a given AudioDevicePort meets the specified filter criteria.\n     * @param port  The port to test.\n     * @param flags A set of bitflags specifying the criteria to test.\n     * @see {@link GET_DEVICES_OUTPUTS} and {@link GET_DEVICES_INPUTS}\n     *",
    "links" : [ "GET_DEVICES_INPUTS", "GET_DEVICES_OUTPUTS" ]
  }, {
    "name" : "private static boolean checkTypes(AudioDevicePort port)",
    "returnType" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public AudioDeviceInfo[] getDevices(@AudioDeviceRole int flags)",
    "returnType" : "AudioDeviceInfo[]",
    "comment" : "\n     * Returns an array of {@link AudioDeviceInfo} objects corresponding to the audio devices\n     * currently connected to the system and meeting the criteria specified in the\n     * <code>flags</code> parameter.\n     * @param flags A set of bitflags specifying the criteria to test.\n     * @see #GET_DEVICES_OUTPUTS\n     * @see #GET_DEVICES_INPUTS\n     * @see #GET_DEVICES_ALL\n     * @return A (possibly zero-length) array of AudioDeviceInfo objects.\n     ",
    "links" : [ "android.media.AudioDeviceInfo" ]
  }, {
    "name" : "private static AudioDeviceInfo[] infoListFromPortList(ArrayList<AudioDevicePort> ports, int flags)",
    "returnType" : "AudioDeviceInfo[]",
    "comment" : "\n     * Does the actual computation to generate an array of (externally-visible) AudioDeviceInfo\n     * objects from the current (internal) AudioDevicePort list.\n     ",
    "links" : [ ]
  }, {
    "name" : "private static AudioDeviceInfo[] calcListDeltas(ArrayList<AudioDevicePort> ports_A, ArrayList<AudioDevicePort> ports_B, int flags)",
    "returnType" : "AudioDeviceInfo[]",
    "comment" : "\n     * Calculate the list of ports that are in ports_B, but not in ports_A. This is used by\n     * the add/remove callback mechanism to provide a list of the newly added or removed devices\n     * rather than the whole list and make the app figure it out.\n     * Note that calling this method with:\n     *  ports_A == PREVIOUS_ports and ports_B == CURRENT_ports will calculated ADDED ports.\n     *  ports_A == CURRENT_ports and ports_B == PREVIOUS_ports will calculated REMOVED ports.\n     ",
    "links" : [ ]
  }, {
    "name" : "public static AudioDeviceInfo[] getDevicesStatic(int flags)",
    "returnType" : "AudioDeviceInfo[]",
    "comment" : "\n     * Generates a list of AudioDeviceInfo objects corresponding to the audio devices currently\n     * connected to the system and meeting the criteria specified in the <code>flags</code>\n     * parameter.\n     * This is an internal function. The public API front is getDevices(int).\n     * @param flags A set of bitflags specifying the criteria to test.\n     * @see #GET_DEVICES_OUTPUTS\n     * @see #GET_DEVICES_INPUTS\n     * @see #GET_DEVICES_ALL\n     * @return A (possibly zero-length) array of AudioDeviceInfo objects.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public void registerAudioDeviceCallback(AudioDeviceCallback callback, @Nullable Handler handler)",
    "returnType" : "void",
    "comment" : "\n     * Registers an {@link AudioDeviceCallback} object to receive notifications of changes\n     * to the set of connected audio devices.\n     * @param callback The {@link AudioDeviceCallback} object to receive connect/disconnect\n     * notifications.\n     * @param handler Specifies the {@link Handler} object for the thread on which to execute\n     * the callback. If <code>null</code>, the {@link Handler} associated with the main\n     * {@link Looper} will be used.\n     ",
    "links" : [ "android.media.AudioDeviceCallback", "android.media.audiopolicy.AudioVolumeGroupChangeHandler", "android.os.Looper" ]
  }, {
    "name" : "public void unregisterAudioDeviceCallback(AudioDeviceCallback callback)",
    "returnType" : "void",
    "comment" : "\n     * Unregisters an {@link AudioDeviceCallback} object which has been previously registered\n     * to receive notifications of changes to the set of connected audio devices.\n     * @param callback The {@link AudioDeviceCallback} object that was previously registered\n     * with {@link AudioManager#registerAudioDeviceCallback} to be unregistered.\n     ",
    "links" : [ "android.media.AudioDeviceCallback", "android.media.AudioManager#registerAudioDeviceCallback" ]
  }, {
    "name" : "public static void setPortIdForMicrophones(ArrayList<MicrophoneInfo> microphones)",
    "returnType" : "void",
    "comment" : "\n     * Set port id for microphones by matching device type and address.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public static MicrophoneInfo microphoneInfoFromAudioDeviceInfo(AudioDeviceInfo deviceInfo)",
    "returnType" : "MicrophoneInfo",
    "comment" : "\n     * Convert {@link AudioDeviceInfo} to {@link MicrophoneInfo}.\n     * @hide\n     ",
    "links" : [ "android.media.MicrophoneInfo", "android.media.AudioDeviceInfo" ]
  }, {
    "name" : "private void addMicrophonesFromAudioDeviceInfo(ArrayList<MicrophoneInfo> microphones, HashSet<Integer> filterTypes)",
    "returnType" : "void",
    "comment" : "\n     * Add {@link MicrophoneInfo} by device information while filtering certain types.\n     ",
    "links" : [ "android.media.MicrophoneInfo" ]
  }, {
    "name" : "public List<MicrophoneInfo> getMicrophones() throws IOException",
    "returnType" : "List<MicrophoneInfo>",
    "comment" : "\n     * Returns a list of {@link MicrophoneInfo} that corresponds to the characteristics\n     * of all available microphones. The list is empty when no microphones are available\n     * on the device. An error during the query will result in an IOException being thrown.\n     *\n     * @return a list that contains all microphones' characteristics\n     * @throws IOException if an error occurs.\n     ",
    "links" : [ "android.media.MicrophoneInfo" ]
  }, {
    "name" : "public List<BluetoothCodecConfig> getHwOffloadEncodingFormatsSupportedForA2DP()",
    "returnType" : "List<BluetoothCodecConfig>",
    "comment" : "\n     * Returns a list of audio formats that corresponds to encoding formats\n     * supported on offload path for A2DP playback.\n     *\n     * @return a list of {@link BluetoothCodecConfig} objects containing encoding formats\n     * supported for offload A2DP playback\n     * @hide\n     ",
    "links" : [ "android.bluetooth.BluetoothCodecConfig" ]
  }, {
    "name" : "private void broadcastDeviceListChange_sync(Handler handler)",
    "returnType" : "void",
    "comment" : "\n     * Internal method to compute and generate add/remove messages and then send to any\n     * registered callbacks. Must be called synchronized on mDeviceCallbacks.\n     ",
    "links" : [ ]
  }, {
    "name" : "public void setAudioServerStateCallback(@NonNull Executor executor, @NonNull AudioServerStateCallback stateCallback)",
    "returnType" : "void",
    "comment" : "\n     * @hide\n     * Registers a callback for notification of audio server state changes.\n     * @param executor {@link Executor} to handle the callbacks\n     * @param stateCallback the callback to receive the audio server state changes\n     *        To remove the callabck, pass a null reference for both executor and stateCallback.\n     ",
    "links" : [ "android.annotation.CallbackExecutor" ]
  }, {
    "name" : "public void clearAudioServerStateCallback()",
    "returnType" : "void",
    "comment" : "\n     * @hide\n     * Unregisters the callback for notification of audio server state changes.\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean isAudioServerRunning()",
    "returnType" : "boolean",
    "comment" : "\n     * @hide\n     * Checks if native audioservice is running or not.\n     * @return true if native audioservice runs, false otherwise.\n     ",
    "links" : [ ]
  }, {
    "name" : "public Map<Integer, Boolean> getSurroundFormats()",
    "returnType" : "Map<Integer, Boolean>",
    "comment" : "\n     * @hide\n     * Returns all surround formats.\n     * @return a map where the key is a surround format and\n     * the value indicates the surround format is enabled or not\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean setSurroundFormatEnabled(@AudioFormat.SurroundSoundEncoding int audioFormat, boolean enabled)",
    "returnType" : "boolean",
    "comment" : "\n     * @hide\n     * Set a certain surround format as enabled or not.\n     * @param audioFormat a surround format, the value is one of\n     *        {@link AudioFormat#ENCODING_AC3}, {@link AudioFormat#ENCODING_E_AC3},\n     *        {@link AudioFormat#ENCODING_DTS}, {@link AudioFormat#ENCODING_DTS_HD},\n     *        {@link AudioFormat#ENCODING_AAC_LC}, {@link AudioFormat#ENCODING_DOLBY_TRUEHD},\n     *        {@link AudioFormat#ENCODING_E_AC3_JOC}. Once {@link AudioFormat#ENCODING_AAC_LC} is\n     *        set as enabled, {@link AudioFormat#ENCODING_AAC_LC},\n     *        {@link AudioFormat#ENCODING_AAC_HE_V1}, {@link AudioFormat#ENCODING_AAC_HE_V2},\n     *        {@link AudioFormat#ENCODING_AAC_ELD}, {@link AudioFormat#ENCODING_AAC_XHE} are\n     *        all enabled.\n     * @param enabled the required surround format state, true for enabled, false for disabled\n     * @return true if successful, otherwise false\n     ",
    "links" : [ "android.media.AudioFormat#ENCODING_E_AC3_JOC", "android.media.AudioFormat#ENCODING_AAC_LC", "android.media.AudioFormat#ENCODING_DTS_HD", "android.media.AudioFormat#ENCODING_AAC_HE_V2", "android.media.AudioFormat#ENCODING_AAC_HE_V1", "android.media.AudioFormat#ENCODING_DTS", "android.media.AudioFormat#ENCODING_AC3", "android.media.AudioFormat#ENCODING_AAC_ELD", "android.media.AudioFormat#ENCODING_E_AC3", "android.media.AudioFormat#ENCODING_AAC_XHE", "android.media.AudioFormat#ENCODING_DOLBY_TRUEHD" ]
  }, {
    "name" : "public Map<Integer, Boolean> getReportedSurroundFormats()",
    "returnType" : "Map<Integer, Boolean>",
    "comment" : "\n     * @hide\n     * Returns all surround formats that are reported by the connected HDMI device.\n     * The keys are not affected by calling setSurroundFormatEnabled(), and the values\n     * are not affected by calling setSurroundFormatEnabled() when in AUTO mode.\n     * This information can used to show the AUTO setting for SurroundSound.\n     *\n     * @return a map where the key is a surround format and\n     * the value indicates the surround format is enabled or not\n     ",
    "links" : [ ]
  }, {
    "name" : "public static boolean isHapticPlaybackSupported()",
    "returnType" : "boolean",
    "comment" : "\n     * Return if audio haptic coupled playback is supported or not.\n     *\n     * @return whether audio haptic playback supported.\n     ",
    "links" : [ ]
  }, {
    "name" : "public static List<AudioProductStrategy> getAudioProductStrategies()",
    "returnType" : "List<AudioProductStrategy>",
    "comment" : "\n     * @hide\n     * Introspection API to retrieve audio product strategies.\n     * When implementing {Car|Oem}AudioManager, use this method  to retrieve the collection of\n     * audio product strategies, which is indexed by a weakly typed index in order to be extended\n     * by OEM without any needs of AOSP patches.\n     * The {Car|Oem}AudioManager can expose API to build {@link AudioAttributes} for a given product\n     * strategy refered either by its index or human readable string. It will allow clients\n     * application to start streaming data using these {@link AudioAttributes} on the selected\n     * device by Audio Policy Engine.\n     * @return a (possibly zero-length) array of\n     *         {@see android.media.audiopolicy.AudioProductStrategy} objects.\n     ",
    "links" : [ "android.media.AudioAttributes" ]
  }, {
    "name" : "public static List<AudioVolumeGroup> getAudioVolumeGroups()",
    "returnType" : "List<AudioVolumeGroup>",
    "comment" : "\n     * @hide\n     * Introspection API to retrieve audio volume groups.\n     * When implementing {Car|Oem}AudioManager, use this method  to retrieve the collection of\n     * audio volume groups.\n     * @return a (possibly zero-length) List of\n     *         {@see android.media.audiopolicy.AudioVolumeGroup} objects.\n     ",
    "links" : [ ]
  }, {
    "name" : "public void registerVolumeGroupCallback(@NonNull Executor executor, @NonNull VolumeGroupCallback callback)",
    "returnType" : "void",
    "comment" : "\n    * @hide\n    * Register an audio volume group change listener.\n    * @param callback the {@link VolumeGroupCallback} to register\n    ",
    "links" : [ "VolumeGroupCallback" ]
  }, {
    "name" : "public void unregisterVolumeGroupCallback(@NonNull VolumeGroupCallback callback)",
    "returnType" : "void",
    "comment" : "\n    * @hide\n    * Unregister an audio volume group change listener.\n    * @param callback the {@link VolumeGroupCallback} to unregister\n    ",
    "links" : [ "VolumeGroupCallback" ]
  }, {
    "name" : "public static boolean hasHapticChannels(Uri uri)",
    "returnType" : "boolean",
    "comment" : "\n     * Return if an asset contains haptic channels or not.\n     * @param uri the {@link Uri} of the asset.\n     * @return true if the assert contains haptic channels.\n     * @hide\n     ",
    "links" : [ "android.net.Uri" ]
  }, {
    "name" : "public static void setRttEnabled(boolean rttEnabled)",
    "returnType" : "void",
    "comment" : "\n     * Set whether or not there is an active RTT call.\n     * This method should be called by Telecom service.\n     * @hide\n     * TODO: make this a @SystemApi\n     ",
    "links" : [ ]
  }, {
    "name" : "public void setMultiAudioFocusEnabled(boolean enabled)",
    "returnType" : "void",
    "comment" : " @hide\n     * TODO: make this a @SystemApi ",
    "links" : [ ]
  } ],
  "variableNames" : [ "mOriginalContext", "mApplicationContext", "mVolumeKeyUpTime", "mUseVolumeKeySounds", "mUseFixedVolume", "TAG", "DEBUG", "sAudioPortEventHandler", "sAudioAudioVolumeGroupChangedHandler", "ACTION_AUDIO_BECOMING_NOISY", "RINGER_MODE_CHANGED_ACTION", "INTERNAL_RINGER_MODE_CHANGED_ACTION", "EXTRA_RINGER_MODE", "VIBRATE_SETTING_CHANGED_ACTION", "VOLUME_CHANGED_ACTION", "STREAM_DEVICES_CHANGED_ACTION", "STREAM_MUTE_CHANGED_ACTION", "MASTER_MUTE_CHANGED_ACTION", "EXTRA_VIBRATE_SETTING", "EXTRA_VIBRATE_TYPE", "EXTRA_VOLUME_STREAM_TYPE", "EXTRA_VOLUME_STREAM_TYPE_ALIAS", "EXTRA_VOLUME_STREAM_VALUE", "EXTRA_PREV_VOLUME_STREAM_VALUE", "EXTRA_VOLUME_STREAM_DEVICES", "EXTRA_PREV_VOLUME_STREAM_DEVICES", "EXTRA_MASTER_VOLUME_MUTED", "EXTRA_STREAM_VOLUME_MUTED", "ACTION_HEADSET_PLUG", "ACTION_HDMI_AUDIO_PLUG", "EXTRA_AUDIO_PLUG_STATE", "EXTRA_MAX_CHANNEL_COUNT", "EXTRA_ENCODINGS", "STREAM_VOICE_CALL", "STREAM_SYSTEM", "STREAM_RING", "STREAM_MUSIC", "STREAM_ALARM", "STREAM_NOTIFICATION", "STREAM_BLUETOOTH_SCO", "STREAM_SYSTEM_ENFORCED", "STREAM_DTMF", "STREAM_TTS", "STREAM_ACCESSIBILITY", "STREAM_ASSISTANT", "NUM_STREAMS", "ADJUST_RAISE", "ADJUST_LOWER", "ADJUST_SAME", "ADJUST_MUTE", "ADJUST_UNMUTE", "ADJUST_TOGGLE_MUTE", "FLAG_SHOW_UI", "FLAG_ALLOW_RINGER_MODES", "FLAG_PLAY_SOUND", "FLAG_REMOVE_SOUND_AND_VIBRATE", "FLAG_VIBRATE", "FLAG_FIXED_VOLUME", "FLAG_BLUETOOTH_ABS_VOLUME", "FLAG_SHOW_SILENT_HINT", "FLAG_HDMI_SYSTEM_AUDIO_VOLUME", "FLAG_ACTIVE_MEDIA_ONLY", "FLAG_SHOW_UI_WARNINGS", "FLAG_SHOW_VIBRATE_HINT", "FLAG_FROM_KEY", "FLAG_NAMES", "RINGER_MODE_SILENT", "RINGER_MODE_VIBRATE", "RINGER_MODE_NORMAL", "RINGER_MODE_MAX", "VIBRATE_TYPE_RINGER", "VIBRATE_TYPE_NOTIFICATION", "VIBRATE_SETTING_OFF", "VIBRATE_SETTING_ON", "VIBRATE_SETTING_ONLY_SILENT", "USE_DEFAULT_STREAM_TYPE", "sService", "VOLUME_MIN_DB", "mPrefDevListenerLock", "mPrefDevListeners", "mPrefDevDispatcherStub", "ACTION_SCO_AUDIO_STATE_CHANGED", "ACTION_SCO_AUDIO_STATE_UPDATED", "EXTRA_SCO_AUDIO_STATE", "EXTRA_SCO_AUDIO_PREVIOUS_STATE", "SCO_AUDIO_STATE_DISCONNECTED", "SCO_AUDIO_STATE_CONNECTED", "SCO_AUDIO_STATE_CONNECTING", "SCO_AUDIO_STATE_ERROR", "ACTION_MICROPHONE_MUTE_CHANGED", "ACTION_SPEAKERPHONE_STATE_CHANGED", "MODE_INVALID", "MODE_CURRENT", "MODE_NORMAL", "MODE_RINGTONE", "MODE_IN_CALL", "MODE_IN_COMMUNICATION", "MODE_CALL_SCREENING", "ROUTE_EARPIECE", "ROUTE_SPEAKER", "ROUTE_BLUETOOTH", "ROUTE_BLUETOOTH_SCO", "ROUTE_HEADSET", "ROUTE_BLUETOOTH_A2DP", "ROUTE_ALL", "AUDIO_SESSION_ID_GENERATE", "FX_KEY_CLICK", "FX_FOCUS_NAVIGATION_UP", "FX_FOCUS_NAVIGATION_DOWN", "FX_FOCUS_NAVIGATION_LEFT", "FX_FOCUS_NAVIGATION_RIGHT", "FX_KEYPRESS_STANDARD", "FX_KEYPRESS_SPACEBAR", "FX_KEYPRESS_DELETE", "FX_KEYPRESS_RETURN", "FX_KEYPRESS_INVALID", "NUM_SOUND_EFFECTS", "AUDIOFOCUS_NONE", "AUDIOFOCUS_GAIN", "AUDIOFOCUS_GAIN_TRANSIENT", "AUDIOFOCUS_GAIN_TRANSIENT_MAY_DUCK", "AUDIOFOCUS_GAIN_TRANSIENT_EXCLUSIVE", "AUDIOFOCUS_LOSS", "AUDIOFOCUS_LOSS_TRANSIENT", "AUDIOFOCUS_LOSS_TRANSIENT_CAN_DUCK", "mAudioFocusIdListenerMap", "mServiceEventHandlerDelegate", "MSSG_FOCUS_CHANGE", "MSSG_RECORDING_CONFIG_CHANGE", "MSSG_PLAYBACK_CONFIG_CHANGE", "mAudioFocusDispatcher", "AUDIOFOCUS_REQUEST_FAILED", "AUDIOFOCUS_REQUEST_GRANTED", "AUDIOFOCUS_REQUEST_DELAYED", "AUDIOFOCUS_REQUEST_WAITING_FOR_EXT_POLICY", "EXT_FOCUS_POLICY_TIMEOUT_MS", "FOCUS_CLIENT_ID_STRING", "mFocusRequestsLock", "mFocusRequestsAwaitingResult", "AUDIOFOCUS_FLAG_DELAY_OK", "AUDIOFOCUS_FLAG_PAUSES_ON_DUCKABLE_LOSS", "AUDIOFOCUS_FLAG_LOCK", "AUDIOFOCUS_FLAGS_APPS", "AUDIOFOCUS_FLAGS_SYSTEM", "mPlaybackCallbackList", "mPlaybackCallbackLock", "mPlayCb", "RECORD_CONFIG_EVENT_NONE", "RECORD_CONFIG_EVENT_START", "RECORD_CONFIG_EVENT_STOP", "RECORD_CONFIG_EVENT_UPDATE", "RECORD_CONFIG_EVENT_RELEASE", "RECORD_RIID_INVALID", "RECORDER_STATE_STARTED", "RECORDER_STATE_STOPPED", "mRecordCallbackList", "mRecordCallbackLock", "mRecCb", "mICallBack", "DEVICE_NONE", "DEVICE_OUT_EARPIECE", "DEVICE_OUT_SPEAKER", "DEVICE_OUT_WIRED_HEADSET", "DEVICE_OUT_WIRED_HEADPHONE", "DEVICE_OUT_USB_HEADSET", "DEVICE_OUT_BLUETOOTH_SCO", "DEVICE_OUT_BLUETOOTH_SCO_HEADSET", "DEVICE_OUT_BLUETOOTH_SCO_CARKIT", "DEVICE_OUT_BLUETOOTH_A2DP", "DEVICE_OUT_BLUETOOTH_A2DP_HEADPHONES", "DEVICE_OUT_BLUETOOTH_A2DP_SPEAKER", "DEVICE_OUT_AUX_DIGITAL", "DEVICE_OUT_HDMI", "DEVICE_OUT_ANLG_DOCK_HEADSET", "DEVICE_OUT_DGTL_DOCK_HEADSET", "DEVICE_OUT_USB_ACCESSORY", "DEVICE_OUT_USB_DEVICE", "DEVICE_OUT_REMOTE_SUBMIX", "DEVICE_OUT_TELEPHONY_TX", "DEVICE_OUT_LINE", "DEVICE_OUT_HDMI_ARC", "DEVICE_OUT_SPDIF", "DEVICE_OUT_FM", "DEVICE_OUT_DEFAULT", "DEVICE_IN_BUILTIN_MIC", "DEVICE_IN_BLUETOOTH_SCO_HEADSET", "DEVICE_IN_WIRED_HEADSET", "DEVICE_IN_HDMI", "DEVICE_IN_HDMI_ARC", "DEVICE_IN_TELEPHONY_RX", "DEVICE_IN_BACK_MIC", "DEVICE_IN_ANLG_DOCK_HEADSET", "DEVICE_IN_DGTL_DOCK_HEADSET", "DEVICE_IN_USB_ACCESSORY", "DEVICE_IN_USB_DEVICE", "DEVICE_IN_FM_TUNER", "DEVICE_IN_TV_TUNER", "DEVICE_IN_LINE", "DEVICE_IN_SPDIF", "DEVICE_IN_LOOPBACK", "DEVICE_VOLUME_BEHAVIOR_UNSET", "DEVICE_VOLUME_BEHAVIOR_VARIABLE", "DEVICE_VOLUME_BEHAVIOR_FULL", "DEVICE_VOLUME_BEHAVIOR_FIXED", "DEVICE_VOLUME_BEHAVIOR_ABSOLUTE", "DEVICE_VOLUME_BEHAVIOR_ABSOLUTE_MULTI_MODE", "PROPERTY_OUTPUT_SAMPLE_RATE", "PROPERTY_OUTPUT_FRAMES_PER_BUFFER", "PROPERTY_SUPPORT_MIC_NEAR_ULTRASOUND", "PROPERTY_SUPPORT_SPEAKER_NEAR_ULTRASOUND", "PROPERTY_SUPPORT_AUDIO_SOURCE_UNPROCESSED", "SUCCESS", "ERROR", "ERROR_BAD_VALUE", "ERROR_INVALID_OPERATION", "ERROR_PERMISSION_DENIED", "ERROR_NO_INIT", "ERROR_DEAD_OBJECT", "AUDIOPORT_GENERATION_INIT", "sAudioPortGeneration", "sAudioPortsCached", "sPreviousAudioPortsCached", "sAudioPatchesCached", "mPortListener", "MSG_DEVICES_CALLBACK_REGISTERED", "MSG_DEVICES_DEVICES_ADDED", "MSG_DEVICES_DEVICES_REMOVED", "mDeviceCallbacks", "GET_DEVICES_INPUTS", "GET_DEVICES_OUTPUTS", "GET_DEVICES_ALL", "mPreviousPorts", "mAudioServerStateExec", "mAudioServerStateCb", "mAudioServerStateCbLock", "mAudioServerStateDispatcher" ],
  "methodNames" : [ "public static final String adjustToString(int adj)", "public static String flagsToString(int flags)", "private Context getContext()", "private void setContext(Context context)", "private static IAudioService getService()", "public void dispatchMediaKeyEvent(KeyEvent keyEvent)", "public void preDispatchKeyEvent(KeyEvent event, int stream)", "public boolean isVolumeFixed()", "public void adjustStreamVolume(int streamType, int direction, int flags)", "public void adjustVolume(int direction, int flags)", "public void adjustSuggestedStreamVolume(int direction, int suggestedStreamType, int flags)", "public void setMasterMute(boolean mute, int flags)", "public int getRingerMode()", "public static boolean isValidRingerMode(int ringerMode)", "public int getStreamMaxVolume(int streamType)", "public int getStreamMinVolume(int streamType)", "public int getStreamMinVolumeInt(int streamType)", "public int getStreamVolume(int streamType)", "public float getStreamVolumeDb(@PublicStreamTypes int streamType, int index, @AudioDeviceInfo.AudioDeviceTypeOut int deviceType)", "private static boolean isPublicStreamType(int streamType)", "public int getLastAudibleStreamVolume(int streamType)", "public int getUiSoundsStreamType()", "public void setRingerMode(int ringerMode)", "public void setStreamVolume(int streamType, int index, int flags)", "public void setVolumeIndexForAttributes(@NonNull AudioAttributes attr, int index, int flags)", "public int getVolumeIndexForAttributes(@NonNull AudioAttributes attr)", "public int getMaxVolumeIndexForAttributes(@NonNull AudioAttributes attr)", "public int getMinVolumeIndexForAttributes(@NonNull AudioAttributes attr)", "public void setSupportedSystemUsages(@NonNull @AttributeSystemUsage int[] systemUsages)", "public int[] getSupportedSystemUsages()", "public void setStreamSolo(int streamType, boolean state)", "public void setStreamMute(int streamType, boolean state)", "public boolean isStreamMute(int streamType)", "public boolean isMasterMute()", "public void forceVolumeControlStream(int streamType)", "public boolean shouldVibrate(int vibrateType)", "public int getVibrateSetting(int vibrateType)", "public void setVibrateSetting(int vibrateType, int vibrateSetting)", "public void setSpeakerphoneOn(boolean on)", "public boolean isSpeakerphoneOn()", "public void setAllowedCapturePolicy(@AudioAttributes.CapturePolicy int capturePolicy)", "public int getAllowedCapturePolicy()", "public boolean setPreferredDeviceForStrategy(@NonNull AudioProductStrategy strategy, @NonNull AudioDeviceAttributes device)", "public boolean removePreferredDeviceForStrategy(@NonNull AudioProductStrategy strategy)", "public AudioDeviceAttributes getPreferredDeviceForStrategy(@NonNull AudioProductStrategy strategy)", "public void addOnPreferredDeviceForStrategyChangedListener(@NonNull @CallbackExecutor Executor executor, @NonNull OnPreferredDeviceForStrategyChangedListener listener) throws SecurityException", "public void removeOnPreferredDeviceForStrategyChangedListener(@NonNull OnPreferredDeviceForStrategyChangedListener listener)", "private PrefDevListenerInfo getPrefDevListenerInfo(OnPreferredDeviceForStrategyChangedListener listener)", "private boolean hasPrefDevListener(OnPreferredDeviceForStrategyChangedListener listener)", "private boolean removePrefDevListener(OnPreferredDeviceForStrategyChangedListener listener)", "public static boolean isOffloadedPlaybackSupported(@NonNull AudioFormat format, @NonNull AudioAttributes attributes)", "public boolean isBluetoothScoAvailableOffCall()", "public void startBluetoothSco()", "public void startBluetoothScoVirtualCall()", "public void stopBluetoothSco()", "public void setBluetoothScoOn(boolean on)", "public boolean isBluetoothScoOn()", "public void setBluetoothA2dpOn(boolean on)", "public boolean isBluetoothA2dpOn()", "public void setWiredHeadsetOn(boolean on)", "public boolean isWiredHeadsetOn()", "public void setMicrophoneMute(boolean on)", "public void setMicrophoneMuteFromSwitch(boolean on)", "public boolean isMicrophoneMute()", "public void setMode(@AudioMode int mode)", "public int getMode()", "public boolean isCallScreeningModeSupported()", "public void setRouting(int mode, int routes, int mask)", "public int getRouting(int mode)", "public boolean isMusicActive()", "public boolean isMusicActiveRemotely()", "public boolean isAudioFocusExclusive()", "public int generateAudioSessionId()", "public void setParameter(String key, String value)", "public void setParameters(String keyValuePairs)", "public String getParameters(String keys)", "public void playSoundEffect(int effectType)", "public void playSoundEffect(int effectType, int userId)", "public void playSoundEffect(int effectType, float volume)", "private boolean querySoundEffectsEnabled(int user)", "public void loadSoundEffects()", "public void unloadSoundEffects()", "public static String audioFocusToString(int focus)", "private FocusRequestInfo findFocusRequestInfo(String id)", "private String getIdForAudioFocusListener(OnAudioFocusChangeListener l)", "public void registerAudioFocusRequest(@NonNull AudioFocusRequest afr)", "public void unregisterAudioFocusRequest(OnAudioFocusChangeListener l)", "public int requestAudioFocus(OnAudioFocusChangeListener l, int streamType, int durationHint)", "public int requestAudioFocus(@NonNull AudioFocusRequest focusRequest)", "public int abandonAudioFocusRequest(@NonNull AudioFocusRequest focusRequest)", "public int requestAudioFocus(OnAudioFocusChangeListener l, @NonNull AudioAttributes requestAttributes, int durationHint, int flags) throws IllegalArgumentException", "public int requestAudioFocus(OnAudioFocusChangeListener l, @NonNull AudioAttributes requestAttributes, int durationHint, int flags, AudioPolicy ap) throws IllegalArgumentException", "public int requestAudioFocus(@NonNull AudioFocusRequest afr, @Nullable AudioPolicy ap)", "public void requestAudioFocusForCall(int streamType, int durationHint)", "public int getFocusRampTimeMs(int focusGain, AudioAttributes attr)", "public void setFocusRequestResult(@NonNull AudioFocusInfo afi, @FocusRequestResult int requestResult, @NonNull AudioPolicy ap)", "public int dispatchAudioFocusChange(@NonNull AudioFocusInfo afi, int focusChange, @NonNull AudioPolicy ap)", "public void abandonAudioFocusForCall()", "public int abandonAudioFocus(OnAudioFocusChangeListener l)", "public int abandonAudioFocus(OnAudioFocusChangeListener l, AudioAttributes aa)", "public void registerMediaButtonEventReceiver(ComponentName eventReceiver)", "public void registerMediaButtonEventReceiver(PendingIntent eventReceiver)", "public void registerMediaButtonIntent(PendingIntent pi, ComponentName eventReceiver)", "public void unregisterMediaButtonEventReceiver(ComponentName eventReceiver)", "public void unregisterMediaButtonEventReceiver(PendingIntent eventReceiver)", "public void unregisterMediaButtonIntent(PendingIntent pi)", "public void registerRemoteControlClient(RemoteControlClient rcClient)", "public void unregisterRemoteControlClient(RemoteControlClient rcClient)", "public boolean registerRemoteController(RemoteController rctlr)", "public void unregisterRemoteController(RemoteController rctlr)", "public int registerAudioPolicy(@NonNull AudioPolicy policy)", " static int registerAudioPolicyStatic(@NonNull AudioPolicy policy)", "public void unregisterAudioPolicyAsync(@NonNull AudioPolicy policy)", " static void unregisterAudioPolicyAsyncStatic(@NonNull AudioPolicy policy)", "public void unregisterAudioPolicy(@NonNull AudioPolicy policy)", "public boolean hasRegisteredDynamicPolicy()", "public void registerAudioPlaybackCallback(@NonNull AudioPlaybackCallback cb, @Nullable Handler handler)", "public void unregisterAudioPlaybackCallback(@NonNull AudioPlaybackCallback cb)", "public List<AudioPlaybackConfiguration> getActivePlaybackConfigurations()", "private boolean hasPlaybackCallback_sync(@NonNull AudioPlaybackCallback cb)", "private boolean removePlaybackCallback_sync(@NonNull AudioPlaybackCallback cb)", "public void registerAudioRecordingCallback(@NonNull AudioRecordingCallback cb, @Nullable Handler handler)", "public void unregisterAudioRecordingCallback(@NonNull AudioRecordingCallback cb)", "public List<AudioRecordingConfiguration> getActiveRecordingConfigurations()", "private boolean hasRecordCallback_sync(@NonNull AudioRecordingCallback cb)", "private boolean removeRecordCallback_sync(@NonNull AudioRecordingCallback cb)", "public void reloadAudioSettings()", "public void avrcpSupportsAbsoluteVolume(String address, boolean support)", "public boolean isSilentMode()", "public static boolean isOutputDevice(int device)", "public static boolean isInputDevice(int device)", "public int getDevicesForStream(int streamType)", "public List<AudioDeviceAttributes> getDevicesForAttributes(@NonNull AudioAttributes attributes)", "public static void enforceValidVolumeBehavior(int volumeBehavior)", "public void setDeviceVolumeBehavior(int deviceType, @Nullable String deviceAddress, @DeviceVolumeBehavior int deviceVolumeBehavior)", "public void setDeviceVolumeBehavior(@NonNull AudioDeviceAttributes device, @DeviceVolumeBehavior int deviceVolumeBehavior)", "public int getDeviceVolumeBehavior(int deviceType, @Nullable String deviceAddress)", "public int getDeviceVolumeBehavior(@NonNull AudioDeviceAttributes device)", "public void setWiredDeviceConnectionState(int type, int state, String address, String name)", "public void setBluetoothHearingAidDeviceConnectionState(BluetoothDevice device, int state, boolean suppressNoisyIntent, int musicDevice)", "public void setBluetoothA2dpDeviceConnectionStateSuppressNoisyIntent(BluetoothDevice device, int state, int profile, boolean suppressNoisyIntent, int a2dpVolume)", "public void handleBluetoothA2dpDeviceConfigChange(BluetoothDevice device)", "public IRingtonePlayer getRingtonePlayer()", "public String getProperty(String key)", "public boolean setAdditionalOutputDeviceDelay(@NonNull AudioDeviceInfo device, @IntRange(from = 0) long delayMillis)", "public long getAdditionalOutputDeviceDelay(@NonNull AudioDeviceInfo device)", "public long getMaxAdditionalOutputDeviceDelay(@NonNull AudioDeviceInfo device)", "public int getOutputLatency(int streamType)", "public void setVolumeController(IVolumeController controller)", "public void notifyVolumeControllerVisible(IVolumeController controller, boolean visible)", "public boolean isStreamAffectedByRingerMode(int streamType)", "public boolean isStreamAffectedByMute(int streamType)", "public void disableSafeMediaVolume()", "public void setRingerModeInternal(int ringerMode)", "public int getRingerModeInternal()", "public void setVolumePolicy(VolumePolicy policy)", "public int setHdmiSystemAudioSupported(boolean on)", "public boolean isHdmiSystemAudioSupported()", "public static int listAudioPorts(ArrayList<AudioPort> ports)", "public static int listPreviousAudioPorts(ArrayList<AudioPort> ports)", "public static int listAudioDevicePorts(ArrayList<AudioDevicePort> devices)", "public static int listPreviousAudioDevicePorts(ArrayList<AudioDevicePort> devices)", "private static void filterDevicePorts(ArrayList<AudioPort> ports, ArrayList<AudioDevicePort> devices)", "public static int createAudioPatch(AudioPatch[] patch, AudioPortConfig[] sources, AudioPortConfig[] sinks)", "public static int releaseAudioPatch(AudioPatch patch)", "public static int listAudioPatches(ArrayList<AudioPatch> patches)", "public static int setAudioPortGain(AudioPort port, AudioGainConfig gain)", "public void registerAudioPortUpdateListener(OnAudioPortUpdateListener l)", "public void unregisterAudioPortUpdateListener(OnAudioPortUpdateListener l)", " static int resetAudioPortGeneration()", " static int updateAudioPortCache(ArrayList<AudioPort> ports, ArrayList<AudioPatch> patches, ArrayList<AudioPort> previousPorts)", " static AudioPortConfig updatePortConfig(AudioPortConfig portCfg, ArrayList<AudioPort> ports)", "private static boolean checkFlags(AudioDevicePort port, int flags)", "private static boolean checkTypes(AudioDevicePort port)", "public AudioDeviceInfo[] getDevices(@AudioDeviceRole int flags)", "private static AudioDeviceInfo[] infoListFromPortList(ArrayList<AudioDevicePort> ports, int flags)", "private static AudioDeviceInfo[] calcListDeltas(ArrayList<AudioDevicePort> ports_A, ArrayList<AudioDevicePort> ports_B, int flags)", "public static AudioDeviceInfo[] getDevicesStatic(int flags)", "public void registerAudioDeviceCallback(AudioDeviceCallback callback, @Nullable Handler handler)", "public void unregisterAudioDeviceCallback(AudioDeviceCallback callback)", "public static void setPortIdForMicrophones(ArrayList<MicrophoneInfo> microphones)", "public static MicrophoneInfo microphoneInfoFromAudioDeviceInfo(AudioDeviceInfo deviceInfo)", "private void addMicrophonesFromAudioDeviceInfo(ArrayList<MicrophoneInfo> microphones, HashSet<Integer> filterTypes)", "public List<MicrophoneInfo> getMicrophones() throws IOException", "public List<BluetoothCodecConfig> getHwOffloadEncodingFormatsSupportedForA2DP()", "private void broadcastDeviceListChange_sync(Handler handler)", "public void setAudioServerStateCallback(@NonNull Executor executor, @NonNull AudioServerStateCallback stateCallback)", "public void clearAudioServerStateCallback()", "public boolean isAudioServerRunning()", "public Map<Integer, Boolean> getSurroundFormats()", "public boolean setSurroundFormatEnabled(@AudioFormat.SurroundSoundEncoding int audioFormat, boolean enabled)", "public Map<Integer, Boolean> getReportedSurroundFormats()", "public static boolean isHapticPlaybackSupported()", "public static List<AudioProductStrategy> getAudioProductStrategies()", "public static List<AudioVolumeGroup> getAudioVolumeGroups()", "public void registerVolumeGroupCallback(@NonNull Executor executor, @NonNull VolumeGroupCallback callback)", "public void unregisterVolumeGroupCallback(@NonNull VolumeGroupCallback callback)", "public static boolean hasHapticChannels(Uri uri)", "public static void setRttEnabled(boolean rttEnabled)", "public void setMultiAudioFocusEnabled(boolean enabled)" ]
}