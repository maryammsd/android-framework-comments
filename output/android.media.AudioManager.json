{
  "filePath" : "/home/maryam/clearblue/files/android-source-35/android/media/AudioManager.java",
  "packageName" : "android.media",
  "className" : "AudioManager",
  "comment" : "\n * AudioManager provides access to volume and ringer mode control.\n ",
  "links" : [ ],
  "variables" : [ {
    "name" : "mOriginalContext",
    "type" : "Context",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mApplicationContext",
    "type" : "Context",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mOriginalContextDeviceId",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mVirtualDeviceManager",
    "type" : "VirtualDeviceManager",
    "comment" : " Lazy initialized.",
    "links" : [ ]
  }, {
    "name" : "TAG",
    "type" : "String",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "DEBUG",
    "type" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "sAudioPortEventHandler",
    "type" : "AudioPortEventHandler",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "sAudioAudioVolumeGroupChangedHandler",
    "type" : "AudioVolumeGroupChangeHandler",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "sContext",
    "type" : "WeakReference<Context>",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "ACTION_AUDIO_BECOMING_NOISY",
    "type" : "String",
    "comment" : "\n     * Broadcast intent, a hint for applications that audio is about to become\n     * 'noisy' due to a change in audio outputs. For example, this intent may\n     * be sent when a wired headset is unplugged, or when an A2DP audio\n     * sink is disconnected, and the audio system is about to automatically\n     * switch audio route to the speaker. Applications that are controlling\n     * audio streams may consider pausing, reducing volume or some other action\n     * on receipt of this intent so as not to surprise the user with audio\n     * from the speaker.\n     ",
    "links" : [ ]
  }, {
    "name" : "RINGER_MODE_CHANGED_ACTION",
    "type" : "String",
    "comment" : "\n     * Sticky broadcast intent action indicating that the ringer mode has\n     * changed. Includes the new ringer mode.\n     *\n     * @see #EXTRA_RINGER_MODE\n     ",
    "links" : [ ]
  }, {
    "name" : "INTERNAL_RINGER_MODE_CHANGED_ACTION",
    "type" : "String",
    "comment" : "\n     * @hide\n     * Sticky broadcast intent action indicating that the internal ringer mode has\n     * changed. Includes the new ringer mode.\n     *\n     * @see #EXTRA_RINGER_MODE\n     ",
    "links" : [ ]
  }, {
    "name" : "EXTRA_RINGER_MODE",
    "type" : "String",
    "comment" : "\n     * The new ringer mode.\n     *\n     * @see #RINGER_MODE_CHANGED_ACTION\n     * @see #RINGER_MODE_NORMAL\n     * @see #RINGER_MODE_SILENT\n     * @see #RINGER_MODE_VIBRATE\n     ",
    "links" : [ ]
  }, {
    "name" : "VIBRATE_SETTING_CHANGED_ACTION",
    "type" : "String",
    "comment" : "\n     * Broadcast intent action indicating that the vibrate setting has\n     * changed. Includes the vibrate type and its new setting.\n     *\n     * @see #EXTRA_VIBRATE_TYPE\n     * @see #EXTRA_VIBRATE_SETTING\n     * @deprecated Applications should maintain their own vibrate policy based on\n     * current ringer mode and listen to {@link #RINGER_MODE_CHANGED_ACTION} instead.\n     ",
    "links" : [ "#RINGER_MODE_CHANGED_ACTION" ]
  }, {
    "name" : "VOLUME_CHANGED_ACTION",
    "type" : "String",
    "comment" : "\n     * @hide Broadcast intent when the volume for a particular stream type changes.\n     * Includes the stream, the new volume and previous volumes.\n     * Notes:\n     *  - for internal platform use only, do not make public,\n     *  - never used for \"remote\" volume changes\n     *\n     * @see #EXTRA_VOLUME_STREAM_TYPE\n     * @see #EXTRA_VOLUME_STREAM_VALUE\n     * @see #EXTRA_PREV_VOLUME_STREAM_VALUE\n     ",
    "links" : [ ]
  }, {
    "name" : "ACTION_VOLUME_CHANGED",
    "type" : "String",
    "comment" : "\n     * @hide Broadcast intent when the volume for a particular stream type changes.\n     * Includes the stream, the new volume and previous volumes.\n     * Notes:\n     *  - for internal platform use only, do not make public,\n     *  - never used for \"remote\" volume changes\n     *\n     * @see #EXTRA_VOLUME_STREAM_TYPE\n     * @see #EXTRA_VOLUME_STREAM_VALUE\n     * @see #EXTRA_PREV_VOLUME_STREAM_VALUE\n     ",
    "links" : [ ]
  }, {
    "name" : "STREAM_DEVICES_CHANGED_ACTION",
    "type" : "String",
    "comment" : "\n     * @hide Broadcast intent when the devices for a particular stream type changes.\n     * Includes the stream, the new devices and previous devices.\n     * Notes:\n     *  - for internal platform use only, do not make public,\n     *  - never used for \"remote\" volume changes\n     *\n     * @see #EXTRA_VOLUME_STREAM_TYPE\n     * @see #EXTRA_VOLUME_STREAM_DEVICES\n     * @see #EXTRA_PREV_VOLUME_STREAM_DEVICES\n     * @see #getDevicesForStream\n     ",
    "links" : [ ]
  }, {
    "name" : "STREAM_MUTE_CHANGED_ACTION",
    "type" : "String",
    "comment" : "\n     * @hide Broadcast intent when a stream mute state changes.\n     * Includes the stream that changed and the new mute state\n     *\n     * @see #EXTRA_VOLUME_STREAM_TYPE\n     * @see #EXTRA_STREAM_VOLUME_MUTED\n     ",
    "links" : [ ]
  }, {
    "name" : "MASTER_MUTE_CHANGED_ACTION",
    "type" : "String",
    "comment" : "\n     * @hide Broadcast intent when the master mute state changes.\n     * Includes the the new volume\n     *\n     * @see #EXTRA_MASTER_VOLUME_MUTED\n     ",
    "links" : [ ]
  }, {
    "name" : "EXTRA_VIBRATE_SETTING",
    "type" : "String",
    "comment" : "\n     * The new vibrate setting for a particular type.\n     *\n     * @see #VIBRATE_SETTING_CHANGED_ACTION\n     * @see #EXTRA_VIBRATE_TYPE\n     * @see #VIBRATE_SETTING_ON\n     * @see #VIBRATE_SETTING_OFF\n     * @see #VIBRATE_SETTING_ONLY_SILENT\n     * @deprecated Applications should maintain their own vibrate policy based on\n     * current ringer mode and listen to {@link #RINGER_MODE_CHANGED_ACTION} instead.\n     ",
    "links" : [ "#RINGER_MODE_CHANGED_ACTION" ]
  }, {
    "name" : "EXTRA_VIBRATE_TYPE",
    "type" : "String",
    "comment" : "\n     * The vibrate type whose setting has changed.\n     *\n     * @see #VIBRATE_SETTING_CHANGED_ACTION\n     * @see #VIBRATE_TYPE_NOTIFICATION\n     * @see #VIBRATE_TYPE_RINGER\n     * @deprecated Applications should maintain their own vibrate policy based on\n     * current ringer mode and listen to {@link #RINGER_MODE_CHANGED_ACTION} instead.\n     ",
    "links" : [ "#RINGER_MODE_CHANGED_ACTION" ]
  }, {
    "name" : "EXTRA_VOLUME_STREAM_TYPE",
    "type" : "String",
    "comment" : "\n     * @hide The stream type for the volume changed intent.\n     ",
    "links" : [ ]
  }, {
    "name" : "EXTRA_VOLUME_STREAM_TYPE_ALIAS",
    "type" : "String",
    "comment" : "\n     * @hide\n     * The stream type alias for the volume changed intent.\n     * For instance the intent may indicate a change of the {@link #STREAM_NOTIFICATION} stream\n     * type (as indicated by the {@link #EXTRA_VOLUME_STREAM_TYPE} extra), but this is also\n     * reflected by a change of the volume of its alias, {@link #STREAM_RING} on some devices,\n     * {@link #STREAM_MUSIC} on others (e.g. a television).\n     ",
    "links" : [ "#EXTRA_VOLUME_STREAM_TYPE", "#STREAM_MUSIC", "#STREAM_RING", "#STREAM_NOTIFICATION" ]
  }, {
    "name" : "EXTRA_VOLUME_STREAM_VALUE",
    "type" : "String",
    "comment" : "\n     * @hide The volume associated with the stream for the volume changed intent.\n     ",
    "links" : [ ]
  }, {
    "name" : "EXTRA_PREV_VOLUME_STREAM_VALUE",
    "type" : "String",
    "comment" : "\n     * @hide The previous volume associated with the stream for the volume changed intent.\n     ",
    "links" : [ ]
  }, {
    "name" : "EXTRA_VOLUME_STREAM_DEVICES",
    "type" : "String",
    "comment" : "\n     * @hide The devices associated with the stream for the stream devices changed intent.\n     ",
    "links" : [ ]
  }, {
    "name" : "EXTRA_PREV_VOLUME_STREAM_DEVICES",
    "type" : "String",
    "comment" : "\n     * @hide The previous devices associated with the stream for the stream devices changed intent.\n     ",
    "links" : [ ]
  }, {
    "name" : "EXTRA_MASTER_VOLUME_MUTED",
    "type" : "String",
    "comment" : "\n     * @hide The new master volume mute state for the master mute changed intent.\n     * Value is boolean\n     ",
    "links" : [ ]
  }, {
    "name" : "EXTRA_STREAM_VOLUME_MUTED",
    "type" : "String",
    "comment" : "\n     * @hide The new stream volume mute state for the stream mute changed intent.\n     * Value is boolean\n     ",
    "links" : [ ]
  }, {
    "name" : "ACTION_HEADSET_PLUG",
    "type" : "String",
    "comment" : "\n     * Broadcast Action: Wired Headset plugged in or unplugged.\n     *\n     * You <em>cannot</em> receive this through components declared\n     * in manifests, only by explicitly registering for it with\n     * {@link Context#registerReceiver(BroadcastReceiver, IntentFilter)\n     * Context.registerReceiver()}.\n     *\n     * <p>The intent will have the following extra values:\n     * <ul>\n     *   <li><em>state</em> - 0 for unplugged, 1 for plugged. </li>\n     *   <li><em>name</em> - Headset type, human readable string </li>\n     *   <li><em>microphone</em> - 1 if headset has a microphone, 0 otherwise </li>\n     * </ul>\n     * </ul>\n     ",
    "links" : [ "android.content.Context#registerReceiver(BroadcastReceiver" ]
  }, {
    "name" : "ACTION_HDMI_AUDIO_PLUG",
    "type" : "String",
    "comment" : "\n     * Broadcast Action: A sticky broadcast indicating an HDMI cable was plugged or unplugged.\n     *\n     * The intent will have the following extra values: {@link #EXTRA_AUDIO_PLUG_STATE},\n     * {@link #EXTRA_MAX_CHANNEL_COUNT}, {@link #EXTRA_ENCODINGS}.\n     * <p>It can only be received by explicitly registering for it with\n     * {@link Context#registerReceiver(BroadcastReceiver, IntentFilter)}.\n     ",
    "links" : [ "#EXTRA_AUDIO_PLUG_STATE", "#EXTRA_ENCODINGS", "#EXTRA_MAX_CHANNEL_COUNT", "android.content.Context#registerReceiver(BroadcastReceiver" ]
  }, {
    "name" : "EXTRA_AUDIO_PLUG_STATE",
    "type" : "String",
    "comment" : "\n     * Extra used in {@link #ACTION_HDMI_AUDIO_PLUG} to communicate whether HDMI is plugged in\n     * or unplugged.\n     * An integer value of 1 indicates a plugged-in state, 0 is unplugged.\n     ",
    "links" : [ "#ACTION_HDMI_AUDIO_PLUG" ]
  }, {
    "name" : "EXTRA_MAX_CHANNEL_COUNT",
    "type" : "String",
    "comment" : "\n     * Extra used in {@link #ACTION_HDMI_AUDIO_PLUG} to define the maximum number of channels\n     * supported by the HDMI device.\n     * The corresponding integer value is only available when the device is plugged in (as expressed\n     * by {@link #EXTRA_AUDIO_PLUG_STATE}).\n     ",
    "links" : [ "#EXTRA_AUDIO_PLUG_STATE", "#ACTION_HDMI_AUDIO_PLUG" ]
  }, {
    "name" : "EXTRA_ENCODINGS",
    "type" : "String",
    "comment" : "\n     * Extra used in {@link #ACTION_HDMI_AUDIO_PLUG} to define the audio encodings supported by\n     * the connected HDMI device.\n     * The corresponding array of encoding values is only available when the device is plugged in\n     * (as expressed by {@link #EXTRA_AUDIO_PLUG_STATE}). Encoding values are defined in\n     * {@link AudioFormat} (for instance see {@link AudioFormat#ENCODING_PCM_16BIT}). Use\n     * {@link android.content.Intent#getIntArrayExtra(String)} to retrieve the encoding values.\n     ",
    "links" : [ "#EXTRA_AUDIO_PLUG_STATE", "#ACTION_HDMI_AUDIO_PLUG", "android.media.AudioFormat", "android.content.Intent#getIntArrayExtra(String)", "android.media.AudioFormat#ENCODING_PCM_16BIT" ]
  }, {
    "name" : "STREAM_VOICE_CALL",
    "type" : "int",
    "comment" : " Used to identify the volume of audio streams for phone calls ",
    "links" : [ ]
  }, {
    "name" : "STREAM_SYSTEM",
    "type" : "int",
    "comment" : " Used to identify the volume of audio streams for system sounds ",
    "links" : [ ]
  }, {
    "name" : "STREAM_RING",
    "type" : "int",
    "comment" : " Used to identify the volume of audio streams for the phone ring ",
    "links" : [ ]
  }, {
    "name" : "STREAM_MUSIC",
    "type" : "int",
    "comment" : " Used to identify the volume of audio streams for music playback ",
    "links" : [ ]
  }, {
    "name" : "STREAM_ALARM",
    "type" : "int",
    "comment" : " Used to identify the volume of audio streams for alarms ",
    "links" : [ ]
  }, {
    "name" : "STREAM_NOTIFICATION",
    "type" : "int",
    "comment" : " Used to identify the volume of audio streams for notifications ",
    "links" : [ ]
  }, {
    "name" : "STREAM_BLUETOOTH_SCO",
    "type" : "int",
    "comment" : " @hide Used to identify the volume of audio streams for phone calls when connected\n     *        to bluetooth ",
    "links" : [ ]
  }, {
    "name" : "STREAM_SYSTEM_ENFORCED",
    "type" : "int",
    "comment" : " @hide Used to identify the volume of audio streams for enforced system sounds\n     *        in certain countries (e.g camera in Japan) ",
    "links" : [ ]
  }, {
    "name" : "STREAM_DTMF",
    "type" : "int",
    "comment" : " Used to identify the volume of audio streams for DTMF Tones ",
    "links" : [ ]
  }, {
    "name" : "STREAM_TTS",
    "type" : "int",
    "comment" : " @hide Used to identify the volume of audio streams exclusively transmitted through the\n     *        speaker (TTS) of the device ",
    "links" : [ ]
  }, {
    "name" : "STREAM_ACCESSIBILITY",
    "type" : "int",
    "comment" : " Used to identify the volume of audio streams for accessibility prompts ",
    "links" : [ ]
  }, {
    "name" : "STREAM_ASSISTANT",
    "type" : "int",
    "comment" : " @hide Used to identify the volume of audio streams for virtual assistant ",
    "links" : [ ]
  }, {
    "name" : "NUM_STREAMS",
    "type" : "int",
    "comment" : "\n     * @deprecated Do not iterate on volume stream type values.\n     ",
    "links" : [ ]
  }, {
    "name" : "PUBLIC_STREAM_TYPES",
    "type" : "int[]",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "ADJUST_RAISE",
    "type" : "int",
    "comment" : "\n     * Increase the ringer volume.\n     *\n     * @see #adjustVolume(int, int)\n     * @see #adjustStreamVolume(int, int, int)\n     ",
    "links" : [ ]
  }, {
    "name" : "ADJUST_LOWER",
    "type" : "int",
    "comment" : "\n     * Decrease the ringer volume.\n     *\n     * @see #adjustVolume(int, int)\n     * @see #adjustStreamVolume(int, int, int)\n     ",
    "links" : [ ]
  }, {
    "name" : "ADJUST_SAME",
    "type" : "int",
    "comment" : "\n     * Maintain the previous ringer volume. This may be useful when needing to\n     * show the volume toast without actually modifying the volume.\n     *\n     * @see #adjustVolume(int, int)\n     * @see #adjustStreamVolume(int, int, int)\n     ",
    "links" : [ ]
  }, {
    "name" : "ADJUST_MUTE",
    "type" : "int",
    "comment" : "\n     * Mute the volume. Has no effect if the stream is already muted.\n     *\n     * @see #adjustVolume(int, int)\n     * @see #adjustStreamVolume(int, int, int)\n     ",
    "links" : [ ]
  }, {
    "name" : "ADJUST_UNMUTE",
    "type" : "int",
    "comment" : "\n     * Unmute the volume. Has no effect if the stream is not muted.\n     *\n     * @see #adjustVolume(int, int)\n     * @see #adjustStreamVolume(int, int, int)\n     ",
    "links" : [ ]
  }, {
    "name" : "ADJUST_TOGGLE_MUTE",
    "type" : "int",
    "comment" : "\n     * Toggle the mute state. If muted the stream will be unmuted. If not muted\n     * the stream will be muted.\n     *\n     * @see #adjustVolume(int, int)\n     * @see #adjustStreamVolume(int, int, int)\n     ",
    "links" : [ ]
  }, {
    "name" : "FLAG_SHOW_UI",
    "type" : "int",
    "comment" : "\n     * Show a toast containing the current volume.\n     *\n     * @see #adjustStreamVolume(int, int, int)\n     * @see #adjustVolume(int, int)\n     * @see #setStreamVolume(int, int, int)\n     * @see #setRingerMode(int)\n     ",
    "links" : [ ]
  }, {
    "name" : "FLAG_ALLOW_RINGER_MODES",
    "type" : "int",
    "comment" : "\n     * Whether to include ringer modes as possible options when changing volume.\n     * For example, if true and volume level is 0 and the volume is adjusted\n     * with {@link #ADJUST_LOWER}, then the ringer mode may switch the silent or\n     * vibrate mode.\n     * <p>\n     * By default this is on for the ring stream. If this flag is included,\n     * this behavior will be present regardless of the stream type being\n     * affected by the ringer mode.\n     *\n     * @see #adjustVolume(int, int)\n     * @see #adjustStreamVolume(int, int, int)\n     ",
    "links" : [ "#ADJUST_LOWER" ]
  }, {
    "name" : "FLAG_PLAY_SOUND",
    "type" : "int",
    "comment" : "\n     * Whether to play a sound when changing the volume.\n     * <p>\n     * If this is given to {@link #adjustVolume(int, int)} or\n     * {@link #adjustSuggestedStreamVolume(int, int, int)}, it may be ignored\n     * in some cases (for example, the decided stream type is not\n     * {@link AudioManager#STREAM_RING}, or the volume is being adjusted\n     * downward).\n     *\n     * @see #adjustStreamVolume(int, int, int)\n     * @see #adjustVolume(int, int)\n     * @see #setStreamVolume(int, int, int)\n     ",
    "links" : [ "android.media.AudioManager#STREAM_RING", "#adjustSuggestedStreamVolume(int", "#adjustVolume(int" ]
  }, {
    "name" : "FLAG_REMOVE_SOUND_AND_VIBRATE",
    "type" : "int",
    "comment" : "\n     * Removes any sounds/vibrate that may be in the queue, or are playing (related to\n     * changing volume).\n     ",
    "links" : [ ]
  }, {
    "name" : "FLAG_VIBRATE",
    "type" : "int",
    "comment" : "\n     * Whether to vibrate if going into the vibrate ringer mode.\n     ",
    "links" : [ ]
  }, {
    "name" : "FLAG_FIXED_VOLUME",
    "type" : "int",
    "comment" : "\n     * Indicates to VolumePanel that the volume slider should be disabled as user\n     * cannot change the stream volume\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "FLAG_BLUETOOTH_ABS_VOLUME",
    "type" : "int",
    "comment" : "\n     * Indicates the volume set/adjust call is for Bluetooth absolute volume\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "FLAG_SHOW_SILENT_HINT",
    "type" : "int",
    "comment" : "\n     * Adjusting the volume was prevented due to silent mode, display a hint in the UI.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "FLAG_HDMI_SYSTEM_AUDIO_VOLUME",
    "type" : "int",
    "comment" : "\n     * Indicates the volume call is for Hdmi Cec system audio volume\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "FLAG_ACTIVE_MEDIA_ONLY",
    "type" : "int",
    "comment" : "\n     * Indicates that this should only be handled if media is actively playing.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "FLAG_SHOW_UI_WARNINGS",
    "type" : "int",
    "comment" : "\n     * Like FLAG_SHOW_UI, but only dialog warnings and confirmations, no sliders.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "FLAG_SHOW_VIBRATE_HINT",
    "type" : "int",
    "comment" : "\n     * Adjusting the volume down from vibrated was prevented, display a hint in the UI.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "FLAG_FROM_KEY",
    "type" : "int",
    "comment" : "\n     * Adjusting the volume due to a hardware key press.\n     * This flag can be used in the places in order to denote (or check) that a volume adjustment\n     * request is from a hardware key press. (e.g. {@link MediaController}).\n     * @hide\n     ",
    "links" : [ "android.media.session.MediaController" ]
  }, {
    "name" : "FLAG_ABSOLUTE_VOLUME",
    "type" : "int",
    "comment" : "\n     * Indicates that an absolute volume controller is notifying AudioService of a change in the\n     * volume or mute status of an external audio system.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "ENCODED_SURROUND_OUTPUT_UNKNOWN",
    "type" : "int",
    "comment" : "\n     * The mode for surround sound formats is unknown.\n     ",
    "links" : [ ]
  }, {
    "name" : "ENCODED_SURROUND_OUTPUT_AUTO",
    "type" : "int",
    "comment" : "\n     * The surround sound formats are available for use if they are detected. This is the default\n     * mode.\n     ",
    "links" : [ ]
  }, {
    "name" : "ENCODED_SURROUND_OUTPUT_NEVER",
    "type" : "int",
    "comment" : "\n     * The surround sound formats are NEVER available, even if they are detected by the hardware.\n     * Those formats will not be reported.\n     ",
    "links" : [ ]
  }, {
    "name" : "ENCODED_SURROUND_OUTPUT_ALWAYS",
    "type" : "int",
    "comment" : "\n     * The surround sound formats are ALWAYS available, even if they are not detected by the\n     * hardware. Those formats will be reported as part of the HDMI output capability.\n     * Applications are then free to use either PCM or encoded output.\n     ",
    "links" : [ ]
  }, {
    "name" : "ENCODED_SURROUND_OUTPUT_MANUAL",
    "type" : "int",
    "comment" : "\n     * Surround sound formats are available according to the choice of user, even if they are not\n     * detected by the hardware. Those formats will be reported as part of the HDMI output\n     * capability. Applications are then free to use either PCM or encoded output.\n     ",
    "links" : [ ]
  }, {
    "name" : "FLAG_NAMES",
    "type" : "TreeMap<Integer, String>",
    "comment" : " The iterator of TreeMap#entrySet() returns the entries in ascending key order.",
    "links" : [ ]
  }, {
    "name" : "RINGER_MODE_SILENT",
    "type" : "int",
    "comment" : "\n     * Ringer mode that will be silent and will not vibrate. (This overrides the\n     * vibrate setting.)\n     *\n     * @see #setRingerMode(int)\n     * @see #getRingerMode()\n     ",
    "links" : [ ]
  }, {
    "name" : "RINGER_MODE_VIBRATE",
    "type" : "int",
    "comment" : "\n     * Ringer mode that will be silent and will vibrate. (This will cause the\n     * phone ringer to always vibrate, but the notification vibrate to only\n     * vibrate if set.)\n     *\n     * @see #setRingerMode(int)\n     * @see #getRingerMode()\n     ",
    "links" : [ ]
  }, {
    "name" : "RINGER_MODE_NORMAL",
    "type" : "int",
    "comment" : "\n     * Ringer mode that may be audible and may vibrate. It will be audible if\n     * the volume before changing out of this mode was audible. It will vibrate\n     * if the vibrate setting is on.\n     *\n     * @see #setRingerMode(int)\n     * @see #getRingerMode()\n     ",
    "links" : [ ]
  }, {
    "name" : "RINGER_MODE_MAX",
    "type" : "int",
    "comment" : "\n     * Maximum valid ringer mode value. Values must start from 0 and be contiguous.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "VIBRATE_TYPE_RINGER",
    "type" : "int",
    "comment" : "\n     * Vibrate type that corresponds to the ringer.\n     *\n     * @see #setVibrateSetting(int, int)\n     * @see #getVibrateSetting(int)\n     * @see #shouldVibrate(int)\n     * @deprecated Applications should maintain their own vibrate policy based on\n     * current ringer mode that can be queried via {@link #getRingerMode()}.\n     ",
    "links" : [ "#getRingerMode()" ]
  }, {
    "name" : "VIBRATE_TYPE_NOTIFICATION",
    "type" : "int",
    "comment" : "\n     * Vibrate type that corresponds to notifications.\n     *\n     * @see #setVibrateSetting(int, int)\n     * @see #getVibrateSetting(int)\n     * @see #shouldVibrate(int)\n     * @deprecated Applications should maintain their own vibrate policy based on\n     * current ringer mode that can be queried via {@link #getRingerMode()}.\n     ",
    "links" : [ "#getRingerMode()" ]
  }, {
    "name" : "VIBRATE_SETTING_OFF",
    "type" : "int",
    "comment" : "\n     * Vibrate setting that suggests to never vibrate.\n     *\n     * @see #setVibrateSetting(int, int)\n     * @see #getVibrateSetting(int)\n     * @deprecated Applications should maintain their own vibrate policy based on\n     * current ringer mode that can be queried via {@link #getRingerMode()}.\n     ",
    "links" : [ "#getRingerMode()" ]
  }, {
    "name" : "VIBRATE_SETTING_ON",
    "type" : "int",
    "comment" : "\n     * Vibrate setting that suggests to vibrate when possible.\n     *\n     * @see #setVibrateSetting(int, int)\n     * @see #getVibrateSetting(int)\n     * @deprecated Applications should maintain their own vibrate policy based on\n     * current ringer mode that can be queried via {@link #getRingerMode()}.\n     ",
    "links" : [ "#getRingerMode()" ]
  }, {
    "name" : "VIBRATE_SETTING_ONLY_SILENT",
    "type" : "int",
    "comment" : "\n     * Vibrate setting that suggests to only vibrate when in the vibrate ringer\n     * mode.\n     *\n     * @see #setVibrateSetting(int, int)\n     * @see #getVibrateSetting(int)\n     * @deprecated Applications should maintain their own vibrate policy based on\n     * current ringer mode that can be queried via {@link #getRingerMode()}.\n     ",
    "links" : [ "#getRingerMode()" ]
  }, {
    "name" : "USE_DEFAULT_STREAM_TYPE",
    "type" : "int",
    "comment" : "\n     * Suggests using the default stream type. This may not be used in all\n     * places a stream type is needed.\n     ",
    "links" : [ ]
  }, {
    "name" : "sService",
    "type" : "IAudioService",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "VOLUME_MIN_DB",
    "type" : "float",
    "comment" : " keep in sync with frameworks/av/services/audiopolicy/common/include/Volume.h",
    "links" : [ ]
  }, {
    "name" : "mPrefDevListenerMgr",
    "type" : "CallbackUtil.LazyListenerManager<OnPreferredDevicesForStrategyChangedListener>",
    "comment" : "\n     * Manages the OnPreferredDevicesForStrategyChangedListener listeners and the\n     * StrategyPreferredDevicesDispatcherStub\n     ",
    "links" : [ ]
  }, {
    "name" : "mNonDefDevListenerMgr",
    "type" : "CallbackUtil.LazyListenerManager<OnNonDefaultDevicesForStrategyChangedListener>",
    "comment" : "\n     * Manages the OnNonDefaultDevicesForStrategyChangedListener listeners and the\n     * StrategyNonDefaultDevicesDispatcherStub\n     ",
    "links" : [ ]
  }, {
    "name" : "mDevRoleForCapturePresetListeners",
    "type" : "Map<Integer, Object>",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mDevRoleForCapturePresetListenersLock",
    "type" : "Object",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mDeviceRoleListenersStatus",
    "type" : "int",
    "comment" : "\n     * Record if there is a listener added for device role change. If there is a listener added for\n     * a specified device role change, the bit at position `1 << device_role` is set.\n     ",
    "links" : [ ]
  }, {
    "name" : "mDevicesRoleForCapturePresetDispatcherStub",
    "type" : "CapturePresetDevicesRoleDispatcherStub",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "DIRECT_PLAYBACK_NOT_SUPPORTED",
    "type" : "int",
    "comment" : " Return value for {@link #getDirectPlaybackSupport(AudioFormat, AudioAttributes)}:\n        direct playback not supported. ",
    "links" : [ "#getDirectPlaybackSupport(AudioFormat" ]
  }, {
    "name" : "DIRECT_PLAYBACK_OFFLOAD_SUPPORTED",
    "type" : "int",
    "comment" : " Return value for {@link #getDirectPlaybackSupport(AudioFormat, AudioAttributes)}:\n        direct offload playback supported. Compressed offload is a variant of direct playback.\n        It is the feature that allows audio processing tasks to be done on the Android device but\n        not on the application processor, instead, it is handled by dedicated hardware such as audio\n        DSPs. That will allow the application processor to be idle as much as possible, which is\n        good for power saving. Compressed offload playback supports\n        {@link AudioTrack.StreamEventCallback} for event notifications. ",
    "links" : [ "#getDirectPlaybackSupport(AudioFormat", "AudioTrack.StreamEventCallback" ]
  }, {
    "name" : "DIRECT_PLAYBACK_OFFLOAD_GAPLESS_SUPPORTED",
    "type" : "int",
    "comment" : " Return value for {@link #getDirectPlaybackSupport(AudioFormat, AudioAttributes)}:\n        direct offload playback supported with gapless transitions. Compressed offload is a variant\n        of direct playback. It is the feature that allows audio processing tasks to be done on the\n        Android device but not on the application processor, instead, it is handled by dedicated\n        hardware such as audio DSPs. That will allow the application processor to be idle as much as\n        possible, which is good for power saving. Compressed offload playback supports\n        {@link AudioTrack.StreamEventCallback} for event notifications. Gapless transitions\n        indicates the ability to play consecutive audio tracks without an audio silence in\n        between. ",
    "links" : [ "#getDirectPlaybackSupport(AudioFormat", "AudioTrack.StreamEventCallback" ]
  }, {
    "name" : "DIRECT_PLAYBACK_BITSTREAM_SUPPORTED",
    "type" : "int",
    "comment" : " Return value for {@link #getDirectPlaybackSupport(AudioFormat, AudioAttributes)}:\n        direct playback supported. This value covers direct playback that is bitstream pass-through\n        such as compressed pass-through. ",
    "links" : [ "#getDirectPlaybackSupport(AudioFormat" ]
  }, {
    "name" : "PLAYBACK_OFFLOAD_NOT_SUPPORTED",
    "type" : "int",
    "comment" : " Return value for {@link #getPlaybackOffloadSupport(AudioFormat, AudioAttributes)}:\n        offload playback not supported ",
    "links" : [ "#getPlaybackOffloadSupport(AudioFormat" ]
  }, {
    "name" : "PLAYBACK_OFFLOAD_SUPPORTED",
    "type" : "int",
    "comment" : " Return value for {@link #getPlaybackOffloadSupport(AudioFormat, AudioAttributes)}:\n        offload playback supported ",
    "links" : [ "#getPlaybackOffloadSupport(AudioFormat" ]
  }, {
    "name" : "PLAYBACK_OFFLOAD_GAPLESS_SUPPORTED",
    "type" : "int",
    "comment" : " Return value for {@link #getPlaybackOffloadSupport(AudioFormat, AudioAttributes)}:\n        offload playback supported with gapless transitions ",
    "links" : [ "#getPlaybackOffloadSupport(AudioFormat" ]
  }, {
    "name" : "ACTION_SCO_AUDIO_STATE_CHANGED",
    "type" : "String",
    "comment" : "\n     * Sticky broadcast intent action indicating that the Bluetooth SCO audio\n     * connection state has changed. The intent contains on extra {@link #EXTRA_SCO_AUDIO_STATE}\n     * indicating the new state which is either {@link #SCO_AUDIO_STATE_DISCONNECTED}\n     * or {@link #SCO_AUDIO_STATE_CONNECTED}\n     *\n     * @see #startBluetoothSco()\n     * @deprecated Use  {@link #ACTION_SCO_AUDIO_STATE_UPDATED} instead\n     ",
    "links" : [ "#ACTION_SCO_AUDIO_STATE_UPDATED", "#SCO_AUDIO_STATE_DISCONNECTED", "#EXTRA_SCO_AUDIO_STATE", "#SCO_AUDIO_STATE_CONNECTED" ]
  }, {
    "name" : "ACTION_SCO_AUDIO_STATE_UPDATED",
    "type" : "String",
    "comment" : "\n     * Sticky broadcast intent action indicating that the Bluetooth SCO audio\n     * connection state has been updated.\n     * <p>This intent has two extras:\n     * <ul>\n     *   <li> {@link #EXTRA_SCO_AUDIO_STATE} - The new SCO audio state. </li>\n     *   <li> {@link #EXTRA_SCO_AUDIO_PREVIOUS_STATE}- The previous SCO audio state. </li>\n     * </ul>\n     * <p> EXTRA_SCO_AUDIO_STATE or EXTRA_SCO_AUDIO_PREVIOUS_STATE can be any of:\n     * <ul>\n     *   <li> {@link #SCO_AUDIO_STATE_DISCONNECTED}, </li>\n     *   <li> {@link #SCO_AUDIO_STATE_CONNECTING} or </li>\n     *   <li> {@link #SCO_AUDIO_STATE_CONNECTED}, </li>\n     * </ul>\n     * @see #startBluetoothSco()\n     ",
    "links" : [ "#EXTRA_SCO_AUDIO_PREVIOUS_STATE", "#SCO_AUDIO_STATE_CONNECTING", "#SCO_AUDIO_STATE_DISCONNECTED", "#EXTRA_SCO_AUDIO_STATE", "#SCO_AUDIO_STATE_CONNECTED" ]
  }, {
    "name" : "EXTRA_SCO_AUDIO_STATE",
    "type" : "String",
    "comment" : "\n     * Extra for intent {@link #ACTION_SCO_AUDIO_STATE_CHANGED} or\n     * {@link #ACTION_SCO_AUDIO_STATE_UPDATED} containing the new bluetooth SCO connection state.\n     ",
    "links" : [ "#ACTION_SCO_AUDIO_STATE_UPDATED", "#ACTION_SCO_AUDIO_STATE_CHANGED" ]
  }, {
    "name" : "EXTRA_SCO_AUDIO_PREVIOUS_STATE",
    "type" : "String",
    "comment" : "\n     * Extra for intent {@link #ACTION_SCO_AUDIO_STATE_UPDATED} containing the previous\n     * bluetooth SCO connection state.\n     ",
    "links" : [ "#ACTION_SCO_AUDIO_STATE_UPDATED" ]
  }, {
    "name" : "SCO_AUDIO_STATE_DISCONNECTED",
    "type" : "int",
    "comment" : "\n     * Value for extra EXTRA_SCO_AUDIO_STATE or EXTRA_SCO_AUDIO_PREVIOUS_STATE\n     * indicating that the SCO audio channel is not established\n     ",
    "links" : [ ]
  }, {
    "name" : "SCO_AUDIO_STATE_CONNECTED",
    "type" : "int",
    "comment" : "\n     * Value for extra {@link #EXTRA_SCO_AUDIO_STATE} or {@link #EXTRA_SCO_AUDIO_PREVIOUS_STATE}\n     * indicating that the SCO audio channel is established\n     ",
    "links" : [ "#EXTRA_SCO_AUDIO_PREVIOUS_STATE", "#EXTRA_SCO_AUDIO_STATE" ]
  }, {
    "name" : "SCO_AUDIO_STATE_CONNECTING",
    "type" : "int",
    "comment" : "\n     * Value for extra EXTRA_SCO_AUDIO_STATE or EXTRA_SCO_AUDIO_PREVIOUS_STATE\n     * indicating that the SCO audio channel is being established\n     ",
    "links" : [ ]
  }, {
    "name" : "SCO_AUDIO_STATE_ERROR",
    "type" : "int",
    "comment" : "\n     * Value for extra EXTRA_SCO_AUDIO_STATE indicating that\n     * there was an error trying to obtain the state\n     ",
    "links" : [ ]
  }, {
    "name" : "ACTION_MICROPHONE_MUTE_CHANGED",
    "type" : "String",
    "comment" : "\n     * Broadcast Action: microphone muting state changed.\n     *\n     * You <em>cannot</em> receive this through components declared\n     * in manifests, only by explicitly registering for it with\n     * {@link Context#registerReceiver(BroadcastReceiver, IntentFilter)\n     * Context.registerReceiver()}.\n     *\n     * <p>The intent has no extra values, use {@link #isMicrophoneMute} to check whether the\n     * microphone is muted.\n     ",
    "links" : [ "android.content.Context#registerReceiver(BroadcastReceiver", "#isMicrophoneMute" ]
  }, {
    "name" : "ACTION_SPEAKERPHONE_STATE_CHANGED",
    "type" : "String",
    "comment" : "\n     * Broadcast Action: speakerphone state changed.\n     *\n     * You <em>cannot</em> receive this through components declared\n     * in manifests, only by explicitly registering for it with\n     * {@link Context#registerReceiver(BroadcastReceiver, IntentFilter)\n     * Context.registerReceiver()}.\n     *\n     * <p>The intent has no extra values, use {@link #isSpeakerphoneOn} to check whether the\n     * speakerphone functionality is enabled or not.\n     ",
    "links" : [ "android.content.Context#registerReceiver(BroadcastReceiver", "#isSpeakerphoneOn" ]
  }, {
    "name" : "CALL_REDIRECTION_AUDIO_MODES",
    "type" : "long",
    "comment" : "\n     * This change id controls use of audio modes for call audio redirection.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "mModeChangedListenerMgr",
    "type" : "CallbackUtil.LazyListenerManager<OnModeChangedListener>",
    "comment" : "\n     * manages the OnModeChangedListener listeners and the ModeDispatcherStub\n     ",
    "links" : [ ]
  }, {
    "name" : "MODE_INVALID",
    "type" : "int",
    "comment" : "\n     * Invalid audio mode.\n     ",
    "links" : [ ]
  }, {
    "name" : "MODE_CURRENT",
    "type" : "int",
    "comment" : "\n     * Current audio mode. Used to apply audio routing to current mode.\n     ",
    "links" : [ ]
  }, {
    "name" : "MODE_NORMAL",
    "type" : "int",
    "comment" : "\n     * Normal audio mode: not ringing and no call established.\n     ",
    "links" : [ ]
  }, {
    "name" : "MODE_RINGTONE",
    "type" : "int",
    "comment" : "\n     * Ringing audio mode. An incoming is being signaled.\n     ",
    "links" : [ ]
  }, {
    "name" : "MODE_IN_CALL",
    "type" : "int",
    "comment" : "\n     * In call audio mode. A telephony call is established.\n     ",
    "links" : [ ]
  }, {
    "name" : "MODE_IN_COMMUNICATION",
    "type" : "int",
    "comment" : "\n     * In communication audio mode. An audio/video chat or VoIP call is established.\n     ",
    "links" : [ ]
  }, {
    "name" : "MODE_CALL_SCREENING",
    "type" : "int",
    "comment" : "\n     * Call screening in progress. Call is connected and audio is accessible to call\n     * screening applications but other audio use cases are still possible.\n     ",
    "links" : [ ]
  }, {
    "name" : "MODE_CALL_REDIRECT",
    "type" : "int",
    "comment" : "\n     * A telephony call is established and its audio is being redirected to another device.\n     ",
    "links" : [ ]
  }, {
    "name" : "MODE_COMMUNICATION_REDIRECT",
    "type" : "int",
    "comment" : "\n     * An audio/video chat or VoIP call is established and its audio is being redirected to another\n     * device.\n     ",
    "links" : [ ]
  }, {
    "name" : "ROUTE_EARPIECE",
    "type" : "int",
    "comment" : "\n     * Routing audio output to earpiece\n     * @deprecated   Do not set audio routing directly, use setSpeakerphoneOn(),\n     * setBluetoothScoOn() methods instead.\n     ",
    "links" : [ ]
  }, {
    "name" : "ROUTE_SPEAKER",
    "type" : "int",
    "comment" : "\n     * Routing audio output to speaker\n     * @deprecated   Do not set audio routing directly, use setSpeakerphoneOn(),\n     * setBluetoothScoOn() methods instead.\n     ",
    "links" : [ ]
  }, {
    "name" : "ROUTE_BLUETOOTH",
    "type" : "int",
    "comment" : "\n     * @deprecated use {@link #ROUTE_BLUETOOTH_SCO}\n     * @deprecated   Do not set audio routing directly, use setSpeakerphoneOn(),\n     * setBluetoothScoOn() methods instead.\n     ",
    "links" : [ "#ROUTE_BLUETOOTH_SCO" ]
  }, {
    "name" : "ROUTE_BLUETOOTH_SCO",
    "type" : "int",
    "comment" : "\n     * Routing audio output to bluetooth SCO\n     * @deprecated   Do not set audio routing directly, use setSpeakerphoneOn(),\n     * setBluetoothScoOn() methods instead.\n     ",
    "links" : [ ]
  }, {
    "name" : "ROUTE_HEADSET",
    "type" : "int",
    "comment" : "\n     * Routing audio output to headset\n     * @deprecated   Do not set audio routing directly, use setSpeakerphoneOn(),\n     * setBluetoothScoOn() methods instead.\n     ",
    "links" : [ ]
  }, {
    "name" : "ROUTE_BLUETOOTH_A2DP",
    "type" : "int",
    "comment" : "\n     * Routing audio output to bluetooth A2DP\n     * @deprecated   Do not set audio routing directly, use setSpeakerphoneOn(),\n     * setBluetoothScoOn() methods instead.\n     ",
    "links" : [ ]
  }, {
    "name" : "ROUTE_ALL",
    "type" : "int",
    "comment" : "\n     * Used for mask parameter of {@link #setRouting(int,int,int)}.\n     * @deprecated   Do not set audio routing directly, use setSpeakerphoneOn(),\n     * setBluetoothScoOn() methods instead.\n     ",
    "links" : [ "#setRouting(int" ]
  }, {
    "name" : "AUDIO_SESSION_ID_GENERATE",
    "type" : "int",
    "comment" : "\n     * A special audio session ID to indicate that the audio session ID isn't known and the\n     * framework should generate a new value. This can be used when building a new\n     * {@link AudioTrack} instance with\n     * {@link AudioTrack#AudioTrack(AudioAttributes, AudioFormat, int, int, int)}.\n     ",
    "links" : [ "android.media.AudioTrack#AudioTrack(AudioAttributes", "android.media.AudioTrack" ]
  }, {
    "name" : "FX_KEY_CLICK",
    "type" : "int",
    "comment" : "\n     * Keyboard and direction pad click sound\n     * @see #playSoundEffect(int)\n     ",
    "links" : [ ]
  }, {
    "name" : "FX_FOCUS_NAVIGATION_UP",
    "type" : "int",
    "comment" : "\n     * Focus has moved up\n     * @see #playSoundEffect(int)\n     ",
    "links" : [ ]
  }, {
    "name" : "FX_FOCUS_NAVIGATION_DOWN",
    "type" : "int",
    "comment" : "\n     * Focus has moved down\n     * @see #playSoundEffect(int)\n     ",
    "links" : [ ]
  }, {
    "name" : "FX_FOCUS_NAVIGATION_LEFT",
    "type" : "int",
    "comment" : "\n     * Focus has moved left\n     * @see #playSoundEffect(int)\n     ",
    "links" : [ ]
  }, {
    "name" : "FX_FOCUS_NAVIGATION_RIGHT",
    "type" : "int",
    "comment" : "\n     * Focus has moved right\n     * @see #playSoundEffect(int)\n     ",
    "links" : [ ]
  }, {
    "name" : "FX_KEYPRESS_STANDARD",
    "type" : "int",
    "comment" : "\n     * IME standard keypress sound\n     * @see #playSoundEffect(int)\n     ",
    "links" : [ ]
  }, {
    "name" : "FX_KEYPRESS_SPACEBAR",
    "type" : "int",
    "comment" : "\n     * IME spacebar keypress sound\n     * @see #playSoundEffect(int)\n     ",
    "links" : [ ]
  }, {
    "name" : "FX_KEYPRESS_DELETE",
    "type" : "int",
    "comment" : "\n     * IME delete keypress sound\n     * @see #playSoundEffect(int)\n     ",
    "links" : [ ]
  }, {
    "name" : "FX_KEYPRESS_RETURN",
    "type" : "int",
    "comment" : "\n     * IME return_keypress sound\n     * @see #playSoundEffect(int)\n     ",
    "links" : [ ]
  }, {
    "name" : "FX_KEYPRESS_INVALID",
    "type" : "int",
    "comment" : "\n     * Invalid keypress sound\n     * @see #playSoundEffect(int)\n     ",
    "links" : [ ]
  }, {
    "name" : "FX_BACK",
    "type" : "int",
    "comment" : "\n     * Back sound\n     * @see #playSoundEffect(int)\n     ",
    "links" : [ ]
  }, {
    "name" : "FX_HOME",
    "type" : "int",
    "comment" : "\n     * @hide Home sound\n     * <p>\n     * To be played by the framework when the home app becomes active if config_enableHomeSound is\n     * set to true. This is currently only used on TV devices.\n     * Note that this sound is only available if a sound file is specified in audio_assets.xml.\n     * @see #playSoundEffect(int)\n     ",
    "links" : [ ]
  }, {
    "name" : "FX_FOCUS_NAVIGATION_REPEAT_1",
    "type" : "int",
    "comment" : "\n     * @hide Navigation repeat sound 1\n     * <p>\n     * To be played by the framework when a focus navigation is repeatedly triggered\n     * (e.g. due to long-pressing) and {@link #areNavigationRepeatSoundEffectsEnabled()} is true.\n     * This is currently only used on TV devices.\n     * Note that this sound is only available if a sound file is specified in audio_assets.xml\n     * @see #playSoundEffect(int)\n     ",
    "links" : [ "#areNavigationRepeatSoundEffectsEnabled()" ]
  }, {
    "name" : "FX_FOCUS_NAVIGATION_REPEAT_2",
    "type" : "int",
    "comment" : "\n     * @hide Navigation repeat sound 2\n     * <p>\n     * To be played by the framework when a focus navigation is repeatedly triggered\n     * (e.g. due to long-pressing) and {@link #areNavigationRepeatSoundEffectsEnabled()} is true.\n     * This is currently only used on TV devices.\n     * Note that this sound is only available if a sound file is specified in audio_assets.xml\n     * @see #playSoundEffect(int)\n     ",
    "links" : [ "#areNavigationRepeatSoundEffectsEnabled()" ]
  }, {
    "name" : "FX_FOCUS_NAVIGATION_REPEAT_3",
    "type" : "int",
    "comment" : "\n     * @hide Navigation repeat sound 3\n     * <p>\n     * To be played by the framework when a focus navigation is repeatedly triggered\n     * (e.g. due to long-pressing) and {@link #areNavigationRepeatSoundEffectsEnabled()} is true.\n     * This is currently only used on TV devices.\n     * Note that this sound is only available if a sound file is specified in audio_assets.xml\n     * @see #playSoundEffect(int)\n     ",
    "links" : [ "#areNavigationRepeatSoundEffectsEnabled()" ]
  }, {
    "name" : "FX_FOCUS_NAVIGATION_REPEAT_4",
    "type" : "int",
    "comment" : "\n     * @hide Navigation repeat sound 4\n     * <p>\n     * To be played by the framework when a focus navigation is repeatedly triggered\n     * (e.g. due to long-pressing) and {@link #areNavigationRepeatSoundEffectsEnabled()} is true.\n     * This is currently only used on TV devices.\n     * Note that this sound is only available if a sound file is specified in audio_assets.xml\n     * @see #playSoundEffect(int)\n     ",
    "links" : [ "#areNavigationRepeatSoundEffectsEnabled()" ]
  }, {
    "name" : "NUM_SOUND_EFFECTS",
    "type" : "int",
    "comment" : "\n     * @hide Number of sound effects\n     ",
    "links" : [ ]
  }, {
    "name" : "NUM_NAVIGATION_REPEAT_SOUND_EFFECTS",
    "type" : "int",
    "comment" : "\n     * @hide Number of FX_FOCUS_NAVIGATION_REPEAT_* sound effects\n     ",
    "links" : [ ]
  }, {
    "name" : "AUDIOFOCUS_NONE",
    "type" : "int",
    "comment" : "\n     * Used to indicate no audio focus has been gained or lost, or requested.\n     ",
    "links" : [ ]
  }, {
    "name" : "AUDIOFOCUS_GAIN",
    "type" : "int",
    "comment" : "\n     * Used to indicate a gain of audio focus, or a request of audio focus, of unknown duration.\n     * @see OnAudioFocusChangeListener#onAudioFocusChange(int)\n     * @see #requestAudioFocus(OnAudioFocusChangeListener, int, int)\n     ",
    "links" : [ ]
  }, {
    "name" : "AUDIOFOCUS_GAIN_TRANSIENT",
    "type" : "int",
    "comment" : "\n     * Used to indicate a temporary gain or request of audio focus, anticipated to last a short\n     * amount of time. Examples of temporary changes are the playback of driving directions, or an\n     * event notification.\n     * @see OnAudioFocusChangeListener#onAudioFocusChange(int)\n     * @see #requestAudioFocus(OnAudioFocusChangeListener, int, int)\n     ",
    "links" : [ ]
  }, {
    "name" : "AUDIOFOCUS_GAIN_TRANSIENT_MAY_DUCK",
    "type" : "int",
    "comment" : "\n     * Used to indicate a temporary request of audio focus, anticipated to last a short\n     * amount of time, and where it is acceptable for other audio applications to keep playing\n     * after having lowered their output level (also referred to as \"ducking\").\n     * Examples of temporary changes are the playback of driving directions where playback of music\n     * in the background is acceptable.\n     * @see OnAudioFocusChangeListener#onAudioFocusChange(int)\n     * @see #requestAudioFocus(OnAudioFocusChangeListener, int, int)\n     ",
    "links" : [ ]
  }, {
    "name" : "AUDIOFOCUS_GAIN_TRANSIENT_EXCLUSIVE",
    "type" : "int",
    "comment" : "\n     * Used to indicate a temporary request of audio focus, anticipated to last a short\n     * amount of time, during which no other applications, or system components, should play\n     * anything. Examples of exclusive and transient audio focus requests are voice\n     * memo recording and speech recognition, during which the system shouldn't play any\n     * notifications, and media playback should have paused.\n     * @see #requestAudioFocus(OnAudioFocusChangeListener, int, int)\n     ",
    "links" : [ ]
  }, {
    "name" : "AUDIOFOCUS_LOSS",
    "type" : "int",
    "comment" : "\n     * Used to indicate a loss of audio focus of unknown duration.\n     * @see OnAudioFocusChangeListener#onAudioFocusChange(int)\n     ",
    "links" : [ ]
  }, {
    "name" : "AUDIOFOCUS_LOSS_TRANSIENT",
    "type" : "int",
    "comment" : "\n     * Used to indicate a transient loss of audio focus.\n     * @see OnAudioFocusChangeListener#onAudioFocusChange(int)\n     ",
    "links" : [ ]
  }, {
    "name" : "AUDIOFOCUS_LOSS_TRANSIENT_CAN_DUCK",
    "type" : "int",
    "comment" : "\n     * Used to indicate a transient loss of audio focus where the loser of the audio focus can\n     * lower its output volume if it wants to continue playing (also referred to as \"ducking\"), as\n     * the new focus owner doesn't require others to be silent.\n     * @see OnAudioFocusChangeListener#onAudioFocusChange(int)\n     ",
    "links" : [ ]
  }, {
    "name" : "mAudioFocusIdListenerMap",
    "type" : "ConcurrentHashMap<String, FocusRequestInfo>",
    "comment" : "\n     * Map to convert focus event listener IDs, as used in the AudioService audio focus stack,\n     * to actual listener objects.\n     ",
    "links" : [ ]
  }, {
    "name" : "mServiceEventHandlerDelegate",
    "type" : "ServiceEventHandlerDelegate",
    "comment" : "\n     * Handler for events (audio focus change, recording config change) coming from the\n     * audio service.\n     ",
    "links" : [ ]
  }, {
    "name" : "MSSG_FOCUS_CHANGE",
    "type" : "int",
    "comment" : "\n     * Event types\n     ",
    "links" : [ ]
  }, {
    "name" : "MSSG_RECORDING_CONFIG_CHANGE",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "MSSG_PLAYBACK_CONFIG_CHANGE",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mAudioFocusDispatcher",
    "type" : "IAudioFocusDispatcher",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "AUDIOFOCUS_REQUEST_FAILED",
    "type" : "int",
    "comment" : "\n     * A failed focus change request.\n     ",
    "links" : [ ]
  }, {
    "name" : "AUDIOFOCUS_REQUEST_GRANTED",
    "type" : "int",
    "comment" : "\n     * A successful focus change request.\n     ",
    "links" : [ ]
  }, {
    "name" : "AUDIOFOCUS_REQUEST_DELAYED",
    "type" : "int",
    "comment" : "\n      * A focus change request whose granting is delayed: the request was successful, but the\n      * requester will only be granted audio focus once the condition that prevented immediate\n      * granting has ended.\n      * See {@link #requestAudioFocus(AudioFocusRequest)} and\n      * {@link AudioFocusRequest.Builder#setAcceptsDelayedFocusGain(boolean)}\n      ",
    "links" : [ "AudioFocusRequest.Builder#setAcceptsDelayedFocusGain(boolean)", "#requestAudioFocus(AudioFocusRequest)" ]
  }, {
    "name" : "AUDIOFOCUS_REQUEST_WAITING_FOR_EXT_POLICY",
    "type" : "int",
    "comment" : "\n     * @hide\n     * code returned when a synchronous focus request on the client-side is to be blocked\n     * until the external audio focus policy decides on the response for the client\n     ",
    "links" : [ ]
  }, {
    "name" : "EXT_FOCUS_POLICY_TIMEOUT_MS",
    "type" : "int",
    "comment" : "\n     * Timeout duration in ms when waiting on an external focus policy for the result for a\n     * focus request\n     ",
    "links" : [ ]
  }, {
    "name" : "FOCUS_CLIENT_ID_STRING",
    "type" : "String",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mFocusRequestsLock",
    "type" : "Object",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mFocusRequestsAwaitingResult",
    "type" : "HashMap<String, BlockingFocusResultReceiver>",
    "comment" : "\n     * Map of all receivers of focus request results, one per unresolved focus request.\n     * Receivers are added before sending the request to the external focus policy,\n     * and are removed either after receiving the result, or after the timeout.\n     * This variable is lazily initialized.\n     ",
    "links" : [ ]
  }, {
    "name" : "AUDIOFOCUS_FLAG_DELAY_OK",
    "type" : "int",
    "comment" : "\n     * @hide\n     * Use this flag when requesting audio focus to indicate it is ok for the requester to not be\n     * granted audio focus immediately (as indicated by {@link #AUDIOFOCUS_REQUEST_DELAYED}) when\n     * the system is in a state where focus cannot change, but be granted focus later when\n     * this condition ends.\n     ",
    "links" : [ "#AUDIOFOCUS_REQUEST_DELAYED" ]
  }, {
    "name" : "AUDIOFOCUS_FLAG_PAUSES_ON_DUCKABLE_LOSS",
    "type" : "int",
    "comment" : "\n     * @hide\n     * Use this flag when requesting audio focus to indicate that the requester\n     * will pause its media playback (if applicable) when losing audio focus with\n     * {@link #AUDIOFOCUS_LOSS_TRANSIENT_CAN_DUCK}, rather than ducking.\n     * <br>On some platforms, the ducking may be handled without the application being aware of it\n     * (i.e. it will not transiently lose focus). For applications that for instance play spoken\n     * content, such as audio book or podcast players, ducking may never be acceptable, and will\n     * thus always pause. This flag enables them to be declared as such whenever they request focus.\n     ",
    "links" : [ "#AUDIOFOCUS_LOSS_TRANSIENT_CAN_DUCK" ]
  }, {
    "name" : "AUDIOFOCUS_FLAG_LOCK",
    "type" : "int",
    "comment" : "\n     * @hide\n     * Use this flag to lock audio focus so granting is temporarily disabled.\n     * <br>This flag can only be used by owners of a registered\n     * {@link android.media.audiopolicy.AudioPolicy} in\n     * {@link #requestAudioFocus(OnAudioFocusChangeListener, AudioAttributes, int, int, AudioPolicy)}\n     ",
    "links" : [ "#requestAudioFocus(OnAudioFocusChangeListener", "android.media.audiopolicy.AudioPolicy" ]
  }, {
    "name" : "AUDIOFOCUS_FLAG_TEST",
    "type" : "int",
    "comment" : "\n     * @hide\n     * flag set on test API calls,\n     * see {@link #requestAudioFocusForTest(AudioFocusRequest, String, int, int)},\n     ",
    "links" : [ "#requestAudioFocusForTest(AudioFocusRequest" ]
  }, {
    "name" : "AUDIOFOCUS_FLAGS_APPS",
    "type" : "int",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "AUDIOFOCUS_FLAGS_SYSTEM",
    "type" : "int",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "mPlaybackCallbackList",
    "type" : "List<AudioPlaybackCallbackInfo>",
    "comment" : "\n     * All operations on this list are sync'd on mPlaybackCallbackLock.\n     * List is lazy-initialized in\n     * {@link #registerAudioPlaybackCallback(AudioPlaybackCallback, Handler)}.\n     * List can be null.\n     ",
    "links" : [ "#registerAudioPlaybackCallback(AudioPlaybackCallback" ]
  }, {
    "name" : "mPlaybackCallbackLock",
    "type" : "Object",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mPlayCb",
    "type" : "IPlaybackConfigDispatcher",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "RECORD_CONFIG_EVENT_NONE",
    "type" : "int",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "RECORD_CONFIG_EVENT_START",
    "type" : "int",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "RECORD_CONFIG_EVENT_STOP",
    "type" : "int",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "RECORD_CONFIG_EVENT_UPDATE",
    "type" : "int",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "RECORD_CONFIG_EVENT_RELEASE",
    "type" : "int",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "RECORD_RIID_INVALID",
    "type" : "int",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "RECORDER_STATE_STARTED",
    "type" : "int",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "RECORDER_STATE_STOPPED",
    "type" : "int",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "mRecordCallbackList",
    "type" : "List<AudioRecordingCallbackInfo>",
    "comment" : "\n     * All operations on this list are sync'd on mRecordCallbackLock.\n     * List is lazy-initialized in\n     * {@link #registerAudioRecordingCallback(AudioRecordingCallback, Handler)}.\n     * List can be null.\n     ",
    "links" : [ "#registerAudioRecordingCallback(AudioRecordingCallback" ]
  }, {
    "name" : "mRecordCallbackLock",
    "type" : "Object",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mRecCb",
    "type" : "IRecordingConfigDispatcher",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mICallBack",
    "type" : "IBinder",
    "comment" : "\n      * {@hide}\n      ",
    "links" : [ ]
  }, {
    "name" : "DEVICE_NONE",
    "type" : "int",
    "comment" : " @hide\n     * The audio device code for representing \"no device.\" ",
    "links" : [ ]
  }, {
    "name" : "DEVICE_OUT_EARPIECE",
    "type" : "int",
    "comment" : " @hide\n     *  The audio output device code for the small speaker at the front of the device used\n     *  when placing calls.  Does not refer to an in-ear headphone without attached microphone,\n     *  such as earbuds, earphones, or in-ear monitors (IEM). Those would be handled as a\n     *  {@link #DEVICE_OUT_WIRED_HEADPHONE}.\n     ",
    "links" : [ "#DEVICE_OUT_WIRED_HEADPHONE" ]
  }, {
    "name" : "DEVICE_OUT_SPEAKER",
    "type" : "int",
    "comment" : " @hide\n     *  The audio output device code for the built-in speaker ",
    "links" : [ ]
  }, {
    "name" : "DEVICE_OUT_WIRED_HEADSET",
    "type" : "int",
    "comment" : " @hide\n     * The audio output device code for a wired headset with attached microphone ",
    "links" : [ ]
  }, {
    "name" : "DEVICE_OUT_WIRED_HEADPHONE",
    "type" : "int",
    "comment" : " @hide\n     * The audio output device code for a wired headphone without attached microphone ",
    "links" : [ ]
  }, {
    "name" : "DEVICE_OUT_USB_HEADSET",
    "type" : "int",
    "comment" : " @hide\n     * The audio output device code for a USB headphone with attached microphone ",
    "links" : [ ]
  }, {
    "name" : "DEVICE_OUT_BLUETOOTH_SCO",
    "type" : "int",
    "comment" : " @hide\n     * The audio output device code for generic Bluetooth SCO, for voice ",
    "links" : [ ]
  }, {
    "name" : "DEVICE_OUT_BLUETOOTH_SCO_HEADSET",
    "type" : "int",
    "comment" : " @hide\n     * The audio output device code for Bluetooth SCO Headset Profile (HSP) and\n     * Hands-Free Profile (HFP), for voice\n     ",
    "links" : [ ]
  }, {
    "name" : "DEVICE_OUT_BLUETOOTH_SCO_CARKIT",
    "type" : "int",
    "comment" : " @hide\n     * The audio output device code for Bluetooth SCO car audio, for voice ",
    "links" : [ ]
  }, {
    "name" : "DEVICE_OUT_BLUETOOTH_A2DP",
    "type" : "int",
    "comment" : " @hide\n     * The audio output device code for generic Bluetooth A2DP, for music ",
    "links" : [ ]
  }, {
    "name" : "DEVICE_OUT_BLUETOOTH_A2DP_HEADPHONES",
    "type" : "int",
    "comment" : " @hide\n     * The audio output device code for Bluetooth A2DP headphones, for music ",
    "links" : [ ]
  }, {
    "name" : "DEVICE_OUT_BLUETOOTH_A2DP_SPEAKER",
    "type" : "int",
    "comment" : " @hide\n     * The audio output device code for Bluetooth A2DP external speaker, for music ",
    "links" : [ ]
  }, {
    "name" : "DEVICE_OUT_AUX_DIGITAL",
    "type" : "int",
    "comment" : " @hide\n     * The audio output device code for S/PDIF (legacy) or HDMI\n     * Deprecated: replaced by {@link #DEVICE_OUT_HDMI} ",
    "links" : [ "#DEVICE_OUT_HDMI" ]
  }, {
    "name" : "DEVICE_OUT_HDMI",
    "type" : "int",
    "comment" : " @hide\n     * The audio output device code for HDMI ",
    "links" : [ ]
  }, {
    "name" : "DEVICE_OUT_ANLG_DOCK_HEADSET",
    "type" : "int",
    "comment" : " @hide\n     * The audio output device code for an analog wired headset attached via a\n     *  docking station\n     ",
    "links" : [ ]
  }, {
    "name" : "DEVICE_OUT_DGTL_DOCK_HEADSET",
    "type" : "int",
    "comment" : " @hide\n     * The audio output device code for a digital wired headset attached via a\n     *  docking station\n     ",
    "links" : [ ]
  }, {
    "name" : "DEVICE_OUT_USB_ACCESSORY",
    "type" : "int",
    "comment" : " @hide\n     * The audio output device code for a USB audio accessory. The accessory is in USB host\n     * mode and the Android device in USB device mode\n     ",
    "links" : [ ]
  }, {
    "name" : "DEVICE_OUT_USB_DEVICE",
    "type" : "int",
    "comment" : " @hide\n     * The audio output device code for a USB audio device. The device is in USB device\n     * mode and the Android device in USB host mode\n     ",
    "links" : [ ]
  }, {
    "name" : "DEVICE_OUT_REMOTE_SUBMIX",
    "type" : "int",
    "comment" : " @hide\n     * The audio output device code for projection output.\n     ",
    "links" : [ ]
  }, {
    "name" : "DEVICE_OUT_TELEPHONY_TX",
    "type" : "int",
    "comment" : " @hide\n     * The audio output device code the telephony voice TX path.\n     ",
    "links" : [ ]
  }, {
    "name" : "DEVICE_OUT_LINE",
    "type" : "int",
    "comment" : " @hide\n     * The audio output device code for an analog jack with line impedance detected.\n     ",
    "links" : [ ]
  }, {
    "name" : "DEVICE_OUT_HDMI_ARC",
    "type" : "int",
    "comment" : " @hide\n     * The audio output device code for HDMI Audio Return Channel.\n     ",
    "links" : [ ]
  }, {
    "name" : "DEVICE_OUT_HDMI_EARC",
    "type" : "int",
    "comment" : " @hide\n     * The audio output device code for HDMI enhanced Audio Return Channel.\n     ",
    "links" : [ ]
  }, {
    "name" : "DEVICE_OUT_SPDIF",
    "type" : "int",
    "comment" : " @hide\n     * The audio output device code for S/PDIF digital connection.\n     ",
    "links" : [ ]
  }, {
    "name" : "DEVICE_OUT_FM",
    "type" : "int",
    "comment" : " @hide\n     * The audio output device code for built-in FM transmitter.\n     ",
    "links" : [ ]
  }, {
    "name" : "DEVICE_OUT_ECHO_CANCELLER",
    "type" : "int",
    "comment" : " @hide\n     * The audio output device code for echo reference injection point.\n     ",
    "links" : [ ]
  }, {
    "name" : "DEVICE_OUT_BLE_HEADSET",
    "type" : "int",
    "comment" : " @hide\n     * The audio output device code for a BLE audio headset.\n     ",
    "links" : [ ]
  }, {
    "name" : "DEVICE_OUT_BLE_SPEAKER",
    "type" : "int",
    "comment" : " @hide\n     * The audio output device code for a BLE audio speaker.\n     ",
    "links" : [ ]
  }, {
    "name" : "DEVICE_OUT_BLE_BROADCAST",
    "type" : "int",
    "comment" : " @hide\n     * The audio output device code for a BLE audio brodcast group.\n     ",
    "links" : [ ]
  }, {
    "name" : "DEVICE_OUT_DEFAULT",
    "type" : "int",
    "comment" : " @hide\n     * This is not used as a returned value from {@link #getDevicesForStream}, but could be\n     *  used in the future in a set method to select whatever default device is chosen by the\n     *  platform-specific implementation.\n     ",
    "links" : [ "#getDevicesForStream" ]
  }, {
    "name" : "DEVICE_IN_BUILTIN_MIC",
    "type" : "int",
    "comment" : " @hide\n     * The audio input device code for default built-in microphone\n     ",
    "links" : [ ]
  }, {
    "name" : "DEVICE_IN_BLUETOOTH_SCO_HEADSET",
    "type" : "int",
    "comment" : " @hide\n     * The audio input device code for a Bluetooth SCO headset\n     ",
    "links" : [ ]
  }, {
    "name" : "DEVICE_IN_WIRED_HEADSET",
    "type" : "int",
    "comment" : " @hide\n     * The audio input device code for wired headset microphone\n     ",
    "links" : [ ]
  }, {
    "name" : "DEVICE_IN_HDMI",
    "type" : "int",
    "comment" : " @hide\n     * The audio input device code for HDMI\n     ",
    "links" : [ ]
  }, {
    "name" : "DEVICE_IN_HDMI_ARC",
    "type" : "int",
    "comment" : " @hide\n     * The audio input device code for HDMI ARC\n     ",
    "links" : [ ]
  }, {
    "name" : "DEVICE_IN_HDMI_EARC",
    "type" : "int",
    "comment" : " @hide\n     * The audio input device code for HDMI EARC\n     ",
    "links" : [ ]
  }, {
    "name" : "DEVICE_IN_TELEPHONY_RX",
    "type" : "int",
    "comment" : " @hide\n     * The audio input device code for telephony voice RX path\n     ",
    "links" : [ ]
  }, {
    "name" : "DEVICE_IN_BACK_MIC",
    "type" : "int",
    "comment" : " @hide\n     * The audio input device code for built-in microphone pointing to the back\n     ",
    "links" : [ ]
  }, {
    "name" : "DEVICE_IN_ANLG_DOCK_HEADSET",
    "type" : "int",
    "comment" : " @hide\n     * The audio input device code for analog from a docking station\n     ",
    "links" : [ ]
  }, {
    "name" : "DEVICE_IN_DGTL_DOCK_HEADSET",
    "type" : "int",
    "comment" : " @hide\n     * The audio input device code for digital from a docking station\n     ",
    "links" : [ ]
  }, {
    "name" : "DEVICE_IN_USB_ACCESSORY",
    "type" : "int",
    "comment" : " @hide\n     * The audio input device code for a USB audio accessory. The accessory is in USB host\n     * mode and the Android device in USB device mode\n     ",
    "links" : [ ]
  }, {
    "name" : "DEVICE_IN_USB_DEVICE",
    "type" : "int",
    "comment" : " @hide\n     * The audio input device code for a USB audio device. The device is in USB device\n     * mode and the Android device in USB host mode\n     ",
    "links" : [ ]
  }, {
    "name" : "DEVICE_IN_FM_TUNER",
    "type" : "int",
    "comment" : " @hide\n     * The audio input device code for a FM radio tuner\n     ",
    "links" : [ ]
  }, {
    "name" : "DEVICE_IN_TV_TUNER",
    "type" : "int",
    "comment" : " @hide\n     * The audio input device code for a TV tuner\n     ",
    "links" : [ ]
  }, {
    "name" : "DEVICE_IN_LINE",
    "type" : "int",
    "comment" : " @hide\n     * The audio input device code for an analog jack with line impedance detected\n     ",
    "links" : [ ]
  }, {
    "name" : "DEVICE_IN_SPDIF",
    "type" : "int",
    "comment" : " @hide\n     * The audio input device code for a S/PDIF digital connection\n     ",
    "links" : [ ]
  }, {
    "name" : "DEVICE_IN_LOOPBACK",
    "type" : "int",
    "comment" : " @hide\n     * The audio input device code for audio loopback\n     ",
    "links" : [ ]
  }, {
    "name" : "DEVICE_IN_ECHO_REFERENCE",
    "type" : "int",
    "comment" : " @hide\n     * The audio input device code for an echo reference capture point.\n     ",
    "links" : [ ]
  }, {
    "name" : "DEVICE_IN_BLE_HEADSET",
    "type" : "int",
    "comment" : " @hide\n     * The audio input device code for a BLE audio headset.\n     ",
    "links" : [ ]
  }, {
    "name" : "mDevicesForAttributesListenerToStub",
    "type" : "ConcurrentHashMap<OnDevicesForAttributesChangedListener, IDevicesForAttributesCallbackStub>",
    "comment" : " different AudioAttributes.",
    "links" : [ ]
  }, {
    "name" : "DEVICE_VOLUME_BEHAVIOR_UNSET",
    "type" : "int",
    "comment" : "\n     * @hide\n     * Volume behavior for an audio device that has no particular volume behavior set. Invalid as\n     * an argument to {@link #setDeviceVolumeBehavior(AudioDeviceAttributes, int)} and should not\n     * be returned by {@link #getDeviceVolumeBehavior(AudioDeviceAttributes)}.\n     ",
    "links" : [ "#getDeviceVolumeBehavior(AudioDeviceAttributes)", "#setDeviceVolumeBehavior(AudioDeviceAttributes" ]
  }, {
    "name" : "DEVICE_VOLUME_BEHAVIOR_VARIABLE",
    "type" : "int",
    "comment" : "\n     * @hide\n     * Volume behavior for an audio device where a software attenuation is applied\n     * @see #setDeviceVolumeBehavior(AudioDeviceAttributes, int)\n     ",
    "links" : [ ]
  }, {
    "name" : "DEVICE_VOLUME_BEHAVIOR_FULL",
    "type" : "int",
    "comment" : "\n     * @hide\n     * Volume behavior for an audio device where the volume is always set to provide no attenuation\n     *     nor gain (e.g. unit gain).\n     * @see #setDeviceVolumeBehavior(AudioDeviceAttributes, int)\n     ",
    "links" : [ ]
  }, {
    "name" : "DEVICE_VOLUME_BEHAVIOR_FIXED",
    "type" : "int",
    "comment" : "\n     * @hide\n     * Volume behavior for an audio device where the volume is either set to muted, or to provide\n     *     no attenuation nor gain (e.g. unit gain).\n     * @see #setDeviceVolumeBehavior(AudioDeviceAttributes, int)\n     ",
    "links" : [ ]
  }, {
    "name" : "DEVICE_VOLUME_BEHAVIOR_ABSOLUTE",
    "type" : "int",
    "comment" : "\n     * @hide\n     * Volume behavior for an audio device where no software attenuation is applied, and\n     *     the volume is kept synchronized between the host and the device itself through a\n     *     device-specific protocol such as BT AVRCP.\n     * @see #setDeviceVolumeBehavior(AudioDeviceAttributes, int)\n     ",
    "links" : [ ]
  }, {
    "name" : "DEVICE_VOLUME_BEHAVIOR_ABSOLUTE_MULTI_MODE",
    "type" : "int",
    "comment" : "\n     * @hide\n     * Volume behavior for an audio device where no software attenuation is applied, and\n     *     the volume is kept synchronized between the host and the device itself through a\n     *     device-specific protocol (such as for hearing aids), based on the audio mode (e.g.\n     *     normal vs in phone call).\n     * @see #setMode(int)\n     * @see #setDeviceVolumeBehavior(AudioDeviceAttributes, int)\n     ",
    "links" : [ ]
  }, {
    "name" : "DEVICE_VOLUME_BEHAVIOR_ABSOLUTE_ADJUST_ONLY",
    "type" : "int",
    "comment" : "\n     * @hide\n     * A variant of {@link #DEVICE_VOLUME_BEHAVIOR_ABSOLUTE} where the host cannot reliably set\n     * the volume percentage of the audio device. Specifically, {@link #setStreamVolume} will have\n     * no effect, or an unreliable effect.\n     ",
    "links" : [ "#setStreamVolume", "#DEVICE_VOLUME_BEHAVIOR_ABSOLUTE" ]
  }, {
    "name" : "RETURN_DEVICE_VOLUME_BEHAVIOR_ABSOLUTE_ADJUST_ONLY",
    "type" : "long",
    "comment" : "\n     * @hide\n     * Controls whether DEVICE_VOLUME_BEHAVIOR_ABSOLUTE_ADJUST_ONLY may be returned by\n     * getDeviceVolumeBehavior. If this is disabled, DEVICE_VOLUME_BEHAVIOR_FULL is returned\n     * in its place.\n     ",
    "links" : [ ]
  }, {
    "name" : "PROPERTY_OUTPUT_SAMPLE_RATE",
    "type" : "String",
    "comment" : " FIXME Deprecate",
    "links" : [ ]
  }, {
    "name" : "PROPERTY_OUTPUT_FRAMES_PER_BUFFER",
    "type" : "String",
    "comment" : " FIXME Deprecate",
    "links" : [ ]
  }, {
    "name" : "PROPERTY_SUPPORT_MIC_NEAR_ULTRASOUND",
    "type" : "String",
    "comment" : "\n     * Used as a key for {@link #getProperty} to determine if the default microphone audio source\n     * supports near-ultrasound frequencies (range of 18 - 21 kHz).\n     ",
    "links" : [ "#getProperty" ]
  }, {
    "name" : "PROPERTY_SUPPORT_SPEAKER_NEAR_ULTRASOUND",
    "type" : "String",
    "comment" : "\n     * Used as a key for {@link #getProperty} to determine if the default speaker audio path\n     * supports near-ultrasound frequencies (range of 18 - 21 kHz).\n     ",
    "links" : [ "#getProperty" ]
  }, {
    "name" : "PROPERTY_SUPPORT_AUDIO_SOURCE_UNPROCESSED",
    "type" : "String",
    "comment" : "\n     * Used as a key for {@link #getProperty} to determine if the unprocessed audio source is\n     * available and supported with the expected frequency range and level response.\n     ",
    "links" : [ "#getProperty" ]
  }, {
    "name" : "AUDIO_DEVICE_CATEGORY_UNKNOWN",
    "type" : "int",
    "comment" : "\n     * @hide\n     * Describes an audio device that has not been categorized with a specific\n     * audio type.\n     ",
    "links" : [ ]
  }, {
    "name" : "AUDIO_DEVICE_CATEGORY_OTHER",
    "type" : "int",
    "comment" : "\n     * @hide\n     * Describes an audio device which is categorized as something different.\n     ",
    "links" : [ ]
  }, {
    "name" : "AUDIO_DEVICE_CATEGORY_SPEAKER",
    "type" : "int",
    "comment" : "\n     * @hide\n     * Describes an audio device which was categorized as speakers.\n     ",
    "links" : [ ]
  }, {
    "name" : "AUDIO_DEVICE_CATEGORY_HEADPHONES",
    "type" : "int",
    "comment" : "\n     * @hide\n     * Describes an audio device which was categorized as headphones.\n     ",
    "links" : [ ]
  }, {
    "name" : "AUDIO_DEVICE_CATEGORY_CARKIT",
    "type" : "int",
    "comment" : "\n     * @hide\n     * Describes an audio device which was categorized as car-kit.\n     ",
    "links" : [ ]
  }, {
    "name" : "AUDIO_DEVICE_CATEGORY_WATCH",
    "type" : "int",
    "comment" : "\n     * @hide\n     * Describes an audio device which was categorized as watch.\n     ",
    "links" : [ ]
  }, {
    "name" : "AUDIO_DEVICE_CATEGORY_HEARING_AID",
    "type" : "int",
    "comment" : "\n     * @hide\n     * Describes an audio device which was categorized as hearing aid.\n     ",
    "links" : [ ]
  }, {
    "name" : "AUDIO_DEVICE_CATEGORY_RECEIVER",
    "type" : "int",
    "comment" : "\n     * @hide\n     * Describes an audio device which was categorized as receiver.\n     ",
    "links" : [ ]
  }, {
    "name" : "CSD_WARNING_DOSE_REACHED_1X",
    "type" : "int",
    "comment" : "\n     * @hide\n     * Sound dose warning at every 100% of dose during integration window\n     ",
    "links" : [ ]
  }, {
    "name" : "CSD_WARNING_DOSE_REPEATED_5X",
    "type" : "int",
    "comment" : "\n     * @hide\n     * Sound dose warning when 500% of dose is reached during integration window\n     ",
    "links" : [ ]
  }, {
    "name" : "CSD_WARNING_MOMENTARY_EXPOSURE",
    "type" : "int",
    "comment" : "\n     * @hide\n     * Sound dose warning after a momentary exposure event\n     ",
    "links" : [ ]
  }, {
    "name" : "CSD_WARNING_ACCUMULATION_START",
    "type" : "int",
    "comment" : "\n     * @hide\n     * Sound dose warning at every 100% of dose during integration window\n     ",
    "links" : [ ]
  }, {
    "name" : "SUCCESS",
    "type" : "int",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "ERROR",
    "type" : "int",
    "comment" : "\n     * A default error code.\n     ",
    "links" : [ ]
  }, {
    "name" : "ERROR_BAD_VALUE",
    "type" : "int",
    "comment" : " @hide\n     * CANDIDATE FOR PUBLIC API\n     ",
    "links" : [ ]
  }, {
    "name" : "ERROR_INVALID_OPERATION",
    "type" : "int",
    "comment" : " @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "ERROR_PERMISSION_DENIED",
    "type" : "int",
    "comment" : " @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "ERROR_NO_INIT",
    "type" : "int",
    "comment" : " @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "ERROR_DEAD_OBJECT",
    "type" : "int",
    "comment" : "\n     * An error code indicating that the object reporting it is no longer valid and needs to\n     * be recreated.\n     ",
    "links" : [ ]
  }, {
    "name" : "AUDIOPORT_GENERATION_INIT",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "sAudioPortGenerationLock",
    "type" : "Object",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "sAudioPortGeneration",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "sAudioPortsCached",
    "type" : "ArrayList<AudioPort>",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "sPreviousAudioPortsCached",
    "type" : "ArrayList<AudioPort>",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "sAudioPatchesCached",
    "type" : "ArrayList<AudioPatch>",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mPortListener",
    "type" : "OnAmPortUpdateListener",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "MSG_DEVICES_CALLBACK_REGISTERED",
    "type" : "int",
    "comment" : "\n     * The message sent to apps when the contents of the device list changes if they provide\n     * a {@link Handler} object to {@link registerAudioDeviceCallback}.\n     ",
    "links" : [ "registerAudioDeviceCallback", "android.media.audiopolicy.AudioVolumeGroupChangeHandler" ]
  }, {
    "name" : "MSG_DEVICES_DEVICES_ADDED",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "MSG_DEVICES_DEVICES_REMOVED",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mDeviceCallbacks",
    "type" : "ArrayMap<AudioDeviceCallback, NativeEventHandlerDelegate>",
    "comment" : "\n     * The list of {@link AudioDeviceCallback} objects to receive add/remove notifications.\n     ",
    "links" : [ "android.media.AudioDeviceCallback" ]
  }, {
    "name" : "GET_DEVICES_INPUTS",
    "type" : "int",
    "comment" : "\n     * Specifies to the {@link AudioManager#getDevices(int)} method to include\n     * source (i.e. input) audio devices.\n     ",
    "links" : [ "android.media.AudioManager#getDevices(int)" ]
  }, {
    "name" : "GET_DEVICES_OUTPUTS",
    "type" : "int",
    "comment" : "\n     * Specifies to the {@link AudioManager#getDevices(int)} method to include\n     * sink (i.e. output) audio devices.\n     ",
    "links" : [ "android.media.AudioManager#getDevices(int)" ]
  }, {
    "name" : "GET_DEVICES_ALL",
    "type" : "int",
    "comment" : "\n     * Specifies to the {@link AudioManager#getDevices(int)} method to include both\n     * source and sink devices.\n     ",
    "links" : [ "android.media.AudioManager#getDevices(int)" ]
  }, {
    "name" : "mPreviousPorts",
    "type" : "ArrayList<AudioDevicePort>",
    "comment" : " of the ports that exist at the time of the last notification.",
    "links" : [ ]
  }, {
    "name" : "mAudioServerStateExec",
    "type" : "Executor",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mAudioServerStateCb",
    "type" : "AudioServerStateCallback",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mAudioServerStateCbLock",
    "type" : "Object",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mAudioServerStateDispatcher",
    "type" : "IAudioServerStateDispatcher",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mCommDeviceChangedListenerMgr",
    "type" : "CallbackUtil.LazyListenerManager<OnCommunicationDeviceChangedListener>",
    "comment" : "\n     * manages the OnCommunicationDeviceChangedListener listeners and the\n     * CommunicationDeviceDispatcherStub\n     ",
    "links" : [ ]
  }, {
    "name" : "CALL_REDIRECT_NONE",
    "type" : "int",
    "comment" : "\n     * Not used for call redirection\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "CALL_REDIRECT_PSTN",
    "type" : "int",
    "comment" : "\n     * Used to redirect  PSTN call\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "CALL_REDIRECT_VOIP",
    "type" : "int",
    "comment" : "\n     * Used to redirect  VoIP call\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "mCallRedirectionLock",
    "type" : "Object",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mCallRedirectionModeListener",
    "type" : "CallInjectionModeChangedListener",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mCallIRedirectionClients",
    "type" : "ArrayList<CallIRedirectionClientInfo>",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mPrefMixerAttributesListenerMgr",
    "type" : "CallbackUtil.LazyListenerManager<OnPreferredMixerAttributesChangedListener>",
    "comment" : "\n     * Manage the {@link OnPreferredMixerAttributesChangedListener} listeners and the\n     * {@link PreferredMixerAttributesDispatcherStub}.\n     ",
    "links" : [ "OnPreferredMixerAttributesChangedListener", "PreferredMixerAttributesDispatcherStub" ]
  }, {
    "name" : "mStreamAliasingListenerMgr",
    "type" : "CallbackUtil.LazyListenerManager<Runnable>",
    "comment" : "\n     * manages the stream aliasing listeners and StreamAliasingDispatcherStub\n     ",
    "links" : [ ]
  }, {
    "name" : "mMuteAwaitConnectionListenerLock",
    "type" : "Object",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mMuteAwaitConnectionListeners",
    "type" : "ArrayList<ListenerInfo<MuteAwaitConnectionCallback>>",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mMuteAwaitConnDispatcherStub",
    "type" : "MuteAwaitConnectionDispatcherStub",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mIsAutomotive",
    "type" : "boolean",
    "comment" : "",
    "links" : [ ]
  } ],
  "methods" : [ {
    "name" : "public static final int[] getPublicStreamTypes()",
    "returnType" : "int[]",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "public static final String adjustToString(int adj)",
    "returnType" : "String",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "public static String flagsToString(int flags)",
    "returnType" : "String",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "private Context getContext()",
    "returnType" : "Context",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private void setContext(Context context)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : " static IAudioService getService()",
    "returnType" : "IAudioService",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private VirtualDeviceManager getVirtualDeviceManager()",
    "returnType" : "VirtualDeviceManager",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public void dispatchMediaKeyEvent(KeyEvent keyEvent)",
    "returnType" : "void",
    "comment" : "\n     * Sends a simulated key event for a media button. To simulate a key press, you must first send\n     * a KeyEvent built with a {@link KeyEvent#ACTION_DOWN} action, then another event with the\n     * {@link KeyEvent#ACTION_UP} action.\n     *\n     * <p>The key event will be sent to the current media key event consumer which registered with\n     * {@link AudioManager#registerMediaButtonEventReceiver(PendingIntent)}.\n     *\n     * @param keyEvent a media session {@link KeyEvent}, as defined by {@link\n     *     KeyEvent#isMediaSessionKey}.\n     ",
    "links" : [ "android.view.KeyEvent#ACTION_UP", "android.view.KeyEvent", "android.view.KeyEvent#ACTION_DOWN", "android.media.AudioManager#registerMediaButtonEventReceiver(PendingIntent)", "android.view.KeyEvent#isMediaSessionKey" ]
  }, {
    "name" : "public void preDispatchKeyEvent(KeyEvent event, int stream)",
    "returnType" : "void",
    "comment" : "\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean isVolumeFixed()",
    "returnType" : "boolean",
    "comment" : "\n     * Indicates if the device implements a fixed volume policy.\n     * <p>Some devices may not have volume control and may operate at a fixed volume,\n     * and may not enable muting or changing the volume of audio streams.\n     * This method will return true on such devices.\n     * <p>The following APIs have no effect when volume is fixed:\n     * <ul>\n     *   <li> {@link #adjustVolume(int, int)}\n     *   <li> {@link #adjustSuggestedStreamVolume(int, int, int)}\n     *   <li> {@link #adjustStreamVolume(int, int, int)}\n     *   <li> {@link #setStreamVolume(int, int, int)}\n     *   <li> {@link #setRingerMode(int)}\n     *   <li> {@link #setStreamSolo(int, boolean)}\n     *   <li> {@link #setStreamMute(int, boolean)}\n     * </ul>\n     ",
    "links" : [ "#setStreamVolume(int", "#adjustStreamVolume(int", "#setRingerMode(int)", "#adjustSuggestedStreamVolume(int", "#setStreamMute(int", "#setStreamSolo(int", "#adjustVolume(int" ]
  }, {
    "name" : "public void adjustStreamVolume(int streamType, int direction, @PublicVolumeFlags int flags)",
    "returnType" : "void",
    "comment" : "\n     * Adjusts the volume of a particular stream by one step in a direction.\n     * <p>\n     * This method should only be used by applications that replace the platform-wide\n     * management of audio settings or the main telephony application.\n     * <p>This method has no effect if the device implements a fixed volume policy\n     * as indicated by {@link #isVolumeFixed()}.\n     * <p>From N onward, ringer mode adjustments that would toggle Do Not Disturb are not allowed\n     * unless the app has been granted Do Not Disturb Access.\n     * See {@link NotificationManager#isNotificationPolicyAccessGranted()}.\n     *\n     * @param streamType The stream type to adjust. One of {@link #STREAM_VOICE_CALL},\n     * {@link #STREAM_SYSTEM}, {@link #STREAM_RING}, {@link #STREAM_MUSIC},\n     * {@link #STREAM_ALARM} or {@link #STREAM_ACCESSIBILITY}.\n     * @param direction The direction to adjust the volume. One of\n     *            {@link #ADJUST_LOWER}, {@link #ADJUST_RAISE}, or\n     *            {@link #ADJUST_SAME}.\n     * @param flags\n     * @see #adjustVolume(int, int)\n     * @see #setStreamVolume(int, int, int)\n     * @throws SecurityException if the adjustment triggers a Do Not Disturb change\n     *   and the caller is not granted notification policy access.\n     ",
    "links" : [ "#STREAM_ALARM", "#ADJUST_LOWER", "#isVolumeFixed()", "#STREAM_SYSTEM", "#ADJUST_SAME", "android.app.NotificationManager#isNotificationPolicyAccessGranted()", "#STREAM_VOICE_CALL", "#STREAM_MUSIC", "#STREAM_RING", "#ADJUST_RAISE", "#STREAM_ACCESSIBILITY" ]
  }, {
    "name" : "public void adjustVolume(int direction, @PublicVolumeFlags int flags)",
    "returnType" : "void",
    "comment" : "\n     * Adjusts the volume of the most relevant stream. For example, if a call is\n     * active, it will have the highest priority regardless of if the in-call\n     * screen is showing. Another example, if music is playing in the background\n     * and a call is not active, the music stream will be adjusted.\n     * <p>\n     * This method should only be used by applications that replace the\n     * platform-wide management of audio settings or the main telephony\n     * application.\n     * <p>\n     * This method has no effect if the device implements a fixed volume policy\n     * as indicated by {@link #isVolumeFixed()}.\n     *\n     * @param direction The direction to adjust the volume. One of\n     *            {@link #ADJUST_LOWER}, {@link #ADJUST_RAISE},\n     *            {@link #ADJUST_SAME}, {@link #ADJUST_MUTE},\n     *            {@link #ADJUST_UNMUTE}, or {@link #ADJUST_TOGGLE_MUTE}.\n     * @param flags\n     * @see #adjustSuggestedStreamVolume(int, int, int)\n     * @see #adjustStreamVolume(int, int, int)\n     * @see #setStreamVolume(int, int, int)\n     * @see #isVolumeFixed()\n     ",
    "links" : [ "#ADJUST_LOWER", "#ADJUST_MUTE", "#ADJUST_TOGGLE_MUTE", "#isVolumeFixed()", "#ADJUST_SAME", "#ADJUST_RAISE", "#ADJUST_UNMUTE" ]
  }, {
    "name" : "public void adjustSuggestedStreamVolume(int direction, int suggestedStreamType, @PublicVolumeFlags int flags)",
    "returnType" : "void",
    "comment" : "\n     * Adjusts the volume of the most relevant stream, or the given fallback\n     * stream.\n     * <p>\n     * This method should only be used by applications that replace the\n     * platform-wide management of audio settings or the main telephony\n     * application.\n     * <p>\n     * This method has no effect if the device implements a fixed volume policy\n     * as indicated by {@link #isVolumeFixed()}.\n     *\n     * @param direction The direction to adjust the volume. One of\n     *            {@link #ADJUST_LOWER}, {@link #ADJUST_RAISE},\n     *            {@link #ADJUST_SAME}, {@link #ADJUST_MUTE},\n     *            {@link #ADJUST_UNMUTE}, or {@link #ADJUST_TOGGLE_MUTE}.\n     * @param suggestedStreamType The stream type that will be used if there\n     *            isn't a relevant stream. {@link #USE_DEFAULT_STREAM_TYPE} is\n     *            valid here.\n     * @param flags\n     * @see #adjustVolume(int, int)\n     * @see #adjustStreamVolume(int, int, int)\n     * @see #setStreamVolume(int, int, int)\n     * @see #isVolumeFixed()\n     ",
    "links" : [ "#ADJUST_LOWER", "#ADJUST_MUTE", "#ADJUST_TOGGLE_MUTE", "#isVolumeFixed()", "#ADJUST_SAME", "#USE_DEFAULT_STREAM_TYPE", "#ADJUST_RAISE", "#ADJUST_UNMUTE" ]
  }, {
    "name" : "public void setMasterMute(boolean mute, int flags)",
    "returnType" : "void",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "public int getRingerMode()",
    "returnType" : "int",
    "comment" : "\n     * Returns the current ringtone mode.\n     *\n     * @return The current ringtone mode, one of {@link #RINGER_MODE_NORMAL},\n     *         {@link #RINGER_MODE_SILENT}, or {@link #RINGER_MODE_VIBRATE}.\n     * @see #setRingerMode(int)\n     ",
    "links" : [ "#RINGER_MODE_SILENT", "#RINGER_MODE_VIBRATE", "#RINGER_MODE_NORMAL" ]
  }, {
    "name" : "public boolean isRampingRingerEnabled()",
    "returnType" : "boolean",
    "comment" : "\n     * Returns the current user setting for ramping ringer on incoming phone call ringtone.\n     *\n     * @return true if the incoming phone call ringtone is configured to gradually increase its\n     * volume, false otherwise.\n     ",
    "links" : [ ]
  }, {
    "name" : "public void setRampingRingerEnabled(boolean enabled)",
    "returnType" : "void",
    "comment" : "\n     * Sets the flag for enabling ramping ringer on incoming phone call ringtone.\n     *\n     * @see #isRampingRingerEnabled()\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public static boolean isValidRingerMode(int ringerMode)",
    "returnType" : "boolean",
    "comment" : "\n     * Checks valid ringer mode values.\n     *\n     * @return true if the ringer mode indicated is valid, false otherwise.\n     *\n     * @see #setRingerMode(int)\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public int getStreamMaxVolume(int streamType)",
    "returnType" : "int",
    "comment" : "\n     * Returns the maximum volume index for a particular stream.\n     *\n     * @param streamType The stream type whose maximum volume index is returned.\n     * @return The maximum valid volume index for the stream.\n     * @see #getStreamVolume(int)\n     ",
    "links" : [ ]
  }, {
    "name" : "public int getStreamMinVolume(int streamType)",
    "returnType" : "int",
    "comment" : "\n     * Returns the minimum volume index for a particular stream.\n     * @param streamType The stream type whose minimum volume index is returned. Must be one of\n     *     {@link #STREAM_VOICE_CALL}, {@link #STREAM_SYSTEM},\n     *     {@link #STREAM_RING}, {@link #STREAM_MUSIC}, {@link #STREAM_ALARM},\n     *     {@link #STREAM_NOTIFICATION}, {@link #STREAM_DTMF} or {@link #STREAM_ACCESSIBILITY}.\n     * @return The minimum valid volume index for the stream.\n     * @see #getStreamVolume(int)\n     ",
    "links" : [ "#STREAM_ALARM", "#STREAM_SYSTEM", "#STREAM_VOICE_CALL", "#STREAM_MUSIC", "#STREAM_RING", "#STREAM_NOTIFICATION", "#STREAM_DTMF", "#STREAM_ACCESSIBILITY" ]
  }, {
    "name" : "public int getStreamMinVolumeInt(int streamType)",
    "returnType" : "int",
    "comment" : "\n     * @hide\n     * Same as {@link #getStreamMinVolume(int)} but without the check on the public stream type.\n     * @param streamType The stream type whose minimum volume index is returned.\n     * @return The minimum valid volume index for the stream.\n     * @see #getStreamVolume(int)\n     ",
    "links" : [ "#getStreamMinVolume(int)" ]
  }, {
    "name" : "public int getStreamVolume(int streamType)",
    "returnType" : "int",
    "comment" : "\n     * Returns the current volume index for a particular stream.\n     *\n     * @param streamType The stream type whose volume index is returned.\n     * @return The current volume index for the stream.\n     * @see #getStreamMaxVolume(int)\n     * @see #setStreamVolume(int, int, int)\n     ",
    "links" : [ ]
  }, {
    "name" : "public float getStreamVolumeDb(@PublicStreamTypes int streamType, int index, @AudioDeviceInfo.AudioDeviceTypeOut int deviceType)",
    "returnType" : "float",
    "comment" : "\n     * Returns the volume in dB (decibel) for the given stream type at the given volume index, on\n     * the given type of audio output device.\n     * @param streamType stream type for which the volume is queried.\n     * @param index the volume index for which the volume is queried. The index value must be\n     *     between the minimum and maximum index values for the given stream type (see\n     *     {@link #getStreamMinVolume(int)} and {@link #getStreamMaxVolume(int)}).\n     * @param deviceType the type of audio output device for which volume is queried.\n     * @return a volume expressed in dB.\n     *     A negative value indicates the audio signal is attenuated. A typical maximum value\n     *     at the maximum volume index is 0 dB (no attenuation nor amplification). Muting is\n     *     reflected by a value of {@link Float#NEGATIVE_INFINITY}.\n     ",
    "links" : [ "#getStreamMinVolume(int)", "android.media.Float#NEGATIVE_INFINITY", "#getStreamMaxVolume(int)" ]
  }, {
    "name" : "public static boolean isPublicStreamType(int streamType)",
    "returnType" : "boolean",
    "comment" : "\n     * @hide\n     * Checks whether a stream type is part of the public SDK\n     * @param streamType\n     * @return true if the stream type is available in SDK\n     ",
    "links" : [ ]
  }, {
    "name" : "public int getLastAudibleStreamVolume(int streamType)",
    "returnType" : "int",
    "comment" : "\n     * Get last audible volume before stream was muted.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public int getUiSoundsStreamType()",
    "returnType" : "int",
    "comment" : "\n     * Get the stream type whose volume is driving the UI sounds volume.\n     * UI sounds are screen lock/unlock, camera shutter, key clicks...\n     * It is assumed that this stream type is also tied to ringer mode changes.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public void setRingerMode(int ringerMode)",
    "returnType" : "void",
    "comment" : "\n     * Sets the ringer mode.\n     * <p>\n     * Silent mode will mute the volume and will not vibrate. Vibrate mode will\n     * mute the volume and vibrate. Normal mode will be audible and may vibrate\n     * according to user settings.\n     * <p>This method has no effect if the device implements a fixed volume policy\n     * as indicated by {@link #isVolumeFixed()}.\n     * * <p>From N onward, ringer mode adjustments that would toggle Do Not Disturb are not allowed\n     * unless the app has been granted Do Not Disturb Access.\n     * See {@link NotificationManager#isNotificationPolicyAccessGranted()}.\n     * @param ringerMode The ringer mode, one of {@link #RINGER_MODE_NORMAL},\n     *            {@link #RINGER_MODE_SILENT}, or {@link #RINGER_MODE_VIBRATE}.\n     * @see #getRingerMode()\n     * @see #isVolumeFixed()\n     ",
    "links" : [ "#isVolumeFixed()", "#RINGER_MODE_SILENT", "android.app.NotificationManager#isNotificationPolicyAccessGranted()", "#RINGER_MODE_VIBRATE", "#RINGER_MODE_NORMAL" ]
  }, {
    "name" : "public void setStreamVolume(int streamType, int index, @PublicVolumeFlags int flags)",
    "returnType" : "void",
    "comment" : "\n     * Sets the volume index for a particular stream.\n     * <p>This method has no effect if the device implements a fixed volume policy\n     * as indicated by {@link #isVolumeFixed()}.\n     * <p>From N onward, volume adjustments that would toggle Do Not Disturb are not allowed unless\n     * the app has been granted Do Not Disturb Access.\n     * See {@link NotificationManager#isNotificationPolicyAccessGranted()}.\n     * @param streamType The stream whose volume index should be set.\n     * @param index The volume index to set. See\n     *            {@link #getStreamMaxVolume(int)} for the largest valid value.\n     * @param flags\n     * @see #getStreamMaxVolume(int)\n     * @see #getStreamVolume(int)\n     * @see #isVolumeFixed()\n     * @throws SecurityException if the volume change triggers a Do Not Disturb change\n     *   and the caller is not granted notification policy access.\n     ",
    "links" : [ "#isVolumeFixed()", "#getStreamMaxVolume(int)", "android.app.NotificationManager#isNotificationPolicyAccessGranted()" ]
  }, {
    "name" : "public void setVolumeIndexForAttributes(@NonNull AudioAttributes attr, int index, @SystemVolumeFlags int flags)",
    "returnType" : "void",
    "comment" : "\n     * Sets the volume index for a particular {@link AudioAttributes}.\n     * @param attr The {@link AudioAttributes} whose volume index should be set.\n     * @param index The volume index to set. See\n     *          {@link #getMaxVolumeIndexForAttributes(AudioAttributes)} for the largest valid value\n     *          {@link #getMinVolumeIndexForAttributes(AudioAttributes)} for the lowest valid value.\n     * @param flags\n     * @see #getMaxVolumeIndexForAttributes(AudioAttributes)\n     * @see #getMinVolumeIndexForAttributes(AudioAttributes)\n     * @see #isVolumeFixed()\n     * @hide\n     ",
    "links" : [ "#getMaxVolumeIndexForAttributes(AudioAttributes)", "android.media.AudioAttributes", "#getMinVolumeIndexForAttributes(AudioAttributes)" ]
  }, {
    "name" : "public int getVolumeIndexForAttributes(@NonNull AudioAttributes attr)",
    "returnType" : "int",
    "comment" : "\n     * Returns the current volume index for a particular {@link AudioAttributes}.\n     *\n     * @param attr The {@link AudioAttributes} whose volume index is returned.\n     * @return The current volume index for the stream.\n     * @see #getMaxVolumeIndexForAttributes(AudioAttributes)\n     * @see #getMinVolumeIndexForAttributes(AudioAttributes)\n     * @see #setVolumeForAttributes(AudioAttributes, int, int)\n     * @hide\n     ",
    "links" : [ "android.media.AudioAttributes" ]
  }, {
    "name" : "public int getMaxVolumeIndexForAttributes(@NonNull AudioAttributes attr)",
    "returnType" : "int",
    "comment" : "\n     * Returns the maximum volume index for a particular {@link AudioAttributes}.\n     *\n     * @param attr The {@link AudioAttributes} whose maximum volume index is returned.\n     * @return The maximum valid volume index for the {@link AudioAttributes}.\n     * @see #getVolumeIndexForAttributes(AudioAttributes)\n     * @hide\n     ",
    "links" : [ "android.media.AudioAttributes" ]
  }, {
    "name" : "public int getMinVolumeIndexForAttributes(@NonNull AudioAttributes attr)",
    "returnType" : "int",
    "comment" : "\n     * Returns the minimum volume index for a particular {@link AudioAttributes}.\n     *\n     * @param attr The {@link AudioAttributes} whose minimum volume index is returned.\n     * @return The minimum valid volume index for the {@link AudioAttributes}.\n     * @see #getVolumeIndexForAttributes(AudioAttributes)\n     * @hide\n     ",
    "links" : [ "android.media.AudioAttributes" ]
  }, {
    "name" : "public int getVolumeGroupIdForAttributes(@NonNull AudioAttributes attributes)",
    "returnType" : "int",
    "comment" : "\n     * Returns the volume group id associated to the given {@link AudioAttributes}.\n     *\n     * @param attributes The {@link AudioAttributes} to consider.\n     * @return audio volume group id supporting the given {@link AudioAttributes} if found,\n     * {@code android.media.audiopolicy.AudioVolumeGroup.DEFAULT_VOLUME_GROUP} otherwise.\n     ",
    "links" : [ "android.media.AudioAttributes" ]
  }, {
    "name" : "public void setVolumeGroupVolumeIndex(int groupId, int index, @SystemVolumeFlags int flags)",
    "returnType" : "void",
    "comment" : "\n     * Sets the volume index for a particular group associated to given id.\n     * <p> Call first in prior {@link #getVolumeGroupIdForAttributes(AudioAttributes)}\n     * to retrieve the volume group id supporting the given {@link AudioAttributes}.\n     *\n     * @param groupId of the {@link android.media.audiopolicy.AudioVolumeGroup} to consider.\n     * @param index The volume index to set. See\n     *          {@link #getVolumeGroupMaxVolumeIndex(id)} for the largest valid value\n     *          {@link #getVolumeGroupMinVolumeIndex(id)} for the lowest valid value.\n     * @param flags\n     * @hide\n     ",
    "links" : [ "#getVolumeGroupMaxVolumeIndex(id)", "android.media.audiopolicy.AudioVolumeGroup", "android.media.AudioAttributes", "#getVolumeGroupMinVolumeIndex(id)", "#getVolumeGroupIdForAttributes(AudioAttributes)" ]
  }, {
    "name" : "public int getVolumeGroupVolumeIndex(int groupId)",
    "returnType" : "int",
    "comment" : "\n     * Returns the current volume index for a particular group associated to given id.\n     * <p> Call first in prior {@link #getVolumeGroupIdForAttributes(AudioAttributes)}\n     * to retrieve the volume group id supporting the given {@link AudioAttributes}.\n     *\n     * @param groupId of the {@link android.media.audiopolicy.AudioVolumeGroup} to consider.\n     * @return The current volume index for the stream.\n     * @hide\n     ",
    "links" : [ "android.media.audiopolicy.AudioVolumeGroup", "android.media.AudioAttributes", "#getVolumeGroupIdForAttributes(AudioAttributes)" ]
  }, {
    "name" : "public int getVolumeGroupMaxVolumeIndex(int groupId)",
    "returnType" : "int",
    "comment" : "\n     * Returns the maximum volume index for a particular group associated to given id.\n     * <p> Call first in prior {@link #getVolumeGroupIdForAttributes(AudioAttributes)}\n     * to retrieve the volume group id supporting the given {@link AudioAttributes}.\n     *\n     * @param groupId of the {@link android.media.audiopolicy.AudioVolumeGroup} to consider.\n     * @return The maximum valid volume index for the {@link AudioAttributes}.\n     * @hide\n     ",
    "links" : [ "android.media.audiopolicy.AudioVolumeGroup", "android.media.AudioAttributes", "#getVolumeGroupIdForAttributes(AudioAttributes)" ]
  }, {
    "name" : "public int getVolumeGroupMinVolumeIndex(int groupId)",
    "returnType" : "int",
    "comment" : "\n     * Returns the minimum volume index for a particular group associated to given id.\n     * <p> Call first in prior {@link #getVolumeGroupIdForAttributes(AudioAttributes)}\n     * to retrieve the volume group id supporting the given {@link AudioAttributes}.\n     *\n     * @param groupId of the {@link android.media.audiopolicy.AudioVolumeGroup} to consider.\n     * @return The minimum valid volume index for the {@link AudioAttributes}.\n     * @hide\n     ",
    "links" : [ "android.media.audiopolicy.AudioVolumeGroup", "android.media.AudioAttributes", "#getVolumeGroupIdForAttributes(AudioAttributes)" ]
  }, {
    "name" : "public void adjustVolumeGroupVolume(int groupId, int direction, @PublicVolumeFlags int flags)",
    "returnType" : "void",
    "comment" : "\n     * Adjusts the volume of a particular group associated to given id by one step in a direction.\n     * <p> If the volume group is associated to a stream type, it fallbacks on\n     * {@link #adjustStreamVolume(int, int, int)} for compatibility reason.\n     * <p> Call first in prior {@link #getVolumeGroupIdForAttributes(AudioAttributes)} to retrieve\n     * the volume group id supporting the given {@link AudioAttributes}.\n     *\n     * @param groupId of the audio volume group to consider.\n     * @param direction The direction to adjust the volume. One of\n     *            {@link #ADJUST_LOWER}, {@link #ADJUST_RAISE}, or\n     *            {@link #ADJUST_SAME}.\n     * @param flags\n     * @throws SecurityException if the adjustment triggers a Do Not Disturb change and the caller\n     * is not granted notification policy access.\n     ",
    "links" : [ "#ADJUST_LOWER", "#ADJUST_SAME", "#adjustStreamVolume(int", "android.media.AudioAttributes", "#getVolumeGroupIdForAttributes(AudioAttributes)", "#ADJUST_RAISE" ]
  }, {
    "name" : "public int getLastAudibleVolumeForVolumeGroup(int groupId)",
    "returnType" : "int",
    "comment" : "\n     * Get last audible volume of the group associated to given id before it was muted.\n     * <p> Call first in prior {@link #getVolumeGroupIdForAttributes(AudioAttributes)} to retrieve\n     * the volume group id supporting the given {@link AudioAttributes}.\n     *\n     * @param groupId of the {@link android.media.audiopolicy.AudioVolumeGroup} to consider.\n     * @return current volume if not muted, volume before muted otherwise.\n     * @hide\n     ",
    "links" : [ "android.media.audiopolicy.AudioVolumeGroup", "android.media.AudioAttributes", "#getVolumeGroupIdForAttributes(AudioAttributes)" ]
  }, {
    "name" : "public boolean isVolumeGroupMuted(int groupId)",
    "returnType" : "boolean",
    "comment" : "\n     * Returns the current mute state for a particular volume group associated to the given id.\n     * <p> Call first in prior {@link #getVolumeGroupIdForAttributes(AudioAttributes)} to retrieve\n     * the volume group id supporting the given {@link AudioAttributes}.\n     *\n     * @param groupId of the audio volume group to consider.\n     * @return The mute state for the given audio volume group id.\n     * @see #adjustVolumeGroupVolume(int, int, int)\n     ",
    "links" : [ "android.media.AudioAttributes", "#getVolumeGroupIdForAttributes(AudioAttributes)" ]
  }, {
    "name" : "public void setSupportedSystemUsages(@NonNull @AttributeSystemUsage int[] systemUsages)",
    "returnType" : "void",
    "comment" : "\n     * Set the system usages to be supported on this device.\n     * @param systemUsages array of system usages to support {@link AttributeSystemUsage}\n     * @hide\n     ",
    "links" : [ "android.media.AudioAttributes.AttributeSystemUsage" ]
  }, {
    "name" : "public int[] getSupportedSystemUsages()",
    "returnType" : "int[]",
    "comment" : "\n     * Get the system usages supported on this device.\n     * @return array of supported system usages {@link AttributeSystemUsage}\n     * @hide\n     ",
    "links" : [ "android.media.AudioAttributes.AttributeSystemUsage" ]
  }, {
    "name" : "public void setStreamSolo(int streamType, boolean state)",
    "returnType" : "void",
    "comment" : "\n     * Solo or unsolo a particular stream.\n     * <p>\n     * Do not use. This method has been deprecated and is now a no-op.\n     * {@link #requestAudioFocus} should be used for exclusive audio playback.\n     *\n     * @param streamType The stream to be soloed/unsoloed.\n     * @param state The required solo state: true for solo ON, false for solo\n     *            OFF\n     * @see #isVolumeFixed()\n     * @deprecated Do not use. If you need exclusive audio playback use\n     *             {@link #requestAudioFocus}.\n     ",
    "links" : [ "#requestAudioFocus" ]
  }, {
    "name" : "public void setStreamMute(int streamType, boolean state)",
    "returnType" : "void",
    "comment" : "\n     * Mute or unmute an audio stream.\n     * <p>\n     * This method should only be used by applications that replace the\n     * platform-wide management of audio settings or the main telephony\n     * application.\n     * <p>\n     * This method has no effect if the device implements a fixed volume policy\n     * as indicated by {@link #isVolumeFixed()}.\n     * <p>\n     * This method was deprecated in API level 22. Prior to API level 22 this\n     * method had significantly different behavior and should be used carefully.\n     * The following applies only to pre-22 platforms:\n     * <ul>\n     * <li>The mute command is protected against client process death: if a\n     * process with an active mute request on a stream dies, this stream will be\n     * unmuted automatically.</li>\n     * <li>The mute requests for a given stream are cumulative: the AudioManager\n     * can receive several mute requests from one or more clients and the stream\n     * will be unmuted only when the same number of unmute requests are\n     * received.</li>\n     * <li>For a better user experience, applications MUST unmute a muted stream\n     * in onPause() and mute is again in onResume() if appropriate.</li>\n     * </ul>\n     *\n     * @param streamType The stream to be muted/unmuted.\n     * @param state The required mute state: true for mute ON, false for mute\n     *            OFF\n     * @see #isVolumeFixed()\n     * @deprecated Use {@link #adjustStreamVolume(int, int, int)} with\n     *             {@link #ADJUST_MUTE} or {@link #ADJUST_UNMUTE} instead.\n     ",
    "links" : [ "#ADJUST_MUTE", "#isVolumeFixed()", "#adjustStreamVolume(int", "#ADJUST_UNMUTE" ]
  }, {
    "name" : "public boolean isStreamMute(int streamType)",
    "returnType" : "boolean",
    "comment" : "\n     * Returns the current mute state for a particular stream.\n     *\n     * @param streamType The stream to get mute state for.\n     * @return The mute state for the given stream.\n     * @see #adjustStreamVolume(int, int, int)\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean isMasterMute()",
    "returnType" : "boolean",
    "comment" : "\n     * get master mute state.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public void forceVolumeControlStream(int streamType)",
    "returnType" : "void",
    "comment" : "\n     * forces the stream controlled by hard volume keys\n     * specifying streamType == -1 releases control to the\n     * logic.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean shouldVibrate(int vibrateType)",
    "returnType" : "boolean",
    "comment" : "\n     * Returns whether a particular type should vibrate according to user\n     * settings and the current ringer mode.\n     * <p>\n     * This shouldn't be needed by most clients that use notifications to\n     * vibrate. The notification manager will not vibrate if the policy doesn't\n     * allow it, so the client should always set a vibrate pattern and let the\n     * notification manager control whether or not to actually vibrate.\n     *\n     * @param vibrateType The type of vibrate. One of\n     *            {@link #VIBRATE_TYPE_NOTIFICATION} or\n     *            {@link #VIBRATE_TYPE_RINGER}.\n     * @return Whether the type should vibrate at the instant this method is\n     *         called.\n     * @see #setVibrateSetting(int, int)\n     * @see #getVibrateSetting(int)\n     * @deprecated Applications should maintain their own vibrate policy based on\n     * current ringer mode that can be queried via {@link #getRingerMode()}.\n     ",
    "links" : [ "#getRingerMode()", "#VIBRATE_TYPE_NOTIFICATION", "#VIBRATE_TYPE_RINGER" ]
  }, {
    "name" : "public int getVibrateSetting(int vibrateType)",
    "returnType" : "int",
    "comment" : "\n     * Returns whether the user's vibrate setting for a vibrate type.\n     * <p>\n     * This shouldn't be needed by most clients that want to vibrate, instead\n     * see {@link #shouldVibrate(int)}.\n     *\n     * @param vibrateType The type of vibrate. One of\n     *            {@link #VIBRATE_TYPE_NOTIFICATION} or\n     *            {@link #VIBRATE_TYPE_RINGER}.\n     * @return The vibrate setting, one of {@link #VIBRATE_SETTING_ON},\n     *         {@link #VIBRATE_SETTING_OFF}, or\n     *         {@link #VIBRATE_SETTING_ONLY_SILENT}.\n     * @see #setVibrateSetting(int, int)\n     * @see #shouldVibrate(int)\n     * @deprecated Applications should maintain their own vibrate policy based on\n     * current ringer mode that can be queried via {@link #getRingerMode()}.\n     ",
    "links" : [ "#VIBRATE_SETTING_ONLY_SILENT", "#getRingerMode()", "#shouldVibrate(int)", "#VIBRATE_TYPE_NOTIFICATION", "#VIBRATE_SETTING_ON", "#VIBRATE_TYPE_RINGER", "#VIBRATE_SETTING_OFF" ]
  }, {
    "name" : "public void setVibrateSetting(int vibrateType, int vibrateSetting)",
    "returnType" : "void",
    "comment" : "\n     * Sets the setting for when the vibrate type should vibrate.\n     * <p>\n     * This method should only be used by applications that replace the platform-wide\n     * management of audio settings or the main telephony application.\n     *\n     * @param vibrateType The type of vibrate. One of\n     *            {@link #VIBRATE_TYPE_NOTIFICATION} or\n     *            {@link #VIBRATE_TYPE_RINGER}.\n     * @param vibrateSetting The vibrate setting, one of\n     *            {@link #VIBRATE_SETTING_ON},\n     *            {@link #VIBRATE_SETTING_OFF}, or\n     *            {@link #VIBRATE_SETTING_ONLY_SILENT}.\n     * @see #getVibrateSetting(int)\n     * @see #shouldVibrate(int)\n     * @deprecated Applications should maintain their own vibrate policy based on\n     * current ringer mode that can be queried via {@link #getRingerMode()}.\n     ",
    "links" : [ "#VIBRATE_SETTING_ONLY_SILENT", "#getRingerMode()", "#VIBRATE_TYPE_NOTIFICATION", "#VIBRATE_SETTING_ON", "#VIBRATE_TYPE_RINGER", "#VIBRATE_SETTING_OFF" ]
  }, {
    "name" : "public void setSpeakerphoneOn(boolean on)",
    "returnType" : "void",
    "comment" : "\n     * Sets the speakerphone on or off.\n     * <p>\n     * This method should only be used by applications that replace the platform-wide\n     * management of audio settings or the main telephony application.\n     *\n     * @param on set <var>true</var> to turn on speakerphone;\n     *           <var>false</var> to turn it off\n     * @deprecated Use {@link AudioManager#setCommunicationDevice(AudioDeviceInfo)} or\n     *           {@link AudioManager#clearCommunicationDevice()} instead.\n     ",
    "links" : [ "android.media.AudioManager#setCommunicationDevice(AudioDeviceInfo)", "android.media.AudioManager#clearCommunicationDevice()" ]
  }, {
    "name" : "public boolean isSpeakerphoneOn()",
    "returnType" : "boolean",
    "comment" : "\n     * Checks whether the speakerphone is on or off.\n     *\n     * @return true if speakerphone is on, false if it's off\n     * @deprecated Use {@link AudioManager#getCommunicationDevice()} instead.\n     ",
    "links" : [ "android.media.AudioManager#getCommunicationDevice()" ]
  }, {
    "name" : "public void setAllowedCapturePolicy(@AudioAttributes.CapturePolicy int capturePolicy)",
    "returnType" : "void",
    "comment" : "\n     * Specifies whether the audio played by this app may or may not be captured by other apps or\n     * the system.\n     *\n     * The default is {@link AudioAttributes#ALLOW_CAPTURE_BY_ALL}.\n     *\n     * There are multiple ways to set this policy:\n     * <ul>\n     * <li> for each track independently, see\n     *    {@link AudioAttributes.Builder#setAllowedCapturePolicy(int)} </li>\n     * <li> application-wide at runtime, with this method </li>\n     * <li> application-wide at build time, see {@code allowAudioPlaybackCapture} in the application\n     *       manifest. </li>\n     * </ul>\n     * The most restrictive policy is always applied.\n     *\n     * See {@link AudioPlaybackCaptureConfiguration} for more details on\n     * which audio signals can be captured.\n     *\n     * @param capturePolicy one of\n     *     {@link AudioAttributes#ALLOW_CAPTURE_BY_ALL},\n     *     {@link AudioAttributes#ALLOW_CAPTURE_BY_SYSTEM},\n     *     {@link AudioAttributes#ALLOW_CAPTURE_BY_NONE}.\n     * @throws RuntimeException if the argument is not a valid value.\n     ",
    "links" : [ "android.media.AudioAttributes#ALLOW_CAPTURE_BY_ALL", "android.media.AudioAttributes#ALLOW_CAPTURE_BY_SYSTEM", "android.media.AudioPlaybackCaptureConfiguration", "android.media.AudioAttributes#ALLOW_CAPTURE_BY_NONE", "AudioAttributes.Builder#setAllowedCapturePolicy(int)" ]
  }, {
    "name" : "public int getAllowedCapturePolicy()",
    "returnType" : "int",
    "comment" : "\n     * Return the capture policy.\n     * @return the capture policy set by {@link #setAllowedCapturePolicy(int)} or\n     *         the default if it was not called.\n     ",
    "links" : [ "#setAllowedCapturePolicy(int)" ]
  }, {
    "name" : "public boolean setPreferredDeviceForStrategy(@NonNull AudioProductStrategy strategy, @NonNull AudioDeviceAttributes device)",
    "returnType" : "boolean",
    "comment" : "\n     * @hide\n     * Set the preferred device for a given strategy, i.e. the audio routing to be used by\n     * this audio strategy. Note that the device may not be available at the time the preferred\n     * device is set, but it will be used once made available.\n     * <p>Use {@link #removePreferredDeviceForStrategy(AudioProductStrategy)} to cancel setting\n     * this preference for this strategy.</p>\n     * @param strategy the audio strategy whose routing will be affected\n     * @param device the audio device to route to when available\n     * @return true if the operation was successful, false otherwise\n     ",
    "links" : [ "#removePreferredDeviceForStrategy(AudioProductStrategy)" ]
  }, {
    "name" : "public boolean removePreferredDeviceForStrategy(@NonNull AudioProductStrategy strategy)",
    "returnType" : "boolean",
    "comment" : "\n     * @hide\n     * Removes the preferred audio device(s) previously set with\n     * {@link #setPreferredDeviceForStrategy(AudioProductStrategy, AudioDeviceAttributes)} or\n     * {@link #setPreferredDevicesForStrategy(AudioProductStrategy, List<AudioDeviceAttributes>)}.\n     * @param strategy the audio strategy whose routing will be affected\n     * @return true if the operation was successful, false otherwise (invalid strategy, or no\n     *     device set for example)\n     ",
    "links" : [ "#setPreferredDeviceForStrategy(AudioProductStrategy", "#setPreferredDevicesForStrategy(AudioProductStrategy" ]
  }, {
    "name" : "public AudioDeviceAttributes getPreferredDeviceForStrategy(@NonNull AudioProductStrategy strategy)",
    "returnType" : "AudioDeviceAttributes",
    "comment" : "\n     * @hide\n     * Return the preferred device for an audio strategy, previously set with\n     * {@link #setPreferredDeviceForStrategy(AudioProductStrategy, AudioDeviceAttributes)} or\n     * {@link #setPreferredDevicesForStrategy(AudioProductStrategy, List<AudioDeviceAttributes>)}\n     * @param strategy the strategy to query\n     * @return the preferred device for that strategy, if multiple devices are set as preferred\n     *    devices, the first one in the list will be returned. Null will be returned if none was\n     *    ever set or if the strategy is invalid\n     ",
    "links" : [ "#setPreferredDeviceForStrategy(AudioProductStrategy", "#setPreferredDevicesForStrategy(AudioProductStrategy" ]
  }, {
    "name" : "public boolean setPreferredDevicesForStrategy(@NonNull AudioProductStrategy strategy, @NonNull List<AudioDeviceAttributes> devices)",
    "returnType" : "boolean",
    "comment" : "\n     * @hide\n     * Set the preferred devices for a given strategy, i.e. the audio routing to be used by\n     * this audio strategy. Note that the devices may not be available at the time the preferred\n     * devices is set, but it will be used once made available.\n     * <p>Use {@link #removePreferredDeviceForStrategy(AudioProductStrategy)} to cancel setting\n     * this preference for this strategy.</p>\n     * Note that the list of devices is not a list ranked by preference, but a list of one or more\n     * devices used simultaneously to output the same audio signal.\n     * @param strategy the audio strategy whose routing will be affected\n     * @param devices a non-empty list of the audio devices to route to when available\n     * @return true if the operation was successful, false otherwise\n     ",
    "links" : [ "#removePreferredDeviceForStrategy(AudioProductStrategy)" ]
  }, {
    "name" : "public List<AudioDeviceAttributes> getPreferredDevicesForStrategy(@NonNull AudioProductStrategy strategy)",
    "returnType" : "List<AudioDeviceAttributes>",
    "comment" : "\n     * @hide\n     * Return the preferred devices for an audio strategy, previously set with\n     * {@link #setPreferredDeviceForStrategy(AudioProductStrategy, AudioDeviceAttributes)}\n     * {@link #setPreferredDevicesForStrategy(AudioProductStrategy, List<AudioDeviceAttributes>)}\n     * @param strategy the strategy to query\n     * @return list of the preferred devices for that strategy\n     ",
    "links" : [ "#setPreferredDeviceForStrategy(AudioProductStrategy", "#setPreferredDevicesForStrategy(AudioProductStrategy" ]
  }, {
    "name" : "public boolean setDeviceAsNonDefaultForStrategy(@NonNull AudioProductStrategy strategy, @NonNull AudioDeviceAttributes device)",
    "returnType" : "boolean",
    "comment" : "\n     * @hide\n     * Set a device as non-default for a given strategy, i.e. the audio routing to be avoided by\n     * this audio strategy.\n     * <p>Use\n     * {@link #removeDeviceAsNonDefaultForStrategy(AudioProductStrategy, AudioDeviceAttributes)}\n     * to cancel setting this preference for this strategy.</p>\n     * @param strategy the audio strategy whose routing will be affected\n     * @param device the audio device to not route to when available\n     * @return true if the operation was successful, false otherwise\n     ",
    "links" : [ "#removeDeviceAsNonDefaultForStrategy(AudioProductStrategy" ]
  }, {
    "name" : "public boolean removeDeviceAsNonDefaultForStrategy(@NonNull AudioProductStrategy strategy, @NonNull AudioDeviceAttributes device)",
    "returnType" : "boolean",
    "comment" : "\n     * @hide\n     * Removes the audio device(s) from the non-default device list previously set with\n     * {@link #setDeviceAsNonDefaultForStrategy(AudioProductStrategy, AudioDeviceAttributes)}\n     * @param strategy the audio strategy whose routing will be affected\n     * @param device the audio device to remove from the non-default device list\n     * @return true if the operation was successful, false otherwise (invalid strategy, or no\n     *     device set for example)\n     ",
    "links" : [ "#setDeviceAsNonDefaultForStrategy(AudioProductStrategy" ]
  }, {
    "name" : "public List<AudioDeviceAttributes> getNonDefaultDevicesForStrategy(@NonNull AudioProductStrategy strategy)",
    "returnType" : "List<AudioDeviceAttributes>",
    "comment" : "\n     * @hide\n     * Gets the audio device(s) from the non-default device list previously set with\n     * {@link #setDeviceAsNonDefaultForStrategy(AudioProductStrategy, AudioDeviceAttributes)}\n     * @param strategy the audio strategy to query\n     * @return list of non-default devices for the strategy\n     ",
    "links" : [ "#setDeviceAsNonDefaultForStrategy(AudioProductStrategy" ]
  }, {
    "name" : "public void addOnPreferredDeviceForStrategyChangedListener(@NonNull @CallbackExecutor Executor executor, @NonNull OnPreferredDeviceForStrategyChangedListener listener) throws SecurityException",
    "returnType" : "void",
    "comment" : "\n     * @hide\n     * Adds a listener for being notified of changes to the strategy-preferred audio device.\n     * @param executor\n     * @param listener\n     * @throws SecurityException if the caller doesn't hold the required permission\n     * @deprecated use {@link #addOnPreferredDevicesForStrategyChangedListener(\n     *             Executor, AudioManager.OnPreferredDevicesForStrategyChangedListener)} instead\n     ",
    "links" : [ "#addOnPreferredDevicesForStrategyChangedListener(" ]
  }, {
    "name" : "public void removeOnPreferredDeviceForStrategyChangedListener(@NonNull OnPreferredDeviceForStrategyChangedListener listener)",
    "returnType" : "void",
    "comment" : "\n     * @hide\n     * Removes a previously added listener of changes to the strategy-preferred audio device.\n     * @param listener\n     * @deprecated use {@link #removeOnPreferredDevicesForStrategyChangedListener(\n     *             AudioManager.OnPreferredDevicesForStrategyChangedListener)} instead\n     ",
    "links" : [ "#removeOnPreferredDevicesForStrategyChangedListener(" ]
  }, {
    "name" : "public void addOnPreferredDevicesForStrategyChangedListener(@NonNull @CallbackExecutor Executor executor, @NonNull OnPreferredDevicesForStrategyChangedListener listener) throws SecurityException",
    "returnType" : "void",
    "comment" : "\n     * @hide\n     * Adds a listener for being notified of changes to the strategy-preferred audio device.\n     * @param executor\n     * @param listener\n     * @throws SecurityException if the caller doesn't hold the required permission\n     ",
    "links" : [ ]
  }, {
    "name" : "public void removeOnPreferredDevicesForStrategyChangedListener(@NonNull OnPreferredDevicesForStrategyChangedListener listener)",
    "returnType" : "void",
    "comment" : "\n     * @hide\n     * Removes a previously added listener of changes to the strategy-preferred audio device.\n     * @param listener\n     ",
    "links" : [ ]
  }, {
    "name" : "public void addOnNonDefaultDevicesForStrategyChangedListener(@NonNull @CallbackExecutor Executor executor, @NonNull OnNonDefaultDevicesForStrategyChangedListener listener) throws SecurityException",
    "returnType" : "void",
    "comment" : "\n     * @hide\n     * Adds a listener for being notified of changes to the non-default audio devices for\n     * strategies.\n     * @param executor\n     * @param listener\n     * @throws SecurityException if the caller doesn't hold the required permission\n     ",
    "links" : [ ]
  }, {
    "name" : "public void removeOnNonDefaultDevicesForStrategyChangedListener(@NonNull OnNonDefaultDevicesForStrategyChangedListener listener)",
    "returnType" : "void",
    "comment" : "\n     * @hide\n     * Removes a previously added listener of changes to the non-default audio device for\n     * strategies.\n     * @param listener\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean setPreferredDeviceForCapturePreset(@MediaRecorder.SystemSource int capturePreset, @NonNull AudioDeviceAttributes device)",
    "returnType" : "boolean",
    "comment" : "\n     * @hide\n     * Set the preferred device for a given capture preset, i.e. the audio routing to be used by\n     * this capture preset. Note that the device may not be available at the time the preferred\n     * device is set, but it will be used once made available.\n     * <p>Use {@link #clearPreferredDevicesForCapturePreset(int)} to cancel setting this preference\n     * for this capture preset.</p>\n     * @param capturePreset the audio capture preset whose routing will be affected\n     * @param device the audio device to route to when available\n     * @return true if the operation was successful, false otherwise\n     ",
    "links" : [ "#clearPreferredDevicesForCapturePreset(int)" ]
  }, {
    "name" : "public boolean clearPreferredDevicesForCapturePreset(@MediaRecorder.SystemSource int capturePreset)",
    "returnType" : "boolean",
    "comment" : "\n     * @hide\n     * Remove all the preferred audio devices previously set\n     * @param capturePreset the audio capture preset whose routing will be affected\n     * @return true if the operation was successful, false otherwise (invalid capture preset, or no\n     *     device set for example)\n     ",
    "links" : [ ]
  }, {
    "name" : "public List<AudioDeviceAttributes> getPreferredDevicesForCapturePreset(@MediaRecorder.SystemSource int capturePreset)",
    "returnType" : "List<AudioDeviceAttributes>",
    "comment" : "\n     * @hide\n     * Return the preferred devices for an audio capture preset, previously set with\n     * {@link #setPreferredDeviceForCapturePreset(int, AudioDeviceAttributes)}\n     * @param capturePreset the capture preset to query\n     * @return a list that contains preferred devices for that capture preset.\n     ",
    "links" : [ "#setPreferredDeviceForCapturePreset(int" ]
  }, {
    "name" : "private boolean setPreferredDevicesForCapturePreset(@MediaRecorder.SystemSource int capturePreset, @NonNull List<AudioDeviceAttributes> devices)",
    "returnType" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public void addOnPreferredDevicesForCapturePresetChangedListener(@NonNull @CallbackExecutor Executor executor, @NonNull OnPreferredDevicesForCapturePresetChangedListener listener) throws SecurityException",
    "returnType" : "void",
    "comment" : "\n     * @hide\n     * Adds a listener for being notified of changes to the capture-preset-preferred audio device.\n     * @param executor\n     * @param listener\n     * @throws SecurityException if the caller doesn't hold the required permission\n     ",
    "links" : [ ]
  }, {
    "name" : "public void removeOnPreferredDevicesForCapturePresetChangedListener(@NonNull OnPreferredDevicesForCapturePresetChangedListener listener)",
    "returnType" : "void",
    "comment" : "\n     * @hide\n     * Removes a previously added listener of changes to the capture-preset-preferred audio device.\n     * @param listener\n     ",
    "links" : [ ]
  }, {
    "name" : "private int addOnDevRoleForCapturePresetChangedListener(@NonNull @CallbackExecutor Executor executor, @NonNull T listener, int deviceRole)",
    "returnType" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private int removeOnDevRoleForCapturePresetChangedListener(@NonNull T listener, int deviceRole)",
    "returnType" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public static int getDirectPlaybackSupport(@NonNull AudioFormat format, @NonNull AudioAttributes attributes)",
    "returnType" : "int",
    "comment" : "\n     * Returns a bitfield representing the different forms of direct playback currently available\n     * for a given audio format.\n     * <p>Direct playback means that the audio stream is not altered by the framework. The audio\n     * stream will not be resampled, volume scaled, downmixed or mixed with other content by\n     * the framework. But it may be wrapped in a higher level protocol such as IEC61937 for\n     * passthrough.\n     * <p>Checking for direct support can help the app select the representation of audio content\n     * that most closely matches the capabilities of the device and peripherals (e.g. A/V receiver)\n     * connected to it. Note that the provided stream can still be re-encoded or mixed with other\n     * streams, if needed.\n     * @param format the audio format (codec, sample rate, channels) being checked.\n     * @param attributes the {@link AudioAttributes} to be used for playback\n     * @return the direct playback mode available with given format and attributes. The returned\n     *         value will be {@link #DIRECT_PLAYBACK_NOT_SUPPORTED} or a combination of\n     *         {@link #DIRECT_PLAYBACK_OFFLOAD_SUPPORTED},\n     *         {@link #DIRECT_PLAYBACK_OFFLOAD_GAPLESS_SUPPORTED} and\n     *         {@link #DIRECT_PLAYBACK_BITSTREAM_SUPPORTED}. Note that if\n     *         {@link #DIRECT_PLAYBACK_OFFLOAD_GAPLESS_SUPPORTED} is present in the returned value,\n     *         then {@link #DIRECT_PLAYBACK_OFFLOAD_SUPPORTED} will be too.\n     ",
    "links" : [ "#DIRECT_PLAYBACK_NOT_SUPPORTED", "#DIRECT_PLAYBACK_BITSTREAM_SUPPORTED", "android.media.AudioAttributes", "#DIRECT_PLAYBACK_OFFLOAD_GAPLESS_SUPPORTED", "#DIRECT_PLAYBACK_OFFLOAD_SUPPORTED" ]
  }, {
    "name" : "public static boolean isOffloadedPlaybackSupported(@NonNull AudioFormat format, @NonNull AudioAttributes attributes)",
    "returnType" : "boolean",
    "comment" : "\n     * Returns whether offloaded playback of an audio format is supported on the device.\n     * <p>Offloaded playback is the feature where the decoding and playback of an audio stream\n     * is not competing with other software resources. In general, it is supported by dedicated\n     * hardware, such as audio DSPs.\n     * <p>Note that this query only provides information about the support of an audio format,\n     * it does not indicate whether the resources necessary for the offloaded playback are\n     * available at that instant.\n     * @param format the audio format (codec, sample rate, channels) being checked.\n     * @param attributes the {@link AudioAttributes} to be used for playback\n     * @return true if the given audio format can be offloaded.\n     ",
    "links" : [ "android.media.AudioAttributes" ]
  }, {
    "name" : "public static int getPlaybackOffloadSupport(@NonNull AudioFormat format, @NonNull AudioAttributes attributes)",
    "returnType" : "int",
    "comment" : "\n     * Returns whether offloaded playback of an audio format is supported on the device or not and\n     * when supported whether gapless transitions are possible or not.\n     * <p>Offloaded playback is the feature where the decoding and playback of an audio stream\n     * is not competing with other software resources. In general, it is supported by dedicated\n     * hardware, such as audio DSPs.\n     * <p>Note that this query only provides information about the support of an audio format,\n     * it does not indicate whether the resources necessary for the offloaded playback are\n     * available at that instant.\n     * @param format the audio format (codec, sample rate, channels) being checked.\n     * @param attributes the {@link AudioAttributes} to be used for playback\n     * @return {@link #PLAYBACK_OFFLOAD_NOT_SUPPORTED} if offload playback if not supported,\n     *         {@link #PLAYBACK_OFFLOAD_SUPPORTED} if offload playback is supported or\n     *         {@link #PLAYBACK_OFFLOAD_GAPLESS_SUPPORTED} if gapless transitions are\n     *         also supported.\n     * @deprecated Use {@link #getDirectPlaybackSupport(AudioFormat, AudioAttributes)} instead\n     ",
    "links" : [ "#PLAYBACK_OFFLOAD_NOT_SUPPORTED", "#PLAYBACK_OFFLOAD_GAPLESS_SUPPORTED", "#getDirectPlaybackSupport(AudioFormat", "android.media.AudioAttributes", "#PLAYBACK_OFFLOAD_SUPPORTED" ]
  }, {
    "name" : "public Spatializer getSpatializer()",
    "returnType" : "Spatializer",
    "comment" : "\n     * Return a handle to the optional platform's {@link Spatializer}\n     * @return the {@code Spatializer} instance.\n     * @see Spatializer#getImmersiveAudioLevel() to check for the level of support of the effect\n     *   on the platform\n     ",
    "links" : [ "android.media.Spatializer" ]
  }, {
    "name" : "public boolean isBluetoothScoAvailableOffCall()",
    "returnType" : "boolean",
    "comment" : "\n     * Indicates if current platform supports use of SCO for off call use cases.\n     * Application wanted to use bluetooth SCO audio when the phone is not in call\n     * must first call this method to make sure that the platform supports this\n     * feature.\n     * @return true if bluetooth SCO can be used for audio when not in call\n     *         false otherwise\n     * @see #startBluetoothSco()\n    ",
    "links" : [ ]
  }, {
    "name" : "public void startBluetoothSco()",
    "returnType" : "void",
    "comment" : "\n     * Start bluetooth SCO audio connection.\n     * <p>Requires Permission:\n     *   {@link Manifest.permission#MODIFY_AUDIO_SETTINGS}.\n     * <p>This method can be used by applications wanting to send and received audio\n     * to/from a bluetooth SCO headset while the phone is not in call.\n     * <p>As the SCO connection establishment can take several seconds,\n     * applications should not rely on the connection to be available when the method\n     * returns but instead register to receive the intent {@link #ACTION_SCO_AUDIO_STATE_UPDATED}\n     * and wait for the state to be {@link #SCO_AUDIO_STATE_CONNECTED}.\n     * <p>As the ACTION_SCO_AUDIO_STATE_UPDATED intent is sticky, the application can check the SCO\n     * audio state before calling startBluetoothSco() by reading the intent returned by the receiver\n     * registration. If the state is already CONNECTED, no state change will be received via the\n     * intent after calling startBluetoothSco(). It is however useful to call startBluetoothSco()\n     * so that the connection stays active in case the current initiator stops the connection.\n     * <p>Unless the connection is already active as described above, the state will always\n     * transition from DISCONNECTED to CONNECTING and then either to CONNECTED if the connection\n     * succeeds or back to DISCONNECTED if the connection fails (e.g no headset is connected).\n     * <p>When finished with the SCO connection or if the establishment fails, the application must\n     * call {@link #stopBluetoothSco()} to clear the request and turn down the bluetooth connection.\n     * <p>Even if a SCO connection is established, the following restrictions apply on audio\n     * output streams so that they can be routed to SCO headset:\n     * <ul>\n     *   <li> the stream type must be {@link #STREAM_VOICE_CALL} </li>\n     *   <li> the format must be mono </li>\n     *   <li> the sampling must be 16kHz or 8kHz </li>\n     * </ul>\n     * <p>The following restrictions apply on input streams:\n     * <ul>\n     *   <li> the format must be mono </li>\n     *   <li> the sampling must be 8kHz </li>\n     * </ul>\n     * <p>Note that the phone application always has the priority on the usage of the SCO\n     * connection for telephony. If this method is called while the phone is in call\n     * it will be ignored. Similarly, if a call is received or sent while an application\n     * is using the SCO connection, the connection will be lost for the application and NOT\n     * returned automatically when the call ends.\n     * <p>NOTE: up to and including API version\n     * {@link android.os.Build.VERSION_CODES#JELLY_BEAN_MR1}, this method initiates a virtual\n     * voice call to the bluetooth headset.\n     * After API version {@link android.os.Build.VERSION_CODES#JELLY_BEAN_MR2} only a raw SCO audio\n     * connection is established.\n     * @see #stopBluetoothSco()\n     * @see #ACTION_SCO_AUDIO_STATE_UPDATED\n     * @deprecated Use {@link AudioManager#setCommunicationDevice(AudioDeviceInfo)} instead.\n     ",
    "links" : [ "android.os.Build.VERSION_CODES#JELLY_BEAN_MR1", "#ACTION_SCO_AUDIO_STATE_UPDATED", "android.os.Build.VERSION_CODES#JELLY_BEAN_MR2", "#STREAM_VOICE_CALL", "#stopBluetoothSco()", "android.media.AudioManager#setCommunicationDevice(AudioDeviceInfo)", "Manifest.permission#MODIFY_AUDIO_SETTINGS", "#SCO_AUDIO_STATE_CONNECTED" ]
  }, {
    "name" : "public void startBluetoothScoVirtualCall()",
    "returnType" : "void",
    "comment" : "\n     * @hide\n     * Start bluetooth SCO audio connection in virtual call mode.\n     * <p>Requires Permission:\n     *   {@link Manifest.permission#MODIFY_AUDIO_SETTINGS}.\n     * <p>Similar to {@link #startBluetoothSco()} with explicit selection of virtual call mode.\n     * Telephony and communication applications (VoIP, Video Chat) should preferably select\n     * virtual call mode.\n     * Applications using voice input for search or commands should first try raw audio connection\n     * with {@link #startBluetoothSco()} and fall back to startBluetoothScoVirtualCall() in case of\n     * failure.\n     * @see #startBluetoothSco()\n     * @see #stopBluetoothSco()\n     * @see #ACTION_SCO_AUDIO_STATE_UPDATED\n     ",
    "links" : [ "#startBluetoothSco()", "Manifest.permission#MODIFY_AUDIO_SETTINGS" ]
  }, {
    "name" : "public void stopBluetoothSco()",
    "returnType" : "void",
    "comment" : " Also used for connections started with {@link #startBluetoothScoVirtualCall()}",
    "links" : [ "#startBluetoothScoVirtualCall()" ]
  }, {
    "name" : "public void setBluetoothScoOn(boolean on)",
    "returnType" : "void",
    "comment" : "\n     * Request use of Bluetooth SCO headset for communications.\n     * <p>\n     * This method should only be used by applications that replace the platform-wide\n     * management of audio settings or the main telephony application.\n     *\n     * @param on set <var>true</var> to use bluetooth SCO for communications;\n     *               <var>false</var> to not use bluetooth SCO for communications\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean isBluetoothScoOn()",
    "returnType" : "boolean",
    "comment" : "\n     * Checks whether communications use Bluetooth SCO.\n     *\n     * @return true if SCO is used for communications;\n     *         false if otherwise\n     * @deprecated Use {@link AudioManager#getCommunicationDevice()} instead.\n     ",
    "links" : [ "android.media.AudioManager#getCommunicationDevice()" ]
  }, {
    "name" : "public void setBluetoothA2dpOn(boolean on)",
    "returnType" : "void",
    "comment" : "\n     * @deprecated Use {@link MediaRouter#selectRoute} instead.\n     ",
    "links" : [ "android.media.MediaRouter#selectRoute" ]
  }, {
    "name" : "public boolean isBluetoothA2dpOn()",
    "returnType" : "boolean",
    "comment" : "\n     * Checks whether a Bluetooth A2DP audio peripheral is connected or not.\n     *\n     * @return true if a Bluetooth A2DP peripheral is connected\n     *         false if otherwise\n     * @deprecated Use {@link AudioManager#getDevices(int)} instead to list available audio devices.\n     ",
    "links" : [ "android.media.AudioManager#getDevices(int)" ]
  }, {
    "name" : "public void setWiredHeadsetOn(boolean on)",
    "returnType" : "void",
    "comment" : "\n     * Sets audio routing to the wired headset on or off.\n     *\n     * @param on set <var>true</var> to route audio to/from wired\n     *           headset; <var>false</var> disable wired headset audio\n     * @deprecated Do not use.\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean isWiredHeadsetOn()",
    "returnType" : "boolean",
    "comment" : "\n     * Checks whether a wired headset is connected or not.\n     * <p>This is not a valid indication that audio playback is\n     * actually over the wired headset as audio routing depends on other conditions.\n     *\n     * @return true if a wired headset is connected.\n     *         false if otherwise\n     * @deprecated Use {@link AudioManager#getDevices(int)} instead to list available audio devices.\n     ",
    "links" : [ "android.media.AudioManager#getDevices(int)" ]
  }, {
    "name" : "public void setMicrophoneMute(boolean on)",
    "returnType" : "void",
    "comment" : "\n     * Sets the microphone mute on or off.\n     * <p>\n     * This method should only be used by applications that replace the platform-wide\n     * management of audio settings or the main telephony application.\n     *\n     * @param on set <var>true</var> to mute the microphone;\n     *           <var>false</var> to turn mute off\n     ",
    "links" : [ ]
  }, {
    "name" : "public void setMicrophoneMuteFromSwitch(boolean on)",
    "returnType" : "void",
    "comment" : "\n     * @hide\n     * Sets the microphone from switch mute on or off.\n     * <p>\n     * This method should only be used by InputManager to notify\n     * Audio Subsystem about Microphone Mute switch state.\n     *\n     * @param on set <var>true</var> to mute the microphone;\n     *           <var>false</var> to turn mute off\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean isMicrophoneMute()",
    "returnType" : "boolean",
    "comment" : "\n     * Checks whether the microphone mute is on or off.\n     *\n     * @return true if microphone is muted, false if it's not\n     ",
    "links" : [ ]
  }, {
    "name" : "public void setMode(@AudioMode int mode)",
    "returnType" : "void",
    "comment" : "\n     * Sets the audio mode.\n     * <p>\n     * The audio mode encompasses audio routing AND the behavior of\n     * the telephony layer. Therefore this method should only be used by applications that\n     * replace the platform-wide management of audio settings or the main telephony application.\n     * In particular, the {@link #MODE_IN_CALL} mode should only be used by the telephony\n     * application when it places a phone call, as it will cause signals from the radio layer\n     * to feed the platform mixer.\n     *\n     * @param mode  the requested audio mode.\n     *              Informs the HAL about the current audio state so that\n     *              it can route the audio appropriately.\n     ",
    "links" : [ "#MODE_IN_CALL" ]
  }, {
    "name" : "public int getMode()",
    "returnType" : "int",
    "comment" : "\n     * Returns the current audio mode.\n     *\n     * @return      the current audio mode.\n     ",
    "links" : [ ]
  }, {
    "name" : "public void addOnModeChangedListener(@NonNull @CallbackExecutor Executor executor, @NonNull OnModeChangedListener listener)",
    "returnType" : "void",
    "comment" : "\n     * Adds a listener to be notified of changes to the audio mode.\n     * See {@link #getMode()}\n     * @param executor\n     * @param listener\n     ",
    "links" : [ "#getMode()" ]
  }, {
    "name" : "public void removeOnModeChangedListener(@NonNull OnModeChangedListener listener)",
    "returnType" : "void",
    "comment" : "\n     * Removes a previously added listener for changes to audio mode.\n     * See {@link #getMode()}\n     * @param listener\n     ",
    "links" : [ "#getMode()" ]
  }, {
    "name" : "public boolean isCallScreeningModeSupported()",
    "returnType" : "boolean",
    "comment" : "\n    * Indicates if the platform supports a special call screening and call monitoring mode.\n    * <p>\n    * When this mode is supported, it is possible to perform call screening and monitoring\n    * functions while other use cases like music or movie playback are active.\n    * <p>\n    * Use {@link #setMode(int)} with mode {@link #MODE_CALL_SCREENING} to place the platform in\n    * call screening mode.\n    * <p>\n    * If call screening mode is not supported, setting mode to\n    * MODE_CALL_SCREENING will be ignored and will not change current mode reported by\n    *  {@link #getMode()}.\n    * @return true if call screening mode is supported, false otherwise.\n    ",
    "links" : [ "#getMode()", "#setMode(int)", "#MODE_CALL_SCREENING" ]
  }, {
    "name" : "public void setRouting(int mode, int routes, int mask)",
    "returnType" : "void",
    "comment" : "\n     * Sets the audio routing for a specified mode\n     *\n     * @param mode   audio mode to change route. E.g., MODE_RINGTONE.\n     * @param routes bit vector of routes requested, created from one or\n     *               more of ROUTE_xxx types. Set bits indicate that route should be on\n     * @param mask   bit vector of routes to change, created from one or more of\n     * ROUTE_xxx types. Unset bits indicate the route should be left unchanged\n     *\n     * @deprecated   Do not set audio routing directly, use setSpeakerphoneOn(),\n     * setBluetoothScoOn() methods instead.\n     ",
    "links" : [ ]
  }, {
    "name" : "public int getRouting(int mode)",
    "returnType" : "int",
    "comment" : "\n     * Returns the current audio routing bit vector for a specified mode.\n     *\n     * @param mode audio mode to get route (e.g., MODE_RINGTONE)\n     * @return an audio route bit vector that can be compared with ROUTE_xxx\n     * bits\n     * @deprecated   Do not query audio routing directly, use isSpeakerphoneOn(),\n     * isBluetoothScoOn(), isBluetoothA2dpOn() and isWiredHeadsetOn() methods instead.\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean isMusicActive()",
    "returnType" : "boolean",
    "comment" : "\n     * Checks whether any music is active.\n     *\n     * @return true if any music tracks are active.\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean isMusicActiveRemotely()",
    "returnType" : "boolean",
    "comment" : "\n     * @hide\n     * Checks whether any music or media is actively playing on a remote device (e.g. wireless\n     *   display). Note that BT audio sinks are not considered remote devices.\n     * @return true if {@link AudioManager#STREAM_MUSIC} is active on a remote device\n     ",
    "links" : [ "android.media.AudioManager#STREAM_MUSIC" ]
  }, {
    "name" : "public boolean isAudioFocusExclusive()",
    "returnType" : "boolean",
    "comment" : "\n     * @hide\n     * Checks whether the current audio focus is exclusive.\n     * @return true if the top of the audio focus stack requested focus\n     *     with {@link #AUDIOFOCUS_GAIN_TRANSIENT_EXCLUSIVE}\n     ",
    "links" : [ "#AUDIOFOCUS_GAIN_TRANSIENT_EXCLUSIVE" ]
  }, {
    "name" : "public int generateAudioSessionId()",
    "returnType" : "int",
    "comment" : "\n     * Return a new audio session identifier not associated with any player or effect.\n     * An audio session identifier is a system wide unique identifier for a set of audio streams\n     * (one or more mixed together).\n     * <p>The primary use of the audio session ID is to associate audio effects to audio players,\n     * such as {@link MediaPlayer} or {@link AudioTrack}: all audio effects sharing the same audio\n     * session ID will be applied to the mixed audio content of the players that share the same\n     * audio session.\n     * <p>This method can for instance be used when creating one of the\n     * {@link android.media.audiofx.AudioEffect} objects to define the audio session of the effect,\n     * or to specify a session for a speech synthesis utterance\n     * in {@link android.speech.tts.TextToSpeech.Engine}.\n     * @return a new unclaimed and unused audio session identifier, or {@link #ERROR} when the\n     *   system failed to generate a new session, a condition in which audio playback or recording\n     *   will subsequently fail as well.\n     ",
    "links" : [ "android.media.audiofx.AudioEffect", "#ERROR", "android.media.MediaPlayer", "android.speech.tts.TextToSpeech.Engine", "android.media.AudioTrack" ]
  }, {
    "name" : "public void setParameter(String key, String value)",
    "returnType" : "void",
    "comment" : "\n     * @hide\n     * @deprecated Use {@link #setParameters(String)} instead\n     ",
    "links" : [ "#setParameters(String)" ]
  }, {
    "name" : "public void setParameters(String keyValuePairs)",
    "returnType" : "void",
    "comment" : "\n     * Sets a variable number of parameter values to audio hardware.\n     *\n     * @param keyValuePairs list of parameters key value pairs in the form:\n     *    key1=value1;key2=value2;...\n     *\n     ",
    "links" : [ ]
  }, {
    "name" : "public void setHfpEnabled(boolean enable)",
    "returnType" : "void",
    "comment" : "\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public void setHfpVolume(int volume)",
    "returnType" : "void",
    "comment" : "\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public void setHfpSamplingRate(int rate)",
    "returnType" : "void",
    "comment" : "\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public void setBluetoothHeadsetProperties(@NonNull String name, boolean hasNrecEnabled, boolean hasWbsEnabled)",
    "returnType" : "void",
    "comment" : "\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public void setA2dpSuspended(boolean enable)",
    "returnType" : "void",
    "comment" : "\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public void setLeAudioSuspended(boolean enable)",
    "returnType" : "void",
    "comment" : "\n     * Suspends the use of LE Audio.\n     *\n     * @param enable {@code true} to suspend le audio, {@code false} to unsuspend\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public String getParameters(String keys)",
    "returnType" : "String",
    "comment" : "\n     * Gets a variable number of parameter values from audio hardware.\n     *\n     * @param keys list of parameters\n     * @return list of parameters key value pairs in the form:\n     *    key1=value1;key2=value2;...\n     ",
    "links" : [ ]
  }, {
    "name" : "public static int getNthNavigationRepeatSoundEffect(int n)",
    "returnType" : "int",
    "comment" : "\n     * @hide\n     * @param n a value in [0, {@link #NUM_NAVIGATION_REPEAT_SOUND_EFFECTS}[\n     * @return The id of a navigation repeat sound effect or -1 if out of bounds\n     ",
    "links" : [ "#NUM_NAVIGATION_REPEAT_SOUND_EFFECTS" ]
  }, {
    "name" : "public void setNavigationRepeatSoundEffectsEnabled(boolean enabled)",
    "returnType" : "void",
    "comment" : "\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean areNavigationRepeatSoundEffectsEnabled()",
    "returnType" : "boolean",
    "comment" : "\n     * @hide\n     * @return true if the navigation repeat sound effects are enabled\n     ",
    "links" : [ ]
  }, {
    "name" : "public void setHomeSoundEffectEnabled(boolean enabled)",
    "returnType" : "void",
    "comment" : "\n     * @hide\n     * @param enabled\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean isHomeSoundEffectEnabled()",
    "returnType" : "boolean",
    "comment" : "\n     * @hide\n     * @return true if the home sound effect is enabled\n     ",
    "links" : [ ]
  }, {
    "name" : "public void playSoundEffect(@SystemSoundEffect int effectType)",
    "returnType" : "void",
    "comment" : "\n     * Plays a sound effect (Key clicks, lid open/close...)\n     * @param effectType The type of sound effect.\n     * NOTE: This version uses the UI settings to determine\n     * whether sounds are heard or not.\n     ",
    "links" : [ ]
  }, {
    "name" : "public void playSoundEffect(@SystemSoundEffect int effectType, int userId)",
    "returnType" : "void",
    "comment" : "\n     * Plays a sound effect (Key clicks, lid open/close...)\n     * @param effectType The type of sound effect.\n     * @param userId The current user to pull sound settings from\n     * NOTE: This version uses the UI settings to determine\n     * whether sounds are heard or not.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public void playSoundEffect(@SystemSoundEffect int effectType, float volume)",
    "returnType" : "void",
    "comment" : "\n     * Plays a sound effect (Key clicks, lid open/close...)\n     * @param effectType The type of sound effect.\n     * @param volume Sound effect volume.\n     * The volume value is a raw scalar so UI controls should be scaled logarithmically.\n     * If a volume of -1 is specified, the AudioManager.STREAM_MUSIC stream volume minus 3dB will be used.\n     * NOTE: This version is for applications that have their own\n     * settings panel for enabling and controlling volume.\n     ",
    "links" : [ ]
  }, {
    "name" : "private boolean delegateSoundEffectToVdm(@SystemSoundEffect int effectType)",
    "returnType" : "boolean",
    "comment" : "\n     * Checks whether this {@link AudioManager} instance is associated with {@link VirtualDevice}\n     * configured with custom device policy for audio. If there is such device, request to play\n     * sound effect is forwarded to {@link VirtualDeviceManager}.\n     *\n     * @param effectType - The type of sound effect.\n     * @return true if the request was forwarded to {@link VirtualDeviceManager} instance,\n     * false otherwise.\n     ",
    "links" : [ "VirtualDevice", "android.companion.virtual.VirtualDeviceManager", "android.media.AudioManager" ]
  }, {
    "name" : "private boolean hasCustomPolicyVirtualDeviceContext()",
    "returnType" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public void loadSoundEffects()",
    "returnType" : "void",
    "comment" : "\n     *  Load Sound effects.\n     *  This method must be called when sound effects are enabled.\n     ",
    "links" : [ ]
  }, {
    "name" : "public void unloadSoundEffects()",
    "returnType" : "void",
    "comment" : "\n     *  Unload Sound effects.\n     *  This method can be called to free some memory when\n     *  sound effects are disabled.\n     ",
    "links" : [ ]
  }, {
    "name" : "public static String audioFocusToString(int focus)",
    "returnType" : "String",
    "comment" : "\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "private FocusRequestInfo findFocusRequestInfo(String id)",
    "returnType" : "FocusRequestInfo",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private String getIdForAudioFocusListener(OnAudioFocusChangeListener l)",
    "returnType" : "String",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public void registerAudioFocusRequest(@NonNull AudioFocusRequest afr)",
    "returnType" : "void",
    "comment" : "\n     * @hide\n     * Registers a listener to be called when audio focus changes and keeps track of the associated\n     * focus request (including Handler to use for the listener).\n     * @param afr the full request parameters\n     ",
    "links" : [ ]
  }, {
    "name" : "public void unregisterAudioFocusRequest(OnAudioFocusChangeListener l)",
    "returnType" : "void",
    "comment" : "\n     * @hide\n     * Causes the specified listener to not be called anymore when focus is gained or lost.\n     * @param l the listener to unregister.\n     ",
    "links" : [ ]
  }, {
    "name" : "public int requestAudioFocus(OnAudioFocusChangeListener l, int streamType, int durationHint)",
    "returnType" : "int",
    "comment" : "\n     *  Request audio focus.\n     *  Send a request to obtain the audio focus\n     *  @param l the listener to be notified of audio focus changes\n     *  @param streamType the main audio stream type affected by the focus request\n     *  @param durationHint use {@link #AUDIOFOCUS_GAIN_TRANSIENT} to indicate this focus request\n     *      is temporary, and focus will be abandonned shortly. Examples of transient requests are\n     *      for the playback of driving directions, or notifications sounds.\n     *      Use {@link #AUDIOFOCUS_GAIN_TRANSIENT_MAY_DUCK} to indicate also that it's ok for\n     *      the previous focus owner to keep playing if it ducks its audio output.\n     *      Alternatively use {@link #AUDIOFOCUS_GAIN_TRANSIENT_EXCLUSIVE} for a temporary request\n     *      that benefits from the system not playing disruptive sounds like notifications, for\n     *      usecases such as voice memo recording, or speech recognition.\n     *      Use {@link #AUDIOFOCUS_GAIN} for a focus request of unknown duration such\n     *      as the playback of a song or a video.\n     *  @return {@link #AUDIOFOCUS_REQUEST_FAILED} or {@link #AUDIOFOCUS_REQUEST_GRANTED}\n     *  @deprecated use {@link #requestAudioFocus(AudioFocusRequest)}\n     ",
    "links" : [ "#AUDIOFOCUS_GAIN_TRANSIENT_MAY_DUCK", "#AUDIOFOCUS_GAIN_TRANSIENT_EXCLUSIVE", "#AUDIOFOCUS_REQUEST_GRANTED", "#AUDIOFOCUS_GAIN_TRANSIENT", "#AUDIOFOCUS_REQUEST_FAILED", "#AUDIOFOCUS_GAIN", "#requestAudioFocus(AudioFocusRequest)" ]
  }, {
    "name" : "public int requestAudioFocus(@NonNull AudioFocusRequest focusRequest)",
    "returnType" : "int",
    "comment" : "\n     * Request audio focus.\n     * See the {@link AudioFocusRequest} for information about the options available to configure\n     * your request, and notification of focus gain and loss.\n     * @param focusRequest a {@link AudioFocusRequest} instance used to configure how focus is\n     *   requested.\n     * @return {@link #AUDIOFOCUS_REQUEST_FAILED}, {@link #AUDIOFOCUS_REQUEST_GRANTED}\n     *     or {@link #AUDIOFOCUS_REQUEST_DELAYED}.\n     *     <br>Note that the return value is never {@link #AUDIOFOCUS_REQUEST_DELAYED} when focus\n     *     is requested without building the {@link AudioFocusRequest} with\n     *     {@link AudioFocusRequest.Builder#setAcceptsDelayedFocusGain(boolean)} set to\n     *     {@code true}.\n     * @throws NullPointerException if passed a null argument\n     ",
    "links" : [ "#AUDIOFOCUS_REQUEST_DELAYED", "#AUDIOFOCUS_REQUEST_GRANTED", "android.media.AudioFocusRequest", "AudioFocusRequest.Builder#setAcceptsDelayedFocusGain(boolean)", "#AUDIOFOCUS_REQUEST_FAILED" ]
  }, {
    "name" : "public int abandonAudioFocusRequest(@NonNull AudioFocusRequest focusRequest)",
    "returnType" : "int",
    "comment" : "\n     *  Abandon audio focus. Causes the previous focus owner, if any, to receive focus.\n     *  @param focusRequest the {@link AudioFocusRequest} that was used when requesting focus\n     *      with {@link #requestAudioFocus(AudioFocusRequest)}.\n     *  @return {@link #AUDIOFOCUS_REQUEST_FAILED} or {@link #AUDIOFOCUS_REQUEST_GRANTED}\n     *  @throws IllegalArgumentException if passed a null argument\n     ",
    "links" : [ "#AUDIOFOCUS_REQUEST_GRANTED", "android.media.AudioFocusRequest", "#AUDIOFOCUS_REQUEST_FAILED", "#requestAudioFocus(AudioFocusRequest)" ]
  }, {
    "name" : "public int requestAudioFocus(OnAudioFocusChangeListener l, @NonNull AudioAttributes requestAttributes, int durationHint, int flags) throws IllegalArgumentException",
    "returnType" : "int",
    "comment" : "\n     * @hide\n     * Request audio focus.\n     * Send a request to obtain the audio focus. This method differs from\n     * {@link #requestAudioFocus(OnAudioFocusChangeListener, int, int)} in that it can express\n     * that the requester accepts delayed grants of audio focus.\n     * @param l the listener to be notified of audio focus changes. It is not allowed to be null\n     *     when the request is flagged with {@link #AUDIOFOCUS_FLAG_DELAY_OK}.\n     * @param requestAttributes non null {@link AudioAttributes} describing the main reason for\n     *     requesting audio focus.\n     * @param durationHint use {@link #AUDIOFOCUS_GAIN_TRANSIENT} to indicate this focus request\n     *      is temporary, and focus will be abandonned shortly. Examples of transient requests are\n     *      for the playback of driving directions, or notifications sounds.\n     *      Use {@link #AUDIOFOCUS_GAIN_TRANSIENT_MAY_DUCK} to indicate also that it's ok for\n     *      the previous focus owner to keep playing if it ducks its audio output.\n     *      Alternatively use {@link #AUDIOFOCUS_GAIN_TRANSIENT_EXCLUSIVE} for a temporary request\n     *      that benefits from the system not playing disruptive sounds like notifications, for\n     *      usecases such as voice memo recording, or speech recognition.\n     *      Use {@link #AUDIOFOCUS_GAIN} for a focus request of unknown duration such\n     *      as the playback of a song or a video.\n     * @param flags 0 or a combination of {link #AUDIOFOCUS_FLAG_DELAY_OK},\n     *     {@link #AUDIOFOCUS_FLAG_PAUSES_ON_DUCKABLE_LOSS} and {@link #AUDIOFOCUS_FLAG_LOCK}.\n     *     <br>Use 0 when not using any flags for the request, which behaves like\n     *     {@link #requestAudioFocus(OnAudioFocusChangeListener, int, int)}, where either audio\n     *     focus is granted immediately, or the grant request fails because the system is in a\n     *     state where focus cannot change (e.g. a phone call).\n     * @return {@link #AUDIOFOCUS_REQUEST_FAILED}, {@link #AUDIOFOCUS_REQUEST_GRANTED}\n     *     or {@link #AUDIOFOCUS_REQUEST_DELAYED}.\n     *     The return value is never {@link #AUDIOFOCUS_REQUEST_DELAYED} when focus is requested\n     *     without the {@link #AUDIOFOCUS_FLAG_DELAY_OK} flag.\n     * @throws IllegalArgumentException\n     ",
    "links" : [ "#AUDIOFOCUS_GAIN_TRANSIENT_MAY_DUCK", "#AUDIOFOCUS_FLAG_LOCK", "#AUDIOFOCUS_REQUEST_DELAYED", "#AUDIOFOCUS_GAIN_TRANSIENT_EXCLUSIVE", "#AUDIOFOCUS_REQUEST_GRANTED", "android.media.AudioAttributes", "#AUDIOFOCUS_FLAG_PAUSES_ON_DUCKABLE_LOSS", "#requestAudioFocus(OnAudioFocusChangeListener", "#AUDIOFOCUS_GAIN_TRANSIENT", "#AUDIOFOCUS_REQUEST_FAILED", "#AUDIOFOCUS_FLAG_DELAY_OK", "#AUDIOFOCUS_GAIN" ]
  }, {
    "name" : "public int requestAudioFocus(OnAudioFocusChangeListener l, @NonNull AudioAttributes requestAttributes, int durationHint, int flags, AudioPolicy ap) throws IllegalArgumentException",
    "returnType" : "int",
    "comment" : "\n     * @hide\n     * Request or lock audio focus.\n     * This method is to be used by system components that have registered an\n     * {@link android.media.audiopolicy.AudioPolicy} to request audio focus, but also to \"lock\" it\n     * so focus granting is temporarily disabled.\n     * @param l see the description of the same parameter in\n     *     {@link #requestAudioFocus(OnAudioFocusChangeListener, AudioAttributes, int, int)}\n     * @param requestAttributes non null {@link AudioAttributes} describing the main reason for\n     *     requesting audio focus.\n     * @param durationHint see the description of the same parameter in\n     *     {@link #requestAudioFocus(OnAudioFocusChangeListener, AudioAttributes, int, int)}\n     * @param flags 0 or a combination of {link #AUDIOFOCUS_FLAG_DELAY_OK},\n     *     {@link #AUDIOFOCUS_FLAG_PAUSES_ON_DUCKABLE_LOSS}, and {@link #AUDIOFOCUS_FLAG_LOCK}.\n     *     <br>Use 0 when not using any flags for the request, which behaves like\n     *     {@link #requestAudioFocus(OnAudioFocusChangeListener, int, int)}, where either audio\n     *     focus is granted immediately, or the grant request fails because the system is in a\n     *     state where focus cannot change (e.g. a phone call).\n     * @param ap a registered {@link android.media.audiopolicy.AudioPolicy} instance when locking\n     *     focus, or null.\n     * @return see the description of the same return value in\n     *     {@link #requestAudioFocus(OnAudioFocusChangeListener, AudioAttributes, int, int)}\n     * @throws IllegalArgumentException\n     * @deprecated use {@link #requestAudioFocus(AudioFocusRequest, AudioPolicy)}\n     ",
    "links" : [ "#AUDIOFOCUS_FLAG_LOCK", "#requestAudioFocus(AudioFocusRequest", "android.media.AudioAttributes", "#AUDIOFOCUS_FLAG_PAUSES_ON_DUCKABLE_LOSS", "#requestAudioFocus(OnAudioFocusChangeListener", "android.media.audiopolicy.AudioPolicy" ]
  }, {
    "name" : "public int requestAudioFocusForTest(@NonNull AudioFocusRequest afr, @NonNull String clientFakeId, int clientFakeUid, int clientTargetSdk)",
    "returnType" : "int",
    "comment" : "\n     * @hide\n     * Test API to request audio focus for an arbitrary client operating from a (fake) given UID.\n     * Used to simulate conditions of the test, not the behavior of the focus requester under test.\n     * @param afr the parameters of the request\n     * @param clientFakeId the identifier of the AudioManager the client would be requesting from\n     * @param clientFakeUid the UID of the client, here an arbitrary int,\n     *                      doesn't have to be a real UID\n     * @param clientTargetSdk the target SDK used by the client\n     * @return return code indicating status of the request\n     ",
    "links" : [ ]
  }, {
    "name" : "public int abandonAudioFocusForTest(@NonNull AudioFocusRequest afr, @NonNull String clientFakeId)",
    "returnType" : "int",
    "comment" : "\n     * @hide\n     * Test API to abandon audio focus for an arbitrary client.\n     * Used to simulate conditions of the test, not the behavior of the focus requester under test.\n     * @param afr the parameters used for the request\n     * @param clientFakeId clientFakeId the identifier of the AudioManager from which the client\n     *      would be requesting\n     * @return return code indicating status of the request\n     ",
    "links" : [ ]
  }, {
    "name" : "public long getFadeOutDurationOnFocusLossMillis(@NonNull AudioAttributes aa)",
    "returnType" : "long",
    "comment" : "\n     * @hide\n     * Return the duration of the fade out applied when a player of the given AudioAttributes\n     * is losing audio focus\n     * @param aa the AudioAttributes of the player losing focus with {@link #AUDIOFOCUS_LOSS}\n     * @return a duration in ms, 0 indicates no fade out is applied\n     ",
    "links" : [ "#AUDIOFOCUS_LOSS" ]
  }, {
    "name" : "public List<Integer> getFocusDuckedUidsForTest()",
    "returnType" : "List<Integer>",
    "comment" : "\n     * @hide\n     * Test method to return the list of UIDs currently marked as ducked because of their\n     * audio focus status\n     * @return the list of UIDs, can be empty when no app is being ducked.\n     ",
    "links" : [ ]
  }, {
    "name" : "public long getFocusFadeOutDurationForTest()",
    "returnType" : "long",
    "comment" : "\n     * @hide\n     * Test method to return the duration of the fade out applied on the players of a focus loser\n     * @return the fade out duration in ms\n     ",
    "links" : [ ]
  }, {
    "name" : "public long getFocusUnmuteDelayAfterFadeOutForTest()",
    "returnType" : "long",
    "comment" : "\n     * @hide\n     * Test method to return the length of time after a fade-out before the focus loser is unmuted\n     * (and is faded back in).\n     * @return the time gap after a fade-out completion on focus loss, and fade-in start in ms.\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean enterAudioFocusFreezeForTest(@NonNull List<Integer> exemptedUids)",
    "returnType" : "boolean",
    "comment" : "\n     * @hide\n     * Test method to start preventing applications from requesting audio focus during a test,\n     * which could interfere with the functionality/behavior under test.\n     * Calling this method needs to be paired with a call to {@link #exitAudioFocusFreezeForTest}\n     * when the testing is done. If this is not the case (e.g. in case of a test crash),\n     * a death observer mechanism will ensure the system is not left in a bad state, but this should\n     * not be relied on when implementing tests.\n     * @param exemptedUids a list of UIDs that are exempt from the freeze. This would for instance\n     *     be those of the test runner and other players used in the test, or the \"fake\" UIDs used\n     *     for testing with {@link #requestAudioFocusForTest(AudioFocusRequest, String, int, int)}.\n     * @return true if the focus freeze mode is successfully entered, false if there was an issue,\n     *     such as another freeze in place at the time of invocation.\n     *     A false result should result in a test failure as this would indicate the system is not\n     *     in a proper state with a predictable behavior for audio focus management.\n     ",
    "links" : [ "#exitAudioFocusFreezeForTest", "#requestAudioFocusForTest(AudioFocusRequest" ]
  }, {
    "name" : "public boolean exitAudioFocusFreezeForTest()",
    "returnType" : "boolean",
    "comment" : "\n     * @hide\n     * Test method to end preventing applications from requesting audio focus during a test.\n     * @return true if the focus freeze mode is successfully exited, false if there was an issue,\n     *     such as the freeze already having ended, or not started.\n     ",
    "links" : [ ]
  }, {
    "name" : "public int requestAudioFocus(@NonNull AudioFocusRequest afr, @Nullable AudioPolicy ap)",
    "returnType" : "int",
    "comment" : "\n     * @hide\n     * Request or lock audio focus.\n     * This method is to be used by system components that have registered an\n     * {@link android.media.audiopolicy.AudioPolicy} to request audio focus, but also to \"lock\" it\n     * so focus granting is temporarily disabled.\n     * @param afr see the description of the same parameter in\n     *     {@link #requestAudioFocus(AudioFocusRequest)}\n     * @param ap a registered {@link android.media.audiopolicy.AudioPolicy} instance when locking\n     *     focus, or null.\n     * @return {@link #AUDIOFOCUS_REQUEST_FAILED}, {@link #AUDIOFOCUS_REQUEST_GRANTED}\n     *     or {@link #AUDIOFOCUS_REQUEST_DELAYED}.\n     * @throws NullPointerException if the AudioFocusRequest is null\n     * @throws IllegalArgumentException when trying to lock focus without an AudioPolicy\n     ",
    "links" : [ "#AUDIOFOCUS_REQUEST_DELAYED", "#AUDIOFOCUS_REQUEST_GRANTED", "android.media.audiopolicy.AudioPolicy", "#AUDIOFOCUS_REQUEST_FAILED", "#requestAudioFocus(AudioFocusRequest)" ]
  }, {
    "name" : "private BlockingFocusResultReceiver addClientIdToFocusReceiverLocked(String clientId)",
    "returnType" : "BlockingFocusResultReceiver",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private int handleExternalAudioPolicyWaitIfNeeded(String clientId, BlockingFocusResultReceiver focusReceiver)",
    "returnType" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public void requestAudioFocusForCall(int streamType, int durationHint)",
    "returnType" : "void",
    "comment" : "\n     * @hide\n     * Used internally by telephony package to request audio focus. Will cause the focus request\n     * to be associated with the \"voice communication\" identifier only used in AudioService\n     * to identify this use case.\n     * @param streamType use STREAM_RING for focus requests when ringing, VOICE_CALL for\n     *    the establishment of the call\n     * @param durationHint the type of focus request. AUDIOFOCUS_GAIN_TRANSIENT is recommended so\n     *    media applications resume after a call\n     ",
    "links" : [ ]
  }, {
    "name" : "public int getFocusRampTimeMs(int focusGain, AudioAttributes attr)",
    "returnType" : "int",
    "comment" : "\n     * @hide\n     * Return the volume ramping time for a sound to be played after the given focus request,\n     *   and to play a sound of the given attributes\n     * @param focusGain\n     * @param attr\n     * @return\n     ",
    "links" : [ ]
  }, {
    "name" : "public void setFocusRequestResult(@NonNull AudioFocusInfo afi, @FocusRequestResult int requestResult, @NonNull AudioPolicy ap)",
    "returnType" : "void",
    "comment" : "\n     * @hide\n     * Set the result to the audio focus request received through\n     * {@link AudioPolicyFocusListener#onAudioFocusRequest(AudioFocusInfo, int)}.\n     * @param afi the information about the focus requester\n     * @param requestResult the result to the focus request to be passed to the requester\n     * @param ap a valid registered {@link AudioPolicy} configured as a focus policy.\n     ",
    "links" : [ "android.media.audiopolicy.AudioPolicy.AudioPolicyFocusListener#onAudioFocusRequest(AudioFocusInfo", "android.media.audiopolicy.AudioPolicy" ]
  }, {
    "name" : "public int dispatchAudioFocusChange(@NonNull AudioFocusInfo afi, int focusChange, @NonNull AudioPolicy ap)",
    "returnType" : "int",
    "comment" : "\n     * @hide\n     * Notifies an application with a focus listener of gain or loss of audio focus.\n     * This method can only be used by owners of an {@link AudioPolicy} configured with\n     * {@link AudioPolicy.Builder#setIsAudioFocusPolicy(boolean)} set to true.\n     * @param afi the recipient of the focus change, that has previously requested audio focus, and\n     *     that was received by the {@code AudioPolicy} through\n     *     {@link AudioPolicy.AudioPolicyFocusListener#onAudioFocusRequest(AudioFocusInfo, int)}.\n     * @param focusChange one of focus gain types ({@link #AUDIOFOCUS_GAIN},\n     *     {@link #AUDIOFOCUS_GAIN_TRANSIENT}, {@link #AUDIOFOCUS_GAIN_TRANSIENT_MAY_DUCK} or\n     *     {@link #AUDIOFOCUS_GAIN_TRANSIENT_EXCLUSIVE})\n     *     or one of the focus loss types ({@link AudioManager#AUDIOFOCUS_LOSS},\n     *     {@link AudioManager#AUDIOFOCUS_LOSS_TRANSIENT},\n     *     or {@link AudioManager#AUDIOFOCUS_LOSS_TRANSIENT_CAN_DUCK}).\n     *     <br>For the focus gain, the change type should be the same as the app requested.\n     * @param ap a valid registered {@link AudioPolicy} configured as a focus policy.\n     * @return {@link #AUDIOFOCUS_REQUEST_GRANTED} if the dispatch was successfully sent, or\n     *     {@link #AUDIOFOCUS_REQUEST_FAILED} if the focus client didn't have a listener, or\n     *     if there was an error sending the request.\n     * @throws NullPointerException if the {@link AudioFocusInfo} or {@link AudioPolicy} are null.\n     ",
    "links" : [ "#AUDIOFOCUS_GAIN_TRANSIENT_MAY_DUCK", "android.media.AudioManager#AUDIOFOCUS_LOSS_TRANSIENT", "AudioPolicy.Builder#setIsAudioFocusPolicy(boolean)", "#AUDIOFOCUS_GAIN_TRANSIENT_EXCLUSIVE", "AudioPolicy.AudioPolicyFocusListener#onAudioFocusRequest(AudioFocusInfo", "android.media.AudioManager#AUDIOFOCUS_LOSS_TRANSIENT_CAN_DUCK", "#AUDIOFOCUS_REQUEST_GRANTED", "#AUDIOFOCUS_GAIN_TRANSIENT", "android.media.AudioFocusInfo", "android.media.audiopolicy.AudioPolicy", "#AUDIOFOCUS_REQUEST_FAILED", "#AUDIOFOCUS_GAIN", "android.media.AudioManager#AUDIOFOCUS_LOSS" ]
  }, {
    "name" : "public int dispatchAudioFocusChangeWithFade(@NonNull AudioFocusInfo afi, int focusChange, @NonNull AudioPolicy ap, @NonNull List<AudioFocusInfo> otherActiveAfis, @Nullable FadeManagerConfiguration transientFadeMgrConfig)",
    "returnType" : "int",
    "comment" : "\n     * Notifies an application with a focus listener of gain or loss of audio focus\n     *\n     * <p>This is similar to {@link #dispatchAudioFocusChange(AudioFocusInfo, int, AudioPolicy)} but\n     * with additional functionality  of fade. The players of the application with  audio focus\n     * change, provided they meet the active {@link FadeManagerConfiguration} requirements, are\n     * faded before dispatching the callback to the application. For example, players of the\n     * application losing audio focus will be faded out, whereas players of the application gaining\n     * audio focus will be faded in, if needed.\n     *\n     * <p>The applicability of fade is decided against the supplied active {@link AudioFocusInfo}.\n     * This list cannot be {@code null}. The list can be empty if no other active\n     * {@link AudioFocusInfo} available at the time of the dispatch.\n     *\n     * <p>The {@link FadeManagerConfiguration} supplied here is prioritized over existing fade\n     * configurations. If none supplied, either the {@link FadeManagerConfiguration} set through\n     * {@link AudioPolicy} or the default will be used to determine the fade properties.\n     *\n     * <p>This method can only be used by owners of an {@link AudioPolicy} configured with\n     * {@link AudioPolicy.Builder#setIsAudioFocusPolicy(boolean)} set to true.\n     *\n     * @param afi the recipient of the focus change, that has previously requested audio focus, and\n     *     that was received by the {@code AudioPolicy} through\n     *     {@link AudioPolicy.AudioPolicyFocusListener#onAudioFocusRequest(AudioFocusInfo, int)}\n     * @param focusChange one of focus gain types ({@link #AUDIOFOCUS_GAIN},\n     *     {@link #AUDIOFOCUS_GAIN_TRANSIENT}, {@link #AUDIOFOCUS_GAIN_TRANSIENT_MAY_DUCK} or\n     *     {@link #AUDIOFOCUS_GAIN_TRANSIENT_EXCLUSIVE})\n     *     or one of the focus loss types ({@link AudioManager#AUDIOFOCUS_LOSS},\n     *     {@link AudioManager#AUDIOFOCUS_LOSS_TRANSIENT},\n     *     or {@link AudioManager#AUDIOFOCUS_LOSS_TRANSIENT_CAN_DUCK}).\n     *     <br>For the focus gain, the change type should be the same as the app requested\n     * @param ap a valid registered {@link AudioPolicy} configured as a focus policy.\n     * @param otherActiveAfis active {@link AudioFocusInfo} that are granted audio focus at the time\n     *     of dispatch\n     * @param transientFadeMgrConfig {@link FadeManagerConfiguration} that will be used for fading\n     *     players resulting from this dispatch. This is a transient configuration that is only\n     *     valid for this focus change and shall be discarded after processing this request.\n     * @return {@link #AUDIOFOCUS_REQUEST_FAILED} if the focus client didn't have a listener or if\n     *     there was an error sending the request, or {@link #AUDIOFOCUS_REQUEST_GRANTED} if the\n     *     dispatch was successfully sent, or {@link #AUDIOFOCUS_REQUEST_DELAYED} if\n     *     the request was successful but the dispatch of focus change was delayed due to a fade\n     *     operation.\n     * @hide\n     ",
    "links" : [ "#AUDIOFOCUS_GAIN_TRANSIENT_MAY_DUCK", "android.media.AudioManager#AUDIOFOCUS_LOSS_TRANSIENT", "AudioPolicy.Builder#setIsAudioFocusPolicy(boolean)", "#AUDIOFOCUS_GAIN_TRANSIENT_EXCLUSIVE", "AudioPolicy.AudioPolicyFocusListener#onAudioFocusRequest(AudioFocusInfo", "android.media.AudioManager#AUDIOFOCUS_LOSS_TRANSIENT_CAN_DUCK", "#AUDIOFOCUS_REQUEST_GRANTED", "#AUDIOFOCUS_REQUEST_DELAYED", "android.media.FadeManagerConfiguration", "android.media.AudioFocusInfo", "#AUDIOFOCUS_GAIN_TRANSIENT", "android.media.audiopolicy.AudioPolicy", "#AUDIOFOCUS_REQUEST_FAILED", "#dispatchAudioFocusChange(AudioFocusInfo", "#AUDIOFOCUS_GAIN", "android.media.AudioManager#AUDIOFOCUS_LOSS" ]
  }, {
    "name" : "public void abandonAudioFocusForCall()",
    "returnType" : "void",
    "comment" : "\n     * @hide\n     * Used internally by telephony package to abandon audio focus, typically after a call or\n     * when ringing ends and the call is rejected or not answered.\n     * Should match one or more calls to {@link #requestAudioFocusForCall(int, int)}.\n     ",
    "links" : [ "#requestAudioFocusForCall(int" ]
  }, {
    "name" : "public int abandonAudioFocus(OnAudioFocusChangeListener l)",
    "returnType" : "int",
    "comment" : "\n     *  Abandon audio focus. Causes the previous focus owner, if any, to receive focus.\n     *  @param l the listener with which focus was requested.\n     *  @return {@link #AUDIOFOCUS_REQUEST_FAILED} or {@link #AUDIOFOCUS_REQUEST_GRANTED}\n     *  @deprecated use {@link #abandonAudioFocusRequest(AudioFocusRequest)}\n     ",
    "links" : [ "#abandonAudioFocusRequest(AudioFocusRequest)", "#AUDIOFOCUS_REQUEST_GRANTED", "#AUDIOFOCUS_REQUEST_FAILED" ]
  }, {
    "name" : "public int abandonAudioFocus(OnAudioFocusChangeListener l, AudioAttributes aa)",
    "returnType" : "int",
    "comment" : "\n     * @hide\n     * Abandon audio focus. Causes the previous focus owner, if any, to receive focus.\n     *  @param l the listener with which focus was requested.\n     * @param aa the {@link AudioAttributes} with which audio focus was requested\n     * @return {@link #AUDIOFOCUS_REQUEST_FAILED} or {@link #AUDIOFOCUS_REQUEST_GRANTED}\n     * @deprecated use {@link #abandonAudioFocusRequest(AudioFocusRequest)}\n     ",
    "links" : [ "#abandonAudioFocusRequest(AudioFocusRequest)", "#AUDIOFOCUS_REQUEST_GRANTED", "android.media.AudioAttributes", "#AUDIOFOCUS_REQUEST_FAILED" ]
  }, {
    "name" : "public void registerMediaButtonEventReceiver(ComponentName eventReceiver)",
    "returnType" : "void",
    "comment" : "\n     * Register a component to be the sole receiver of MEDIA_BUTTON intents.\n     * @param eventReceiver identifier of a {@link android.content.BroadcastReceiver}\n     *      that will receive the media button intent. This broadcast receiver must be declared\n     *      in the application manifest. The package of the component must match that of\n     *      the context you're registering from.\n     * @deprecated Use {@link MediaSession#setMediaButtonReceiver(PendingIntent)} instead.\n     ",
    "links" : [ "android.media.session.MediaSession#setMediaButtonReceiver(PendingIntent)", "android.content.BroadcastReceiver" ]
  }, {
    "name" : "public void registerMediaButtonEventReceiver(PendingIntent eventReceiver)",
    "returnType" : "void",
    "comment" : "\n     * Register a component to be the sole receiver of MEDIA_BUTTON intents.  This is like\n     * {@link #registerMediaButtonEventReceiver(android.content.ComponentName)}, but allows\n     * the buttons to go to any PendingIntent.  Note that you should only use this form if\n     * you know you will continue running for the full time until unregistering the\n     * PendingIntent.\n     * @param eventReceiver target that will receive media button intents.  The PendingIntent\n     * will be sent an {@link Intent#ACTION_MEDIA_BUTTON} event when a media button action\n     * occurs, with {@link Intent#EXTRA_KEY_EVENT} added and holding the key code of the\n     * media button that was pressed.\n     * @deprecated Use {@link MediaSession#setMediaButtonReceiver(PendingIntent)} instead.\n     ",
    "links" : [ "#registerMediaButtonEventReceiver(android.content.ComponentName)", "android.app.PendingIntent#ACTION_MEDIA_BUTTON", "android.media.session.MediaSession#setMediaButtonReceiver(PendingIntent)", "android.app.PendingIntent#EXTRA_KEY_EVENT" ]
  }, {
    "name" : "public void registerMediaButtonIntent(PendingIntent pi, ComponentName eventReceiver)",
    "returnType" : "void",
    "comment" : "\n     * @hide\n     * no-op if (pi == null) or (eventReceiver == null)\n     ",
    "links" : [ ]
  }, {
    "name" : "public void unregisterMediaButtonEventReceiver(ComponentName eventReceiver)",
    "returnType" : "void",
    "comment" : "\n     * Unregister the receiver of MEDIA_BUTTON intents.\n     * @param eventReceiver identifier of a {@link android.content.BroadcastReceiver}\n     *      that was registered with {@link #registerMediaButtonEventReceiver(ComponentName)}.\n     * @deprecated Use {@link MediaSession} instead.\n     ",
    "links" : [ "#registerMediaButtonEventReceiver(ComponentName)", "android.media.session.MediaSession", "android.content.BroadcastReceiver" ]
  }, {
    "name" : "public void unregisterMediaButtonEventReceiver(PendingIntent eventReceiver)",
    "returnType" : "void",
    "comment" : "\n     * Unregister the receiver of MEDIA_BUTTON intents.\n     * @param eventReceiver same PendingIntent that was registed with\n     *      {@link #registerMediaButtonEventReceiver(PendingIntent)}.\n     * @deprecated Use {@link MediaSession} instead.\n     ",
    "links" : [ "android.media.session.MediaSession", "#registerMediaButtonEventReceiver(PendingIntent)" ]
  }, {
    "name" : "public void unregisterMediaButtonIntent(PendingIntent pi)",
    "returnType" : "void",
    "comment" : "\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public void registerRemoteControlClient(RemoteControlClient rcClient)",
    "returnType" : "void",
    "comment" : "\n     * Registers the remote control client for providing information to display on the remote\n     * controls.\n     * @param rcClient The remote control client from which remote controls will receive\n     *      information to display.\n     * @see RemoteControlClient\n     * @deprecated Use {@link MediaSession} instead.\n     ",
    "links" : [ "android.media.session.MediaSession" ]
  }, {
    "name" : "public void unregisterRemoteControlClient(RemoteControlClient rcClient)",
    "returnType" : "void",
    "comment" : "\n     * Unregisters the remote control client that was providing information to display on the\n     * remote controls.\n     * @param rcClient The remote control client to unregister.\n     * @see #registerRemoteControlClient(RemoteControlClient)\n     * @deprecated Use {@link MediaSession} instead.\n     ",
    "links" : [ "android.media.session.MediaSession" ]
  }, {
    "name" : "public boolean registerRemoteController(RemoteController rctlr)",
    "returnType" : "boolean",
    "comment" : "\n     * Registers a {@link RemoteController} instance for it to receive media\n     * metadata updates and playback state information from applications using\n     * {@link RemoteControlClient}, and control their playback.\n     * <p>\n     * Registration requires the {@link RemoteController.OnClientUpdateListener} listener to be\n     * one of the enabled notification listeners (see\n     * {@link android.service.notification.NotificationListenerService}).\n     *\n     * @param rctlr the object to register.\n     * @return true if the {@link RemoteController} was successfully registered,\n     *         false if an error occurred, due to an internal system error, or\n     *         insufficient permissions.\n     * @deprecated Use\n     *             {@link MediaSessionManager#addOnActiveSessionsChangedListener(android.media.session.MediaSessionManager.OnActiveSessionsChangedListener, ComponentName)}\n     *             and {@link MediaController} instead.\n     ",
    "links" : [ "android.media.RemoteControlClient", "android.media.session.MediaSessionManager#addOnActiveSessionsChangedListener(android.media.session.MediaSessionManager.OnActiveSessionsChangedListener", "android.media.RemoteController", "RemoteController.OnClientUpdateListener", "android.service.notification.NotificationListenerService", "android.media.session.MediaController" ]
  }, {
    "name" : "public void unregisterRemoteController(RemoteController rctlr)",
    "returnType" : "void",
    "comment" : "\n     * Unregisters a {@link RemoteController}, causing it to no longer receive\n     * media metadata and playback state information, and no longer be capable\n     * of controlling playback.\n     *\n     * @param rctlr the object to unregister.\n     * @deprecated Use\n     *             {@link MediaSessionManager#removeOnActiveSessionsChangedListener(android.media.session.MediaSessionManager.OnActiveSessionsChangedListener)}\n     *             instead.\n     ",
    "links" : [ "android.media.RemoteController", "android.media.session.MediaSessionManager#removeOnActiveSessionsChangedListener(android.media.session.MediaSessionManager.OnActiveSessionsChangedListener)" ]
  }, {
    "name" : "public int registerAudioPolicy(@NonNull AudioPolicy policy)",
    "returnType" : "int",
    "comment" : "\n     * @hide\n     * Register the given {@link AudioPolicy}.\n     * This call is synchronous and blocks until the registration process successfully completed\n     * or failed to complete.\n     * @param policy the non-null {@link AudioPolicy} to register.\n     * @return {@link #ERROR} if there was an error communicating with the registration service\n     *    or if the user doesn't have the required\n     *    {@link Manifest.permission#MODIFY_AUDIO_ROUTING} permission,\n     *    {@link #SUCCESS} otherwise.\n     ",
    "links" : [ "Manifest.permission#MODIFY_AUDIO_ROUTING", "#ERROR", "#SUCCESS", "android.media.audiopolicy.AudioPolicy" ]
  }, {
    "name" : " static int registerAudioPolicyStatic(@NonNull AudioPolicy policy)",
    "returnType" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public void unregisterAudioPolicyAsync(@NonNull AudioPolicy policy)",
    "returnType" : "void",
    "comment" : "\n     * @hide\n     * Unregisters an {@link AudioPolicy} asynchronously.\n     * @param policy the non-null {@link AudioPolicy} to unregister.\n     ",
    "links" : [ "android.media.audiopolicy.AudioPolicy" ]
  }, {
    "name" : " static void unregisterAudioPolicyAsyncStatic(@NonNull AudioPolicy policy)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public void unregisterAudioPolicy(@NonNull AudioPolicy policy)",
    "returnType" : "void",
    "comment" : "\n     * @hide\n     * Unregisters an {@link AudioPolicy} synchronously.\n     * This method also invalidates all {@link AudioRecord} and {@link AudioTrack} objects\n     * associated with mixes of this policy.\n     * @param policy the non-null {@link AudioPolicy} to unregister.\n     ",
    "links" : [ "android.media.AudioRecord", "android.media.AudioTrack", "android.media.audiopolicy.AudioPolicy" ]
  }, {
    "name" : "public List<android.media.audiopolicy.AudioMix> getRegisteredPolicyMixes()",
    "returnType" : "List<android.media.audiopolicy.AudioMix>",
    "comment" : "\n     * @hide\n     * @return All currently registered audio policy mixes.\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean hasRegisteredDynamicPolicy()",
    "returnType" : "boolean",
    "comment" : "\n     * @hide\n     * @return true if an AudioPolicy was previously registered\n     ",
    "links" : [ ]
  }, {
    "name" : "public void registerAudioPlaybackCallback(@NonNull AudioPlaybackCallback cb, @Nullable Handler handler)",
    "returnType" : "void",
    "comment" : "\n     * Register a callback to be notified of audio playback changes through\n     * {@link AudioPlaybackCallback}\n     * @param cb non-null callback to register\n     * @param handler the {@link Handler} object for the thread on which to execute\n     * the callback. If <code>null</code>, the {@link Handler} associated with the main\n     * {@link Looper} will be used.\n     ",
    "links" : [ "AudioPlaybackCallback", "android.media.audiopolicy.AudioVolumeGroupChangeHandler", "android.os.Looper" ]
  }, {
    "name" : "public void unregisterAudioPlaybackCallback(@NonNull AudioPlaybackCallback cb)",
    "returnType" : "void",
    "comment" : "\n     * Unregister an audio playback callback previously registered with\n     * {@link #registerAudioPlaybackCallback(AudioPlaybackCallback, Handler)}.\n     * @param cb non-null callback to unregister\n     ",
    "links" : [ "#registerAudioPlaybackCallback(AudioPlaybackCallback" ]
  }, {
    "name" : "public List<AudioPlaybackConfiguration> getActivePlaybackConfigurations()",
    "returnType" : "List<AudioPlaybackConfiguration>",
    "comment" : "\n     * Returns the current active audio playback configurations of the device\n     * @return a non-null list of playback configurations. An empty list indicates there is no\n     *     playback active when queried.\n     * @see AudioPlaybackConfiguration\n     ",
    "links" : [ ]
  }, {
    "name" : "private boolean hasPlaybackCallback_sync(@NonNull AudioPlaybackCallback cb)",
    "returnType" : "boolean",
    "comment" : "\n     * Must be called synchronized on mPlaybackCallbackLock\n     ",
    "links" : [ ]
  }, {
    "name" : "private boolean removePlaybackCallback_sync(@NonNull AudioPlaybackCallback cb)",
    "returnType" : "boolean",
    "comment" : "\n     * Must be called synchronized on mPlaybackCallbackLock\n     ",
    "links" : [ ]
  }, {
    "name" : "public void registerAudioRecordingCallback(@NonNull AudioRecordingCallback cb, @Nullable Handler handler)",
    "returnType" : "void",
    "comment" : "\n     * Register a callback to be notified of audio recording changes through\n     * {@link AudioRecordingCallback}\n     * @param cb non-null callback to register\n     * @param handler the {@link Handler} object for the thread on which to execute\n     * the callback. If <code>null</code>, the {@link Handler} associated with the main\n     * {@link Looper} will be used.\n     ",
    "links" : [ "android.media.audiopolicy.AudioVolumeGroupChangeHandler", "android.os.Looper", "AudioRecordingCallback" ]
  }, {
    "name" : "public void unregisterAudioRecordingCallback(@NonNull AudioRecordingCallback cb)",
    "returnType" : "void",
    "comment" : "\n     * Unregister an audio recording callback previously registered with\n     * {@link #registerAudioRecordingCallback(AudioRecordingCallback, Handler)}.\n     * @param cb non-null callback to unregister\n     ",
    "links" : [ "#registerAudioRecordingCallback(AudioRecordingCallback" ]
  }, {
    "name" : "public List<AudioRecordingConfiguration> getActiveRecordingConfigurations()",
    "returnType" : "List<AudioRecordingConfiguration>",
    "comment" : "\n     * Returns the current active audio recording configurations of the device.\n     * @return a non-null list of recording configurations. An empty list indicates there is\n     *     no recording active when queried.\n     * @see AudioRecordingConfiguration\n     ",
    "links" : [ ]
  }, {
    "name" : "private boolean hasRecordCallback_sync(@NonNull AudioRecordingCallback cb)",
    "returnType" : "boolean",
    "comment" : "\n     * Must be called synchronized on mRecordCallbackLock\n     ",
    "links" : [ ]
  }, {
    "name" : "private boolean removeRecordCallback_sync(@NonNull AudioRecordingCallback cb)",
    "returnType" : "boolean",
    "comment" : "\n     * Must be called synchronized on mRecordCallbackLock\n     ",
    "links" : [ ]
  }, {
    "name" : "public void reloadAudioSettings()",
    "returnType" : "void",
    "comment" : "\n     *  @hide\n     *  Reload audio settings. This method is called by Settings backup\n     *  agent when audio settings are restored and causes the AudioService\n     *  to read and apply restored settings.\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean isSilentMode()",
    "returnType" : "boolean",
    "comment" : "\n     * Checks whether the phone is in silent mode, with or without vibrate.\n     *\n     * @return true if phone is in silent mode, with or without vibrate.\n     *\n     * @see #getRingerMode()\n     *\n     * @hide pending API Council approval\n     ",
    "links" : [ ]
  }, {
    "name" : "public static boolean isOutputDevice(int device)",
    "returnType" : "boolean",
    "comment" : "\n     * Return true if the device code corresponds to an output device.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public static boolean isInputDevice(int device)",
    "returnType" : "boolean",
    "comment" : "\n     * Return true if the device code corresponds to an input device.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public int getDevicesForStream(int streamType)",
    "returnType" : "int",
    "comment" : "\n     * Return the enabled devices for the specified output stream type.\n     *\n     * @param streamType The stream type to query. One of\n     *            {@link #STREAM_VOICE_CALL},\n     *            {@link #STREAM_SYSTEM},\n     *            {@link #STREAM_RING},\n     *            {@link #STREAM_MUSIC},\n     *            {@link #STREAM_ALARM},\n     *            {@link #STREAM_NOTIFICATION},\n     *            {@link #STREAM_DTMF},\n     *            {@link #STREAM_ACCESSIBILITY}.\n     *\n     * @return The bit-mask \"or\" of audio output device codes for all enabled devices on this\n     *         stream. Zero or more of\n     *            {@link #DEVICE_OUT_EARPIECE},\n     *            {@link #DEVICE_OUT_SPEAKER},\n     *            {@link #DEVICE_OUT_WIRED_HEADSET},\n     *            {@link #DEVICE_OUT_WIRED_HEADPHONE},\n     *            {@link #DEVICE_OUT_BLUETOOTH_SCO},\n     *            {@link #DEVICE_OUT_BLUETOOTH_SCO_HEADSET},\n     *            {@link #DEVICE_OUT_BLUETOOTH_SCO_CARKIT},\n     *            {@link #DEVICE_OUT_BLUETOOTH_A2DP},\n     *            {@link #DEVICE_OUT_BLUETOOTH_A2DP_HEADPHONES},\n     *            {@link #DEVICE_OUT_BLUETOOTH_A2DP_SPEAKER},\n     *            {@link #DEVICE_OUT_HDMI},\n     *            {@link #DEVICE_OUT_ANLG_DOCK_HEADSET},\n     *            {@link #DEVICE_OUT_DGTL_DOCK_HEADSET}.\n     *            {@link #DEVICE_OUT_USB_ACCESSORY}.\n     *            {@link #DEVICE_OUT_USB_DEVICE}.\n     *            {@link #DEVICE_OUT_REMOTE_SUBMIX}.\n     *            {@link #DEVICE_OUT_TELEPHONY_TX}.\n     *            {@link #DEVICE_OUT_LINE}.\n     *            {@link #DEVICE_OUT_HDMI_ARC}.\n     *            {@link #DEVICE_OUT_HDMI_EARC}.\n     *            {@link #DEVICE_OUT_SPDIF}.\n     *            {@link #DEVICE_OUT_FM}.\n     *            {@link #DEVICE_OUT_DEFAULT} is not used here.\n     *\n     * The implementation may support additional device codes beyond those listed, so\n     * the application should ignore any bits which it does not recognize.\n     * Note that the information may be imprecise when the implementation\n     * cannot distinguish whether a particular device is enabled.\n     *\n     * @deprecated on {@link android.os.Build.VERSION_CODES#T} as new devices\n     *             will have multi-bit device types.\n     *             Prefer to use {@link #getDevicesForAttributes()} instead,\n     *             noting that getDevicesForStream() has a few small discrepancies\n     *             for better volume handling.\n     * @hide\n     ",
    "links" : [ "#DEVICE_OUT_WIRED_HEADSET", "#DEVICE_OUT_HDMI_ARC", "#DEVICE_OUT_BLUETOOTH_SCO", "#DEVICE_OUT_BLUETOOTH_SCO_CARKIT", "#DEVICE_OUT_EARPIECE", "#DEVICE_OUT_DEFAULT", "#DEVICE_OUT_DGTL_DOCK_HEADSET", "#DEVICE_OUT_FM", "#DEVICE_OUT_REMOTE_SUBMIX", "#STREAM_ALARM", "#DEVICE_OUT_BLUETOOTH_A2DP_SPEAKER", "#DEVICE_OUT_SPDIF", "#STREAM_SYSTEM", "#DEVICE_OUT_HDMI", "#DEVICE_OUT_USB_ACCESSORY", "#getDevicesForAttributes()", "#STREAM_VOICE_CALL", "#STREAM_MUSIC", "#STREAM_NOTIFICATION", "#STREAM_DTMF", "#DEVICE_OUT_TELEPHONY_TX", "#DEVICE_OUT_BLUETOOTH_A2DP", "#DEVICE_OUT_BLUETOOTH_SCO_HEADSET", "#DEVICE_OUT_HDMI_EARC", "#STREAM_RING", "#DEVICE_OUT_ANLG_DOCK_HEADSET", "#DEVICE_OUT_USB_DEVICE", "#DEVICE_OUT_SPEAKER", "android.os.Build.VERSION_CODES#T", "#DEVICE_OUT_LINE", "#DEVICE_OUT_BLUETOOTH_A2DP_HEADPHONES", "#DEVICE_OUT_WIRED_HEADPHONE", "#STREAM_ACCESSIBILITY" ]
  }, {
    "name" : "public List<AudioDeviceAttributes> getDevicesForAttributes(@NonNull AudioAttributes attributes)",
    "returnType" : "List<AudioDeviceAttributes>",
    "comment" : "\n     * @hide\n     * Get the audio devices that would be used for the routing of the given audio attributes.\n     * @param attributes the {@link AudioAttributes} for which the routing is being queried\n     * @return an empty list if there was an issue with the request, a list of audio devices\n     *   otherwise (typically one device, except for duplicated paths).\n     ",
    "links" : [ "android.media.AudioAttributes" ]
  }, {
    "name" : "public void addOnDevicesForAttributesChangedListener(@NonNull AudioAttributes attributes, @NonNull @CallbackExecutor Executor executor, @NonNull OnDevicesForAttributesChangedListener listener)",
    "returnType" : "void",
    "comment" : "\n     * @hide\n     * Adds a listener for being notified of routing changes for the given {@link AudioAttributes}.\n     * @param attributes the {@link AudioAttributes} to listen for routing changes\n     * @param executor\n     * @param listener\n     ",
    "links" : [ "android.media.AudioAttributes" ]
  }, {
    "name" : "public void removeOnDevicesForAttributesChangedListener(@NonNull OnDevicesForAttributesChangedListener listener)",
    "returnType" : "void",
    "comment" : "\n     * @hide\n     * Removes a previously registered listener for being notified of routing changes for the given\n     * {@link AudioAttributes}.\n     * @param listener\n     ",
    "links" : [ "android.media.AudioAttributes" ]
  }, {
    "name" : "public List<AudioDeviceInfo> getAudioDevicesForAttributes(@NonNull AudioAttributes attributes)",
    "returnType" : "List<AudioDeviceInfo>",
    "comment" : "\n     * Get the audio devices that would be used for the routing of the given audio attributes.\n     * These are the devices anticipated to play sound from an {@link AudioTrack} created with\n     * the specified {@link AudioAttributes}.\n     * The audio routing can change if audio devices are physically connected or disconnected or\n     * concurrently through {@link AudioRouting} or {@link MediaRouter}.\n     * @param attributes the {@link AudioAttributes} for which the routing is being queried\n     * @return an empty list if there was an issue with the request, a list of\n     * {@link AudioDeviceInfo} otherwise (typically one device, except for duplicated paths).\n     ",
    "links" : [ "android.media.AudioRouting", "android.media.MediaRouter", "android.media.AudioAttributes", "android.media.AudioTrack", "android.media.AudioDeviceInfo" ]
  }, {
    "name" : "public static void enforceValidVolumeBehavior(int volumeBehavior)",
    "returnType" : "void",
    "comment" : "\n     * @hide\n     * Throws IAE on an invalid volume behavior value\n     * @param volumeBehavior behavior value to check\n     ",
    "links" : [ ]
  }, {
    "name" : "public void setDeviceVolumeBehavior(@NonNull AudioDeviceAttributes device, @DeviceVolumeBehavior int deviceVolumeBehavior)",
    "returnType" : "void",
    "comment" : "\n     * @hide\n     * Sets the volume behavior for an audio output device.\n     * @see #DEVICE_VOLUME_BEHAVIOR_VARIABLE\n     * @see #DEVICE_VOLUME_BEHAVIOR_FULL\n     * @see #DEVICE_VOLUME_BEHAVIOR_FIXED\n     * @see #DEVICE_VOLUME_BEHAVIOR_ABSOLUTE\n     * @see #DEVICE_VOLUME_BEHAVIOR_ABSOLUTE_MULTI_MODE\n     * @param device the device to be affected\n     * @param deviceVolumeBehavior one of the device behaviors\n     ",
    "links" : [ ]
  }, {
    "name" : "public int getDeviceVolumeBehavior(@NonNull AudioDeviceAttributes device)",
    "returnType" : "int",
    "comment" : "\n     * @hide\n     * Returns the volume device behavior for the given audio device\n     * @param device the audio device\n     * @return the volume behavior for the device\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean isFullVolumeDevice()",
    "returnType" : "boolean",
    "comment" : "\n     * @hide\n     * Returns {@code true} if the volume device behavior is {@link #DEVICE_VOLUME_BEHAVIOR_FULL}.\n     ",
    "links" : [ "#DEVICE_VOLUME_BEHAVIOR_FULL" ]
  }, {
    "name" : "public void setWiredDeviceConnectionState(int device, int state, String address, String name)",
    "returnType" : "void",
    "comment" : "\n     * Indicate wired accessory connection state change.\n     * @param device type of device connected/disconnected (AudioManager.DEVICE_OUT_xxx)\n     * @param state  new connection state: 1 connected, 0 disconnected\n     * @param name   device name\n     * {@hide}\n     ",
    "links" : [ ]
  }, {
    "name" : "public void setWiredDeviceConnectionState(AudioDeviceAttributes attributes, int state)",
    "returnType" : "void",
    "comment" : "\n     * Indicate wired accessory connection state change and attributes.\n     * @param state      new connection state: 1 connected, 0 disconnected\n     * @param attributes attributes of the connected device\n     * {@hide}\n     ",
    "links" : [ ]
  }, {
    "name" : "public void setTestDeviceConnectionState(@NonNull AudioDeviceAttributes device, boolean connected)",
    "returnType" : "void",
    "comment" : "\n     * Indicate wired accessory connection state change.\n     * @param device {@link AudioDeviceAttributes} of the device to \"fake-connect\"\n     * @param connected true for connected, false for disconnected\n     * {@hide}\n     ",
    "links" : [ "android.media.AudioDeviceAttributes" ]
  }, {
    "name" : "public void handleBluetoothActiveDeviceChanged(@Nullable BluetoothDevice newDevice, @Nullable BluetoothDevice previousDevice, @NonNull BluetoothProfileConnectionInfo info)",
    "returnType" : "void",
    "comment" : "\n     * Indicate Bluetooth profile connection state change.\n     * Configuration changes for A2DP are indicated by having the same <code>newDevice</code> and\n     * <code>previousDevice</code>\n     * This operation is asynchronous.\n     *\n     * @param newDevice Bluetooth device connected or null if there is no new devices\n     * @param previousDevice Bluetooth device disconnected or null if there is no disconnected\n     * devices\n     * @param info contain all info related to the device. {@link BluetoothProfileConnectionInfo}\n     * {@hide}\n     ",
    "links" : [ "android.media.BluetoothProfileConnectionInfo" ]
  }, {
    "name" : "public IRingtonePlayer getRingtonePlayer()",
    "returnType" : "IRingtonePlayer",
    "comment" : " {@hide} ",
    "links" : [ ]
  }, {
    "name" : "public String getProperty(String key)",
    "returnType" : "String",
    "comment" : "\n     * Returns the value of the property with the specified key.\n     * @param key One of the strings corresponding to a property key: either\n     *            {@link #PROPERTY_OUTPUT_SAMPLE_RATE},\n     *            {@link #PROPERTY_OUTPUT_FRAMES_PER_BUFFER},\n     *            {@link #PROPERTY_SUPPORT_MIC_NEAR_ULTRASOUND},\n     *            {@link #PROPERTY_SUPPORT_SPEAKER_NEAR_ULTRASOUND}, or\n     *            {@link #PROPERTY_SUPPORT_AUDIO_SOURCE_UNPROCESSED}.\n     * @return A string representing the associated value for that property key,\n     *         or null if there is no value for that key.\n     ",
    "links" : [ "#PROPERTY_OUTPUT_SAMPLE_RATE", "#PROPERTY_SUPPORT_AUDIO_SOURCE_UNPROCESSED", "#PROPERTY_OUTPUT_FRAMES_PER_BUFFER", "#PROPERTY_SUPPORT_MIC_NEAR_ULTRASOUND", "#PROPERTY_SUPPORT_SPEAKER_NEAR_ULTRASOUND" ]
  }, {
    "name" : "public boolean setAdditionalOutputDeviceDelay(@NonNull AudioDeviceInfo device, @IntRange(from = 0) long delayMillis)",
    "returnType" : "boolean",
    "comment" : "\n     * @hide\n     * Sets an additional audio output device delay in milliseconds.\n     *\n     * The additional output delay is a request to the output device to\n     * delay audio presentation (generally with respect to video presentation for better\n     * synchronization).\n     * It may not be supported by all output devices,\n     * and typically increases the audio latency by the amount of additional\n     * audio delay requested.\n     *\n     * If additional audio delay is supported by an audio output device,\n     * it is expected to be supported for all output streams (and configurations)\n     * opened on that device.\n     *\n     * @param device an instance of {@link AudioDeviceInfo} returned from {@link getDevices()}.\n     * @param delayMillis delay in milliseconds desired.  This should be in range of {@code 0}\n     *     to the value returned by {@link #getMaxAdditionalOutputDeviceDelay()}.\n     * @return true if successful, false if the device does not support output device delay\n     *     or the delay is not in range of {@link #getMaxAdditionalOutputDeviceDelay()}.\n     ",
    "links" : [ "getDevices()", "#getMaxAdditionalOutputDeviceDelay()", "android.media.AudioDeviceInfo" ]
  }, {
    "name" : "public long getAdditionalOutputDeviceDelay(@NonNull AudioDeviceInfo device)",
    "returnType" : "long",
    "comment" : "\n     * @hide\n     * Returns the current additional audio output device delay in milliseconds.\n     *\n     * @param device an instance of {@link AudioDeviceInfo} returned from {@link getDevices()}.\n     * @return the additional output device delay. This is a non-negative number.\n     *     {@code 0} is returned if unsupported.\n     ",
    "links" : [ "getDevices()", "android.media.AudioDeviceInfo" ]
  }, {
    "name" : "public long getMaxAdditionalOutputDeviceDelay(@NonNull AudioDeviceInfo device)",
    "returnType" : "long",
    "comment" : "\n     * @hide\n     * Returns the maximum additional audio output device delay in milliseconds.\n     *\n     * @param device an instance of {@link AudioDeviceInfo} returned from {@link getDevices()}.\n     * @return the maximum output device delay in milliseconds that can be set.\n     *     This is a non-negative number\n     *     representing the additional audio delay supported for the device.\n     *     {@code 0} is returned if unsupported.\n     ",
    "links" : [ "getDevices()", "android.media.AudioDeviceInfo" ]
  }, {
    "name" : "public int getOutputLatency(int streamType)",
    "returnType" : "int",
    "comment" : "\n     * Returns the estimated latency for the given stream type in milliseconds.\n     *\n     * DO NOT UNHIDE. The existing approach for doing A/V sync has too many problems. We need\n     * a better solution.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public void setVolumeController(IVolumeController controller)",
    "returnType" : "void",
    "comment" : "\n     * Registers a global volume controller interface.  Currently limited to SystemUI.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public IVolumeController getVolumeController()",
    "returnType" : "IVolumeController",
    "comment" : "\n     * Returns the registered volume controller interface.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public void notifyVolumeControllerVisible(IVolumeController controller, boolean visible)",
    "returnType" : "void",
    "comment" : "\n     * Notify audio manager about volume controller visibility changes.\n     * Currently limited to SystemUI.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean isStreamAffectedByRingerMode(int streamType)",
    "returnType" : "boolean",
    "comment" : "\n     * Only useful for volume controllers.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean isStreamAffectedByMute(int streamType)",
    "returnType" : "boolean",
    "comment" : "\n     * Only useful for volume controllers.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public void disableSafeMediaVolume()",
    "returnType" : "void",
    "comment" : "\n     * Only useful for volume controllers.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public void lowerVolumeToRs1()",
    "returnType" : "void",
    "comment" : "\n     * @hide\n     * Lower media volume to RS1 interval\n     ",
    "links" : [ ]
  }, {
    "name" : "public float getRs2Value()",
    "returnType" : "float",
    "comment" : "\n     * @hide\n     * @return the RS2 upper bound used for momentary exposure warnings\n     ",
    "links" : [ ]
  }, {
    "name" : "public void setRs2Value(float rs2Value)",
    "returnType" : "void",
    "comment" : "\n     * @hide\n     * Sets the RS2 upper bound used for momentary exposure warnings\n     ",
    "links" : [ ]
  }, {
    "name" : "public float getCsd()",
    "returnType" : "float",
    "comment" : "\n     * @hide\n     * @return the current computed sound dose value\n     ",
    "links" : [ ]
  }, {
    "name" : "public void setCsd(float csd)",
    "returnType" : "void",
    "comment" : "\n     * @hide\n     * Sets the computed sound dose value to {@code csd}. A negative value will\n     * reset all the CSD related timeouts: after a momentary exposure warning and\n     * before the momentary exposure reaches RS2 (see IEC62368-1 10.6.5)\n     ",
    "links" : [ ]
  }, {
    "name" : "public void forceUseFrameworkMel(boolean useFrameworkMel)",
    "returnType" : "void",
    "comment" : "\n     * @hide\n     * Forces the computation of MEL values (used for CSD) on framework level. This will have the\n     * result of ignoring the MEL values computed on HAL level. Should only be used in testing\n     * since this can affect the certification of a device with EN50332-3 regulation.\n     ",
    "links" : [ ]
  }, {
    "name" : "public void forceComputeCsdOnAllDevices(boolean computeCsdOnAllDevices)",
    "returnType" : "void",
    "comment" : "\n     * @hide\n     * Forces the computation of CSD on all output devices.\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean isCsdEnabled()",
    "returnType" : "boolean",
    "comment" : "\n     * @hide\n     * Returns whether CSD is enabled and supported by the current active audio module HAL.\n     * This method will return {@code false) for setups in which CSD as a feature is available\n     * (see {@link AudioManager#isCsdAsAFeatureAvailable()}) and not enabled (see\n     * {@link AudioManager#isCsdAsAFeatureEnabled()}).\n     ",
    "links" : [ "android.media.AudioManager#isCsdAsAFeatureAvailable()", "android.media.AudioManager#isCsdAsAFeatureEnabled()" ]
  }, {
    "name" : "public boolean isCsdAsAFeatureAvailable()",
    "returnType" : "boolean",
    "comment" : "\n     * @hide\n     * Returns whether CSD as a feature can be manipulated by a client. This method\n     * returns {@code true} in countries where there isn't a safe hearing regulation\n     * enforced.\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean isCsdAsAFeatureEnabled()",
    "returnType" : "boolean",
    "comment" : "\n     * @hide\n     * Returns {@code true} if the client has enabled CSD. This function should only\n     * be called if {@link AudioManager#isCsdAsAFeatureAvailable()} returns {@code true}.\n     ",
    "links" : [ "android.media.AudioManager#isCsdAsAFeatureAvailable()" ]
  }, {
    "name" : "public void setCsdAsAFeatureEnabled(boolean csdToggleValue)",
    "returnType" : "void",
    "comment" : "\n     * @hide\n     * Enables/disables the CSD feature. This function should only be called if\n     * {@link AudioManager#isCsdAsAFeatureAvailable()} returns {@code true}.\n     ",
    "links" : [ "android.media.AudioManager#isCsdAsAFeatureAvailable()" ]
  }, {
    "name" : "public static String audioDeviceCategoryToString(int audioDeviceCategory)",
    "returnType" : "String",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "public void setBluetoothAudioDeviceCategory_legacy(@NonNull String address, boolean isBle, @AudioDeviceCategory int btAudioDeviceType)",
    "returnType" : "void",
    "comment" : "\n     * @hide\n     * Sets the audio device type of a Bluetooth device given its MAC address\n     ",
    "links" : [ ]
  }, {
    "name" : "public int getBluetoothAudioDeviceCategory_legacy(@NonNull String address, boolean isBle)",
    "returnType" : "int",
    "comment" : "\n     * @hide\n     * Gets the audio device type of a Bluetooth device given its MAC address\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean setBluetoothAudioDeviceCategory(@NonNull String address, @AudioDeviceCategory int btAudioDeviceCategory)",
    "returnType" : "boolean",
    "comment" : "\n     * @hide\n     * Sets the audio device type of a Bluetooth device given its MAC address\n     *\n     * @return {@code true} if the device type was set successfully. If the\n     *         audio device type was automatically identified this method will\n     *         return {@code false}.\n     ",
    "links" : [ ]
  }, {
    "name" : "public int getBluetoothAudioDeviceCategory(@NonNull String address)",
    "returnType" : "int",
    "comment" : "\n     * @hide\n     * Gets the audio device type of a Bluetooth device given its MAC address\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean isBluetoothAudioDeviceCategoryFixed(@NonNull String address)",
    "returnType" : "boolean",
    "comment" : "\n     * @hide\n     * Returns {@code true} if the audio device type of a Bluetooth device can\n     * be automatically identified\n     ",
    "links" : [ ]
  }, {
    "name" : "public void setRingerModeInternal(int ringerMode)",
    "returnType" : "void",
    "comment" : "\n     * Only useful for volume controllers.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public int getRingerModeInternal()",
    "returnType" : "int",
    "comment" : "\n     * Only useful for volume controllers.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public void setVolumePolicy(VolumePolicy policy)",
    "returnType" : "void",
    "comment" : "\n     * Only useful for volume controllers.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public int setHdmiSystemAudioSupported(boolean on)",
    "returnType" : "int",
    "comment" : "\n     * Set Hdmi Cec system audio mode.\n     *\n     * @param on whether to be on system audio mode\n     * @return output device type. 0 (DEVICE_NONE) if failed to set device.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean isHdmiSystemAudioSupported()",
    "returnType" : "boolean",
    "comment" : "\n     * Returns true if Hdmi Cec system audio mode is supported.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public static int listAudioPorts(ArrayList<AudioPort> ports)",
    "returnType" : "int",
    "comment" : "\n     * Returns a list of descriptors for all audio ports managed by the audio framework.\n     * Audio ports are nodes in the audio framework or audio hardware that can be configured\n     * or connected and disconnected with createAudioPatch() or releaseAudioPatch().\n     * See AudioPort for a list of attributes of each audio port.\n     * @param ports An AudioPort ArrayList where the list will be returned.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public static int listPreviousAudioPorts(ArrayList<AudioPort> ports)",
    "returnType" : "int",
    "comment" : "\n     * Returns a list of descriptors for all audio ports managed by the audio framework as\n     * it was before the last update calback.\n     * @param ports An AudioPort ArrayList where the list will be returned.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public static int listAudioDevicePorts(ArrayList<AudioDevicePort> devices)",
    "returnType" : "int",
    "comment" : "\n     * Specialized version of listAudioPorts() listing only audio devices (AudioDevicePort)\n     * @see listAudioPorts(ArrayList<AudioPort>)\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public static int listPreviousAudioDevicePorts(ArrayList<AudioDevicePort> devices)",
    "returnType" : "int",
    "comment" : "\n     * Specialized version of listPreviousAudioPorts() listing only audio devices (AudioDevicePort)\n     * @see listPreviousAudioPorts(ArrayList<AudioPort>)\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "private static void filterDevicePorts(ArrayList<AudioPort> ports, ArrayList<AudioDevicePort> devices)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public static int createAudioPatch(AudioPatch[] patch, AudioPortConfig[] sources, AudioPortConfig[] sinks)",
    "returnType" : "int",
    "comment" : "\n     * Create a connection between two or more devices. The framework will reject the request if\n     * device types are not compatible or the implementation does not support the requested\n     * configuration.\n     * NOTE: current implementation is limited to one source and one sink per patch.\n     * @param patch AudioPatch array where the newly created patch will be returned.\n     *              As input, if patch[0] is not null, the specified patch will be replaced by the\n     *              new patch created. This avoids calling releaseAudioPatch() when modifying a\n     *              patch and allows the implementation to optimize transitions.\n     * @param sources List of source audio ports. All must be AudioPort.ROLE_SOURCE.\n     * @param sinks   List of sink audio ports. All must be AudioPort.ROLE_SINK.\n     *\n     * @return - {@link #SUCCESS} if connection is successful.\n     *         - {@link #ERROR_BAD_VALUE} if incompatible device types are passed.\n     *         - {@link #ERROR_INVALID_OPERATION} if the requested connection is not supported.\n     *         - {@link #ERROR_PERMISSION_DENIED} if the client does not have permission to create\n     *         a patch.\n     *         - {@link #ERROR_DEAD_OBJECT} if the server process is dead\n     *         - {@link #ERROR} if patch cannot be connected for any other reason.\n     *\n     *         patch[0] contains the newly created patch\n     * @hide\n     ",
    "links" : [ "#ERROR_DEAD_OBJECT", "#ERROR_PERMISSION_DENIED", "#ERROR_BAD_VALUE", "#SUCCESS", "#ERROR", "#ERROR_INVALID_OPERATION" ]
  }, {
    "name" : "public static int releaseAudioPatch(AudioPatch patch)",
    "returnType" : "int",
    "comment" : "\n     * Releases an existing audio patch connection.\n     * @param patch The audio patch to disconnect.\n     * @return - {@link #SUCCESS} if disconnection is successful.\n     *         - {@link #ERROR_BAD_VALUE} if the specified patch does not exist.\n     *         - {@link #ERROR_PERMISSION_DENIED} if the client does not have permission to release\n     *         a patch.\n     *         - {@link #ERROR_DEAD_OBJECT} if the server process is dead\n     *         - {@link #ERROR} if patch cannot be released for any other reason.\n     * @hide\n     ",
    "links" : [ "#ERROR_DEAD_OBJECT", "#ERROR_PERMISSION_DENIED", "#ERROR_BAD_VALUE", "#SUCCESS", "#ERROR" ]
  }, {
    "name" : "public static int listAudioPatches(ArrayList<AudioPatch> patches)",
    "returnType" : "int",
    "comment" : "\n     * List all existing connections between audio ports.\n     * @param patches An AudioPatch array where the list will be returned.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public static int setAudioPortGain(AudioPort port, AudioGainConfig gain)",
    "returnType" : "int",
    "comment" : "\n     * Set the gain on the specified AudioPort. The AudioGainConfig config is build by\n     * AudioGain.buildConfig()\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public void registerAudioPortUpdateListener(OnAudioPortUpdateListener l)",
    "returnType" : "void",
    "comment" : "\n     * Register an audio port list update listener.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public void unregisterAudioPortUpdateListener(OnAudioPortUpdateListener l)",
    "returnType" : "void",
    "comment" : "\n     * Unregister an audio port list update listener.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : " static int resetAudioPortGeneration()",
    "returnType" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : " static int updateAudioPortCache(ArrayList<AudioPort> ports, ArrayList<AudioPatch> patches, ArrayList<AudioPort> previousPorts)",
    "returnType" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : " static AudioPortConfig updatePortConfig(AudioPortConfig portCfg, ArrayList<AudioPort> ports)",
    "returnType" : "AudioPortConfig",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private static boolean checkFlags(AudioDevicePort port, int flags)",
    "returnType" : "boolean",
    "comment" : "\n     * Determines if a given AudioDevicePort meets the specified filter criteria.\n     * @param port  The port to test.\n     * @param flags A set of bitflags specifying the criteria to test.\n     * @see {@link GET_DEVICES_OUTPUTS} and {@link GET_DEVICES_INPUTS}\n     *",
    "links" : [ "GET_DEVICES_INPUTS", "GET_DEVICES_OUTPUTS" ]
  }, {
    "name" : "private static boolean checkTypes(AudioDevicePort port)",
    "returnType" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public Set<Integer> getSupportedDeviceTypes(@AudioDeviceRole int direction)",
    "returnType" : "Set<Integer>",
    "comment" : "\n     * Returns a Set of unique Integers corresponding to audio device type identifiers that can\n     * <i>potentially</i> be connected to the system and meeting the criteria specified in the\n     * <code>direction</code> parameter.\n     * Note that this set contains {@link AudioDeviceInfo} device type identifiers for both devices\n     * currently available <i>and</i> those that can be available if the user connects an audio\n     * peripheral. Examples include TYPE_WIRED_HEADSET if the Android device supports an analog\n     * headset jack or TYPE_USB_DEVICE if the Android device supports a USB host-mode port.\n     * These are generally a superset of device type identifiers associated with the\n     * AudioDeviceInfo objects returned from AudioManager.getDevices().\n     * @param direction The constant specifying whether input or output devices are queried.\n     * @see #GET_DEVICES_OUTPUTS\n     * @see #GET_DEVICES_INPUTS\n     * @return A (possibly zero-length) Set of Integer objects corresponding to the audio\n     * device types of devices supported by the implementation.\n     * @throws IllegalArgumentException If an invalid direction constant is specified.\n     ",
    "links" : [ "android.media.AudioDeviceInfo" ]
  }, {
    "name" : "public AudioDeviceInfo[] getDevices(@AudioDeviceRole int flags)",
    "returnType" : "AudioDeviceInfo[]",
    "comment" : "\n     * Returns an array of {@link AudioDeviceInfo} objects corresponding to the audio devices\n     * currently connected to the system and meeting the criteria specified in the\n     * <code>flags</code> parameter.\n     * Notes that Android audio framework only support one device per device type. In that case,\n     * if there are multiple audio device with the same device type connected to the Android device,\n     * only the last reported device will be known by Android audio framework and returned by this\n     * API.\n     * @param flags A set of bitflags specifying the criteria to test.\n     * @see #GET_DEVICES_OUTPUTS\n     * @see #GET_DEVICES_INPUTS\n     * @see #GET_DEVICES_ALL\n     * @return A (possibly zero-length) array of AudioDeviceInfo objects.\n     ",
    "links" : [ "android.media.AudioDeviceInfo" ]
  }, {
    "name" : "private static AudioDeviceInfo[] infoListFromPortList(ArrayList<AudioDevicePort> ports, int flags)",
    "returnType" : "AudioDeviceInfo[]",
    "comment" : "\n     * Does the actual computation to generate an array of (externally-visible) AudioDeviceInfo\n     * objects from the current (internal) AudioDevicePort list.\n     ",
    "links" : [ ]
  }, {
    "name" : "private static AudioDeviceInfo[] calcListDeltas(ArrayList<AudioDevicePort> ports_A, ArrayList<AudioDevicePort> ports_B, int flags)",
    "returnType" : "AudioDeviceInfo[]",
    "comment" : "\n     * Calculate the list of ports that are in ports_B, but not in ports_A. This is used by\n     * the add/remove callback mechanism to provide a list of the newly added or removed devices\n     * rather than the whole list and make the app figure it out.\n     * Note that calling this method with:\n     *  ports_A == PREVIOUS_ports and ports_B == CURRENT_ports will calculated ADDED ports.\n     *  ports_A == CURRENT_ports and ports_B == PREVIOUS_ports will calculated REMOVED ports.\n     ",
    "links" : [ ]
  }, {
    "name" : "public static AudioDeviceInfo[] getDevicesStatic(int flags)",
    "returnType" : "AudioDeviceInfo[]",
    "comment" : "\n     * Generates a list of AudioDeviceInfo objects corresponding to the audio devices currently\n     * connected to the system and meeting the criteria specified in the <code>flags</code>\n     * parameter.\n     * This is an internal function. The public API front is getDevices(int).\n     * @param flags A set of bitflags specifying the criteria to test.\n     * @see #GET_DEVICES_OUTPUTS\n     * @see #GET_DEVICES_INPUTS\n     * @see #GET_DEVICES_ALL\n     * @return A (possibly zero-length) array of AudioDeviceInfo objects.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public static AudioDeviceInfo getDeviceForPortId(int portId, int flags)",
    "returnType" : "AudioDeviceInfo",
    "comment" : "\n     * Returns an {@link AudioDeviceInfo} corresponding to the specified {@link AudioPort} ID.\n     * @param portId The audio port ID to look up for.\n     * @param flags A set of bitflags specifying the criteria to test.\n     * @see #GET_DEVICES_OUTPUTS\n     * @see #GET_DEVICES_INPUTS\n     * @see #GET_DEVICES_ALL\n     * @return An AudioDeviceInfo or null if no device with matching port ID is found.\n     * @hide\n     ",
    "links" : [ "android.media.AudioDeviceInfo", "android.media.AudioPort" ]
  }, {
    "name" : "public void registerAudioDeviceCallback(AudioDeviceCallback callback, @Nullable Handler handler)",
    "returnType" : "void",
    "comment" : "\n     * Registers an {@link AudioDeviceCallback} object to receive notifications of changes\n     * to the set of connected audio devices.\n     * @param callback The {@link AudioDeviceCallback} object to receive connect/disconnect\n     * notifications.\n     * @param handler Specifies the {@link Handler} object for the thread on which to execute\n     * the callback. If <code>null</code>, the {@link Handler} associated with the main\n     * {@link Looper} will be used.\n     ",
    "links" : [ "android.media.AudioDeviceCallback", "android.media.audiopolicy.AudioVolumeGroupChangeHandler", "android.os.Looper" ]
  }, {
    "name" : "public void unregisterAudioDeviceCallback(AudioDeviceCallback callback)",
    "returnType" : "void",
    "comment" : "\n     * Unregisters an {@link AudioDeviceCallback} object which has been previously registered\n     * to receive notifications of changes to the set of connected audio devices.\n     * @param callback The {@link AudioDeviceCallback} object that was previously registered\n     * with {@link AudioManager#registerAudioDeviceCallback} to be unregistered.\n     ",
    "links" : [ "android.media.AudioDeviceCallback", "android.media.AudioManager#registerAudioDeviceCallback" ]
  }, {
    "name" : "public static void setPortIdForMicrophones(ArrayList<MicrophoneInfo> microphones)",
    "returnType" : "void",
    "comment" : "\n     * Set port id for microphones by matching device type and address.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public static MicrophoneInfo microphoneInfoFromAudioDeviceInfo(AudioDeviceInfo deviceInfo)",
    "returnType" : "MicrophoneInfo",
    "comment" : "\n     * Convert {@link AudioDeviceInfo} to {@link MicrophoneInfo}.\n     * @hide\n     ",
    "links" : [ "android.media.MicrophoneInfo", "android.media.AudioDeviceInfo" ]
  }, {
    "name" : "private void addMicrophonesFromAudioDeviceInfo(ArrayList<MicrophoneInfo> microphones, HashSet<Integer> filterTypes)",
    "returnType" : "void",
    "comment" : "\n     * Add {@link MicrophoneInfo} by device information while filtering certain types.\n     ",
    "links" : [ "android.media.MicrophoneInfo" ]
  }, {
    "name" : "public List<MicrophoneInfo> getMicrophones() throws IOException",
    "returnType" : "List<MicrophoneInfo>",
    "comment" : "\n     * Returns a list of {@link MicrophoneInfo} that corresponds to the characteristics\n     * of all available microphones. The list is empty when no microphones are available\n     * on the device. An error during the query will result in an IOException being thrown.\n     *\n     * @return a list that contains all microphones' characteristics\n     * @throws IOException if an error occurs.\n     ",
    "links" : [ "android.media.MicrophoneInfo" ]
  }, {
    "name" : "public List<BluetoothCodecConfig> getHwOffloadFormatsSupportedForA2dp()",
    "returnType" : "List<BluetoothCodecConfig>",
    "comment" : "\n     * Returns a list of audio formats that corresponds to encoding formats\n     * supported on offload path for A2DP playback.\n     *\n     * @return a list of {@link BluetoothCodecConfig} objects containing encoding formats\n     * supported for offload A2DP playback\n     * @hide\n     ",
    "links" : [ "android.bluetooth.BluetoothCodecConfig" ]
  }, {
    "name" : "private List<BluetoothLeAudioCodecConfig> getHwOffloadFormatsSupportedForLeAudio(@AudioSystem.BtOffloadDeviceType int deviceType)",
    "returnType" : "List<BluetoothLeAudioCodecConfig>",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public List<BluetoothLeAudioCodecConfig> getHwOffloadFormatsSupportedForLeAudio()",
    "returnType" : "List<BluetoothLeAudioCodecConfig>",
    "comment" : "\n     * Returns a list of audio formats that corresponds to encoding formats\n     * supported on offload path for Le audio playback.\n     *\n     * @return a list of {@link BluetoothLeAudioCodecConfig} objects containing encoding formats\n     * supported for offload Le Audio playback\n     * @hide\n     ",
    "links" : [ "android.bluetooth.BluetoothLeAudioCodecConfig" ]
  }, {
    "name" : "public List<BluetoothLeAudioCodecConfig> getHwOffloadFormatsSupportedForLeBroadcast()",
    "returnType" : "List<BluetoothLeAudioCodecConfig>",
    "comment" : "\n     * Returns a list of audio formats that corresponds to encoding formats\n     * supported on offload path for Le Broadcast playback.\n     *\n     * @return a list of {@link BluetoothLeAudioCodecConfig} objects containing encoding formats\n     * supported for offload Le Broadcast playback\n     * @hide\n     ",
    "links" : [ "android.bluetooth.BluetoothLeAudioCodecConfig" ]
  }, {
    "name" : "private void broadcastDeviceListChange_sync(Handler handler)",
    "returnType" : "void",
    "comment" : "\n     * Internal method to compute and generate add/remove messages and then send to any\n     * registered callbacks. Must be called synchronized on mDeviceCallbacks.\n     ",
    "links" : [ ]
  }, {
    "name" : "public void setAudioServerStateCallback(@NonNull Executor executor, @NonNull AudioServerStateCallback stateCallback)",
    "returnType" : "void",
    "comment" : "\n     * @hide\n     * Registers a callback for notification of audio server state changes.\n     * @param executor {@link Executor} to handle the callbacks\n     * @param stateCallback the callback to receive the audio server state changes\n     *        To remove the callabck, pass a null reference for both executor and stateCallback.\n     ",
    "links" : [ "android.annotation.CallbackExecutor" ]
  }, {
    "name" : "public void clearAudioServerStateCallback()",
    "returnType" : "void",
    "comment" : "\n     * @hide\n     * Unregisters the callback for notification of audio server state changes.\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean isAudioServerRunning()",
    "returnType" : "boolean",
    "comment" : "\n     * @hide\n     * Checks if native audioservice is running or not.\n     * @return true if native audioservice runs, false otherwise.\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean setEncodedSurroundMode(@EncodedSurroundOutputMode int mode)",
    "returnType" : "boolean",
    "comment" : "\n     * Sets the surround sound mode.\n     *\n     * @return true if successful, otherwise false\n     ",
    "links" : [ ]
  }, {
    "name" : "public int getEncodedSurroundMode()",
    "returnType" : "int",
    "comment" : "\n     * Gets the surround sound mode.\n     *\n     * @return true if successful, otherwise false\n     ",
    "links" : [ ]
  }, {
    "name" : "public Map<Integer, Boolean> getSurroundFormats()",
    "returnType" : "Map<Integer, Boolean>",
    "comment" : "\n     * @hide\n     * Returns all surround formats.\n     * @return a map where the key is a surround format and\n     * the value indicates the surround format is enabled or not\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean setSurroundFormatEnabled(@AudioFormat.SurroundSoundEncoding int audioFormat, boolean enabled)",
    "returnType" : "boolean",
    "comment" : "\n     * Sets and persists a certain surround format as enabled or not.\n     * <p>\n     * This API is called by TvSettings surround sound menu when user enables or disables a\n     * surround sound format. This setting is persisted as global user setting.\n     * Applications should revert their changes to surround sound settings unless they intend to\n     * modify the global user settings across all apps. The framework does not auto-revert an\n     * application's settings after a lifecycle event. Audio focus is not required to apply these\n     * settings.\n     *\n     * @param enabled the required surround format state, true for enabled, false for disabled\n     * @return true if successful, otherwise false\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean isSurroundFormatEnabled(@AudioFormat.SurroundSoundEncoding int audioFormat)",
    "returnType" : "boolean",
    "comment" : "\n     * Gets whether a certain surround format is enabled or not.\n     * @param audioFormat a surround format\n     *\n     * @return whether the required surround format is enabled\n     ",
    "links" : [ ]
  }, {
    "name" : "public List<Integer> getReportedSurroundFormats()",
    "returnType" : "List<Integer>",
    "comment" : "\n     * @hide\n     * Returns all surround formats that are reported by the connected HDMI device.\n     * The return values are not affected by calling setSurroundFormatEnabled.\n     *\n     * @return a list of surround formats\n     ",
    "links" : [ ]
  }, {
    "name" : "public static boolean isHapticPlaybackSupported()",
    "returnType" : "boolean",
    "comment" : "\n     * Return if audio haptic coupled playback is supported or not.\n     *\n     * @return whether audio haptic playback supported.\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean isUltrasoundSupported()",
    "returnType" : "boolean",
    "comment" : "\n     * @hide\n     * Indicates whether a platform supports the Ultrasound feature which covers the playback\n     * and recording of 20kHz~ sounds. If platform supports Ultrasound, then the\n     * usage will be\n     * To start the Ultrasound playback:\n     *     - Create an AudioTrack with {@link AudioAttributes.CONTENT_TYPE_ULTRASOUND}.\n     * To start the Ultrasound capture:\n     *     - Create an AudioRecord with {@link MediaRecorder.AudioSource.ULTRASOUND}.\n     *\n     * @return whether the ultrasound feature is supported, true when platform supports both\n     * Ultrasound playback and capture, false otherwise.\n     ",
    "links" : [ "MediaRecorder.AudioSource.ULTRASOUND", "AudioAttributes.CONTENT_TYPE_ULTRASOUND" ]
  }, {
    "name" : "public boolean isHotwordStreamSupported(boolean lookbackAudio)",
    "returnType" : "boolean",
    "comment" : "\n     * @hide\n     * Indicates whether the platform supports capturing content from the hotword recognition\n     * pipeline. To capture content of this type, create an AudioRecord with\n     * {@link AudioRecord.Builder.setRequestHotwordStream(boolean, boolean)}.\n     * @param lookbackAudio Query if the hotword stream additionally supports providing buffered\n     * audio prior to stream open.\n     * @return True if the platform supports capturing hotword content, and if lookbackAudio\n     * is true, if it additionally supports capturing buffered hotword content prior to stream\n     * open. False otherwise.\n     ",
    "links" : [ "AudioRecord.Builder.setRequestHotwordStream(boolean" ]
  }, {
    "name" : "public static List<AudioProductStrategy> getAudioProductStrategies()",
    "returnType" : "List<AudioProductStrategy>",
    "comment" : "\n     * @hide\n     * Introspection API to retrieve audio product strategies.\n     * When implementing {Car|Oem}AudioManager, use this method  to retrieve the collection of\n     * audio product strategies, which is indexed by a weakly typed index in order to be extended\n     * by OEM without any needs of AOSP patches.\n     * The {Car|Oem}AudioManager can expose API to build {@link AudioAttributes} for a given product\n     * strategy refered either by its index or human readable string. It will allow clients\n     * application to start streaming data using these {@link AudioAttributes} on the selected\n     * device by Audio Policy Engine.\n     * @return a (possibly zero-length) array of\n     *         {@see android.media.audiopolicy.AudioProductStrategy} objects.\n     ",
    "links" : [ "android.media.AudioAttributes" ]
  }, {
    "name" : "public static List<AudioVolumeGroup> getAudioVolumeGroups()",
    "returnType" : "List<AudioVolumeGroup>",
    "comment" : "\n     * @hide\n     * Introspection API to retrieve audio volume groups.\n     * When implementing {Car|Oem}AudioManager, use this method  to retrieve the collection of\n     * audio volume groups.\n     * @return a (possibly zero-length) List of\n     *         {@see android.media.audiopolicy.AudioVolumeGroup} objects.\n     ",
    "links" : [ ]
  }, {
    "name" : "public void registerVolumeGroupCallback(@NonNull Executor executor, @NonNull VolumeGroupCallback callback)",
    "returnType" : "void",
    "comment" : "\n    * @hide\n    * Register an audio volume group change listener.\n    * @param callback the {@link VolumeGroupCallback} to register\n    ",
    "links" : [ "VolumeGroupCallback" ]
  }, {
    "name" : "public void unregisterVolumeGroupCallback(@NonNull VolumeGroupCallback callback)",
    "returnType" : "void",
    "comment" : "\n    * @hide\n    * Unregister an audio volume group change listener.\n    * @param callback the {@link VolumeGroupCallback} to unregister\n    ",
    "links" : [ "VolumeGroupCallback" ]
  }, {
    "name" : "public static boolean hasHapticChannelsImpl(@NonNull Context context, @NonNull Uri uri)",
    "returnType" : "boolean",
    "comment" : "\n     * Return if an asset contains haptic channels or not.\n     *\n     * @param context the {@link Context} to resolve the uri.\n     * @param uri the {@link Uri} of the asset.\n     * @return true if the assert contains haptic channels.\n     * @hide\n     ",
    "links" : [ "android.content.Context", "android.net.Uri" ]
  }, {
    "name" : "public static boolean hasHapticChannels(@Nullable Context context, @NonNull Uri uri)",
    "returnType" : "boolean",
    "comment" : "\n     * Return if an asset contains haptic channels or not.\n     *\n     * @param context the {@link Context} to resolve the uri.\n     * @param uri the {@link Uri} of the asset.\n     * @return true if the assert contains haptic channels.\n     * @hide\n     ",
    "links" : [ "android.content.Context", "android.net.Uri" ]
  }, {
    "name" : "public static void setRttEnabled(boolean rttEnabled)",
    "returnType" : "void",
    "comment" : "\n     * Set whether or not there is an active RTT call.\n     * This method should be called by Telecom service.\n     * @hide\n     * TODO: make this a @SystemApi\n     ",
    "links" : [ ]
  }, {
    "name" : "public void adjustSuggestedStreamVolumeForUid(int suggestedStreamType, int direction, @SystemVolumeFlags int flags, @NonNull String packageName, int uid, int pid, int targetSdkVersion)",
    "returnType" : "void",
    "comment" : "\n     * Adjusts the volume of the most relevant stream, or the given fallback\n     * stream.\n     * <p>\n     * This method should only be used by applications that replace the\n     * platform-wide management of audio settings or the main telephony\n     * application.\n     * <p>\n     * This method has no effect if the device implements a fixed volume policy\n     * as indicated by {@link #isVolumeFixed()}.\n     * <p>This API checks if the caller has the necessary permissions based on the provided\n     * component name, uid, and pid values.\n     * See {@link #adjustSuggestedStreamVolume(int, int, int)}.\n     *\n     * @param suggestedStreamType The stream type that will be used if there\n     *         isn't a relevant stream. {@link #USE_DEFAULT_STREAM_TYPE} is\n     *         valid here.\n     * @param direction The direction to adjust the volume. One of\n     *         {@link #ADJUST_LOWER}, {@link #ADJUST_RAISE},\n     *         {@link #ADJUST_SAME}, {@link #ADJUST_MUTE},\n     *         {@link #ADJUST_UNMUTE}, or {@link #ADJUST_TOGGLE_MUTE}.\n     * @param flags\n     * @param packageName the package name of client application\n     * @param uid the uid of client application\n     * @param pid the pid of client application\n     * @param targetSdkVersion the target sdk version of client application\n     * @see #adjustVolume(int, int)\n     * @see #adjustStreamVolume(int, int, int)\n     * @see #setStreamVolume(int, int, int)\n     * @see #isVolumeFixed()\n     *\n     * @hide\n     ",
    "links" : [ "#ADJUST_LOWER", "#ADJUST_MUTE", "#ADJUST_TOGGLE_MUTE", "#isVolumeFixed()", "#ADJUST_SAME", "#USE_DEFAULT_STREAM_TYPE", "#adjustSuggestedStreamVolume(int", "#ADJUST_RAISE", "#ADJUST_UNMUTE" ]
  }, {
    "name" : "public void adjustStreamVolumeForUid(int streamType, int direction, @SystemVolumeFlags int flags, @NonNull String packageName, int uid, int pid, int targetSdkVersion)",
    "returnType" : "void",
    "comment" : "\n     * Adjusts the volume of a particular stream by one step in a direction.\n     * <p>\n     * This method should only be used by applications that replace the platform-wide\n     * management of audio settings or the main telephony application.\n     * <p>This method has no effect if the device implements a fixed volume policy\n     * as indicated by {@link #isVolumeFixed()}.\n     * <p>From N onward, ringer mode adjustments that would toggle Do Not Disturb are not allowed\n     * unless the app has been granted Do Not Disturb Access.\n     * See {@link NotificationManager#isNotificationPolicyAccessGranted()}.\n     * <p>This API checks if the caller has the necessary permissions based on the provided\n     * component name, uid, and pid values.\n     * See {@link #adjustStreamVolume(int, int, int)}.\n     *\n     * @param streamType The stream type to adjust. One of {@link #STREAM_VOICE_CALL},\n     *         {@link #STREAM_SYSTEM}, {@link #STREAM_RING}, {@link #STREAM_MUSIC},\n     *         {@link #STREAM_ALARM} or {@link #STREAM_ACCESSIBILITY}.\n     * @param direction The direction to adjust the volume. One of\n     *         {@link #ADJUST_LOWER}, {@link #ADJUST_RAISE}, or\n     *         {@link #ADJUST_SAME}.\n     * @param flags\n     * @param packageName the package name of client application\n     * @param uid the uid of client application\n     * @param pid the pid of client application\n     * @param targetSdkVersion the target sdk version of client application\n     * @see #adjustVolume(int, int)\n     * @see #setStreamVolume(int, int, int)\n     * @throws SecurityException if the adjustment triggers a Do Not Disturb change\n     *         and the caller is not granted notification policy access.\n     *\n     * @hide\n     ",
    "links" : [ "#STREAM_ALARM", "#ADJUST_LOWER", "#isVolumeFixed()", "#STREAM_SYSTEM", "#ADJUST_SAME", "#adjustStreamVolume(int", "android.app.NotificationManager#isNotificationPolicyAccessGranted()", "#STREAM_VOICE_CALL", "#STREAM_MUSIC", "#STREAM_RING", "#ADJUST_RAISE", "#STREAM_ACCESSIBILITY" ]
  }, {
    "name" : "public void setStreamVolumeForUid(int streamType, int index, @SystemVolumeFlags int flags, @NonNull String packageName, int uid, int pid, int targetSdkVersion)",
    "returnType" : "void",
    "comment" : "\n     * Sets the volume index for a particular stream.\n     * <p>This method has no effect if the device implements a fixed volume policy\n     * as indicated by {@link #isVolumeFixed()}.\n     * <p>From N onward, volume adjustments that would toggle Do Not Disturb are not allowed unless\n     * the app has been granted Do Not Disturb Access.\n     * See {@link NotificationManager#isNotificationPolicyAccessGranted()}.\n     * <p>This API checks if the caller has the necessary permissions based on the provided\n     * component name, uid, and pid values.\n     * See {@link #setStreamVolume(int, int, int)}.\n     *\n     * @param streamType The stream whose volume index should be set.\n     * @param index The volume index to set. See\n     *         {@link #getStreamMaxVolume(int)} for the largest valid value.\n     * @param flags\n     * @param packageName the package name of client application\n     * @param uid the uid of client application\n     * @param pid the pid of client application\n     * @param targetSdkVersion the target sdk version of client application\n     * @see #getStreamMaxVolume(int)\n     * @see #getStreamVolume(int)\n     * @see #isVolumeFixed()\n     * @throws SecurityException if the volume change triggers a Do Not Disturb change\n     *         and the caller is not granted notification policy access.\n     *\n     * @hide\n     ",
    "links" : [ "#setStreamVolume(int", "#isVolumeFixed()", "#getStreamMaxVolume(int)", "android.app.NotificationManager#isNotificationPolicyAccessGranted()" ]
  }, {
    "name" : "public void setMultiAudioFocusEnabled(boolean enabled)",
    "returnType" : "void",
    "comment" : " @hide\n     * TODO: make this a @SystemApi ",
    "links" : [ ]
  }, {
    "name" : "public int getAudioHwSyncForSession(int sessionId)",
    "returnType" : "int",
    "comment" : "\n     * Retrieves the Hardware A/V synchronization ID corresponding to the given audio session ID.\n     * For more details on Hardware A/V synchronization please refer to\n     *  <a href=\"https://source.android.com/devices/tv/multimedia-tunneling/\">\n     * media tunneling documentation</a>.\n     * @param sessionId the audio session ID for which the HW A/V sync ID is retrieved.\n     * @return the HW A/V sync ID for this audio session (an integer different from 0).\n     * @throws UnsupportedOperationException if HW A/V synchronization is not supported.\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean setCommunicationDevice(@NonNull AudioDeviceInfo device)",
    "returnType" : "boolean",
    "comment" : "\n     * Selects the audio device that should be used for communication use cases, for instance voice\n     * or video calls. This method can be used by voice or video chat applications to select a\n     * different audio device than the one selected by default by the platform.\n     * <p>The device selection is expressed as an {@link AudioDeviceInfo} among devices returned by\n     * {@link #getAvailableCommunicationDevices()}. Note that only devices in a sink role\n     * (AKA output devices, see {@link AudioDeviceInfo#isSink()}) can be specified. The matching\n     * source device is selected automatically by the platform.\n     * <p>The selection is active as long as the requesting application process lives, until\n     * {@link #clearCommunicationDevice} is called or until the device is disconnected.\n     * It is therefore important for applications to clear the request when a call ends or the\n     * the requesting activity or service is stopped or destroyed.\n     * <p>In case of simultaneous requests by multiple applications the priority is given to the\n     * application currently controlling the audio mode (see {@link #setMode(int)}). This is the\n     * latest application having selected mode {@link #MODE_IN_COMMUNICATION} or mode\n     * {@link #MODE_IN_CALL}. Note that <code>MODE_IN_CALL</code> can only be selected by the main\n     * telephony application with permission\n     * {@link Manifest.permission#MODIFY_PHONE_STATE}.\n     * <p> If the requested devices is not currently available, the request will be rejected and\n     * the method will return false.\n     * <p>This API replaces the following deprecated APIs:\n     * <ul>\n     *   <li> {@link #startBluetoothSco()}\n     *   <li> {@link #stopBluetoothSco()}\n     *   <li> {@link #setSpeakerphoneOn(boolean)}\n     * </ul>\n     * <h4>Example</h4>\n     * <p>The example below shows how to enable and disable speakerphone mode.\n     * <pre class=\"prettyprint\">\n     * // Get an AudioManager instance\n     * AudioManager audioManager = Context.getSystemService(AudioManager.class);\n     * AudioDeviceInfo speakerDevice = null;\n     * List<AudioDeviceInfo> devices = audioManager.getAvailableCommunicationDevices();\n     * for (AudioDeviceInfo device : devices) {\n     *     if (device.getType() == AudioDeviceInfo.TYPE_BUILTIN_SPEAKER) {\n     *         speakerDevice = device;\n     *         break;\n     *     }\n     * }\n     * if (speakerDevice != null) {\n     *     // Turn speakerphone ON.\n     *     boolean result = audioManager.setCommunicationDevice(speakerDevice);\n     *     if (!result) {\n     *         // Handle error.\n     *     }\n     *     // Turn speakerphone OFF.\n     *     audioManager.clearCommunicationDevice();\n     * }\n     * </pre>\n     * @param device the requested audio device.\n     * @return <code>true</code> if the request was accepted, <code>false</code> otherwise.\n     * @throws IllegalArgumentException If an invalid device is specified.\n     ",
    "links" : [ "android.media.AudioDeviceInfo#isSink()", "#startBluetoothSco()", "#clearCommunicationDevice", "#MODE_IN_CALL", "#getAvailableCommunicationDevices()", "Manifest.permission#MODIFY_PHONE_STATE", "#MODE_IN_COMMUNICATION", "#setSpeakerphoneOn(boolean)", "android.media.AudioDeviceInfo", "#stopBluetoothSco()", "#setMode(int)" ]
  }, {
    "name" : "public void clearCommunicationDevice()",
    "returnType" : "void",
    "comment" : "\n     * Cancels previous communication device selection made with\n     * {@link #setCommunicationDevice(AudioDeviceInfo)}.\n     ",
    "links" : [ "#setCommunicationDevice(AudioDeviceInfo)" ]
  }, {
    "name" : "public AudioDeviceInfo getCommunicationDevice()",
    "returnType" : "AudioDeviceInfo",
    "comment" : "\n     * Returns currently selected audio device for communication.\n     * <p>This API replaces the following deprecated APIs:\n     * <ul>\n     *   <li> {@link #isBluetoothScoOn()}\n     *   <li> {@link #isSpeakerphoneOn()}\n     * </ul>\n     * @return an {@link AudioDeviceInfo} indicating which audio device is\n     * currently selected for communication use cases. Can be null on platforms\n     * not supporting {@link android.content.pm.PackageManager#FEATURE_TELEPHONY}.\n     * is used.\n     ",
    "links" : [ "#isBluetoothScoOn()", "#isSpeakerphoneOn()", "android.media.AudioDeviceInfo", "android.content.pm.PackageManager#FEATURE_TELEPHONY" ]
  }, {
    "name" : "public List<AudioDeviceInfo> getAvailableCommunicationDevices()",
    "returnType" : "List<AudioDeviceInfo>",
    "comment" : "\n     * Returns a list of audio devices that can be selected for communication use cases via\n     * {@link #setCommunicationDevice(AudioDeviceInfo)}.\n     * @return a list of {@link AudioDeviceInfo} suitable for use with setCommunicationDevice().\n     ",
    "links" : [ "#setCommunicationDevice(AudioDeviceInfo)", "android.media.AudioDeviceInfo" ]
  }, {
    "name" : "public List<AudioProfile> getDirectProfilesForAttributes(@NonNull AudioAttributes attributes)",
    "returnType" : "List<AudioProfile>",
    "comment" : "\n     * Returns a list of direct {@link AudioProfile} that are supported for the specified\n     * {@link AudioAttributes}. This can be empty in case of an error or if no direct playback\n     * is possible.\n     *\n     * <p>Direct playback means that the audio stream is not resampled or downmixed\n     * by the framework. Checking for direct support can help the app select the representation\n     * of audio content that most closely matches the capabilities of the device and peripherals\n     * (e.g. A/V receiver) connected to it. Note that the provided stream can still be re-encoded\n     * or mixed with other streams, if needed.\n     * <p>When using this information to inform your application which audio format to play,\n     * query again whenever audio output devices change (see {@link AudioDeviceCallback}).\n     * @param attributes a non-null {@link AudioAttributes} instance.\n     * @return a list of {@link AudioProfile}\n     ",
    "links" : [ "android.media.AudioDeviceCallback", "android.media.AudioProfile", "android.media.AudioAttributes" ]
  }, {
    "name" : "public static AudioDeviceInfo getDeviceInfoFromType(@AudioDeviceInfo.AudioDeviceTypeOut int deviceType)",
    "returnType" : "AudioDeviceInfo",
    "comment" : "\n     * @hide\n     * Returns an {@link AudioDeviceInfo} corresponding to a connected device of the type provided.\n     * The type must be a valid output type defined in <code>AudioDeviceInfo</code> class,\n     * for instance {@link AudioDeviceInfo#TYPE_BUILTIN_SPEAKER}.\n     * The method will return null if no device of the provided type is connected.\n     * If more than one device of the provided type is connected, an object corresponding to the\n     * first device encountered in the enumeration list will be returned.\n     * @param deviceType The device device for which an <code>AudioDeviceInfo</code>\n     *                   object is queried.\n     * @return An AudioDeviceInfo object or null if no device with the requested type is connected.\n     * @throws IllegalArgumentException If an invalid device type is specified.\n     ",
    "links" : [ "android.media.AudioDeviceInfo", "android.media.AudioDeviceInfo#TYPE_BUILTIN_SPEAKER" ]
  }, {
    "name" : "public static AudioDeviceInfo getDeviceInfoFromTypeAndAddress(@AudioDeviceInfo.AudioDeviceTypeOut int type, @Nullable String address)",
    "returnType" : "AudioDeviceInfo",
    "comment" : "\n     * @hide\n     * Returns an {@link AudioDeviceInfo} corresponding to a connected device of the type and\n     * address provided.\n     * The type must be a valid output type defined in <code>AudioDeviceInfo</code> class,\n     * for instance {@link AudioDeviceInfo#TYPE_BUILTIN_SPEAKER}.\n     * If a null address is provided, the matching will happen on the type only.\n     * The method will return null if no device of the provided type and address is connected.\n     * If more than one device of the provided type is connected, an object corresponding to the\n     * first device encountered in the enumeration list will be returned.\n     * @param type The device device for which an <code>AudioDeviceInfo</code>\n     *             object is queried.\n     * @param address The device address for which an <code>AudioDeviceInfo</code>\n     *                object is queried or null if requesting match on type only.\n     * @return An AudioDeviceInfo object or null if no matching device is connected.\n     * @throws IllegalArgumentException If an invalid device type is specified.\n     ",
    "links" : [ "android.media.AudioDeviceInfo", "android.media.AudioDeviceInfo#TYPE_BUILTIN_SPEAKER" ]
  }, {
    "name" : "public void addOnCommunicationDeviceChangedListener(@NonNull @CallbackExecutor Executor executor, @NonNull OnCommunicationDeviceChangedListener listener)",
    "returnType" : "void",
    "comment" : "\n     * Adds a listener for being notified of changes to the communication audio device.\n     * See {@link #setCommunicationDevice(AudioDeviceInfo)}.\n     * @param executor\n     * @param listener\n     ",
    "links" : [ "#setCommunicationDevice(AudioDeviceInfo)" ]
  }, {
    "name" : "public void removeOnCommunicationDeviceChangedListener(@NonNull OnCommunicationDeviceChangedListener listener)",
    "returnType" : "void",
    "comment" : "\n     * Removes a previously added listener of changes to the communication audio device.\n     * See {@link #setCommunicationDevice(AudioDeviceInfo)}.\n     * @param listener\n     ",
    "links" : [ "#setCommunicationDevice(AudioDeviceInfo)" ]
  }, {
    "name" : "public boolean isPstnCallAudioInterceptable()",
    "returnType" : "boolean",
    "comment" : "\n     * @hide\n     * Indicates if the platform allows accessing the uplink and downlink audio of an ongoing\n     * PSTN call.\n     * When true, {@link getCallUplinkInjectionAudioTrack(AudioFormat)} can be used to obtain\n     * an AudioTrack for call uplink audio injection and\n     * {@link getCallDownlinkExtractionAudioRecord(AudioFormat)} can be used to obtain\n     * an AudioRecord for call downlink audio extraction.\n     * @return true if PSTN call audio is accessible, false otherwise.\n     ",
    "links" : [ "getCallUplinkInjectionAudioTrack(AudioFormat)", "getCallDownlinkExtractionAudioRecord(AudioFormat)" ]
  }, {
    "name" : "private int getCallRedirectMode()",
    "returnType" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private void checkCallRedirectionFormat(AudioFormat format, boolean isOutput)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public AudioTrack getCallUplinkInjectionAudioTrack(@NonNull AudioFormat format)",
    "returnType" : "AudioTrack",
    "comment" : "\n     * @hide\n     * Returns an AudioTrack that can be used to inject audio to an active call uplink.\n     * This can be used for functions like call screening or call audio redirection and is reserved\n     * to system apps with privileged permission.\n     * @param format the desired audio format for audio playback.\n     * p>Formats accepted are:\n     * <ul>\n     *   <li><em>Sampling rate</em> - 8kHz to 48kHz. </li>\n     *   <li><em>Channel mask</em> - Mono or Stereo </li>\n     *   <li><em>Sample format</em> - PCM 16 bit or FLOAT 32 bit </li>\n     * </ul>\n     *\n     * @return The AudioTrack used for audio injection\n     * @throws NullPointerException if AudioFormat argument is null.\n     * @throws UnsupportedOperationException if on unsupported AudioFormat is specified.\n     * @throws IllegalArgumentException if an invalid AudioFormat is specified.\n     * @throws SecurityException if permission CALL_AUDIO_INTERCEPTION  is missing .\n     * @throws IllegalStateException if current audio mode is not MODE_IN_CALL,\n     *         MODE_IN_COMMUNICATION, MODE_CALL_SCREENING, MODE_CALL_REDIRECT\n     *         or MODE_COMMUNICATION_REDIRECT.\n     ",
    "links" : [ ]
  }, {
    "name" : "public AudioRecord getCallDownlinkExtractionAudioRecord(@NonNull AudioFormat format)",
    "returnType" : "AudioRecord",
    "comment" : "\n     * @hide\n     * Returns an AudioRecord that can be used to extract audio from an active call downlink.\n     * This can be used for functions like call screening or call audio redirection and is reserved\n     * to system apps with privileged permission.\n     * @param format the desired audio format for audio capture.\n     *<p>Formats accepted are:\n     * <ul>\n     *   <li><em>Sampling rate</em> - 8kHz to 48kHz. </li>\n     *   <li><em>Channel mask</em> - Mono or Stereo </li>\n     *   <li><em>Sample format</em> - PCM 16 bit or FLOAT 32 bit </li>\n     * </ul>\n     *\n     * @return The AudioRecord used for audio extraction\n     * @throws UnsupportedOperationException if on unsupported AudioFormat is specified.\n     * @throws IllegalArgumentException if an invalid AudioFormat is specified.\n     * @throws NullPointerException if AudioFormat argument is null.\n     * @throws SecurityException if permission CALL_AUDIO_INTERCEPTION  is missing .\n     * @throws IllegalStateException if current audio mode is not MODE_IN_CALL,\n     *         MODE_IN_COMMUNICATION, MODE_CALL_SCREENING, MODE_CALL_REDIRECT\n     *         or MODE_COMMUNICATION_REDIRECT.\n     ",
    "links" : [ ]
  }, {
    "name" : "public void muteAwaitConnection(@NonNull int[] usagesToMute, @NonNull AudioDeviceAttributes device, long timeout, @NonNull TimeUnit timeUnit) throws IllegalStateException",
    "returnType" : "void",
    "comment" : "\n     * @hide\n     * Mute a set of playback use cases until a given audio device is connected.\n     * Automatically unmute upon connection of the device, or after the given timeout, whichever\n     * happens first.\n     * @param usagesToMute non-empty array of {@link AudioAttributes} usages (for example\n     *                     {@link AudioAttributes#USAGE_MEDIA}) to mute until the\n     *                     device connects\n     * @param device the audio device expected to connect within the timeout duration\n     * @param timeout the maximum amount of time to wait for the device connection\n     * @param timeUnit the unit for the timeout\n     * @throws IllegalStateException when trying to issue the command while another is already in\n     *         progress and hasn't been cancelled by\n     *         {@link #cancelMuteAwaitConnection(AudioDeviceAttributes)}. See\n     *         {@link #getMutingExpectedDevice()} to check if a muting command is active.\n     * @see #registerMuteAwaitConnectionCallback(Executor, AudioManager.MuteAwaitConnectionCallback)\n     ",
    "links" : [ "#cancelMuteAwaitConnection(AudioDeviceAttributes)", "#getMutingExpectedDevice()", "android.media.AudioAttributes", "android.media.AudioAttributes#USAGE_MEDIA" ]
  }, {
    "name" : "public AudioDeviceAttributes getMutingExpectedDevice()",
    "returnType" : "AudioDeviceAttributes",
    "comment" : "\n     * @hide\n     * Query which audio device, if any, is causing some playback use cases to be muted until it\n     * connects.\n     * @return the audio device used in\n     *        {@link #muteAwaitConnection(int[], AudioDeviceAttributes, long, TimeUnit)}, or null\n     *        if there is no active muting command (either because the muting command was not issued\n     *        or because it timed out)\n     ",
    "links" : [ "#muteAwaitConnection(int" ]
  }, {
    "name" : "public void cancelMuteAwaitConnection(@NonNull AudioDeviceAttributes device) throws IllegalStateException",
    "returnType" : "void",
    "comment" : "\n     * @hide\n     * Cancel a {@link #muteAwaitConnection(int[], AudioDeviceAttributes, long, TimeUnit)}\n     * command.\n     * @param device the device whose connection was expected when the {@code muteAwaitConnection}\n     *               command was issued.\n     * @throws IllegalStateException when trying to issue the command for a device whose connection\n     *         is not anticipated by a previous call to\n     *         {@link #muteAwaitConnection(int[], AudioDeviceAttributes, long, TimeUnit)}\n     ",
    "links" : [ "#muteAwaitConnection(int" ]
  }, {
    "name" : "public void registerMuteAwaitConnectionCallback(@NonNull @CallbackExecutor Executor executor, @NonNull MuteAwaitConnectionCallback callback)",
    "returnType" : "void",
    "comment" : "\n     * @hide\n     * Register a callback to receive updates on the playback muting conditional on a specific\n     * audio device connection.\n     * @param executor the {@link Executor} handling the callback\n     * @param callback the callback to register\n     ",
    "links" : [ "android.annotation.CallbackExecutor" ]
  }, {
    "name" : "public void unregisterMuteAwaitConnectionCallback(@NonNull MuteAwaitConnectionCallback callback)",
    "returnType" : "void",
    "comment" : "\n     * @hide\n     * Unregister a previously registered callback for playback muting conditional on device\n     * connection.\n     * @param callback the callback to unregister\n     ",
    "links" : [ ]
  }, {
    "name" : "public void addAssistantServicesUids(@NonNull int[] assistantUids)",
    "returnType" : "void",
    "comment" : "\n     * Add UIDs that can be considered as assistant.\n     *\n     * @param assistantUids UIDs of the services that can be considered as assistant.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public void removeAssistantServicesUids(@NonNull int[] assistantUids)",
    "returnType" : "void",
    "comment" : "\n     * Remove UIDs that can be considered as assistant.\n     *\n     * @param assistantUids UIDs of the services that should be remove.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public int[] getAssistantServicesUids()",
    "returnType" : "int[]",
    "comment" : "\n     * Get the assistants UIDs that been added with the\n     * {@link #addAssistantServicesUids(int[])} and not yet removed with\n     * {@link #removeAssistantServicesUids(int[])}\n     *\n     * <p> Note that during native audioserver crash and after boot up the list of assistant\n     * UIDs will be reset to an empty list (i.e. no UID will be considered as assistant)\n     * Just after user switch, the list of assistant will also reset to empty.\n     * In both cases,The component's UID of the assistiant role or assistant setting will be\n     * automitically added to the list by the audio service.\n     *\n     * @return array of assistants UIDs\n     *\n     * @hide\n     ",
    "links" : [ "#removeAssistantServicesUids(int", "#addAssistantServicesUids(int" ]
  }, {
    "name" : "public void setActiveAssistantServiceUids(@NonNull int[] assistantUids)",
    "returnType" : "void",
    "comment" : "\n     * Sets UIDs that can be considered as active assistant. Calling the API with a new array will\n     * overwrite previous UIDs. If the array of UIDs is empty then no UID will be considered active.\n     * In this manner calling the API with an empty array will remove all UIDs previously set.\n     *\n     * @param assistantUids UIDs of the services that can be considered active assistant. Can be\n     * an empty array, for this no UID will be considered active.\n     *\n     * <p> Note that during audio service crash reset and after boot up the list of active assistant\n     * UIDs will be reset to an empty list (i.e. no UID will be considered as an active assistant).\n     * Just after user switch the list of active assistant will also reset to empty.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public int[] getActiveAssistantServicesUids()",
    "returnType" : "int[]",
    "comment" : "\n     * Get active assistant UIDs last set with the\n     * {@link #setActiveAssistantServiceUids(int[])}\n     *\n     * @return array of active assistants UIDs\n     *\n     * @hide\n     ",
    "links" : [ "#setActiveAssistantServiceUids(int" ]
  }, {
    "name" : "public static AudioHalVersionInfo getHalVersion()",
    "returnType" : "AudioHalVersionInfo",
    "comment" : "\n     * Returns an {@link AudioHalVersionInfo} indicating the Audio Hal Version. If there is no audio\n     * HAL found, null will be returned.\n     *\n     * @return @see @link #AudioHalVersionInfo The version of Audio HAL.\n     * @hide\n     ",
    "links" : [ "android.media.AudioHalVersionInfo", "#AudioHalVersionInfo" ]
  }, {
    "name" : "public List<AudioMixerAttributes> getSupportedMixerAttributes(@NonNull AudioDeviceInfo device)",
    "returnType" : "List<AudioMixerAttributes>",
    "comment" : "\n     * Returns the {@link AudioMixerAttributes} that can be used to set as preferred mixer\n     * attributes via {@link #setPreferredMixerAttributes(\n     * AudioAttributes, AudioDeviceInfo, AudioMixerAttributes)}.\n     * <p>Note that only USB devices are guaranteed to expose configurable mixer attributes. An\n     * empty list may be returned for all other types of devices as they may not allow dynamic\n     * configuration.\n     *\n     * @param device the device to query\n     * @return a list of {@link AudioMixerAttributes} that can be used as preferred mixer attributes\n     *         for the given device.\n     * @see #setPreferredMixerAttributes(AudioAttributes, AudioDeviceInfo, AudioMixerAttributes)\n     ",
    "links" : [ "android.media.AudioMixerAttributes", "#setPreferredMixerAttributes(" ]
  }, {
    "name" : "public boolean setPreferredMixerAttributes(@NonNull AudioAttributes attributes, @NonNull AudioDeviceInfo device, @NonNull AudioMixerAttributes mixerAttributes)",
    "returnType" : "boolean",
    "comment" : "\n     * Configures the mixer attributes for a particular {@link AudioAttributes} over a given\n     * {@link AudioDeviceInfo}.\n     * <p>Call {@link #getSupportedMixerAttributes(AudioDeviceInfo)} to determine which mixer\n     * attributes can be used with the given device.\n     * <p>The ownership of preferred mixer attributes is recognized by uid. When a playback from the\n     * same uid is routed to the given audio device when calling this API, the output mixer/stream\n     * will be configured with the values previously set via this API.\n     * <p>Use {@link #clearPreferredMixerAttributes(AudioAttributes, AudioDeviceInfo)}\n     * to cancel setting mixer attributes for this {@link AudioAttributes}.\n     *\n     * @param attributes the {@link AudioAttributes} whose mixer attributes should be set.\n     *                   Currently, only {@link AudioAttributes#USAGE_MEDIA} is supported. When\n     *                   playing audio targeted at the given device, use the same attributes for\n     *                   playback.\n     * @param device the device to be routed. Currently, only USB device will be allowed.\n     * @param mixerAttributes the preferred mixer attributes. When playing audio targeted at the\n     *                        given device, use the same {@link AudioFormat} for both playback\n     *                        and the mixer attributes.\n     * @return true only if the preferred mixer attributes are set successfully.\n     * @see #getPreferredMixerAttributes(AudioAttributes, AudioDeviceInfo)\n     * @see #clearPreferredMixerAttributes(AudioAttributes, AudioDeviceInfo)\n     ",
    "links" : [ "#getSupportedMixerAttributes(AudioDeviceInfo)", "android.media.AudioAttributes", "#clearPreferredMixerAttributes(AudioAttributes", "android.media.AudioFormat", "android.media.AudioDeviceInfo", "android.media.AudioAttributes#USAGE_MEDIA" ]
  }, {
    "name" : "public AudioMixerAttributes getPreferredMixerAttributes(@NonNull AudioAttributes attributes, @NonNull AudioDeviceInfo device)",
    "returnType" : "AudioMixerAttributes",
    "comment" : "\n     * Returns current preferred mixer attributes that is set via\n     * {@link #setPreferredMixerAttributes(AudioAttributes, AudioDeviceInfo, AudioMixerAttributes)}\n     *\n     * @param attributes the {@link AudioAttributes} whose mixer attributes should be set.\n     * @param device the expected routing device\n     * @return the preferred mixer attributes, which will be null when no preferred mixer attributes\n     *         have been set, or when they have been cleared.\n     * @see #setPreferredMixerAttributes(AudioAttributes, AudioDeviceInfo, AudioMixerAttributes)\n     * @see #clearPreferredMixerAttributes(AudioAttributes, AudioDeviceInfo)\n     ",
    "links" : [ "#setPreferredMixerAttributes(AudioAttributes", "android.media.AudioAttributes" ]
  }, {
    "name" : "public boolean clearPreferredMixerAttributes(@NonNull AudioAttributes attributes, @NonNull AudioDeviceInfo device)",
    "returnType" : "boolean",
    "comment" : "\n     * Clears the current preferred mixer attributes that were previously set via\n     * {@link #setPreferredMixerAttributes(AudioAttributes, AudioDeviceInfo, AudioMixerAttributes)}\n     *\n     * @param attributes the {@link AudioAttributes} whose mixer attributes should be cleared.\n     * @param device the expected routing device\n     * @return true only if the preferred mixer attributes are removed successfully.\n     * @see #setPreferredMixerAttributes(AudioAttributes, AudioDeviceInfo, AudioMixerAttributes)\n     * @see #getPreferredMixerAttributes(AudioAttributes, AudioDeviceInfo)\n     ",
    "links" : [ "#setPreferredMixerAttributes(AudioAttributes", "android.media.AudioAttributes" ]
  }, {
    "name" : "public void addOnPreferredMixerAttributesChangedListener(@NonNull @CallbackExecutor Executor executor, @NonNull OnPreferredMixerAttributesChangedListener listener)",
    "returnType" : "void",
    "comment" : "\n     * Adds a listener for being notified of changes to the preferred mixer attributes.\n     * @param executor the executor to execute the callback\n     * @param listener the listener to be notified of changes in the preferred mixer attributes.\n     ",
    "links" : [ ]
  }, {
    "name" : "public void removeOnPreferredMixerAttributesChangedListener(@NonNull OnPreferredMixerAttributesChangedListener listener)",
    "returnType" : "void",
    "comment" : "\n     * Removes a previously added listener of changes to the preferred mixer attributes.\n     * @param listener the listener to be notified of changes in the preferred mixer attributes,\n     *                 which were added via {@link #addOnPreferredMixerAttributesChangedListener(\n     *                 Executor, OnPreferredMixerAttributesChangedListener)}.\n     ",
    "links" : [ "#addOnPreferredMixerAttributesChangedListener(" ]
  }, {
    "name" : "public boolean supportsBluetoothVariableLatency()",
    "returnType" : "boolean",
    "comment" : "\n     * Requests if the implementation supports controlling the latency modes\n     * over the Bluetooth A2DP or LE Audio links.\n     *\n     * @return true if supported, false otherwise\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public void setBluetoothVariableLatencyEnabled(boolean enabled)",
    "returnType" : "void",
    "comment" : "\n     * Enables or disables the variable Bluetooth latency control mechanism in the\n     * audio framework and the audio HAL. This does not apply to the latency mode control\n     * on the spatializer output as this is a built-in feature.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean isBluetoothVariableLatencyEnabled()",
    "returnType" : "boolean",
    "comment" : "\n     * Indicates if the variable Bluetooth latency control mechanism is enabled or disabled.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public void addOnStreamAliasingChangedListener(@NonNull @CallbackExecutor Executor executor, @NonNull Runnable onStreamAliasingChangedListener)",
    "returnType" : "void",
    "comment" : "\n     * @hide\n     * Adds a listener to be notified of changes to volume stream type aliasing.\n     * See {@link #getIndependentStreamTypes()} and {@link #getStreamTypeAlias(int)}\n     * @param executor the Executor running the listener\n     * @param onStreamAliasingChangedListener the listener to add for the aliasing changes\n     ",
    "links" : [ "#getStreamTypeAlias(int)", "#getIndependentStreamTypes()" ]
  }, {
    "name" : "public void removeOnStreamAliasingChangedListener(@NonNull Runnable onStreamAliasingChangedListener)",
    "returnType" : "void",
    "comment" : "\n     * @hide\n     * Removes a previously added listener for changes to stream aliasing.\n     * See {@link #getIndependentStreamTypes()} and {@link #getStreamTypeAlias(int)}\n     * @see #addOnStreamAliasingChangedListener(Executor, Runnable)\n     * @param onStreamAliasingChangedListener the previously added listener of aliasing changes\n     ",
    "links" : [ "#getStreamTypeAlias(int)", "#getIndependentStreamTypes()" ]
  }, {
    "name" : "public void setNotifAliasRingForTest(boolean isAliased)",
    "returnType" : "void",
    "comment" : "\n     * @hide\n     * Test method to temporarily override whether STREAM_NOTIFICATION is aliased to STREAM_RING,\n     * volumes will be updated in case of a change.\n     * @param isAliased if true, STREAM_NOTIFICATION is aliased to STREAM_RING\n     ",
    "links" : [ ]
  }, {
    "name" : "public List<Integer> getIndependentStreamTypes()",
    "returnType" : "List<Integer>",
    "comment" : "\n     * @hide\n     * Return the list of independent stream types for volume control.\n     * A stream type is considered independent when the volume changes of that type do not\n     * affect any other independent volume control stream type.\n     * An independent stream type is its own alias when using {@link #getStreamTypeAlias(int)}.\n     * @return list of independent stream types, where each value can be one of\n     *     {@link #STREAM_VOICE_CALL}, {@link #STREAM_SYSTEM}, {@link #STREAM_RING},\n     *     {@link #STREAM_MUSIC}, {@link #STREAM_ALARM}, {@link #STREAM_NOTIFICATION},\n     *     {@link #STREAM_DTMF} and {@link #STREAM_ACCESSIBILITY}.\n     ",
    "links" : [ "#STREAM_ALARM", "#getStreamTypeAlias(int)", "#STREAM_SYSTEM", "#STREAM_VOICE_CALL", "#STREAM_MUSIC", "#STREAM_RING", "#STREAM_NOTIFICATION", "#STREAM_DTMF", "#STREAM_ACCESSIBILITY" ]
  }, {
    "name" : "public int getStreamTypeAlias(@PublicStreamTypes int sourceStreamType)",
    "returnType" : "int",
    "comment" : "\n     * @hide\n     * Return the stream type that a given stream is aliased to.\n     * A stream alias means that any change to the source stream will also be applied to the alias,\n     * and vice-versa.\n     * If a stream is independent (i.e. part of the stream types returned by\n     * {@link #getIndependentStreamTypes()}), its alias is itself.\n     * @param sourceStreamType the stream type to query for the alias.\n     * @return the stream type the source type is aliased to.\n     ",
    "links" : [ "#getIndependentStreamTypes()" ]
  }, {
    "name" : "public boolean isVolumeControlUsingVolumeGroups()",
    "returnType" : "boolean",
    "comment" : "\n     * @hide\n     * Returns whether the system uses {@link AudioVolumeGroup} for volume control\n     * @return true when volume control is performed through volume groups, false if it uses\n     *     stream types.\n     ",
    "links" : [ "android.media.audiopolicy.AudioVolumeGroup" ]
  }, {
    "name" : "public boolean shouldNotificationSoundPlay(@NonNull final AudioAttributes aa)",
    "returnType" : "boolean",
    "comment" : "\n     * @hide\n     * Checks whether a notification sound should be played or not, as reported by the state\n     * of the audio framework. Querying whether playback should proceed is favored over\n     * playing and letting the sound be muted or not.\n     * @param aa the {@link AudioAttributes} of the notification about to maybe play\n     * @return true if the audio framework state is such that the notification should be played\n     *    because at time of checking, and the notification will be heard,\n     *    false otherwise\n     ",
    "links" : [ "android.media.AudioAttributes" ]
  }, {
    "name" : "private void initPlatform()",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private boolean applyAutoHardening()",
    "returnType" : "boolean",
    "comment" : "",
    "links" : [ ]
  } ],
  "methodNames" : [ "public static final int[] getPublicStreamTypes()", "public static final String adjustToString(int adj)", "public static String flagsToString(int flags)", "private Context getContext()", "private void setContext(Context context)", " static IAudioService getService()", "private VirtualDeviceManager getVirtualDeviceManager()", "public void dispatchMediaKeyEvent(KeyEvent keyEvent)", "public void preDispatchKeyEvent(KeyEvent event, int stream)", "public boolean isVolumeFixed()", "public void adjustStreamVolume(int streamType, int direction, @PublicVolumeFlags int flags)", "public void adjustVolume(int direction, @PublicVolumeFlags int flags)", "public void adjustSuggestedStreamVolume(int direction, int suggestedStreamType, @PublicVolumeFlags int flags)", "public void setMasterMute(boolean mute, int flags)", "public int getRingerMode()", "public boolean isRampingRingerEnabled()", "public void setRampingRingerEnabled(boolean enabled)", "public static boolean isValidRingerMode(int ringerMode)", "public int getStreamMaxVolume(int streamType)", "public int getStreamMinVolume(int streamType)", "public int getStreamMinVolumeInt(int streamType)", "public int getStreamVolume(int streamType)", "public float getStreamVolumeDb(@PublicStreamTypes int streamType, int index, @AudioDeviceInfo.AudioDeviceTypeOut int deviceType)", "public static boolean isPublicStreamType(int streamType)", "public int getLastAudibleStreamVolume(int streamType)", "public int getUiSoundsStreamType()", "public void setRingerMode(int ringerMode)", "public void setStreamVolume(int streamType, int index, @PublicVolumeFlags int flags)", "public void setVolumeIndexForAttributes(@NonNull AudioAttributes attr, int index, @SystemVolumeFlags int flags)", "public int getVolumeIndexForAttributes(@NonNull AudioAttributes attr)", "public int getMaxVolumeIndexForAttributes(@NonNull AudioAttributes attr)", "public int getMinVolumeIndexForAttributes(@NonNull AudioAttributes attr)", "public int getVolumeGroupIdForAttributes(@NonNull AudioAttributes attributes)", "public void setVolumeGroupVolumeIndex(int groupId, int index, @SystemVolumeFlags int flags)", "public int getVolumeGroupVolumeIndex(int groupId)", "public int getVolumeGroupMaxVolumeIndex(int groupId)", "public int getVolumeGroupMinVolumeIndex(int groupId)", "public void adjustVolumeGroupVolume(int groupId, int direction, @PublicVolumeFlags int flags)", "public int getLastAudibleVolumeForVolumeGroup(int groupId)", "public boolean isVolumeGroupMuted(int groupId)", "public void setSupportedSystemUsages(@NonNull @AttributeSystemUsage int[] systemUsages)", "public int[] getSupportedSystemUsages()", "public void setStreamSolo(int streamType, boolean state)", "public void setStreamMute(int streamType, boolean state)", "public boolean isStreamMute(int streamType)", "public boolean isMasterMute()", "public void forceVolumeControlStream(int streamType)", "public boolean shouldVibrate(int vibrateType)", "public int getVibrateSetting(int vibrateType)", "public void setVibrateSetting(int vibrateType, int vibrateSetting)", "public void setSpeakerphoneOn(boolean on)", "public boolean isSpeakerphoneOn()", "public void setAllowedCapturePolicy(@AudioAttributes.CapturePolicy int capturePolicy)", "public int getAllowedCapturePolicy()", "public boolean setPreferredDeviceForStrategy(@NonNull AudioProductStrategy strategy, @NonNull AudioDeviceAttributes device)", "public boolean removePreferredDeviceForStrategy(@NonNull AudioProductStrategy strategy)", "public AudioDeviceAttributes getPreferredDeviceForStrategy(@NonNull AudioProductStrategy strategy)", "public boolean setPreferredDevicesForStrategy(@NonNull AudioProductStrategy strategy, @NonNull List<AudioDeviceAttributes> devices)", "public List<AudioDeviceAttributes> getPreferredDevicesForStrategy(@NonNull AudioProductStrategy strategy)", "public boolean setDeviceAsNonDefaultForStrategy(@NonNull AudioProductStrategy strategy, @NonNull AudioDeviceAttributes device)", "public boolean removeDeviceAsNonDefaultForStrategy(@NonNull AudioProductStrategy strategy, @NonNull AudioDeviceAttributes device)", "public List<AudioDeviceAttributes> getNonDefaultDevicesForStrategy(@NonNull AudioProductStrategy strategy)", "public void addOnPreferredDeviceForStrategyChangedListener(@NonNull @CallbackExecutor Executor executor, @NonNull OnPreferredDeviceForStrategyChangedListener listener) throws SecurityException", "public void removeOnPreferredDeviceForStrategyChangedListener(@NonNull OnPreferredDeviceForStrategyChangedListener listener)", "public void addOnPreferredDevicesForStrategyChangedListener(@NonNull @CallbackExecutor Executor executor, @NonNull OnPreferredDevicesForStrategyChangedListener listener) throws SecurityException", "public void removeOnPreferredDevicesForStrategyChangedListener(@NonNull OnPreferredDevicesForStrategyChangedListener listener)", "public void addOnNonDefaultDevicesForStrategyChangedListener(@NonNull @CallbackExecutor Executor executor, @NonNull OnNonDefaultDevicesForStrategyChangedListener listener) throws SecurityException", "public void removeOnNonDefaultDevicesForStrategyChangedListener(@NonNull OnNonDefaultDevicesForStrategyChangedListener listener)", "public boolean setPreferredDeviceForCapturePreset(@MediaRecorder.SystemSource int capturePreset, @NonNull AudioDeviceAttributes device)", "public boolean clearPreferredDevicesForCapturePreset(@MediaRecorder.SystemSource int capturePreset)", "public List<AudioDeviceAttributes> getPreferredDevicesForCapturePreset(@MediaRecorder.SystemSource int capturePreset)", "private boolean setPreferredDevicesForCapturePreset(@MediaRecorder.SystemSource int capturePreset, @NonNull List<AudioDeviceAttributes> devices)", "public void addOnPreferredDevicesForCapturePresetChangedListener(@NonNull @CallbackExecutor Executor executor, @NonNull OnPreferredDevicesForCapturePresetChangedListener listener) throws SecurityException", "public void removeOnPreferredDevicesForCapturePresetChangedListener(@NonNull OnPreferredDevicesForCapturePresetChangedListener listener)", "private int addOnDevRoleForCapturePresetChangedListener(@NonNull @CallbackExecutor Executor executor, @NonNull T listener, int deviceRole)", "private int removeOnDevRoleForCapturePresetChangedListener(@NonNull T listener, int deviceRole)", "public static int getDirectPlaybackSupport(@NonNull AudioFormat format, @NonNull AudioAttributes attributes)", "public static boolean isOffloadedPlaybackSupported(@NonNull AudioFormat format, @NonNull AudioAttributes attributes)", "public static int getPlaybackOffloadSupport(@NonNull AudioFormat format, @NonNull AudioAttributes attributes)", "public Spatializer getSpatializer()", "public boolean isBluetoothScoAvailableOffCall()", "public void startBluetoothSco()", "public void startBluetoothScoVirtualCall()", "public void stopBluetoothSco()", "public void setBluetoothScoOn(boolean on)", "public boolean isBluetoothScoOn()", "public void setBluetoothA2dpOn(boolean on)", "public boolean isBluetoothA2dpOn()", "public void setWiredHeadsetOn(boolean on)", "public boolean isWiredHeadsetOn()", "public void setMicrophoneMute(boolean on)", "public void setMicrophoneMuteFromSwitch(boolean on)", "public boolean isMicrophoneMute()", "public void setMode(@AudioMode int mode)", "public int getMode()", "public void addOnModeChangedListener(@NonNull @CallbackExecutor Executor executor, @NonNull OnModeChangedListener listener)", "public void removeOnModeChangedListener(@NonNull OnModeChangedListener listener)", "public boolean isCallScreeningModeSupported()", "public void setRouting(int mode, int routes, int mask)", "public int getRouting(int mode)", "public boolean isMusicActive()", "public boolean isMusicActiveRemotely()", "public boolean isAudioFocusExclusive()", "public int generateAudioSessionId()", "public void setParameter(String key, String value)", "public void setParameters(String keyValuePairs)", "public void setHfpEnabled(boolean enable)", "public void setHfpVolume(int volume)", "public void setHfpSamplingRate(int rate)", "public void setBluetoothHeadsetProperties(@NonNull String name, boolean hasNrecEnabled, boolean hasWbsEnabled)", "public void setA2dpSuspended(boolean enable)", "public void setLeAudioSuspended(boolean enable)", "public String getParameters(String keys)", "public static int getNthNavigationRepeatSoundEffect(int n)", "public void setNavigationRepeatSoundEffectsEnabled(boolean enabled)", "public boolean areNavigationRepeatSoundEffectsEnabled()", "public void setHomeSoundEffectEnabled(boolean enabled)", "public boolean isHomeSoundEffectEnabled()", "public void playSoundEffect(@SystemSoundEffect int effectType)", "public void playSoundEffect(@SystemSoundEffect int effectType, int userId)", "public void playSoundEffect(@SystemSoundEffect int effectType, float volume)", "private boolean delegateSoundEffectToVdm(@SystemSoundEffect int effectType)", "private boolean hasCustomPolicyVirtualDeviceContext()", "public void loadSoundEffects()", "public void unloadSoundEffects()", "public static String audioFocusToString(int focus)", "private FocusRequestInfo findFocusRequestInfo(String id)", "private String getIdForAudioFocusListener(OnAudioFocusChangeListener l)", "public void registerAudioFocusRequest(@NonNull AudioFocusRequest afr)", "public void unregisterAudioFocusRequest(OnAudioFocusChangeListener l)", "public int requestAudioFocus(OnAudioFocusChangeListener l, int streamType, int durationHint)", "public int requestAudioFocus(@NonNull AudioFocusRequest focusRequest)", "public int abandonAudioFocusRequest(@NonNull AudioFocusRequest focusRequest)", "public int requestAudioFocus(OnAudioFocusChangeListener l, @NonNull AudioAttributes requestAttributes, int durationHint, int flags) throws IllegalArgumentException", "public int requestAudioFocus(OnAudioFocusChangeListener l, @NonNull AudioAttributes requestAttributes, int durationHint, int flags, AudioPolicy ap) throws IllegalArgumentException", "public int requestAudioFocusForTest(@NonNull AudioFocusRequest afr, @NonNull String clientFakeId, int clientFakeUid, int clientTargetSdk)", "public int abandonAudioFocusForTest(@NonNull AudioFocusRequest afr, @NonNull String clientFakeId)", "public long getFadeOutDurationOnFocusLossMillis(@NonNull AudioAttributes aa)", "public List<Integer> getFocusDuckedUidsForTest()", "public long getFocusFadeOutDurationForTest()", "public long getFocusUnmuteDelayAfterFadeOutForTest()", "public boolean enterAudioFocusFreezeForTest(@NonNull List<Integer> exemptedUids)", "public boolean exitAudioFocusFreezeForTest()", "public int requestAudioFocus(@NonNull AudioFocusRequest afr, @Nullable AudioPolicy ap)", "private BlockingFocusResultReceiver addClientIdToFocusReceiverLocked(String clientId)", "private int handleExternalAudioPolicyWaitIfNeeded(String clientId, BlockingFocusResultReceiver focusReceiver)", "public void requestAudioFocusForCall(int streamType, int durationHint)", "public int getFocusRampTimeMs(int focusGain, AudioAttributes attr)", "public void setFocusRequestResult(@NonNull AudioFocusInfo afi, @FocusRequestResult int requestResult, @NonNull AudioPolicy ap)", "public int dispatchAudioFocusChange(@NonNull AudioFocusInfo afi, int focusChange, @NonNull AudioPolicy ap)", "public int dispatchAudioFocusChangeWithFade(@NonNull AudioFocusInfo afi, int focusChange, @NonNull AudioPolicy ap, @NonNull List<AudioFocusInfo> otherActiveAfis, @Nullable FadeManagerConfiguration transientFadeMgrConfig)", "public void abandonAudioFocusForCall()", "public int abandonAudioFocus(OnAudioFocusChangeListener l)", "public int abandonAudioFocus(OnAudioFocusChangeListener l, AudioAttributes aa)", "public void registerMediaButtonEventReceiver(ComponentName eventReceiver)", "public void registerMediaButtonEventReceiver(PendingIntent eventReceiver)", "public void registerMediaButtonIntent(PendingIntent pi, ComponentName eventReceiver)", "public void unregisterMediaButtonEventReceiver(ComponentName eventReceiver)", "public void unregisterMediaButtonEventReceiver(PendingIntent eventReceiver)", "public void unregisterMediaButtonIntent(PendingIntent pi)", "public void registerRemoteControlClient(RemoteControlClient rcClient)", "public void unregisterRemoteControlClient(RemoteControlClient rcClient)", "public boolean registerRemoteController(RemoteController rctlr)", "public void unregisterRemoteController(RemoteController rctlr)", "public int registerAudioPolicy(@NonNull AudioPolicy policy)", " static int registerAudioPolicyStatic(@NonNull AudioPolicy policy)", "public void unregisterAudioPolicyAsync(@NonNull AudioPolicy policy)", " static void unregisterAudioPolicyAsyncStatic(@NonNull AudioPolicy policy)", "public void unregisterAudioPolicy(@NonNull AudioPolicy policy)", "public List<android.media.audiopolicy.AudioMix> getRegisteredPolicyMixes()", "public boolean hasRegisteredDynamicPolicy()", "public void registerAudioPlaybackCallback(@NonNull AudioPlaybackCallback cb, @Nullable Handler handler)", "public void unregisterAudioPlaybackCallback(@NonNull AudioPlaybackCallback cb)", "public List<AudioPlaybackConfiguration> getActivePlaybackConfigurations()", "private boolean hasPlaybackCallback_sync(@NonNull AudioPlaybackCallback cb)", "private boolean removePlaybackCallback_sync(@NonNull AudioPlaybackCallback cb)", "public void registerAudioRecordingCallback(@NonNull AudioRecordingCallback cb, @Nullable Handler handler)", "public void unregisterAudioRecordingCallback(@NonNull AudioRecordingCallback cb)", "public List<AudioRecordingConfiguration> getActiveRecordingConfigurations()", "private boolean hasRecordCallback_sync(@NonNull AudioRecordingCallback cb)", "private boolean removeRecordCallback_sync(@NonNull AudioRecordingCallback cb)", "public void reloadAudioSettings()", "public boolean isSilentMode()", "public static boolean isOutputDevice(int device)", "public static boolean isInputDevice(int device)", "public int getDevicesForStream(int streamType)", "public List<AudioDeviceAttributes> getDevicesForAttributes(@NonNull AudioAttributes attributes)", "public void addOnDevicesForAttributesChangedListener(@NonNull AudioAttributes attributes, @NonNull @CallbackExecutor Executor executor, @NonNull OnDevicesForAttributesChangedListener listener)", "public void removeOnDevicesForAttributesChangedListener(@NonNull OnDevicesForAttributesChangedListener listener)", "public List<AudioDeviceInfo> getAudioDevicesForAttributes(@NonNull AudioAttributes attributes)", "public static void enforceValidVolumeBehavior(int volumeBehavior)", "public void setDeviceVolumeBehavior(@NonNull AudioDeviceAttributes device, @DeviceVolumeBehavior int deviceVolumeBehavior)", "public int getDeviceVolumeBehavior(@NonNull AudioDeviceAttributes device)", "public boolean isFullVolumeDevice()", "public void setWiredDeviceConnectionState(int device, int state, String address, String name)", "public void setWiredDeviceConnectionState(AudioDeviceAttributes attributes, int state)", "public void setTestDeviceConnectionState(@NonNull AudioDeviceAttributes device, boolean connected)", "public void handleBluetoothActiveDeviceChanged(@Nullable BluetoothDevice newDevice, @Nullable BluetoothDevice previousDevice, @NonNull BluetoothProfileConnectionInfo info)", "public IRingtonePlayer getRingtonePlayer()", "public String getProperty(String key)", "public boolean setAdditionalOutputDeviceDelay(@NonNull AudioDeviceInfo device, @IntRange(from = 0) long delayMillis)", "public long getAdditionalOutputDeviceDelay(@NonNull AudioDeviceInfo device)", "public long getMaxAdditionalOutputDeviceDelay(@NonNull AudioDeviceInfo device)", "public int getOutputLatency(int streamType)", "public void setVolumeController(IVolumeController controller)", "public IVolumeController getVolumeController()", "public void notifyVolumeControllerVisible(IVolumeController controller, boolean visible)", "public boolean isStreamAffectedByRingerMode(int streamType)", "public boolean isStreamAffectedByMute(int streamType)", "public void disableSafeMediaVolume()", "public void lowerVolumeToRs1()", "public float getRs2Value()", "public void setRs2Value(float rs2Value)", "public float getCsd()", "public void setCsd(float csd)", "public void forceUseFrameworkMel(boolean useFrameworkMel)", "public void forceComputeCsdOnAllDevices(boolean computeCsdOnAllDevices)", "public boolean isCsdEnabled()", "public boolean isCsdAsAFeatureAvailable()", "public boolean isCsdAsAFeatureEnabled()", "public void setCsdAsAFeatureEnabled(boolean csdToggleValue)", "public static String audioDeviceCategoryToString(int audioDeviceCategory)", "public void setBluetoothAudioDeviceCategory_legacy(@NonNull String address, boolean isBle, @AudioDeviceCategory int btAudioDeviceType)", "public int getBluetoothAudioDeviceCategory_legacy(@NonNull String address, boolean isBle)", "public boolean setBluetoothAudioDeviceCategory(@NonNull String address, @AudioDeviceCategory int btAudioDeviceCategory)", "public int getBluetoothAudioDeviceCategory(@NonNull String address)", "public boolean isBluetoothAudioDeviceCategoryFixed(@NonNull String address)", "public void setRingerModeInternal(int ringerMode)", "public int getRingerModeInternal()", "public void setVolumePolicy(VolumePolicy policy)", "public int setHdmiSystemAudioSupported(boolean on)", "public boolean isHdmiSystemAudioSupported()", "public static int listAudioPorts(ArrayList<AudioPort> ports)", "public static int listPreviousAudioPorts(ArrayList<AudioPort> ports)", "public static int listAudioDevicePorts(ArrayList<AudioDevicePort> devices)", "public static int listPreviousAudioDevicePorts(ArrayList<AudioDevicePort> devices)", "private static void filterDevicePorts(ArrayList<AudioPort> ports, ArrayList<AudioDevicePort> devices)", "public static int createAudioPatch(AudioPatch[] patch, AudioPortConfig[] sources, AudioPortConfig[] sinks)", "public static int releaseAudioPatch(AudioPatch patch)", "public static int listAudioPatches(ArrayList<AudioPatch> patches)", "public static int setAudioPortGain(AudioPort port, AudioGainConfig gain)", "public void registerAudioPortUpdateListener(OnAudioPortUpdateListener l)", "public void unregisterAudioPortUpdateListener(OnAudioPortUpdateListener l)", " static int resetAudioPortGeneration()", " static int updateAudioPortCache(ArrayList<AudioPort> ports, ArrayList<AudioPatch> patches, ArrayList<AudioPort> previousPorts)", " static AudioPortConfig updatePortConfig(AudioPortConfig portCfg, ArrayList<AudioPort> ports)", "private static boolean checkFlags(AudioDevicePort port, int flags)", "private static boolean checkTypes(AudioDevicePort port)", "public Set<Integer> getSupportedDeviceTypes(@AudioDeviceRole int direction)", "public AudioDeviceInfo[] getDevices(@AudioDeviceRole int flags)", "private static AudioDeviceInfo[] infoListFromPortList(ArrayList<AudioDevicePort> ports, int flags)", "private static AudioDeviceInfo[] calcListDeltas(ArrayList<AudioDevicePort> ports_A, ArrayList<AudioDevicePort> ports_B, int flags)", "public static AudioDeviceInfo[] getDevicesStatic(int flags)", "public static AudioDeviceInfo getDeviceForPortId(int portId, int flags)", "public void registerAudioDeviceCallback(AudioDeviceCallback callback, @Nullable Handler handler)", "public void unregisterAudioDeviceCallback(AudioDeviceCallback callback)", "public static void setPortIdForMicrophones(ArrayList<MicrophoneInfo> microphones)", "public static MicrophoneInfo microphoneInfoFromAudioDeviceInfo(AudioDeviceInfo deviceInfo)", "private void addMicrophonesFromAudioDeviceInfo(ArrayList<MicrophoneInfo> microphones, HashSet<Integer> filterTypes)", "public List<MicrophoneInfo> getMicrophones() throws IOException", "public List<BluetoothCodecConfig> getHwOffloadFormatsSupportedForA2dp()", "private List<BluetoothLeAudioCodecConfig> getHwOffloadFormatsSupportedForLeAudio(@AudioSystem.BtOffloadDeviceType int deviceType)", "public List<BluetoothLeAudioCodecConfig> getHwOffloadFormatsSupportedForLeAudio()", "public List<BluetoothLeAudioCodecConfig> getHwOffloadFormatsSupportedForLeBroadcast()", "private void broadcastDeviceListChange_sync(Handler handler)", "public void setAudioServerStateCallback(@NonNull Executor executor, @NonNull AudioServerStateCallback stateCallback)", "public void clearAudioServerStateCallback()", "public boolean isAudioServerRunning()", "public boolean setEncodedSurroundMode(@EncodedSurroundOutputMode int mode)", "public int getEncodedSurroundMode()", "public Map<Integer, Boolean> getSurroundFormats()", "public boolean setSurroundFormatEnabled(@AudioFormat.SurroundSoundEncoding int audioFormat, boolean enabled)", "public boolean isSurroundFormatEnabled(@AudioFormat.SurroundSoundEncoding int audioFormat)", "public List<Integer> getReportedSurroundFormats()", "public static boolean isHapticPlaybackSupported()", "public boolean isUltrasoundSupported()", "public boolean isHotwordStreamSupported(boolean lookbackAudio)", "public static List<AudioProductStrategy> getAudioProductStrategies()", "public static List<AudioVolumeGroup> getAudioVolumeGroups()", "public void registerVolumeGroupCallback(@NonNull Executor executor, @NonNull VolumeGroupCallback callback)", "public void unregisterVolumeGroupCallback(@NonNull VolumeGroupCallback callback)", "public static boolean hasHapticChannelsImpl(@NonNull Context context, @NonNull Uri uri)", "public static boolean hasHapticChannels(@Nullable Context context, @NonNull Uri uri)", "public static void setRttEnabled(boolean rttEnabled)", "public void adjustSuggestedStreamVolumeForUid(int suggestedStreamType, int direction, @SystemVolumeFlags int flags, @NonNull String packageName, int uid, int pid, int targetSdkVersion)", "public void adjustStreamVolumeForUid(int streamType, int direction, @SystemVolumeFlags int flags, @NonNull String packageName, int uid, int pid, int targetSdkVersion)", "public void setStreamVolumeForUid(int streamType, int index, @SystemVolumeFlags int flags, @NonNull String packageName, int uid, int pid, int targetSdkVersion)", "public void setMultiAudioFocusEnabled(boolean enabled)", "public int getAudioHwSyncForSession(int sessionId)", "public boolean setCommunicationDevice(@NonNull AudioDeviceInfo device)", "public void clearCommunicationDevice()", "public AudioDeviceInfo getCommunicationDevice()", "public List<AudioDeviceInfo> getAvailableCommunicationDevices()", "public List<AudioProfile> getDirectProfilesForAttributes(@NonNull AudioAttributes attributes)", "public static AudioDeviceInfo getDeviceInfoFromType(@AudioDeviceInfo.AudioDeviceTypeOut int deviceType)", "public static AudioDeviceInfo getDeviceInfoFromTypeAndAddress(@AudioDeviceInfo.AudioDeviceTypeOut int type, @Nullable String address)", "public void addOnCommunicationDeviceChangedListener(@NonNull @CallbackExecutor Executor executor, @NonNull OnCommunicationDeviceChangedListener listener)", "public void removeOnCommunicationDeviceChangedListener(@NonNull OnCommunicationDeviceChangedListener listener)", "public boolean isPstnCallAudioInterceptable()", "private int getCallRedirectMode()", "private void checkCallRedirectionFormat(AudioFormat format, boolean isOutput)", "public AudioTrack getCallUplinkInjectionAudioTrack(@NonNull AudioFormat format)", "public AudioRecord getCallDownlinkExtractionAudioRecord(@NonNull AudioFormat format)", "public void muteAwaitConnection(@NonNull int[] usagesToMute, @NonNull AudioDeviceAttributes device, long timeout, @NonNull TimeUnit timeUnit) throws IllegalStateException", "public AudioDeviceAttributes getMutingExpectedDevice()", "public void cancelMuteAwaitConnection(@NonNull AudioDeviceAttributes device) throws IllegalStateException", "public void registerMuteAwaitConnectionCallback(@NonNull @CallbackExecutor Executor executor, @NonNull MuteAwaitConnectionCallback callback)", "public void unregisterMuteAwaitConnectionCallback(@NonNull MuteAwaitConnectionCallback callback)", "public void addAssistantServicesUids(@NonNull int[] assistantUids)", "public void removeAssistantServicesUids(@NonNull int[] assistantUids)", "public int[] getAssistantServicesUids()", "public void setActiveAssistantServiceUids(@NonNull int[] assistantUids)", "public int[] getActiveAssistantServicesUids()", "public static AudioHalVersionInfo getHalVersion()", "public List<AudioMixerAttributes> getSupportedMixerAttributes(@NonNull AudioDeviceInfo device)", "public boolean setPreferredMixerAttributes(@NonNull AudioAttributes attributes, @NonNull AudioDeviceInfo device, @NonNull AudioMixerAttributes mixerAttributes)", "public AudioMixerAttributes getPreferredMixerAttributes(@NonNull AudioAttributes attributes, @NonNull AudioDeviceInfo device)", "public boolean clearPreferredMixerAttributes(@NonNull AudioAttributes attributes, @NonNull AudioDeviceInfo device)", "public void addOnPreferredMixerAttributesChangedListener(@NonNull @CallbackExecutor Executor executor, @NonNull OnPreferredMixerAttributesChangedListener listener)", "public void removeOnPreferredMixerAttributesChangedListener(@NonNull OnPreferredMixerAttributesChangedListener listener)", "public boolean supportsBluetoothVariableLatency()", "public void setBluetoothVariableLatencyEnabled(boolean enabled)", "public boolean isBluetoothVariableLatencyEnabled()", "public void addOnStreamAliasingChangedListener(@NonNull @CallbackExecutor Executor executor, @NonNull Runnable onStreamAliasingChangedListener)", "public void removeOnStreamAliasingChangedListener(@NonNull Runnable onStreamAliasingChangedListener)", "public void setNotifAliasRingForTest(boolean isAliased)", "public List<Integer> getIndependentStreamTypes()", "public int getStreamTypeAlias(@PublicStreamTypes int sourceStreamType)", "public boolean isVolumeControlUsingVolumeGroups()", "public boolean shouldNotificationSoundPlay(@NonNull final AudioAttributes aa)", "private void initPlatform()", "private boolean applyAutoHardening()" ],
  "variableNames" : [ "mOriginalContext", "mApplicationContext", "mOriginalContextDeviceId", "mVirtualDeviceManager", "TAG", "DEBUG", "sAudioPortEventHandler", "sAudioAudioVolumeGroupChangedHandler", "sContext", "ACTION_AUDIO_BECOMING_NOISY", "RINGER_MODE_CHANGED_ACTION", "INTERNAL_RINGER_MODE_CHANGED_ACTION", "EXTRA_RINGER_MODE", "VIBRATE_SETTING_CHANGED_ACTION", "VOLUME_CHANGED_ACTION", "ACTION_VOLUME_CHANGED", "STREAM_DEVICES_CHANGED_ACTION", "STREAM_MUTE_CHANGED_ACTION", "MASTER_MUTE_CHANGED_ACTION", "EXTRA_VIBRATE_SETTING", "EXTRA_VIBRATE_TYPE", "EXTRA_VOLUME_STREAM_TYPE", "EXTRA_VOLUME_STREAM_TYPE_ALIAS", "EXTRA_VOLUME_STREAM_VALUE", "EXTRA_PREV_VOLUME_STREAM_VALUE", "EXTRA_VOLUME_STREAM_DEVICES", "EXTRA_PREV_VOLUME_STREAM_DEVICES", "EXTRA_MASTER_VOLUME_MUTED", "EXTRA_STREAM_VOLUME_MUTED", "ACTION_HEADSET_PLUG", "ACTION_HDMI_AUDIO_PLUG", "EXTRA_AUDIO_PLUG_STATE", "EXTRA_MAX_CHANNEL_COUNT", "EXTRA_ENCODINGS", "STREAM_VOICE_CALL", "STREAM_SYSTEM", "STREAM_RING", "STREAM_MUSIC", "STREAM_ALARM", "STREAM_NOTIFICATION", "STREAM_BLUETOOTH_SCO", "STREAM_SYSTEM_ENFORCED", "STREAM_DTMF", "STREAM_TTS", "STREAM_ACCESSIBILITY", "STREAM_ASSISTANT", "NUM_STREAMS", "PUBLIC_STREAM_TYPES", "ADJUST_RAISE", "ADJUST_LOWER", "ADJUST_SAME", "ADJUST_MUTE", "ADJUST_UNMUTE", "ADJUST_TOGGLE_MUTE", "FLAG_SHOW_UI", "FLAG_ALLOW_RINGER_MODES", "FLAG_PLAY_SOUND", "FLAG_REMOVE_SOUND_AND_VIBRATE", "FLAG_VIBRATE", "FLAG_FIXED_VOLUME", "FLAG_BLUETOOTH_ABS_VOLUME", "FLAG_SHOW_SILENT_HINT", "FLAG_HDMI_SYSTEM_AUDIO_VOLUME", "FLAG_ACTIVE_MEDIA_ONLY", "FLAG_SHOW_UI_WARNINGS", "FLAG_SHOW_VIBRATE_HINT", "FLAG_FROM_KEY", "FLAG_ABSOLUTE_VOLUME", "ENCODED_SURROUND_OUTPUT_UNKNOWN", "ENCODED_SURROUND_OUTPUT_AUTO", "ENCODED_SURROUND_OUTPUT_NEVER", "ENCODED_SURROUND_OUTPUT_ALWAYS", "ENCODED_SURROUND_OUTPUT_MANUAL", "FLAG_NAMES", "RINGER_MODE_SILENT", "RINGER_MODE_VIBRATE", "RINGER_MODE_NORMAL", "RINGER_MODE_MAX", "VIBRATE_TYPE_RINGER", "VIBRATE_TYPE_NOTIFICATION", "VIBRATE_SETTING_OFF", "VIBRATE_SETTING_ON", "VIBRATE_SETTING_ONLY_SILENT", "USE_DEFAULT_STREAM_TYPE", "sService", "VOLUME_MIN_DB", "mPrefDevListenerMgr", "mNonDefDevListenerMgr", "mDevRoleForCapturePresetListeners", "mDevRoleForCapturePresetListenersLock", "mDeviceRoleListenersStatus", "mDevicesRoleForCapturePresetDispatcherStub", "DIRECT_PLAYBACK_NOT_SUPPORTED", "DIRECT_PLAYBACK_OFFLOAD_SUPPORTED", "DIRECT_PLAYBACK_OFFLOAD_GAPLESS_SUPPORTED", "DIRECT_PLAYBACK_BITSTREAM_SUPPORTED", "PLAYBACK_OFFLOAD_NOT_SUPPORTED", "PLAYBACK_OFFLOAD_SUPPORTED", "PLAYBACK_OFFLOAD_GAPLESS_SUPPORTED", "ACTION_SCO_AUDIO_STATE_CHANGED", "ACTION_SCO_AUDIO_STATE_UPDATED", "EXTRA_SCO_AUDIO_STATE", "EXTRA_SCO_AUDIO_PREVIOUS_STATE", "SCO_AUDIO_STATE_DISCONNECTED", "SCO_AUDIO_STATE_CONNECTED", "SCO_AUDIO_STATE_CONNECTING", "SCO_AUDIO_STATE_ERROR", "ACTION_MICROPHONE_MUTE_CHANGED", "ACTION_SPEAKERPHONE_STATE_CHANGED", "CALL_REDIRECTION_AUDIO_MODES", "mModeChangedListenerMgr", "MODE_INVALID", "MODE_CURRENT", "MODE_NORMAL", "MODE_RINGTONE", "MODE_IN_CALL", "MODE_IN_COMMUNICATION", "MODE_CALL_SCREENING", "MODE_CALL_REDIRECT", "MODE_COMMUNICATION_REDIRECT", "ROUTE_EARPIECE", "ROUTE_SPEAKER", "ROUTE_BLUETOOTH", "ROUTE_BLUETOOTH_SCO", "ROUTE_HEADSET", "ROUTE_BLUETOOTH_A2DP", "ROUTE_ALL", "AUDIO_SESSION_ID_GENERATE", "FX_KEY_CLICK", "FX_FOCUS_NAVIGATION_UP", "FX_FOCUS_NAVIGATION_DOWN", "FX_FOCUS_NAVIGATION_LEFT", "FX_FOCUS_NAVIGATION_RIGHT", "FX_KEYPRESS_STANDARD", "FX_KEYPRESS_SPACEBAR", "FX_KEYPRESS_DELETE", "FX_KEYPRESS_RETURN", "FX_KEYPRESS_INVALID", "FX_BACK", "FX_HOME", "FX_FOCUS_NAVIGATION_REPEAT_1", "FX_FOCUS_NAVIGATION_REPEAT_2", "FX_FOCUS_NAVIGATION_REPEAT_3", "FX_FOCUS_NAVIGATION_REPEAT_4", "NUM_SOUND_EFFECTS", "NUM_NAVIGATION_REPEAT_SOUND_EFFECTS", "AUDIOFOCUS_NONE", "AUDIOFOCUS_GAIN", "AUDIOFOCUS_GAIN_TRANSIENT", "AUDIOFOCUS_GAIN_TRANSIENT_MAY_DUCK", "AUDIOFOCUS_GAIN_TRANSIENT_EXCLUSIVE", "AUDIOFOCUS_LOSS", "AUDIOFOCUS_LOSS_TRANSIENT", "AUDIOFOCUS_LOSS_TRANSIENT_CAN_DUCK", "mAudioFocusIdListenerMap", "mServiceEventHandlerDelegate", "MSSG_FOCUS_CHANGE", "MSSG_RECORDING_CONFIG_CHANGE", "MSSG_PLAYBACK_CONFIG_CHANGE", "mAudioFocusDispatcher", "AUDIOFOCUS_REQUEST_FAILED", "AUDIOFOCUS_REQUEST_GRANTED", "AUDIOFOCUS_REQUEST_DELAYED", "AUDIOFOCUS_REQUEST_WAITING_FOR_EXT_POLICY", "EXT_FOCUS_POLICY_TIMEOUT_MS", "FOCUS_CLIENT_ID_STRING", "mFocusRequestsLock", "mFocusRequestsAwaitingResult", "AUDIOFOCUS_FLAG_DELAY_OK", "AUDIOFOCUS_FLAG_PAUSES_ON_DUCKABLE_LOSS", "AUDIOFOCUS_FLAG_LOCK", "AUDIOFOCUS_FLAG_TEST", "AUDIOFOCUS_FLAGS_APPS", "AUDIOFOCUS_FLAGS_SYSTEM", "mPlaybackCallbackList", "mPlaybackCallbackLock", "mPlayCb", "RECORD_CONFIG_EVENT_NONE", "RECORD_CONFIG_EVENT_START", "RECORD_CONFIG_EVENT_STOP", "RECORD_CONFIG_EVENT_UPDATE", "RECORD_CONFIG_EVENT_RELEASE", "RECORD_RIID_INVALID", "RECORDER_STATE_STARTED", "RECORDER_STATE_STOPPED", "mRecordCallbackList", "mRecordCallbackLock", "mRecCb", "mICallBack", "DEVICE_NONE", "DEVICE_OUT_EARPIECE", "DEVICE_OUT_SPEAKER", "DEVICE_OUT_WIRED_HEADSET", "DEVICE_OUT_WIRED_HEADPHONE", "DEVICE_OUT_USB_HEADSET", "DEVICE_OUT_BLUETOOTH_SCO", "DEVICE_OUT_BLUETOOTH_SCO_HEADSET", "DEVICE_OUT_BLUETOOTH_SCO_CARKIT", "DEVICE_OUT_BLUETOOTH_A2DP", "DEVICE_OUT_BLUETOOTH_A2DP_HEADPHONES", "DEVICE_OUT_BLUETOOTH_A2DP_SPEAKER", "DEVICE_OUT_AUX_DIGITAL", "DEVICE_OUT_HDMI", "DEVICE_OUT_ANLG_DOCK_HEADSET", "DEVICE_OUT_DGTL_DOCK_HEADSET", "DEVICE_OUT_USB_ACCESSORY", "DEVICE_OUT_USB_DEVICE", "DEVICE_OUT_REMOTE_SUBMIX", "DEVICE_OUT_TELEPHONY_TX", "DEVICE_OUT_LINE", "DEVICE_OUT_HDMI_ARC", "DEVICE_OUT_HDMI_EARC", "DEVICE_OUT_SPDIF", "DEVICE_OUT_FM", "DEVICE_OUT_ECHO_CANCELLER", "DEVICE_OUT_BLE_HEADSET", "DEVICE_OUT_BLE_SPEAKER", "DEVICE_OUT_BLE_BROADCAST", "DEVICE_OUT_DEFAULT", "DEVICE_IN_BUILTIN_MIC", "DEVICE_IN_BLUETOOTH_SCO_HEADSET", "DEVICE_IN_WIRED_HEADSET", "DEVICE_IN_HDMI", "DEVICE_IN_HDMI_ARC", "DEVICE_IN_HDMI_EARC", "DEVICE_IN_TELEPHONY_RX", "DEVICE_IN_BACK_MIC", "DEVICE_IN_ANLG_DOCK_HEADSET", "DEVICE_IN_DGTL_DOCK_HEADSET", "DEVICE_IN_USB_ACCESSORY", "DEVICE_IN_USB_DEVICE", "DEVICE_IN_FM_TUNER", "DEVICE_IN_TV_TUNER", "DEVICE_IN_LINE", "DEVICE_IN_SPDIF", "DEVICE_IN_LOOPBACK", "DEVICE_IN_ECHO_REFERENCE", "DEVICE_IN_BLE_HEADSET", "mDevicesForAttributesListenerToStub", "DEVICE_VOLUME_BEHAVIOR_UNSET", "DEVICE_VOLUME_BEHAVIOR_VARIABLE", "DEVICE_VOLUME_BEHAVIOR_FULL", "DEVICE_VOLUME_BEHAVIOR_FIXED", "DEVICE_VOLUME_BEHAVIOR_ABSOLUTE", "DEVICE_VOLUME_BEHAVIOR_ABSOLUTE_MULTI_MODE", "DEVICE_VOLUME_BEHAVIOR_ABSOLUTE_ADJUST_ONLY", "RETURN_DEVICE_VOLUME_BEHAVIOR_ABSOLUTE_ADJUST_ONLY", "PROPERTY_OUTPUT_SAMPLE_RATE", "PROPERTY_OUTPUT_FRAMES_PER_BUFFER", "PROPERTY_SUPPORT_MIC_NEAR_ULTRASOUND", "PROPERTY_SUPPORT_SPEAKER_NEAR_ULTRASOUND", "PROPERTY_SUPPORT_AUDIO_SOURCE_UNPROCESSED", "AUDIO_DEVICE_CATEGORY_UNKNOWN", "AUDIO_DEVICE_CATEGORY_OTHER", "AUDIO_DEVICE_CATEGORY_SPEAKER", "AUDIO_DEVICE_CATEGORY_HEADPHONES", "AUDIO_DEVICE_CATEGORY_CARKIT", "AUDIO_DEVICE_CATEGORY_WATCH", "AUDIO_DEVICE_CATEGORY_HEARING_AID", "AUDIO_DEVICE_CATEGORY_RECEIVER", "CSD_WARNING_DOSE_REACHED_1X", "CSD_WARNING_DOSE_REPEATED_5X", "CSD_WARNING_MOMENTARY_EXPOSURE", "CSD_WARNING_ACCUMULATION_START", "SUCCESS", "ERROR", "ERROR_BAD_VALUE", "ERROR_INVALID_OPERATION", "ERROR_PERMISSION_DENIED", "ERROR_NO_INIT", "ERROR_DEAD_OBJECT", "AUDIOPORT_GENERATION_INIT", "sAudioPortGenerationLock", "sAudioPortGeneration", "sAudioPortsCached", "sPreviousAudioPortsCached", "sAudioPatchesCached", "mPortListener", "MSG_DEVICES_CALLBACK_REGISTERED", "MSG_DEVICES_DEVICES_ADDED", "MSG_DEVICES_DEVICES_REMOVED", "mDeviceCallbacks", "GET_DEVICES_INPUTS", "GET_DEVICES_OUTPUTS", "GET_DEVICES_ALL", "mPreviousPorts", "mAudioServerStateExec", "mAudioServerStateCb", "mAudioServerStateCbLock", "mAudioServerStateDispatcher", "mCommDeviceChangedListenerMgr", "CALL_REDIRECT_NONE", "CALL_REDIRECT_PSTN", "CALL_REDIRECT_VOIP", "mCallRedirectionLock", "mCallRedirectionModeListener", "mCallIRedirectionClients", "mPrefMixerAttributesListenerMgr", "mStreamAliasingListenerMgr", "mMuteAwaitConnectionListenerLock", "mMuteAwaitConnectionListeners", "mMuteAwaitConnDispatcherStub", "mIsAutomotive" ]
}