{
  "filePath" : "/home/maryam/clearblue/files/android-source-30/android/telephony/PhoneNumberUtils.java",
  "packageName" : "android.telephony",
  "className" : "PhoneNumberUtils",
  "comment" : "\n * Various utilities for dealing with phone number strings.\n ",
  "variables" : [ {
    "name" : "BCD_EXTENDED_TYPE_EF_ADN",
    "type" : "int",
    "comment" : "\n     * The BCD extended type used to determine the extended char for the digit which is greater than\n     * 9.\n     *\n     * see TS 51.011 section 10.5.1 EF_ADN(Abbreviated dialling numbers)\n     ",
    "links" : [ ]
  }, {
    "name" : "BCD_EXTENDED_TYPE_CALLED_PARTY",
    "type" : "int",
    "comment" : "\n     * The BCD extended type used to determine the extended char for the digit which is greater than\n     * 9.\n     *\n     * see TS 24.008 section 10.5.4.7 Called party BCD number\n     ",
    "links" : [ ]
  }, {
    "name" : "PAUSE",
    "type" : "char",
    "comment" : "\n     * Special characters\n     *\n     * (See \"What is a phone number?\" doc)\n     * 'p' --- GSM pause character, same as comma\n     * 'n' --- GSM wild character\n     * 'w' --- GSM wait character\n     ",
    "links" : [ ]
  }, {
    "name" : "WAIT",
    "type" : "char",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "WILD",
    "type" : "char",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "CLIR_ON",
    "type" : "String",
    "comment" : "\n     * Calling Line Identification Restriction (CLIR)\n     ",
    "links" : [ ]
  }, {
    "name" : "CLIR_OFF",
    "type" : "String",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "TOA_International",
    "type" : "int",
    "comment" : "\n     * TOA = TON + NPI\n     * See TS 24.008 section 10.5.4.7 for details.\n     * These are the only really useful TOA values\n     ",
    "links" : [ ]
  }, {
    "name" : "TOA_Unknown",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "LOG_TAG",
    "type" : "String",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "DBG",
    "type" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "BCD_EF_ADN_EXTENDED",
    "type" : "String",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "BCD_CALLED_PARTY_EXTENDED",
    "type" : "String",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "GLOBAL_PHONE_NUMBER_PATTERN",
    "type" : "Pattern",
    "comment" : "\n     * global-phone-number = [\"+\"] 1*( DIGIT / written-sep )\n     * written-sep         = (\"-\"/\".\")\n     ",
    "links" : [ ]
  }, {
    "name" : "sMinMatch",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "FORMAT_UNKNOWN",
    "type" : "int",
    "comment" : " The current locale is unknown, look for a country code or don't format ",
    "links" : [ ]
  }, {
    "name" : "FORMAT_NANP",
    "type" : "int",
    "comment" : " NANP formatting ",
    "links" : [ ]
  }, {
    "name" : "FORMAT_JAPAN",
    "type" : "int",
    "comment" : " Japanese formatting ",
    "links" : [ ]
  }, {
    "name" : "NANP_COUNTRIES",
    "type" : "String[]",
    "comment" : " List of country codes for countries that use the NANP ",
    "links" : [ ]
  }, {
    "name" : "KOREA_ISO_COUNTRY_CODE",
    "type" : "String",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "JAPAN_ISO_COUNTRY_CODE",
    "type" : "String",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "NANP_STATE_DIGIT",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "NANP_STATE_PLUS",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "NANP_STATE_ONE",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "NANP_STATE_DASH",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "KEYPAD_MAP",
    "type" : "SparseIntArray",
    "comment" : "\n     * The phone keypad letter mapping (see ITU E.161 or ISO/IEC 9995-8.)\n     * TODO: This should come from a resource.\n     ",
    "links" : [ ]
  }, {
    "name" : "PLUS_SIGN_CHAR",
    "type" : "char",
    "comment" : "================ Plus Code formatting =========================",
    "links" : [ ]
  }, {
    "name" : "PLUS_SIGN_STRING",
    "type" : "String",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "NANP_IDP_STRING",
    "type" : "String",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "NANP_LENGTH",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "COUNTRY_CALLING_CALL",
    "type" : "boolean[]",
    "comment" : "\n     * If true, the number is country calling code.\n     ",
    "links" : [ ]
  }, {
    "name" : "CCC_LENGTH",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "sConvertToEmergencyMap",
    "type" : "String[]",
    "comment" : "\n     * The config held calling number conversion map, expected to convert to emergency number.\n     ",
    "links" : [ ]
  } ],
  "methods" : [ {
    "name" : "public static boolean isISODigit(char c)",
    "returnType" : "boolean",
    "comment" : " True if c is ISO-LATIN characters 0-9 ",
    "links" : [ ]
  }, {
    "name" : "public static final boolean is12Key(char c)",
    "returnType" : "boolean",
    "comment" : " True if c is ISO-LATIN characters 0-9, *, # ",
    "links" : [ ]
  }, {
    "name" : "public static final boolean isDialable(char c)",
    "returnType" : "boolean",
    "comment" : " True if c is ISO-LATIN characters 0-9, *, # , +, WILD  ",
    "links" : [ ]
  }, {
    "name" : "public static final boolean isReallyDialable(char c)",
    "returnType" : "boolean",
    "comment" : " True if c is ISO-LATIN characters 0-9, *, # , + (no WILD)  ",
    "links" : [ ]
  }, {
    "name" : "public static final boolean isNonSeparator(char c)",
    "returnType" : "boolean",
    "comment" : " True if c is ISO-LATIN characters 0-9, *, # , +, WILD, WAIT, PAUSE   ",
    "links" : [ ]
  }, {
    "name" : "public static final boolean isStartsPostDial(char c)",
    "returnType" : "boolean",
    "comment" : " This any anything to the right of this char is part of the\n     *  post-dial string (eg this is PAUSE or WAIT)\n     ",
    "links" : [ ]
  }, {
    "name" : "private static boolean isPause(char c)",
    "returnType" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private static boolean isToneWait(char c)",
    "returnType" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private static int getMinMatch()",
    "returnType" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public static int getMinMatchForTest()",
    "returnType" : "int",
    "comment" : "\n     * A Test API to get current sMinMatch.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public static void setMinMatchForTest(int minMatch)",
    "returnType" : "void",
    "comment" : "\n     * A Test API to set sMinMatch.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "private static boolean isSeparator(char ch)",
    "returnType" : "boolean",
    "comment" : " Returns true if ch is not dialable or alpha char ",
    "links" : [ ]
  }, {
    "name" : "public static String getNumberFromIntent(Intent intent, Context context)",
    "returnType" : "String",
    "comment" : " Extracts the phone number from an Intent.\n     *\n     * @param intent the intent to get the number of\n     * @param context a context to use for database access\n     *\n     * @return the phone number that would be called by the intent, or\n     *         <code>null</code> if the number cannot be found.\n     ",
    "links" : [ ]
  }, {
    "name" : "public static String extractNetworkPortion(String phoneNumber)",
    "returnType" : "String",
    "comment" : " Extracts the network address portion and canonicalizes\n     *  (filters out separators.)\n     *  Network address portion is everything up to DTMF control digit\n     *  separators (pause or wait), but without non-dialable characters.\n     *\n     *  Please note that the GSM wild character is allowed in the result.\n     *  This must be resolved before dialing.\n     *\n     *  Returns null if phoneNumber == null\n     ",
    "links" : [ ]
  }, {
    "name" : "public static String extractNetworkPortionAlt(String phoneNumber)",
    "returnType" : "String",
    "comment" : "\n     * Extracts the network address portion and canonicalize.\n     *\n     * This function is equivalent to extractNetworkPortion(), except\n     * for allowing the PLUS character to occur at arbitrary positions\n     * in the address portion, not just the first position.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public static String stripSeparators(String phoneNumber)",
    "returnType" : "String",
    "comment" : "\n     * Strips separators from a phone number string.\n     * @param phoneNumber phone number to strip.\n     * @return phone string stripped of separators.\n     ",
    "links" : [ ]
  }, {
    "name" : "public static String convertAndStrip(String phoneNumber)",
    "returnType" : "String",
    "comment" : "\n     * Translates keypad letters to actual digits (e.g. 1-800-GOOG-411 will\n     * become 1-800-4664-411), and then strips all separators (e.g. 1-800-4664-411 will become\n     * 18004664411).\n     *\n     * @see #convertKeypadLettersToDigits(String)\n     * @see #stripSeparators(String)\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public static String convertPreDial(String phoneNumber)",
    "returnType" : "String",
    "comment" : "\n     * Converts pause and tonewait pause characters\n     * to Android representation.\n     * RFC 3601 says pause is 'p' and tonewait is 'w'.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "private static int minPositive(int a, int b)",
    "returnType" : "int",
    "comment" : " or -1 if both are negative ",
    "links" : [ ]
  }, {
    "name" : "private static void log(String msg)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private static int indexOfLastNetworkChar(String a)",
    "returnType" : "int",
    "comment" : " index of the last character of the network portion\n     *  (eg anything after is a post-dial string)\n     ",
    "links" : [ ]
  }, {
    "name" : "public static String extractPostDialPortion(String phoneNumber)",
    "returnType" : "String",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public static boolean compare(String a, String b)",
    "returnType" : "boolean",
    "comment" : "\n     * Compare phone numbers a and b, return true if they're identical enough for caller ID purposes.\n     ",
    "links" : [ ]
  }, {
    "name" : "public static boolean compare(Context context, String a, String b)",
    "returnType" : "boolean",
    "comment" : "\n     * Compare phone numbers a and b, and return true if they're identical\n     * enough for caller ID purposes. Checks a resource to determine whether\n     * to use a strict or loose comparison algorithm.\n     ",
    "links" : [ ]
  }, {
    "name" : "public static boolean compare(String a, String b, boolean useStrictComparation)",
    "returnType" : "boolean",
    "comment" : "\n     * @hide only for testing.\n     ",
    "links" : [ ]
  }, {
    "name" : "public static boolean compareLoosely(String a, String b)",
    "returnType" : "boolean",
    "comment" : "\n     * Compare phone numbers a and b, return true if they're identical\n     * enough for caller ID purposes.\n     *\n     * - Compares from right to left\n     * - requires minimum characters to match\n     * - handles common trunk prefixes and international prefixes\n     *   (basically, everything except the Russian trunk prefix)\n     *\n     * Note that this method does not return false even when the two phone numbers\n     * are not exactly same; rather; we can call this method \"similar()\", not \"equals()\".\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public static boolean compareStrictly(String a, String b)",
    "returnType" : "boolean",
    "comment" : "\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public static boolean compareStrictly(String a, String b, boolean acceptInvalidCCCPrefix)",
    "returnType" : "boolean",
    "comment" : "\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public static String toCallerIDMinMatch(String phoneNumber)",
    "returnType" : "String",
    "comment" : "\n     * Returns the rightmost minimum matched characters in the network portion\n     * in *reversed* order\n     *\n     * This can be used to do a database lookup against the column\n     * that stores getStrippedReversed()\n     *\n     * Returns null if phoneNumber == null\n     ",
    "links" : [ ]
  }, {
    "name" : "public static String getStrippedReversed(String phoneNumber)",
    "returnType" : "String",
    "comment" : "\n     * Returns the network portion reversed.\n     * This string is intended to go into an index column for a\n     * database lookup.\n     *\n     * Returns null if phoneNumber == null\n     ",
    "links" : [ ]
  }, {
    "name" : "private static String internalGetStrippedReversed(String np, int numDigits)",
    "returnType" : "String",
    "comment" : "\n     * Returns the last numDigits of the reversed phone number\n     * Returns null if np == null\n     ",
    "links" : [ ]
  }, {
    "name" : "public static String stringFromStringAndTOA(String s, int TOA)",
    "returnType" : "String",
    "comment" : "\n     * Basically: makes sure there's a + in front of a\n     * TOA_International number\n     *\n     * Returns null if s == null\n     ",
    "links" : [ ]
  }, {
    "name" : "public static int toaFromString(String s)",
    "returnType" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public static String calledPartyBCDToString(byte[] bytes, int offset, int length)",
    "returnType" : "String",
    "comment" : "\n     *  3GPP TS 24.008 10.5.4.7\n     *  Called Party BCD Number\n     *\n     *  See Also TS 51.011 10.5.1 \"dialing number/ssc string\"\n     *  and TS 11.11 \"10.3.1 EF adn (Abbreviated dialing numbers)\"\n     *\n     * @param bytes the data buffer\n     * @param offset should point to the TOA (aka. TON/NPI) octet after the length byte\n     * @param length is the number of bytes including TOA byte\n     *                and must be at least 2\n     *\n     * @return partial string on invalid decode\n     *\n     * @deprecated use {@link #calledPartyBCDToString(byte[], int, int, int)} instead. Calling this\n     * method is equivalent to calling {@link #calledPartyBCDToString(byte[], int, int)} with\n     * {@link #BCD_EXTENDED_TYPE_EF_ADN} as the extended type.\n     ",
    "links" : [ "#calledPartyBCDToString", "#calledPartyBCDToString", "#BCD_EXTENDED_TYPE_EF_ADN" ]
  }, {
    "name" : "public static String calledPartyBCDToString(byte[] bytes, int offset, int length, @BcdExtendType int bcdExtType)",
    "returnType" : "String",
    "comment" : "\n     *  3GPP TS 24.008 10.5.4.7\n     *  Called Party BCD Number\n     *\n     *  See Also TS 51.011 10.5.1 \"dialing number/ssc string\"\n     *  and TS 11.11 \"10.3.1 EF adn (Abbreviated dialing numbers)\"\n     *\n     * @param bytes the data buffer\n     * @param offset should point to the TOA (aka. TON/NPI) octet after the length byte\n     * @param length is the number of bytes including TOA byte\n     *                and must be at least 2\n     * @param bcdExtType used to determine the extended bcd coding\n     * @see #BCD_EXTENDED_TYPE_EF_ADN\n     * @see #BCD_EXTENDED_TYPE_CALLED_PARTY\n     *\n     ",
    "links" : [ ]
  }, {
    "name" : "private static void internalCalledPartyBCDFragmentToString(StringBuilder sb, byte[] bytes, int offset, int length, @BcdExtendType int bcdExtType)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public static String calledPartyBCDFragmentToString(byte[] bytes, int offset, int length)",
    "returnType" : "String",
    "comment" : "\n     * Like calledPartyBCDToString, but field does not start with a\n     * TOA byte. For example: SIM ADN extension fields\n     *\n     * @deprecated use {@link #calledPartyBCDFragmentToString(byte[], int, int, int)} instead.\n     * Calling this method is equivalent to calling\n     * {@link #calledPartyBCDFragmentToString(byte[], int, int, int)} with\n     * {@link #BCD_EXTENDED_TYPE_EF_ADN} as the extended type.\n     ",
    "links" : [ "#calledPartyBCDFragmentToString", "#calledPartyBCDFragmentToString", "#BCD_EXTENDED_TYPE_EF_ADN" ]
  }, {
    "name" : "public static String calledPartyBCDFragmentToString(byte[] bytes, int offset, int length, @BcdExtendType int bcdExtType)",
    "returnType" : "String",
    "comment" : "\n     * Like calledPartyBCDToString, but field does not start with a\n     * TOA byte. For example: SIM ADN extension fields\n     ",
    "links" : [ ]
  }, {
    "name" : "private static char bcdToChar(byte b, @BcdExtendType int bcdExtType)",
    "returnType" : "char",
    "comment" : "\n     * Returns the correspond character for given {@code b} based on {@code bcdExtType}, or 0 on\n     * invalid code.\n     ",
    "links" : [ ]
  }, {
    "name" : "private static int charToBCD(char c, @BcdExtendType int bcdExtType)",
    "returnType" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public static boolean isWellFormedSmsAddress(String address)",
    "returnType" : "boolean",
    "comment" : "\n     * Return true iff the network portion of <code>address</code> is,\n     * as far as we can tell on the device, suitable for use as an SMS\n     * destination address.\n     ",
    "links" : [ ]
  }, {
    "name" : "public static boolean isGlobalPhoneNumber(String phoneNumber)",
    "returnType" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private static boolean isDialable(String address)",
    "returnType" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private static boolean isNonSeparator(String address)",
    "returnType" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public static byte[] networkPortionToCalledPartyBCD(String s)",
    "returnType" : "byte[]",
    "comment" : "\n     * Note: calls extractNetworkPortion(), so do not use for\n     * SIM EF[ADN] style records\n     *\n     * Returns null if network portion is empty.\n     ",
    "links" : [ ]
  }, {
    "name" : "public static byte[] networkPortionToCalledPartyBCDWithLength(String s)",
    "returnType" : "byte[]",
    "comment" : "\n     * Same as {@link #networkPortionToCalledPartyBCD}, but includes a\n     * one-byte length prefix.\n     ",
    "links" : [ "#networkPortionToCalledPartyBCD" ]
  }, {
    "name" : "public static byte[] numberToCalledPartyBCD(String number)",
    "returnType" : "byte[]",
    "comment" : "\n     * Convert a dialing number to BCD byte array\n     *\n     * @param number dialing number string. If the dialing number starts with '+', set to\n     * international TOA\n     *\n     * @return BCD byte array\n     *\n     * @deprecated use {@link #numberToCalledPartyBCD(String, int)} instead. Calling this method\n     * is equivalent to calling {@link #numberToCalledPartyBCD(String, int)} with\n     * {@link #BCD_EXTENDED_TYPE_EF_ADN} as the extended type.\n     ",
    "links" : [ "#numberToCalledPartyBCD", "#numberToCalledPartyBCD", "#BCD_EXTENDED_TYPE_EF_ADN" ]
  }, {
    "name" : "public static byte[] numberToCalledPartyBCD(String number, @BcdExtendType int bcdExtType)",
    "returnType" : "byte[]",
    "comment" : "\n     * Convert a dialing number to BCD byte array\n     *\n     * @param number dialing number string. If the dialing number starts with '+', set to\n     * international TOA\n     * @param bcdExtType used to determine the extended bcd coding\n     * @see #BCD_EXTENDED_TYPE_EF_ADN\n     * @see #BCD_EXTENDED_TYPE_CALLED_PARTY\n     *\n     * @return BCD byte array\n     ",
    "links" : [ ]
  }, {
    "name" : "private static byte[] numberToCalledPartyBCDHelper(String number, boolean includeLength, @BcdExtendType int bcdExtType)",
    "returnType" : "byte[]",
    "comment" : "\n     * If includeLength is true, prepend a one-byte length value to\n     * the return array.\n     ",
    "links" : [ ]
  }, {
    "name" : "public static String formatNumber(String source)",
    "returnType" : "String",
    "comment" : "\n     * Breaks the given number down and formats it according to the rules\n     * for the country the number is from.\n     *\n     * @param source The phone number to format\n     * @return A locally acceptable formatting of the input, or the raw input if\n     *  formatting rules aren't known for the number\n     *\n     * @deprecated Use link #formatNumber(String phoneNumber, String defaultCountryIso) instead\n     ",
    "links" : [ ]
  }, {
    "name" : "public static String formatNumber(String source, int defaultFormattingType)",
    "returnType" : "String",
    "comment" : "\n     * Formats the given number with the given formatting type. Currently\n     * {@link #FORMAT_NANP} and {@link #FORMAT_JAPAN} are supported as a formating type.\n     *\n     * @param source the phone number to format\n     * @param defaultFormattingType The default formatting rules to apply if the number does\n     * not begin with +[country_code]\n     * @return The phone number formatted with the given formatting type.\n     *\n     * @hide\n     * @deprecated Use link #formatNumber(String phoneNumber, String defaultCountryIso) instead\n     ",
    "links" : [ "#FORMAT_NANP", "#FORMAT_JAPAN" ]
  }, {
    "name" : "public static int getFormatTypeForLocale(Locale locale)",
    "returnType" : "int",
    "comment" : "\n     * Returns the phone number formatting type for the given locale.\n     *\n     * @param locale The locale of interest, usually {@link Locale#getDefault()}\n     * @return The formatting type for the given locale, or FORMAT_UNKNOWN if the formatting\n     * rules are not known for the given locale\n     *\n     * @deprecated Use link #formatNumber(String phoneNumber, String defaultCountryIso) instead\n     ",
    "links" : [ "Locale#getDefault" ]
  }, {
    "name" : "public static void formatNumber(Editable text, int defaultFormattingType)",
    "returnType" : "void",
    "comment" : "\n     * Formats a phone number in-place. Currently {@link #FORMAT_JAPAN} and {@link #FORMAT_NANP}\n     * is supported as a second argument.\n     *\n     * @param text The number to be formatted, will be modified with the formatting\n     * @param defaultFormattingType The default formatting rules to apply if the number does\n     * not begin with +[country_code]\n     *\n     * @deprecated Use link #formatNumber(String phoneNumber, String defaultCountryIso) instead\n     ",
    "links" : [ "#FORMAT_JAPAN", "#FORMAT_NANP" ]
  }, {
    "name" : "public static void formatNanpNumber(Editable text)",
    "returnType" : "void",
    "comment" : "\n     * Formats a phone number in-place using the NANP formatting rules. Numbers will be formatted\n     * as:\n     *\n     * <p><code>\n     * xxxxx\n     * xxx-xxxx\n     * xxx-xxx-xxxx\n     * 1-xxx-xxx-xxxx\n     * +1-xxx-xxx-xxxx\n     * </code></p>\n     *\n     * @param text the number to be formatted, will be modified with the formatting\n     *\n     * @deprecated Use link #formatNumber(String phoneNumber, String defaultCountryIso) instead\n     ",
    "links" : [ ]
  }, {
    "name" : "public static void formatJapaneseNumber(Editable text)",
    "returnType" : "void",
    "comment" : "\n     * Formats a phone number in-place using the Japanese formatting rules.\n     * Numbers will be formatted as:\n     *\n     * <p><code>\n     * 03-xxxx-xxxx\n     * 090-xxxx-xxxx\n     * 0120-xxx-xxx\n     * +81-3-xxxx-xxxx\n     * +81-90-xxxx-xxxx\n     * </code></p>\n     *\n     * @param text the number to be formatted, will be modified with\n     * the formatting\n     *\n     * @deprecated Use link #formatNumber(String phoneNumber, String defaultCountryIso) instead\n     ",
    "links" : [ ]
  }, {
    "name" : "private static void removeDashes(Editable text)",
    "returnType" : "void",
    "comment" : "\n     * Removes all dashes from the number.\n     *\n     * @param text the number to clear from dashes\n     ",
    "links" : [ ]
  }, {
    "name" : "public static String formatNumberToE164(String phoneNumber, String defaultCountryIso)",
    "returnType" : "String",
    "comment" : "\n     * Formats the specified {@code phoneNumber} to the E.164 representation.\n     *\n     * @param phoneNumber the phone number to format.\n     * @param defaultCountryIso the ISO 3166-1 two letters country code.\n     * @return the E.164 representation, or null if the given phone number is not valid.\n     ",
    "links" : [ ]
  }, {
    "name" : "public static String formatNumberToRFC3966(String phoneNumber, String defaultCountryIso)",
    "returnType" : "String",
    "comment" : "\n     * Formats the specified {@code phoneNumber} to the RFC3966 representation.\n     *\n     * @param phoneNumber the phone number to format.\n     * @param defaultCountryIso the ISO 3166-1 two letters country code.\n     * @return the RFC3966 representation, or null if the given phone number is not valid.\n     ",
    "links" : [ ]
  }, {
    "name" : "private static String formatNumberInternal(String rawPhoneNumber, String defaultCountryIso, PhoneNumberFormat formatIdentifier)",
    "returnType" : "String",
    "comment" : "\n     * Formats the raw phone number (string) using the specified {@code formatIdentifier}.\n     * <p>\n     * The given phone number must have an area code and could have a country code.\n     * <p>\n     * The defaultCountryIso is used to validate the given number and generate the formatted number\n     * if the specified number doesn't have a country code.\n     *\n     * @param rawPhoneNumber The phone number to format.\n     * @param defaultCountryIso The ISO 3166-1 two letters country code.\n     * @param formatIdentifier The (enum) identifier of the desired format.\n     * @return the formatted representation, or null if the specified number is not valid.\n     ",
    "links" : [ ]
  }, {
    "name" : "public static boolean isInternationalNumber(String phoneNumber, String defaultCountryIso)",
    "returnType" : "boolean",
    "comment" : "\n     * Determines if a {@param phoneNumber} is international if dialed from\n     * {@param defaultCountryIso}.\n     *\n     * @param phoneNumber The phone number.\n     * @param defaultCountryIso The current country ISO.\n     * @return {@code true} if the number is international, {@code false} otherwise.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public static String formatNumber(String phoneNumber, String defaultCountryIso)",
    "returnType" : "String",
    "comment" : "\n     * Format a phone number.\n     * <p>\n     * If the given number doesn't have the country code, the phone will be\n     * formatted to the default country's convention.\n     *\n     * @param phoneNumber\n     *            the number to be formatted.\n     * @param defaultCountryIso\n     *            the ISO 3166-1 two letters country code whose convention will\n     *            be used if the given number doesn't have the country code.\n     * @return the formatted number, or null if the given number is not valid.\n     ",
    "links" : [ ]
  }, {
    "name" : "public static String formatNumber(String phoneNumber, String phoneNumberE164, String defaultCountryIso)",
    "returnType" : "String",
    "comment" : "\n     * Format the phone number only if the given number hasn't been formatted.\n     * <p>\n     * The number which has only dailable character is treated as not being\n     * formatted.\n     *\n     * @param phoneNumber\n     *            the number to be formatted.\n     * @param phoneNumberE164\n     *            the E164 format number whose country code is used if the given\n     *            phoneNumber doesn't have the country code.\n     * @param defaultCountryIso\n     *            the ISO 3166-1 two letters country code whose convention will\n     *            be used if the phoneNumberE164 is null or invalid, or if phoneNumber\n     *            contains IDD.\n     * @return the formatted number if the given number has been formatted,\n     *            otherwise, return the given number.\n     ",
    "links" : [ ]
  }, {
    "name" : "public static String normalizeNumber(String phoneNumber)",
    "returnType" : "String",
    "comment" : "\n     * Normalize a phone number by removing the characters other than digits. If\n     * the given number has keypad letters, the letters will be converted to\n     * digits first.\n     *\n     * @param phoneNumber the number to be normalized.\n     * @return the normalized number.\n     ",
    "links" : [ ]
  }, {
    "name" : "public static String replaceUnicodeDigits(String number)",
    "returnType" : "String",
    "comment" : "\n     * Replaces all unicode(e.g. Arabic, Persian) digits with their decimal digit equivalents.\n     *\n     * @param number the number to perform the replacement on.\n     * @return the replaced number.\n     ",
    "links" : [ ]
  }, {
    "name" : "public static boolean isEmergencyNumber(String number)",
    "returnType" : "boolean",
    "comment" : "\n     * Checks a given number against the list of\n     * emergency numbers provided by the RIL and SIM card.\n     *\n     * @param number the number to look up.\n     * @return true if the number is in the list of emergency numbers\n     *         listed in the RIL / SIM, otherwise return false.\n     *\n     * @deprecated Please use {@link TelephonyManager#isEmergencyNumber(String)} instead.\n     ",
    "links" : [ "TelephonyManager#isEmergencyNumber" ]
  }, {
    "name" : "public static boolean isEmergencyNumber(int subId, String number)",
    "returnType" : "boolean",
    "comment" : "\n     * Checks a given number against the list of\n     * emergency numbers provided by the RIL and SIM card.\n     *\n     * @param subId the subscription id of the SIM.\n     * @param number the number to look up.\n     * @return true if the number is in the list of emergency numbers\n     *         listed in the RIL / SIM, otherwise return false.\n     *\n     * @deprecated Please use {@link TelephonyManager#isEmergencyNumber(String)}\n     *             instead.\n     *\n     * @hide\n     ",
    "links" : [ "TelephonyManager#isEmergencyNumber" ]
  }, {
    "name" : "public static boolean isPotentialEmergencyNumber(String number)",
    "returnType" : "boolean",
    "comment" : "\n     * Checks if given number might *potentially* result in\n     * a call to an emergency service on the current network.\n     *\n     * Specifically, this method will return true if the specified number\n     * is an emergency number according to the list managed by the RIL or\n     * SIM, *or* if the specified number simply starts with the same\n     * digits as any of the emergency numbers listed in the RIL / SIM.\n     *\n     * This method is intended for internal use by the phone app when\n     * deciding whether to allow ACTION_CALL intents from 3rd party apps\n     * (where we're required to *not* allow emergency calls to be placed.)\n     *\n     * @param number the number to look up.\n     * @return true if the number is in the list of emergency numbers\n     *         listed in the RIL / SIM, *or* if the number starts with the\n     *         same digits as any of those emergency numbers.\n     *\n     * @deprecated Please use {@link TelephonyManager#isPotentialEmergencyNumber(String)}\n     *             instead.\n     *\n     * @hide\n     ",
    "links" : [ "TelephonyManager#isPotentialEmergencyNumber" ]
  }, {
    "name" : "public static boolean isPotentialEmergencyNumber(int subId, String number)",
    "returnType" : "boolean",
    "comment" : "\n     * Checks if given number might *potentially* result in\n     * a call to an emergency service on the current network.\n     *\n     * Specifically, this method will return true if the specified number\n     * is an emergency number according to the list managed by the RIL or\n     * SIM, *or* if the specified number simply starts with the same\n     * digits as any of the emergency numbers listed in the RIL / SIM.\n     *\n     * This method is intended for internal use by the phone app when\n     * deciding whether to allow ACTION_CALL intents from 3rd party apps\n     * (where we're required to *not* allow emergency calls to be placed.)\n     *\n     * @param subId the subscription id of the SIM.\n     * @param number the number to look up.\n     * @return true if the number is in the list of emergency numbers\n     *         listed in the RIL / SIM, *or* if the number starts with the\n     *         same digits as any of those emergency numbers.\n     *\n     * @deprecated Please use {@link TelephonyManager#isPotentialEmergencyNumber(String)}\n     *             instead.\n     *\n     * @hide\n     ",
    "links" : [ "TelephonyManager#isPotentialEmergencyNumber" ]
  }, {
    "name" : "private static boolean isEmergencyNumberInternal(String number, boolean useExactMatch)",
    "returnType" : "boolean",
    "comment" : "\n     * Helper function for isEmergencyNumber(String) and\n     * isPotentialEmergencyNumber(String).\n     *\n     * @param number the number to look up.\n     *\n     * @param useExactMatch if true, consider a number to be an emergency\n     *           number only if it *exactly* matches a number listed in\n     *           the RIL / SIM.  If false, a number is considered to be an\n     *           emergency number if it simply starts with the same digits\n     *           as any of the emergency numbers listed in the RIL / SIM.\n     *           (Setting useExactMatch to false allows you to identify\n     *           number that could *potentially* result in emergency calls\n     *           since many networks will actually ignore trailing digits\n     *           after a valid emergency number.)\n     *\n     * @return true if the number is in the list of emergency numbers\n     *         listed in the RIL / sim, otherwise return false.\n     ",
    "links" : [ ]
  }, {
    "name" : "private static boolean isEmergencyNumberInternal(int subId, String number, boolean useExactMatch)",
    "returnType" : "boolean",
    "comment" : "\n     * Helper function for isEmergencyNumber(String) and\n     * isPotentialEmergencyNumber(String).\n     *\n     * @param subId the subscription id of the SIM.\n     * @param number the number to look up.\n     *\n     * @param useExactMatch if true, consider a number to be an emergency\n     *           number only if it *exactly* matches a number listed in\n     *           the RIL / SIM.  If false, a number is considered to be an\n     *           emergency number if it simply starts with the same digits\n     *           as any of the emergency numbers listed in the RIL / SIM.\n     *           (Setting useExactMatch to false allows you to identify\n     *           number that could *potentially* result in emergency calls\n     *           since many networks will actually ignore trailing digits\n     *           after a valid emergency number.)\n     *\n     * @return true if the number is in the list of emergency numbers\n     *         listed in the RIL / sim, otherwise return false.\n     ",
    "links" : [ ]
  }, {
    "name" : "public static boolean isEmergencyNumber(String number, String defaultCountryIso)",
    "returnType" : "boolean",
    "comment" : "\n     * Checks if a given number is an emergency number for a specific country.\n     *\n     * @param number the number to look up.\n     * @param defaultCountryIso the specific country which the number should be checked against\n     * @return if the number is an emergency number for the specific country, then return true,\n     * otherwise false\n     *\n     * @deprecated Please use {@link TelephonyManager#isEmergencyNumber(String)}\n     *             instead.\n     *\n     * @hide\n     ",
    "links" : [ "TelephonyManager#isEmergencyNumber" ]
  }, {
    "name" : "public static boolean isEmergencyNumber(int subId, String number, String defaultCountryIso)",
    "returnType" : "boolean",
    "comment" : "\n     * Checks if a given number is an emergency number for a specific country.\n     *\n     * @param subId the subscription id of the SIM.\n     * @param number the number to look up.\n     * @param defaultCountryIso the specific country which the number should be checked against\n     * @return if the number is an emergency number for the specific country, then return true,\n     * otherwise false\n     *\n     * @deprecated Please use {@link TelephonyManager#isEmergencyNumber(String)}\n     *             instead.\n     *\n     * @hide\n     ",
    "links" : [ "TelephonyManager#isEmergencyNumber" ]
  }, {
    "name" : "public static boolean isPotentialEmergencyNumber(String number, String defaultCountryIso)",
    "returnType" : "boolean",
    "comment" : "\n     * Checks if a given number might *potentially* result in a call to an\n     * emergency service, for a specific country.\n     *\n     * Specifically, this method will return true if the specified number\n     * is an emergency number in the specified country, *or* if the number\n     * simply starts with the same digits as any emergency number for that\n     * country.\n     *\n     * This method is intended for internal use by the phone app when\n     * deciding whether to allow ACTION_CALL intents from 3rd party apps\n     * (where we're required to *not* allow emergency calls to be placed.)\n     *\n     * @param number the number to look up.\n     * @param defaultCountryIso the specific country which the number should be checked against\n     * @return true if the number is an emergency number for the specific\n     *         country, *or* if the number starts with the same digits as\n     *         any of those emergency numbers.\n     *\n     * @deprecated Please use {@link TelephonyManager#isPotentialEmergencyNumber(String)}\n     *             instead.\n     *\n     * @hide\n     ",
    "links" : [ "TelephonyManager#isPotentialEmergencyNumber" ]
  }, {
    "name" : "public static boolean isPotentialEmergencyNumber(int subId, String number, String defaultCountryIso)",
    "returnType" : "boolean",
    "comment" : "\n     * Checks if a given number might *potentially* result in a call to an\n     * emergency service, for a specific country.\n     *\n     * Specifically, this method will return true if the specified number\n     * is an emergency number in the specified country, *or* if the number\n     * simply starts with the same digits as any emergency number for that\n     * country.\n     *\n     * This method is intended for internal use by the phone app when\n     * deciding whether to allow ACTION_CALL intents from 3rd party apps\n     * (where we're required to *not* allow emergency calls to be placed.)\n     *\n     * @param subId the subscription id of the SIM.\n     * @param number the number to look up.\n     * @param defaultCountryIso the specific country which the number should be checked against\n     * @return true if the number is an emergency number for the specific\n     *         country, *or* if the number starts with the same digits as\n     *         any of those emergency numbers.\n     *\n     * @deprecated Please use {@link TelephonyManager#isPotentialEmergencyNumber(String)}\n     *             instead.\n     *\n     * @hide\n     ",
    "links" : [ "TelephonyManager#isPotentialEmergencyNumber" ]
  }, {
    "name" : "private static boolean isEmergencyNumberInternal(String number, String defaultCountryIso, boolean useExactMatch)",
    "returnType" : "boolean",
    "comment" : "\n     * Helper function for isEmergencyNumber(String, String) and\n     * isPotentialEmergencyNumber(String, String).\n     *\n     * @param number the number to look up.\n     * @param defaultCountryIso the specific country which the number should be checked against\n     * @param useExactMatch if true, consider a number to be an emergency\n     *           number only if it *exactly* matches a number listed in\n     *           the RIL / SIM.  If false, a number is considered to be an\n     *           emergency number if it simply starts with the same digits\n     *           as any of the emergency numbers listed in the RIL / SIM.\n     *\n     * @return true if the number is an emergency number for the specified country.\n     ",
    "links" : [ ]
  }, {
    "name" : "private static boolean isEmergencyNumberInternal(int subId, String number, String defaultCountryIso, boolean useExactMatch)",
    "returnType" : "boolean",
    "comment" : "\n     * Helper function for isEmergencyNumber(String, String) and\n     * isPotentialEmergencyNumber(String, String).\n     *\n     * @param subId the subscription id of the SIM.\n     * @param number the number to look up.\n     * @param defaultCountryIso the specific country which the number should be checked against\n     * @param useExactMatch if true, consider a number to be an emergency\n     *           number only if it *exactly* matches a number listed in\n     *           the RIL / SIM.  If false, a number is considered to be an\n     *           emergency number if it simply starts with the same digits\n     *           as any of the emergency numbers listed in the RIL / SIM.\n     *\n     * @return true if the number is an emergency number for the specified country.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public static boolean isLocalEmergencyNumber(Context context, String number)",
    "returnType" : "boolean",
    "comment" : "\n     * Checks if a given number is an emergency number for the country that the user is in.\n     *\n     * @param number the number to look up.\n     * @param context the specific context which the number should be checked against\n     * @return true if the specified number is an emergency number for the country the user\n     * is currently in.\n     *\n     * @deprecated Please use {@link TelephonyManager#isEmergencyNumber(String)}\n     *             instead.\n     ",
    "links" : [ "TelephonyManager#isEmergencyNumber" ]
  }, {
    "name" : "public static boolean isLocalEmergencyNumber(Context context, int subId, String number)",
    "returnType" : "boolean",
    "comment" : "\n     * Checks if a given number is an emergency number for the country that the user is in.\n     *\n     * @param subId the subscription id of the SIM.\n     * @param number the number to look up.\n     * @param context the specific context which the number should be checked against\n     * @return true if the specified number is an emergency number for the country the user\n     * is currently in.\n     *\n     * @deprecated Please use {@link TelephonyManager#isEmergencyNumber(String)}\n     *             instead.\n     *\n     * @hide\n     ",
    "links" : [ "TelephonyManager#isEmergencyNumber" ]
  }, {
    "name" : "public static boolean isPotentialLocalEmergencyNumber(Context context, String number)",
    "returnType" : "boolean",
    "comment" : "\n     * Checks if a given number might *potentially* result in a call to an\n     * emergency service, for the country that the user is in. The current\n     * country is determined using the CountryDetector.\n     *\n     * Specifically, this method will return true if the specified number\n     * is an emergency number in the current country, *or* if the number\n     * simply starts with the same digits as any emergency number for the\n     * current country.\n     *\n     * This method is intended for internal use by the phone app when\n     * deciding whether to allow ACTION_CALL intents from 3rd party apps\n     * (where we're required to *not* allow emergency calls to be placed.)\n     *\n     * @param number the number to look up.\n     * @param context the specific context which the number should be checked against\n     * @return true if the specified number is an emergency number for a local country, based on the\n     *              CountryDetector.\n     *\n     * @see android.location.CountryDetector\n     *\n     * @deprecated Please use {@link TelephonyManager#isPotentialEmergencyNumber(String)}\n     *             instead.\n     *\n     * @hide\n     ",
    "links" : [ "TelephonyManager#isPotentialEmergencyNumber" ]
  }, {
    "name" : "public static boolean isPotentialLocalEmergencyNumber(Context context, int subId, String number)",
    "returnType" : "boolean",
    "comment" : "\n     * Checks if a given number might *potentially* result in a call to an\n     * emergency service, for the country that the user is in. The current\n     * country is determined using the CountryDetector.\n     *\n     * Specifically, this method will return true if the specified number\n     * is an emergency number in the current country, *or* if the number\n     * simply starts with the same digits as any emergency number for the\n     * current country.\n     *\n     * This method is intended for internal use by the phone app when\n     * deciding whether to allow ACTION_CALL intents from 3rd party apps\n     * (where we're required to *not* allow emergency calls to be placed.)\n     *\n     * @param subId the subscription id of the SIM.\n     * @param number the number to look up.\n     * @param context the specific context which the number should be checked against\n     * @return true if the specified number is an emergency number for a local country, based on the\n     *              CountryDetector.\n     *\n     * @deprecated Please use {@link TelephonyManager#isPotentialEmergencyNumber(String)}\n     *             instead.\n     *\n     * @hide\n     ",
    "links" : [ "TelephonyManager#isPotentialEmergencyNumber" ]
  }, {
    "name" : "private static boolean isLocalEmergencyNumberInternal(String number, Context context, boolean useExactMatch)",
    "returnType" : "boolean",
    "comment" : "\n     * Helper function for isLocalEmergencyNumber() and\n     * isPotentialLocalEmergencyNumber().\n     *\n     * @param number the number to look up.\n     * @param context the specific context which the number should be checked against\n     * @param useExactMatch if true, consider a number to be an emergency\n     *           number only if it *exactly* matches a number listed in\n     *           the RIL / SIM.  If false, a number is considered to be an\n     *           emergency number if it simply starts with the same digits\n     *           as any of the emergency numbers listed in the RIL / SIM.\n     *\n     * @return true if the specified number is an emergency number for a\n     *              local country, based on the CountryDetector.\n     *\n     * @see android.location.CountryDetector\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "private static boolean isLocalEmergencyNumberInternal(int subId, String number, Context context, boolean useExactMatch)",
    "returnType" : "boolean",
    "comment" : "\n     * Helper function for isLocalEmergencyNumber() and\n     * isPotentialLocalEmergencyNumber().\n     *\n     * @param subId the subscription id of the SIM.\n     * @param number the number to look up.\n     * @param context the specific context which the number should be checked against\n     * @param useExactMatch if true, consider a number to be an emergency\n     *           number only if it *exactly* matches a number listed in\n     *           the RIL / SIM.  If false, a number is considered to be an\n     *           emergency number if it simply starts with the same digits\n     *           as any of the emergency numbers listed in the RIL / SIM.\n     *\n     * @return true if the specified number is an emergency number for a\n     *              local country, based on the CountryDetector.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public static boolean isVoiceMailNumber(String number)",
    "returnType" : "boolean",
    "comment" : "\n     * isVoiceMailNumber: checks a given number against the voicemail\n     *   number provided by the RIL and SIM card. The caller must have\n     *   the READ_PHONE_STATE credential.\n     *\n     * @param number the number to look up.\n     * @return true if the number is in the list of voicemail. False\n     * otherwise, including if the caller does not have the permission\n     * to read the VM number.\n     ",
    "links" : [ ]
  }, {
    "name" : "public static boolean isVoiceMailNumber(int subId, String number)",
    "returnType" : "boolean",
    "comment" : "\n     * isVoiceMailNumber: checks a given number against the voicemail\n     *   number provided by the RIL and SIM card. The caller must have\n     *   the READ_PHONE_STATE credential.\n     *\n     * @param subId the subscription id of the SIM.\n     * @param number the number to look up.\n     * @return true if the number is in the list of voicemail. False\n     * otherwise, including if the caller does not have the permission\n     * to read the VM number.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public static boolean isVoiceMailNumber(@NonNull Context context, int subId, @Nullable String number)",
    "returnType" : "boolean",
    "comment" : "\n     * isVoiceMailNumber: checks a given number against the voicemail\n     *   number provided by the RIL and SIM card. The caller must have\n     *   the READ_PHONE_STATE credential.\n     *\n     * @param context {@link Context}.\n     * @param subId the subscription id of the SIM.\n     * @param number the number to look up.\n     * @return true if the number is in the list of voicemail. False\n     * otherwise, including if the caller does not have the permission\n     * to read the VM number.\n     * @hide\n     ",
    "links" : [ "Context" ]
  }, {
    "name" : "public static String convertKeypadLettersToDigits(String input)",
    "returnType" : "String",
    "comment" : "\n     * Translates any alphabetic letters (i.e. [A-Za-z]) in the\n     * specified phone number into the equivalent numeric digits,\n     * according to the phone keypad letter mapping described in\n     * ITU E.161 and ISO/IEC 9995-8.\n     *\n     * @return the input string, with alpha letters converted to numeric\n     *         digits using the phone keypad letter mapping.  For example,\n     *         an input of \"1-800-GOOG-411\" will return \"1-800-4664-411\".\n     ",
    "links" : [ ]
  }, {
    "name" : "public static String cdmaCheckAndProcessPlusCode(String dialStr)",
    "returnType" : "String",
    "comment" : "\n     * This function checks if there is a plus sign (+) in the passed-in dialing number.\n     * If there is, it processes the plus sign based on the default telephone\n     * numbering plan of the system when the phone is activated and the current\n     * telephone numbering plan of the system that the phone is camped on.\n     * Currently, we only support the case that the default and current telephone\n     * numbering plans are North American Numbering Plan(NANP).\n     *\n     * The passed-in dialStr should only contain the valid format as described below,\n     * 1) the 1st character in the dialStr should be one of the really dialable\n     *    characters listed below\n     *    ISO-LATIN characters 0-9, *, # , +\n     * 2) the dialStr should already strip out the separator characters,\n     *    every character in the dialStr should be one of the non separator characters\n     *    listed below\n     *    ISO-LATIN characters 0-9, *, # , +, WILD, WAIT, PAUSE\n     *\n     * Otherwise, this function returns the dial string passed in\n     *\n     * @param dialStr the original dial string\n     * @return the converted dial string if the current/default countries belong to NANP,\n     * and if there is the \"+\" in the original dial string. Otherwise, the original dial\n     * string returns.\n     *\n     * This API is for CDMA only\n     *\n     * @hide TODO: pending API Council approval\n     ",
    "links" : [ ]
  }, {
    "name" : "public static String cdmaCheckAndProcessPlusCodeForSms(String dialStr)",
    "returnType" : "String",
    "comment" : "\n     * Process phone number for CDMA, converting plus code using the home network number format.\n     * This is used for outgoing SMS messages.\n     *\n     * @param dialStr the original dial string\n     * @return the converted dial string\n     * @hide for internal use\n     ",
    "links" : [ ]
  }, {
    "name" : "public static String cdmaCheckAndProcessPlusCodeByNumberFormat(String dialStr, int currFormat, int defaultFormat)",
    "returnType" : "String",
    "comment" : "\n     * This function should be called from checkAndProcessPlusCode only\n     * And it is used for test purpose also.\n     *\n     * It checks the dial string by looping through the network portion,\n     * post dial portion 1, post dial porting 2, etc. If there is any\n     * plus sign, then process the plus sign.\n     * Currently, this function supports the plus sign conversion within NANP only.\n     * Specifically, it handles the plus sign in the following ways:\n     * 1)+1NANP,remove +, e.g.\n     *   +18475797000 is converted to 18475797000,\n     * 2)+NANP or +non-NANP Numbers,replace + with the current NANP IDP, e.g,\n     *   +8475797000 is converted to 0118475797000,\n     *   +11875767800 is converted to 01111875767800\n     * 3)+1NANP in post dial string(s), e.g.\n     *   8475797000;+18475231753 is converted to 8475797000;18475231753\n     *\n     *\n     * @param dialStr the original dial string\n     * @param currFormat the numbering system of the current country that the phone is camped on\n     * @param defaultFormat the numbering system of the country that the phone is activated on\n     * @return the converted dial string if the current/default countries belong to NANP,\n     * and if there is the \"+\" in the original dial string. Otherwise, the original dial\n     * string returns.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public static CharSequence createTtsSpannable(CharSequence phoneNumber)",
    "returnType" : "CharSequence",
    "comment" : "\n     * Wrap the supplied {@code CharSequence} with a {@code TtsSpan}, annotating it as\n     * containing a phone number in its entirety.\n     *\n     * @param phoneNumber A {@code CharSequence} the entirety of which represents a phone number.\n     * @return A {@code CharSequence} with appropriate annotations.\n     ",
    "links" : [ ]
  }, {
    "name" : "public static void addTtsSpan(Spannable s, int start, int endExclusive)",
    "returnType" : "void",
    "comment" : "\n     * Attach a {@link TtsSpan} to the supplied {@code Spannable} at the indicated location,\n     * annotating that location as containing a phone number.\n     *\n     * @param s A {@code Spannable} to annotate.\n     * @param start The starting character position of the phone number in {@code s}.\n     * @param endExclusive The position after the ending character in the phone number {@code s}.\n     ",
    "links" : [ "TtsSpan" ]
  }, {
    "name" : "public static CharSequence ttsSpanAsPhoneNumber(CharSequence phoneNumber)",
    "returnType" : "CharSequence",
    "comment" : "\n     * Wrap the supplied {@code CharSequence} with a {@code TtsSpan}, annotating it as\n     * containing a phone number in its entirety.\n     *\n     * @param phoneNumber A {@code CharSequence} the entirety of which represents a phone number.\n     * @return A {@code CharSequence} with appropriate annotations.\n     * @deprecated Renamed {@link #createTtsSpannable}.\n     *\n     * @hide\n     ",
    "links" : [ "#createTtsSpannable" ]
  }, {
    "name" : "public static void ttsSpanAsPhoneNumber(Spannable s, int start, int end)",
    "returnType" : "void",
    "comment" : "\n     * Attach a {@link TtsSpan} to the supplied {@code Spannable} at the indicated location,\n     * annotating that location as containing a phone number.\n     *\n     * @param s A {@code Spannable} to annotate.\n     * @param start The starting character position of the phone number in {@code s}.\n     * @param end The ending character position of the phone number in {@code s}.\n     *\n     * @deprecated Renamed {@link #addTtsSpan}.\n     *\n     * @hide\n     ",
    "links" : [ "TtsSpan", "#addTtsSpan" ]
  }, {
    "name" : "public static TtsSpan createTtsSpan(String phoneNumberString)",
    "returnType" : "TtsSpan",
    "comment" : "\n     * Create a {@code TtsSpan} for the supplied {@code String}.\n     *\n     * @param phoneNumberString A {@code String} the entirety of which represents a phone number.\n     * @return A {@code TtsSpan} for {@param phoneNumberString}.\n     ",
    "links" : [ ]
  }, {
    "name" : "private static String splitAtNonNumerics(CharSequence number)",
    "returnType" : "String",
    "comment" : " a digit or the characters * and #, to produce a result like \"20 123 456#\".",
    "links" : [ ]
  }, {
    "name" : "private static String getCurrentIdp(boolean useNanp)",
    "returnType" : "String",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private static boolean isTwoToNine(char c)",
    "returnType" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private static int getFormatTypeFromCountryCode(String country)",
    "returnType" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public static boolean isNanp(String dialStr)",
    "returnType" : "boolean",
    "comment" : "\n     * This function checks if the passed in string conforms to the NANP format\n     * i.e. NXX-NXX-XXXX, N is any digit 2-9 and X is any digit 0-9\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "private static boolean isOneNanp(String dialStr)",
    "returnType" : "boolean",
    "comment" : "\n    * This function checks if the passed in string conforms to 1-NANP format\n    ",
    "links" : [ ]
  }, {
    "name" : "public static boolean isUriNumber(@Nullable String number)",
    "returnType" : "boolean",
    "comment" : "\n     * Determines if the specified number is actually a URI\n     * (i.e. a SIP address) rather than a regular PSTN phone number,\n     * based on whether or not the number contains an \"@\" character.\n     *\n     * @hide\n     * @param number\n     * @return true if number contains @\n     ",
    "links" : [ ]
  }, {
    "name" : "public static String getUsernameFromUriNumber(@NonNull String number)",
    "returnType" : "String",
    "comment" : "\n     * @return the \"username\" part of the specified SIP address,\n     *         i.e. the part before the \"@\" character (or \"%40\").\n     *\n     * @param number SIP address of the form \"username@domainname\"\n     *               (or the URI-escaped equivalent \"username%40domainname\")\n     * @see #isUriNumber\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public static Uri convertSipUriToTelUri(Uri source)",
    "returnType" : "Uri",
    "comment" : "\n     * Given a {@link Uri} with a {@code sip} scheme, attempts to build an equivalent {@code tel}\n     * scheme {@link Uri}.  If the source {@link Uri} does not contain a valid number, or is not\n     * using the {@code sip} scheme, the original {@link Uri} is returned.\n     *\n     * @param source The {@link Uri} to convert.\n     * @return The equivalent {@code tel} scheme {@link Uri}.\n     *\n     * @hide\n     ",
    "links" : [ "Uri", "Uri", "Uri", "Uri", "Uri", "Uri" ]
  }, {
    "name" : "private static String processPlusCode(String networkDialStr, boolean useNanp)",
    "returnType" : "String",
    "comment" : "\n     * This function handles the plus code conversion\n     * If the number format is\n     * 1)+1NANP,remove +,\n     * 2)other than +1NANP, any + numbers,replace + with the current IDP\n     ",
    "links" : [ ]
  }, {
    "name" : "private static int findDialableIndexFromPostDialStr(String postDialStr)",
    "returnType" : "int",
    "comment" : " in the post dial string",
    "links" : [ ]
  }, {
    "name" : "private static String appendPwCharBackToOrigDialStr(int dialableIndex, String origStr, String dialStr)",
    "returnType" : "String",
    "comment" : " dial string based on the dialable index passed in",
    "links" : [ ]
  }, {
    "name" : "private static boolean matchIntlPrefix(String a, int len)",
    "returnType" : "boolean",
    "comment" : " all of a up to len must be an international prefix or\n     *  separators/non-dialing digits\n     ",
    "links" : [ ]
  }, {
    "name" : "private static boolean matchIntlPrefixAndCC(String a, int len)",
    "returnType" : "boolean",
    "comment" : " all of 'a' up to len must be a (+|00|011)country code)\n     *  We're fast and loose with the country code. Any \\d{1,3} matches ",
    "links" : [ ]
  }, {
    "name" : "private static boolean matchTrunkPrefix(String a, int len)",
    "returnType" : "boolean",
    "comment" : " all of 'a' up to len must match non-US trunk prefix ('0') ",
    "links" : [ ]
  }, {
    "name" : "private static boolean isCountryCallingCode(int countryCallingCodeCandidate)",
    "returnType" : "boolean",
    "comment" : "\n     * @return true when input is valid Country Calling Code.\n     ",
    "links" : [ ]
  }, {
    "name" : "private static int tryGetISODigit(char ch)",
    "returnType" : "int",
    "comment" : "\n     * Returns integer corresponding to the input if input \"ch\" is\n     * ISO-LATIN characters 0-9.\n     * Returns -1 otherwise\n     ",
    "links" : [ ]
  }, {
    "name" : "private static CountryCallingCodeAndNewIndex tryGetCountryCallingCodeAndNewIndex(String str, boolean acceptThailandCase)",
    "returnType" : "CountryCallingCodeAndNewIndex",
    "comment" : "\n     * Note that this function does not strictly care the country calling code with\n     * 3 length (like Morocco: +212), assuming it is enough to use the first two\n     * digit to compare two phone numbers.\n     ",
    "links" : [ ]
  }, {
    "name" : "private static int tryGetTrunkPrefixOmittedIndex(String str, int currentIndex)",
    "returnType" : "int",
    "comment" : "\n     * Currently this function simply ignore the first digit assuming it is\n     * trunk prefix. Actually trunk prefix is different in each country.\n     *\n     * e.g.\n     * \"+79161234567\" equals \"89161234567\" (Russian trunk digit is 8)\n     * \"+33123456789\" equals \"0123456789\" (French trunk digit is 0)\n     *\n     ",
    "links" : [ ]
  }, {
    "name" : "private static boolean checkPrefixIsIgnorable(final String str, int forwardIndex, int backwardIndex)",
    "returnType" : "boolean",
    "comment" : "\n     * Return true if the prefix of \"str\" is \"ignorable\". Here, \"ignorable\" means\n     * that \"str\" has only one digit and separator characters. The one digit is\n     * assumed to be trunk prefix.\n     ",
    "links" : [ ]
  }, {
    "name" : "private static int getDefaultVoiceSubId()",
    "returnType" : "int",
    "comment" : "\n     * Returns Default voice subscription Id.\n     ",
    "links" : [ ]
  }, {
    "name" : "public static String convertToEmergencyNumber(Context context, String number)",
    "returnType" : "String",
    "comment" : "\n     * Converts to emergency number based on the conversion map.\n     * The conversion map is declared as config_convert_to_emergency_number_map.\n     *\n     * @param context a context to use for accessing resources\n     * @return The converted emergency number if the number matches conversion map,\n     * otherwise original number.\n     *\n     * @hide\n     ",
    "links" : [ ]
  } ],
  "variableNames" : [ "BCD_EXTENDED_TYPE_EF_ADN", "BCD_EXTENDED_TYPE_CALLED_PARTY", "PAUSE", "WAIT", "WILD", "CLIR_ON", "CLIR_OFF", "TOA_International", "TOA_Unknown", "LOG_TAG", "DBG", "BCD_EF_ADN_EXTENDED", "BCD_CALLED_PARTY_EXTENDED", "GLOBAL_PHONE_NUMBER_PATTERN", "sMinMatch", "FORMAT_UNKNOWN", "FORMAT_NANP", "FORMAT_JAPAN", "NANP_COUNTRIES", "KOREA_ISO_COUNTRY_CODE", "JAPAN_ISO_COUNTRY_CODE", "NANP_STATE_DIGIT", "NANP_STATE_PLUS", "NANP_STATE_ONE", "NANP_STATE_DASH", "KEYPAD_MAP", "PLUS_SIGN_CHAR", "PLUS_SIGN_STRING", "NANP_IDP_STRING", "NANP_LENGTH", "COUNTRY_CALLING_CALL", "CCC_LENGTH", "sConvertToEmergencyMap" ],
  "methodNames" : [ "public static boolean isISODigit(char c)", "public static final boolean is12Key(char c)", "public static final boolean isDialable(char c)", "public static final boolean isReallyDialable(char c)", "public static final boolean isNonSeparator(char c)", "public static final boolean isStartsPostDial(char c)", "private static boolean isPause(char c)", "private static boolean isToneWait(char c)", "private static int getMinMatch()", "public static int getMinMatchForTest()", "public static void setMinMatchForTest(int minMatch)", "private static boolean isSeparator(char ch)", "public static String getNumberFromIntent(Intent intent, Context context)", "public static String extractNetworkPortion(String phoneNumber)", "public static String extractNetworkPortionAlt(String phoneNumber)", "public static String stripSeparators(String phoneNumber)", "public static String convertAndStrip(String phoneNumber)", "public static String convertPreDial(String phoneNumber)", "private static int minPositive(int a, int b)", "private static void log(String msg)", "private static int indexOfLastNetworkChar(String a)", "public static String extractPostDialPortion(String phoneNumber)", "public static boolean compare(String a, String b)", "public static boolean compare(Context context, String a, String b)", "public static boolean compare(String a, String b, boolean useStrictComparation)", "public static boolean compareLoosely(String a, String b)", "public static boolean compareStrictly(String a, String b)", "public static boolean compareStrictly(String a, String b, boolean acceptInvalidCCCPrefix)", "public static String toCallerIDMinMatch(String phoneNumber)", "public static String getStrippedReversed(String phoneNumber)", "private static String internalGetStrippedReversed(String np, int numDigits)", "public static String stringFromStringAndTOA(String s, int TOA)", "public static int toaFromString(String s)", "public static String calledPartyBCDToString(byte[] bytes, int offset, int length)", "public static String calledPartyBCDToString(byte[] bytes, int offset, int length, @BcdExtendType int bcdExtType)", "private static void internalCalledPartyBCDFragmentToString(StringBuilder sb, byte[] bytes, int offset, int length, @BcdExtendType int bcdExtType)", "public static String calledPartyBCDFragmentToString(byte[] bytes, int offset, int length)", "public static String calledPartyBCDFragmentToString(byte[] bytes, int offset, int length, @BcdExtendType int bcdExtType)", "private static char bcdToChar(byte b, @BcdExtendType int bcdExtType)", "private static int charToBCD(char c, @BcdExtendType int bcdExtType)", "public static boolean isWellFormedSmsAddress(String address)", "public static boolean isGlobalPhoneNumber(String phoneNumber)", "private static boolean isDialable(String address)", "private static boolean isNonSeparator(String address)", "public static byte[] networkPortionToCalledPartyBCD(String s)", "public static byte[] networkPortionToCalledPartyBCDWithLength(String s)", "public static byte[] numberToCalledPartyBCD(String number)", "public static byte[] numberToCalledPartyBCD(String number, @BcdExtendType int bcdExtType)", "private static byte[] numberToCalledPartyBCDHelper(String number, boolean includeLength, @BcdExtendType int bcdExtType)", "public static String formatNumber(String source)", "public static String formatNumber(String source, int defaultFormattingType)", "public static int getFormatTypeForLocale(Locale locale)", "public static void formatNumber(Editable text, int defaultFormattingType)", "public static void formatNanpNumber(Editable text)", "public static void formatJapaneseNumber(Editable text)", "private static void removeDashes(Editable text)", "public static String formatNumberToE164(String phoneNumber, String defaultCountryIso)", "public static String formatNumberToRFC3966(String phoneNumber, String defaultCountryIso)", "private static String formatNumberInternal(String rawPhoneNumber, String defaultCountryIso, PhoneNumberFormat formatIdentifier)", "public static boolean isInternationalNumber(String phoneNumber, String defaultCountryIso)", "public static String formatNumber(String phoneNumber, String defaultCountryIso)", "public static String formatNumber(String phoneNumber, String phoneNumberE164, String defaultCountryIso)", "public static String normalizeNumber(String phoneNumber)", "public static String replaceUnicodeDigits(String number)", "public static boolean isEmergencyNumber(String number)", "public static boolean isEmergencyNumber(int subId, String number)", "public static boolean isPotentialEmergencyNumber(String number)", "public static boolean isPotentialEmergencyNumber(int subId, String number)", "private static boolean isEmergencyNumberInternal(String number, boolean useExactMatch)", "private static boolean isEmergencyNumberInternal(int subId, String number, boolean useExactMatch)", "public static boolean isEmergencyNumber(String number, String defaultCountryIso)", "public static boolean isEmergencyNumber(int subId, String number, String defaultCountryIso)", "public static boolean isPotentialEmergencyNumber(String number, String defaultCountryIso)", "public static boolean isPotentialEmergencyNumber(int subId, String number, String defaultCountryIso)", "private static boolean isEmergencyNumberInternal(String number, String defaultCountryIso, boolean useExactMatch)", "private static boolean isEmergencyNumberInternal(int subId, String number, String defaultCountryIso, boolean useExactMatch)", "public static boolean isLocalEmergencyNumber(Context context, String number)", "public static boolean isLocalEmergencyNumber(Context context, int subId, String number)", "public static boolean isPotentialLocalEmergencyNumber(Context context, String number)", "public static boolean isPotentialLocalEmergencyNumber(Context context, int subId, String number)", "private static boolean isLocalEmergencyNumberInternal(String number, Context context, boolean useExactMatch)", "private static boolean isLocalEmergencyNumberInternal(int subId, String number, Context context, boolean useExactMatch)", "public static boolean isVoiceMailNumber(String number)", "public static boolean isVoiceMailNumber(int subId, String number)", "public static boolean isVoiceMailNumber(@NonNull Context context, int subId, @Nullable String number)", "public static String convertKeypadLettersToDigits(String input)", "public static String cdmaCheckAndProcessPlusCode(String dialStr)", "public static String cdmaCheckAndProcessPlusCodeForSms(String dialStr)", "public static String cdmaCheckAndProcessPlusCodeByNumberFormat(String dialStr, int currFormat, int defaultFormat)", "public static CharSequence createTtsSpannable(CharSequence phoneNumber)", "public static void addTtsSpan(Spannable s, int start, int endExclusive)", "public static CharSequence ttsSpanAsPhoneNumber(CharSequence phoneNumber)", "public static void ttsSpanAsPhoneNumber(Spannable s, int start, int end)", "public static TtsSpan createTtsSpan(String phoneNumberString)", "private static String splitAtNonNumerics(CharSequence number)", "private static String getCurrentIdp(boolean useNanp)", "private static boolean isTwoToNine(char c)", "private static int getFormatTypeFromCountryCode(String country)", "public static boolean isNanp(String dialStr)", "private static boolean isOneNanp(String dialStr)", "public static boolean isUriNumber(@Nullable String number)", "public static String getUsernameFromUriNumber(@NonNull String number)", "public static Uri convertSipUriToTelUri(Uri source)", "private static String processPlusCode(String networkDialStr, boolean useNanp)", "private static int findDialableIndexFromPostDialStr(String postDialStr)", "private static String appendPwCharBackToOrigDialStr(int dialableIndex, String origStr, String dialStr)", "private static boolean matchIntlPrefix(String a, int len)", "private static boolean matchIntlPrefixAndCC(String a, int len)", "private static boolean matchTrunkPrefix(String a, int len)", "private static boolean isCountryCallingCode(int countryCallingCodeCandidate)", "private static int tryGetISODigit(char ch)", "private static CountryCallingCodeAndNewIndex tryGetCountryCallingCodeAndNewIndex(String str, boolean acceptThailandCase)", "private static int tryGetTrunkPrefixOmittedIndex(String str, int currentIndex)", "private static boolean checkPrefixIsIgnorable(final String str, int forwardIndex, int backwardIndex)", "private static int getDefaultVoiceSubId()", "public static String convertToEmergencyNumber(Context context, String number)" ]
}