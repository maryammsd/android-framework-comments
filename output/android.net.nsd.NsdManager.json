{
  "filePath" : "/home/maryam/clearblue/files/android-source-35/android/net/nsd/NsdManager.java",
  "packageName" : "android.net.nsd",
  "className" : "NsdManager",
  "comment" : "\n * The Network Service Discovery Manager class provides the API to discover services\n * on a network. As an example, if device A and device B are connected over a Wi-Fi\n * network, a game registered on device A can be discovered by a game on device\n * B. Another example use case is an application discovering printers on the network.\n *\n * <p> The API currently supports DNS based service discovery and discovery is currently\n * limited to a local network over Multicast DNS. DNS service discovery is described at\n * http://files.dns-sd.org/draft-cheshire-dnsext-dns-sd.txt\n *\n * <p> The API is asynchronous, and responses to requests from an application are on listener\n * callbacks on a separate internal thread.\n *\n * <p> There are three main operations the API supports - registration, discovery and resolution.\n * <pre>\n *                          Application start\n *                                 |\n *                                 |\n *                                 |                  onServiceRegistered()\n *                     Register any local services  /\n *                      to be advertised with       \\\n *                       registerService()            onRegistrationFailed()\n *                                 |\n *                                 |\n *                          discoverServices()\n *                                 |\n *                      Maintain a list to track\n *                        discovered services\n *                                 |\n *                                 |--------->\n *                                 |          |\n *                                 |      onServiceFound()\n *                                 |          |\n *                                 |     add service to list\n *                                 |          |\n *                                 |<----------\n *                                 |\n *                                 |--------->\n *                                 |          |\n *                                 |      onServiceLost()\n *                                 |          |\n *                                 |   remove service from list\n *                                 |          |\n *                                 |<----------\n *                                 |\n *                                 |\n *                                 | Connect to a service\n *                                 | from list ?\n *                                 |\n *                          resolveService()\n *                                 |\n *                         onServiceResolved()\n *                                 |\n *                     Establish connection to service\n *                     with the host and port information\n *\n * </pre>\n * An application that needs to advertise itself over a network for other applications to\n * discover it can do so with a call to {@link #registerService}. If Example is a http based\n * application that can provide HTML data to peer services, it can register a name \"Example\"\n * with service type \"_http._tcp\". A successful registration is notified with a callback to\n * {@link RegistrationListener#onServiceRegistered} and a failure to register is notified\n * over {@link RegistrationListener#onRegistrationFailed}\n *\n * <p> A peer application looking for http services can initiate a discovery for \"_http._tcp\"\n * with a call to {@link #discoverServices}. A service found is notified with a callback\n * to {@link DiscoveryListener#onServiceFound} and a service lost is notified on\n * {@link DiscoveryListener#onServiceLost}.\n *\n * <p> Once the peer application discovers the \"Example\" http service, and either needs to read the\n * attributes of the service or wants to receive data from the \"Example\" application, it can\n * initiate a resolve with {@link #resolveService} to resolve the attributes, host, and port\n * details. A successful resolve is notified on {@link ResolveListener#onServiceResolved} and a\n * failure is notified on {@link ResolveListener#onResolveFailed}.\n *\n * Applications can reserve for a service type at\n * http://www.iana.org/form/ports-service. Existing services can be found at\n * http://www.iana.org/assignments/service-names-port-numbers/service-names-port-numbers.xml\n *\n * @see NsdServiceInfo\n ",
  "links" : [ "#onServiceResolved", "#onServiceRegistered", "#onRegistrationFailed", "#discoverServices", "#resolveService", "#onResolveFailed", "#onServiceFound", "#onServiceLost", "#registerService" ],
  "variables" : [ {
    "name" : "TAG",
    "type" : "String",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "DBG",
    "type" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "TYPE_LABEL_REGEX",
    "type" : "String",
    "comment" : "\n     * A regex for the acceptable format of a type or subtype label.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "SUBTYPE_LABEL_REGEX",
    "type" : "String",
    "comment" : "\n     * A regex for the acceptable format of a subtype label.\n     *\n     * As per RFC 6763 7.1, \"Subtype strings are not required to begin with an underscore, though\n     * they often do.\", and \"Subtype strings [...] may be constructed using arbitrary 8-bit data\n     * values.  In many cases these data values may be UTF-8 [RFC3629] representations of text, or\n     * even (as in the example above) plain ASCII [RFC20], but they do not have to be.\".\n     *\n     * This regex is overly conservative as it mandates the underscore and only allows printable\n     * ASCII characters (codes 0x20 to 0x7e, space to tilde), except for comma (0x2c) and dot\n     * (0x2e); so the NsdManager API does not allow everything the RFC allows. This may be revisited\n     * in the future, but using arbitrary bytes makes logging and testing harder, and using other\n     * characters would probably be a bad idea for interoperability for apps.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "TYPE_REGEX",
    "type" : "String",
    "comment" : "\n     * A regex for the acceptable format of a service type specification.\n     *\n     * When it matches, matcher group 1 is an optional leading subtype when using legacy dot syntax\n     * (_subtype._type._tcp). Matcher group 2 is the actual type, and matcher group 3 contains\n     * optional comma-separated subtypes.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "ACTION_NSD_STATE_CHANGED",
    "type" : "String",
    "comment" : "\n     * Broadcast intent action to indicate whether network service discovery is\n     * enabled or disabled. An extra {@link #EXTRA_NSD_STATE} provides the state\n     * information as int.\n     *\n     * @see #EXTRA_NSD_STATE\n     ",
    "links" : [ "#EXTRA_NSD_STATE" ]
  }, {
    "name" : "EXTRA_NSD_STATE",
    "type" : "String",
    "comment" : "\n     * The lookup key for an int that indicates whether network service discovery is enabled\n     * or disabled. Retrieve it with {@link android.content.Intent#getIntExtra(String,int)}.\n     *\n     * @see #NSD_STATE_DISABLED\n     * @see #NSD_STATE_ENABLED\n     ",
    "links" : [ "android.content.Intent#getIntExtra(String" ]
  }, {
    "name" : "NSD_STATE_DISABLED",
    "type" : "int",
    "comment" : " TODO: Deprecate this since NSD service is never disabled.",
    "links" : [ ]
  }, {
    "name" : "NSD_STATE_ENABLED",
    "type" : "int",
    "comment" : "\n     * Network service discovery is enabled\n     *\n     * @see #ACTION_NSD_STATE_CHANGED\n     ",
    "links" : [ ]
  }, {
    "name" : "DISCOVER_SERVICES",
    "type" : "int",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "DISCOVER_SERVICES_STARTED",
    "type" : "int",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "DISCOVER_SERVICES_FAILED",
    "type" : "int",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "SERVICE_FOUND",
    "type" : "int",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "SERVICE_LOST",
    "type" : "int",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "STOP_DISCOVERY",
    "type" : "int",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "STOP_DISCOVERY_FAILED",
    "type" : "int",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "STOP_DISCOVERY_SUCCEEDED",
    "type" : "int",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "REGISTER_SERVICE",
    "type" : "int",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "REGISTER_SERVICE_FAILED",
    "type" : "int",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "REGISTER_SERVICE_SUCCEEDED",
    "type" : "int",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "UNREGISTER_SERVICE",
    "type" : "int",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "UNREGISTER_SERVICE_FAILED",
    "type" : "int",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "UNREGISTER_SERVICE_SUCCEEDED",
    "type" : "int",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "RESOLVE_SERVICE",
    "type" : "int",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "RESOLVE_SERVICE_FAILED",
    "type" : "int",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "RESOLVE_SERVICE_SUCCEEDED",
    "type" : "int",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "DAEMON_CLEANUP",
    "type" : "int",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "DAEMON_STARTUP",
    "type" : "int",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "MDNS_SERVICE_EVENT",
    "type" : "int",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "REGISTER_CLIENT",
    "type" : "int",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "UNREGISTER_CLIENT",
    "type" : "int",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "MDNS_DISCOVERY_MANAGER_EVENT",
    "type" : "int",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "STOP_RESOLUTION",
    "type" : "int",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "STOP_RESOLUTION_FAILED",
    "type" : "int",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "STOP_RESOLUTION_SUCCEEDED",
    "type" : "int",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "REGISTER_SERVICE_CALLBACK",
    "type" : "int",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "REGISTER_SERVICE_CALLBACK_FAILED",
    "type" : "int",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "SERVICE_UPDATED",
    "type" : "int",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "SERVICE_UPDATED_LOST",
    "type" : "int",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "UNREGISTER_SERVICE_CALLBACK",
    "type" : "int",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "UNREGISTER_SERVICE_CALLBACK_SUCCEEDED",
    "type" : "int",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "REGISTER_OFFLOAD_ENGINE",
    "type" : "int",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "UNREGISTER_OFFLOAD_ENGINE",
    "type" : "int",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "PROTOCOL_DNS_SD",
    "type" : "int",
    "comment" : " Dns based service discovery protocol ",
    "links" : [ ]
  }, {
    "name" : "TTL_SECONDS_MIN",
    "type" : "long",
    "comment" : "\n     * The minimum TTL seconds which is allowed for a service registration.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "TTL_SECONDS_MAX",
    "type" : "long",
    "comment" : "\n     * The maximum TTL seconds which is allowed for a service registration.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "EVENT_NAMES",
    "type" : "SparseArray<String>",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "FIRST_LISTENER_KEY",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "DNSSEC_PROTOCOL",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mService",
    "type" : "INsdServiceConnector",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mContext",
    "type" : "Context",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mListenerKey",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mListenerMap",
    "type" : "SparseArray",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mServiceMap",
    "type" : "SparseArray<NsdServiceInfo>",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mDiscoveryMap",
    "type" : "SparseArray<DiscoveryRequest>",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mExecutorMap",
    "type" : "SparseArray<Executor>",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mMapLock",
    "type" : "Object",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mPerNetworkDiscoveryMap",
    "type" : "ArrayMap<Integer, PerNetworkDiscoveryTracker>",
    "comment" : " Map of listener key sent by client -> per-network discovery tracker",
    "links" : [ ]
  }, {
    "name" : "mOffloadEngines",
    "type" : "ArrayList<OffloadEngineProxy>",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mHandler",
    "type" : "ServiceHandler",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "FAILURE_INTERNAL_ERROR",
    "type" : "int",
    "comment" : "\n     * Failures are passed with {@link RegistrationListener#onRegistrationFailed},\n     * {@link RegistrationListener#onUnregistrationFailed},\n     * {@link DiscoveryListener#onStartDiscoveryFailed},\n     * {@link DiscoveryListener#onStopDiscoveryFailed} or {@link ResolveListener#onResolveFailed}.\n     *\n     * Indicates that the operation failed due to an internal error.\n     ",
    "links" : [ "#onUnregistrationFailed", "#onStopDiscoveryFailed", "#onRegistrationFailed", "#onResolveFailed", "#onStartDiscoveryFailed" ]
  }, {
    "name" : "FAILURE_ALREADY_ACTIVE",
    "type" : "int",
    "comment" : "\n     * Indicates that the operation failed because it is already active.\n     ",
    "links" : [ ]
  }, {
    "name" : "FAILURE_MAX_LIMIT",
    "type" : "int",
    "comment" : "\n     * Indicates that the operation failed because the maximum outstanding\n     * requests from the applications have reached.\n     ",
    "links" : [ ]
  }, {
    "name" : "FAILURE_OPERATION_NOT_RUNNING",
    "type" : "int",
    "comment" : "\n     * Indicates that the stop operation failed because it is not running.\n     * This failure is passed with {@link ResolveListener#onStopResolutionFailed}.\n     ",
    "links" : [ "#onStopResolutionFailed" ]
  }, {
    "name" : "FAILURE_BAD_PARAMETERS",
    "type" : "int",
    "comment" : "\n     * Indicates that the service has failed to resolve because of bad parameters.\n     *\n     * This failure is passed with\n     * {@link ServiceInfoCallback#onServiceInfoCallbackRegistrationFailed}.\n     ",
    "links" : [ "#onServiceInfoCallbackRegistrationFailed" ]
  } ],
  "methods" : [ {
    "name" : "public static String nameOf(int event)",
    "returnType" : "String",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "public void registerOffloadEngine(@NonNull String ifaceName, @OffloadEngine.OffloadType long offloadType, @OffloadEngine.OffloadCapability long offloadCapability, @NonNull Executor executor, @NonNull OffloadEngine engine)",
    "returnType" : "void",
    "comment" : "\n     * Registers an OffloadEngine with NsdManager.\n     *\n     * A caller can register itself as an OffloadEngine if it supports mDns hardware offload.\n     * The caller must implement the {@link OffloadEngine} interface and update hardware offload\n     * state property when the {@link OffloadEngine#onOffloadServiceUpdated} and\n     * {@link OffloadEngine#onOffloadServiceRemoved} callback are called. Multiple engines may be\n     * registered for the same interface, and that the same engine cannot be registered twice.\n     *\n     * @param ifaceName  indicates which network interface the hardware offload runs on\n     * @param offloadType    the type of offload that the offload engine support\n     * @param offloadCapability    the capabilities of the offload engine\n     * @param executor   the executor on which to receive the offload callbacks\n     * @param engine     the OffloadEngine that will receive the offload callbacks\n     * @throws IllegalStateException if the engine is already registered.\n     *\n     * @hide\n     ",
    "links" : [ "android.net.nsd.OffloadEngine#onOffloadServiceRemoved", "android.net.nsd.OffloadEngine", "android.net.nsd.OffloadEngine#onOffloadServiceUpdated" ]
  }, {
    "name" : "public void unregisterOffloadEngine(@NonNull OffloadEngine engine)",
    "returnType" : "void",
    "comment" : "\n     * Unregisters an OffloadEngine from NsdService.\n     *\n     * A caller can unregister itself as an OffloadEngine when it doesn't want to receive the\n     * callback anymore. The OffloadEngine must have been previously registered with the system\n     * using the {@link NsdManager#registerOffloadEngine} method.\n     *\n     * @param engine OffloadEngine object to be removed from NsdService\n     * @throws IllegalStateException if the engine is not registered.\n     *\n     * @hide\n     ",
    "links" : [ "android.net.nsd.NsdManager#registerOffloadEngine" ]
  }, {
    "name" : "private int nextListenerKey()",
    "returnType" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private int putListener(Object listener, Executor e, NsdServiceInfo serviceInfo)",
    "returnType" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private int putListener(Object listener, Executor e, DiscoveryRequest discoveryRequest)",
    "returnType" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private int putListener(Object listener, Executor e, SparseArray<T> map, T value)",
    "returnType" : "int",
    "comment" : " Assert that the listener is not in the map, then add it and returns its key",
    "links" : [ ]
  }, {
    "name" : "private int updateRegisteredListener(Object listener, Executor e, NsdServiceInfo s)",
    "returnType" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private void removeListener(int key)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private int getListenerKey(Object listener)",
    "returnType" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private static String getNsdServiceInfoType(DiscoveryRequest r)",
    "returnType" : "String",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public void registerService(NsdServiceInfo serviceInfo, int protocolType, RegistrationListener listener)",
    "returnType" : "void",
    "comment" : "\n     * Register a service to be discovered by other services.\n     *\n     * <p> The function call immediately returns after sending a request to register service\n     * to the framework. The application is notified of a successful registration\n     * through the callback {@link RegistrationListener#onServiceRegistered} or a failure\n     * through {@link RegistrationListener#onRegistrationFailed}.\n     *\n     * <p> The application should call {@link #unregisterService} when the service\n     * registration is no longer required, and/or whenever the application is stopped.\n     *\n     * @param serviceInfo The service being registered\n     * @param protocolType The service discovery protocol\n     * @param listener The listener notifies of a successful registration and is used to\n     * unregister this service through a call on {@link #unregisterService}. Cannot be null.\n     * Cannot be in use for an active service registration.\n     ",
    "links" : [ "#onServiceRegistered", "#unregisterService", "#onRegistrationFailed" ]
  }, {
    "name" : "public void registerService(@NonNull NsdServiceInfo serviceInfo, int protocolType, @NonNull Executor executor, @NonNull RegistrationListener listener)",
    "returnType" : "void",
    "comment" : "\n     * Register a service to be discovered by other services.\n     *\n     * <p> The function call immediately returns after sending a request to register service\n     * to the framework. The application is notified of a successful registration\n     * through the callback {@link RegistrationListener#onServiceRegistered} or a failure\n     * through {@link RegistrationListener#onRegistrationFailed}.\n     *\n     * <p> The application should call {@link #unregisterService} when the service\n     * registration is no longer required, and/or whenever the application is stopped.\n     * @param serviceInfo The service being registered\n     * @param protocolType The service discovery protocol\n     * @param executor Executor to run listener callbacks with\n     * @param listener The listener notifies of a successful registration and is used to\n     * unregister this service through a call on {@link #unregisterService}. Cannot be null.\n     ",
    "links" : [ "#onServiceRegistered", "#unregisterService", "#onRegistrationFailed" ]
  }, {
    "name" : "private boolean isSubtypeUpdateRequest(@NonNull NsdServiceInfo serviceInfo, @NonNull RegistrationListener listener)",
    "returnType" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private static Pair<String, String> getTypeAndSubtypes(@Nullable String typeWithSubtype)",
    "returnType" : "Pair<String, String>",
    "comment" : "\n     * Get the base type from a type specification with \"_type._tcp,sub1,sub2\" syntax.\n     *\n     * <p>This rejects specifications using dot syntax to specify subtypes (\"_sub1._type._tcp\").\n     *\n     * @return Type and comma-separated list of subtypes, or null if invalid format.\n     ",
    "links" : [ ]
  }, {
    "name" : "public void registerService(@NonNull AdvertisingRequest advertisingRequest, @NonNull Executor executor, @NonNull RegistrationListener listener)",
    "returnType" : "void",
    "comment" : "    @FlaggedApi(Flags.ADVERTISE_REQUEST_API)",
    "links" : [ ]
  }, {
    "name" : "public void unregisterService(RegistrationListener listener)",
    "returnType" : "void",
    "comment" : "\n     * Unregister a service registered through {@link #registerService}. A successful\n     * unregister is notified to the application with a call to\n     * {@link RegistrationListener#onServiceUnregistered}.\n     *\n     * @param listener This should be the listener object that was passed to\n     * {@link #registerService}. It identifies the service that should be unregistered\n     * and notifies of a successful or unsuccessful unregistration via the listener\n     * callbacks.  In API versions 20 and above, the listener object may be used for\n     * another service registration once the callback has been called.  In API versions <= 19,\n     * there is no entirely reliable way to know when a listener may be re-used, and a new\n     * listener should be created for each service registration request.\n     ",
    "links" : [ "#onServiceUnregistered", "#registerService" ]
  }, {
    "name" : "public void discoverServices(String serviceType, int protocolType, DiscoveryListener listener)",
    "returnType" : "void",
    "comment" : "\n     * Initiate service discovery to browse for instances of a service type. Service discovery\n     * consumes network bandwidth and will continue until the application calls\n     * {@link #stopServiceDiscovery}.\n     *\n     * <p> The function call immediately returns after sending a request to start service\n     * discovery to the framework. The application is notified of a success to initiate\n     * discovery through the callback {@link DiscoveryListener#onDiscoveryStarted} or a failure\n     * through {@link DiscoveryListener#onStartDiscoveryFailed}.\n     *\n     * <p> Upon successful start, application is notified when a service is found with\n     * {@link DiscoveryListener#onServiceFound} or when a service is lost with\n     * {@link DiscoveryListener#onServiceLost}.\n     *\n     * <p> Upon failure to start, service discovery is not active and application does\n     * not need to invoke {@link #stopServiceDiscovery}\n     *\n     * <p> The application should call {@link #stopServiceDiscovery} when discovery of this\n     * service type is no longer required, and/or whenever the application is paused or\n     * stopped.\n     *\n     * @param serviceType The service type being discovered. Examples include \"_http._tcp\" for\n     * http services or \"_ipp._tcp\" for printers\n     * @param protocolType The service discovery protocol\n     * @param listener  The listener notifies of a successful discovery and is used\n     * to stop discovery on this serviceType through a call on {@link #stopServiceDiscovery}.\n     * Cannot be null. Cannot be in use for an active service discovery.\n     ",
    "links" : [ "#stopServiceDiscovery", "#onDiscoveryStarted", "#onServiceFound", "#onServiceLost", "#onStartDiscoveryFailed" ]
  }, {
    "name" : "public void discoverServices(@NonNull String serviceType, int protocolType, @Nullable Network network, @NonNull Executor executor, @NonNull DiscoveryListener listener)",
    "returnType" : "void",
    "comment" : "\n     * Initiate service discovery to browse for instances of a service type. Service discovery\n     * consumes network bandwidth and will continue until the application calls\n     * {@link #stopServiceDiscovery}.\n     *\n     * <p> The function call immediately returns after sending a request to start service\n     * discovery to the framework. The application is notified of a success to initiate\n     * discovery through the callback {@link DiscoveryListener#onDiscoveryStarted} or a failure\n     * through {@link DiscoveryListener#onStartDiscoveryFailed}.\n     *\n     * <p> Upon successful start, application is notified when a service is found with\n     * {@link DiscoveryListener#onServiceFound} or when a service is lost with\n     * {@link DiscoveryListener#onServiceLost}.\n     *\n     * <p> Upon failure to start, service discovery is not active and application does\n     * not need to invoke {@link #stopServiceDiscovery}\n     *\n     * <p> The application should call {@link #stopServiceDiscovery} when discovery of this\n     * service type is no longer required, and/or whenever the application is paused or\n     * stopped.\n     * @param serviceType The service type being discovered. Examples include \"_http._tcp\" for\n     * http services or \"_ipp._tcp\" for printers\n     * @param protocolType The service discovery protocol\n     * @param network Network to discover services on, or null to discover on all available networks\n     * @param executor Executor to run listener callbacks with\n     * @param listener  The listener notifies of a successful discovery and is used\n     * to stop discovery on this serviceType through a call on {@link #stopServiceDiscovery}.\n     ",
    "links" : [ "#stopServiceDiscovery", "#onDiscoveryStarted", "#onServiceFound", "#onServiceLost", "#onStartDiscoveryFailed" ]
  }, {
    "name" : "public void discoverServices(@NonNull DiscoveryRequest discoveryRequest, @NonNull Executor executor, @NonNull DiscoveryListener listener)",
    "returnType" : "void",
    "comment" : "\n     * Initiates service discovery to browse for instances of a service type. Service discovery\n     * consumes network bandwidth and will continue until the application calls\n     * {@link #stopServiceDiscovery}.\n     *\n     * <p> The function call immediately returns after sending a request to start service\n     * discovery to the framework. The application is notified of a success to initiate\n     * discovery through the callback {@link DiscoveryListener#onDiscoveryStarted} or a failure\n     * through {@link DiscoveryListener#onStartDiscoveryFailed}.\n     *\n     * <p> Upon successful start, application is notified when a service is found with\n     * {@link DiscoveryListener#onServiceFound} or when a service is lost with\n     * {@link DiscoveryListener#onServiceLost}.\n     *\n     * <p> Upon failure to start, service discovery is not active and application does\n     * not need to invoke {@link #stopServiceDiscovery}\n     *\n     * <p> The application should call {@link #stopServiceDiscovery} when discovery of this\n     * service type is no longer required, and/or whenever the application is paused or\n     * stopped.\n     *\n     * @param discoveryRequest the {@link DiscoveryRequest} object which specifies the discovery\n     * parameters such as service type, subtype and network\n     * @param executor Executor to run listener callbacks with\n     * @param listener  The listener notifies of a successful discovery and is used\n     * to stop discovery on this serviceType through a call on {@link #stopServiceDiscovery}.\n     ",
    "links" : [ "#stopServiceDiscovery", "#onDiscoveryStarted", "#onServiceFound", "#onServiceLost", "android.net.nsd.DiscoveryRequest", "#onStartDiscoveryFailed" ]
  }, {
    "name" : "public void discoverServices(@NonNull String serviceType, int protocolType, @NonNull NetworkRequest networkRequest, @NonNull Executor executor, @NonNull DiscoveryListener listener)",
    "returnType" : "void",
    "comment" : "\n     * Initiate service discovery to browse for instances of a service type. Service discovery\n     * consumes network bandwidth and will continue until the application calls\n     * {@link #stopServiceDiscovery}.\n     *\n     * <p> The function call immediately returns after sending a request to start service\n     * discovery to the framework. The application is notified of a success to initiate\n     * discovery through the callback {@link DiscoveryListener#onDiscoveryStarted} or a failure\n     * through {@link DiscoveryListener#onStartDiscoveryFailed}.\n     *\n     * <p> Upon successful start, application is notified when a service is found with\n     * {@link DiscoveryListener#onServiceFound} or when a service is lost with\n     * {@link DiscoveryListener#onServiceLost}.\n     *\n     * <p> Upon failure to start, service discovery is not active and application does\n     * not need to invoke {@link #stopServiceDiscovery}\n     *\n     * <p> The application should call {@link #stopServiceDiscovery} when discovery of this\n     * service type is no longer required, and/or whenever the application is paused or\n     * stopped.\n     *\n     * <p> During discovery, new networks may connect or existing networks may disconnect - for\n     * example if wifi is reconnected. When a service was found on a network that disconnects,\n     * {@link DiscoveryListener#onServiceLost} will be called. If a new network connects that\n     * matches the {@link NetworkRequest}, {@link DiscoveryListener#onServiceFound} will be called\n     * for services found on that network. Applications that do not want to track networks\n     * themselves are encouraged to use this method instead of other overloads of\n     * {@code discoverServices}, as they will receive proper notifications when a service becomes\n     * available or unavailable due to network changes.\n     * @param serviceType The service type being discovered. Examples include \"_http._tcp\" for\n     * http services or \"_ipp._tcp\" for printers\n     * @param protocolType The service discovery protocol\n     * @param networkRequest Request specifying networks that should be considered when discovering\n     * @param executor Executor to run listener callbacks with\n     * @param listener  The listener notifies of a successful discovery and is used\n     * to stop discovery on this serviceType through a call on {@link #stopServiceDiscovery}.\n     ",
    "links" : [ "#stopServiceDiscovery", "#onDiscoveryStarted", "#onServiceFound", "#onServiceLost", "android.net.NetworkRequest", "#onStartDiscoveryFailed" ]
  }, {
    "name" : "public void stopServiceDiscovery(DiscoveryListener listener)",
    "returnType" : "void",
    "comment" : "\n     * Stop service discovery initiated with {@link #discoverServices}.  An active service\n     * discovery is notified to the application with {@link DiscoveryListener#onDiscoveryStarted}\n     * and it stays active until the application invokes a stop service discovery. A successful\n     * stop is notified to with a call to {@link DiscoveryListener#onDiscoveryStopped}.\n     *\n     * <p> Upon failure to stop service discovery, application is notified through\n     * {@link DiscoveryListener#onStopDiscoveryFailed}.\n     *\n     * @param listener This should be the listener object that was passed to {@link #discoverServices}.\n     * It identifies the discovery that should be stopped and notifies of a successful or\n     * unsuccessful stop.  In API versions 20 and above, the listener object may be used for\n     * another service discovery once the callback has been called.  In API versions <= 19,\n     * there is no entirely reliable way to know when a listener may be re-used, and a new\n     * listener should be created for each service discovery request.\n     ",
    "links" : [ "#onDiscoveryStopped", "#onStopDiscoveryFailed", "#discoverServices", "#onDiscoveryStarted" ]
  }, {
    "name" : "public void resolveService(NsdServiceInfo serviceInfo, ResolveListener listener)",
    "returnType" : "void",
    "comment" : "\n     * Resolve a discovered service. An application can resolve a service right before\n     * establishing a connection to fetch the IP and port details on which to setup\n     * the connection.\n     *\n     * @param serviceInfo service to be resolved\n     * @param listener to receive callback upon success or failure. Cannot be null.\n     * Cannot be in use for an active service resolution.\n     *\n     * @deprecated the returned ServiceInfo may get stale at any time after resolution, including\n     * immediately after the callback is called, and may not contain some service information that\n     * could be delivered later, like additional host addresses. Prefer using\n     * {@link #registerServiceInfoCallback}, which will keep the application up-to-date with the\n     * state of the service.\n     ",
    "links" : [ "#registerServiceInfoCallback" ]
  }, {
    "name" : "public void resolveService(@NonNull NsdServiceInfo serviceInfo, @NonNull Executor executor, @NonNull ResolveListener listener)",
    "returnType" : "void",
    "comment" : "\n     * Resolve a discovered service. An application can resolve a service right before\n     * establishing a connection to fetch the IP and port details on which to setup\n     * the connection.\n     * @param serviceInfo service to be resolved\n     * @param executor Executor to run listener callbacks with\n     * @param listener to receive callback upon success or failure.\n     *\n     * @deprecated the returned ServiceInfo may get stale at any time after resolution, including\n     * immediately after the callback is called, and may not contain some service information that\n     * could be delivered later, like additional host addresses. Prefer using\n     * {@link #registerServiceInfoCallback}, which will keep the application up-to-date with the\n     * state of the service.\n     ",
    "links" : [ "#registerServiceInfoCallback" ]
  }, {
    "name" : "public void stopServiceResolution(@NonNull ResolveListener listener)",
    "returnType" : "void",
    "comment" : "\n     * Stop service resolution initiated with {@link #resolveService}.\n     *\n     * A successful stop is notified with a call to {@link ResolveListener#onResolutionStopped}.\n     *\n     * <p> Upon failure to stop service resolution for example if resolution is done or the\n     * requester stops resolution repeatedly, the application is notified\n     * {@link ResolveListener#onStopResolutionFailed} with {@link #FAILURE_OPERATION_NOT_RUNNING}\n     *\n     * @param listener This should be a listener object that was passed to {@link #resolveService}.\n     *                 It identifies the resolution that should be stopped and notifies of a\n     *                 successful or unsuccessful stop. Throws {@code IllegalArgumentException} if\n     *                 the listener was not passed to resolveService before.\n     ",
    "links" : [ "#onResolutionStopped", "#resolveService", "#FAILURE_OPERATION_NOT_RUNNING", "#onStopResolutionFailed" ]
  }, {
    "name" : "public void registerServiceInfoCallback(@NonNull NsdServiceInfo serviceInfo, @NonNull Executor executor, @NonNull ServiceInfoCallback listener)",
    "returnType" : "void",
    "comment" : " TODO: use {@link DiscoveryRequest} to specify the service to be subscribed",
    "links" : [ "android.net.nsd.DiscoveryRequest" ]
  }, {
    "name" : "public void unregisterServiceInfoCallback(@NonNull ServiceInfoCallback listener)",
    "returnType" : "void",
    "comment" : "\n     * Unregister a callback registered with {@link #registerServiceInfoCallback}.\n     *\n     * A successful unregistration is notified with a call to\n     * {@link ServiceInfoCallback#onServiceInfoCallbackUnregistered}. The same callback can only be\n     * reused after this is called.\n     *\n     * <p>If the callback is not already registered, this will throw with\n     * {@link IllegalArgumentException}.\n     *\n     * @param listener This should be a listener object that was passed to\n     *                 {@link #registerServiceInfoCallback}. It identifies the registration that\n     *                 should be unregistered and notifies of a successful or unsuccessful stop.\n     *                 Throws {@code IllegalArgumentException} if the listener was not passed to\n     *                 {@link #registerServiceInfoCallback} before.\n     ",
    "links" : [ "#onServiceInfoCallbackUnregistered", "IllegalArgumentException", "#registerServiceInfoCallback" ]
  }, {
    "name" : "private static void checkListener(Object listener)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : " static void checkProtocol(int protocolType)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private static void checkServiceInfoForResolution(NsdServiceInfo serviceInfo)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private static ServiceValidationType validateService(NsdServiceInfo serviceInfo)",
    "returnType" : "ServiceValidationType",
    "comment" : "\n     * Check if the service is valid for registration and classify it as one of {@link\n     * ServiceValidationType}.\n     ",
    "links" : [ "ServiceValidationType" ]
  }, {
    "name" : "private static HostValidationType validateHost(NsdServiceInfo serviceInfo)",
    "returnType" : "HostValidationType",
    "comment" : "\n     * Check if the host is valid for registration and classify it as one of {@link\n     * HostValidationType}.\n     ",
    "links" : [ "HostValidationType" ]
  }, {
    "name" : "private static PublicKeyValidationType validatePublicKey(NsdServiceInfo serviceInfo)",
    "returnType" : "PublicKeyValidationType",
    "comment" : "\n     * Check if the public key is valid for registration and classify it as one of {@link\n     * PublicKeyValidationType}.\n     *\n     * <p>For simplicity, it only checks if the protocol is DNSSEC and the RDATA is not fewer than 4\n     * bytes. See RFC 3445 Section 3.\n     ",
    "links" : [ "PublicKeyValidationType" ]
  }, {
    "name" : "public static void checkServiceInfoForRegistration(NsdServiceInfo serviceInfo)",
    "returnType" : "void",
    "comment" : "\n     * Check if the {@link NsdServiceInfo} is valid for registration.\n     *\n     * <p>Firstly, check if service, host and public key are all valid respectively. Then check if\n     * the combination of service, host and public key is valid.\n     *\n     * <p>If the {@code serviceInfo} is invalid, throw an {@link IllegalArgumentException}\n     * describing the reason.\n     *\n     * <p>There are the invalid combinations of service, host and public key:\n     *\n     * <ul>\n     *   <li>Neither service nor host is specified.\n     *   <li>No public key is specified and the service has a zero port.\n     *   <li>The registration only contains the hostname but addresses are missing.\n     * </ul>\n     *\n     * <p>Keys are used to reserve hostnames or service names while the service/host is temporarily\n     * inactive, so registrations with a key and just a hostname or a service name are acceptable.\n     *\n     * @hide\n     ",
    "links" : [ "android.net.nsd.NsdServiceInfo", "IllegalArgumentException" ]
  } ],
  "methodNames" : [ "public static String nameOf(int event)", "public void registerOffloadEngine(@NonNull String ifaceName, @OffloadEngine.OffloadType long offloadType, @OffloadEngine.OffloadCapability long offloadCapability, @NonNull Executor executor, @NonNull OffloadEngine engine)", "public void unregisterOffloadEngine(@NonNull OffloadEngine engine)", "private int nextListenerKey()", "private int putListener(Object listener, Executor e, NsdServiceInfo serviceInfo)", "private int putListener(Object listener, Executor e, DiscoveryRequest discoveryRequest)", "private int putListener(Object listener, Executor e, SparseArray<T> map, T value)", "private int updateRegisteredListener(Object listener, Executor e, NsdServiceInfo s)", "private void removeListener(int key)", "private int getListenerKey(Object listener)", "private static String getNsdServiceInfoType(DiscoveryRequest r)", "public void registerService(NsdServiceInfo serviceInfo, int protocolType, RegistrationListener listener)", "public void registerService(@NonNull NsdServiceInfo serviceInfo, int protocolType, @NonNull Executor executor, @NonNull RegistrationListener listener)", "private boolean isSubtypeUpdateRequest(@NonNull NsdServiceInfo serviceInfo, @NonNull RegistrationListener listener)", "private static Pair<String, String> getTypeAndSubtypes(@Nullable String typeWithSubtype)", "public void registerService(@NonNull AdvertisingRequest advertisingRequest, @NonNull Executor executor, @NonNull RegistrationListener listener)", "public void unregisterService(RegistrationListener listener)", "public void discoverServices(String serviceType, int protocolType, DiscoveryListener listener)", "public void discoverServices(@NonNull String serviceType, int protocolType, @Nullable Network network, @NonNull Executor executor, @NonNull DiscoveryListener listener)", "public void discoverServices(@NonNull DiscoveryRequest discoveryRequest, @NonNull Executor executor, @NonNull DiscoveryListener listener)", "public void discoverServices(@NonNull String serviceType, int protocolType, @NonNull NetworkRequest networkRequest, @NonNull Executor executor, @NonNull DiscoveryListener listener)", "public void stopServiceDiscovery(DiscoveryListener listener)", "public void resolveService(NsdServiceInfo serviceInfo, ResolveListener listener)", "public void resolveService(@NonNull NsdServiceInfo serviceInfo, @NonNull Executor executor, @NonNull ResolveListener listener)", "public void stopServiceResolution(@NonNull ResolveListener listener)", "public void registerServiceInfoCallback(@NonNull NsdServiceInfo serviceInfo, @NonNull Executor executor, @NonNull ServiceInfoCallback listener)", "public void unregisterServiceInfoCallback(@NonNull ServiceInfoCallback listener)", "private static void checkListener(Object listener)", " static void checkProtocol(int protocolType)", "private static void checkServiceInfoForResolution(NsdServiceInfo serviceInfo)", "private static ServiceValidationType validateService(NsdServiceInfo serviceInfo)", "private static HostValidationType validateHost(NsdServiceInfo serviceInfo)", "private static PublicKeyValidationType validatePublicKey(NsdServiceInfo serviceInfo)", "public static void checkServiceInfoForRegistration(NsdServiceInfo serviceInfo)" ],
  "variableNames" : [ "TAG", "DBG", "TYPE_LABEL_REGEX", "SUBTYPE_LABEL_REGEX", "TYPE_REGEX", "ACTION_NSD_STATE_CHANGED", "EXTRA_NSD_STATE", "NSD_STATE_DISABLED", "NSD_STATE_ENABLED", "DISCOVER_SERVICES", "DISCOVER_SERVICES_STARTED", "DISCOVER_SERVICES_FAILED", "SERVICE_FOUND", "SERVICE_LOST", "STOP_DISCOVERY", "STOP_DISCOVERY_FAILED", "STOP_DISCOVERY_SUCCEEDED", "REGISTER_SERVICE", "REGISTER_SERVICE_FAILED", "REGISTER_SERVICE_SUCCEEDED", "UNREGISTER_SERVICE", "UNREGISTER_SERVICE_FAILED", "UNREGISTER_SERVICE_SUCCEEDED", "RESOLVE_SERVICE", "RESOLVE_SERVICE_FAILED", "RESOLVE_SERVICE_SUCCEEDED", "DAEMON_CLEANUP", "DAEMON_STARTUP", "MDNS_SERVICE_EVENT", "REGISTER_CLIENT", "UNREGISTER_CLIENT", "MDNS_DISCOVERY_MANAGER_EVENT", "STOP_RESOLUTION", "STOP_RESOLUTION_FAILED", "STOP_RESOLUTION_SUCCEEDED", "REGISTER_SERVICE_CALLBACK", "REGISTER_SERVICE_CALLBACK_FAILED", "SERVICE_UPDATED", "SERVICE_UPDATED_LOST", "UNREGISTER_SERVICE_CALLBACK", "UNREGISTER_SERVICE_CALLBACK_SUCCEEDED", "REGISTER_OFFLOAD_ENGINE", "UNREGISTER_OFFLOAD_ENGINE", "PROTOCOL_DNS_SD", "TTL_SECONDS_MIN", "TTL_SECONDS_MAX", "EVENT_NAMES", "FIRST_LISTENER_KEY", "DNSSEC_PROTOCOL", "mService", "mContext", "mListenerKey", "mListenerMap", "mServiceMap", "mDiscoveryMap", "mExecutorMap", "mMapLock", "mPerNetworkDiscoveryMap", "mOffloadEngines", "mHandler", "FAILURE_INTERNAL_ERROR", "FAILURE_ALREADY_ACTIVE", "FAILURE_MAX_LIMIT", "FAILURE_OPERATION_NOT_RUNNING", "FAILURE_BAD_PARAMETERS" ]
}