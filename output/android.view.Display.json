{
  "filePath" : "/home/maryam/clearblue/files/android-source-30/android/view/Display.java",
  "packageName" : "android.view",
  "className" : "Display",
  "comment" : "\n * Provides information about the size and density of a logical display.\n * <p>\n * The display area is described in two different ways.\n * <ul>\n * <li>The application display area specifies the part of the display that may contain\n * an application window, excluding the system decorations.  The application display area may\n * be smaller than the real display area because the system subtracts the space needed\n * for decor elements such as the status bar.  Use {@link WindowMetrics#getBounds()} to query the\n * application window bounds.</li>\n * <li>The real display area specifies the part of the display that contains content\n * including the system decorations.  Even so, the real display area may be smaller than the\n * physical size of the display if the window manager is emulating a smaller display\n * using (adb shell wm size).  Use the following methods to query the\n * real display area: {@link #getRealSize}, {@link #getRealMetrics}.</li>\n * </ul>\n * </p><p>\n * A logical display does not necessarily represent a particular physical display device\n * such as the internal display or an external display.  The contents of a logical\n * display may be presented on one or more physical displays according to the devices\n * that are currently attached and whether mirroring has been enabled.\n * </p>\n ",
  "variables" : [ {
    "name" : "TAG",
    "type" : "String",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "DEBUG",
    "type" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mGlobal",
    "type" : "DisplayManagerGlobal",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mDisplayId",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mLayerStack",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mFlags",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mType",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mAddress",
    "type" : "DisplayAddress",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mOwnerUid",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mOwnerPackageName",
    "type" : "String",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mResources",
    "type" : "Resources",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mDisplayAdjustments",
    "type" : "DisplayAdjustments",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mDisplayInfo",
    "type" : "DisplayInfo",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mIsValid",
    "type" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mTempMetrics",
    "type" : "DisplayMetrics",
    "comment" : " Temporary display metrics structure used for compatibility mode.",
    "links" : [ ]
  }, {
    "name" : "CACHED_APP_SIZE_DURATION_MILLIS",
    "type" : "int",
    "comment" : " Applications should now be using WindowMetrics instead.",
    "links" : [ ]
  }, {
    "name" : "mLastCachedAppSizeUpdate",
    "type" : "long",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mCachedAppWidthCompat",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mCachedAppHeightCompat",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mMayAdjustByFixedRotation",
    "type" : "boolean",
    "comment" : "\n     * Indicates that the application is started in a different rotation than the real display, so\n     * the display information may be adjusted. That ensures the methods {@link #getRotation},\n     * {@link #getRealSize}, {@link #getRealMetrics}, and {@link #getCutout} are consistent with how\n     * the application window is laid out.\n     ",
    "links" : [ "#getRealMetrics", "#getCutout", "#getRealSize", "#getRotation" ]
  }, {
    "name" : "DEFAULT_DISPLAY",
    "type" : "int",
    "comment" : "\n     * The default Display id, which is the id of the primary display assuming there is one.\n     ",
    "links" : [ ]
  }, {
    "name" : "INVALID_DISPLAY",
    "type" : "int",
    "comment" : "\n     * Invalid display id.\n     ",
    "links" : [ ]
  }, {
    "name" : "FLAG_SUPPORTS_PROTECTED_BUFFERS",
    "type" : "int",
    "comment" : "\n     * Display flag: Indicates that the display supports compositing content\n     * that is stored in protected graphics buffers.\n     * <p>\n     * If this flag is set then the display device supports compositing protected buffers.\n     * </p><p>\n     * If this flag is not set then the display device may not support compositing\n     * protected buffers; the user may see a blank region on the screen instead of\n     * the protected content.\n     * </p><p>\n     * Secure (DRM) video decoders may allocate protected graphics buffers to request that\n     * a hardware-protected path be provided between the video decoder and the external\n     * display sink.  If a hardware-protected path is not available, then content stored\n     * in protected graphics buffers may not be composited.\n     * </p><p>\n     * An application can use the absence of this flag as a hint that it should not use protected\n     * buffers for this display because the content may not be visible.  For example,\n     * if the flag is not set then the application may choose not to show content on this\n     * display, show an informative error message, select an alternate content stream\n     * or adopt a different strategy for decoding content that does not rely on\n     * protected buffers.\n     * </p>\n     *\n     * @see #getFlags\n     ",
    "links" : [ ]
  }, {
    "name" : "FLAG_SECURE",
    "type" : "int",
    "comment" : "\n     * Display flag: Indicates that the display has a secure video output and\n     * supports compositing secure surfaces.\n     * <p>\n     * If this flag is set then the display device has a secure video output\n     * and is capable of showing secure surfaces.  It may also be capable of\n     * showing {@link #FLAG_SUPPORTS_PROTECTED_BUFFERS protected buffers}.\n     * </p><p>\n     * If this flag is not set then the display device may not have a secure video\n     * output; the user may see a blank region on the screen instead of\n     * the contents of secure surfaces or protected buffers.\n     * </p><p>\n     * Secure surfaces are used to prevent content rendered into those surfaces\n     * by applications from appearing in screenshots or from being viewed\n     * on non-secure displays.  Protected buffers are used by secure video decoders\n     * for a similar purpose.\n     * </p><p>\n     * An application creates a window with a secure surface by specifying the\n     * {@link WindowManager.LayoutParams#FLAG_SECURE} window flag.\n     * Likewise, an application creates a {@link SurfaceView} with a secure surface\n     * by calling {@link SurfaceView#setSecure} before attaching the secure view to\n     * its containing window.\n     * </p><p>\n     * An application can use the absence of this flag as a hint that it should not create\n     * secure surfaces or protected buffers on this display because the content may\n     * not be visible.  For example, if the flag is not set then the application may\n     * choose not to show content on this display, show an informative error message,\n     * select an alternate content stream or adopt a different strategy for decoding\n     * content that does not rely on secure surfaces or protected buffers.\n     * </p>\n     *\n     * @see #getFlags\n     ",
    "links" : [ "#FLAG_SUPPORTS_PROTECTED_BUFFERS", "android.view.SurfaceView", "WindowManager.LayoutParams#FLAG_SECURE", "android.view.SurfaceView#setSecure" ]
  }, {
    "name" : "FLAG_PRIVATE",
    "type" : "int",
    "comment" : "\n     * Display flag: Indicates that the display is private.  Only the application that\n     * owns the display and apps that are already on the display can create windows on it.\n     *\n     * @see #getFlags\n     ",
    "links" : [ ]
  }, {
    "name" : "FLAG_PRESENTATION",
    "type" : "int",
    "comment" : "\n     * Display flag: Indicates that the display is a presentation display.\n     * <p>\n     * This flag identifies secondary displays that are suitable for\n     * use as presentation displays such as external or wireless displays.  Applications\n     * may automatically project their content to presentation displays to provide\n     * richer second screen experiences.\n     * </p>\n     *\n     * @see #getFlags\n     ",
    "links" : [ ]
  }, {
    "name" : "FLAG_ROUND",
    "type" : "int",
    "comment" : "\n     * Display flag: Indicates that the display has a round shape.\n     * <p>\n     * This flag identifies displays that are circular, elliptical or otherwise\n     * do not permit the user to see all the way to the logical corners of the display.\n     * </p>\n     *\n     * @see #getFlags\n     ",
    "links" : [ ]
  }, {
    "name" : "FLAG_CAN_SHOW_WITH_INSECURE_KEYGUARD",
    "type" : "int",
    "comment" : " TODO (b/114338689): Remove the flag and use IWindowManager#shouldShowWithInsecureKeyguard",
    "links" : [ ]
  }, {
    "name" : "FLAG_SHOULD_SHOW_SYSTEM_DECORATIONS",
    "type" : "int",
    "comment" : " TODO (b/114338689): Remove the flag and use IWindowManager#setShouldShowSystemDecors",
    "links" : [ ]
  }, {
    "name" : "FLAG_TRUSTED",
    "type" : "int",
    "comment" : "\n     * Flag: The display is trusted to show system decorations and receive inputs without users'\n     * touch.\n     * @see #FLAG_SHOULD_SHOW_SYSTEM_DECORATIONS\n     *\n     * @see #getFlags()\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "FLAG_SCALING_DISABLED",
    "type" : "int",
    "comment" : "\n     * Display flag: Indicates that the contents of the display should not be scaled\n     * to fit the physical screen dimensions.  Used for development only to emulate\n     * devices with smaller physicals screens while preserving density.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "TYPE_UNKNOWN",
    "type" : "int",
    "comment" : "\n     * Display type: Unknown display type.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "TYPE_INTERNAL",
    "type" : "int",
    "comment" : "\n     * Display type: Physical display connected through an internal port.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "TYPE_EXTERNAL",
    "type" : "int",
    "comment" : "\n     * Display type: Physical display connected through an external port.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "TYPE_WIFI",
    "type" : "int",
    "comment" : "\n     * Display type: WiFi display.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "TYPE_OVERLAY",
    "type" : "int",
    "comment" : "\n     * Display type: Overlay display.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "TYPE_VIRTUAL",
    "type" : "int",
    "comment" : "\n     * Display type: Virtual display.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "STATE_UNKNOWN",
    "type" : "int",
    "comment" : " 0",
    "links" : [ ]
  }, {
    "name" : "STATE_OFF",
    "type" : "int",
    "comment" : " 1",
    "links" : [ ]
  }, {
    "name" : "STATE_ON",
    "type" : "int",
    "comment" : " 2",
    "links" : [ ]
  }, {
    "name" : "STATE_DOZE",
    "type" : "int",
    "comment" : " 3",
    "links" : [ ]
  }, {
    "name" : "STATE_DOZE_SUSPEND",
    "type" : "int",
    "comment" : " 4",
    "links" : [ ]
  }, {
    "name" : "STATE_VR",
    "type" : "int",
    "comment" : " 5",
    "links" : [ ]
  }, {
    "name" : "STATE_ON_SUSPEND",
    "type" : "int",
    "comment" : " 6",
    "links" : [ ]
  }, {
    "name" : "COLOR_MODE_INVALID",
    "type" : "int",
    "comment" : "\n     * Display color mode: The current color mode is unknown or invalid.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "COLOR_MODE_DEFAULT",
    "type" : "int",
    "comment" : "\n     * Display color mode: The default or native gamut of the display.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "COLOR_MODE_BT601_625",
    "type" : "int",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "COLOR_MODE_BT601_625_UNADJUSTED",
    "type" : "int",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "COLOR_MODE_BT601_525",
    "type" : "int",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "COLOR_MODE_BT601_525_UNADJUSTED",
    "type" : "int",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "COLOR_MODE_BT709",
    "type" : "int",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "COLOR_MODE_DCI_P3",
    "type" : "int",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "COLOR_MODE_SRGB",
    "type" : "int",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "COLOR_MODE_ADOBE_RGB",
    "type" : "int",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "COLOR_MODE_DISPLAY_P3",
    "type" : "int",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "REMOVE_MODE_MOVE_CONTENT_TO_PRIMARY",
    "type" : "int",
    "comment" : " TODO (b/114338689): Remove the flag and use WindowManager#REMOVE_CONTENT_MODE_MOVE_TO_PRIMARY",
    "links" : [ ]
  }, {
    "name" : "REMOVE_MODE_DESTROY_CONTENT",
    "type" : "int",
    "comment" : " TODO (b/114338689): Remove the flag and use WindowManager#REMOVE_CONTENT_MODE_DESTROY",
    "links" : [ ]
  } ],
  "methods" : [ {
    "name" : "public int getDisplayId()",
    "returnType" : "int",
    "comment" : "\n     * Gets the display id.\n     * <p>\n     * Each logical display has a unique id.\n     * The default display has id {@link #DEFAULT_DISPLAY}.\n     * </p>\n     ",
    "links" : [ "#DEFAULT_DISPLAY" ]
  }, {
    "name" : "public String getUniqueId()",
    "returnType" : "String",
    "comment" : "\n     * Gets the display unique id.\n     * <p>\n     * Unique id is different from display id because physical displays have stable unique id across\n     * reboots.\n     *\n     * @see com.android.service.display.DisplayDevice#hasStableUniqueId().\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean isValid()",
    "returnType" : "boolean",
    "comment" : "\n     * Returns true if this display is still valid, false if the display has been removed.\n     *\n     * If the display is invalid, then the methods of this class will\n     * continue to report the most recently observed display information.\n     * However, it is unwise (and rather fruitless) to continue using a\n     * {@link Display} object after the display's demise.\n     *\n     * It's possible for a display that was previously invalid to become\n     * valid again if a display with the same id is reconnected.\n     *\n     * @return True if the display is still valid.\n     ",
    "links" : [ "android.view.Display" ]
  }, {
    "name" : "public boolean getDisplayInfo(DisplayInfo outDisplayInfo)",
    "returnType" : "boolean",
    "comment" : "\n     * Gets a full copy of the display information.\n     *\n     * @param outDisplayInfo The object to receive the copy of the display information.\n     * @return True if the display is still valid.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public int getLayerStack()",
    "returnType" : "int",
    "comment" : "\n     * Gets the display's layer stack.\n     *\n     * Each display has its own independent layer stack upon which surfaces\n     * are placed to be managed by surface flinger.\n     *\n     * @return The display's layer stack number.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public int getFlags()",
    "returnType" : "int",
    "comment" : "\n     * Returns a combination of flags that describe the capabilities of the display.\n     *\n     * @return The display flags.\n     *\n     * @see #FLAG_SUPPORTS_PROTECTED_BUFFERS\n     * @see #FLAG_SECURE\n     * @see #FLAG_PRIVATE\n     * @see #FLAG_ROUND\n     ",
    "links" : [ ]
  }, {
    "name" : "public int getType()",
    "returnType" : "int",
    "comment" : "\n     * Gets the display type.\n     *\n     * @return The display type.\n     *\n     * @see #TYPE_UNKNOWN\n     * @see #TYPE_INTERNAL\n     * @see #TYPE_EXTERNAL\n     * @see #TYPE_WIFI\n     * @see #TYPE_OVERLAY\n     * @see #TYPE_VIRTUAL\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public DisplayAddress getAddress()",
    "returnType" : "DisplayAddress",
    "comment" : "\n     * Gets the display address, or null if none.\n     * Interpretation varies by display type.\n     *\n     * @return The display address.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public int getOwnerUid()",
    "returnType" : "int",
    "comment" : "\n     * Gets the UID of the application that owns this display, or zero if it is\n     * owned by the system.\n     * <p>\n     * If the display is private, then only the owner can use it.\n     * </p>\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public String getOwnerPackageName()",
    "returnType" : "String",
    "comment" : "\n     * Gets the package name of the application that owns this display, or null if it is\n     * owned by the system.\n     * <p>\n     * If the display is private, then only the owner can use it.\n     * </p>\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public DisplayAdjustments getDisplayAdjustments()",
    "returnType" : "DisplayAdjustments",
    "comment" : "\n     * Gets the compatibility info used by this display instance.\n     *\n     * @return The display adjustments holder, or null if none is required.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public String getName()",
    "returnType" : "String",
    "comment" : "\n     * Gets the name of the display.\n     * <p>\n     * Note that some displays may be renamed by the user.\n     * </p>\n     *\n     * @return The display's name.\n     ",
    "links" : [ ]
  }, {
    "name" : "public void getSize(Point outSize)",
    "returnType" : "void",
    "comment" : "\n     * Gets the size of the display, in pixels.\n     * Value returned by this method does not necessarily represent the actual raw size\n     * (native resolution) of the display.\n     * <p>\n     * 1. The returned size may be adjusted to exclude certain system decor elements\n     * that are always visible.\n     * </p><p>\n     * 2. It may be scaled to provide compatibility with older applications that\n     * were originally designed for smaller displays.\n     * </p><p>\n     * 3. It can be different depending on the WindowManager to which the display belongs.\n     * </p><p>\n     * - If requested from non-Activity context (e.g. Application context via\n     * {@code (WindowManager) getApplicationContext().getSystemService(Context.WINDOW_SERVICE)})\n     * it will report the size of the entire display based on current rotation and with subtracted\n     * system decoration areas.\n     * </p><p>\n     * - If requested from activity (either using {@code getWindowManager()} or\n     * {@code (WindowManager) getSystemService(Context.WINDOW_SERVICE)}) resulting size will\n     * correspond to current app window size. In this case it can be smaller than physical size in\n     * multi-window mode.\n     * </p><p>\n     * Typically for the purposes of layout apps should make a request from activity context\n     * to obtain size available for the app content.\n     * </p>\n     *\n     * @param outSize A {@link Point} object to receive the size information.\n     * @deprecated Use {@link WindowManager#getCurrentWindowMetrics()} to obtain an instance of\n     * {@link WindowMetrics} and use {@link WindowMetrics#getBounds()} instead.\n     ",
    "links" : [ "android.view.WindowMetrics", "android.view.WindowMetrics#getBounds()", "android.graphics.Point", "android.view.WindowManager#getCurrentWindowMetrics()" ]
  }, {
    "name" : "public void getRectSize(Rect outSize)",
    "returnType" : "void",
    "comment" : "\n     * Gets the size of the display as a rectangle, in pixels.\n     *\n     * @param outSize A {@link Rect} object to receive the size information.\n     * @deprecated Use {@link WindowMetrics#getBounds()} to get the dimensions of the application\n     * window area.\n     ",
    "links" : [ "android.graphics.Rect", "android.view.WindowMetrics#getBounds()" ]
  }, {
    "name" : "public void getCurrentSizeRange(Point outSmallestSize, Point outLargestSize)",
    "returnType" : "void",
    "comment" : "\n     * Return the range of display sizes an application can expect to encounter\n     * under normal operation, as long as there is no physical change in screen\n     * size.  This is basically the sizes you will see as the orientation\n     * changes, taking into account whatever screen decoration there is in\n     * each rotation.  For example, the status bar is always at the top of the\n     * screen, so it will reduce the height both in landscape and portrait, and\n     * the smallest height returned here will be the smaller of the two.\n     *\n     * This is intended for applications to get an idea of the range of sizes\n     * they will encounter while going through device rotations, to provide a\n     * stable UI through rotation.  The sizes here take into account all standard\n     * system decorations that reduce the size actually available to the\n     * application: the status bar, navigation bar, system bar, etc.  It does\n     * <em>not</em> take into account more transient elements like an IME\n     * soft keyboard.\n     *\n     * @param outSmallestSize Filled in with the smallest width and height\n     * that the application will encounter, in pixels (not dp units).  The x\n     * (width) dimension here directly corresponds to\n     * {@link android.content.res.Configuration#smallestScreenWidthDp\n     * Configuration.smallestScreenWidthDp}, except the value here is in raw\n     * screen pixels rather than dp units.  Your application may of course\n     * still get smaller space yet if, for example, a soft keyboard is\n     * being displayed.\n     * @param outLargestSize Filled in with the largest width and height\n     * that the application will encounter, in pixels (not dp units).  Your\n     * application may of course still get larger space than this if,\n     * for example, screen decorations like the status bar are being hidden.\n     ",
    "links" : [ "android.content.res.Configuration#smallestScreenWidthDpConfiguration.smallestScreenWidthDp" ]
  }, {
    "name" : "public int getMaximumSizeDimension()",
    "returnType" : "int",
    "comment" : "\n     * Return the maximum screen size dimension that will happen.  This is\n     * mostly for wallpapers.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public int getWidth()",
    "returnType" : "int",
    "comment" : "\n     * @deprecated Use {@link WindowMetrics#getBounds#width()} instead.\n     ",
    "links" : [ "android.view.WindowMetrics#getBounds" ]
  }, {
    "name" : "public int getHeight()",
    "returnType" : "int",
    "comment" : "\n     * @deprecated Use {@link WindowMetrics#getBounds()#height()} instead.\n     ",
    "links" : [ "android.view.WindowMetrics#getBounds()" ]
  }, {
    "name" : "public int getRotation()",
    "returnType" : "int",
    "comment" : "\n     * Returns the rotation of the screen from its \"natural\" orientation.\n     * The returned value may be {@link Surface#ROTATION_0 Surface.ROTATION_0}\n     * (no rotation), {@link Surface#ROTATION_90 Surface.ROTATION_90},\n     * {@link Surface#ROTATION_180 Surface.ROTATION_180}, or\n     * {@link Surface#ROTATION_270 Surface.ROTATION_270}.  For\n     * example, if a device has a naturally tall screen, and the user has\n     * turned it on its side to go into a landscape orientation, the value\n     * returned here may be either {@link Surface#ROTATION_90 Surface.ROTATION_90}\n     * or {@link Surface#ROTATION_270 Surface.ROTATION_270} depending on\n     * the direction it was turned.  The angle is the rotation of the drawn\n     * graphics on the screen, which is the opposite direction of the physical\n     * rotation of the device.  For example, if the device is rotated 90\n     * degrees counter-clockwise, to compensate rendering will be rotated by\n     * 90 degrees clockwise and thus the returned value here will be\n     * {@link Surface#ROTATION_90 Surface.ROTATION_90}.\n     ",
    "links" : [ "android.view.Surface#ROTATION_270", "android.view.Surface#ROTATION_180", "android.view.Surface#ROTATION_90", "android.view.Surface#ROTATION_0" ]
  }, {
    "name" : "public int getOrientation()",
    "returnType" : "int",
    "comment" : "\n     * @deprecated use {@link #getRotation}\n     * @return orientation of this display.\n     ",
    "links" : [ "#getRotation" ]
  }, {
    "name" : "public DisplayCutout getCutout()",
    "returnType" : "DisplayCutout",
    "comment" : "\n     * Returns the {@link DisplayCutout}, or {@code null} if there is none.\n     *\n     * @see DisplayCutout\n     ",
    "links" : [ "android.view.DisplayCutout" ]
  }, {
    "name" : "public int getPixelFormat()",
    "returnType" : "int",
    "comment" : "\n     * Gets the pixel format of the display.\n     * @return One of the constants defined in {@link android.graphics.PixelFormat}.\n     *\n     * @deprecated This method is no longer supported.\n     * The result is always {@link PixelFormat#RGBA_8888}.\n     ",
    "links" : [ "android.graphics.PixelFormat#RGBA_8888", "android.graphics.PixelFormat" ]
  }, {
    "name" : "public float getRefreshRate()",
    "returnType" : "float",
    "comment" : "\n     * Gets the refresh rate of this display in frames per second.\n     ",
    "links" : [ ]
  }, {
    "name" : "public float[] getSupportedRefreshRates()",
    "returnType" : "float[]",
    "comment" : "\n     * Get the supported refresh rates of this display in frames per second.\n     * <p>\n     * This method only returns refresh rates for the display's default modes. For more options, use\n     * {@link #getSupportedModes()}.\n     *\n     * @deprecated use {@link #getSupportedModes()} instead\n     ",
    "links" : [ "#getSupportedModes()" ]
  }, {
    "name" : "public Mode getMode()",
    "returnType" : "Mode",
    "comment" : "\n     * Returns the active mode of the display.\n     ",
    "links" : [ ]
  }, {
    "name" : "public Mode[] getSupportedModes()",
    "returnType" : "Mode[]",
    "comment" : "\n     * Gets the supported modes of this display.\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean isMinimalPostProcessingSupported()",
    "returnType" : "boolean",
    "comment" : "\n     * <p> Returns true if the connected display can be switched into a mode with minimal\n     * post processing. </p>\n     *\n     * <p> If the Display sink is connected via HDMI, this method will return true if the\n     * display supports either Auto Low Latency Mode or Game Content Type.\n     *\n     * <p> If the Display sink has an internal connection or uses some other protocol than\n     * HDMI, this method will return true if the sink can be switched into an\n     * implementation-defined low latency image processing mode. </p>\n     *\n     * <p> The ability to switch to a mode with minimal post processing may be disabled\n     * by a user setting in the system settings menu. In that case, this method returns\n     * false. </p>\n     *\n     * @see android.view.Window#setPreferMinimalPostProcessing\n     ",
    "links" : [ ]
  }, {
    "name" : "public void requestColorMode(int colorMode)",
    "returnType" : "void",
    "comment" : "\n     * Request the display applies a color mode.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public int getColorMode()",
    "returnType" : "int",
    "comment" : "\n     * Returns the active color mode of this display\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public int getRemoveMode()",
    "returnType" : "int",
    "comment" : " TODO (b/114338689): Remove the method and use IWindowManager#getRemoveContentMode",
    "links" : [ ]
  }, {
    "name" : "public HdrCapabilities getHdrCapabilities()",
    "returnType" : "HdrCapabilities",
    "comment" : "\n     * Returns the display's HDR capabilities.\n     *\n     * @see #isHdr()\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean isHdr()",
    "returnType" : "boolean",
    "comment" : "\n     * Returns whether this display supports any HDR type.\n     *\n     * @see #getHdrCapabilities()\n     * @see HdrCapabilities#getSupportedHdrTypes()\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean isWideColorGamut()",
    "returnType" : "boolean",
    "comment" : "\n     * Returns whether this display can be used to display wide color gamut content.\n     * This does not necessarily mean the device itself can render wide color gamut\n     * content. To ensure wide color gamut content can be produced, refer to\n     * {@link Configuration#isScreenWideColorGamut()}.\n     ",
    "links" : [ "android.content.res.Configuration#isScreenWideColorGamut()" ]
  }, {
    "name" : "public ColorSpace getPreferredWideGamutColorSpace()",
    "returnType" : "ColorSpace",
    "comment" : "\n     * Returns the preferred wide color space of the Display.\n     * The returned wide gamut color space is based on hardware capability and\n     * is preferred by the composition pipeline.\n     * Returns null if the display doesn't support wide color gamut.\n     * {@link Display#isWideColorGamut()}.\n     ",
    "links" : [ "android.view.Display#isWideColorGamut()" ]
  }, {
    "name" : "public int[] getSupportedColorModes()",
    "returnType" : "int[]",
    "comment" : "\n     * Gets the supported color modes of this device.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public ColorSpace[] getSupportedWideColorGamut()",
    "returnType" : "ColorSpace[]",
    "comment" : "\n     * Gets the supported wide color gamuts of this device.\n     *\n     * @return Supported WCG color spaces.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public long getAppVsyncOffsetNanos()",
    "returnType" : "long",
    "comment" : "\n     * Gets the app VSYNC offset, in nanoseconds.  This is a positive value indicating\n     * the phase offset of the VSYNC events provided by Choreographer relative to the\n     * display refresh.  For example, if Choreographer reports that the refresh occurred\n     * at time N, it actually occurred at (N - appVsyncOffset).\n     * <p>\n     * Apps generally do not need to be aware of this.  It's only useful for fine-grained\n     * A/V synchronization.\n     ",
    "links" : [ ]
  }, {
    "name" : "public long getPresentationDeadlineNanos()",
    "returnType" : "long",
    "comment" : "\n     * This is how far in advance a buffer must be queued for presentation at\n     * a given time.  If you want a buffer to appear on the screen at\n     * time N, you must submit the buffer before (N - presentationDeadline).\n     * <p>\n     * The desired presentation time for GLES rendering may be set with\n     * {@link android.opengl.EGLExt#eglPresentationTimeANDROID}.  For video decoding, use\n     * {@link android.media.MediaCodec#releaseOutputBuffer(int, long)}.  Times are\n     * expressed in nanoseconds, using the system monotonic clock\n     * ({@link System#nanoTime}).\n     ",
    "links" : [ "android.opengl.EGLExt#eglPresentationTimeANDROID", "#nanoTime", "android.media.MediaCodec#releaseOutputBuffer(int" ]
  }, {
    "name" : "public void getMetrics(DisplayMetrics outMetrics)",
    "returnType" : "void",
    "comment" : "\n     * Gets display metrics that describe the size and density of this display.\n     * The size returned by this method does not necessarily represent the\n     * actual raw size (native resolution) of the display.\n     * <p>\n     * 1. The returned size may be adjusted to exclude certain system decor elements\n     * that are always visible.\n     * </p><p>\n     * 2. It may be scaled to provide compatibility with older applications that\n     * were originally designed for smaller displays.\n     * </p><p>\n     * 3. It can be different depending on the WindowManager to which the display belongs.\n     * </p><p>\n     * - If requested from non-Activity context (e.g. Application context via\n     * {@code (WindowManager) getApplicationContext().getSystemService(Context.WINDOW_SERVICE)})\n     * metrics will report the size of the entire display based on current rotation and with\n     * subtracted system decoration areas.\n     * </p><p>\n     * - If requested from activity (either using {@code getWindowManager()} or\n     * {@code (WindowManager) getSystemService(Context.WINDOW_SERVICE)}) resulting metrics will\n     * correspond to current app window metrics. In this case the size can be smaller than physical\n     * size in multi-window mode.\n     * </p>\n     *\n     * @param outMetrics A {@link DisplayMetrics} object to receive the metrics.\n     * @deprecated Use {@link WindowMetrics#getBounds()} to get the dimensions of the application\n     * window area, and {@link Configuration#densityDpi} to get the current density.\n     ",
    "links" : [ "android.view.WindowMetrics#getBounds()", "android.content.res.Configuration#densityDpi", "android.util.DisplayMetrics" ]
  }, {
    "name" : "public void getRealSize(Point outSize)",
    "returnType" : "void",
    "comment" : "\n     * Gets the real size of the display without subtracting any window decor or\n     * applying any compatibility scale factors.\n     * <p>\n     * The size is adjusted based on the current rotation of the display.\n     * </p><p>\n     * The real size may be smaller than the physical size of the screen when the\n     * window manager is emulating a smaller display (using adb shell wm size).\n     * </p>\n     *\n     * @param outSize Set to the real size of the display.\n     ",
    "links" : [ ]
  }, {
    "name" : "public void getRealMetrics(DisplayMetrics outMetrics)",
    "returnType" : "void",
    "comment" : "\n     * Gets display metrics based on the real size of this display.\n     * <p>\n     * The size is adjusted based on the current rotation of the display.\n     * </p><p>\n     * The real size may be smaller than the physical size of the screen when the\n     * window manager is emulating a smaller display (using adb shell wm size).\n     * </p>\n     *\n     * @param outMetrics A {@link DisplayMetrics} object to receive the metrics.\n     ",
    "links" : [ "android.util.DisplayMetrics" ]
  }, {
    "name" : "public int getState()",
    "returnType" : "int",
    "comment" : "\n     * Gets the state of the display, such as whether it is on or off.\n     *\n     * @return The state of the display: one of {@link #STATE_OFF}, {@link #STATE_ON},\n     * {@link #STATE_DOZE}, {@link #STATE_DOZE_SUSPEND}, {@link #STATE_ON_SUSPEND}, or\n     * {@link #STATE_UNKNOWN}.\n     ",
    "links" : [ "#STATE_ON_SUSPEND", "#STATE_ON", "#STATE_DOZE_SUSPEND", "#STATE_OFF", "#STATE_UNKNOWN", "#STATE_DOZE" ]
  }, {
    "name" : "public boolean hasAccess(int uid)",
    "returnType" : "boolean",
    "comment" : "\n     * Returns true if the specified UID has access to this display.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public static boolean hasAccess(int uid, int flags, int ownerUid, int displayId)",
    "returnType" : "boolean",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "public boolean isPublicPresentation()",
    "returnType" : "boolean",
    "comment" : "\n     * Returns true if the display is a public presentation display.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean isTrusted()",
    "returnType" : "boolean",
    "comment" : "\n     * @return {@code true} if the display is a trusted display.\n     *\n     * @see #FLAG_TRUSTED\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "private void updateDisplayInfoLocked()",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private void updateCachedAppSizeIfNeededLocked()",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public String toString()",
    "returnType" : "String",
    "comment" : " For debugging purposes",
    "links" : [ ]
  }, {
    "name" : "public static String typeToString(int type)",
    "returnType" : "String",
    "comment" : "\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public static String stateToString(int state)",
    "returnType" : "String",
    "comment" : "\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public static boolean isSuspendedState(int state)",
    "returnType" : "boolean",
    "comment" : "\n     * Returns true if display updates may be suspended while in the specified\n     * display power state. In SUSPEND states, updates are absolutely forbidden.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public static boolean isDozeState(int state)",
    "returnType" : "boolean",
    "comment" : "\n     * Returns true if the display may be in a reduced operating mode while in the\n     * specified display power state.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public static boolean isActiveState(int state)",
    "returnType" : "boolean",
    "comment" : "\n     * Returns true if the display is in active state such as {@link #STATE_ON}\n     * or {@link #STATE_VR}.\n     * @hide\n     ",
    "links" : [ "#STATE_ON", "#STATE_VR" ]
  } ],
  "variableNames" : [ "TAG", "DEBUG", "mGlobal", "mDisplayId", "mLayerStack", "mFlags", "mType", "mAddress", "mOwnerUid", "mOwnerPackageName", "mResources", "mDisplayAdjustments", "mDisplayInfo", "mIsValid", "mTempMetrics", "CACHED_APP_SIZE_DURATION_MILLIS", "mLastCachedAppSizeUpdate", "mCachedAppWidthCompat", "mCachedAppHeightCompat", "mMayAdjustByFixedRotation", "DEFAULT_DISPLAY", "INVALID_DISPLAY", "FLAG_SUPPORTS_PROTECTED_BUFFERS", "FLAG_SECURE", "FLAG_PRIVATE", "FLAG_PRESENTATION", "FLAG_ROUND", "FLAG_CAN_SHOW_WITH_INSECURE_KEYGUARD", "FLAG_SHOULD_SHOW_SYSTEM_DECORATIONS", "FLAG_TRUSTED", "FLAG_SCALING_DISABLED", "TYPE_UNKNOWN", "TYPE_INTERNAL", "TYPE_EXTERNAL", "TYPE_WIFI", "TYPE_OVERLAY", "TYPE_VIRTUAL", "STATE_UNKNOWN", "STATE_OFF", "STATE_ON", "STATE_DOZE", "STATE_DOZE_SUSPEND", "STATE_VR", "STATE_ON_SUSPEND", "COLOR_MODE_INVALID", "COLOR_MODE_DEFAULT", "COLOR_MODE_BT601_625", "COLOR_MODE_BT601_625_UNADJUSTED", "COLOR_MODE_BT601_525", "COLOR_MODE_BT601_525_UNADJUSTED", "COLOR_MODE_BT709", "COLOR_MODE_DCI_P3", "COLOR_MODE_SRGB", "COLOR_MODE_ADOBE_RGB", "COLOR_MODE_DISPLAY_P3", "REMOVE_MODE_MOVE_CONTENT_TO_PRIMARY", "REMOVE_MODE_DESTROY_CONTENT" ],
  "methodNames" : [ "public int getDisplayId()", "public String getUniqueId()", "public boolean isValid()", "public boolean getDisplayInfo(DisplayInfo outDisplayInfo)", "public int getLayerStack()", "public int getFlags()", "public int getType()", "public DisplayAddress getAddress()", "public int getOwnerUid()", "public String getOwnerPackageName()", "public DisplayAdjustments getDisplayAdjustments()", "public String getName()", "public void getSize(Point outSize)", "public void getRectSize(Rect outSize)", "public void getCurrentSizeRange(Point outSmallestSize, Point outLargestSize)", "public int getMaximumSizeDimension()", "public int getWidth()", "public int getHeight()", "public int getRotation()", "public int getOrientation()", "public DisplayCutout getCutout()", "public int getPixelFormat()", "public float getRefreshRate()", "public float[] getSupportedRefreshRates()", "public Mode getMode()", "public Mode[] getSupportedModes()", "public boolean isMinimalPostProcessingSupported()", "public void requestColorMode(int colorMode)", "public int getColorMode()", "public int getRemoveMode()", "public HdrCapabilities getHdrCapabilities()", "public boolean isHdr()", "public boolean isWideColorGamut()", "public ColorSpace getPreferredWideGamutColorSpace()", "public int[] getSupportedColorModes()", "public ColorSpace[] getSupportedWideColorGamut()", "public long getAppVsyncOffsetNanos()", "public long getPresentationDeadlineNanos()", "public void getMetrics(DisplayMetrics outMetrics)", "public void getRealSize(Point outSize)", "public void getRealMetrics(DisplayMetrics outMetrics)", "public int getState()", "public boolean hasAccess(int uid)", "public static boolean hasAccess(int uid, int flags, int ownerUid, int displayId)", "public boolean isPublicPresentation()", "public boolean isTrusted()", "private void updateDisplayInfoLocked()", "private void updateCachedAppSizeIfNeededLocked()", "public String toString()", "public static String typeToString(int type)", "public static String stateToString(int state)", "public static boolean isSuspendedState(int state)", "public static boolean isDozeState(int state)", "public static boolean isActiveState(int state)" ]
}