{
  "filePath" : "/home/maryam/clearblue/files/android-source-30/android/hardware/camera2/params/StreamConfigurationMap.java",
  "packageName" : "android.hardware.camera2.params",
  "className" : "StreamConfigurationMap",
  "comment" : "\n * Immutable class to store the available stream\n * {@link CameraCharacteristics#SCALER_STREAM_CONFIGURATION_MAP configurations} to set up\n * {@link android.view.Surface Surfaces} for creating a\n * {@link android.hardware.camera2.CameraCaptureSession capture session} with\n * {@link android.hardware.camera2.CameraDevice#createCaptureSession}.\n * <!-- TODO: link to input stream configuration -->\n *\n * <p>This is the authoritative list for all <!-- input/ -->output formats (and sizes respectively\n * for that format) that are supported by a camera device.</p>\n *\n * <p>This also contains the minimum frame durations and stall durations for each format/size\n * combination that can be used to calculate effective frame rate when submitting multiple captures.\n * </p>\n *\n * <p>An instance of this object is available from {@link CameraCharacteristics} using\n * the {@link CameraCharacteristics#SCALER_STREAM_CONFIGURATION_MAP} key and the\n * {@link CameraCharacteristics#get} method.</p>\n *\n * <pre><code>{@code\n * CameraCharacteristics characteristics = cameraManager.getCameraCharacteristics(cameraId);\n * StreamConfigurationMap configs = characteristics.get(\n *         CameraCharacteristics.SCALER_STREAM_CONFIGURATION_MAP);\n * }</code></pre>\n *\n * @see CameraCharacteristics#SCALER_STREAM_CONFIGURATION_MAP\n * @see CameraDevice#createCaptureSession\n ",
  "variables" : [ {
    "name" : "TAG",
    "type" : "String",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "HAL_PIXEL_FORMAT_RAW16",
    "type" : "int",
    "comment" : " from system/core/include/system/graphics.h",
    "links" : [ ]
  }, {
    "name" : "HAL_PIXEL_FORMAT_BLOB",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "HAL_PIXEL_FORMAT_IMPLEMENTATION_DEFINED",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "HAL_PIXEL_FORMAT_YCbCr_420_888",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "HAL_PIXEL_FORMAT_RAW_OPAQUE",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "HAL_PIXEL_FORMAT_RAW10",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "HAL_PIXEL_FORMAT_RAW12",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "HAL_PIXEL_FORMAT_Y16",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "HAL_DATASPACE_STANDARD_SHIFT",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "HAL_DATASPACE_TRANSFER_SHIFT",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "HAL_DATASPACE_RANGE_SHIFT",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "HAL_DATASPACE_UNKNOWN",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "HAL_DATASPACE_V0_JFIF",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "HAL_DATASPACE_DEPTH",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "HAL_DATASPACE_DYNAMIC_DEPTH",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "HAL_DATASPACE_HEIF",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "DURATION_20FPS_NS",
    "type" : "long",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "DURATION_MIN_FRAME",
    "type" : "int",
    "comment" : "\n     * @see #getDurations(int, int)\n     ",
    "links" : [ ]
  }, {
    "name" : "DURATION_STALL",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mConfigurations",
    "type" : "StreamConfiguration[]",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mMinFrameDurations",
    "type" : "StreamConfigurationDuration[]",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mStallDurations",
    "type" : "StreamConfigurationDuration[]",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mDepthConfigurations",
    "type" : "StreamConfiguration[]",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mDepthMinFrameDurations",
    "type" : "StreamConfigurationDuration[]",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mDepthStallDurations",
    "type" : "StreamConfigurationDuration[]",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mDynamicDepthConfigurations",
    "type" : "StreamConfiguration[]",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mDynamicDepthMinFrameDurations",
    "type" : "StreamConfigurationDuration[]",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mDynamicDepthStallDurations",
    "type" : "StreamConfigurationDuration[]",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mHeicConfigurations",
    "type" : "StreamConfiguration[]",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mHeicMinFrameDurations",
    "type" : "StreamConfigurationDuration[]",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mHeicStallDurations",
    "type" : "StreamConfigurationDuration[]",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mHighSpeedVideoConfigurations",
    "type" : "HighSpeedVideoConfiguration[]",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mInputOutputFormatsMap",
    "type" : "ReprocessFormatsMap",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mListHighResolution",
    "type" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mOutputFormats",
    "type" : "SparseIntArray",
    "comment" : " internal format -> num output sizes mapping, not including slow high-res sizes, for\n     * non-depth dataspaces ",
    "links" : [ ]
  }, {
    "name" : "mHighResOutputFormats",
    "type" : "SparseIntArray",
    "comment" : " internal format -> num output sizes mapping for slow high-res sizes, for non-depth\n     * dataspaces ",
    "links" : [ ]
  }, {
    "name" : "mAllOutputFormats",
    "type" : "SparseIntArray",
    "comment" : " internal format -> num output sizes mapping for all non-depth dataspaces ",
    "links" : [ ]
  }, {
    "name" : "mInputFormats",
    "type" : "SparseIntArray",
    "comment" : " internal format -> num input sizes mapping, for input reprocessing formats ",
    "links" : [ ]
  }, {
    "name" : "mDepthOutputFormats",
    "type" : "SparseIntArray",
    "comment" : " internal format -> num depth output sizes mapping, for HAL_DATASPACE_DEPTH ",
    "links" : [ ]
  }, {
    "name" : "mDynamicDepthOutputFormats",
    "type" : "SparseIntArray",
    "comment" : " internal format -> num dynamic depth output sizes mapping, for HAL_DATASPACE_DYNAMIC_DEPTH ",
    "links" : [ ]
  }, {
    "name" : "mHeicOutputFormats",
    "type" : "SparseIntArray",
    "comment" : " internal format -> num heic output sizes mapping, for HAL_DATASPACE_HEIF ",
    "links" : [ ]
  }, {
    "name" : "mHighSpeedVideoSizeMap",
    "type" : "HashMap<Size, Integer>",
    "comment" : " High speed video Size -> FPS range count mapping",
    "links" : [ ]
  }, {
    "name" : "mHighSpeedVideoFpsRangeMap",
    "type" : "HashMap<Range<Integer>, Integer>",
    "comment" : " High speed video FPS range -> Size count mapping",
    "links" : [ ]
  } ],
  "methods" : [ {
    "name" : "public int[] getOutputFormats()",
    "returnType" : "int[]",
    "comment" : "\n     * Get the image {@code format} output formats in this stream configuration.\n     *\n     * <p>All image formats returned by this function will be defined in either {@link ImageFormat}\n     * or in {@link PixelFormat} (and there is no possibility of collision).</p>\n     *\n     * <p>Formats listed in this array are guaranteed to return true if queried with\n     * {@link #isOutputSupportedFor(int)}.</p>\n     *\n     * @return an array of integer format\n     *\n     * @see ImageFormat\n     * @see PixelFormat\n     ",
    "links" : [ "ImageFormat", "PixelFormat", "#isOutputSupportedFor" ]
  }, {
    "name" : "public int[] getValidOutputFormatsForInput(int inputFormat)",
    "returnType" : "int[]",
    "comment" : "\n     * Get the image {@code format} output formats for a reprocessing input format.\n     *\n     * <p>When submitting a {@link CaptureRequest} with an input Surface of a given format,\n     * the only allowed target outputs of the {@link CaptureRequest} are the ones with a format\n     * listed in the return value of this method. Including any other output Surface as a target\n     * will throw an IllegalArgumentException. If no output format is supported given the input\n     * format, an empty int[] will be returned.</p>\n     *\n     * <p>All image formats returned by this function will be defined in either {@link ImageFormat}\n     * or in {@link PixelFormat} (and there is no possibility of collision).</p>\n     *\n     * <p>Formats listed in this array are guaranteed to return true if queried with\n     * {@link #isOutputSupportedFor(int)}.</p>\n     *\n     * @return an array of integer format\n     *\n     * @see ImageFormat\n     * @see PixelFormat\n     ",
    "links" : [ "CaptureRequest", "CaptureRequest", "ImageFormat", "PixelFormat", "#isOutputSupportedFor" ]
  }, {
    "name" : "public int[] getInputFormats()",
    "returnType" : "int[]",
    "comment" : "\n     * Get the image {@code format} input formats in this stream configuration.\n     *\n     * <p>All image formats returned by this function will be defined in either {@link ImageFormat}\n     * or in {@link PixelFormat} (and there is no possibility of collision).</p>\n     *\n     * @return an array of integer format\n     *\n     * @see ImageFormat\n     * @see PixelFormat\n     ",
    "links" : [ "ImageFormat", "PixelFormat" ]
  }, {
    "name" : "public Size[] getInputSizes(final int format)",
    "returnType" : "Size[]",
    "comment" : "\n     * Get the supported input sizes for this input format.\n     *\n     * <p>The format must have come from {@link #getInputFormats}; otherwise\n     * {@code null} is returned.</p>\n     *\n     * @param format a format from {@link #getInputFormats}\n     * @return a non-empty array of sizes, or {@code null} if the format was not available.\n     ",
    "links" : [ "#getInputFormats", "#getInputFormats" ]
  }, {
    "name" : "public boolean isOutputSupportedFor(int format)",
    "returnType" : "boolean",
    "comment" : "\n     * Determine whether or not output surfaces with a particular user-defined format can be passed\n     * {@link CameraDevice#createCaptureSession createCaptureSession}.\n     *\n     * <p>This method determines that the output {@code format} is supported by the camera device;\n     * each output {@code surface} target may or may not itself support that {@code format}.\n     * Refer to the class which provides the surface for additional documentation.</p>\n     *\n     * <p>Formats for which this returns {@code true} are guaranteed to exist in the result\n     * returned by {@link #getOutputSizes}.</p>\n     *\n     * @param format an image format from either {@link ImageFormat} or {@link PixelFormat}\n     * @return\n     *          {@code true} iff using a {@code surface} with this {@code format} will be\n     *          supported with {@link CameraDevice#createCaptureSession}\n     *\n     * @throws IllegalArgumentException\n     *          if the image format was not a defined named constant\n     *          from either {@link ImageFormat} or {@link PixelFormat}\n     *\n     * @see ImageFormat\n     * @see PixelFormat\n     * @see CameraDevice#createCaptureSession\n     ",
    "links" : [ "CameraDevice#createCaptureSession", "#getOutputSizes", "ImageFormat", "PixelFormat", "CameraDevice#createCaptureSession", "ImageFormat", "PixelFormat" ]
  }, {
    "name" : "public static boolean isOutputSupportedFor(Class<T> klass)",
    "returnType" : "boolean",
    "comment" : "\n     * Determine whether or not output streams can be configured with a particular class\n     * as a consumer.\n     *\n     * <p>The following list is generally usable for outputs:\n     * <ul>\n     * <li>{@link android.media.ImageReader} -\n     * Recommended for image processing or streaming to external resources (such as a file or\n     * network)\n     * <li>{@link android.media.MediaRecorder} -\n     * Recommended for recording video (simple to use)\n     * <li>{@link android.media.MediaCodec} -\n     * Recommended for recording video (more complicated to use, with more flexibility)\n     * <li>{@link android.renderscript.Allocation} -\n     * Recommended for image processing with {@link android.renderscript RenderScript}\n     * <li>{@link android.view.SurfaceHolder} -\n     * Recommended for low-power camera preview with {@link android.view.SurfaceView}\n     * <li>{@link android.graphics.SurfaceTexture} -\n     * Recommended for OpenGL-accelerated preview processing or compositing with\n     * {@link android.view.TextureView}\n     * </ul>\n     * </p>\n     *\n     * <p>Generally speaking this means that creating a {@link Surface} from that class <i>may</i>\n     * provide a producer endpoint that is suitable to be used with\n     * {@link CameraDevice#createCaptureSession}.</p>\n     *\n     * <p>Since not all of the above classes support output of all format and size combinations,\n     * the particular combination should be queried with {@link #isOutputSupportedFor(Surface)}.</p>\n     *\n     * @param klass a non-{@code null} {@link Class} object reference\n     * @return {@code true} if this class is supported as an output, {@code false} otherwise\n     *\n     * @throws NullPointerException if {@code klass} was {@code null}\n     *\n     * @see CameraDevice#createCaptureSession\n     * @see #isOutputSupportedFor(Surface)\n     ",
    "links" : [ "android.media.ImageReader", "android.media.MediaRecorder", "android.media.MediaCodec", "android.renderscript.Allocation", "android.renderscript", "android.view.SurfaceHolder", "android.view.SurfaceView", "android.graphics.SurfaceTexture", "android.view.TextureView", "Surface", "CameraDevice#createCaptureSession", "#isOutputSupportedFor", "Class" ]
  }, {
    "name" : "public boolean isOutputSupportedFor(Surface surface)",
    "returnType" : "boolean",
    "comment" : "\n     * Determine whether or not the {@code surface} in its current state is suitable to be included\n     * in a {@link CameraDevice#createCaptureSession capture session} as an output.\n     *\n     * <p>Not all surfaces are usable with the {@link CameraDevice}, and not all configurations\n     * of that {@code surface} are compatible. Some classes that provide the {@code surface} are\n     * compatible with the {@link CameraDevice} in general\n     * (see {@link #isOutputSupportedFor(Class)}, but it is the caller's responsibility to put the\n     * {@code surface} into a state that will be compatible with the {@link CameraDevice}.</p>\n     *\n     * <p>Reasons for a {@code surface} being specifically incompatible might be:\n     * <ul>\n     * <li>Using a format that's not listed by {@link #getOutputFormats}\n     * <li>Using a format/size combination that's not listed by {@link #getOutputSizes}\n     * <li>The {@code surface} itself is not in a state where it can service a new producer.</p>\n     * </li>\n     * </ul>\n     *\n     * <p>Surfaces from flexible sources will return true even if the exact size of the Surface does\n     * not match a camera-supported size, as long as the format (or class) is supported and the\n     * camera device supports a size that is equal to or less than 1080p in that format. If such as\n     * Surface is used to create a capture session, it will have its size rounded to the nearest\n     * supported size, below or equal to 1080p. Flexible sources include SurfaceView, SurfaceTexture,\n     * and ImageReader.</p>\n     *\n     * <p>This is not an exhaustive list; see the particular class's documentation for further\n     * possible reasons of incompatibility.</p>\n     *\n     * @param surface a non-{@code null} {@link Surface} object reference\n     * @return {@code true} if this is supported, {@code false} otherwise\n     *\n     * @throws NullPointerException if {@code surface} was {@code null}\n     * @throws IllegalArgumentException if the Surface endpoint is no longer valid\n     *\n     * @see CameraDevice#createCaptureSession\n     * @see #isOutputSupportedFor(Class)\n     ",
    "links" : [ "CameraDevice#createCaptureSession", "CameraDevice", "CameraDevice", "#isOutputSupportedFor", "CameraDevice", "#getOutputFormats", "#getOutputSizes", "Surface" ]
  }, {
    "name" : "public boolean isOutputSupportedFor(Size size, int format)",
    "returnType" : "boolean",
    "comment" : "\n     * Determine whether or not the particular stream configuration is suitable to be included\n     * in a {@link CameraDevice#createCaptureSession capture session} as an output.\n     *\n     * @param size stream configuration size\n     * @param format stream configuration format\n     * @return {@code true} if this is supported, {@code false} otherwise\n     *\n     * @see CameraDevice#createCaptureSession\n     * @see #isOutputSupportedFor(Class)\n     * @hide\n     ",
    "links" : [ "CameraDevice#createCaptureSession" ]
  }, {
    "name" : "public Size[] getOutputSizes(Class<T> klass)",
    "returnType" : "Size[]",
    "comment" : "\n     * Get a list of sizes compatible with {@code klass} to use as an output.\n     *\n     * <p>Some of the supported classes may support additional formats beyond\n     * {@link ImageFormat#PRIVATE}; this function only returns\n     * sizes for {@link ImageFormat#PRIVATE}. For example, {@link android.media.ImageReader}\n     * supports {@link ImageFormat#YUV_420_888} and {@link ImageFormat#PRIVATE}, this method will\n     * only return the sizes for {@link ImageFormat#PRIVATE} for {@link android.media.ImageReader}\n     * class.</p>\n     *\n     * <p>If a well-defined format such as {@code NV21} is required, use\n     * {@link #getOutputSizes(int)} instead.</p>\n     *\n     * <p>The {@code klass} should be a supported output, that querying\n     * {@code #isOutputSupportedFor(Class)} should return {@code true}.</p>\n     *\n     * @param klass\n     *          a non-{@code null} {@link Class} object reference\n     * @return\n     *          an array of supported sizes for {@link ImageFormat#PRIVATE} format,\n     *          or {@code null} iff the {@code klass} is not a supported output.\n     *\n     *\n     * @throws NullPointerException if {@code klass} was {@code null}\n     *\n     * @see #isOutputSupportedFor(Class)\n     ",
    "links" : [ "ImageFormat#PRIVATE", "ImageFormat#PRIVATE", "android.media.ImageReader", "ImageFormat#YUV_420_888", "ImageFormat#PRIVATE", "ImageFormat#PRIVATE", "android.media.ImageReader", "#getOutputSizes", "Class", "ImageFormat#PRIVATE" ]
  }, {
    "name" : "public Size[] getOutputSizes(int format)",
    "returnType" : "Size[]",
    "comment" : "\n     * Get a list of sizes compatible with the requested image {@code format}.\n     *\n     * <p>The {@code format} should be a supported format (one of the formats returned by\n     * {@link #getOutputFormats}).</p>\n     *\n     * As of API level 23, the {@link #getHighResolutionOutputSizes} method can be used on devices\n     * that support the\n     * {@link android.hardware.camera2.CameraCharacteristics#REQUEST_AVAILABLE_CAPABILITIES_BURST_CAPTURE BURST_CAPTURE}\n     * capability to get a list of high-resolution output sizes that cannot operate at the preferred\n     * 20fps rate. This means that for some supported formats, this method will return an empty\n     * list, if all the supported resolutions operate at below 20fps.  For devices that do not\n     * support the BURST_CAPTURE capability, all output resolutions are listed through this method.\n     *\n     * @param format an image format from {@link ImageFormat} or {@link PixelFormat}\n     * @return\n     *          an array of supported sizes,\n     *          or {@code null} if the {@code format} is not a supported output\n     *\n     * @see ImageFormat\n     * @see PixelFormat\n     * @see #getOutputFormats\n     ",
    "links" : [ "#getOutputFormats", "#getHighResolutionOutputSizes", "android.hardware.camera2.CameraCharacteristics#REQUEST_AVAILABLE_CAPABILITIES_BURST_CAPTURE", "ImageFormat", "PixelFormat" ]
  }, {
    "name" : "public Size[] getHighSpeedVideoSizes()",
    "returnType" : "Size[]",
    "comment" : "\n     * Get a list of supported high speed video recording sizes.\n     * <p>\n     * When {@link CameraMetadata#REQUEST_AVAILABLE_CAPABILITIES_CONSTRAINED_HIGH_SPEED_VIDEO} is\n     * supported in {@link CameraCharacteristics#REQUEST_AVAILABLE_CAPABILITIES}, this method will\n     * list the supported high speed video size configurations. All the sizes listed will be a\n     * subset of the sizes reported by {@link #getOutputSizes} for processed non-stalling formats\n     * (typically {@link ImageFormat#PRIVATE} {@link ImageFormat#YUV_420_888}, etc.)\n     * </p>\n     * <p>\n     * To enable high speed video recording, application must create a constrained create high speed\n     * capture session via {@link CameraDevice#createConstrainedHighSpeedCaptureSession}, and submit\n     * a CaptureRequest list created by\n     * {@link android.hardware.camera2.CameraConstrainedHighSpeedCaptureSession#createHighSpeedRequestList}\n     * to this session. The application must select the video size from this method and\n     * {@link CaptureRequest#CONTROL_AE_TARGET_FPS_RANGE FPS range} from\n     * {@link #getHighSpeedVideoFpsRangesFor} to configure the constrained high speed session and\n     * generate the high speed request list. For example, if the application intends to do high\n     * speed recording, it can select the maximum size reported by this method to create high speed\n     * capture session. Note that for the use case of multiple output streams, application must\n     * select one unique size from this method to use (e.g., preview and recording streams must have\n     * the same size). Otherwise, the high speed session creation will fail. Once the size is\n     * selected, application can get the supported FPS ranges by\n     * {@link #getHighSpeedVideoFpsRangesFor}, and use these FPS ranges to setup the recording\n     * request lists via\n     * {@link android.hardware.camera2.CameraConstrainedHighSpeedCaptureSession#createHighSpeedRequestList}.\n     * </p>\n     *\n     * @return an array of supported high speed video recording sizes\n     * @see #getHighSpeedVideoFpsRangesFor(Size)\n     * @see CameraMetadata#REQUEST_AVAILABLE_CAPABILITIES_CONSTRAINED_HIGH_SPEED_VIDEO\n     * @see CameraDevice#createConstrainedHighSpeedCaptureSession\n     * @see android.hardware.camera2.CameraConstrainedHighSpeedCaptureSession#createHighSpeedRequestList\n     ",
    "links" : [ "CameraMetadata#REQUEST_AVAILABLE_CAPABILITIES_CONSTRAINED_HIGH_SPEED_VIDEO", "CameraCharacteristics#REQUEST_AVAILABLE_CAPABILITIES", "#getOutputSizes", "ImageFormat#PRIVATE", "ImageFormat#YUV_420_888", "CameraDevice#createConstrainedHighSpeedCaptureSession", "android.hardware.camera2.CameraConstrainedHighSpeedCaptureSession#createHighSpeedRequestList", "CaptureRequest#CONTROL_AE_TARGET_FPS_RANGE", "#getHighSpeedVideoFpsRangesFor", "#getHighSpeedVideoFpsRangesFor", "android.hardware.camera2.CameraConstrainedHighSpeedCaptureSession#createHighSpeedRequestList" ]
  }, {
    "name" : "public Range<Integer>[] getHighSpeedVideoFpsRangesFor(Size size)",
    "returnType" : "Range<Integer>[]",
    "comment" : "\n     * Get the frame per second ranges (fpsMin, fpsMax) for input high speed video size.\n     * <p>\n     * See {@link #getHighSpeedVideoFpsRanges} for how to enable high speed recording.\n     * </p>\n     * <p>\n     * The {@link CaptureRequest#CONTROL_AE_TARGET_FPS_RANGE FPS ranges} reported in this method\n     * must not be used to setup capture requests that are submitted to unconstrained capture\n     * sessions, or it will result in {@link IllegalArgumentException IllegalArgumentExceptions}.\n     * </p>\n     * <p>\n     * See {@link #getHighSpeedVideoFpsRanges} for the characteristics of the returned FPS ranges.\n     * </p>\n     *\n     * @param size one of the sizes returned by {@link #getHighSpeedVideoSizes()}\n     * @return an array of supported high speed video recording FPS ranges The upper bound of\n     *         returned ranges is guaranteed to be greater than or equal to 120.\n     * @throws IllegalArgumentException if input size does not exist in the return value of\n     *             getHighSpeedVideoSizes\n     * @see #getHighSpeedVideoSizes()\n     * @see #getHighSpeedVideoFpsRanges()\n     ",
    "links" : [ "#getHighSpeedVideoFpsRanges", "CaptureRequest#CONTROL_AE_TARGET_FPS_RANGE", "IllegalArgumentException", "#getHighSpeedVideoFpsRanges", "#getHighSpeedVideoSizes" ]
  }, {
    "name" : "public Range<Integer>[] getHighSpeedVideoFpsRanges()",
    "returnType" : "Range<Integer>[]",
    "comment" : "\n     * Get a list of supported high speed video recording FPS ranges.\n     * <p>\n     * When {@link CameraMetadata#REQUEST_AVAILABLE_CAPABILITIES_CONSTRAINED_HIGH_SPEED_VIDEO} is\n     * supported in {@link CameraCharacteristics#REQUEST_AVAILABLE_CAPABILITIES}, this method will\n     * list the supported high speed video FPS range configurations. Application can then use\n     * {@link #getHighSpeedVideoSizesFor} to query available sizes for one of returned FPS range.\n     * </p>\n     * <p>\n     * To enable high speed video recording, application must create a constrained create high speed\n     * capture session via {@link CameraDevice#createConstrainedHighSpeedCaptureSession}, and submit\n     * a CaptureRequest list created by\n     * {@link android.hardware.camera2.CameraConstrainedHighSpeedCaptureSession#createHighSpeedRequestList}\n     * to this session. The application must select the video size from this method and\n     * {@link CaptureRequest#CONTROL_AE_TARGET_FPS_RANGE FPS range} from\n     * {@link #getHighSpeedVideoFpsRangesFor} to configure the constrained high speed session and\n     * generate the high speed request list. For example, if the application intends to do high\n     * speed recording, it can select one FPS range reported by this method, query the video sizes\n     * corresponding to this FPS range by {@link #getHighSpeedVideoSizesFor} and use one of reported\n     * sizes to create a high speed capture session. Note that for the use case of multiple output\n     * streams, application must select one unique size from this method to use (e.g., preview and\n     * recording streams must have the same size). Otherwise, the high speed session creation will\n     * fail. Once the high speed capture session is created, the application can set the FPS range\n     * in the recording request lists via\n     * {@link android.hardware.camera2.CameraConstrainedHighSpeedCaptureSession#createHighSpeedRequestList}.\n     * </p>\n     * <p>\n     * The FPS ranges reported by this method will have below characteristics:\n     * <li>The fpsMin and fpsMax will be a multiple 30fps.</li>\n     * <li>The fpsMin will be no less than 30fps, the fpsMax will be no less than 120fps.</li>\n     * <li>At least one range will be a fixed FPS range where fpsMin == fpsMax.</li>\n     * <li>For each fixed FPS range, there will be one corresponding variable FPS range [30,\n     * fps_max]. These kinds of FPS ranges are suitable for preview-only use cases where the\n     * application doesn't want the camera device always produce higher frame rate than the display\n     * refresh rate.</li>\n     * </p>\n     *\n     * @return an array of supported high speed video recording FPS ranges The upper bound of\n     *         returned ranges is guaranteed to be larger or equal to 120.\n     * @see #getHighSpeedVideoSizesFor\n     * @see CameraMetadata#REQUEST_AVAILABLE_CAPABILITIES_CONSTRAINED_HIGH_SPEED_VIDEO\n     * @see CameraDevice#createConstrainedHighSpeedCaptureSession\n     * @see android.hardware.camera2.CameraConstrainedHighSpeedCaptureSession#createHighSpeedRequestList\n     ",
    "links" : [ "CameraMetadata#REQUEST_AVAILABLE_CAPABILITIES_CONSTRAINED_HIGH_SPEED_VIDEO", "CameraCharacteristics#REQUEST_AVAILABLE_CAPABILITIES", "#getHighSpeedVideoSizesFor", "CameraDevice#createConstrainedHighSpeedCaptureSession", "android.hardware.camera2.CameraConstrainedHighSpeedCaptureSession#createHighSpeedRequestList", "CaptureRequest#CONTROL_AE_TARGET_FPS_RANGE", "#getHighSpeedVideoFpsRangesFor", "#getHighSpeedVideoSizesFor", "android.hardware.camera2.CameraConstrainedHighSpeedCaptureSession#createHighSpeedRequestList" ]
  }, {
    "name" : "public Size[] getHighSpeedVideoSizesFor(Range<Integer> fpsRange)",
    "returnType" : "Size[]",
    "comment" : "\n     * Get the supported video sizes for an input high speed FPS range.\n     *\n     * <p> See {@link #getHighSpeedVideoSizes} for how to enable high speed recording.</p>\n     *\n     * @param fpsRange one of the FPS range returned by {@link #getHighSpeedVideoFpsRanges()}\n     * @return An array of video sizes to create high speed capture sessions for high speed streaming\n     *         use cases.\n     *\n     * @throws IllegalArgumentException if input FPS range does not exist in the return value of\n     *         getHighSpeedVideoFpsRanges\n     * @see #getHighSpeedVideoFpsRanges()\n     ",
    "links" : [ "#getHighSpeedVideoSizes", "#getHighSpeedVideoFpsRanges" ]
  }, {
    "name" : "public Size[] getHighResolutionOutputSizes(int format)",
    "returnType" : "Size[]",
    "comment" : "\n     * Get a list of supported high resolution sizes, which cannot operate at full BURST_CAPTURE\n     * rate.\n     *\n     * <p>This includes all output sizes that cannot meet the 20 fps frame rate requirements for the\n     * {@link android.hardware.camera2.CameraCharacteristics#REQUEST_AVAILABLE_CAPABILITIES_BURST_CAPTURE BURST_CAPTURE}\n     * capability.  This does not include the stall duration, so for example, a JPEG or RAW16 output\n     * resolution with a large stall duration but a minimum frame duration that's above 20 fps will\n     * still be listed in the regular {@link #getOutputSizes} list. All the sizes on this list that\n     * are less than 24 megapixels are still guaranteed to operate at a rate of at least 10 fps,\n     * not including stall duration. Sizes on this list that are at least 24 megapixels are allowed\n     * to operate at less than 10 fps.</p>\n     *\n     * <p>For a device that does not support the BURST_CAPTURE capability, this list will be\n     * {@code null}, since resolutions in the {@link #getOutputSizes} list are already not\n     * guaranteed to meet &gt;= 20 fps rate requirements. For a device that does support the\n     * BURST_CAPTURE capability, this list may be empty, if all supported resolutions meet the 20\n     * fps requirement.</p>\n     *\n     * @return an array of supported slower high-resolution sizes, or {@code null} if the\n     *         BURST_CAPTURE capability is not supported\n     ",
    "links" : [ "android.hardware.camera2.CameraCharacteristics#REQUEST_AVAILABLE_CAPABILITIES_BURST_CAPTURE", "#getOutputSizes", "#getOutputSizes" ]
  }, {
    "name" : "public long getOutputMinFrameDuration(int format, Size size)",
    "returnType" : "long",
    "comment" : "\n     * Get the minimum {@link CaptureRequest#SENSOR_FRAME_DURATION frame duration}\n     * for the format/size combination (in nanoseconds).\n     *\n     * <p>{@code format} should be one of the ones returned by {@link #getOutputFormats()}.</p>\n     * <p>{@code size} should be one of the ones returned by\n     * {@link #getOutputSizes(int)}.</p>\n     *\n     * <p>This corresponds to the minimum frame duration (maximum frame rate) possible when only\n     * that stream is configured in a session, with all processing (typically in\n     * {@code android.*.mode}) set to either {@code OFF} or {@code FAST}.  </p>\n     *\n     * <p>When multiple streams are used in a session, the minimum frame duration will be\n     * {@code max(individual stream min durations)}.  See {@link #getOutputStallDuration} for\n     * details of timing for formats that may cause frame rate slowdown when they are targeted by a\n     * capture request.</p>\n     *\n     * <p>For devices that do not support manual sensor control\n     * ({@link android.hardware.camera2.CameraMetadata#REQUEST_AVAILABLE_CAPABILITIES_MANUAL_SENSOR}),\n     * this function may return 0.</p>\n     *\n     * <p>The minimum frame duration of a stream (of a particular format, size) is the same\n     * regardless of whether the stream is input or output.</p>\n     *\n     * @param format an image format from {@link ImageFormat} or {@link PixelFormat}\n     * @param size an output-compatible size\n     * @return a minimum frame duration {@code >} 0 in nanoseconds, or\n     *          0 if the minimum frame duration is not available.\n     *\n     * @throws IllegalArgumentException if {@code format} or {@code size} was not supported\n     * @throws NullPointerException if {@code size} was {@code null}\n     *\n     * @see CaptureRequest#SENSOR_FRAME_DURATION\n     * @see #getOutputStallDuration(int, Size)\n     * @see ImageFormat\n     * @see PixelFormat\n     ",
    "links" : [ "CaptureRequest#SENSOR_FRAME_DURATION", "#getOutputFormats", "#getOutputSizes", "#getOutputStallDuration", "android.hardware.camera2.CameraMetadata#REQUEST_AVAILABLE_CAPABILITIES_MANUAL_SENSOR", "ImageFormat", "PixelFormat" ]
  }, {
    "name" : "public long getOutputMinFrameDuration(final Class<T> klass, final Size size)",
    "returnType" : "long",
    "comment" : "\n     * Get the minimum {@link CaptureRequest#SENSOR_FRAME_DURATION frame duration}\n     * for the class/size combination (in nanoseconds).\n     *\n     * <p>This assumes that the {@code klass} is set up to use {@link ImageFormat#PRIVATE}.\n     * For user-defined formats, use {@link #getOutputMinFrameDuration(int, Size)}.</p>\n     *\n     * <p>{@code klass} should be one of the ones which is supported by\n     * {@link #isOutputSupportedFor(Class)}.</p>\n     *\n     * <p>{@code size} should be one of the ones returned by\n     * {@link #getOutputSizes(int)}.</p>\n     *\n     * <p>This corresponds to the minimum frame duration (maximum frame rate) possible when only\n     * that stream is configured in a session, with all processing (typically in\n     * {@code android.*.mode}) set to either {@code OFF} or {@code FAST}.  </p>\n     *\n     * <p>When multiple streams are used in a session, the minimum frame duration will be\n     * {@code max(individual stream min durations)}.  See {@link #getOutputStallDuration} for\n     * details of timing for formats that may cause frame rate slowdown when they are targeted by a\n     * capture request.</p>\n     *\n     * <p>For devices that do not support manual sensor control\n     * ({@link android.hardware.camera2.CameraMetadata#REQUEST_AVAILABLE_CAPABILITIES_MANUAL_SENSOR}),\n     * this function may return 0.</p>\n     *\n     * <p>The minimum frame duration of a stream (of a particular format, size) is the same\n     * regardless of whether the stream is input or output.</p>\n     *\n     * @param klass\n     *          a class which is supported by {@link #isOutputSupportedFor(Class)} and has a\n     *          non-empty array returned by {@link #getOutputSizes(Class)}\n     * @param size an output-compatible size\n     * @return a minimum frame duration {@code >} 0 in nanoseconds, or\n     *          0 if the minimum frame duration is not available.\n     *\n     * @throws IllegalArgumentException if {@code klass} or {@code size} was not supported\n     * @throws NullPointerException if {@code size} or {@code klass} was {@code null}\n     *\n     * @see CaptureRequest#SENSOR_FRAME_DURATION\n     * @see ImageFormat\n     * @see PixelFormat\n     ",
    "links" : [ "CaptureRequest#SENSOR_FRAME_DURATION", "ImageFormat#PRIVATE", "#getOutputMinFrameDuration", "#isOutputSupportedFor", "#getOutputSizes", "#getOutputStallDuration", "android.hardware.camera2.CameraMetadata#REQUEST_AVAILABLE_CAPABILITIES_MANUAL_SENSOR", "#isOutputSupportedFor", "#getOutputSizes" ]
  }, {
    "name" : "public long getOutputStallDuration(int format, Size size)",
    "returnType" : "long",
    "comment" : "\n     * Get the stall duration for the format/size combination (in nanoseconds).\n     *\n     * <p>{@code format} should be one of the ones returned by {@link #getOutputFormats()}.</p>\n     * <p>{@code size} should be one of the ones returned by\n     * {@link #getOutputSizes(int)}.</p>\n     *\n     * <p>\n     * A stall duration is how much extra time would get added to the normal minimum frame duration\n     * for a repeating request that has streams with non-zero stall.\n     *\n     * <p>For example, consider JPEG captures which have the following characteristics:\n     *\n     * <ul>\n     * <li>JPEG streams act like processed YUV streams in requests for which they are not included;\n     * in requests in which they are directly referenced, they act as JPEG streams.\n     * This is because supporting a JPEG stream requires the underlying YUV data to always be ready\n     * for use by a JPEG encoder, but the encoder will only be used (and impact frame duration) on\n     * requests that actually reference a JPEG stream.\n     * <li>The JPEG processor can run concurrently to the rest of the camera pipeline, but cannot\n     * process more than 1 capture at a time.\n     * </ul>\n     *\n     * <p>In other words, using a repeating YUV request would result in a steady frame rate\n     * (let's say it's 30 FPS). If a single JPEG request is submitted periodically,\n     * the frame rate will stay at 30 FPS (as long as we wait for the previous JPEG to return each\n     * time). If we try to submit a repeating YUV + JPEG request, then the frame rate will drop from\n     * 30 FPS.</p>\n     *\n     * <p>In general, submitting a new request with a non-0 stall time stream will <em>not</em> cause a\n     * frame rate drop unless there are still outstanding buffers for that stream from previous\n     * requests.</p>\n     *\n     * <p>Submitting a repeating request with streams (call this {@code S}) is the same as setting\n     * the minimum frame duration from the normal minimum frame duration corresponding to {@code S},\n     * added with the maximum stall duration for {@code S}.</p>\n     *\n     * <p>If interleaving requests with and without a stall duration, a request will stall by the\n     * maximum of the remaining times for each can-stall stream with outstanding buffers.</p>\n     *\n     * <p>This means that a stalling request will not have an exposure start until the stall has\n     * completed.</p>\n     *\n     * <p>This should correspond to the stall duration when only that stream is active, with all\n     * processing (typically in {@code android.*.mode}) set to {@code FAST} or {@code OFF}.\n     * Setting any of the processing modes to {@code HIGH_QUALITY} effectively results in an\n     * indeterminate stall duration for all streams in a request (the regular stall calculation\n     * rules are ignored).</p>\n     *\n     * <p>The following formats may always have a stall duration:\n     * <ul>\n     * <li>{@link ImageFormat#JPEG JPEG}\n     * <li>{@link ImageFormat#RAW_SENSOR RAW16}\n     * <li>{@link ImageFormat#RAW_PRIVATE RAW_PRIVATE}\n     * </ul>\n     * </p>\n     *\n     * <p>The following formats will never have a stall duration:\n     * <ul>\n     * <li>{@link ImageFormat#YUV_420_888 YUV_420_888}\n     * <li>{@link #isOutputSupportedFor(Class) Implementation-Defined}\n     * </ul></p>\n     *\n     * <p>\n     * All other formats may or may not have an allowed stall duration on a per-capability basis;\n     * refer to {@link CameraCharacteristics#REQUEST_AVAILABLE_CAPABILITIES\n     * android.request.availableCapabilities} for more details.</p>\n     * </p>\n     *\n     * <p>See {@link CaptureRequest#SENSOR_FRAME_DURATION android.sensor.frameDuration}\n     * for more information about calculating the max frame rate (absent stalls).</p>\n     *\n     * @param format an image format from {@link ImageFormat} or {@link PixelFormat}\n     * @param size an output-compatible size\n     * @return a stall duration {@code >=} 0 in nanoseconds\n     *\n     * @throws IllegalArgumentException if {@code format} or {@code size} was not supported\n     * @throws NullPointerException if {@code size} was {@code null}\n     *\n     * @see CaptureRequest#SENSOR_FRAME_DURATION\n     * @see ImageFormat\n     * @see PixelFormat\n     ",
    "links" : [ "#getOutputFormats", "#getOutputSizes", "ImageFormat#JPEG", "ImageFormat#RAW_SENSOR", "ImageFormat#RAW_PRIVATE", "ImageFormat#YUV_420_888", "#isOutputSupportedFor", "CameraCharacteristics#REQUEST_AVAILABLE_CAPABILITIES", "CaptureRequest#SENSOR_FRAME_DURATION", "ImageFormat", "PixelFormat" ]
  }, {
    "name" : "public long getOutputStallDuration(final Class<T> klass, final Size size)",
    "returnType" : "long",
    "comment" : "\n     * Get the stall duration for the class/size combination (in nanoseconds).\n     *\n     * <p>This assumes that the {@code klass} is set up to use {@link ImageFormat#PRIVATE}.\n     * For user-defined formats, use {@link #getOutputMinFrameDuration(int, Size)}.</p>\n     *\n     * <p>{@code klass} should be one of the ones with a non-empty array returned by\n     * {@link #getOutputSizes(Class)}.</p>\n     *\n     * <p>{@code size} should be one of the ones returned by\n     * {@link #getOutputSizes(Class)}.</p>\n     *\n     * <p>See {@link #getOutputStallDuration(int, Size)} for a definition of a\n     * <em>stall duration</em>.</p>\n     *\n     * @param klass\n     *          a class which is supported by {@link #isOutputSupportedFor(Class)} and has a\n     *          non-empty array returned by {@link #getOutputSizes(Class)}\n     * @param size an output-compatible size\n     * @return a minimum frame duration {@code >=} 0 in nanoseconds\n     *\n     * @throws IllegalArgumentException if {@code klass} or {@code size} was not supported\n     * @throws NullPointerException if {@code size} or {@code klass} was {@code null}\n     *\n     * @see CaptureRequest#SENSOR_FRAME_DURATION\n     * @see ImageFormat\n     * @see PixelFormat\n     ",
    "links" : [ "ImageFormat#PRIVATE", "#getOutputMinFrameDuration", "#getOutputSizes", "#getOutputSizes", "#getOutputStallDuration", "#isOutputSupportedFor", "#getOutputSizes" ]
  }, {
    "name" : "public boolean equals(final Object obj)",
    "returnType" : "boolean",
    "comment" : "\n     * Check if this {@link StreamConfigurationMap} is equal to another\n     * {@link StreamConfigurationMap}.\n     *\n     * <p>Two vectors are only equal if and only if each of the respective elements is equal.</p>\n     *\n     * @return {@code true} if the objects were equal, {@code false} otherwise\n     ",
    "links" : [ "StreamConfigurationMap", "StreamConfigurationMap" ]
  }, {
    "name" : "public int hashCode()",
    "returnType" : "int",
    "comment" : "\n     * {@inheritDoc}\n     ",
    "links" : [ ]
  }, {
    "name" : "private int checkArgumentFormatSupported(int format, boolean output)",
    "returnType" : "int",
    "comment" : " Check that the argument is supported by #getOutputFormats or #getInputFormats",
    "links" : [ ]
  }, {
    "name" : " static int checkArgumentFormatInternal(int format)",
    "returnType" : "int",
    "comment" : "\n     * Ensures that the format is either user-defined or implementation defined.\n     *\n     * <p>If a format has a different internal representation than the public representation,\n     * passing in the public representation here will fail.</p>\n     *\n     * <p>For example if trying to use {@link ImageFormat#JPEG}:\n     * it has a different public representation than the internal representation\n     * {@code HAL_PIXEL_FORMAT_BLOB}, this check will fail.</p>\n     *\n     * <p>Any invalid/undefined formats will raise an exception.</p>\n     *\n     * @param format image format\n     * @return the format\n     *\n     * @throws IllegalArgumentException if the format was invalid\n     ",
    "links" : [ "ImageFormat#JPEG" ]
  }, {
    "name" : " static int checkArgumentFormat(int format)",
    "returnType" : "int",
    "comment" : "\n     * Ensures that the format is publicly user-defined in either ImageFormat or PixelFormat.\n     *\n     * <p>If a format has a different public representation than the internal representation,\n     * passing in the internal representation here will fail.</p>\n     *\n     * <p>For example if trying to use {@code HAL_PIXEL_FORMAT_BLOB}:\n     * it has a different internal representation than the public representation\n     * {@link ImageFormat#JPEG}, this check will fail.</p>\n     *\n     * <p>Any invalid/undefined formats will raise an exception, including implementation-defined.\n     * </p>\n     *\n     * <p>Note that {@code @hide} and deprecated formats will not pass this check.</p>\n     *\n     * @param format image format\n     * @return the format\n     *\n     * @throws IllegalArgumentException if the format was not user-defined\n     ",
    "links" : [ "ImageFormat#JPEG" ]
  }, {
    "name" : "public static int imageFormatToPublic(int format)",
    "returnType" : "int",
    "comment" : "\n     * Convert an internal format compatible with {@code graphics.h} into public-visible\n     * {@code ImageFormat}. This assumes the dataspace of the format is not HAL_DATASPACE_DEPTH.\n     *\n     * <p>In particular these formats are converted:\n     * <ul>\n     * <li>HAL_PIXEL_FORMAT_BLOB => ImageFormat.JPEG</li>\n     * </ul>\n     * </p>\n     *\n     * <p>Passing in a format which has no public equivalent will fail;\n     * as will passing in a public format which has a different internal format equivalent.\n     * See {@link #checkArgumentFormat} for more details about a legal public format.</p>\n     *\n     * <p>All other formats are returned as-is, no further invalid check is performed.</p>\n     *\n     * <p>This function is the dual of {@link #imageFormatToInternal} for dataspaces other than\n     * HAL_DATASPACE_DEPTH.</p>\n     *\n     * @param format image format from {@link ImageFormat} or {@link PixelFormat}\n     * @return the converted image formats\n     *\n     * @throws IllegalArgumentException\n     *          if {@code format} is {@code HAL_PIXEL_FORMAT_IMPLEMENTATION_DEFINED} or\n     *          {@link ImageFormat#JPEG}\n     *\n     * @see ImageFormat\n     * @see PixelFormat\n     * @see #checkArgumentFormat\n     * @hide\n     ",
    "links" : [ "#checkArgumentFormat", "#imageFormatToInternal", "ImageFormat", "PixelFormat", "ImageFormat#JPEG" ]
  }, {
    "name" : "public static int depthFormatToPublic(int format)",
    "returnType" : "int",
    "comment" : "\n     * Convert an internal format compatible with {@code graphics.h} into public-visible\n     * {@code ImageFormat}. This assumes the dataspace of the format is HAL_DATASPACE_DEPTH.\n     *\n     * <p>In particular these formats are converted:\n     * <ul>\n     * <li>HAL_PIXEL_FORMAT_BLOB => ImageFormat.DEPTH_POINT_CLOUD\n     * <li>HAL_PIXEL_FORMAT_Y16 => ImageFormat.DEPTH16\n     * </ul>\n     * </p>\n     *\n     * <p>Passing in an implementation-defined format which has no public equivalent will fail;\n     * as will passing in a public format which has a different internal format equivalent.\n     * See {@link #checkArgumentFormat} for more details about a legal public format.</p>\n     *\n     * <p>All other formats are returned as-is, no further invalid check is performed.</p>\n     *\n     * <p>This function is the dual of {@link #imageFormatToInternal} for formats associated with\n     * HAL_DATASPACE_DEPTH.</p>\n     *\n     * @param format image format from {@link ImageFormat} or {@link PixelFormat}\n     * @return the converted image formats\n     *\n     * @throws IllegalArgumentException\n     *          if {@code format} is {@code HAL_PIXEL_FORMAT_IMPLEMENTATION_DEFINED} or\n     *          {@link ImageFormat#JPEG}\n     *\n     * @see ImageFormat\n     * @see PixelFormat\n     * @see #checkArgumentFormat\n     * @hide\n     ",
    "links" : [ "#checkArgumentFormat", "#imageFormatToInternal", "ImageFormat", "PixelFormat", "ImageFormat#JPEG" ]
  }, {
    "name" : " static int[] imageFormatToPublic(int[] formats)",
    "returnType" : "int[]",
    "comment" : "\n     * Convert image formats from internal to public formats (in-place).\n     *\n     * @param formats an array of image formats\n     * @return {@code formats}\n     *\n     * @see #imageFormatToPublic\n     ",
    "links" : [ ]
  }, {
    "name" : " static int imageFormatToInternal(int format)",
    "returnType" : "int",
    "comment" : "\n     * Convert a public format compatible with {@code ImageFormat} to an internal format\n     * from {@code graphics.h}.\n     *\n     * <p>In particular these formats are converted:\n     * <ul>\n     * <li>ImageFormat.JPEG => HAL_PIXEL_FORMAT_BLOB\n     * <li>ImageFormat.DEPTH_POINT_CLOUD => HAL_PIXEL_FORMAT_BLOB\n     * <li>ImageFormat.DEPTH_JPEG => HAL_PIXEL_FORMAT_BLOB\n     * <li>ImageFormat.HEIC => HAL_PIXEL_FORMAT_BLOB\n     * <li>ImageFormat.DEPTH16 => HAL_PIXEL_FORMAT_Y16\n     * </ul>\n     * </p>\n     *\n     * <p>Passing in an internal format which has a different public format equivalent will fail.\n     * See {@link #checkArgumentFormat} for more details about a legal public format.</p>\n     *\n     * <p>All other formats are returned as-is, no invalid check is performed.</p>\n     *\n     * <p>This function is the dual of {@link #imageFormatToPublic}.</p>\n     *\n     * @param format public image format from {@link ImageFormat} or {@link PixelFormat}\n     * @return the converted image formats\n     *\n     * @see ImageFormat\n     * @see PixelFormat\n     *\n     * @throws IllegalArgumentException\n     *              if {@code format} was {@code HAL_PIXEL_FORMAT_IMPLEMENTATION_DEFINED}\n     ",
    "links" : [ "#checkArgumentFormat", "#imageFormatToPublic", "ImageFormat", "PixelFormat" ]
  }, {
    "name" : " static int imageFormatToDataspace(int format)",
    "returnType" : "int",
    "comment" : "\n     * Convert a public format compatible with {@code ImageFormat} to an internal dataspace\n     * from {@code graphics.h}.\n     *\n     * <p>In particular these formats are converted:\n     * <ul>\n     * <li>ImageFormat.JPEG => HAL_DATASPACE_V0_JFIF\n     * <li>ImageFormat.DEPTH_POINT_CLOUD => HAL_DATASPACE_DEPTH\n     * <li>ImageFormat.DEPTH16 => HAL_DATASPACE_DEPTH\n     * <li>ImageFormat.DEPTH_JPEG => HAL_DATASPACE_DYNAMIC_DEPTH\n     * <li>ImageFormat.HEIC => HAL_DATASPACE_HEIF\n     * <li>others => HAL_DATASPACE_UNKNOWN\n     * </ul>\n     * </p>\n     *\n     * <p>Passing in an implementation-defined format here will fail (it's not a public format);\n     * as will passing in an internal format which has a different public format equivalent.\n     * See {@link #checkArgumentFormat} for more details about a legal public format.</p>\n     *\n     * <p>All other formats are returned as-is, no invalid check is performed.</p>\n     *\n     * <p>This function is the dual of {@link #imageFormatToPublic}.</p>\n     *\n     * @param format public image format from {@link ImageFormat} or {@link PixelFormat}\n     * @return the converted image formats\n     *\n     * @see ImageFormat\n     * @see PixelFormat\n     *\n     * @throws IllegalArgumentException\n     *              if {@code format} was {@code HAL_PIXEL_FORMAT_IMPLEMENTATION_DEFINED}\n     ",
    "links" : [ "#checkArgumentFormat", "#imageFormatToPublic", "ImageFormat", "PixelFormat" ]
  }, {
    "name" : "public static int[] imageFormatToInternal(int[] formats)",
    "returnType" : "int[]",
    "comment" : "\n     * Convert image formats from public to internal formats (in-place).\n     *\n     * @param formats an array of image formats\n     * @return {@code formats}\n     *\n     * @see #imageFormatToInternal\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "private Size[] getPublicFormatSizes(int format, boolean output, boolean highRes)",
    "returnType" : "Size[]",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private Size[] getInternalFormatSizes(int format, int dataspace, boolean output, boolean highRes)",
    "returnType" : "Size[]",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private int[] getPublicFormats(boolean output)",
    "returnType" : "int[]",
    "comment" : " Get the list of publically visible output formats; does not include IMPL_DEFINED ",
    "links" : [ ]
  }, {
    "name" : "private SparseIntArray getFormatsMap(boolean output)",
    "returnType" : "SparseIntArray",
    "comment" : " Get the format -> size count map for either output or input formats ",
    "links" : [ ]
  }, {
    "name" : "private long getInternalFormatDuration(int format, int dataspace, Size size, int duration)",
    "returnType" : "long",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private StreamConfigurationDuration[] getDurations(int duration, int dataspace)",
    "returnType" : "StreamConfigurationDuration[]",
    "comment" : "\n     * Get the durations array for the kind of duration\n     *\n     * @see #DURATION_MIN_FRAME\n     * @see #DURATION_STALL\n     * ",
    "links" : [ ]
  }, {
    "name" : "private int getPublicFormatCount(boolean output)",
    "returnType" : "int",
    "comment" : " Count the number of publicly-visible output formats ",
    "links" : [ ]
  }, {
    "name" : "private static boolean arrayContains(T[] array, T element)",
    "returnType" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private boolean isSupportedInternalConfiguration(int format, int dataspace, Size size)",
    "returnType" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public String toString()",
    "returnType" : "String",
    "comment" : "\n     * Return this {@link StreamConfigurationMap} as a string representation.\n     *\n     * <p>{@code \"StreamConfigurationMap(Outputs([w:%d, h:%d, format:%s(%d), min_duration:%d,\n     * stall:%d], ... [w:%d, h:%d, format:%s(%d), min_duration:%d, stall:%d]), Inputs([w:%d, h:%d,\n     * format:%s(%d)], ... [w:%d, h:%d, format:%s(%d)]), ValidOutputFormatsForInput(\n     * [in:%d, out:%d, ... %d], ... [in:%d, out:%d, ... %d]), HighSpeedVideoConfigurations(\n     * [w:%d, h:%d, min_fps:%d, max_fps:%d], ... [w:%d, h:%d, min_fps:%d, max_fps:%d]))\"}.</p>\n     *\n     * <p>{@code Outputs([w:%d, h:%d, format:%s(%d), min_duration:%d, stall:%d], ...\n     * [w:%d, h:%d, format:%s(%d), min_duration:%d, stall:%d])}, where\n     * {@code [w:%d, h:%d, format:%s(%d), min_duration:%d, stall:%d]} represents an output\n     * configuration's width, height, format, minimal frame duration in nanoseconds, and stall\n     * duration in nanoseconds.</p>\n     *\n     * <p>{@code Inputs([w:%d, h:%d, format:%s(%d)], ... [w:%d, h:%d, format:%s(%d)])}, where\n     * {@code [w:%d, h:%d, format:%s(%d)]} represents an input configuration's width, height, and\n     * format.</p>\n     *\n     * <p>{@code ValidOutputFormatsForInput([in:%s(%d), out:%s(%d), ... %s(%d)],\n     * ... [in:%s(%d), out:%s(%d), ... %s(%d)])}, where {@code [in:%s(%d), out:%s(%d), ... %s(%d)]}\n     * represents an input fomat and its valid output formats.</p>\n     *\n     * <p>{@code HighSpeedVideoConfigurations([w:%d, h:%d, min_fps:%d, max_fps:%d],\n     * ... [w:%d, h:%d, min_fps:%d, max_fps:%d])}, where\n     * {@code [w:%d, h:%d, min_fps:%d, max_fps:%d]} represents a high speed video output\n     * configuration's width, height, minimal frame rate, and maximal frame rate.</p>\n     *\n     * @return string representation of {@link StreamConfigurationMap}\n     ",
    "links" : [ "StreamConfigurationMap", "StreamConfigurationMap" ]
  }, {
    "name" : "private void appendOutputsString(StringBuilder sb)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private void appendHighResOutputsString(StringBuilder sb)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private void appendInputsString(StringBuilder sb)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private void appendValidOutputFormatsForInputString(StringBuilder sb)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private void appendHighSpeedVideoConfigurationsString(StringBuilder sb)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private String formatToString(int format)",
    "returnType" : "String",
    "comment" : "",
    "links" : [ ]
  } ],
  "variableNames" : [ "TAG", "HAL_PIXEL_FORMAT_RAW16", "HAL_PIXEL_FORMAT_BLOB", "HAL_PIXEL_FORMAT_IMPLEMENTATION_DEFINED", "HAL_PIXEL_FORMAT_YCbCr_420_888", "HAL_PIXEL_FORMAT_RAW_OPAQUE", "HAL_PIXEL_FORMAT_RAW10", "HAL_PIXEL_FORMAT_RAW12", "HAL_PIXEL_FORMAT_Y16", "HAL_DATASPACE_STANDARD_SHIFT", "HAL_DATASPACE_TRANSFER_SHIFT", "HAL_DATASPACE_RANGE_SHIFT", "HAL_DATASPACE_UNKNOWN", "HAL_DATASPACE_V0_JFIF", "HAL_DATASPACE_DEPTH", "HAL_DATASPACE_DYNAMIC_DEPTH", "HAL_DATASPACE_HEIF", "DURATION_20FPS_NS", "DURATION_MIN_FRAME", "DURATION_STALL", "mConfigurations", "mMinFrameDurations", "mStallDurations", "mDepthConfigurations", "mDepthMinFrameDurations", "mDepthStallDurations", "mDynamicDepthConfigurations", "mDynamicDepthMinFrameDurations", "mDynamicDepthStallDurations", "mHeicConfigurations", "mHeicMinFrameDurations", "mHeicStallDurations", "mHighSpeedVideoConfigurations", "mInputOutputFormatsMap", "mListHighResolution", "mOutputFormats", "mHighResOutputFormats", "mAllOutputFormats", "mInputFormats", "mDepthOutputFormats", "mDynamicDepthOutputFormats", "mHeicOutputFormats", "mHighSpeedVideoSizeMap", "mHighSpeedVideoFpsRangeMap" ],
  "methodNames" : [ "public int[] getOutputFormats()", "public int[] getValidOutputFormatsForInput(int inputFormat)", "public int[] getInputFormats()", "public Size[] getInputSizes(final int format)", "public boolean isOutputSupportedFor(int format)", "public static boolean isOutputSupportedFor(Class<T> klass)", "public boolean isOutputSupportedFor(Surface surface)", "public boolean isOutputSupportedFor(Size size, int format)", "public Size[] getOutputSizes(Class<T> klass)", "public Size[] getOutputSizes(int format)", "public Size[] getHighSpeedVideoSizes()", "public Range<Integer>[] getHighSpeedVideoFpsRangesFor(Size size)", "public Range<Integer>[] getHighSpeedVideoFpsRanges()", "public Size[] getHighSpeedVideoSizesFor(Range<Integer> fpsRange)", "public Size[] getHighResolutionOutputSizes(int format)", "public long getOutputMinFrameDuration(int format, Size size)", "public long getOutputMinFrameDuration(final Class<T> klass, final Size size)", "public long getOutputStallDuration(int format, Size size)", "public long getOutputStallDuration(final Class<T> klass, final Size size)", "public boolean equals(final Object obj)", "public int hashCode()", "private int checkArgumentFormatSupported(int format, boolean output)", " static int checkArgumentFormatInternal(int format)", " static int checkArgumentFormat(int format)", "public static int imageFormatToPublic(int format)", "public static int depthFormatToPublic(int format)", " static int[] imageFormatToPublic(int[] formats)", " static int imageFormatToInternal(int format)", " static int imageFormatToDataspace(int format)", "public static int[] imageFormatToInternal(int[] formats)", "private Size[] getPublicFormatSizes(int format, boolean output, boolean highRes)", "private Size[] getInternalFormatSizes(int format, int dataspace, boolean output, boolean highRes)", "private int[] getPublicFormats(boolean output)", "private SparseIntArray getFormatsMap(boolean output)", "private long getInternalFormatDuration(int format, int dataspace, Size size, int duration)", "private StreamConfigurationDuration[] getDurations(int duration, int dataspace)", "private int getPublicFormatCount(boolean output)", "private static boolean arrayContains(T[] array, T element)", "private boolean isSupportedInternalConfiguration(int format, int dataspace, Size size)", "public String toString()", "private void appendOutputsString(StringBuilder sb)", "private void appendHighResOutputsString(StringBuilder sb)", "private void appendInputsString(StringBuilder sb)", "private void appendValidOutputFormatsForInputString(StringBuilder sb)", "private void appendHighSpeedVideoConfigurationsString(StringBuilder sb)", "private String formatToString(int format)" ]
}