{
  "filePath" : "/home/maryam/clearblue/files/android-source-35/java/lang/invoke/MethodHandle.java",
  "packageName" : "java.lang.invoke",
  "className" : "MethodHandle",
  "comment" : "\n * A method handle is a typed, directly executable reference to an underlying method,\n * constructor, field, or similar low-level operation, with optional\n * transformations of arguments or return values.\n * These transformations are quite general, and include such patterns as\n * {@linkplain #asType conversion},\n * {@linkplain #bindTo insertion},\n * {@linkplain java.lang.invoke.MethodHandles#dropArguments deletion},\n * and {@linkplain java.lang.invoke.MethodHandles#filterArguments substitution}.\n *\n * <h1>Method handle contents</h1>\n * Method handles are dynamically and strongly typed according to their parameter and return types.\n * They are not distinguished by the name or the defining class of their underlying methods.\n * A method handle must be invoked using a symbolic type descriptor which matches\n * the method handle's own {@linkplain #type type descriptor}.\n * <p>\n * Every method handle reports its type descriptor via the {@link #type type} accessor.\n * This type descriptor is a {@link java.lang.invoke.MethodType MethodType} object,\n * whose structure is a series of classes, one of which is\n * the return type of the method (or {@code void.class} if none).\n * <p>\n * A method handle's type controls the types of invocations it accepts,\n * and the kinds of transformations that apply to it.\n * <p>\n * A method handle contains a pair of special invoker methods\n * called {@link #invokeExact invokeExact} and {@link #invoke invoke}.\n * Both invoker methods provide direct access to the method handle's\n * underlying method, constructor, field, or other operation,\n * as modified by transformations of arguments and return values.\n * Both invokers accept calls which exactly match the method handle's own type.\n * The plain, inexact invoker also accepts a range of other call types.\n * <p>\n * Method handles are immutable and have no visible state.\n * Of course, they can be bound to underlying methods or data which exhibit state.\n * With respect to the Java Memory Model, any method handle will behave\n * as if all of its (internal) fields are final variables.  This means that any method\n * handle made visible to the application will always be fully formed.\n * This is true even if the method handle is published through a shared\n * variable in a data race.\n * <p>\n * Method handles cannot be subclassed by the user.\n * Implementations may (or may not) create internal subclasses of {@code MethodHandle}\n * which may be visible via the {@link java.lang.Object#getClass Object.getClass}\n * operation.  The programmer should not draw conclusions about a method handle\n * from its specific class, as the method handle class hierarchy (if any)\n * may change from time to time or across implementations from different vendors.\n *\n * <h1>Method handle compilation</h1>\n * A Java method call expression naming {@code invokeExact} or {@code invoke}\n * can invoke a method handle from Java source code.\n * From the viewpoint of source code, these methods can take any arguments\n * and their result can be cast to any return type.\n * Formally this is accomplished by giving the invoker methods\n * {@code Object} return types and variable arity {@code Object} arguments,\n * but they have an additional quality called <em>signature polymorphism</em>\n * which connects this freedom of invocation directly to the JVM execution stack.\n * <p>\n * As is usual with virtual methods, source-level calls to {@code invokeExact}\n * and {@code invoke} compile to an {@code invokevirtual} instruction.\n * More unusually, the compiler must record the actual argument types,\n * and may not perform method invocation conversions on the arguments.\n * Instead, it must push them on the stack according to their own unconverted types.\n * The method handle object itself is pushed on the stack before the arguments.\n * The compiler then calls the method handle with a symbolic type descriptor which\n * describes the argument and return types.\n * <p>\n * To issue a complete symbolic type descriptor, the compiler must also determine\n * the return type.  This is based on a cast on the method invocation expression,\n * if there is one, or else {@code Object} if the invocation is an expression\n * or else {@code void} if the invocation is a statement.\n * The cast may be to a primitive type (but not {@code void}).\n * <p>\n * As a corner case, an uncasted {@code null} argument is given\n * a symbolic type descriptor of {@code java.lang.Void}.\n * The ambiguity with the type {@code Void} is harmless, since there are no references of type\n * {@code Void} except the null reference.\n *\n * <h1>Method handle invocation</h1>\n * The first time a {@code invokevirtual} instruction is executed\n * it is linked, by symbolically resolving the names in the instruction\n * and verifying that the method call is statically legal.\n * This is true of calls to {@code invokeExact} and {@code invoke}.\n * In this case, the symbolic type descriptor emitted by the compiler is checked for\n * correct syntax and names it contains are resolved.\n * Thus, an {@code invokevirtual} instruction which invokes\n * a method handle will always link, as long\n * as the symbolic type descriptor is syntactically well-formed\n * and the types exist.\n * <p>\n * When the {@code invokevirtual} is executed after linking,\n * the receiving method handle's type is first checked by the JVM\n * to ensure that it matches the symbolic type descriptor.\n * If the type match fails, it means that the method which the\n * caller is invoking is not present on the individual\n * method handle being invoked.\n * <p>\n * In the case of {@code invokeExact}, the type descriptor of the invocation\n * (after resolving symbolic type names) must exactly match the method type\n * of the receiving method handle.\n * In the case of plain, inexact {@code invoke}, the resolved type descriptor\n * must be a valid argument to the receiver's {@link #asType asType} method.\n * Thus, plain {@code invoke} is more permissive than {@code invokeExact}.\n * <p>\n * After type matching, a call to {@code invokeExact} directly\n * and immediately invoke the method handle's underlying method\n * (or other behavior, as the case may be).\n * <p>\n * A call to plain {@code invoke} works the same as a call to\n * {@code invokeExact}, if the symbolic type descriptor specified by the caller\n * exactly matches the method handle's own type.\n * If there is a type mismatch, {@code invoke} attempts\n * to adjust the type of the receiving method handle,\n * as if by a call to {@link #asType asType},\n * to obtain an exactly invokable method handle {@code M2}.\n * This allows a more powerful negotiation of method type\n * between caller and callee.\n * <p>\n * (<em>Note:</em> The adjusted method handle {@code M2} is not directly observable,\n * and implementations are therefore not required to materialize it.)\n *\n * <h1>Invocation checking</h1>\n * In typical programs, method handle type matching will usually succeed.\n * But if a match fails, the JVM will throw a {@link WrongMethodTypeException},\n * either directly (in the case of {@code invokeExact}) or indirectly as if\n * by a failed call to {@code asType} (in the case of {@code invoke}).\n * <p>\n * Thus, a method type mismatch which might show up as a linkage error\n * in a statically typed program can show up as\n * a dynamic {@code WrongMethodTypeException}\n * in a program which uses method handles.\n * <p>\n * Because method types contain \"live\" {@code Class} objects,\n * method type matching takes into account both types names and class loaders.\n * Thus, even if a method handle {@code M} is created in one\n * class loader {@code L1} and used in another {@code L2},\n * method handle calls are type-safe, because the caller's symbolic type\n * descriptor, as resolved in {@code L2},\n * is matched against the original callee method's symbolic type descriptor,\n * as resolved in {@code L1}.\n * The resolution in {@code L1} happens when {@code M} is created\n * and its type is assigned, while the resolution in {@code L2} happens\n * when the {@code invokevirtual} instruction is linked.\n * <p>\n * Apart from the checking of type descriptors,\n * a method handle's capability to call its underlying method is unrestricted.\n * If a method handle is formed on a non-public method by a class\n * that has access to that method, the resulting handle can be used\n * in any place by any caller who receives a reference to it.\n * <p>\n * Unlike with the Core Reflection API, where access is checked every time\n * a reflective method is invoked,\n * method handle access checking is performed\n * <a href=\"MethodHandles.Lookup.html#access\">when the method handle is created</a>.\n * In the case of {@code ldc} (see below), access checking is performed as part of linking\n * the constant pool entry underlying the constant method handle.\n * <p>\n * Thus, handles to non-public methods, or to methods in non-public classes,\n * should generally be kept secret.\n * They should not be passed to untrusted code unless their use from\n * the untrusted code would be harmless.\n *\n * <h1>Method handle creation</h1>\n * Java code can create a method handle that directly accesses\n * any method, constructor, or field that is accessible to that code.\n * This is done via a reflective, capability-based API called\n * {@link java.lang.invoke.MethodHandles.Lookup MethodHandles.Lookup}\n * For example, a static method handle can be obtained\n * from {@link java.lang.invoke.MethodHandles.Lookup#findStatic Lookup.findStatic}.\n * There are also conversion methods from Core Reflection API objects,\n * such as {@link java.lang.invoke.MethodHandles.Lookup#unreflect Lookup.unreflect}.\n * <p>\n * Like classes and strings, method handles that correspond to accessible\n * fields, methods, and constructors can also be represented directly\n * in a class file's constant pool as constants to be loaded by {@code ldc} bytecodes.\n * A new type of constant pool entry, {@code CONSTANT_MethodHandle},\n * refers directly to an associated {@code CONSTANT_Methodref},\n * {@code CONSTANT_InterfaceMethodref}, or {@code CONSTANT_Fieldref}\n * constant pool entry.\n * (For full details on method handle constants,\n * see sections 4.4.8 and 5.4.3.5 of the Java Virtual Machine Specification.)\n * <p>\n * Method handles produced by lookups or constant loads from methods or\n * constructors with the variable arity modifier bit ({@code 0x0080})\n * have a corresponding variable arity, as if they were defined with\n * the help of {@link #asVarargsCollector asVarargsCollector}.\n * <p>\n * A method reference may refer either to a static or non-static method.\n * In the non-static case, the method handle type includes an explicit\n * receiver argument, prepended before any other arguments.\n * In the method handle's type, the initial receiver argument is typed\n * according to the class under which the method was initially requested.\n * (E.g., if a non-static method handle is obtained via {@code ldc},\n * the type of the receiver is the class named in the constant pool entry.)\n * <p>\n * Method handle constants are subject to the same link-time access checks\n * their corresponding bytecode instructions, and the {@code ldc} instruction\n * will throw corresponding linkage errors if the bytecode behaviors would\n * throw such errors.\n * <p>\n * As a corollary of this, access to protected members is restricted\n * to receivers only of the accessing class, or one of its subclasses,\n * and the accessing class must in turn be a subclass (or package sibling)\n * of the protected member's defining class.\n * If a method reference refers to a protected non-static method or field\n * of a class outside the current package, the receiver argument will\n * be narrowed to the type of the accessing class.\n * <p>\n * When a method handle to a virtual method is invoked, the method is\n * always looked up in the receiver (that is, the first argument).\n * <p>\n * A non-virtual method handle to a specific virtual method implementation\n * can also be created.  These do not perform virtual lookup based on\n * receiver type.  Such a method handle simulates the effect of\n * an {@code invokespecial} instruction to the same method.\n *\n * <h1>Usage examples</h1>\n * Here are some examples of usage:\n * <blockquote><pre>{@code\nObject x, y; String s; int i;\nMethodType mt; MethodHandle mh;\nMethodHandles.Lookup lookup = MethodHandles.lookup();\n// mt is (char,char)String\nmt = MethodType.methodType(String.class, char.class, char.class);\nmh = lookup.findVirtual(String.class, \"replace\", mt);\ns = (String) mh.invokeExact(\"daddy\",'d','n');\n// invokeExact(Ljava/lang/String;CC)Ljava/lang/String;\nassertEquals(s, \"nanny\");\n// weakly typed invocation (using MHs.invoke)\ns = (String) mh.invokeWithArguments(\"sappy\", 'p', 'v');\nassertEquals(s, \"savvy\");\n// mt is (Object[])List\nmt = MethodType.methodType(java.util.List.class, Object[].class);\nmh = lookup.findStatic(java.util.Arrays.class, \"asList\", mt);\nassert(mh.isVarargsCollector());\nx = mh.invoke(\"one\", \"two\");\n// invoke(Ljava/lang/String;Ljava/lang/String;)Ljava/lang/Object;\nassertEquals(x, java.util.Arrays.asList(\"one\",\"two\"));\n// mt is (Object,Object,Object)Object\nmt = MethodType.genericMethodType(3);\nmh = mh.asType(mt);\nx = mh.invokeExact((Object)1, (Object)2, (Object)3);\n// invokeExact(Ljava/lang/Object;Ljava/lang/Object;Ljava/lang/Object;)Ljava/lang/Object;\nassertEquals(x, java.util.Arrays.asList(1,2,3));\n// mt is ()int\nmt = MethodType.methodType(int.class);\nmh = lookup.findVirtual(java.util.List.class, \"size\", mt);\ni = (int) mh.invokeExact(java.util.Arrays.asList(1,2,3));\n// invokeExact(Ljava/util/List;)I\nassert(i == 3);\nmt = MethodType.methodType(void.class, String.class);\nmh = lookup.findVirtual(java.io.PrintStream.class, \"println\", mt);\nmh.invokeExact(System.out, \"Hello, world.\");\n// invokeExact(Ljava/io/PrintStream;Ljava/lang/String;)V\n * }</pre></blockquote>\n * Each of the above calls to {@code invokeExact} or plain {@code invoke}\n * generates a single invokevirtual instruction with\n * the symbolic type descriptor indicated in the following comment.\n * In these examples, the helper method {@code assertEquals} is assumed to\n * be a method which calls {@link java.util.Objects#equals(Object,Object) Objects.equals}\n * on its arguments, and asserts that the result is true.\n *\n * <h1>Exceptions</h1>\n * The methods {@code invokeExact} and {@code invoke} are declared\n * to throw {@link java.lang.Throwable Throwable},\n * which is to say that there is no static restriction on what a method handle\n * can throw.  Since the JVM does not distinguish between checked\n * and unchecked exceptions (other than by their class, of course),\n * there is no particular effect on bytecode shape from ascribing\n * checked exceptions to method handle invocations.  But in Java source\n * code, methods which perform method handle calls must either explicitly\n * throw {@code Throwable}, or else must catch all\n * throwables locally, rethrowing only those which are legal in the context,\n * and wrapping ones which are illegal.\n *\n * <h1><a name=\"sigpoly\"></a>Signature polymorphism</h1>\n * The unusual compilation and linkage behavior of\n * {@code invokeExact} and plain {@code invoke}\n * is referenced by the term <em>signature polymorphism</em>.\n * As defined in the Java Language Specification,\n * a signature polymorphic method is one which can operate with\n * any of a wide range of call signatures and return types.\n * <p>\n * In source code, a call to a signature polymorphic method will\n * compile, regardless of the requested symbolic type descriptor.\n * As usual, the Java compiler emits an {@code invokevirtual}\n * instruction with the given symbolic type descriptor against the named method.\n * The unusual part is that the symbolic type descriptor is derived from\n * the actual argument and return types, not from the method declaration.\n * <p>\n * When the JVM processes bytecode containing signature polymorphic calls,\n * it will successfully link any such call, regardless of its symbolic type descriptor.\n * (In order to retain type safety, the JVM will guard such calls with suitable\n * dynamic type checks, as described elsewhere.)\n * <p>\n * Bytecode generators, including the compiler back end, are required to emit\n * untransformed symbolic type descriptors for these methods.\n * Tools which determine symbolic linkage are required to accept such\n * untransformed descriptors, without reporting linkage errors.\n *\n * <h1>Interoperation between method handles and the Core Reflection API</h1>\n * Using factory methods in the {@link java.lang.invoke.MethodHandles.Lookup Lookup} API,\n * any class member represented by a Core Reflection API object\n * can be converted to a behaviorally equivalent method handle.\n * For example, a reflective {@link java.lang.reflect.Method Method} can\n * be converted to a method handle using\n * {@link java.lang.invoke.MethodHandles.Lookup#unreflect Lookup.unreflect}.\n * The resulting method handles generally provide more direct and efficient\n * access to the underlying class members.\n * <p>\n * As a special case,\n * when the Core Reflection API is used to view the signature polymorphic\n * methods {@code invokeExact} or plain {@code invoke} in this class,\n * they appear as ordinary non-polymorphic methods.\n * Their reflective appearance, as viewed by\n * {@link java.lang.Class#getDeclaredMethod Class.getDeclaredMethod},\n * is unaffected by their special status in this API.\n * For example, {@link java.lang.reflect.Method#getModifiers Method.getModifiers}\n * will report exactly those modifier bits required for any similarly\n * declared method, including in this case {@code native} and {@code varargs} bits.\n * <p>\n * As with any reflected method, these methods (when reflected) may be\n * invoked via {@link java.lang.reflect.Method#invoke java.lang.reflect.Method.invoke}.\n * However, such reflective calls do not result in method handle invocations.\n * Such a call, if passed the required argument\n * (a single one, of type {@code Object[]}), will ignore the argument and\n * will throw an {@code UnsupportedOperationException}.\n * <p>\n * Since {@code invokevirtual} instructions can natively\n * invoke method handles under any symbolic type descriptor, this reflective view conflicts\n * with the normal presentation of these methods via bytecodes.\n * Thus, these two native methods, when reflectively viewed by\n * {@code Class.getDeclaredMethod}, may be regarded as placeholders only.\n * <p>\n * In order to obtain an invoker method for a particular type descriptor,\n * use {@link java.lang.invoke.MethodHandles#exactInvoker MethodHandles.exactInvoker},\n * or {@link java.lang.invoke.MethodHandles#invoker MethodHandles.invoker}.\n * The {@link java.lang.invoke.MethodHandles.Lookup#findVirtual Lookup.findVirtual}\n * API is also able to return a method handle\n * to call {@code invokeExact} or plain {@code invoke},\n * for any specified type descriptor .\n *\n * <h1>Interoperation between method handles and Java generics</h1>\n * A method handle can be obtained on a method, constructor, or field\n * which is declared with Java generic types.\n * As with the Core Reflection API, the type of the method handle\n * will constructed from the erasure of the source-level type.\n * When a method handle is invoked, the types of its arguments\n * or the return value cast type may be generic types or type instances.\n * If this occurs, the compiler will replace those\n * types by their erasures when it constructs the symbolic type descriptor\n * for the {@code invokevirtual} instruction.\n * <p>\n * Method handles do not represent\n * their function-like types in terms of Java parameterized (generic) types,\n * because there are three mismatches between function-like types and parameterized\n * Java types.\n * <ul>\n * <li>Method types range over all possible arities,\n * from no arguments to up to the  <a href=\"MethodHandle.html#maxarity\">maximum number</a> of allowed arguments.\n * Generics are not variadic, and so cannot represent this.</li>\n * <li>Method types can specify arguments of primitive types,\n * which Java generic types cannot range over.</li>\n * <li>Higher order functions over method handles (combinators) are\n * often generic across a wide range of function types, including\n * those of multiple arities.  It is impossible to represent such\n * genericity with a Java type parameter.</li>\n * </ul>\n *\n * <h1><a name=\"maxarity\"></a>Arity limits</h1>\n * The JVM imposes on all methods and constructors of any kind an absolute\n * limit of 255 stacked arguments.  This limit can appear more restrictive\n * in certain cases:\n * <ul>\n * <li>A {@code long} or {@code double} argument counts (for purposes of arity limits) as two argument slots.\n * <li>A non-static method consumes an extra argument for the object on which the method is called.\n * <li>A constructor consumes an extra argument for the object which is being constructed.\n * <li>Since a method handle&rsquo;s {@code invoke} method (or other signature-polymorphic method) is non-virtual,\n *     it consumes an extra argument for the method handle itself, in addition to any non-virtual receiver object.\n * </ul>\n * These limits imply that certain method handles cannot be created, solely because of the JVM limit on stacked arguments.\n * For example, if a static JVM method accepts exactly 255 arguments, a method handle cannot be created for it.\n * Attempts to create method handles with impossible method types lead to an {@link IllegalArgumentException}.\n * In particular, a method handle&rsquo;s type must not have an arity of the exact maximum 255.\n *\n * @see MethodType\n * @see MethodHandles\n * @author John Rose, JSR 292 EG\n ",
  "links" : [ "java.lang.Throwable", "java.lang.invoke.WrongMethodTypeException", "java.lang.Class#getDeclaredMethod", "java.lang.invoke.MethodHandles.Lookup#findVirtual", "java.util.Objects#equals(Object", "java.lang.invoke.MethodHandles#exactInvoker", "java.lang.Object#getClass", "java.lang.invoke.MethodHandles#invoker", "#invokeExact", "java.lang.invoke.MethodHandles.Lookup", "java.lang.invoke.MethodType", "#asType", "java.lang.invoke.MethodHandles.Lookup#findStatic", "#invoke", "java.lang.invoke.MethodHandles.Lookup#unreflect", "java.lang.reflect.Method#invoke", "java.lang.reflect.Method", "#type", "IllegalArgumentException", "#asVarargsCollector", "java.lang.reflect.Method#getModifiers" ],
  "variables" : [ {
    "name" : "type",
    "type" : "MethodType",
    "comment" : "\n     * The type of this method handle, this corresponds to the exact type of the method\n     * being invoked.\n     ",
    "links" : [ ]
  }, {
    "name" : "asTypeCache",
    "type" : "MethodHandle",
    "comment" : "private",
    "links" : [ ]
  }, {
    "name" : "cachedSpreadInvoker",
    "type" : "MethodHandle",
    "comment" : "\n     * The spread invoker associated with this type with zero trailing arguments.\n     * This is used to speed up invokeWithArguments.\n     ",
    "links" : [ ]
  }, {
    "name" : "INVOKE_VIRTUAL",
    "type" : "int",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "INVOKE_SUPER",
    "type" : "int",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "INVOKE_DIRECT",
    "type" : "int",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "INVOKE_STATIC",
    "type" : "int",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "INVOKE_INTERFACE",
    "type" : "int",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "INVOKE_TRANSFORM",
    "type" : "int",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "INVOKE_VAR_HANDLE",
    "type" : "int",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "INVOKE_VAR_HANDLE_EXACT",
    "type" : "int",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "IGET",
    "type" : "int",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "IPUT",
    "type" : "int",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "SGET",
    "type" : "int",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "SPUT",
    "type" : "int",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "handleKind",
    "type" : "int",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "artFieldOrMethod",
    "type" : "long",
    "comment" : " @hide ",
    "links" : [ ]
  } ],
  "methods" : [ {
    "name" : "public MethodType type()",
    "returnType" : "MethodType",
    "comment" : "\n     * Reports the type of this method handle.\n     * Every invocation of this method handle via {@code invokeExact} must exactly match this type.\n     * @return the method handle type\n     ",
    "links" : [ ]
  }, {
    "name" : "public final native Object invokeExact(Object... args) throws Throwable",
    "returnType" : "Object",
    "comment" : "\n     * Invokes the method handle, allowing any caller type descriptor, but requiring an exact type match.\n     * The symbolic type descriptor at the call site of {@code invokeExact} must\n     * exactly match this method handle's {@link #type type}.\n     * No conversions are allowed on arguments or return values.\n     * <p>\n     * When this method is observed via the Core Reflection API,\n     * it will appear as a single native method, taking an object array and returning an object.\n     * If this native method is invoked directly via\n     * {@link java.lang.reflect.Method#invoke java.lang.reflect.Method.invoke}, via JNI,\n     * or indirectly via {@link java.lang.invoke.MethodHandles.Lookup#unreflect Lookup.unreflect},\n     * it will throw an {@code UnsupportedOperationException}.\n     * @param args the signature-polymorphic parameter list, statically represented using varargs\n     * @return the signature-polymorphic result, statically represented using {@code Object}\n     * @throws WrongMethodTypeException if the target's type is not identical with the caller's symbolic type descriptor\n     * @throws Throwable anything thrown by the underlying method propagates unchanged through the method handle call\n     ",
    "links" : [ "java.lang.invoke.MethodHandles.Lookup#unreflect", "java.lang.reflect.Method#invoke", "#type" ]
  }, {
    "name" : "public final native Object invoke(Object... args) throws Throwable",
    "returnType" : "Object",
    "comment" : "\n     * Invokes the method handle, allowing any caller type descriptor,\n     * and optionally performing conversions on arguments and return values.\n     * <p>\n     * If the call site's symbolic type descriptor exactly matches this method handle's {@link #type type},\n     * the call proceeds as if by {@link #invokeExact invokeExact}.\n     * <p>\n     * Otherwise, the call proceeds as if this method handle were first\n     * adjusted by calling {@link #asType asType} to adjust this method handle\n     * to the required type, and then the call proceeds as if by\n     * {@link #invokeExact invokeExact} on the adjusted method handle.\n     * <p>\n     * There is no guarantee that the {@code asType} call is actually made.\n     * If the JVM can predict the results of making the call, it may perform\n     * adaptations directly on the caller's arguments,\n     * and call the target method handle according to its own exact type.\n     * <p>\n     * The resolved type descriptor at the call site of {@code invoke} must\n     * be a valid argument to the receivers {@code asType} method.\n     * In particular, the caller must specify the same argument arity\n     * as the callee's type,\n     * if the callee is not a {@linkplain #asVarargsCollector variable arity collector}.\n     * <p>\n     * When this method is observed via the Core Reflection API,\n     * it will appear as a single native method, taking an object array and returning an object.\n     * If this native method is invoked directly via\n     * {@link java.lang.reflect.Method#invoke java.lang.reflect.Method.invoke}, via JNI,\n     * or indirectly via {@link java.lang.invoke.MethodHandles.Lookup#unreflect Lookup.unreflect},\n     * it will throw an {@code UnsupportedOperationException}.\n     * @param args the signature-polymorphic parameter list, statically represented using varargs\n     * @return the signature-polymorphic result, statically represented using {@code Object}\n     * @throws WrongMethodTypeException if the target's type cannot be adjusted to the caller's symbolic type descriptor\n     * @throws ClassCastException if the target's type can be adjusted to the caller, but a reference cast fails\n     * @throws Throwable anything thrown by the underlying method propagates unchanged through the method handle call\n     ",
    "links" : [ "#asType", "java.lang.invoke.MethodHandles.Lookup#unreflect", "java.lang.reflect.Method#invoke", "#type", "#invokeExact" ]
  }, {
    "name" : "public Object invokeWithArguments(Object... arguments) throws Throwable",
    "returnType" : "Object",
    "comment" : "\n     * Performs a variable arity invocation, passing the arguments in the given list\n     * to the method handle, as if via an inexact {@link #invoke invoke} from a call site\n     * which mentions only the type {@code Object}, and whose arity is the length\n     * of the argument list.\n     * <p>\n     * Specifically, execution proceeds as if by the following steps,\n     * although the methods are not guaranteed to be called if the JVM\n     * can predict their effects.\n     * <ul>\n     * <li>Determine the length of the argument array as {@code N}.\n     *     For a null reference, {@code N=0}. </li>\n     * <li>Determine the general type {@code TN} of {@code N} arguments as\n     *     as {@code TN=MethodType.genericMethodType(N)}.</li>\n     * <li>Force the original target method handle {@code MH0} to the\n     *     required type, as {@code MH1 = MH0.asType(TN)}. </li>\n     * <li>Spread the array into {@code N} separate arguments {@code A0, ...}. </li>\n     * <li>Invoke the type-adjusted method handle on the unpacked arguments:\n     *     MH1.invokeExact(A0, ...). </li>\n     * <li>Take the return value as an {@code Object} reference. </li>\n     * </ul>\n     * <p>\n     * Because of the action of the {@code asType} step, the following argument\n     * conversions are applied as necessary:\n     * <ul>\n     * <li>reference casting\n     * <li>unboxing\n     * <li>widening primitive conversions\n     * </ul>\n     * <p>\n     * The result returned by the call is boxed if it is a primitive,\n     * or forced to null if the return type is void.\n     * <p>\n     * This call is equivalent to the following code:\n     * <blockquote><pre>{@code\n     * MethodHandle invoker = MethodHandles.spreadInvoker(this.type(), 0);\n     * Object result = invoker.invokeExact(this, arguments);\n     * }</pre></blockquote>\n     * <p>\n     * Unlike the signature polymorphic methods {@code invokeExact} and {@code invoke},\n     * {@code invokeWithArguments} can be accessed normally via the Core Reflection API and JNI.\n     * It can therefore be used as a bridge between native or reflective code and method handles.\n     *\n     * @param arguments the arguments to pass to the target\n     * @return the result returned by the target\n     * @throws ClassCastException if an argument cannot be converted by reference casting\n     * @throws WrongMethodTypeException if the target's type cannot be adjusted to take the given number of {@code Object} arguments\n     * @throws Throwable anything thrown by the target method invocation\n     * @see MethodHandles#spreadInvoker\n     ",
    "links" : [ "#invoke" ]
  }, {
    "name" : "public Object invokeWithArguments(java.util.List<?> arguments) throws Throwable",
    "returnType" : "Object",
    "comment" : "\n     * Performs a variable arity invocation, passing the arguments in the given array\n     * to the method handle, as if via an inexact {@link #invoke invoke} from a call site\n     * which mentions only the type {@code Object}, and whose arity is the length\n     * of the argument array.\n     * <p>\n     * This method is also equivalent to the following code:\n     * <blockquote><pre>{@code\n     *   invokeWithArguments(arguments.toArray()\n     * }</pre></blockquote>\n     *\n     * @param arguments the arguments to pass to the target\n     * @return the result returned by the target\n     * @throws NullPointerException if {@code arguments} is a null reference\n     * @throws ClassCastException if an argument cannot be converted by reference casting\n     * @throws WrongMethodTypeException if the target's type cannot be adjusted to take the given number of {@code Object} arguments\n     * @throws Throwable anything thrown by the target method invocation\n     ",
    "links" : [ "#invoke" ]
  }, {
    "name" : "public MethodHandle asType(MethodType newType)",
    "returnType" : "MethodHandle",
    "comment" : "\n     * Produces an adapter method handle which adapts the type of the\n     * current method handle to a new type.\n     * The resulting method handle is guaranteed to report a type\n     * which is equal to the desired new type.\n     * <p>\n     * If the original type and new type are equal, returns {@code this}.\n     * <p>\n     * The new method handle, when invoked, will perform the following\n     * steps:\n     * <ul>\n     * <li>Convert the incoming argument list to match the original\n     *     method handle's argument list.\n     * <li>Invoke the original method handle on the converted argument list.\n     * <li>Convert any result returned by the original method handle\n     *     to the return type of new method handle.\n     * </ul>\n     * <p>\n     * This method provides the crucial behavioral difference between\n     * {@link #invokeExact invokeExact} and plain, inexact {@link #invoke invoke}.\n     * The two methods\n     * perform the same steps when the caller's type descriptor exactly m atches\n     * the callee's, but when the types differ, plain {@link #invoke invoke}\n     * also calls {@code asType} (or some internal equivalent) in order\n     * to match up the caller's and callee's types.\n     * <p>\n     * If the current method is a variable arity method handle\n     * argument list conversion may involve the conversion and collection\n     * of several arguments into an array, as\n     * {@linkplain #asVarargsCollector described elsewhere}.\n     * In every other case, all conversions are applied <em>pairwise</em>,\n     * which means that each argument or return value is converted to\n     * exactly one argument or return value (or no return value).\n     * The applied conversions are defined by consulting the\n     * the corresponding component types of the old and new\n     * method handle types.\n     * <p>\n     * Let <em>T0</em> and <em>T1</em> be corresponding new and old parameter types,\n     * or old and new return types.  Specifically, for some valid index {@code i}, let\n     * <em>T0</em>{@code =newType.parameterType(i)} and <em>T1</em>{@code =this.type().parameterType(i)}.\n     * Or else, going the other way for return values, let\n     * <em>T0</em>{@code =this.type().returnType()} and <em>T1</em>{@code =newType.returnType()}.\n     * If the types are the same, the new method handle makes no change\n     * to the corresponding argument or return value (if any).\n     * Otherwise, one of the following conversions is applied\n     * if possible:\n     * <ul>\n     * <li>If <em>T0</em> and <em>T1</em> are references, then a cast to <em>T1</em> is applied.\n     *     (The types do not need to be related in any particular way.\n     *     This is because a dynamic value of null can convert to any reference type.)\n     * <li>If <em>T0</em> and <em>T1</em> are primitives, then a Java method invocation\n     *     conversion (JLS 5.3) is applied, if one exists.\n     *     (Specifically, <em>T0</em> must convert to <em>T1</em> by a widening primitive conversion.)\n     * <li>If <em>T0</em> is a primitive and <em>T1</em> a reference,\n     *     a Java casting conversion (JLS 5.5) is applied if one exists.\n     *     (Specifically, the value is boxed from <em>T0</em> to its wrapper class,\n     *     which is then widened as needed to <em>T1</em>.)\n     * <li>If <em>T0</em> is a reference and <em>T1</em> a primitive, an unboxing\n     *     conversion will be applied at runtime, possibly followed\n     *     by a Java method invocation conversion (JLS 5.3)\n     *     on the primitive value.  (These are the primitive widening conversions.)\n     *     <em>T0</em> must be a wrapper class or a supertype of one.\n     *     (In the case where <em>T0</em> is Object, these are the conversions\n     *     allowed by {@link java.lang.reflect.Method#invoke java.lang.reflect.Method.invoke}.)\n     *     The unboxing conversion must have a possibility of success, which means that\n     *     if <em>T0</em> is not itself a wrapper class, there must exist at least one\n     *     wrapper class <em>TW</em> which is a subtype of <em>T0</em> and whose unboxed\n     *     primitive value can be widened to <em>T1</em>.\n     * <li>If the return type <em>T1</em> is marked as void, any returned value is discarded\n     * <li>If the return type <em>T0</em> is void and <em>T1</em> a reference, a null value is introduced.\n     * <li>If the return type <em>T0</em> is void and <em>T1</em> a primitive,\n     *     a zero value is introduced.\n     * </ul>\n     * (<em>Note:</em> Both <em>T0</em> and <em>T1</em> may be regarded as static types,\n     * because neither corresponds specifically to the <em>dynamic type</em> of any\n     * actual argument or return value.)\n     * <p>\n     * The method handle conversion cannot be made if any one of the required\n     * pairwise conversions cannot be made.\n     * <p>\n     * At runtime, the conversions applied to reference arguments\n     * or return values may require additional runtime checks which can fail.\n     * An unboxing operation may fail because the original reference is null,\n     * causing a {@link java.lang.NullPointerException NullPointerException}.\n     * An unboxing operation or a reference cast may also fail on a reference\n     * to an object of the wrong type,\n     * causing a {@link java.lang.ClassCastException ClassCastException}.\n     * Although an unboxing operation may accept several kinds of wrappers,\n     * if none are available, a {@code ClassCastException} will be thrown.\n     *\n     * @param newType the expected type of the new method handle\n     * @return a method handle which delegates to {@code this} after performing\n     *           any necessary argument conversions, and arranges for any\n     *           necessary return value conversions\n     * @throws NullPointerException if {@code newType} is a null reference\n     * @throws WrongMethodTypeException if the conversion cannot be made\n     * @see MethodHandles#explicitCastArguments\n     ",
    "links" : [ "#invoke", "java.lang.reflect.Method#invoke", "java.lang.ClassCastException", "java.lang.NullPointerException", "#invokeExact" ]
  }, {
    "name" : "private MethodHandle asTypeCached(MethodType newType)",
    "returnType" : "MethodHandle",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : " MethodHandle asTypeUncached(MethodType newType)",
    "returnType" : "MethodHandle",
    "comment" : "non-public",
    "links" : [ ]
  }, {
    "name" : "public MethodHandle asSpreader(Class<?> arrayType, int arrayLength)",
    "returnType" : "MethodHandle",
    "comment" : "\n     * Makes an <em>array-spreading</em> method handle, which accepts a trailing array argument\n     * and spreads its elements as positional arguments.\n     * The new method handle adapts, as its <i>target</i>,\n     * the current method handle.  The type of the adapter will be\n     * the same as the type of the target, except that the final\n     * {@code arrayLength} parameters of the target's type are replaced\n     * by a single array parameter of type {@code arrayType}.\n     * <p>\n     * If the array element type differs from any of the corresponding\n     * argument types on the original target,\n     * the original target is adapted to take the array elements directly,\n     * as if by a call to {@link #asType asType}.\n     * <p>\n     * When called, the adapter replaces a trailing array argument\n     * by the array's elements, each as its own argument to the target.\n     * (The order of the arguments is preserved.)\n     * They are converted pairwise by casting and/or unboxing\n     * to the types of the trailing parameters of the target.\n     * Finally the target is called.\n     * What the target eventually returns is returned unchanged by the adapter.\n     * <p>\n     * Before calling the target, the adapter verifies that the array\n     * contains exactly enough elements to provide a correct argument count\n     * to the target method handle.\n     * (The array may also be null when zero elements are required.)\n     * <p>\n     * When the adapter is called, the length of the supplied {@code array}\n     * argument is queried as if by {@code array.length} or {@code arraylength}\n     * bytecode. If the adapter accepts a zero-length trailing array argument,\n     * the supplied {@code array} argument can either be a zero-length array or\n     * {@code null}; otherwise, the adapter will throw a {@code NullPointerException}\n     * if the array is {@code null} and throw an {@link IllegalArgumentException}\n     * if the array does not have the correct number of elements.\n     * <p>\n     * Here are some simple examples of array-spreading method handles:\n     * <blockquote><pre>{@code\nMethodHandle equals = publicLookup()\n  .findVirtual(String.class, \"equals\", methodType(boolean.class, Object.class));\nassert( (boolean) equals.invokeExact(\"me\", (Object)\"me\"));\nassert(!(boolean) equals.invokeExact(\"me\", (Object)\"thee\"));\n// spread both arguments from a 2-array:\nMethodHandle eq2 = equals.asSpreader(Object[].class, 2);\nassert( (boolean) eq2.invokeExact(new Object[]{ \"me\", \"me\" }));\nassert(!(boolean) eq2.invokeExact(new Object[]{ \"me\", \"thee\" }));\n// try to spread from anything but a 2-array:\nfor (int n = 0; n <= 10; n++) {\n  Object[] badArityArgs = (n == 2 ? new Object[0] : new Object[n]);\n  try { assert((boolean) eq2.invokeExact(badArityArgs) && false); }\n  catch (IllegalArgumentException ex) { } // OK\n}\n// spread both arguments from a String array:\nMethodHandle eq2s = equals.asSpreader(String[].class, 2);\nassert( (boolean) eq2s.invokeExact(new String[]{ \"me\", \"me\" }));\nassert(!(boolean) eq2s.invokeExact(new String[]{ \"me\", \"thee\" }));\n// spread second arguments from a 1-array:\nMethodHandle eq1 = equals.asSpreader(Object[].class, 1);\nassert( (boolean) eq1.invokeExact(\"me\", new Object[]{ \"me\" }));\nassert(!(boolean) eq1.invokeExact(\"me\", new Object[]{ \"thee\" }));\n// spread no arguments from a 0-array or null:\nMethodHandle eq0 = equals.asSpreader(Object[].class, 0);\nassert( (boolean) eq0.invokeExact(\"me\", (Object)\"me\", new Object[0]));\nassert(!(boolean) eq0.invokeExact(\"me\", (Object)\"thee\", (Object[])null));\n// asSpreader and asCollector are approximate inverses:\nfor (int n = 0; n <= 2; n++) {\n    for (Class<?> a : new Class<?>[]{Object[].class, String[].class, CharSequence[].class}) {\n        MethodHandle equals2 = equals.asSpreader(a, n).asCollector(a, n);\n        assert( (boolean) equals2.invokeWithArguments(\"me\", \"me\"));\n        assert(!(boolean) equals2.invokeWithArguments(\"me\", \"thee\"));\n    }\n}\nMethodHandle caToString = publicLookup()\n  .findStatic(Arrays.class, \"toString\", methodType(String.class, char[].class));\nassertEquals(\"[A, B, C]\", (String) caToString.invokeExact(\"ABC\".toCharArray()));\nMethodHandle caString3 = caToString.asCollector(char[].class, 3);\nassertEquals(\"[A, B, C]\", (String) caString3.invokeExact('A', 'B', 'C'));\nMethodHandle caToString2 = caString3.asSpreader(char[].class, 2);\nassertEquals(\"[A, B, C]\", (String) caToString2.invokeExact('A', \"BC\".toCharArray()));\n     * }</pre></blockquote>\n     * @param arrayType usually {@code Object[]}, the type of the array argument from which to extract the spread arguments\n     * @param arrayLength the number of arguments to spread from an incoming array argument\n     * @return a new method handle which spreads its final array argument,\n     *         before calling the original method handle\n     * @throws NullPointerException if {@code arrayType} is a null reference\n     * @throws IllegalArgumentException if {@code arrayType} is not an array type,\n     *         or if target does not have at least\n     *         {@code arrayLength} parameter types,\n     *         or if {@code arrayLength} is negative,\n     *         or if the resulting method handle's type would have\n     *         <a href=\"MethodHandle.html#maxarity\">too many parameters</a>\n     * @throws WrongMethodTypeException if the implied {@code asType} call fails\n     * @see #asCollector\n     ",
    "links" : [ "#asType", "IllegalArgumentException" ]
  }, {
    "name" : "public MethodHandle asSpreader(int spreadArgPos, Class<?> arrayType, int arrayLength)",
    "returnType" : "MethodHandle",
    "comment" : "\n     * Makes an <em>array-spreading</em> method handle, which accepts an array argument at a given position and spreads\n     * its elements as positional arguments in place of the array. The new method handle adapts, as its <i>target</i>,\n     * the current method handle. The type of the adapter will be the same as the type of the target, except that the\n     * {@code arrayLength} parameters of the target's type, starting at the zero-based position {@code spreadArgPos},\n     * are replaced by a single array parameter of type {@code arrayType}.\n     * <p>\n     * This method behaves very much like {@link #asSpreader(Class, int)}, but accepts an additional {@code spreadArgPos}\n     * argument to indicate at which position in the parameter list the spreading should take place.\n     *\n     * @apiNote Example:\n     * <blockquote><pre>{@code\n    MethodHandle compare = LOOKUP.findStatic(Objects.class, \"compare\", methodType(int.class, Object.class, Object.class, Comparator.class));\n    MethodHandle compare2FromArray = compare.asSpreader(0, Object[].class, 2);\n    Object[] ints = new Object[]{3, 9, 7, 7};\n    Comparator<Integer> cmp = (a, b) -> a - b;\n    assertTrue((int) compare2FromArray.invoke(Arrays.copyOfRange(ints, 0, 2), cmp) < 0);\n    assertTrue((int) compare2FromArray.invoke(Arrays.copyOfRange(ints, 1, 3), cmp) > 0);\n    assertTrue((int) compare2FromArray.invoke(Arrays.copyOfRange(ints, 2, 4), cmp) == 0);\n     * }</pre></blockquote>\n     * @param spreadArgPos the position (zero-based index) in the argument list at which spreading should start.\n     * @param arrayType usually {@code Object[]}, the type of the array argument from which to extract the spread arguments\n     * @param arrayLength the number of arguments to spread from an incoming array argument\n     * @return a new method handle which spreads an array argument at a given position,\n     *         before calling the original method handle\n     * @throws NullPointerException if {@code arrayType} is a null reference\n     * @throws IllegalArgumentException if {@code arrayType} is not an array type,\n     *         or if target does not have at least\n     *         {@code arrayLength} parameter types,\n     *         or if {@code arrayLength} is negative,\n     *         or if {@code spreadArgPos} has an illegal value (negative, or together with arrayLength exceeding the\n     *         number of arguments),\n     *         or if the resulting method handle's type would have\n     *         <a href=\"MethodHandle.html#maxarity\">too many parameters</a>\n     * @throws WrongMethodTypeException if the implied {@code asType} call fails\n     *\n     * @see #asSpreader(Class, int)\n     * @since 9\n     ",
    "links" : [ "#asSpreader(Class" ]
  }, {
    "name" : "private MethodType asSpreaderChecks(Class<?> arrayType, int pos, int arrayLength)",
    "returnType" : "MethodType",
    "comment" : "\n     * See if {@code asSpreader} can be validly called with the given arguments.\n     * Return the type of the method handle call after spreading but before conversions.\n     ",
    "links" : [ ]
  }, {
    "name" : "private void spreadArrayChecks(Class<?> arrayType, int arrayLength)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public MethodHandle withVarargs(boolean makeVarargs)",
    "returnType" : "MethodHandle",
    "comment" : "\n     * Adapts this method handle to be {@linkplain #asVarargsCollector variable arity}\n     * if the boolean flag is true, else {@linkplain #asFixedArity fixed arity}.\n     * If the method handle is already of the proper arity mode, it is returned\n     * unchanged.\n     * @apiNote\n     * <p>This method is sometimes useful when adapting a method handle that\n     * may be variable arity, to ensure that the resulting adapter is also\n     * variable arity if and only if the original handle was.  For example,\n     * this code changes the first argument of a handle {@code mh} to {@code int} without\n     * disturbing its variable arity property:\n     * {@code mh.asType(mh.type().changeParameterType(0,int.class))\n     *     .withVarargs(mh.isVarargsCollector())}\n     * <p>\n     * This call is approximately equivalent to the following code:\n     * <blockquote><pre>{@code\n     * if (makeVarargs == isVarargsCollector())\n     *   return this;\n     * else if (makeVarargs)\n     *   return asVarargsCollector(type().lastParameterType());\n     * else\n     *   return return asFixedArity();\n     * }</pre></blockquote>\n     * @param makeVarargs true if the return method handle should have variable arity behavior\n     * @return a method handle of the same type, with possibly adjusted variable arity behavior\n     * @throws IllegalArgumentException if {@code makeVarargs} is true and\n     *         this method handle does not have a trailing array parameter\n     * @since 9\n     * @see #asVarargsCollector\n     * @see #asFixedArity\n     ",
    "links" : [ ]
  }, {
    "name" : "public MethodHandle asCollector(Class<?> arrayType, int arrayLength)",
    "returnType" : "MethodHandle",
    "comment" : "\n     * Makes an <em>array-collecting</em> method handle, which accepts a given number of trailing\n     * positional arguments and collects them into an array argument.\n     * The new method handle adapts, as its <i>target</i>,\n     * the current method handle.  The type of the adapter will be\n     * the same as the type of the target, except that a single trailing\n     * parameter (usually of type {@code arrayType}) is replaced by\n     * {@code arrayLength} parameters whose type is element type of {@code arrayType}.\n     * <p>\n     * If the array type differs from the final argument type on the original target,\n     * the original target is adapted to take the array type directly,\n     * as if by a call to {@link #asType asType}.\n     * <p>\n     * When called, the adapter replaces its trailing {@code arrayLength}\n     * arguments by a single new array of type {@code arrayType}, whose elements\n     * comprise (in order) the replaced arguments.\n     * Finally the target is called.\n     * What the target eventually returns is returned unchanged by the adapter.\n     * <p>\n     * (The array may also be a shared constant when {@code arrayLength} is zero.)\n     * <p>\n     * (<em>Note:</em> The {@code arrayType} is often identical to the last\n     * parameter type of the original target.\n     * It is an explicit argument for symmetry with {@code asSpreader}, and also\n     * to allow the target to use a simple {@code Object} as its last parameter type.)\n     * <p>\n     * In order to create a collecting adapter which is not restricted to a particular\n     * number of collected arguments, use {@link #asVarargsCollector asVarargsCollector} instead.\n     * <p>\n     * Here are some examples of array-collecting method handles:\n     * <blockquote><pre>{@code\nMethodHandle deepToString = publicLookup()\n  .findStatic(Arrays.class, \"deepToString\", methodType(String.class, Object[].class));\nassertEquals(\"[won]\",   (String) deepToString.invokeExact(new Object[]{\"won\"}));\nMethodHandle ts1 = deepToString.asCollector(Object[].class, 1);\nassertEquals(methodType(String.class, Object.class), ts1.type());\n//assertEquals(\"[won]\", (String) ts1.invokeExact(         new Object[]{\"won\"})); //FAIL\nassertEquals(\"[[won]]\", (String) ts1.invokeExact((Object) new Object[]{\"won\"}));\n// arrayType can be a subtype of Object[]\nMethodHandle ts2 = deepToString.asCollector(String[].class, 2);\nassertEquals(methodType(String.class, String.class, String.class), ts2.type());\nassertEquals(\"[two, too]\", (String) ts2.invokeExact(\"two\", \"too\"));\nMethodHandle ts0 = deepToString.asCollector(Object[].class, 0);\nassertEquals(\"[]\", (String) ts0.invokeExact());\n// collectors can be nested, Lisp-style\nMethodHandle ts22 = deepToString.asCollector(Object[].class, 3).asCollector(String[].class, 2);\nassertEquals(\"[A, B, [C, D]]\", ((String) ts22.invokeExact((Object)'A', (Object)\"B\", \"C\", \"D\")));\n// arrayType can be any primitive array type\nMethodHandle bytesToString = publicLookup()\n  .findStatic(Arrays.class, \"toString\", methodType(String.class, byte[].class))\n  .asCollector(byte[].class, 3);\nassertEquals(\"[1, 2, 3]\", (String) bytesToString.invokeExact((byte)1, (byte)2, (byte)3));\nMethodHandle longsToString = publicLookup()\n  .findStatic(Arrays.class, \"toString\", methodType(String.class, long[].class))\n  .asCollector(long[].class, 1);\nassertEquals(\"[123]\", (String) longsToString.invokeExact((long)123));\n     * }</pre></blockquote>\n     * @param arrayType often {@code Object[]}, the type of the array argument which will collect the arguments\n     * @param arrayLength the number of arguments to collect into a new array argument\n     * @return a new method handle which collects some trailing argument\n     *         into an array, before calling the original method handle\n     * @throws NullPointerException if {@code arrayType} is a null reference\n     * @throws IllegalArgumentException if {@code arrayType} is not an array type\n     *         or {@code arrayType} is not assignable to this method handle's trailing parameter type,\n     *         or {@code arrayLength} is not a legal array size,\n     *         or the resulting method handle's type would have\n     *         <a href=\"MethodHandle.html#maxarity\">too many parameters</a>\n     * @throws WrongMethodTypeException if the implied {@code asType} call fails\n     * @see #asSpreader\n     * @see #asVarargsCollector\n     ",
    "links" : [ "#asType", "#asVarargsCollector" ]
  }, {
    "name" : "public MethodHandle asCollector(int collectArgPos, Class<?> arrayType, int arrayLength)",
    "returnType" : "MethodHandle",
    "comment" : "\n     * Makes an <em>array-collecting</em> method handle, which accepts a given number of positional arguments starting\n     * at a given position, and collects them into an array argument. The new method handle adapts, as its\n     * <i>target</i>, the current method handle. The type of the adapter will be the same as the type of the target,\n     * except that the parameter at the position indicated by {@code collectArgPos} (usually of type {@code arrayType})\n     * is replaced by {@code arrayLength} parameters whose type is element type of {@code arrayType}.\n     * <p>\n     * This method behaves very much like {@link #asCollector(Class, int)}, but differs in that its {@code\n     * collectArgPos} argument indicates at which position in the parameter list arguments should be collected. This\n     * index is zero-based.\n     *\n     * @apiNote Examples:\n     * <blockquote><pre>{@code\n    StringWriter swr = new StringWriter();\n    MethodHandle swWrite = LOOKUP.findVirtual(StringWriter.class, \"write\", methodType(void.class, char[].class, int.class, int.class)).bindTo(swr);\n    MethodHandle swWrite4 = swWrite.asCollector(0, char[].class, 4);\n    swWrite4.invoke('A', 'B', 'C', 'D', 1, 2);\n    assertEquals(\"BC\", swr.toString());\n    swWrite4.invoke('P', 'Q', 'R', 'S', 0, 4);\n    assertEquals(\"BCPQRS\", swr.toString());\n    swWrite4.invoke('W', 'X', 'Y', 'Z', 3, 1);\n    assertEquals(\"BCPQRSZ\", swr.toString());\n     * }</pre></blockquote>\n     * <p>\n     * <em>Note:</em> The resulting adapter is never a {@linkplain MethodHandle#asVarargsCollector\n     * variable-arity method handle}, even if the original target method handle was.\n     * @param collectArgPos the zero-based position in the parameter list at which to start collecting.\n     * @param arrayType often {@code Object[]}, the type of the array argument which will collect the arguments\n     * @param arrayLength the number of arguments to collect into a new array argument\n     * @return a new method handle which collects some arguments\n     *         into an array, before calling the original method handle\n     * @throws NullPointerException if {@code arrayType} is a null reference\n     * @throws IllegalArgumentException if {@code arrayType} is not an array type\n     *         or {@code arrayType} is not assignable to this method handle's array parameter type,\n     *         or {@code arrayLength} is not a legal array size,\n     *         or {@code collectArgPos} has an illegal value (negative, or greater than the number of arguments),\n     *         or the resulting method handle's type would have\n     *         <a href=\"MethodHandle.html#maxarity\">too many parameters</a>\n     * @throws WrongMethodTypeException if the implied {@code asType} call fails\n     *\n     * @see #asCollector(Class, int)\n     * @since 9\n     ",
    "links" : [ "#asCollector(Class" ]
  }, {
    "name" : " boolean asCollectorChecks(Class<?> arrayType, int pos, int arrayLength)",
    "returnType" : "boolean",
    "comment" : "non-public",
    "links" : [ ]
  }, {
    "name" : "public MethodHandle asVarargsCollector(Class<?> arrayType)",
    "returnType" : "MethodHandle",
    "comment" : "\n     * Makes a <em>variable arity</em> adapter which is able to accept\n     * any number of trailing positional arguments and collect them\n     * into an array argument.\n     * <p>\n     * The type and behavior of the adapter will be the same as\n     * the type and behavior of the target, except that certain\n     * {@code invoke} and {@code asType} requests can lead to\n     * trailing positional arguments being collected into target's\n     * trailing parameter.\n     * Also, the\n     * {@linkplain MethodType#lastParameterType last parameter type}\n     * of the adapter will be\n     * {@code arrayType}, even if the target has a different\n     * last parameter type.\n     * <p>\n     * This transformation may return {@code this} if the method handle is\n     * already of variable arity and its trailing parameter type\n     * is identical to {@code arrayType}.\n     * <p>\n     * When called with {@link #invokeExact invokeExact}, the adapter invokes\n     * the target with no argument changes.\n     * (<em>Note:</em> This behavior is different from a\n     * {@linkplain #asCollector fixed arity collector},\n     * since it accepts a whole array of indeterminate length,\n     * rather than a fixed number of arguments.)\n     * <p>\n     * When called with plain, inexact {@link #invoke invoke}, if the caller\n     * type is the same as the adapter, the adapter invokes the target as with\n     * {@code invokeExact}.\n     * (This is the normal behavior for {@code invoke} when types match.)\n     * <p>\n     * Otherwise, if the caller and adapter arity are the same, and the\n     * trailing parameter type of the caller is a reference type identical to\n     * or assignable to the trailing parameter type of the adapter,\n     * the arguments and return values are converted pairwise,\n     * as if by {@link #asType asType} on a fixed arity\n     * method handle.\n     * <p>\n     * Otherwise, the arities differ, or the adapter's trailing parameter\n     * type is not assignable from the corresponding caller type.\n     * In this case, the adapter replaces all trailing arguments from\n     * the original trailing argument position onward, by\n     * a new array of type {@code arrayType}, whose elements\n     * comprise (in order) the replaced arguments.\n     * <p>\n     * The caller type must provides as least enough arguments,\n     * and of the correct type, to satisfy the target's requirement for\n     * positional arguments before the trailing array argument.\n     * Thus, the caller must supply, at a minimum, {@code N-1} arguments,\n     * where {@code N} is the arity of the target.\n     * Also, there must exist conversions from the incoming arguments\n     * to the target's arguments.\n     * As with other uses of plain {@code invoke}, if these basic\n     * requirements are not fulfilled, a {@code WrongMethodTypeException}\n     * may be thrown.\n     * <p>\n     * In all cases, what the target eventually returns is returned unchanged by the adapter.\n     * <p>\n     * In the final case, it is exactly as if the target method handle were\n     * temporarily adapted with a {@linkplain #asCollector fixed arity collector}\n     * to the arity required by the caller type.\n     * (As with {@code asCollector}, if the array length is zero,\n     * a shared constant may be used instead of a new array.\n     * If the implied call to {@code asCollector} would throw\n     * an {@code IllegalArgumentException} or {@code WrongMethodTypeException},\n     * the call to the variable arity adapter must throw\n     * {@code WrongMethodTypeException}.)\n     * <p>\n     * The behavior of {@link #asType asType} is also specialized for\n     * variable arity adapters, to maintain the invariant that\n     * plain, inexact {@code invoke} is always equivalent to an {@code asType}\n     * call to adjust the target type, followed by {@code invokeExact}.\n     * Therefore, a variable arity adapter responds\n     * to an {@code asType} request by building a fixed arity collector,\n     * if and only if the adapter and requested type differ either\n     * in arity or trailing argument type.\n     * The resulting fixed arity collector has its type further adjusted\n     * (if necessary) to the requested type by pairwise conversion,\n     * as if by another application of {@code asType}.\n     * <p>\n     * When a method handle is obtained by executing an {@code ldc} instruction\n     * of a {@code CONSTANT_MethodHandle} constant, and the target method is marked\n     * as a variable arity method (with the modifier bit {@code 0x0080}),\n     * the method handle will accept multiple arities, as if the method handle\n     * constant were created by means of a call to {@code asVarargsCollector}.\n     * <p>\n     * In order to create a collecting adapter which collects a predetermined\n     * number of arguments, and whose type reflects this predetermined number,\n     * use {@link #asCollector asCollector} instead.\n     * <p>\n     * No method handle transformations produce new method handles with\n     * variable arity, unless they are documented as doing so.\n     * Therefore, besides {@code asVarargsCollector} and {@code withVarargs},\n     * all methods in {@code MethodHandle} and {@code MethodHandles}\n     * will return a method handle with fixed arity,\n     * except in the cases where they are specified to return their original\n     * operand (e.g., {@code asType} of the method handle's own type).\n     * <p>\n     * Calling {@code asVarargsCollector} on a method handle which is already\n     * of variable arity will produce a method handle with the same type and behavior.\n     * It may (or may not) return the original variable arity method handle.\n     * <p>\n     * Here is an example, of a list-making variable arity method handle:\n     * <blockquote><pre>{@code\nMethodHandle deepToString = publicLookup()\n  .findStatic(Arrays.class, \"deepToString\", methodType(String.class, Object[].class));\nMethodHandle ts1 = deepToString.asVarargsCollector(Object[].class);\nassertEquals(\"[won]\",   (String) ts1.invokeExact(    new Object[]{\"won\"}));\nassertEquals(\"[won]\",   (String) ts1.invoke(         new Object[]{\"won\"}));\nassertEquals(\"[won]\",   (String) ts1.invoke(                      \"won\" ));\nassertEquals(\"[[won]]\", (String) ts1.invoke((Object) new Object[]{\"won\"}));\n// findStatic of Arrays.asList(...) produces a variable arity method handle:\nMethodHandle asList = publicLookup()\n  .findStatic(Arrays.class, \"asList\", methodType(List.class, Object[].class));\nassertEquals(methodType(List.class, Object[].class), asList.type());\nassert(asList.isVarargsCollector());\nassertEquals(\"[]\", asList.invoke().toString());\nassertEquals(\"[1]\", asList.invoke(1).toString());\nassertEquals(\"[two, too]\", asList.invoke(\"two\", \"too\").toString());\nString[] argv = { \"three\", \"thee\", \"tee\" };\nassertEquals(\"[three, thee, tee]\", asList.invoke(argv).toString());\nassertEquals(\"[three, thee, tee]\", asList.invoke((Object[])argv).toString());\nList ls = (List) asList.invoke((Object)argv);\nassertEquals(1, ls.size());\nassertEquals(\"[three, thee, tee]\", Arrays.toString((Object[])ls.get(0)));\n     * }</pre></blockquote>\n     * <p style=\"font-size:smaller;\">\n     * <em>Discussion:</em>\n     * These rules are designed as a dynamically-typed variation\n     * of the Java rules for variable arity methods.\n     * In both cases, callers to a variable arity method or method handle\n     * can either pass zero or more positional arguments, or else pass\n     * pre-collected arrays of any length.  Users should be aware of the\n     * special role of the final argument, and of the effect of a\n     * type match on that final argument, which determines whether\n     * or not a single trailing argument is interpreted as a whole\n     * array or a single element of an array to be collected.\n     * Note that the dynamic type of the trailing argument has no\n     * effect on this decision, only a comparison between the symbolic\n     * type descriptor of the call site and the type descriptor of the method handle.)\n     *\n     * @param arrayType often {@code Object[]}, the type of the array argument which will collect the arguments\n     * @return a new method handle which can collect any number of trailing arguments\n     *         into an array, before calling the original method handle\n     * @throws NullPointerException if {@code arrayType} is a null reference\n     * @throws IllegalArgumentException if {@code arrayType} is not an array type\n     *         or {@code arrayType} is not assignable to this method handle's trailing parameter type\n     * @see #asCollector\n     * @see #isVarargsCollector\n     * @see #withVarargs\n     * @see #asFixedArity\n     ",
    "links" : [ "#asType", "#invoke", "#asCollector", "#invokeExact" ]
  }, {
    "name" : "public boolean isVarargsCollector()",
    "returnType" : "boolean",
    "comment" : "\n     * Determines if this method handle\n     * supports {@linkplain #asVarargsCollector variable arity} calls.\n     * Such method handles arise from the following sources:\n     * <ul>\n     * <li>a call to {@linkplain #asVarargsCollector asVarargsCollector}\n     * <li>a call to a {@linkplain java.lang.invoke.MethodHandles.Lookup lookup method}\n     *     which resolves to a variable arity Java method or constructor\n     * <li>an {@code ldc} instruction of a {@code CONSTANT_MethodHandle}\n     *     which resolves to a variable arity Java method or constructor\n     * </ul>\n     * @return true if this method handle accepts more than one arity of plain, inexact {@code invoke} calls\n     * @see #asVarargsCollector\n     * @see #asFixedArity\n     ",
    "links" : [ ]
  }, {
    "name" : "public MethodHandle asFixedArity()",
    "returnType" : "MethodHandle",
    "comment" : "\n     * Makes a <em>fixed arity</em> method handle which is otherwise\n     * equivalent to the current method handle.\n     * <p>\n     * If the current method handle is not of\n     * {@linkplain #asVarargsCollector variable arity},\n     * the current method handle is returned.\n     * This is true even if the current method handle\n     * could not be a valid input to {@code asVarargsCollector}.\n     * <p>\n     * Otherwise, the resulting fixed-arity method handle has the same\n     * type and behavior of the current method handle,\n     * except that {@link #isVarargsCollector isVarargsCollector}\n     * will be false.\n     * The fixed-arity method handle may (or may not) be the\n     * a previous argument to {@code asVarargsCollector}.\n     * <p>\n     * Here is an example, of a list-making variable arity method handle:\n     * <blockquote><pre>{@code\nMethodHandle asListVar = publicLookup()\n  .findStatic(Arrays.class, \"asList\", methodType(List.class, Object[].class))\n  .asVarargsCollector(Object[].class);\nMethodHandle asListFix = asListVar.asFixedArity();\nassertEquals(\"[1]\", asListVar.invoke(1).toString());\nException caught = null;\ntry { asListFix.invoke((Object)1); }\ncatch (Exception ex) { caught = ex; }\nassert(caught instanceof ClassCastException);\nassertEquals(\"[two, too]\", asListVar.invoke(\"two\", \"too\").toString());\ntry { asListFix.invoke(\"two\", \"too\"); }\ncatch (Exception ex) { caught = ex; }\nassert(caught instanceof WrongMethodTypeException);\nObject[] argv = { \"three\", \"thee\", \"tee\" };\nassertEquals(\"[three, thee, tee]\", asListVar.invoke(argv).toString());\nassertEquals(\"[three, thee, tee]\", asListFix.invoke(argv).toString());\nassertEquals(1, ((List) asListVar.invoke((Object)argv)).size());\nassertEquals(\"[three, thee, tee]\", asListFix.invoke((Object)argv).toString());\n     * }</pre></blockquote>\n     *\n     * @return a new method handle which accepts only a fixed number of arguments\n     * @see #asVarargsCollector\n     * @see #isVarargsCollector\n     ",
    "links" : [ "#isVarargsCollector" ]
  }, {
    "name" : "public MethodHandle bindTo(Object x)",
    "returnType" : "MethodHandle",
    "comment" : "\n     * Binds a value {@code x} to the first argument of a method handle, without invoking it.\n     * The new method handle adapts, as its <i>target</i>,\n     * the current method handle by binding it to the given argument.\n     * The type of the bound handle will be\n     * the same as the type of the target, except that a single leading\n     * reference parameter will be omitted.\n     * <p>\n     * When called, the bound handle inserts the given value {@code x}\n     * as a new leading argument to the target.  The other arguments are\n     * also passed unchanged.\n     * What the target eventually returns is returned unchanged by the bound handle.\n     * <p>\n     * The reference {@code x} must be convertible to the first parameter\n     * type of the target.\n     * <p>\n     * (<em>Note:</em>  Because method handles are immutable, the target method handle\n     * retains its original type and behavior.)\n     * @param x  the value to bind to the first argument of the target\n     * @return a new method handle which prepends the given value to the incoming\n     *         argument list, before calling the original method handle\n     * @throws IllegalArgumentException if the target does not have a\n     *         leading parameter type that is a reference type\n     * @throws ClassCastException if {@code x} cannot be converted\n     *         to the leading parameter type of the target\n     * @see MethodHandles#insertArguments\n     ",
    "links" : [ ]
  }, {
    "name" : "public String toString()",
    "returnType" : "String",
    "comment" : "\n     * Returns a string representation of the method handle,\n     * starting with the string {@code \"MethodHandle\"} and\n     * ending with the string representation of the method handle's type.\n     * In other words, this method returns a string equal to the value of:\n     * <blockquote><pre>{@code\n     * \"MethodHandle\" + type().toString()\n     * }</pre></blockquote>\n     * <p>\n     * (<em>Note:</em>  Future releases of this API may add further information\n     * to the string representation.\n     * Therefore, the present syntax should not be parsed by applications.)\n     *\n     * @return a string representation of the method handle\n     ",
    "links" : [ ]
  }, {
    "name" : " String standardString()",
    "returnType" : "String",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public int getHandleKind()",
    "returnType" : "int",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "protected void transform(EmulatedStackFrame arguments) throws Throwable",
    "returnType" : "void",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : " native void invokeExactWithFrame(EmulatedStackFrame arguments) throws Throwable",
    "returnType" : "void",
    "comment" : " package-private ",
    "links" : [ ]
  }, {
    "name" : "protected MethodHandle duplicate()",
    "returnType" : "MethodHandle",
    "comment" : "\n     * Creates a copy of this method handle, copying all relevant data.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "private void transformInternal(EmulatedStackFrame arguments) throws Throwable",
    "returnType" : "void",
    "comment" : "\n     * This is the entry point for all transform calls, and dispatches to the protected\n     * transform method. This layer of indirection exists purely for convenience, because\n     * we can invoke-direct on a fixed ArtMethod for all transform variants.\n     *\n     * NOTE: If this extra layer of indirection proves to be a problem, we can get rid\n     * of this layer of indirection at the cost of some additional ugliness.\n     ",
    "links" : [ ]
  } ],
  "methodNames" : [ "public MethodType type()", "public final native Object invokeExact(Object... args) throws Throwable", "public final native Object invoke(Object... args) throws Throwable", "public Object invokeWithArguments(Object... arguments) throws Throwable", "public Object invokeWithArguments(java.util.List<?> arguments) throws Throwable", "public MethodHandle asType(MethodType newType)", "private MethodHandle asTypeCached(MethodType newType)", " MethodHandle asTypeUncached(MethodType newType)", "public MethodHandle asSpreader(Class<?> arrayType, int arrayLength)", "public MethodHandle asSpreader(int spreadArgPos, Class<?> arrayType, int arrayLength)", "private MethodType asSpreaderChecks(Class<?> arrayType, int pos, int arrayLength)", "private void spreadArrayChecks(Class<?> arrayType, int arrayLength)", "public MethodHandle withVarargs(boolean makeVarargs)", "public MethodHandle asCollector(Class<?> arrayType, int arrayLength)", "public MethodHandle asCollector(int collectArgPos, Class<?> arrayType, int arrayLength)", " boolean asCollectorChecks(Class<?> arrayType, int pos, int arrayLength)", "public MethodHandle asVarargsCollector(Class<?> arrayType)", "public boolean isVarargsCollector()", "public MethodHandle asFixedArity()", "public MethodHandle bindTo(Object x)", "public String toString()", " String standardString()", "public int getHandleKind()", "protected void transform(EmulatedStackFrame arguments) throws Throwable", " native void invokeExactWithFrame(EmulatedStackFrame arguments) throws Throwable", "protected MethodHandle duplicate()", "private void transformInternal(EmulatedStackFrame arguments) throws Throwable" ],
  "variableNames" : [ "type", "asTypeCache", "cachedSpreadInvoker", "INVOKE_VIRTUAL", "INVOKE_SUPER", "INVOKE_DIRECT", "INVOKE_STATIC", "INVOKE_INTERFACE", "INVOKE_TRANSFORM", "INVOKE_VAR_HANDLE", "INVOKE_VAR_HANDLE_EXACT", "IGET", "IPUT", "SGET", "SPUT", "handleKind", "artFieldOrMethod" ]
}