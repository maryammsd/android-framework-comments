{
  "filePath" : "/home/maryam/clearblue/files/android-source-35/java/util/Comparator.java",
  "packageName" : "java.util",
  "className" : "Comparator",
  "comment" : "\n * A comparison function, which imposes a <i>total ordering</i> on\n * some collection of objects.  Comparators can be passed to a sort\n * method (such as {@link Collections#sort(List,Comparator)\n * Collections.sort} or {@link Arrays#sort(Object[],Comparator)\n * Arrays.sort}) to allow precise control over the sort order.\n * Comparators can also be used to control the order of certain data\n * structures (such as {@linkplain SortedSet sorted sets} or\n * {@linkplain SortedMap sorted maps}), or to provide an ordering for\n * collections of objects that don't have a {@linkplain Comparable\n * natural ordering}.<p>\n *\n * The ordering imposed by a comparator {@code c} on a set of elements\n * {@code S} is said to be <i>consistent with equals</i> if and only if\n * {@code c.compare(e1, e2)==0} has the same boolean value as\n * {@code e1.equals(e2)} for every {@code e1} and {@code e2} in\n * {@code S}.<p>\n *\n * Caution should be exercised when using a comparator capable of imposing an\n * ordering inconsistent with equals to order a sorted set (or sorted map).\n * Suppose a sorted set (or sorted map) with an explicit comparator {@code c}\n * is used with elements (or keys) drawn from a set {@code S}.  If the\n * ordering imposed by {@code c} on {@code S} is inconsistent with equals,\n * the sorted set (or sorted map) will behave \"strangely.\"  In particular the\n * sorted set (or sorted map) will violate the general contract for set (or\n * map), which is defined in terms of {@code equals}.<p>\n *\n * For example, suppose one adds two elements {@code a} and {@code b} such that\n * {@code (a.equals(b) && c.compare(a, b) != 0)}\n * to an empty {@code TreeSet} with comparator {@code c}.\n * The second {@code add} operation will return\n * true (and the size of the tree set will increase) because {@code a} and\n * {@code b} are not equivalent from the tree set's perspective, even though\n * this is contrary to the specification of the\n * {@link Set#add Set.add} method.<p>\n *\n * Note: It is generally a good idea for comparators to also implement\n * {@code java.io.Serializable}, as they may be used as ordering methods in\n * serializable data structures (like {@link TreeSet}, {@link TreeMap}).  In\n * order for the data structure to serialize successfully, the comparator (if\n * provided) must implement {@code Serializable}.<p>\n *\n * For the mathematically inclined, the <i>relation</i> that defines the\n * <i>imposed ordering</i> that a given comparator {@code c} imposes on a\n * given set of objects {@code S} is:<pre>\n *       {(x, y) such that c.compare(x, y) &lt;= 0}.\n * </pre> The <i>quotient</i> for this total order is:<pre>\n *       {(x, y) such that c.compare(x, y) == 0}.\n * </pre>\n *\n * It follows immediately from the contract for {@code compare} that the\n * quotient is an <i>equivalence relation</i> on {@code S}, and that the\n * imposed ordering is a <i>total order</i> on {@code S}.  When we say that\n * the ordering imposed by {@code c} on {@code S} is <i>consistent with\n * equals</i>, we mean that the quotient for the ordering is the equivalence\n * relation defined by the objects' {@link Object#equals(Object)\n * equals(Object)} method(s):<pre>\n *     {(x, y) such that x.equals(y)}. </pre>\n *\n * In other words, when the imposed ordering is consistent with\n * equals, the equivalence classes defined by the equivalence relation\n * of the {@code equals} method and the equivalence classes defined by\n * the quotient of the {@code compare} method are the same.\n\n * <p>Unlike {@code Comparable}, a comparator may optionally permit\n * comparison of null arguments, while maintaining the requirements for\n * an equivalence relation.\n *\n * <p>This interface is a member of the\n * <a href=\"{@docRoot}/java.base/java/util/package-summary.html#CollectionsFramework\">\n * Java Collections Framework</a>.\n *\n * @param <T> the type of objects that may be compared by this comparator\n *\n * @author  Josh Bloch\n * @author  Neal Gafter\n * @see Comparable\n * @see java.io.Serializable\n * @since 1.2\n ",
  "links" : [ "java.util.TreeMap", "#equals(Object)", "java.util.Set#add", "java.util.Collections#sort(List", "java.util.TreeSet", "java.util.Arrays#sort(Object" ],
  "variables" : [ ],
  "methods" : [ {
    "name" : " int compare(T o1, T o2)",
    "returnType" : "int",
    "comment" : "\n     * Compares its two arguments for order.  Returns a negative integer,\n     * zero, or a positive integer as the first argument is less than, equal\n     * to, or greater than the second.<p>\n     *\n     * The implementor must ensure that {@link Integer#signum\n     * signum}{@code (compare(x, y)) == -signum(compare(y, x))} for\n     * all {@code x} and {@code y}.  (This implies that {@code\n     * compare(x, y)} must throw an exception if and only if {@code\n     * compare(y, x)} throws an exception.)<p>\n     *\n     * The implementor must also ensure that the relation is transitive:\n     * {@code ((compare(x, y)>0) && (compare(y, z)>0))} implies\n     * {@code compare(x, z)>0}.<p>\n     *\n     * Finally, the implementor must ensure that {@code compare(x,\n     * y)==0} implies that {@code signum(compare(x,\n     * z))==signum(compare(y, z))} for all {@code z}.\n     *\n     * @apiNote\n     * It is generally the case, but <i>not</i> strictly required that\n     * {@code (compare(x, y)==0) == (x.equals(y))}.  Generally speaking,\n     * any comparator that violates this condition should clearly indicate\n     * this fact.  The recommended language is \"Note: this comparator\n     * imposes orderings that are inconsistent with equals.\"\n     *\n     * @param o1 the first object to be compared.\n     * @param o2 the second object to be compared.\n     * @return a negative integer, zero, or a positive integer as the\n     *         first argument is less than, equal to, or greater than the\n     *         second.\n     * @throws NullPointerException if an argument is null and this\n     *         comparator does not permit null arguments\n     * @throws ClassCastException if the arguments' types prevent them from\n     *         being compared by this comparator.\n     ",
    "links" : [ "#signumsignum" ]
  }, {
    "name" : " boolean equals(Object obj)",
    "returnType" : "boolean",
    "comment" : "\n     * Indicates whether some other object is &quot;equal to&quot;\n     * this comparator.  This method must obey the general contract of\n     * {@link Object#equals(Object)}.  Additionally, this method can\n     * return {@code true} <i>only</i> if the specified object is also\n     * a comparator and it imposes the same ordering as this\n     * comparator.  Thus, {@code comp1.equals(comp2)} implies that\n     * {@link Integer#signum signum}{@code (comp1.compare(o1,\n     * o2))==signum(comp2.compare(o1, o2))} for every object reference\n     * {@code o1} and {@code o2}.<p>\n     *\n     * Note that it is <i>always</i> safe <i>not</i> to override\n     * {@code Object.equals(Object)}.  However, overriding this method may,\n     * in some cases, improve performance by allowing programs to determine\n     * that two distinct comparators impose the same order.\n     *\n     * @param   obj   the reference object with which to compare.\n     * @return  {@code true} only if the specified object is also\n     *          a comparator and it imposes the same ordering as this\n     *          comparator.\n     * @see Object#equals(Object)\n     * @see Object#hashCode()\n     ",
    "links" : [ "#equals(Object)", "#signum" ]
  }, {
    "name" : " Comparator<T> reversed()",
    "returnType" : "Comparator<T>",
    "comment" : "\n     * Returns a comparator that imposes the reverse ordering of this\n     * comparator.\n     *\n     * @return a comparator that imposes the reverse ordering of this\n     *         comparator.\n     * @since 1.8\n     ",
    "links" : [ ]
  }, {
    "name" : " Comparator<T> thenComparing(Comparator<? super T> other)",
    "returnType" : "Comparator<T>",
    "comment" : "\n     * Returns a lexicographic-order comparator with another comparator.\n     * If this {@code Comparator} considers two elements equal, i.e.\n     * {@code compare(a, b) == 0}, {@code other} is used to determine the order.\n     *\n     * <p>The returned comparator is serializable if the specified comparator\n     * is also serializable.\n     *\n     * @apiNote\n     * For example, to sort a collection of {@code String} based on the length\n     * and then case-insensitive natural ordering, the comparator can be\n     * composed using following code,\n     *\n     * <pre>{@code\n     *     Comparator<String> cmp = Comparator.comparingInt(String::length)\n     *             .thenComparing(String.CASE_INSENSITIVE_ORDER);\n     * }</pre>\n     *\n     * @param  other the other comparator to be used when this comparator\n     *         compares two objects that are equal.\n     * @return a lexicographic-order comparator composed of this and then the\n     *         other comparator\n     * @throws NullPointerException if the argument is null.\n     * @since 1.8\n     ",
    "links" : [ ]
  }, {
    "name" : " Comparator<T> thenComparing(Function<? super T, ? extends U> keyExtractor, Comparator<? super U> keyComparator)",
    "returnType" : "Comparator<T>",
    "comment" : "\n     * Returns a lexicographic-order comparator with a function that\n     * extracts a key to be compared with the given {@code Comparator}.\n     *\n     * @implSpec This default implementation behaves as if {@code\n     *           thenComparing(comparing(keyExtractor, cmp))}.\n     *\n     * @param  <U>  the type of the sort key\n     * @param  keyExtractor the function used to extract the sort key\n     * @param  keyComparator the {@code Comparator} used to compare the sort key\n     * @return a lexicographic-order comparator composed of this comparator\n     *         and then comparing on the key extracted by the keyExtractor function\n     * @throws NullPointerException if either argument is null.\n     * @see #comparing(Function, Comparator)\n     * @see #thenComparing(Comparator)\n     * @since 1.8\n     ",
    "links" : [ ]
  }, {
    "name" : " Comparator<T> thenComparing(Function<? super T, ? extends U> keyExtractor)",
    "returnType" : "Comparator<T>",
    "comment" : "\n     * Returns a lexicographic-order comparator with a function that\n     * extracts a {@code Comparable} sort key.\n     *\n     * @implSpec This default implementation behaves as if {@code\n     *           thenComparing(comparing(keyExtractor))}.\n     *\n     * @param  <U>  the type of the {@link Comparable} sort key\n     * @param  keyExtractor the function used to extract the {@link\n     *         Comparable} sort key\n     * @return a lexicographic-order comparator composed of this and then the\n     *         {@link Comparable} sort key.\n     * @throws NullPointerException if the argument is null.\n     * @see #comparing(Function)\n     * @see #thenComparing(Comparator)\n     * @since 1.8\n     ",
    "links" : [ "Comparable" ]
  }, {
    "name" : " Comparator<T> thenComparingInt(ToIntFunction<? super T> keyExtractor)",
    "returnType" : "Comparator<T>",
    "comment" : "\n     * Returns a lexicographic-order comparator with a function that\n     * extracts an {@code int} sort key.\n     *\n     * @implSpec This default implementation behaves as if {@code\n     *           thenComparing(comparingInt(keyExtractor))}.\n     *\n     * @param  keyExtractor the function used to extract the integer sort key\n     * @return a lexicographic-order comparator composed of this and then the\n     *         {@code int} sort key\n     * @throws NullPointerException if the argument is null.\n     * @see #comparingInt(ToIntFunction)\n     * @see #thenComparing(Comparator)\n     * @since 1.8\n     ",
    "links" : [ ]
  }, {
    "name" : " Comparator<T> thenComparingLong(ToLongFunction<? super T> keyExtractor)",
    "returnType" : "Comparator<T>",
    "comment" : "\n     * Returns a lexicographic-order comparator with a function that\n     * extracts a {@code long} sort key.\n     *\n     * @implSpec This default implementation behaves as if {@code\n     *           thenComparing(comparingLong(keyExtractor))}.\n     *\n     * @param  keyExtractor the function used to extract the long sort key\n     * @return a lexicographic-order comparator composed of this and then the\n     *         {@code long} sort key\n     * @throws NullPointerException if the argument is null.\n     * @see #comparingLong(ToLongFunction)\n     * @see #thenComparing(Comparator)\n     * @since 1.8\n     ",
    "links" : [ ]
  }, {
    "name" : " Comparator<T> thenComparingDouble(ToDoubleFunction<? super T> keyExtractor)",
    "returnType" : "Comparator<T>",
    "comment" : "\n     * Returns a lexicographic-order comparator with a function that\n     * extracts a {@code double} sort key.\n     *\n     * @implSpec This default implementation behaves as if {@code\n     *           thenComparing(comparingDouble(keyExtractor))}.\n     *\n     * @param  keyExtractor the function used to extract the double sort key\n     * @return a lexicographic-order comparator composed of this and then the\n     *         {@code double} sort key\n     * @throws NullPointerException if the argument is null.\n     * @see #comparingDouble(ToDoubleFunction)\n     * @see #thenComparing(Comparator)\n     * @since 1.8\n     ",
    "links" : [ ]
  }, {
    "name" : "public static Comparator<T> reverseOrder()",
    "returnType" : "Comparator<T>",
    "comment" : "\n     * Returns a comparator that imposes the reverse of the <em>natural\n     * ordering</em>.\n     *\n     * <p>The returned comparator is serializable and throws {@link\n     * NullPointerException} when comparing {@code null}.\n     *\n     * @param  <T> the {@link Comparable} type of element to be compared\n     * @return a comparator that imposes the reverse of the <i>natural\n     *         ordering</i> on {@code Comparable} objects.\n     * @see Comparable\n     * @since 1.8\n     ",
    "links" : [ "Comparable", "NullPointerException" ]
  }, {
    "name" : "public static Comparator<T> naturalOrder()",
    "returnType" : "Comparator<T>",
    "comment" : "\n     * Returns a comparator that compares {@link Comparable} objects in natural\n     * order.\n     *\n     * <p>The returned comparator is serializable and throws {@link\n     * NullPointerException} when comparing {@code null}.\n     *\n     * @param  <T> the {@link Comparable} type of element to be compared\n     * @return a comparator that imposes the <i>natural ordering</i> on {@code\n     *         Comparable} objects.\n     * @see Comparable\n     * @since 1.8\n     ",
    "links" : [ "Comparable", "NullPointerException" ]
  }, {
    "name" : "public static Comparator<T> nullsFirst(Comparator<? super T> comparator)",
    "returnType" : "Comparator<T>",
    "comment" : "\n     * Returns a null-friendly comparator that considers {@code null} to be\n     * less than non-null. When both are {@code null}, they are considered\n     * equal. If both are non-null, the specified {@code Comparator} is used\n     * to determine the order. If the specified comparator is {@code null},\n     * then the returned comparator considers all non-null values to be equal.\n     *\n     * <p>The returned comparator is serializable if the specified comparator\n     * is serializable.\n     *\n     * @param  <T> the type of the elements to be compared\n     * @param  comparator a {@code Comparator} for comparing non-null values\n     * @return a comparator that considers {@code null} to be less than\n     *         non-null, and compares non-null objects with the supplied\n     *         {@code Comparator}.\n     * @since 1.8\n     ",
    "links" : [ ]
  }, {
    "name" : "public static Comparator<T> nullsLast(Comparator<? super T> comparator)",
    "returnType" : "Comparator<T>",
    "comment" : "\n     * Returns a null-friendly comparator that considers {@code null} to be\n     * greater than non-null. When both are {@code null}, they are considered\n     * equal. If both are non-null, the specified {@code Comparator} is used\n     * to determine the order. If the specified comparator is {@code null},\n     * then the returned comparator considers all non-null values to be equal.\n     *\n     * <p>The returned comparator is serializable if the specified comparator\n     * is serializable.\n     *\n     * @param  <T> the type of the elements to be compared\n     * @param  comparator a {@code Comparator} for comparing non-null values\n     * @return a comparator that considers {@code null} to be greater than\n     *         non-null, and compares non-null objects with the supplied\n     *         {@code Comparator}.\n     * @since 1.8\n     ",
    "links" : [ ]
  }, {
    "name" : "public static Comparator<T> comparing(Function<? super T, ? extends U> keyExtractor, Comparator<? super U> keyComparator)",
    "returnType" : "Comparator<T>",
    "comment" : "\n     * Accepts a function that extracts a sort key from a type {@code T}, and\n     * returns a {@code Comparator<T>} that compares by that sort key using\n     * the specified {@link Comparator}.\n     *\n     * <p>The returned comparator is serializable if the specified function\n     * and comparator are both serializable.\n     *\n     * @apiNote\n     * For example, to obtain a {@code Comparator} that compares {@code\n     * Person} objects by their last name ignoring case differences,\n     *\n     * <pre>{@code\n     *     Comparator<Person> cmp = Comparator.comparing(\n     *             Person::getLastName,\n     *             String.CASE_INSENSITIVE_ORDER);\n     * }</pre>\n     *\n     * @param  <T> the type of element to be compared\n     * @param  <U> the type of the sort key\n     * @param  keyExtractor the function used to extract the sort key\n     * @param  keyComparator the {@code Comparator} used to compare the sort key\n     * @return a comparator that compares by an extracted key using the\n     *         specified {@code Comparator}\n     * @throws NullPointerException if either argument is null\n     * @since 1.8\n     ",
    "links" : [ "java.util.Comparator" ]
  }, {
    "name" : "public static Comparator<T> comparing(Function<? super T, ? extends U> keyExtractor)",
    "returnType" : "Comparator<T>",
    "comment" : "\n     * Accepts a function that extracts a {@link java.lang.Comparable\n     * Comparable} sort key from a type {@code T}, and returns a {@code\n     * Comparator<T>} that compares by that sort key.\n     *\n     * <p>The returned comparator is serializable if the specified function\n     * is also serializable.\n     *\n     * @apiNote\n     * For example, to obtain a {@code Comparator} that compares {@code\n     * Person} objects by their last name,\n     *\n     * <pre>{@code\n     *     Comparator<Person> byLastName = Comparator.comparing(Person::getLastName);\n     * }</pre>\n     *\n     * @param  <T> the type of element to be compared\n     * @param  <U> the type of the {@code Comparable} sort key\n     * @param  keyExtractor the function used to extract the {@link\n     *         Comparable} sort key\n     * @return a comparator that compares by an extracted key\n     * @throws NullPointerException if the argument is null\n     * @since 1.8\n     ",
    "links" : [ "Comparable", "java.lang.ComparableComparable" ]
  }, {
    "name" : "public static Comparator<T> comparingInt(ToIntFunction<? super T> keyExtractor)",
    "returnType" : "Comparator<T>",
    "comment" : "\n     * Accepts a function that extracts an {@code int} sort key from a type\n     * {@code T}, and returns a {@code Comparator<T>} that compares by that\n     * sort key.\n     *\n     * <p>The returned comparator is serializable if the specified function\n     * is also serializable.\n     *\n     * @param  <T> the type of element to be compared\n     * @param  keyExtractor the function used to extract the integer sort key\n     * @return a comparator that compares by an extracted key\n     * @see #comparing(Function)\n     * @throws NullPointerException if the argument is null\n     * @since 1.8\n     ",
    "links" : [ ]
  }, {
    "name" : "public static Comparator<T> comparingLong(ToLongFunction<? super T> keyExtractor)",
    "returnType" : "Comparator<T>",
    "comment" : "\n     * Accepts a function that extracts a {@code long} sort key from a type\n     * {@code T}, and returns a {@code Comparator<T>} that compares by that\n     * sort key.\n     *\n     * <p>The returned comparator is serializable if the specified function is\n     * also serializable.\n     *\n     * @param  <T> the type of element to be compared\n     * @param  keyExtractor the function used to extract the long sort key\n     * @return a comparator that compares by an extracted key\n     * @see #comparing(Function)\n     * @throws NullPointerException if the argument is null\n     * @since 1.8\n     ",
    "links" : [ ]
  }, {
    "name" : "public static Comparator<T> comparingDouble(ToDoubleFunction<? super T> keyExtractor)",
    "returnType" : "Comparator<T>",
    "comment" : "\n     * Accepts a function that extracts a {@code double} sort key from a type\n     * {@code T}, and returns a {@code Comparator<T>} that compares by that\n     * sort key.\n     *\n     * <p>The returned comparator is serializable if the specified function\n     * is also serializable.\n     *\n     * @param  <T> the type of element to be compared\n     * @param  keyExtractor the function used to extract the double sort key\n     * @return a comparator that compares by an extracted key\n     * @see #comparing(Function)\n     * @throws NullPointerException if the argument is null\n     * @since 1.8\n     ",
    "links" : [ ]
  } ],
  "methodNames" : [ " int compare(T o1, T o2)", " boolean equals(Object obj)", " Comparator<T> reversed()", " Comparator<T> thenComparing(Comparator<? super T> other)", " Comparator<T> thenComparing(Function<? super T, ? extends U> keyExtractor, Comparator<? super U> keyComparator)", " Comparator<T> thenComparing(Function<? super T, ? extends U> keyExtractor)", " Comparator<T> thenComparingInt(ToIntFunction<? super T> keyExtractor)", " Comparator<T> thenComparingLong(ToLongFunction<? super T> keyExtractor)", " Comparator<T> thenComparingDouble(ToDoubleFunction<? super T> keyExtractor)", "public static Comparator<T> reverseOrder()", "public static Comparator<T> naturalOrder()", "public static Comparator<T> nullsFirst(Comparator<? super T> comparator)", "public static Comparator<T> nullsLast(Comparator<? super T> comparator)", "public static Comparator<T> comparing(Function<? super T, ? extends U> keyExtractor, Comparator<? super U> keyComparator)", "public static Comparator<T> comparing(Function<? super T, ? extends U> keyExtractor)", "public static Comparator<T> comparingInt(ToIntFunction<? super T> keyExtractor)", "public static Comparator<T> comparingLong(ToLongFunction<? super T> keyExtractor)", "public static Comparator<T> comparingDouble(ToDoubleFunction<? super T> keyExtractor)" ],
  "variableNames" : [ ]
}