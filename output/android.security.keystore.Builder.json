{
  "filePath" : "/home/maryam/clearblue/files/android-source-30/android/security/keystore/KeyGenParameterSpec.java",
  "packageName" : "android.security.keystore",
  "className" : "Builder",
  "comment" : "\n     * Builder of {@link KeyGenParameterSpec} instances.\n     ",
  "variables" : [ {
    "name" : "mKeystoreAlias",
    "type" : "String",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mPurposes",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mUid",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mKeySize",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mSpec",
    "type" : "AlgorithmParameterSpec",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mCertificateSubject",
    "type" : "X500Principal",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mCertificateSerialNumber",
    "type" : "BigInteger",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mCertificateNotBefore",
    "type" : "Date",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mCertificateNotAfter",
    "type" : "Date",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mKeyValidityStart",
    "type" : "Date",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mKeyValidityForOriginationEnd",
    "type" : "Date",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mKeyValidityForConsumptionEnd",
    "type" : "Date",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mDigests",
    "type" : "String[]",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mEncryptionPaddings",
    "type" : "String[]",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mSignaturePaddings",
    "type" : "String[]",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mBlockModes",
    "type" : "String[]",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mRandomizedEncryptionRequired",
    "type" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mUserAuthenticationRequired",
    "type" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mUserAuthenticationValidityDurationSeconds",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mUserAuthenticationType",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mUserPresenceRequired",
    "type" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mAttestationChallenge",
    "type" : "byte[]",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mUniqueIdIncluded",
    "type" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mUserAuthenticationValidWhileOnBody",
    "type" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mInvalidatedByBiometricEnrollment",
    "type" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mIsStrongBoxBacked",
    "type" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mUserConfirmationRequired",
    "type" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mUnlockedDeviceRequired",
    "type" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mCriticalToDeviceEncryption",
    "type" : "boolean",
    "comment" : "",
    "links" : [ ]
  } ],
  "methods" : [ {
    "name" : "public Builder setUid(int uid)",
    "returnType" : "Builder",
    "comment" : "\n         * Sets the UID which will own the key.\n         *\n         * Such cross-UID access is permitted to a few system UIDs and only to a few other UIDs\n         * (e.g., Wi-Fi, VPN) all of which are system.\n         *\n         * @param uid UID or {@code -1} for the UID of the current process.\n         *\n         * @hide\n         ",
    "links" : [ ]
  }, {
    "name" : "public Builder setKeySize(int keySize)",
    "returnType" : "Builder",
    "comment" : "\n         * Sets the size (in bits) of the key to be generated. For instance, for RSA keys this sets\n         * the modulus size, for EC keys this selects a curve with a matching field size, and for\n         * symmetric keys this sets the size of the bitstring which is their key material.\n         *\n         * <p>The default key size is specific to each key algorithm. If key size is not set\n         * via this method, it should be looked up from the algorithm-specific parameters (if any)\n         * provided via\n         * {@link #setAlgorithmParameterSpec(AlgorithmParameterSpec) setAlgorithmParameterSpec}.\n         ",
    "links" : [ "#setAlgorithmParameterSpec(AlgorithmParameterSpec)" ]
  }, {
    "name" : "public Builder setAlgorithmParameterSpec(@NonNull AlgorithmParameterSpec spec)",
    "returnType" : "Builder",
    "comment" : "\n         * Sets the algorithm-specific key generation parameters. For example, for RSA keys this may\n         * be an instance of {@link java.security.spec.RSAKeyGenParameterSpec} whereas for EC keys\n         * this may be an instance of {@link java.security.spec.ECGenParameterSpec}.\n         *\n         * <p>These key generation parameters must match other explicitly set parameters (if any),\n         * such as key size.\n         ",
    "links" : [ "java.security.spec.ECGenParameterSpec", "java.security.spec.RSAKeyGenParameterSpec" ]
  }, {
    "name" : "public Builder setCertificateSubject(@NonNull X500Principal subject)",
    "returnType" : "Builder",
    "comment" : "\n         * Sets the subject used for the self-signed certificate of the generated key pair.\n         *\n         * <p>By default, the subject is {@code CN=fake}.\n         ",
    "links" : [ ]
  }, {
    "name" : "public Builder setCertificateSerialNumber(@NonNull BigInteger serialNumber)",
    "returnType" : "Builder",
    "comment" : "\n         * Sets the serial number used for the self-signed certificate of the generated key pair.\n         *\n         * <p>By default, the serial number is {@code 1}.\n         ",
    "links" : [ ]
  }, {
    "name" : "public Builder setCertificateNotBefore(@NonNull Date date)",
    "returnType" : "Builder",
    "comment" : "\n         * Sets the start of the validity period for the self-signed certificate of the generated\n         * key pair.\n         *\n         * <p>By default, this date is {@code Jan 1 1970}.\n         ",
    "links" : [ ]
  }, {
    "name" : "public Builder setCertificateNotAfter(@NonNull Date date)",
    "returnType" : "Builder",
    "comment" : "\n         * Sets the end of the validity period for the self-signed certificate of the generated key\n         * pair.\n         *\n         * <p>By default, this date is {@code Jan 1 2048}.\n         ",
    "links" : [ ]
  }, {
    "name" : "public Builder setKeyValidityStart(Date startDate)",
    "returnType" : "Builder",
    "comment" : "\n         * Sets the time instant before which the key is not yet valid.\n         *\n         * <p>By default, the key is valid at any instant.\n         *\n         * @see #setKeyValidityEnd(Date)\n         ",
    "links" : [ ]
  }, {
    "name" : "public Builder setKeyValidityEnd(Date endDate)",
    "returnType" : "Builder",
    "comment" : "\n         * Sets the time instant after which the key is no longer valid.\n         *\n         * <p>By default, the key is valid at any instant.\n         *\n         * @see #setKeyValidityStart(Date)\n         * @see #setKeyValidityForConsumptionEnd(Date)\n         * @see #setKeyValidityForOriginationEnd(Date)\n         ",
    "links" : [ ]
  }, {
    "name" : "public Builder setKeyValidityForOriginationEnd(Date endDate)",
    "returnType" : "Builder",
    "comment" : "\n         * Sets the time instant after which the key is no longer valid for encryption and signing.\n         *\n         * <p>By default, the key is valid at any instant.\n         *\n         * @see #setKeyValidityForConsumptionEnd(Date)\n         ",
    "links" : [ ]
  }, {
    "name" : "public Builder setKeyValidityForConsumptionEnd(Date endDate)",
    "returnType" : "Builder",
    "comment" : "\n         * Sets the time instant after which the key is no longer valid for decryption and\n         * verification.\n         *\n         * <p>By default, the key is valid at any instant.\n         *\n         * @see #setKeyValidityForOriginationEnd(Date)\n         ",
    "links" : [ ]
  }, {
    "name" : "public Builder setDigests(@KeyProperties.DigestEnum String... digests)",
    "returnType" : "Builder",
    "comment" : "\n         * Sets the set of digests algorithms (e.g., {@code SHA-256}, {@code SHA-384}) with which\n         * the key can be used. Attempts to use the key with any other digest algorithm will be\n         * rejected.\n         *\n         * <p>This must be specified for signing/verification keys and RSA encryption/decryption\n         * keys used with RSA OAEP padding scheme because these operations involve a digest. For\n         * HMAC keys, the default is the digest associated with the key algorithm (e.g.,\n         * {@code SHA-256} for key algorithm {@code HmacSHA256}). HMAC keys cannot be authorized\n         * for more than one digest.\n         *\n         * <p>For private keys used for TLS/SSL client or server authentication it is usually\n         * necessary to authorize the use of no digest ({@link KeyProperties#DIGEST_NONE}). This is\n         * because TLS/SSL stacks typically generate the necessary digest(s) themselves and then use\n         * a private key to sign it.\n         *\n         * <p>See {@link KeyProperties}.{@code DIGEST} constants.\n         ",
    "links" : [ "android.security.keystore.KeyProperties#DIGEST_NONE", "android.security.keystore.KeyProperties" ]
  }, {
    "name" : "public Builder setEncryptionPaddings(@KeyProperties.EncryptionPaddingEnum String... paddings)",
    "returnType" : "Builder",
    "comment" : "\n         * Sets the set of padding schemes (e.g., {@code PKCS7Padding}, {@code OAEPPadding},\n         * {@code PKCS1Padding}, {@code NoPadding}) with which the key can be used when\n         * encrypting/decrypting. Attempts to use the key with any other padding scheme will be\n         * rejected.\n         *\n         * <p>This must be specified for keys which are used for encryption/decryption.\n         *\n         * <p>For RSA private keys used by TLS/SSL servers to authenticate themselves to clients it\n         * is usually necessary to authorize the use of no/any padding\n         * ({@link KeyProperties#ENCRYPTION_PADDING_NONE}) and/or PKCS#1 encryption padding\n         * ({@link KeyProperties#ENCRYPTION_PADDING_RSA_PKCS1}). This is because RSA decryption is\n         * required by some cipher suites, and some stacks request decryption using no padding\n         * whereas others request PKCS#1 padding.\n         *\n         * <p>See {@link KeyProperties}.{@code ENCRYPTION_PADDING} constants.\n         ",
    "links" : [ "android.security.keystore.KeyProperties#ENCRYPTION_PADDING_NONE", "android.security.keystore.KeyProperties", "android.security.keystore.KeyProperties#ENCRYPTION_PADDING_RSA_PKCS1" ]
  }, {
    "name" : "public Builder setSignaturePaddings(@KeyProperties.SignaturePaddingEnum String... paddings)",
    "returnType" : "Builder",
    "comment" : "\n         * Sets the set of padding schemes (e.g., {@code PSS}, {@code PKCS#1}) with which the key\n         * can be used when signing/verifying. Attempts to use the key with any other padding scheme\n         * will be rejected.\n         *\n         * <p>This must be specified for RSA keys which are used for signing/verification.\n         *\n         * <p>See {@link KeyProperties}.{@code SIGNATURE_PADDING} constants.\n         ",
    "links" : [ "android.security.keystore.KeyProperties" ]
  }, {
    "name" : "public Builder setBlockModes(@KeyProperties.BlockModeEnum String... blockModes)",
    "returnType" : "Builder",
    "comment" : "\n         * Sets the set of block modes (e.g., {@code GCM}, {@code CBC}) with which the key can be\n         * used when encrypting/decrypting. Attempts to use the key with any other block modes will\n         * be rejected.\n         *\n         * <p>This must be specified for symmetric encryption/decryption keys.\n         *\n         * <p>See {@link KeyProperties}.{@code BLOCK_MODE} constants.\n         ",
    "links" : [ "android.security.keystore.KeyProperties" ]
  }, {
    "name" : "public Builder setRandomizedEncryptionRequired(boolean required)",
    "returnType" : "Builder",
    "comment" : "\n         * Sets whether encryption using this key must be sufficiently randomized to produce\n         * different ciphertexts for the same plaintext every time. The formal cryptographic\n         * property being required is <em>indistinguishability under chosen-plaintext attack\n         * ({@code IND-CPA})</em>. This property is important because it mitigates several classes\n         * of weaknesses due to which ciphertext may leak information about plaintext. For example,\n         * if a given plaintext always produces the same ciphertext, an attacker may see the\n         * repeated ciphertexts and be able to deduce something about the plaintext.\n         *\n         * <p>By default, {@code IND-CPA} is required.\n         *\n         * <p>When {@code IND-CPA} is required:\n         * <ul>\n         * <li>encryption/decryption transformation which do not offer {@code IND-CPA}, such as\n         * {@code ECB} with a symmetric encryption algorithm, or RSA encryption/decryption without\n         * padding, are prohibited;</li>\n         * <li>in block modes which use an IV, such as {@code GCM}, {@code CBC}, and {@code CTR},\n         * caller-provided IVs are rejected when encrypting, to ensure that only random IVs are\n         * used.</li>\n         * </ul>\n         *\n         * <p>Before disabling this requirement, consider the following approaches instead:\n         * <ul>\n         * <li>If you are generating a random IV for encryption and then initializing a {@code}\n         * Cipher using the IV, the solution is to let the {@code Cipher} generate a random IV\n         * instead. This will occur if the {@code Cipher} is initialized for encryption without an\n         * IV. The IV can then be queried via {@link Cipher#getIV()}.</li>\n         * <li>If you are generating a non-random IV (e.g., an IV derived from something not fully\n         * random, such as the name of the file being encrypted, or transaction ID, or password,\n         * or a device identifier), consider changing your design to use a random IV which will then\n         * be provided in addition to the ciphertext to the entities which need to decrypt the\n         * ciphertext.</li>\n         * <li>If you are using RSA encryption without padding, consider switching to encryption\n         * padding schemes which offer {@code IND-CPA}, such as PKCS#1 or OAEP.</li>\n         * </ul>\n         ",
    "links" : [ "javax.crypto.Cipher#getIV()" ]
  }, {
    "name" : "public Builder setUserAuthenticationRequired(boolean required)",
    "returnType" : "Builder",
    "comment" : "\n         * Sets whether this key is authorized to be used only if the user has been authenticated.\n         *\n         * <p>By default, the key is authorized to be used regardless of whether the user has been\n         * authenticated.\n         *\n         * <p>When user authentication is required:\n         * <ul>\n         * <li>The key can only be generated if secure lock screen is set up (see\n         * {@link KeyguardManager#isDeviceSecure()}). Additionally, if the key requires that user\n         * authentication takes place for every use of the key (see\n         * {@link #setUserAuthenticationValidityDurationSeconds(int)}), at least one biometric\n         * must be enrolled (see {@link BiometricManager#canAuthenticate()}).</li>\n         * <li>The use of the key must be authorized by the user by authenticating to this Android\n         * device using a subset of their secure lock screen credentials such as\n         * password/PIN/pattern or biometric.\n         * <a href=\"{@docRoot}training/articles/keystore.html#UserAuthentication\">More\n         * information</a>.\n         * <li>The key will become <em>irreversibly invalidated</em> once the secure lock screen is\n         * disabled (reconfigured to None, Swipe or other mode which does not authenticate the user)\n         * or when the secure lock screen is forcibly reset (e.g., by a Device Administrator).\n         * Additionally, if the key requires that user authentication takes place for every use of\n         * the key, it is also irreversibly invalidated once a new biometric is enrolled or once\\\n         * no more biometrics are enrolled, unless {@link\n         * #setInvalidatedByBiometricEnrollment(boolean)} is used to allow validity after\n         * enrollment. Attempts to initialize cryptographic operations using such keys will throw\n         * {@link KeyPermanentlyInvalidatedException}.</li>\n         * </ul>\n         *\n         * <p>This authorization applies only to secret key and private key operations. Public key\n         * operations are not restricted.\n         *\n         * @see #setUserAuthenticationValidityDurationSeconds(int)\n         * @see KeyguardManager#isDeviceSecure()\n         * @see BiometricManager#canAuthenticate()\n         ",
    "links" : [ "android.hardware.biometrics.BiometricManager#canAuthenticate()", "android.security.keystore.KeyPermanentlyInvalidatedException", "#setUserAuthenticationValidityDurationSeconds(int)", "android.app.KeyguardManager#isDeviceSecure()", "#setInvalidatedByBiometricEnrollment(boolean)" ]
  }, {
    "name" : "public Builder setUserConfirmationRequired(boolean required)",
    "returnType" : "Builder",
    "comment" : "\n         * Sets whether this key is authorized to be used only for messages confirmed by the\n         * user.\n         *\n         * Confirmation is separate from user authentication (see\n         * {@link #setUserAuthenticationRequired(boolean)}). Keys can be created that require\n         * confirmation but not user authentication, or user authentication but not confirmation,\n         * or both. Confirmation verifies that some user with physical possession of the device has\n         * approved a displayed message. User authentication verifies that the correct user is\n         * present and has authenticated.\n         *\n         * <p>This authorization applies only to secret key and private key operations. Public key\n         * operations are not restricted.\n         *\n         * See {@link android.security.ConfirmationPrompt} class for\n         * more details about user confirmations.\n         ",
    "links" : [ "#setUserAuthenticationRequired(boolean)", "android.security.ConfirmationPrompt" ]
  }, {
    "name" : "public Builder setUserAuthenticationValidityDurationSeconds(@IntRange(from = -1) int seconds)",
    "returnType" : "Builder",
    "comment" : "\n         * Sets the duration of time (seconds) for which this key is authorized to be used after the\n         * user is successfully authenticated. This has effect if the key requires user\n         * authentication for its use (see {@link #setUserAuthenticationRequired(boolean)}).\n         *\n         * <p>By default, if user authentication is required, it must take place for every use of\n         * the key.\n         *\n         * <p>Cryptographic operations involving keys which require user authentication to take\n         * place for every operation can only use biometric authentication. This is achieved by\n         * initializing a cryptographic operation ({@link Signature}, {@link Cipher}, {@link Mac})\n         * with the key, wrapping it into a {@link BiometricPrompt.CryptoObject}, invoking\n         * {@code BiometricPrompt.authenticate} with {@code CryptoObject}, and proceeding with\n         * the cryptographic operation only if the authentication flow succeeds.\n         *\n         * <p>Cryptographic operations involving keys which are authorized to be used for a duration\n         * of time after a successful user authentication event can only use secure lock screen\n         * authentication. These cryptographic operations will throw\n         * {@link UserNotAuthenticatedException} during initialization if the user needs to be\n         * authenticated to proceed. This situation can be resolved by the user unlocking the secure\n         * lock screen of the Android or by going through the confirm credential flow initiated by\n         * {@link KeyguardManager#createConfirmDeviceCredentialIntent(CharSequence, CharSequence)}.\n         * Once resolved, initializing a new cryptographic operation using this key (or any other\n         * key which is authorized to be used for a fixed duration of time after user\n         * authentication) should succeed provided the user authentication flow completed\n         * successfully.\n         *\n         * @param seconds duration in seconds or {@code -1} if user authentication must take place\n         *        for every use of the key.\n         *\n         * @see #setUserAuthenticationRequired(boolean)\n         * @see BiometricPrompt\n         * @see BiometricPrompt.CryptoObject\n         * @see KeyguardManager\n         * @deprecated See {@link #setUserAuthenticationParameters(int, int)}\n         ",
    "links" : [ "BiometricPrompt.CryptoObject", "android.security.keystore.UserNotAuthenticatedException", "java.security.Signature", "javax.crypto.Mac", "android.app.KeyguardManager#createConfirmDeviceCredentialIntent(CharSequence", "#setUserAuthenticationParameters(int", "javax.crypto.Cipher", "#setUserAuthenticationRequired(boolean)" ]
  }, {
    "name" : "public Builder setUserAuthenticationParameters(@IntRange(from = 0) int timeout, @KeyProperties.AuthEnum int type)",
    "returnType" : "Builder",
    "comment" : "\n         * Sets the duration of time (seconds) and authorization type for which this key is\n         * authorized to be used after the user is successfully authenticated. This has effect if\n         * the key requires user authentication for its use (see\n         * {@link #setUserAuthenticationRequired(boolean)}).\n         *\n         * <p>By default, if user authentication is required, it must take place for every use of\n         * the key.\n         *\n         * <p>These cryptographic operations will throw {@link UserNotAuthenticatedException} during\n         * initialization if the user needs to be authenticated to proceed. This situation can be\n         * resolved by the user authenticating with the appropriate biometric or credential as\n         * required by the key. See {@link BiometricPrompt.Builder#setAllowedAuthenticators(int)}\n         * and {@link BiometricManager.Authenticators}.\n         *\n         * <p>Once resolved, initializing a new cryptographic operation using this key (or any other\n         * key which is authorized to be used for a fixed duration of time after user\n         * authentication) should succeed provided the user authentication flow completed\n         * successfully.\n         *\n         * @param timeout duration in seconds or {@code 0} if user authentication must take place\n         *        for every use of the key.\n         * @param type set of authentication types which can authorize use of the key. See\n         *        {@link KeyProperties}.{@code AUTH} flags.\n         *\n         * @see #setUserAuthenticationRequired(boolean)\n         * @see BiometricPrompt\n         * @see BiometricPrompt.CryptoObject\n         * @see KeyguardManager\n         ",
    "links" : [ "android.security.keystore.KeyProperties", "android.security.keystore.UserNotAuthenticatedException", "BiometricManager.Authenticators", "BiometricPrompt.Builder#setAllowedAuthenticators(int)", "#setUserAuthenticationRequired(boolean)" ]
  }, {
    "name" : "public Builder setUserPresenceRequired(boolean required)",
    "returnType" : "Builder",
    "comment" : "\n         * Sets whether a test of user presence is required to be performed between the\n         * {@code Signature.initSign()} and {@code Signature.sign()} method calls.\n         * It requires that the KeyStore implementation have a direct way to validate the user\n         * presence for example a KeyStore hardware backed strongbox can use a button press that\n         * is observable in hardware. A test for user presence is tangential to authentication. The\n         * test can be part of an authentication step as long as this step can be validated by the\n         * hardware protecting the key and cannot be spoofed. For example, a physical button press\n         * can be used as a test of user presence if the other pins connected to the button are not\n         * able to simulate a button press.There must be no way for the primary processor to fake a\n         * button press, or that button must not be used as a test of user presence.\n         ",
    "links" : [ ]
  }, {
    "name" : "public Builder setAttestationChallenge(byte[] attestationChallenge)",
    "returnType" : "Builder",
    "comment" : "\n         * Sets whether an attestation certificate will be generated for this key pair, and what\n         * challenge value will be placed in the certificate.  The attestation certificate chain\n         * can be retrieved with with {@link java.security.KeyStore#getCertificateChain(String)}.\n         *\n         * <p>If {@code attestationChallenge} is not {@code null}, the public key certificate for\n         * this key pair will contain an extension that describes the details of the key's\n         * configuration and authorizations, including the {@code attestationChallenge} value. If\n         * the key is in secure hardware, and if the secure hardware supports attestation, the\n         * certificate will be signed by a chain of certificates rooted at a trustworthy CA key.\n         * Otherwise the chain will be rooted at an untrusted certificate.\n         *\n         * <p>The purpose of the challenge value is to enable relying parties to verify that the key\n         * was created in response to a specific request. If attestation is desired but no\n         * challenged is needed, any non-{@code null} value may be used, including an empty byte\n         * array.\n         *\n         * <p>If {@code attestationChallenge} is {@code null}, and this spec is used to generate an\n         * asymmetric (RSA or EC) key pair, the public key certificate will be self-signed if the\n         * key has purpose {@link android.security.keystore.KeyProperties#PURPOSE_SIGN}. If the key\n         * does not have purpose {@link android.security.keystore.KeyProperties#PURPOSE_SIGN}, it is\n         * not possible to use the key to sign a certificate, so the public key certificate will\n         * contain a dummy signature.\n         *\n         * <p>Symmetric keys, such as AES and HMAC keys, do not have public key certificates. If a\n         * {@link #getAttestationChallenge()} returns non-null and the spec is used to generate a\n         * symmetric (AES or HMAC) key, {@link javax.crypto.KeyGenerator#generateKey()} will throw\n         * {@link java.security.InvalidAlgorithmParameterException}.\n         ",
    "links" : [ "java.security.KeyStore#getCertificateChain(String)", "#getAttestationChallenge()", "android.security.keystore.KeyProperties#PURPOSE_SIGN", "javax.crypto.KeyGenerator#generateKey()", "java.security.InvalidAlgorithmParameterException" ]
  }, {
    "name" : "public Builder setUniqueIdIncluded(boolean uniqueIdIncluded)",
    "returnType" : "Builder",
    "comment" : "\n         * @hide Only system apps can use this method.\n         *\n         * Sets whether to include a temporary unique ID field in the attestation certificate.\n         ",
    "links" : [ ]
  }, {
    "name" : "public Builder setUserAuthenticationValidWhileOnBody(boolean remainsValid)",
    "returnType" : "Builder",
    "comment" : "\n         * Sets whether the key will remain authorized only until the device is removed from the\n         * user's body up to the limit of the authentication validity period (see\n         * {@link #setUserAuthenticationValidityDurationSeconds} and\n         * {@link #setUserAuthenticationRequired}). Once the device has been removed from the\n         * user's body, the key will be considered unauthorized and the user will need to\n         * re-authenticate to use it. For keys without an authentication validity period this\n         * parameter has no effect.\n         *\n         * <p>Similarly, on devices that do not have an on-body sensor, this parameter will have no\n         * effect; the device will always be considered to be \"on-body\" and the key will therefore\n         * remain authorized until the validity period ends.\n         *\n         * @param remainsValid if {@code true}, and if the device supports on-body detection, key\n         * will be invalidated when the device is removed from the user's body or when the\n         * authentication validity expires, whichever occurs first.\n         ",
    "links" : [ "#setUserAuthenticationValidityDurationSeconds", "#setUserAuthenticationRequired" ]
  }, {
    "name" : "public Builder setInvalidatedByBiometricEnrollment(boolean invalidateKey)",
    "returnType" : "Builder",
    "comment" : "\n         * Sets whether this key should be invalidated on biometric enrollment.  This\n         * applies only to keys which require user authentication (see {@link\n         * #setUserAuthenticationRequired(boolean)}) and if no positive validity duration has been\n         * set (see {@link #setUserAuthenticationValidityDurationSeconds(int)}, meaning the key is\n         * valid for biometric authentication only.\n         *\n         * <p>By default, {@code invalidateKey} is {@code true}, so keys that are valid for\n         * biometric authentication only are <em>irreversibly invalidated</em> when a new\n         * biometric is enrolled, or when all existing biometrics are deleted.  That may be\n         * changed by calling this method with {@code invalidateKey} set to {@code false}.\n         *\n         * <p>Invalidating keys on enrollment of a new biometric or unenrollment of all biometrics\n         * improves security by ensuring that an unauthorized person who obtains the password can't\n         * gain the use of biometric-authenticated keys by enrolling their own biometric.  However,\n         * invalidating keys makes key-dependent operations impossible, requiring some fallback\n         * procedure to authenticate the user and set up a new key.\n         ",
    "links" : [ "#setUserAuthenticationValidityDurationSeconds(int)", "#setUserAuthenticationRequired(boolean)" ]
  }, {
    "name" : "public Builder setIsStrongBoxBacked(boolean isStrongBoxBacked)",
    "returnType" : "Builder",
    "comment" : "\n         * Sets whether this key should be protected by a StrongBox security chip.\n         ",
    "links" : [ ]
  }, {
    "name" : "public Builder setUnlockedDeviceRequired(boolean unlockedDeviceRequired)",
    "returnType" : "Builder",
    "comment" : "\n         * Sets whether the keystore requires the screen to be unlocked before allowing decryption\n         * using this key. If this is set to {@code true}, any attempt to decrypt or sign using this\n         * key while the screen is locked will fail. A locked device requires a PIN, password,\n         * biometric, or other trusted factor to access. While the screen is locked, the key can\n         * still be used for encryption or signature verification.\n         ",
    "links" : [ ]
  }, {
    "name" : "public Builder setCriticalToDeviceEncryption(boolean critical)",
    "returnType" : "Builder",
    "comment" : "\n         * Set whether this key is critical to the device encryption flow\n         *\n         * This is a special flag only available to system servers to indicate the current key\n         * is part of the device encryption flow.\n         *\n         * @see android.security.KeyStore#FLAG_CRITICAL_TO_DEVICE_ENCRYPTION\n         * @hide\n         ",
    "links" : [ ]
  }, {
    "name" : "public KeyGenParameterSpec build()",
    "returnType" : "KeyGenParameterSpec",
    "comment" : "\n         * Builds an instance of {@code KeyGenParameterSpec}.\n         ",
    "links" : [ ]
  } ],
  "variableNames" : [ "mKeystoreAlias", "mPurposes", "mUid", "mKeySize", "mSpec", "mCertificateSubject", "mCertificateSerialNumber", "mCertificateNotBefore", "mCertificateNotAfter", "mKeyValidityStart", "mKeyValidityForOriginationEnd", "mKeyValidityForConsumptionEnd", "mDigests", "mEncryptionPaddings", "mSignaturePaddings", "mBlockModes", "mRandomizedEncryptionRequired", "mUserAuthenticationRequired", "mUserAuthenticationValidityDurationSeconds", "mUserAuthenticationType", "mUserPresenceRequired", "mAttestationChallenge", "mUniqueIdIncluded", "mUserAuthenticationValidWhileOnBody", "mInvalidatedByBiometricEnrollment", "mIsStrongBoxBacked", "mUserConfirmationRequired", "mUnlockedDeviceRequired", "mCriticalToDeviceEncryption" ],
  "methodNames" : [ "public Builder setUid(int uid)", "public Builder setKeySize(int keySize)", "public Builder setAlgorithmParameterSpec(@NonNull AlgorithmParameterSpec spec)", "public Builder setCertificateSubject(@NonNull X500Principal subject)", "public Builder setCertificateSerialNumber(@NonNull BigInteger serialNumber)", "public Builder setCertificateNotBefore(@NonNull Date date)", "public Builder setCertificateNotAfter(@NonNull Date date)", "public Builder setKeyValidityStart(Date startDate)", "public Builder setKeyValidityEnd(Date endDate)", "public Builder setKeyValidityForOriginationEnd(Date endDate)", "public Builder setKeyValidityForConsumptionEnd(Date endDate)", "public Builder setDigests(@KeyProperties.DigestEnum String... digests)", "public Builder setEncryptionPaddings(@KeyProperties.EncryptionPaddingEnum String... paddings)", "public Builder setSignaturePaddings(@KeyProperties.SignaturePaddingEnum String... paddings)", "public Builder setBlockModes(@KeyProperties.BlockModeEnum String... blockModes)", "public Builder setRandomizedEncryptionRequired(boolean required)", "public Builder setUserAuthenticationRequired(boolean required)", "public Builder setUserConfirmationRequired(boolean required)", "public Builder setUserAuthenticationValidityDurationSeconds(@IntRange(from = -1) int seconds)", "public Builder setUserAuthenticationParameters(@IntRange(from = 0) int timeout, @KeyProperties.AuthEnum int type)", "public Builder setUserPresenceRequired(boolean required)", "public Builder setAttestationChallenge(byte[] attestationChallenge)", "public Builder setUniqueIdIncluded(boolean uniqueIdIncluded)", "public Builder setUserAuthenticationValidWhileOnBody(boolean remainsValid)", "public Builder setInvalidatedByBiometricEnrollment(boolean invalidateKey)", "public Builder setIsStrongBoxBacked(boolean isStrongBoxBacked)", "public Builder setUnlockedDeviceRequired(boolean unlockedDeviceRequired)", "public Builder setCriticalToDeviceEncryption(boolean critical)", "public KeyGenParameterSpec build()" ]
}