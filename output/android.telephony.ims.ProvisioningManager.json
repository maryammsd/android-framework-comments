{
  "filePath" : "/home/maryam/clearblue/files/android-source-35/android/telephony/ims/ProvisioningManager.java",
  "packageName" : "android.telephony.ims",
  "className" : "ProvisioningManager",
  "comment" : "\n * Manages IMS provisioning and configuration parameters, as well as callbacks for apps to listen\n * to changes in these configurations.\n *\n * IMS provisioning keys are defined per carrier or OEM using OMA-DM or other provisioning\n * applications and may vary. It is up to the carrier and OEM applications to ensure that the\n * correct provisioning keys are being used when integrating with a vendor's ImsService.\n *\n * Use {@link android.telephony.ims.ImsManager#getProvisioningManager(int)} to get an instance of\n * this manager.\n ",
  "links" : [ "android.telephony.ims.ImsManager#getProvisioningManager(int)" ],
  "variables" : [ {
    "name" : "TAG",
    "type" : "String",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "STRING_QUERY_RESULT_ERROR_GENERIC",
    "type" : "String",
    "comment" : "\n     * The query from {@link #getProvisioningStringValue(int)} has resulted in an unspecified error.\n     * @hide\n     ",
    "links" : [ "#getProvisioningStringValue(int)" ]
  }, {
    "name" : "STRING_QUERY_RESULT_ERROR_NOT_READY",
    "type" : "String",
    "comment" : "\n     * The query from {@link #getProvisioningStringValue(int)} has resulted in an error because the\n     * ImsService implementation was not ready for provisioning queries.\n     * @hide\n     ",
    "links" : [ "#getProvisioningStringValue(int)" ]
  }, {
    "name" : "PROVISIONING_RESULT_UNKNOWN",
    "type" : "int",
    "comment" : "\n     * There is no existing configuration for the queried provisioning key.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "PROVISIONING_VALUE_DISABLED",
    "type" : "int",
    "comment" : "\n     * The integer result of provisioning for the queried key is disabled.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "PROVISIONING_VALUE_ENABLED",
    "type" : "int",
    "comment" : "\n     * The integer result of provisioning for the queried key is enabled.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "KEY_AMR_CODEC_MODE_SET_VALUES",
    "type" : "int",
    "comment" : "\n     * AMR CODEC Mode Value set, 0-7 in comma separated sequence.\n     * <p>\n     * This corresponds to the {@code mode-set} parameter for the AMR codec.\n     * See 3GPP TS 26.101 Table 1A for more information.\n     * <p>\n     * <UL>\n     *     <LI>0 - AMR 4.75 kbit/s</LI>\n     *     <LI>1 - AMR 5.15 kbit/s</LI>\n     *     <LI>2 - AMR 5.90 kbit/s</LI>\n     *     <LI>3 - AMR 6.70 kbit/s (PDC-EFR)</LI>\n     *     <LI>4 - AMR 7.40 kbit/s (TDMA-EFR)</LI>\n     *     <LI>5 - AMR 7.95 kbit/s</LI>\n     *     <LI>6 - AMR 10.2 kbit/s</LI>\n     *     <LI>7 - AMR 12.2 kbit/s (GSM-EFR)</LI>\n     * </UL>\n     * <p>\n     * Value is in String format.\n     * @see #setProvisioningIntValue(int, int)\n     * @see #getProvisioningIntValue(int)\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "KEY_AMR_WB_CODEC_MODE_SET_VALUES",
    "type" : "int",
    "comment" : "\n     * Wide Band AMR CODEC Mode Value set,0-7 in comma separated sequence.\n     * <p>\n     * This corresponds to the {@code mode-set} parameter for the AMR wideband codec.\n     * See 3GPP TS 26.101 Table 1A for more information.\n     * <p>\n     * <UL>\n     *     <LI>0 - AMR 4.75 kbit/s</LI>\n     *     <LI>1 - AMR 5.15 kbit/s</LI>\n     *     <LI>2 - AMR 5.90 kbit/s</LI>\n     *     <LI>3 - AMR 6.70 kbit/s (PDC-EFR)</LI>\n     *     <LI>4 - AMR 7.40 kbit/s (TDMA-EFR)</LI>\n     *     <LI>5 - AMR 7.95 kbit/s</LI>\n     *     <LI>6 - AMR 10.2 kbit/s</LI>\n     *     <LI>7 - AMR 12.2 kbit/s (GSM-EFR)</LI>\n     * </UL>\n     * <p>\n     * Value is in String format.\n     * @see #setProvisioningStringValue(int, String)\n     * @see #getProvisioningStringValue(int)\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "KEY_SIP_SESSION_TIMER_SEC",
    "type" : "int",
    "comment" : "\n     * SIP Session Timer value (seconds).\n     * <p>\n     * See RFC4028 for more information.\n     * <p>\n     * Value is in Integer format.\n     * @see #setProvisioningIntValue(int, int)\n     * @see #getProvisioningIntValue(int)\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "KEY_MINIMUM_SIP_SESSION_EXPIRATION_TIMER_SEC",
    "type" : "int",
    "comment" : "\n     * Minimum SIP Session Expiration Timer in (seconds).\n     * <p>\n     * See RFC4028 for more information.\n     * <p>\n     * Value is in Integer format.\n     * @see #setProvisioningIntValue(int, int)\n     * @see #getProvisioningIntValue(int)\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "KEY_SIP_INVITE_CANCELLATION_TIMER_MS",
    "type" : "int",
    "comment" : "\n     * SIP_INVITE cancellation time out value (in milliseconds). Integer format.\n     * <p>\n     * See RFC4028 for more information.\n     * <p>\n     * Value is in Integer format.\n     * @see #setProvisioningIntValue(int, int)\n     * @see #getProvisioningIntValue(int)\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "KEY_TRANSITION_TO_LTE_DELAY_MS",
    "type" : "int",
    "comment" : "\n     * Delay time when an iRAT transitions from eHRPD/HRPD/1xRTT to LTE.\n     * Value is in Integer format.\n     * @see #setProvisioningIntValue(int, int)\n     * @see #getProvisioningIntValue(int)\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "KEY_ENABLE_SILENT_REDIAL",
    "type" : "int",
    "comment" : "\n     * Silent redial status of Enabled (True), or Disabled (False).\n     * Value is in boolean format.\n     * @see #setProvisioningIntValue(int, int)\n     * @see #getProvisioningIntValue(int)\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "KEY_T1_TIMER_VALUE_MS",
    "type" : "int",
    "comment" : "\n     * An integer key representing the SIP T1 timer value in milliseconds for the associated\n     * subscription.\n     * <p>\n     * The SIP T1 timer is an estimate of the round-trip time and will retransmit\n     * INVITE transactions that are longer than T1 milliseconds over unreliable transports, doubling\n     * the time before retransmission every time there is no response. See RFC3261, section 17.1.1.1\n     * for more details.\n     * <p>\n     * The value is an integer.\n     * @see #setProvisioningIntValue(int, int)\n     * @see #getProvisioningIntValue(int)\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "KEY_T2_TIMER_VALUE_MS",
    "type" : "int",
    "comment" : "\n     * SIP T2 timer value in milliseconds.  See RFC 3261 for information.\n     * <p>\n     * The T2 timer is the maximum retransmit interval for non-INVITE requests and INVITE responses.\n     * <p>\n     * Value is in Integer format.\n     * @see #setProvisioningIntValue(int, int)\n     * @see #getProvisioningIntValue(int)\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "KEY_TF_TIMER_VALUE_MS",
    "type" : "int",
    "comment" : "\n     * SIP TF timer value in milliseconds.  See RFC 3261 for information.\n     * <p>\n     * The TF timer is the non-INVITE transaction timeout timer.\n     * <p>\n     * Value is in Integer format.\n     * @see #setProvisioningIntValue(int, int)\n     * @see #getProvisioningIntValue(int)\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "KEY_VOLTE_PROVISIONING_STATUS",
    "type" : "int",
    "comment" : "\n     * An integer key representing the voice over LTE (VoLTE) provisioning status for the\n     * associated subscription. Determines whether the user can register for voice services over\n     * LTE.\n     * <p>\n     * Use {@link #PROVISIONING_VALUE_ENABLED} to enable VoLTE provisioning and\n     * {@link #PROVISIONING_VALUE_DISABLED} to disable VoLTE provisioning.\n     * @see #setProvisioningIntValue(int, int)\n     * @see #getProvisioningIntValue(int)\n     * @hide\n     ",
    "links" : [ "#PROVISIONING_VALUE_DISABLED", "#PROVISIONING_VALUE_ENABLED" ]
  }, {
    "name" : "KEY_VT_PROVISIONING_STATUS",
    "type" : "int",
    "comment" : "\n     * An integer key representing the video telephony (VT) provisioning status for the\n     * associated subscription. Determines whether the user can register for video services over\n     * LTE.\n     * <p>\n     * Use {@link #PROVISIONING_VALUE_ENABLED} to enable VT provisioning and\n     * {@link #PROVISIONING_VALUE_DISABLED} to disable VT provisioning.\n     * @see #setProvisioningIntValue(int, int)\n     * @see #getProvisioningIntValue(int)\n     * @hide\n     ",
    "links" : [ "#PROVISIONING_VALUE_DISABLED", "#PROVISIONING_VALUE_ENABLED" ]
  }, {
    "name" : "KEY_REGISTRATION_DOMAIN_NAME",
    "type" : "int",
    "comment" : "\n     * Domain Name for the device to populate the request URI for REGISTRATION.\n     * Value is in String format.\n     * @see #setProvisioningStringValue(int, String)\n     * @see #getProvisioningStringValue(int)\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "KEY_SMS_FORMAT",
    "type" : "int",
    "comment" : "\n     * Device Outgoing SMS based on either 3GPP or 3GPP2 standards.\n     * Value is in Integer format.\n     * Valid values are {@link #SMS_FORMAT_3GPP} and {@link #SMS_FORMAT_3GPP2}.\n     * @see #setProvisioningIntValue(int, int)\n     * @see #getProvisioningIntValue(int)\n     * @hide\n     ",
    "links" : [ "#SMS_FORMAT_3GPP", "#SMS_FORMAT_3GPP2" ]
  }, {
    "name" : "SMS_FORMAT_3GPP2",
    "type" : "int",
    "comment" : "\n     * Value used with {@link #KEY_SMS_FORMAT} to indicate 3GPP2 SMS format is used.\n     * See {@link android.telephony.SmsMessage#FORMAT_3GPP2} for more information.\n     * @hide\n     ",
    "links" : [ "#KEY_SMS_FORMAT", "android.telephony.SmsMessage#FORMAT_3GPP2" ]
  }, {
    "name" : "SMS_FORMAT_3GPP",
    "type" : "int",
    "comment" : "\n     * Value used with {@link #KEY_SMS_FORMAT} to indicate 3GPP SMS format is used.\n     * See {@link android.telephony.SmsMessage#FORMAT_3GPP} for more information.\n     * @hide\n     ",
    "links" : [ "#KEY_SMS_FORMAT", "android.telephony.SmsMessage#FORMAT_3GPP" ]
  }, {
    "name" : "KEY_SMS_OVER_IP_ENABLED",
    "type" : "int",
    "comment" : "\n     * Turns SMS over IMS ON/OFF on the device.\n     * Value is in Integer format. ON (1), OFF(0).\n     * @see #setProvisioningIntValue(int, int)\n     * @see #getProvisioningIntValue(int)\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "KEY_RCS_PUBLISH_TIMER_SEC",
    "type" : "int",
    "comment" : "\n     * An integer key associated with the carrier configured SIP PUBLISH timer, which dictates the\n     * expiration time in seconds for published online availability in RCS presence.\n     * <p>\n     * Value is in Integer format.\n     * @see #setProvisioningIntValue(int, int)\n     * @see #getProvisioningIntValue(int)\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "KEY_RCS_PUBLISH_OFFLINE_AVAILABILITY_TIMER_SEC",
    "type" : "int",
    "comment" : "\n     * An integer key associated with the carrier configured expiration time in seconds for\n     * published offline availability in RCS presence provided, which is provided to the network.\n     * <p>\n     * Value is in Integer format.\n     * @see #setProvisioningIntValue(int, int)\n     * @see #getProvisioningIntValue(int)\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "KEY_RCS_CAPABILITY_DISCOVERY_ENABLED",
    "type" : "int",
    "comment" : "\n     * An integer key associated with whether or not capability discovery is provisioned for this\n     * subscription. Any capability requests will be ignored by the RCS service.\n     * <p>\n     * The value is an integer, either {@link #PROVISIONING_VALUE_DISABLED} if capability\n     * discovery is disabled or {@link #PROVISIONING_VALUE_ENABLED} if capability discovery is\n     * enabled.\n     * @see #setProvisioningIntValue(int, int)\n     * @see #getProvisioningIntValue(int)\n     * @hide\n     ",
    "links" : [ "#PROVISIONING_VALUE_DISABLED", "#PROVISIONING_VALUE_ENABLED" ]
  }, {
    "name" : "KEY_RCS_CAPABILITIES_CACHE_EXPIRATION_SEC",
    "type" : "int",
    "comment" : "\n     * An integer key associated with the period of time in seconds the capability information of\n     * each contact is cached on the device.\n     * <p>\n     * Seconds are used because this is usually measured in the span of days.\n     * <p>\n     * Value is in Integer format.\n     * @see #setProvisioningIntValue(int, int)\n     * @see #getProvisioningIntValue(int)\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "KEY_RCS_AVAILABILITY_CACHE_EXPIRATION_SEC",
    "type" : "int",
    "comment" : "\n     * An integer key associated with the period of time in seconds that the availability\n     * information of a contact is cached on the device, which is based on the carrier provisioning\n     * configuration from the network.\n     * <p>\n     * Value is in Integer format.\n     * @see #setProvisioningIntValue(int, int)\n     * @see #getProvisioningIntValue(int)\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "KEY_RCS_CAPABILITIES_POLL_INTERVAL_SEC",
    "type" : "int",
    "comment" : "\n     * An integer key associated with the carrier configured interval in seconds expected between\n     * successive capability polling attempts, which is based on the carrier provisioning\n     * configuration from the network.\n     * <p>\n     * Value is in Integer format.\n     * @see #setProvisioningIntValue(int, int)\n     * @see #getProvisioningIntValue(int)\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "KEY_RCS_PUBLISH_SOURCE_THROTTLE_MS",
    "type" : "int",
    "comment" : "\n     * An integer key representing the minimum time allowed between two consecutive presence publish\n     * messages from the device in milliseconds.\n     * <p>\n     * Value is in Integer format.\n     * @see #setProvisioningIntValue(int, int)\n     * @see #getProvisioningIntValue(int)\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "KEY_RCS_MAX_NUM_ENTRIES_IN_RCL",
    "type" : "int",
    "comment" : "\n     * An integer key associated with the maximum number of MDNs contained in one SIP Request\n     * Contained List (RCS) used to retrieve the RCS capabilities of the contacts book.\n     * <p>\n     * Value is in Integer format.\n     * @see #setProvisioningIntValue(int, int)\n     * @see #getProvisioningIntValue(int)\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "KEY_RCS_CAPABILITY_POLL_LIST_SUB_EXP_SEC",
    "type" : "int",
    "comment" : "\n     * An integer associated with the expiration timer used during the SIP subscription of a\n     * Request Contained List (RCL), which is used to retrieve the RCS capabilities of the contact\n     * book. This timer value is sent in seconds to the network.\n     * <p>\n     * Value is in Integer format.\n     * @see #setProvisioningIntValue(int, int)\n     * @see #getProvisioningIntValue(int)\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "KEY_USE_GZIP_FOR_LIST_SUBSCRIPTION",
    "type" : "int",
    "comment" : "\n     * Applies compression to LIST Subscription.\n     * Value is in Integer format. Enable (1), Disable(0).\n     * @see #setProvisioningIntValue(int, int)\n     * @see #getProvisioningIntValue(int)\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "KEY_EAB_PROVISIONING_STATUS",
    "type" : "int",
    "comment" : "\n     * An integer key representing the RCS enhanced address book (EAB) provisioning status for the\n     * associated subscription. Determines whether or not SIP OPTIONS or presence will be used to\n     * retrieve RCS capabilities for the user's contacts.\n     * <p>\n     * Use {@link #PROVISIONING_VALUE_ENABLED} to enable EAB provisioning and\n     * {@link #PROVISIONING_VALUE_DISABLED} to disable EAB provisioning.\n     * @see #setProvisioningIntValue(int, int)\n     * @see #getProvisioningIntValue(int)\n     * @hide\n     ",
    "links" : [ "#PROVISIONING_VALUE_DISABLED", "#PROVISIONING_VALUE_ENABLED" ]
  }, {
    "name" : "KEY_VOICE_OVER_WIFI_ROAMING_ENABLED_OVERRIDE",
    "type" : "int",
    "comment" : "\n     * Override the user-defined WiFi Roaming enabled setting for this subscription, defined in\n     * {@link android.telephony.SubscriptionManager#WFC_ROAMING_ENABLED_CONTENT_URI},\n     * for the purposes of provisioning the subscription for WiFi Calling.\n     *\n     * @see #setProvisioningIntValue(int, int)\n     * @see #getProvisioningIntValue(int)\n     * @hide\n     ",
    "links" : [ "android.telephony.SubscriptionManager#WFC_ROAMING_ENABLED_CONTENT_URI" ]
  }, {
    "name" : "KEY_VOICE_OVER_WIFI_MODE_OVERRIDE",
    "type" : "int",
    "comment" : "\n     * Override the user-defined WiFi mode for this subscription, defined in\n     * {@link android.telephony.SubscriptionManager#WFC_MODE_CONTENT_URI},\n     * for the purposes of provisioning this subscription for WiFi Calling.\n     *\n     * Valid values for this key are:\n     * {@link ImsMmTelManager#WIFI_MODE_WIFI_ONLY},\n     * {@link ImsMmTelManager#WIFI_MODE_CELLULAR_PREFERRED}, or\n     * {@link ImsMmTelManager#WIFI_MODE_WIFI_PREFERRED}.\n     *\n     * @see #setProvisioningIntValue(int, int)\n     * @see #getProvisioningIntValue(int)\n     * @hide\n     ",
    "links" : [ "android.telephony.ims.ImsMmTelManager#WIFI_MODE_WIFI_PREFERRED", "android.telephony.ims.ImsMmTelManager#WIFI_MODE_CELLULAR_PREFERRED", "android.telephony.SubscriptionManager#WFC_MODE_CONTENT_URI", "android.telephony.ims.ImsMmTelManager#WIFI_MODE_WIFI_ONLY" ]
  }, {
    "name" : "KEY_VOICE_OVER_WIFI_ENABLED_OVERRIDE",
    "type" : "int",
    "comment" : "\n     * Enable voice over wifi.  Enabled (1), or Disabled (0).\n     * Value is in Integer format.\n     * @see #setProvisioningIntValue(int, int)\n     * @see #getProvisioningIntValue(int)\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "KEY_MOBILE_DATA_ENABLED",
    "type" : "int",
    "comment" : "\n     * Mobile data enabled.\n     * Value is in Integer format. On (1), OFF(0).\n     * @see #setProvisioningIntValue(int, int)\n     * @see #getProvisioningIntValue(int)\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "KEY_VOLTE_USER_OPT_IN_STATUS",
    "type" : "int",
    "comment" : "\n     * VoLTE user opted in status.\n     * Value is in Integer format. Opted-in (1) Opted-out (0).\n     * @see #setProvisioningIntValue(int, int)\n     * @see #getProvisioningIntValue(int)\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "KEY_LOCAL_BREAKOUT_PCSCF_ADDRESS",
    "type" : "int",
    "comment" : "\n     * Proxy for Call Session Control Function(P-CSCF) address for Local-BreakOut(LBO).\n     * Value is in String format.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "KEY_SIP_KEEP_ALIVE_ENABLED",
    "type" : "int",
    "comment" : "\n     * Keep Alive Enabled for SIP.\n     * Value is in Integer format.\n     * @see #setProvisioningIntValue(int, int)\n     * @see #getProvisioningIntValue(int)\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "KEY_REGISTRATION_RETRY_BASE_TIME_SEC",
    "type" : "int",
    "comment" : "\n     * Registration retry Base Time value in seconds, which is based off of the carrier\n     * configuration.\n     * Value is in Integer format.\n     * @see #setProvisioningIntValue(int, int)\n     * @see #getProvisioningIntValue(int)\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "KEY_REGISTRATION_RETRY_MAX_TIME_SEC",
    "type" : "int",
    "comment" : "\n     * Registration retry Max Time value in seconds, which is based off of the carrier\n     * configuration.\n     * Value is in Integer format.\n     * @see #setProvisioningIntValue(int, int)\n     * @see #getProvisioningIntValue(int)\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "KEY_RTP_SPEECH_START_PORT",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "KEY_RTP_SPEECH_END_PORT",
    "type" : "int",
    "comment" : "\n     * Largest RTP port for speech code.\n     * Value is in Integer format.\n     * @see #setProvisioningIntValue(int, int)\n     * @see #getProvisioningIntValue(int)\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "KEY_SIP_INVITE_REQUEST_TRANSMIT_INTERVAL_MS",
    "type" : "int",
    "comment" : "\n     * SIP Timer A's value in milliseconds. Timer A is the INVITE request retransmit interval (in\n     * milliseconds), for UDP only.\n     * Value is in Integer format.\n     * @see #setProvisioningIntValue(int, int)\n     * @see #getProvisioningIntValue(int)\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "KEY_SIP_INVITE_ACK_WAIT_TIME_MS",
    "type" : "int",
    "comment" : "\n     * SIP Timer B's value in milliseconds. Timer B is the wait time for INVITE message to be,\n     * in milliseconds.\n     * Value is in Integer format.\n     * @see #setProvisioningIntValue(int, int)\n     * @see #getProvisioningIntValue(int)\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "KEY_SIP_INVITE_RESPONSE_RETRANSMIT_WAIT_TIME_MS",
    "type" : "int",
    "comment" : "\n     * SIP Timer D's value in milliseconds. Timer D is the wait time for response retransmits of\n     * the invite client transactions, in milliseconds.\n     * Value is in Integer format.\n     * @see #setProvisioningIntValue(int, int)\n     * @see #getProvisioningIntValue(int)\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "KEY_SIP_NON_INVITE_REQUEST_RETRANSMIT_INTERVAL_MS",
    "type" : "int",
    "comment" : "\n     * SIP Timer E's value in milliseconds. Timer E is the value Non-INVITE request retransmit\n     * interval (in milliseconds), for UDP only.\n     * Value is in Integer format.\n     * @see #setProvisioningIntValue(int, int)\n     * @see #getProvisioningIntValue(int)\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "KEY_SIP_NON_INVITE_TRANSACTION_TIMEOUT_TIMER_MS",
    "type" : "int",
    "comment" : "\n     * SIP Timer F's value in milliseconds. Timer F is the Non-INVITE transaction timeout timer,\n     * in milliseconds.\n     * Value is in Integer format.\n     * @see #setProvisioningIntValue(int, int)\n     * @see #getProvisioningIntValue(int)\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "KEY_SIP_INVITE_RESPONSE_RETRANSMIT_INTERVAL_MS",
    "type" : "int",
    "comment" : "\n     * SIP Timer G's value in milliseconds. Timer G is the value of INVITE response\n     * retransmit interval.\n     * Value is in Integer format.\n     * @see #setProvisioningIntValue(int, int)\n     * @see #getProvisioningIntValue(int)\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "KEY_SIP_ACK_RECEIPT_WAIT_TIME_MS",
    "type" : "int",
    "comment" : "\n     * SIP Timer H's value in milliseconds. Timer H is the value of wait time for\n     * ACK receipt.\n     * Value is in Integer format.\n     * @see #setProvisioningIntValue(int, int)\n     * @see #getProvisioningIntValue(int)\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "KEY_SIP_ACK_RETRANSMIT_WAIT_TIME_MS",
    "type" : "int",
    "comment" : "\n     * SIP Timer I's value in milliseconds. Timer I is the value of wait time for\n     * ACK retransmits.\n     * Value is in Integer format.\n     * @see #setProvisioningIntValue(int, int)\n     * @see #getProvisioningIntValue(int)\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "KEY_SIP_NON_INVITE_REQUEST_RETRANSMISSION_WAIT_TIME_MS",
    "type" : "int",
    "comment" : "\n     * SIP Timer J's value in milliseconds. Timer J is the value of wait time for\n     * non-invite request retransmission.\n     * Value is in Integer format.\n     * @see #setProvisioningIntValue(int, int)\n     * @see #getProvisioningIntValue(int)\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "KEY_SIP_NON_INVITE_RESPONSE_RETRANSMISSION_WAIT_TIME_MS",
    "type" : "int",
    "comment" : "\n     * SIP Timer K's value in milliseconds. Timer K is the value of wait time for\n     * non-invite response retransmits.\n     * Value is in Integer format.\n     * @see #setProvisioningIntValue(int, int)\n     * @see #getProvisioningIntValue(int)\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "KEY_AMR_WB_OCTET_ALIGNED_PAYLOAD_TYPE",
    "type" : "int",
    "comment" : "\n     * AMR WB octet aligned dynamic payload type.\n     * Value is in Integer format.\n     * @see #setProvisioningIntValue(int, int)\n     * @see #getProvisioningIntValue(int)\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "KEY_AMR_WB_BANDWIDTH_EFFICIENT_PAYLOAD_TYPE",
    "type" : "int",
    "comment" : "\n     * AMR WB bandwidth efficient payload type.\n     * Value is in Integer format.\n     * @see #setProvisioningIntValue(int, int)\n     * @see #getProvisioningIntValue(int)\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "KEY_AMR_OCTET_ALIGNED_PAYLOAD_TYPE",
    "type" : "int",
    "comment" : "\n     * AMR octet aligned dynamic payload type.\n     * Value is in Integer format.\n     * @see #setProvisioningIntValue(int, int)\n     * @see #getProvisioningIntValue(int)\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "KEY_AMR_BANDWIDTH_EFFICIENT_PAYLOAD_TYPE",
    "type" : "int",
    "comment" : "\n     * AMR bandwidth efficient payload type.\n     * Value is in Integer format.\n     * @see #setProvisioningIntValue(int, int)\n     * @see #getProvisioningIntValue(int)\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "KEY_DTMF_WB_PAYLOAD_TYPE",
    "type" : "int",
    "comment" : "\n     * DTMF WB payload type.\n     * Value is in Integer format.\n     * @see #setProvisioningIntValue(int, int)\n     * @see #getProvisioningIntValue(int)\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "KEY_DTMF_NB_PAYLOAD_TYPE",
    "type" : "int",
    "comment" : "\n     * DTMF NB payload type.\n     * Value is in Integer format.\n     * @see #setProvisioningIntValue(int, int)\n     * @see #getProvisioningIntValue(int)\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "KEY_AMR_DEFAULT_ENCODING_MODE",
    "type" : "int",
    "comment" : "\n     * AMR Default encoding mode.\n     * Value is in Integer format.\n     * @see #setProvisioningIntValue(int, int)\n     * @see #getProvisioningIntValue(int)\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "KEY_SMS_PUBLIC_SERVICE_IDENTITY",
    "type" : "int",
    "comment" : "\n     * SMS Public Service Identity.\n     * Value is in String format.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "KEY_VIDEO_QUALITY",
    "type" : "int",
    "comment" : "\n     * Video Quality - VideoQualityFeatureValuesConstants.\n     * Valid values are: {@link #VIDEO_QUALITY_HIGH} and {@link #VIDEO_QUALITY_LOW}.\n     * Value is in Integer format.\n     * @see #setProvisioningIntValue(int, int)\n     * @see #getProvisioningIntValue(int)\n     * @hide\n     ",
    "links" : [ "#VIDEO_QUALITY_HIGH", "#VIDEO_QUALITY_LOW" ]
  }, {
    "name" : "VIDEO_QUALITY_LOW",
    "type" : "int",
    "comment" : "\n     * Used with {@link #KEY_VIDEO_QUALITY} to indicate low video quality.\n     * @hide\n     ",
    "links" : [ "#KEY_VIDEO_QUALITY" ]
  }, {
    "name" : "VIDEO_QUALITY_HIGH",
    "type" : "int",
    "comment" : "\n     * Used with {@link #KEY_VIDEO_QUALITY} to indicate high video quality.\n     * @hide\n     ",
    "links" : [ "#KEY_VIDEO_QUALITY" ]
  }, {
    "name" : "KEY_LTE_THRESHOLD_1",
    "type" : "int",
    "comment" : "\n     * LTE to WIFI handover threshold.\n     * Handover from LTE to WiFi if LTE < THLTE1 and WiFi >= {@link #KEY_WIFI_THRESHOLD_A}.\n     * Value is in Integer format.\n     * @see #setProvisioningIntValue(int, int)\n     * @see #getProvisioningIntValue(int)\n     * @hide\n     ",
    "links" : [ "#KEY_WIFI_THRESHOLD_A" ]
  }, {
    "name" : "KEY_LTE_THRESHOLD_2",
    "type" : "int",
    "comment" : "\n     * WIFI to LTE handover threshold.\n     * Handover from WiFi to LTE if LTE >= {@link #KEY_LTE_THRESHOLD_3} or (WiFi < {@link\n     * #KEY_WIFI_THRESHOLD_B} and LTE >= {@link #KEY_LTE_THRESHOLD_2}).\n     * Value is in Integer format.\n     *\n     * @see #setProvisioningIntValue(int, int)\n     * @see #getProvisioningIntValue(int)\n     * @hide\n     ",
    "links" : [ "#KEY_WIFI_THRESHOLD_B", "#KEY_LTE_THRESHOLD_2", "#KEY_LTE_THRESHOLD_3" ]
  }, {
    "name" : "KEY_LTE_THRESHOLD_3",
    "type" : "int",
    "comment" : "\n     * LTE to WIFI handover threshold.\n     * Handover from WiFi to LTE if LTE >= {@link #KEY_LTE_THRESHOLD_3} or (WiFi < {@link\n     * #KEY_WIFI_THRESHOLD_B} and LTE >= {@link #KEY_LTE_THRESHOLD_2}).\n     * Value is in Integer format.\n     *\n     * @see #setProvisioningIntValue(int, int)\n     * @see #getProvisioningIntValue(int)\n     * @hide\n     ",
    "links" : [ "#KEY_WIFI_THRESHOLD_B", "#KEY_LTE_THRESHOLD_2", "#KEY_LTE_THRESHOLD_3" ]
  }, {
    "name" : "KEY_1X_THRESHOLD",
    "type" : "int",
    "comment" : "\n     * 1x to WIFI handover threshold.\n     * Handover from 1x to WiFi if 1x < {@link #KEY_1X_THRESHOLD}.\n     * Value is in Integer format.\n     * @see #setProvisioningIntValue(int, int)\n     * @see #getProvisioningIntValue(int)\n     * @hide\n     ",
    "links" : [ "#KEY_1X_THRESHOLD" ]
  }, {
    "name" : "KEY_WIFI_THRESHOLD_A",
    "type" : "int",
    "comment" : "\n     * LTE to WIFI threshold A.\n     * Handover from LTE to WiFi if LTE < {@link #KEY_LTE_THRESHOLD_1} and WiFi >= {@link\n     * #KEY_WIFI_THRESHOLD_A}.\n     * Value is in Integer format.\n     *\n     * @see #setProvisioningIntValue(int, int)\n     * @see #getProvisioningIntValue(int)\n     * @hide\n     ",
    "links" : [ "#KEY_WIFI_THRESHOLD_A", "#KEY_LTE_THRESHOLD_1" ]
  }, {
    "name" : "KEY_WIFI_THRESHOLD_B",
    "type" : "int",
    "comment" : "\n     * WiFi to LTRE handover threshold B.\n     * Handover from WiFi to LTE if LTE >= {@link #KEY_LTE_THRESHOLD_3} or (WiFi <\n     * {@link #KEY_WIFI_THRESHOLD_B} and LTE >= {@link #KEY_LTE_THRESHOLD_2}).\n     * Value is in Integer format.\n     * @see #setProvisioningIntValue(int, int)\n     * @see #getProvisioningIntValue(int)\n     * @hide\n     ",
    "links" : [ "#KEY_WIFI_THRESHOLD_B", "#KEY_LTE_THRESHOLD_2", "#KEY_LTE_THRESHOLD_3" ]
  }, {
    "name" : "KEY_LTE_EPDG_TIMER_SEC",
    "type" : "int",
    "comment" : "\n     * LTE ePDG timer (in seconds).\n     * Device shall not handover back to LTE until the T_ePDG_LTE timer expires.\n     * Value is in Integer format.\n     * @see #setProvisioningIntValue(int, int)\n     * @see #getProvisioningIntValue(int)\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "KEY_WIFI_EPDG_TIMER_SEC",
    "type" : "int",
    "comment" : "\n     * WiFi ePDG timer (in seconds).\n     * Device shall not handover back to WiFi until the T_ePDG_WiFi timer expires.\n     * Value is in Integer format.\n     * @see #setProvisioningIntValue(int, int)\n     * @see #getProvisioningIntValue(int)\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "KEY_1X_EPDG_TIMER_SEC",
    "type" : "int",
    "comment" : "\n     * 1x ePDG timer (in seconds).\n     * Device shall not re-register on 1x until the T_ePDG_1x timer expires.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "KEY_MULTIENDPOINT_ENABLED",
    "type" : "int",
    "comment" : "\n     * MultiEndpoint status: Enabled (1), or Disabled (0).\n     * Value is in Integer format.\n     * @see #setProvisioningIntValue(int, int)\n     * @see #getProvisioningIntValue(int)\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "KEY_RTT_ENABLED",
    "type" : "int",
    "comment" : "\n     * RTT status: Enabled (1), or Disabled (0).\n     * Value is in Integer format.\n     * @see #setProvisioningIntValue(int, int)\n     * @see #getProvisioningIntValue(int)\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "KEY_VOICE_OVER_WIFI_ENTITLEMENT_ID",
    "type" : "int",
    "comment" : "\n     * An obfuscated string defined by the carrier to indicate VoWiFi entitlement status.\n     *\n     * <p>Implementation note: how to generate the value and how it affects VoWiFi service\n     * should follow carrier requirements. For example, set an empty string could result in\n     * VoWiFi being disabled by IMS service, and set to a specific string could enable.\n     *\n     * <p>Value is in String format.\n     * @see #setProvisioningStringValue(int, String)\n     * @see #getProvisioningStringValue(int)\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "KEY_VOIMS_OPT_IN_STATUS",
    "type" : "int",
    "comment" : "\n     * An integer key representing the voice over IMS opt-in provisioning status for the\n     * associated subscription. Determines whether the user can see for voice services over\n     * IMS.\n     *\n     * <p> The flag will force to show the VoLTE option in settings irrespective of others VoLTE\n     * carrier config which hide the VoLTE option (e.g.\n     * {@link CarrierConfigManager#KEY_HIDE_ENHANCED_4G_LTE_BOOL}).\n     *\n     * <p>Use {@link #PROVISIONING_VALUE_ENABLED} to enable VoIMS provisioning and\n     * {@link #PROVISIONING_VALUE_DISABLED} to disable VoIMS  provisioning.\n     * @see #setProvisioningIntValue(int, int)\n     * @see #getProvisioningIntValue(int)\n     * @hide\n     ",
    "links" : [ "android.telephony.CarrierConfigManager#KEY_HIDE_ENHANCED_4G_LTE_BOOL", "#PROVISIONING_VALUE_DISABLED", "#PROVISIONING_VALUE_ENABLED" ]
  }, {
    "name" : "mSubId",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "ACTION_RCS_SINGLE_REGISTRATION_CAPABILITY_UPDATE",
    "type" : "String",
    "comment" : "\n     * Provides the single registration capability of the device and the carrier.\n     *\n     * <p>This intent only provides the capability and not the current provisioning status of\n     * the RCS VoLTE single registration feature. Only default messaging application may receive\n     * the intent.\n     *\n     * <p>Contains {@link #EXTRA_SUBSCRIPTION_ID} to specify the subscription index for which\n     * the intent is valid. and {@link #EXTRA_STATUS} to specify RCS VoLTE single registration\n     * status.\n     * @hide\n     ",
    "links" : [ "#EXTRA_SUBSCRIPTION_ID", "#EXTRA_STATUS" ]
  }, {
    "name" : "EXTRA_SUBSCRIPTION_ID",
    "type" : "String",
    "comment" : "\n     * Integer extra to specify subscription index.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "EXTRA_STATUS",
    "type" : "String",
    "comment" : "\n     * Integer extra to specify RCS single registration status\n     *\n     * <p>The value can be {@link #STATUS_CAPABLE}, {@link #STATUS_DEVICE_NOT_CAPABLE},\n     * {@link #STATUS_CARRIER_NOT_CAPABLE}, or bitwise OR of\n     * {@link #STATUS_DEVICE_NOT_CAPABLE} and {@link #STATUS_CARRIER_NOT_CAPABLE}.\n     * @hide\n     ",
    "links" : [ "#STATUS_CAPABLE", "#STATUS_CARRIER_NOT_CAPABLE", "#STATUS_DEVICE_NOT_CAPABLE" ]
  }, {
    "name" : "STATUS_CAPABLE",
    "type" : "int",
    "comment" : "\n     * RCS VoLTE single registration is supported by the device and carrier.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "STATUS_DEVICE_NOT_CAPABLE",
    "type" : "int",
    "comment" : "\n     * RCS VoLTE single registration is not supported by the device.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "STATUS_CARRIER_NOT_CAPABLE",
    "type" : "int",
    "comment" : "\n     * RCS VoLTE single registration is not supported by the carrier\n     * @hide\n     ",
    "links" : [ ]
  } ],
  "methods" : [ {
    "name" : "public static ProvisioningManager createForSubscriptionId(int subId)",
    "returnType" : "ProvisioningManager",
    "comment" : "\n     * Create a new {@link ProvisioningManager} for the subscription specified.\n     *\n     * @param subId The ID of the subscription that this ProvisioningManager will use.\n     * @see android.telephony.SubscriptionManager#getActiveSubscriptionInfoList()\n     * @throws IllegalArgumentException if the subscription is invalid.\n     * @hide\n     ",
    "links" : [ "android.telephony.ims.ProvisioningManager" ]
  }, {
    "name" : "public void registerProvisioningChangedCallback(@NonNull @CallbackExecutor Executor executor, @NonNull Callback callback) throws ImsException",
    "returnType" : "void",
    "comment" : "\n     * Register a new {@link Callback} to listen to changes to changes in IMS provisioning.\n     *\n     * When the subscription associated with this callback is removed (SIM removed, ESIM swap,\n     * etc...), this callback will automatically be removed.\n     *\n     * <p> Requires Permission:\n     * <ul>\n     *     <li>{@link android.Manifest.permission#READ_PRIVILEGED_PHONE_STATE},</li>\n     * </ul>\n     *\n     * @param executor The {@link Executor} to call the callback methods on\n     * @param callback The provisioning callbackto be registered.\n     * @see #unregisterProvisioningChangedCallback(Callback)\n     * @see SubscriptionManager.OnSubscriptionsChangedListener\n     * @throws IllegalArgumentException if the subscription associated with this callback is not\n     * active (SIM is not inserted, ESIM inactive) or the subscription is invalid.\n     * @throws ImsException if the subscription associated with this callback is valid, but\n     * the {@link ImsService} associated with the subscription is not available. This can happen if\n     * the service crashed, for example. See {@link ImsException#getCode()} for a more detailed\n     * reason.\n     * @hide\n     ",
    "links" : [ "android.telephony.ims.aidl.IFeatureProvisioningCallback", "android.Manifest.permission#READ_PRIVILEGED_PHONE_STATE", "android.annotation.CallbackExecutor", "android.telephony.ims.ImsException#getCode()", "android.telephony.ims.ImsService" ]
  }, {
    "name" : "public void unregisterProvisioningChangedCallback(@NonNull Callback callback)",
    "returnType" : "void",
    "comment" : "\n     * Unregister an existing {@link Callback}. When the subscription associated with this\n     * callback is removed (SIM removed, ESIM swap, etc...), this callback will automatically be\n     * removed. If this method is called for an inactive subscription, it will result in a no-op.\n     *\n     * <p> Requires Permission:\n     * <ul>\n     *     <li>{@link android.Manifest.permission#READ_PRIVILEGED_PHONE_STATE},</li>\n     * </ul>\n     *\n     * @param callback The existing {@link Callback} to be removed.\n     * @see #registerProvisioningChangedCallback(Executor, Callback)\n     *\n     * @throws IllegalArgumentException if the subscription associated with this callback is\n     * invalid.\n     * @hide\n     ",
    "links" : [ "android.telephony.ims.aidl.IFeatureProvisioningCallback", "android.Manifest.permission#READ_PRIVILEGED_PHONE_STATE" ]
  }, {
    "name" : "public void registerFeatureProvisioningChangedCallback(@NonNull @CallbackExecutor Executor executor, @NonNull FeatureProvisioningCallback callback) throws ImsException",
    "returnType" : "void",
    "comment" : "\n     * Register a new {@link FeatureProvisioningCallback}, which is used to listen for\n     * IMS feature provisioning updates.\n     * <p>\n     * When the subscription associated with this callback is removed (SIM removed,\n     * ESIM swap,etc...), this callback will automatically be removed.\n     *\n     * <p> Requires Permission:\n     * <ul>\n     *     <li> android.Manifest.permission#READ_PRIVILEGED_PHONE_STATE,</li>\n     *     <li>{@link android.Manifest.permission#READ_PRECISE_PHONE_STATE},</li>\n     *     <li>or that the caller has carrier privileges (see\n     *         {@link TelephonyManager#hasCarrierPrivileges()}).</li>\n     * </ul>\n     *\n     * @param executor The executor that the callback methods will be called on.\n     * @param callback The callback instance being registered.\n     * @throws ImsException if the subscription associated with this callback is\n     * valid, but the service crashed, for example. See\n     * {@link ImsException#getCode()} for a more detailed reason.\n     * @throws UnsupportedOperationException If the device does not have\n     *          {@link PackageManager#FEATURE_TELEPHONY_IMS}.\n     ",
    "links" : [ "android.content.pm.PackageManager#FEATURE_TELEPHONY_IMS", "android.Manifest.permission#READ_PRECISE_PHONE_STATE", "android.telephony.ims.aidl.IFeatureProvisioningCallback", "android.telephony.ims.ImsException#getCode()", "android.telephony.TelephonyManager#hasCarrierPrivileges()" ]
  }, {
    "name" : "public void unregisterFeatureProvisioningChangedCallback(@NonNull FeatureProvisioningCallback callback)",
    "returnType" : "void",
    "comment" : "\n     * Unregisters a previously registered {@link FeatureProvisioningCallback}\n     * instance.  When the subscription associated with this\n     * callback is removed (SIM removed, ESIM swap, etc...), this callback will\n     * automatically be removed. If this method is called for an inactive\n     * subscription, it will result in a no-op.\n     *\n     * @param callback The existing {@link FeatureProvisioningCallback} to be removed.\n     * @see #registerFeatureProvisioningChangedCallback(Executor, FeatureProvisioningCallback)\n     * @throws UnsupportedOperationException If the device does not have\n     *          {@link PackageManager#FEATURE_TELEPHONY_IMS}.\n     ",
    "links" : [ "android.content.pm.PackageManager#FEATURE_TELEPHONY_IMS", "android.telephony.ims.aidl.IFeatureProvisioningCallback" ]
  }, {
    "name" : "public int getProvisioningIntValue(int key)",
    "returnType" : "int",
    "comment" : "\n     * Query for the integer value associated with the provided key.\n     *\n     * This operation is blocking and should not be performed on the UI thread.\n     *\n     * @param key An integer that represents the provisioning key, which is defined by the OEM.\n     * @return an integer value for the provided key, or\n     * {@link ImsConfigImplBase#CONFIG_RESULT_UNKNOWN} if the key doesn't exist.\n     * @throws IllegalArgumentException if the key provided was invalid.\n     * @throws UnsupportedOperationException If the device does not have\n     *          {@link PackageManager#FEATURE_TELEPHONY_IMS}.\n     * @hide\n     ",
    "links" : [ "android.content.pm.PackageManager#FEATURE_TELEPHONY_IMS", "android.telephony.ims.stub.ImsConfigImplBase#CONFIG_RESULT_UNKNOWN" ]
  }, {
    "name" : "public String getProvisioningStringValue(int key)",
    "returnType" : "String",
    "comment" : "\n     * Query for the String value associated with the provided key.\n     *\n     * This operation is blocking and should not be performed on the UI thread.\n     *\n     * @param key A String that represents the provisioning key, which is defined by the OEM.\n     * @return a String value for the provided key, {@code null} if the key doesn't exist, or\n     * {@link StringResultError} if there was an error getting the value for the provided key.\n     * @throws IllegalArgumentException if the key provided was invalid.\n     * @throws UnsupportedOperationException If the device does not have\n     *          {@link PackageManager#FEATURE_TELEPHONY_IMS}.\n     * @hide\n     ",
    "links" : [ "android.content.pm.PackageManager#FEATURE_TELEPHONY_IMS", "StringResultError" ]
  }, {
    "name" : "public int setProvisioningIntValue(int key, int value)",
    "returnType" : "int",
    "comment" : "\n     * Set the integer value associated with the provided key.\n     *\n     * This operation is blocking and should not be performed on the UI thread.\n     *\n     * Use {@link #setProvisioningStringValue(int, String)} with proper namespacing (to be defined\n     * per OEM or carrier) when possible instead to avoid key collision if needed.\n     * @param key An integer that represents the provisioning key, which is defined by the OEM.\n     * @param value a integer value for the provided key.\n     * @return the result of setting the configuration value.\n     * @throws UnsupportedOperationException If the device does not have\n     *          {@link PackageManager#FEATURE_TELEPHONY_IMS}.\n     * @hide\n     *\n     * Note: For compatibility purposes, the integer values [0 - 99] used in\n     * {@link #setProvisioningIntValue(int, int)} have been reserved for existing provisioning keys\n     * previously defined in the Android framework. Please do not redefine new provisioning keys\n     * in this range or it may generate collisions with existing keys. Some common constants have\n     * also been defined in this class to make integrating with other system apps easier.\n     ",
    "links" : [ "android.content.pm.PackageManager#FEATURE_TELEPHONY_IMS", "#setProvisioningIntValue(int", "#setProvisioningStringValue(int" ]
  }, {
    "name" : "public int setProvisioningStringValue(int key, @NonNull String value)",
    "returnType" : "int",
    "comment" : "\n     * Set the String value associated with the provided key.\n     *\n     * This operation is blocking and should not be performed on the UI thread.\n     *\n     * @param key A String that represents the provisioning key, which is defined by the OEM and\n     *     should be appropriately namespaced to avoid collision.\n     * @param value a String value for the provided key.\n     * @return the result of setting the configuration value.\n     * @throws UnsupportedOperationException If the device does not have\n     *          {@link PackageManager#FEATURE_TELEPHONY_IMS}.\n     * @hide\n     ",
    "links" : [ "android.content.pm.PackageManager#FEATURE_TELEPHONY_IMS" ]
  }, {
    "name" : "public void setProvisioningStatusForCapability(@MmTelFeature.MmTelCapabilities.MmTelCapability int capability, @ImsRegistrationImplBase.ImsRegistrationTech int tech, boolean isProvisioned)",
    "returnType" : "void",
    "comment" : "\n     * Set the provisioning status for the IMS MmTel capability using the specified subscription.\n     *\n     * Provisioning may or may not be required, depending on the carrier configuration. If\n     * provisioning is not required for the carrier associated with this subscription or the device\n     * does not support the capability/technology combination specified, this operation will be a\n     * no-op.\n     *\n     * <p>Requires Permission:\n     * <ul>\n     *     <li>{@link android.Manifest.permission#MODIFY_PHONE_STATE},</li>\n     *     <li>or that the calling app has carrier privileges (see</li>\n     *     <li>{@link TelephonyManager#hasCarrierPrivileges}).</li>\n     * </ul>\n     *\n     * @see CarrierConfigManager.Ims#KEY_MMTEL_REQUIRES_PROVISIONING_BUNDLE\n     * @param isProvisioned true if the device is provisioned for UT over IMS, false otherwise.\n     *\n     * @throws UnsupportedOperationException If the device does not have\n     *          {@link PackageManager#FEATURE_TELEPHONY_IMS}.\n     ",
    "links" : [ "android.content.pm.PackageManager#FEATURE_TELEPHONY_IMS", "android.Manifest.permission#MODIFY_PHONE_STATE", "android.telephony.TelephonyManager#hasCarrierPrivileges" ]
  }, {
    "name" : "public boolean getProvisioningStatusForCapability(@MmTelFeature.MmTelCapabilities.MmTelCapability int capability, @ImsRegistrationImplBase.ImsRegistrationTech int tech)",
    "returnType" : "boolean",
    "comment" : "\n     * Get the provisioning status for the IMS MmTel capability specified.\n     *\n     * If provisioning is not required for the queried {@code capability} and\n     * {@code tech} combination specified, this method will\n     * always return {@code true}.\n     *\n     * <p> Requires Permission:\n     * <ul>\n     *     <li>android.Manifest.permission#READ_PRIVILEGED_PHONE_STATE,</li>\n     *     <li>{@link android.Manifest.permission#READ_PRECISE_PHONE_STATE},</li>\n     *     <li>or that the caller has carrier privileges (see\n     *         {@link TelephonyManager#hasCarrierPrivileges()}).</li>\n     * </ul>\n     *\n     * @see CarrierConfigManager.Ims#KEY_MMTEL_REQUIRES_PROVISIONING_BUNDLE\n     * @return true if the device is provisioned for the capability or does not require\n     * provisioning, false if the capability does require provisioning and has not been\n     * provisioned yet.\n     *\n     * @throws UnsupportedOperationException If the device does not have\n     *          {@link PackageManager#FEATURE_TELEPHONY_IMS}.\n     ",
    "links" : [ "android.content.pm.PackageManager#FEATURE_TELEPHONY_IMS", "android.Manifest.permission#READ_PRECISE_PHONE_STATE", "android.telephony.TelephonyManager#hasCarrierPrivileges()" ]
  }, {
    "name" : "public boolean getRcsProvisioningStatusForCapability(@ImsRcsManager.RcsImsCapabilityFlag int capability)",
    "returnType" : "boolean",
    "comment" : "\n     * Get the provisioning status for the IMS RCS capability specified.\n     *\n     * If provisioning is not required for the queried\n     * {@code capability} or if the device does not support IMS\n     * this method will always return {@code true}.\n     *\n     * @see CarrierConfigManager.Ims#KEY_CARRIER_RCS_PROVISIONING_REQUIRED_BOOL\n     * @return true if the device is provisioned for the capability or does not require\n     * provisioning, false if the capability does require provisioning and has not been\n     * provisioned yet.\n     * @throws UnsupportedOperationException If the device does not have\n     *          {@link PackageManager#FEATURE_TELEPHONY_IMS}.\n     *\n     * @deprecated Use {@link #getRcsProvisioningStatusForCapability(int, int)} instead,\n     * as this only retrieves provisioning information for\n     * {@link ImsRegistrationImplBase#REGISTRATION_TECH_LTE}\n     * @hide\n     ",
    "links" : [ "android.content.pm.PackageManager#FEATURE_TELEPHONY_IMS", "#getRcsProvisioningStatusForCapability(int", "android.telephony.ims.stub.ImsRegistrationImplBase#REGISTRATION_TECH_LTE" ]
  }, {
    "name" : "public boolean getRcsProvisioningStatusForCapability(@ImsRcsManager.RcsImsCapabilityFlag int capability, @ImsRegistrationImplBase.ImsRegistrationTech int tech)",
    "returnType" : "boolean",
    "comment" : "\n     * Get the provisioning status for the IMS RCS capability specified.\n     *\n     * If provisioning is not required for the queried\n     * {@code capability} or if the device does not support IMS\n     * this method will always return {@code true}.\n     *\n     * <p> Requires Permission:\n     * <ul>\n     *     <li>{@link android.Manifest.permission#READ_PRECISE_PHONE_STATE},</li>\n     *     <li>or that the caller has carrier privileges (see\n     *         {@link TelephonyManager#hasCarrierPrivileges()}).</li>\n     * </ul>\n     *\n     * @see CarrierConfigManager.Ims#KEY_RCS_REQUIRES_PROVISIONING_BUNDLE\n     * @return true if the device is provisioned for the capability or does not require\n     * provisioning, false if the capability does require provisioning and has not been\n     * provisioned yet.\n     *\n     * @throws UnsupportedOperationException If the device does not have\n     *          {@link PackageManager#FEATURE_TELEPHONY_IMS}.\n     ",
    "links" : [ "android.content.pm.PackageManager#FEATURE_TELEPHONY_IMS", "android.Manifest.permission#READ_PRECISE_PHONE_STATE", "android.telephony.TelephonyManager#hasCarrierPrivileges()" ]
  }, {
    "name" : "public void setRcsProvisioningStatusForCapability(@ImsRcsManager.RcsImsCapabilityFlag int capability, boolean isProvisioned)",
    "returnType" : "void",
    "comment" : "\n     * Set the provisioning status for the IMS RCS capability using the specified subscription.\n     *\n     * <p> Requires Permission:\n     * <ul>\n     *     <li>{@link android.Manifest.permission#MODIFY_PHONE_STATE}</li>\n     *     <li>or that the caller has carrier privileges (see\n     *         {@link TelephonyManager#hasCarrierPrivileges()}).</li>\n     * </ul>\n\n     * Provisioning may or may not be required, depending on the carrier configuration. If\n     * provisioning is not required for the carrier associated with this subscription or the device\n     * does not support the capability/technology combination specified, this operation will be a\n     * no-op.\n     *\n     * @see CarrierConfigManager#KEY_CARRIER_RCS_PROVISIONING_REQUIRED_BOOL\n     * @param isProvisioned true if the device is provisioned for the RCS capability specified,\n     *                      false otherwise.\n     * @throws UnsupportedOperationException If the device does not have\n     *          {@link PackageManager#FEATURE_TELEPHONY_IMS}.\n     *\n     * @deprecated Use {@link #setRcsProvisioningStatusForCapability(int, int, boolean)} instead,\n     * as this method only sets provisioning information for\n     * {@link ImsRegistrationImplBase#REGISTRATION_TECH_LTE}\n     * @hide\n     ",
    "links" : [ "android.content.pm.PackageManager#FEATURE_TELEPHONY_IMS", "#setRcsProvisioningStatusForCapability(int", "android.Manifest.permission#MODIFY_PHONE_STATE", "android.telephony.ims.stub.ImsRegistrationImplBase#REGISTRATION_TECH_LTE", "android.telephony.TelephonyManager#hasCarrierPrivileges()" ]
  }, {
    "name" : "public void setRcsProvisioningStatusForCapability(@ImsRcsManager.RcsImsCapabilityFlag int capability, @ImsRegistrationImplBase.ImsRegistrationTech int tech, boolean isProvisioned)",
    "returnType" : "void",
    "comment" : "\n     * Set the provisioning status for the IMS RCS capability using the specified subscription.\n     *\n     * Provisioning may or may not be required, depending on the carrier configuration. If\n     * provisioning is not required for the carrier associated with this subscription or the device\n     * does not support the capability/technology combination specified, this operation will be a\n     * no-op.\n     *\n     * <p> Requires Permission:\n     * <ul>\n     *     <li>{@link android.Manifest.permission#MODIFY_PHONE_STATE},</li>\n     *     <li>or that the caller has carrier privileges (see\n     *         {@link TelephonyManager#hasCarrierPrivileges()}).</li>\n     * </ul>\n     *\n     * @see CarrierConfigManager.Ims#KEY_RCS_REQUIRES_PROVISIONING_BUNDLE\n     * @param isProvisioned true if the device is provisioned for the RCS capability specified,\n     *                      false otherwise.\n     *\n     * @throws UnsupportedOperationException If the device does not have\n     *          {@link PackageManager#FEATURE_TELEPHONY_IMS}.\n     ",
    "links" : [ "android.content.pm.PackageManager#FEATURE_TELEPHONY_IMS", "android.Manifest.permission#MODIFY_PHONE_STATE", "android.telephony.TelephonyManager#hasCarrierPrivileges()" ]
  }, {
    "name" : "public boolean isProvisioningRequiredForCapability(@MmTelFeature.MmTelCapabilities.MmTelCapability int capability, @ImsRegistrationImplBase.ImsRegistrationTech int tech)",
    "returnType" : "boolean",
    "comment" : "\n     * Indicates whether provisioning for the MMTEL capability and IMS registration technology\n     * specified is required or not\n     *\n     * <p> Requires Permission:\n     * <ul>\n     *     <li> android.Manifest.permission#READ_PRIVILEGED_PHONE_STATE,</li>\n     *     <li>{@link android.Manifest.permission#READ_PRECISE_PHONE_STATE},</li>\n     *     <li> or that the caller has carrier privileges (see\n     *         {@link TelephonyManager#hasCarrierPrivileges()}).</li>\n     * </ul>\n     *\n     * @return true if provisioning is required for the MMTEL capability and IMS\n     * registration technology specified, false if it is not required or if the device does not\n     * support IMS.\n     *\n     * @throws UnsupportedOperationException If the device does not have\n     *          {@link PackageManager#FEATURE_TELEPHONY_IMS}.\n     ",
    "links" : [ "android.content.pm.PackageManager#FEATURE_TELEPHONY_IMS", "android.Manifest.permission#READ_PRECISE_PHONE_STATE", "android.telephony.TelephonyManager#hasCarrierPrivileges()" ]
  }, {
    "name" : "public boolean isRcsProvisioningRequiredForCapability(@ImsRcsManager.RcsImsCapabilityFlag int capability, @ImsRegistrationImplBase.ImsRegistrationTech int tech)",
    "returnType" : "boolean",
    "comment" : "\n     * Indicates whether provisioning for the RCS capability and IMS registration technology\n     * specified is required or not\n     *\n     * <p> Requires Permission:\n     * <ul>\n     *     <li> android.Manifest.permission#READ_PRIVILEGED_PHONE_STATE,</li>\n     *     <li>{@link android.Manifest.permission#READ_PRECISE_PHONE_STATE},</li>\n     *     <li> or that the caller has carrier privileges (see\n     *         {@link TelephonyManager#hasCarrierPrivileges()}).</li>\n     * </ul>\n     *\n     * @return true if provisioning is required for the RCS capability and IMS\n     * registration technology specified, false if it is not required or if the device does not\n     * support IMS.\n     *\n     * @throws UnsupportedOperationException If the device does not have\n     *          {@link PackageManager#FEATURE_TELEPHONY_IMS}.\n     ",
    "links" : [ "android.content.pm.PackageManager#FEATURE_TELEPHONY_IMS", "android.Manifest.permission#READ_PRECISE_PHONE_STATE", "android.telephony.TelephonyManager#hasCarrierPrivileges()" ]
  }, {
    "name" : "public void notifyRcsAutoConfigurationReceived(@NonNull byte[] config, boolean isCompressed)",
    "returnType" : "void",
    "comment" : "\n     * Notify the framework that an RCS autoconfiguration XML file has been received for\n     * provisioning. This API is only valid if the device supports IMS, which can be checked using\n     * {@link PackageManager#hasSystemFeature}.\n     *\n     * <p>Requires Permission:\n     * <ul>\n     *     <li>{@link Manifest.permission#MODIFY_PHONE_STATE},</li>\n     *     <li>or that the calling app has carrier privileges (see\n     *         {@link TelephonyManager#hasCarrierPrivileges()}).</li>\n     * </ul>\n     *\n     * @param config The XML file to be read. ASCII/UTF8 encoded text if not compressed.\n     * @param isCompressed The XML file is compressed in gzip format and must be decompressed\n     *         before being read.\n     *\n     * @throws UnsupportedOperationException If the device does not have\n     *          {@link PackageManager#FEATURE_TELEPHONY_IMS_SINGLE_REGISTRATION}.\n     * @hide\n     ",
    "links" : [ "android.content.pm.PackageManager#FEATURE_TELEPHONY_IMS_SINGLE_REGISTRATION", "Manifest.permission#MODIFY_PHONE_STATE", "android.content.pm.PackageManager#hasSystemFeature", "android.telephony.TelephonyManager#hasCarrierPrivileges()" ]
  }, {
    "name" : "public void setRcsClientConfiguration(@NonNull RcsClientConfiguration rcc) throws ImsException",
    "returnType" : "void",
    "comment" : "\n     * Provide the client configuration parameters of the RCS application.\n     *\n     * <p>When this application is also the default messaging application, and RCS\n     * provisioning is done using autoconfiguration, then these parameters shall be\n     * sent in the HTTP get request to fetch the RCS provisioning. RCS client\n     * configuration must be provided by the application before registering for the\n     * provisioning status events\n     * {@link #registerRcsProvisioningCallback(Executor, RcsProvisioningCallback)}\n     * When the IMS/RCS service receives the RCS client configuration, it will detect\n     * the change in the configuration, and trigger the auto-configuration as needed.\n     * @param rcc RCS client configuration {@link RcsClientConfiguration}\n     *\n     * @throws UnsupportedOperationException If the device does not have\n     *          {@link PackageManager#FEATURE_TELEPHONY_IMS_SINGLE_REGISTRATION}.\n     * @hide\n     ",
    "links" : [ "android.content.pm.PackageManager#FEATURE_TELEPHONY_IMS_SINGLE_REGISTRATION", "android.telephony.ims.RcsClientConfiguration", "#registerRcsProvisioningCallback(Executor" ]
  }, {
    "name" : "public boolean isRcsVolteSingleRegistrationCapable() throws ImsException",
    "returnType" : "boolean",
    "comment" : "\n     * Returns a flag to indicate whether or not the device supports IMS single registration for\n     * MMTEL and RCS features as well as if the carrier has provisioned the feature.\n     *\n     * <p> Requires Permission:\n     * <ul>\n     *     <li>{@link android.Manifest.permission#READ_PRIVILEGED_PHONE_STATE},</li>\n     *     <li>{@link android.Manifest.permission#PERFORM_IMS_SINGLE_REGISTRATION},</li>\n     *     <li>or that the calling app has carrier privileges (see\n     *         {@link TelephonyManager#hasCarrierPrivileges()}).</li>\n     * </ul>\n     *\n     * @return true if IMS single registration is capable at this time, or false otherwise\n     * @throws ImsException If the remote ImsService is not available for any reason or\n     * the subscription associated with this instance is no longer active.\n     * See {@link ImsException#getCode()} for more information.\n     * @see PackageManager#FEATURE_TELEPHONY_IMS_SINGLE_REGISTRATION for whether or not this\n     * device supports IMS single registration.\n     * @hide\n     ",
    "links" : [ "android.Manifest.permission#READ_PRIVILEGED_PHONE_STATE", "android.telephony.ims.ImsException#getCode()", "android.Manifest.permission#PERFORM_IMS_SINGLE_REGISTRATION", "android.telephony.TelephonyManager#hasCarrierPrivileges()" ]
  }, {
    "name" : "public void registerRcsProvisioningCallback(@NonNull @CallbackExecutor Executor executor, @NonNull RcsProvisioningCallback callback) throws ImsException",
    "returnType" : "void",
    "comment" : "\n    * Registers a new {@link RcsProvisioningCallback} to listen to changes to\n    * RCS provisioning xml.\n    *\n    * <p>RCS application must be the default messaging application and must\n    * have already registered its {@link RcsClientConfiguration} by using\n    * {@link #setRcsClientConfiguration} before it registers the provisioning\n    * callback. If ProvisioningManager has a valid RCS configuration at the\n    * time of callback registration and a reconfiguration is not required\n    * due to RCS client parameters change, then the callback shall be invoked\n    * immediately with the xml.\n    * When the subscription associated with this callback is removed (SIM removed,\n    * ESIM swap,etc...), this callback will automatically be removed.\n    * <p> Requires Permission:\n    * <ul>\n    *     <li>{@link android.Manifest.permission#READ_PRIVILEGED_PHONE_STATE},</li>\n    *     <li>{@link android.Manifest.permission#PERFORM_IMS_SINGLE_REGISTRATION},</li>\n    * </ul>\n    *\n    * @param executor The {@link Executor} to call the callback methods on\n    * @param callback The rcs provisioning callback to be registered.\n    * @see #unregisterRcsProvisioningCallback(RcsProvisioningCallback)\n    * @see SubscriptionManager.OnSubscriptionsChangedListener\n    * @throws IllegalArgumentException if the subscription associated with this\n    * callback is not active (SIM is not inserted, ESIM inactive) or the\n    * subscription is invalid.\n    * @throws ImsException if the subscription associated with this callback is\n    * valid, but the {@link ImsService} associated with the subscription is not\n    * available. This can happen if the service crashed, for example.\n    * It shall also throw this exception when the RCS client parameters for the\n    * application are not valid. In that case application must set the client\n    * params (See {@link #setRcsClientConfiguration}) and re register the\n    * callback.\n    * See {@link ImsException#getCode()} for a more detailed reason.\n    * @throws UnsupportedOperationException If the device does not have\n    *          {@link PackageManager#FEATURE_TELEPHONY_IMS_SINGLE_REGISTRATION}.\n    * @hide\n    ",
    "links" : [ "android.content.pm.PackageManager#FEATURE_TELEPHONY_IMS_SINGLE_REGISTRATION", "android.telephony.ims.RcsClientConfiguration", "RcsProvisioningCallback", "android.Manifest.permission#READ_PRIVILEGED_PHONE_STATE", "android.annotation.CallbackExecutor", "#setRcsClientConfiguration", "android.telephony.ims.ImsException#getCode()", "android.Manifest.permission#PERFORM_IMS_SINGLE_REGISTRATION", "android.telephony.ims.ImsService" ]
  }, {
    "name" : "public void unregisterRcsProvisioningCallback(@NonNull RcsProvisioningCallback callback)",
    "returnType" : "void",
    "comment" : "\n     * Unregister an existing {@link RcsProvisioningCallback}. Application can\n     * unregister when its no longer interested in the provisioning updates\n     * like when a user disables RCS from the UI/settings.\n     * When the subscription associated with this callback is removed (SIM\n     * removed, ESIM swap, etc...), this callback will automatically be\n     * removed. If this method is called for an inactive subscription, it\n     * will result in a no-op.\n     * <p> Requires Permission:\n     * <ul>\n     *     <li>{@link android.Manifest.permission#READ_PRIVILEGED_PHONE_STATE},</li>\n     *     <li>{@link android.Manifest.permission#PERFORM_IMS_SINGLE_REGISTRATION},</li>\n     * </ul>\n     *\n     * @param callback The existing {@link RcsProvisioningCallback} to be\n     * removed.\n     * @see #registerRcsProvisioningCallback(Executor, RcsProvisioningCallback)\n     * @throws IllegalArgumentException if the subscription associated with\n     * this callback is invalid.\n     * @throws UnsupportedOperationException If the device does not have\n     *          {@link PackageManager#FEATURE_TELEPHONY_IMS_SINGLE_REGISTRATION}.\n     * @hide\n     ",
    "links" : [ "android.content.pm.PackageManager#FEATURE_TELEPHONY_IMS_SINGLE_REGISTRATION", "RcsProvisioningCallback", "android.Manifest.permission#READ_PRIVILEGED_PHONE_STATE", "android.Manifest.permission#PERFORM_IMS_SINGLE_REGISTRATION" ]
  }, {
    "name" : "public void triggerRcsReconfiguration()",
    "returnType" : "void",
    "comment" : "\n     * Reconfiguration triggered by the RCS application. Most likely cause\n     * is the 403 forbidden to a HTTP request. This API is only valid if the device supports IMS,\n     * which can be checked using {@link PackageManager#hasSystemFeature}\n     *\n     * <p>When this api is called, the RCS configuration for the associated\n     * subscription will be removed, and the application which has registered\n     * {@link RcsProvisioningCallback} may expect to receive\n     * {@link RcsProvisioningCallback#onConfigurationReset}, then\n     * {@link RcsProvisioningCallback#onConfigurationChanged} when the new\n     * RCS configuration is received and notified by {@link #notifyRcsAutoConfigurationReceived}\n     *\n     * @throws UnsupportedOperationException If the device does not have\n     *          {@link PackageManager#FEATURE_TELEPHONY_IMS_SINGLE_REGISTRATION}.\n     * @hide\n     ",
    "links" : [ "android.content.pm.PackageManager#FEATURE_TELEPHONY_IMS_SINGLE_REGISTRATION", "#notifyRcsAutoConfigurationReceived", "#onConfigurationReset", "RcsProvisioningCallback", "#onConfigurationChanged", "android.content.pm.PackageManager#hasSystemFeature" ]
  }, {
    "name" : "private static ITelephony getITelephony()",
    "returnType" : "ITelephony",
    "comment" : "",
    "links" : [ ]
  } ],
  "methodNames" : [ "public static ProvisioningManager createForSubscriptionId(int subId)", "public void registerProvisioningChangedCallback(@NonNull @CallbackExecutor Executor executor, @NonNull Callback callback) throws ImsException", "public void unregisterProvisioningChangedCallback(@NonNull Callback callback)", "public void registerFeatureProvisioningChangedCallback(@NonNull @CallbackExecutor Executor executor, @NonNull FeatureProvisioningCallback callback) throws ImsException", "public void unregisterFeatureProvisioningChangedCallback(@NonNull FeatureProvisioningCallback callback)", "public int getProvisioningIntValue(int key)", "public String getProvisioningStringValue(int key)", "public int setProvisioningIntValue(int key, int value)", "public int setProvisioningStringValue(int key, @NonNull String value)", "public void setProvisioningStatusForCapability(@MmTelFeature.MmTelCapabilities.MmTelCapability int capability, @ImsRegistrationImplBase.ImsRegistrationTech int tech, boolean isProvisioned)", "public boolean getProvisioningStatusForCapability(@MmTelFeature.MmTelCapabilities.MmTelCapability int capability, @ImsRegistrationImplBase.ImsRegistrationTech int tech)", "public boolean getRcsProvisioningStatusForCapability(@ImsRcsManager.RcsImsCapabilityFlag int capability)", "public boolean getRcsProvisioningStatusForCapability(@ImsRcsManager.RcsImsCapabilityFlag int capability, @ImsRegistrationImplBase.ImsRegistrationTech int tech)", "public void setRcsProvisioningStatusForCapability(@ImsRcsManager.RcsImsCapabilityFlag int capability, boolean isProvisioned)", "public void setRcsProvisioningStatusForCapability(@ImsRcsManager.RcsImsCapabilityFlag int capability, @ImsRegistrationImplBase.ImsRegistrationTech int tech, boolean isProvisioned)", "public boolean isProvisioningRequiredForCapability(@MmTelFeature.MmTelCapabilities.MmTelCapability int capability, @ImsRegistrationImplBase.ImsRegistrationTech int tech)", "public boolean isRcsProvisioningRequiredForCapability(@ImsRcsManager.RcsImsCapabilityFlag int capability, @ImsRegistrationImplBase.ImsRegistrationTech int tech)", "public void notifyRcsAutoConfigurationReceived(@NonNull byte[] config, boolean isCompressed)", "public void setRcsClientConfiguration(@NonNull RcsClientConfiguration rcc) throws ImsException", "public boolean isRcsVolteSingleRegistrationCapable() throws ImsException", "public void registerRcsProvisioningCallback(@NonNull @CallbackExecutor Executor executor, @NonNull RcsProvisioningCallback callback) throws ImsException", "public void unregisterRcsProvisioningCallback(@NonNull RcsProvisioningCallback callback)", "public void triggerRcsReconfiguration()", "private static ITelephony getITelephony()" ],
  "variableNames" : [ "TAG", "STRING_QUERY_RESULT_ERROR_GENERIC", "STRING_QUERY_RESULT_ERROR_NOT_READY", "PROVISIONING_RESULT_UNKNOWN", "PROVISIONING_VALUE_DISABLED", "PROVISIONING_VALUE_ENABLED", "KEY_AMR_CODEC_MODE_SET_VALUES", "KEY_AMR_WB_CODEC_MODE_SET_VALUES", "KEY_SIP_SESSION_TIMER_SEC", "KEY_MINIMUM_SIP_SESSION_EXPIRATION_TIMER_SEC", "KEY_SIP_INVITE_CANCELLATION_TIMER_MS", "KEY_TRANSITION_TO_LTE_DELAY_MS", "KEY_ENABLE_SILENT_REDIAL", "KEY_T1_TIMER_VALUE_MS", "KEY_T2_TIMER_VALUE_MS", "KEY_TF_TIMER_VALUE_MS", "KEY_VOLTE_PROVISIONING_STATUS", "KEY_VT_PROVISIONING_STATUS", "KEY_REGISTRATION_DOMAIN_NAME", "KEY_SMS_FORMAT", "SMS_FORMAT_3GPP2", "SMS_FORMAT_3GPP", "KEY_SMS_OVER_IP_ENABLED", "KEY_RCS_PUBLISH_TIMER_SEC", "KEY_RCS_PUBLISH_OFFLINE_AVAILABILITY_TIMER_SEC", "KEY_RCS_CAPABILITY_DISCOVERY_ENABLED", "KEY_RCS_CAPABILITIES_CACHE_EXPIRATION_SEC", "KEY_RCS_AVAILABILITY_CACHE_EXPIRATION_SEC", "KEY_RCS_CAPABILITIES_POLL_INTERVAL_SEC", "KEY_RCS_PUBLISH_SOURCE_THROTTLE_MS", "KEY_RCS_MAX_NUM_ENTRIES_IN_RCL", "KEY_RCS_CAPABILITY_POLL_LIST_SUB_EXP_SEC", "KEY_USE_GZIP_FOR_LIST_SUBSCRIPTION", "KEY_EAB_PROVISIONING_STATUS", "KEY_VOICE_OVER_WIFI_ROAMING_ENABLED_OVERRIDE", "KEY_VOICE_OVER_WIFI_MODE_OVERRIDE", "KEY_VOICE_OVER_WIFI_ENABLED_OVERRIDE", "KEY_MOBILE_DATA_ENABLED", "KEY_VOLTE_USER_OPT_IN_STATUS", "KEY_LOCAL_BREAKOUT_PCSCF_ADDRESS", "KEY_SIP_KEEP_ALIVE_ENABLED", "KEY_REGISTRATION_RETRY_BASE_TIME_SEC", "KEY_REGISTRATION_RETRY_MAX_TIME_SEC", "KEY_RTP_SPEECH_START_PORT", "KEY_RTP_SPEECH_END_PORT", "KEY_SIP_INVITE_REQUEST_TRANSMIT_INTERVAL_MS", "KEY_SIP_INVITE_ACK_WAIT_TIME_MS", "KEY_SIP_INVITE_RESPONSE_RETRANSMIT_WAIT_TIME_MS", "KEY_SIP_NON_INVITE_REQUEST_RETRANSMIT_INTERVAL_MS", "KEY_SIP_NON_INVITE_TRANSACTION_TIMEOUT_TIMER_MS", "KEY_SIP_INVITE_RESPONSE_RETRANSMIT_INTERVAL_MS", "KEY_SIP_ACK_RECEIPT_WAIT_TIME_MS", "KEY_SIP_ACK_RETRANSMIT_WAIT_TIME_MS", "KEY_SIP_NON_INVITE_REQUEST_RETRANSMISSION_WAIT_TIME_MS", "KEY_SIP_NON_INVITE_RESPONSE_RETRANSMISSION_WAIT_TIME_MS", "KEY_AMR_WB_OCTET_ALIGNED_PAYLOAD_TYPE", "KEY_AMR_WB_BANDWIDTH_EFFICIENT_PAYLOAD_TYPE", "KEY_AMR_OCTET_ALIGNED_PAYLOAD_TYPE", "KEY_AMR_BANDWIDTH_EFFICIENT_PAYLOAD_TYPE", "KEY_DTMF_WB_PAYLOAD_TYPE", "KEY_DTMF_NB_PAYLOAD_TYPE", "KEY_AMR_DEFAULT_ENCODING_MODE", "KEY_SMS_PUBLIC_SERVICE_IDENTITY", "KEY_VIDEO_QUALITY", "VIDEO_QUALITY_LOW", "VIDEO_QUALITY_HIGH", "KEY_LTE_THRESHOLD_1", "KEY_LTE_THRESHOLD_2", "KEY_LTE_THRESHOLD_3", "KEY_1X_THRESHOLD", "KEY_WIFI_THRESHOLD_A", "KEY_WIFI_THRESHOLD_B", "KEY_LTE_EPDG_TIMER_SEC", "KEY_WIFI_EPDG_TIMER_SEC", "KEY_1X_EPDG_TIMER_SEC", "KEY_MULTIENDPOINT_ENABLED", "KEY_RTT_ENABLED", "KEY_VOICE_OVER_WIFI_ENTITLEMENT_ID", "KEY_VOIMS_OPT_IN_STATUS", "mSubId", "ACTION_RCS_SINGLE_REGISTRATION_CAPABILITY_UPDATE", "EXTRA_SUBSCRIPTION_ID", "EXTRA_STATUS", "STATUS_CAPABLE", "STATUS_DEVICE_NOT_CAPABLE", "STATUS_CARRIER_NOT_CAPABLE" ]
}