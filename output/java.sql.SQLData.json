{
  "filePath" : "/home/maryam/clearblue/files/android-source-35/java/sql/SQLData.java",
  "packageName" : "java.sql",
  "className" : "SQLData",
  "comment" : "\n * The interface used for the custom mapping of an SQL user-defined type (UDT) to\n * a class in the Java programming language. The class object for a class\n * implementing the <code>SQLData</code> interface will be entered in the\n * appropriate <code>Connection</code> object's type map along with the SQL\n * name of the UDT for which it is a custom mapping.\n * <P>\n * Typically, a <code>SQLData</code> implementation\n * will define a field for each attribute of an SQL structured type or a\n * single field for an SQL <code>DISTINCT</code> type. When the UDT is\n * retrieved from a data source with the <code>ResultSet.getObject</code>\n * method, it will be mapped as an instance of this class.  A programmer\n * can operate on this class instance just as on any other object in the\n * Java programming language and then store any changes made to it by\n * calling the <code>PreparedStatement.setObject</code> method,\n * which will map it back to the SQL type.\n * <p>\n * It is expected that the implementation of the class for a custom\n * mapping will be done by a tool.  In a typical implementation, the\n * programmer would simply supply the name of the SQL UDT, the name of\n * the class to which it is being mapped, and the names of the fields to\n * which each of the attributes of the UDT is to be mapped.  The tool will use\n * this information to implement the <code>SQLData.readSQL</code> and\n * <code>SQLData.writeSQL</code> methods.  The <code>readSQL</code> method\n * calls the appropriate <code>SQLInput</code> methods to read\n * each attribute from an <code>SQLInput</code> object, and the\n * <code>writeSQL</code> method calls <code>SQLOutput</code> methods\n * to write each attribute back to the data source via an\n * <code>SQLOutput</code> object.\n * <P>\n * An application programmer will not normally call <code>SQLData</code> methods\n * directly, and the <code>SQLInput</code> and <code>SQLOutput</code> methods\n * are called internally by <code>SQLData</code> methods, not by application code.\n *\n * @since 1.2\n ",
  "links" : [ ],
  "variables" : [ ],
  "methods" : [ {
    "name" : " String getSQLTypeName() throws SQLException",
    "returnType" : "String",
    "comment" : "\n  * Returns the fully-qualified\n  * name of the SQL user-defined type that this object represents.\n  * This method is called by the JDBC driver to get the name of the\n  * UDT instance that is being mapped to this instance of\n  * <code>SQLData</code>.\n  *\n  * @return the type name that was passed to the method <code>readSQL</code>\n  *            when this object was constructed and populated\n  * @exception SQLException if there is a database access error\n  * @exception SQLFeatureNotSupportedException if the JDBC driver does not support\n  * this method\n  * @since 1.2\n  ",
    "links" : [ ]
  }, {
    "name" : " void readSQL(SQLInput stream, String typeName) throws SQLException",
    "returnType" : "void",
    "comment" : "\n  * Populates this object with data read from the database.\n  * The implementation of the method must follow this protocol:\n  * <UL>\n  * <LI>It must read each of the attributes or elements of the SQL\n  * type  from the given input stream.  This is done\n  * by calling a method of the input stream to read each\n  * item, in the order that they appear in the SQL definition\n  * of the type.\n  * <LI>The method <code>readSQL</code> then\n  * assigns the data to appropriate fields or\n  * elements (of this or other objects).\n  * Specifically, it must call the appropriate <i>reader</i> method\n  * (<code>SQLInput.readString</code>, <code>SQLInput.readBigDecimal</code>,\n  * and so on) method(s) to do the following:\n  * for a distinct type, read its single data element;\n  * for a structured type, read a value for each attribute of the SQL type.\n  * </UL>\n  * The JDBC driver initializes the input stream with a type map\n  * before calling this method, which is used by the appropriate\n  * <code>SQLInput</code> reader method on the stream.\n  *\n  * @param stream the <code>SQLInput</code> object from which to read the data for\n  * the value that is being custom mapped\n  * @param typeName the SQL type name of the value on the data stream\n  * @exception SQLException if there is a database access error\n  * @exception SQLFeatureNotSupportedException if the JDBC driver does not support\n  * this method\n  * @see SQLInput\n  * @since 1.2\n  ",
    "links" : [ ]
  }, {
    "name" : " void writeSQL(SQLOutput stream) throws SQLException",
    "returnType" : "void",
    "comment" : "\n  * Writes this object to the given SQL data stream, converting it back to\n  * its SQL value in the data source.\n  * The implementation of the method must follow this protocol:<BR>\n  * It must write each of the attributes of the SQL type\n  * to the given output stream.  This is done by calling a\n  * method of the output stream to write each item, in the order that\n  * they appear in the SQL definition of the type.\n  * Specifically, it must call the appropriate <code>SQLOutput</code> writer\n  * method(s) (<code>writeInt</code>, <code>writeString</code>, and so on)\n  * to do the following: for a Distinct Type, write its single data element;\n  * for a Structured Type, write a value for each attribute of the SQL type.\n  *\n  * @param stream the <code>SQLOutput</code> object to which to write the data for\n  * the value that was custom mapped\n  * @exception SQLException if there is a database access error\n  * @exception SQLFeatureNotSupportedException if the JDBC driver does not support\n  * this method\n  * @see SQLOutput\n  * @since 1.2\n  ",
    "links" : [ ]
  } ],
  "methodNames" : [ " String getSQLTypeName() throws SQLException", " void readSQL(SQLInput stream, String typeName) throws SQLException", " void writeSQL(SQLOutput stream) throws SQLException" ],
  "variableNames" : [ ]
}