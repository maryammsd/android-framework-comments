{
  "filePath" : "/home/maryam/clearblue/files/android-source-35/android/bluetooth/BluetoothDevice.java",
  "packageName" : "android.bluetooth",
  "className" : "BluetoothDevice",
  "comment" : "\n * Represents a remote Bluetooth device. A {@link BluetoothDevice} lets you create a connection with\n * the respective device or query information about it, such as the name, address, class, and\n * bonding state.\n *\n * <p>This class is really just a thin wrapper for a Bluetooth hardware address. Objects of this\n * class are immutable. Operations on this class are performed on the remote Bluetooth hardware\n * address, using the {@link BluetoothAdapter} that was used to create this {@link BluetoothDevice}.\n *\n * <p>To get a {@link BluetoothDevice}, use {@link BluetoothAdapter#getRemoteDevice(String)\n * BluetoothAdapter.getRemoteDevice(String)} to create one representing a device of a known MAC\n * address (which you can get through device discovery with {@link BluetoothAdapter}) or get one\n * from the set of bonded devices returned by {@link BluetoothAdapter#getBondedDevices()\n * BluetoothAdapter.getBondedDevices()}. You can then open a {@link BluetoothSocket} for\n * communication with the remote device, using {@link #createRfcommSocketToServiceRecord(UUID)} over\n * Bluetooth BR/EDR or using {@link #createL2capChannel(int)} over Bluetooth LE.\n *\n * <p><div class=\"special reference\">\n *\n * <h3>Developer Guides</h3>\n *\n * <p>For more information about using Bluetooth, read the <a href=\n * \"{@docRoot}guide/topics/connectivity/bluetooth.html\">Bluetooth</a> developer guide. </div>\n *\n * @see BluetoothAdapter\n * @see BluetoothSocket\n ",
  "links" : [ "android.bluetooth.BluetoothDevice", "android.bluetooth.BluetoothSocket", "android.bluetooth.BluetoothAdapter", "#createL2capChannel(int)", "#createRfcommSocketToServiceRecord(UUID)", "android.bluetooth.BluetoothAdapter#getRemoteDevice(String)", "android.bluetooth.BluetoothAdapter#getBondedDevices()" ],
  "variables" : [ {
    "name" : "TAG",
    "type" : "String",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "DBG",
    "type" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "CONNECTION_STATE_DISCONNECTED",
    "type" : "int",
    "comment" : "\n     * Connection state bitmask disconnected bit as returned by getConnectionState.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "CONNECTION_STATE_CONNECTED",
    "type" : "int",
    "comment" : "\n     * Connection state bitmask connected bit as returned by getConnectionState.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "CONNECTION_STATE_ENCRYPTED_BREDR",
    "type" : "int",
    "comment" : "\n     * Connection state bitmask encrypted BREDR bit as returned by getConnectionState.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "CONNECTION_STATE_ENCRYPTED_LE",
    "type" : "int",
    "comment" : "\n     * Connection state bitmask encrypted LE bit as returned by getConnectionState.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "ERROR",
    "type" : "int",
    "comment" : "\n     * Sentinel error value for this class. Guaranteed to not equal any other integer constant in\n     * this class. Provided as a convenience for functions that require a sentinel error value, for\n     * example:\n     *\n     * <p><code>Intent.getIntExtra(BluetoothDevice.EXTRA_BOND_STATE,\n     * BluetoothDevice.ERROR)</code>\n     ",
    "links" : [ ]
  }, {
    "name" : "ACTION_FOUND",
    "type" : "String",
    "comment" : " TODO: Change API to not broadcast RSSI if not available (incoming connection)",
    "links" : [ ]
  }, {
    "name" : "ACTION_CLASS_CHANGED",
    "type" : "String",
    "comment" : "\n     * Broadcast Action: Bluetooth class of a remote device has changed.\n     *\n     * <p>Always contains the extra fields {@link #EXTRA_DEVICE} and {@link #EXTRA_CLASS}.\n     *\n     * @see BluetoothClass\n     ",
    "links" : [ "#EXTRA_DEVICE", "#EXTRA_CLASS" ]
  }, {
    "name" : "ACTION_ACL_CONNECTED",
    "type" : "String",
    "comment" : "\n     * Broadcast Action: Indicates a low level (ACL) connection has been established with a remote\n     * device.\n     *\n     * <p>Always contains the extra fields {@link #EXTRA_DEVICE} and {@link #EXTRA_TRANSPORT}.\n     *\n     * <p>ACL connections are managed automatically by the Android Bluetooth stack.\n     ",
    "links" : [ "#EXTRA_DEVICE", "#EXTRA_TRANSPORT" ]
  }, {
    "name" : "ACTION_ACL_DISCONNECT_REQUESTED",
    "type" : "String",
    "comment" : "\n     * Broadcast Action: Indicates that a low level (ACL) disconnection has been requested for a\n     * remote device, and it will soon be disconnected.\n     *\n     * <p>This is useful for graceful disconnection. Applications should use this intent as a hint\n     * to immediately terminate higher level connections (RFCOMM, L2CAP, or profile connections) to\n     * the remote device.\n     *\n     * <p>Always contains the extra field {@link #EXTRA_DEVICE}.\n     ",
    "links" : [ "#EXTRA_DEVICE" ]
  }, {
    "name" : "ACTION_ACL_DISCONNECTED",
    "type" : "String",
    "comment" : "\n     * Broadcast Action: Indicates a low level (ACL) disconnection from a remote device.\n     *\n     * <p>Always contains the extra fields {@link #EXTRA_DEVICE} and {@link #EXTRA_TRANSPORT}.\n     *\n     * <p>ACL connections are managed automatically by the Android Bluetooth stack.\n     ",
    "links" : [ "#EXTRA_DEVICE", "#EXTRA_TRANSPORT" ]
  }, {
    "name" : "ACTION_NAME_CHANGED",
    "type" : "String",
    "comment" : "\n     * Broadcast Action: Indicates the friendly name of a remote device has been retrieved for the\n     * first time, or changed since the last retrieval.\n     *\n     * <p>Always contains the extra fields {@link #EXTRA_DEVICE} and {@link #EXTRA_NAME}.\n     ",
    "links" : [ "#EXTRA_DEVICE", "#EXTRA_NAME" ]
  }, {
    "name" : "ACTION_ALIAS_CHANGED",
    "type" : "String",
    "comment" : "\n     * Broadcast Action: Indicates the alias of a remote device has been changed.\n     *\n     * <p>Always contains the extra field {@link #EXTRA_DEVICE}.\n     ",
    "links" : [ "#EXTRA_DEVICE" ]
  }, {
    "name" : "ACTION_BOND_STATE_CHANGED",
    "type" : "String",
    "comment" : " contain a hidden extra field EXTRA_UNBOND_REASON with the result code.",
    "links" : [ ]
  }, {
    "name" : "ACTION_BATTERY_LEVEL_CHANGED",
    "type" : "String",
    "comment" : "\n     * Broadcast Action: Indicates the battery level of a remote device has been retrieved for the\n     * first time, or changed since the last retrieval\n     *\n     * <p>Always contains the extra fields {@link #EXTRA_DEVICE} and {@link #EXTRA_BATTERY_LEVEL}.\n     *\n     * @hide\n     ",
    "links" : [ "#EXTRA_DEVICE", "#EXTRA_BATTERY_LEVEL" ]
  }, {
    "name" : "ACTION_SWITCH_BUFFER_SIZE",
    "type" : "String",
    "comment" : "\n     * Broadcast Action: Indicates the audio buffer size should be switched between a low latency\n     * buffer size and a higher and larger latency buffer size. Only registered receivers will\n     * receive this intent.\n     *\n     * <p>Always contains the extra fields {@link #EXTRA_DEVICE} and {@link\n     * #EXTRA_LOW_LATENCY_BUFFER_SIZE}.\n     *\n     * @hide\n     ",
    "links" : [ "#EXTRA_DEVICE", "#EXTRA_LOW_LATENCY_BUFFER_SIZE" ]
  }, {
    "name" : "ACTION_KEY_MISSING",
    "type" : "String",
    "comment" : "\n     * Broadcast Action: Indicates that previously bonded device couldn't provide keys to establish\n     * encryption. This can have numerous reasons, i.e.:\n     *\n     * <ul>\n     *   <li>remote was factory reset, or removed bond\n     *   <li>spoofing attack, someone is impersonating remote device\n     *   <li>in case of LE devices, very unlikely address collision\n     * </ul>\n     *\n     * Only registered receivers will receive this intent.\n     *\n     * <p>Always contains the extra field {@link #EXTRA_DEVICE}\n     *\n     * @hide\n     ",
    "links" : [ "#EXTRA_DEVICE" ]
  }, {
    "name" : "EXTRA_BATTERY_LEVEL",
    "type" : "String",
    "comment" : "\n     * Used as an Integer extra field in {@link #ACTION_BATTERY_LEVEL_CHANGED} intent. It contains\n     * the most recently retrieved battery level information ranging from 0% to 100% for a remote\n     * device, {@link #BATTERY_LEVEL_UNKNOWN} when the valid is unknown or there is an error, {@link\n     * #BATTERY_LEVEL_BLUETOOTH_OFF} when the bluetooth is off\n     *\n     * @hide\n     ",
    "links" : [ "#ACTION_BATTERY_LEVEL_CHANGED", "#BATTERY_LEVEL_BLUETOOTH_OFF", "#BATTERY_LEVEL_UNKNOWN" ]
  }, {
    "name" : "BATTERY_LEVEL_UNKNOWN",
    "type" : "int",
    "comment" : "\n     * Used as the unknown value for {@link #EXTRA_BATTERY_LEVEL} and {@link #getBatteryLevel()}\n     *\n     * @hide\n     ",
    "links" : [ "#getBatteryLevel()", "#EXTRA_BATTERY_LEVEL" ]
  }, {
    "name" : "BATTERY_LEVEL_BLUETOOTH_OFF",
    "type" : "int",
    "comment" : "\n     * Used as an error value for {@link #getBatteryLevel()} to represent bluetooth is off\n     *\n     * @hide\n     ",
    "links" : [ "#getBatteryLevel()" ]
  }, {
    "name" : "EXTRA_DEVICE",
    "type" : "String",
    "comment" : "\n     * Used as a Parcelable {@link BluetoothDevice} extra field in every intent broadcast by this\n     * class. It contains the {@link BluetoothDevice} that the intent applies to.\n     ",
    "links" : [ "android.bluetooth.BluetoothDevice" ]
  }, {
    "name" : "EXTRA_NAME",
    "type" : "String",
    "comment" : "\n     * Used as a String extra field in {@link #ACTION_NAME_CHANGED} and {@link #ACTION_FOUND}\n     * intents. It contains the friendly Bluetooth name.\n     ",
    "links" : [ "#ACTION_NAME_CHANGED", "#ACTION_FOUND" ]
  }, {
    "name" : "EXTRA_BQR",
    "type" : "String",
    "comment" : "\n     * Used as a Parcelable {@link BluetoothQualityReport} extra field in {@link\n     * #ACTION_REMOTE_ISSUE_OCCURRED} intent. It contains the {@link BluetoothQualityReport}.\n     *\n     * @hide\n     ",
    "links" : [ "android.bluetooth.BluetoothQualityReport", "#ACTION_REMOTE_ISSUE_OCCURRED" ]
  }, {
    "name" : "EXTRA_RSSI",
    "type" : "String",
    "comment" : "\n     * Used as an optional short extra field in {@link #ACTION_FOUND} intents. Contains the RSSI\n     * value of the remote device as reported by the Bluetooth hardware.\n     ",
    "links" : [ "#ACTION_FOUND" ]
  }, {
    "name" : "EXTRA_IS_COORDINATED_SET_MEMBER",
    "type" : "String",
    "comment" : "\n     * Used as a boolean extra field in {@link #ACTION_FOUND} intents. It contains the information\n     * if device is discovered as member of a coordinated set or not. Pairing with device that\n     * belongs to a set would trigger pairing with the rest of set members. See Bluetooth CSIP\n     * specification for more details.\n     ",
    "links" : [ "#ACTION_FOUND" ]
  }, {
    "name" : "EXTRA_CLASS",
    "type" : "String",
    "comment" : "\n     * Used as a Parcelable {@link BluetoothClass} extra field in {@link #ACTION_FOUND} and {@link\n     * #ACTION_CLASS_CHANGED} intents.\n     ",
    "links" : [ "#ACTION_CLASS_CHANGED", "#ACTION_FOUND", "android.bluetooth.BluetoothClass" ]
  }, {
    "name" : "EXTRA_BOND_STATE",
    "type" : "String",
    "comment" : "\n     * Used as an int extra field in {@link #ACTION_BOND_STATE_CHANGED} intents. Contains the bond\n     * state of the remote device.\n     *\n     * <p>Possible values are: {@link #BOND_NONE}, {@link #BOND_BONDING}, {@link #BOND_BONDED}.\n     ",
    "links" : [ "#BOND_BONDING", "#BOND_NONE", "#BOND_BONDED", "#ACTION_BOND_STATE_CHANGED" ]
  }, {
    "name" : "EXTRA_PREVIOUS_BOND_STATE",
    "type" : "String",
    "comment" : "\n     * Used as an int extra field in {@link #ACTION_BOND_STATE_CHANGED} intents. Contains the\n     * previous bond state of the remote device.\n     *\n     * <p>Possible values are: {@link #BOND_NONE}, {@link #BOND_BONDING}, {@link #BOND_BONDED}.\n     ",
    "links" : [ "#BOND_BONDING", "#BOND_NONE", "#BOND_BONDED", "#ACTION_BOND_STATE_CHANGED" ]
  }, {
    "name" : "EXTRA_LOW_LATENCY_BUFFER_SIZE",
    "type" : "String",
    "comment" : "\n     * Used as a boolean extra field to indicate if audio buffer size is low latency or not\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "BOND_NONE",
    "type" : "int",
    "comment" : "\n     * Indicates the remote device is not bonded (paired).\n     *\n     * <p>There is no shared link key with the remote device, so communication (if it is allowed at\n     * all) will be unauthenticated and unencrypted.\n     ",
    "links" : [ ]
  }, {
    "name" : "BOND_BONDING",
    "type" : "int",
    "comment" : " Indicates bonding (pairing) is in progress with the remote device. ",
    "links" : [ ]
  }, {
    "name" : "BOND_BONDED",
    "type" : "int",
    "comment" : "\n     * Indicates the remote device is bonded (paired).\n     *\n     * <p>A shared link keys exists locally for the remote device, so communication can be\n     * authenticated and encrypted.\n     *\n     * <p><i>Being bonded (paired) with a remote device does not necessarily mean the device is\n     * currently connected. It just means that the pending procedure was completed at some earlier\n     * time, and the link key is still stored locally, ready to use on the next connection. </i>\n     ",
    "links" : [ ]
  }, {
    "name" : "EXTRA_UNBOND_REASON",
    "type" : "String",
    "comment" : "\n     * Used as an int extra field in {@link #ACTION_PAIRING_REQUEST} intents for unbond reason.\n     * Possible value are : - {@link #UNBOND_REASON_AUTH_FAILED} - {@link\n     * #UNBOND_REASON_AUTH_REJECTED} - {@link #UNBOND_REASON_AUTH_CANCELED} - {@link\n     * #UNBOND_REASON_REMOTE_DEVICE_DOWN} - {@link #UNBOND_REASON_DISCOVERY_IN_PROGRESS} - {@link\n     * #UNBOND_REASON_AUTH_TIMEOUT} - {@link #UNBOND_REASON_REPEATED_ATTEMPTS} - {@link\n     * #UNBOND_REASON_REMOTE_AUTH_CANCELED} - {@link #UNBOND_REASON_REMOVED}\n     *\n     * <p>Note: Can be added as a hidden extra field for {@link #ACTION_BOND_STATE_CHANGED} when the\n     * {@link #EXTRA_BOND_STATE} is {@link #BOND_NONE}\n     *\n     * @hide\n     ",
    "links" : [ "#UNBOND_REASON_DISCOVERY_IN_PROGRESS", "#UNBOND_REASON_AUTH_TIMEOUT", "#UNBOND_REASON_REMOTE_DEVICE_DOWN", "#UNBOND_REASON_REMOTE_AUTH_CANCELED", "#UNBOND_REASON_AUTH_CANCELED", "#UNBOND_REASON_REMOVED", "#BOND_NONE", "#ACTION_PAIRING_REQUEST", "#ACTION_BOND_STATE_CHANGED", "#UNBOND_REASON_AUTH_FAILED", "#EXTRA_BOND_STATE", "#UNBOND_REASON_AUTH_REJECTED", "#UNBOND_REASON_REPEATED_ATTEMPTS" ]
  }, {
    "name" : "EXTRA_REASON",
    "type" : "String",
    "comment" : "\n     * Use {@link EXTRA_UNBOND_REASON} instead\n     *\n     * @hide\n     ",
    "links" : [ "EXTRA_UNBOND_REASON" ]
  }, {
    "name" : "EXTRA_PAIRING_VARIANT",
    "type" : "String",
    "comment" : "\n     * Used as an int extra field in {@link #ACTION_PAIRING_REQUEST} intents to indicate pairing\n     * method used. Possible values are: {@link #PAIRING_VARIANT_PIN}, {@link\n     * #PAIRING_VARIANT_PASSKEY_CONFIRMATION},\n     ",
    "links" : [ "#PAIRING_VARIANT_PIN", "#PAIRING_VARIANT_PASSKEY_CONFIRMATION", "#ACTION_PAIRING_REQUEST" ]
  }, {
    "name" : "EXTRA_PAIRING_KEY",
    "type" : "String",
    "comment" : "\n     * Used as an int extra field in {@link #ACTION_PAIRING_REQUEST} intents as the value of\n     * passkey. The Bluetooth Passkey is a 6-digit numerical value represented as integer value in\n     * the range 0x00000000 â€“ 0x000F423F (000000 to 999999).\n     ",
    "links" : [ "#ACTION_PAIRING_REQUEST" ]
  }, {
    "name" : "EXTRA_PAIRING_INITIATOR",
    "type" : "String",
    "comment" : "\n     * Used as an int extra field in {@link #ACTION_PAIRING_REQUEST} intents as the location of\n     * initiator. Possible value are: {@link #EXTRA_PAIRING_INITIATOR_FOREGROUND}, {@link\n     * #EXTRA_PAIRING_INITIATOR_BACKGROUND},\n     *\n     * @hide\n     ",
    "links" : [ "#EXTRA_PAIRING_INITIATOR_FOREGROUND", "#EXTRA_PAIRING_INITIATOR_BACKGROUND", "#ACTION_PAIRING_REQUEST" ]
  }, {
    "name" : "EXTRA_PAIRING_INITIATOR_FOREGROUND",
    "type" : "int",
    "comment" : "\n     * Bluetooth pairing initiator, Foreground App\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "EXTRA_PAIRING_INITIATOR_BACKGROUND",
    "type" : "int",
    "comment" : "\n     * Bluetooth pairing initiator, Background\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "DEVICE_TYPE_UNKNOWN",
    "type" : "int",
    "comment" : " Bluetooth device type, Unknown ",
    "links" : [ ]
  }, {
    "name" : "DEVICE_TYPE_CLASSIC",
    "type" : "int",
    "comment" : " Bluetooth device type, Classic - BR/EDR devices ",
    "links" : [ ]
  }, {
    "name" : "DEVICE_TYPE_LE",
    "type" : "int",
    "comment" : " Bluetooth device type, Low Energy - LE-only ",
    "links" : [ ]
  }, {
    "name" : "DEVICE_TYPE_DUAL",
    "type" : "int",
    "comment" : " Bluetooth device type, Dual Mode - BR/EDR/LE ",
    "links" : [ ]
  }, {
    "name" : "ACTION_SDP_RECORD",
    "type" : "String",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "METADATA_MAX_LENGTH",
    "type" : "int",
    "comment" : "\n     * Maximum length of a metadata entry, this is to avoid exploding Bluetooth disk usage\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "METADATA_MANUFACTURER_NAME",
    "type" : "int",
    "comment" : "\n     * Manufacturer name of this Bluetooth device Data type should be {@link String} as {@link Byte}\n     * array.\n     *\n     * @hide\n     ",
    "links" : [ "Byte", "String" ]
  }, {
    "name" : "METADATA_MODEL_NAME",
    "type" : "int",
    "comment" : "\n     * Model name of this Bluetooth device Data type should be {@link String} as {@link Byte} array.\n     *\n     * @hide\n     ",
    "links" : [ "Byte", "String" ]
  }, {
    "name" : "METADATA_SOFTWARE_VERSION",
    "type" : "int",
    "comment" : "\n     * Software version of this Bluetooth device Data type should be {@link String} as {@link Byte}\n     * array.\n     *\n     * @hide\n     ",
    "links" : [ "Byte", "String" ]
  }, {
    "name" : "METADATA_HARDWARE_VERSION",
    "type" : "int",
    "comment" : "\n     * Hardware version of this Bluetooth device Data type should be {@link String} as {@link Byte}\n     * array.\n     *\n     * @hide\n     ",
    "links" : [ "Byte", "String" ]
  }, {
    "name" : "METADATA_COMPANION_APP",
    "type" : "int",
    "comment" : "\n     * Package name of the companion app, if any Data type should be {@link String} as {@link Byte}\n     * array.\n     *\n     * @hide\n     ",
    "links" : [ "Byte", "String" ]
  }, {
    "name" : "METADATA_MAIN_ICON",
    "type" : "int",
    "comment" : "\n     * URI to the main icon shown on the settings UI Data type should be {@link Byte} array.\n     *\n     * @hide\n     ",
    "links" : [ "Byte" ]
  }, {
    "name" : "METADATA_IS_UNTETHERED_HEADSET",
    "type" : "int",
    "comment" : "\n     * Whether this device is an untethered headset with left, right and case Data type should be\n     * {@link String} as {@link Byte} array.\n     *\n     * @hide\n     ",
    "links" : [ "Byte", "String" ]
  }, {
    "name" : "METADATA_UNTETHERED_LEFT_ICON",
    "type" : "int",
    "comment" : "\n     * URI to icon of the left headset Data type should be {@link Byte} array.\n     *\n     * @hide\n     ",
    "links" : [ "Byte" ]
  }, {
    "name" : "METADATA_UNTETHERED_RIGHT_ICON",
    "type" : "int",
    "comment" : "\n     * URI to icon of the right headset Data type should be {@link Byte} array.\n     *\n     * @hide\n     ",
    "links" : [ "Byte" ]
  }, {
    "name" : "METADATA_UNTETHERED_CASE_ICON",
    "type" : "int",
    "comment" : "\n     * URI to icon of the headset charging case Data type should be {@link Byte} array.\n     *\n     * @hide\n     ",
    "links" : [ "Byte" ]
  }, {
    "name" : "METADATA_UNTETHERED_LEFT_BATTERY",
    "type" : "int",
    "comment" : "\n     * Battery level of left headset Data type should be {@link String} 0-100 as {@link Byte} array,\n     * otherwise as invalid.\n     *\n     * @hide\n     ",
    "links" : [ "Byte", "String" ]
  }, {
    "name" : "METADATA_UNTETHERED_RIGHT_BATTERY",
    "type" : "int",
    "comment" : "\n     * Battery level of right headset Data type should be {@link String} 0-100 as {@link Byte}\n     * array, otherwise as invalid.\n     *\n     * @hide\n     ",
    "links" : [ "Byte", "String" ]
  }, {
    "name" : "METADATA_UNTETHERED_CASE_BATTERY",
    "type" : "int",
    "comment" : "\n     * Battery level of the headset charging case Data type should be {@link String} 0-100 as {@link\n     * Byte} array, otherwise as invalid.\n     *\n     * @hide\n     ",
    "links" : [ "Byte", "String" ]
  }, {
    "name" : "METADATA_UNTETHERED_LEFT_CHARGING",
    "type" : "int",
    "comment" : "\n     * Whether the left headset is charging Data type should be {@link String} as {@link Byte}\n     * array.\n     *\n     * @hide\n     ",
    "links" : [ "Byte", "String" ]
  }, {
    "name" : "METADATA_UNTETHERED_RIGHT_CHARGING",
    "type" : "int",
    "comment" : "\n     * Whether the right headset is charging Data type should be {@link String} as {@link Byte}\n     * array.\n     *\n     * @hide\n     ",
    "links" : [ "Byte", "String" ]
  }, {
    "name" : "METADATA_UNTETHERED_CASE_CHARGING",
    "type" : "int",
    "comment" : "\n     * Whether the headset charging case is charging Data type should be {@link String} as {@link\n     * Byte} array.\n     *\n     * @hide\n     ",
    "links" : [ "Byte", "String" ]
  }, {
    "name" : "METADATA_ENHANCED_SETTINGS_UI_URI",
    "type" : "int",
    "comment" : "\n     * URI to the enhanced settings UI slice Data type should be {@link String} as {@link Byte}\n     * array, null means the UI does not exist.\n     *\n     * @hide\n     ",
    "links" : [ "Byte", "String" ]
  }, {
    "name" : "COMPANION_TYPE_PRIMARY",
    "type" : "String",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "COMPANION_TYPE_SECONDARY",
    "type" : "String",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "COMPANION_TYPE_NONE",
    "type" : "String",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "METADATA_DEVICE_TYPE",
    "type" : "int",
    "comment" : "\n     * Type of the Bluetooth device, must be within the list of BluetoothDevice.DEVICE_TYPE_* Data\n     * type should be {@link String} as {@link Byte} array.\n     *\n     * @hide\n     ",
    "links" : [ "Byte", "String" ]
  }, {
    "name" : "METADATA_MAIN_BATTERY",
    "type" : "int",
    "comment" : "\n     * Battery level of the Bluetooth device, use when the Bluetooth device does not support HFP\n     * battery indicator. Data type should be {@link String} as {@link Byte} array.\n     *\n     * @hide\n     ",
    "links" : [ "Byte", "String" ]
  }, {
    "name" : "METADATA_MAIN_CHARGING",
    "type" : "int",
    "comment" : "\n     * Whether the device is charging. Data type should be {@link String} as {@link Byte} array.\n     *\n     * @hide\n     ",
    "links" : [ "Byte", "String" ]
  }, {
    "name" : "METADATA_MAIN_LOW_BATTERY_THRESHOLD",
    "type" : "int",
    "comment" : "\n     * The battery threshold of the Bluetooth device to show low battery icon. Data type should be\n     * {@link String} as {@link Byte} array.\n     *\n     * @hide\n     ",
    "links" : [ "Byte", "String" ]
  }, {
    "name" : "METADATA_UNTETHERED_LEFT_LOW_BATTERY_THRESHOLD",
    "type" : "int",
    "comment" : "\n     * The battery threshold of the left headset to show low battery icon. Data type should be\n     * {@link String} as {@link Byte} array.\n     *\n     * @hide\n     ",
    "links" : [ "Byte", "String" ]
  }, {
    "name" : "METADATA_UNTETHERED_RIGHT_LOW_BATTERY_THRESHOLD",
    "type" : "int",
    "comment" : "\n     * The battery threshold of the right headset to show low battery icon. Data type should be\n     * {@link String} as {@link Byte} array.\n     *\n     * @hide\n     ",
    "links" : [ "Byte", "String" ]
  }, {
    "name" : "METADATA_UNTETHERED_CASE_LOW_BATTERY_THRESHOLD",
    "type" : "int",
    "comment" : "\n     * The battery threshold of the case to show low battery icon. Data type should be {@link\n     * String} as {@link Byte} array.\n     *\n     * @hide\n     ",
    "links" : [ "Byte", "String" ]
  }, {
    "name" : "METADATA_SPATIAL_AUDIO",
    "type" : "int",
    "comment" : "\n     * The metadata of the audio spatial data. Data type should be {@link Byte} array.\n     *\n     * @hide\n     ",
    "links" : [ "Byte" ]
  }, {
    "name" : "METADATA_FAST_PAIR_CUSTOMIZED_FIELDS",
    "type" : "int",
    "comment" : "\n     * The metadata of the Fast Pair for any custmized feature. Data type should be {@link Byte}\n     * array.\n     *\n     * @hide\n     ",
    "links" : [ "Byte" ]
  }, {
    "name" : "METADATA_LE_AUDIO",
    "type" : "int",
    "comment" : "\n     * The metadata of the Fast Pair for LE Audio capable devices. Data type should be {@link Byte}\n     * array.\n     *\n     * @hide\n     ",
    "links" : [ "Byte" ]
  }, {
    "name" : "METADATA_GMCS_CCCD",
    "type" : "int",
    "comment" : "\n     * The UUIDs (16-bit) of registered to CCC characteristics from Media Control services. Data\n     * type should be {@link Byte} array.\n     *\n     * @hide\n     ",
    "links" : [ "Byte" ]
  }, {
    "name" : "METADATA_GTBS_CCCD",
    "type" : "int",
    "comment" : "\n     * The UUIDs (16-bit) of registered to CCC characteristics from Telephony Bearer service. Data\n     * type should be {@link Byte} array.\n     *\n     * @hide\n     ",
    "links" : [ "Byte" ]
  }, {
    "name" : "METADATA_EXCLUSIVE_MANAGER",
    "type" : "int",
    "comment" : "\n     * Specify the exclusive manager app for this BluetoothDevice.\n     *\n     * <p>If there's a manager app specified for this BluetoothDevice, and the app is currently\n     * installed and enabled on the device, that manager app shall be responsible for providing the\n     * BluetoothDevice management functionality (e.g. connect, disconnect, forget, etc.). Android\n     * Settings app or Quick Settings System UI shall not provide any management functionality for\n     * such BluetoothDevice.\n     *\n     * <p>Data type should be a {@link String} representation of the {@link ComponentName} (e.g.\n     * \"com.android.settings/.SettingsActivity\") or the package name (e.g. \"com.android.settings\")\n     * of the exclusive manager, provided as a {@link Byte} array.\n     *\n     * @hide\n     ",
    "links" : [ "Byte", "ComponentName", "String" ]
  }, {
    "name" : "METADATA_MAX_KEY",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "DEVICE_TYPE_DEFAULT",
    "type" : "String",
    "comment" : "\n     * Device type which is used in METADATA_DEVICE_TYPE Indicates this Bluetooth device is a\n     * standard Bluetooth accessory or not listed in METADATA_DEVICE_TYPE_*.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "DEVICE_TYPE_WATCH",
    "type" : "String",
    "comment" : "\n     * Device type which is used in METADATA_DEVICE_TYPE Indicates this Bluetooth device is a watch.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "DEVICE_TYPE_UNTETHERED_HEADSET",
    "type" : "String",
    "comment" : "\n     * Device type which is used in METADATA_DEVICE_TYPE Indicates this Bluetooth device is an\n     * untethered headset.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "DEVICE_TYPE_STYLUS",
    "type" : "String",
    "comment" : "\n     * Device type which is used in METADATA_DEVICE_TYPE Indicates this Bluetooth device is a\n     * stylus.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "DEVICE_TYPE_SPEAKER",
    "type" : "String",
    "comment" : "\n     * Device type which is used in METADATA_DEVICE_TYPE Indicates this Bluetooth device is a\n     * speaker.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "DEVICE_TYPE_HEADSET",
    "type" : "String",
    "comment" : "\n     * Device type which is used in METADATA_DEVICE_TYPE Indicates this Bluetooth device is a\n     * tethered headset.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "DEVICE_TYPE_CARKIT",
    "type" : "String",
    "comment" : "\n     * Device type which is used in METADATA_DEVICE_TYPE Indicates this Bluetooth device is a\n     * Carkit.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "DEVICE_TYPE_HEARING_AID",
    "type" : "String",
    "comment" : "\n     * Device type which is used in METADATA_DEVICE_TYPE Indicates this Bluetooth device is a\n     * HearingAid.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "ACTION_UUID",
    "type" : "String",
    "comment" : "\n     * Broadcast Action: This intent is used to broadcast the {@link UUID} wrapped as a {@link\n     * android.os.ParcelUuid} of the remote device after it has been fetched. This intent is sent\n     * only when the UUIDs of the remote device are requested to be fetched using Service Discovery\n     * Protocol\n     *\n     * <p>Always contains the extra field {@link #EXTRA_DEVICE}\n     *\n     * <p>Always contains the extra field {@link #EXTRA_UUID}\n     ",
    "links" : [ "#EXTRA_DEVICE", "android.os.ParcelUuid", "#EXTRA_UUID", "java.util.UUID" ]
  }, {
    "name" : "ACTION_MAS_INSTANCE",
    "type" : "String",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "ACTION_NAME_FAILED",
    "type" : "String",
    "comment" : " TODO: is this actually useful?",
    "links" : [ ]
  }, {
    "name" : "ACTION_PAIRING_REQUEST",
    "type" : "String",
    "comment" : " Broadcast Action: This intent is used to broadcast PAIRING REQUEST ",
    "links" : [ ]
  }, {
    "name" : "CHANGE_TO_STRING_REDACTED",
    "type" : "long",
    "comment" : "\n     * Starting from {@link android.os.Build.VERSION_CODES#UPSIDE_DOWN_CAKE}, the return value of\n     * {@link BluetoothDevice#toString()} has changed to improve privacy.\n     ",
    "links" : [ "android.os.Build.VERSION_CODES#UPSIDE_DOWN_CAKE", "android.bluetooth.BluetoothDevice#toString()" ]
  }, {
    "name" : "ACTION_PAIRING_CANCEL",
    "type" : "String",
    "comment" : "\n     * Broadcast Action: This intent is used to broadcast PAIRING CANCEL\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "ACTION_CONNECTION_ACCESS_REQUEST",
    "type" : "String",
    "comment" : "\n     * Broadcast Action: This intent is used to broadcast CONNECTION ACCESS REQUEST\n     *\n     * <p>This action will trigger a prompt for the user to accept or deny giving the permission for\n     * this device. Permissions can be specified with {@link #EXTRA_ACCESS_REQUEST_TYPE}.\n     *\n     * <p>The reply will be an {@link #ACTION_CONNECTION_ACCESS_REPLY} sent to the specified {@link\n     * #EXTRA_PACKAGE_NAME} and {@link #EXTRA_CLASS_NAME}.\n     *\n     * <p>This action can be cancelled with {@link #ACTION_CONNECTION_ACCESS_CANCEL}.\n     *\n     * @hide\n     ",
    "links" : [ "#EXTRA_PACKAGE_NAME", "#EXTRA_ACCESS_REQUEST_TYPE", "#ACTION_CONNECTION_ACCESS_REPLY", "#ACTION_CONNECTION_ACCESS_CANCEL", "#EXTRA_CLASS_NAME" ]
  }, {
    "name" : "ACTION_CONNECTION_ACCESS_REPLY",
    "type" : "String",
    "comment" : "\n     * Broadcast Action: This intent is used to broadcast CONNECTION ACCESS REPLY\n     *\n     * <p>This action is the reply from {@link #ACTION_CONNECTION_ACCESS_REQUEST} that is sent to\n     * the specified {@link #EXTRA_PACKAGE_NAME} and {@link #EXTRA_CLASS_NAME}.\n     *\n     * <p>See the extra fields {@link #EXTRA_CONNECTION_ACCESS_RESULT} and {@link\n     * #EXTRA_ALWAYS_ALLOWED} for possible results.\n     *\n     * @hide\n     ",
    "links" : [ "#EXTRA_CONNECTION_ACCESS_RESULT", "#EXTRA_PACKAGE_NAME", "#EXTRA_ALWAYS_ALLOWED", "#ACTION_CONNECTION_ACCESS_REQUEST", "#EXTRA_CLASS_NAME" ]
  }, {
    "name" : "ACTION_CONNECTION_ACCESS_CANCEL",
    "type" : "String",
    "comment" : "\n     * Broadcast Action: This intent is used to broadcast CONNECTION ACCESS CANCEL\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "ACTION_SILENCE_MODE_CHANGED",
    "type" : "String",
    "comment" : "\n     * Intent to broadcast silence mode changed. Always contains the extra field {@link\n     * #EXTRA_DEVICE}\n     *\n     * @hide\n     ",
    "links" : [ "#EXTRA_DEVICE" ]
  }, {
    "name" : "EXTRA_ACCESS_REQUEST_TYPE",
    "type" : "String",
    "comment" : "\n     * Used as an extra field in {@link #ACTION_CONNECTION_ACCESS_REQUEST}.\n     *\n     * <p>Possible values are {@link #REQUEST_TYPE_PROFILE_CONNECTION}, {@link\n     * #REQUEST_TYPE_PHONEBOOK_ACCESS}, {@link #REQUEST_TYPE_MESSAGE_ACCESS} and {@link\n     * #REQUEST_TYPE_SIM_ACCESS}\n     *\n     * @hide\n     ",
    "links" : [ "#REQUEST_TYPE_PHONEBOOK_ACCESS", "#REQUEST_TYPE_MESSAGE_ACCESS", "#ACTION_CONNECTION_ACCESS_REQUEST", "#REQUEST_TYPE_PROFILE_CONNECTION", "#REQUEST_TYPE_SIM_ACCESS" ]
  }, {
    "name" : "REQUEST_TYPE_PROFILE_CONNECTION",
    "type" : "int",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "REQUEST_TYPE_PHONEBOOK_ACCESS",
    "type" : "int",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "REQUEST_TYPE_MESSAGE_ACCESS",
    "type" : "int",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "REQUEST_TYPE_SIM_ACCESS",
    "type" : "int",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "EXTRA_PACKAGE_NAME",
    "type" : "String",
    "comment" : "\n     * Used as an extra field in {@link #ACTION_CONNECTION_ACCESS_REQUEST} intents, Contains package\n     * name to return reply intent to.\n     *\n     * @hide\n     ",
    "links" : [ "#ACTION_CONNECTION_ACCESS_REQUEST" ]
  }, {
    "name" : "EXTRA_CLASS_NAME",
    "type" : "String",
    "comment" : "\n     * Used as an extra field in {@link #ACTION_CONNECTION_ACCESS_REQUEST} intents, Contains class\n     * name to return reply intent to.\n     *\n     * @hide\n     ",
    "links" : [ "#ACTION_CONNECTION_ACCESS_REQUEST" ]
  }, {
    "name" : "EXTRA_CONNECTION_ACCESS_RESULT",
    "type" : "String",
    "comment" : "\n     * Used as an extra field in {@link #ACTION_CONNECTION_ACCESS_REPLY} intent.\n     *\n     * <p>Possible values are {@link #CONNECTION_ACCESS_YES} and {@link #CONNECTION_ACCESS_NO}.\n     *\n     * @hide\n     ",
    "links" : [ "#CONNECTION_ACCESS_YES", "#ACTION_CONNECTION_ACCESS_REPLY", "#CONNECTION_ACCESS_NO" ]
  }, {
    "name" : "CONNECTION_ACCESS_YES",
    "type" : "int",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "CONNECTION_ACCESS_NO",
    "type" : "int",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "EXTRA_ALWAYS_ALLOWED",
    "type" : "String",
    "comment" : "\n     * Used as an extra field in {@link #ACTION_CONNECTION_ACCESS_REPLY} intents, Contains boolean\n     * to indicate if the allowed response is once-for-all so that next request will be granted\n     * without asking user again.\n     *\n     * @hide\n     ",
    "links" : [ "#ACTION_CONNECTION_ACCESS_REPLY" ]
  }, {
    "name" : "BOND_SUCCESS",
    "type" : "int",
    "comment" : "\n     * A bond attempt succeeded\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "UNBOND_REASON_AUTH_FAILED",
    "type" : "int",
    "comment" : "\n     * A bond attempt failed because pins did not match, or remote device did not respond to pin\n     * request in time\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "UNBOND_REASON_AUTH_REJECTED",
    "type" : "int",
    "comment" : "\n     * A bond attempt failed because the other side explicitly rejected bonding\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "UNBOND_REASON_AUTH_CANCELED",
    "type" : "int",
    "comment" : "\n     * A bond attempt failed because we canceled the bonding process\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "UNBOND_REASON_REMOTE_DEVICE_DOWN",
    "type" : "int",
    "comment" : "\n     * A bond attempt failed because we could not contact the remote device\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "UNBOND_REASON_DISCOVERY_IN_PROGRESS",
    "type" : "int",
    "comment" : "\n     * A bond attempt failed because a discovery is in progress\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "UNBOND_REASON_AUTH_TIMEOUT",
    "type" : "int",
    "comment" : "\n     * A bond attempt failed because of authentication timeout\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "UNBOND_REASON_REPEATED_ATTEMPTS",
    "type" : "int",
    "comment" : "\n     * A bond attempt failed because of repeated attempts\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "UNBOND_REASON_REMOTE_AUTH_CANCELED",
    "type" : "int",
    "comment" : "\n     * A bond attempt failed because we received an Authentication Cancel by remote end\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "UNBOND_REASON_REMOVED",
    "type" : "int",
    "comment" : "\n     * An existing bond was explicitly revoked\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "PAIRING_VARIANT_PIN",
    "type" : "int",
    "comment" : " The user will be prompted to enter a pin or an app will enter a pin for user. ",
    "links" : [ ]
  }, {
    "name" : "PAIRING_VARIANT_PASSKEY",
    "type" : "int",
    "comment" : "\n     * The user will be prompted to enter a passkey\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "PAIRING_VARIANT_PASSKEY_CONFIRMATION",
    "type" : "int",
    "comment" : "\n     * The user will be prompted to confirm the passkey displayed on the screen or an app will\n     * confirm the passkey for the user.\n     ",
    "links" : [ ]
  }, {
    "name" : "PAIRING_VARIANT_CONSENT",
    "type" : "int",
    "comment" : "\n     * The user will be prompted to accept or deny the incoming pairing request\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "PAIRING_VARIANT_DISPLAY_PASSKEY",
    "type" : "int",
    "comment" : "\n     * The user will be prompted to enter the passkey displayed on remote device This is used for\n     * Bluetooth 2.1 pairing.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "PAIRING_VARIANT_DISPLAY_PIN",
    "type" : "int",
    "comment" : "\n     * The user will be prompted to enter the PIN displayed on remote device. This is used for\n     * Bluetooth 2.0 pairing.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "PAIRING_VARIANT_OOB_CONSENT",
    "type" : "int",
    "comment" : "\n     * The user will be prompted to accept or deny the OOB pairing request. This is used for\n     * Bluetooth 2.1 secure simple pairing.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "PAIRING_VARIANT_PIN_16_DIGITS",
    "type" : "int",
    "comment" : "\n     * The user will be prompted to enter a 16 digit pin or an app will enter a 16 digit pin for\n     * user.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "EXTRA_UUID",
    "type" : "String",
    "comment" : "\n     * Used as an extra field in {@link #ACTION_UUID} intents, Contains the {@link\n     * android.os.ParcelUuid}s of the remote device which is a parcelable version of {@link UUID}. A\n     * {@code null} EXTRA_UUID indicates a timeout.\n     ",
    "links" : [ "#ACTION_UUID", "android.os.ParcelUuid", "java.util.UUID" ]
  }, {
    "name" : "EXTRA_SDP_RECORD",
    "type" : "String",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "EXTRA_SDP_SEARCH_STATUS",
    "type" : "String",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "ACCESS_UNKNOWN",
    "type" : "int",
    "comment" : "\n     * For {@link #getPhonebookAccessPermission}, {@link #setPhonebookAccessPermission}, {@link\n     * #getMessageAccessPermission} and {@link #setMessageAccessPermission}.\n     *\n     * @hide\n     ",
    "links" : [ "#getPhonebookAccessPermission", "#getMessageAccessPermission", "#setPhonebookAccessPermission", "#setMessageAccessPermission" ]
  }, {
    "name" : "ACCESS_ALLOWED",
    "type" : "int",
    "comment" : "\n     * For {@link #getPhonebookAccessPermission}, {@link #setPhonebookAccessPermission}, {@link\n     * #getMessageAccessPermission} and {@link #setMessageAccessPermission}.\n     *\n     * @hide\n     ",
    "links" : [ "#getPhonebookAccessPermission", "#getMessageAccessPermission", "#setPhonebookAccessPermission", "#setMessageAccessPermission" ]
  }, {
    "name" : "ACCESS_REJECTED",
    "type" : "int",
    "comment" : "\n     * For {@link #getPhonebookAccessPermission}, {@link #setPhonebookAccessPermission}, {@link\n     * #getMessageAccessPermission} and {@link #setMessageAccessPermission}.\n     *\n     * @hide\n     ",
    "links" : [ "#getPhonebookAccessPermission", "#getMessageAccessPermission", "#setPhonebookAccessPermission", "#setMessageAccessPermission" ]
  }, {
    "name" : "TRANSPORT_AUTO",
    "type" : "int",
    "comment" : " No preference of physical transport for GATT connections to remote dual-mode devices ",
    "links" : [ ]
  }, {
    "name" : "TRANSPORT_BREDR",
    "type" : "int",
    "comment" : " Constant representing the BR/EDR transport. ",
    "links" : [ ]
  }, {
    "name" : "TRANSPORT_LE",
    "type" : "int",
    "comment" : " Constant representing the Bluetooth Low Energy (BLE) Transport. ",
    "links" : [ ]
  }, {
    "name" : "PHY_LE_1M",
    "type" : "int",
    "comment" : "\n     * Bluetooth LE 1M PHY. Used to refer to LE 1M Physical Channel for advertising, scanning or\n     * connection.\n     ",
    "links" : [ ]
  }, {
    "name" : "PHY_LE_2M",
    "type" : "int",
    "comment" : "\n     * Bluetooth LE 2M PHY. Used to refer to LE 2M Physical Channel for advertising, scanning or\n     * connection.\n     ",
    "links" : [ ]
  }, {
    "name" : "PHY_LE_CODED",
    "type" : "int",
    "comment" : "\n     * Bluetooth LE Coded PHY. Used to refer to LE Coded Physical Channel for advertising, scanning\n     * or connection.\n     ",
    "links" : [ ]
  }, {
    "name" : "PHY_LE_1M_MASK",
    "type" : "int",
    "comment" : "\n     * Bluetooth LE 1M PHY mask. Used to specify LE 1M Physical Channel as one of many available\n     * options in a bitmask.\n     ",
    "links" : [ ]
  }, {
    "name" : "PHY_LE_2M_MASK",
    "type" : "int",
    "comment" : "\n     * Bluetooth LE 2M PHY mask. Used to specify LE 2M Physical Channel as one of many available\n     * options in a bitmask.\n     ",
    "links" : [ ]
  }, {
    "name" : "PHY_LE_CODED_MASK",
    "type" : "int",
    "comment" : "\n     * Bluetooth LE Coded PHY mask. Used to specify LE Coded Physical Channel as one of many\n     * available options in a bitmask.\n     ",
    "links" : [ ]
  }, {
    "name" : "PHY_OPTION_NO_PREFERRED",
    "type" : "int",
    "comment" : " No preferred coding when transmitting on the LE Coded PHY. ",
    "links" : [ ]
  }, {
    "name" : "PHY_OPTION_S2",
    "type" : "int",
    "comment" : " Prefer the S=2 coding to be used when transmitting on the LE Coded PHY. ",
    "links" : [ ]
  }, {
    "name" : "PHY_OPTION_S8",
    "type" : "int",
    "comment" : " Prefer the S=8 coding to be used when transmitting on the LE Coded PHY. ",
    "links" : [ ]
  }, {
    "name" : "EXTRA_MAS_INSTANCE",
    "type" : "String",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "EXTRA_TRANSPORT",
    "type" : "String",
    "comment" : "\n     * Used as an int extra field in {@link #ACTION_ACL_CONNECTED} and {@link\n     * #ACTION_ACL_DISCONNECTED} intents to indicate which transport is connected. Possible values\n     * are: {@link #TRANSPORT_BREDR} and {@link #TRANSPORT_LE}.\n     ",
    "links" : [ "#TRANSPORT_LE", "#ACTION_ACL_CONNECTED", "#ACTION_ACL_DISCONNECTED", "#TRANSPORT_BREDR" ]
  }, {
    "name" : "ADDRESS_TYPE_PUBLIC",
    "type" : "int",
    "comment" : " Hardware MAC Address of the device ",
    "links" : [ ]
  }, {
    "name" : "ADDRESS_TYPE_RANDOM",
    "type" : "int",
    "comment" : " Address is either resolvable, non-resolvable or static. ",
    "links" : [ ]
  }, {
    "name" : "ADDRESS_TYPE_UNKNOWN",
    "type" : "int",
    "comment" : " Address type is unknown or unavailable ",
    "links" : [ ]
  }, {
    "name" : "ADDRESS_TYPE_ANONYMOUS",
    "type" : "int",
    "comment" : " Address type used to indicate an anonymous advertisement. ",
    "links" : [ ]
  }, {
    "name" : "ACTIVE_AUDIO_DEVICE_POLICY_DEFAULT",
    "type" : "int",
    "comment" : "\n     * Indicates default active audio device policy is applied to this device\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "ACTIVE_AUDIO_DEVICE_POLICY_ALL_PROFILES_ACTIVE_UPON_CONNECTION",
    "type" : "int",
    "comment" : "\n     * Indicates all profiles active audio device policy is applied to this device\n     *\n     * <p>all profiles are active upon device connection\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "ACTIVE_AUDIO_DEVICE_POLICY_ALL_PROFILES_INACTIVE_UPON_CONNECTION",
    "type" : "int",
    "comment" : "\n     * Indicates all profiles inactive audio device policy is applied to this device\n     *\n     * <p>all profiles are inactive upon device connection\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "NULL_MAC_ADDRESS",
    "type" : "String",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mAddress",
    "type" : "String",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mAddressType",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "sIsLogRedactionFlagSynced",
    "type" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "sIsLogRedactionEnabled",
    "type" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mAttributionSource",
    "type" : "AttributionSource",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "CREATOR",
    "type" : "Creator<BluetoothDevice>",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "sBluetoothBondQuery",
    "type" : "IpcDataCache.QueryHandler<Pair<IBluetooth, Pair<AttributionSource, BluetoothDevice>>, Integer>",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "GET_BOND_STATE_API",
    "type" : "String",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "sBluetoothBondCache",
    "type" : "BluetoothCache<Pair<IBluetooth, Pair<AttributionSource, BluetoothDevice>>, Integer>",
    "comment" : "",
    "links" : [ ]
  } ],
  "methods" : [ {
    "name" : " static IBluetooth getService()",
    "returnType" : "IBluetooth",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public void setAttributionSource(@NonNull AttributionSource attributionSource)",
    "returnType" : "void",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "public void prepareToEnterProcess(@NonNull AttributionSource attributionSource)",
    "returnType" : "void",
    "comment" : "\n     * Method should never be used anywhere. Only exception is from {@link Intent} Used to set the\n     * device current attribution source\n     *\n     * @param attributionSource The associated {@link AttributionSource} for this device in this\n     *     process\n     * @hide\n     ",
    "links" : [ "android.content.AttributionSource", "Intent" ]
  }, {
    "name" : "public boolean equals(@Nullable Object o)",
    "returnType" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public int hashCode()",
    "returnType" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public String toString()",
    "returnType" : "String",
    "comment" : "\n     * Returns a string representation of this BluetoothDevice.\n     *\n     * <p>For apps targeting {@link android.os.Build.VERSION_CODES#UPSIDE_DOWN_CAKE} (API level 34)\n     * or higher, this returns the MAC address of the device redacted by replacing the hexadecimal\n     * digits of leftmost 4 bytes (in big endian order) with \"XX\", e.g., \"XX:XX:XX:XX:12:34\". For\n     * apps targeting earlier versions, the MAC address is returned without redaction.\n     *\n     * <p>Warning: The return value of {@link #toString()} may change in the future. It is intended\n     * to be used in logging statements. Thus apps should never rely on the return value of {@link\n     * #toString()} in their logic. Always use other appropriate APIs instead (e.g., use {@link\n     * #getAddress()} to get the MAC address).\n     *\n     * @return string representation of this BluetoothDevice\n     ",
    "links" : [ "android.os.Build.VERSION_CODES#UPSIDE_DOWN_CAKE", "#getAddress()", "#toString()" ]
  }, {
    "name" : "private static boolean shouldLogBeRedacted()",
    "returnType" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public String toStringForLogging()",
    "returnType" : "String",
    "comment" : "\n     * Returns a string representation of this BluetoothDevice for logging. So far, this function\n     * only returns hardware address. If more information is needed, add it here\n     *\n     * @return string representation of this BluetoothDevice used for logging\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public int describeContents()",
    "returnType" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public void writeToParcel(Parcel out, int flags)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public String getAddress()",
    "returnType" : "String",
    "comment" : "\n     * Returns the hardware address of this BluetoothDevice.\n     *\n     * <p>For example, \"00:11:22:AA:BB:CC\".\n     *\n     * @return Bluetooth hardware address as string\n     ",
    "links" : [ ]
  }, {
    "name" : "public int getAddressType()",
    "returnType" : "int",
    "comment" : "\n     * Returns the address type of this BluetoothDevice, one of {@link ADDRESS_TYPE_PUBLIC}, {@link\n     * ADDRESS_TYPE_RANDOM}, {@link ADDRESS_TYPE_ANONYMOUS}, or {@link ADDRESS_TYPE_UNKNOWN}.\n     *\n     * @return Bluetooth address type\n     ",
    "links" : [ "ADDRESS_TYPE_UNKNOWN", "ADDRESS_TYPE_PUBLIC", "ADDRESS_TYPE_RANDOM", "ADDRESS_TYPE_ANONYMOUS" ]
  }, {
    "name" : "public String getAnonymizedAddress()",
    "returnType" : "String",
    "comment" : "\n     * Returns the anonymized hardware address of this BluetoothDevice. The first three octets will\n     * be suppressed for anonymization.\n     *\n     * <p>For example, \"XX:XX:XX:AA:BB:CC\".\n     *\n     * @return Anonymized bluetooth hardware address as string\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public String getAddressForLogging()",
    "returnType" : "String",
    "comment" : "\n     * Returns string representation of the hardware address of this BluetoothDevice for logging\n     * purpose. Depending on the build type and device config, this function returns either full\n     * address string (returned by getAddress), or a redacted string with the leftmost 4 bytes shown\n     * as 'xx',\n     *\n     * <p>For example, \"xx:xx:xx:xx:aa:bb\". This function is intended to avoid leaking full address\n     * in logs.\n     *\n     * @return string representation of the hardware address for logging\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public String getIdentityAddress()",
    "returnType" : "String",
    "comment" : "\n     * Returns the identity address of this BluetoothDevice.\n     *\n     * <p>For example, \"00:11:22:AA:BB:CC\".\n     *\n     * @return Bluetooth identity address as a string\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public String getName()",
    "returnType" : "String",
    "comment" : "\n     * Get the friendly Bluetooth name of the remote device.\n     *\n     * <p>The local adapter will automatically retrieve remote names when performing a device scan,\n     * and will cache them. This method just returns the name for this device from the cache.\n     *\n     * @return the Bluetooth name, or null if there was a problem.\n     ",
    "links" : [ ]
  }, {
    "name" : "public int getType()",
    "returnType" : "int",
    "comment" : "\n     * Get the Bluetooth device type of the remote device.\n     *\n     * @return the device type {@link #DEVICE_TYPE_CLASSIC}, {@link #DEVICE_TYPE_LE} {@link\n     *     #DEVICE_TYPE_DUAL}. {@link #DEVICE_TYPE_UNKNOWN} if it's not available\n     ",
    "links" : [ "#DEVICE_TYPE_LE", "#DEVICE_TYPE_UNKNOWN", "#DEVICE_TYPE_CLASSIC", "#DEVICE_TYPE_DUAL" ]
  }, {
    "name" : "public String getAlias()",
    "returnType" : "String",
    "comment" : "\n     * Get the locally modifiable name (alias) of the remote Bluetooth device.\n     *\n     * @return the Bluetooth alias, the friendly device name if no alias, or null if there was a\n     *     problem\n     ",
    "links" : [ ]
  }, {
    "name" : "public int setAlias(@Nullable String alias)",
    "returnType" : "int",
    "comment" : "\n     * Sets the locally modifiable name (alias) of the remote Bluetooth device. This method\n     * overwrites the previously stored alias. The new alias is saved in local storage so that the\n     * change is preserved over power cycles.\n     *\n     * <p>This method requires the calling app to be associated with Companion Device Manager (see\n     * {@link android.companion.CompanionDeviceManager#associate(AssociationRequest,\n     * android.companion.CompanionDeviceManager.Callback, Handler)}) and have the {@link\n     * android.Manifest.permission#BLUETOOTH_CONNECT} permission. Alternatively, if the caller has\n     * the {@link android.Manifest.permission#BLUETOOTH_PRIVILEGED} permission, they can bypass the\n     * Companion Device Manager association requirement as well as other permission requirements.\n     *\n     * @param alias is the new locally modifiable name for the remote Bluetooth device which must be\n     *     the empty string. If null, we clear the alias.\n     * @return whether the alias was successfully changed\n     * @throws IllegalArgumentException if the alias is the empty string\n     ",
    "links" : [ "android.companion.CompanionDeviceManager#associate(AssociationRequest", "android.Manifest.permission#BLUETOOTH_CONNECT", "android.Manifest.permission#BLUETOOTH_PRIVILEGED" ]
  }, {
    "name" : "public int getBatteryLevel()",
    "returnType" : "int",
    "comment" : "\n     * Get the most recent identified battery level of this Bluetooth device\n     *\n     * @return Battery level in percents from 0 to 100, {@link #BATTERY_LEVEL_BLUETOOTH_OFF} if\n     *     Bluetooth is disabled or {@link #BATTERY_LEVEL_UNKNOWN} if device is disconnected, or\n     *     does not have any battery reporting service, or return value is invalid\n     * @hide\n     ",
    "links" : [ "#BATTERY_LEVEL_BLUETOOTH_OFF", "#BATTERY_LEVEL_UNKNOWN" ]
  }, {
    "name" : "public boolean createBond()",
    "returnType" : "boolean",
    "comment" : "\n     * Start the bonding (pairing) process with the remote device.\n     *\n     * <p>This is an asynchronous call, it will return immediately. Register for {@link\n     * #ACTION_BOND_STATE_CHANGED} intents to be notified when the bonding process completes, and\n     * its result.\n     *\n     * <p>Android system services will handle the necessary user interactions to confirm and\n     * complete the bonding process.\n     *\n     * @return false on immediate error, true if bonding will begin\n     ",
    "links" : [ "#ACTION_BOND_STATE_CHANGED" ]
  }, {
    "name" : "public boolean createBond(int transport)",
    "returnType" : "boolean",
    "comment" : "\n     * Start the bonding (pairing) process with the remote device using the specified transport.\n     *\n     * <p>This is an asynchronous call, it will return immediately. Register for {@link\n     * #ACTION_BOND_STATE_CHANGED} intents to be notified when the bonding process completes, and\n     * its result.\n     *\n     * <p>Android system services will handle the necessary user interactions to confirm and\n     * complete the bonding process.\n     *\n     * @param transport The transport to use for the pairing procedure.\n     * @return false on immediate error, true if bonding will begin\n     * @throws IllegalArgumentException if an invalid transport was specified\n     * @hide\n     ",
    "links" : [ "#ACTION_BOND_STATE_CHANGED" ]
  }, {
    "name" : "public boolean createBondOutOfBand(int transport, @Nullable OobData remoteP192Data, @Nullable OobData remoteP256Data)",
    "returnType" : "boolean",
    "comment" : "\n     * Start the bonding (pairing) process with the remote device using the Out Of Band mechanism.\n     *\n     * <p>This is an asynchronous call, it will return immediately. Register for {@link\n     * #ACTION_BOND_STATE_CHANGED} intents to be notified when the bonding process completes, and\n     * its result.\n     *\n     * <p>Android system services will handle the necessary user interactions to confirm and\n     * complete the bonding process.\n     *\n     * <p>There are two possible versions of OOB Data. This data can come in as P192 or P256. This\n     * is a reference to the cryptography used to generate the key. The caller may pass one or both.\n     * If both types of data are passed, then the P256 data will be preferred, and thus used.\n     *\n     * @param transport - Transport to use\n     * @param remoteP192Data - Out Of Band data (P192) or null\n     * @param remoteP256Data - Out Of Band data (P256) or null\n     * @return false on immediate error, true if bonding will begin\n     * @hide\n     ",
    "links" : [ "#ACTION_BOND_STATE_CHANGED" ]
  }, {
    "name" : "private boolean createBondInternal(int transport, @Nullable OobData remoteP192Data, @Nullable OobData remoteP256Data)",
    "returnType" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public boolean isBondingInitiatedLocally()",
    "returnType" : "boolean",
    "comment" : "\n     * Gets whether bonding was initiated locally\n     *\n     * @return true if bonding is initiated locally, false otherwise\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean cancelBondProcess()",
    "returnType" : "boolean",
    "comment" : "\n     * Cancel an in-progress bonding request started with {@link #createBond}.\n     *\n     * @return true on success, false on error\n     * @hide\n     ",
    "links" : [ "#createBond" ]
  }, {
    "name" : "public boolean removeBond()",
    "returnType" : "boolean",
    "comment" : "\n     * Remove bond (pairing) with the remote device.\n     *\n     * <p>Delete the link key associated with the remote device, and immediately terminate\n     * connections to that device that require authentication and encryption.\n     *\n     * @return true on success, false on error\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "private static void invalidateCache(@NonNull String api)",
    "returnType" : "void",
    "comment" : "\n     * Invalidate a bluetooth cache. This method is just a short-hand wrapper that enforces the\n     * bluetooth module.\n     ",
    "links" : [ ]
  }, {
    "name" : "public void disableBluetoothGetBondStateCache()",
    "returnType" : "void",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "public static void invalidateBluetoothGetBondStateCache()",
    "returnType" : "void",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "public int getBondState()",
    "returnType" : "int",
    "comment" : "\n     * Get the bond state of the remote device.\n     *\n     * <p>Possible values for the bond state are: {@link #BOND_NONE}, {@link #BOND_BONDING}, {@link\n     * #BOND_BONDED}.\n     *\n     * @return the bond state\n     ",
    "links" : [ "#BOND_BONDING", "#BOND_NONE", "#BOND_BONDED" ]
  }, {
    "name" : "public boolean canBondWithoutDialog()",
    "returnType" : "boolean",
    "comment" : "\n     * Checks whether this bluetooth device is associated with CDM and meets the criteria to skip\n     * the bluetooth pairing dialog because it has been already consented by the CDM prompt.\n     *\n     * @return true if we can bond without the dialog, false otherwise\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public String getPackageNameOfBondingApplication()",
    "returnType" : "String",
    "comment" : "\n     * Gets the package name of the application that initiate bonding with this device\n     *\n     * @return package name of the application, or null of no application initiate bonding with this\n     *     device\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public int connect()",
    "returnType" : "int",
    "comment" : "\n     * Connects all user enabled and supported bluetooth profiles between the local and remote\n     * device. If no profiles are user enabled (e.g. first connection), we connect all supported\n     * profiles. If the device is not already connected, this will page the device before initiating\n     * profile connections. Connection is asynchronous and you should listen to each profile's\n     * broadcast intent ACTION_CONNECTION_STATE_CHANGED to verify whether connection was successful.\n     * For example, to verify a2dp is connected, you would listen for {@link\n     * BluetoothA2dp#ACTION_CONNECTION_STATE_CHANGED}\n     *\n     * @return whether the messages were successfully sent to try to connect all profiles\n     * @throws IllegalArgumentException if the device address is invalid\n     * @hide\n     ",
    "links" : [ "android.bluetooth.BluetoothA2dp#ACTION_CONNECTION_STATE_CHANGED" ]
  }, {
    "name" : "public int disconnect()",
    "returnType" : "int",
    "comment" : "\n     * Disconnects all connected bluetooth profiles between the local and remote device.\n     * Disconnection is asynchronous, so you should listen to each profile's broadcast intent\n     * ACTION_CONNECTION_STATE_CHANGED to verify whether disconnection was successful. For example,\n     * to verify a2dp is disconnected, you would listen for {@link\n     * BluetoothA2dp#ACTION_CONNECTION_STATE_CHANGED}. Once all profiles have disconnected, the ACL\n     * link should come down and {@link #ACTION_ACL_DISCONNECTED} should be broadcast.\n     *\n     * <p>In the rare event that one or more profiles fail to disconnect, call this method again to\n     * send another request to disconnect each connected profile.\n     *\n     * @return whether the messages were successfully sent to try to disconnect all profiles\n     * @throws IllegalArgumentException if the device address is invalid\n     * @hide\n     ",
    "links" : [ "android.bluetooth.BluetoothA2dp#ACTION_CONNECTION_STATE_CHANGED", "#ACTION_ACL_DISCONNECTED" ]
  }, {
    "name" : "public boolean isConnected()",
    "returnType" : "boolean",
    "comment" : "\n     * Returns whether there is an open connection to this device.\n     *\n     * @return True if there is at least one open connection to this device.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public int getConnectionHandle(@Transport int transport)",
    "returnType" : "int",
    "comment" : "\n     * Returns the ACL connection handle associated with an open connection to this device on the\n     * given transport.\n     *\n     * <p>This handle is a unique identifier for the connection while it remains active. Refer to\n     * the Bluetooth Core Specification Version 5.4 Vol 4 Part E Section 5.3.1 Controller Handles\n     * for details.\n     *\n     * @return the ACL handle, or {@link BluetoothDevice#ERROR} if no connection currently exists on\n     *     the given transport.\n     * @hide\n     ",
    "links" : [ "android.bluetooth.BluetoothDevice#ERROR" ]
  }, {
    "name" : "public boolean isEncrypted()",
    "returnType" : "boolean",
    "comment" : "\n     * Returns whether there is an open connection to this device that has been encrypted.\n     *\n     * @return True if there is at least one encrypted connection to this device.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public BluetoothClass getBluetoothClass()",
    "returnType" : "BluetoothClass",
    "comment" : "\n     * Get the Bluetooth class of the remote device.\n     *\n     * @return Bluetooth class object, or null on error\n     ",
    "links" : [ ]
  }, {
    "name" : "public ParcelUuid[] getUuids()",
    "returnType" : "ParcelUuid[]",
    "comment" : "\n     * Returns the supported features (UUIDs) of the remote device.\n     *\n     * <p>This method does not start a service discovery procedure to retrieve the UUIDs from the\n     * remote device. Instead, the local cached copy of the service UUIDs are returned.\n     *\n     * <p>Use {@link #fetchUuidsWithSdp} if fresh UUIDs are desired.\n     *\n     * @return the supported features (UUIDs) of the remote device, or null on error\n     ",
    "links" : [ "#fetchUuidsWithSdp" ]
  }, {
    "name" : "public boolean fetchUuidsWithSdp()",
    "returnType" : "boolean",
    "comment" : "\n     * Perform a service discovery on the remote device to get the UUIDs supported.\n     *\n     * <p>This API is asynchronous and {@link #ACTION_UUID} intent is sent, with the UUIDs supported\n     * by the remote end. If there is an error in getting the SDP records or if the process takes a\n     * long time, or the device is bonding and we have its UUIDs cached, {@link #ACTION_UUID} intent\n     * is sent with the UUIDs that is currently present in the cache. Clients should use the {@link\n     * #getUuids} to get UUIDs if service discovery is not to be performed. If there is an ongoing\n     * bonding process, service discovery or device inquiry, the request will be queued.\n     *\n     * @return False if the check fails, True if the process of initiating an ACL connection to the\n     *     remote device was started or cached UUIDs will be broadcast.\n     ",
    "links" : [ "#getUuids", "#ACTION_UUID" ]
  }, {
    "name" : "public boolean fetchUuidsWithSdp(@Transport int transport)",
    "returnType" : "boolean",
    "comment" : "\n     * Perform a service discovery on the remote device to get the UUIDs supported with the specific\n     * transport.\n     *\n     * <p>This API is asynchronous and {@link #ACTION_UUID} intent is sent, with the UUIDs supported\n     * by the remote end. If there is an error in getting the SDP or GATT records or if the process\n     * takes a long time, or the device is bonding and we have its UUIDs cached, {@link\n     * #ACTION_UUID} intent is sent with the UUIDs that is currently present in the cache. Clients\n     * should use the {@link #getUuids} to get UUIDs if service discovery is not to be performed. If\n     * there is an ongoing bonding process, service discovery or device inquiry, the request will be\n     * queued.\n     *\n     * @param transport - provide type of transport (e.g. LE or Classic).\n     * @return False if the check fails, True if the process of initiating an ACL connection to the\n     *     remote device was started or cached UUIDs will be broadcast with the specific transport.\n     * @hide\n     ",
    "links" : [ "#getUuids", "#ACTION_UUID" ]
  }, {
    "name" : "public boolean sdpSearch(ParcelUuid uuid)",
    "returnType" : "boolean",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "public boolean setPin(byte[] pin)",
    "returnType" : "boolean",
    "comment" : "\n     * Set the pin during pairing when the pairing method is {@link #PAIRING_VARIANT_PIN}\n     *\n     * @return true pin has been set false for error\n     ",
    "links" : [ "#PAIRING_VARIANT_PIN" ]
  }, {
    "name" : "public boolean setPin(@NonNull String pin)",
    "returnType" : "boolean",
    "comment" : "\n     * Set the pin during pairing when the pairing method is {@link #PAIRING_VARIANT_PIN}\n     *\n     * @return true pin has been set false for error\n     * @hide\n     ",
    "links" : [ "#PAIRING_VARIANT_PIN" ]
  }, {
    "name" : "public boolean setPairingConfirmation(boolean confirm)",
    "returnType" : "boolean",
    "comment" : "\n     * Confirm passkey for {@link #PAIRING_VARIANT_PASSKEY_CONFIRMATION} pairing.\n     *\n     * @return true confirmation has been sent out false for error\n     ",
    "links" : [ "#PAIRING_VARIANT_PASSKEY_CONFIRMATION" ]
  }, {
    "name" : " boolean isBluetoothEnabled()",
    "returnType" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public int getPhonebookAccessPermission()",
    "returnType" : "int",
    "comment" : "\n     * Gets whether the phonebook access is allowed for this bluetooth device\n     *\n     * @return Whether the phonebook access is allowed to this device. Can be {@link\n     *     #ACCESS_UNKNOWN}, {@link #ACCESS_ALLOWED} or {@link #ACCESS_REJECTED}.\n     * @hide\n     ",
    "links" : [ "#ACCESS_ALLOWED", "#ACCESS_REJECTED", "#ACCESS_UNKNOWN" ]
  }, {
    "name" : "public boolean setSilenceMode(boolean silence)",
    "returnType" : "boolean",
    "comment" : "\n     * Sets whether the {@link BluetoothDevice} enters silence mode. Audio will not be routed to the\n     * {@link BluetoothDevice} if set to {@code true}.\n     *\n     * <p>When the {@link BluetoothDevice} enters silence mode, and the {@link BluetoothDevice} is\n     * an active device (for A2DP or HFP), the active device for that profile will be set to null.\n     * If the {@link BluetoothDevice} exits silence mode while the A2DP or HFP active device is\n     * null, the {@link BluetoothDevice} will be set as the active device for that profile. If the\n     * {@link BluetoothDevice} is disconnected, it exits silence mode. If the {@link\n     * BluetoothDevice} is set as the active device for A2DP or HFP, while silence mode is enabled,\n     * then the device will exit silence mode. If the {@link BluetoothDevice} is in silence mode,\n     * AVRCP position change event and HFP AG indicators will be disabled. If the {@link\n     * BluetoothDevice} is not connected with A2DP or HFP, it cannot enter silence mode.\n     *\n     * @param silence true to enter silence mode, false to exit\n     * @return true on success, false on error.\n     * @throws IllegalStateException if Bluetooth is not turned ON.\n     * @hide\n     ",
    "links" : [ "android.bluetooth.BluetoothDevice" ]
  }, {
    "name" : "public boolean isInSilenceMode()",
    "returnType" : "boolean",
    "comment" : "\n     * Check whether the {@link BluetoothDevice} is in silence mode\n     *\n     * @return true on device in silence mode, otherwise false.\n     * @throws IllegalStateException if Bluetooth is not turned ON.\n     * @hide\n     ",
    "links" : [ "android.bluetooth.BluetoothDevice" ]
  }, {
    "name" : "public boolean setPhonebookAccessPermission(@AccessPermission int value)",
    "returnType" : "boolean",
    "comment" : "\n     * Sets whether the phonebook access is allowed to this device.\n     *\n     * @param value Can be {@link #ACCESS_UNKNOWN}, {@link #ACCESS_ALLOWED} or {@link\n     *     #ACCESS_REJECTED}.\n     * @return Whether the value has been successfully set.\n     * @hide\n     ",
    "links" : [ "#ACCESS_ALLOWED", "#ACCESS_REJECTED", "#ACCESS_UNKNOWN" ]
  }, {
    "name" : "public int getMessageAccessPermission()",
    "returnType" : "int",
    "comment" : "\n     * Gets whether message access is allowed to this bluetooth device\n     *\n     * @return Whether the message access is allowed to this device.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean setMessageAccessPermission(@AccessPermission int value)",
    "returnType" : "boolean",
    "comment" : "\n     * Sets whether the message access is allowed to this device.\n     *\n     * @param value Can be {@link #ACCESS_UNKNOWN} if the device is unbonded, {@link\n     *     #ACCESS_ALLOWED} if the permission is being granted, or {@link #ACCESS_REJECTED} if the\n     *     permission is not being granted.\n     * @return Whether the value has been successfully set.\n     * @hide\n     ",
    "links" : [ "#ACCESS_ALLOWED", "#ACCESS_REJECTED", "#ACCESS_UNKNOWN" ]
  }, {
    "name" : "public int getSimAccessPermission()",
    "returnType" : "int",
    "comment" : "\n     * Gets whether sim access is allowed for this bluetooth device\n     *\n     * @return Whether the Sim access is allowed to this device.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean setSimAccessPermission(int value)",
    "returnType" : "boolean",
    "comment" : "\n     * Sets whether the Sim access is allowed to this device.\n     *\n     * @param value Can be {@link #ACCESS_UNKNOWN} if the device is unbonded, {@link\n     *     #ACCESS_ALLOWED} if the permission is being granted, or {@link #ACCESS_REJECTED} if the\n     *     permission is not being granted.\n     * @return Whether the value has been successfully set.\n     * @hide\n     ",
    "links" : [ "#ACCESS_ALLOWED", "#ACCESS_REJECTED", "#ACCESS_UNKNOWN" ]
  }, {
    "name" : "public BluetoothSocket createRfcommSocket(int channel) throws IOException",
    "returnType" : "BluetoothSocket",
    "comment" : "\n     * Create an RFCOMM {@link BluetoothSocket} ready to start a secure outgoing connection to this\n     * remote device on given channel.\n     *\n     * <p>The remote device will be authenticated and communication on this socket will be\n     * encrypted.\n     *\n     * <p>Use this socket only if an authenticated socket link is possible. Authentication refers to\n     * the authentication of the link key to prevent person-in-the-middle type of attacks. For\n     * example, for Bluetooth 2.1 devices, if any of the devices does not have an input and output\n     * capability or just has the ability to display a numeric key, a secure socket connection is\n     * not possible. In such a case, use {@link createInsecureRfcommSocket}. For more details, refer\n     * to the Security Model section 5.2 (vol 3) of Bluetooth Core Specification version 2.1 + EDR.\n     *\n     * <p>Use {@link BluetoothSocket#connect} to initiate the outgoing connection.\n     *\n     * <p>Valid RFCOMM channels are in range 1 to 30.\n     *\n     * @param channel RFCOMM channel to connect to\n     * @return a RFCOMM BluetoothServerSocket ready for an outgoing connection\n     * @throws IOException on error, for example Bluetooth not available, or insufficient\n     *     permissions\n     * @hide\n     ",
    "links" : [ "android.bluetooth.BluetoothSocket", "createInsecureRfcommSocket", "android.bluetooth.BluetoothSocket#connect" ]
  }, {
    "name" : "public BluetoothSocket createL2capSocket(int channel) throws IOException",
    "returnType" : "BluetoothSocket",
    "comment" : "\n     * Create an L2cap {@link BluetoothSocket} ready to start a secure outgoing connection to this\n     * remote device on given channel.\n     *\n     * <p>The remote device will be authenticated and communication on this socket will be\n     * encrypted.\n     *\n     * <p>Use this socket only if an authenticated socket link is possible. Authentication refers to\n     * the authentication of the link key to prevent person-in-the-middle type of attacks. For\n     * example, for Bluetooth 2.1 devices, if any of the devices does not have an input and output\n     * capability or just has the ability to display a numeric key, a secure socket connection is\n     * not possible. In such a case, use {@link createInsecureRfcommSocket}. For more details, refer\n     * to the Security Model section 5.2 (vol 3) of Bluetooth Core Specification version 2.1 + EDR.\n     *\n     * <p>Use {@link BluetoothSocket#connect} to initiate the outgoing connection.\n     *\n     * <p>Valid L2CAP PSM channels are in range 1 to 2^16.\n     *\n     * @param channel L2cap PSM/channel to connect to\n     * @return a RFCOMM BluetoothServerSocket ready for an outgoing connection\n     * @throws IOException on error, for example Bluetooth not available, or insufficient\n     *     permissions\n     * @hide\n     ",
    "links" : [ "android.bluetooth.BluetoothSocket", "createInsecureRfcommSocket", "android.bluetooth.BluetoothSocket#connect" ]
  }, {
    "name" : "public BluetoothSocket createInsecureL2capSocket(int channel) throws IOException",
    "returnType" : "BluetoothSocket",
    "comment" : "\n     * Create an L2cap {@link BluetoothSocket} ready to start an insecure outgoing connection to\n     * this remote device on given channel.\n     *\n     * <p>The remote device will be not authenticated and communication on this socket will not be\n     * encrypted.\n     *\n     * <p>Use {@link BluetoothSocket#connect} to initiate the outgoing connection.\n     *\n     * <p>Valid L2CAP PSM channels are in range 1 to 2^16.\n     *\n     * @param channel L2cap PSM/channel to connect to\n     * @return a RFCOMM BluetoothServerSocket ready for an outgoing connection\n     * @throws IOException on error, for example Bluetooth not available, or insufficient\n     *     permissions\n     * @hide\n     ",
    "links" : [ "android.bluetooth.BluetoothSocket", "android.bluetooth.BluetoothSocket#connect" ]
  }, {
    "name" : "public BluetoothSocket createRfcommSocketToServiceRecord(UUID uuid) throws IOException",
    "returnType" : "BluetoothSocket",
    "comment" : "\n     * Create an RFCOMM {@link BluetoothSocket} ready to start a secure outgoing connection to this\n     * remote device using SDP lookup of uuid.\n     *\n     * <p>This is designed to be used with {@link\n     * BluetoothAdapter#listenUsingRfcommWithServiceRecord} for peer-peer Bluetooth applications.\n     *\n     * <p>Use {@link BluetoothSocket#connect} to initiate the outgoing connection. This will also\n     * perform an SDP lookup of the given uuid to determine which channel to connect to.\n     *\n     * <p>The remote device will be authenticated and communication on this socket will be\n     * encrypted.\n     *\n     * <p>Use this socket only if an authenticated socket link is possible. Authentication refers to\n     * the authentication of the link key to prevent person-in-the-middle type of attacks. For\n     * example, for Bluetooth 2.1 devices, if any of the devices does not have an input and output\n     * capability or just has the ability to display a numeric key, a secure socket connection is\n     * not possible. In such a case, use {@link #createInsecureRfcommSocketToServiceRecord}. For\n     * more details, refer to the Security Model section 5.2 (vol 3) of Bluetooth Core Specification\n     * version 2.1 + EDR.\n     *\n     * <p>Hint: If you are connecting to a Bluetooth serial board then try using the well-known SPP\n     * UUID 00001101-0000-1000-8000-00805F9B34FB. However if you are connecting to an Android peer\n     * then please generate your own unique UUID.\n     *\n     * @param uuid service record uuid to lookup RFCOMM channel\n     * @return a RFCOMM BluetoothServerSocket ready for an outgoing connection\n     * @throws IOException on error, for example Bluetooth not available, or insufficient\n     *     permissions\n     ",
    "links" : [ "android.bluetooth.BluetoothSocket", "#createInsecureRfcommSocketToServiceRecord", "android.bluetooth.BluetoothAdapter#listenUsingRfcommWithServiceRecord", "android.bluetooth.BluetoothSocket#connect" ]
  }, {
    "name" : "public BluetoothSocket createInsecureRfcommSocketToServiceRecord(UUID uuid) throws IOException",
    "returnType" : "BluetoothSocket",
    "comment" : "\n     * Create an RFCOMM {@link BluetoothSocket} socket ready to start an insecure outgoing\n     * connection to this remote device using SDP lookup of uuid.\n     *\n     * <p>The communication channel will not have an authenticated link key i.e. it will be subject\n     * to person-in-the-middle attacks. For Bluetooth 2.1 devices, the link key will be encrypted,\n     * as encryption is mandatory. For legacy devices (pre Bluetooth 2.1 devices) the link key will\n     * be not be encrypted. Use {@link #createRfcommSocketToServiceRecord} if an encrypted and\n     * authenticated communication channel is desired.\n     *\n     * <p>This is designed to be used with {@link\n     * BluetoothAdapter#listenUsingInsecureRfcommWithServiceRecord} for peer-peer Bluetooth\n     * applications.\n     *\n     * <p>Use {@link BluetoothSocket#connect} to initiate the outgoing connection. This will also\n     * perform an SDP lookup of the given uuid to determine which channel to connect to.\n     *\n     * <p>The remote device will be authenticated and communication on this socket will be\n     * encrypted.\n     *\n     * <p>Hint: If you are connecting to a Bluetooth serial board then try using the well-known SPP\n     * UUID 00001101-0000-1000-8000-00805F9B34FB. However if you are connecting to an Android peer\n     * then please generate your own unique UUID.\n     *\n     * @param uuid service record uuid to lookup RFCOMM channel\n     * @return a RFCOMM BluetoothServerSocket ready for an outgoing connection\n     * @throws IOException on error, for example Bluetooth not available, or insufficient\n     *     permissions\n     ",
    "links" : [ "android.bluetooth.BluetoothSocket", "#createRfcommSocketToServiceRecord", "android.bluetooth.BluetoothAdapter#listenUsingInsecureRfcommWithServiceRecord", "android.bluetooth.BluetoothSocket#connect" ]
  }, {
    "name" : "public BluetoothSocket createInsecureRfcommSocket(int port) throws IOException",
    "returnType" : "BluetoothSocket",
    "comment" : "\n     * Construct an insecure RFCOMM socket ready to start an outgoing connection. Call #connect on\n     * the returned #BluetoothSocket to begin the connection. The remote device will not be\n     * authenticated and communication on this socket will not be encrypted.\n     *\n     * @param port remote port\n     * @return An RFCOMM BluetoothSocket\n     * @throws IOException On error, for example Bluetooth not available, or insufficient\n     *     permissions.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public BluetoothSocket createScoSocket() throws IOException",
    "returnType" : "BluetoothSocket",
    "comment" : "\n     * Construct a SCO socket ready to start an outgoing connection. Call #connect on the returned\n     * #BluetoothSocket to begin the connection.\n     *\n     * @return a SCO BluetoothSocket\n     * @throws IOException on error, for example Bluetooth not available, or insufficient\n     *     permissions.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public static byte[] convertPinToBytes(String pin)",
    "returnType" : "byte[]",
    "comment" : "\n     * Check that a pin is valid and convert to byte array.\n     *\n     * <p>Bluetooth pin's are 1 to 16 bytes of UTF-8 characters.\n     *\n     * @param pin pin as java String\n     * @return the pin code as a UTF-8 byte array, or null if it is an invalid Bluetooth pin.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public BluetoothGatt connectGatt(Context context, boolean autoConnect, BluetoothGattCallback callback)",
    "returnType" : "BluetoothGatt",
    "comment" : "\n     * Connect to GATT Server hosted by this device. Caller acts as GATT client. The callback is\n     * used to deliver results to Caller, such as connection status as well as any further GATT\n     * client operations. The method returns a BluetoothGatt instance. You can use BluetoothGatt to\n     * conduct GATT client operations.\n     *\n     * @param callback GATT callback handler that will receive asynchronous callbacks.\n     * @param autoConnect Whether to directly connect to the remote device (false) or to\n     *     automatically connect as soon as the remote device becomes available (true).\n     * @throws IllegalArgumentException if callback is null\n     ",
    "links" : [ ]
  }, {
    "name" : "public BluetoothGatt connectGatt(Context context, boolean autoConnect, BluetoothGattCallback callback, int transport)",
    "returnType" : "BluetoothGatt",
    "comment" : "\n     * Connect to GATT Server hosted by this device. Caller acts as GATT client. The callback is\n     * used to deliver results to Caller, such as connection status as well as any further GATT\n     * client operations. The method returns a BluetoothGatt instance. You can use BluetoothGatt to\n     * conduct GATT client operations.\n     *\n     * @param callback GATT callback handler that will receive asynchronous callbacks.\n     * @param autoConnect Whether to directly connect to the remote device (false) or to\n     *     automatically connect as soon as the remote device becomes available (true).\n     * @param transport preferred transport for GATT connections to remote dual-mode devices {@link\n     *     BluetoothDevice#TRANSPORT_AUTO} or {@link BluetoothDevice#TRANSPORT_BREDR} or {@link\n     *     BluetoothDevice#TRANSPORT_LE}\n     * @throws IllegalArgumentException if callback is null\n     ",
    "links" : [ "android.bluetooth.BluetoothDevice#TRANSPORT_BREDR", "android.bluetooth.BluetoothDevice#TRANSPORT_AUTO", "android.bluetooth.BluetoothDevice#TRANSPORT_LE" ]
  }, {
    "name" : "public BluetoothGatt connectGatt(Context context, boolean autoConnect, BluetoothGattCallback callback, int transport, int phy)",
    "returnType" : "BluetoothGatt",
    "comment" : "\n     * Connect to GATT Server hosted by this device. Caller acts as GATT client. The callback is\n     * used to deliver results to Caller, such as connection status as well as any further GATT\n     * client operations. The method returns a BluetoothGatt instance. You can use BluetoothGatt to\n     * conduct GATT client operations.\n     *\n     * @param callback GATT callback handler that will receive asynchronous callbacks.\n     * @param autoConnect Whether to directly connect to the remote device (false) or to\n     *     automatically connect as soon as the remote device becomes available (true).\n     * @param transport preferred transport for GATT connections to remote dual-mode devices {@link\n     *     BluetoothDevice#TRANSPORT_AUTO} or {@link BluetoothDevice#TRANSPORT_BREDR} or {@link\n     *     BluetoothDevice#TRANSPORT_LE}\n     * @param phy preferred PHY for connections to remote LE device. Bitwise OR of any of {@link\n     *     BluetoothDevice#PHY_LE_1M_MASK}, {@link BluetoothDevice#PHY_LE_2M_MASK}, and {@link\n     *     BluetoothDevice#PHY_LE_CODED_MASK}. This option does not take effect if {@code\n     *     autoConnect} is set to true.\n     * @throws NullPointerException if callback is null\n     ",
    "links" : [ "android.bluetooth.BluetoothDevice#TRANSPORT_BREDR", "android.bluetooth.BluetoothDevice#TRANSPORT_AUTO", "android.bluetooth.BluetoothDevice#PHY_LE_2M_MASK", "android.bluetooth.BluetoothDevice#PHY_LE_1M_MASK", "android.bluetooth.BluetoothDevice#PHY_LE_CODED_MASK", "android.bluetooth.BluetoothDevice#TRANSPORT_LE" ]
  }, {
    "name" : "public BluetoothGatt connectGatt(Context context, boolean autoConnect, BluetoothGattCallback callback, int transport, int phy, Handler handler)",
    "returnType" : "BluetoothGatt",
    "comment" : "\n     * Connect to GATT Server hosted by this device. Caller acts as GATT client. The callback is\n     * used to deliver results to Caller, such as connection status as well as any further GATT\n     * client operations. The method returns a BluetoothGatt instance. You can use BluetoothGatt to\n     * conduct GATT client operations.\n     *\n     * @param callback GATT callback handler that will receive asynchronous callbacks.\n     * @param autoConnect Whether to directly connect to the remote device (false) or to\n     *     automatically connect as soon as the remote device becomes available (true).\n     * @param transport preferred transport for GATT connections to remote dual-mode devices {@link\n     *     BluetoothDevice#TRANSPORT_AUTO} or {@link BluetoothDevice#TRANSPORT_BREDR} or {@link\n     *     BluetoothDevice#TRANSPORT_LE}\n     * @param phy preferred PHY for connections to remote LE device. Bitwise OR of any of {@link\n     *     BluetoothDevice#PHY_LE_1M_MASK}, {@link BluetoothDevice#PHY_LE_2M_MASK}, an d{@link\n     *     BluetoothDevice#PHY_LE_CODED_MASK}. This option does not take effect if {@code\n     *     autoConnect} is set to true.\n     * @param handler The handler to use for the callback. If {@code null}, callbacks will happen on\n     *     an un-specified background thread.\n     * @throws NullPointerException if callback is null\n     ",
    "links" : [ "android.bluetooth.BluetoothDevice#TRANSPORT_BREDR", "android.bluetooth.BluetoothDevice#TRANSPORT_AUTO", "android.bluetooth.BluetoothDevice#PHY_LE_2M_MASK", "android.bluetooth.BluetoothDevice#PHY_LE_1M_MASK", "android.bluetooth.BluetoothDevice#PHY_LE_CODED_MASK", "android.bluetooth.BluetoothDevice#TRANSPORT_LE" ]
  }, {
    "name" : "public BluetoothGatt connectGatt(Context context, boolean autoConnect, BluetoothGattCallback callback, int transport, boolean opportunistic, int phy, Handler handler)",
    "returnType" : "BluetoothGatt",
    "comment" : "\n     * Connect to GATT Server hosted by this device. Caller acts as GATT client. The callback is\n     * used to deliver results to Caller, such as connection status as well as any further GATT\n     * client operations. The method returns a BluetoothGatt instance. You can use BluetoothGatt to\n     * conduct GATT client operations.\n     *\n     * @param callback GATT callback handler that will receive asynchronous callbacks.\n     * @param autoConnect Whether to directly connect to the remote device (false) or to\n     *     automatically connect as soon as the remote device becomes available (true).\n     * @param transport preferred transport for GATT connections to remote dual-mode devices {@link\n     *     BluetoothDevice#TRANSPORT_AUTO} or {@link BluetoothDevice#TRANSPORT_BREDR} or {@link\n     *     BluetoothDevice#TRANSPORT_LE}\n     * @param opportunistic Whether this GATT client is opportunistic. An opportunistic GATT client\n     *     does not hold a GATT connection. It automatically disconnects when no other GATT\n     *     connections are active for the remote device.\n     * @param phy preferred PHY for connections to remote LE device. Bitwise OR of any of {@link\n     *     BluetoothDevice#PHY_LE_1M_MASK}, {@link BluetoothDevice#PHY_LE_2M_MASK}, an d{@link\n     *     BluetoothDevice#PHY_LE_CODED_MASK}. This option does not take effect if {@code\n     *     autoConnect} is set to true.\n     * @param handler The handler to use for the callback. If {@code null}, callbacks will happen on\n     *     an un-specified background thread.\n     * @return A BluetoothGatt instance. You can use BluetoothGatt to conduct GATT client\n     *     operations.\n     * @hide\n     ",
    "links" : [ "android.bluetooth.BluetoothDevice#TRANSPORT_BREDR", "android.bluetooth.BluetoothDevice#TRANSPORT_AUTO", "android.bluetooth.BluetoothDevice#PHY_LE_2M_MASK", "android.bluetooth.BluetoothDevice#PHY_LE_1M_MASK", "android.bluetooth.BluetoothDevice#PHY_LE_CODED_MASK", "android.bluetooth.BluetoothDevice#TRANSPORT_LE" ]
  }, {
    "name" : "public BluetoothSocket createL2capChannel(int psm) throws IOException",
    "returnType" : "BluetoothSocket",
    "comment" : "\n     * Create a Bluetooth L2CAP Connection-oriented Channel (CoC) {@link BluetoothSocket} that can\n     * be used to start a secure outgoing connection to the remote device with the same dynamic\n     * protocol/service multiplexer (PSM) value. The supported Bluetooth transport is LE only.\n     *\n     * <p>This is designed to be used with {@link BluetoothAdapter#listenUsingL2capChannel()} for\n     * peer-peer Bluetooth applications.\n     *\n     * <p>Use {@link BluetoothSocket#connect} to initiate the outgoing connection.\n     *\n     * <p>Application using this API is responsible for obtaining PSM value from remote device.\n     *\n     * <p>The remote device will be authenticated and communication on this socket will be\n     * encrypted.\n     *\n     * <p>Use this socket if an authenticated socket link is possible. Authentication refers to the\n     * authentication of the link key to prevent person-in-the-middle type of attacks.\n     *\n     * @param psm dynamic PSM value from remote device\n     * @return a CoC #BluetoothSocket ready for an outgoing connection\n     * @throws IOException on error, for example Bluetooth not available, or insufficient\n     *     permissions\n     ",
    "links" : [ "android.bluetooth.BluetoothSocket", "android.bluetooth.BluetoothAdapter#listenUsingL2capChannel()", "android.bluetooth.BluetoothSocket#connect" ]
  }, {
    "name" : "public BluetoothSocket createInsecureL2capChannel(int psm) throws IOException",
    "returnType" : "BluetoothSocket",
    "comment" : "\n     * Create a Bluetooth L2CAP Connection-oriented Channel (CoC) {@link BluetoothSocket} that can\n     * be used to start a secure outgoing connection to the remote device with the same dynamic\n     * protocol/service multiplexer (PSM) value. The supported Bluetooth transport is LE only.\n     *\n     * <p>This is designed to be used with {@link\n     * BluetoothAdapter#listenUsingInsecureL2capChannel()} for peer-peer Bluetooth applications.\n     *\n     * <p>Use {@link BluetoothSocket#connect} to initiate the outgoing connection.\n     *\n     * <p>Application using this API is responsible for obtaining PSM value from remote device.\n     *\n     * <p>The communication channel may not have an authenticated link key, i.e. it may be subject\n     * to person-in-the-middle attacks. Use {@link #createL2capChannel(int)} if an encrypted and\n     * authenticated communication channel is possible.\n     *\n     * @param psm dynamic PSM value from remote device\n     * @return a CoC #BluetoothSocket ready for an outgoing connection\n     * @throws IOException on error, for example Bluetooth not available, or insufficient\n     *     permissions\n     ",
    "links" : [ "android.bluetooth.BluetoothSocket", "android.bluetooth.BluetoothAdapter#listenUsingInsecureL2capChannel()", "#createL2capChannel(int)", "android.bluetooth.BluetoothSocket#connect" ]
  }, {
    "name" : "public boolean setMetadata(@MetadataKey int key, @NonNull byte[] value)",
    "returnType" : "boolean",
    "comment" : "\n     * Set a keyed metadata of this {@link BluetoothDevice} to a {@link String} value. Only bonded\n     * devices's metadata will be persisted across Bluetooth restart. Metadata will be removed when\n     * the device's bond state is moved to {@link #BOND_NONE}.\n     *\n     * @param key must be within the list of BluetoothDevice.METADATA_*\n     * @param value a byte array data to set for key. Must be less than {@link\n     *     BluetoothAdapter#METADATA_MAX_LENGTH} characters in length\n     * @return true on success, false on error\n     * @hide\n     ",
    "links" : [ "android.bluetooth.BluetoothDevice", "android.bluetooth.BluetoothAdapter#METADATA_MAX_LENGTH", "String", "#BOND_NONE" ]
  }, {
    "name" : "public byte[] getMetadata(@MetadataKey int key)",
    "returnType" : "byte[]",
    "comment" : "\n     * Get a keyed metadata for this {@link BluetoothDevice} as {@link String}\n     *\n     * @param key must be within the list of BluetoothDevice.METADATA_*\n     * @return Metadata of the key as byte array, null on error or not found\n     * @hide\n     ",
    "links" : [ "android.bluetooth.BluetoothDevice", "String" ]
  }, {
    "name" : "public static int getMaxMetadataKey()",
    "returnType" : "int",
    "comment" : "\n     * Get the maximum metadata key ID.\n     *\n     * @return the last supported metadata key\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public int isRequestAudioPolicyAsSinkSupported()",
    "returnType" : "int",
    "comment" : "\n     * Returns whether the audio policy feature is supported by both the local and the remote\n     * device. This is configured during initiating the connection between the devices through one\n     * of the transport protocols (e.g. HFP Vendor specific protocol). So if the API is invoked\n     * before this initial configuration is completed, it returns {@link\n     * BluetoothStatusCodes#FEATURE_NOT_CONFIGURED} to indicate the remote device has not yet\n     * relayed this information. After the internal configuration, the support status will be set to\n     * either {@link BluetoothStatusCodes#FEATURE_NOT_SUPPORTED} or {@link\n     * BluetoothStatusCodes#FEATURE_SUPPORTED}. The rest of the APIs related to this feature in both\n     * {@link BluetoothDevice} and {@link BluetoothSinkAudioPolicy} should be invoked only after\n     * getting a {@link BluetoothStatusCodes#FEATURE_SUPPORTED} response from this API.\n     *\n     * <p>Note that this API is intended to be used by a client device to send these requests to the\n     * server represented by this BluetoothDevice object.\n     *\n     * @return if call audio policy feature is supported by both local and remote device or not\n     * @hide\n     ",
    "links" : [ "android.bluetooth.BluetoothDevice", "android.bluetooth.BluetoothStatusCodes#FEATURE_NOT_CONFIGURED", "android.bluetooth.BluetoothStatusCodes#FEATURE_SUPPORTED", "android.bluetooth.BluetoothSinkAudioPolicy", "android.bluetooth.BluetoothStatusCodes#FEATURE_NOT_SUPPORTED" ]
  }, {
    "name" : "public int requestAudioPolicyAsSink(@NonNull BluetoothSinkAudioPolicy policies)",
    "returnType" : "int",
    "comment" : "\n     * Sets call audio preferences and sends them to the remote device.\n     *\n     * <p>Note that the caller should check if the feature is supported by invoking {@link\n     * BluetoothDevice#isRequestAudioPolicyAsSinkSupported} first.\n     *\n     * <p>This API will throw an exception if the feature is not supported but still invoked.\n     *\n     * <p>Note that this API is intended to be used by a client device to send these requests to the\n     * server represented by this BluetoothDevice object.\n     *\n     * @param policies call audio policy preferences\n     * @return whether audio policy was requested successfully or not\n     * @hide\n     ",
    "links" : [ "android.bluetooth.BluetoothDevice#isRequestAudioPolicyAsSinkSupported" ]
  }, {
    "name" : "public BluetoothSinkAudioPolicy getRequestedAudioPolicyAsSink()",
    "returnType" : "BluetoothSinkAudioPolicy",
    "comment" : "\n     * Gets the call audio preferences for the remote device.\n     *\n     * <p>Note that the caller should check if the feature is supported by invoking {@link\n     * BluetoothDevice#isRequestAudioPolicyAsSinkSupported} first.\n     *\n     * <p>This API will throw an exception if the feature is not supported but still invoked.\n     *\n     * <p>This API will return null if 1. The bluetooth service is not started yet, 2. It is invoked\n     * for a device which is not bonded, or 3. The used transport, for example, HFP Client profile\n     * is not enabled or connected yet.\n     *\n     * <p>Note that this API is intended to be used by a client device to send these requests to the\n     * server represented by this BluetoothDevice object.\n     *\n     * @return call audio policy as {@link BluetoothSinkAudioPolicy} object\n     * @hide\n     ",
    "links" : [ "android.bluetooth.BluetoothSinkAudioPolicy", "android.bluetooth.BluetoothDevice#isRequestAudioPolicyAsSinkSupported" ]
  }, {
    "name" : "public boolean setLowLatencyAudioAllowed(boolean allowed)",
    "returnType" : "boolean",
    "comment" : "\n     * Enable or disable audio low latency for this {@link BluetoothDevice}.\n     *\n     * @param allowed true if low latency is allowed, false if low latency is disallowed.\n     * @return true if the value is successfully set, false if there is a error when setting the\n     *     value.\n     * @hide\n     ",
    "links" : [ "android.bluetooth.BluetoothDevice" ]
  }, {
    "name" : "public int setActiveAudioDevicePolicy(@ActiveAudioDevicePolicy int activeAudioDevicePolicy)",
    "returnType" : "int",
    "comment" : "\n     * Set the active audio device policy for this {@link BluetoothDevice} to indicate what {@link\n     * ActiveAudioDevicePolicy} is applied upon device connection.\n     *\n     * <p>This API allows application to set the audio device profiles active policy upon\n     * connection, only bonded device's policy will be persisted across Bluetooth restart. Policy\n     * setting will be removed when the device's bond state is moved to {@link #BOND_NONE}.\n     *\n     * @param activeAudioDevicePolicy is the active audio device policy to set for this device\n     * @return whether the policy was set properly\n     * @throws IllegalArgumentException if this BluetoothDevice object has an invalid address\n     * @hide\n     ",
    "links" : [ "android.bluetooth.BluetoothDevice", "ActiveAudioDevicePolicy", "#BOND_NONE" ]
  }, {
    "name" : "public int getActiveAudioDevicePolicy()",
    "returnType" : "int",
    "comment" : "\n     * Get the active audio device policy for this {@link BluetoothDevice}.\n     *\n     * @return active audio device policy of the device\n     * @hide\n     ",
    "links" : [ "android.bluetooth.BluetoothDevice" ]
  }, {
    "name" : "private static void log(String msg)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  } ],
  "methodNames" : [ " static IBluetooth getService()", "public void setAttributionSource(@NonNull AttributionSource attributionSource)", "public void prepareToEnterProcess(@NonNull AttributionSource attributionSource)", "public boolean equals(@Nullable Object o)", "public int hashCode()", "public String toString()", "private static boolean shouldLogBeRedacted()", "public String toStringForLogging()", "public int describeContents()", "public void writeToParcel(Parcel out, int flags)", "public String getAddress()", "public int getAddressType()", "public String getAnonymizedAddress()", "public String getAddressForLogging()", "public String getIdentityAddress()", "public String getName()", "public int getType()", "public String getAlias()", "public int setAlias(@Nullable String alias)", "public int getBatteryLevel()", "public boolean createBond()", "public boolean createBond(int transport)", "public boolean createBondOutOfBand(int transport, @Nullable OobData remoteP192Data, @Nullable OobData remoteP256Data)", "private boolean createBondInternal(int transport, @Nullable OobData remoteP192Data, @Nullable OobData remoteP256Data)", "public boolean isBondingInitiatedLocally()", "public boolean cancelBondProcess()", "public boolean removeBond()", "private static void invalidateCache(@NonNull String api)", "public void disableBluetoothGetBondStateCache()", "public static void invalidateBluetoothGetBondStateCache()", "public int getBondState()", "public boolean canBondWithoutDialog()", "public String getPackageNameOfBondingApplication()", "public int connect()", "public int disconnect()", "public boolean isConnected()", "public int getConnectionHandle(@Transport int transport)", "public boolean isEncrypted()", "public BluetoothClass getBluetoothClass()", "public ParcelUuid[] getUuids()", "public boolean fetchUuidsWithSdp()", "public boolean fetchUuidsWithSdp(@Transport int transport)", "public boolean sdpSearch(ParcelUuid uuid)", "public boolean setPin(byte[] pin)", "public boolean setPin(@NonNull String pin)", "public boolean setPairingConfirmation(boolean confirm)", " boolean isBluetoothEnabled()", "public int getPhonebookAccessPermission()", "public boolean setSilenceMode(boolean silence)", "public boolean isInSilenceMode()", "public boolean setPhonebookAccessPermission(@AccessPermission int value)", "public int getMessageAccessPermission()", "public boolean setMessageAccessPermission(@AccessPermission int value)", "public int getSimAccessPermission()", "public boolean setSimAccessPermission(int value)", "public BluetoothSocket createRfcommSocket(int channel) throws IOException", "public BluetoothSocket createL2capSocket(int channel) throws IOException", "public BluetoothSocket createInsecureL2capSocket(int channel) throws IOException", "public BluetoothSocket createRfcommSocketToServiceRecord(UUID uuid) throws IOException", "public BluetoothSocket createInsecureRfcommSocketToServiceRecord(UUID uuid) throws IOException", "public BluetoothSocket createInsecureRfcommSocket(int port) throws IOException", "public BluetoothSocket createScoSocket() throws IOException", "public static byte[] convertPinToBytes(String pin)", "public BluetoothGatt connectGatt(Context context, boolean autoConnect, BluetoothGattCallback callback)", "public BluetoothGatt connectGatt(Context context, boolean autoConnect, BluetoothGattCallback callback, int transport)", "public BluetoothGatt connectGatt(Context context, boolean autoConnect, BluetoothGattCallback callback, int transport, int phy)", "public BluetoothGatt connectGatt(Context context, boolean autoConnect, BluetoothGattCallback callback, int transport, int phy, Handler handler)", "public BluetoothGatt connectGatt(Context context, boolean autoConnect, BluetoothGattCallback callback, int transport, boolean opportunistic, int phy, Handler handler)", "public BluetoothSocket createL2capChannel(int psm) throws IOException", "public BluetoothSocket createInsecureL2capChannel(int psm) throws IOException", "public boolean setMetadata(@MetadataKey int key, @NonNull byte[] value)", "public byte[] getMetadata(@MetadataKey int key)", "public static int getMaxMetadataKey()", "public int isRequestAudioPolicyAsSinkSupported()", "public int requestAudioPolicyAsSink(@NonNull BluetoothSinkAudioPolicy policies)", "public BluetoothSinkAudioPolicy getRequestedAudioPolicyAsSink()", "public boolean setLowLatencyAudioAllowed(boolean allowed)", "public int setActiveAudioDevicePolicy(@ActiveAudioDevicePolicy int activeAudioDevicePolicy)", "public int getActiveAudioDevicePolicy()", "private static void log(String msg)" ],
  "variableNames" : [ "TAG", "DBG", "CONNECTION_STATE_DISCONNECTED", "CONNECTION_STATE_CONNECTED", "CONNECTION_STATE_ENCRYPTED_BREDR", "CONNECTION_STATE_ENCRYPTED_LE", "ERROR", "ACTION_FOUND", "ACTION_CLASS_CHANGED", "ACTION_ACL_CONNECTED", "ACTION_ACL_DISCONNECT_REQUESTED", "ACTION_ACL_DISCONNECTED", "ACTION_NAME_CHANGED", "ACTION_ALIAS_CHANGED", "ACTION_BOND_STATE_CHANGED", "ACTION_BATTERY_LEVEL_CHANGED", "ACTION_SWITCH_BUFFER_SIZE", "ACTION_KEY_MISSING", "EXTRA_BATTERY_LEVEL", "BATTERY_LEVEL_UNKNOWN", "BATTERY_LEVEL_BLUETOOTH_OFF", "EXTRA_DEVICE", "EXTRA_NAME", "EXTRA_BQR", "EXTRA_RSSI", "EXTRA_IS_COORDINATED_SET_MEMBER", "EXTRA_CLASS", "EXTRA_BOND_STATE", "EXTRA_PREVIOUS_BOND_STATE", "EXTRA_LOW_LATENCY_BUFFER_SIZE", "BOND_NONE", "BOND_BONDING", "BOND_BONDED", "EXTRA_UNBOND_REASON", "EXTRA_REASON", "EXTRA_PAIRING_VARIANT", "EXTRA_PAIRING_KEY", "EXTRA_PAIRING_INITIATOR", "EXTRA_PAIRING_INITIATOR_FOREGROUND", "EXTRA_PAIRING_INITIATOR_BACKGROUND", "DEVICE_TYPE_UNKNOWN", "DEVICE_TYPE_CLASSIC", "DEVICE_TYPE_LE", "DEVICE_TYPE_DUAL", "ACTION_SDP_RECORD", "METADATA_MAX_LENGTH", "METADATA_MANUFACTURER_NAME", "METADATA_MODEL_NAME", "METADATA_SOFTWARE_VERSION", "METADATA_HARDWARE_VERSION", "METADATA_COMPANION_APP", "METADATA_MAIN_ICON", "METADATA_IS_UNTETHERED_HEADSET", "METADATA_UNTETHERED_LEFT_ICON", "METADATA_UNTETHERED_RIGHT_ICON", "METADATA_UNTETHERED_CASE_ICON", "METADATA_UNTETHERED_LEFT_BATTERY", "METADATA_UNTETHERED_RIGHT_BATTERY", "METADATA_UNTETHERED_CASE_BATTERY", "METADATA_UNTETHERED_LEFT_CHARGING", "METADATA_UNTETHERED_RIGHT_CHARGING", "METADATA_UNTETHERED_CASE_CHARGING", "METADATA_ENHANCED_SETTINGS_UI_URI", "COMPANION_TYPE_PRIMARY", "COMPANION_TYPE_SECONDARY", "COMPANION_TYPE_NONE", "METADATA_DEVICE_TYPE", "METADATA_MAIN_BATTERY", "METADATA_MAIN_CHARGING", "METADATA_MAIN_LOW_BATTERY_THRESHOLD", "METADATA_UNTETHERED_LEFT_LOW_BATTERY_THRESHOLD", "METADATA_UNTETHERED_RIGHT_LOW_BATTERY_THRESHOLD", "METADATA_UNTETHERED_CASE_LOW_BATTERY_THRESHOLD", "METADATA_SPATIAL_AUDIO", "METADATA_FAST_PAIR_CUSTOMIZED_FIELDS", "METADATA_LE_AUDIO", "METADATA_GMCS_CCCD", "METADATA_GTBS_CCCD", "METADATA_EXCLUSIVE_MANAGER", "METADATA_MAX_KEY", "DEVICE_TYPE_DEFAULT", "DEVICE_TYPE_WATCH", "DEVICE_TYPE_UNTETHERED_HEADSET", "DEVICE_TYPE_STYLUS", "DEVICE_TYPE_SPEAKER", "DEVICE_TYPE_HEADSET", "DEVICE_TYPE_CARKIT", "DEVICE_TYPE_HEARING_AID", "ACTION_UUID", "ACTION_MAS_INSTANCE", "ACTION_NAME_FAILED", "ACTION_PAIRING_REQUEST", "CHANGE_TO_STRING_REDACTED", "ACTION_PAIRING_CANCEL", "ACTION_CONNECTION_ACCESS_REQUEST", "ACTION_CONNECTION_ACCESS_REPLY", "ACTION_CONNECTION_ACCESS_CANCEL", "ACTION_SILENCE_MODE_CHANGED", "EXTRA_ACCESS_REQUEST_TYPE", "REQUEST_TYPE_PROFILE_CONNECTION", "REQUEST_TYPE_PHONEBOOK_ACCESS", "REQUEST_TYPE_MESSAGE_ACCESS", "REQUEST_TYPE_SIM_ACCESS", "EXTRA_PACKAGE_NAME", "EXTRA_CLASS_NAME", "EXTRA_CONNECTION_ACCESS_RESULT", "CONNECTION_ACCESS_YES", "CONNECTION_ACCESS_NO", "EXTRA_ALWAYS_ALLOWED", "BOND_SUCCESS", "UNBOND_REASON_AUTH_FAILED", "UNBOND_REASON_AUTH_REJECTED", "UNBOND_REASON_AUTH_CANCELED", "UNBOND_REASON_REMOTE_DEVICE_DOWN", "UNBOND_REASON_DISCOVERY_IN_PROGRESS", "UNBOND_REASON_AUTH_TIMEOUT", "UNBOND_REASON_REPEATED_ATTEMPTS", "UNBOND_REASON_REMOTE_AUTH_CANCELED", "UNBOND_REASON_REMOVED", "PAIRING_VARIANT_PIN", "PAIRING_VARIANT_PASSKEY", "PAIRING_VARIANT_PASSKEY_CONFIRMATION", "PAIRING_VARIANT_CONSENT", "PAIRING_VARIANT_DISPLAY_PASSKEY", "PAIRING_VARIANT_DISPLAY_PIN", "PAIRING_VARIANT_OOB_CONSENT", "PAIRING_VARIANT_PIN_16_DIGITS", "EXTRA_UUID", "EXTRA_SDP_RECORD", "EXTRA_SDP_SEARCH_STATUS", "ACCESS_UNKNOWN", "ACCESS_ALLOWED", "ACCESS_REJECTED", "TRANSPORT_AUTO", "TRANSPORT_BREDR", "TRANSPORT_LE", "PHY_LE_1M", "PHY_LE_2M", "PHY_LE_CODED", "PHY_LE_1M_MASK", "PHY_LE_2M_MASK", "PHY_LE_CODED_MASK", "PHY_OPTION_NO_PREFERRED", "PHY_OPTION_S2", "PHY_OPTION_S8", "EXTRA_MAS_INSTANCE", "EXTRA_TRANSPORT", "ADDRESS_TYPE_PUBLIC", "ADDRESS_TYPE_RANDOM", "ADDRESS_TYPE_UNKNOWN", "ADDRESS_TYPE_ANONYMOUS", "ACTIVE_AUDIO_DEVICE_POLICY_DEFAULT", "ACTIVE_AUDIO_DEVICE_POLICY_ALL_PROFILES_ACTIVE_UPON_CONNECTION", "ACTIVE_AUDIO_DEVICE_POLICY_ALL_PROFILES_INACTIVE_UPON_CONNECTION", "NULL_MAC_ADDRESS", "mAddress", "mAddressType", "sIsLogRedactionFlagSynced", "sIsLogRedactionEnabled", "mAttributionSource", "CREATOR", "sBluetoothBondQuery", "GET_BOND_STATE_API", "sBluetoothBondCache" ]
}