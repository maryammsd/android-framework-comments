{
  "filePath" : "/home/maryam/clearblue/files/android-source-30/android/telephony/TelephonyManager.java",
  "packageName" : "android.telephony",
  "className" : "TelephonyManager",
  "comment" : "\n * Provides access to information about the telephony services on\n * the device. Applications can use the methods in this class to\n * determine telephony services and states, as well as to access some\n * types of subscriber information. Applications can also register\n * a listener to receive notification of telephony state changes.\n * <p>\n * The returned TelephonyManager will use the default subscription for all calls.\n * To call an API for a specific subscription, use {@link #createForSubscriptionId(int)}. e.g.\n * <code>\n *   telephonyManager = defaultSubTelephonyManager.createForSubscriptionId(subId);\n * </code>\n * <p>\n * Note that access to some telephony information is\n * permission-protected. Your application cannot access the protected\n * information unless it has the appropriate permissions declared in\n * its manifest file. Where permissions apply, they are noted in the\n * the methods through which you access the protected information.\n *\n * <p>TelephonyManager is intended for use on devices that implement\n * {@link android.content.pm.PackageManager#FEATURE_TELEPHONY FEATURE_TELEPHONY}. On devices\n * that do not implement this feature, the behavior is not reliable.\n ",
  "variables" : [ {
    "name" : "TAG",
    "type" : "String",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "CALLBACK_ON_MORE_ERROR_CODE_CHANGE",
    "type" : "long",
    "comment" : "\n     * To expand the error codes for {@link TelephonyManager#updateAvailableNetworks} and\n     * {@link TelephonyManager#setPreferredOpportunisticDataSubscription}.\n     ",
    "links" : [ "android.telephony.TelephonyManager#updateAvailableNetworks", "android.telephony.TelephonyManager#setPreferredOpportunisticDataSubscription" ]
  }, {
    "name" : "MODEM_ACTIVITY_RESULT_KEY",
    "type" : "String",
    "comment" : "\n     * The key to use when placing the result of {@link #requestModemActivityInfo(ResultReceiver)}\n     * into the ResultReceiver Bundle.\n     * @hide\n     ",
    "links" : [ "#requestModemActivityInfo(ResultReceiver)" ]
  }, {
    "name" : "PHONE_PROCESS_NAME",
    "type" : "String",
    "comment" : "\n     * The process name of the Phone app as well as many other apps that use this process name, such\n     * as settings and vendor components.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "NETWORK_SELECTION_MODE_UNKNOWN",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "NETWORK_SELECTION_MODE_AUTO",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "NETWORK_SELECTION_MODE_MANUAL",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "OTASP_UNINITIALIZED",
    "type" : "int",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "OTASP_UNKNOWN",
    "type" : "int",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "OTASP_NEEDED",
    "type" : "int",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "OTASP_NOT_NEEDED",
    "type" : "int",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "OTASP_SIM_UNPROVISIONED",
    "type" : "int",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "KEY_TYPE_EPDG",
    "type" : "int",
    "comment" : "\n     * Used in carrier Wi-Fi for IMSI + IMPI encryption, this indicates a public key that's\n     * available for use in ePDG links.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "KEY_TYPE_WLAN",
    "type" : "int",
    "comment" : "\n     * Used in carrier Wi-Fi for IMSI + IMPI encryption, this indicates a public key that's\n     * available for use in WLAN links.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "SRVCC_STATE_HANDOVER_NONE",
    "type" : "int",
    "comment" : "\n     * No Single Radio Voice Call Continuity (SRVCC) handover is active.\n     * See TS 23.216 for more information.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "SRVCC_STATE_HANDOVER_STARTED",
    "type" : "int",
    "comment" : "\n     * Single Radio Voice Call Continuity (SRVCC) handover has been started on the network.\n     * See TS 23.216 for more information.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "SRVCC_STATE_HANDOVER_COMPLETED",
    "type" : "int",
    "comment" : "\n     * Ongoing Single Radio Voice Call Continuity (SRVCC) handover has successfully completed.\n     * See TS 23.216 for more information.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "SRVCC_STATE_HANDOVER_FAILED",
    "type" : "int",
    "comment" : "\n     * Ongoing Single Radio Voice Call Continuity (SRVCC) handover has failed.\n     * See TS 23.216 for more information.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "SRVCC_STATE_HANDOVER_CANCELED",
    "type" : "int",
    "comment" : "\n     * Ongoing Single Radio Voice Call Continuity (SRVCC) handover has been canceled.\n     * See TS 23.216 for more information.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "UNSUPPORTED_CARD_ID",
    "type" : "int",
    "comment" : "\n     * A UICC card identifier used if the device does not support the operation.\n     * For example, {@link #getCardIdForDefaultEuicc()} returns this value if the device has no\n     * eUICC, or the eUICC cannot be read.\n     ",
    "links" : [ "#getCardIdForDefaultEuicc()" ]
  }, {
    "name" : "UNINITIALIZED_CARD_ID",
    "type" : "int",
    "comment" : "\n     * A UICC card identifier used before the UICC card is loaded. See\n     * {@link #getCardIdForDefaultEuicc()} and {@link UiccCardInfo#getCardId()}.\n     * <p>\n     * Note that once the UICC card is loaded, the card ID may become {@link #UNSUPPORTED_CARD_ID}.\n     ",
    "links" : [ "android.telephony.UiccCardInfo#getCardId()", "#UNSUPPORTED_CARD_ID", "#getCardIdForDefaultEuicc()" ]
  }, {
    "name" : "mContext",
    "type" : "Context",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mSubId",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mSubscriptionManager",
    "type" : "SubscriptionManager",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mTelephonyScanManager",
    "type" : "TelephonyScanManager",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "sCacheLock",
    "type" : "Object",
    "comment" : " Cached service handles, cleared by resetServiceHandles() at death ",
    "links" : [ ]
  }, {
    "name" : "sServiceHandleCacheEnabled",
    "type" : "boolean",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "sIPhoneSubInfo",
    "type" : "IPhoneSubInfo",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "sISub",
    "type" : "ISub",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "sISms",
    "type" : "ISms",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "sServiceDeath",
    "type" : "DeathRecipient",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "sInstance",
    "type" : "TelephonyManager",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "ACTION_PHONE_STATE_CHANGED",
    "type" : "String",
    "comment" : "\n     * Broadcast intent action indicating that the call state\n     * on the device has changed.\n     *\n     * <p>\n     * The {@link #EXTRA_STATE} extra indicates the new call state.\n     * If a receiving app has {@link android.Manifest.permission#READ_CALL_LOG} permission, a second\n     * extra {@link #EXTRA_INCOMING_NUMBER} provides the phone number for incoming and outgoing\n     * calls as a String.\n     * <p>\n     * If the receiving app has\n     * {@link android.Manifest.permission#READ_CALL_LOG} and\n     * {@link android.Manifest.permission#READ_PHONE_STATE} permission, it will receive the\n     * broadcast twice; one with the {@link #EXTRA_INCOMING_NUMBER} populated with the phone number,\n     * and another with it blank.  Due to the nature of broadcasts, you cannot assume the order\n     * in which these broadcasts will arrive, however you are guaranteed to receive two in this\n     * case.  Apps which are interested in the {@link #EXTRA_INCOMING_NUMBER} can ignore the\n     * broadcasts where {@link #EXTRA_INCOMING_NUMBER} is not present in the extras (e.g. where\n     * {@link Intent#hasExtra(String)} returns {@code false}).\n     * <p class=\"note\">\n     * This was a {@link android.content.Context#sendStickyBroadcast sticky}\n     * broadcast in version 1.0, but it is no longer sticky.\n     * Instead, use {@link #getCallState} to synchronously query the current call state.\n     *\n     * @see #EXTRA_STATE\n     * @see #EXTRA_INCOMING_NUMBER\n     * @see #getCallState\n     ",
    "links" : [ "#EXTRA_STATE", "#getCallState", "android.app.PendingIntent#hasExtra(String)", "android.Manifest.permission#READ_PHONE_STATE", "android.Manifest.permission#READ_CALL_LOG", "#EXTRA_INCOMING_NUMBER", "android.content.Context#sendStickyBroadcast" ]
  }, {
    "name" : "ACTION_RESPOND_VIA_MESSAGE",
    "type" : "String",
    "comment" : "\n     * The Phone app sends this intent when a user opts to respond-via-message during an incoming\n     * call. By default, the device's default SMS app consumes this message and sends a text message\n     * to the caller. A third party app can also provide this functionality by consuming this Intent\n     * with a {@link android.app.Service} and sending the message using its own messaging system.\n     * <p>The intent contains a URI (available from {@link android.content.Intent#getData})\n     * describing the recipient, using either the {@code sms:}, {@code smsto:}, {@code mms:},\n     * or {@code mmsto:} URI schema. Each of these URI schema carry the recipient information the\n     * same way: the path part of the URI contains the recipient's phone number or a comma-separated\n     * set of phone numbers if there are multiple recipients. For example, {@code\n     * smsto:2065551234}.</p>\n     *\n     * <p>The intent may also contain extras for the message text (in {@link\n     * android.content.Intent#EXTRA_TEXT}) and a message subject\n     * (in {@link android.content.Intent#EXTRA_SUBJECT}).</p>\n     *\n     * <p class=\"note\"><strong>Note:</strong>\n     * The intent-filter that consumes this Intent needs to be in a {@link android.app.Service}\n     * that requires the\n     * permission {@link android.Manifest.permission#SEND_RESPOND_VIA_MESSAGE}.</p>\n     * <p>For example, the service that receives this intent can be declared in the manifest file\n     * with an intent filter like this:</p>\n     * <pre>\n     * &lt;!-- Service that delivers SMS messages received from the phone \"quick response\" -->\n     * &lt;service android:name=\".HeadlessSmsSendService\"\n     *          android:permission=\"android.permission.SEND_RESPOND_VIA_MESSAGE\"\n     *          android:exported=\"true\" >\n     *   &lt;intent-filter>\n     *     &lt;action android:name=\"android.intent.action.RESPOND_VIA_MESSAGE\" />\n     *     &lt;category android:name=\"android.intent.category.DEFAULT\" />\n     *     &lt;data android:scheme=\"sms\" />\n     *     &lt;data android:scheme=\"smsto\" />\n     *     &lt;data android:scheme=\"mms\" />\n     *     &lt;data android:scheme=\"mmsto\" />\n     *   &lt;/intent-filter>\n     * &lt;/service></pre>\n     * <p>\n     * Output: nothing.\n     ",
    "links" : [ "android.content.Intent#EXTRA_TEXT", "android.Manifest.permission#SEND_RESPOND_VIA_MESSAGE", "android.app.Service", "android.content.Intent#getData", "android.content.Intent#EXTRA_SUBJECT" ]
  }, {
    "name" : "ACTION_EMERGENCY_ASSISTANCE",
    "type" : "String",
    "comment" : "\n     * The emergency dialer may choose to present activities with intent filters for this\n     * action as emergency assistance buttons that launch the activity when clicked.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "METADATA_HIDE_VOICEMAIL_SETTINGS_MENU",
    "type" : "String",
    "comment" : "\n     * A boolean meta-data value indicating whether the voicemail settings should be hidden in the\n     * call settings page launched by\n     * {@link android.telecom.TelecomManager#ACTION_SHOW_CALL_SETTINGS}.\n     * Dialer implementations (see {@link android.telecom.TelecomManager#getDefaultDialerPackage()})\n     * which would also like to manage voicemail settings should set this meta-data to {@code true}\n     * in the manifest registration of their application.\n     *\n     * @see android.telecom.TelecomManager#ACTION_SHOW_CALL_SETTINGS\n     * @see #ACTION_CONFIGURE_VOICEMAIL\n     * @see #EXTRA_HIDE_PUBLIC_SETTINGS\n     ",
    "links" : [ "android.telecom.TelecomManager#getDefaultDialerPackage()", "android.telecom.TelecomManager#ACTION_SHOW_CALL_SETTINGS" ]
  }, {
    "name" : "ACTION_CONFIGURE_VOICEMAIL",
    "type" : "String",
    "comment" : "\n     * Open the voicemail settings activity to make changes to voicemail configuration.\n     *\n     * <p>\n     * The {@link #EXTRA_PHONE_ACCOUNT_HANDLE} extra indicates which {@link PhoneAccountHandle} to\n     * configure voicemail.\n     * The {@link #EXTRA_HIDE_PUBLIC_SETTINGS} hides settings the dialer will modify through public\n     * API if set.\n     *\n     * @see #EXTRA_PHONE_ACCOUNT_HANDLE\n     * @see #EXTRA_HIDE_PUBLIC_SETTINGS\n     ",
    "links" : [ "android.telecom.PhoneAccountHandle", "#EXTRA_HIDE_PUBLIC_SETTINGS", "#EXTRA_PHONE_ACCOUNT_HANDLE" ]
  }, {
    "name" : "EXTRA_HIDE_PUBLIC_SETTINGS",
    "type" : "String",
    "comment" : "\n     * The boolean value indicating whether the voicemail settings activity launched by {@link\n     * #ACTION_CONFIGURE_VOICEMAIL} should hide settings accessible through public API. This is\n     * used by dialer implementations which provides their own voicemail settings UI, but still\n     * needs to expose device specific voicemail settings to the user.\n     *\n     * @see #ACTION_CONFIGURE_VOICEMAIL\n     * @see #METADATA_HIDE_VOICEMAIL_SETTINGS_MENU\n     ",
    "links" : [ "#ACTION_CONFIGURE_VOICEMAIL" ]
  }, {
    "name" : "EMERGENCY_ASSISTANCE_ENABLED",
    "type" : "boolean",
    "comment" : "\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "EXTRA_STATE",
    "type" : "String",
    "comment" : "\n     * The lookup key used with the {@link #ACTION_PHONE_STATE_CHANGED} broadcast\n     * for a String containing the new call state.\n     *\n     * <p class=\"note\">\n     * Retrieve with\n     * {@link android.content.Intent#getStringExtra(String)}.\n     *\n     * @see #EXTRA_STATE_IDLE\n     * @see #EXTRA_STATE_RINGING\n     * @see #EXTRA_STATE_OFFHOOK\n     ",
    "links" : [ "android.content.Intent#getStringExtra(String)", "#ACTION_PHONE_STATE_CHANGED" ]
  }, {
    "name" : "EXTRA_STATE_IDLE",
    "type" : "String",
    "comment" : "\n     * Value used with {@link #EXTRA_STATE} corresponding to\n     * {@link #CALL_STATE_IDLE}.\n     ",
    "links" : [ "#EXTRA_STATE", "#CALL_STATE_IDLE" ]
  }, {
    "name" : "EXTRA_STATE_RINGING",
    "type" : "String",
    "comment" : "\n     * Value used with {@link #EXTRA_STATE} corresponding to\n     * {@link #CALL_STATE_RINGING}.\n     ",
    "links" : [ "#EXTRA_STATE", "#CALL_STATE_RINGING" ]
  }, {
    "name" : "EXTRA_STATE_OFFHOOK",
    "type" : "String",
    "comment" : "\n     * Value used with {@link #EXTRA_STATE} corresponding to\n     * {@link #CALL_STATE_OFFHOOK}.\n     ",
    "links" : [ "#CALL_STATE_OFFHOOK", "#EXTRA_STATE" ]
  }, {
    "name" : "EXTRA_INCOMING_NUMBER",
    "type" : "String",
    "comment" : "\n     * Extra key used with the {@link #ACTION_PHONE_STATE_CHANGED} broadcast\n     * for a String containing the incoming or outgoing phone number.\n     * <p>\n     * This extra is only populated for receivers of the {@link #ACTION_PHONE_STATE_CHANGED}\n     * broadcast which have been granted the {@link android.Manifest.permission#READ_CALL_LOG} and\n     * {@link android.Manifest.permission#READ_PHONE_STATE} permissions.\n     * <p>\n     * For incoming calls, the phone number is only guaranteed to be populated when the\n     * {@link #EXTRA_STATE} changes from {@link #EXTRA_STATE_IDLE} to {@link #EXTRA_STATE_RINGING}.\n     * If the incoming caller is from an unknown number, the extra will be populated with an empty\n     * string.\n     * For outgoing calls, the phone number is only guaranteed to be populated when the\n     * {@link #EXTRA_STATE} changes from {@link #EXTRA_STATE_IDLE} to {@link #EXTRA_STATE_OFFHOOK}.\n     * <p class=\"note\">\n     * Retrieve with\n     * {@link android.content.Intent#getStringExtra(String)}.\n     * <p>\n     *\n     * @deprecated Companion apps for wearable devices should use the {@link InCallService} API\n     * to retrieve the phone number for calls instead.  Apps performing call screening should use\n     * the {@link CallScreeningService} API instead.\n     ",
    "links" : [ "#EXTRA_STATE_IDLE", "android.content.Intent#getStringExtra(String)", "android.telecom.InCallService", "#EXTRA_STATE", "#ACTION_PHONE_STATE_CHANGED", "#EXTRA_STATE_RINGING", "#EXTRA_STATE_OFFHOOK", "android.Manifest.permission#READ_PHONE_STATE", "android.telecom.CallScreeningService", "android.Manifest.permission#READ_CALL_LOG" ]
  }, {
    "name" : "ACTION_CALL_DISCONNECT_CAUSE_CHANGED",
    "type" : "String",
    "comment" : "\n     * Broadcast intent action indicating that call disconnect cause has changed.\n     *\n     * <p>\n     * The {@link #EXTRA_DISCONNECT_CAUSE} extra indicates the disconnect cause.\n     * The {@link #EXTRA_PRECISE_DISCONNECT_CAUSE} extra indicates the precise disconnect cause.\n     *\n     * <p class=\"note\">\n     * Requires the READ_PRECISE_PHONE_STATE permission.\n     *\n     * @see #EXTRA_DISCONNECT_CAUSE\n     * @see #EXTRA_PRECISE_DISCONNECT_CAUSE\n     *\n     * @hide\n     ",
    "links" : [ "#EXTRA_PRECISE_DISCONNECT_CAUSE", "#EXTRA_DISCONNECT_CAUSE" ]
  }, {
    "name" : "EXTRA_DISCONNECT_CAUSE",
    "type" : "String",
    "comment" : "\n     * The lookup key used with the {@link #ACTION_PRECISE_CALL_STATE_CHANGED} broadcast and\n     * {@link PhoneStateListener#onPreciseCallStateChanged(PreciseCallState)} for an integer\n     * containing the disconnect cause.\n     *\n     * @see DisconnectCause\n     *\n     * <p class=\"note\">\n     * Retrieve with\n     * {@link android.content.Intent#getIntExtra(String name, int defaultValue)}.\n     *\n     * @deprecated Should use the {@link TelecomManager#EXTRA_DISCONNECT_CAUSE} instead.\n     * @hide\n     ",
    "links" : [ "#ACTION_PRECISE_CALL_STATE_CHANGED", "android.content.Intent#getIntExtra(String", "android.telephony.PhoneStateListener#onPreciseCallStateChanged(PreciseCallState)", "android.telecom.TelecomManager#EXTRA_DISCONNECT_CAUSE" ]
  }, {
    "name" : "EXTRA_PRECISE_DISCONNECT_CAUSE",
    "type" : "String",
    "comment" : "\n     * The lookup key used with the {@link #ACTION_PRECISE_CALL_STATE_CHANGED} broadcast and\n     * {@link PhoneStateListener#onPreciseCallStateChanged(PreciseCallState)} for an integer\n     * containing the disconnect cause provided by the RIL.\n     *\n     * @see PreciseDisconnectCause\n     *\n     * <p class=\"note\">\n     * Retrieve with\n     * {@link android.content.Intent#getIntExtra(String name, int defaultValue)}.\n     *\n     * @hide\n     ",
    "links" : [ "#ACTION_PRECISE_CALL_STATE_CHANGED", "android.content.Intent#getIntExtra(String", "android.telephony.PhoneStateListener#onPreciseCallStateChanged(PreciseCallState)" ]
  }, {
    "name" : "ACTION_SHOW_VOICEMAIL_NOTIFICATION",
    "type" : "String",
    "comment" : "\n     * Broadcast intent action for letting the default dialer to know to show voicemail\n     * notification.\n     *\n     * <p>\n     * The {@link #EXTRA_PHONE_ACCOUNT_HANDLE} extra indicates which {@link PhoneAccountHandle} the\n     * voicemail is received on.\n     * The {@link #EXTRA_NOTIFICATION_COUNT} extra indicates the total numbers of unheard\n     * voicemails.\n     * The {@link #EXTRA_VOICEMAIL_NUMBER} extra indicates the voicemail number if available.\n     * The {@link #EXTRA_CALL_VOICEMAIL_INTENT} extra is a {@link android.app.PendingIntent} that\n     * will call the voicemail number when sent. This extra will be empty if the voicemail number\n     * is not set, and {@link #EXTRA_LAUNCH_VOICEMAIL_SETTINGS_INTENT} will be set instead.\n     * The {@link #EXTRA_LAUNCH_VOICEMAIL_SETTINGS_INTENT} extra is a\n     * {@link android.app.PendingIntent} that will launch the voicemail settings. This extra is only\n     * available when the voicemail number is not set.\n     * The {@link #EXTRA_IS_REFRESH} extra indicates whether the notification is a refresh or a new\n     * notification.\n     *\n     * @see #EXTRA_PHONE_ACCOUNT_HANDLE\n     * @see #EXTRA_NOTIFICATION_COUNT\n     * @see #EXTRA_VOICEMAIL_NUMBER\n     * @see #EXTRA_CALL_VOICEMAIL_INTENT\n     * @see #EXTRA_LAUNCH_VOICEMAIL_SETTINGS_INTENT\n     * @see #EXTRA_IS_REFRESH\n     ",
    "links" : [ "android.telecom.PhoneAccountHandle", "#EXTRA_VOICEMAIL_NUMBER", "#EXTRA_CALL_VOICEMAIL_INTENT", "#EXTRA_LAUNCH_VOICEMAIL_SETTINGS_INTENT", "#EXTRA_IS_REFRESH", "android.app.PendingIntent", "#EXTRA_PHONE_ACCOUNT_HANDLE", "#EXTRA_NOTIFICATION_COUNT" ]
  }, {
    "name" : "EXTRA_PHONE_ACCOUNT_HANDLE",
    "type" : "String",
    "comment" : "\n     * The extra used with an {@link #ACTION_CONFIGURE_VOICEMAIL} and\n     * {@link #ACTION_SHOW_VOICEMAIL_NOTIFICATION} {@code Intent} to specify the\n     * {@link PhoneAccountHandle} the configuration or notification is for.\n     * <p class=\"note\">\n     * Retrieve with {@link android.content.Intent#getParcelableExtra(String)}.\n     ",
    "links" : [ "android.telecom.PhoneAccountHandle", "#ACTION_SHOW_VOICEMAIL_NOTIFICATION", "android.content.Intent#getParcelableExtra(String)", "#ACTION_CONFIGURE_VOICEMAIL" ]
  }, {
    "name" : "EXTRA_NOTIFICATION_COUNT",
    "type" : "String",
    "comment" : "\n     * The number of voice messages associated with the notification.\n     ",
    "links" : [ ]
  }, {
    "name" : "EXTRA_VOICEMAIL_NUMBER",
    "type" : "String",
    "comment" : "\n     * The voicemail number.\n     ",
    "links" : [ ]
  }, {
    "name" : "EXTRA_CALL_VOICEMAIL_INTENT",
    "type" : "String",
    "comment" : "\n     * The intent to call voicemail.\n     ",
    "links" : [ ]
  }, {
    "name" : "EXTRA_LAUNCH_VOICEMAIL_SETTINGS_INTENT",
    "type" : "String",
    "comment" : "\n     * The intent to launch voicemail settings.\n     ",
    "links" : [ ]
  }, {
    "name" : "EXTRA_IS_REFRESH",
    "type" : "String",
    "comment" : "\n     * Boolean value representing whether the {@link\n     * TelephonyManager#ACTION_SHOW_VOICEMAIL_NOTIFICATION} is new or a refresh of an existing\n     * notification. Notification refresh happens after reboot or connectivity changes. The user has\n     * already been notified for the voicemail so it should not alert the user, and should not be\n     * shown again if the user has dismissed it.\n     ",
    "links" : [ "android.telephony.TelephonyManager#ACTION_SHOW_VOICEMAIL_NOTIFICATION" ]
  }, {
    "name" : "EVENT_HANDOVER_VIDEO_FROM_WIFI_TO_LTE",
    "type" : "String",
    "comment" : "\n     * {@link android.telecom.Connection} event used to indicate that an IMS call has be\n     * successfully handed over from WIFI to LTE.\n     * <p>\n     * Sent via {@link android.telecom.Connection#sendConnectionEvent(String, Bundle)}.\n     * The {@link Bundle} parameter is expected to be null when this connection event is used.\n     * @hide\n     ",
    "links" : [ "android.os.Bundle", "android.telecom.Connection#sendConnectionEvent(String", "android.telecom.Connection" ]
  }, {
    "name" : "EVENT_HANDOVER_VIDEO_FROM_LTE_TO_WIFI",
    "type" : "String",
    "comment" : "\n     * {@link android.telecom.Connection} event used to indicate that an IMS call has be\n     * successfully handed over from LTE to WIFI.\n     * <p>\n     * Sent via {@link android.telecom.Connection#sendConnectionEvent(String, Bundle)}.\n     * The {@link Bundle} parameter is expected to be null when this connection event is used.\n     * @hide\n     ",
    "links" : [ "android.os.Bundle", "android.telecom.Connection#sendConnectionEvent(String", "android.telecom.Connection" ]
  }, {
    "name" : "EVENT_HANDOVER_TO_WIFI_FAILED",
    "type" : "String",
    "comment" : "\n     * {@link android.telecom.Connection} event used to indicate that an IMS call failed to be\n     * handed over from LTE to WIFI.\n     * <p>\n     * Sent via {@link android.telecom.Connection#sendConnectionEvent(String, Bundle)}.\n     * The {@link Bundle} parameter is expected to be null when this connection event is used.\n     * @hide\n     ",
    "links" : [ "android.os.Bundle", "android.telecom.Connection#sendConnectionEvent(String", "android.telecom.Connection" ]
  }, {
    "name" : "EVENT_DOWNGRADE_DATA_LIMIT_REACHED",
    "type" : "String",
    "comment" : "\n     * {@link android.telecom.Connection} event used to indicate that a video call was downgraded to\n     * audio because the data limit was reached.\n     * <p>\n     * Sent via {@link android.telecom.Connection#sendConnectionEvent(String, Bundle)}.\n     * The {@link Bundle} parameter is expected to be null when this connection event is used.\n     * @hide\n     ",
    "links" : [ "android.os.Bundle", "android.telecom.Connection#sendConnectionEvent(String", "android.telecom.Connection" ]
  }, {
    "name" : "EVENT_DOWNGRADE_DATA_DISABLED",
    "type" : "String",
    "comment" : "\n     * {@link android.telecom.Connection} event used to indicate that a video call was downgraded to\n     * audio because the data was disabled.\n     * <p>\n     * Sent via {@link android.telecom.Connection#sendConnectionEvent(String, Bundle)}.\n     * The {@link Bundle} parameter is expected to be null when this connection event is used.\n     * @hide\n     ",
    "links" : [ "android.os.Bundle", "android.telecom.Connection#sendConnectionEvent(String", "android.telecom.Connection" ]
  }, {
    "name" : "EVENT_NOTIFY_INTERNATIONAL_CALL_ON_WFC",
    "type" : "String",
    "comment" : "\n     * {@link android.telecom.Connection} event used to indicate that the InCall UI should notify\n     * the user when an international call is placed while on WFC only.\n     * <p>\n     * Used when the carrier config value\n     * {@link CarrierConfigManager#KEY_NOTIFY_INTERNATIONAL_CALL_ON_WFC_BOOL} is true, the device\n     * is on WFC (VoLTE not available) and an international number is dialed.\n     * <p>\n     * Sent via {@link android.telecom.Connection#sendConnectionEvent(String, Bundle)}.\n     * The {@link Bundle} parameter is expected to be null when this connection event is used.\n     * @hide\n     ",
    "links" : [ "android.os.Bundle", "android.telephony.CarrierConfigManager#KEY_NOTIFY_INTERNATIONAL_CALL_ON_WFC_BOOL", "android.telecom.Connection#sendConnectionEvent(String", "android.telecom.Connection" ]
  }, {
    "name" : "EVENT_CALL_FORWARDED",
    "type" : "String",
    "comment" : "\n     * {@link android.telecom.Connection} event used to indicate that an outgoing call has been\n     * forwarded to another number.\n     * <p>\n     * Sent in response to an IMS supplementary service notification indicating the call has been\n     * forwarded.\n     * <p>\n     * Sent via {@link android.telecom.Connection#sendConnectionEvent(String, Bundle)}.\n     * The {@link Bundle} parameter is expected to be null when this connection event is used.\n     * @hide\n     ",
    "links" : [ "android.os.Bundle", "android.telecom.Connection#sendConnectionEvent(String", "android.telecom.Connection" ]
  }, {
    "name" : "EVENT_SUPPLEMENTARY_SERVICE_NOTIFICATION",
    "type" : "String",
    "comment" : "\n     * {@link android.telecom.Connection} event used to indicate that a supplementary service\n     * notification has been received.\n     * <p>\n     * Sent via {@link android.telecom.Connection#sendConnectionEvent(String, Bundle)}.\n     * The {@link Bundle} parameter is expected to include the following extras:\n     * <ul>\n     *     <li>{@link #EXTRA_NOTIFICATION_TYPE} - the notification type.</li>\n     *     <li>{@link #EXTRA_NOTIFICATION_CODE} - the notification code.</li>\n     *     <li>{@link #EXTRA_NOTIFICATION_MESSAGE} - human-readable message associated with the\n     *     supplementary service notification.</li>\n     * </ul>\n     * @hide\n     ",
    "links" : [ "android.os.Bundle", "#EXTRA_NOTIFICATION_TYPE", "#EXTRA_NOTIFICATION_MESSAGE", "android.telecom.Connection#sendConnectionEvent(String", "#EXTRA_NOTIFICATION_CODE", "android.telecom.Connection" ]
  }, {
    "name" : "EXTRA_NOTIFICATION_TYPE",
    "type" : "String",
    "comment" : "\n     * Integer extra key used with {@link #EVENT_SUPPLEMENTARY_SERVICE_NOTIFICATION} which indicates\n     * the type of supplementary service notification which occurred.\n     * Will be either\n     * {@link com.android.internal.telephony.gsm.SuppServiceNotification#NOTIFICATION_TYPE_CODE_1}\n     * or\n     * {@link com.android.internal.telephony.gsm.SuppServiceNotification#NOTIFICATION_TYPE_CODE_2}\n     * <p>\n     * Set in the extras for the {@link #EVENT_SUPPLEMENTARY_SERVICE_NOTIFICATION} connection event.\n     * @hide\n     ",
    "links" : [ "com.android.internal.telephony.gsm.SuppServiceNotification#NOTIFICATION_TYPE_CODE_1", "com.android.internal.telephony.gsm.SuppServiceNotification#NOTIFICATION_TYPE_CODE_2", "#EVENT_SUPPLEMENTARY_SERVICE_NOTIFICATION" ]
  }, {
    "name" : "EXTRA_NOTIFICATION_CODE",
    "type" : "String",
    "comment" : "\n     * Integer extra key used with {@link #EVENT_SUPPLEMENTARY_SERVICE_NOTIFICATION} which indicates\n     * the supplementary service notification which occurred.\n     * <p>\n     * Depending on the {@link #EXTRA_NOTIFICATION_TYPE}, the code will be one of the {@code CODE_*}\n     * codes defined in {@link com.android.internal.telephony.gsm.SuppServiceNotification}.\n     * <p>\n     * Set in the extras for the {@link #EVENT_SUPPLEMENTARY_SERVICE_NOTIFICATION} connection event.\n     * @hide\n     ",
    "links" : [ "#EXTRA_NOTIFICATION_TYPE", "com.android.internal.telephony.gsm.SuppServiceNotification", "#EVENT_SUPPLEMENTARY_SERVICE_NOTIFICATION" ]
  }, {
    "name" : "EXTRA_NOTIFICATION_MESSAGE",
    "type" : "String",
    "comment" : "\n     * {@link CharSequence} extra key used with {@link #EVENT_SUPPLEMENTARY_SERVICE_NOTIFICATION}\n     * which contains a human-readable message which can be displayed to the user for the\n     * supplementary service notification.\n     * <p>\n     * Set in the extras for the {@link #EVENT_SUPPLEMENTARY_SERVICE_NOTIFICATION} connection event.\n     * @hide\n     ",
    "links" : [ "CharSequence", "#EVENT_SUPPLEMENTARY_SERVICE_NOTIFICATION" ]
  }, {
    "name" : "VVM_TYPE_OMTP",
    "type" : "String",
    "comment" : "\n     * The OMTP protocol.\n     ",
    "links" : [ ]
  }, {
    "name" : "VVM_TYPE_CVVM",
    "type" : "String",
    "comment" : "\n     * A flavor of OMTP protocol with a different mobile originated (MO) format\n     ",
    "links" : [ ]
  }, {
    "name" : "EXTRA_VISUAL_VOICEMAIL_ENABLED_BY_USER_BOOL",
    "type" : "String",
    "comment" : "\n     * Key in bundle returned by {@link #getVisualVoicemailPackageName()}, indicating whether visual\n     * voicemail was enabled or disabled by the user. If the user never explicitly changed this\n     * setting, this key will not exist.\n     *\n     * @see #getVisualVoicemailSettings()\n     * @hide\n     ",
    "links" : [ "#getVisualVoicemailPackageName()" ]
  }, {
    "name" : "EXTRA_VOICEMAIL_SCRAMBLED_PIN_STRING",
    "type" : "String",
    "comment" : "\n     * Key in bundle returned by {@link #getVisualVoicemailPackageName()}, indicating the voicemail\n     * access PIN scrambled during the auto provisioning process. The user is expected to reset\n     * their PIN if this value is not {@code null}.\n     *\n     * @see #getVisualVoicemailSettings()\n     * @hide\n     ",
    "links" : [ "#getVisualVoicemailPackageName()" ]
  }, {
    "name" : "ACTION_MULTI_SIM_CONFIG_CHANGED",
    "type" : "String",
    "comment" : "\n     * Broadcast action to be received by Broadcast receivers.\n     *\n     * Indicates multi-SIM configuration is changed. For example, it changed\n     * from single SIM capable to dual-SIM capable (DSDS or DSDA) or triple-SIM mode.\n     *\n     * It doesn't indicate how many subscriptions are actually active, or which states SIMs are,\n     * or that all steps during multi-SIM change are done. To know those information you still need\n     * to listen to SIM_STATE changes or active subscription changes.\n     *\n     * See extra of {@link #EXTRA_ACTIVE_SIM_SUPPORTED_COUNT} for updated value.\n     ",
    "links" : [ "#EXTRA_ACTIVE_SIM_SUPPORTED_COUNT" ]
  }, {
    "name" : "EXTRA_ACTIVE_SIM_SUPPORTED_COUNT",
    "type" : "String",
    "comment" : "\n     * The number of active SIM supported by current multi-SIM config. It's not related to how many\n     * SIM/subscriptions are currently active.\n     *\n     * Same value will be returned by {@link #getActiveModemCount()}.\n     *\n     * For single SIM mode, it's 1.\n     * For DSDS or DSDA mode, it's 2.\n     * For triple-SIM mode, it's 3.\n     *\n     * Extra of {@link #ACTION_MULTI_SIM_CONFIG_CHANGED}.\n     *\n     * type: integer\n     ",
    "links" : [ "#getActiveModemCount()", "#ACTION_MULTI_SIM_CONFIG_CHANGED" ]
  }, {
    "name" : "USSD_RESPONSE",
    "type" : "String",
    "comment" : "\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "USSD_RETURN_SUCCESS",
    "type" : "int",
    "comment" : "\n     * USSD return code success.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "USSD_RETURN_FAILURE",
    "type" : "int",
    "comment" : "\n     * Failed code returned when the mobile network has failed to complete a USSD request.\n     * <p>\n     * Returned via {@link TelephonyManager.UssdResponseCallback#onReceiveUssdResponseFailed(\n     * TelephonyManager, String, int)}.\n     ",
    "links" : [ "TelephonyManager.UssdResponseCallback#onReceiveUssdResponseFailed(" ]
  }, {
    "name" : "USSD_ERROR_SERVICE_UNAVAIL",
    "type" : "int",
    "comment" : "\n     * Failure code returned when a USSD request has failed to execute because the Telephony\n     * service is unavailable.\n     * <p>\n     * Returned via {@link TelephonyManager.UssdResponseCallback#onReceiveUssdResponseFailed(\n     * TelephonyManager, String, int)}.\n     ",
    "links" : [ "TelephonyManager.UssdResponseCallback#onReceiveUssdResponseFailed(" ]
  }, {
    "name" : "CDMA_ROAMING_MODE_RADIO_DEFAULT",
    "type" : "int",
    "comment" : "\n     * Value for {@link CarrierConfigManager#KEY_CDMA_ROAMING_MODE_INT} which leaves the roaming\n     * mode set to the radio default or to the user's preference if they've indicated one.\n     ",
    "links" : [ "android.telephony.CarrierConfigManager#KEY_CDMA_ROAMING_MODE_INT" ]
  }, {
    "name" : "CDMA_ROAMING_MODE_HOME",
    "type" : "int",
    "comment" : "\n     * Value for {@link CarrierConfigManager#KEY_CDMA_ROAMING_MODE_INT} which only permits\n     * connections on home networks.\n     ",
    "links" : [ "android.telephony.CarrierConfigManager#KEY_CDMA_ROAMING_MODE_INT" ]
  }, {
    "name" : "CDMA_ROAMING_MODE_AFFILIATED",
    "type" : "int",
    "comment" : "\n     * Value for {@link CarrierConfigManager#KEY_CDMA_ROAMING_MODE_INT} which permits roaming on\n     * affiliated networks.\n     ",
    "links" : [ "android.telephony.CarrierConfigManager#KEY_CDMA_ROAMING_MODE_INT" ]
  }, {
    "name" : "CDMA_ROAMING_MODE_ANY",
    "type" : "int",
    "comment" : "\n     * Value for {@link CarrierConfigManager#KEY_CDMA_ROAMING_MODE_INT} which permits roaming on\n     * any network.\n     ",
    "links" : [ "android.telephony.CarrierConfigManager#KEY_CDMA_ROAMING_MODE_INT" ]
  }, {
    "name" : "UNKNOWN_CARRIER_ID",
    "type" : "int",
    "comment" : "\n     * An unknown carrier id. It could either be subscription unavailable or the subscription\n     * carrier cannot be recognized. Unrecognized carriers here means\n     * {@link #getSimOperator() MCC+MNC} cannot be identified.\n     ",
    "links" : [ "#getSimOperator()" ]
  }, {
    "name" : "UNKNOWN_CARRIER_ID_LIST_VERSION",
    "type" : "int",
    "comment" : "\n     * An unknown carrier id list version.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "ACTION_SUBSCRIPTION_CARRIER_IDENTITY_CHANGED",
    "type" : "String",
    "comment" : "\n     * Broadcast Action: The subscription carrier identity has changed.\n     * This intent could be sent on the following events:\n     * <ul>\n     *   <li>Subscription absent. Carrier identity could change from a valid id to\n     *   {@link TelephonyManager#UNKNOWN_CARRIER_ID}.</li>\n     *   <li>Subscription loaded. Carrier identity could change from\n     *   {@link TelephonyManager#UNKNOWN_CARRIER_ID} to a valid id.</li>\n     *   <li>The subscription carrier is recognized after a remote update.</li>\n     * </ul>\n     * The intent will have the following extra values:\n     * <ul>\n     *   <li>{@link #EXTRA_CARRIER_ID} The up-to-date carrier id of the current subscription id.\n     *   </li>\n     *   <li>{@link #EXTRA_CARRIER_NAME} The up-to-date carrier name of the current subscription.\n     *   </li>\n     *   <li>{@link #EXTRA_SUBSCRIPTION_ID} The subscription id associated with the changed carrier\n     *   identity.\n     *   </li>\n     * </ul>\n     * <p class=\"note\">This is a protected intent that can only be sent by the system.\n     ",
    "links" : [ "android.telephony.TelephonyManager#UNKNOWN_CARRIER_ID", "#EXTRA_CARRIER_NAME", "#EXTRA_SUBSCRIPTION_ID", "#EXTRA_CARRIER_ID" ]
  }, {
    "name" : "EXTRA_CARRIER_ID",
    "type" : "String",
    "comment" : "\n     * An int extra used with {@link #ACTION_SUBSCRIPTION_CARRIER_IDENTITY_CHANGED} which indicates\n     * the updated carrier id returned by {@link TelephonyManager#getSimCarrierId()}.\n     * <p>Will be {@link TelephonyManager#UNKNOWN_CARRIER_ID} if the subscription is unavailable or\n     * the carrier cannot be identified.\n     ",
    "links" : [ "android.telephony.TelephonyManager#UNKNOWN_CARRIER_ID", "android.telephony.TelephonyManager#getSimCarrierId()", "#ACTION_SUBSCRIPTION_CARRIER_IDENTITY_CHANGED" ]
  }, {
    "name" : "EXTRA_CARRIER_NAME",
    "type" : "String",
    "comment" : "\n     * An string extra used with {@link #ACTION_SUBSCRIPTION_CARRIER_IDENTITY_CHANGED} which\n     * indicates the updated carrier name of the current subscription.\n     * @see TelephonyManager#getSimCarrierIdName()\n     * <p>Carrier name is a user-facing name of the carrier id {@link #EXTRA_CARRIER_ID},\n     * usually the brand name of the subsidiary (e.g. T-Mobile).\n     ",
    "links" : [ "#ACTION_SUBSCRIPTION_CARRIER_IDENTITY_CHANGED", "#EXTRA_CARRIER_ID" ]
  }, {
    "name" : "ACTION_SUBSCRIPTION_SPECIFIC_CARRIER_IDENTITY_CHANGED",
    "type" : "String",
    "comment" : "\n     * Broadcast Action: The subscription specific carrier identity has changed.\n     *\n     * A specific carrier ID returns the fine-grained carrier ID of the current subscription.\n     * It can represent the fact that a carrier may be in effect an aggregation of other carriers\n     * (ie in an MVNO type scenario) where each of these specific carriers which are used to make\n     * up the actual carrier service may have different carrier configurations.\n     * A specific carrier ID could also be used, for example, in a scenario where a carrier requires\n     * different carrier configuration for different service offering such as a prepaid plan.\n     *\n     * the specific carrier ID would be used for configuration purposes, but apps wishing to know\n     * about the carrier itself should use the regular carrier ID returned by\n     * {@link #getSimCarrierId()}.\n     *\n     * <p>Similar like {@link #ACTION_SUBSCRIPTION_CARRIER_IDENTITY_CHANGED}, this intent will be\n     * sent on the event of {@link #ACTION_SUBSCRIPTION_CARRIER_IDENTITY_CHANGED} while its also\n     * possible to be sent without {@link #ACTION_SUBSCRIPTION_CARRIER_IDENTITY_CHANGED} when\n     * specific carrier ID changes while carrier ID remains the same.\n     * e.g, the same subscription switches to different IMSI could potentially change its\n     * specific carrier ID while carrier id remains the same.\n     * @see #getSimSpecificCarrierId()\n     * @see #getSimCarrierId()\n     *\n     * The intent will have the following extra values:\n     * <ul>\n     *   <li>{@link #EXTRA_SPECIFIC_CARRIER_ID} The up-to-date specific carrier id of the\n     *   current subscription.\n     *   </li>\n     *   <li>{@link #EXTRA_SPECIFIC_CARRIER_NAME} The up-to-date name of the specific carrier id.\n     *   </li>\n     *   <li>{@link #EXTRA_SUBSCRIPTION_ID} The subscription id associated with the changed carrier\n     *   identity.\n     *   </li>\n     * </ul>\n     * <p class=\"note\">This is a protected intent that can only be sent by the system.\n     ",
    "links" : [ "#EXTRA_SPECIFIC_CARRIER_ID", "#EXTRA_SPECIFIC_CARRIER_NAME", "#EXTRA_SUBSCRIPTION_ID", "#ACTION_SUBSCRIPTION_CARRIER_IDENTITY_CHANGED", "#getSimCarrierId()" ]
  }, {
    "name" : "EXTRA_SPECIFIC_CARRIER_ID",
    "type" : "String",
    "comment" : "\n     * An int extra used with {@link #ACTION_SUBSCRIPTION_SPECIFIC_CARRIER_IDENTITY_CHANGED} which\n     * indicates the updated specific carrier id returned by\n     * {@link TelephonyManager#getSimSpecificCarrierId()}. Note, its possible specific carrier id\n     * changes while {@link #ACTION_SUBSCRIPTION_CARRIER_IDENTITY_CHANGED} remains the same\n     * e.g, when subscription switch to different IMSIs.\n     * <p>Will be {@link TelephonyManager#UNKNOWN_CARRIER_ID} if the subscription is unavailable or\n     * the carrier cannot be identified.\n     ",
    "links" : [ "android.telephony.TelephonyManager#UNKNOWN_CARRIER_ID", "#ACTION_SUBSCRIPTION_SPECIFIC_CARRIER_IDENTITY_CHANGED", "android.telephony.TelephonyManager#getSimSpecificCarrierId()", "#ACTION_SUBSCRIPTION_CARRIER_IDENTITY_CHANGED" ]
  }, {
    "name" : "EXTRA_SPECIFIC_CARRIER_NAME",
    "type" : "String",
    "comment" : "\n     * An string extra used with {@link #ACTION_SUBSCRIPTION_SPECIFIC_CARRIER_IDENTITY_CHANGED}\n     * which indicates the updated specific carrier name returned by\n     * {@link TelephonyManager#getSimSpecificCarrierIdName()}.\n     * <p>it's a user-facing name of the specific carrier id {@link #EXTRA_SPECIFIC_CARRIER_ID}\n     * e.g, Tracfone-AT&T\n     ",
    "links" : [ "#EXTRA_SPECIFIC_CARRIER_ID", "#ACTION_SUBSCRIPTION_SPECIFIC_CARRIER_IDENTITY_CHANGED", "android.telephony.TelephonyManager#getSimSpecificCarrierIdName()" ]
  }, {
    "name" : "EXTRA_SUBSCRIPTION_ID",
    "type" : "String",
    "comment" : "\n     * An int extra used with {@link #ACTION_SUBSCRIPTION_CARRIER_IDENTITY_CHANGED} to indicate the\n     * subscription which has changed; or in general whenever a subscription ID needs specified.\n     ",
    "links" : [ "#ACTION_SUBSCRIPTION_CARRIER_IDENTITY_CHANGED" ]
  }, {
    "name" : "ACTION_SERVICE_PROVIDERS_UPDATED",
    "type" : "String",
    "comment" : "\n     * Broadcast Action: The Service Provider string(s) have been updated. Activities or\n     * services that use these strings should update their display.\n     *\n     * <p>The intent will have the following extra values:\n     * <dl>\n     *   <dt>{@link #EXTRA_SHOW_PLMN}</dt>\n     *   <dd>Boolean that indicates whether the PLMN should be shown.</dd>\n     *   <dt>{@link #EXTRA_PLMN}</dt>\n     *   <dd>The operator name of the registered network, as a string.</dd>\n     *   <dt>{@link #EXTRA_SHOW_SPN}</dt>\n     *   <dd>Boolean that indicates whether the SPN should be shown.</dd>\n     *   <dt>{@link #EXTRA_SPN}</dt>\n     *   <dd>The service provider name, as a string.</dd>\n     *   <dt>{@link #EXTRA_DATA_SPN}</dt>\n     *   <dd>The service provider name for data service, as a string.</dd>\n     * </dl>\n     *\n     * Note that {@link #EXTRA_SHOW_PLMN} may indicate that {@link #EXTRA_PLMN} should be displayed,\n     * even though the value for {@link #EXTRA_PLMN} is null. This can happen, for example, if the\n     * phone has not registered to a network yet. In this case the receiver may substitute an\n     * appropriate placeholder string (eg, \"No service\").\n     *\n     * It is recommended to display {@link #EXTRA_PLMN} before / above {@link #EXTRA_SPN} if\n     * both are displayed.\n     *\n     * <p>Note: this is a protected intent that can only be sent by the system.\n     * @hide\n     ",
    "links" : [ "#EXTRA_SPN", "#EXTRA_PLMN", "#EXTRA_SHOW_PLMN", "#EXTRA_DATA_SPN", "#EXTRA_SHOW_SPN" ]
  }, {
    "name" : "EXTRA_SHOW_PLMN",
    "type" : "String",
    "comment" : "\n     * String intent extra to be used with {@link ACTION_SERVICE_PROVIDERS_UPDATED} to indicate\n     * whether the PLMN should be shown.\n     * @hide\n     ",
    "links" : [ "ACTION_SERVICE_PROVIDERS_UPDATED" ]
  }, {
    "name" : "EXTRA_PLMN",
    "type" : "String",
    "comment" : "\n     * String intent extra to be used with {@link ACTION_SERVICE_PROVIDERS_UPDATED} to indicate\n     * the operator name of the registered network.\n     * @hide\n     ",
    "links" : [ "ACTION_SERVICE_PROVIDERS_UPDATED" ]
  }, {
    "name" : "EXTRA_SHOW_SPN",
    "type" : "String",
    "comment" : "\n     * String intent extra to be used with {@link ACTION_SERVICE_PROVIDERS_UPDATED} to indicate\n     * whether the PLMN should be shown.\n     * @hide\n     ",
    "links" : [ "ACTION_SERVICE_PROVIDERS_UPDATED" ]
  }, {
    "name" : "EXTRA_SPN",
    "type" : "String",
    "comment" : "\n     * String intent extra to be used with {@link ACTION_SERVICE_PROVIDERS_UPDATED} to indicate\n     * the service provider name.\n     * @hide\n     ",
    "links" : [ "ACTION_SERVICE_PROVIDERS_UPDATED" ]
  }, {
    "name" : "EXTRA_DATA_SPN",
    "type" : "String",
    "comment" : "\n     * String intent extra to be used with {@link ACTION_SERVICE_PROVIDERS_UPDATED} to indicate\n     * the service provider name for data service.\n     * @hide\n     ",
    "links" : [ "ACTION_SERVICE_PROVIDERS_UPDATED" ]
  }, {
    "name" : "ACTION_DATA_STALL_DETECTED",
    "type" : "String",
    "comment" : " TODO(b/78370030) : Restrict this to system applications only",
    "links" : [ ]
  }, {
    "name" : "ACTION_CARRIER_MESSAGING_CLIENT_SERVICE",
    "type" : "String",
    "comment" : "\n     * A service action that identifies\n     * a {@link android.service.carrier.CarrierMessagingClientService} subclass in the\n     * AndroidManifest.xml.\n     *\n     * <p>See {@link android.service.carrier.CarrierMessagingClientService} for the details.\n     ",
    "links" : [ "android.service.carrier.CarrierMessagingClientService" ]
  }, {
    "name" : "EXTRA_RECOVERY_ACTION",
    "type" : "String",
    "comment" : "\n     * An int extra used with {@link #ACTION_DATA_STALL_DETECTED} to indicate the\n     * action associated with the data stall recovery.\n     *\n     * @see #ACTION_DATA_STALL_DETECTED\n     *\n     * @hide\n     ",
    "links" : [ "#ACTION_DATA_STALL_DETECTED" ]
  }, {
    "name" : "MAX_NUMBER_VERIFICATION_TIMEOUT_MILLIS",
    "type" : "long",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "ACTION_ANOMALY_REPORTED",
    "type" : "String",
    "comment" : "\n     * Intent sent when an error occurs that debug tools should log and possibly take further\n     * action such as capturing vendor-specific logs.\n     *\n     * A privileged application that reads these events should take appropriate vendor-specific\n     * action to record the event and collect further information to assist in analysis, debugging,\n     * and resolution of any associated issue.\n     *\n     * <p>This event should not be used for generic logging or diagnostic monitoring purposes and\n     * should generally be sent at a low rate. Instead, this mechanism should be used for the\n     * framework to notify a debugging application that an event (such as a bug) has occured\n     * within the framework if that event should trigger the collection and preservation of other\n     * more detailed device state for debugging.\n     *\n     * <p>At most one application can receive these events and should register a receiver in\n     * in the application manifest. For performance reasons, if no application to receive these\n     * events is detected at boot, then these events will not be sent.\n     *\n     * <p>Each event will include an {@link EXTRA_ANOMALY_ID} that will uniquely identify the\n     * event that has occurred. Each event will be sent to the diagnostic monitor only once per\n     * boot cycle (as another optimization).\n     *\n     * @see #EXTRA_ANOMALY_ID\n     * @see #EXTRA_ANOMALY_DESCRIPTION\n     * @hide\n     ",
    "links" : [ "EXTRA_ANOMALY_ID" ]
  }, {
    "name" : "EXTRA_ANOMALY_ID",
    "type" : "String",
    "comment" : "\n     * An arbitrary ParcelUuid which should be consistent for each occurrence of a DebugEvent.\n     *\n     * This field must be included in all {@link ACTION_ANOMALY_REPORTED} events.\n     *\n     * @see #ACTION_ANOMALY_REPORTED\n     * @hide\n     ",
    "links" : [ "ACTION_ANOMALY_REPORTED" ]
  }, {
    "name" : "EXTRA_ANOMALY_DESCRIPTION",
    "type" : "String",
    "comment" : "\n     * A freeform string description of the Anomaly.\n     *\n     * This field is optional for all {@link ACTION_ANOMALY_REPORTED}s, as a guideline should not\n     * exceed 80 characters, and should be as short as possible to convey the essence of the event.\n     *\n     * @see #ACTION_ANOMALY_REPORTED\n     * @hide\n     ",
    "links" : [ "ACTION_ANOMALY_REPORTED" ]
  }, {
    "name" : "ACTION_PRIMARY_SUBSCRIPTION_LIST_CHANGED",
    "type" : "String",
    "comment" : "\n     * Broadcast intent sent to indicate primary (non-opportunistic) subscription list has changed.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "EXTRA_DEFAULT_SUBSCRIPTION_SELECT_TYPE",
    "type" : "String",
    "comment" : "\n     * Integer intent extra to be used with {@link #ACTION_PRIMARY_SUBSCRIPTION_LIST_CHANGED}\n     * to indicate what type of SIM selection is needed.\n     *\n     * @hide\n     ",
    "links" : [ "#ACTION_PRIMARY_SUBSCRIPTION_LIST_CHANGED" ]
  }, {
    "name" : "EXTRA_DEFAULT_SUBSCRIPTION_SELECT_TYPE_NONE",
    "type" : "int",
    "comment" : "\n     * Used as an int value for {@link #EXTRA_DEFAULT_SUBSCRIPTION_SELECT_TYPE}\n     * to indicate there's no need to re-select any default subscription.\n     * @hide\n     ",
    "links" : [ "#EXTRA_DEFAULT_SUBSCRIPTION_SELECT_TYPE" ]
  }, {
    "name" : "EXTRA_DEFAULT_SUBSCRIPTION_SELECT_TYPE_DATA",
    "type" : "int",
    "comment" : "\n     * Used as an int value for {@link #EXTRA_DEFAULT_SUBSCRIPTION_SELECT_TYPE}\n     * to indicate there's a need to select default data subscription.\n     * @hide\n     ",
    "links" : [ "#EXTRA_DEFAULT_SUBSCRIPTION_SELECT_TYPE" ]
  }, {
    "name" : "EXTRA_DEFAULT_SUBSCRIPTION_SELECT_TYPE_VOICE",
    "type" : "int",
    "comment" : "\n     * Used as an int value for {@link #EXTRA_DEFAULT_SUBSCRIPTION_SELECT_TYPE}\n     * to indicate there's a need to select default voice call subscription.\n     * @hide\n     ",
    "links" : [ "#EXTRA_DEFAULT_SUBSCRIPTION_SELECT_TYPE" ]
  }, {
    "name" : "EXTRA_DEFAULT_SUBSCRIPTION_SELECT_TYPE_SMS",
    "type" : "int",
    "comment" : "\n     * Used as an int value for {@link #EXTRA_DEFAULT_SUBSCRIPTION_SELECT_TYPE}\n     * to indicate there's a need to select default sms subscription.\n     * @hide\n     ",
    "links" : [ "#EXTRA_DEFAULT_SUBSCRIPTION_SELECT_TYPE" ]
  }, {
    "name" : "EXTRA_DEFAULT_SUBSCRIPTION_SELECT_TYPE_ALL",
    "type" : "int",
    "comment" : "\n     * Used as an int value for {@link #EXTRA_DEFAULT_SUBSCRIPTION_SELECT_TYPE}\n     * to indicate user to decide whether current SIM should be preferred for all\n     * data / voice / sms. {@link #EXTRA_SUBSCRIPTION_ID} will specified to indicate\n     * which subscription should be the default subscription.\n     * @hide\n     ",
    "links" : [ "#EXTRA_SUBSCRIPTION_ID", "#EXTRA_DEFAULT_SUBSCRIPTION_SELECT_TYPE" ]
  }, {
    "name" : "EXTRA_SIM_COMBINATION_WARNING_TYPE",
    "type" : "String",
    "comment" : "\n     * Integer intent extra to be used with {@link #ACTION_PRIMARY_SUBSCRIPTION_LIST_CHANGED}\n     * to indicate if the SIM combination in DSDS has limitation or compatible issue.\n     * e.g. two CDMA SIMs may disrupt each other's voice call in certain scenarios.\n     *\n     * @hide\n     ",
    "links" : [ "#ACTION_PRIMARY_SUBSCRIPTION_LIST_CHANGED" ]
  }, {
    "name" : "EXTRA_SIM_COMBINATION_WARNING_TYPE_NONE",
    "type" : "int",
    "comment" : "\n     * Used as an int value for {@link #EXTRA_DEFAULT_SUBSCRIPTION_SELECT_TYPE}\n     * to indicate there's no SIM combination warning.\n     * @hide\n     ",
    "links" : [ "#EXTRA_DEFAULT_SUBSCRIPTION_SELECT_TYPE" ]
  }, {
    "name" : "EXTRA_SIM_COMBINATION_WARNING_TYPE_DUAL_CDMA",
    "type" : "int",
    "comment" : "\n     * Used as an int value for {@link #EXTRA_DEFAULT_SUBSCRIPTION_SELECT_TYPE}\n     * to indicate two active SIMs are both CDMA hence there might be functional limitation.\n     * @hide\n     ",
    "links" : [ "#EXTRA_DEFAULT_SUBSCRIPTION_SELECT_TYPE" ]
  }, {
    "name" : "EXTRA_SIM_COMBINATION_NAMES",
    "type" : "String",
    "comment" : "\n     * String intent extra to be used with {@link #ACTION_PRIMARY_SUBSCRIPTION_LIST_CHANGED}\n     * to indicate what's the name of SIM combination it has limitation or compatible issue.\n     * e.g. two CDMA SIMs may disrupt each other's voice call in certain scenarios, and the\n     * name will be \"operator1 & operator2\".\n     *\n     * @hide\n     ",
    "links" : [ "#ACTION_PRIMARY_SUBSCRIPTION_LIST_CHANGED" ]
  }, {
    "name" : "ACTION_EMERGENCY_CALLBACK_MODE_CHANGED",
    "type" : "String",
    "comment" : "\n     * <p>Broadcast Action: The emergency callback mode is changed.\n     * <ul>\n     *   <li><em>EXTRA_PHONE_IN_ECM_STATE</em> - A boolean value,true=phone in ECM,\n     *   false=ECM off</li>\n     * </ul>\n     * <p class=\"note\">\n     * You can <em>not</em> receive this through components declared\n     * in manifests, only by explicitly registering for it with\n     * {@link android.content.Context#registerReceiver(android.content.BroadcastReceiver,\n     * android.content.IntentFilter) Context.registerReceiver()}.\n     *\n     * <p class=\"note\">This is a protected intent that can only be sent by the system.\n     *\n     * @see #EXTRA_PHONE_IN_ECM_STATE\n     *\n     * @hide\n     ",
    "links" : [ "android.content.Context#registerReceiver(android.content.BroadcastReceiver" ]
  }, {
    "name" : "EXTRA_PHONE_IN_ECM_STATE",
    "type" : "String",
    "comment" : "\n     * Extra included in {@link #ACTION_EMERGENCY_CALLBACK_MODE_CHANGED}.\n     * Indicates whether the phone is in an emergency phone state.\n     *\n     * @hide\n     ",
    "links" : [ "#ACTION_EMERGENCY_CALLBACK_MODE_CHANGED" ]
  }, {
    "name" : "ACTION_CARRIER_SIGNAL_REDIRECTED",
    "type" : "String",
    "comment" : "\n     * <p>Broadcast Action: when data connections get redirected with validation failure.\n     * intended for sim/account status checks and only sent to the specified carrier app\n     * The intent will have the following extra values:</p>\n     * <ul>\n     *   <li>{@link #EXTRA_APN_TYPE}</li><dd>A string with the apn type.</dd>\n     *   <li>{@link #EXTRA_APN_TYPE_INT}</li><dd>A integer with the apn type.</dd>\n     *   <li>{@link #EXTRA_REDIRECTION_URL}</li><dd>redirection url string</dd>\n     *   <li>subId</li><dd>Sub Id which associated the data connection failure.</dd>\n     * </ul>\n     * <p class=\"note\">This is a protected intent that can only be sent by the system.</p>\n     * @hide\n     ",
    "links" : [ "#EXTRA_APN_TYPE_INT", "#EXTRA_APN_TYPE", "#EXTRA_REDIRECTION_URL" ]
  }, {
    "name" : "ACTION_CARRIER_SIGNAL_REQUEST_NETWORK_FAILED",
    "type" : "String",
    "comment" : "\n     * <p>Broadcast Action: when data connections setup fails.\n     * intended for sim/account status checks and only sent to the specified carrier app\n     * The intent will have the following extra values:</p>\n     * <ul>\n     *   <li>{@link #EXTRA_APN_TYPE}</li><dd>A string with the apn type.</dd>\n     *   <li>{@link #EXTRA_APN_TYPE_INT}</li><dd>A integer with the apn type.</dd>\n     *   <li>{@link #EXTRA_ERROR_CODE}</li><dd>A integer with dataFailCause.</dd>\n     *   <li>subId</li><dd>Sub Id which associated the data connection failure.</dd>\n     * </ul>\n     * <p class=\"note\">This is a protected intent that can only be sent by the system. </p>\n     * @hide\n     ",
    "links" : [ "#EXTRA_APN_TYPE_INT", "#EXTRA_APN_TYPE", "#EXTRA_ERROR_CODE" ]
  }, {
    "name" : "ACTION_CARRIER_SIGNAL_PCO_VALUE",
    "type" : "String",
    "comment" : "\n     * <p>Broadcast Action: when pco value is available.\n     * intended for sim/account status checks and only sent to the specified carrier app\n     * The intent will have the following extra values:</p>\n     * <ul>\n     *   <li>{@link #EXTRA_APN_TYPE}</li><dd>A string with the apn type.</dd>\n     *   <li>{@link #EXTRA_APN_TYPE_INT}</li><dd>A integer with the apn type.</dd>\n     *   <li>{@link #EXTRA_APN_PROTOCOL}</li><dd>A string with the protocol of the apn connection\n     *      (IP,IPV6, IPV4V6)</dd>\n     *   <li>{@link #EXTRA_APN_PROTOCOL_INT}</li><dd>A integer with the protocol of the apn\n     *      connection (IP,IPV6, IPV4V6)</dd>\n     *   <li>{@link #EXTRA_PCO_ID}</li><dd>An integer indicating the pco id for the data.</dd>\n     *   <li>{@link #EXTRA_PCO_VALUE}</li><dd>A byte array of pco data read from modem.</dd>\n     *   <li>subId</li><dd>Sub Id which associated the data connection.</dd>\n     * </ul>\n     * <p class=\"note\">This is a protected intent that can only be sent by the system. </p>\n     * @hide\n     ",
    "links" : [ "#EXTRA_PCO_VALUE", "#EXTRA_PCO_ID", "#EXTRA_APN_TYPE_INT", "#EXTRA_APN_PROTOCOL", "#EXTRA_APN_PROTOCOL_INT", "#EXTRA_APN_TYPE" ]
  }, {
    "name" : "ACTION_CARRIER_SIGNAL_DEFAULT_NETWORK_AVAILABLE",
    "type" : "String",
    "comment" : "\n     * <p>Broadcast Action: when system default network available/unavailable with\n     * carrier-disabled mobile data. Intended for carrier apps to set/reset carrier actions when\n     * other network becomes system default network, Wi-Fi for example.\n     * The intent will have the following extra values:</p>\n     * <ul>\n     *   <li>{@link #EXTRA_DEFAULT_NETWORK_AVAILABLE}</li>\n     *   <dd>A boolean indicates default network available.</dd>\n     *   <li>subId</li><dd>Sub Id which associated the default data.</dd>\n     * </ul>\n     * <p class=\"note\">This is a protected intent that can only be sent by the system. </p>\n     * @hide\n     ",
    "links" : [ "#EXTRA_DEFAULT_NETWORK_AVAILABLE" ]
  }, {
    "name" : "ACTION_CARRIER_SIGNAL_RESET",
    "type" : "String",
    "comment" : "\n     * <p>Broadcast Action: when framework reset all carrier actions on sim load or absent.\n     * intended for carrier apps clean up (clear UI e.g.) and only sent to the specified carrier app\n     * The intent will have the following extra values:</p>\n     * <ul>\n     *   <li>subId</li><dd>Sub Id which associated the data connection failure.</dd>\n     * </ul>\n     * <p class=\"note\">This is a protected intent that can only be sent by the system.</p>\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "EXTRA_REDIRECTION_URL",
    "type" : "String",
    "comment" : "\n     *  An string extra of redirected url upon {@link #ACTION_CARRIER_SIGNAL_REDIRECTED}.\n     *  @hide\n     ",
    "links" : [ "#ACTION_CARRIER_SIGNAL_REDIRECTED" ]
  }, {
    "name" : "EXTRA_ERROR_CODE",
    "type" : "String",
    "comment" : "\n     *  An integer extra of error code upon {@link #ACTION_CARRIER_SIGNAL_REQUEST_NETWORK_FAILED}.\n     *  Check {@link DataFailCause} for all possible values.\n     *  @hide\n     ",
    "links" : [ "#ACTION_CARRIER_SIGNAL_REQUEST_NETWORK_FAILED", "android.telephony.DataFailCause" ]
  }, {
    "name" : "EXTRA_APN_TYPE",
    "type" : "String",
    "comment" : "\n     *  An string extra of corresponding apn type upon\n     *  {@link #ACTION_CARRIER_SIGNAL_REQUEST_NETWORK_FAILED},\n     *  {@link #ACTION_CARRIER_SIGNAL_REDIRECTED} and\n     *  {@link #ACTION_CARRIER_SIGNAL_PCO_VALUE} broadcasts.\n     *  @deprecated This is kept for backward compatibility reason. Use {@link #EXTRA_APN_TYPE_INT}\n     *  instead.\n     *\n     *  @hide\n     ",
    "links" : [ "#ACTION_CARRIER_SIGNAL_REQUEST_NETWORK_FAILED", "#EXTRA_APN_TYPE_INT", "#ACTION_CARRIER_SIGNAL_REDIRECTED", "#ACTION_CARRIER_SIGNAL_PCO_VALUE" ]
  }, {
    "name" : "EXTRA_APN_TYPE_INT",
    "type" : "String",
    "comment" : "\n     *  An string integer of corresponding apn type upon\n     *  {@link #ACTION_CARRIER_SIGNAL_REQUEST_NETWORK_FAILED},\n     *  {@link #ACTION_CARRIER_SIGNAL_REDIRECTED} and\n     *  {@link #ACTION_CARRIER_SIGNAL_PCO_VALUE} broadcasts.\n     *  Check {@link ApnSetting} TYPE_* for its values.\n     *  @hide\n     ",
    "links" : [ "android.telephony.data.ApnSetting", "#ACTION_CARRIER_SIGNAL_REQUEST_NETWORK_FAILED", "#ACTION_CARRIER_SIGNAL_REDIRECTED", "#ACTION_CARRIER_SIGNAL_PCO_VALUE" ]
  }, {
    "name" : "EXTRA_APN_PROTOCOL",
    "type" : "String",
    "comment" : "\n     *  An string extra with the protocol of the apn connection (IP,IPV6, IPV4V6) upon\n     *  {@link #ACTION_CARRIER_SIGNAL_PCO_VALUE} broadcasts.\n     *  @deprecated This is kept for backward compatibility reason.\n     *  Use {@link #EXTRA_APN_PROTOCOL_INT} instead.\n     *\n     *  @hide\n     ",
    "links" : [ "#EXTRA_APN_PROTOCOL_INT", "#ACTION_CARRIER_SIGNAL_PCO_VALUE" ]
  }, {
    "name" : "EXTRA_APN_PROTOCOL_INT",
    "type" : "String",
    "comment" : "\n     *  An integer extra with the protocol of the apn connection (IP,IPV6, IPV4V6) upon\n     *  {@link #ACTION_CARRIER_SIGNAL_PCO_VALUE} broadcasts.\n     *  Check {@link ApnSetting} PROTOCOL_* for its values.\n     *  @hide\n     ",
    "links" : [ "android.telephony.data.ApnSetting", "#ACTION_CARRIER_SIGNAL_PCO_VALUE" ]
  }, {
    "name" : "EXTRA_PCO_ID",
    "type" : "String",
    "comment" : "\n     *  An integer extra indicating the pco id for the data upon\n     *  {@link #ACTION_CARRIER_SIGNAL_PCO_VALUE} broadcasts.\n     *  @hide\n     ",
    "links" : [ "#ACTION_CARRIER_SIGNAL_PCO_VALUE" ]
  }, {
    "name" : "EXTRA_PCO_VALUE",
    "type" : "String",
    "comment" : "\n     *  An extra of byte array of pco data read from modem upon\n     *  {@link #ACTION_CARRIER_SIGNAL_PCO_VALUE} broadcasts.\n     *  @hide\n     ",
    "links" : [ "#ACTION_CARRIER_SIGNAL_PCO_VALUE" ]
  }, {
    "name" : "EXTRA_DEFAULT_NETWORK_AVAILABLE",
    "type" : "String",
    "comment" : "\n     *  An boolean extra indicating default network available upon\n     *  {@link #ACTION_CARRIER_SIGNAL_DEFAULT_NETWORK_AVAILABLE} broadcasts.\n     *  @hide\n     ",
    "links" : [ "#ACTION_CARRIER_SIGNAL_DEFAULT_NETWORK_AVAILABLE" ]
  }, {
    "name" : "ACTION_EMERGENCY_CALL_STATE_CHANGED",
    "type" : "String",
    "comment" : "\n     * <p>Broadcast Action: The emergency call state is changed.\n     * <ul>\n     *   <li><em>EXTRA_PHONE_IN_EMERGENCY_CALL</em> - A boolean value, true if phone in emergency\n     *   call, false otherwise</li>\n     * </ul>\n     * <p class=\"note\">\n     * You can <em>not</em> receive this through components declared\n     * in manifests, only by explicitly registering for it with\n     * {@link android.content.Context#registerReceiver(android.content.BroadcastReceiver,\n     * android.content.IntentFilter) Context.registerReceiver()}.\n     *\n     * <p class=\"note\">This is a protected intent that can only be sent by the system.\n     *\n     * @see #EXTRA_PHONE_IN_EMERGENCY_CALL\n     *\n     * @hide\n     ",
    "links" : [ "android.content.Context#registerReceiver(android.content.BroadcastReceiver" ]
  }, {
    "name" : "EXTRA_PHONE_IN_EMERGENCY_CALL",
    "type" : "String",
    "comment" : "\n     * Extra included in {@link #ACTION_EMERGENCY_CALL_STATE_CHANGED}.\n     * It indicates whether the phone is making an emergency call.\n     *\n     * @hide\n     ",
    "links" : [ "#ACTION_EMERGENCY_CALL_STATE_CHANGED" ]
  }, {
    "name" : "ACTION_SHOW_NOTICE_ECM_BLOCK_OTHERS",
    "type" : "String",
    "comment" : "\n     * <p>Broadcast Action: It indicates the Emergency callback mode blocks datacall/sms\n     * <p class=\"note\">.\n     * This is to pop up a notice to show user that the phone is in emergency callback mode\n     * and data calls and outgoing sms are blocked.\n     *\n     * <p class=\"note\">This is a protected intent that can only be sent by the system.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "ACTION_DEFAULT_DATA_SUBSCRIPTION_CHANGED",
    "type" : "String",
    "comment" : "\n     * Broadcast Action: The default data subscription has changed in a multi-SIM device.\n     * This has the following extra values:</p>\n     * <ul>\n     *   <li><em>subscription</em> - A int, the current data default subscription.</li>\n     * </ul>\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "ACTION_DEFAULT_VOICE_SUBSCRIPTION_CHANGED",
    "type" : "String",
    "comment" : "\n     * Broadcast Action: The default voice subscription has changed in a mult-SIm device.\n     * This has the following extra values:</p>\n     * <ul>\n     *   <li><em>subscription</em> - A int, the current voice default subscription.</li>\n     * </ul>\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "ACTION_REQUEST_OMADM_CONFIGURATION_UPDATE",
    "type" : "String",
    "comment" : "\n     * Broadcast Action: This triggers a client initiated OMA-DM session to the OMA server.\n     * <p class=\"note\">\n     * Open Mobile Alliance (OMA) Device Management (DM).\n     *\n     * This intent is used by the system components to trigger OMA-DM\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "PHONE_TYPE_NONE",
    "type" : "int",
    "comment" : " No phone radio. ",
    "links" : [ ]
  }, {
    "name" : "PHONE_TYPE_GSM",
    "type" : "int",
    "comment" : " Phone radio is GSM. ",
    "links" : [ ]
  }, {
    "name" : "PHONE_TYPE_CDMA",
    "type" : "int",
    "comment" : " Phone radio is CDMA. ",
    "links" : [ ]
  }, {
    "name" : "PHONE_TYPE_SIP",
    "type" : "int",
    "comment" : " Phone is via SIP. ",
    "links" : [ ]
  }, {
    "name" : "PHONE_TYPE_IMS",
    "type" : "int",
    "comment" : "\n     * Phone is via IMS.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "PHONE_TYPE_THIRD_PARTY",
    "type" : "int",
    "comment" : "\n     * Phone is via Third Party.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "sKernelCmdLine",
    "type" : "String",
    "comment" : " Kernel command line ",
    "links" : [ ]
  }, {
    "name" : "sProductTypePattern",
    "type" : "Pattern",
    "comment" : " Pattern for selecting the product type from the kernel command line ",
    "links" : [ ]
  }, {
    "name" : "sLteOnCdmaProductType",
    "type" : "String",
    "comment" : " The ProductType used for LTE on CDMA devices ",
    "links" : [ ]
  }, {
    "name" : "NETWORK_TYPE_UNKNOWN",
    "type" : "int",
    "comment" : " = 0.",
    "links" : [ ]
  }, {
    "name" : "NETWORK_TYPE_GPRS",
    "type" : "int",
    "comment" : " = 1.",
    "links" : [ ]
  }, {
    "name" : "NETWORK_TYPE_EDGE",
    "type" : "int",
    "comment" : " = 2.",
    "links" : [ ]
  }, {
    "name" : "NETWORK_TYPE_UMTS",
    "type" : "int",
    "comment" : " = 3.",
    "links" : [ ]
  }, {
    "name" : "NETWORK_TYPE_CDMA",
    "type" : "int",
    "comment" : " = 4.",
    "links" : [ ]
  }, {
    "name" : "NETWORK_TYPE_EVDO_0",
    "type" : "int",
    "comment" : " = 5.",
    "links" : [ ]
  }, {
    "name" : "NETWORK_TYPE_EVDO_A",
    "type" : "int",
    "comment" : " = 6.",
    "links" : [ ]
  }, {
    "name" : "NETWORK_TYPE_1xRTT",
    "type" : "int",
    "comment" : " = 7.",
    "links" : [ ]
  }, {
    "name" : "NETWORK_TYPE_HSDPA",
    "type" : "int",
    "comment" : " = 8.",
    "links" : [ ]
  }, {
    "name" : "NETWORK_TYPE_HSUPA",
    "type" : "int",
    "comment" : " = 9.",
    "links" : [ ]
  }, {
    "name" : "NETWORK_TYPE_HSPA",
    "type" : "int",
    "comment" : " = 10.",
    "links" : [ ]
  }, {
    "name" : "NETWORK_TYPE_IDEN",
    "type" : "int",
    "comment" : " = 11.",
    "links" : [ ]
  }, {
    "name" : "NETWORK_TYPE_EVDO_B",
    "type" : "int",
    "comment" : " = 12.",
    "links" : [ ]
  }, {
    "name" : "NETWORK_TYPE_LTE",
    "type" : "int",
    "comment" : " = 13.",
    "links" : [ ]
  }, {
    "name" : "NETWORK_TYPE_EHRPD",
    "type" : "int",
    "comment" : " = 14.",
    "links" : [ ]
  }, {
    "name" : "NETWORK_TYPE_HSPAP",
    "type" : "int",
    "comment" : " = 15.",
    "links" : [ ]
  }, {
    "name" : "NETWORK_TYPE_GSM",
    "type" : "int",
    "comment" : " = 16.",
    "links" : [ ]
  }, {
    "name" : "NETWORK_TYPE_TD_SCDMA",
    "type" : "int",
    "comment" : " Current network is TD_SCDMA ",
    "links" : [ ]
  }, {
    "name" : "NETWORK_TYPE_IWLAN",
    "type" : "int",
    "comment" : " = 18.",
    "links" : [ ]
  }, {
    "name" : "NETWORK_TYPE_LTE_CA",
    "type" : "int",
    "comment" : " Current network is LTE_CA {@hide} ",
    "links" : [ ]
  }, {
    "name" : "NETWORK_TYPE_NR",
    "type" : "int",
    "comment" : " 20.",
    "links" : [ ]
  }, {
    "name" : "NETWORK_TYPES",
    "type" : "int[]",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "SIM_STATE_UNKNOWN",
    "type" : "int",
    "comment" : " 0",
    "links" : [ ]
  }, {
    "name" : "SIM_STATE_ABSENT",
    "type" : "int",
    "comment" : " 1",
    "links" : [ ]
  }, {
    "name" : "SIM_STATE_PIN_REQUIRED",
    "type" : "int",
    "comment" : " SIM card state: Locked: requires the user's SIM PIN to unlock ",
    "links" : [ ]
  }, {
    "name" : "SIM_STATE_PUK_REQUIRED",
    "type" : "int",
    "comment" : " SIM card state: Locked: requires the user's SIM PUK to unlock ",
    "links" : [ ]
  }, {
    "name" : "SIM_STATE_NETWORK_LOCKED",
    "type" : "int",
    "comment" : " SIM card state: Locked: requires a network PIN to unlock ",
    "links" : [ ]
  }, {
    "name" : "SIM_STATE_READY",
    "type" : "int",
    "comment" : " 5",
    "links" : [ ]
  }, {
    "name" : "SIM_STATE_NOT_READY",
    "type" : "int",
    "comment" : " 6",
    "links" : [ ]
  }, {
    "name" : "SIM_STATE_PERM_DISABLED",
    "type" : "int",
    "comment" : " SIM card state: SIM Card Error, permanently disabled ",
    "links" : [ ]
  }, {
    "name" : "SIM_STATE_CARD_IO_ERROR",
    "type" : "int",
    "comment" : " SIM card state: SIM Card Error, present but faulty ",
    "links" : [ ]
  }, {
    "name" : "SIM_STATE_CARD_RESTRICTED",
    "type" : "int",
    "comment" : " SIM card state: SIM Card restricted, present but not usable due to\n     * carrier restrictions.\n     ",
    "links" : [ ]
  }, {
    "name" : "SIM_STATE_LOADED",
    "type" : "int",
    "comment" : "\n     * SIM card state: Loaded: SIM card applications have been loaded\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "SIM_STATE_PRESENT",
    "type" : "int",
    "comment" : "\n     * SIM card state: SIM Card is present\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "EXTRA_SIM_STATE",
    "type" : "String",
    "comment" : "\n     * Extra included in {@link #ACTION_SIM_CARD_STATE_CHANGED} and\n     * {@link #ACTION_SIM_APPLICATION_STATE_CHANGED} to indicate the card/application state.\n     *\n     * @hide\n     ",
    "links" : [ "#ACTION_SIM_APPLICATION_STATE_CHANGED", "#ACTION_SIM_CARD_STATE_CHANGED" ]
  }, {
    "name" : "ACTION_SIM_CARD_STATE_CHANGED",
    "type" : "String",
    "comment" : "\n     * Broadcast Action: The sim card state has changed.\n     * The intent will have the following extra values:</p>\n     * <dl>\n     *   <dt>{@link #EXTRA_SIM_STATE}</dt>\n     *   <dd>The sim card state. One of:\n     *     <dl>\n     *       <dt>{@link #SIM_STATE_ABSENT}</dt>\n     *       <dd>SIM card not found</dd>\n     *       <dt>{@link #SIM_STATE_CARD_IO_ERROR}</dt>\n     *       <dd>SIM card IO error</dd>\n     *       <dt>{@link #SIM_STATE_CARD_RESTRICTED}</dt>\n     *       <dd>SIM card is restricted</dd>\n     *       <dt>{@link #SIM_STATE_PRESENT}</dt>\n     *       <dd>SIM card is present</dd>\n     *     </dl>\n     *   </dd>\n     * </dl>\n     *\n     * <p class=\"note\">Requires the READ_PRIVILEGED_PHONE_STATE permission.\n     *\n     * <p class=\"note\">The current state can also be queried using {@link #getSimCardState()}.\n     *\n     * <p class=\"note\">This is a protected intent that can only be sent by the system.\n     * @hide\n     ",
    "links" : [ "#getSimCardState()", "#SIM_STATE_CARD_RESTRICTED", "#EXTRA_SIM_STATE", "#SIM_STATE_PRESENT", "#SIM_STATE_CARD_IO_ERROR", "#SIM_STATE_ABSENT" ]
  }, {
    "name" : "ACTION_SIM_APPLICATION_STATE_CHANGED",
    "type" : "String",
    "comment" : "\n     * Broadcast Action: The sim application state has changed.\n     * The intent will have the following extra values:</p>\n     * <dl>\n     *   <dt>{@link #EXTRA_SIM_STATE}</dt>\n     *   <dd>The sim application state. One of:\n     *     <dl>\n     *       <dt>{@link #SIM_STATE_NOT_READY}</dt>\n     *       <dd>SIM card applications not ready</dd>\n     *       <dt>{@link #SIM_STATE_PIN_REQUIRED}</dt>\n     *       <dd>SIM card PIN locked</dd>\n     *       <dt>{@link #SIM_STATE_PUK_REQUIRED}</dt>\n     *       <dd>SIM card PUK locked</dd>\n     *       <dt>{@link #SIM_STATE_NETWORK_LOCKED}</dt>\n     *       <dd>SIM card network locked</dd>\n     *       <dt>{@link #SIM_STATE_PERM_DISABLED}</dt>\n     *       <dd>SIM card permanently disabled due to PUK failures</dd>\n     *       <dt>{@link #SIM_STATE_LOADED}</dt>\n     *       <dd>SIM card data loaded</dd>\n     *     </dl>\n     *   </dd>\n     * </dl>\n     *\n     * <p class=\"note\">Requires the READ_PRIVILEGED_PHONE_STATE permission.\n     *\n     * <p class=\"note\">The current state can also be queried using\n     * {@link #getSimApplicationState()}.\n     *\n     * <p class=\"note\">This is a protected intent that can only be sent by the system.\n     * @hide\n     ",
    "links" : [ "#EXTRA_SIM_STATE", "#SIM_STATE_PERM_DISABLED", "#SIM_STATE_PUK_REQUIRED", "#SIM_STATE_PIN_REQUIRED", "#SIM_STATE_NETWORK_LOCKED", "#getSimApplicationState()", "#SIM_STATE_NOT_READY", "#SIM_STATE_LOADED" ]
  }, {
    "name" : "ACTION_SIM_SLOT_STATUS_CHANGED",
    "type" : "String",
    "comment" : "\n     * Broadcast Action: Status of the SIM slots on the device has changed.\n     *\n     * <p class=\"note\">Requires the READ_PRIVILEGED_PHONE_STATE permission.\n     *\n     * <p class=\"note\">The status can be queried using\n     * {@link #getUiccSlotsInfo()}\n     *\n     * <p class=\"note\">This is a protected intent that can only be sent by the system.\n     * @hide\n     ",
    "links" : [ "#getUiccSlotsInfo()" ]
  }, {
    "name" : "ACTION_SECRET_CODE",
    "type" : "String",
    "comment" : "\n     * Broadcast Action: A debug code has been entered in the dialer.\n     * <p>\n     * This intent is broadcast by the system and OEM telephony apps may need to receive these\n     * broadcasts. And it requires the sender to be default dialer or has carrier privileges\n     * (see {@link #hasCarrierPrivileges}).\n     * <p>\n     * These \"secret codes\" are used to activate developer menus by dialing certain codes.\n     * And they are of the form {@code *#*#<code>#*#*}. The intent will have the data\n     * URI: {@code android_secret_code://<code>}. It is possible that a manifest\n     * receiver would be woken up even if it is not currently running.\n     * <p>\n     * It is supposed to replace {@link android.provider.Telephony.Sms.Intents#SECRET_CODE_ACTION}\n     * in the next Android version.\n     * Before that both of these two actions will be broadcast.\n     ",
    "links" : [ "#hasCarrierPrivileges", "android.provider.Telephony.Sms.Intents#SECRET_CODE_ACTION" ]
  }, {
    "name" : "SIM_ACTIVATION_STATE_UNKNOWN",
    "type" : "int",
    "comment" : "\n     * Initial SIM activation state, unknown. Not set by any carrier apps.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "SIM_ACTIVATION_STATE_ACTIVATING",
    "type" : "int",
    "comment" : "\n     * indicate SIM is under activation procedure now.\n     * intermediate state followed by another state update with activation procedure result:\n     * @see #SIM_ACTIVATION_STATE_ACTIVATED\n     * @see #SIM_ACTIVATION_STATE_DEACTIVATED\n     * @see #SIM_ACTIVATION_STATE_RESTRICTED\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "SIM_ACTIVATION_STATE_ACTIVATED",
    "type" : "int",
    "comment" : "\n     * Indicate SIM has been successfully activated with full service\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "SIM_ACTIVATION_STATE_DEACTIVATED",
    "type" : "int",
    "comment" : "\n     * Indicate SIM has been deactivated by the carrier so that service is not available\n     * and requires activation service to enable services.\n     * Carrier apps could be signalled to set activation state to deactivated if detected\n     * deactivated sim state and set it back to activated after successfully run activation service.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "SIM_ACTIVATION_STATE_RESTRICTED",
    "type" : "int",
    "comment" : "\n     * Restricted state indicate SIM has been activated but service are restricted.\n     * note this is currently available for data activation state. For example out of byte sim.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "CALL_STATE_IDLE",
    "type" : "int",
    "comment" : "\n     * Device call state: No activity.\n     ",
    "links" : [ ]
  }, {
    "name" : "CALL_STATE_RINGING",
    "type" : "int",
    "comment" : "\n     * Device call state: Ringing. A new call arrived and is\n     *  ringing or waiting. In the latter case, another call is\n     *  already active.\n     ",
    "links" : [ ]
  }, {
    "name" : "CALL_STATE_OFFHOOK",
    "type" : "int",
    "comment" : "\n     * Device call state: Off-hook. At least one call exists\n     * that is dialing, active, or on hold, and no calls are ringing\n     * or waiting.\n     ",
    "links" : [ ]
  }, {
    "name" : "DATA_ACTIVITY_NONE",
    "type" : "int",
    "comment" : " Data connection activity: No traffic. ",
    "links" : [ ]
  }, {
    "name" : "DATA_ACTIVITY_IN",
    "type" : "int",
    "comment" : " Data connection activity: Currently receiving IP PPP traffic. ",
    "links" : [ ]
  }, {
    "name" : "DATA_ACTIVITY_OUT",
    "type" : "int",
    "comment" : " Data connection activity: Currently sending IP PPP traffic. ",
    "links" : [ ]
  }, {
    "name" : "DATA_ACTIVITY_INOUT",
    "type" : "int",
    "comment" : " Data connection activity: Currently both sending and receiving\n     *  IP PPP traffic. ",
    "links" : [ ]
  }, {
    "name" : "DATA_ACTIVITY_DORMANT",
    "type" : "int",
    "comment" : "\n     * Data connection is active, but physical link is down\n     ",
    "links" : [ ]
  }, {
    "name" : "DATA_UNKNOWN",
    "type" : "int",
    "comment" : " Data connection state: Unknown.  Used before we know the state. ",
    "links" : [ ]
  }, {
    "name" : "DATA_DISCONNECTED",
    "type" : "int",
    "comment" : " Data connection state: Disconnected. IP traffic not available. ",
    "links" : [ ]
  }, {
    "name" : "DATA_CONNECTING",
    "type" : "int",
    "comment" : " Data connection state: Currently setting up a data connection. ",
    "links" : [ ]
  }, {
    "name" : "DATA_CONNECTED",
    "type" : "int",
    "comment" : " Data connection state: Connected. IP traffic should be available. ",
    "links" : [ ]
  }, {
    "name" : "DATA_SUSPENDED",
    "type" : "int",
    "comment" : " Data connection state: Suspended. The connection is up, but IP\n     * traffic is temporarily unavailable. For example, in a 2G network,\n     * data activity may be suspended when a voice call arrives. ",
    "links" : [ ]
  }, {
    "name" : "DATA_DISCONNECTING",
    "type" : "int",
    "comment" : "\n     * Data connection state: Disconnecting.\n     *\n     * IP traffic may be available but will cease working imminently.\n     ",
    "links" : [ ]
  }, {
    "name" : "GET_DATA_STATE_R_VERSION",
    "type" : "long",
    "comment" : "\n     * Used for checking if the SDK version for {@link TelephonyManager#getDataState} is above Q.\n     ",
    "links" : [ "android.telephony.TelephonyManager#getDataState" ]
  }, {
    "name" : "APPTYPE_SIM",
    "type" : "int",
    "comment" : " UICC application type is SIM ",
    "links" : [ ]
  }, {
    "name" : "APPTYPE_USIM",
    "type" : "int",
    "comment" : " UICC application type is USIM ",
    "links" : [ ]
  }, {
    "name" : "APPTYPE_RUIM",
    "type" : "int",
    "comment" : " UICC application type is RUIM ",
    "links" : [ ]
  }, {
    "name" : "APPTYPE_CSIM",
    "type" : "int",
    "comment" : " UICC application type is CSIM ",
    "links" : [ ]
  }, {
    "name" : "APPTYPE_ISIM",
    "type" : "int",
    "comment" : " UICC application type is ISIM ",
    "links" : [ ]
  }, {
    "name" : "AUTHTYPE_EAP_SIM",
    "type" : "int",
    "comment" : " Authentication type for UICC challenge is EAP SIM. See RFC 4186 for details. ",
    "links" : [ ]
  }, {
    "name" : "AUTHTYPE_EAP_AKA",
    "type" : "int",
    "comment" : " Authentication type for UICC challenge is EAP AKA. See RFC 4187 for details. ",
    "links" : [ ]
  }, {
    "name" : "NETWORK_MODE_WCDMA_PREF",
    "type" : "int",
    "comment" : "\n     * Preferred network mode is GSM/WCDMA (WCDMA preferred).\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "NETWORK_MODE_GSM_ONLY",
    "type" : "int",
    "comment" : "\n     * Preferred network mode is GSM only.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "NETWORK_MODE_WCDMA_ONLY",
    "type" : "int",
    "comment" : "\n     * Preferred network mode is WCDMA only.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "NETWORK_MODE_GSM_UMTS",
    "type" : "int",
    "comment" : "\n     * Preferred network mode is GSM/WCDMA (auto mode, according to PRL).\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "NETWORK_MODE_CDMA_EVDO",
    "type" : "int",
    "comment" : "\n     * Preferred network mode is CDMA and EvDo (auto mode, according to PRL).\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "NETWORK_MODE_CDMA_NO_EVDO",
    "type" : "int",
    "comment" : "\n     * Preferred network mode is CDMA only.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "NETWORK_MODE_EVDO_NO_CDMA",
    "type" : "int",
    "comment" : "\n     * Preferred network mode is EvDo only.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "NETWORK_MODE_GLOBAL",
    "type" : "int",
    "comment" : "\n     * Preferred network mode is GSM/WCDMA, CDMA, and EvDo (auto mode, according to PRL).\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "NETWORK_MODE_LTE_CDMA_EVDO",
    "type" : "int",
    "comment" : "\n     * Preferred network mode is LTE, CDMA and EvDo.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "NETWORK_MODE_LTE_GSM_WCDMA",
    "type" : "int",
    "comment" : "\n     * Preferred network mode is LTE, GSM/WCDMA.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "NETWORK_MODE_LTE_CDMA_EVDO_GSM_WCDMA",
    "type" : "int",
    "comment" : "\n     * Preferred network mode is LTE, CDMA, EvDo, GSM/WCDMA.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "NETWORK_MODE_LTE_ONLY",
    "type" : "int",
    "comment" : "\n     * Preferred network mode is LTE Only.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "NETWORK_MODE_LTE_WCDMA",
    "type" : "int",
    "comment" : "\n     * Preferred network mode is LTE/WCDMA.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "NETWORK_MODE_TDSCDMA_ONLY",
    "type" : "int",
    "comment" : "\n     * Preferred network mode is TD-SCDMA only.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "NETWORK_MODE_TDSCDMA_WCDMA",
    "type" : "int",
    "comment" : "\n     * Preferred network mode is TD-SCDMA and WCDMA.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "NETWORK_MODE_LTE_TDSCDMA",
    "type" : "int",
    "comment" : "\n     * Preferred network mode is TD-SCDMA and LTE.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "NETWORK_MODE_TDSCDMA_GSM",
    "type" : "int",
    "comment" : "\n     * Preferred network mode is TD-SCDMA and GSM.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "NETWORK_MODE_LTE_TDSCDMA_GSM",
    "type" : "int",
    "comment" : "\n     * Preferred network mode is TD-SCDMA,GSM and LTE.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "NETWORK_MODE_TDSCDMA_GSM_WCDMA",
    "type" : "int",
    "comment" : "\n     * Preferred network mode is TD-SCDMA, GSM/WCDMA.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "NETWORK_MODE_LTE_TDSCDMA_WCDMA",
    "type" : "int",
    "comment" : "\n     * Preferred network mode is TD-SCDMA, WCDMA and LTE.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "NETWORK_MODE_LTE_TDSCDMA_GSM_WCDMA",
    "type" : "int",
    "comment" : "\n     * Preferred network mode is TD-SCDMA, GSM/WCDMA and LTE.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "NETWORK_MODE_TDSCDMA_CDMA_EVDO_GSM_WCDMA",
    "type" : "int",
    "comment" : "\n     * Preferred network mode is TD-SCDMA,EvDo,CDMA,GSM/WCDMA.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "NETWORK_MODE_LTE_TDSCDMA_CDMA_EVDO_GSM_WCDMA",
    "type" : "int",
    "comment" : "\n     * Preferred network mode is TD-SCDMA/LTE/GSM/WCDMA, CDMA, and EvDo.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "NETWORK_MODE_NR_ONLY",
    "type" : "int",
    "comment" : "\n     * Preferred network mode is NR 5G only.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "NETWORK_MODE_NR_LTE",
    "type" : "int",
    "comment" : "\n     * Preferred network mode is NR 5G, LTE.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "NETWORK_MODE_NR_LTE_CDMA_EVDO",
    "type" : "int",
    "comment" : "\n     * Preferred network mode is NR 5G, LTE, CDMA and EvDo.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "NETWORK_MODE_NR_LTE_GSM_WCDMA",
    "type" : "int",
    "comment" : "\n     * Preferred network mode is NR 5G, LTE, GSM and WCDMA.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "NETWORK_MODE_NR_LTE_CDMA_EVDO_GSM_WCDMA",
    "type" : "int",
    "comment" : "\n     * Preferred network mode is NR 5G, LTE, CDMA, EvDo, GSM and WCDMA.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "NETWORK_MODE_NR_LTE_WCDMA",
    "type" : "int",
    "comment" : "\n     * Preferred network mode is NR 5G, LTE and WCDMA.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "NETWORK_MODE_NR_LTE_TDSCDMA",
    "type" : "int",
    "comment" : "\n     * Preferred network mode is NR 5G, LTE and TDSCDMA.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "NETWORK_MODE_NR_LTE_TDSCDMA_GSM",
    "type" : "int",
    "comment" : "\n     * Preferred network mode is NR 5G, LTE, TD-SCDMA and GSM.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "NETWORK_MODE_NR_LTE_TDSCDMA_WCDMA",
    "type" : "int",
    "comment" : "\n     * Preferred network mode is NR 5G, LTE, TD-SCDMA, WCDMA.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "NETWORK_MODE_NR_LTE_TDSCDMA_GSM_WCDMA",
    "type" : "int",
    "comment" : "\n     * Preferred network mode is NR 5G, LTE, TD-SCDMA, GSM and WCDMA.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "NETWORK_MODE_NR_LTE_TDSCDMA_CDMA_EVDO_GSM_WCDMA",
    "type" : "int",
    "comment" : "\n     * Preferred network mode is NR 5G, LTE, TD-SCDMA, CDMA, EVDO, GSM and WCDMA.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "DEFAULT_PREFERRED_NETWORK_MODE",
    "type" : "int",
    "comment" : "\n     * The default preferred network mode constant.\n     *\n     * <p> This constant is used in case of nothing is set in\n     * TelephonyProperties#default_network().\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "ALLOWED_NETWORK_TYPES_REASON_POWER",
    "type" : "int",
    "comment" : "\n     * To indicate allowed network type change is requested by power manager.\n     * Power Manger configuration won't affect the settings configured through\n     * {@link setAllowedNetworkTypes} and will result in allowing network types that are in both\n     * configurations (i.e intersection of both sets).\n     * @hide\n     ",
    "links" : [ "setAllowedNetworkTypes" ]
  }, {
    "name" : "CARRIER_PRIVILEGE_STATUS_HAS_ACCESS",
    "type" : "int",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "CARRIER_PRIVILEGE_STATUS_NO_ACCESS",
    "type" : "int",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "CARRIER_PRIVILEGE_STATUS_RULES_NOT_LOADED",
    "type" : "int",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "CARRIER_PRIVILEGE_STATUS_ERROR_LOADING_RULES",
    "type" : "int",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "RADIO_POWER_OFF",
    "type" : "int",
    "comment" : "\n     * Radio explicitly powered off (e.g, airplane mode).\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "RADIO_POWER_ON",
    "type" : "int",
    "comment" : "\n     * Radio power is on.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "RADIO_POWER_UNAVAILABLE",
    "type" : "int",
    "comment" : "\n     * Radio power unavailable (eg, modem resetting or not booted).\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "CDMA_SUBSCRIPTION_UNKNOWN",
    "type" : "int",
    "comment" : " Used for CDMA subscription mode, it'll be UNKNOWN if there is no Subscription source.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "CDMA_SUBSCRIPTION_RUIM_SIM",
    "type" : "int",
    "comment" : " Used for CDMA subscription mode: RUIM/SIM (default)\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "CDMA_SUBSCRIPTION_NV",
    "type" : "int",
    "comment" : " Used for CDMA subscription mode: NV -> non-volatile memory\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "PREFERRED_CDMA_SUBSCRIPTION",
    "type" : "int",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "CARD_POWER_DOWN",
    "type" : "int",
    "comment" : "\n     * Powers down the SIM. SIM must be up prior.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "CARD_POWER_UP",
    "type" : "int",
    "comment" : "\n     * Powers up the SIM normally. SIM must be down prior.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "CARD_POWER_UP_PASS_THROUGH",
    "type" : "int",
    "comment" : "\n     * Powers up the SIM in PASS_THROUGH mode. SIM must be down prior.\n     * When SIM is powered up in PASS_THOUGH mode, the modem does not send\n     * any command to it (for example SELECT of MF, or TERMINAL CAPABILITY),\n     * and the SIM card is controlled completely by Telephony sending APDUs\n     * directly. The SIM card state will be RIL_CARDSTATE_PRESENT and the\n     * number of card apps will be 0.\n     * No new error code is generated. Emergency calls are supported in the\n     * same way as if the SIM card is absent.\n     * The PASS_THROUGH mode is valid only for the specific card session where it\n     * is activated, and normal behavior occurs at the next SIM initialization,\n     * unless PASS_THROUGH mode is requested again. Hence, the last power-up mode\n     * is NOT persistent across boots. On reboot, SIM will power up normally.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "SET_CARRIER_RESTRICTION_SUCCESS",
    "type" : "int",
    "comment" : "\n     * The carrier restrictions were successfully set.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "SET_CARRIER_RESTRICTION_NOT_SUPPORTED",
    "type" : "int",
    "comment" : "\n     * The carrier restrictions were not set due to lack of support in the modem. This can happen\n     * if the modem does not support setting the carrier restrictions or if the configuration\n     * passed in the {@code setCarrierRestrictionRules} is not supported by the modem.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "SET_CARRIER_RESTRICTION_ERROR",
    "type" : "int",
    "comment" : "\n     * The setting of carrier restrictions failed.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "INDICATION_UPDATE_MODE_NORMAL",
    "type" : "int",
    "comment" : "\n     * In this mode, modem will not send specified indications when screen is off.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "INDICATION_UPDATE_MODE_IGNORE_SCREEN_OFF",
    "type" : "int",
    "comment" : "\n     * In this mode, modem will still send specified indications when screen is off.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "INDICATION_FILTER_SIGNAL_STRENGTH",
    "type" : "int",
    "comment" : "\n     * The indication for signal strength update.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "INDICATION_FILTER_FULL_NETWORK_STATE",
    "type" : "int",
    "comment" : "\n     * The indication for full network state update.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "INDICATION_FILTER_DATA_CALL_DORMANCY_CHANGED",
    "type" : "int",
    "comment" : "\n     * The indication for data call dormancy changed update.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "INDICATION_FILTER_LINK_CAPACITY_ESTIMATE",
    "type" : "int",
    "comment" : "\n     * The indication for link capacity estimate update.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "INDICATION_FILTER_PHYSICAL_CHANNEL_CONFIG",
    "type" : "int",
    "comment" : "\n     * The indication for physical channel config update.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "NETWORK_TYPE_BITMASK_UNKNOWN",
    "type" : "long",
    "comment" : "\n     * network type bitmask unknown.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "NETWORK_TYPE_BITMASK_GSM",
    "type" : "long",
    "comment" : "\n     * network type bitmask indicating the support of radio tech GSM.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "NETWORK_TYPE_BITMASK_GPRS",
    "type" : "long",
    "comment" : "\n     * network type bitmask indicating the support of radio tech GPRS.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "NETWORK_TYPE_BITMASK_EDGE",
    "type" : "long",
    "comment" : "\n     * network type bitmask indicating the support of radio tech EDGE.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "NETWORK_TYPE_BITMASK_CDMA",
    "type" : "long",
    "comment" : "\n     * network type bitmask indicating the support of radio tech CDMA(IS95A/IS95B).\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "NETWORK_TYPE_BITMASK_1xRTT",
    "type" : "long",
    "comment" : "\n     * network type bitmask indicating the support of radio tech 1xRTT.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "NETWORK_TYPE_BITMASK_EVDO_0",
    "type" : "long",
    "comment" : "\n     * network type bitmask indicating the support of radio tech EVDO 0.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "NETWORK_TYPE_BITMASK_EVDO_A",
    "type" : "long",
    "comment" : "\n     * network type bitmask indicating the support of radio tech EVDO A.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "NETWORK_TYPE_BITMASK_EVDO_B",
    "type" : "long",
    "comment" : "\n     * network type bitmask indicating the support of radio tech EVDO B.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "NETWORK_TYPE_BITMASK_EHRPD",
    "type" : "long",
    "comment" : "\n     * network type bitmask indicating the support of radio tech EHRPD.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "NETWORK_TYPE_BITMASK_HSUPA",
    "type" : "long",
    "comment" : "\n     * network type bitmask indicating the support of radio tech HSUPA.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "NETWORK_TYPE_BITMASK_HSDPA",
    "type" : "long",
    "comment" : "\n     * network type bitmask indicating the support of radio tech HSDPA.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "NETWORK_TYPE_BITMASK_HSPA",
    "type" : "long",
    "comment" : "\n     * network type bitmask indicating the support of radio tech HSPA.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "NETWORK_TYPE_BITMASK_HSPAP",
    "type" : "long",
    "comment" : "\n     * network type bitmask indicating the support of radio tech HSPAP.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "NETWORK_TYPE_BITMASK_UMTS",
    "type" : "long",
    "comment" : "\n     * network type bitmask indicating the support of radio tech UMTS.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "NETWORK_TYPE_BITMASK_TD_SCDMA",
    "type" : "long",
    "comment" : "\n     * network type bitmask indicating the support of radio tech TD_SCDMA.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "NETWORK_TYPE_BITMASK_LTE",
    "type" : "long",
    "comment" : "\n     * network type bitmask indicating the support of radio tech LTE.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "NETWORK_TYPE_BITMASK_LTE_CA",
    "type" : "long",
    "comment" : "\n     * network type bitmask indicating the support of radio tech LTE CA (carrier aggregation).\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "NETWORK_TYPE_BITMASK_NR",
    "type" : "long",
    "comment" : "\n     * network type bitmask indicating the support of radio tech NR(New Radio) 5G.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "NETWORK_TYPE_BITMASK_IWLAN",
    "type" : "long",
    "comment" : "\n     * network type bitmask indicating the support of radio tech IWLAN.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "NETWORK_CLASS_BITMASK_2G",
    "type" : "long",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "NETWORK_CLASS_BITMASK_3G",
    "type" : "long",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "NETWORK_CLASS_BITMASK_4G",
    "type" : "long",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "NETWORK_CLASS_BITMASK_5G",
    "type" : "long",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "NETWORK_STANDARDS_FAMILY_BITMASK_3GPP",
    "type" : "long",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "NETWORK_STANDARDS_FAMILY_BITMASK_3GPP2",
    "type" : "long",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "INVALID_EMERGENCY_NUMBER_DB_VERSION",
    "type" : "int",
    "comment" : "\n     * Indicates Emergency number database version is invalid.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "SET_OPPORTUNISTIC_SUB_SUCCESS",
    "type" : "int",
    "comment" : "\n     * No error. Operation succeeded.\n     ",
    "links" : [ ]
  }, {
    "name" : "SET_OPPORTUNISTIC_SUB_VALIDATION_FAILED",
    "type" : "int",
    "comment" : "\n     * Validation failed when trying to switch to preferred subscription.\n     ",
    "links" : [ ]
  }, {
    "name" : "SET_OPPORTUNISTIC_SUB_INACTIVE_SUBSCRIPTION",
    "type" : "int",
    "comment" : "\n     * The subscription is not valid. It must be an active opportunistic subscription.\n     ",
    "links" : [ ]
  }, {
    "name" : "SET_OPPORTUNISTIC_SUB_NO_OPPORTUNISTIC_SUB_AVAILABLE",
    "type" : "int",
    "comment" : "\n     * The subscription is not valid. It must be an opportunistic subscription.\n     ",
    "links" : [ ]
  }, {
    "name" : "SET_OPPORTUNISTIC_SUB_REMOTE_SERVICE_EXCEPTION",
    "type" : "int",
    "comment" : "\n     * Subscription service happened remote exception.\n     ",
    "links" : [ ]
  }, {
    "name" : "UPDATE_AVAILABLE_NETWORKS_SUCCESS",
    "type" : "int",
    "comment" : "\n     * No error. Operation succeeded.\n     ",
    "links" : [ ]
  }, {
    "name" : "UPDATE_AVAILABLE_NETWORKS_UNKNOWN_FAILURE",
    "type" : "int",
    "comment" : "\n     * There is a unknown failure happened.\n     ",
    "links" : [ ]
  }, {
    "name" : "UPDATE_AVAILABLE_NETWORKS_ABORTED",
    "type" : "int",
    "comment" : "\n     * The request is aborted.\n     ",
    "links" : [ ]
  }, {
    "name" : "UPDATE_AVAILABLE_NETWORKS_INVALID_ARGUMENTS",
    "type" : "int",
    "comment" : "\n     * The parameter passed in is invalid.\n     ",
    "links" : [ ]
  }, {
    "name" : "UPDATE_AVAILABLE_NETWORKS_NO_CARRIER_PRIVILEGE",
    "type" : "int",
    "comment" : "\n     * No carrier privilege.\n     ",
    "links" : [ ]
  }, {
    "name" : "UPDATE_AVAILABLE_NETWORKS_DISABLE_MODEM_FAIL",
    "type" : "int",
    "comment" : "\n     * Disable modem fail.\n     ",
    "links" : [ ]
  }, {
    "name" : "UPDATE_AVAILABLE_NETWORKS_ENABLE_MODEM_FAIL",
    "type" : "int",
    "comment" : "\n     * Enable modem fail.\n     ",
    "links" : [ ]
  }, {
    "name" : "UPDATE_AVAILABLE_NETWORKS_MULTIPLE_NETWORKS_NOT_SUPPORTED",
    "type" : "int",
    "comment" : "\n     * Carrier app does not support multiple available networks.\n     ",
    "links" : [ ]
  }, {
    "name" : "UPDATE_AVAILABLE_NETWORKS_NO_OPPORTUNISTIC_SUB_AVAILABLE",
    "type" : "int",
    "comment" : "\n     * The subscription is not valid. It must be an opportunistic subscription.\n     ",
    "links" : [ ]
  }, {
    "name" : "UPDATE_AVAILABLE_NETWORKS_REMOTE_SERVICE_EXCEPTION",
    "type" : "int",
    "comment" : "\n     * There is no OpportunisticNetworkService.\n     ",
    "links" : [ ]
  }, {
    "name" : "UPDATE_AVAILABLE_NETWORKS_SERVICE_IS_DISABLED",
    "type" : "int",
    "comment" : "\n     * OpportunisticNetworkService is disabled.\n     ",
    "links" : [ ]
  }, {
    "name" : "ACTION_NETWORK_COUNTRY_CHANGED",
    "type" : "String",
    "comment" : "\n     * Broadcast intent action for network country code changes.\n     *\n     * <p>\n     * The {@link #EXTRA_NETWORK_COUNTRY} extra indicates the country code of the current\n     * network returned by {@link #getNetworkCountryIso()}.\n     *\n     * <p>There may be a delay of several minutes before reporting that no country is detected.\n     *\n     * @see #EXTRA_NETWORK_COUNTRY\n     * @see #getNetworkCountryIso()\n     ",
    "links" : [ "#EXTRA_NETWORK_COUNTRY", "#getNetworkCountryIso()" ]
  }, {
    "name" : "EXTRA_NETWORK_COUNTRY",
    "type" : "String",
    "comment" : "\n     * The extra used with an {@link #ACTION_NETWORK_COUNTRY_CHANGED} to specify the\n     * the country code in ISO-3166-1 alpha-2 format.\n     * <p class=\"note\">\n     * Retrieve with {@link android.content.Intent#getStringExtra(String)}.\n     ",
    "links" : [ "android.content.Intent#getStringExtra(String)", "#ACTION_NETWORK_COUNTRY_CHANGED" ]
  }, {
    "name" : "EXTRA_LAST_KNOWN_NETWORK_COUNTRY",
    "type" : "String",
    "comment" : "\n     * The extra used with an {@link #ACTION_NETWORK_COUNTRY_CHANGED} to specify the\n     * last known the country code in ISO-3166-1 alpha-2 format.\n     * <p class=\"note\">\n     * Retrieve with {@link android.content.Intent#getStringExtra(String)}.\n     *\n     * @hide\n     ",
    "links" : [ "android.content.Intent#getStringExtra(String)", "#ACTION_NETWORK_COUNTRY_CHANGED" ]
  }, {
    "name" : "MULTISIM_ALLOWED",
    "type" : "int",
    "comment" : "\n     * The usage of multiple SIM cards at the same time to register on the network (e.g. Dual\n     * Standby or Dual Active) is supported.\n     ",
    "links" : [ ]
  }, {
    "name" : "MULTISIM_NOT_SUPPORTED_BY_HARDWARE",
    "type" : "int",
    "comment" : "\n     * The usage of multiple SIM cards at the same time to register on the network (e.g. Dual\n     * Standby or Dual Active) is not supported by the hardware.\n     ",
    "links" : [ ]
  }, {
    "name" : "MULTISIM_NOT_SUPPORTED_BY_CARRIER",
    "type" : "int",
    "comment" : "\n     * The usage of multiple SIM cards at the same time to register on the network (e.g. Dual\n     * Standby or Dual Active) is supported by the hardware, but restricted by the carrier.\n     ",
    "links" : [ ]
  }, {
    "name" : "CALL_WAITING_STATUS_ACTIVE",
    "type" : "int",
    "comment" : "\n     * Indicates the call waiting status is active.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "CALL_WAITING_STATUS_INACTIVE",
    "type" : "int",
    "comment" : "\n     * Indicates the call waiting status is inactive.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "CALL_WAITING_STATUS_UNKNOWN_ERROR",
    "type" : "int",
    "comment" : "\n     * Indicates the call waiting status is with an unknown error.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "CALL_WAITING_STATUS_NOT_SUPPORTED",
    "type" : "int",
    "comment" : "\n     * Indicates the call waiting is not supported (e.g. called via CDMA).\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "CHANGE_ICC_LOCK_SUCCESS",
    "type" : "int",
    "comment" : "\n     * The IccLock state or password was changed successfully.\n     * @hide\n     ",
    "links" : [ ]
  } ],
  "methods" : [ {
    "name" : "public static TelephonyManager getDefault()",
    "returnType" : "TelephonyManager",
    "comment" : " @hide\n    /* @deprecated - use getSystemService as described above ",
    "links" : [ ]
  }, {
    "name" : "private String getOpPackageName()",
    "returnType" : "String",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private String getAttributionTag()",
    "returnType" : "String",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private boolean isSystemProcess()",
    "returnType" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public MultiSimVariants getMultiSimConfiguration()",
    "returnType" : "MultiSimVariants",
    "comment" : " {@hide} ",
    "links" : [ ]
  }, {
    "name" : "public int getPhoneCount()",
    "returnType" : "int",
    "comment" : "\n     * Returns the number of phones available.\n     * Returns 0 if none of voice, sms, data is not supported\n     * Returns 1 for Single standby mode (Single SIM functionality).\n     * Returns 2 for Dual standby mode (Dual SIM functionality).\n     * Returns 3 for Tri standby mode (Tri SIM functionality).\n     * @deprecated Use {@link #getActiveModemCount} instead.\n     ",
    "links" : [ "#getActiveModemCount" ]
  }, {
    "name" : "public int getActiveModemCount()",
    "returnType" : "int",
    "comment" : "\n     * Returns the number of logical modems currently configured to be activated.\n     *\n     * Returns 0 if none of voice, sms, data is not supported\n     * Returns 1 for Single standby mode (Single SIM functionality).\n     * Returns 2 for Dual standby mode (Dual SIM functionality).\n     * Returns 3 for Tri standby mode (Tri SIM functionality).\n     ",
    "links" : [ ]
  }, {
    "name" : "public int getSupportedModemCount()",
    "returnType" : "int",
    "comment" : "\n     * Return how many logical modem can be potentially active simultaneously, in terms of hardware\n     * capability.\n     * It might return different value from {@link #getActiveModemCount}. For example, for a\n     * dual-SIM capable device operating in single SIM mode (only one logical modem is turned on),\n     * {@link #getActiveModemCount} returns 1 while this API returns 2.\n     ",
    "links" : [ "#getActiveModemCount" ]
  }, {
    "name" : "public int getMaxNumberOfSimultaneouslyActiveSims()",
    "returnType" : "int",
    "comment" : "\n     * Gets the maximum number of SIMs that can be active, based on the device's multisim\n     * configuration.\n     * @return 1 for single-SIM, DSDS, and TSTS devices. 2 for DSDA devices.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public static TelephonyManager from(Context context)",
    "returnType" : "TelephonyManager",
    "comment" : " {@hide} ",
    "links" : [ ]
  }, {
    "name" : "public TelephonyManager createForSubscriptionId(int subId)",
    "returnType" : "TelephonyManager",
    "comment" : "\n     * Create a new TelephonyManager object pinned to the given subscription ID.\n     *\n     * @return a TelephonyManager that uses the given subId for all calls.\n     ",
    "links" : [ ]
  }, {
    "name" : "public TelephonyManager createForPhoneAccountHandle(PhoneAccountHandle phoneAccountHandle)",
    "returnType" : "TelephonyManager",
    "comment" : "\n     * Create a new TelephonyManager object pinned to the subscription ID associated with the given\n     * phone account.\n     *\n     * @return a TelephonyManager that uses the given phone account for all calls, or {@code null}\n     * if the phone account does not correspond to a valid subscription ID.\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean isMultiSimEnabled()",
    "returnType" : "boolean",
    "comment" : " {@hide} ",
    "links" : [ ]
  }, {
    "name" : "public String getDeviceSoftwareVersion()",
    "returnType" : "String",
    "comment" : "\n     * Returns the software version number for the device, for example,\n     * the IMEI/SV for GSM phones. Return null if the software version is\n     * not available.\n     * <p>\n     * Requires Permission: {@link android.Manifest.permission#READ_PHONE_STATE READ_PHONE_STATE}.\n     ",
    "links" : [ "android.Manifest.permission#READ_PHONE_STATE" ]
  }, {
    "name" : "public String getDeviceSoftwareVersion(int slotIndex)",
    "returnType" : "String",
    "comment" : "\n     * Returns the software version number for the device, for example,\n     * the IMEI/SV for GSM phones. Return null if the software version is\n     * not available.\n     * <p>\n     * Requires Permission: READ_PRIVILEGED_PHONE_STATE.\n     *\n     * @param slotIndex of which deviceID is returned\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public String getDeviceId()",
    "returnType" : "String",
    "comment" : "\n     * Returns the unique device ID, for example, the IMEI for GSM and the MEID\n     * or ESN for CDMA phones. Return null if device ID is not available.\n     *\n     * <p>Starting with API level 29, persistent device identifiers are guarded behind additional\n     * restrictions, and apps are recommended to use resettable identifiers (see <a\n     * href=\"c\"> Best practices for unique identifiers</a>). This method can be invoked if one of\n     * the following requirements is met:\n     * <ul>\n     *     <li>If the calling app has been granted the READ_PRIVILEGED_PHONE_STATE permission; this\n     *     is a privileged permission that can only be granted to apps preloaded on the device.\n     *     <li>If the calling app is the device or profile owner and has been granted the\n     *     {@link Manifest.permission#READ_PHONE_STATE} permission. The profile owner is an app that\n     *     owns a managed profile on the device; for more details see <a\n     *     href=\"https://developer.android.com/work/managed-profiles\">Work profiles</a>.\n     *     Profile owner access is deprecated and will be removed in a future release.\n     *     <li>If the calling app has carrier privileges (see {@link #hasCarrierPrivileges}) on any\n     *     active subscription.\n     *     <li>If the calling app is the default SMS role holder (see {@link\n     *     RoleManager#isRoleHeld(String)}).\n     * </ul>\n     *\n     * <p>If the calling app does not meet one of these requirements then this method will behave\n     * as follows:\n     *\n     * <ul>\n     *     <li>If the calling app's target SDK is API level 28 or lower and the app has the\n     *     READ_PHONE_STATE permission then null is returned.</li>\n     *     <li>If the calling app's target SDK is API level 28 or lower and the app does not have\n     *     the READ_PHONE_STATE permission, or if the calling app is targeting API level 29 or\n     *     higher, then a SecurityException is thrown.</li>\n     * </ul>\n     *\n     * @deprecated Use {@link #getImei} which returns IMEI for GSM or {@link #getMeid} which returns\n     * MEID for CDMA.\n     ",
    "links" : [ "#getImei", "Manifest.permission#READ_PHONE_STATE", "#hasCarrierPrivileges", "android.app.role.RoleManager#isRoleHeld(String)", "#getMeid" ]
  }, {
    "name" : "public String getDeviceId(int slotIndex)",
    "returnType" : "String",
    "comment" : "\n     * Returns the unique device ID of a subscription, for example, the IMEI for\n     * GSM and the MEID for CDMA phones. Return null if device ID is not available.\n     *\n     * <p>Starting with API level 29, persistent device identifiers are guarded behind additional\n     * restrictions, and apps are recommended to use resettable identifiers (see <a\n     * href=\"c\"> Best practices for unique identifiers</a>). This method can be invoked if one of\n     * the following requirements is met:\n     * <ul>\n     *     <li>If the calling app has been granted the READ_PRIVILEGED_PHONE_STATE permission; this\n     *     is a privileged permission that can only be granted to apps preloaded on the device.\n     *     <li>If the calling app is the device or profile owner and has been granted the\n     *     {@link Manifest.permission#READ_PHONE_STATE} permission. The profile owner is an app that\n     *     owns a managed profile on the device; for more details see <a\n     *     href=\"https://developer.android.com/work/managed-profiles\">Work profiles</a>.\n     *     Profile owner access is deprecated and will be removed in a future release.\n     *     <li>If the calling app has carrier privileges (see {@link #hasCarrierPrivileges}) on any\n     *     active subscription.\n     *     <li>If the calling app is the default SMS role holder (see {@link\n     *     RoleManager#isRoleHeld(String)}).\n     * </ul>\n     *\n     * <p>If the calling app does not meet one of these requirements then this method will behave\n     * as follows:\n     *\n     * <ul>\n     *     <li>If the calling app's target SDK is API level 28 or lower and the app has the\n     *     READ_PHONE_STATE permission then null is returned.</li>\n     *     <li>If the calling app's target SDK is API level 28 or lower and the app does not have\n     *     the READ_PHONE_STATE permission, or if the calling app is targeting API level 29 or\n     *     higher, then a SecurityException is thrown.</li>\n     * </ul>\n     *\n     * @param slotIndex of which deviceID is returned\n     *\n     * @deprecated Use {@link #getImei} which returns IMEI for GSM or {@link #getMeid} which returns\n     * MEID for CDMA.\n     ",
    "links" : [ "#getImei", "Manifest.permission#READ_PHONE_STATE", "#hasCarrierPrivileges", "android.app.role.RoleManager#isRoleHeld(String)", "#getMeid" ]
  }, {
    "name" : "public String getImei()",
    "returnType" : "String",
    "comment" : "\n     * Returns the IMEI (International Mobile Equipment Identity). Return null if IMEI is not\n     * available.\n     *\n     * See {@link #getImei(int)} for details on the required permissions and behavior\n     * when the caller does not hold sufficient permissions.\n     ",
    "links" : [ "#getImei(int)" ]
  }, {
    "name" : "public String getImei(int slotIndex)",
    "returnType" : "String",
    "comment" : "\n     * Returns the IMEI (International Mobile Equipment Identity). Return null if IMEI is not\n     * available.\n     *\n     * <p>Starting with API level 29, persistent device identifiers are guarded behind additional\n     * restrictions, and apps are recommended to use resettable identifiers (see <a\n     * href=\"c\"> Best practices for unique identifiers</a>). This method can be invoked if one of\n     * the following requirements is met:\n     * <ul>\n     *     <li>If the calling app has been granted the READ_PRIVILEGED_PHONE_STATE permission; this\n     *     is a privileged permission that can only be granted to apps preloaded on the device.\n     *     <li>If the calling app is the device or profile owner and has been granted the\n     *     {@link Manifest.permission#READ_PHONE_STATE} permission. The profile owner is an app that\n     *     owns a managed profile on the device; for more details see <a\n     *     href=\"https://developer.android.com/work/managed-profiles\">Work profiles</a>.\n     *     Profile owner access is deprecated and will be removed in a future release.\n     *     <li>If the calling app has carrier privileges (see {@link #hasCarrierPrivileges}) on any\n     *     active subscription.\n     *     <li>If the calling app is the default SMS role holder (see {@link\n     *     RoleManager#isRoleHeld(String)}).\n     * </ul>\n     *\n     * <p>If the calling app does not meet one of these requirements then this method will behave\n     * as follows:\n     *\n     * <ul>\n     *     <li>If the calling app's target SDK is API level 28 or lower and the app has the\n     *     READ_PHONE_STATE permission then null is returned.</li>\n     *     <li>If the calling app's target SDK is API level 28 or lower and the app does not have\n     *     the READ_PHONE_STATE permission, or if the calling app is targeting API level 29 or\n     *     higher, then a SecurityException is thrown.</li>\n     * </ul>\n     *\n     * @param slotIndex of which IMEI is returned\n     ",
    "links" : [ "Manifest.permission#READ_PHONE_STATE", "#hasCarrierPrivileges", "android.app.role.RoleManager#isRoleHeld(String)" ]
  }, {
    "name" : "public String getTypeAllocationCode()",
    "returnType" : "String",
    "comment" : "\n     * Returns the Type Allocation Code from the IMEI. Return null if Type Allocation Code is not\n     * available.\n     ",
    "links" : [ ]
  }, {
    "name" : "public String getTypeAllocationCode(int slotIndex)",
    "returnType" : "String",
    "comment" : "\n     * Returns the Type Allocation Code from the IMEI. Return null if Type Allocation Code is not\n     * available.\n     *\n     * @param slotIndex of which Type Allocation Code is returned\n     ",
    "links" : [ ]
  }, {
    "name" : "public String getMeid()",
    "returnType" : "String",
    "comment" : "\n     * Returns the MEID (Mobile Equipment Identifier). Return null if MEID is not available.\n     *\n     * <p>Starting with API level 29, persistent device identifiers are guarded behind additional\n     * restrictions, and apps are recommended to use resettable identifiers (see <a\n     * href=\"c\"> Best practices for unique identifiers</a>). This method can be invoked if one of\n     * the following requirements is met:\n     * <ul>\n     *     <li>If the calling app has been granted the READ_PRIVILEGED_PHONE_STATE permission; this\n     *     is a privileged permission that can only be granted to apps preloaded on the device.\n     *     <li>If the calling app is the device or profile owner and has been granted the\n     *     {@link Manifest.permission#READ_PHONE_STATE} permission. The profile owner is an app that\n     *     owns a managed profile on the device; for more details see <a\n     *     href=\"https://developer.android.com/work/managed-profiles\">Work profiles</a>.\n     *     Profile owner access is deprecated and will be removed in a future release.\n     *     <li>If the calling app has carrier privileges (see {@link #hasCarrierPrivileges}) on any\n     *     active subscription.\n     *     <li>If the calling app is the default SMS role holder (see {@link\n     *     RoleManager#isRoleHeld(String)}).\n     * </ul>\n     *\n     * <p>If the calling app does not meet one of these requirements then this method will behave\n     * as follows:\n     *\n     * <ul>\n     *     <li>If the calling app's target SDK is API level 28 or lower and the app has the\n     *     READ_PHONE_STATE permission then null is returned.</li>\n     *     <li>If the calling app's target SDK is API level 28 or lower and the app does not have\n     *     the READ_PHONE_STATE permission, or if the calling app is targeting API level 29 or\n     *     higher, then a SecurityException is thrown.</li>\n     * </ul>\n     ",
    "links" : [ "Manifest.permission#READ_PHONE_STATE", "#hasCarrierPrivileges", "android.app.role.RoleManager#isRoleHeld(String)" ]
  }, {
    "name" : "public String getMeid(int slotIndex)",
    "returnType" : "String",
    "comment" : "\n     * Returns the MEID (Mobile Equipment Identifier). Return null if MEID is not available.\n     *\n     * <p>Starting with API level 29, persistent device identifiers are guarded behind additional\n     * restrictions, and apps are recommended to use resettable identifiers (see <a\n     * href=\"c\"> Best practices for unique identifiers</a>). This method can be invoked if one of\n     * the following requirements is met:\n     * <ul>\n     *     <li>If the calling app has been granted the READ_PRIVILEGED_PHONE_STATE permission; this\n     *     is a privileged permission that can only be granted to apps preloaded on the device.\n     *     <li>If the calling app is the device or profile owner and has been granted the\n     *     {@link Manifest.permission#READ_PHONE_STATE} permission. The profile owner is an app that\n     *     owns a managed profile on the device; for more details see <a\n     *     href=\"https://developer.android.com/work/managed-profiles\">Work profiles</a>.\n     *     Profile owner access is deprecated and will be removed in a future release.\n     *     <li>If the calling app has carrier privileges (see {@link #hasCarrierPrivileges}) on any\n     *     active subscription.\n     *     <li>If the calling app is the default SMS role holder (see {@link\n     *     RoleManager#isRoleHeld(String)}).\n     * </ul>\n     *\n     * <p>If the calling app does not meet one of these requirements then this method will behave\n     * as follows:\n     *\n     * <ul>\n     *     <li>If the calling app's target SDK is API level 28 or lower and the app has the\n     *     READ_PHONE_STATE permission then null is returned.</li>\n     *     <li>If the calling app's target SDK is API level 28 or lower and the app does not have\n     *     the READ_PHONE_STATE permission, or if the calling app is targeting API level 29 or\n     *     higher, then a SecurityException is thrown.</li>\n     * </ul>\n     *\n     * @param slotIndex of which MEID is returned\n     ",
    "links" : [ "Manifest.permission#READ_PHONE_STATE", "#hasCarrierPrivileges", "android.app.role.RoleManager#isRoleHeld(String)" ]
  }, {
    "name" : "public String getManufacturerCode()",
    "returnType" : "String",
    "comment" : "\n     * Returns the Manufacturer Code from the MEID. Return null if Manufacturer Code is not\n     * available.\n     ",
    "links" : [ ]
  }, {
    "name" : "public String getManufacturerCode(int slotIndex)",
    "returnType" : "String",
    "comment" : "\n     * Returns the Manufacturer Code from the MEID. Return null if Manufacturer Code is not\n     * available.\n     *\n     * @param slotIndex of which Type Allocation Code is returned\n     ",
    "links" : [ ]
  }, {
    "name" : "public String getNai()",
    "returnType" : "String",
    "comment" : "\n     * Returns the Network Access Identifier (NAI). Return null if NAI is not available.\n     *\n     * <p>Starting with API level 29, persistent device identifiers are guarded behind additional\n     * restrictions, and apps are recommended to use resettable identifiers (see <a\n     * href=\"c\"> Best practices for unique identifiers</a>). This method can be invoked if one of\n     * the following requirements is met:\n     * <ul>\n     *     <li>If the calling app has been granted the READ_PRIVILEGED_PHONE_STATE permission; this\n     *     is a privileged permission that can only be granted to apps preloaded on the device.\n     *     <li>If the calling app is the device or profile owner and has been granted the\n     *     {@link Manifest.permission#READ_PHONE_STATE} permission. The profile owner is an app that\n     *     owns a managed profile on the device; for more details see <a\n     *     href=\"https://developer.android.com/work/managed-profiles\">Work profiles</a>.\n     *     Profile owner access is deprecated and will be removed in a future release.\n     *     <li>If the calling app has carrier privileges (see {@link #hasCarrierPrivileges}).\n     *     <li>If the calling app is the default SMS role holder (see {@link\n     *     RoleManager#isRoleHeld(String)}).\n     * </ul>\n     *\n     * <p>If the calling app does not meet one of these requirements then this method will behave\n     * as follows:\n     *\n     * <ul>\n     *     <li>If the calling app's target SDK is API level 28 or lower and the app has the\n     *     READ_PHONE_STATE permission then null is returned.</li>\n     *     <li>If the calling app's target SDK is API level 28 or lower and the app does not have\n     *     the READ_PHONE_STATE permission, or if the calling app is targeting API level 29 or\n     *     higher, then a SecurityException is thrown.</li>\n     * </ul>\n     ",
    "links" : [ "Manifest.permission#READ_PHONE_STATE", "#hasCarrierPrivileges", "android.app.role.RoleManager#isRoleHeld(String)" ]
  }, {
    "name" : "public String getNai(int slotIndex)",
    "returnType" : "String",
    "comment" : " {@hide}",
    "links" : [ ]
  }, {
    "name" : "private String getNaiBySubscriberId(int subId)",
    "returnType" : "String",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public CellLocation getCellLocation()",
    "returnType" : "CellLocation",
    "comment" : "\n     * Returns the current location of the device.\n     *<p>\n     * If there is only one radio in the device and that radio has an LTE connection,\n     * this method will return null. The implementation must not to try add LTE\n     * identifiers into the existing cdma/gsm classes.\n     *<p>\n     * @return Current location of the device or null if not available.\n     *\n     * @deprecated use {@link #getAllCellInfo} instead, which returns a superset of this API.\n     ",
    "links" : [ "#getAllCellInfo" ]
  }, {
    "name" : "public void enableLocationUpdates()",
    "returnType" : "void",
    "comment" : "\n     * Enables location update notifications.  {@link PhoneStateListener#onCellLocationChanged\n     * PhoneStateListener.onCellLocationChanged} will be called on location updates.\n     *\n     * @hide\n     ",
    "links" : [ "android.telephony.PhoneStateListener#onCellLocationChangedPhoneStateListener.onCellLocationChanged" ]
  }, {
    "name" : "public void enableLocationUpdates(int subId)",
    "returnType" : "void",
    "comment" : "\n     * Enables location update notifications for a subscription.\n     * {@link PhoneStateListener#onCellLocationChanged\n     * PhoneStateListener.onCellLocationChanged} will be called on location updates.\n     *\n     * @param subId for which the location updates are enabled\n     * @hide\n     ",
    "links" : [ "android.telephony.PhoneStateListener#onCellLocationChangedPhoneStateListener.onCellLocationChanged" ]
  }, {
    "name" : "public void disableLocationUpdates()",
    "returnType" : "void",
    "comment" : "\n     * Disables location update notifications.  {@link PhoneStateListener#onCellLocationChanged\n     * PhoneStateListener.onCellLocationChanged} will be called on location updates.\n     *\n     * @hide\n     ",
    "links" : [ "android.telephony.PhoneStateListener#onCellLocationChangedPhoneStateListener.onCellLocationChanged" ]
  }, {
    "name" : "public void disableLocationUpdates(int subId)",
    "returnType" : "void",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "public List<NeighboringCellInfo> getNeighboringCellInfo()",
    "returnType" : "List<NeighboringCellInfo>",
    "comment" : "\n     * Returns the neighboring cell information of the device.\n     *\n     * @return List of NeighboringCellInfo or null if info unavailable.\n     *\n     * @removed\n     * @deprecated Use {@link #getAllCellInfo} which returns a superset of the information\n     *             from NeighboringCellInfo, including LTE cell information.\n     ",
    "links" : [ "#getAllCellInfo" ]
  }, {
    "name" : "public int getCurrentPhoneType()",
    "returnType" : "int",
    "comment" : "\n     * Returns the current phone type.\n     * TODO: This is a last minute change and hence hidden.\n     *\n     * @see #PHONE_TYPE_NONE\n     * @see #PHONE_TYPE_GSM\n     * @see #PHONE_TYPE_CDMA\n     * @see #PHONE_TYPE_SIP\n     *\n     * {@hide}\n     ",
    "links" : [ ]
  }, {
    "name" : "public int getCurrentPhoneType(int subId)",
    "returnType" : "int",
    "comment" : "\n     * Returns a constant indicating the device phone type for a subscription.\n     *\n     * @see #PHONE_TYPE_NONE\n     * @see #PHONE_TYPE_GSM\n     * @see #PHONE_TYPE_CDMA\n     *\n     * @param subId for which phone type is returned\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public int getCurrentPhoneTypeForSlot(int slotIndex)",
    "returnType" : "int",
    "comment" : "\n     * See getCurrentPhoneType.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public int getPhoneType()",
    "returnType" : "int",
    "comment" : "\n     * Returns a constant indicating the device phone type.  This\n     * indicates the type of radio used to transmit voice calls.\n     *\n     * @see #PHONE_TYPE_NONE\n     * @see #PHONE_TYPE_GSM\n     * @see #PHONE_TYPE_CDMA\n     * @see #PHONE_TYPE_SIP\n     ",
    "links" : [ ]
  }, {
    "name" : "private int getPhoneTypeFromProperty()",
    "returnType" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private int getPhoneTypeFromProperty(int phoneId)",
    "returnType" : "int",
    "comment" : " {@hide} ",
    "links" : [ ]
  }, {
    "name" : "private int getPhoneTypeFromNetworkType()",
    "returnType" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private int getPhoneTypeFromNetworkType(int phoneId)",
    "returnType" : "int",
    "comment" : " {@hide} ",
    "links" : [ ]
  }, {
    "name" : "public static int getPhoneType(int networkMode)",
    "returnType" : "int",
    "comment" : "\n     * This function returns the type of the phone, depending\n     * on the network mode.\n     *\n     * @param networkMode\n     * @return Phone Type\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "private static String getProcCmdLine()",
    "returnType" : "String",
    "comment" : "\n     * The contents of the /proc/cmdline file\n     ",
    "links" : [ ]
  }, {
    "name" : "public static long getMaxNumberVerificationTimeoutMillis()",
    "returnType" : "long",
    "comment" : "\n     * @return The max value for the timeout passed in {@link #requestNumberVerification}.\n     * @hide\n     ",
    "links" : [ "#requestNumberVerification" ]
  }, {
    "name" : "public static int getLteOnCdmaModeStatic()",
    "returnType" : "int",
    "comment" : "\n     * Return if the current radio is LTE on CDMA. This\n     * is a tri-state return value as for a period of time\n     * the mode may be unknown.\n     *\n     * @return {@link PhoneConstants#LTE_ON_CDMA_UNKNOWN}, {@link PhoneConstants#LTE_ON_CDMA_FALSE}\n     * or {@link PhoneConstants#LTE_ON_CDMA_TRUE}\n     *\n     * @hide\n     ",
    "links" : [ "com.android.internal.telephony.PhoneConstants#LTE_ON_CDMA_UNKNOWN", "com.android.internal.telephony.PhoneConstants#LTE_ON_CDMA_FALSE", "com.android.internal.telephony.PhoneConstants#LTE_ON_CDMA_TRUE" ]
  }, {
    "name" : "public String getNetworkOperatorName()",
    "returnType" : "String",
    "comment" : "\n     * Returns the alphabetic name of current registered operator.\n     * <p>\n     * Availability: Only when user is registered to a network. Result may be\n     * unreliable on CDMA networks (use {@link #getPhoneType()} to determine if\n     * on a CDMA network).\n     ",
    "links" : [ "#getPhoneType()" ]
  }, {
    "name" : "public String getNetworkOperatorName(int subId)",
    "returnType" : "String",
    "comment" : "\n     * Returns the alphabetic name of current registered operator\n     * for a particular subscription.\n     * <p>\n     * Availability: Only when user is registered to a network. Result may be\n     * unreliable on CDMA networks (use {@link #getPhoneType()} to determine if\n     * on a CDMA network).\n     * @param subId\n     * @hide\n     ",
    "links" : [ "#getPhoneType()" ]
  }, {
    "name" : "public String getNetworkOperator()",
    "returnType" : "String",
    "comment" : "\n     * Returns the numeric name (MCC+MNC) of current registered operator.\n     * <p>\n     * Availability: Only when user is registered to a network. Result may be\n     * unreliable on CDMA networks (use {@link #getPhoneType()} to determine if\n     * on a CDMA network).\n     ",
    "links" : [ "#getPhoneType()" ]
  }, {
    "name" : "public String getNetworkOperator(int subId)",
    "returnType" : "String",
    "comment" : "\n     * Returns the numeric name (MCC+MNC) of current registered operator\n     * for a particular subscription.\n     * <p>\n     * Availability: Only when user is registered to a network. Result may be\n     * unreliable on CDMA networks (use {@link #getPhoneType()} to determine if\n     * on a CDMA network).\n     *\n     * @param subId\n     * @hide\n     ",
    "links" : [ "#getPhoneType()" ]
  }, {
    "name" : "public String getNetworkOperatorForPhone(int phoneId)",
    "returnType" : "String",
    "comment" : "\n     * Returns the numeric name (MCC+MNC) of current registered operator\n     * for a particular subscription.\n     * <p>\n     * Availability: Only when user is registered to a network. Result may be\n     * unreliable on CDMA networks (use {@link #getPhoneType()} to determine if\n     * on a CDMA network).\n     *\n     * @param phoneId\n     * @hide\n     *",
    "links" : [ "#getPhoneType()" ]
  }, {
    "name" : "public String getNetworkSpecifier()",
    "returnType" : "String",
    "comment" : "\n     * Returns the network specifier of the subscription ID pinned to the TelephonyManager. The\n     * network specifier is used by {@link\n     * android.net.NetworkRequest.Builder#setNetworkSpecifier(String)} to create a {@link\n     * android.net.NetworkRequest} that connects through the subscription.\n     *\n     * @see android.net.NetworkRequest.Builder#setNetworkSpecifier(String)\n     * @see #createForSubscriptionId(int)\n     * @see #createForPhoneAccountHandle(PhoneAccountHandle)\n     ",
    "links" : [ "android.net.NetworkRequest.Builder#setNetworkSpecifier(String)", "android.net.NetworkRequest" ]
  }, {
    "name" : "public PersistableBundle getCarrierConfig()",
    "returnType" : "PersistableBundle",
    "comment" : "\n     * Returns the carrier config of the subscription ID pinned to the TelephonyManager. If an\n     * invalid subscription ID is pinned to the TelephonyManager, the returned config will contain\n     * default values.\n     *\n     * <p>This method may take several seconds to complete, so it should only be called from a\n     * worker thread.\n     *\n     * <p>Requires Permission: {@link android.Manifest.permission#READ_PHONE_STATE READ_PHONE_STATE}\n     * or that the calling app has carrier privileges (see {@link #hasCarrierPrivileges}).\n     *\n     * @see CarrierConfigManager#getConfigForSubId(int)\n     * @see #createForSubscriptionId(int)\n     * @see #createForPhoneAccountHandle(PhoneAccountHandle)\n     ",
    "links" : [ "#hasCarrierPrivileges", "android.Manifest.permission#READ_PHONE_STATE" ]
  }, {
    "name" : "public boolean isNetworkRoaming()",
    "returnType" : "boolean",
    "comment" : "\n     * Returns true if the device is considered roaming on the current\n     * network, for GSM purposes.\n     * <p>\n     * Availability: Only when user registered to a network.\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean isNetworkRoaming(int subId)",
    "returnType" : "boolean",
    "comment" : "\n     * Returns true if the device is considered roaming on the current\n     * network for a subscription.\n     * <p>\n     * Availability: Only when user registered to a network.\n     *\n     * @param subId\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public String getNetworkCountryIso()",
    "returnType" : "String",
    "comment" : "\n     * Returns the ISO-3166-1 alpha-2 country code equivalent of the MCC (Mobile Country Code) of\n     * the current registered operator or the cell nearby, if available.\n     *\n     * Note: Result may be unreliable on CDMA networks (use {@link #getPhoneType()} to determine\n     * if on a CDMA network).\n     * <p>\n     * @return the lowercase 2 character ISO-3166-1 alpha-2 country code, or empty string if not\n     * available.\n     ",
    "links" : [ "#getPhoneType()" ]
  }, {
    "name" : "public String getNetworkCountryIso(int slotIndex)",
    "returnType" : "String",
    "comment" : "\n     * Returns the ISO-3166-1 alpha-2 country code equivalent of the MCC (Mobile Country Code) of\n     * the current registered operator or the cell nearby, if available. This is same as\n     * {@link #getNetworkCountryIso()} but allowing specifying the SIM slot index. This is used for\n     * accessing network country info from the SIM slot that does not have SIM inserted.\n     *\n     * Note: Result may be unreliable on CDMA networks (use {@link #getPhoneType()} to determine\n     * if on a CDMA network).\n     * <p>\n     *\n     * @param slotIndex the SIM slot index to get network country ISO.\n     *\n     * @return the lowercase 2 character ISO-3166-1 alpha-2 country code, or empty string if not\n     * available.\n     *\n     * @throws IllegalArgumentException when the slotIndex is invalid.\n     *\n     ",
    "links" : [ "#getPhoneType()", "#getNetworkCountryIso()" ]
  }, {
    "name" : "public String getNetworkCountryIsoForPhone(int phoneId)",
    "returnType" : "String",
    "comment" : "\n     * @hide\n     * @deprecated Use {@link #getNetworkCountryIso(int)} instead.\n     ",
    "links" : [ "#getNetworkCountryIso(int)" ]
  }, {
    "name" : "public static int[] getAllNetworkTypes()",
    "returnType" : "int[]",
    "comment" : "\n     * Return a collection of all network types\n     * @return network types\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public int getNetworkType()",
    "returnType" : "int",
    "comment" : "\n     * Return the current data network type.\n     *\n     * @deprecated use {@link #getDataNetworkType()}\n     * @return the NETWORK_TYPE_xxxx for current data connection.\n     ",
    "links" : [ "#getDataNetworkType()" ]
  }, {
    "name" : "public int getNetworkType(int subId)",
    "returnType" : "int",
    "comment" : "\n     * Returns a constant indicating the radio technology (network type)\n     * currently in use on the device for a subscription.\n     * @return the network type\n     *\n     * @param subId for which network type is returned\n     *\n     * @see #NETWORK_TYPE_UNKNOWN\n     * @see #NETWORK_TYPE_GPRS\n     * @see #NETWORK_TYPE_EDGE\n     * @see #NETWORK_TYPE_UMTS\n     * @see #NETWORK_TYPE_HSDPA\n     * @see #NETWORK_TYPE_HSUPA\n     * @see #NETWORK_TYPE_HSPA\n     * @see #NETWORK_TYPE_CDMA\n     * @see #NETWORK_TYPE_EVDO_0\n     * @see #NETWORK_TYPE_EVDO_A\n     * @see #NETWORK_TYPE_EVDO_B\n     * @see #NETWORK_TYPE_1xRTT\n     * @see #NETWORK_TYPE_IDEN\n     * @see #NETWORK_TYPE_LTE\n     * @see #NETWORK_TYPE_EHRPD\n     * @see #NETWORK_TYPE_HSPAP\n     * @see #NETWORK_TYPE_NR\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public int getDataNetworkType()",
    "returnType" : "int",
    "comment" : "\n     * Returns a constant indicating the radio technology (network type)\n     * currently in use on the device for data transmission.\n     *\n     * If this object has been created with {@link #createForSubscriptionId}, applies to the given\n     * subId. Otherwise, applies to {@link SubscriptionManager#getDefaultDataSubscriptionId()}\n     *\n     * <p>Requires Permission: {@link android.Manifest.permission#READ_PHONE_STATE READ_PHONE_STATE}\n     * or that the calling app has carrier privileges (see {@link #hasCarrierPrivileges}).\n     *\n     * @return the network type\n     *\n     * @see #NETWORK_TYPE_UNKNOWN\n     * @see #NETWORK_TYPE_GPRS\n     * @see #NETWORK_TYPE_EDGE\n     * @see #NETWORK_TYPE_UMTS\n     * @see #NETWORK_TYPE_HSDPA\n     * @see #NETWORK_TYPE_HSUPA\n     * @see #NETWORK_TYPE_HSPA\n     * @see #NETWORK_TYPE_CDMA\n     * @see #NETWORK_TYPE_EVDO_0\n     * @see #NETWORK_TYPE_EVDO_A\n     * @see #NETWORK_TYPE_EVDO_B\n     * @see #NETWORK_TYPE_1xRTT\n     * @see #NETWORK_TYPE_IDEN\n     * @see #NETWORK_TYPE_LTE\n     * @see #NETWORK_TYPE_EHRPD\n     * @see #NETWORK_TYPE_HSPAP\n     * @see #NETWORK_TYPE_NR\n     ",
    "links" : [ "#createForSubscriptionId", "android.telephony.SubscriptionManager#getDefaultDataSubscriptionId()", "#hasCarrierPrivileges", "android.Manifest.permission#READ_PHONE_STATE" ]
  }, {
    "name" : "public int getDataNetworkType(int subId)",
    "returnType" : "int",
    "comment" : "\n     * Returns a constant indicating the radio technology (network type)\n     * currently in use on the device for data transmission for a subscription\n     * @return the network type\n     *\n     * @param subId for which network type is returned\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public int getVoiceNetworkType()",
    "returnType" : "int",
    "comment" : "\n     * Returns the NETWORK_TYPE_xxxx for voice\n     *\n     * <p>Requires Permission: {@link android.Manifest.permission#READ_PHONE_STATE READ_PHONE_STATE}\n     * or that the calling app has carrier privileges (see {@link #hasCarrierPrivileges}).\n     ",
    "links" : [ "#hasCarrierPrivileges", "android.Manifest.permission#READ_PHONE_STATE" ]
  }, {
    "name" : "public int getVoiceNetworkType(int subId)",
    "returnType" : "int",
    "comment" : "\n     * Returns the NETWORK_TYPE_xxxx for voice for a subId\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public String getNetworkTypeName()",
    "returnType" : "String",
    "comment" : "\n     * Returns a string representation of the radio technology (network type)\n     * currently in use on the device.\n     * @return the name of the radio technology\n     *\n     * @hide pending API council review\n     ",
    "links" : [ ]
  }, {
    "name" : "public static String getNetworkTypeName(@NetworkType int type)",
    "returnType" : "String",
    "comment" : " {@hide} ",
    "links" : [ ]
  }, {
    "name" : "public static long getBitMaskForNetworkType(@NetworkType int networkType)",
    "returnType" : "long",
    "comment" : "\n     * Returns the bitmask for a given technology (network type)\n     * @param networkType for which bitmask is returned\n     * @return the network type bitmask\n     * {@hide}\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean hasIccCard()",
    "returnType" : "boolean",
    "comment" : "\n     * @return true if a ICC card is present\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean hasIccCard(int slotIndex)",
    "returnType" : "boolean",
    "comment" : " FIXME Input argument slotIndex should be of type int",
    "links" : [ ]
  }, {
    "name" : "public int getSimState()",
    "returnType" : "int",
    "comment" : "\n     * Returns a constant indicating the state of the default SIM card.\n     *\n     * @see #SIM_STATE_UNKNOWN\n     * @see #SIM_STATE_ABSENT\n     * @see #SIM_STATE_PIN_REQUIRED\n     * @see #SIM_STATE_PUK_REQUIRED\n     * @see #SIM_STATE_NETWORK_LOCKED\n     * @see #SIM_STATE_READY\n     * @see #SIM_STATE_NOT_READY\n     * @see #SIM_STATE_PERM_DISABLED\n     * @see #SIM_STATE_CARD_IO_ERROR\n     * @see #SIM_STATE_CARD_RESTRICTED\n     ",
    "links" : [ ]
  }, {
    "name" : "private int getSimStateIncludingLoaded()",
    "returnType" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public int getSimCardState()",
    "returnType" : "int",
    "comment" : "\n     * Returns a constant indicating the state of the default SIM card.\n     *\n     * @see #SIM_STATE_UNKNOWN\n     * @see #SIM_STATE_ABSENT\n     * @see #SIM_STATE_CARD_IO_ERROR\n     * @see #SIM_STATE_CARD_RESTRICTED\n     * @see #SIM_STATE_PRESENT\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public int getSimCardState(int physicalSlotIndex)",
    "returnType" : "int",
    "comment" : "\n     * Returns a constant indicating the state of the device SIM card in a physical slot.\n     *\n     * @param physicalSlotIndex physical slot index\n     *\n     * @see #SIM_STATE_UNKNOWN\n     * @see #SIM_STATE_ABSENT\n     * @see #SIM_STATE_CARD_IO_ERROR\n     * @see #SIM_STATE_CARD_RESTRICTED\n     * @see #SIM_STATE_PRESENT\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "private int getSimCardStateFromSimState(int simState)",
    "returnType" : "int",
    "comment" : "\n     * Converts SIM state to SIM card state.\n     * @param simState\n     * @return SIM card state\n     ",
    "links" : [ ]
  }, {
    "name" : "private int getLogicalSlotIndex(int physicalSlotIndex)",
    "returnType" : "int",
    "comment" : "\n     * Converts a physical slot index to logical slot index.\n     * @param physicalSlotIndex physical slot index\n     * @return logical slot index\n     ",
    "links" : [ ]
  }, {
    "name" : "public int getSimApplicationState()",
    "returnType" : "int",
    "comment" : "\n     * Returns a constant indicating the state of the card applications on the default SIM card.\n     *\n     * @see #SIM_STATE_UNKNOWN\n     * @see #SIM_STATE_PIN_REQUIRED\n     * @see #SIM_STATE_PUK_REQUIRED\n     * @see #SIM_STATE_NETWORK_LOCKED\n     * @see #SIM_STATE_NOT_READY\n     * @see #SIM_STATE_PERM_DISABLED\n     * @see #SIM_STATE_LOADED\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public int getSimApplicationState(int physicalSlotIndex)",
    "returnType" : "int",
    "comment" : "\n     * Returns a constant indicating the state of the card applications on the device SIM card in\n     * a physical slot.\n     *\n     * @param physicalSlotIndex physical slot index\n     *\n     * @see #SIM_STATE_UNKNOWN\n     * @see #SIM_STATE_PIN_REQUIRED\n     * @see #SIM_STATE_PUK_REQUIRED\n     * @see #SIM_STATE_NETWORK_LOCKED\n     * @see #SIM_STATE_NOT_READY\n     * @see #SIM_STATE_PERM_DISABLED\n     * @see #SIM_STATE_LOADED\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "private int getSimApplicationStateFromSimState(int simState)",
    "returnType" : "int",
    "comment" : "\n     * Converts SIM state to SIM application state.\n     * @param simState\n     * @return SIM application state\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean isApplicationOnUicc(@UiccAppType int appType)",
    "returnType" : "boolean",
    "comment" : "\n     * Returns true if the specified type of application (e.g. {@link #APPTYPE_CSIM} is present\n     * on the UICC card.\n     *\n     * Requires that the calling app has READ_PRIVILEGED_PHONE_STATE permission\n     *\n     * @param appType the uicc app type like {@link APPTYPE_CSIM}\n     * @return true if the specified type of application in UICC CARD or false if no uicc or error.\n     * @hide\n     ",
    "links" : [ "#APPTYPE_CSIM", "APPTYPE_CSIM" ]
  }, {
    "name" : "public int getSimState(int slotIndex)",
    "returnType" : "int",
    "comment" : "\n     * Returns a constant indicating the state of the device SIM card in a logical slot.\n     *\n     * @param slotIndex logical slot index\n     *\n     * @see #SIM_STATE_UNKNOWN\n     * @see #SIM_STATE_ABSENT\n     * @see #SIM_STATE_PIN_REQUIRED\n     * @see #SIM_STATE_PUK_REQUIRED\n     * @see #SIM_STATE_NETWORK_LOCKED\n     * @see #SIM_STATE_READY\n     * @see #SIM_STATE_NOT_READY\n     * @see #SIM_STATE_PERM_DISABLED\n     * @see #SIM_STATE_CARD_IO_ERROR\n     * @see #SIM_STATE_CARD_RESTRICTED\n     ",
    "links" : [ ]
  }, {
    "name" : "public String getSimOperator()",
    "returnType" : "String",
    "comment" : "\n     * Returns the MCC+MNC (mobile country code + mobile network code) of the\n     * provider of the SIM. 5 or 6 decimal digits.\n     * <p>\n     * Availability: SIM state must be {@link #SIM_STATE_READY}\n     *\n     * @see #getSimState\n     ",
    "links" : [ "#SIM_STATE_READY" ]
  }, {
    "name" : "public String getSimOperator(int subId)",
    "returnType" : "String",
    "comment" : "\n     * Returns the MCC+MNC (mobile country code + mobile network code) of the\n     * provider of the SIM. 5 or 6 decimal digits.\n     * <p>\n     * Availability: SIM state must be {@link #SIM_STATE_READY}\n     *\n     * @see #getSimState\n     *\n     * @param subId for which SimOperator is returned\n     * @hide\n     ",
    "links" : [ "#SIM_STATE_READY" ]
  }, {
    "name" : "public String getSimOperatorNumeric()",
    "returnType" : "String",
    "comment" : "\n     * Returns the MCC+MNC (mobile country code + mobile network code) of the\n     * provider of the SIM. 5 or 6 decimal digits.\n     * <p>\n     * Availability: SIM state must be {@link #SIM_STATE_READY}\n     *\n     * @see #getSimState\n     * @hide\n     ",
    "links" : [ "#SIM_STATE_READY" ]
  }, {
    "name" : "public String getSimOperatorNumeric(int subId)",
    "returnType" : "String",
    "comment" : "\n     * Returns the MCC+MNC (mobile country code + mobile network code) of the\n     * provider of the SIM for a particular subscription. 5 or 6 decimal digits.\n     * <p>\n     * Availability: SIM state must be {@link #SIM_STATE_READY}\n     *\n     * @see #getSimState\n     *\n     * @param subId for which SimOperator is returned\n     * @hide\n     ",
    "links" : [ "#SIM_STATE_READY" ]
  }, {
    "name" : "public String getSimOperatorNumericForPhone(int phoneId)",
    "returnType" : "String",
    "comment" : "\n     * Returns the MCC+MNC (mobile country code + mobile network code) of the\n     * provider of the SIM for a particular subscription. 5 or 6 decimal digits.\n     * <p>\n     *\n     * @param phoneId for which SimOperator is returned\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public String getSimOperatorName()",
    "returnType" : "String",
    "comment" : "\n     * Returns the Service Provider Name (SPN).\n     * <p>\n     * Availability: SIM state must be {@link #SIM_STATE_READY}\n     *\n     * @see #getSimState\n     ",
    "links" : [ "#SIM_STATE_READY" ]
  }, {
    "name" : "public String getSimOperatorName(int subId)",
    "returnType" : "String",
    "comment" : "\n     * Returns the Service Provider Name (SPN).\n     * <p>\n     * Availability: SIM state must be {@link #SIM_STATE_READY}\n     *\n     * @see #getSimState\n     *\n     * @param subId for which SimOperatorName is returned\n     * @hide\n     ",
    "links" : [ "#SIM_STATE_READY" ]
  }, {
    "name" : "public String getSimOperatorNameForPhone(int phoneId)",
    "returnType" : "String",
    "comment" : "\n     * Returns the Service Provider Name (SPN).\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public String getSimCountryIso()",
    "returnType" : "String",
    "comment" : "\n     * Returns the ISO-3166-1 alpha-2 country code equivalent for the SIM provider's country code.\n     * <p>\n     * The ISO-3166-1 alpha-2 country code is provided in lowercase 2 character format.\n     * @return the lowercase 2 character ISO-3166-1 alpha-2 country code, or empty string is not\n     * available.\n     ",
    "links" : [ ]
  }, {
    "name" : "public static String getSimCountryIso(int subId)",
    "returnType" : "String",
    "comment" : "\n     * Returns the ISO country code equivalent for the SIM provider's country code.\n     *\n     * @param subId for which SimCountryIso is returned\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public static String getSimCountryIsoForPhone(int phoneId)",
    "returnType" : "String",
    "comment" : "\n     * Returns the ISO country code equivalent for the SIM provider's country code.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public String getSimSerialNumber()",
    "returnType" : "String",
    "comment" : "\n     * Returns the serial number of the SIM, if applicable. Return null if it is\n     * unavailable.\n     *\n     * <p>Starting with API level 29, persistent device identifiers are guarded behind additional\n     * restrictions, and apps are recommended to use resettable identifiers (see <a\n     * href=\"c\"> Best practices for unique identifiers</a>). This method can be invoked if one of\n     * the following requirements is met:\n     * <ul>\n     *     <li>If the calling app has been granted the READ_PRIVILEGED_PHONE_STATE permission; this\n     *     is a privileged permission that can only be granted to apps preloaded on the device.\n     *     <li>If the calling app is the device or profile owner and has been granted the\n     *     {@link Manifest.permission#READ_PHONE_STATE} permission. The profile owner is an app that\n     *     owns a managed profile on the device; for more details see <a\n     *     href=\"https://developer.android.com/work/managed-profiles\">Work profiles</a>.\n     *     Profile owner access is deprecated and will be removed in a future release.\n     *     <li>If the calling app has carrier privileges (see {@link #hasCarrierPrivileges}).\n     *     <li>If the calling app is the default SMS role holder (see {@link\n     *     RoleManager#isRoleHeld(String)}).\n     * </ul>\n     *\n     * <p>If the calling app does not meet one of these requirements then this method will behave\n     * as follows:\n     *\n     * <ul>\n     *     <li>If the calling app's target SDK is API level 28 or lower and the app has the\n     *     READ_PHONE_STATE permission then null is returned.</li>\n     *     <li>If the calling app's target SDK is API level 28 or lower and the app does not have\n     *     the READ_PHONE_STATE permission, or if the calling app is targeting API level 29 or\n     *     higher, then a SecurityException is thrown.</li>\n     * </ul>\n     ",
    "links" : [ "Manifest.permission#READ_PHONE_STATE", "#hasCarrierPrivileges", "android.app.role.RoleManager#isRoleHeld(String)" ]
  }, {
    "name" : "public String getSimSerialNumber(int subId)",
    "returnType" : "String",
    "comment" : "\n     * Returns the serial number for the given subscription, if applicable. Return null if it is\n     * unavailable.\n     *\n     * <p>Starting with API level 29, persistent device identifiers are guarded behind additional\n     * restrictions, and apps are recommended to use resettable identifiers (see <a\n     * href=\"c\"> Best practices for unique identifiers</a>). This method can be invoked if one of\n     * the following requirements is met:\n     * <ul>\n     *     <li>If the calling app has been granted the READ_PRIVILEGED_PHONE_STATE permission; this\n     *     is a privileged permission that can only be granted to apps preloaded on the device.\n     *     <li>If the calling app is the device or profile owner and has been granted the\n     *     {@link Manifest.permission#READ_PHONE_STATE} permission. The profile owner is an app that\n     *     owns a managed profile on the device; for more details see <a\n     *     href=\"https://developer.android.com/work/managed-profiles\">Work profiles</a>.\n     *     Profile owner access is deprecated and will be removed in a future release.\n     *     <li>If the calling app has carrier privileges (see {@link #hasCarrierPrivileges}).\n     *     <li>If the calling app is the default SMS role holder (see {@link\n     *     RoleManager#isRoleHeld(String)}).\n     * </ul>\n     *\n     * <p>If the calling app does not meet one of these requirements then this method will behave\n     * as follows:\n     *\n     * <ul>\n     *     <li>If the calling app's target SDK is API level 28 or lower and the app has the\n     *     READ_PHONE_STATE permission then null is returned.</li>\n     *     <li>If the calling app's target SDK is API level 28 or lower and the app does not have\n     *     the READ_PHONE_STATE permission, or if the calling app is targeting API level 29 or\n     *     higher, then a SecurityException is thrown.</li>\n     * </ul>\n     *\n     * @param subId for which Sim Serial number is returned\n     * @hide\n     ",
    "links" : [ "Manifest.permission#READ_PHONE_STATE", "#hasCarrierPrivileges", "android.app.role.RoleManager#isRoleHeld(String)" ]
  }, {
    "name" : "public boolean isLteCdmaEvdoGsmWcdmaEnabled()",
    "returnType" : "boolean",
    "comment" : "\n     * Return if the current radio can support both 3GPP and 3GPP2 radio technologies at the same\n     * time. This is also known as global mode, which includes LTE, CDMA, EvDo and GSM/WCDMA.\n     *\n     * <p>If this object has been created with {@link #createForSubscriptionId}, applies to the\n     * given subId. Otherwise, applies to {@link SubscriptionManager#getDefaultSubscriptionId()}.\n     *\n     * @return {@code true} if 3GPP and 3GPP2 radio technologies can be supported at the same time\n     *         {@code false} if not supported or unknown\n     * @hide\n     ",
    "links" : [ "#createForSubscriptionId", "android.telephony.SubscriptionManager#getDefaultSubscriptionId()" ]
  }, {
    "name" : "public int getLteOnCdmaMode(int subId)",
    "returnType" : "int",
    "comment" : "\n     * Return if the current radio is LTE on CDMA for Subscription. This\n     * is a tri-state return value as for a period of time\n     * the mode may be unknown.\n     *\n     * @param subId for which radio is LTE on CDMA is returned\n     * @return {@link PhoneConstants#LTE_ON_CDMA_UNKNOWN}, {@link PhoneConstants#LTE_ON_CDMA_FALSE}\n     * or {@link PhoneConstants#LTE_ON_CDMA_TRUE}\n     * @hide\n     ",
    "links" : [ "com.android.internal.telephony.PhoneConstants#LTE_ON_CDMA_UNKNOWN", "com.android.internal.telephony.PhoneConstants#LTE_ON_CDMA_FALSE", "com.android.internal.telephony.PhoneConstants#LTE_ON_CDMA_TRUE" ]
  }, {
    "name" : "public int getCardIdForDefaultEuicc()",
    "returnType" : "int",
    "comment" : "\n     * Get the card ID of the default eUICC card. If the eUICCs have not yet been loaded, returns\n     * {@link #UNINITIALIZED_CARD_ID}. If there is no eUICC or the device does not support card IDs\n     * for eUICCs, returns {@link #UNSUPPORTED_CARD_ID}.\n     *\n     * <p>The card ID is a unique identifier associated with a UICC or eUICC card. Card IDs are\n     * unique to a device, and always refer to the same UICC or eUICC card unless the device goes\n     * through a factory reset.\n     *\n     * @return card ID of the default eUICC card, if loaded.\n     ",
    "links" : [ "#UNINITIALIZED_CARD_ID", "#UNSUPPORTED_CARD_ID" ]
  }, {
    "name" : "public List<UiccCardInfo> getUiccCardsInfo()",
    "returnType" : "List<UiccCardInfo>",
    "comment" : "\n     * Gets information about currently inserted UICCs and eUICCs.\n     * <p>\n     * Requires that the calling app has carrier privileges (see {@link #hasCarrierPrivileges}).\n     * <p>\n     * If the caller has carrier priviliges on any active subscription, then they have permission to\n     * get simple information like the card ID ({@link UiccCardInfo#getCardId()}), whether the card\n     * is an eUICC ({@link UiccCardInfo#isEuicc()}), and the slot index where the card is inserted\n     * ({@link UiccCardInfo#getSlotIndex()}).\n     * <p>\n     * To get private information such as the EID ({@link UiccCardInfo#getEid()}) or ICCID\n     * ({@link UiccCardInfo#getIccId()}), the caller must have carrier priviliges on that specific\n     * UICC or eUICC card.\n     * <p>\n     * See {@link UiccCardInfo} for more details on the kind of information available.\n     *\n     * @return a list of UiccCardInfo objects, representing information on the currently inserted\n     * UICCs and eUICCs. Each UiccCardInfo in the list will have private information filtered out if\n     * the caller does not have adequate permissions for that card.\n     ",
    "links" : [ "android.telephony.UiccCardInfo#getSlotIndex()", "android.telephony.UiccCardInfo#getEid()", "#hasCarrierPrivileges", "android.telephony.UiccCardInfo#isEuicc()", "android.telephony.UiccCardInfo#getCardId()", "android.telephony.UiccCardInfo#getIccId()", "android.telephony.UiccCardInfo" ]
  }, {
    "name" : "public UiccSlotInfo[] getUiccSlotsInfo()",
    "returnType" : "UiccSlotInfo[]",
    "comment" : "\n     * Gets all the UICC slots. The objects in the array can be null if the slot info is not\n     * available, which is possible between phone process starting and getting slot info from modem.\n     *\n     * @return UiccSlotInfo array.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public void refreshUiccProfile()",
    "returnType" : "void",
    "comment" : "\n     * Test method to reload the UICC profile.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean switchSlots(int[] physicalSlots)",
    "returnType" : "boolean",
    "comment" : "\n     * Map logicalSlot to physicalSlot, and activate the physicalSlot if it is inactive. For\n     * example, passing the physicalSlots array [1, 0] means mapping the first item 1, which is\n     * physical slot index 1, to the logical slot 0; and mapping the second item 0, which is\n     * physical slot index 0, to the logical slot 1. The index of the array means the index of the\n     * logical slots.\n     *\n     * @param physicalSlots The content of the array represents the physical slot index. The array\n     *        size should be same as {@link #getUiccSlotsInfo()}.\n     * @return boolean Return true if the switch succeeds, false if the switch fails.\n     * @hide\n     ",
    "links" : [ "#getUiccSlotsInfo()" ]
  }, {
    "name" : "public Map<Integer, Integer> getLogicalToPhysicalSlotMapping()",
    "returnType" : "Map<Integer, Integer>",
    "comment" : "\n     * Get the mapping from logical slots to physical slots. The key of the map is the logical slot\n     * id and the value is the physical slots id mapped to this logical slot id.\n     *\n     * @return a map indicates the mapping from logical slots to physical slots. The size of the map\n     * should be {@link #getPhoneCount()} if success, otherwise return an empty map.\n     *\n     * @hide\n     ",
    "links" : [ "#getPhoneCount()" ]
  }, {
    "name" : "public String getSubscriberId()",
    "returnType" : "String",
    "comment" : "\n     * Returns the unique subscriber ID, for example, the IMSI for a GSM phone.\n     * Return null if it is unavailable.\n     *\n     * <p>Starting with API level 29, persistent device identifiers are guarded behind additional\n     * restrictions, and apps are recommended to use resettable identifiers (see <a\n     * href=\"c\"> Best practices for unique identifiers</a>). This method can be invoked if one of\n     * the following requirements is met:\n     * <ul>\n     *     <li>If the calling app has been granted the READ_PRIVILEGED_PHONE_STATE permission; this\n     *     is a privileged permission that can only be granted to apps preloaded on the device.\n     *     <li>If the calling app is the device or profile owner and has been granted the\n     *     {@link Manifest.permission#READ_PHONE_STATE} permission. The profile owner is an app that\n     *     owns a managed profile on the device; for more details see <a\n     *     href=\"https://developer.android.com/work/managed-profiles\">Work profiles</a>.\n     *     Profile owner access is deprecated and will be removed in a future release.\n     *     <li>If the calling app has carrier privileges (see {@link #hasCarrierPrivileges}).\n     *     <li>If the calling app is the default SMS role holder (see {@link\n     *     RoleManager#isRoleHeld(String)}).\n     * </ul>\n     *\n     * <p>If the calling app does not meet one of these requirements then this method will behave\n     * as follows:\n     *\n     * <ul>\n     *     <li>If the calling app's target SDK is API level 28 or lower and the app has the\n     *     READ_PHONE_STATE permission then null is returned.</li>\n     *     <li>If the calling app's target SDK is API level 28 or lower and the app does not have\n     *     the READ_PHONE_STATE permission, or if the calling app is targeting API level 29 or\n     *     higher, then a SecurityException is thrown.</li>\n     * </ul>\n     ",
    "links" : [ "Manifest.permission#READ_PHONE_STATE", "#hasCarrierPrivileges", "android.app.role.RoleManager#isRoleHeld(String)" ]
  }, {
    "name" : "public String getSubscriberId(int subId)",
    "returnType" : "String",
    "comment" : "\n     * Returns the unique subscriber ID, for example, the IMSI for a GSM phone\n     * for a subscription.\n     * Return null if it is unavailable.\n     *\n     * <p>Starting with API level 29, persistent device identifiers are guarded behind additional\n     * restrictions, and apps are recommended to use resettable identifiers (see <a\n     * href=\"c\"> Best practices for unique identifiers</a>). This method can be invoked if one of\n     * the following requirements is met:\n     * <ul>\n     *     <li>If the calling app has been granted the READ_PRIVILEGED_PHONE_STATE permission; this\n     *     is a privileged permission that can only be granted to apps preloaded on the device.\n     *     <li>If the calling app is the device or profile owner and has been granted the\n     *     {@link Manifest.permission#READ_PHONE_STATE} permission. The profile owner is an app that\n     *     owns a managed profile on the device; for more details see <a\n     *     href=\"https://developer.android.com/work/managed-profiles\">Work profiles</a>.\n     *     Profile owner access is deprecated and will be removed in a future release.\n     *     <li>If the calling app has carrier privileges (see {@link #hasCarrierPrivileges}).\n     *     <li>If the calling app is the default SMS role holder (see {@link\n     *     RoleManager#isRoleHeld(String)}).\n     * </ul>\n     *\n     * <p>If the calling app does not meet one of these requirements then this method will behave\n     * as follows:\n     *\n     * <ul>\n     *     <li>If the calling app's target SDK is API level 28 or lower and the app has the\n     *     READ_PHONE_STATE permission then null is returned.</li>\n     *     <li>If the calling app's target SDK is API level 28 or lower and the app does not have\n     *     the READ_PHONE_STATE permission, or if the calling app is targeting API level 29 or\n     *     higher, then a SecurityException is thrown.</li>\n     * </ul>\n     *\n     * @param subId whose subscriber id is returned\n     * @hide\n     ",
    "links" : [ "Manifest.permission#READ_PHONE_STATE", "#hasCarrierPrivileges", "android.app.role.RoleManager#isRoleHeld(String)" ]
  }, {
    "name" : "public ImsiEncryptionInfo getCarrierInfoForImsiEncryption(@KeyType int keyType)",
    "returnType" : "ImsiEncryptionInfo",
    "comment" : "\n     * Returns carrier specific information that will be used to encrypt the IMSI and IMPI,\n     * including the public key and the key identifier; or {@code null} if not available.\n     * <p>\n     * For a multi-sim device, the dafault data sim is used if not specified.\n     * <p>\n     * Requires Permission: READ_PRIVILEGED_PHONE_STATE.\n     *\n     * @param keyType whether the key is being used for EPDG or WLAN. Valid values are\n     *        {@link #KEY_TYPE_EPDG} or {@link #KEY_TYPE_WLAN}.\n     * @return ImsiEncryptionInfo Carrier specific information that will be used to encrypt the\n     *         IMSI and IMPI. This includes the public key and the key identifier. This information\n     *         will be stored in the device keystore. {@code null} will be returned when no key is\n     *         found, and the carrier does not require a key.\n     * @throws IllegalArgumentException when an invalid key is found or when key is required but\n     *         not found.\n     * @hide\n     ",
    "links" : [ "#KEY_TYPE_EPDG", "#KEY_TYPE_WLAN" ]
  }, {
    "name" : "public void resetCarrierKeysForImsiEncryption()",
    "returnType" : "void",
    "comment" : "\n     * Resets the carrier keys used to encrypt the IMSI and IMPI.\n     * <p>\n     * This involves 2 steps:\n     *  1. Delete the keys from the database.\n     *  2. Send an intent to download new Certificates.\n     * <p>\n     * For a multi-sim device, the dafault data sim is used if not specified.\n     * <p>\n     * Requires Permission: MODIFY_PHONE_STATE.\n     *\n     * @see #getCarrierInfoForImsiEncryption\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "private static boolean isKeyEnabled(int keyAvailability, @KeyType int keyType)",
    "returnType" : "boolean",
    "comment" : "\n     * @param keyAvailability bitmask that defines the availabilty of keys for a type.\n     * @param keyType the key type which is being checked. (WLAN, EPDG)\n     * @return true if the digit at position keyType is 1, else false.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "private boolean isImsiEncryptionRequired(int subId, @KeyType int keyType)",
    "returnType" : "boolean",
    "comment" : "\n     * If Carrier requires Imsi to be encrypted.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public void setCarrierInfoForImsiEncryption(ImsiEncryptionInfo imsiEncryptionInfo)",
    "returnType" : "void",
    "comment" : "\n     * Sets the Carrier specific information that will be used to encrypt the IMSI and IMPI.\n     * This includes the public key and the key identifier. This information will be stored in the\n     * device keystore.\n     * <p>\n     * Requires Permission:\n     *   {@link android.Manifest.permission#MODIFY_PHONE_STATE MODIFY_PHONE_STATE}\n     * @param imsiEncryptionInfo which includes the Key Type, the Public Key\n     *        (java.security.PublicKey) and the Key Identifier.and the Key Identifier.\n     *        The keyIdentifier Attribute value pair that helps a server locate\n     *        the private key to decrypt the permanent identity. This field is\n     *        optional and if it is present then it’s always separated from encrypted\n     *        permanent identity with “,”. Key identifier AVP is presented in ASCII string\n     *        with “name=value” format.\n     * @hide\n     ",
    "links" : [ "android.Manifest.permission#MODIFY_PHONE_STATE" ]
  }, {
    "name" : "public String getGroupIdLevel1()",
    "returnType" : "String",
    "comment" : "\n     * Returns the Group Identifier Level1 for a GSM phone.\n     * Return null if it is unavailable.\n     *\n     * <p>Requires Permission: {@link android.Manifest.permission#READ_PHONE_STATE READ_PHONE_STATE}\n     * or that the calling app has carrier privileges (see {@link #hasCarrierPrivileges}).\n     ",
    "links" : [ "#hasCarrierPrivileges", "android.Manifest.permission#READ_PHONE_STATE" ]
  }, {
    "name" : "public String getGroupIdLevel1(int subId)",
    "returnType" : "String",
    "comment" : "\n     * Returns the Group Identifier Level1 for a GSM phone for a particular subscription.\n     * Return null if it is unavailable.\n     *\n     * @param subId whose subscriber id is returned\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public String getLine1Number()",
    "returnType" : "String",
    "comment" : "\n     * Returns the phone number string for line 1, for example, the MSISDN\n     * for a GSM phone for a particular subscription. Return null if it is unavailable.\n     * <p>\n     * The default SMS app can also use this.\n     *\n     * <p>Requires Permission:\n     *     {@link android.Manifest.permission#READ_SMS READ_SMS},\n     *     {@link android.Manifest.permission#READ_PHONE_NUMBERS READ_PHONE_NUMBERS},\n     *     that the caller is the default SMS app,\n     *     or that the caller has carrier privileges (see {@link #hasCarrierPrivileges})\n     *     for any API level.\n     *     {@link android.Manifest.permission#READ_PHONE_STATE READ_PHONE_STATE}\n     *     for apps targeting SDK API level 29 and below.\n     ",
    "links" : [ "#hasCarrierPrivileges", "android.Manifest.permission#READ_SMS", "android.Manifest.permission#READ_PHONE_STATE", "android.Manifest.permission#READ_PHONE_NUMBERS" ]
  }, {
    "name" : "public String getLine1Number(int subId)",
    "returnType" : "String",
    "comment" : "\n     * Returns the phone number string for line 1, for example, the MSISDN\n     * for a GSM phone for a particular subscription. Return null if it is unavailable.\n     * <p>\n     * The default SMS app can also use this.\n     *\n     * <p>Requires Permission:\n     *     {@link android.Manifest.permission#READ_SMS READ_SMS},\n     *     {@link android.Manifest.permission#READ_PHONE_NUMBERS READ_PHONE_NUMBERS},\n     *     that the caller is the default SMS app,\n     *     or that the caller has carrier privileges (see {@link #hasCarrierPrivileges})\n     *     for any API level.\n     *     {@link android.Manifest.permission#READ_PHONE_STATE READ_PHONE_STATE}\n     *     for apps targeting SDK API level 29 and below.\n     *\n     * @param subId whose phone number for line 1 is returned\n     * @hide\n     ",
    "links" : [ "#hasCarrierPrivileges", "android.Manifest.permission#READ_SMS", "android.Manifest.permission#READ_PHONE_STATE", "android.Manifest.permission#READ_PHONE_NUMBERS" ]
  }, {
    "name" : "public boolean setLine1NumberForDisplay(String alphaTag, String number)",
    "returnType" : "boolean",
    "comment" : "\n     * Set the line 1 phone number string and its alphatag for the current ICCID\n     * for display purpose only, for example, displayed in Phone Status. It won't\n     * change the actual MSISDN/MDN. To unset alphatag or number, pass in a null\n     * value.\n     *\n     * <p>Requires that the calling app has carrier privileges (see {@link #hasCarrierPrivileges}).\n     *\n     * @param alphaTag alpha-tagging of the dailing nubmer\n     * @param number The dialing number\n     * @return true if the operation was executed correctly.\n     ",
    "links" : [ "#hasCarrierPrivileges" ]
  }, {
    "name" : "public boolean setLine1NumberForDisplay(int subId, String alphaTag, String number)",
    "returnType" : "boolean",
    "comment" : "\n     * Set the line 1 phone number string and its alphatag for the current ICCID\n     * for display purpose only, for example, displayed in Phone Status. It won't\n     * change the actual MSISDN/MDN. To unset alphatag or number, pass in a null\n     * value.\n     *\n     * <p>Requires that the calling app has carrier privileges (see {@link #hasCarrierPrivileges}).\n     *\n     * @param subId the subscriber that the alphatag and dialing number belongs to.\n     * @param alphaTag alpha-tagging of the dailing nubmer\n     * @param number The dialing number\n     * @return true if the operation was executed correctly.\n     * @hide\n     ",
    "links" : [ "#hasCarrierPrivileges" ]
  }, {
    "name" : "public String getLine1AlphaTag()",
    "returnType" : "String",
    "comment" : "\n     * Returns the alphabetic identifier associated with the line 1 number.\n     * Return null if it is unavailable.\n     * @hide\n     * nobody seems to call this.\n     ",
    "links" : [ ]
  }, {
    "name" : "public String getLine1AlphaTag(int subId)",
    "returnType" : "String",
    "comment" : "\n     * Returns the alphabetic identifier associated with the line 1 number\n     * for a subscription.\n     * Return null if it is unavailable.\n     * @param subId whose alphabetic identifier associated with line 1 is returned\n     * nobody seems to call this.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public String[] getMergedSubscriberIds()",
    "returnType" : "String[]",
    "comment" : "\n     * Return the set of subscriber IDs that should be considered \"merged together\" for data usage\n     * purposes. This is commonly {@code null} to indicate no merging is required. Any returned\n     * subscribers are sorted in a deterministic order.\n     * <p>\n     * The returned set of subscriber IDs will include the subscriber ID corresponding to this\n     * TelephonyManager's subId.\n     *\n     * This is deprecated and {@link #getMergedImsisFromGroup()} should be used for data\n     * usage merging purpose.\n     * TODO: remove this API.\n     *\n     * @hide\n     ",
    "links" : [ "#getMergedImsisFromGroup()" ]
  }, {
    "name" : "public String[] getMergedImsisFromGroup()",
    "returnType" : "String[]",
    "comment" : "\n     * Return the set of IMSIs that should be considered \"merged together\" for data usage\n     * purposes. Unlike {@link #getMergedSubscriberIds()} this API merge IMSIs based on\n     * subscription grouping: IMSI of those in the same group will all be returned.\n     * Return the current IMSI if there is no subscription group.\n     *\n     * <p>Requires the calling app to have READ_PRIVILEGED_PHONE_STATE permission.\n     *\n     * @hide\n     ",
    "links" : [ "#getMergedSubscriberIds()" ]
  }, {
    "name" : "public String getMsisdn()",
    "returnType" : "String",
    "comment" : "\n     * Returns the MSISDN string for a GSM phone. Return null if it is unavailable.\n     *\n     * <p>Requires Permission:\n     *     {@link android.Manifest.permission#READ_SMS READ_SMS},\n     *     {@link android.Manifest.permission#READ_PHONE_NUMBERS READ_PHONE_NUMBERS},\n     *     that the caller is the default SMS app,\n     *     or that the caller has carrier privileges (see {@link #hasCarrierPrivileges})\n     *     for any API level.\n     *     {@link android.Manifest.permission#READ_PHONE_STATE READ_PHONE_STATE}\n     *     for apps targeting SDK API level 29 and below.\n     *\n     * @hide\n     ",
    "links" : [ "#hasCarrierPrivileges", "android.Manifest.permission#READ_SMS", "android.Manifest.permission#READ_PHONE_STATE", "android.Manifest.permission#READ_PHONE_NUMBERS" ]
  }, {
    "name" : "public String getMsisdn(int subId)",
    "returnType" : "String",
    "comment" : "\n     * Returns the MSISDN string for a GSM phone. Return null if it is unavailable.\n     *\n     * @param subId for which msisdn is returned\n     *\n     * <p>Requires Permission:\n     *     {@link android.Manifest.permission#READ_SMS READ_SMS},\n     *     {@link android.Manifest.permission#READ_PHONE_NUMBERS READ_PHONE_NUMBERS},\n     *     that the caller is the default SMS app,\n     *     or that the caller has carrier privileges (see {@link #hasCarrierPrivileges})\n     *     for any API level.\n     *     {@link android.Manifest.permission#READ_PHONE_STATE READ_PHONE_STATE}\n     *     for apps targeting SDK API level 29 and below.\n     *\n     * @hide\n     ",
    "links" : [ "#hasCarrierPrivileges", "android.Manifest.permission#READ_SMS", "android.Manifest.permission#READ_PHONE_STATE", "android.Manifest.permission#READ_PHONE_NUMBERS" ]
  }, {
    "name" : "public String getVoiceMailNumber()",
    "returnType" : "String",
    "comment" : "\n     * Returns the voice mail number. Return null if it is unavailable.\n     *\n     * <p>Requires Permission: {@link android.Manifest.permission#READ_PHONE_STATE READ_PHONE_STATE}\n     * or that the calling app has carrier privileges (see {@link #hasCarrierPrivileges}).\n     ",
    "links" : [ "#hasCarrierPrivileges", "android.Manifest.permission#READ_PHONE_STATE" ]
  }, {
    "name" : "public String getVoiceMailNumber(int subId)",
    "returnType" : "String",
    "comment" : "\n     * Returns the voice mail number for a subscription.\n     * Return null if it is unavailable.\n     * @param subId whose voice mail number is returned\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean setVoiceMailNumber(String alphaTag, String number)",
    "returnType" : "boolean",
    "comment" : "\n     * Sets the voice mail number.\n     *\n     * <p>Requires that the calling app has carrier privileges (see {@link #hasCarrierPrivileges}).\n     *\n     * @param alphaTag The alpha tag to display.\n     * @param number The voicemail number.\n     ",
    "links" : [ "#hasCarrierPrivileges" ]
  }, {
    "name" : "public boolean setVoiceMailNumber(int subId, String alphaTag, String number)",
    "returnType" : "boolean",
    "comment" : "\n     * Sets the voicemail number for the given subscriber.\n     *\n     * <p>Requires that the calling app has carrier privileges (see {@link #hasCarrierPrivileges}).\n     *\n     * @param subId The subscription id.\n     * @param alphaTag The alpha tag to display.\n     * @param number The voicemail number.\n     * @hide\n     ",
    "links" : [ "#hasCarrierPrivileges" ]
  }, {
    "name" : "public void setVisualVoicemailEnabled(PhoneAccountHandle phoneAccountHandle, boolean enabled)",
    "returnType" : "void",
    "comment" : "\n     * Enables or disables the visual voicemail client for a phone account.\n     *\n     * <p>Requires that the calling app is the default dialer, or has carrier privileges (see\n     * {@link #hasCarrierPrivileges}), or has permission\n     * {@link android.Manifest.permission#MODIFY_PHONE_STATE MODIFY_PHONE_STATE}.\n     *\n     * @param phoneAccountHandle the phone account to change the client state\n     * @param enabled the new state of the client\n     * @hide\n     * @deprecated Visual voicemail no longer in telephony. {@link VisualVoicemailService} should\n     * be implemented instead.\n     ",
    "links" : [ "#hasCarrierPrivileges", "android.Manifest.permission#MODIFY_PHONE_STATE", "android.telephony.VisualVoicemailService" ]
  }, {
    "name" : "public boolean isVisualVoicemailEnabled(PhoneAccountHandle phoneAccountHandle)",
    "returnType" : "boolean",
    "comment" : "\n     * Returns whether the visual voicemail client is enabled.\n     *\n     * @param phoneAccountHandle the phone account to check for.\n     * @return {@code true} when the visual voicemail client is enabled for this client\n     * @hide\n     * @deprecated Visual voicemail no longer in telephony. {@link VisualVoicemailService} should\n     * be implemented instead.\n     ",
    "links" : [ "android.telephony.VisualVoicemailService" ]
  }, {
    "name" : "public Bundle getVisualVoicemailSettings()",
    "returnType" : "Bundle",
    "comment" : "\n     * Returns an opaque bundle of settings formerly used by the visual voicemail client for the\n     * subscription ID pinned to the TelephonyManager, or {@code null} if the subscription ID is\n     * invalid. This method allows the system dialer to migrate settings out of the pre-O visual\n     * voicemail client in telephony.\n     *\n     * <p>Requires the caller to be the system dialer.\n     *\n     * @see #KEY_VISUAL_VOICEMAIL_ENABLED_BY_USER_BOOL\n     * @see #KEY_VOICEMAIL_SCRAMBLED_PIN_STRING\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public String getVisualVoicemailPackageName()",
    "returnType" : "String",
    "comment" : "\n     * Returns the package responsible of processing visual voicemail for the subscription ID pinned\n     * to the TelephonyManager. Returns {@code null} when there is no package responsible for\n     * processing visual voicemail for the subscription.\n     *\n     * <p>Requires Permission: {@link android.Manifest.permission#READ_PHONE_STATE READ_PHONE_STATE}\n     * or that the calling app has carrier privileges (see {@link #hasCarrierPrivileges}).\n     *\n     * @see #createForSubscriptionId(int)\n     * @see #createForPhoneAccountHandle(PhoneAccountHandle)\n     * @see VisualVoicemailService\n     ",
    "links" : [ "#hasCarrierPrivileges", "android.Manifest.permission#READ_PHONE_STATE" ]
  }, {
    "name" : "public void setVisualVoicemailSmsFilterSettings(VisualVoicemailSmsFilterSettings settings)",
    "returnType" : "void",
    "comment" : "\n     * Set the visual voicemail SMS filter settings for the subscription ID pinned\n     * to the TelephonyManager.\n     * When the filter is enabled, {@link\n     * VisualVoicemailService#onSmsReceived(VisualVoicemailTask, VisualVoicemailSms)} will be\n     * called when a SMS matching the settings is received. Caller must be the default dialer,\n     * system dialer, or carrier visual voicemail app.\n     *\n     * @param settings The settings for the filter, or {@code null} to disable the filter.\n     *\n     * @see TelecomManager#getDefaultDialerPackage()\n     * @see CarrierConfigManager#KEY_CARRIER_VVM_PACKAGE_NAME_STRING_ARRAY\n     ",
    "links" : [ "android.telephony.VisualVoicemailService#onSmsReceived(VisualVoicemailTask" ]
  }, {
    "name" : "public void sendVisualVoicemailSms(String number, int port, String text, PendingIntent sentIntent)",
    "returnType" : "void",
    "comment" : "\n     * Send a visual voicemail SMS. The caller must be the current default dialer.\n     * A {@link VisualVoicemailService} uses this method to send a command via SMS to the carrier's\n     * visual voicemail server.  Some examples for carriers using the OMTP standard include\n     * activating and deactivating visual voicemail, or requesting the current visual voicemail\n     * provisioning status.  See the OMTP Visual Voicemail specification for more information on the\n     * format of these SMS messages.\n     *\n     * <p>Requires Permission:\n     * {@link android.Manifest.permission#SEND_SMS SEND_SMS}\n     *\n     * @param number The destination number.\n     * @param port The destination port for data SMS, or 0 for text SMS.\n     * @param text The message content. For data sms, it will be encoded as a UTF-8 byte stream.\n     * @param sentIntent The sent intent passed to the {@link SmsManager}\n     *\n     * @throws SecurityException if the caller is not the current default dialer\n     *\n     * @see SmsManager#sendDataMessage(String, String, short, byte[], PendingIntent, PendingIntent)\n     * @see SmsManager#sendTextMessage(String, String, String, PendingIntent, PendingIntent)\n     ",
    "links" : [ "android.telephony.SmsManager", "android.Manifest.permission#SEND_SMS", "android.telephony.VisualVoicemailService" ]
  }, {
    "name" : "public void enableVisualVoicemailSmsFilter(int subId, VisualVoicemailSmsFilterSettings settings)",
    "returnType" : "void",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "public void disableVisualVoicemailSmsFilter(int subId)",
    "returnType" : "void",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "public VisualVoicemailSmsFilterSettings getVisualVoicemailSmsFilterSettings(int subId)",
    "returnType" : "VisualVoicemailSmsFilterSettings",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "public VisualVoicemailSmsFilterSettings getActiveVisualVoicemailSmsFilterSettings(int subId)",
    "returnType" : "VisualVoicemailSmsFilterSettings",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "public void sendVisualVoicemailSmsForSubscriber(int subId, String number, int port, String text, PendingIntent sentIntent)",
    "returnType" : "void",
    "comment" : "\n     * Send a visual voicemail SMS. The IPC caller must be the current default dialer.\n     *\n     * @param phoneAccountHandle The account to send the SMS with.\n     * @param number The destination number.\n     * @param port The destination port for data SMS, or 0 for text SMS.\n     * @param text The message content. For data sms, it will be encoded as a UTF-8 byte stream.\n     * @param sentIntent The sent intent passed to the {@link SmsManager}\n     *\n     * @see SmsManager#sendDataMessage(String, String, short, byte[], PendingIntent, PendingIntent)\n     * @see SmsManager#sendTextMessage(String, String, String, PendingIntent, PendingIntent)\n     *\n     * @hide\n     ",
    "links" : [ "android.telephony.SmsManager" ]
  }, {
    "name" : "public void setVoiceActivationState(@SimActivationState int activationState)",
    "returnType" : "void",
    "comment" : "\n      * Sets the voice activation state\n      *\n      * <p>Requires Permission:\n      * {@link android.Manifest.permission#MODIFY_PHONE_STATE MODIFY_PHONE_STATE} or that the\n      * calling app has carrier privileges (see {@link #hasCarrierPrivileges}).\n      *\n      * @param activationState The voice activation state\n      * @see #SIM_ACTIVATION_STATE_UNKNOWN\n      * @see #SIM_ACTIVATION_STATE_ACTIVATING\n      * @see #SIM_ACTIVATION_STATE_ACTIVATED\n      * @see #SIM_ACTIVATION_STATE_DEACTIVATED\n      * @hide\n      ",
    "links" : [ "#hasCarrierPrivileges", "android.Manifest.permission#MODIFY_PHONE_STATE" ]
  }, {
    "name" : "public void setVoiceActivationState(int subId, @SimActivationState int activationState)",
    "returnType" : "void",
    "comment" : "\n     * Sets the voice activation state for the given subscriber.\n     *\n     * <p>Requires Permission:\n     * {@link android.Manifest.permission#MODIFY_PHONE_STATE MODIFY_PHONE_STATE} or that the\n     * calling app has carrier privileges (see {@link #hasCarrierPrivileges}).\n     *\n     * @param subId The subscription id.\n     * @param activationState The voice activation state of the given subscriber.\n     * @see #SIM_ACTIVATION_STATE_UNKNOWN\n     * @see #SIM_ACTIVATION_STATE_ACTIVATING\n     * @see #SIM_ACTIVATION_STATE_ACTIVATED\n     * @see #SIM_ACTIVATION_STATE_DEACTIVATED\n     * @hide\n     ",
    "links" : [ "#hasCarrierPrivileges", "android.Manifest.permission#MODIFY_PHONE_STATE" ]
  }, {
    "name" : "public void setDataActivationState(@SimActivationState int activationState)",
    "returnType" : "void",
    "comment" : "\n     * Sets the data activation state\n     *\n     * <p>Requires Permission:\n     * {@link android.Manifest.permission#MODIFY_PHONE_STATE MODIFY_PHONE_STATE} or that the\n     * calling app has carrier privileges (see {@link #hasCarrierPrivileges}).\n     *\n     * @param activationState The data activation state\n     * @see #SIM_ACTIVATION_STATE_UNKNOWN\n     * @see #SIM_ACTIVATION_STATE_ACTIVATING\n     * @see #SIM_ACTIVATION_STATE_ACTIVATED\n     * @see #SIM_ACTIVATION_STATE_DEACTIVATED\n     * @see #SIM_ACTIVATION_STATE_RESTRICTED\n     * @hide\n     ",
    "links" : [ "#hasCarrierPrivileges", "android.Manifest.permission#MODIFY_PHONE_STATE" ]
  }, {
    "name" : "public void setDataActivationState(int subId, @SimActivationState int activationState)",
    "returnType" : "void",
    "comment" : "\n     * Sets the data activation state for the given subscriber.\n     *\n     * <p>Requires Permission:\n     * {@link android.Manifest.permission#MODIFY_PHONE_STATE MODIFY_PHONE_STATE} or that the\n     * calling app has carrier privileges (see {@link #hasCarrierPrivileges}).\n     *\n     * @param subId The subscription id.\n     * @param activationState The data activation state of the given subscriber.\n     * @see #SIM_ACTIVATION_STATE_UNKNOWN\n     * @see #SIM_ACTIVATION_STATE_ACTIVATING\n     * @see #SIM_ACTIVATION_STATE_ACTIVATED\n     * @see #SIM_ACTIVATION_STATE_DEACTIVATED\n     * @see #SIM_ACTIVATION_STATE_RESTRICTED\n     * @hide\n     ",
    "links" : [ "#hasCarrierPrivileges", "android.Manifest.permission#MODIFY_PHONE_STATE" ]
  }, {
    "name" : "public int getVoiceActivationState()",
    "returnType" : "int",
    "comment" : "\n     * Returns the voice activation state\n     *\n     * <p>Requires Permission:\n     * {@link android.Manifest.permission#READ_PRIVILEGED_PHONE_STATE READ_PRIVILEGED_PHONE_STATE}\n     * or that the calling app has carrier privileges (see {@link #hasCarrierPrivileges}).\n     *\n     * @return voiceActivationState\n     * @see #SIM_ACTIVATION_STATE_UNKNOWN\n     * @see #SIM_ACTIVATION_STATE_ACTIVATING\n     * @see #SIM_ACTIVATION_STATE_ACTIVATED\n     * @see #SIM_ACTIVATION_STATE_DEACTIVATED\n     * @hide\n     ",
    "links" : [ "#hasCarrierPrivileges", "android.Manifest.permission#READ_PRIVILEGED_PHONE_STATE" ]
  }, {
    "name" : "public int getVoiceActivationState(int subId)",
    "returnType" : "int",
    "comment" : "\n     * Returns the voice activation state for the given subscriber.\n     *\n     * <p>Requires Permission:\n     * {@link android.Manifest.permission#READ_PRIVILEGED_PHONE_STATE READ_PRIVILEGED_PHONE_STATE}\n     * or that the calling app has carrier privileges (see {@link #hasCarrierPrivileges}).\n     *\n     * @param subId The subscription id.\n     *\n     * @return voiceActivationState for the given subscriber\n     * @see #SIM_ACTIVATION_STATE_UNKNOWN\n     * @see #SIM_ACTIVATION_STATE_ACTIVATING\n     * @see #SIM_ACTIVATION_STATE_ACTIVATED\n     * @see #SIM_ACTIVATION_STATE_DEACTIVATED\n     * @hide\n     ",
    "links" : [ "#hasCarrierPrivileges", "android.Manifest.permission#READ_PRIVILEGED_PHONE_STATE" ]
  }, {
    "name" : "public int getDataActivationState()",
    "returnType" : "int",
    "comment" : "\n     * Returns the data activation state\n     *\n     * <p>Requires Permission:\n     * {@link android.Manifest.permission#READ_PRIVILEGED_PHONE_STATE READ_PRIVILEGED_PHONE_STATE}\n     * or that the calling app has carrier privileges (see {@link #hasCarrierPrivileges}).\n     *\n     * @return dataActivationState for the given subscriber\n     * @see #SIM_ACTIVATION_STATE_UNKNOWN\n     * @see #SIM_ACTIVATION_STATE_ACTIVATING\n     * @see #SIM_ACTIVATION_STATE_ACTIVATED\n     * @see #SIM_ACTIVATION_STATE_DEACTIVATED\n     * @see #SIM_ACTIVATION_STATE_RESTRICTED\n     * @hide\n     ",
    "links" : [ "#hasCarrierPrivileges", "android.Manifest.permission#READ_PRIVILEGED_PHONE_STATE" ]
  }, {
    "name" : "public int getDataActivationState(int subId)",
    "returnType" : "int",
    "comment" : "\n     * Returns the data activation state for the given subscriber.\n     *\n     * <p>Requires Permission:\n     * {@link android.Manifest.permission#READ_PRIVILEGED_PHONE_STATE READ_PRIVILEGED_PHONE_STATE}\n     * or that the calling app has carrier privileges (see {@link #hasCarrierPrivileges}).\n     *\n     * @param subId The subscription id.\n     *\n     * @return dataActivationState for the given subscriber\n     * @see #SIM_ACTIVATION_STATE_UNKNOWN\n     * @see #SIM_ACTIVATION_STATE_ACTIVATING\n     * @see #SIM_ACTIVATION_STATE_ACTIVATED\n     * @see #SIM_ACTIVATION_STATE_DEACTIVATED\n     * @see #SIM_ACTIVATION_STATE_RESTRICTED\n     * @hide\n     ",
    "links" : [ "#hasCarrierPrivileges", "android.Manifest.permission#READ_PRIVILEGED_PHONE_STATE" ]
  }, {
    "name" : "public int getVoiceMessageCount()",
    "returnType" : "int",
    "comment" : "\n     * Returns the voice mail count. Return 0 if unavailable, -1 if there are unread voice messages\n     * but the count is unknown.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public int getVoiceMessageCount(int subId)",
    "returnType" : "int",
    "comment" : "\n     * Returns the voice mail count for a subscription. Return 0 if unavailable or the caller does\n     * not have the READ_PHONE_STATE permission.\n     * @param subId whose voice message count is returned\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public String getVoiceMailAlphaTag()",
    "returnType" : "String",
    "comment" : "\n     * Retrieves the alphabetic identifier associated with the voice\n     * mail number.\n     *\n     * <p>Requires Permission: {@link android.Manifest.permission#READ_PHONE_STATE READ_PHONE_STATE}\n     * or that the calling app has carrier privileges (see {@link #hasCarrierPrivileges}).\n     ",
    "links" : [ "#hasCarrierPrivileges", "android.Manifest.permission#READ_PHONE_STATE" ]
  }, {
    "name" : "public String getVoiceMailAlphaTag(int subId)",
    "returnType" : "String",
    "comment" : "\n     * Retrieves the alphabetic identifier associated with the voice\n     * mail number for a subscription.\n     * @param subId whose alphabetic identifier associated with the\n     * voice mail number is returned\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public void sendDialerSpecialCode(String inputCode)",
    "returnType" : "void",
    "comment" : "\n     * Send the special dialer code. The IPC caller must be the current default dialer or have\n     * carrier privileges (see {@link #hasCarrierPrivileges}).\n     *\n     * @param inputCode The special dialer code to send\n     *\n     * @throws SecurityException if the caller does not have carrier privileges or is not the\n     *         current default dialer\n     ",
    "links" : [ "#hasCarrierPrivileges" ]
  }, {
    "name" : "public String getIsimImpi()",
    "returnType" : "String",
    "comment" : "\n     * Returns the IMS private user identity (IMPI) that was loaded from the ISIM.\n     * @return the IMPI, or null if not present or not loaded\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public String getIsimDomain()",
    "returnType" : "String",
    "comment" : "\n     * Returns the IMS home network domain name that was loaded from the ISIM {@see #APPTYPE_ISIM}.\n     * @return the IMS domain name. Returns {@code null} if ISIM hasn't been loaded or IMS domain\n     * hasn't been loaded or isn't present on the ISIM.\n     *\n     * <p>Requires Permission:\n     * {@link android.Manifest.permission#READ_PRIVILEGED_PHONE_STATE READ_PRIVILEGED_PHONE_STATE}\n     * @hide\n     ",
    "links" : [ "android.Manifest.permission#READ_PRIVILEGED_PHONE_STATE" ]
  }, {
    "name" : "public String[] getIsimImpu()",
    "returnType" : "String[]",
    "comment" : "\n     * Returns the IMS public user identities (IMPU) that were loaded from the ISIM.\n     * @return an array of IMPU strings, with one IMPU per string, or null if\n     *      not present or not loaded\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public int getCallState()",
    "returnType" : "int",
    "comment" : "\n     * Returns the state of all calls on the device.\n     * <p>\n     * This method considers not only calls in the Telephony stack, but also calls via other\n     * {@link android.telecom.ConnectionService} implementations.\n     * <p>\n     * Note: The call state returned via this method may differ from what is reported by\n     * {@link PhoneStateListener#onCallStateChanged(int, String)}, as that callback only considers\n     * Telephony (mobile) calls.\n     *\n     * @return the current call state.\n     ",
    "links" : [ "android.telephony.PhoneStateListener#onCallStateChanged(int", "android.telecom.ConnectionService" ]
  }, {
    "name" : "public int getCallState(int subId)",
    "returnType" : "int",
    "comment" : "\n     * Returns the Telephony call state for calls on a specific subscription.\n     * <p>\n     * Note: This method considers ONLY telephony/mobile calls, where {@link #getCallState()}\n     * considers the state of calls from other {@link android.telecom.ConnectionService}\n     * implementations.\n     *\n     * @param subId the subscription to check call state for.\n     * @hide\n     ",
    "links" : [ "#getCallState()", "android.telecom.ConnectionService" ]
  }, {
    "name" : "private IPhoneSubInfo getSubscriberInfo()",
    "returnType" : "IPhoneSubInfo",
    "comment" : "\n    * @hide\n    ",
    "links" : [ ]
  }, {
    "name" : "public int getCallStateForSlot(int slotIndex)",
    "returnType" : "int",
    "comment" : "\n     * Returns the Telephony call state for calls on a specific SIM slot.\n     * <p>\n     * Note: This method considers ONLY telephony/mobile calls, where {@link #getCallState()}\n     * considers the state of calls from other {@link android.telecom.ConnectionService}\n     * implementations.\n     *\n     * @param slotIndex the SIM slot index to check call state for.\n     * @hide\n     ",
    "links" : [ "#getCallState()", "android.telecom.ConnectionService" ]
  }, {
    "name" : "public int getDataActivity()",
    "returnType" : "int",
    "comment" : "\n     * Returns a constant indicating the type of activity on a data connection\n     * (cellular).\n     *\n     * @see #DATA_ACTIVITY_NONE\n     * @see #DATA_ACTIVITY_IN\n     * @see #DATA_ACTIVITY_OUT\n     * @see #DATA_ACTIVITY_INOUT\n     * @see #DATA_ACTIVITY_DORMANT\n     ",
    "links" : [ ]
  }, {
    "name" : "public int getDataState()",
    "returnType" : "int",
    "comment" : "\n     * Returns a constant indicating the current data connection state\n     * (cellular).\n     *\n     * @see #DATA_DISCONNECTED\n     * @see #DATA_CONNECTING\n     * @see #DATA_CONNECTED\n     * @see #DATA_SUSPENDED\n     * @see #DATA_DISCONNECTING\n     ",
    "links" : [ ]
  }, {
    "name" : "public static String dataStateToString(@DataState int state)",
    "returnType" : "String",
    "comment" : "\n     * Convert data state to string\n     *\n     * @return The data state in string format.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "private ITelephony getITelephony()",
    "returnType" : "ITelephony",
    "comment" : "\n    * @hide\n    ",
    "links" : [ ]
  }, {
    "name" : "private IOns getIOns()",
    "returnType" : "IOns",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public void listen(PhoneStateListener listener, int events)",
    "returnType" : "void",
    "comment" : "\n     * Registers a listener object to receive notification of changes\n     * in specified telephony states.\n     * <p>\n     * To register a listener, pass a {@link PhoneStateListener} and specify at least one telephony\n     * state of interest in the events argument.\n     *\n     * At registration, and when a specified telephony state changes, the telephony manager invokes\n     * the appropriate callback method on the listener object and passes the current (updated)\n     * values.\n     * <p>\n     * To un-register a listener, pass the listener object and set the events argument to\n     * {@link PhoneStateListener#LISTEN_NONE LISTEN_NONE} (0).\n     *\n     * If this TelephonyManager object has been created with {@link #createForSubscriptionId},\n     * applies to the given subId. Otherwise, applies to\n     * {@link SubscriptionManager#getDefaultSubscriptionId()}. To listen events for multiple subIds,\n     * pass a separate listener object to each TelephonyManager object created with\n     * {@link #createForSubscriptionId}.\n     *\n     * Note: if you call this method while in the middle of a binder transaction, you <b>must</b>\n     * call {@link android.os.Binder#clearCallingIdentity()} before calling this method. A\n     * {@link SecurityException} will be thrown otherwise.\n     *\n     * This API should be used sparingly -- large numbers of listeners will cause system\n     * instability. If a process has registered too many listeners without unregistering them, it\n     * may encounter an {@link IllegalStateException} when trying to register more listeners.\n     *\n     * @param listener The {@link PhoneStateListener} object to register\n     *                 (or unregister)\n     * @param events The telephony state(s) of interest to the listener,\n     *               as a bitwise-OR combination of {@link PhoneStateListener}\n     *               LISTEN_ flags.\n     ",
    "links" : [ "#createForSubscriptionId", "IllegalStateException", "android.telephony.PhoneStateListener#LISTEN_NONE", "android.telephony.SubscriptionManager#getDefaultSubscriptionId()", "android.telephony.PhoneStateListener", "android.os.Binder#clearCallingIdentity()", "SecurityException" ]
  }, {
    "name" : "public CdmaEriInformation getCdmaEriInformation()",
    "returnType" : "CdmaEriInformation",
    "comment" : "\n     * Get the CDMA ERI (Enhanced Roaming Indicator) information\n     *\n     * Returns {@link android.telephony#CdmaEriInformation}\n     *\n     * @hide\n     ",
    "links" : [ "android.telephony#CdmaEriInformation" ]
  }, {
    "name" : "public int getCdmaEriIconIndex(int subId)",
    "returnType" : "int",
    "comment" : "\n     * Returns the CDMA ERI icon index to display for a subscription\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public int getCdmaEriIconMode(int subId)",
    "returnType" : "int",
    "comment" : "\n     * Returns the CDMA ERI icon mode for a subscription.\n     * 0 - ON\n     * 1 - FLASHING\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public String getCdmaEriText()",
    "returnType" : "String",
    "comment" : "\n     * Returns the CDMA ERI text,\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public String getCdmaEriText(int subId)",
    "returnType" : "String",
    "comment" : "\n     * Returns the CDMA ERI text, of a subscription\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean isVoiceCapable()",
    "returnType" : "boolean",
    "comment" : "\n     * @return true if the current device is \"voice capable\".\n     * <p>\n     * \"Voice capable\" means that this device supports circuit-switched\n     * (i.e. voice) phone calls over the telephony network, and is allowed\n     * to display the in-call UI while a cellular voice call is active.\n     * This will be false on \"data only\" devices which can't make voice\n     * calls and don't support any in-call UI.\n     * <p>\n     * Note: the meaning of this flag is subtly different from the\n     * PackageManager.FEATURE_TELEPHONY system feature, which is available\n     * on any device with a telephony radio, even if the device is\n     * data-only.\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean isSmsCapable()",
    "returnType" : "boolean",
    "comment" : "\n     * @return true if the current device supports sms service.\n     * <p>\n     * If true, this means that the device supports both sending and\n     * receiving sms via the telephony network.\n     * <p>\n     * Note: Voicemail waiting sms, cell broadcasting sms, and MMS are\n     *       disabled when device doesn't support sms.\n     ",
    "links" : [ ]
  }, {
    "name" : "public List<CellInfo> getAllCellInfo()",
    "returnType" : "List<CellInfo>",
    "comment" : "\n     * Requests all available cell information from all radios on the device including the\n     * camped/registered, serving, and neighboring cells.\n     *\n     * <p>The response can include one or more {@link android.telephony.CellInfoGsm CellInfoGsm},\n     * {@link android.telephony.CellInfoCdma CellInfoCdma},\n     * {@link android.telephony.CellInfoTdscdma CellInfoTdscdma},\n     * {@link android.telephony.CellInfoLte CellInfoLte}, and\n     * {@link android.telephony.CellInfoWcdma CellInfoWcdma} objects, in any combination.\n     * It is typical to see instances of one or more of any these in the list. In addition, zero\n     * or more of the returned objects may be considered registered; that is, their\n     * {@link android.telephony.CellInfo#isRegistered CellInfo.isRegistered()}\n     * methods may return true, indicating that the cell is being used or would be used for\n     * signaling communication if necessary.\n     *\n     * <p>Beginning with {@link android.os.Build.VERSION_CODES#Q Android Q},\n     * if this API results in a change of the cached CellInfo, that change will be reported via\n     * {@link android.telephony.PhoneStateListener#onCellInfoChanged onCellInfoChanged()}.\n     *\n     * <p>Apps targeting {@link android.os.Build.VERSION_CODES#Q Android Q} or higher will no\n     * longer trigger a refresh of the cached CellInfo by invoking this API. Instead, those apps\n     * will receive the latest cached results, which may not be current. Apps targeting\n     * {@link android.os.Build.VERSION_CODES#Q Android Q} or higher that wish to request updated\n     * CellInfo should call\n     * {@link android.telephony.TelephonyManager#requestCellInfoUpdate requestCellInfoUpdate()};\n     * however, in all cases, updates will be rate-limited and are not guaranteed. To determine the\n     * recency of CellInfo data, callers should check\n     * {@link android.telephony.CellInfo#getTimeStamp CellInfo#getTimeStamp()}.\n     *\n     * <p>This method returns valid data for devices with\n     * {@link android.content.pm.PackageManager#FEATURE_TELEPHONY FEATURE_TELEPHONY}. In cases\n     * where only partial information is available for a particular CellInfo entry, unavailable\n     * fields will be reported as {@link android.telephony.CellInfo#UNAVAILABLE}. All reported\n     * cells will include at least a valid set of technology-specific identification info and a\n     * power level measurement.\n     *\n     * <p>This method is preferred over using {@link\n     * android.telephony.TelephonyManager#getCellLocation getCellLocation()}.\n     *\n     * @return List of {@link android.telephony.CellInfo}; null if cell\n     * information is unavailable.\n     ",
    "links" : [ "android.telephony.CellInfoLte", "android.telephony.CellInfoTdscdma", "android.telephony.CellInfoGsm", "android.telephony.CellInfoCdma", "android.telephony.TelephonyManager#requestCellInfoUpdate", "android.telephony.CellInfo#isRegistered", "android.telephony.CellInfoWcdma", "android.telephony.CellInfo", "android.content.pm.PackageManager#FEATURE_TELEPHONY", "android.os.Build.VERSION_CODES#Q", "android.telephony.PhoneStateListener#onCellInfoChanged", "android.telephony.CellInfo#getTimeStamp", "android.telephony.CellInfo#UNAVAILABLE", "android.telephony.TelephonyManager#getCellLocation" ]
  }, {
    "name" : "public void requestCellInfoUpdate(@NonNull @CallbackExecutor Executor executor, @NonNull CellInfoCallback callback)",
    "returnType" : "void",
    "comment" : "\n     * Requests all available cell information from the current subscription for observed\n     * camped/registered, serving, and neighboring cells.\n     *\n     * <p>Any available results from this request will be provided by calls to\n     * {@link android.telephony.PhoneStateListener#onCellInfoChanged onCellInfoChanged()}\n     * for each active subscription.\n     *\n     * <p>This method returns valid data for devices with\n     * {@link android.content.pm.PackageManager#FEATURE_TELEPHONY FEATURE_TELEPHONY}. On devices\n     * that do not implement this feature, the behavior is not reliable.\n     *\n     * @param executor the executor on which callback will be invoked.\n     * @param callback a callback to receive CellInfo.\n     ",
    "links" : [ "android.telephony.PhoneStateListener#onCellInfoChanged", "android.content.pm.PackageManager#FEATURE_TELEPHONY" ]
  }, {
    "name" : "public void requestCellInfoUpdate(@NonNull WorkSource workSource, @NonNull @CallbackExecutor Executor executor, @NonNull CellInfoCallback callback)",
    "returnType" : "void",
    "comment" : "\n     * Requests all available cell information from the current subscription for observed\n     * camped/registered, serving, and neighboring cells.\n     *\n     * <p>Any available results from this request will be provided by calls to\n     * {@link android.telephony.PhoneStateListener#onCellInfoChanged onCellInfoChanged()}\n     * for each active subscription.\n     *\n     * <p>This method returns valid data for devices with\n     * {@link android.content.pm.PackageManager#FEATURE_TELEPHONY FEATURE_TELEPHONY}. On devices\n     * that do not implement this feature, the behavior is not reliable.\n     *\n     * @param workSource the requestor to whom the power consumption for this should be attributed.\n     * @param executor the executor on which callback will be invoked.\n     * @param callback a callback to receive CellInfo.\n     * @hide\n     ",
    "links" : [ "android.telephony.PhoneStateListener#onCellInfoChanged", "android.content.pm.PackageManager#FEATURE_TELEPHONY" ]
  }, {
    "name" : "private static Throwable createThrowableByClassName(String className, String message)",
    "returnType" : "Throwable",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public void setCellInfoListRate(int rateInMillis)",
    "returnType" : "void",
    "comment" : "\n     * Sets the minimum time in milli-seconds between {@link PhoneStateListener#onCellInfoChanged\n     * PhoneStateListener.onCellInfoChanged} will be invoked.\n     *<p>\n     * The default, 0, means invoke onCellInfoChanged when any of the reported\n     * information changes. Setting the value to INT_MAX(0x7fffffff) means never issue\n     * A onCellInfoChanged.\n     *<p>\n     * @param rateInMillis the rate\n     *\n     * @hide\n     ",
    "links" : [ "android.telephony.PhoneStateListener#onCellInfoChangedPhoneStateListener.onCellInfoChanged" ]
  }, {
    "name" : "public String getMmsUserAgent()",
    "returnType" : "String",
    "comment" : "\n     * Returns the MMS user agent.\n     ",
    "links" : [ ]
  }, {
    "name" : "public String getMmsUAProfUrl()",
    "returnType" : "String",
    "comment" : "\n     * Returns the MMS user agent profile URL.\n     ",
    "links" : [ ]
  }, {
    "name" : "public IccOpenLogicalChannelResponse iccOpenLogicalChannel(String AID)",
    "returnType" : "IccOpenLogicalChannelResponse",
    "comment" : "\n     * Opens a logical channel to the ICC card.\n     *\n     * Input parameters equivalent to TS 27.007 AT+CCHO command.\n     *\n     * <p>Requires Permission:\n     * {@link android.Manifest.permission#MODIFY_PHONE_STATE MODIFY_PHONE_STATE} or that the calling\n     * app has carrier privileges (see {@link #hasCarrierPrivileges}).\n     *\n     * @param AID Application id. See ETSI 102.221 and 101.220.\n     * @return an IccOpenLogicalChannelResponse object.\n     * @deprecated Replaced by {@link #iccOpenLogicalChannel(String, int)}\n     ",
    "links" : [ "#hasCarrierPrivileges", "android.Manifest.permission#MODIFY_PHONE_STATE", "#iccOpenLogicalChannel(String" ]
  }, {
    "name" : "public IccOpenLogicalChannelResponse iccOpenLogicalChannelBySlot(int slotIndex, @Nullable String aid, int p2)",
    "returnType" : "IccOpenLogicalChannelResponse",
    "comment" : "\n     * Opens a logical channel to the ICC card using the physical slot index.\n     *\n     * Use this method when no subscriptions are available on the SIM and the operation must be\n     * performed using the physical slot index.\n     *\n     * This operation wraps two APDU instructions:\n     * <ul>\n     *     <li>MANAGE CHANNEL to open a logical channel</li>\n     *     <li>SELECT the given {@code AID} using the given {@code p2}</li>\n     * </ul>\n     *\n     * Per Open Mobile API Specification v3.2 section 6.2.7.h, only p2 values of 0x00, 0x04, 0x08,\n     * and 0x0C are guaranteed to be supported.\n     *\n     * If the SELECT command's status word is not '9000', '62xx', or '63xx', the status word will be\n     * considered an error and the channel shall not be opened.\n     *\n     * Input parameters equivalent to TS 27.007 AT+CCHO command.\n     *\n     * <p>Requires Permission:\n     * {@link android.Manifest.permission#MODIFY_PHONE_STATE MODIFY_PHONE_STATE}.\n     *\n     * @param slotIndex the physical slot index of the ICC card\n     * @param aid Application id. See ETSI 102.221 and 101.220.\n     * @param p2 P2 parameter (described in ISO 7816-4).\n     * @return an IccOpenLogicalChannelResponse object.\n     * @hide\n     ",
    "links" : [ "android.Manifest.permission#MODIFY_PHONE_STATE" ]
  }, {
    "name" : "public IccOpenLogicalChannelResponse iccOpenLogicalChannel(String AID, int p2)",
    "returnType" : "IccOpenLogicalChannelResponse",
    "comment" : "\n     * Opens a logical channel to the ICC card.\n     *\n     * This operation wraps two APDU instructions:\n     * <ul>\n     *     <li>MANAGE CHANNEL to open a logical channel</li>\n     *     <li>SELECT the given {@code AID} using the given {@code p2}</li>\n     * </ul>\n     *\n     * Per Open Mobile API Specification v3.2 section 6.2.7.h, only p2 values of 0x00, 0x04, 0x08,\n     * and 0x0C are guaranteed to be supported.\n     *\n     * If the SELECT command's status word is not '9000', '62xx', or '63xx', the status word will be\n     * considered an error and the channel shall not be opened.\n     *\n     * Input parameters equivalent to TS 27.007 AT+CCHO command.\n     *\n     * <p>Requires Permission:\n     * {@link android.Manifest.permission#MODIFY_PHONE_STATE MODIFY_PHONE_STATE} or that the calling\n     * app has carrier privileges (see {@link #hasCarrierPrivileges}).\n     *\n     * @param AID Application id. See ETSI 102.221 and 101.220.\n     * @param p2 P2 parameter (described in ISO 7816-4).\n     * @return an IccOpenLogicalChannelResponse object.\n     * @deprecated Use {@link android.se.omapi.SEService} APIs instead. See\n     *             {@link android.se.omapi.SEService#getUiccReader(int)},\n     *             {@link android.se.omapi.Reader#openSession()},\n     *             {@link android.se.omapi.Session#openLogicalChannel(byte[], byte)}.\n     ",
    "links" : [ "android.se.omapi.SEService#getUiccReader(int)", "#hasCarrierPrivileges", "android.Manifest.permission#MODIFY_PHONE_STATE", "android.se.omapi.Reader#openSession()", "android.se.omapi.SEService", "android.se.omapi.Session#openLogicalChannel(byte" ]
  }, {
    "name" : "public IccOpenLogicalChannelResponse iccOpenLogicalChannel(int subId, String AID, int p2)",
    "returnType" : "IccOpenLogicalChannelResponse",
    "comment" : "\n     * Opens a logical channel to the ICC card.\n     *\n     * This operation wraps two APDU instructions:\n     * <ul>\n     *     <li>MANAGE CHANNEL to open a logical channel</li>\n     *     <li>SELECT the given {@code AID} using the given {@code p2}</li>\n     * </ul>\n     *\n     * Per Open Mobile API Specification v3.2 section 6.2.7.h, only p2 values of 0x00, 0x04, 0x08,\n     * and 0x0C are guaranteed to be supported.\n     *\n     * If the SELECT command's status word is not '9000', '62xx', or '63xx', the status word will be\n     * considered an error and the channel shall not be opened.\n     *\n     * Input parameters equivalent to TS 27.007 AT+CCHO command.\n     *\n     * <p>Requires Permission:\n     * {@link android.Manifest.permission#MODIFY_PHONE_STATE MODIFY_PHONE_STATE} or that the calling\n     * app has carrier privileges (see {@link #hasCarrierPrivileges}).\n     *\n     * @param subId The subscription to use.\n     * @param AID Application id. See ETSI 102.221 and 101.220.\n     * @param p2 P2 parameter (described in ISO 7816-4).\n     * @return an IccOpenLogicalChannelResponse object.\n     * @hide\n     * @deprecated Use {@link android.se.omapi.SEService} APIs instead. See\n     *             {@link android.se.omapi.SEService#getUiccReader(int)},\n     *             {@link android.se.omapi.Reader#openSession()},\n     *             {@link android.se.omapi.Session#openLogicalChannel(byte[], byte)}.\n     ",
    "links" : [ "android.se.omapi.SEService#getUiccReader(int)", "#hasCarrierPrivileges", "android.Manifest.permission#MODIFY_PHONE_STATE", "android.se.omapi.Reader#openSession()", "android.se.omapi.SEService", "android.se.omapi.Session#openLogicalChannel(byte" ]
  }, {
    "name" : "public boolean iccCloseLogicalChannelBySlot(int slotIndex, int channel)",
    "returnType" : "boolean",
    "comment" : "\n     * Closes a previously opened logical channel to the ICC card using the physical slot index.\n     *\n     * Use this method when no subscriptions are available on the SIM and the operation must be\n     * performed using the physical slot index.\n     *\n     * Input parameters equivalent to TS 27.007 AT+CCHC command.\n     *\n     * <p>Requires Permission:\n     * {@link android.Manifest.permission#MODIFY_PHONE_STATE MODIFY_PHONE_STATE}.\n     *\n     * @param slotIndex the physical slot index of the ICC card\n     * @param channel is the channel id to be closed as returned by a successful\n     *            iccOpenLogicalChannel.\n     * @return true if the channel was closed successfully.\n     * @hide\n     * @deprecated Use {@link android.se.omapi.SEService} APIs instead. See\n     *             {@link android.se.omapi.Channel#close()}.\n     ",
    "links" : [ "android.se.omapi.Channel#close()", "android.Manifest.permission#MODIFY_PHONE_STATE", "android.se.omapi.SEService" ]
  }, {
    "name" : "public boolean iccCloseLogicalChannel(int channel)",
    "returnType" : "boolean",
    "comment" : "\n     * Closes a previously opened logical channel to the ICC card.\n     *\n     * Input parameters equivalent to TS 27.007 AT+CCHC command.\n     *\n     * <p>Requires Permission:\n     * {@link android.Manifest.permission#MODIFY_PHONE_STATE MODIFY_PHONE_STATE} or that the calling\n     * app has carrier privileges (see {@link #hasCarrierPrivileges}).\n     *\n     * @param channel is the channel id to be closed as returned by a successful\n     *            iccOpenLogicalChannel.\n     * @return true if the channel was closed successfully.\n     * @deprecated Use {@link android.se.omapi.SEService} APIs instead. See\n     *             {@link android.se.omapi.Channel#close()}.\n     ",
    "links" : [ "#hasCarrierPrivileges", "android.se.omapi.Channel#close()", "android.Manifest.permission#MODIFY_PHONE_STATE", "android.se.omapi.SEService" ]
  }, {
    "name" : "public boolean iccCloseLogicalChannel(int subId, int channel)",
    "returnType" : "boolean",
    "comment" : "\n     * Closes a previously opened logical channel to the ICC card.\n     *\n     * Input parameters equivalent to TS 27.007 AT+CCHC command.\n     *\n     * <p>Requires Permission:\n     * {@link android.Manifest.permission#MODIFY_PHONE_STATE MODIFY_PHONE_STATE} or that the calling\n     * app has carrier privileges (see {@link #hasCarrierPrivileges}).\n     *\n     * @param subId The subscription to use.\n     * @param channel is the channel id to be closed as returned by a successful\n     *            iccOpenLogicalChannel.\n     * @return true if the channel was closed successfully.\n     * @hide\n     * @deprecated Use {@link android.se.omapi.SEService} APIs instead. See\n     *             {@link android.se.omapi.Channel#close()}.\n     ",
    "links" : [ "#hasCarrierPrivileges", "android.se.omapi.Channel#close()", "android.Manifest.permission#MODIFY_PHONE_STATE", "android.se.omapi.SEService" ]
  }, {
    "name" : "public String iccTransmitApduLogicalChannelBySlot(int slotIndex, int channel, int cla, int instruction, int p1, int p2, int p3, @Nullable String data)",
    "returnType" : "String",
    "comment" : "\n     * Transmit an APDU to the ICC card over a logical channel using the physical slot index.\n     *\n     * Use this method when no subscriptions are available on the SIM and the operation must be\n     * performed using the physical slot index.\n     *\n     * Input parameters equivalent to TS 27.007 AT+CGLA command.\n     *\n     * <p>Requires Permission:\n     * {@link android.Manifest.permission#MODIFY_PHONE_STATE MODIFY_PHONE_STATE}.\n     *\n     * @param slotIndex the physical slot index of the ICC card\n     * @param channel is the channel id to be closed as returned by a successful\n     *            iccOpenLogicalChannel.\n     * @param cla Class of the APDU command.\n     * @param instruction Instruction of the APDU command.\n     * @param p1 P1 value of the APDU command.\n     * @param p2 P2 value of the APDU command.\n     * @param p3 P3 value of the APDU command. If p3 is negative a 4 byte APDU\n     *            is sent to the SIM.\n     * @param data Data to be sent with the APDU.\n     * @return The APDU response from the ICC card with the status appended at the end, or null if\n     * there is an issue connecting to the Telephony service.\n     * @hide\n     * @deprecated Use {@link android.se.omapi.SEService} APIs instead. See\n     *             {@link android.se.omapi.Channel#transmit(byte[])}.\n     ",
    "links" : [ "android.se.omapi.Channel#transmit(byte", "android.Manifest.permission#MODIFY_PHONE_STATE", "android.se.omapi.SEService" ]
  }, {
    "name" : "public String iccTransmitApduLogicalChannel(int channel, int cla, int instruction, int p1, int p2, int p3, String data)",
    "returnType" : "String",
    "comment" : "\n     * Transmit an APDU to the ICC card over a logical channel.\n     *\n     * Input parameters equivalent to TS 27.007 AT+CGLA command.\n     *\n     * <p>Requires Permission:\n     * {@link android.Manifest.permission#MODIFY_PHONE_STATE MODIFY_PHONE_STATE} or that the calling\n     * app has carrier privileges (see {@link #hasCarrierPrivileges}).\n     *\n     * @param channel is the channel id to be closed as returned by a successful\n     *            iccOpenLogicalChannel.\n     * @param cla Class of the APDU command.\n     * @param instruction Instruction of the APDU command.\n     * @param p1 P1 value of the APDU command.\n     * @param p2 P2 value of the APDU command.\n     * @param p3 P3 value of the APDU command. If p3 is negative a 4 byte APDU\n     *            is sent to the SIM.\n     * @param data Data to be sent with the APDU.\n     * @return The APDU response from the ICC card with the status appended at\n     *            the end.\n     * @deprecated Use {@link android.se.omapi.SEService} APIs instead. See\n     *             {@link android.se.omapi.Channel#transmit(byte[])}.\n     ",
    "links" : [ "android.se.omapi.Channel#transmit(byte", "#hasCarrierPrivileges", "android.Manifest.permission#MODIFY_PHONE_STATE", "android.se.omapi.SEService" ]
  }, {
    "name" : "public String iccTransmitApduLogicalChannel(int subId, int channel, int cla, int instruction, int p1, int p2, int p3, String data)",
    "returnType" : "String",
    "comment" : "\n     * Transmit an APDU to the ICC card over a logical channel.\n     *\n     * Input parameters equivalent to TS 27.007 AT+CGLA command.\n     *\n     * <p>Requires Permission:\n     * {@link android.Manifest.permission#MODIFY_PHONE_STATE MODIFY_PHONE_STATE} or that the calling\n     * app has carrier privileges (see {@link #hasCarrierPrivileges}).\n     *\n     * @param subId The subscription to use.\n     * @param channel is the channel id to be closed as returned by a successful\n     *            iccOpenLogicalChannel.\n     * @param cla Class of the APDU command.\n     * @param instruction Instruction of the APDU command.\n     * @param p1 P1 value of the APDU command.\n     * @param p2 P2 value of the APDU command.\n     * @param p3 P3 value of the APDU command. If p3 is negative a 4 byte APDU\n     *            is sent to the SIM.\n     * @param data Data to be sent with the APDU.\n     * @return The APDU response from the ICC card with the status appended at\n     *            the end.\n     * @hide\n     * @deprecated Use {@link android.se.omapi.SEService} APIs instead. See\n     *             {@link android.se.omapi.Channel#transmit(byte[])}.\n     ",
    "links" : [ "android.se.omapi.Channel#transmit(byte", "#hasCarrierPrivileges", "android.Manifest.permission#MODIFY_PHONE_STATE", "android.se.omapi.SEService" ]
  }, {
    "name" : "public String iccTransmitApduBasicChannelBySlot(int slotIndex, int cla, int instruction, int p1, int p2, int p3, @Nullable String data)",
    "returnType" : "String",
    "comment" : "\n     * Transmit an APDU to the ICC card over the basic channel using the physical slot index.\n     *\n     * Use this method when no subscriptions are available on the SIM and the operation must be\n     * performed using the physical slot index.\n     *\n     * Input parameters equivalent to TS 27.007 AT+CSIM command.\n     *\n     * <p>Requires Permission:\n     * {@link android.Manifest.permission#MODIFY_PHONE_STATE MODIFY_PHONE_STATE}.\n     *\n     * @param slotIndex the physical slot index of the ICC card to target\n     * @param cla Class of the APDU command.\n     * @param instruction Instruction of the APDU command.\n     * @param p1 P1 value of the APDU command.\n     * @param p2 P2 value of the APDU command.\n     * @param p3 P3 value of the APDU command. If p3 is negative a 4 byte APDU\n     *            is sent to the SIM.\n     * @param data Data to be sent with the APDU.\n     * @return The APDU response from the ICC card with the status appended at\n     *            the end.\n     * @hide\n     * @deprecated Use {@link android.se.omapi.SEService} APIs instead. See\n     *             {@link android.se.omapi.SEService#getUiccReader(int)},\n     *             {@link android.se.omapi.Reader#openSession()},\n     *             {@link android.se.omapi.Session#openBasicChannel(byte[], byte)},\n     *             {@link android.se.omapi.Channel#transmit(byte[])}.\n     ",
    "links" : [ "android.se.omapi.SEService#getUiccReader(int)", "android.se.omapi.Channel#transmit(byte", "android.se.omapi.Session#openBasicChannel(byte", "android.Manifest.permission#MODIFY_PHONE_STATE", "android.se.omapi.Reader#openSession()", "android.se.omapi.SEService" ]
  }, {
    "name" : "public String iccTransmitApduBasicChannel(int cla, int instruction, int p1, int p2, int p3, String data)",
    "returnType" : "String",
    "comment" : "\n     * Transmit an APDU to the ICC card over the basic channel.\n     *\n     * Input parameters equivalent to TS 27.007 AT+CSIM command.\n     *\n     * <p>Requires Permission:\n     * {@link android.Manifest.permission#MODIFY_PHONE_STATE MODIFY_PHONE_STATE} or that the calling\n     * app has carrier privileges (see {@link #hasCarrierPrivileges}).\n     *\n     * @param cla Class of the APDU command.\n     * @param instruction Instruction of the APDU command.\n     * @param p1 P1 value of the APDU command.\n     * @param p2 P2 value of the APDU command.\n     * @param p3 P3 value of the APDU command. If p3 is negative a 4 byte APDU\n     *            is sent to the SIM.\n     * @param data Data to be sent with the APDU.\n     * @return The APDU response from the ICC card with the status appended at\n     *            the end.\n     * @deprecated Use {@link android.se.omapi.SEService} APIs instead. See\n     *             {@link android.se.omapi.SEService#getUiccReader(int)},\n     *             {@link android.se.omapi.Reader#openSession()},\n     *             {@link android.se.omapi.Session#openBasicChannel(byte[], byte)},\n     *             {@link android.se.omapi.Channel#transmit(byte[])}.\n     ",
    "links" : [ "android.se.omapi.SEService#getUiccReader(int)", "android.se.omapi.Channel#transmit(byte", "#hasCarrierPrivileges", "android.se.omapi.Session#openBasicChannel(byte", "android.Manifest.permission#MODIFY_PHONE_STATE", "android.se.omapi.Reader#openSession()", "android.se.omapi.SEService" ]
  }, {
    "name" : "public String iccTransmitApduBasicChannel(int subId, int cla, int instruction, int p1, int p2, int p3, String data)",
    "returnType" : "String",
    "comment" : "\n     * Transmit an APDU to the ICC card over the basic channel.\n     *\n     * Input parameters equivalent to TS 27.007 AT+CSIM command.\n     *\n     * <p>Requires Permission:\n     * {@link android.Manifest.permission#MODIFY_PHONE_STATE MODIFY_PHONE_STATE} or that the calling\n     * app has carrier privileges (see {@link #hasCarrierPrivileges}).\n     *\n     * @param subId The subscription to use.\n     * @param cla Class of the APDU command.\n     * @param instruction Instruction of the APDU command.\n     * @param p1 P1 value of the APDU command.\n     * @param p2 P2 value of the APDU command.\n     * @param p3 P3 value of the APDU command. If p3 is negative a 4 byte APDU\n     *            is sent to the SIM.\n     * @param data Data to be sent with the APDU.\n     * @return The APDU response from the ICC card with the status appended at\n     *            the end.\n     * @hide\n     * @deprecated Use {@link android.se.omapi.SEService} APIs instead. See\n     *             {@link android.se.omapi.SEService#getUiccReader(int)},\n     *             {@link android.se.omapi.Reader#openSession()},\n     *             {@link android.se.omapi.Session#openBasicChannel(byte[], byte)},\n     *             {@link android.se.omapi.Channel#transmit(byte[])}.\n     ",
    "links" : [ "android.se.omapi.SEService#getUiccReader(int)", "android.se.omapi.Channel#transmit(byte", "#hasCarrierPrivileges", "android.se.omapi.Session#openBasicChannel(byte", "android.Manifest.permission#MODIFY_PHONE_STATE", "android.se.omapi.Reader#openSession()", "android.se.omapi.SEService" ]
  }, {
    "name" : "public byte[] iccExchangeSimIO(int fileID, int command, int p1, int p2, int p3, String filePath)",
    "returnType" : "byte[]",
    "comment" : "\n     * Returns the response APDU for a command APDU sent through SIM_IO.\n     *\n     * <p>Requires Permission:\n     * {@link android.Manifest.permission#MODIFY_PHONE_STATE MODIFY_PHONE_STATE} or that the calling\n     * app has carrier privileges (see {@link #hasCarrierPrivileges}).\n     *\n     * @param fileID\n     * @param command\n     * @param p1 P1 value of the APDU command.\n     * @param p2 P2 value of the APDU command.\n     * @param p3 P3 value of the APDU command.\n     * @param filePath\n     * @return The APDU response.\n     * @deprecated Use {@link android.se.omapi.SEService} APIs instead. See\n     *             {@link android.se.omapi.SEService#getUiccReader(int)},\n     *             {@link android.se.omapi.Reader#openSession()},\n     *             {@link android.se.omapi.Session#openBasicChannel(byte[], byte)},\n     *             {@link android.se.omapi.Channel#transmit(byte[])}.\n     ",
    "links" : [ "android.se.omapi.SEService#getUiccReader(int)", "android.se.omapi.Channel#transmit(byte", "#hasCarrierPrivileges", "android.se.omapi.Session#openBasicChannel(byte", "android.Manifest.permission#MODIFY_PHONE_STATE", "android.se.omapi.Reader#openSession()", "android.se.omapi.SEService" ]
  }, {
    "name" : "public byte[] iccExchangeSimIO(int subId, int fileID, int command, int p1, int p2, int p3, String filePath)",
    "returnType" : "byte[]",
    "comment" : "\n     * Returns the response APDU for a command APDU sent through SIM_IO.\n     *\n     * <p>Requires Permission:\n     * {@link android.Manifest.permission#MODIFY_PHONE_STATE MODIFY_PHONE_STATE} or that the calling\n     * app has carrier privileges (see {@link #hasCarrierPrivileges}).\n     *\n     * @param subId The subscription to use.\n     * @param fileID\n     * @param command\n     * @param p1 P1 value of the APDU command.\n     * @param p2 P2 value of the APDU command.\n     * @param p3 P3 value of the APDU command.\n     * @param filePath\n     * @return The APDU response.\n     * @hide\n     * @deprecated Use {@link android.se.omapi.SEService} APIs instead. See\n     *             {@link android.se.omapi.SEService#getUiccReader(int)},\n     *             {@link android.se.omapi.Reader#openSession()},\n     *             {@link android.se.omapi.Session#openBasicChannel(byte[], byte)},\n     *             {@link android.se.omapi.Channel#transmit(byte[])}.\n     ",
    "links" : [ "android.se.omapi.SEService#getUiccReader(int)", "android.se.omapi.Channel#transmit(byte", "#hasCarrierPrivileges", "android.se.omapi.Session#openBasicChannel(byte", "android.Manifest.permission#MODIFY_PHONE_STATE", "android.se.omapi.Reader#openSession()", "android.se.omapi.SEService" ]
  }, {
    "name" : "public String sendEnvelopeWithStatus(String content)",
    "returnType" : "String",
    "comment" : "\n     * Send ENVELOPE to the SIM and return the response.\n     *\n     * <p>Requires Permission:\n     * {@link android.Manifest.permission#MODIFY_PHONE_STATE MODIFY_PHONE_STATE} or that the calling\n     * app has carrier privileges (see {@link #hasCarrierPrivileges}).\n     *\n     * @param content String containing SAT/USAT response in hexadecimal\n     *                format starting with command tag. See TS 102 223 for\n     *                details.\n     * @return The APDU response from the ICC card in hexadecimal format\n     *         with the last 4 bytes being the status word. If the command fails,\n     *         returns an empty string.\n     * @deprecated Use {@link android.se.omapi.SEService} APIs instead. See\n     *             {@link android.se.omapi.SEService#getUiccReader(int)},\n     *             {@link android.se.omapi.Reader#openSession()},\n     *             {@link android.se.omapi.Session#openBasicChannel(byte[], byte)},\n     *             {@link android.se.omapi.Channel#transmit(byte[])}.\n     ",
    "links" : [ "android.se.omapi.SEService#getUiccReader(int)", "android.se.omapi.Channel#transmit(byte", "#hasCarrierPrivileges", "android.se.omapi.Session#openBasicChannel(byte", "android.Manifest.permission#MODIFY_PHONE_STATE", "android.se.omapi.Reader#openSession()", "android.se.omapi.SEService" ]
  }, {
    "name" : "public String sendEnvelopeWithStatus(int subId, String content)",
    "returnType" : "String",
    "comment" : "\n     * Send ENVELOPE to the SIM and return the response.\n     *\n     * <p>Requires Permission:\n     * {@link android.Manifest.permission#MODIFY_PHONE_STATE MODIFY_PHONE_STATE} or that the calling\n     * app has carrier privileges (see {@link #hasCarrierPrivileges}).\n     *\n     * @param subId The subscription to use.\n     * @param content String containing SAT/USAT response in hexadecimal\n     *                format starting with command tag. See TS 102 223 for\n     *                details.\n     * @return The APDU response from the ICC card in hexadecimal format\n     *         with the last 4 bytes being the status word. If the command fails,\n     *         returns an empty string.\n     * @hide\n     * @deprecated Use {@link android.se.omapi.SEService} APIs instead. See\n     *             {@link android.se.omapi.SEService#getUiccReader(int)},\n     *             {@link android.se.omapi.Reader#openSession()},\n     *             {@link android.se.omapi.Session#openBasicChannel(byte[], byte)},\n     *             {@link android.se.omapi.Channel#transmit(byte[])}.\n     ",
    "links" : [ "android.se.omapi.SEService#getUiccReader(int)", "android.se.omapi.Channel#transmit(byte", "#hasCarrierPrivileges", "android.se.omapi.Session#openBasicChannel(byte", "android.Manifest.permission#MODIFY_PHONE_STATE", "android.se.omapi.Reader#openSession()", "android.se.omapi.SEService" ]
  }, {
    "name" : "public String nvReadItem(int itemID)",
    "returnType" : "String",
    "comment" : "\n     * Read one of the NV items defined in com.android.internal.telephony.RadioNVItems.\n     * Used for device configuration by some CDMA operators.\n     *\n     * <p>Requires Permission:\n     * {@link android.Manifest.permission#MODIFY_PHONE_STATE MODIFY_PHONE_STATE} or that the calling\n     * app has carrier privileges (see {@link #hasCarrierPrivileges}).\n     *\n     * @param itemID the ID of the item to read.\n     * @return the NV item as a String, or null on any failure.\n     *\n     * @hide\n     ",
    "links" : [ "#hasCarrierPrivileges", "android.Manifest.permission#MODIFY_PHONE_STATE" ]
  }, {
    "name" : "public boolean nvWriteItem(int itemID, String itemValue)",
    "returnType" : "boolean",
    "comment" : "\n     * Write one of the NV items defined in com.android.internal.telephony.RadioNVItems.\n     * Used for device configuration by some CDMA operators.\n     *\n     * <p>Requires Permission:\n     * {@link android.Manifest.permission#MODIFY_PHONE_STATE MODIFY_PHONE_STATE} or that the calling\n     * app has carrier privileges (see {@link #hasCarrierPrivileges}).\n     *\n     * @param itemID the ID of the item to read.\n     * @param itemValue the value to write, as a String.\n     * @return true on success; false on any failure.\n     *\n     * @hide\n     ",
    "links" : [ "#hasCarrierPrivileges", "android.Manifest.permission#MODIFY_PHONE_STATE" ]
  }, {
    "name" : "public boolean nvWriteCdmaPrl(byte[] preferredRoamingList)",
    "returnType" : "boolean",
    "comment" : "\n     * Update the CDMA Preferred Roaming List (PRL) in the radio NV storage.\n     * Used for device configuration by some CDMA operators.\n     *\n     * <p>Requires Permission:\n     * {@link android.Manifest.permission#MODIFY_PHONE_STATE MODIFY_PHONE_STATE} or that the calling\n     * app has carrier privileges (see {@link #hasCarrierPrivileges}).\n     *\n     * @param preferredRoamingList byte array containing the new PRL.\n     * @return true on success; false on any failure.\n     *\n     * @hide\n     ",
    "links" : [ "#hasCarrierPrivileges", "android.Manifest.permission#MODIFY_PHONE_STATE" ]
  }, {
    "name" : "public boolean nvResetConfig(int resetType)",
    "returnType" : "boolean",
    "comment" : "\n     * Perform the specified type of NV config reset. The radio will be taken offline\n     * and the device must be rebooted after the operation. Used for device\n     * configuration by some CDMA operators.\n     *\n     * <p>Requires Permission:\n     * {@link android.Manifest.permission#MODIFY_PHONE_STATE MODIFY_PHONE_STATE} or that the calling\n     * app has carrier privileges (see {@link #hasCarrierPrivileges}).\n     *\n     * TODO: remove this one. use {@link #rebootRadio()} for reset type 1 and\n     * {@link #resetRadioConfig()} for reset type 3\n     *\n     * @param resetType reset type: 1: reload NV reset, 2: erase NV reset, 3: factory NV reset\n     * @return true on success; false on any failure.\n     *\n     * @hide\n     ",
    "links" : [ "#rebootRadio()", "#hasCarrierPrivileges", "android.Manifest.permission#MODIFY_PHONE_STATE", "#resetRadioConfig()" ]
  }, {
    "name" : "public boolean resetRadioConfig()",
    "returnType" : "boolean",
    "comment" : "\n     * Rollback modem configurations to factory default except some config which are in whitelist.\n     * Used for device configuration by some carriers.\n     *\n     * <p>Requires Permission:\n     * {@link android.Manifest.permission#MODIFY_PHONE_STATE MODIFY_PHONE_STATE} or that the calling\n     * app has carrier privileges (see {@link #hasCarrierPrivileges}).\n     *\n     * @return {@code true} on success; {@code false} on any failure.\n     *\n     * @hide\n     ",
    "links" : [ "#hasCarrierPrivileges", "android.Manifest.permission#MODIFY_PHONE_STATE" ]
  }, {
    "name" : "public boolean rebootRadio()",
    "returnType" : "boolean",
    "comment" : "\n     * Generate a radio modem reset. Used for device configuration by some carriers.\n     *\n     * <p>Requires Permission:\n     * {@link android.Manifest.permission#MODIFY_PHONE_STATE MODIFY_PHONE_STATE} or that the calling\n     * app has carrier privileges (see {@link #hasCarrierPrivileges}).\n     *\n     * @return {@code true} on success; {@code false} on any failure.\n     *\n     * @hide\n     ",
    "links" : [ "#hasCarrierPrivileges", "android.Manifest.permission#MODIFY_PHONE_STATE" ]
  }, {
    "name" : "public int getSubscriptionId()",
    "returnType" : "int",
    "comment" : "\n     * Return an appropriate subscription ID for any situation.\n     *\n     * If this object has been created with {@link #createForSubscriptionId}, then the provided\n     * subscription ID is returned. Otherwise, the default subscription ID will be returned.\n     *\n     ",
    "links" : [ "#createForSubscriptionId" ]
  }, {
    "name" : "private int getSubId()",
    "returnType" : "int",
    "comment" : "\n     * Return an appropriate subscription ID for any situation.\n     *\n     * If this object has been created with {@link #createForSubscriptionId}, then the provided\n     * subscription ID is returned. Otherwise, the default subscription ID will be returned.\n     *\n     ",
    "links" : [ "#createForSubscriptionId" ]
  }, {
    "name" : "private int getSubId(int preferredSubId)",
    "returnType" : "int",
    "comment" : "\n     * Return an appropriate subscription ID for any situation.\n     *\n     * If this object has been created with {@link #createForSubscriptionId}, then the provided\n     * subId is returned. Otherwise, the preferred subId which is based on caller's context is\n     * returned.\n     * {@see SubscriptionManager#getDefaultDataSubscriptionId()}\n     * {@see SubscriptionManager#getDefaultVoiceSubscriptionId()}\n     * {@see SubscriptionManager#getDefaultSmsSubscriptionId()}\n     ",
    "links" : [ "#createForSubscriptionId" ]
  }, {
    "name" : "private int getPhoneId()",
    "returnType" : "int",
    "comment" : "\n     * Return an appropriate phone ID for any situation.\n     *\n     * If this object has been created with {@link #createForSubscriptionId}, then the phoneId\n     * associated with the provided subId is returned. Otherwise, the default phoneId associated\n     * with the default subId will be returned.\n     ",
    "links" : [ "#createForSubscriptionId" ]
  }, {
    "name" : "private int getPhoneId(int preferredSubId)",
    "returnType" : "int",
    "comment" : "\n     * Return an appropriate phone ID for any situation.\n     *\n     * If this object has been created with {@link #createForSubscriptionId}, then the phoneId\n     * associated with the provided subId is returned. Otherwise, return the phoneId associated\n     * with the preferred subId based on caller's context.\n     * {@see SubscriptionManager#getDefaultDataSubscriptionId()}\n     * {@see SubscriptionManager#getDefaultVoiceSubscriptionId()}\n     * {@see SubscriptionManager#getDefaultSmsSubscriptionId()}\n     ",
    "links" : [ "#createForSubscriptionId" ]
  }, {
    "name" : "public int getSlotIndex()",
    "returnType" : "int",
    "comment" : "\n     * Return an appropriate slot index for any situation.\n     *\n     * if this object has been created with {@link #createForSubscriptionId}, then the slot index\n     * associated with the provided subId is returned. Otherwise, return the slot index associated\n     * with the default subId.\n     * If SIM is not inserted, return default SIM slot index.\n     *\n     * {@hide}\n     ",
    "links" : [ "#createForSubscriptionId" ]
  }, {
    "name" : "public void requestNumberVerification(@NonNull PhoneNumberRange range, long timeoutMillis, @NonNull @CallbackExecutor Executor executor, @NonNull NumberVerificationCallback callback)",
    "returnType" : "void",
    "comment" : "\n     * Request that the next incoming call from a number matching {@code range} be intercepted.\n     *\n     * This API is intended for OEMs to provide a service for apps to verify the device's phone\n     * number. When called, the Telephony stack will store the provided {@link PhoneNumberRange} and\n     * intercept the next incoming call from a number that lies within the range, within a timeout\n     * specified by {@code timeoutMillis}.\n     *\n     * If such a phone call is received, the caller will be notified via\n     * {@link NumberVerificationCallback#onCallReceived(String)} on the provided {@link Executor}.\n     * If verification fails for any reason, the caller will be notified via\n     * {@link NumberVerificationCallback#onVerificationFailed(int)}\n     * on the provided {@link Executor}.\n     *\n     * In addition to the {@link Manifest.permission#MODIFY_PHONE_STATE} permission, callers of this\n     * API must also be listed in the device configuration as an authorized app in\n     * {@code packages/services/Telephony/res/values/config.xml} under the\n     * {@code config_number_verification_package_name} key.\n     *\n     * @hide\n     * @param range The range of phone numbers the caller expects a phone call from.\n     * @param timeoutMillis The amount of time to wait for such a call, or the value of\n     *                      {@link #getMaxNumberVerificationTimeoutMillis()}, whichever is lesser.\n     * @param executor The {@link Executor} that callbacks should be executed on.\n     * @param callback The callback to use for delivering results.\n     ",
    "links" : [ "Manifest.permission#MODIFY_PHONE_STATE", "android.annotation.CallbackExecutor", "com.android.internal.telephony.INumberVerificationCallback#onVerificationFailed(int)", "#getMaxNumberVerificationTimeoutMillis()", "android.telephony.PhoneNumberRange", "com.android.internal.telephony.INumberVerificationCallback#onCallReceived(String)" ]
  }, {
    "name" : "private static List<T> updateTelephonyProperty(List<T> prop, int phoneId, T value)",
    "returnType" : "List<T>",
    "comment" : "\n     * Inserts or updates a list property. Expands the list if its length is not enough.\n     ",
    "links" : [ ]
  }, {
    "name" : "public static int getIntAtIndex(android.content.ContentResolver cr, String name, int index) throws android.provider.Settings.SettingNotFoundException",
    "returnType" : "int",
    "comment" : "\n     * Convenience function for retrieving a value from the secure settings\n     * value list as an integer.  Note that internally setting values are\n     * always stored as strings; this function converts the string to an\n     * integer for you.\n     * <p>\n     * This version does not take a default value.  If the setting has not\n     * been set, or the string value is not a number,\n     * it throws {@link SettingNotFoundException}.\n     *\n     * @param cr The ContentResolver to access.\n     * @param name The name of the setting to retrieve.\n     * @param index The index of the list\n     *\n     * @throws SettingNotFoundException Thrown if a setting by the given\n     * name can't be found or the setting value is not an integer.\n     *\n     * @return The value at the given index of settings.\n     * @hide\n     ",
    "links" : [ "android.provider.Settings.SettingNotFoundException" ]
  }, {
    "name" : "public static boolean putIntAtIndex(android.content.ContentResolver cr, String name, int index, int value)",
    "returnType" : "boolean",
    "comment" : "\n     * Convenience function for updating settings value as coma separated\n     * integer values. This will either create a new entry in the table if the\n     * given name does not exist, or modify the value of the existing row\n     * with that name.  Note that internally setting values are always\n     * stored as strings, so this function converts the given value to a\n     * string before storing it.\n     *\n     * @param cr The ContentResolver to access.\n     * @param name The name of the setting to modify.\n     * @param index The index of the list\n     * @param value The new value for the setting to be added to the list.\n     * @return true if the value was set, false on database errors\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public static String getTelephonyProperty(int phoneId, String property, String defaultVal)",
    "returnType" : "String",
    "comment" : "\n     * Gets a per-phone telephony property from a property name.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "private static T getTelephonyProperty(int phoneId, List<T> prop, T defaultValue)",
    "returnType" : "T",
    "comment" : "\n     * Gets a typed per-phone telephony property from a schematized list property.\n     ",
    "links" : [ ]
  }, {
    "name" : "public static String getTelephonyProperty(String property, String defaultVal)",
    "returnType" : "String",
    "comment" : "\n     * Gets a global telephony property.\n     *\n     * See also getTelephonyProperty(phoneId, property, defaultVal). Most telephony properties are\n     * per-phone.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public int getSimCount()",
    "returnType" : "int",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "public String getIsimIst()",
    "returnType" : "String",
    "comment" : "\n     * Returns the IMS Service Table (IST) that was loaded from the ISIM.\n     *\n     * See 3GPP TS 31.103 (Section 4.2.7) for the definition and more information on this table.\n     *\n     * @return IMS Service Table or null if not present or not loaded\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public String[] getIsimPcscf()",
    "returnType" : "String[]",
    "comment" : "\n     * Returns the IMS Proxy Call Session Control Function(PCSCF) that were loaded from the ISIM.\n     * @return an array of PCSCF strings with one PCSCF per string, or null if\n     *         not present or not loaded\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public String getIccAuthentication(int appType, int authType, String data)",
    "returnType" : "String",
    "comment" : " it's not public API.",
    "links" : [ ]
  }, {
    "name" : "public String getIccAuthentication(int subId, int appType, int authType, String data)",
    "returnType" : "String",
    "comment" : "\n     * Returns the response of USIM Authentication for specified subId.\n     * Returns null if the authentication hasn't been successful\n     *\n     * <p>Requires that the calling app has carrier privileges (see {@link #hasCarrierPrivileges}).\n     *\n     * @param subId subscription ID used for authentication\n     * @param appType the icc application type, like {@link #APPTYPE_USIM}\n     * @param authType the authentication type, {@link #AUTHTYPE_EAP_AKA} or\n     * {@link #AUTHTYPE_EAP_SIM}\n     * @param data authentication challenge data, base64 encoded.\n     * See 3GPP TS 31.102 7.1.2 for more details.\n     * @return the response of authentication. This value will be null in the following cases only\n     * (see 3GPP TS 31.102 7.3.1):\n     *   Authentication error, incorrect MAC\n     *   Authentication error, security context not supported\n     *   Key freshness failure\n     *   Authentication error, no memory space available\n     *   Authentication error, no memory space available in EFMUK\n     * @hide\n     ",
    "links" : [ "#hasCarrierPrivileges", "#AUTHTYPE_EAP_AKA", "#APPTYPE_USIM", "#AUTHTYPE_EAP_SIM" ]
  }, {
    "name" : "public String[] getForbiddenPlmns()",
    "returnType" : "String[]",
    "comment" : "\n     * Returns an array of Forbidden PLMNs from the USIM App\n     * Returns null if the query fails.\n     *\n     * <p>Requires Permission: {@link android.Manifest.permission#READ_PHONE_STATE READ_PHONE_STATE}\n     * or that the calling app has carrier privileges (see {@link #hasCarrierPrivileges}).\n     *\n     * @return an array of forbidden PLMNs or null if not available\n     ",
    "links" : [ "#hasCarrierPrivileges", "android.Manifest.permission#READ_PHONE_STATE" ]
  }, {
    "name" : "public String[] getForbiddenPlmns(int subId, int appType)",
    "returnType" : "String[]",
    "comment" : "\n     * Returns an array of Forbidden PLMNs from the specified SIM App\n     * Returns null if the query fails.\n     *\n     * @param subId subscription ID used for authentication\n     * @param appType the icc application type, like {@link #APPTYPE_USIM}\n     * @return fplmns an array of forbidden PLMNs\n     * @hide\n     ",
    "links" : [ "#APPTYPE_USIM" ]
  }, {
    "name" : "public int setForbiddenPlmns(@NonNull List<String> fplmns)",
    "returnType" : "int",
    "comment" : "\n     * Replace the contents of the forbidden PLMN SIM file with the provided values.\n     * Passing an empty list will clear the contents of the EFfplmn file.\n     * If the provided list is shorter than the size of EFfplmn, then the list will be padded\n     * up to the file size with 'FFFFFF'. (required by 3GPP TS 31.102 spec 4.2.16)\n     * If the list is longer than the size of EFfplmn, then the file will be written from the\n     * beginning of the list up to the file size.\n     *\n     * <p>Requires Permission: {@link android.Manifest.permission#MODIFY_PHONE_STATE\n     * MODIFY_PHONE_STATE}\n     * or that the calling app has carrier privileges (see {@link #hasCarrierPrivileges}).\n     *\n     * @param fplmns a list of PLMNs to be forbidden.\n     *\n     * @return number of PLMNs that were successfully written to the SIM FPLMN list.\n     * This may be less than the number of PLMNs passed in where the SIM file does not have enough\n     * room for all of the values passed in. Return -1 in the event of an unexpected failure\n     ",
    "links" : [ "#hasCarrierPrivileges", "android.Manifest.permission#MODIFY_PHONE_STATEMODIFY_PHONE_STATE" ]
  }, {
    "name" : "public String[] getPcscfAddress(String apnType)",
    "returnType" : "String[]",
    "comment" : "\n     * Get P-CSCF address from PCO after data connection is established or modified.\n     * @param apnType the apnType, \"ims\" for IMS APN, \"emergency\" for EMERGENCY APN\n     * @return array of P-CSCF address\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public void resetIms(int slotIndex)",
    "returnType" : "void",
    "comment" : "\n     * Resets the {@link android.telephony.ims.ImsService} associated with the specified sim slot.\n     * Used by diagnostic apps to force the IMS stack to be disabled and re-enabled in an effort to\n     * recover from scenarios where the {@link android.telephony.ims.ImsService} gets in to a bad\n     * state.\n     *\n     * @param slotIndex the sim slot to reset the IMS stack on.\n     * @hide ",
    "links" : [ "android.telephony.ims.ImsService" ]
  }, {
    "name" : "public void enableIms(int slotId)",
    "returnType" : "void",
    "comment" : "\n     * Enables IMS for the framework. This will trigger IMS registration and ImsFeature capability\n     * status updates, if not already enabled.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public void disableIms(int slotId)",
    "returnType" : "void",
    "comment" : "\n     * Disables IMS for the framework. This will trigger IMS de-registration and trigger ImsFeature\n     * status updates to disabled.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public IImsMmTelFeature getImsMmTelFeatureAndListen(int slotIndex, IImsServiceFeatureCallback callback)",
    "returnType" : "IImsMmTelFeature",
    "comment" : "\n     * Returns the {@link IImsMmTelFeature} that corresponds to the given slot Id and MMTel\n     * feature or {@link null} if the service is not available. If an MMTelFeature is available, the\n     * {@link IImsServiceFeatureCallback} callback is registered as a listener for feature updates.\n     * @param slotIndex The SIM slot that we are requesting the {@link IImsMmTelFeature} for.\n     * @param callback Listener that will send updates to ImsManager when there are updates to\n     * ImsServiceController.\n     * @return {@link IImsMmTelFeature} interface for the feature specified or {@code null} if\n     * it is unavailable.\n     * @hide\n     ",
    "links" : [ "null", "com.android.ims.internal.IImsServiceFeatureCallback", "android.telephony.ims.aidl.IImsMmTelFeature" ]
  }, {
    "name" : "public IImsRcsFeature getImsRcsFeatureAndListen(int slotIndex, IImsServiceFeatureCallback callback)",
    "returnType" : "IImsRcsFeature",
    "comment" : "\n     * Returns the {@link IImsRcsFeature} that corresponds to the given slot Id and RCS\n     * feature for emergency calling or {@link null} if the service is not available. If an\n     * RcsFeature is available, the {@link IImsServiceFeatureCallback} callback is registered as a\n     * listener for feature updates.\n     * @param slotIndex The SIM slot that we are requesting the {@link IImsRcsFeature} for.\n     * @param callback Listener that will send updates to ImsManager when there are updates to\n     * ImsServiceController.\n     * @return {@link IImsRcsFeature} interface for the feature specified or {@code null} if\n     * it is unavailable.\n     * @hide\n     ",
    "links" : [ "android.telephony.ims.aidl.IImsRcsFeature", "null", "com.android.ims.internal.IImsServiceFeatureCallback" ]
  }, {
    "name" : "public void unregisterImsFeatureCallback(int slotIndex, int featureType, IImsServiceFeatureCallback callback)",
    "returnType" : "void",
    "comment" : "\n     * Unregister a IImsServiceFeatureCallback previously associated with an ImsFeature through\n     * {@link #getImsMmTelFeatureAndListen(int, IImsServiceFeatureCallback)} or\n     * {@link #getImsRcsFeatureAndListen(int, IImsServiceFeatureCallback)}.\n     * @param slotIndex The SIM slot associated with the callback.\n     * @param featureType The {@link android.telephony.ims.feature.ImsFeature.FeatureType}\n     *                    associated with the callback.\n     * @param callback The callback to be unregistered.\n     * @hide\n     ",
    "links" : [ "android.telephony.ims.feature.ImsFeature.FeatureType", "#getImsRcsFeatureAndListen(int", "#getImsMmTelFeatureAndListen(int" ]
  }, {
    "name" : "public IImsRegistration getImsRegistration(int slotIndex, int feature)",
    "returnType" : "IImsRegistration",
    "comment" : "\n     * @return the {@IImsRegistration} interface that corresponds with the slot index and feature.\n     * @param slotIndex The SIM slot corresponding to the ImsService ImsRegistration is active for.\n     * @param feature An integer indicating the feature that we wish to get the ImsRegistration for.\n     * Corresponds to features defined in ImsFeature.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public IImsConfig getImsConfig(int slotIndex, int feature)",
    "returnType" : "IImsConfig",
    "comment" : "\n     * @return the {@IImsConfig} interface that corresponds with the slot index and feature.\n     * @param slotIndex The SIM slot corresponding to the ImsService ImsConfig is active for.\n     * @param feature An integer indicating the feature that we wish to get the ImsConfig for.\n     * Corresponds to features defined in ImsFeature.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public void setImsRegistrationState(boolean registered)",
    "returnType" : "void",
    "comment" : "\n     * Set IMS registration state\n     *\n     * @param Registration state\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public int getPreferredNetworkType(int subId)",
    "returnType" : "int",
    "comment" : "\n     * Get the preferred network type.\n     * Used for device configuration by some CDMA operators.\n     *\n     * <p>Requires Permission:\n     * {@link android.Manifest.permission#READ_PRIVILEGED_PHONE_STATE READ_PRIVILEGED_PHONE_STATE}\n     * app has carrier privileges (see {@link #hasCarrierPrivileges}).\n     *\n     * @return the preferred network type.\n     * @hide\n     * @deprecated Use {@link #getPreferredNetworkTypeBitmask} instead.\n     ",
    "links" : [ "#getPreferredNetworkTypeBitmask", "#hasCarrierPrivileges", "android.Manifest.permission#READ_PRIVILEGED_PHONE_STATE" ]
  }, {
    "name" : "public long getPreferredNetworkTypeBitmask()",
    "returnType" : "long",
    "comment" : "\n     * Get the preferred network type bitmask.\n     *\n     * <p>If this object has been created with {@link #createForSubscriptionId}, applies to the\n     * given subId. Otherwise, applies to {@link SubscriptionManager#getDefaultSubscriptionId()}\n     *\n     * <p>Requires Permission:\n     * {@link android.Manifest.permission#READ_PRIVILEGED_PHONE_STATE READ_PRIVILEGED_PHONE_STATE}\n     * or that the calling app has carrier privileges (see {@link #hasCarrierPrivileges}).\n     *\n     * @return The bitmask of preferred network types.\n     *\n     * @hide\n     ",
    "links" : [ "#createForSubscriptionId", "android.telephony.SubscriptionManager#getDefaultSubscriptionId()", "#hasCarrierPrivileges", "android.Manifest.permission#READ_PRIVILEGED_PHONE_STATE" ]
  }, {
    "name" : "public long getAllowedNetworkTypes()",
    "returnType" : "long",
    "comment" : "\n     * Get the allowed network types.\n     *\n     * <p>Requires Permission:\n     * {@link android.Manifest.permission#READ_PRIVILEGED_PHONE_STATE READ_PRIVILEGED_PHONE_STATE}\n     * or that the calling app has carrier privileges (see {@link #hasCarrierPrivileges}).\n     *\n     * @return the allowed network type bitmask\n     * @hide\n     ",
    "links" : [ "#hasCarrierPrivileges", "android.Manifest.permission#READ_PRIVILEGED_PHONE_STATE" ]
  }, {
    "name" : "public void setNetworkSelectionModeAutomatic()",
    "returnType" : "void",
    "comment" : "\n     * Sets the network selection mode to automatic.\n     *\n     * <p>If this object has been created with {@link #createForSubscriptionId}, applies to the\n     * given subId. Otherwise, applies to {@link SubscriptionManager#getDefaultSubscriptionId()}\n     *\n     * <p>Requires Permission:\n     * {@link android.Manifest.permission#MODIFY_PHONE_STATE MODIFY_PHONE_STATE} or that the calling\n     * app has carrier privileges (see {@link #hasCarrierPrivileges}).\n     ",
    "links" : [ "#createForSubscriptionId", "android.telephony.SubscriptionManager#getDefaultSubscriptionId()", "#hasCarrierPrivileges", "android.Manifest.permission#MODIFY_PHONE_STATE" ]
  }, {
    "name" : "public CellNetworkScanResult getAvailableNetworks()",
    "returnType" : "CellNetworkScanResult",
    "comment" : "\n     * Perform a radio scan and return the list of available networks.\n     *\n     * <p>If this object has been created with {@link #createForSubscriptionId}, applies to the\n     * given subId. Otherwise, applies to {@link SubscriptionManager#getDefaultSubscriptionId()}\n     *\n     * <p> Note that this scan can take a long time (sometimes minutes) to happen.\n     *\n     * <p>Requires Permissions:\n     * {@link android.Manifest.permission#MODIFY_PHONE_STATE} or that the calling app has carrier\n     * privileges (see {@link #hasCarrierPrivileges})\n     * and {@link android.Manifest.permission#ACCESS_COARSE_LOCATION}.\n     *\n     * @return {@link CellNetworkScanResult} with the status\n     * {@link CellNetworkScanResult#STATUS_SUCCESS} and a list of\n     * {@link com.android.internal.telephony.OperatorInfo} if it's available. Otherwise, the failure\n     * caused will be included in the result.\n     *\n     * @hide\n     ",
    "links" : [ "#createForSubscriptionId", "android.Manifest.permission#ACCESS_COARSE_LOCATION", "android.telephony.SubscriptionManager#getDefaultSubscriptionId()", "#hasCarrierPrivileges", "com.android.internal.telephony.CellNetworkScanResult#STATUS_SUCCESS", "android.Manifest.permission#MODIFY_PHONE_STATE", "com.android.internal.telephony.CellNetworkScanResult", "com.android.internal.telephony.OperatorInfo" ]
  }, {
    "name" : "public NetworkScan requestNetworkScan(NetworkScanRequest request, Executor executor, TelephonyScanManager.NetworkScanCallback callback)",
    "returnType" : "NetworkScan",
    "comment" : "\n     * Request a network scan.\n     *\n     * This method is asynchronous, so the network scan results will be returned by callback.\n     * The returned NetworkScan will contain a callback method which can be used to stop the scan.\n     *\n     * <p>Requires Permission:\n     * {@link android.Manifest.permission#MODIFY_PHONE_STATE MODIFY_PHONE_STATE} or that the calling\n     * app has carrier privileges (see {@link #hasCarrierPrivileges})\n     * and {@link android.Manifest.permission#ACCESS_FINE_LOCATION}.\n     *\n     * If the system-wide location switch is off, apps may still call this API, with the\n     * following constraints:\n     * <ol>\n     *     <li>The app must hold the {@code android.permission.NETWORK_SCAN} permission.</li>\n     *     <li>The app must not supply any specific bands or channels to scan.</li>\n     *     <li>The app must only specify MCC/MNC pairs that are\n     *     associated to a SIM in the device.</li>\n     *     <li>Returned results will have no meaningful info other than signal strength\n     *     and MCC/MNC info.</li>\n     * </ol>\n     *\n     * @param request Contains all the RAT with bands/channels that need to be scanned.\n     * @param executor The executor through which the callback should be invoked. Since the scan\n     *        request may trigger multiple callbacks and they must be invoked in the same order as\n     *        they are received by the platform, the user should provide an executor which executes\n     *        tasks one at a time in serial order. For example AsyncTask.SERIAL_EXECUTOR.\n     * @param callback Returns network scan results or errors.\n     * @return A NetworkScan obj which contains a callback which can be used to stop the scan.\n     ",
    "links" : [ "android.Manifest.permission#ACCESS_FINE_LOCATION", "#hasCarrierPrivileges", "android.Manifest.permission#MODIFY_PHONE_STATE" ]
  }, {
    "name" : "public NetworkScan requestNetworkScan(NetworkScanRequest request, TelephonyScanManager.NetworkScanCallback callback)",
    "returnType" : "NetworkScan",
    "comment" : "\n     * @deprecated\n     * Use {@link\n     * #requestNetworkScan(NetworkScanRequest, Executor, TelephonyScanManager.NetworkScanCallback)}\n     * @removed\n     ",
    "links" : [ "#requestNetworkScan(NetworkScanRequest" ]
  }, {
    "name" : "public boolean setNetworkSelectionModeManual(String operatorNumeric, boolean persistSelection)",
    "returnType" : "boolean",
    "comment" : "\n     * Ask the radio to connect to the input network and change selection mode to manual.\n     *\n     * <p>If this object has been created with {@link #createForSubscriptionId}, applies to the\n     * given subId. Otherwise, applies to {@link SubscriptionManager#getDefaultSubscriptionId()}\n     *\n     * <p>Requires Permission:\n     * {@link android.Manifest.permission#MODIFY_PHONE_STATE MODIFY_PHONE_STATE} or that the calling\n     * app has carrier privileges (see {@link #hasCarrierPrivileges}).\n     *\n     * @param operatorNumeric the PLMN ID of the network to select.\n     * @param persistSelection whether the selection will persist until reboot. If true, only allows\n     * attaching to the selected PLMN until reboot; otherwise, attach to the chosen PLMN and resume\n     * normal network selection next time.\n     * @return {@code true} on success; {@code false} on any failure.\n     ",
    "links" : [ "#createForSubscriptionId", "android.telephony.SubscriptionManager#getDefaultSubscriptionId()", "#hasCarrierPrivileges", "android.Manifest.permission#MODIFY_PHONE_STATE" ]
  }, {
    "name" : "public boolean setNetworkSelectionModeManual(@NonNull String operatorNumeric, boolean persistSelection, @AccessNetworkConstants.RadioAccessNetworkType int ran)",
    "returnType" : "boolean",
    "comment" : "\n     * Ask the radio to connect to the input network and change selection mode to manual.\n     *\n     * <p>If this object has been created with {@link #createForSubscriptionId}, applies to the\n     * given subId. Otherwise, applies to {@link SubscriptionManager#getDefaultSubscriptionId()}\n     *\n     * <p>Requires Permission:\n     * {@link android.Manifest.permission#MODIFY_PHONE_STATE MODIFY_PHONE_STATE} or that the calling\n     * app has carrier privileges (see {@link #hasCarrierPrivileges}).\n     *\n     * @param operatorNumeric the PLMN ID of the network to select.\n     * @param persistSelection whether the selection will persist until reboot.\n     *         If true, only allows attaching to the selected PLMN until reboot; otherwise,\n     *         attach to the chosen PLMN and resume normal network selection next time.\n     * @param ran the initial suggested radio access network type.\n     *         If registration fails, the RAN is not available after, the RAN is not within the\n     *         network types specified by the preferred network types, or the value is\n     *         {@link AccessNetworkConstants.AccessNetworkType#UNKNOWN}, modem will select\n     *         the next best RAN for network registration.\n     * @return {@code true} on success; {@code false} on any failure.\n     ",
    "links" : [ "#createForSubscriptionId", "AccessNetworkConstants.AccessNetworkType#UNKNOWN", "android.telephony.SubscriptionManager#getDefaultSubscriptionId()", "#hasCarrierPrivileges", "android.Manifest.permission#MODIFY_PHONE_STATE" ]
  }, {
    "name" : "public boolean setNetworkSelectionModeManual(OperatorInfo operatorInfo, boolean persistSelection)",
    "returnType" : "boolean",
    "comment" : "\n     * Ask the radio to connect to the input network and change selection mode to manual.\n     *\n     * <p>If this object has been created with {@link #createForSubscriptionId}, applies to the\n     * given subId. Otherwise, applies to {@link SubscriptionManager#getDefaultSubscriptionId()}\n     *\n     * <p>Requires Permission:\n     * {@link android.Manifest.permission#MODIFY_PHONE_STATE MODIFY_PHONE_STATE} or that the calling\n     * app has carrier privileges (see {@link #hasCarrierPrivileges}).\n     *\n     * @param operatorInfo included the PLMN id, long name, short name of the operator to attach to.\n     * @param persistSelection whether the selection will persist until reboot. If true, only allows\n     * attaching to the selected PLMN until reboot; otherwise, attach to the chosen PLMN and resume\n     * normal network selection next time.\n     * @return {@code true} on success; {@code true} on any failure.\n     *\n     * @hide\n     ",
    "links" : [ "#createForSubscriptionId", "android.telephony.SubscriptionManager#getDefaultSubscriptionId()", "#hasCarrierPrivileges", "android.Manifest.permission#MODIFY_PHONE_STATE" ]
  }, {
    "name" : "public int getNetworkSelectionMode()",
    "returnType" : "int",
    "comment" : "\n     * Get the network selection mode.\n     *\n     * <p>If this object has been created with {@link #createForSubscriptionId}, applies to the\n     * given subId. Otherwise, applies to {@link SubscriptionManager#getDefaultSubscriptionId()}\n     *  <p>Requires Permission: {@link android.Manifest.permission#READ_PRECISE_PHONE_STATE\n     * READ_PRECISE_PHONE_STATE}\n     * or that the calling app has carrier privileges (see {@link #hasCarrierPrivileges}).\n     *\n     * @return the network selection mode.\n     ",
    "links" : [ "#createForSubscriptionId", "android.telephony.SubscriptionManager#getDefaultSubscriptionId()", "android.Manifest.permission#READ_PRECISE_PHONE_STATEREAD_PRECISE_PHONE_STATE", "#hasCarrierPrivileges" ]
  }, {
    "name" : "public String getManualNetworkSelectionPlmn()",
    "returnType" : "String",
    "comment" : "\n     * Get the PLMN chosen for Manual Network Selection if active.\n     * Return empty string if in automatic selection.\n     *\n     * <p>Requires Permission: {@link android.Manifest.permission#READ_PRECISE_PHONE_STATE\n     * READ_PRECISE_PHONE_STATE} or that the calling app has carrier privileges\n     * (see {@link #hasCarrierPrivileges})\n     *\n     * @return manually selected network info on success or empty string on failure\n     ",
    "links" : [ "android.Manifest.permission#READ_PRECISE_PHONE_STATEREAD_PRECISE_PHONE_STATE", "#hasCarrierPrivileges" ]
  }, {
    "name" : "public boolean isInEmergencySmsMode()",
    "returnType" : "boolean",
    "comment" : "\n     * Query Telephony to see if there has recently been an emergency SMS sent to the network by the\n     * user and we are still within the time interval after the emergency SMS was sent that we are\n     * considered in Emergency SMS mode.\n     *\n     * <p>This mode is used by other applications to allow them to perform special functionality,\n     * such as allow the GNSS service to provide user location to the carrier network for emergency\n     * when an emergency SMS is sent. This interval is set by\n     * {@link CarrierConfigManager#KEY_EMERGENCY_SMS_MODE_TIMER_MS_INT}. If\n     * the carrier does not support this mode, this function will always return false.\n     *\n     * @return {@code true} if this device is in emergency SMS mode, {@code false} otherwise.\n     *\n     * @hide\n     ",
    "links" : [ "android.telephony.CarrierConfigManager#KEY_EMERGENCY_SMS_MODE_TIMER_MS_INT" ]
  }, {
    "name" : "public boolean setPreferredNetworkType(int subId, @PrefNetworkMode int networkType)",
    "returnType" : "boolean",
    "comment" : "\n     * Set the preferred network type.\n     *\n     * <p>Requires Permission:\n     * {@link android.Manifest.permission#MODIFY_PHONE_STATE MODIFY_PHONE_STATE} or that the calling\n     * app has carrier privileges (see {@link #hasCarrierPrivileges}).\n     *\n     * @param subId the id of the subscription to set the preferred network type for.\n     * @param networkType the preferred network type\n     * @return true on success; false on any failure.\n     * @hide\n     * @deprecated Use {@link #setPreferredNetworkTypeBitmask} instead.\n     ",
    "links" : [ "#setPreferredNetworkTypeBitmask", "#hasCarrierPrivileges", "android.Manifest.permission#MODIFY_PHONE_STATE" ]
  }, {
    "name" : "public boolean setPreferredNetworkTypeBitmask(@NetworkTypeBitMask long networkTypeBitmask)",
    "returnType" : "boolean",
    "comment" : "\n     * Set the preferred network type bitmask but if {@link #setAllowedNetworkTypes} has been set,\n     * only the allowed network type will set to the modem.\n     *\n     * <p>If this object has been created with {@link #createForSubscriptionId}, applies to the\n     * given subId. Otherwise, applies to {@link SubscriptionManager#getDefaultSubscriptionId()}\n     *\n     * <p>Requires Permission:\n     * {@link android.Manifest.permission#MODIFY_PHONE_STATE MODIFY_PHONE_STATE} or that the calling\n     * app has carrier privileges (see {@link #hasCarrierPrivileges}).\n     *\n     * @param networkTypeBitmask The bitmask of preferred network types.\n     * @return true on success; false on any failure.\n     * @hide\n     ",
    "links" : [ "#createForSubscriptionId", "#setAllowedNetworkTypes", "android.telephony.SubscriptionManager#getDefaultSubscriptionId()", "#hasCarrierPrivileges", "android.Manifest.permission#MODIFY_PHONE_STATE" ]
  }, {
    "name" : "public boolean setAllowedNetworkTypes(@NetworkTypeBitMask long allowedNetworkTypes)",
    "returnType" : "boolean",
    "comment" : "\n     * Set the allowed network types of the device. This is for carrier or privileged apps to\n     * enable/disable certain network types on the device. The user preferred network types should\n     * be set through {@link #setPreferredNetworkTypeBitmask}.\n     *\n     * @param allowedNetworkTypes The bitmask of allowed network types.\n     * @return true on success; false on any failure.\n     * @hide\n     ",
    "links" : [ "#setPreferredNetworkTypeBitmask" ]
  }, {
    "name" : "public void setAllowedNetworkTypesForReason(@AllowedNetworkTypesReason int reason, @NetworkTypeBitMask long allowedNetworkTypes)",
    "returnType" : "void",
    "comment" : "\n     * Set the allowed network types of the device and\n     * provide the reason triggering the allowed network change.\n     * This can be called for following reasons\n     * <ol>\n     * <li>Allowed network types control by power manager\n     * {@link #ALLOWED_NETWORK_TYPES_REASON_POWER}\n     * </ol>\n     * This API will result in allowing an intersection of allowed network types for all reasons,\n     * including the configuration done through {@link setAllowedNetworkTypes}.\n     * While this API and {@link setAllowedNetworkTypes} is controlling allowed network types\n     * on device, user preference will still be set through {@link #setPreferredNetworkTypeBitmask}.\n     * Thus resultant network type configured on modem will be an intersection of the network types\n     * from setAllowedNetworkTypesForReason, {@link setAllowedNetworkTypes}\n     * and {@link #setPreferredNetworkTypeBitmask}.\n     *\n     * @param reason the reason the allowed network type change is taking place\n     * @param allowedNetworkTypes The bitmask of allowed network types.\n     * @throws IllegalStateException if the Telephony process is not currently available.\n     * @throws IllegalArgumentException if invalid AllowedNetworkTypesReason is passed.\n     * @hide\n     ",
    "links" : [ "#setPreferredNetworkTypeBitmask", "#ALLOWED_NETWORK_TYPES_REASON_POWER", "setAllowedNetworkTypes" ]
  }, {
    "name" : "public long getAllowedNetworkTypesForReason(@AllowedNetworkTypesReason int reason)",
    "returnType" : "long",
    "comment" : "\n     * Get the allowed network types for certain reason.\n     *\n     * {@link #getAllowedNetworkTypesForReason} returns allowed network type for a\n     * specific reason. For effective allowed network types configured on device,\n     * query {@link getEffectiveAllowedNetworkTypes}\n     *\n     * <p>Requires Permission:\n     * {@link android.Manifest.permission#READ_PRIVILEGED_PHONE_STATE READ_PRIVILEGED_PHONE_STATE}\n     * or that the calling app has carrier privileges (see {@link #hasCarrierPrivileges}).\n     *s\n     * @param reason the reason the allowed network type change is taking place\n     * @return the allowed network type bitmask\n     * @throws IllegalStateException if the Telephony process is not currently available.\n     * @throws IllegalArgumentException if invalid AllowedNetworkTypesReason is passed.\n     * @hide\n     ",
    "links" : [ "#getAllowedNetworkTypesForReason", "#hasCarrierPrivileges", "getEffectiveAllowedNetworkTypes", "android.Manifest.permission#READ_PRIVILEGED_PHONE_STATE" ]
  }, {
    "name" : "public static long getAllNetworkTypesBitmask()",
    "returnType" : "long",
    "comment" : "\n     * Get bit mask of all network types.\n     *\n     * @return bit mask of all network types\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public long getEffectiveAllowedNetworkTypes()",
    "returnType" : "long",
    "comment" : "\n     * Get the allowed network types configured on the device.\n     * This API will return an intersection of allowed network types for all reasons,\n     * including the configuration done through setAllowedNetworkTypes\n     *\n     * <p>Requires Permission:\n     * {@link android.Manifest.permission#READ_PRIVILEGED_PHONE_STATE READ_PRIVILEGED_PHONE_STATE}\n     * or that the calling app has carrier privileges (see {@link #hasCarrierPrivileges}).\n     *\n     * @return the allowed network type bitmask\n     * @throws IllegalStateException if the Telephony process is not currently available.\n     * @hide\n     ",
    "links" : [ "#hasCarrierPrivileges", "android.Manifest.permission#READ_PRIVILEGED_PHONE_STATE" ]
  }, {
    "name" : "public boolean setPreferredNetworkTypeToGlobal()",
    "returnType" : "boolean",
    "comment" : "\n     * Set the preferred network type to global mode which includes LTE, CDMA, EvDo and GSM/WCDMA.\n     *\n     * <p>Requires that the calling app has carrier privileges (see {@link #hasCarrierPrivileges}).\n     *\n     * @return true on success; false on any failure.\n     ",
    "links" : [ "#hasCarrierPrivileges" ]
  }, {
    "name" : "public boolean setPreferredNetworkTypeToGlobal(int subId)",
    "returnType" : "boolean",
    "comment" : "\n     * Set the preferred network type to global mode which includes LTE, CDMA, EvDo and GSM/WCDMA.\n     *\n     * <p>Requires that the calling app has carrier privileges (see {@link #hasCarrierPrivileges}).\n     *\n     * @return true on success; false on any failure.\n     * @hide\n     ",
    "links" : [ "#hasCarrierPrivileges" ]
  }, {
    "name" : "public boolean isTetheringApnRequired()",
    "returnType" : "boolean",
    "comment" : "\n     * Check whether DUN APN is required for tethering.\n     * <p>\n     * Requires Permission: MODIFY_PHONE_STATE.\n     *\n     * @return {@code true} if DUN APN is required for tethering.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean isTetheringApnRequired(int subId)",
    "returnType" : "boolean",
    "comment" : "\n     * Check whether DUN APN is required for tethering with subId.\n     *\n     * @param subId the id of the subscription to require tethering.\n     * @return {@code true} if DUN APN is required for tethering.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean hasCarrierPrivileges()",
    "returnType" : "boolean",
    "comment" : "\n     * Has the calling application been granted carrier privileges by the carrier.\n     *\n     * If any of the packages in the calling UID has carrier privileges, the\n     * call will return true. This access is granted by the owner of the UICC\n     * card and does not depend on the registered carrier.\n     *\n     * @return true if the app has carrier privileges.\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean hasCarrierPrivileges(int subId)",
    "returnType" : "boolean",
    "comment" : "\n     * Has the calling application been granted carrier privileges by the carrier.\n     *\n     * If any of the packages in the calling UID has carrier privileges, the\n     * call will return true. This access is granted by the owner of the UICC\n     * card and does not depend on the registered carrier.\n     *\n     * @param subId The subscription to use.\n     * @return true if the app has carrier privileges.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean setOperatorBrandOverride(String brand)",
    "returnType" : "boolean",
    "comment" : "\n     * Override the branding for the current ICCID.\n     *\n     * Once set, whenever the SIM is present in the device, the service\n     * provider name (SPN) and the operator name will both be replaced by the\n     * brand value input. To unset the value, the same function should be\n     * called with a null brand value.\n     *\n     * <p>Requires that the calling app has carrier privileges (see {@link #hasCarrierPrivileges}).\n     *\n     * @param brand The brand name to display/set.\n     * @return true if the operation was executed correctly.\n     ",
    "links" : [ "#hasCarrierPrivileges" ]
  }, {
    "name" : "public boolean setOperatorBrandOverride(int subId, String brand)",
    "returnType" : "boolean",
    "comment" : "\n     * Override the branding for the current ICCID.\n     *\n     * Once set, whenever the SIM is present in the device, the service\n     * provider name (SPN) and the operator name will both be replaced by the\n     * brand value input. To unset the value, the same function should be\n     * called with a null brand value.\n     *\n     * <p>Requires that the calling app has carrier privileges (see {@link #hasCarrierPrivileges}).\n     *\n     * @param subId The subscription to use.\n     * @param brand The brand name to display/set.\n     * @return true if the operation was executed correctly.\n     * @hide\n     ",
    "links" : [ "#hasCarrierPrivileges" ]
  }, {
    "name" : "public boolean setRoamingOverride(List<String> gsmRoamingList, List<String> gsmNonRoamingList, List<String> cdmaRoamingList, List<String> cdmaNonRoamingList)",
    "returnType" : "boolean",
    "comment" : "\n     * Override the roaming preference for the current ICCID.\n     *\n     * Using this call, the carrier app (see #hasCarrierPrivileges) can override\n     * the platform's notion of a network operator being considered roaming or not.\n     * The change only affects the ICCID that was active when this call was made.\n     *\n     * If null is passed as any of the input, the corresponding value is deleted.\n     *\n     * <p>Requires that the caller have carrier privilege. See #hasCarrierPrivileges.\n     *\n     * @param gsmRoamingList - List of MCCMNCs to be considered roaming for 3GPP RATs.\n     * @param gsmNonRoamingList - List of MCCMNCs to be considered not roaming for 3GPP RATs.\n     * @param cdmaRoamingList - List of SIDs to be considered roaming for 3GPP2 RATs.\n     * @param cdmaNonRoamingList - List of SIDs to be considered not roaming for 3GPP2 RATs.\n     * @return true if the operation was executed correctly.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean setRoamingOverride(int subId, List<String> gsmRoamingList, List<String> gsmNonRoamingList, List<String> cdmaRoamingList, List<String> cdmaNonRoamingList)",
    "returnType" : "boolean",
    "comment" : "\n     * Override the roaming preference for the current ICCID.\n     *\n     * Using this call, the carrier app (see #hasCarrierPrivileges) can override\n     * the platform's notion of a network operator being considered roaming or not.\n     * The change only affects the ICCID that was active when this call was made.\n     *\n     * If null is passed as any of the input, the corresponding value is deleted.\n     *\n     * <p>Requires that the caller have carrier privilege. See #hasCarrierPrivileges.\n     *\n     * @param subId for which the roaming overrides apply.\n     * @param gsmRoamingList - List of MCCMNCs to be considered roaming for 3GPP RATs.\n     * @param gsmNonRoamingList - List of MCCMNCs to be considered not roaming for 3GPP RATs.\n     * @param cdmaRoamingList - List of SIDs to be considered roaming for 3GPP2 RATs.\n     * @param cdmaNonRoamingList - List of SIDs to be considered not roaming for 3GPP2 RATs.\n     * @return true if the operation was executed correctly.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public String getCdmaMdn()",
    "returnType" : "String",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "public String getCdmaMdn(int subId)",
    "returnType" : "String",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "public String getCdmaMin()",
    "returnType" : "String",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "public String getCdmaMin(int subId)",
    "returnType" : "String",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "public int checkCarrierPrivilegesForPackage(String pkgName)",
    "returnType" : "int",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "public int checkCarrierPrivilegesForPackageAnyPhone(String pkgName)",
    "returnType" : "int",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "public List<String> getCarrierPackageNamesForIntent(Intent intent)",
    "returnType" : "List<String>",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "public List<String> getCarrierPackageNamesForIntentAndPhone(Intent intent, int phoneId)",
    "returnType" : "List<String>",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "public List<String> getPackagesWithCarrierPrivileges()",
    "returnType" : "List<String>",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "public List<String> getCarrierPrivilegedPackagesForAllActiveSubscriptions()",
    "returnType" : "List<String>",
    "comment" : "\n     * Get the names of packages with carrier privileges for all the active subscriptions.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public void dial(String number)",
    "returnType" : "void",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "public void call(String callingPackage, String number)",
    "returnType" : "void",
    "comment" : "\n     * @deprecated Use  {@link android.telecom.TelecomManager#placeCall(Uri address,\n     * Bundle extras)} instead.\n     * @hide\n     ",
    "links" : [ "android.telecom.TelecomManager#placeCall(Uri" ]
  }, {
    "name" : "public boolean endCall()",
    "returnType" : "boolean",
    "comment" : "\n     * @removed Use {@link android.telecom.TelecomManager#endCall()} instead.\n     * @hide\n     * @removed\n     ",
    "links" : [ "android.telecom.TelecomManager#endCall()" ]
  }, {
    "name" : "public void answerRingingCall()",
    "returnType" : "void",
    "comment" : "\n     * @removed Use {@link android.telecom.TelecomManager#acceptRingingCall} instead\n     * @hide\n     * @removed\n     ",
    "links" : [ "android.telecom.TelecomManager#acceptRingingCall" ]
  }, {
    "name" : "public void silenceRinger()",
    "returnType" : "void",
    "comment" : "\n     * @removed Use {@link android.telecom.TelecomManager#silenceRinger} instead\n     * @hide\n     ",
    "links" : [ "android.telecom.TelecomManager#silenceRinger" ]
  }, {
    "name" : "public boolean isOffhook()",
    "returnType" : "boolean",
    "comment" : "\n     * @deprecated Use {@link android.telecom.TelecomManager#isInCall} instead\n     * @hide\n     ",
    "links" : [ "android.telecom.TelecomManager#isInCall" ]
  }, {
    "name" : "public boolean isRinging()",
    "returnType" : "boolean",
    "comment" : "\n     * @deprecated Use {@link android.telecom.TelecomManager#isRinging} instead\n     * @hide\n     ",
    "links" : [ "android.telecom.TelecomManager#isRinging" ]
  }, {
    "name" : "public boolean isIdle()",
    "returnType" : "boolean",
    "comment" : "\n     * @deprecated Use {@link android.telecom.TelecomManager#isInCall} instead\n     * @hide\n     ",
    "links" : [ "android.telecom.TelecomManager#isInCall" ]
  }, {
    "name" : "public boolean isRadioOn()",
    "returnType" : "boolean",
    "comment" : "\n     * @deprecated Use {@link android.telephony.TelephonyManager#getServiceState} instead\n     * @hide\n     ",
    "links" : [ "android.telephony.TelephonyManager#getServiceState" ]
  }, {
    "name" : "public boolean supplyPin(String pin)",
    "returnType" : "boolean",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "public boolean supplyPuk(String puk, String pin)",
    "returnType" : "boolean",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "public int[] supplyPinReportResult(String pin)",
    "returnType" : "int[]",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "public int[] supplyPukReportResult(String puk, String pin)",
    "returnType" : "int[]",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "public PinResult supplyPinReportPinResult(@NonNull String pin)",
    "returnType" : "PinResult",
    "comment" : "\n     * Used when the user attempts to enter their pin.\n     *\n     * @param pin The user entered pin.\n     * @return The result of the pin.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public PinResult supplyPukReportPinResult(@NonNull String puk, @NonNull String pin)",
    "returnType" : "PinResult",
    "comment" : "\n     * Used when the user attempts to enter the puk or their pin.\n     *\n     * @param puk The product unblocking key.\n     * @param pin The user entered pin.\n     * @return The result of the pin.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public void sendUssdRequest(String ussdRequest, final UssdResponseCallback callback, Handler handler)",
    "returnType" : "void",
    "comment" : "\n     * Sends an Unstructured Supplementary Service Data (USSD) request to the mobile network and\n     * informs the caller of the response via the supplied {@code callback}.\n     * <p>Carriers define USSD codes which can be sent by the user to request information such as\n     * the user's current data balance or minutes balance.\n     * <p>Requires permission:\n     * {@link android.Manifest.permission#CALL_PHONE}\n     * @param ussdRequest the USSD command to be executed.\n     * @param callback called by the framework to inform the caller of the result of executing the\n     *                 USSD request (see {@link UssdResponseCallback}).\n     * @param handler the {@link Handler} to run the request on.\n     ",
    "links" : [ "UssdResponseCallback", "android.os.Handler", "android.Manifest.permission#CALL_PHONE" ]
  }, {
    "name" : "public boolean isConcurrentVoiceAndDataSupported()",
    "returnType" : "boolean",
    "comment" : "\n     * Whether the device is currently on a technology (e.g. UMTS or LTE) which can support\n     * voice and data simultaneously. This can change based on location or network condition.\n     *\n     * @return {@code true} if simultaneous voice and data supported, and {@code false} otherwise.\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean handlePinMmi(String dialString)",
    "returnType" : "boolean",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "public boolean handlePinMmiForSubscriber(int subId, String dialString)",
    "returnType" : "boolean",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "public void toggleRadioOnOff()",
    "returnType" : "void",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "public boolean setRadio(boolean turnOn)",
    "returnType" : "boolean",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "public boolean setRadioPower(boolean turnOn)",
    "returnType" : "boolean",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "public void shutdownAllRadios()",
    "returnType" : "void",
    "comment" : "\n     * Shut down all the live radios over all the slot indexes.\n     *\n     * <p>To know when the radio has completed powering off, use\n     * {@link PhoneStateListener#LISTEN_SERVICE_STATE LISTEN_SERVICE_STATE}.\n     *\n     * @hide\n     ",
    "links" : [ "android.telephony.PhoneStateListener#LISTEN_SERVICE_STATE" ]
  }, {
    "name" : "public boolean isAnyRadioPoweredOn()",
    "returnType" : "boolean",
    "comment" : "\n     * Check if any radio is on over all the slot indexes.\n     *\n     * @return {@code true} if any radio is on over any slot index.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public int getRadioPowerState()",
    "returnType" : "int",
    "comment" : "\n     * @return current modem radio state.\n     *\n     * <p>Requires permission: {@link android.Manifest.permission#READ_PRIVILEGED_PHONE_STATE} or\n     * {@link android.Manifest.permission#READ_PHONE_STATE} or that the calling\n     * app has carrier privileges (see {@link #hasCarrierPrivileges}).\n     *\n     * @hide\n     ",
    "links" : [ "#hasCarrierPrivileges", "android.Manifest.permission#READ_PRIVILEGED_PHONE_STATE", "android.Manifest.permission#READ_PHONE_STATE" ]
  }, {
    "name" : "public void updateServiceLocation()",
    "returnType" : "void",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "public boolean enableDataConnectivity()",
    "returnType" : "boolean",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "public boolean disableDataConnectivity()",
    "returnType" : "boolean",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "public boolean isDataConnectivityPossible()",
    "returnType" : "boolean",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "public boolean needsOtaServiceProvisioning()",
    "returnType" : "boolean",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "public void setDataEnabled(boolean enable)",
    "returnType" : "void",
    "comment" : "\n     * Turns mobile data on or off.\n     * If this object has been created with {@link #createForSubscriptionId}, applies to the given\n     * subId. Otherwise, applies to {@link SubscriptionManager#getDefaultDataSubscriptionId()}\n     *\n     * <p>Requires Permission:\n     * {@link android.Manifest.permission#MODIFY_PHONE_STATE MODIFY_PHONE_STATE} or that the calling\n     * app has carrier privileges (see {@link #hasCarrierPrivileges}).\n     *\n     * @param enable Whether to enable mobile data.\n     *\n     ",
    "links" : [ "#createForSubscriptionId", "android.telephony.SubscriptionManager#getDefaultDataSubscriptionId()", "#hasCarrierPrivileges", "android.Manifest.permission#MODIFY_PHONE_STATE" ]
  }, {
    "name" : "public void setDataEnabled(int subId, boolean enable)",
    "returnType" : "void",
    "comment" : "\n     * @hide\n     * @deprecated use {@link #setDataEnabled(boolean)} instead.\n    ",
    "links" : [ "#setDataEnabled(boolean)" ]
  }, {
    "name" : "public boolean getDataEnabled()",
    "returnType" : "boolean",
    "comment" : "\n     * @deprecated use {@link #isDataEnabled()} instead.\n     * @hide\n     ",
    "links" : [ "#isDataEnabled()" ]
  }, {
    "name" : "public boolean isDataEnabled()",
    "returnType" : "boolean",
    "comment" : "\n     * Returns whether mobile data is enabled or not per user setting. There are other factors\n     * that could disable mobile data, but they are not considered here.\n     *\n     * If this object has been created with {@link #createForSubscriptionId}, applies to the given\n     * subId. Otherwise, applies to {@link SubscriptionManager#getDefaultDataSubscriptionId()}\n     *\n     * <p>Requires one of the following permissions:\n     * {@link android.Manifest.permission#ACCESS_NETWORK_STATE},\n     * {@link android.Manifest.permission#MODIFY_PHONE_STATE}, or that the calling app has carrier\n     * privileges (see {@link #hasCarrierPrivileges}).\n     *\n     * <p>Note that this does not take into account any data restrictions that may be present on the\n     * calling app. Such restrictions may be inspected with\n     * {@link ConnectivityManager#getRestrictBackgroundStatus}.\n     *\n     * @return true if mobile data is enabled.\n     ",
    "links" : [ "#createForSubscriptionId", "android.Manifest.permission#ACCESS_NETWORK_STATE", "android.net.ConnectivityManager#getRestrictBackgroundStatus", "android.telephony.SubscriptionManager#getDefaultDataSubscriptionId()", "#hasCarrierPrivileges", "android.Manifest.permission#MODIFY_PHONE_STATE" ]
  }, {
    "name" : "public boolean isDataRoamingEnabled()",
    "returnType" : "boolean",
    "comment" : "\n     * Returns whether mobile data roaming is enabled on the subscription.\n     *\n     * <p>If this object has been created with {@link #createForSubscriptionId}, applies to the\n     * given subId. Otherwise, applies to {@link SubscriptionManager#getDefaultDataSubscriptionId()}\n     *\n     * <p>Requires one of the following permissions:\n     * {@link android.Manifest.permission#ACCESS_NETWORK_STATE},\n     * {@link android.Manifest.permission#READ_PHONE_STATE} or that the calling app\n     * has carrier privileges (see {@link #hasCarrierPrivileges}).\n     *\n     * @return {@code true} if the data roaming is enabled on the subscription, otherwise return\n     * {@code false}.\n     ",
    "links" : [ "#createForSubscriptionId", "android.Manifest.permission#ACCESS_NETWORK_STATE", "android.telephony.SubscriptionManager#getDefaultDataSubscriptionId()", "#hasCarrierPrivileges", "android.Manifest.permission#READ_PHONE_STATE" ]
  }, {
    "name" : "public int getCdmaRoamingMode()",
    "returnType" : "int",
    "comment" : "\n     * Gets the roaming mode for CDMA phone.\n     *\n     * <p>If this object has been created with {@link #createForSubscriptionId}, applies to the\n     * given subId. Otherwise, applies to {@link SubscriptionManager#getDefaultSubscriptionId()}\n     *\n     * @return one of {@link #CDMA_ROAMING_MODE_RADIO_DEFAULT}, {@link #CDMA_ROAMING_MODE_HOME},\n     * {@link #CDMA_ROAMING_MODE_AFFILIATED}, {@link #CDMA_ROAMING_MODE_ANY}.\n     *\n     * @hide\n     ",
    "links" : [ "#createForSubscriptionId", "#CDMA_ROAMING_MODE_RADIO_DEFAULT", "android.telephony.SubscriptionManager#getDefaultSubscriptionId()", "#CDMA_ROAMING_MODE_ANY", "#CDMA_ROAMING_MODE_HOME", "#CDMA_ROAMING_MODE_AFFILIATED" ]
  }, {
    "name" : "public boolean setCdmaRoamingMode(@CdmaRoamingMode int mode)",
    "returnType" : "boolean",
    "comment" : "\n     * Sets the roaming mode for CDMA phone to the given mode {@code mode}.\n     *\n     * <p>If this object has been created with {@link #createForSubscriptionId}, applies to the\n     * given subId. Otherwise, applies to {@link SubscriptionManager#getDefaultSubscriptionId()}\n     *\n     * @param mode should be one of {@link #CDMA_ROAMING_MODE_RADIO_DEFAULT},\n     * {@link #CDMA_ROAMING_MODE_HOME}, {@link #CDMA_ROAMING_MODE_AFFILIATED},\n     * {@link #CDMA_ROAMING_MODE_ANY}.\n     *\n     * @return {@code true} if successed.\n     *\n     * @hide\n     ",
    "links" : [ "#createForSubscriptionId", "#CDMA_ROAMING_MODE_RADIO_DEFAULT", "android.telephony.SubscriptionManager#getDefaultSubscriptionId()", "#CDMA_ROAMING_MODE_ANY", "#CDMA_ROAMING_MODE_HOME", "#CDMA_ROAMING_MODE_AFFILIATED" ]
  }, {
    "name" : "public boolean setCdmaSubscriptionMode(@CdmaSubscription int mode)",
    "returnType" : "boolean",
    "comment" : "\n     * Sets the subscription mode for CDMA phone to the given mode {@code mode}.\n     *\n     * @param mode CDMA subscription mode\n     *\n     * @return {@code true} if successed.\n     *\n     * @see #CDMA_SUBSCRIPTION_UNKNOWN\n     * @see #CDMA_SUBSCRIPTION_RUIM_SIM\n     * @see #CDMA_SUBSCRIPTION_NV\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public void setDataRoamingEnabled(boolean isEnabled)",
    "returnType" : "void",
    "comment" : "\n     * Enables/Disables the data roaming on the subscription.\n     *\n     * <p>If this object has been created with {@link #createForSubscriptionId}, applies to the\n     * given subId. Otherwise, applies to {@link SubscriptionManager#getDefaultDataSubscriptionId()}\n     *\n     * <p> Requires permission:\n     * {@link android.Manifest.permission#MODIFY_PHONE_STATE} or that the calling app has carrier\n     * privileges (see {@link #hasCarrierPrivileges}).\n     *\n     * @param isEnabled {@code true} to enable mobile data roaming, otherwise disable it.\n     *\n     * @hide\n     ",
    "links" : [ "#createForSubscriptionId", "android.telephony.SubscriptionManager#getDefaultDataSubscriptionId()", "#hasCarrierPrivileges", "android.Manifest.permission#MODIFY_PHONE_STATE" ]
  }, {
    "name" : "public boolean getDataEnabled(int subId)",
    "returnType" : "boolean",
    "comment" : "\n     * @deprecated use {@link #isDataEnabled()} instead.\n     * @hide\n     ",
    "links" : [ "#isDataEnabled()" ]
  }, {
    "name" : "public int invokeOemRilRequestRaw(byte[] oemReq, byte[] oemResp)",
    "returnType" : "int",
    "comment" : "\n     * Returns the result and response from RIL for oem request\n     *\n     * @param oemReq the data is sent to ril.\n     * @param oemResp the respose data from RIL.\n     * @return negative value request was not handled or get error\n     *         0 request was handled succesfully, but no response data\n     *         positive value success, data length of response\n     * @hide\n     * @deprecated OEM needs a vendor-extension hal and their apps should use that instead\n     ",
    "links" : [ ]
  }, {
    "name" : "public void enableVideoCalling(boolean enable)",
    "returnType" : "void",
    "comment" : "\n     * @deprecated Use {@link android.telephony.ims.ImsMmTelManager#setVtSettingEnabled(boolean)}\n     * instead.\n     * @hide\n     ",
    "links" : [ "android.telephony.ims.ImsMmTelManager#setVtSettingEnabled(boolean)" ]
  }, {
    "name" : "public boolean isVideoCallingEnabled()",
    "returnType" : "boolean",
    "comment" : "\n     * @deprecated Use {@link ImsMmTelManager#isVtSettingEnabled()} instead to check if the user\n     * has enabled the Video Calling setting, {@link ImsMmTelManager#isAvailable(int, int)} to\n     * determine if video calling is available, or {@link ImsMmTelManager#isCapable(int, int)} to\n     * determine if video calling is capable.\n     * @hide\n     ",
    "links" : [ "android.telephony.ims.ImsMmTelManager#isAvailable(int", "android.telephony.ims.ImsMmTelManager#isCapable(int", "android.telephony.ims.ImsMmTelManager#isVtSettingEnabled()" ]
  }, {
    "name" : "public boolean canChangeDtmfToneLength()",
    "returnType" : "boolean",
    "comment" : "\n     * Whether the device supports configuring the DTMF tone length.\n     *\n     * @return {@code true} if the DTMF tone length can be changed, and {@code false} otherwise.\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean isWorldPhone()",
    "returnType" : "boolean",
    "comment" : "\n     * Whether the device is a world phone.\n     *\n     * @return {@code true} if the device is a world phone, and {@code false} otherwise.\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean isTtyModeSupported()",
    "returnType" : "boolean",
    "comment" : "\n     * @deprecated Use {@link TelecomManager#isTtySupported()} instead\n     * Whether the phone supports TTY mode.\n     *\n     * @return {@code true} if the device supports TTY mode, and {@code false} otherwise.\n     *\n     ",
    "links" : [ "android.telecom.TelecomManager#isTtySupported()" ]
  }, {
    "name" : "public boolean isRttSupported()",
    "returnType" : "boolean",
    "comment" : "\n     * Determines whether the device currently supports RTT (Real-time text). Based both on carrier\n     * support for the feature and device firmware support.\n     *\n     * @return {@code true} if the device and carrier both support RTT, {@code false} otherwise.\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean isHearingAidCompatibilitySupported()",
    "returnType" : "boolean",
    "comment" : "\n     * Whether the phone supports hearing aid compatibility.\n     *\n     * @return {@code true} if the device supports hearing aid compatibility, and {@code false}\n     * otherwise.\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean isImsRegistered(int subId)",
    "returnType" : "boolean",
    "comment" : "\n     * Returns the IMS Registration Status for a particular Subscription ID.\n     *\n     * @param subId Subscription ID\n     * @return true if IMS status is registered, false if the IMS status is not registered or a\n     * RemoteException occurred.\n     * Use {@link ImsMmTelManager.RegistrationCallback} instead.\n     * @hide\n     ",
    "links" : [ "ImsMmTelManager.RegistrationCallback" ]
  }, {
    "name" : "public boolean isImsRegistered()",
    "returnType" : "boolean",
    "comment" : "\n     * Returns the IMS Registration Status for a particular Subscription ID, which is determined\n     * when the TelephonyManager is created using {@link #createForSubscriptionId(int)}. If an\n     * invalid subscription ID is used during creation, will the default subscription ID will be\n     * used.\n     *\n     * @return true if IMS status is registered, false if the IMS status is not registered or a\n     * RemoteException occurred.\n     * @see SubscriptionManager#getDefaultSubscriptionId()\n     * @hide\n     ",
    "links" : [ "#createForSubscriptionId(int)" ]
  }, {
    "name" : "public boolean isVolteAvailable()",
    "returnType" : "boolean",
    "comment" : "\n     * The current status of Voice over LTE for the subscription associated with this instance when\n     * it was created using {@link #createForSubscriptionId(int)}. If an invalid subscription ID was\n     * used during creation, the default subscription ID will be used.\n     * @return true if Voice over LTE is available or false if it is unavailable or unknown.\n     * @see SubscriptionManager#getDefaultSubscriptionId()\n     * <p>\n     * Use {@link ImsMmTelManager#isAvailable(int, int)} instead.\n     * @hide\n     ",
    "links" : [ "android.telephony.ims.ImsMmTelManager#isAvailable(int", "#createForSubscriptionId(int)" ]
  }, {
    "name" : "public boolean isVideoTelephonyAvailable()",
    "returnType" : "boolean",
    "comment" : "\n     * The availability of Video Telephony (VT) for the subscription ID specified when this instance\n     * was created using {@link #createForSubscriptionId(int)}. If an invalid subscription ID was\n     * used during creation, the default subscription ID will be used. To query the\n     * underlying technology that VT is available on, use {@link #getImsRegTechnologyForMmTel}.\n     * @return true if VT is available, or false if it is unavailable or unknown.\n     * Use {@link ImsMmTelManager#isAvailable(int, int)} instead.\n     * @hide\n     ",
    "links" : [ "android.telephony.ims.ImsMmTelManager#isAvailable(int", "#getImsRegTechnologyForMmTel", "#createForSubscriptionId(int)" ]
  }, {
    "name" : "public boolean isWifiCallingAvailable()",
    "returnType" : "boolean",
    "comment" : "\n     * Returns the Status of Wi-Fi calling (Voice over WiFi) for the subscription ID specified.\n     * @param subId the subscription ID.\n     * @return true if VoWiFi is available, or false if it is unavailable or unknown.\n     * Use {@link ImsMmTelManager#isAvailable(int, int)} instead.\n     * @hide\n     ",
    "links" : [ "android.telephony.ims.ImsMmTelManager#isAvailable(int" ]
  }, {
    "name" : "public int getImsRegTechnologyForMmTel()",
    "returnType" : "int",
    "comment" : "\n     * The technology that IMS is registered for for the MMTEL feature.\n     * @param subId subscription ID to get IMS registration technology for.\n     * @return The IMS registration technology that IMS is registered to for the MMTEL feature.\n     * Valid return results are:\n     *  - {@link ImsRegistrationImplBase#REGISTRATION_TECH_LTE} for LTE registration,\n     *  - {@link ImsRegistrationImplBase#REGISTRATION_TECH_IWLAN} for IWLAN registration, or\n     *  - {@link ImsRegistrationImplBase#REGISTRATION_TECH_NONE} if we are not registered or the\n     *  result is unavailable.\n     *  Use {@link ImsMmTelManager.RegistrationCallback} instead.\n     *  @hide\n     ",
    "links" : [ "android.telephony.ims.stub.ImsRegistrationImplBase#REGISTRATION_TECH_IWLAN", "android.telephony.ims.stub.ImsRegistrationImplBase#REGISTRATION_TECH_NONE", "android.telephony.ims.stub.ImsRegistrationImplBase#REGISTRATION_TECH_LTE", "ImsMmTelManager.RegistrationCallback" ]
  }, {
    "name" : "public void setSimOperatorNumeric(String numeric)",
    "returnType" : "void",
    "comment" : "\n    * Set TelephonyProperties.icc_operator_numeric for the default phone.\n    *\n    * @hide\n    ",
    "links" : [ ]
  }, {
    "name" : "public void setSimOperatorNumericForPhone(int phoneId, String numeric)",
    "returnType" : "void",
    "comment" : "\n    * Set TelephonyProperties.icc_operator_numeric for the given phone.\n    *\n    * @hide\n    ",
    "links" : [ ]
  }, {
    "name" : "public void setSimOperatorName(String name)",
    "returnType" : "void",
    "comment" : "\n     * Set TelephonyProperties.icc_operator_alpha for the default phone.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public void setSimOperatorNameForPhone(int phoneId, String name)",
    "returnType" : "void",
    "comment" : "\n     * Set TelephonyProperties.icc_operator_alpha for the given phone.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public void setSimCountryIso(String iso)",
    "returnType" : "void",
    "comment" : "\n    * Set TelephonyProperties.icc_operator_iso_country for the default phone.\n    *\n    * @hide\n    ",
    "links" : [ ]
  }, {
    "name" : "public void setSimCountryIsoForPhone(int phoneId, String iso)",
    "returnType" : "void",
    "comment" : "\n    * Set TelephonyProperties.icc_operator_iso_country for the given phone.\n    *\n    * @hide\n    ",
    "links" : [ ]
  }, {
    "name" : "public void setSimState(String state)",
    "returnType" : "void",
    "comment" : "\n     * Set TelephonyProperties.sim_state for the default phone.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public void setSimStateForPhone(int phoneId, String state)",
    "returnType" : "void",
    "comment" : "\n     * Set TelephonyProperties.sim_state for the given phone.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public void setSimPowerState(int state)",
    "returnType" : "void",
    "comment" : "\n     * Set SIM card power state.\n     *\n     * @param state  State of SIM (power down, power up, pass through)\n     * @see #CARD_POWER_DOWN\n     * @see #CARD_POWER_UP\n     * @see #CARD_POWER_UP_PASS_THROUGH\n     * Callers should monitor for {@link TelephonyIntents#ACTION_SIM_STATE_CHANGED}\n     * broadcasts to determine success or failure and timeout if needed.\n     *\n     * <p>Requires Permission:\n     *   {@link android.Manifest.permission#MODIFY_PHONE_STATE MODIFY_PHONE_STATE}\n     *\n     * {@hide}\n     *",
    "links" : [ "#ACTION_SIM_STATE_CHANGED", "android.Manifest.permission#MODIFY_PHONE_STATE" ]
  }, {
    "name" : "public void setSimPowerStateForSlot(int slotIndex, int state)",
    "returnType" : "void",
    "comment" : "\n     * Set SIM card power state.\n     *\n     * @param slotIndex SIM slot id\n     * @param state  State of SIM (power down, power up, pass through)\n     * @see #CARD_POWER_DOWN\n     * @see #CARD_POWER_UP\n     * @see #CARD_POWER_UP_PASS_THROUGH\n     * Callers should monitor for {@link TelephonyIntents#ACTION_SIM_STATE_CHANGED}\n     * broadcasts to determine success or failure and timeout if needed.\n     *\n     * <p>Requires Permission:\n     *   {@link android.Manifest.permission#MODIFY_PHONE_STATE MODIFY_PHONE_STATE}\n     *\n     * {@hide}\n     *",
    "links" : [ "#ACTION_SIM_STATE_CHANGED", "android.Manifest.permission#MODIFY_PHONE_STATE" ]
  }, {
    "name" : "public void setBasebandVersion(String version)",
    "returnType" : "void",
    "comment" : "\n     * Set baseband version for the default phone.\n     *\n     * @param version baseband version\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public void setBasebandVersionForPhone(int phoneId, String version)",
    "returnType" : "void",
    "comment" : "\n     * Set baseband version by phone id.\n     *\n     * @param phoneId for which baseband version is set\n     * @param version baseband version\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public String getBasebandVersion()",
    "returnType" : "String",
    "comment" : "\n     * Get baseband version for the default phone.\n     *\n     * @return baseband version.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public String getBasebandVersionForPhone(int phoneId)",
    "returnType" : "String",
    "comment" : "\n     * Get baseband version by phone id.\n     *\n     * @return baseband version.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public void setPhoneType(int type)",
    "returnType" : "void",
    "comment" : "\n     * Set phone type for the default phone.\n     *\n     * @param type phone type\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public void setPhoneType(int phoneId, int type)",
    "returnType" : "void",
    "comment" : "\n     * Set phone type by phone id.\n     *\n     * @param phoneId for which phone type is set\n     * @param type phone type\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public String getOtaSpNumberSchema(String defaultValue)",
    "returnType" : "String",
    "comment" : "\n     * Get OTASP number schema for the default phone.\n     *\n     * @param defaultValue default value\n     * @return OTA SP number schema\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public String getOtaSpNumberSchemaForPhone(int phoneId, String defaultValue)",
    "returnType" : "String",
    "comment" : "\n     * Get OTASP number schema by phone id.\n     *\n     * @param phoneId for which OTA SP number schema is get\n     * @param defaultValue default value\n     * @return OTA SP number schema\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean getSmsReceiveCapable(boolean defaultValue)",
    "returnType" : "boolean",
    "comment" : "\n     * Get SMS receive capable from system property for the default phone.\n     *\n     * @param defaultValue default value\n     * @return SMS receive capable\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean getSmsReceiveCapableForPhone(int phoneId, boolean defaultValue)",
    "returnType" : "boolean",
    "comment" : "\n     * Get SMS receive capable from system property by phone id.\n     *\n     * @param phoneId for which SMS receive capable is get\n     * @param defaultValue default value\n     * @return SMS receive capable\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean getSmsSendCapable(boolean defaultValue)",
    "returnType" : "boolean",
    "comment" : "\n     * Get SMS send capable from system property for the default phone.\n     *\n     * @param defaultValue default value\n     * @return SMS send capable\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean getSmsSendCapableForPhone(int phoneId, boolean defaultValue)",
    "returnType" : "boolean",
    "comment" : "\n     * Get SMS send capable from system property by phone id.\n     *\n     * @param phoneId for which SMS send capable is get\n     * @param defaultValue default value\n     * @return SMS send capable\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public ComponentName getAndUpdateDefaultRespondViaMessageApplication()",
    "returnType" : "ComponentName",
    "comment" : "\n     * Gets the default Respond Via Message application, updating the cache if there is no\n     * respond-via-message application currently configured.\n     * @return component name of the app and class to direct Respond Via Message intent to, or\n     * {@code null} if the functionality is not supported.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public ComponentName getDefaultRespondViaMessageApplication()",
    "returnType" : "ComponentName",
    "comment" : "\n     * Gets the default Respond Via Message application.\n     * @return component name of the app and class to direct Respond Via Message intent to, or\n     * {@code null} if the functionality is not supported.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public void setNetworkOperatorName(String name)",
    "returnType" : "void",
    "comment" : "\n     * Set the alphabetic name of current registered operator.\n     * @param name the alphabetic name of current registered operator.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public void setNetworkOperatorNameForPhone(int phoneId, String name)",
    "returnType" : "void",
    "comment" : "\n     * Set the alphabetic name of current registered operator.\n     * @param phoneId which phone you want to set\n     * @param name the alphabetic name of current registered operator.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public void setNetworkOperatorNumeric(String numeric)",
    "returnType" : "void",
    "comment" : "\n     * Set the numeric name (MCC+MNC) of current registered operator.\n     * @param operator the numeric name (MCC+MNC) of current registered operator\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public void setNetworkOperatorNumericForPhone(int phoneId, String numeric)",
    "returnType" : "void",
    "comment" : "\n     * Set the numeric name (MCC+MNC) of current registered operator.\n     * @param phoneId for which phone type is set\n     * @param operator the numeric name (MCC+MNC) of current registered operator\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public void setNetworkRoaming(boolean isRoaming)",
    "returnType" : "void",
    "comment" : "\n     * Set roaming state of the current network, for GSM purposes.\n     * @param isRoaming is network in romaing state or not\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public void setNetworkRoamingForPhone(int phoneId, boolean isRoaming)",
    "returnType" : "void",
    "comment" : "\n     * Set roaming state of the current network, for GSM purposes.\n     * @param phoneId which phone you want to set\n     * @param isRoaming is network in romaing state or not\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public void setDataNetworkType(int type)",
    "returnType" : "void",
    "comment" : "\n     * Set the network type currently in use on the device for data transmission.\n     *\n     * If this object has been created with {@link #createForSubscriptionId}, applies to the\n     * phoneId associated with the given subId. Otherwise, applies to the phoneId associated with\n     * {@link SubscriptionManager#getDefaultDataSubscriptionId()}\n     * @param type the network type currently in use on the device for data transmission\n     * @hide\n     ",
    "links" : [ "#createForSubscriptionId", "android.telephony.SubscriptionManager#getDefaultDataSubscriptionId()" ]
  }, {
    "name" : "public void setDataNetworkTypeForPhone(int phoneId, int type)",
    "returnType" : "void",
    "comment" : "\n     * Set the network type currently in use on the device for data transmission.\n     * @param phoneId which phone you want to set\n     * @param type the network type currently in use on the device for data transmission\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public int getSubIdForPhoneAccount(@Nullable PhoneAccount phoneAccount)",
    "returnType" : "int",
    "comment" : "\n     * Returns the subscription ID for the given phone account.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public PhoneAccountHandle getPhoneAccountHandleForSubscriptionId(int subscriptionId)",
    "returnType" : "PhoneAccountHandle",
    "comment" : "\n     * Determines the {@link PhoneAccountHandle} associated with a subscription Id.\n     *\n     * @param subscriptionId The subscription Id to check.\n     * @return The {@link PhoneAccountHandle} associated with a subscription Id, or {@code null} if\n     * there is no associated {@link PhoneAccountHandle}.\n     * @hide\n     ",
    "links" : [ "android.telecom.PhoneAccountHandle" ]
  }, {
    "name" : "public int getSubscriptionId(@NonNull PhoneAccountHandle phoneAccountHandle)",
    "returnType" : "int",
    "comment" : "\n     * Returns the subscription ID for the given phone account handle.\n     *\n     * @param phoneAccountHandle the phone account handle for outgoing calls\n     * @return subscription ID for the given phone account handle; or\n     *         {@link SubscriptionManager#INVALID_SUBSCRIPTION_ID}\n     *         if not available; or throw a SecurityException if the caller doesn't have the\n     *         permission.\n     ",
    "links" : [ "android.telephony.SubscriptionManager#INVALID_SUBSCRIPTION_ID" ]
  }, {
    "name" : "public void factoryReset(int subId)",
    "returnType" : "void",
    "comment" : "\n     * Resets telephony manager settings back to factory defaults.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public void resetSettings()",
    "returnType" : "void",
    "comment" : "\n     * Resets Telephony and IMS settings back to factory defaults only for the subscription\n     * associated with this instance.\n     * @see #createForSubscriptionId(int)\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public Locale getSimLocale()",
    "returnType" : "Locale",
    "comment" : "\n     * Returns a locale based on the country and language from the SIM. Returns {@code null} if\n     * no locale could be derived from subscriptions.\n     *\n     * <p>Requires Permission:\n     * {@link android.Manifest.permission#READ_PRIVILEGED_PHONE_STATE READ_PRIVILEGED_PHONE_STATE}\n     *\n     * @see Locale#toLanguageTag()\n     *\n     * @hide\n     ",
    "links" : [ "android.Manifest.permission#READ_PRIVILEGED_PHONE_STATE" ]
  }, {
    "name" : "public String getLocaleFromDefaultSim()",
    "returnType" : "String",
    "comment" : "\n     * TODO delete after SuW migrates to new API.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public void requestModemActivityInfo(@NonNull ResultReceiver result)",
    "returnType" : "void",
    "comment" : "\n     * Requests the modem activity info. The recipient will place the result\n     * in `result`.\n     * @param result The object on which the recipient will send the resulting\n     * {@link android.telephony.ModemActivityInfo} object with key of\n     * {@link #MODEM_ACTIVITY_RESULT_KEY}.\n     * @hide\n     ",
    "links" : [ "#MODEM_ACTIVITY_RESULT_KEY", "android.telephony.ModemActivityInfo" ]
  }, {
    "name" : "public ServiceState getServiceState()",
    "returnType" : "ServiceState",
    "comment" : "\n     * Returns the current {@link ServiceState} information.\n     *\n     * <p>If this object has been created with {@link #createForSubscriptionId}, applies to the\n     * given subId. Otherwise, applies to {@link SubscriptionManager#getDefaultSubscriptionId()}\n     *\n     * <p>Requires Permission: {@link android.Manifest.permission#READ_PHONE_STATE READ_PHONE_STATE}\n     * or that the calling app has carrier privileges (see {@link #hasCarrierPrivileges})\n     * and {@link android.Manifest.permission#ACCESS_COARSE_LOCATION}.\n     ",
    "links" : [ "#createForSubscriptionId", "android.Manifest.permission#ACCESS_COARSE_LOCATION", "android.telephony.SubscriptionManager#getDefaultSubscriptionId()", "android.telephony.ServiceState", "#hasCarrierPrivileges", "android.Manifest.permission#READ_PHONE_STATE" ]
  }, {
    "name" : "public ServiceState getServiceStateForSubscriber(int subId)",
    "returnType" : "ServiceState",
    "comment" : "\n     * Returns the service state information on specified subscription. Callers require\n     * either READ_PRIVILEGED_PHONE_STATE or READ_PHONE_STATE to retrieve the information.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public Uri getVoicemailRingtoneUri(PhoneAccountHandle accountHandle)",
    "returnType" : "Uri",
    "comment" : "\n     * Returns the URI for the per-account voicemail ringtone set in Phone settings.\n     *\n     * @param accountHandle The handle for the {@link PhoneAccount} for which to retrieve the\n     * voicemail ringtone.\n     * @return The URI for the ringtone to play when receiving a voicemail from a specific\n     * PhoneAccount.\n     ",
    "links" : [ "android.telecom.PhoneAccount" ]
  }, {
    "name" : "public void setVoicemailRingtoneUri(PhoneAccountHandle phoneAccountHandle, Uri uri)",
    "returnType" : "void",
    "comment" : "\n     * Sets the per-account voicemail ringtone.\n     *\n     * <p>Requires that the calling app is the default dialer, or has carrier privileges (see\n     * {@link #hasCarrierPrivileges}, or has permission\n     * {@link android.Manifest.permission#MODIFY_PHONE_STATE MODIFY_PHONE_STATE}.\n     *\n     * @param phoneAccountHandle The handle for the {@link PhoneAccount} for which to set the\n     * voicemail ringtone.\n     * @param uri The URI for the ringtone to play when receiving a voicemail from a specific\n     * PhoneAccount.\n     *\n     * @deprecated Use {@link android.provider.Settings#ACTION_CHANNEL_NOTIFICATION_SETTINGS}\n     * instead.\n     ",
    "links" : [ "android.telecom.PhoneAccount", "#hasCarrierPrivileges", "android.provider.Settings#ACTION_CHANNEL_NOTIFICATION_SETTINGS", "android.Manifest.permission#MODIFY_PHONE_STATE" ]
  }, {
    "name" : "public boolean isVoicemailVibrationEnabled(PhoneAccountHandle accountHandle)",
    "returnType" : "boolean",
    "comment" : "\n     * Returns whether vibration is set for voicemail notification in Phone settings.\n     *\n     * @param accountHandle The handle for the {@link PhoneAccount} for which to retrieve the\n     * voicemail vibration setting.\n     * @return {@code true} if the vibration is set for this PhoneAccount, {@code false} otherwise.\n     ",
    "links" : [ "android.telecom.PhoneAccount" ]
  }, {
    "name" : "public void setVoicemailVibrationEnabled(PhoneAccountHandle phoneAccountHandle, boolean enabled)",
    "returnType" : "void",
    "comment" : "\n     * Sets the per-account preference whether vibration is enabled for voicemail notifications.\n     *\n     * <p>Requires that the calling app is the default dialer, or has carrier privileges (see\n     * {@link #hasCarrierPrivileges}, or has permission\n     * {@link android.Manifest.permission#MODIFY_PHONE_STATE MODIFY_PHONE_STATE}.\n     *\n     * @param phoneAccountHandle The handle for the {@link PhoneAccount} for which to set the\n     * voicemail vibration setting.\n     * @param enabled Whether to enable or disable vibration for voicemail notifications from a\n     * specific PhoneAccount.\n     *\n     * @deprecated Use {@link android.provider.Settings#ACTION_CHANNEL_NOTIFICATION_SETTINGS}\n     * instead.\n     ",
    "links" : [ "android.telecom.PhoneAccount", "#hasCarrierPrivileges", "android.provider.Settings#ACTION_CHANNEL_NOTIFICATION_SETTINGS", "android.Manifest.permission#MODIFY_PHONE_STATE" ]
  }, {
    "name" : "public int getSimCarrierId()",
    "returnType" : "int",
    "comment" : "\n     * Returns carrier id of the current subscription.\n     * <p>To recognize a carrier (including MVNO) as a first-class identity, Android assigns each\n     * carrier with a canonical integer a.k.a. carrier id. The carrier ID is an Android\n     * platform-wide identifier for a carrier. AOSP maintains carrier ID assignments in\n     * <a href=\"https://android.googlesource.com/platform/packages/providers/TelephonyProvider/+/master/assets/latest_carrier_id/carrier_list.textpb\">here</a>\n     *\n     * <p>Apps which have carrier-specific configurations or business logic can use the carrier id\n     * as an Android platform-wide identifier for carriers.\n     *\n     * @return Carrier id of the current subscription. Return {@link #UNKNOWN_CARRIER_ID} if the\n     * subscription is unavailable or the carrier cannot be identified.\n     ",
    "links" : [ "#UNKNOWN_CARRIER_ID" ]
  }, {
    "name" : "public CharSequence getSimCarrierIdName()",
    "returnType" : "CharSequence",
    "comment" : "\n     * Returns carrier id name of the current subscription.\n     * <p>Carrier id name is a user-facing name of carrier id returned by\n     * {@link #getSimCarrierId()}, usually the brand name of the subsidiary\n     * (e.g. T-Mobile). Each carrier could configure multiple {@link #getSimOperatorName() SPN} but\n     * should have a single carrier name. Carrier name is not a canonical identity,\n     * use {@link #getSimCarrierId()} instead.\n     * <p>The returned carrier name is unlocalized.\n     *\n     * @return Carrier name of the current subscription. Return {@code null} if the subscription is\n     * unavailable or the carrier cannot be identified.\n     ",
    "links" : [ "#getSimOperatorName()", "#getSimCarrierId()" ]
  }, {
    "name" : "public int getSimSpecificCarrierId()",
    "returnType" : "int",
    "comment" : "\n     * Returns fine-grained carrier ID of the current subscription.\n     *\n     * A specific carrier ID can represent the fact that a carrier may be in effect an aggregation\n     * of other carriers (ie in an MVNO type scenario) where each of these specific carriers which\n     * are used to make up the actual carrier service may have different carrier configurations.\n     * A specific carrier ID could also be used, for example, in a scenario where a carrier requires\n     * different carrier configuration for different service offering such as a prepaid plan.\n     *\n     * the specific carrier ID would be used for configuration purposes, but apps wishing to know\n     * about the carrier itself should use the regular carrier ID returned by\n     * {@link #getSimCarrierId()}.\n     *\n     * e.g, Tracfone SIMs could return different specific carrier ID based on IMSI from current\n     * subscription while carrier ID remains the same.\n     *\n     * <p>For carriers without fine-grained specific carrier ids, return {@link #getSimCarrierId()}\n     * <p>Specific carrier ids are defined in the same way as carrier id\n     * <a href=\"https://android.googlesource.com/platform/packages/providers/TelephonyProvider/+/master/assets/latest_carrier_id/carrier_list.textpb\">here</a>\n     * except each with a \"parent\" id linking to its top-level carrier id.\n     *\n     * @return Returns fine-grained carrier id of the current subscription.\n     * Return {@link #UNKNOWN_CARRIER_ID} if the subscription is unavailable or the carrier cannot\n     * be identified.\n     ",
    "links" : [ "#getSimCarrierId()", "#UNKNOWN_CARRIER_ID" ]
  }, {
    "name" : "public CharSequence getSimSpecificCarrierIdName()",
    "returnType" : "CharSequence",
    "comment" : "\n     * Similar like {@link #getSimCarrierIdName()}, returns user-facing name of the\n     * specific carrier id returned by {@link #getSimSpecificCarrierId()}.\n     *\n     * The specific carrier ID would be used for configuration purposes, but apps wishing to know\n     * about the carrier itself should use the regular carrier ID returned by\n     * {@link #getSimCarrierIdName()}.\n     *\n     * <p>The returned name is unlocalized.\n     *\n     * @return user-facing name of the subscription specific carrier id. Return {@code null} if the\n     * subscription is unavailable or the carrier cannot be identified.\n     ",
    "links" : [ "#getSimCarrierIdName()", "#getSimSpecificCarrierId()" ]
  }, {
    "name" : "public int getCarrierIdFromSimMccMnc()",
    "returnType" : "int",
    "comment" : "\n     * Returns carrier id based on sim MCCMNC (returned by {@link #getSimOperator()}) only.\n     * This is used for fallback when configurations/logic for exact carrier id\n     * {@link #getSimCarrierId()} are not found.\n     *\n     * Android carrier id table <a href=\"https://android.googlesource.com/platform/packages/providers/TelephonyProvider/+/master/assets/latest_carrier_id/carrier_list.textpb\">here</a>\n     * can be updated out-of-band, its possible a MVNO (Mobile Virtual Network Operator) carrier\n     * was not fully recognized and assigned to its MNO (Mobile Network Operator) carrier id\n     * by default. After carrier id table update, a new carrier id was assigned. If apps don't\n     * take the update with the new id, it might be helpful to always fallback by using carrier\n     * id based on MCCMNC if there is no match.\n     *\n     * @return matching carrier id from sim MCCMNC. Return {@link #UNKNOWN_CARRIER_ID} if the\n     * subscription is unavailable or the carrier cannot be identified.\n     ",
    "links" : [ "#getSimCarrierId()", "#UNKNOWN_CARRIER_ID", "#getSimOperator()" ]
  }, {
    "name" : "public int getCarrierIdFromMccMnc(String mccmnc)",
    "returnType" : "int",
    "comment" : "\n      * Returns carrier id based on MCCMNC (returned by {@link #getSimOperator()}) only. This is\n      * used for fallback when configurations/logic for exact carrier id {@link #getSimCarrierId()}\n      * are not found.\n      *\n      * Android carrier id table <a href=\"https://android.googlesource.com/platform/packages/providers/TelephonyProvider/+/master/assets/latest_carrier_id/carrier_list.textpb\">here</a>\n      * can be updated out-of-band, its possible a MVNO (Mobile Virtual Network Operator) carrier\n      * was not fully recognized and assigned to its MNO (Mobile Network Operator) carrier id\n      * by default. After carrier id table update, a new carrier id was assigned. If apps don't\n      * take the update with the new id, it might be helpful to always fallback by using carrier\n      * id based on MCCMNC if there is no match.\n      *\n      * @return matching carrier id from passing MCCMNC. Return {@link #UNKNOWN_CARRIER_ID} if the\n      * subscription is unavailable or the carrier cannot be identified.\n      * @hide\n      ",
    "links" : [ "#getSimCarrierId()", "#UNKNOWN_CARRIER_ID", "#getSimOperator()" ]
  }, {
    "name" : "public List<String> getCertsFromCarrierPrivilegeAccessRules()",
    "returnType" : "List<String>",
    "comment" : "\n     * Return a list of certs in hex string from loaded carrier privileges access rules.\n     *\n     * @return a list of certificate in hex string. return {@code null} if there is no certs\n     * or privilege rules are not loaded yet.\n     *\n     * <p>Requires Permission:\n     * {@link android.Manifest.permission#READ_PRIVILEGED_PHONE_STATE}\n     * @hide\n     ",
    "links" : [ "android.Manifest.permission#READ_PRIVILEGED_PHONE_STATE" ]
  }, {
    "name" : "public String getAidForAppType(@UiccAppType int appType)",
    "returnType" : "String",
    "comment" : "\n     * Return the application ID for the uicc application type like {@link #APPTYPE_CSIM}.\n     * All uicc applications are uniquely identified by application ID, represented by the hex\n     * string. e.g, A00000015141434C00. See ETSI 102.221 and 101.220\n     * <p>Requires Permission:\n     *   {@link android.Manifest.permission#READ_PRIVILEGED_PHONE_STATE}\n     *\n     * @param appType the uicc app type.\n     * @return Application ID for specified app type or {@code null} if no uicc or error.\n     * @hide\n     ",
    "links" : [ "#APPTYPE_CSIM", "android.Manifest.permission#READ_PRIVILEGED_PHONE_STATE" ]
  }, {
    "name" : "public String getAidForAppType(int subId, int appType)",
    "returnType" : "String",
    "comment" : "\n     * same as {@link #getAidForAppType(int)}\n     * @hide\n     ",
    "links" : [ "#getAidForAppType(int)" ]
  }, {
    "name" : "public String getEsn()",
    "returnType" : "String",
    "comment" : "\n     * Return the Electronic Serial Number.\n     *\n     * Requires that the calling app has READ_PRIVILEGED_PHONE_STATE permission\n     *\n     * @return ESN or null if error.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public String getEsn(int subId)",
    "returnType" : "String",
    "comment" : "\n     * Return the Electronic Serial Number.\n     *\n     * Requires that the calling app has READ_PRIVILEGED_PHONE_STATE permission\n     *\n     * @param subId the subscription ID that this request applies to.\n     * @return ESN or null if error.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public String getCdmaPrlVersion()",
    "returnType" : "String",
    "comment" : "\n     * Return the Preferred Roaming List Version\n     *\n     * Requires that the calling app has READ_PRIVILEGED_PHONE_STATE permission\n     *\n     * @return PRLVersion or null if error.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public String getCdmaPrlVersion(int subId)",
    "returnType" : "String",
    "comment" : "\n     * Return the Preferred Roaming List Version\n     *\n     * Requires that the calling app has READ_PRIVILEGED_PHONE_STATE permission\n     *\n     * @param subId the subscription ID that this request applies to.\n     * @return PRLVersion or null if error.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public List<TelephonyHistogram> getTelephonyHistograms()",
    "returnType" : "List<TelephonyHistogram>",
    "comment" : "\n     * Get snapshot of Telephony histograms\n     * @return List of Telephony histograms\n     * Requires Permission:\n     *   {@link android.Manifest.permission#MODIFY_PHONE_STATE MODIFY_PHONE_STATE}\n     * Or the calling app has carrier privileges.\n     * @hide\n     ",
    "links" : [ "android.Manifest.permission#MODIFY_PHONE_STATE" ]
  }, {
    "name" : "public int setAllowedCarriers(int slotIndex, List<CarrierIdentifier> carriers)",
    "returnType" : "int",
    "comment" : "\n     * Set the allowed carrier list for slotIndex\n     * Require system privileges. In the future we may add this to carrier APIs.\n     *\n     * <p>Requires Permission:\n     *   {@link android.Manifest.permission#MODIFY_PHONE_STATE}\n     *\n     * <p>This method works only on devices with {@link\n     * android.content.pm.PackageManager#FEATURE_TELEPHONY_CARRIERLOCK} enabled.\n     *\n     * @deprecated use setCarrierRestrictionRules instead\n     *\n     * @return The number of carriers set successfully. Should be length of\n     * carrierList on success; -1 if carrierList null or on error.\n     * @hide\n     ",
    "links" : [ "android.content.pm.PackageManager#FEATURE_TELEPHONY_CARRIERLOCK", "android.Manifest.permission#MODIFY_PHONE_STATE" ]
  }, {
    "name" : "public int setCarrierRestrictionRules(@NonNull CarrierRestrictionRules rules)",
    "returnType" : "int",
    "comment" : "\n     * Set the allowed carrier list and the excluded carrier list indicating the priority between\n     * the two lists.\n     * Requires system privileges.\n     *\n     * <p>Requires Permission:\n     *   {@link android.Manifest.permission#MODIFY_PHONE_STATE}\n     *\n     * <p>This method works only on devices with {@link\n     * android.content.pm.PackageManager#FEATURE_TELEPHONY_CARRIERLOCK} enabled.\n     *\n     * @return {@link #SET_CARRIER_RESTRICTION_SUCCESS} in case of success.\n     * {@link #SET_CARRIER_RESTRICTION_NOT_SUPPORTED} if the modem does not support the\n     * configuration. {@link #SET_CARRIER_RESTRICTION_ERROR} in all other error cases.\n     * @hide\n     ",
    "links" : [ "#SET_CARRIER_RESTRICTION_SUCCESS", "android.content.pm.PackageManager#FEATURE_TELEPHONY_CARRIERLOCK", "#SET_CARRIER_RESTRICTION_NOT_SUPPORTED", "#SET_CARRIER_RESTRICTION_ERROR", "android.Manifest.permission#MODIFY_PHONE_STATE" ]
  }, {
    "name" : "public List<CarrierIdentifier> getAllowedCarriers(int slotIndex)",
    "returnType" : "List<CarrierIdentifier>",
    "comment" : "\n     * Get the allowed carrier list for slotIndex.\n     * Requires system privileges.\n     *\n     * <p>This method returns valid data on devices with {@link\n     * android.content.pm.PackageManager#FEATURE_TELEPHONY_CARRIERLOCK} enabled.\n     *\n     * @deprecated Apps should use {@link getCarriersRestrictionRules} to retrieve the list of\n     * allowed and excliuded carriers, as the result of this API is valid only when the excluded\n     * list is empty. This API could return an empty list, even if some restrictions are present.\n     *\n     * @return List of {@link android.telephony.CarrierIdentifier}; empty list\n     * means all carriers are allowed.\n     * @hide\n     ",
    "links" : [ "android.content.pm.PackageManager#FEATURE_TELEPHONY_CARRIERLOCK", "getCarriersRestrictionRules", "android.telephony.CarrierIdentifier" ]
  }, {
    "name" : "public CarrierRestrictionRules getCarrierRestrictionRules()",
    "returnType" : "CarrierRestrictionRules",
    "comment" : "\n     * Get the allowed carrier list and the excluded carrier list indicating the priority between\n     * the two lists.\n     * Require system privileges. In the future we may add this to carrier APIs.\n     *\n     * <p>This method returns valid data on devices with {@link\n     * android.content.pm.PackageManager#FEATURE_TELEPHONY_CARRIERLOCK} enabled.\n     *\n     * @return {@link CarrierRestrictionRules} which contains the allowed carrier list and the\n     * excluded carrier list with the priority between the two lists. Returns {@code null}\n     * in case of error.\n     * @hide\n     ",
    "links" : [ "android.content.pm.PackageManager#FEATURE_TELEPHONY_CARRIERLOCK", "android.telephony.CarrierRestrictionRules" ]
  }, {
    "name" : "public void setCarrierDataEnabled(boolean enabled)",
    "returnType" : "void",
    "comment" : "\n     * Used to enable or disable carrier data by the system based on carrier signalling or\n     * carrier privileged apps. Different from {@link #setDataEnabled(boolean)} which is linked to\n     * user settings, carrier data on/off won't affect user settings but will bypass the\n     * settings and turns off data internally if set to {@code false}.\n     *\n     * <p>If this object has been created with {@link #createForSubscriptionId}, applies to the\n     * given subId. Otherwise, applies to {@link SubscriptionManager#getDefaultDataSubscriptionId()}\n     *\n     * <p>Requires Permission:\n     * {@link android.Manifest.permission#MODIFY_PHONE_STATE MODIFY_PHONE_STATE}.\n     *\n     * @param enabled control enable or disable carrier data.\n     * @see #resetAllCarrierActions()\n     * @hide\n     ",
    "links" : [ "#createForSubscriptionId", "android.telephony.SubscriptionManager#getDefaultDataSubscriptionId()", "android.Manifest.permission#MODIFY_PHONE_STATE", "#setDataEnabled(boolean)" ]
  }, {
    "name" : "public void setRadioEnabled(boolean enabled)",
    "returnType" : "void",
    "comment" : "\n     * Carrier action to enable or disable the radio.\n     *\n     * <p>If this object has been created with {@link #createForSubscriptionId}, applies to the\n     * given subId. Otherwise, applies to {@link SubscriptionManager#getDefaultDataSubscriptionId()}\n     *\n     * <p>Requires Permission:\n     * {@link android.Manifest.permission#MODIFY_PHONE_STATE MODIFY_PHONE_STATE}.\n     *\n     * @param enabled control enable or disable radio.\n     * @see #resetAllCarrierActions()\n     * @hide\n     ",
    "links" : [ "#createForSubscriptionId", "android.telephony.SubscriptionManager#getDefaultDataSubscriptionId()", "android.Manifest.permission#MODIFY_PHONE_STATE" ]
  }, {
    "name" : "public void reportDefaultNetworkStatus(boolean report)",
    "returnType" : "void",
    "comment" : "\n     * Carrier action to start or stop reporting default network available events.\n     *\n     * <p>If this object has been created with {@link #createForSubscriptionId}, applies to the\n     * given subId. Otherwise, applies to {@link SubscriptionManager#getDefaultDataSubscriptionId()}\n     *\n     * <p>Requires Permission:\n     * {@link android.Manifest.permission#MODIFY_PHONE_STATE MODIFY_PHONE_STATE}.\n     *\n     * @param report control start/stop reporting network status.\n     * @see #resetAllCarrierActions()\n     * @hide\n     ",
    "links" : [ "#createForSubscriptionId", "android.telephony.SubscriptionManager#getDefaultDataSubscriptionId()", "android.Manifest.permission#MODIFY_PHONE_STATE" ]
  }, {
    "name" : "public void resetAllCarrierActions()",
    "returnType" : "void",
    "comment" : "\n     * Reset all carrier actions previously set by {@link #setRadioEnabled},\n     * {@link #reportDefaultNetworkStatus} and {@link #setCarrierDataEnabled}.\n     *\n     * <p>If this object has been created with {@link #createForSubscriptionId}, applies to the\n     * given subId. Otherwise, applies to {@link SubscriptionManager#getDefaultDataSubscriptionId()}\n     *\n     * <p>Requires Permission:\n     * {@link android.Manifest.permission#MODIFY_PHONE_STATE MODIFY_PHONE_STATE}.\n     * @hide\n     ",
    "links" : [ "#createForSubscriptionId", "android.telephony.SubscriptionManager#getDefaultDataSubscriptionId()", "#setCarrierDataEnabled", "#setRadioEnabled", "android.Manifest.permission#MODIFY_PHONE_STATE", "#reportDefaultNetworkStatus" ]
  }, {
    "name" : "public void setPolicyDataEnabled(boolean enabled)",
    "returnType" : "void",
    "comment" : "\n     * Policy control of data connection. Usually used when data limit is passed.\n     * @param enabled True if enabling the data, otherwise disabling.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public List<ClientRequestStats> getClientRequestStats(int subId)",
    "returnType" : "List<ClientRequestStats>",
    "comment" : "\n     * Get Client request stats which will contain statistical information\n     * on each request made by client.\n     * Callers require either READ_PRIVILEGED_PHONE_STATE or\n     * READ_PHONE_STATE to retrieve the information.\n     * @param subId sub id\n     * @return List of Client Request Stats\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean getEmergencyCallbackMode()",
    "returnType" : "boolean",
    "comment" : "\n     * Checks if phone is in emergency callback mode.\n     *\n     * <p>If this object has been created with {@link #createForSubscriptionId}, applies to the\n     * given subId. Otherwise, applies to {@link SubscriptionManager#getDefaultSubscriptionId()}\n     *\n     * @return true if phone is in emergency callback mode.\n     * @hide\n     ",
    "links" : [ "#createForSubscriptionId", "android.telephony.SubscriptionManager#getDefaultSubscriptionId()" ]
  }, {
    "name" : "public boolean getEmergencyCallbackMode(int subId)",
    "returnType" : "boolean",
    "comment" : "\n     * Check if phone is in emergency callback mode\n     * @return true if phone is in emergency callback mode\n     * @param subId the subscription ID that this action applies to.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean isManualNetworkSelectionAllowed()",
    "returnType" : "boolean",
    "comment" : "\n     * Checks if manual network selection is allowed.\n     *\n     * <p>Requires Permission: {@link android.Manifest.permission#READ_PRECISE_PHONE_STATE\n     * READ_PRECISE_PHONE_STATE} or that the calling app has carrier privileges\n     * (see {@link #hasCarrierPrivileges})\n     *\n     * <p>If this object has been created with {@link #createForSubscriptionId}, applies to the\n     * given subId. Otherwise, applies to {@link SubscriptionManager#getDefaultSubscriptionId()}.\n     *\n     * @return {@code true} if manual network selection is allowed, otherwise return {@code false}.\n     ",
    "links" : [ "#createForSubscriptionId", "android.telephony.SubscriptionManager#getDefaultSubscriptionId()", "android.Manifest.permission#READ_PRECISE_PHONE_STATEREAD_PRECISE_PHONE_STATE", "#hasCarrierPrivileges" ]
  }, {
    "name" : "public void setAlwaysReportSignalStrength(boolean isEnabled)",
    "returnType" : "void",
    "comment" : "\n     * Enable or disable signal strength changes from radio will always be reported in any\n     * condition (e.g. screen is off). This is only allowed for System caller.\n     *\n     * @param isEnabled {@code true} for enabling; {@code false} for disabling.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public SignalStrength getSignalStrength()",
    "returnType" : "SignalStrength",
    "comment" : "\n     * Get the most recently available signal strength information.\n     *\n     * Get the most recent SignalStrength information reported by the modem. Due\n     * to power saving this information may not always be current.\n     * @return the most recent cached signal strength info from the modem\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean isDataConnectionAllowed()",
    "returnType" : "boolean",
    "comment" : "\n     * Checks whether cellular data connection is allowed in the device.\n     *\n     * <p>Whether cellular data connection is allowed considers all factors below:\n     * <UL>\n     *   <LI>User turned on data setting {@link #isDataEnabled}.</LI>\n     *   <LI>Carrier allows data to be on.</LI>\n     *   <LI>Network policy.</LI>\n     *   <LI>And possibly others.</LI>\n     * </UL>\n     * @return {@code true} if the overall data connection is allowed; {@code false} if not.\n     * @hide\n     ",
    "links" : [ "#isDataEnabled" ]
  }, {
    "name" : "public boolean isDataCapable()",
    "returnType" : "boolean",
    "comment" : "\n     * @return true if the current device is \"data capable\" over a radio on the device.\n     * <p>\n     * \"Data capable\" means that this device supports packet-switched\n     * data connections over the telephony network.\n     * <p>\n     * Note: the meaning of this flag is subtly different from the\n     * PackageManager.FEATURE_TELEPHONY system feature, which is available\n     * on any device with a telephony radio, even if the device is\n     * voice-only.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public void setCarrierTestOverride(String mccmnc, String imsi, String iccid, String gid1, String gid2, String plmn, String spn)",
    "returnType" : "void",
    "comment" : "\n     * A test API to override carrier information including mccmnc, imsi, iccid, gid1, gid2,\n     * plmn and spn. This would be handy for, eg, forcing a particular carrier id, carrier's config\n     * (also any country or carrier overlays) to be loaded when using a test SIM with a call box.\n     *\n     * <p>Requires Permission:\n     *   {@link android.Manifest.permission#MODIFY_PHONE_STATE MODIFY_PHONE_STATE}\n     *\n     *\n     * @deprecated\n     * @hide\n     ",
    "links" : [ "android.Manifest.permission#MODIFY_PHONE_STATE" ]
  }, {
    "name" : "public void setCarrierTestOverride(String mccmnc, String imsi, String iccid, String gid1, String gid2, String plmn, String spn, String carrierPriviledgeRules, String apn)",
    "returnType" : "void",
    "comment" : "\n     * A test API to override carrier information including mccmnc, imsi, iccid, gid1, gid2,\n     * plmn, spn, apn and carrier priviledge. This would be handy for, eg, forcing a particular\n     * carrier id, carrier's config (also any country or carrier overlays) to be loaded when using\n     * a test SIM with a call box.\n     *\n     * <p>Requires Permission:\n     *   {@link android.Manifest.permission#MODIFY_PHONE_STATE MODIFY_PHONE_STATE}\n     *\n     * @hide\n     ",
    "links" : [ "android.Manifest.permission#MODIFY_PHONE_STATE" ]
  }, {
    "name" : "public int getCarrierIdListVersion()",
    "returnType" : "int",
    "comment" : "\n     * A test API to return installed carrier id list version\n     *\n     * <p>Requires Permission:\n     *   {@link android.Manifest.permission#READ_PRIVILEGED_PHONE_STATE READ_PRIVILEGED_PHONE_STATE}\n     *\n     * @hide\n     ",
    "links" : [ "android.Manifest.permission#READ_PRIVILEGED_PHONE_STATE" ]
  }, {
    "name" : "public int getNumberOfModemsWithSimultaneousDataConnections()",
    "returnType" : "int",
    "comment" : "\n     * How many modems can have simultaneous data connections.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean setOpportunisticNetworkState(boolean enable)",
    "returnType" : "boolean",
    "comment" : "\n     * Enable or disable OpportunisticNetworkService.\n     *\n     * This method should be called to enable or disable\n     * OpportunisticNetwork service on the device.\n     *\n     * <p>\n     * Requires Permission:\n     *   {@link android.Manifest.permission#MODIFY_PHONE_STATE MODIFY_PHONE_STATE}\n     *\n     * @param enable enable(True) or disable(False)\n     * @return returns true if successfully set.\n     * @hide\n     ",
    "links" : [ "android.Manifest.permission#MODIFY_PHONE_STATE" ]
  }, {
    "name" : "public boolean isOpportunisticNetworkEnabled()",
    "returnType" : "boolean",
    "comment" : "\n     * is OpportunisticNetworkService enabled\n     *\n     * This method should be called to determine if the OpportunisticNetworkService is\n     * enabled\n     *\n     * <p>\n     * Requires Permission:\n     *   {@link android.Manifest.permission#READ_PRIVILEGED_PHONE_STATE READ_PRIVILEGED_PHONE_STATE}\n     * @hide\n     ",
    "links" : [ "android.Manifest.permission#READ_PRIVILEGED_PHONE_STATE" ]
  }, {
    "name" : "public long getSupportedRadioAccessFamily()",
    "returnType" : "long",
    "comment" : "\n     * @return Modem supported radio access family bitmask\n     *\n     * <p>Requires permission: {@link android.Manifest.permission#READ_PRIVILEGED_PHONE_STATE} or\n     * that the calling app has carrier privileges (see {@link #hasCarrierPrivileges}).\n     * @hide\n     ",
    "links" : [ "#hasCarrierPrivileges", "android.Manifest.permission#READ_PRIVILEGED_PHONE_STATE" ]
  }, {
    "name" : "public void notifyOtaEmergencyNumberDbInstalled()",
    "returnType" : "void",
    "comment" : "\n     * Notify Telephony for OTA emergency number database installation complete.\n     *\n     * <p> Requires permission:\n     * {@link android.Manifest.permission#MODIFY_PHONE_STATE MODIFY_PHONE_STATE}\n     *\n     * @hide\n     ",
    "links" : [ "android.Manifest.permission#MODIFY_PHONE_STATE" ]
  }, {
    "name" : "public void updateOtaEmergencyNumberDbFilePath(@NonNull ParcelFileDescriptor otaParcelFileDescriptor)",
    "returnType" : "void",
    "comment" : "\n     * Override the file path for OTA emergency number database in a file partition.\n     *\n     * @param otaParcelFileDescriptor parcelable file descriptor for OTA emergency number database.\n     *\n     * <p> Requires permission:\n     * {@link android.Manifest.permission#READ_ACTIVE_EMERGENCY_SESSION}\n     *\n     * @hide\n     ",
    "links" : [ "android.Manifest.permission#READ_ACTIVE_EMERGENCY_SESSION" ]
  }, {
    "name" : "public void resetOtaEmergencyNumberDbFilePath()",
    "returnType" : "void",
    "comment" : "\n     * Reset the file path to default for OTA emergency number database in a file partition.\n     *\n     * <p> Requires permission:\n     * {@link android.Manifest.permission#READ_ACTIVE_EMERGENCY_SESSION}\n     *\n     * @hide\n     ",
    "links" : [ "android.Manifest.permission#READ_ACTIVE_EMERGENCY_SESSION" ]
  }, {
    "name" : "public boolean isEmergencyAssistanceEnabled()",
    "returnType" : "boolean",
    "comment" : "\n     * Returns whether {@link TelephonyManager#ACTION_EMERGENCY_ASSISTANCE emergency assistance} is\n     * available on the device.\n     * <p>\n     * Requires permission: {@link android.Manifest.permission#READ_PRIVILEGED_PHONE_STATE}\n     *\n     * @return {@code true} if emergency assistance is available, {@code false} otherwise\n     *\n     * @hide\n     ",
    "links" : [ "android.telephony.TelephonyManager#ACTION_EMERGENCY_ASSISTANCE", "android.Manifest.permission#READ_PRIVILEGED_PHONE_STATE" ]
  }, {
    "name" : "public Map<Integer, List<EmergencyNumber>> getEmergencyNumberList()",
    "returnType" : "Map<Integer, List<EmergencyNumber>>",
    "comment" : "\n     * Get the emergency number list based on current locale, sim, default, modem and network.\n     *\n     * <p>In each returned list, the emergency number {@link EmergencyNumber} coming from higher\n     * priority sources will be located at the smaller index; the priority order of sources are:\n     * {@link EmergencyNumber#EMERGENCY_NUMBER_SOURCE_NETWORK_SIGNALING} >\n     * {@link EmergencyNumber#EMERGENCY_NUMBER_SOURCE_SIM} >\n     * {@link EmergencyNumber#EMERGENCY_NUMBER_SOURCE_DATABASE} >\n     * {@link EmergencyNumber#EMERGENCY_NUMBER_SOURCE_DEFAULT} >\n     * {@link EmergencyNumber#EMERGENCY_NUMBER_SOURCE_MODEM_CONFIG}\n     *\n     * <p>The subscriptions which the returned list would be based on, are all the active\n     * subscriptions, no matter which subscription could be used to create TelephonyManager.\n     *\n     * <p>Requires permission {@link android.Manifest.permission#READ_PHONE_STATE} or the calling\n     * app has carrier privileges (see {@link #hasCarrierPrivileges}).\n     *\n     * @return Map including the keys as the active subscription IDs (Note: if there is no active\n     * subscription, the key is {@link SubscriptionManager#getDefaultSubscriptionId}) and the value\n     * as the list of {@link EmergencyNumber}; empty Map if this information is not available;\n     * or throw a SecurityException if the caller does not have the permission.\n     ",
    "links" : [ "android.telephony.emergency.EmergencyNumber#EMERGENCY_NUMBER_SOURCE_DATABASE", "android.telephony.emergency.EmergencyNumber#EMERGENCY_NUMBER_SOURCE_DEFAULT", "android.telephony.emergency.EmergencyNumber#EMERGENCY_NUMBER_SOURCE_SIM", "android.telephony.emergency.EmergencyNumber#EMERGENCY_NUMBER_SOURCE_NETWORK_SIGNALING", "#hasCarrierPrivileges", "android.telephony.SubscriptionManager#getDefaultSubscriptionId", "android.Manifest.permission#READ_PHONE_STATE", "android.telephony.emergency.EmergencyNumber", "android.telephony.emergency.EmergencyNumber#EMERGENCY_NUMBER_SOURCE_MODEM_CONFIG" ]
  }, {
    "name" : "public Map<Integer, List<EmergencyNumber>> getEmergencyNumberList(@EmergencyServiceCategories int categories)",
    "returnType" : "Map<Integer, List<EmergencyNumber>>",
    "comment" : "\n     * Get the per-category emergency number list based on current locale, sim, default, modem\n     * and network.\n     *\n     * <p>In each returned list, the emergency number {@link EmergencyNumber} coming from higher\n     * priority sources will be located at the smaller index; the priority order of sources are:\n     * {@link EmergencyNumber#EMERGENCY_NUMBER_SOURCE_NETWORK_SIGNALING} >\n     * {@link EmergencyNumber#EMERGENCY_NUMBER_SOURCE_SIM} >\n     * {@link EmergencyNumber#EMERGENCY_NUMBER_SOURCE_DATABASE} >\n     * {@link EmergencyNumber#EMERGENCY_NUMBER_SOURCE_DEFAULT} >\n     * {@link EmergencyNumber#EMERGENCY_NUMBER_SOURCE_MODEM_CONFIG}\n     *\n     * <p>The subscriptions which the returned list would be based on, are all the active\n     * subscriptions, no matter which subscription could be used to create TelephonyManager.\n     *\n     * <p>Requires permission {@link android.Manifest.permission#READ_PHONE_STATE} or the calling\n     * app has carrier privileges (see {@link #hasCarrierPrivileges}).\n     *\n     * @param categories the emergency service categories which are the bitwise-OR combination of\n     * the following constants:\n     * <ol>\n     * <li>{@link EmergencyNumber#EMERGENCY_SERVICE_CATEGORY_UNSPECIFIED} </li>\n     * <li>{@link EmergencyNumber#EMERGENCY_SERVICE_CATEGORY_POLICE} </li>\n     * <li>{@link EmergencyNumber#EMERGENCY_SERVICE_CATEGORY_AMBULANCE} </li>\n     * <li>{@link EmergencyNumber#EMERGENCY_SERVICE_CATEGORY_FIRE_BRIGADE} </li>\n     * <li>{@link EmergencyNumber#EMERGENCY_SERVICE_CATEGORY_MARINE_GUARD} </li>\n     * <li>{@link EmergencyNumber#EMERGENCY_SERVICE_CATEGORY_MOUNTAIN_RESCUE} </li>\n     * <li>{@link EmergencyNumber#EMERGENCY_SERVICE_CATEGORY_MIEC} </li>\n     * <li>{@link EmergencyNumber#EMERGENCY_SERVICE_CATEGORY_AIEC} </li>\n     * </ol>\n     * @return Map including the keys as the active subscription IDs (Note: if there is no active\n     * subscription, the key is {@link SubscriptionManager#getDefaultSubscriptionId}) and the value\n     * as the list of {@link EmergencyNumber}; empty Map if this information is not available;\n     * or throw a SecurityException if the caller does not have the permission.\n     * @throws IllegalStateException if the Telephony process is not currently available.\n     ",
    "links" : [ "android.telephony.emergency.EmergencyNumber#EMERGENCY_NUMBER_SOURCE_DATABASE", "android.telephony.emergency.EmergencyNumber#EMERGENCY_SERVICE_CATEGORY_MIEC", "android.telephony.emergency.EmergencyNumber#EMERGENCY_NUMBER_SOURCE_DEFAULT", "android.telephony.emergency.EmergencyNumber#EMERGENCY_SERVICE_CATEGORY_POLICE", "android.telephony.emergency.EmergencyNumber#EMERGENCY_SERVICE_CATEGORY_MARINE_GUARD", "android.telephony.emergency.EmergencyNumber#EMERGENCY_SERVICE_CATEGORY_FIRE_BRIGADE", "android.telephony.emergency.EmergencyNumber", "android.telephony.emergency.EmergencyNumber#EMERGENCY_NUMBER_SOURCE_MODEM_CONFIG", "android.telephony.emergency.EmergencyNumber#EMERGENCY_SERVICE_CATEGORY_UNSPECIFIED", "android.telephony.emergency.EmergencyNumber#EMERGENCY_SERVICE_CATEGORY_AMBULANCE", "android.telephony.emergency.EmergencyNumber#EMERGENCY_SERVICE_CATEGORY_AIEC", "android.telephony.emergency.EmergencyNumber#EMERGENCY_SERVICE_CATEGORY_MOUNTAIN_RESCUE", "android.telephony.emergency.EmergencyNumber#EMERGENCY_NUMBER_SOURCE_SIM", "android.telephony.emergency.EmergencyNumber#EMERGENCY_NUMBER_SOURCE_NETWORK_SIGNALING", "#hasCarrierPrivileges", "android.telephony.SubscriptionManager#getDefaultSubscriptionId", "android.Manifest.permission#READ_PHONE_STATE" ]
  }, {
    "name" : "public boolean isEmergencyNumber(@NonNull String number)",
    "returnType" : "boolean",
    "comment" : "\n     * Identifies if the supplied phone number is an emergency number that matches a known\n     * emergency number based on current locale, SIM card(s), Android database, modem, network,\n     * or defaults.\n     *\n     * <p>This method assumes that only dialable phone numbers are passed in; non-dialable\n     * numbers are not considered emergency numbers. A dialable phone number consists only\n     * of characters/digits identified by {@link PhoneNumberUtils#isDialable(char)}.\n     *\n     * <p>The subscriptions which the identification would be based on, are all the active\n     * subscriptions, no matter which subscription could be used to create TelephonyManager.\n     *\n     * @param number - the number to look up\n     * @return {@code true} if the given number is an emergency number based on current locale,\n     * SIM card(s), Android database, modem, network or defaults; {@code false} otherwise.\n     * @throws IllegalStateException if the Telephony process is not currently available.\n     ",
    "links" : [ "android.telephony.PhoneNumberUtils#isDialable(char)" ]
  }, {
    "name" : "public boolean isPotentialEmergencyNumber(@NonNull String number)",
    "returnType" : "boolean",
    "comment" : "\n     * Checks if the supplied number is an emergency number based on current locale, sim, default,\n     * modem and network.\n     *\n     * <p> Specifically, this method will return {@code true} if the specified number is an\n     * emergency number, *or* if the number simply starts with the same digits as any current\n     * emergency number.\n     *\n     * <p>The subscriptions which the identification would be based on, are all the active\n     * subscriptions, no matter which subscription could be used to create TelephonyManager.\n     *\n     * <p>Requires permission: {@link android.Manifest.permission#READ_PRIVILEGED_PHONE_STATE} or\n     * that the calling app has carrier privileges (see {@link #hasCarrierPrivileges}).\n     *\n     * @param number - the number to look up\n     * @return {@code true} if the given number is an emergency number or it simply starts with\n     * the same digits of any current emergency number based on current locale, sim, modem and\n     * network; {@code false} if it is not; or throw an SecurityException if the caller does not\n     * have the required permission/privileges\n     * @throws IllegalStateException if the Telephony process is not currently available.\n     * @hide\n     ",
    "links" : [ "#hasCarrierPrivileges", "android.Manifest.permission#READ_PRIVILEGED_PHONE_STATE" ]
  }, {
    "name" : "public int getEmergencyNumberDbVersion()",
    "returnType" : "int",
    "comment" : "\n     * Returns the emergency number database version.\n     *\n     * <p>Requires Permission:\n     *   {@link android.Manifest.permission#READ_PRIVILEGED_PHONE_STATE READ_PRIVILEGED_PHONE_STATE}\n     *\n     * @hide\n     ",
    "links" : [ "android.Manifest.permission#READ_PRIVILEGED_PHONE_STATE" ]
  }, {
    "name" : "public void setPreferredOpportunisticDataSubscription(int subId, boolean needValidation, @Nullable @CallbackExecutor Executor executor, @Nullable Consumer<Integer> callback)",
    "returnType" : "void",
    "comment" : "\n     * Set preferred opportunistic data subscription id.\n     *\n     * Switch internet data to preferred opportunistic data subscription id. This api\n     * can result in lose of internet connectivity for short period of time while internet data\n     * is handed over.\n     * <p>Requires that the calling app has carrier privileges on both primary and\n     * secondary subscriptions (see\n     * {@link #hasCarrierPrivileges}), or has permission\n     * {@link android.Manifest.permission#MODIFY_PHONE_STATE MODIFY_PHONE_STATE}.\n     *\n     * @param subId which opportunistic subscription\n     * {@link SubscriptionManager#getOpportunisticSubscriptions} is preferred for cellular data.\n     * Pass {@link SubscriptionManager#DEFAULT_SUBSCRIPTION_ID} to unset the preference\n     * @param needValidation whether validation is needed before switch happens.\n     * @param executor The executor of where the callback will execute.\n     * @param callback Callback will be triggered once it succeeds or failed.\n     *                 See {@link TelephonyManager.SetOpportunisticSubscriptionResult}\n     *                 for more details. Pass null if don't care about the result.\n     ",
    "links" : [ "TelephonyManager.SetOpportunisticSubscriptionResult", "#hasCarrierPrivileges", "android.telephony.SubscriptionManager#DEFAULT_SUBSCRIPTION_ID", "android.Manifest.permission#MODIFY_PHONE_STATE", "android.telephony.SubscriptionManager#getOpportunisticSubscriptions" ]
  }, {
    "name" : "public int getPreferredOpportunisticDataSubscription()",
    "returnType" : "int",
    "comment" : "\n     * Get preferred opportunistic data subscription Id\n     *\n     * <p>Requires that the calling app has carrier privileges (see {@link #hasCarrierPrivileges}),\n     * or has either READ_PRIVILEGED_PHONE_STATE\n     * or {@link android.Manifest.permission#READ_PHONE_STATE READ_PHONE_STATE} permission.\n     * @return subId preferred opportunistic subscription id or\n     * {@link SubscriptionManager#DEFAULT_SUBSCRIPTION_ID} if there are no preferred\n     * subscription id\n     *\n     ",
    "links" : [ "#hasCarrierPrivileges", "android.telephony.SubscriptionManager#DEFAULT_SUBSCRIPTION_ID", "android.Manifest.permission#READ_PHONE_STATE" ]
  }, {
    "name" : "public void updateAvailableNetworks(@NonNull List<AvailableNetworkInfo> availableNetworks, @Nullable @CallbackExecutor Executor executor, @UpdateAvailableNetworksResult @Nullable Consumer<Integer> callback)",
    "returnType" : "void",
    "comment" : "\n     * Update availability of a list of networks in the current location.\n     *\n     * This api should be called to inform OpportunisticNetwork Service about the availability\n     * of a network at the current location. This information will be used by OpportunisticNetwork\n     * service to enable modem stack and to attach to the network. If an empty list is passed,\n     * it is assumed that no network is available and will result in disabling the modem stack\n     * to save power. This api do not switch internet data once network attach is completed.\n     * Use {@link TelephonyManager#setPreferredOpportunisticDataSubscription}\n     * to switch internet data after network attach is complete.\n     * Requires that the calling app has carrier privileges on both primary and\n     * secondary subscriptions (see {@link #hasCarrierPrivileges}), or has permission\n     * {@link android.Manifest.permission#MODIFY_PHONE_STATE MODIFY_PHONE_STATE}.\n     * @param availableNetworks is a list of available network information.\n     * @param executor The executor of where the callback will execute.\n     * @param callback Callback will be triggered once it succeeds or failed.\n     *\n     ",
    "links" : [ "android.telephony.TelephonyManager#setPreferredOpportunisticDataSubscription", "#hasCarrierPrivileges", "android.Manifest.permission#MODIFY_PHONE_STATE" ]
  }, {
    "name" : "public boolean enableModemForSlot(int slotIndex, boolean enable)",
    "returnType" : "boolean",
    "comment" : "\n     * Enable or disable a logical modem stack. When a logical modem is disabled, the corresponding\n     * SIM will still be visible to the user but its mapping modem will not have any radio activity.\n     * For example, we will disable a modem when user or system believes the corresponding SIM\n     * is temporarily not needed (e.g. out of coverage), and will enable it back on when needed.\n     *\n     * Requires that the calling app has permission\n     * {@link android.Manifest.permission#MODIFY_PHONE_STATE MODIFY_PHONE_STATE}.\n     * @param slotIndex which corresponding modem will operate on.\n     * @param enable whether to enable or disable the modem stack.\n     * @return whether the operation is successful.\n     *\n     * @hide\n     ",
    "links" : [ "android.Manifest.permission#MODIFY_PHONE_STATE" ]
  }, {
    "name" : "public boolean isModemEnabledForSlot(int slotIndex)",
    "returnType" : "boolean",
    "comment" : "\n     * It indicates whether modem is enabled or not per slot.\n     * It's the corresponding status of TelephonyManager.enableModemForSlot.\n     *\n     * <p>Requires Permission:\n     * READ_PRIVILEGED_PHONE_STATE or\n     * {@link android.Manifest.permission#READ_PHONE_STATE READ_PHONE_STATE}\n     * @param slotIndex which slot it's checking.\n     ",
    "links" : [ "android.Manifest.permission#READ_PHONE_STATE" ]
  }, {
    "name" : "public void setMultiSimCarrierRestriction(boolean isMultiSimCarrierRestricted)",
    "returnType" : "void",
    "comment" : "\n     * Indicate if the user is allowed to use multiple SIM cards at the same time to register\n     * on the network (e.g. Dual Standby or Dual Active) when the device supports it, or if the\n     * usage is restricted. This API is used to prevent usage of multiple SIM card, based on\n     * policies of the carrier.\n     * <p>Note: the API does not prevent access to the SIM cards for operations that don't require\n     * access to the network.\n     *\n     * @param isMultiSimCarrierRestricted true if usage of multiple SIMs is restricted, false\n     * otherwise.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public int isMultiSimSupported()",
    "returnType" : "int",
    "comment" : "\n     * Returns if the usage of multiple SIM cards at the same time to register on the network\n     * (e.g. Dual Standby or Dual Active) is supported by the device and by the carrier.\n     *\n     * <p>Requires Permission: {@link android.Manifest.permission#READ_PHONE_STATE READ_PHONE_STATE}\n     * or that the calling app has carrier privileges (see {@link #hasCarrierPrivileges}).\n     *\n     * @return {@link #MULTISIM_ALLOWED} if the device supports multiple SIMs.\n     * {@link #MULTISIM_NOT_SUPPORTED_BY_HARDWARE} if the device does not support multiple SIMs.\n     * {@link #MULTISIM_NOT_SUPPORTED_BY_CARRIER} in the device supports multiple SIMs, but the\n     * functionality is restricted by the carrier.\n     ",
    "links" : [ "#MULTISIM_NOT_SUPPORTED_BY_HARDWARE", "#MULTISIM_NOT_SUPPORTED_BY_CARRIER", "#hasCarrierPrivileges", "android.Manifest.permission#READ_PHONE_STATE", "#MULTISIM_ALLOWED" ]
  }, {
    "name" : "public void switchMultiSimConfig(int numOfSims)",
    "returnType" : "void",
    "comment" : "\n     * Switch configs to enable multi-sim or switch back to single-sim\n     * <p>Requires Permission:\n     * {@link android.Manifest.permission#MODIFY_PHONE_STATE MODIFY_PHONE_STATE} or that the\n     * calling app has carrier privileges (see {@link #hasCarrierPrivileges}).\n     *\n     * Note: with only carrier privileges, it is not allowed to switch from multi-sim\n     * to single-sim\n     *\n     * @param numOfSims number of live SIMs we want to switch to\n     * @throws android.os.RemoteException\n     ",
    "links" : [ "#hasCarrierPrivileges", "android.Manifest.permission#MODIFY_PHONE_STATE" ]
  }, {
    "name" : "public boolean doesSwitchMultiSimConfigTriggerReboot()",
    "returnType" : "boolean",
    "comment" : "\n     * Get whether making changes to modem configurations by {@link #switchMultiSimConfig(int)} will\n     * trigger device reboot.\n     * The modem configuration change refers to switching from single SIM configuration to DSDS\n     * or the other way around.\n     *\n     *  <p>Requires Permission:\n     * {@link android.Manifest.permission#READ_PHONE_STATE READ_PHONE_STATE} or that the\n     * calling app has carrier privileges (see {@link #hasCarrierPrivileges}).\n     *\n     * @return {@code true} if reboot will be triggered after making changes to modem\n     * configurations, otherwise return {@code false}.\n     ",
    "links" : [ "#hasCarrierPrivileges", "#switchMultiSimConfig(int)", "android.Manifest.permission#READ_PHONE_STATE" ]
  }, {
    "name" : "public Pair<Integer, Integer> getRadioHalVersion()",
    "returnType" : "Pair<Integer, Integer>",
    "comment" : "\n     * Retrieve the Radio HAL Version for this device.\n     *\n     * Get the HAL version for the IRadio interface for test purposes.\n     *\n     * @return a Pair of (major version, minor version) or (-1,-1) if unknown.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public int getCarrierPrivilegeStatus(int uid)",
    "returnType" : "int",
    "comment" : "\n     * Get the calling application status about carrier privileges for the subscription created\n     * in TelephonyManager. Used by Telephony Module for permission checking.\n     *\n     * @param uid Uid to check.\n     * @return any value of {@link #CARRIER_PRIVILEGE_STATUS_HAS_ACCESS},\n     *         {@link #CARRIER_PRIVILEGE_STATUS_NO_ACCESS},\n     *         {@link #CARRIER_PRIVILEGE_STATUS_RULES_NOT_LOADED}, or\n     *         {@link #CARRIER_PRIVILEGE_STATUS_ERROR_LOADING_RULES}\n     *\n     * @hide\n     ",
    "links" : [ "#CARRIER_PRIVILEGE_STATUS_NO_ACCESS", "#CARRIER_PRIVILEGE_STATUS_HAS_ACCESS", "#CARRIER_PRIVILEGE_STATUS_ERROR_LOADING_RULES", "#CARRIER_PRIVILEGE_STATUS_RULES_NOT_LOADED" ]
  }, {
    "name" : "public List<ApnSetting> getDevicePolicyOverrideApns(@NonNull Context context)",
    "returnType" : "List<ApnSetting>",
    "comment" : "\n     * Returns a list of APNs set as overrides by the device policy manager via\n     * {@link #addDevicePolicyOverrideApn}.\n     * This method must only be called from the system or phone processes.\n     *\n     * @param context Context to use.\n     * @return {@link List} of APNs that have been set as overrides.\n     * @throws {@link SecurityException} if the caller is not the system or phone process.\n     * @hide\n     ",
    "links" : [ "SecurityException", "#addDevicePolicyOverrideApn", "java.util.ArrayList" ]
  }, {
    "name" : "public int addDevicePolicyOverrideApn(@NonNull Context context, @NonNull ApnSetting apnSetting)",
    "returnType" : "int",
    "comment" : "\n     * Used by the device policy manager to add a new override APN.\n     * This method must only be called from the system or phone processes.\n     *\n     * @param context Context to use.\n     * @param apnSetting The {@link ApnSetting} describing the new APN.\n     * @return An integer, corresponding to a primary key in a database, that allows the caller to\n     *         modify the APN in the future via {@link #modifyDevicePolicyOverrideApn}, or\n     *         {@link android.provider.Telephony.Carriers.INVALID_APN_ID} if the override operation\n     *         failed.\n     * @throws {@link SecurityException} if the caller is not the system or phone process.\n     * @hide\n     ",
    "links" : [ "android.telephony.data.ApnSetting", "android.provider.Telephony.Carriers.INVALID_APN_ID", "#modifyDevicePolicyOverrideApn", "SecurityException" ]
  }, {
    "name" : "public boolean modifyDevicePolicyOverrideApn(@NonNull Context context, int apnId, @NonNull ApnSetting apnSetting)",
    "returnType" : "boolean",
    "comment" : "\n     * Used by the device policy manager to modify an override APN.\n     * This method must only be called from the system or phone processes.\n     *\n     * @param context Context to use.\n     * @param apnId The integer key of the APN to modify, as returned by\n     *              {@link #addDevicePolicyOverrideApn}\n     * @param apnSetting The {@link ApnSetting} describing the updated APN.\n     * @return {@code true} if successful, {@code false} otherwise.\n     * @throws {@link SecurityException} if the caller is not the system or phone process.\n     * @hide\n     ",
    "links" : [ "android.telephony.data.ApnSetting", "SecurityException", "#addDevicePolicyOverrideApn" ]
  }, {
    "name" : "public boolean isDataEnabledForApn(@ApnType int apnType)",
    "returnType" : "boolean",
    "comment" : "\n     * Return whether data is enabled for certain APN type. This will tell if framework will accept\n     * corresponding network requests on a subId.\n     *\n     * {@link #isDataEnabled()} is directly associated with users' Mobile data toggle on / off. If\n     * {@link #isDataEnabled()} returns false, it means in general all meter-ed data are disabled.\n     *\n     * This per APN type API gives a better idea whether data is allowed on a specific APN type.\n     * It will return true if:\n     *\n     *  1) User data is turned on, or\n     *  2) APN is un-metered for this subscription, or\n     *  3) APN type is whitelisted. E.g. MMS is whitelisted if\n     *  {@link #setAlwaysAllowMmsData(boolean)} is turned on.\n     *\n     * @param apnType Value indicating the apn type. Apn types are defined in {@link ApnSetting}.\n     * @return whether data is enabled for a apn type.\n     *\n     * @hide\n     ",
    "links" : [ "android.telephony.data.ApnSetting", "#isDataEnabled()", "#setAlwaysAllowMmsData(boolean)" ]
  }, {
    "name" : "public boolean isApnMetered(@ApnType int apnType)",
    "returnType" : "boolean",
    "comment" : "\n     * Whether an APN type is metered or not. It will be evaluated with the subId associated\n     * with the TelephonyManager instance.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public void setSystemSelectionChannels(@NonNull List<RadioAccessSpecifier> specifiers, @NonNull @CallbackExecutor Executor executor, @NonNull Consumer<Boolean> callback)",
    "returnType" : "void",
    "comment" : "\n     * Specify which bands modem's background scan must act on.\n     * If {@code specifiers} is non-empty, the scan will be restricted to the bands specified.\n     * Otherwise, it scans all bands.\n     *\n     * For example, CBRS is only on LTE band 48. By specifying this band,\n     * modem saves more power.\n     *\n     * @param specifiers which bands to scan.\n     * @param executor The executor to execute the callback on\n     * @param callback The callback that gets invoked when the radio responds to the request. Called\n     *                 with {@code true} if the request succeeded, {@code false} otherwise.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public void setSystemSelectionChannels(@NonNull List<RadioAccessSpecifier> specifiers)",
    "returnType" : "void",
    "comment" : "\n     * Same as {@link #setSystemSelectionChannels(List, Executor, Consumer<Boolean>)}, but to be\n     * used when the caller does not need feedback on the results of the operation.\n     * @param specifiers which bands to scan.\n     * @hide\n     ",
    "links" : [ "#setSystemSelectionChannels(List" ]
  }, {
    "name" : "private void setSystemSelectionChannelsInternal(@NonNull List<RadioAccessSpecifier> specifiers, @Nullable @CallbackExecutor Executor executor, @Nullable Consumer<Boolean> callback)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public boolean matchesCurrentSimOperator(@NonNull String mccmnc, @MvnoType int mvnoType, @Nullable String mvnoMatchData)",
    "returnType" : "boolean",
    "comment" : "\n     * Verifies whether the input MCC/MNC and MVNO correspond to the current carrier.\n     *\n     * @param mccmnc the carrier's mccmnc that you want to match\n     * @param mvnoType the mvnoType that defined in {@link ApnSetting}\n     * @param mvnoMatchData the MVNO match data\n     * @return {@code true} if input mccmnc and mvno matches with data from sim operator.\n     * {@code false} otherwise.\n     *\n     * {@hide}\n     ",
    "links" : [ "android.telephony.data.ApnSetting" ]
  }, {
    "name" : "public CallForwardingInfo getCallForwarding(@CallForwardingReason int callForwardingReason)",
    "returnType" : "CallForwardingInfo",
    "comment" : "\n     * Gets the voice call forwarding info {@link CallForwardingInfo}, given the call forward\n     * reason.\n     *\n     * @param callForwardingReason the call forwarding reasons\n     *\n     * @throws IllegalArgumentException if callForwardingReason is not any of\n     * {@link CallForwardingInfo.REASON_UNCONDITIONAL}, {@link CallForwardingInfo.REASON_BUSY},\n     * {@link CallForwardingInfo.REASON_NO_REPLY}, {@link CallForwardingInfo.REASON_NOT_REACHABLE},\n     * {@link CallForwardingInfo.REASON_ALL}, {@link CallForwardingInfo.REASON_ALL_CONDITIONAL}\n     *\n     * @return {@link CallForwardingInfo} with the status {@link CallForwardingInfo#STATUS_ACTIVE}\n     * or {@link CallForwardingInfo#STATUS_INACTIVE} and the target phone number to forward calls\n     * to, if it's available. Otherwise, it will return a {@link CallForwardingInfo} with status\n     * {@link CallForwardingInfo#STATUS_UNKNOWN_ERROR},\n     * {@link CallForwardingInfo#STATUS_NOT_SUPPORTED},\n     * or {@link CallForwardingInfo#STATUS_FDN_CHECK_FAILURE} depending on the situation.\n     *\n     * @hide\n     ",
    "links" : [ "CallForwardingInfo.REASON_NO_REPLY", "CallForwardingInfo.REASON_ALL", "android.telephony.CallForwardingInfo#STATUS_UNKNOWN_ERROR", "android.telephony.CallForwardingInfo#STATUS_ACTIVE", "android.telephony.CallForwardingInfo#STATUS_INACTIVE", "CallForwardingInfo.REASON_BUSY", "CallForwardingInfo.REASON_NOT_REACHABLE", "android.telephony.CallForwardingInfo#STATUS_FDN_CHECK_FAILURE", "CallForwardingInfo.REASON_UNCONDITIONAL", "android.telephony.CallForwardingInfo", "android.telephony.CallForwardingInfo#STATUS_NOT_SUPPORTED", "CallForwardingInfo.REASON_ALL_CONDITIONAL" ]
  }, {
    "name" : "public boolean setCallForwarding(@NonNull CallForwardingInfo callForwardingInfo)",
    "returnType" : "boolean",
    "comment" : "\n     * Sets the voice call forwarding info including status (enable/disable), call forwarding\n     * reason, the number to forward, and the timeout before the forwarding is attempted.\n     *\n     * @param callForwardingInfo {@link CallForwardingInfo} to setup the call forwarding.\n     * Enabling if {@link CallForwardingInfo#getStatus()} returns\n     * {@link CallForwardingInfo#STATUS_ACTIVE}; Disabling if\n     * {@link CallForwardingInfo#getStatus()} returns {@link CallForwardingInfo#STATUS_INACTIVE}.\n     *\n     * @throws IllegalArgumentException if any of the following for parameter callForwardingInfo:\n     * 0) it is {@code null}.\n     * 1) {@link CallForwardingInfo#getStatus()} returns neither\n     * {@link CallForwardingInfo#STATUS_ACTIVE} nor {@link CallForwardingInfo#STATUS_INACTIVE}.\n     * 2) {@link CallForwardingInfo#getReason()} is not any of\n     * {@link CallForwardingInfo.REASON_UNCONDITIONAL}, {@link CallForwardingInfo.REASON_BUSY},\n     * {@link CallForwardingInfo.REASON_NO_REPLY}, {@link CallForwardingInfo.REASON_NOT_REACHABLE},\n     * {@link CallForwardingInfo.REASON_ALL}, {@link CallForwardingInfo.REASON_ALL_CONDITIONAL}\n     * 3) {@link CallForwardingInfo#getNumber()} returns {@code null}.\n     * 4) {@link CallForwardingInfo#getTimeoutSeconds()} doesn't return a positive value.\n     *\n     * @return {@code true} to indicate it was set successfully; {@code false} otherwise.\n     *\n     * @hide\n     ",
    "links" : [ "CallForwardingInfo.REASON_BUSY", "CallForwardingInfo.REASON_UNCONDITIONAL", "android.telephony.CallForwardingInfo", "CallForwardingInfo.REASON_ALL_CONDITIONAL", "CallForwardingInfo.REASON_NO_REPLY", "CallForwardingInfo.REASON_ALL", "android.telephony.CallForwardingInfo#STATUS_ACTIVE", "android.telephony.CallForwardingInfo#STATUS_INACTIVE", "android.telephony.CallForwardingInfo#getTimeoutSeconds()", "android.telephony.CallForwardingInfo#getStatus()", "CallForwardingInfo.REASON_NOT_REACHABLE", "android.telephony.CallForwardingInfo#getNumber()", "android.telephony.CallForwardingInfo#getReason()" ]
  }, {
    "name" : "public int getCallWaitingStatus()",
    "returnType" : "int",
    "comment" : "\n     * Gets the status of voice call waiting function. Call waiting function enables the waiting\n     * for the incoming call when it reaches the user who is busy to make another call and allows\n     * users to decide whether to switch to the incoming call.\n     *\n     * @return the status of call waiting function.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean setCallWaitingStatus(boolean isEnable)",
    "returnType" : "boolean",
    "comment" : "\n     * Sets the status for voice call waiting function. Call waiting function enables the waiting\n     * for the incoming call when it reaches the user who is busy to make another call and allows\n     * users to decide whether to switch to the incoming call.\n     *\n     * @param isEnable {@code true} to enable; {@code false} to disable.\n     * @return {@code true} to indicate it was set successfully; {@code false} otherwise.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean setDataAllowedDuringVoiceCall(boolean allow)",
    "returnType" : "boolean",
    "comment" : "\n     * Set allowing mobile data during voice call. This is used for allowing data on the non-default\n     * data SIM. When a voice call is placed on the non-default data SIM on DSDS devices, users will\n     * not be able to use mobile data. By calling this API, data will be temporarily enabled on the\n     * non-default data SIM during the life cycle of the voice call.\n     *\n     * @param allow {@code true} if allowing using data during voice call, {@code false} if\n     * disallowed.\n     *\n     * @return {@code true} if operation is successful. otherwise {@code false}.\n     *\n     * @throws SecurityException if the caller doesn't have the permission.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean isDataAllowedInVoiceCall()",
    "returnType" : "boolean",
    "comment" : "\n     * Check whether data is allowed during voice call. This is used for allowing data on the\n     * non-default data SIM. When a voice call is placed on the non-default data SIM on DSDS\n     * devices, users will not be able to use mobile data. By calling this API, data will be\n     * temporarily enabled on the non-default data SIM during the life cycle of the voice call.\n     *\n     * @return {@code true} if data is allowed during voice call.\n     *\n     * @throws SecurityException if the caller doesn't have the permission.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean setAlwaysAllowMmsData(boolean alwaysAllow)",
    "returnType" : "boolean",
    "comment" : "\n     * Set whether the specific sim card always allows MMS connection. If true, MMS network\n     * request will be accepted by telephony even if user turns \"mobile data\" off\n     * on this specific sim card.\n     *\n     * @param alwaysAllow whether Mms data is always allowed.\n     * @return whether operation is successful.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean isIccLockEnabled()",
    "returnType" : "boolean",
    "comment" : "\n     * Check whether ICC pin lock is enabled.\n     * This is a sync call which returns the cached pin enabled state.\n     *\n     * @return {@code true} if ICC lock enabled, {@code false} if ICC lock disabled.\n     *\n     * @throws SecurityException if the caller doesn't have the permission.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public int setIccLockEnabled(boolean enabled, @NonNull String password)",
    "returnType" : "int",
    "comment" : "\n     * Set the ICC pin lock enabled or disabled.\n     *\n     * If enable/disable ICC pin lock successfully, a value of {@link Integer#MAX_VALUE} is\n     * returned.\n     * If an incorrect old password is specified, the return value will indicate how many more\n     * attempts the user can make to change the password before the SIM is locked.\n     * Using PUK code to unlock SIM if enter the incorrect old password 3 times.\n     *\n     * @param enabled    \"true\" for locked, \"false\" for unlocked.\n     * @param password   needed to change the ICC pin state, aka. Pin1\n     * @return an integer representing the status of IccLock enabled or disabled in the following\n     * three cases:\n     *   - {@link TelephonyManager#CHANGE_ICC_LOCK_SUCCESS} if enabled or disabled IccLock\n     *   successfully.\n     *   - Positive number and zero for remaining password attempts.\n     *   - Negative number for other failure cases (such like enabling/disabling PIN failed).\n     *\n     * @throws SecurityException if the caller doesn't have the permission.\n     *\n     * @hide\n     ",
    "links" : [ "#MAX_VALUE", "android.telephony.TelephonyManager#CHANGE_ICC_LOCK_SUCCESS" ]
  }, {
    "name" : "public int changeIccLockPassword(@NonNull String oldPassword, @NonNull String newPassword)",
    "returnType" : "int",
    "comment" : "\n     * Change the ICC password used in ICC pin lock.\n     *\n     * If the password was changed successfully, a value of {@link Integer#MAX_VALUE} is returned.\n     * If an incorrect old password is specified, the return value will indicate how many more\n     * attempts the user can make to change the password before the SIM is locked.\n     * Using PUK code to unlock SIM if enter the incorrect old password 3 times.\n     *\n     * @param oldPassword is the old password\n     * @param newPassword is the new password\n     * @return an integer representing the status of IccLock changed in the following three cases:\n     *   - {@link TelephonyManager#CHANGE_ICC_LOCK_SUCCESS} if changed IccLock successfully.\n     *   - Positive number and zero for remaining password attempts.\n     *   - Negative number for other failure cases (such like enabling/disabling PIN failed).\n     *\n     * @throws SecurityException if the caller doesn't have the permission.\n     *\n     * @hide\n     ",
    "links" : [ "#MAX_VALUE", "android.telephony.TelephonyManager#CHANGE_ICC_LOCK_SUCCESS" ]
  }, {
    "name" : "public void notifyUserActivity()",
    "returnType" : "void",
    "comment" : "\n     * Called when userActivity is signalled in the power manager.\n     * This should only be called from system Uid.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "private static void resetServiceCache()",
    "returnType" : "void",
    "comment" : "\n    * Reset everything in the service cache; if one handle died then they are\n    * all probably broken.\n    * @hide\n    ",
    "links" : [ ]
  }, {
    "name" : " static IPhoneSubInfo getSubscriberInfoService()",
    "returnType" : "IPhoneSubInfo",
    "comment" : "\n    * @hide\n    ",
    "links" : [ ]
  }, {
    "name" : " static ISub getSubscriptionService()",
    "returnType" : "ISub",
    "comment" : "\n    * @hide\n    ",
    "links" : [ ]
  }, {
    "name" : " static ISms getSmsService()",
    "returnType" : "ISms",
    "comment" : "\n    * @hide\n    ",
    "links" : [ ]
  }, {
    "name" : "public static void disableServiceHandleCaching()",
    "returnType" : "void",
    "comment" : "\n     * Disables service handle caching for tests that utilize mock services.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public static void enableServiceHandleCaching()",
    "returnType" : "void",
    "comment" : "\n     * Reenables service handle caching.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean canConnectTo5GInDsdsMode()",
    "returnType" : "boolean",
    "comment" : "\n     * Whether device can connect to 5G network when two SIMs are active.\n     * @hide\n     * TODO b/153669716: remove or make system API.\n     ",
    "links" : [ ]
  } ],
  "variableNames" : [ "TAG", "CALLBACK_ON_MORE_ERROR_CODE_CHANGE", "MODEM_ACTIVITY_RESULT_KEY", "PHONE_PROCESS_NAME", "NETWORK_SELECTION_MODE_UNKNOWN", "NETWORK_SELECTION_MODE_AUTO", "NETWORK_SELECTION_MODE_MANUAL", "OTASP_UNINITIALIZED", "OTASP_UNKNOWN", "OTASP_NEEDED", "OTASP_NOT_NEEDED", "OTASP_SIM_UNPROVISIONED", "KEY_TYPE_EPDG", "KEY_TYPE_WLAN", "SRVCC_STATE_HANDOVER_NONE", "SRVCC_STATE_HANDOVER_STARTED", "SRVCC_STATE_HANDOVER_COMPLETED", "SRVCC_STATE_HANDOVER_FAILED", "SRVCC_STATE_HANDOVER_CANCELED", "UNSUPPORTED_CARD_ID", "UNINITIALIZED_CARD_ID", "mContext", "mSubId", "mSubscriptionManager", "mTelephonyScanManager", "sCacheLock", "sServiceHandleCacheEnabled", "sIPhoneSubInfo", "sISub", "sISms", "sServiceDeath", "sInstance", "ACTION_PHONE_STATE_CHANGED", "ACTION_RESPOND_VIA_MESSAGE", "ACTION_EMERGENCY_ASSISTANCE", "METADATA_HIDE_VOICEMAIL_SETTINGS_MENU", "ACTION_CONFIGURE_VOICEMAIL", "EXTRA_HIDE_PUBLIC_SETTINGS", "EMERGENCY_ASSISTANCE_ENABLED", "EXTRA_STATE", "EXTRA_STATE_IDLE", "EXTRA_STATE_RINGING", "EXTRA_STATE_OFFHOOK", "EXTRA_INCOMING_NUMBER", "ACTION_CALL_DISCONNECT_CAUSE_CHANGED", "EXTRA_DISCONNECT_CAUSE", "EXTRA_PRECISE_DISCONNECT_CAUSE", "ACTION_SHOW_VOICEMAIL_NOTIFICATION", "EXTRA_PHONE_ACCOUNT_HANDLE", "EXTRA_NOTIFICATION_COUNT", "EXTRA_VOICEMAIL_NUMBER", "EXTRA_CALL_VOICEMAIL_INTENT", "EXTRA_LAUNCH_VOICEMAIL_SETTINGS_INTENT", "EXTRA_IS_REFRESH", "EVENT_HANDOVER_VIDEO_FROM_WIFI_TO_LTE", "EVENT_HANDOVER_VIDEO_FROM_LTE_TO_WIFI", "EVENT_HANDOVER_TO_WIFI_FAILED", "EVENT_DOWNGRADE_DATA_LIMIT_REACHED", "EVENT_DOWNGRADE_DATA_DISABLED", "EVENT_NOTIFY_INTERNATIONAL_CALL_ON_WFC", "EVENT_CALL_FORWARDED", "EVENT_SUPPLEMENTARY_SERVICE_NOTIFICATION", "EXTRA_NOTIFICATION_TYPE", "EXTRA_NOTIFICATION_CODE", "EXTRA_NOTIFICATION_MESSAGE", "VVM_TYPE_OMTP", "VVM_TYPE_CVVM", "EXTRA_VISUAL_VOICEMAIL_ENABLED_BY_USER_BOOL", "EXTRA_VOICEMAIL_SCRAMBLED_PIN_STRING", "ACTION_MULTI_SIM_CONFIG_CHANGED", "EXTRA_ACTIVE_SIM_SUPPORTED_COUNT", "USSD_RESPONSE", "USSD_RETURN_SUCCESS", "USSD_RETURN_FAILURE", "USSD_ERROR_SERVICE_UNAVAIL", "CDMA_ROAMING_MODE_RADIO_DEFAULT", "CDMA_ROAMING_MODE_HOME", "CDMA_ROAMING_MODE_AFFILIATED", "CDMA_ROAMING_MODE_ANY", "UNKNOWN_CARRIER_ID", "UNKNOWN_CARRIER_ID_LIST_VERSION", "ACTION_SUBSCRIPTION_CARRIER_IDENTITY_CHANGED", "EXTRA_CARRIER_ID", "EXTRA_CARRIER_NAME", "ACTION_SUBSCRIPTION_SPECIFIC_CARRIER_IDENTITY_CHANGED", "EXTRA_SPECIFIC_CARRIER_ID", "EXTRA_SPECIFIC_CARRIER_NAME", "EXTRA_SUBSCRIPTION_ID", "ACTION_SERVICE_PROVIDERS_UPDATED", "EXTRA_SHOW_PLMN", "EXTRA_PLMN", "EXTRA_SHOW_SPN", "EXTRA_SPN", "EXTRA_DATA_SPN", "ACTION_DATA_STALL_DETECTED", "ACTION_CARRIER_MESSAGING_CLIENT_SERVICE", "EXTRA_RECOVERY_ACTION", "MAX_NUMBER_VERIFICATION_TIMEOUT_MILLIS", "ACTION_ANOMALY_REPORTED", "EXTRA_ANOMALY_ID", "EXTRA_ANOMALY_DESCRIPTION", "ACTION_PRIMARY_SUBSCRIPTION_LIST_CHANGED", "EXTRA_DEFAULT_SUBSCRIPTION_SELECT_TYPE", "EXTRA_DEFAULT_SUBSCRIPTION_SELECT_TYPE_NONE", "EXTRA_DEFAULT_SUBSCRIPTION_SELECT_TYPE_DATA", "EXTRA_DEFAULT_SUBSCRIPTION_SELECT_TYPE_VOICE", "EXTRA_DEFAULT_SUBSCRIPTION_SELECT_TYPE_SMS", "EXTRA_DEFAULT_SUBSCRIPTION_SELECT_TYPE_ALL", "EXTRA_SIM_COMBINATION_WARNING_TYPE", "EXTRA_SIM_COMBINATION_WARNING_TYPE_NONE", "EXTRA_SIM_COMBINATION_WARNING_TYPE_DUAL_CDMA", "EXTRA_SIM_COMBINATION_NAMES", "ACTION_EMERGENCY_CALLBACK_MODE_CHANGED", "EXTRA_PHONE_IN_ECM_STATE", "ACTION_CARRIER_SIGNAL_REDIRECTED", "ACTION_CARRIER_SIGNAL_REQUEST_NETWORK_FAILED", "ACTION_CARRIER_SIGNAL_PCO_VALUE", "ACTION_CARRIER_SIGNAL_DEFAULT_NETWORK_AVAILABLE", "ACTION_CARRIER_SIGNAL_RESET", "EXTRA_REDIRECTION_URL", "EXTRA_ERROR_CODE", "EXTRA_APN_TYPE", "EXTRA_APN_TYPE_INT", "EXTRA_APN_PROTOCOL", "EXTRA_APN_PROTOCOL_INT", "EXTRA_PCO_ID", "EXTRA_PCO_VALUE", "EXTRA_DEFAULT_NETWORK_AVAILABLE", "ACTION_EMERGENCY_CALL_STATE_CHANGED", "EXTRA_PHONE_IN_EMERGENCY_CALL", "ACTION_SHOW_NOTICE_ECM_BLOCK_OTHERS", "ACTION_DEFAULT_DATA_SUBSCRIPTION_CHANGED", "ACTION_DEFAULT_VOICE_SUBSCRIPTION_CHANGED", "ACTION_REQUEST_OMADM_CONFIGURATION_UPDATE", "PHONE_TYPE_NONE", "PHONE_TYPE_GSM", "PHONE_TYPE_CDMA", "PHONE_TYPE_SIP", "PHONE_TYPE_IMS", "PHONE_TYPE_THIRD_PARTY", "sKernelCmdLine", "sProductTypePattern", "sLteOnCdmaProductType", "NETWORK_TYPE_UNKNOWN", "NETWORK_TYPE_GPRS", "NETWORK_TYPE_EDGE", "NETWORK_TYPE_UMTS", "NETWORK_TYPE_CDMA", "NETWORK_TYPE_EVDO_0", "NETWORK_TYPE_EVDO_A", "NETWORK_TYPE_1xRTT", "NETWORK_TYPE_HSDPA", "NETWORK_TYPE_HSUPA", "NETWORK_TYPE_HSPA", "NETWORK_TYPE_IDEN", "NETWORK_TYPE_EVDO_B", "NETWORK_TYPE_LTE", "NETWORK_TYPE_EHRPD", "NETWORK_TYPE_HSPAP", "NETWORK_TYPE_GSM", "NETWORK_TYPE_TD_SCDMA", "NETWORK_TYPE_IWLAN", "NETWORK_TYPE_LTE_CA", "NETWORK_TYPE_NR", "NETWORK_TYPES", "SIM_STATE_UNKNOWN", "SIM_STATE_ABSENT", "SIM_STATE_PIN_REQUIRED", "SIM_STATE_PUK_REQUIRED", "SIM_STATE_NETWORK_LOCKED", "SIM_STATE_READY", "SIM_STATE_NOT_READY", "SIM_STATE_PERM_DISABLED", "SIM_STATE_CARD_IO_ERROR", "SIM_STATE_CARD_RESTRICTED", "SIM_STATE_LOADED", "SIM_STATE_PRESENT", "EXTRA_SIM_STATE", "ACTION_SIM_CARD_STATE_CHANGED", "ACTION_SIM_APPLICATION_STATE_CHANGED", "ACTION_SIM_SLOT_STATUS_CHANGED", "ACTION_SECRET_CODE", "SIM_ACTIVATION_STATE_UNKNOWN", "SIM_ACTIVATION_STATE_ACTIVATING", "SIM_ACTIVATION_STATE_ACTIVATED", "SIM_ACTIVATION_STATE_DEACTIVATED", "SIM_ACTIVATION_STATE_RESTRICTED", "CALL_STATE_IDLE", "CALL_STATE_RINGING", "CALL_STATE_OFFHOOK", "DATA_ACTIVITY_NONE", "DATA_ACTIVITY_IN", "DATA_ACTIVITY_OUT", "DATA_ACTIVITY_INOUT", "DATA_ACTIVITY_DORMANT", "DATA_UNKNOWN", "DATA_DISCONNECTED", "DATA_CONNECTING", "DATA_CONNECTED", "DATA_SUSPENDED", "DATA_DISCONNECTING", "GET_DATA_STATE_R_VERSION", "APPTYPE_SIM", "APPTYPE_USIM", "APPTYPE_RUIM", "APPTYPE_CSIM", "APPTYPE_ISIM", "AUTHTYPE_EAP_SIM", "AUTHTYPE_EAP_AKA", "NETWORK_MODE_WCDMA_PREF", "NETWORK_MODE_GSM_ONLY", "NETWORK_MODE_WCDMA_ONLY", "NETWORK_MODE_GSM_UMTS", "NETWORK_MODE_CDMA_EVDO", "NETWORK_MODE_CDMA_NO_EVDO", "NETWORK_MODE_EVDO_NO_CDMA", "NETWORK_MODE_GLOBAL", "NETWORK_MODE_LTE_CDMA_EVDO", "NETWORK_MODE_LTE_GSM_WCDMA", "NETWORK_MODE_LTE_CDMA_EVDO_GSM_WCDMA", "NETWORK_MODE_LTE_ONLY", "NETWORK_MODE_LTE_WCDMA", "NETWORK_MODE_TDSCDMA_ONLY", "NETWORK_MODE_TDSCDMA_WCDMA", "NETWORK_MODE_LTE_TDSCDMA", "NETWORK_MODE_TDSCDMA_GSM", "NETWORK_MODE_LTE_TDSCDMA_GSM", "NETWORK_MODE_TDSCDMA_GSM_WCDMA", "NETWORK_MODE_LTE_TDSCDMA_WCDMA", "NETWORK_MODE_LTE_TDSCDMA_GSM_WCDMA", "NETWORK_MODE_TDSCDMA_CDMA_EVDO_GSM_WCDMA", "NETWORK_MODE_LTE_TDSCDMA_CDMA_EVDO_GSM_WCDMA", "NETWORK_MODE_NR_ONLY", "NETWORK_MODE_NR_LTE", "NETWORK_MODE_NR_LTE_CDMA_EVDO", "NETWORK_MODE_NR_LTE_GSM_WCDMA", "NETWORK_MODE_NR_LTE_CDMA_EVDO_GSM_WCDMA", "NETWORK_MODE_NR_LTE_WCDMA", "NETWORK_MODE_NR_LTE_TDSCDMA", "NETWORK_MODE_NR_LTE_TDSCDMA_GSM", "NETWORK_MODE_NR_LTE_TDSCDMA_WCDMA", "NETWORK_MODE_NR_LTE_TDSCDMA_GSM_WCDMA", "NETWORK_MODE_NR_LTE_TDSCDMA_CDMA_EVDO_GSM_WCDMA", "DEFAULT_PREFERRED_NETWORK_MODE", "ALLOWED_NETWORK_TYPES_REASON_POWER", "CARRIER_PRIVILEGE_STATUS_HAS_ACCESS", "CARRIER_PRIVILEGE_STATUS_NO_ACCESS", "CARRIER_PRIVILEGE_STATUS_RULES_NOT_LOADED", "CARRIER_PRIVILEGE_STATUS_ERROR_LOADING_RULES", "RADIO_POWER_OFF", "RADIO_POWER_ON", "RADIO_POWER_UNAVAILABLE", "CDMA_SUBSCRIPTION_UNKNOWN", "CDMA_SUBSCRIPTION_RUIM_SIM", "CDMA_SUBSCRIPTION_NV", "PREFERRED_CDMA_SUBSCRIPTION", "CARD_POWER_DOWN", "CARD_POWER_UP", "CARD_POWER_UP_PASS_THROUGH", "SET_CARRIER_RESTRICTION_SUCCESS", "SET_CARRIER_RESTRICTION_NOT_SUPPORTED", "SET_CARRIER_RESTRICTION_ERROR", "INDICATION_UPDATE_MODE_NORMAL", "INDICATION_UPDATE_MODE_IGNORE_SCREEN_OFF", "INDICATION_FILTER_SIGNAL_STRENGTH", "INDICATION_FILTER_FULL_NETWORK_STATE", "INDICATION_FILTER_DATA_CALL_DORMANCY_CHANGED", "INDICATION_FILTER_LINK_CAPACITY_ESTIMATE", "INDICATION_FILTER_PHYSICAL_CHANNEL_CONFIG", "NETWORK_TYPE_BITMASK_UNKNOWN", "NETWORK_TYPE_BITMASK_GSM", "NETWORK_TYPE_BITMASK_GPRS", "NETWORK_TYPE_BITMASK_EDGE", "NETWORK_TYPE_BITMASK_CDMA", "NETWORK_TYPE_BITMASK_1xRTT", "NETWORK_TYPE_BITMASK_EVDO_0", "NETWORK_TYPE_BITMASK_EVDO_A", "NETWORK_TYPE_BITMASK_EVDO_B", "NETWORK_TYPE_BITMASK_EHRPD", "NETWORK_TYPE_BITMASK_HSUPA", "NETWORK_TYPE_BITMASK_HSDPA", "NETWORK_TYPE_BITMASK_HSPA", "NETWORK_TYPE_BITMASK_HSPAP", "NETWORK_TYPE_BITMASK_UMTS", "NETWORK_TYPE_BITMASK_TD_SCDMA", "NETWORK_TYPE_BITMASK_LTE", "NETWORK_TYPE_BITMASK_LTE_CA", "NETWORK_TYPE_BITMASK_NR", "NETWORK_TYPE_BITMASK_IWLAN", "NETWORK_CLASS_BITMASK_2G", "NETWORK_CLASS_BITMASK_3G", "NETWORK_CLASS_BITMASK_4G", "NETWORK_CLASS_BITMASK_5G", "NETWORK_STANDARDS_FAMILY_BITMASK_3GPP", "NETWORK_STANDARDS_FAMILY_BITMASK_3GPP2", "INVALID_EMERGENCY_NUMBER_DB_VERSION", "SET_OPPORTUNISTIC_SUB_SUCCESS", "SET_OPPORTUNISTIC_SUB_VALIDATION_FAILED", "SET_OPPORTUNISTIC_SUB_INACTIVE_SUBSCRIPTION", "SET_OPPORTUNISTIC_SUB_NO_OPPORTUNISTIC_SUB_AVAILABLE", "SET_OPPORTUNISTIC_SUB_REMOTE_SERVICE_EXCEPTION", "UPDATE_AVAILABLE_NETWORKS_SUCCESS", "UPDATE_AVAILABLE_NETWORKS_UNKNOWN_FAILURE", "UPDATE_AVAILABLE_NETWORKS_ABORTED", "UPDATE_AVAILABLE_NETWORKS_INVALID_ARGUMENTS", "UPDATE_AVAILABLE_NETWORKS_NO_CARRIER_PRIVILEGE", "UPDATE_AVAILABLE_NETWORKS_DISABLE_MODEM_FAIL", "UPDATE_AVAILABLE_NETWORKS_ENABLE_MODEM_FAIL", "UPDATE_AVAILABLE_NETWORKS_MULTIPLE_NETWORKS_NOT_SUPPORTED", "UPDATE_AVAILABLE_NETWORKS_NO_OPPORTUNISTIC_SUB_AVAILABLE", "UPDATE_AVAILABLE_NETWORKS_REMOTE_SERVICE_EXCEPTION", "UPDATE_AVAILABLE_NETWORKS_SERVICE_IS_DISABLED", "ACTION_NETWORK_COUNTRY_CHANGED", "EXTRA_NETWORK_COUNTRY", "EXTRA_LAST_KNOWN_NETWORK_COUNTRY", "MULTISIM_ALLOWED", "MULTISIM_NOT_SUPPORTED_BY_HARDWARE", "MULTISIM_NOT_SUPPORTED_BY_CARRIER", "CALL_WAITING_STATUS_ACTIVE", "CALL_WAITING_STATUS_INACTIVE", "CALL_WAITING_STATUS_UNKNOWN_ERROR", "CALL_WAITING_STATUS_NOT_SUPPORTED", "CHANGE_ICC_LOCK_SUCCESS" ],
  "methodNames" : [ "public static TelephonyManager getDefault()", "private String getOpPackageName()", "private String getAttributionTag()", "private boolean isSystemProcess()", "public MultiSimVariants getMultiSimConfiguration()", "public int getPhoneCount()", "public int getActiveModemCount()", "public int getSupportedModemCount()", "public int getMaxNumberOfSimultaneouslyActiveSims()", "public static TelephonyManager from(Context context)", "public TelephonyManager createForSubscriptionId(int subId)", "public TelephonyManager createForPhoneAccountHandle(PhoneAccountHandle phoneAccountHandle)", "public boolean isMultiSimEnabled()", "public String getDeviceSoftwareVersion()", "public String getDeviceSoftwareVersion(int slotIndex)", "public String getDeviceId()", "public String getDeviceId(int slotIndex)", "public String getImei()", "public String getImei(int slotIndex)", "public String getTypeAllocationCode()", "public String getTypeAllocationCode(int slotIndex)", "public String getMeid()", "public String getMeid(int slotIndex)", "public String getManufacturerCode()", "public String getManufacturerCode(int slotIndex)", "public String getNai()", "public String getNai(int slotIndex)", "private String getNaiBySubscriberId(int subId)", "public CellLocation getCellLocation()", "public void enableLocationUpdates()", "public void enableLocationUpdates(int subId)", "public void disableLocationUpdates()", "public void disableLocationUpdates(int subId)", "public List<NeighboringCellInfo> getNeighboringCellInfo()", "public int getCurrentPhoneType()", "public int getCurrentPhoneType(int subId)", "public int getCurrentPhoneTypeForSlot(int slotIndex)", "public int getPhoneType()", "private int getPhoneTypeFromProperty()", "private int getPhoneTypeFromProperty(int phoneId)", "private int getPhoneTypeFromNetworkType()", "private int getPhoneTypeFromNetworkType(int phoneId)", "public static int getPhoneType(int networkMode)", "private static String getProcCmdLine()", "public static long getMaxNumberVerificationTimeoutMillis()", "public static int getLteOnCdmaModeStatic()", "public String getNetworkOperatorName()", "public String getNetworkOperatorName(int subId)", "public String getNetworkOperator()", "public String getNetworkOperator(int subId)", "public String getNetworkOperatorForPhone(int phoneId)", "public String getNetworkSpecifier()", "public PersistableBundle getCarrierConfig()", "public boolean isNetworkRoaming()", "public boolean isNetworkRoaming(int subId)", "public String getNetworkCountryIso()", "public String getNetworkCountryIso(int slotIndex)", "public String getNetworkCountryIsoForPhone(int phoneId)", "public static int[] getAllNetworkTypes()", "public int getNetworkType()", "public int getNetworkType(int subId)", "public int getDataNetworkType()", "public int getDataNetworkType(int subId)", "public int getVoiceNetworkType()", "public int getVoiceNetworkType(int subId)", "public String getNetworkTypeName()", "public static String getNetworkTypeName(@NetworkType int type)", "public static long getBitMaskForNetworkType(@NetworkType int networkType)", "public boolean hasIccCard()", "public boolean hasIccCard(int slotIndex)", "public int getSimState()", "private int getSimStateIncludingLoaded()", "public int getSimCardState()", "public int getSimCardState(int physicalSlotIndex)", "private int getSimCardStateFromSimState(int simState)", "private int getLogicalSlotIndex(int physicalSlotIndex)", "public int getSimApplicationState()", "public int getSimApplicationState(int physicalSlotIndex)", "private int getSimApplicationStateFromSimState(int simState)", "public boolean isApplicationOnUicc(@UiccAppType int appType)", "public int getSimState(int slotIndex)", "public String getSimOperator()", "public String getSimOperator(int subId)", "public String getSimOperatorNumeric()", "public String getSimOperatorNumeric(int subId)", "public String getSimOperatorNumericForPhone(int phoneId)", "public String getSimOperatorName()", "public String getSimOperatorName(int subId)", "public String getSimOperatorNameForPhone(int phoneId)", "public String getSimCountryIso()", "public static String getSimCountryIso(int subId)", "public static String getSimCountryIsoForPhone(int phoneId)", "public String getSimSerialNumber()", "public String getSimSerialNumber(int subId)", "public boolean isLteCdmaEvdoGsmWcdmaEnabled()", "public int getLteOnCdmaMode(int subId)", "public int getCardIdForDefaultEuicc()", "public List<UiccCardInfo> getUiccCardsInfo()", "public UiccSlotInfo[] getUiccSlotsInfo()", "public void refreshUiccProfile()", "public boolean switchSlots(int[] physicalSlots)", "public Map<Integer, Integer> getLogicalToPhysicalSlotMapping()", "public String getSubscriberId()", "public String getSubscriberId(int subId)", "public ImsiEncryptionInfo getCarrierInfoForImsiEncryption(@KeyType int keyType)", "public void resetCarrierKeysForImsiEncryption()", "private static boolean isKeyEnabled(int keyAvailability, @KeyType int keyType)", "private boolean isImsiEncryptionRequired(int subId, @KeyType int keyType)", "public void setCarrierInfoForImsiEncryption(ImsiEncryptionInfo imsiEncryptionInfo)", "public String getGroupIdLevel1()", "public String getGroupIdLevel1(int subId)", "public String getLine1Number()", "public String getLine1Number(int subId)", "public boolean setLine1NumberForDisplay(String alphaTag, String number)", "public boolean setLine1NumberForDisplay(int subId, String alphaTag, String number)", "public String getLine1AlphaTag()", "public String getLine1AlphaTag(int subId)", "public String[] getMergedSubscriberIds()", "public String[] getMergedImsisFromGroup()", "public String getMsisdn()", "public String getMsisdn(int subId)", "public String getVoiceMailNumber()", "public String getVoiceMailNumber(int subId)", "public boolean setVoiceMailNumber(String alphaTag, String number)", "public boolean setVoiceMailNumber(int subId, String alphaTag, String number)", "public void setVisualVoicemailEnabled(PhoneAccountHandle phoneAccountHandle, boolean enabled)", "public boolean isVisualVoicemailEnabled(PhoneAccountHandle phoneAccountHandle)", "public Bundle getVisualVoicemailSettings()", "public String getVisualVoicemailPackageName()", "public void setVisualVoicemailSmsFilterSettings(VisualVoicemailSmsFilterSettings settings)", "public void sendVisualVoicemailSms(String number, int port, String text, PendingIntent sentIntent)", "public void enableVisualVoicemailSmsFilter(int subId, VisualVoicemailSmsFilterSettings settings)", "public void disableVisualVoicemailSmsFilter(int subId)", "public VisualVoicemailSmsFilterSettings getVisualVoicemailSmsFilterSettings(int subId)", "public VisualVoicemailSmsFilterSettings getActiveVisualVoicemailSmsFilterSettings(int subId)", "public void sendVisualVoicemailSmsForSubscriber(int subId, String number, int port, String text, PendingIntent sentIntent)", "public void setVoiceActivationState(@SimActivationState int activationState)", "public void setVoiceActivationState(int subId, @SimActivationState int activationState)", "public void setDataActivationState(@SimActivationState int activationState)", "public void setDataActivationState(int subId, @SimActivationState int activationState)", "public int getVoiceActivationState()", "public int getVoiceActivationState(int subId)", "public int getDataActivationState()", "public int getDataActivationState(int subId)", "public int getVoiceMessageCount()", "public int getVoiceMessageCount(int subId)", "public String getVoiceMailAlphaTag()", "public String getVoiceMailAlphaTag(int subId)", "public void sendDialerSpecialCode(String inputCode)", "public String getIsimImpi()", "public String getIsimDomain()", "public String[] getIsimImpu()", "public int getCallState()", "public int getCallState(int subId)", "private IPhoneSubInfo getSubscriberInfo()", "public int getCallStateForSlot(int slotIndex)", "public int getDataActivity()", "public int getDataState()", "public static String dataStateToString(@DataState int state)", "private ITelephony getITelephony()", "private IOns getIOns()", "public void listen(PhoneStateListener listener, int events)", "public CdmaEriInformation getCdmaEriInformation()", "public int getCdmaEriIconIndex(int subId)", "public int getCdmaEriIconMode(int subId)", "public String getCdmaEriText()", "public String getCdmaEriText(int subId)", "public boolean isVoiceCapable()", "public boolean isSmsCapable()", "public List<CellInfo> getAllCellInfo()", "public void requestCellInfoUpdate(@NonNull @CallbackExecutor Executor executor, @NonNull CellInfoCallback callback)", "public void requestCellInfoUpdate(@NonNull WorkSource workSource, @NonNull @CallbackExecutor Executor executor, @NonNull CellInfoCallback callback)", "private static Throwable createThrowableByClassName(String className, String message)", "public void setCellInfoListRate(int rateInMillis)", "public String getMmsUserAgent()", "public String getMmsUAProfUrl()", "public IccOpenLogicalChannelResponse iccOpenLogicalChannel(String AID)", "public IccOpenLogicalChannelResponse iccOpenLogicalChannelBySlot(int slotIndex, @Nullable String aid, int p2)", "public IccOpenLogicalChannelResponse iccOpenLogicalChannel(String AID, int p2)", "public IccOpenLogicalChannelResponse iccOpenLogicalChannel(int subId, String AID, int p2)", "public boolean iccCloseLogicalChannelBySlot(int slotIndex, int channel)", "public boolean iccCloseLogicalChannel(int channel)", "public boolean iccCloseLogicalChannel(int subId, int channel)", "public String iccTransmitApduLogicalChannelBySlot(int slotIndex, int channel, int cla, int instruction, int p1, int p2, int p3, @Nullable String data)", "public String iccTransmitApduLogicalChannel(int channel, int cla, int instruction, int p1, int p2, int p3, String data)", "public String iccTransmitApduLogicalChannel(int subId, int channel, int cla, int instruction, int p1, int p2, int p3, String data)", "public String iccTransmitApduBasicChannelBySlot(int slotIndex, int cla, int instruction, int p1, int p2, int p3, @Nullable String data)", "public String iccTransmitApduBasicChannel(int cla, int instruction, int p1, int p2, int p3, String data)", "public String iccTransmitApduBasicChannel(int subId, int cla, int instruction, int p1, int p2, int p3, String data)", "public byte[] iccExchangeSimIO(int fileID, int command, int p1, int p2, int p3, String filePath)", "public byte[] iccExchangeSimIO(int subId, int fileID, int command, int p1, int p2, int p3, String filePath)", "public String sendEnvelopeWithStatus(String content)", "public String sendEnvelopeWithStatus(int subId, String content)", "public String nvReadItem(int itemID)", "public boolean nvWriteItem(int itemID, String itemValue)", "public boolean nvWriteCdmaPrl(byte[] preferredRoamingList)", "public boolean nvResetConfig(int resetType)", "public boolean resetRadioConfig()", "public boolean rebootRadio()", "public int getSubscriptionId()", "private int getSubId()", "private int getSubId(int preferredSubId)", "private int getPhoneId()", "private int getPhoneId(int preferredSubId)", "public int getSlotIndex()", "public void requestNumberVerification(@NonNull PhoneNumberRange range, long timeoutMillis, @NonNull @CallbackExecutor Executor executor, @NonNull NumberVerificationCallback callback)", "private static List<T> updateTelephonyProperty(List<T> prop, int phoneId, T value)", "public static int getIntAtIndex(android.content.ContentResolver cr, String name, int index) throws android.provider.Settings.SettingNotFoundException", "public static boolean putIntAtIndex(android.content.ContentResolver cr, String name, int index, int value)", "public static String getTelephonyProperty(int phoneId, String property, String defaultVal)", "private static T getTelephonyProperty(int phoneId, List<T> prop, T defaultValue)", "public static String getTelephonyProperty(String property, String defaultVal)", "public int getSimCount()", "public String getIsimIst()", "public String[] getIsimPcscf()", "public String getIccAuthentication(int appType, int authType, String data)", "public String getIccAuthentication(int subId, int appType, int authType, String data)", "public String[] getForbiddenPlmns()", "public String[] getForbiddenPlmns(int subId, int appType)", "public int setForbiddenPlmns(@NonNull List<String> fplmns)", "public String[] getPcscfAddress(String apnType)", "public void resetIms(int slotIndex)", "public void enableIms(int slotId)", "public void disableIms(int slotId)", "public IImsMmTelFeature getImsMmTelFeatureAndListen(int slotIndex, IImsServiceFeatureCallback callback)", "public IImsRcsFeature getImsRcsFeatureAndListen(int slotIndex, IImsServiceFeatureCallback callback)", "public void unregisterImsFeatureCallback(int slotIndex, int featureType, IImsServiceFeatureCallback callback)", "public IImsRegistration getImsRegistration(int slotIndex, int feature)", "public IImsConfig getImsConfig(int slotIndex, int feature)", "public void setImsRegistrationState(boolean registered)", "public int getPreferredNetworkType(int subId)", "public long getPreferredNetworkTypeBitmask()", "public long getAllowedNetworkTypes()", "public void setNetworkSelectionModeAutomatic()", "public CellNetworkScanResult getAvailableNetworks()", "public NetworkScan requestNetworkScan(NetworkScanRequest request, Executor executor, TelephonyScanManager.NetworkScanCallback callback)", "public NetworkScan requestNetworkScan(NetworkScanRequest request, TelephonyScanManager.NetworkScanCallback callback)", "public boolean setNetworkSelectionModeManual(String operatorNumeric, boolean persistSelection)", "public boolean setNetworkSelectionModeManual(@NonNull String operatorNumeric, boolean persistSelection, @AccessNetworkConstants.RadioAccessNetworkType int ran)", "public boolean setNetworkSelectionModeManual(OperatorInfo operatorInfo, boolean persistSelection)", "public int getNetworkSelectionMode()", "public String getManualNetworkSelectionPlmn()", "public boolean isInEmergencySmsMode()", "public boolean setPreferredNetworkType(int subId, @PrefNetworkMode int networkType)", "public boolean setPreferredNetworkTypeBitmask(@NetworkTypeBitMask long networkTypeBitmask)", "public boolean setAllowedNetworkTypes(@NetworkTypeBitMask long allowedNetworkTypes)", "public void setAllowedNetworkTypesForReason(@AllowedNetworkTypesReason int reason, @NetworkTypeBitMask long allowedNetworkTypes)", "public long getAllowedNetworkTypesForReason(@AllowedNetworkTypesReason int reason)", "public static long getAllNetworkTypesBitmask()", "public long getEffectiveAllowedNetworkTypes()", "public boolean setPreferredNetworkTypeToGlobal()", "public boolean setPreferredNetworkTypeToGlobal(int subId)", "public boolean isTetheringApnRequired()", "public boolean isTetheringApnRequired(int subId)", "public boolean hasCarrierPrivileges()", "public boolean hasCarrierPrivileges(int subId)", "public boolean setOperatorBrandOverride(String brand)", "public boolean setOperatorBrandOverride(int subId, String brand)", "public boolean setRoamingOverride(List<String> gsmRoamingList, List<String> gsmNonRoamingList, List<String> cdmaRoamingList, List<String> cdmaNonRoamingList)", "public boolean setRoamingOverride(int subId, List<String> gsmRoamingList, List<String> gsmNonRoamingList, List<String> cdmaRoamingList, List<String> cdmaNonRoamingList)", "public String getCdmaMdn()", "public String getCdmaMdn(int subId)", "public String getCdmaMin()", "public String getCdmaMin(int subId)", "public int checkCarrierPrivilegesForPackage(String pkgName)", "public int checkCarrierPrivilegesForPackageAnyPhone(String pkgName)", "public List<String> getCarrierPackageNamesForIntent(Intent intent)", "public List<String> getCarrierPackageNamesForIntentAndPhone(Intent intent, int phoneId)", "public List<String> getPackagesWithCarrierPrivileges()", "public List<String> getCarrierPrivilegedPackagesForAllActiveSubscriptions()", "public void dial(String number)", "public void call(String callingPackage, String number)", "public boolean endCall()", "public void answerRingingCall()", "public void silenceRinger()", "public boolean isOffhook()", "public boolean isRinging()", "public boolean isIdle()", "public boolean isRadioOn()", "public boolean supplyPin(String pin)", "public boolean supplyPuk(String puk, String pin)", "public int[] supplyPinReportResult(String pin)", "public int[] supplyPukReportResult(String puk, String pin)", "public PinResult supplyPinReportPinResult(@NonNull String pin)", "public PinResult supplyPukReportPinResult(@NonNull String puk, @NonNull String pin)", "public void sendUssdRequest(String ussdRequest, final UssdResponseCallback callback, Handler handler)", "public boolean isConcurrentVoiceAndDataSupported()", "public boolean handlePinMmi(String dialString)", "public boolean handlePinMmiForSubscriber(int subId, String dialString)", "public void toggleRadioOnOff()", "public boolean setRadio(boolean turnOn)", "public boolean setRadioPower(boolean turnOn)", "public void shutdownAllRadios()", "public boolean isAnyRadioPoweredOn()", "public int getRadioPowerState()", "public void updateServiceLocation()", "public boolean enableDataConnectivity()", "public boolean disableDataConnectivity()", "public boolean isDataConnectivityPossible()", "public boolean needsOtaServiceProvisioning()", "public void setDataEnabled(boolean enable)", "public void setDataEnabled(int subId, boolean enable)", "public boolean getDataEnabled()", "public boolean isDataEnabled()", "public boolean isDataRoamingEnabled()", "public int getCdmaRoamingMode()", "public boolean setCdmaRoamingMode(@CdmaRoamingMode int mode)", "public boolean setCdmaSubscriptionMode(@CdmaSubscription int mode)", "public void setDataRoamingEnabled(boolean isEnabled)", "public boolean getDataEnabled(int subId)", "public int invokeOemRilRequestRaw(byte[] oemReq, byte[] oemResp)", "public void enableVideoCalling(boolean enable)", "public boolean isVideoCallingEnabled()", "public boolean canChangeDtmfToneLength()", "public boolean isWorldPhone()", "public boolean isTtyModeSupported()", "public boolean isRttSupported()", "public boolean isHearingAidCompatibilitySupported()", "public boolean isImsRegistered(int subId)", "public boolean isImsRegistered()", "public boolean isVolteAvailable()", "public boolean isVideoTelephonyAvailable()", "public boolean isWifiCallingAvailable()", "public int getImsRegTechnologyForMmTel()", "public void setSimOperatorNumeric(String numeric)", "public void setSimOperatorNumericForPhone(int phoneId, String numeric)", "public void setSimOperatorName(String name)", "public void setSimOperatorNameForPhone(int phoneId, String name)", "public void setSimCountryIso(String iso)", "public void setSimCountryIsoForPhone(int phoneId, String iso)", "public void setSimState(String state)", "public void setSimStateForPhone(int phoneId, String state)", "public void setSimPowerState(int state)", "public void setSimPowerStateForSlot(int slotIndex, int state)", "public void setBasebandVersion(String version)", "public void setBasebandVersionForPhone(int phoneId, String version)", "public String getBasebandVersion()", "public String getBasebandVersionForPhone(int phoneId)", "public void setPhoneType(int type)", "public void setPhoneType(int phoneId, int type)", "public String getOtaSpNumberSchema(String defaultValue)", "public String getOtaSpNumberSchemaForPhone(int phoneId, String defaultValue)", "public boolean getSmsReceiveCapable(boolean defaultValue)", "public boolean getSmsReceiveCapableForPhone(int phoneId, boolean defaultValue)", "public boolean getSmsSendCapable(boolean defaultValue)", "public boolean getSmsSendCapableForPhone(int phoneId, boolean defaultValue)", "public ComponentName getAndUpdateDefaultRespondViaMessageApplication()", "public ComponentName getDefaultRespondViaMessageApplication()", "public void setNetworkOperatorName(String name)", "public void setNetworkOperatorNameForPhone(int phoneId, String name)", "public void setNetworkOperatorNumeric(String numeric)", "public void setNetworkOperatorNumericForPhone(int phoneId, String numeric)", "public void setNetworkRoaming(boolean isRoaming)", "public void setNetworkRoamingForPhone(int phoneId, boolean isRoaming)", "public void setDataNetworkType(int type)", "public void setDataNetworkTypeForPhone(int phoneId, int type)", "public int getSubIdForPhoneAccount(@Nullable PhoneAccount phoneAccount)", "public PhoneAccountHandle getPhoneAccountHandleForSubscriptionId(int subscriptionId)", "public int getSubscriptionId(@NonNull PhoneAccountHandle phoneAccountHandle)", "public void factoryReset(int subId)", "public void resetSettings()", "public Locale getSimLocale()", "public String getLocaleFromDefaultSim()", "public void requestModemActivityInfo(@NonNull ResultReceiver result)", "public ServiceState getServiceState()", "public ServiceState getServiceStateForSubscriber(int subId)", "public Uri getVoicemailRingtoneUri(PhoneAccountHandle accountHandle)", "public void setVoicemailRingtoneUri(PhoneAccountHandle phoneAccountHandle, Uri uri)", "public boolean isVoicemailVibrationEnabled(PhoneAccountHandle accountHandle)", "public void setVoicemailVibrationEnabled(PhoneAccountHandle phoneAccountHandle, boolean enabled)", "public int getSimCarrierId()", "public CharSequence getSimCarrierIdName()", "public int getSimSpecificCarrierId()", "public CharSequence getSimSpecificCarrierIdName()", "public int getCarrierIdFromSimMccMnc()", "public int getCarrierIdFromMccMnc(String mccmnc)", "public List<String> getCertsFromCarrierPrivilegeAccessRules()", "public String getAidForAppType(@UiccAppType int appType)", "public String getAidForAppType(int subId, int appType)", "public String getEsn()", "public String getEsn(int subId)", "public String getCdmaPrlVersion()", "public String getCdmaPrlVersion(int subId)", "public List<TelephonyHistogram> getTelephonyHistograms()", "public int setAllowedCarriers(int slotIndex, List<CarrierIdentifier> carriers)", "public int setCarrierRestrictionRules(@NonNull CarrierRestrictionRules rules)", "public List<CarrierIdentifier> getAllowedCarriers(int slotIndex)", "public CarrierRestrictionRules getCarrierRestrictionRules()", "public void setCarrierDataEnabled(boolean enabled)", "public void setRadioEnabled(boolean enabled)", "public void reportDefaultNetworkStatus(boolean report)", "public void resetAllCarrierActions()", "public void setPolicyDataEnabled(boolean enabled)", "public List<ClientRequestStats> getClientRequestStats(int subId)", "public boolean getEmergencyCallbackMode()", "public boolean getEmergencyCallbackMode(int subId)", "public boolean isManualNetworkSelectionAllowed()", "public void setAlwaysReportSignalStrength(boolean isEnabled)", "public SignalStrength getSignalStrength()", "public boolean isDataConnectionAllowed()", "public boolean isDataCapable()", "public void setCarrierTestOverride(String mccmnc, String imsi, String iccid, String gid1, String gid2, String plmn, String spn)", "public void setCarrierTestOverride(String mccmnc, String imsi, String iccid, String gid1, String gid2, String plmn, String spn, String carrierPriviledgeRules, String apn)", "public int getCarrierIdListVersion()", "public int getNumberOfModemsWithSimultaneousDataConnections()", "public boolean setOpportunisticNetworkState(boolean enable)", "public boolean isOpportunisticNetworkEnabled()", "public long getSupportedRadioAccessFamily()", "public void notifyOtaEmergencyNumberDbInstalled()", "public void updateOtaEmergencyNumberDbFilePath(@NonNull ParcelFileDescriptor otaParcelFileDescriptor)", "public void resetOtaEmergencyNumberDbFilePath()", "public boolean isEmergencyAssistanceEnabled()", "public Map<Integer, List<EmergencyNumber>> getEmergencyNumberList()", "public Map<Integer, List<EmergencyNumber>> getEmergencyNumberList(@EmergencyServiceCategories int categories)", "public boolean isEmergencyNumber(@NonNull String number)", "public boolean isPotentialEmergencyNumber(@NonNull String number)", "public int getEmergencyNumberDbVersion()", "public void setPreferredOpportunisticDataSubscription(int subId, boolean needValidation, @Nullable @CallbackExecutor Executor executor, @Nullable Consumer<Integer> callback)", "public int getPreferredOpportunisticDataSubscription()", "public void updateAvailableNetworks(@NonNull List<AvailableNetworkInfo> availableNetworks, @Nullable @CallbackExecutor Executor executor, @UpdateAvailableNetworksResult @Nullable Consumer<Integer> callback)", "public boolean enableModemForSlot(int slotIndex, boolean enable)", "public boolean isModemEnabledForSlot(int slotIndex)", "public void setMultiSimCarrierRestriction(boolean isMultiSimCarrierRestricted)", "public int isMultiSimSupported()", "public void switchMultiSimConfig(int numOfSims)", "public boolean doesSwitchMultiSimConfigTriggerReboot()", "public Pair<Integer, Integer> getRadioHalVersion()", "public int getCarrierPrivilegeStatus(int uid)", "public List<ApnSetting> getDevicePolicyOverrideApns(@NonNull Context context)", "public int addDevicePolicyOverrideApn(@NonNull Context context, @NonNull ApnSetting apnSetting)", "public boolean modifyDevicePolicyOverrideApn(@NonNull Context context, int apnId, @NonNull ApnSetting apnSetting)", "public boolean isDataEnabledForApn(@ApnType int apnType)", "public boolean isApnMetered(@ApnType int apnType)", "public void setSystemSelectionChannels(@NonNull List<RadioAccessSpecifier> specifiers, @NonNull @CallbackExecutor Executor executor, @NonNull Consumer<Boolean> callback)", "public void setSystemSelectionChannels(@NonNull List<RadioAccessSpecifier> specifiers)", "private void setSystemSelectionChannelsInternal(@NonNull List<RadioAccessSpecifier> specifiers, @Nullable @CallbackExecutor Executor executor, @Nullable Consumer<Boolean> callback)", "public boolean matchesCurrentSimOperator(@NonNull String mccmnc, @MvnoType int mvnoType, @Nullable String mvnoMatchData)", "public CallForwardingInfo getCallForwarding(@CallForwardingReason int callForwardingReason)", "public boolean setCallForwarding(@NonNull CallForwardingInfo callForwardingInfo)", "public int getCallWaitingStatus()", "public boolean setCallWaitingStatus(boolean isEnable)", "public boolean setDataAllowedDuringVoiceCall(boolean allow)", "public boolean isDataAllowedInVoiceCall()", "public boolean setAlwaysAllowMmsData(boolean alwaysAllow)", "public boolean isIccLockEnabled()", "public int setIccLockEnabled(boolean enabled, @NonNull String password)", "public int changeIccLockPassword(@NonNull String oldPassword, @NonNull String newPassword)", "public void notifyUserActivity()", "private static void resetServiceCache()", " static IPhoneSubInfo getSubscriberInfoService()", " static ISub getSubscriptionService()", " static ISms getSmsService()", "public static void disableServiceHandleCaching()", "public static void enableServiceHandleCaching()", "public boolean canConnectTo5GInDsdsMode()" ]
}