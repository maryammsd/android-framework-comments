{
  "filePath" : "/home/maryam/clearblue/files/android-source-35/android/app/usage/UsageStatsManager.java",
  "packageName" : "android.app.usage",
  "className" : "UsageStatsManager",
  "comment" : "\n * Provides access to device usage history and statistics. Usage data is aggregated into\n * time intervals: days, weeks, months, and years.\n * <p />\n * When requesting usage data since a particular time, the request might look something like this:\n * <pre>\n * PAST                   REQUEST_TIME                    TODAY                   FUTURE\n * ————————————————————————————||———————————————————————————¦-----------------------|\n *                        YEAR ||                           ¦                       |\n * ————————————————————————————||———————————————————————————¦-----------------------|\n *  MONTH            |         ||                MONTH      ¦                       |\n * ——————————————————|—————————||———————————————————————————¦-----------------------|\n *   |      WEEK     |     WEEK||    |     WEEK     |     WE¦EK     |      WEEK     |\n * ————————————————————————————||———————————————————|———————¦-----------------------|\n *                             ||           |DAY|DAY|DAY|DAY¦DAY|DAY|DAY|DAY|DAY|DAY|\n * ————————————————————————————||———————————————————————————¦-----------------------|\n * </pre>\n * A request for data in the middle of a time interval will include that interval.\n * <p/>\n * <b>NOTE:</b> Most methods on this API require the permission\n * android.permission.PACKAGE_USAGE_STATS. However, declaring the permission implies intention to\n * use the API and the user of the device still needs to grant permission through the Settings\n * application.\n * See {@link android.provider.Settings#ACTION_USAGE_ACCESS_SETTINGS}.\n * Methods which only return the information for the calling package do not require this permission.\n * E.g. {@link #getAppStandbyBucket()} and {@link #queryEventsForSelf(long, long)}.\n ",
  "links" : [ "#getAppStandbyBucket()", "#queryEventsForSelf(long", "android.provider.Settings#ACTION_USAGE_ACCESS_SETTINGS" ],
  "variables" : [ {
    "name" : "INTERVAL_DAILY",
    "type" : "int",
    "comment" : "\n     * An interval type that spans a day. See {@link #queryUsageStats(int, long, long)}.\n     ",
    "links" : [ "#queryUsageStats(int" ]
  }, {
    "name" : "INTERVAL_WEEKLY",
    "type" : "int",
    "comment" : "\n     * An interval type that spans a week. See {@link #queryUsageStats(int, long, long)}.\n     ",
    "links" : [ "#queryUsageStats(int" ]
  }, {
    "name" : "INTERVAL_MONTHLY",
    "type" : "int",
    "comment" : "\n     * An interval type that spans a month. See {@link #queryUsageStats(int, long, long)}.\n     ",
    "links" : [ "#queryUsageStats(int" ]
  }, {
    "name" : "INTERVAL_YEARLY",
    "type" : "int",
    "comment" : "\n     * An interval type that spans a year. See {@link #queryUsageStats(int, long, long)}.\n     ",
    "links" : [ "#queryUsageStats(int" ]
  }, {
    "name" : "INTERVAL_BEST",
    "type" : "int",
    "comment" : "\n     * An interval type that will use the best fit interval for the given time range.\n     * See {@link #queryUsageStats(int, long, long)}.\n     ",
    "links" : [ "#queryUsageStats(int" ]
  }, {
    "name" : "INTERVAL_COUNT",
    "type" : "int",
    "comment" : "\n     * The number of available intervals. Does not include {@link #INTERVAL_BEST}, since it\n     * is a pseudo interval (it actually selects a real interval).\n     * {@hide}\n     ",
    "links" : [ "#INTERVAL_BEST" ]
  }, {
    "name" : "STANDBY_BUCKET_EXEMPTED",
    "type" : "int",
    "comment" : "\n     * The app is exempted for some reason and the bucket cannot be changed.\n     * {@hide}\n     ",
    "links" : [ ]
  }, {
    "name" : "STANDBY_BUCKET_ACTIVE",
    "type" : "int",
    "comment" : "\n     * The app was used very recently, currently in use or likely to be used very soon. Standby\n     * bucket values that are &le; {@link #STANDBY_BUCKET_ACTIVE} will not be throttled by the\n     * system while they are in this bucket. Buckets &gt; {@link #STANDBY_BUCKET_ACTIVE} will most\n     * likely be restricted in some way. For instance, jobs and alarms may be deferred.\n     * @see #getAppStandbyBucket()\n     ",
    "links" : [ "#STANDBY_BUCKET_ACTIVE" ]
  }, {
    "name" : "STANDBY_BUCKET_WORKING_SET",
    "type" : "int",
    "comment" : "\n     * The app was used recently and/or likely to be used in the next few hours. Restrictions will\n     * apply to these apps, such as deferral of jobs and alarms.\n     * @see #getAppStandbyBucket()\n     ",
    "links" : [ ]
  }, {
    "name" : "STANDBY_BUCKET_FREQUENT",
    "type" : "int",
    "comment" : "\n     * The app was used in the last few days and/or likely to be used in the next few days.\n     * Restrictions will apply to these apps, such as deferral of jobs and alarms. The delays may be\n     * greater than for apps in higher buckets (lower bucket value). Bucket values &gt;\n     * {@link #STANDBY_BUCKET_FREQUENT} may additionally have network access limited.\n     * @see #getAppStandbyBucket()\n     ",
    "links" : [ "#STANDBY_BUCKET_FREQUENT" ]
  }, {
    "name" : "STANDBY_BUCKET_RARE",
    "type" : "int",
    "comment" : "\n     * The app has not be used for several days and/or is unlikely to be used for several days.\n     * Apps in this bucket will have more restrictions, including network restrictions, except\n     * during certain short periods (at a minimum, once a day) when they are allowed to execute\n     * jobs, access the network, etc.\n     * @see #getAppStandbyBucket()\n     ",
    "links" : [ ]
  }, {
    "name" : "STANDBY_BUCKET_RESTRICTED",
    "type" : "int",
    "comment" : "\n     * The app has not be used for several days, is unlikely to be used for several days, and has\n     * been misbehaving in some manner.\n     * Apps in this bucket will have the most restrictions, including network restrictions and\n     * additional restrictions on jobs.\n     * <p> Note: this bucket is not enabled in {@link Build.VERSION_CODES#R}.\n     * @see #getAppStandbyBucket()\n     ",
    "links" : [ "Build.VERSION_CODES#R" ]
  }, {
    "name" : "STANDBY_BUCKET_NEVER",
    "type" : "int",
    "comment" : "\n     * The app has never been used.\n     * {@hide}\n     ",
    "links" : [ ]
  }, {
    "name" : "REASON_MAIN_MASK",
    "type" : "int",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "REASON_MAIN_DEFAULT",
    "type" : "int",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "REASON_MAIN_TIMEOUT",
    "type" : "int",
    "comment" : "\n     * The app spent sufficient time in the old bucket without any substantial event so it reached\n     * the timeout threshold to have its bucket lowered.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "REASON_MAIN_USAGE",
    "type" : "int",
    "comment" : "\n     * The app was used in some way. Look at the REASON_SUB_USAGE_ reason for more details.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "REASON_MAIN_FORCED_BY_USER",
    "type" : "int",
    "comment" : "\n     * Forced by the user/developer, either explicitly or implicitly through some action. If user\n     * action was not involved and this is purely due to the system,\n     * {@link #REASON_MAIN_FORCED_BY_SYSTEM} should be used instead.\n     * @hide\n     ",
    "links" : [ "#REASON_MAIN_FORCED_BY_SYSTEM" ]
  }, {
    "name" : "REASON_MAIN_PREDICTED",
    "type" : "int",
    "comment" : "\n     * Set by a privileged system app. This may be overridden by\n     * {@link #REASON_MAIN_FORCED_BY_SYSTEM} or user action.\n     * @hide\n     ",
    "links" : [ "#REASON_MAIN_FORCED_BY_SYSTEM" ]
  }, {
    "name" : "REASON_MAIN_FORCED_BY_SYSTEM",
    "type" : "int",
    "comment" : "\n     * Forced by the system, independent of user action. If user action is involved,\n     * {@link #REASON_MAIN_FORCED_BY_USER} should be used instead. When this is used, only\n     * {@link #REASON_MAIN_FORCED_BY_SYSTEM} or user action can change the bucket.\n     * @hide\n     ",
    "links" : [ "#REASON_MAIN_FORCED_BY_USER", "#REASON_MAIN_FORCED_BY_SYSTEM" ]
  }, {
    "name" : "REASON_SUB_MASK",
    "type" : "int",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "REASON_SUB_DEFAULT_UNDEFINED",
    "type" : "int",
    "comment" : "\n     * The reason for using the default main reason is unknown or undefined.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "REASON_SUB_DEFAULT_APP_UPDATE",
    "type" : "int",
    "comment" : "\n     * The app was updated.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "REASON_SUB_DEFAULT_APP_RESTORED",
    "type" : "int",
    "comment" : "\n     * The app was restored.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "REASON_SUB_USAGE_SYSTEM_INTERACTION",
    "type" : "int",
    "comment" : "\n     * The app was interacted with in some way by the system.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "REASON_SUB_USAGE_NOTIFICATION_SEEN",
    "type" : "int",
    "comment" : "\n     * A notification was viewed by the user. This does not mean the user interacted with the\n     * notification.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "REASON_SUB_USAGE_USER_INTERACTION",
    "type" : "int",
    "comment" : "\n     * The app was interacted with in some way by the user. This includes interacting with\n     * notification.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "REASON_SUB_USAGE_MOVE_TO_FOREGROUND",
    "type" : "int",
    "comment" : "\n     * An {@link android.app.Activity} moved to the foreground.\n     * @hide\n     ",
    "links" : [ "android.app.Activity" ]
  }, {
    "name" : "REASON_SUB_USAGE_MOVE_TO_BACKGROUND",
    "type" : "int",
    "comment" : "\n     * An {@link android.app.Activity} moved to the background.\n     * @hide\n     ",
    "links" : [ "android.app.Activity" ]
  }, {
    "name" : "REASON_SUB_USAGE_SYSTEM_UPDATE",
    "type" : "int",
    "comment" : "\n     * There was a system update.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "REASON_SUB_USAGE_ACTIVE_TIMEOUT",
    "type" : "int",
    "comment" : "\n     * An app is in an elevated bucket because of an active timeout preventing it from being placed\n     * in a lower bucket.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "REASON_SUB_USAGE_SYNC_ADAPTER",
    "type" : "int",
    "comment" : "\n     * This system package's sync adapter has been used for another package's content provider.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "REASON_SUB_USAGE_SLICE_PINNED",
    "type" : "int",
    "comment" : "\n     * A slice was pinned by an app.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "REASON_SUB_USAGE_SLICE_PINNED_PRIV",
    "type" : "int",
    "comment" : " /**\n     * A slice was pinned by the default launcher or the default assistant.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "REASON_SUB_USAGE_EXEMPTED_SYNC_SCHEDULED_NON_DOZE",
    "type" : "int",
    "comment" : "\n     * A sync operation that is exempt from app standby was scheduled when the device wasn't Dozing.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "REASON_SUB_USAGE_EXEMPTED_SYNC_SCHEDULED_DOZE",
    "type" : "int",
    "comment" : "\n     * A sync operation that is exempt from app standby was scheduled while the device was Dozing.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "REASON_SUB_USAGE_EXEMPTED_SYNC_START",
    "type" : "int",
    "comment" : "\n     * A sync operation that is exempt from app standby started.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "REASON_SUB_USAGE_UNEXEMPTED_SYNC_SCHEDULED",
    "type" : "int",
    "comment" : "\n     * A sync operation that is not exempt from app standby was scheduled.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "REASON_SUB_USAGE_FOREGROUND_SERVICE_START",
    "type" : "int",
    "comment" : "\n     * A foreground service started.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "REASON_SUB_PREDICTED_RESTORED",
    "type" : "int",
    "comment" : "\n     * The predicted bucket was restored after the app's temporary elevation to the ACTIVE bucket\n     * ended.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "REASON_SUB_FORCED_SYSTEM_FLAG_UNDEFINED",
    "type" : "int",
    "comment" : "\n     * The reason the system forced the app into the bucket is unknown or undefined.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "REASON_SUB_FORCED_SYSTEM_FLAG_BACKGROUND_RESOURCE_USAGE",
    "type" : "int",
    "comment" : "\n     * The app was unnecessarily using system resources (battery, memory, etc) in the background.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "REASON_SUB_FORCED_SYSTEM_FLAG_ABUSE",
    "type" : "int",
    "comment" : "\n     * The app was deemed to be intentionally abusive.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "REASON_SUB_FORCED_SYSTEM_FLAG_BUGGY",
    "type" : "int",
    "comment" : "\n     * The app was displaying buggy behavior.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "REASON_SUB_FORCED_USER_FLAG_INTERACTION",
    "type" : "int",
    "comment" : "\n     * The app was moved to restricted bucket due to user interaction, i.e., toggling FAS.\n     *\n     * <p>\n     * Note: This should be coming from the more end-user facing UX, not from developer\n     * options nor adb command.\n     </p>\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "EXTRA_OBSERVER_ID",
    "type" : "String",
    "comment" : "\n     * Observer id of the registered observer for the group of packages that reached the usage\n     * time limit. Included as an extra in the PendingIntent that was registered.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "EXTRA_TIME_LIMIT",
    "type" : "String",
    "comment" : "\n     * Original time limit in milliseconds specified by the registered observer for the group of\n     * packages that reached the usage time limit. Included as an extra in the PendingIntent that\n     * was registered.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "EXTRA_TIME_USED",
    "type" : "String",
    "comment" : "\n     * Actual usage time in milliseconds for the group of packages that reached the specified time\n     * limit. Included as an extra in the PendingIntent that was registered.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "EXTRA_EVENT_CATEGORY",
    "type" : "String",
    "comment" : "\n     * A String extra, when used with {@link UsageEvents.Event#getExtras}, that indicates\n     * the category of the user interaction associated with the event. The category cannot\n     * be more than 127 characters, longer value will be truncated to 127 characters.\n     ",
    "links" : [ "UsageEvents.Event#getExtras" ]
  }, {
    "name" : "EXTRA_EVENT_ACTION",
    "type" : "String",
    "comment" : "\n     * A String extra, when used with {@link UsageEvents.Event#getExtras}, that indicates\n     * the action of the user interaction associated with the event. The action cannot be\n     * more than 127 characters, longer value will be truncated to 127 characters.\n     ",
    "links" : [ "UsageEvents.Event#getExtras" ]
  }, {
    "name" : "USAGE_SOURCE_TASK_ROOT_ACTIVITY",
    "type" : "int",
    "comment" : "\n     * App usage observers will consider the task root package the source of usage.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "USAGE_SOURCE_CURRENT_ACTIVITY",
    "type" : "int",
    "comment" : "\n     * App usage observers will consider the visible activity's package the source of usage.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "sEmptyResults",
    "type" : "UsageEvents",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mContext",
    "type" : "Context",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mService",
    "type" : "IUsageStatsManager",
    "comment" : "",
    "links" : [ ]
  } ],
  "methods" : [ {
    "name" : "public List<UsageStats> queryUsageStats(int intervalType, long beginTime, long endTime)",
    "returnType" : "List<UsageStats>",
    "comment" : "\n     * Gets application usage stats for the given time range, aggregated by the specified interval.\n     *\n     * <p>\n     * The returned list will contain one or more {@link UsageStats} objects for each package, with\n     * usage data that covers at least the given time range.\n     * Note: The begin and end times of the time range may be expanded to the nearest whole interval\n     * period.\n     * </p>\n     *\n     * <p> The caller must have {@link android.Manifest.permission#PACKAGE_USAGE_STATS} </p>\n     * <em>Note: Starting from {@link android.os.Build.VERSION_CODES#R Android R}, if the user's\n     * device is not in an unlocked state (as defined by {@link UserManager#isUserUnlocked()}),\n     * then {@code null} will be returned.</em>\n     *\n     * @param intervalType The time interval by which the stats are aggregated.\n     * @param beginTime The inclusive beginning of the range of stats to include in the results.\n     *                  Defined in terms of \"Unix time\", see\n     *                  {@link java.lang.System#currentTimeMillis}.\n     * @param endTime The exclusive end of the range of stats to include in the results. Defined\n     *                in terms of \"Unix time\", see {@link java.lang.System#currentTimeMillis}.\n     * @return A list of {@link UsageStats}\n     *\n     * @see #INTERVAL_DAILY\n     * @see #INTERVAL_WEEKLY\n     * @see #INTERVAL_MONTHLY\n     * @see #INTERVAL_YEARLY\n     * @see #INTERVAL_BEST\n     ",
    "links" : [ "android.Manifest.permission#PACKAGE_USAGE_STATS", "android.os.Build.VERSION_CODES#R", "android.app.usage.UsageStats", "android.os.UserManager#isUserUnlocked()", "java.lang.System#currentTimeMillis" ]
  }, {
    "name" : "public List<ConfigurationStats> queryConfigurations(int intervalType, long beginTime, long endTime)",
    "returnType" : "List<ConfigurationStats>",
    "comment" : "\n     * Gets the hardware configurations the device was in for the given time range, aggregated by\n     * the specified interval. The results are ordered as in\n     * {@link #queryUsageStats(int, long, long)}.\n     * <p> The caller must have {@link android.Manifest.permission#PACKAGE_USAGE_STATS} </p>\n     * <em>Note: Starting from {@link android.os.Build.VERSION_CODES#R Android R}, if the user's\n     * device is not in an unlocked state (as defined by {@link UserManager#isUserUnlocked()}),\n     * then {@code null} will be returned.</em>\n     *\n     * @param intervalType The time interval by which the stats are aggregated.\n     * @param beginTime The inclusive beginning of the range of stats to include in the results.\n     *                  Defined in terms of \"Unix time\", see\n     *                  {@link java.lang.System#currentTimeMillis}.\n     * @param endTime The exclusive end of the range of stats to include in the results. Defined\n     *                in terms of \"Unix time\", see {@link java.lang.System#currentTimeMillis}.\n     * @return A list of {@link ConfigurationStats}\n     ",
    "links" : [ "android.Manifest.permission#PACKAGE_USAGE_STATS", "android.os.Build.VERSION_CODES#R", "android.app.usage.ConfigurationStats", "#queryUsageStats(int", "android.os.UserManager#isUserUnlocked()", "java.lang.System#currentTimeMillis" ]
  }, {
    "name" : "public List<EventStats> queryEventStats(int intervalType, long beginTime, long endTime)",
    "returnType" : "List<EventStats>",
    "comment" : "\n     * Gets aggregated event stats for the given time range, aggregated by the specified interval.\n     * <p>The returned list will contain a {@link EventStats} object for each event type that\n     * is being aggregated and has data for an interval that is a subset of the time range given.\n     *\n     * <p>The current event types that will be aggregated here are:</p>\n     * <ul>\n     *     <li>{@link UsageEvents.Event#SCREEN_INTERACTIVE}</li>\n     *     <li>{@link UsageEvents.Event#SCREEN_NON_INTERACTIVE}</li>\n     *     <li>{@link UsageEvents.Event#KEYGUARD_SHOWN}</li>\n     *     <li>{@link UsageEvents.Event#KEYGUARD_HIDDEN}</li>\n     * </ul>\n     *\n     * <p> The caller must have {@link android.Manifest.permission#PACKAGE_USAGE_STATS} </p>\n     * <em>Note: Starting from {@link android.os.Build.VERSION_CODES#R Android R}, if the user's\n     * device is not in an unlocked state (as defined by {@link UserManager#isUserUnlocked()}),\n     * then {@code null} will be returned.</em>\n     *\n     * @param intervalType The time interval by which the stats are aggregated.\n     * @param beginTime The inclusive beginning of the range of stats to include in the results.\n     *                  Defined in terms of \"Unix time\", see\n     *                  {@link java.lang.System#currentTimeMillis}.\n     * @param endTime The exclusive end of the range of stats to include in the results. Defined\n     *                in terms of \"Unix time\", see {@link java.lang.System#currentTimeMillis}.\n     * @return A list of {@link EventStats}\n     *\n     * @see #INTERVAL_DAILY\n     * @see #INTERVAL_WEEKLY\n     * @see #INTERVAL_MONTHLY\n     * @see #INTERVAL_YEARLY\n     * @see #INTERVAL_BEST\n     ",
    "links" : [ "android.Manifest.permission#PACKAGE_USAGE_STATS", "android.os.Build.VERSION_CODES#R", "UsageEvents.Event#KEYGUARD_HIDDEN", "UsageEvents.Event#SCREEN_NON_INTERACTIVE", "android.app.usage.EventStats", "android.os.UserManager#isUserUnlocked()", "java.lang.System#currentTimeMillis", "UsageEvents.Event#SCREEN_INTERACTIVE", "UsageEvents.Event#KEYGUARD_SHOWN" ]
  }, {
    "name" : "public UsageEvents queryEvents(long beginTime, long endTime)",
    "returnType" : "UsageEvents",
    "comment" : "\n     * Query for events in the given time range. Events are only kept by the system for a few\n     * days.\n     * <p> The caller must have {@link android.Manifest.permission#PACKAGE_USAGE_STATS} </p>\n     * <em>Note: Starting from {@link android.os.Build.VERSION_CODES#R Android R}, if the user's\n     * device is not in an unlocked state (as defined by {@link UserManager#isUserUnlocked()}),\n     * then {@code null} will be returned.</em>\n     *\n     * @param beginTime The inclusive beginning of the range of events to include in the results.\n     *                  Defined in terms of \"Unix time\", see\n     *                  {@link java.lang.System#currentTimeMillis}.\n     * @param endTime The exclusive end of the range of events to include in the results. Defined\n     *                in terms of \"Unix time\", see {@link java.lang.System#currentTimeMillis}.\n     * @return A {@link UsageEvents}.\n     ",
    "links" : [ "android.Manifest.permission#PACKAGE_USAGE_STATS", "android.os.Build.VERSION_CODES#R", "android.app.usage.UsageEvents", "android.os.UserManager#isUserUnlocked()", "java.lang.System#currentTimeMillis" ]
  }, {
    "name" : "public UsageEvents queryEvents(@NonNull UsageEventsQuery query)",
    "returnType" : "UsageEvents",
    "comment" : "\n     * Query for events with specific UsageEventsQuery object.\n     *\n     * <em>Note: if the user's device is not in an unlocked state (as defined by\n     * {@link UserManager#isUserUnlocked()}), then {@code null} will be returned.</em>\n     *\n     * @param query The query object used to specify the query parameters.\n     * @return A {@link UsageEvents} which contains the events matching the query parameters.\n     ",
    "links" : [ "android.app.usage.UsageEvents", "android.os.UserManager#isUserUnlocked()" ]
  }, {
    "name" : "public UsageEvents queryEventsForSelf(long beginTime, long endTime)",
    "returnType" : "UsageEvents",
    "comment" : "\n     * Like {@link #queryEvents(long, long)}, but only returns events for the calling package.\n     * <em>Note: Starting from {@link android.os.Build.VERSION_CODES#R Android R}, if the user's\n     * device is not in an unlocked state (as defined by {@link UserManager#isUserUnlocked()}),\n     * then {@code null} will be returned.</em>\n     *\n     * @param beginTime The inclusive beginning of the range of events to include in the results.\n     *                  Defined in terms of \"Unix time\", see\n     *                  {@link java.lang.System#currentTimeMillis}.\n     * @param endTime The exclusive end of the range of events to include in the results. Defined\n     *                in terms of \"Unix time\", see {@link java.lang.System#currentTimeMillis}.\n     * @return A {@link UsageEvents} object.\n     *\n     * @see #queryEvents(long, long)\n     ",
    "links" : [ "android.os.Build.VERSION_CODES#R", "android.app.usage.UsageEvents", "#queryEvents(long", "android.os.UserManager#isUserUnlocked()", "java.lang.System#currentTimeMillis" ]
  }, {
    "name" : "public Map<String, UsageStats> queryAndAggregateUsageStats(long beginTime, long endTime)",
    "returnType" : "Map<String, UsageStats>",
    "comment" : "\n     * A convenience method that queries for all stats in the given range (using the best interval\n     * for that range), merges the resulting data, and keys it by package name.\n     * See {@link #queryUsageStats(int, long, long)}.\n     * <p> The caller must have {@link android.Manifest.permission#PACKAGE_USAGE_STATS} </p>\n     *\n     * @param beginTime The inclusive beginning of the range of stats to include in the results.\n     *                  Defined in terms of \"Unix time\", see\n     *                  {@link java.lang.System#currentTimeMillis}.\n     * @param endTime The exclusive end of the range of stats to include in the results. Defined\n     *                in terms of \"Unix time\", see {@link java.lang.System#currentTimeMillis}.\n     * @return A {@link java.util.Map} keyed by package name\n     ",
    "links" : [ "android.Manifest.permission#PACKAGE_USAGE_STATS", "#queryUsageStats(int", "java.util.Map", "java.lang.System#currentTimeMillis" ]
  }, {
    "name" : "public boolean isAppStandbyEnabled()",
    "returnType" : "boolean",
    "comment" : "\n     * Returns whether the app standby bucket feature is enabled.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean isAppInactive(String packageName)",
    "returnType" : "boolean",
    "comment" : "\n     * Returns whether the specified app is currently considered inactive. This will be true if the\n     * app hasn't been used directly or indirectly for a period of time defined by the system. This\n     * could be of the order of several hours or days. Apps are not considered inactive when the\n     * device is charging.\n     * <p> The caller must have {@link android.Manifest.permission#PACKAGE_USAGE_STATS} to query the\n     * inactive state of other apps</p>\n     *\n     * @param packageName The package name of the app to query\n     * @return whether the app is currently considered inactive or false if querying another app\n     * without {@link android.Manifest.permission#PACKAGE_USAGE_STATS}\n     ",
    "links" : [ "android.Manifest.permission#PACKAGE_USAGE_STATS" ]
  }, {
    "name" : "public void setAppInactive(String packageName, boolean inactive)",
    "returnType" : "void",
    "comment" : "\n     * {@hide}\n     ",
    "links" : [ ]
  }, {
    "name" : "public int getAppStandbyBucket()",
    "returnType" : "int",
    "comment" : "\n     * Returns the current standby bucket of the calling app. The system determines the standby\n     * state of the app based on app usage patterns. Standby buckets determine how much an app will\n     * be restricted from running background tasks such as jobs and alarms.\n     * <p>Restrictions increase progressively from {@link #STANDBY_BUCKET_ACTIVE} to\n     * {@link #STANDBY_BUCKET_RESTRICTED}, with {@link #STANDBY_BUCKET_ACTIVE} being the least\n     * restrictive. The battery level of the device might also affect the restrictions.\n     * <p>Apps in buckets &le; {@link #STANDBY_BUCKET_ACTIVE} have no standby restrictions imposed.\n     * Apps in buckets &gt; {@link #STANDBY_BUCKET_FREQUENT} may have network access restricted when\n     * running in the background.\n     * <p>The standby state of an app can change at any time either due to a user interaction or a\n     * system interaction or some algorithm determining that the app can be restricted for a period\n     * of time before the user has a need for it.\n     * <p>You can also query the recent history of standby bucket changes by calling\n     * {@link #queryEventsForSelf(long, long)} and searching for\n     * {@link UsageEvents.Event#STANDBY_BUCKET_CHANGED}.\n     *\n     * @return the current standby bucket of the calling app. One of STANDBY_BUCKET_* constants.\n     ",
    "links" : [ "#STANDBY_BUCKET_FREQUENT", "#STANDBY_BUCKET_RESTRICTED", "#queryEventsForSelf(long", "UsageEvents.Event#STANDBY_BUCKET_CHANGED", "#STANDBY_BUCKET_ACTIVE" ]
  }, {
    "name" : "public int getAppStandbyBucket(String packageName)",
    "returnType" : "int",
    "comment" : "\n     * {@hide}\n     * Returns the current standby bucket of the specified app. The caller must hold the permission\n     * android.permission.PACKAGE_USAGE_STATS.\n     * @param packageName the package for which to fetch the current standby bucket.\n     ",
    "links" : [ ]
  }, {
    "name" : "public void setAppStandbyBucket(String packageName, @StandbyBuckets int bucket)",
    "returnType" : "void",
    "comment" : "\n     * {@hide}\n     * Changes an app's standby bucket to the provided value. The caller can only set the standby\n     * bucket for a different app than itself. The caller will not be able to change an app's\n     * standby bucket if that app is in the {@link #STANDBY_BUCKET_RESTRICTED} bucket.\n     * @param packageName the package name of the app to set the bucket for. A SecurityException\n     *                    will be thrown if the package name is that of the caller.\n     * @param bucket the standby bucket to set it to, which should be one of STANDBY_BUCKET_*.\n     *               Setting a standby bucket outside of the range of STANDBY_BUCKET_ACTIVE to\n     *               STANDBY_BUCKET_NEVER will result in a SecurityException.\n     ",
    "links" : [ "#STANDBY_BUCKET_RESTRICTED" ]
  }, {
    "name" : "public Map<String, Integer> getAppStandbyBuckets()",
    "returnType" : "Map<String, Integer>",
    "comment" : "\n     * {@hide}\n     * Returns the current standby bucket of every app that has a bucket assigned to it.\n     * The caller must hold the permission android.permission.PACKAGE_USAGE_STATS. The key of the\n     * returned Map is the package name and the value is the bucket assigned to the package.\n     * @see #getAppStandbyBucket()\n     ",
    "links" : [ ]
  }, {
    "name" : "public void setAppStandbyBuckets(Map<String, Integer> appBuckets)",
    "returnType" : "void",
    "comment" : "\n     * {@hide}\n     * Changes the app standby bucket for multiple apps at once. The Map is keyed by the package\n     * name and the value is one of STANDBY_BUCKET_*. The caller will not be able to change an\n     * app's standby bucket if that app is in the {@link #STANDBY_BUCKET_RESTRICTED} bucket.\n     * @param appBuckets a map of package name to bucket value.\n     ",
    "links" : [ "#STANDBY_BUCKET_RESTRICTED" ]
  }, {
    "name" : "public int getAppMinStandbyBucket(String packageName)",
    "returnType" : "int",
    "comment" : "\n     * Return the lowest bucket this app can ever enter.\n     *\n     * @param packageName the package for which to fetch the minimum allowed standby bucket.\n     * {@hide}\n     ",
    "links" : [ ]
  }, {
    "name" : "public void setEstimatedLaunchTimeMillis(@NonNull String packageName, @CurrentTimeMillisLong long estimatedLaunchTimeMillis)",
    "returnType" : "void",
    "comment" : "\n     * Changes an app's estimated launch time. An app is considered \"launched\" when a user opens\n     * one of its {@link android.app.Activity Activities}. The provided time is persisted across\n     * reboots and is used unless 1) the time is more than a week in the future and the platform\n     * thinks the app will be launched sooner, 2) the estimated time has passed. Passing in\n     * {@link Long#MAX_VALUE} effectively clears the previously set launch time for the app.\n     *\n     * @param packageName               The package name of the app to set the bucket for.\n     * @param estimatedLaunchTimeMillis The next time the app is expected to be launched. Units are\n     *                                  in milliseconds since epoch (the same as\n     *                                  {@link System#currentTimeMillis()}).\n     * @hide\n     ",
    "links" : [ "#currentTimeMillis()", "android.app.Activity", "android.annotation.CurrentTimeMillisLong#MAX_VALUE" ]
  }, {
    "name" : "public void setEstimatedLaunchTimesMillis(@NonNull Map<String, Long> estimatedLaunchTimesMillis)",
    "returnType" : "void",
    "comment" : "\n     * Changes the estimated launch times for multiple apps at once. The map is keyed by the\n     * package name and the value is the estimated launch time.\n     *\n     * @param estimatedLaunchTimesMillis A map of package name to estimated launch time.\n     * @see #setEstimatedLaunchTimeMillis(String, long)\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public void registerAppUsageObserver(int observerId, @NonNull String[] observedEntities, long timeLimit, @NonNull TimeUnit timeUnit, @NonNull PendingIntent callbackIntent)",
    "returnType" : "void",
    "comment" : "\n     * @hide\n     * Register an app usage limit observer that receives a callback on the provided intent when\n     * the sum of usages of apps and tokens in the {@code observed} array exceeds the\n     * {@code timeLimit} specified. The structure of a token is a String with the reporting\n     * package's name and a token the reporting app will use, separated by the forward slash\n     * character. Example: com.reporting.package/5OM3*0P4QU3-7OK3N\n     * The observer will automatically be unregistered when the time limit is reached and the\n     * intent is delivered. Registering an {@code observerId} that was already registered will\n     * override the previous one. No more than 1000 unique {@code observerId} may be registered by\n     * a single uid at any one time.\n     * @param observerId A unique id associated with the group of apps to be monitored. There can\n     *                  be multiple groups with common packages and different time limits.\n     * @param observedEntities The list of packages and token to observe for usage time. Cannot be\n     *                         null and must include at least one package or token.\n     * @param timeLimit The total time the set of apps can be in the foreground before the\n     *                  callbackIntent is delivered. Must be at least one minute.\n     * @param timeUnit The unit for time specified in {@code timeLimit}. Cannot be null.\n     * @param callbackIntent The PendingIntent that will be dispatched when the usage limit is\n     *                       exceeded by the group of apps. The delivered Intent will also contain\n     *                       the extras {@link #EXTRA_OBSERVER_ID}, {@link #EXTRA_TIME_LIMIT} and\n     *                       {@link #EXTRA_TIME_USED}. Cannot be null.\n     * @throws SecurityException if the caller doesn't have the OBSERVE_APP_USAGE permission and\n     *                           is not the profile owner of this user.\n     ",
    "links" : [ "#EXTRA_TIME_USED", "#EXTRA_TIME_LIMIT", "#EXTRA_OBSERVER_ID" ]
  }, {
    "name" : "public void unregisterAppUsageObserver(int observerId)",
    "returnType" : "void",
    "comment" : "\n     * @hide\n     * Unregister the app usage observer specified by the {@code observerId}. This will only apply\n     * to any observer registered by this application. Unregistering an observer that was already\n     * unregistered or never registered will have no effect.\n     * @param observerId The id of the observer that was previously registered.\n     * @throws SecurityException if the caller doesn't have the OBSERVE_APP_USAGE permission and is\n     *                           not the profile owner of this user.\n     ",
    "links" : [ ]
  }, {
    "name" : "public void registerUsageSessionObserver(int sessionObserverId, @NonNull String[] observedEntities, @NonNull Duration timeLimit, @NonNull Duration sessionThresholdTime, @NonNull PendingIntent limitReachedCallbackIntent, @Nullable PendingIntent sessionEndCallbackIntent)",
    "returnType" : "void",
    "comment" : "\n     * Register a usage session observer that receives a callback on the provided {@code\n     * limitReachedCallbackIntent} when the sum of usages of apps and tokens in the {@code\n     * observed} array exceeds the {@code timeLimit} specified within a usage session. The\n     * structure of a token is a String with the reporting packages' name and a token the\n     * reporting app will use, separated by the forward slash character.\n     * Example: com.reporting.package/5OM3*0P4QU3-7OK3N\n     * After the {@code timeLimit} has been reached, the usage session observer will receive a\n     * callback on the provided {@code sessionEndCallbackIntent} when the usage session ends.\n     * Registering another session observer against a {@code sessionObserverId} that has already\n     * been registered will override the previous session observer.\n     *\n     * @param sessionObserverId A unique id associated with the group of apps to be\n     *                          monitored. There can be multiple groups with common\n     *                          packages and different time limits.\n     * @param observedEntities The list of packages and token to observe for usage time. Cannot be\n     *                         null and must include at least one package or token.\n     * @param timeLimit The total time the set of apps can be used continuously before the {@code\n     *                  limitReachedCallbackIntent} is delivered. Must be at least one minute.\n     * @param sessionThresholdTime The time that can take place between usage sessions before the\n     *                             next session is considered a new session. Must be non-negative.\n     * @param limitReachedCallbackIntent The {@link PendingIntent} that will be dispatched when the\n     *                                   usage limit is exceeded by the group of apps. The\n     *                                   delivered Intent will also contain the extras {@link\n     *                                   #EXTRA_OBSERVER_ID}, {@link #EXTRA_TIME_LIMIT} and {@link\n     *                                   #EXTRA_TIME_USED}. Cannot be null.\n     * @param sessionEndCallbackIntent The {@link PendingIntent}  that will be dispatched when the\n     *                                 session has ended after the usage limit has been exceeded.\n     *                                 The session is considered at its end after the {@code\n     *                                 observed} usage has stopped and an additional {@code\n     *                                 sessionThresholdTime} has passed. The delivered Intent will\n     *                                 also contain the extras {@link #EXTRA_OBSERVER_ID} and {@link\n     *                                 #EXTRA_TIME_USED}. Can be null.\n     * @throws SecurityException if the caller doesn't have the OBSERVE_APP_USAGE permission and\n     *                           is not the profile owner of this user.\n     * @hide\n     ",
    "links" : [ "#EXTRA_TIME_USED", "#EXTRA_TIME_LIMIT", "android.app.PendingIntent", "#EXTRA_OBSERVER_ID" ]
  }, {
    "name" : "public void unregisterUsageSessionObserver(int sessionObserverId)",
    "returnType" : "void",
    "comment" : "\n     * Unregister the usage session observer specified by the {@code sessionObserverId}. This will\n     * only apply to any app session observer registered by this application. Unregistering an\n     * observer that was already unregistered or never registered will have no effect.\n     *\n     * @param sessionObserverId The id of the observer that was previously registered.\n     * @throws SecurityException if the caller doesn't have the OBSERVE_APP_USAGE permission and\n     *                           is not the profile owner of this user.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public void registerAppUsageLimitObserver(int observerId, @NonNull String[] observedEntities, @NonNull Duration timeLimit, @NonNull Duration timeUsed, @Nullable PendingIntent callbackIntent)",
    "returnType" : "void",
    "comment" : "\n     * Register a usage limit observer that receives a callback on the provided intent when the\n     * sum of usages of apps and tokens in the provided {@code observedEntities} array exceeds the\n     * {@code timeLimit} specified. The structure of a token is a {@link String} with the reporting\n     * package's name and a token that the calling app will use, separated by the forward slash\n     * character. Example: com.reporting.package/5OM3*0P4QU3-7OK3N\n     * <p>\n     * Registering an {@code observerId} that was already registered will override the previous one.\n     * No more than 1000 unique {@code observerId} may be registered by a single uid\n     * at any one time.\n     * A limit is not cleared when the usage time is exceeded. It needs to be unregistered via\n     * {@link #unregisterAppUsageLimitObserver}.\n     * <p>\n     * Note: usage limits are not persisted in the system and are cleared on reboots. Callers\n     * must reset any limits that they need on reboots.\n     * <p>\n     * This method is similar to {@link #registerAppUsageObserver}, but the usage limit set here\n     * will be visible to the launcher so that it can report the limit to the user and how much\n     * of it is remaining.\n     * @see android.content.pm.LauncherApps#getAppUsageLimit\n     *\n     * @param observerId A unique id associated with the group of apps to be monitored. There can\n     *                   be multiple groups with common packages and different time limits.\n     * @param observedEntities The list of packages and token to observe for usage time. Cannot be\n     *                         null and must include at least one package or token.\n     * @param timeLimit The total time the set of apps can be in the foreground before the\n     *                  {@code callbackIntent} is delivered. Must be at least one minute.\n     * @param timeUsed The time that has already been used by the set of apps in\n     *                 {@code observedEntities}. Note: a time used equal to or greater than\n     *                 {@code timeLimit} can be set to indicate that the user has already exhausted\n     *                 the limit for a group, in which case, the given {@code callbackIntent} will\n     *                 be ignored.\n     * @param callbackIntent The PendingIntent that will be dispatched when the usage limit is\n     *                       exceeded by the group of apps. The delivered Intent will also contain\n     *                       the extras {@link #EXTRA_OBSERVER_ID}, {@link #EXTRA_TIME_LIMIT} and\n     *                       {@link #EXTRA_TIME_USED}. Cannot be {@code null} unless the observer is\n     *                       being registered with a {@code timeUsed} equal to or greater than\n     *                       {@code timeLimit}.\n     * @throws SecurityException if the caller is neither the active supervision app nor does it\n     *                           have both SUSPEND_APPS and OBSERVE_APP_USAGE permissions.\n     * @hide\n     ",
    "links" : [ "#unregisterAppUsageLimitObserver", "#EXTRA_TIME_USED", "#EXTRA_TIME_LIMIT", "String", "#registerAppUsageObserver", "#EXTRA_OBSERVER_ID" ]
  }, {
    "name" : "public void unregisterAppUsageLimitObserver(int observerId)",
    "returnType" : "void",
    "comment" : "\n     * Unregister the app usage limit observer specified by the {@code observerId}.\n     * This will only apply to any observer registered by this application. Unregistering\n     * an observer that was already unregistered or never registered will have no effect.\n     *\n     * @param observerId The id of the observer that was previously registered.\n     * @throws SecurityException if the caller is neither the active supervision app nor does it\n     *                         have both SUSPEND_APPS and OBSERVE_APP_USAGE permissions.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public void reportUserInteraction(@NonNull String packageName, int userId)",
    "returnType" : "void",
    "comment" : "\n     * Reports user interaction with a given package in the given user.\n     *\n     * <p><em>This method is only for use by the system</em>\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public void reportUserInteraction(@NonNull String packageName, @UserIdInt int userId, @NonNull PersistableBundle extras)",
    "returnType" : "void",
    "comment" : "\n     * Reports user interaction with given package and a particular {@code extras}\n     * in the given user.\n     *\n     * <p>\n     * Note: The structure of {@code extras} is a {@link PersistableBundle} with the\n     * category {@link #EXTRA_EVENT_CATEGORY} and the action {@link #EXTRA_EVENT_ACTION}.\n     * Category provides additional detail about the user interaction, the value\n     * is defined in namespace based. Example: android.app.notification could be used to\n     * indicate that the reported user interaction is related to notification. Action\n     * indicates the general action that performed.\n     * </p>\n     *\n     * @param packageName The package name of the app\n     * @param userId The user id who triggers the user interaction\n     * @param extras The {@link PersistableBundle} that will be used to specify the\n     *               extra details for the user interaction event. The {@link PersistableBundle}\n     *               must contain the extras {@link #EXTRA_EVENT_CATEGORY},\n     *               {@link #EXTRA_EVENT_ACTION}. Cannot be empty.\n     * @hide\n     ",
    "links" : [ "android.os.PersistableBundle", "#EXTRA_EVENT_ACTION", "#EXTRA_EVENT_CATEGORY" ]
  }, {
    "name" : "public void reportUsageStart(@NonNull Activity activity, @NonNull String token)",
    "returnType" : "void",
    "comment" : "\n     * Report usage associated with a particular {@code token} has started. Tokens are app defined\n     * strings used to represent usage of in-app features. Apps with the {@link\n     * android.Manifest.permission#OBSERVE_APP_USAGE} permission can register time limit observers\n     * to monitor the usage of a token. In app usage can only associated with an {@code activity}\n     * and usage will be considered stopped if the activity stops or crashes.\n     * @see #registerAppUsageObserver\n     * @see #registerUsageSessionObserver\n     * @see #registerAppUsageLimitObserver\n     *\n     * @param activity The activity {@code token} is associated with.\n     * @param token The token to report usage against.\n     * @hide\n     ",
    "links" : [ "android.Manifest.permission#OBSERVE_APP_USAGE" ]
  }, {
    "name" : "public void reportUsageStart(@NonNull Activity activity, @NonNull String token, long timeAgoMs)",
    "returnType" : "void",
    "comment" : "\n     * Report usage associated with a particular {@code token} had started some amount of time in\n     * the past. Tokens are app defined strings used to represent usage of in-app features. Apps\n     * with the {@link android.Manifest.permission#OBSERVE_APP_USAGE} permission can register time\n     * limit observers to monitor the usage of a token. In app usage can only associated with an\n     * {@code activity} and usage will be considered stopped if the activity stops or crashes.\n     * @see #registerAppUsageObserver\n     * @see #registerUsageSessionObserver\n     * @see #registerAppUsageLimitObserver\n     *\n     * @param activity The activity {@code token} is associated with.\n     * @param token The token to report usage against.\n     * @param timeAgoMs How long ago the start of usage took place\n     * @hide\n     ",
    "links" : [ "android.Manifest.permission#OBSERVE_APP_USAGE" ]
  }, {
    "name" : "public void reportUsageStop(@NonNull Activity activity, @NonNull String token)",
    "returnType" : "void",
    "comment" : "\n     * Report the usage associated with a particular {@code token} has stopped.\n     *\n     * @param activity The activity {@code token} is associated with.\n     * @param token The token to report usage against.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public int getUsageSource()",
    "returnType" : "int",
    "comment" : "\n     * Get what App Usage Observers will consider the source of usage for an activity. Usage Source\n     * is decided at boot and will not change until next boot.\n     * @see #USAGE_SOURCE_TASK_ROOT_ACTIVITY\n     * @see #USAGE_SOURCE_CURRENT_ACTIVITY\n     *\n     * @throws SecurityException if the caller doesn't have the OBSERVE_APP_USAGE permission and\n     *                           is not the profile owner of this user.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public void forceUsageSourceSettingRead()",
    "returnType" : "void",
    "comment" : "\n     * Force the Usage Source be reread from global settings.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public static String reasonToString(int standbyReason)",
    "returnType" : "String",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "public static String usageSourceToString(int usageSource)",
    "returnType" : "String",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "public static String standbyBucketToString(int standbyBucket)",
    "returnType" : "String",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "public void whitelistAppTemporarily(String packageName, long duration, UserHandle user)",
    "returnType" : "void",
    "comment" : "\n     * {@hide}\n     * Temporarily allowlist the specified app for a short duration. This is to allow an app\n     * receiving a high priority message to be able to access the network and acquire wakelocks\n     * even if the device is in power-save mode or the app is currently considered inactive.\n     * @param packageName The package name of the app to allowlist.\n     * @param duration Duration to allowlist the app for, in milliseconds. It is recommended that\n     * this be limited to 10s of seconds. Requested duration will be clamped to a few minutes.\n     * @param user The user for whom the package should be allowlisted. Passing in a user that is\n     * not the same as the caller's process will require the INTERACT_ACROSS_USERS permission.\n     * @see #isAppInactive(String)\n     *\n     * @deprecated Use\n     * {@link android.os.PowerWhitelistManager#whitelistAppTemporarily(String, long)} instead.\n     ",
    "links" : [ "android.os.PowerWhitelistManager#whitelistAppTemporarily(String" ]
  }, {
    "name" : "public void onCarrierPrivilegedAppsChanged()",
    "returnType" : "void",
    "comment" : "\n     * Inform usage stats that the carrier privileged apps access rules have changed.\n     * <p> The caller must have {@link android.Manifest.permission#BIND_CARRIER_SERVICES} </p>\n     * @hide\n     ",
    "links" : [ "android.Manifest.permission#BIND_CARRIER_SERVICES" ]
  }, {
    "name" : "public void reportChooserSelection(String packageName, int userId, String contentType, String[] annotations, String action)",
    "returnType" : "void",
    "comment" : "\n     * Reports a Chooser action to the UsageStatsManager.\n     *\n     * @param packageName The package name of the app that is selected.\n     * @param userId The user id of who makes the selection.\n     * @param contentType The type of the content, e.g., Image, Video, App.\n     * @param annotations The annotations of the content, e.g., Game, Selfie.\n     * @param action The action type of Intent that invokes ChooserActivity.\n     * {@link UsageEvents}\n     * @hide\n     ",
    "links" : [ "android.app.usage.UsageEvents" ]
  }, {
    "name" : "public long getLastTimeAnyComponentUsed(@NonNull String packageName)",
    "returnType" : "long",
    "comment" : "\n     * Get the last time a package is used by any users including explicit user interaction and\n     * component usage, measured in milliseconds since the epoch and truncated to the boundary of\n     * last day before the exact time. For packages that are never used, the time will be the epoch.\n     * <p> Note that this usage stats is user-agnostic. </p>\n     * <p>\n     * Also note that component usage is only reported for component bindings (e.g. broadcast\n     * receiver, service, content provider) and only when such a binding would cause an app to leave\n     * the stopped state.\n     * See {@link UsageEvents.Event.USER_INTERACTION}, {@link UsageEvents.Event.APP_COMPONENT_USED}.\n     * </p>\n     *\n     * @param packageName The name of the package to be queried.\n     * @return last time the queried package is used since the epoch.\n     * @hide\n     ",
    "links" : [ "UsageEvents.Event.USER_INTERACTION", "UsageEvents.Event.APP_COMPONENT_USED" ]
  }, {
    "name" : "public List<BroadcastResponseStats> queryBroadcastResponseStats(@Nullable String packageName, @IntRange(from = 0) long id)",
    "returnType" : "List<BroadcastResponseStats>",
    "comment" : "\n     * Returns the broadcast response stats since the last boot corresponding to\n     * {@code packageName} and {@code id}.\n     *\n     * <p> Broadcast response stats will include the aggregated data of what actions an app took\n     * upon receiving a broadcast. This data will consider the broadcasts that the caller sent to\n     * {@code packageName} and explicitly requested to record the response events using\n     * {@link BroadcastOptions#recordResponseEventWhileInBackground(long)}.\n     *\n     * <p> The returned list could one or more {@link BroadcastResponseStats} objects or be empty\n     * depending on the {@code packageName} and {@code id} and whether there is any data\n     * corresponding to these. If the {@code packageName} is not {@code null} and {@code id} is\n     * {@code > 0}, then the returned list would contain at most one {@link BroadcastResponseStats}\n     * object. Otherwise, the returned list could contain more than one\n     * {@link BroadcastResponseStats} object in no particular order.\n     *\n     * <p> Note: It is possible that same {@code id} was used for broadcasts sent to different\n     * packages. So, callers can query the data corresponding to\n     * all broadcasts with a particular {@code id} by passing {@code packageName} as {@code null}.\n     *\n     * @param packageName The name of the package that the caller wants to query for\n     *                    or {@code null} to indicate that data corresponding to all packages\n     *                    should be returned.\n     * @param id The ID corresponding to the broadcasts that the caller wants to query for, or\n     *           {@code 0} to indicate that data corresponding to all IDs should be returned.\n     *           This is the ID the caller specifies when requesting a broadcast response event\n     *           to be recorded using\n     *           {@link BroadcastOptions#recordResponseEventWhileInBackground(long)}.\n     *\n     * @return the list of broadcast response stats corresponding to {@code packageName}\n     *         and {@code id}.\n     *\n     * @see #clearBroadcastResponseStats(String, long)\n     * @hide\n     ",
    "links" : [ "android.app.usage.BroadcastResponseStats", "android.app.BroadcastOptions#recordResponseEventWhileInBackground(long)" ]
  }, {
    "name" : "public void clearBroadcastResponseStats(@Nullable String packageName, @IntRange(from = 0) long id)",
    "returnType" : "void",
    "comment" : "\n     * Clears the broadcast response stats corresponding to {@code packageName} and {@code id}.\n     *\n     * <p> When a caller uses this API, stats related to the events occurring till that point will\n     * be cleared and subsequent calls to {@link #queryBroadcastResponseStats(String, long)} will\n     * return stats related to events occurring after this.\n     *\n     * @param packageName The name of the package that the caller wants to clear the data for or\n     *                    {@code null} to indicate that data corresponding to all packages should\n     *                    be cleared.\n     * @param id The ID corresponding to the broadcasts that the caller wants to clear the data\n     *           for, or {code 0} to indicate that data corresponding to all IDs should be deleted.\n     *           This is the ID the caller specifies when requesting a broadcast response event\n     *           to be recorded using\n     *           {@link BroadcastOptions#recordResponseEventWhileInBackground(long)}.\n     *\n     * @see #queryBroadcastResponseStats(String, long)\n     * @hide\n     ",
    "links" : [ "#queryBroadcastResponseStats(String", "android.app.BroadcastOptions#recordResponseEventWhileInBackground(long)" ]
  }, {
    "name" : "public void clearBroadcastEvents()",
    "returnType" : "void",
    "comment" : "\n     * Clears the broadcast events that were sent by the caller uid.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean isPackageExemptedFromBroadcastResponseStats(@NonNull String packageName)",
    "returnType" : "boolean",
    "comment" : "\n     * Checks whether the given {@code packageName} is exempted from broadcast response tracking.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public String getAppStandbyConstant(@NonNull String key)",
    "returnType" : "String",
    "comment" : " @hide ",
    "links" : [ ]
  } ],
  "methodNames" : [ "public List<UsageStats> queryUsageStats(int intervalType, long beginTime, long endTime)", "public List<ConfigurationStats> queryConfigurations(int intervalType, long beginTime, long endTime)", "public List<EventStats> queryEventStats(int intervalType, long beginTime, long endTime)", "public UsageEvents queryEvents(long beginTime, long endTime)", "public UsageEvents queryEvents(@NonNull UsageEventsQuery query)", "public UsageEvents queryEventsForSelf(long beginTime, long endTime)", "public Map<String, UsageStats> queryAndAggregateUsageStats(long beginTime, long endTime)", "public boolean isAppStandbyEnabled()", "public boolean isAppInactive(String packageName)", "public void setAppInactive(String packageName, boolean inactive)", "public int getAppStandbyBucket()", "public int getAppStandbyBucket(String packageName)", "public void setAppStandbyBucket(String packageName, @StandbyBuckets int bucket)", "public Map<String, Integer> getAppStandbyBuckets()", "public void setAppStandbyBuckets(Map<String, Integer> appBuckets)", "public int getAppMinStandbyBucket(String packageName)", "public void setEstimatedLaunchTimeMillis(@NonNull String packageName, @CurrentTimeMillisLong long estimatedLaunchTimeMillis)", "public void setEstimatedLaunchTimesMillis(@NonNull Map<String, Long> estimatedLaunchTimesMillis)", "public void registerAppUsageObserver(int observerId, @NonNull String[] observedEntities, long timeLimit, @NonNull TimeUnit timeUnit, @NonNull PendingIntent callbackIntent)", "public void unregisterAppUsageObserver(int observerId)", "public void registerUsageSessionObserver(int sessionObserverId, @NonNull String[] observedEntities, @NonNull Duration timeLimit, @NonNull Duration sessionThresholdTime, @NonNull PendingIntent limitReachedCallbackIntent, @Nullable PendingIntent sessionEndCallbackIntent)", "public void unregisterUsageSessionObserver(int sessionObserverId)", "public void registerAppUsageLimitObserver(int observerId, @NonNull String[] observedEntities, @NonNull Duration timeLimit, @NonNull Duration timeUsed, @Nullable PendingIntent callbackIntent)", "public void unregisterAppUsageLimitObserver(int observerId)", "public void reportUserInteraction(@NonNull String packageName, int userId)", "public void reportUserInteraction(@NonNull String packageName, @UserIdInt int userId, @NonNull PersistableBundle extras)", "public void reportUsageStart(@NonNull Activity activity, @NonNull String token)", "public void reportUsageStart(@NonNull Activity activity, @NonNull String token, long timeAgoMs)", "public void reportUsageStop(@NonNull Activity activity, @NonNull String token)", "public int getUsageSource()", "public void forceUsageSourceSettingRead()", "public static String reasonToString(int standbyReason)", "public static String usageSourceToString(int usageSource)", "public static String standbyBucketToString(int standbyBucket)", "public void whitelistAppTemporarily(String packageName, long duration, UserHandle user)", "public void onCarrierPrivilegedAppsChanged()", "public void reportChooserSelection(String packageName, int userId, String contentType, String[] annotations, String action)", "public long getLastTimeAnyComponentUsed(@NonNull String packageName)", "public List<BroadcastResponseStats> queryBroadcastResponseStats(@Nullable String packageName, @IntRange(from = 0) long id)", "public void clearBroadcastResponseStats(@Nullable String packageName, @IntRange(from = 0) long id)", "public void clearBroadcastEvents()", "public boolean isPackageExemptedFromBroadcastResponseStats(@NonNull String packageName)", "public String getAppStandbyConstant(@NonNull String key)" ],
  "variableNames" : [ "INTERVAL_DAILY", "INTERVAL_WEEKLY", "INTERVAL_MONTHLY", "INTERVAL_YEARLY", "INTERVAL_BEST", "INTERVAL_COUNT", "STANDBY_BUCKET_EXEMPTED", "STANDBY_BUCKET_ACTIVE", "STANDBY_BUCKET_WORKING_SET", "STANDBY_BUCKET_FREQUENT", "STANDBY_BUCKET_RARE", "STANDBY_BUCKET_RESTRICTED", "STANDBY_BUCKET_NEVER", "REASON_MAIN_MASK", "REASON_MAIN_DEFAULT", "REASON_MAIN_TIMEOUT", "REASON_MAIN_USAGE", "REASON_MAIN_FORCED_BY_USER", "REASON_MAIN_PREDICTED", "REASON_MAIN_FORCED_BY_SYSTEM", "REASON_SUB_MASK", "REASON_SUB_DEFAULT_UNDEFINED", "REASON_SUB_DEFAULT_APP_UPDATE", "REASON_SUB_DEFAULT_APP_RESTORED", "REASON_SUB_USAGE_SYSTEM_INTERACTION", "REASON_SUB_USAGE_NOTIFICATION_SEEN", "REASON_SUB_USAGE_USER_INTERACTION", "REASON_SUB_USAGE_MOVE_TO_FOREGROUND", "REASON_SUB_USAGE_MOVE_TO_BACKGROUND", "REASON_SUB_USAGE_SYSTEM_UPDATE", "REASON_SUB_USAGE_ACTIVE_TIMEOUT", "REASON_SUB_USAGE_SYNC_ADAPTER", "REASON_SUB_USAGE_SLICE_PINNED", "REASON_SUB_USAGE_SLICE_PINNED_PRIV", "REASON_SUB_USAGE_EXEMPTED_SYNC_SCHEDULED_NON_DOZE", "REASON_SUB_USAGE_EXEMPTED_SYNC_SCHEDULED_DOZE", "REASON_SUB_USAGE_EXEMPTED_SYNC_START", "REASON_SUB_USAGE_UNEXEMPTED_SYNC_SCHEDULED", "REASON_SUB_USAGE_FOREGROUND_SERVICE_START", "REASON_SUB_PREDICTED_RESTORED", "REASON_SUB_FORCED_SYSTEM_FLAG_UNDEFINED", "REASON_SUB_FORCED_SYSTEM_FLAG_BACKGROUND_RESOURCE_USAGE", "REASON_SUB_FORCED_SYSTEM_FLAG_ABUSE", "REASON_SUB_FORCED_SYSTEM_FLAG_BUGGY", "REASON_SUB_FORCED_USER_FLAG_INTERACTION", "EXTRA_OBSERVER_ID", "EXTRA_TIME_LIMIT", "EXTRA_TIME_USED", "EXTRA_EVENT_CATEGORY", "EXTRA_EVENT_ACTION", "USAGE_SOURCE_TASK_ROOT_ACTIVITY", "USAGE_SOURCE_CURRENT_ACTIVITY", "sEmptyResults", "mContext", "mService" ]
}