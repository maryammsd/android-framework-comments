{
  "filePath" : "/home/maryam/clearblue/files/android-source-35/org/apache/xml/serializer/ToStream.java",
  "packageName" : "org.apache.xml.serializer",
  "className" : "ToStream",
  "comment" : "\n * This abstract class is a base class for other stream \n * serializers (xml, html, text ...) that write output to a stream.\n * \n * @xsl.usage internal\n ",
  "links" : [ ],
  "variables" : [ {
    "name" : "COMMENT_BEGIN",
    "type" : "String",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "COMMENT_END",
    "type" : "String",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "m_disableOutputEscapingStates",
    "type" : "BoolStack",
    "comment" : " Stack to keep track of disabling output escaping. ",
    "links" : [ ]
  }, {
    "name" : "m_encodingInfo",
    "type" : "EncodingInfo",
    "comment" : "\n     * The encoding information associated with this serializer.\n     * Although initially there is no encoding,\n     * there is a dummy EncodingInfo object that will say\n     * that every character is in the encoding. This is useful\n     * for a serializer that is in temporary output state and has\n     * no associated encoding. A serializer in final output state\n     * will have an encoding, and will worry about whether \n     * single chars or surrogate pairs of high/low chars form\n     * characters in the output encoding. \n     ",
    "links" : [ ]
  }, {
    "name" : "m_preserves",
    "type" : "BoolStack",
    "comment" : "\n     * Stack to keep track of whether or not we need to\n     * preserve whitespace.\n     * \n     * Used to push/pop values used for the field m_ispreserve, but\n     * m_ispreserve is only relevant if m_doIndent is true.\n     * If m_doIndent is false this field has no impact.\n     * \n     ",
    "links" : [ ]
  }, {
    "name" : "m_ispreserve",
    "type" : "boolean",
    "comment" : "\n     * State flag to tell if preservation of whitespace\n     * is important. \n     * \n     * Used only in shouldIndent() but only if m_doIndent is true.\n     * If m_doIndent is false this flag has no impact.\n     * \n     ",
    "links" : [ ]
  }, {
    "name" : "m_isprevtext",
    "type" : "boolean",
    "comment" : "\n     * State flag that tells if the previous node processed\n     * was text, so we can tell if we should preserve whitespace.\n     * \n     * Used in endDocument() and shouldIndent() but\n     * only if m_doIndent is true. \n     * If m_doIndent is false this flag has no impact.\n     ",
    "links" : [ ]
  }, {
    "name" : "s_systemLineSep",
    "type" : "char[]",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "m_lineSep",
    "type" : "char[]",
    "comment" : "\n     * The system line separator for writing out line breaks.\n     * The default value is from the system property,\n     * but this value can be set through the xsl:output\n     * extension attribute xalan:line-separator.\n     ",
    "links" : [ ]
  }, {
    "name" : "m_lineSepUse",
    "type" : "boolean",
    "comment" : "\n     * True if the the system line separator is to be used.\n     ",
    "links" : [ ]
  }, {
    "name" : "m_lineSepLen",
    "type" : "int",
    "comment" : "\n     * The length of the line seperator, since the write is done\n     * one character at a time.\n     ",
    "links" : [ ]
  }, {
    "name" : "m_charInfo",
    "type" : "CharInfo",
    "comment" : "\n     * Map that tells which characters should have special treatment, and it\n     *  provides character to entity name lookup.\n     ",
    "links" : [ ]
  }, {
    "name" : "m_shouldFlush",
    "type" : "boolean",
    "comment" : " True if we control the buffer, and we should flush the output on endDocument. ",
    "links" : [ ]
  }, {
    "name" : "m_spaceBeforeClose",
    "type" : "boolean",
    "comment" : "\n     * Add space before '/>' for XHTML.\n     ",
    "links" : [ ]
  }, {
    "name" : "m_startNewLine",
    "type" : "boolean",
    "comment" : "\n     * Flag to signal that a newline should be added.\n     * \n     * Used only in indent() which is called only if m_doIndent is true.\n     * If m_doIndent is false this flag has no impact.\n     ",
    "links" : [ ]
  }, {
    "name" : "m_inDoctype",
    "type" : "boolean",
    "comment" : "\n     * Tells if we're in an internal document type subset.\n     ",
    "links" : [ ]
  }, {
    "name" : "m_isUTF8",
    "type" : "boolean",
    "comment" : "\n       * Flag to quickly tell if the encoding is UTF8.\n       ",
    "links" : [ ]
  }, {
    "name" : "m_cdataStartCalled",
    "type" : "boolean",
    "comment" : "\n     * remembers if we are in between the startCDATA() and endCDATA() callbacks\n     ",
    "links" : [ ]
  }, {
    "name" : "m_expandDTDEntities",
    "type" : "boolean",
    "comment" : "\n     * If this flag is true DTD entity references are not left as-is,\n     * which is exiting older behavior.\n     ",
    "links" : [ ]
  }, {
    "name" : "m_escaping",
    "type" : "boolean",
    "comment" : "\n     * Taken from XSLTC \n     ",
    "links" : [ ]
  }, {
    "name" : "m_outputStream",
    "type" : "OutputStream",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "m_writer_set_by_user",
    "type" : "boolean",
    "comment" : "",
    "links" : [ ]
  } ],
  "methods" : [ {
    "name" : "protected void closeCDATA() throws org.xml.sax.SAXException",
    "returnType" : "void",
    "comment" : "\n     * This helper method to writes out \"]]>\" when closing a CDATA section.\n     *\n     * @throws org.xml.sax.SAXException\n     ",
    "links" : [ ]
  }, {
    "name" : "public void serialize(Node node) throws IOException",
    "returnType" : "void",
    "comment" : "\n     * Serializes the DOM node. Throws an exception only if an I/O\n     * exception occured while serializing.\n     *\n     * @param node Node to serialize.\n     * @throws IOException An I/O exception occured while serializing\n     ",
    "links" : [ ]
  }, {
    "name" : "protected final void flushWriter() throws org.xml.sax.SAXException",
    "returnType" : "void",
    "comment" : "\n     * Flush the formatter's result stream.\n     *\n     * @throws org.xml.sax.SAXException\n     ",
    "links" : [ ]
  }, {
    "name" : "public OutputStream getOutputStream()",
    "returnType" : "OutputStream",
    "comment" : "\n     * Get the output stream where the events will be serialized to.\n     *\n     * @return reference to the result stream, or null of only a writer was\n     * set.\n     ",
    "links" : [ ]
  }, {
    "name" : "public void elementDecl(String name, String model) throws SAXException",
    "returnType" : "void",
    "comment" : "\n     *   Report an element type declaration.\n     *  \n     *   <p>The content model will consist of the string \"EMPTY\", the\n     *   string \"ANY\", or a parenthesised group, optionally followed\n     *   by an occurrence indicator.  The model will be normalized so\n     *   that all whitespace is removed,and will include the enclosing\n     *   parentheses.</p>\n     *  \n     *   @param name The element type name.\n     *   @param model The content model as a normalized string.\n     *   @exception SAXException The application may raise an exception.\n     ",
    "links" : [ ]
  }, {
    "name" : "public void internalEntityDecl(String name, String value) throws SAXException",
    "returnType" : "void",
    "comment" : "\n     * Report an internal entity declaration.\n     *\n     * <p>Only the effective (first) declaration for each entity\n     * will be reported.</p>\n     *\n     * @param name The name of the entity.  If it is a parameter\n     *        entity, the name will begin with '%'.\n     * @param value The replacement text of the entity.\n     * @exception SAXException The application may raise an exception.\n     * @see #externalEntityDecl\n     * @see org.xml.sax.DTDHandler#unparsedEntityDecl\n     ",
    "links" : [ ]
  }, {
    "name" : " void outputEntityDecl(String name, String value) throws IOException",
    "returnType" : "void",
    "comment" : "\n     * Output the doc type declaration.\n     *\n     * @param name non-null reference to document type name.\n     * NEEDSDOC @param value\n     *\n     * @throws org.xml.sax.SAXException\n     ",
    "links" : [ ]
  }, {
    "name" : "protected final void outputLineSep() throws IOException",
    "returnType" : "void",
    "comment" : "\n     * Output a system-dependent line break.\n     *\n     * @throws org.xml.sax.SAXException\n     ",
    "links" : [ ]
  }, {
    "name" : " void setProp(String name, String val, boolean defaultVal)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public void setOutputFormat(Properties format)",
    "returnType" : "void",
    "comment" : "\n     * Specifies an output format for this serializer. It the\n     * serializer has already been associated with an output format,\n     * it will switch to the new format. This method should not be\n     * called while the serializer is in the process of serializing\n     * a document.\n     *\n     * @param format The output format to use\n     ",
    "links" : [ ]
  }, {
    "name" : "public Properties getOutputFormat()",
    "returnType" : "Properties",
    "comment" : "\n     * Returns the output format for this serializer.\n     *\n     * @return The output format in use\n     ",
    "links" : [ ]
  }, {
    "name" : "public void setWriter(Writer writer)",
    "returnType" : "void",
    "comment" : "\n     * Specifies a writer to which the document should be serialized.\n     * This method should not be called while the serializer is in\n     * the process of serializing a document.\n     *\n     * @param writer The output writer stream\n     ",
    "links" : [ ]
  }, {
    "name" : "private void setWriterInternal(Writer writer, boolean setByUser)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public boolean setLineSepUse(boolean use_sytem_line_break)",
    "returnType" : "boolean",
    "comment" : "\n     * Set if the operating systems end-of-line line separator should\n     * be used when serializing.  If set false NL character \n     * (decimal 10) is left alone, otherwise the new-line will be replaced on\n     * output with the systems line separator. For example on UNIX this is\n     * NL, while on Windows it is two characters, CR NL, where CR is the\n     * carriage-return (decimal 13).\n     *  \n     * @param use_sytem_line_break True if an input NL is replaced with the \n     * operating systems end-of-line separator.\n     * @return The previously set value of the serializer.\n     ",
    "links" : [ ]
  }, {
    "name" : "public void setOutputStream(OutputStream output)",
    "returnType" : "void",
    "comment" : "\n     * Specifies an output stream to which the document should be\n     * serialized. This method should not be called while the\n     * serializer is in the process of serializing a document.\n     * <p>\n     * The encoding specified in the output properties is used, or\n     * if no encoding was specified, the default for the selected\n     * output method.\n     *\n     * @param output The output stream\n     ",
    "links" : [ ]
  }, {
    "name" : "private void setOutputStreamInternal(OutputStream output, boolean setByUser)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public boolean setEscaping(boolean escape)",
    "returnType" : "boolean",
    "comment" : "\n     * @see SerializationHandler#setEscaping(boolean)\n     ",
    "links" : [ ]
  }, {
    "name" : "protected void indent(int depth) throws IOException",
    "returnType" : "void",
    "comment" : "\n     * Might print a newline character and the indentation amount\n     * of the given depth.\n     * \n     * @param depth the indentation depth (element nesting depth)\n     *\n     * @throws org.xml.sax.SAXException if an error occurs during writing.\n     ",
    "links" : [ ]
  }, {
    "name" : "protected void indent() throws IOException",
    "returnType" : "void",
    "comment" : "\n     * Indent at the current element nesting depth.\n     * @throws IOException\n     ",
    "links" : [ ]
  }, {
    "name" : "private void printSpace(int n) throws IOException",
    "returnType" : "void",
    "comment" : "\n     * Prints <var>n</var> spaces.\n     * @param n         Number of spaces to print.\n     *\n     * @throws org.xml.sax.SAXException if an error occurs when writing.\n     ",
    "links" : [ ]
  }, {
    "name" : "public void attributeDecl(String eName, String aName, String type, String valueDefault, String value) throws SAXException",
    "returnType" : "void",
    "comment" : "\n     * Report an attribute type declaration.\n     *\n     * <p>Only the effective (first) declaration for an attribute will\n     * be reported.  The type will be one of the strings \"CDATA\",\n     * \"ID\", \"IDREF\", \"IDREFS\", \"NMTOKEN\", \"NMTOKENS\", \"ENTITY\",\n     * \"ENTITIES\", or \"NOTATION\", or a parenthesized token group with\n     * the separator \"|\" and all whitespace removed.</p>\n     *\n     * @param eName The name of the associated element.\n     * @param aName The name of the attribute.\n     * @param type A string representing the attribute type.\n     * @param valueDefault A string representing the attribute default\n     *        (\"#IMPLIED\", \"#REQUIRED\", or \"#FIXED\") or null if\n     *        none of these applies.\n     * @param value A string representing the attribute's default value,\n     *        or null if there is none.\n     * @exception SAXException The application may raise an exception.\n     ",
    "links" : [ ]
  }, {
    "name" : "public Writer getWriter()",
    "returnType" : "Writer",
    "comment" : "\n     * Get the character stream where the events will be serialized to.\n     *\n     * @return Reference to the result Writer, or null.\n     ",
    "links" : [ ]
  }, {
    "name" : "public void externalEntityDecl(String name, String publicId, String systemId) throws SAXException",
    "returnType" : "void",
    "comment" : "\n     * Report a parsed external entity declaration.\n     *\n     * <p>Only the effective (first) declaration for each entity\n     * will be reported.</p>\n     *\n     * @param name The name of the entity.  If it is a parameter\n     *        entity, the name will begin with '%'.\n     * @param publicId The declared public identifier of the entity, or\n     *        null if none was declared.\n     * @param systemId The declared system identifier of the entity.\n     * @exception SAXException The application may raise an exception.\n     * @see #internalEntityDecl\n     * @see org.xml.sax.DTDHandler#unparsedEntityDecl\n     ",
    "links" : [ ]
  }, {
    "name" : "protected boolean escapingNotNeeded(char ch)",
    "returnType" : "boolean",
    "comment" : "\n     * Tell if this character can be written without escaping.\n     ",
    "links" : [ ]
  }, {
    "name" : "protected int writeUTF16Surrogate(char c, char[] ch, int i, int end) throws IOException",
    "returnType" : "int",
    "comment" : "\n     * Once a surrogate has been detected, write out the pair of\n     * characters if it is in the encoding, or if there is no\n     * encoding, otherwise write out an entity reference\n     * of the value of the unicode code point of the character\n     * represented by the high/low surrogate pair.\n     * <p>\n     * An exception is thrown if there is no low surrogate in the pair,\n     * because the array ends unexpectely, or if the low char is there\n     * but its value is such that it is not a low surrogate.\n     *\n     * @param c the first (high) part of the surrogate, which\n     * must be confirmed before calling this method.\n     * @param ch Character array.\n     * @param i position Where the surrogate was detected.\n     * @param end The end index of the significant characters.\n     * @return 0 if the pair of characters was written out as-is,\n     * the unicode code point of the character represented by\n     * the surrogate pair if an entity reference with that value\n     * was written out. \n     * \n     * @throws IOException\n     * @throws org.xml.sax.SAXException if invalid UTF-16 surrogate detected.\n     ",
    "links" : [ ]
  }, {
    "name" : " int accumDefaultEntity(java.io.Writer writer, char ch, int i, char[] chars, int len, boolean fromTextNode, boolean escLF) throws IOException",
    "returnType" : "int",
    "comment" : "\n     * Handle one of the default entities, return false if it\n     * is not a default entity.\n     *\n     * @param ch character to be escaped.\n     * @param i index into character array.\n     * @param chars non-null reference to character array.\n     * @param len length of chars.\n     * @param fromTextNode true if the characters being processed\n     * are from a text node, false if they are from an attribute value\n     * @param escLF true if the linefeed should be escaped.\n     *\n     * @return i+1 if the character was written, else i.\n     *\n     * @throws java.io.IOException\n     ",
    "links" : [ ]
  }, {
    "name" : " void writeNormalizedChars(char[] ch, int start, int length, boolean isCData, boolean useSystemLineSeparator) throws IOException, org.xml.sax.SAXException",
    "returnType" : "void",
    "comment" : "\n     * Normalize the characters, but don't escape.\n     *\n     * @param ch The characters from the XML document.\n     * @param start The start position in the array.\n     * @param length The number of characters to read from the array.\n     * @param isCData true if a CDATA block should be built around the characters.\n     * @param useSystemLineSeparator true if the operating systems \n     * end-of-line separator should be output rather than a new-line character.\n     *\n     * @throws IOException\n     * @throws org.xml.sax.SAXException\n     ",
    "links" : [ ]
  }, {
    "name" : "public void endNonEscaping() throws org.xml.sax.SAXException",
    "returnType" : "void",
    "comment" : "\n     * Ends an un-escaping section.\n     *\n     * @see #startNonEscaping\n     *\n     * @throws org.xml.sax.SAXException\n     ",
    "links" : [ ]
  }, {
    "name" : "public void startNonEscaping() throws org.xml.sax.SAXException",
    "returnType" : "void",
    "comment" : "\n     * Starts an un-escaping section. All characters printed within an un-\n     * escaping section are printed as is, without escaping special characters\n     * into entity references. Only XML and HTML serializers need to support\n     * this method.\n     * <p> The contents of the un-escaping section will be delivered through the\n     * regular <tt>characters</tt> event.\n     *\n     * @throws org.xml.sax.SAXException\n     ",
    "links" : [ ]
  }, {
    "name" : "protected void cdata(char[] ch, int start, final int length) throws org.xml.sax.SAXException",
    "returnType" : "void",
    "comment" : "\n     * Receive notification of cdata.\n     *\n     * <p>The Parser will call this method to report each chunk of\n     * character data.  SAX parsers may return all contiguous character\n     * data in a single chunk, or they may split it into several\n     * chunks; however, all of the characters in any single event\n     * must come from the same external entity, so that the Locator\n     * provides useful information.</p>\n     *\n     * <p>The application must not attempt to read from the array\n     * outside of the specified range.</p>\n     *\n     * <p>Note that some parsers will report whitespace using the\n     * ignorableWhitespace() method rather than this one (validating\n     * parsers must do so).</p>\n     *\n     * @param ch The characters from the XML document.\n     * @param start The start position in the array.\n     * @param length The number of characters to read from the array.\n     * @throws org.xml.sax.SAXException Any SAX exception, possibly\n     *            wrapping another exception.\n     * @see #ignorableWhitespace\n     * @see org.xml.sax.Locator\n     *\n     * @throws org.xml.sax.SAXException\n     ",
    "links" : [ ]
  }, {
    "name" : "private boolean isEscapingDisabled()",
    "returnType" : "boolean",
    "comment" : "\n     * Tell if the character escaping should be disabled for the current state.\n     *\n     * @return true if the character escaping should be disabled.\n     ",
    "links" : [ ]
  }, {
    "name" : "protected void charactersRaw(char[] ch, int start, int length) throws org.xml.sax.SAXException",
    "returnType" : "void",
    "comment" : "\n     * If available, when the disable-output-escaping attribute is used,\n     * output raw text without escaping.\n     *\n     * @param ch The characters from the XML document.\n     * @param start The start position in the array.\n     * @param length The number of characters to read from the array.\n     *\n     * @throws org.xml.sax.SAXException\n     ",
    "links" : [ ]
  }, {
    "name" : "public void characters(final char[] chars, final int start, final int length) throws org.xml.sax.SAXException",
    "returnType" : "void",
    "comment" : "\n     * Receive notification of character data.\n     *\n     * <p>The Parser will call this method to report each chunk of\n     * character data.  SAX parsers may return all contiguous character\n     * data in a single chunk, or they may split it into several\n     * chunks; however, all of the characters in any single event\n     * must come from the same external entity, so that the Locator\n     * provides useful information.</p>\n     *\n     * <p>The application must not attempt to read from the array\n     * outside of the specified range.</p>\n     *\n     * <p>Note that some parsers will report whitespace using the\n     * ignorableWhitespace() method rather than this one (validating\n     * parsers must do so).</p>\n     *\n     * @param chars The characters from the XML document.\n     * @param start The start position in the array.\n     * @param length The number of characters to read from the array.\n     * @throws org.xml.sax.SAXException Any SAX exception, possibly\n     *            wrapping another exception.\n     * @see #ignorableWhitespace\n     * @see org.xml.sax.Locator\n     *\n     * @throws org.xml.sax.SAXException\n     ",
    "links" : [ ]
  }, {
    "name" : "private int processLineFeed(final char[] chars, int i, int lastProcessed, final Writer writer) throws IOException",
    "returnType" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private void writeOutCleanChars(final char[] chars, int i, int lastProcessed) throws IOException",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private static boolean isCharacterInC0orC1Range(char ch)",
    "returnType" : "boolean",
    "comment" : "\n     * This method checks if a given character is between C0 or C1 range\n     * of Control characters.\n     * This method is added to support Control Characters for XML 1.1\n     * If a given character is TAB (0x09), LF (0x0A) or CR (0x0D), this method\n     * return false. Since they are whitespace characters, no special processing is needed.\n     * \n     * @param ch\n     * @return boolean\n     ",
    "links" : [ ]
  }, {
    "name" : "private static boolean isNELorLSEPCharacter(char ch)",
    "returnType" : "boolean",
    "comment" : "\n     * This method checks if a given character either NEL (0x85) or LSEP (0x2028)\n     * These are new end of line charcters added in XML 1.1.  These characters must be\n     * written as Numeric Character References (NCR) in XML 1.1 output document.\n     * \n     * @param ch\n     * @return boolean\n     ",
    "links" : [ ]
  }, {
    "name" : "private int processDirty(char[] chars, int end, int i, char ch, int lastDirty, boolean fromTextNode) throws IOException",
    "returnType" : "int",
    "comment" : "\n     * Process a dirty character and any preeceding clean characters\n     * that were not yet processed.\n     * @param chars array of characters being processed\n     * @param end one (1) beyond the last character \n     * in chars to be processed\n     * @param i the index of the dirty character\n     * @param ch the character in chars[i]\n     * @param lastDirty the last dirty character previous to i\n     * @param fromTextNode true if the characters being processed are\n     * from a text node, false if they are from an attribute value.\n     * @return the index of the last character processed\n     ",
    "links" : [ ]
  }, {
    "name" : "public void characters(String s) throws org.xml.sax.SAXException",
    "returnType" : "void",
    "comment" : "\n     * Receive notification of character data.\n     *\n     * @param s The string of characters to process.\n     *\n     * @throws org.xml.sax.SAXException\n     ",
    "links" : [ ]
  }, {
    "name" : "private int accumDefaultEscape(Writer writer, char ch, int i, char[] chars, int len, boolean fromTextNode, boolean escLF) throws IOException",
    "returnType" : "int",
    "comment" : "\n     * Escape and writer.write a character.\n     *\n     * @param ch character to be escaped.\n     * @param i index into character array.\n     * @param chars non-null reference to character array.\n     * @param len length of chars.\n     * @param fromTextNode true if the characters being processed are\n     * from a text node, false if the characters being processed are from\n     * an attribute value.\n     * @param escLF true if the linefeed should be escaped.\n     *\n     * @return i+1 if a character was written, i+2 if two characters\n     * were written out, else return i.\n     *\n     * @throws org.xml.sax.SAXException\n     ",
    "links" : [ ]
  }, {
    "name" : "public void startElement(String namespaceURI, String localName, String name, Attributes atts) throws org.xml.sax.SAXException",
    "returnType" : "void",
    "comment" : "\n     * Receive notification of the beginning of an element, although this is a\n     * SAX method additional namespace or attribute information can occur before\n     * or after this call, that is associated with this element.\n     *\n     *\n     * @param namespaceURI The Namespace URI, or the empty string if the\n     *        element has no Namespace URI or if Namespace\n     *        processing is not being performed.\n     * @param localName The local name (without prefix), or the\n     *        empty string if Namespace processing is not being\n     *        performed.\n     * @param name The element type name.\n     * @param atts The attributes attached to the element, if any.\n     * @throws org.xml.sax.SAXException Any SAX exception, possibly\n     *            wrapping another exception.\n     * @see org.xml.sax.ContentHandler#startElement\n     * @see org.xml.sax.ContentHandler#endElement\n     * @see org.xml.sax.AttributeList\n     *\n     * @throws org.xml.sax.SAXException\n     ",
    "links" : [ ]
  }, {
    "name" : "public void startElement(String elementNamespaceURI, String elementLocalName, String elementName) throws SAXException",
    "returnType" : "void",
    "comment" : "\n      * Receive notification of the beginning of an element, additional\n      * namespace or attribute information can occur before or after this call,\n      * that is associated with this element.\n      *\n      *\n      * @param elementNamespaceURI The Namespace URI, or the empty string if the\n      *        element has no Namespace URI or if Namespace\n      *        processing is not being performed.\n      * @param elementLocalName The local name (without prefix), or the\n      *        empty string if Namespace processing is not being\n      *        performed.\n      * @param elementName The element type name.\n      * @throws org.xml.sax.SAXException Any SAX exception, possibly\n      *            wrapping another exception.\n      * @see org.xml.sax.ContentHandler#startElement\n      * @see org.xml.sax.ContentHandler#endElement\n      * @see org.xml.sax.AttributeList\n      *\n      * @throws org.xml.sax.SAXException\n      ",
    "links" : [ ]
  }, {
    "name" : "public void startElement(String elementName) throws SAXException",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : " void outputDocTypeDecl(String name, boolean closeDecl) throws SAXException",
    "returnType" : "void",
    "comment" : "\n     * Output the doc type declaration.\n     *\n     * @param name non-null reference to document type name.\n     * NEEDSDOC @param closeDecl\n     *\n     * @throws java.io.IOException\n     ",
    "links" : [ ]
  }, {
    "name" : "public void processAttributes(java.io.Writer writer, int nAttrs) throws IOException, SAXException",
    "returnType" : "void",
    "comment" : "\n     * Process the attributes, which means to write out the currently\n     * collected attributes to the writer. The attributes are not\n     * cleared by this method\n     * \n     * @param writer the writer to write processed attributes to.\n     * @param nAttrs the number of attributes in m_attributes \n     * to be processed\n     *\n     * @throws java.io.IOException\n     * @throws org.xml.sax.SAXException\n     ",
    "links" : [ ]
  }, {
    "name" : "public void writeAttrString(Writer writer, String string, String encoding) throws IOException",
    "returnType" : "void",
    "comment" : "\n     * Returns the specified <var>string</var> after substituting <VAR>specials</VAR>,\n     * and UTF-16 surrogates for chracter references <CODE>&amp;#xnn</CODE>.\n     *\n     * @param   string      String to convert to XML format.\n     * @param   encoding    CURRENTLY NOT IMPLEMENTED.\n     *\n     * @throws java.io.IOException\n     ",
    "links" : [ ]
  }, {
    "name" : "public void endElement(String namespaceURI, String localName, String name) throws org.xml.sax.SAXException",
    "returnType" : "void",
    "comment" : "\n     * Receive notification of the end of an element.\n     *\n     *\n     * @param namespaceURI The Namespace URI, or the empty string if the\n     *        element has no Namespace URI or if Namespace\n     *        processing is not being performed.\n     * @param localName The local name (without prefix), or the\n     *        empty string if Namespace processing is not being\n     *        performed.\n     * @param name The element type name\n     * @throws org.xml.sax.SAXException Any SAX exception, possibly\n     *            wrapping another exception.\n     *\n     * @throws org.xml.sax.SAXException\n     ",
    "links" : [ ]
  }, {
    "name" : "public void endElement(String name) throws org.xml.sax.SAXException",
    "returnType" : "void",
    "comment" : "\n     * Receive notification of the end of an element.\n     * @param name The element type name\n     * @throws org.xml.sax.SAXException Any SAX exception, possibly\n     *     wrapping another exception.\n     ",
    "links" : [ ]
  }, {
    "name" : "public void startPrefixMapping(String prefix, String uri) throws org.xml.sax.SAXException",
    "returnType" : "void",
    "comment" : "\n     * Begin the scope of a prefix-URI Namespace mapping\n     * just before another element is about to start.\n     * This call will close any open tags so that the prefix mapping\n     * will not apply to the current element, but the up comming child.\n     * \n     * @see org.xml.sax.ContentHandler#startPrefixMapping\n     * \n     * @param prefix The Namespace prefix being declared.\n     * @param uri The Namespace URI the prefix is mapped to.\n     * \n     * @throws org.xml.sax.SAXException The client may throw\n     *            an exception during processing.\n     * \n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean startPrefixMapping(String prefix, String uri, boolean shouldFlush) throws org.xml.sax.SAXException",
    "returnType" : "boolean",
    "comment" : "\n     * Handle a prefix/uri mapping, which is associated with a startElement()\n     * that is soon to follow. Need to close any open start tag to make\n     * sure than any name space attributes due to this event are associated wih\n     * the up comming element, not the current one.\n     * @see ExtendedContentHandler#startPrefixMapping\n     *\n     * @param prefix The Namespace prefix being declared.\n     * @param uri The Namespace URI the prefix is mapped to.\n     * @param shouldFlush true if any open tags need to be closed first, this\n     * will impact which element the mapping applies to (open parent, or its up\n     * comming child)\n     * @return returns true if the call made a change to the current \n     * namespace information, false if it did not change anything, e.g. if the\n     * prefix/namespace mapping was already in scope from before.\n     * \n     * @throws org.xml.sax.SAXException The client may throw\n     *            an exception during processing.\n     *\n     *\n     ",
    "links" : [ ]
  }, {
    "name" : "public void comment(char[] ch, int start, int length) throws org.xml.sax.SAXException",
    "returnType" : "void",
    "comment" : "\n     * Receive notification of an XML comment anywhere in the document. This\n     * callback will be used for comments inside or outside the document\n     * element, including comments in the external DTD subset (if read).\n     * @param ch An array holding the characters in the comment.\n     * @param start The starting position in the array.\n     * @param length The number of characters to use from the array.\n     * @throws org.xml.sax.SAXException The application may raise an exception.\n     ",
    "links" : [ ]
  }, {
    "name" : "public void endCDATA() throws org.xml.sax.SAXException",
    "returnType" : "void",
    "comment" : "\n     * Report the end of a CDATA section.\n     * @throws org.xml.sax.SAXException The application may raise an exception.\n     *\n     *  @see  #startCDATA\n     ",
    "links" : [ ]
  }, {
    "name" : "public void endDTD() throws org.xml.sax.SAXException",
    "returnType" : "void",
    "comment" : "\n     * Report the end of DTD declarations.\n     * @throws org.xml.sax.SAXException The application may raise an exception.\n     * @see #startDTD\n     ",
    "links" : [ ]
  }, {
    "name" : "public void endPrefixMapping(String prefix) throws org.xml.sax.SAXException",
    "returnType" : "void",
    "comment" : "\n     * End the scope of a prefix-URI Namespace mapping.\n     * @see org.xml.sax.ContentHandler#endPrefixMapping\n     * \n     * @param prefix The prefix that was being mapping.\n     * @throws org.xml.sax.SAXException The client may throw\n     *            an exception during processing.\n     ",
    "links" : [ ]
  }, {
    "name" : "public void ignorableWhitespace(char[] ch, int start, int length) throws org.xml.sax.SAXException",
    "returnType" : "void",
    "comment" : "\n     * Receive notification of ignorable whitespace in element content.\n     * \n     * Not sure how to get this invoked quite yet.\n     * \n     * @param ch The characters from the XML document.\n     * @param start The start position in the array.\n     * @param length The number of characters to read from the array.\n     * @throws org.xml.sax.SAXException Any SAX exception, possibly\n     *            wrapping another exception.\n     * @see #characters\n     * \n     * @throws org.xml.sax.SAXException\n     ",
    "links" : [ ]
  }, {
    "name" : "public void skippedEntity(String name) throws org.xml.sax.SAXException",
    "returnType" : "void",
    "comment" : "\n     * Receive notification of a skipped entity.\n     * @see org.xml.sax.ContentHandler#skippedEntity\n     * \n     * @param name The name of the skipped entity.  If it is a\n     *       parameter                   entity, the name will begin with '%',\n     * and if it is the external DTD subset, it will be the string\n     * \"[dtd]\".\n     * @throws org.xml.sax.SAXException Any SAX exception, possibly wrapping\n     * another exception.\n     ",
    "links" : [ ]
  }, {
    "name" : "public void startCDATA() throws org.xml.sax.SAXException",
    "returnType" : "void",
    "comment" : "\n     * Report the start of a CDATA section.\n     * \n     * @throws org.xml.sax.SAXException The application may raise an exception.\n     * @see #endCDATA\n     ",
    "links" : [ ]
  }, {
    "name" : "public void startEntity(String name) throws org.xml.sax.SAXException",
    "returnType" : "void",
    "comment" : "\n     * Report the beginning of an entity.\n     * \n     * The start and end of the document entity are not reported.\n     * The start and end of the external DTD subset are reported\n     * using the pseudo-name \"[dtd]\".  All other events must be\n     * properly nested within start/end entity events.\n     * \n     * @param name The name of the entity.  If it is a parameter\n     *        entity, the name will begin with '%'.\n     * @throws org.xml.sax.SAXException The application may raise an exception.\n     * @see #endEntity\n     * @see org.xml.sax.ext.DeclHandler#internalEntityDecl\n     * @see org.xml.sax.ext.DeclHandler#externalEntityDecl\n     ",
    "links" : [ ]
  }, {
    "name" : "protected void closeStartTag() throws SAXException",
    "returnType" : "void",
    "comment" : "\n     * For the enclosing elements starting tag write out\n     * out any attributes followed by \">\"\n     *\n     * @throws org.xml.sax.SAXException\n     ",
    "links" : [ ]
  }, {
    "name" : "public void startDTD(String name, String publicId, String systemId) throws org.xml.sax.SAXException",
    "returnType" : "void",
    "comment" : "\n     * Report the start of DTD declarations, if any.\n     *\n     * Any declarations are assumed to be in the internal subset unless\n     * otherwise indicated.\n     * \n     * @param name The document type name.\n     * @param publicId The declared public identifier for the\n     *        external DTD subset, or null if none was declared.\n     * @param systemId The declared system identifier for the\n     *        external DTD subset, or null if none was declared.\n     * @throws org.xml.sax.SAXException The application may raise an\n     *            exception.\n     * @see #endDTD\n     * @see #startEntity\n     ",
    "links" : [ ]
  }, {
    "name" : "public int getIndentAmount()",
    "returnType" : "int",
    "comment" : "\n     * Returns the m_indentAmount.\n     * @return int\n     ",
    "links" : [ ]
  }, {
    "name" : "public void setIndentAmount(int m_indentAmount)",
    "returnType" : "void",
    "comment" : "\n     * Sets the m_indentAmount.\n     * \n     * @param m_indentAmount The m_indentAmount to set\n     ",
    "links" : [ ]
  }, {
    "name" : "protected boolean shouldIndent()",
    "returnType" : "boolean",
    "comment" : "\n     * Tell if, based on space preservation constraints and the doIndent property,\n     * if an indent should occur.\n     *\n     * @return True if an indent should occur.\n     ",
    "links" : [ ]
  }, {
    "name" : "private void setCdataSectionElements(String key, Properties props)",
    "returnType" : "void",
    "comment" : "\n     * Searches for the list of qname properties with the specified key in the\n     * property list. If the key is not found in this property list, the default\n     * property list, and its defaults, recursively, are then checked. The\n     * method returns <code>null</code> if the property is not found.\n     *\n     * @param   key   the property key.\n     * @param props the list of properties to search in.\n     * \n     * Sets the vector of local-name/URI pairs of the cdata section elements\n     * specified in the cdata-section-elements property.\n     * \n     * This method is essentially a copy of getQNameProperties() from\n     * OutputProperties. Eventually this method should go away and a call\n     * to setCdataSectionElements(Vector v) should be made directly.\n     ",
    "links" : [ ]
  }, {
    "name" : "private void addCdataSectionElement(String URI_and_localName, Vector v)",
    "returnType" : "void",
    "comment" : "\n     * Adds a URI/LocalName pair of strings to the list.\n     *\n     * @param URI_and_localName String of the form \"{uri}local\" or \"local\" \n     * \n     * @return a QName object\n     ",
    "links" : [ ]
  }, {
    "name" : "public void setCdataSectionElements(Vector URI_and_localNames)",
    "returnType" : "void",
    "comment" : "\n     * Remembers the cdata sections specified in the cdata-section-elements.\n     * The \"official way to set URI and localName pairs. \n     * This method should be used by both Xalan and XSLTC.\n     * \n     * @param URI_and_localNames a vector of pairs of Strings (URI/local)\n     ",
    "links" : [ ]
  }, {
    "name" : "protected String ensureAttributesNamespaceIsDeclared(String ns, String localName, String rawName) throws org.xml.sax.SAXException",
    "returnType" : "String",
    "comment" : "\n     * Makes sure that the namespace URI for the given qualified attribute name\n     * is declared.\n     * @param ns the namespace URI\n     * @param rawName the qualified name \n     * @return returns null if no action is taken, otherwise it returns the\n     * prefix used in declaring the namespace. \n     * @throws SAXException\n     ",
    "links" : [ ]
  }, {
    "name" : " void ensurePrefixIsDeclared(String ns, String rawName) throws org.xml.sax.SAXException",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public void flushPending() throws SAXException",
    "returnType" : "void",
    "comment" : "\n     * This method flushes any pending events, which can be startDocument()\n     * closing the opening tag of an element, or closing an open CDATA section.\n     ",
    "links" : [ ]
  }, {
    "name" : "public void setContentHandler(ContentHandler ch)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public boolean addAttributeAlways(String uri, String localName, String rawName, String type, String value, boolean xslAttribute)",
    "returnType" : "boolean",
    "comment" : "\n     * Adds the given attribute to the set of attributes, even if there is\n     * no currently open element. This is useful if a SAX startPrefixMapping()\n     * should need to add an attribute before the element name is seen.\n     * \n     * This method is a copy of its super classes method, except that some\n     * tracing of events is done.  This is so the tracing is only done for\n     * stream serializers, not for SAX ones.\n     *\n     * @param uri the URI of the attribute\n     * @param localName the local name of the attribute\n     * @param rawName   the qualified name of the attribute\n     * @param type the type of the attribute (probably CDATA)\n     * @param value the value of the attribute\n     * @param xslAttribute true if this attribute is coming from an xsl:attribute element.\n     * @return true if the attribute value was added, \n     * false if the attribute already existed and the value was\n     * replaced with the new value.\n     ",
    "links" : [ ]
  }, {
    "name" : "protected void firePseudoAttributes()",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public void setTransformer(Transformer transformer)",
    "returnType" : "void",
    "comment" : "\n     * @see SerializationHandler#setTransformer(Transformer)\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean reset()",
    "returnType" : "boolean",
    "comment" : "\n     * Try's to reset the super class and reset this class for \n     * re-use, so that you don't need to create a new serializer \n     * (mostly for performance reasons).\n     * \n     * @return true if the class was successfuly reset.\n     ",
    "links" : [ ]
  }, {
    "name" : "private void resetToStream()",
    "returnType" : "void",
    "comment" : "\n     * Reset all of the fields owned by ToStream class\n     *\n     ",
    "links" : [ ]
  }, {
    "name" : "public void setEncoding(String encoding)",
    "returnType" : "void",
    "comment" : "\n      * Sets the character encoding coming from the xsl:output encoding stylesheet attribute.\n      * @param encoding the character encoding\n      ",
    "links" : [ ]
  }, {
    "name" : "public void notationDecl(String name, String pubID, String sysID) throws SAXException",
    "returnType" : "void",
    "comment" : "\n     * If this method is called, the serializer is used as a\n     * DTDHandler, which changes behavior how the serializer \n     * handles document entities. \n     * @see org.xml.sax.DTDHandler#notationDecl(java.lang.String, java.lang.String, java.lang.String)\n     ",
    "links" : [ ]
  }, {
    "name" : "public void unparsedEntityDecl(String name, String pubID, String sysID, String notationName) throws SAXException",
    "returnType" : "void",
    "comment" : "\n     * If this method is called, the serializer is used as a\n     * DTDHandler, which changes behavior how the serializer \n     * handles document entities. \n     * @see org.xml.sax.DTDHandler#unparsedEntityDecl(java.lang.String, java.lang.String, java.lang.String, java.lang.String)\n     ",
    "links" : [ ]
  }, {
    "name" : "private void DTDprolog() throws SAXException, IOException",
    "returnType" : "void",
    "comment" : "\n     * A private helper method to output the \n     * @throws SAXException\n     * @throws IOException\n     ",
    "links" : [ ]
  }, {
    "name" : "public void setDTDEntityExpansion(boolean expand)",
    "returnType" : "void",
    "comment" : "\n     * If set to false the serializer does not expand DTD entities,\n     * but leaves them as is, the default value is true;\n     ",
    "links" : [ ]
  }, {
    "name" : "public void setNewLine(char[] eolChars)",
    "returnType" : "void",
    "comment" : "\n     * Sets the end of line characters to be used during serialization\n     * @param eolChars A character array corresponding to the characters to be used.\n     ",
    "links" : [ ]
  }, {
    "name" : "public void addCdataSectionElements(String URI_and_localNames)",
    "returnType" : "void",
    "comment" : "\n     * Remembers the cdata sections specified in the cdata-section-elements by appending the given\n     * cdata section elements to the list. This method can be called multiple times, but once an\n     * element is put in the list of cdata section elements it can not be removed.\n     * This method should be used by both Xalan and XSLTC.\n     * \n     * @param URI_and_localNames a whitespace separated list of element names, each element\n     * is a URI in curly braces (optional) and a local name. An example of such a parameter is:\n     * \"{http://company.com}price {myURI2}book chapter\"\n     ",
    "links" : [ ]
  } ],
  "methodNames" : [ "protected void closeCDATA() throws org.xml.sax.SAXException", "public void serialize(Node node) throws IOException", "protected final void flushWriter() throws org.xml.sax.SAXException", "public OutputStream getOutputStream()", "public void elementDecl(String name, String model) throws SAXException", "public void internalEntityDecl(String name, String value) throws SAXException", " void outputEntityDecl(String name, String value) throws IOException", "protected final void outputLineSep() throws IOException", " void setProp(String name, String val, boolean defaultVal)", "public void setOutputFormat(Properties format)", "public Properties getOutputFormat()", "public void setWriter(Writer writer)", "private void setWriterInternal(Writer writer, boolean setByUser)", "public boolean setLineSepUse(boolean use_sytem_line_break)", "public void setOutputStream(OutputStream output)", "private void setOutputStreamInternal(OutputStream output, boolean setByUser)", "public boolean setEscaping(boolean escape)", "protected void indent(int depth) throws IOException", "protected void indent() throws IOException", "private void printSpace(int n) throws IOException", "public void attributeDecl(String eName, String aName, String type, String valueDefault, String value) throws SAXException", "public Writer getWriter()", "public void externalEntityDecl(String name, String publicId, String systemId) throws SAXException", "protected boolean escapingNotNeeded(char ch)", "protected int writeUTF16Surrogate(char c, char[] ch, int i, int end) throws IOException", " int accumDefaultEntity(java.io.Writer writer, char ch, int i, char[] chars, int len, boolean fromTextNode, boolean escLF) throws IOException", " void writeNormalizedChars(char[] ch, int start, int length, boolean isCData, boolean useSystemLineSeparator) throws IOException, org.xml.sax.SAXException", "public void endNonEscaping() throws org.xml.sax.SAXException", "public void startNonEscaping() throws org.xml.sax.SAXException", "protected void cdata(char[] ch, int start, final int length) throws org.xml.sax.SAXException", "private boolean isEscapingDisabled()", "protected void charactersRaw(char[] ch, int start, int length) throws org.xml.sax.SAXException", "public void characters(final char[] chars, final int start, final int length) throws org.xml.sax.SAXException", "private int processLineFeed(final char[] chars, int i, int lastProcessed, final Writer writer) throws IOException", "private void writeOutCleanChars(final char[] chars, int i, int lastProcessed) throws IOException", "private static boolean isCharacterInC0orC1Range(char ch)", "private static boolean isNELorLSEPCharacter(char ch)", "private int processDirty(char[] chars, int end, int i, char ch, int lastDirty, boolean fromTextNode) throws IOException", "public void characters(String s) throws org.xml.sax.SAXException", "private int accumDefaultEscape(Writer writer, char ch, int i, char[] chars, int len, boolean fromTextNode, boolean escLF) throws IOException", "public void startElement(String namespaceURI, String localName, String name, Attributes atts) throws org.xml.sax.SAXException", "public void startElement(String elementNamespaceURI, String elementLocalName, String elementName) throws SAXException", "public void startElement(String elementName) throws SAXException", " void outputDocTypeDecl(String name, boolean closeDecl) throws SAXException", "public void processAttributes(java.io.Writer writer, int nAttrs) throws IOException, SAXException", "public void writeAttrString(Writer writer, String string, String encoding) throws IOException", "public void endElement(String namespaceURI, String localName, String name) throws org.xml.sax.SAXException", "public void endElement(String name) throws org.xml.sax.SAXException", "public void startPrefixMapping(String prefix, String uri) throws org.xml.sax.SAXException", "public boolean startPrefixMapping(String prefix, String uri, boolean shouldFlush) throws org.xml.sax.SAXException", "public void comment(char[] ch, int start, int length) throws org.xml.sax.SAXException", "public void endCDATA() throws org.xml.sax.SAXException", "public void endDTD() throws org.xml.sax.SAXException", "public void endPrefixMapping(String prefix) throws org.xml.sax.SAXException", "public void ignorableWhitespace(char[] ch, int start, int length) throws org.xml.sax.SAXException", "public void skippedEntity(String name) throws org.xml.sax.SAXException", "public void startCDATA() throws org.xml.sax.SAXException", "public void startEntity(String name) throws org.xml.sax.SAXException", "protected void closeStartTag() throws SAXException", "public void startDTD(String name, String publicId, String systemId) throws org.xml.sax.SAXException", "public int getIndentAmount()", "public void setIndentAmount(int m_indentAmount)", "protected boolean shouldIndent()", "private void setCdataSectionElements(String key, Properties props)", "private void addCdataSectionElement(String URI_and_localName, Vector v)", "public void setCdataSectionElements(Vector URI_and_localNames)", "protected String ensureAttributesNamespaceIsDeclared(String ns, String localName, String rawName) throws org.xml.sax.SAXException", " void ensurePrefixIsDeclared(String ns, String rawName) throws org.xml.sax.SAXException", "public void flushPending() throws SAXException", "public void setContentHandler(ContentHandler ch)", "public boolean addAttributeAlways(String uri, String localName, String rawName, String type, String value, boolean xslAttribute)", "protected void firePseudoAttributes()", "public void setTransformer(Transformer transformer)", "public boolean reset()", "private void resetToStream()", "public void setEncoding(String encoding)", "public void notationDecl(String name, String pubID, String sysID) throws SAXException", "public void unparsedEntityDecl(String name, String pubID, String sysID, String notationName) throws SAXException", "private void DTDprolog() throws SAXException, IOException", "public void setDTDEntityExpansion(boolean expand)", "public void setNewLine(char[] eolChars)", "public void addCdataSectionElements(String URI_and_localNames)" ],
  "variableNames" : [ "COMMENT_BEGIN", "COMMENT_END", "m_disableOutputEscapingStates", "m_encodingInfo", "m_preserves", "m_ispreserve", "m_isprevtext", "s_systemLineSep", "m_lineSep", "m_lineSepUse", "m_lineSepLen", "m_charInfo", "m_shouldFlush", "m_spaceBeforeClose", "m_startNewLine", "m_inDoctype", "m_isUTF8", "m_cdataStartCalled", "m_expandDTDEntities", "m_escaping", "m_outputStream", "m_writer_set_by_user" ]
}