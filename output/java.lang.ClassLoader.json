{
  "filePath" : "/home/maryam/clearblue/files/android-source-35/java/lang/ClassLoader.java",
  "packageName" : "java.lang",
  "className" : "ClassLoader",
  "comment" : "\n * A class loader is an object that is responsible for loading classes. The\n * class {@code ClassLoader} is an abstract class.  Given the <a\n * href=\"#binary-name\">binary name</a> of a class, a class loader should attempt to\n * locate or generate data that constitutes a definition for the class.  A\n * typical strategy is to transform the name into a file name and then read a\n * \"class file\" of that name from a file system.\n *\n * <p> Every {@link java.lang.Class Class} object contains a {@link\n * Class#getClassLoader() reference} to the {@code ClassLoader} that defined\n * it.\n *\n * <p> {@code Class} objects for array classes are not created by class\n * loaders, but are created automatically as required by the Java runtime.\n * The class loader for an array class, as returned by {@link\n * Class#getClassLoader()} is the same as the class loader for its element\n * type; if the element type is a primitive type, then the array class has no\n * class loader.\n *\n * <p> Applications implement subclasses of {@code ClassLoader} in order to\n * extend the manner in which the Java virtual machine dynamically loads\n * classes.\n *\n * <p> Class loaders may typically be used by security managers to indicate\n * security domains.\n *\n * <p> In addition to loading classes, a class loader is also responsible for\n * locating resources. A resource is some data (a \"{@code .class}\" file,\n * configuration data, or an image for example) that is identified with an\n * abstract '/'-separated path name. Resources are typically packaged with an\n * application or library so that they can be located by code in the\n * application or library. In some cases, the resources are included so that\n * they can be located by other libraries.\n *\n * <p> The {@code ClassLoader} class uses a delegation model to search for\n * classes and resources.  Each instance of {@code ClassLoader} has an\n * associated parent class loader. When requested to find a class or\n * resource, a {@code ClassLoader} instance will usually delegate the search\n * for the class or resource to its parent class loader before attempting to\n * find the class or resource itself.\n *\n * <p> Class loaders that support concurrent loading of classes are known as\n * <em>{@code #isRegisteredAsParallelCapable() parallel capable}</em> class\n * loaders and are required to register themselves at their class initialization\n * time by invoking the {@code\n * #registerAsParallelCapable ClassLoader.registerAsParallelCapable}\n * method. Note that the {@code ClassLoader} class is registered as parallel\n * capable by default. However, its subclasses still need to register themselves\n * if they are parallel capable.\n * In environments in which the delegation model is not strictly\n * hierarchical, class loaders need to be parallel capable, otherwise class\n * loading can lead to deadlocks because the loader lock is held for the\n * duration of the class loading process (see {@link #loadClass\n * loadClass} methods).\n *\n * <h2> <a id=\"builtinLoaders\">Run-time Built-in Class Loaders</a></h2>\n *\n * The Java run-time has the following built-in class loaders:\n *\n * <ul>\n * <li><p>Bootstrap class loader.\n *     It is the virtual machine's built-in class loader, typically represented\n *     as {@code null}, and does not have a parent.</li>\n * <li><p>{@linkplain #getSystemClassLoader() System class loader}.\n *     It is also known as <em>application class loader</em> and is distinct\n *     from the platform class loader.\n *     The system class loader is typically used to define classes on the\n *     application class path, module path, and JDK-specific tools.\n *     The platform class loader is the parent or an ancestor of the system class\n *     loader, so the system class loader can load platform classes by delegating\n *     to its parent.</li>\n * </ul>\n *\n * <p> Normally, the Java virtual machine loads classes from the local file\n * system in a platform-dependent manner.\n * However, some classes may not originate from a file; they may originate\n * from other sources, such as the network, or they could be constructed by an\n * application.  The method {@link #defineClass(String, byte[], int, int)\n * defineClass} converts an array of bytes into an instance of class\n * {@code Class}. Instances of this newly defined class can be created using\n * {@link Class#newInstance Class.newInstance}.\n *\n * <p> The methods and constructors of objects created by a class loader may\n * reference other classes.  To determine the class(es) referred to, the Java\n * virtual machine invokes the {@link #loadClass loadClass} method of\n * the class loader that originally created the class.\n *\n * <p> For example, an application could create a network class loader to\n * download class files from a server.  Sample code might look like:\n *\n * <blockquote><pre>\n *   ClassLoader loader&nbsp;= new NetworkClassLoader(host,&nbsp;port);\n *   Object main&nbsp;= loader.loadClass(\"Main\", true).newInstance();\n *       &nbsp;.&nbsp;.&nbsp;.\n * </pre></blockquote>\n *\n * <p> The network class loader subclass must define the methods {@link\n * #findClass findClass} and {@code loadClassData} to load a class\n * from the network.  Once it has downloaded the bytes that make up the class,\n * it should use the method {@link #defineClass defineClass} to\n * create a class instance.  A sample implementation is:\n *\n * <blockquote><pre>\n *     class NetworkClassLoader extends ClassLoader {\n *         String host;\n *         int port;\n *\n *         public Class findClass(String name) {\n *             byte[] b = loadClassData(name);\n *             return defineClass(name, b, 0, b.length);\n *         }\n *\n *         private byte[] loadClassData(String name) {\n *             // load the class data from the connection\n *             &nbsp;.&nbsp;.&nbsp;.\n *         }\n *     }\n * </pre></blockquote>\n *\n * <h3> <a id=\"binary-name\">Binary names</a> </h3>\n *\n * <p> Any class name provided as a {@code String} parameter to methods in\n * {@code ClassLoader} must be a binary name as defined by\n * <cite>The Java Language Specification</cite>.\n *\n * <p> Examples of valid class names include:\n * <blockquote><pre>\n *   \"java.lang.String\"\n *   \"javax.swing.JSpinner$DefaultEditor\"\n *   \"java.security.KeyStore$Builder$FileBuilder$1\"\n *   \"java.net.URLClassLoader$3$1\"\n * </pre></blockquote>\n *\n * <p> Any package name provided as a {@code String} parameter to methods in\n * {@code ClassLoader} must be either the empty string (denoting an unnamed package)\n * or a fully qualified name as defined by\n * <cite>The Java Language Specification</cite>.\n *\n * @jls 6.7 Fully Qualified Names\n * @jls 13.1 The Form of a Binary\n * @see      #resolveClass(Class)\n * @since 1.0\n * @revised 9\n ",
  "links" : [ "#loadClass", "#defineClass(String", "#findClass", "java.lang.Class#newInstance", "#defineClass", "java.lang.Class", "#loadClassloadClass", "java.lang.Class#getClassLoader()" ],
  "variables" : [ {
    "name" : "proxyCache",
    "type" : "Map<List<Class<?>>, Class<?>>",
    "comment" : "\n     * To avoid unloading individual classes, {@link java.lang.reflect.Proxy}\n     * only generates one class for each set of interfaces. This maps sets of\n     * interfaces to the proxy class that implements all of them. It is declared\n     * here so that these generated classes can be unloaded with their class\n     * loader.\n     *\n     * @hide\n     ",
    "links" : [ "java.lang.reflect.Proxy" ]
  }, {
    "name" : "parent",
    "type" : "ClassLoader",
    "comment" : " must be added *after* it.",
    "links" : [ ]
  }, {
    "name" : "name",
    "type" : "String",
    "comment" : " class loader name",
    "links" : [ ]
  }, {
    "name" : "packages",
    "type" : "Map<String, Package>",
    "comment" : "         = new ConcurrentHashMap<>();",
    "links" : [ ]
  }, {
    "name" : "allocator",
    "type" : "long",
    "comment" : "\n     * Pointer to the allocator used by the runtime to allocate metadata such\n     * as ArtFields and ArtMethods.\n     ",
    "links" : [ ]
  }, {
    "name" : "classTable",
    "type" : "long",
    "comment" : "\n     * Pointer to the class table, only used from within the runtime.\n     ",
    "links" : [ ]
  } ],
  "methods" : [ {
    "name" : "private static ClassLoader createSystemClassLoader()",
    "returnType" : "ClassLoader",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private static Void checkCreateClassLoader()",
    "returnType" : "Void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private static Void checkCreateClassLoader(String name)",
    "returnType" : "Void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public String getName()",
    "returnType" : "String",
    "comment" : "\n     * Returns the name of this class loader or {@code null} if\n     * this class loader is not named.\n     *\n     * @apiNote This method is non-final for compatibility.  If this\n     * method is overridden, this method must return the same name\n     * as specified when this class loader was instantiated.\n     *\n     * @return name of this class loader; or {@code null} if\n     * this class loader is not named.\n     *\n     * @since 9\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : " final String name()",
    "returnType" : "String",
    "comment" : " calling the overrideable getName method",
    "links" : [ ]
  }, {
    "name" : "public Class<?> loadClass(String name) throws ClassNotFoundException",
    "returnType" : "Class<?>",
    "comment" : "\n     * Loads the class with the specified <a href=\"#binary-name\">binary name</a>.\n     * This method searches for classes in the same manner as the {@link\n     * #loadClass(String, boolean)} method.  It is invoked by the Java virtual\n     * machine to resolve class references.  Invoking this method is equivalent\n     * to invoking {@link #loadClass(String, boolean) loadClass(name,\n     * false)}.\n     *\n     * @param   name\n     *          The <a href=\"#binary-name\">binary name</a> of the class\n     *\n     * @return  The resulting {@code Class} object\n     *\n     * @throws  ClassNotFoundException\n     *          If the class was not found\n     ",
    "links" : [ "#loadClass(String" ]
  }, {
    "name" : "protected Class<?> loadClass(String name, boolean resolve) throws ClassNotFoundException",
    "returnType" : "Class<?>",
    "comment" : "\n     * Loads the class with the specified <a href=\"#binary-name\">binary name</a>.  The\n     * default implementation of this method searches for classes in the\n     * following order:\n     *\n     * <ol>\n     *\n     *   <li><p> Invoke {@link #findLoadedClass(String)} to check if the class\n     *   has already been loaded.  </p></li>\n     *\n     *   <li><p> Invoke the {@link #loadClass(String) loadClass} method\n     *   on the parent class loader.  If the parent is {@code null} the class\n     *   loader built into the virtual machine is used, instead.  </p></li>\n     *\n     *   <li><p> Invoke the {@link #findClass(String)} method to find the\n     *   class.  </p></li>\n     *\n     * </ol>\n     *\n     * <p> If the class was found using the above steps, and the\n     * {@code resolve} flag is true, this method will then invoke the {@link\n     * #resolveClass(Class)} method on the resulting {@code Class} object.\n     *\n     * <p> Subclasses of {@code ClassLoader} are encouraged to override {@link\n     * #findClass(String)}, rather than this method.  </p>\n     *\n     * @param   name\n     *          The <a href=\"#binary-name\">binary name</a> of the class\n     *\n     * @param   resolve\n     *          If {@code true} then resolve the class\n     *\n     * @return  The resulting {@code Class} object\n     *\n     * @throws  ClassNotFoundException\n     *          If the class could not be found\n     ",
    "links" : [ "#findClass(String)", "#loadClass(String)", "#findLoadedClass(String)", "#resolveClass(Class)" ]
  }, {
    "name" : "protected Class<?> findClass(String name) throws ClassNotFoundException",
    "returnType" : "Class<?>",
    "comment" : "\n     * Finds the class with the specified <a href=\"#binary-name\">binary name</a>.\n     * This method should be overridden by class loader implementations that\n     * follow the delegation model for loading classes, and will be invoked by\n     * the {@link #loadClass loadClass} method after checking the\n     * parent class loader for the requested class.\n     *\n     * @implSpec The default implementation throws {@code ClassNotFoundException}.\n     *\n     * @param   name\n     *          The <a href=\"#binary-name\">binary name</a> of the class\n     *\n     * @return  The resulting {@code Class} object\n     *\n     * @throws  ClassNotFoundException\n     *          If the class could not be found\n     *\n     * @since  1.2\n     ",
    "links" : [ "#loadClass" ]
  }, {
    "name" : "protected final Class<?> defineClass(byte[] b, int off, int len) throws ClassFormatError",
    "returnType" : "Class<?>",
    "comment" : "\n     * Converts an array of bytes into an instance of class {@code Class}.\n     * Before the {@code Class} can be used it must be resolved.  This method\n     * is deprecated in favor of the version that takes a <a\n     * href=\"#binary-name\">binary name</a> as its first argument, and is more secure.\n     *\n     * @param  b\n     *         The bytes that make up the class data.  The bytes in positions\n     *         {@code off} through {@code off+len-1} should have the format\n     *         of a valid class file as defined by\n     *         <cite>The Java Virtual Machine Specification</cite>.\n     *\n     * @param  off\n     *         The start offset in {@code b} of the class data\n     *\n     * @param  len\n     *         The length of the class data\n     *\n     * @return  The {@code Class} object that was created from the specified\n     *          class data\n     *\n     * @throws  ClassFormatError\n     *          If the data did not contain a valid class\n     *\n     * @throws  IndexOutOfBoundsException\n     *          If either {@code off} or {@code len} is negative, or if\n     *          {@code off+len} is greater than {@code b.length}.\n     *\n     * @throws  SecurityException\n     *          If an attempt is made to add this class to a package that\n     *          contains classes that were signed by a different set of\n     *          certificates than this class, or if an attempt is made\n     *          to define a class in a package with a fully-qualified name\n     *          that starts with \"{@code java.}\".\n     *\n     * @see  #loadClass(String, boolean)\n     * @see  #resolveClass(Class)\n     *\n     * @deprecated  Replaced by {@link #defineClass(String, byte[], int, int)\n     * defineClass(String, byte[], int, int)}\n     ",
    "links" : [ "#defineClass(String" ]
  }, {
    "name" : "protected final Class<?> defineClass(String name, byte[] b, int off, int len) throws ClassFormatError",
    "returnType" : "Class<?>",
    "comment" : "\n     * Converts an array of bytes into an instance of class {@code Class}.\n     * Before the {@code Class} can be used it must be resolved.\n     *\n     * <p> This method assigns a default {@link java.security.ProtectionDomain\n     * ProtectionDomain} to the newly defined class.  The\n     * {@code ProtectionDomain} is effectively granted the same set of\n     * permissions returned when {@link\n     * java.security.Policy#getPermissions(java.security.CodeSource)\n     * Policy.getPolicy().getPermissions(new CodeSource(null, null))}\n     * is invoked.  The default protection domain is created on the first invocation\n     * of {@link #defineClass(String, byte[], int, int) defineClass},\n     * and re-used on subsequent invocations.\n     *\n     * <p> To assign a specific {@code ProtectionDomain} to the class, use\n     * the {@link #defineClass(String, byte[], int, int,\n     * java.security.ProtectionDomain) defineClass} method that takes a\n     * {@code ProtectionDomain} as one of its arguments.  </p>\n     *\n     * <p>\n     * This method defines a package in this class loader corresponding to the\n     * package of the {@code Class} (if such a package has not already been defined\n     * in this class loader). The name of the defined package is derived from\n     * the <a href=\"#binary-name\">binary name</a> of the class specified by\n     * the byte array {@code b}.\n     * Other properties of the defined package are as specified by {@link Package}.\n     *\n     * @param  name\n     *         The expected <a href=\"#binary-name\">binary name</a> of the class, or\n     *         {@code null} if not known\n     *\n     * @param  b\n     *         The bytes that make up the class data.  The bytes in positions\n     *         {@code off} through {@code off+len-1} should have the format\n     *         of a valid class file as defined by\n     *         <cite>The Java Virtual Machine Specification</cite>.\n     *\n     * @param  off\n     *         The start offset in {@code b} of the class data\n     *\n     * @param  len\n     *         The length of the class data\n     *\n     * @return  The {@code Class} object that was created from the specified\n     *          class data.\n     *\n     * @throws  ClassFormatError\n     *          If the data did not contain a valid class\n     *\n     * @throws  IndexOutOfBoundsException\n     *          If either {@code off} or {@code len} is negative, or if\n     *          {@code off+len} is greater than {@code b.length}.\n     *\n     * @throws  SecurityException\n     *          If an attempt is made to add this class to a package that\n     *          contains classes that were signed by a different set of\n     *          certificates than this class (which is unsigned), or if\n     *          {@code name} begins with \"{@code java.}\".\n     *\n     * @see  #loadClass(String, boolean)\n     * @see  #resolveClass(Class)\n     * @see  java.security.CodeSource\n     * @see  java.security.SecureClassLoader\n     *\n     * @since  1.1\n     * @revised 9\n     ",
    "links" : [ "java.security.Policy#getPermissions(java.security.CodeSource)", "#defineClass(String", "java.lang.Package", "java.security.ProtectionDomainProtectionDomain" ]
  }, {
    "name" : "protected final Class<?> defineClass(String name, byte[] b, int off, int len, ProtectionDomain protectionDomain) throws ClassFormatError",
    "returnType" : "Class<?>",
    "comment" : " Android-changed: Removed javadoc related to the getPlatformClassLoader().",
    "links" : [ ]
  }, {
    "name" : "protected final Class<?> defineClass(String name, java.nio.ByteBuffer b, ProtectionDomain protectionDomain) throws ClassFormatError",
    "returnType" : "Class<?>",
    "comment" : "\n     * Converts a {@link java.nio.ByteBuffer ByteBuffer} into an instance\n     * of class {@code Class}, with the given {@code ProtectionDomain}.\n     * If the given {@code ProtectionDomain} is {@code null}, then a default\n     * protection domain will be assigned to the class as\n     * specified in the documentation for {@link #defineClass(String, byte[],\n     * int, int)}.  Before the class can be used it must be resolved.\n     *\n     * <p>The rules about the first class defined in a package determining the\n     * set of certificates for the package, the restrictions on class names,\n     * and the defined package of the class\n     * are identical to those specified in the documentation for {@link\n     * #defineClass(String, byte[], int, int, ProtectionDomain)}.\n     *\n     * <p> An invocation of this method of the form\n     * <i>cl</i>{@code .defineClass(}<i>name</i>{@code ,}\n     * <i>bBuffer</i>{@code ,} <i>pd</i>{@code )} yields exactly the same\n     * result as the statements\n     *\n     *<p> <code>\n     * ...<br>\n     * byte[] temp = new byte[bBuffer.{@link\n     * java.nio.ByteBuffer#remaining remaining}()];<br>\n     *     bBuffer.{@link java.nio.ByteBuffer#get(byte[])\n     * get}(temp);<br>\n     *     return {@link #defineClass(String, byte[], int, int, ProtectionDomain)\n     * cl.defineClass}(name, temp, 0,\n     * temp.length, pd);<br>\n     * </code></p>\n     *\n     * @param  name\n     *         The expected <a href=\"#binary-name\">binary name</a>. of the class, or\n     *         {@code null} if not known\n     *\n     * @param  b\n     *         The bytes that make up the class data. The bytes from positions\n     *         {@code b.position()} through {@code b.position() + b.limit() -1\n     *         } should have the format of a valid class file as defined by\n     *         <cite>The Java Virtual Machine Specification</cite>.\n     *\n     * @param  protectionDomain\n     *         The {@code ProtectionDomain} of the class, or {@code null}.\n     *\n     * @return  The {@code Class} object created from the data,\n     *          and {@code ProtectionDomain}.\n     *\n     * @throws  ClassFormatError\n     *          If the data did not contain a valid class.\n     *\n     * @throws  NoClassDefFoundError\n     *          If {@code name} is not {@code null} and not equal to the\n     *          <a href=\"#binary-name\">binary name</a> of the class specified by {@code b}\n     *\n     * @throws  SecurityException\n     *          If an attempt is made to add this class to a package that\n     *          contains classes that were signed by a different set of\n     *          certificates than this class, or if {@code name} begins with\n     *          \"{@code java.}\".\n     *\n     * @see      #defineClass(String, byte[], int, int, ProtectionDomain)\n     *\n     * @since  1.5\n     * @revised 9\n     ",
    "links" : [ "#defineClass(String", "java.nio.ByteBuffer#get(byte", "java.nio.ByteBuffer", "java.nio.ByteBuffer#remaining" ]
  }, {
    "name" : "protected final void resolveClass(Class<?> c)",
    "returnType" : "void",
    "comment" : "\n     * Links the specified class.  This (misleadingly named) method may be\n     * used by a class loader to link a class.  If the class {@code c} has\n     * already been linked, then this method simply returns. Otherwise, the\n     * class is linked as described in the \"Execution\" chapter of\n     * <cite>The Java Language Specification</cite>.\n     *\n     * @param  c\n     *         The class to link\n     *\n     * @throws  NullPointerException\n     *          If {@code c} is {@code null}.\n     *\n     * @see  #defineClass(String, byte[], int, int)\n     ",
    "links" : [ ]
  }, {
    "name" : "protected final Class<?> findSystemClass(String name) throws ClassNotFoundException",
    "returnType" : "Class<?>",
    "comment" : "\n     * Finds a class with the specified <a href=\"#binary-name\">binary name</a>,\n     * loading it if necessary.\n     *\n     * <p> This method loads the class through the system class loader (see\n     * {@link #getSystemClassLoader()}).  The {@code Class} object returned\n     * might have more than one {@code ClassLoader} associated with it.\n     * Subclasses of {@code ClassLoader} need not usually invoke this method,\n     * because most class loaders need to override just {@link\n     * #findClass(String)}.  </p>\n     *\n     * @param  name\n     *         The <a href=\"#binary-name\">binary name</a> of the class\n     *\n     * @return  The {@code Class} object for the specified {@code name}\n     *\n     * @throws  ClassNotFoundException\n     *          If the class could not be found\n     *\n     * @see  #ClassLoader(ClassLoader)\n     * @see  #getParent()\n     ",
    "links" : [ "#findClass(String)", "#getSystemClassLoader()" ]
  }, {
    "name" : "private Class<?> findBootstrapClassOrNull(String name)",
    "returnType" : "Class<?>",
    "comment" : "\n    static Class<?> findBootstrapClassOrNull(String name) {\n        if (!checkName(name)) return null;\n\n        return findBootstrapClass(name);\n    }\n\n    // return null if not found\n    private static native Class<?> findBootstrapClass(String name);\n    ",
    "links" : [ ]
  }, {
    "name" : "protected final Class<?> findLoadedClass(String name)",
    "returnType" : "Class<?>",
    "comment" : "\n     * Returns the class with the given <a href=\"#binary-name\">binary name</a> if this\n     * loader has been recorded by the Java virtual machine as an initiating\n     * loader of a class with that <a href=\"#binary-name\">binary name</a>.  Otherwise\n     * {@code null} is returned.\n     *\n     * @param  name\n     *         The <a href=\"#binary-name\">binary name</a> of the class\n     *\n     * @return  The {@code Class} object, or {@code null} if the class has\n     *          not been loaded\n     *\n     * @since  1.1\n     ",
    "links" : [ ]
  }, {
    "name" : "protected final void setSigners(Class<?> c, Object[] signers)",
    "returnType" : "void",
    "comment" : "\n     * Sets the signers of a class.  This should be invoked after defining a\n     * class.\n     *\n     * @param  c\n     *         The {@code Class} object\n     *\n     * @param  signers\n     *         The signers for the class\n     *\n     * @since  1.1\n     ",
    "links" : [ ]
  }, {
    "name" : "public URL getResource(String name)",
    "returnType" : "URL",
    "comment" : "\n     * Finds the resource with the given name.  A resource is some data\n     * (images, audio, text, etc) that can be accessed by class code in a way\n     * that is independent of the location of the code.\n     *\n     * <p> The name of a resource is a '{@code /}'-separated path name thatf\n     * identifies the resource. </p>\n     *\n     * @implSpec The default implementation will first search the parent class\n     * loader for the resource; if the parent is {@code null} the path of the\n     * class loader built into the virtual machine is searched. If not found,\n     * this method will invoke {@link #findResource(String)} to find the resource.\n     *\n     * @apiNote Where several modules are defined to the same class loader,\n     * and where more than one module contains a resource with the given name,\n     * then the ordering that modules are searched is not specified and may be\n     * very unpredictable.\n     * When overriding this method it is recommended that an implementation\n     * ensures that any delegation is consistent with the {@link\n     * #getResources(java.lang.String) getResources(String)} method.\n     *\n     * @param  name\n     *         The resource name\n     *\n     * @return  {@code URL} object for reading the resource; {@code null} if\n     *          the resource could not be found, a {@code URL} could not be\n     *          constructed to locate the resource, the resource is in a package\n     *          that is not opened unconditionally, or access to the resource is\n     *          denied by the security manager.\n     *\n     * @throws  NullPointerException If {@code name} is {@code null}\n     *\n     * @since  1.1\n     * @revised 9\n     ",
    "links" : [ "#findResource(String)", "#getResources(java.lang.String)" ]
  }, {
    "name" : "public Enumeration<URL> getResources(String name) throws IOException",
    "returnType" : "Enumeration<URL>",
    "comment" : "\n     * Finds all the resources with the given name. A resource is some data\n     * (images, audio, text, etc) that can be accessed by class code in a way\n     * that is independent of the location of the code.\n     *\n     * <p> The name of a resource is a {@code /}-separated path name that\n     * identifies the resource. </p>\n     *\n     * @implSpec The default implementation will first search the parent class\n     * loader for the resource; if the parent is {@code null} the path of the\n     * class loader built into the virtual machine is searched. It then\n     * invokes {@link #findResources(String)} to find the resources with the\n     * name in this class loader. It returns an enumeration whose elements\n     * are the URLs found by searching the parent class loader followed by\n     * the elements found with {@code findResources}.\n     *\n     * @apiNote Where several modules are defined to the same class loader,\n     * and where more than one module contains a resource with the given name,\n     * then the ordering is not specified and may be very unpredictable.\n     * When overriding this method it is recommended that an\n     * implementation ensures that any delegation is consistent with the {@link\n     * #getResource(java.lang.String) getResource(String)} method. This should\n     * ensure that the first element returned by the Enumeration's\n     * {@code nextElement} method is the same resource that the\n     * {@code getResource(String)} method would return.\n     *\n     * @param  name\n     *         The resource name\n     *\n     * @return  An enumeration of {@link java.net.URL URL} objects for the\n     *          resource. If no resources could be found, the enumeration will\n     *          be empty. Resources for which a {@code URL} cannot be\n     *          constructed, are in a package that is not opened\n     *          unconditionally, or access to the resource is denied by the\n     *          security manager, are not returned in the enumeration.\n     *\n     * @throws  IOException\n     *          If I/O errors occur\n     * @throws  NullPointerException If {@code name} is {@code null}\n     *\n     * @since  1.2\n     * @revised 9\n     ",
    "links" : [ "java.net.URL", "#findResources(String)", "#getResource(java.lang.String)" ]
  }, {
    "name" : "public Stream<URL> resources(String name)",
    "returnType" : "Stream<URL>",
    "comment" : "\n     * Returns a stream whose elements are the URLs of all the resources with\n     * the given name. A resource is some data (images, audio, text, etc) that\n     * can be accessed by class code in a way that is independent of the\n     * location of the code.\n     *\n     * <p> The name of a resource is a {@code /}-separated path name that\n     * identifies the resource.\n     *\n     * <p> The resources will be located when the returned stream is evaluated.\n     * If the evaluation results in an {@code IOException} then the I/O\n     * exception is wrapped in an {@link UncheckedIOException} that is then\n     * thrown.\n     * @implSpec The default implementation invokes {@link #getResources(String)\n     * getResources} to find all the resources with the given name and returns\n     * a stream with the elements in the enumeration as the source.\n     *\n     * @apiNote When overriding this method it is recommended that an\n     * implementation ensures that any delegation is consistent with the {@link\n     * #getResource(java.lang.String) getResource(String)} method. This should\n     * ensure that the first element returned by the stream is the same\n     * resource that the {@code getResource(String)} method would return.\n     *\n     * @param  name\n     *         The resource name\n     *\n     * @return  A stream of resource {@link java.net.URL URL} objects. If no\n     *          resources could  be found, the stream will be empty. Resources\n     *          for which a {@code URL} cannot be constructed, are in a package\n     *          that is not opened unconditionally, or access to the resource\n     *          is denied by the security manager, will not be in the stream.\n     *\n     * @throws  NullPointerException If {@code name} is {@code null}\n     *\n     * @since  9\n     * @hide\n     ",
    "links" : [ "java.io.UncheckedIOException", "java.net.URL", "#getResource(java.lang.String)", "#getResources(String)" ]
  }, {
    "name" : "protected URL findResource(String name)",
    "returnType" : "URL",
    "comment" : "\n     * Finds the resource with the given name. Class loader implementations\n     * should override this method.\n     *\n     * @implSpec The default implementation returns {@code null}.\n     *\n     * @param  name\n     *         The resource name\n     *\n     * @return  {@code URL} object for reading the resource; {@code null} if\n     *          the resource could not be found, a {@code URL} could not be\n     *          constructed to locate the resource, the resource is in a package\n     *          that is not opened unconditionally, or access to the resource is\n     *          denied by the security manager.\n     *\n     * @since  1.2\n     * @revised 9\n     ",
    "links" : [ ]
  }, {
    "name" : "protected Enumeration<URL> findResources(String name) throws IOException",
    "returnType" : "Enumeration<URL>",
    "comment" : "\n     * Returns an enumeration of {@link java.net.URL URL} objects\n     * representing all the resources with the given name. Class loader\n     * implementations should override this method.\n     *\n     * @implSpec The default implementation returns an enumeration that\n     * contains no elements.\n     *\n     * @param  name\n     *         The resource name\n     *\n     * @return  An enumeration of {@link java.net.URL URL} objects for\n     *          the resource. If no resources could  be found, the enumeration\n     *          will be empty. Resources for which a {@code URL} cannot be\n     *          constructed, are in a package that is not opened unconditionally,\n     *          or access to the resource is denied by the security manager,\n     *          are not returned in the enumeration.\n     *\n     * @throws  IOException\n     *          If I/O errors occur\n     *\n     * @since  1.2\n     * @revised 9\n     ",
    "links" : [ "java.net.URL" ]
  }, {
    "name" : "protected static boolean registerAsParallelCapable()",
    "returnType" : "boolean",
    "comment" : "\n     * Registers the caller as\n     * {@code #isRegisteredAsParallelCapable() parallel capable}.\n     * The registration succeeds if and only if all of the following\n     * conditions are met:\n     * <ol>\n     * <li> no instance of the caller has been created</li>\n     * <li> all of the super classes (except class Object) of the caller are\n     * registered as parallel capable</li>\n     * </ol>\n     * <p>Note that once a class loader is registered as parallel capable, there\n     * is no way to change it back.</p>\n     *\n     * @return  {@code true} if the caller is successfully registered as\n     *          parallel capable and {@code false} if otherwise.\n     *\n     * @since   1.7\n     ",
    "links" : [ ]
  }, {
    "name" : "public final boolean isRegisteredAsParallelCapable()",
    "returnType" : "boolean",
    "comment" : "\n     * Returns {@code true} if this class loader is registered as\n     * {@code #registerAsParallelCapable parallel capable}, otherwise\n     * {@code false}.\n     *\n     * @return  {@code true} if this class loader is parallel capable,\n     *          otherwise {@code false}.\n     *\n     * @since   9\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public static URL getSystemResource(String name)",
    "returnType" : "URL",
    "comment" : "\n     * Find a resource of the specified name from the search path used to load\n     * classes.  This method locates the resource through the system class\n     * loader (see {@link #getSystemClassLoader()}).\n     *\n     * @param  name\n     *         The resource name\n     *\n     * @return  A {@link java.net.URL URL} to the resource; {@code\n     *          null} if the resource could not be found, a URL could not be\n     *          constructed to locate the resource, the resource is in a package\n     *          that is not opened unconditionally or access to the resource is\n     *          denied by the security manager.\n     *\n     * @since  1.1\n     * @revised 9\n     ",
    "links" : [ "java.net.URL", "#getSystemClassLoader()" ]
  }, {
    "name" : "public static Enumeration<URL> getSystemResources(String name) throws IOException",
    "returnType" : "Enumeration<URL>",
    "comment" : "\n     * Finds all resources of the specified name from the search path used to\n     * load classes.  The resources thus found are returned as an\n     * {@link java.util.Enumeration Enumeration} of {@link\n     * java.net.URL URL} objects.\n     *\n     * <p> The search order is described in the documentation for {@link\n     * #getSystemResource(String)}.  </p>\n     *\n     * @param  name\n     *         The resource name\n     *\n     * @return  An enumeration of {@link java.net.URL URL} objects for\n     *          the resource. If no resources could  be found, the enumeration\n     *          will be empty. Resources for which a {@code URL} cannot be\n     *          constructed, are in a package that is not opened unconditionally,\n     *          or access to the resource is denied by the security manager,\n     *          are not returned in the enumeration.\n     *\n     * @throws  IOException\n     *          If I/O errors occur\n     *\n     * @since  1.2\n     * @revised 9\n     ",
    "links" : [ "java.util.Enumeration", "#getSystemResource(String)", "java.net.URL" ]
  }, {
    "name" : "private static URL getBootstrapResource(String name)",
    "returnType" : "URL",
    "comment" : "\n     * Find resources from the VM's built-in classloader.\n     ",
    "links" : [ ]
  }, {
    "name" : "private static Enumeration<URL> getBootstrapResources(String name) throws IOException",
    "returnType" : "Enumeration<URL>",
    "comment" : "\n     * Find resources from the VM's built-in classloader.\n     ",
    "links" : [ ]
  }, {
    "name" : "public InputStream getResourceAsStream(String name)",
    "returnType" : "InputStream",
    "comment" : "\n     * Returns an input stream for reading the specified resource.\n     *\n     * <p> The search order is described in the documentation for {@link\n     * #getResource(String)}.  </p>\n     *\n     * @param  name\n     *         The resource name\n     *\n     * @return  An input stream for reading the resource; {@code null} if the\n     *          resource could not be found, the resource is in a package that\n     *          is not opened unconditionally, or access to the resource is\n     *          denied by the security manager.\n     *\n     * @throws  NullPointerException If {@code name} is {@code null}\n     *\n     * @since  1.1\n     * @revised 9\n     ",
    "links" : [ "#getResource(String)" ]
  }, {
    "name" : "public static InputStream getSystemResourceAsStream(String name)",
    "returnType" : "InputStream",
    "comment" : "\n     * Open for reading, a resource of the specified name from the search path\n     * used to load classes.  This method locates the resource through the\n     * system class loader (see {@link #getSystemClassLoader()}).\n     *\n     * @param  name\n     *         The resource name\n     *\n     * @return  An input stream for reading the resource; {@code null} if the\n     *          resource could not be found, the resource is in a package that\n     *          is not opened unconditionally, or access to the resource is\n     *          denied by the security manager.\n     *\n     * @since  1.1\n     * @revised 9\n     ",
    "links" : [ "#getSystemClassLoader()" ]
  }, {
    "name" : "public final ClassLoader getParent()",
    "returnType" : "ClassLoader",
    "comment" : "\n     * Returns the parent class loader for delegation. Some implementations may\n     * use {@code null} to represent the bootstrap class loader. This method\n     * will return {@code null} in such implementations if this class loader's\n     * parent is the bootstrap class loader.\n     *\n     * @return  The parent {@code ClassLoader}\n     *\n     * @throws  SecurityException\n     *          If a security manager is present, and the caller's class loader\n     *          is not {@code null} and is not an ancestor of this class loader,\n     *          and the caller does not have the\n     *          {@link RuntimePermission}{@code (\"getClassLoader\")}\n     *\n     * @since  1.2\n     ",
    "links" : [ "java.lang.RuntimePermission" ]
  }, {
    "name" : "public static ClassLoader getPlatformClassLoader()",
    "returnType" : "ClassLoader",
    "comment" : "\n     * Returns the platform class loader.  All\n     * <a href=\"#builtinLoaders\">platform classes</a> are visible to\n     * the platform class loader.\n     *\n     * @implNote The name of the builtin platform class loader is\n     * {@code \"platform\"}.\n     *\n     * @return  The platform {@code ClassLoader}.\n     *\n     * @throws  SecurityException\n     *          If a security manager is present, and the caller's class loader is\n     *          not {@code null}, and the caller's class loader is not the same\n     *          as or an ancestor of the platform class loader,\n     *          and the caller does not have the\n     *          {@link RuntimePermission}{@code (\"getClassLoader\")}\n     *\n     * @since 9\n     * @hide\n     ",
    "links" : [ "java.lang.RuntimePermission" ]
  }, {
    "name" : "public static ClassLoader getSystemClassLoader()",
    "returnType" : "ClassLoader",
    "comment" : "\n     * Returns the system class loader.  This is the default\n     * delegation parent for new {@code ClassLoader} instances, and is\n     * typically the class loader used to start the application.\n     *\n     * <p> This method is first invoked early in the runtime's startup\n     * sequence, at which point it creates the system class loader. This\n     * class loader will be the context class loader for the main application\n     * thread (for example, the thread that invokes the {@code main} method of\n     * the main class).\n     *\n     * <p> The default system class loader is an implementation-dependent\n     * instance of this class.\n     *\n     * @implNote The system property to override the system class loader is not\n     * examined until the VM is almost fully initialized. Code that executes\n     * this method during startup should take care not to cache the return\n     * value until the system is fully initialized.\n     *\n     * <p> The name of the built-in system class loader is {@code \"app\"}.\n     * The system property \"{@code java.class.path}\" is read during early\n     * initialization of the VM to determine the class path.\n     * An empty value of \"{@code java.class.path}\" property is interpreted\n     * differently depending on whether the initial module (the module\n     * containing the main class) is named or unnamed:\n     * If named, the built-in system class loader will have no class path and\n     * will search for classes and resources using the application module path;\n     * otherwise, if unnamed, it will set the class path to the current\n     * working directory.\n     *\n     * <p> JAR files on the class path may contain a {@code Class-Path} manifest\n     * attribute to specify dependent JAR files to be included in the class path.\n     * {@code Class-Path} entries must meet certain conditions for validity (see\n     * the <a href=\"{@docRoot}/../specs/jar/jar.html#class-path-attribute\">\n     * JAR File Specification</a> for details).  Invalid {@code Class-Path}\n     * entries are ignored.\n     *\n     * @return  The system {@code ClassLoader}\n     *\n     * @throws  SecurityException\n     *          If a security manager is present, and the caller's class loader\n     *          is not {@code null} and is not the same as or an ancestor of the\n     *          system class loader, and the caller does not have the\n     *          {@link RuntimePermission}{@code (\"getClassLoader\")}\n     *\n     * @throws  IllegalStateException\n     *          If invoked recursively during the construction of the class\n     *          loader specified by the \"{@code java.system.class.loader}\"\n     *          property.\n     *\n     * @throws  Error\n     *          If the system property \"{@code java.system.class.loader}\"\n     *          is defined but the named class could not be loaded, the\n     *          provider class does not define the required constructor, or an\n     *          exception is thrown by that constructor when it is invoked. The\n     *          underlying cause of the error can be retrieved via the\n     *          {@link Throwable#getCause()} method.\n     *\n     * @revised  1.4\n     * @revised 9\n     ",
    "links" : [ "java.lang.RuntimePermission", "java.lang.Throwable#getCause()" ]
  }, {
    "name" : " boolean isAncestor(ClassLoader cl)",
    "returnType" : "boolean",
    "comment" : " loader's delegation chain.",
    "links" : [ ]
  }, {
    "name" : "private static boolean needsClassLoaderPermissionCheck(ClassLoader from, ClassLoader to)",
    "returnType" : "boolean",
    "comment" : " any class loader.",
    "links" : [ ]
  }, {
    "name" : " static ClassLoader getClassLoader(Class<?> caller)",
    "returnType" : "ClassLoader",
    "comment" : " Returns the class's class loader, or null if none.",
    "links" : [ ]
  }, {
    "name" : "protected Package definePackage(String name, String specTitle, String specVersion, String specVendor, String implTitle, String implVersion, String implVendor, URL sealBase) throws IllegalArgumentException",
    "returnType" : "Package",
    "comment" : "\n     * Defines a package by <a href=\"#binary-name\">name</a> in this {@code ClassLoader}.\n     * <p>\n     * <a href=\"#binary-name\">Package names</a> must be unique within a class loader and\n     * cannot be redefined or changed once created.\n     * <p>\n     * If a class loader wishes to define a package with specific properties,\n     * such as version information, then the class loader should call this\n     * {@code definePackage} method before calling {@code defineClass}.\n     * Otherwise, the\n     * {@link #defineClass(String, byte[], int, int, ProtectionDomain) defineClass}\n     * method will define a package in this class loader corresponding to the package\n     * of the newly defined class; the properties of this defined package are\n     * specified by {@link Package}.\n     *\n     * @apiNote\n     * A class loader that wishes to define a package for classes in a JAR\n     * typically uses the specification and implementation titles, versions, and\n     * vendors from the JAR's manifest. If the package is specified as\n     * {@linkplain java.util.jar.Attributes.Name#SEALED sealed} in the JAR's manifest,\n     * the {@code URL} of the JAR file is typically used as the {@code sealBase}.\n     * If classes of package {@code 'p'} defined by this class loader\n     * are loaded from multiple JARs, the {@code Package} object may contain\n     * different information depending on the first class of package {@code 'p'}\n     * defined and which JAR's manifest is read first to explicitly define\n     * package {@code 'p'}.\n     *\n     * <p> It is strongly recommended that a class loader does not call this\n     * method to explicitly define packages in <em>named modules</em>; instead,\n     * the package will be automatically defined when a class is {@linkplain\n     * #defineClass(String, byte[], int, int, ProtectionDomain) being defined}.\n     * If it is desirable to define {@code Package} explicitly, it should ensure\n     * that all packages in a named module are defined with the properties\n     * specified by {@link Package}.  Otherwise, some {@code Package} objects\n     * in a named module may be for example sealed with different seal base.\n     *\n     * @param  name\n     *         The <a href=\"#binary-name\">package name</a>\n     *\n     * @param  specTitle\n     *         The specification title\n     *\n     * @param  specVersion\n     *         The specification version\n     *\n     * @param  specVendor\n     *         The specification vendor\n     *\n     * @param  implTitle\n     *         The implementation title\n     *\n     * @param  implVersion\n     *         The implementation version\n     *\n     * @param  implVendor\n     *         The implementation vendor\n     *\n     * @param  sealBase\n     *         If not {@code null}, then this package is sealed with\n     *         respect to the given code source {@link java.net.URL URL}\n     *         object.  Otherwise, the package is not sealed.\n     *\n     * @return  The newly defined {@code Package} object\n     *\n     * @throws  NullPointerException\n     *          if {@code name} is {@code null}.\n     *\n     * @throws  IllegalArgumentException\n     *          if a package of the given {@code name} is already\n     *          defined by this class loader\n     *\n     *\n     * @since  1.2\n     * @revised 9\n     *\n     * @jvms 5.3 Creation and Loading\n     * @see <a href=\"{@docRoot}/../specs/jar/jar.html#package-sealing\">\n     *      The JAR File Specification: Package Sealing</a>\n     ",
    "links" : [ "#defineClass(String", "java.lang.Package", "java.net.URL" ]
  }, {
    "name" : "public final Package getDefinedPackage(String name)",
    "returnType" : "Package",
    "comment" : "\n     * Returns a {@code Package} of the given <a href=\"#binary-name\">name</a> that\n     * has been defined by this class loader.\n     *\n     * @param  name The <a href=\"#binary-name\">package name</a>\n     *\n     * @return The {@code Package} of the given name that has been defined\n     *         by this class loader, or {@code null} if not found\n     *\n     * @throws  NullPointerException\n     *          if {@code name} is {@code null}.\n     *\n     * @jvms 5.3 Creation and Loading\n     *\n     * @since  9\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public final Package[] getDefinedPackages()",
    "returnType" : "Package[]",
    "comment" : "\n     * Returns all of the {@code Package}s that have been defined by\n     * this class loader.  The returned array has no duplicated {@code Package}s\n     * of the same name.\n     *\n     * @apiNote This method returns an array rather than a {@code Set} or {@code Stream}\n     *          for consistency with the existing {@link #getPackages} method.\n     *\n     * @return The array of {@code Package} objects that have been defined by\n     *         this class loader; or an zero length array if no package has been\n     *         defined by this class loader.\n     *\n     * @jvms 5.3 Creation and Loading\n     *\n     * @since  9\n     * @hide\n     ",
    "links" : [ "#getPackages" ]
  }, {
    "name" : "protected Package getPackage(String name)",
    "returnType" : "Package",
    "comment" : "\n     * Finds a package by <a href=\"#binary-name\">name</a> in this class loader and its ancestors.\n     * <p>\n     * If this class loader defines a {@code Package} of the given name,\n     * the {@code Package} is returned. Otherwise, the ancestors of\n     * this class loader are searched recursively (parent by parent)\n     * for a {@code Package} of the given name.\n     *\n     * @param  name\n     *         The <a href=\"#binary-name\">package name</a>\n     *\n     * @return The {@code Package} of the given name that has been defined by\n     *         this class loader or its ancestors, or {@code null} if not found.\n     *\n     * @throws  NullPointerException\n     *          if {@code name} is {@code null}.\n     *\n     * @deprecated\n     * If multiple class loaders delegate to each other and define classes\n     * with the same package name, and one such loader relies on the lookup\n     * behavior of {@code getPackage} to return a {@code Package} from\n     * a parent loader, then the properties exposed by the {@code Package}\n     * may not be as expected in the rest of the program.\n     * For example, the {@code Package} will only expose annotations from the\n     * {@code package-info.class} file defined by the parent loader, even if\n     * annotations exist in a {@code package-info.class} file defined by\n     * a child loader.\n     *\n     * @since  1.2\n     * @revised 9\n     ",
    "links" : [ ]
  }, {
    "name" : "protected Package[] getPackages()",
    "returnType" : "Package[]",
    "comment" : "\n     * Returns all of the {@code Package}s that have been defined by\n     * this class loader and its ancestors.  The returned array may contain\n     * more than one {@code Package} object of the same package name, each\n     * defined by a different class loader in the class loader hierarchy.\n     *\n     * @return  The array of {@code Package} objects that have been defined by\n     *          this class loader and its ancestors\n     *\n     * @since  1.2\n     * @revised 9\n     ",
    "links" : [ ]
  }, {
    "name" : "protected String findLibrary(String libname)",
    "returnType" : "String",
    "comment" : "\n     * Returns the absolute path name of a native library.  The VM invokes this\n     * method to locate the native libraries that belong to classes loaded with\n     * this class loader. If this method returns {@code null}, the VM\n     * searches the library along the path specified as the\n     * \"{@code java.library.path}\" property.\n     *\n     * @param  libname\n     *         The library name\n     *\n     * @return  The absolute path of the native library\n     *\n     * @see  System#loadLibrary(String)\n     * @see  System#mapLibraryName(String)\n     *\n     * @since  1.2\n     ",
    "links" : [ ]
  }, {
    "name" : "public void setDefaultAssertionStatus(boolean enabled)",
    "returnType" : "void",
    "comment" : "\n     * Sets the default assertion status for this class loader.  This setting\n     * determines whether classes loaded by this class loader and initialized\n     * in the future will have assertions enabled or disabled by default.\n     * This setting may be overridden on a per-package or per-class basis by\n     * invoking {@link #setPackageAssertionStatus(String, boolean)} or {@link\n     * #setClassAssertionStatus(String, boolean)}.\n     *\n     * Android-note: AssertionStatuses are unsupported. This method is a no-op.\n     *\n     * @param  enabled\n     *         {@code true} if classes loaded by this class loader will\n     *         henceforth have assertions enabled by default, {@code false}\n     *         if they will have assertions disabled by default.\n     *\n     * @since  1.4\n     ",
    "links" : [ "#setPackageAssertionStatus(String", "#setClassAssertionStatus(String" ]
  }, {
    "name" : "public void setPackageAssertionStatus(String packageName, boolean enabled)",
    "returnType" : "void",
    "comment" : "\n     * Sets the package default assertion status for the named package.  The\n     * package default assertion status determines the assertion status for\n     * classes initialized in the future that belong to the named package or\n     * any of its \"subpackages\".\n     *\n     * <p> A subpackage of a package named p is any package whose name begins\n     * with \"{@code p.}\".  For example, {@code javax.swing.text} is a\n     * subpackage of {@code javax.swing}, and both {@code java.util} and\n     * {@code java.lang.reflect} are subpackages of {@code java}.\n     *\n     * <p> In the event that multiple package defaults apply to a given class,\n     * the package default pertaining to the most specific package takes\n     * precedence over the others.  For example, if {@code javax.lang} and\n     * {@code javax.lang.reflect} both have package defaults associated with\n     * them, the latter package default applies to classes in\n     * {@code javax.lang.reflect}.\n     *\n     * <p> Package defaults take precedence over the class loader's default\n     * assertion status, and may be overridden on a per-class basis by invoking\n     * {@link #setClassAssertionStatus(String, boolean)}.  </p>\n     *\n     * Android-note: AssertionStatuses are unsupported. This method is a no-op.\n     *\n     * @param  packageName\n     *         The name of the package whose package default assertion status\n     *         is to be set. A {@code null} value indicates the unnamed\n     *         package that is \"current\"\n     *         (see section {@jls 7.4.2} of\n     *         <cite>The Java Language Specification</cite>.)\n     *\n     * @param  enabled\n     *         {@code true} if classes loaded by this classloader and\n     *         belonging to the named package or any of its subpackages will\n     *         have assertions enabled by default, {@code false} if they will\n     *         have assertions disabled by default.\n     *\n     * @since  1.4\n     ",
    "links" : [ "#setClassAssertionStatus(String" ]
  }, {
    "name" : "public void setClassAssertionStatus(String className, boolean enabled)",
    "returnType" : "void",
    "comment" : "\n     * Sets the desired assertion status for the named top-level class in this\n     * class loader and any nested classes contained therein.  This setting\n     * takes precedence over the class loader's default assertion status, and\n     * over any applicable per-package default.  This method has no effect if\n     * the named class has already been initialized.  (Once a class is\n     * initialized, its assertion status cannot change.)\n     *\n     * <p> If the named class is not a top-level class, this invocation will\n     * have no effect on the actual assertion status of any class. </p>\n     *\n     * Android-note: AssertionStatuses are unsupported. This method is a no-op.\n     *\n     * @param  className\n     *         The fully qualified class name of the top-level class whose\n     *         assertion status is to be set.\n     *\n     * @param  enabled\n     *         {@code true} if the named class is to have assertions\n     *         enabled when (and if) it is initialized, {@code false} if the\n     *         class is to have assertions disabled.\n     *\n     * @since  1.4\n     ",
    "links" : [ ]
  }, {
    "name" : "public void clearAssertionStatus()",
    "returnType" : "void",
    "comment" : "\n     * Sets the default assertion status for this class loader to\n     * {@code false} and discards any package defaults or class assertion\n     * status settings associated with the class loader.  This method is\n     * provided so that class loaders can be made to ignore any command line or\n     * persistent assertion status settings and \"start with a clean slate.\"\n     *\n     * Android-note: AssertionStatuses are unsupported. This method is a no-op.\n     *\n     * @since  1.4\n     ",
    "links" : [ ]
  } ],
  "methodNames" : [ "private static ClassLoader createSystemClassLoader()", "private static Void checkCreateClassLoader()", "private static Void checkCreateClassLoader(String name)", "public String getName()", " final String name()", "public Class<?> loadClass(String name) throws ClassNotFoundException", "protected Class<?> loadClass(String name, boolean resolve) throws ClassNotFoundException", "protected Class<?> findClass(String name) throws ClassNotFoundException", "protected final Class<?> defineClass(byte[] b, int off, int len) throws ClassFormatError", "protected final Class<?> defineClass(String name, byte[] b, int off, int len) throws ClassFormatError", "protected final Class<?> defineClass(String name, byte[] b, int off, int len, ProtectionDomain protectionDomain) throws ClassFormatError", "protected final Class<?> defineClass(String name, java.nio.ByteBuffer b, ProtectionDomain protectionDomain) throws ClassFormatError", "protected final void resolveClass(Class<?> c)", "protected final Class<?> findSystemClass(String name) throws ClassNotFoundException", "private Class<?> findBootstrapClassOrNull(String name)", "protected final Class<?> findLoadedClass(String name)", "protected final void setSigners(Class<?> c, Object[] signers)", "public URL getResource(String name)", "public Enumeration<URL> getResources(String name) throws IOException", "public Stream<URL> resources(String name)", "protected URL findResource(String name)", "protected Enumeration<URL> findResources(String name) throws IOException", "protected static boolean registerAsParallelCapable()", "public final boolean isRegisteredAsParallelCapable()", "public static URL getSystemResource(String name)", "public static Enumeration<URL> getSystemResources(String name) throws IOException", "private static URL getBootstrapResource(String name)", "private static Enumeration<URL> getBootstrapResources(String name) throws IOException", "public InputStream getResourceAsStream(String name)", "public static InputStream getSystemResourceAsStream(String name)", "public final ClassLoader getParent()", "public static ClassLoader getPlatformClassLoader()", "public static ClassLoader getSystemClassLoader()", " boolean isAncestor(ClassLoader cl)", "private static boolean needsClassLoaderPermissionCheck(ClassLoader from, ClassLoader to)", " static ClassLoader getClassLoader(Class<?> caller)", "protected Package definePackage(String name, String specTitle, String specVersion, String specVendor, String implTitle, String implVersion, String implVendor, URL sealBase) throws IllegalArgumentException", "public final Package getDefinedPackage(String name)", "public final Package[] getDefinedPackages()", "protected Package getPackage(String name)", "protected Package[] getPackages()", "protected String findLibrary(String libname)", "public void setDefaultAssertionStatus(boolean enabled)", "public void setPackageAssertionStatus(String packageName, boolean enabled)", "public void setClassAssertionStatus(String className, boolean enabled)", "public void clearAssertionStatus()" ],
  "variableNames" : [ "proxyCache", "parent", "name", "packages", "allocator", "classTable" ]
}