{
  "filePath" : "/home/maryam/clearblue/files/android-source-30/android/media/AudioRecord.java",
  "packageName" : "android.media",
  "className" : "AudioRecord",
  "comment" : "\n * The AudioRecord class manages the audio resources for Java applications\n * to record audio from the audio input hardware of the platform. This is\n * achieved by \"pulling\" (reading) the data from the AudioRecord object. The\n * application is responsible for polling the AudioRecord object in time using one of\n * the following three methods:  {@link #read(byte[],int, int)}, {@link #read(short[], int, int)}\n * or {@link #read(ByteBuffer, int)}. The choice of which method to use will be based\n * on the audio data storage format that is the most convenient for the user of AudioRecord.\n * <p>Upon creation, an AudioRecord object initializes its associated audio buffer that it will\n * fill with the new audio data. The size of this buffer, specified during the construction,\n * determines how long an AudioRecord can record before \"over-running\" data that has not\n * been read yet. Data should be read from the audio hardware in chunks of sizes inferior to\n * the total recording buffer size.\n ",
  "variables" : [ {
    "name" : "STATE_UNINITIALIZED",
    "type" : "int",
    "comment" : "\n     *  indicates AudioRecord state is not successfully initialized.\n     ",
    "links" : [ ]
  }, {
    "name" : "STATE_INITIALIZED",
    "type" : "int",
    "comment" : "\n     *  indicates AudioRecord state is ready to be used\n     ",
    "links" : [ ]
  }, {
    "name" : "RECORDSTATE_STOPPED",
    "type" : "int",
    "comment" : " matches SL_RECORDSTATE_STOPPED",
    "links" : [ ]
  }, {
    "name" : "RECORDSTATE_RECORDING",
    "type" : "int",
    "comment" : " matches SL_RECORDSTATE_RECORDING",
    "links" : [ ]
  }, {
    "name" : "SUCCESS",
    "type" : "int",
    "comment" : "\n     * Denotes a successful operation.\n     ",
    "links" : [ ]
  }, {
    "name" : "ERROR",
    "type" : "int",
    "comment" : "\n     * Denotes a generic operation failure.\n     ",
    "links" : [ ]
  }, {
    "name" : "ERROR_BAD_VALUE",
    "type" : "int",
    "comment" : "\n     * Denotes a failure due to the use of an invalid value.\n     ",
    "links" : [ ]
  }, {
    "name" : "ERROR_INVALID_OPERATION",
    "type" : "int",
    "comment" : "\n     * Denotes a failure due to the improper use of a method.\n     ",
    "links" : [ ]
  }, {
    "name" : "ERROR_DEAD_OBJECT",
    "type" : "int",
    "comment" : "\n     * An error code indicating that the object reporting it is no longer valid and needs to\n     * be recreated.\n     ",
    "links" : [ ]
  }, {
    "name" : "AUDIORECORD_ERROR_SETUP_ZEROFRAMECOUNT",
    "type" : "int",
    "comment" : " to keep in sync with frameworks/base/core/jni/android_media_AudioRecord.cpp",
    "links" : [ ]
  }, {
    "name" : "AUDIORECORD_ERROR_SETUP_INVALIDCHANNELMASK",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "AUDIORECORD_ERROR_SETUP_INVALIDFORMAT",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "AUDIORECORD_ERROR_SETUP_INVALIDSOURCE",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "AUDIORECORD_ERROR_SETUP_NATIVEINITFAILED",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "NATIVE_EVENT_MARKER",
    "type" : "int",
    "comment" : "\n     * Event id denotes when record head has reached a previously set marker.\n     ",
    "links" : [ ]
  }, {
    "name" : "NATIVE_EVENT_NEW_POS",
    "type" : "int",
    "comment" : "\n     * Event id denotes when previously set update period has elapsed during recording.\n     ",
    "links" : [ ]
  }, {
    "name" : "TAG",
    "type" : "String",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "SUBMIX_FIXED_VOLUME",
    "type" : "String",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "READ_BLOCKING",
    "type" : "int",
    "comment" : "\n     * The read mode indicating the read operation will block until all data\n     * requested has been read.\n     ",
    "links" : [ ]
  }, {
    "name" : "READ_NON_BLOCKING",
    "type" : "int",
    "comment" : "\n     * The read mode indicating the read operation will return immediately after\n     * reading as much audio data as possible without blocking.\n     ",
    "links" : [ ]
  }, {
    "name" : "mNativeRecorderInJavaObj",
    "type" : "long",
    "comment" : "\n     * Accessed by native methods: provides access to C++ AudioRecord object\n     ",
    "links" : [ ]
  }, {
    "name" : "mNativeCallbackCookie",
    "type" : "long",
    "comment" : "\n     * Accessed by native methods: provides access to the callback data.\n     ",
    "links" : [ ]
  }, {
    "name" : "mNativeDeviceCallback",
    "type" : "long",
    "comment" : "\n     * Accessed by native methods: provides access to the JNIDeviceCallback instance.\n     ",
    "links" : [ ]
  }, {
    "name" : "mAudioCapturePolicy",
    "type" : "AudioPolicy",
    "comment" : "--------------------",
    "links" : [ ]
  }, {
    "name" : "mSampleRate",
    "type" : "int",
    "comment" : " initialized by all constructors via audioParamCheck()",
    "links" : [ ]
  }, {
    "name" : "mChannelCount",
    "type" : "int",
    "comment" : "\n     * The number of input audio channels (1 is mono, 2 is stereo)\n     ",
    "links" : [ ]
  }, {
    "name" : "mChannelMask",
    "type" : "int",
    "comment" : "\n     * The audio channel position mask\n     ",
    "links" : [ ]
  }, {
    "name" : "mChannelIndexMask",
    "type" : "int",
    "comment" : "\n     * The audio channel index mask\n     ",
    "links" : [ ]
  }, {
    "name" : "mAudioFormat",
    "type" : "int",
    "comment" : "\n     * The encoding of the audio samples.\n     * @see AudioFormat#ENCODING_PCM_8BIT\n     * @see AudioFormat#ENCODING_PCM_16BIT\n     * @see AudioFormat#ENCODING_PCM_FLOAT\n     ",
    "links" : [ ]
  }, {
    "name" : "mRecordSource",
    "type" : "int",
    "comment" : "\n     * Where the audio data is recorded from.\n     ",
    "links" : [ ]
  }, {
    "name" : "mState",
    "type" : "int",
    "comment" : "\n     * Indicates the state of the AudioRecord instance.\n     ",
    "links" : [ ]
  }, {
    "name" : "mRecordingState",
    "type" : "int",
    "comment" : "\n     * Indicates the recording state of the AudioRecord instance.\n     ",
    "links" : [ ]
  }, {
    "name" : "mRecordingStateLock",
    "type" : "Object",
    "comment" : "\n     * Lock to make sure mRecordingState updates are reflecting the actual state of the object.\n     ",
    "links" : [ ]
  }, {
    "name" : "mPositionListener",
    "type" : "OnRecordPositionUpdateListener",
    "comment" : "\n     * The listener the AudioRecord notifies when the record position reaches a marker\n     * or for periodic updates during the progression of the record head.\n     *  @see #setRecordPositionUpdateListener(OnRecordPositionUpdateListener)\n     *  @see #setRecordPositionUpdateListener(OnRecordPositionUpdateListener, Handler)\n     ",
    "links" : [ ]
  }, {
    "name" : "mPositionListenerLock",
    "type" : "Object",
    "comment" : "\n     * Lock to protect position listener updates against event notifications\n     ",
    "links" : [ ]
  }, {
    "name" : "mEventHandler",
    "type" : "NativeEventHandler",
    "comment" : "\n     * Handler for marker events coming from the native code\n     ",
    "links" : [ ]
  }, {
    "name" : "mInitializationLooper",
    "type" : "Looper",
    "comment" : "\n     * Looper associated with the thread that creates the AudioRecord instance\n     ",
    "links" : [ ]
  }, {
    "name" : "mNativeBufferSizeInBytes",
    "type" : "int",
    "comment" : "\n     * Size of the native audio buffer.\n     ",
    "links" : [ ]
  }, {
    "name" : "mSessionId",
    "type" : "int",
    "comment" : "\n     * Audio session ID\n     ",
    "links" : [ ]
  }, {
    "name" : "mAudioAttributes",
    "type" : "AudioAttributes",
    "comment" : "\n     * AudioAttributes\n     ",
    "links" : [ ]
  }, {
    "name" : "mIsSubmixFullVolume",
    "type" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mICallBack",
    "type" : "IBinder",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mRoutingChangeListeners",
    "type" : "ArrayMap<AudioRouting.OnRoutingChangedListener, NativeRoutingEventHandlerDelegate>",
    "comment" : "\n     * The list of AudioRouting.OnRoutingChangedListener interfaces added (with\n     * {@link AudioRecord#addOnRoutingChangedListener} by an app to receive\n     * (re)routing notifications.\n     ",
    "links" : [ "android.media.AudioRecord#addOnRoutingChangedListener" ]
  }, {
    "name" : "mPreferredDevice",
    "type" : "AudioDeviceInfo",
    "comment" : "--------------------",
    "links" : [ ]
  }, {
    "name" : "mRecordingInfoImpl",
    "type" : "AudioRecordingMonitorImpl",
    "comment" : "",
    "links" : [ ]
  } ],
  "methods" : [ {
    "name" : "private String getCurrentOpPackageName()",
    "returnType" : "String",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private void unregisterAudioPolicyOnRelease(AudioPolicy audioPolicy)",
    "returnType" : "void",
    "comment" : "\n     * Sets an {@link AudioPolicy} to automatically unregister when the record is released.\n     *\n     * <p>This is to prevent users of the audio capture API from having to manually unregister the\n     * policy that was used to create the record.\n     ",
    "links" : [ "android.media.audiopolicy.AudioPolicy" ]
  }, {
    "name" : " void deferred_connect(long nativeRecordInJavaObj)",
    "returnType" : "void",
    "comment" : " package ",
    "links" : [ ]
  }, {
    "name" : "private static int getChannelMaskFromLegacyConfig(int inChannelConfig, boolean allowLegacyConfig)",
    "returnType" : "int",
    "comment" : " IllegalArgumentException-s are thrown",
    "links" : [ ]
  }, {
    "name" : "private void audioParamCheck(int audioSource, int sampleRateInHz, int audioFormat) throws IllegalArgumentException",
    "returnType" : "void",
    "comment" : "    mSampleRate is valid",
    "links" : [ ]
  }, {
    "name" : "private void audioBuffSizeCheck(int audioBufferSize) throws IllegalArgumentException",
    "returnType" : "void",
    "comment" : "    mNativeBufferSizeInBytes is valid (multiple of frame size, positive)",
    "links" : [ ]
  }, {
    "name" : "public void release()",
    "returnType" : "void",
    "comment" : "\n     * Releases the native AudioRecord resources.\n     * The object can no longer be used and the reference should be set to null\n     * after a call to release()\n     ",
    "links" : [ ]
  }, {
    "name" : "protected void finalize()",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public int getSampleRate()",
    "returnType" : "int",
    "comment" : "\n     * Returns the configured audio sink sample rate in Hz.\n     * The sink sample rate never changes after construction.\n     * If the constructor had a specific sample rate, then the sink sample rate is that value.\n     * If the constructor had {@link AudioFormat#SAMPLE_RATE_UNSPECIFIED},\n     * then the sink sample rate is a route-dependent default value based on the source [sic].\n     ",
    "links" : [ "android.media.AudioFormat#SAMPLE_RATE_UNSPECIFIED" ]
  }, {
    "name" : "public int getAudioSource()",
    "returnType" : "int",
    "comment" : "\n     * Returns the audio recording source.\n     * @see MediaRecorder.AudioSource\n     ",
    "links" : [ ]
  }, {
    "name" : "public int getAudioFormat()",
    "returnType" : "int",
    "comment" : "\n     * Returns the configured audio data encoding. See {@link AudioFormat#ENCODING_PCM_8BIT},\n     * {@link AudioFormat#ENCODING_PCM_16BIT}, and {@link AudioFormat#ENCODING_PCM_FLOAT}.\n     ",
    "links" : [ "android.media.AudioFormat#ENCODING_PCM_8BIT", "android.media.AudioFormat#ENCODING_PCM_FLOAT", "android.media.AudioFormat#ENCODING_PCM_16BIT" ]
  }, {
    "name" : "public int getChannelConfiguration()",
    "returnType" : "int",
    "comment" : "\n     * Returns the configured channel position mask.\n     * <p> See {@link AudioFormat#CHANNEL_IN_MONO}\n     * and {@link AudioFormat#CHANNEL_IN_STEREO}.\n     * This method may return {@link AudioFormat#CHANNEL_INVALID} if\n     * a channel index mask is used.\n     * Consider {@link #getFormat()} instead, to obtain an {@link AudioFormat},\n     * which contains both the channel position mask and the channel index mask.\n     ",
    "links" : [ "android.media.AudioFormat#CHANNEL_IN_STEREO", "android.media.AudioFormat#CHANNEL_INVALID", "android.media.AudioFormat", "android.media.AudioFormat#CHANNEL_IN_MONO", "#getFormat()" ]
  }, {
    "name" : "public AudioFormat getFormat()",
    "returnType" : "AudioFormat",
    "comment" : "\n     * Returns the configured <code>AudioRecord</code> format.\n     * @return an {@link AudioFormat} containing the\n     * <code>AudioRecord</code> parameters at the time of configuration.\n     ",
    "links" : [ "android.media.AudioFormat" ]
  }, {
    "name" : "public int getChannelCount()",
    "returnType" : "int",
    "comment" : "\n     * Returns the configured number of channels.\n     ",
    "links" : [ ]
  }, {
    "name" : "public int getState()",
    "returnType" : "int",
    "comment" : "\n     * Returns the state of the AudioRecord instance. This is useful after the\n     * AudioRecord instance has been created to check if it was initialized\n     * properly. This ensures that the appropriate hardware resources have been\n     * acquired.\n     * @see AudioRecord#STATE_INITIALIZED\n     * @see AudioRecord#STATE_UNINITIALIZED\n     ",
    "links" : [ ]
  }, {
    "name" : "public int getRecordingState()",
    "returnType" : "int",
    "comment" : "\n     * Returns the recording state of the AudioRecord instance.\n     * @see AudioRecord#RECORDSTATE_STOPPED\n     * @see AudioRecord#RECORDSTATE_RECORDING\n     ",
    "links" : [ ]
  }, {
    "name" : "public int getBufferSizeInFrames()",
    "returnType" : "int",
    "comment" : "\n     *  Returns the frame count of the native <code>AudioRecord</code> buffer.\n     *  This is greater than or equal to the bufferSizeInBytes converted to frame units\n     *  specified in the <code>AudioRecord</code> constructor or Builder.\n     *  The native frame count may be enlarged to accommodate the requirements of the\n     *  source on creation or if the <code>AudioRecord</code>\n     *  is subsequently rerouted.\n     *  @return current size in frames of the <code>AudioRecord</code> buffer.\n     *  @throws IllegalStateException\n     ",
    "links" : [ ]
  }, {
    "name" : "public int getNotificationMarkerPosition()",
    "returnType" : "int",
    "comment" : "\n     * Returns the notification marker position expressed in frames.\n     ",
    "links" : [ ]
  }, {
    "name" : "public int getPositionNotificationPeriod()",
    "returnType" : "int",
    "comment" : "\n     * Returns the notification update period expressed in frames.\n     ",
    "links" : [ ]
  }, {
    "name" : "public int getTimestamp(@NonNull AudioTimestamp outTimestamp, @AudioTimestamp.Timebase int timebase)",
    "returnType" : "int",
    "comment" : "\n     * Poll for an {@link AudioTimestamp} on demand.\n     * <p>\n     * The AudioTimestamp reflects the frame delivery information at\n     * the earliest point available in the capture pipeline.\n     * <p>\n     * Calling {@link #startRecording()} following a {@link #stop()} will reset\n     * the frame count to 0.\n     *\n     * @param outTimestamp a caller provided non-null AudioTimestamp instance,\n     *        which is updated with the AudioRecord frame delivery information upon success.\n     * @param timebase one of\n     *        {@link AudioTimestamp#TIMEBASE_BOOTTIME AudioTimestamp.TIMEBASE_BOOTTIME} or\n     *        {@link AudioTimestamp#TIMEBASE_MONOTONIC AudioTimestamp.TIMEBASE_MONOTONIC},\n     *        used to select the clock for the AudioTimestamp time.\n     * @return {@link #SUCCESS} if a timestamp is available,\n     *         or {@link #ERROR_INVALID_OPERATION} if a timestamp not available.\n     ",
    "links" : [ "#startRecording()", "android.media.AudioTimestamp#TIMEBASE_MONOTONIC", "#stop()", "android.media.AudioTimestamp", "android.media.AudioTimestamp#TIMEBASE_BOOTTIME", "#SUCCESS", "#ERROR_INVALID_OPERATION" ]
  }, {
    "name" : "public static int getMinBufferSize(int sampleRateInHz, int channelConfig, int audioFormat)",
    "returnType" : "int",
    "comment" : "\n     * Returns the minimum buffer size required for the successful creation of an AudioRecord\n     * object, in byte units.\n     * Note that this size doesn't guarantee a smooth recording under load, and higher values\n     * should be chosen according to the expected frequency at which the AudioRecord instance\n     * will be polled for new data.\n     * See {@link #AudioRecord(int, int, int, int, int)} for more information on valid\n     * configuration values.\n     * @param sampleRateInHz the sample rate expressed in Hertz.\n     *   {@link AudioFormat#SAMPLE_RATE_UNSPECIFIED} is not permitted.\n     * @param channelConfig describes the configuration of the audio channels.\n     *   See {@link AudioFormat#CHANNEL_IN_MONO} and\n     *   {@link AudioFormat#CHANNEL_IN_STEREO}\n     * @param audioFormat the format in which the audio data is represented.\n     *   See {@link AudioFormat#ENCODING_PCM_16BIT}.\n     * @return {@link #ERROR_BAD_VALUE} if the recording parameters are not supported by the\n     *  hardware, or an invalid parameter was passed,\n     *  or {@link #ERROR} if the implementation was unable to query the hardware for its\n     *  input properties,\n     *   or the minimum buffer size expressed in bytes.\n     * @see #AudioRecord(int, int, int, int, int)\n     ",
    "links" : [ "android.media.AudioFormat#CHANNEL_IN_STEREO", "#ERROR_BAD_VALUE", "#ERROR", "android.media.AudioFormat#SAMPLE_RATE_UNSPECIFIED", "android.media.AudioFormat#CHANNEL_IN_MONO", "android.media.AudioFormat#ENCODING_PCM_16BIT", "#AudioRecord(int" ]
  }, {
    "name" : "public int getAudioSessionId()",
    "returnType" : "int",
    "comment" : "\n     * Returns the audio session ID.\n     *\n     * @return the ID of the audio session this AudioRecord belongs to.\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean isPrivacySensitive()",
    "returnType" : "boolean",
    "comment" : "\n     * Returns whether this AudioRecord is marked as privacy sensitive or not.\n     * <p>\n     * See {@link Builder#setPrivacySensitive(boolean)}\n     * <p>\n     * @return true if privacy sensitive, false otherwise\n     ",
    "links" : [ "#setPrivacySensitive(boolean)" ]
  }, {
    "name" : "public void startRecording() throws IllegalStateException",
    "returnType" : "void",
    "comment" : "\n     * Starts recording from the AudioRecord instance.\n     * @throws IllegalStateException\n     ",
    "links" : [ ]
  }, {
    "name" : "public void startRecording(MediaSyncEvent syncEvent) throws IllegalStateException",
    "returnType" : "void",
    "comment" : "\n     * Starts recording from the AudioRecord instance when the specified synchronization event\n     * occurs on the specified audio session.\n     * @throws IllegalStateException\n     * @param syncEvent event that triggers the capture.\n     * @see MediaSyncEvent\n     ",
    "links" : [ ]
  }, {
    "name" : "public void stop() throws IllegalStateException",
    "returnType" : "void",
    "comment" : "\n     * Stops recording.\n     * @throws IllegalStateException\n     ",
    "links" : [ ]
  }, {
    "name" : "private void handleFullVolumeRec(boolean starting)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public int read(@NonNull byte[] audioData, int offsetInBytes, int sizeInBytes)",
    "returnType" : "int",
    "comment" : "\n     * Reads audio data from the audio hardware for recording into a byte array.\n     * The format specified in the AudioRecord constructor should be\n     * {@link AudioFormat#ENCODING_PCM_8BIT} to correspond to the data in the array.\n     * @param audioData the array to which the recorded audio data is written.\n     * @param offsetInBytes index in audioData from which the data is written expressed in bytes.\n     * @param sizeInBytes the number of requested bytes.\n     * @return zero or the positive number of bytes that were read, or one of the following\n     *    error codes. The number of bytes will not exceed sizeInBytes.\n     * <ul>\n     * <li>{@link #ERROR_INVALID_OPERATION} if the object isn't properly initialized</li>\n     * <li>{@link #ERROR_BAD_VALUE} if the parameters don't resolve to valid data and indexes</li>\n     * <li>{@link #ERROR_DEAD_OBJECT} if the object is not valid anymore and\n     *    needs to be recreated. The dead object error code is not returned if some data was\n     *    successfully transferred. In this case, the error is returned at the next read()</li>\n     * <li>{@link #ERROR} in case of other error</li>\n     * </ul>\n     ",
    "links" : [ "#ERROR_DEAD_OBJECT", "android.media.AudioFormat#ENCODING_PCM_8BIT", "#ERROR_BAD_VALUE", "#ERROR", "#ERROR_INVALID_OPERATION" ]
  }, {
    "name" : "public int read(@NonNull byte[] audioData, int offsetInBytes, int sizeInBytes, @ReadMode int readMode)",
    "returnType" : "int",
    "comment" : "\n     * Reads audio data from the audio hardware for recording into a byte array.\n     * The format specified in the AudioRecord constructor should be\n     * {@link AudioFormat#ENCODING_PCM_8BIT} to correspond to the data in the array.\n     * The format can be {@link AudioFormat#ENCODING_PCM_16BIT}, but this is deprecated.\n     * @param audioData the array to which the recorded audio data is written.\n     * @param offsetInBytes index in audioData to which the data is written expressed in bytes.\n     *        Must not be negative, or cause the data access to go out of bounds of the array.\n     * @param sizeInBytes the number of requested bytes.\n     *        Must not be negative, or cause the data access to go out of bounds of the array.\n     * @param readMode one of {@link #READ_BLOCKING}, {@link #READ_NON_BLOCKING}.\n     *     <br>With {@link #READ_BLOCKING}, the read will block until all the requested data\n     *     is read.\n     *     <br>With {@link #READ_NON_BLOCKING}, the read will return immediately after\n     *     reading as much audio data as possible without blocking.\n     * @return zero or the positive number of bytes that were read, or one of the following\n     *    error codes. The number of bytes will be a multiple of the frame size in bytes\n     *    not to exceed sizeInBytes.\n     * <ul>\n     * <li>{@link #ERROR_INVALID_OPERATION} if the object isn't properly initialized</li>\n     * <li>{@link #ERROR_BAD_VALUE} if the parameters don't resolve to valid data and indexes</li>\n     * <li>{@link #ERROR_DEAD_OBJECT} if the object is not valid anymore and\n     *    needs to be recreated. The dead object error code is not returned if some data was\n     *    successfully transferred. In this case, the error is returned at the next read()</li>\n     * <li>{@link #ERROR} in case of other error</li>\n     * </ul>\n     ",
    "links" : [ "#READ_NON_BLOCKING", "#ERROR_DEAD_OBJECT", "#READ_BLOCKING", "android.media.AudioFormat#ENCODING_PCM_8BIT", "#ERROR_BAD_VALUE", "#ERROR", "#ERROR_INVALID_OPERATION", "android.media.AudioFormat#ENCODING_PCM_16BIT" ]
  }, {
    "name" : "public int read(@NonNull short[] audioData, int offsetInShorts, int sizeInShorts)",
    "returnType" : "int",
    "comment" : "\n     * Reads audio data from the audio hardware for recording into a short array.\n     * The format specified in the AudioRecord constructor should be\n     * {@link AudioFormat#ENCODING_PCM_16BIT} to correspond to the data in the array.\n     * @param audioData the array to which the recorded audio data is written.\n     * @param offsetInShorts index in audioData to which the data is written expressed in shorts.\n     *        Must not be negative, or cause the data access to go out of bounds of the array.\n     * @param sizeInShorts the number of requested shorts.\n     *        Must not be negative, or cause the data access to go out of bounds of the array.\n     * @return zero or the positive number of shorts that were read, or one of the following\n     *    error codes. The number of shorts will be a multiple of the channel count not to exceed\n     *    sizeInShorts.\n     * <ul>\n     * <li>{@link #ERROR_INVALID_OPERATION} if the object isn't properly initialized</li>\n     * <li>{@link #ERROR_BAD_VALUE} if the parameters don't resolve to valid data and indexes</li>\n     * <li>{@link #ERROR_DEAD_OBJECT} if the object is not valid anymore and\n     *    needs to be recreated. The dead object error code is not returned if some data was\n     *    successfully transferred. In this case, the error is returned at the next read()</li>\n     * <li>{@link #ERROR} in case of other error</li>\n     * </ul>\n     ",
    "links" : [ "#ERROR_DEAD_OBJECT", "#ERROR_BAD_VALUE", "#ERROR", "#ERROR_INVALID_OPERATION", "android.media.AudioFormat#ENCODING_PCM_16BIT" ]
  }, {
    "name" : "public int read(@NonNull short[] audioData, int offsetInShorts, int sizeInShorts, @ReadMode int readMode)",
    "returnType" : "int",
    "comment" : "\n     * Reads audio data from the audio hardware for recording into a short array.\n     * The format specified in the AudioRecord constructor should be\n     * {@link AudioFormat#ENCODING_PCM_16BIT} to correspond to the data in the array.\n     * @param audioData the array to which the recorded audio data is written.\n     * @param offsetInShorts index in audioData from which the data is written expressed in shorts.\n     *        Must not be negative, or cause the data access to go out of bounds of the array.\n     * @param sizeInShorts the number of requested shorts.\n     *        Must not be negative, or cause the data access to go out of bounds of the array.\n     * @param readMode one of {@link #READ_BLOCKING}, {@link #READ_NON_BLOCKING}.\n     *     <br>With {@link #READ_BLOCKING}, the read will block until all the requested data\n     *     is read.\n     *     <br>With {@link #READ_NON_BLOCKING}, the read will return immediately after\n     *     reading as much audio data as possible without blocking.\n     * @return zero or the positive number of shorts that were read, or one of the following\n     *    error codes. The number of shorts will be a multiple of the channel count not to exceed\n     *    sizeInShorts.\n     * <ul>\n     * <li>{@link #ERROR_INVALID_OPERATION} if the object isn't properly initialized</li>\n     * <li>{@link #ERROR_BAD_VALUE} if the parameters don't resolve to valid data and indexes</li>\n     * <li>{@link #ERROR_DEAD_OBJECT} if the object is not valid anymore and\n     *    needs to be recreated. The dead object error code is not returned if some data was\n     *    successfully transferred. In this case, the error is returned at the next read()</li>\n     * <li>{@link #ERROR} in case of other error</li>\n     * </ul>\n     ",
    "links" : [ "#READ_NON_BLOCKING", "#ERROR_DEAD_OBJECT", "#READ_BLOCKING", "#ERROR_BAD_VALUE", "#ERROR", "#ERROR_INVALID_OPERATION", "android.media.AudioFormat#ENCODING_PCM_16BIT" ]
  }, {
    "name" : "public int read(@NonNull float[] audioData, int offsetInFloats, int sizeInFloats, @ReadMode int readMode)",
    "returnType" : "int",
    "comment" : "\n     * Reads audio data from the audio hardware for recording into a float array.\n     * The format specified in the AudioRecord constructor should be\n     * {@link AudioFormat#ENCODING_PCM_FLOAT} to correspond to the data in the array.\n     * @param audioData the array to which the recorded audio data is written.\n     * @param offsetInFloats index in audioData from which the data is written.\n     *        Must not be negative, or cause the data access to go out of bounds of the array.\n     * @param sizeInFloats the number of requested floats.\n     *        Must not be negative, or cause the data access to go out of bounds of the array.\n     * @param readMode one of {@link #READ_BLOCKING}, {@link #READ_NON_BLOCKING}.\n     *     <br>With {@link #READ_BLOCKING}, the read will block until all the requested data\n     *     is read.\n     *     <br>With {@link #READ_NON_BLOCKING}, the read will return immediately after\n     *     reading as much audio data as possible without blocking.\n     * @return zero or the positive number of floats that were read, or one of the following\n     *    error codes. The number of floats will be a multiple of the channel count not to exceed\n     *    sizeInFloats.\n     * <ul>\n     * <li>{@link #ERROR_INVALID_OPERATION} if the object isn't properly initialized</li>\n     * <li>{@link #ERROR_BAD_VALUE} if the parameters don't resolve to valid data and indexes</li>\n     * <li>{@link #ERROR_DEAD_OBJECT} if the object is not valid anymore and\n     *    needs to be recreated. The dead object error code is not returned if some data was\n     *    successfully transferred. In this case, the error is returned at the next read()</li>\n     * <li>{@link #ERROR} in case of other error</li>\n     * </ul>\n     ",
    "links" : [ "#READ_NON_BLOCKING", "#ERROR_DEAD_OBJECT", "#READ_BLOCKING", "#ERROR_BAD_VALUE", "android.media.AudioFormat#ENCODING_PCM_FLOAT", "#ERROR", "#ERROR_INVALID_OPERATION" ]
  }, {
    "name" : "public int read(@NonNull ByteBuffer audioBuffer, int sizeInBytes)",
    "returnType" : "int",
    "comment" : "\n     * Reads audio data from the audio hardware for recording into a direct buffer. If this buffer\n     * is not a direct buffer, this method will always return 0.\n     * Note that the value returned by {@link java.nio.Buffer#position()} on this buffer is\n     * unchanged after a call to this method.\n     * The representation of the data in the buffer will depend on the format specified in\n     * the AudioRecord constructor, and will be native endian.\n     * @param audioBuffer the direct buffer to which the recorded audio data is written.\n     * Data is written to audioBuffer.position().\n     * @param sizeInBytes the number of requested bytes. It is recommended but not enforced\n     *    that the number of bytes requested be a multiple of the frame size (sample size in\n     *    bytes multiplied by the channel count).\n     * @return zero or the positive number of bytes that were read, or one of the following\n     *    error codes. The number of bytes will not exceed sizeInBytes and will be truncated to be\n     *    a multiple of the frame size.\n     * <ul>\n     * <li>{@link #ERROR_INVALID_OPERATION} if the object isn't properly initialized</li>\n     * <li>{@link #ERROR_BAD_VALUE} if the parameters don't resolve to valid data and indexes</li>\n     * <li>{@link #ERROR_DEAD_OBJECT} if the object is not valid anymore and\n     *    needs to be recreated. The dead object error code is not returned if some data was\n     *    successfully transferred. In this case, the error is returned at the next read()</li>\n     * <li>{@link #ERROR} in case of other error</li>\n     * </ul>\n     ",
    "links" : [ "#ERROR_DEAD_OBJECT", "#ERROR_BAD_VALUE", "#ERROR", "#ERROR_INVALID_OPERATION", "java.nio.Buffer#position()" ]
  }, {
    "name" : "public int read(@NonNull ByteBuffer audioBuffer, int sizeInBytes, @ReadMode int readMode)",
    "returnType" : "int",
    "comment" : "\n     * Reads audio data from the audio hardware for recording into a direct buffer. If this buffer\n     * is not a direct buffer, this method will always return 0.\n     * Note that the value returned by {@link java.nio.Buffer#position()} on this buffer is\n     * unchanged after a call to this method.\n     * The representation of the data in the buffer will depend on the format specified in\n     * the AudioRecord constructor, and will be native endian.\n     * @param audioBuffer the direct buffer to which the recorded audio data is written.\n     * Data is written to audioBuffer.position().\n     * @param sizeInBytes the number of requested bytes. It is recommended but not enforced\n     *    that the number of bytes requested be a multiple of the frame size (sample size in\n     *    bytes multiplied by the channel count).\n     * @param readMode one of {@link #READ_BLOCKING}, {@link #READ_NON_BLOCKING}.\n     *     <br>With {@link #READ_BLOCKING}, the read will block until all the requested data\n     *     is read.\n     *     <br>With {@link #READ_NON_BLOCKING}, the read will return immediately after\n     *     reading as much audio data as possible without blocking.\n     * @return zero or the positive number of bytes that were read, or one of the following\n     *    error codes. The number of bytes will not exceed sizeInBytes and will be truncated to be\n     *    a multiple of the frame size.\n     * <ul>\n     * <li>{@link #ERROR_INVALID_OPERATION} if the object isn't properly initialized</li>\n     * <li>{@link #ERROR_BAD_VALUE} if the parameters don't resolve to valid data and indexes</li>\n     * <li>{@link #ERROR_DEAD_OBJECT} if the object is not valid anymore and\n     *    needs to be recreated. The dead object error code is not returned if some data was\n     *    successfully transferred. In this case, the error is returned at the next read()</li>\n     * <li>{@link #ERROR} in case of other error</li>\n     * </ul>\n     ",
    "links" : [ "#READ_NON_BLOCKING", "#ERROR_DEAD_OBJECT", "#READ_BLOCKING", "#ERROR_BAD_VALUE", "#ERROR", "#ERROR_INVALID_OPERATION", "java.nio.Buffer#position()" ]
  }, {
    "name" : "public PersistableBundle getMetrics()",
    "returnType" : "PersistableBundle",
    "comment" : "\n     *  Return Metrics data about the current AudioTrack instance.\n     *\n     * @return a {@link PersistableBundle} containing the set of attributes and values\n     * available for the media being handled by this instance of AudioRecord\n     * The attributes are descibed in {@link MetricsConstants}.\n     *\n     * Additional vendor-specific fields may also be present in\n     * the return value.\n     ",
    "links" : [ "MetricsConstants", "android.os.PersistableBundle" ]
  }, {
    "name" : "private native PersistableBundle native_getMetrics()",
    "returnType" : "PersistableBundle",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public void setRecordPositionUpdateListener(OnRecordPositionUpdateListener listener)",
    "returnType" : "void",
    "comment" : "\n     * Sets the listener the AudioRecord notifies when a previously set marker is reached or\n     * for each periodic record head position update.\n     * @param listener\n     ",
    "links" : [ ]
  }, {
    "name" : "public void setRecordPositionUpdateListener(OnRecordPositionUpdateListener listener, Handler handler)",
    "returnType" : "void",
    "comment" : "\n     * Sets the listener the AudioRecord notifies when a previously set marker is reached or\n     * for each periodic record head position update.\n     * Use this method to receive AudioRecord events in the Handler associated with another\n     * thread than the one in which you created the AudioRecord instance.\n     * @param listener\n     * @param handler the Handler that will receive the event notification messages.\n     ",
    "links" : [ ]
  }, {
    "name" : "public int setNotificationMarkerPosition(int markerInFrames)",
    "returnType" : "int",
    "comment" : "\n     * Sets the marker position at which the listener is called, if set with\n     * {@link #setRecordPositionUpdateListener(OnRecordPositionUpdateListener)} or\n     * {@link #setRecordPositionUpdateListener(OnRecordPositionUpdateListener, Handler)}.\n     * @param markerInFrames marker position expressed in frames\n     * @return error code or success, see {@link #SUCCESS}, {@link #ERROR_BAD_VALUE},\n     *  {@link #ERROR_INVALID_OPERATION}\n     ",
    "links" : [ "#setRecordPositionUpdateListener(OnRecordPositionUpdateListener", "#setRecordPositionUpdateListener(OnRecordPositionUpdateListener)", "#ERROR_BAD_VALUE", "#SUCCESS", "#ERROR_INVALID_OPERATION" ]
  }, {
    "name" : "public AudioDeviceInfo getRoutedDevice()",
    "returnType" : "AudioDeviceInfo",
    "comment" : "\n     * Returns an {@link AudioDeviceInfo} identifying the current routing of this AudioRecord.\n     * Note: The query is only valid if the AudioRecord is currently recording. If it is not,\n     * <code>getRoutedDevice()</code> will return null.\n     ",
    "links" : [ "android.media.AudioDeviceInfo" ]
  }, {
    "name" : "private void testEnableNativeRoutingCallbacksLocked()",
    "returnType" : "void",
    "comment" : "\n     * Call BEFORE adding a routing callback handler.\n     ",
    "links" : [ ]
  }, {
    "name" : "private void testDisableNativeRoutingCallbacksLocked()",
    "returnType" : "void",
    "comment" : "\n     * Call AFTER removing a routing callback handler.\n     ",
    "links" : [ ]
  }, {
    "name" : "public void addOnRoutingChangedListener(AudioRouting.OnRoutingChangedListener listener, android.os.Handler handler)",
    "returnType" : "void",
    "comment" : "\n     * Adds an {@link AudioRouting.OnRoutingChangedListener} to receive notifications of\n     * routing changes on this AudioRecord.\n     * @param listener The {@link AudioRouting.OnRoutingChangedListener} interface to receive\n     * notifications of rerouting events.\n     * @param handler  Specifies the {@link Handler} object for the thread on which to execute\n     * the callback. If <code>null</code>, the {@link Handler} associated with the main\n     * {@link Looper} will be used.\n     ",
    "links" : [ "android.os.Handler", "android.os.Looper", "AudioRouting.OnRoutingChangedListener" ]
  }, {
    "name" : "public void removeOnRoutingChangedListener(AudioRouting.OnRoutingChangedListener listener)",
    "returnType" : "void",
    "comment" : "\n     * Removes an {@link AudioRouting.OnRoutingChangedListener} which has been previously added\n    * to receive rerouting notifications.\n    * @param listener The previously added {@link AudioRouting.OnRoutingChangedListener} interface\n    * to remove.\n    ",
    "links" : [ "AudioRouting.OnRoutingChangedListener" ]
  }, {
    "name" : "public void addOnRoutingChangedListener(OnRoutingChangedListener listener, android.os.Handler handler)",
    "returnType" : "void",
    "comment" : "\n     * Adds an {@link OnRoutingChangedListener} to receive notifications of routing changes\n     * on this AudioRecord.\n     * @param listener The {@link OnRoutingChangedListener} interface to receive notifications\n     * of rerouting events.\n     * @param handler  Specifies the {@link Handler} object for the thread on which to execute\n     * the callback. If <code>null</code>, the {@link Handler} associated with the main\n     * {@link Looper} will be used.\n     * @deprecated users should switch to the general purpose\n     *             {@link AudioRouting.OnRoutingChangedListener} class instead.\n     ",
    "links" : [ "OnRoutingChangedListener", "android.os.Handler", "android.os.Looper", "AudioRouting.OnRoutingChangedListener" ]
  }, {
    "name" : "public void removeOnRoutingChangedListener(OnRoutingChangedListener listener)",
    "returnType" : "void",
    "comment" : "\n      * Removes an {@link OnRoutingChangedListener} which has been previously added\n     * to receive rerouting notifications.\n     * @param listener The previously added {@link OnRoutingChangedListener} interface to remove.\n     * @deprecated users should switch to the general purpose\n     *             {@link AudioRouting.OnRoutingChangedListener} class instead.\n     ",
    "links" : [ "OnRoutingChangedListener", "AudioRouting.OnRoutingChangedListener" ]
  }, {
    "name" : "private void broadcastRoutingChange()",
    "returnType" : "void",
    "comment" : "\n     * Sends device list change notification to all listeners.\n     ",
    "links" : [ ]
  }, {
    "name" : "public int setPositionNotificationPeriod(int periodInFrames)",
    "returnType" : "int",
    "comment" : "\n     * Sets the period at which the listener is called, if set with\n     * {@link #setRecordPositionUpdateListener(OnRecordPositionUpdateListener)} or\n     * {@link #setRecordPositionUpdateListener(OnRecordPositionUpdateListener, Handler)}.\n     * It is possible for notifications to be lost if the period is too small.\n     * @param periodInFrames update period expressed in frames\n     * @return error code or success, see {@link #SUCCESS}, {@link #ERROR_INVALID_OPERATION}\n     ",
    "links" : [ "#setRecordPositionUpdateListener(OnRecordPositionUpdateListener", "#setRecordPositionUpdateListener(OnRecordPositionUpdateListener)", "#SUCCESS", "#ERROR_INVALID_OPERATION" ]
  }, {
    "name" : "public boolean setPreferredDevice(AudioDeviceInfo deviceInfo)",
    "returnType" : "boolean",
    "comment" : "\n     * Specifies an audio device (via an {@link AudioDeviceInfo} object) to route\n     * the input to this AudioRecord.\n     * @param deviceInfo The {@link AudioDeviceInfo} specifying the audio source.\n     *  If deviceInfo is null, default routing is restored.\n     * @return true if successful, false if the specified {@link AudioDeviceInfo} is non-null and\n     * does not correspond to a valid audio input device.\n     ",
    "links" : [ "android.media.AudioDeviceInfo" ]
  }, {
    "name" : "public AudioDeviceInfo getPreferredDevice()",
    "returnType" : "AudioDeviceInfo",
    "comment" : "\n     * Returns the selected input specified by {@link #setPreferredDevice}. Note that this\n     * is not guarenteed to correspond to the actual device being used for recording.\n     ",
    "links" : [ "#setPreferredDevice" ]
  }, {
    "name" : "public List<MicrophoneInfo> getActiveMicrophones() throws IOException",
    "returnType" : "List<MicrophoneInfo>",
    "comment" : "\n     * Returns a lists of {@link MicrophoneInfo} representing the active microphones.\n     * By querying channel mapping for each active microphone, developer can know how\n     * the microphone is used by each channels or a capture stream.\n     * Note that the information about the active microphones may change during a recording.\n     * See {@link AudioManager#registerAudioDeviceCallback} to be notified of changes\n     * in the audio devices, querying the active microphones then will return the latest\n     * information.\n     *\n     * @return a lists of {@link MicrophoneInfo} representing the active microphones.\n     * @throws IOException if an error occurs\n     ",
    "links" : [ "android.media.MicrophoneInfo", "android.media.AudioManager#registerAudioDeviceCallback" ]
  }, {
    "name" : "public void registerAudioRecordingCallback(@NonNull @CallbackExecutor Executor executor, @NonNull AudioManager.AudioRecordingCallback cb)",
    "returnType" : "void",
    "comment" : "\n     * Register a callback to be notified of audio capture changes via a\n     * {@link AudioManager.AudioRecordingCallback}. A callback is received when the capture path\n     * configuration changes (pre-processing, format, sampling rate...) or capture is\n     * silenced/unsilenced by the system.\n     * @param executor {@link Executor} to handle the callbacks.\n     * @param cb non-null callback to register\n     ",
    "links" : [ "AudioManager.AudioRecordingCallback", "android.annotation.CallbackExecutor" ]
  }, {
    "name" : "public void unregisterAudioRecordingCallback(@NonNull AudioManager.AudioRecordingCallback cb)",
    "returnType" : "void",
    "comment" : "\n     * Unregister an audio recording callback previously registered with\n     * {@link #registerAudioRecordingCallback(Executor, AudioManager.AudioRecordingCallback)}.\n     * @param cb non-null callback to unregister\n     ",
    "links" : [ "#registerAudioRecordingCallback(Executor" ]
  }, {
    "name" : "public AudioRecordingConfiguration getActiveRecordingConfiguration()",
    "returnType" : "AudioRecordingConfiguration",
    "comment" : "\n     * Returns the current active audio recording for this audio recorder.\n     * @return a valid {@link AudioRecordingConfiguration} if this recorder is active\n     * or null otherwise.\n     * @see AudioRecordingConfiguration\n     ",
    "links" : [ "android.media.AudioRecordingConfiguration" ]
  }, {
    "name" : "public int getPortId()",
    "returnType" : "int",
    "comment" : "\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean setPreferredMicrophoneDirection(@DirectionMode int direction)",
    "returnType" : "boolean",
    "comment" : "\n     * Specifies the logical microphone (for processing). Applications can use this to specify\n     * which side of the device to optimize capture from. Typically used in conjunction with\n     * the camera capturing video.\n     *\n     * @return true if sucessful.\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean setPreferredMicrophoneFieldDimension(@FloatRange(from = -1.0, to = 1.0) float zoom)",
    "returnType" : "boolean",
    "comment" : "\n     * Specifies the zoom factor (i.e. the field dimension) for the selected microphone\n     * (for processing). The selected microphone is determined by the use-case for the stream.\n     *\n     * @param zoom the desired field dimension of microphone capture. Range is from -1 (wide angle),\n     * though 0 (no zoom) to 1 (maximum zoom).\n     * @return true if sucessful.\n     ",
    "links" : [ ]
  }, {
    "name" : "private static void postEventFromNative(Object audiorecord_ref, int what, int arg1, int arg2, Object obj)",
    "returnType" : "void",
    "comment" : "--------------------",
    "links" : [ ]
  }, {
    "name" : "private final native int native_setup(Object audiorecord_this, Object attributes, int[] sampleRate, int channelMask, int channelIndexMask, int audioFormat, int buffSizeInBytes, int[] sessionId, String opPackageName, long nativeRecordInJavaObj)",
    "returnType" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private final native void native_finalize()",
    "returnType" : "void",
    "comment" : " TODO remove: implementation calls directly into implementation of native_release()",
    "links" : [ ]
  }, {
    "name" : "public final native void native_release()",
    "returnType" : "void",
    "comment" : "\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "private final native int native_start(int syncEvent, int sessionId)",
    "returnType" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private final native void native_stop()",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private final native int native_read_in_byte_array(byte[] audioData, int offsetInBytes, int sizeInBytes, boolean isBlocking)",
    "returnType" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private final native int native_read_in_short_array(short[] audioData, int offsetInShorts, int sizeInShorts, boolean isBlocking)",
    "returnType" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private final native int native_read_in_float_array(float[] audioData, int offsetInFloats, int sizeInFloats, boolean isBlocking)",
    "returnType" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private final native int native_read_in_direct_buffer(Object jBuffer, int sizeInBytes, boolean isBlocking)",
    "returnType" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private final native int native_get_buffer_size_in_frames()",
    "returnType" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private final native int native_set_marker_pos(int marker)",
    "returnType" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private final native int native_get_marker_pos()",
    "returnType" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private final native int native_set_pos_update_period(int updatePeriod)",
    "returnType" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private final native int native_get_pos_update_period()",
    "returnType" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private static final native int native_get_min_buff_size(int sampleRateInHz, int channelCount, int audioFormat)",
    "returnType" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private final native boolean native_setInputDevice(int deviceId)",
    "returnType" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private final native int native_getRoutedDeviceId()",
    "returnType" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private final native void native_enableDeviceCallback()",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private final native void native_disableDeviceCallback()",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private final native int native_get_timestamp(@NonNull AudioTimestamp outTimestamp, @AudioTimestamp.Timebase int timebase)",
    "returnType" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private final native int native_get_active_microphones(ArrayList<MicrophoneInfo> activeMicrophones)",
    "returnType" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private native int native_getPortId()",
    "returnType" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private native int native_set_preferred_microphone_direction(int direction)",
    "returnType" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private native int native_set_preferred_microphone_field_dimension(float zoom)",
    "returnType" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private static void logd(String msg)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private static void loge(String msg)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  } ],
  "variableNames" : [ "STATE_UNINITIALIZED", "STATE_INITIALIZED", "RECORDSTATE_STOPPED", "RECORDSTATE_RECORDING", "SUCCESS", "ERROR", "ERROR_BAD_VALUE", "ERROR_INVALID_OPERATION", "ERROR_DEAD_OBJECT", "AUDIORECORD_ERROR_SETUP_ZEROFRAMECOUNT", "AUDIORECORD_ERROR_SETUP_INVALIDCHANNELMASK", "AUDIORECORD_ERROR_SETUP_INVALIDFORMAT", "AUDIORECORD_ERROR_SETUP_INVALIDSOURCE", "AUDIORECORD_ERROR_SETUP_NATIVEINITFAILED", "NATIVE_EVENT_MARKER", "NATIVE_EVENT_NEW_POS", "TAG", "SUBMIX_FIXED_VOLUME", "READ_BLOCKING", "READ_NON_BLOCKING", "mNativeRecorderInJavaObj", "mNativeCallbackCookie", "mNativeDeviceCallback", "mAudioCapturePolicy", "mSampleRate", "mChannelCount", "mChannelMask", "mChannelIndexMask", "mAudioFormat", "mRecordSource", "mState", "mRecordingState", "mRecordingStateLock", "mPositionListener", "mPositionListenerLock", "mEventHandler", "mInitializationLooper", "mNativeBufferSizeInBytes", "mSessionId", "mAudioAttributes", "mIsSubmixFullVolume", "mICallBack", "mRoutingChangeListeners", "mPreferredDevice", "mRecordingInfoImpl" ],
  "methodNames" : [ "private String getCurrentOpPackageName()", "private void unregisterAudioPolicyOnRelease(AudioPolicy audioPolicy)", " void deferred_connect(long nativeRecordInJavaObj)", "private static int getChannelMaskFromLegacyConfig(int inChannelConfig, boolean allowLegacyConfig)", "private void audioParamCheck(int audioSource, int sampleRateInHz, int audioFormat) throws IllegalArgumentException", "private void audioBuffSizeCheck(int audioBufferSize) throws IllegalArgumentException", "public void release()", "protected void finalize()", "public int getSampleRate()", "public int getAudioSource()", "public int getAudioFormat()", "public int getChannelConfiguration()", "public AudioFormat getFormat()", "public int getChannelCount()", "public int getState()", "public int getRecordingState()", "public int getBufferSizeInFrames()", "public int getNotificationMarkerPosition()", "public int getPositionNotificationPeriod()", "public int getTimestamp(@NonNull AudioTimestamp outTimestamp, @AudioTimestamp.Timebase int timebase)", "public static int getMinBufferSize(int sampleRateInHz, int channelConfig, int audioFormat)", "public int getAudioSessionId()", "public boolean isPrivacySensitive()", "public void startRecording() throws IllegalStateException", "public void startRecording(MediaSyncEvent syncEvent) throws IllegalStateException", "public void stop() throws IllegalStateException", "private void handleFullVolumeRec(boolean starting)", "public int read(@NonNull byte[] audioData, int offsetInBytes, int sizeInBytes)", "public int read(@NonNull byte[] audioData, int offsetInBytes, int sizeInBytes, @ReadMode int readMode)", "public int read(@NonNull short[] audioData, int offsetInShorts, int sizeInShorts)", "public int read(@NonNull short[] audioData, int offsetInShorts, int sizeInShorts, @ReadMode int readMode)", "public int read(@NonNull float[] audioData, int offsetInFloats, int sizeInFloats, @ReadMode int readMode)", "public int read(@NonNull ByteBuffer audioBuffer, int sizeInBytes)", "public int read(@NonNull ByteBuffer audioBuffer, int sizeInBytes, @ReadMode int readMode)", "public PersistableBundle getMetrics()", "private native PersistableBundle native_getMetrics()", "public void setRecordPositionUpdateListener(OnRecordPositionUpdateListener listener)", "public void setRecordPositionUpdateListener(OnRecordPositionUpdateListener listener, Handler handler)", "public int setNotificationMarkerPosition(int markerInFrames)", "public AudioDeviceInfo getRoutedDevice()", "private void testEnableNativeRoutingCallbacksLocked()", "private void testDisableNativeRoutingCallbacksLocked()", "public void addOnRoutingChangedListener(AudioRouting.OnRoutingChangedListener listener, android.os.Handler handler)", "public void removeOnRoutingChangedListener(AudioRouting.OnRoutingChangedListener listener)", "public void addOnRoutingChangedListener(OnRoutingChangedListener listener, android.os.Handler handler)", "public void removeOnRoutingChangedListener(OnRoutingChangedListener listener)", "private void broadcastRoutingChange()", "public int setPositionNotificationPeriod(int periodInFrames)", "public boolean setPreferredDevice(AudioDeviceInfo deviceInfo)", "public AudioDeviceInfo getPreferredDevice()", "public List<MicrophoneInfo> getActiveMicrophones() throws IOException", "public void registerAudioRecordingCallback(@NonNull @CallbackExecutor Executor executor, @NonNull AudioManager.AudioRecordingCallback cb)", "public void unregisterAudioRecordingCallback(@NonNull AudioManager.AudioRecordingCallback cb)", "public AudioRecordingConfiguration getActiveRecordingConfiguration()", "public int getPortId()", "public boolean setPreferredMicrophoneDirection(@DirectionMode int direction)", "public boolean setPreferredMicrophoneFieldDimension(@FloatRange(from = -1.0, to = 1.0) float zoom)", "private static void postEventFromNative(Object audiorecord_ref, int what, int arg1, int arg2, Object obj)", "private final native int native_setup(Object audiorecord_this, Object attributes, int[] sampleRate, int channelMask, int channelIndexMask, int audioFormat, int buffSizeInBytes, int[] sessionId, String opPackageName, long nativeRecordInJavaObj)", "private final native void native_finalize()", "public final native void native_release()", "private final native int native_start(int syncEvent, int sessionId)", "private final native void native_stop()", "private final native int native_read_in_byte_array(byte[] audioData, int offsetInBytes, int sizeInBytes, boolean isBlocking)", "private final native int native_read_in_short_array(short[] audioData, int offsetInShorts, int sizeInShorts, boolean isBlocking)", "private final native int native_read_in_float_array(float[] audioData, int offsetInFloats, int sizeInFloats, boolean isBlocking)", "private final native int native_read_in_direct_buffer(Object jBuffer, int sizeInBytes, boolean isBlocking)", "private final native int native_get_buffer_size_in_frames()", "private final native int native_set_marker_pos(int marker)", "private final native int native_get_marker_pos()", "private final native int native_set_pos_update_period(int updatePeriod)", "private final native int native_get_pos_update_period()", "private static final native int native_get_min_buff_size(int sampleRateInHz, int channelCount, int audioFormat)", "private final native boolean native_setInputDevice(int deviceId)", "private final native int native_getRoutedDeviceId()", "private final native void native_enableDeviceCallback()", "private final native void native_disableDeviceCallback()", "private final native int native_get_timestamp(@NonNull AudioTimestamp outTimestamp, @AudioTimestamp.Timebase int timebase)", "private final native int native_get_active_microphones(ArrayList<MicrophoneInfo> activeMicrophones)", "private native int native_getPortId()", "private native int native_set_preferred_microphone_direction(int direction)", "private native int native_set_preferred_microphone_field_dimension(float zoom)", "private static void logd(String msg)", "private static void loge(String msg)" ]
}