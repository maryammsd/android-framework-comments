{
  "filePath" : "/home/maryam/clearblue/files/android-source-30/android/view/InputDevice.java",
  "packageName" : "android.view",
  "className" : "InputDevice",
  "comment" : "\n * Describes the capabilities of a particular input device.\n * <p>\n * Each input device may support multiple classes of input.  For example, a multi-function\n * keyboard may compose the capabilities of a standard keyboard together with a track pad mouse\n * or other pointing device.\n * </p><p>\n * Some input devices present multiple distinguishable sources of input.\n * Applications can query the framework about the characteristics of each distinct source.\n * </p><p>\n * As a further wrinkle, different kinds of input sources uses different coordinate systems\n * to describe motion events.  Refer to the comments on the input source constants for\n * the appropriate interpretation.\n * </p>\n ",
  "variables" : [ {
    "name" : "mId",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mGeneration",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mControllerNumber",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mName",
    "type" : "String",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mVendorId",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mProductId",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mDescriptor",
    "type" : "String",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mIdentifier",
    "type" : "InputDeviceIdentifier",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mIsExternal",
    "type" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mSources",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mKeyboardType",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mKeyCharacterMap",
    "type" : "KeyCharacterMap",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mHasVibrator",
    "type" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mHasMicrophone",
    "type" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mHasButtonUnderPad",
    "type" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mMotionRanges",
    "type" : "ArrayList<MotionRange>",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mVibrator",
    "type" : "Vibrator",
    "comment" : " guarded by mMotionRanges during initialization",
    "links" : [ ]
  }, {
    "name" : "SOURCE_CLASS_MASK",
    "type" : "int",
    "comment" : "\n     * A mask for input source classes.\n     *\n     * Each distinct input source constant has one or more input source class bits set to\n     * specify the desired interpretation for its input events.\n     ",
    "links" : [ ]
  }, {
    "name" : "SOURCE_CLASS_NONE",
    "type" : "int",
    "comment" : "\n     * The input source has no class.\n     *\n     * It is up to the application to determine how to handle the device based on the device type.\n     ",
    "links" : [ ]
  }, {
    "name" : "SOURCE_CLASS_BUTTON",
    "type" : "int",
    "comment" : "\n     * The input source has buttons or keys.\n     * Examples: {@link #SOURCE_KEYBOARD}, {@link #SOURCE_DPAD}.\n     *\n     * A {@link KeyEvent} should be interpreted as a button or key press.\n     *\n     * Use {@link #getKeyCharacterMap} to query the device's button and key mappings.\n     ",
    "links" : [ "#SOURCE_KEYBOARD", "#SOURCE_DPAD", "KeyEvent", "#getKeyCharacterMap" ]
  }, {
    "name" : "SOURCE_CLASS_POINTER",
    "type" : "int",
    "comment" : "\n     * The input source is a pointing device associated with a display.\n     * Examples: {@link #SOURCE_TOUCHSCREEN}, {@link #SOURCE_MOUSE}.\n     *\n     * A {@link MotionEvent} should be interpreted as absolute coordinates in\n     * display units according to the {@link View} hierarchy.  Pointer down/up indicated when\n     * the finger touches the display or when the selection button is pressed/released.\n     *\n     * Use {@link #getMotionRange} to query the range of the pointing device.  Some devices permit\n     * touches outside the display area so the effective range may be somewhat smaller or larger\n     * than the actual display size.\n     ",
    "links" : [ "#SOURCE_TOUCHSCREEN", "#SOURCE_MOUSE", "MotionEvent", "View", "#getMotionRange" ]
  }, {
    "name" : "SOURCE_CLASS_TRACKBALL",
    "type" : "int",
    "comment" : "\n     * The input source is a trackball navigation device.\n     * Examples: {@link #SOURCE_TRACKBALL}.\n     *\n     * A {@link MotionEvent} should be interpreted as relative movements in device-specific\n     * units used for navigation purposes.  Pointer down/up indicates when the selection button\n     * is pressed/released.\n     *\n     * Use {@link #getMotionRange} to query the range of motion.\n     ",
    "links" : [ "#SOURCE_TRACKBALL", "MotionEvent", "#getMotionRange" ]
  }, {
    "name" : "SOURCE_CLASS_POSITION",
    "type" : "int",
    "comment" : "\n     * The input source is an absolute positioning device not associated with a display\n     * (unlike {@link #SOURCE_CLASS_POINTER}).\n     *\n     * A {@link MotionEvent} should be interpreted as absolute coordinates in\n     * device-specific surface units.\n     *\n     * Use {@link #getMotionRange} to query the range of positions.\n     ",
    "links" : [ "#SOURCE_CLASS_POINTER", "MotionEvent", "#getMotionRange" ]
  }, {
    "name" : "SOURCE_CLASS_JOYSTICK",
    "type" : "int",
    "comment" : "\n     * The input source is a joystick.\n     *\n     * A {@link MotionEvent} should be interpreted as absolute joystick movements.\n     *\n     * Use {@link #getMotionRange} to query the range of positions.\n     ",
    "links" : [ "MotionEvent", "#getMotionRange" ]
  }, {
    "name" : "SOURCE_UNKNOWN",
    "type" : "int",
    "comment" : "\n     * The input source is unknown.\n     ",
    "links" : [ ]
  }, {
    "name" : "SOURCE_KEYBOARD",
    "type" : "int",
    "comment" : "\n     * The input source is a keyboard.\n     *\n     * This source indicates pretty much anything that has buttons.  Use\n     * {@link #getKeyboardType()} to determine whether the keyboard has alphabetic keys\n     * and can be used to enter text.\n     *\n     * @see #SOURCE_CLASS_BUTTON\n     ",
    "links" : [ "#getKeyboardType" ]
  }, {
    "name" : "SOURCE_DPAD",
    "type" : "int",
    "comment" : "\n     * The input source is a DPad.\n     *\n     * @see #SOURCE_CLASS_BUTTON\n     ",
    "links" : [ ]
  }, {
    "name" : "SOURCE_GAMEPAD",
    "type" : "int",
    "comment" : "\n     * The input source is a game pad.\n     * (It may also be a {@link #SOURCE_JOYSTICK}).\n     *\n     * @see #SOURCE_CLASS_BUTTON\n     ",
    "links" : [ "#SOURCE_JOYSTICK" ]
  }, {
    "name" : "SOURCE_TOUCHSCREEN",
    "type" : "int",
    "comment" : "\n     * The input source is a touch screen pointing device.\n     *\n     * @see #SOURCE_CLASS_POINTER\n     ",
    "links" : [ ]
  }, {
    "name" : "SOURCE_MOUSE",
    "type" : "int",
    "comment" : "\n     * The input source is a mouse pointing device.\n     * This code is also used for other mouse-like pointing devices such as trackpads\n     * and trackpoints.\n     *\n     * @see #SOURCE_CLASS_POINTER\n     ",
    "links" : [ ]
  }, {
    "name" : "SOURCE_STYLUS",
    "type" : "int",
    "comment" : "\n     * The input source is a stylus pointing device.\n     * <p>\n     * Note that this bit merely indicates that an input device is capable of obtaining\n     * input from a stylus.  To determine whether a given touch event was produced\n     * by a stylus, examine the tool type returned by {@link MotionEvent#getToolType(int)}\n     * for each individual pointer.\n     * </p><p>\n     * A single touch event may multiple pointers with different tool types,\n     * such as an event that has one pointer with tool type\n     * {@link MotionEvent#TOOL_TYPE_FINGER} and another pointer with tool type\n     * {@link MotionEvent#TOOL_TYPE_STYLUS}.  So it is important to examine\n     * the tool type of each pointer, regardless of the source reported\n     * by {@link MotionEvent#getSource()}.\n     * </p>\n     *\n     * @see #SOURCE_CLASS_POINTER\n     ",
    "links" : [ "MotionEvent#getToolType", "MotionEvent#TOOL_TYPE_FINGER", "MotionEvent#TOOL_TYPE_STYLUS", "MotionEvent#getSource" ]
  }, {
    "name" : "SOURCE_BLUETOOTH_STYLUS",
    "type" : "int",
    "comment" : "\n     * The input device is a Bluetooth stylus.\n     * <p>\n     * Note that this bit merely indicates that an input device is capable of\n     * obtaining input from a Bluetooth stylus.  To determine whether a given\n     * touch event was produced by a stylus, examine the tool type returned by\n     * {@link MotionEvent#getToolType(int)} for each individual pointer.\n     * </p><p>\n     * A single touch event may multiple pointers with different tool types,\n     * such as an event that has one pointer with tool type\n     * {@link MotionEvent#TOOL_TYPE_FINGER} and another pointer with tool type\n     * {@link MotionEvent#TOOL_TYPE_STYLUS}.  So it is important to examine\n     * the tool type of each pointer, regardless of the source reported\n     * by {@link MotionEvent#getSource()}.\n     * </p><p>\n     * A bluetooth stylus generally receives its pressure and button state\n     * information from the stylus itself, and derives the rest from another\n     * source. For example, a Bluetooth stylus used in conjunction with a\n     * touchscreen would derive its contact position and pointer size from the\n     * touchscreen and may not be any more accurate than other tools such as\n     * fingers.\n     * </p>\n     *\n     * @see #SOURCE_STYLUS\n     * @see #SOURCE_CLASS_POINTER\n     ",
    "links" : [ "MotionEvent#getToolType", "MotionEvent#TOOL_TYPE_FINGER", "MotionEvent#TOOL_TYPE_STYLUS", "MotionEvent#getSource" ]
  }, {
    "name" : "SOURCE_TRACKBALL",
    "type" : "int",
    "comment" : "\n     * The input source is a trackball.\n     *\n     * @see #SOURCE_CLASS_TRACKBALL\n     ",
    "links" : [ ]
  }, {
    "name" : "SOURCE_MOUSE_RELATIVE",
    "type" : "int",
    "comment" : "\n     * The input source is a mouse device whose relative motions should be interpreted as\n     * navigation events.\n     *\n     * @see #SOURCE_CLASS_TRACKBALL\n     ",
    "links" : [ ]
  }, {
    "name" : "SOURCE_TOUCHPAD",
    "type" : "int",
    "comment" : "\n     * The input source is a touch pad or digitizer tablet that is not\n     * associated with a display (unlike {@link #SOURCE_TOUCHSCREEN}).\n     *\n     * @see #SOURCE_CLASS_POSITION\n     ",
    "links" : [ "#SOURCE_TOUCHSCREEN" ]
  }, {
    "name" : "SOURCE_TOUCH_NAVIGATION",
    "type" : "int",
    "comment" : "\n     * The input source is a touch device whose motions should be interpreted as navigation events.\n     *\n     * For example, an upward swipe should be as an upward focus traversal in the same manner as\n     * pressing up on a D-Pad would be. Swipes to the left, right and down should be treated in a\n     * similar manner.\n     *\n     * @see #SOURCE_CLASS_NONE\n     ",
    "links" : [ ]
  }, {
    "name" : "SOURCE_ROTARY_ENCODER",
    "type" : "int",
    "comment" : "\n     * The input source is a rotating encoder device whose motions should be interpreted as akin to\n     * those of a scroll wheel.\n     *\n     * @see #SOURCE_CLASS_NONE\n     ",
    "links" : [ ]
  }, {
    "name" : "SOURCE_JOYSTICK",
    "type" : "int",
    "comment" : "\n     * The input source is a joystick.\n     * (It may also be a {@link #SOURCE_GAMEPAD}).\n     *\n     * @see #SOURCE_CLASS_JOYSTICK\n     ",
    "links" : [ "#SOURCE_GAMEPAD" ]
  }, {
    "name" : "SOURCE_HDMI",
    "type" : "int",
    "comment" : "\n     * The input source is a device connected through HDMI-based bus.\n     *\n     * The key comes in through HDMI-CEC or MHL signal line, and is treated as if it were\n     * generated by a locally connected DPAD or keyboard.\n     ",
    "links" : [ ]
  }, {
    "name" : "SOURCE_ANY",
    "type" : "int",
    "comment" : "\n     * A special input source constant that is used when filtering input devices\n     * to match devices that provide any type of input source.\n     ",
    "links" : [ ]
  }, {
    "name" : "MOTION_RANGE_X",
    "type" : "int",
    "comment" : "\n     * Constant for retrieving the range of values for {@link MotionEvent#AXIS_X}.\n     *\n     * @see #getMotionRange\n     * @deprecated Use {@link MotionEvent#AXIS_X} instead.\n     ",
    "links" : [ "MotionEvent#AXIS_X", "MotionEvent#AXIS_X" ]
  }, {
    "name" : "MOTION_RANGE_Y",
    "type" : "int",
    "comment" : "\n     * Constant for retrieving the range of values for {@link MotionEvent#AXIS_Y}.\n     *\n     * @see #getMotionRange\n     * @deprecated Use {@link MotionEvent#AXIS_Y} instead.\n     ",
    "links" : [ "MotionEvent#AXIS_Y", "MotionEvent#AXIS_Y" ]
  }, {
    "name" : "MOTION_RANGE_PRESSURE",
    "type" : "int",
    "comment" : "\n     * Constant for retrieving the range of values for {@link MotionEvent#AXIS_PRESSURE}.\n     *\n     * @see #getMotionRange\n     * @deprecated Use {@link MotionEvent#AXIS_PRESSURE} instead.\n     ",
    "links" : [ "MotionEvent#AXIS_PRESSURE", "MotionEvent#AXIS_PRESSURE" ]
  }, {
    "name" : "MOTION_RANGE_SIZE",
    "type" : "int",
    "comment" : "\n     * Constant for retrieving the range of values for {@link MotionEvent#AXIS_SIZE}.\n     *\n     * @see #getMotionRange\n     * @deprecated Use {@link MotionEvent#AXIS_SIZE} instead.\n     ",
    "links" : [ "MotionEvent#AXIS_SIZE", "MotionEvent#AXIS_SIZE" ]
  }, {
    "name" : "MOTION_RANGE_TOUCH_MAJOR",
    "type" : "int",
    "comment" : "\n     * Constant for retrieving the range of values for {@link MotionEvent#AXIS_TOUCH_MAJOR}.\n     *\n     * @see #getMotionRange\n     * @deprecated Use {@link MotionEvent#AXIS_TOUCH_MAJOR} instead.\n     ",
    "links" : [ "MotionEvent#AXIS_TOUCH_MAJOR", "MotionEvent#AXIS_TOUCH_MAJOR" ]
  }, {
    "name" : "MOTION_RANGE_TOUCH_MINOR",
    "type" : "int",
    "comment" : "\n     * Constant for retrieving the range of values for {@link MotionEvent#AXIS_TOUCH_MINOR}.\n     *\n     * @see #getMotionRange\n     * @deprecated Use {@link MotionEvent#AXIS_TOUCH_MINOR} instead.\n     ",
    "links" : [ "MotionEvent#AXIS_TOUCH_MINOR", "MotionEvent#AXIS_TOUCH_MINOR" ]
  }, {
    "name" : "MOTION_RANGE_TOOL_MAJOR",
    "type" : "int",
    "comment" : "\n     * Constant for retrieving the range of values for {@link MotionEvent#AXIS_TOOL_MAJOR}.\n     *\n     * @see #getMotionRange\n     * @deprecated Use {@link MotionEvent#AXIS_TOOL_MAJOR} instead.\n     ",
    "links" : [ "MotionEvent#AXIS_TOOL_MAJOR", "MotionEvent#AXIS_TOOL_MAJOR" ]
  }, {
    "name" : "MOTION_RANGE_TOOL_MINOR",
    "type" : "int",
    "comment" : "\n     * Constant for retrieving the range of values for {@link MotionEvent#AXIS_TOOL_MINOR}.\n     *\n     * @see #getMotionRange\n     * @deprecated Use {@link MotionEvent#AXIS_TOOL_MINOR} instead.\n     ",
    "links" : [ "MotionEvent#AXIS_TOOL_MINOR", "MotionEvent#AXIS_TOOL_MINOR" ]
  }, {
    "name" : "MOTION_RANGE_ORIENTATION",
    "type" : "int",
    "comment" : "\n     * Constant for retrieving the range of values for {@link MotionEvent#AXIS_ORIENTATION}.\n     *\n     * @see #getMotionRange\n     * @deprecated Use {@link MotionEvent#AXIS_ORIENTATION} instead.\n     ",
    "links" : [ "MotionEvent#AXIS_ORIENTATION", "MotionEvent#AXIS_ORIENTATION" ]
  }, {
    "name" : "KEYBOARD_TYPE_NONE",
    "type" : "int",
    "comment" : "\n     * There is no keyboard.\n     ",
    "links" : [ ]
  }, {
    "name" : "KEYBOARD_TYPE_NON_ALPHABETIC",
    "type" : "int",
    "comment" : "\n     * The keyboard is not fully alphabetic.  It may be a numeric keypad or an assortment\n     * of buttons that are not mapped as alphabetic keys suitable for text input.\n     ",
    "links" : [ ]
  }, {
    "name" : "KEYBOARD_TYPE_ALPHABETIC",
    "type" : "int",
    "comment" : "\n     * The keyboard supports a complement of alphabetic keys.\n     ",
    "links" : [ ]
  }, {
    "name" : "MAX_RANGES",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "CREATOR",
    "type" : "Parcelable.Creator<InputDevice>",
    "comment" : "",
    "links" : [ ]
  } ],
  "methods" : [ {
    "name" : "public static InputDevice getDevice(int id)",
    "returnType" : "InputDevice",
    "comment" : "\n     * Gets information about the input device with the specified id.\n     * @param id The device id.\n     * @return The input device or null if not found.\n     ",
    "links" : [ ]
  }, {
    "name" : "public static int[] getDeviceIds()",
    "returnType" : "int[]",
    "comment" : "\n     * Gets the ids of all input devices in the system.\n     * @return The input device ids.\n     ",
    "links" : [ ]
  }, {
    "name" : "public int getId()",
    "returnType" : "int",
    "comment" : "\n     * Gets the input device id.\n     * <p>\n     * Each input device receives a unique id when it is first configured\n     * by the system.  The input device id may change when the system is restarted or if the\n     * input device is disconnected, reconnected or reconfigured at any time.\n     * If you require a stable identifier for a device that persists across\n     * boots and reconfigurations, use {@link #getDescriptor()}.\n     * </p>\n     *\n     * @return The input device id.\n     ",
    "links" : [ "#getDescriptor" ]
  }, {
    "name" : "public int getControllerNumber()",
    "returnType" : "int",
    "comment" : "\n     * The controller number for a given input device.\n     * <p>\n     * Each gamepad or joystick is given a unique, positive controller number when initially\n     * configured by the system. This number may change due to events such as device disconnects /\n     * reconnects or user initiated reassignment. Any change in number will trigger an event that\n     * can be observed by registering an {@link InputManager.InputDeviceListener}.\n     * </p>\n     * <p>\n     * All input devices which are not gamepads or joysticks will be assigned a controller number\n     * of 0.\n     * </p>\n     *\n     * @return The controller number of the device.\n     ",
    "links" : [ "InputManager.InputDeviceListener" ]
  }, {
    "name" : "public InputDeviceIdentifier getIdentifier()",
    "returnType" : "InputDeviceIdentifier",
    "comment" : "\n     * The set of identifying information for type of input device. This\n     * information can be used by the system to configure appropriate settings\n     * for the device.\n     *\n     * @return The identifier object for this device\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public int getGeneration()",
    "returnType" : "int",
    "comment" : "\n     * Gets a generation number for this input device.\n     * The generation number is incremented whenever the device is reconfigured and its\n     * properties may have changed.\n     *\n     * @return The generation number.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public int getVendorId()",
    "returnType" : "int",
    "comment" : "\n     * Gets the vendor id for the given device, if available.\n     * <p>\n     * A vendor id uniquely identifies the company who manufactured the device. A value of 0 will\n     * be assigned where a vendor id is not available.\n     * </p>\n     *\n     * @return The vendor id of a given device\n     ",
    "links" : [ ]
  }, {
    "name" : "public int getProductId()",
    "returnType" : "int",
    "comment" : "\n     * Gets the product id for the given device, if available.\n     * <p>\n     * A product id uniquely identifies which product within the address space of a given vendor,\n     * identified by the device's vendor id. A value of 0 will be assigned where a product id is\n     * not available.\n     * </p>\n     *\n     * @return The product id of a given device\n     ",
    "links" : [ ]
  }, {
    "name" : "public String getDescriptor()",
    "returnType" : "String",
    "comment" : "\n     * Gets the input device descriptor, which is a stable identifier for an input device.\n     * <p>\n     * An input device descriptor uniquely identifies an input device.  Its value\n     * is intended to be persistent across system restarts, and should not change even\n     * if the input device is disconnected, reconnected or reconfigured at any time.\n     * </p><p>\n     * It is possible for there to be multiple {@link InputDevice} instances that have the\n     * same input device descriptor.  This might happen in situations where a single\n     * human input device registers multiple {@link InputDevice} instances (HID collections)\n     * that describe separate features of the device, such as a keyboard that also\n     * has a trackpad.  Alternately, it may be that the input devices are simply\n     * indistinguishable, such as two keyboards made by the same manufacturer.\n     * </p><p>\n     * The input device descriptor returned by {@link #getDescriptor} should only be\n     * used when an application needs to remember settings associated with a particular\n     * input device.  For all other purposes when referring to a logical\n     * {@link InputDevice} instance at runtime use the id returned by {@link #getId()}.\n     * </p>\n     *\n     * @return The input device descriptor.\n     ",
    "links" : [ "InputDevice", "InputDevice", "#getDescriptor", "InputDevice", "#getId" ]
  }, {
    "name" : "public boolean isVirtual()",
    "returnType" : "boolean",
    "comment" : "\n     * Returns true if the device is a virtual input device rather than a real one,\n     * such as the virtual keyboard (see {@link KeyCharacterMap#VIRTUAL_KEYBOARD}).\n     * <p>\n     * Virtual input devices are provided to implement system-level functionality\n     * and should not be seen or configured by users.\n     * </p>\n     *\n     * @return True if the device is virtual.\n     *\n     * @see KeyCharacterMap#VIRTUAL_KEYBOARD\n     ",
    "links" : [ "KeyCharacterMap#VIRTUAL_KEYBOARD" ]
  }, {
    "name" : "public boolean isExternal()",
    "returnType" : "boolean",
    "comment" : "\n     * Returns true if the device is external (connected to USB or Bluetooth or some other\n     * peripheral bus), otherwise it is built-in.\n     *\n     * @return True if the device is external.\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean isFullKeyboard()",
    "returnType" : "boolean",
    "comment" : "\n     * Returns true if the device is a full keyboard.\n     *\n     * @return True if the device is a full keyboard.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public String getName()",
    "returnType" : "String",
    "comment" : "\n     * Gets the name of this input device.\n     * @return The input device name.\n     ",
    "links" : [ ]
  }, {
    "name" : "public int getSources()",
    "returnType" : "int",
    "comment" : "\n     * Gets the input sources supported by this input device as a combined bitfield.\n     * @return The supported input sources.\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean supportsSource(int source)",
    "returnType" : "boolean",
    "comment" : "\n     * Determines whether the input device supports the given source or sources.\n     *\n     * @param source The input source or sources to check against. This can be a generic device\n     * type such as {@link InputDevice#SOURCE_MOUSE}, a more generic device class, such as\n     * {@link InputDevice#SOURCE_CLASS_POINTER}, or a combination of sources bitwise ORed together.\n     * @return Whether the device can produce all of the given sources.\n     ",
    "links" : [ "InputDevice#SOURCE_MOUSE", "InputDevice#SOURCE_CLASS_POINTER" ]
  }, {
    "name" : "public int getKeyboardType()",
    "returnType" : "int",
    "comment" : "\n     * Gets the keyboard type.\n     * @return The keyboard type.\n     ",
    "links" : [ ]
  }, {
    "name" : "public KeyCharacterMap getKeyCharacterMap()",
    "returnType" : "KeyCharacterMap",
    "comment" : "\n     * Gets the key character map associated with this input device.\n     * @return The key character map.\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean[] hasKeys(int... keys)",
    "returnType" : "boolean[]",
    "comment" : "\n     * Gets whether the device is capable of producing the list of keycodes.\n     * @param keys The list of android keycodes to check for.\n     * @return An array of booleans where each member specifies whether the device is capable of\n     * generating the keycode given by the corresponding value at the same index in the keys array.\n     ",
    "links" : [ ]
  }, {
    "name" : "public MotionRange getMotionRange(int axis)",
    "returnType" : "MotionRange",
    "comment" : "\n     * Gets information about the range of values for a particular {@link MotionEvent} axis.\n     * If the device supports multiple sources, the same axis may have different meanings\n     * for each source.  Returns information about the first axis found for any source.\n     * To obtain information about the axis for a specific source, use\n     * {@link #getMotionRange(int, int)}.\n     *\n     * @param axis The axis constant.\n     * @return The range of values, or null if the requested axis is not\n     * supported by the device.\n     *\n     * @see MotionEvent#AXIS_X\n     * @see MotionEvent#AXIS_Y\n     ",
    "links" : [ "MotionEvent", "#getMotionRange" ]
  }, {
    "name" : "public MotionRange getMotionRange(int axis, int source)",
    "returnType" : "MotionRange",
    "comment" : "\n     * Gets information about the range of values for a particular {@link MotionEvent} axis\n     * used by a particular source on the device.\n     * If the device supports multiple sources, the same axis may have different meanings\n     * for each source.\n     *\n     * @param axis The axis constant.\n     * @param source The source for which to return information.\n     * @return The range of values, or null if the requested axis is not\n     * supported by the device.\n     *\n     * @see MotionEvent#AXIS_X\n     * @see MotionEvent#AXIS_Y\n     ",
    "links" : [ "MotionEvent" ]
  }, {
    "name" : "public List<MotionRange> getMotionRanges()",
    "returnType" : "List<MotionRange>",
    "comment" : "\n     * Gets the ranges for all axes supported by the device.\n     * @return The motion ranges for the device.\n     *\n     * @see #getMotionRange(int, int)\n     ",
    "links" : [ ]
  }, {
    "name" : "private void addMotionRange(int axis, int source, float min, float max, float flat, float fuzz, float resolution)",
    "returnType" : "void",
    "comment" : " Called from native code.",
    "links" : [ ]
  }, {
    "name" : "public Vibrator getVibrator()",
    "returnType" : "Vibrator",
    "comment" : "\n     * Gets the vibrator service associated with the device, if there is one.\n     * Even if the device does not have a vibrator, the result is never null.\n     * Use {@link Vibrator#hasVibrator} to determine whether a vibrator is\n     * present.\n     *\n     * Note that the vibrator associated with the device may be different from\n     * the system vibrator.  To obtain an instance of the system vibrator instead, call\n     * {@link Context#getSystemService} with {@link Context#VIBRATOR_SERVICE} as argument.\n     *\n     * @return The vibrator service associated with the device, never null.\n     ",
    "links" : [ "Vibrator#hasVibrator", "Context#getSystemService", "Context#VIBRATOR_SERVICE" ]
  }, {
    "name" : "public boolean isEnabled()",
    "returnType" : "boolean",
    "comment" : "\n     * Returns true if input device is enabled.\n     * @return Whether the input device is enabled.\n     ",
    "links" : [ ]
  }, {
    "name" : "public void enable()",
    "returnType" : "void",
    "comment" : "\n     * Enables the input device.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public void disable()",
    "returnType" : "void",
    "comment" : "\n     * Disables the input device.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean hasMicrophone()",
    "returnType" : "boolean",
    "comment" : "\n     * Reports whether the device has a built-in microphone.\n     * @return Whether the device has a built-in microphone.\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean hasButtonUnderPad()",
    "returnType" : "boolean",
    "comment" : "\n     * Reports whether the device has a button under its touchpad\n     * @return Whether the device has a button under its touchpad\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public void setPointerType(int pointerType)",
    "returnType" : "void",
    "comment" : "\n     * Sets the current pointer type.\n     * @param pointerType the type of the pointer icon.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public void setCustomPointerIcon(PointerIcon icon)",
    "returnType" : "void",
    "comment" : "\n     * Specifies the current custom pointer.\n     * @param icon the icon data.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public void writeToParcel(Parcel out, int flags)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public int describeContents()",
    "returnType" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public String toString()",
    "returnType" : "String",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private void appendSourceDescriptionIfApplicable(StringBuilder description, int source, String sourceName)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  } ],
  "variableNames" : [ "mId", "mGeneration", "mControllerNumber", "mName", "mVendorId", "mProductId", "mDescriptor", "mIdentifier", "mIsExternal", "mSources", "mKeyboardType", "mKeyCharacterMap", "mHasVibrator", "mHasMicrophone", "mHasButtonUnderPad", "mMotionRanges", "mVibrator", "SOURCE_CLASS_MASK", "SOURCE_CLASS_NONE", "SOURCE_CLASS_BUTTON", "SOURCE_CLASS_POINTER", "SOURCE_CLASS_TRACKBALL", "SOURCE_CLASS_POSITION", "SOURCE_CLASS_JOYSTICK", "SOURCE_UNKNOWN", "SOURCE_KEYBOARD", "SOURCE_DPAD", "SOURCE_GAMEPAD", "SOURCE_TOUCHSCREEN", "SOURCE_MOUSE", "SOURCE_STYLUS", "SOURCE_BLUETOOTH_STYLUS", "SOURCE_TRACKBALL", "SOURCE_MOUSE_RELATIVE", "SOURCE_TOUCHPAD", "SOURCE_TOUCH_NAVIGATION", "SOURCE_ROTARY_ENCODER", "SOURCE_JOYSTICK", "SOURCE_HDMI", "SOURCE_ANY", "MOTION_RANGE_X", "MOTION_RANGE_Y", "MOTION_RANGE_PRESSURE", "MOTION_RANGE_SIZE", "MOTION_RANGE_TOUCH_MAJOR", "MOTION_RANGE_TOUCH_MINOR", "MOTION_RANGE_TOOL_MAJOR", "MOTION_RANGE_TOOL_MINOR", "MOTION_RANGE_ORIENTATION", "KEYBOARD_TYPE_NONE", "KEYBOARD_TYPE_NON_ALPHABETIC", "KEYBOARD_TYPE_ALPHABETIC", "MAX_RANGES", "CREATOR" ],
  "methodNames" : [ "public static InputDevice getDevice(int id)", "public static int[] getDeviceIds()", "public int getId()", "public int getControllerNumber()", "public InputDeviceIdentifier getIdentifier()", "public int getGeneration()", "public int getVendorId()", "public int getProductId()", "public String getDescriptor()", "public boolean isVirtual()", "public boolean isExternal()", "public boolean isFullKeyboard()", "public String getName()", "public int getSources()", "public boolean supportsSource(int source)", "public int getKeyboardType()", "public KeyCharacterMap getKeyCharacterMap()", "public boolean[] hasKeys(int... keys)", "public MotionRange getMotionRange(int axis)", "public MotionRange getMotionRange(int axis, int source)", "public List<MotionRange> getMotionRanges()", "private void addMotionRange(int axis, int source, float min, float max, float flat, float fuzz, float resolution)", "public Vibrator getVibrator()", "public boolean isEnabled()", "public void enable()", "public void disable()", "public boolean hasMicrophone()", "public boolean hasButtonUnderPad()", "public void setPointerType(int pointerType)", "public void setCustomPointerIcon(PointerIcon icon)", "public void writeToParcel(Parcel out, int flags)", "public int describeContents()", "public String toString()", "private void appendSourceDescriptionIfApplicable(StringBuilder description, int source, String sourceName)" ]
}