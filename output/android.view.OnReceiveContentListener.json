{
  "filePath" : "/home/maryam/clearblue/files/android-source-35/android/view/OnReceiveContentListener.java",
  "packageName" : "android.view",
  "className" : "OnReceiveContentListener",
  "comment" : "\n * Listener for apps to implement handling for insertion of content. Content may be both text and\n * non-text (plain/styled text, HTML, images, videos, audio files, etc).\n *\n * <p>This listener can be attached to different types of UI components using\n * {@link View#setOnReceiveContentListener}.\n *\n * <p>Here is a sample implementation that handles content URIs and delegates the processing for\n * text and everything else to the platform:<br>\n * <pre class=\"prettyprint\">\n * // (1) Define the listener\n * public class MyReceiver implements OnReceiveContentListener {\n *     public static final String[] MIME_TYPES = new String[] {\"image/*\", \"video/*\"};\n *\n *     &#64;Override\n *     public ContentInfo onReceiveContent(View view, ContentInfo payload) {\n *         Pair&lt;ContentInfo, ContentInfo&gt; split =\n *                 ContentInfoCompat.partition(payload, item -&gt; item.getUri() != null);\n *         ContentInfo uriContent = split.first;\n *         ContentInfo remaining = split.second;\n *         if (uriContent != null) {\n *             ClipData clip = uriContent.getClip();\n *             for (int i = 0; i < clip.getItemCount(); i++) {\n *                 Uri uri = clip.getItemAt(i).getUri();\n *                 // ... app-specific logic to handle the URI ...\n *             }\n *         }\n *         // Return anything that we didn't handle ourselves. This preserves the default platform\n *         // behavior for text and anything else for which we are not implementing custom handling.\n *         return remaining;\n *     }\n * }\n *\n * // (2) Register the listener\n * public class MyActivity extends Activity {\n *     &#64;Override\n *     public void onCreate(Bundle savedInstanceState) {\n *         // ...\n *\n *         EditText myInput = findViewById(R.id.my_input);\n *         myInput.setOnReceiveContentListener(MyReceiver.MIME_TYPES, new MyReceiver());\n *     }\n * </pre>\n ",
  "links" : [ "android.view.View#setOnReceiveContentListener" ],
  "variables" : [ ],
  "methods" : [ {
    "name" : " ContentInfo onReceiveContent(@NonNull View view, @NonNull ContentInfo payload)",
    "returnType" : "ContentInfo",
    "comment" : "\n     * Receive the given content.\n     *\n     * <p>Implementations should handle any content items of interest and return all unhandled\n     * items to preserve the default platform behavior for content that does not have app-specific\n     * handling. For example, an implementation may provide handling for content URIs (to provide\n     * support for inserting images, etc) and delegate the processing of text to the platform to\n     * preserve the common behavior for inserting text. See the class javadoc for a sample\n     * implementation.\n     *\n     * <h3>Handling different content</h3>\n     * <ul>\n     *     <li>Text. If the {@link ContentInfo#getSource() source} is\n     *     {@link ContentInfo#SOURCE_AUTOFILL autofill}, the view's content should be fully\n     *     replaced by the passed-in text. For sources other than autofill, the passed-in text\n     *     should overwrite the current selection or be inserted at the current cursor position\n     *     if there is no selection.\n     *     <li>Non-text content (e.g. images). The content may be inserted inline if the widget\n     *     supports this, or it may be added as an attachment (could potentially be shown in a\n     *     completely separate view).\n     * </ul>\n     *\n     * <h3>URI permissions</h3>\n     * <p>{@link android.content.Intent#FLAG_GRANT_READ_URI_PERMISSION Read permissions} are\n     * granted automatically by the platform for any\n     * {@link android.content.ContentResolver#SCHEME_CONTENT content URIs} in the payload passed\n     * to this listener. Permissions are transient and will be released automatically by the\n     * platform.\n     * <p>Processing of content should normally be done in a service or activity.\n     * For long-running processing, using {@code androidx.work.WorkManager} is recommended.\n     * When implementing this, permissions should be extended to the target service or activity\n     * by passing the content using {@link android.content.Intent#setClipData Intent.setClipData}\n     * and {@link android.content.Intent#addFlags(int) setting} the flag\n     * {@link android.content.Intent#FLAG_GRANT_READ_URI_PERMISSION FLAG_GRANT_READ_URI_PERMISSION}.\n     * <p>Alternatively, if using a background thread within the current context to process the\n     * content, a reference to the {@code payload} object should be maintained to ensure that\n     * permissions are not revoked prematurely.\n     *\n     * @param view The view where the content insertion was requested.\n     * @param payload The content to insert and related metadata. The payload may contain multiple\n     *                items and their MIME types may be different (e.g. an image item and a text\n     *                item). The payload may also contain items whose MIME type is not in the list\n     *                of MIME types specified when\n     *                {@link View#setOnReceiveContentListener setting} the listener. For\n     *                those items, the listener may reject the content (defer to the default\n     *                platform behavior) or execute some other fallback logic (e.g. show an\n     *                appropriate message to the user).\n     *\n     * @return The portion of the passed-in content whose processing should be delegated to\n     * the platform. Return null if all content was handled in some way. Actual insertion of\n     * the content may be processed asynchronously in the background and may or may not\n     * succeed even if this method returns null. For example, an app may end up not inserting\n     * an item if it exceeds the app's size limit for that type of content.\n     ",
    "links" : [ "android.content.Intent#addFlags(int)", "android.view.View#setOnReceiveContentListener", "android.view.ContentInfo#SOURCE_AUTOFILL", "android.content.ContentResolver#SCHEME_CONTENT", "android.content.Intent#setClipData", "android.view.ContentInfo#getSource()", "android.content.Intent#FLAG_GRANT_READ_URI_PERMISSION" ]
  } ],
  "methodNames" : [ " ContentInfo onReceiveContent(@NonNull View view, @NonNull ContentInfo payload)" ],
  "variableNames" : [ ]
}