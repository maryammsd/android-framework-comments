{
  "filePath" : "/home/maryam/clearblue/files/android-source-30/android/hardware/hdmi/HdmiControlManager.java",
  "packageName" : "android.hardware.hdmi",
  "className" : "HdmiControlManager",
  "comment" : "\n * The {@link HdmiControlManager} class is used to send HDMI control messages\n * to attached CEC devices.\n *\n * <p>Provides various HDMI client instances that represent HDMI-CEC logical devices\n * hosted in the system. {@link #getTvClient()}, for instance will return an\n * {@link HdmiTvClient} object if the system is configured to host one. Android system\n * can host more than one logical CEC devices. If multiple types are configured they\n * all work as if they were independent logical devices running in the system.\n *\n * @hide\n ",
  "variables" : [ {
    "name" : "TAG",
    "type" : "String",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mService",
    "type" : "IHdmiControlService",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "INVALID_PHYSICAL_ADDRESS",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mLocalPhysicalAddress",
    "type" : "int",
    "comment" : "\n     * A cache of the current device's physical address. When device's HDMI out port\n     * is not connected to any device, it is set to {@link #INVALID_PHYSICAL_ADDRESS}.\n     *\n     * <p>Otherwise it is updated by the {@link ClientHotplugEventListener} registered\n     * with {@link com.android.server.hdmi.HdmiControlService} by the\n     * {@link #addHotplugEventListener(HotplugEventListener)} and the address is from\n     * {@link com.android.server.hdmi.HdmiControlService#getPortInfo()}\n     ",
    "links" : [ "#INVALID_PHYSICAL_ADDRESS", "ClientHotplugEventListener", "com.android.server.hdmi.HdmiControlService", "#addHotplugEventListener", "com.android.server.hdmi.HdmiControlService#getPortInfo" ]
  }, {
    "name" : "mLock",
    "type" : "Object",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "ACTION_OSD_MESSAGE",
    "type" : "String",
    "comment" : "\n     * Broadcast Action: Display OSD message.\n     * <p>Send when the service has a message to display on screen for events\n     * that need user's attention such as ARC status change.\n     * <p>Always contains the extra fields {@link #EXTRA_MESSAGE_ID}.\n     * <p>Requires {@link android.Manifest.permission#HDMI_CEC} to receive.\n     ",
    "links" : [ "#EXTRA_MESSAGE_ID", "android.Manifest.permission#HDMI_CEC" ]
  }, {
    "name" : "OSD_MESSAGE_ARC_CONNECTED_INVALID_PORT",
    "type" : "int",
    "comment" : "\n     * Message that ARC enabled device is connected to invalid port (non-ARC port).\n     ",
    "links" : [ ]
  }, {
    "name" : "OSD_MESSAGE_AVR_VOLUME_CHANGED",
    "type" : "int",
    "comment" : "\n     * Message used by TV to receive volume status from Audio Receiver. It should check volume value\n     * that is retrieved from extra value with the key {@link #EXTRA_MESSAGE_EXTRA_PARAM1}. If the\n     * value is in range of [0,100], it is current volume of Audio Receiver. And there is another\n     * value, {@link #AVR_VOLUME_MUTED}, which is used to inform volume mute.\n     ",
    "links" : [ "#EXTRA_MESSAGE_EXTRA_PARAM1", "#AVR_VOLUME_MUTED" ]
  }, {
    "name" : "EXTRA_MESSAGE_ID",
    "type" : "String",
    "comment" : "\n     * Used as an extra field in the intent {@link #ACTION_OSD_MESSAGE}. Contains the ID of\n     * the message to display on screen.\n     ",
    "links" : [ "#ACTION_OSD_MESSAGE" ]
  }, {
    "name" : "EXTRA_MESSAGE_EXTRA_PARAM1",
    "type" : "String",
    "comment" : "\n     * Used as an extra field in the intent {@link #ACTION_OSD_MESSAGE}. Contains the extra value\n     * of the message.\n     ",
    "links" : [ "#ACTION_OSD_MESSAGE" ]
  }, {
    "name" : "AVR_VOLUME_MUTED",
    "type" : "int",
    "comment" : "\n     * Volume value for mute state.\n     ",
    "links" : [ ]
  }, {
    "name" : "POWER_STATUS_UNKNOWN",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "POWER_STATUS_ON",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "POWER_STATUS_STANDBY",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "POWER_STATUS_TRANSIENT_TO_ON",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "POWER_STATUS_TRANSIENT_TO_STANDBY",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "RESULT_SUCCESS",
    "type" : "int",
    "comment" : " Control operation is successfully handled by the framework. ",
    "links" : [ ]
  }, {
    "name" : "RESULT_TIMEOUT",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "RESULT_SOURCE_NOT_AVAILABLE",
    "type" : "int",
    "comment" : " Source device that the application is using is not available. ",
    "links" : [ ]
  }, {
    "name" : "RESULT_TARGET_NOT_AVAILABLE",
    "type" : "int",
    "comment" : " Target device that the application is controlling is not available. ",
    "links" : [ ]
  }, {
    "name" : "RESULT_ALREADY_IN_PROGRESS",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "RESULT_EXCEPTION",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "RESULT_INCORRECT_MODE",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "RESULT_COMMUNICATION_FAILED",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "DEVICE_EVENT_ADD_DEVICE",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "DEVICE_EVENT_REMOVE_DEVICE",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "DEVICE_EVENT_UPDATE_DEVICE",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "ONE_TOUCH_RECORD_RECORDING_CURRENTLY_SELECTED_SOURCE",
    "type" : "int",
    "comment" : " Recording currently selected source. Indicates the status of a recording. ",
    "links" : [ ]
  }, {
    "name" : "ONE_TOUCH_RECORD_RECORDING_DIGITAL_SERVICE",
    "type" : "int",
    "comment" : " Recording Digital Service. Indicates the status of a recording. ",
    "links" : [ ]
  }, {
    "name" : "ONE_TOUCH_RECORD_RECORDING_ANALOGUE_SERVICE",
    "type" : "int",
    "comment" : " Recording Analogue Service. Indicates the status of a recording. ",
    "links" : [ ]
  }, {
    "name" : "ONE_TOUCH_RECORD_RECORDING_EXTERNAL_INPUT",
    "type" : "int",
    "comment" : " Recording External input. Indicates the status of a recording. ",
    "links" : [ ]
  }, {
    "name" : "ONE_TOUCH_RECORD_UNABLE_DIGITAL_SERVICE",
    "type" : "int",
    "comment" : " No recording – unable to record Digital Service. No suitable tuner. ",
    "links" : [ ]
  }, {
    "name" : "ONE_TOUCH_RECORD_UNABLE_ANALOGUE_SERVICE",
    "type" : "int",
    "comment" : " No recording – unable to record Analogue Service. No suitable tuner. ",
    "links" : [ ]
  }, {
    "name" : "ONE_TOUCH_RECORD_UNABLE_SELECTED_SERVICE",
    "type" : "int",
    "comment" : "\n     * No recording – unable to select required service. as suitable tuner, but the requested\n     * parameters are invalid or out of range for that tuner.\n     ",
    "links" : [ ]
  }, {
    "name" : "ONE_TOUCH_RECORD_INVALID_EXTERNAL_PLUG_NUMBER",
    "type" : "int",
    "comment" : " No recording – invalid External plug number ",
    "links" : [ ]
  }, {
    "name" : "ONE_TOUCH_RECORD_INVALID_EXTERNAL_PHYSICAL_ADDRESS",
    "type" : "int",
    "comment" : " No recording – invalid External Physical Address ",
    "links" : [ ]
  }, {
    "name" : "ONE_TOUCH_RECORD_UNSUPPORTED_CA",
    "type" : "int",
    "comment" : " No recording – CA system not supported ",
    "links" : [ ]
  }, {
    "name" : "ONE_TOUCH_RECORD_NO_OR_INSUFFICIENT_CA_ENTITLEMENTS",
    "type" : "int",
    "comment" : " No Recording – No or Insufficient CA Entitlements” ",
    "links" : [ ]
  }, {
    "name" : "ONE_TOUCH_RECORD_DISALLOW_TO_COPY",
    "type" : "int",
    "comment" : " No recording – Not allowed to copy source. Source is “copy never”. ",
    "links" : [ ]
  }, {
    "name" : "ONE_TOUCH_RECORD_DISALLOW_TO_FUTHER_COPIES",
    "type" : "int",
    "comment" : " No recording – No further copies allowed ",
    "links" : [ ]
  }, {
    "name" : "ONE_TOUCH_RECORD_NO_MEDIA",
    "type" : "int",
    "comment" : " No recording – No media ",
    "links" : [ ]
  }, {
    "name" : "ONE_TOUCH_RECORD_PLAYING",
    "type" : "int",
    "comment" : " No recording – playing ",
    "links" : [ ]
  }, {
    "name" : "ONE_TOUCH_RECORD_ALREADY_RECORDING",
    "type" : "int",
    "comment" : " No recording – already recording ",
    "links" : [ ]
  }, {
    "name" : "ONE_TOUCH_RECORD_MEDIA_PROTECTED",
    "type" : "int",
    "comment" : " No recording – media protected ",
    "links" : [ ]
  }, {
    "name" : "ONE_TOUCH_RECORD_NO_SOURCE_SIGNAL",
    "type" : "int",
    "comment" : " No recording – no source signal ",
    "links" : [ ]
  }, {
    "name" : "ONE_TOUCH_RECORD_MEDIA_PROBLEM",
    "type" : "int",
    "comment" : " No recording – media problem ",
    "links" : [ ]
  }, {
    "name" : "ONE_TOUCH_RECORD_NOT_ENOUGH_SPACE",
    "type" : "int",
    "comment" : " No recording – not enough space available ",
    "links" : [ ]
  }, {
    "name" : "ONE_TOUCH_RECORD_PARENT_LOCK_ON",
    "type" : "int",
    "comment" : " No recording – Parental Lock On ",
    "links" : [ ]
  }, {
    "name" : "ONE_TOUCH_RECORD_RECORDING_TERMINATED_NORMALLY",
    "type" : "int",
    "comment" : " Recording terminated normally ",
    "links" : [ ]
  }, {
    "name" : "ONE_TOUCH_RECORD_RECORDING_ALREADY_TERMINATED",
    "type" : "int",
    "comment" : " Recording has already terminated ",
    "links" : [ ]
  }, {
    "name" : "ONE_TOUCH_RECORD_OTHER_REASON",
    "type" : "int",
    "comment" : " No recording – other reason ",
    "links" : [ ]
  }, {
    "name" : "ONE_TOUCH_RECORD_PREVIOUS_RECORDING_IN_PROGRESS",
    "type" : "int",
    "comment" : " No recording. Previous recording request in progress. ",
    "links" : [ ]
  }, {
    "name" : "ONE_TOUCH_RECORD_CHECK_RECORDER_CONNECTION",
    "type" : "int",
    "comment" : " No recording. Please check recorder and connection. ",
    "links" : [ ]
  }, {
    "name" : "ONE_TOUCH_RECORD_FAIL_TO_RECORD_DISPLAYED_SCREEN",
    "type" : "int",
    "comment" : " Cannot record currently displayed source. ",
    "links" : [ ]
  }, {
    "name" : "ONE_TOUCH_RECORD_CEC_DISABLED",
    "type" : "int",
    "comment" : " CEC is disabled. ",
    "links" : [ ]
  }, {
    "name" : "TIMER_RECORDING_TYPE_DIGITAL",
    "type" : "int",
    "comment" : " Timer recording type for digital service source. ",
    "links" : [ ]
  }, {
    "name" : "TIMER_RECORDING_TYPE_ANALOGUE",
    "type" : "int",
    "comment" : " Timer recording type for analogue service source. ",
    "links" : [ ]
  }, {
    "name" : "TIMER_RECORDING_TYPE_EXTERNAL",
    "type" : "int",
    "comment" : " Timer recording type for external source. ",
    "links" : [ ]
  }, {
    "name" : "TIMER_STATUS_MEDIA_INFO_PRESENT_NOT_PROTECTED",
    "type" : "int",
    "comment" : " [Timer Status Data/Media Info] - Media present and not protected. ",
    "links" : [ ]
  }, {
    "name" : "TIMER_STATUS_MEDIA_INFO_PRESENT_PROTECTED",
    "type" : "int",
    "comment" : " [Timer Status Data/Media Info] - Media present, but protected. ",
    "links" : [ ]
  }, {
    "name" : "TIMER_STATUS_MEDIA_INFO_NOT_PRESENT",
    "type" : "int",
    "comment" : " [Timer Status Data/Media Info] - Media not present. ",
    "links" : [ ]
  }, {
    "name" : "TIMER_STATUS_PROGRAMMED_INFO_ENOUGH_SPACE",
    "type" : "int",
    "comment" : " [Timer Status Data/Programmed Info] - Enough space available for recording. ",
    "links" : [ ]
  }, {
    "name" : "TIMER_STATUS_PROGRAMMED_INFO_NOT_ENOUGH_SPACE",
    "type" : "int",
    "comment" : " [Timer Status Data/Programmed Info] - Not enough space available for recording. ",
    "links" : [ ]
  }, {
    "name" : "TIMER_STATUS_PROGRAMMED_INFO_MIGHT_NOT_ENOUGH_SPACE",
    "type" : "int",
    "comment" : " [Timer Status Data/Programmed Info] - Might not enough space available for recording. ",
    "links" : [ ]
  }, {
    "name" : "TIMER_STATUS_PROGRAMMED_INFO_NO_MEDIA_INFO",
    "type" : "int",
    "comment" : " [Timer Status Data/Programmed Info] - No media info available. ",
    "links" : [ ]
  }, {
    "name" : "TIMER_STATUS_NOT_PROGRAMMED_NO_FREE_TIME",
    "type" : "int",
    "comment" : " [Timer Status Data/Not Programmed Error Info] - No free timer available. ",
    "links" : [ ]
  }, {
    "name" : "TIMER_STATUS_NOT_PROGRAMMED_DATE_OUT_OF_RANGE",
    "type" : "int",
    "comment" : " [Timer Status Data/Not Programmed Error Info] - Date out of range. ",
    "links" : [ ]
  }, {
    "name" : "TIMER_STATUS_NOT_PROGRAMMED_INVALID_SEQUENCE",
    "type" : "int",
    "comment" : " [Timer Status Data/Not Programmed Error Info] - Recording Sequence error. ",
    "links" : [ ]
  }, {
    "name" : "TIMER_STATUS_NOT_PROGRAMMED_INVALID_EXTERNAL_PLUG_NUMBER",
    "type" : "int",
    "comment" : " [Timer Status Data/Not Programmed Error Info] - Invalid External Plug Number. ",
    "links" : [ ]
  }, {
    "name" : "TIMER_STATUS_NOT_PROGRAMMED_INVALID_EXTERNAL_PHYSICAL_NUMBER",
    "type" : "int",
    "comment" : " [Timer Status Data/Not Programmed Error Info] - Invalid External Physical Address. ",
    "links" : [ ]
  }, {
    "name" : "TIMER_STATUS_NOT_PROGRAMMED_CA_NOT_SUPPORTED",
    "type" : "int",
    "comment" : " [Timer Status Data/Not Programmed Error Info] - CA system not supported. ",
    "links" : [ ]
  }, {
    "name" : "TIMER_STATUS_NOT_PROGRAMMED_NO_CA_ENTITLEMENTS",
    "type" : "int",
    "comment" : " [Timer Status Data/Not Programmed Error Info] - No or insufficient CA Entitlements. ",
    "links" : [ ]
  }, {
    "name" : "TIMER_STATUS_NOT_PROGRAMMED_UNSUPPORTED_RESOLUTION",
    "type" : "int",
    "comment" : " [Timer Status Data/Not Programmed Error Info] - Does not support resolution. ",
    "links" : [ ]
  }, {
    "name" : "TIMER_STATUS_NOT_PROGRAMMED_PARENTAL_LOCK_ON",
    "type" : "int",
    "comment" : " [Timer Status Data/Not Programmed Error Info] - Parental Lock On. ",
    "links" : [ ]
  }, {
    "name" : "TIMER_STATUS_NOT_PROGRAMMED_CLOCK_FAILURE",
    "type" : "int",
    "comment" : " [Timer Status Data/Not Programmed Error Info] - Clock Failure. ",
    "links" : [ ]
  }, {
    "name" : "TIMER_STATUS_NOT_PROGRAMMED_DUPLICATED",
    "type" : "int",
    "comment" : " [Timer Status Data/Not Programmed Error Info] - Duplicate: already programmed. ",
    "links" : [ ]
  }, {
    "name" : "TIMER_RECORDING_RESULT_EXTRA_NO_ERROR",
    "type" : "int",
    "comment" : " No extra error. ",
    "links" : [ ]
  }, {
    "name" : "TIMER_RECORDING_RESULT_EXTRA_CHECK_RECORDER_CONNECTION",
    "type" : "int",
    "comment" : " No timer recording - check recorder and connection. ",
    "links" : [ ]
  }, {
    "name" : "TIMER_RECORDING_RESULT_EXTRA_FAIL_TO_RECORD_SELECTED_SOURCE",
    "type" : "int",
    "comment" : " No timer recording - cannot record selected source. ",
    "links" : [ ]
  }, {
    "name" : "TIMER_RECORDING_RESULT_EXTRA_CEC_DISABLED",
    "type" : "int",
    "comment" : " CEC is disabled. ",
    "links" : [ ]
  }, {
    "name" : "CLEAR_TIMER_STATUS_TIMER_NOT_CLEARED_RECORDING",
    "type" : "int",
    "comment" : " Timer not cleared – recording. ",
    "links" : [ ]
  }, {
    "name" : "CLEAR_TIMER_STATUS_TIMER_NOT_CLEARED_NO_MATCHING",
    "type" : "int",
    "comment" : " Timer not cleared – no matching. ",
    "links" : [ ]
  }, {
    "name" : "CLEAR_TIMER_STATUS_TIMER_NOT_CLEARED_NO_INFO_AVAILABLE",
    "type" : "int",
    "comment" : " Timer not cleared – no info available. ",
    "links" : [ ]
  }, {
    "name" : "CLEAR_TIMER_STATUS_TIMER_CLEARED",
    "type" : "int",
    "comment" : " Timer cleared. ",
    "links" : [ ]
  }, {
    "name" : "CLEAR_TIMER_STATUS_CHECK_RECORDER_CONNECTION",
    "type" : "int",
    "comment" : " Clear timer error - check recorder and connection. ",
    "links" : [ ]
  }, {
    "name" : "CLEAR_TIMER_STATUS_FAIL_TO_CLEAR_SELECTED_SOURCE",
    "type" : "int",
    "comment" : " Clear timer error - cannot clear timer for selected source. ",
    "links" : [ ]
  }, {
    "name" : "CLEAR_TIMER_STATUS_CEC_DISABLE",
    "type" : "int",
    "comment" : " Clear timer error - CEC is disabled. ",
    "links" : [ ]
  }, {
    "name" : "CONTROL_STATE_CHANGED_REASON_START",
    "type" : "int",
    "comment" : " The HdmiControlService is started. ",
    "links" : [ ]
  }, {
    "name" : "CONTROL_STATE_CHANGED_REASON_SETTING",
    "type" : "int",
    "comment" : " The state of HdmiControlService is changed by changing of settings. ",
    "links" : [ ]
  }, {
    "name" : "CONTROL_STATE_CHANGED_REASON_WAKEUP",
    "type" : "int",
    "comment" : " The HdmiControlService is enabled to wake up. ",
    "links" : [ ]
  }, {
    "name" : "CONTROL_STATE_CHANGED_REASON_STANDBY",
    "type" : "int",
    "comment" : " The HdmiControlService will be disabled to standby. ",
    "links" : [ ]
  }, {
    "name" : "mHasPlaybackDevice",
    "type" : "boolean",
    "comment" : " True if we have a logical device of type playback hosted in the system.",
    "links" : [ ]
  }, {
    "name" : "mHasTvDevice",
    "type" : "boolean",
    "comment" : " True if we have a logical device of type TV hosted in the system.",
    "links" : [ ]
  }, {
    "name" : "mHasAudioSystemDevice",
    "type" : "boolean",
    "comment" : " True if we have a logical device of type audio system hosted in the system.",
    "links" : [ ]
  }, {
    "name" : "mHasSwitchDevice",
    "type" : "boolean",
    "comment" : " True if we have a logical device of type audio system hosted in the system.",
    "links" : [ ]
  }, {
    "name" : "mIsSwitchDevice",
    "type" : "boolean",
    "comment" : " True if it's a switch device.",
    "links" : [ ]
  }, {
    "name" : "mHotplugEventListeners",
    "type" : "ArrayMap<HotplugEventListener, IHdmiHotplugEventListener>",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mHdmiControlStatusChangeListeners",
    "type" : "ArrayMap<HdmiControlStatusChangeListener, IHdmiControlStatusChangeListener>",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mHdmiCecVolumeControlFeatureListeners",
    "type" : "ArrayMap<HdmiCecVolumeControlFeatureListener, IHdmiCecVolumeControlFeatureListener>",
    "comment" : "",
    "links" : [ ]
  } ],
  "methods" : [ {
    "name" : "private void setLocalPhysicalAddress(int physicalAddress)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private int getLocalPhysicalAddress()",
    "returnType" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private static boolean hasDeviceType(int[] types, int type)",
    "returnType" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public HdmiClient getClient(int type)",
    "returnType" : "HdmiClient",
    "comment" : "\n     * Gets an object that represents an HDMI-CEC logical device of a specified type.\n     *\n     * @param type CEC device type\n     * @return {@link HdmiClient} instance. {@code null} on failure.\n     * See {@link HdmiDeviceInfo#DEVICE_PLAYBACK}\n     * See {@link HdmiDeviceInfo#DEVICE_TV}\n     * See {@link HdmiDeviceInfo#DEVICE_AUDIO_SYSTEM}\n     *\n     * @hide\n     ",
    "links" : [ "HdmiClient", "HdmiDeviceInfo#DEVICE_PLAYBACK", "HdmiDeviceInfo#DEVICE_TV", "HdmiDeviceInfo#DEVICE_AUDIO_SYSTEM" ]
  }, {
    "name" : "public HdmiPlaybackClient getPlaybackClient()",
    "returnType" : "HdmiPlaybackClient",
    "comment" : "\n     * Gets an object that represents an HDMI-CEC logical device of type playback on the system.\n     *\n     * <p>Used to send HDMI control messages to other devices like TV or audio amplifier through\n     * HDMI bus. It is also possible to communicate with other logical devices hosted in the same\n     * system if the system is configured to host more than one type of HDMI-CEC logical devices.\n     *\n     * @return {@link HdmiPlaybackClient} instance. {@code null} on failure.\n     *\n     * @hide\n     ",
    "links" : [ "HdmiPlaybackClient" ]
  }, {
    "name" : "public HdmiTvClient getTvClient()",
    "returnType" : "HdmiTvClient",
    "comment" : "\n     * Gets an object that represents an HDMI-CEC logical device of type TV on the system.\n     *\n     * <p>Used to send HDMI control messages to other devices and manage them through\n     * HDMI bus. It is also possible to communicate with other logical devices hosted in the same\n     * system if the system is configured to host more than one type of HDMI-CEC logical devices.\n     *\n     * @return {@link HdmiTvClient} instance. {@code null} on failure.\n     *\n     * @hide\n     ",
    "links" : [ "HdmiTvClient" ]
  }, {
    "name" : "public HdmiAudioSystemClient getAudioSystemClient()",
    "returnType" : "HdmiAudioSystemClient",
    "comment" : "\n     * Gets an object that represents an HDMI-CEC logical device of type audio system on the system.\n     *\n     * <p>Used to send HDMI control messages to other devices like TV through HDMI bus. It is also\n     * possible to communicate with other logical devices hosted in the same system if the system is\n     * configured to host more than one type of HDMI-CEC logical devices.\n     *\n     * @return {@link HdmiAudioSystemClient} instance. {@code null} on failure.\n     *\n     * TODO(b/110094868): unhide for Q\n     * @hide\n     ",
    "links" : [ "HdmiAudioSystemClient" ]
  }, {
    "name" : "public HdmiSwitchClient getSwitchClient()",
    "returnType" : "HdmiSwitchClient",
    "comment" : "\n     * Gets an object that represents an HDMI-CEC logical device of type switch on the system.\n     *\n     * <p>Used to send HDMI control messages to other devices (e.g. TVs) through HDMI bus.\n     * It is also possible to communicate with other logical devices hosted in the same\n     * system if the system is configured to host more than one type of HDMI-CEC logical device.\n     *\n     * @return {@link HdmiSwitchClient} instance. {@code null} on failure.\n     ",
    "links" : [ "HdmiSwitchClient" ]
  }, {
    "name" : "public List<HdmiDeviceInfo> getConnectedDevices()",
    "returnType" : "List<HdmiDeviceInfo>",
    "comment" : "\n     * Get a snapshot of the real-time status of the devices on the CEC bus.\n     *\n     * <p>This only applies to devices with switch functionality, which are devices with one\n     * or more than one HDMI inputs.\n     *\n     * @return a list of {@link HdmiDeviceInfo} of the connected CEC devices on the CEC bus. An\n     * empty list will be returned if there is none.\n     *\n     * @hide\n     ",
    "links" : [ "HdmiDeviceInfo" ]
  }, {
    "name" : "public List<HdmiDeviceInfo> getConnectedDevicesList()",
    "returnType" : "List<HdmiDeviceInfo>",
    "comment" : "\n     * @removed\n     * @hide\n     * @deprecated Please use {@link #getConnectedDevices()} instead.\n     ",
    "links" : [ "#getConnectedDevices" ]
  }, {
    "name" : "public void powerOffDevice(@NonNull HdmiDeviceInfo deviceInfo)",
    "returnType" : "void",
    "comment" : "\n     * Power off the target device by sending CEC commands. Note that this device can't be the\n     * current device itself.\n     *\n     * <p>The target device info can be obtained by calling {@link #getConnectedDevicesList()}.\n     *\n     * @param deviceInfo {@link HdmiDeviceInfo} of the device to be powered off.\n     *\n     * @hide\n     ",
    "links" : [ "#getConnectedDevicesList", "HdmiDeviceInfo" ]
  }, {
    "name" : "public void powerOffRemoteDevice(@NonNull HdmiDeviceInfo deviceInfo)",
    "returnType" : "void",
    "comment" : "\n     * @removed\n     * @hide\n     * @deprecated Please use {@link #powerOffDevice(deviceInfo)} instead.\n     ",
    "links" : [ "#powerOffDevice" ]
  }, {
    "name" : "public void powerOnDevice(HdmiDeviceInfo deviceInfo)",
    "returnType" : "void",
    "comment" : "\n     * Power on the target device by sending CEC commands. Note that this device can't be the\n     * current device itself.\n     *\n     * <p>The target device info can be obtained by calling {@link #getConnectedDevicesList()}.\n     *\n     * @param deviceInfo {@link HdmiDeviceInfo} of the device to be powered on.\n     *\n     * @hide\n     ",
    "links" : [ "#getConnectedDevicesList", "HdmiDeviceInfo" ]
  }, {
    "name" : "public void powerOnRemoteDevice(HdmiDeviceInfo deviceInfo)",
    "returnType" : "void",
    "comment" : "\n     * @removed\n     * @hide\n     * @deprecated Please use {@link #powerOnDevice(deviceInfo)} instead.\n     ",
    "links" : [ "#powerOnDevice" ]
  }, {
    "name" : "public void setActiveSource(@NonNull HdmiDeviceInfo deviceInfo)",
    "returnType" : "void",
    "comment" : "\n     * Request the target device to be the new Active Source by sending CEC commands. Note that\n     * this device can't be the current device itself.\n     *\n     * <p>The target device info can be obtained by calling {@link #getConnectedDevicesList()}.\n     *\n     * <p>If the target device responds to the command, the users should see the target device\n     * streaming on their TVs.\n     *\n     * @param deviceInfo HdmiDeviceInfo of the target device\n     *\n     * @hide\n     ",
    "links" : [ "#getConnectedDevicesList" ]
  }, {
    "name" : "public void requestRemoteDeviceToBecomeActiveSource(@NonNull HdmiDeviceInfo deviceInfo)",
    "returnType" : "void",
    "comment" : "\n     * @removed\n     * @hide\n     * @deprecated Please use {@link #setActiveSource(deviceInfo)} instead.\n     ",
    "links" : [ "#setActiveSource" ]
  }, {
    "name" : "public void setStandbyMode(boolean isStandbyModeOn)",
    "returnType" : "void",
    "comment" : "\n     * Controls standby mode of the system. It will also try to turn on/off the connected devices if\n     * necessary.\n     *\n     * @param isStandbyModeOn target status of the system's standby mode\n     ",
    "links" : [ ]
  }, {
    "name" : "public void setHdmiCecVolumeControlEnabled(boolean isHdmiCecVolumeControlEnabled)",
    "returnType" : "void",
    "comment" : "\n     * Controls whether volume control commands via HDMI CEC are enabled.\n     *\n     * <p>When disabled:\n     * <ul>\n     *     <li>the device will not send any HDMI CEC audio messages\n     *     <li>received HDMI CEC audio messages are responded to with {@code <Feature Abort>}\n     * </ul>\n     *\n     * <p>Effects on different device types:\n     * <table>\n     *     <tr><th>HDMI CEC device type</th><th>enabled</th><th>disabled</th></tr>\n     *     <tr>\n     *         <td>TV (type: 0)</td>\n     *         <td>Per CEC specification.</td>\n     *         <td>TV changes system volume. TV no longer reacts to incoming volume changes via\n     *         {@code <User Control Pressed>}. TV no longer handles {@code <Report Audio Status>}\n     *         .</td>\n     *     </tr>\n     *     <tr>\n     *         <td>Playback device (type: 4)</td>\n     *         <td>Device sends volume commands to TV/Audio system via {@code <User Control\n     *         Pressed>}</td><td>Device does not send volume commands via {@code <User Control\n     *         Pressed>}.</td>\n     *     </tr>\n     *     <tr>\n     *         <td>Audio device (type: 5)</td>\n     *         <td>Full \"System Audio Control\" capabilities.</td>\n     *         <td>Audio device no longer reacts to incoming {@code <User Control Pressed>}\n     *         volume commands. Audio device no longer reports volume changes via {@code <Report\n     *         Audio Status>}.</td>\n     *     </tr>\n     * </table>\n     *\n     * <p> Due to the resulting behavior, usage on TV and Audio devices is discouraged.\n     *\n     * @param isHdmiCecVolumeControlEnabled target state of HDMI CEC volume control.\n     * @see Settings.Global.HDMI_CONTROL_VOLUME_CONTROL_ENABLED\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean isHdmiCecVolumeControlEnabled()",
    "returnType" : "boolean",
    "comment" : "\n     * Returns whether volume changes via HDMI CEC are enabled.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean getSystemAudioMode()",
    "returnType" : "boolean",
    "comment" : "\n     * Gets whether the system is in system audio mode.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public int getPhysicalAddress()",
    "returnType" : "int",
    "comment" : "\n     * Get the physical address of the device.\n     *\n     * <p>Physical address needs to be automatically adjusted when devices are phyiscally or\n     * electrically added or removed from the device tree. Please see HDMI Specification Version\n     * 1.4b 8.7 Physical Address for more details on the address discovery proccess.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean isDeviceConnected(@NonNull HdmiDeviceInfo targetDevice)",
    "returnType" : "boolean",
    "comment" : "\n     * Check if the target device is connected to the current device.\n     *\n     * <p>The API also returns true if the current device is the target.\n     *\n     * @param targetDevice {@link HdmiDeviceInfo} of the target device.\n     * @return true if {@code targetDevice} is directly or indirectly\n     * connected to the current device.\n     *\n     * @hide\n     ",
    "links" : [ "HdmiDeviceInfo" ]
  }, {
    "name" : "public boolean isRemoteDeviceConnected(@NonNull HdmiDeviceInfo targetDevice)",
    "returnType" : "boolean",
    "comment" : "\n     * @removed\n     * @hide\n     * @deprecated Please use {@link #isDeviceConnected(targetDevice)} instead.\n     ",
    "links" : [ "#isDeviceConnected" ]
  }, {
    "name" : "public void addHotplugEventListener(HotplugEventListener listener)",
    "returnType" : "void",
    "comment" : "\n     * Adds a listener to get informed of {@link HdmiHotplugEvent}.\n     *\n     * <p>To stop getting the notification,\n     * use {@link #removeHotplugEventListener(HotplugEventListener)}.\n     *\n     * @param listener {@link HotplugEventListener} instance\n     * @see HdmiControlManager#removeHotplugEventListener(HotplugEventListener)\n     *\n     * @hide\n     ",
    "links" : [ "HdmiHotplugEvent", "#removeHotplugEventListener", "HotplugEventListener" ]
  }, {
    "name" : "public void removeHotplugEventListener(HotplugEventListener listener)",
    "returnType" : "void",
    "comment" : "\n     * Removes a listener to stop getting informed of {@link HdmiHotplugEvent}.\n     *\n     * @param listener {@link HotplugEventListener} instance to be removed\n     *\n     * @hide\n     ",
    "links" : [ "HdmiHotplugEvent", "HotplugEventListener" ]
  }, {
    "name" : "private IHdmiHotplugEventListener getHotplugEventListenerWrapper(final HotplugEventListener listener)",
    "returnType" : "IHdmiHotplugEventListener",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public void addHdmiControlStatusChangeListener(HdmiControlStatusChangeListener listener)",
    "returnType" : "void",
    "comment" : "\n     * Adds a listener to get informed of {@link HdmiControlStatusChange}.\n     *\n     * <p>To stop getting the notification,\n     * use {@link #removeHdmiControlStatusChangeListener(HdmiControlStatusChangeListener)}.\n     *\n     * @param listener {@link HdmiControlStatusChangeListener} instance\n     * @see HdmiControlManager#removeHdmiControlStatusChangeListener(\n     * HdmiControlStatusChangeListener)\n     *\n     * @hide\n     ",
    "links" : [ "HdmiControlStatusChange", "#removeHdmiControlStatusChangeListener", "HdmiControlStatusChangeListener" ]
  }, {
    "name" : "public void removeHdmiControlStatusChangeListener(HdmiControlStatusChangeListener listener)",
    "returnType" : "void",
    "comment" : "\n     * Removes a listener to stop getting informed of {@link HdmiControlStatusChange}.\n     *\n     * @param listener {@link HdmiControlStatusChangeListener} instance to be removed\n     *\n     * @hide\n     ",
    "links" : [ "HdmiControlStatusChange", "HdmiControlStatusChangeListener" ]
  }, {
    "name" : "private IHdmiControlStatusChangeListener getHdmiControlStatusChangeListenerWrapper(final HdmiControlStatusChangeListener listener)",
    "returnType" : "IHdmiControlStatusChangeListener",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public void addHdmiCecVolumeControlFeatureListener(@NonNull @CallbackExecutor Executor executor, @NonNull HdmiCecVolumeControlFeatureListener listener)",
    "returnType" : "void",
    "comment" : "\n     * Adds a listener to get informed of changes to the state of the HDMI CEC volume control\n     * feature.\n     *\n     * Upon adding a listener, the current state of the HDMI CEC volume control feature will be\n     * sent immediately.\n     *\n     * <p>To stop getting the notification,\n     * use {@link #removeHdmiCecVolumeControlFeatureListener(HdmiCecVolumeControlFeatureListener)}.\n     *\n     * @param listener {@link HdmiCecVolumeControlFeatureListener} instance\n     * @hide\n     * @see #removeHdmiCecVolumeControlFeatureListener(HdmiCecVolumeControlFeatureListener)\n     ",
    "links" : [ "#removeHdmiCecVolumeControlFeatureListener", "HdmiCecVolumeControlFeatureListener" ]
  }, {
    "name" : "public void removeHdmiCecVolumeControlFeatureListener(HdmiCecVolumeControlFeatureListener listener)",
    "returnType" : "void",
    "comment" : "\n     * Removes a listener to stop getting informed of changes to the state of the HDMI CEC volume\n     * control feature.\n     *\n     * @param listener {@link HdmiCecVolumeControlFeatureListener} instance to be removed\n     * @hide\n     ",
    "links" : [ "HdmiCecVolumeControlFeatureListener" ]
  }, {
    "name" : "private IHdmiCecVolumeControlFeatureListener createHdmiCecVolumeControlFeatureListenerWrapper(Executor executor, final HdmiCecVolumeControlFeatureListener listener)",
    "returnType" : "IHdmiCecVolumeControlFeatureListener",
    "comment" : "",
    "links" : [ ]
  } ],
  "variableNames" : [ "TAG", "mService", "INVALID_PHYSICAL_ADDRESS", "mLocalPhysicalAddress", "mLock", "ACTION_OSD_MESSAGE", "OSD_MESSAGE_ARC_CONNECTED_INVALID_PORT", "OSD_MESSAGE_AVR_VOLUME_CHANGED", "EXTRA_MESSAGE_ID", "EXTRA_MESSAGE_EXTRA_PARAM1", "AVR_VOLUME_MUTED", "POWER_STATUS_UNKNOWN", "POWER_STATUS_ON", "POWER_STATUS_STANDBY", "POWER_STATUS_TRANSIENT_TO_ON", "POWER_STATUS_TRANSIENT_TO_STANDBY", "RESULT_SUCCESS", "RESULT_TIMEOUT", "RESULT_SOURCE_NOT_AVAILABLE", "RESULT_TARGET_NOT_AVAILABLE", "RESULT_ALREADY_IN_PROGRESS", "RESULT_EXCEPTION", "RESULT_INCORRECT_MODE", "RESULT_COMMUNICATION_FAILED", "DEVICE_EVENT_ADD_DEVICE", "DEVICE_EVENT_REMOVE_DEVICE", "DEVICE_EVENT_UPDATE_DEVICE", "ONE_TOUCH_RECORD_RECORDING_CURRENTLY_SELECTED_SOURCE", "ONE_TOUCH_RECORD_RECORDING_DIGITAL_SERVICE", "ONE_TOUCH_RECORD_RECORDING_ANALOGUE_SERVICE", "ONE_TOUCH_RECORD_RECORDING_EXTERNAL_INPUT", "ONE_TOUCH_RECORD_UNABLE_DIGITAL_SERVICE", "ONE_TOUCH_RECORD_UNABLE_ANALOGUE_SERVICE", "ONE_TOUCH_RECORD_UNABLE_SELECTED_SERVICE", "ONE_TOUCH_RECORD_INVALID_EXTERNAL_PLUG_NUMBER", "ONE_TOUCH_RECORD_INVALID_EXTERNAL_PHYSICAL_ADDRESS", "ONE_TOUCH_RECORD_UNSUPPORTED_CA", "ONE_TOUCH_RECORD_NO_OR_INSUFFICIENT_CA_ENTITLEMENTS", "ONE_TOUCH_RECORD_DISALLOW_TO_COPY", "ONE_TOUCH_RECORD_DISALLOW_TO_FUTHER_COPIES", "ONE_TOUCH_RECORD_NO_MEDIA", "ONE_TOUCH_RECORD_PLAYING", "ONE_TOUCH_RECORD_ALREADY_RECORDING", "ONE_TOUCH_RECORD_MEDIA_PROTECTED", "ONE_TOUCH_RECORD_NO_SOURCE_SIGNAL", "ONE_TOUCH_RECORD_MEDIA_PROBLEM", "ONE_TOUCH_RECORD_NOT_ENOUGH_SPACE", "ONE_TOUCH_RECORD_PARENT_LOCK_ON", "ONE_TOUCH_RECORD_RECORDING_TERMINATED_NORMALLY", "ONE_TOUCH_RECORD_RECORDING_ALREADY_TERMINATED", "ONE_TOUCH_RECORD_OTHER_REASON", "ONE_TOUCH_RECORD_PREVIOUS_RECORDING_IN_PROGRESS", "ONE_TOUCH_RECORD_CHECK_RECORDER_CONNECTION", "ONE_TOUCH_RECORD_FAIL_TO_RECORD_DISPLAYED_SCREEN", "ONE_TOUCH_RECORD_CEC_DISABLED", "TIMER_RECORDING_TYPE_DIGITAL", "TIMER_RECORDING_TYPE_ANALOGUE", "TIMER_RECORDING_TYPE_EXTERNAL", "TIMER_STATUS_MEDIA_INFO_PRESENT_NOT_PROTECTED", "TIMER_STATUS_MEDIA_INFO_PRESENT_PROTECTED", "TIMER_STATUS_MEDIA_INFO_NOT_PRESENT", "TIMER_STATUS_PROGRAMMED_INFO_ENOUGH_SPACE", "TIMER_STATUS_PROGRAMMED_INFO_NOT_ENOUGH_SPACE", "TIMER_STATUS_PROGRAMMED_INFO_MIGHT_NOT_ENOUGH_SPACE", "TIMER_STATUS_PROGRAMMED_INFO_NO_MEDIA_INFO", "TIMER_STATUS_NOT_PROGRAMMED_NO_FREE_TIME", "TIMER_STATUS_NOT_PROGRAMMED_DATE_OUT_OF_RANGE", "TIMER_STATUS_NOT_PROGRAMMED_INVALID_SEQUENCE", "TIMER_STATUS_NOT_PROGRAMMED_INVALID_EXTERNAL_PLUG_NUMBER", "TIMER_STATUS_NOT_PROGRAMMED_INVALID_EXTERNAL_PHYSICAL_NUMBER", "TIMER_STATUS_NOT_PROGRAMMED_CA_NOT_SUPPORTED", "TIMER_STATUS_NOT_PROGRAMMED_NO_CA_ENTITLEMENTS", "TIMER_STATUS_NOT_PROGRAMMED_UNSUPPORTED_RESOLUTION", "TIMER_STATUS_NOT_PROGRAMMED_PARENTAL_LOCK_ON", "TIMER_STATUS_NOT_PROGRAMMED_CLOCK_FAILURE", "TIMER_STATUS_NOT_PROGRAMMED_DUPLICATED", "TIMER_RECORDING_RESULT_EXTRA_NO_ERROR", "TIMER_RECORDING_RESULT_EXTRA_CHECK_RECORDER_CONNECTION", "TIMER_RECORDING_RESULT_EXTRA_FAIL_TO_RECORD_SELECTED_SOURCE", "TIMER_RECORDING_RESULT_EXTRA_CEC_DISABLED", "CLEAR_TIMER_STATUS_TIMER_NOT_CLEARED_RECORDING", "CLEAR_TIMER_STATUS_TIMER_NOT_CLEARED_NO_MATCHING", "CLEAR_TIMER_STATUS_TIMER_NOT_CLEARED_NO_INFO_AVAILABLE", "CLEAR_TIMER_STATUS_TIMER_CLEARED", "CLEAR_TIMER_STATUS_CHECK_RECORDER_CONNECTION", "CLEAR_TIMER_STATUS_FAIL_TO_CLEAR_SELECTED_SOURCE", "CLEAR_TIMER_STATUS_CEC_DISABLE", "CONTROL_STATE_CHANGED_REASON_START", "CONTROL_STATE_CHANGED_REASON_SETTING", "CONTROL_STATE_CHANGED_REASON_WAKEUP", "CONTROL_STATE_CHANGED_REASON_STANDBY", "mHasPlaybackDevice", "mHasTvDevice", "mHasAudioSystemDevice", "mHasSwitchDevice", "mIsSwitchDevice", "mHotplugEventListeners", "mHdmiControlStatusChangeListeners", "mHdmiCecVolumeControlFeatureListeners" ],
  "methodNames" : [ "private void setLocalPhysicalAddress(int physicalAddress)", "private int getLocalPhysicalAddress()", "private static boolean hasDeviceType(int[] types, int type)", "public HdmiClient getClient(int type)", "public HdmiPlaybackClient getPlaybackClient()", "public HdmiTvClient getTvClient()", "public HdmiAudioSystemClient getAudioSystemClient()", "public HdmiSwitchClient getSwitchClient()", "public List<HdmiDeviceInfo> getConnectedDevices()", "public List<HdmiDeviceInfo> getConnectedDevicesList()", "public void powerOffDevice(@NonNull HdmiDeviceInfo deviceInfo)", "public void powerOffRemoteDevice(@NonNull HdmiDeviceInfo deviceInfo)", "public void powerOnDevice(HdmiDeviceInfo deviceInfo)", "public void powerOnRemoteDevice(HdmiDeviceInfo deviceInfo)", "public void setActiveSource(@NonNull HdmiDeviceInfo deviceInfo)", "public void requestRemoteDeviceToBecomeActiveSource(@NonNull HdmiDeviceInfo deviceInfo)", "public void setStandbyMode(boolean isStandbyModeOn)", "public void setHdmiCecVolumeControlEnabled(boolean isHdmiCecVolumeControlEnabled)", "public boolean isHdmiCecVolumeControlEnabled()", "public boolean getSystemAudioMode()", "public int getPhysicalAddress()", "public boolean isDeviceConnected(@NonNull HdmiDeviceInfo targetDevice)", "public boolean isRemoteDeviceConnected(@NonNull HdmiDeviceInfo targetDevice)", "public void addHotplugEventListener(HotplugEventListener listener)", "public void removeHotplugEventListener(HotplugEventListener listener)", "private IHdmiHotplugEventListener getHotplugEventListenerWrapper(final HotplugEventListener listener)", "public void addHdmiControlStatusChangeListener(HdmiControlStatusChangeListener listener)", "public void removeHdmiControlStatusChangeListener(HdmiControlStatusChangeListener listener)", "private IHdmiControlStatusChangeListener getHdmiControlStatusChangeListenerWrapper(final HdmiControlStatusChangeListener listener)", "public void addHdmiCecVolumeControlFeatureListener(@NonNull @CallbackExecutor Executor executor, @NonNull HdmiCecVolumeControlFeatureListener listener)", "public void removeHdmiCecVolumeControlFeatureListener(HdmiCecVolumeControlFeatureListener listener)", "private IHdmiCecVolumeControlFeatureListener createHdmiCecVolumeControlFeatureListenerWrapper(Executor executor, final HdmiCecVolumeControlFeatureListener listener)" ]
}