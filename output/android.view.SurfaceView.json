{
  "filePath" : "/home/maryam/clearblue/files/android-source-35/android/view/SurfaceView.java",
  "packageName" : "android.view",
  "className" : "SurfaceView",
  "comment" : "\n * Provides a dedicated drawing surface embedded inside of a view hierarchy.\n * You can control the format of this surface and, if you like, its size; the\n * SurfaceView takes care of placing the surface at the correct location on the\n * screen\n *\n * <p>The surface is Z ordered so that it is behind the window holding its\n * SurfaceView; the SurfaceView punches a hole in its window to allow its\n * surface to be displayed. The view hierarchy will take care of correctly\n * compositing with the Surface any siblings of the SurfaceView that would\n * normally appear on top of it. This can be used to place overlays such as\n * buttons on top of the Surface, though note however that it can have an\n * impact on performance since a full alpha-blended composite will be performed\n * each time the Surface changes.\n *\n * <p> The transparent region that makes the surface visible is based on the\n * layout positions in the view hierarchy. If the post-layout transform\n * properties are used to draw a sibling view on top of the SurfaceView, the\n * view may not be properly composited with the surface.\n *\n * <p>Access to the underlying surface is provided via the SurfaceHolder interface,\n * which can be retrieved by calling {@link #getHolder}.\n *\n * <p>The Surface will be created for you while the SurfaceView's window is\n * visible; you should implement {@link SurfaceHolder.Callback#surfaceCreated}\n * and {@link SurfaceHolder.Callback#surfaceDestroyed} to discover when the\n * Surface is created and destroyed as the window is shown and hidden.\n *\n * <p>One of the purposes of this class is to provide a surface in which a\n * secondary thread can render into the screen. If you are going to use it\n * this way, you need to be aware of some threading semantics:\n *\n * <ul>\n * <li> All SurfaceView and\n * {@link SurfaceHolder.Callback SurfaceHolder.Callback} methods will be called\n * from the thread running the SurfaceView's window (typically the main thread\n * of the application). They thus need to correctly synchronize with any\n * state that is also touched by the drawing thread.\n * <li> You must ensure that the drawing thread only touches the underlying\n * Surface while it is valid -- between\n * {@link SurfaceHolder.Callback#surfaceCreated SurfaceHolder.Callback.surfaceCreated()}\n * and\n * {@link SurfaceHolder.Callback#surfaceDestroyed SurfaceHolder.Callback.surfaceDestroyed()}.\n * </ul>\n *\n * <p class=\"note\"><strong>Note:</strong> Starting in platform version\n * {@link android.os.Build.VERSION_CODES#N}, SurfaceView's window position is\n * updated synchronously with other View rendering. This means that translating\n * and scaling a SurfaceView on screen will not cause rendering artifacts. Such\n * artifacts may occur on previous versions of the platform when its window is\n * positioned asynchronously.</p>\n *\n * <p class=\"note\"><strong>Note:</strong> Starting in platform version\n * {@link android.os.Build.VERSION_CODES#UPSIDE_DOWN_CAKE}, SurfaceView will support arbitrary\n * alpha blending. Prior platform versions ignored alpha values on the SurfaceView if they were\n * between 0 and 1. If the SurfaceView is configured with Z-above, then the alpha is applied\n * directly to the Surface. If the SurfaceView is configured with Z-below, then the alpha is\n * applied to the hole punch directly. Note that when using Z-below, overlapping SurfaceViews\n * may not blend properly as a consequence of not applying alpha to the surface content directly.\n ",
  "links" : [ "SurfaceHolder.Callback", "android.os.Build.VERSION_CODES#UPSIDE_DOWN_CAKE", "#getHolder", "SurfaceHolder.Callback#surfaceCreated", "android.os.Build.VERSION_CODES#N", "SurfaceHolder.Callback#surfaceDestroyed" ],
  "variables" : [ {
    "name" : "SURFACE_LIFECYCLE_DEFAULT",
    "type" : "int",
    "comment" : "\n     * Default lifecycle of the Surface owned by this SurfaceView.\n     *\n     * The default lifecycle matches {@link #SURFACE_LIFECYCLE_FOLLOWS_VISIBILITY}.\n     ",
    "links" : [ "#SURFACE_LIFECYCLE_FOLLOWS_VISIBILITY" ]
  }, {
    "name" : "SURFACE_LIFECYCLE_FOLLOWS_VISIBILITY",
    "type" : "int",
    "comment" : "\n     * The Surface lifecycle is tied to SurfaceView visibility.\n     *\n     * The Surface is created when the SurfaceView becomes visible, and is destroyed when the\n     * SurfaceView is no longer visible.\n     ",
    "links" : [ ]
  }, {
    "name" : "SURFACE_LIFECYCLE_FOLLOWS_ATTACHMENT",
    "type" : "int",
    "comment" : "\n     * The Surface lifecycle is tied to SurfaceView attachment.\n     * The Surface is created when the SurfaceView first becomes attached, but is not destroyed\n     * until this SurfaceView has been detached from the current window.\n     ",
    "links" : [ ]
  }, {
    "name" : "TAG",
    "type" : "String",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "DEBUG",
    "type" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "DEBUG_POSITION",
    "type" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "FORWARD_BACK_KEY_TOLERANCE_MS",
    "type" : "long",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mCallbacks",
    "type" : "ArrayList<SurfaceHolder.Callback>",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mLocation",
    "type" : "int[]",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mSurfaceLock",
    "type" : "ReentrantLock",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mSurface",
    "type" : "Surface",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mDrawingStopped",
    "type" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mDrawFinished",
    "type" : "boolean",
    "comment" : " holes.",
    "links" : [ ]
  }, {
    "name" : "mScreenRect",
    "type" : "Rect",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mSurfaceSession",
    "type" : "SurfaceSession",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mLimitedHdrEnabled",
    "type" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mSurfaceControl",
    "type" : "SurfaceControl",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mBackgroundControl",
    "type" : "SurfaceControl",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mDisableBackgroundLayer",
    "type" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mRequestedSurfaceLifecycleStrategy",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mSurfaceLifecycleStrategy",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mRequestedHdrHeadroom",
    "type" : "float",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mHdrHeadroom",
    "type" : "float",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mSurfaceControlLock",
    "type" : "Object",
    "comment" : "\n     * We use this lock to protect access to mSurfaceControl. Both are accessed on the UI\n     * thread and the render thread via RenderNode.PositionUpdateListener#positionLost.\n     ",
    "links" : [ ]
  }, {
    "name" : "mTmpRect",
    "type" : "Rect",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mRoundedViewportPaint",
    "type" : "Paint",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mSubLayer",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mRequestedSubLayer",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mIsCreating",
    "type" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mScrollChangedListener",
    "type" : "ViewTreeObserver.OnScrollChangedListener",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mDrawListener",
    "type" : "ViewTreeObserver.OnPreDrawListener",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mRequestedVisible",
    "type" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mWindowVisibility",
    "type" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mLastWindowVisibility",
    "type" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mViewVisibility",
    "type" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mWindowStopped",
    "type" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mRequestedWidth",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mRequestedHeight",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mRequestedFormat",
    "type" : "int",
    "comment" : " Set SurfaceView's format to 565 by default to maintain backward\n     * compatibility with applications assuming this format.\n     ",
    "links" : [ ]
  }, {
    "name" : "mAlpha",
    "type" : "float",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mClipSurfaceToBounds",
    "type" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mBackgroundColor",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mHaveFrame",
    "type" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mSurfaceCreated",
    "type" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mLastLockTime",
    "type" : "long",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mVisible",
    "type" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mWindowSpaceLeft",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mWindowSpaceTop",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mSurfaceWidth",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mSurfaceHeight",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mCornerRadius",
    "type" : "float",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mFormat",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mSurfaceFrame",
    "type" : "Rect",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mLastSurfaceWidth",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mLastSurfaceHeight",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mTransformHint",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mGlobalListenersAdded",
    "type" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mAttachedToWindow",
    "type" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mSurfaceFlags",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mSyncGroups",
    "type" : "ArraySet<SurfaceSyncGroup>",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mRtTransaction",
    "type" : "SurfaceControl.Transaction",
    "comment" : "\n     * Transaction that should be used from the render thread. This transaction is only thread safe\n     * with other calls directly from the render thread.\n     ",
    "links" : [ ]
  }, {
    "name" : "mFrameCallbackTransaction",
    "type" : "SurfaceControl.Transaction",
    "comment" : "\n     * Transaction that should be used whe\n     * {@link HardwareRenderer.FrameDrawingCallback#onFrameDraw} is invoked. All\n     * frame callbacks can use the same transaction since they will be thread safe\n     ",
    "links" : [ "HardwareRenderer.FrameDrawingCallback#onFrameDraw" ]
  }, {
    "name" : "mParentSurfaceSequenceId",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mRemoteAccessibilityController",
    "type" : "RemoteAccessibilityController",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mTmpMatrix",
    "type" : "Matrix",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mSurfacePackage",
    "type" : "SurfaceControlViewHost.SurfacePackage",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mBlastSurfaceControl",
    "type" : "SurfaceControl",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mBlastBufferQueue",
    "type" : "BLASTBufferQueue",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mEmbeddedWindowParams",
    "type" : "ConcurrentLinkedQueue<WindowManager.LayoutParams>",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mSurfaceControlViewHostParent",
    "type" : "ISurfaceControlViewHostParent",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mRtDrivenClipping",
    "type" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mRTLastReportedPosition",
    "type" : "Rect",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mRTLastSetCrop",
    "type" : "Rect",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mPositionListener",
    "type" : "SurfaceViewPositionUpdateListener",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mSurfaceHolder",
    "type" : "SurfaceHolder",
    "comment" : "",
    "links" : [ ]
  } ],
  "methods" : [ {
    "name" : "public SurfaceHolder getHolder()",
    "returnType" : "SurfaceHolder",
    "comment" : "\n     * Return the SurfaceHolder providing access and control over this\n     * SurfaceView's underlying surface.\n     *\n     * @return SurfaceHolder The holder of the surface.\n     ",
    "links" : [ ]
  }, {
    "name" : "private void updateRequestedVisibility()",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private void setWindowStopped(boolean stopped)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "protected void onAttachedToWindow()",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "protected void onWindowVisibilityChanged(int visibility)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public void setVisibility(int visibility)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public void setUseAlpha()",
    "returnType" : "void",
    "comment" : "\n     * Make alpha value of this view reflect onto the surface. This can only be called from at most\n     * one SurfaceView within a view tree.\n     *\n     * <p class=\"note\"><strong>Note:</strong> Alpha value of the view is ignored and the underlying\n     * surface is rendered opaque by default.</p>\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public void setAlpha(float alpha)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "protected boolean onSetAlpha(int alpha)",
    "returnType" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private void performDrawFinished()",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "protected void onDetachedFromWindow()",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "protected boolean setFrame(int left, int top, int right, int bottom)",
    "returnType" : "boolean",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "public boolean gatherTransparentRegion(Region region)",
    "returnType" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public void draw(Canvas canvas)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "protected void dispatchDraw(Canvas canvas)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public void setEnableSurfaceClipping(boolean enabled)",
    "returnType" : "void",
    "comment" : "\n     * Control whether the surface is clipped to the same bounds as the View. If true, then\n     * the bounds set by {@link #setClipBounds(Rect)} are applied to the surface as window-crop.\n     *\n     * @param enabled whether to enable surface clipping\n     * @hide\n     ",
    "links" : [ "#setClipBounds(Rect)" ]
  }, {
    "name" : "public void setClipBounds(Rect clipBounds)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public boolean hasOverlappingRendering()",
    "returnType" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private void clearSurfaceViewPort(Canvas canvas)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public void setCornerRadius(float cornerRadius)",
    "returnType" : "void",
    "comment" : "\n     * Sets the corner radius for the SurfaceView. This will round both the corners of the\n     * underlying surface, as well as the corners of the hole created to expose the surface.\n     *\n     * @param cornerRadius the new radius of the corners in pixels\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public float getCornerRadius()",
    "returnType" : "float",
    "comment" : "\n     * Returns the corner radius for the SurfaceView.\n\n     * @return the radius of the corners in pixels\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public void setZOrderMediaOverlay(boolean isMediaOverlay)",
    "returnType" : "void",
    "comment" : "\n     * Control whether the surface view's surface is placed on top of another\n     * regular surface view in the window (but still behind the window itself).\n     * This is typically used to place overlays on top of an underlying media\n     * surface view.\n     *\n     * <p>Note that this must be set before the surface view's containing\n     * window is attached to the window manager.\n     *\n     * <p>Calling this overrides any previous call to {@link #setZOrderOnTop}.\n     ",
    "links" : [ "#setZOrderOnTop" ]
  }, {
    "name" : "public void setZOrderOnTop(boolean onTop)",
    "returnType" : "void",
    "comment" : "\n     * Control whether the surface view's surface is placed on top of its\n     * window.  Normally it is placed behind the window, to allow it to\n     * (for the most part) appear to composite with the views in the\n     * hierarchy.  By setting this, you cause it to be placed above the\n     * window.  This means that none of the contents of the window this\n     * SurfaceView is in will be visible on top of its surface.\n     *\n     * <p>Note that this must be set before the surface view's containing\n     * window is attached to the window manager. If you target {@link Build.VERSION_CODES#R}\n     * the Z ordering can be changed dynamically if the backing surface is\n     * created, otherwise it would be applied at surface construction time.\n     *\n     * <p>Calling this overrides any previous call to {@link #setZOrderMediaOverlay}.\n     *\n     * @param onTop Whether to show the surface on top of this view's window.\n     ",
    "links" : [ "#setZOrderMediaOverlay", "Build.VERSION_CODES#R" ]
  }, {
    "name" : "public boolean isZOrderedOnTop()",
    "returnType" : "boolean",
    "comment" : "\n     * @return Whether the surface backing this view appears on top of its parent.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean setZOrderedOnTop(boolean onTop, boolean allowDynamicChange)",
    "returnType" : "boolean",
    "comment" : "\n     * Controls whether the surface view's surface is placed on top of its\n     * window. Normally it is placed behind the window, to allow it to\n     * (for the most part) appear to composite with the views in the\n     * hierarchy. By setting this, you cause it to be placed above the\n     * window. This means that none of the contents of the window this\n     * SurfaceView is in will be visible on top of its surface.\n     *\n     * <p>Calling this overrides any previous call to {@link #setZOrderMediaOverlay}.\n     *\n     * @param onTop Whether to show the surface on top of this view's window.\n     * @param allowDynamicChange Whether this can happen after the surface is created.\n     * @return Whether the Z ordering changed.\n     *\n     * @hide\n     ",
    "links" : [ "#setZOrderMediaOverlay" ]
  }, {
    "name" : "public void setSecure(boolean isSecure)",
    "returnType" : "void",
    "comment" : "\n     * Control whether the surface view's content should be treated as secure,\n     * preventing it from appearing in screenshots or from being viewed on\n     * non-secure displays.\n     *\n     * <p>Note that this must be set before the surface view's containing\n     * window is attached to the window manager.\n     *\n     * <p>See {@link android.view.Display#FLAG_SECURE} for details.\n     *\n     * @param isSecure True if the surface view is secure.\n     ",
    "links" : [ "android.view.Display#FLAG_SECURE" ]
  }, {
    "name" : "public void setSurfaceLifecycle(@SurfaceLifecycleStrategy int lifecycleStrategy)",
    "returnType" : "void",
    "comment" : "\n     * Controls the lifecycle of the Surface owned by this SurfaceView.\n     *\n     * <p>By default, the lifecycycle strategy employed by the SurfaceView is\n     * {@link #SURFACE_LIFECYCLE_DEFAULT}.\n     *\n     * @param lifecycleStrategy The strategy for the lifecycle of the Surface owned by this\n     * SurfaceView.\n     ",
    "links" : [ "#SURFACE_LIFECYCLE_DEFAULT" ]
  }, {
    "name" : "public void setDesiredHdrHeadroom(@FloatRange(from = 0.0f, to = 10000.0) float desiredHeadroom)",
    "returnType" : "void",
    "comment" : "\n     * Sets the desired amount of HDR headroom to be used when HDR content is presented on this\n     * SurfaceView.\n     *\n     * <p>By default the system will choose an amount of HDR headroom that is appropriate\n     * for the underlying device capabilities & bit-depth of the panel. However, for some types\n     * of content this can end up being more headroom than necessary or desired. An example\n     * would be a messaging app or gallery thumbnail view where some amount of HDR pop is desired\n     * without overly influencing the perceived brightness of the majority SDR content. This can\n     * also be used to animate in/out of an HDR range for smoother transitions.</p>\n     *\n     * <p>Note: The actual amount of HDR headroom that will be given is subject to a variety\n     * of factors such as ambient conditions, display capabilities, or bit-depth limitations.\n     * See {@link Display#getHdrSdrRatio()} for more information as well as how to query the\n     * current value.</p>\n     *\n     * @param desiredHeadroom The amount of HDR headroom that is desired. Must be >= 1.0 (no HDR)\n     *                        and <= 10,000.0. Passing 0.0 will reset to the default, automatically\n     *                        chosen value.\n     * @see Display#getHdrSdrRatio()\n     ",
    "links" : [ "android.view.Display#getHdrSdrRatio()" ]
  }, {
    "name" : "private void updateOpaqueFlag()",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private void updateBackgroundVisibility(Transaction t)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private Transaction updateBackgroundColor(Transaction t)",
    "returnType" : "Transaction",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private void releaseSurfaces(boolean releaseSurfacePackage)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private void replacePositionUpdateListener(int surfaceWidth, int surfaceHeight)",
    "returnType" : "void",
    "comment" : " guarantee any changes we post will be applied.",
    "links" : [ ]
  }, {
    "name" : "private boolean performSurfaceTransaction(ViewRootImpl viewRoot, Translator translator, boolean creating, boolean sizeChanged, boolean hintChanged, boolean relativeZChanged, boolean hdrHeadroomChanged, Transaction surfaceUpdateTransaction)",
    "returnType" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private boolean requiresSurfaceControlCreation(boolean formatChanged, boolean visibleChanged)",
    "returnType" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private boolean surfaceShouldExist()",
    "returnType" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "protected void updateSurface()",
    "returnType" : "void",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "public String getName()",
    "returnType" : "String",
    "comment" : "\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "private void handleSyncBufferCallback(SurfaceHolder.Callback[] callbacks, SyncBufferTransactionCallback syncBufferTransactionCallback)",
    "returnType" : "void",
    "comment" : "\n     * If SV is trying to be part of the VRI sync, we need to add SV to the VRI sync before\n     * invoking the redrawNeeded call to the owner. This is to ensure we can set up the SV in\n     * the sync before the SV owner knows it needs to draw a new frame.\n     * Once the redrawNeeded callback is invoked, we can stop the continuous sync transaction\n     * call which will invoke the syncTransaction callback that contains the buffer. The\n     * code waits until we can retrieve the transaction that contains the buffer before\n     * notifying the syncer that the buffer is ready.\n     ",
    "links" : [ ]
  }, {
    "name" : "private void handleSyncNoBuffer(SurfaceHolder.Callback[] callbacks)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private void redrawNeededAsync(SurfaceHolder.Callback[] callbacks, Runnable callbacksCollected)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public void vriDrawStarted(boolean isWmSync)",
    "returnType" : "void",
    "comment" : "\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "private void copySurface(boolean surfaceControlCreated, boolean bufferSizeChanged)",
    "returnType" : "void",
    "comment" : "\n     * Copy the Surface from the SurfaceControl or the blast adapter.\n     *\n     * @param surfaceControlCreated true if we created the SurfaceControl and need to update our\n     *                              Surface if needed.\n     * @param bufferSizeChanged true if the BufferSize has changed and we need to recreate the\n     *                          Surface for compatibility reasons.\n     ",
    "links" : [ ]
  }, {
    "name" : "private void setBufferSize(Transaction transaction)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private void createBlastSurfaceControls(ViewRootImpl viewRoot, String name, Transaction surfaceUpdateTransaction)",
    "returnType" : "void",
    "comment" : "\n     * Creates the surface control hierarchy as follows\n     *   ViewRootImpl surface\n     *     bounds layer (crops all child surfaces to parent surface insets)\n     *       * SurfaceView surface (drawn relative to ViewRootImpl surface)\n     *           * Blast surface (if enabled)\n     *       * Background color layer (drawn behind all SurfaceView surfaces)\n     *\n     *  The bounds layer is used to crop the surface view so it does not draw into the parent\n     *  surface inset region. Since there can be multiple surface views below or above the parent\n     *  surface, one option is to create multiple bounds layer for each z order. The other option,\n     *  the one implement is to create a single bounds layer and set z order for each child surface\n     *  relative to the parent surface.\n     *  When creating the surface view, we parent it to the bounds layer and then set the relative z\n     *  order. When the parent surface changes, we have to make sure to update the relative z via\n     *  ViewRootImpl.SurfaceChangedCallback.\n     *\n     *  We don't recreate the surface controls but only recreate the adapter. Since the blast layer\n     *  is still alive, the old buffers will continue to be presented until replaced by buffers from\n     *  the new adapter. This means we do not need to track the old surface control and destroy it\n     *  after the client has drawn to avoid any flickers.\n     *\n     ",
    "links" : [ ]
  }, {
    "name" : "private void onDrawFinished()",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "protected void onSetSurfacePositionAndScale(@NonNull Transaction transaction, @NonNull SurfaceControl surface, int positionLeft, int positionTop, float postScaleX, float postScaleY)",
    "returnType" : "void",
    "comment" : "\n     * Sets the surface position and scale. Can be called on\n     * the UI thread as well as on the renderer thread.\n     *\n     * @param transaction Transaction in which to execute.\n     * @param surface Surface whose location to set.\n     * @param positionLeft The left position to set.\n     * @param positionTop The top position to set.\n     * @param postScaleX The X axis post scale\n     * @param postScaleY The Y axis post scale\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public void requestUpdateSurfacePositionAndScale()",
    "returnType" : "void",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "public Rect getSurfaceRenderPosition()",
    "returnType" : "Rect",
    "comment" : "\n     * @return The last render position of the backing surface or an empty rect.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "private void applyOrMergeTransaction(Transaction t, long frameNumber)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private SurfaceHolder.Callback[] getSurfaceCallbacks()",
    "returnType" : "SurfaceHolder.Callback[]",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private void runOnUiThread(Runnable runnable)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public boolean isFixedSize()",
    "returnType" : "boolean",
    "comment" : "\n     * Check to see if the surface has fixed size dimensions or if the surface's\n     * dimensions are dimensions are dependent on its current layout.\n     *\n     * @return true if the surface has dimensions that are fixed in size\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "private boolean isAboveParent()",
    "returnType" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public void setResizeBackgroundColor(int bgColor)",
    "returnType" : "void",
    "comment" : "\n     * Set an opaque background color to use with this {@link SurfaceView} when it's being resized\n     * and size of the content hasn't updated yet. This color will fill the expanded area when the\n     * view becomes larger.\n     * @param bgColor An opaque color to fill the background. Alpha component will be ignored.\n     * @hide\n     ",
    "links" : [ "android.view.SurfaceView" ]
  }, {
    "name" : "public void setResizeBackgroundColor(@NonNull SurfaceControl.Transaction t, int bgColor)",
    "returnType" : "void",
    "comment" : "\n     * Version of {@link #setResizeBackgroundColor(int)} that allows you to provide\n     * {@link SurfaceControl.Transaction}.\n     * @hide\n     ",
    "links" : [ "#setResizeBackgroundColor(int)", "SurfaceControl.Transaction" ]
  }, {
    "name" : "public SurfaceControl getSurfaceControl()",
    "returnType" : "SurfaceControl",
    "comment" : "\n     * Return a SurfaceControl which can be used for parenting Surfaces to this SurfaceView.\n     *\n     * Note that this SurfaceControl is effectively read-only. Its only well-defined usage is in\n     * using the SurfaceControl as a parent for an application's hierarchy of SurfaceControls. All\n     * other properties of the SurfaceControl, such as its position, may be mutated by the\n     * SurfaceView at any time which will override what the application is requesting. Do not apply\n     * any {@link SurfaceControl.Transaction} to this SurfaceControl except for reparenting\n     * child SurfaceControls. See: {@link SurfaceControl.Transaction#reparent}.\n     *\n     * @return The SurfaceControl for this SurfaceView.\n     ",
    "links" : [ "SurfaceControl.Transaction#reparent", "SurfaceControl.Transaction" ]
  }, {
    "name" : "public IBinder getHostToken()",
    "returnType" : "IBinder",
    "comment" : "\n     * A token used for constructing {@link SurfaceControlViewHost}. This token should\n     * be passed from the host process to the client process.\n     *\n     * @return The token\n     * @deprecated Use {@link AttachedSurfaceControl#getInputTransferToken()} instead.\n     ",
    "links" : [ "android.view.SurfaceControlViewHost", "android.view.AttachedSurfaceControl#getInputTransferToken()" ]
  }, {
    "name" : "public void surfaceCreated(SurfaceControl.Transaction t)",
    "returnType" : "void",
    "comment" : "\n     * Set window stopped to false and update surface visibility when ViewRootImpl surface is\n     * created.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public void surfaceDestroyed()",
    "returnType" : "void",
    "comment" : "\n     * Set window stopped to true and update surface visibility when ViewRootImpl surface is\n     * destroyed.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public void surfaceReplaced(Transaction t)",
    "returnType" : "void",
    "comment" : "\n     * Called when a valid ViewRootImpl surface is replaced by another valid surface. In this\n     * case update relative z to the new parent surface.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "private void updateRelativeZ(Transaction t)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public void setChildSurfacePackage(@NonNull SurfaceControlViewHost.SurfacePackage p)",
    "returnType" : "void",
    "comment" : "\n     * Display the view-hierarchy embedded within a {@link SurfaceControlViewHost.SurfacePackage}\n     * within this SurfaceView.\n     *\n     * This can be called independently of the SurfaceView lifetime callbacks. SurfaceView\n     * will internally manage reparenting the package to our Surface as it is created\n     * and destroyed.\n     *\n     * If this SurfaceView is above its host Surface (see\n     * {@link #setZOrderOnTop} then the embedded Surface hierarchy will be able to receive\n     * input.\n     *\n     * This will take ownership of the SurfaceControl contained inside the SurfacePackage\n     * and free the caller of the obligation to call\n     * {@link SurfaceControlViewHost.SurfacePackage#release}. However, note that\n     * {@link SurfaceControlViewHost.SurfacePackage#release} and\n     * {@link SurfaceControlViewHost#release} are not the same. While the ownership\n     * of this particular {@link SurfaceControlViewHost.SurfacePackage} will be taken by the\n     * SurfaceView the underlying {@link SurfaceControlViewHost} remains managed by it's original\n     * remote-owner.\n     *\n     * @param p The SurfacePackage to embed.\n     ",
    "links" : [ "android.view.SurfaceControlViewHost#release", "SurfaceControlViewHost.SurfacePackage", "#setZOrderOnTop", "SurfaceControlViewHost.SurfacePackage#release", "android.view.SurfaceControlViewHost" ]
  }, {
    "name" : "private void reparentSurfacePackage(SurfaceControl.Transaction t, SurfaceControlViewHost.SurfacePackage p)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public void onInitializeAccessibilityNodeInfoInternal(AccessibilityNodeInfo info)",
    "returnType" : "void",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "public int getImportantForAccessibility()",
    "returnType" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private void initEmbeddedHierarchyForAccessibility(SurfaceControlViewHost.SurfacePackage p)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private void notifySurfaceDestroyed()",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : " void updateEmbeddedAccessibilityMatrix(boolean force)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "protected void onFocusChanged(boolean gainFocus, @FocusDirection int direction, @Nullable Rect previouslyFocusedRect)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private void requestEmbeddedFocus(boolean gainFocus)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private void applyTransactionOnVriDraw(Transaction t)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public void syncNextFrame(Consumer<Transaction> t)",
    "returnType" : "void",
    "comment" : "\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public void applyTransactionToFrame(@NonNull SurfaceControl.Transaction transaction)",
    "returnType" : "void",
    "comment" : "\n     * Adds a transaction that would be applied synchronously with displaying the SurfaceView's next\n     * frame.\n     *\n     * Note that the exact frame that the transaction is applied with is only well-defined when\n     * SurfaceView rendering is paused prior to calling applyTransactionToFrame(), so that the\n     * transaction is applied with the next frame rendered after applyTransactionToFrame() is\n     * called. If frames are continuously rendering to the SurfaceView when\n     * applyTransactionToFrame() is called, then it is undefined which frame the transaction is\n     * applied with. It is also possible for the transaction to not be applied if no new frames are\n     * rendered to the SurfaceView after this is called.\n     *\n     * @param transaction The transaction to apply. The system takes ownership of the transaction\n     *                    and promises to eventually apply the transaction.\n     * @throws IllegalStateException if the underlying Surface does not exist (and therefore\n     *         there is no next frame).\n     ",
    "links" : [ ]
  }, {
    "name" : " void performCollectViewAttributes(AttachInfo attachInfo, int visibility)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  } ],
  "methodNames" : [ "public SurfaceHolder getHolder()", "private void updateRequestedVisibility()", "private void setWindowStopped(boolean stopped)", "protected void onAttachedToWindow()", "protected void onWindowVisibilityChanged(int visibility)", "public void setVisibility(int visibility)", "public void setUseAlpha()", "public void setAlpha(float alpha)", "protected boolean onSetAlpha(int alpha)", "private void performDrawFinished()", "protected void onDetachedFromWindow()", "protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec)", "protected boolean setFrame(int left, int top, int right, int bottom)", "public boolean gatherTransparentRegion(Region region)", "public void draw(Canvas canvas)", "protected void dispatchDraw(Canvas canvas)", "public void setEnableSurfaceClipping(boolean enabled)", "public void setClipBounds(Rect clipBounds)", "public boolean hasOverlappingRendering()", "private void clearSurfaceViewPort(Canvas canvas)", "public void setCornerRadius(float cornerRadius)", "public float getCornerRadius()", "public void setZOrderMediaOverlay(boolean isMediaOverlay)", "public void setZOrderOnTop(boolean onTop)", "public boolean isZOrderedOnTop()", "public boolean setZOrderedOnTop(boolean onTop, boolean allowDynamicChange)", "public void setSecure(boolean isSecure)", "public void setSurfaceLifecycle(@SurfaceLifecycleStrategy int lifecycleStrategy)", "public void setDesiredHdrHeadroom(@FloatRange(from = 0.0f, to = 10000.0) float desiredHeadroom)", "private void updateOpaqueFlag()", "private void updateBackgroundVisibility(Transaction t)", "private Transaction updateBackgroundColor(Transaction t)", "private void releaseSurfaces(boolean releaseSurfacePackage)", "private void replacePositionUpdateListener(int surfaceWidth, int surfaceHeight)", "private boolean performSurfaceTransaction(ViewRootImpl viewRoot, Translator translator, boolean creating, boolean sizeChanged, boolean hintChanged, boolean relativeZChanged, boolean hdrHeadroomChanged, Transaction surfaceUpdateTransaction)", "private boolean requiresSurfaceControlCreation(boolean formatChanged, boolean visibleChanged)", "private boolean surfaceShouldExist()", "protected void updateSurface()", "public String getName()", "private void handleSyncBufferCallback(SurfaceHolder.Callback[] callbacks, SyncBufferTransactionCallback syncBufferTransactionCallback)", "private void handleSyncNoBuffer(SurfaceHolder.Callback[] callbacks)", "private void redrawNeededAsync(SurfaceHolder.Callback[] callbacks, Runnable callbacksCollected)", "public void vriDrawStarted(boolean isWmSync)", "private void copySurface(boolean surfaceControlCreated, boolean bufferSizeChanged)", "private void setBufferSize(Transaction transaction)", "private void createBlastSurfaceControls(ViewRootImpl viewRoot, String name, Transaction surfaceUpdateTransaction)", "private void onDrawFinished()", "protected void onSetSurfacePositionAndScale(@NonNull Transaction transaction, @NonNull SurfaceControl surface, int positionLeft, int positionTop, float postScaleX, float postScaleY)", "public void requestUpdateSurfacePositionAndScale()", "public Rect getSurfaceRenderPosition()", "private void applyOrMergeTransaction(Transaction t, long frameNumber)", "private SurfaceHolder.Callback[] getSurfaceCallbacks()", "private void runOnUiThread(Runnable runnable)", "public boolean isFixedSize()", "private boolean isAboveParent()", "public void setResizeBackgroundColor(int bgColor)", "public void setResizeBackgroundColor(@NonNull SurfaceControl.Transaction t, int bgColor)", "public SurfaceControl getSurfaceControl()", "public IBinder getHostToken()", "public void surfaceCreated(SurfaceControl.Transaction t)", "public void surfaceDestroyed()", "public void surfaceReplaced(Transaction t)", "private void updateRelativeZ(Transaction t)", "public void setChildSurfacePackage(@NonNull SurfaceControlViewHost.SurfacePackage p)", "private void reparentSurfacePackage(SurfaceControl.Transaction t, SurfaceControlViewHost.SurfacePackage p)", "public void onInitializeAccessibilityNodeInfoInternal(AccessibilityNodeInfo info)", "public int getImportantForAccessibility()", "private void initEmbeddedHierarchyForAccessibility(SurfaceControlViewHost.SurfacePackage p)", "private void notifySurfaceDestroyed()", " void updateEmbeddedAccessibilityMatrix(boolean force)", "protected void onFocusChanged(boolean gainFocus, @FocusDirection int direction, @Nullable Rect previouslyFocusedRect)", "private void requestEmbeddedFocus(boolean gainFocus)", "private void applyTransactionOnVriDraw(Transaction t)", "public void syncNextFrame(Consumer<Transaction> t)", "public void applyTransactionToFrame(@NonNull SurfaceControl.Transaction transaction)", " void performCollectViewAttributes(AttachInfo attachInfo, int visibility)" ],
  "variableNames" : [ "SURFACE_LIFECYCLE_DEFAULT", "SURFACE_LIFECYCLE_FOLLOWS_VISIBILITY", "SURFACE_LIFECYCLE_FOLLOWS_ATTACHMENT", "TAG", "DEBUG", "DEBUG_POSITION", "FORWARD_BACK_KEY_TOLERANCE_MS", "mCallbacks", "mLocation", "mSurfaceLock", "mSurface", "mDrawingStopped", "mDrawFinished", "mScreenRect", "mSurfaceSession", "mLimitedHdrEnabled", "mSurfaceControl", "mBackgroundControl", "mDisableBackgroundLayer", "mRequestedSurfaceLifecycleStrategy", "mSurfaceLifecycleStrategy", "mRequestedHdrHeadroom", "mHdrHeadroom", "mSurfaceControlLock", "mTmpRect", "mRoundedViewportPaint", "mSubLayer", "mRequestedSubLayer", "mIsCreating", "mScrollChangedListener", "mDrawListener", "mRequestedVisible", "mWindowVisibility", "mLastWindowVisibility", "mViewVisibility", "mWindowStopped", "mRequestedWidth", "mRequestedHeight", "mRequestedFormat", "mAlpha", "mClipSurfaceToBounds", "mBackgroundColor", "mHaveFrame", "mSurfaceCreated", "mLastLockTime", "mVisible", "mWindowSpaceLeft", "mWindowSpaceTop", "mSurfaceWidth", "mSurfaceHeight", "mCornerRadius", "mFormat", "mSurfaceFrame", "mLastSurfaceWidth", "mLastSurfaceHeight", "mTransformHint", "mGlobalListenersAdded", "mAttachedToWindow", "mSurfaceFlags", "mSyncGroups", "mRtTransaction", "mFrameCallbackTransaction", "mParentSurfaceSequenceId", "mRemoteAccessibilityController", "mTmpMatrix", "mSurfacePackage", "mBlastSurfaceControl", "mBlastBufferQueue", "mEmbeddedWindowParams", "mSurfaceControlViewHostParent", "mRtDrivenClipping", "mRTLastReportedPosition", "mRTLastSetCrop", "mPositionListener", "mSurfaceHolder" ]
}