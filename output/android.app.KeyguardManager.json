{
  "filePath" : "/home/maryam/clearblue/files/android-source-35/android/app/KeyguardManager.java",
  "packageName" : "android.app",
  "className" : "KeyguardManager",
  "comment" : "\n * Class to manage and query the state of the lock screen (also known as Keyguard).\n ",
  "links" : [ ],
  "variables" : [ {
    "name" : "TAG",
    "type" : "String",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mContext",
    "type" : "Context",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mLockPatternUtils",
    "type" : "LockPatternUtils",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mWM",
    "type" : "IWindowManager",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mAm",
    "type" : "IActivityManager",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mTrustManager",
    "type" : "ITrustManager",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mNotificationManager",
    "type" : "INotificationManager",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mListeners",
    "type" : "ArrayMap<WeakEscrowTokenRemovedListener, IWeakEscrowTokenRemovedListener>",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "ACTION_CONFIRM_DEVICE_CREDENTIAL",
    "type" : "String",
    "comment" : "\n     * Intent used to prompt user for device credentials.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "ACTION_CONFIRM_DEVICE_CREDENTIAL_WITH_USER",
    "type" : "String",
    "comment" : "\n     * Intent used to prompt user for device credentials.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "ACTION_CONFIRM_FRP_CREDENTIAL",
    "type" : "String",
    "comment" : "\n     * Intent used to prompt user for factory reset credentials.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "ACTION_CONFIRM_REMOTE_DEVICE_CREDENTIAL",
    "type" : "String",
    "comment" : "\n     * Intent used to prompt user to to validate the credentials of a remote device.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "ACTION_PREPARE_REPAIR_MODE_DEVICE_CREDENTIAL",
    "type" : "String",
    "comment" : "\n     * Intent used to prompt user for device credential for entering repair\n     * mode. If the credential is verified successfully, then the information\n     * needed to verify the credential again will be written to a location that\n     * is available to repair mode. This makes it possible for repair mode to\n     * require that the same credential be provided to exit repair mode.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "ACTION_CONFIRM_REPAIR_MODE_DEVICE_CREDENTIAL",
    "type" : "String",
    "comment" : "\n     * Intent used to prompt user for device credential that is written by\n     * {@link #ACTION_PREPARE_REPAIR_MODE_DEVICE_CREDENTIAL} for exiting\n     * repair mode.\n     * @hide\n     ",
    "links" : [ "#ACTION_PREPARE_REPAIR_MODE_DEVICE_CREDENTIAL" ]
  }, {
    "name" : "EXTRA_TITLE",
    "type" : "String",
    "comment" : "\n     * A CharSequence dialog title to show to the user when used with a\n     * {@link #ACTION_CONFIRM_DEVICE_CREDENTIAL}.\n     * @hide\n     ",
    "links" : [ "#ACTION_CONFIRM_DEVICE_CREDENTIAL" ]
  }, {
    "name" : "EXTRA_DESCRIPTION",
    "type" : "String",
    "comment" : "\n     * A CharSequence description to show to the user when used with\n     * {@link #ACTION_CONFIRM_DEVICE_CREDENTIAL}.\n     * @hide\n     ",
    "links" : [ "#ACTION_CONFIRM_DEVICE_CREDENTIAL" ]
  }, {
    "name" : "EXTRA_ALTERNATE_BUTTON_LABEL",
    "type" : "String",
    "comment" : "\n     * A CharSequence description to show to the user on the alternate button when used with\n     * {@link #ACTION_CONFIRM_FRP_CREDENTIAL}.\n     * @hide\n     ",
    "links" : [ "#ACTION_CONFIRM_FRP_CREDENTIAL" ]
  }, {
    "name" : "EXTRA_CHECKBOX_LABEL",
    "type" : "String",
    "comment" : "\n     * A CharSequence label for the checkbox when used with\n     * {@link #ACTION_CONFIRM_REMOTE_DEVICE_CREDENTIAL}\n     * @hide\n     ",
    "links" : [ "#ACTION_CONFIRM_REMOTE_DEVICE_CREDENTIAL" ]
  }, {
    "name" : "EXTRA_REMOTE_LOCKSCREEN_VALIDATION_SESSION",
    "type" : "String",
    "comment" : "\n     * A {@link RemoteLockscreenValidationSession} extra to be sent along with\n     * {@link #ACTION_CONFIRM_REMOTE_DEVICE_CREDENTIAL} containing the data needed to prompt for\n     * a remote device's lock screen.\n     * @hide\n     ",
    "links" : [ "android.app.RemoteLockscreenValidationSession", "#ACTION_CONFIRM_REMOTE_DEVICE_CREDENTIAL" ]
  }, {
    "name" : "EXTRA_FORCE_TASK_OVERLAY",
    "type" : "String",
    "comment" : "\n     * A boolean indicating that credential confirmation activity should be a task overlay.\n     * {@link #ACTION_CONFIRM_DEVICE_CREDENTIAL_WITH_USER}.\n     * @hide\n     ",
    "links" : [ "#ACTION_CONFIRM_DEVICE_CREDENTIAL_WITH_USER" ]
  }, {
    "name" : "RESULT_ALTERNATE",
    "type" : "int",
    "comment" : "\n     * Result code returned by the activity started by\n     * {@link #createConfirmFactoryResetCredentialIntent} or\n     * {@link #createConfirmDeviceCredentialForRemoteValidationIntent}\n     * indicating that the user clicked the alternate button.\n     *\n     * @hide\n     ",
    "links" : [ "#createConfirmDeviceCredentialForRemoteValidationIntent", "#createConfirmFactoryResetCredentialIntent" ]
  }, {
    "name" : "EXTRA_DISALLOW_BIOMETRICS_IF_POLICY_EXISTS",
    "type" : "String",
    "comment" : "\n     *\n     * If this is set, check device policy for allowed biometrics when the user is authenticating.\n     * This should only be used in the context of managed profiles.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "PASSWORD",
    "type" : "int",
    "comment" : "\n     *\n     * Password lock type, see {@link #setLock}\n     *\n     * @hide\n     ",
    "links" : [ "#setLock" ]
  }, {
    "name" : "PIN",
    "type" : "int",
    "comment" : "\n     *\n     * Pin lock type, see {@link #setLock}\n     *\n     * @hide\n     ",
    "links" : [ "#setLock" ]
  }, {
    "name" : "PATTERN",
    "type" : "int",
    "comment" : "\n     *\n     * Pattern lock type, see {@link #setLock}\n     *\n     * @hide\n     ",
    "links" : [ "#setLock" ]
  }, {
    "name" : "mIKeyguardLockedStateListener",
    "type" : "IKeyguardLockedStateListener",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mKeyguardLockedStateListeners",
    "type" : "ArrayMap<KeyguardLockedStateListener, Executor>",
    "comment" : "",
    "links" : [ ]
  } ],
  "methods" : [ {
    "name" : "public Intent createConfirmDeviceCredentialIntent(CharSequence title, CharSequence description)",
    "returnType" : "Intent",
    "comment" : "\n     * Get an intent to prompt the user to confirm credentials (pin, pattern, password or biometrics\n     * if enrolled) for the current user of the device. The caller is expected to launch this\n     * activity using {@link android.app.Activity#startActivityForResult(Intent, int)} and check for\n     * {@link android.app.Activity#RESULT_OK} if the user successfully completes the challenge.\n     *\n     * @return the intent for launching the activity or null if no password is required.\n     *\n     * @deprecated see {@link\n     *   android.hardware.biometrics.BiometricPrompt.Builder#setAllowedAuthenticators(int)}\n     ",
    "links" : [ "android.app.Activity#RESULT_OK", "android.app.Activity#startActivityForResult(Intent", "android.hardware.biometrics.BiometricPrompt.Builder#setAllowedAuthenticators(int)" ]
  }, {
    "name" : "public Intent createConfirmDeviceCredentialIntent(CharSequence title, CharSequence description, int userId)",
    "returnType" : "Intent",
    "comment" : "\n     * Get an intent to prompt the user to confirm credentials (pin, pattern or password)\n     * for the given user. The caller is expected to launch this activity using\n     * {@link android.app.Activity#startActivityForResult(Intent, int)} and check for\n     * {@link android.app.Activity#RESULT_OK} if the user successfully completes the challenge.\n     *\n     * @return the intent for launching the activity or null if no password is required.\n     *\n     * @hide\n     ",
    "links" : [ "android.app.Activity#RESULT_OK", "android.app.Activity#startActivityForResult(Intent" ]
  }, {
    "name" : "public Intent createConfirmDeviceCredentialIntent(CharSequence title, CharSequence description, int userId, boolean disallowBiometricsIfPolicyExists)",
    "returnType" : "Intent",
    "comment" : "\n     * Get an intent to prompt the user to confirm credentials (pin, pattern or password)\n     * for the given user. The caller is expected to launch this activity using\n     * {@link android.app.Activity#startActivityForResult(Intent, int)} and check for\n     * {@link android.app.Activity#RESULT_OK} if the user successfully completes the challenge.\n     *\n     * @param disallowBiometricsIfPolicyExists If true check if the Device Policy Manager has\n     * disabled biometrics on the device. If biometrics are disabled, fall back to PIN/pattern/pass.\n     *\n     * @return the intent for launching the activity or null if no password is required.\n     *\n     * @hide\n     ",
    "links" : [ "android.app.Activity#RESULT_OK", "android.app.Activity#startActivityForResult(Intent" ]
  }, {
    "name" : "public Intent createConfirmFactoryResetCredentialIntent(CharSequence title, CharSequence description, CharSequence alternateButtonLabel)",
    "returnType" : "Intent",
    "comment" : "\n     * Get an intent to prompt the user to confirm credentials (pin, pattern or password)\n     * for the previous owner of the device. The caller is expected to launch this activity using\n     * {@link android.app.Activity#startActivityForResult(Intent, int)} and check for\n     * {@link android.app.Activity#RESULT_OK} if the user successfully completes the challenge.\n     *\n     * @param alternateButtonLabel if not empty, a button is provided with the given label. Upon\n     *                             clicking this button, the activity returns\n     *                             {@link #RESULT_ALTERNATE}\n     *\n     * @return the intent for launching the activity or null if the previous owner of the device\n     *         did not set a credential.\n     * @throws UnsupportedOperationException if the device does not support factory reset\n     *                                       credentials\n     * @throws IllegalStateException if the device has already been provisioned\n     * @hide\n     ",
    "links" : [ "android.app.Activity#RESULT_OK", "android.app.Activity#startActivityForResult(Intent", "#RESULT_ALTERNATE" ]
  }, {
    "name" : "public Intent createConfirmDeviceCredentialForRemoteValidationIntent(@NonNull RemoteLockscreenValidationSession session, @NonNull ComponentName remoteLockscreenValidationServiceComponent, @Nullable CharSequence title, @Nullable CharSequence description, @Nullable CharSequence checkboxLabel, @Nullable CharSequence alternateButtonLabel)",
    "returnType" : "Intent",
    "comment" : "\n     * Get an Intent to launch an activity to prompt the user to confirm the\n     * credentials (pin, pattern or password) of a remote device.\n     * @param session contains information necessary to start remote device credential validation.\n     * @param remoteLockscreenValidationServiceComponent\n     *          the {@link ComponentName} of the implementation of\n     *          {@link android.service.remotelockscreenvalidation.RemoteLockscreenValidationService}\n     * @param checkboxLabel if not empty, a checkbox is provided with the given label. When checked,\n     *                      the validated remote device credential will be set as the device lock of\n     *                      the current device.\n     * @param alternateButtonLabel if not empty, a button is provided with the given label. Upon\n     *                             clicking this button, the activity returns\n     *                             {@link #RESULT_ALTERNATE}.\n     * @hide\n     ",
    "links" : [ "android.service.remotelockscreenvalidation.RemoteLockscreenValidationService", "android.content.ComponentName", "#RESULT_ALTERNATE" ]
  }, {
    "name" : "public void setPrivateNotificationsAllowed(boolean allow)",
    "returnType" : "void",
    "comment" : "\n     * Controls whether notifications can be shown atop a securely locked screen in their full\n     * private form (same as when the device is unlocked).\n     *\n     * <p>Other sources like the DevicePolicyManger and Settings app can modify this configuration.\n     * The result is that private notifications are only shown if all sources allow it.\n     *\n     * @param allow secure notifications can be shown if {@code true},\n     * secure notifications cannot be shown if {@code false}\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean getPrivateNotificationsAllowed()",
    "returnType" : "boolean",
    "comment" : "\n     * Returns whether notifications can be shown atop a securely locked screen in their full\n     * private form (same as when the device is unlocked).\n     *\n     * @return {@code true} if secure notifications can be shown, {@code false} otherwise.\n     * By default, private notifications are allowed.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "private String getSettingsPackageForIntent(Intent intent)",
    "returnType" : "String",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public KeyguardLock newKeyguardLock(String tag)",
    "returnType" : "KeyguardLock",
    "comment" : "\n     * Enables you to temporarily disable / reenable the keyguard (lock screen).\n     *\n     * @param tag A tag that informally identifies who you are (for debugging who\n     *   is disabling the keyguard).\n     *\n     * @return A {@link KeyguardLock} handle to use to disable and reenable the\n     *   keyguard.\n     *\n     * @deprecated Use {@link android.R.attr#showWhenLocked} or {@link\n     *   android.app.Activity#setShowWhenLocked(boolean)} instead. This allows you to seamlessly\n     *   occlude and unocclude the keyguard as your application moves in and out of the foreground\n     *   and does not require that any special permissions be requested.\n     ",
    "links" : [ "KeyguardLock", "android.app.Activity#setShowWhenLocked(boolean)", "android.R.attr#showWhenLocked" ]
  }, {
    "name" : "public boolean isKeyguardLocked()",
    "returnType" : "boolean",
    "comment" : "\n     * Returns whether the lock screen (also known as Keyguard) is showing.\n     * <p>\n     * Specifically, this returns {@code true} in the following cases:\n     * <ul>\n     *   <li>The lock screen is showing in the foreground.</li>\n     *   <li>The lock screen is showing, but it is occluded by an activity that is showing on top of\n     *   it. A common example is the phone app receiving a call or making an emergency call.</li>\n     *   <li>The lock screen was showing but is temporarily disabled as a result of <a\n     *   href=\"https://developer.android.com/work/dpc/dedicated-devices/lock-task-mode\">lock task\n     *   mode</a> or an app using the deprecated {@link KeyguardLock} API.</li>\n     * </ul>\n     * <p>\n     * \"Showing\" refers to a logical state of the UI, regardless of whether the screen happens to be\n     * on. When the power button is pressed on an unlocked device, the lock screen starts \"showing\"\n     * immediately when the screen turns off.\n     * <p>\n     * This method does not distinguish a lock screen that is requiring authentication (e.g. with\n     * PIN, pattern, password, or biometric) from a lock screen that is trivially dismissible (e.g.\n     * with swipe). It also does not distinguish a lock screen requesting a SIM card PIN from a\n     * normal device lock screen. Finally, it always returns the global lock screen state and does\n     * not consider the {@link Context}'s user specifically.\n     * <p>\n     * Note that {@code isKeyguardLocked()} is confusingly named and probably should be called\n     * {@code isKeyguardShowing()}. On many devices, the lock screen displays an <i>unlocked</i>\n     * padlock icon when it is trivially dismissible. As mentioned above, {@code isKeyguardLocked()}\n     * actually returns {@code true} in this case, not {@code false} as might be expected. {@link\n     * #isDeviceLocked()} is an alternative API that has slightly different semantics.\n     *\n     * @return {@code true} if the lock screen is showing\n     * @see #isDeviceLocked()\n     ",
    "links" : [ "android.content.Context", "#isDeviceLocked()", "KeyguardLock" ]
  }, {
    "name" : "public boolean isKeyguardSecure()",
    "returnType" : "boolean",
    "comment" : "\n     * Returns whether the user has a secure lock screen or there is a locked SIM card.\n     * <p>\n     * Specifically, this returns {@code true} if at least one of the following is true:\n     * <ul>\n     *   <li>The {@link Context}'s user has a secure lock screen. A full user or a profile that uses\n     *   a separate challenge has a secure lock screen if its lock screen is set to PIN, pattern, or\n     *   password, as opposed to swipe or none. A profile that uses a unified challenge is\n     *   considered to have a secure lock screen if and only if its parent user has a secure lock\n     *   screen.</li>\n     *   <li>At least one SIM card is currently locked and requires a PIN.</li>\n     * </ul>\n     * <p>\n     * This method does not consider whether the lock screen is currently showing or not.\n     * <p>\n     * See also {@link #isDeviceSecure()} which excludes locked SIM cards.\n     *\n     * @return {@code true} if the user has a secure lock screen or there is a locked SIM card\n     * @see #isDeviceSecure()\n     ",
    "links" : [ "android.content.Context", "#isDeviceSecure()" ]
  }, {
    "name" : "public boolean inKeyguardRestrictedInputMode()",
    "returnType" : "boolean",
    "comment" : "\n     * Returns whether the lock screen is showing.\n     * <p>\n     * This is exactly the same as {@link #isKeyguardLocked()}.\n     *\n     * @return the value of {@link #isKeyguardLocked()}\n     * @deprecated Use {@link #isKeyguardLocked()} instead.\n     ",
    "links" : [ "#isKeyguardLocked()" ]
  }, {
    "name" : "public boolean isDeviceLocked()",
    "returnType" : "boolean",
    "comment" : "\n     * Returns whether the device is currently locked for the user.\n     * <p>\n     * This method returns the device locked state for the {@link Context}'s user. The device is\n     * considered to be locked for a user when the user's apps are currently inaccessible and some\n     * form of lock screen authentication is required to regain access to them. The lock screen\n     * authentication typically uses PIN, pattern, password, or biometric. Some devices may support\n     * additional methods, such as unlock using a paired smartwatch. \"Swipe\" does not count as\n     * authentication; if the lock screen is dismissible with swipe, for example due to the lock\n     * screen being set to Swipe or due to the device being kept unlocked by being near a trusted\n     * bluetooth device or in a trusted location, the device is considered unlocked.\n     * <div class=\"note\">\n     * <p>\n     * <b>Note:</b> In the case of multiple full users, each user can have their own lock screen\n     * authentication configured. The device-locked state may differ between different users. For\n     * example, the device may be unlocked for the current user, but locked for a non-current user\n     * if lock screen authentication would be required to access that user's apps after switching to\n     * that user.\n     * <p>\n     * In the case of a profile, when the device goes to the main lock screen, up to two layers of\n     * authentication may be required to regain access to the profile's apps: one to unlock the main\n     * lock screen, and one to unlock the profile (when a separate profile challenge is required).\n     * For a profile, the device is considered to be locked as long as any challenge remains, either\n     * the parent user's challenge (when applicable) or the profile's challenge (when applicable).\n     * </div>\n     *\n     * @return {@code true} if the device is currently locked for the user\n     * @see #isKeyguardLocked()\n     ",
    "links" : [ "android.content.Context" ]
  }, {
    "name" : "public boolean isDeviceLocked(int userId)",
    "returnType" : "boolean",
    "comment" : "\n     * Per-user version of {@link #isDeviceLocked()}.\n     *\n     * @hide\n     ",
    "links" : [ "#isDeviceLocked()" ]
  }, {
    "name" : "public boolean isDeviceLocked(@UserIdInt int userId, int deviceId)",
    "returnType" : "boolean",
    "comment" : "\n     * Per-user per-device version of {@link #isDeviceLocked()}.\n     *\n     * @hide\n     ",
    "links" : [ "#isDeviceLocked()" ]
  }, {
    "name" : "public boolean isDeviceSecure()",
    "returnType" : "boolean",
    "comment" : "\n     * Returns whether the user has a secure lock screen.\n     * <p>\n     * This returns {@code true} if the {@link Context}'s user has a secure lock screen. A full user\n     * or a profile that uses a separate challenge has a secure lock screen if its lock screen is\n     * set to PIN, pattern, or password, as opposed to swipe or none. A profile that uses a unified\n     * challenge is considered to have a secure lock screen if and only if its parent user has a\n     * secure lock screen.\n     * <p>\n     * This method does not consider whether the lock screen is currently showing or not.\n     * <p>\n     * See also {@link #isKeyguardSecure()} which includes locked SIM cards.\n     *\n     * @return {@code true} if the user has a secure lock screen\n     * @see #isKeyguardSecure()\n     ",
    "links" : [ "android.content.Context", "#isKeyguardSecure()" ]
  }, {
    "name" : "public boolean isDeviceSecure(int userId)",
    "returnType" : "boolean",
    "comment" : "\n     * Per-user version of {@link #isDeviceSecure()}.\n     *\n     * @hide\n     ",
    "links" : [ "#isDeviceSecure()" ]
  }, {
    "name" : "public boolean isDeviceSecure(@UserIdInt int userId, int deviceId)",
    "returnType" : "boolean",
    "comment" : "\n     * Per-user per-device version of {@link #isDeviceSecure()}.\n     *\n     * @hide\n     ",
    "links" : [ "#isDeviceSecure()" ]
  }, {
    "name" : "public void requestDismissKeyguard(@NonNull Activity activity, @Nullable KeyguardDismissCallback callback)",
    "returnType" : "void",
    "comment" : "\n     * Requests that the Keyguard (lock screen) be dismissed if it is currently showing.\n     * <p>\n     * If the Keyguard is not secure or the device is currently in a trusted state, calling this\n     * method will immediately dismiss the Keyguard without any user interaction.\n     * <p>\n     * If the Keyguard is secure and the device is not in a trusted state, this will bring up the\n     * UI so the user can enter their credentials.\n     * <p>\n     * If the value set for the {@link Activity} attr {@link android.R.attr#turnScreenOn} is true,\n     * the screen will turn on when the keyguard is dismissed.\n     *\n     * @param activity The activity requesting the dismissal. The activity must either be visible\n     *                 by using {@link android.R.attr#showWhenLocked} or {@link\n     *                 android.app.Activity#setShowWhenLocked(boolean)}, or must be in a state in\n     *                 which it would be visible if Keyguard would not be hiding it. If that's not\n     *                 the case, the request will fail immediately and\n     *                 {@link KeyguardDismissCallback#onDismissError} will be invoked.\n     * @param callback The callback to be called if the request to dismiss Keyguard was successful\n     *                 or {@code null} if the caller isn't interested in knowing the result. The\n     *                 callback will not be invoked if the activity was destroyed before the\n     *                 callback was received.\n     ",
    "links" : [ "android.app.Activity#setShowWhenLocked(boolean)", "android.R.attr#showWhenLocked", "android.R.attr#turnScreenOn", "android.app.Activity", "com.android.internal.policy.IKeyguardDismissCallback#onDismissError" ]
  }, {
    "name" : "public void requestDismissKeyguard(@NonNull Activity activity, @Nullable CharSequence message, @Nullable KeyguardDismissCallback callback)",
    "returnType" : "void",
    "comment" : "\n     * Requests that the Keyguard (lock screen) be dismissed if it is currently showing.\n     * <p>\n     * If the Keyguard is not secure or the device is currently in a trusted state, calling this\n     * method will immediately dismiss the Keyguard without any user interaction.\n     * <p>\n     * If the Keyguard is secure and the device is not in a trusted state, this will bring up the\n     * UI so the user can enter their credentials.\n     * <p>\n     * If the value set for the {@link Activity} attr {@link android.R.attr#turnScreenOn} is true,\n     * the screen will turn on when the keyguard is dismissed.\n     *\n     * @param activity The activity requesting the dismissal. The activity must either be visible\n     *                 by using {@link android.R.attr#showWhenLocked} or {@link\n     *                 android.app.Activity#setShowWhenLocked(boolean)}, or must be in a state in\n     *                 which it would be visible if Keyguard would not be hiding it. If that's not\n     *                 the case, the request will fail immediately and\n     *                 {@link KeyguardDismissCallback#onDismissError} will be invoked.\n     * @param message  A message that will be shown in the keyguard explaining why the user\n     *                 would want to dismiss it.\n     * @param callback The callback to be called if the request to dismiss Keyguard was successful\n     *                 or {@code null} if the caller isn't interested in knowing the result. The\n     *                 callback will not be invoked if the activity was destroyed before the\n     *                 callback was received.\n     * @hide\n     ",
    "links" : [ "android.app.Activity#setShowWhenLocked(boolean)", "android.R.attr#showWhenLocked", "android.R.attr#turnScreenOn", "android.app.Activity", "com.android.internal.policy.IKeyguardDismissCallback#onDismissError" ]
  }, {
    "name" : "public void exitKeyguardSecurely(final OnKeyguardExitResult callback)",
    "returnType" : "void",
    "comment" : "\n     * Exit the keyguard securely.  The use case for this api is that, after\n     * disabling the keyguard, your app, which was granted permission to\n     * disable the keyguard and show a limited amount of information deemed\n     * safe without the user getting past the keyguard, needs to navigate to\n     * something that is not safe to view without getting past the keyguard.\n     *\n     * This will, if the keyguard is secure, bring up the unlock screen of\n     * the keyguard.\n     *\n     * @param callback Lets you know whether the operation was successful and\n     *   it is safe to launch anything that would normally be considered safe\n     *   once the user has gotten past the keyguard.\n     *\n     * @deprecated Use {@link android.R.attr#showWhenLocked} or {@link\n     *   android.app.Activity#setShowWhenLocked(boolean)} to seamlessly occlude and unocclude the\n     *   keyguard as your application moves in and out of the foreground, without requiring any\n     *   special permissions. Use {@link #requestDismissKeyguard(android.app.Activity,\n     *   KeyguardDismissCallback)} to request dismissal of the keyguard.\n     ",
    "links" : [ "#requestDismissKeyguard(android.app.Activity", "android.app.Activity#setShowWhenLocked(boolean)", "android.R.attr#showWhenLocked" ]
  }, {
    "name" : "public boolean checkInitialLockMethodUsage()",
    "returnType" : "boolean",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "private boolean hasPermission(String permission)",
    "returnType" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public boolean isValidLockPasswordComplexity(@LockTypes int lockType, @NonNull byte[] password, @PasswordComplexity int complexity)",
    "returnType" : "boolean",
    "comment" : "\n    * Determine if a given password is valid based off its lock type and expected complexity level.\n    *\n    * @param lockType - type of lock as specified in {@link LockTypes}\n    * @param password - password to validate; this has the same encoding\n    *        as the output of String#getBytes\n    * @param complexity - complexity level imposed by the requester\n    *        as defined in {@code DevicePolicyManager.PasswordComplexity}\n    * @return {@code true} if the password is valid, false otherwise\n    * @hide\n    ",
    "links" : [ "LockTypes" ]
  }, {
    "name" : "public int getMinLockLength(boolean isPin, @PasswordComplexity int complexity)",
    "returnType" : "int",
    "comment" : "\n    * Determine the minimum allowable length for a lock type for a given complexity level.\n    *\n    * @param isPin - whether this is a PIN-type password (only digits)\n    * @param complexity - complexity level imposed by the requester\n    *        as defined in {@code DevicePolicyManager.PasswordComplexity}\n    * @return minimum allowable password length\n    * @hide\n    ",
    "links" : [ ]
  }, {
    "name" : "public boolean setLock(@LockTypes int lockType, @NonNull byte[] password, @PasswordComplexity int complexity)",
    "returnType" : "boolean",
    "comment" : "\n    * Set the lockscreen password after validating against its expected complexity level.\n    *\n    * Below {@link android.os.Build.VERSION_CODES#S_V2}, this API will only work\n    * when {@link PackageManager.FEATURE_AUTOMOTIVE} is present.\n    * @param lockType - type of lock as specified in {@link LockTypes}\n    * @param password - password to validate; this has the same encoding\n    *        as the output of String#getBytes\n    * @param complexity - complexity level imposed by the requester\n    *        as defined in {@code DevicePolicyManager.PasswordComplexity}\n    * @return {@code true} if the lock is successfully set, false otherwise\n    * @hide\n    ",
    "links" : [ "LockTypes", "android.os.Build.VERSION_CODES#S_V2", "PackageManager.FEATURE_AUTOMOTIVE" ]
  }, {
    "name" : "public long addWeakEscrowToken(@NonNull byte[] token, @NonNull UserHandle user, @NonNull @CallbackExecutor Executor executor, @NonNull WeakEscrowTokenActivatedListener listener)",
    "returnType" : "long",
    "comment" : "\n     * Create a weak escrow token for the current user, which can later be used to unlock FBE\n     * or change user password.\n     *\n     * After adding, if the user currently  has a secure lockscreen, they will need to perform a\n     * confirm credential operation in order to activate the token for future use. If the user\n     * has no secure lockscreen, then the token is activated immediately.\n     *\n     * If the user changes or removes the lockscreen password, any activated weak escrow token will\n     * be removed.\n     *\n     * @return a unique 64-bit token handle which is needed to refer to this token later.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean removeWeakEscrowToken(long handle, @NonNull UserHandle user)",
    "returnType" : "boolean",
    "comment" : "\n     * Remove a weak escrow token.\n     *\n     * @return {@code true} if the given handle refers to a valid weak token previously returned\n     * from {@link #addWeakEscrowToken}, whether it's active or not. return false otherwise.\n     * @hide\n     ",
    "links" : [ "#addWeakEscrowToken" ]
  }, {
    "name" : "public boolean isWeakEscrowTokenActive(long handle, @NonNull UserHandle user)",
    "returnType" : "boolean",
    "comment" : "\n     * Check if the given weak escrow token is active or not.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean isWeakEscrowTokenValid(long handle, @NonNull byte[] token, @NonNull UserHandle user)",
    "returnType" : "boolean",
    "comment" : "\n     * Check if the given weak escrow token is validate.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean registerWeakEscrowTokenRemovedListener(@NonNull @CallbackExecutor Executor executor, @NonNull WeakEscrowTokenRemovedListener listener)",
    "returnType" : "boolean",
    "comment" : "\n     * Register the given WeakEscrowTokenRemovedListener.\n     *\n     * @return {@code true} if the listener is registered successfully, return false otherwise.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean unregisterWeakEscrowTokenRemovedListener(@NonNull WeakEscrowTokenRemovedListener listener)",
    "returnType" : "boolean",
    "comment" : "\n     * Unregister the given WeakEscrowTokenRemovedListener.\n     *\n     * @return {@code true} if the listener is unregistered successfully, return false otherwise.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean setLock(@LockTypes int newLockType, @Nullable byte[] newPassword, @LockTypes int currentLockType, @Nullable byte[] currentPassword)",
    "returnType" : "boolean",
    "comment" : "\n     * Set the lockscreen password to {@code newPassword} after validating the current password\n     * against {@code currentPassword}.\n     * <p>If no password is currently set, {@code currentPassword} should be set to {@code null}.\n     * <p>To clear the current password, {@code newPassword} should be set to {@code null}.\n     *\n     * @return {@code true} if password successfully set.\n     *\n     * @throws IllegalArgumentException if {@code newLockType} or {@code currentLockType}\n     * is invalid.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean checkLock(@LockTypes int lockType, @Nullable byte[] password)",
    "returnType" : "boolean",
    "comment" : "\n     * Verifies the current lock credentials against {@code password}.\n     * <p>To check if no password is set, {@code password} should be set to {@code null}.\n     *\n     * @return {@code true} if credentials match\n     *\n     * @throws IllegalArgumentException if {@code lockType} is invalid.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public RemoteLockscreenValidationSession startRemoteLockscreenValidation()",
    "returnType" : "RemoteLockscreenValidationSession",
    "comment" : " Starts a session to verify lockscreen credentials provided by a remote device.\n     *\n     * The session and corresponding public key will be removed when\n     * {@code validateRemoteLockScreen} provides a correct guess or after 10 minutes of inactivity.\n     *\n     * @return information necessary to perform remote lock screen credentials check, including\n\n     * short lived public key used to send encrypted guess and lock screen type.\n     *\n     * @throws IllegalStateException if lock screen is not set\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public RemoteLockscreenValidationResult validateRemoteLockscreen(@NonNull byte[] encryptedCredential)",
    "returnType" : "RemoteLockscreenValidationResult",
    "comment" : "\n     * Verifies credentials guess from a remote device.\n     *\n     * <p>Secret must be encrypted using {@code SecureBox} library\n     * with public key from {@code RemoteLockscreenValidationSession}\n     * and header set to {@code \"encrypted_remote_credentials\"} in UTF-8 encoding.\n     *\n     * @throws IllegalStateException if there was a decryption error.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "private LockscreenCredential createLockscreenCredential(@LockTypes int lockType, @Nullable byte[] password)",
    "returnType" : "LockscreenCredential",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public void addKeyguardLockedStateListener(@NonNull @CallbackExecutor Executor executor, @NonNull KeyguardLockedStateListener listener)",
    "returnType" : "void",
    "comment" : "\n     * Registers a listener to execute when the keyguard locked state changes.\n     *\n     * @param listener The listener to add to receive keyguard locked state changes.\n     *\n     * @see #isKeyguardLocked()\n     * @see #removeKeyguardLockedStateListener(KeyguardLockedStateListener)\n     ",
    "links" : [ ]
  }, {
    "name" : "public void removeKeyguardLockedStateListener(@NonNull KeyguardLockedStateListener listener)",
    "returnType" : "void",
    "comment" : "\n     * Unregisters a listener that executes when the keyguard locked state changes.\n     *\n     * @param listener The listener to remove.\n     *\n     * @see #isKeyguardLocked()\n     * @see #addKeyguardLockedStateListener(Executor, KeyguardLockedStateListener)\n     ",
    "links" : [ ]
  } ],
  "methodNames" : [ "public Intent createConfirmDeviceCredentialIntent(CharSequence title, CharSequence description)", "public Intent createConfirmDeviceCredentialIntent(CharSequence title, CharSequence description, int userId)", "public Intent createConfirmDeviceCredentialIntent(CharSequence title, CharSequence description, int userId, boolean disallowBiometricsIfPolicyExists)", "public Intent createConfirmFactoryResetCredentialIntent(CharSequence title, CharSequence description, CharSequence alternateButtonLabel)", "public Intent createConfirmDeviceCredentialForRemoteValidationIntent(@NonNull RemoteLockscreenValidationSession session, @NonNull ComponentName remoteLockscreenValidationServiceComponent, @Nullable CharSequence title, @Nullable CharSequence description, @Nullable CharSequence checkboxLabel, @Nullable CharSequence alternateButtonLabel)", "public void setPrivateNotificationsAllowed(boolean allow)", "public boolean getPrivateNotificationsAllowed()", "private String getSettingsPackageForIntent(Intent intent)", "public KeyguardLock newKeyguardLock(String tag)", "public boolean isKeyguardLocked()", "public boolean isKeyguardSecure()", "public boolean inKeyguardRestrictedInputMode()", "public boolean isDeviceLocked()", "public boolean isDeviceLocked(int userId)", "public boolean isDeviceLocked(@UserIdInt int userId, int deviceId)", "public boolean isDeviceSecure()", "public boolean isDeviceSecure(int userId)", "public boolean isDeviceSecure(@UserIdInt int userId, int deviceId)", "public void requestDismissKeyguard(@NonNull Activity activity, @Nullable KeyguardDismissCallback callback)", "public void requestDismissKeyguard(@NonNull Activity activity, @Nullable CharSequence message, @Nullable KeyguardDismissCallback callback)", "public void exitKeyguardSecurely(final OnKeyguardExitResult callback)", "public boolean checkInitialLockMethodUsage()", "private boolean hasPermission(String permission)", "public boolean isValidLockPasswordComplexity(@LockTypes int lockType, @NonNull byte[] password, @PasswordComplexity int complexity)", "public int getMinLockLength(boolean isPin, @PasswordComplexity int complexity)", "public boolean setLock(@LockTypes int lockType, @NonNull byte[] password, @PasswordComplexity int complexity)", "public long addWeakEscrowToken(@NonNull byte[] token, @NonNull UserHandle user, @NonNull @CallbackExecutor Executor executor, @NonNull WeakEscrowTokenActivatedListener listener)", "public boolean removeWeakEscrowToken(long handle, @NonNull UserHandle user)", "public boolean isWeakEscrowTokenActive(long handle, @NonNull UserHandle user)", "public boolean isWeakEscrowTokenValid(long handle, @NonNull byte[] token, @NonNull UserHandle user)", "public boolean registerWeakEscrowTokenRemovedListener(@NonNull @CallbackExecutor Executor executor, @NonNull WeakEscrowTokenRemovedListener listener)", "public boolean unregisterWeakEscrowTokenRemovedListener(@NonNull WeakEscrowTokenRemovedListener listener)", "public boolean setLock(@LockTypes int newLockType, @Nullable byte[] newPassword, @LockTypes int currentLockType, @Nullable byte[] currentPassword)", "public boolean checkLock(@LockTypes int lockType, @Nullable byte[] password)", "public RemoteLockscreenValidationSession startRemoteLockscreenValidation()", "public RemoteLockscreenValidationResult validateRemoteLockscreen(@NonNull byte[] encryptedCredential)", "private LockscreenCredential createLockscreenCredential(@LockTypes int lockType, @Nullable byte[] password)", "public void addKeyguardLockedStateListener(@NonNull @CallbackExecutor Executor executor, @NonNull KeyguardLockedStateListener listener)", "public void removeKeyguardLockedStateListener(@NonNull KeyguardLockedStateListener listener)" ],
  "variableNames" : [ "TAG", "mContext", "mLockPatternUtils", "mWM", "mAm", "mTrustManager", "mNotificationManager", "mListeners", "ACTION_CONFIRM_DEVICE_CREDENTIAL", "ACTION_CONFIRM_DEVICE_CREDENTIAL_WITH_USER", "ACTION_CONFIRM_FRP_CREDENTIAL", "ACTION_CONFIRM_REMOTE_DEVICE_CREDENTIAL", "ACTION_PREPARE_REPAIR_MODE_DEVICE_CREDENTIAL", "ACTION_CONFIRM_REPAIR_MODE_DEVICE_CREDENTIAL", "EXTRA_TITLE", "EXTRA_DESCRIPTION", "EXTRA_ALTERNATE_BUTTON_LABEL", "EXTRA_CHECKBOX_LABEL", "EXTRA_REMOTE_LOCKSCREEN_VALIDATION_SESSION", "EXTRA_FORCE_TASK_OVERLAY", "RESULT_ALTERNATE", "EXTRA_DISALLOW_BIOMETRICS_IF_POLICY_EXISTS", "PASSWORD", "PIN", "PATTERN", "mIKeyguardLockedStateListener", "mKeyguardLockedStateListeners" ]
}