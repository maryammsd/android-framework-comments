{
  "filePath" : "/home/maryam/clearblue/files/android-source-35/android/icu/util/Freezable.java",
  "packageName" : "android.icu.util",
  "className" : "Freezable",
  "comment" : "\n * Provides a flexible mechanism for controlling access, without requiring that\n * a class be immutable. Once frozen, an object can never be unfrozen, so it is\n * thread-safe from that point onward. Once the object has been frozen, \n * it must guarantee that no changes can be made to it. Any attempt to alter \n * it must raise an UnsupportedOperationException exception. This means that when \n * the object returns internal objects, or if anyone has references to those internal\n * objects, that those internal objects must either be immutable, or must also\n * raise exceptions if any attempt to modify them is made. Of course, the object\n * can return clones of internal objects, since those are safe.\n * <h2>Background</h2>\n * <p>\n * There are often times when you need objects to be objects 'safe', so that\n * they can't be modified. Examples are when objects need to be thread-safe, or\n * in writing robust code, or in caches. If you are only creating your own\n * objects, you can guarantee this, of course -- but only if you don't make a\n * mistake. If you have objects handed into you, or are creating objects using\n * others handed into you, it is a different story. It all comes down to whether\n * you want to take the Blanche Dubois approach (&quot;depend on the kindness of\n * strangers&quot;) or the Andy Grove approach (&quot;Only the Paranoid\n * Survive&quot;).\n * </p>\n * <p>\n * For example, suppose we have a simple class:\n * </p>\n * \n * <pre>\n * public class A {\n *      protected Collection b;\n * \n *      protected Collection c;\n * \n *      public Collection get_b() {\n *              return b;\n *      }\n * \n *      public Collection get_c() {\n *              return c;\n *      }\n * \n *      public A(Collection new_b, Collection new_c) {\n *              b = new_b;\n *              c = new_c;\n *      }\n * }\n * </pre>\n * \n * <p>\n * Since the class doesn't have any setters, someone might think that it is\n * immutable. You know where this is leading, of course; this class is unsafe in\n * a number of ways. The following illustrates that.\n * </p>\n * \n * <pre>\n *  public test1(SupposedlyImmutableClass x, SafeStorage y) {\n *    // unsafe getter\n *    A a = x.getA();\n *    Collection col = a.get_b();\n *    col.add(something); // a has now been changed, and x too\n *\n *    // unsafe constructor\n *    a = new A(col, col);\n *    y.store(a);\n *    col.add(something); // a has now been changed, and y too\n *  }\n * </pre>\n * \n * <p>\n * There are a few different techniques for having safe classes.\n * </p>\n * <ol>\n * <li>Const objects. In C++, you can declare parameters const.</li>\n * <li>Immutable wrappers. For example, you can put a collection in an\n * immutable wrapper.</li>\n * <li>Always-Immutable objects. Java uses this approach, with a few\n * variations. Examples:\n * <ol>\n * <li>Simple. Once a Color is created (eg from R, G, and B integers) it is\n * immutable.</li>\n * <li>Builder Class. There is a separate 'builder' class. For example,\n * modifiable Strings are created using StringBuffer (which doesn't have the\n * full String API available). Once you want an immutable form, you create one\n * with toString().</li>\n * <li>Primitives. These are always safe, since they are copied on input/output\n * from methods.</li>\n * </ol>\n * </li>\n * <li>Cloning. Where you need an object to be safe, you clone it.</li>\n * </ol>\n * <p>\n * There are advantages and disadvantages of each of these.\n * </p>\n * <ol>\n * <li>Const provides a certain level of protection, but since const can be and\n * is often cast away, it only protects against most inadvertent mistakes. It\n * also offers no threading protection, since anyone who has a pointer to the\n * (unconst) object in another thread can mess you up.</li>\n * <li>Immutable wrappers are safer than const in that the constness can't be\n * cast away. But other than that they have all the same problems: not safe if\n * someone else keeps hold of the original object, or if any of the objects\n * returned by the class are mutable.</li>\n * <li>Always-Immutable Objects are safe, but usage can require excessive\n * object creation.</li>\n * <li>Cloning is only safe if the object truly has a 'safe' clone; defined as\n * one that <i>ensures that no change to the clone affects the original</i>.\n * Unfortunately, many objects don't have a 'safe' clone, and always cloning can\n * require excessive object creation.</li>\n * </ol>\n * <h2>Freezable Model</h2>\n * <p>\n * The <code>Freezable</code> model supplements these choices by giving you\n * the ability to build up an object by calling various methods, then when it is\n * in a final state, you can <i>make</i> it immutable. Once immutable, an\n * object cannot <i>ever </i>be modified, and is completely thread-safe: that\n * is, multiple threads can have references to it without any synchronization.\n * If someone needs a mutable version of an object, they can use\n * <code>cloneAsThawed()</code>, and modify the copy. This provides a simple,\n * effective mechanism for safe classes in circumstances where the alternatives\n * are insufficient or clumsy. (If an object is shared before it is immutable,\n * then it is the responsibility of each thread to mutex its usage (as with\n * other objects).)\n * </p>\n * <p>\n * Here is what needs to be done to implement this interface, depending on the\n * type of the object.\n * </p>\n * <h3><b>Immutable Objects</b></h3>\n * <p>\n * These are the easiest. You just use the interface to reflect that, by adding\n * the following:\n * </p>\n * \n * <pre>\n *  public class A implements Freezable&lt;A&gt; {\n *   ...\n *   public final boolean isFrozen() {return true;}\n *   public final A freeze() {return this;}\n *   public final A cloneAsThawed() { return this; }\n *   }\n * </pre>\n * \n * <p>\n * These can be final methods because subclasses of immutable objects must\n * themselves be immutable. (Note: <code>freeze</code> is returning\n * <code>this</code> for chaining.)\n * </p>\n * <h3><b>Mutable Objects</b></h3>\n * <p>\n * Add a protected 'flagging' field:\n * </p>\n * \n * <pre>\n * protected volatile boolean frozen; // WARNING: must be volatile\n * </pre>\n * \n * <p>\n * Add the following methods:\n * </p>\n * \n * <pre>\n * public final boolean isFrozen() {\n *      return frozen;\n * };\n * \n * public A freeze() {\n *      frozen = true;  // WARNING: must be final statement before return\n *      return this;\n * }\n * </pre>\n * \n * <p>\n * Add a <code>cloneAsThawed()</code> method following the normal pattern for\n * <code>clone()</code>, except that <code>frozen=false</code> in the new\n * clone.\n * </p>\n * <p>\n * Then take the setters (that is, any method that can change the internal state\n * of the object), and add the following as the first statement:\n * </p>\n * \n * <pre>\n * if (isFrozen()) {\n *      throw new UnsupportedOperationException(&quot;Attempt to modify frozen object&quot;);\n * }\n * </pre>\n * \n * <h4><b>Subclassing</b></h4>\n * <p>\n * Any subclass of a <code>Freezable</code> will just use its superclass's\n * flagging field. It must override <code>freeze()</code> and\n * <code>cloneAsThawed()</code> to call the superclass, but normally does not\n * override <code>isFrozen()</code>. It must then just pay attention to its\n * own getters, setters and fields.\n * </p>\n * <h4><b>Internal Caches</b></h4>\n * <p>\n * Internal caches are cases where the object is logically unmodified, but\n * internal state of the object changes. For example, there are const C++\n * functions that cast away the const on the &quot;this&quot; pointer in order\n * to modify an object cache. These cases are handled by mutexing the internal\n * cache to ensure thread-safety. For example, suppose that UnicodeSet had an\n * internal marker to the last code point accessed. In this case, the field is\n * not externally visible, so the only thing you need to do is to synchronize\n * the field for thread safety.\n * </p>\n * <h4>Unsafe Internal Access</h4>\n * <p>\n * Internal fields are called <i>safe</i> if they are either\n * <code>frozen</code> or immutable (such as String or primitives). If you've\n * never allowed internal access to these, then you are all done. For example,\n * converting UnicodeSet to be <code>Freezable</code> is just accomplished\n * with the above steps. But remember that you <i><b>have</b></i> allowed\n * access to unsafe internals if you have any code like the following, in a\n * getter, setter, or constructor:\n * </p>\n * \n * <pre>\n * Collection getStuff() {\n *      return stuff;\n * } // caller could keep reference &amp; modify\n * \n * void setStuff(Collection x) {\n *      stuff = x;\n * } // caller could keep reference &amp; modify\n * \n * MyClass(Collection x) {\n *      stuff = x;\n * } // caller could keep reference &amp; modify\n * </pre>\n * \n * <p>\n * These also illustrated in the code sample in <b>Background</b> above.\n * </p>\n * <p>\n * To deal with unsafe internals, the simplest course of action is to do the\n * work in the <code>freeze()</code> function. Just make all of your internal\n * fields frozen, and set the frozen flag. Any subsequent getter/setter will\n * work properly. Here is an example:\n * </p>\n * <p><b>Warning!</b> The 'frozen' boolean MUST be volatile, and must be set as the last statement\n * in the method.</p>\n * <pre>\n * public A freeze() {\n *      if (!frozen) {\n *              foo.freeze();\n *              frozen = true;\n *      }\n *      return this;\n * }\n * </pre>\n * \n * <p>\n * If the field is a <code>Collection</code> or <code>Map</code>, then to\n * make it frozen you have two choices. If you have never allowed access to the\n * collection from outside your object, then just wrap it to prevent future\n * modification.\n * </p>\n * \n * <pre>\n * zone_to_country = Collections.unmodifiableMap(zone_to_country);\n * </pre>\n * \n * <p>\n * If you have <i>ever</i> allowed access, then do a <code>clone()</code>\n * before wrapping it.\n * </p>\n * \n * <pre>\n * zone_to_country = Collections.unmodifiableMap(zone_to_country.clone());\n * </pre>\n * \n * <p>\n * If a collection <i>(or any other container of objects)</i> itself can\n * contain mutable objects, then for a safe clone you need to recurse through it\n * to make the entire collection immutable. The recursing code should pick the\n * most specific collection available, to avoid the necessity of later\n * downcasing.\n * </p>\n * <blockquote>\n * <p>\n * <b>Note: </b>An annoying flaw in Java is that the generic collections, like\n * <code>Map</code> or <code>Set</code>, don't have a <code>clone()</code>\n * operation. When you don't know the type of the collection, the simplest\n * course is to just create a new collection:\n * </p>\n * \n * <pre>\n * zone_to_country = Collections.unmodifiableMap(new HashMap(zone_to_country));\n * </pre>\n * \n * </blockquote>\n ",
  "links" : [ ],
  "variables" : [ ],
  "methods" : [ {
    "name" : "public boolean isFrozen()",
    "returnType" : "boolean",
    "comment" : "\n     * Determines whether the object has been frozen or not.\n     ",
    "links" : [ ]
  }, {
    "name" : "public T freeze()",
    "returnType" : "T",
    "comment" : "\n     * Freezes the object.\n     * @return the object itself.\n     ",
    "links" : [ ]
  }, {
    "name" : "public T cloneAsThawed()",
    "returnType" : "T",
    "comment" : "\n     * Provides for the clone operation. Any clone is initially unfrozen.\n     ",
    "links" : [ ]
  } ],
  "methodNames" : [ "public boolean isFrozen()", "public T freeze()", "public T cloneAsThawed()" ],
  "variableNames" : [ ]
}