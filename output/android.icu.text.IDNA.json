{
  "filePath" : "/home/maryam/clearblue/files/android-source-35/android/icu/text/IDNA.java",
  "packageName" : "android.icu.text",
  "className" : "IDNA",
  "comment" : "\n * Abstract base class for IDNA processing.\n * See http://www.unicode.org/reports/tr46/\n * and http://www.ietf.org/rfc/rfc3490.txt\n * <p>\n * The IDNA class is not intended for public subclassing.\n * <p>\n * The non-static methods implement UTS #46 and IDNA2008.\n * IDNA2008 is implemented according to UTS #46, see getUTS46Instance().\n * <p>\n * IDNA2003 is obsolete. The static methods implement IDNA2003. They are all deprecated.\n * <p>\n * IDNA2003 API Overview:\n * <p>\n * The static IDNA API methods implement the IDNA protocol as defined in the\n * <a href=\"http://www.ietf.org/rfc/rfc3490.txt\">IDNA RFC</a>.\n * The draft defines 2 operations: ToASCII and ToUnicode. Domain labels \n * containing non-ASCII code points are required to be processed by\n * ToASCII operation before passing it to resolver libraries. Domain names\n * that are obtained from resolver libraries are required to be processed by\n * ToUnicode operation before displaying the domain name to the user.\n * IDNA requires that implementations process input strings with \n * <a href=\"http://www.ietf.org/rfc/rfc3491.txt\">Nameprep</a>, \n * which is a profile of <a href=\"http://www.ietf.org/rfc/rfc3454.txt\">Stringprep</a> , \n * and then with <a href=\"http://www.ietf.org/rfc/rfc3492.txt\">Punycode</a>. \n * Implementations of IDNA MUST fully implement Nameprep and Punycode; \n * neither Nameprep nor Punycode are optional.\n * The input and output of ToASCII and ToUnicode operations are Unicode \n * and are designed to be chainable, i.e., applying ToASCII or ToUnicode operations\n * multiple times to an input string will yield the same result as applying the operation\n * once.\n * ToUnicode(ToUnicode(ToUnicode...(ToUnicode(string)))) == ToUnicode(string) \n * ToASCII(ToASCII(ToASCII...(ToASCII(string))) == ToASCII(string).\n * \n * @author Ram Viswanadha, Markus Scherer\n ",
  "links" : [ ],
  "variables" : [ {
    "name" : "DEFAULT",
    "type" : "int",
    "comment" : " \n     * Default options value: None of the other options are set.\n     * For use in static worker and factory methods.\n     ",
    "links" : [ ]
  }, {
    "name" : "ALLOW_UNASSIGNED",
    "type" : "int",
    "comment" : " \n     * Option to allow unassigned code points in domain names and labels.\n     * For use in static worker and factory methods.\n     * <p>This option is ignored by the UTS46 implementation.\n     * (UTS #46 disallows unassigned code points.)\n     * @deprecated ICU 55 Use UTS 46 instead via {@link #getUTS46Instance(int)}.\n     * @hide original deprecated declaration\n     ",
    "links" : [ "#getUTS46Instance(int)" ]
  }, {
    "name" : "USE_STD3_RULES",
    "type" : "int",
    "comment" : " \n     * Option to check whether the input conforms to the STD3 ASCII rules,\n     * for example the restriction of labels to LDH characters\n     * (ASCII Letters, Digits and Hyphen-Minus).\n     * For use in static worker and factory methods.\n     ",
    "links" : [ ]
  }, {
    "name" : "CHECK_BIDI",
    "type" : "int",
    "comment" : "\n     * IDNA option to check for whether the input conforms to the BiDi rules.\n     * For use in static worker and factory methods.\n     * <p>This option is ignored by the IDNA2003 implementation.\n     * (IDNA2003 always performs a BiDi check.)\n     ",
    "links" : [ ]
  }, {
    "name" : "CHECK_CONTEXTJ",
    "type" : "int",
    "comment" : "\n     * IDNA option to check for whether the input conforms to the CONTEXTJ rules.\n     * For use in static worker and factory methods.\n     * <p>This option is ignored by the IDNA2003 implementation.\n     * (The CONTEXTJ check is new in IDNA2008.)\n     ",
    "links" : [ ]
  }, {
    "name" : "NONTRANSITIONAL_TO_ASCII",
    "type" : "int",
    "comment" : "\n     * IDNA option for nontransitional processing in ToASCII().\n     * For use in static worker and factory methods.\n     * <p>By default, ToASCII() uses transitional processing.\n     * <p>This option is ignored by the IDNA2003 implementation.\n     * (This is only relevant for compatibility of newer IDNA implementations with IDNA2003.)\n     ",
    "links" : [ ]
  }, {
    "name" : "NONTRANSITIONAL_TO_UNICODE",
    "type" : "int",
    "comment" : "\n     * IDNA option for nontransitional processing in ToUnicode().\n     * For use in static worker and factory methods.\n     * <p>By default, ToUnicode() uses transitional processing.\n     * <p>This option is ignored by the IDNA2003 implementation.\n     * (This is only relevant for compatibility of newer IDNA implementations with IDNA2003.)\n     ",
    "links" : [ ]
  }, {
    "name" : "CHECK_CONTEXTO",
    "type" : "int",
    "comment" : "\n     * IDNA option to check for whether the input conforms to the CONTEXTO rules.\n     * For use in static worker and factory methods.\n     * <p>This option is ignored by the IDNA2003 implementation.\n     * (The CONTEXTO check is new in IDNA2008.)\n     * <p>This is for use by registries for IDNA2008 conformance.\n     * UTS #46 does not require the CONTEXTO check.\n     ",
    "links" : [ ]
  } ],
  "methods" : [ {
    "name" : "public static IDNA getUTS46Instance(int options)",
    "returnType" : "IDNA",
    "comment" : "\n     * Returns an IDNA instance which implements UTS #46.\n     * Returns an unmodifiable instance, owned by the caller.\n     * Cache it for multiple operations, and delete it when done.\n     * The instance is thread-safe, that is, it can be used concurrently.\n     * <p>\n     * UTS #46 defines Unicode IDNA Compatibility Processing,\n     * updated to the latest version of Unicode and compatible with both\n     * IDNA2003 and IDNA2008.\n     * <p>\n     * The worker functions use transitional processing, including deviation mappings,\n     * unless NONTRANSITIONAL_TO_ASCII or NONTRANSITIONAL_TO_UNICODE\n     * is used in which case the deviation characters are passed through without change.\n     * <p>\n     * Disallowed characters are mapped to U+FFFD.\n     * <p>\n     * Operations with the UTS #46 instance do not support the\n     * ALLOW_UNASSIGNED option.\n     * <p>\n     * By default, the UTS #46 implementation allows all ASCII characters (as valid or mapped).\n     * When the USE_STD3_RULES option is used, ASCII characters other than\n     * letters, digits, hyphen (LDH) and dot/full stop are disallowed and mapped to U+FFFD.\n     *\n     * @param options Bit set to modify the processing and error checking.\n     * @return the UTS #46 IDNA instance, if successful\n     ",
    "links" : [ ]
  }, {
    "name" : "public abstract StringBuilder labelToASCII(CharSequence label, StringBuilder dest, Info info)",
    "returnType" : "StringBuilder",
    "comment" : "\n     * Converts a single domain name label into its ASCII form for DNS lookup.\n     * If any processing step fails, then info.hasErrors() will be true and\n     * the result might not be an ASCII string.\n     * The label might be modified according to the types of errors.\n     * Labels with severe errors will be left in (or turned into) their Unicode form.\n     *\n     * @param label Input domain name label\n     * @param dest Destination string object\n     * @param info Output container of IDNA processing details.\n     * @return dest\n     ",
    "links" : [ ]
  }, {
    "name" : "public abstract StringBuilder labelToUnicode(CharSequence label, StringBuilder dest, Info info)",
    "returnType" : "StringBuilder",
    "comment" : "\n     * Converts a single domain name label into its Unicode form for human-readable display.\n     * If any processing step fails, then info.hasErrors() will be true.\n     * The label might be modified according to the types of errors.\n     *\n     * @param label Input domain name label\n     * @param dest Destination string object\n     * @param info Output container of IDNA processing details.\n     * @return dest\n     ",
    "links" : [ ]
  }, {
    "name" : "public abstract StringBuilder nameToASCII(CharSequence name, StringBuilder dest, Info info)",
    "returnType" : "StringBuilder",
    "comment" : "\n     * Converts a whole domain name into its ASCII form for DNS lookup.\n     * If any processing step fails, then info.hasErrors() will be true and\n     * the result might not be an ASCII string.\n     * The domain name might be modified according to the types of errors.\n     * Labels with severe errors will be left in (or turned into) their Unicode form.\n     *\n     * @param name Input domain name\n     * @param dest Destination string object\n     * @param info Output container of IDNA processing details.\n     * @return dest\n     ",
    "links" : [ ]
  }, {
    "name" : "public abstract StringBuilder nameToUnicode(CharSequence name, StringBuilder dest, Info info)",
    "returnType" : "StringBuilder",
    "comment" : "\n     * Converts a whole domain name into its Unicode form for human-readable display.\n     * If any processing step fails, then info.hasErrors() will be true.\n     * The domain name might be modified according to the types of errors.\n     *\n     * @param name Input domain name\n     * @param dest Destination string object\n     * @param info Output container of IDNA processing details.\n     * @return dest\n     ",
    "links" : [ ]
  }, {
    "name" : "protected static void resetInfo(Info info)",
    "returnType" : "void",
    "comment" : "\n     * @deprecated This API is ICU internal only.\n     * @hide original deprecated declaration\n     * @hide draft / provisional / internal are hidden on Android\n     ",
    "links" : [ ]
  }, {
    "name" : "protected static boolean hasCertainErrors(Info info, EnumSet<Error> errors)",
    "returnType" : "boolean",
    "comment" : "\n     * @deprecated This API is ICU internal only.\n     * @hide original deprecated declaration\n     * @hide draft / provisional / internal are hidden on Android\n     ",
    "links" : [ ]
  }, {
    "name" : "protected static boolean hasCertainLabelErrors(Info info, EnumSet<Error> errors)",
    "returnType" : "boolean",
    "comment" : "\n     * @deprecated This API is ICU internal only.\n     * @hide original deprecated declaration\n     * @hide draft / provisional / internal are hidden on Android\n     ",
    "links" : [ ]
  }, {
    "name" : "protected static void addLabelError(Info info, Error error)",
    "returnType" : "void",
    "comment" : "\n     * @deprecated This API is ICU internal only.\n     * @hide original deprecated declaration\n     * @hide draft / provisional / internal are hidden on Android\n     ",
    "links" : [ ]
  }, {
    "name" : "protected static void promoteAndResetLabelErrors(Info info)",
    "returnType" : "void",
    "comment" : "\n     * @deprecated This API is ICU internal only.\n     * @hide original deprecated declaration\n     * @hide draft / provisional / internal are hidden on Android\n     ",
    "links" : [ ]
  }, {
    "name" : "protected static void addError(Info info, Error error)",
    "returnType" : "void",
    "comment" : "\n     * @deprecated This API is ICU internal only.\n     * @hide original deprecated declaration\n     * @hide draft / provisional / internal are hidden on Android\n     ",
    "links" : [ ]
  }, {
    "name" : "protected static void setTransitionalDifferent(Info info)",
    "returnType" : "void",
    "comment" : "\n     * @deprecated This API is ICU internal only.\n     * @hide original deprecated declaration\n     * @hide draft / provisional / internal are hidden on Android\n     ",
    "links" : [ ]
  }, {
    "name" : "protected static void setBiDi(Info info)",
    "returnType" : "void",
    "comment" : "\n     * @deprecated This API is ICU internal only.\n     * @hide original deprecated declaration\n     * @hide draft / provisional / internal are hidden on Android\n     ",
    "links" : [ ]
  }, {
    "name" : "protected static boolean isBiDi(Info info)",
    "returnType" : "boolean",
    "comment" : "\n     * @deprecated This API is ICU internal only.\n     * @hide original deprecated declaration\n     * @hide draft / provisional / internal are hidden on Android\n     ",
    "links" : [ ]
  }, {
    "name" : "protected static void setNotOkBiDi(Info info)",
    "returnType" : "void",
    "comment" : "\n     * @deprecated This API is ICU internal only.\n     * @hide original deprecated declaration\n     * @hide draft / provisional / internal are hidden on Android\n     ",
    "links" : [ ]
  }, {
    "name" : "protected static boolean isOkBiDi(Info info)",
    "returnType" : "boolean",
    "comment" : "\n     * @deprecated This API is ICU internal only.\n     * @hide original deprecated declaration\n     * @hide draft / provisional / internal are hidden on Android\n     ",
    "links" : [ ]
  }, {
    "name" : "public static StringBuffer convertToASCII(String src, int options) throws StringPrepParseException",
    "returnType" : "StringBuffer",
    "comment" : "\n     * IDNA2003: This function implements the ToASCII operation as defined in the IDNA RFC.\n     * This operation is done on <b>single labels</b> before sending it to something that expects\n     * ASCII names. A label is an individual part of a domain name. Labels are usually\n     * separated by dots; e.g.\" \"www.example.com\" is composed of 3 labels \n     * \"www\",\"example\", and \"com\".\n     *\n     * @param src       The input string to be processed\n     * @param options   A bit set of options:\n     *  - IDNA.DEFAULT              Use default options, i.e., do not process unassigned code points\n     *                              and do not use STD3 ASCII rules\n     *                              If unassigned code points are found the operation fails with \n     *                              StringPrepParseException.\n     *\n     *  - IDNA.ALLOW_UNASSIGNED     Unassigned values can be converted to ASCII for query operations\n     *                              If this option is set, the unassigned code points are in the input \n     *                              are treated as normal Unicode code points.\n     *                          \n     *  - IDNA.USE_STD3_RULES       Use STD3 ASCII rules for host name syntax restrictions\n     *                              If this option is set and the input does not satisfy STD3 rules,  \n     *                              the operation will fail with ParseException\n     * @return StringBuffer the converted String\n     * @throws StringPrepParseException When an error occurs for parsing a string.\n     * @deprecated ICU 55 Use UTS 46 instead via {@link #getUTS46Instance(int)}.\n     * @hide original deprecated declaration\n     ",
    "links" : [ "#getUTS46Instance(int)" ]
  }, {
    "name" : "public static StringBuffer convertToASCII(StringBuffer src, int options) throws StringPrepParseException",
    "returnType" : "StringBuffer",
    "comment" : "\n     * IDNA2003: This function implements the ToASCII operation as defined in the IDNA RFC.\n     * This operation is done on <b>single labels</b> before sending it to something that expects\n     * ASCII names. A label is an individual part of a domain name. Labels are usually\n     * separated by dots; e.g.\" \"www.example.com\" is composed of 3 labels \n     * \"www\",\"example\", and \"com\".\n     *\n     * @param src       The input string as StringBuffer to be processed\n     * @param options   A bit set of options:\n     *  - IDNA.DEFAULT              Use default options, i.e., do not process unassigned code points\n     *                              and do not use STD3 ASCII rules\n     *                              If unassigned code points are found the operation fails with \n     *                              ParseException.\n     *\n     *  - IDNA.ALLOW_UNASSIGNED     Unassigned values can be converted to ASCII for query operations\n     *                              If this option is set, the unassigned code points are in the input \n     *                              are treated as normal Unicode code points.\n     *                          \n     *  - IDNA.USE_STD3_RULES       Use STD3 ASCII rules for host name syntax restrictions\n     *                              If this option is set and the input does not satisfy STD3 rules,  \n     *                              the operation will fail with ParseException\n     * @return StringBuffer the converted String\n     * @deprecated ICU 55 Use UTS 46 instead via {@link #getUTS46Instance(int)}.\n     * @hide original deprecated declaration\n     ",
    "links" : [ "#getUTS46Instance(int)" ]
  }, {
    "name" : "public static StringBuffer convertToASCII(UCharacterIterator src, int options) throws StringPrepParseException",
    "returnType" : "StringBuffer",
    "comment" : "\n     * IDNA2003: This function implements the ToASCII operation as defined in the IDNA RFC.\n     * This operation is done on <b>single labels</b> before sending it to something that expects\n     * ASCII names. A label is an individual part of a domain name. Labels are usually\n     * separated by dots; e.g.\" \"www.example.com\" is composed of 3 labels \n     * \"www\",\"example\", and \"com\".\n     *\n     * @param src       The input string as UCharacterIterator to be processed\n     * @param options   A bit set of options:\n     *  - IDNA.DEFAULT              Use default options, i.e., do not process unassigned code points\n     *                              and do not use STD3 ASCII rules\n     *                              If unassigned code points are found the operation fails with \n     *                              ParseException.\n     *\n     *  - IDNA.ALLOW_UNASSIGNED     Unassigned values can be converted to ASCII for query operations\n     *                              If this option is set, the unassigned code points are in the input \n     *                              are treated as normal Unicode code points.\n     *                          \n     *  - IDNA.USE_STD3_RULES       Use STD3 ASCII rules for host name syntax restrictions\n     *                              If this option is set and the input does not satisfy STD3 rules,  \n     *                              the operation will fail with ParseException\n     * @return StringBuffer the converted String\n     * @deprecated ICU 55 Use UTS 46 instead via {@link #getUTS46Instance(int)}.\n     * @hide original deprecated declaration\n     ",
    "links" : [ "#getUTS46Instance(int)" ]
  }, {
    "name" : "public static StringBuffer convertIDNToASCII(UCharacterIterator src, int options) throws StringPrepParseException",
    "returnType" : "StringBuffer",
    "comment" : "\n     * IDNA2003: Convenience function that implements the IDNToASCII operation as defined in the IDNA RFC.\n     * This operation is done on complete domain names, e.g: \"www.example.com\". \n     * It is important to note that this operation can fail. If it fails, then the input \n     * domain name cannot be used as an Internationalized Domain Name and the application\n     * should have methods defined to deal with the failure.\n     * \n     * <b>Note:</b> IDNA RFC specifies that a conformant application should divide a domain name\n     * into separate labels, decide whether to apply allowUnassigned and useSTD3ASCIIRules on each, \n     * and then convert. This function does not offer that level of granularity. The options once  \n     * set will apply to all labels in the domain name\n     *\n     * @param src       The input string as UCharacterIterator to be processed\n     * @param options   A bit set of options:\n     *  - IDNA.DEFAULT              Use default options, i.e., do not process unassigned code points\n     *                              and do not use STD3 ASCII rules\n     *                              If unassigned code points are found the operation fails with \n     *                              ParseException.\n     *\n     *  - IDNA.ALLOW_UNASSIGNED     Unassigned values can be converted to ASCII for query operations\n     *                              If this option is set, the unassigned code points are in the input \n     *                              are treated as normal Unicode code points.\n     *                          \n     *  - IDNA.USE_STD3_RULES       Use STD3 ASCII rules for host name syntax restrictions\n     *                              If this option is set and the input does not satisfy STD3 rules,  \n     *                              the operation will fail with ParseException\n     * @return StringBuffer the converted String\n     * @deprecated ICU 55 Use UTS 46 instead via {@link #getUTS46Instance(int)}.\n     * @hide original deprecated declaration\n     ",
    "links" : [ "#getUTS46Instance(int)" ]
  }, {
    "name" : "public static StringBuffer convertIDNToASCII(StringBuffer src, int options) throws StringPrepParseException",
    "returnType" : "StringBuffer",
    "comment" : "\n     * IDNA2003: Convenience function that implements the IDNToASCII operation as defined in the IDNA RFC.\n     * This operation is done on complete domain names, e.g: \"www.example.com\". \n     * It is important to note that this operation can fail. If it fails, then the input \n     * domain name cannot be used as an Internationalized Domain Name and the application\n     * should have methods defined to deal with the failure.\n     * \n     * <b>Note:</b> IDNA RFC specifies that a conformant application should divide a domain name\n     * into separate labels, decide whether to apply allowUnassigned and useSTD3ASCIIRules on each, \n     * and then convert. This function does not offer that level of granularity. The options once  \n     * set will apply to all labels in the domain name\n     *\n     * @param src       The input string as a StringBuffer to be processed\n     * @param options   A bit set of options:\n     *  - IDNA.DEFAULT              Use default options, i.e., do not process unassigned code points\n     *                              and do not use STD3 ASCII rules\n     *                              If unassigned code points are found the operation fails with \n     *                              ParseException.\n     *\n     *  - IDNA.ALLOW_UNASSIGNED     Unassigned values can be converted to ASCII for query operations\n     *                              If this option is set, the unassigned code points are in the input \n     *                              are treated as normal Unicode code points.\n     *                          \n     *  - IDNA.USE_STD3_RULES       Use STD3 ASCII rules for host name syntax restrictions\n     *                              If this option is set and the input does not satisfy STD3 rules,  \n     *                              the operation will fail with ParseException\n     * @return StringBuffer the converted String\n     * @deprecated ICU 55 Use UTS 46 instead via {@link #getUTS46Instance(int)}.\n     * @hide original deprecated declaration\n     ",
    "links" : [ "#getUTS46Instance(int)" ]
  }, {
    "name" : "public static StringBuffer convertIDNToASCII(String src, int options) throws StringPrepParseException",
    "returnType" : "StringBuffer",
    "comment" : "\n     * IDNA2003: Convenience function that implements the IDNToASCII operation as defined in the IDNA RFC.\n     * This operation is done on complete domain names, e.g: \"www.example.com\". \n     * It is important to note that this operation can fail. If it fails, then the input \n     * domain name cannot be used as an Internationalized Domain Name and the application\n     * should have methods defined to deal with the failure.\n     * \n     * <b>Note:</b> IDNA RFC specifies that a conformant application should divide a domain name\n     * into separate labels, decide whether to apply allowUnassigned and useSTD3ASCIIRules on each, \n     * and then convert. This function does not offer that level of granularity. The options once  \n     * set will apply to all labels in the domain name\n     *\n     * @param src       The input string to be processed\n     * @param options   A bit set of options:\n     *  - IDNA.DEFAULT              Use default options, i.e., do not process unassigned code points\n     *                              and do not use STD3 ASCII rules\n     *                              If unassigned code points are found the operation fails with \n     *                              ParseException.\n     *\n     *  - IDNA.ALLOW_UNASSIGNED     Unassigned values can be converted to ASCII for query operations\n     *                              If this option is set, the unassigned code points are in the input \n     *                              are treated as normal Unicode code points.\n     *                          \n     *  - IDNA.USE_STD3_RULES       Use STD3 ASCII rules for host name syntax restrictions\n     *                              If this option is set and the input does not satisfy STD3 rules,  \n     *                              the operation will fail with ParseException\n     * @return StringBuffer the converted String\n     * @deprecated ICU 55 Use UTS 46 instead via {@link #getUTS46Instance(int)}.\n     * @hide original deprecated declaration\n     ",
    "links" : [ "#getUTS46Instance(int)" ]
  }, {
    "name" : "public static StringBuffer convertToUnicode(String src, int options) throws StringPrepParseException",
    "returnType" : "StringBuffer",
    "comment" : "\n     * IDNA2003: This function implements the ToUnicode operation as defined in the IDNA RFC.\n     * This operation is done on <b>single labels</b> before sending it to something that expects\n     * Unicode names. A label is an individual part of a domain name. Labels are usually\n     * separated by dots; for e.g.\" \"www.example.com\" is composed of 3 labels \n     * \"www\",\"example\", and \"com\".\n     * \n     * @param src       The input string to be processed\n     * @param options   A bit set of options:\n     *  - IDNA.DEFAULT              Use default options, i.e., do not process unassigned code points\n     *                              and do not use STD3 ASCII rules\n     *                              If unassigned code points are found the operation fails with \n     *                              ParseException.\n     *\n     *  - IDNA.ALLOW_UNASSIGNED     Unassigned values can be converted to ASCII for query operations\n     *                              If this option is set, the unassigned code points are in the input \n     *                              are treated as normal Unicode code points.\n     *                          \n     *  - IDNA.USE_STD3_RULES       Use STD3 ASCII rules for host name syntax restrictions\n     *                              If this option is set and the input does not satisfy STD3 rules,  \n     *                              the operation will fail with ParseException\n     * @return StringBuffer the converted String\n     * @deprecated ICU 55 Use UTS 46 instead via {@link #getUTS46Instance(int)}.\n     * @hide original deprecated declaration\n     ",
    "links" : [ "#getUTS46Instance(int)" ]
  }, {
    "name" : "public static StringBuffer convertToUnicode(StringBuffer src, int options) throws StringPrepParseException",
    "returnType" : "StringBuffer",
    "comment" : "\n     * IDNA2003: This function implements the ToUnicode operation as defined in the IDNA RFC.\n     * This operation is done on <b>single labels</b> before sending it to something that expects\n     * Unicode names. A label is an individual part of a domain name. Labels are usually\n     * separated by dots; for e.g.\" \"www.example.com\" is composed of 3 labels \n     * \"www\",\"example\", and \"com\".\n     * \n     * @param src       The input string as StringBuffer to be processed\n     * @param options   A bit set of options:\n     *  - IDNA.DEFAULT              Use default options, i.e., do not process unassigned code points\n     *                              and do not use STD3 ASCII rules\n     *                              If unassigned code points are found the operation fails with \n     *                              ParseException.\n     *\n     *  - IDNA.ALLOW_UNASSIGNED     Unassigned values can be converted to ASCII for query operations\n     *                              If this option is set, the unassigned code points are in the input \n     *                              are treated as normal Unicode code points.\n     *                          \n     *  - IDNA.USE_STD3_RULES       Use STD3 ASCII rules for host name syntax restrictions\n     *                              If this option is set and the input does not satisfy STD3 rules,  \n     *                              the operation will fail with ParseException\n     * @return StringBuffer the converted String\n     * @deprecated ICU 55 Use UTS 46 instead via {@link #getUTS46Instance(int)}.\n     * @hide original deprecated declaration\n     ",
    "links" : [ "#getUTS46Instance(int)" ]
  }, {
    "name" : "public static StringBuffer convertToUnicode(UCharacterIterator src, int options) throws StringPrepParseException",
    "returnType" : "StringBuffer",
    "comment" : "\n     * IDNA2003: Function that implements the ToUnicode operation as defined in the IDNA RFC.\n     * This operation is done on <b>single labels</b> before sending it to something that expects\n     * Unicode names. A label is an individual part of a domain name. Labels are usually\n     * separated by dots; for e.g.\" \"www.example.com\" is composed of 3 labels \n     * \"www\",\"example\", and \"com\".\n     * \n     * @param src       The input string as UCharacterIterator to be processed\n     * @param options   A bit set of options:\n     *  - IDNA.DEFAULT              Use default options, i.e., do not process unassigned code points\n     *                              and do not use STD3 ASCII rules\n     *                              If unassigned code points are found the operation fails with \n     *                              ParseException.\n     *\n     *  - IDNA.ALLOW_UNASSIGNED     Unassigned values can be converted to ASCII for query operations\n     *                              If this option is set, the unassigned code points are in the input \n     *                              are treated as normal Unicode code points.\n     *                          \n     *  - IDNA.USE_STD3_RULES       Use STD3 ASCII rules for host name syntax restrictions\n     *                              If this option is set and the input does not satisfy STD3 rules,  \n     *                              the operation will fail with ParseException\n     * @return StringBuffer the converted String\n     * @deprecated ICU 55 Use UTS 46 instead via {@link #getUTS46Instance(int)}.\n     * @hide original deprecated declaration\n     ",
    "links" : [ "#getUTS46Instance(int)" ]
  }, {
    "name" : "public static StringBuffer convertIDNToUnicode(UCharacterIterator src, int options) throws StringPrepParseException",
    "returnType" : "StringBuffer",
    "comment" : "\n     * IDNA2003: Convenience function that implements the IDNToUnicode operation as defined in the IDNA RFC.\n     * This operation is done on complete domain names, e.g: \"www.example.com\". \n     *\n     * <b>Note:</b> IDNA RFC specifies that a conformant application should divide a domain name\n     * into separate labels, decide whether to apply allowUnassigned and useSTD3ASCIIRules on each, \n     * and then convert. This function does not offer that level of granularity. The options once  \n     * set will apply to all labels in the domain name\n     *\n     * @param src       The input string as UCharacterIterator to be processed\n     * @param options   A bit set of options:\n     *  - IDNA.DEFAULT              Use default options, i.e., do not process unassigned code points\n     *                              and do not use STD3 ASCII rules\n     *                              If unassigned code points are found the operation fails with \n     *                              ParseException.\n     *\n     *  - IDNA.ALLOW_UNASSIGNED     Unassigned values can be converted to ASCII for query operations\n     *                              If this option is set, the unassigned code points are in the input \n     *                              are treated as normal Unicode code points.\n     *                          \n     *  - IDNA.USE_STD3_RULES       Use STD3 ASCII rules for host name syntax restrictions\n     *                              If this option is set and the input does not satisfy STD3 rules,  \n     *                              the operation will fail with ParseException\n     * @return StringBuffer the converted String\n     * @deprecated ICU 55 Use UTS 46 instead via {@link #getUTS46Instance(int)}.\n     * @hide original deprecated declaration\n     ",
    "links" : [ "#getUTS46Instance(int)" ]
  }, {
    "name" : "public static StringBuffer convertIDNToUnicode(StringBuffer src, int options) throws StringPrepParseException",
    "returnType" : "StringBuffer",
    "comment" : "\n     * IDNA2003: Convenience function that implements the IDNToUnicode operation as defined in the IDNA RFC.\n     * This operation is done on complete domain names, e.g: \"www.example.com\". \n     *\n     * <b>Note:</b> IDNA RFC specifies that a conformant application should divide a domain name\n     * into separate labels, decide whether to apply allowUnassigned and useSTD3ASCIIRules on each, \n     * and then convert. This function does not offer that level of granularity. The options once  \n     * set will apply to all labels in the domain name\n     *\n     * @param src       The input string as StringBuffer to be processed\n     * @param options   A bit set of options:\n     *  - IDNA.DEFAULT              Use default options, i.e., do not process unassigned code points\n     *                              and do not use STD3 ASCII rules\n     *                              If unassigned code points are found the operation fails with \n     *                              ParseException.\n     *\n     *  - IDNA.ALLOW_UNASSIGNED     Unassigned values can be converted to ASCII for query operations\n     *                              If this option is set, the unassigned code points are in the input \n     *                              are treated as normal Unicode code points.\n     *                          \n     *  - IDNA.USE_STD3_RULES       Use STD3 ASCII rules for host name syntax restrictions\n     *                              If this option is set and the input does not satisfy STD3 rules,  \n     *                              the operation will fail with ParseException\n     * @return StringBuffer the converted String\n     * @deprecated ICU 55 Use UTS 46 instead via {@link #getUTS46Instance(int)}.\n     * @hide original deprecated declaration\n     ",
    "links" : [ "#getUTS46Instance(int)" ]
  }, {
    "name" : "public static StringBuffer convertIDNToUnicode(String src, int options) throws StringPrepParseException",
    "returnType" : "StringBuffer",
    "comment" : "\n     * IDNA2003: Convenience function that implements the IDNToUnicode operation as defined in the IDNA RFC.\n     * This operation is done on complete domain names, e.g: \"www.example.com\". \n     *\n     * <b>Note:</b> IDNA RFC specifies that a conformant application should divide a domain name\n     * into separate labels, decide whether to apply allowUnassigned and useSTD3ASCIIRules on each, \n     * and then convert. This function does not offer that level of granularity. The options once  \n     * set will apply to all labels in the domain name\n     *\n     * @param src       The input string to be processed\n     * @param options   A bit set of options:\n     *  - IDNA.DEFAULT              Use default options, i.e., do not process unassigned code points\n     *                              and do not use STD3 ASCII rules\n     *                              If unassigned code points are found the operation fails with \n     *                              ParseException.\n     *\n     *  - IDNA.ALLOW_UNASSIGNED     Unassigned values can be converted to ASCII for query operations\n     *                              If this option is set, the unassigned code points are in the input \n     *                              are treated as normal Unicode code points.\n     *                          \n     *  - IDNA.USE_STD3_RULES       Use STD3 ASCII rules for host name syntax restrictions\n     *                              If this option is set and the input does not satisfy STD3 rules,  \n     *                              the operation will fail with ParseException\n     * @return StringBuffer the converted String\n     * @deprecated ICU 55 Use UTS 46 instead via {@link #getUTS46Instance(int)}.\n     * @hide original deprecated declaration\n     ",
    "links" : [ "#getUTS46Instance(int)" ]
  }, {
    "name" : "public static int compare(StringBuffer s1, StringBuffer s2, int options) throws StringPrepParseException",
    "returnType" : "int",
    "comment" : "\n     * IDNA2003: Compare two IDN strings for equivalence.\n     * This function splits the domain names into labels and compares them.\n     * According to IDN RFC, whenever two labels are compared, they are \n     * considered equal if and only if their ASCII forms (obtained by \n     * applying toASCII) match using an case-insensitive ASCII comparison.\n     * Two domain names are considered a match if and only if all labels \n     * match regardless of whether label separators match.\n     * \n     * @param s1        First IDN string as StringBuffer\n     * @param s2        Second IDN string as StringBuffer\n     * @param options   A bit set of options:\n     *  - IDNA.DEFAULT              Use default options, i.e., do not process unassigned code points\n     *                              and do not use STD3 ASCII rules\n     *                              If unassigned code points are found the operation fails with \n     *                              ParseException.\n     *\n     *  - IDNA.ALLOW_UNASSIGNED    Unassigned values can be converted to ASCII for query operations\n     *                              If this option is set, the unassigned code points are in the input \n     *                              are treated as normal Unicode code points.\n     *                          \n     *  - IDNA.USE_STD3_RULES      Use STD3 ASCII rules for host name syntax restrictions\n     *                              If this option is set and the input does not satisfy STD3 rules,  \n     *                              the operation will fail with ParseException\n     * @return 0 if the strings are equal, &gt; 0 if s1 &gt; s2 and &lt; 0 if s1 &lt; s2\n     * @deprecated ICU 55 Use UTS 46 instead via {@link #getUTS46Instance(int)}.\n     * @hide original deprecated declaration\n     ",
    "links" : [ "#getUTS46Instance(int)" ]
  }, {
    "name" : "public static int compare(String s1, String s2, int options) throws StringPrepParseException",
    "returnType" : "int",
    "comment" : "\n     * IDNA2003: Compare two IDN strings for equivalence.\n     * This function splits the domain names into labels and compares them.\n     * According to IDN RFC, whenever two labels are compared, they are \n     * considered equal if and only if their ASCII forms (obtained by \n     * applying toASCII) match using an case-insensitive ASCII comparison.\n     * Two domain names are considered a match if and only if all labels \n     * match regardless of whether label separators match.\n     * \n     * @param s1        First IDN string \n     * @param s2        Second IDN string\n     * @param options   A bit set of options:\n     *  - IDNA.DEFAULT              Use default options, i.e., do not process unassigned code points\n     *                              and do not use STD3 ASCII rules\n     *                              If unassigned code points are found the operation fails with \n     *                              ParseException.\n     *\n     *  - IDNA.ALLOW_UNASSIGNED    Unassigned values can be converted to ASCII for query operations\n     *                              If this option is set, the unassigned code points are in the input \n     *                              are treated as normal Unicode code points.\n     *                          \n     *  - IDNA.USE_STD3_RULES      Use STD3 ASCII rules for host name syntax restrictions\n     *                              If this option is set and the input does not satisfy STD3 rules,  \n     *                              the operation will fail with ParseException\n     * @return 0 if the strings are equal, &gt; 0 if s1 &gt; s2 and &lt; 0 if s1 &lt; s2\n     * @deprecated ICU 55 Use UTS 46 instead via {@link #getUTS46Instance(int)}.\n     * @hide original deprecated declaration\n     ",
    "links" : [ "#getUTS46Instance(int)" ]
  }, {
    "name" : "public static int compare(UCharacterIterator s1, UCharacterIterator s2, int options) throws StringPrepParseException",
    "returnType" : "int",
    "comment" : "\n     * IDNA2003: Compare two IDN strings for equivalence.\n     * This function splits the domain names into labels and compares them.\n     * According to IDN RFC, whenever two labels are compared, they are \n     * considered equal if and only if their ASCII forms (obtained by \n     * applying toASCII) match using an case-insensitive ASCII comparison.\n     * Two domain names are considered a match if and only if all labels \n     * match regardless of whether label separators match.\n     * \n     * @param s1        First IDN string as UCharacterIterator\n     * @param s2        Second IDN string as UCharacterIterator\n     * @param options   A bit set of options:\n     *  - IDNA.DEFAULT              Use default options, i.e., do not process unassigned code points\n     *                              and do not use STD3 ASCII rules\n     *                              If unassigned code points are found the operation fails with \n     *                              ParseException.\n     *\n     *  - IDNA.ALLOW_UNASSIGNED     Unassigned values can be converted to ASCII for query operations\n     *                              If this option is set, the unassigned code points are in the input \n     *                              are treated as normal Unicode code points.\n     *                          \n     *  - IDNA.USE_STD3_RULES       Use STD3 ASCII rules for host name syntax restrictions\n     *                              If this option is set and the input does not satisfy STD3 rules,  \n     *                              the operation will fail with ParseException\n     * @return 0 if the strings are equal, &gt; 0 if i1 &gt; i2 and &lt; 0 if i1 &lt; i2\n     * @deprecated ICU 55 Use UTS 46 instead via {@link #getUTS46Instance(int)}.\n     * @hide original deprecated declaration\n     ",
    "links" : [ "#getUTS46Instance(int)" ]
  } ],
  "methodNames" : [ "public static IDNA getUTS46Instance(int options)", "public abstract StringBuilder labelToASCII(CharSequence label, StringBuilder dest, Info info)", "public abstract StringBuilder labelToUnicode(CharSequence label, StringBuilder dest, Info info)", "public abstract StringBuilder nameToASCII(CharSequence name, StringBuilder dest, Info info)", "public abstract StringBuilder nameToUnicode(CharSequence name, StringBuilder dest, Info info)", "protected static void resetInfo(Info info)", "protected static boolean hasCertainErrors(Info info, EnumSet<Error> errors)", "protected static boolean hasCertainLabelErrors(Info info, EnumSet<Error> errors)", "protected static void addLabelError(Info info, Error error)", "protected static void promoteAndResetLabelErrors(Info info)", "protected static void addError(Info info, Error error)", "protected static void setTransitionalDifferent(Info info)", "protected static void setBiDi(Info info)", "protected static boolean isBiDi(Info info)", "protected static void setNotOkBiDi(Info info)", "protected static boolean isOkBiDi(Info info)", "public static StringBuffer convertToASCII(String src, int options) throws StringPrepParseException", "public static StringBuffer convertToASCII(StringBuffer src, int options) throws StringPrepParseException", "public static StringBuffer convertToASCII(UCharacterIterator src, int options) throws StringPrepParseException", "public static StringBuffer convertIDNToASCII(UCharacterIterator src, int options) throws StringPrepParseException", "public static StringBuffer convertIDNToASCII(StringBuffer src, int options) throws StringPrepParseException", "public static StringBuffer convertIDNToASCII(String src, int options) throws StringPrepParseException", "public static StringBuffer convertToUnicode(String src, int options) throws StringPrepParseException", "public static StringBuffer convertToUnicode(StringBuffer src, int options) throws StringPrepParseException", "public static StringBuffer convertToUnicode(UCharacterIterator src, int options) throws StringPrepParseException", "public static StringBuffer convertIDNToUnicode(UCharacterIterator src, int options) throws StringPrepParseException", "public static StringBuffer convertIDNToUnicode(StringBuffer src, int options) throws StringPrepParseException", "public static StringBuffer convertIDNToUnicode(String src, int options) throws StringPrepParseException", "public static int compare(StringBuffer s1, StringBuffer s2, int options) throws StringPrepParseException", "public static int compare(String s1, String s2, int options) throws StringPrepParseException", "public static int compare(UCharacterIterator s1, UCharacterIterator s2, int options) throws StringPrepParseException" ],
  "variableNames" : [ "DEFAULT", "ALLOW_UNASSIGNED", "USE_STD3_RULES", "CHECK_BIDI", "CHECK_CONTEXTJ", "NONTRANSITIONAL_TO_ASCII", "NONTRANSITIONAL_TO_UNICODE", "CHECK_CONTEXTO" ]
}