{
  "filePath" : "/home/maryam/clearblue/files/android-source-35/android/hardware/camera2/CameraCaptureSession.java",
  "packageName" : "android.hardware.camera2",
  "className" : "CaptureCallback",
  "comment" : "\n     * <p>A callback object for tracking the progress of a {@link CaptureRequest} submitted to the\n     * camera device.</p>\n     *\n     * <p>This callback is invoked when a request triggers a capture to start,\n     * and when the capture is complete. In case on an error capturing an image,\n     * the error method is triggered instead of the completion method.</p>\n     *\n     * @see #capture\n     * @see #captureBurst\n     * @see #setRepeatingRequest\n     * @see #setRepeatingBurst\n     ",
  "links" : [ "android.hardware.camera2.CaptureRequest" ],
  "variables" : [ {
    "name" : "NO_FRAMES_CAPTURED",
    "type" : "int",
    "comment" : "\n         * This constant is used to indicate that no images were captured for\n         * the request.\n         *\n         * @hide\n         ",
    "links" : [ ]
  } ],
  "methods" : [ {
    "name" : "public void onCaptureStarted(@NonNull CameraCaptureSession session, @NonNull CaptureRequest request, long timestamp, long frameNumber)",
    "returnType" : "void",
    "comment" : "\n         * This method is called when the camera device has started capturing\n         * the output image for the request, at the beginning of image exposure, or\n         * when the camera device has started processing an input image for a reprocess\n         * request.\n         *\n         * <p>For a regular capture request, this callback is invoked right as\n         * the capture of a frame begins, so it is the most appropriate time\n         * for playing a shutter sound, or triggering UI indicators of capture.</p>\n         *\n         * <p>The request that is being used for this capture is provided, along\n         * with the actual timestamp for the start of exposure. For a reprocess\n         * request, this timestamp will be the input image's start of exposure\n         * which matches {@link CaptureResult#SENSOR_TIMESTAMP the result timestamp field}\n         * of the {@link TotalCaptureResult} that was used to\n         * {@link CameraDevice#createReprocessCaptureRequest create the reprocess request}.\n         * This timestamp matches the timestamps that will be\n         * included in {@link CaptureResult#SENSOR_TIMESTAMP the result timestamp field},\n         * and in the buffers sent to each output Surface. These buffer\n         * timestamps are accessible through, for example,\n         * {@link android.media.Image#getTimestamp() Image.getTimestamp()} or\n         * {@link android.graphics.SurfaceTexture#getTimestamp()}.\n         * The frame number included is equal to the frame number that will be included in\n         * {@link CaptureResult#getFrameNumber}.</p>\n         *\n         * <p>For the simplest way to play a shutter sound camera shutter or a\n         * video recording start/stop sound, see the\n         * {@link android.media.MediaActionSound} class.</p>\n         *\n         * <p>The default implementation of this method does nothing.</p>\n         *\n         * @param session the session returned by {@link CameraDevice#createCaptureSession}\n         * @param request the request for the capture that just begun\n         * @param timestamp the timestamp at start of capture for a regular request, or\n         *                  the timestamp at the input image's start of capture for a\n         *                  reprocess request, in nanoseconds.\n         * @param frameNumber the frame number for this capture\n         *\n         * @see android.media.MediaActionSound\n         ",
    "links" : [ "android.graphics.SurfaceTexture#getTimestamp()", "android.media.Image#getTimestamp()", "android.hardware.camera2.CameraDevice#createReprocessCaptureRequest", "android.hardware.camera2.CaptureResult#getFrameNumber", "android.media.MediaActionSound", "android.hardware.camera2.CameraDevice#createCaptureSession", "android.hardware.camera2.TotalCaptureResult", "android.hardware.camera2.CaptureResult#SENSOR_TIMESTAMP" ]
  }, {
    "name" : "public void onReadoutStarted(@NonNull CameraCaptureSession session, @NonNull CaptureRequest request, long timestamp, long frameNumber)",
    "returnType" : "void",
    "comment" : "\n         * This method is called when the camera device has started reading out the output\n         * image for the request, at the beginning of the sensor image readout.\n         *\n         * <p>For a capture request, this callback is invoked right after\n         * {@link #onCaptureStarted}. Unlike {@link #onCaptureStarted}, instead of passing\n         * a timestamp of start of exposure, this callback passes a timestamp of start of\n         * camera data readout. This is useful because for a camera running at fixed frame\n         * rate, the start of readout is at fixed interval, which is not necessarily true for\n         * the start of exposure, particularly when autoexposure is changing exposure duration\n         * between frames.</p>\n         *\n         * <p>The timestamps match the timestamps of the output surfaces with readout timestamp\n         * enabled (via {@link OutputConfiguration#setReadoutTimestampEnabled}) if:</p>\n         * <ul>\n         * <li> Timestamp base is {@link OutputConfiguration#TIMESTAMP_BASE_DEFAULT} and the\n         * output\n         *   <ul>\n         *   <li> is not a SurfaceView surface, and </li>\n         *   <li> is not a MediaRecoder, MediaCodec, or ImageReader surface with {@link\n         *   android.hardware.HardwareBuffer#USAGE_VIDEO_ENCODE} usage flag or the device's {@link\n         *   CameraCharacteristics#SENSOR_INFO_TIMESTAMP_SOURCE} is {@code UNKNOWN}</li>\n         *   </ul>\n         * </li>\n         * <li> Timestamp base is {@link OutputConfiguration#TIMESTAMP_BASE_SENSOR},</li>\n         * <li> Timestamp base is {@link OutputConfiguration#TIMESTAMP_BASE_MONOTONIC} and the\n         *  device's {@link CameraCharacteristics#SENSOR_INFO_TIMESTAMP_SOURCE} is {@code\n         *  UNKNOWN},</li>\n         * <li> Timestamp base is {@link OutputConfiguration#TIMESTAMP_BASE_REALTIME} and the\n         *  device's {@link CameraCharacteristics#SENSOR_INFO_TIMESTAMP_SOURCE} is {@code REALTIME}\n         * </li>\n         * </ul>\n         * <p>Otherwise, the timestamps won't match the timestamp of the output surfaces. See\n         * the possible parameters for {@link OutputConfiguration#setTimestampBase} for details.</p>\n         *\n         * <p>This callback will be called only if {@link\n         * CameraCharacteristics#SENSOR_READOUT_TIMESTAMP} is\n         * {@link CameraMetadata#SENSOR_READOUT_TIMESTAMP_HARDWARE}, and it's called\n         * right after {@link #onCaptureStarted}.</p>\n         *\n         * @param session the session returned by {@link CameraDevice#createCaptureSession}\n         * @param request the request for the readout that just began\n         * @param timestamp the timestamp at start of readout for a regular request, or\n         *                  the timestamp at the input image's start of readout for a\n         *                  reprocess request, in nanoseconds.\n         * @param frameNumber the frame number for this capture\n         ",
    "links" : [ "#onCaptureStarted", "android.hardware.HardwareBuffer#USAGE_VIDEO_ENCODE", "android.hardware.camera2.CameraCharacteristics#SENSOR_READOUT_TIMESTAMP", "android.hardware.camera2.CameraMetadata#SENSOR_READOUT_TIMESTAMP_HARDWARE", "android.hardware.camera2.params.OutputConfiguration#setTimestampBase", "android.hardware.camera2.params.OutputConfiguration#TIMESTAMP_BASE_REALTIME", "android.hardware.camera2.CameraCharacteristics#SENSOR_INFO_TIMESTAMP_SOURCE", "android.hardware.camera2.params.OutputConfiguration#TIMESTAMP_BASE_SENSOR", "android.hardware.camera2.params.OutputConfiguration#TIMESTAMP_BASE_MONOTONIC", "android.hardware.camera2.CameraDevice#createCaptureSession", "android.hardware.camera2.params.OutputConfiguration#setReadoutTimestampEnabled", "android.hardware.camera2.params.OutputConfiguration#TIMESTAMP_BASE_DEFAULT" ]
  }, {
    "name" : "public void onCapturePartial(CameraCaptureSession session, CaptureRequest request, CaptureResult result)",
    "returnType" : "void",
    "comment" : "\n         * This method is called when some results from an image capture are\n         * available.\n         *\n         * <p>The result provided here will contain some subset of the fields of\n         * a full result. Multiple onCapturePartial calls may happen per\n         * capture; a given result field will only be present in one partial\n         * capture at most. The final onCaptureCompleted call will always\n         * contain all the fields, whether onCapturePartial was called or\n         * not.</p>\n         *\n         * <p>The default implementation of this method does nothing.</p>\n         *\n         * @param session the session returned by {@link CameraDevice#createCaptureSession}\n         * @param request The request that was given to the CameraDevice\n         * @param result The partial output metadata from the capture, which\n         * includes a subset of the CaptureResult fields.\n         *\n         * @see #capture\n         * @see #captureBurst\n         * @see #setRepeatingRequest\n         * @see #setRepeatingBurst\n         *\n         * @hide\n         ",
    "links" : [ "android.hardware.camera2.CameraDevice#createCaptureSession" ]
  }, {
    "name" : "public void onCaptureProgressed(@NonNull CameraCaptureSession session, @NonNull CaptureRequest request, @NonNull CaptureResult partialResult)",
    "returnType" : "void",
    "comment" : "\n         * This method is called when an image capture makes partial forward progress; some\n         * (but not all) results from an image capture are available.\n         *\n         * <p>The result provided here will contain some subset of the fields of\n         * a full result. Multiple {@link #onCaptureProgressed} calls may happen per\n         * capture; a given result field will only be present in one partial\n         * capture at most. The final {@link #onCaptureCompleted} call will always\n         * contain all the fields (in particular, the union of all the fields of all\n         * the partial results composing the total result).</p>\n         *\n         * <p>For each request, some result data might be available earlier than others. The typical\n         * delay between each partial result (per request) is a single frame interval.\n         * For performance-oriented use-cases, applications should query the metadata they need\n         * to make forward progress from the partial results and avoid waiting for the completed\n         * result.</p>\n         *\n         * <p>For a particular request, {@link #onCaptureProgressed} may happen before or after\n         * {@link #onCaptureStarted}.</p>\n         *\n         * <p>Each request will generate at least {@code 1} partial results, and at most\n         * {@link CameraCharacteristics#REQUEST_PARTIAL_RESULT_COUNT} partial results.</p>\n         *\n         * <p>Depending on the request settings, the number of partial results per request\n         * will vary, although typically the partial count could be the same as long as the\n         * camera device subsystems enabled stay the same.</p>\n         *\n         * <p>The default implementation of this method does nothing.</p>\n         *\n         * @param session the session returned by {@link CameraDevice#createCaptureSession}\n         * @param request The request that was given to the CameraDevice\n         * @param partialResult The partial output metadata from the capture, which\n         * includes a subset of the {@link TotalCaptureResult} fields.\n         *\n         * @see #capture\n         * @see #captureBurst\n         * @see #setRepeatingRequest\n         * @see #setRepeatingBurst\n         ",
    "links" : [ "#onCaptureCompleted", "#onCaptureStarted", "android.hardware.camera2.CameraCharacteristics#REQUEST_PARTIAL_RESULT_COUNT", "android.hardware.camera2.CameraDevice#createCaptureSession", "android.hardware.camera2.TotalCaptureResult", "#onCaptureProgressed" ]
  }, {
    "name" : "public void onCaptureCompleted(@NonNull CameraCaptureSession session, @NonNull CaptureRequest request, @NonNull TotalCaptureResult result)",
    "returnType" : "void",
    "comment" : "\n         * This method is called when an image capture has fully completed and all the\n         * result metadata is available.\n         *\n         * <p>This callback will always fire after the last {@link #onCaptureProgressed};\n         * in other words, no more partial results will be delivered once the completed result\n         * is available.</p>\n         *\n         * <p>For performance-intensive use-cases where latency is a factor, consider\n         * using {@link #onCaptureProgressed} instead.</p>\n         *\n         * <p>The default implementation of this method does nothing.</p>\n         *\n         * @param session the session returned by {@link CameraDevice#createCaptureSession}\n         * @param request The request that was given to the CameraDevice\n         * @param result The total output metadata from the capture, including the\n         * final capture parameters and the state of the camera system during\n         * capture.\n         *\n         * @see #capture\n         * @see #captureBurst\n         * @see #setRepeatingRequest\n         * @see #setRepeatingBurst\n         ",
    "links" : [ "android.hardware.camera2.CameraDevice#createCaptureSession", "#onCaptureProgressed" ]
  }, {
    "name" : "public void onCaptureFailed(@NonNull CameraCaptureSession session, @NonNull CaptureRequest request, @NonNull CaptureFailure failure)",
    "returnType" : "void",
    "comment" : "\n         * This method is called instead of {@link #onCaptureCompleted} when the\n         * camera device failed to produce a {@link CaptureResult} for the\n         * request.\n         *\n         * <p>Other requests are unaffected, and some or all image buffers from\n         * the capture may have been pushed to their respective output\n         * streams.</p>\n         *\n         * <p>If a logical multi-camera fails to generate capture result for one of\n         * its physical cameras, this method will be called with a {@link CaptureFailure}\n         * for that physical camera. In such cases, as long as the logical camera capture\n         * result is valid, {@link #onCaptureCompleted} will still be called.</p>\n         *\n         * <p>The default implementation of this method does nothing.</p>\n         *\n         * @param session\n         *            The session returned by {@link CameraDevice#createCaptureSession}\n         * @param request\n         *            The request that was given to the CameraDevice\n         * @param failure\n         *            The output failure from the capture, including the failure reason\n         *            and the frame number.\n         *\n         * @see #capture\n         * @see #captureBurst\n         * @see #setRepeatingRequest\n         * @see #setRepeatingBurst\n         ",
    "links" : [ "#onCaptureCompleted", "android.hardware.camera2.CaptureResult", "android.hardware.camera2.CaptureFailure", "android.hardware.camera2.CameraDevice#createCaptureSession" ]
  }, {
    "name" : "public void onCaptureSequenceCompleted(@NonNull CameraCaptureSession session, int sequenceId, long frameNumber)",
    "returnType" : "void",
    "comment" : "\n         * This method is called independently of the others in CaptureCallback,\n         * when a capture sequence finishes and all {@link CaptureResult}\n         * or {@link CaptureFailure} for it have been returned via this listener.\n         *\n         * <p>In total, there will be at least one result/failure returned by this listener\n         * before this callback is invoked. If the capture sequence is aborted before any\n         * requests have been processed, {@link #onCaptureSequenceAborted} is invoked instead.</p>\n         *\n         * <p>The default implementation does nothing.</p>\n         *\n         * @param session\n         *            The session returned by {@link CameraDevice#createCaptureSession}\n         * @param sequenceId\n         *            A sequence ID returned by the {@link #capture} family of functions.\n         * @param frameNumber\n         *            The last frame number (returned by {@link CaptureResult#getFrameNumber}\n         *            or {@link CaptureFailure#getFrameNumber}) in the capture sequence.\n         *\n         * @see CaptureResult#getFrameNumber()\n         * @see CaptureFailure#getFrameNumber()\n         * @see CaptureResult#getSequenceId()\n         * @see CaptureFailure#getSequenceId()\n         * @see #onCaptureSequenceAborted\n         ",
    "links" : [ "android.hardware.camera2.CaptureResult", "#onCaptureSequenceAborted", "android.hardware.camera2.CaptureFailure#getFrameNumber", "android.hardware.camera2.CaptureFailure", "android.hardware.camera2.CaptureResult#getFrameNumber", "android.hardware.camera2.CameraDevice#createCaptureSession", "#capture" ]
  }, {
    "name" : "public void onCaptureSequenceAborted(@NonNull CameraCaptureSession session, int sequenceId)",
    "returnType" : "void",
    "comment" : "\n         * This method is called independently of the others in CaptureCallback,\n         * when a capture sequence aborts before any {@link CaptureResult}\n         * or {@link CaptureFailure} for it have been returned via this listener.\n         *\n         * <p>Due to the asynchronous nature of the camera device, not all submitted captures\n         * are immediately processed. It is possible to clear out the pending requests\n         * by a variety of operations such as {@link CameraCaptureSession#stopRepeating} or\n         * {@link CameraCaptureSession#abortCaptures}. When such an event happens,\n         * {@link #onCaptureSequenceCompleted} will not be called.</p>\n         *\n         * <p>The default implementation does nothing.</p>\n         *\n         * @param session\n         *            The session returned by {@link CameraDevice#createCaptureSession}\n         * @param sequenceId\n         *            A sequence ID returned by the {@link #capture} family of functions.\n         *\n         * @see CaptureResult#getFrameNumber()\n         * @see CaptureFailure#getFrameNumber()\n         * @see CaptureResult#getSequenceId()\n         * @see CaptureFailure#getSequenceId()\n         * @see #onCaptureSequenceCompleted\n         ",
    "links" : [ "android.hardware.camera2.CameraCaptureSession#abortCaptures", "#onCaptureSequenceCompleted", "android.hardware.camera2.CaptureResult", "android.hardware.camera2.CaptureFailure", "android.hardware.camera2.CameraDevice#createCaptureSession", "android.hardware.camera2.CameraCaptureSession#stopRepeating", "#capture" ]
  }, {
    "name" : "public void onCaptureBufferLost(@NonNull CameraCaptureSession session, @NonNull CaptureRequest request, @NonNull Surface target, long frameNumber)",
    "returnType" : "void",
    "comment" : "\n         * <p>This method is called if a single buffer for a capture could not be sent to its\n         * destination surface.</p>\n         *\n         * <p>If the whole capture failed, then {@link #onCaptureFailed} will be called instead. If\n         * some but not all buffers were captured but the result metadata will not be available,\n         * then onCaptureFailed will be invoked with {@link CaptureFailure#wasImageCaptured}\n         * returning true, along with one or more calls to {@link #onCaptureBufferLost} for the\n         * failed outputs.</p>\n         *\n         * @param session\n         *            The session returned by {@link CameraDevice#createCaptureSession}\n         * @param request\n         *            The request that was given to the CameraDevice\n         * @param target\n         *            The target Surface that the buffer will not be produced for\n         * @param frameNumber\n         *            The frame number for the request\n         ",
    "links" : [ "#onCaptureBufferLost", "android.hardware.camera2.CameraDevice#createCaptureSession", "android.hardware.camera2.CaptureFailure#wasImageCaptured", "#onCaptureFailed" ]
  } ],
  "methodNames" : [ "public void onCaptureStarted(@NonNull CameraCaptureSession session, @NonNull CaptureRequest request, long timestamp, long frameNumber)", "public void onReadoutStarted(@NonNull CameraCaptureSession session, @NonNull CaptureRequest request, long timestamp, long frameNumber)", "public void onCapturePartial(CameraCaptureSession session, CaptureRequest request, CaptureResult result)", "public void onCaptureProgressed(@NonNull CameraCaptureSession session, @NonNull CaptureRequest request, @NonNull CaptureResult partialResult)", "public void onCaptureCompleted(@NonNull CameraCaptureSession session, @NonNull CaptureRequest request, @NonNull TotalCaptureResult result)", "public void onCaptureFailed(@NonNull CameraCaptureSession session, @NonNull CaptureRequest request, @NonNull CaptureFailure failure)", "public void onCaptureSequenceCompleted(@NonNull CameraCaptureSession session, int sequenceId, long frameNumber)", "public void onCaptureSequenceAborted(@NonNull CameraCaptureSession session, int sequenceId)", "public void onCaptureBufferLost(@NonNull CameraCaptureSession session, @NonNull CaptureRequest request, @NonNull Surface target, long frameNumber)" ],
  "variableNames" : [ "NO_FRAMES_CAPTURED" ]
}