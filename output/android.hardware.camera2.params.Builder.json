{
  "filePath" : "/home/maryam/clearblue/files/android-source-30/android/hardware/camera2/params/MandatoryStreamCombination.java",
  "packageName" : "android.hardware.camera2.params",
  "className" : "Builder",
  "comment" : "\n     * Helper builder class to generate a list of available mandatory stream combinations.\n     * @hide\n     ",
  "variables" : [ {
    "name" : "mDisplaySize",
    "type" : "Size",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mCapabilities",
    "type" : "List<Integer>",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mHwLevel",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mCameraId",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mStreamConfigMap",
    "type" : "StreamConfigurationMap",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mIsHiddenPhysicalCamera",
    "type" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "kPreviewSizeBound",
    "type" : "Size",
    "comment" : "",
    "links" : [ ]
  } ],
  "methods" : [ {
    "name" : "public List<MandatoryStreamCombination> getAvailableMandatoryConcurrentStreamCombinations()",
    "returnType" : "List<MandatoryStreamCombination>",
    "comment" : "\n          * Retrieve a list of all available mandatory concurrent stream combinations.\n          * This method should only be called for devices which are listed in combinations returned\n          * by CameraManager.getConcurrentCameraIds.\n          *\n          * @return a non-modifiable list of supported mandatory concurrent stream combinations.\n          ",
    "links" : [ ]
  }, {
    "name" : "public List<MandatoryStreamCombination> getAvailableMandatoryStreamCombinations()",
    "returnType" : "List<MandatoryStreamCombination>",
    "comment" : "\n         * Retrieve a list of all available mandatory stream combinations.\n         *\n         * @return a non-modifiable list of supported mandatory stream combinations or\n         *         null in case device is not backward compatible or the method encounters\n         *         an error.\n         ",
    "links" : [ ]
  }, {
    "name" : "private List<MandatoryStreamCombination> generateAvailableCombinations(@NonNull ArrayList<StreamCombinationTemplate> availableTemplates)",
    "returnType" : "List<MandatoryStreamCombination>",
    "comment" : "\n         * Helper method to generate the available stream combinations given the\n         * list of available combination templates.\n         *\n         * @param availableTemplates a list of templates supported by the camera device.\n         * @return a non-modifiable list of supported mandatory stream combinations or\n         *         null in case of errors.\n         ",
    "links" : [ ]
  }, {
    "name" : "private HashMap<Pair<SizeThreshold, Integer>, List<Size>> enumerateAvailableSizes()",
    "returnType" : "HashMap<Pair<SizeThreshold, Integer>, List<Size>>",
    "comment" : "\n         * Helper method to enumerate all available sizes according to size threshold and format.\n         ",
    "links" : [ ]
  }, {
    "name" : "private static List<Size> getSizesWithinBound(@NonNull Size[] sizes, @NonNull Size bound)",
    "returnType" : "List<Size>",
    "comment" : "\n         * Compile a list of sizes smaller than or equal to given bound.\n         * Return an empty list if there is no size smaller than or equal to the bound.\n         ",
    "links" : [ ]
  }, {
    "name" : "public static Size getMinSize(Size a, Size b)",
    "returnType" : "Size",
    "comment" : "\n         * Return the lower size\n         ",
    "links" : [ ]
  }, {
    "name" : "public static Size getMaxSize(@NonNull Size... sizes)",
    "returnType" : "Size",
    "comment" : "\n         * Get the largest size by area.\n         *\n         * @param sizes an array of sizes, must have at least 1 element\n         *\n         * @return Largest Size\n         *\n         * @throws IllegalArgumentException if sizes was null or had 0 elements\n         ",
    "links" : [ ]
  }, {
    "name" : "private boolean isHardwareLevelAtLeast(int level)",
    "returnType" : "boolean",
    "comment" : "\n         * Whether or not the hardware level reported by android.info.supportedHardwareLevel is\n         * at least the desired one (but could be higher)\n         ",
    "links" : [ ]
  }, {
    "name" : "private boolean isExternalCamera()",
    "returnType" : "boolean",
    "comment" : "\n         * Whether or not the camera is an external camera.\n         *\n         * @return {@code true} if the device is external, {@code false} otherwise.\n         ",
    "links" : [ ]
  }, {
    "name" : "private boolean isHardwareLevelAtLeastLegacy()",
    "returnType" : "boolean",
    "comment" : "\n         * Whether or not the hardware level is at least legacy.\n         *\n         * @return {@code true} if the device is {@code LEGACY}, {@code false} otherwise.\n         ",
    "links" : [ ]
  }, {
    "name" : "private boolean isHardwareLevelAtLeastLimited()",
    "returnType" : "boolean",
    "comment" : "\n         * Whether or not the hardware level is at least limited.\n         *\n         * @return {@code true} if the device is {@code LIMITED} or {@code FULL},\n         *         {@code false} otherwise (i.e. LEGACY).\n         ",
    "links" : [ ]
  }, {
    "name" : "private boolean isHardwareLevelAtLeastFull()",
    "returnType" : "boolean",
    "comment" : "\n         * Whether or not the hardware level is at least full.\n         *\n         * @return {@code true} if the device is {@code FULL}, {@code false} otherwise.\n         ",
    "links" : [ ]
  }, {
    "name" : "private boolean isHardwareLevelAtLeastLevel3()",
    "returnType" : "boolean",
    "comment" : "\n         * Whether or not the hardware level is at least Level 3.\n         *\n         * @return {@code true} if the device is {@code LEVEL3}, {@code false} otherwise.\n         ",
    "links" : [ ]
  }, {
    "name" : "private boolean isCapabilitySupported(int capability)",
    "returnType" : "boolean",
    "comment" : "\n         * Determine whether the current device supports a capability or not.\n         *\n         * @param capability (non-negative)\n         *\n         * @return {@code true} if the capability is supported, {@code false} otherwise.\n         *\n         ",
    "links" : [ ]
  }, {
    "name" : "private boolean isColorOutputSupported()",
    "returnType" : "boolean",
    "comment" : "\n         * Check whether the current device is backward compatible.\n         ",
    "links" : [ ]
  }, {
    "name" : "private boolean isPrivateReprocessingSupported()",
    "returnType" : "boolean",
    "comment" : "\n         * Check whether the current device supports private reprocessing.\n         ",
    "links" : [ ]
  }, {
    "name" : "private boolean isYUVReprocessingSupported()",
    "returnType" : "boolean",
    "comment" : "\n         * Check whether the current device supports YUV reprocessing.\n         ",
    "links" : [ ]
  }, {
    "name" : "private Size getMaxRecordingSize()",
    "returnType" : "Size",
    "comment" : "\n         * Return the maximum supported video size using the camcorder profile information.\n         *\n         * @return Maximum supported video size.\n         ",
    "links" : [ ]
  }, {
    "name" : "private Size getMaxCameraRecordingSize()",
    "returnType" : "Size",
    "comment" : "\n         * Return the maximum supported video size for cameras using data from\n         * the stream configuration map.\n         *\n         * @return Maximum supported video size.\n         ",
    "links" : [ ]
  }, {
    "name" : "private Size getMaxPreviewSize(List<Size> orderedPreviewSizes)",
    "returnType" : "Size",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private static int compareSizes(int widthA, int heightA, int widthB, int heightB)",
    "returnType" : "int",
    "comment" : "\n         * Size comparison method used by size comparators.\n         ",
    "links" : [ ]
  }, {
    "name" : "private static List<Size> getAscendingOrderSizes(@NonNull final List<Size> sizeList, boolean ascending)",
    "returnType" : "List<Size>",
    "comment" : "\n         * Get a sorted list of sizes from a given size list.\n         *\n         * <p>\n         * The size is compare by area it covers, if the areas are same, then\n         * compare the widths.\n         * </p>\n         *\n         * @param sizeList The input size list to be sorted\n         * @param ascending True if the order is ascending, otherwise descending order\n         * @return The ordered list of sizes\n         ",
    "links" : [ ]
  } ],
  "variableNames" : [ "mDisplaySize", "mCapabilities", "mHwLevel", "mCameraId", "mStreamConfigMap", "mIsHiddenPhysicalCamera", "kPreviewSizeBound" ],
  "methodNames" : [ "public List<MandatoryStreamCombination> getAvailableMandatoryConcurrentStreamCombinations()", "public List<MandatoryStreamCombination> getAvailableMandatoryStreamCombinations()", "private List<MandatoryStreamCombination> generateAvailableCombinations(@NonNull ArrayList<StreamCombinationTemplate> availableTemplates)", "private HashMap<Pair<SizeThreshold, Integer>, List<Size>> enumerateAvailableSizes()", "private static List<Size> getSizesWithinBound(@NonNull Size[] sizes, @NonNull Size bound)", "public static Size getMinSize(Size a, Size b)", "public static Size getMaxSize(@NonNull Size... sizes)", "private boolean isHardwareLevelAtLeast(int level)", "private boolean isExternalCamera()", "private boolean isHardwareLevelAtLeastLegacy()", "private boolean isHardwareLevelAtLeastLimited()", "private boolean isHardwareLevelAtLeastFull()", "private boolean isHardwareLevelAtLeastLevel3()", "private boolean isCapabilitySupported(int capability)", "private boolean isColorOutputSupported()", "private boolean isPrivateReprocessingSupported()", "private boolean isYUVReprocessingSupported()", "private Size getMaxRecordingSize()", "private Size getMaxCameraRecordingSize()", "private Size getMaxPreviewSize(List<Size> orderedPreviewSizes)", "private static int compareSizes(int widthA, int heightA, int widthB, int heightB)", "private static List<Size> getAscendingOrderSizes(@NonNull final List<Size> sizeList, boolean ascending)" ]
}