{
  "filePath" : "/home/maryam/clearblue/files/android-source-35/org/xml/sax/ext/EntityResolver2.java",
  "packageName" : "org.xml.sax.ext",
  "className" : "EntityResolver2",
  "comment" : "\n * Extended interface for mapping external entity references to input\n * sources, or providing a missing external subset.  The\n * {@link XMLReader#setEntityResolver XMLReader.setEntityResolver()} method\n * is used to provide implementations of this interface to parsers.\n * When a parser uses the methods in this interface, the\n * {@link EntityResolver2#resolveEntity EntityResolver2.resolveEntity()}\n * method (in this interface) is used <em>instead of</em> the older (SAX 1.0)\n * {@link EntityResolver#resolveEntity EntityResolver.resolveEntity()} method.\n *\n * <blockquote>\n * <em>This module, both source code and documentation, is in the\n * Public Domain, and comes with <strong>NO WARRANTY</strong>.</em>\n * </blockquote>\n *\n * <p>If a SAX application requires the customized handling which this\n * interface defines for external entities, it must ensure that it uses\n * an XMLReader with the\n * <em>http://xml.org/sax/features/use-entity-resolver2</em> feature flag\n * set to <em>true</em> (which is its default value when the feature is\n * recognized).  If that flag is unrecognized, or its value is false,\n * or the resolver does not implement this interface, then only the\n * {@link EntityResolver} method will be used.\n * </p>\n *\n * <p>That supports three categories of application that modify entity\n * resolution.  <em>Old Style</em> applications won't know about this interface;\n * they will provide an EntityResolver.\n * <em>Transitional Mode</em> provide an EntityResolver2 and automatically\n * get the benefit of its methods in any systems (parsers or other tools)\n * supporting it, due to polymorphism.\n * Both <em>Old Style</em> and <em>Transitional Mode</em> applications will\n * work with any SAX2 parser.\n * <em>New style</em> applications will fail to run except on SAX2 parsers\n * that support this particular feature.\n * They will insist that feature flag have a value of \"true\", and the\n * EntityResolver2 implementation they provide  might throw an exception\n * if the original SAX 1.0 style entity resolution method is invoked.\n * </p>\n *\n * @see org.xml.sax.XMLReader#setEntityResolver\n *\n * @since SAX 2.0 (extensions 1.1 alpha)\n * @author David Brownell\n * @version TBD\n ",
  "links" : [ "org.xml.sax.ext.EntityResolver2#resolveEntity", "org.xml.sax.XMLReader#setEntityResolver", "org.xml.sax.EntityResolver#resolveEntity", "org.xml.sax.EntityResolver" ],
  "variables" : [ ],
  "methods" : [ {
    "name" : "public InputSource getExternalSubset(String name, String baseURI) throws SAXException, IOException",
    "returnType" : "InputSource",
    "comment" : "\n     * Allows applications to provide an external subset for documents\n     * that don't explicitly define one.  Documents with DOCTYPE declarations\n     * that omit an external subset can thus augment the declarations\n     * available for validation, entity processing, and attribute processing\n     * (normalization, defaulting, and reporting types including ID).\n     * This augmentation is reported\n     * through the {@link LexicalHandler#startDTD startDTD()} method as if\n     * the document text had originally included the external subset;\n     * this callback is made before any internal subset data or errors\n     * are reported.</p>\n     *\n     * <p>This method can also be used with documents that have no DOCTYPE\n     * declaration.  When the root element is encountered,\n     * but no DOCTYPE declaration has been seen, this method is\n     * invoked.  If it returns a value for the external subset, that root\n     * element is declared to be the root element, giving the effect of\n     * splicing a DOCTYPE declaration at the end the prolog of a document\n     * that could not otherwise be valid.  The sequence of parser callbacks\n     * in that case logically resembles this:</p>\n     *\n     * <pre>\n     * ... comments and PIs from the prolog (as usual)\n     * startDTD (\"rootName\", source.getPublicId (), source.getSystemId ());\n     * startEntity (\"[dtd]\");\n     * ... declarations, comments, and PIs from the external subset\n     * endEntity (\"[dtd]\");\n     * endDTD ();\n     * ... then the rest of the document (as usual)\n     * startElement (..., \"rootName\", ...);\n     * </pre>\n     *\n     * <p>Note that the InputSource gets no further resolution.\n     * Implementations of this method may wish to invoke\n     * {@link #resolveEntity resolveEntity()} to gain benefits such as use\n     * of local caches of DTD entities.  Also, this method will never be\n     * used by a (non-validating) processor that is not including external\n     * parameter entities. </p>\n     *\n     * <p>Uses for this method include facilitating data validation when\n     * interoperating with XML processors that would always require\n     * undesirable network accesses for external entities, or which for\n     * other reasons adopt a \"no DTDs\" policy.\n     * Non-validation motives include forcing documents to include DTDs so\n     * that attributes are handled consistently.\n     * For example, an XPath processor needs to know which attibutes have\n     * type \"ID\" before it can process a widely used type of reference.</p>\n     *\n     * <p><strong>Warning:</strong> Returning an external subset modifies\n     * the input document.  By providing definitions for general entities,\n     * it can make a malformed document appear to be well formed.\n     * </p>\n     *\n     * @param name Identifies the document root element.  This name comes\n     *    from a DOCTYPE declaration (where available) or from the actual\n     *    root element.\n     * @param baseURI The document's base URI, serving as an additional\n     *    hint for selecting the external subset.  This is always an absolute\n     *    URI, unless it is null because the XMLReader was given an InputSource\n     *    without one.\n     *\n     * @return An InputSource object describing the new external subset\n     *    to be used by the parser, or null to indicate that no external\n     *    subset is provided.\n     *\n     * @exception SAXException Any SAX exception, possibly wrapping\n     *    another exception.\n     * @exception IOException Probably indicating a failure to create\n     *    a new InputStream or Reader, or an illegal URL.\n     ",
    "links" : [ "org.xml.sax.ext.LexicalHandler#startDTD", "#resolveEntity" ]
  }, {
    "name" : "public InputSource resolveEntity(String name, String publicId, String baseURI, String systemId) throws SAXException, IOException",
    "returnType" : "InputSource",
    "comment" : "\n     * Allows applications to map references to external entities into input\n     * sources, or tell the parser it should use conventional URI resolution.\n     * This method is only called for external entities which have been\n     * properly declared.\n     * This method provides more flexibility than the {@link EntityResolver}\n     * interface, supporting implementations of more complex catalogue\n     * schemes such as the one defined by the <a href=\n    \"http://www.oasis-open.org/committees/entity/spec-2001-08-06.html\"\n    >OASIS XML Catalogs</a> specification.</p>\n     *\n     * <p>Parsers configured to use this resolver method will call it\n     * to determine the input source to use for any external entity\n     * being included because of a reference in the XML text.\n     * That excludes the document entity, and any external entity returned\n     * by {@link #getExternalSubset getExternalSubset()}.\n     * When a (non-validating) processor is configured not to include\n     * a class of entities (parameter or general) through use of feature\n     * flags, this method is not invoked for such entities.  </p>\n     *\n     * <p>Note that the entity naming scheme used here is the same one\n     * used in the {@link LexicalHandler}, or in the {@link\n    org.xml.sax.ContentHandler#skippedEntity\n    ContentHandler.skippedEntity()}\n     * method. </p>\n     *\n     * @param name Identifies the external entity being resolved.\n     *    Either \"[dtd]\" for the external subset, or a name starting\n     *    with \"%\" to indicate a parameter entity, or else the name of\n     *    a general entity.  This is never null when invoked by a SAX2\n     *    parser.\n     * @param publicId The public identifier of the external entity being\n     *    referenced (normalized as required by the XML specification), or\n     *    null if none was supplied.\n     * @param baseURI The URI with respect to which relative systemIDs\n     *    are interpreted.  This is always an absolute URI, unless it is\n     *    null (likely because the XMLReader was given an InputSource without\n     *  one).  This URI is defined by the XML specification to be the one\n     *    associated with the \"&lt;\" starting the relevant declaration.\n     * @param systemId The system identifier of the external entity\n     *    being referenced; either a relative or absolute URI.\n     *  This is never null when invoked by a SAX2 parser; only declared\n     *    entities, and any external subset, are resolved by such parsers.\n     *\n     * @return An InputSource object describing the new input source to\n     *    be used by the parser.  Returning null directs the parser to\n     *    resolve the system ID against the base URI and open a connection\n     *    to resulting URI.\n     *\n     * @exception SAXException Any SAX exception, possibly wrapping\n     *    another exception.\n     * @exception IOException Probably indicating a failure to create\n     *    a new InputStream or Reader, or an illegal URL.\n     ",
    "links" : [ "org.xml.sax.ext.LexicalHandler", "org.xml.sax.ContentHandler#skippedEntityContentHandler.skippedEntity()", "org.xml.sax.EntityResolver", "#getExternalSubset" ]
  } ],
  "methodNames" : [ "public InputSource getExternalSubset(String name, String baseURI) throws SAXException, IOException", "public InputSource resolveEntity(String name, String publicId, String baseURI, String systemId) throws SAXException, IOException" ],
  "variableNames" : [ ]
}