{
  "filePath" : "/home/maryam/clearblue/files/android-source-35/android/hardware/biometrics/fingerprint/ISession.java",
  "packageName" : "android.hardware.biometrics.fingerprint",
  "className" : "ISession",
  "comment" : "\n * Operations defined within this interface can be split into the following categories:\n *   1) Non-interrupting operations. These operations are handled by the HAL in a FIFO order.\n *     1a) Cancellable operations. These operations can usually run for several minutes. To allow\n *         for cancellation, they return an instance of ICancellationSignal that allows the\n *         framework to cancel them by calling ICancellationSignal#cancel. If such an operation is\n *         cancelled, it must notify the framework by calling ISessionCallback#onError with\n *         Error::CANCELED.\n *     1b) Non-cancellable operations. Such operations cannot be cancelled once started.\n *   2) Interrupting operations. These operations may be invoked by the framework immediately,\n *      regardless of whether another operation is executing. For example, on devices with sensors\n *      of FingerprintSensorType::UNDER_DISPLAY_*, ISession#onPointerDown may be invoked while the\n *      HAL is executing ISession#enroll, ISession#authenticate or ISession#detectInteraction.\n * \n * The lifecycle of a non-interrupting operation ends when one of its final callbacks is called.\n * For example, ISession#authenticate is considered completed when either ISessionCallback#onError\n * or ISessionCallback#onAuthenticationSucceeded is called.\n * \n * The lifecycle of an interrupting operation ends when it returns. Interrupting operations do not\n * have callbacks.\n * \n * ISession only supports execution of one non-interrupting operation at a time, regardless of\n * whether it's cancellable. The framework must wait for a callback indicating the end of the\n * current non-interrupting operation before a new non-interrupting operation can be started.\n * @hide\n ",
  "links" : [ ],
  "variables" : [ {
    "name" : "VERSION",
    "type" : "int",
    "comment" : "\n   * The version of this interface that the caller is built against.\n   * This might be different from what {@link #getInterfaceVersion()\n   * getInterfaceVersion} returns as that is the version of the interface\n   * that the remote object is implementing.\n   ",
    "links" : [ "#getInterfaceVersion()" ]
  }, {
    "name" : "HASH",
    "type" : "String",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "DESCRIPTOR",
    "type" : "java.lang.String",
    "comment" : " @hide ",
    "links" : [ ]
  } ],
  "methods" : [ {
    "name" : "public void generateChallenge() throws android.os.RemoteException",
    "returnType" : "void",
    "comment" : "\n   * generateChallenge:\n   * \n   * Begins a secure transaction request. Note that the challenge by itself is not useful. It only\n   * becomes useful when wrapped in a verifiable message such as a HardwareAuthToken.\n   * \n   * Canonical example:\n   *   1) User requests an operation, such as fingerprint enrollment.\n   *   2) Fingerprint enrollment cannot happen until the user confirms their lockscreen credential\n   *      (PIN/Pattern/Password).\n   *   3) However, the biometric subsystem does not want just \"any\" proof of credential\n   *      confirmation. It needs proof that the user explicitly authenticated credential in order\n   *      to allow addition of biometric enrollments.\n   * To secure this path, the following path is taken:\n   *   1) Upon user requesting fingerprint enroll, the framework requests\n   *      ISession#generateChallenge\n   *   2) Framework sends the challenge to the credential subsystem, and upon credential\n   *      confirmation, a HAT is created, containing the challenge in the \"challenge\" field.\n   *   3) Framework sends the HAT to the HAL, e.g. ISession#enroll.\n   *   4) Implementation verifies the authenticity and integrity of the HAT.\n   *   5) Implementation now has confidence that the user entered their credential to allow\n   *      biometric enrollment.\n   * \n   * Note that this interface allows multiple in-flight challenges. Invoking generateChallenge\n   * twice does not invalidate the first challenge. The challenge is invalidated only when:\n   *   1) Its lifespan exceeds the HAL's internal challenge timeout\n   *   2) IFingerprint#revokeChallenge is invoked\n   * \n   * For example, the following is a possible table of valid challenges:\n   * ----------------------------------------------\n   * | SensorId | UserId | ValidUntil | Challenge |\n   * |----------|--------|------------|-----------|\n   * | 0        | 0      | <Time1>    | <Random1> |\n   * | 0        | 0      | <Time2>    | <Random2> |\n   * | 1        | 0      | <Time3>    | <Random3> |\n   * | 0        | 10     | <Time4>    | <Random4> |\n   * ----------------------------------------------\n   * \n   * Callbacks that signify the end of this operation's lifecycle:\n   *   - ISessionCallback#onChallengeGenerated\n   ",
    "links" : [ ]
  }, {
    "name" : "public void revokeChallenge(long challenge) throws android.os.RemoteException",
    "returnType" : "void",
    "comment" : "\n   * revokeChallenge:\n   * \n   * Revokes a challenge that was previously generated. Note that if a non-existent challenge is\n   * provided, the HAL must still notify the framework using ISessionCallback#onChallengeRevoked.\n   * \n   * Callbacks that signify the end of this operation's lifecycle:\n   *   - ISessionCallback#onChallengeRevoked\n   * \n   * @param challenge Challenge that should be revoked.\n   ",
    "links" : [ ]
  }, {
    "name" : "public android.hardware.biometrics.common.ICancellationSignal enroll(android.hardware.keymaster.HardwareAuthToken hat) throws android.os.RemoteException",
    "returnType" : "android.hardware.biometrics.common.ICancellationSignal",
    "comment" : "\n   * enroll:\n   * \n   * A request to add a fingerprint enrollment.\n   * \n   * At any point during enrollment, if a non-recoverable error occurs, the HAL must notify the\n   * framework via ISessionCallback#onError with the applicable enrollment-specific error.\n   * \n   * Before capturing fingerprint data, the HAL must first verify the authenticity and integrity\n   * of the provided HardwareAuthToken. In addition, it must check that the challenge within the\n   * provided HardwareAuthToken is valid. See ISession#generateChallenge. If any of the above\n   * checks fail, the framework must be notified using ISessionCallback#onError with\n   * Error::UNABLE_TO_PROCESS.\n   * \n   * During enrollment, the HAL may notify the framework via ISessionCallback#onAcquired with\n   * messages that may be used to guide the user. This callback can be invoked multiple times if\n   * necessary. Similarly, the framework may be notified of enrollment progress changes via\n   * ISessionCallback#onEnrollmentProgress. Once the framework is notified that there are 0\n   * \"remaining\" steps, the framework may cache the \"enrollmentId\". See\n   * ISessionCallback#onEnrollmentProgress for more info.\n   * \n   * When a finger is successfully added and before the framework is notified of remaining=0, the\n   * HAL must update and associate this (sensorId, userId) pair with a new entropy-encoded random\n   * identifier. See ISession#getAuthenticatorId for more information.\n   * \n   * Callbacks that signify the end of this operation's lifecycle:\n   *   - ISessionCallback#onError\n   *   - ISessionCallback#onEnrollmentProgress(enrollmentId, remaining=0)\n   * \n   * Other applicable callbacks:\n   *   - ISessionCallback#onAcquired\n   * \n   * @param hat See above documentation.\n   * @return ICancellationSignal An object that can be used by the framework to cancel this\n   *                             operation.\n   ",
    "links" : [ ]
  }, {
    "name" : "public android.hardware.biometrics.common.ICancellationSignal authenticate(long operationId) throws android.os.RemoteException",
    "returnType" : "android.hardware.biometrics.common.ICancellationSignal",
    "comment" : "\n   * authenticate:\n   * \n   * A request to start looking for fingerprints to authenticate.\n   * \n   * At any point during authentication, if a non-recoverable error occurs, the HAL must notify\n   * the framework via ISessionCallback#onError with the applicable authentication-specific error.\n   * \n   * During authentication, the HAL may notify the framework via ISessionCallback#onAcquired with\n   * messages that may be used to guide the user. This callback can be invoked multiple times if\n   * necessary.\n   * \n   * The HAL must notify the framework of accepts and rejects via\n   * ISessionCallback#onAuthenticationSucceeded and ISessionCallback#onAuthenticationFailed,\n   * correspondingly.\n   * \n   * The authentication lifecycle ends when either:\n   *   1) A fingerprint is accepted, and ISessionCallback#onAuthenticationSucceeded is invoked.\n   *   2) Any non-recoverable error occurs (such as lockout). See the full list of\n   *      authentication-specific errors in the Error enum.\n   * \n   * Note that upon successful authentication, the lockout counter for this (sensorId, userId)\n   * pair must be cleared.\n   * \n   * Note that upon successful authentication, ONLY sensors configured as SensorStrength::STRONG\n   * are allowed to create and send a HardwareAuthToken to the framework. See the Android CDD for\n   * more details. For SensorStrength::STRONG sensors, the HardwareAuthToken's \"challenge\" field\n   * must be set with the operationId passed in during #authenticate. If the sensor is NOT\n   * SensorStrength::STRONG, the HardwareAuthToken MUST be null.\n   * \n   * Callbacks that signify the end of this operation's lifecycle:\n   *   - ISessionCallback#onError\n   *   - ISessionCallback#onAuthenticationSucceeded\n   * \n   * Other applicable callbacks:\n   *   - ISessionCallback#onAcquired\n   *   - ISessionCallback#onAuthenticationFailed\n   *   - ISessionCallback#onLockoutTimed\n   *   - ISessionCallback#onLockoutPermanent\n   * \n   * @param operationId For sensors configured as SensorStrength::STRONG, this must be used ONLY\n   *                    upon successful authentication and wrapped in the HardwareAuthToken's\n   *                    \"challenge\" field and sent to the framework via\n   *                    ISessionCallback#onAuthenticationSucceeded. The operationId is an opaque\n   *                    identifier created from a separate secure subsystem such as, but not\n   *                    limited to KeyStore/KeyMaster. The HardwareAuthToken can then be used as\n   *                    an attestation for the provided operation. For example, this is used to\n   *                    unlock biometric-bound auth-per-use keys (see\n   *                    setUserAuthenticationParameters in KeyGenParameterSpec.Builder and\n   *                    KeyProtection.Builder).\n   * @return ICancellationSignal An object that can be used by the framework to cancel this\n   * operation.\n   ",
    "links" : [ ]
  }, {
    "name" : "public android.hardware.biometrics.common.ICancellationSignal detectInteraction() throws android.os.RemoteException",
    "returnType" : "android.hardware.biometrics.common.ICancellationSignal",
    "comment" : "\n   * detectInteraction:\n   * \n   * A request to start looking for fingerprints without performing matching. Must only be called\n   * if SensorProps#supportsDetectInteraction is true. If invoked on HALs that do not support this\n   * functionality, the HAL must respond with ISession#onError(UNABLE_TO_PROCESS, 0).\n   * \n   * The framework will use this operation in cases where determining user presence is required,\n   * but identifying/authenticating is not. For example, when the device is encrypted (first boot)\n   * or in lockdown mode.\n   * \n   * At any point during detectInteraction, if a non-recoverable error occurs, the HAL must notify\n   * the framework via ISessionCallback#onError with the applicable error.\n   * \n   * The HAL must only check whether a fingerprint-like image was detected (e.g. to minimize\n   * interactions due to non-fingerprint objects), and the lockout counter must not be modified.\n   * \n   * Upon detecting any fingerprint, the HAL must invoke ISessionCallback#onInteractionDetected.\n   * \n   * The lifecycle of this operation ends when either:\n   * 1) Any fingerprint is detected and the framework is notified via\n   *    ISessionCallback#onInteractionDetected.\n   * 2) An error occurs, for example Error::TIMEOUT.\n   * \n   * Note that if the operation is canceled, the HAL must notify the framework via\n   * ISessionCallback#onError with Error::CANCELED.\n   * \n   * Callbacks that signify the end of this operation's lifecycle:\n   *   - ISessionCallback#onError\n   *   - ISessionCallback#onInteractionDetected\n   * \n   * Other applicable callbacks:\n   *   - ISessionCallback#onAcquired\n   * \n   * @return ICancellationSignal An object that can be used by the framework to cancel this\n   *                             operation.\n   ",
    "links" : [ ]
  }, {
    "name" : "public void enumerateEnrollments() throws android.os.RemoteException",
    "returnType" : "void",
    "comment" : "\n   * enumerateEnrollments:\n   * \n   * A request to enumerate (list) the enrollments for this (sensorId, userId) pair. The framework\n   * typically uses this to ensure that its cache is in sync with the HAL.\n   * \n   * The HAL must then notify the framework with a list of enrollments applicable for the current\n   * session via ISessionCallback#onEnrollmentsEnumerated.\n   * \n   * Callbacks that signify the end of this operation's lifecycle:\n   *   - ISessionCallback#onEnrollmentsEnumerated\n   ",
    "links" : [ ]
  }, {
    "name" : "public void removeEnrollments(int[] enrollmentIds) throws android.os.RemoteException",
    "returnType" : "void",
    "comment" : "\n   * removeEnrollments:\n   * \n   * A request to remove the enrollments for this (sensorId, userId) pair.\n   * \n   * After removing the enrollmentIds from everywhere necessary (filesystem, secure subsystems,\n   * etc), the HAL must notify the framework via ISessionCallback#onEnrollmentsRemoved.\n   * \n   * Callbacks that signify the end of this operation's lifecycle:\n   *   - ISessionCallback#onEnrollmentsRemoved\n   * \n   * @param enrollmentIds a list of enrollments that should be removed.\n   ",
    "links" : [ ]
  }, {
    "name" : "public void getAuthenticatorId() throws android.os.RemoteException",
    "returnType" : "void",
    "comment" : "\n   * getAuthenticatorId:\n   * \n   * MUST return 0 via ISessionCallback#onAuthenticatorIdRetrieved for sensors that are configured\n   * as SensorStrength::WEAK or SensorStrength::CONVENIENCE.\n   * \n   * The following only applies to sensors that are configured as SensorStrength::STRONG.\n   * \n   * The authenticatorId is a (sensorId, user)-specific identifier which can be used during key\n   * generation and import to associate the key (in KeyStore / KeyMaster) with the current set of\n   * enrolled fingerprints. For example, the following public Android APIs allow for keys to be\n   * invalidated when the user adds a new enrollment after the key was created:\n   * KeyGenParameterSpec.Builder.setInvalidatedByBiometricEnrollment and\n   * KeyProtection.Builder.setInvalidatedByBiometricEnrollment.\n   * \n   * In addition, upon successful fingerprint authentication, the signed HAT that is returned to\n   * the framework via ISessionCallback#onAuthenticationSucceeded must contain this identifier in\n   * the authenticatorId field.\n   * \n   * Returns an entropy-encoded random identifier associated with the current set of enrollments\n   * via ISessionCallback#onAuthenticatorIdRetrieved. The authenticatorId\n   *   1) MUST change whenever a new fingerprint is enrolled\n   *   2) MUST return 0 if no fingerprints are enrolled\n   *   3) MUST not change if a fingerprint is deleted.\n   *   4) MUST be an entropy-encoded random number\n   * \n   * Callbacks that signify the end of this operation's lifecycle:\n   *   - ISessionCallback#onAuthenticatorIdRetrieved\n   ",
    "links" : [ ]
  }, {
    "name" : "public void invalidateAuthenticatorId() throws android.os.RemoteException",
    "returnType" : "void",
    "comment" : "\n   * invalidateAuthenticatorId:\n   * \n   * This operation only applies to sensors that are configured as SensorStrength::STRONG. If\n   * invoked by the framework for sensors of other strengths, the HAL should immediately invoke\n   * ISessionCallback#onAuthenticatorIdInvalidated.\n   * \n   * The following only applies to sensors that are configured as SensorStrength::STRONG.\n   * \n   * When invoked by the framework, the HAL must perform the following sequence of events:\n   *   1) Update the authenticatorId with a new entropy-encoded random number\n   *   2) Persist the new authenticatorId to non-ephemeral storage\n   *   3) Notify the framework that the above is completed, via\n   *      ISessionCallback#onAuthenticatorInvalidated\n   * \n   * A practical use case of invalidation would be when the user adds a new enrollment to a sensor\n   * managed by a different HAL instance. The public android.security.keystore APIs bind keys to\n   * \"all biometrics\" rather than \"fingerprint-only\" or \"face-only\" (see #getAuthenticatorId for\n   * more details). As such, the framework would coordinate invalidation across multiple biometric\n   * HALs as necessary.\n   * \n   * Callbacks that signify the end of this operation's lifecycle:\n   *   - ISessionCallback#onAuthenticatorIdInvalidated\n   ",
    "links" : [ ]
  }, {
    "name" : "public void resetLockout(android.hardware.keymaster.HardwareAuthToken hat) throws android.os.RemoteException",
    "returnType" : "void",
    "comment" : "\n   * resetLockout:\n   * \n   * Requests the HAL to clear the lockout counter. Upon receiving this request, the HAL must\n   * perform the following:\n   *   1) Verify the authenticity and integrity of the provided HAT\n   *   2) Verify that the timestamp provided within the HAT is relatively recent (e.g. on the\n   *      order of minutes, not hours).\n   * If either of the checks fail, the HAL must invoke ISessionCallback#onError with\n   * Error::UNABLE_TO_PROCESS.\n   * \n   * Upon successful verification, the HAL must clear the lockout counter and notify the framework\n   * via ISessionCallback#onLockoutCleared.\n   * \n   * Note that lockout is user AND sensor specific. In other words, there is a separate lockout\n   * state for each (user, sensor) pair. For example, the following is a valid state on a\n   * multi-sensor device:\n   * ------------------------------------------------------------------\n   * | SensorId | UserId | FailedAttempts | LockedOut | LockedUntil   |\n   * |----------|--------|----------------|-----------|---------------|\n   * | 0        | 0      | 1              | false     | x             |\n   * | 1        | 0      | 5              | true      | <future_time> |\n   * | 0        | 10     | 0              | false     | x             |\n   * | 1        | 10     | 0              | false     | x             |\n   * ------------------------------------------------------------------\n   * \n   * Lockout may be cleared in the following ways:\n   *   1) ISession#resetLockout\n   *   2) After a period of time, according to a rate-limiter.\n   * \n   * Note that the \"FailedAttempts\" counter must be cleared upon successful fingerprint\n   * authentication. For example, if SensorId=0 UserId=0 FailedAttempts=1, and a successful\n   * fingerprint authentication occurs, the counter for that (SensorId, UserId) pair must be reset\n   * to 0.\n   * \n   * In addition, lockout states MUST persist after device reboots, HAL crashes, etc.\n   * \n   * See the Android CDD section 7.3.10 for the full set of lockout and rate-limiting\n   * requirements.\n   * \n   * Callbacks that signify the end of this operation's lifecycle:\n   *   - ISessionCallback#onLockoutCleared\n   * \n   * @param hat HardwareAuthToken See above documentation.\n   ",
    "links" : [ ]
  }, {
    "name" : "public void close() throws android.os.RemoteException",
    "returnType" : "void",
    "comment" : "\n   * Close this session and allow the HAL to release the resources associated with this session.\n   * \n   * A session can only be closed when the HAL is idling, i.e. not performing any of the\n   * non-interruptable operations. If the HAL is busy performing a cancellable operation, the\n   * operation must be explicitly cancelled with a call to ICancellationSignal#cancel before\n   * the session can be closed.\n   * \n   * After a session is closed, the HAL must notify the framework by calling\n   * ISessionCallback#onSessionClosed.\n   * \n   * All sessions must be explicitly closed. Calling IFingerprint#createSession while there is an\n   * active session is considered an error.\n   * \n   * Callbacks that signify the end of this operation's lifecycle:\n   *   - ISessionCallback#onSessionClosed\n   ",
    "links" : [ ]
  }, {
    "name" : "public void onPointerDown(int pointerId, int x, int y, float minor, float major) throws android.os.RemoteException",
    "returnType" : "void",
    "comment" : "\n   * onPointerDown:\n   * \n   * This operation only applies to sensors that are configured as\n   * FingerprintSensorType::UNDER_DISPLAY_*. If invoked erroneously by the framework for sensors\n   * of other types, the HAL must treat this as a no-op and return immediately.\n   * \n   * This operation is used to notify the HAL of display touches. This operation can be invoked\n   * when the HAL is performing any one of: ISession#authenticate, ISession#enroll,\n   * ISession#detectInteraction.\n   * \n   * Note that the framework will only invoke this operation if the event occurred on the display\n   * on which this sensor is located.\n   * \n   * Note that for sensors which require illumination such as\n   * FingerprintSensorType::UNDER_DISPLAY_OPTICAL, and where illumination is handled below the\n   * framework, this is a good time to start illuminating.\n   * \n   * @param pointerId See android.view.MotionEvent#getPointerId\n   * @param x The distance in pixels from the left edge of the display.\n   * @param y The distance in pixels from the top edge of the display.\n   * @param minor See android.view.MotionEvent#getTouchMinor\n   * @param major See android.view.MotionEvent#getTouchMajor\n   * \n   * @deprecated use onPointerDownWithContext instead.\n   ",
    "links" : [ ]
  }, {
    "name" : "public void onPointerUp(int pointerId) throws android.os.RemoteException",
    "returnType" : "void",
    "comment" : "\n   * onPointerUp:\n   * \n   * This operation only applies to sensors that are configured as\n   * FingerprintSensorType::UNDER_DISPLAY_*. If invoked for sensors of other types, the HAL must\n   * treat this as a no-op and return immediately.\n   * \n   * This operation can be invoked when the HAL is performing any one of: ISession#authenticate,\n   * ISession#enroll, ISession#detectInteraction.\n   * \n   * @param pointerId See android.view.MotionEvent#getPointerId\n   * \n   * @deprecated use onPointerUpWithContext instead.\n   ",
    "links" : [ ]
  }, {
    "name" : "public void onUiReady() throws android.os.RemoteException",
    "returnType" : "void",
    "comment" : "\n   * onUiReady:\n   * \n   * This operation only applies to sensors that are configured as\n   * FingerprintSensorType::UNDER_DISPLAY_OPTICAL. If invoked for sensors of other types, the HAL\n   * must treat this as a no-op and return immediately.\n   * \n   * This operation can be invoked when the HAL is performing any one of: ISession#authenticate,\n   * ISession#enroll, ISession#detectInteraction.\n   * \n   * For FingerprintSensorType::UNDER_DISPLAY_OPTICAL where illumination is handled above the\n   * HAL, the framework will invoke this operation to notify when the illumination is showing.\n   ",
    "links" : [ ]
  }, {
    "name" : "public android.hardware.biometrics.common.ICancellationSignal authenticateWithContext(long operationId, android.hardware.biometrics.common.OperationContext context) throws android.os.RemoteException",
    "returnType" : "android.hardware.biometrics.common.ICancellationSignal",
    "comment" : " See ISession#authenticate(long) ",
    "links" : [ ]
  }, {
    "name" : "public android.hardware.biometrics.common.ICancellationSignal enrollWithContext(android.hardware.keymaster.HardwareAuthToken hat, android.hardware.biometrics.common.OperationContext context) throws android.os.RemoteException",
    "returnType" : "android.hardware.biometrics.common.ICancellationSignal",
    "comment" : " See ISession#enroll(HardwareAuthToken) ",
    "links" : [ ]
  }, {
    "name" : "public android.hardware.biometrics.common.ICancellationSignal detectInteractionWithContext(android.hardware.biometrics.common.OperationContext context) throws android.os.RemoteException",
    "returnType" : "android.hardware.biometrics.common.ICancellationSignal",
    "comment" : " See ISession#detectInteraction() ",
    "links" : [ ]
  }, {
    "name" : "public void onPointerDownWithContext(android.hardware.biometrics.fingerprint.PointerContext context) throws android.os.RemoteException",
    "returnType" : "void",
    "comment" : "\n   * onPointerDownWithContext:\n   * \n   * This operation only applies to sensors that are configured as\n   * FingerprintSensorType::UNDER_DISPLAY_*. If invoked erroneously by the framework for sensors\n   * of other types, the HAL must treat this as a no-op and return immediately.\n   * \n   * Notifies the HAL that a finger entered the sensor area. This operation can be invoked\n   * regardless of the current state of the HAL.\n   * \n   * Note that for sensors which require illumination, for example\n   * FingerprintSensorType::UNDER_DISPLAY_OPTICAL, this is a good time to start illuminating.\n   * \n   * @param context See PointerContext\n   ",
    "links" : [ ]
  }, {
    "name" : "public void onPointerUpWithContext(android.hardware.biometrics.fingerprint.PointerContext context) throws android.os.RemoteException",
    "returnType" : "void",
    "comment" : "\n   * onPointerUpWithContext:\n   * \n   * This operation only applies to sensors that are configured as\n   * FingerprintSensorType::UNDER_DISPLAY_*. If invoked for sensors of other types, the HAL must\n   * treat this as a no-op and return immediately.\n   * \n   * Notifies the HAL that a finger left the sensor area. This operation can be invoked regardless\n   * of the current state of the HAL.\n   * \n   * @param context See PointerContext\n   ",
    "links" : [ ]
  }, {
    "name" : "public void onContextChanged(android.hardware.biometrics.common.OperationContext context) throws android.os.RemoteException",
    "returnType" : "void",
    "comment" : "\n   * onContextChanged:\n   * \n   * This may be called while an authenticate, detect interaction, or enrollment operation is\n   * running when the context changes.\n   ",
    "links" : [ ]
  }, {
    "name" : "public void onPointerCancelWithContext(android.hardware.biometrics.fingerprint.PointerContext context) throws android.os.RemoteException",
    "returnType" : "void",
    "comment" : "\n   * onPointerCancelWithContext:\n   * \n   * This operation only applies to sensors that are configured as\n   * FingerprintSensorType::UNDER_DISPLAY_*. If invoked for sensors of other types, the HAL must\n   * treat this as a no-op and return immediately.\n   * \n   * Notifies the HAL that if there were fingers within the sensor area, they are no longer being\n   * tracked. The fingers may or may not still be on the sensor. This operation can be invoked\n   * regardless of the current state of the HAL.\n   * \n   * @param context See PointerContext\n   ",
    "links" : [ ]
  }, {
    "name" : "public void setIgnoreDisplayTouches(boolean shouldIgnore) throws android.os.RemoteException",
    "returnType" : "void",
    "comment" : "\n   * setIgnoreDisplayTouches:\n   * \n   * This operation only applies to sensors that have SensorProps#halHandlesDisplayTouches\n   * set to true. For all other sensors this is a no-op.\n   * \n   * Instructs the HAL whether to ignore display touches. This can be useful to avoid unintended\n   * fingerprint captures during certain UI interactions. For example, when entering a lockscreen\n   * PIN, some of the touches might overlap with the fingerprint sensor. Those touches should be\n   * ignored to avoid unintended authentication attempts.\n   * \n   * This flag must default to false when the HAL starts.\n   * \n   * The framework is responsible for both setting the flag to true and resetting it to false\n   * whenever it's appropriate.\n   * \n   * @param shouldIgnore whether the display touches should be ignored.\n   * \n   * @deprecated use isHardwareIgnoringTouches in OperationContext from onContextChanged instead\n   ",
    "links" : [ ]
  }, {
    "name" : "public int getInterfaceVersion() throws android.os.RemoteException",
    "returnType" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public String getInterfaceHash() throws android.os.RemoteException",
    "returnType" : "String",
    "comment" : "",
    "links" : [ ]
  } ],
  "methodNames" : [ "public void generateChallenge() throws android.os.RemoteException", "public void revokeChallenge(long challenge) throws android.os.RemoteException", "public android.hardware.biometrics.common.ICancellationSignal enroll(android.hardware.keymaster.HardwareAuthToken hat) throws android.os.RemoteException", "public android.hardware.biometrics.common.ICancellationSignal authenticate(long operationId) throws android.os.RemoteException", "public android.hardware.biometrics.common.ICancellationSignal detectInteraction() throws android.os.RemoteException", "public void enumerateEnrollments() throws android.os.RemoteException", "public void removeEnrollments(int[] enrollmentIds) throws android.os.RemoteException", "public void getAuthenticatorId() throws android.os.RemoteException", "public void invalidateAuthenticatorId() throws android.os.RemoteException", "public void resetLockout(android.hardware.keymaster.HardwareAuthToken hat) throws android.os.RemoteException", "public void close() throws android.os.RemoteException", "public void onPointerDown(int pointerId, int x, int y, float minor, float major) throws android.os.RemoteException", "public void onPointerUp(int pointerId) throws android.os.RemoteException", "public void onUiReady() throws android.os.RemoteException", "public android.hardware.biometrics.common.ICancellationSignal authenticateWithContext(long operationId, android.hardware.biometrics.common.OperationContext context) throws android.os.RemoteException", "public android.hardware.biometrics.common.ICancellationSignal enrollWithContext(android.hardware.keymaster.HardwareAuthToken hat, android.hardware.biometrics.common.OperationContext context) throws android.os.RemoteException", "public android.hardware.biometrics.common.ICancellationSignal detectInteractionWithContext(android.hardware.biometrics.common.OperationContext context) throws android.os.RemoteException", "public void onPointerDownWithContext(android.hardware.biometrics.fingerprint.PointerContext context) throws android.os.RemoteException", "public void onPointerUpWithContext(android.hardware.biometrics.fingerprint.PointerContext context) throws android.os.RemoteException", "public void onContextChanged(android.hardware.biometrics.common.OperationContext context) throws android.os.RemoteException", "public void onPointerCancelWithContext(android.hardware.biometrics.fingerprint.PointerContext context) throws android.os.RemoteException", "public void setIgnoreDisplayTouches(boolean shouldIgnore) throws android.os.RemoteException", "public int getInterfaceVersion() throws android.os.RemoteException", "public String getInterfaceHash() throws android.os.RemoteException" ],
  "variableNames" : [ "VERSION", "HASH", "DESCRIPTOR" ]
}