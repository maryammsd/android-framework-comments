{
  "filePath" : "/home/maryam/clearblue/files/android-source-35/java/text/DecimalFormat.java",
  "packageName" : "java.text",
  "className" : "DecimalFormat",
  "comment" : "\n * {@code DecimalFormat} is a concrete subclass of\n * {@code NumberFormat} that formats decimal numbers. It has a variety of\n * features designed to make it possible to parse and format numbers in any\n * locale, including support for Western, Arabic, and Indic digits.  It also\n * supports different kinds of numbers, including integers (123), fixed-point\n * numbers (123.4), scientific notation (1.23E4), percentages (12%), and\n * currency amounts ($123).  All of these can be localized.\n *\n * <p>To obtain a {@code NumberFormat} for a specific locale, including the\n * default locale, call one of {@code NumberFormat}'s factory methods, such\n * as {@code getInstance()}.  In general, do not call the\n * {@code DecimalFormat} constructors directly, since the\n * {@code NumberFormat} factory methods may return subclasses other than\n * {@code DecimalFormat}. If you need to customize the format object, do\n * something like this:\n *\n * <blockquote><pre>\n * NumberFormat f = NumberFormat.getInstance(loc);\n * if (f instanceof DecimalFormat) {\n *     ((DecimalFormat) f).setDecimalSeparatorAlwaysShown(true);\n * }\n * </pre></blockquote>\n *\n * <p>A {@code DecimalFormat} comprises a <em>pattern</em> and a set of\n * <em>symbols</em>.  The pattern may be set directly using\n * {@code applyPattern()}, or indirectly using the API methods.  The\n * symbols are stored in a {@code DecimalFormatSymbols} object.  When using\n * the {@code NumberFormat} factory methods, the pattern and symbols are\n * read from localized {@code ResourceBundle}s.\n *\n * <h2>Patterns</h2>\n *\n * {@code DecimalFormat} patterns have the following syntax:\n * <blockquote><pre>\n * <i>Pattern:</i>\n *         <i>PositivePattern</i>\n *         <i>PositivePattern</i> ; <i>NegativePattern</i>\n * <i>PositivePattern:</i>\n *         <i>Prefix<sub>opt</sub></i> <i>Number</i> <i>Suffix<sub>opt</sub></i>\n * <i>NegativePattern:</i>\n *         <i>Prefix<sub>opt</sub></i> <i>Number</i> <i>Suffix<sub>opt</sub></i>\n * <i>Prefix:</i>\n *         any Unicode characters except &#92;uFFFE, &#92;uFFFF, and special characters\n * <i>Suffix:</i>\n *         any Unicode characters except &#92;uFFFE, &#92;uFFFF, and special characters\n * <i>Number:</i>\n *         <i>Integer</i> <i>Exponent<sub>opt</sub></i>\n *         <i>Integer</i> . <i>Fraction</i> <i>Exponent<sub>opt</sub></i>\n * <i>Integer:</i>\n *         <i>MinimumInteger</i>\n *         #\n *         # <i>Integer</i>\n *         # , <i>Integer</i>\n * <i>MinimumInteger:</i>\n *         0\n *         0 <i>MinimumInteger</i>\n *         0 , <i>MinimumInteger</i>\n * <i>Fraction:</i>\n *         <i>MinimumFraction<sub>opt</sub></i> <i>OptionalFraction<sub>opt</sub></i>\n * <i>MinimumFraction:</i>\n *         0 <i>MinimumFraction<sub>opt</sub></i>\n * <i>OptionalFraction:</i>\n *         # <i>OptionalFraction<sub>opt</sub></i>\n * <i>Exponent:</i>\n *         E <i>MinimumExponent</i>\n * <i>MinimumExponent:</i>\n *         0 <i>MinimumExponent<sub>opt</sub></i>\n * </pre></blockquote>\n *\n * <p>A {@code DecimalFormat} pattern contains a positive and negative\n * subpattern, for example, {@code \"#,##0.00;(#,##0.00)\"}.  Each\n * subpattern has a prefix, numeric part, and suffix. The negative subpattern\n * is optional; if absent, then the positive subpattern prefixed with the\n * minus sign ({@code '-' U+002D HYPHEN-MINUS}) is used as the\n * negative subpattern. That is, {@code \"0.00\"} alone is equivalent to\n * {@code \"0.00;-0.00\"}.  If there is an explicit negative subpattern, it\n * serves only to specify the negative prefix and suffix; the number of digits,\n * minimal digits, and other characteristics are all the same as the positive\n * pattern. That means that {@code \"#,##0.0#;(#)\"} produces precisely\n * the same behavior as {@code \"#,##0.0#;(#,##0.0#)\"}.\n *\n * <p>The prefixes, suffixes, and various symbols used for infinity, digits,\n * grouping separators, decimal separators, etc. may be set to arbitrary\n * values, and they will appear properly during formatting.  However, care must\n * be taken that the symbols and strings do not conflict, or parsing will be\n * unreliable.  For example, either the positive and negative prefixes or the\n * suffixes must be distinct for {@code DecimalFormat.parse()} to be able\n * to distinguish positive from negative values.  (If they are identical, then\n * {@code DecimalFormat} will behave as if no negative subpattern was\n * specified.)  Another example is that the decimal separator and grouping\n * separator should be distinct characters, or parsing will be impossible.\n *\n * <p>The grouping separator is commonly used for thousands, but in some\n * countries it separates ten-thousands. The grouping size is a constant number\n * of digits between the grouping characters, such as 3 for 100,000,000 or 4 for\n * 1,0000,0000.  If you supply a pattern with multiple grouping characters, the\n * interval between the last one and the end of the integer is the one that is\n * used. So {@code \"#,##,###,####\"} == {@code \"######,####\"} ==\n * {@code \"##,####,####\"}.\n *\n * <h3><a id=\"special_pattern_character\">Special Pattern Characters</a></h3>\n *\n * <p>Many characters in a pattern are taken literally; they are matched during\n * parsing and output unchanged during formatting.  Special characters, on the\n * other hand, stand for other characters, strings, or classes of characters.\n * They must be quoted, unless noted otherwise, if they are to appear in the\n * prefix or suffix as literals.\n *\n * <p>The characters listed here are used in non-localized patterns.  Localized\n * patterns use the corresponding characters taken from this formatter's\n * {@code DecimalFormatSymbols} object instead, and these characters lose\n * their special status.  Two exceptions are the currency sign and quote, which\n * are not localized.\n *\n * <blockquote>\n * <table class=\"striped\">\n * <caption style=\"display:none\">Chart showing symbol, location, localized, and meaning.</caption>\n * <thead>\n *     <tr>\n *          <th scope=\"col\" style=\"text-align:left\">Symbol\n *          <th scope=\"col\" style=\"text-align:left\">Location\n *          <th scope=\"col\" style=\"text-align:left\">Localized?\n *          <th scope=\"col\" style=\"text-align:left\">Meaning\n * </thead>\n * <tbody>\n *     <tr style=\"vertical-align:top\">\n *          <th scope=\"row\">{@code 0}\n *          <td>Number\n *          <td>Yes\n *          <td>Digit\n *     <tr style=\"vertical-align: top\">\n *          <th scope=\"row\">{@code #}\n *          <td>Number\n *          <td>Yes\n *          <td>Digit, zero shows as absent\n *     <tr style=\"vertical-align:top\">\n *          <th scope=\"row\">{@code .}\n *          <td>Number\n *          <td>Yes\n *          <td>Decimal separator or monetary decimal separator\n *     <tr style=\"vertical-align: top\">\n *          <th scope=\"row\">{@code -}\n *          <td>Number\n *          <td>Yes\n *          <td>Minus sign\n *     <tr style=\"vertical-align:top\">\n *          <th scope=\"row\">{@code ,}\n *          <td>Number\n *          <td>Yes\n *          <td>Grouping separator or monetary grouping separator\n *     <tr style=\"vertical-align: top\">\n *          <th scope=\"row\">{@code E}\n *          <td>Number\n *          <td>Yes\n *          <td>Separates mantissa and exponent in scientific notation.\n *              <em>Need not be quoted in prefix or suffix.</em>\n *     <tr style=\"vertical-align:top\">\n *          <th scope=\"row\">{@code ;}\n *          <td>Subpattern boundary\n *          <td>Yes\n *          <td>Separates positive and negative subpatterns\n *     <tr style=\"vertical-align: top\">\n *          <th scope=\"row\">{@code %}\n *          <td>Prefix or suffix\n *          <td>Yes\n *          <td>Multiply by 100 and show as percentage\n *     <tr style=\"vertical-align:top\">\n *          <th scope=\"row\">{@code &#92;u2030}\n *          <td>Prefix or suffix\n *          <td>Yes\n *          <td>Multiply by 1000 and show as per mille value\n *     <tr style=\"vertical-align: top\">\n *          <th scope=\"row\">{@code &#164;} ({@code &#92;u00A4})\n *          <td>Prefix or suffix\n *          <td>No\n *          <td>Currency sign, replaced by currency symbol.  If\n *              doubled, replaced by international currency symbol.\n *              If present in a pattern, the monetary decimal/grouping separators\n *              are used instead of the decimal/grouping separators.\n *     <tr style=\"vertical-align:top\">\n *          <th scope=\"row\">{@code '}\n *          <td>Prefix or suffix\n *          <td>No\n *          <td>Used to quote special characters in a prefix or suffix,\n *              for example, {@code \"'#'#\"} formats 123 to\n *              {@code \"#123\"}.  To create a single quote\n *              itself, use two in a row: {@code \"# o''clock\"}.\n * </tbody>\n * </table>\n * </blockquote>\n *\n * <h3>Scientific Notation</h3>\n *\n * <p>Numbers in scientific notation are expressed as the product of a mantissa\n * and a power of ten, for example, 1234 can be expressed as 1.234 x 10^3.  The\n * mantissa is often in the range 1.0 &le; x {@literal <} 10.0, but it need not\n * be.\n * {@code DecimalFormat} can be instructed to format and parse scientific\n * notation <em>only via a pattern</em>; there is currently no factory method\n * that creates a scientific notation format.  In a pattern, the exponent\n * character immediately followed by one or more digit characters indicates\n * scientific notation.  Example: {@code \"0.###E0\"} formats the number\n * 1234 as {@code \"1.234E3\"}.\n *\n * <ul>\n * <li>The number of digit characters after the exponent character gives the\n * minimum exponent digit count.  There is no maximum.  Negative exponents are\n * formatted using the localized minus sign, <em>not</em> the prefix and suffix\n * from the pattern.  This allows patterns such as {@code \"0.###E0 m/s\"}.\n *\n * <li>The minimum and maximum number of integer digits are interpreted\n * together:\n *\n * <ul>\n * <li>If the maximum number of integer digits is greater than their minimum number\n * and greater than 1, it forces the exponent to be a multiple of the maximum\n * number of integer digits, and the minimum number of integer digits to be\n * interpreted as 1.  The most common use of this is to generate\n * <em>engineering notation</em>, in which the exponent is a multiple of three,\n * e.g., {@code \"##0.#####E0\"}. Using this pattern, the number 12345\n * formats to {@code \"12.345E3\"}, and 123456 formats to\n * {@code \"123.456E3\"}.\n *\n * <li>Otherwise, the minimum number of integer digits is achieved by adjusting the\n * exponent.  Example: 0.00123 formatted with {@code \"00.###E0\"} yields\n * {@code \"12.3E-4\"}.\n * </ul>\n *\n * <li>The number of significant digits in the mantissa is the sum of the\n * <em>minimum integer</em> and <em>maximum fraction</em> digits, and is\n * unaffected by the maximum integer digits.  For example, 12345 formatted with\n * {@code \"##0.##E0\"} is {@code \"12.3E3\"}. To show all digits, set\n * the significant digits count to zero.  The number of significant digits\n * does not affect parsing.\n *\n * <li>Exponential patterns may not contain grouping separators.\n * </ul>\n *\n * <h3>Rounding</h3>\n *\n * {@code DecimalFormat} provides rounding modes defined in\n * {@link java.math.RoundingMode} for formatting.  By default, it uses\n * {@link java.math.RoundingMode#HALF_EVEN RoundingMode.HALF_EVEN}.\n *\n * <h3>Digits</h3>\n *\n * For formatting, {@code DecimalFormat} uses the ten consecutive\n * characters starting with the localized zero digit defined in the\n * {@code DecimalFormatSymbols} object as digits. For parsing, these\n * digits as well as all Unicode decimal digits, as defined by\n * {@link Character#digit Character.digit}, are recognized.\n *\n * <h4>Special Values</h4>\n *\n * <p>{@code NaN} is formatted as a string, which typically has a single character\n * {@code &#92;uFFFD}.  This string is determined by the\n * {@code DecimalFormatSymbols} object.  This is the only value for which\n * the prefixes and suffixes are not used.\n *\n * <p>Infinity is formatted as a string, which typically has a single character\n * {@code &#92;u221E}, with the positive or negative prefixes and suffixes\n * applied.  The infinity string is determined by the\n * {@code DecimalFormatSymbols} object.\n *\n * <p>Negative zero ({@code \"-0\"}) parses to\n * <ul>\n * <li>{@code BigDecimal(0)} if {@code isParseBigDecimal()} is\n * true,\n * <li>{@code Long(0)} if {@code isParseBigDecimal()} is false\n *     and {@code isParseIntegerOnly()} is true,\n * <li>{@code Double(-0.0)} if both {@code isParseBigDecimal()}\n * and {@code isParseIntegerOnly()} are false.\n * </ul>\n *\n * <h3><a id=\"synchronization\">Synchronization</a></h3>\n *\n * <p>\n * Decimal formats are generally not synchronized.\n * It is recommended to create separate format instances for each thread.\n * If multiple threads access a format concurrently, it must be synchronized\n * externally.\n *\n * <h3>Example</h3>\n *\n * <blockquote><pre><strong>{@code\n * // Print out a number using the localized number, integer, currency,\n * // and percent format for each locale}</strong>{@code\n * Locale[] locales = NumberFormat.getAvailableLocales();\n * double myNumber = -1234.56;\n * NumberFormat form;\n * for (int j = 0; j < 4; ++j) {\n *     System.out.println(\"FORMAT\");\n *     for (int i = 0; i < locales.length; ++i) {\n *         if (locales[i].getCountry().length() == 0) {\n *            continue; // Skip language-only locales\n *         }\n *         System.out.print(locales[i].getDisplayName());\n *         switch (j) {\n *         case 0:\n *             form = NumberFormat.getInstance(locales[i]); break;\n *         case 1:\n *             form = NumberFormat.getIntegerInstance(locales[i]); break;\n *         case 2:\n *             form = NumberFormat.getCurrencyInstance(locales[i]); break;\n *         default:\n *             form = NumberFormat.getPercentInstance(locales[i]); break;\n *         }\n *         if (form instanceof DecimalFormat) {\n *             System.out.print(\": \" + ((DecimalFormat) form).toPattern());\n *         }\n *         System.out.print(\" -> \" + form.format(myNumber));\n *         try {\n *             System.out.println(\" -> \" + form.parse(form.format(myNumber)));\n *         } catch (ParseException e) {}\n *     }\n * }\n * }</pre></blockquote>\n *\n * @see          <a href=\"http://docs.oracle.com/javase/tutorial/i18n/format/decimalFormat.html\">Java Tutorial</a>\n * @see          NumberFormat\n * @see          DecimalFormatSymbols\n * @see          ParsePosition\n * @author       Mark Davis\n * @author       Alan Liu\n * @since 1.1\n ",
  "links" : [ "#digit", "java.math.RoundingMode#HALF_EVEN", "java.math.RoundingMode" ],
  "variables" : [ {
    "name" : "icuDecimalFormat",
    "type" : "android.icu.text.DecimalFormat",
    "comment" : " Android-added: ICU DecimalFormat to delegate to.",
    "links" : [ ]
  }, {
    "name" : "serialPersistentFields",
    "type" : "ObjectStreamField[]",
    "comment" : " the fields list to be serialized",
    "links" : [ ]
  }, {
    "name" : "symbols",
    "type" : "DecimalFormatSymbols",
    "comment" : " LIU new DecimalFormatSymbols();",
    "links" : [ ]
  }, {
    "name" : "maximumIntegerDigits",
    "type" : "int",
    "comment" : " Android-changed: removed initialization.",
    "links" : [ ]
  }, {
    "name" : "minimumIntegerDigits",
    "type" : "int",
    "comment" : " Android-changed: removed initialization.",
    "links" : [ ]
  }, {
    "name" : "maximumFractionDigits",
    "type" : "int",
    "comment" : " Android-changed: removed initialization.",
    "links" : [ ]
  }, {
    "name" : "minimumFractionDigits",
    "type" : "int",
    "comment" : " Android-changed: removed initialization.",
    "links" : [ ]
  }, {
    "name" : "roundingMode",
    "type" : "RoundingMode",
    "comment" : "\n     * The {@link java.math.RoundingMode} used in this DecimalFormat.\n     *\n     * @serial\n     * @since 1.6\n     ",
    "links" : [ "java.math.RoundingMode" ]
  }, {
    "name" : "currentSerialVersion",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "DOUBLE_INTEGER_DIGITS",
    "type" : "int",
    "comment" : " Upper limit on integer and fraction digits for a Java double",
    "links" : [ ]
  }, {
    "name" : "DOUBLE_FRACTION_DIGITS",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "MAXIMUM_INTEGER_DIGITS",
    "type" : "int",
    "comment" : " Upper limit on integer and fraction digits for BigDecimal and BigInteger",
    "links" : [ ]
  }, {
    "name" : "MAXIMUM_FRACTION_DIGITS",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "serialVersionUID",
    "type" : "long",
    "comment" : " Proclaim JDK 1.1 serial compatibility.",
    "links" : [ ]
  } ],
  "methods" : [ {
    "name" : "private void initPattern(String pattern)",
    "returnType" : "void",
    "comment" : "\n     * Applies the pattern similarly to {@link #applyPattern(String)}, except it initializes\n     * {@link #icuDecimalFormat} in the process. This should only be called from constructors.\n     ",
    "links" : [ "#icuDecimalFormat", "#applyPattern(String)" ]
  }, {
    "name" : "private void updateFieldsFromIcu()",
    "returnType" : "void",
    "comment" : "\n     * Update local fields indicating maximum/minimum integer/fraction digit count from the ICU\n     * DecimalFormat. This needs to be called whenever a new pattern is applied.\n     ",
    "links" : [ ]
  }, {
    "name" : "private static FieldPosition getIcuFieldPosition(FieldPosition fp)",
    "returnType" : "FieldPosition",
    "comment" : "\n     * Converts between field positions used by Java/ICU.\n     * @param fp The java.text.NumberFormat.Field field position\n     * @return The android.icu.text.NumberFormat.Field field position\n     ",
    "links" : [ ]
  }, {
    "name" : "private static Field toJavaFieldAttribute(AttributedCharacterIterator.Attribute icuAttribute)",
    "returnType" : "Field",
    "comment" : "\n     * Converts the Attribute that ICU returns in its AttributedCharacterIterator\n     * responses to the type that java uses.\n     * @param icuAttribute The AttributedCharacterIterator.Attribute field.\n     * @return Field converted to a java.text.NumberFormat.Field field.\n     ",
    "links" : [ ]
  }, {
    "name" : "public final StringBuffer format(Object number, StringBuffer toAppendTo, FieldPosition pos)",
    "returnType" : "StringBuffer",
    "comment" : "\n     * Formats a number and appends the resulting text to the given string\n     * buffer.\n     * The number can be of any subclass of {@link java.lang.Number}.\n     * <p>\n     * This implementation uses the maximum precision permitted.\n     * @param number     the number to format\n     * @param toAppendTo the {@code StringBuffer} to which the formatted\n     *                   text is to be appended\n     * @param pos        keeps track on the position of the field within the\n     *                   returned string. For example, for formatting a number\n     *                   {@code 1234567.89} in {@code Locale.US} locale,\n     *                   if the given {@code fieldPosition} is\n     *                   {@link NumberFormat#INTEGER_FIELD}, the begin index\n     *                   and end index of {@code fieldPosition} will be set\n     *                   to 0 and 9, respectively for the output string\n     *                   {@code 1,234,567.89}.\n     * @return           the value passed in as {@code toAppendTo}\n     * @throws           IllegalArgumentException if {@code number} is\n     *                   null or not an instance of {@code Number}.\n     * @throws           NullPointerException if {@code toAppendTo} or\n     *                   {@code pos} is null\n     * @throws           ArithmeticException if rounding is needed with rounding\n     *                   mode being set to RoundingMode.UNNECESSARY\n     * @see              java.text.FieldPosition\n     ",
    "links" : [ "java.text.NumberFormat#INTEGER_FIELD", "java.lang.Number" ]
  }, {
    "name" : "public StringBuffer format(double number, StringBuffer result, FieldPosition fieldPosition)",
    "returnType" : "StringBuffer",
    "comment" : "\n     * Formats a double to produce a string.\n     * @param number    The double to format\n     * @param result    where the text is to be appended\n     * @param fieldPosition    keeps track on the position of the field within\n     *                         the returned string. For example, for formatting\n     *                         a number {@code 1234567.89} in {@code Locale.US}\n     *                         locale, if the given {@code fieldPosition} is\n     *                         {@link NumberFormat#INTEGER_FIELD}, the begin index\n     *                         and end index of {@code fieldPosition} will be set\n     *                         to 0 and 9, respectively for the output string\n     *                         {@code 1,234,567.89}.\n     * @throws    NullPointerException if {@code result} or\n     *            {@code fieldPosition} is {@code null}\n     * @throws    ArithmeticException if rounding is needed with rounding\n     *            mode being set to RoundingMode.UNNECESSARY\n     * @return The formatted number string\n     * @see java.text.FieldPosition\n     ",
    "links" : [ "java.text.NumberFormat#INTEGER_FIELD" ]
  }, {
    "name" : "public StringBuffer format(long number, StringBuffer result, FieldPosition fieldPosition)",
    "returnType" : "StringBuffer",
    "comment" : "\n     * Format a long to produce a string.\n     * @param number    The long to format\n     * @param result    where the text is to be appended\n     * @param fieldPosition    keeps track on the position of the field within\n     *                         the returned string. For example, for formatting\n     *                         a number {@code 123456789} in {@code Locale.US}\n     *                         locale, if the given {@code fieldPosition} is\n     *                         {@link NumberFormat#INTEGER_FIELD}, the begin index\n     *                         and end index of {@code fieldPosition} will be set\n     *                         to 0 and 11, respectively for the output string\n     *                         {@code 123,456,789}.\n     * @throws          NullPointerException if {@code result} or\n     *                  {@code fieldPosition} is {@code null}\n     * @throws          ArithmeticException if rounding is needed with rounding\n     *                  mode being set to RoundingMode.UNNECESSARY\n     * @return The formatted number string\n     * @see java.text.FieldPosition\n     ",
    "links" : [ "java.text.NumberFormat#INTEGER_FIELD" ]
  }, {
    "name" : "private StringBuffer format(BigDecimal number, StringBuffer result, FieldPosition fieldPosition)",
    "returnType" : "StringBuffer",
    "comment" : "\n     * Formats a BigDecimal to produce a string.\n     * @param number    The BigDecimal to format\n     * @param result    where the text is to be appended\n     * @param fieldPosition    keeps track on the position of the field within\n     *                         the returned string. For example, for formatting\n     *                         a number {@code 1234567.89} in {@code Locale.US}\n     *                         locale, if the given {@code fieldPosition} is\n     *                         {@link NumberFormat#INTEGER_FIELD}, the begin index\n     *                         and end index of {@code fieldPosition} will be set\n     *                         to 0 and 9, respectively for the output string\n     *                         {@code 1,234,567.89}.\n     * @return The formatted number string\n     * @throws           ArithmeticException if rounding is needed with rounding\n     *                   mode being set to RoundingMode.UNNECESSARY\n     * @see java.text.FieldPosition\n     ",
    "links" : [ "java.text.NumberFormat#INTEGER_FIELD" ]
  }, {
    "name" : "private StringBuffer format(BigInteger number, StringBuffer result, FieldPosition fieldPosition)",
    "returnType" : "StringBuffer",
    "comment" : "\n     * Format a BigInteger to produce a string.\n     * @param number    The BigInteger to format\n     * @param result    where the text is to be appended\n     * @param fieldPosition    keeps track on the position of the field within\n     *                         the returned string. For example, for formatting\n     *                         a number {@code 123456789} in {@code Locale.US}\n     *                         locale, if the given {@code fieldPosition} is\n     *                         {@link NumberFormat#INTEGER_FIELD}, the begin index\n     *                         and end index of {@code fieldPosition} will be set\n     *                         to 0 and 11, respectively for the output string\n     *                         {@code 123,456,789}.\n     * @return The formatted number string\n     * @throws           ArithmeticException if rounding is needed with rounding\n     *                   mode being set to RoundingMode.UNNECESSARY\n     * @see java.text.FieldPosition\n     ",
    "links" : [ "java.text.NumberFormat#INTEGER_FIELD" ]
  }, {
    "name" : "public AttributedCharacterIterator formatToCharacterIterator(Object obj)",
    "returnType" : "AttributedCharacterIterator",
    "comment" : "\n     * Formats an Object producing an {@code AttributedCharacterIterator}.\n     * You can use the returned {@code AttributedCharacterIterator}\n     * to build the resulting String, as well as to determine information\n     * about the resulting String.\n     * <p>\n     * Each attribute key of the AttributedCharacterIterator will be of type\n     * {@code NumberFormat.Field}, with the attribute value being the\n     * same as the attribute key.\n     *\n     * @throws    NullPointerException if obj is null.\n     * @throws    IllegalArgumentException when the Format cannot format the\n     *            given object.\n     * @throws           ArithmeticException if rounding is needed with rounding\n     *                   mode being set to RoundingMode.UNNECESSARY\n     * @param obj The object to format\n     * @return AttributedCharacterIterator describing the formatted value.\n     * @since 1.4\n     ",
    "links" : [ ]
  }, {
    "name" : "public Number parse(String text, ParsePosition pos)",
    "returnType" : "Number",
    "comment" : "\n     * Parses text from a string to produce a {@code Number}.\n     * <p>\n     * The method attempts to parse text starting at the index given by\n     * {@code pos}.\n     * If parsing succeeds, then the index of {@code pos} is updated\n     * to the index after the last character used (parsing does not necessarily\n     * use all characters up to the end of the string), and the parsed\n     * number is returned. The updated {@code pos} can be used to\n     * indicate the starting point for the next call to this method.\n     * If an error occurs, then the index of {@code pos} is not\n     * changed, the error index of {@code pos} is set to the index of\n     * the character where the error occurred, and null is returned.\n     * <p>\n     * The subclass returned depends on the value of {@link #isParseBigDecimal}\n     * as well as on the string being parsed.\n     * <ul>\n     *   <li>If {@code isParseBigDecimal()} is false (the default),\n     *       most integer values are returned as {@code Long}\n     *       objects, no matter how they are written: {@code \"17\"} and\n     *       {@code \"17.000\"} both parse to {@code Long(17)}.\n     *       Values that cannot fit into a {@code Long} are returned as\n     *       {@code Double}s. This includes values with a fractional part,\n     *       infinite values, {@code NaN}, and the value -0.0.\n     *       {@code DecimalFormat} does <em>not</em> decide whether to\n     *       return a {@code Double} or a {@code Long} based on the\n     *       presence of a decimal separator in the source string. Doing so\n     *       would prevent integers that overflow the mantissa of a double,\n     *       such as {@code \"-9,223,372,036,854,775,808.00\"}, from being\n     *       parsed accurately.\n     *       <p>\n     *       Callers may use the {@code Number} methods\n     *       {@code doubleValue}, {@code longValue}, etc., to obtain\n     *       the type they want.\n     *   <li>If {@code isParseBigDecimal()} is true, values are returned\n     *       as {@code BigDecimal} objects. The values are the ones\n     *       constructed by {@link java.math.BigDecimal#BigDecimal(String)}\n     *       for corresponding strings in locale-independent format. The\n     *       special cases negative and positive infinity and NaN are returned\n     *       as {@code Double} instances holding the values of the\n     *       corresponding {@code Double} constants.\n     * </ul>\n     * <p>\n     * {@code DecimalFormat} parses all Unicode characters that represent\n     * decimal digits, as defined by {@code Character.digit()}. In\n     * addition, {@code DecimalFormat} also recognizes as digits the ten\n     * consecutive characters starting with the localized zero digit defined in\n     * the {@code DecimalFormatSymbols} object.\n     *\n     * @param text the string to be parsed\n     * @param pos  A {@code ParsePosition} object with index and error\n     *             index information as described above.\n     * @return     the parsed value, or {@code null} if the parse fails\n     * @throws     NullPointerException if {@code text} or\n     *             {@code pos} is null.\n     ",
    "links" : [ "java.math.BigDecimal#BigDecimal(String)", "#isParseBigDecimal" ]
  }, {
    "name" : "public DecimalFormatSymbols getDecimalFormatSymbols()",
    "returnType" : "DecimalFormatSymbols",
    "comment" : "\n     * Returns a copy of the decimal format symbols, which is generally not\n     * changed by the programmer or user.\n     * @return a copy of the desired DecimalFormatSymbols\n     * @see java.text.DecimalFormatSymbols\n     ",
    "links" : [ ]
  }, {
    "name" : "public void setDecimalFormatSymbols(DecimalFormatSymbols newSymbols)",
    "returnType" : "void",
    "comment" : "\n     * Sets the decimal format symbols, which is generally not changed\n     * by the programmer or user.\n     * @param newSymbols desired DecimalFormatSymbols\n     * @see java.text.DecimalFormatSymbols\n     ",
    "links" : [ ]
  }, {
    "name" : "public String getPositivePrefix()",
    "returnType" : "String",
    "comment" : "\n     * Get the positive prefix.\n     * <P>Examples: +123, $123, sFr123\n     *\n     * @return the positive prefix\n     ",
    "links" : [ ]
  }, {
    "name" : "public void setPositivePrefix(String newValue)",
    "returnType" : "void",
    "comment" : "\n     * Set the positive prefix.\n     * <P>Examples: +123, $123, sFr123\n     *\n     * @param newValue the new positive prefix\n     ",
    "links" : [ ]
  }, {
    "name" : "public String getNegativePrefix()",
    "returnType" : "String",
    "comment" : "\n     * Get the negative prefix.\n     * <P>Examples: -123, ($123) (with negative suffix), sFr-123\n     *\n     * @return the negative prefix\n     ",
    "links" : [ ]
  }, {
    "name" : "public void setNegativePrefix(String newValue)",
    "returnType" : "void",
    "comment" : "\n     * Set the negative prefix.\n     * <P>Examples: -123, ($123) (with negative suffix), sFr-123\n     *\n     * @param newValue the new negative prefix\n     ",
    "links" : [ ]
  }, {
    "name" : "public String getPositiveSuffix()",
    "returnType" : "String",
    "comment" : "\n     * Get the positive suffix.\n     * <P>Example: 123%\n     *\n     * @return the positive suffix\n     ",
    "links" : [ ]
  }, {
    "name" : "public void setPositiveSuffix(String newValue)",
    "returnType" : "void",
    "comment" : "\n     * Set the positive suffix.\n     * <P>Example: 123%\n     *\n     * @param newValue the new positive suffix\n     ",
    "links" : [ ]
  }, {
    "name" : "public String getNegativeSuffix()",
    "returnType" : "String",
    "comment" : "\n     * Get the negative suffix.\n     * <P>Examples: -123%, ($123) (with positive suffixes)\n     *\n     * @return the negative suffix\n     ",
    "links" : [ ]
  }, {
    "name" : "public void setNegativeSuffix(String newValue)",
    "returnType" : "void",
    "comment" : "\n     * Set the negative suffix.\n     * <P>Examples: 123%\n     *\n     * @param newValue the new negative suffix\n     ",
    "links" : [ ]
  }, {
    "name" : "public int getMultiplier()",
    "returnType" : "int",
    "comment" : "\n     * Gets the multiplier for use in percent, per mille, and similar\n     * formats.\n     *\n     * @return the multiplier\n     * @see #setMultiplier(int)\n     ",
    "links" : [ ]
  }, {
    "name" : "public void setMultiplier(int newValue)",
    "returnType" : "void",
    "comment" : "\n     * Sets the multiplier for use in percent, per mille, and similar\n     * formats.\n     * For a percent format, set the multiplier to 100 and the suffixes to\n     * have '%' (for Arabic, use the Arabic percent sign).\n     * For a per mille format, set the multiplier to 1000 and the suffixes to\n     * have '&#92;u2030'.\n     *\n     * <P>Example: with multiplier 100, 1.23 is formatted as \"123\", and\n     * \"123\" is parsed into 1.23.\n     *\n     * @param newValue the new multiplier\n     * @see #getMultiplier\n     ",
    "links" : [ ]
  }, {
    "name" : "public void setGroupingUsed(boolean newValue)",
    "returnType" : "void",
    "comment" : "\n     * {@inheritDoc}\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean isGroupingUsed()",
    "returnType" : "boolean",
    "comment" : "\n     * {@inheritDoc}\n     ",
    "links" : [ ]
  }, {
    "name" : "public int getGroupingSize()",
    "returnType" : "int",
    "comment" : "\n     * Return the grouping size. Grouping size is the number of digits between\n     * grouping separators in the integer portion of a number.  For example,\n     * in the number \"123,456.78\", the grouping size is 3. Grouping size of\n     * zero designates that grouping is not used, which provides the same\n     * formatting as if calling {@link #setGroupingUsed(boolean)\n     * setGroupingUsed(false)}.\n     *\n     * @return the grouping size\n     * @see #setGroupingSize\n     * @see java.text.NumberFormat#isGroupingUsed\n     * @see java.text.DecimalFormatSymbols#getGroupingSeparator\n     ",
    "links" : [ "#setGroupingUsed(boolean)" ]
  }, {
    "name" : "public void setGroupingSize(int newValue)",
    "returnType" : "void",
    "comment" : "\n     * Set the grouping size. Grouping size is the number of digits between\n     * grouping separators in the integer portion of a number.  For example,\n     * in the number \"123,456.78\", the grouping size is 3. Grouping size of\n     * zero designates that grouping is not used, which provides the same\n     * formatting as if calling {@link #setGroupingUsed(boolean)\n     * setGroupingUsed(false)}.\n     * <p>\n     * The value passed in is converted to a byte, which may lose information.\n     * Values that are negative or greater than\n     * {@link java.lang.Byte#MAX_VALUE Byte.MAX_VALUE}, will throw an\n     * {@code IllegalArgumentException}.\n     *\n     * @param newValue the new grouping size\n     * @see #getGroupingSize\n     * @see java.text.NumberFormat#setGroupingUsed\n     * @see java.text.DecimalFormatSymbols#setGroupingSeparator\n     * @throws IllegalArgumentException if {@code newValue} is negative or\n     *          greater than {@link java.lang.Byte#MAX_VALUE Byte.MAX_VALUE}\n     ",
    "links" : [ "java.lang.Byte#MAX_VALUE", "#setGroupingUsed(boolean)" ]
  }, {
    "name" : "public boolean isDecimalSeparatorAlwaysShown()",
    "returnType" : "boolean",
    "comment" : "\n     * Allows you to get the behavior of the decimal separator with integers.\n     * (The decimal separator will always appear with decimals.)\n     * <P>Example: Decimal ON: 12345 &rarr; 12345.; OFF: 12345 &rarr; 12345\n     *\n     * @return {@code true} if the decimal separator is always shown;\n     *         {@code false} otherwise\n     ",
    "links" : [ ]
  }, {
    "name" : "public void setDecimalSeparatorAlwaysShown(boolean newValue)",
    "returnType" : "void",
    "comment" : "\n     * Allows you to set the behavior of the decimal separator with integers.\n     * (The decimal separator will always appear with decimals.)\n     * <P>Example: Decimal ON: 12345 &rarr; 12345.; OFF: 12345 &rarr; 12345\n     *\n     * @param newValue {@code true} if the decimal separator is always shown;\n     *                 {@code false} otherwise\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean isParseBigDecimal()",
    "returnType" : "boolean",
    "comment" : "\n     * Returns whether the {@link #parse(java.lang.String, java.text.ParsePosition)}\n     * method returns {@code BigDecimal}. The default value is false.\n     *\n     * @return {@code true} if the parse method returns BigDecimal;\n     *         {@code false} otherwise\n     * @see #setParseBigDecimal\n     * @since 1.5\n     ",
    "links" : [ "#parse(java.lang.String" ]
  }, {
    "name" : "public void setParseBigDecimal(boolean newValue)",
    "returnType" : "void",
    "comment" : "\n     * Sets whether the {@link #parse(java.lang.String, java.text.ParsePosition)}\n     * method returns {@code BigDecimal}.\n     *\n     * @param newValue {@code true} if the parse method returns BigDecimal;\n     *                 {@code false} otherwise\n     * @see #isParseBigDecimal\n     * @since 1.5\n     ",
    "links" : [ "#parse(java.lang.String" ]
  }, {
    "name" : "public boolean isParseIntegerOnly()",
    "returnType" : "boolean",
    "comment" : "\n     * {@inheritDoc}\n     ",
    "links" : [ ]
  }, {
    "name" : "public void setParseIntegerOnly(boolean value)",
    "returnType" : "void",
    "comment" : "\n     * {@inheritDoc}\n     ",
    "links" : [ ]
  }, {
    "name" : "public Object clone()",
    "returnType" : "Object",
    "comment" : "\n     * Standard override; no change in semantics.\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean equals(Object obj)",
    "returnType" : "boolean",
    "comment" : "\n     * Overrides equals\n     ",
    "links" : [ ]
  }, {
    "name" : "private boolean compareIcuRoundingIncrement(android.icu.text.DecimalFormat other)",
    "returnType" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public int hashCode()",
    "returnType" : "int",
    "comment" : "\n     * Overrides hashCode\n     ",
    "links" : [ ]
  }, {
    "name" : "public String toPattern()",
    "returnType" : "String",
    "comment" : "\n     * Synthesizes a pattern string that represents the current state\n     * of this Format object.\n     *\n     * @return a pattern string\n     * @see #applyPattern\n     ",
    "links" : [ ]
  }, {
    "name" : "public String toLocalizedPattern()",
    "returnType" : "String",
    "comment" : "\n     * Synthesizes a localized pattern string that represents the current\n     * state of this Format object.\n     *\n     * @return a localized pattern string\n     * @see #applyPattern\n     ",
    "links" : [ ]
  }, {
    "name" : "public void applyPattern(String pattern)",
    "returnType" : "void",
    "comment" : "\n     * Apply the given pattern to this Format object.  A pattern is a\n     * short-hand specification for the various formatting properties.\n     * These properties can also be changed individually through the\n     * various setter methods.\n     * <p>\n     * There is no limit to integer digits set\n     * by this routine, since that is the typical end-user desire;\n     * use setMaximumInteger if you want to set a real value.\n     * For negative numbers, use a second pattern, separated by a semicolon\n     * <P>Example {@code \"#,#00.0#\"} &rarr; 1,234.56\n     * <P>This means a minimum of 2 integer digits, 1 fraction digit, and\n     * a maximum of 2 fraction digits.\n     * <p>Example: {@code \"#,#00.0#;(#,#00.0#)\"} for negatives in\n     * parentheses.\n     * <p>In negative patterns, the minimum and maximum counts are ignored;\n     * these are presumed to be set in the positive pattern.\n     *\n     * @param pattern a new pattern\n     * @throws    NullPointerException if {@code pattern} is null\n     * @throws    IllegalArgumentException if the given pattern is invalid.\n     ",
    "links" : [ ]
  }, {
    "name" : "public void applyLocalizedPattern(String pattern)",
    "returnType" : "void",
    "comment" : "\n     * Apply the given pattern to this Format object.  The pattern\n     * is assumed to be in a localized notation. A pattern is a\n     * short-hand specification for the various formatting properties.\n     * These properties can also be changed individually through the\n     * various setter methods.\n     * <p>\n     * There is no limit to integer digits set\n     * by this routine, since that is the typical end-user desire;\n     * use setMaximumInteger if you want to set a real value.\n     * For negative numbers, use a second pattern, separated by a semicolon\n     * <P>Example {@code \"#,#00.0#\"} &rarr; 1,234.56\n     * <P>This means a minimum of 2 integer digits, 1 fraction digit, and\n     * a maximum of 2 fraction digits.\n     * <p>Example: {@code \"#,#00.0#;(#,#00.0#)\"} for negatives in\n     * parentheses.\n     * <p>In negative patterns, the minimum and maximum counts are ignored;\n     * these are presumed to be set in the positive pattern.\n     *\n     * @param pattern a new pattern\n     * @throws    NullPointerException if {@code pattern} is null\n     * @throws    IllegalArgumentException if the given pattern is invalid.\n     ",
    "links" : [ ]
  }, {
    "name" : "public void setMaximumIntegerDigits(int newValue)",
    "returnType" : "void",
    "comment" : "\n     * Sets the maximum number of digits allowed in the integer portion of a\n     * number.\n     * For formatting numbers other than {@code BigInteger} and\n     * {@code BigDecimal} objects, the lower of {@code newValue} and\n     * 309 is used. Negative input values are replaced with 0.\n     * @see NumberFormat#setMaximumIntegerDigits\n     ",
    "links" : [ ]
  }, {
    "name" : "public void setMinimumIntegerDigits(int newValue)",
    "returnType" : "void",
    "comment" : "\n     * Sets the minimum number of digits allowed in the integer portion of a\n     * number.\n     * For formatting numbers other than {@code BigInteger} and\n     * {@code BigDecimal} objects, the lower of {@code newValue} and\n     * 309 is used. Negative input values are replaced with 0.\n     * @see NumberFormat#setMinimumIntegerDigits\n     ",
    "links" : [ ]
  }, {
    "name" : "public void setMaximumFractionDigits(int newValue)",
    "returnType" : "void",
    "comment" : "\n     * Sets the maximum number of digits allowed in the fraction portion of a\n     * number.\n     * For formatting numbers other than {@code BigInteger} and\n     * {@code BigDecimal} objects, the lower of {@code newValue} and\n     * 340 is used. Negative input values are replaced with 0.\n     * @see NumberFormat#setMaximumFractionDigits\n     ",
    "links" : [ ]
  }, {
    "name" : "public void setMinimumFractionDigits(int newValue)",
    "returnType" : "void",
    "comment" : "\n     * Sets the minimum number of digits allowed in the fraction portion of a\n     * number.\n     * For formatting numbers other than {@code BigInteger} and\n     * {@code BigDecimal} objects, the lower of {@code newValue} and\n     * 340 is used. Negative input values are replaced with 0.\n     * @see NumberFormat#setMinimumFractionDigits\n     ",
    "links" : [ ]
  }, {
    "name" : "public int getMaximumIntegerDigits()",
    "returnType" : "int",
    "comment" : "\n     * Gets the maximum number of digits allowed in the integer portion of a\n     * number.\n     * For formatting numbers other than {@code BigInteger} and\n     * {@code BigDecimal} objects, the lower of the return value and\n     * 309 is used.\n     * @see #setMaximumIntegerDigits\n     ",
    "links" : [ ]
  }, {
    "name" : "public int getMinimumIntegerDigits()",
    "returnType" : "int",
    "comment" : "\n     * Gets the minimum number of digits allowed in the integer portion of a\n     * number.\n     * For formatting numbers other than {@code BigInteger} and\n     * {@code BigDecimal} objects, the lower of the return value and\n     * 309 is used.\n     * @see #setMinimumIntegerDigits\n     ",
    "links" : [ ]
  }, {
    "name" : "public int getMaximumFractionDigits()",
    "returnType" : "int",
    "comment" : "\n     * Gets the maximum number of digits allowed in the fraction portion of a\n     * number.\n     * For formatting numbers other than {@code BigInteger} and\n     * {@code BigDecimal} objects, the lower of the return value and\n     * 340 is used.\n     * @see #setMaximumFractionDigits\n     ",
    "links" : [ ]
  }, {
    "name" : "public int getMinimumFractionDigits()",
    "returnType" : "int",
    "comment" : "\n     * Gets the minimum number of digits allowed in the fraction portion of a\n     * number.\n     * For formatting numbers other than {@code BigInteger} and\n     * {@code BigDecimal} objects, the lower of the return value and\n     * 340 is used.\n     * @see #setMinimumFractionDigits\n     ",
    "links" : [ ]
  }, {
    "name" : "public Currency getCurrency()",
    "returnType" : "Currency",
    "comment" : "\n     * Gets the currency used by this decimal format when formatting\n     * currency values.\n     * The currency is obtained by calling\n     * {@link DecimalFormatSymbols#getCurrency DecimalFormatSymbols.getCurrency}\n     * on this number format's symbols.\n     *\n     * @return the currency used by this decimal format, or {@code null}\n     * @since 1.4\n     ",
    "links" : [ "java.text.DecimalFormatSymbols#getCurrency" ]
  }, {
    "name" : "public void setCurrency(Currency currency)",
    "returnType" : "void",
    "comment" : "\n     * Sets the currency used by this number format when formatting\n     * currency values. This does not update the minimum or maximum\n     * number of fraction digits used by the number format.\n     * The currency is set by calling\n     * {@link DecimalFormatSymbols#setCurrency DecimalFormatSymbols.setCurrency}\n     * on this number format's symbols.\n     *\n     * @param currency the new currency to be used by this decimal format\n     * @throws    NullPointerException if {@code currency} is null\n     * @since 1.4\n     ",
    "links" : [ "java.text.DecimalFormatSymbols#setCurrency" ]
  }, {
    "name" : "public RoundingMode getRoundingMode()",
    "returnType" : "RoundingMode",
    "comment" : "\n     * Gets the {@link java.math.RoundingMode} used in this DecimalFormat.\n     *\n     * @return The {@code RoundingMode} used for this DecimalFormat.\n     * @see #setRoundingMode(RoundingMode)\n     * @since 1.6\n     ",
    "links" : [ "java.math.RoundingMode" ]
  }, {
    "name" : "private static int convertRoundingMode(RoundingMode rm)",
    "returnType" : "int",
    "comment" : " BEGIN Android-added: convertRoundingMode() to convert between Java and ICU RoundingMode enums.",
    "links" : [ ]
  }, {
    "name" : "public void setRoundingMode(RoundingMode roundingMode)",
    "returnType" : "void",
    "comment" : "\n     * Sets the {@link java.math.RoundingMode} used in this DecimalFormat.\n     *\n     * @param roundingMode The {@code RoundingMode} to be used\n     * @see #getRoundingMode()\n     * @throws    NullPointerException if {@code roundingMode} is null.\n     * @since 1.6\n     ",
    "links" : [ "java.math.RoundingMode" ]
  }, {
    "name" : " void adjustForCurrencyDefaultFractionDigits()",
    "returnType" : "void",
    "comment" : "\n     * Adjusts the minimum and maximum fraction digits to values that\n     * are reasonable for the currency's default fraction digits.\n     ",
    "links" : [ ]
  }, {
    "name" : "private void writeObject(ObjectOutputStream stream) throws IOException, ClassNotFoundException",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private void readObject(ObjectInputStream stream) throws IOException, ClassNotFoundException",
    "returnType" : "void",
    "comment" : "\n     * Reads the default serializable fields from the stream and performs\n     * validations and adjustments for older serialized versions. The\n     * validations and adjustments are:\n     * <ol>\n     * <li>\n     * Verify that the superclass's digit count fields correctly reflect\n     * the limits imposed on formatting numbers other than\n     * {@code BigInteger} and {@code BigDecimal} objects. These\n     * limits are stored in the superclass for serialization compatibility\n     * with older versions, while the limits for {@code BigInteger} and\n     * {@code BigDecimal} objects are kept in this class.\n     * If, in the superclass, the minimum or maximum integer digit count is\n     * larger than {@code DOUBLE_INTEGER_DIGITS} or if the minimum or\n     * maximum fraction digit count is larger than\n     * {@code DOUBLE_FRACTION_DIGITS}, then the stream data is invalid\n     * and this method throws an {@code InvalidObjectException}.\n     * <li>\n     * If {@code serialVersionOnStream} is less than 4, initialize\n     * {@code roundingMode} to {@link java.math.RoundingMode#HALF_EVEN\n     * RoundingMode.HALF_EVEN}.  This field is new with version 4.\n     * <li>\n     * If {@code serialVersionOnStream} is less than 3, then call\n     * the setters for the minimum and maximum integer and fraction digits with\n     * the values of the corresponding superclass getters to initialize the\n     * fields in this class. The fields in this class are new with version 3.\n     * <li>\n     * If {@code serialVersionOnStream} is less than 1, indicating that\n     * the stream was written by JDK 1.1, initialize\n     * {@code useExponentialNotation}\n     * to false, since it was not present in JDK 1.1.\n     * <li>\n     * Set {@code serialVersionOnStream} to the maximum allowed value so\n     * that default serialization will work properly if this object is streamed\n     * out again.\n     * </ol>\n     *\n     * <p>Stream versions older than 2 will not have the affix pattern variables\n     * {@code posPrefixPattern} etc.  As a result, they will be initialized\n     * to {@code null}, which means the affix strings will be taken as\n     * literal values.  This is exactly what we want, since that corresponds to\n     * the pre-version-2 behavior.\n     ",
    "links" : [ "java.math.RoundingMode#HALF_EVENRoundingMode.HALF_EVEN" ]
  } ],
  "methodNames" : [ "private void initPattern(String pattern)", "private void updateFieldsFromIcu()", "private static FieldPosition getIcuFieldPosition(FieldPosition fp)", "private static Field toJavaFieldAttribute(AttributedCharacterIterator.Attribute icuAttribute)", "public final StringBuffer format(Object number, StringBuffer toAppendTo, FieldPosition pos)", "public StringBuffer format(double number, StringBuffer result, FieldPosition fieldPosition)", "public StringBuffer format(long number, StringBuffer result, FieldPosition fieldPosition)", "private StringBuffer format(BigDecimal number, StringBuffer result, FieldPosition fieldPosition)", "private StringBuffer format(BigInteger number, StringBuffer result, FieldPosition fieldPosition)", "public AttributedCharacterIterator formatToCharacterIterator(Object obj)", "public Number parse(String text, ParsePosition pos)", "public DecimalFormatSymbols getDecimalFormatSymbols()", "public void setDecimalFormatSymbols(DecimalFormatSymbols newSymbols)", "public String getPositivePrefix()", "public void setPositivePrefix(String newValue)", "public String getNegativePrefix()", "public void setNegativePrefix(String newValue)", "public String getPositiveSuffix()", "public void setPositiveSuffix(String newValue)", "public String getNegativeSuffix()", "public void setNegativeSuffix(String newValue)", "public int getMultiplier()", "public void setMultiplier(int newValue)", "public void setGroupingUsed(boolean newValue)", "public boolean isGroupingUsed()", "public int getGroupingSize()", "public void setGroupingSize(int newValue)", "public boolean isDecimalSeparatorAlwaysShown()", "public void setDecimalSeparatorAlwaysShown(boolean newValue)", "public boolean isParseBigDecimal()", "public void setParseBigDecimal(boolean newValue)", "public boolean isParseIntegerOnly()", "public void setParseIntegerOnly(boolean value)", "public Object clone()", "public boolean equals(Object obj)", "private boolean compareIcuRoundingIncrement(android.icu.text.DecimalFormat other)", "public int hashCode()", "public String toPattern()", "public String toLocalizedPattern()", "public void applyPattern(String pattern)", "public void applyLocalizedPattern(String pattern)", "public void setMaximumIntegerDigits(int newValue)", "public void setMinimumIntegerDigits(int newValue)", "public void setMaximumFractionDigits(int newValue)", "public void setMinimumFractionDigits(int newValue)", "public int getMaximumIntegerDigits()", "public int getMinimumIntegerDigits()", "public int getMaximumFractionDigits()", "public int getMinimumFractionDigits()", "public Currency getCurrency()", "public void setCurrency(Currency currency)", "public RoundingMode getRoundingMode()", "private static int convertRoundingMode(RoundingMode rm)", "public void setRoundingMode(RoundingMode roundingMode)", " void adjustForCurrencyDefaultFractionDigits()", "private void writeObject(ObjectOutputStream stream) throws IOException, ClassNotFoundException", "private void readObject(ObjectInputStream stream) throws IOException, ClassNotFoundException" ],
  "variableNames" : [ "icuDecimalFormat", "serialPersistentFields", "symbols", "maximumIntegerDigits", "minimumIntegerDigits", "maximumFractionDigits", "minimumFractionDigits", "roundingMode", "currentSerialVersion", "DOUBLE_INTEGER_DIGITS", "DOUBLE_FRACTION_DIGITS", "MAXIMUM_INTEGER_DIGITS", "MAXIMUM_FRACTION_DIGITS", "serialVersionUID" ]
}