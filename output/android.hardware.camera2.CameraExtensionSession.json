{
  "filePath" : "/home/maryam/clearblue/files/android-source-35/android/hardware/camera2/CameraExtensionSession.java",
  "packageName" : "android.hardware.camera2",
  "className" : "CameraExtensionSession",
  "comment" : "\n * A camera capture session that enables access to device-specific camera extensions, which\n * often use multi-frame bursts and sophisticated post-process algorithms for image capture.\n *\n * <p>The capture session will be returned after a successful call to\n * {@link CameraDevice#createExtensionSession} as part of the argument\n * in the registered state callback {@link StateCallback#onConfigured}\n * method. </p>\n *\n * <p>Note that CameraExtensionSession is currently limited to a maximum of two output\n * surfaces for continuous repeating and multi-frame processing respectively. Some\n * features such as capture settings will not be supported as the device-specific\n * Extension is allowed to override all capture parameters.</p>\n *\n * <p>Information about support for specific device-specific extensions can be queried\n * from {@link CameraExtensionCharacteristics}. </p>\n ",
  "links" : [ "#onConfigured", "android.hardware.camera2.CameraExtensionCharacteristics", "android.hardware.camera2.CameraDevice#createExtensionSession" ],
  "variables" : [ ],
  "methods" : [ {
    "name" : "public android.hardware.camera2.CameraDevice getDevice()",
    "returnType" : "android.hardware.camera2.CameraDevice",
    "comment" : "\n     * Get the camera device that this session is created for.\n     ",
    "links" : [ ]
  }, {
    "name" : "public int capture(@NonNull CaptureRequest request, @NonNull Executor executor, @NonNull ExtensionCaptureCallback listener) throws CameraAccessException",
    "returnType" : "int",
    "comment" : "\n     * Submit a request for device-specific processing using input\n     * from the camera device, to produce a single high-quality output result.\n     *\n     * <p>Note that single capture requests currently do not support\n     * client parameters except for controls advertised in\n     * {@link CameraExtensionCharacteristics#getAvailableCaptureRequestKeys}.\n     * The rest of the settings included in the request will be entirely overridden by\n     * the device-specific extension. </p>\n     *\n     * <p> If {@link CameraExtensionCharacteristics#isPostviewAvailable} returns\n     * false, the {@link CaptureRequest.Builder#addTarget} will support only one\n     * ImageFormat.YUV_420_888 or ImageFormat.JPEG target surface. {@link CaptureRequest}\n     * arguments that include further targets will cause IllegalArgumentException to be thrown.\n     * If postview is available, {@link CaptureRequest.Builder#addTarget} will support up to two\n     * ImageFormat.YUV_420_888 or ImageFormat.JPEG target surfaces for the still capture and\n     * postview. IllegalArgumentException will be thrown if a postview target is added without\n     * a still capture target, if more than two target surfaces are added, or if the surface\n     * formats for postview and capture are not equivalent.\n     *\n     * <p>Starting with Android {@link android.os.Build.VERSION_CODES#TIRAMISU} single capture\n     * requests will also support the preview {@link android.graphics.ImageFormat#PRIVATE} target\n     * surface. These can typically be used for enabling AF/AE triggers. Do note, that single\n     * capture requests referencing both output surfaces remain unsupported.</p>\n     *\n     * <p>Each request will produce one new frame for one target Surface, set\n     * with the CaptureRequest builder's\n     * {@link CaptureRequest.Builder#addTarget} method.</p>\n     *\n     * <p>Multiple requests can be in progress at once. Requests are\n     * processed in first-in, first-out order.</p>\n     *\n     * <p>Requests submitted through this method have higher priority than\n     * those submitted through {@link #setRepeatingRequest}, and will be\n     * processed as soon as the current repeat processing completes.</p>\n     *\n     * @param request the settings for this capture\n     * @param executor the executor which will be used for invoking the\n     *                 listener.\n     * @param listener The callback object to notify once this request has\n     *                 been processed.\n     * @return int A unique capture sequence ID used by\n     * {@link ExtensionCaptureCallback#onCaptureSequenceCompleted}.\n     * @throws CameraAccessException    if the camera device is no longer\n     *                                  connected or has encountered a fatal error\n     * @throws IllegalStateException    if this session is no longer active,\n     *                                  either because the session was explicitly closed, a new\n     *                                  session has been created or the camera device has been\n     *                                  closed.\n     * @throws IllegalArgumentException if the request targets no Surfaces\n     *                                  or Surfaces that are not configured as outputs for this\n     *                                  session; or the request targets a set of Surfaces that\n     *                                  cannot be submitted simultaneously.\n     ",
    "links" : [ "CaptureRequest.Builder#addTarget", "android.os.Build.VERSION_CODES#TIRAMISU", "android.graphics.ImageFormat#PRIVATE", "#onCaptureSequenceCompleted", "android.hardware.camera2.CameraExtensionCharacteristics#isPostviewAvailable", "#setRepeatingRequest", "android.hardware.camera2.CaptureRequest", "android.hardware.camera2.CameraExtensionCharacteristics#getAvailableCaptureRequestKeys" ]
  }, {
    "name" : "public int setRepeatingRequest(@NonNull CaptureRequest request, @NonNull Executor executor, @NonNull ExtensionCaptureCallback listener) throws CameraAccessException",
    "returnType" : "int",
    "comment" : "\n     * Request endlessly repeating device-specific extension processing of\n     * camera images.\n     *\n     * <p>With this method, the camera device will continually capture images\n     * and process them using the device-specific extension at the maximum\n     * rate possible.</p>\n     *\n     * <p>Note that repeating capture requests currently do not support\n     * client parameters except for controls advertised in\n     * {@link CameraExtensionCharacteristics#getAvailableCaptureRequestKeys}.\n     * The rest of the settings included in the request will be entirely overridden by\n     * the device-specific extension. </p>\n     *\n     * <p>The {@link CaptureRequest.Builder#addTarget} supports only one\n     * target surface. {@link CaptureRequest} arguments that include further\n     * targets will cause IllegalArgumentException to be thrown.</p>\n     *\n     * <p>Repeating requests are a simple way for an application to maintain a\n     * preview or other continuous stream of frames.</p>\n     *\n     * <p>Repeat requests have lower priority than those submitted\n     * through {@link #capture}, so if  {@link #capture} is called when a\n     * repeating request is active, the capture request will be processed\n     * before any further repeating requests are processed.</p>\n     *\n     * <p>To stop the repeating capture, call {@link #stopRepeating}.</p>\n     *\n     * <p>Calling this method will replace any earlier repeating request.</p>\n     *\n     * @param request the request to repeat indefinitely\n     * @param executor the executor which will be used for invoking the\n     *                 listener.\n     * @param listener The callback object to notify every time the\n     *                 request finishes processing.\n     * @return int A unique capture sequence ID used by\n     * {@link ExtensionCaptureCallback#onCaptureSequenceCompleted}.\n     * @throws CameraAccessException    if the camera device is no longer\n     *                                  connected or has encountered a fatal error\n     * @throws IllegalStateException    if this session is no longer active,\n     *                                  either because the session was explicitly closed, a new\n     *                                  session has been created or the camera device has been\n     *                                  closed.\n     * @throws IllegalArgumentException If the request references no\n     *                                  Surfaces or references Surfaces that are not currently\n     *                                  configured as outputs.\n     * @see #capture\n     ",
    "links" : [ "CaptureRequest.Builder#addTarget", "#onCaptureSequenceCompleted", "#stopRepeating", "#capture", "android.hardware.camera2.CaptureRequest", "android.hardware.camera2.CameraExtensionCharacteristics#getAvailableCaptureRequestKeys" ]
  }, {
    "name" : "public void stopRepeating() throws CameraAccessException",
    "returnType" : "void",
    "comment" : "\n     * Cancel any ongoing repeating capture set by\n     * {@link #setRepeatingRequest setRepeatingRequest}. Has no effect on\n     * requests submitted through {@link #capture capture}.\n     *\n     * <p>Any currently in-flight captures will still complete.</p>\n     *\n     * @throws CameraAccessException if the camera device is no longer\n     *                               connected or has  encountered a fatal error\n     * @throws IllegalStateException if this session is no longer active,\n     *                               either because the session was explicitly closed, a new\n     *                               session has been created or the camera device has been closed.\n     * @see #setRepeatingRequest\n     ",
    "links" : [ "#setRepeatingRequest", "#capture" ]
  }, {
    "name" : "public StillCaptureLatency getRealtimeStillCaptureLatency() throws CameraAccessException",
    "returnType" : "StillCaptureLatency",
    "comment" : "\n     * Return the realtime still {@link #capture} latency.\n     *\n     * <p>The estimations will take into account the current environment conditions, the camera\n     * state and will include the time spent processing the multi-frame capture request along with\n     * any additional time for encoding of the processed buffer if necessary.</p>\n     *\n     * @return The realtime still capture latency,\n     * or {@code null} if the estimation is not supported.\n     ",
    "links" : [ "#capture" ]
  }, {
    "name" : "public void close() throws CameraAccessException",
    "returnType" : "void",
    "comment" : "\n     * Close this capture session asynchronously.\n     *\n     * <p>Closing a session frees up the target output Surfaces of the session\n     * for reuse with either a new session, or to other APIs that can draw\n     * to Surfaces.</p>\n     *\n     * <p>Note that creating a new capture session with\n     * {@link android.hardware.camera2.CameraDevice#createCaptureSession} or\n     * {@link android.hardware.camera2.CameraDevice#createExtensionSession}\n     * will close any existing capture session automatically, and call the\n     * older session listener's {@link StateCallback#onClosed} callback.\n     * Using\n     * {@link android.hardware.camera2.CameraDevice#createCaptureSession} or\n     * {@link android.hardware.camera2.CameraDevice#createExtensionSession}\n     * directly without closing is the recommended approach for quickly\n     * switching to a new session, since unchanged target outputs can be\n     * reused more efficiently.</p>\n     *\n     * <p>Once a session is closed, all methods on it will throw an\n     * IllegalStateException, and any repeating requests are\n     * stopped (as if {@link #stopRepeating()} was called).</p>\n     *\n     * <p>Closing a session is idempotent; closing more than once has no\n     * effect.</p>\n     ",
    "links" : [ "#stopRepeating()", "android.hardware.camera2.CameraDevice#createCaptureSession", "#onClosed", "android.hardware.camera2.CameraDevice#createExtensionSession" ]
  } ],
  "methodNames" : [ "public android.hardware.camera2.CameraDevice getDevice()", "public int capture(@NonNull CaptureRequest request, @NonNull Executor executor, @NonNull ExtensionCaptureCallback listener) throws CameraAccessException", "public int setRepeatingRequest(@NonNull CaptureRequest request, @NonNull Executor executor, @NonNull ExtensionCaptureCallback listener) throws CameraAccessException", "public void stopRepeating() throws CameraAccessException", "public StillCaptureLatency getRealtimeStillCaptureLatency() throws CameraAccessException", "public void close() throws CameraAccessException" ],
  "variableNames" : [ ]
}