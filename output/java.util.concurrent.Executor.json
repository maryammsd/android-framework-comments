{
  "filePath" : "/home/maryam/clearblue/files/android-source-35/java/util/concurrent/Executor.java",
  "packageName" : "java.util.concurrent",
  "className" : "Executor",
  "comment" : "\n * An object that executes submitted {@link Runnable} tasks. This\n * interface provides a way of decoupling task submission from the\n * mechanics of how each task will be run, including details of thread\n * use, scheduling, etc.  An {@code Executor} is normally used\n * instead of explicitly creating threads. For example, rather than\n * invoking {@code new Thread(new RunnableTask()).start()} for each\n * of a set of tasks, you might use:\n *\n * <pre> {@code\n * Executor executor = anExecutor();\n * executor.execute(new RunnableTask1());\n * executor.execute(new RunnableTask2());\n * ...}</pre>\n *\n * However, the {@code Executor} interface does not strictly require\n * that execution be asynchronous. In the simplest case, an executor\n * can run the submitted task immediately in the caller's thread:\n *\n * <pre> {@code\n * class DirectExecutor implements Executor {\n *   public void execute(Runnable r) {\n *     r.run();\n *   }\n * }}</pre>\n *\n * More typically, tasks are executed in some thread other than the\n * caller's thread.  The executor below spawns a new thread for each\n * task.\n *\n * <pre> {@code\n * class ThreadPerTaskExecutor implements Executor {\n *   public void execute(Runnable r) {\n *     new Thread(r).start();\n *   }\n * }}</pre>\n *\n * Many {@code Executor} implementations impose some sort of\n * limitation on how and when tasks are scheduled.  The executor below\n * serializes the submission of tasks to a second executor,\n * illustrating a composite executor.\n *\n * <pre> {@code\n * class SerialExecutor implements Executor {\n *   final Queue<Runnable> tasks = new ArrayDeque<>();\n *   final Executor executor;\n *   Runnable active;\n *\n *   SerialExecutor(Executor executor) {\n *     this.executor = executor;\n *   }\n *\n *   public synchronized void execute(Runnable r) {\n *     tasks.add(() -> {\n *       try {\n *         r.run();\n *       } finally {\n *         scheduleNext();\n *       }\n *     });\n *     if (active == null) {\n *       scheduleNext();\n *     }\n *   }\n *\n *   protected synchronized void scheduleNext() {\n *     if ((active = tasks.poll()) != null) {\n *       executor.execute(active);\n *     }\n *   }\n * }}</pre>\n *\n * The {@code Executor} implementations provided in this package\n * implement {@link ExecutorService}, which is a more extensive\n * interface.  The {@link ThreadPoolExecutor} class provides an\n * extensible thread pool implementation. The {@link Executors} class\n * provides convenient factory methods for these Executors.\n *\n * <p>Memory consistency effects: Actions in a thread prior to\n * submitting a {@code Runnable} object to an {@code Executor}\n * <a href=\"package-summary.html#MemoryVisibility\"><i>happen-before</i></a>\n * its execution begins, perhaps in another thread.\n *\n * @since 1.5\n * @author Doug Lea\n ",
  "links" : [ "java.util.concurrent.ThreadPoolExecutor", "Runnable", "java.util.concurrent.ExecutorService", "java.util.concurrent.Executors" ],
  "variables" : [ ],
  "methods" : [ {
    "name" : " void execute(Runnable command)",
    "returnType" : "void",
    "comment" : "\n     * Executes the given command at some time in the future.  The command\n     * may execute in a new thread, in a pooled thread, or in the calling\n     * thread, at the discretion of the {@code Executor} implementation.\n     *\n     * @param command the runnable task\n     * @throws RejectedExecutionException if this task cannot be\n     * accepted for execution\n     * @throws NullPointerException if command is null\n     ",
    "links" : [ ]
  } ],
  "methodNames" : [ " void execute(Runnable command)" ],
  "variableNames" : [ ]
}